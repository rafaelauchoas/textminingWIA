Artificial Intelligence 248 (2017) 123–157Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintFrom model checking to equilibrium checking: Reactive modules for rational verificationJulian Gutierrez, Paul Harrenstein, Michael Wooldridge∗Department of Computer Science, University of Oxford, United Kingdoma r t i c l e i n f oa b s t r a c tArticle history:Received 2 July 2015Received in revised form 2 April 2017Accepted 8 April 2017Available online 12 April 2017Keywords:Complexity of equilibriaReactive modulesTemporal logicModel checking is the best-known and most successful approach to formally verifying that systems satisfy specifications, expressed as temporal logic formulae. In this article, we develop the theory of equilibrium checking, a related but distinct problem. Equilibrium checking is relevant for multi-agent systems in which system components (agents) are assumed to be acting rationally in pursuit of delegated goals, and is concerned with understanding what temporal properties hold of such systems under the assumption that agents select strategies in equilibrium. The formal framework we use to study this problem assumes agents are modelled using Reactive Modules, a system modelling language that is used in a range of practical model checking systems. Each agent (or player) in a Reactive Modules game is specified as a nondeterministic guarded command program, and each player’s goal is specified with a temporal logic formula that the player desires to see satisfied. A strategy for a player in a Reactive Modules game defines how that player selects enabled guarded commands for execution over successive rounds of the game. For this general setting, we investigate games in which players have goals specified in Linear Temporal Logic (in which case it is assumed that players choose deterministic strategies) and in Computation Tree Logic (in which case players select nondeterministic strategies). For each of these cases, after formally defining the game setting, we characterise the complexity of a range of problems relating to Nash equilibria (e.g., the computation or the verification of existence of a Nash equilibrium or checking whether a given temporal formula is satisfied on some Nash equilibrium). We then go on to show how the model we present can be used to encode, for example, games in which the choices available to players are specified using STRIPS planning operators.© 2017 Elsevier B.V. All rights reserved.1. IntroductionOur main interest in this paper is in the analysis of concurrent systems composed of multiple non-deterministic computer programs, in which at run-time each program resolves its non-determinism rationally and strategically in pursuit of an individual goal, specified as a formula of temporal logic. Since the programs are assumed to be acting strategically, game theory provides a natural collection of analytical concepts for such systems [53]. If we apply game-theoretic analysis to such systems, then the main questions to be answered about such systems are not just “what computations might the system produce?”, but rather, “what computations might the system produce if the constituent programs act rationally?” If we interpret acting rationally to mean choosing strategies (for resolving non-determinism) that are in Nash equilibrium, then * Corresponding author.E-mail address: mjw@cs.ox.ac.uk (M. Wooldridge).http://dx.doi.org/10.1016/j.artint.2017.04.0030004-3702/© 2017 Elsevier B.V. All rights reserved.124J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157this question amounts to asking “which of the possible computations of the system will be produced in equilibrium?” Further, if we use temporal logic as the language for expressing properties of our multi-agent and concurrent system (as is standard in the computer aided verification community [20]), then we can also interpret this question as “which temporal logic formulae are satisfied by computations arising from the selection of strategies in equilibrium?” We refer to this general problem as equilibrium checking [75].Related questions have previously been considered within computer science and artificial intelligence – see e.g., [14,23,29,30,51,13,8]. However, a common feature in this previous work is that the computational models used as the basis for analysis are highly abstract, and in particular are not directly based on real-world programming models or languages. For example, in [29] the authors define and investigate iterated Boolean games (iBG), a generalisation of Boolean games [36,37], in which each agent exercises unique control over a set of Boolean variables, and system execution proceeds in an infinite sequence of rounds, with each agent selecting a valuation for the variables under their control in each round. Each player has a goal, specified as a formula of Linear Temporal Logic (LTL), which it desires to see achieved. The iterated Boolean games model is simple and natural, and provides a compelling framework with which to pose questions relating to strategic multi-agent interaction in settings where agents have goals specified as logical formulae. However, this model is arguably rather abstract, and is some distance from realistic programming languages and system modelling languages; we discuss such work in more detail in the related work section towards the end of this article.In brief, our main aim is to study a framework without these limitations. Specifically, we study game-like systems in which players are specified using (a subset of) the Reactive Modules language [2], which is widely used as a system modelling language in practical model checking systems such as mocha [4] and Prism [43]. Reactive Modules is intended to support the succinct, high-level specification of concurrent and multi-agent systems. As we will see, Reactive Modulescan readily be used to encode other frameworks for modelling multi-agent systems (such as multi-agent STRIPS planning systems [10]).The remainder of the article is structured as follows:• We begin in the following section by motivating our work in detail, in particular by arguing that the classical notion of system correctness is of limited value in multi-agent systems, and introducing the idea of equilibrium checking as representing a more appropriate framework through which to understand the behaviour of such systems.• We then survey the logics LTL and CTL, and their semantic basis on Kripke structures, present srml – a sublanguage ofReactive Modules that we use throughout the article – and then develop a formal semantics for it.• We then introduce Reactive Modules games, in which the structure of the game (what we call the “arena”) is specified using Reactive Modules, and the preferences of players are specified by associating a temporal (LTL or CTL) goal formula with each player, which defines runs or computation trees that would satisfy the player’s goal.• We then investigate the complexity of various game-theoretic questions in Reactive Modules games, for both the LTL and the CTL settings, and conclude by discussing the complexity and expressiveness of our new framework against the most relevant related work. Table 2 at the end of the paper summarises our findings.• Finally, to demonstrate the wider applicability of our framework, we show how it can be used to capture propositional STRIPS games (cf. [22,12,25]), such as the MA-STRIPS model of Brafman and Domshlak [10].Although largely self-contained, our technical presentation is necessarily terse, and readers may find it useful to have some familiarity with temporal logics [20,18], model checking [16], complexity theory [54], and basic concepts of non-cooperative game theory [53].2. MotivationOur aim in this section is to motivate and introduce the idea of equilibrium checking as a multi-agent systems counter-part to the standard notion of verification and model checking. (Many readers will be familiar with much of this material – we beg their indulgence so that we can tell the story in its entirety.)Correctness and formal verification The correctness problem has been one of the most widely studied problems in computer science over the past fifty years, and remains a topic of fundamental concern to the present day [9]. Broadly speaking, the correctness problem is concerned with checking that computer systems behave as their designer intends. Probably the most important problem studied within the correctness domain is that of formal verification. Formal verification is the problem of checking that a given computer program or system P is correct with respect to a given formal (i.e., mathematical) specification ϕ. We understand ϕ as a description of system behaviours that the designer judges to be acceptable – a program that guarantees to generate a behaviour as described in ϕ is deemed to correctly implement the specification ϕ.A key insight, due to Amir Pnueli, is that temporal logic can be a useful language with which to express formal specifica-tions of system behaviour [56]. Pnueli proposed the use of Linear Temporal Logic (LTL) for expressing desirable properties of computations. LTL extends classical logic with tense operators X (“in the next state. . . ”), F (“eventually. . . ”), G (“always. . . ”), and U (“. . . until . . . ”) [20]. For example, the requirement that a system never enters a “crash” state can naturally be ex-pressed in LTL by a formula G¬crash. If we let (cid:2)P (cid:3) denote the set of all possible computations that may be produced by the program P , and let (cid:2)ϕ(cid:3) denote the set of state sequences that satisfy the LTL formula ϕ, then verification of LTL properties J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157125Fig. 1. Model checking. A model checker takes as input a model, representing a finite state abstraction of a system, together with a claim about the system behaviour, expressed in temporal logic. It then determines whether or not the claim is true of the model or not; most practical model checkers will provide a counter example if not.reduces to the problem of checking whether (cid:2)P (cid:3) ⊆ (cid:2)ϕ(cid:3). Another key temporal formalism is Computation Tree Logic (CTL), which modifies LTL by prefixing tense operators with path quantifiers A (“on all paths. . . ”) and E (“on some path. . . ”). While LTL is suited to reasoning about runs or computational histories, CTL is suited to reasoning about transition systems that encode all possible system behaviours.Model checking The most successful approach to verification using temporal logic specifications is model checking [16]. Model checking starts from the idea that the behaviour of a finite state program P can be represented as a Kripke structure, or transition system K P . Now, Kripke structures can be interpreted as models for temporal logic. So, for example, checking whether a program P satisfies an LTL property ϕ reduces to the problem of checking whether ϕ is satisfied on every path through K P . Checking a CTL specification ϕ is even simpler: the Kripke structure K P is a CTL model, so we simply need to check whether K P |= ϕ holds. For an illustration see Fig. 1. These checks can be efficiently automated for many cases of interest. In the case of CTL, for example, checking whether K P |= ϕ holds can be solved in time O (|K P | · |ϕ|) [15,20]; for LTL, the problem is more complex (PSPACE-complete [20]), but using automata theoretic techniques it can be solved in time |ϕ|) [69], the latter result indicating that such an approach is feasible for small specifications. Since the model O (|K P | · 2checking paradigm was first proposed in 1981, huge progress has been made on extending the range of systems amenable to verification by model checking, and to extending the range of properties that might be checked [16].Multi-agent systems We now turn the class of systems that we will be concerned with in the present paper. The field of multi-agent systems is concerned with the theory and practice of systems containing multiple interacting semi-autonomous software components known as agents [72,62]. Multi-agent systems are generally understood as distinct from conventional distributed or concurrent systems in several respects, but the most important distinction for our purposes is that different agents are assumed to be operating on behalf of different external principals, who delegate their preferences or goals to their agent. Because different agents are “owned” by different principals, there is no assumption that agents will have preferences that are aligned with each other.Correctness in multi-agent systems Now, consider the following question:How should we interpret correctness and formal verification in the context of multi-agent systems?In one sense, this question is easily answered: We can certainly think of a multi-agent system as a collection of interacting non-deterministic computer programs, with non-determinism representing the idea that agents have choices available to them; we can model such a system using any number of readily available model checking systems, which would then allow us to start reasoning about the possible computational behaviours that the system might in principle exhibit. But while such an analysis is entirely legitimate, and might well yield important insights, it nevertheless misses a key part of the story that is relevant in order to understand a multi-agent system. This is because it ignores the fact that agents are assumed to pursue their preferences rationally and strategically. Thus, certain system behaviours that might be possible in principle will never arise in practice because they could not arise from rational choices by agents within the system.126J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157Fig. 2. Equilibrium checking. The key difference to model checking is that we also take as input the preferences of each of the system components, and the key question asked is whether or not the temporal property ϕ holds on some/all equilibria of the system.The classical formulation of correctness does not naturally match the multi-agent system setting because there is no single specification ϕ against which the correctness of a multi-agent system is judged. Instead, the agents within such a system each carry their own specification: an agent is judged to be correct if it acts rationally to achieve its delegated preferences or goals. There is no single standard of correctness by which the system as a whole can be judged, and attempting to apply such a standard does not help to understand the behaviour of the system. So, what should replace the classical notion of correctness in the context of multi-agent systems? We will now argue for the concept of rational verification and equilibrium checking.Rational verification and equilibrium checking We believe (as do many other researchers [52,62]) that game theory provides an appropriate analytical framework for the analysis of multi-agent systems. Originating within economics, game theory is essentially the theory of strategic interaction between self-interested entities [49]. While the mathematical framework of game theory was not developed specifically to study computational settings, it nevertheless seems that the toolkit of analytical concepts it provides can be adapted and applied to multi-agent settings. A game in the sense of game theory is usually understood as an abstract mathematical model of a situation in which self-interested players must make decisions. A game specifies the decision-makers in the game – the players – and the choices available to them – their strategies. For every combination of possible choices by players, the game also specifies what outcome will result, and each player has their own preferences over possible outcomes. A key concern in game theory is to try to understand what the outcomes of a game can or should be, under the assumption that the players within it choose rationally in pursuit of their preferences. To this end, many solution concepts have been proposed, of which Nash equilibrium is probably the best-known. A Nash equilibrium is a collection of choices, one for each participant in the game, such that no player can benefit by unilaterally deviating from this combination of choices. Nash equilibria seem like reasonable candidates for the outcome of a game because to unilaterally move away from a Nash equilibrium would result in that player being worse off – which would clearly not be rational. In general, it could be the case that a given game has no Nash equilibrium, or multiple Nash equilibria.It should be easy to see how this general setup maps to the multi-agent systems setting: players map to the agents within the system, and each player’s preferences are defined as their delegated goals; the choices available to each player correspond to the possible courses of action that may be taken by each agent in the system. Outcomes will correspond to the computations or runs of the system, and agents will have preferences over these runs; they act to try and bring about their most preferred runs.With this in mind, we believe it is natural to think of the following problem as a counterpart to model checking and classical verification. We are given a multi-agent system, and a temporal logic formula ϕ representing a property of interest. We then ask whether ϕ would be satisfied in some run that would arise from a Nash equilibrium collection of choices by agents within the system. We call this equilibrium checking, and refer to the general paradigm as rational verification. For an illustration see Fig. 2. This idea is captured in the following decision problem:E-Nash:Given: Multi-agent system M; temporal formula ϕ.Question: Is it the case that ϕ holds on some computation of M that could arise through the agents in M choosing strategies that form a Nash equilibrium?J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157127The obvious counterpart of this decision problem is A-Nash, which asks whether a temporal formula ϕ is satisfied on allcomputations that could arise as a result of agents choosing strategies that form a Nash equilibrium.A higher-level question is simply whether a system has some Nash equilibria:Non-Emptiness:Given: Multi-agent system M.Question: Does M have some Nash equilibria?A system without any Nash equilibria is inherently unstable: whatever collection of choices we might consider for the agents within it, some player would have preferred to make an alternative choice. Notice that an efficient algorithm for solving E-Nash would imply an efficient algorithm for Non-Emptiness.Finally, we might consider the question of verifying whether a given strategy profile represents a Nash equilibrium:NE-Membership:Given: Multi-agent system M, strategy profile (cid:4)σ .Question: Is (cid:4)σ a Nash equilibrium?The aim of the present article is to formulate and investigate the main computational questions relating to equilibrium checking. In order to be able to study these questions, we need to fix on an appropriate model of multi-agent systems, and also some way of defining preferences for this model. As we noted above, the model of multi-agent systems that we adopt is that of Reactive Modules [2]. Our argument for studying this framework is that it is a well-known, widely studied, and most importantly, widely used framework for modelling concurrent and multi-agent systems [4,67,43]. In short, Reactive Modules represents a realistic computational framework within which to study the questions of interest to us. This leaves the question of how to define preferences. Our approach here is very natural: we assume that preferences are defined by giving each agent a temporal logic goal, which the agent is required to try to accomplish. The use of logically-specified goals is commonplace in AI, and temporal logic itself is widely used as a goal specification language within the AI planning community [25]. Moreover, this approach also fits well with the classic view of correctness, as discussed above, wherein a temporal logic goal can be interpreted as a specification that the agent should satisfy.3. PreliminariesWe will be dealing with logics that extend propositional logic. Thus, these logics are based on a finite set (cid:4) of Boolean variables, and contain the classical connectives “∧” (and), “∨” (or), “¬” (not), “→” (implies), and “↔” (iff), as well as the Boolean constants “(cid:9)” (truth) and “⊥” (falsity). A valuation for propositional logic is given by a subset v ⊆ (cid:4), with the intended interpretation that x ∈ v means that x is true under valuation v, while x (cid:12)∈ v means that x is false under v. For propositional formulae ϕ we write v |= ϕ to mean that ϕ is satisfied by v. Let V ((cid:4)) = 2(cid:4) be the set of all valuations for variables (cid:4); where (cid:4) is clear, we omit reference to it and write V . Let v⊥ = ∅ be the valuation under which all variables are false. Where v ∈ V , we let χv denote the characteristic formula of v, which is satisfied only by the valuation v, that is,(cid:2)(cid:2)χv =x ∧¬x .x∈vx(cid:12)∈v3.1. Kripke structuresWe use Kripke structures [16, p. 14] to model the dynamics of our systems. A Kripke structure K over (cid:4) is given by a tuple K = (S, S 0, R, π ), where S is a finite non-empty set of states with typical element s and R ⊆ S × S is a left total (cid:14)) ∈ R. transition relation on S. Left totality means that for every state s ∈ S, there is another state sMoreover, S 0 ⊆ S is the set of initial states and π : S → V is a valuation function, assigning a valuation π (s) to every s ∈ S. See Fig. 3 for an illustration of a Kripke structure over (cid:4) = {x, y}. Where K = (S, S 0, R, π ) is a Kripke structure over (cid:4), and (cid:7) ⊆ (cid:4), then we denote the restriction of K to (cid:7) by K |(cid:7) , where K |(cid:7) = (S, S 0, R, π |(cid:7) ) is the same as K except that the valuation function π |(cid:7) is defined as follows: π |(cid:7) (s) = π (s) ∩ (cid:7). We say that the size of a Kripke structure K , denoted by |K |, is |S| + |R| + |π |.(cid:14) ∈ S such that (s, sρ = π (ρ[0]), π (ρ[1]), π (ρ[2]), . . . ,3.2. Computation runsA run of a Kripke structure K is a sequence ρ = s0, s1, s2, . . . of states where for all t ∈ N we have (st , st+1) ∈ R. Using square brackets around parameters referring to time points, we let ρ[t] denote the state assigned to time point t ∈ N by run ρ. We say ρ is an s-run if ρ[0] = s. A run ρ of K where ρ[0] ∈ S 0 is referred to as an initial run. Thus, in our example in Fig. 3, s0, s0, s2, s3, s3, s3 . . . and s2, s3, s1, s0, s1, s0, . . . are both runs but only the former is an initial run. Let runs(K , s)128J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157indicates that (cid:14)) ∈ R. The annotations inside the vertices indicate which propositional variables are set to true at the respective state and which are set to false, where, Fig. 3. A Kripke structure with four states, s0, s1, s2, and s3, of which the former two are initial states. An arrow from state s to state s(s, se.g., ¯x indicates that variable x is set to false.(cid:14)be the set of s-runs of K , and let runs(K ) be the set of initial runs of K . Notice that a run ρ ∈ runs(K ) is a sequence of states. Every such sequence induces an infinite sequence ρ ∈ V ω of valuations, given bywhich we also refer to as a computation run. In our example in Fig. 3, we thus find that {x, y}, {x, y}, {x}, ∅, ∅, ∅, . . .is a computation run, whereas, for instance, { y}, {x}, ∅, {x, y}, {x, y}, . . . is not. The set of these sequences, (i.e., sequences of valuations corresponding to runs in runs(K )) we denote by runs(K ).Given (cid:7) ⊆ (cid:4) and ρ : N → V ((cid:4)), we denote the restriction of ρ to (cid:7) by ρ|(cid:7) , i.e., ρ|(cid:7) [t] = ρ[t] ∩ (cid:7) for each t ∈ N. We refer to a finite prefix of a run as a partial run, and denote partial runs by (cid:10), (cid:10)(cid:14), . . . etc. We extend the notations for runs, restrictions of runs, etc., to initial runs, restrictions of partial runs, etc., in the obvious way.3.3. Linear temporal logicWe use the well-known framework of Linear Temporal Logic (LTL) to express properties of runs of our systems [20,46,47]. Formulae of LTL are essentially predicates over infinite sequences of states. LTL extends propositional logic with two modal tense operators, namely, X (“next”) and U (“until”). Formally, the syntax of LTL is defined with respect to a set (cid:4) of Boolean variables as follows:ϕ ::= x | ¬ϕ | ϕ ∨ ϕ | Xϕ | ϕ U ϕwhere x ∈ (cid:4). The remaining classical logical connectives are defined in terms of ¬ and ∨ in the usual way. Two key derived LTL operators are F (“eventually”) and G (“always”), which are defined in terms of U as follows: Fϕ = (cid:9) U ϕ, and Gϕ = ¬F¬ϕ. Given a set of variables (cid:7), let Ltl((cid:7)) be the set of LTL formulae over (cid:7); where the variable set is clear from the context, we write Ltl.We interpret formulae of LTL with respect to pairs (ρ, t) where ρ ∈ V ω is a run and t ∈ N is a temporal index into ρ. Any given LTL formula may be true at none or multiple time points on a run; for example, a formula Xp will be true at a time point t ∈ N on a run ρ if p is true on run ρ at time t + 1. We will write (ρ, t) |= ϕ to mean that ϕ ∈ Ltl is true at time t ∈ N on run ρ. The rules defining when formulae are true (i.e., the semantics of LTL) are defined as follows, where x ∈ (cid:4):iffiff(ρ, t) |= x(ρ, t) |= ¬ϕ(ρ, t) |= ϕ ∨ ψ iff(ρ, t) |= Xϕ(ρ, t) |= ϕ U ψ iffiffx ∈ ρ[t]it is not the case that (ρ, t) |= ϕ(ρ, t) |= ϕ or (ρ, t) |= ψ(ρ, t + 1) |= ϕfor some tfor all t ≤ t(cid:14) ≥ t : both (ρ, t(cid:14) : (ρ, t(cid:14)(cid:14) < t(cid:14)(cid:14)) |= ϕ(cid:14)) |= ψ andIf (ρ, 0) |= ϕ, we write ρ |= ϕ and say that ρ satisfies ϕ. We say that ϕ and ψ are equivalent if for all ρ we have ρ |= ϕif and only if ρ |= ψ . A formula ϕ ∈ Ltl is satisfiable if there is some run satisfying ϕ; moreover, it is satisfied by a Kripke structure K if it is satisfied by all its initial runs, that is, if, and only if, it is satisfied by all ρ ∈ runs(K ). As usual, we say that the size of an LTL formula ϕ, denoted by |ϕ|, is its number of subformulae.3.4. Computation tree logicIn order to express branching-time properties, we use Computation Tree Logic (CTL), a branching temporal logic that extends propositional logic with tense modalities and path quantifiers [20]. Specifically, CTL combines the tense operators XJ. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157129and U with the path quantifiers A and E; the path quantifier A means “on all paths. . . ”, while E means “on some path. . . ”. Formally, given a set (cid:4) of Boolean variables, the syntax of CTL is defined as follows:ϕ ::= x | ¬ϕ | ϕ ∨ ϕ | AXϕ | E(ϕ U ϕ) | A(ϕ U ϕ)where x ∈ (cid:4). Assuming the remaining classical connectives have been defined as usual, we can define the remaining CTL operators as follows:EFϕ = E((cid:9) U ϕ)AFϕ = A((cid:9) U ϕ)EXϕ = ¬AX¬ϕAGϕ = ¬EF¬ϕEGϕ = ¬AF¬ϕLet Ctl((cid:4)) denote the set of CTL formulae over (cid:4); when (cid:4) is clear from the context, we write Ctl. CTL formulae are interpreted with respect to pairs (K , s), where K is a Kripke structure and s is a state in K . We write (K , s) |= ϕ to mean that the CTL formula ϕ ∈ Ctl is satisfied in state s of K . Formally, for Kripke structures K , states s in K , and x ∈ (cid:4), we have:(K , s) |= x(K , s) |= ¬ϕ(K , s) |= ϕ ∨ ψ(K , s) |= AXϕ(K , s) |= E(ϕ U ψ)iffiffiffiffiff(K , s) |= A(ϕ U ψ)iffx ∈ π (s)it is not the case that (K , s) |= ϕ(K , s) |= ϕ or (K , s) |= ψ∀ρ ∈ runs(K , s) : (K , ρ[1]) |= ϕ∃ρ ∈ runs(K , s), ∃t ∈ N such that (K , ρ[t]) |= ψand ∀t(cid:14) ∈ N with 0 ≤ t(cid:14) < t : (K , ρ[t(cid:14)]) |= ϕ∀ρ ∈ runs(K , s), ∃t ∈ N such that (K , ρ[t]) |= ψand ∀t(cid:14) < t : (K , ρ[t]) |= ϕ(cid:14) ∈ N with 0 ≤ tIf (K , s0) |= ϕ for all s0 ∈ S 0, we write K |= ϕ and say that K satisfies ϕ. A CTL formula ϕ is satisfiable if K |= ϕ for some K . We say that ϕ and ψ are equivalent if K |= ϕ iff K |= ψ , for all K . We also say that the size of a CTL formula ϕ, denoted by |ϕ|, is its number of subformulae.3.5. Computation treesWe sometimes find it convenient to adopt an alternative view of Kripke structures, where we unfold the transition relation R to obtain a computation tree. We now present the associated technical definitions for such unfoldings.First, we assume the standard definitions of a word, string, and prefix of a string. Where w is a finite word over some alphabet, we denote by prefix(w) the set of non-empty prefixes of w. A tree over an alphabet (cid:12) we define by a non-empty set T ⊆ (cid:12)+of non-empty strings over (cid:12), such that(i) T ∩ (cid:12) is a singleton (the root of the tree),(ii) T is closed under non-empty prefixes, i.e., prefix(w) ⊆ T for every w ∈ T , and(iii) w ∈ T implies wa ∈ T for some a ∈ (cid:12).∗The set T then fixes the set of the vertices and there is an edge between vertices w, ww(cid:14) = wa.A state-tree for a Kripke structure K = (S, S 0, R, π ) is a tree κ over S such that (s, s(cid:14) ∈ T for . An s-tree is a state-tree κ with root s (i.e., with s ∈ κ ). Observe that by condition (i) every state-tree is an some w ∈ Ss-tree for exactly one state s in S. If s ∈ S 0, an s-tree is also called an initial state-tree. By trees(K , s) we denote the set of s-trees and by trees(K ) the set of initial state-trees for the Kripke structure K .(cid:14)) ∈ R whenever ws, wss(cid:14) ∈ T iff there is an a ∈ (cid:12) such that By a computation tree we understand a tree on the set V ((cid:4)) of valuations over (cid:4). For (cid:7) ⊆ (cid:4) we have κ|(cid:7) denote the restriction of κ to (cid:7), i.e., for every u ∈ T , κ|(cid:7) (u) = κ(u) ∩ (cid:7). Notice that every state-tree κ for a Kripke structure K induces a computation tree κ such thatκ = {π (s0) . . . π (sk) : s1 . . . sk ∈ κ}.In such a case κ is said to be a computation tree for K . If κ is an initial state-tree, the corresponding computation tree κ is said to be an initial computation tree. The set of all initial computation trees for K we denote by trees(K ). We refer to Fig. 4for an illustration of this concept.By an unfolding of K = (S, S 0, R, π ) we understand a maximal initial computation tree of K . Let κ ∈ trees(K ) be an initial state-tree for K such that s0 . . . sk ∈ κ implies s0 . . . sksk+1 ∈ κ for every state sk+1 with sk R sk+1. Then, the corresponding computation tree κ : T → V for K is an unfolding of K . Each initial state s ∈ S 0 induces a unique unfolding. By unfold(K )we denote the set of unfoldings of K .130J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157Fig. 4. The figure on the left is an (initial) state tree for the Kripke structure in Fig. 3. The figure on the right is the corresponding computation tree, where each vertex v 1 . . . vk is labelled with the last element vk , e.g., vertex {x, y}{x}∅ (or xy x ¯y ¯x ¯y) is labelled with ∅ (or ¯x ¯y).4. The simple reactive modules languageIn this section, we describe the language we use for modelling multi-agent systems: the Simple Reactive Modules Language(srml). This language is a subset of the Reactive Modules Language (rml [2]) that is widely used in model checkers such as Mocha [4] and Prism [43]. The fragment we make use of, known as srml, was introduced by van der Hoek et al. [67] to study the complexity of model checking for the Alternating-time Temporal Logic (ATL) [3]. Our presentation of srml largely follows that in [67], except that while a formal semantics for srml was hinted at in [67], we here give a complete formal semantics for the language, showing how srml-defined systems induce computational runs and Kripke structures.The structures used to define agents in srml are known as modules. An srml module consists of:(i) a n interface, which defines the name of the module and lists the Boolean variables under the control of the module; and(ii) a number of guarded commands, which define the choices available to the module at every state.Guarded commands are of two kinds: those used for initialising the variables under the module’s control (init guarded commands), and those for updating these variables subsequently (update guarded commands). A guarded command has two parts: a condition part (the “guard”) and a corresponding action part, which defines how to update the value of (some of) the variables under the control of a module. The intuitive reading of a guarded command ϕ (cid:2) α is “if the condition ϕis satisfied, then one of the choices available to the module is to execute the action α”. It is important to note that the truth of the guard ϕ does not mean that α will be executed: only that it is enabled for execution – i.e., that it may be chosen.An action α is a sequence of assignment statements. These statements define how (some subset of) the module’s con-trolled variables should be updated if the guarded command is executed. If in some state no guarded command of a given module is enabled, then the values of the variables in that module are assumed to remain unchanged in the next state: the module has no choice.Here is an example of a guarded command:(x ∧ y)(cid:3) (cid:4)(cid:5) (cid:6)guard(cid:2) x(cid:3)(cid:14) := ⊥; y(cid:4)(cid:5)action(cid:14) := (cid:9)(cid:6)The guard is the propositional logic formula x ∧ y, so this guarded command will be enabled in any system state where both variables x and y take the value “(cid:9)”. If the guarded command is chosen for execution, then the effect is that in the next state of the system, the variable x will take value ⊥, while y will take value (cid:9). (The “prime” notation xmeans “the value of variable x after the statement is executed”.)(cid:14)The following example illustrates the concrete syntax for modules:module toggle controls xinit:: (cid:9) (cid:2) x:: (cid:9) (cid:2) xupdate::x (cid:2) x:: ¬x (cid:2) x(cid:14) := (cid:9)(cid:14) := ⊥(cid:14) := ⊥(cid:14) := (cid:9)This module, named toggle, controls a single Boolean variable, x. There are two init guarded commands and two updateguarded commands. (The symbol “::” is a syntactic separator.) The init guarded commands of toggle define two choices for the initialisation of this variable: assign it the value (cid:9) or the value ⊥. With respect to update guarded commands, the first command says that if x has the value (cid:9), then the corresponding choice is to assign it the value ⊥, while the second command says that if x has the value ⊥, then it can subsequently be assigned the value (cid:9). In other words, the module nondeterministically chooses a value for x initially, and then on subsequent rounds toggles this value. Notice that in this example, the init commands are nondeterministic, while the update commands are deterministic.J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–1571314.1. Formal definitionWe now give a formal definition of the semantics of srml. Formally, a guarded command g over Boolean variables (cid:4) is an expression(cid:14)ϕ (cid:2) x1(cid:14):= ψ1; · · · ; xk:= ψkwhere ϕ and every ψi is a propositional logic formula over (cid:4) and each xi is a member of (cid:4). Let guard(g) denote the guardof g. Thus, in the above rule, guard(g) = ϕ. We will require that no variable appears on the left hand side of two assignment (cid:14)(cid:14)statements in the same guarded command, that is, xk are all distinct. The intended interpretation of g is that 1 through xif the propositional formula ϕ evaluates to true against the valuation v corresponding to the current state of the system, then the statement is enabled for execution; executing the statement means evaluating each ψi against the current state vof the system, and setting the corresponding variable xi to the truth value obtained from evaluating ψi in this way. We say that x1, . . . , xk are the controlled variables of g, and denote this set by ctr(g). If none of the guarded commands of a module is enabled, the values of all variables in ctr(g) are left unchanged. In what follows, we will write skip as an abbreviation for the assignment that leaves the value of every variable controlled by a module unchanged.Now, recall that an init guarded command is only used to initialise the values of variables when the system begins execution. Full rml allows for quite sophisticated initialisation schemes, but in srml, it is assumed that the guards to initcommand are “(cid:9)”, i.e., every init command is enabled for execution in the initialisation round of the system. We will also (cid:14) := ψ on the right hand side of an init command, the expressions ψ are simply assume that in the assignment statements xBoolean constants, i.e., either (cid:9) or ⊥. Formally, an srml module, mi , is then defined as a triple:mi = ((cid:4)i, Ii, U i)where:• (cid:4)i ⊆ (cid:4) is the (finite) set of variables controlled by mi ;• Ii is a (finite) set of initialisation guarded commands, such that for all g ∈ Ii , we have ctr(g) ⊆ (cid:4)i ; and• U i is a (finite) set of update guarded commands, such that for all g ∈ U i , we have ctr(g) ⊆ (cid:4)i .An srml arena A is then given by an (n + 2)-tuple:A = (N, (cid:4), m1, . . . , mn),where N = {1, . . . , n} is a set of agents, (cid:4) is a set of Boolean variables, and for each i ∈ N, mi = ((cid:4)i, Ii, U i) is an srmlmodule over (cid:4) that defines the choices available to agent i. We require that {(cid:4)1, . . . , (cid:4)n} forms a partition of (cid:4) (so every variable in (cid:4) is controlled by some agent, and no variable is controlled by more than one agent). For a propositional valuation v ⊆ (cid:4), let v i denote v ∩ (cid:4)i .The size of an srml arena A = (N, (cid:4), m1, . . . , mn), denoted by | A|, is defined to be |m1| + · · · + |mn|, where the size of a module mi , denoted by |mi|, is given by (cid:4)i and the number of guards and assignment statements in such a module, which is polynomially bounded by the number of guarded commands multiplied by the number of variables controlled by mi , that is, polynomially bounded by (|Ii| + |U i|) ∗ |(cid:4)i|.For technical reasons, we introduce for every module mi = ((cid:4)i, Ii, U i) an auxiliary guarded command, gskipigiven by:gskipi=¬guard(g) (cid:2) skip(cid:2)g∈U iskipiThus, executing gleaves all values for the variables in (cid:4)i unchanged.1Given a module mi = ((cid:4)i, Ii, U i) and a valuation v, we define enabledi(v) as the set of update guarded commands that are enabled at v, under the proviso that, if none of the guarded commands in U i is enabled, gskipiwill be. Formally,enabledi(v) = {g ∈ U i ∪ {gskipi} : v |= guard(g)}.Observe that, defined in this way, enabledi(v) is never empty, and will contain gguarded commands in U i is enabled.2skipias the unique element if none of the We now define a function that specifies the semantics of guarded commands. Let g : ϕ (cid:2) x:= ψk be a guarded command in a module mi that controls the variables in (cid:4)i . Then, execi(g, v) denotes the propositional valuation for the variables (cid:4)i that would result from the execution of g on v. Notice that execi(· · ·) only gives a valuation for (cid:14):= ψ1; · · · ; xk(cid:14)1skipiis introduced to facilitate a clear semantical definition of the behaviour of a reactive module if at some point of time none of 1 The command gits update guarded commands are enabled. There are, of course, other ways to resolve this issue. For example, one could also require that U i always contains g2 Recall that all initial guarded commands are enabled initially.(or one could give a considerably more complicated definition of execi (gi , v) than the one given in the main text).skipi132J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157module mi controls xmodule m j controls yinit:: (cid:9) (cid:2) x:: (cid:9) (cid:2) x(cid:14) := (cid:9)(cid:14) := ⊥(g1i )(g2i )init:: (cid:9) (cid:2) y(cid:14) := (cid:9)(g1j )update:: x ∧ y (cid:2) xy (cid:2) x::x (cid:2) x::(cid:14) := (cid:9) (g3i )(cid:14) := ¬x(g4i )(cid:14) := y(g5i )update:: x ↔ y (cid:2) yx ∨ y (cid:2) y::::(cid:9) (cid:2) skip(cid:14) := (cid:9) (g2j )(cid:14) := ¬x(g3j )(g4j )Fig. 5. The reactive modules mi and m j used in Example 1.the variables (cid:4)i controlled by mi ; it does not specify the value of variables controlled by other modules. Formally, the (cid:14)function execi(· · ·) is defined for guarded command g = ϕ (cid:2) x1execi(g, v) = (v i \ ctr(g)) ∪ {xi ∈ {x1, . . . , xk} : v |= ψi}.:= ψk and valuation v as follows:(cid:14):= ψ1; · · · ; xkThe behaviour of an srml arena is obtained by executing enabled guarded commands, one for each module, in a syn-chronous and concurrent way. A joint guarded command J = (g1, . . . , gn) is a profile of guarded commands, one for each module. We extend the notations from guarded commands to joint guarded commands in the obvious way. In particular we writeenabled(v) = enabled1(v) × · · · × enabledn(v).Moreover, we useexec( J , v) = exec1(g1, v) ∪ · · · ∪ execn(gn, v)to denote the execution of a joint guarded command J = (g1, . . . , gn) at valuation v. Then, the deterministic execution of an srml arena proceeds in rounds. In the first round, the choices available to a module mi correspond to the initialisation guarded commands Ii of mi ; the module selects one of these for execution; call this guarded command gi . The result is defined to be execi(gi, v⊥). The collection of choices made by all players then defines the of the choice made by miinitial valuation that appears in the run. In subsequent rounds, the choices available to a module mi correspond to the update guarded commands that are enabled for execution by the valuation that was produced on the previous round. Again, each player selects one such enabled guarded command for execution, and the collective result of these choices defines the next valuation that appears in the run, and so on. More formally, the deterministic execution of an srml arena A =(N, (cid:4), m1, . . . , mn) produces a run ρ : N → V such that, for some joint guarded command J ∈ I1 × · · · × In, we have ρ[0] =exec( J , v⊥) and, for all t > 0, there is some joint command J ∈ enabled(ρ[t − 1]) with ρ[t] = exec( J , ρ[t − 1]). An srmlarena A may allow different runs, depending on which joint guarded commands are selected for execution, and the set of runs an arena A permits we will denote by runs( A).An srml arena A = (N, (cid:4), m1, . . . , mn) can also be executed nondeterministically, in which case it produces a computation tree κ . For any such computation tree there is some joint initial guarded command J ∈ I1 × · · · × In, such that exec( J , v⊥) ∈κ and, for all v 0 . . . vk and v 0 . . . vk vk+1 in κ , there is some enabled J in enabled(vk) with exec( J , vk) = vk+1. An arena Amay allow multiple computation trees, and the set of computation trees an arena A allows we denote by trees( A). Since bisimilar trees satisfy the same set of both LTL and CTL formulae, to simplify the presentation of our results we may allow trees( A) – and trees(K ), with K a Kripke structure – to be closed under bisimulation [38].To illustrate these concepts, consider the following example of an SRML arena.Example 1. Let (cid:4) = {x, y} and consider the srml arenaA = ({i, j}, {x, y}, mi, m j),where agent i controls x and agent j controls y and mi and m j are further specified as in Fig. 5. Thus,enabledi({x, y}) = U ienabledi( {x} ) = {g5ienabledi( { y} ) = {g4ienabledi( ∅ ) = {g}}skipienabled j({x, y}) = U jenabled j( {x} ) = {g3enabled j( { y} ) = {g3enabled j( ∅ ) = {g2jj , g4j , g4j , g4jj}}}}Furthermore, observe that exec((g1,j ), ∅) = ∅. It follows that {x, y}, {x}, ∅, ∅, . . . is a run in runs( A). By a similar argument, it can also readily be appreciated g4that the (partial) computation tree in Fig. 4 depicts the initial part of a computation tree contained in trees( A). Fig. 6further illustrates the transitions between valuations that are induced by enabled guarded commands.j ), {x}) = {x}, and exec((gj ), v⊥) = {x, y}, exec((g3j ), {x, y}) = {x}, exec((g5i , g3i , g3i , g1skipiJ. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157133Fig. 6. Graphical depiction of the behaviour of the srml Arena of Example 1. Here, e.g., x ¯y represents {x}, the valuation that sets x to true and y to false. If an edge between valuations v and w is labelled with both a guarded command gkfor player j, then (gkfor player i and a guarded command gmi , gmj ) ∈ enabled(v) and execk(gkj , v) = w.i , gmji4.2. Kripke-based and logic-based semanticsAbove, we have presented a formal semantics for srml, showing how arenas can be executed deterministically (leading to runs), or non-deterministically (leading to computation trees). We now present two further semantics, both of which are used extensively in what follows. In the first, we show how srml arenas induce Kripke structures, while in the second, we see how the semantics of srml arenas can be defined in terms of temporal logic formulae.Whenever an enabled joint guarded command of an srml arena is executed, the system it describes can be seen as transitioning from one state to the next. Moreover, as the set of enabled commands at a state only depends on the set of propositional set to true in that state, states with the same associated valuation can be viewed as identical. Thus, everysrml arena induces a finite Kripke structure. For instance, a comparison with Fig. 6 reveals that the Kripke structure in Fig. 3 models the behaviour of the srml arena of Example 1 in this way.At this point, it is useful to remind ourselves that one of the reasons for using srml specifications is that they allow a succinct representation of models that capture the possible (infinite) computations of a distributed, concurrent, and multi-agent (computer) system. For technical reasons, however, in some cases it is useful to explicitly refer to the Kripke structure – i.e., transition system – that is induced by an arena A = (N, (cid:4), m1, . . . , mn); such a structure we denote by K A , which may in general be exponential in the size of A. Formally, we have:Lemma 2 (Kripke-based semantics). For every arena A, there is a Kripke structure K A of size at most exponential in | A| with the same set of runs and the same set of computation trees, i.e., with:runs( A) = runs(K A) and trees( A) = trees(K A).Likewise, for every Kripke structure K = (S, S 0, R, π ), there exists an srml arena A K containing a single srml module mK = ((cid:4) ∪S, I K , U K ) of linear size with respect to |K | whose runs and computation trees when restricted to (cid:4) are exactly those in K , i.e.,runs(K ) = {ρ|(cid:4) : ρ ∈ runs( A K )} and trees(K ) = {κ|(cid:4) : κ ∈ trees( A K )}.Proof. An algorithm to construct Kripke structures K A for srml arenas A is given in Fig. 12 in the Appendix.To prove the second half of the lemma, we now provide a general explicit construction of an srml module based on a given Kripke structure. Thus, let K = (S, S 0, R, π ) with π : S → V ((cid:4)). Define the srml module mK for the Kripke structure K as in Fig. 7. Observe that this construction introduces new variables, in addition to the variables (cid:4) of the Kripke structure. Specifically, we introduce a new variable for each state of the Kripke structure.3In the module in Fig. 7, sas follows: for each (s, shold. All other states are set to ⊥ to indicate that the system is currently not in those states.:= (cid:9); means that the initial state is s0. In the update rules the transition relation R is modelled as a next state where propositions p, . . .(cid:14)) ∈ R we have a rule indicating that at s we can choose s(cid:14)0(cid:14)To see that the size of mK is linear in the size of K , observe that we have exactly one controlled variable for each state of the Kripke structure as well as exactly one update guarded command for each pair in R. On the other hand, the fact that both K and mK have the same sets of runs and computation trees (when the trees induced by A K are restricted to the variables (cid:4)) immediately follows from the construction in Fig. 7. (cid:3)3 Observant readers will note that in fact, we only need to introduce O (log2much more convoluted.|S| + 1) new variables, but the construction of mK in this case would be 134J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157module mK controls S ∪ (cid:4)init// to indicate in state s0, . . . ∈ S 0 where// propositions p, . . . hold and q, . . . do not(cid:14) := ⊥; . . .:: (cid:9) (cid:2) s(cid:4)(cid:5)(cid:6)(cid:4)\π (s0) = {q,...}(cid:14):= ⊥; . . .:= (cid:9); s1(cid:6)(cid:4)(cid:5)(cid:3)S\{s0} = {s1,...}(cid:14) := (cid:9); . . .; p(cid:3)(cid:6)(cid:4)(cid:5)π (s0) = {p,...}; q(cid:3)(cid:14)0. . .update// to indicate next states s// propositions p, . . . hold and q, . . . do not:: s (cid:2) s(cid:14) ∈ R(s) where(cid:14)(cid:14) := (cid:9); s:= ⊥; . . .i(cid:6)(cid:4)(cid:5)(cid:3)S\{s(cid:14)} = {si ,...}(cid:14) := (cid:9); . . .; p(cid:6)(cid:4)(cid:5)(cid:3)π (s(cid:14)) = {p,...}; q(cid:3)(cid:14) := ⊥; . . .(cid:4)(cid:5)(cid:6)(cid:4)\π (s(cid:14)) = {q,...}. . .Fig. 7. Construction for generating srml modules from Kripke structures.We now present another lemma that will also be useful subsequently. The lemma shows, firstly, that for every arena A, it is possible to define an LTL formula ThLT L( A) that acts as the LTL theory of A, in the sense that the runs satisfying ThLT L( A) are exactly the runs of A. Formally, we have the following result:Lemma 3 (Logic-based semantics). For every arena A of size | A|, there is an LTL formula ThLT L( A) of size polynomial in | A| such that for all ρ : N → 2(cid:4),ρ ∈ runs( A)if and only if ρ |= ThLT L( A).Moreover, ThLT L( A) can be computed in time polynomial in the size of A.Proof. Let A = (N, (cid:4), m1, . . . , mn) be the given arena. We define the formula ThLT L( A) as the conjunction of two formulae, which roughly speaking define the effect of the initialisation and update commands in A, respectively:ThLT L( A) = Init( A) ∧ Update( A).We begin by defining a temporal predicate Unch((cid:7)), which asserts that the variables (cid:7) ⊆ (cid:4) take the same value in the next state that they do in the present state (i.e., they remain unchanged):(cid:2)Unch((cid:7)) =(x ↔ Xx).x∈(cid:7)Then, we define the effect of a single initialisation guarded command.(cid:14)Initi(g = (cid:9) (cid:2) x1(cid:14):= b1; · · · ; xk:= bk) =(cid:7) k(cid:2)l=1(cid:8)∧xl ↔ bl(cid:7) (cid:2)(cid:8)x ↔ ⊥.x∈(cid:4)i \ctr(g)The expression Initi then captures the semantics of initialisation commands (we write ⊕ as an abbreviation of the “exactly one” operator – which is equivalent to the “exclusive-or” operator in the binary case):(cid:9)Initi =Initi(g) =(cid:10)(cid:7)Initi(g) ∧(cid:2)¬Initi(g(cid:14)(cid:8))g∈Iig∈Iig(cid:14)∈Ii \{g}Then:Init( A) =(cid:2)i∈NIniti.Next we define the semantics of update rules. Again, we do this in two parts. We first define the effect of a single update guarded command:(cid:14)Updatei(g = ϕ (cid:2) x1(cid:14):= ψ1; · · · ; xk:= ψk) = ϕ ∧(cid:12)ψl ↔ Xxl∧ Unch((cid:4)i \ ctr(g)).(cid:11)k(cid:2)l=1We then define the overall effect of i’s update commands:⎛⎞Updatei =⎝(cid:2)g∈U i¬guard(g) ∧ Unch((cid:4)i)⎠ ∨(cid:9)g∈U iUpdatei(g).J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157135Finally:Update( A) = G(cid:2)i∈NUpdateiIn order to show that ρ ∈ runs( A) if, and only if, ρ|(cid:4) |= ThLT L( A), one proceeds by induction. Moreover, that ThLT L( A) is polynomial in the size of A immediately follows from the construction of the LTL formula, and that it can be computed in time polynomial in the size of A follows similarly. (cid:3)Hereafter, we will write Th( A) for ThLT L( A). Moreover, we will say that a temporal logic formula ϕ characterises or rep-resents the behaviour of an arena A if ϕ is logically equivalent to Th( A). It should also be easy to see that the constructions of Th( A), for arenas, can be restricted to characterise the behaviour of (subsets of) single modules. In particular, we write Th(mi) for the formula that characterises the behaviour of module mi , and write Th(m−i) for the formula that characterises the behaviour of the set of modules {m j : j ∈ N and i (cid:12)= j}.5. Reactive modules gamesWe can now introduce the game model we work with in the remainder of this article. The games we consider are called reactive modules games (RMGs) and have two components. The first component is an arena: this defines the players in the game, the variables they control, and the choices available to these players in every game state. The arena in an RMG plays a role analogous to that of a game form in conventional game theory [53, p. 201]: while it defines players and their choices, it does not specify the preferences of players. Preferences in RMGs are specified by the second component of an RMG: every player i is assumed to be associated with a goal γi , which in RMGs will be a temporal logic formula. The idea is that players desire to see their goal satisfied. Moreover, as one would expect, they are indifferent between two outcomes that satisfy their goal, and indifferent between outcomes that do not achieve it.Formally, an RMG G is given by a structure:G = ( A, γ1, . . . , γn)where:• A = (N, (cid:4), m1, . . . , mn) is an srml arena with components as defined earlier;• for all i ∈ N, the formula γi is the goal of player i, represented as a temporal logic formula; in what follows, we consider both LTL and CTL as possible goal languages.Games in which all players have goals expressed as LTL formulae are called LTL RMGs, while games in which players have goals expressed as CTL formulae are called CTL RMGs. Both types of game are played by each player i selecting a strategy σithat will define how to make choices over time. In the case of LTL RMGs strategies will be deterministic, whereas for CTL RMGs strategies are non-deterministic. (Formal definitions will be given shortly.) Then, once every player i has selected a strategy σi , a strategy profile (cid:4)σ = (σ1, . . . , σn) results and the game has an outcome, which given the nature of the strategies will be:• A run (an infinite word), denoted by ρ( (cid:4)σ ), for LTL RMGs;• A Kripke structure, denoted by K (cid:4)σ , for CTL RMGs.In either case, the outcome will determine whether or not each player’s goal is or is not satisfied. Recall that LTL formulae are interpreted on runs and CTL formulae on Kripke structures. In order to simplify notation, whenever the game is clear from the context, we will write (cid:4)σ |= ϕ for both ρ( (cid:4)σ ) |= ϕ, if ϕ ∈ Ltl, and K (cid:4)σ |= ϕ, if ϕ ∈ Ctl. Although neither strategies nor outcomes ρ( (cid:4)σ ) and K (cid:4)σ have been formally given yet (defined in the next sections), we are now in a position to define a preference relation (cid:2)i over outcomes for each player i with goal γi . For strategy profiles (cid:4)σ and (cid:4)σ (cid:14), we say that(cid:4)σ (cid:2)i (cid:4)σ (cid:14)if and only if(cid:4)σ (cid:14) |= γi implies (cid:4)σ |= γi.We say that player i strictly prefers outcome σ over σ (cid:14)but not σ (cid:14) (cid:2)i σ , and is indifferent between σ and σ (cid:14)and σ (cid:14) (cid:2)i σ . As defined above, players strictly prefer outcomes that satisfy their goals over out-whenever both σ (cid:2)i σ (cid:14)comes that do not, and will be indifferent otherwise. It can easily be established that the preference relations (cid:2)i satisfy the standard requirements of reflexivity, transitivity, and completeness, so that they can play their conventional role in subsequent game-theoretic definitions (see, e.g., [53, p. 7]). Here, we state the lemma but omit the straightforward proof.if σ (cid:2)i σ (cid:14)Lemma 4. Each relation (cid:2)i , as defined above, is reflexive, transitive, and complete.We now define the standard solution concept of Nash equilibrium for RMGs. For this we need one small additional piece i ) we of notation. Given a strategy profile (cid:4)σ = (σ1, . . . , σi−1, σi, σi+1, . . . , σn) and a strategy σ (cid:14)will denote the strategy profile that is the same as (cid:4)σ except that the strategy for player i is σ (cid:14)i for player i, then by ( (cid:4)σ−i, σ (cid:14)i , that is:136J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157( (cid:4)σ−i, σ (cid:14)i ) = (σ1, . . . , σi−1, σ (cid:14)i , σi+1, . . . , σn).Then (cid:4)σ is said to be a Nash equilibrium of G if for all players i and all strategies σ (cid:14)i for player i, we have(cid:4)σ (cid:2)i ( (cid:4)σ−i, σ (cid:14)i ).Hereafter, we let NE(G) be the set of (pure strategy) Nash equilibria for an RMG G. As is usually the case in game theory, it is possible that NE(G) = ∅ (there are no equilibria), or that NE(G) contains just one, or multiple equilibria; there may even be infinitely many equilibria. If there are no equilibria, then the system is inherently unstable – this is one of the key system properties that we will be interested in checking, in the form of the Non-Emptiness problem, described below. If there are multiple equilibria, then this presents the players in the game with a coordination problem: they need to find some way of fixing on one of the equilibria. One way for players to do this is to look for focal points, that is, equilibria that “stand out” from others in the sense that they have certain distinctive features; see, e.g., [61]. In the RMGs setting, for example, an equilibrium that satisfied the goals of all players might be regarded as particularly distinctive. From the point of view of a system designer, the existence of multiple equilibria may not be an issue if all of these equilibria satisfy certain desirable properties. This is another key computational problem that we study, in the form of the A-Nash decision problem, described below.Before studying LTL and CTL RMGs in detail, we should make explicit some important assumptions that underpin our work. The game-theoretic interpretation that we place on RMGs essentially corresponds to the standard game-theoretic model of non-cooperative strategic form games, and in common with this work, we make two assumptions. First, we assume that the game is common knowledge to all players, i.e., all the players know the arena A and goals γi , and know that other players know this, etc. Second, we assume that all players act rationally, taking into account the fact that all other players act rationally. We emphasise that these are common (although not universal) assumptions in game theory. Dropping them would be an interesting topic for future work, but beyond the present paper.5.1. LTL reactive modules gamesPlayers in an LTL RMG possess LTL goals and choose deterministic strategies. The interaction between (i.e., parallel com-position of) such strategies will determine a unique run of the arena, that is, an infinite sequence of states/valuations, which can be used as the LTL model against which to interpret players’ goals.Let us fix some notation. We will write (cid:4)−i for (cid:4) \ (cid:4)i and let V i (respectively, V −i ) denote the set of valuations to variables in (cid:4)i (respectively, (cid:4)−i ).For LTL RMGs, we model strategies as finite state machines with output – technically, deterministic Moore machines. The input language of such a machine representing a strategy for player i corresponds to the choices of other players, i.e., assignments for variables that other players control, V i , while outputs are variable assignments for the player implementing the strategy, i.e., V i .∗−iRepresenting strategies as finite state machines has a number of advantages. First, as the name suggests, it is a finiterepresentation scheme. A more mathematically abstract representation for strategies would be model them as functions → V i , i.e., functions that map a sequence of choices for other players to a choice for player i. The problem with this f i : Vrepresentation from a computational point of view is that the domain of such functions is infinite, which raises substantial difficulties if we want to study decision problems that take such strategies as input. Second, while it may appear that finite state machine representations are weaker than the more mathematically abstract representation, this is in fact not the case if we are only concerned with players whose goals are expressed as temporal logic formulae. In such cases, all we need are finite state machine strategies: the existence of a “general” strategy for a player that will accomplish a player’s goal implies the existence of a finite state machine strategy that will do the same job. Finally, the use of finite state machine strategies is, in fact, standard in the literature on iterated games [6]. These and related questions are discussed in more detail in [29].Now, given A = (N, (cid:4), m1, . . . , mn), an srml arena, we define a deterministic strategy for module mi = ((cid:4)i, Ii, U i) as a structure σi = (Q i, q0i , δi, τi), where∈ Q i is the initial state,• Q i is a finite and non-empty set of states,• q0i• δi : Q i × V −i → Q i is a transition function, and• τi : Q i → V i is an output function.Note, in particular, that not all strategies for a given module will comply with that module’s specification. For instance, if (cid:14) := ⊥, then a strategy for mi should not prescribe mi to set xi , δi, τi) for module mi is the only guarded command of a module mi has the form (cid:9) (cid:2) xto true under any contingency. Thus, given an arena A = (N, (cid:4), m1, . . . , mn), a strategy σi = (Q i, q0consistent with mi if the following two conditions are satisfied:(i) f or the initial state q0(ii) f or all q, qgi ∈ enabledi(v).i , we have τi(q0i ) = execi(g, v⊥) for some g ∈ I1 × · · · × In, and(cid:14) ∈ Q i and v = v i ∪ v−i ∈ V such that δ(q, v−i) = q(cid:14)and v i = τi(q), we have τi(q(cid:14)) = execi(gi, v) for some J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157137Fig. 8. Three deterministic machine strategies. The states are represented by the vertices. The labels inside the vertices denote the truth values the player sets its propositional variables to when in the corresponding state. An arrow between two vertices indicates a transition the machine makes on reading the choices for the propositional variables controlled by the other players as given by the label.Note that, defined in this way, strategies implicitly have perfect information: the player can completely and correctly perceive the choices of other players in the game. Clearly this is ultimately too strong an assumption in many settings, but it will suffice as a first approximation. Also, we are implicitly assuming strategies have finite memory (although we impose no bounds on memory size).If a strategy σiis consistent with module mi , we simply say that σiis a strategy for mi . Given an srml arena A =(N, (cid:4), m1, . . . , mn), we say that a strategy profile (cid:4)σ = (σ1, . . . , σn) is consistent with A if each σi is consistent with mi . In the remainder of the article, we restrict our attention to consistent strategies, and so from here on, the term “strategy” should be understood to mean “consistent strategy”.Finally, because each strategy σi is deterministic, there is a unique run induced by (cid:4)σ , which we denote by ρ( (cid:4)σ ).Example 5. Consider once more the srml arena of Example 1 and the (deterministic) strategies depicted in Fig. 8. First consider the strategy profile (σi, σ j), which gives rise to the computation run that starts with:{ y}, {x, y}, {x}, ∅, { y}, . . .Here, the machine strategy σi subsequently visits the states q0i , . . . and σ j the states q0j , . . . . Both (cid:14)strategies comply with their respective modules. For instance, the transition δ(qi, ∅) = qi in σi is warranted on basis of the (cid:14)(cid:14) := y. Notice that {x} (cid:12)|= y and, as execi(g5i , i.e., x (cid:2) xi , {x}) = ∅ = τ (qguarded command g5i), condition (ii) above is satisfied. By contrast strategy σ (cid:14)(cid:14)i, { y}) = r0i and observe that g4i , i.e., i does not comply with mi . To see this, consider the transition δ(ri ) = ∅, whereas, as { y} |= ¬xy (cid:2) xand thus execi(g4(cid:14) := ¬x, is the only update guarded command that is enabled at valuation { y}. Yet, τi(r0i , { y}) = {x}, condition (ii) above would require that τi(r0j , q j, q j, q0i , qi, qi, qi ) = {x}.j , q0(cid:14)i, q05.2. CTL reactive modules gamesPlayers in a CTL RMG possess CTL goals and have non-deterministic strategies at their disposal. Intuitively, whereas deterministic strategies can be seen as controllers, which resolve the non-determinism of the system by choosing a single computation path, non-deterministic strategies should be understood as supervisors, which disable undesirable behaviours of the system but leave the remaining choices to be selected/executed in a non-deterministic manner.Thus, whereas a profile (cid:4)σ of deterministic strategies can be associated with a unique and infinite sequence of states/val-uations of the system, a profile of non-deterministic strategies can be associated with a unique and infinite tree of system states/valuations – where only the non-deterministic choices made by (cid:4)σ are left in the tree.The definition of non-deterministic strategies is a simple generalisation of that of deterministic ones, where only the transition function is redefined, as follows: δi : Q i × V −i → 2Q i \ {∅}. Finally, the definitions of outcome (that is, of K (cid:4)σ ), consistency, and Nash equilibrium with respect to profiles (cid:4)σ of consistent non-deterministic strategies are straightforwardly extended.5.3. Example: rational mutual exclusionMutual exclusion algorithms (MEAs) play a fundamental role in distributed computing. As the name suggests, they are designed to ensure mutual exclusion, i.e., that in concurrent settings two processes or agents cannot simultaneously enter a “critical region” (CR). Classic examples of MEAs are Peterson’s algorithm [55], Lamport’s bakery algorithm [44], and Ricart and Agrawala’s improvement of the latter [59]. We now show how such an algorithm can be defined using srml, how it ensures mutual exclusion, and how rational action can moreover guarantee non-starvation. Non-starvation is the desirable property that no process or agent is perpetually denied access to a shared resource; in the context of MEAs, the resource in question is access to the CR.In a ring-based MEA, the agents are organised in a cycle along which a “token” is passed – similar to a distributed implementation of a round-robin scheduler [40]. Possession of the token signifies exclusive permission to enter the CR, i.e., an agent can enter the CR only if she is in possession of the token. The modules in Fig. 9 specify a srml arena138J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157module rbme0 controls x0, y0module rbme1 controls x1, y1module rbme2 controls x2, y2init(cid:14):: (cid:9) (cid:2) x0:= ⊥, y(cid:14)0:= ⊥init(cid:14):: (cid:9) (cid:2) x1:= ⊥, y(cid:14)1:= ⊥init(cid:14):: (cid:9) (cid:2) x2:= ⊥, y(cid:14)2:= (cid:9)update(cid:14):: y2 ∨ x0 (cid:2) x0(cid:14):: y2 ∨ x0 (cid:2) x0:= ⊥:: y0 (cid:2) y(cid:14)0:= (cid:9):= ⊥, y:= (cid:9)(cid:14)0update(cid:14):: y0 ∨ x1 (cid:2) x1(cid:14):: y0 ∨ x1 (cid:2) x1:= ⊥:: y1 (cid:2) y(cid:14)1:= (cid:9):= ⊥, y:= (cid:9)(cid:14)1update(cid:14):: y1 ∨ x2 (cid:2) x2(cid:14):: y1 ∨ x2 (cid:2) x2:= ⊥:: y2 (cid:2) y(cid:14)2:= (cid:9):= ⊥, y:= (cid:9)(cid:14)2Fig. 9. Modules for the ring-based mutual exclusion algorithm.Fig. 10. Kripke structure for the arena Arbme .Table 1Description of the behaviour of the agents with respect to Fig. 10. A (cid:2)-symbol indicates that the respective step can be repeated any number of times.Statex0y0x1y1x2s0s1s2s3s4s5s001000000010000000100000001000000010y21Annotation2 passes token on to agent 00 (cid:2) 0 has token and is in CR00 passes token on to agent 10 (cid:2) 1 has token and is in CR01 passes token on to agent 20 (cid:2) 2 has token and is in CR12 passes token on to agent 0Arbme = ({0, 1, 2}, {x0, x1, x2, y0, y1, y2}, rbme0, rbme1, rbme2),which implements a three-agent distributed ring-based MEA (cf., [17], pp. 474–475). The algorithm easily extends to settings with any finite number of agents.Thus, in Arbme each agent i controls two variables, xi and yi . Variable xi being true means that agent i has the token and enters the CR, whereas yi indicates that agent i has the token and passes it to the next agent i + 1. (We assume arithmetic modulo 3 throughout the example). In the initial state, agent 2 has the token and passes it on to agent 0; no agent is in the CR. On possession of the token, each agent can decide whether to enter the CR or to pass on the token. Once an agent iis in the CR, i.e., if xi is true, it can remain there as long as it suits him. On exiting the CR, i.e., if ¬xi ∧ yi holds, agent iimmediately passes the token on to agent i + 1. The behaviour of the system is described by the modules’ specifications. The Kripke structure for arena Arbme is depicted in Fig. 10 and Table 1 further illustrates the dynamics of the system.Observe that, in every state – and thus at every time and on all runs of Arbme – at most one agent has the token and can enter the CR. Hence, the formula(cid:7)(cid:8)(xi ∨ yi) → (¬xi+1 ∧ ¬ yi+1 ∧ ¬xi+2 ∧ ¬ yi+2)(cid:2)Gi∈{0,1,2}is satisfied, which signifies that the protocol guarantees mutual exclusion.The system, however, still allows for many different runs, some of which are undesirable, e.g., if at some point some agent enters the CR and does not leave it ever afterwards. Such behaviour would violate the desired starvation-free property. This is even the case if we assume that each agent i has as a goal to have the token (and thus the ability to enter the CR) infinitely often, i.e., γi = GF(xi ∨ yi), and we restrict our attention to runs that are sustained by a Nash equilibrium. If all agents adopt a strategy in which they enter the CR and remain there for ever when given the opportunity, a Nash equilibrium results in which two agents can never enter the CR.If, on the other hand, each agent i has as a goal the CTL formula γi = GF¬xi , i.e., to be out of the CR infinitely often, then each of them can guarantee its own goal to be satisfied by simply adopting any strategy according to which it exits the CR after a finite period of time in possession of the token. Thus, no agent will perpetually be excluded from having J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157139the opportunity to enter the CR and each agent rationally follows a starvation-free protocol. Under these preferences, a powerful property of our game-like specification of the ring-based mutual exclusion algorithm is that on all runs that are sustained by a Nash equilibrium, the distributed system is guaranteed to be starvation-free! Thus, safety (mutual exclusion) and starvation-freeness for the distributed system can all be uniformly dealt with within RMGs.5.4. Example: deferred acceptanceThe deferred acceptance algorithm, as proposed in 1962 by David Gale and Lloyd Shapley [24], has been tremendously influential both in theory and in practice. The power of this two-sided allocation scheme lies in its very simplicity and its ramifications have numerous and various practical applications to, e.g., kidney exchange, school choice, and the assignment of doctors to hospitals (also see [60,27,45]).Agents are divided in two disjoint finite groups, m-agents and f-agents, and each agent has preferences over the agents in the other group. The goal is to find a stable matching, that is, a pairing of m-agents and f-agents for which there are no matched pairs (mi, f i) and (m j, f j) such that mi and f j prefer one another to f i and m j , respectively. The deferred acceptance algorithm (DA) is a scheme in which each m-agent proposes to one of his most preferred f-agents. If the offer is accepted the engagement stands until a more preferred m-agent comes along and proposes to f-agent. If the offer is rejected, the m-agent strikes the f-agent from his list and proposes to one of his next most preferred f-agents. The algorithm is guaranteed to terminate and to yield a stable matching.We can model and reason about the DA setting within the RMG framework. We assume there to be m-agents m1, . . . , mk= {xi1, . . . , xik, zi1, . . . , zik}, in the past. = { y1 j, . . . , ykj}, where yi j signifies that f-agent f j provisionally and an equal number of f-agents f 1, . . . , fk. Every m-agent mi controls a set of variables (cid:4)miwhere xi jSimilarly, every f-agent f j controls a set of variables (cid:4) f jaccepts mi ’s proposal.indicates that m-agent mi proposes to f-agent f j , while zi j records that mi has proposed to f jIn our setting, each agent has dichotomous preferences, dividing the agents of the other group into those that are approved and those that are not approved. Let for every m-agent mi the set of indices of approved f-agents be denoted by F i and for every f-agent f j the set of indices of approved m-agents by M j . That is, F i = { j : mi approves f j} and M j = {i : f j approves mi}. The preferences of m-agent mi and f-agent f j are then given byγmi= AFAGγ f j= AFAG(cid:7) (cid:10)(cid:8)yi jj∈F i(cid:7) (cid:10)(cid:8)yi j,i∈M jrespectively, that is, every m-agent wishes to be eventually for ever matched with one of his approved f-agents, and every f-agent with one of her approved m-agents. In our setting with dichotomous preferences, stability means that there is no m-agent mi and no f-agent f j such that f j is one of mi ’s approved f-agents and mi is one of f j ’s approved m-agents, and neither mi is matched to one of his approved f-agents and f j is not matched with one of her approved m-agents. If j ∈ Fmiand i ∈ M j , we say that (i, j) is a blocking pair and let Xdenote the set of blocking pairs. Then,∗ϕstability =(cid:2)(cid:17) (cid:10)(cid:10)(cid:18)yil ∨yljAFAG(i, j)∈ X ∗l∈F il∈M jsignifies that on every computation path eventually stable matchings will obtain for ever after, a desirable property.The execution of the DA algorithm takes place over several rounds. We assume that, in every odd round, m-agents that are not engaged can (non-deterministically) propose to any of the f-agents he has not proposed to before. By contrast, in every even round each of the f-agents can (non-deterministically) engage any m-agent that proposed to her in the previous round or, alternatively, decide to stay with her current fiancé, if any, and remain single otherwise. Observe that once an f-agent is engaged, she will be engaged for ever after, be it not necessarily to the same m-agent. These provisions are laid down by the modules depicted in Fig. 11. It is worth observing that these specifications are independent of the agents’ preferences and that they guarantee that none of the agents will be engaged with more than one agent at any one time.Obviously, ϕstability does not hold in every computation tree of the resulting RMG G DA: an f-agent may very well accept an unfavourable offer and stick to it, even if one of her approved m-agents is rejected by all of his approved f-agents. More surprisingly, ϕstability does hold not even hold in every run that is sustained by a Nash equilibrium. To see this, consider the f 1 and f 2, such that both m-agents approve of f 1, but not of f 2, case with two m-agents, m1 and m2, and two f-agents,and both f-agents approve of m1, but not of m2. Thus, m1 and f i are the only blocking pair. Let, furthermore, m1 and m2adopt strategies in which they propose in the first round to f 2 and f 1, respectively, and f 1 one in which she invariably accepts offers from m2 only. Then, iff 2 accepts f 1’s proposal in the first round, a non-stable matching will prevail ever after, that is, ϕstability will fail to hold forever. Even though m1’s and f 1’s strategies may seem irrational and leads to neither the former’s nor the latter’s goal being satisfied, they cannot offset each others’ folly by choosing another strategy. As, moreover, m2 and f 2 are fully satisfied with the outcome, it follows that the strategy profile described above is a Nash equilibrium.If, however, the situation had been different and all m-agents, rather than wishing to end up with an approved f-agent, weaken their goals to and aim to have at least proposed to all approved f-agents before proposing to a non-approved f-agent, all (non-deterministic) computations sustained by a Nash equilibrium will satisfy ϕstability. To appreciate this, assume that 140J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157module mi controls xi1, . . . , xik, zi1, . . . , zikmodule f j controls y1 j , . . . , ykjinit(cid:14):: (cid:9) (cid:2) xi1:= (cid:9)...(cid:14):: (cid:9) (cid:2) xik:= (cid:9)update:: xi1 (cid:2) zi1 := (cid:9), xi1 := ⊥...(cid:19):: xik (cid:2) zik := (cid:9), xik := ⊥::(cid:14)1≤ j≤k(¬xi j ∧ ¬ yi j ) ∧ ¬zi1 (cid:2) xi1...(cid:19)::(cid:14)1≤ j≤k(¬xi j ∧ ¬ yi j ) ∧ ¬zik (cid:2) xikinit:: (cid:9) (cid:2) skipupdate:: (cid:9) (cid:2) skip:: x1 j (cid:2) y(cid:14)1 j:= (cid:9), y(cid:14)2 j(cid:14):= ⊥, . . . , xkj:= ⊥...:: xkj (cid:2) y(cid:14)1 j:= ⊥, . . . , y(cid:14)k j −1 j:= ⊥, y(cid:14)kj:= (cid:9):= (cid:9):= (cid:9)Fig. 11. Modules for the m-agents mi (left) and f-agents f j (right) for the deferred acceptance setting.some blocking pair mi and f j ends up to be forever unmatched with any of their approved agents. Then, either mi has successfully proposed to an non-approved f-agent before proposing to f j or f j has declined a proposal by mi . In the former case, mi can achieve his goal by diverting to strategy in which he proposes to his approved f-agents before proposing to the other agents. In the latter case,f j would have obtained a better outcome if she had accepted mi ’s proposal and stuck with it.6. Equilibrium analysisIn this section, we study the following game-theoretic decision problems for RMGs:• Realizability: whether a player can guarantee the satisfaction of a temporal formula within a given arena;• Non-emptiness: whether a given game has at least one Nash equilibrium;• NE-membership: whether a strategy profile forms a Nash equilibrium; and• E-Nash and A-Nash: whether a temporal logic formula can be satisfied on some or on all Nash equilibria of a given game.In order to solve the problems above mentioned, we first note that, similar to the case of Kripke structures, any strategy σi for a player i can be specified by an srml module. We will describe the construction of modules for non-deterministic strategies; clearly, the construction for deterministic strategies appears as a, simpler, special case.(cid:14)i) be the module specifying some σi = (Q i, q0i , δi, τi) for a module mi = ((cid:4)i, Ii, U i). With each state qi ∈ Q i , we associate a fresh propositional variable, which, for presentational convenience, we will denote by qi as well. The module m(σi) then controls the variables (cid:4)(cid:14)(cid:14)i of mi(σi) contains a single guarded command:= (cid:4)i ∪ Q i . The init part ILet m(σi) = ((cid:4)(cid:14)(cid:14)i, Ui, Ii(cid:9) (cid:2) q0i:= (cid:9); x1 := (cid:9); · · · ; xk := (cid:9)(cid:4)(cid:5)(cid:6)i ) = {x1, . . . , xk}(cid:3)where τi (q0.(cid:14)i of the module mi(σi) to encode both the output function τi and the transition We then use the update commands Ufunction δi . The update part contains for all valuations v i ∈ v and v−i ∈ V −i and all q, r ∈ Q i such that r ∈ δi(q, v−i) and (cid:19)τi(q) = v i an update guarded command – and recall that we have defined χv =; xk+1 := ⊥; · · · ; xl := ⊥(cid:3)(cid:4)(cid:5)(cid:6)(cid:4)i \ τi(r) = {xk+1, . . . , xl}χv ∧ q (cid:2) q := ⊥; r := (cid:9); x1 := (cid:9); · · · ; xk := (cid:9)(cid:6)(cid:4)(cid:5)τi (r)={x1,...,xk}¬x – given byx∈v x ∧x(cid:12)∈v(cid:19)(cid:3),if q (cid:12)= r, or, otherwise, an update guarded command given by; xk+1 := ⊥; · · · ; xl := ⊥χv ∧ q (cid:2) r := (cid:9); x1 := (cid:9); · · · ; xk := (cid:9)(cid:3)(cid:6)(cid:3)(cid:6)(cid:4)(cid:5)(cid:4)i \ τi (r) = {xk+1, . . . , xl}(cid:4)(cid:5)τi (r) = {x1, . . . , xk}.Note that m(σi) has one initialisation rule and one rule for each transition in δi . Then, m(σi) is of size linear in |σi|. That the behaviour of m(σi) is exactly as the behaviour of σi is obvious from the construction. Moreover, using Lemmas 2and 3, and the fact that the size of m(σi ) is linear in |σi|, analogous results with respect to strategies and strategy profiles are obtained.In particular, given an arena A = (N, (cid:4), m1, . . . , mn) and a strategy σi , we can define the Kripke structure and runs = (N, (cid:4) ∪ Q i,induced by σi on A by replacing mi with m(σi), that is, induced by the semantics of the srml arena Aσim1, . . . , m(σi), . . . , mn). The outcome with respect to some (cid:4)σ , then, is given by the Kripke structure or runs associated with J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157141(cid:20)the srml arena A (cid:4)σ = (N, (cid:4) ∪i∈N Q i, m(σ1), . . . , m(σn)). Since we are interested only in the computation runs and trees with respect to (cid:4) associated with both K (cid:4)σ and A (cid:4)σ , let us write runs(K (cid:4)σ )|(cid:4) for the restriction with respect to (cid:4), that is for the set {ρ|(cid:4) : ρ ∈ runs(K (cid:4)σ )}, and similarly for the set of computation trees. Then, once (cid:4)σ is specified in srml, the following result immediately follows from Lemma 2.Lemma 6 (srml semantics of strategies). Let (cid:4)σ be some strategy profile with respect to an arena A. Then, there are srml modules m(σ1), . . . , m(σn), where each srml module m(σi) is of linear size in |σi| such thatruns(K (cid:4)σ )|(cid:4) = runs( A (cid:4)σ )|(cid:4) and trees(K (cid:4)σ )|(cid:4) = trees( A (cid:4)σ )|(cid:4).Notice that in the case of strategy profiles containing non-deterministic strategies, the behaviour of such strategies is very easily handled by the semantics of the modules: non-determinism is simply captured by the choices that the module representing a particular strategy has at its disposal.Finally, since strategy profiles can be specified (in linear size) as arenas in srml, while preserving their induced sets of runs and computation trees, we can define a temporal logic-based theory for strategy profiles. Note, however, that outcomes of this new arena, A (cid:4)σ , are now with respect to valuations in the set (cid:4) ∪i∈N Q i rather than with respect to valuations in (cid:4) only. One can, nevertheless, restrict outcomes to their projection over valuations in (cid:4). A simple corollary of Lemma 6, using Lemma 3, is the following result.(cid:20)Corollary 7 (Logic theory of strategies). Let A = (N, (cid:4), m1, . . . , mn) be an arena. For every strategy profile (cid:4)σ = (σ1, . . . , σn), of size | (cid:4)σ |, for A there is an LTL formula ThLT L( A (cid:4)σ ), of size polynomial in | (cid:4)σ |, such thatρ|(cid:4) ∈ runs(K (cid:4)σ )|(cid:4) if and only if ρ|(cid:4) |= ThLT L( A (cid:4)σ ).With these results in place, we can now start to investigate the decision problems discussed at the beginning of this section, for both the linear and branching time case.6.1. On the complexity of LTL RMGsThe first problem we study is Realizability for LTL RMGs, which asks whether a player has a strategy to achieve its temporal logic goal with the context of a given arena, no matter how the other agents behave.RealizabilityRMG G, player i, and LTL formula ϕ.Given:Question: Does there exist a strategy σi such thatfor all (cid:4)σ−i it holds that ρ( (cid:4)σ−i, σi) |= ϕ?Proposition 8. Realizability for LTL RMGs is 2EXPTIME-complete. It is 2EXPTIME-hard for 2-player games, and PSPACE-complete for 1-player games.Proof. For membership we reduce Realizability to the synthesis problem with respect to reactive environments, a problem known to be 2EXPTIME-complete for LTL specifications [42]. First, let Th(mi) be an LTL formula characterising the module for player i and let Th(m−i) be an LTL formula characterising the modules of all other players in G – i.e., an LTL formula for the srml system comprising the modules in {m1, . . . , mi−1, mi+1, . . . , mn}. (We do not give the construction for Th(mi), which should be immediate from results given above.) Then, it should be easy to see that the LTL formula ϕ is realizable in the context of LTL srml games if, and only if, the following LTL formula can be synthesised with respect to any reactive environment:Th(mi) ∧ (Th(m−i) → ϕ)provided that the environment (the coalition of players in N \ {i}) controls the variables in (cid:4) \ (cid:4)i and the system (player i) controls the variables in (cid:4)i .Note that since in order to solve the Realizability problem we checked whether the LTL formula Th(mi) ∧ (Th(m−i) → ϕ)can be synthesised, and the size of such a formula is polynomial in the sizes of both the LTL formula ϕ and the game G, then it follows that Realizability is 2EXPTIME in the sizes of both the game G and the input formula ϕ.For hardness, we first reduce LTL games (also called control games for LTL [5]) to an instance of Realizability with 3 players/modules (for the sake of simplicity in the presentation), and then such an instance to a game with only 2 modules. Now, let us introduce LTL games. An LTL game is a two-player zero-sum game given by (G LT L, ϕ, v 0) where ϕ is an LTL formula over a set 2(cid:12) , andG LT L = (V G , V 0, V 1, γ : V → 2V , μ : V → 2(cid:12))142J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157is a graph with vertices in V G which are partitioned in player 0 vertices V 0 and player 1 vertices V 1. The transitions of the graph are given by γ ; if v, which we may assume is (cid:14). Each vertex v has a set of properties P associated to it, which are given by μ; thus P ∈ 2(cid:12) holds in vertex vlabelled by vif P = μ(v). The graph G LT L is assumed to be total: for every v ∈ V G , we have γ (v) (cid:12)= ∅.(cid:14) ∈ V G , then there is a transition from v to v(cid:14) ∈ γ (v), for some v, vThe game is played for infinitely many rounds by each player choosing a successor vertex whenever it is their turn: player 0 plays in vertices in V 0 and player 1 plays in vertices in V 1. The game starts in the initial vertex v 0 ∈ V G . Playing the game defines an infinite sequence of vertices w = v 0, v 1, v 2, . . ., such that for each vk, with k ∈ N, we have vk+1 ∈ γ (vk). An LTL game is won by player 0 if w |= ϕ; otherwise player 1 wins. LTL games are determined, that is, there is always a winning strategy either for player 0 or for player 1. Checking whether player 0 has a winning strategy in an LTL game is a 2EXPTIME-complete problem [5].(cid:14)We construct an LTL RMG with three players m0, m1, and out and show that player 0 has a winning strategy in the LTL game (G LT L, ϕ, v 0) if, and only if, there exists a strategy σ0 for m0 such that for all strategy profiles (cid:4)σ , K ( (cid:4)σ−0, σ0) |= ϕ. The construction given below is similar to the one used in Lemma 2 to translate Kripke transition systems to srml modules. Let us, first, define the following sets of controlled variables:• S 00• S 10• S 01• S 11= {xv : v ∈ V 0}= {xv : v ∈ V 1}= { y v : v ∈ V 0}= { y v : v ∈ V 1}Using the above sets of controlled variables, we can define the following modules.module m0 controls S 00∪ S 10:= (cid:9)init// to indicate that the initial state is v 0(cid:14):: (cid:9) (cid:2) xv0update// for each v ∈ V 0 and w ∈ γ (v) \ {v}:(cid:14)(cid:14):: xv ∨ y v (cid:2) x:= ⊥; xwv// for each v ∈ V 0 with v ∈ γ (v), i.e., for “loops”:(cid:14):: xv ∨ y v (cid:2) xv// for each v ∈ V 1, where player 1 moves:(cid:14):: xv (cid:2) xvmodule m1 controls S 01∪ S 11:= (cid:9):= (cid:9):= ⊥(cid:14)v0:= (cid:9)init// to indicate that the initial state is v 0:: (cid:9) (cid:2) yupdate// for each v ∈ V 1 and w ∈ γ (v) \ {v}:(cid:14):: xv ∨ y v (cid:2) yw// for each v ∈ V 1 with v ∈ γ (v), i.e., for “loops”::: xv ∨ y v (cid:2) y// for each v ∈ V 0, where player 0 moves::: y v (cid:2) y:= ⊥; y:= ⊥:= (cid:9):= (cid:9)(cid:14)v(cid:14)v(cid:14)vmodule out controls (cid:12)init// initialize all propositions in (cid:12) to false, i.e.,:: (cid:9) (cid:2) skipupdate// for each v ∈ V 0 ∪ V 1 and// where μ(v) = {p1, . . . , pk} and (cid:12) \ μ(v) = {q1, . . . , qm}::= (cid:9); q:: xv ∨ y v (cid:2) p:= (cid:9); . . . ; p(cid:14):= ⊥; . . . ; qm:= ⊥(cid:14)1(cid:14)1(cid:14)kNow, see that the runs with respect to out are completely defined by the possible runs of the LTL game. More precisely, we haveruns(out) = {∅; ρ : ρ ∈ runs(G LT L)} .As a consequence, for every formula ψ and run ρ in the LTL game G LT L , there is a strategy profile (cid:4)σ such that the following holds:J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157143ρ |= ψ if and only if K (cid:4)σ |= Xψ .Based on the above facts, we can now show that player 0 has a winning strategy σc in the LTL game (G LT L, ϕ, v 0) if, and only if, there exist a winning strategy σ0 for m0 in the associated srml game, as defined above.(=⇒) First, suppose that player 0 has a winning strategy σc in the given LTL game (G LT L, ϕ, v 0), which can be assumed to be of finite memory. Then, we can use a construction similar to the one given for Lemma 6 to define an srml module, say m(σc), that characterises σc . Because of the definition of the srml game induced by an LTL game, it immediately follows that module m0 has a winning strategy, specified by m(σc), for Xϕ.(⇐=) Now, suppose that the srml module m0 has a winning strategy σ0 in the game ( A, γ0 = Xϕ, γ1 = ¬Xϕ, γout = (cid:9)), with A defined by srml modules as those given above. Then, because σ0 is a finite-memory strategy, it straightforwardly defines a strategy in the LTL game for ϕ.This part of the proof shows that the problem is 2EXPTIME-hard for 3-player games. However, note that out is a deter-ministic module with the trivial goal (cid:9). As a consequence, it can be eliminated from the game. Let G 2 be the game built based on G such that the controlled variables and guarded commands of out are given to player i. It then follows that player i has a strategy σi such that for all (cid:4)σ−i it holds that ρ( (cid:4)σ−i, σi) |= ϕ in G if and only if i has a strategy σ ∗i such that for all (cid:4)σ ∗i ) |= ϕ in G 2. The only if direction is trivial: simply let σ ∗i be the strategy that plays as σi and σout , any strategy for out in G. The if direction is almost just as easy. Consider the contrapositive argument, that is, that if i does not have a strategy to realise ϕ in G 2, then it does not have a strategy to realise ϕ in G. Now, we only have to simply observe that the set of strategies for i in G 2 is a super set of the set of strategies for i in G. Therefore if i does not have a strategy to realise ϕ in G 2, then o does not have such a strategy in G either, which completes the proof of the 2EXPTIME-hardness result in 2-player games.−i it holds that ρ( (cid:4)σ ∗−i, σ ∗Finally consider the case of 1-player games. For membership of PSPACE, consider an arena A and a formula ϕ. We simply need to check whether the LTL formula Th( A) ∧ ϕ is satisfiable, which is clearly in PSPACE. For hardness, we can immediately reduce the LTL satisfiability problem for formulae over one variable; the details are straightforward from the description given above. (cid:3)It is natural to ask whether there are classes of games for which the decision problems we study are easier. While the study of such classes is not the main focus of this paper, there are natural subsets of LTL for which some of the decision problems we discuss are easier. Consider the class of as Objective LTL (OLTL) formulae. Informally, an OLTL formula is one in which no temporal connective occurs within the scope of a classical connective. Thus FGp and p U Gq are OLTL formulae, but p ∧ Xq is not an OLTL formula; the latter is not an OLTL formula because the “X” operator occurs within the scope of the “∧” operator. Formally, the syntax of OLTL formulae is given as follows:ϕ ::= Xϕ | ϕ U ϕ | ψψ ::= x | ¬ψ | ψ ∨ ψNow, we can show:Proposition 9. Realizability for OLTL RMGs is EXPTIME-complete.Proof. We first give an overview. Given an arena A, player i, and target formula ϕ, we start by constructing K A , the Kripke structure induced by A. As we already noted, K A can be computed in time exponential in the size of A. We then use dynamic programming to label each state s of K A with the subformulae of ϕ that i can guarantee to be able to bring about in s. The actual algorithm for this is closely related to the standard explicit state CTL model checking algorithm (see, e.g., [20]). The algorithm cannot be used for this purpose for arbitrary LTL formulae, because of the possibility of temporal operators occurring within the scope of a classical connective. However, the approach works for OLTL formulae. The algorithm operates in time polynomial in the size of K A . Finally, we check whether all initial states of K A are labelled with the target formula ϕ; if the answer is “yes”, then the answer to the Realizability problem is “yes”, otherwise it is “no”. The detailed algorithm is presented in Fig. 13 in the Appendix. For EXPTIME-hardness, we can straightforwardly reduce the problem of determining whether a player has a winning strategy in the game Peek-G 4 (see the proof of Proposition 15, below, for details of the problem). (cid:3)Next, we ask whether a strategy profile is a Nash equilibrium:NE-membershipGiven:Question:RMG G and strategy profile (cid:4)σ .Is it the case that (cid:4)σ ∈ NE(G)?Note that the strategies (cid:4)σ = (σ1, . . . , σn) given in the input to this problem are represented as finite state machines. We assume that they are represented by explicitly enumerating the various components of the finite state machine.144J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157Proposition 10. NE-membership for LTL RMGs is PSPACE-complete. In addition, it is PSPACE-hard even for one-player games and LTL goals over a singleton variable set (cid:4).Proof. For membership in PSPACE we define a procedure that uses two oracles, one for LTL model-checking and one for satisfiability, which are both known to be in PSPACE [63]. The procedure is based on the observation that if the profile (cid:4)σ is a Nash equilibrium, then either ρ( (cid:4)σ ) |= γi or ρ( (cid:4)σ−i, σ (cid:14)i . For hardness, we reduce LTL satisfiability for formulae with one propositional variable [19] to a one-player LTL RMG. Let us first prove membership in PSPACE.i ) (cid:12)|= γi , for every player i and strategy σ (cid:14)Recall that a profile (cid:4)σ of deterministic strategies in an LTL RMG is a pure-strategy Nash equilibrium if and only if for every player i in N,either ρ( (cid:4)σ ) |= γi or ρ( (cid:4)σ−i, σ (cid:14)i ) (cid:12)|= γi for every strategy σ (cid:14)iThus, we can, for every player i, check whetherboth ρ( (cid:4)σ ) (cid:12)|= γi and ρ( (cid:4)σ−i, σ (cid:14)i ) |= γi for some strategy σ (cid:14)i∈ (cid:12)i.∈ (cid:12)i,and conclude (cid:4)σ (cid:12)∈ NE(G) if such a statement holds; otherwise (cid:4)σ ∈ NE(G).Checking ρ( (cid:4)σ ) (cid:12)|= γi can be done in PSPACE. First, use Lemma 6 and Corollary 7 to construct an LTL formula Th( A (cid:4)σ ) that characterises (cid:4)σ . It is not difficult to show that, for all runs ρ that satisfy Th( A (cid:4)σ ), it is the case that ρ|(cid:4) = ρ( (cid:4)σ ). To simplify notation, hereafter, we will write Th( (cid:4)σ ) for Th( A (cid:4)σ ). Such a formula, namely Th( (cid:4)σ ), is polynomial in | (cid:4)σ |.Following the automata-theoretic approach to model checking, we now construct two alternating Büchi word (ABW) automata ATh( (cid:4)σ ) and Aγi which accept exactly all the words that satisfy the formulae Th( (cid:4)σ ) and γi , respectively. Such alternating automata are polynomial in |Th( (cid:4)σ )| and |γi|. We now simply ask whether L(ATh( (cid:4)σ ))|(cid:4) ⊆ L(Aγi ), that is, whether the language accepted by ATh( (cid:4)σ ) and restricted to (cid:4) is included in the language accepted by Aγi . Such a question can be answered in PSPACE. If L(ATh( (cid:4)σ ))|(cid:4) ⊆ L(Aγi ) then ρ( (cid:4)σ ) |= γi ; otherwise ρ( (cid:4)σ ) (cid:12)|= γi . Since PSPACE is a deterministic complexity class, checking ρ( (cid:4)σ ) (cid:12)|= γi is also in PSPACE, as required.On the other hand, checking that ρ( (cid:4)σ−i, σ (cid:14)∈ (cid:12)i can be done using constructions very similar to those used in Lemma 6 and Corollary 7, but in this case we check LTL satisfiability instead. First, let us write Th(m(σ j)) for the LTL formula that characterises σ j , with j ∈ N. Specifically, we check whether the LTL formula γi ∧j∈N\{i} Th(m(σ j)) is satisfiable, which also can be done in PSPACE.(cid:19)Note that since in order to solve the NE-membership problem we checked whether the LTL formula γi ∧j∈N\{i} Th(m(σ j)) is satisfiable, and the size of such a formula is polynomial in the sizes of both the LTL goals γi and the strategies σ j , then it follows that NE-membership is PSPACE in the sizes of both the game G and the input strategy profile (cid:4)σ .i ) |= γi for some σ (cid:14)(cid:19)iNow, for hardness, we reduce the LTL satisfiability problem (which is PSPACE-complete, even for formulae with only one propositional variable [19]) in the same way that is done for iBG [29]. More specifically, we take the class of LTL formulae over one propositional variable and ask whether a given LTL formula ϕ in this class is satisfiable. Because this formula is over only one propositional variable, say p, any model can be produced by an srml module.Then, reasoning as in the proof for iBG [29], we can show that the srml module m, defined below, has a winning strategy to satisfy ϕ ∧ q if, and only if, the formula ϕ is satisfiable. This strategy can be used to build a strategy profile σm that is not a Nash equilibrium if, and only if, ϕ is satisfiable.module m controls p, qinit:: (cid:9) (cid:2) p:: (cid:9) (cid:2) p:: (cid:9) (cid:2) q:: (cid:9) (cid:2) qupdate:: (cid:9) (cid:2) p:: (cid:9) (cid:2) p(cid:14) := (cid:9)(cid:14) := ⊥(cid:14) := (cid:9)(cid:14) := ⊥(cid:14) := (cid:9)(cid:14) := ⊥Now, consider a strategy σm such that q (cid:12)∈ τ (q0). Then, it follows that σm (cid:12)|= ϕ ∧ q. If ϕ is satisfiable then m has a beneficial deviation: switch to a strategy σ (cid:14)m that builds a model for ϕ and such that q ∈ τ (q0). However, if ϕ is not satisfiable, then no strategy for m will satisfy ϕ ∧ q, and hence σm would be a Nash equilibrium in such a case. Note that the reason this reduction works is because the arena where the game is played has constant size (because ϕ is a formula with only one propositional variable). (cid:3)The next problem asks if a game has any Nash equilibrium.Non-emptinessGiven:Question:RMG G.Is it the case that NE(G) (cid:12)= ∅?J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157145Proposition 11. Non-emptiness for LTL RMGs is 2EXPTIME-complete, and it is 2EXPTIME-hard for 2-player games.Proof. For membership in 2EXPTIME, we instantiate the E-Nash problem (described below) with ϕ = (cid:9). For hardness, one can reduce LTL synthesis with two variables, say x and y to a two-player game with five Boolean variables. The reduction takes as input an LTL synthesis game with two players, 1 and 2, and an LTL formula ϕ such that player 1 has a winning strategy in the synthesis game if and only if ϕ can be synthesised; otherwise, player 2 has a winning strategy to show that ¬ϕ can be synthesised – because it is a zero-sum game. Based on this input game, the reduction uses the two modules below and following LTL goals:• γ1 = (¬ϕ → (p ↔ q)) ∧ (ϕ → r)• γ2 = (¬ϕ → ¬(p ↔ q)) ∧ (ϕ → (ϕ ↔ ¬r))where ϕ is an LTL formula over Boolean variables x and y.module m1 controls {x, p, r}init:: (cid:9) (cid:2) x := ⊥; p := ⊥; r := ⊥:: (cid:9) (cid:2) x := ⊥; p := ⊥; r := (cid:9):: (cid:9) (cid:2) x := ⊥; p := (cid:9); r := ⊥:: (cid:9) (cid:2) x := ⊥; p := (cid:9); r := (cid:9):: (cid:9) (cid:2) x := (cid:9); p := ⊥; r := ⊥:: . . .update:: (cid:9) (cid:2) x := ⊥; p := ⊥; r := ⊥:: (cid:9) (cid:2) x := ⊥; p := ⊥; r := (cid:9):: (cid:9) (cid:2) x := ⊥; p := (cid:9); r := ⊥:: (cid:9) (cid:2) x := ⊥; p := (cid:9); r := (cid:9):: (cid:9) (cid:2) x := ⊥; p := ⊥; r := ⊥:: . . .module m2 controls { y, q}init:: (cid:9) (cid:2) y := ⊥; q := ⊥:: (cid:9) (cid:2) y := ⊥; q := (cid:9):: . . .update:: (cid:9) (cid:2) y := ⊥; q := ⊥:: (cid:9) (cid:2) y := ⊥; q := (cid:9):: . . .Given this two-player game, G, it is not hard to check that player 1 has a winning strategy to synthesise ϕ if and only if G has a Nash equilibrium, from which 2EXPTIME-hardness follows.• (⇒) Assume that player 1 has a winning strategy to synthesise ϕ. Then, module m1 can use such a winning strategy to ensure that ϕ holds, while setting r to (cid:9). Then, γ1 is satisfied and m1 will not deviate. On the other hand, in this case, m2 will not have its goal γ2 satisfied, but cannot beneficially deviate since (ϕ → (ϕ ↔ ¬r)) will still be false in every unilateral deviation of m2.• (⇐) We prove the contrapositive statement: assume that player 1 does not have a winning strategy to synthesise ϕand show that in such a case G does not have a Nash equilibrium. Since the game for LTL synthesis is determined and player 1 does not have a winning strategy to synthesise ϕ then we know that player 2 has a winning strategy for ¬ϕ. We will analyse all possible cases and show that in each instance at least one of the players has a beneficial deviation. Let (cid:4)σ = (σ1, σ2) be an arbitrary strategy profile and assume first that (cid:4)σ |= ¬ϕ. Then, if (cid:4)σ |= (p ↔ q) player m2 will have a beneficial deviation. If, on the other hand, (cid:4)σ |= ¬(p ↔ q) then player m1 will have a beneficial deviation. Now, suppose that (cid:4)σ |= ϕ. Then, if (cid:4)σ |= ¬r player m1 will have a beneficial deviation. If, on the other hand, (cid:4)σ |= r then player m2 will have a beneficial deviation: in case (cid:4)σ |= ¬(p ↔ q), player m2 simply has to deviate to a strategy σ (cid:14)2 that is winning for ¬ϕ and keep the same value for q; in case (cid:4)σ |= (p ↔ q), player m2 can deviate to a strategy σ (cid:14)2 that is winning for ¬ϕ and change the value of q with respect to the one given by σ2. This analysis covers all possible cases with respect to ϕ, r, and p, q.Then, the problem is 2EXPTIME-hard with two players and five Boolean variables. (cid:3)146J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157Arguably, the two key decision problems relating to the game-theoretic analysis of game-like concurrent and multi-agent systems are (i) checking whether an LTL formula holds on some run given by a Nash equilibrium of the system; and (ii) checking whether a given LTL formula holds on all runs given by the Nash equilibria of the system. These two problems are formalised in the E-Nash and A-Nash problems, respectively.E-NashGiven:Question: Does ρ( (cid:4)σ ) |= ϕ hold for some (cid:4)σ ∈ NE(G)?RMG G, LTL formula ϕ.A-NashGiven:Question: Does ρ( (cid:4)σ ) |= ϕ hold for all (cid:4)σ ∈ NE(G)?RMG G, LTL formula ϕ.These two decision problems were first studied in [29] for iterated Boolean games (iBG). In such a setting, there was no language to specify the systems that the iBGs were to model. Even more, the setting was quite simple: it was assumed that in every system state all variables could be updated. In this article, we study systems that do not impose this restriction, and we show that we obtain similar complexity results in this case. Note that using RMGs allows us to express systems that cannot be directly expressed in iBGs; however, as we noted above, RMGs cannot succinctly express iBGs.More specifically, even though RMGs can be used to impose constraints in the choices that players can make (i.e., the values they can give the variables they control), it is still possible to find a reduction from the E-Nash and A-Nash for LTL RMGs to the same problems in the context of iBGs. Before describing the reduction, let us define an iBG G, which we will call a ‘supervised game’, in which all the Nash equilibria of the iBG Gmust be consistent with the Nash equilibria of some initially given LTL RMG G.(cid:14)(cid:14)Formally, an iterated Boolean game is a structure(N, (cid:4), ((cid:4)i)i∈N , (γi)i∈N )where every element of the structure is as for LTL RMGs. Strategies are defined as for LTL RMGs, that is, as Moore finite-state machines. However, as we can see, the arena where an iBG is played is implicitly given: it is the unique clique whose vertices are the valuations V = 2(cid:4). Having such an arena to play the game informally means that, in an iBG, it is assumed that in every state all agents can update the values of all the variables they control; note that, in contrast, in an LTL RMG only the variables that are in the scope of enabled guarded commands can be updated.More specifically, note that, in general, the LTL RMG representation of an iBG may result in a game of exponential size since one would have to specify in the LTL RMG all the (exponentially many) choices with respect to (cid:4) that players in an iBG have at their disposal. This is, indeed, the reason why a simple polynomial-time reduction from iBG to LTL RMGs is not possible – e.g., in order to obtain hardness results for LTL RMGs.Nevertheless, as mentioned above, for the particular case of the E-Nash and A-Nash problems, a reduction from LTL RMGs to iBGs is possible. We first present a key technical result, which relies on the following game construction. Given an LTL RMG G = ( A = (N, (cid:4), (mi)i∈N ), (γi)i∈N ), we let the iBG Gi )i∈N(cid:14) ) be its supervised game, given by(cid:14), (cid:4)(cid:14), ((cid:4)i)i∈N(cid:14) , (γ (cid:14)(cid:14) = (N• N• γ (cid:14)i• γ (cid:14)n+1• γ (cid:14)n+2(cid:14) = N ∪ {n + 1, n + 2} and (cid:4)(cid:14) = (cid:4) ∪ {xn+1, xn+2},=(cid:19)j∈N(cid:19)(cid:19)Th(m j) ∧ γi ,j∈Nj∈NTh(m j) ∨ (xn+1 ↔ xn+2),Th(m j) ∨ ¬(xn+1 ↔ xn+2),==where i ∈ N. Recall that each Th(mi) is an LTL formula that characterises module mi . Based on this definition of supervised games, we obtain the following result.Lemma 12. Let G = ( A = (N, (cid:4), (mi)i∈N ), (γi)i∈N ) be an LTL RMG and let Gthen:(cid:14) = (N(cid:14), (cid:4)(cid:14), ((cid:4)i)i∈N(cid:14) , (γ (cid:14)i )i∈N(cid:14) ) be its supervised game, (cid:4)σ ∈ NE(G)( (cid:4)σ , σn+1, σn+2) ∈ NE(Gfor all (cid:4)σ and strategies σn+1, σn+2 for players n + 1 and n + 2.if and only if(cid:14))Proof. We first prove the left-to-right direction. Since (cid:4)σ is a profile of strategies that is consistent with A, then the LTL formula(cid:2)Th(m j)j∈Nis satisfied and, hence, also the LTL goals γn+1 and γn+2. Thus, players n + 1 and n + 2 will not deviate. Moreover, because players n + 1 and n + 2 do not control any variable already present in the game G and the goals (γ (cid:14)i )i∈N do not depend on the Boolean variables in {xn+1, xn+2}, it follows thatJ. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157147ii(cid:14)ρ( (cid:4)σ ) |= γiiff ρ( (cid:4)σ , σn+1, σn+2) |= γ (cid:14)iff ρ( (cid:4)σ , σn+1, σn+2)|(cid:4) |= γ (cid:14)i )i∈N and strategies σn+1, σn+2 for players n + 1 and n + 2. Then, players i in N who have their goal by ρ( (cid:4)σ , σn+1, σn+2) – thus, they will not want to deviate. Similarly, by ρ( (cid:4)σ , σn+1, σn+2), provided that they only use strategies that are consistent with i that is not (cid:19)Th(m j) will be false. Then, no player can have a beneficial deviation by switching to a strategy that is not consistent with A. As a consequence, for all goals in (γ (cid:14)achieved in G by ρ( (cid:4)σ ) will also have it satisfied in Gplayers i in N who did not have their goal achieved in G by ρ( (cid:4)σ ) will not have it satisfied in Geither, and hence will not have a beneficial deviation in GA. Then, if a player i has a beneficial deviation in Gconsistent with A. But, in such a case its goal γi will not be satisfied because the conjunct in G( (cid:4)σ , σn+1, σn+2) ∈ NE(Gand not in G it must be by switching to a strategy σ (cid:14)We now prove the right-to-left direction. Since ( (cid:4)σ , σn+1, σn+2) ∈ NE(G(cid:14)), we know both that players n + 1 and n + 2have their goals achieved and that the strategies in (cid:4)σ are consistent with the srml modules (mi)i∈N – because the LTL (because the two final players are playing a version formula of Matching Pennies, for which there is no pure Nash equilibrium).Th(m j) is necessarily satisfied in all Nash equilibria of G(cid:14)), as desired.Hence, (cid:4)σ is a legal strategy in G (i.e., consistent with the arena given by (mi)i∈N ). For exactly the same reasons given in j∈Nj∈N(cid:19)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)the left-to-right direction, the strategy profile (cid:4)σ is, therefore, a Nash equilibrium in G, that is, becauseρ( (cid:4)σ , σn+1, σn+2) |= γ (cid:14)iiff ρ( (cid:4)σ , σn+1, σn+2)|(cid:4) |= γ (cid:14)iiff ρ( (cid:4)σ ) |= γias needed. Note, in particular, that if a player i did not have its goal γ (cid:14)by ρ( (cid:4)σ , σn+1, σn+2), then such a i satisfied in GTh(m j) is necessarily satisfied. Then, ρ( (cid:4)σ ) (cid:12)|= γi . strategy profile does not satisfy γi either – because the LTL formula j∈NMoreover, player i cannot have a beneficial deviation in G by switching to an alternative strategy because every strategy in G was already available in G. (cid:3)(cid:19)(cid:14)(cid:14)(cid:14)The reason why we call the iBG G“the supervised game of G,” under the definition given above, is that in Gwe have introduced two new players, namely n + 1 and n + 2, who act as “supervisors” of the behaviour of the players i in N in the following sense: they (players n + 1 and n + 2) can easily ensure that any strategy profile in the iBG Gwhich forms a Nash equilibrium is possible if, and only if, the other players comply with the constrained behaviour imposed by the specification Th(m j). Then, using Lemma 12, we of the modules in G, that is, the behaviour formally specified by the LTL formulacan show the next result.j∈N(cid:19)(cid:14)(cid:14)Proposition 13. The E-Nash and A-Nash problems for LTL RMGs are both 2EXPTIME-complete.Proof. Consider E-Nash first. For hardness, we can trivially reduce the Non-emptiness problem for LTL RMGs by asking whether (cid:9) is satisfied on some Nash equilibrium outcome. For membership, use Lemma 12 to construct a supervised game and straightforwardly reduce E-Nash for LTL RMGs to E-Nash for iBG, which is known to be 2EXPTIME-complete [29]. Since 2EXPTIME is a deterministic complexity class, the desired complexity result for the A-Nash problem immediately follows.Finally, since in [29] we use rational synthesis [23] to solve the E-Nash problem for iBG, which is 2EXPTIME in the sizes of players’ goals and input LTL formula, then we obtain that E-Nash for LTL RMGs is 2EXPTIME with respect to both the size of the RMG G and input LTL formula ϕ. (cid:3)This result shows, in particular, that in the linear-time setting analysing equilibrium properties (via the E-Nash and A-Nashproblems) is as hard as the controller synthesis problem for LTL [57] – or, expressed in game-theoretic terms, as hard as solving two-player zero-sum perfect-information games with LTL goals.6.2. On the complexity of CTL RMGsIn this section, we are interested in the computational complexity of the decision problems just investigated, but now in the branching-time framework we developed in previous sections. The first complexity result we are to present is forRealizability, which we obtain via a reduction to CTL supervisory-control games in [42] (aka CTL games on graphs).Proposition 14. Realizability for CTL RMGs is 2EXPTIME-complete.Proof. For membership in 2EXPTIME, similar to the case for LTL, we use a reduction to the control-synthesis problem for CTL specifications with reactive environments [42]. Firstly, from the set of modules in the given game G, construct the induced Kripke structure K , which is at most exponential in the size of the modules. Now, associate player i with the “system” in the CTL control-synthesis problem, the set of players N \ {i} with its (reactive) “environment” and let ϕ be the CTL goal of the system – hence, ¬ϕ would be the CTL goal of the environment since it is a zero-sum game. It is not hard to show that player i has a strategy to achieve ϕ if, and only if, the system has a strategy to win the CTL control-synthesis 148J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157game.4 Because the complexity is doubly exponential in the size of the formula ϕ, but only exponential in the size of the given graph (K in this case), then the procedure is now doubly exponential in the size of the initial game G. Therefore, containment in 2EXPTIME still follows, but with an exponentially higher system complexity, matching the result in the linear-time case using a logic-based approach instead, that is, a decision procedure that is doubly exponential in the sizes of both the system/game and the formula.For hardness, again analogous to the LTL case, we use the CTL supervisory-control games in [5], where, in particular, non-deterministic strategies instead of only deterministic ones are considered. (cid:3)This result sharply contrasts with the computational complexity of the usual realizability problem for CTL specifications, which is known to be EXPTIME-complete [21]. There is, however, a clear difference between the standard realizability problem and the one we are considering: whereas in the former a strategy (for player i, the system) must be constructed with respect to a known special strategy of the environment (for players in N \ {i}), in the latter we have to construct a strategy that ensures the goal of player i with respect to any strategy of player i’s opponents.Proposition 14 shows, in addition, that whereas in the linear-time framework Realizability for a multi-player game is as hard as synthesis in a two-player system, in the branching-time context the problem is considerably harder, that is, while synthesis for CTL specifications is EXPTIME-complete, Realizability for CTL RMGs is 2EXPTIME-complete.On the other hand, the following complexity result shows that, as in the linear-time case, the NE-membership problem is as hard as the satisfiability problem for the temporal logic under consideration.Proposition 15. NE-membership for CTL RMGs is EXPTIME-complete.Proof. To show membership in EXPTIME, we use a variation of the algorithm given to show Proposition 6 in [29]. In particular, we use the following two facts:• CTL model checking over Kripke structures can be done in polynomial time (and the Kripke structure K A induced by an arena A may be exponential in the size of A);• the intersection non-emptiness problem for Alternating Büchi Tree (ABT) automata is EXPTIME-complete.Then, firstly, in order to check whether K (cid:4)σ |(cid:4) (cid:12)|= ϕ, where ϕ is a CTL formula, we construct the Kripke structure K (cid:4)σ induced by A (cid:4)σ . Since the Kripke structure K (cid:4)σ may be exponential in the size of (cid:4)σ , this step (which is used to check if a player gets or not its goal achieved by (cid:4)σ ) can be done in EXPTIME. The other step, namely, whether a player i that did not get its goal γi achieved can have a beneficial deviation by switching to an alternative strategy, can be reduced to the intersec-tion non-emptiness problem for ABT automata – here is where we deviate from the algorithm given to show Proposition 6 in [29]. Instead of checking satisfiability of a CTL formula, we will construct an ABT Aγi that represents γi . Such an automa-ton is polynomial in the size of γi ; see [41,70]. Also, because our strategies are (non-deterministic) transducers, they are also, in particular, Non-deterministic Büchi Tree (NBT) automata with a trivial acceptance condition (all states are accepting states). Write Aσi for each strategy regarded as an NBT of this kind. Then, checking that player i has a strategy to deviate and achieve its goal can be verified by checking non-emptiness of the following automaton:× . . . × Aσn ,× . . . × Aσi−1× Aσi+1× AγiAσ1since we need to check that the language of trees accepted by this automaton is non-empty. Because every automaton Axis linear or polynomial in the size of each x, this step is exponential in the size of x, that is, exponential in the sizes of both the strategies σi and the goal γi . Then, inclusion in EXPTIME follows.Hardness, on the other hand, is shown by a reduction from the problem of determining whether a given player has a winning strategy in the game peek-G 4 [64, p. 158]; our construction of a CTL RMG for an instance of peek-G 4 is inspired by the construction presented in [67].An instance of peek-G 4 is given by a structure: ( X1, X2, X3, ϕ), where:• X1 and X2 are disjoint, finite sets of Boolean variables, with the intended interpretation that the variables in X1 are under the control of agent 1, and X2 are under the control of agent 2;• X3 ⊆ ( X1 ∪ X2) are the variables deemed to be true in the initial state of the game; and• ϕ is a propositional logic formula over the variables X1 ∪ X2, representing the winning condition.The game is played in a series of rounds, with agents i ∈ {1, 2} alternating turns – and agent 1 moving first – to select a value ((cid:9) or ⊥) for one of their variables in Xi . The game starts from the initial assignment of truth values defined by X3 . Variables that were not changed retain the same truth value in the subsequent round. An agent wins in a given round if it makes a move such that the resulting truth assignment defined by that round makes ϕ true.4 The only difference is that in G the two players play concurrently, whereas in the CTL control-synthesis game, they play sequentially. A similar situation is found in Proposition 3 of [32].J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157149The decision problem associated with peek-G 4 is determining if agent 2 has a winning strategy in a given instance ( X1, X2, X3, ϕ). We would like to remark that since peek-G 4 only requires “memoryless” strategies, they can be modelled with our finite-state machine model of strategies: whether an agent i can win depends only on the current truth assignment, the distribution of variables, the winning formula, and whose turn it is currently. As a corollary, if agent i can force a win, then it can force it in O (2| X1∪X2|) moves.From ( X1, X2, X3, ϕ), the following CTL RMG can be constructed. For each Boolean variable x ∈ ( X1 ∪ X2), we create a variable with the same name in our srml model, and we create two additional Boolean variables: turn and p. The former, will have the intended interpretation that if turn = (cid:9), then it is agent 1’s turn to move, while if turn = ⊥, then it is agent 2’s turn to move. We then have an srml module, which we call move, the purpose of which is to control turn, toggling its value in each successive round, starting from the initial case of it being agent 1’s move. Note that because of the definition of the module move, it has only one possible legal strategy up to equality with respect to its observable behaviour, namely (cid:9), ⊥, (cid:9), ⊥, . . .. The goal γmove of this player in the CTL RMG is defined to be γmove = (cid:9).module move controls turn(cid:14) := (cid:9)init:: (cid:9) (cid:2) turnupdate:: turn (cid:2) turn:: (¬turn) (cid:2) turn(cid:14) := ⊥(cid:14) := (cid:9)Moreover, for each of the two peek-G 4 players i ∈ {1, 2}, we create an srml module agi that controls the variables Xi . We also let the module ag2 control p. The modules ag1 and ag2 are as follows. For ag1, it begins by deterministically initialising the values of all its variables to the values defined by X3 (that is, if variable x ∈ X1 appears in X3 then this variable is initialised to (cid:9), otherwise it is initialised to ⊥). The module ag2 is the same as defined for ag1, save that ag2has two init commands instead of only one: while one of the init commands sets p to (cid:9), the other one sets p to ⊥.Then, after initialisation, when it is a player’s turn, such a player can non-deterministically choose at most one of the variables under its control and toggle the value of this variable; when it is not this player’s turn, it has no choice but to do nothing, leaving the value of all its variables unchanged. The general structure of ag1 is thus as follows, where X1 = {x1, . . . , xk}.module ag1 controls x1, . . . , xk:= . . . ; xk := . . .init// initialise based on values from X3(cid:14):: (cid:9) (cid:2) x1update(cid:14):: turn (cid:2) x1(cid:14):: turn (cid:2) x1. . .(cid:14):: turn (cid:2) xk(cid:14):: turn (cid:2) xk:: (cid:9) (cid:2) skip:= ⊥:= (cid:9):= ⊥:= (cid:9)And the general structure of ag2 is thus as follows, where X2 = { y1, . . . , yl}.module ag2 controls p, y1, . . . , yl(cid:14)1(cid:14)1(cid:14) := (cid:9); y(cid:14) := ⊥; yinit// initialise based on values from X3:= . . . ; yl := . . .:: (cid:9) (cid:2) p:: (cid:9) (cid:2) p:= . . . ; yl := . . .update:: turn (cid:2) y:: turn (cid:2) y. . .:: turn (cid:2) y:: turn (cid:2) y:: (cid:9) (cid:2) skip:= ⊥:= (cid:9):= ⊥:= (cid:9)(cid:14)1(cid:14)1(cid:14)l(cid:14)lNotice that an agent can always skip, electing to leave its variables unchanged; and, if it is not this agent’s turn to move, this is the only choice it has. The srml arena under consideration contains just these three modules. We define the goal of agent 1 to be γ1 = (cid:9), and the goal of agent 2 to be the CTL formula γ2 = p ∧ A(¬ϕ U (turn ∧ ϕ)).In addition, we also let the strategy σ1 of agent 1 be the trivial non-deterministic strategy that contains all possible choices available at each round of the game, i.e., a strategy that in every round non-deterministically chooses any of the 150J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157commands in the update part of the module ag1. For ag2 we let the strategy σ2 be any strategy such that it chooses the initialisation command where p = ⊥. Then, clearly, with this strategy profile, namely (σ1, σ2, σmove), players ag1 and movehave their goals satisfied, whereas player ag2 fails to have its goal γ2 satisfied (because σ2 makes p = ⊥). More formally, with respect to this strategy profile we know that K(σ1,σ2,σmove) (cid:12)|= γ2.However, if agent 2 has a winning strategy in peek-G 4, then the player ag2 has a beneficial deviation σ (cid:14)2 to a strategy making the same choices as such a winning strategy and which sets p = (cid:9) in the initialisation stage, so that its goal γ2 is achieved. Hence, whereas (σ1, σ2, σmove) is not a Nash equilibrium, the strategy profile (σ1, σ (cid:14)2, σmove) would be an equilibrium as in that case all players get their goals satisfied. Formally, the following holds:if agent 2 has a winning strategy, then (σ1, σ2, σmove) (cid:12)∈ NE(G).If, on the other hand, agent 2 does not have a winning strategy in peek-G 4, then, because the strategy σ1 of ag1, as defined above, contains all possible choices that agent 1 can make, it necessarily follows that there would be a run of the game that can be used as a witness to show that γ2 is not satisfied, in particular, for all strategies σ (cid:14)2 that set p = (cid:9) (as otherwise agent 2 would have a winning strategy – contradicting our initial hypothesis). Then, it follows that in this case player ag2cannot have a beneficial deviation and that the strategy profile (σ1, σ2, σmove) is in fact a Nash equilibrium. Formally, in this case, the following statement holds:if agent 2 has no winning strategy, then (σ1, σ2, σmove) ∈ NE(G).Thus, agent 2 has a winning strategy for the instance of peek-G 4 if, and only if, (σ1, σ2, σmove) is not a Nash equilibrium. Since EXPTIME is a deterministic complexity class, hardness of the NE-membership problem for CTL RMGs with respect to the EXPTIME complexity class follows. Finally, observe that because we use intersection non-emptiness to show membership in EXPTIME, we obtain that NE-membership is EXPTIME in the sizes of both the RMG G and the strategy profile (cid:4)σ . (cid:3)Finally, we show that, as in the linear-time case, checking both whether a system/game has at least one Nash equilibrium as well as whether a CTL formula holds on some or on all Nash equilibria of such a game-like multi-agent system are 2EXPTIME-hard problems. Formally:Proposition 16. The following three problems are 2EXPTIME-hard:Non-emptiness, E-Nash, and A-Nash for CTL RMGs.Proof. For these results, we reduce CTL supervisory-control games on graphs to the Non-emptiness problem – a game construction in which we add two new players who ensure that the “system” player in the initially given CTL supervisory-control game has a winning strategy if, and only if, there is a Nash equilibrium in the constructed CTL RMG. Then, the other two decision problems we have considered, namely, E-Nash and A-Nash, inherit such a hardness complexity result. (cid:3)7. Beyond reactive modulesThe results we prove in this article may at first sight appear to be closely tied to a single formalism for defining game arenas, i.e., the Reactive Modules language. However, this language is in fact very general. To illustrate the scope of our framework, we now show how a standard AI formalism for planning agents can be directly modelled within our framework: the propositional STRIPS notation [22,12,25]. Descendants of the STRIPS notation remain widely used within the planning community, and various multi-agent planning models based on STRIPS have been investigated within the literature, such as the MA-STRIPS model of Brafman and Domshlak [10].The basic idea of the STRIPS notation is to model the effects of actions in terms of “pre-condition, delete, add lists”: the pre-condition defines what must be true in order for the action to be executed; the add list defines what propositions will be made true by the execution of the action; and the delete list defines what propositions will be made false by the execution of the action. As we did previously, we assume a vocabulary (cid:4) of propositional variables, used to characterise the state of the system. Formally, a STRIPS descriptor for an action α is given by a structureα = (Tα, Fα, Dα, Aα),where:• Tα is the set of propositions that must be true in order for α to be executed;• Fα is the set of propositions that must be false in order for α to be executed;• Dα is the set of propositions that characterise those facts made false by the performance of α (the delete list); and• Aα is the set of propositions that characterise those facts made true by the performance of α (the add list).As with RMGs, we model the state of the system at any given time as a valuation v ∈ V . For every action α we define a propositional formula preα , such that this formula is satisfied by a valuation whenever the pre-condition of α is met:J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157151preα =(cid:2)x ∧(cid:2)x∈Tαy∈Fα¬ y.The effect of executing an action α when the world is as described by the valuation v is denoted eff (α, v), where this partial function is defined as follows:(cid:21)eff (α, v) =(v \ Dα) ∪ Aαundefinedif v |= preαotherwise.We can then naturally define a multi-agent STRIPS arena:A = (N, (cid:4), v 0, Ac1, . . . , Acn)where N = {1, . . . , n} is the set of players, (cid:4) is the vocabulary of propositional variables used to represent the state of the system, v 0 ∈ V is the initial state of the game, and for each player i ∈ N, Aci = {α1} is set of action descriptors, representing the actions that i can perform. The domain of an action α, denoted dom α, is the set of variables whose truth status can be changed by the performance of α, i.e., dom α = Dα ∪ Aα . To keep things simple, we assume that the actions of different players are disjoint:i , . . . , αki∀i (cid:12)= j ∈ N, ∀α1 ∈ Aci, ∀α2 ∈ Ac j, dom α1 ∩ dom α2 = ∅.(cid:20)Let (cid:4)i =α∈ Acidom α be the set of variables under the control of player i.The execution of a STRIPS arena then proceeds over an infinite sequence of rounds: in the first round, variables are initialised to their values in v 0; on each subsequent round, each player i selects an action α ∈ Aci whose pre-condition is satisfied, and the profile of actions selected by players are then executed as defined in the eff (· · ·) function to generate the next state of the system. Each player then chooses another action whose pre-condition is satisfied, and so on.A STRIPS game is then given by a structureG = ( A, γ1, . . . , γn)where A is a multi-agent STRIPS arena, and γi is the temporal logic goal of player i; as with RMGs, we might consider LTL or CTL goals. Given this setup, it should be clear that we can then define strategies for agents in the same way that we did for RMGs, and then runs, Kripke structures, etc. similarly. (The details are straightforward but tedious, and we omit them here.) We remark that the definition we give here is very similar to that of the MA-STRIPS model of Brafman and Domshlak [10], except that in MA-STRIPS, goals are represented as sets of states, with the idea being that an agent wants to bring about one of the set. This can be represented directly within our model by giving agents goals of the form Fϕ.We now show how we can translate a STRIPS arena into an equivalent RML arena. First, let α = (Tα, Fα, Dα, Aα) be an action descriptor. Then we define a guarded command gα for this action descriptor as follows:(cid:14)preα (cid:2) r(cid:3)1(cid:14)k:= (cid:9); · · · ; r(cid:4)(cid:5)Aα ={r1,...,rk}:= (cid:9);(cid:6)(cid:14)z(cid:3)1(cid:14):= ⊥; · · · ; zk(cid:4)(cid:5)Dα ={z1,...,zk}:= ⊥(cid:6)We define a single init guarded command g0ithe valuation v 0:(cid:14)(cid:9) (cid:2) x(cid:3)i:= (cid:9); · · · ;(cid:6)(cid:4)(cid:5)xi ∈(cid:4)i ∩v0(cid:14)xj(cid:3):= ⊥; · · · ;(cid:6)(cid:4)(cid:5)x j ∈((cid:4)i \v0)for player i, which sets the variables under the control of i to correspond to Finally, the module mi for each player i is then simply mi = ((cid:4)i, Ii, U i) where (cid:4)i is as defined above, Ii = {g0} is the single iinitialisation guarded command for i as defined above, and U i = {gα | α ∈ Aci} is the set of update guarded commands for i.Now, it should be clear from construction that the srml arena constructed in this way will operate in the same way as the STRIPS arena that we began with. In particular, when each player i selects an enabled update command gα for execution, this corresponds to selecting an action α ∈ Aci whose pre-condition is satisfied. Executing a guarded command simulates the behaviour of executing the action α as defined by the descriptor (Tα, Fα, Dα, Aα).Thus, we can translate propositional multi-agent STRIPS systems into our formalism. Note that translation in the opposite direction is not directly possible, however, because srml guarded commands are richer than propositional STRIPS operators: (cid:14) := ϕ, meaning that the variable xin the action part of a guarded command, we are allowed to have actions such as xshould take the value of the formula ϕ. Such constructs are not provided in propositional STRIPS (they can be simulated, but only at the cost of an exponential blow up in the number of actions).Finally, note that the fact that propositional STRIPS planning games can be encoded within our game framework implies that membership results for the corresponding decision problems studied in the article carry over directly (hardness results do not carry over automatically, although many of them can be seen to hold from the constructions presented earlier).152J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–1578. Related workOur work has its antecedents in two closely related threads of computer science research: the first, arising from the computer-aided verification community, is the use of logics and techniques inspired by game theory for the automated verification of computer programs (see, e.g., [3]); the second, arising largely from the artificial intelligence community, is the use of logic in the formal specification and verification of multi-agent systems (see, e.g., [76,68] for surveys).Historically, the computer-aided verification community focussed on the problem of checking whether a system S sat-isfies a given property ϕ, where ϕ is expressed as a formula of temporal logic (typically either LTL or CTL) [20,16]. Using temporal logics such as LTL or CTL makes it possible to express properties relating to the temporal ordering of events in a system, but does not enable the expression of strategic properties, such as “component i can guarantee that the system never enters a fail state.” This observation motivated Alur et al. to develop Alternating-time Temporal Logic (ATL) [3], which is explicitly intended to support such reasoning. However, there are important limitations on the game properties that can be expressed using ATL. First, ATL provides no direct mechanism to refer to strategies in the object language – which appears to be required if one intends to capture game-theoretic properties such as Nash equilibrium. Second, the language provides no mechanism for directly representing the preferences of system components – and again, this seems appropriate if one hopes to reason about game-theoretic equilibrium properties, as we do in this paper.The idea of introducing strategies into the object language has been pursued by a number of researchers [14,50]. Probably the best-known and most successful such formalism is Strategy Logic (SL), which can be thought of as a temporal logic that includes a framework for naming strategies and reasoning about their properties [66,14,50].Relatively little work within the computer aided verification community has addressed the problem of capturing the preferences of players, and the role that these preferences play in strategic, game theoretic reasoning. However, of the work on this topic that is present in the literature, it seems fairly common to model player preferences in the same way that we do in the present paper: as temporal logic formulae that the player desires to see satisfied [5,23] (or else, more generally, as ω-regular objectives [13,8]). To pick one example of this work, Alur et al. [5] investigated the complexity of game-theoretic questions for games played on graphs, in which players attempt to satisfy a goal, expressed as a temporal logic formula. One aspect of such work is that it assumes that agents make moves in a game arena that is explicitly modelled as a graph. This is an unrealistic assumption in practice, since the state transition graph for any real system will be of size exponential in the number of variables in the system. Moreover, the significance of complexity results for such games might reasonably be questioned, since an unrealistic representation of the game arena is assumed. Similar comments apply to many other studies of game-theoretic properties of concurrent systems.In the second strand of work, researchers in the AI community have developed a range of formalisms intended for the specification and verification of multi-agent systems. Originally, this work focussed on practical reasoning agents, (i.e., planning systems [25]), and in particular, on the belief-desire-intention model of agency [58]. In this model, agents are viewed as selecting intentions from a set of possible desires, which then represent commitments to achieve certain states of affairs; they then select and execute plans of action to achieve their intentions. However, difficulties in obtaining a satisfactory formalisation of rational mental states led researchers to seek alternative foundations for modelling rational action in multi-agent systems, and game theory became increasingly adopted as a foundation. See, e.g., [39] for an excellent survey of this stream of work. Of this body of work, it is worth identifying several threads of research that are related to the present paper. Bulling et al. [11] consider variations of ATL with the explicit intention of reasoning about temporal properties of strategic notions such as Nash equilibrium. The key differences with the present work are, first, that our aim is not to reason about game theoretic properties in the object language; and second, our use of a compact system modelling language (srml) to define the underpinning game structure.Our work in the present article draws upon both of these paradigms, and it is most closely related to the work presented in [29,30,33]. In [29], Gutierrez et al. introduced a model called Iterated Boolean Games (iBGs). In an iBG, each player exercises unique control over a set of Boolean variables, and play proceeds over an infinite series of rounds, where at each round each player makes a Boolean assignment to the variables they control. Each player is associated with an LTL formula that the player desires to see satisfied in the LTL model traced out by the infinite play of the game. A key concern of Gutierrez et al. was to classify the complexity of game-theoretic decision problems in iBGs (such as checking for the existence of pure strategy Nash equilibria).5 Observe that, in contrast to many other studies of game properties in concurrent systems, the arena in which an iBG is played is defined succinctly: simply by listing the variables that each player controls. While we believe the iBG model and the Boolean games model that it generalises are simple and elegant models with which to formulate questions of strategic interaction in multi-agent systems, they clearly represent a very high-level abstraction of real systems. In particular, in iBGs, it is assumed that at every time point, every player has complete freedom to assign values to the variables it controls. This greatly limits the multi-agent scenarios that can be modelled with iBGs. In [30,33], Gutierrez et al. presented a more realistic model of concurrent programs, but as with other studies of game-like properties in concurrent systems, it assumes that game arenas are explicitly presented – and for the reasons described above, we believe this is an unrealistic assumption in practice.5 The iBG model is essentially a generalisation of the conventional Boolean games model introduced by Harrenstein et al. [37]. Conventional Boolean games are like iBGs, except that play takes just one round, and goals are expressed using classical propositional logic, rather than LTL.J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157153Table 2Overview of computational complexity results.RealizabilityNE-membershipNon-emptinessE-NashA-NashLTL RMGs2EXPTIME-cPSPACE-c2EXPTIME-c2EXPTIME-c2EXPTIME-c(Proposition 8)(Proposition 10)(Proposition 11)(Proposition 13)(Proposition 13)CTL RMGs2EXPTIME-c2EXPTIME-c2EXPTIME-hard2EXPTIME-hard2EXPTIME-hard(Proposition 14)(Proposition 15)(Proposition 16)(Proposition 16)(Proposition 16)In short, while our broad aim is the same as [5,11,13,8,29,30,33] (i.e., the game-theoretic analysis of concurrent and multi-agent systems), our approach is to use a language for defining game arenas that is much closer to real-world program-ming and system modelling. We represent game arenas using the Reactive Modules language, which permits the succinctdefinition of concurrent and multi-agent systems and protocols. Questions relating to the complexity of game-theoretic questions on such succinctly-specified arenas are, we believe, much more meaningful in this context than on arenas in which the game graph is explicitly presented. Interestingly, we find that for many of the decision problems we consider, the complexity does not increase when studying game arenas specified using Reactive Modules.9. Conclusion and future workIn this article, we have studied a novel game model that admits a natural characterisation in a simple, yet computation-ally powerful, syntactic fragment of the Reactive Modules language [2]. Also, the complexity of reasoning about equilibria in this model as well as of checking and synthesising temporal properties of multi-agent systems specified in such a language was investigated, both, in the linear-time and branching-time frameworks [20].Several research groups are working on problems related to equilibrium checking: Fisman et al. [23] study the problem of synthesising systems so that certain desirable properties hold in equilibrium; in addition, extensive overviews of decision problems related to equilibrium checking are given in [13,8], for a range of concurrent game models.In our own work, we have investigated many issues surrounding rational verification, particularly using Boolean games [37]. Boolean games are essentially “one-shot” versions of iterated Boolean games, as described above, where play consists of a single round, and agent goals γi are specified as propositional formulae. A question that we have investigated at length is possible mechanisms for managing games. This might be necessary, for example, if the game contains socially undesirable equilibria [73], or where a game possesses no equilibrium, and we wish to introduce one (which we call sta-bilisation). One obvious mechanism for manipulating games is the use of taxation schemes, which provide incentives for players to avoid undesirable equilibria, or to prefer desirable equilibria [74]. (Related issues have recently been studied in the context of concurrent games [1].) Another possibility is to try to influence players by changing their beliefs through communication. For example, [26] considered a Boolean games setting where players make their choices based on beliefs about some variables in the environment, and a central authority is able to reveal certain information in order to modify these beliefs. Another issue we have investigated is the extent to which we can develop a language that supports reason-ing about strategies directly in the object language. Strategy Logic (SL) is a variation of temporal logic, closely related to Alternating-time temporal logic [3], which includes names for strategies in the object language [14], and using SL, it is pos-sible to reason about Nash equilibria. However, SL is in general undecidable, which raises the question of whether weaker languages might be used. For instance, in [30] a temporal logic containing a quantifier [NE]ϕ, meaning “ϕ holds on all Nash equilibrium computations”, is proposed. Also, in [31] it is shown that the existence of Nash equilibria can be represented, up to bisimilarity, in logic languages that are even weaker than full SL. Other researchers have investigated similar con-cerns [11]. Another interesting question is the extent to which the model of interaction used in a particular setting affects the possible equilibria that may result. In [35], we investigated Nash equilibria in games based on event structures [71], and were able to characterise conditions required for the existence of equilibria. Another research direction is the extent to which we can go beyond the representation of preferences as simple binary formulae; one possible approach, investigated in [48], is to represent player’s goals as formulae of Łukasiewicz logic, which permits a much richer class of preferences to be directly represented.Many issues are being currently studied, or remain for future work. Mixed (stochastic) strategies is an obvious major topic of interest, as it is the possibility of imperfect information [34], and of course solution concepts beyond Nash equilibria, such as subgame perfect equilibrium. Our Eagle tool is a prototype [65], limited in its scope, and not optimised: extensions supporting LTL, incomplete information, etc., are all highly desirable.Our main complexity results are summarised in Table 2 and some of them are rather surprising. For instance, we showed that with respect to goals given by LTL formulae and deterministic strategies, it is equally hard to verify equilibrium proper-ties (i.e., those studied in E-Nash and A-Nash) regardless of whether the arenas modelling the systems of interest are either explicitly specified in srml or implicitly given – as in iterated Boolean games (iBGs [29]), where the induced Kripke struc-tures are exponential in the number of variables. Recall that, in general, the srml model of any iBG is also of exponential size.Less surprising is the fact that the complexity of all the key questions we studied is 2EXPTIME-hard. This is high com-putational complexity, which presents a real challenge for practical implementations. Our results show that, as for (LTL) 154J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157:= S AS A := ∅, S 0Afor each v ∈ S A dofor each J ∈ C1 × · · · × Cn doS A := S A ∪ {exec( J , v⊥)}S 0Aπ A := π A ∪ {(exec( J , v⊥), exec( J , v⊥))}function Arena2Kripke( A = (N, (cid:4), m1, . . . , mi, . . . , mn)):= ∅, R A := ∅, π A := ∅1.2. C1 := I1; · · · ; Cn := In;3.4.5.6.7. end-forX := ∅8.9. while X (cid:12)= S A doX := S A10.11.12.13.14.15.16.17.18. end-while19.2021.22.23.24.25.26. end-forC1 := enabled1(π A(v)), . . . , Cn := enabledn(π A(v))for each J ∈ C1 × · · · × Cn doif exec( J , π A(v)) = π A(vR A := R A ∪ {(v, v(cid:14)) ∈ S A × S A doend-ifend-forfor each (v, vend-forend-for(cid:14)) do(cid:14))}C1 := enabled1(π A(v)); . . .; Cn := enabledn(π A(v))for each J ∈ C1 × · · · × Cn doS A := S A ∪ {exec( J , π A (v))}π A := π A ∪ {(exec( J , π A (v)), exec( J , π A(v)))}Fig. 12. Algorithm for generating Kripke structures. Here, K A = (S A , S 0(N, (cid:4), m1, . . . , mn) passed as input.A , R A , π A ) is the output of the function, produced from the srml arena A =synthesis problems, this is the best that one can do. As a consequence, if practical implementations are desired, one would have to look for suitable simplifications to the main setting: for instance, games with memoryless strategies, or games with goals in simpler LTL syntactic fragments. In the former case, one cannot do better than EXPTIME for general LTL goals; in the latter case, the complexity may be reduced even to PSPACE for safety goals. Either way, any practical implementation will probably have to deal with an associated synthesis problem from a logical specification, which most likely will be of high complexity. In fact, even though we deal with succinct system specifications, which are closer to the ones used in realistic scenarios, as clearly shown in [5], high complexities would be obtained even if explicit system representations are used, simply due to the fact that players goals are expressed using the full language of LTL. An alternative is studied in [28], where Nash equilibria is studied with respect to fragments of LTL within the iBG framework.Moreover, from an expressivity standpoint, RMGs are more general than iBGs. Indeed, the class of induced Kripke struc-tures induced by RMGs is strictly larger than the class of semantic structures associated with iBGs. A simple example is the distributed algorithm in Section 5.3, which cannot be specified as an iBG, but has an srml representation. Then, with RMGs, we have more expressive power with the same complexity.A somewhat different question is the extent to which the techniques and solution concepts developed here can be used in practice, for example when designing electronic commerce systems. The issue here touches on a substantial debate within game theory itself, concerning the applicability of game-theoretic concepts. If we view game theory as being a descriptivetheory, which aims to predict what people will actually do in strategic settings, then game-theoretic solution concepts seem to be of limited value in many cases (see, e.g., [7] for extensive discussion). There are several points to make here. First, one can argue that while people fail to be rational in the sense that game theory defines, when we design computer programsto make decisions, we can design them to act rationally. Second, we suggest that Nash equilibrium analysis is a starting point for understanding the rational dynamics of a system, rather than an end point. The Nash equilibrium computations of an RMG are a subset of the overall possible computations of the system at hand, and assuming rational action, then the actual trajectory of the system will lie with the Nash equilibrium set. But the analysis of the present paper stops at this point, once we have identified the rational computations. Finally, if we aim to use our techniques to understand the rational dynamics of human system, then work is needed on developing computational models of human strategic decision making. This would take us into the territory of behavioural game theory, and is somewhat beyond the scope of the present paper.In future work, we plan to use our specification language and games framework to implement a model checker of equi-librium properties in game-like concurrent and multi-agent systems. It would be also very interesting to investigate how the complexity results we have obtained so far are affected by the adoption of other temporal logic languages and solution con-cepts. Studying the relationship to Markov games and probabilistic model checking would also be interesting, perhaps using logics such as PCTL [43]. It would also be interesting to study situations in which the actions of players have unreliable effects (i.e., non-deterministic actions). Finally, much work remains to be done in settings where one considers imperfect information [34] or more general payoff sets and preference relations. All these issues should certainly be also investigated further.J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157155(cid:18) := ∅let L be the set osf (ϕ) ordered according to length (shortest first)for c := 1 to |L| doif L[c] is a propositional formula then(cid:14)) |= L[c]repeatfor each s(cid:14) ∈ S A doreturn π A(sfunction realizable(i, ϕ, s)1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18. end-for19. if ϕ ∈ (cid:18)(s) then return (cid:9) else return ⊥elsif L[c] = Xψ then(cid:14))return can(i, ψ, selsif L[c] = ψ U χ then(ψ ∈ (cid:18)(s(cid:18)(suntil no change to (cid:18)end-ifend-forif χ ∈ (cid:18)(s(cid:14)) := (cid:18)(s(cid:14)) orend-if(cid:14)) and can(i, ψ U χ , s(cid:14)) ∪ {ψ U χ }(cid:14))) thenfor each g ∈ CiT := ∅for each J ∈ C1 × · · · × {g} × · · · Cnfunction can(i, ϕ, s)1. C1 := enabled1(π A(s)); · · · ; Cn := enabledn(π A(s))2. flag := ⊥3.4.5.6.7.8.9.10.end-if11. end-for12. return f lagT := T ∪ {exec( J , π A (s))}(cid:14) : sflag := (cid:9)(cid:14) ∈ T and ϕ ∈ (cid:18)(send-forif T = {s(cid:14))} thenFig. 13. Algorithm for checking whether a player i can realise a formula ϕ from a state s.AcknowledgementsWe would like to thank Giuseppe Perelli and Alexis Toumi for very useful comments on an earlier version of this paper. Richard Appleby helped us debug some of the algorithms. This work was financially supported by the ERC Grant 291528 (“RACE”) at Oxford. The paper includes motivational/background material from the AAAI-2016 paper [75], although we emphasise that all the results presented in the present paper are new.Appendix A. Algorithms from the main textIn this appendix, we present algorithms that we held over from the main text in the interests of readability.First, Fig. 12 presents an algorithm that takes as input an RML arena A, and from this arena computes the Kripke structure induced by A. From inspection it is straightforward to see that the algorithm is correct, and is guaranteed to terminate in time exponential in | A|. Lines (3)–(7) compute the initial states S 0A . Lines (8)–(18) then extend these initial states to compute all reachable states of the system. Finally, lines (19)–(26) compute the relation R A .Fig. 13 presents an algorithm for checking whether an OLTL formula ϕ is realizable for a player i from a state s in a Kripke structure K A = (S A, S 0A, R A, π A). The algorithm works by backwards induction, building up a labelling function (cid:18), which associates with each state in S A the formulae that i can realize from that state. The algorithm is closely related to Zermelo’s algorithm, and critically depends upon the fact that the input is an OLTL formula.The algorithm makes use of a subsidiary function can(i, ϕ, s), which checks to see whether player i has a guarded command available for execution in state s, such that in all states that could result from the execution of this guarded command, the formula ϕ is true.It is straightforward from construction that the algorithm is correct, and guaranteed to terminate in time exponential in the size of A.156J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157References[1] S. Almagor, G. Avni, O. Kupferman, Repairing multi-player games, in: L. Aceto, D. de Frutos Escri (Eds.), Proceedings of the Twenty-Sixth Annual Conference on Concurrency Theory, CONCUR’15, Madrid, Spain, in: Leibniz International Proceedings in Informatics (LIPIcs), 2015, pp. 325–339.[2] R. Alur, T.A. Henzinger, Reactive modules, Form. Methods Syst. Des. 15 (11) (1999) 7–48.[3] R. Alur, T.A. Henzinger, O. Kupferman, Alternating-time temporal logic, J. ACM 49 (5) (2002) 672–713.[4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani, S. Ta ¸siran, MOCHA: modularity in model checking, in: Proceedings of the 10th International Conference on Computer Aided Verification, CAV’98, in: LNCS, vol. 1427, Springer, 1998, pp. 521–525.[5] R. Alur, S. La Torre, P. Madhusudan, Playing games with boxes and diamonds, in: Proceedings of the Fourteenth Annual Conference on Concurrency Theory, CONCUR’03, in: LNCS, vol. 2761, Springer, 2003, pp. 127–141.[6] K. Binmore, Fun and Games: A Text on Game Theory, D.C. Heath and Company, Lexington, MA, 1992.[7] K. Binmore, Does Game Theory Work?, The MIT Press, Cambridge, MA, 2007.[8] P. Bouyer, R. Brenguier, N. Markey, M. Ummels, Pure Nash equilibria in concurrent games, Log. Methods Comput. Sci. 2 (2015) 9.[9] R.S. Boyer, J.S. Moore (Eds.), The Correctness Problem in Computer Science, The Academic Press, London, England, 1981.[10] R. Brafman, C. Domshlak, On the complexity of planning for agent teams and its implications for single agent planning, Artif. Intell. 198 (2013) 52–71.[11] N. Bulling, W. Jamroga, J. Dix, Reasoning about temporal properties of rational play, Ann. Math. Artif. Intell. 53 (1–4) (2008) 51–114.[12] T. Bylander, The computational complexity of propositional STRIPS planning, Artif. Intell. 69 (1–2) (1994) 165–204.[13] K. Chatterjee, T.A. Henzinger, A survey of stochastic ω-regular games, J. Comput. Syst. Sci. 78 (2012) 394–413.[14] K. Chatterjee, T.A. Henzinger, N. Piterman, Strategy logic, Inf. Comput. 208 (6) (2010) 677–693.[15] E.M. Clarke, E.A. Emerson, Design and synthesis of synchronization skeletons using branching time temporal logic, in: Proceedings of the Workshop on Logics of Programs, in: LNCS, vol. 131, Springer-Verlag, Berlin, Germany, 1981, pp. 52–71.[16] E.M. Clarke, O. Grumberg, D.A. Peled, Model Checking, The MIT Press, Cambridge, MA, 2000.[17] G. Coulouris, J. Dollimore, T. Kindberg, Distributed Systems: Concepts and Design, Addison-Wesley, 2005.[18] S. Demri, V. Goranko, M. Lange, Temporal Logics in Computer Science: Finite-State Systems, Cambridge Tracts in Theoretical Computer Science, vol. 58, Cambridge University Press, 2016.pp. 996–1072.[19] S. Demri, Ph. Schnoebelen, The complexity of propositional linear temporal logics in simple cases, Inf. Comput. 174 (1) (2002) 84–103.[20] E.A. Emerson, Temporal and modal logic, in: Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics, Elsevier, 1990, [21] E.A. Emerson, E.M. Clarke, Using branching time temporal logic to synthesize synchronization skeletons, Sci. Comput. Program. 2 (3) (1982) 241–266.[22] R.E. Fikes, N. Nilsson, STRIPS: a new approach to the application of theorem proving to problem solving, Artif. Intell. 2 (1971) 189–208.[23] D. Fisman, O. Kupferman, Y. Lustig, Rational synthesis, in: 16th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS’10, in: LNCS, vol. 6015, Springer, 2010, pp. 190–204.[24] D. Gale, L.S. Shapley, College admissions and the stability of marriage, Am. Math. Mon. 69 (1) (1962) 9–15.[25] M. Ghallab, D. Nau, P. Traverso, Automated Planning: Theory and Practice, Morgan Kaufmann Publishers, San Mateo, CA, 2004.[26] J. Grant, S. Kraus, M. Wooldridge, I. Zuckerman, Manipulating games by sharing information, Stud. Log. 102 (2014) 267–295.[27] D. Gusfield, R.W. Irving, The Stable Marriage Problem: Structure and Algorithms, MIT Press, Cambridge, MA, USA, 1989.[28] J. Gutierrez, P. Harrenstein, G. Perelli, M. Wooldridge, Expressiveness and Nash equilibrium in iterated Boolean games, in: C.M. Jonker, S. Marsella, J. Thangarajah, K. Tuyls (Eds.), Proceedings of the 2016 International Conference on Autonomous Agents and Multiagent Systems, AAMAS’16, ACM, 2016, pp. 707–715.[29] J. Gutierrez, P. Harrenstein, M. Wooldridge, Iterated Boolean games, in: F. Rossi (Ed.), Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence, IJCAI’13, IJCAI/AAAI Press, 2013, pp. 932–938.[30] J. Gutierrez, P. Harrenstein, M. Wooldridge, Reasoning about equilibria in game-like concurrent systems, in: C. Baral, G. De Giacomo, Th. Eiter (Eds.), Proceedings of the Fourteenth International Conference on Principles of Knowledge Representation and Reasoning, KR’14, Vienna, Austria, AAAI Press, 2014.[31] J. Gutierrez, P. Harrenstein, M. Wooldridge, Expressiveness and complexity results for strategic reasoning, in: Proceedings of the Twenty-Sixth Annual Conference on Concurrency Theory, CONCUR’15, Madrid, Spain, in: Leibniz International Proceedings in Informatics (LIPIcs), vol. 42, 2015, pp. 268–282.[32] J. Gutierrez, P. Harrenstein, M. Wooldridge, Iterated Boolean games, Inf. Comput. 242 (2015) 53–79.[33] J. Gutierrez, P. Harrenstein, M. Wooldridge, Reasoning about equilibria in game-like concurrent systems, Ann. Pure Appl. Logic 169 (2) (2017) 373–403.[34] J. Gutierrez, G. Perelli, M. Wooldridge, Imperfect information in reactive modules games, in: C. Baral, J.P. Delgrande, F. Wolter (Eds.), Proceedings of the Fifteenth International Conference on Principles of Knowledge Representation and Reasoning, KR’16, AAAI Press, 2016, pp. 390–400.[35] J. Gutierrez, M. Wooldridge, Equilibria of concurrent games on event structures, in: Proceedings of the Joint Meeting of the Twenty-Third EACSL Annual Conference on Computer Science Logic, CSL’14, and the Twenty-Ninth Annual ACM/IEEE Symposium on Logic in Computer Science, LICS’14, Vienna, Austria, 2014, Article No. 46.[36] P. Harrenstein, Logic in Conflict, PhD thesis, Utrecht University, 2004.[37] P. Harrenstein, W. van der Hoek, J.-J.Ch. Meyer, C. Witteveen, Boolean games, in: J. van Benthem (Ed.), Proceedings of the Eighth Conference on Theoretical Aspects of Rationality and Knowledge, TARK’01, Siena, Italy, 2001, pp. 287–298.[38] M. Hennessy, R.A. Connolly Milner, Algebraic laws for nondeterminism and concurrency, J. ACM 32 (1) (1985) 137–161.[39] W. Jamroga, W. Penczek, Specification and verification of multi-agent systems, in: N. Bezhanishvili, V. Goranko (Eds.), Lectures on Logic and Computa-tion, in: LNCS, vol. 7388, Springer, 2012, pp. 210–263.[40] L. Kleinrock, Analysis of a time-shared processor, Nav. Res. Logist. Q. 11 (1) (1964) 59–73.[41] O. Kupferman, M.Y. Vardi, P. Wolper, An automata-theoretic approach to branching time model checking, J. ACM 47 (2) (2000) 312–360.[42] Orna Kupferman, P. Madhusudan, P.S. Thiagarajan, Moshe Y. Vardi, Open systems in reactive environments: control and synthesis, in: C. Palamidessi (Ed.), Proceedings of the Eleventh International Conference on Concurrency Theory, CONCUR’00, in: LNCS, vol. 1877, Springer, 2000, pp. 92–107.[43] M. Kwiatkowska, G. Norman, D. Parker, PRISM: probabilistic model checking for performance and reliability analysis, ACM SIGMETRICS Perform. Eval. Rev. 36 (4) (2009) 40–45.[44] L. Lamport, A new solution of Dijkstra’s concurrent programming problem, Commun. ACM 17 (8) (1974) 453–455.[45] D. Manlove, Algorithmics of Matching Under Preferences, World Scientific Publishing Company, 2013.[46] Z. Manna, A. Pnueli, The Temporal Logic of Reactive and Concurrent Systems, Springer, 1992.[47] Z. Manna, A. Pnueli, Temporal Verification of Reactive Systems — Safety, Springer, 1995.[48] E. Marchioni, M. Wooldridge, Łukasiewicz games: a logic-based approach to quantitative strategic interactions, ACM Trans. Comput. Log. 16 (4) (2015), Article No. 33.[49] M. Maschler, E. Solan, S. Zamir, Game Theory, Cambridge University Press, Cambridge, England, 2013.[50] F. Mogavero, A. Murano, G. Perelli, M.Y. Vardi, Reasoning about strategies: on the model-checking problem, ACM Trans. Comput. Log. 15 (4) (2014).J. Gutierrez et al. / Artificial Intelligence 248 (2017) 123–157157land, 2008.[51] F. Mogavero, A. Murano, M.Y. Vardi, Reasoning about strategies, in: K. Lodaya, M. Mahajan (Eds.), Proceedings of the IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS’10, in: Leibniz International Proceedings in Informatics (LIPIcs), vol. 8, 2010, pp. 133–144.[52] N. Nisan, T. Rougarden, E. Tardos, V.V. Vazirani (Eds.), Algorithmic Game Theory, Cambridge University Press, Cambridge, England, 2007.[53] M.J. Osborne, A. Rubinstein, A Course in Game Theory, The MIT Press, Cambridge, MA, 1994.[54] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.[55] G.L. Peterson, Myths about the mutual exclusion problem, Inf. Process. Lett. 12 (3) (1981) 115–116.[56] A. Pnueli, The temporal logic of programs, in: Proceedings of the Eighteenth IEEE Symposium on the Foundations of Computer Science, FOCS’77, The Society, 1977, pp. 46–57.[57] A. Pnueli, R. Rosner, On the synthesis of an asynchronous reactive module, in: G. Ausiello, M. Dezani-Ciancaglini, S. Ronchi Della Rocca (Eds.), Proceed-ings of the Sixteenth International Colloquium on Automata, Languages, and Programs, ICALP’89, 1989, pp. 652–671.[58] A.S. Rao, M. Georgeff, Decision procedures for BDI logics, J. Log. Comput. 8 (3) (1998) 293–344.[59] G. Ricart, A.K. Agrawala, An optimal algorithm for mutual exclusion in computer networks, Commun. ACM 24 (1) (1981) 9–17.[60] A.E. Roth, M.A.O. Sotomayor, Two-Sided Matching: A Study in Game Theoretic Modelling and Analysis, Cambridge University Press, 1990.[61] T.C. Schelling, The Strategy of Conflict, Harvard University Press, 1981.[62] Y. Shoham, K. Leyton-Brown, Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations, Cambridge University Press, Cambridge, Eng-[63] A.P. Sistla, E.M. Clarke, The complexity of propositional linear temporal logics, J. ACM 32 (3) (1985) 733–749.[64] L.J. Stockmeyer, A.K. Chandra, Provably difficult combinatorial games, SIAM J. Comput. 8 (2) (1979) 151–174.[65] A. Toumi, J. Gutierrez, M. Wooldridge, A tool for the automated verification of Nash equilibria in concurrent games, in: M. Leucker, C. Rueda, F.D. Valencia (Eds.), Proceedings of the Twelfth International Colloquium on Theoretical Aspects of Computing, ICTAC’15, in: LNCS, vol. 9399, Springer, 2015, pp. 583–594.[66] W. van der Hoek, W. Jamroga, M. Wooldridge, A logic for strategic reasoning, in: M. Pechoucek, D. Steiner, S. Thompson (Eds.), Proceedings of the Fourth International Joint Conference on Autonomous Agents and Multiagent Systems, AAMAS’05, 2005, pp. 157–164.[67] W. van der Hoek, A. Lomuscio, M. Wooldridge, On the complexity of practical ATL model checking, in: H. Nakashima, M.P. Wellman, G. Weiss, P. Stone (Eds.), Proceedings of the Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, AAMAS’06, ACM, 2006, pp. 201–208.[68] W. van der Hoek, M. Wooldridge, Towards a logic of rational agency, Log. J. IGPL 11 (2) (2003) 135–159.[69] M.Y. Vardi, P. Wolper, An automata-theoretic approach to automatic program verification, in: First Symposium in Logic in Computer Science, LICS’86, IEEE Computer Society, 1986, pp. 322–331.vol. 2, Amsterdam University Press, 2008, pp. 629–736.[70] Moshe Y. Vardi, Thomas Wilke, Automata: from logics to algorithms, in: Logic and Automata: History and Perspectives, in: Texts in Logic and Games, [71] Glynn Winskel, Event structures, in: W. Brauer, W. Reisig, G. Rozenberg (Eds.), Advances in Petri Nets 1986. Proceedings of an Advanced Course, Bad Honnef, 8.–19. September 1986, Part 2: Petri Nets: Applications and Relationships to Other Models of Concurrency, in: LNCS, vol. 255, 1987, pp. 325–392.[72] M. Wooldridge, An Introduction to Multiagent Systems, second edition, John Wiley & Sons, 2009.[73] M. Wooldridge, Bad equilibria (and what to do about them), in: L. De Raedt, C. Bessiere, D. Dubois, P. Doherty, P. Frasconi, F. Heintz, P. Lucas (Eds.), Proceedings of the Twentieth European Conference on Artificial Intelligence, ECAI’12, Montpellier, France, 2012, pp. 6–11.[74] M. Wooldridge, U. Endriss, S. Kraus, J. Lang, Incentive engineering for boolean games, Artif. Intell. 195 (2013) 418–439.[75] M. Wooldridge, J. Gutierrez, P. Harrenstein, E. Marchioni, G. Perelli, A. Toumi, Rational verification: from model checking to equilibrium checking, in: D. Schuurmans, M. Wellman (Eds.), Proceedings of the Thirtieth AAAI Conference on Artificial Intelligence, AAAI’16, Phoenix, AZ, 2016, pp. 4184–4190.[76] M. Wooldridge, N.R. Jennings, Intelligent agents: theory and practice, Knowl. Eng. Rev. 10 (2) (1995) 115–152.