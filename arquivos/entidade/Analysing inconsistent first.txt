Artificial Intelligence 172 (2008) 1064–1093www.elsevier.com/locate/artintAnalysing inconsistent first-order knowledgebasesJohn Grant a,b, Anthony Hunter c,∗a Department of Mathematics, Towson University, Towson, MD 21252, USAb Department of Computer Science, University of Maryland, College Park, MD 20742, USAc Department of Computer Science, University College London, Gower Street, London WC1E 6BT, UKReceived 31 December 2006; received in revised form 14 November 2007; accepted 14 November 2007Available online 22 November 2007AbstractIt is well-known that knowledgebases may contain inconsistencies. We provide a framework of measures, based on a first-orderfour-valued logic, to quantify the inconsistency of a knowledgebase. This allows for the comparison of the inconsistency of diverseknowledgebases that have been represented as sets of first-order logic formulae. We motivate the approach by considering someexamples of knowledgebases for representing and reasoning with ontological knowledge and with temporal knowledge. Analysingontological knowledge (including the statements about which concepts are subconcepts of other concepts, and which conceptsare disjoint) can be problematical when there is a lack of knowledge about the instances that may populate the concepts, andanalysing temporal knowledge (such as temporal integrity constraints) can be problematical when considering infinite linear timelines isomorphic to the natural numbers or the real numbers or more complex structures such as branching time lines. We addressthese difficulties by providing algebraic measures of inconsistency in first-order knowledgebases.© 2007 Elsevier B.V. All rights reserved.Keywords: Measuring inconsistency; Paraconsistent logics; Inconsistency tolerance; Analysing inconsistency; Conflict resolution1. IntroductionThe need for handling inconsistencies in knowledgebases has been well recognised in recent years. Inconsistenciesmay arise for various reasons such as when information sources are merged or in the presence of integrity constraints.The use of first-order logic becomes problematical because a single (local) inconsistency leads to the (global) incon-sistency of the entire knowledgebase. Paraconsistent logics allow for local inconsistency without global inconsistency.Paraconsistent reasoning is important in handling inconsistent information, and there have been a number of proposalsfor paraconsistent logics, such as Da Costa’s Cω logics [11], developments of C systems [9], Priest’s three-valued logicLPm [33], Belnap’s four-valued logic [5], and versions of Belnap’s four-valued logic restricted to minimal models [1],for reasoning with inconsistent information. Further approaches, such as techniques for analysing and querying incon-sistent databases and knowledgebases [2,3,12,31], techniques for merging knowledgebases [4,7,27,28], and analyticaltechniques for inconsistent software specifications [19], have been proposed (for reviews of some applications see* Corresponding author.E-mail addresses: jgrant@towson.edu (J. Grant), a.hunter@cs.ucl.ac.uk (A. Hunter).0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2007.11.006J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931065[6,16]). Whilst these methods provide potentially valuable ways of using inconsistent knowledgebases, they do notprovide an adequate way of summarising the nature of the inconsistencies.Our interest in this paper is in providing a measure for the inconsistency of a knowledgebase represented as a set offirst-order logic formulae. By providing such a measure we can compare different knowledgebases and evaluate theirquality of information. If given the opportunity to choose between different knowledgebases, we may try to choosethe one that is least inconsistent.Four-valued paraconsistent logics have been used as the basis of an approach to measuring inconsistency in knowl-edgebases [14,20,21]. In this, each inconsistent set of formulae is reflected in the four-valued models for the set, andthen the inconsistency is measured in the models. This approach to measuring inconsistency has already been seen asa useful tool in analysing a diverse range of information types including news reports [23], integrity constraints [14],ontologies [32], software specifications [8,30], and ecommerce protocols [10]. However, this approach of measuringinconsistency has been restricted to either a propositional language or a language with predicates but without functionsymbols.In this paper, we present a framework for measuring inconsistency for a full first-order language, together withexamples in analysing ontological and temporal knowledge. Dealing with a full first-order language is potentiallyimportant in diverse applications (such as reasoning about specifications [13]), but it does also raise issues with regardto analysing arbitrarily large, including infinite, domains. To address these issues, our framework provides algebraicmeasures of inconsistency in first-order knowledgebases.2. Overview of our approachIn this section, we provide an informal overview of our approach together with some examples to motivate andillustrate our approach. We start by recalling that many diverse applications in computer science require the ability torepresent and reason with knowledge in a form that is more expressive than propositional logic. Furthermore, in manyapplications, there is a need to analyse inconsistency arising in knowledge.To illustrate the need for systems and/or users to analyse inconsistency, consider diverse applications such as toolsfor analysing formal software specifications (where parts of the specifications may have come from different sources),systems for disambiguation in natural language processing (where there are conflicting syntactic, semantic, or prag-matic parses of the text/speech being parsed), and tools for developing ontologies based on description logics (wherethere may be multiple ontologies perhaps from multiple sources that need to be combined by an ontology engineerinto a single coherent and consistent ontology). In these examples, and in many other potential applications, there iseither the need for an automatic system to analyse the degree of inconsistency arising in the available knowledge, orthere is the need for a system to provide a user (such as a software or knowledge engineer) with an assessment of thedegree of inconsistency arising in the available knowledge. Once the system/user has access to an assessment of thedegree of inconsistency, the system/user can make a more intelligent and better informed decision on the course ofaction to take on the inconsistency.In this paper we assume a knowledgebase is a set of formulae of classical first-order logic. We impose no restrictionson this. It can include function symbols, variable symbols, and quantifier symbols. And of course, a knowledgebasecan be inconsistent, and indeed, any formula in a knowledgebase may be inconsistent.Our approach to measuring inconsistency in a knowledgebase is to consider the “four-valued models” of it. Each ofthese models is based on what we call a bistructure, which essentially is a pair of classical interpretations: One of theseinterpretations is used for the satisfaction of positive literals (i.e. the atoms), and the other is used for the satisfactionof negative literals. So in a bistructure, both an atom and its negation, or neither, can be satisfied. This gives a four-valued semantics, so that an atom may be regarded as being exactly one of “true” or “false” or “both true and false”or “neither true nor false” in a bistructure. The semantics for more complex formulae is given by a generalisation ofBelnap’s four valued logic, which is a paraconsistent logic that we call tolerant logic. For our purposes, this semanticsis simple and the set of models for any knowledgebase is always nonempty.Given a bistructure, we apply a simple measure of inconsistency, denoted Inc, that gives the proportion of the tuplesin the bistructure that are in conflict. The amount of conflict in a bistructure is the number of tuples that are both trueand false. This is normalised by the total number of tuples that are possible in the interpretations (which is a functionof the size of the domain), so we get a value in the [0, 1] interval. For example, if we have a bistructure with just onemonadic relation R and two domain objects a1 and a2, and the first classical interpretation has both (cid:3)a1(cid:4) and (cid:3)a2(cid:4) (for1066J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093R), and the second classical interpretation has (cid:3)a1(cid:4) (for ¬R), then there is conflict with respect to the tuple (cid:3)a1(cid:4) andso the proportion of tuples in conflict is 1/2. Note, this measure is not restricted to Herbrand interpretations.We then generalise this measure of inconsistency to sets of bistructures. In order to set up our framework, andconsider various properties, we deal with sets of bistructures in general. But in practice, if we want to analyse aknowledgebase, we consider the set of models for the knowledgebase.For a knowledgebase, since our measure of inconsistency of a model is dependent on the domain size, we considerthe models for each domain size in turn. For each domain size, we find the minimum degree of inconsistency in amodel from the models of this size, using a function denoted MicroInc, and then we summarise this value obtained foreach size in the form of a ratio of univariate polynomial functions (i.e. a rational function) where the variable is thecardinality of the domain. The polynomial that is the numerator gives the minimum number of tuples in conflict forthe models of domain size n, and the polynomial that is the denominator gives the maximum number of tuples in themodels of domain size n. By representing the degree of inconsistency in the form of such a rational function, we havea concise summary of the nature of the inconsistency for any domain size. Furthermore, it provides a direct way ofcomparing knowledgebases in terms of their respective rational functions.To illustrate our approach, we now look at examples of knowledgebases to show some of the key aspects ofmeasuring inconsistency. We start with some simple examples based on pairs of formulae taken from the followinglist of formulae (A1)–(A7). For each pair we consider, for example (A2, A3), imagine there are two agents who haveprovided the formulae, and these two agents need to jointly provide a formula that they both can agree on. Perhapsthe agents need to do this as part of a requirements capture process for some software system for which the agents arestakeholders. So each formula represents the requirements of one of the agents. By measuring the inconsistency ofthe union of the two formulae, we get a measure of how divergent the two agents are in their positions. Furthermore,if the agents are negotiating, they may withdraw one or both formulae, and replace them with formulae that are lessinconsistent. Such a negotiation may be undertaken with the aim of finding a pair of formulae that are consistenttogether.(A1) P (a)(A2) ¬P (a)(A3) ∀x.P (x)(A4) ∃x.¬P (x)(A5) ¬∃x.P (x)(A6) ∀x.¬P (x)(A7) ∀x.¬P (f (x))For the pair (A1, A2), we may describe this as an “atomic conflict” (A1 says one domain object is in the inter-pretation for P whereas A2 says that one domain object is in the interpretation for the negation of P ). For the pairs(A2, A3) and (A3, A4), we have something similar to the case for (A1, A2), in that there is at least one domain objectin conflict. So, for each of the pairs (A1, A2), (A2, A3), and (A3, A4), if our knowledgebase contains just the twoformulae in the pair, then we will calculate the measure of inconsistency as the rational function 1/n, and in the limit,as n goes to infinity, the degree of inconsistency is 0.For the pairs (A3, A5) and (A3, A6), we have more significant inconsistency. In the models, all domain objects arein conflict in each pair. So, for each of (A3, A5) and (A3, A6), if the knowledgebase contains just the two formulae inthe pair, then we will calculate the measure of inconsistency as the rational function n/n, and in the limit, the degreeof inconsistency is 1.For the pair (A3, A7), we have something similar to the pair (A3, A6), but here we also need to consider thefunction symbol f in the right formula. If we consider the models with the fewest conflicts (which we will see are themodels we want to base our measures on), then the interpretation of the function symbol should be a constant function,i.e. there is c ∈ D such that for all d ∈ D, f (d) = c. In this case, there is one domain object in conflict, namely thec just mentioned. So, for (A3, A7), if the knowledgebase contains just the two formulae in the pair, then we willcalculate the measure of inconsistency as the rational function 1/n, and in the limit, the degree of inconsistencyis 0.We now consider examples of ontological knowledge. Whilst description logics are now the leading approachto formalising ontological knowledge, the basic description logics are actually subsystems of classical logic; so itJ. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931067is straightforward to present examples of ontological knowledge in the form of classical logic. For this, we adoptthe following conventions: (1) A concept P is represented by a monadic predicate P (x); (2) An individual c thatis a member of a concept P is represented by a ground predicate P (c); (3) The relationship that the concept Q isa subconcept of the concept P is represented by ∀x.Q(x) → P (x); and (4) The relationship that the concept Q isdisjoint with the concept P is represented by ∀x.Q(x) → ¬P (x) ∧ ∀x.P (x) → ¬Q(x).We see a key advantage of our approach for analysing an ontology (when it is under development) if we consider theneed to analyse the structure (i.e. the concepts and their inter-relationships) without knowing about the instances thatmay populate it. For example, for a medical records ontology, the ontology engineer should have obtained knowledgethat for example the concept heart surgery is a subclass of the concept surgery, and that male and female are disjointconcepts, but the ontology engineer cannot be expected to have a list of all the patients of the hospital in the future.Hence, when the ontology is being developed, the number of instances that will be in the ontology is unknown. Ourapproach directly deals with this issue, since we can consider an arbitrarily large number of instances, which we do byconsidering an arbitrary-sized domain. In other words, our measure of inconsistency, captured by a rational function,is a representation of the inconsistency for each domain size.We start by considering the formulae (B1)–(B4). These formulae are not inconsistent. They say that S is a sub-concept of R, Q is a subconcept of P , Q and S are disjoint, and P and R are disjoint. However, if we also have theassumption (B5) that says that there is an instance in S and Q, then we do have an inconsistency.(B1) ∀x.S(x) → R(x)(B2) ∀x.(Q(x) → ¬S(x) ∧ S(x) → ¬Q(x))(B3) ∀x.Q(x) → P (x)(B4) ∀x.(P (x) → ¬R(x) ∧ R(x) → ¬P (x))(B5) ∃x.S(x) ∧ Q(x)So without knowing anything about the actual membership of these concepts, we can analyse the inconsistency inthis ontological knowledge. For (B1)–(B5), we will see in Example 15, that the rational function is 1/n. This meansthat as the size of the domain increases, the inconsistency is diluted, and in the limit, the degree of inconsistency isreduced to zero.As another example of ontological knowledge, consider (C1)–(C7) which are inconsistent. For this, we will see(in Example 17) that the degree of inconsistency is given by the rational function 1/3. So as the size of the domainincreases, the inconsistency is not diluted, and in the limit, the degree of inconsistency is 1/3. Furthermore, if wecompare (B1)–(B5) and (C1)–(C7), for n > 3, the rational function for (C1)–(C7) is always greater than that for(B1)–(B5), and so we can regard (C1)–(C7) as more inconsistent than (B1)–(B5).(C1) ∀x.S(x) → R(x)(C2) ∀x.Q(x) → P (x)(C3) ∀x.(Q(x) → ¬S(x) ∧ S(x) → ¬Q(x))(C4) ∀x.(P (x) → ¬R(x) ∧ R(x) → ¬P (x))(C5) ∀x.(T (x) → ¬U (x) ∧ U (x) → ¬T (x))(C6) ∀x.(T (x) → U (x) ∧ U (x) → T (x))(C7) ∀x.T (x) ∨ U (x)We now turn to temporal knowledge. The following set of formulae (D1)–(D3) is consistent in classical logic butthe set is only satisfied by an infinite model such as one based on the sequence of the natural numbers. Such a setof formulae may appear as part of a specification for time-stamping locutions in a dialogue protocol between twointeracting agents.(D1) ∀x, ∃y.R(x, y)(D2) ∀x, y.(R(x, y) → ¬R(y, x))(D3) ∀x, y, z.(R(x, y) ∧ R(y, z) → R(x, z))1068J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093Now suppose the formula (D4) is added to (D1)–(D3); then the set is inconsistent. However, in a sense, the conflictis extremely small, and so any bistructure for it is “overwhelmingly consistent”. In contrast, if the following formula(D5) is added to (D1)–(D3), then the set is inconsistent, and in a sense, the conflict is extremely large, and so anybistructure for it is “substantially inconsistent”.(D4) R(1, 1)(D5) ∀x.R(x, x)In our framework, we will provide a degree of inconsistency to account for inconsistency in infinite models (allowingus for example to differentiate between the inconsistency in the set {D1, D2, D3, D4}, and the set {D1, D2, D3, D5}),and explore some of the relationships between them, as well as with the degree of inconsistency for finite models.We will also provide a measure of the consistency of an infinite model which provides an alternative dimension foranalysing an infinite model.Since the proposal in this paper is the first proposal for measuring inconsistency in full first-order logic (includinginfinite models), our approach offers considerable advantages for applications in artificial intelligence and computerscience involving first-order knowledge. A number of other proposals have been made for measuring the degree ofinformation in the presence of inconsistency [24,26,29,37], and for measuring the degree of inconsistency in infor-mation [14,15,17,18,20–22,24–26,36]. All these proposals are based on propositional logic, apart from [15] and [14],with the former primarily investigating the mathematical structure of various inconsistency measures, while the latteris based on a restricted form of first-order logic. Furthermore, there are six key improvements in this new paper overthe [14] paper:1. In [14] we only considered a restricted first-order language with universal and existential quantification but with-out function symbols (apart from constant symbols) whereas in this paper we consider full first-order logic, andtherefore in this paper we are able to handle a wider range of knowledgebases.2. In [14] we only considered Herbrand interpretations, whereas in this paper, we consider any first-order interpre-tation, and therefore we drop some constraints that are inappropriate for some applications.3. In [14] we only considered finite interpretations, whereas in this paper, we consider both finite and infinite inter-pretations, and therefore in this paper we are able to handle a wider range of knowledgebases.4. In [14] we used quasi-classical logic to find the four-valued models of a knowledgebase, whereas in this paperwe use a first-order version of Belnap’s logic, and as a result we have a simpler logic for finding the models for aknowledgebase.5. In [14] the measure of inconsistency for a knowledgebase was summarised by a sequence of numbers(cid:3)n1, n2, n3, . . .(cid:4) (where n1 is the measure for a domain of cardinality 1, n2 is the measure for a domain ofcardinality 2, and so on), whereas in this paper, the measure of inconsistency for a knowledgebase is summarisedby a ratio of univariate polynomial functions (i.e. a rational function).6. In [14] we did not consider limit behaviour of measures, whereas in this paper we provide a characterisation ofmeasures in terms of limit behaviour.In the following sections, we formalise our approach a follows. In Section 3 we review the basic definitions for thelanguage and semantics of first-order logic that we require. In Section 4 we present a first-order version of the seman-tics for Belnap’s four-valued logic, called tolerant logic, that we will use to find the models for a knowledgebase. InSection 5 we consider some classes of interpretations that allow us to restrict the models considered for a knowledge-base (e.g. for temporal knowledge, we may wish to restrict consideration to models with elements corresponding tothe real numbers). In Section 6 we consider measures for a finite set of finite models (which we call a bounded frame),for a set of finite models that includes a model of every domain size (which we call an unbounded frame), and for aset of models that includes an infinite model (which we call an infinite frame). In Section 7 we consider a frameworkfor measuring consistency which is a counterpart to our framework for measuring inconsistency. Finally, in Section 8we show that the semantics for tolerant logic subsumes the semantics for Belnap’s logic.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–109310693. Basic definitions for a first-order logicIn this section, we provide some basic definitions and notation that are used for presenting a first-order logic (FOL).The language for FOL contains logical symbols: connectives {¬, ∨, ∧, →}, quantifiers {∀, ∃}, punctuation symbols(parentheses, comma, and period), and an infinite set of variables. A specific language L is determined by its predicate,constant, and function symbols; these we consider the nonlogical symbols that must be provided in a language. Weassume that the number of predicate and function symbols is finite. We sometimes write P (n) to indicate that P is ann-ary predicate symbol.We adopt the following conventions for our notation.• Uppercase letters like P and R for predicate symbols.• Lowercase letters like f , g, and h, perhaps with subscript, for function symbols.• Lowercase letters like a, b, c, and d, perhaps with subscript, for constant symbols.• Lowercase letters like x and y, perhaps with subscript, for variable symbols.• Lowercase letters like t and s, perhaps with subscript, for terms.We assume the usual classical definitions for a language including definitions for a free variable, a bound variable,and a ground formula. An atom is of the form P (t1, . . . , tn), where t1, . . . , tn are terms. As usual, a literal is either anatom or the negation of an atom. The set of formulae is defined by the usual inductive definitions for classical logic.We use the Greek letters α, β, γ for literals, φ for a clause (a disjunction of literals), ψ for a conjunction of clauses,and θ for any formula. For a language L, the set of formulae that can be formed by the usual inductive definitions isdenoted Formulae(L). We will usually not specify L and assume that given a knowledgebase Δ, L is the languagethat contains exactly the nonlogical (i.e. constant, function, and predicate) symbols that appear in Δ.We now consider the classical semantics for FOL.Definition 1. A classical structure for the language L is a pair (D, I ), where D is a nonempty set called the domainand I is a function called an interpretation that makes assignments to the symbols of L as follows:1. For every constant symbol c, I (c) ∈ D.2. For every function symbol f of arity n > 0, I (f ) : Dn (cid:11)→ D is an n-ary function.3. For every predicate symbol P of arity n > 0, I (P ) ⊆ Dn is an n-ary relation.We handle variables in FOL formulae using the standard notion of an assignment.Definition 2. Let (D, I ) be a classical structure, and let V be the set of variable symbols in L. An assignment A for(D, I ) is a function A : V (cid:11)→ D. Given an assignment A, an x-variant assignment A(cid:13) is the same as A except perhapsin the assignment for the variable x.Whilst the definitions for language and interpretations considered in this section are those of classical logic, wewill use them for a paraconsistent logic in the next section.In order to consider properties of our framework, we also require the classical consequence relation, denoted (cid:14).We assume ⊥ is shorthand for any classically inconsistent formula. However, in order to simplify the presentation weassume that ⊥ is not in the language L. For a knowledgebase Δ ⊆ Formulae(L), as a shorthand we write Δ (cid:14) ⊥ toindicate that Δ is inconsistent in classical logic; otherwise we write Δ (cid:16)(cid:14) ⊥.4. Tolerant logicWe now present the definitions for tolerant logic which is a first-order four-valued logic. The language for tolerantlogic is that of FOL. However, the semantics is different; that is why tolerant logic supports paraconsistent reasoning.The notion of a bistructure in tolerant logic is based on the notion of a classical interpretation. The basic differenceis that for tolerant logic we use a pair of classical interpretations to give a tolerant interpretation.1070J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093Definition 3. A bistructure is a tuple (D, I +, I −) where (D, I +) and (D, I −) are classical interpretations, and for allconstant symbols c, I +(c) = I −(c), and for all function symbols f , I +(f ) = I −(f ).The above definition ensures that in a bistructure (D, I +, I −) both the classical interpretations I + and I − usethe same domain object for each constant symbol, and the same function in the domain for each function symbol.Therefore the classical interpretations I + and I − in a bistructure can only differ in their assignment to predicatesymbols. As a result, we can use I + as the interpretation for positive literals and I − as the interpretation for negativeliterals. This is formalised in the definition for decoupled satisfaction.Definition 4. For a bistructure E = (D, I +, I −) and an assignment A, we define a satisfiability relation, |=d , calleddecoupled satisfaction for literals in L as follows:(E, A) |=d P (t1, . . . , tn)(E, A) |=d ¬P (t1, . . . , tn)where for 1 (cid:2) i (cid:2) n,(cid:2)∗(cid:2)iffIiff(t1), . . . , I∗I(t1), . . . , I∗+(cid:3)(tn)∗∈ I(cid:3)(tn)∈ I(P )−(P )• if ti is a variable, then I ∗(ti) = I +(A(ti)) = I −(A(ti))• if ti is a constant, then I ∗(ti) = I +(ti) = I −(ti)• if ti is of the form f (s1, . . . , sm), then I ∗(ti) = I +(f )(I ∗(s1), . . . , I ∗(sm)) = I −(f )(I ∗(s1), . . . , I ∗(sm))Since we allow both an atom and its complement to be satisfiable, we have decoupled, at the level of the structure,the link between an atom and its complement. In contrast, if a classical structure satisfies a literal, then it is forced tonot satisfy the complement of the literal. This decoupling gives the basis for a semantics for paraconsistent reasoning.In the following definition for satisfiability for arbitrary formulae, we provide a partial coupling (i.e. a couplingthat is weaker than in classical logic) for a formula and its complement. In the propositional case, this definition ofsatisfiability coincides with that of Belnap’s four-valued logic [5], which is a propositional logic that has a four-valuedlattice-theoretic interpretation of connectives (see Theorem 5).Definition 5. Let E be a bistructure and let A be an assignment. The satisfiability relation, denoted |=, is defined byinduction on the length of a formula as follows where α is a literal, and θ , θ1, and θ2 are arbitrary formulae.iff(E, A) |= α iff(E, A) |= θ1 ∨ θ2(E, A) |= θ1 ∧ θ2(E, A) |= θ1 → θ2(E, A) |= ¬¬θiff(E, A) |= ¬(θ1 ∨ θ2)(E, A) |= ¬(θ1 ∧ θ2)(E, A) |= ¬(θ1 → θ2)(E, A) |= ∃x.θ(E, A) |= ∀x.θ(E, A) |= ¬∃x.θ(E, A) |= ¬∀x.θiffiffiffiff(E, A) |=d αiff(E, A) |= θ1 or (E, A) |= θ2(E, A) |= θ1 and (E, A) |= θ2(E, A) |= ¬θ1 or (E, A) |= θ2iff(E, A) |= θiffiffiff(E, A) |= ¬θ1 and (E, A) |= ¬θ2(E, A) |= ¬θ1 or (E, A) |= ¬θ2(E, A) |= θ1 and (E, A) |= ¬θ2(cid:13)for some x-variant assignment A(cid:13)for all x-variant assignments A(cid:13), (E, A(cid:13), (E, A) |= θ) |= θ(E, A) |= ∀x.¬θ(E, A) |= ∃x.¬θIn Definition 5, the first condition defines satisfaction for literals, the second to fourth conditions define satisfactionfor conjunction, disjunction, and implication, respectively, the fifth to eighth conditions define satisfaction for nega-tion, and the ninth to twelfth conditions define satisfaction for quantification. We extend satisfaction to a bistructurein the next definition.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931071Definition 6. Let E be a bistructure and θ an arbitrary formula.E |= θifffor all assignments A, (E, A) |= θExample 1. Let L contain the predicate symbols P (2) and Q(1), the function symbol f (1), and the constant symbolsc1, c2, and c3. Let E = (D, I +, I −) be such that D = {d1, d2, d3} and the interpretations I + and I − are as follows.++++IIII++I(c2) = d1,+(c1) = I(f )(d1) = d2,(cid:4)(P ) =(Q) =I(cid:5)(cid:3)d1, d3(cid:4), (cid:3)d3, d3(cid:4)(cid:5)(cid:4)(cid:3)d2(cid:4)I,(c3) = d3(f )(d2) = d3,−,(Q) = {}−II(P ) =+(f )(d3) = d3(cid:5)(cid:4)(cid:3)d1, d3(cid:4)Here, we see that (cid:3)d1, d3(cid:4) is in both I +(P ) and I −(P ). Since, I +(c1) = d1 and I +(c3) = d3, we have by Definition 3that I −(c1) = d1 and I −(c3) = d3. Hence, for all assignments A, we get E |= P (c1, c3) and E |= ¬P (c1, c3). Incontrast, we see that (cid:3)d3, d3(cid:4) is in I +(P ) but not in I −(P ). Hence, for all assignments A, we get E |= P (c3, c3) butnot E |= ¬P (c3, c3). Similarly, (cid:3)d2(cid:4) is in I +(Q) but not in I −(Q), and I +(f )(d1) = d2, and I +(c1) = d1. Hence, forall assignments A, we get E |= Q(f (c1)) but not E |= ¬Q(f (c1)).Next we define the concept of a model.Definition 7. Let Δ be a set of formulae and let E be a bistructure. E is a model of Δ iff for all θ ∈ Δ, E |= θ .In the next section, we will consider classes of models for tolerant logic and then we will return to studying TolerantLogic, in Section 8, where we will show how tolerant logic generalises Belnap’s logic.5. Classes of models for knowledgebasesWe start with the class of all models for a knowledgebase (Definition 8) and then consider subclasses (Definitions 9–13) that will allow us to focus our analysis of inconsistency in knowledgebases using appropriate assumptions withouthaving to add extra formulae to a knowledgebase or add further constraints on the semantics.Definition 8. For a set of formulae Δ, Models(Δ) = {E | E |= θ for all θ ∈ Δ}.Next we consider a definition that gives the models that satisfy the unique names assumption (UNA), meaning thatdifferent constant symbols are assigned to different objects in the domain. In other words, each constant is treated asa unique name.Definition 9. Let Δ be a set of formulae.(cid:4)(cid:6)(cid:7)UNAModels(Δ) =D, I−+, I∈ Models(Δ) | for all c, c(cid:13)if c (cid:16)= c(cid:13)then I+(c) (cid:16)= I+(c(cid:13)(cid:5))Example 2. Let E = (D, I +, I −) be such that D = {d1, d2, d3} and the interpretations I + and I − are as follows.++II−(c1) = d1,(P ) =(c2) = d2,(cid:5)(cid:3)d1, d3(cid:4), (cid:3)d3, d3(cid:4),(cid:4)I+II(c3) = d3(cid:5)(cid:4)−(cid:3)d2, d3(cid:4)(P ) =If Δ = {P (c1, c3), ¬P (c2, c3), P (c3, c3)}, then E ∈ UNAModels(Δ).As an illustration of the utility of measures of inconsistency, we will consider in the next section some examples ofknowledgebases that define sets and subsets of concepts (i.e. a form of ontological knowledge). For this, we will usethe following class of models.1072J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093Definition 10. Let Δ be a set of formulae.ConceptModels(Δ) =(cid:4)E ∈ Models(Δ) |for each formula of the form ∀x.α → β ∈ Δ,for each assignment A,if (E, A) |= α then (E, A) |= β(cid:5)Example 3. Let E = (D, I +, I −) be such that D = {d1, d2, d3} and the interpretations I + and I − are as follows.+++III++(cid:4)(c1) = d1,(P ) =(Q) =(c2) = d2,I(cid:5)−(cid:3)d1(cid:4), (cid:3)d2(cid:4)I,(cid:5)(cid:4)(cid:3)d1(cid:4), (cid:3)d2(cid:4), (cid:3)d3(cid:4),I(P ) =−I(c3) = d3(cid:5)(cid:4)(cid:3)d3(cid:4)(Q) = {}If Δ = {P (c1), ∀x.P (x) → Q(x)}, then E ∈ ConceptModels(Δ). Now consider E(cid:13) which is the same as E except thatI +(P ) = {(cid:3)d1(cid:4)} = I −(P ) and I +(Q) = {(cid:3)d2(cid:4), (cid:3)d3(cid:4)}. So E(cid:13) ∈ Models(Δ) \ ConceptModels(Δ).We will also consider the measurement of inconsistency in temporal knowledge. To facilitate this, we considermodels that conform to particular flows of time. Often temporal knowledge is represented using linear time lines,isomorphic to some or all of the natural numbers or the real numbers, or more complex structures such as branchingtime lines. These structures raise particular difficulties for analysis in the case of inconsistency.For modelling time flows, we need a predicate t1 (cid:17) t2 where t1 is before t2 in the flow of time. The language Lmay also contain additional predicate symbols as needed for the application. We also assume the following languagesfor use with time flows: Lk is the language that includes the (cid:17) relation and the constant symbols for the sequenceof natural numbers from 1 to k; Lp is the language that includes the (cid:17) relation and the constant symbols for thenatural numbers (positive integers); and Li is the language that includes the (cid:17) relation and the constant symbols forthe integers.Definition 11. Let Δ ⊆ Formulae(Lk) be a set of formulae.D, I +, I −FPModels(Δ) =(cid:4)(cid:6)(cid:7)∈ Models(Δ) | D is the sequence of natural numbers from 1 to kand ∀n ∈ {1, . . . , k}(I +(n) = n)and ∀c(I +(c) ∈ {1, . . . , k})and there is a predicate symbol (cid:17)s.t. I +((cid:17)) is the usual ordering over {1, . . . , k}(cid:5)\ I +((cid:17))and I −((cid:17)) =(cid:6){1, . . . , k} × {1, . . . , k}(cid:7)Definition 12. Let Δ ⊆ Formulae(Lp) be a set of formulae.D, I +, I −∈ Models(Δ) | D = NCPModels(Δ) =(cid:4)(cid:6)(cid:7)and ∀n ∈ N(I +(n) = n)and ∀c(I +(c) ∈ N)and there is a predicate symbol (cid:17)s.t. I +((cid:17)) is the usual ordering over N(cid:5)and I −((cid:17)) = N2 \ I +((cid:17))Definition 13. Let Δ ⊆ Formulae(Li) be a set of formulae.D, I +, I −∈ Models(Δ) | D = ZCIModels(Δ) =(cid:4)(cid:6)(cid:7)and ∀n ∈ Z(I +(n) = n)and ∀c(I +(c) ∈ Z)and there is a predicate symbol (cid:17)s.t. I +((cid:17)) is the usual ordering over Z(cid:5)and I −((cid:17)) = Z2 \ I +((cid:17))J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931073We can regard FPModels(Δ) as the models of Δ that are finite linear time models isomorphic to a subset of thenatural numbers (and so FP stands for finite positive integer models), CPModels(Δ) as the models of Δ that arelinear time models isomorphic to the natural numbers (and so CP stands for countable positive integer models), andCIModels(Δ) as the models of Δ that are linear time models isomorphic to the integers (and so CI stands for countableinteger models).In the following examples, we use the usual symbols for numbers for illustrating the elements of the domain andfor use as constant symbols in the language. It may be desirable in some situations, to use a different symbol for anumber in the domain and a number in the language, so that the difference between them is explicit.Example 4. Let E = (D, I +, I −) be such that D = {1, 2, 3, 4, 5, 6, 7} and the interpretations I + and I − are as follows.I +(4) = 4,(cid:4)I +(3) = 3,I +(2) = 2,(cid:5)(cid:3)1(cid:4), (cid:3)3(cid:4), (cid:3)5(cid:4), (cid:3)7(cid:4)(cid:5)(cid:3)2(cid:4), (cid:3)4(cid:4), (cid:3)6(cid:4)I +(1) = 1,(cid:4)I +(P ) =I −(P ) =I +((cid:17)) is the usual ordering over {1, . . . , 7}\ I +((cid:17))I −((cid:17)) ={1, . . . , 7} × {1, . . . , 7}If Δ = {P (1), ¬P (2), P (3)}, then E ∈ FPModels(Δ).(cid:7)(cid:6)I +(5) = 5,I +(6) = 6,I +(7) = 7Example 5. Let E = (D, I +, I −) be such that D = N and the interpretations I + and I − are as follows.(cid:4)(cid:5)for all n ∈ NI +(n) = n,(cid:4)I +(P ) =(cid:3)n(cid:4) | n ∈ NI −(P ) =(cid:3)n(cid:4) | n ∈ NI +((cid:17)) is the usual ordering over NI −((cid:17)) = N2 \ I +((cid:17))(cid:5)If Δ = {∀x.P (x), ∀x.¬P (x)}, then E ∈ CPModels(Δ).We can define further classes of models as required to capture for example continuous flows of time isomorphicto the real numbers and branching flows of time. We may also consider further constraints such as domain closureaxioms (e.g. [35]). Whilst we have not considered equality in this paper, it is possible to either adapt the definitionfor tolerant logic to support an equality relation in the semantics (in which case, it may be appropriate to assume thatfor any knowledgebase, the equality relation is never both true and false), or a form of quasi-equality is introduced byaxiomatisation (as proposed in [14]).For every set of formulae Δ, Models(Δ) is nonempty. Furthermore, for every n ∈ N, and for every Δ, there is amodel E ∈ Models(Δ) such that E = (D, I +, I −) and |D| = n. Even if the formulae in Δ involve many constantsymbols, there may be an interpretation that assigns the same element in the domain to some or all of these constantsymbols. It is only when we deal with special classes of models such as UNAModels(Δ) that we eliminate thesepossibilities.6. Framework for measuring inconsistencyFor a bistructure E = (D, I +, I −), let Domain(E) = D. In general, we can consider two disjoint possibilitiesfor |Domain(E)| for any bistructure E: These are that |Domain(E)| is finite or that |Domain(E)| is infinite. In thefollowing, we will provide a framework that measures inconsistency for both these cases.For the rest of the paper, a set of bistructures is called a frame. We adopt the following nomenclature for describinga frame Φ.• Φ is a bounded frame iff ∃n ∈ N such that ∀E ∈ Φ |Domain(E)| (cid:2) n.• Φ is an unbounded frame iff ∃m ∈ N ∀n ∈ N (n (cid:3) m implies ∃E ∈ Φ |Domain(E)| = n).• Φ is an infinite frame iff ∃E ∈ Φ such that |Domain(E)| (cid:3) ℵ0.1074J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093An example of a bounded frame is given by a singleton set containing just the bistructure given in Example 4. Anexample of an unbounded frame is given by Models(Δ) when Δ = {∀x, y.P (x, y)}. An example of an infinite frameis given by a singleton set containing just the bistructure given in Example 5.Obviously, if Φ is a bounded frame, then Φ is not an unbounded frame, and Φ is not an infinite frame. But it ispossible that Φ is both an unbounded frame and an infinite frame.For a frame Φ, any Φ(cid:13) ⊆ Φ is called a subframe. Obviously, if Φ is unbounded, there are subframes of Φ that arebounded. If Φ is an infinite frame, there may be a subframe that is unbounded, and there may be a subframe that isbounded. To support consideration of subframes, we draw on the following two subsidiary definitions.Finite(Φ) =Infinite(Φ) =(cid:4)E ∈ Φ |(cid:4)E ∈ Φ |(cid:5)(cid:8)(cid:8)(cid:8) ∈ N(cid:8)Domain(E)(cid:8)(cid:8)(cid:8) (cid:3) ℵ0(cid:8)Domain(E)(cid:5)Some of the key definitions in the rest of this paper will be based on analysing the bistructures in a frame. We in-troduce the notions of bounded, unbounded, and infinite frames to provide a general way of presenting our frameworkfor measuring inconsistency. We will give definitions for a measure for inconsistency in a bistructure (Definition 16),a measure for inconsistency in a bounded frame (Definition 17), a measure for inconsistency in an unbounded frame(Definition 20), and a measure for inconsistency in an infinite frame (Definition 25). Normally, we expect each frame tobe a set of models for a knowledgebase Δ, such as Models(Δ), UNAModels(Δ), ConceptModels(Δ), or CPModels(Δ).But since there are many possible classes of models that we could consider (Section 5 only considers some of the pos-sible classes), it is simpler and more general to define our framework of measures in terms of frames rather thandirectly in terms of particular classes of models for knowledgebases.6.1. Measuring inconsistency in a bistructureWe start by considering how to measure the inconsistency of a bistructure. We assume that we are given a languageL and E = (D, I +, I −) is a bistructure for L. The nonlogical symbols considered in the definitions and examples areassumed to be in L.Definition 14. Let E = (D, I +, I −) be a bistructure, and let Π be a set of predicate symbols.CollisionCount(Π, E) =(cid:9)(cid:8)(cid:8)(cid:8)(cid:8)Collision(Pi, E)where Collision(Pi, E) = {(cid:3)d1, . . . , dn(cid:4) ∈ Dn | (cid:3)d1, . . . , dn(cid:4) ∈ I +(Pi) ∩ I −(Pi)}.Pi ∈ΠThe following definition gives an upper bound on CollisionCount given a set of predicate symbols and a bistructure.Definition 15. Let E = (D, I +, I −) be a bistructure, and let Π be a set of predicate symbols.UniverseCount(Π, E) =(cid:9)(cid:8)(cid:8)(cid:8)(cid:8)Universe(Pi, E)where Universe(Pi, E) = {Pi(d1, . . . , dn) | d1, . . . , dn ∈ D and Pi is arity n}.Pi ∈ΠExample 6. Let E = (D, I +, I −) such that D = {1, 2, 3} andI +(P ) =I −(P ) =(cid:4)(cid:4)(cid:5)(cid:3)1(cid:4), (cid:3)2(cid:4)(cid:5)(cid:3)3(cid:4)I +(Q) =I −(Q) =(cid:5)(cid:4)(cid:3)1, 2(cid:4), (cid:3)1, 3(cid:4), (cid:3)2, 3(cid:4)(cid:5)(cid:4)(cid:3)1, 2(cid:4), (cid:3)1, 3(cid:4), (cid:3)3, 2(cid:4)Hence, CollisionCount({P , Q}, E) = 2 since,Collision(P , E) = {}(cid:5)(cid:4)(cid:3)1, 2(cid:4), (cid:3)1, 3(cid:4)Collision(Q, E) =and UniverseCount({P , Q}, E) = 12 since,Universe(P , E) =Universe(Q, E) =(cid:4)(cid:5)(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4)(cid:5)(cid:4)(cid:3)1, 1(cid:4), (cid:3)1, 2(cid:4), (cid:3)1, 3(cid:4), (cid:3)2, 1(cid:4), (cid:3)2, 2(cid:4), (cid:3)2, 3(cid:4), (cid:3)3, 1(cid:4), (cid:3)3, 2(cid:4), (cid:3)3, 3(cid:4)J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931075In the definition of UniverseCount(Π, E), it does not make sense to let Π = ∅, and so for the rest of this paper,we assume that Π is always nonempty. Having Π as a parameter allows us to focus on particular subsets of predicatesymbols during an analysis of a model or set of models. This is valuable, since when considering arbitrarily largedomains, the value obtained by CollisionCount for some predicate symbols may “drown out” the CollisionCount forother predicate symbols.We bring together the measure of CollisionCount and UniverseCount in the following definition for the measure ofinconsistency for a set of predicate symbols in a bistructure with a finite domain.Definition 16. Let Π be a set of predicate symbols and let E be a bistructure. The bistructure degree of inconsistencyof (Π, E), denoted Inc(Π, E), is defined as follows: If 0 < UniverseCount(Π, E) < ∞, thenInc(Π, E) = CollisionCount(Π, E)UniverseCount(Π, E)otherwise Inc(Π, E) = 0.Example 7. Continuing Example 6, Inc(Π, E) = 2/12 = 1/6, where Π = {P , Q}.The following are some simple observations concerning the Inc function.• For any Π and E, 0 (cid:2) Inc(Π, E) (cid:2) 1.• For any Π and E, if Inc(Π, E) = 1, then for all Π (cid:13) ⊆ Π , Inc(Π (cid:13), E) = 1.• For any Π and E, if Inc(Π, E) = 0, then for all Π (cid:13) ⊆ Π , Inc(Π (cid:13), E) = 0.In tolerant logic for any knowledgebase there is always a model. This model can be obtained by taking each atomin the language of the knowledgebase, and letting the model satisfy the atom and the negation of the atom. This modelgives the maximum degree of inconsistency, as formalised in the next proposition.Proposition 1. For all Δ, there is an E ∈ Models(Δ), such that Inc(Π, E) = 1 where Π is the set of all predicatesymbols in Δ.Proof. Consider the bistructure E that for each n-ary Pi ∈ Π , and d1, . . . , dn ∈ D, both E |= Pi(d1, . . . , dn)and E |= ¬Pi(d1, . . . , dn) hold. So E ∈ Models(Δ) and Inc(Π, E) = 1 because CollisionCount(Π, E) =UniverseCount(Π, E). (cid:2)6.2. Bounded degree of inconsistencyNow we consider the measure of inconsistency for a bounded frame. It is particularly useful if there is a maximumfinite size for the intended models. Essentially, it takes a credulous point of view by using the bistructure, from theframe, with the minimum degree of inconsistency.Definition 17. Let Π be a set of predicate symbols, and Φ be a bounded frame. The bounded degree of inconsistencyof (Π, Φ), denoted MicroInc(Π, Φ), is defined as follows.(cid:6)(cid:4)(cid:5)(cid:7)MicroInc(Π, Φ) = MinInc(Π, E) | E ∈ ΦWe can use this measure for giving a measure of inconsistency for a knowledgebase Δ when there is a case for abounded frame Φ that is in some sense representative of the knowledge. For example, if Δ is a set of ground literals,then a bounded frame containing just one model that satisfies exactly the literals in Δ is in a sense representative ofthe knowledge in Δ. The second reason we introduce the bounded degree of inconsistency is that we use it as part ofthe definition of the unbounded degree of inconsistency that we introduce in the next section.1076J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093Example 8. Let Π = {P }, D = {d1, d2, d3, d4}, and Φ = {M1, M2} where M1 = (D, I−1 (P ) =−2 (P ) =(cid:5)(cid:4)(cid:3)d4(cid:4)(cid:5)(cid:4)(cid:3)d1(cid:4), (cid:3)d2(cid:4), (cid:3)d3(cid:4), (cid:3)d4(cid:4)(cid:5)(cid:3)d1(cid:4), (cid:3)d2(cid:4), (cid:3)d3(cid:4), (cid:3)d4(cid:4)(cid:5)(cid:3)d1(cid:4), (cid:3)d2(cid:4), (cid:3)d3(cid:4), (cid:3)d4(cid:4)+1 (P ) =+2 (P ) =(cid:4)(cid:4)IIII+1 , I−1 ), and M2 = (D, I+2 , I−2 ).Therefore,(cid:6){P }, M1CollisionCount(cid:6){P }, M2CollisionCount(cid:6){P }, M1UniverseCount(cid:6){P }, M2UniverseCount(cid:7)(cid:7)(cid:7)(cid:7)= 1= 4= 4= 4So Inc({P }, M1) = 1/4, and Inc({P }, M2) = 4/4, and therefore MicroInc({P }, Φ) = 1/4.IIExample 9. Let Π = {P , Q}, D = {d1, d2}, and Φ = {M1, M2, M3} where M1 = (D, I+−and M3 = (D, I3 , I3 ).(cid:4)(cid:5)+(cid:3)d1(cid:4), (cid:3)d2(cid:4)1 (P ) =(cid:5)(cid:4)+(cid:3)d1(cid:4)1 (Q) =(cid:5)+(cid:3)d1(cid:4)2 (P ) =(cid:5)(cid:4)+(cid:3)d2(cid:4)2 (Q) =(cid:4)(cid:5)+(cid:3)d1(cid:4), (cid:3)d2(cid:4)3 (P ) =(cid:5)(cid:4)+(cid:3)d1(cid:4), (cid:3)d2(cid:4)3 (Q) =(cid:4)(cid:5)(cid:3)d1(cid:4), (cid:3)d2(cid:4)(cid:5)(cid:4)(cid:3)d1(cid:4)(cid:5)(cid:4)(cid:3)d1(cid:4), (cid:3)d2(cid:4)(cid:5)(cid:4)(cid:3)d2(cid:4)(cid:5)(cid:4)(cid:3)d1(cid:4)(cid:5)(cid:4)(cid:3)d1(cid:4), (cid:3)d2(cid:4)−1 (P ) =−1 (Q) =−2 (P ) =−2 (Q) =−3 (P ) =−3 (Q) =IIIIII(cid:4)IIII+1 , I−1 ), M2 = (D, I+2 , I−2 ),(cid:7)Since, for Mi ∈ {M1, M2, M3}, UniverseCount({P }, Mi) = 2, UniverseCount({Q}, Mi) = 2, and UniverseCount({P ,Q}, M1) = 4 , we have= 22= 12(cid:7)= 34(cid:6){P }, M1Inc(cid:6){Q}, M1Inc(cid:6){P , Q}, M1Inc(cid:6){P }, M3(cid:6){Q}, M3(cid:6){P , Q}, M3(cid:6){P }, M2(cid:6){Q}, M2(cid:6){P , Q}, M2= 12= 12(cid:7)= 24= 12= 22(cid:7)= 34IncIncIncIncIncInc(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)So MicroInc({P }, Φ) = 1/2, MicroInc({Q}, Φ) = 1/2, and MicroInc({P , Q}, Φ) = 1/2.We get MicroInc(Π, Φ) = 0 when Φ is a finite set of finite models for a knowledgebase that is consistent accordingto classical logic, and we get MicroInc(Π, Φ) = 1 when Φ is a finite set of finite models for a “completely inconsistent”knowledgebase (i.e. a knowledgebase for which each model of the knowledgebase, and for each atom in the languageof the knowledgebase, the model satisfies the atom and its negation).Proposition 2. For all knowledgebases Δ, and for all sets of predicate symbols Π , if Δ (cid:16)(cid:14) ⊥, and Φ = {E | E ∈Models(Δ) and |Domain(E)| (cid:2) n for some n ∈ N}, then MicroInc(Π, Φ) = 0.Proof. Φ is a nonempty bounded frame. Since Δ (cid:16)(cid:14) ⊥ there is an E ∈ Φ such that Inc(Π, E) = 0. Hence,MicroInc(Π, Φ) = 0. (cid:2)The definitions of Inc and MicroInc are quite general definitions characterising inconsistency for several reasons:they actually support the use of diverse logics (not just tolerant logics) for generating the models of a knowledgebase,the definitions are based on frames rather than knowledgebases, and they are able to focus attention on particularpredicates rather than all predicates used in the knowledgebase or language, thus providing a finer grained analysis ofinconsistency.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–109310776.3. Unbounded degree of inconsistencyNow we consider how to measure inconsistency in unbounded frames. An unbounded frame may contain infinitebistructures; however, in the measure we define we consider only the finite bistructures in the frame. In particular, thismeans that if the frame consists of the models of a knowledgebase, we restrict consideration to the finite models. Inthe following definition we identify a function that for each n ∈ N gives the bounded degree of inconsistency for thebistructures with domain of cardinality n.Definition 18. Let Π be a set of predicate symbols, let Φ be an unbounded frame, and for each n ∈ N, let Φ[n] =Π : N (cid:11)→ [0, 1] such that for each n ∈ N,{E ∈ Φ | |Domain(E)| = n}. The discord function for (Π, Φ) is a function f Φif Φ[n] (cid:16)= ∅,then f Φ(cid:7)(cid:6)Π, Φ[n]Π (n) = MicroInc,otherwise f ΦΠ (n) = 0.So we can consider an unbounded frame as a sequence of bounded frames Φ[n] (each of which contains justbistructures of domain size n), then obtain the bounded degree of inconsistency of Φ[n] for each n, and then representthis sequence of values by a univariate function which we call a discord function.Example 10. Let Δ = {P (a), ¬P (a)}, Π = {P }, and Φ = Models(Δ). So, for all n, f ΦΠ (n) = 1/n.Example 11. Let Δ = {P (a), ∃x.¬P (x)}, with Φ = Models(Δ), and Π = {P }. Hence, f ΦΠ (1) = 1, and for all n > 1,Π (n) = 0 because in the second case we can always choose an element of the domain other than a, say b, for whichf Φ¬P (b) holds and there is no inconsistency.The next two examples illustrate the effect of imposing a restriction on the models considered for a knowledgebase.Example 12. Let Δ = {P (a), ¬P (a), P (b), ¬P (b), P (c), ¬P (c)}, with Φ = Models(Δ), and Π = {P }. In this case,the models in Φ with fewest conflicts are those where all constant symbols are assigned the same domain object.Hence for all n, f ΦΠ (n) = 1/n.Example 13. Let Δ = {P (a), ¬P (a), P (b), ¬P (b), P (c), ¬P (c)}, with Φ = UNAModels(Δ), and Π = {P }. In thiscase, because of the unique names assumption, the models in Φ assign each constant symbol a different domain object.Π (n) = 3/n.Hence there are no models of cardinality 1 or 2 and we obtain f ΦΠ (2) = 0, and for all n > 2, f ΦΠ (1) = 0, f ΦWhilst in general, the discord function f ΦΠ is just a summary of the inconsistency arising in the bistructures in Φ,for some frames, the discord function is particularly interesting for our purposes. To consider some of these, we definethe concept of a special type of rational function that we call a special function.Definition 19. A special function is a function r : N (cid:11)→ [0, 1] of the following form where r1 and r2 are each anonnegative and nondecreasing univariate polynomial function such that for all n ∈ N r2(n) (cid:16)= 0, there is k ∈ N suchthat for all n (cid:3) k, 0 (cid:2) r1(n) (cid:2) r2(n), andr(n) = r1(n)r2(n)For some classes of frames, we can show that the discord function is a special function. In Examples 10 and 12each discord function is a rational function. We give some further examples for discord functions below and in Fig. 1.Now we define the unbounded degree of inconsistency as a special function for an important class of unboundedframes.Definition 20. Let Π be a set of predicate symbols, Φ an unbounded frame, and let f ΦΠ be the corresponding discordΠ (n) = hΦfunction. Suppose that there is a special function hΦΠ such that for all n > n0, f ΦΠ theunbounded degree of inconsistency for (Π, Φ). If an unbounded frame Φ for Π , written (Φ, Π), has an unboundeddegree of inconsistency, we call it a smooth frame. We also let Threshold(hΦΠ ) be the lowest value for n0 wheren0 ∈ N ∪ {0}.Π (n). We call hΦ1078J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093Δ1Δ2Δ3Δ4Δ5Δ6Δ7Δ8{P (a), ¬P (a) ∨ ¬Q(a), Q(a)}{∀x.P (x), ∀x.¬P (x) ∨ ¬Q(x), ∀x.Q(x)}{∀x.P (x) ∧ ¬P (x), ∀x.Q(x)}{∀x.P (x) ∧ ¬P (x), ∀x.Q(x) ∧ ¬Q(x)}{P (a) ∧ ¬P (a), ∀x.Q(x)}{∀x, y.P (x, y) ∧ ¬P (x, y), ∀x.Q(x)}{∃x, y.P (x, y) ∧ ¬P (x, y), ∀x, y.Q(x, y)}{P (a) ∧ ¬P (a), ∀x.Q(x) ∧ ¬Q(x)}Π1 = {P }0Π2 = {Q}00111n11n21n0010001Π3 = {P , Q}12n1212112nnn+112n2n+12nFig. 1. Examples of discord functions f Φsymbols Πj . In each case, the discord function is a special function.Π such that Φ is Models(Δi ) with different knowledgebases Δi and with different sets of predicateExamples 10–13 illustrate smooth frames. In particular, for Example 13, hΦΠ (n) = 3/n and Threshold(hΦΠ ) = 2.The following example of an unbounded frame is not smooth.Example 14. Let Φ = {Ei | i ∈ N} and Π = {P (1)}, where Ei = (Di, I−{(cid:3)d1(cid:4)} and for the odd values of i, Ii (P ) = {(cid:3)d1(cid:4)} while for the even values of i, IΠ (n) = 1/n and for the even values of n, f Φvalues of n, f Φthere is no finite threshold to allow us to identify it with f Φ+i (P ) =−i (P ) = ∅. In this case for the oddΠ (n) = 0. Of course 1/n is a special function; however,Π after the threshold value.−i ) such that Di = {d1, . . . , di}, I+i , IIf Δ is consistent according to classical logic, and Φ = Models(Δ) then hΦΠ (n), for all n > 1, becausefor any such n ∈ N, either there is no model of size n or there is a model of size n with no collisions. We excluded thecase of n = 1 because of examples such as the consistent theory Δ = {∃x.P (x), ∃x.¬P (x)} that has a collision in amodel of size 1. In contrast, we can characterise a “maximally inconsistent” model as follows.Π (n) = 0 = f ΦProposition 3. If for all n ∈ N, f ΦE ∈ Φ,Π (n) = 1 = hΦΠ (n), then for each arity m predicate symbol P ∈ Π , and for allE |= ∀x1, . . . , xm.P (x1, . . . , xm) ∧ ¬P (x1, . . . , xm)Proof. Since f ΦΠ (n) is always 1, every atom must be involved in a collision. (cid:2)To illustrate how the unbounded degree of inconsistency can be useful, we give two examples of ontologies pre-sented in classical logic. As discussed in Section 2, we can adopt the following conventions: (1) A concept P isrepresented by a monadic predicate P (x); (2) An individual c that is a member of a concept P is represented bya ground predicate P (c); (3) The relationship that the concept Q is a subconcept of the concept P is representedby ∀x.Q(x) → P (x); and (4) The relationship that the concept Q is disjoint with the concept P is represented by∀x.Q(x) → ¬P (x) ∧ ∀x.P (x) → ¬Q(x).Example 15. Let Δ be the following set of formulae where instance c is member of disjoint concepts.(cid:7)(cid:6)Q(x) → ¬S(x) ∧ S(x) → ¬Q(x)∀x.∀x.S(x) → R(x)(cid:7)(cid:6)P (x) → ¬R(x) ∧ R(x) → ¬P (x)∀x.Q(x) → P (x) ∀x.S(c)Q(c)If Π = {P , Q, R, S} and Φ = ConceptModels(Δ), then for all E ∈ Φ,E |= P (c)E |= ¬P (c) E |= ¬Q(c) E |= ¬R(c) E |= ¬S(c)E |= Q(c)E |= R(c)E |= S(c)Hence, for all E ∈ Φ, if |E| = n then Min({CollisionCount(Π, E)}) = 4 and UniverseCount(Π, E) = 4n. ThereforeΠ ) = 0. Note, we get the same result ifΠ (n) = 4/4n = 1/n for all n ∈ N, and so hΦf Φwe replace S(c) and Q(c) by ∃x.(S(x) ∧ Q(x)) in Δ.Π (n) = 1/n with Threshhold(hΦJ. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931079Example 16. Let Δ be the following set of formulae where (1) states that T and U are disjoint concepts, (2) statesthat T and U are the same concept, and (3) states that T and U comprise everything.(1) ∀x.(T (x) → ¬U (x) ∧ U (x) → ¬T (x))(2) ∀x.(T (x) → U (x) ∧ U (x) → T (x))(3) ∀x.T (x) ∨ U (x)If Π = {T , U }, E ∈ Φ = ConceptModels(Δ), and d ∈ Domain(E), then according to (3) either E |= T (d) orE |= U (d) (or both). Assume w.l.g. that E |= T (d). Then by (1) E |= ¬U (d) and by (2) E |= U (d). Applying(1) again yields E |= ¬T (d). Hence, for all E ∈ Φ, Inc(Π, E) = 2n/2n. Therefore, f ΦΠ (n) = 1, andThreshold(hΦΠ (n) = hΦΠ ) = 0.Example 17. Continuing Example 16, we extend Δ by adding the following set of formulae.(cid:7)(cid:6)Q(x) → ¬S(x) ∧ S(x) → ¬Q(x)∀x.∀x.S(x) → R(x)(cid:7)(cid:6)P (x) → ¬R(x) ∧ R(x) → ¬P (x)∀x.Q(x) → P (x) ∀x.Let Π = {P , Q, R, S, T , U } and Φ = ConceptModels(Δ). Now for any E ∈ Φ and for any d ∈ Domain(E), it ispossible to just make E |= ¬P (d), E |= ¬Q(d), E |= ¬R(d), and E |= ¬S(d) with no collisions for the predicatesΠ (n) = 2n/6n = 1/3, and Threshold(hΦP , Q, R, and S. Therefore, f ΦΠ (n) = hΦΠ ) = 0.As we showed in Example 14 not all unbounded frames are smooth. However, the following result shows that if weconsider all the models of a knowledgebase Δ (i.e. Models(Δ) ), or if we consider UNAModels(Δ), or if we considerConceptModels(Δ), then there is an unbounded degree of inconsistency for any Π , and hence such a class of modelsis a smooth frame.Theorem 1. Let Δ be a knowledgebase, and let Π be a set of predicate symbols. If Φ = Models(Δ), or if Φ =UNAModels(Δ), or if Φ = ConceptModels(Δ), then (Π, Φ) is a smooth frame.Proof. We start with the case where Φ = Models(Δ) and Π is the set of all predicate symbols in Δ. It is known thatfor all n ∈ N, Φ[n] (cid:16)= ∅ (where Φ[n] contains the models of size n in Φ). What is needed is to show that the discordfunction f ΦΠ is a special function after a possible threshold value, as explained in Definitions 19 and 20. Since for allE ∈ Φ[n], UniverseCount(Π, E) is the same, let r2(n) = UniverseCount(Π, E) for some E ∈ Φ[n]. Clearly, r2 cannever be 0 because the domains and Π are not empty. Also, let r1(n) = Min({CollisionCount(Π, E)|E ∈ Φ[n]}). Wehave previously observed that 0 (cid:2) Inc(Π, E) (cid:2) 1 for all Π and E, hence 0 (cid:2) r1(n) (cid:2) r2(n) holds for all n ∈ N. So wemust show that both r1 and r2 are nondecreasing univariate polynomial functions. By definition both are univariatefunctions. It remains to show that both r1 and r2 are nondecreasing polynomial functions.We start with r2. We can actually compute UniverseCount(Π, E) for E ∈ Φ[n] as follows. Suppose Π containsthe predicate symbols P1(m1), . . . , Pk(mk) (the arities are in parentheses). Then r2(n) = UniverseCount(Π, E) =nm1 + · · · + nmk . This is a polynomial, although it may have to be simplified to write in standard form. Clearly, r2 isnondecreasing.Computing r1 can be quite complex for an arbitrary Δ. What we need to show is that r1 is nondecreasing andpolynomial. It is clear that r1 is nondecreasing after a threshold of n = 1 because as we enlarge a model by adding adomain element, the number of collisions cannot decrease. There may be a problem in the special case of going from1 to 2 elements, for example, if Δ = {∃x.P (x), ∃x.¬P (x)}. So it remains to show that r1 is a polynomial function.We do not give all the details here but explain the basic idea through an example. At the end of this subsection weactually calculate r1 for some special cases.Consider the case where Π = {P (2)} and there are no constant or function symbols in the language. Recall that tocompute r1(n) we try to find the minimal number of collisions in a model of size n. We choose 4 statements in Δ thatcause collisions, taking care of all quantifier combinations (for arity 2):(1) ∃x, y.P (x, y) ∧ ¬P (x, y)1080J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093(2) ∃x, ∀y.P (x, y) ∧ ¬P (x, y)(3) ∀x, ∃y.P (x, y) ∧ ¬P (x, y)(4) ∀x, y.P (x, y) ∧ ¬P (x, y)The minimal number of collisions for (1) is 1, for (2) and (3) is n, and for (4) is n2. What happens is that for each argu-ment an existential quantifier provides a multiplicative factor 1 while a universal quantifier provides a multiplicativefactor n. This does not change even if there is a mix of different quantifiers, such as(5) ∀x, ∃y.P (x, y) ∧ ∃x, ∀y.¬P (x, y)However, we may have to subtract overlaps and recognise when there are no collisions such as for(6) ∃x, y.P (x, y) ∧ ∃x, y.¬P (x, y)(except for the case n = 1 that we have eliminated). The important point is that every number we get for collisions mustbe ni for some i, where 0 (cid:2) i (cid:2) Arity(P ), including the number of elements in an overlap. Adding and subtractingsuch powers of n always yields a polynomial.Now suppose that Π contains the predicate symbols P1(m1), . . . , Pk(mk) as given above. Then for any Pj , 1 (cid:2)j (cid:2) k, the minimal number of collisions is calculated as above for P except that now we get powers of n up to thelargest arity of the predicate symbols. So far, implicitly we have restricted our analysis to conjunctions. In the caseof disjunction, such as θ = θ1 ∨ · · · ∨ θt we take the minimum number of collisions in any of the θi , 1 (cid:2) i (cid:2) t, whileimplication can be rewritten using disjunction (and negation). In all cases the calculation yields a sum of powers of nwith subtractions, also powers of n for overlaps, and hence the result is a polynomial. A similar argument works if Πis a subset of the predicates in Δ.Let us now consider the case where the language contains constant and function symbols. For the purpose ofcounting collisions we can always interpret a function symbol as a constant function in which case it has the effectof a constant symbol in counting collisions (as discussed in Section 2). So we need not deal separately with functionsymbols. But a constant symbol has the same effect as an existential quantifier, so for example,(7) ∃y.P (c, y) ∧ ¬P (c, y)gives the same number of minimal collisions as (1). This completes the proof for the case where Φ = Models(Δ).We now show how this result extends to the other classes of types of models. Consider the case where (cid:12) =ConceptModels(Δ). If for all n ∈ N, (cid:12)[n] contains a model in Φ[n] with a minimal number of collisions, theneverything works as before. So let us consider how models of Φ[n] with a minimal number of collisions might not bein (cid:12)[n]. The following formula illustrates what might happen:(8) ∀x.P (x) ∧ ¬P (x) ∧ ¬Q(x) ∧ (P (x) → Q(x))Consider a model E of Φ with minimal number of collisions, where for all d ∈ Domain(E), (cid:3)d(cid:4) ∈ I +(P ) ∩ I −(P ) ∩I −(Q) but d /∈ I +(Q). There are n collisions. However E /∈ (cid:12). For E to satisfy the requirement for a concept model,d must also be in I +(Q). This requires adding n collisions. In the general case the number of collisions that must beadded will again be a power of n, so r1 is still a polynomial.Finally, we consider the case where Γ = UNAModels(Δ). Let nΔ be the number of different constant symbols inΔ or 1 if there are none. Here the proof for Φ[n] goes through for Γ [n], n (cid:3) nΔ. Hence the same result holds but withThreshold(hΓΠ ) = nΔ − 1. (cid:2)Using the proof of this theorem we can show that when the knowledgebase is exclusively ground formulae (i.e.there are no variables), then the numerator of the discord function is a constant.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931081Proposition 4. Let Δ be a knowledgebase which incorporates no variable symbols, and let Π be a set of predicatesymbols. If Φ = Models(Δ), or Φ = ConceptModels(Δ), or Φ = UNAModels(Δ), then there is an m ∈ N, and n0 ∈ N,such that for all n ∈ N, where n > n0, the numerator of hΦΠ (n) is m.Proof. Clearly, Δ must have at least one constant symbol. Now recall from the proof of Theorem 1 that each constantsymbol acts as an existential quantifier from the point of view of counting collisions. Also, each existential quan-tifier yields a multiplicative factor of 1. Hence there are no terms in the polynomial for r1 (the numerator) with nifor i > 0, so it must be a constant. We can actually get an upper bound on m as follows. If there are t predicatesymbols then m (cid:2) t for Φ = Models(Δ) and Φ = ConceptModels(Δ), because we can identify all the constant sym-bols with a single element in the domain of the model and each predicate symbol causes at most one collision. Heren0 = 0. The calculation is more complicated in the case where Φ = UNAModels(Δ) because all constant symbolsmust be interpreted as different elements of D. Suppose Δ contains c constant symbols and the predicate symbols are:P1(k1), . . . , Pq (kq ). Then the number of collisions for any E ∈ Φ of size (cid:3) c (there are no models of size < c) mustbe at most ck1 + · · · + ckq whose sum is the upper bound for m with n0 = c − 1. (cid:2)We can compare discord functions using the following ordering relation.Definition 21. The discord ordering, denoted (cid:17), is defined as follows, where f ΦΠ and f Φ(cid:13)Π (cid:13) are discord functions.f ΦΠ(cid:17) f Φ(cid:13)Π (cid:13)iffthere is an n(cid:13) ∈ N such that for all n ∈ N, if n(cid:13) (cid:2) n, then f ΦΠ (n) (cid:2) f Φ(cid:13)Π (cid:13) (n)Intuitively, if f ΦΠNext we show by examples that the discord function is not monotonic or antimonotonic in general.Π (cid:13) , then (Φ, Π) is less or equally inconsistent with (Φ(cid:13), Π (cid:13)).(cid:17) f Φ(cid:13)Example 18. Let Δ2 = {P (c)}, Π = {P }, and Δ1 = {P (c), ¬P (c)} and Φi = Models(Δi) for i = 1, 2. Clearly Φ1 ⊂Φ2 and for all n ∈ N, f Φ2Π . Now let Φ4 = Models(Δ1) for the Δ1 givenabove and Φ3 = {E | E ∈ Φ4 and |Domain(E)| is even}. Here, Φ3 ⊂ Φ4, but now f Φ4Π (n) = 1/n for all n ∈ N, whilef Φ3Π (n) = 1/n for all even n and 0 for all odd n. Hence it is not the case that f Φ4This shows that in general, Φ1 ⊆ Φ2 implies neither f Φ1Π(cid:17) f Φ3Π .Π . Note that Φ3 is not a smoothΠ (n), so we cannot have f Φ1Π (n) < f Φ1Π nor f Φ2Π(cid:17) f Φ1(cid:17) f Φ2(cid:17) f Φ2ΠΠframe.Example 19. Let Δ2, Δ3, Π1, and Π3 be the examples in Fig. 1. Here, Π1 ⊂ Π3. Let Φ2 = Models(Δ2) and Φ3 =(n) and f Φ3Models(Δ3). We obtain for all n ∈ N f Φ2(n) < f Φ2(n). This shows that in general, Π1 ⊆ Π2Π3Π3Π1(cid:17) f Φimplies neither f Φ.Π1Π1(n) < f Φ3Π1nor f ΦΠ2(cid:17) f ΦΠ2We noted in Example 18 that Φ3 is not a smooth frame. In fact, for smooth frames, the discord function is anti-monotonic in Φ.Proposition 5. If Φ1 and Φ2 are both smooth frames and Φ1 ⊆ Φ2, then f Φ2Π(cid:17) f Φ1Π .Proof. Let Φ1 ⊆ Φ2 for smooth frames Φ1 and Φ2 where the corresponding special functions are hΦ1with Threshold(hΦ1increase the minimum number of collisions for a Φ[n], we obtain for all n > n0, hΦ2Π (n), hence f Φ2f Φ1Π and hΦ2ΠΠ ) = n2. Let n0 = max{n1, n2}. Recalling that additional models cannotΠ (n) =Π ) = n1 and Threshold(hΦ2Π (n) (cid:2) hΦ1Π (n) = f Φ2Π . (cid:2)(cid:17) f Φ1ΠFor a knowledgebase Δ, let Con(Δ) = {Γ ⊆ Δ | Γ (cid:16)(cid:14) ⊥} be the set of consistent subsets of Δ. The set of maximallyconsistent subsets of Δ is defined as follows.(cid:5)(cid:4)Γ ∈ Con(Δ) | for all Γ (cid:13) ∈ Con(Δ)(Γ (cid:16)⊂ Γ (cid:13))MaxCon(Δ) =(cid:10)Also let Free(Δ) =MaxCon(Δ) be the set of formulae that are in all maximally consistent subsets of Δ. These maybe regarded as the uncontroversial formulae in Δ since they do not appear in any minimally inconsistent subset of Δ1082J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093(where a minimally inconsistent subset of Δ is a subset Γ of Δ such that Γ is inconsistent and for all Γ (cid:13) ⊂ Γ , Γ (cid:13) isconsistent).The following result shows that if a formula θ is not involved in any inconsistency in Δ ∪ {θ }, then adding θ to Δcannot make the inconsistencies in Δ worse.Proposition 6. Let Φ1 = Models(Δ), and Φ2 = Models(Δ∪{α}). If α ∈ Free(Δ∪{α}), then f Φ2Πif α contains only nonlogical symbols in Δ then f Φ2Π= f Φ1Π .(cid:17) f Φ1Π . Furthermore,Π ) = n10, and let Threshold(hΦ2Proof. Let Threshold(hΦ10. So for each n > n20,Min({CollisionCount(Π, E) | E ∈ Φ1[n]} = Min({CollisionCount(Π, E) | E ∈ Φ2[n]}. Also for each n > n20, for eachE1 ∈ Φ1[n], and for each E2 ∈ Φ2[n], UniverseCount(Π, E1) (cid:2) UniverseCount(Π, E2). So for each n ∈ N, if n > n20,then MicroInc(Π, Φ2[n]) (cid:2) MicroInc(Π, Φ1[n]). Hence, f Φ2Π . In case α contains only nonlogical symbols inΠΔ, then we have UniverseCount(Π, E1) = UniverseCount(Π, E2), and so f Φ2Π0. Since Δ ⊆ Δ ∪ {α}, n20Π ) = n2Π . (cid:2)(cid:17) f Φ1= f Φ1(cid:3) n1In the proof of Theorem 1 we gave a general argument to explain why the discord function is a special function fora smooth frame. Now we give specific results for some special cases.Proposition 7. Let ψ be a sentence of the form Q1x1, . . . , Qkxk.P (t1, . . . , tm) ∧ ¬P (t1, . . . , tm) where {x1, . . . , xk} ⊆{t1, . . . , tm}, and {x1, . . . , xk} (cid:16)= ∅, and each ti ∈ {t1, . . . , tm} \ {x1, . . . , xk} is a constant symbol, and Q1, . . . , Qk ∈{∀, ∃}. If Φ = Models({ψ}), and Π = {P }, thenΠ (n) = d1 × · · · × dkf Φnmwhere for each di ∈ {d1, . . . , dk}, di = n if Qi is a universal quantifier, and di = 1 if Qi is an existential quantifier.Proof. If ψ is of the form Q1x1, . . . , Qkxk.P (t1, . . . , tm) ∧ ¬P (t1, . . . , tm), then for each n, there is an E ∈ Φ[n],with a minimal number of collisions, such that CollisionCount(Π, E) = d1 × · · · × dk, where for each di ∈ {d1, . . . , dk},di = n if Qi is a universal quantifier, because all n domain elements are involved in collisions, and di = 1 if Qi isan existential quantifier, because one domain element must be involved in a collision. Furthermore, for all E ∈ Φ[n],UniverseCount(Π, E) = nm, therefore f ΦΠ (n) = (d1 × · · · × dk)/nm. (cid:2)For example, consider ψ = ∀x, y, ∃z.P (x, y, z) ∧ ¬P (x, y, z). So for Φ = Models({ψ}), and Π = {P }, we get= n2/n3 = 1/n. Also consider ψ (cid:13) = ∀y, ∃z.P (a, y, z) ∧ ¬P (a, y, z). So for Φ(cid:13) = Models({ψ (cid:13)}), and Π = {P },f ΦΠwe get f Φ(cid:13)Π= n/n3 = 1/n2.Corollary 1. Let ψ be a sentence of the form ∀x1, . . . , xk.P (x1, . . . , xk) ∧ ¬P (x1, . . . , xk). If Φ = Models({ψ}), andΠ = {P }, then f ΦΠ (n) = 1.Corollary 2. Let ψ be a sentence of the form ∃x1, . . . , xk(P (t1, . . . , tm) ∧ ¬P (t1, . . . , tm)). If Φ = Models({ψ}), andΠ = {P }, then f ΦΠ (n) = 1/nm.When ψ is a sentence of the form Q1x1, . . . , Qkxk.P (t1, . . . , tm) ∧ ¬P (t1, . . . , tm) ∧ P (cid:13)(t (cid:13)m1, . . . ,m) where {x1, . . . , xk} ⊆ {t1, . . . , tm, t (cid:13)t (cid:13)} and {x1, . . . , xk} (cid:16)= ∅, and each ti ∈ {t1, . . . , tm} is either a variablesymbol or a constant symbol, and P (cid:16)= P (cid:13), we can obtain the special function for the models of each of the followingusing Proposition 7 and then sum them.m) ∧ ¬P (cid:13)(t (cid:13)1, . . . , t (cid:13)1, . . . , t (cid:13)Q1x1, . . . , Qkxk.P (t1, . . . , tm) ∧ ¬P (t1, . . . , tm)Q1x1, . . . , Qkxk.P (cid:13)(t (cid:13)1, . . . , t (cid:13)1, . . . , t (cid:13)m)m) ∧ ¬P (cid:13)(t (cid:13)For example, consider ψ = ∀x, y, ∃z.P (a, y, z) ∧ ¬P (a, y, z) ∧ P (cid:13)(x, y, z) ∧ ¬P (cid:13)(x, y, z). So for Φ = Models({ψ}),and Π = {P , P (cid:13)}, we get f ΦΠSimilarly when ψ is a sentence of the form Q1x1, . . . , Qkxk.P (t1, . . . , tm) ∧ ¬P (t1, . . . , tm) ∧ P (t (cid:13)1, . . . , t (cid:13)m) ∧} and {x1, . . . , xk} (cid:16)= ∅, and each ti ∈ {t1, . . . , tm} is eitherm) where {x1, . . . , xk} ⊆ {t1, . . . , tm, t (cid:13)= (n + n2)/2n3.1, . . . , t (cid:13)1, . . . , t (cid:13)¬P (t (cid:13)mJ. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931083a variable symbol or a constant symbol, we can obtain the special function for the models of each of the followingusing the above result, then obtain the special function by taking their sum minus their overlap.Q1x1, . . . , Qkxk.P (t1, . . . , tm) ∧ ¬P (t1, . . . , tm)Q1x1, . . . , Qkxk.P (t (cid:13)1, . . . , t (cid:13)1, . . . , t (cid:13)m)m) ∧ ¬P (t (cid:13)For example, consider ψ = ∀x, y, ∃z.P (a, y, z) ∧ ¬P (a, y, z) ∧ P (x, b, z) ∧ ¬P (x, b, z). So for Φ = Models({ψ}),and Π = {P }, we get f ΦΠ= (2n − 1)/n3.6.4. Inconsistency in the limit for smooth framesWe now consider the limit behaviour of the unbounded degree of inconsistency for smooth frames. In the limit,limn→∞ f ΦΠ , so it suffices to write only one of these functions. An advantage of considering the limit isΠthat we can identify a measure of inconsistency that is a rational number in the [0, 1] interval. This provides a simplesummary of the unbounded degree of inconsistency for a knowledgebase.= limn→∞ hΦTheorem 2. If f Φlimn→∞ f ΦΠ (n) = k.Π is a discord function, and Φ is a smooth frame, then there is a rational number k ∈ [0, 1] such thatProof. Let f Φn > n0, f Φc2n2 + · · · + cq nq , such that for all n > n0,Π be a discord function, and let Φ be a smooth frame. By definition, there is an n0 such that for allΠ is a special function. Therefore, there are polynomials b0 + b1n + b2n2 + · · · + bpnp and c0 + c1n +f ΦΠ (n) =c0 + c1n + c2n2 + · · · + cq nqb0 + b1n + b2n2 + · · · + bpnpSince, q = p or q < p, we have the following two cases.If q = p,then limn→∞c0 + c1n + c2n2 + · · · + cpnpb0 + b1n + b2n2 + · · · + bpnp=cpbpwhere cp (cid:2) bpIf q < p,then limn→∞c0 + c1n + c2n2 + · · · + cq nqb0 + b1n + b2n2 + · · · + bpnp= 0Therefore, there exists a rational number k ∈ [0, 1] such that limn→∞ f ΦΠ (n) = k. (cid:2)Example 20. Returning to Fig. 1, with Π = Π3, the limits are as follows: for Δ1, Δ5, and Δ7, limn→∞ f ΦΠΔ2, Δ3, and Δ8, limn→∞ f ΦΠ= 1/2, and for Δ4, and Δ6, limn→∞ f ΦΠ= 1.= 0, forFollowing on from Theorem 2, when limn→∞ f ΦΠ (n) is nonzero, we have the following characterisation of conflictsarising.Proposition 8. Let f ΦΠ be a discord function and Φ a smooth frame such that for all n > n0,f ΦΠ (n) =c0 + c1n + c2n2 + · · · + cpnpb0 + b1n + b2n2 + · · · + bpnpThen for all E ∈ Φ, there is a P ∈ Π such that E |= ∀x1, . . . , xp.P (x1, . . . , xp) ∧ ¬P (x1, . . . , xp).Π is a discord function for a smooth frame, for all n > n0, f ΦΠProof. Since f ΦΠ is a special function. Therefore,for all n > n0, MicroInc(Π, Φ[n]) is a special function, and so, for all n > n0, Min({Inc(Π, E) | E ∈ Φ[n]}) is a specialfunction. This implies that for all n > n0, the following is a special function:= hΦ(cid:11)(cid:12)MinCollisionCount(Π, E)UniverseCount(Π, E)(cid:13)(cid:14)(cid:8)(cid:8)(cid:8) E ∈ Φ[n]1084J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093Since, for all n, for all E, E(cid:13) ∈ Φ[n], UniverseCount(Π, E) = UniverseCount(Π, E(cid:13)), we can rewrite the above asMin({CollisionCount(Π, E) | E ∈ Φ[n]})UniverseCount(Π, E)Thus,(cid:6)(cid:4)MinCollisionCount(Π, E) | E ∈ Φ[n](cid:5)(cid:7)= c0 + c1n + c2n2 + · · · + cpnp(1)UniverseCount(Π, E) = b0 + b1n + b2n2 + · · · + bpnp(2)Using the proof of Theorem 1, (2) implies that there is an arity p predicate symbol P ∈ Π , and therefore from (1) andthe fact that cp (cid:16)= 0 and the highest power of n is p, it follows that for all E ∈ Φ, there is an arity p predicate symbolP ∈ Π , such that E |= ∀x1, . . . , xp.P (x1, . . . , xp) ∧ ¬P (x1, . . . , xp). (cid:2)The next result is basically the reverse of Theorem 2.Theorem 3. If k ∈ [0, 1], and k is rational, then there is a smooth frame Φ with discord function f Φlimn→∞ f ΦΠ (n) = k.Π such thatProof. Let k = s/t where 0 (cid:2) s (cid:2) t. Let r1(n) = s × n and r2(n) = t × n. Clearly, r1 and r2 are both nondecreasingand nonnegative univariate polynomial functions such that for all n ∈ N (r1(n)/r2(n)) = k. Now we construct aknowledgebase Δ, such that Φ = Models(Δ), and Π is the set of all predicate symbols used in Δ, so that(cid:6)(cid:4)(cid:5)(cid:7)r1(n) = Minr2(n) = UniverseCount(Π, E), when E ∈ Φ[n]CollisionCount(Π, E) | E ∈ Φ[n]Let Π have t monadic predicate symbols. So for any n, and any E ∈ Φ[n],UniverseCount(Π, E) = n × tThen we continue the construction by putting s formulae into Δ of the form ∀x.Pi(x) ∧ ¬Pi(x) using s differentpredicate symbols available in Π . So, for any n,(cid:5)(cid:7)(cid:6)(cid:4)MinCollisionCount(Π, E) | E ∈ Φ[n]= n × sHence, for any n, r1(n) = n × s. By definition, Min({Inc(Π, E) | E ∈ Φ[n]}) = MicroInc(Π, Φ[n]) = f ΦΠ (n) = k. (cid:2)for all n, (r1(n)/r2(n)) = s/t = k, limn→∞ f ΦΠ (n). SinceExample 21. For k = 2/5, if Δ = {∀x.P1(x) ∧ ¬P1(x), ∀x.P2(x) ∧ ¬P2(x)}, and Π = {P1, P2, P3, P4, P5}, all unarypredicate symbols, then for each n, r1(n) = 2 × n and r2(n) = 5 × n. Hence, limn→∞ f ΦΠ (n) = 2/5.Proposition 9. Let Δ be a knowledgebase that incorporates no variable symbols, and let Π be a set of predicatesymbols. If Φ = Models(Δ), then limn→∞ f ΦΠ (n) = 0.Proof. If Δ is a knowledgebase which incorporates no variable symbols, and Φ = Models(Δ), then there is a m ∈ N,such that for all n ∈ N, the numerator of hΦΠ (n) isΠ (n) converges to 0. (cid:2)a nondecreasing and nonnegative univariate polynomial function of n of degree at least 1, hΦΠ (n) is m (according to Proposition 4). Since, the denominator of hΦSo whilst (Π, Φ) may be inconsistent for any finite bistructure, in the limit it may be consistent (i.e. k may be 0).Intuitively, this means that the “inconsistent part” of the knowledge becomes “infinitely insignificant” in the limit. Weuse this result to give us the following nomenclature for a discord function f ΦΠ .Definition 22. For any Φ and Π , and for any k ∈ [0, 1],(Π, Φ) is k-inconsistent in the limitifflimn→∞f ΦΠ (n) = k.So by Proposition 9, a knowledgebase without variable symbols is always 0-inconsistent in the limit.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931085Proposition 10. Let Δ be a knowledgebase, Π a set of predicate symbols and Π (cid:13) ⊆ Π where Π (cid:13) includes the predicatesymbols of Π of the highest arity. If Φ = Models(Δ) then (Π, Φ) is k-inconsistent in the limit iff (Π (cid:13), Φ) is k-inconsistent in the limit.Π (n) = k, where the discord function isProof. By Definition 22, (Π, Φ) is k-inconsistent in the limit iff limn→∞ f ΦΠ (cid:13)(n) = k(cid:13). Let the highest arity of aΠ . Similarly, there is a discord function f Φf Φpredicate symbol in Π be p. Hence, there are polynomials c0 + c1n + c2n2 + · · · + cq nq and b0 + b1n + b2n2 + · · · +bpnp such thatΠ (cid:13) for (Π (cid:13), Φ) such that limn→∞ f Φf ΦΠ (n) =c0 + c1n + c2n2 + · · · + cq nqb0 + b1n + b2n2 + · · · + bpnpand there is a polynomial e0 + e1n + e2n2 + · · · + esns such thatΠ (cid:13)(n) = e0 + e1n + e2n2 + · · · + esnsf Φb0 + b1n + b2n2 + · · · + br npsince the power of the leading term for UniverseCount does not change.There are two cases.(Case 1) k = 0. This means that q < p and hence Φ (cid:16)|= ∀x1, . . . , xp.P (x1, . . . , xp) ∧ ¬P (x1, . . . , xp) for any arityp predicate symbol P . This remains the case if some predicate symbols are removed from Π , hence k(cid:13) = 0.(Case 2) k > 0. This means that q = p and hence there are cq predicate symbols P1, . . . , Pcq , such that Φ |=∀x1, . . . , xp.(Pi(x1, . . . , xp) ∧ ¬Pi(x1, . . . , xp)) for all i, 1 (cid:2) i (cid:2) cq . As long as all of these arity n predicate symbolsstay in Π (cid:13), we obtain s = q = p and cq = es . So limn→∞ f ΦΠ (n) = k, proving the result. (cid:2)Π (cid:13)(n) = limn→∞ f ΦSince we are primarily interested in measuring inconsistency in knowledgebases, the unbounded degree of in-consistency, in the form of a special function, is an efficient way of describing and analysing inconsistency inknowledgebases that have finite models. Furthermore, with the unbounded degree of inconsistency, we can categorisethe models for a knowledgebase as being either consistent in the limit (i.e. k = 0) or inconsistent in the limit (i.e.k > 0). Though note that the discord function gives a finer distinction than the k in the limit: Consider for exampletwo discord functions f and f (cid:13) with the same limit but for which f ΦΠΠ holds (such as 1/n2 and 1/n).(cid:17) f (cid:13)Φ6.5. Infinite degree of inconsistencyNow we turn to measuring inconsistency in bistructures with infinite domains. We have already argued that infinitedomains arise in diverse applications in artificial intelligence and computer science, such as when reasoning abouttemporal knowledge. Unfortunately, when we consider infinite domains, we are unable to consider inconsistency as aratio of the number of collisions in a model and the size of the universe. Therefore we need to take a more abstractapproach for extending our framework to analyse infinite frames adequately. To this end, we introduce the macrotypesposet.Definition 23. The macrotypes poset is a poset ((cid:2)m, {∞(cid:24), ∞⊥}) where ∞(cid:24) (cid:2)m ∞⊥ We call (cid:2)m the macrotypeordering and we call {∞(cid:24), ∞⊥} the macrotypes.For each bistructure with an infinite domain, we assign a macrotype as follows.Definition 24. Let Π be a set of predicate symbols and let E be a bistructure such that |Domain(E)| (cid:3) ℵ0. The Macfunction is defined as follows:(cid:8)(cid:8)(cid:8)Domain(E)(cid:8) (cid:3) ℵ0, and CollisionCount(Π, E) < ℵ0,(cid:8)(cid:8)(cid:8) (cid:3) ℵ0, and CollisionCount(Π, E) (cid:3) ℵ0,(cid:8)Domain(E)then Mac(Π, E) = ∞(cid:24)then Mac(Π, E) = ∞⊥IfIfIntuitively, for the macrotypes, the superscript (cid:24) denotes the bistructure is “overwhelmingly consistent”, and thesuperscript ⊥ denotes the bistructure is “substantially inconsistent”.1086J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093Example 22. Let Δ = {∀x.P (x), ∀x.¬P (x)}, Π = {P }, and E ∈ Models(Δ). If Domain(E) = N or Domain(E) = R,then Mac(Π, E) = ∞⊥.Example 23. Let Δ = {∀x.P (x), Q(a) ∧ ¬Q(a)}, Π = {P }, and E ∈ Models(Δ). If Domain(E) = N or Domain(E) =R, then Mac(Π, E) = ∞(cid:24).Now we can provide a measure of inconsistency for infinite frames. The definition takes a credulous view by usingthe bistructure in the frame with the minimum inconsistency according to the macrotype ordering.Definition 25. Let Π be a set of predicate symbols, and Φ an infinite frame. Let Infinite(Φ) = {E ∈ Φ | |D| (cid:3) ℵ0},where D is the domain of E. The infinite degree of inconsistency of (Π, Φ), denoted MacroInc(Π, Φ), is defined asfollows.For E ∈ Infinite(Φ),(cid:7)(cid:6)Mac(Π, E) (cid:2)m Mac(Π, E(cid:13))if ∀E(cid:13) ∈ Infinite(Φ)then MacroInc(Π, Φ) = Mac(Π, E),In order to better illustrate the measurement of the infinite degree of inconsistency, we consider some simpleexamples of knowledgebases for representing and reasoning with temporal knowledge.Example 24. For Δ = {∀x.(x (cid:17) 5) → ¬P (x), ∀x.P (x)} and Π = {P },(cid:6)(cid:7)Π, CPModels(Δ)(cid:6)(cid:7)Π, CIModels(Δ)= ∞(cid:24)= ∞⊥MacroIncMacroIncThe infinite degree of inconsistency is a function that is monotonic in one argument and antimonotonic in the otherargument, as captured by the following results.Proposition 11. If Π (cid:13) ⊆ Π , and Φ is an infinite frame, then MacroInc(Π (cid:13), Φ) (cid:2)m MacroInc(Π, Φ).Proof. Assume Π (cid:13) ⊆ Π . So, for all E ∈ Φ, CollisionCount(Π (cid:13), E) (cid:2) CollisionCount(Π, E). Therefore, for all E ∈Infinite(Φ), Mac(Π (cid:13), E) (cid:2)m Mac(Π, E). Therefore, MacroInc(Π (cid:13), Φ) (cid:2)m MacroInc(Π, Φ). (cid:2)Proposition 12. If Φ(cid:13) ⊆ Φ, and Φ and Φ(cid:13) are infinite frames, then MacroInc(Π, Φ) (cid:2)m MacroInc(Π, Φ(cid:13)).Proof. Assume Φ(cid:13) ⊆ Φ. For all E(cid:13) ∈ Φ(cid:13), there is an E ∈ Φ (namely E(cid:13)), such that CollisionCount(Π, E) (cid:2)CollisionCount(Π, E(cid:13)). So for all E(cid:13) ∈ Infinite(Φ(cid:13)), there is an E ∈ Infinite(Φ), such that Mac(Π, E) (cid:2)m Mac(Π, E(cid:13)).Therefore, MacroInc(Π, Φ) (cid:2)m MacroInc(Π, Φ(cid:13)). (cid:2)For knowledgebases Δ that are consistent by classical logic (i.e. Δ (cid:16)(cid:14) ⊥) we have the following result for the infinitedegree of inconsistency.Proposition 13. Let Δ be a knowledgebase and let Π be a set of predicate symbols. If Δ (cid:16)(cid:14) ⊥, then MacroInc(Π,Models(Δ)) = ∞(cid:24).Proof. If Δ (cid:16)(cid:14) ⊥, then there is a model E ∈ Infinite(Models(Δ)) such that CollisionCount(Π, E) = 0. Hence,MacroInc(Π, Models(Δ)) = ∞(cid:24). (cid:2)Similarly, if a knowledgebase is “completely inconsistent”, then we have the following result for the infinite degreeof inconsistency.Proposition 14. Let Δ be a knowledgebase and let Π be a set of predicate symbols. If for all E ∈ Finite(Models(Δ)),Inc(Π, E) = 1, then MacroInc(Π, Models(Δ)) = ∞⊥.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931087Proof. Let Φ = Models(Δ). If for all E ∈ Finite(Φ), Inc(Π, E) = 1, then by Proposition 3, we must have forall E ∈ Finite(Φ), E |= ∀x1, . . . , xk.P (x1, . . . , xk) ∧ ¬P (x1, . . . , xk) for all P ∈ Π . Hence, for all E ∈ Infinite(Φ),CollisionCount(Π, E) (cid:3) ℵ0. Therefore, MacroInc(Π, Models(Δ)) = ∞⊥. (cid:2)The following result shows that for any knowledgebase Δ, there is a “continuity” of the measurement of inconsis-tencies going from the subframe Finite(Models(Δ)) to the subframe Infinite(Models(Δ)).Theorem 4. Let Δ be a knowledgebase and let Φ = Models(Δ). If (Π, Φ) is k-inconsistent in the limit, and k > 0,then MacroInc(Π, Φ) = ∞⊥.Proof. By Theorem 1, (Π, Φ) is a smooth frame. Let (Π, Φ) be k-inconsistent in the limit and let k ∈ (0, 1]. ThereforeΠ (n) and polynomials b0 + b1n + b2n2 + · · · + bpnp and c0 + c1n + c2n2 + · · · + cq nq ,there exists a discord function f Φq (cid:2) p, such that for all n > n0,Π (n) = f ΦhΦΠ (n) =c0 + c1n + c2n2 + · · · + cq nqb0 + b1n + b2n2 + · · · + bpnp= r1(n)r2(n)wherek = limn→∞c0 + c1n + c2n2 + · · · + cq nqb0 + b1n + b2n2 + · · · + bpnpSince k > 0, it follows that q = p. As shown in Proposition 8, the only way this is possible is if we have at least onearity p predicate symbol P ∈ Π for which for all E ∈ Φ, E |= ∀x1 . . . xp.P (x1, . . . , xp) ∧ ¬P (x1, . . . , xp). Now, ifwe consider any E ∈ Infinite(Models(Δ)), then CollisionCount(Π, E) (cid:3) ℵ0 and so MacroInc(Π, Φ) = ∞⊥. (cid:2)However, if Φ is k-inconsistent in the limit, and k = 0, then it is not necessarily the case that MacroInc(Π, Φ) =∞(cid:24), as illustrated by the following example.Example 25. Consider a language that has a unary predicate P1 and a binary predicate P2. Let Δ = {∀x.P1(x) ∧¬P1(x)}. Here Φ is 0-inconsistent in the limit but MacroInc(Π, Φ) = ∞⊥ for Π = {P1, P2}.7. Framework for measuring consistencyWe can extend our analysis of inconsistency by also measuring “harmonies”. We view this as the complement toCollisionCount(Π, E), as explicated in the following definition for harmony.Definition 26. Let E be a bistructure, where D = Domain(E) and let Π be a set of predicate symbols.HarmonyCount(Π, E) =(cid:9)(cid:8)(cid:8)(cid:8)(cid:8)Harmony(Pi, E)where for each arity n predicate symbol Pi , Harmony(Pi, E) = Dn \ Collision(Pi, E)Pi ∈ΠWe can now use HarmonyCount(Π, E) as a second dimension, along with CollisionCount(Π, E), to compare mod-els. We can use this for both finite models and infinite models, but for finite models, with CollisionCount(Π, E), wecan calculate HarmonyCount(Π, E), whereas for infinite models, we cannot calculate HarmonyCount(Π, E) fromCollisionCount(Π, E).Consider a finite model with 5 elements for a language with a unary predicate R1 and a binary predicate R2. Thereare 5 atoms for R1 and 25 for R2, altogether there are 30 atoms. Suppose that for this model there are 4 collisions.Then there must be 30 − 4 = 26 “harmonies”. There is no need to deal separately with the number 26 because ifanother finite model with 5 elements for the same language has 3 collisions, it must have 27 harmonies and the seconddimension is irrelevant for comparing harmonies.The situation is different for infinite models. Suppose an infinite model for the same language has infinitely manycollisions. That does not tell us how many harmonies there are. Furthermore, suppose that D1 has infinitely many1088J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093collisions and 0 harmonies, while D2 has infinitely many collisions and 5 harmonies and D3 has infinitely manycollisions and infinitely many harmonies. It would be very reasonable to say that D3 is the least inconsistent model,D2 is next, and D1 is the most inconsistent. To capture this idea, we require the following notion of a profile.For the rest of this section, we will only deal with infinite bistructures.Definition 27. Let Π be a set of predicate symbols, and E a bistructure. The profile of (Π, E), denoted Pro(Π, E), isdefined as follows.Pro(Π, E) =(cid:3)CollisionCount(Π, E), HarmonyCount(Π, E)(cid:2)Using the profile function, we define an ordering relation over profiles as follows.Definition 28. Let Π be a set of predicate symbols, and E1 and E2 bistructures. If Pro(Π, E1) = (cid:3)a1, b1(cid:4) andPro(Π, E2) = (cid:3)a2, b2(cid:4), then the profile ordering, denoted (cid:2)Π , is defined as follows.E1 (cid:2)Π E2iffa1 (cid:2) a2 and b2 (cid:2) b1Also let E1 <Π E2 denote that E1 (cid:2)Π E2, and E2 (cid:16)(cid:2)Π E1, and let E1 ∼Π E2 denote that E1 (cid:2)Π E2, and E2 (cid:2)Π E1.So if E1 (cid:2)Π E2, then E1 is less inconsistent than, or equally inconsistent with, E2.+Example 26. Let E1 = (D1, I1 , Iand(cid:4)(cid:5)(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .(cid:5)(cid:4)(cid:3)1(cid:4), (cid:3)2(cid:4)II+1 (P ) =+1 (Q) =+2 (P ) =+2 (Q) =+3 (P ) =+3 (Q) =IIII(cid:5)(cid:4)(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .(cid:5)(cid:4)(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .(cid:5)(cid:4)(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .(cid:5)(cid:4)(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .−1 ), E2 = (D2, I+2 , I−2 ), and E3 = (D3, I+3 , I−3 ) be such that D1 = D2 = D3 = N(cid:4)(cid:5)(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .−1 (P ) =−1 (Q) = {}(cid:5)(cid:4)−(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .2 (P ) =(cid:5)(cid:4)−(cid:3)6(cid:4), (cid:3)7(cid:4), (cid:3)8(cid:4), . . .2 (Q) =(cid:5)(cid:4)−3 (P ) =(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .(cid:5)(cid:4)−(cid:3)2(cid:4), (cid:3)3(cid:4), (cid:3)4(cid:4), . . .3 (Q) =IIIIIIHence,= ℵ0= 0(cid:7)(cid:7)(cid:7)(cid:6){P }, E1CollisionCount(cid:6){Q}, E1CollisionCount(cid:6){P , Q}, E1CollisionCount(cid:6){P }, E2CollisionCount(cid:6){Q}, E2CollisionCount(cid:6){P , Q}, E2CollisionCount(cid:6){P }, E3CollisionCount(cid:6){Q}, E3CollisionCount(cid:6){P , Q}, E3CollisionCount(cid:7)(cid:7)(cid:7)(cid:7)= 0= ℵ0(cid:7)(cid:7)(cid:7)(cid:6){P }, E1HarmonyCount(cid:6){Q}, E1HarmonyCount(cid:6){P , Q}, E1= ℵ0 HarmonyCount(cid:6){P }, E2HarmonyCount(cid:6){Q}, E2HarmonyCount(cid:6){P , Q}, E2= ℵ0 HarmonyCount(cid:6){P }, E3HarmonyCount(cid:6){Q}, E3HarmonyCount(cid:6){P , Q}, E3= ℵ0 HarmonyCount(cid:7)(cid:7)(cid:7)(cid:7)= 0= 5(cid:7)= 0= 1(cid:7)= ℵ0= ℵ0(cid:7)= ℵ0= ℵ0(cid:7)= 5= 1= ℵ0So for Π = {P }, E1 ∼Π E2 and E2 ∼Π E3. And for Π (cid:13) = {P , Q}, E1 <Π (cid:13) E2 and E2 <Π (cid:13) E3.We now focus on a particular class of frames, called equiframes, that are defined next.Definition 29. A frame Φ is an equiframe iff for all Ei, Ej ∈ Φ, Domain(Ei) = Domain(Ej ).In the following, we consider equiframes Φ for which each E ∈ Φ is such that |Domain(E)| = ℵ0, and give adefinition for a profile for such equiframes. Some examples are given in Examples 27–30. We can consider alternativetypes of equiframes, for example equiframes Φ for which each E ∈ Φ is such that Domain(E) = [0, 1], in a similarway.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931089Definition 30. Let Π be a set of predicate symbols and let Φ be an equiframe of bistructures {Ei | i ∈ I } where I isan index set and the domain cardinality is ℵ0. Let Pro(Π, Ei) = (cid:3)ai, bi(cid:4) for all i ∈ I . Let a = Min({ai | i ∈ I }) and let(cid:12)b =Max({bi | i ∈ I })ℵ0if it existsotherwiseThe profile of (Π, Φ) is defined as Pro(Π, Φ) = (cid:3)a, b(cid:4).Example 27. For Δ1 = {∀x.P (x), ∀x.(x (cid:17) 6) → ¬P (x)}, let Φ1 = CPModels(Δ1). So Pro({P }, Φ1) = (cid:3)6, ℵ0(cid:4).Example 28. For Δ2 = {∀x.P (x), ∀x.¬P (x)}, let Φ2 = CPModels(Δ2). So Pro({P }, Φ2) = (cid:3)ℵ0, 0(cid:4).Example 29. For Δ3 = {∀x.P (x), ∀x.Q(x) ∧ ¬Q(x)}, let Φ3 = CPModels(Δ3).(cid:7)(cid:6){P }, Φ3(cid:6){Q}, Φ3(cid:6){P , Q}, Φ3(cid:7)ProProPro= (cid:3)0, ℵ0(cid:4)= (cid:3)ℵ0, 0(cid:4)(cid:7)= (cid:3)ℵ0, ℵ0(cid:4)Example 30. For Δ4 = {∀x.P (x)}, let Φ4 = CPModels(Δ4). So Pro({P }, Φ4) = (cid:3)0, ℵ0(cid:4).+i (P ) =Example 31. Let Φ5 be the frame {Ei | i ∈ N} where Ei = (N, Ii = 1, 2, 3, . . .{(cid:3)1(cid:4), (cid:3)2(cid:4), (cid:3)3(cid:4), . . .} and by ICollisionCount({P }, Ei) = ℵ0 and HarmonyCount({P }, Ei) = i. This is where we need to use the second line inthe definition of b in Definition 30, and find that Pro({P }, Φ5) = (cid:3)ℵ0, ℵ0(cid:4), even though no Ei has infinitely manyharmonies.−i (P ) = {(cid:3)i + 1(cid:4), (cid:3)i + 2(cid:4), (cid:3)i + 3(cid:4), . . .}. This means that for all−i ) for i = 1, 2, 3, . . . defined by I+i , IWe can compare profiles using the following profile ranking.Definition 31. If Pro(Π1, Φ1) = (cid:3)a1, b1(cid:4), and Pro(Π2, Φ2) = (cid:3)a2, b2(cid:4), then the profile ranking is defined as follows:Pro(Π1, Φ1) (cid:17) Pro(Π2, Φ2)iffa1 (cid:2) a2 and b2 (cid:2) b1Let Pro(Π1, Φ1) ≺ Pro(Π2, Φ2) denote that Pro(Π1, Φ1) (cid:17) Pro(Π2, Φ2) and Pro(Π2, Φ2) (cid:16)(cid:17) Pro(Π1, Φ1) andPro(Π1, Φ1)∼Pro(Π2, Φ2) denote that Pro(Π1, Φ1) (cid:17) Pro(Π2, Φ2) and Pro(Π2, Φ2) (cid:17) Pro(Π1, Φ1).Clearly, (cid:17) defines a total order.Example 32. Using Examples 27–30, we get the following profile ranking.(cid:6){P }, Φ3(cid:7)Pro∼ Pro(cid:6){P }, Φ4(cid:7)≺ Pro≺ Pro(cid:7)(cid:6){P }, Φ1(cid:6){P , Q}, Φ3(cid:7)∼ Pro(cid:6){P }, Φ5(cid:7)≺ Pro(cid:6){Q}, Φ3(cid:7)∼ Pro(cid:6){P }, Φ2(cid:7)In general, for an equiframe Φ that is a set of models from a knowledgebase Δ, such as CPModels(Δ), Pro(Π, Φ)is minimal in the (cid:17) ranking when Δ is consistent, and Pro(Π, Φ) is maximal in the (cid:17) ranking when for each E ∈ Φ,for all predicates P ∈ Π , E |= ∀x1, . . . , xk.P (x1, . . . , xk) ∧ ¬P (x1, . . . , xk).Proposition 15. For equiframes Φ1 and Φ2, if Φ1 ⊆ Φ2, then Pro(Π, Φ2) (cid:17) Pro(Π, Φ1).Proof. Let Pro(Π, Φ1) = (cid:3)a1, b1(cid:4) and Pro(Π, Φ2) = (cid:3)a2, b2(cid:4). Also let I1 be the index set for Φ1 and let I2 be the indexset for Φ2. Since Φ1 ⊆ Φ2, we have that I1 ⊆ I2. So by Definition 30, a2 (cid:2) a1 and b1 (cid:2) b2. Therefore, Pro(Π, Φ2) (cid:17)Pro(Π, Φ1). (cid:2)So increasing an equiframe Φ monotonically decreases Pro(Π, Φ) in the (cid:17) ordering. However increasing Πneither monotonically increases nor decreases Pro(Π, Φ) in the (cid:17) ordering, as we show by referring to Example 32for Φ3 where Pro({P }, Φ3) ≺ Pro({P , Q}, Φ3) ≺ Pro({Q}, Φ3).1090J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093The notions of harmony count, and of a profile, provide a potentially useful addition to our framework for analysinginconsistent first-order knowledgebases. As we discussed above, for finite domains, we can determine the harmoniesfor a bistructure from the collisions, but for infinite domains this is not possible. So for finite domains, harmony countcan be made explicit, and for infinite domains, harmony count provides further useful information for evaluating andcomparing inconsistent knowledgebases as illustrated in Examples 27–31. Furthermore, using the profile ranking (asillustrated in Example 32), we may for example choose a knowledgebase for which its set of models are minimal inthe profile ranking, if we are seeking better (i.e. less conflicting and more harmonious) sources of information.8. Tolerant logic generalises Belnap’s logicWe now compare our presentation of tolerant logic with Belnap’s four-valued logic. We only deal with the groundportion of FOL, because Belnap’s four-valued logic is propositional. Let G ⊆ Formulae(L) be the set of groundformulae in L that involve the ¬, ∨ and ∧ symbols. So if θ ∈ G, then θ contains no variable symbols nor any quantifiersymbols. An interpretation in Belnap’s four-valued logic is a truth assignment t that for the atoms of G assigns a valuein {T , F, N, B}, and for an arbitrary formula θ ∈ G, t (θ ) is defined by the truth tables for Belnap’s four-valued logicgiven in Tables 1 to 3. The lattice ordering is given as B > T , B > F , T > N , and F > N . In particular, t (θ ) (cid:3) T ifft (θ ) = B or t (θ ) = T .Definition 32. Let t be a Belnap truth assignment, t : G (cid:11)→ {T , F, N, B}, and let E be a bistructure. t represents E forall atoms in G iff for all atoms α ∈ G, the following constraints hold for t and E.t (α) = N iff E (cid:16)|= α and E (cid:16)|= ¬αt (α) = F iff E (cid:16)|= α and E |= ¬αt (α) = Tiff E |= α and E (cid:16)|= ¬αt (α) = B iff E |= α and E |= ¬αFor θ ∈ G, the satisfaction relation for tolerant logic, given by |=, coincides with the semantics for Belnap’s four-valued logic as shown by the following result.Table 1Truth table for negationα¬αNNTable 2Truth table for conjunction∧NFTBNNFNFTable 3Truth table for disjunction∨NFTBNNNTTFTFFFFFFNFTBTFTNFTBTTTTTBBBFFBBBTBTBJ. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931091Theorem 5. Let t be a Belnap truth assignment t : G (cid:11)→ {T , F, N, B}, and let E be a bistructure such that t representsE for A. For θ ∈ G,t (θ ) (cid:3) Tiff E |= θProof. By induction on the length of a formula. The base case is where θ is a literal. Then t (θ ) (cid:3) T iff E |= θ byDefinition 32. For the induction we assume the inductive hypothesis that t (α) (cid:3) T iff E |= α and t (β) (cid:3) T iff E |= β.The following 5 cases exhaust all the possibilities and complete the proof.Case 1: θ is of the form α ∧ β.t (α ∧ β) (cid:3) Tt (α) (cid:3) T and t (β) (cid:3) T by Table 2iffiff E |= α and E |= β by the inductive hypothesisiff E |= α ∧ β by Definition 5Case 2: θ is of the form α ∨ β.t (α ∨ β) (cid:3) Tt (α) (cid:3) T or t (β) (cid:3) T by Table 3iffiff E |= α or E |= β by the inductive hypothesisiff E |= α ∨ β by Definition 5Case 3: θ is of the form ¬(α ∧ β).(cid:7)(cid:6)¬(α ∧ β)(cid:3) Ttt (α ∧ β) (cid:3) F by Table 1t (α) (cid:3) F or t (β) (cid:3) F by Table 2t (¬α) (cid:3) T or t (¬β) (cid:3) T by Table 1iffiffiffiff E |= ¬α or E |= ¬β by the inductive hypothesisiff E |= ¬(α ∧ β) by Definition 5Case 4: θ is of the form ¬(α ∨ β).(cid:7)(cid:6)¬(α ∨ β)(cid:3) Ttt (α ∨ β) (cid:3) F by Table 1t (α) (cid:3) F and t (β) (cid:3) F by Table 3t (¬α) (cid:3) T and t (¬β) (cid:3) T by Table 1iffiffiffiff E |= ¬α and E |= ¬β by the inductive hypothesisiff E |= ¬(α ∨ β) by Definition 5Case 5: θ is of the form ¬¬α.t (¬¬α) (cid:3) Tt (α) (cid:3) T by Table 1iffiff E |= α by the inductive hypothesisiff E |= ¬¬α by Definition 5(cid:2)Whilst Belnap’s four-valued logic is a simple, intuitive and well-known proposal, there are some interesting, thoughmore complex proposals, that are variants of Belnap’s proposal, such as a proposal by Arieli and Avron that has apreferential semantics which selects those models for a knowledgebase that are minimal with respect to the assignmentof the B truth value [1]. These variants on Belnap’s proposal may offer some useful developments of the frameworkfor analysing inconsistent information presented in this paper.9. DiscussionThe need to develop robust, but principled, logic-based techniques for analysing inconsistent information is in-creasingly recognised as an important research area for artificial intelligence in particular, and for computer sciencein general. This interest stems from the recognition that the dichotomy between consistent and inconsistent set offormulae that comes from classical logics is not sufficient for describing inconsistent information.A number of proposals have been made for measuring the degree of information in the presence of inconsistency[24,26,29,37], and for measuring the degree of inconsistency in information [14,15,18,20–22,24–26]. For a reviewsee [17].1092J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–1093These measures are potentially important in diverse applications in artificial intelligence, such as belief revision,belief merging, negotiation, multi-agent systems, decision-support, and software engineering tools. Already, measur-ing inconsistency has been seen to be a useful tool in analysing a diverse range of information types including newsreports [23], integrity constraints [14], information merging [34], ontologies [32], software specifications [8,30], andecommerce protocols [10].The current proposals for measuring inconsistency can be classified in two ways. The first approach involves“counting” the minimal number of formulae needed to produce the inconsistency. The more formulae needed toproduce the inconsistency, the less inconsistent the set [25]. This idea is an interesting one, but it rejects the possibilityof a more fine-grained inspection of the (content of the) formulae. In particular, if one looks to singleton sets only, oneis back to the initial problem, with only two values: consistent or inconsistent.The second approach (which includes the proposal presented in this paper) involves looking at the proportion ofthe language that is touched by the inconsistency. This allows us to look inside the formulae [14,20,24]. This meansthat two formulae (singleton sets) can have different inconsistency measures. In these proposals one can identify theset of formulae with its conjunction (i.e. the set {ϕ, ϕ(cid:13)} has the same inconsistency measure as the set {ϕ ∧ ϕ(cid:13)}). Thismeans that the distribution of the contradiction among the formulae is not taken into account.Recently, there has been a proposal to combine the first and second approaches in a unified framework [18].The framework, based on coalitional game theory, supports inconsistency measures that are able to look inside theformulae, but also to take into account the distribution of the contradiction among the different formulae of the set,allowing for the identification of the blame/responsibility of each formula of the knowledgebase in the inconsistency.All the proposals discussed above are based on propositional logic, apart from [15], which deals mainly withinfinite models, and [14] which is based on a restricted form of first-order logic. So the proposal in this paper, basedon tolerant logic, is the first proposal for measuring inconsistency in first-order knowledge. This potentially offersconsiderable advantages for applications in artificial intelligence and computer science involving first-order logic.AcknowledgementThe authors are very grateful to the anonymous reviewers of this paper as well as Yue Ma and Guilin Qi for theirvaluable suggestions for improvements.References[1] O. Arieli, A. Avron, The value of the four values, Artificial Intelligence 102 (1998) 97–141.[2] M. Arenas, L. Bertossi, M. Kifer, Applications of annotated predicate calculus to querying inconsistent databases, in: Computational Logic(CL’2000), in: LNCS, vol. 1861, Springer, 2000, pp. 926–941.[3] L. Bertossi, J. Chomicki, Query answering in inconsistent databases, in: G. Saake, J. Chomicki, R. van der Meyden (Eds.), Logics for EmergingApplications of Databases, Springer, 2003.[4] S. Benferhat, D. Dubois, S. Kaci, H. Prade, Encoding information fusion in possibilistic logic: A general framework for rational syntacticmerging, in: Proceedings of the 14th European Conference on Artificial Intelligence (ECAI’2000), IOS Press, 2000, pp. 3–7.[5] N. Belnap, A useful four-valued logic, in: G. Epstein (Ed.), Modern Uses of Multiple-Valued Logic, Reidel, 1977, pp. 8–37.[6] L. Bertossi, A. Hunter, T. Schaub, Introduction to inconsistency tolerance, in: Inconsistency Tolerance, in: LNCS, vol. 3300, Springer, 2004,pp. 1–16.[7] C. Baral, S. Kraus, J. Minker, V.S. Subrahmanian, Combining knowledgebases of first-order theories, Computational Intelligence 8 (1992)45–71.[8] B. Barragáns-Martínez, J. Pazos-Arias, A. Fernández-Vilas, On measuring levels of inconsistency in multi-perspective requirements specifi-cations, in: Proceedings of the 1st Conference on the Principles of Software Engineering (PRISE’04), 2004, pp. 21–30.[9] W. Carnielli, J. Marcos, A taxonomy of C systems, in: Paraconsistency: The Logical Way to the Inconsistent, Marcel Dekker, 2002, pp. 1–94.[10] Q. Chen, C. Zhang, S. Zhang, A verification model for electronic transaction protocols, in: Advanced Web Technologies and Applications, in:LNCS, vol. 3007, Springer, 2004, pp. 824–833.[11] N.C. da Costa, On the theory of inconsistent formal systems, Notre Dame Journal of Formal Logic 15 (1974) 497–510.[12] S. de Amo, W. Carnielli, J. Marcos, A logical framework for integrating inconsistent information in multiple databases, in: Proceedings of theSecond International Symposium on Foundations of Information and Knowledge Systems, in: LNCS, vol. 2284, Springer, 2002, pp. 67–84.[13] A. Finkelstein, D. Gabbay, A. Hunter, J. Kramer, B. Nuseibeh, Inconsistency handling in multi-perspective specifications, IEEE Transactionson Software Engineering 20 (8) (1994) 569–578.[14] J. Grant, A. Hunter, Measuring inconsistency in knowledgebases, Journal of Intelligent Information Systems 27 (2006) 159–184.[15] J. Grant, Classifications for inconsistent theories, Notre Dame Journal of Formal Logic 19 (1978) 435–444.[16] J. Grant, V.S. Subrahmanian, Applications of paraconsistency in data and knowledge bases, Synthese 125 (2000) 121–132.J. Grant, A. Hunter / Artificial Intelligence 172 (2008) 1064–10931093[17] A. Hunter, S. Konieczny, Approaches to measuring inconsistent information, in: Inconsistency Tolerance, in: LNCS, vol. 3300, Springer,2004, pp. 189–234.[18] A. Hunter, S. Konieczny, Shapley inconsistency values, in: Proceedings of the 10th International Conference on Knowledge Representation(KR’06), AAAI Press, 2006, pp. 249–259.[19] A. Hunter, B. Nuseibeh, Managing inconsistent specifications: Reasoning, analysis and action, ACM Transactions on Software Engineeringand Methodology 7 (1998) 335–367.[20] A. Hunter, Measuring inconsistency in knowledge via quasi-classical models, in: Proceedings of the National Conference on Artificial Intel-ligence (AAAI’02), MIT Press, 2002, pp. 68–73.[21] A. Hunter, Evaluating significance of inconsistencies, in: Proceedings of the 18th International Joint Conference on Artificial Intelligence(IJCAI’03), 2003, pp. 468–473.[22] A. Hunter, Logical comparison of inconsistent perspectives using scoring functions, Knowledge and Information Systems Journal 6 (2004)528–543.[23] A. Hunter, How to act on inconsistent news: Ignore, resolve, or reject, Data and Knowledge Engineering 57 (2006) 221–239.[24] S. Konieczny, J. Lang, P. Marquis, Quantifying information and contradiction in propositional logic through epistemic actions, in: Proceedingsof the 18th International Joint Conference on Artificial Intelligence (IJCAI’03), 2003, pp. 106–111.[25] K. Knight, Measuring inconsistency, Journal of Philosophical Logic 31 (2001) 77–98.[26] K. Knight, Two information measures for inconsistent sets, Journal of Logic, Language and Information 12 (2003) 227–248.[27] S. Konieczny, R. Pino Perez, On the logic of merging, in: Proceedings of the Sixth International Conference on Principles of KnowledgeRepresentation and Reasoning (KR’98), Morgan Kaufmann, 1998, pp. 488–498.[28] J. Lin, A.O. Mendelzon, Merging databases under constraints, International Journal of Cooperative Information Systems 7 (1) (1998) 55–76.[29] E. Lozinskii, Information and evidence in logic systems, Journal of Experimental and Theoretical Artificial Intelligence 6 (1994) 163–193.[30] K. Mu, Z. Jin, R. Lu, W. Liu, Measuring inconsistency in requirements engineering, in: Symbolic and Quantitative Approaches to Reasoningwith Uncertainty (ECSQARU’05), in: LNAI, vol. 3571, Springer, 2005, pp. 440–451.[31] M. Martinez, A. Pugliese, G. Simari, V.S. Subrahmanian, H. Prade, How dirty is your relational database? an axiomatic approach, in: Symbolicand Quantitative Approaches to Reasoning with Uncertainty (ECSQARU’07), in: LNCS, vol. 4724, Springer, 2007, pp. 103–114.[32] Y. Ma, G. Qi, P. Hitzler, Z. Lin, Measuring inconsistency for description logics based on paraconsistent semantics, in: Symbolic and Quanti-tative Approaches to Reasoning and Uncertainty (ECSQARU’07), in: LNCS, vol. 4724, Springer, 2007, pp. 30–41.[33] G. Priest, Reasoning about truth, Artificial Intelligence 39 (1989) 231–244.[34] G. Qi, W. Liu, D. Bell, Measuring conflict and agreement between two prioritized belief bases, in: Proceedings of the Nineteenth InternationalJoint Conference on Artificial Intelligence (IJCAI’05), 2005, pp. 552–557.[35] R. Reiter, Equality and domain closure in first-order databases, Journal of the Association of Computing Machinery 27 (2) (1980) 235–249.[36] D. Sarenac, R. Jennings, Implication, preservation, and truth, in: Proceedings of the International Conference on Artificial Intelligence, CSREAPress, 2001.[37] P. Wong, Ph. Besnard, Paraconsistent reasoning as an analytic tool, Journal of the Interest Group in Propositional Logic 9 (2001) 233–246.