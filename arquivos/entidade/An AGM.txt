Artificial Intelligence 174 (2010) 72–104Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintAn AGM-style belief revision mechanism for probabilistic spatio-temporallogicsJohn Grant a,c, Francesco Parisi b, Austin Parker c, V.S. Subrahmanian c,∗a Towson University, Towson, MD 21252, USAb Università della Calabria, 87036 Rende (CS), Italyc University of Maryland, College Park, MD 20742, USAa r t i c l ei n f oa b s t r a c tArticle history:Received 27 February 2009Received in revised form 21 September2009Accepted 6 October 2009Available online 14 October 2009Keywords:Belief revisionReasoning about motionSpatio-temporal logicsUncertainty managementThere is now extensive interest in reasoning about moving objects. A probabilistic spatio-temporal (PST) knowledge base (KB) contains atomic statements of the form “Object ois/was/will be in region r at time t with probability in the interval [(cid:2), u]”. In this paper,we study mechanisms for belief revision in PST KBs. We propose multiple methods forrevising PST KBs. These methods involve finding maximally consistent subsets and maximalcardinality consistent subsets. In addition, there may be applications where the user hasdoubts about the accuracy of the spatial information, or the temporal aspects, or aboutthe ability to recognize objects in such statements. We study belief revision mechanismsthat allow changes to the KB in each of these three components. Finally, there may bedoubts about the assignment of probabilities in the KB. Allowing changes to the probabilityof statements in the KB yields another belief revision mechanism. Each of these beliefrevision methods may be epistemically desirable for some applications, but not for others.We show that some of these approaches cannot satisfy AGM-style axioms for belief revisionunder certain conditions. We also perform a detailed complexity analysis of each of theseapproaches. Simply put, all belief revision methods proposed that satisfy AGM-style axiomsturn out to be intractable with the exception of the method that revises beliefs by changingthe probabilities (minimally) in the KB. We also propose two hybrids of these basicapproaches to revision and analyze the complexity of these hybrid methods.© 2009 Elsevier B.V. All rights reserved.1. IntroductionThere are numerous applications where we need to reason about probabilistic spatio-temporal applications. A shippingcompany may be interested in continuously tracking the locations of its vehicles. As RFID tags become ever more common,companies (pharma, automotive, electronics) are interested in tracking supply items and in understanding where these itemsare now, and where they might be in the future. Military agencies are interested in tracking where vehicles might be — nowand in the future. Cell phone companies are interested in when and where cell phones might be in the future in order todetermine how best to balance load on cell towers. Moreover, all these applications have an essential component involvinguncertainty. Predicting where a cell phone might be in the future may be derived probabilistically from past logs showingthe phones’ location. Likewise, predicting where and when an RFID tag will be is subject to uncertainty. Where and when aship will reach a given geolocation is also subject to many forces that cannot be accurately specified, even when a scheduleis available.* Corresponding author.E-mail addresses: jgrant@towson.edu (J. Grant), fparisi@deis.unical.it (F. Parisi), austinjp@cs.umd.edu (A. Parker), vs@cs.umd.edu (V.S. Subrahmanian).0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2009.10.002J. Grant et al. / Artificial Intelligence 174 (2010) 72–10473Methods to reason about probabilistic spatio-temporal (PST) information have emerged in recent years, both in databases[20] and in AI [5,18]. In this paper, we build upon the results of [20]. Our PST knowledge base contains a set of facts of theform loc(id, r, t)[(cid:2), u] which informally states that “Object o is somewhere in region r at time t with a probability between(cid:2) and u (inclusive)”. A more formal description will be provided shortly in the paper.One important aspect of applications such as those mentioned above is that there is continuous change. As objects move,they encounter unexpected situations, leading to a continuous revision of estimates of where they might be in the future, aswell as a revision of where they might have been in the past. Surprisingly, to date, we are not aware of any effort to handlerevisions to such PST knowledge bases. A PST knowledge base K can be revised in many different ways. Clearly, when theinsertion of a fact ra into the knowledge base leads to no inconsistency, i.e. K ∪ {ra} is consistent, then ra can just be addedto K. However, when K ∪ {ra} is inconsistent, then many different belief revision operations are possible.In this paper, we focus on several different ways in which to revise K based on various epistemic intuitions.• Following on much work in classical reasoning about inconsistency in AI, our revision could try to find a maximal (w.r.t.either subset inclusion or cardinality) subset K(cid:4)of K that is consistent with ra — in this case, the revision of K w.r.t.the update ra is K(cid:4) ∪ {ra}. We study these two revision strategies, show that they satisfy AGM-style axioms (defined inSection 2), and that they lead to computational intractability.• It is also possible to revise K when ra is inserted by minimally modifying the spatial, temporal, or object componentsin K.– We first propose a revision mechanism based on just modifying the object ids in a PST KB. An application user ordeveloper may wish to use this strategy for an application when there is reason to believe that the object ids arelikely to be incorrect. This may occur, for instance, when the PST KB is generated using an image processing program(e.g. a car license plate reader) that may be “off”.– We also propose a revision mechanism based on just modifying the temporal component in a PST KB. An applicationuser or developer may wish to use this strategy for an application when there is reason to believe that the timesreported are “off”. This may be due to historical skepticism such as the belief that the clocks used to automaticallygenerate PS KBs in the application are flawed.– We also propose a revision mechanism based on just modifying the spatial component in a PST KB. An applicationuser or developer may wish to use this strategy for an application when there is reason to believe that the regionsare inaccurate. This may be due to the fact that GPS transponders exhibited errors previously.We develop all these revision mechanisms. We show that spatial revisions may not satisfy AGM-style axioms and thatthe other mechanisms — though they satisfy AGM-style axioms — are computationally intractable.• We also propose three revision mechanisms based on revising the probability intervals in a PST KB. In one, only thelower bound is modified, in another, only the upper bound is modified, and in the third, both may be simultaneouslymodified. We show that the last mechanism not only satisfies AGM-style axioms, but that there is a polynomial timealgorithm to compute this update mechanism. An end user may use this mechanism when there is reason to believethat the probabilities in a PST KB are likely to be incorrect.• We also propose a revision mechanism that allows simultaneous changes to each of the spatial, temporal, object, andprobability components in PST KBs. The user can specify how unlikely each of these mechanisms may be wrong bysetting appropriate weights.Fig. 1 summarizes the types of revision methods proposed in this paper — it also states whether the method satisfies AGM-style axioms or not, and the computational complexity involved. As probabilistic revision is polynomial, we spend a fairamount of time focusing on speeding this up via the use of a suite of heuristics.Fig. 1. A summary of this paper’s results. Unless otherwise stated, all results assume that T is finite.74J. Grant et al. / Artificial Intelligence 174 (2010) 72–104This paper builds on some of our previous work on representing and reasoning about probabilistic spatio temporal (PST)knowledge bases [23]. Section 2 formalizes the notion of a PST KB from some of our past work, overviews AGM axiomsfor updating logical theories, and provides a linear programming based algorithm to check the consistency of PST KBs.Section 3 provides many possible ways of revising a PST KB and shows which of these methods satisfy AGM-style axioms,and also analyzes the computational complexity of implementing these methods. Section 4 provides two hybrid methods torevise PST KBs based on the basic methods proposed previously. We study whether these hybrid methods satisfy AGM-styleaxioms, as well as the computational complexity of these methods. Section 5 identifies a partitioning strategy that may beused to more quickly find an approximate solution to probabilistic revision problems. Section 6 compares our work withrelated work in the scientific literature. At the end, Section 7 identifies directions for future work on reasoning about PSTKBs.All proofs not given in the text are given in Appendices A and B.2. Background: Formal model[20,21] proposes a framework for probabilistic spatio-temporal reasoning in which we can reason about statementsof the form “Object o is/was/will be in region r at time t with a probability within the interval [(cid:2), u]”. We assume theexistence of some finite set ID of object ids. We generally assume a finite convex set S of points in a 2-dimensional space1;however, in some cases the 2-dimensionality of space is irrelevant and we simply deal with a set of points, |S| > 1. We usedistance(p, q) to represent the Euclidean distance between p and q. We assume that time, T , is represented by the set of allnon-negative integers. However, in some cases, as specified later, we will assume that T is a finite set: T = {0, 1, . . . , N} forsome integer N. Though time may be infinite in theory, virtually all real world applications are only intended to last somenumber of years and so, for practical applications, it is reasonable to assume that PST knowledge bases are only intended tolast for a finite window of time in the future. We also assume that an object cannot be at two different points at the sametime, although two objects may be at the same point at the same time.Definition 1. If id ∈ ID, t ∈ T , r ⊆ S (r (cid:7)= ∅), then loc(id, r, t) is called an ST atom. A PST atom is an ST atom annotated withprobabilistic parameter [(cid:2), u], where 0 (cid:2) (cid:2) (cid:2) u (cid:2) 1, and is denoted as loc(id, r, t)[(cid:2), u].Intuitively, an ST atom loc(id, r, t) says that the object with the given id is somewhere on a location in region r attime t. Let Pr(loc(id, r, t)) denote the probability that event loc(id, r, t) occurs. The PST atom loc(id, r, t)[(cid:2), u] means that(cid:2) (cid:2) Pr(loc(id, r, t)) (cid:2) u. Soon we will define the concept of a PST knowledge base which contains a set of PST atoms, theprobabilistic information about the location of objects at various times, as well as constraints on the movement of objects.We now introduce the PST atoms for an example that will be used throughout the paper to illustrate various concepts.Example 1. Fig. 2 shows (rectangular) regions R0, . . . , R4 in Beijing. A worker living in the home at location (3, 3) commutesto the factory at (8, 7) every weekday from 7:30am to 8:00am. We will therefore use the time series 0, 1, 2, . . . , 30 todenote the 31 possible minutes between 7:30am and 8am (i.e. time 5 is 7:35). The worker can take one of many pathsto work, but through observation, we determined that he is almost always in the vicinity of work after 7:58. In PST-syntax: loc(worker, R2, 28)[0.9, 1], loc(worker, R2, 29)[0.9, 1], loc(worker, R2, 30)[0.9, 1]. Further, the worker is in the vicinityof work by 7:45 half the time: loc(worker, R2, 15)[0.5, 0.5]. We know that the worker almost never travels anywhere inR1: loc(worker, R1, 0)[0, 0.01], . . . , loc(worker, R1, 30)[0, 0.01], and that half the time, the worker gets breakfast at a placesomewhere in R3 at 7:45: loc(worker, R3, 15)[0.5, 0.5]. We denote the knowledge base containing these atoms as KBeijing.Probabilistic intervals such as [(cid:2), u] allow for a more flexible approach that subsumes the commonly used single proba-bility for each point: one can always use the singleton interval [p, p]. With probabilistic intervals, there are fewer restrictionson the data generation process — the probability need not be determined exactly, but only within a range. Furthermore,even if all data about basic events only contained point probabilities, the implied probabilities of complex (e.g. conjunctiveor disjunctive) events end up being intervals unless additional assumptions such as independence assumptions are made.dis-For instance, suppose an object is in region r with 50% probability. Then we can infer that the object is in a region rjoint from r with a probability in the interval [0, 0.5]. We would not, however, be able to infer anything if all our inferenceswere limited to a notation allowing only point probabilities. Therefore we continue the tradition of the probabilistic spatialtemporal logics in [20,21] with our use of probability intervals.(cid:4)In the initial work in [20,21], it was assumed that there were no velocity constraints on moving objects — obviously, thiswas not realistic. Moreover, it was assumed that all points in S are reachable from all other points by all objects — obviouslythis is not always a valid assumption as well. For example, a 2-dimensional representation of the world (or even just of thestate of Maryland), consists of regions that are reachable by some vehicles (e.g., cars) but not by others (e.g., boats) and vice1 The framework is easily extensible to higher dimensions. The finiteness requirement ensures that a potentially continuous 2-dimensional space issomehow discretized. Virtually all existing real world geographic information systems [27] assume that space is discretized into a grid of size M × N forsome M, N (cid:2) 1 and most geographic data structures such as quadtrees, R-trees, etc. supported by GISs make the same assumption.J. Grant et al. / Artificial Intelligence 174 (2010) 72–10475Fig. 2. An example PST knowledge base representing possible locations of a commuter in Beijing, China. The lines represent possible paths that can betaken to the factory and to the park.versa. We provide a very general notion of a reachability atom and a reachability definition below that allows us to capturethese concepts and use a more real-world framework than that provided in [20,21].Definition 2. If p1, p2 ∈ S and id ∈ ID, then reachableid(p1, p2) is called a reachability atom. A reachability definition RD, is afinite set of reachability atoms.Intuitively, the reachability atom reachableid(p1, p2) says that it is possible for the object id to reach location p2 fromlocation p1 in one unit of time. Note that this definition is very general — what is reachable in one time point dependsnot only on the place p1, but also the object id. For example, the same object may move at a very low speed when goingfrom p1 to p2 (e.g., a steep upward slope) and at a different speed when going from p2 to p3. Likewise, different vehiclesmay also exhibit different maximal speeds depending upon the type of vehicle (trucks might go slower than Ferraris forinstance). We also assume that the points in S are close enough together or the time units are long enough, so that anadjacent2 point never requires more than one time unit to be reached if it can be reached at all.Though the definition of RD appears to require explicit storage, this is not necessary when implementing a PST KB. RDmay be dynamically determined — for instance by invoking a third party code base such as Google Maps. Without loss ofgenerality, we assume that RD contains reachableid(p, p) for all p ∈ S and id ∈ ID. This merely says that if id is at p, it canreach the same point p within one time unit.Definition 3. Given a reachability definition RD, we define connectedid(p1, p2) as the transitive closure of reachableid(p1, p2).A reachability definition is fully connected if connectedid(p1, p2) holds for every id ∈ ID and p1, p2 ∈ S.Thus connectedid(p1, p2) means that id can get from p1 to p2 but not necessarily in one unit of time. We now present asimple example.Example 2. If we allow the worker from Example 1 to travel at most a Manhattan distance of 2 each time point,3 thiscreates a natural reachability definition RDworker where reachableid((x1, y1), (x2, y2)) ∈ RDworker iff |x1 − x2| + | y1 − y2| (cid:2) 2.This simple reachability definition is clearly fully connected.2 Points p1 = (x1, y1) and p2 = (x2, y2) are adjacent if |x1 − x2| + | y1 − y2| = 1.3 Manhattan distance is the standard L1 norm: for (x1, y1) and (x2, y2) it is |x1 − x2| + | y1 − y2|.76J. Grant et al. / Artificial Intelligence 174 (2010) 72–104We now formally define a PST KB.Definition 4 (PST KB). A PST knowledge base is a pair (K, RD) where K is a finite set of PST atoms and RD is a reachabilitydefinition.Example 3. Using the set KBeijing from Example 1, and the reachability definition RDworker from Example 2, we have the PSTknowledge base: (KBeijing, RDworker).Throughout this paper, we assume the existence of an arbitrary, but fixed reachability definition, RD, and refer to K as a PST KB. Wedefine the semantics of PST KBs through worlds.Definition 5 (World). A world w is a function, w : ID × T → S such that for all objects id, points p1, p2, and time points t1,t2 with t2 = t1 + 1 if w(id, t1) = p1 and w(id, t2) = p2 then reachableid(p1, p2) ∈ RD. W is the set of all worlds. To simplifyformulas later we will assume that w ranges over W .A world specifies where in space S an object o is at time t. A world w can be represented by the set of ST atomsloc(id, {p}, t) such that w(id, t) = p. We write w |(cid:10) loc(id, r, t) iff w(id, t) ∈ r. Example worlds W 1, W 2, and W 3 can be seenin Fig. 2. An interpretation assigns a probability to each world.Definition 6 (Interpretation). An interpretation I is a probability distribution over W .I(w) is the probability that w describes the actual locations of all the objects at all the time values.Example 4. Continuing with Example 1, two possible commutes the worker may take are shown in Fig. 2 as pathsW 1 and W 2. There is a further path the worker may take to the park labeled W 3. The function corresponding to W 1has the worker staying at home until 7:40am W 1(worker, t) = (3, 3) for t = 0, . . . , 10, then W 1(worker, 11) = (4, 3), andW 1(worker, 12) = (5, 3). At this point the worker stops for breakfast: W 1(worker, t) = (6, 4) for t = 13, . . . , 26. Then theworker continues to work: W 1(worker, 27) = (7, 4), W 1(worker, 28) = (8, 5), W 1(worker, 29) = (8, 6), and W 1(worker, 30) =(8, 7). The function for W 2 has the worker move directly along the path and staying at work, i.e. W 2(worker, 0) = (3, 3),W 2(worker, 1) = (4, 4), W 2(worker, 2) = (5, 4), W 2(worker, 3) = (6, 5), W 2(worker, 4) = (6, 6), W 2(worker, 5) = (7, 6), andW 2(worker, 6 . . . 30) = (8, 7).An example interpretation I assigns probability 0.5 to world W 1, probability 0.5 to world W 2, and probability 0 to allother worlds including W 3.The definition of satisfaction of a PST atom by an interpretation is as follows.Definition 7 (Satisfaction/Entailment).(cid:2)Interpretation I satisfies the PST atom a = loc(id, r, t)[(cid:2), u], denoted I |(cid:10) a,w|(cid:10)loc(id,r,t) I(w) ∈ [(cid:2), u]. I satisfies K, denoted I |(cid:10) K, iff I satisfies all a ∈ K. K entails K(cid:4), denoted K |(cid:10) K(cid:4)iff(resp. Kentails a, denoted K |(cid:10) a) iff all I satisfying K also satisfy K(cid:4)(resp. a).K is consistent iff there is an interpretation I that satisfies it. K and K(cid:4)interpretations I , I |(cid:10) K iff I |(cid:10) K(cid:4)from Example 1. Hence KBeijing is consistent. We will assume in all our work that we start with a consistent KB.) iff for all. For instance, the interpretation from Example 4 satisfies the PST knowledge base KBeijingare equivalent (denoted K ≡ K(cid:4)A PST atom a is consistent with K iff K ∪ {a} is consistent.Example 5. The atom loc(worker, R4, 29)[0.75, 0.75] is not consistent with the knowledge base KBeijing from Example 1 dueto the fact that KBeijing states that the worker is in region R2 at time 29 with probability in [0.9, 1] and R2 is disjointfrom R4. The total probability of the worker being on the map at time 29 would then exceed 1.However, loc(worker, R4, 29)[0.1, 0.1] is consistent with KBeijing — consider for instance an interpretation that gives tothe world W 3 a probability 0.1 (making the probability of being in region R4 also 0.1) and world W 1 a probability of 0.9(making the probability of being in region R2 0.9 as KBeijing requires).We are interested in studying the revision of PST KBs when a revision atom ra is added to K. We start by presentingAGM-style postulates [1] for this purpose. A revision operator (cid:3) is a binary function that takes K and ra as input, andproduces K (cid:3) ra as output. (cid:3) is required to satisfy these AGM-style axioms4 expressed in our framework as given below.4 As PST KBs are atomic, we do not discuss AGM axioms involving negation and disjunction.J. Grant et al. / Artificial Intelligence 174 (2010) 72–10477(A1) K (cid:3) ra is a PST KB.(A2) K (cid:3) ra |(cid:10) ra.(A3) (K ∪ {ra}) |(cid:10) (K (cid:3) ra).(A4) If ra is consistent with K then (K (cid:3) ra) |(cid:10) (K ∪ {ra}).(A5) K (cid:3) ra is inconsistent iff {ra} is inconsistent.(cid:4)then K (cid:3) ra ≡ K (cid:3) ra(A6) If ra ≡ ra.(cid:4)We say a revision strategy is AGM-compliant or that it satisfies the AGM axioms if it satisfies Axioms (A1)–(A6).2.1. Consistency checkingWe can check the consistency of a PST KB by solving a linear program. Because linear programs can be solved in timepolynomial in their input, consistency checking will run in polynomial time when the number of time points is bounded apriori.The linear program we use contains variables of the form v id,t,p,q, each representing the probability that object id willbe at point p at time t and then at point q at time t + 1 (i.e. the probability of loc(id, {p}, t) ∧ loc(id, {q}, t + 1)).For convenience, let minT(K) (resp. maxT(K)) be the minimum (resp. maximum) time point referenced in K. When Tis finite we have a priori bounds for minT(K) and maxT(K). For technical reasons, we include the time point maxT(K) + 1in T . A detailed explanation of the constraints is given after the definition.Definition 8 (LP(K)). LP(K), the linear program for K contains the following constraints where minT(K) (cid:2) t (cid:2) maxT(K):(1) For all loc(id, r, t)[(cid:2), u] ∈ K:(cid:3)(cid:3)(cid:2) (cid:2)v id,t,p,qp∈rq∈S(cid:2)(cid:2)and u (cid:4)(cid:3)(cid:3)p∈rq∈Sv id,t,p,q.q∈S v id,t,p,q = 1.(2) For all id, t:p∈S(3) For all p, q ∈ S and all id, t: v id,t,p,q (cid:4) 0.(4) For all p, q ∈ S and all id, t such that reachableid(p, q) /∈ RD: v id,t,p,q = 0.(5) For all p ∈ S and id, t:(cid:2)(cid:2)q∈S v id,t,q,p =q∈S v id,t+1,p,q.(cid:4)The constraints each serve their purpose. Constraint (1) ensures that a solution places the object in r with a probabilitybetween (cid:2) and u, as required by the atom loc(id, r, t)[(cid:2), u]. Constraints (2) and (3) ensure that for each id and t, the v id,t,p,qvariables jointly represent a proper probability distribution (i.e. sum to 1 and have non-negative probabilities). Constraint(4) enforces the reachability definition by assigning a probability of 0 to travel points p and q that cannot be reached in(cid:4), q), then the object couldone time step. Note that if there is a third point pstill travel between p and q because v id,t,p,p(cid:4) and v id,t+1,p(cid:4),q can both be non-zero. It would just take two time steps, whichis sensible when reachability says the object cannot travel from p to q in one time step. Constraint (5) is central to thecorrectness of our variable formulation. Since each variable v id,t,p,q gives the probability of being at p and moving to q, weneed something to ensure that id can in fact be at p at time t with the probability given by v id,t,p,q. Constraint (5) providesthat insurance, by forcing the probability of an object entering any point to be the same as the object leaving that point.such that reachableid(p, p(cid:4)) and reachableid(pNote that when a constraint of the form v id,t,p,q = 0 is included in LP(K) because of clause (4) above, the redundantconstraint v id,t,p,q (cid:4) 0 generated by clause (3) above can be eliminated, as well as all occurrences of this variable in otherconstraints. We take advantage of these simplifications in our implementation and solve linear programs consisting only ofvariables v id,t,p,q for which reachableid(p, q) holds.The following result gives a one to one correspondence between the problem of checking the consistency of K and theproblem of checking the solvability of the constraints LP(K).Theorem 1. (See Proposition 4 from [22].) LP(K) has a solution iff K is consistent.Proof. We present a sketch of the proof here. A complete proof can be found in [22].(cid:2)(⇒): Let θ be a solution satisfying LP(K). To construct a satisfying interpretation I , let α[id, p] be the probability that(cid:4)]θ , where we(cid:4)] to be the probability of moving from pid is at p at the first time point, minT(K) computed from θ as follows: α[id, p] =write v[id, t, p, q]θ for the value assigned by θ to v id,t,p,q. Now define δ[id, t, p, pto pp(cid:4)∈S v[id, minT(K), p, pat time t, or:(cid:4)δ[id, t, p, p(cid:4)] =(cid:2)(cid:4)]θv[id, t, p, pp(cid:4)(cid:4)∈S v[id, t, p, p(cid:4)(cid:4)]θ78(cid:2)(whenJ. Grant et al. / Artificial Intelligence 174 (2010) 72–104(cid:4)(cid:4)]θ = 0, δ is defined to be 0 as well). We can now define I for all w ∈ W as:p(cid:4)(cid:4)∈S v[id, t, p, p(cid:4)I(w) =αid∈ID(cid:5)id, w(id, 0)(cid:6) (cid:4)(cid:6)(cid:5)id, t, w(id, t), w(id, t + 1).δt,t+1∈TI can be shown to be an interpretation satisfying K.(cid:2)(⇐): Letw∈W, w(id,t)=p, w(id,t+1)=p(cid:4) I(w). θ can be shown to be a solution to LP(K). (cid:2)I be an interpretation which satisfies K. Define a variable assignment θsuch that: v id,t,p,p(cid:4) =The theorem yields a straightforward consistency checking algorithm: check if LP(K) has a solution using standard linearprogramming solvers.To determine the running time of this algorithm, we count the number of variables and equations in LP(K). The numberof variables is dependent upon the number of ids in the knowledge base, which is at most |K|, the number of points inspace, which is |S|, and the number of time points nt = maxT(K) − minT(K). This gives an upper bound of O (|K| · |S|2 · nt)variables in LP(K).The number of constraints in LP(K) is 2 · |K| for (1), plus one constraint per id and t for (2), plus at most |S|2 constraintsper id and t for (3) and (4), plus |S| constraints per id and t for (5) giving O (|K| · |S|2 · nt) constraints. The entire linearprogram’s size can be bounded by the number of variables times the number of constraints, that is, O ((|K| · |S|2 · nt)2).Linear programs are solvable in time cubic in the size of the linear constraints [15]. The running time required to finda solution to LP(K), thereby determining the consistency of K, is O ((|K| · |S|2 · nt)6). Therefore consistency checking ispolynomial in the size of the input knowledge base.3. Basic belief revision strategiesIn this section, we present six “basic” ways of revising consistent PST KBs. The first two ways use the standard methodstudied extensively in logical reasoning — eliminate entire atoms from K when the ra being inserted conflicts with K. Toadhere to the principle of minimal change, we can either remove a minimal subset of K or the smallest number of possiblePST atoms from K, leading to the first and second basic belief revision strategies (called MAX-SUBSET and MAX-CARDrevision strategies, respectively).Subsequently, we note that it might be possible to restore consistency by changing the region, or the time, or the id, orthe probability bounds associated with PST atoms in K when a new PST atom ra is inserted. These lead to another fourtypes of basic ways of revising PST KBs when insertions occur.We study these methods in the rest of this section.3.1. Maximal consistent subset revisionWe can define a revision operator (cid:3)m based on maximal consistent subsets as follows.Definition 9. Suppose K is a PST KB, ra a PST atom, and K(cid:4) ⊆ K. Then K(cid:4) ∪ {ra} accomplishes the revision of K by adding ravia the subset strategy iff K(cid:4)is a subset of K and K(cid:4) ∪ {ra} is consistent. We say that K(cid:4) ∪ {ra} accomplishes the revision of Kby adding ra via the max-subset strategy iff it accomplishes the revision of K by adding ra via the subset strategy and there isno other K(cid:4)(cid:4) ∪ {ra} that accomplishes the same revision such that K(cid:4) (cid:2) K(cid:4)(cid:4).This definition does not necessarily determine a unique revision. To achieve uniqueness a strict total ordering can beinduced on all K(cid:4)satisfying the above definition and the minimal element picked. Throughout the rest of this paper, we assumesuch a strict total ordering O T is available. We further assume that O T is polynomially computable: that is, one can determinethe relationship between K and K(cid:4)according to O T in polynomial time. We use the notation K (cid:3)m ra to denote the K(cid:4) ∪ {ra}that accomplishes the revision of K by adding ra via the max-subset strategy such that K(cid:4)is minimal under order O T .The following example exhibits both how maximal subset revision and the total ordering O T will function.Example 6. We revisit the set of atoms KBeijing from Example 1 with the reachability definition RDworker from Example 2.Suppose, in that example, that a camera in the park shows the worker there exactly 50% of the time at 7:45am. Thisconflicts with the knowledge base KBeijing, according to which the worker is either near the factory or in R3 both with 50%probability, and the worker cannot be in three different places each with 50% probability at the same time! The revisionatom here is: loc(worker, R4, 15)[0.5, 0.5].For explication purposes, we list the relevant subset of KBeijing:(cid:8)loc(worker, R3, 15)[0.5, 0.5], loc(worker, R2, 15)[0.5, 0.5](cid:7).To achieve consistency with the revision atom, only one of these atoms must be removed from KBeijing. Therefore there aretwo possible maximal subset revisions:J. Grant et al. / Artificial Intelligence 174 (2010) 72–10479• K1 = KBeijing \ {loc(worker, R3, 15)[0.5, 0.5]},• K2 = KBeijing \ {loc(worker, R2, 15)[0.5, 0.5]}(note that other sorts of revision, where the probabilities, the regions, the time, or even the ID are changed, will beaddressed later in this paper). Both K1 and K2 are consistent with the revision atom loc(worker, R4, 15)[0.5, 0.5], so todetermine which of K1 and K2 will be KBeijing (cid:3)m loc(worker, R4, 15)[0.5, 0.5], we consult the ordering O T . If K1 is “small-er” than K2 according to O T , then it is the answer. Suppose that in this case O T prefers atoms associated with R2 toatoms associated with R3, making K1 the “smaller” of the two revisions. Therefore KBeijing (cid:3)m loc(worker, R4, 15)[0.5, 0.5] =K1 ∪ {loc(worker, R4, 15)[0.5, 0.5]}.We now verify that (cid:3)m satisfies the AGM axioms.Proposition 1. (cid:3)m is AGM-compliant.Algorithm 1. Computes the maximal subset revision according to O T .MaxSubset(K, ra)Let list = [K] {list is the list of maximal subsets of K}while list is not empty donext List = [] {initialize the list for the next iteration.}{Traverse list in order.}for K(cid:4) ∈ list doIf K(cid:4) ∪ {ra} is consistent then continue to next K(cid:4){Remove each possible element from K(cid:4)for atm ∈ K(cid:4)}.doadd K(cid:4) \ {atm} to next List.end forend forSet list = next List.remove duplicates from list {Don’t check the same revision twice.}end whilereturn the minimal member of list according to O T .The MaxSubset algorithm shown as Algorithm 1 correctly computes the (cid:3)m revision operator. However, as the followingresult shows, the decision problem associated with computing (cid:3)m is intractable (so long as P (cid:7)= NP).Theorem 2. Given PST KBs K and K(cid:4), and revision atom ra, determining if K(cid:4) ∪ {ra} = K (cid:3)m ra is coNP-complete.Proof Sketch. Membership follows from the fact that if K(cid:4)can be determinedto be a better revision in polynomial time (since consistency is a polynomial time operation). That the problem is coNP-hard is done by reduction from the MCSS problem (Definition 29 in Appendix A), which, according to Lemma 1 (also inAppendix A), is coNP-hard. (cid:2)is not the best revision, then a witness K(cid:4)(cid:4)3.2. O TThe total ordering O T plays an essential role in the definition of the (cid:3) operators used in this paper. The templatewe use for defining the various revision methods will be to introduce a method by which the knowledge base can bechanged to create consistency (e.g. taking subsets of the knowledge base as above or changing some aspect of the datain the knowledge base). It will then generally be infeasible, without compromising the generality of the approach, to saywhich of the potential consistent changes is the best revision. We can easily imagine different subsets preferred in differentapplication domains, perhaps based on how the atoms were created, or their importance if true, etc. We therefore abstractout that last choice with O T , letting the user-supplied total ordering say which of the potential solutions is “best” for thegiven application. This is not an original approach, as it is similar to the selection mechanisms in the original work on AGMrevision [1].For our purposes, we suppose that O T runs in polynomial time in the representation and comparison of any two knowl-edge bases. This allows many possibilities for O T : it could prefer knowledge bases with regions closer to a given pointof interest, or O T could prefer knowledge bases with atoms further in the future, or prefer knowledge bases with tighterprobability intervals, and so on.80J. Grant et al. / Artificial Intelligence 174 (2010) 72–104Apart from establishing a unique answer to a given revision, the ordering O T will ensure the satisfaction of Axiom (A6).That axiom requires that even when the revision atoms differ syntactically, revision by either atom results in the sameanswer. Since consistency with the revision atom decides the set of possible revisions, the O T minimal revision will be thesame regardless of the syntax of semantically equivalent revision atoms.For these reasons O T will be used as part of the (cid:3) operators we define throughout this paper.3.3. Indeterminate MAX-SUBSET revision is polynomialWhen we examine the proof of Theorem 2, we note that the source of the complexity of maximal subset revision is thetotal ordering O T . The proof that determining if K(cid:4)is K (cid:3) {ra} is coNP-complete relies on the construction of a specifictotal ordering O T . However, if we are willing to give up uniqueness and ignore O T (as has been commonly done in variouspapers in the past [3]), then the result below shows that this problem can be solved in polynomial time.Theorem 3. Given PST KBs K and K(cid:4)and PST atom ra, determining whether K(cid:4) ∪ {ra} accomplishes the revision of K by adding ra viathe max-subset strategy according only to Definition 9 (irrespective of the order O T ) can be accomplished in polynomial time w.r.t.the size of K.To prove this theorem, we give a polynomial-time algorithm that returns true iff K(cid:4)is the max-subset revision of Kis not the max-subset revision of K (note that O T is used to establish which max-subsetw.r.t. ra, and returns false iff K(cid:4)revision is K (cid:3)m ra, and is therefore inconsequential).3.4. Maximal cardinality (MAX-CARD) revisionMax-subset revision turned out to be coNP-complete, but only because of the total ordering O T . In this section, weintroduce max-cardinality revision, where instead of ensuring that there is no superset consistent with the revision, onemust ensure that there is no larger-cardinality subset of the original knowledge base consistent with the revision atom.Definition 10. Suppose K is a PST KB, ra is a PST atom, and K(cid:4) ⊆ K. We say that K(cid:4) ∪ {ra} accomplishes the revision of K byadding ra via the max-cardinality strategy iff it accomplishes the revision of K by adding ra via the subset strategy and thereis no other K(cid:4)(cid:4) ∪ {ra} that accomplishes the revision via the subset strategy and |K(cid:4)| < |K(cid:4)(cid:4)|.Again, the issue of uniqueness is resolved through a strict total ordering O T . We denote the O T -minimal knowledgebase accomplishing max-cardinality revision of K with respect to ra as: K (cid:3)c ra. However, unlike max-subset revision,max-cardinality revision is coNP-hard regardless of O T .Theorem 4. Determining if K(cid:4)accomplishes max-cardinality revision of K by adding ra is coNP-complete.Proof Sketch. Membership can be denied by a witness K(cid:4)(cid:4)and is consistent with therevision, so the problem is in coNP. coNP-hardness is established by reduction from the MCSS problem (Definition 29 inAppendix A), which, according to Lemma 1 (also in Appendix A), is coNP-hard.that has larger cardinality than K(cid:4)Max cardinality subset revision may be expensive to compute; however, it still satisfies the AGM axioms. (cid:2)Proposition 2. For knowledge base K and revision atom ra, K (cid:3)c ra is an AGM-compliant revision function.We now show that we can find maximal cardinality revisions by solving a mixed integer linear program.5Consider a modified version of LP(K) (see Definition 8) where for each PST atom ai = loc(idi, ri, ti)[(cid:2)i, ui] in K, weinclude a binary (integer) variable δi . Our intention is that δi = 0 implies that ai is in the revised KB, while δi = 1 means aiis not in the revised KB.Definition 11 (Maximal Cardinality Subset Revision Program). Let the Maximal Cardinality Subset Revision Program for K andra, MCSRP(K, ra), contain the following constraints:1. For each ai = loc(idi, ri, ti)[(cid:2)i, ui] ∈ K:p∈riq∈S v idi ,ti ,p,q) (cid:2) ui + δi ,(cid:2)(cid:2)(a) (cid:2)i − δi (cid:2) ((b) δi ∈ {0, 1}.5 A linear program is a set of linear constraints and objective function where all variables range over the reals. An integer program is a set of linearconstraints (and objective function) where all variables range over integers. A mixed integer linear program is one where some variables may range overintegers, while others may range over the reals.(cid:4)2. For ra = loc(id, r(cid:2)p∈r(cid:4)(a) (cid:2) (cid:2)(cid:2)(cid:4))[(cid:2), u]:(cid:4), tq∈S v id(cid:4),t(cid:4),p,qJ. Grant et al. / Artificial Intelligence 174 (2010) 72–10481(cid:2) u.3. For each id in the knowledge base and each t in T :(cid:2)(cid:2)(a) For all p, q ∈ S, v id,t,p,q (cid:4) 0.(b)(c) For all p, q ∈ S, if reachableid(p, q) /∈ RD: v id,t,p,q = 0.(d) For all p ∈ S:q∈S v id,t,q,p =q∈S v id,t,p,q = 1.q∈S v id,t+1,p,q.p∈S(cid:2)(cid:2)The following result shows that there is a one to one correspondence between the solutions of a linear program associ-ated with MCSRP(K, ra) and a revision that accomplishes the insertion of ra into K using the max-cardinality strategy.Theorem 5. Suppose that K is a PST KB and ra a PST atom. Let θ be a solution of the optimization problem(cid:3)minimizeai ∈Kδisubject to MCSRP(K, ra).Then K(cid:4) = {ai ∈ K | δiθ = 0} ∪ {ra} accomplishes the revision of K by adding ra via the max-cardinality strategy.The preceding result provides a straightforward algorithm to find a max-cardinality revision. Just construct MCSRP(K, ra),solve the linear program stated in the preceding theorem, and use the solution as indicated in the preceding theorem.3.5. Minimizing spatial changeNow we can consider revising K by changing the spatial component r of PST atoms in K. A spatial revision of PST atomWe definep∈r minp(cid:4)∈r(cid:4) distance(p, p(cid:4) = loc(id, ra = loc(id, r, t)[(cid:2), u] is an atom of the form aregions given by:as(cid:2)of K contains at most one spatial(revision of each atom in K. The distance, (dS (K, K(cid:4))), is the sum of the distances between the individual atoms and theirassociated spatial revision.the Euclidean distance between points(cid:4))).6 A spatial revision K(cid:4)p(cid:4)∈r(cid:4) minp∈r distance(p, pthe distance dS (a, a(cid:4), t)[(cid:2), u].(cid:4))) + (in the(cid:2)(cid:4))Definition 12. A spatial revision K(cid:4)revision K(cid:4)(cid:4)of K by adding ra such that K(cid:4)(cid:4) ∪ {ra} is consistent and dS (K, K(cid:4)(cid:4)) < dS (K, K(cid:4)).of K by adding ra is optimal iff K(cid:4) ∪ {ra} is consistent and there is no other spatialAs in the case of other revision strategies, there may be multiple optimal spatial revision strategies and we use a total. We now give an example ofordering O T to obtain uniqueness. We write K (cid:3)s ra to denote this optimal spatial revision K(cid:4)spatial change.Example 7. Consider again the revision from Example 6 where the knowledge base KBeijing is being revised by the atom:loc(worker, R4, 15)[0.5, 0.5]. It could be that the data collection procedures determined the regions via some potentiallyerroneous method, and that therefore the inconsistency can be fixed by changing the regions in the knowledge basewith spatial revision. One possible spatial revision of KBeijing replaces the atom loc(worker, R3, 15)[0.5, 0.5] with the atomloc(worker, R3 ∪ {(7, 2)}, 15)[0.5, 0.5]. We call this spatial revision KsBeijing) is one, whichis the minimal possible non-zero value for dS . Therefore, KsBeijing is an optimal spatial revision. In this case, there areno other optimal spatial revisions, however, when there are other optimal spatial revisions, we use O T to choose be-Beijing would have thetween them. For instance, if we used dsame spatial distance from KBeijing as the spatial revision Ks2Beijing, which substitutes loc(worker, R3 ∪ {(8, 2)}, 15)[0.5, 0.5]Beijing and Ks2In this case, both Ksfor loc(worker, R3, 15)[0.5, 0.5].Beijing would be optimal spatial revisions (they both∗have the same distance from KBeijing according to dS ), but only the one deemed minimal according to O T would beKBeijing (cid:3)s loc(worker, R4, 15)[0.5, 0.5]. We would expect a reasonable O Tto prefer knowledge bases with connectedregions to knowledge bases with unconnected regions, meaning that KBeijing (cid:3)s loc(worker, R4, 15)[0.5, 0.5] would beKs∗S from footnote 6 as the spatial distance function, then KsBeijing. We note that dS (KBeijing, Ks∪ {loc(worker, R4, 15)[0.5, 0.5]}.BeijingThe following theorem characterizes the cases where a spatial revision satisfying the AGM Axioms (A1)–(A6) is possible.Theorem 6. Let K be any knowledge base and |S| > 2. An AGM-compliant spatial revision is possible for every atom ra =loc(id, r, t)[(cid:2), u] where r is a strict subset of S iff for all ai = loc(id, ri, t)[(cid:2)i, ui] ∈ K either li = 0 or ui = 1.6 Many other distance functions can also be defined (e.g. we could set the distance to be d∗S (a, a(cid:4)) = |r ∪ r(cid:4)| − |r ∩ r(cid:4)|); however, the results in this sectionhold irrespective of the specific distance function.82J. Grant et al. / Artificial Intelligence 174 (2010) 72–104Next we give a specific example where no spatial revision is possible.the knowledge base KBeijingthe atomExample 8. We revisitloc(worker, R3, 15)[0.5, 0.5]. When given the revision atom loc(worker, {(5, 3)}, 15)[1, 1], which is inconsistent with KBeijing,one might suppose that it is inconsistent with the knowledge base due to some problem with the regions associated withthe atoms, and that simply by fixing those regions, we might regain consistency. However, it is not that easy in this case:the revision atom is inconsistent with loc(worker, R3, 15)[0.5, 0.5], since (5, 3) ∈ R3. The revision atom forces a probabilitymass of 1 for R3 while the knowledge base forces a probability mass of 0.5 for R3. However, even if we changed the regionin the atom loc(worker, R3, 15)[0.5, 0.5] from R3 to R3 \ {(5, 3)} (or in fact, to any r ⊂ S that does not contain (5, 3)), wefind that the revision is still inconsistent with the revision atom. Thus there is no spatial revision in this case.from Example 1. Recallcontainsthat KBeijingThis theorem and the example show that spatial revision is brittle and that, unless the knowledge base satisfies somefairly restrictive requirements, we cannot always revise KBs by using spatial revision alone. In KBs like that from Example 8,one inserted PST atom is capable of causing such a severe conflict between PST atoms in the KB that even drastic changesin every PST atom’s region does not lead to a possible resolution of the inconsistency. We take this result as evidence thatspatial revision should not be relied on by itself as a revision technique for PST knowledge bases.3.6. Minimizing temporal changeIn this section, we study what happens when we revise a PST KB by changing only time stamps. We will consider boththe infinite case where T is the set of all non-negative integers (this is how T was defined) as well as where T = {0, . . . , N}for some positive integer N, making T finite. A temporal revision of PST atom a = loc(id, r, t)[(cid:2), u] is a PST atom of the form(cid:4) = loc(id, r, ta(cid:4))[(cid:2), u]. We define the distance between them as dT (a, a(cid:4)) = |t − t(cid:4)|.A temporal revision of K is a PST KB K(cid:4)containing at most one temporal revision of each atom in K. The distance, (dT (K, K(cid:4))), is the sum of the distances between the individual atoms and their associated temporalbetween K and K(cid:4)revisions.Definition 13. A temporal revision K(cid:4)revision K(cid:4)(cid:4)of K by adding ra such that K(cid:4)(cid:4) ∪ {ra} is consistent and dT (K, K(cid:4)(cid:4)) < dT (K, K(cid:4)).of K by adding ra is optimal iff K(cid:4) ∪ {ra} is consistent and there is no other temporalAs in the case of the previous two revision strategies, there can be multiple optimal temporal revisions — we assumethe existence of a strict total ordering O T to achieve uniqueness. We denote this optimal temporal revision of K by addingra as K ˙+t ra.Example 9. Again, we consider the revision from Example 6 where the knowledge base KBeijing is being revised by theatom: loc(worker, R4, 15)[0.5, 0.5]. In this example, however, we suppose the error creating the inconsistency arises due totemporal inaccuracies in our knowledge base, implying that the inconsistency can be fixed by changing the timestamps inthe knowledge base. The relevant atoms from KBeijing are:(cid:7)(cid:8)loc(worker, R3, 15)[0.5, 0.5], loc(worker, R2, 15)[0.5, 0.5].However, since it takes the worker at least 2 time periods to travel from R 4 to R2 (recall the worker can travel Manhattandistance two each time step), and it only takes the worker 1 time period to travel to R 3 from R4, the revisions chang-ing loc(worker, R3, 15)[0.5, 0.5] to either loc(worker, R3, 14)[0.5, 0.5], or loc(worker, R3, 16)[0.5, 0.5] will both be consistentwith loc(worker, R4, 15)[0.5, 0.5] and will be optimal temporal revisions (we could also change loc(worker, R 2, 15)[0.5, 0.5]to time points 13 or 17 to achieve consistency, but the resulting distance dT would be larger than the above revisionsand therefore not optimal). If O T prefers knowledge bases with higher time points to knowledge bases with lower timepoints, then the optimal temporal revision, KBeijing (cid:3)t loc(worker, R4, 15)[0.5, 0.5] will change loc(worker, R3, 15)[0.5, 0.5] toloc(worker, R3, 16)[0.5, 0.5].Now we show by examples that temporal revisions need not exist when either T is finite (Example 10) or when thereachability definition is not fully connected (Example 11).Example 10. For T = {0, 1}, let(cid:9)(cid:7)(cid:10)K =locid, {p1}, 0[0.6, 0.6], loc(cid:9)id, {p2}, 1(cid:10)(cid:8)[0.6, 0.6]and let the revision atom be ra = loc(id, {p1}, 0)[0.7, 0.7]. All possible temporal revisions of K are inconsistent with ra.Example 11. For infinite T a two point space S = {p1, p2}, and RD where {reachable(p, p) | p ∈ S} = RD,let K ={loc(id, {p1}, 0)[1, 1]} and ra = loc(id, {p2}, 1)[1, 1]. No matter what integer t ∈ T is used for the temporal revision:K(cid:4) = {loc(id, {p1}, t)[1, 1]}, K(cid:4)will still be inconsistent with ra because ra requires that the object always be at p2 while K(cid:4)requires that the object always be at p1.J. Grant et al. / Artificial Intelligence 174 (2010) 72–10483We can guarantee the existence of a temporal revision if we eliminate the causes of these two counterexamples.Proposition 3. If T is infinite and RD is fully connected, then there is an AGM-compliant minimal temporal revision K(cid:4) = K (cid:3)t ra.The basic idea involves changing the time points for all atoms in K such that the difference in time between any twoatoms is sufficient for the object to travel form any point in space to any point in space.When a temporal revision exists, the following result shows that when T is finite deciding if a temporal revision isoptimal is coNP-complete. From a practical point of view, there is no loss of utility in the finiteness assumption as the sizeof T can be an arbitrarily large finite number.Theorem 7. Given a PST atom ra, and PST KBs K and K(cid:4)Further, if T is finite then deciding whether K(cid:4), deciding whether K(cid:4)is a temporally optimal revision of K by ra is coNP-hard.is a temporally optimal revision of K by adding ra is coNP-complete.The proof proceeds by reduction to the MCSS problem (Definition 29 in Appendix A). The following corollary of Theo-rem 7 states that checking whether a PST KB is the optimal temporal revision of a given knowledge base is coNP-completeeven when we take the order O T into account.Corollary 1. Given a PST atom ra, and PST KBs K, K(cid:4)where T is finite, checking whether K(cid:4) = K ˙+t ra is coNP-complete.(cid:4))[(cid:2), u] is a unary temporal revision of loc(id, r, t)[(cid:2), u] iff abs(t − tWe now introduce Algorithm 2 to compute temporal revisions. This algorithm works via unary temporal revisions where(cid:4)) = 1. The algorithm creates a search tree —loc(id, r, teach node N in the search tree has an N.KB field. The root of the search tree is initialized to Root.KB = K. Every child C ofa node N is just like N except that exactly one PST atom in N.KB is replaced by a unary temporal revision. Further, eachchild KB is required to be further (according to dT ) from K than its parent. When visiting a node N, the algorithm checks ifN.KB ∪ {ra} is consistent. By creating and visiting this tree in breadth first order, we are guaranteed that the first node thatsatisfies this consistency check is an optimal temporal revision of K that accomplishes the insertion of ra.Algorithm 2. TemporalRevision(K, ra) Find K (cid:3)t ra.If {a} is inconsistent, return error.Get new node Root. Set Root.KB = K;TODO = [Root]. {TODO is an ordered list.}while True doLet nextTODO be an empty list.{iterate over TODO in order.}for N in TODO doif N.KB ∪ {ra} is consistent return N.KB ∪ {ra}.Insert each child of N into nextTODO.end forLet TODO = nextTODO.sort TODO according to strict total ordering O T .end whileTheorem 8. If there exists a minimal temporal revision for K with respect to ra, then Algorithm 2 is correct, i.e. TemporalRevision(K,ra) returns K (cid:3)t ra. Moreover, TemporalRevision(K, a) is AGM-compliant.The TemporalRevision algorithm takes time exponential in the size of the knowledge base (as expected due to Theo-rem 7).3.7. Minimizing object Id changeIn this section, we introduce a revision operator that changes the object ids of PST atoms. IDs of moving objects can beincorrect for any number of reasons. For example, if the data was inserted manually then an id might be erroneous becauseof a typing error. Alternatively, if the ids were detected using an image processing program which may be used in sometraffic cameras,7 errors might occur because of occlusion when the image is captured, or due to poor lighting conditions,7 Many cities in the US and Europe have traffic cameras to track offenders. Some of these use automated methods to read license plates, while othersjust register an image of the license plate that is then manually inserted into the database by someone who looks at the image.84J. Grant et al. / Artificial Intelligence 174 (2010) 72–104or wind conditions (e.g. leaves blowing across the field of view of the camera), or just error in the image recognitionalgorithms.In order to evaluate the distance between a KB and its revisions, we assume the existence of a metric d O (id1, id2) whosevalue is the cost of changing an object id from id1 to id2. For example, this function could use the edit-distance cost ofchanging the name of the object identified by id1 into the name of the object identified by id2. Edit distance might workwell for identifying typographical errors. Versions of edit distance that take proximity on a typewriter keyboard are alsoavailable.An object id revision of PST atom a = loc(id, r, t)[(cid:2), u] is an atom of the form a(cid:4) = loc(id(cid:4), r, t)[(cid:2), u]. The distance d O (a, a(cid:4))is given by d O (id, id(cid:4)).An object id revision of K is a K(cid:4)containing at most one object id revision of each atom in K. The distance between aPST KB and its object id revision (d O (K, K(cid:4))) is the sum of the distances between the individual atoms and their associatedobject id revisions.Definition 14. An object id revision K(cid:4)id revision K(cid:4)(cid:4)of K by adding ra such that K(cid:4)(cid:4) ∪ {ra} is consistent and d O (K, K(cid:4)(cid:4)) < d O (K, K(cid:4)).of K by adding ra is optimal iff K(cid:4) ∪ {ra} is consistent and there is no other objectAs in the case of the previous revision strategies, there can be multiple optimal revisions — we assume the existence ofa strict total ordering O T to obtain uniqueness. We denote this optimal object id revision of K by adding ra as K (cid:3)O ra. Wenow give an example of object ID change.Example 12. Again we use the knowledge base KBeijing from Example 1 and the revision atom specifying the worker is inthe park with 50% probability at time 15: loc(worker, R4, 15)[0.5, 0.5]. Recall that the revision is inconsistent with KBeijingdue to the following atoms:loc(worker, R3, 15)[0.5, 0.5], loc(worker, R2, 15)[0.5, 0.5],which together specify that the worker could not be in R4 at time 15 with any probability. Either of those atoms could bemistaken — maybe it is the worker’s brother who is seen in R3 at time 15, and due to familial resemblance is mistaken forthe worker, or maybe it is a different worker that shows up to work in R 2. This suggests two possible object id revisions:• K1B• K2B= KBeijing \ {loc(worker, R3, 15)[0.5, 0.5]} ∪ {loc(brother, R3, 15)[0.5, 0.5]},= KBeijing \ {loc(worker, R2, 15)[0.5, 0.5]} ∪ {loc(worker2, R2, 15)[0.5, 0.5]}.We will assume these two of the many possible revisions to have the same (optimal) distance according to d O , i.e.d O (KBeijing, K1B ) and therefore that O T will be needed to decide which is KBeijing (cid:3)O loc(worker, R4,15)[0.5, 0.5].B ) = d O (KBeijing, K2However, it turns out that object ID change is again not always possible. The next example shows that if ID is finite anddetermined a priori, there need not always be an object id revision.Example 13. Let ID = {id1, . . . , idn} and r (cid:2) S. Let K = {a1, . . . , an} where ai = loc(idi, r, 0)[ 1i , 1loc(id1, r, 0)[0, 0]. No object id revision of K is consistent with ra, so Axiom (A5) is not satisfied.i] for 1 (cid:2) i (cid:2) n. Let ra =Even so, when there is an object ID change, it is hard to find. The following theorem states that checking for optimalobject id revisions of a given knowledge base is coNP-complete.Theorem 9. Given a PST atom ra, and PST KBs K, K(cid:4)coNP-complete.where T is finite, deciding whether K(cid:4)is an optimal object id revision of K isAs with other coNP-complete proofs in this paper, the MCSS problem (Definition 29 in Appendix A) is used in thereduction. The full proof is given in Appendix B. A corollary states that checking whether a PST KB is the optimal object idrevision of a given knowledge base is also coNP-complete (here the order O T is considered).Corollary 2. Given PST atom ra, and PST KBs K, K(cid:4)where T is finite, deciding whether K(cid:4) = K ˙+o ra is coNP-complete.3.8. Minimizing probability changeIn this section, we propose a belief revision operator that replaces PST atoms of the form loc(id, r, t)[(cid:2), u] in K by PST(cid:4)]. In other words, these belief revision operators expand the probability boundsatoms loc(id, r, t)[(cid:2)(cid:4), u(cid:4)] where [(cid:2), u] ⊆ [(cid:2)(cid:4), uof PST atoms in K in order to retain consistency when ra is added.First we examine changing only the lower or upper bound (i.e. changing (cid:2) to (cid:2)(cid:4)or u to u(cid:4)the possibility of changing both. In all cases we want to minimize the expansion of the probability interval [(cid:2), u] to [(cid:2)(cid:4), urespectively), then we consider(cid:4)].J. Grant et al. / Artificial Intelligence 174 (2010) 72–104853.8.1. Minimizing lower/upper bound changeOne may wish to modify a PST KB by changing only the lower (resp. upper) bounds of the PST atoms. We show herehow to do this for lower bounds. Doing upper bound change is analogous.Definition 15. Suppose a = loc(id, r, t)[(cid:2), u] is a PST atom and (cid:2)(cid:4) (cid:2) (cid:2). Then the PST atom alower bound revision of a. The distance, d(cid:2)(a, ais defined as ((cid:2) − (cid:2)(cid:4)).(cid:4)) between a and a(cid:4)(cid:4) = loc(id, r, t)[(cid:2)(cid:4), u] is called aA lower bound revision of K is a K(cid:4)containing at most one lower bound revision of each atom in K. The distance, (d(cid:2)(K, K(cid:4))), is the sum of the distances between the individual atoms and their associated lower boundbetween K and K(cid:4)revision.Definition 16. A lower bound revision K(cid:4)bound revision K(cid:4)(cid:4)of K by adding ra such that K(cid:4)(cid:4) ∪ {ra} is consistent and d(cid:2)(K, K(cid:4)(cid:4)) < d(cid:2)(K, K(cid:4)).of K by adding ra is optimal iff K(cid:4) ∪ {ra} is consistent and there is no other lowerAs in the case of the previous revision strategies, there can be multiple optimal lower bound revisions and we assumethe existence of a strict total ordering O T to obtain uniqueness. We denote this minimal optimal lower bound revision ofK by adding ra as K (cid:3)(cid:2) ra.The following theorem characterizes the cases where a lower bound revision is possible.Theorem 10. Let K be any knowledge base. Lower bound revision of K for any atom ra is AGM-compliant iff for all ai ∈ K, ui = 1.The following is a particular example where no lower bound revision exists.Example 14. For KBeijing from Example 1 let ra = loc(worker, (7, 6), 15)[1, 1]. There is no lower bound revision of KBeijingconsistent with ra.It is therefore impossible to guarantee the existence of an AGM-compliant revision when using lower bound revision. Ananalogous result holds for upper bound revision.3.8.2. Minimizing probability interval changeIn this subsection we examine changing both the lower and the upper bounds of the probability intervals in PST atoms.We will see that unlike attempts to change either of the bounds individually, revision strategies changing both boundscan be guaranteed to exist. Further, we will present a polynomial time algorithm for making AGM-compliant revisions bychanging the probability intervals.Our definition of probability interval revision combines both lower bound and upper bound revisions.(cid:4)Definition 17. Suppose a = loc(id, r, t)[(cid:2), u] is a PST atom, u (cid:2) u(cid:4)) between a and aprobabilistic revision of a. The distance, d P (a, a, and (cid:2)(cid:4) (cid:2) (cid:2). The PST atom ais defined as ((cid:2) − (cid:2)(cid:4)) + (u(cid:4)(cid:4) = loc(id, r, t)[(cid:2)(cid:4), u(cid:4) − u).(cid:4)] is called aA probabilistic revision of K is a K(cid:4)containing at most one probabilistic revision of each atom in K. The distance, (d P (K, K(cid:4))), is the sum of the distances between the individual atoms and their associated probabilisticbetween K and K(cid:4)revision.Definition 18. A probabilistic revision K(cid:4)probabilistic revision K(cid:4)(cid:4)of K by adding ra such that K(cid:4)(cid:4) ∪ {ra} is consistent and d P (K, K(cid:4)(cid:4)) < d P (K, K(cid:4)).of K by adding ra is optimal iff K(cid:4) ∪ {ra} is consistent and there is no otherAs in the case of the previous revision strategies, there can be multiple optimal probabilistic revisions and we assumethe existence of a strict total ordering O T to get uniqueness. We denote this optimal probabilistic revision of K with respectto atom ra as K (cid:3)p ra. We now give an example of probabilistic revision.Example 15. Consider again KBeijing from Example 1 and a revision atom specifying the worker in the park with 50%probability at time 15: loc(worker, R4, 15)[0.5, 0.5]. This revision atom is inconsistent with KBeijing due to the subset:(cid:7)(cid:8)loc(worker, R3, 15)[0.5, 0.5], loc(worker, R2, 15)[0.5, 0.5].The probability intervals for either of those atoms could be wrong, and in probabilistic revision, we modify those bounds tocreate consistency. This suggests three of many possible probability interval revisions:• Suppose that loc(worker, R3, 15)[0.5, 0.5] was mistaken:K1B= KBeijing \ {loc(worker, R3, 15)[0.5, 0.5]} ∪ {loc(worker, R3, 15)[0, 0.5]}.86J. Grant et al. / Artificial Intelligence 174 (2010) 72–104• Suppose that loc(worker, R2, 15)[0.5, 0.5] was mistaken:K2B= KBeijing \ {loc(worker, R2, 15)[0.5, 0.5]} ∪ {loc(worker, R2, 15)[0, 0.5]}.• Suppose both loc(worker, R3, 15)[0.5, 0.5] and loc(worker, R2, 15)[0.5, 0.5] were partially mistaken:= KBeijing \ {loc(worker, R3, 15)[0.5, 0.5], loc(worker, R2, 15)[0.5, 0.5]} ∪ {loc(worker, R3, 15)[0.25, 0.5], loc(worker, R2,K3B15)[0.25, 0.5]}.(of course, any change to the lower bounds so that the lower bounds of all three atoms adds to 1 would work). Note thatall mentioned revisions have a distance of 0.5 from KBeijing (i.e. d P (KBeijing, K1B )). ThusO T will be needed to distinguish between them. If we suppose that O T prefers not to change atoms associated with R2,then KBeijing (cid:3)P loc(worker, R4, 15)[0.5, 0.5] will be K1B∪ {loc(worker, R4, 15)[0.5, 0.5]}.B ) = d P (KBeijing, K3B ) = d P (KBeijing, K2We can find an optimal probabilistic revision by setting up a linear program similar to LP(K) (Definition 8). We again usethe variables v id,t,p,q, each representing the probability of an object id being at location p at time t and at location q at timet + 1. We limit the range of id to those objects mentioned in the database and the range of t to the bounded set T provideda priori (we assume a bounded set of time points T for probabilistic revision). For each PST atom ai = loc(idi, ri, ti)[(cid:2)i, ui] inK, we also include variables lowi and upi representing the atoms’ modified lower and upper bounds.Definition 19 (Probability Revision Linear Program (PRLP)). Let PRLP(K, ra) contain the following constraints:(cid:2)(cid:2)1. For each ai = loc(idi, ri, ti)[(cid:2)i, ui] ∈ K:(cid:2)q∈S v idi ,ti ,p,q) − lowi .(cid:2)q∈S v idi ,ti ,p,q) − upi .(a) 0 (cid:2) ((b) 0 (cid:4) ((c) (cid:2)i (cid:4) lowi , lowi (cid:4) 0, ui (cid:2) upi , and upi(cid:2)(cid:4))[(cid:2), u]:p∈rip∈ri(cid:2)(cid:4)2. For ra = loc(id, r(cid:2)p∈r(cid:4)(a) (cid:2) (cid:2),t(cid:4),p,q and u (cid:4)(cid:4), tq∈S v id(cid:4)(cid:2) 1.(cid:2)(cid:2)3. For each id in K and each t in T :(a) For all p, q ∈ S, v id,t,p,q (cid:4) 0.(b)(c) For all p, q ∈ S, if reachableid(p, q) /∈ RD: v id,t,p,q = 0.(d) For all p ∈ S:q∈S v id,t,q,p =q∈S v id,t,p,q = 1.q∈S v id,t+1,p,q.p∈S(cid:2)(cid:2)(cid:2)p∈r(cid:4)q∈S v id(cid:4),t(cid:4),p,q.We now compute an optimal revision of K by minimizing the distance function subject to PRLP(K, ra). As in the caseof all our revision strategies, when there are multiple solutions to this linear program, we assume there is a mechanism todeterministically pick one. We are now able to define a probabilistic revision strategy.Definition 20 (Probabilistic Revision). Suppose K is a PST KB and ra a PST atom. Let θ be a (deterministically) selectedsolution of the linear program(cid:3)(cid:9)((cid:2)i − lowi) + (upi(cid:10)− ui)subject to PRLP(K, ra).minimizeai ∈KReturn the PST KB defined as(cid:7)loc(idi, ri, ti)[lowiθ, upiθ] | loc(idi, ri, ti)[(cid:2)i, ui] ∈ K(cid:8)∪ {ra}.The size of PRLP(K) has the same big-O bound as LP(K): O ((|K| · |S|2 · nt)2) (the only difference is the addition of2 · |K| extra variables for the lowi and upi ). Since solving linear programs is also polynomial [15], and we can assume ourmechanism for picking a solution deterministically runs in polynomial time8; hence the above procedure computes K (cid:3)p rain polynomial time.This polynomial time probabilistic revision strategy is also AGM-compliant.Proposition 4. K (cid:3)p ra satisfies (A1)–(A6).4. Hybrid belief revision strategyThe previous section dealt with the revision of a PST KB by deleting atoms or modifying a single component of atoms.Here we consider combinations of these strategies that we call hybrid belief revision strategies. In the first subsection weallow only modifications of atoms; the second subsection allows deletions of atoms as well.8 Such mechanisms exist: consider a strict total ordering over the variables which specifies the order with which the linear program solver shouldminimize variables.4.1. Minimizing weighted hybrid changeJ. Grant et al. / Artificial Intelligence 174 (2010) 72–10487In this subsection, we consider a technique which allows all parts of an atom to be revised. A hybrid revision of a PSTis a weighted sum of the(cid:4)]. The distance between a and a(cid:4)(cid:4) = loc(id(cid:4))[(cid:2)(cid:4), u(cid:4), t, r(cid:4)atom a = loc(id, r, t)[(cid:2), u] is a PST atom adistances already defined:(cid:4)(cid:4)dH (a, a) = w O · d O (a, a) + w S · dS (a, a(cid:4)) + w T · dT (a, a(cid:4)) + w P · d P (a, a(cid:4)).Here d O , dS , dT , d P are the distance functions between atoms defined in the last section that quantify distances betweenobjects, regions, time points, and probability intervals respectively. Likewise, w O , w S , w T , and w P are weights, specifyingthe relative importance of the associated type of change. The weighted hybrid distance function uses the distances betweentwo atoms along each of these four parameters to compute a distance between them.The weights are non-zero, non-negative, and allow a special value ∞. Assigning a weight ∞ to any w is equivalentto forcing no change of the appropriate type because any such change would make the distance between two PST atomsinfinite. (We assume 0 × ∞ = 0, to allow other types of changes.)(cid:4))[(cid:2)(cid:4), uDefinition 21. Any PST atom a(cid:4)a = loc(id, r, t)[(cid:2), u]. The distance between a and a(cid:4)(cid:4) = loc(id(cid:4), t, r(cid:4)] can be considered to be a weighted hybrid revision of any PST atomis defined to be dH (a, a(cid:4)).For K and K(cid:4), K(cid:4)is a weighted hybrid revision of K iff there is a bijection β from K to K(cid:4)such that for all a ∈ K, β(a)is defined to be the minimum distance of all theis a hybrid revision of a. The hybrid revision distance between K and K(cid:4)bijections between them or(cid:10)(cid:9)K, K(cid:4)dH= minβ: K↔K(cid:4)(cid:11) (cid:3)(cid:9)(cid:10)a, β(a)dH(cid:12).a∈KWe say that K(cid:4)is an optimal weighted hybrid revision of K by adding ra iff K(cid:4) ∪ {ra} is consistent and there is no K(cid:4)(cid:4)such that K(cid:4)(cid:4) ∪ {ra} is consistent and dH (K, K(cid:4)) > dH (K, K(cid:4)(cid:4)).Again there can be multiple optimal weighted hybrid revisions for a given KB and revision atom. We use the strict totalthat is minimal according to O T is the weightedis the O T -minimal optimal weightedordering O T to obtain uniqueness. The optimal weighted hybrid revision K(cid:4)hybrid revision returned by the (cid:3)h operator. That is, K (cid:3)h ra = K(cid:4) ∪ {ra} where K(cid:4)hybrid revision. We now give an example of hybrid revision relating to the knowledge base from Example 1.Example 16. Consider revising KBeijing from Example 1 with the revision atom loc(worker, R4, 15)[0.6, 0.6]. This revisionatom is inconsistent with KBeijing due to the subset: {loc(worker, R3, 15)[0.5, 0.5], loc(worker, R2, 15)[0.5, 0.5]}. In hybridrevision, we are able to change the objects, regions, time points, and probabilities. We now list several possible weightedhybrid revisions.loc(worker, R3, 15)[0.5, 0.5]is off: K1B= KBeijing \ {loc(worker, R3, 15)[0.5, 0.5]} ∪• Ifthe time and identity of{loc(brother, R3, 16)[0.5, 0.5]}.K2B15)[0.2, 1]}.• If the probabilities for both loc(worker, R3, 15)[0.5, 0.5] and loc(worker, R2, 15)[0.5, 0.5] were partially mistaken:= KBeijing \ {loc(worker, R3, 15)[0.5, 0.5], loc(worker, R2, 15)[0.5, 0.5]} ∪ {loc(worker, R3, 15)[0.2, 0.5], loc(worker, R2,• If the region and probabilities of loc(worker, R3, 15)[0.5, 0.5] are wrong: K3B= KBeijing \ {loc(worker, R3, 15)[0.5, 0.5]} ∪{loc(worker, R3 ∪ {(7, 2)}, 15)[0.5, 0.6]}.Note that all of these are valid revisions as they are all consistent with loc(worker, R 4, 15)[0.6, 0.6]. Depending on theweights in dH , any one of these could be an optimal hybrid revision. If we suppose w O = w T = 10, w S = 0.1 and w P = 1,then K3B ) = 0.2). In this casethere are no other weighted hybrid revisions with distance of 0.2 or less from K, so K (cid:3)h loc(worker, R4, 15)[0.5, 0.5] = K3B .B will be an optimal hybrid revision (since dH (K, K1B ) = 0.9, and dH (K, K3B ) > 10, dH (K, K2Weighted hybrid revision subsumes object, spatial, temporal or probabilistic revision: in fact, to obtain any combination,a user need only set all weights not associated with that type of revision in dH to ∞. Therefore, as a corollary to the factthat spatial revision is not possible in the general case (Section 3.5), we can state the following result.Proposition 5. Weighted hybrid revision cannot be guaranteed to satisfy all our AGM-style axioms.The following result derives the computational complexity of checking whether a given knowledge-base K(cid:4)weighted hybrid revision of K.is an optimalTheorem 11. Given a PST atom ra, and PST KBs K, K(cid:4)where T is finite, deciding whether K(cid:4) ∪ {ra} = K ˙+h ra is coNP-complete.88J. Grant et al. / Artificial Intelligence 174 (2010) 72–104The reduction uses object change (though could use any of the coNP-hard types of change introduced in this paper).Next we show how to accomplish hybrid revision by an appropriate mixed integer linear program (MILP) in a provablycorrect way. In order to achieve this, we extend and modify the definition of PRLP (Definition 19) by adding spatial, temporal,and object id integer valued variables that will co-exist with the real valued variables in the definition of PRLP as follows.For each ai = loc(idi, ri, ti)[(cid:2)i, ui] ∈ K, let region(ai) be a set of regions that may replace ri . In general, region(ai) consistsof all possible regions belonging to S but one could consider an appropriate subset (we assume that ri ∈ region(ai)). Foreach region r j ∈ region(ai), we use an integer valued variable ˆrij which is intended to be set to 1 if region r j is the revisedregion for ai and 0 otherwise. We thus limit the values of all ˆri= 1. This constraintj to {0, 1} and add the constraintindicates that exactly one such region can have a value set to 1. Temporal variables ˆtiin a similar way.j and object id variablesij are addedˆidˆrij(cid:2)As in PRLP, we have the real-valued variables lowi and upi limited to the [0, 1] interval representing the revised lowerand upper bounds for atom ai . We continue the use of v id,t,p,q to represent the probability of object id being at location pat time t and at location q at time t + 1.jWe now formally introduce the following set of integer linear constraints.Definition 22 (Hybrid Revision Linear Program (HRLP)). For knowledge base K = {ai = loc(idi, ri, ti)[(cid:2)i, ui]}, and revision atomra = loc(idr, rr, tr)[(cid:2)r, ur], let HRLP(K, ra) be the following set of constraints:(cid:2)(cid:2)p∈rr(1) (cid:2)r (cid:2)(2) ∀ai = loc(idi, ri, ti)[(cid:2), u] ∈ K, ∀id j ∈ ID, ∀tk ∈ T , and ∀rm ∈ regions(ai),(cid:10)q∈S v idr ,tr ,p,q (cid:2) ur (enforce proper revision).(cid:3)(cid:3)(cid:9)(cid:9)(cid:10)(cid:10)(cid:9)lowi −1 − ˆidij−1 − ˆtik−1 − ˆrim(cid:2)p∈rmq∈Sv id j ,tk,p,q (cid:2) upi(cid:9)+1 − ˆidij(cid:9)(cid:10)+1 − ˆtik(cid:10)(cid:9)+1 − ˆrim(cid:10).(cid:2)(cid:2)(cid:2)ij= 1,id j ∈IDˆ(3) For all ai ∈ K:id(4) For all ai = loc(idi, ri, ti)[(cid:2)i, ui] ∈ K: lowi (cid:2) (cid:2)i , upi(5) For all id ∈ ID, t, t + 1 ∈ T , and p ∈ S:q∈S v id,t+1,p,q.(6) For all id ∈ ID, t ∈ T , and p, q ∈ S: v id,t,p,q = 0 if reachableid(p, q) /∈ RD.(cid:2)(7) For all id ∈ ID, and t ∈ T :r j ∈regions(ai )(cid:4) ui .(cid:2)q∈S v id,t,q,p =ˆtij(cid:2)= 1.= 1,q∈S v id,t,p,q = 1.t j ∈Tp∈Sˆrij(cid:2)Given a solution to HRLP(K, ra), we can construct a bijection β such that β(K) is a hybrid revision of K by adding ra asfollows. Let θ be a solution to HRLP(K, ra). Define(cid:7)βθ (K) =loc(id j, rm, tk)[lowiθ, upiθ] | ai ∈ K ∧ ˆidijθ = 1 ∧ ˆrimθ = 1 ∧ ˆtikθ = 1(cid:8).Note that becauseˆidij , ˆrim, and ˆtik are all either zero or one, constraint (3) of HRLP ensures that βθ (K) is well-defined.We now show that the problem of finding an optimal weighted hybrid revision corresponds to solving a mixed integerlinear program that has HRLP(K, ra) as its set of constraints.Theorem 12. Let K = {ai | ai = loc(idi, ri, ti)[(cid:2)i, ui]}, and ra = loc(idr, rr, tr)[(cid:2)r, ur], the revision atom. θ is an optimal solution ofthe optimization problemminimize the objective function(cid:3)(cid:11) (cid:3)(cid:12)(cid:11) (cid:3)(cid:3)ˆidij· d O (idi, id j)+ w S(cid:12)(cid:12)ˆrij· dS (ri, r j)(cid:12)r j ∈regions(ai )ˆtij· dT (ti, t j)+ w P((cid:2)i − lowi) + (upi− ui)ai ∈K(cid:11) (cid:3)ai ∈Kw Oai ∈Kid j ∈ID(cid:11) (cid:3)(cid:3)+ w Tai ∈Kt j ∈Tsubject toHRLP(K, ra)iff βθ (K) is an optimal hybrid revision of K by adding ra.S |)The number of constraints in HRLP(K, ra) is equal to the number of constraints in PRLP(K, ra) plus O (|K| · |ID| · |T | · |2new constraints due to items (2) and (3) in Definition 22. As the number of constraints in PRLP(K, ra) is O (|K| · |T | · |S|2),S |). Since |S| is constant, this gives an upper boundthe total number of constraints in HRLP(K, ra) is O (|K| · |ID| · |T | · |2of O (|K| · |T | · |ID|) constraints for HRLP(K, ra). It is worth noting that, although in the worst case the number of possibleS |, this number could be appropriately boundedways to replace each region ri of atom ai ∈ K is bounded by the constant |2J. Grant et al. / Artificial Intelligence 174 (2010) 72–10489by a smaller constant in specific real-life applications by, for instance, only allowing changes to connected subsets of S.The number of variables in HRLP(K, ra) is equal to the number of variables in PRLP(K, ra) (that is, O (|K| · |T | · |S|2)) plusS | · |K|) new variables due to items (2) and (3) in Definition 22. As |S| is constant, this givesO (|ID| · |K| + |T | · |K| + |2an upper bound of O (|K| · (|ID| + |T |)) variables for HRLP(K, ra). The size of HRLP(K, ra) is O (|K|2 · |ID|2 · |T |2) (numberof variables times number of constraints). Thus the size of HRLP(K, ra) is equivalent to the size of PRLP(K, ra) times |ID|2.However, HRLP(K, ra) is a set of linear constraints over integer as well as real variables and therefore all known solutionprocedures run in exponential time, making it substantially more expensive to solve than an equivalently sized PRLP(K, ra),which has only real variables and is therefore solvable in polynomial time.4.2. Prob-MAXCARD (PMC) hybrid revisionIn the previous section, we considered weighted hybrid revision which uses a linear combination of distances along eachof four dimensions (object change, spatial change, temporal change, and probability interval change) to define an optimalrevision. However, the max-subset and max-cardinality revision mechanisms are not considered there.In this section we address a hybrid belief revision strategy that combines maximal cardinality subset and probabilityrevision. According to this revision strategy, an atom may be either deleted from the knowledge base or have its probabilityinterval changed. We call this Prob-MAXCARD (PMC) revision.We will define a mixed integer linear program problem for knowledge base K and revision atom ra. Before doing this,we first need to introduce a set of mixed integer linear constraints.Definition 23 (Max-Card and Probability Revision Program). Let MCPRP(K, ra) be equal to PRLP(K, ra) except that inequali-ties 1(a) and 1(b) are replaced by the following:1. For each ai = loc(idi, ri, ti)[(cid:2)i, ui] ∈ K:(cid:2)q∈S v idi ,ti ,p,q).+ δi .q∈S v idi ,ti ,p,q) (cid:2) upi(a) lowi − δi (cid:2) ((b) (p∈ri(c) δi ∈ {0, 1}.p∈ri(cid:2)(cid:2)(cid:2)Observe that, in MCPRP(K, ra), for each ai ∈ K, if δi = 0 (1)(a) is equivalent to that of PRLP(K, ra). Otherwise, δi = 1 andequation (1)(a) is trivially satisfied by any solution of MCPRP(K, ra), as if ai did not belong to K.Before formally definition PMC revision, we assume the existence of two vectors wm and w p of weights. The i’th compo-pi ,, indicates the importance of retaining ai in K, while the i’th component of w p , namely wnent of vector wm, namely wmiindicates the cost of modifying the probability interval of ai .Definition 24 (PROB-MAXCARD (PMC) Revision). Suppose K is a PST KB and ra is a PST atom. Let θ be a solution of the linearprogramminimize(cid:3)ai ∈Kwmi· δi +(cid:9)wpi·(cid:3)ai ∈K((cid:2)i − lowi) + (upi(cid:10)− ui)subject to MCPRP(K, ra),where wm and w p are vectors of weights, each of them having |K| strictly positive elements. Return the PST KB(cid:7)loc(idi, ri, ti)[lowiθ, upiθ] | loc(idi, ri, ti)[(cid:2)i, ui] ∈ K ∧ δiθ = 0∪ {ra}.(cid:8)It is worth noting that, for each solution θ of the above mixed integer linear program and for each atom ai ∈ K, eitherδiθ = 0 or lowiθ = (cid:2)i and upiθ = ui .The vectors of weight wm and w p can be used to specify, for each atom, if either maximal-cardinality revision orprobability revision is preferred. We can use these vectors to say that for a given subset of atoms of K we trust theprobability values but a maximal-cardinality revision for this portion of the knowledge base is allowed. The uniqueness ofthe solution can be obtained as before by using the total ordering O T .5. Improvements and approximations of probabilistic revisionThe decision problems associated with all revision strategies proposed thus far are intractable with the exception of theprobabilistic revision proposed in Definition 20. As this is the only AGM-compliant revision strategy for PST KBs that hasany chance of being practically useful, this section focuses on methods to make it more efficient.5.1. Reducing the size of the linear program PRLPProbabilistic revision is computed by solving a linear program associated with the set of constraints PRLP(K, ra). It iswell known that smaller linear programs are usually (but not always) more efficiently solvable than larger ones. In this90J. Grant et al. / Artificial Intelligence 174 (2010) 72–104subsection we eliminate both constraints and variables to generate a smaller linear program PRLPT by using the intuitionthat only time points explicitly mentioned in the knowledge base K need to be considered when constructing PRLP(K, ra).However, we need to be careful to make sure that the reachability constraints are still satisfied.Let T K be the set {t | loc(−, −, t)[(cid:2), u] ∈ K} of time points explicitly mentioned in K. T K is at most the size of T , andoften smaller due to the fact that there is not always information for every possible time point.There are several places in the definition of PRLP(K, ra) where the set T of time points explicitly causes the incorporationof variables and constraints. Fortunately, we can simplify parts 3(c) and 3(d) of Definition 19 as follows.1. We change the reachability constraints defined in the original PRLP as:∀p, q ∈ S, t ∈ T , id ∈ ID if reachableid(p, q) /∈ RD: v id,t,p,q = 0.When T K = {t0, . . . , tn} with t j < t j+1, we are concerned with the object’s ability to move from p to q in t j+1 − t j timepoints. An object can reach q from p in k time points if there is a path from p to q: p1, . . . , pk where p1 = p, pk = q,and for each pi, pi+1, the object can reach pi+1 from pi (reachableid(pi, pi+1)). We say reachableid(p, q, t) iff such a pathof length t exists. We write RDT for the set of all reachableid(p, q, t) that can be generated from RD. Now, when usingT K, we can replace the reachability constraints of the form given above with the simpler set of constraints∀p, q ∈ S, ti ∈ T K, id ∈ ID if reachableid(p, q, ti+1 − ti) /∈ RDT: v id,ti ,p,q = 0.2. The second change involves the constraints ensuring that the probability of entering point p equals the probability ofexiting point p(cid:3)v id,t,q,p =q∈S(cid:3)q∈Sv id,t+1,p,q.If t + 1 /∈ T K then we can replace such constraints in PRLP with constraints:(cid:3)(cid:3)v id,ti ,q,p =v id,ti+1,p,q.q∈Sq∈SFormally, this results in the following set of linear constraints.Definition 25 (PRLPT ). The set of linear constraints PRLPT (K, ra) contains all constraints from PRLP(K, ra) (generated withT = T K) except that constraints of the form• ∀p, q ∈ S, t ∈ T , id ∈ ID if reachableid(p, q) /∈ RD: v id,t,p,q = 0,•(cid:2)(cid:2)q∈S v id,t,q,p =q∈S v id,t+1,p,qare replaced by• ∀p, q ∈ S, ti ∈ T , id ∈ ID if reachableid(p, q, ti+1 − ti) /∈ RDT: v id,ti ,p,q = 0,•(cid:2)(cid:2)q∈S v id,ti ,q,p =q∈S v id,ti+1,p,q.The following theorem says that probabilistic revisions can be correctly computed from this reduced linear pro-gram PRLPT .Theorem 13. (See Theorem 5 from [22].) For any given K and ra, there is a solution to PRLPT (K, ra) iff there is a solutionto PRLP(K, ra).5.2. Approximate probabilistic revision via space partitioningWhile polynomial, the running time of the linear programming-based probabilistic revision algorithm can be quite large.With the optimizations mentioned above, there are at most |S|2 · |T K| variables (where |T K| will be bounded by the minof |K| and |T |) and at most |S| · |T K| + |K| constraints. The size of the linear program that must then be solved is thereforeO ((|S| · |T K| + |K|) · (|S|2 · |T K|)) — each constraint contains at most one entry per variable. Linear programming is aworst-case cubic operation, putting the entire process in:(cid:9)(cid:9)O(|S| · |T K| + |K|) ·(cid:9)|S|2 · |T K|(cid:10)(cid:10)(cid:10)3(cid:9)|S|9 · |T K|6 + |S|6 · |T K|3 · |K|3(cid:10).= OThe term with the largest exponent is |S|, which suggests that focusing on decreasing the size of S will most drasticallyimprove the running time of probabilistic revision.Our strategy here will be to reduce the size of S by partitioning it into related sets of points based on the PST atoms inthe KB.J. Grant et al. / Artificial Intelligence 174 (2010) 72–10491Fig. 3. An example partitioning according to point equivalence. Each dot is a point, each solid box on the left is a PST atom’s region, and each dotted boxis a partition (with the upper right and lower left dots being part of the same partition). On the right the partitions are displayed without the PST atomregions.5.2.1. Definition of partitionWe first define a concept of equivalence that leads to the partitioning. Given a PST KB K, we use the notation Kid,t todenote the set of all PST atoms of the form loc(id, −, t)[−, −] in K.Definition 26 (Point-Equivalence). Suppose K is a PST KB, ra = loc(id, r, t)[(cid:2), u] a revision atom, t a time point, and p1, p2(cid:4)] ∈ Kid,t ,are two points in S. We say that p1 and p2 are t-equivalent, denoted p1 ∼t p2, if and only if for all loc(id, r, t)[(cid:2)(cid:4), up1 ∈ r ⇔ p2 ∈ r.Intuitively, when two points p1, p2 are t-equivalent, the variables associated with points p1, p2 in the linear programPRLP(K, ra) occur in exactly the same constraints.Example 17. Fig. 3 shows a partitioning of space where each dot is a point in space and each solid box is a PST atom’sregion. The dotted regions represent the partitions. The knowledge base being used is(cid:7)(cid:8)loc(id, A, 0)[(cid:2)1, u1], loc(id, B, 0)[(cid:2)2, u2].It is easy to see that ∼t is an equivalence relation and induces a set of equivalence classes. Let P t be the set of suchequivalence classes for a given time point t. Note that |P t| (cid:2) |S|. Our intuition is that the variables in PRLP(K, ra) associatedwith all points occurring in a given equivalence class can be collapsed into a single variable (representing the sum of thevariables being collapsed).5.3. Reachability between partitionsSuppose we have partitioned S for each time point t1, . . . , tn ∈ T K, obtaining Pt1 , . . . , Ptn . We create two new versions(cid:4) ∈ Pti+1 : cautious reachabilityof the reachable predicate to address an object’s potential to move from partition P ∈ P ti to Pand optimistic reachability.Definition 27. For times t and t(cid:4), partition P ∈ P t and partition P(cid:4) ∈ P t(cid:4),• Cautious Partition Reachability:We say reachable• Optimistic Partition Reachability:∀id(P , P∃id(P , P(cid:4), t(cid:4) − t) iff for all p ∈ P and q ∈ P(cid:4), reachableid(p, q, t(cid:4) − t).We say reachable(cid:4), t(cid:4) − t) iff there exists p ∈ P and q ∈ P(cid:4), such that reachableid(p, q, t(cid:4) − t).Intuitively, cautious reachability requires that all points in P(cid:4)frame. Optimistic reachability, on the other hand, only requires that some point in Pwithin a given time period.be reachable from all points in P within a given timebe reachable from some point in P(cid:4)Example 18. With a reachability predicate that returns true if the two points are at most Manhattan distance 2 apart, inFig. 3 the cautious reachability predicate is never true, while the optimistic reachability predicate is always true. Fig. 4shows another partitioning where the cautious reachability predicate is sometimes true (shown with arrows in the figure).Notice how the square center partition p9 is not reachable via the cautious reachability predicate in Fig. 4: this is due tothe fact that every other partition contains at least one point more than distance 2 from at least one of the points in thesquare center partition (i.e. the lower right point of p9 does not reach the point in p1, the lower right point in p9 does notreach the upper point in p2, and so forth).5.4. Partition granularityThe partitions and reachability conditions create a new space where partitions function as points, and objects can movebetween partitions just as they had previously moved between points. Under cautious partition reachability, however, the92J. Grant et al. / Artificial Intelligence 174 (2010) 72–104Fig. 4. This is a granularized version of the partitions in Fig. 3. With a reachability predicate that returns true for points Manhattan distance at most two,the arrows represent cautious reachability.analogy is incomplete. Cautious reachability is so cautious that in many cases, there will be partitions that cannot be(cid:4) ∈ Pti−1 can reach Preached or cannot reach anywhere else. For instance, it may be that for all partitions P ∈ P ti , no Punder cautious partition reachability.In a process called “granularizing”, we split partitions in each P ti until each partition can reach and be reached by atleast one other partition under cautious partition reachability. The following example illustrates granularization.Example 19. Fig. 4 shows a granularization of the partitioning in Fig. 3. Also displayed in Fig. 4 are arrows representing cau-tious partition reachability when the original reachability predicate allows the object to move at most Manhattan distancetwo. Notice that before granularization, there was no cautious partition reachability, while after granularization, we have amuch more connected (though still not fully connected) graph.Algorithm 3 accomplishes this granularization by iteratively dividing the partitions at time points t0 and t1 until everypartition at time point t0 can cautiously reach a partition at time point t1 and every partition at time point t1 is cautiouslyreachable from a partition at time point t0.Algorithm 3. Granularize(Pt0 , Pt1 ): For time points t0 and t1, take partitions Pt0 and Pt1 and return (Pt0every member of Pt0be reached by some member of Pt0(cid:7) under cautious partition reachability and every member of P t1(cid:7) can reach some member of Pt1(cid:7) under cautious partition reachability.(cid:7) , Pt1(cid:7) ) where(cid:7) can(cid:7) = Pt0 and Pt11: Let Pt0(cid:7) = Pt1 .2: Mark every partition in Pt0 and Pt1 as “not done”.3: while Any partition in Pt0 or Pt1 is marked “not done” do(cid:7) do4:(cid:4) ∈ Pt1for Each partition P ∈ Pt0for Each partition P5:(cid:7) do6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22:is cautiously reachable from P in time t1 − t0 then mark both P and P(cid:4)as “done”.(cid:4)If Pend forend forfor Each partition P ∈ Pt0for Each partition P(cid:4) ∈ Pt1(cid:7) not marked “done” do(cid:7) do(cid:4)If there is any subset of Pminimal x (resp. y) coordinates (for uniqueness). Add Pfor PMark P and PGoto line 3are inherited from P(cid:4) \ P(cid:4)(cid:4)“done”.and P).(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)that P cautiously reaches in time t1 − t0, let P(cid:4)(cid:4)(cid:4)(cid:4)and P(cid:4) \ P(cid:4)(cid:4)to Pt1 and remove Pbe the largest such subset with(the “done” marks(cid:4)end forend forfor Each partition P ∈ Pt1for Each partition P(cid:4) ∈ Pt0(cid:7) not marked “done” do(cid:7) do(cid:4)If there is any subset of Pminimal x (resp. y) coordinates (for uniqueness). Add Pfor PGoto line 3are inherited from P(cid:4) \ Pand P).(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)that cautiously reaches P in time t1 − t0, let P(cid:4)(cid:4)(cid:4)(cid:4)and P(cid:4) \ P(cid:4)(cid:4)to Pt0 and remove Pbe the largest such subset with(the “done” marks(cid:4)end forend forIf there is a partition not marked “done”, find the largest partition in either P t0 or Pt1 , with minimal x (resp. y)coordinates. Remove it from the partition set, split it in half, and add both halves as partitions to the partitionset, inheriting any marks.23: end whileJ. Grant et al. / Artificial Intelligence 174 (2010) 72–10493Fig. 5. Initial partitions of the same space at two time points, with arrows signifying cautious reachability.Fig. 6. First iteration splits q1 into q1a and q1b.Fig. 7. Second iteration splits q2 into q2a and q2b, finishing the granularization.The following example shows how granularization works.Example 20. Suppose the underlying 3 × 3 space is partitioned according to Fig. 4 at time point 0, and according to Fig. 3 attime point 1. For this example, we suppose a reachability predicate allowing the object to travel a Manhattan distance of atmost 2 at each time point. The partitions are shown in Fig. 5 with the arrows signifying cautious reachability between theassociated partitions. The algorithm divides the partitions so that every resulting partition at time 0 can cautiously reach apartition at time 1 (i.e. has an arrow originating from it), and every resulting partition at time 1 is cautiously reached by apartition at time 0 (i.e. has an arrow terminating at it).On the first iteration of the while loop in Algorithm 3, the first unmarked partition encountered is p2, since p2 hasno arrows originating from it. However, there is a subset of q1 that p2 reaches. The algorithm then removes q1 from thesecond partition, and replaces it with the partitions q1a and q1b shown in Fig. 6. Notice how with the division of q1, manymore partitions are cautiously reachable.On the second iteration of the while loop, the first unmarked partition encountered is p4. p4 can reach a subset of q2,so q2 is divided into q2a and q2b as shown in Fig. 7. After this step, enough cautious reachability predicates have becometrue that all partitions at time 0 can reach a partition at time 1, and all partitions at time 1 can be reached by a partitionat time 0. Thus every partition is marked and the algorithm finishes.The following result shows the correctness of the granularization procedure.Proposition 6. If the associated reachability definition is fully connected, then for (P t0 , Pt1 ) returned by Algorithm 3, for all P ∈ Pt0(cid:4) ∈ Pt0 such that P cautiously reachesthere is PPin time t1 − t0 and for all P ∈ Pt1 there is P(cid:4) ∈ Pt1 such that P cautiously reaches Pin time t1 − t0.(cid:4)(cid:4)94J. Grant et al. / Artificial Intelligence 174 (2010) 72–104By partitioning space and using these new reachability predications, we can build new linear programs for computingapproximate probabilistic revisions of a PST KB. In this section we assume such a consistent K and a revision atom ra =loc(id, r, t)[(cid:2), u]. We further assume that all atoms in K reference the same id as in the revision atom (we can do thiswithout loss of generality because no atoms except those referencing the same id can be changed in probabilistic revision).For technical purposes relating to the construction of the partitions, we add a null atom, loc(id, r, t)[0, 1] (that does notchange the meaning of K) to K. The inclusion of this null atom ensures that the time point t will be in T K and will includer when computing the partitioning of S for time t. The linear program given in the next definition will then be guaranteedto have the variables relating to the revision atom.As before, we create T K as the set of time points mentioned in K, and create a partitioning P ti for each ti ∈ T K.The variables for this set of linear constraints specify the probability of moving from partition to partition. They are of(cid:4) ∈ Pti+1 . vti ,P ,P (cid:4) represents the probability of id being in partition P at time ti andthe form vti ,P ,P (cid:4) where P ∈ Pti and Pat time ti+1. For PST atoms loc(idi, ri, ti)[(cid:2)i, ui] ∈ K, the variables lowi and upi are included as themoving to partition Prevised atom’s lower and upper bounds. We include only the more useful cautious case below; a similar definition can begiven for the optimistic case.(cid:4)Definition 28 (Cautious Partition Revision Linear Program). For PST KB K, revision atom ra, and granularizations P tipartitions Pti for each ti ∈ T K, the cautious partition revision linear program, C PRLP(K, ra, {P ticonstraints:(cid:7) of the(cid:7) }), contains the following1. For each ai = loc(idi, ri, ti)[(cid:2)i, ui] ∈ K:(cid:2)(cid:2)(cid:2)(a) 0 (cid:2) ((cid:7) , P ∩ri (cid:7)=∅(b) 0 (cid:4) ((cid:7) ,P ∩ri (cid:7)=∅(c) (cid:2)i (cid:4) lowi , lowi (cid:4) 0, ui (cid:2) upi , and upivti ,P ,P (cid:4) ) − lowi .vti ,P ,P (cid:4) ) − upi .(cid:2) 1.P (cid:4)∈Pti+1(cid:7)P (cid:4)∈Pti+1(cid:7)P ∈PtiP ∈Pti(cid:2)vti ,P ,P (cid:4) ).vti ,P ,P (cid:4) ).2. For ra = loc(id, r, t)[(cid:2), u]:(cid:2)(cid:2)(cid:2)(cid:2)(a) (cid:2) (cid:2) ((b) u (cid:4) ((cid:7) ,P ∩ri (cid:7)=0(cid:7) ,P ∩ri (cid:7)=0P ∈PtiP (cid:4)∈Pti+1(cid:7)P ∈PtiP (cid:4)∈Pti+1(cid:7)3. For each ti in T K s.t. ti+1 ∈ T K:(a) For all vti ,P ,P (cid:4) , vti ,P ,P (cid:4) (cid:4) 0.(cid:2)(b)P (cid:4)∈Pti+1P ∈Pti(cid:7)(cid:7)(c) For all P ∈ Pti(cid:7) , P(d) For all P ∈ Pti(cid:7) :vti ,P ,P (cid:4) = 1.(cid:4) ∈ Pti+1(cid:7)(cid:2)(cid:2)P (cid:4)∈Pti(cid:7)if reachable(cid:2)vti ,P (cid:4),P =∀id(P , PP (cid:4)∈Pti+1(cid:7)(cid:4), ti+1 − ti) /∈ RDT: vti ,P ,P (cid:4) = 0.vti+1,P ,P (cid:4) .i((cid:2) − lowi) +Just as for the probabilistic revision algorithm (see Definition 20), we can minimize the objective function− u) subject to C PRLP(K, ra), as shown below. Unlike the probabilistic revision algorithm, the results will only be an(cid:2)(upiapproximation.Algorithm 4. Computes an approximate probabilistic revision using partitioning of space for given K and ra = loc(id, r,t)[(cid:2), u].(cid:4), t(cid:4), r(cid:4) = id}.(cid:4)] ∈ K|idLet ¯K = {loc(id(cid:4))[(cid:2)(cid:4), uAdd loc(id, r, t)[0, 1] to ¯K.For each ti ∈ T K, create Pti , the partition of space according to point equivalence.Set Pt0for i = 0 to |T K| − 1 do(cid:7) , Pti+1(cid:7)) = Granularize(Pti , Pti+1 ).(cid:7) = Pt0 .Let (Ptiend forConstruct C PRLP( ¯K, ra, {Pti(cid:7) }).Let θ be a solution minimizingreturn {loc(id, ri, ti)[lowiθ, upiθ] | loc(id, ri, ti)[(cid:2)i, ui] ∈ ¯K} ∪ {ra}.i((cid:2) − lowi) + (upi(cid:2)− u) subject to C PRLP(K, ra, {Pti(cid:7) }).The following example shows how this algorithm works.Example 21. Consider the knowledge base(cid:7)(cid:8)a1 = loc(id, A, 0)[0.5, 1], a2 = loc(id, B, 0)[0.75, 1]where A and B refer to the regions in Fig. 3. Further suppose the revision atom ra = {loc(id, A, 0)[0, 0]}, which states thatthe object is not in region A at time 0. First, the algorithm sets ¯K to K ∪ {loc(id, A, 0)[0, 1]}, a dummy atom to ensurethe appropriate partitions are created. Initially, Algorithm 4 partitions space according to point equivalence (resulting inJ. Grant et al. / Artificial Intelligence 174 (2010) 72–10495the partitioning shown in Fig. 3). Then, after running the granularization (Algorithm 3) procedure before line 8, we letthe resulting P 0}) is thefollowing simplified set of linear constraints (all variables known to be zero have been removed):(cid:7) be the partitionings shown in Fig. 7. The resulting linear program, C PRLP(K, ra, {P 0(cid:7) and P 1(cid:7) , P 1(cid:7)1. Inequalities for each atom:(a) For a1 = loc(id, A, 0)[0.5, 1]:0 (cid:2) v 0,p1,q1a + v 0,p1,q1b + v 0,p2,q1a + v 0,p2,q2b + v 0,p9,q4 + v 0,p8,q1b + v 0,p8,q2a − low1,0 (cid:4) v 0,p1,q1a + v 0,p1,q1b + v 0,p2,q1a + v 0,p2,q2b + v 0,p9,q4 + v 0,p8,q1b + v 0,p8,q2a − up1,low1 (cid:2) 0.5, up1(cid:4) 1.(b) For a2 = loc(id, B, 0)[0.75, 1]:0 (cid:2) v 0,p9,q4 + v 0,p4,q2b + v 0,p5,q3 + v 0,p6,q2a − low2,0 (cid:4) v 0,p9,q4 + v 0,p4,q2b + v 0,p5,q3 + v 0,p6,q2a − up2,low2 (cid:2) 0.75, up2(cid:4) 1.2. For the revision atom loc(id, A, 0)[0, 0]:0 (cid:2) v 0,p1,q1a + v 0,p1,q1b + v 0,p2,q1a + v 0,p2,q2b + v 0,p9,q4 + v 0,p8,q1b + v 0,p8,q2a,1 (cid:4) v 0,p1,q1a + v 0,p1,q1b + v 0,p2,q1a + v 0,p2,q2b + v 0,p9,q4 + v 0,p8,q1b + v 0,p8,q2a.3. Extra constraints for correctness:(a) v 0,p1,q1a (cid:4) 0, v 0,p1,q1b (cid:4) 0, v 0,p2,q1a (cid:4) 0, v 0,p2,q2b (cid:4) 0, v 0,p3,q1a (cid:4) 0, v 0,p3,q2b (cid:4) 0, v 0,p4,q2b (cid:4) 0, v 0,p5,q3 (cid:4) 0,(b) v 0,p1,q1a + v 0,p1,q1b + v 0,p2,q1a + v 0,p2,q2b + v 0,p3,q1a + v 0,p3,q2b + v 0,p4,q2b + v 0,p5,q3 + v 0,p6,q2a + v 0,p7,q2a +v 0,p6,q2a (cid:4) 0, v 0,p7,q2a (cid:4) 0, v 0,p9,q4 (cid:4) 0.v 0,p9,q4 = 1.(c) All variables known to be zero are removed.(d) Since we have only one time point in the example, no movement constraints are necessary.This set of constraints is substantially smaller than PRLPT (K, ra), which even after eliminating variables known to be zero− low1 − low2 subject to those constraints,would use at least 45 variables (here we have only 11). By minimizing up1= 1, low1 = 0, and low2 = 0.75. The resulting knowledge base iswe will come up with a solution where up1therefore: {loc(id, A, 0)[0, 1], loc(id, B, 0)[0.75, 1]} ∪ {ra = loc(id, A, 0)[0, 0]}.= 1, up2+ up26. Related workThere is much work on spatio-temporal logics [10,16] in the literature. These logics extend temporal logics to handlespace. There is also much work on qualitative spatio-temporal theories (for a survey see [5,18,28] which discusses theframe problem when constructing a logic-based calculus for reasoning about the movement of objects in a real-valued co-ordinate system). [25] focuses on relative position and orientation of objects with existing methods for qualitative reasoningin a Newtonian framework. Other efforts combine a spatial logic, such as RCC − 8 [26], BRCC − 8 [31] and S4u [4], withpropositional temporal logics (PTL). The work on spatio-temporal reasoning is mostly qualitative [5,9,16,32], and focuses onrelations between spatio-temporal entities while dealing with discrete time.In contrast to all the important works mentioned above, our work brings two important new elements together.• First, our work blends probabilities into the mix, and is intended for reasoning about moving objects whose location ata given point in time (past, present or future) is not known with certainty. The preceding work above does not.• Second, this specific paper focuses on the problem of belief revision (not studied in past work) in spatio-temporal logicswith uncertainty. We have not seen a treatment of belief revision in spatio-temporal logics thus far, and certainly notfor probabilistic spatio-temporal logics.In addition to the above works on spatio-temporal logics, there are works on logics integrating time and probabilities.Much of this work was performed in the model checking community. The PRISM system [14] supports a mix of timeand probabilities for model checking by model checking w.r.t. specifications written in the temporal probabilistic logicsPCTL [11] and CSL [2]. However, none of these works has any spatial element in them, and they focus on model checking,not on handling knowledge base updates.Another related work by our group on reasoning about “go” theories [6–8] focused on spatio-temporal logical theoriesthat were sets of “go” atoms. Such atoms intuitively described plans (known) of moving objects. A go-atom states that anobject will go from location A to location B, leaving A at a time point in some time interval, arriving at B at a time pointin some interval, and traveling in the interim at a velocity within some stated interval. [6] developed a basic theory of“go” theories, while [8] gave a closed world assumption for such theories. Later, [24] extended this logic to include someprobabilistic information about such plans. We extended this work to uncertainty about where objects might be at a giventime [20,21]. This paper builds upon the framework of [20,21], but makes two major changes. First, it addresses the problemof belief revision in probabilistic spatio-temporal theories — something we have not seen addressed before in the literature.Second (as a minor contribution), it adds the realistic requirement that vehicles can only reach certain places within certaintime frames.96J. Grant et al. / Artificial Intelligence 174 (2010) 72–1047. ConclusionsThough there has been extensive interest in AI over the last few years on reasoning about moving objects, to date wehave seen no work (except the short version of this paper [23]) on belief revision in probabilistic spatio-temporal theories.This is a particularly important and thorny problem because information about moving objects may come in at a very highrate. For instance, moving objects with RFID tags on them will submit reports whenever they are within reach of a RFIDscanner. The location of moving objects such as cell phones are continuously monitored by a satellite network (this is whatallows police to track locations from where emergency cell phone calls have been made, or to track criminals engaged incell phone communications). Additional applications include satellite tracking of birds and animals for wildlife and biologicalstudies where the animals in question are constantly on the move. What is common about all of these types of applications is thatthere is continuous change about when observations are made and where they are made. Concurrently with such data collectionmethods are a wide suite of methods to predict where moving objects will be in the future. Recent work [29] focuses onpredicting the destinations of moving objects using probabilistic HMMs. Mittu and Ross [17] and Hammel [30] developedmethods to predict locations of enemy submarines in the future. Such prediction methods produce atoms closely resemblingthe PST atoms in this paper.In this paper, we first build on the framework of our own past work [20,21] in order to include the realistic requirementthat vehicles have velocity constraints and we show how to handle consistency checking in this setting. We then developanalogs of the AGM axioms to handle insertions into PST KBs and evaluate different ways of accomplishing these revisions.We present three types of revision methods.• The maximal consistent subset, and the maximal cardinality subset strategies revise a PST knowledge base in the pres-ence of new information by completely dropping PST atoms (either by dropping a minimal subset, or a cardinalityminimal subset). While both these methods satisfy our AGM-style axioms, they lead to computationally intractableproblems.• The second class of revision methods each modify one component of PST atoms in the PST knowledge base.◦ Spatial revisions only modify the spatial component of PST atoms and do not satisfy AGM-style axioms.◦ Temporal revisions only modify the temporal component of PST atoms, but lead to computational intractability.◦ Object revisions modify only the object id part of a PST atom and satisfy AGM-style axioms, but computing them iscomputationally intractable.◦ Probabilistic revisions have the wonderful feature that they both satisfy AGM-style axioms and are polynomiallysolvable.• Our third class of revision methods are hybrid in nature, combining elements of the previous two methods. Weightedhybrid revision allows spatial, temporal, object and probabilistic revisions to co-occur — but again, computing an optimalrevision of this kind is computationally intractable. Another hybrid mechanism — Probabilistic Maximal Subset revisioncombines maximal consistent subsets and probabilistic revision, and is also intractable.Fig. 1 introduced in Section 1 presents a summary of our results — both in terms of AGM compliance and in terms ofcomplexity results.Last but not least, we study probabilistic revision further and develop methods to reduce the size of the problem so thatthe performance of probabilistic revision can be improved.For example, consider the paper of [17] that describes a system to predict where (enemy) submarines will be in the fu-ture, given the presence of a sensor field that produces observations at irregular time periods. Whenever a new observationabout a particular submarine is made, a prediction algorithm may produce new predictions about where that submarinewill be in the future. When we attempt to add these new predictions to a PST knowledge base the result may well beinconsistent (because the new observation may conflict with past predictions — we all know predictions are often wrong)with the previous predictions and as a consequence, the PST knowledge base needs to be updated. The speed at which weneed to update the PST knowledge base depends upon the speed with which new observations are being made. In the caseof submarine observations via an underwater sonar field, the observations may not be coming in too frequently.However, consider a different application where military air traffic control need to predict where enemy planes will bein the future. Such predictions may be made using algorithms that look at satellite surveillance data of the air space inquestion. However, the observations here are likely to be made much more frequently than in the submarine’s case andhence, new predictions of the planned flight path of the enemy plane will be continuously generated. When inserting theseinto a knowledge base of predictions, we need to revise the PST knowledge base. Such revisions are likely to be neededquite frequently because the frequency of observations in this application is higher.In general, much work remains to be done. A detailed implementation and experimental analysis of the heuristic al-gorithms in this paper needs to be done. Randomized algorithms to solve massive linear programs such as those in [13]need to be developed to further scale such belief revision algorithms. For instance, we need to scale them along severaldimensions. First, we need to study what happens as more and more time points are considered, i.e. |T | is increased. Wealso need to study what happens when |S| increases. A third thing is to study how these algorithms (and improvementsupon them) perform when the frequency of updates is increased. Fast approximation algorithms, together with good ap-proximation guarantees would also be helpful. In this paper, we have shown a number of NP-hardness results, but no strongJ. Grant et al. / Artificial Intelligence 174 (2010) 72–10497NP-hardness results (which generally show additionally that the problems are not polynomially approximable either). Suchresults would also be very useful. In addition, there is the possibility that priorities exist among the various atoms in a PSTknowledge base. If we extend the PST-logic syntax to include the usual logic connectives (which we have not done hereas the paper is already quite complex), and define logic consequence in the obvious way, then we can leverage the baserevision paradigm [12] for this purpose. These are important directions for future work.AcknowledgementsResearchers funded in part by ARO grant W911NF0910206, ONR grant N000140910685, and AFOSR grant FA95500510298.We thank the referees for many helpful comments and suggestions.Appendix A. The maximum cardinality subset sum problemThe maximum cardinality subset sum (MCSS) problem is defined as follows.Definition 29 (MCSS Problem). Given a set of positive integers S = {s1, . . . , sn}, a positive integer constant c, and a subset(cid:4) ⊆ S, decide whether Ssi ∈S(cid:4) si = c and thereSis a maximum cardinality subset of S which sum up exactly to c, that is,is no subset S(cid:4)(cid:4) ⊆ S such that |S(cid:4)| and(cid:4)(cid:4)| > |S(cid:2)(cid:2)(cid:4)si ∈S(cid:4)(cid:4) si = c.We show that MCSS is coNP-hard.Lemma 1. The Maximum Cardinality Subset Sum Problem is coNP-hard.Proof. We show a LOGSPACE reduction from the complement of the Subset Sum problem, which is coNP-hard [19], to ourproblem. The complement of the Subset Sum problem is defined as follows: given a set of positive integers S = {s1, . . . , sn}and a positive integer constant c, decide if there is no subset S(cid:4) ⊆ S such that(cid:2)Observe that the complement of Subset Sum is still coNP-hard even if we require that S does not contain {c}. We(cid:4)1) starting from an instance (S, c) of theconsider this case in the following. We construct an instance of MCSS (S 1, c1, Scomplement of Subset Sum as follows. S1 = S ∪ {c}, c1 = c, and Ssi ∈S(cid:4) si = c.(cid:4)1= {c1}.(cid:4)1 is a maximum cardinality subset of S1 which sumsWe prove that there is no subset S(cid:4) ⊆ S such thatsi ∈S(cid:4) si = c iff S(cid:2)up exactly to c1 by contraposition.(⇒) Assume that S(cid:4)(cid:4)1(cid:4)such that |S1sum would be greater than c1). Thus, S(cid:2)(cid:4)1 is not a maximum cardinality subset of S1 which sums up exactly to c1. Then there is S| andsi = c1. As the elements of S1 are positive integers, S⊆ S1(cid:4)(cid:4)1 does not contain c1 (otherwise the(cid:4)(cid:4) ⊆ S such that(cid:4)(cid:4) ⊆ S. As c1 = c, there is also a subset of S⊆ S1 \ {c1}, that is, S| > |Ssi ∈S(cid:2)(cid:4)(cid:4)1(cid:4)(cid:4)1(cid:4)(cid:4)1si ∈S(cid:4)(cid:4) si = c.(⇐) Assume that there is a subset S(cid:2)(cid:4)| (cid:4) 2. Let Spositive integers only, |Sandsi = c = c1. (cid:2)(cid:4)(cid:4)1si ∈S(cid:4)(cid:4)1(cid:4) ⊆ S such that(cid:2)⊆ S1 contain the same elements of Ssi ∈S(cid:4) si = c. As S does not contain element c and consists of| = 1⊆ S1 such that |S. Then there is S| > |S(cid:4)(cid:4)(cid:4)1(cid:4)1(cid:4)(cid:4)1Appendix B. ProofsProposition 1. (cid:3)m satisfies the AGM axioms.Proof. Axioms (A1) to (A4) are straightforward. Axiom (A5) also holds because K (cid:3)m ra = K(cid:4) ∪ ra, where K(cid:4)is the largestsubset of K consistent with ra. The only way for K (cid:3)m ra to be inconsistent is for K(cid:4)to be empty and ra inconsistent byitself (if ra is consistent, in the worst case K(cid:4) = ∅). Axiom (A6) is verified because of the strict total ordering introduced forthe maximal subsets. (cid:2)Theorem 2. Given PST KBs K and K(cid:4), and revision atom ra, determining if K(cid:4) ∪ {ra} = K (cid:3)m ra is coNP-complete.Proof. (Membership) Given K, K(cid:4)whether K(cid:4) ∪ {ra} = K (cid:3)m ra is a PST KB K(cid:4)(cid:4)subset strategy and either (i) K(cid:4) (cid:2) K(cid:4)(cid:4)polynomial time, the problem is in coNP., and ra, a polynomial size witness for the complement of the problem of decidingsuch that K(cid:4)(cid:4) ∪ {ra} accomplishes the revision of K by adding ra via theaccording the order O T . As this witness can be verified inprecedes K(cid:4)or (ii) K(cid:4)(cid:4)(Hardness) Take an instance of MCSS defined by S = {s1, . . . , sn}, constant c and SLemma 1, also in Appendix A, this problem is coNP-hard. We reduce from MCSS to show coNP-hardness. Let tot =Let S = {p1, . . . , pn, pn+1} (n + 1 point space) and(cid:8)(cid:10)(cid:9)(cid:4) ⊆ S (Definition 29 in Appendix A). Bysi ∈S si .(cid:2)K =(cid:7)locid, {pi}, 0[si/tot, si/tot] | si ∈ S.98J. Grant et al. / Artificial Intelligence 174 (2010) 72–104(cid:9)(cid:7)K(cid:4) =Let ra = loc(id, {pn+1}, 0)[1 − c/tot, 1 − c/tot], and let(cid:10)id, {pi}, 0.Consider orderings O T that prefer revision ¯K to ¯K(cid:4)c/tot. If[si/tot, si/tot] | si ∈ Sloc(cid:2)(cid:2)(cid:8)(cid:4)loc(id,r,t)[(cid:2),u]∈ ¯K (cid:2) =(cid:3)(cid:2) = c/tot,loc(id,r,t)[(cid:2),u]∈ ¯K(cid:4) (cid:2) = c/tot then ¯K < ¯K(cid:4)( ¯K < ¯K(cid:4)) whenever(cid:2)loc(id,r,t)[(cid:2),u]∈ ¯K (cid:2) = c/tot andif | ¯K| > | ¯K(cid:4)|. Finally, of all ¯K such that(cid:2)loc(id,r,t)[(cid:2),u]∈ ¯K(cid:4) (cid:2) (cid:7)=loc(id,r,t)[(cid:2),u]∈ ¯Kwhich also have size |K(cid:4)|, K(cid:4)is minimal according to O T . That is, O T prefers any maximally sized database whose atoms’lower bounds sum to c/tot, and further, of the databases of size |K(cid:4)| whose atoms’ lower bounds sum to c/tot, it prefers K(cid:4).(cid:4)) is an instanceis a maximal subset revision of K w.r.t. ra under O T iff (S, c, SNow we show by contraposition that K(cid:4)of MCSS.(⇒): Suppose that (S, c, S(cid:4)) is not an instance of MCSS. Then there is S(cid:4)(cid:4) ⊆ S such that(cid:2)s∈S(cid:4)(cid:4) s = c and |S(cid:4)(cid:4)| > |S|.Construct K(cid:4)(cid:4):(cid:7)K(cid:4)(cid:4) =(cid:9)loc(cid:10)id, {pi}, 0(cid:2)[si/tot, si/tot] | si ∈ S.loc(id,r,t)[(cid:2),u]∈K(cid:4)(cid:4) (cid:2) = c/tot and |K(cid:4)(cid:4)| > |K(cid:4)|. Therefore K(cid:4)(cid:4)K(cid:4)(cid:4) ∪ {ra} is consistent,a revision of K by adding ra via the max-subset strategy.(cid:8)(cid:4)(cid:4)is preferred by O T over K(cid:4)and K(cid:4)is not(⇐): Suppose K(cid:4)(cid:4)) be an instance of MCSS. Let K(cid:4)(cid:4): the sum of the lower bounds of all atoms in K(cid:4)is not a maximal subset revision of K. Let (S, c, Scannot be a superset of K(cid:4)be the optimal max-subset revision. Notice that K(cid:4)(cid:4)is exactly c/tot,and the revision atom enforces a lower bound of 1 − c/tot. Since all concerned atoms have neither intersecting regionsnor zero lower bounds, the inclusion of any other atom would force inconsistency. Thus K(cid:4)(cid:4) (cid:7)⊃ K(cid:4)must bepreferred over K(cid:4)by O T . O T prefers knowledge bases whose atoms’ lower bounds sum to c/tot, thus the lower boundssum to c/tot. Among knowledge bases whose atoms’ lower bounds sum to c/tot (including both K(cid:4)of the atoms in K(cid:4)(cid:4)and K(cid:4)(cid:4), O Tprefers K(cid:4)would not be optimal). Now construct(cid:4))(cid:4)|. Because of S(cid:4)(cid:4) = {si | loc(id, {pi}, 0)[si/tot, si/tot] ∈ K(cid:4)(cid:4)}. Note thatSis not an instance of MCSS. (cid:2)), O T prefers the larger knowledge bases, and among such knowledge bases that are also the same size as K(cid:4)si ∈S(cid:4)(cid:4) si = c and since |K(cid:4)(cid:4)| > |K(cid:4)|, |S. Therefore |K(cid:4)(cid:4)| > |K(cid:4)| (otherwise K(cid:4)would be preferred by O T and K(cid:4)(cid:4)and thus K(cid:4)(cid:4)(cid:4)(cid:4)| > |S, (S, c, S(cid:2)(cid:4)(cid:4)Theorem 3. Given PST KBs K and K(cid:4)and PST atom ra, determining whether K(cid:4) ∪ {ra} accomplishes the revision of K by adding ra viathe max-subset strategy according only to Definition 9 (irrespective of the order O T ) can be accomplished in polynomial time w.r.t.the size of K.is a subset of K and K(cid:4) ∪ {ra} is consistent and there is no other. The idea is to take potential max-subset revision K(cid:4), andthat have exactly one more element and are still subsets of K: if one of those subsets is consistentdoes not accomplish max-subset revision of K. However, if all such supersets are inconsistent, we can verifyis consistent with ra.accomplishes max-subset revision by checking if K(cid:4)Proof. We can use the following procedure to check if K(cid:4)K(cid:4)(cid:4) ∪ {ra} that accomplishes the same revision such that K(cid:4) (cid:2) K(cid:4)(cid:4)check all supersets of K(cid:4)with ra then K(cid:4)that K(cid:4)CheckSubsets(K, K(cid:4), ra)1: If K(cid:4)2: If K(cid:4) ∪ {ra} is not consistent, return false.3: Let V = {K(cid:4) ∪ {sa}|sa ∈ K, sa /∈ K(cid:4)} (notice |V | (cid:2) |K|).4: Check the consistency of K(cid:4)(cid:4) ∪ {a} for all K(cid:4)(cid:4) ∈ V .5: If all K(cid:4)(cid:4) ∈ V results in inconsistent K(cid:4)(cid:4) ∪ {ra}, then return true.6: Return false otherwise.is not a subset of K, return false.Notice that every step of CheckSubsets is polynomially computable: the most expensive step is line 4, where we checkat most |K| knowledge bases for consistency. However, since all the knowledge bases have size at most |K| and sinceconsistency checking is polynomial, that line runs in polynomial time.The existence of such a polynomial time algorithm allows us to show that determining if K(cid:4)accomplishes max-subsetaccomplishes the revision of K by adding ra via the max-subset strategy, then this can be verified by checkingrevision is in both NP and coNP, and is therefore polynomially computable.In NP: If K(cid:4)that CheckSubsets(K, K(cid:4), ra) returns true.In coNP: If K(cid:4)such that K(cid:4)(cid:4) ∪ {ra} is consistent. Take some sa ∈ K(cid:4)(cid:4) \ K(cid:4)inconsistent). Thus the algorithm returns false in this case providing a polynomial time method for verifying that K(cid:4)not accomplish max-subset revision. (cid:2)does not accomplish the revision of K by adding ra via the max-subset strategy, then there is K(cid:4)(cid:4) ⊃ K(cid:4)would bedoes. (K(cid:4) \ {sa}) ∪ {ra} must be consistent (otherwise K(cid:4)(cid:4)Theorem 4. Determining if K(cid:4)accomplishes max-cardinality revision of K by adding ra is coNP-complete.J. Grant et al. / Artificial Intelligence 174 (2010) 72–10499Proof. (Membership) Given K, ra, and K(cid:4), a polynomial size witness for the complement of the problem of decidingwhether K(cid:4)such that K(cid:4)(cid:4) ∪ {ra} accomplishes the revision of K byadding ra via the subset strategy and |K(cid:4)(cid:4)| > |K(cid:4)|. As this witness can be verified in polynomial time, the problem is incoNP.is a max-cardinality revision of K is a PST KB K(cid:4)(cid:4)(Hardness) Take an instance of MCSS defined by S = {s1, . . . , sn}, constant c and S(cid:2)(cid:4) ⊂ S (Definition 29 in Appendix A).By Lemma 1, also in Appendix A, this problem is coNP-hard. We reduce from MCSS to show coNP-hardness. Let tot =1 +si ∈S si . Let S = {p1, . . . , pn, pn+1} (n + 1 point space). We use the knowledge base(cid:8)c/tot, 1 − k/Kback =id, {p1, . . . , pn}, 0| k = 1, . . . , n + 1(n + 1) · totloc(cid:10)(cid:6)(cid:10)(cid:5)(cid:7)(cid:9)(cid:9)as a backdrop of n + 1 atoms (distinguished by their upper bounds) that we do not expect to change. Kback ensures thatunless we remove more than n + 1 atoms the lower bound for the probability in the region {p1, . . . , pn} will be c/tot. LetK =(cid:9)(cid:7)loc(cid:10)id, {pi}, 0[si/tot, si/tot] | si ∈ S∪ Kback.Let ra = loc(id, {pn+1}, 0)[1 − c/tot, 1 − c/tot], and let(cid:10)(cid:8)(cid:7)(cid:9)K(cid:4) =locid, {pi}, 0[si/tot, si/tot] | si ∈ S∪ Kback.(cid:8)(cid:4)We show by contraposition that K(cid:4)subset of S such that(cid:2)(⇒): Suppose that S(cid:2)(cid:4)s∈S(cid:4) s = c.is not a maximal cardinality subset of S such that(cid:2)such that(cid:2)s∈S(cid:4)(cid:4) s = c. Let K(cid:4)(cid:4) = {loc(id, {pi}, 0)[si/tot, si/tot] | si ∈ S(cid:4)(cid:4)} ∪ Kback. Since |Ss∈S(cid:4) s = c. Then there is S(cid:4)(cid:4)| > |S(cid:4)(cid:4) ⊂ S with |S(cid:4)|(cid:4)(cid:4)| > |S(cid:4)|, |K(cid:4)(cid:4)| > |K(cid:4)|. Further, sinceaccomplishes revision of K by ra via max-cardinality iff S(cid:4)is the maximal cardinalitys∈S(cid:4)(cid:4) s = c, K(cid:4)(cid:4)(⇐): Suppose that K(cid:4)is consistent with ra. Thus K(cid:4)does not accomplish the revision of K by adding ra via max-cardinality.is not the max-cardinality revision of K. Let K(cid:4)(cid:4)be a max-cardinality revision of K. Notice thatra ∪ Kback causes no problem: members of Kback ensure that the area {p1, . . . , pn} has probability at least c/tot, whilera ensures that the area {p1, . . . , pn} has probability at most c/tot. To eliminate the requirement that {p1, . . . , pn} hasprobability at least c/tot, all n + 1 members of Kback would have to be removed from K, and therefore we can be assuredthat in K(cid:4)(cid:4)that are not also in Kbackmust be at least c/tot:(cid:3), there is at least one atom loc(id, {p1, . . . , pn}, 0)[c/tot, ·]. Thus the sum of atoms in K(cid:4)(cid:4)is compatible with ra, those same atoms can add up to no more than c/tot:loc(id,{pi },0)[si /tot,si /tot]∈K(cid:4)(cid:4)\KbackAlso, because K(cid:4)(cid:4)(cid:3)loc(id,{pi },0)[si /tot,si /tot]∈K(cid:4)(cid:4)\KbackThus we have that(cid:3)loc(id,{pi },0)[si /tot,si /tot]∈K(cid:4)(cid:4)\Kbacksi/tot (cid:4) c/tot.si/tot (cid:2) c/tot.si/tot = c/tot.Thus we can create Sbigger than K(cid:4)(cid:4)(cid:4) = {si | loc(id, {pi}, 0)[si/tot, si/tot] ∈ K(cid:4)(cid:4) \ Kback}, and we are guaranteed that, it follows that Sis bigger than S. So Sis not a maximal cardinality subset of S such that(cid:4)(cid:4)(cid:4)(cid:4)si ∈S(cid:4)(cid:4) si = c. Since K(cid:4)(cid:4)(cid:2)iss∈S(cid:4) s = c. (cid:2)(cid:2)Proposition 2. For knowledge base K and revision atom ra, K (cid:3)c ra is an AGM-compliant revision function.Proof. (A1)–(A5) are straightforward. (A6) follows from the use of the strict total ordering O T to determine K (cid:3)c ra fromall knowledge bases accomplishing max-cardinality revision of K by ra. (cid:2)Theorem 5. Suppose that K is a PST KB and ra a PST atom. Let θ be a solution of the optimization problem(cid:3)minimizeai ∈Kδisubject to MCSRP(K, ra).Then K(cid:4) = {ai ∈ K | δiθ = 0} ∪ {ra} accomplishes the revision of K by adding ra via the max-cardinality strategy.Proof. For each ˆK ⊂ K, let Θ ˆK be the set {θ | θ is a solution of MCSRP(K, ra) such that ∀ai ∈ ˆK, δiθ = 1}. We first showthat Θ ˆK is equivalent to the set of solutions of LP(K \ ˆK) (see Definition 8), in the sense that for each solution θ ∈ Θ ˆK,there is a solution θ (cid:4)of LP(K \ ˆK) such that v id,t,p,qθ = v id,t,p,qθ (cid:4), and vice versa.LetˆK ⊂ K and θ ∈ Θ ˆK. Then, for each ai ∈ ˆK, constraint (1)(a) is equal to (cid:2)i − 1 (cid:2) (This is equivalent to using atom a(cid:4)i= loc(idi, ri, ti)[0, 1] instead of ai = loc(idi, ri, ti)[(cid:2)i, ui] in ˆK. Since K \ ˆK ∪ {a(cid:2)(cid:2)p∈riq∈S v idi ,ti ,p,q) (cid:2) ui + 1.(cid:4) =100J. Grant et al. / Artificial Intelligence 174 (2010) 72–104loc(idi, ri, ti)[0, 1] | a = loc(idi, ri, ti)[(cid:2), u] ∈ ˆK} ≡ K \ ˆK, for θ ∈ Θ ˆK, the constraints in MCSRP(K, ra) are equivalent to thosein LP(K \ ˆK). Thus there is a solution θ (cid:4)of LP(K \ ˆK) such that v id,t,p,qθ (cid:4) = v id,t,p,qθ . Next assume that there is a solution θ (cid:4)of LP(K \ ˆK). It is easy to see that constraints (1)(a) for atoms ai ∈ ˆK are satisfied by every solution θ of MCSRP(K, ra) suchthat δiθ = 1, that is, they are satisfied by θ ∈ Θ ˆK. Moreover all the other constraints in MCSRP(K, ra) are satisfied by makingv id,t,p,qθ = v id,t,p,qθ (cid:4). Thus for each ˆK ⊂ K, Θ ˆK is not empty iff LP(K \ ˆK) has a solution iff K \ ˆK ∪ {ra} is consistent.We now show that every optimal solution of the optimization problem determines a knowledge base K(cid:4)accomplishingthe revision of K by adding ra via the max-cardinality strategy.For each solution θ of MCSRP(K, ra), define K(θ) = {ai ∈ K | δiθ = 0}. Clearly, for each solution θ of MCSRP(K, ra), it isthe case that θ ∈ ΘK\K(θ). Moreover, as shown above, K(θ) ∪ {ra} is consistent.Let θ be an optimal solution of the optimization problem, and let K(cid:4)be K(θ). As θ is a solution of MCSRP(K, ra) andθ ∈ ΘK\K(cid:4) , K(cid:4) ∪ {ra} is consistent. As the job of the objective function is to minimize the sum of the δi values, there is noof MCSRP(K, ra) such that Σai ∈Kδiθ (cid:4) < Σai ∈Kδiθ . For every solution θ of MCSRP(K, ra), |K(θ)| = |K| − Σai ∈Kδiθ .solution θ (cid:4)Thus for every solution θ of MCSRP(K, ra), corresponding to a knowledge base K(θ) such that K(θ) ∪ {ra} is consistent,|K(θ)| (cid:2) |K(θ)|, proving that K(cid:4)accomplishes the revision of K by adding ra via the max-cardinality strategy. (cid:2)Theorem 6. Let K be any knowledge base and |S| > 2. A spatial revision satisfying the AGM axioms is possible for every atom ra =loc(id, r, t)[(cid:2), u] where r is a strict subset of S iff for all ai = loc(id, ri, t)[(cid:2)i, ui] ∈ K either li = 0 or ui = 1.Proof. (⇐) To show that a revision satisfying the AGM axioms is possible, it suffices show that a spatial revision consistentwith the revision atom exists because then there will be an optimal spatial revision and Axioms (A1)–(A5) follow directly —(A6) follows from the use of O T . We now construct such a revision. Suppose that for all ai ∈ K, (cid:2)i = 0 or ui = 1, andra = loc(id, r, t)[(cid:2), u] is given. For every ai for which ui = 1, change ri to Space. For every ai for which (cid:2)i = 0, there are twocases: (1) if |r| > 1, change all such ri to the same point in r, and (2) if |r| = 1, change all such ri to the same point in S − r.(⇒) Suppose that for some ai = loc(idi, ri, ti)[(cid:2)i, ui] ∈ K, (cid:2)i (cid:7)= 0 and ui (cid:7)= 1. Let ra = loc(idi, {p}, ti)[1, 1] where p ∈ ri .There is no spatial revision. (cid:2)Proposition 3. If T is infinite and RD is fully connected, then there exists a minimal temporal revision K(cid:4) = K (cid:3)t ra that satisfies theAGM axioms.Proof. It suffices to show that there exists a temporal revision of K consistent with ra. Let ra = loc(id, r, t)[(cid:2), u] and K ={loc(idi, ri, ti)[(cid:2)i, ui]}. Let (cid:10)tid be the maximal time it takes to move from any point in space to any other according tothe reachability predicate. Define K(cid:4)(cid:4) = {loc(id, ri, t + (i + 1) · (cid:10)tid)[(cid:2)i, ui] | idi = id} ∪ {loc(idi, ri, ti)[(cid:2)i, ui] | idi (cid:7)= id}. Since allatoms referencing id refer to time points (cid:10)tid apart, the object id can have moved anywhere in space between atoms andno two atoms (including the revision atom) can contradict one another. Thus K(cid:4)(cid:4)is a temporal revision consistent with ra.That the knowledge base K(cid:4) = K (cid:3)t ra satisfies the AGM Axioms (A1)–(A4) follows directly from the fact that if K isalways exists, Axiom (A5) is verified. Finally, the total ordering O Tconsistent with ra, K(cid:4) = K ∪ {ra}. Since a consistent K(cid:4)ensures compliance with Axiom (A6). (cid:2)Theorem 7. Given a PST atom ra, and PST KBs K, and K(cid:4)Further, if T is finite then deciding whether K(cid:4), deciding whether K(cid:4)is a temporally optimal revision of K by ra is coNP-hard.is a temporally optimal revision of K by adding ra is coNP-complete.Proof. (Membership) Given K(cid:4)is atemporally optimal revision of K is a K(cid:4)(cid:4)is a temporally optimal revision of K; (ii) K(cid:4)(cid:4) ∪ {ra} is consistent;and (iii) dT (K, K(cid:4)(cid:4)) < dT (K, K(cid:4)). Obviously, items (i) and (iii) can be verified in polynomial time. Moreover, if T is finite,item ii) can also be verified in polynomial time by solving LP(K(cid:4)(cid:4) ∪ {ra})., a polynomial size witness for the complement of the problem of deciding whether K(cid:4)such that (i) K(cid:4)(cid:4)(Hardness) We formalize the temporally optimal revision problem as follows: (K, ra, K(cid:4)) is a positive instance of theis an optimal temporal revision of K by adding ra (here we do not consider theoptimal temporal revision problem iff K(cid:4)total order O T ).We give a LOGSPACE reduction from the Maximum Cardinality Subset Sum (MCSS) (see Definition 29 in Appendix A)problem to our problem. Lemma 1 from Appendix A states that MCSS is coNP-hard.Consider an instance of MCSS (S = {s1, . . . , sn}, c, S(cid:4)), and construct an instance of optimal temporal revision as follows.Let S = {p1, . . . , pn, pn+1, . . . , p2n+1}. Create a reachability predicate where reachableid(pi, p j) ∈ RD if: j = n + 1 and i <si ∈S si . Let K = {loc(id, {pi}, 0)[si/Tot, si/Tot] | si ∈ S},n + 1, or i > n and j = i + 1, or j < n + 1 and i = 2n + 1. Let Tot =ra = loc(id, {pn+1}, 1)[c/Tot, c/Tot], and(cid:2)K(cid:4) =(cid:7)(cid:9)loc(cid:10)id, {pi}, 0[si/Tot, si/Tot] | si ∈ S(cid:7)(cid:8)(cid:4)∪(cid:9)id, {pi}, 1(cid:10)loc[si/Tot, si/Tot] | si /∈ S(cid:8)(cid:4).Now we show by contraposition that (S, c, S(cid:4)) is in MCSS iff (K, ra, K(cid:4)) is an optimal temporal revision.J. Grant et al. / Artificial Intelligence 174 (2010) 72–104101(⇒): Notice that dT (K, K(cid:4)) = |S| − |Sa temporal revision K(cid:4)(cid:4)K(cid:4)(cid:4) \ K(cid:4)(cid:4)(cid:7)=0. Observe several things about K(cid:4)(cid:4)s.t. dT (K, K(cid:4)(cid:4)) < dT (K, K(cid:4)). Let K(cid:4)(cid:4)(cid:7)=0(cid:7)=0:(cid:4)|. Suppose that (K, ra, K(cid:4)) is not an optimal temporal revision. Then there is== {loc(id, {pi}, ti)[si/Tot, si/Tot] ∈ K(cid:4)(cid:4) | ti (cid:7)= 0} and let K(cid:4)(cid:4)0• For all loc(id, {pi}, ti)[si/Tot, si/Tot], ti (cid:2) n. If not, then dT (K, K(cid:4)(cid:4)) > n and since |S(cid:4)| (cid:2) n, dT (K, K(cid:4)) would be smallerand K(cid:4)(cid:4)would not be the counter example.• Because of the reachability predicate, all ti > 0 are equal to 1. If ra is consistent with K(cid:4)(cid:4), then ra is consistent with(cid:7)(cid:9)(cid:10)(cid:9)(cid:10)∪locid, {pi}, 1[si/Tot, si/Tot] | locid, {pi}, tiK(cid:4)(cid:4)0Since K(cid:4)(cid:4)(cid:8)[si/Tot, si/Tot] ∈ K(cid:4)(cid:4)(cid:7)=0(cid:7)=0, ti = 1..has minimal dT (K, K(cid:4)(cid:4)) for all loc(id, {pi}, ti)[si/Tot, si/Tot] ∈ K(cid:4)(cid:4)| < |S| − |S• Because dT (K, K(cid:4)(cid:4)) < dT (K, K(cid:4)), |K(cid:4)(cid:4)(cid:7)=0• Because of the reachability predicate, the probability left in locations p1, . . . , pn at time 0 all goes to the location pn+1.(cid:4)|.Thus to be consistent with ra, it must be the case that:loc(id,{pi },0)[si /Tot,si /Tot]∈K(cid:4)(cid:4)0• Because all atoms in K(cid:4)(cid:4)(cid:3)(cid:3)si/Tot (cid:2) c/Tot.si/Tot (cid:2) 1 − c/Tot.(cid:7)=0 are at time point 1, to be consistent with ra, it must be the case that:0 and K(cid:4)(cid:4)(cid:7)=0 are disjoint and cover K(cid:4)(cid:4), this implies:(cid:2)Asloc(id,{pi },ti )[si /Tot,si /Tot]∈K(cid:4)(cid:4)(cid:7)=0si/Tot = 1, and since K(cid:4)(cid:4)(cid:3)sisi/Tot (cid:4) c/Tot.loc(id,{pi },ti )[si /Tot,si /Tot]∈K(cid:4)(cid:4)0• Taken together, the previous three points imply(cid:3)si/Tot = c.loc(id,{pi },ti )[si /Tot,si /Tot]∈K(cid:4)(cid:4)0Construct S(cid:4)(cid:4) =S(cid:2)(cid:4)(cid:4)(cid:7)where(cid:9)si | locid, {pi}, ti(cid:10)(cid:8)[si/Tot, si/Tot]∈ K(cid:4)(cid:4)0.si/Tot = c, we know that(cid:2)Sincethat |S| − |Sloc(id,{pi },ti )[si /Tot,si /Tot]∈K(cid:4)(cid:4)(cid:7)=0(cid:4)(cid:4)| > |S(cid:4)(cid:4)| < |S| − |S(cid:4)| ⇒ |S(⇐): Suppose that (S, c, S(cid:10)(cid:9)(cid:7)K(cid:4)(cid:4) =locid, {pi}, 0(cid:4)(cid:4)| > |S(cid:4)(cid:4)(cid:4)|. Because of S(cid:4)) is not in MCSS. Let S(cid:4)(cid:4)(cid:8)(cid:4)(cid:4)[si/Tot, si/Tot] | si ∈ S∪Note that since |Stime 1 for id is 1 in K(cid:4)(cid:4) ∪ {ra} and it is therefore consistent. Thus K(cid:4)(cid:4)optimal revision. (cid:2)(cid:4)|, dT (K, K(cid:4)(cid:4)) < dT (K, K(cid:4)). Further notice that sincesi ∈S(cid:4)(cid:4) si = c. Further, since dT (K, K(cid:4)(cid:4)) < dT (K, K(cid:4)) we know(cid:4)) is not in MCSS., (S, c, Sbe a counter-example to (S, c, S(cid:10)(cid:7)(cid:4)) being in MCSS. Construct K(cid:4)(cid:4)as:(cid:8)(cid:9)locid, {pi}, 1[si/Tot, si/Tot] | si /∈ S(cid:4)(cid:4).(cid:2)s∈S(cid:4)(cid:4) s = c, the total assigned probability atis a counterexample to (K, ra, K(cid:4)) being a temporallyCorollary 1. Given a PST atom ra, and PST KBs K, K(cid:4)where T is finite, checking whether K(cid:4) = K ˙+t ra is coNP-complete.Proof. (Membership) A polynomial size witness for the complement of the problem of deciding whether K(cid:4) = K ˙+t ra is atemporal revision K(cid:4)(cid:4)such that K(cid:4)(cid:4) ∪ {ra} is consistent and either dT (K, K(cid:4)(cid:4)) < dT (K, K(cid:4)) or dT (K, K(cid:4)(cid:4)) = dT (K, K(cid:4)) and K(cid:4)(cid:4)precedes K according the strict total order O T . As in the case of the membership proof of Theorem 9, this witness can beverified in polynomial time.(Hardness) Consider the proof of Theorem 7 and let O T be such that, for dT (K, K(cid:4)) = |S| − |S(cid:4)|, K(cid:4)is its minimumelement. Then, reasoning as in the proof of Theorem 7, it is easy to see that (S, c, S(cid:4)) is in MCSS iff K(cid:4) = K ˙+t ra. (cid:2)Theorem 8. If there exists a minimal temporal revision for K with respect to ra, then Algorithm 2 is correct, i.e. TemporalRevision(K,ra) returns K (cid:3)t ra. Moreover, TemporalRevision(K, a) satisfies the AGM axioms.is the minimal temporal revision. That Algorithm 2 returns K(cid:4) ∪ {ra} follows from the order in whichProof. Suppose that K(cid:4). In each iteration of the while loop, d(K, K(cid:4)(cid:4)) for allthe algorithm checks the consistency of potential temporal revisions K(cid:4)(cid:4)K(cid:4)(cid:4)in TODO increases by one. Since each element of TODO is checked at each iteration, the algorithm cannot return any K(cid:4)(cid:4)such that d(K, K(cid:4)(cid:4)) < d(K, K(cid:4)). Further, the list TODO is sorted according to O T , therefore when the temporal distance from102J. Grant et al. / Artificial Intelligence 174 (2010) 72–104any element of TODO to K is d(K, K(cid:4)), the first element from TODO checked will be K(cid:4)O T , K(cid:4)will be placed at the front). Thus K(cid:4) = K (cid:3)t ra will be returned.That K (cid:3)t ra complies with the AGM axioms is straightforward. (cid:2)(when TODO is sorted according toTheorem 9. Given a PST atom ra, and PST KBs K, K(cid:4)coNP-complete.where T is finite, deciding whether K(cid:4)is an optimal object id revision of K isProof. (Membership) Given K(cid:4)is anoptimal object id revision of K is a K(cid:4)(cid:4)is an object id revision of K; (ii) K(cid:4)(cid:4) ∪ {ra} is consistent; and(iii) d O (K, K(cid:4)(cid:4)) < d O (K, K(cid:4)). Obviously, this witness can be verified in polynomial time for items (i) and (iii). Moreover, asT is finite, item (ii) can also be verified in polynomial time by solving LP(K(cid:4)(cid:4) ∪ {a})., a polynomial size witness for the complement of the problem of deciding if K(cid:4)such that (i) K(cid:4)(cid:4)(Hardness) We show a LOGSPACE reduction from the Maximum Cardinality Subset Sum (MCSS) (see Definition 29 inAppendix A) problem to our problem. Lemma 1 states that MCSS is coNP-hard.We construct an instance (cid:25)K, ra, K(cid:4)(cid:28) of our problem starting from instance (cid:25)S = {s1, . . . , sn}, c, SLet S = {p1, . . . , pn, pn+1}, ID finite such that {id1, id2} ⊆ ID, T a finite set of time points which includes t0, d O (id1, id2) =si ∈S si .d O (id2, id1) = 1 and for all idi, id j ∈ ID such that i and j are different from 1 and 2, d O (idi, id j) = n + 1, and Tot =(cid:4)(cid:28) of MCSS as follows.(cid:2)Observe that MCSS is still coNP-hard if c (cid:7)= Tot/2. We consider this case in our proof.Assume that RD = ∅. We define an instance (cid:25)K, ra, K(cid:4)(cid:28) of the problem as follows:• K = {loc(id1, {pi}, t0)[ si• a = loc(id1, {p1, . . . , pn}, t0)[ c• K(cid:4) = {loc(id1, {pi}, t0)[ siTot , siTot , siTotTot] | si ∈ S} ∪ {loc(id2, {p1, . . . , pn}, t0)[1 − c],Tot , cTot] | si ∈ S(cid:4)} ∪ {loc(id2, {pi}, t0)[ siTot , siTotTot , 1 − cTot]},] | si ∈ S \ S(cid:4)} ∪ {loc(id2, {p1, . . . , pn}, t0)[1 − cTot , 1 − cTot]}.We prove by contraposition that S(cid:4)is a maximum cardinality subset of S which sums up exactly to c iff K(cid:4)is an optimalobject id revision of K.(⇒) Assume that K(cid:4)is not an optimal object id revision of K. Then there is K(cid:4)(cid:4)such that (i) K(cid:4)(cid:4)(cid:2)is a object id revision(cid:2)si ∈S\S(cid:4)(cid:4) d O (id1, id2) =si ∈S\S(cid:4)(cid:4) 1 =of K; (ii) K(cid:4)(cid:4) ∪ {ra} is consistent; and (iii) d O (K, K(cid:4)(cid:4)) < d O (K, K(cid:4)).be the set of si ∈ S such that (id1, {pi}, t0, [ siLet S]) ∈ K(cid:4)(cid:4)(cid:4)(cid:4)n − |S(cid:4)(cid:4)| and d O (K, K(cid:4)(cid:4)) < d O (K, K(cid:4)) = n − |S(cid:2)Tot , si(cid:4)(cid:4)| < n − |Ssi ∈S(cid:4)(cid:4) si = c. As K(cid:4)(cid:4) ∪ {ra} is consistent,(cid:4)|, n − |STotWe now show that(cid:3). As d O (K, K(cid:4)(cid:4)) =(cid:4)(cid:4)| > |S(cid:4)|.(cid:4)|, thus |SsiTot(cid:2) cTot.]∈K(cid:4)(cid:4)loc(id1,{pi },t0)[ si(cid:2)Tot , siTotThus,Tot , 1 − ccto cTotsi ∈S(cid:4)(cid:4) si (cid:2) c. Moreover, since c (cid:7)= Tot/2, for every object id revision of K, the id of atom {loc(id2, {p1, . . . , pn}, t0)[1 −]} cannot be changed into id1, because it would be inconsistent with ra, which requires a probability mass equalTot in the same locations and at the same time point. As K(cid:4)(cid:4)contains {loc(id2, {p1, . . . , pn}, t0)[1 − cTot , 1 − cTot]},(cid:3)siTot(cid:2) 1 − cTot.]∈K(cid:4)(cid:4)loc(id2,{pi },t0)[ si(cid:2)Tot , sisi ∈S\S(cid:4)(cid:4) si (cid:2) Tot − c. AsTot(cid:2)(cid:2)(cid:2)Thus,si ∈S(cid:4)(cid:4) si (cid:2) c, we obtainshown thatcardinality subset of S which sums up exactly to c.(⇐) Assume now that S(cid:2)si ∈S(cid:4)(cid:4) si = Tot −such that |S|(cid:4)(cid:4) > |S(cid:4)| and(cid:4)(cid:4)} ∪ {loc(id2, {pi}, t0)[ siTot , siSK(cid:4)(cid:4) ∪ {ra} is consistent. Since d O (K, K(cid:4)(cid:4)) = n − |SThus K(cid:4)is not an optimal object id revision of K. (cid:2)Tot(cid:2)(cid:2)si ∈S\S(cid:4)(cid:4) si , the latter implies thatsi ∈S(cid:4)(cid:4) si = c. Since we have further shown that |Ssi ∈S(cid:4)(cid:4) si (cid:4) c. Since we have alreadyis not a maximum(cid:4)(cid:4)| > |S(cid:4)|, S(cid:4)(cid:4)is not a maximum cardinality subset of S which sums up exactly to c. Then, there is Ssi ∈S(cid:4)(cid:4) si = c. Let K(cid:4)(cid:4)Tot , si] | si ∈ S \ Sbe the following object id revision of K. K(cid:4)(cid:4) = {loc(id1, {pi}, t0)[ si(cid:2)(cid:4)(cid:4) ⊆ S] | si ∈si ∈S(cid:4)(cid:4) si = c, it is easy to see that(cid:4)|, we have d O (K, K(cid:4)(cid:4)) < d O (K, K(cid:4)).(cid:4)(cid:4)} ∪ {loc(id2, {p1, . . . , pn}, t0)[1 − c(cid:4)(cid:4)| and d O (K, K(cid:4)) = n − |STot , 1 − c]}. AsTot(cid:4)| and |S|(cid:4)(cid:4) > |STotCorollary 2. Given PST atom ra, and PST KBs K, K(cid:4)where T is finite, deciding whether K(cid:4) = K ˙+o ra is coNP-complete.Proof. (Membership) A polynomial size witness for the complement of the problem of deciding if K(cid:4) = K ˙+o ra is ansuch that K(cid:4)(cid:4) ∪ {ra} is consistent and either d O (K, K(cid:4)(cid:4)) < d O (K, K(cid:4)) or d O (K, K(cid:4)(cid:4)) = d O (K, K(cid:4)) and K(cid:4)(cid:4)object id revision K(cid:4)(cid:4)precedes K according the strict total order O T . As in the case of the membership proof of Theorem 9, this witness can beverified in polynomial time.(Hardness) Consider the proof of Theorem 9 and let O T be such that, for d O (K, K(cid:4)) = |S| − |S(cid:4)|, K(cid:4)is its minimumelement. Then, reasoning as in the proof of Theorem 9, it is easy to see that (S, c, S(cid:4)) is in MCSS iff K(cid:4) = K ˙+o ra. (cid:2)J. Grant et al. / Artificial Intelligence 174 (2010) 72–104103Theorem 10. Let K be any knowledge base. A lower bound revision of K satisfying the AGM axioms is possible for every atom ra iff forall ai ∈ K, ui = 1.Proof. (⇐) Assume that all ui = 1. Then lowering all (cid:2)i to 0 yields a lower bound revision satisfying the AGM axioms.(⇒) Suppose that for some ai ∈ K, ai = loc(id, ri, t)[(cid:2)i, ui] and ui (cid:7)= 1. Let ra = loc(id, ri, t)[1, 1]. There is no lower boundrevision. (cid:2)Proposition 4. K (cid:3)p ra satisfies (A1)–(A6).Proof. Axiom (A1) follows from the fact that there is always a solution to PRLP(K) — consider the solution that sets alllowi to 0 and all upi to 1. (A2) follows from the inequalities specified in 2(a) of PRLP. Axiom (A3) follows from the fact thatupper bounds are increased and lower bounds are decreased (according to the inequalities in 1(c) of PRLP), loosening theknowledge base such that any interpretation satisfying K ∪ {ra} must also satisfy K (cid:3)p ra. Axiom (A4) follows from the factthat the minimum value possible for the distance function occurs when there is no change to the knowledge base. Thus ifat all possible, the algorithm returns the original values for the lower and upper bounds of the knowledge base making theupdated knowledge base equal to the original knowledge base. Axiom (A5) follows from the fact that any solution to PRLPcorresponds to a consistent knowledge base. Consider if θ is a solution to PRLP(K, ra). θ (minus any assignments to the(cid:4)variables lowi and upi ) is also a solution to LP(K (cid:3)p ra). Axiom (A6) follows from the use of the strict total order. If ra ≡ ra,(cid:4)). Thus the minimal member of both sets ofthen the solutions to PRLP(K, ra) will be exactly the solutions to PRLP(K, rasolutions will be the same according to the strict total order and the same revised knowledge base will be returned. (cid:2)Theorem 11. Given a PST atom ra, and PST KBs K, K(cid:4)where T is finite, deciding whether K(cid:4) ∪ {ra} = K ˙+h ra is coNP-complete.Proof. (Membership) A polynomial size witness for the complement of the problem of deciding whether K(cid:4) = K ˙+h ra isa hybrid revision K(cid:4)(cid:4)such that K(cid:4)(cid:4) ∪ {ra} is consistent and either dH (K, K(cid:4)(cid:4)) < dH (K, K(cid:4)) or dH (K, K(cid:4)(cid:4)) = dH (K, K(cid:4)) andK(cid:4)(cid:4)precedes K according the strict total order O T . By the finiteness of T , the consistency of K(cid:4)(cid:4) ∪ {ra} can be verified inpolynomial time by solving LP(K(cid:4)(cid:4) ∪ {ra}). Moreover, conditions regarding the minimality w.r.t. dH ( ) and O T can also beverified in polynomial time.(Hardness) It is easy to see that the coNP-hard problem of checking whether K(cid:4) = K ˙+o ra can be reduced to the problemof deciding whether K(cid:4) = K ˙+h ra by defining dH ( ) so that, w S = w T = w P = ∞ and w O (cid:7)= ∞. (cid:2)Theorem 12. Let K = {ai | ai = loc(idi, ri, ti)[(cid:2)i, ui]}, and ra = loc(idr, rr , tr)[(cid:2)r, ur], the revision atom. θ is an optimal solution of theoptimization problemminimize the objective function(cid:3)(cid:11) (cid:3)(cid:12)(cid:11) (cid:3)(cid:3)ˆidij· d O (idi, id j)+ w S(cid:12)(cid:12)ˆrij· dS (ri, r j)(cid:12)r j ∈regions(ai )ˆtij· dT (ti, t j)+ w P((cid:2)i − lowi) + (upi− ui)ai ∈K(cid:11) (cid:3)ai ∈Kw Oai ∈Kid j ∈ID(cid:11) (cid:3)(cid:3)+ w Tai ∈Kt j ∈Tsubject toHRLP(K, ra)iff βθ (K) is an optimal hybrid revision of K by adding ra.Proof. By contraposition.(cid:4)i= tk, and ˆrii, u= id j , ˆti(cid:4)= rm. The constraints in (3) in Definition 22 are clearly satisfied. Moreover, if idisuch that K(cid:4) ∪ {ra} is consistent and dH (K, βθ (K)) > dH (K, K(cid:4)). Let K(cid:4) = {afor HRLP(K, ra) such that, ∀ai ∈ K, ∀id j ∈ ID, ∀tk ∈ T , and ∀rm ∈ regions(ai),mθ (cid:4) = 1 iff r(cid:2)(⇒) Suppose that θ is a solution for HRLP(K, ra) and βθ (K) is not an optimal hybrid revision of K by adding ra. Thus,]}. Constructkθ (cid:4) = 1 iff== id j ∧ t= rm is false, then equations (2) in Definition 22 are trivially satisfied by every solution of HRLP(K, ra), since theyq∈S v id j ,tk,p,q (cid:2) U with [L, U ] ⊇ [0, 1]. The non-trivial constraints of type (2) are those such that= rm, obtaining lowi (cid:2), Definition 22 isfor PRLP(K(cid:4), ra) such that for each a∈ K(cid:4),is a solution of HRLP(K, ra) such that βθ (cid:4) (K) = K(cid:4).(cid:4)) and dH (K, βθ (K)) >there is K(cid:4)solution θ (cid:4)(cid:4)ti(cid:4)tk ∧ ribecome L (cid:2)(cid:4)(cid:4)= id j ∧ tidiiequivalent to PRLP(K(cid:4), ra). As K(cid:4) ∪ {ra} is consistent, there is a solution θ (cid:4)(cid:4)lowiθ (cid:4)(cid:4) = (cid:2)(cid:4)As dH (K, K(cid:4)) =a∈K w O · d O (a, adH (K, K(cid:4)), dH (K, βθ (K)) > dH (K, βθ (cid:4) (K)), i.e., θ is not an optimal solution for HRLP(K, ra).q∈S v id j ,tk,p,q (cid:2) ui . Thus for the fixed solution θ (cid:4)(cid:4)(cid:4)= loc(idi, ti, rˆijθ (cid:4) = 1 iff idid(cid:4)i . Thus, θ (cid:4)(cid:4)) + w S · dS (a, ai . Let lowiθ (cid:4) = (cid:2)(cid:4)(cid:2)i , and upiθ (cid:4)(cid:4) = u(cid:2)i and upiθ (cid:4) = u(cid:4)) + w P · d P (a, a(cid:4)) + w T · dT (a, ap∈rm= tk ∧ ra∈K dH (a, ai)[(cid:2)(cid:4)(cid:4)) =p∈rm(cid:2)(cid:2)(cid:2)(cid:4)i(cid:4)i(cid:4)i(cid:4)i(cid:4)i(cid:4)i(cid:4)(cid:4)104J. Grant et al. / Artificial Intelligence 174 (2010) 72–104(⇐) Suppose that βθ (K) is a hybrid revision of K by adding ra and θ is not an optimal solution for HRLP(K, ra). Thusthere is a solution θ (cid:4)of HRLP(K, ra) such that dH (K, βθ (K)) > dH (K, βθ (cid:4) (K)). Reasoning similarly to the previous case, itis easy to see that βθ (cid:4) (K) ∪ {ra} is consistent and since dH (K, βθ (K)) > dH (K, βθ (cid:4) (K)) this implies that βθ (K) is not anoptimal hybrid revision. (cid:2)Proposition 5. If the associated reachability definition is fully connected, then for (P t0 , Pt1 ) returned by Algorithm 3, for all P ∈ Pt0(cid:4) ∈ Pt0 such that P cautiously reachesthere is PPin time t1 − t0 and for all P ∈ Pt1 there is P(cid:4) ∈ Pt1 such that P cautiously reaches Pin time t1 − t0.(cid:4)(cid:4)(cid:7) and Pt1Proof. The proof follows from the fact that each line in Algorithm 3 maintains the invariant that every partition in P t0(cid:7)marked “done” cautiously reaches at least one partition in P t1(cid:7) marked “done” is cautiouslyreached by at least one partition in P t0(cid:7) . We can be sure that eventually the algorithm will complete because eventuallyPt0(cid:7) will contain only singleton partitions, where each partition represents only one point. In this degenerate case,the cautious reachability predicate equals the underlying reachability predicate, which is fully connected by assumption.Therefore every point and the associated partition in P t0(cid:7) , andevery point and the associated partition in P t1(cid:7) . Line 22(cid:7)guarantees that eventually, either the degenerate case will eventually occur or all partitions will be marked “done”. (cid:2)(cid:7) can reach some other point and its associated partition in P t1is reached by some other point and its associated partition in P t0(cid:7) and every partition in Pt1References[1] C.E. Alchourrón, P. Gärdenfors, D. Makinson, On the logic of theory change: Partial meet contraction and revision functions, Journal of Symbolic Logic 50(1985) 510–530.[2] A. Aziz, K. Sanwal, V. Singhal, R.K. Brayton, Verifying continuous time Markov chains, in: Proceedings of the 8th International Conference on ComputerAided Verification, Springer-Verlag, London, UK, 1996, pp. 269–276.[3] C. Baral, S. Kraus, J. Minker, V.S. Subrahmanian, Combining knowledge bases consisting of first-order theories, Computational Intelligence 8 (1) (1992)45–71.[4] B. Bennett, Modal logics for qualitative spatial reasoning, Journal of the Interest Group on Pure and Applied Logic 4 (1996) 23–45.[5] A.G. Cohn, S.M. Hazarika, Qualitative spatial representation and reasoning: An overview, Fundam. Inf. 46 (1–2) (2001) 1–29.[6] Dana Nau, Fusun Yaman, V.S. Subrahmanian, The logic of motion, in: Proc. 9th International Conference on the Principles of Knowledge Representationand Reasoning (KR-2004), 2004, pp. 85–94.[7] Dana Nau, Fusun Yaman, V.S. Subrahmanian, Going far, logically, in: Proc. IJCAI 2005, 2005, pp. 615–620.[8] Dana Nau, Fusun Yaman, V.S. Subrahmanian, A motion closed world assumption, in: Proc. IJCAI 2005, 2005, pp. 621–626.[9] A.G. Cohn, D. Magee, A. Galata, D. Hogg, S. Hazarika, Towards an architecture for cognitive vision using qualitative spatio-temporal representations andabduction, in: C. Freksa, C. Habel, K.F. Wender (Eds.), Spatial Cognition III, in: Lecture Notes in Computer Science, vol. 2685, Springer-Verlag, 2003.[10] David Gabelaia, Roman Kontchakov, Agi Kurucz, Frank Wolter, Michael Zakharyaschev, On the computational complexity of spatio-temporal logics, in:FLAIRS Conference, 2003, pp. 460–464.[11] H. Hansson, B. Jonsson, Logic for reasoning about time and reliability, Formal Asp. Comput. 6 (5) (1994) 512–535.[12] S.O. Hansson, Knowledge-level analysis of belief base operations, Artificial Intelligence 82 (1) (1996) 215–235.[13] Samir Khuller, Maria Vanina Martinez, Dana Nau, Gerardo Simari, Amy Sliva, V.S. Subrahmanian, Computing most probable worlds of action probabilis-tic logic programs: Scalable estimation for 1030,000 worlds, Annals of Mathematics and Artificial Intelligence 51 (2–4) (2007) 295–331.[14] M. Kwiatkowska, G. Normal, D. Parker, Prism: Probabilistic symbolic model checker, in: Computer Performance Evaluation: Modelling Techniques andTools, in: Lecture Notes in Computer Science, vol. 2324, Springer-Verlag, 2002, pp. 113–140.[15] L.G. Khachiyan, A polynomial algorithm in linear programming, Soviet Mathematics Doklady 20 (1979) 191–194.[16] Stephan Merz, Martin Wirsing, Júlia Zappe, A spatio-temporal logic for the specification and refinement of mobile systems, in: Mauro Pezzè (Ed.), FASE,in: Lecture Notes in Computer Science, vol. 2621, Springer, 2003, pp. 87–101.[17] R. Mittu, R. Ross, Building upon the coalitions agent experiment (coax) — integration of multimedia information in gccs-m using impact, in: Intl. Conf.on Multimedia Information Systems, 2003, pp. 35–44.[18] Philippe Muller, Space–time as a primitive for space and motion, in: FOIS, IOS Press, Amsterdam, June 1998, pp. 63–76.[19] Christos M. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.[20] A.J. Parker, V.S. Subrahmanian, J. Grant, A logical formulation of probabilistic spatial databases, IEEE TKDE 19 (11) (2007) 1541–1556.[21] A.J. Parker, V.S. Subrahmanian, J. Grant, Spot databases: Efficient consistency checking and optimistic selection in probabilistic spatial databases, IEEETKDE 21 (1) (2009) 92–107.[22] Austin Parker, Spatial probabilistic temporal databases, PhD thesis, University of Maryland, 2008.[23] Austin Parker, Guillaume Infantes, John Grant, V.S. Subrahmanian, An agm-based belief revision mechanism for probabilistic spatio-temporal logics, in:AAAI, 2008.[24] Austin Parker, Fusun Yaman, Dana Nau, V.S. Subrahmanian, Probabilistic go theories, in: Proceedings of the International Joint Conference on ArtificialIntelligence (IJCAI), January 2007, pp. 501–506.[25] R. Rajagopalan, B. Kuipers, Qualitative spatial reasoning about objects in motion: Application to physics problem solving, in: IJCAI’94, San Antonio, TX,1994, pp. 238–245.[26] D. Cohn, A. Randell, Z. Cui, A spatial logic based on regions and connection, in: KR199: International Conference on Knowledge Representation andReasoning, Morgan Kaufmann, 1992, pp. 165–176.[27] H. Samet, Foundations of Multidimensional and Metric Data Structures, Morgan Kaufman, 2006.[28] Murray Shanahan, Default reasoning about spatial occupancy, Artif. Intell. 74 (1) (1995) 147–163.[29] Finnegan Southey, Wesley Loh, Dana F. Wilkinson, Inferring complex agent motions from partial trajectory observations, in: IJCAI, 2007, pp. 2631–2637.[30] B. Yetso, T. Hammel, T.J. Rogers, Fusing live sensor data into situational multimedia views, in: Proc. 2003 Intl. Conf. on Multimedia Information Systems,2003, pp. 145–146.[31] Frank Wolter, Michael Zakharyaschev, Spatial reasoning in rcc-8 with boolean region terms, in: ECAI2000: Principles of Knowledge Representation andReasoning, IOS Press, Berlin, 2000, pp. 244–248.[32] Frank Wolter, Michael Zakharyaschev, Spatio-temporal representation and reasoning based on RCC-8, in: Anthony G. Cohn, Fausto Giunchiglia, BartSelman (Eds.), KR2000: Principles of Knowledge Representation and Reasoning, Morgan Kaufmann, San Francisco, 2000, pp. 3–14.