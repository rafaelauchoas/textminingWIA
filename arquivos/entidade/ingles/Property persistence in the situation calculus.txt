Artificial Intelligence 174 (2010) 865–888Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintProperty persistence in the situation calculusRyan F. Kelly, Adrian R. Pearce∗Department of Computer Science and Software Engineering, The University of Melbourne, Victoria 3010, Australiaa r t i c l ei n f oa b s t r a c tArticle history:Received 25 May 2009Received in revised form 6 May 2010Accepted 6 May 2010Available online 8 May 2010Keywords:Situation calculusAutomated reasoningProperty persistence1. IntroductionWe develop a new automated reasoning technique for the situation calculus that canhandle a class of queries containing universal quantification over situation terms. Althoughsuch queries arise naturally in many important reasoning tasks, they are difficult toautomate in the situation calculus due to the presence of a second-order induction axiom.We show how to reduce queries about property persistence, a common type of universally-quantified query, to an equivalent form that does not quantify over situations and so isamenable to existing reasoning techniques. Our algorithm replaces induction with a meta-level fixpoint calculation; crucially, this calculation uses only first-order reasoning with alimited set of axioms. The result is a powerful new tool for verifying sophisticated domainproperties in the situation calculus.© 2010 Elsevier B.V. All rights reserved.The situation calculus is one of the most popular and influential AI formalisms for reasoning about action and change,having found application in a wide variety of both theoretical and practical works [5,6,9,26,27,30]. A major contributorto the success of the formalism is that it combines a powerful modelling language built on first-order logic with easilyimplementable techniques for effective automated reasoning.A key challenge when working with the situation calculus is managing this balance between expressivity and effective-ness. An induction axiom is used to define the structure of situation terms, so answering arbitrary queries requires reasoningin second-order logic. While certain special cases are known to be decidable [31], such reasoning is prohibitively expensivein general [24].If queries are restricted to certain syntactic forms, it is possible to obtain much more effective reasoning procedures –for example, queries restricted to existential quantification over situations can be answered using only first-order logic [23],while queries containing only ground situation terms permit special-purpose techniques such as regression [26].However, there are many important reasoning tasks that require universal quantification over situations, for which thesituation calculus currently offers no effective reasoning tools. One simple example is the problem of goal impossibility –establishing that all possible situations fail to satisfy a goal. In this paper we study a subset of universally-quantified querieswhich we refer to as property persistence queries: under a particular situation calculus theory D, and given some formula φand situation σ , determine whether φ will hold in all situations in the future of σ :D |(cid:3) ∀s: σ (cid:5) s → φ[s]The need for second-order logic has traditionally limited automated reasoning about such queries. We introduce a newapproach to property persistence that is similar in spirit to the standard regression operator, by defining a meta-level* Corresponding author. Tel.: +613 8344 1399; fax: +613 9348 1184.E-mail addresses: rfk@csse.unimelb.edu.au (R.F. Kelly), adrianrp@unimelb.edu.au (A.R. Pearce).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.05.003866R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888operator PD such that φ persists at σ if and only if PD(φ) holds at σ . We term the resulting formula the persistencecondition of φ and show how to calculate it as a fixpoint of applications of an operator based on regression; crucially, thiscalculation requires only first-order logic and a limited set of axioms. The persistence condition is also guaranteed to be ina form amenable to existing automated reasoning techniques.Importantly, our results do not require restrictions on the domain theory D – they are generally applicable to the fullfirst-order situation calculus, and are based purely on standard first-order reasoning techniques.The result is a powerful new technique for exploring sophisticated domain properties in the situation calculus. It allowssome second-order aspects of the theory to be “factored out” and handled using a special-purpose algorithm. The techniqueis always sound, and we show that it is complete for important standard variants of the situation calculus. Perhaps mostimportantly, it builds upon and integrates well with standard techniques for effective automated reasoning, so our techniqueis directly applicable to existing theories and systems based on the situation calculus.A preliminary version of this paper has previously appeared as [15]; this revised edition includes extended and additionalproofs, a more comprehensive discussion of the termination properties of our algorithm, and a detailed example of how thepersistence condition can be used to reason about goal impossibility – a deceptively simple task which is nonethelessbeyond the reach of existing reasoning techniques.The paper now proceeds with a brief review of the situation calculus, before formally defining the persistence conditionand establishing its effectiveness as a reasoning tool. Readers familiar with the situation calculus are encouraged to reviewthe background material in Sections 2 and 4, as we make several small modifications to the standard notation that greatlysimplify the development of our approach: the unique names axioms Duna are incorporated into a general backgroundtheory Dbg ; the Poss fluent is subsumed by a general class of action description predicates defined in Dad; we parameterisethe “future situations” predicate s (cid:2) s; and weuse the single-step variant of the regression operator, with corresponding definitions of regressable formulae.to assert that all intermediate actions satisfy a given predicate using s <α s(cid:7)(cid:7)2. The situation calculusThe situation calculus is a powerful formalism for describing and reasoning about dynamic worlds. It was first introducedby McCarthy and Hayes [22] and has since been significantly expanded and formalised [23,26]. We use the particular variantdue to Reiter et al. at the University of Toronto, sometimes called the “Toronto school” or “situations-as-histories” version.The formalisation below is based on the standard definitions from [16,23,25], with some simple modifications.The language Lsitcalc of the situation calculus is a many-sorted language of second-order logic with equality, containingthe following disjoint sorts:• Action terms denote individual instantaneous events that can cause the state of the world to change;• Situation terms are histories of the actions that have occurred in the world, with the initial situation represented by S 0and successive situations built using the function do : Action × Situation → Situation;• Object terms represent any other object in the domain.Fluents are predicates representing properties of the world that may change between situations, and so take a situationterm as their final argument. Predicates and functions that do not take a situation term are called rigid. We use the termprimitive fluent to describe fluents that are directly affected by actions, rather than being defined in terms of other fluents.No functions other than S0 and do produce values of sort Situation. For the sake of clarity we will not consider functionalfluents in this paper; this is a common simplifying assumption in the situation calculus literature and does not result in aloss of generality.Lsitcalc contains the standard alphabet of logical connectives, constants (cid:8) and ⊥, countably infinitely many variables ofeach sort, countably infinitely many predicates of each arity, etc.; for a complete definition, consult the foundational paperby Pirri and Reiter [23]. We follow standard naming conventions for the situation calculus: upper-case roman names indicateconstants; lower-case roman names indicate variables; Greek characters indicate meta-variables or formula templates. Allaxioms universally close over their free variables at outermost scope. The notation ¯t indicates a vector of terms of context-appropriate arity and type. The connectives ∧, ¬, ∃ are taken as primitive, with ∨, →, ≡, ∀ defined in the usual manner.Complex properties of the state of the world are represented using uniform formulae. These are basically logical combi-nations of fluents referring to a common situation term.Definition 1 (Uniform formulae). Let σ be a fixed situation term, R i an arbitrary rigid predicate, F i an arbitrary primitivefluent predicate, τi an arbitrary term that is not of sort Situation, and xi an arbitrary variable that is not of sort Situation.Then the formulae uniform in σ are the smallest set of syntactically-valid formulae satisfying:φ ::= F i( ¯τi, σ ) | R i( ¯τi) | τi = τ j | φi ∧ φ j | ¬φ | ∃xi: φWe will call a formula uniform if it is uniform in some situation. The important aspect of this definition is that theformula refers to no situation other than σ , which appears as the final argument of all fluents in the formula. In particular,uniform formulae cannot quantify over situations or compare situation terms, and cannot contain non-primitive fluents.R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888867The meta-variable φ is used throughout to refer to an arbitrary uniform formula. The notation φ[s(cid:7)] represents a uniformformula with the particular situation sinserted into all its fluents, replacing whatever situation term was previously there.Note that this is simply a syntactic shorthand designed to keep the presentation clean and readable – it is not an operationfrom the logic itself.(cid:7)The dynamics of a particular domain are captured by a set of sentences called a basic action theory. Queries about thebehaviour of the world are posed as logical entailment queries relative to this theory.Definition 2 (Basic action theory). A basic action theory, denoted D, is a set of situation calculus sentences (of the specificsyntactic form outlined below) describing a particular dynamic world. It consists of the following disjoint sets: the founda-tional axioms of the situation calculus (Σ ); action description axioms defining various aspects of action performance, suchas preconditions (Dad); successor state axioms describing how primitive fluents change between situations (Dssa); axiomsdescribing the value of primitive fluents in the initial situation (DS0 ); and axioms describing the static background facts ofthe domain (Dbg ):D = Σ ∪ Dad ∪ Dssa ∪ DS0∪ DbgThese axioms must satisfy some simple consistency criteria in order to constitute a valid domain description [23]. Thisis a straightforward modification of the standard definition of a basic action theory, intended to simplify the details of ourforthcoming development.The axiom set DS0 is a collection of sentences uniform in S0 that describe the initial state of the world, while the setDbg contains all the situation-independent facts about the domain. Standard notation includes situation-independent factsin DS0 , but our upcoming definitions require that they be separate. Dbg includes the standard unique names axioms foractions [23].The axiom set Dssa contains one successor state axiom for each primitive fluent in the domain, providing a monotonicsolution to the frame problem for that fluent. They have the following form, where Φ is uniform in s:(cid:2)(cid:3)¯x, do(a, s)F≡ ΦF (¯x, a, s)The axiom set Dad defines fluents that describe various aspects of the performance of an action, which we call actiondescription predicates. For each such predicate ADP(¯x, a, s) the set Dad contains a single axiom of the following form, whereΠADP is uniform in s:ADP(¯x, a, s) ≡ ΠADP(¯x, a, s)The canonical example of an action description predicate is the precondition predicate Poss(a, s), which indicates whetherit is possible to perform an action in a given situation. In principle there can be any number of predicates or functionsdefined in a similar way – a common example is the function SR used to axiomatise sensing actions in [29]. We willhenceforth use the meta-predicate α to denote an arbitrary action description predicate.Note that this is a departure from the standard notion, where a separate axiom specifies the preconditions for eachfunction of sort Action [23]. The single-axiom approach used here embodies a domain closure assumption on the Actionsort, and is necessary when reasoning about formulae that universally quantify over actions [28,34].We will sometimes write the definition of an action description predicate in terms of other previously-defined actiondescription predicates. This is purely a notational convenience; the definitions in Dad must use primitive fluents only.The foundational axioms Σ ensure that situations form a branching-time account of the world state. There is a distin-guished situation term S0 called the initial situation, and situations in general form a tree structure with S 0 at the root anddo(a, s) constructing the situation that results from performing action a in situation s. We abbreviate the performance ofseveral successive actions by writing:(cid:2)(cid:2)def= doan, do(cid:2)do(cid:3)(cid:3)(cid:3)[a1 . . . an], s(cid:7)The relation s (cid:2) s. . . , do(a1, s)(cid:7)indicates that sis in the future of s:¬(s (cid:2) S0)(cid:2)s (cid:2) doa, s(cid:3)(cid:7)≡ s (cid:5) s(cid:7)(cid:7)Here s (cid:5) sis the standard abbreviation for s (cid:2) s. This notation for “in the future of” can be extended to consideronly those futures in which all actions satisfy a particular action description predicate. We include a relation <α for eachaction description predicate α, with the following definitions:(cid:7) ∨ s = s(cid:7)¬(s <α S0)(cid:2)a, ss <α do(cid:3)(cid:7)≡ s (cid:2)α s(cid:7) ∧ α(cid:3)(cid:2)a, s(cid:7)868R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888For example, by stating that s <Poss sbetween s and sthe action and situation arguments of the action description predicate in order to simplify the presentation.in the future of s, but that all actions performedwere actually possible; this is equivalent to the < operator of Pirri and Reiter [23]. Note that we suppresswe assert that not only is s(cid:7)(cid:7)(cid:7)Finally, a second-order induction axiom is used to assert that all situations must be constructed by performing a finitesequence of actions:(cid:4)∀P :P (S0) ∧ ∀s, a:(cid:2)P (s) → P(cid:2)(cid:3)(cid:3)(cid:5)do(a, s)→ ∀s: P (s)This axiom is the only second-order sentence in a basic action theory, and is vital to the proper semantics of statementsthat universally quantify over situation terms [24].3. Property persistence queriesWith this notation in hand, let us now formally define the kinds of query that are of interest in this paper. Given someuniform formula φ and situation σ , a property persistence query asks whether φ will hold in all situations in the future of σ :D |(cid:3) ∀s: σ (cid:5) s → φ[s]More generally, one may wish to limit the futures under consideration to those brought about by actions satisfying acertain predicate α, which is easily accomplished using the (cid:2)α relation. We thus have the following definition of a propertypersistence query:Definition 3 (Property persistence query). Let φ be a uniform formula, α an action description predicate, and σ a situationterm. Then a property persistence query is a query of the form:D |(cid:3) ∀s: σ (cid:2)α s → φ[s]If the query contains free variables, we treat them as universally quantified at outermost scope.In words, a persistence query states that “φ holds in σ , and assuming all subsequent actions satisfy α, φ will continue tohold”. For succinctness we will henceforth describe this as “φ persists under α”. Such queries are involved in many usefulreasoning tasks; the following are a small selection:Goal impossibility. Given a goal G, establish that there is no legal situation in which that goal is achieved:D |(cid:3) ∀s: S0 (cid:2)Poss s → ¬G(s)Goal futility. Given a goal G and situation σ , establish that the goal cannot be achieved in any legal future of σ :D |(cid:3) ∀s: σ (cid:2)Poss s → ¬G(s)Note how this differs from goal impossibility: while the goal may have initially been achievable, subsequent actions haverendered the goal unachievable. Detecting and avoiding such situations could be a very important task.Checking state constraints. Given a state constraint SC, show that the constraint holds in every legal situation:D |(cid:3) ∀s: S0 (cid:2)Poss s → SC(s)This can be seen as a variant of goal impossibility, by showing that the constraint can never be violated.Need for cooperation. Given an agent agt, goal G and situation σ , establish that no sequence of actions performed by thatagent only can achieve the goal. Suppose we define MyAction to identify the agent’s own actions:MyAction(a, s) def= actor(a) = agtThen the appropriate query is:D |(cid:3) ∀s: σ (cid:2)MyAction s → ¬G(s)If this is the case, the agent will need to seek cooperation from another agent in order to achieve its goal.R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888869Knowledge with hidden actions. Consider an agent reasoning about its own knowledge in a multi-agent domain, where theother agents can perform “hidden” actions that it is unable to observe. To reason correctly in such asynchronous domains,the agent must take into account arbitrarily-long sequences of hidden actions [14,32].For example, suppose an agent can only observe actions if they occur in the same room as it and the lights are on:(cid:2)Hidden(a, s) def= InSameRoomactor(a), agt, s(cid:3)∧ LightsOn(s)Intuitively, to establish that it knows φ the agent must establish that φ cannot become false through a sequence ofhidden actions:D |(cid:3) ∀s: σ (cid:2)Hidden s → φ[s]Here σ (cid:2)Hidden s denotes that a sequence of possible, but hidden, actions was performed by other agents between σ and s.The “gold thief” domain. As a more detailed example, which we will revisit in Section 7, consider a domain in which athief may try to steal some gold from a safe. There is a light in the room, and a security camera that will detect the thief’sactions as long as the light is on. The safe can be open or closed, but the gold can only be stolen if the safe is open. It ispossible for the thief to crack the safe and force it open, but only if the light is on.The actions in this domain are takeGold, crackSafe and toggleLight, the primitive fluents are SafeOpen, LightOn and Stolen,and the action description predicates include the standard Poss(a, s) and a custom predicate Undet(a, s) indicating thataction a would not be detected by the security camera. The complete axioms can be found in Appendix B.As the owners of the gold, we would like to ensure that the thief cannot steal it. Unfortunately this is not possible, asnothing prevents him from simply cracking the safe and taking the gold. We can, however, ensure that the thief cannotsteal the gold undetected. Formally, we want to establish that “no sequence of undetected actions results in the gold beingstolen”:D |(cid:3) ∀s: S0 (cid:2)Undet s → ¬Stolen(s)(1)Intuitively, this will be the case as long as the gold is not already stolen, and either the light is on (so the thief’s actionswill be detected) or the safe is closed (so the thief must switch on the light to crack it):Dbg ∪ DS0|(cid:3) ¬Stolen(S0) ∧(cid:5)(cid:4)¬SafeOpen(S0) ∨ LightOn(S0)(2)A manual proof that (1) iff (2) is straightforward, but it is beyond the reach of the standard automated reasoning tools ofthe situation calculus. The difficulty, as we shall explore in the next section, stems from the use of a second-order inductionaxiom to define the set of all situations.4. Effective reasoningAn important feature of the situation calculus is the existence of effective reasoning procedures for certain types ofquery. In the general case, answering a query about a basic action theory D is a theorem-proving task in second-order logic(denoted SOL) due to the induction axiom:D |(cid:3)SOL ψThis is clearly problematic for effective automated reasoning. Fortunately, restricting the syntactic form of queries canallow us to discard some axioms from D and make automated reasoning easier.A core result of Pirri and Reiter [23] is that if a query performs only existential quantification over situations, then it canbe answered without the induction axiom (denoted I ) and thus using only first-order logic (FOL):D |(cid:3)SOL ∃s: ψ(s)iffD − {I} |(cid:3)FOL ∃s: ψ(s)While this is a substantial improvement over requiring a second-order theorem prover, it is still far from an effectivetechnique. Effective reasoning requires that the set of axioms be reduced as much as possible.In their work on state constraints, Lin and Reiter [19] show how to reduce the task of verifying a state constraint to areasoning task we call static domain reasoning, where only the background axioms need to be considered:Dbg |(cid:3)FOL ∀s: φ[s]Since the axioms in Dbg do not mention situation terms, the leading quantification in such queries has no effect – φwill hold for all s if and only if it holds for some s. This is an important result because it is usually not valid to drop the870R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888induction axiom for queries that universally quantify over situations. Their work has shown that this can be circumventedin some cases.Simpler still are queries uniform in the initial situation, which can be answered using only first-order logic and a limitedset of axioms:D |(cid:3)SOL φ[S0]iff∪ Dbg |(cid:3)FOL φ[S0]DS0We call such reasoning initial situation reasoning. Since the axioms DS0∪ Dbg often satisfy the closed-world assumption,provers such as Prolog can be employed to handle this type of query quite effectively.While few useful queries happen to precisely match these restricted forms, it is possible to answer quite broad classesof query by transforming them into such a form. This insight is at the heart of the principle tool for effective reasoning inthe situation calculus: regression.4.1. RegressionThe regression meta-operator RD is a syntactic manipulation that encodes the preconditions and effects of actions intothe query itself, meaning fewer axioms are needed for the final reasoning task [23,26]. The idea is to reduce a query aboutsome future situation to a query about the initial situation only, which is much easier to answer.There are two styles of regression operator commonly defined in the literature: the single-pass operator as definedin [23] which reduces to S0 in a single application, and the single-step operator as defined in [29] which operates oneaction at a time. We use the single-step variant as it is the more powerful of the two; the single-pass operator can only beapplied to situations rooted at S0, while the single-step operator can handle formulae containing situation variables.Regression is only defined for formulae that are regressable:Definition 4 (Regressable formulae). Let σi be an arbitrary situation term, xi an arbitrary variable not of sort Situation, τian arbitrary term not of sort Situation, ai an arbitrary term of sort Action, R i an arbitrary rigid predicate, F i an arbitraryprimitive fluent predicate, and αi an arbitrary action description predicate. Then the regressable formulae are the smallestset of syntactically-valid formulae satisfying:ϕ ::= F i( ¯τi, σi) | αi( ¯τi, ai, σi) | R i( ¯τi) | τi = τ j | ¬ϕ | ϕi ∧ ϕ j | ∃xi: ϕRegressable formulae are more general than uniform formulae. In particular, they can contain action description predi-cates and may mention different situation terms. They cannot, however, quantify over situation terms or compare situationsusing the (cid:2) predicate. Note also that our definition is more general than that of [23], where the single-pass regressionoperator is used.The regression operator is defined using a series of regression rules such as those shown below, mirroring the structureof regressable formulae:Definition 5 (Regression operator). Let R i be an arbitrary rigid predicate, αi be an arbitrary action description predicate withaxiom αi( ¯ν, a, s) ≡ Πα( ¯ν, a, s) in Dad, F i be an arbitrary primitive fluent with axiom F i(¯x, do(a, s)) ≡ ΦF i (¯x, a, s) in Dssa, τibe an arbitrary term not of sort Situation, si be an arbitrary variable of sort Situation, and ai be an arbitrary term of sortAction. Then the regression of φ, denoted RD(φ), is defined according to the following structural rules:RD(ϕi ∧ ϕ j) def= RD(ϕi) ∧ RD(ϕ j)RD(∃xi: ϕ) def= ∃xi: RD(ϕ)RD(¬ϕi) def= ¬RD(ϕi)(cid:3)αi( ¯τi, ai, σi)RD(cid:2)(cid:2)def= RD(cid:3)(cid:3)(cid:3)Πα( ¯τi, ai, σi)def= ΦF i ( ¯τi, ai, σi)(cid:2)(cid:2)(cid:2)RDRDRD(cid:2)F i¯τi, do(ai, σi)(cid:3)F i( ¯τi, si)def= F i( ¯τi, si)(cid:3)def= F i( ¯τi, S0)F i( ¯τi, S0)RD(τi = τ j) def= τi = τ j(cid:3)def= R i( ¯τi)R i( ¯τi)RD(cid:2)R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888871The key point here is that each application of RD replaces action description predicates with the RHS of their definitionsfrom Dad and primitive fluents with the RHS of their successor state axioms from Dssa, “unwinding” a single action fromeach do(a, σ ) situation term in the query. If the situation term is not constructed using do, it is left unchanged.Let us briefly state some important properties of the regression operator. First, and most importantly, it preserves equiv-alence of formulae:Proposition 1. For ϕ a regressable formula, D |(cid:3) ϕ ≡ RD(ϕ).Proof. By Pirri and Reiter [23, Theorem 2]. (cid:3)Any formula uniform in do(a, s) is regressable, and the resulting formula will always be uniform in s:Proposition 2. For φ uniform in do(a, s), RD(φ) is uniform in s.Proof. By induction on the structure of regressable formulae. (cid:3)Let R∗D denote repeated applications of RD until the formula remains unchanged. Such applications can transform aquery about some future situation into a query about the initial situation only:Proposition 3. For φ uniform in do([a1 . . . an], S0), R∗D(φ) is uniform in S0.Proof. By Pirri and Reiter [23, Theorem 3, part 1]. (cid:3)This last property is key to effective reasoning in the situation calculus, as it allows one to answer the projection problem.D(φ) holds in the initialTo determine whether φ holds in a given future situation, it suffices to determine whether R∗situation:Proposition 4. For φ uniform in do([a1 . . . an], S0):D |(cid:3) φ iff DS0∪ Dbg |(cid:3) R∗D(φ).Proof. By Pirri and Reiter [23, Theorem 3, part 2]. (cid:3)The regressed form is usually easier to answer, as it requires only the initial state axioms and background theory. Theaxioms Dad and Dssa are essentially “compiled into the query” by the R∗D operator. While an efficiency gain is not guar-anteed, regression has proven a very effective technique in practice [17,23], particularly when combined with techniques tolimit the resulting increase in query size [33].Unfortunately, this powerful technique cannot be applied to formulae that are not regressable. Its operation dependscrucially on knowing how many actions there are in each situation term, so that each action can be “unwound” from thequery in turn. Queries that universally quantify over situations, such as the property persistence queries of interest in thispaper, fall squarely outside the reach of standard regression techniques.4.2. Inductive reasoningWhile there is a rich and diverse literature base for the situation calculus, there appears to have been little work onqueries that universally quantify over situation terms. Reiter [24] has shown why the induction axiom cannot in general beeliminated when proving such statements, demonstrating the use of the axiom in manual proofs but offering no automatedprocedure.Other work on universally-quantified queries focuses on highly specialised applications, such as verifying state constraints[1,19] or studying properties of ConGolog programs [2,4,12]. While these works have produced useful results, they aretypically intended as stand-alone techniques rather than general reasoning tools for the situation calculus.Pirri and Reiter [19] have shown that the induction axiom can be “compiled away” when verifying a state constraint, bymeans of the following equivalence1:(cid:2)(cid:3)∀s: S0 (cid:2)Poss s → φ[s]|(cid:3) φ[S0] →D − DS0iffDbg |(cid:3) ∀s, a: φ[s] ∧ RD(cid:2)(cid:3)Poss(a, s)→ RD(cid:2)(cid:4)do(a, s)(cid:5)(cid:3)φ1 We have modified the original equations for consistency with our modified notation.872R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888Verification of a state constraint can thus be reduced to the comparatively straightforward task of static domain reasoning.Verification of state constraints was also approached by Bertossi et al. [1], who develop an automatic constraint verificationsystem using an induction theorem prover.However, there are many issues that are not addressed by these highly specialised works. What if we are interested inthe future of some arbitrary situation σ , rather than only S0? What if we restrict future actions according to an arbitraryaction description predicate? Can we integrate a method for handling universally-quantified queries with existing regressiontechniques? Our treatment of property persistence can provide a concrete basis for these considerations, and is hencesignificantly more general than this existing work.Formulating various safety, liveness and starvation properties of ConGolog programs also requires universal quantificationover situations. De Giacomo et al. [4] show how to re-cast these properties as fixpoint queries in second-order logic, anda preliminary model-checker capable of verifying them is described in [12]. Claßen and Lakemeyer [2] have developed alogic of ConGolog programs based on an iterative fixpoint computation similar to the one we propose in this paper. Theirtechnique is based on a modal variant of the situation calculus known as ES and is designed for quite specific applications;by contrast, our approach aims to be a general-purpose reasoning tool for the classical situation calculus.If one is willing to restrict attention to propositional domains, it is possible to use techniques from the propositionalmu-calculus to answer a broad range of inductive queries [11]. In a similar vein, Ternovska [31] has proven decidability fora variant of the situation calculus with monadic fluents. Our work differs by focusing on a narrower class of queries, byconstructing fixpoints at the meta-level rather than in the language, and by its applicability to the full first-order situationcalculus.Finally, let us introduce an important property of situations first formally identified by Savelli [28]: that universal quan-tification over situation terms is equivalent to a kind of infinite conjunction over the levels of the tree of situations:D |(cid:3) ∀s: ψ(s)iff(cid:6)D |(cid:3)(cid:7)n∈N∀a1 . . . an: ψ(cid:2)(cid:2)do[a1 . . . an], S0(cid:3)(cid:3)(cid:8)This is a direct consequence of the induction axiom for situations, which restricts situations to be constructed by per-forming some countable number of actions in the initial situation.5. The persistence conditionTo enable the use of persistence queries in practical systems, we clearly need a more effective reasoning techniquethan open-ended second-order theorem proving. Our approach is inspired by the success of Reiter’s regression technique:use a meta-level operator to transform the query into one that is easier to answer. Specifically, our technique transformsa property persistence query at σ into the evaluation of a uniform formula at σ – a much simpler query which can beapproached using existing techniques.Formally, we seek a method for transforming a uniform formula φ and action description predicate α into a uniformformula PD(φ, α) that is true at precisely the situations in which φ persists under α. We call such a formula the persistencecondition of φ under α.Definition 6 (Persistence condition). The persistence condition of φ under α, denoted PD(φ, α), is a uniform formula suchthat:D − DS0PD(φ, α)[s] ≡ ∀sIn other words, PD(φ, α) holds at s iff φ persists under α at s.: s (cid:2)α s|(cid:3) ∀s:s(cid:7) → φ(cid:7)(cid:4)(cid:5)(cid:3)(cid:7)(cid:2)Defining PD to be independent of the initial world state allows it to be calculated regardless of what (if anything) isknown about the actual state of the world – after all, a situated agent may not know all the details of DS0 , and we stillwant it to be able to use this technique.Provided that such a formula PD(φ, α) is given, we can use standard regression to reduce reasoning about situation-invariant properties to a first-order reasoning task as follows:D |(cid:3) ∀s: σ (cid:2)α s → φ[s]iffD |(cid:3) PD(φ, α)[σ ]iff∪ Dbg |(cid:3) R∗DDS0(cid:2)(cid:3)PD(φ, α)[σ ]R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888873Note that this generalises the work of Lin and Reiter [19] on state constraints, where queries are restricted to the form∀s: S0 (cid:2)Poss s → φ[s].Definition 6 alone clearly does not make the task of answering a persistence query any easier – it gives no indication ofhow the persistence condition might be calculated in practice, or even whether such a formula actually exists for a given φand α. In order to establish these results, we first need to define the weaker notion of a formula persisting to depth n in asituation.Definition 7 (Persistence to depth 1). A uniform formula φ persists to depth 1 under α in situation s when the formulaP 1D(φ, α)[s] holds, as defined by:D(φ, α)[s] def= φ[s] ∧ ∀a: RDP 1(cid:2)(cid:3)α[a, s]→ RD(cid:2)(cid:4)do(a, s)(cid:5)(cid:3)φSince α is an action description predicate and φ is a uniform formula, the expressions RD(α[a, s]) and RD(φ[do(a, s)])D is a literal encoding of the requirementare always defined and the resulting formula is always uniform in s. Note that P 1that “φ holds in s and in all its direct successors”.Successive applications of P 1D can then assert persistence to greater depths:Definition 8 (Persistence to depth n). For any n (cid:3) 0, a uniform formula φ persists to depth n under α in situation s when theformula PnD(φ, α)[s] holds, as defined by:D(φ, α) def= φP 0D(φ, α) def= P 1PnD(cid:2)Pn−1D (φ, α), α(cid:3)The following theorem confirms that PnD operates according to this intuition – for any sequence of actions of lengthi (cid:2) n, if each action satisfies α when it is executed, then φ will hold after performing those actions.Theorem 1. For any n ∈ N, Pnsatisfying α:D(φ, α) holds in σ iff φ holds in σ and in all successors of σ reached by performing at most n actionsD |(cid:3) PnD(φ, α)[σ ] ≡(cid:9)i(cid:2)n∀a1 . . . ai:(cid:10) (cid:9)j(cid:2)i(cid:2)(cid:4)a j, doα[a1 . . . a j−1], σ(cid:3)(cid:5)(cid:4)do(cid:2)[a1 . . . ai], σ→ φ(cid:11)(cid:3)(cid:5)Proof sketch. By induction on the natural numbers. For n = 0 we have φ[σ ] ≡ φ[σ ] by definition. For the inductive case,we expand the definition of PnPn−1D (φ, α)[σ ] ∧ ∀a: RDD(φ, α)[σ ] to get the following for the LHS:(cid:5)(cid:3)(cid:2)(cid:2)(cid:3)α[a, σ ]→ RD(cid:4)D (φ, α)Pn−1do(a, σ )Substituting for Pn−1D using the inductive hypothesis gives us a conjunction ranging over i (cid:2) n − 1, with universallyquantified variables a1 . . . ai , and we must establish the i = n case. Pushing this conjunction inside the scope of the ∀aquantifier, we can rename a ⇒ a1, a1 ⇒ a2, etc. to get the required expression. For a detailed proof see Appendix A. (cid:3)The PnD operator thus allows us to express the persistence of a formula to any given depth using a simple syntactictranslation based on regression. Intuitively, one would expect PD(φ, α) to be some sort of fixpoint of P 1D(φ, α), sincePD(φ, α) must imply persistence up to any depth. Such a fixpoint could then be calculated by iterative application of P 1D .The remainder of this section is devoted to verifying this intuition.We begin with two straightforward generalisations of results from the situation calculus literature, adapting them to our(cid:2)α notation:Proposition 5. For any action description predicate α, the foundational axioms of the situation calculus entail the following inductionprinciple:∀W , s: W (s) ∧(cid:4)∀a, s(cid:7)(cid:5)(cid:4)a, s(cid:7): α∧ s (cid:2)α s(cid:7) ∧ W(cid:3)(cid:2)(cid:7)s→ W(cid:2)(cid:2)a, sdo(cid:7)(cid:3)(cid:3)(cid:5)(cid:7)→ ∀s: s (cid:2)α s(cid:7) → W(cid:3)(cid:2)(cid:7)sProof. A trivial adaptation of Theorem 3.2 in [24]. (cid:3)874R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888Proposition 6. For any basic action theory D, uniform formula φ and action description predicate α:D − DS0|(cid:3) ∀s: φ[s] →(cid:2)∀s(cid:7): s (cid:2)α s(cid:7) → φ(cid:5)(cid:3)(cid:4)(cid:7)siffDbg |(cid:3) ∀s, a: φ[s] ∧ RD(cid:2)(cid:3)α[a, s]→ RD(cid:2)(cid:4)do(a, s)(cid:5)(cid:3)φProof. A straightforward generalisation of the model-construction proof of Lemma 5.3 in [19], utilising Proposition 5. Thedetails of this proof are reproduced in Appendix A. (cid:3)Proposition 6 will be key in our algorithm for calculating the persistence condition. It allows one to establish the result“if φ holds in s, then φ persists in s” by using static domain reasoning, a comparatively straightforward reasoning task.We next formalise some basic relationships between our hypothetical PD operator and PnD :Lemma 1. Given a basic action theory D, uniform formula φ and action description predicate α, then for any n:D − DS0|(cid:3) ∀s:(cid:2)(cid:7)∀s: s (cid:2)α s(cid:7) → φ(cid:5)(cid:3)(cid:4)(cid:7)s≡(cid:2)(cid:7)∀s: s (cid:2)α s(cid:7) → Pn(cid:4)D(φ, α)(cid:5)(cid:3)(cid:7)sThat is, φ persists under α iff PnD[φ, α] persists under α.D[φ, α] implies φ by definition, the if direction is trivial. For the only-if direction we proceed by inductionFor the base case of P 1D , let M be a model of D and μ an assignment to the free variables in φ. Suppose that φ persistsProof. Since Pnon n.at s but P 1D(φ, α) does not:M, μ |(cid:3) ∀sM, μ (cid:17)|(cid:3) ∀s(cid:7)(cid:7): s (cid:2)α s: s (cid:2)α s(cid:7) → φs(cid:7) → Pn(cid:4)D(φ, α)(cid:4)(cid:5)(cid:7)(cid:5)(cid:7)s(3)(4)For (4) to hold, there must be some situation element from M that is in the future of μ(s) but at which P 1Let μ assign this situation element to the fresh variable ˙s, so that:D(φ, α) is false.M, μ |(cid:3) s (cid:2)α ˙s ∧ ¬P 1Expanding the definition of P 1D(φ, α)[˙s]D we have:(cid:2)M, μ |(cid:3) s (cid:2)α ˙s ∧ ¬φ[˙s] ∧ ∀a: α[a, ˙s] → φ(cid:4)do(a, ˙s)(cid:5)(cid:3)But by our assumption that (3) holds, we must have:M, μ |(cid:3) φ[˙s]M, μ |(cid:3) ∀a: α[a, ˙s] → φ(cid:5)(cid:4)do(a, ˙s)(5)It is thus impossible for (5) to hold, and we have a contradiction. Since our choice of M and μ was arbitrary, the resultwill hold for any s and we have the lemma as required.For the inductive case, assume that Pn−1D(Pn−1P 1D (φ, α), φ), and we repeat the base case proof using φ(cid:7) = Pn−1D (φ, α) persists but PnD(φ, α) does not. By definition we have PnD (φ, α) in place of φ to obtain a contradiction. (cid:3)D(φ, α) =Lemma 2. Given a basic action theory D, uniform formula φ and action description predicate α, then for any n:(cid:3)D(φ, α)[s]PD(φ, α)[s] → Pn|(cid:3) ∀s:(cid:2)D − DS0Proof. PD(φ, α) implies the persistence of φ by definition. If φ persists at s, then by Lemma 1 we have that Pnpersists at s. Since the persistence of Pndesired. (cid:3)D(φ, α)D(φ, α) holds at s by definition, we have the lemma asD(φ, α) at s implies that PnWe are now equipped to prove the major theorem of this paper: that if PnD(φ, α) implies Pn+1D (φ, α), then PnD(φ, α) isequivalent to the persistence condition for φ under α.875(6)Theorem 2. Given a basic action theory D, uniform formula φ and action description predicate α, then for any n:R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888Dbg |(cid:3) ∀s: PnD(φ, α)[s] → Pn+1D (φ, α)[s]iffD − Ds0|(cid:3) ∀s: PnD(φ, α)[s] ≡ PD(φ, α)[s]In other words, if we can calculate a fixpoint of applications of P 1(7)D(φ, α)[s] then that fixpoint is the persistence condition for φ under α.Proof. For the if direction, we begin by expanding Eq. (6) using the definition of P 1D to get the equivalent form:(cid:2)(cid:3)Dbg |(cid:3) ∀s: PnDbg |(cid:3) ∀s: PnDbg |(cid:3) ∀s, a: PnD(φ, α)[s] → P 1DD(φ, α)[s] ∧ ∀a: RDD(φ, α)[s] →Pn(cid:3)→ RDα[a, s]D(φ, α)[s] ∧ ∀a: RDD(φ, α), α[s]Pn(cid:2)(cid:2)(cid:2)(cid:3)α[a, s](cid:2)P 1→ RD(cid:4)D(φα)do(a, s)(cid:2)P 1(cid:4)D(φ, α)(cid:5)(cid:3)(cid:5)(cid:3)(cid:3)do(a, s)By Proposition 6, Eq. (6) thus lets us conclude that Pnpersistence of φ under α, which is equivalent to PD(φ, α) by definition, giving:D(φ, α) persists under α. By Lemma 1 this is equivalent to theD − Ds0|(cid:3) ∀s: PnD(φ, α)[s] → PD(φ, α)[s]By Lemma 2 this is an equivalence, yielding Eq. (7) as required.The only-if direction is a straightforward reversal of this reasoning process: PD(φ, α) implies the persistence of φ, whichimplies the persistence of PnD(φ, α), which yields Eq. (6) by Proposition 6. (cid:3)Since Dbg |(cid:3) Pn+1D operator, as ourinitial intuition suggested. We can therefore apply some standard results from fixpoint theory to the calculation of PD(φ, α),which we will do in the next section.D(φ, α) by definition, Eq. (6) identifies PnD(φ, α) as a fixpoint of the P 1D (φ, α) → PnTo conclude this section, we establish what is essentially the “dual” of the theorem above – that is there is any uniformformula satisfying the definition of PD(φ, α) then it is the fixpoint of applications of P 1D .2Theorem 3. Given a basic action theory D, uniform formula φ and action description predicate α, suppose that ψ is a regressableformula with s the only zero-arity term of sort situation and:D − DS0|(cid:3) ∀s: ψ(s) ≡ ∀s(cid:7): s (cid:2)α s(cid:7) → φ(cid:4)(cid:5)(cid:7)sψ(s) thus identifies precisely those situations in which φ persists under α. Then for any situation term σ :D |(cid:3) R∗D(ψ)[σ ]iff(cid:6)D |(cid:3)n∈N(cid:7)(cid:8)D(φ, α)[σ ]PnIn other words, R∗D(ψ) is a uniform formula representing the fixpoint of applications of P 1D(φ, α)[s].Proof sketch. The restricted form of ψ means that it is “about” only the situation s and its successors, so we can applyregression to transform it into a formula uniform in s. The theorem is then a straightforward adaptation of Lemma 6 in [28],using Savelli’s technique of splitting the quantification over situation terms into an infinite conjunction. For a detailed proofsee Appendix A. (cid:3)6. Calculating PDSince we can easily calculate PnD(φ, α) for any n, we have a straightforward algorithm for determining PD(φ, α): searchfor an n such that(cid:2)Dbg |(cid:3) ∀s:D(φ, α)[s] → Pn+1PnD(φ, α) to be simpler than Pn+1Since we expect Pniterative procedure for doing just that. Note that the calculation of P 1so we do not present an algorithm for it.(cid:3)D (φ, α)[s]D (φ, α), we should look for the smallest such n. Algorithm 1 presents anD(φ, α) is a straightforward syntactic transformation,2 Previous versions of this work [13,14] incorrectly claimed that such a formula would always exist. Our thanks to an anonymous reviewer for helpingto clarify this point.876R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888Algorithm 1 Calculate PD(φ, α)pn ⇐ φpn1 ⇐ P 1while Dbg (cid:17)|(cid:3) ∀s : pn[s] → pn1[s] doD(pn, α)pn ⇐ pn1pn1 ⇐ P 1D[pn, α]end whilereturn pn6.1. SoundnessIf Algorithm 1 terminates, it terminates returning a value of pn for which Eq. (6) holds. By Theorem 2 this value of pn isequivalent to the persistence condition for φ under α. The algorithm therefore correctly calculates the persistence condition.D(φ, α) is unsatisfiable for any situation, as it appears in the antecedent ofan implication. The algorithm thus correctly returns an unsatisfiable condition (equivalent to ⊥) when φ can never persistunder α.In particular, note that Eq. (6) holds when Pn6.2. CompletenessThere are two aspects to the completeness of our technique: whether the necessary fixpoint exists at all, and whetherthe algorithm for calculating it will terminate in a finite number of iterations.6.2.1. Existence of the persistence conditionBy Theorem 3 we know that the persistence condition is always the fixpoint of applications of P 1D . In other words, ifD has no finitely-expressible fixpoint for a given φ and α, then a uniform formula satisfying the definition of PD(φ, α)P 1does not exist.Unfortunately, it is relatively easy to construct a fluent for which a first-order persistence condition does not exist.Consider a domain with a single object sort modelled after the standard first-order axioms for the natural numbers, a singlefluent F (x, s) and a single action A that makes F (x, s) false whenever F (suc(x), s) is false:(cid:2)(cid:3)x, do( A, s)F≡ F(cid:2)suc(x), s(cid:3)Let us attempt to calculate the persistence condition of F (0, s) with the action description predicate α set to true. Thesequence of iterations produced by Algorithm 1 would be:(cid:2)(cid:2)(cid:3)F (0, s)(cid:3)F (0, s)...(cid:2)(cid:3)F (0, s)P 1DP 2DPnD≡ F (0, s) ∧ F≡ F (0, s) ∧ F(cid:2)suc(0), s(cid:2)suc(0), s(cid:3)(cid:3)(cid:2)(cid:2)(cid:3)suc(0), s(cid:3)suc∧ F≡(cid:2)Fi=n(cid:9)i=0(cid:3)suci(0), sIt is straightforward to manually demonstrate that F (0, s) will persist if and only if F holds for all objects built bysuccessive applications of suc to 0. Such a condition can only be expressed using a transitive closure, and hence there is nofirst-order formula that is equivalent to the persistence condition of F (0, s).Of course, if Dbg provides an axiomatisation of the standard “greater than” predicate x < y then we can finitely identifythese objects, and the persistence condition can be expressed as:(cid:2)(cid:3)F (0, s)PD≡ F (0, s) ∧ ∀x: 0 < x → F (x, s)However, calculating such a condition would still be beyond the reach of Algorithm 1; since it cannot be constructed byfinitely many applications of P 1D , the algorithm would fail to terminate.Nevertheless, Theorem 3 does provide an important completeness result – it demonstrates that if there exists any tech-nique to replace reasoning about a persistence query at σ with a regression-based reasoning scheme at σ , then it isequivalent (up to termination of the algorithm) to our approach.In fact, we suspect that a stronger result than Theorem 3 holds: that if a persistence query at σ can be replaced by anyfirst-order formula that does not universally quantify over situation terms, then that query has a well-defined persistencecondition.Conjecture 1. Given a basic action theory D, uniform formula φ and action description predicate α, suppose that ψ(s) is a sentenceof Lsitcalc whose prenex normal form contains only existential quantifiers over situations, with s the only free variable of sort situation,such that:R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888877D − DS0|(cid:3) ∀s: ψ(s) ≡ ∀s(cid:7): s (cid:2)α s(cid:7) → φ(cid:5)(cid:4)(cid:7)sThus ψ(s) identifies precisely those situations in which φ persists under α. Then there is a uniform formula PD(φ, α) such that:D |(cid:3) ∀s: ψ(s) ≡ PD(φ, α)[s]In other words: if the domain D permits some technique for transforming a persistence query into a query that doesn’tuniversally quantify over situations, then D is also amenable to the technique presented in this paper.The proof from Theorem 3 cannot be applied to this conjecture because we have no way to reduce this more general ψ(s)to a uniform formula. As part of our ongoing research, we aim to either confirm this intuition or to find a counter-example– either result would shed valuable light on the study of universally-quantified queries in the situation calculus.6.2.2. TerminationAs shown in the previous section, even if the persistence condition PD(φ, α) is known to exist there is no guarantee thatAlgorithm 1 can calculate it in a finite amount of time. The algorithm may in fact fail to terminate for two distinct reasons:the loop condition may never be satisfied, or the first-order logical inference in the loop condition may be undecidable.The later case indicates that the background theory Dbg is undecidable. While this is a concern, it affects more than justour algorithm – any system implemented around such an action theory will be incomplete. With respect to this source ofincompleteness, our algorithm is no more incomplete than any larger reasoning system it would form a part of. We willconcern ourselves only with the former case.To ensure the completeness of our approach, we must restrict the domain theory and/or the form of queries being posedso that PD(φ, α) is not only guaranteed to exist, but is guaranteed to be calculable within a finite number of iterations.Some standard results from fixpoint theory can be applied towards this task:Definition 9. Let L(Dbg) be the Lindenbaum–Tarski algebra of the background theory for formulae uniform in s. It is thus aboolean lattice where:• elements are sets of uniform formulae grouped by equivalence w.r.t. Dbg ,• meet and join are ∧ and ∨ respectively,• logical implication w.r.t. Dbg forms a partial ordering relation, and• top and bottom are the equivalence classes of (cid:8) and ⊥ respectively.Theorem 4. For any fixed value of α, P 1D(φ, α)[s] is a monotone decreasing function over L(Dbg).Proof. The domain and range of P 1of P 1decreasing function as required. (cid:3)D it is always the case that Dbg |(cid:3) P 1D are uniform formulae and so correspond to the elements of L(Dbg). By the definitionD is a monotoneD(φ, α) → φ. Since → is the partial ordering relation of L(Dbg), P 1Corollary 1. If L(Dbg) is a complete lattice, then given a uniform formula φ and action description predicate α, the persistence condi-tion PD(φ, α) always exists and is unique up to equivalence under Dbg .Proof. A standard result from fixpoint theory. Since P 1D is a monotone decreasing function over a complete lattice, the con-structive proof of Tarski’s fixpoint theorem [3] means it has a unique greatest fixpoint less than the equivalence class of φ.This fixpoint can be found by transfinite iteration of applications of P 1D and is equivalent to PD(φ, α) by Theorem 2. (cid:3)Corollary 2. If L(Dbg) is a well-founded lattice, then given a uniform formula φ and action description predicate α, the persistencecondition PD(φ, α) always exists and can be calculated by finitely many applications of P 1D .Proof. A standard result from fixpoint theory. A well-founded lattice L(Dbg) as no infinite descending chains of elements,so the transfinite iteration used by [3] to find the fixpoint of P 1D in Corollary 1 must terminate after finitely many itera-tions. (cid:3)6.3. Guaranteeing completenessThe most obvious restriction that can be applied to guarantee completeness is to ensure that the action and objectsorts are finite. In such theories the lattice L(Dbg) is finite, and any finite lattice is both complete and well-founded. Thesetheories also have the advantage that the static domain reasoning performed by Algorithm 1 can be done using propositionallogic, meaning it is decidable and so providing a strong termination guarantee.878R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888There are notable advantages to maintaining the expressive power of first-order logic even when the domain can bepropositionalised – for example, the use of quantifiers can produce exponentially-shorter formulae and hence lead to shorterproofs.applications of P 1An alternate approach is to restrict the form of the successor state axioms and/or the queries being posed so thatD operate on a subset of L(Dbg) which meets the requirements set out in Corollaries 1 and 2.For example, suppose we restrict successor state axioms and action description predicates to the following forms, where¯yi ⊆ ¯x and Φ+/−F ,iand Πα,i mention no terms other than ¯x and s:(cid:2)(cid:3)¯x, do(a, s)F≡n(cid:12)i=1a = ai( ¯yi) ∧ Φ+F ,i(¯x, s) ∨ F (¯x, s) ∧ ¬n(cid:12)i=1a = ai( ¯yi) ∧ Φ−F ,iα(¯x, a, s) ≡n(cid:12)i=1a = ai( ¯yi) ∧ Πα,i(¯x, s)Such domains have a finite number of actions, each of which is only capable of changing fluents about objects it is givenas direct arguments. For example, the action ai( A) can change the fluent F ( A, s) but not F (B, s).Now, suppose we have a quantifier free uniform formula φ. When calculating P 1the action terms introduced by the successor state axioms, so that P 1mentioning only the terms found in φ. The range of P 1terminating calculation of PD(φ, α). A detailed proof appears in Appendix A (Theorem 5).D(φ, α) it is possible to simplify awayD(φ, α) is also a quantifier-free uniform formulaD applied to φ is thus a finite subset of L(Dbg), which ensures aThis restriction is similar to the local-effect theories of [21,35], with the additional requirement that the right-hand sideof the axiom contain no quantifiers. Whether local-effect theories can guarantee termination without additional restrictionswould be an interesting avenue for further research.As an example, the classic “holding” predicate can be expressed in a form that meets this restriction:(cid:2)Holding(cid:2)(cid:3)obj, do(a, s)(cid:3)Poss(cid:2)pickup(obj), s(cid:3)Possdrop(obj), s≡ ¬Holding(obj, s)≡ Holding(obj, s)≡ a = pickup(obj) ∨ Holding(obj, s) ∧ a (cid:17)= drop(obj)However, if there are multiple agents acting in the domain then the possibility predicate for pickup would no longermeet this restriction, as it contains a quantifier on the right-hand side:(cid:2)Posspickup(agt, obj), s(cid:3)≡ ¬∃agt(cid:7)(cid:2): Holdingagt(cid:3)(cid:7), obj, sClearly this is a strong restriction on the structure of the theory, as the successor state axioms are not able to containany quantifiers. It does demonstrate, however, that certain syntactic restrictions on D are able to guarantee terminatingcalculation of PD . It seems there should be a more general “syntactic well-foundedness” restriction that can be applied tothese axioms, but we have not successfully formulated one at this stage.In a similar vein, suppose that the theory of action is context free [20]. In such theories successor state axioms have thefollowing form:(cid:2)(cid:3)¯x, do(a, s)F≡ Φ+F (¯x, a) ∨(cid:2)F (¯x, s) ∧ ¬Φ(cid:3)−F (¯x, a)The effects of an action are thus independent of the situation in which it is performed. Lin and Levesque [18, Lemma 6.2]have show that context-free theories with a finite number of parameterless actions have a finite state space, which issufficient to ensure termination of our algorithm.Intuitively, if there are at most N distinct states in the domain then any situation more than N actions into the futurehas the same state as some situation less than N actions into the future. Algorithm 1 will therefore terminate after at mostN iterations. A detailed proof is available in Appendix A (Theorem 6).From a slightly different perspective, suppose that φ can never persist under α, so that PD(φ, α) ≡ ⊥. Further supposethat D has the compactness property as in standard first-order logic. Then the “quantum levels” of Savelli [28] guarantee thatthere is a fixed, finite number of actions within which ¬φ can always be achieved. In this case Algorithm 1 will determinePD(φ, α) ≡ ⊥ within finitely many iterations.It would also be interesting to determine whether known variants of the situation calculus in which the projectionproblem is decidable (such as [10]) are able to guarantee termination of the fixpoint construction, or whether more sophis-ticated fixpoint algorithms can be applied instead of simple iterative approximation. Investigating such algorithms would bea promising avenue for future research.The important point here is not that we can guarantee termination in general, but that we have precisely characterisedthe inductive reasoning necessary to answer property persistence queries, and shown how it can be replaced by the evalu-ation of a uniform formula at the situation in question.R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–8888796.4. EffectivenessOur algorithm replaces a single reasoning task based on the full action theory D with a series of reasoning tasks basedon the static background theory Dbg . Is this a worthwhile trade-off in practice? The following points weigh strongly infavour of our approach.First and foremost, we avoid the need for the second-order induction axiom. All the reasoning tasks can be performedusing standard first-order reasoning, for which there are high-quality automated provers. Second, the calculation of PDperforms only static reasoning, which as discussed in Section 2 is a comparatively straightforward task which can be madedecidable under certain conditions. Third, PD(φ, α)[σ ] is in a form amenable to regression, a standard tool for effectivereasoning in the situation calculus. Fourth, the persistence condition for a given φ and α can be cached and re-used for aseries of related queries about different situations, a significant gain in amortised efficiency. Finally, in realistic domains weexpect many properties to fail to persist beyond a few situations into the future, meaning that our algorithm will requirefew iterations in a large number of cases.Of course, we also inherit the potential disadvantage of the regression operator: the length of PD(φ, α) may be muchlarger than the length of φ. Since there is no bound on the number of iterations required for Algorithm 1 to terminate, thelength of PD(φ, α) is actually unbounded in the general case. As with regression, our experience has been that this is rarelya problem in practice, and is more than compensated for by the reduced complexity of the resulting reasoning task.6.5. Related algorithmsAs noted in Section 2, our use of fixpoints in this paper has much in common with the study of properties of ConGologprograms [2,4]. In particular, our algorithm has deep similarities to the CheckEU and CheckEG algorithms used by Claßenand Lakemeyer [2]. Like our work, they seek a fixpoint using iterative application of a meta-level function based on regres-sion. Indeed, Algorithm 1 could be re-cast as a special case of their approach, but without the need to maintain a complexgraph structure.Claßen and Lakemeyer also note that their approach is not able to guarantee completeness in the general case, andthey identify as future work the discovery of general classes of theory for which their technique is complete. Given theunderlying similarities, we are confident that such advances in reasoning about ConGolog programs will advance our abilityto answer persistence queries, and vice-versa.We also note that work on state invariants in other planning formalisms (e.g. [7,8]) uses ideas broadly similar to ourapproach – an iterative algorithm that explores longer and longer sequences of actions until a stable state is reached. Inthese formalisms, the domain typically has a finiteness restriction that guarantees eventual termination of the algorithm.7. ExamplesTo demonstrate the applicability of our technique, consider again the example persistence queries given in Section 3.The persistence condition is readily applicable to each example, and the transformed queries can then be answered usingstandard regression.Goal impossibility. Given a goal G, establish that there is no legal situation in which that goal is satisfied:D |(cid:3) PD(¬G, Poss)[S0]The persistence condition of ¬G with respect to action legality allows goal impossibility to be checked easily.Goal futility. Given a goal G and situation σ , establish that the goal cannot be satisfied in any legal future situation from σ :D |(cid:3) PD(¬G, Poss)[σ ]Precisely the same formula is required for checking goal impossibility and goal futility. This highlights the advantage of re-using the persistence condition at multiple situations. Our approach makes it feasible for an agent to check for goal futilityeach time it considers performing an action, and avoid situations that would make its goals unachievable.Checking state constraints. Given a state constraint SC, show that the constraint holds in every legal situation:D |(cid:3) PD(SC, Poss)[S0]However, since we want a state constraint to always persist, it must satisfy the following equivalence:Dbg |(cid:3) φ ≡ PD(φ, Poss)If this equivalence does not hold then PD(φ, Poss) indicates the additional conditions that are necessary to ensure that φpersists, which may be useful for adjusting the action theory to enforce the constraint. This particular application has strongparallels to the approach to state constraints developed by Lin and Reiter [19].880R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888Need for cooperation. Given an agent agt, goal G and situation σ , establish that no sequence of actions performed by thatagent only can achieve the goal:D |(cid:3) PD(¬G, MyAction)[σ ]Knowledge with hidden actions. In recent work we have developed a regression rule for knowledge that uses the persis-tence condition to account for arbitrarily-long sequences of hidden actions [14]. While the details of this formulation areoutside the scope of the current paper, the general form of the regression rule is:(cid:2)RD(cid:2)(cid:3)(cid:3)Knowsφ, do(a, s)def= Knows(cid:2)(cid:2)(cid:4)PD(φ, Hidden)RD(cid:5)(cid:3)(cid:3)do(a, s), sThe key point of this definition is that the agent can only know φ if it knows that φ will persist after any sequence ofhidden actions.This highlights an important benefit of our approach – it integrates well with existing reasoning techniques. If one iswilling to assume that PD(φ, α) will always exist, it can be used to “factor out” the inductive reasoning and produce aregression rule for formulae that universally quantify over situations.The “gold thief” domain. As a detailed example of our technique in action, consider again the “gold thief” domain asdescribed in Section 3 and axiomatised in Appendix B. We want to establish that:D |(cid:3) ∀s: S0 (cid:2)Undet s → ¬Stolen(s)By the definition of the persistence condition, this is equivalent to:D |(cid:3) PD(¬Stolen, Undet)[σ ]To answer this query we will employ Algorithm 1, calculating PnD for successively larger values of n until the seriesconverges to a fixpoint. Full details of this calculation can be found in Appendix C; we present only the major results below.The case of n = 0 is trivial:P 0D(¬Stolen, Undet)[s] = ¬Stolen(s)The n = 1 case is given by Definition 7 as:P 1D(. . .)[s] = ¬Stolen(s) ∧ ∀a: RD(cid:2)(cid:3)Undet(a, s)(cid:2)→ RD¬Stolen(cid:2)(cid:3)(cid:3)do(a, s)Expanding the ∀a quantifier over each of the three actions in this domain we obtain:P 1D(. . .)[s] = ¬Stolen(s) ∧ RD∧ RD(cid:2)(cid:2)(cid:3)Undet(takeGold, s)(cid:2)(cid:3)Undet(crackSafe, s)→ RD(cid:3)Undet(toggleLight, s)→ RD→ RD(cid:2)¬Stolen(cid:2)¬Stolen(cid:2)(cid:2)¬Stolen(cid:2)(cid:3)(cid:3)do(takeGold, s)(cid:3)(cid:3)do(crackSafe, s)(cid:2)(cid:3)(cid:3)do(toggleLight, s)∧ RDApplying regression and simplifying produces the final result:(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)D(. . .)[s] = ¬Stolen(s) ∧P 1Intuitively, this indicates that the gold cannot be stolen by a single undetected action if the safe is not open (since itwould first have to be cracked) or the light is on (since the action would be detected). Since this is clearly not entailed bythe P 0D case, we must continue to the n = 2 case. Again applying Definition 7 and expanding out each individual action, weget:P 2D(. . .)[s] = ¬Stolen(s) ∧(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)(cid:3)Undet(takeGold, s)(cid:2)(cid:2)∧ RD(cid:4)¬SafeOpen∧(cid:2)→ RD(cid:3)do(takeGold, s)(cid:2)(cid:3)Undet(crackSafe, s)∧ RD(cid:4)¬SafeOpen∧(cid:2)→ RD(cid:3)do(crackSafe, s)(cid:2)∧ RD(cid:4)¬SafeOpen(cid:3)Undet(toggleLight, s)(cid:2)do(cid:3)toggleLight(s)∧(cid:2)¬Stolen(cid:2)∨ LightOn(cid:2)¬Stolen(cid:2)(cid:2)(cid:3)do(takeGold, s)(cid:3)(cid:5)(cid:3)do(takeGold, s)(cid:2)(cid:3)do(crackSafe, s)(cid:3)(cid:5)(cid:3)∨ LightOn→ RD(¬Stolen(cid:2)∨ LightOndo(crackSafe, s)(cid:2)(cid:3)do(toggleLight, s)(cid:3)(cid:5)(cid:3)do(toggleLight, s)R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888881Performing the regression and simplifying down, we eventually obtain:P 2D(. . .)[s] = ¬Stolen(s) ∧(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)We have clearly satisfied the termination condition of Algorithm 1, since P 1D → P 2D , and have thus successfully calcu-lated the persistence condition:PD(¬Stolen, Undet) = ¬Stolen ∧ [¬SafeOpen ∨ LightOn]Checking whether the gold is safe is now a simple matter of reasoning about the initial situation:D |(cid:3) ¬Stolen(S0) ∧(cid:5)(cid:4)¬SafeOpen(S0) ∨ LightOn(S0)With PD(¬Stolen, Undet) in hand, we can also perform more sophisticated reasoning about the safety of the gold – forexample, we can check whether a proposed action would jeopardise the safety of the gold and refuse to perform the actionif so.8. ConclusionsIn this paper we have developed an algorithm that transforms property persistence queries, a quite general and usefulclass of situation calculus query, into a form that is amenable to standard techniques for effective reasoning in the situationcalculus. The algorithm replaces a second-order induction axiom with a meta-level fixpoint calculation based on iterativeapplication of the standard regression operator. It is shown to be sound, and complete in several interesting cases.Our approach generalises previous work on universally-quantified queries in several important ways. It can considersequences of actions satisfying a range of conditions, not just the standard ordering over action possibility, enabling us totreat problems such as need for cooperation and knowledge with hidden actions. It can establish that properties persist inthe future of an arbitrary situation, not necessarily the initial situation, enabling us to answer the question of goal futility.The results of calculating the persistence condition can be cached, allowing for example the goal futility question to beefficiently posed on a large number of situations once the persistence condition has been calculated.Perhaps most importantly for the wider situation calculus community, we have factored out the inductive reasoning re-quired to answer these queries. Work on increasing the effectiveness of this inductive reasoning, and on guaranteeing aterminating calculation in stronger classes of action theory, can proceed independently from the development of formalismsthat utilise persistence queries. This opens the possibility of wider application of the property persistence approach – sub-sequent applications can use the PD operator as a kind of “black box” for dealing with persistence queries, for example toformulate regression rules as in our own work on knowledge [14].This paper has thus significantly increased the scope of queries that can be posed within automated reasoning systemsbuilt upon the situation calculus.Appendix A. Detailed proofsTheorem 1. For any n ∈ N, Pnsatisfying α:D(φ, α) holds in σ iff φ holds in σ and in all successors of σ reached by performing at most n actionsD |(cid:3) Pn(cid:9)D(φ, α)[σ ] ≡(cid:10) (cid:9)∀a1 . . . ai:i(cid:2)nj(cid:2)i(cid:2)(cid:4)a j, doα[a1 . . . a j−1], σ(cid:3)(cid:5)(cid:2)(cid:4)do→ φ[a1 . . . ai], σ(cid:11)(cid:3)(cid:5)Proof. By induction on the natural numbers. For n = 0 we have φ[σ ] ≡ φ[σ ] by definition. For the inductive case, weexpand the definition of PnPn−1D (φ, α)[σ ] ∧ ∀a: RDD(φ, α)[σ ] to get the following for the LHS:(cid:2)(cid:2)(cid:5)(cid:3)(cid:3)α[a, σ ]→ RD(cid:4)D (φ, α)Pn−1do(a, σ )By the inductive hypothesis we can equate Pn−1D (φ, α)[σ ] in this LHS with all but the i = n clause from the RHS con-junction, and we suppress them on both sides. If we also drop the regression operators we are left with the following toestablish:D |(cid:3) ∀a: α[a, σ ] → Pn−1(cid:5)do(a, σ )(cid:4)D (φ, α)(cid:2)(cid:4)a j, do≡(cid:3)(cid:5)(cid:2)(cid:4)do→ φ[a1 . . . an], σ(cid:11)(cid:3)(cid:5)∀a1 . . . an:[a1 . . . a j−1], σ(cid:10) (cid:9)αj(cid:2)n882R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888We can again use the inductive hypothesis on Pn−1D in the LHS of this equivalence. If we then distribute the α[a, σ ]implication over the outermost conjunction and collect quantifiers, we obtain the following for the LHS:(cid:9)i(cid:2)n−1(cid:10)∀a, a1 . . . ai:α[a, σ ] ∧(cid:2)(cid:4)a j, doα(cid:9)j(cid:2)i[a, a1 . . . a j−1], σ(cid:3)(cid:5)(cid:2)(cid:4)do→ φ[a, a1 . . . ai], σ(cid:11)(cid:3)(cid:5)Renaming a ⇒ a1, a1 ⇒ a2, . . . , ai ⇒ ai+1, we see that each of the i < n − 1 clauses on the LHS is equivalent to one ofthe i < n clauses that have been suppressed on the RHS. The remaining i = n − 1 clause is equivalent to the required RHS:(cid:10)(cid:9)∀a1 . . . an:(cid:2)(cid:4)a j, doα[a1 . . . a j−1], σ(cid:3)(cid:5)(cid:2)(cid:4)do→ φ[a1 . . . an], σ(cid:11)(cid:3)(cid:5)j(cid:2)nWe therefore have the desired equivalence. (cid:3)Lemma 3. For any basic action theory D, uniform formula φ and action description predicate α:ifΣ ∪ Dbg ∪ Dssa ∪ Dad ∪thenDbg |(cid:3) ∀s, a: φ[s] ∧ RD(cid:7)(cid:8)φ[S0]|(cid:3) ∀s: S0 (cid:2)α s → φ[s](cid:2)(cid:3)α[a, s]→ RD(cid:2)(cid:4)do(a, s)(cid:5)(cid:3)φProof. This is a straightforward generalisation of the proof of Lemma 5.3 in [19] using our modified notation. We repeatthe details of the proof below for convenience. Begin by assuming the antecedent:Σ ∪ Dbg ∪ Dssa ∪ Dad ∪(cid:7)(cid:8)φ[S0]|(cid:3) ∀s: S0 (cid:2)α s → φ[s](A.1)Let M be a model of Dbg . Suppose μs and μa are variable assignments for situation and action variables respectively, suchthat:M, μs, μa |(cid:3) φ[s] ∧ RD(cid:2)(cid:3)α[a, s]We will show that M, μs, μa |(cid:3) RD(φ[do(a, s)]). Following the construction in [23], we construct a model M(cid:7)following properties:with theand M share the same domains for sorts Action and Object.interprets every rigid predicate and function the same as M.1. M(cid:7)2. M(cid:7)3. M(cid:7) |(cid:3) Σ ∪ Dssa ∪ Dad.4. For every variable assignment for object variables μo, and for every fluent F (¯x, s), M(cid:7), μo |(cid:3) F (¯x, S0) iff M, μs, μo |(cid:3)F (¯x, s).Since M, μs, μa |(cid:3) RD(α[a, s]) and M(cid:7) |(cid:3) Dad we have:M(cid:7), μa |(cid:3) α[a, S0]Since M, μs, μa |(cid:3) φ[s], property (4) of M(cid:7)ensures that:M(cid:7), μa |(cid:3) φ[S0]By our assumption (A.1), M(cid:7), μa |(cid:3) φ[do(a, S0)]. Since M(cid:7)satisfies Dssa the regression operator can be employed toyield:M(cid:7), μa |(cid:3) RDFinally, property (4) of M(cid:7)φ(cid:2)(cid:4)do(a, S0)(cid:5)(cid:3)M(cid:7), μa |(cid:3) RD(cid:2)φ(cid:4)do(a, S0)gives us:(cid:5)(cid:3)iff M, μs, μa |(cid:3) RD(cid:2)(cid:4)do(a, s)(cid:5)(cid:3)φSince we have the LHS of this equivalence by construction, we can conclude the RHS. This suffices to establish thelemma. (cid:3)Proposition 6. For any basic action theory D, uniform formula φ and action description predicate α:R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888883|(cid:3) ∀s: φ[s] →(cid:2)(cid:7)∀s: s (cid:2)α s(cid:7) → φ(cid:5)(cid:3)(cid:4)(cid:7)sD − DS0iffDbg |(cid:3) ∀s, a: φ[s] ∧ RD(cid:2)(cid:3)α[a, s]→ RD(cid:2)(cid:4)do(a, s)(cid:5)(cid:3)φProof. The if direction is straightforward using the induction axiom from Proposition 5. For the only-if direction, we cantake the S0 case of the LHS to obtain:D − DS0|(cid:3) φ[S0] →(cid:2)(cid:3)∀s: S0 (cid:2)α s → φ[s]Lifting φ[S0] into the axioms, this precisely matches the form of Lemma 3 and we have the theorem as desired. (cid:3)Theorem 3. Given a basic action theory D, uniform formula φ and action description predicate α, suppose that ψ is a regressableformula with s the only zero-arity term of sort situation and:D − DS0|(cid:3) ∀s: ψ(s) ≡ ∀s(cid:7): s (cid:2)α s(cid:7) → φ(cid:5)(cid:4)(cid:7)sψ(s) thus identifies precisely those situations in which φ persists under α. Then for any situation term σ :D |(cid:3) R∗D(ψ)[σ ]iff(cid:6)D |(cid:3)n∈N(cid:7)(cid:8)D(φ, α)[σ ]PnIn other words, R∗D(ψ) is a uniform formula representing the fixpoint of applications of P 1D(φ, α)[s].Proof. The restrictions on ψ mean it is a regressable formula containing only situations of the form s and do([a1 . . . ai], s).R∗D(ψ) can therefore unwind these action terms and produce an equivalent formula uniform in s.Let M be a model of D − DS0 and μ an assignment to the free variables in φ. Adopting the technique used by Savelliinto a kind of infinite conjunction over the levels of the tree of(cid:7)in [28, Lemma 6], we can split the quantification over ssituations:M, μ |(cid:3) ∀s(cid:7): s (cid:2)α s(cid:7) → φ(cid:5)(cid:4)(cid:7)siffM, μ |(cid:3)(cid:13)(cid:6)n∈N∀a1 . . . an:n(cid:9)i=1(cid:2)(cid:2)ai, doα[a1 . . . ai−1], s(cid:3)(cid:3)(cid:2)(cid:4)do→ φ[a1 . . . an], s(cid:14)(cid:3)(cid:5)(A.2)Note that each element of the set (A.2) is a statement about all situations n actions into the future of s. Moreover, eachelement can be regressed to give a formula uniform in s.Now take the finite subset of (A.2) for n up to any natural number m. Clearly such a subset can be written as a finite(cid:13)(cid:6)∀a1 . . . an:(cid:2)(cid:2)ai, doα[a1 . . . ai−1], s(cid:3)(cid:3)(cid:2)(cid:4)do→ φ[a1 . . . an], s(cid:14)(cid:3)(cid:5)n(cid:9)i=1∀a1 . . . an:n(cid:9)i=1(cid:2)(cid:2)ai, doα[a1 . . . ai−1], s(cid:3)(cid:3)(cid:2)(cid:4)do→ φ[a1 . . . an], s(cid:3)(cid:5)(A.3)Eq. (A.3) precisely matches the form of the RHS of the equivalence in Theorem 1, so we can substitute to LHS to give:(cid:2)(cid:2)ai, doα[a1 . . . ai−1], s(cid:3)(cid:3)(cid:2)(cid:4)do→ φ[a1 . . . an], s(cid:14)(cid:3)(cid:5)M, μ |(cid:3)(cid:13)(cid:6)n(cid:2)m∀a1 . . . an:n(cid:9)i=1iffM, μ |(cid:3) PmD(φ, α)[s]conjunction:M, μ |(cid:3)iffM, μ |(cid:3)n(cid:2)m(cid:9)n(cid:2)m884R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888By definition PmD(φ, α) implies Pn(cid:13)M, μ |(cid:3)∀a1 . . . an:D(φ, α) for any n < m, so we have:(cid:2)[a1 . . . ai−1], s(cid:3)(cid:3)(cid:2)(cid:4)do→ φ[a1 . . . an], s(cid:14)(cid:3)(cid:5)(cid:2)ai, do(cid:6)n(cid:2)mn(cid:9)αi=1iffM, μ |(cid:3)(cid:6)(cid:7)(cid:8)D(φ, α)[s]Pnn(cid:2)mNoting that this construction works for any M, μ and m ∈ N gives the theorem as required. (cid:3)Theorem 5. Let D be such that all successor state axioms and action description predicates take the following restricted forms, where¯yi ⊆ ¯x and Φand Πα,i mention no terms other than ¯x and s:+/−F ,i(cid:2)(cid:3)¯x, do(a, s)F≡n(cid:12)i=1a = ai( ¯yi) ∧ Φ+F ,i(¯x, s) ∨ F (¯x, s) ∧ ¬n(cid:12)i=1a = ai( ¯yi) ∧ Φ−F ,iα(¯x, a, s) ≡n(cid:12)i=1a = ai( ¯yi) ∧ Πα,i¯x, s)Then for a quantifier-free uniform formula φ and any α, the persistence condition PD(φ, α) exists and can be calculated in finitelymany iterations.Proof. We will treat only the case where φ = F (¯x, s); the general case follows by induction on the structure of φ. CalculatingP 1D(F (¯x, s), α) gives:(cid:2)P 1DF (¯x, s), α(cid:3)= F (¯x, s) ∧ ∀a:(cid:15)n(cid:12)j=1a = a j( ¯y j) ∧ Φ+F ,i(¯x, s) ∨ F (¯x, s) ∧ ¬(cid:16)a = ai( ¯yi) ∧ Πα,i(¯x, s)→(cid:15)n(cid:12)i=1(cid:16)n(cid:12)j=1a = a j( ¯y j) ∧ Φ−F ,iIf we take the i-disjunction outside the implication, it becomes a conjunction over action types:(cid:2)P 1DF (¯x, s), α(cid:3)= F (¯x, s) ∧ ∀a:n(cid:9)(cid:15)a = ai( ¯yi) ∧ Πα,i(¯x, s) →i=1n(cid:12)i=1a = ai( ¯yi) ∧ Φ+F ,i(¯x, s) ∨ F (¯x, s) ∧ ¬(cid:16)n(cid:12)i=1a = ai( ¯yi) ∧ Φ−F ,iThis allows us to remove the quantification over a and eliminate the explicit references to ai to produce:(cid:2)P 1DF (¯x, s)α(cid:3)= F (¯x, s) ∧n(cid:9)(cid:2)i=1Πα,i(¯x, s) → Φ+F ,i(¯x, s) ∨ F (¯x, s) ∧ ¬Φ−F ,i(cid:3)Let terms(φ) denote the set of all terms mentioned in φ:(cid:2)(cid:3)F ( ¯τ , σ )termsdef= ¯τ ∪ {σ }terms(τi = τ j) def= (τi, τ j)terms(φi ∧ φ j) def= terms(φi) ∪ terms(φ j)terms(¬φ) def= terms(φ)+/−F ,iRecall that Φand Πα,i mention no terms other than ¯x and s, so:(cid:3)(cid:3)(cid:3)F (¯x, s)F (¯x, s), α= termsP 1D(cid:2)(cid:2)(cid:2)termsR.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888885And by induction, we have that for any n:(cid:2)(cid:3)F (¯x, s)terms= terms(cid:2)(cid:2)PnDF (¯x, s), α(cid:3)(cid:3)Since terms(F (¯x, s)) is finite, it follows that applications of P 1D to F (¯x, s) can only generate finitely many non-equiv-D thus operates over a finite subset of L(Dbg), which suffices to ensure the terminating calculation ofalent formulae. P 1PD(F (¯x, s), α). (cid:3)Theorem 6. Let D be a context-free domain with finitely many parameterless actions, then for any φ and α the persistence conditionPD(φ, α) exists and can be calculated in finitely many iterations.Proof. Following the notation used in [18], say that two situations have the same state if they satisfy precisely the samefluents:(cid:2)SameStates, sn(cid:9)(cid:2)(cid:3)(cid:7)def=i=1∀¯xi : F i(¯xi, s) ≡ F i(cid:3)(cid:3)(cid:2)(cid:7)¯xi, sObserve that such situations also satisfy the same uniform formulae:D |(cid:3) SameState(cid:2)s, s(cid:2)(cid:3)(cid:7)→φ[s] ≡ φ(cid:5)(cid:3)(cid:4)(cid:7)sLet (cid:20)do(ξ, S0)(cid:20) be the set of all situations that have the same state as do(ξ, S0) for a given sequence of actions ξ . By[18, Lemma 6.1] there are at most N distinct sets (cid:20)do(ξ, S0)(cid:20) for some natural number N.We show that Algorithm 1 terminates after at most N iterations. Suppose otherwise, i.e. suppose that there is a modelM of D and a variable assignment μ such that:D(φ, α)[s]M, μ |(cid:3) P NM, μ |(cid:3) ¬P N+1D (φ, α)[s]Then there must exist a sequence of actions [ A1 . . . A N+1] such that:M, μ |(cid:3) ¬φ(cid:2)(cid:4)do[ A1 . . . A N+1], s(cid:3)(cid:5)(A.4)(A.5)We will show that such a sequence cannot exist. First, assume that (cid:20)do([ A1 . . . Ai], s)(cid:20) is distinct for each i (cid:2) N. Sincethere are at most N such distinct states in the domain, (cid:20)do([ A1 . . . A N+1)(cid:20) must be the same as (cid:20)do([ A1 . . . Ai], s)(cid:20) forsome i. By (A.4) we have that φ[do([ A1 . . . Ai], s)] for any i (cid:2) N, and so (A.5) cannot hold.Alternately, assume that there is some i < j (cid:2) N such that:(cid:3)(cid:3)(cid:2)(cid:3)(cid:2)M, μ |(cid:3) SameState[ A1 . . . Ai], s, do[ A1 . . . A j], s(cid:2)doThen we can remove the redundant actions between i and j to get:M, μ |(cid:3) SameState(cid:2)(cid:2)do[ A1 . . . Ai, A j+1 . . . A N+1], s(cid:3)(cid:2), do[ A1 . . . A N+1], s(cid:3)(cid:3)By (A.4) we know that φ holds at do([ A1 . . . Ai, A j+1 . . . A N+1]), so (A.5) cannot hold and we have the desired contradic-tion.There can therefore be no such model M, and persistence to depth N suffices to establish persistence to any depth. (cid:3)Appendix B. Axioms for the “gold thief” domainThis section gives the axioms used for the “gold thief” example domain in Sections 3 and 7. In this domain a thief maytry to steal some gold from a safe. There is a light in the room, and a security camera that will detect the thief’s actions aslong as the light is on. The safe can be open or closed, but the gold can only be stolen if the safe is open. It is possible forthe thief to crack the safe and force it open, but only if the light is on.The actions in this domain are takeGold, crackSafe and toggleLight, the primitive fluents are SafeOpen, LightOn and Stolen,and the action description predicates include the standard Poss(a, s) and a custom predicate Undet(a, s) indicating thataction a would not be detected by the security camera.The successor state axioms Dssa consist of the following sentences:(cid:2)StolenSafeOpen(cid:2)LightOn(cid:3)do(a, s)(cid:2)(cid:3)do(a, s)(cid:3)do(a, s)≡ a = takeGold ∨ Stolen(s)≡ a = crackSafe ∨ SafeOpen(s)≡ a = toggleLight ∧ ¬LightOn(s) ∨ LightOn(s) ∧ a (cid:17)= toggleLight886R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888The action description predicates in Dad are defined by the following:Poss(a, s) ≡ a = toggleLight ∨ a = takeGold ∧ SafeOpen(s) ∨ a = crackSafe ∧ LightOn(s)Undet(a, s) ≡ Poss(a, s) ∧ a (cid:17)= toggleLight ∧ ¬LightOn(s)The background theory Dbg contains only the standard unique names assumptions for actions, and the initial situationaxioms DS0 are not specified since they are not used in the discussion.Appendix C. Complete calculation for the “gold thief” domainThis section presents complete details of the calculation of PD for the “gold thief” example as outlined in Section 7. Weneed to calculate:PD(¬Stolen, Undet)[σ ]To calculate this persistence condition we follow Algorithm 1, calculating PnD for successively larger values of n until theseries converges to a fixpoint. The case of n = 0 is trivial:P 0D(¬Stolen, Undet)[s] = ¬Stolen(s)The n = 1 case is given by Definition 7 as:P 1D(. . .)[s] = ¬Stolen(s) ∧ ∀a: RD(cid:2)(cid:3)Undet(a, s)(cid:2)→ RD¬Stolen(cid:2)(cid:3)(cid:3)do(a, s)Some straightforward simplifications can be applied at this stage. First, since there are finitely many actions in thisdomain, the ∀a quantification can be replaced with a finite conjunction:P 1D(. . .)[s] = ¬Stolen(s)(cid:2)(cid:2)(cid:2)∧ RD∧ RD∧ RD(cid:3)Undet(takeGold, s)(cid:2)→ RD(cid:3)Undet(crackSafe, s)→ RD(cid:3)Undet(toggleLight, s)→ RD(cid:2)(cid:3)(cid:3)¬Stolen(cid:2)¬Stolen(cid:2)do(takeGold, s)(cid:2)(cid:3)(cid:3)do(crackSafe, s)(cid:2)¬Stolendo(toggleLight, s)(cid:3)(cid:3)From the domain axioms we know that crackSafe and toggleLight do not affect whether the gold has been stolen, whiletakeGold will always make Stolen true. Performing the regression of ¬Stolen we thus obtain the following result:P 1D(. . .)[s] = ¬Stolen(s) ∧ RD∧ RD(cid:2)(cid:2)(cid:3)Undet(takeGold, s)(cid:3)Undet(crackSafe, s)→ ¬Stolen(s)(cid:3)→ ¬Stolen(s)Undet(toggleCam, s)(cid:2)→ ¬(cid:8)∧ RDSince the conjunction already contains ¬Stolen(s) unconditionally, we can simplify away the final three cases. We obtain:P 1D(. . .)[s] = ¬Stolen(s) ∧ ¬RD(cid:2)(cid:3)Undet(takeGold, s)Performing the remaining regression, we obtain the final result for P 1D :P 1D(. . .)[s] = ¬Stolen(s) ∧(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)Since this is clearly not entailed by the P 0expanding out each individual action, we get:D case, we must continue to the n = 2 case. Again applying Definition 7 andP 2D(. . .)[s] = ¬Stolen(s) ∧(cid:2)(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)(cid:3)Undet(takeGold, s)(cid:2)∧ RD(cid:4)¬SafeOpen∧(cid:2)→ RD(cid:3)do(takeGold, s)¬Stolen(cid:2)(cid:2)(cid:3)Undet(crackSafe, s)∧ RD(cid:4)¬SafeOpen∧(cid:2)→ RD(cid:3)do(crackSafe, s)(cid:2)∧ RD(cid:4)¬SafeOpen(cid:3)Undet(toggleLight, s)(cid:2)do(cid:3)toggleLight(s)∧(cid:2)∨ LightOn→ RD(¬Stolen(cid:2)∨ LightOn¬Stolen(cid:2)∨ LightOn(cid:2)(cid:2)(cid:3)do(takeGold, s)(cid:3)(cid:5)(cid:3)do(takeGold, s)(cid:2)(cid:3)do(crackSafe, s)(cid:3)(cid:5)(cid:3)do(crackSafe, s)(cid:2)(cid:3)do(toggleLight, s)(cid:3)(cid:5)(cid:3)do(toggleLight, s)R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888887Applying similar simplifications to the P 1D case, we can obtain:P 2D(. . .)[s] = ¬Stolen(s) ∧∧ RD∧ RD∧ RDFurther simplifying:(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)(cid:3)Undet(takeGold, s)→ ¬(cid:8) ∧(cid:3)Undet(crackSafe, s)→ ¬Stolen(s) ∧(cid:3)Undet(toggleLight, s)→ ¬Stolen(s) ∧(cid:2)(cid:2)(cid:2)(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)(cid:5)(cid:4)¬(cid:8) ∨ LightOn(s)(cid:4)(cid:5)¬SafeOpen(s) ∨ ¬LightOn(s)P 2D(. . .)[s] = ¬Stolen(s) ∧∧(cid:4)¬RD(cid:2)(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)∧ ¬RD(cid:2)(cid:3)Undet(takeGold, s)(cid:3)Undet(toggleLight, s)(cid:5)∨ ¬SafeOpen(s) ∨ ¬LightOn(s)Now performing the second regression:P 2D(. . .)[s] = ¬Stolen(s) ∧∧(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)(cid:5)(cid:4)¬⊥ ∨ ¬SafeOpen(s) ∨ ¬LightOn(s)Further simplification gives:P 2D(. . .)[s] = ¬Stolen(s) ∧(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)(cid:5)(cid:4)¬SafeOpen(s) ∨ LightOn(s)∧We have clearly satisfied the termination condition of Algorithm 1, since P 1D → P 2D . We have thus successfully calculatedthe persistence condition:PD(¬Stolen, Undet) = ¬Stolen ∧ [¬SafeOpen ∨ LightOn]References[1] Leopoldo E. Bertossi, Javier Pinto, Pablo Saez, Deepak Kapur, Mahadevan Subramaniam, Automating proofs of integrity constraints in situation calculus,in: Proceedings of the 9th International Symposium on Methodologies for Intelligent Systems, in: Lecture Notes in Artificial Intelligence, Springer, 1996,pp. 212–222.[2] Jens Claßen, Gerhard Lakemeyer, A logic for non-terminating Golog programs, in: Proceedings of the 11th International Conference on Principles ofKnowledge Representation and Reasoning (KR’08), 2008, pp. 589–599.[3] Patrick Cousot, Radhia Cousot, Constructive versions of Tarski’s fixed point theorems, Pacific Journal of Mathematics 82 (1) (1979) 43–57.[4] Giuseppe De Giacomo, Evgenia Ternovska, Ray Reiter, Non-terminating processes in the situation calculus, in: Proceedings of the AAAI’97 Workshopon Robots, Softbots, Immobots: Theories of Action, Planning and Control, 1997.[5] Alessandro Farinelli, Alberto Finzi, Thomas Lukasiewicz, Team programming in Golog under partial observability, in: Proceedings of the 20th Interna-tional Joint Conference on Artificial Intelligence (IJCAI’07), 2007, pp. 2097–2012.[6] A. Ferrein, Ch. Fritz, G. Lakemeyer, Using Golog for deliberation and team coordination in robotic soccer, Kunstliche Intelligenz I (2005) 24–43.[7] Maria Fox, Derek Long, The automatic inference of state invariants in TIM, Journal of Artificial Intelligence Research 9 (1998) 367–421.[8] Alfonso Gerevini, Lenhart K. Schubert, Discovering state constraints in DISCOPLAN: Some new results, in: Proceedings of the Seventeenth NationalConference on Artificial Intelligence (AAAI), 2000, pp. 761–767.[9] Hojjat Ghaderi, Hector Levesque, Yves Lespérance, A logical theory of coordination and joint ability, in: Proceedings of the 22nd AAAI Conference onArtificial Intelligence (AAAI’07), 2007, pp. 421–426.[10] Yilian Gu, Mikhail Soutchanski, Decidable reasoning in a modified situation calculus, in: Proceedings of the 20th International Joint Conference onArtificial Intelligence (IJCAI’07), 2007, pp. 1891–1897.[11] Mayu Ishida, Reasoning about actions: A model-theoretic approach, Masters’ thesis in computer science, School of Computing Science, Simon FraserUniversity, 2002.[12] L. Kalantari, E. Ternovska, A model checker for verifying ConGolog programs, in: Proceedings of the 18th AAAI Conference on Artificial Intelligence(AAAI’02), 2002.[13] Ryan Kelly, Asynchronous multi-agent reasoning in the situation calculus, PhD thesis, Department of Computer Science and Software Engineering, TheUniversity of Melbourne, Melbourne, Victoria, Australia, 2008.[14] Ryan F. Kelly, Adrian R. Pearce, Knowledge and observations in the situation calculus, in: Proceedings of the 6th International Joint Conference onAutonomous Agents and Multi-Agent Systems (AAMAS’07), 2007, pp. 841–843.[15] Ryan F. Kelly, Adrian R. Pearce, Property persistence in the situation calculus, in: Proceedings of the 20th International Joint Conference on ArtificialIntelligence (IJCAI’07), 2007, pp. 1948–1953.[16] H. Levesque, F. Pirri, R. Reiter, Foundations for the situation calculus, Electronic Transactions on Artificial Intelligence 2 (3–4) (1998) 159–178.[17] Hector J. Levesque, Ray Reiter, Yves Lespérance, Lin Fangzhen, Richard B. Scherl, GOLOG: A logic programming language for dynamic domains, Journalof Logic Programming 31 (1–3) (1997) 59–83.[18] F. Lin, H. Levesque, What robots can do: Robot programs and effective achievability, Artificial Intelligence 101 (1998) 201–226.[19] Lin Fangzhen, Ray Reiter, State constraints revisited, Journal of Logic and Computation 4 (5) (1994) 655–678.[20] Lin Fangzhen, Ray Reiter, How to progress a database, Artificial Intelligence 92 (1997) 131–167.[21] Yongmei Liu, Gerhard Lakemeyer, On first-order definability and computability of progression for local-effect actions and beyond, in: Proceedings ofthe 21st International Joint Conference on Artificial Intelligence (IJCAI’09), 2009, pp. 860–866.[22] John McCarthy, Patrick J. Hayes, Some philosophical problems from the standpoint of artificial intelligence, in: B. Meltzer, D. Michie (Eds.), MachineIntelligence, vol. 4, Edinburgh University Press, 1969, pp. 463–502.[23] Fiora Pirri, Ray Reiter, Some contributions to the metatheory of the situation calculus, Journal of the ACM 46 (3) (1999) 325–361.[24] Ray Reiter, Proving properties of states in the situation calculus, Artificial Intelligence 64 (1993) 337–351.888R.F. Kelly, A.R. Pearce / Artificial Intelligence 174 (2010) 865–888[25] Ray Reiter, Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems, The MIT Press, 2001.[26] Ray Reiter, The frame problem in situation the calculus: A simple solution (sometimes) and a completeness result for goal regression, in: VladimirLifschitz (Ed.), Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, Academic Press Professional, Inc.,1991, pp. 359–380.[27] Sebastian Sardina, Giuseppe De Giacomo, Yves Lespénce, Hector Levesque, On the semantics of deliberation in IndiGolog – from theory to implemen-tation, Annals of Mathematics and Artificial Intelligence 41 (2–4) (August 2004) 259–299.[28] Francesco Savelli, Existential assertions and quantum levels on the tree of the situation calculus, Artificial Intelligence 170 (6) (2006) 643–652.[29] Richard Scherl, Hector Levesque, Knowledge, action, and the frame problem, Artificial Intelligence 144 (2003) 1–39.[30] Steven Shapiro, Yves Lespérance, Hector J. Levesque, The cognitive agents specification language and verification environment for multiagent systems,in: Proceedings of the 1st International Joint Conference on Autonomous Agents and Multi-Agent Systems (AAMAS’02), 2002, pp. 19–26.[31] E. Ternovska, Automata theory for reasoning about actions, in: Proceedings of the 16th International Joint Conference on Artificial Intelligence (IJCAI’99),1999, pp. 153–158.[32] Johan van Benthem, Eric Pacuit, The tree of knowledge in action: Towards a common perspective, Advances in Modal Logic 6 (2006) 87–106.[33] Hans van Ditmarsch, Andreas Herzig, Tiago de Lima, Optimal regression for reasoning about knowledge and actions, in: Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence, 2007, pp. 1070–1075.[34] Stavros Vassos, Hector Levesque, On the progression of situation calculus basic action theories: Resolving a 10-year-old conjecture, in: Proceedings ofthe 23rd AAAI Conference on Artificial Intelligence (AAAI’08), 2008, pp. 1004–1009.[35] Stavros Vassos, Gerhard Lakemeyer, Hector J. Levesque, First-order strong progression for local-effect basic action theories, in: Proceedings of the 11thInternational Conference on Principles of Knowledge Representation and Reasoning (KR’08), 2008, pp. 662–671.