Artificial Intelligence 175 (2011) 1570–1603Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintInconsistent heuristics in theory and practiceAriel Felner a,∗Zhifu Zhang c, Uzi Zahavi b, Robert Holte c, Jonathan Schaeffer c, Nathan Sturtevant c,a Department of Information Systems Engineering, Ben-Gurion University of the Negev, Beer-Sheva 85104, Israelb Department of Computer Science, Bar-Ilan University, Ramat-Gan 52900, Israelc Department of Computing Science, University of Alberta, Edmonton, Alberta, T6G2E8, Canadaa r t i c l ei n f oa b s t r a c tArticle history:Received 26 July 2010Received in revised form 10 February 2011Accepted 10 February 2011Available online 18 February 2011Keywords:Heuristic searchAdmissible heuristicsInconsistent heuristics∗AIDA∗1. Introduction and overview.In the field of heuristic search it is usually assumed that admissible heuristics areconsistent,implying that consistency is a desirable attribute. The term “inconsistentheuristic” has, at times, been portrayed negatively, as something to be avoided. Part of thisis historical: early research discovered that inconsistency can lead to poor performance∗(nodes might be re-expanded many times). However, the issue has never been fullyfor A∗investigated, and was not re-considered after the invention of IDAThis paper shows that many of the preconceived notions about inconsistent heuristicsare outdated. The worst-case exponential time of inconsistent heuristics is shown to onlyoccur on contrived graphs with edge weights that are exponential in the size of the graph.Furthermore, the paper shows that rather than being something to be avoided, inconsistentheuristics often add a diversity of heuristic values into a search which can lead to areduction in the number of node expansions. Inconsistent heuristics are easy to create,contrary to the common perception in the AI literature. To demonstrate this, a number ofmethods for achieving effective inconsistent heuristics are presented.Pathmax is a way of propagating inconsistent heuristic values in the search from parentto children. This technique is generalized into bidirectional pathmax (BPMX) whichpropagates values from a parent to a child node, and vice versa. BPMX can be integrated∗. When inconsistent heuristics are used with BPMX, experimental resultsinto IDA. Positive results are alsoshow a large reduction in the search effort required by IDApresented for Asearches.and A∗∗∗© 2011 Elsevier B.V. All rights reserved.Heuristic search algorithms such as A[22] are guided by the cost function f (n) = g(n) + h(n), where g(n)is the cost of the current path from the start node to node n and h(n) is a heuristic function estimating the cost from n toa goal node. If h(n) is admissible (i.e., is always a lower bound) these algorithms are guaranteed to find optimal paths.∗[15] and IDA∗The Aalgorithm is guaranteed to return an optimal solution only if an admissible heuristic is used. There is no re-quirement that the heuristic be consistent.1 It is usually assumed that admissible heuristics are consistent. In their popularAI textbook Artificial Intelligence: A Modern Approach, Russell and Norvig write that “one has to work quite hard to concoct∗* Corresponding author.E-mail addresses: felner@bgu.ac.il (A. Felner), zahaviu@biu.ac.il (U. Zahavi), holte@cs.ualberta.ca (R. Holte), jonathan@cs.ualberta.ca (J. Schaeffer),nathanst@cs.ualberta.ca (N. Sturtevant), zhang@cs.ualberta.ca (Z. Zhang).1 A heuristic is consistent if for every two states x and y, h(x) (cid:2) c(x, y) + h( y) where c(x, y) is the cost of the shortest path between x and y. Derivationsand definitions of consistent and inconsistent heuristics are provided in Section 3.0004-3702/$ – see front matter © 2011 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2011.02.001A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031571heuristics that are admissible but not consistent” [38]. Many researchers work under the assumption that “almost all admis-sible heuristics are consistent” [25]. Some algorithms require that the heuristic be consistent (such as Frontier A[30], whichsearches without the closed list).2 The term “inconsistent heuristic” has, at times, been portrayed negatively, as somethingthat should be avoided. Part of this is historical: early research discovered that inconsistency can lead to poor performance∗for A. However, the issue of inconsistent heuristics has never been fully investigated or re-considered after the invention of∗IDA. This paper argues that these perceptions about inconsistent heuristics are wrong. We show that inconsistent heuris-tics have many benefits. Further, they can be used in practice for many search domains. We observe that many recentlydeveloped heuristics are inconsistent.∗A known problem with inconsistent heuristics is that they may cause algorithms like Ato find shorter paths to nodesthat were previously expanded and inserted into the closed list. If this happens, then these nodes must be moved back tothe open list, where they might be chosen for expansion again. This phenomenon is known as node re-expansion. Awith aninconsistent heuristic may perform an exponential number of node re-expansions [32]. We present insights into this phe-nomenon, showing that the exponential time behavior only appears in contrived graphs where edge weights and heuristicvalues grow exponentially with the graph size. For IDA, it is important to note that node re-expansion is inevitable due tothe algorithm’s depth-first search. The use of an inconsistent heuristic does not exacerbate this. Because no history of pre-whether the heuristic is consistentvious searches is maintained, each separate path to the node will be examined by IDAor not.∗∗∗∗Inconsistent heuristics often add a diversity of heuristic values into a search. We show that these values can be used toescape heuristic depressions (regions of the search space with low heuristic values), and can lead to a large reduction in thesearch effort. Part of this is achieved by our generalization of pathmax into bidirectional pathmax. The idea of pathmax wasintroduced by Mero [34] as a method for propagating inconsistent values in the search from a parent node to its children.Pathmax causes the f -values of nodes to be monotonic non-decreasing along any path in the search tree. The pathmax ideafor undirected state spaces is generalized into bidirectional pathmax (BPMX). BPMX propagates values in a similar mannerto pathmax, but does this in both directions (parent to child, and child to parent). BPMX turns out to be more effective∗than pathmax in practice. It can easily be integrated into IDA. Using BPMX, thepropagation of inconsistent values allows a search to escape from heuristic depressions more quickly.and, with slightly more effort, into A∗Trivially, one can create an inconsistent heuristics by taking a consistent heuristic and degrading some of its values. Theresulting heuristic will be less informed. Contrary to the perception in the literature, informed inconsistent heuristics areeasy to create. General guidelines as well as a number of simple methods for creating effective inconsistent heuristics areprovided. The characteristics of inconsistent heuristics are analyzed to provide insights into how to effectively use them tofurther reduce the search effort.Finally, experimental results show that using inconsistent heuristics with BPMX yields a significant reduction in the-based search applications. The application domains used are the sliding-tile∗search effort required for many IDApuzzle, Pancake problem, Rubik’s cube, TopSpin and pathfinding in maps.∗- and AThe paper is organized as follows. In Section 2 we provide background material. Section 3 defines consistent and in-consistent heuristics. Section 4 presents a study of the behavior of Awith inconsistent heuristics. BPMX is introduced inSection 5 and its attributes when used with inconsistent heuristics are studied. Methods for creating inconsistent heuristicsare discussed in Section 6. Extensive experimental results for IDAare provided in Sections 7 and 8, respectively.Finally we provide our conclusions in Section 9.∗and for A∗∗Portions of this work have been previously published [14,21,44–47]. This paper summarizes this line of work and tiestogether all the results. In addition new experimental results are provided.2. Terminology and backgroundThis section presents terminology and background material used for this research.2.1. TerminologyThroughout the paper the following terminology is used. A state space is a graph whose vertices are called states. Theexecution of a search algorithm (e.g., A) from an initial state creates a search graph. A search tree spans that graphaccording to the progress of the search algorithm. The term node is used throughout this paper to refer to the nodes of thesearch tree. Each node in the search tree corresponds to some state in the state space. The search tree may contain nodesthat correspond to the same state (via different paths). These are called duplicates.∗and IDA∗The fundamental operation in a search algorithm is to expand a node (i.e., to compute or generate the node’s successorsin the search tree). We assume that each node expansion takes the same amount of time. This allows us to measure thetime complexity of the algorithms in terms of the total number of node expansions performed by the algorithm in solving∗2 The breadth-first heuristic search algorithm [49], a competitor to Frontier A, does not have this requirement and works with inconsistent heuristicstoo.1572A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 1. 3 × 3 × 3 Rubik’s cube.a given problem.3 The space complexity of a search algorithm is measured in terms of the number of nodes that need tobe stored simultaneously.A second measure of interest is the number of unique states that are expanded at least once during the search. Thephrase number of distinct expanded states refers to this measure and is denoted by N.The term c(x, y) is used to denote the cost of a shortest path from x to y. In addition, h(x) denotes an admissible∗(x) denotes the cost of the shortest path from x to a goal ( = c(x, goal)).heuristic from x to a goal while h2.2. Search algorithms∗The A∗Aalgorithm is a best-first search algorithm [15]. It keeps an open list of nodes (denoted hereafter as OPEN), usuallyimplemented as a priority queue, which is initialized with the start state node. At each expansion step of the algorithm,a node of minimal cost is extracted from OPEN and its children are generated and added to OPEN. The expanded node isinserted into the closed list (denoted hereafter as CLOSED). The algorithm halts when a goal node is chosen for expansion.∗Aemploys a duplicate detection mechanism and stores at most one node for any given state. Before a node is added toOPEN it is first matched against both OPEN and CLOSED. If a duplicate node (node with the same state) is found in OPENthen only the node with the smaller g-value is kept in OPEN. If the duplicate node is found in CLOSED with a smalleror equal g-value, the newly generated node is ignored. If the node is found in CLOSED with a larger g-value, the copy inCLOSED is removed and the copy with the smaller g-value is added to OPEN.is an iterative-deepening version of Arequires memory linear in the number of distinct states expanded.uses the cost function f (n) = g(n) + h(n), where g(n) is the cost of reaching node n from the start node (via the bestknown path) and h(n) is an estimate of the remaining distance from n to the goal. If h(n) is admissible (i.e., its estimate∗is guaranteed to return a shortest path solution if one exists [6].is always a lower bound on the actual distance) then Ahas been proven to be admissible, complete, and optimally effective [6]. WithFurthermore, with a consistent heuristic, Aan inconsistent heuristic, Ais optimal with respect to the number of distinct states expanded, N, but may re-expand nodesmany times. A∗IDA[22]. It performs a series of depth-first searches, each to an increasingsolution-cost threshold T . T is initially set to h(s), where s is the start node. If the goal is found within the threshold,proceeds to the next iteration by increasing T to the minimum f -value thatthe search ends successfully. Otherwise, IDA, even when the given heuristic is consistent,exceeded T in the previous iteration. The worst-case time complexity of IDAis O (N 2) on trees, O (22N ) on directed acyclic graphs [31], and Ω(N!) on cyclic or undirected graphs. The space complexity∗is O (bd) where b is the maximum branching factor and d is the maximum depth of the search (number of edgesof IDAis effectively used to solvetraversed from the root to the goal). Despite these worst-case time bounds, in practice, IDAmany combinatorial problems, especially ones whose state spaces do not have many small cycles. Due to its modest space∗complexity, IDAexhausts available memory before arriving at a solution.can solve problems for which A∗∗∗∗∗∗∗∗2.3. ApplicationsWe now provide an overview of the application domains used in this paper.2.3.1. Rubik’s cubeRubik’s cube was invented in 1974 by Ern ˝o Rubik of Hungary. The standard version consists of a 3 × 3 × 3 cube (Fig. 1),with different colored stickers on each of the exposed squares of the sub-cubes, or cubies. There are 20 movable cubiesand six stable cubies in the center of each face. The movable cubies can be divided into eight corner cubies, with threefaces each, and twelve edge cubies, with two faces each. Corner cubies can only move among corner positions, and edgecubies can only move among edge positions. There are about 4 × 1019 different reachable states. In the goal state, all thesquares on each side of the cube are the same color. Pruning redundant moves results in a search tree with an asymptoticbranching factor of about 13.34847 [24].4 Pattern databases (PDBs, see below) are an effective and commonly-used heuristicthis domain.3 In experiments with IDA∗, it is common to report the number of generated nodes instead of the number of node expansions. We follow this practice∗in our IDAexperiments.4 We adopt the same setting first used by Korf [24] where both 90-degree and 180-degree rotation of a face count as a legal move.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031573Fig. 2. (20, 4)-TopSpin puzzle.Fig. 3. The 8-, 15- and 24-puzzle goal states.2.3.2. TopSpin puzzleThe (n, r)-TopSpin puzzle has n tokens arranged in a ring (see Fig. 2). The ring of tokens can be shifted cyclically clockwiseor counterclockwise. The tokens pass through the reverse circle which is fixed in the top of the ring. At any given time rtokens are located inside the reverse circle. These tokens can be reversed (rotated 180 degrees). The task is to rearrangethe puzzle such that the tokens are sorted in increasing order. The (20, 4) version of the puzzle is shown in Fig. 2 in itsgoal position where tokens 19, 20, 1 and 2 are in the reverse circle and can be reversed. We used the classic encoding ofthis puzzle which has N operators, one for each clockwise circular shift of length 0 . . . N − 1 of the entire ring followed bya reversal/rotation for the tokens in the reverse circle [4]. Each operator has a cost of one. Note that there are n! differentways to permute the tokens. However, since the puzzle is cyclic, only the relative location of the different tokens matters,and thus there are only (n − 1)! unique states. PDBs are an effective heuristic for this puzzle.2.3.3. The sliding-tile puzzlesOne of the classic examples of a single-agent path-finding problem in the AI literature is the sliding-tile puzzle. Threecommon versions of this puzzle are the 3 × 3 8-puzzle, the 4 × 4 15-puzzle and the 5 × 5 24-puzzle. They consist of asquare frame containing a set of numbered square tiles, and an empty position called the blank. The legal operators are toslide any tile that is horizontally or vertically adjacent to the blank into the blank’s position. The objective is to rearrangethe tiles from some random initial solvable configuration into a particular desired goal configuration. The state space growsexponentially in size as the number of tiles increases, and it has been shown that finding optimal solutions to the sliding-tile puzzle is NP-complete [37]. The 8-puzzle contains 9!/2 (181 440) reachable states, the 15-puzzle contains about 1013reachable states, and the 24-puzzle contains almost 1025 states. The goal states of these puzzles are shown in Fig. 3.The classic admissible heuristic function for the sliding-tile puzzles is called Manhattan Distance. It is computed bycounting the number of grid units that each tile is displaced from its goal position, and summing these values over all tiles,excluding the blank. PDBs provide the best existing admissible heuristics for this problem.2.3.4. The pancake puzzleThe pancake puzzle is inspired by a waiter navigating a busy restaurant with a stack of n pancakes [8]. The waiter wantsto sort the pancakes ordered by size, to deliver the pancakes in a pleasing visual presentation. Having only one free hand,the only available operation is to lift a top portion of the stack and reverse it. In this domain, a state is a permutationof the values 0 . . . (n − 1). A state has n − 1 successors, with the kth successor formed by reversing the order of the firstk + 1 elements of the permutation (0 < k (cid:2) n − 1). For example, if n = 5 the successors of the goal state (cid:3)0, 1, 2, 3, 4(cid:4) are(cid:3)1, 0, 2, 3, 4(cid:4), (cid:3)2, 1, 0, 3, 4(cid:4), (cid:3)3, 2, 1, 0, 4(cid:4) and (cid:3)4, 3, 2, 1, 0(cid:4), as shown in Fig. 4. From any state it is possible to reach any other1574A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 4. The 5-pancake puzzle.permutation, so the size of the state space is n!. In this domain, every operator is applicable to every state. Hence it has aconstant branching factor of n − 1. PDBs are a well-informed and commonly-used heuristic for this domain.5Fig. 5. Sample game map.2.3.5. PathfindingA map is an m ×n grid of passable areas and obstacles. There are eight possible movements from a position—four cardinalmoves and four diagonal moves—subject to obstacles and boundary conditions. Cardinal moves have cost 1, and diagonal2. Fig. 5 shows one of the maps used in our experiments (a 512 × 512 grid). The goal is, for instance, tomoves have costmove from point A to point B in the fewest number of moves, traversing only the light area. In general, for this applicationthe best heuristic depends on properties of the domain.√2.4. Pattern database heuristicsThe efficiency of a single-agent search algorithm is largely dictated by the quality of the heuristic used. An effective andcommonly-used heuristic for most of the application domains used in this paper are memory- or table-based heuristics.The largest body of work on these heuristics is on pattern databases [5] (PDBs). PDBs are therefore used in most of ourexperimental studies, and the purpose of this section is to give the background details. However, it is important to note5 The best heuristic known for this puzzle is called the gap heuristic [16] and uses domain-dependent attributes.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031575Fig. 6. States in the state space are mapped to patterns in the abstract space.Fig. 7. Example of regular PDB lookups.that none of this paper’s key ideas (inconsistency, BPMX, etc.) depend on the heuristic being a PDB; these ideas apply toheuristics of all forms. PDB heuristics allow us to achieve state-of-the-art performance for some of our application domains.PDBs are built as follows.6 The state space of a permutation problem represents all the different ways of placing a givenset of objects into a given set of locations (i.e., all the possible states). A subproblem is an abstraction of the original problemdefined by only considering some of these objects while treating the others as irrelevant (“don’t care”). A pattern (abstractstate) is a specific assignment of locations to the objects of the subproblem. The pattern space or abstract space is the set ofall the different reachable patterns of a given abstract problem.Each state in the original state space is abstracted to a state in the pattern space by only considering the pattern objects,and ignoring the others. The goal pattern is the abstraction of the goal state. As illustrated in Fig. 6, there is an edge betweentwo different patterns p1 and p2 in the pattern space if there exist two states s1 and s2 of the original problem such thatp1 is the abstraction of s1, p2 is the abstraction of s2, and there is an operator in the original problem space that connectss1 to s2.A pattern database (PDB) is a lookup table that stores the distance of each pattern to the goal pattern in the patternspace. A PDB is built by running a breadth-first search7 backwards from the goal pattern until the entire pattern space isspanned. A state s in the original space is mapped to a pattern p by ignoring all details in the state description that are notpreserved in the pattern. The value stored in the PDB for p is a lower bound (and thus serves as an admissible heuristic)on the distance of s to the goal state in the original space since the pattern space is an abstraction of the original space.Pattern databases have proven to be a powerful technique for finding effective lower bounds for numerous combinatorialpuzzle domains [24,5,26,10,11]. Furthermore, they have also proved to be useful for other search problems (e.g., multiplesequence alignment [33,48] and planning [9]).2.4.1. Pattern database examplePDBs can be built for the sliding-tile puzzles as illustrated in Fig. 7. Assume that the subproblem is defined to only includetiles 2, 3, 6 and 7; all the tiles are ignored except for 2, 3, 6 and 7. The resulting {2–3–6–7}-PDB has an entry for eachpattern containing the distance from that pattern to the goal pattern (shown in Fig. 7(d)). Fig. 7(b,d) depicts the PDB lookupfor estimating a distance from a given state S (Fig. 7(a)) to the goal (Fig. 7(c)). State S is mapped to a 2-3-6-7 pattern by6 We give a definition of PDBs which is specific to permutation state spaces, since these are used in this paper. However, PDBs can be built for a muchwider set of state spaces and abstractions (e.g., planning domains [9] or other combinatorial problems [10,33]).7 This description assumes all operators have the same cost. Uniform cost search should be used in cases where operators have different costs.1576A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 8. Partitionings and reflections of the tile puzzles.ignoring all the tiles other than 2, 3, 6 and 7 (Fig. 7(b)). Then, this pattern’s distance to the goal pattern (Fig. 7(d)) is lookedup in the PDB. To be specific, if the PDB is represented as a 4-dimensional array, PDB[ ][ ][ ][ ], with the array indexes beingthe locations of tiles 2, 3, 6, and 7, respectively, then the lookup for state S is PDB[8][12][13][14] (tile 2 is in location 8,tile 3 in location 12, etc.).As another example, consider only the eight cubies of the yellow face in Rubik’s cube. A “yellow face” PDB will store thedistances for all configurations of the “yellow” cubies to their goal location. These distances are admissible heuristics for thecomplete set of cubies.2.4.2. Additive PDBsThe best existing method for optimally solving the sliding-tile puzzles uses disjoint additive pattern databases [10,26]. Thetiles are partitioned into disjoint sets, and a PDB is built for each set. An x– y–z partitioning is a partition of the tiles intodisjoint sets with cardinalities x, y and z. We build a PDB for each set which stores the cost of moving the tiles in thepattern set from any given arrangement to their goal positions. For each such PDB, moves of tiles in the other sets are notcounted. The important attribute is that each move of the puzzle changes the location of one tile only. Since for each setof pattern tiles we only count moves of the pattern tiles, and each move only moves one tile, values from different disjointPDBs can be added together and the results are still admissible. Fig. 8 presents the two 7–8 partitionings for the 15-puzzleand the two 6–6–6–6 partitionings for the 24-puzzle that were first used in the context of additive PDBs [10,26].3. Consistent and inconsistent heuristicsAdmissibility is a desirable property for a heuristic since it guarantees that the solution returned by Awill beoptimal. Another attribute for a heuristic is that it can be consistent. An admissible heuristic h is consistent if, for every twostates x and y, if there is a path from x to y, then∗∗and IDAh(x) (cid:2) c(x, y) + h( y)(1)where c(x, y) is the cost of the least-cost path from x to y [15]. This is a kind of triangle inequality: the estimated distanceto the goal from x cannot be reduced by moving to a different state y and adding the estimate of the distance to the goalfrom y to the cost of reaching y from x. Pearl [36] showed that restricting y to be a neighbor of x produces an equivalentdefinition with an intuitive interpretation: in moving from a state to its neighbor, h must not decrease more than thecost of the edge that connects them. This means that the cost function f (n) = g(n) + h(n) is always non-decreasing alongany given path in the search graph. We call this the monotonicity8 of the cost function f , which is guaranteed when his consistent. Note that consistency is a property of the heuristic h while monotonicity is a property of the cost functionf (n) = g(n) + h(n). In Section 5 we will show different methods for enforcing monotonicity and consistency.If the graph is undirected then the cost of going from x to y is the same as from y to x. Since the heuristic is consistentwe also get thath( y) (cid:2) c( y, x) + h(x).Merging Eqs. (1) and (2) yields an alternative definition for consistent heuristics for undirected state spaces:(cid:2)(cid:2)(cid:2)h(x) − h( y)(cid:2) (cid:2) c(x, y).(2)(3)This inequality means that when moving from a parent to a child in a search tree, the heuristic h cannot increase ordecrease more than the change in g.3.1. Inconsistent heuristicsAn admissible heuristic h is inconsistent if for at least one pair of states x and y,h(x) > c(x, y) + h( y).(4)8 Pearl [36] used the term monotonicity in a different sense.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031577Fig. 9. Inconsistent heuristic.Fig. 10. Re-expanding of nodes by A∗.If y is a successor of x, the f -value will decrease when moving from x to y. The cost function fin this case is referredto as a non-monotonic cost function.Similar to the reasoning above, for undirected graphs a heuristic is inconsistent if for at least one pair of states x and y(cid:2)(cid:2)(cid:2)h(x) − h( y)(cid:2) > c(x, y).(5)This means that the difference between the heuristic values of x and y is larger than the actual cost of going from x to y.According to this definition there are two types of inconsistencies in undirected search graphs; both are shown in Fig. 9.As in all figures in the paper, the number inside a node is its admissible h-value. An edge is generally labeled with its cost.• Type 1: h decreases from parent to child. The parent node p has f (p) = g(p) + h(p) = 5 + 5 = 10. Since the heuristic isadmissible, any path from the start node to the goal node that passes through p has a cost of at least 10. Since theedge from p to c1 has a cost of 1, f (c1) = g(c1) + h(c1) = 6 + 2 = 8. This is a lower bound on the total cost of reachingthe goal through c1. This is weaker than the lower bound from the parent (which is valid for all its children). Thus theinformation provided by evaluating c1 is “inconsistent” (in the sense that they do not agree) with the information fromits parent p. In this case fis non-monotonic when moving from p to c1.• Type 2: h increases from parent to child. Node c2 presents another possible case for inconsistency, although this case isonly inconsistent because the graph is undirected. Here the heuristic increased from 5 to 8 while the cost of the edgeis still monotonic increasing from p ( f = 10) to c2 ( f = 14). However the increase ofwas only 1. The cost function fthe h-value is larger than the increase of the g-value. Note that since the graph is undirected there is also an edge fromc2 to p. Hence, logically p is also one of the children of c2. In this second occurrence of p, the f -value will decreasefrom 14 to 12 and is non-monotonic. Thus, the historical claim (e.g., of Pearl [36]) that consistency is equivalent tomonotonicity is technically correct.9The difference between the two types of inconsistency is important because later we will show that the pathmax prop-agation deals with Type 1 and corrects heuristics to be monotonic while our new bidirectional pathmax (BPMX) describedbelow also deals with Type 2 and can cause the heuristic to be fully consistent. Note that the “good” behavior of consistentheuristics (e.g., that they do not re-expand nodes) usually comes from the cost function f being monotonic.3.2. Inconsistent heuristics in A∗and in IDA∗∗Assume that a state can be reached from the start state by multiple paths, each with a possibly different cost. Whenever, it is first matched against OPEN and CLOSED and if a duplicate is found, the copy with the largera node is generated by Ag-value is ignored. If a consistent heuristic is used then f is monotonic and all ancestors of a node n have f -values less than(e.g., with f (n) = K ) it always has the optimal g-valueor equal to f (n). Therefore, the first time a node n is expanded by Aamong all possible paths from the start to n. Otherwise, one of the ancestors of n along the optimal path to n must be inOPEN, but its f -value must be smaller than K so it must have been expanded prior to n. As a consequence, when a node isexpanded and moved to CLOSED it will never be chosen for expansion again. By contrast, with inconsistent heuristics wherethe f -function is non-monotonic, Amay re-expand nodes when they are reached via a lower cost path. A simple exampleof this is shown in Fig. 10. Nodes b and c will be generated when the start node a is expanded with f (b) = 1 + 6 = 7and f (c) = 3 + 1 = 4. Next, node c will be expanded, and the goal is discovered with an f -value of 8. Since b has a lowerf -value, it will be expanded next, resulting in a lower cost path to c. This operation is referred to as the re-opening of nodes∗∗9 In practical applications it is a common practice (known as parent pruning) not to list the parent of a node as one of its children. In such cases theheuristic can be inconsistent according to Eq. (5) but the corresponding f -function is still monotonic. In practice, a full search tree where inconsistenciesare only due to this second case (and the cost function fis always monotonic) is probably rather rare. Therefore, in the reminder of this paper we willgenerally assume that all inconsistent heuristics produce a cost function f that is non-monotonic.1578A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 11. G 5 in Martelli’s family.(c in our case), since nodes from CLOSED are re-opened and moved back to OPEN. Now, c will be re-expanded with a lowerg-cost, and a lower cost path of length 7 to the goal will be found. So, with Athe use of inconsistent heuristics comeswith a real risk of many more node expansions than with a consistent heuristic. As the next section shows, this risk is notnearly as great as was previously thought. In a later section our experiments show that inconsistent heuristics can actually∗speed up an A∗IDA∗, as a depth-first search (DFS) algorithm, does not perform duplicate detection.10 Using IDAon the state space inFig. 10, node c will also be expanded twice (once for each of the paths) whether the heuristic is consistent or not. Thus,∗, and using inconsistent heuristics will not result in any additionalthe problem of re-expanding nodes already exists in IDAperformance degradation.search.∗4. Worst-case behavior of A∗with inconsistent heuristics∗This section presents an analysis of the worst-case time complexity of AIf the heuristic is admissible and consistent, A∗However, as just explained, if the heuristic is admissible but not consistent, nodes can be re-opened and Aas O (2N ) node expansions, where N is the number of distinct expanded states. This was proven by Martelli [32].is “optimal” in terms of the number of node expansions ([36], p. 85).can do as many∗when inconsistent heuristics are used.4.1. The G i family of state spacesMartelli defined a family of state spaces {G i}, for all i (cid:3) 3, such that G i contains i + 1 states and requires Ato doO (2i) node expansions to find the solution [32]. G 5 from Martelli’s family is shown in Fig. 11; the number inside a stateis its heuristic value and the number beside an edge is its cost. There are many inconsistencies in this graph. For example,c(n4, n3) = 1 but h(n4) − h(n3) = 6. The unique optimal path from the start (n5) to the goal (n0) has the states in decreasingorder of their index (n5, n4, . . . , n0), but n4 has a large enough heuristic value ( f (n4) = 14) that it will not be expanded by∗until all possible paths to the goal (with f < 14) involving all the other states have been fully explored. Thus, when n4Ais expanded, nodes n3, n2 and n1 are re-opened and then expanded again. The sequence of node expansions until reachingthe goal, with the f -values shown inside the parentheses, is as follows: n5(23), n1(11), n2(12), n1(10), n3(13), n1(9), n2(10),n1(8), n4(14), n1(7), n2(8), n1(6), n3(9), n1(5), n2(6), n1(4). Note that after n4 is expanded the entire sequence of expansionsthat occurred prior to the expansion of n4 is repeated but this time all these nodes are examined via paths through n4.Thus, the existence of n4 in G 5 essentially doubles the search effort required for G 4. This property holds for each ni sothe total amount of work is O (2i). As we will show below, this worst-case behavior hinges on the state space having theproperties that the edge weights and heuristic values grow exponentially with the number of states (as is clearly seen inthe definition of Martelli’s state spaces).∗4.2. Variants of A∗∗∗, called B, that improves upon AMartelli devised a variant of A’s worst-case time complexity while maintaining admis-sibility [32]. algorithm B maintains a global variable F that keeps track of the maximum f -value of the nodes expandedthus far in the search. When choosing the next node to expand, if fm, the minimum f -value in OPEN, satisfies fm (cid:3) F , then∗, otherwise the node with minimum g-value among those with f < F is chosen. Because the value offm is chosen as in AF can only change (increase) when a node is expanded for the first time, and no node will be expanded more than once10 In an advanced implementation of IDA(as in any DFS) one can detect whether the current node already appeared as one of the ancestors in thecurrent branch of the tree. However, only a small portion of the possible duplicates can be detected with this method when compared to algorithms thatkeep OPEN and CLOSED lists.∗A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031579Fig. 12. First and last explored path.for a given value of F , the worst-case time complexity of algorithm B is O (N 2) node expansions. However, even with thisimprovement the worst-case scenario is still poor, further reinforcing the impression that inconsistency is undesirable.Bagchi and Mahanti proposed algorithm C, a variant of B, by changing the condition for the special case from fm < F tofm (cid:2) F and altering the tie-breaking rule to prefer smaller g-values [1]. C’s worst-case time complexity is the same as B’s,O (N 2).4.3. New analysis∗Although Martelli proved that the number of node expansions Aperforms may be exponential in the number of distinct∗expanded states, this behavior has never been reported in real-world applications of A. His family of worst-case state spaceshave solution costs and heuristic values that grow exponentially with the number of states. We now present a new resultthat such exponential growth in solution costs and heuristic values are necessary conditions for A’s worst-case behavior tooccur.∗We assume all edge weights are non-negative integers (edge weights of zero are permitted). The key quantity in ouranalysis is (cid:3), defined to be the greatest common divisor of all the non-zero edge weights. The cost of every path from thestart node to node n is a multiple of (cid:3), and so too is the difference in the costs of any two paths from the start node to n.Therefore, if during a search we re-open n because a new path to it is found with a smaller cost than our current g(n)value, we know that g(n) will be reduced by at least (cid:3).Theorem 1. If A∗performs M > N node expansions then there must be a node with heuristic value of at least LB = (cid:3) ∗ (cid:6)(M − N)/N(cid:7).∗does M node expansions and there are only N distinct expanded states, then the number of re-expansionsProof. If Ais M − N. By the pigeon-hole principle there must be a node, say K , with at least (cid:6)(M − N)/N(cid:7) re-expansions. Eachre-expansion must decrease g(K ) by at least (cid:3), so after this process the g-value of K is reduced by at least LB = (cid:3) ∗(cid:6)(M − N)/N(cid:7). (cid:2)In Fig. 12, S is the start node, K is any node that is re-expanded at least (cid:6)(M − N)/N(cid:7) times (as we have just seen, atleast one such node must exist), L is the path that resulted from the first expansion of K , and the upper path to K (via B)is the path that resulted from the last expansion of K . Denote the f - and g-values along path L as f L and gL , and the f -and g-values along the upper path as f last and glast, respectively.Node B is any node on the upper path, excluding S, with the maximum f last value (that is, the maximum f last valueamong any other node on the upper path). Nodes distinct from S and K must exist along this path because if there were adirect edge from S to K , then K would be opened as soon as S was expanded with a g-value smaller than gL(K ). HenceK would not be expanded via L, leading to a contradiction. Node B must be one of these intermediate nodes—it cannot beS by definition and it cannot be K because if f last(K ) was the largest f last value, the entire upper path would be expandedbefore K would be expanded via L, again a contradiction. Hence, B is an intermediate node between S and K .h(B) must be large enough to make f last(B) (cid:3) f L(K ) (because K is first expanded via L). We will now use the followingfacts to show that h(B) must be at least LB:f last(B) = glast(B) + h(B),f last(B) (cid:3) f L(K ),f L(K ) = gL(K ) + h(K ),glast(B) (cid:2) glast(K ),LB (cid:2) gL(K ) − glast(K ).So,h(B) = f last(B) − glast(B), by Fact (6)(cid:3) f L(K ) − glast(B), by Fact (7)= gL(K ) + h(K ) − glast(B), by Fact (8)(6)(7)(8)(9)(10)1580A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603(cid:3) gL(K ) − glast(K ) + h(K ), by Fact (9)(cid:3) gL(K ) − glast(K ),(cid:3) LB, by Fact (10).since h(K ) (cid:3) 0∗From Theorem 1 it follows that for A∗(cid:3) ∗ (cid:6)(2N − N)/N(cid:7), and for Ato do 2N node expansions, there must be a node with a heuristic value of at leastto do N 2 node expansions, there must be a node with a heuristic value of at least (cid:3) ∗ (N − 1).Corollary 2. Let h∗(start) denote the optimal solution cost. If A∗performs more than N node expansions then h∗(start) (cid:3) LB.Proof. Since in the proof of Theorem 1 Aleast LB. (cid:2)∗expanded node B before the goal, h∗(start) must be at least f (B), which is atCorollary 3. If hN + N ∗ λ/(cid:3).∗(start) (cid:2) λ then M, the number of node expansions done by A∗to find a path to the goal, is less than or equal toProof. Using Corollary 2,(cid:4)(cid:3)(M − N)/N(cid:3) ∗which implies= LB (cid:2) h∗(start) (cid:2) λM (cid:2) N + N ∗ λ/(cid:3).(cid:2)Corollary 4. Let m be a fixed constant and G a graph of arbitrary size (not depending on m) whose edge weights are all less than orequal to m. Then M, the number of node expansions done by Aduring a search in G, is at most N + N ∗ m ∗ (N − 1)/(cid:3).∗Proof. Because the non-goal nodes on the solution path must each have been expanded, there are at most N − 1 edges inthe solution path and h∗(start) is therefore at most λ = m ∗ (N − 1). By Corollary 3,M (cid:2) N + N ∗ λ/(cid:3) (cid:2) N + N ∗ m ∗ (N − 1)/(cid:3).(cid:2)∗This is just one example of conditions under which A’s worst-time complexity is not nearly as bad as Martelli’s boundsuggests. The key observation arising from the analysis in this section is that there is an intimate relationship between thenumber of node expansions, the magnitude of the heuristic values, and the cost of an optimal path to the goal. The numberof node expansions can only grow exponentially if the latter two factors do as well.5. Pathmax and bidirectional pathmaxIt is well known that the f -values along any path in a search tree can be forced to be monotonic non-decreasing. This issimply done by propagating the f -value of a parent to a child if it is larger. This technique is usually called pathmax. In thissection, the idea behind pathmax is introduced and then, for undirected state spaces, generalized to a new method calledbidirectional pathmax which provides better heuristic propagation.5.1. Pathmax(cid:8)Mero introduced algorithm B, a variant of B, that dynamically updates heuristic values during the search while main-taining admissibility [34]. This was achieved by adding two rules (known as pathmax rules) for propagating heuristic values(cid:8)has a worst-case time complexity of O (N 2).between a node and its children. Like algorithm B (described in Section 4), B∗too. The rules propagateWhile the pathmax rules were introduced in the context of algorithm B, they are applicable in Aheuristic values during the search between a parent node p and its child node ci (where the edge connecting them costsc(p, ci)) as follows:Pathmax Rule 1: h(ci) ← max(h(ci), h(p) − c(p, ci)), andPathmax Rule 2: h(p) ← max(h(p), minci ∈Successors[p](h(ci) + c(p, ci))).11For Rule 1, we know h(p) (cid:2) hh is admissible. We also know that h∗(p) (where h∗(p) (cid:2) c(p, ci) + h∗(x) denotes the optimal cost to the goal node) and h(ci) (cid:2) h∗(ci) because∗(ci) because one possible path from p to the goal goes via ci . By11 This is our version of pathmax Rule 2. The version in the original paper [34] is clearly not correct and is probably a printing error.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031581Fig. 13. Pathmax Rule 1.Fig. 14. Pathmax Rule 2.Fig. 15. Example where a closed node must be re-opened with pathmax.∗(ci) (cid:3) h(p) − c(p, ci). Fig. 13 shows how the parent node p updates thecombining these facts, it can be inferred that hheuristic values of the child nodes c1 and c2 according to Rule 1. A consequence of this rule is that the child node inheritsthe f -value of the parent node if it is larger. Pathmax Rule 1 is often written as f (ci) := max( f (p), f (ci)). This causes thef -value to be monotonic non-decreasing along any path. However, a child node can still have a heuristic value that is largerthan that of the parent by more than the change in g and the heuristic can still be inconsistent if the graph is undirected(as in inconsistency Type 2 presented at the end of Section 3.1). Our bidirectional pathmax method (BPMX) described belowdeals with such cases and corrects this type of inconsistency.The explanation for Rule 2 (introduced by Mero) is as follows. In directed state spaces, the optimal path from p to a∗(p) is at least as large as minci ∈Successors[p](h(ci) + c(p, ci)).goal must contain one of p’s successors (unless p is a goal), so hRule 2 corrects h(p) to reflect this. Fig. 14 shows how the child nodes c1 and c2 update the heuristic value of the parentnode p according to Rule 2. c1 has the minimal f -value and its value is propagated to the parent. While the idea of Rule 2is correct, its practical value is limited. First, in some state spaces (e.g., in undirected state spaces) there is an edge fromstate p to its parent a and the shortest path from p to the goal might pass through state a. In such cases, using Rule 2is relevant only if a is actually listed as a child of p in the search graph. This will be possible only if the parent pruningoptimization is not used. We discuss more limitations of Rule 2 in Section 5.4 after we introduce our generalization ofRule 1 to bidirectional pathmax.5.2. Pathmax does not make the f -function monotonicIt is sometimes thought that pathmax Rule 1 actually converts a non-monotonic cost function finto a monotonic costfunction and, as a consequence, node re-expansion will be prevented.12 This is not correct. It is true that after applyingpathmax the f -values never decrease along the path that was just traversed. However, the f -values can still be non-monotonic for paths that were not traversed yet. To see this, recall that with a consistent heuristic where the cost function, because when a node is removed from OPEN for the first time weis monotonic, closed nodes are never re-opened by Aare guaranteed to have found a least-cost path to it. This is the key advantage of a consistent heuristic over an inconsistentheuristic which has a non-monotonic cost function where closed nodes can be re-opened. Pathmax does not correct thisdeficiency of inconsistent heuristics. This was noted by Nilsson [35] (p. 153) and by Zhou and Hansen [50].Consider the example in Fig. 15 where the heuristic is admissible but is inconsistent (h(a) = 99 but h(b) = 1), and fisnon-monotonic ( f (b) < f (a)). The optimal path in this example is start–a–b–goal, with a cost of 100. Awill expand startand then c ( f = 30), at which point a and b will be in OPEN. a will have f = 99 and b, because of pathmax, will havef = 30 instead of f = 21. b will be now be expanded and closed, even though the least-cost path to b (via a) has not been∗∗12 We do not use the term consistent because of our understanding that the cost function can be monotonic but the heuristic can still be inconsistent asin Type 2 (presented in Section 3.1) for undirected graphs.1582A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 16. Example of BPMX. The arrows show direction of the propagation of heuristic values. Propagation occurs along the bold edges.∗found. Arevealing the better path to b, and requiring b and all of the nodes in T to be expanded for a second time.will then expand the entire set of nodes in the subtree T before it expands a. At that point a will be expanded,5.3. Bidirectional pathmax—BPMXMero’s Rule 1 was defined to propagate values between a parent and its child in the search tree. However, this pathmaxrule can be applied from a given node x to another node y in any direction (not necessarily from a parent to its childrenin a search tree) as long as there is a path from x to y. This can be beneficial in application domains where the searchgraph is undirected, e.g., when operators are invertible and costs symmetric. Assume an admissible heuristic h where h(x) >∗( y) (cid:3)h( y) + c(x, y). Now, h∗(x) − c(x, y) (cid:3) h(x) − c(x, y) (since h is admissible) and we can apply the following general rule:h∗( y) because a possible path from x to the goal passes through y. Therefore h∗(x) (cid:2) c(x, y) + hh( y) ← max(cid:5)(cid:6)h( y), h(x) − c(x, y).(11)Pathmax Rule 1 used this general rule from a parent node to its children. In a search tree if there is an edge from a childc to its parent p then this can be achieved by introducing a new pathmax rule for children-to-parent value propagation asfollows:Pathmax Rule 3: h(p) ← max(h(p), h(c) − c(c, p)).Fig. 16(a) shows how Rule 3 can be used. The heuristic of child c1 is propagated to the parent p and p’s heuristic isincreased from 3 to 8.Our new method, bidirectional pathmax (BPMX), uses Rules 1 and 3 to propagate (inconsistent) heuristic values in anydirection, as described generally in Eq. (11). Large heuristic values are propagated along edges but to preserve admissibilitywe subtract the weight of the edges along the way. Therefore, updating a node’s value can have a cascading effect (to itsneighbors and so on) as the propagation that started from child c1 continues from the parent to the other children (asshown in Fig. 16(b)). The BPMX process stops when we arrive at a node whose original heuristic value is not smaller thanthe propagated value. The bold edges in Fig. 16(b) correspond to cases where BPMX further propagates the new heuristicvalue of p to its children (to c2 and c3). By contrast, child c4 cannot exploit BPMX here as its original heuristic value was 8while BPMX would propagate a value of 6.Note that Rule 1 only deals with inconsistencies of Type 1 (described in Section 3.1) and causes the cost function tobe monotonic along the edge. BPMX further extends this to inconsistencies of Type 2 and causes the heuristic to be fullyconsistent.5.3.1. BPMX for IDA∗∗Before discussing BPMX for IDAwe first highlight the following observation.∗Observation. What is important for IDAis not the exact f -value of a node but whether or not the f -value causes a cutoff.∗Explanation. IDAthan T . Thus, only a cutoff reduces the work performed.expands a node if its f -value is less than or equal to the current threshold T and backtracks if it is largerIt may not be immediately obvious, but using Rule 1 with IDAdoes not have any benefit.13 This is because propagatingthe heuristic of the parent p (with Rule 1) to the child c will cause f (c) = f (p). It will not increase its f -value above thethreshold T (as the f -value of p was already less than or equal to T ) and therefore will not result in additional pruning.∗Using Rule 3 with IDAfully expanded). For example, suppose that the current IDAhas great potential as it may prune many nodes that would otherwise be generated (and eventhreshold T for Fig. 17 is 2. Without the propagation of h from∗∗∗13 We discuss Rule 2 in the context of IDAin Section 5.4.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031583∗Algorithm 1. IDAwith BPMX (“::” adds an element to a list)∗Fig. 17. BPMX. In IDA, the right branch is not even generated.bpmx(initial_node s)∗threshold ←− h(s)repeatfunction IDA01:02:03:04:05:06:07:08: end functionuntil GoalFoundreturn PathGoalFound ←− DFSbpmx(s, NULL, 0, Path, threshold, hs )threshold ←− next_threshold()(cid:11) Returns the optimal solutionh p ←− h(p)if (h p + g) > threshold then return falseif p = goal_node then return truefor each legal_move mi do−1 then continueif mi = pmgenerate child ci by applying mi to pif DFSbpmx(ci , mi , g + c(p, ci), Path, threshold, hci ) = true then09: boolean function DFSbpmx(node p, previous_move pm, depth g, List Path, integer threshold, heuristic_value &h p )10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25: end functionh p ←− max(h p , hciif (h p + g) > threshold then return falsePath ←− mi :: Pathreturn true(cid:11) Rule 3(cid:11) Backtrack ASAPend forreturn false(cid:11) Parent pruning− c(ci , p))end ifelse∗the left child, both the parent node ( f (p) = g(p) + h(p) = 0 + 2 = 2) and the right child ( f (c1) = g(c1) + h(c1) = 1 + 1 = 2)would be expanded. When using BPMX propagation, the following will occur. The left child will have f (c2) = 1 + 5 = 6,∗and with a T = 2 IDAwill backtrack. However, BPMX will update the parent’s h-value to h(p) = 4 and its overall cost tof (p) = 0 + 4 = 4. This results in a cutoff, and the search will backtrack from the root node without even generating theright child (whose heuristic value can be modified to 3, e.g., in Aas discussed below).∗An efficient implementation of BPMX for IDAis provided in Algorithm 1. In this implementation, Rule 3 is applied “forfree” when backtracking from a child. First, the heuristic of the parent p is updated by Rule 3 (line 20). Then, if the f -valueof the parent becomes larger than the threshold, the subtree below it is immediately pruned (line 21) and control is passedback to the parent of p. In this case, the other children of p are not generated.An alternative exhaustive implementation will not stop at line 21 but will continue to generate all children of p andcalculate their heuristics. This may result in propagating higher heuristic values by Rule 3 to the parent p and increase thechance of further pruning ancestors of p. The drawback of this implementation is that parent p is fully expanded.14 Wehave experimented with this variant in most of the domains studied in this paper. However, no gains were provided andthe “lazy” approach of stopping as soon as a cutoff occurred consistently outperformed the exhaustive variant. Therefore,we only report experimental results with the lazy variant.A reminiscent idea of BPMX for propagating heuristic values between nodes was introduced in the context of learn-ing heuristics in DFS searches [3]. The difference is that unlike BPMX the “learning algorithm” of that work requires atransposition table.5.3.2. BPMX for A∗Due to its depth-first nature, BPMX propagation is easily implemented in IDA, and values are propagated naturallyBPMX updates are more difficult as nodes that might be updated∗∗between children and their parents. By contrast, in Amay need to be retrieved from OPEN or CLOSED.BPMX can be parameterized with the maximum depth that a heuristic value will be propagated. BPMX(1) is at oneextreme, propagating h updates only among a node and its children. BPMX(∞) is at the other extreme, propagating hupdates as far as possible.14 This process can be extended and we can perform a k-lookahead search to find large heuristic values.1584A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603∗Algorithm 2. Awith BPMX(1) (assumes symmetric edge costs)BestH ←− max(BestH, lookupH(neighbor) − c(current, neighbor))(cid:11) Stores parent h-cost (from pathmax)(cid:11) Cache these lookups for later usecurrent ←− pop best node from queueif current is goal return extractPath(start, goal)neighbors ←− generateSuccessors(current)BestH ←− 0for each neighbor 1...i in neighborsend forstoreH(current, max(lookupH(current), BestH))for each neighbor 1...i in neighborsEdgeCost = c(current, neighbor)switch (getLocation(neighbor))if (lookupH(neighbor) < BestH − EdgeCost)storeH(neighbor, BestH − EdgeCost)end ifif (lookupG(current) + EdgeCost < lookupG(neighbor))setParent(neighbor, current)storeG(neighbor, lookupG(current) + EdgeCost)reopen(neighbor)if (lookupG(current) + EdgeCost < LookupG(neighbor))setParent(neighbor, current)storeG(neighbor, lookupG(current) + EdgeCost)updateKey(neighbor)end ifif (BestH − EdgeCost > lookupH(neighbor))storeH(neighbor, BestH − EdgeCost)updateKey(neighbor)addOpenNode(neighbor, lookupG(current) + EdgeCost,max(h(neighbor, goal), BestH − EdgeCost))(cid:11) BPMX or PMX update(cid:11) Found shorter path(cid:11) Found shorter path(cid:11) Re-sort OPEN(cid:11) BPMX or PMX update(cid:11) also applies BPMX or PMX updatepush(start)case ClosedList:∗bpmx(1)(start, goal)01: function A02:03: while (queue is not empty)04:05:06:07:08:09:10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25:26:27:28:29:30:31:32:33:34:35:36:37:end for38:end while39:40:return nil41: end functionend ifcase OpenList:case NotFound:end switchend ifBPMX(1) can be implemented efficiently if the BPMX computation happens after all children of a node have been gen-erated (and checked for duplicates in OPEN and CLOSED) but before they are added/moved back to OPEN and/or CLOSED.Assume that a node p is expanded and that its k children c1, c2, . . . , ck are generated. References to these nodes can besaved for faster manipulation in the following steps. Let cmax be the node with the maximum heuristic value among all thechildren and let hmax = h(cmax). In addition, assume that each edge has unit cost and is undirected. hmax can be propagatedto the parent node by decreasing it by one (using Rule 3) and then to the other children by decreasing it by one again(using Rule 1). Thus, each of the other children ci can have a heuristic of(cid:5)h(ci), h(p) − 1, hmax − 2hBPMX(ci) = max(cid:6).∗After all these nodes have their value updated, then the parent node is inserted in CLOSED (with its new f -value) and allthe children are inserted (or changed) in OPEN (with their new f -values).Pseudocode for an efficient implementation of Awith BPMX(1) is shown in Algorithm 2. There is a single data structurefor OPEN and CLOSED which is implicit in calls for looking up nodes. In our actual implementation most lookups are cachedto reduce overhead.BPMX(d) with d > 1 starts at a new node that was just generated and continues to propagate h-values to its generatedneighborhood (nodes on OPEN and CLOSED) as long as the h-values of nodes are being increased. There are a number ofpossible implementations and they all require finding and retrieving nodes from OPEN and CLOSED. Obviously, this willincur some (even all) of the following possible overheads associated with BPMX(d) (with d > 1) within the context of A∗:(a) performing lookups in OPEN and/or CLOSED (when looking for neighbors),(b) ordering OPEN nodes based on their new f -value (when these values change), and(c) computational overhead of comparing heuristic values and assigning a new value based on the propagations.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031585Fig. 18. Worst-case example for BPMX(∞).Fig. 19. Best-case example for BPMX(∞).These costs are the same as the costs incurred when performing Anode expansions. In BPMX(d) the propagatingof heuristic values can result in the equivalent of multiple expansions (re-openings). The propagation (and re-openings)must follow all children of a node until the depth d parameter is satisfied. As such, we regard BPMX with d > 1 as anindependent search process rather than a small optimization on top of the main search. Our experimental results shownode expansions.15 Therefore, in thethat node expansions that occur during the BPMX process have the same cost as Aand BPMX(d > 1) expansions. When d = 1 the overhead is notremainder of the paper we will not distinguish between Aincluded in the count of node expansions, only in time measurements.∗∗∗A natural question is how to determine which value for parameter d is best. It turns out that no fixed d is optimal inthe number of node expansions for all graphs. While a particular d can produce a large reduction in the number of nodeexpansions for a given state space, for a different state space it can result in an O (N 2) increase in the number of nodeexpansions.Fig. 18 gives an example of the worst-case behavior of BPMX(∞). The heuristic values gradually increase from nodes ato d. When node b is reached, the heuristic can be propagated back to node a, increasing the heuristic value by 1. Whennode c is reached, the heuristic update can again be propagated back to nodes b and a. In general, when the ith nodein the chain is generated a BPMX update can be propagated to all previously expanded nodes. Overall this will result in1 + 2 + 3 + · · · + N − 1 = O (N 2) propagation steps with no savings in node expansions. This provides a general worst-casebound. At most, the entire set of previously expanded nodes can be re-expanded during BPMX propagations, which is whathappens here.By contrast, Fig. 19 gives an example of how BPMX(∞) propagation can be effective. Assume node a is the start node. Itis expanded and its three children (b, c and goal) are generated with f -values f (b) = 4,f (c) = 3 and f (goal) = 50. Next cis expanded and d is generated. If BPMX is not activated (left side), then all nodes in the subtree under b with f < 50 willbe expanded; only then goal is expanded and the search terminates. Now, consider the case where BPMX(∞) is activated(right side). While generating node d its heuristic value is propagated with BPMX to c, then to a and then to b raising thef -value of b to 50. Note that we can infer that the entire subtree below b will have f (cid:3) 50. In this case f (b) = f (goal) = 50and, assuming ties are broken in favor of low h-values, goal is expanded and the search halts after expanding only threenodes.5.4. Pathmax Rule 2We have just seen the usefulness of pathmax Rules 1 and 3. Mero also created Rule 2 for children-to-parent valuepropagation [34].Rule 2: h(p) ← max(h(p), minci ∈Sucessors[p](h(ci) + c(p, ci))).We now discuss the properties of Rule 2.5.4.1. Rule 2 when IDA∗is usedSimilar to Rule 1, there is no benefit for using Rule 2 on top of IDAin undirected state spaces as no pruning will becaused by it. Assume that node p has children c1, c2, . . . , ck and that the parent of p is a (as shown in Fig. 20). Assume∗15 This is true for PDB heuristics (inexpensive to compute). However, this might not be true in cases where the heuristic calculation requires a largeamount of time.1586A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 20. Example for Rule 2.also that cm produced the minimalwhen applied to p when Rules 1 and 3 are used.f -value among all the children. We show that neither p nor a can benefit from Rule 2• p cannot benefit from Rule 2: Assume that p is not causing a cutoff in the search. In this case, the search proceeds tothe children. Now, if the minimum child (cm) causes a cutoff then all the other children must also cause a cutoff. Whenusing Rule 2, then all the children are generated in order to find the one with minimum cost. Either way, using Rule 2or not, all children are generated and Rule 2 will have no added value for p.• a cannot benefit from Rule 2: Assume that Rule 2 was activated and that we set f new(p) = f (cm). Now, due to theactivation of Rule 1 (ordinary pathmax) the f -value is monotonically increasing along any path of the search tree. Thus,f new(p) (cid:3) f (p). If f new(p) = f (p) then there is no change in the course of the search by applying Rule 2. Now, considerthe case where f new(p) > f (p). Recall that for Rule 2 to work we must also list a as one of the children of p. Thereare now two cases. The first case (cm = a) is that a produced the minimalf -value among the children. Now, if weapply Rule 3 we get that hnew(a) = h(p) − c(a, p) = h(cm) + c(p, cm) − c(a, p) = h(cm) + c(p, a) − c(a, p) = h(a). Thus,there is no change to the h-value of a. The second case (cm (cid:13)= a) is that another child was chosen as the minimum,meaning that h(a) + c(a, p) (cid:3) h(cm) + c(cm, p). Now, if we apply Rule 3 we get that hnew(a) = h(p) − c(a, p) = h(cm) +c(p, cm) − c(a, p) (cid:2) h(a) + c(a, p) − c(a, p) = h(a). Here applying Rule 3 can only decrease the h-value of a and it isagain unchanged.Thus, a cannot benefit from applying Rule 2 either and Rules 1 and 3 are sufficient to obtain all the potential benefits.5.4.2. Rule 2 when A∗is used∗Assume that we are running Aand that node p is now expanded. Its children are added to OPEN while p goes toCLOSED. If after applying Rule 2, its f -value increases then it will go to CLOSED but with a higher f -value because itsnew h-value is larger than its original h-value. This might affect duplicate pruning in the future if node p is reached via adifferent path.Furthermore, Rule 2 is just a special case (k = 1) of a k-lookahead search where values from the frontier are backed up[23] when repeated searchto the root of the subtree. In fact, similar propagation is used for heuristic learning in LRTAtrials take place. This is also applicable for strict consistent heuristics.∗Based on all the above, we did not implement Rule 2 in our experiments and focus on Rules 1 and 3 which are the coreaspects of BPMX value propagation with inconsistent heuristics.6. Creating inconsistent heuristicsAs illustrated in the quote from Artificial Intelligence: A Modern Approach [38] given earlier, there is a perception thatinconsistent admissible heuristics are hard to create. However, it turns out that this is not true. The following examplesuse PDB-based heuristics (used in many of the applications in this paper) to create inconsistent heuristics. However similarideas can be applied to other heuristics. We show examples of inconsistent heuristics for pathfinding in explicit graphs inSection 8.It is important to note that we can trivially make any heuristic inconsistent. For example, with a table-based heuristic(such as a PDB) one can randomly set table entries to 0. Of course, introducing this inconsistency results in a strictly lessinformed heuristic. In this section we give examples of inconsistent heuristics which provide more informed values that canbenefit the search.6.1. Random selection of heuristicsMany domains have a number of heuristics available. When using only one heuristic the search may enter a regionwith “bad” (low) estimation values (a heuristic depression). With a single fixed heuristic, the search is forced to traverse a(possibly large) portion of that region before being able to escape from it.A well-known solution to this problem is to consult a number of heuristics and take their maximum value [5,10,18,19,24,26]. When the search is in a region of low values for one heuristic, it may be in a region of high values for another. Thereis a tradeoff for doing this, as each heuristic calculation increases the time it takes to compute h(n). Additional heuristicconsultations provide diminishing returns in terms of the reduction in the number of node expansions, so it is not alwaysrecommended to use them all.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031587Fig. 21. Inconsistency of a compressed pattern database.Given a number of heuristics one could select which heuristic to use randomly. Only a single heuristic will be consulted ateach node, and no additional time overhead is needed over a fixed heuristic. Random selection between heuristics introducesmore diversity to the values obtained in a search than using a single fixed selection. The random selection of a heuristicwill produce inconsistent values if there is no or little correlation between the heuristics. Furthermore, a random selectionof heuristics might produce inconsistent h-values even if all the heuristics are themselves consistent.When using PDBs, multiple heuristics often arise from exploiting domain specific geometric symmetries. In particular,additional PDB lookups can be performed given a single PDB. For example, consider Rubik’s cube and suppose we had the“yellow face” PDB described previously in Section 2.4.1. Reflecting and rotating this puzzle will enable similar lookups forany other face with a different color (e.g., green, red, etc.) since any two faces are symmetrical. Different (but admissible)heuristic values can be obtained for each of these lookups in the same PDB. As another example, consider the main diagonalof the sliding-tile puzzle. Any configuration of tiles can be reflected about the main diagonal and the reflected configura-tion shares the same attributes as the original one. Such reflections are usually used when using PDBs for the sliding-tilepuzzle [5,10,11,26] and can be looked up from the same PDB.In recent work, a learning algorithm was used to decide when to switch between two (or more) heuristics [7]. A classifierwas used to map a state to a heuristic, considering the likely quality of the heuristic estimate and the time needed tocompute the value. The resulting search has inconsistencies in the heuristic values used.6.2. Compressed pattern databasesThere is a tradeoff between the size of a table-based heuristic (such as a PDB) and the search performance. Larger tablespresumably contain more detailed information, enabling more accurate heuristic values to be produced.Researchers have explored building very large PDBs (possibly even on disk) and compressing them into smaller PDBs[11,12,27,39,2]. A common compression idea is to replace multiple PDB entries by a single entry (often exploiting a localityproperty, so that the values of the entries are highly correlated), thereby reducing the size of the PDB. To preserve admis-sibility, the compressed entry must store the minimum value among all the entries that it is replacing. This is called lossycompression because some state lookups will end up with a less effective heuristic value. It has been shown that if thevalues in PDBs are locally correlated, then most of the heuristic accuracy will be preserved [11]. Thus, large PDBs can bebuilt and then compressed into a smaller size with little loss in performance. Such compressed PDBs are more informedthan uncompressed PDBs which use the same amount of memory [11].The compression process may introduce inconsistency into the heuristic, since there is no guarantee that the heuristicvalue of adjacent states in the search space will lose the same amount of information during compression. For example,consider the PDB in Fig. 21 and assume that it is consistent. Assume that b and c are connected by an edge with cost of 1.During compression, b might be mapped to x in the abstract space, and c to y. To preserve admissibility, x and y mustcontain the minimum value of the states mapping to those locations. Now states b and c are inconsistent in the abstractspace (the difference between their heuristics (= 2) is bigger than the actual distance between them (= 1)).6.3. Dual heuristicThe concept of duality and dual heuristics in permutation state spaces was introduced by Zahavi et al. [14,44,45]. Suchheuristics may produce inconsistent heuristic values. The papers provide a detailed discussion of these concepts. Here weprovide sufficient details for our purposes.In permutation state spaces, states are different permutations of objects. Similarly, any given operator sequence is also apermutation (i.e., transfers one permutation into another permutation). For each state s, a dual state sd can be computed.The basic definition is as follows. Let π be the permutation that transforms state s into the goal. The dual state of s (labeledas sd) is defined as the state that is constructed by applying π to the goal. Alternatively, if O is the set of operators thattransfer s to the goal, then applying O to the goal will reach sd.This dual state sd has the important property that it is the same distance from the goal as s. The reason is that anysequence of operators that maps s to the goal also maps the goal to sd. Since operators are reversible in permutation statespaces, the sequence can be inverted to map sd to the goal. Efficient methods have been suggested for deriving the dualstate sd given a description of state s [45]. Since the distance to the goal of both states is identical, any admissible heuristicapplied to sd is also admissible for s and can be used as a heuristic for it. For a state s, the term dual lookup is used1588A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 22. Dual states of the parent and its children.when looking up sd in the PDB. When moving from a parent state to a child state, performing a dual lookup may producean inconsistent value even if the heuristic itself (in its regular form) is consistent. The explanation for this is as follows.In a standard search, a parent state p, and any of its children ci , are neighbors by definition. Thus, a consistent heuristicmust return consistent values when applied to p and ci . However, the heuristic values obtained for sd and cdi may not beconsistent because sd and cdi are not necessarily neighbors (as illustrated in Fig. 22).16In general, there are two easy ways to generate inconsistency for a given domain: 1) the use of multiple differentheuristics and 2) using a heuristic that has some values missing or degraded. We provided some examples in this section.This list is not exhaustive and the above examples are by no means the only ways of creating inconsistent heuristics.6.4. Inconsistent versus consistent heuristicsBesides the potential of h-value propagation, inconsistent heuristics have other attributes which might reduce the num-ber of node expansions in a search when compared to consistent heuristics. This section addresses these attributes.Most of the previous work on admissible heuristics mainly concentrated on improving the quality of the heuristic as-sessment. A heuristic h1 is considered to be more informed (better quality) than h2 if it typically returns a higher value foran arbitrary state [38]. A de facto standard usually used by researchers is to compare the average values of a given heuristicover the entire domain space or over a large sample of states of the domain (e.g., [10,11,24,26]). Korf, Reid and Edelkamp(denoted as KRE) introduced the notion of the overall distribution of heuristic values [28,29]. Define p(v) to be the proba-bility that a random state of the state space will have a heuristic value of v. Likewise, define P (v) to be the probabilitythat a random state will have a heuristic value less than or equal to v. KRE suggested using the distribution of values froma heuristic function to measure the “informedness” of the function. Doing this for admissible heuristics will typically showthat if a heuristic is more informed then the distribution of values will be higher, as will be the average value. We showin Section 7.2.1 that, when inconsistent heuristics are used, this distribution is not enough and there are more attributes toconsider.∗on a single iteration when using aKRE also introduced a formula to predict the number of node expansions by IDAconsistent admissible heuristic [28,29]:N(b, d, P ) =d(cid:7)i=0bi P (d − i),where b is the brute-force branching factor, d is the depth of the search (the IDAthreshold), and P is the heuristicdistribution. KRE showed that if P (x) is defined in a particular way (the “equilibrium” distribution) then the number ofnodes n such that f (n) (cid:2) d is equal to N(b, d, P ) in the limit of large d. We call these nodes the nodes with potential to beexpanded or potential nodes in short. KRE then proved that with consistent heuristics all potential nodes will eventually be∗expanded by IDA. Assume that n is a potential node. Since the heuristic is consistent, any ancestor a of n must also havef (a) (cid:2) d and is also a potential node. Then, by induction they showed that the entire branch from the root to n will beexpanded since all the nodes of the branch are potential nodes.∗For inconsistent heuristics the behavior is different. For a potential node n, there may exist an ancestor a with f (a) > d.∗Once IDAvisits this node, the entire subtree below it is pruned and n will not even be generated. A potential node willactually be expanded only if all its ancestors are also potential nodes. This is guaranteed for consistent heuristics but not16 This phenomenon is explained in detail in the original papers [14,44,45]. An example is provided in Appendix A of this paper.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031589Fig. 23. Consistent versus inconsistent heuristics. Nodes are marked with their h-value.for inconsistent heuristics. Thus, for an inconsistent heuristic the number of potential nodes approximated by N(b, d, P ) isonly an upper bound on the number of node expansions.17Assume a given PDB and compare, for example, the dual (or random) lookup of this PDB to the regular consistent lookupof the same PDB. Since exactly the same PDB is used, all these heuristics (which perform a single lookup) will have thesame overall distribution of values and the same number of potential nodes. However, as our experimental results belowshow, fewer nodes are expanded in practice. The explanation for this is shown in Fig. 23. Observe that in both cases there isthe same h-value distribution for each level of the tree. In particular, at depth two there are three nodes with h-value of 3,and two single nodes with h-values of 4 and 6, respectively. In the case of a consistent heuristic (left side of the figure),∗threshold is 5, all three nodes at depth two with h-value of 3 have f = g + h = 2 + 3 = 5 and will beif the current IDAexpanded. They are all potential nodes, and since the heuristic is consistent and all their ancestors are also potential nodes,they are all expanded. The right subtree of the root is pruned because the f -value at level 1 is f = g + h = 1 + 5 = 6 > 5.In the case of an inconsistent heuristic (right side of the figure), only one node at depth two will be expanded (theleftmost node). The node with h-value of 6 will be generated but not expanded because its f -value is 8 and that exceedsthe threshold. Due to BPMX, its value will be propagated to its parent by Rule 3 and the parent’s h-value will be changedto 5. The f -value of the parent will be changed to 6 and the search will backtrack without even generating the rightmostchild (a potential node with h = 3).7. Experiments with IDA∗This section presents results from different domains that illustrate the benefits of inconsistent heuristics and BPMX when∗used with IDA. All experiments were performed on an Intel P4 3.4 GHz with 1 GB of RAM.7.1. TopSpinWe experimented with the (17, 4)-TopSpin puzzle which has 17! = 3.56 × 1014 states. A PDB of the leftmost 9 tokenswas built, representing a pattern space of 17 × 16 × · · · × 9 = 8.82 × 109.18Given a PDB, 17 different symmetric (geometrical) lookups can be derived. For example, a PDB of 9 consecutive tokens([1 . . . 9]) can also be used as a PDB of [2 . . . 10], [3 . . . 11], etc., with an appropriate mapping of tokens. Since all the valuesin this PDB were smaller than 16, each entry is encoded in 4 bits. Hence the PDB only requires 247 MB of space.Some pairs of operators are commutative, leading to the same state. When the search is done using IDA, many duplicatenodes can be avoided by forcing two commutative operators to be applied successively in only one order. For example, theoperator that reverses locations (1, 2, 3, 4) is not related to the operator that reverses locations (11, 12, 13, 14). By forcingthe first one to always be tried before the second eliminates unnecessary duplication in the search tree. This operatorordering decreases the number of generated nodes by an order of magnitude and is applied across all our experiments.Table 1 presents the average number of generated nodes and average time in seconds needed for IDAto solve 1000random instances with different PDB lookup strategies. The first column (Lookups) shows the number of PDB lookups(n (cid:3) 1) that were performed (and maximized). The following PDB-based heuristics were used:∗∗• Regular: A fixed set of n PDB lookups is chosen and used at every node in the search. Since all nodes maximize overthe same lookups, the heuristic is consistent.• Random: Of the 17 possible lookups, n are randomly chosen (and maximized) at each node in the search. Since con-secutive nodes have an h value that is computed differently (possibly n different lookups), the resulting heuristic isinconsistent.• Random + BPMX: The heuristics obtained by combining (inconsistent) random lookups are updated with BPMX.∗When multiple heuristics exist and IDAis used then the following implementation enhancement can save a consider-able number of potential heuristic lookups. For a node n the heuristic lookup should determine whether f (n) (cid:2) T (does not17 Zahavi et al. developed an alternative formula to predict the number of node expansions [42,43]. One of its benefits is that it provides accuratepredictions for inconsistent heuristics too (as opposed to an upper bound).18 Since this puzzle is cyclic and the data is stored in a linear array, we can assume that token number 1 is always in the leftmost position. Thus, for theimplementation, both numbers above can be divided by 17.1590A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Table 1Consistent and inconsistent heuristics for TopSpin (17,4) (IDA∗).Lookups1234567891011121314151617Regular(Consistent)Nodes40 019 4296 981 0271 787 456651 080332 642208 062148 003116 20895 86381 74971 45164 22758 45553 92650 37647 78445 849Time53.12910.6863.2131.3940.8350.6010.4840.4220.3820.3540.3350.3220.3120.3070.3030.3030.304Random(Inconsistent)Nodes1 567 769404 779224 404157 710123 882103 37789 69879 91172 50466 69062 02058 11954 90652 14549 76047 68845 848Time2.8570.8650.5550.4430.3880.3560.3370.3240.3170.3110.3060.3040.3020.3010.3020.3010.303Random + BPMX(Inconsistent)Nodes564 469279 880187 797143 051116 77999 65387 59678 60971 70966 18461 68257 94754 77352 07949 73647 66345 849Time1.0320.6220.4800.4110.3730.3490.3320.3210.3150.3100.3060.3040.3030.3020.3020.3030.304exceed the threshold, meaning that n should be expanded) or whether f (n) > T (meaning that n is pruned). When max-imizing over multiple heuristics, instead of evaluating all the heuristics (exhaustive evaluation) the computation can stopwhen one of the heuristics exceeds T (lazy evaluation); further lookups are not needed.19 Lazy evaluation is not relevant for∗Atoo, for nodes that are expanded, all heuristicsare looked up.as the maximum needs to be calculated and stored. In addition, for IDA∗When BPMX is used, there is a benefit to always using exhaustive evaluations (similar to the variant described in Sec-tion 5.3.1). Exhaustive evaluations will often yield higher values than lazy evaluations, perhaps leading to additional BPMXcutoffs (higher values being propagated). Experiments on the performance of lazy and exhaustive evaluations have beendone for many of the domains used in this research. In general for nodes where a lazy evaluation occurs, the time pernode can drop significantly, as much as by a factor of three in some of our experiments. By contrast, exhaustive evaluationsreduced the number of generated nodes, but this reduction was rather small and never more than 20%. All the resultsreported in this paper used lazy evaluations.The first row in Table 1 corresponds to the benchmark case where only one lookup is allowed. The number of generatednodes is 40 019 429. Randomly selecting a single lookup reduces this number by a factor 25.5 to 1 567 769 nodes. AddingBPMX to this further reduces the number of generated nodes to 564 469—an improvement factor of 70.9 over the bench-mark. This improvement was achieved with a single PDB lookup. The regular fixed selection method needs more than fourdifferent lookups (from the same PDB) to produce a heuristic of similar quality as the one using the random selection withBPMX (see row 4). This is achieved with potentially three additional lookups, increasing the computational cost per node.Adding more lookups provides diminishing returns. Using many lookups provide a diversity of heuristic values and theimprovement factor of an additional lookup (regular or random) decreases. All the selection methods converge to the caseof using all 17 lookups. The random selection of lookups converges faster. For a fixed number of potential lookups, therandom selection strategy always outperforms the fixed strategy. When more lookups are possible, the relative advantage ofthe random selection decreases because the fixed selection also has a diversity of values. When one is interested in a timespeedup, then many variants of both the regular (e.g., consulting all of them) and random lookups will provide the besttime results of nearly 0.3 seconds. In practice, of course, all 17 symmetric lookups are possible and there is no reason notto use them all.7.2. Rubik’s cubeRubik’s cube has 20 movable cubes (cubies); 8 are corners and 12 are edges. The heuristic for Rubik’s cube is usuallyobtained by taking the maximum over three PDBs (one for the eight corners and two covering six edges [24]). The 8-cornerPDB cannot be used in an inconsistent manner (all the corners are always examined; hence there are no symmetries andthe dual lookup is identical to the regular lookup). This section reports results using a 7-edge PDB. There are 24 lines ofgeometrical symmetries which arise from different ways of rotating and reflecting the cube. For the 7-edge PDB, each ofthese symmetries considers a different set of edges, resulting in a different PDB lookup. Similar tendencies were observedin other experiments (based on PDBs built from a mix of edge and corner cubies).19 One can try to order the heuristics to increase the chance of getting a cutoff earlier [18].A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031591Table 2∗Consistent and inconsistent heuristics for Rubik’s cube (IDA).RowLookupsHeuristicOne PDB lookup1234511111Maxing over multiple PDB lookups67891022244RegularDualDual + BPMXRandomRandom + BPMX2 RegularRegular + Dual + BPMX2 Random + BPMX4 Regular4 Random + BPMXNodes90 930 66219 653 3868 315 1169 652 1383 829 13813 380 1542 997 5391 902 7301 053 5221 042 451Time28.187.383.243.301.254.911.340.830.640.64Table 2 shows the average number of generated nodes and the average running time (in seconds) over the set of 100Rubik’s cube instances with goal distance of 14 used by Felner et al. [14]. The Lookups column gives the number of PDBlookups that were used to compute the heuristic value for a state. Lazy evaluation was used whenever possible.The following PDB-based heuristics were used:• Regular: The regular PDB lookup. This heuristic is consistent because the same set of cubies is used for the PDB lookupof both parent and child nodes.• Dual: For each node, the dual state is calculated and is looked up in the PDB. This will produce inconsistent heuristicvalues because the dual lookup of the parent may consult different cubies than the dual lookup of the child.• Random: Randomly select one of the different 24 possible symmetric PDB lookups for the given node. This is inconsis-tent because the set of cubies that are used for the parent are not necessarily the same as for the child.The table shows that single random and dual lookups perform much better than a single regular lookup. In addition,BPMX further improves the results. The dual lookup is much more diverse than the regular lookup and there is much lesscorrelation between successive lookups [14]. Therefore, the search is not stuck in a region with low heuristic values asfrequently happens with regular lookups. A random lookup with BPMX is much faster than either one regular lookup (by afactor of 24) or one dual lookup with BPMX (by a factor of 2.5).Rows 6–10 show the results of maximizing over 2 and 4 regular and random lookups. It is interesting to see that onerandom lookup with BPMX outperforms two regular lookups by a factor of 3.5 in the number of generated nodes and by afactor of 3.9 in time. Two random lookups are better than a regular and a dual lookup because it has a better diversity ofvalues (see below). When four lookups are allowed, the values obtained using our four regular lookups are diverse enoughthat there is no advantage to taking four random lookups.7.2.1. Dynamic distribution of heuristic valuesWe claimed above that part of the reason for the success of an inconsistent heuristic is the diversity of values that getintroduced into the search. This section attempts to give greater understanding to this claim.It is easy to analyze a domain and produce a graph showing the distribution of values produced by a heuristic. However,the obvious question to ask is whether this static (pre-computed) distribution reflects the values that are actually seenduring a search. Of interest is the dynamic distribution of values generated during a search. Distinguishing between staticand dynamic distributions of heuristic values is not new; it has been previously used to explain why the maximum ofseveral weak heuristics can outperform one strong heuristic [18].Fig. 24 shows the dynamic distribution of the heuristic values seen during the searches reported in Table 2, as well asthe static distribution of values in the PDB used. The following observations can be made from these results. First, there isa dramatic difference between the static and dynamic distribution of values for the regular (consistent) heuristic. As can beseen, the dynamic distribution for the regular lookup is greatly shifted towards the smaller heuristic values, compared totheir static distribution in the PDB. This phenomenon was discussed and explained by Holte et al. [18]. The main reason forthis is that most of the generated nodes are deep in the search tree, and their values are necessarily small to be generatedat all. Second, it is easy to recognize that the heuristic with the best performance also had a superior (shifted to the right)dynamic distribution of heuristic values. Note that all these versions used exactly the same PDB represented by the (overall)static distribution of values. Third, the regular heuristic had a poor dynamic distribution because it is consistent; when theheuristic value for a state is low, the children of that state must also have low values. Inconsistent heuristics do not havethis problem; a node can receive any value, meaning that the distribution of values seen is closer to the static distribution1592A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 24. Rubik’s cube heuristic distributions.Table 3Rubik’s cube: random heuristic with BPMX.ChoiceLookups12345812162024Dual11111111111DBF13.3559.3899.3889.3827.1527.0437.0366.8676.8526.8347.681Nodes90 930 66217 098 87514 938 50214 455 9805 132 3964 466 4283 781 7163 822 4223 819 6993 829 1398 315 117BPMX cuts0717 151623 554598 681457 253402 560337 114356 327357 436360 067796 849of the PDB. Finally, inconsistency has the effect of improving the dynamic distribution towards that of the static distribution.The greater the degree of inconsistency, the closer the dynamic distribution approaches the static distribution of the PDB.7.2.2. Dynamic branching factor and BPMXThe effectiveness of BPMX can be characterized by its effect on the branching factor during the search. The dynamicbranching factor (DBF) is defined as the average number of children that are generated for each node that is expanded inthe search. When the heuristic function is inconsistent and BPMX is employed, the dynamic branching factor can be smallerthan the normal branching factor.Table 3 presents DBF results for Rubik’s cube obtained using the 7-edge PDB. An experiment was performed where thenumber of possible PDB lookups was varied, but only a single lookup was used by randomly selecting from this set. The firstcolumn gives the number of available heuristics to randomly select from. The other three columns show results averagedover the same set of instances of Table 2.In the first row, only one PDB lookup was used. Since the same PDB lookup was performed at all nodes, this benchmarkcase is for a single consistent regular heuristic. The dynamic branching factor here is equal to the actual branching factor,13.355, once redundant operators are removed (consistent with the results of Korf [24]).As the number of possible heuristic lookups increases, the DBF decreases. This results in a significant reduction in thenumber of generated nodes. Note two phenomena in these results. First, the range of heuristic values in Rubik’s cube israther small, as can be seen in Fig. 24. Thus, the potential for a large difference between a parent’s heuristic value andits children’s is small. Even in this domain inconsistency caused a dramatic performance improvement. Second, no extraoverhead is needed by these heuristics as only a single PDB lookup is performed at each node. Thus, the reduction in thenumber of generated nodes is fully reflected in the running times.7.3. The 15-puzzleAnother source of inconsistency can be data compression (Section 6.2). Previous research that compressed PDBs of the15-puzzle [11] used a 7–7–1 additive partitioning (shown in Fig. 25). These experiments were repeated, however this timeBPMX was used. The results (averaged over the same set of 1000 random instances first used by Korf and Felner [26]) arereported in Table 4. The first line corresponds to a regular PDB using a 7–7–1 partitioning (536 MB of memory used byPDBs that were represented with a sparse mapping [11]). In the second line the PDB is compressed to roughly half its size(268 MB). Due to the resulting loss of information, the number of nodes generated increased by 100 903 (from 464 978 toA. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031593Fig. 25. BPMX (a 7–7–1 partitioning into disjoint sets of the 15-puzzle).Table 4Results on the 7–7–1 partitioning of the 15-puzzle.CompressBPMX−++−−+Nodes464 978565 881526 681Table 5Results on the 24-puzzle.RowLookupsHeuristicOne PDB lookup12345Two PDB lookups67Three PDB lookups89Four PDB lookups101111122334RegularDualDual + BPMXRandomRandom + BPMX∗Regular + Regular2 Randoms + BPMXRegular + Regular3 Randoms + BPMX∗ + Dual + BPMXTime0.0580.0690.064Av. h43.5943.0243.02Nodes26 630 050 11524 155 327 78918 188 651 2783 386 033 0151 938 538 7391 631 931 544908 186 066852 810 804818 601 469Memory536 871268 435268 435Time15 09520 10510 7613040152914831065114210221331Regular + Regular∗ + Dual + Dual∗ + BPMX751 181 974565 881) agreeing with previous results [11]. Compressing the PDBs can produce inconsistency and this is born out by theBPMX results in the third line (a decrease in the number of nodes generated to 526 681). At first glance, this seems like amodest reduction of less than 10%. However, a different way of viewing this is that BPMX reduced the loss of informationintroduced by compression by 40%, from 100 903 to 61 703. This was done with no additional cost in memory or time.7.4. The 24-puzzleWe now present results on the 24-puzzle using 6–6–6–6 additive PDBs [26]. Similar tendencies were observed for the15-puzzle with the 7–8 additive PDBs [26]. The results in Table 5 are averaged over the 10 instances with the smallestsolution length from standard 50 random states [26]. Four heuristics are available based on 6–6–6–6 additive PDBs [26]in the table), dual lookup,(Fig. 8): regular lookup, regular lookup reflected about the main diagonal (indicated by arefection of the dual lookup. The random heuristic randomly chooses a heuristic from the set of these four heuristics. Asingle dual or random lookup outperforms the regular lookup. We showed in Section 7.1 that there is a diminishing returnfor adding more lookups for both the regular and random case. In the 24-puzzle, adding more lookups (up to the maximumof four) was beneficial. While the smallest number of nodes was achieved by using all four lookups, the best time wasobtained by an inconsistent heuristic using two or three lookups.∗7.5. The pancake puzzle∗Table 6 shows results for IDAoptimally solving 10 random instances of the 17-pancake puzzle with a PDB of 7 pancakes.There are no geometrical symmetric PDB lookups in this domain; and the only way to achieve inconsistency is with thedual lookup. Rows 1–3 have a single PDB lookup. The dual heuristic reduces the number of nodes generated by more thana factor of 12. This improvement is the consequence of the larger diversity of inconsistent heuristic values encountered in1594A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Table 617-pancake results.RowLookupNodesNormal operator order1234RegularDualDual + BPMXRegular + Dual + BPMXOperators ordered by average heuristic difference5678RegularDualDual + BPMXRegular + Dual + BPMX342 308 368 71727 641 066 26814 387 002 1212 478 269 076113 681 386 06413 389 133 74185 086 12039 563 288Time284 05419 55612 485308695 66595727449DBF15.0015.0010.1110.4515.0015.004.185.93Table 7Average Heuristic Difference (AHD) of the operators of the 17-pancake puzzle.Operator2–1011121314151617Regular0.370–0.3970.3960.3970.4000.4010.4020.4110.216Dual00.6130.9581.1651.2911.3581.3761.321the search. When BPMX is used with the dual heuristic, the number of nodes generated is further reduced by almost afactor of two, the result of the dynamic branching factor falling from 15 to 10.11. The best results (row 4) are achievedby performing two lookups (regular and dual) and using BPMX to propagate inconsistencies. This combination produces a138-fold reduction in nodes generated over the regular lookup on its own.7.5.1. Operator ordering to increase BPMX cutoffsConsider the following insight which can be used to further enhance performance in some domains. If a node has a childthat would cause a BPMX cutoff, it should be generated as early in the set of children as possible. This would allow thecutoff to be made before subtrees under the other children are searched. If different operators tend to create inconsistencyat different rates, the search could be sped up by ordering the operators accordingly. The operators on Rubik’s cube andTopSpin are symmetric and it is difficult to find a useful way to order them. This is not the case for the pancake puzzle;each operator differs in the number of pancakes moved.We introduce a new term, the average heuristic difference (AHD). The AHD(oph) for a given operator op and heuristich is the average, over all states s to which op can be applied, of |h(s) − h(op(s))|. To estimate the AHD of an operator,a random state was chosen (s1) and then the relevant operator was applied to this state (yielding state s2). The differencein the heuristic value between s1 and s2 was measured. This was repeated for 100 million different states. Table 7 showsthe AHD results for the operators of the 17-pancake puzzle. The Regular column presents the AHD for each operator whenthe regular lookup was performed and the Dual column presents the AHD for the dual PDB lookup.The regular PDB lookup is consistent and therefore cannot have an AHD greater than 1. For the dual PDB lookups theresults are more interesting. Operators 2–10 all have AHD values of exactly 0, an artifact of the particular PDB used for theseexperiments. The PDB is based on locations 11–17 and moves which did not affect any of these locations (operators 2–10)could not cause a change in the dual heuristic [14,45]. However, for larger operators (13–17), the AHD for the dual lookupwas more than 1. Note that operator 16 has a larger AHD than operator 17, even though it changes a smaller number oflocations.In Table 6, the results for rows 1–4 were obtained by using the operators in the order of most to least tokens moved. Forrows 5–8, the operators were ordered in decreasing order of AHD of the dual lookup, as measured in Table 7. Even whenBPMX is not used (compare rows 5 and 6 to rows 1 and 2), significant improvements are seen. When BPMX is used, AHDordering roughly halves the DBF and dramatically reduces the number of generated nodes (compare rows 7 and 8 to rows3 and 4). The best result (regular and dual lookup, enhanced with BPMX and AHD ordering—row 8) reduces the number ofgenerated nodes by four orders of magnitude as compared to doing the usual single regular lookup.2020 We use simple PDBs for the pancake puzzle to demonstrate the benefits of inconsistent heuristics. However, enhanced PDB methods [41,17], as wellas the domain specific gap heuristic [16], have been developed for this problem. Applying our techniques on top of these heuristic will likely show similarA. Felner et al. / Artificial Intelligence 175 (2011) 1570–160315958. Pathfinding experiments with A∗Fig. 26. Interleaved differential heuristics.∗A∗∗∗has different properties than IDAsetting, we need an application∗is preferred fordomain for which Apathfinding in explicit state spaces. In this section we will demonstrate that inconsistent heuristics can incur significant∗if BPMX is not used. We then demonstrate a number of cases when inconsistent approaches can outperformoverhead in Aconsistent approaches.is the algorithm of choice for combinatorial puzzles, A. To properly assess inconsistent heuristics in the Ais well suited. Whereas IDAThe application domain is a set of 75 grid maps from commercial games, all scaled to grids of size 512 × 512. Eachlocation on the map is either blocked or unblocked. On each map, problems are broken into 128 buckets according to theoptimal path length, with path lengths varying between 1 and 512. We randomized 1280 problem instances from eachmap (different start/end locations). The agent can move horizontally, vertically or diagonally (eight possible directions). Allexperiments in this section were conducted on a 2.4 GHz Intel Core 2 Duo with 4 GB RAM. Most of our reported resultsare only for BPMX(1) (see Section 5.3.2) and in this section when the term BPMX is used without a parameter it refers toBPMX(1).∗All running times are measured in seconds.8.1. Pathfinding heuristicsOctile distance is the most common heuristic in this domain. If the distances along the x and y coordinates between2 ∗ min(dx, dy) + |dx − dy|. This is the optimal distancetwo points are (dx, dy), then the octile distance between them isbetween the two points if 1) there were no restrictions from obstacles or boundaries, and 2) you are allowed to go to any ofyour neighbors in all eight possible directions (including diagonals). The octile heuristic is consistent and does not requireany memory.√8.1.1. True distance heuristicsTrue-distance heuristics (TDHs) are memory-based heuristics that were recently developed for pathfinding applica-tions [40,13]. An example of a TDH is the differential heuristic [40] (DH) which is built as follows: choose K canonical statesfrom the domain; compute and store the shortest path distance from all K canonical states to all other reachable states. Foreach canonical state, S memory is required, where S is the number of states in the state space. For the ith canonical state,ki , an admissible heuristic for any two points a and b can be obtained using hi(a, b) = max(|c(a, ki) − c(b, ki)|, octile(a, b)),where c(x, y) is the shortest path from x to y that is stored in the database. Because c(a, b) + c(b, ki) (cid:3) c(a, ki) for any a,b and ki , it follows that c(a, b) (cid:3) c(a, ki) − c(b, ki). Hence |c(a, ki) − c(b, ki)| is an admissible consistent heuristic for thedistance between a and b.|c(a, ki) − c(b, ki)| can sometimes produce a heuristic value higher than the octile heuristic. For example, this can happenwhen b is on the optimal path from a to ki , and the exact distance from a to b is larger than the octile distance. However,DH can sometimes produce values smaller than the octile distance. Taking the maximum of the DH and the octile heuristicguarantees that the new heuristic dominates the octile heuristic.For a given state, if one takes the maximum of all available differential heuristics, the resulting value is a consistentheuristic. However, if a random subset of the available heuristics is considered then the resulting value will be inconsistent.8.1.2. Interleaved differential heuristicsWe introduce the interleaved differential heuristic (IDH), a convenient way to get most of the benefits of multiple DHs(i.e., with multiple canonical states) but with the storage of only one (similar to what was done in [5]). Consider havingfive DHs 0. . . 4. Instead of storing the distances to all five canonical states at all states, only store a single distance at eachstate. Consider Fig. 26 with an empty grid. Each cell is labeled with the canonical state whose distance is stored at thatperformance gains. In fact, an advantage of using BPMX and random heuristics for this application has already been demonstrated with one of these recentPDBs [17].1596A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603state. In this setup, S memory is used to store portions of all five heuristics, but the search can benefit from all of them asfollows.A heuristic value between two states is only available if the distance to the same canonical state is stored at each state.Thus, if the current node being expanded is state D at the bottom of the grid and the goal is state G (dotted border), thenDH can be used to directly lookup a heuristic value between these two states (both use canonical state 3). However, ifstate A is being expanded, no differential heuristic between A and G can be directly computed (different canonical states).However, neighboring G is state F for which such a heuristic can be computed. Thus, h( A, G) = |c( A, k0) − c(F , k0)| − c(F , G),for canonical state k0. There are many lookups that can be performed using both the neighborhood of the current searchnode and the neighborhood of the goal. More lookups will improve the heuristic estimate but take more time. In this workonly lookups from the current state to neighbors of the goal are performed.The final heuristic is the maximum of the computed IDH heuristic and the octile heuristic. Because different heuristicsare used at each state, the overall heuristic is inconsistent.For further efficiency and improved performance, when we use IDHs we perform a small breadth-first search startingat the goal until one possible state is found for each possible DH lookup. We cache all distances and associated errors.Then, for any given node during the search we perform a single lookup in the cache to lookup a heuristic value. This cacheapproach is efficient because the identity of the neighbor state is unimportant; only the distance and additional error areneeded. Therefore the cache is the size of the number of interleaved heuristics, not the number of neighbors of the goal.8.2. Random heuristic∗The first set of experiments illustrates the effect of BPMX on Awhen an inconsistent heuristic is used. Three heuristicsare compared:(a) octile distance (consistent, used as the baseline);(b) ten DHs (10 canonical states) were built and in a given state one was randomly chosen to use (inconsistent, calledrandom). This was done with and without BPMX; and(c) maximum of all ten DHs (consistent, best possible heuristic).The memory needs for 10 DHs (for both random and maximum) is 10S.∗As expected, AFig. 27 presents experimental results for the number of nodes (bottom) and the CPU time (top). The problem instanceswere partitioned into buckets based on their solution length. The x-axis presents the different solution lengths, with eachpoint being the average solution length of a bucket. The y-axis is the number of node expansions using a logarithmic scale.with the randomwith the max of all possible heuristics expands the fewest number of nodes. Aheuristic and no BPMX expands the most. The random heuristic can never produce worse heuristic values than the octileheuristic. However, random without BPMX performs almost an order of magnitude more node expansions than the octileheuristic due to node re-expansions. From the slope of the lines, it appears that random without BPMX adds a slight∗polynomial overhead to Awith the octile heuristic, and theperformance is quite close to the consistent (max) heuristic. This shows that BPMX is effective at overcoming the node re-expansion problem. It is impressive that BPMX enhances random, with its single lookup, to achieve nearly the performanceof max, with its ten lookups.∗. When BPMX is added to random it performs better than A∗Timing results (top of the figure) show similar trends. Random (with and without BPMX) has faster lookup times than, where thethe correct maximum value is needed. Hence, lazy evaluation∗the max heuristic (fewer heuristics are consulted) and for short paths has better time performance. Unlike IDAalgorithm only needs to know whether a cutoff occurs, in A∗is not possible in A∗.8.2.1. Fixed number of lookupsFig. 28 presents a comparison where k heuristics were used. These k lookups were either fixed (same heuristic used atall nodes; consistent) or randomized (random selection at a given node; inconsistent) out of 10 available heuristics. BPMXwas used for the inconsistent heuristics. In this experiment only the problems with the longest solutions on each map wereconsidered. Each point represents the average of approximately 500 instances, plotting both time and node expansions onlogarithmic scales. The top curve shows the performance given k fixed lookups are used, while the bottom curve shows theperformance using k random lookups.This experiment shows that if the number of lookups is fixed, then a random strategy is better than a fixed strategyfor low values of k, as more diversity is added to the resulting heuristic. When k increases, the significance of this effectdecreases as more lookups implicitly adds more diversity of values with the fixed lookups too. In this domain, the consistentmax-of-10 heuristic achieved the best time results.The results are explained by a number of key differences between using maps and using combinatorial puzzles as ap-plication domains. These differences cause more difficulties to achieve speedup in the search with inconsistent heuristics inthe pathfinding domains than in the puzzle domains.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031597Fig. 27. Nodes expanded in pathfinding with 10S memory.Fig. 28. Comparing fixed and random lookups.• Memory: Unlike the permutation puzzles, where k lookups (random or fixed) need the same amount of memory, herek fixed lookups need kS memory, while k random lookups (out of 10) need 10S memory. k fixed lookups uses lessmemory and therefore may have better memory and cache performance. This explains why when k (cid:3) 7 the fixedlookups have a lower search time than the random lookups.• Indexing time: In the puzzle domains the cost of determining where to find a heuristic lookup is relatively expensive.Typically a non-trivial indexing function is needed, and possibly the application of one or more symmetries and/orpermutations. In the map domain, indexing is easier to compute, leading to (slightly) faster lookup times.• Node re-expansion: In IDA∗∗A(as used in the maps domain), the problem of node re-expansions can cause problems (even when BPMX is used).(as used in the puzzle domains), an inconsistent heuristic does not affect performance. InThus, the maximum of 10 heuristic would be the best choice in the pathfinding domain both in nodes and in time, whilein the puzzles inconsistent heuristics with fewer lookups might yield faster times (e.g., in our 24-puzzle results).Given a new domain, these are important factors which determine whether inconsistent approaches will be successful.In Section 8.3 we show that the interleaved heuristic allows multiple lookups and improves the performance of differentialheuristics using inconsistency and BPMX.1598A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 29. Time versus nodes tradeoff as more heuristics are available.8.2.2. Varying the number of lookups performedThis section examines the performance of random lookups as the amount of available memory (and number of heuristics)increases up to 100S. Three approaches for performing lookups are considered:(a) take the maximum of all available heuristics at each node,(b) take the maximum of 10% of the available heuristics at random (and use BPMX), and(c) take the maximum of 20% of the available heuristics at random (and use BPMX).For example, if 10 heuristics are available (10S memory), then 1 or 2 lookups are performed at each state for the 10% and20% heuristics, respectively. Similarly, if 50 heuristics are available, 5 or 10 lookups are performed for the 10% and 20%heuristics respectively.Fig. 29 shows three curves, one for each approach. Between 10 and 100 differential heuristics were built, increasingby intervals of 10. The nodes expanded and time elapsed to solve the hardest problems (length 508–512) on each mapare computed and compared for each of the three approaches. The points which correspond to having 10, 50 and 100differential heuristics available are labeled on each curve. This is a log–log plot, making the differences easier to see.Consider the consistent heuristic which takes the maximum over all available heuristics. With 10 differential heuristics,an average of 7 milliseconds is needed to complete a search with 1884 node expansions. As more differential heuristics areused, the number of node expansions monotonically decreases. However, execution time only decreases until 30 differentialheuristics are used, at which point the cost of performing additional lookups overtakes the reduction in nodes expanded.Randomly using only 10% of the available heuristics is inconsistent. This curve begins with the worst performance of thethree in terms of both nodes and time. However, when 10 random heuristics (out of 100) are used it is able to match thebest time performance of the consistent heuristic (30 lookups) and is faster than the consistent heuristic with 40 or morelookups.Randomly using 20% of the available heuristics matches the time performance of 30 consistent lookups when performingonly six random lookups (both use 30S memory). The fastest performance is when 60S memory is available (12 lookupsare performed) and is significantly better than the best fixed lookup result. The error bars on this curve correspond to 95%confidence intervals, showing that this result is statistically significant, albeit by a small margin.8.3. Interleaved differential heuristicsIn this section, experimental results comparing a number of approaches that all use 1S memory are reported. The octileheuristic is used as the baseline (using the same results shown previously). A single consistent lookup is compared to aninterleaved differential heuristic (IDH, defined in Section 8.1.2) built using 10 differential heuristics (1S memory). Fig. 30presents the node expansions and the CPU time for these approaches. The results are plotted as a function of the solutionlength. Unlike previous figures, both axes have linear scales.The nodes expanded and timing results reinforce the earlier discussion. BPMX is critical to achieving good performance.Again, even though the heuristic values are no worse than that of the octile heuristic, the performance of the interleaved(inconsistent) heuristic without BPMX is poor (roughly by a factor of 10 for the hardest problems). Both versions of theinterleaved heuristic with BPMX outperform the consistent DH heuristic. BPMX(1) was better than BPMX(∞). When 1SA. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031599Fig. 30. Nodes expanded with 1S memory.memory is available for this domain, an inconsistent heuristic outperforms a consistent heuristic and produces the bestresults. The curves for timing results maintain their same orderings and the same relative performance, supporting thatBPMX node expansions (for d > 1) should count the same as Anode expansions.∗Fig. 31 shows the results for using 80 DHs interleaved into 10S memory. This is compared to 10S memory for 10 fixedlookups. The consistent heuristic with 10S is relatively informed but a slight reduction was achieved by the inconsistentheuristic.8.4. Different degrees of BPMXThe final experiment examines the effect of increasing the BPMX propagation depth. Fig. 32 shows the effect of usingdifferent BPMX propagation depths. The set of problems from Fig. 27 are used, plotting the number of nodes expanded asa function of the solution length. The heuristic is a random selection from the 10 available DHs. Node expansions refers toeach time the neighbors of a node are generated and looked up in OPEN or CLOSED. As explained above, this process is∗exactly the same in BPMX(k) for k > 1 as in a regular Aexpansion. Hence, BPMX expansions are counted the same as Aexpansions. Time results are omitted as they show the same trend.∗For this domain and for this heuristic, BPMX(1) was the best. Larger values of k do not help on average, as sufficientlylarge heuristics seem to always be within one step. In a sense this is fortunate, as BPMX(1) is easy to implement andproduces the best results.9. Discussion and conclusionsHistorically, inconsistent heuristics have been generally avoided when searching for optimal solutions because of theand the belief that inconsistent heuristics are hard to concoct. This paper hascost of re-expanding closed nodes with A∗, and that thedemonstrated that effective inconsistent heuristics are easy to create, can be integrated into IDAbenefits of doing so often substantially reduce the search effort. This represents an important change to the conventionalwisdom for heuristic search.∗and A∗behavior. We showed that Are-expands nodes whether the heuristic is consistent or not, so using inconsistent heuristics does not hurt its’s worst-case exponential behavior is only valid under unrealistic graph settings. Furthermore,∗∗IDA1600A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603Fig. 31. Average nodes expanded and time with 10S memory.Fig. 32. Average nodes expanded for different degrees of BPMX propagation.we generalized the known pathmax propagation rules to bidirectional pathmax (BPMX) and showed that BPMX can lead tofurther performance gains.∗Indeed, experimental results showed major performance gains with inconsistent heuristics for IDA. For allwas used (the puzzle domains), a very large reduction (more than an order of magnitude for manydomains where IDAcases) in the number of generated nodes (and CPU time) was obtained when a single inconsistent heuristic was usedinstead of a single regular consistent heuristic. This was the consequence of introducing more diversity into the heuristicvalues encountered in a search. A further reduction in the number of generated nodes was obtained when BPMX wasimplemented on top of the inconsistent heuristic, as one large heuristic value might influence the entire neighborhood ofstates.∗∗and for AIn all the domains studied in this paper, more than a single heuristic is available either due to internal symmetries of thesame PDB (in the puzzles) or to manually creating more heuristics (in the pathfinding domain). When multiple heuristicsexist, clearly taking the maximum of all heuristics provides the best heuristic value for all states and generates the fewestnodes. This comes with an increase in the runtime overhead per node because of the cost of the additional lookups. Moreheuristics being considered increases the diversity of heuristic values, reducing the number of node expansions. There-fore, when multiple heuristics are available and more lookups are performed, the performance advantage of inconsistentover consistent heuristics decreases. The results presented in this paper vary, in part, because of the number of heuristicsavailable in each of the experimental domains.∗When AA. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031601Fig. 33. 9-pancake states.For TopSpin, the relative advantage of inconsistent heuristics over regular heuristics remains valid for a large range of thenumber of multiple lookups that are performed. In practice, one might use all 17 lookups as they perform equally to othervariants of the random lookups. For Rubik’s cube when four lookups are possible the advantage of inconsistent heuristicsdisappears.For the 24-puzzle, the maximum number of lookups is four. Two or three random lookups were shown to outperform(in time) the maximum of all four. For the pancake puzzle, only a single lookup exists and the use of inconsistent heuristicsproduced spectacular gains.is used (in the pathfinding domain), the problem of node re-expansion arises. This issue can cause a single(random) inconsistent heuristic to generate more nodes than a consistent (octile) heuristic, even though the inconsistentheuristic returns a superior heuristic value for all states. When BPMX is added, the inconsistent heuristic (random) outper-forms a single consistent heuristic and is almost as good as the maximum of ten heuristics (both in node expansions andtime). However, the max of 10 heuristics is still the best choice.It is more difficult to obtain a speed up when using multiple heuristics in an inconsistent manner in the pathfindingdomain than in the puzzle domains for a number of reasons. First, the number of states in the pathfinding domain growsquadratic in the depth of the search while in the puzzle domains it grows exponentially—there is more room for improve-ment. Second, no symmetries are possible in the pathfinding domain and more (potential) lookups need more memory.Third, the lookup time is much smaller than a PDB lookup, so performing multiple lookups is not as costly. Finally, there isthe issue of node re-expansions. However, despite this complication, in this domain too the use of an inconsistent heuris-tic provides the best results. An inconsistent heuristic that is based on interleaving a number of heuristics was shown tooutperform a consistent heuristic given the same amount of memory.The major result of this paper is the demonstration that inconsistent heuristics can increase the diversity of valuesencountered in a search, leading to improved performance. Based on these results, it is our expectation that the use of in-consistent heuristics will become an accepted and powerful tool in the development of high-performance search algorithms.A number of directions remain for future research. Identifying more ways for creating inconsistent heuristics will helpmake their usage more common and beneficial. As well, more research is needed on different variations of BPMX. In partic-ular, different levels of lookahead searches for finding large heuristic values might result in better overall performance.AcknowledgementsThis research was supported by the Israel Science Foundation (ISF) under grants number 728/06 and 305/09 to ArielFelner. The research funding from Alberta’s Informatics Circle of Research Excellence (iCORE) and Canada’s Natural Sciencesand Engineering Research Council (NSERC) is greatly appreciated.Appendix A. Example for dual state heuristicIn this section, we provide an example that shows why the dual heuristic can provide inconsistent values. Consider the9-pancake puzzle states shown in Fig. 33. State G is the goal state of this puzzle. State S 1 is the neighbor of G obtained byreversing the tokens at locations 1–3 (shown in the bold frame), and state S 2 obtained by further reversing the tokens inlocations 1–6. States Gd, Sd2 are the dual states of G, S1 and S2 respectively.1 and SdNote that in this particular examples S1 and Sd1 are identical. In this domain applying a single operator twice in a rowwill reach the same state and state S1 is a single move away from the goal. It is easy to see that applying the same sequence1602A. Felner et al. / Artificial Intelligence 175 (2011) 1570–1603of operators (reverse locations 1–3, reverse locations 1–6) to Sd2 will produce the goal state. Observe that while states S12 (their duals) are not neighbors. Reversing any consecutive k first tokens of state Sdand S2 are neighboring states, Sd1will not arrive at node Sd2 which differ by more than 1.Using these values for S1 and S2 would be inconsistent since they are neighbors. This can be shown by the following PDBexample. Suppose patterns for the 9-pancake puzzle are defined by only considering tokens 4–6 while ignoring the rest ofthe tokens. The resulting PDB provides distances to the goal pattern from all reachable patterns. The right column of Fig. 33shows the corresponding pattern for each state obtained by using the ∗ symbol to represent a “don’t care”.2. Therefore, a consistent heuristic might return values for Sd1 and Sd1 and SdRegular PDB lookups produce consistent heuristic values during search [20]. Indeed, since states S 1 and S2 are neighbors,their PDB heuristic values differ by at most 1. In state S1, tokens 4–6 are in their goal locations and therefore h(S1) = 0. Instate S2 tokens 4–6 are not in their goal locations and we need to apply one operator to reach the goal pattern and thush(S2) = 1. Dual PDB lookups are admissible, but not necessarily consistent. The dual PDB lookup for state S 1 (i.e., the PDBlookup for state Sd1. However, the pattern projected fromstate Sd2 is two moves away from the goal pattern. Thus, performing the dual lookup for states S 1 and S2 (i.e., PDB lookupsfor states Sd2) will produce heuristics that are inconsistent (0 and 2). When moving from S 1 to S2 (or vice versa),even though g was changed by 1, h was changed by 2.1) returns 0 since tokens 4–6 are in their goal location for state Sd1 and SdReferences[1] A. Bagchi, A. Mahanti, Search algorithms under different kinds of heuristics—A comparative study, Journal of the ACM 30 (1) (1983) 1–21.[2] M. Ball, R.C. Holte, The compression power of symbolic pattern databases, in: International Conference on Automated Planning and Scheduling (ICAPS-08), 2008, pp. 2–11.[3] B. Bonet, H. Geffner, Learning depth-first search: A unified approach to heuristic search in deterministic and non-deterministic settings, and its appli-cation to MDPs, in: International Conference on Automated Planning and Scheduling (ICAPS-06), 2006, pp. 142–151.[4] T. Chen, S. Skiena, Sorting with fixed-length reversals, Discrete Applied Mathematics 71 (1–3) (1996) 269–295.[5] J.C. Culberson, J. Schaeffer, Pattern databases, Computational Intelligence 14 (3) (1998) 318–334.∗[6] R. Dechter, J. Pearl, Generalized best-first search strategies and the optimality of A[7] C. Domshlak, E. Karpas, S. Markovitch, To max or not to max: Online learning for speeding up optimal planning, in: AAAI Conference on Artificial, Journal of the ACM 32 (3) (1985) 505–536.Intelligence (AAAI-10), 2010, pp. 1701–1706.[8] H. Dweighter, Problem e2569, American Mathematical Monthly 82 (1975) 1010.[9] S. Edelkamp, Planning with pattern databases, in: European Conference on Planning (ECP-01), 2001, pp. 13–24.[10] A. Felner, R.E. Korf, S. Hanan, Additive pattern database heuristics, Journal of Artificial Intelligence Research 22 (2004) 279–318.[11] A. Felner, R.E. Korf, R. Meshulam, R.C. Holte, Compressed pattern databases, Journal of Artificial Intelligence Research 30 (2007) 213–247.[12] A. Felner, R. Meshulam, R.C. Holte, R.E. Korf, Compressing pattern databases, in: National Conference on Artificial Intelligence (AAAI-04), 2004, pp. 638–643.[13] A. Felner, N. Sturtevant, J. Schaeffer, Abstraction-based heuristics with true distance computations, in: Symposium on Abstraction, Reformulation andApproximation (SARA-09), 2009.[14] A. Felner, U. Zahavi, J. Schaeffer, R.C. Holte, Dual lookups in pattern databases, in: International Joint Conference on Artificial Intelligence (IJCAI-05),2005, pp. 103–108.[15] P.E. Hart, N.J. Nilsson, B. Raphael, A formal basis for the heuristic determination of minimum cost paths, IEEE Transactions on Systems Science andCybernetics SCC-4 (2) (1968) 100–107.[16] M. Helmert, Landmark heuristics for the pancake problem, in: Third Annual Symposium on Combinatorial Search (SOCS-10), 2010, pp. 109–110.[17] Malte Helmert, Gabriele Röger, Relative-order abstractions for the pancake problem, in: ECAI, 2010, pp. 745–750.[18] R.C. Holte, A. Felner, J. Newton, R. Meshulam, D. Furcy, Maximizing over multiple pattern databases speeds up heuristic search, Artificial Intelli-gence 170 (2006) 1123–1136.[19] R.C. Holte, J. Newton, A. Felner, R. Meshulam, D. Furcy, Multiple pattern databases, in: International Conference on Automated Planning and Scheduling(ICAPS-04), 2004, pp. 122–131.∗[20] R.C. Holte, M.B. Perez, R.M. Zimmer, A.J. MacDonald, Hierarchical AIntelligence (AAAI-96), 1996, pp. 530–535.: Searching abstraction hierarchies efficiently, in: National Conference on Artificial[21] A. Junghanns, J. Schaeffer, Domain-dependent single-agent search enhancements, in: International Joint Conference on Artificial Intelligence (IJCAI-99),1999, pp. 570–575.[22] R.E. Korf, Depth-first iterative-deepening: An optimal admissible tree search, Artificial Intelligence 27 (1) (1985) 97–109.[23] R.E. Korf, Real-time heuristic search, Artificial Intelligence 42 (3) (1990) 189–211.[24] R.E. Korf, Finding optimal solutions to Rubik’s Cube using pattern databases, in: National Conference on Artificial Intelligence (AAAI-97), 1997, pp. 700–705.[25] R.E. Korf, Recent progress in the design and analysis of admissible heuristic functions, in: National Conference on Artificial Intelligence (AAAI-00), 2000,pp. 1165–1170.[26] R.E. Korf, A. Felner, Disjoint pattern database heuristics, Artificial Intelligence 134 (1–2) (2002) 9–22.[27] R.E. Korf, A. Felner, Recent progress in heuristic search: A case study of the four-peg Towers of Hanoi problem, in: International Joint Conference onArtificial Intelligence (IJCAI-07), 2007, pp. 2324–2329.[28] R.E. Korf, M. Reid, Complexity analysis of admissible heuristic search, in: National Conference on Artificial Intelligence (AAAI-98), 1998, pp. 305–310.[29] R.E. Korf, M. Reid, S. Edelkamp, Time complexity of iterative-deepening-A[30] R.E. Korf, W. Zhang, I. Thayer, H. Hohwald, Frontier search, Journal of the ACM 52 (5) (September 2005) 715–748.∗[31] A. Mahanti, S. Ghosh, D. Nau, A. Pal, L. Kanal, On the asymptotic performance of IDA, Annals of Mathematics and Artificial Intelligence 20 (1–4) (1997), Artificial Intelligence 129 (1–2) (2001) 199–218.∗161–193.[32] A. Martelli, On the complexity of admissible search algorithms, Artificial Intelligence 8 (1) (1977) 1–13.∗[33] M. McNaughton, P. Lu, J. Schaeffer, D. Szafron, Memory efficient Aheuristics for multiple sequence alignment, in: National Conference on ArtificialIntelligence (AAAI-02), 2002, pp. 737–743.[34] L. Mero, A heuristic search algorithm with modifiable estimate, Artificial Intelligence 23 (1984) 13–27.[35] N. Nilsson, Artificial Intelligence: A New Synthesis, Morgan Kaufmann, 1998.[36] J. Pearl, Heuristics: Intelligent Search Strategies for Computer Problem Solving, Addison-Wesley, 1984.A. Felner et al. / Artificial Intelligence 175 (2011) 1570–16031603[37] D. Ratner, M.K. Warmuth, Finding a shortest solution for the N × N extension of the 15-puzzle is intractable, in: National Conference on ArtificialIntelligence (AAAI-86), 1986, pp. 168–172.[38] S. Russell, P. Norvig, Artificial Intelligence, A Modern Approach, Third edition, Prentice-Hall, 2010.[39] M. Samadi, M. Siabani, A. Felner, R.C. Holte, Compressing pattern databases using learning, in: European Conference on Artificial Intelligence (ECAI-08),2008, pp. 495–499.[40] N. Sturtevant, A. Felner, M. Barer, J. Schaeffer, N. Burch, Memory-based heuristics for explicit state spaces, in: International Joint Conference on ArtificialIntelligence (IJCAI-09), 2009, pp. 609–614.[41] F. Yang, J. Culberson, R.C. Holte, U. Zahavi, A. Felner, A general theory of additive state space abstractions, Journal of Artificial Intelligence Research 32(2008) 631–662.∗[42] U. Zahavi, A. Felner, N. Burch, R.C. Holte, Predicting the performance of IDA(AAAI-08), 2008, pp. 381–386.∗[43] U. Zahavi, A. Felner, N. Burch, R.C. Holte, Predicting the performance of IDAResearch 37 (2010) 41–83.with conditional distributions, in: AAAI Conference on Artificial Intelligence(with BPMX) with conditional distributions, Journal of Artificial Intelligence[44] U. Zahavi, A. Felner, R.C. Holte, J. Schaeffer, Dual search in permutation state spaces, in: National Conference on Artificial Intelligence (AAAI-06), 2006,pp. 1076–1081.[45] U. Zahavi, A. Felner, R.C. Holte, J. Schaeffer, Duality in permutation state spaces and the dual search algorithm, Artificial Intelligence 172 (4–5) (2008)514–540.[46] U. Zahavi, A. Felner, J. Schaeffer, N.R. Sturtevant, Inconsistent heuristics, in: National Conference on Artificial Intelligence (AAAI-07), 2007, pp. 1211–1216.[47] Z. Zhang, N. Sturtevant, J. Schaeffer, R.C. Holte, A. Felner, Agence (IJCAI-09), 2009, pp. 634–639.∗search with inconsistent heuristics, in: International Joint Conference on Artificial Intelli-[48] R. Zhou, E. Hansen, Space-efficient memory-based heuristics, in: National Conference on Artificial Intelligence (AAAI-04), 2004, pp. 677–682.[49] R. Zhou, E. Hansen, Breadth-first heuristic search, Artificial Intelligence 170 (4–5) (2006) 385–408.∗[50] R. Zhou, E.A. Hansen, Memory-bounded Agraph search, in: Florida Artificial Intelligence Research Society (FLAIRS-02), 2002, pp. 203–209.