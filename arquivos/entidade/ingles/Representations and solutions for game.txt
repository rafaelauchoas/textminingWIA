ELSEVIBR Artificial Intelligence 94 (1997) 167-215 Artificial Intelligence Representations and solutions for game-theoretic problems Daphne Koller *, Avi Pfeffer * Computer Science Department, Gates Building IA. Stanford University, Stanford, CA 94305-9010, USA Abstract A system with multiple interacting agents (whether artificial or human) is often best ana- tools. Unfortunately, while the formal foundations are well-established, lyzed using game-theoretic techniques for game-theoretic reasoning are inadequate for dealing with standard computational realistic galmes. This paper describes the Gala system, an implemented system that allows the specification and efficient solution of large imperfect information games. The system contains the first implernentation of a recent algorithm, due to Koller, Megiddo and von Stengel. Experimental results from the system demonstrate that the algorithm is exponentially faster than the standard algorithm in practice, not just in theory. It therefore allows the solution of games that are orders of magnitude larger than were previously possible. The system also provides a new declarative lan- guage for compactly and naturally representing games by their rules. As a whole, the Gala system provides tbe capability for automated game-theoretic analysis of complex real-world situations. @ 1997 Elsevier Science l3.V. Keywords: Game theory; Algorithms; Imperfect information; Multi-agent systems; Game playing; Logic programming; Poker 1. Introchction When dlesigning or analyzing tant to consider and the information mally model “rational” strategies available such a situation the (often incompatible) a situation with multiple it is impor- their possible actions, to them. Game theory provides us with the tools to for- it, and to prescribe as a multi-player goals of these entities, to analyze interacting entities, game, to the different players. * Corresponding author. Email: koller@cs.stanford.edu. ’ &nail: avi@cs.stanford.edu. 0004-3702/97/$17.00 @ 1997 Elsevier Science B.V. All rights reserved. PZISOOO4-3702(97)00023-4 168 D. KolleK A. Pfeffer/Artijicial Intelligence 94 (1997) 167-215 Perfect information Imperfect information No chance Chance Chess Go Inspection game Battleships Backgammon Monopoly OPEC game Poker Fig. 1. Examples of games of various types. real Since incompatible theory has been fundamental microeconomic FCC auction of wavelengths government and more. Clearly, situations policy, tions. e.g., applications and resource information allocation or service involving multiple life contains many situations agents with goals, game theory has played a role in a variety of different areas. Game of (such as the design of the 1995/6 in the realm of (both strategic and tactical), biology, [ 221) . Game theory has also been applied theory and in more practical examples law, politics, military analysis [ 11, both in the theoretical in economics foundations interacting involving multiple agents also arise in computer In some applications, the agents are a mixture of computer in computer game playing, interface design, or discourse understanding. involve two or more artificial agents, e.g., network in a distributed system, coordination science applica- and human users, Other load sharing robots, and routing, of multiple transactions of game-theoretic on the internet. analysis The applicability to computer science problems has not In recent years, several such problems have been analyzed using game the work of Franklin, Galil, and include [ 281 on network routing protocols, intelligence, more of foundations results. Examples the work of Shenker [ 231 on discourse understanding. are turning to game (see, for example, [ 271 and the references for the theoretical tools, with interesting gone unnoticed. theoretic Yung [ 71 on computer security, and the work of Parikh and more multi-agent Despite researchers systems the growing popularity of game little work on providing effective automated in this area has focused almost exclusively on solution algorithms information: world. Unfortunately, concern game hidden theory as an analytic tools for game-theoretic state of the such games form a very small fraction of the class of games that that are In real life, almost all situations there has been analysis. The work for games of pe@ct games where all players have full knowledge of the current from the players. some aspects therein). tool, In artificial contain theory. theory from the possibility the lack of information It is important to distinguish moves. The former involves uncertainty situations where different players have access to different only uncertainty games may materializes. Both perfect and of chance; examples of games from all four categories are shown these are popular to model arms control of chance about the current state of the world, particularly information. The latter involves is resolved as soon as the future involve an element in Fig. 1. Most of theorists is used by game in Section 3.5. The OPEC game the future, uncertainty which information games. The inspection it is described recreational inspections; imperfect about game D. Kollel; A. Pfe$er/Arti$icial Intelligence 94 (1997) 167-215 169 models oil pricing by oil-producing textbook [ 251. countries; it is described in Rasmusen’s game theory As it turns out, the presence of chance elements does not necessitate major changes to solve a game. In fact, the cost of solving a used techniques information game with chance moves to the computational perfect a game with no chance moves. By contrast, greatly one player case, 2 and is even more of a problem when the different players may have access to different greater of imperfect the complexity of the problem. This increase materializes is not substantially in the multi-player the introduction information. increases than solving information even in the case, particularly (both conceptual this problem has been infrastructure and algorithmic) largely of dealing with imperfect level. ignored at the computational for dealing with such games has had several Due to the complexity games, information The lack of a computational unfortunate consequences: l Since game-theoretic the decision-maker must abstract faced with a more complex analysis must be done manually, only small simple games (as most real-life it until the results of the to the original insight, can rarely be applied directly analysis. As a consequence, the situation and simplify to manual situation can be analyzed. When situations are), it b’ecomes amenable analysis, while providing problem. l Manual game-theoretic analysis is a subtle and complicated task, which can only the tools provided by game theory are only be performed by experts. Therefore, available to the general public via specialized consultants. l The lack of practical game-theoretic algorithms has prevented the use of game- theoretic decision making directly by autonomous this paper, we take a first step towards addressing In artificial agents. this lack. We describe system, called Gala, which automates game-theoretic takes a description implemented class of games. The system for the different players which are game-theoretically strategies described. the game If desired, or more of the agents), providing arise. of a game, analyzes rational (playing a picture of the different scenarios the system can also simulate analysis an for a large it, and outputs for the situation the role of one to that are likely The Gala system is composed of two main interacting pieces. The first allows to be described complex games specification which a large game For example, Fig. 2 presents part of a Gala specification is typically described in natural language, which we also call Gala. The Gala language mimics language, by presenting for the game of Poker. clearly and concisely, using a special-purpose large game the way in its rules. such as this, .a game specification the extensive form of a game, a natural augmentation Given generates by game theorists. “Standard” game trees, as typically used in AI game-playing are inadequate information with information sets. of the Gala system of a game tree utilized systems, the agents’ game trees they do not represent this problem by augmenting for modelling state. The extensive real-life games, since the first component form addresses ’ The problem of solving a Markov decision process (MDP) is much easier than the problem of solving a partially observable Markov decision process (POMDP). See [ 101 for a survey. 170 D. Keller; A. Pfeffer/Art@cial Intelligence 94 (1997) 167-215 gamecpoker, C players: [dealer. gambler], flow: (play_round(ante), deal, bet), ante: (money($player) gets $cash, %% each player gets his/her initial allocation of cash payC§ante, gplayer, pot)), Xii and pays the ante into the pot deal: (choose(nature, (Handl, HsndS), (dealcdeck, Ocards, Handi), dealcdeck, $cards, HandZ))), %% a pair of random hands is chosen and dealt from the deck revealcgambler, myhand(Handl)), revealcdealer, myhand(Hand;?)), %% each player's hand is revealed only to him if(beats(Hand1, HendZ), betterhsnd gets gambler, betterhand gets dealer)), XX evaluate the hands immediately, so that we only do %% it once per deal, rather than at every possible showdown bet: (choose(gambler, InitialBet, betueen(0, $money(gambler), InitialBet)), %% the player chooses his bet revealcdealer, betcgembler, InitialBet)), %% reveals it to the other player debt := InitialBet, pay(InitialBet, gambler, pot), %% and pays it into the pot take_turns(next_bet)), next-bet: (choose($player, Bet, ( % meet or raise between($debt, $money($player), Bet) ; % fold ($debt>O, Bet = O))), if(($debt>O, Bet = 01, wins($opponent), (pay(Bet, Splayer, pot), % meet or raise if($debt=O, % fold wins($betterhand), % showdown (reveal($opponent. bet($player. Bet)), debt gets Bet - $debt))))), Fig. 2. Abbreviated Gala description of poker. D. Keller; A. veffer/Artijcial Intelligence 94 (1997) 167-215 171 The second main component of the Gala system automatically analyzes optimal strategies use of randomized strategies formance. The basic insight the opponent(s) for games in extensive is essential is that deterministic to gain additional form. For games of imperfect in order to achieve guaranteed strategies can be predictable, information about the state of the game. and finds information, the reasonable per- allowing Once randomized strategies are allowed, the existence of “optimal information games can be proved perfect an optimal optimal deterministic poker game that the optimal strategy does, indeed, use randomization. for chess. Indeed, Kuhn [ 211. In particular, randomized for poker, in much strategy strategy strategies” this means in im- that there exists the same way as there exists an [ 141 has shown for a simplified than The optimal to his opponent, the player cannot do better strategy has several advantages: i-f playing against a good opponent; furthermore, i.e., the opponent gains no advantage strategy even if his strategy is revealed figuring out the player’s strategy. This last feature is particularly of automated game-analysis attack: sometimes way, their strategy can be discovered by intensive of randomized information none of the (very such strategies. this the player does not do worse from in the context to this form of the code is accessible, and in general, since they always play the same testing. Given these important benefits that games, ) utilize that deal with these games they are often vulnerable it is somewhat surprising few) AI papers in imperfect programs, important strategies [ 3,8,29] (e.g., since Clearly, none of the minimax-based in standard game strategies strategies in imperfect of solution algorithms information for imperfect trees can be adapted solution algorithms for finding optimal randomized games. The Gala system provides access to a variety used to the task of finding information games. them solution algorithms they use. Traditionally, to an alternative Game-theoretic game representation by converting linear optimization then be used for finding optimal strategies. Gala provides access solution algorithms by interfacing with a state-of-the-art called GAMBIT [ 191. can be partitioned games representation, routines such as linear programming in extensive called into two classes, based on the form have been solved form. Standard can and linear complementarity the normal game-theoretic to these normal-form solving system Unfortunately, the normal-form rendering implements an alternative size of the representation, therefore [ 121, for solving games game to a different more compact algorithm,s. The result is solution algorithms form based algorithms. than the normal representation, in extensive incurs exponential conversion process this approach in the blowup for large games. Gala approach, due to Koller, Megiddo and von Stengel the is much called the sequence form. This representation is based on converting form. The approach impractical form, but supports the use of similar that are exponentially linear optimization faster than the normal- One of the sequence-form algorithms (others will be added in future versions of the system). We provide results form). Our results show that this algorithm but also in practice. as part of the Gala system the first experimental (based on the normal in theory, solve complex games where the tree has it to the standard algorithm It allows us to optimally for this algorithm, faster not only is exponentially is implemented comparing 172 D. Keller; A. Pjeffer/Artificial Intelligence 94 (1997) 167-215 r J Q K 6 7 6 9 10 J G K Card received Second round -6 7 6 Caed recense* First round Fig. 3. Gambler strategies for g-card poker. tens of thousands of nodes. In comparison, normal-form game trees larger than 30 nodes. algorithms can rarely deal with the ability By combining from a Gala specification them, the Gala system provides a complete automated game-theoretic to easily specify complex games with the algorithms capable analysis of a Poker game, as in Fig. 2, the system to produce optimal strategies of a general poker game each player gets one card, and In the gambler’s to bet or pass. If the gambler passed and the dealer to bet, the gambler still has his dollar, and therefore gets one more opportunity of solving tool. For example, would generate a game tree, which would then be analyzed for Poker. To illustrate to the case where each player only has one dollar the first round, bet, the dealer must decide whether decides to decide whether or not to bet. At that point, the gambler can either bet his dollar or pass. After hearing to bet. Such a game would consist of three rounds. this process, consider an instantiation the deck consists of 8 cards (6-K), The optimal strategies for the gambler in Fig. 3. They demonstrate are shown simpler game by Kuhn psychological makeup of human players, are actually game-theoretically [ 141): Behaviors such as bluffing, for the Gala system, in a (first observed that seem to arise from the optimal. the game ends. in this game, as obtained an interesting phenomenon These strategies were generated completely automatically from the description of the rules of Poker, described complete end-to-end of a game, and end up with a clear and comprehensible for that game. by the Gala system, starting in Fig. 2. Thus, the system provides functionality, where we start from a simple specification of the rules description of optimal strategies language, which supports a clear and concise specification The remainder of this paper is structured as follows. In Section 2, we review the exten- sets. In Section of of the rules of a game. games, concepts the definition of the Nash equilibrium [ 211. In Section 5 we survey both the solution algorithms based on the normal form of the game, and form algorithms of [ 121. In Section 6, we show how these sive form of a game, where game trees are augmented with information 3, we describe the Gala large and complex games by allowing In Section 4, we review including standard game-theoretic the more recent sequence a formal specification the basic solution in imperfect information D. Keller; A. Pjiefler/Ar@icial Intelligence 94 (1997) 167-215 173 ideas come together different results comparing the sequence Section 7 with some discussion be unfamiliar with game-theoretic tutorial sections concepts to form the Gala system, and present the first experimental in for future work. As some readers may some that review well-known material. Sections 2, 4 and 5.1 present standard form and the normal and directions concepts form algorithms. We conclude the paper contains and techniques, from game theory, while Section 5.2 reviews more recent work. 2. The extensive form In this section we review the extensive form representation of a game. Readers familiar with game theory may wish to skip this section or to skim it rapidly so as to familiarize form is similar to the traditional themselves with the notation used later on. The extensive AI representation some point which changes that have a finite action set and end after a finite number of actions have been Therefore, we consider only finite trees. of a game as a tree. As usual, each node represents a possible state at the initial state. Each edge is an action to situations taken. the state into a new one. In this paper, we restrict attention in time, with the root representing a multi-agent in which case the edges represent it is to choose an action. The set of edges situation, each node is associated with a single agent, leading out of a node are the to that agent. The agent acting at a given node may also be chance or its is When modeling whose turn choices av.ailable nature, moves at the different points rational the agent’s preferences over the different possible outcomes of the situation. Therefore, we associate a vector of payoffs, one for each agent, with each leaf of the tree. random events. An agent’s strategy dictates a strategy which in the game. In order to recommend for an agent, we must model This representation of a multi-agent situation to represent game trees in AI game-playing as a mode.1 for some games, and for almost all games that model real-world To understand why, consider Kuhn deck containing one card. simplified variant of poker, first described by initially has two dollars, and a the three cards J, Q, and K. Each player antes one dollar and is dealt [14-l. The game has two players, each of whom is the very familiar one, standardly used it is inadequate situations. applications. Unfortunately, the following Fig. 4 shows half of the game tree for this game: the part of the tree corresponding (Q, K), and (J, K) . The game consists of three rounds. (shown In the first to the deals (Q, J), in grey) can either bet an additional dollar or pass. After the gambler round, to bet or hearing the gambler’s bet, the dealer (shown to bet, the gambler still has a dollar, pass. If the gambler passed and the dealer decides and therefore gets one more opportunity to decide whether or not to bet. At that point, the game ends. If both bet or both pass, the player with the highest card takes the pot; in the first case, the winning player wins two dollars, and in the second case, he or she takes the pot, wins one. If one player bet and the other passed, thereby winning one dollar. in dashed black) decides whether then the betting player At first glance, Fig. 4 appears to be an adequate, albeit partial, representation of this game. However, this is not the case. Note that, at the two points corresponding 174 D. Keller; A. Pfeffer/Art@cial Intelligence 94 (1997) 167-215 Fig. 4. Naive attempt at a partial game tree for simplified poker, containing three of the six possible deals. Fig. 5. A partial game tree for simplified poker, containing three of the six possible deals. A move to the left corresponds to a pass, a move to the right to a bet. The information sets are drawn as ovals; some of them extend into other parts of the tree. (Q, K), the same information information. (Q, J) and this information the gambler has exactly state is encoded nowhere in this tree,. Therefore, an algorithm that he is capable of executing. Unfortunately, So, this is about the that is not legitimate. theorists have long known to the deals even if the gambler would prefer to bet in the first case and pass in the second, not a strategy gambler’s uses this tree as a model of the game cannot possibly determine strategy Game information a tree, known as the extensive form of the game, also contains information aggregates it is to act. For example, as shown deals gambler. set, represented graphically by an oval containing those states of the game which are indistinguishable the of a game as information sets. Each several nodes of the tree, to the player whose turn the is associated with the of a game must encode representation that the representation the standard (Q, .I) and (Q, K) are in a single in Fig. 5, the two nodes immediately states of the players. Therefore, that this “omniscient” information set, which following D. KolleK A. Pjeffer/Arti$cial Intelligence 94 (1997) 167-215 175 More precisely, the hands dealt let (c, d) denote to the two players. two nodes; each node corresponds Initially, gambler only knows his own card, so for each possible c, he has one information uc containing hand. In her turn, the dealer knows d as well as the gambler’s action Hence, gambler’s previous round. As we can see, Fig. 5 is an accurate game. the set for the dealer’s in the first round. to the set ui in the third of this information action. Finally, the gambler has an information to the two possibilities sets for each d--u: and &corresponding representation still partial) (although sh.e has two of an extensive a formal definition We can now provide [ 151. The game is represented form game, as first de- scribed by Kuhn tree whose nodes denote game states. The internal nodes of the tree are of two types: decision nodes of some player k, for k = 1, . . . , n, and chance moves. The outgoing edges at a decision labels called choices. A node represent possible actions at that node, and have distinct play denotes taken on that path. leaf. A move is a choice as a finite directed the root to some the path from The pyof kth component payoffs may coincide a situation where h* = -h’. function h determines of h(p) /?(p) to the different players in some circumstances, there are only a payoff vector h(p) E R?’ for each leaf p. The the is the payoff at p to player k. The relation between is, in general, arbitrary. Thus, the interests of the players in others. A zero-sum game models i.e., two players, whose interests are strictly opposed, and conflict into sets. Each information information the player cannot differentiate set between that at each node p in u, the for the outgoing edges) at U. For sets u in Fig. 5, the dealer might have the choices ppd and Bz set. This implies (labels that the choice sets C, and C, of any two information The set of decision nodes is partitioned it is assumed to exactly one player k. Intuitively, in the same information u belongs different nodes player must have the same set C, of choices simplicity, and v are disjoint. For example, in vf; and ~2 and Bi in vi, where P indicates with pe$ect the information Throughout a bet. In games information, where the players always know the current state of the game, a pass and B indicates sets of all players are always single nodes. this paper, we restrict attention, as in most of the game-theory literature, a player has perfect to games where all of the players have perfect recall. Informally, recall if he never forgets his previous actions or any fact that he knows. Formally: Definition 1. Player k is said to have pelfect recuEE if for each of his information sets u, and any two nodes p, q E u, the sequence of player k choices on the path to p is precisely the same as the sequence of player k choices on the path to q. Thus, I) and q can only be in the same information set if the entire history of events to u and v is identical uccomling to player k’s point of view. Had there been some the two histories, player k would have had to forget that difference this definition, set. To fully understand leading difference between in order to place p and q in the same information recall our assumption example, PQ, while: the same action when that actions at different labels. For the first-round passing action when the gambler has a Queen would be labelled sets have different information the gambler has a Jack would be labelled PJ. Thus, 176 D. Kollec A. Pfefer/Art@cial Intelligence 94 (1997) 167-215 that pass through different info~ation sets must be different. Hence, two histories definition information never “forget” of perfect recall guarantees sets can never “converge” that two histories into the same information that passed information he once had. the through different set; i.e., the player can 3. The Gala language The extensive form captures the low-level dynamics of the game: the choice points, it captures none of the underlying and the sets of nodes among which a player cannot ~stinguish. the choices available, However, a Poker player are determined by the amount of money he has left. In fact, within extensive points structure, e.g., the fact that the choices of the the player has at various form, we cannot even represent the amount of money in the game. regardless of the hands Since we cannot encode game tree (e.g., by observing identical down explicitly: far from trivial, expect a person less reasonable this information, we cannot utilize it to compactly specify the that the available moves in the betting round of Poker are the players are dealt). The game tree must be written it is possible, although set. While to it is unrealistic tree with 30 nodes, construct a game tree with thousands of nodes. It is even every move and every information to write down a correct game to manually to expect the resulting game tree to be correct. language in natural called Gala The idea of using a declarative of large, complex games. Gala mimics In this section, we present a language, supports clear and concise specifications in which a large game is typically described (for GAme LAnguage), 3 that the way its r&es. language, by presenting to specify games was proposed by Pell [ 241. perfect- He utilizes to information represent and multi- player games; games where the outcomes are arbitrary payoffs; and games with either information. As we will show, the expressive power of Gala allows perfect or imperfect for clear and concise game descriptions, that resemble, at a high-level, a natural language representation it to specify symmetric chess-like games-a board games. Our language is much more general, a very wide class of games, of the rules of the game. class of two-player and can be used in particular: one-player, two-player Gala describes the number of players. a game as a branching program, where each possible execution of to a possible play of the game, as determined by the players’ the program corresponds actions and by the outcomes of the chance moves. The program first specifies an initial It then lists a sequence of game steps, whose state, including execution state to change over the course of the game. A Gala program categories. Declarations program two in the game. In a poker two players named dealer and gambler, consists of a set of declarations. These declarations they might say that the game involves in the first category describe entities the game state and the players’ information fall into causes 3 We use the name “Gala” to refer both to the Gala language and to the Gala system described for solving games specified in Section 6, in this which contains an implementation language. of the Gala language and algorithms D. Kolles A. Pfeffer/Art$cial Intelligence 94 (1997) 167-215 111 a deck of cards, and so on. The other category contains declarations sequence of events ante, deal., bet and nextbet a sequence of Gala statements. Gala provides found the game. In Fig. 2, the declarations all fall into this category. Each such declaration similar flow control statements that take place during in many programming languages. the for flow, contains to those that describe Three important Gala statements building blocks for defining point in the game; choice state of a player. The payoff it indicates are choose, reveal and outcome. These are the basic the course of a game. A choose statement defines a choice the the set of choices available at that point, and whether is made by a player or at random. A reveal statement changes the information statements determine the final outcome of the game. In addition, Gala allows a game state to be explicitly in determining the available choices. For example, specified, maintained the amount of money available and $money(dealer). These are updated by Gala commands to determine the set of possible amounts through in the Poker to the players via the as that a the game, and utilized program of Fig. 2, we maintain variables $money(gambler) the betting progresses, and are accessed player can choose to bet. The game manipulation statements uitous concepts such as combinations with certain affect the structure of the game; they do not induce choice points or specify sets. Rath,er, they provide bookkeeping specification to ubiq- range from simple variable manipulation, for dealing to special-purpose of objects, (e.g., a rectilinear board). These statements do not directly information for the game state, which of the game tree. in turns supports types of objects libraries the It is worth discussing the relationship between Gala and Prolog. Gala for many of its constructs. The Gala is embedded interpreter in Prolog, and uses the Prolog proof generator in Prolog, and uses Prolog syntax written game. In addition, Prolog predicates can be called from within a Gala program, allowing conditions that Prolog predicates in the game is defined by choose statements. Gala consists of two parts: the Gala program by the Gala program. In general, a game in the code describing itself, and auxiliary Prolog predicates used is to discover all possible plays of a on the game state to be expressed as declarative queries. We do require called from within Gala be deterministic, so that all non-determinism We begin by discussing the underlying the various manipulation. together types of Gala statements: Finally, we demonstrate in specifying complete games. semantics of a Gala program. We then discuss and game state flow control, come features of the language basic primitives, how the various 3.1. Gala semantics to a Gala program, As we have discussed, game trees are not sufficiently expressive since for ascribing precise the state of the state of the players. We therefore consider a somewhat more [ 61 for they do not allow us to discuss framework, based on the work of Fagin, Halpem, Moses and Vardi about multi-agent semantics game and the information expressive reasoning systems. We specify the behavior of a Gala program via its execution tree. Each node in the execution tree is a possible state that can occur in the game, with the root corresponding to the initial state of the program, and the children of each node co~esponding the state encoded by that node. states that can follow to those As in [6], a global State describes both states of the different players. (s,,s~,..., internal an (N+l)-tupleoftheform is the local state of player k. The player’s available her local state is the same. the “external” state of the game and the In an N-player game, a global state is therefore SN) where s, is the environment state and Sk local state encodes all of the information to the player, so that the player cannot distinguish between global states where The environment state corresponds to the program state of the Gala program, in the same sense as in any other programing language. It consists of two main parts: serves to be executed. The gameflow A game~ow, which is a Gala code fragment specifying remains of a state, the gameflow the description letters 4 and + to indicate an arbitrary steps. A gamestate, consisting program variables. Gala allows both Prolog-style progressively can be changed at will, as in traditional programming indicate a set of bindings is presented (possibly the course of execution, for all the variables, refined during of a set of current assignments the role of a program counter. the sequence of steps that In in quotes, and we use the sequence of gameflow empty) variables, whose bindings (or bindings) to the are and variables whose values languages. We use V to The local state for each player describes the agent’s mental player’s memories, player. We use Fk to denote represented as an ordered the list of facts known list of facts (Prolog to player k. state. It consists of the to the terms) known The execution tree is a directed tree whose vertices are labeled with global states. The the first command from executing transitions at that state. Some of a state are the possible states resulting successors in the gameflow mechanics of the game (e.g., transferring game). transition successors. The choice point can be due either dice) or to an action of one of the players choices of action will induce different possible plays of the game. to the the ante to the pot in the beginning of a poker In other cases, the in vertices with several (e.g., a roll of the to pass or bet). Different the vertex will have only a single successor. to a choice point In this case, corresponds in the game, resulting to a chance event are deterministic, (e.g., a decision corresponding 3.2. Basic Gala 3.2. I. Choice points has statement The choose the format choose(Player, Template, Constraint), where Template is a Prolog expression containing unbound variables, and Constraint is a Prolog predicate. Any that can be instantiation taken in the current state.4 For example, of Template satisfying Constraint is an action the choose(gambler, InitialBet, between(0, $money(gambler), Bet>) 4 We assume that in a correct Gala program, this set of instnntiations is finite and will be computed in Prolog in a finite amount of time. D. Kollel; A. Ffeffer/Artificiai Intelligence 94 (1997) 167-215 179 in Fig. 2 specifies statement variable Bet which the semantics of Gala variables or nature(@), where satisfying Constraint. 5 the set of possible actions is between 0 and the amount of money in Section 3.3.1.) Player ,u is a probability distribution to be any numerical value for the that the gambler has. (See is either the name of a player, of Template over the instantiations in a state are the answers The power of choose lies in the fact that the available actions to the query depend to a query, and do not have to be encoded explicitly. The answers on the current game state, and vary according the available bets in the statement above depend on the current value of the variable $money(gambler), as described in the gamestate part of the global state. Thus, the same choose statement can be used throughout to context. For example, the betting phase. More formally, let (( “choose(Player ,Template,Constraint), CL”, v), Fl, . . . , Fk, . . . , FN), is made, to her. the statement We cannot transition since, at this point, {The info~ation using the current be prolog constraint Constraint the refinement of the bindings of Prolog variables state, and let Z be the set of inst~t~ations the and are consistent with V. For each I E Z, let V/I denote of Template that satisfy directly from the player might not know in I. this state to the state after the choice in V by the bindings the set of actions available may not be in her locai state.) We therefore implement two transitions. Formally, when the interpretation of Player is some player k E (1,. . . , Iv’}, then a deterministic transition is made to the state: (( “choosing(k, 11, JI”, v), Fl,. . . , (F& 0 choosing(l)), . . . ,3#). choosing is not a statement in the Gala language; it is just a placeholder The statement for the intermediate to distinguish player state. Note that the addition of the fact choosing(X) between This new state has multiple states where she had different choice sets. states, corresponding successor to all possible instantia- to Fk forces the tions f E Z. Each such state has the form (C“,“, V/Z) 5 6,. * A I (Fk 0 choosing(x) 0 chose(l)), . . . ,Fn), where V/1 is the modification of V according of variables below.) Note the requirement enforcing always remembers her own actions. that the fact chose(l) {implied by to the bindings is added in 1. (See the specification local state, to the player’s that a player the perfect recall assumption) For the case of chance events, where Player is nature(p), then we first transition to the state ((“choosing(nature&), z), $“, v),Fl,. , . ,FN). The set of successors for this state are all those of the form ((“s”,V/r),~~T...,3,), such that I E Z. Each of these successor states is reached with probability g(I), 5 w can ba omitted, in which case it defaults to the uniform distribution. 180 D. Keller; A. Pfe$er/Art@cial Intelligence 94 (1997) 167-21.5 The choose statement is the only way to represent choice points is due to a chance move or to a move by one of the players. Thus, in the game, whether it is the to allow multiple successor states in the execution tree. the choice only statement 3.2.2. Znfo~t~on The reveal states statement has the format reveal(Player, and Pact is any Prolog allowing to distinguish not. Fact is interpreted by the Prolog system, using Fact), where Player the fact Fact is added to the player’s is any pIayer local state, runs where Fact was observed from runs where it was the set of bindings term. Intuitively, the player in V. More foxily, let ((“reveal (Player ,Fact), I++“, v) , Fl, . . . , Fk, . . . , FN), be the current state, and let k be the interpretation of Player. Then the next state is: ((“lff2’,v),F~ ,..., &ooFaclw ,... *.?N). where FactV v.6 is the Prolog term resulting from interpreting Fact using the bindings in For example, in the Gala program of Fig. 2, each player’s & starts out as the empty the execution of the s~tements the Prolog list. After value Hand2), each & contains only of Hand; for example, this fact may be myhmd( CJI >. As the betting progresses, each Fk is augmented with facts that denote his own moves and the moves of the opponent. For example, after two rounds of betting, local state may be the list: Cmyhandf C.Jl) , choosing([0,1,21), the gambler’s in games where each player gets one card, fact myhandGIand), for the appropriate Hand11 and revealcdealer, revealcgambler, chose(i), bet (dealer, 011. (see Definition 1) requires Note that the facts known by a player are ordered, so a player can differentiate between in different orders. This is important, because between runs in which by this requirement is local is runs in which the same facts were revealed perfect recall a fact was revealed before or after choosing adding chosen. Since choose and reveal are the only Gala statements state, and they always append maintained. to the facts already known, perfect recall to the player at the time the action to the list of facts known that a player distin~ish that change a player’s an action. We fulfill info~ation chose(dction) 3.2.3. PayoJffs The format of the payoff that the amount haunt statement is added mean actual payoff at the end of the game is the amount she has accumulated game. The cumulative where the game may be very long or infinite. to the player’s the it to be used in contexts In such games, we often want to consider is Payoff (Player, Amount). It is interpreted to Player’s nature of the payoff command to date. Thus, throughout payoff allows 6 Fact may also contain uninstantiated variables, but their names are ignored in this interpretation process. that ignores the names of Given any set of bindings V, a Prolog term Fact has a unique structure Factv variables, and it is this structure that is added to the player’s information state. D. Keller; A. Pfe$er/Artifcial Intelligence 94 (1997) 167-215 181 a prefix o-f the game, and it is useful to date. to be able to have a record of the player’s payoffs To implement the payoff command, we maintain a special set of variables hi, . . . , hN in the global state. Formally, let the current state be ((“payoff (Player Jmount), *I”, V) ,Fl, . . . , &, . . . ,3N). Let k be the interpretation next state is: of player, and p be the interpretation of Amount. Then the ((“‘f’vV[h +hk+p]),3 ,,..., 3k ,..., h). Note that we do not assume that the payoff is revealed to the player. 3.2.4. Basic flow control Gala provides several flow control statements the game. The most basic ones are concatenation, that can be used to guide the progress of and conditional termination Concatenation the concatenation from the semantics is straightforward. of the steps in 4 and $. The semantics If 4 and + are gameflows, for concatenation then (4, $) for other statements, as demonstrated above. statements. is simply is derived the gameflow The game terminates whenever reached. The payoff hk accumulated is assigned in many games a payoff provides am outcome statement takes a vector V as its argument, assigns payoff vk to the kth player, and terminates game. is up to that point is then allocated to player k. Since to all the players when the game terminates, Gala in terms of payoff and end. The statement the in a state is empty, or an end statement that is defined Conditionals have the form if (Condition, cate and Q)I,& are gameflows. in a state, ’ the flow continues with 41, otherwise let the current state be is a Prolog predi- If Condition can be satisfied given the set of bindings V 41, 42) where Condition it continues with 42. More formally, ( (“if(Condition, 41, 42)) @“, v) ,31,. . . ,3~). If Condition can be satisfied given V, then the next state is ((“~i.~",V),~,,...,3N), otherwise, it is As a shorthand one can use if (Condition, is the empty sequence of commands. 4) instead of if (Condition, 4, ~1, where E For example, in our Poker example, beats (Hand1 , Handl) is a Prolog predicate in Fig. 8) used in the argument of an if statement. The outcome of this predicate to the variable betterhand. determines the assignment (defined thereby ’ In a correct Gala program, the evaluation of Condition must always terminate. 182 D. Kollec A. Pfe$er/Artificial Intelligence 94 (I 997) 167-215 3.2.5. Game trees These primitives guage. Any extensive features described appropriate one of the actions duction) at the corresponding into: * are the basic above. A leaf can be translated the Gala tools for specifying game trees within form game can be written as a Gala program utilizing only lan- the statement with an vector of payoffs. For an internal node p, suppose player k has to choose in- rooted rooted at p can be translated that we have already defined gameflows $1,. . . , $1 for the subtrees into an outcome set CL Assume of p. Then the subtree . . , cl, and information children that p is in (by cl,. u), C, member(C, Cct , ., c/l )), revealck, chooseck, if (C=ct , (/II I if (C=cz, ., if (C=c/_t, !+%-I I 1/11)...)). Conversely, the basic primitives influence choose, the construction reveal, and payoff are the only Gala com- of the game tree from a Gala program. that directly mands We return to this point at the end of this section. 3.3. Maintaining game state As we mentioned, the power of the choose player’s set of choices does not have to be explicitly set can depend on the current commands for accessing and manipulating the game state. statement derives from the fact that the listed in the program. Rather, this suite of state of the game. Gala provides an extensive 3.3.1. Variables As in a traditional programming language, described Some of these are standard Prolog variables, which can be accessed statements part of the set of bindings V. They can be changed as a consequences statements described statement). for the Prolog variables (e.g., as a consequence above. The bindings of a particular above the state is maintained via a set of variables. in any of the as of some of the are maintained choice in a choose It is often convenient to model the changing state of traditional programming and changed to the Prolog variables. Gala variables at will. For this reason, in many programming languages: (as for Prolog variables) that game state in the same way as the languages, using variables whose values can to provide Gala variables encoun- they can be assigned values at will, without the old the new value be consistent with to variables are similar it helps changing be assigned in addition tered requiring value. 8 In this program, [. .] is used as a set constructor, and member tests for membership in the resulting set. D. Keller; A. Pfeffer/Art$cial Intelligence 94 (1997) 167-215 183 The two types of variables are normally used in different ways. Prolog variables are statements within a gameflow, while the course of the useful for storing Gala variables can maintain global information game. For example, consider the following code fragment: that is used throughout local information and connecting choose(a, Number, betueencl, 10, Number)), Parity is Number mod 2, reveal(b, Parity), choosecb, Guess, betweencl, 10, Guess)), if(Guess = Number, score gets $score + Number) specifies This fragment that player a chooses any number between 1 and 10 and reveals only its parity to player b. Player b then tries to guess the number, and gets the number’s right. The Prolog variables Number, Parity and value added to each other. Guess are used to connect together and relate the numbers The Gala variable score, in contrast, maintains throughout the course of the game. to his score if he guesses the statements the score that is accumulated Gala variables can be directly referenced within a gameflow by putting a “$” in to is is analogous in Prolog. Gala variables front of them. They can be instantiated within a gameflow using gets, which from Prolog variables using gala_val(GalaVar, PrologVar), and galaset(GalaVar, Value). These statements allow Prolog predicates outside the Gala program the game state. The semantics setting a variable causes a transition to the list, and a reference binding. to access and modify for setting and referencing Gala variables are obvious: is appended in its most recent the gala command to and is replaced by the value to a state in which can be converted the new binding to a variable In Fig. 2, the only Prolog variables are Handi, Hand2, and Bet. They serve precisely above, of making a short-term the role described the choose statement with some additional statement The use of the Gala variable debt allows information revealing connection the outcome of between statements. For example, we use Bet in the to the opponent, and also to update the value of debt. information to be passed between different CdlS to next-bet. 3.3.2. Mol*e complex game states The different types of variables provide the basic facilities for storing, manipulating, for concepts and accessing various aspects of the game state. Using variables, Gala provides a short- hand notation locations that change hands, and their contents, pieces and their movement patterns, and resources statements of the form the user to utilize such as money. For example, Gala allows move(queen(white), (d,l), Cd,811 Or paycgambler, pot, Bet). that occur ubiquitously in games. These include On a more abstract level, we have observed that certain structures and combinations appear in many different games. While these usually they come a straight, on the other hand, a common property; elements successive to one another; bear a relation classes based on rank in which the classes are of a specific size. equivalence involve sets in one way or another, in many flavors. For example, a flush in poker is a set of five cards sharing in which into is a sequence of cards is a partition a full house 184 D. Kollec A. Pfefleer/Artificial Intelligence 94 (1997) 167-215 a few predicates language provides these with various predicates The Prolog have supplemented of the combinations mines whether Set is a sequence of objects in which successive by Predicate, while partition(Relation, Set, Classes) partitions Classes defined by the equivalence in games. For example, relation Relation. that describe sets and subsets. We it easy to describe many chain(Predicate, Set) deter- are related into equivalence elements set that make occurring The following example, using a more elaborate in the same library, function provided test for all types of poker hand except flushes and straights: shows how we can concisely partition_profile(match_rank, Hand, Profile), associate(Profile, HandType, [([4, 11, four-of-a-kind), (C3, 21, full_house), (C3, 1, II, three_of_a_kind), ([2, 2, 11, two_pairs), (C2, 1, 1, II, one-pair), (Cl, 1, 1, 1, 11, nothing)]) relation-in The predicate equivalence The predicate defined by the equivalence non-increasing be [ 3,2]. The profile order. For example, [ 3,2] partitionprofile takes three arguments: a set-in this case Hand; an this case matchrank; and a list of numbers-prologargProfile. is true precisely when the list of numbers is a profile of the partition relation, where a profile is a list of sizes of partition cells in then Profile must if Hand is [90,6), 94,60,60], is then associated with the class full-house. functionality for describing that is common Building on this library of predicates if a game that apply specifically combinations, Gala also provides to a certain class of games. libraries with more specific These include games played on a grid (such as chess or tic-tat-toe) , playing cards, dice, is declared and so on. For example, to include a grid-board object, a range to a rectilinear board become available. One such of predicates in a straight line, all of predicate which satisfy a certain property in tic- In general, high-level predicates tat-toe). It is defined are typically very easy so that level concepts, adding a module in terms of the intermediate little effort. is straight-line, which tests for a sequence of squares (such as an open file in chess or three-in-a-row for a new class of games requires in terms of the chain predicate. to define 3.4. Advanced flow control One of the primary advantages of representing the same code to encode structures to utilize game. For example, as we discussed above, can be used in different the same subtree. a game as a Gala program is the ability the that repeat again and again throughout the set of legal bets the rule for specifying subtrees of the poker game, as well as in different bets within Gala provides a variety of repetition statements, the most basic of which is the while. It has the form while(Condition, +), and is interpreted by translation That is, if the current state is into an if statement. ((“while(Condition, 41, $“,v),~~,...,~~), then the following state would be: (( “if(Condition, (4, while(Condition, do))), ~+%“,v),~~,...,~p~). D. Kolles A. Pfeffer/Artijcial Intelligence 94 (1997) 167-215 185 Gala also provides a repeat statement vides fancier functionality. Its form that is defined is repeat (Flow, Conditionl, in terms of while and pro- , Conditio%). Each Can take One Of tW0 fOrIllS: unless(Predicate) or until(Predicate). in Flow is executed repeatedly until one of the predicates becomes are tested before an iteration, while until conditions The Set true; are tested after Conditioq of statements unless conditions an iteration. Another to a defined procedure. As usual, feature adapted from traditional programming is the de$ned it consists of a head and a the head consists of a name and a list of formal parameters, while the body is a of a is listed as a separate section are in the specification and nextbet jaw, whic.h is analogous body; gameflow. A defined gameflow Gala program. For example, all defined gameflows. in our poker example, deal, bet, languages firstbet game- A call to a defined gameflow is interpreted the values of the actual parameters ters passed by value. If the gameflow gameflow, eters to the defined gameflow defined gameflow conflicts. in the obvious way, with the parame- in a game state begins with a call to a defined for the formal param- for the call the body of a are substituted is substituted in the game state. All Prolog variables within are local, so different calls to the gameflow do not cause binding in the body of the defined gameflow, and this body Finally, Gala provides functionality that allows for players (or a subgroup of players) to be treated uniformly. take the same This allows for games where all the players sequence of actions. One such command is playlound(Flow), executing FLOW once for each player, which takes as value each of the players fOlXl choose($player,Action, example, in the poker program, play_round(ante) Constraint),9 where Flow is a gameflow. to this also defines a special Gala variable “player” a step of the in turn. For twice, with each player will make a choice has the ante flow called if FLOW contains in turn. Thus, In addition $player first instantiated to dealer and then to gambler. In addition to the player variable, game, and lho and rho (for left- and right-hand opponent, multiplayer players the variable opponent is also defined respectively) in a two player in are defined is also a variant of playzound which allows a subset of the in a different order from the default order. to play the round, perhaps games. There Gala also allows a temporally take turns performing takes the form take_turns(Flow, ConditionI, extended version of play-round, a sequence of actions until some condition in which the players is true. The statement the same ., Condition,,), with the player variable and its relatives in the poker program, in turn. This flow, or when someone meets, repeated betting by the players is called within the next-bet is used to describe lo For example, It is essentially ., Condition,,). in the same way as for playzound. construct aS repeat (Flow, ConditionI, being defined the take-turns terminates either when wins0 in which #case $debt=O. 9 The dollar sign indicates lo This is not the same as repeat Condition also checked between that a Gala variable is being referenced; (playzound(Flow) , Condition] see Section 3.3. , . , ConditioQ) is checked only between complete rounds, whereas in the take-turns the turns of the different players. since in this case, is statement, Condition 186 D. Keller, A. F’feffer/Artijcial Intelligence 94 (1997) 167-215 game(inspection, C players : [inspector, violator], params : [stages, inspections]. variables : [stages-remaining = $stages, inspections-remaining = $inspections, violate, inspect]. flow : (repeat(stage, unless(no_more_inspections), unless(no_more_stage.s), until(violation)), determine_outcome), stage : (choose(violator, X, (X = yes ; X = no)), choose(inspector, Y, (Y = yes ; Y = no)), reveal(violator, Y), violate gets X. inspect gets Y, if($inspect = yes, inspections-remaining gets $inspections_remaining - I), stages-remaining gets $stages_remaining - I), determine-outcome : if(no_more_inspections, outcome(C-I, II), if(no_more_stages, outcome(C1, -ll), if($inspect = yes, outcome(iL1, -111, outcome(C-1, 11)))) I). no_more_inspections :- gala_val(inspections_remaining, 0). no_more_stages :- gala_val(stages_remaining, 9, gala_val(inspections_remaining, RI, s =< Ft. violation :- gala_val(violate, yes). Fig. 6. A Gala description of inspection games. 3.5. Two complete Gala programs In this section, we describe how the various bined to form a Gala program. As an example, Fig. 6 shows a complete features of the Gala language are com- listing of a 0. Kolter; A. ~~~~r/~rti~~i~l ~ntel~i~en~e p4 (1997) 167-215 187 simple inspection game, which has received significant attention in the game theory community as a model of on-site inspections for arms control treaties [ 21. The inspection game involves two players: a violator, who wants to commit some treaty-violating act (such as nuclear testing), and an inspector who wants to prevent the act. The game takes place over n stages. In each period, the violator chooses whether olr not to violate, and the inspector chooses whether or not to inspect. By the terms of the treaty, the inspector may only inspect 1 times over the n stages, where 1 < n. If at any stage the violator violates without being caught, the violator wins. If the violator is caught, or if he does not attempt a violation throughout the game, the inspector .wins. If at any point the number of remaining inspections is 0, we assume that the violator will successfully violate at the next stage. If the number of inspections rem~ning equals the number of stages rem~ning, we assume the inspector will inspect in every subsequent stage, thereby ensuring victory. The game terminates as soon as either of these assumptions becomes valid, because the winner is then known. A Gala program consists of a statement game(GameName, DeclarationList), together with a set of auxiliary Prolog predicates. Each declaration in DeclarationList has the form N~IW: Definitioa Some declarations define gameflows, while others specify other aspects of the game. The players declaration lists the players in the game, in the order used by default for constructs such as playround and take-turns. The variables declaration declares Gala variables used in the program. The parader declaration illustrates a powerful feature of Gala. A Gala program can be parameter&d, so that it defines a family of games. The program shown defines the inspection game for any number of stages and inspections. In this program, the parameter values are used only to declare the initial values of Gala variables. In general, the parameters can also appear directly inside a gameflow, but they are not part of the game state, and cannot be modified during a game. The flow declaration defines the gameflow for the entire game; it must appear in every game description. (It is analogous to the main function in a C program.) Two other gameflows are also defined in this program: stage and determineautcome. The content of every garnetlow is a sequence of statements, as defined in the previous sections. E:n this case, the primary construct in the main flow is the repeat statement: stage is repeated until one of the termination conditions is met. When that happens, the outcome of the game is determined. The te~ination conditions are defined in auxiliary Prolog predicates. Each stage consists of a choice by both players. The violator chooses whether or not to violate, while the inspector chooses whether or not to inspect. After they make their choices, the inspector’s decision is revealed to the violator, but the violator’s decision is not revealed to the inspector. The remainder of the stage consists of bookkeeping, updating ,the values of the Gala variables violate, and stagesxemaining. inspectionszemaining inspect, As a final example, Figs. 7 and 8 show the complete code for the poker game from Fig. 2. Approximately half the code is the Gala program, while the rest is Prolog code for evaluating and comparing hands. Most of the code should be easy to understand based on the discussion above. The only new feature is the objects de&ration, which declares that the game includes a deck of cards, and a money account for the two players 188 D. Kolle,: A. Pfeffer/Artificial Intelligence 94 (1997) 167-215 game(poker, [ players : [dealer, gambler], parems : [suits, ranks, cards, cash, ante = 11, objects : [deck : $suits * $ranks, money : [dealer, gambler, pot1 1, variables : [winner, debt], flow : (play_round(ante), deal, bet), ante: (money($player) gets $cash, pay (Sent e I Splayer , pot 1) , deal : (choose(nature, (Hsndl, Hend2) , (dealcdeck, dealcdeck, $cs.rds, Handl), $cerds, Hand2))), %% a pair of random hands is chosen and dealt myhand(Handl)), revealcgambler, reveal (dealer, myhand(Hend2) ) , %% each player’s if (beats(Hend1, betterhand betterhand Hend2) , gets gambler, gets dealer)), hand is revealed only to him from the deck %% evaluate XX it cznce per deal, the hands immediately, so that ue only do rather than at every possible showdown bet : InitialBet, betveen(0, $money(gambler), InitialBet)), chooses his bet betcgsmbler, InitialBet)), to the other player (choose(gsmbler, %% the player revae.l(dealer, %% reveals debt pay(InitialBet, %% end pays take-turns it := InitialBet, gambler, pot), into the pot it (next-bet) 1, next-bet: (choose($player, Bet, ( % meet or raise between($debt, ; % fold $money($player), Bet) if(($debt>O, wins ($opponent (pay(Bet Bet = O), ) , , Splayer, if ($debt=O, ($debt>O, Bet = O))), pot), % fold 7. meet or raise vins($betterhand), (reveal ($opponent , bet @player, debt gets Bet - Sdebt))))), 1 showdown Bet)) , wins(player) : is $money($player) (Winnings Losings is if ($player = dealer, - Winnings outcome( [Winnings, Losingsl) outcome(CLosing.5, Winnings])) , I). + $money(pot) - $cash, Fig. 7. Gala description of poker: Gala program. D. Kollec A. Pfeffer/Ar@cial Intelligence 94 (1997) 167-215 189 beats(Hand1, Hand2) :- predsort(compare_renks, Handl, SortedHandi), predsort(compare_ranks, Hsnd2, SortedHand21, evaluate(SortedHand1, Typel, Detailsi), evaluate(SortedHand2, Type2, Details2), (Type1 = Type2 -> ; Details1 (o> Details2 precedes(Type1, TypeP, Cstraight_flush, four-of-a-kind, full-house, flush, straight, three-of-a-kind, two-pairs, one-pair, nothing])). evaluateWand, Type, Details) :- (is_flush(Hand) -> (is_straight(Hend) -> (Type = straight-flush, Hand = CC_, Rank) I _I, Details = [Rank]) ; (Type = flush, maplist(rank, Hand, Details))) ; (is_straight(Hend) -> (Type = straight, Hand = CC_, Rank) 1 _I, Details = CRankI) ; (partition_profile(match_rank, Hand, profile), associate(Profile, Type, [([a I _I, four_of_a_kid, ([3, X I _I : X>l, full-house), CC3 I _I, three-of-a-kind), (C2. 2 I _I. two-pairs), cc2 I _I, one-pair), (_, nothing)])))). is_flush(Hand) :- checklist(match_suit(_), Hand). is_straigbt(C_l). is_straight(C(_, Ranki), (_, Rank2) I Tail]) :- Rank2 is Rank1 - 1, is_straight(C(_, Rank21 1 Tail]). compare_r,ulks((_, Ranki), (_, Rank211 :- Rank2 =< Rankl. match_rank((_, Rank), Rank). match_suit(Suit, (Suit, _)). Fig. 8. Gala description of poker: Prolog predicates. 190 D. Kolle,: A. Pfeffer/Arti$cial Intelligence 94 (1997) 167-215 and the pot. This declaration these types of objects. For example, the deck and added to a player’s hand, allows the program to use Gala functio~~ity the deal statement causes cards to be removed created for from This Gala program takes five parameters: the amount of cash initially given the suits and ranks of cards in the deck, the to each player, number of cards dealt to each player, and the amount of the ante. Not only does the program describe many different poker games through to describe other variants of poker, in which cards are dealt one at a time, exchanged with the deck, individually in which each player exchanges revealed, and so on. For example, describing cards can be done by adding a gameflow describing the exchange process, and replacing the bet step in flow with (take_turnsfexchangel , bet). it can easily be modified the use of parameters, a game 3.6. Gala programs and game trees form game as a Gala program. games, we to Gala-specified into a game tree. More precisely, given to to the program parameters, we need Above, we showed how we can specify any extensive in order for converting To accomplish However, need a process a Gala program and an assignment generate a game tree co~esponding to apply standard solution algorithms a Gala program of values to the game. this task, we need to understand tree and a game tree. In some sense, an execution in a game tree, each vertex in the execution However, point In contrast, an execution manipulations complex statement t~sfo~atio~s Thus, we eliminate has: in the game, one where different outcomes of the gamestate, e.g., changing the game tree is essentially all vertices the game the relationship between an execution tree is an annotated game tree: just like to a state in the game. I1 tree corresponds tree contains nodes only for those states which represent a choice in the game. lead to different plays tree also contains vertices which correspond the values of variables, to deterministic transforming a into simpler ones, etc. The states corresponding to these deterministic a condensed version of the execution that have only one successor. More precisely, tree, where tree the game would not be associated with nodes in the game tree. in the gameflow l An internal node for every vertex in the execution choosingf.. -3. * A leaf node for every Ieaf vertex in the execution a An edge from one node to another, whenever is the placeholder tree where the first command tree. there is a path consisting of deter- the corresponding ministic edges between The info~atio~ associated vertices to some local state Sk, and consists of all choice nodes for player k that correspond execution-tree is determined only by the local state of the player whose turn it is to move. vertices where player k’s local state is s&. Note that the information tree can be derived tree. An information from set for player k corresponds tree. the local states of the sets for the game in the execution in the execution vertices to set I1 To help disambiguate, we use “state” or “vertex” for nodes in the execution tree, and “node” for nodes in the game tree. D. Kollel; A. Pfe$er/Artificial Melligence 94 (1997) 167-215 191 4. Strategies and equilibrium While defining a game and examining our goal is really to find good strategies the game-theoretic strategy. We describe these concepts the possible scenarios for playing is an interesting exercise, the game. In this section, we survey definitions of a strategy, a minimax strategy, and a Nash equilibrium in the framework of extensive form games. The simplest of all strategies is a pure (deterministic) is a very explicit “how-to-play manual” strategy. Like a conditional plan in AI, a pure strategy that tells the player what to do at every possible point in the game. In the poker example of Fig. 5, such a manual for the gambler would contain an entry: “If I hold a King, and I passed in the first round, then bet 1.” In general, a pure strategy 7# for player k specifies and the dealer bets, a choice at each of his or her information the player cannot distinguish set, the strategy cannot dictate different actions between nodes at those nodes.) in the same information sets. (Since Fixing a strategy of the game, since behavior at these nodes, while random, a tuple of strategies game. Therefore, for player k, determines a probability denote for each of the players does not completely determine the game also contains moves is completely ‘TT = (~1,. distribution the outcome nature. However, the in the description of the . . , TN), where each Vk is a strategy over the leaves of the tree. We will some node p in the tree by PI-,(P). representing specified the probability of reaching Definition 2. The expected payoff H( m) is defined to be H(n) = c fwP)h(P). leaves p to a game is a recommendation to the various players of how to play Based on these definitions, we can now describe what we mean by “solving” a game. A solution the game, i.e., a tuple of strategies w = (9i-1, . . . , TN). Of course, not every tuple of strategies one dictates behavior which would wish that each player’s strategy be optimal with respect to the current context. from his strategy, provided That is, a player should not be able to do better by diverging the strategies of all other players this the strategies are said to be in equilibrium. More formally, we for all players, property have the following definition: for the different players. At the very minimum, If a tuple of strategies satisfies remains constant. is rational Definition every player k and every strategy dk for that player, .3. A strategy combination (~1, . . . , TN) is said to be in equilibrium if for Hk(7T1,. . . ,‘Tk,. . . ,7TN) > Hk(%-,, . . . /IT;, . . . ,‘TN). The equilibrium property is a highly desirable one. Without solution” may leave himself vulnerable following “recommended (since the recommendation advantage of. In that case, following making the whole idea of solution is the rational the recommended somewhat dubious. it, a player following the to having his strategy predicted taken to do) and possibly rational, is no longer solution thing 192 D. Keller, A. Pfee$er/Art$cial Intelligence 94 (1997) 167-215 The ability is particularly to keep one’s strategy a secret. For one thing, code. For another, to subject simply by playing to announce one’s strategy without giving the advantage in the context of an artificial agent. There, important it is always possible the agent’s program it is often possible the game over and over again. to the other player it is very difficult to break the testing to intensive into In perfect games, we can easily construct an equilibrium information game via a process called backward all players are known. At a state which whose turn it is will choose the action that maximizes his or her own payoffs. Under assumption game tree can now determine process reduces the case of zero-sum games. to the induction: At the leaves of the tree, the payoffs for the player the in the the player the optimal action for him or her. This backward due to Zermelo that this player will act rationally, to the standard minimax algorithm in the preceding node the end of the game, induction [ 341) is just before (originally solution in Unfortunately, in most real-life games, the players do not have perfect nodes. And a strategy which is clear that this simple process cannot work for imperfect decision as to the optimal move must be done for the entire information for individual set may not be optimal nodes in the information Queen and the gambler bet. In one of these two nodes, the other, a King. Clearly, different moves are optimal in others. For example, set corresponding information is optimal in our simple poker game, there are two to the situation where the dealer’s hand is a the gambler has a Jack, and in in one node in the information in these two nodes. in the far more complex case of imperfect is that we don’t. In fact, as defined, an equilibrium might not even There, any pure to the other player. That is, we cannot the simple game of “scissors-paper-stone”. information games? The answer exist. To see this, consider strategy achieve equilibrium with any pure strategy. is a losing one as soon as it is revealed How do we find an equilibrium The problem is not with the notion of equilibrium, can find a strategy calculated Pure strategies are predictable, opponent making the information be guaranteed by using randomized gap inherent the original strategy suboptimal. Unpredictable information in imperfect strategies: and predictable play gives the opponent to take advantage of this information, but with the use of pure strategies. information. The thereby play, on the other hand, maintains can only games. Unpredictability Definition 4. A randomized game is a function probability strategy pk for player k (called a behavior that, for each over the choices C, at u. strategy set u of player k, returns information distribution theory) in a In our poker example, a randomized strategy for the gambler can be described by It information. games. Here, the set, rather than defining the probability of betting at each information Once we fix a tuple of randomized strategies ,u = (,ut , . . . , pN), is specified at all points random) /.L determines Definition to a tuple of randomized Definition 3 can be used, again substituting a probability 2 can be used (only strategies. Similarly, substituting distribution /_L for n-) ,u for rr. in the game. Therefore, Pr, over the nodes set uc and u:, c = 1,2,3. (albeit the behavior just as for pure strategies, tree. Thus, to ascribe an expected payoff in in the game presented the notion of equilibrium D. Keller; A. Pfe$er/Art@cial Intelligence 94 (1997) 167-215 193 The use of randomized strategies allows us to find an adequate solution of scissors-paper-stone. probability player strategy so long as the other player sticks to the equilibrium. for the game The strategy combination where each of the players assigns Each an expected payoff of 0, and can do no better with any other to each of the three possible choices l/3 is guaranteed is clearly an equilibrium: However, it is far from clear that an equilibrium involving many moves. In his Nobel-prize winning use of randomized imperfect strategies allows us to guarantee information games. ‘* necessarily exists in complex games theorem, Nash [ 211 showed that the for the existence of an equilibrium Theorem 5 (Nash, 1951). Any extensive-form game with pe$ect recall has an equilib- rium solution in randomized strategies. Just as in the case of perfect compelling when information games, strategies are par- is zero-sum. Then, as shown by von Neumann the equilibrium the game strategy pairs are those where each player plays the optimal defensive the best worst-case payoff. This maximin behavior it is, in fact, in the other player’s best interests the is optimal against a rational player. More precisely, the strategy: is reasonable for to be as harmful ticularly [ 321, any equilibrium equilibrium one that provides zero-sum g,ames since as possible. More formally: Theorem 6 (von Neumann, is in equilibrium mm,, min,‘, HZ ( PI, ~2 1, I3 where the maximization and minimization space of randomized strategies. In a zero-sum game, a strategy pair &, & ,LL~ maximizes is over the iff ,uT maximizes maxP, minPcLz HI (~1, ~2) and 1947). Thus, in zero-sum games, the best defensive strategies are optimal that can be achieved against a rational player, a player can publicly strategy. Furthermore, in a very strong i.e., a player announce her sense: They are the best that also plays intention the defensive to do so without adversely affecting her payoffs. 5. Solving games Now that we have a clearly defined notion of a solution, how do we go about finding In the poker example of Fig. 5, we is, in general, a very difficult problem. one? This would specify a strategy for each of the players using six numbers: information at the various a game, we need to find an appropriate sets (six information set of numbers that satisfies sets per player). When the move probabilities trying to solve the properties we applies ‘* Nash’s result actually in the next section. The application based on a theorem by Kuhn representations l3 Since H2 = -HI, are essentially this is equivalent equivalent. to mixed strategies and normal form games, both of which are described of Nash’s [ 151 asserting theorem that, for extensive games of perfect to extensive form games and behavior is strategies the two strategy recall, to minimizing min,, maxP, HI (~1, ~2). 194 D. Keller; A. Pfeffer/Artijcial Intelligence 94 (1997) 167-215 want. That is, we want to treat the parameters of the strategy as variables, and solve for them. In the zero-sum case, for example, the general computational problem is: Find x which achieves: max, minyHl(x,y) subject to x represents a strategy for player 1 (*) y represents a strategy for player 2 Given our definition of randomized strategies, the appropriate to be obvious: We simply use the different move probabilities example, we would have x = {xc, XL 1 c = 1,2,3} and y = {ydp, y$ 1 d = 1,2,3} representing the dealer’s strategy. representing Unfortunately, the space of legal assignments to these variables set of variables seems in the game. In the poker strategy, the gambler’s which to search. It is continuous H, which plays an important of maximin strategy, and high-dimensional. Furthermore, role in both the definition of equilibrium is not a “nice” linear function of the x’s and y’s. is a difficult one over the payoff function and the definition We now survey the two main frameworks the traditional normal for solving games form algorithms, in extensive form. In and in Section 5.2 we Section 5.1 we survey review the more recent approach of [ 121. 5’. 1. Normal form that will enable a mathematical The representation components the dynamics different senting the goal of game games, of the extensive resentation, called mal form also allows tion. the normal inducing in extensive of a game (nodes, of the game and of the players’ information edges, form is rather complex, sets, chance moves, information requiring many . . .) for repre- state. By contrast, for representing framework analysis of their properties. The complexity theory is to provide a simple uniform form was viewed as detracting theorists game to develop an alternative from its suitability form (also known as the straregic form). for clean and elegant solution algorithms, formulation as a primary rep- of a game, It turns out that the nor- to its attrac- adding The normal form abstracts away much of the structure of the game. It represents the the nor- game only via the list of pure strategies available mal form is a table, indexed by a tuple of pure strategies 7c = (~1, . . . , TN), one for every player. For each such tuple, it lists the tuple of payoffs H(m) = (HI(~), . . . , HN( m)). to the players. More precisely, Clearly, every extensive-form list all of the possible pure-strategy tuple H(m). While game tree, (Definition this game can be converted combinations 7r, and compute into the normal form. We simply the (expected) payoff in the encoded analysis for equilibrium tranformation loses most of the information it does capture the basic components 3): the possible courses of actions and their outcomes. necessary In the case of general two-player games, also called bimatrix games, the normal form can be written as a pair of m x n matrices A and B. A row represents a pure strategy ~1 of player 1, a column chosen pure strategy 7rz of player 2, and the corresponding in A and B are HI (~1, n-2) and Hz( rt,7r2), represents entries a simultaneously respectively. D. Keller; A. Pfeffer/Arti$cial Intelligence 94 (1997) 167-215 195 In zero-sum games, B = -A, by A. so the normal form of the game is completely specified form shows part of the normal for leach possible card, and whether is a 27 x 64 matrix. The 27 rows correspond Fig. 9, for example, Fig. 5. The entire normal strategies of the gambler. Each strategy round if he passe.s in the first round. Thus, the figure) represents Queen, and passing on a Ring bets. form of the simplified poker game of to the indicates what the gambler should do in the first should bet in the third round in the strategy of passing on a Jack in both rounds, betting on a if the dealer to bluff) and then betting the triple pp, b, pb (in an attempt for example, (in boldface the gambler to a dealer’s strategy, Each co.lumn corresponds the action the triple pp, bp, bb (also in boldface) the strategy where the dealer passes on a Jack and bets on a Ring no matter if the gambler passed. The matrix uf; and us; for each possible card d. For example, represents what the gambler does, but bets on a Queen only only shows 16 of the 64 possible strategies. to be taken at indicating The matrix entry for each strategy pair represents the average of the six possible outcomes of the game arising the expected payoff for this pair. In from this case, it is simply the six possible deals. For example, on a (Q, J) deal, the gambler would bet, and then to a payoff of 1. On a (K, Q) deal, the gambler would the dealer would pass, leading pass, and then the dealer would bet, giving to bet after all, with an ensuing payoff of 2. the opportunity the gambler As we mentioned above, solution algorithms. Recall form was the complexity of representing of a player’s pure strategies, a randomized distribution theory games of perfect recall, equivalent literature. Clearly, any randomized to a randomized over this set. Such a distribution representation the simpler of a game also allows for simple that the main difficulty with solving games in the extensive strategy. However, once we list all a randomized strategy can be viewed simply as a probability is known as a mixed strategy in the game For is such a distribution. strategy generates (mixed strategy) it is also the case that any such distribution strategy [ 151. of strategies allows us to construct This representation of the problem of finding equilibrium in the case of two-player games, so we will focus on those for the remainder of the section. However, much of the analysis holds unchanged strategies. The advantages are most tangible in the general case. formulation a simple the probabilities . . . , ?r;‘. We can represent ,ui for player 1, i.e., some distribution over player Suppose player 1 has m pure strategies and player 2 has it pure strategies. Consider l’s pure strate- some mixed strategy as a vector X, with m components gies v;, assigned by ~1 to the pure strategies di of player representing 1. In fact, any nonnegative m-vector x = (xi, . . . ,x,,) with Cz, xi = 1 describes a mixed strategy. Similarly, by an n-vector y. It is easy to see that the expected payoff HI (~1, ,u2) is equal to the matrix product x”Ay, and similarly H2( ~1, ~2) = xTBy. The vectors x,y provide us with an alternative a mixed strategy ~2 for player 2 can be represented this distribution ,UI (+i) solve. They allow us to reduce player games the zero-sum case, the problem to a simple problem of optimization set of variables the problem of finding equilibrium for which we can in two- strategies over a linear space of vectors. For (*) described above can be written as: 196 D. Keller; A. Pfe$er/ArtQicial Intelligence 94 (1997) 167-215 PI’ PI’ PP PP PP PP PI’ PP PP PP PP PP PP PP PP PP pb PP bp pp pb bb pp pb pb pb bp pb bb bp pp bp bp bp pb bp bb bb PP Pi’ bb pb PI’ bb bp PP bb bb Fig. 9. Part of the normal form for three-card poker. D. Keller; A. Pfefler/Artifcial Intelligence 94 (1997) 167-215 197 Find x which achieves: maxx min, subject to xTAy m c i=l n c j=l x,y Xi = 1 Yj = 1 > 0. This problem can be reformulated, [ 51, as a simple linear programming problem, resulting by an appropriate use of linear progrmnming duality [ 321: in the following theorem Theorem 7 (von Neumann, linear program game. The normul form of a zero-sum game defines a (LP) whose solutions are the equilibria (maximin strategies) of the 1947). The standard Simplex algorithm can be used to solve this LP very effectively. Other standard LP solution algorithms, while slower in practice, can be used to guarantee for linear programming a worst-case polynomial transformation time for the solution. allows the reformulation of the equilibrium two-player games as a linear complementarity problem (see [ 41 A different, but related, for general problem for a definition) : Theorem 8. The normal form of a general two-player game defines a linear comple- mentarity problem (LCP) whose solutions are the equilibria of the game. One of the solutions to this LCP (each of which corresponds [ 171. This algorithm can be found by the Len&e-Howson the simplex algorithm both in its general operation and in the fact that, while requiring exponential time required, a general exhaustive enumeration of course, requires exponential is scheme can be used (as in [4, p. 171). This, to an equilibrium) resembles it is fast in practice. in the worst case, If a comprehensive list of equilibria algorithm time. At this point, one might solved, at least in the two-player polynomial-time librium to be solvable have an algorithm which is effective Howevcer, a closer examination is not known algorithm. that think the problem of solving games is essentially case. In the zero-sum case, we have a fairly efficient l4 In the general case, the problem of finding a single equi- time. We do, however, in worst-case polynomial in practice. shows that Theorems 7 and 8 are highly misleading. useful, Although person’s the situation using some alternative the normal form is not a representation which naturally captures a analyst would model formalism, probably a game tree, and then convert intuitive model of a game. In practice, a game-theoretic I4 In fact, we really cannot expect to Theorem 7 also holds, form game. normal to do better for a normal form game. It is easy to show that the converse i.e., the problem of solving a linear program can be reduced to that of solving a 198 D. Keller; A. Pfeffer/Art@cial Intelligence 94 (1997) 167-21.5 Fig. 10. A simple game where player 1 has 1 information sets and 2’ pure strategies the solution. In both theorems, form. And, unfortunately, form for the purposes of finding linear program or linear complementarity the size of the problem-is form of an extensive to the normal to be solved-the the problem size of the resulting normal form game can be very large. this, consider the simple game tree in Fig. 10. In this game, player 1 To understand sets, one for each possible move of player 2 at the initial state. At each has I information of these information sets, the player has to pick one of the two possible moves. Thus, a pure strategy can be described as an I-length vector of R’s and L’s. The total number form of this game contains a row of possible pure strategies form the size of the normal for each and every one of these pure strategies. Therefore, corresponding in the size of the game tree! is therefore 2’. The normal to this game is exponential the normal More generally, our strategy space is the set of functions from information the process of solving moves, and is therefore also exponential the worst-case, 8 incurs an exponential is much worse). Clearly, case. this problem in the number of information the game via the algorithms blowup, not only in time, but also in space (which, renders these algorithms impractical sets to sets. I5 Thus, in in Theorems 7 and in practice, in the worst think One might in practice, but only like the one above. So, while the worst case is bad, perhaps that this blowup does not arise to a deck with k cards. For each card c, player 1 must decide whether in artificial games the typical case is quite reasonable. Unfortunately, this is not the case. Consider our simple poker example, generalized to pass or bet, and if he has the option, whether to pass or bet in the third round. There are is 3k. Player three courses of action for each c, so the total number of possible strategies 2, on the other hand, must decide on her action for each card d and each of the two actions possible in the first round. The number of different decisions is therefore normal of the other, it is also exponential form has a row for each strategy of one player and a column 2k, so the total number of deterministic is 22k = 4k. Since for the first player for each-strategy strategies in k, while the size of the game tree is only 9k + 1. to have been a real-life games, and appears In fact, this blowup occurs in many the significant obstacle to the widespread use of game theory as an analysis technique: I5 This analysis uses the standard conversion of an extensive conversions form, it is still exponential in the size of the game tree. See 1331 for details. into a reduced normal form also exist. While the reduced normal form is smaller form game into the normal form. Alternative than the normal D. Kollec A. F’jeffer/Artificial Intelligence 94 (1997) 167-215 199 This astronomical occurs in some abandon the game theoretic approach. increase important in the number of variables real-world problems to be determined actually and often forces the analyst to An Overview of the Mathematical Theory of Games William F. Lucas, Cornell University Management Science [ 181 5.2. Sequence form imperfect The exponential an unrealistic option algorithms solving [ 121. This approach uses an alternative avoids the exponential main for many games. Recently, however, a new approach blowup associated with the normal form makes the standard solution to information games was developed by Koller, Megiddo, and von Stengel the sequence form, which the blowup associated with the normal form. I6 We will describe ideas briefly here; for more details see [ 12,13,33]. representation called The sequence form is based on a different than representing probabilities Rather or probabilities of full pure strategies the reakution weight of different sequences of moves. representation of individual moves (as in the normal (as in the extensive of the strategic variables. form), represent the variables form), Essent:ially, a sequence for a player corresponds to a path down the tree, but it isolates ignoring chance moves and the decisions in addition to the empty sequence that player’s direct control, In our poker game of Fig. 5, for example, the moves under of the other players. sequence.s: game) he has four sequences third round), last rounfd]. The dealer also has 13 sequences: d, the four sequences [bet on d after seeing a bet], the gambler has 13 to the root of the (in which case there is no [pass on c] , [pass on c, bet in the last round], and [pass on c, pass in the the empty sequence, and for each card [pass on d after seeing a pass], [bet on d after seeing a pass], [pass on d after seeing a bet]. for each card c: [bet on c] (which corresponds More precisely, let k be a player, and let p be a node of the game tree. There unique path from the root to p. On this path, certain edges correspond k. The string of labels of these edges of choices of player k leading is the root. Essentially, make so that p can be reached p if it chooses relevant. is a to moves of player the sequence if p that player k has to in the game. That is, a pure strategy n-k can only reach is to p. It may be the empty sequence 8, for example to make every move in gk(p) is denoted by d(p) the sequence d(p) set when the move at the information and is called the choices describes Our goal is to describe a randomized (Just as, for mixed strategies, we described a randomized sequences. of weights associated with pure strategies.) We therefore consider for a given strategy via some set of weights associated with strategy via a set that, in play. Clearly, a strategy pk, a certain sequence the probability randomized is realized I6 In 1996. it was discovered manovsky’s community Megiddo, and von Stengel. form was first suggested by Romanovsky paper was published only in Russian and so his result was completely unknown in the West. This led to the later but independent development of the sequence that the sequence [26]. But Ro- to the scientific form by Koller, 200 D. Keller; A. Pfe$er/Art.$icial Intelligence 94 (1997) 167-215 player cannot unilaterally sequence to bet in her turn. However, realized given that the appropriate decision points [pass on c, bet in the last round] the player’s strategy does determine whether a sequence in the game are reached. the if the dealer decides is determine whether a sequence is realized. For example, can only be realized Thus, for a given sequence uk (some sequence randomized strategy pk, we define the realization weight of a for player k) as a conditional probability: Definition 9. The realization weight of a sequence gk under pk, denoted to be the probability defined in @k, given that the corresponding realization weights pk (a:), player k, is called a realization plan for player k. is to ,%k, will take the moves in the game. The set of is the set of sequences of . . . , pk (a? ) , where (+i, . . . , up that player k, playing according sets are reached information ,&((Tk), It is fairly easy to see that the realization weight pk( (+k) is simply the product of the probabilities, according to ,&, of the moves listed in (Tk. strategies We can find equilibrium for player k by searching over the space of possible realization plans. More precisely, as described at the beginning of this section, we treat . . , ~7, and search over the space the realization weights of player k as variables xi,. of possible assignments (e.g., minimax). Note that there is at most one sequence, for each node required for one that satisfies our optimality conditions and therefore one variable, number of variables to represent a strategy this to the exponential to these variables tree. Compare in the normal in the game form. Several crucial properties are required order to substitute a search over realization plans for a search over randomized we must provide a correspondence numbers (of the right length) some randomized represents in order to make this process feasible. First, in strategies, the two spaces. Clearly, not every vector of strategy. between actually [ 111) . Zf player k has perfect recall, then there exists Lemma 10 (Koller and Megiddo a matrix E and a vector e such that a non-negative vector x of dimension mk represents the matrix E strategy for player k tf and only if Ex = e. Furthermore, a randomized and vector e can be derived from the game tree in linear time. That is, for a vector straints. These constraints simple: They force the weights the sequences denoted denoted [Pi, P:] [ pc ] . and to represent a randomized strategy, (as encoded in the matrix E and to “add up” the right way. For example, it must satisfy certain con- the vector e) are quite the weight of [pass on c, bet in the last round] and [pass on c, pass in the last round], [ ~c, B:] , must add up to the weight of the sequence [pass on c] , More generally, let (+k be the sequence for player k leading to an information set at which player k is to move, I7 and let cl, . . . , cl be the possible moves at that information set. The sequence uk is realized these are mutually xgkoc,, where Uk o c is the sequence obtained is realized, and exclusive events. Therefore, we must have that x,~ = xUI-toc, + . . . + the move c to the if and only if one of its continuations from concatenating I7 The perfect recall assumption implies that there is at most one sequence cq leading to this information set. D. Keller; A. Pfeffer/Artificial Intelligence 94 (1997) 167-215 201 / 1 0 0 0 0 0 0 0 0 0 0 0 0 -1 1001 0 0 0 0 0 0 0 0 0 -1 (a) Gambler: -1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 -1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 -1 1 1 0 0 0 0 0 -1 0 0 0 \ O 0 0 0 /1000000000000 (b) Dealer: -1 -1 -1 -1 -1 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 Y= \-1000000000011 Fig. 11. Constraints on realization plans for 3-card poker. x= 0 0 0 0 0 0 I 1 \O 1. 0 0 0 0 0 /l (+k. The only other constraints sequence sequence is 1 (because that x, > 0 for all (T. Thus, a realization plan the root of the game is realized are that the realization weight of the empty in any play of the game), and constraints sequences of [P,, B:] values of c) are encoded for the dealer [P,, P:] and in Fig. 11 (a). The constraints are ordered as in Fig. 12. Thus, for the gambler is a 13-element are written under the constraints the the that the weights sum up to the weight of [P,] (for each of the three different in lines 3, 5, and 7 of the matrix. Similarly, a realization plan the constraints vector x satisfying the assumption in Fig. 11 (b) . asserting that is a 13-element vector y satisfying The sequence form transformation allows us to accomplish randomized strategies, by searching over the space of vectors satisfying once an appropriate vector is found, we can easily recover the space of randomized constraints. Furthermore, corresponding of Lemma the realization weights. Let c be a possible move at some node p in the game where player k is to move, and let Uk be the sequence of player-k moves Then the condition strategy pk from tree to p. strategy. That is, if a realization plan satisfies 10, then we can recover the corresponding randomized leading the task of searching over the the if xCk > 0. Otherwise, we can define Pr,,(c) strategy that the resulting ,Uk induces The analysis above shows that we can represent a randomized the realization plan x. arbitrarily. It is straightforward to verify plan, and easily convert between what advantages we have gained payoff function H as a linear was the key to the normal-form the two representations. However, from doing so. The key point function of the realization plan variables; strategy as a realization it is still not clear the this linearity is that we describe solution algorithms. 202 D. Keller: A. Pfeffer/Artijicial Intelligence 94 (1997) 167-215 & PJ PJ& PJ,& B.l PQ PQ>Ph PQ& BQ PK pK& PK& BK 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 100 0 0 0 100 0 0 0 -1 2 0 -I 2 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 2 0 -1 0 0 0 0 0 0 0 1 0 0 0 0 0 -1 -2 0 0 0 0 0 0 -1 2 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 -2 0 0 0 0 0 0 0 2 0 -1 0 0 0 -1 0 0 0 0 0 0 0 0 0 -1 -2 0 0 -1 -2 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 -2 0 0 0 -2 0 0 0 0 Fig. 12. Payoff matrix for the sequence form for simplified poker. To derive this linearity property, we must divide each path in the game tree into its in a game is the product of as the the . . , pN> components. The probability the probability product of the realization weights of all the players’ sequences on that path, times probability of all the chance moves on the path. That is, for a given tuple (PI,. of randomized of all of the moves on the path. This product can be re-expressed that a path is actually strategies, taken where p(p) rating denotes this expression the product of the chance probabilities into Definition 2, we obtain that: on the path to p. Incorpo- H(F) = c h(P) .P(P) q--JPk(akm. N leaves p k=l (1) If x is a realization is precisely xUk, so that H(p) each of the players. plan for player k corresponding is, indeed, linear to the strategy ,Uk, then in the realization weight variables ,&((+k) for In the two player case, the linearity of Eq. ( 1) allows us to achieve a matrix formu- lation analogous called the sequence form, we again define a matrix A (or a pair of matrices A, B) . But here, than pure strategies) of player 1, and the the rows correspond to the one we used for the normal form. In this representation, to the sequences (rather D. Keller; A. Pfeffer/Artificial Intelligence 94 (1997) 167-215 203 columns correspond to the sequences of player 2. The entry aij is the weighted sum of the payoff at the leaves that are reached by the pair of sequences ai and u-& i.e., aij = c P(P) * h(P). the matrix entry for the pair of sequences (denoted BQ ) For example, and [pass on a Jack after seeing a bet] from the one leaf is not consistent consistent with this pair of sequences). Note that if a pair of sequences with any path to a leaf, the matrix entry is zero. Thus, the matrix entry for the pair [bet on a Queen] is 0. Fig. 12 shows the matrix for the sequence and [pass on a Jack after seeing a pass] form for the simplified poker game. (denoted P”,) is 1 (obtained [bet on a Queen] Let x denote a realization for player 2. The entry xi of x is the weight of the sequence af at the ith row of A, i.e., one xi = ,ut (di ), where for player 1, and y denote a realization strategy co~csponding ,ut is the randomized to n (assuming plan plan exists). Similarly, yi = ,u,z(&~>. It now easily follows from the definitions of aij, xi, and yj, and from Eq. ( 1) that Hi (x,Y) = xTAy, precisely as for the normal We can now solve form. (*) using realization weights between similarity use of very similar in the following theorems: the normal techniques form and sequence to those used in the proofs of Theorems 7 and 8, resulting form formulations as our strategic variables. The the of (*) allow Theorem linear program game. 11 (Keller et al. [ 121) . The sequence (LP) whose solutions are the equilibria form of a zero-sum game defines a of the strategies) (maximin As before, standard LP solution algorithms provide us with polynomial time algo- rithms for solving such games. In the more general case: 12 (Keller et al. [ 121). Theorem defines a linear complementarity the game. One of these solutions found by Lemke’s algorithm [ 161. The sequence problem (each of which corresponds game form of a general ho-grayer (LCP) ~&ose soEutiuns are the equilibria of can be to an equilibrium) Lemkes algori~m is a simple variant of the ace-~owson algo~thm, with the same general characteristics. these results At first glance, seem very similar to the normal-form might not be clear what we have gained. The key is that the sequence representation there is at most one sequence each information set. Furthermore, the game tree. Thus, for example, so it the in the size of the game tree, since for it can be generated very easily by a single pass over the LP algorithm for each node in the game tree, and one constraint results, form (and of a realization plan) for zero-sum games is at most linear is polynomial 204 D. Kollel; A. Pfeffer/Art$cial Intelligence 94 (I997) 167-215 Fig. 13. Architecture of the Gala system. tree as opposed in the size of the game (The algorithms is exponential typically time reduction over the standard normal-form in the size of the normal form. for the general case are analogous, except that the worst-case behavior form is representation.) in the size of the game tree, these results provide an exponential in the size of the corresponding Since the normal to polynomial exponential algorithms! 6. The Gala system The Gala system builds on the techniques described in the previous sections and solving games. The system, described system for specifying three main stages for processing a game: generating a game solving the game tree, and examining the strategies. a complete uses specification, to provide in Fig. 13, tree from a Gala functionality, strategies. The result The system as a whole provides end-to-end from the game specification game-theoretic of the optimal for to the examination the game of experimental in Section 3.5, the specification of the general game is compact poker. As demonstrated of the parameters of the program allow the gen- instantiations and natural. Appropriate eration of a variety of games. These games can be effectively solved, and the strategy this below. interpreted. We illustrate is a very useful package this process, consider analysis. To illustrate 6.1. Game tree generation In the first stage, the system receives as input a game specified in Section 3). The system (as described various possible executions of the game. The interpreter works by maintaining the local state of the agents, and updating state, semantics the interpreter the possible outcomes, reaches a choice point, the Gala code, running (Section 3). When in a depth-first it according interprets including fashion. through in the Gala language the the game to the Gala it explores all of D. Keller, A. Pfe$er/Artijicial Intelligence 94 (1997) 167-215 205 The interpreter is implemented in Prolog, relying on the underlying Prolog interpreter in the Gala code. It also utilizes the the generation of the different to facilitate the embedded Prolog predicates for interpreting ability of F’rolog to deal with nondeterminism possible plays of the game. As a result, the interpreter generation of the execution is generated. Whenever is created. The node consisting structural equality). is added of all nodes where the player’s a choose searches the entire execution tree, the corresponding statement is encountered, to the appropriate information game tree, as defined tree of the program. During a node in the game set: the information the in Section 3.6, tree set to Prolog local state is the same (according 6.2. Solving the game the game the resulting the system solves stage of processing, this occurs via one of two methods. The first is using In the second game. Cmrently, form. The Gala system converts resulting matrices. These can be read by the appropriate implementation commercial We are currently working on the implementation games. The Gala system is the first to provide an implementation form algorithms. extensive-form the sequence the solution algorithm. The current the solution of zero-sum games, by using form. two-player of any of the sequence software packages I8 over the resulting of the system supports only of the case of general tree to its sequence linear programming form, and outputs sequence The other solution method is via an interface to the GAMBIT system [ 191, a state- theory software package which provides a number of game-theoretic (primarily algorithms of-the-art game for the normal solution of a game in a format readable by GAMBIT, and calls the appropriate GAMBIT over the result. that such games written combinatmn. in the Gala language can be solved using In particular, GAMBIT form). Gala outputs provides algorithms for multi-player form routines games, so in the two systems the extensive from the program of Fig. 6. The Gala system, via its interface the performance form and the normal form algorithms on practical problems. We experi- in Figs. 7 to GAMBIT, allows us to compare from the Gala program of the sequence mented with two games: simplified poker, instantiated and 8, and inspection game, instantiated The experiments were performed induced by different different variants of these games, We generated poker games with different numbers of cards tion games with a varying number of stages and inspections. experiments, solution engine and the resulting for the conversion together. as follows: The Gala system was used to generate to the parameters. instantiations in the deck, and inspec- form form by the Gala linear program was solved using CPLEX. The times form and the solution of the linear program were added form was transformed For the sequence to the sequence the extensive to sequence For the normal form experiments, the game trees were printed to normal form by the GAMBIT system. The normal I8 CPLEX, Matlab and OSL are all supported. to a file and converted form linear program was again 206 D. Keller: A. Pfeffer/Art@cial Intelligence 94 (1997) 167-215 250 Nemxlfcwm - Sequence form - oL----. 0 500 : 1 2500 WI0 1000 1500 number of nodes in tree 2000 % 2 E” S P z 5 1 4 600 500 400. 300 _ 200 . 100 ” 0 0 Nomal form - sequence ioml - 500 1000 1500 2rJoo number of nodes in tme 2500 3000 Poker Inspection game Fig. 14. Normal form versus sequence form NnniIIg time. 1 5000 10000 15000 2Oooo 25000 number of nodes in tree 0 6000 1GOoo 15000 2iBoo 25oOcl number of nodes in tree Poker Inspection game Fig. 15. Time for genemting and solving the sequence form. solved using CPLEX. The times for the conversion the linear program were added together. running times are shown The resulting to normal form and the solution of in Fig. 14. They are as one would expect in a between a polynomial and exponential algorithm. The results are continued form in Fig. 15. (It was impossible for In more recent experiments, we have solved poker games with over take about an hour on a (see below}. The largest games we have solved to obtain normal-form results comparison for the sequence the larger games.) 140,000 nodes Sun UltraSPARC We believe II. that the Gala system can easily be modified the implementation. the sequence games, simply by streamlining time between generating the poker games, we can see that generating Solving even that the system can be made to run considerably generator. Furthermore, the largest of these games the current form and solving larger to deal with much Fig. 15 also shows the division of linear program. For form takes the bulk of the time. takes less than 10 seconds. Thus, we believe the sequence-form faster by optimizing the sequence the resulting implementation of this generator stores the game D. Keller; A. F’jee$er/Arti$cial Intelligence 94 (1997) 167-215 207 # cards in deck 48 43 38 33 28 23 18 13 8 3 1 fig. 16. Parameters of largest poker games solved. tree in main memory as it is generated. As a consequence, the amount of main memory available posed the most severe constraint on the size of our experiments. A more careful the implementation would write the game tree to disk as it is created, and then generate sequence in a single pass over the tree). We believe that these minor modifications will allow the system to efficiently deal with much it (a process which can be done larger games. form from the main In general, influences on the complexity of solving a sequence in the tree and the structure of the information form game sets. In poker, are the number of nodes for example, the total size of the tree is determined by the initial number of deals and the number of nodes in the subtree for each deal, which in turn depends on cash - ante. Fig. 16 shows the number of cards in the deck, the number of cards dealt to each player, for the largest games solved so far. The most extreme points and the number of rounds are 127 card deck, 1 card each, 1 round; 3 card deck, 1 card each, 11 rounds; and 11 card deck, 5 cards each, 3 rounds. The influence of the information-set formance of the sequence-form Games such as poker, which are wide and shallow, tion sets (information sets which cannot be reached typically gain the most from the use of the sequence the other hand, the tree tends to be deep and narrow, reducing obtained from the sequence-form representation. is apparent when we compare for poker games and for inspection tend to have many parallel the per- games. informa- in the same play of a game) ; they form. In the inspection game, on savings the computational algorithm structure 6.3. Examining the strategies The final stage of processing .by the solution covered allows the user to examine the optimal engine. The user can navigate the game strategies dis- the tree and view 208 D. Kolles A. Pfeffer/Art@cial Intelfigence 94 (1997) 167-215 0’ 6 7 6 Cafd 10 recaived J Q K 0 6 7 8 0 10 J Q K Card received First round Second round Fig. 17. Gambler strategies for S-card poker. *i 6 7 8 9 10 J Q K Card received oi 6 7 8 9 Card recelifed J 0 K After seeing pass After seeing bet Fig. 18. Dealer strategies for S-card poker. optimal behavior since GAMBIT offers a nice graphical user interface resulting strategy at any information strategies. set. The GAMBIT is also useful, for displaying game trees and the interface The Gala system also provides other useful information about the equilibrium in the game tree has a v&e, which solution. is fixed, every branch is Once a pair of strategies is taken and from that point the the expected outcome of the game given that the branch induce players continue a probability distribution over the plays of the game. Therefore, at any of her information sets, the player can derive a belief nodes in the information and the belief state of a player. over the the value of any action to the specified strategies. Also, the strategies the user to examine resulting probability to play according set. Gala allows distribution state-the Figs. 17 and 18 present version of the simplified card deck, each player the strategies poker discussed for an eight-card (We have an eight- is dealt one card, has an ante of $1, and another dollar with from this analysis the paper. throughout resulting D. Keller: A. Pfeffer/Art$cial intelligence 94 (1997) 167-21.5 209 that can be in the the probability it is very high on a 1, 0 on the middle cards, and then goes up for the example of the insights that the gambler bets interesting an for the low cards corresponds a characteristic to associate with the psychological makeup of human players. Similarly, the dealer bets on low cards with very high the gambler In more complex games, we in the first round, in the final round. this as an attempt to discourage to bluffing, to bet.) l9 They provide which achieved by such an analysis. Consider first round: high cards. The behavior that one tends after seeing a pass probability. Psychologically, we interpret from “changing his mind” and betting see other e:xamples where “human” behavior optimal. (e.g., underbidding) is game-theoretically The fact that such “psychological” was first pointed out by Kuhn for the 3-card poker game described above. The Gala system makes ysis an effortless process, and allows games. optimal [ 141. It was a result of a laborious manual in poker analysis this type of anal- it to be carried out for much more complex properties are game-theoretically As this example various actions implemented the outcome of a game-theoretic game, preventing illustrates, the system also provides (e.g., bluffing on a low hand). Thus, for the the output of the system can be directly. Before, only very simple games could be solved exactly. Thus, solution process was a strategy for a greatly simplified the exact probabilities the results from being directly applicable. 7. Discussion 7.1. Equilibrium and optimality particularly Throughout the paper, we have not questioned the use of Nash equilibrium the Nash equilibrium In practice, however, in the case of extensive-form definition of the desired solution. ways appropriate, even in the (relatively imin strategy in the worst case, to materialize when human players are involved: human players takes. as the is not al- games. The problem arises case of zero-sum games. The definition of a max- ,~i be optimal is unlikely invariably make mis- i.e., when player 2 is playing optimally. This situation (as set out in Theorem 6) only requires that the strategy very simple) results adversary in strategies The maximin criterion that are guaranteed than against an optimal one. But the strategies are not guaranteed suboptimal to very they become to take advantages counterintuitive to win $1 assume against an optimal player 2. But now, the latter makes a mistake which allows player 1 to immediately win $10000. of mistakes when behavior. For example, It is perfectly consistent with the definition that player 1 is guaranteed to do no worse against a apparent. This can for the “optimal” lead I9 The game was generated and solved in under 2 seconds using form algorithm did not terminate after two days of execution. the Gala system. The corresponding normal 210 D. Keller; A. Pfe#er/Artificial Intelligence 94 (1997) 167-215 (maximin) goal. strategy to continue playing so as to win the $1 that was the original and induction information to compare for a perfect this behavior It is interesting the one resulting game. In the perfect strategy definition also allows for strategies with the same bizarre behavior. However, backward at each node, imperfect point on” (see Section 7.2 for some discussion). Essentially, which node information set is much more complicated. from an optimal case, the maximin the specific algorithm used to solve the game avoids such strategies by picking, in the case of from this the player might not know that are optimal from an it is much harder to define a notion of “optimal is optimal at that node. Unfortunately, is actually at, and designing the move which information information the game strategies games, These difficulties suite of alternative options is beyond to be no consensus useful is in progress on the computational [ 20,3 1 ] for some results. *O are well known, and have led to the development solution concepts. The discussion (more refined) the scope of this paper; see [ 301 for a survey. Currently, to this problem. Nevertheless, as to the “right solution” of an extensive of the different there seems it would be into the Gala system. Work aspects of these more refined solution concepts. See solutions to incorporate one or more of the alternative There is an alternative than simply the type of mistake players. Rather to learn be used when sharing similar games. The ability of the Gala particularly useful provide there is a long-term flaws in play), features in this context, since for the learning algorithm. less-than-perfect approach reacting that a certain player to the problem of dealing with to suboptimality when interaction with the same player is prone it is detected, we can try to make. This approach can (or with players (long) game or over a series of in the game may be regularities the high-level description of a game state can either within a single to capture language 7.2. Scaling up While we can now solve games with tens of thousands of nodes, we are nowhere close to being able to solve huge games such as full-scale poker, and it is unlikely that we will ever be able to do so. A game tree for five-card draw poker, for example, where players are allowed (for games: We have zero-sum games) algorithms the game tree is often extremely to exchange cards, has over 1O25 different nodes. The situation in the size of the game tree; unfortunately, to that of perfect-information that are fairly efficient is now quite similar Nevertheless, large. chess-playing cannot to imperfect currently applied but the issue is nontrivial. solve full-scale information programs are very successful chess. Can games? We believe that, in principle, the standard game-playing in spite of the fact that we be is yes, the answer techniques *O [20] also contains an extensive games. survey of computational methods for finding equilibria of non-zero-sum D. Kolles A. Pfeffer/Artijkial Intelligence 94 (1997) 167-215 211 The general standard form: algorithms for playing perfect-information games have the following function an initial Expand heuristic evaluation Compute optimal pure strategies the action at the root Choo:se opponent to choose an action. Return new root. to step 1, using subtree of the game, beginning at the root node, and using a to assign a payoff in the resulting is optimal that to the leaves of the subtree. subtree. *’ in the subtree, and wait for the the node reached as a consequence of the actions as the in the in. That is, to solving imperfect-information Can we adapt this approach games? Initially, every- to work out fine. Just as before, we expand an initial subtree of the game, to assign a payoff function strategies tree to obtain randomized for the initial stages of the game, so play can thing seems beginning to the leaves of the subtree. We solve the resulting for each player. We now have a strategy proceed. at the root node, and use a heuristic evaluation The problem arises when we attempt to apply this idea to subsequent positions the player might not know what node she is actually game. At that point, the actual node might be p, while the player knows only that she is in the information set u which contains p. The player must therefore consider and somehow combine subtrees information in u, to obtain a single decision rooted at each of the nodes the for the entire set. in think the nodes Of course, the player also has beliefs over determined by the strategies computed before and the probabilities Therefore, reasoning generating world. We find an optimal move in each tree. Finally, we choose a randomized in which each move it is optimal. set, as of the chance moves. can be solved by a simple process of set separately, in the information that this is the true state of the strategy, that the true state is one for which one might by cases. We consider each of the nodes the assumption a game is weighted by the probability that the problem tree representing the information This approach is clearly flawed: it assumes that the player has perfect information in each round, inspecting. This action has a cost, but does not waste an entire also has the possibility of gathering for example, the inspector when making her decision. Consider, where, before might well be the optimal course of action. However, algorithm d.escribed above. The algorithm considers occurred, in which case one should simply which case the intelligence gather is a waste of resources. inspection. It it will never be chosen by the two options: Either a violation has in inspect; or, a violation has not occurred, a variant of the inspection intelligence game A somewhat more plausible the current pos-ition: The player creates a new game tree, in which the root node is a chance the player’s node, and its children are all the nodes in u. The chance move represents the player’s uncertainty incorporates approach about ” The solution process can be used to guide is often interleaved with the process of generating the game tree, so that partial results the expansion process to more relevant parts of the game tree. 212 D. KolleK A. Pfe$er/Artifcial Intelligence 94 (1997) 167-215 uncertainty, the player’s belief state. The analysis now proceeds with the new tree. of the chance move leading so that the probability to each node agrees with it does it ignores the dealer incorporate set correspond is more subtle. While in three-card poker when The flaw in this algorithm information. Consider the second to decide on her action following the player’s uncertainty, if the player knows the opponent’s uncertainty. After all, even that the true state is one of the nodes in u, the opponent does not necessarily have the round same is a pass by the gambler. The dealer knows her trying own hand, a Jack. The two nodes in her information to those where the gambler has a Queen and a King. In any game that begins by choosing one of these two the gambler will always have a better card than the dealer, and know nodes at random, it, so the dealer has no reason if the gambler in fact, the optimal has a Queen he will not know to take advantage of strategy this situation. The point strategy. Thus, one cannot eliminate if one knows for a fact that they are not. Similarly, nodes possible, but that one player an effect on a player’s strategy. The only nodes that can be completely consideration reached. 22 state can have a large effect on one’s even considers possible, that neither player considers the other player considers possible, can also have from that they cannot be to bluff. However, that he has the better card. And, that the dealer bluff with non-zero probability, it is common knowledge information nodes is that the opponent’s are those for which in the actual game, that the opponent eliminated requires thinks [6] reduce is dynamically It might be possible in which knowledge such nodes. The resulting to develop a solution approach, analogous the number of reachable nodes stays constant, the size of the game tree. Some other method of pruning game and with variants of poker the elimination to the one described algorithm may be useful in a poker game which consists of a deal followed by since all bets are above, where we only eliminate in some games. For example, many rounds of betting, common knowledge. 23 Unfortunately, many games have a more complex structure, created and revealed. This with the inspection the course of the game. In such games, significantly is needed, perhaps one based on the value of information metric believe an interesting Besides information is the case in which cards are dealt during nodes may not the tree [ 93 ). We the tree in a principled manner presents the difficulties designing the heuristic evaluation subtree. This function must take into account other words, nodes in the same information conceivably might estimate fails to differentiate between in function used to evaluate nodes at the leaves of the in a state. In the evaluation of a node must consider not only the node itself, but other state of all the players may for poker function that the player with the better hand will win the current stake, but this the states where a player knows she has the better hand and affect the node’s value.) For example, a naive evaluation the tree, care must also be taken the knowledge of the players set. (In fact, the information research problem. that developing of unreachable an algorithm that prunes in pruning (see, e.g., involved 22 A fact 4 is common knowledge know that they know 23 Unfortunately, the main challenge that they know q5, and so on. in poker is not the depth of the tree but its width. if both players know 4, both players know that they both know 4, they D. Keller; A. Pfe$er/Artijicial Intelligence 94 (1997) 167-215 213 one where she does not, and this knowledge affects the value of the state. In three-card poker, if your opponent possesses a Jack, the state in which you possess a King is better than the one in which you possess a Queen, because you cannot be fooled by a bluff. all of these obstacles, the bounded-depth-search if we were to circumvent is not a general solution. While Even proach too wide, some game trees (full scale poker, for example) depth 1. One approach for such games based on abstraction. Many similar game states are mapped resulting can then be solved completely, play the real game. ap- it may work when the game tree is deep but not to cannot even be expanded (as well as for others) is to the same abstract state, tree tree. The abstract for the abstract game can be used to in an abstract game tree much smaller that may be useful and the strategies than the original In poker, for example, this approach is likely to work very well. It is implausible that that a player can get (in 5-card draw) generates a completely in Section 6 reveal a lot of regularity results each of the (552) hands different strategy. Indeed, our experimental in the strategies, with the gambler exhibiting We believe that are very close various possible abstractions. that the solution for an appropriately to optimal. We are currently identical behavior for the cards 6, 7 and 8. abstracted game will result in strategies in the process of experimenting with to concisely and naturally appropriate abstractions automatically. Even more interestingly, represent a game via its rules may even allow it raises that solve possibility that we might, one day, develop solution algorithms from their rules. Gala’s ability us to construct the intriguing games dinectly 7.3. Conclusion The Gala system can provide search. Different abstractions efficiently. Gala therefore provides a convenient approaches for solving games. the infrastructure re- for experimental and variants of a game can be generated easily and solved tool for testing and evaluating different game-theoretic Perhaps more importantly, Gala can play a crucial role in making game-theoretic simply, in a language to be described expert) the given to people and computer reasoning more accessible plex games not a game-theory equately models in the system nally, a non-expert http://robotics.stanford.edu/"koller/gala.html) will encourage game-theoretic can use. This allows situation. The effective to be obtained the game solution in a reasonable and the public human. We hope can be examined even a layperson the solutions in day-to-day in a way availability interpreted algorithms reasoning solutions of Gala allow life. that that implemented is legible amount of time. Fi- for from the use of (available systems. The system allows com- is it ad- to be refined until (one who Acknowledgements We are deeply grateful way to ensure that the GAMBIT to Richard McKelvey and Ted Turocy for going out of their functionality we needed for our experiments was ready 214 D. Kolles A. Pfeffer/Art@cial Intelligence 94 (1997) X67-215 us access to the CPLEX system the ~ntemational Computer Science for Institute on time. We also thank providing in the early stages of the project. We also wish to thank Nimrod Megiddo, Barney Pell, Stuart Russell, Yoav Shoham, John Tomlin, Bernhard von Stengel, Michael Wellman, and Salim Yusufali and comments. Some of this work was done while both authors were at U.C. Berkeley, with the support of a University of California President’s Postdoctor~ Fellowship and an NSF Science. More recent work was supported Postdoctoral Associateship and by ONR grant NOOO14-96-l-0718. through the generosity of the Powell foundation, for useful discussions in Experimental at Berkeley [ I] R.J. Aumann and S. Hart, eds., Handbook of Game Theory, Vol. 1 (North-Holland, Amsterdam, 1992). [2] R. Avenhaus, B. von Stengel and S. Zamir, Inspection games, in: R.J. Aumann and S. Hart, eds., Handbook of Game Theory, Vol. 3 (North-Holland, Amsterdam, 1997). [ 3 ] J.R.S. Blair, D. Mutchler and C. Liu, Games with imperfect info~~on, in: W~~~~~~ bores of&e Adftl Fall Symposium on Gantes: Planning and Learning ( 1993). 141 R.W. Cottle, J.-S. Pang and R.E. Stone, The Linear Complementarity Problem (Academic Press, New York, 1992). f5] G.B. Da&g, Linear Programming and Extensions (Princeton University Press, Princeton, NJ, 1963). 161 R. Fagin, J.Y. Halpem, Y. Moses and M.Y. Vardi, Reasoning abuu# Knowledge (MIT Press, Cambridge, MA, 1995). [7] M. Franklin, 2. Galil and M. Yung, Eavesdropping games: a graph-theoretic approach to privacy in distributed systems, in: Proceedings 34th Annual IEEE Symposium on Foundations of Computer Science ( 1993) 670-679. info~a~on, in: WoT~~ng Notes of the AAAI Fall ~~m~o~i~rn on Games: Planning and warning [S] S. Gordon, A comparison between probabilistic search and weighted heuristics in a game with incomplete f 1993). [9] R.A. Howard, J.E. Matheson and K.L. Milbr, eds., Readings on the Principles and Applications of Decision Analysis (Stanford Research Institute, Strategic Decisions Group, Menlo Park, CA, 1977). [IO] L.l? Kaelbling, M.L. Littman and A.R. Cassandra, Planning and acting in partially observable stochastic domains, Submitted for publication; can be obtained from http: //www . cs. duke. edu/ -~litt~~/topics/pomdp-page.html(l996). [ 1 I ] D. Keller and N. Megiddo, The complexity of two-person zero-sum games in extensive form, Games and Economic Behavior 4 (1992) 528-552. [ 121 D. Koller, N. Megiddo and B. von Stengel, Fast algorithms for finding randomized strategies in game trees, in: Proceedings of the 26th Annual ACM Symposium on the Theory of Computing ( 1994) 750-759. [ 131 D. Koller, N. Megiddo and B. von Stengel, Efficient solutions of extensive two-person games, Games and Economic Behavior 14 (1996) 247-259. [ 141 H.W. Kuhn, A simplified two-person poker, in: H.W. Kuhn and A.W. Tucker, eds., Contributions to the Theory of Games I (Princeton University Press, Princeton, NJ, 1950) 97-103. [ 151 H.W. Kuhn, Extensive games and the problem of information, in: H.W. Kuhn and A.W. Tucker, eds., Contributions to the Theory of Games II (Princeton University Press, Princeton, NJ, 1953) 193-216. [ 161 C.E. Len&e, Bimatrix eqniIib~um points and mathematical pugging, ~a~ugerne~# Sei. 11 ( 1965) 681-689. [ 171 C.E. Lemke and J.T. Howson Jr, Equilibrium points in bimatrix games, J. Sac. Industrial Appl. Math. 12 (1964) 413-423. [ 181 W.F. Lucas, An overview of the mathematical theory of games, Management Sci. I$ Appendix P ( 1972) 3-19. [I91 R.D. McKelvey, GAMBIT: ~~fe~acfjve Extensive Form Game Program (California Institute of Technology, Pasadena, CA, 1992). 1201 R.D. McKelvey and A. McLennan, Computation of equilibfia in finite games, in: Handbook of Computational Economics ( 1996). D. Keller, A. Pfeffer/Artificial Intelligence 94 (1997) 167-215 215 [21] J.F. Nas,h, Non-cooperative games, Ann. of Math. 54 ( 1951) 286-295. [22] R. Norton, Winning the game of business, Fortune Mag. 131 ( 1995) 36. [23] P. Pa&h, A game-theoretic account of implicature, in: Proceedings 4th Conference on Theoretical Aspects of Reasoning about Knowledge (TARK) (Morgan Kaufmann, Los Altos, CA, 1992). [24] B. Pell, Metagame in symmetric, chess-like games, in: H. van der Herik and L. Allis, eds., Heuristic Programming in Artificial Intelligence 3-The Third Computer Olympiad (Ellis Horwood, Chichester, 1992). [25] E. Rasmusen, Games and Information: An Introduction to Game Theory (Basil Blackwell, Oxford, 1989). [26] J.V. Romanovsky, Reduction of a game with perfect recall to a constrained matrix game, Dokl. Akad. Nuuk SSSR 144 (1962) 62-64 (in Russian). [27] J.S. Rosenschein and G. Zlotkin, Consenting agents: designing conventions for automated negotiation, AI Mug. 15 (1994) 29-46. [28] S.J. Shenker, Making greed work in networks: a game-theoretic analysis of switch service disciplines, IEEE/ACM Trans. Networking 3 (1995) 819-831. [ 291 S.J.J. Smith and D.S. Nau, Strategic planning for imperfect-information games, in: Working Notes of the AAAI Fall Symposium on Games: Planning and Learning ( 1993). [30] E. van Damme, Refinements of the Nash Equilibrium Concept, Lecture Notes in Economics and Mathematical Systems (Springer, Berlin, 1983). [ 3 11 A. van den Elzen, B. von Stengel and D. Talman, Tracing equilibria in extensive games by complementary pivoting, Manuscript ( 1996). [32] J. von Neumann and 0. Morgenstem, The Theory of Games and Economic Behavior (Princeton University Press, Princeton, NJ, 2nd ed., 1947). [ 331 B. von Stengel, Efficient computation of behavior strategies, Games and Economic Behavior 14 (1996) 220-24-6. [ 341 E. Zerrelo, Uber eine Anwendung der Mengenlehre auf die Theorie des Schachspiels, in: E.W. Hobson and A.E.H. Love, eds., Proceedings 5th International Congress of Mathematicians II (Cambridge University Press, Cambridge, 1913) 501-504. 