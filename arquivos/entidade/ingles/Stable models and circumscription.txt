Artificial Intelligence 175 (2011) 236–263Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintStable models and circumscriptionPaolo Ferraris a, Joohyung Lee b, Vladimir Lifschitz c,∗a Google, Inc., 1600 Amphitheatre Parkway, Mountain View, CA 94043, United Statesb Department of Computer Science and Engineering, Arizona State University, 699 South Mill Avenue, Tempe, AZ 85281, United Statesc Department of Computer Sciences, University of Texas at Austin, 1 University Station C0500, Austin, TX 78712, United Statesa r t i c l ei n f oa b s t r a c tArticle history:Available online 13 April 2010Keywords:Answer set programmingCircumscriptionNonmonotonic reasoningProgram completionStable models1. IntroductionThe concept of a stable model provided a declarative semantics for Prolog programswith negation as failure and became a starting point for the development of answer setprogramming. In this paper we propose a new definition of that concept, which coversmany constructs used in answer set programming and, unlike the original definition, refersneither to grounding nor to fixpoints. It is based on a syntactic transformation similar toparallel circumscription.© 2010 Elsevier B.V. All rights reserved.Answer set programming (ASP) is a form of declarative logic programming oriented towards knowledge-intensive searchproblems, such as product configuration and planning. It was identified as a new programming paradigm ten years ago [25,29], and it has found by now a number of serious applications. An ASP program consists of rules that are syntacticallysimilar to Prolog rules, but the computational mechanisms used in ASP are different: they use the ideas that have led to thecreation of fast satisfiability solvers for propositional logic [11].ASP is based on the concept of a stable model [9]. According to the definition, to decide which sets of ground atoms are“stable models” of a given set of rules we first replace each of the given rules by all its ground instances. Then we verifya fixpoint condition that is similar to the conditions employed in the semantics of default logic [33] and autoepistemiclogic [28] (see [19, Sections 4, 5] for details).In this paper we investigate a new approach to defining the concept of a stable model. It is based on a syntactictransformation similar to circumscription [26,27]. The new definition refers neither to grounding nor to fixpoints. It turnsout to be more general, in a number of ways, than the original definition.This treatment of stable models may be of interest for several reasons. First, it provides a new perspective on theplace of stable models within the field of nonmonotonic reasoning. We can distinguish between “fixpoint” nonmonotonicformalisms, such as default logic and autoepistemic logic, and “translational” formalisms, such as program completion [1]and circumscription. In the past, stable models were seen as part of the “fixpoint tradition.” The remarkable similaritybetween the new definition of a stable model and the definition of circumscription is curious from this point of view.Second, we expect that the new definition of a stable model will provide a unified framework for useful answer setprogramming constructs that have been defined and implemented by different research groups. For instance, it may help uscombine choice rules in the sense of lparse [34] with aggregates in the sense of dlv [3]. A step in this direction is describedin [14].* Corresponding author.E-mail address: vl@cs.utexas.edu (V. Lifschitz).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.04.011P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263237Third, our definition is applicable to non-Herbrand models. In such a model, different ground terms may have the samevalue. This may be useful for knowledge representation purposes; we may wish to write, for instance:Father(Jack) = Father(Jane).This possibility is related also to the use of arithmetic functions in ASP, when different ground terms may have the samevalue (2 + 2 = 1 + 3).The new definition of a stable model is introduced in Section 2, and its relation to the original definition is discussedin Section 3. Several useful theorems about the new concept are stated in Section 4. Then we extend the idea of strongequivalence to this framework (Section 5), relate general stable models to program completion (Section 6), and define“pointwise stable models,” which are similar to pointwise circumscription (Section 7). In Section 8, we show how ourtheory of stable models handles strong (or classical) negation, and Section 9 discusses related work. Proofs of theorems arecollected in Appendix A.To make the presentation more self-contained, we include brief reviews of parallel and pointwise circumscription (Sec-tions 2.2 and 7.1) and of two approaches to the stable model semantics proposed earlier (Section 3.1).This article is an extended version of the conference paper [6].2. Stable models2.1. Logic programs as first-order sentencesThe concept of a stable model will be defined here for first-order sentences,1 possibly containing function constantsand equality. Logic programs are viewed in this paper as alternative notation for first-order sentences of special types. Forinstance, we treat the logic programp(a, a),p(a, b),q(x) ← p(x, y)as shorthand forp(a, a) ∧ p(a, b) ∧ ∀xy(cid:2)(cid:3)p(x, y) → q(x).The constraint← p(x), not q(x)(1)(2)(3)is identified with the formula(cid:2)∀x¬(cid:3)p(x) ∧ ¬q(x),and the disjunctive rulep(x); q( y) ← r(x, y)with(cid:2)r(x, y) →(cid:2)∀xy(cid:3)(cid:3)p(x) ∨ q( y).As another example, take the choice rule(cid:4)(cid:5)p(x)← q(x).It says, informally speaking: for every x such that q(x), choose arbitrarily whether or not to include p(x) in the stable model.We can treat this rule as shorthand for(cid:2)(cid:3)(cid:3).(4)(cid:2)q(x) →∀xp(x) ∨ ¬p(x)This formula is logically valid, so that appending it as a conjunctive term to any sentence F would not change the class ofmodels of F . But the class of stable models of F may change, as we will see, after appending (4).The next example involves an aggregate. The rulep(x) ← # card(cid:4)(cid:5)y: q(x, y)< 2means intuitively: if the cardinality of the set { y: q(x, y)} is less than 2 then include p(x) in the stable model. We can treatthis rule as an abbreviation for the formula(cid:2)∀x¬∃ y1 y2(cid:2)q(x, y1) ∧ q(x, y2) ∧ y1 (cid:9)= y2(cid:3)(cid:3)→ p(x).(5)1 A sentence is a formula without free variables.238P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–2632.2. Review of circumscriptionSince the new definition of a stable model is similar to the definition of parallel circumscription, we will begin with abrief review of the latter.Both definitions use the following notation. If p and q are predicate constants of the same arity then p (cid:2) q stands forthe formula(cid:2)(cid:3)p(x) → q(x),∀xwhere x is a tuple of distinct object variables. If p and q are tuples p1, . . . , pn and q1, . . . , qn of predicate constants thenp (cid:2) q stands for the conjunction(p1 (cid:2) q1) ∧ · · · ∧ (pn (cid:2) qn),and p < q stands for (p (cid:2) q) ∧ ¬(q (cid:2) p). In second-order logic, we apply the same notation to tuples of predicate variables.Let p be a list of distinct predicate constants.2 The circumscription operator with the minimized predicates p, denoted byCIRCp, is defined as follows: for any first-order formula F , CIRCp[F ] is the second-order formula(cid:2)F ∧ ¬∃u(cid:3)(u < p) ∧ F (u),where u is a list of distinct predicate variables of the same length as p, and F (u) is the formula obtained from F bysubstituting the variables u for the constants p.3If the list p is empty then we understand CIRCp[F ] as F . We will drop the subscript in the symbol CIRCp when this doesnot lead to confusion.For any sentence F , a p-minimal (or simply minimal) model of F is an interpretation of the underlying signature thatsatisfies CIRCp[F ]. Since the first conjunctive term of CIRCp[F ] is F , it is clear that every minimal model of F is a modelof F .Example 1. If F is formula (2) then CIRCpq[F ] is(cid:3)(cid:3)(cid:2)(cid:2)∀xyp(a, a) ∧ p(a, b) ∧∧ ¬∃uv(cid:2)(cid:2)(cid:3)(u, v) < (p, q)p(x, y) → q(x)∧ ∀xy(cid:2)u(a, a) ∧ u(a, b) ∧(cid:2)u(x, y) → v(x)(cid:3)(cid:3)(cid:3).It can be equivalently rewritten without second-order variables as follows:(cid:2)∀x(cid:3)p(x, y) ↔ (x = a ∧ y = a) ∨ (x = a ∧ y = b)(cid:2)q(x) ↔ x = a∧ ∀xExample 2. Let F be the formula(cid:2)(cid:3)p(x, y) → t(x, y)∀xy∧ ∀xyz(cid:2)(cid:3)t(x, y) ∧ t( y, z) → t(x, z)(“p is a subset of t, and t is a transitive relation”). Then CIRCt[F ] is(cid:3).(6)(7)(cid:2)∀xy(cid:3)p(x, y) → t(x, y)(u < t) ∧ ∀xy(cid:2)∧ ¬∃u∧ ∀xyz(cid:2)(cid:3)p(x, y) → u(x, y)(cid:2)(cid:3)t(x, y) ∧ t( y, z) → t(x, z)(cid:2)∧ ∀xyzu(x, y) ∧ u( y, z) → u(x, z).(cid:3)(cid:3)This condition cannot be expressed by a first-order formula, but its meaning is straightforward: it says that t is the transitiveclosure of p.If we conjoin (7) withp(a, b) ∧ p(b, c)(8)and include both p and t in the list of minimized predicates then the circumscription formula will become expressible infirst-order logic as(cid:2)∀xy(cid:3)p(x, y) ↔ (x = a ∧ y = b) ∨ (x = b ∧ y = c)∧ ∀xy(cid:2)(cid:3)t(x, y) ↔ (x = a ∧ y = b) ∨ (x = b ∧ y = c) ∨ (x = a ∧ y = c).(9)2 In this paper, equality is not considered a predicate constant, so that it is not allowed to be a member of p.3 This definition of the circumscription operator allows F to have free variables, unlike the definition from [17]. Similarly, the definition of the stablemodel operator below is applicable to formulas with free variables, unlike the definition proposed in the conference paper [6].P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–2632392.3. Operator SMWe will now define the stable model operator with the intensional predicates p, denoted by SMp. Some details of thedefinition depend on which propositional connectives and quantifiers are treated as primitives, and which of them areviewed as abbreviations. Let us decide that the primitives are⊥ (falsity), ∧, ∨, →, ∀, ∃;¬F is an abbreviation for F → ⊥, (cid:12) stands for ⊥ → ⊥, and F ↔ G stands for (F → G) ∧ (G → F ).Let p be a list of distinct predicate constants p1, . . . , pn. For any first-order formula F , by SMp[F ] we denote the second-order formula(cid:2)F ∧ ¬∃u(u < p) ∧ F∗(cid:3)(u),where u is a list of n distinct predicate variables u1, . . . , un, and F∗(u) is defined recursively:∗ = F for any atomic formula F that does not contain members of p 4;∗• pi(t)∗ = ui(t) for any tuple t of terms;• F• (F ∧ G)∗ = F• (F ∨ G)∗ = F• (F → G)∗ = (F• (∀xF )∗ = ∀xF∗• (∃xF )∗ = ∃xF;∗;∗ → G;.∗) ∧ (F → G);∗ ∧ G∗ ∨ G∗If the list p is empty then we understand SMp[F ] as F . We will drop the subscript in the symbol SMp when this does notlead to confusion.For any sentence F , a p-stable (or simply stable) model of F is an interpretation of the underlying signature that satisfiesSMp[F ].5 Since the first conjunctive term of SMp[F ] is F , it is clear that every stable model of F is a model of F .Note that if we drop the second conjunctive term from the clause for implication in the definition of F∗(u) then thisformula will turn into F (u), and SM[F ] will turn into CIRC[F ]. It follows that for any sentence F that does not containimplication, SM[F ] coincides with CIRC[F ], and the stable models of F are identical to the minimal models of F .In the next section we will see examples when these two formulas are equivalent to each other even though F doescontain implication. We will see also that there are cases when minimal models are not stable, and when stable models arenot minimal.2.4. ExamplesExample 1 (continued). Let F be formula (2). As noted above, CIRCpq[F ] is equivalent to (6). Consider the result of applyingSMpq to the same formula. Clearly Fu(a, a) ∧ u(a, b) ∧ ∀xy(cid:3)u(x, y) → v(x)p(x, y) → q(x)∗(u, v) is(cid:3)(cid:3)(cid:2)(cid:2)∧(cid:2),and SMpq[F ] isp(a, a) ∧ p(a, b) ∧ ∀xy(cid:2)(cid:2)(cid:3)(u, v) < (p, q)∧ ¬∃uv(cid:2)(cid:3)p(x, y) → q(x)∧ u(a, a) ∧ u(a, b) ∧ ∀xy(cid:2)(cid:2)(cid:3)u(x, y) → v(x)∧(cid:2)p(x, y) → q(x)(cid:3)(cid:3)(cid:3).In the presence of the conjunctive term ∀xy(p(x, y) → q(x)) at the beginning of the formula, the conjunctive term p(x, y) →q(x) at the end can be dropped. This simplification turns SMpq[F ] into CIRCpq[F ]. Consequently, SMpq[F ] is equivalent to (6)as well.Remark 1. It is easy to see that, more generally, SM[F ] is equivalent to CIRC[F ] whenever F is a conjunction such that everyconjunctive term• does not contain implication, or• is the universal closure of a formula G → H such that G and H do not contain implication.Remark 2. The equivalence of SMpq[F ] to (6) in Example 1 can be established also in another way, without referencesto circumscription. In Sections 6.2 and 7.3 we will show how the theory of tight programs [4,2] can be extended to the4 This includes the case when F is ⊥.5 The definition of a stable model used in the conference paper [6] and in related publications [13,16] is less general: it treats all predicate constantsoccurring in F as intensional. We will see that this additional degree of generality is convenient (Section 3.2) but not very essential (Section 4.1).240P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263framework described in this paper, and we will see that the result of applying the operator SM can be often turned into afirst-order formula using the process of program completion. This method can be applied, in particular, to formula (2).Remark 3. According to the original definition of a stable model [9], the only stable model of program (1) is its minimalHerbrand model(cid:4).(10)(cid:5)p(a, a), p(a, b), q(a)This fact is in agreement with the result of the calculation in Example 1, in the sense that (10) is the only Herbrandinterpretation satisfying (6). This is an instance of a general theorem about the relationship between the new, generaldefinition of a stable model and the original definition, which is stated in Section 3 below.Example 2 (continued). If F is (7) then SMt[F ] is equivalent to CIRCt[F ], according to Remark 1. Consequently, in the t-stablemodels of (7), t is the transitive closure of p. Similarly, if F is the conjunction of (7) and (8) then SMpt[F ] is equivalent toCIRCpt[F ] and consequently to (9).It is clear from the definition of circumscription that if sentences F and G are equivalent to each other then the formulasCIRC[F ] and CIRC[G] are equivalent to each other as well. The following example shows, on the other hand, that the operatorSM, applied to two equivalent formulas, can produce formulas that are not equivalent to each other.Example 3. Let us apply SMp to p(a) and to ¬¬p(a). (In logic programming notation the latter can be written as theconstraint ← not p(a).) It is clear that SMp[p(a)] equals CIRCp[p(a)] and is equivalent to(cid:2)∀xp(x) ↔ x = a(cid:3).On the other hand,(cid:2)¬¬p(a)(cid:3)∗ ==(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)∗(cid:3)p(a) → ⊥→ ⊥(cid:3)(cid:3)∗ → ⊥p(a) → ⊥(cid:3)∗ ∧ p(a)(cid:2)p(a) → ⊥↔ ¬(cid:2)(cid:2)(cid:3)u(a) → ⊥= ¬∧(cid:2)(cid:2)(cid:2)(cid:3)p(a) → ⊥(cid:3)→ ⊥∧(cid:3)(cid:3)p(a) → ⊥∧ p(a)↔ p(a),and consequently(cid:6)(cid:7)¬¬p(a)SMp(cid:2)(cid:3)(u < p) ∧ p(a)↔ ¬¬p(a) ∧ ¬∃u↔ p(a) ∧ ¬∃u(u < p)↔ p(a) ∧ ∀x¬p(x)↔ ⊥.Thus some equivalent transformations do not preserve the class of stable models of a formula. We will return to thisquestion in Section 5.1.The following two examples show that sometimes SM is stronger than CIRC, and sometimes weaker.Example 4. Let F be the formula(cid:3)¬p(x) → q(x)(cid:2)∀x,corresponding to the ruleq(x) ← not p(x).(11)The circumscription formula CIRCpq[F ] is equivalent to(cid:2)∀x(cid:3)¬p(x) ↔ q(x).On the other hand, using the fact that formula (11) is tight, we will show in Section 6 that SMpq[F ] can be written as(cid:2)∀x(cid:3)¬p(x) ∧ q(x).(12)Thus SMpq[F ] is stronger than CIRCpq[F ]. In any minimal model of (11), q is the negation of p; about the stable models ofthis formula we can say more: p is identically false, and q is identically true.P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263241Example 5. Let F be formula (4), which represents a choice rule, as discussed above. Since this formula is logically valid, itsp-minimal models are characterized by the condition∀x¬p(x)(“p is empty”). Using the fact that formula (4) is tight, we will show in Section 6 that the p-stable models of (4) can bedescribed, in accordance with the intuitive meaning of the choice construct, by the weaker condition(cid:2)∀x(cid:3)p(x) → q(x)(13)(“p is a subset of q”).3. Relation to other definitions of a stable modelIn this section we relate the definition of a stable model in terms of the operator SM to the original definition of a stablemodel [9] and to the generalization of that definition proposed in [8].3.1. Review of the 1988 and 2005 definitionsRecall that a signature is a set of object, function and predicate constants. A term of a signature σ is formed from objectconstants of σ and object variables using function constants of σ . We distinguish here between atoms and atomic formulas,as follows: an atom of a signature σ is an n-ary predicate constant followed by a list of n terms; atomic formulas of σ areatoms of σ , equalities between terms of σ , and the 0-place connective ⊥. First-order formulas of σ are built from atomicformulas of σ using the binary propositional connectives and quantifiers listed at the beginning of Section 2.3. For anysignature σ containing at least one object constant, an Herbrand interpretation of σ is an interpretation of σ such that (i) itsuniverse is the set of ground terms of σ , and (ii) every ground term of σ represents itself. As usual, we identify an Herbrandinterpretation with the set of ground atoms that are satisfied by it.A traditional program of a signature σ is a set of formulas of the formA1 ∧ · · · ∧ Am ∧ ¬ Am+1 ∧ · · · ∧ ¬ An → An+1(14)(n (cid:3) m (cid:3) 0), where each Ai is an atom of σ . If n = 0 then (14) is understood as A1.For any traditional program Π of a signature σ and any set X of ground atoms of σ , the reduct of Π relative to X is theset of formulas obtained from Π by• replacing each formula from Π with all its ground instances, followed by• removing all formulas (14) such that { Am+1, . . . , An} ∩ X (cid:9)= ∅, followed by• removing the conjunctive terms ¬ Am+1, . . . , ¬ An from the antecedents of the remaining formulas.The reduct of Π relative to X is a set of Horn clauses. If its least Herbrand model equals X then we say that X is a stablemodel of Π in the sense of the 1988 definition [9].The definition from [8] is applicable to arbitrary sets of propositional formulas, and, if we include in it a groundingstep, it will become applicable to arbitrary sets of quantifier-free formulas. For any set Π of quantifier-free formulas of asignature σ and any set X of ground atoms of σ , the modified reduct of Π relative to X is the set of formulas obtainedfrom Π by• replacing each formula from Π with all its ground instances, followed by• replacing, in each formula F , all maximal subformulas of F that are not satisfied by X with ⊥.If X is a minimal (relative to set inclusion) Herbrand model of the modified reduct of Π relative to X then we say that Xis a stable model of Π in the sense of the 2005 definition [8]. As shown in that paper, in application to any traditional programthe 1988 and 2005 definitions are equivalent to each other.Example 6. Signature σ consists of the object constants a, b and the unary predicate constants p, q, r; Π is(cid:4)(cid:5)p(a), p(b), q(a), p(x) ∧ ¬q(x) → r(x)X is(cid:4)(cid:5)p(a), p(b), q(a), r(b).;(15)(16)After grounding, Π becomes(cid:4)(cid:5)p(a), p(b), q(a), p(a) ∧ ¬q(a) → r(a), p(b) ∧ ¬q(b) → r(b).242P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263The reduct of Π relative to X is(cid:4)(cid:5)p(a), p(b), q(a), p(b) → r(b).The least Herbrand model of the reduct equals X . Consequently X is a stable model of Π in the sense of the 1988 definition.The modified reduct of Π relative to X is(cid:4)(cid:5)p(a), p(b), q(a), ⊥ → ⊥, p(b) ∧ ¬⊥ → r(b).Since X is a minimal model of the modified reduct, X is a stable model of Π in the sense of the 2005 definition.3.2. Relation to the new definitionTheorem 1. For any signature σ containing at least one object constant and finitely many predicate constants, any finite set Π ofquantifier-free formulas of σ , and any Herbrand interpretation X of σ , the following conditions are equivalent:• X is a stable model of Π in the sense of the 2005 definition;• X is a p-stable model of the conjunction of the universal closures of the formulas from Π , where p is the list of all predicateconstants of σ .Corollary 1. For any signature σ containing at least one object constant and finitely many predicate constants, any finite traditionalprogram Π of σ , and any Herbrand interpretation X of σ , the following conditions are equivalent:• X is a stable model of Π in the sense of the 1988 definition;• X is a p-stable model of the conjunction of the universal closures of the formulas from Π , where p is the list of all predicateconstants of σ .Example 6 (continued). The result of applying the operator SMpqr to the conjunction of the universal closures of formu-las (15) can be rewritten, using the completion method described in Section 6 below, as(cid:2)∀x(cid:3)p(x) ↔ x = a ∨ x = b(cid:2)q(x) ↔ x = a∧ ∀x(cid:2)(cid:3)r(x) ↔ p(x) ∧ ¬q(x)∧ ∀x(cid:3).(17)The stable model (16) of (15) is the only Herbrand model of this sentence.In the statement of Theorem 1, the underlying signature is assumed to contain finitely many predicate constants, and Πis supposed to consist of finitely many formulas. (The result of grounding Π can be infinite though, if the signature containsfunction constants.) The theorem shows that under these conditions the new definition of a stable model is a generalizationof the 2005 definition, and it is more general in three ways.First, it is more general syntactically: it is applicable to formulas that contain both universal and existential quantifiers,such as the “aggregate formula” (5) or the formula ∃x p(x) (“p is nonempty”). The result of applying the operator SMp tothe latter is the same as the result of applying the corresponding circumscription operator, and it is equivalent to(cid:2)(cid:3)∃x∀ yp( y) ↔ x = y(“p is a singleton”).Second, it is more general semantically: it is applicable to non-Herbrand interpretations. For instance, (17) has modelsin which some elements of the universe are not represented by any of the constants a, b. That formula has also models inwhich a and b represent the same element of the universe. In such a model, both p and q are singletons, and r is empty.Third, it allows us to distinguish between intensional predicates and the other (“extensional”) predicate symbols. This isoften useful when we want to describe the intuitive meaning of a group of rules in a precise way. For instance, the claimthat under the stable model semantics formula (7) expresses the concept of transitive closure is only valid if we treat p asextensional. (A way to express this claim without the use of extensional predicates is discussed in the next section.) See [7]for other uses of this distinction.4. Properties of SM4.1. Changing the set of intensional predicatesThe theorem below shows that making the set of intensional predicates smaller can only make the result of applying theoperator SM weaker, and that this can be compensated by adding “choice rules.” For any predicate constant p, by Choice(p)we denote the formula ∀x(p(x) ∨ ¬p(x)), where x is a list of distinct object variables. For any list p of predicate constants,Choice(p) stands for the conjunction of the formulas Choice(p) for all members p of p.P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263243Theorem 2. For any first-order formula F and any disjoint lists p, q of distinct predicate constants, the following formulas are logicallyvalid:SMpq[F ] → SMp[F ],(cid:7)F ∧ Choice(q)SMpq(cid:6)↔ SMp[F ].It follows that the class of p-stable models of a sentence F contains the class of pq-stable models of F and coincideswith the class of pq-stable models of F ∧ Choice(q).We have seen, for instance, that the condition “t is the transitive closure of p” can be expressed by applying SMt toformula (7). By Theorem 2, it follows that the same condition can be expressed by applying SMpt to the conjunction of (7)and ∀x(p(x) ∨ ¬p(x)).Thus the possibility of distinguishing between intensional and extensional predicates does not really make the conceptof a stable model more general: instead of designating a group q of predicates as extensional, we can conjoin the formulawith Choice(q).In the rest of the paper we will assume that a list p of distinct predicate constants is chosen, and its members will bereferred to as intensional predicates. The predicate constants that do not belong to p will be called extensional predicates.4.2. ConstraintsIn answer set programming, constraints—rules with the empty head, such as (3)—play an important role in view of thefact that adding a constraint to a program affects the set of its stable models in a particularly simple way: it eliminates thestable models that “violate” the constraint. The following theorem shows that sentences beginning with negation can beviewed as a counterpart of constraints in the new framework.Theorem 3. For any first-order formulas F and G, SM[F ∧ ¬G] is equivalent to SM[F ] ∧ ¬G.It follows that the stable models of a sentence of the form F ∧ ¬G can be characterized as the stable models of F thatsatisfy ¬G.For any predicate constant p, by False(p) we denote the formula ∀x¬p(x), where x is a list of distinct object variables.By False(p) we denote the conjunction of the formulas False(p) for all members p of p.Corollary 2. For any first-order formula G, SM[¬G] is equivalent to¬G ∧ False(p).Indeed, if F is (cid:12) then SM[F ∧ ¬G] is equivalent to SM[¬G], and SM[F ] is equivalent to False(p).In Section 5.1 we will show that ¬G can be replaced in these two propositions by formulas of a more general syntacticform.4.3. Trivial predicatesIn traditional theory of stable models, the predicate constants that do not occur in the heads of rules are “trivial,” in thesense that no atom containing such a predicate can belong to a stable model. Theorem 4 shows what form this idea takesin the new framework.Theorem 4. For any first-order formula F and any intensional predicate p, if every occurrence of p in F belongs to the antecedent ofan implication then the formulaSM[F ] → False(p)is logically valid.Consequently, if every occurrence of p in a sentence F belongs to the antecedent of an implication then p is identicallyfalse in every stable model of F . For instance, the only occurrence of p in (7) is in the antecedent of an implication;consequently, in all p-stable models of (7) p is identically false.Recall that an occurrence of a predicate constant (or any other expression) in a formula is called positive if the numberof implications containing that occurrence in the antecedent is even, and strictly positive if that number is 0. The condition“every occurrence of p in F belongs to the antecedent of an implication” in the statement of the theorem can be alsoexpressed by saying that F has no strictly positive occurrences of p.244P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–2635. Logic of here-and-there and strong equivalence5.1. System SQHT=As we saw in Section 2.4, two sentences that are equivalent to each other may have different stable models. Transfor-mations of formulas that preserve the class of stable models were studied in [16], for the special case when all predicateconstants are intensional. The results of that paper imply, in particular, that two sentences have the same stable modelswhenever they are intuitionistically equivalent.6 We will see that the same conclusion holds in the more general frameworkproposed in this paper, with extensional predicates allowed.Thus equivalent transformations that are sanctioned by intuitionistic logic play an important part in the study of stablemodels. In connection with Example 3 above we can note, for instance, that the “fact” p(a) and the “constraint” ¬¬p(a)are equivalent classically, but not intuitionistically; this is what makes them essentially different under the stable modelsemantics. About formula (4), representing a choice rule, we can note that it is not provable in intuitionistic logic; this iswhat makes it nontrivial, as far as stable models are concerned.The main result of [16] is actually about a class of equivalent transformations that contains more than what intuitionisticlogic accepts. The “logic of here-and-there”7 studied in that paper is intermediate between intuitionistic and classical logic.we denote intuitionistic first-order predicate logic with the usual axioms for equality: x = x and the schemaBy INT=x = y →(cid:2)(cid:3)F (x) → F ( y)for every formula F (x) such that y is substitutable for x in F (x). System SQHTwith equality”) is obtained from INTby adding the axiom schemas==(for “static quantified logic of here-and-thereF ∨ (F → G) ∨ ¬Gand(cid:2)∃x(cid:3)F (x) → ∀xF (x),and the axiomx = y ∨ x (cid:9)= y.To illustrate the difference between intuitionistic logic and the logic of here-and-there, we can note that De Morgan’s law¬(F ∧ G) ↔ ¬F ∨ ¬Gand its first-order counterpart¬∀xF (x) ↔ ∃x¬F (x)are not provable intuitionistically, but are provable in SQHT=.If the equivalence between two sentences can be proved in SQHT=then they have the same stable models. We canassert even more:Theorem 5. For any first-order formulas F and G, if the formula F ↔ G is derivable in SQHTextensional predicates q then SM[F ] is equivalent to SM[G].=from the formulas Choice(q) for theFor instance, it is easy to see that the equivalence between (4) and the formula(cid:2)∀x(cid:3)p(x) ∨ ¬p(x) ∨ ¬q(x)(18)is intuitionistically derivable from Choice(q). The p-stable models of (4) are the interpretations that interpret p as a subsetof q (Section 2.4, Example 5). It follows that the p-stable models of (18) can be characterized in the same way.Intermediate logics, such as SQHT, differ from classical logic in that they do not endorse the law of double negation¬¬F ↔ F in full generality. The following theorem identifies a class of cases when double negation elimination is admissibleunder the stable model semantics.=Theorem 6. Let Fpositive occurrences of intensional predicates then SM[F(cid:15)] is equivalent to SM[F ].(cid:15)be the formula obtained from a first-order formula F by inserting ¬¬ in front of a subformula G. If G has no strictly6 See http://plato.stanford.edu/entries/logic-intuitionistic/ for an introduction to intuitionistic logic.7 This name is related to the fact that SQHT=can be described by Kripke models with two worlds (see Appendix A.5.1), often called Here and There.P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263For instance, in a formula of the form∀xy(H → x = y)245(19)every occurrence of every predicate constant belongs to the antecedent of an implication. Consequently, inserting a doublenegation in front of (19) within any sentence will not affect the class of stable models no matter how the set of intensionalpredicates is chosen. (In the terminology of Section 5.2 below, this is a “strongly equivalent” transformation.)From Theorem 6 we can conclude that Theorem 3 and Corollary 2 can be generalized: SM[F ∧ G] is equivalent toSM[F ] ∧ G, and SM[G] is equivalent to G ∧ False(p), whenever G has no strictly positive occurrences of intensional predicates.For instance, SM[F ∧ ∀xy(H → x = y)] is equivalent to SM[F ] ∧ ∀xy(H → x = y).A generalization of Theorem 6 is presented in [7, Section 5].5.2. Strong equivalenceAbout first-order formulas F and G we say that F is strongly equivalent to G if, for any formula H , any occurrence of Fin H , and any list p of distinct predicate constants, SMp[H] is equivalent to SMp[His obtained from H byreplacing the occurrence of F by G. In this definition, H is allowed to contain object, function and predicate constants thatdo not occur in F , G; Theorem 7 below shows, however, that this is not essential. It shows also that in the definition ofstrong equivalence p can be taken to be the set pF G of all predicate constants that occur in F or G, rather than an arbitraryset of predicate constants:(cid:15)], where H(cid:15)Theorem 7. First-order formulas F and G are strongly equivalent to each other iff for any formula H such that every object, function(cid:15)],or predicate constant occurring in H occurs in F or in G, and for any occurrence of F in H , SMpF G [H] is equivalent to SMpF G [Hwhere His obtained from H by replacing the occurrence of F by G.(cid:15)It is clear that if F is strongly equivalent to G then SMp[F ] is equivalent to SMp[G] (take H to be F ). In particular, if Fis strongly equivalent to G then F is equivalent to G (take p to be empty).Strong equivalence was originally defined, in somewhat different contexts, in [15] (for propositional rules with nestedexpressions, without extensional atoms, and assuming that F occurs in H as a conjunctive term) and in [16] (no freevariables in F , G; no extensional predicates; F occurs in H as a conjunctive term). Properties of this relation are interestingfrom the perspective of ASP because they may allow us to simplify a part of a logic program without looking at the otherparts. For instance, replacing the rule p(x) ← x = a in any program with p(a) does not affect the class of stable models,because the formula(cid:2)∀x(cid:3)x = a → p(x)(20)is strongly equivalent to p(a).The main result of [16] can be extended to the new version of strong equivalence as follows:Theorem 8. First-order formulas F and G are strongly equivalent to each other iff formula F ↔ G is provable in SQHT=.For instance, to prove that (20) is strongly equivalent to p(a) we only need to observe that these formulas are intuition-istically equivalent.The definition of strong equivalence can be generalized as follows. For any list q of predicate constants, we say that F isstrongly equivalent to G excluding q if F ∧ Choice(q) is strongly equivalent to G ∧ Choice(q). It is immediate from Theorem 8that F is strongly equivalent to G excluding q iff F ↔ G is derivable in SQHTfrom the formula Choice(q). Theorem 8 isthe special case of this corollary when q is empty. Furthermore, it is clear from Theorem 5 that if F is strongly equivalentto G excluding q then SMp[F ] is equivalent to SMp[G] for any p that is disjoint from q.=An alternative characterization of strong equivalence, similar to the one proposed in [22] for the propositional case, refers∗(u) that was used in Section 2.3 to define the operator SM. In the statement of the theorem below, pF Gto the formula Fis again the list of all predicate constants that occur in F or G; q is a list of new, distinct predicate constants of the samelength as pF G .Theorem 9. F is strongly equivalent to G iff the formula(cid:2)(cid:3)(cid:2)q (cid:2) pF G→∗F(q) ↔ G∗(cid:3)(q)is logically valid.For instance, we can prove that (20) is strongly equivalent to p(a) by showing that the implication(cid:2)(cid:2)(cid:2)(cid:3)x = a → q(x)∀x(cid:2)∧x = a → p(x)(cid:3)(cid:3)(cid:3)↔ q(a)(q (cid:2) p) →is logically valid.246P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–2636. CompletionAs indicated in Section 2.4, the process of completing a logic program, invented by Keith Clark [1], allows us in manycases to rewrite SM[F ] as a first-order formula.6.1. Clark normal formThe completion process involves a series of preliminary transformations followed by the main step—replacing implica-tions by equivalences. For instance, completing program (1) can be described as follows. Step 1: in the representation (2) ofthe program in the syntax of first-order logic, we rewrite each conjunctive term as an implication with the consequent in acanonical form—a predicate constant followed by a list of distinct variables:(cid:2)∀xy(cid:3)x = a ∧ y = a → p(x, y)(cid:3)p(x, y) → q(x)(cid:2).∧ ∀xy∧ ∀xy(cid:2)(cid:3)x = a ∧ y = b → p(x, y)Step 2: we combine implications with the same predicate constant in the consequent into one:(cid:3)(x = a ∧ y = a) ∨ (x = a ∧ y = b)(cid:3)→ p(x, y)∀xy(cid:2)(cid:2)∧ ∀xy(cid:2)(cid:3)p(x, y) → q(x).Step 3: we identify, in each implication, the variables that occur in its antecedent but do not occur in the consequent, andminimize the scopes of the corresponding quantifiers:(cid:2)(cid:2)(cid:3)(x = a ∧ y = a) ∨ (x = a ∧ y = b)(cid:3)→ p(x, y)∀xy(cid:2)∧ ∀x(cid:3)∃ yp(x, y) → q(x).Step 4: we replace all implications by equivalences:∀xy(cid:2)(cid:3)p(x, y) ↔ (x = a ∧ y = a) ∨ (x = a ∧ y = b)(cid:2)(cid:3)q(x) ↔ ∃ y p(x, y)∧ ∀x.(21)(22)Steps 1–3 are intuitionistically equivalent transformations, so that formula (21) has the same stable models as the for-mula (2) that we started with. Step 4 gives us in this case, and in many others, a first-order formula equivalent to the resultof applying the operator SM.This idea can be made precise using the following definitions. About a first-order formula we will say that it is in Clarknormal form (relative to the list p of intensional predicates) if it is a conjunction of formulas of the form,(23)one for each intensional predicate p, where x is a list of distinct object variables. The completion of a formula F in Clarknormal form, denoted by Comp[F ], is obtained from it by replacing each conjunctive term (23) with(cid:2)(cid:3)G → p(x)∀x(cid:2)(cid:3)∀xp(x) ↔ G.For instance, (11) can be written in Clark normal form relative to pq as follows:(cid:3)¬p(x) → q(x)(cid:3)⊥ → p(x)(cid:2)∧ ∀x(cid:2)∀x.The completion of this formula is(cid:2)∀x(cid:3)p(x) ↔ ⊥(cid:2)(cid:3)q(x) ↔ ¬p(x)∧ ∀x.(24)(25)(26)Some formulas can be converted to Clark normal form by strongly equivalent transformations different from those describedin [1]. For instance, formula (4) is strongly equivalent tobecause F ∨ ¬G is equivalent to ¬¬G → F in SQHT=. Formula (27) is in Clark normal form relative to p. Its completion is,(27)(cid:2)(cid:3)q(x) ∧ ¬¬p(x) → p(x)∀x(cid:2)∀x(cid:3)p(x) ↔ q(x) ∧ ¬¬p(x),(28)or, equivalently, (13).We are interested in the relationship between Comp[F ] and SM[F ]. In traditional theory of stable models, every stablemodel of a logic program is an Herbrand model of its completion; the converse, however, can be asserted only undersome syntactic conditions of F , such as tightness [4,2]. Here is the counterpart of the first of these two facts in the newframework:P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263247Theorem 10. For any formula F in Clark normal form, the implicationSM[F ] → Comp[F ]is logically valid.To illustrate the fact that Comp[F ] can be weaker than SM[F ], consider the following formula, which is intuitionisticallyequivalent to (7):(cid:2)∀xyp(x, y) ∨ ∃z(cid:2)(cid:3)t(x, z) ∧ t(z, y)(cid:3)→ t(x, y).(29)It is in Clark normal form, provided that t is taken to be the only intensional predicate. Its completion is weaker than theresult of applying the operator SMt to (7)—the latter, as we know, is not expressible in first-order logic.6.2. Tight formulasWe will now define tightness for formulas in Clark normal form. In Section 7.3 this definition will be extended toarbitrary first-order formulas.We say that an occurrence of a predicate constant in a formula is negated if it belongs to a subformula of the form ¬F(that is, F → ⊥), and nonnegated otherwise.For any formula F in Clark normal form, the predicate dependency graph of F is the directed graph that• has all intensional predicates as its vertices, and• has an edge from p to q if the antecedent G of the conjunctive term (23) of F with p in the consequent has a positivenonnegated occurrence of q.We say that F is tight if the predicate dependency graph of F is acyclic.For example, (21) is tight: its predicate dependency graph has only one edge, from q to p. Formulas (25) and (27) aretight as well: their predicate dependency graphs have no edges. (The antecedent in (27) has a positive occurrence of p,but that occurrence is negated.) On the other hand, (29) is not tight: the only edge of its predicate dependency graph is aself-loop.Theorem 11. For any tight formula F in Clark normal form, SM[F ] is equivalent to the completion of F .In particular, the stable models of a tight sentence in Clark normal form can be characterized as models of its completion.This theorem shows, for instance, that the result of applying the operator SMpq to (2) is equivalent to formula (22). Sincethat formula can be equivalently rewritten as (6), we have justified the claim regarding Example 1 made in Section 2.4.Similarly, the result of applying SMpq to (11) is equivalent to (26). Since that formula can be equivalently rewrittenas (12), we have justified the claim made there regarding Example 4.Similarly, the result of applying SMp to (4) is equivalent to (28). Since that formula can be equivalently rewritten as (13),we have justified the claim made there regarding Example 5.These examples illustrate the process that sometimes allows us to rewrite SM[F ] as a first-order formula:• turn F into a tight formula in Clark normal form using strongly equivalent transformations, and• form its completion (and simplify the result).=This process can be generalized in several ways. First, translating F into a tight formula F 1 in Clark normal form canemploy transformations that are strongly equivalent excluding the extensional predicates; then the equivalence F ↔ F 1 willfrom the formulas Choice(q) for extensional predicates q, and that is enough to guarantee that SM[F ]be derivable in SQHTis equivalent to SM[F 1] (Theorem 5). Second, if we turned F into a conjunction of the form F 1 ∧ ¬G, where F 1 is in Clarknormal form, then Theorem 3 can be used to “factor out” ¬G. Finally, if F is turned into a formula in Clark normal formthat is not tight then in some cases tightness can be achieved by an additional transformation based on Theorem 6. Forinstance, the predicate dependency graph of a formula containing the conjunctive term(cid:3)→ p(x)(cid:3)p(x) → q(x)(cid:3)→ r(x)(cid:2)(cid:2)(cid:2)∀xhas a self-loop at p. But if the predicate r is extensional then that term can be replaced with(cid:3)→ p(x)(cid:3)p(x) → q(x)(cid:3)→ r(x)(cid:2)∀x¬¬(cid:2)(cid:2)without changing the class of stable models. The self-loop is eliminated.248P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–2637. Pointwise stable modelsThe pointwise circumscription operator [18] is a modification of circumscription that reflects the idea of “pointwiseminimality”: it is impossible to make the minimized predicates stronger by changing the truth value of exactly one of them atexactly one point. In this section, we define a similar modification of the operator SM and show that it is closely related tothe process of completion discussed above.87.1. Review of pointwise circumscriptionThe definition of pointwise circumscription uses the following notation. If p and q are predicate constants of the samearity k then p∃x1< q stands for the formula(cid:2)q(y) ∧ x (cid:9)= yp(y) ↔(cid:2)(cid:2)q(x) ∧ ∀y(cid:3)(cid:3)(cid:3),where x, y are disjoint tuples of distinct object variables x1, . . . , xk, y1, . . . , yk, and x (cid:9)= y is shorthand for¬(x1 = y1 ∧ · · · ∧ xk = yk).The formula pq are tuples p1, . . . , pn and q1, . . . , qn of predicate constants then p1< q expresses that the extent of p can be obtained from the extent of q by removing one element. If p and1< q stands for the disjunction(cid:9)(cid:2)(cid:8)1(cid:2)i(cid:2)n1< qipi(cid:3)∧(cid:10)1(cid:2) j(cid:2)n, j(cid:9)=i(cid:11)(p j = q j),and similarly for tuples of predicate variables.Let p be a list of distinct predicate constants. The pointwise circumscription operator with the minimized predicates p, de-noted by PCIRCp, is defined as follows: for any first-order formula F , PCIRCp[F ] stands for(cid:2)(cid:2)F ∧ ¬∃u(cid:3)1< p(cid:3)∧ F (u),uwhere u and F (u) are as in the definition of circumscription (Section 2.2). For any sentence F , a pointwise p-minimal modelof F is an interpretation of the underlying signature that satisfies PCIRCp[F ].It is clear that every minimal model is pointwise minimal. But the converse is not true. For instance, let F be p(a) ↔p(b). An interpretation that makes p true at two distinct points a, b and false in the rest of the universe is not minimal—itcan be “improved” by making p identically false. But it is pointwise minimal, because changing the value of p at one of thepoints a, b would not produce a model of F .Unlike CIRC[F ], the pointwise circumscription formula PCIRC[F ] can be equivalently rewritten without second-orderquantifiers. We will describe this process in terms of predicate expressions λxF (x), where x is a list of distinct object vari-ables, and F (x) is a formula. For any formula H(u), where u is a predicate variable, by H(λxF (x)) we denote the formulaobtained from H(u) by replacing each atomic subformula of the form u(t), where t is a tuple of terms, with F (t). Forinstance, if H(u) is u(a) ∨ u(b) then H(λx¬p(x)) stands for ¬p(a) ∨ ¬p(b).For any predicate variable v and any formula H(v), by H(cid:2)∃xv(x) ∧ Hv(y) ∧ x (cid:9)= y,(cid:2)(cid:2)λy(cid:3)(cid:3)(cid:3)(1)v (v) we denote the formulawhere x and y are disjoint lists of distinct variables. It is easy to see that this formula is equivalent to(cid:2)(cid:2)1< vu(cid:3)(cid:3)∧ H(u).∃uIndeed,∃u(cid:3)(cid:2)(cid:2)1< vu(cid:2)∃x= ∃u(cid:2)↔ ∃u∃x↔ ∃x(cid:2)(cid:3)∧ H(u)(cid:2)(cid:2)v(x) ∧ ∀yu(y) ↔(cid:2)v(x) ∧ ∀yu(y) ↔(cid:2)u(y) ↔∀y(cid:2)v(x) ∧ ∃u(cid:2)(cid:2)v(y) ∧ x (cid:9)= yv(y) ∧ x (cid:9)= y(cid:2)v(y) ∧ x (cid:9)= y(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)∧ H(u)(cid:3)∧ H(u)(cid:3)(cid:3)∧ H(u)(cid:3)(cid:3)↔ H(1)v (v).To generalize this construction to tuples of distinct predicate variables, we define H(1)v1···vn as shorthand forH(1)v1∨ · · · ∨ H(1)vn .8 In propositional case, an analogy between pointwise circumscription and completion was noted in [12].P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263249The following calculation shows that H(cid:3)(cid:2)(cid:2)(cid:3)∧ H(u)(to simplify notation, we assume that n = 2):1< v∃uu(1)v (v) is equivalent to(cid:2)(u1 = v 1) ∧(cid:2)1< v 2u2(cid:3)(cid:3)(cid:3)(cid:3)∧ H(u1, u2)∨(cid:2)(cid:2)∃u1u2(u1, u2)(cid:2)(cid:2)(cid:2)(cid:2)↔ ∃u1u2↔ ∃u1u2(cid:3)1< (v 1, v 2)(cid:3)∧ H(u1, u2)u11< v 1(cid:3)1< v 1(cid:2)(cid:2)(cid:2)u1(cid:2)(cid:2)(cid:3)(cid:3)∧ (u2 = v 2)(cid:3)∧ (u2 = v 2)(cid:2)(u1 = v 1) ∧u21< v 2(cid:3)∧ H(u1, v 2)(cid:3)∨ ∃u2(cid:3)∧ H(u1, u2)(cid:3)(cid:3)(cid:3)∧ H(u1, u2)(cid:3)(cid:2)(cid:2)1< v 2u2∨ ∃u1u2(cid:2)(cid:2)u11↔ ∃u1< v 1(1)v1 (v 1, v 2) ∨ H↔ H(1)= Hv1 v2 (v 1, v 2).(1)v2 (v 1, v 2)(cid:3)∧ H(v 1, u2)Consequently, PCIRCp[F ] is equivalent toF ∧ ¬F(1)u (p),which is a first-order formula. For instance, this translation turns(cid:6)(cid:7)p(a) ↔ p(b)PCIRCpinto the first-order formula(cid:2)(cid:3)∧ ¬∃xp(a) ↔ p(b)(cid:2)(cid:2)(cid:2)p(x) ∧p(a) ∧ x (cid:9)= a(cid:2)(cid:3)↔p(b) ∧ x (cid:9)= b(cid:3)(cid:3)(cid:3),which can be further rewritten as(cid:2)(cid:2)a (cid:9)= b ∧ ∀xp(x) ↔ x = a ∨ x = b(cid:3)(cid:3).∀x¬p(x) ∨7.2. Operator PSMThe pointwise stable model operator with the intensional predicates p, denoted by PSMp, is defined as follows: for any first-order formula F , PSMp[F ] stands forF ∧ ¬∃u(cid:2)(cid:2)(cid:3)1< p∗(cid:3)(u),∧ Fu∗(u) are as in the definition of the stable model operator (Section 2.3). For any sentence F , a pointwisewhere u and Fp-stable model of F is an interpretation of the underlying signature that satisfies PSMp[F ].Every stable model is pointwise stable, but the converse is generally not true. Furthermore, PSM[F ] is equivalent to thefirst-order formula(cid:3)(1)(cid:2)F ∧ ¬u (p).F∗We see that there is a similarity between properties of PSM and properties of completion. Indeed, for any sentence F inClark normal form, every stable model of F satisfies the completion of F (Theorem 10), but the converse is generally nottrue; the completion of F is a first-order formula. The difference is, of course, that the definition of PSM is more general—itis not limited to sentences in Clark normal form.Theorem 12(b) below shows that this is more than a similarity: PSM can be viewed as a generalization of completion.About a sentence in Clark normal form we say that it is pure if, for each of its conjunctive terms (23), G has no strictlypositive occurrences of p. For instance, every tight sentence is pure. Any formula in Clark normal form can be made pure(cid:15)using auxiliary predicates. For instance, formula (29) is not pure, but we can make it pure using the auxiliary predicate t,“synonymous” with t:(cid:2)(cid:2)(cid:3)t(x, z) ∧ t(z, y)(cid:15)(cid:3)(x, y)→ t∧ ∀xy(cid:2)t(cid:15)(cid:3)(x, y) → t(x, y).∀xyp(x, y) ∨ ∃zTheorem 12. For any formula F in Clark normal form, (a) the implicationPSM[F ] → Comp[F ]is logically valid; (b) if F is pure then PSM[F ] is equivalent to Comp[F ].When applied to a formula in Clark normal form that is not pure, PSM provides, generally, a better approximation to SMthan the completion operator.250P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–2637.3. Tight formulas revisitedAs the final comment on the concept of a pointwise stable model, we will show how to extend the tightness condi-tion from formulas in Clark normal form to arbitrary formulas so that a counterpart of Theorem 11 will hold: for a tightformula F , SM[F ] will be equivalent to PSM[F ] (and consequently equivalent to a first-order formula).A rule of a first-order formula F is a strictly positive occurrence of an implication in F . For instance, the only rule of (2)is p(x, y) → q(x). (Note that the first two conjunctive terms of (2) are not rules, according to our definition.) If F is aformula in Clark normal form then its rules are the implications G → p(x) from its conjunctive terms (23). The rules of theformula(cid:2)(cid:2)(cid:2)(cid:3)(cid:3)p(x) →(cid:2)q(x) → r(x)∨(cid:3)p( y) → q( y)(cid:3)→ r( y)arep(x) →(cid:3)(cid:2)q(x) → r(x),q(x) → r(x),(cid:2)(cid:3)p( y) → q( y)→ r( y).For any first-order formula F , the predicate dependency graph of F (relative to the list p of intensional predicates) is thedirected graph that• has all intensional predicates as its vertices, and• has an edge from p to q if, for some rule G → H of F ,· p has a strictly positive occurrence in H , and· q has a positive nonnegated occurrence in G.We say that F is tight (relative to p) if its predicate dependency graph is acyclic.In application to formulas in Clark normal form, the new definition of tightness is equivalent to the definition fromSection 6.2. But it allows us to talk, for instance, about the predicate dependency graph of formula (2) itself, withoutconverting it to Clark normal form, and say that (2) itself is tight. Incidentally, this formula and its normal form (21) havethe same predicate dependency graph, and this is a general phenomenon: strongly equivalent transformations involved inconverting a sentence to its Clark normal form do not usually change its predicate dependency graph, and consequently donot affect its tightness.Theorem 13. For any tight formula F , PSM[F ] is equivalent to SM[F ].Corollary 3. For any tight formula F , SM[F ] is equivalent to a first-order formula.8. Strong negationSome applications of answer set programming are facilitated by the use of a second kind of negation, called “strong” or“classical” [10].Strong negation can be incorporated in the framework of this paper as follows. We distinguish between intensionalpredicates of two kinds, positive and negative, and assume that each negative intensional predicate has the form ∼p, wherep is a positive intensional predicate. Under this approach to strong negation, the symbol ∼ is, syntactically, not a connective;it occurs within atomic formulas. An interpretation of the underlying signature is coherent if the extent of every negativepredicate ∼p in it is disjoint from the extent of the corresponding positive predicate p. In other words, an interpretation iscoherent if it satisfies the formula(cid:2)(cid:3)p(x) ∧ ∼p(x)¬∃x,(30)where x is a list of distinct object variables, for each negative predicate ∼p.By Theorem 3, the coherent stable models of a sentence F can be characterized as the stable model of the conjunctionof F with all formulas (30).Strong negation allows us to distinguish between two kinds of exceptions to defaults: when the default is not applicable,so that the property asserted by the default is not guaranteed to hold, and when we know that the property indeed doesnot hold. For instance, the formula(cid:2)∀x(cid:3)¬ab(x) → p(x)∧ ab(c1) ∧ ab(c2) ∧ ∼p(c2)(31)employs the “abnormality predicate” ab to express that• by default, any object is presumed to have property p,• this default is applicable neither to c1 nor to c2,• c2 does not have property p.P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263251The completion method (Section 6) can be used to characterize the stable models of this formula, with all predicate con-stants treated as intensional, by a first-order formula:(cid:2)∀x(cid:2)∀x(cid:2)∀xab(x) ↔ x = c1 ∨ x = c2(cid:3)p(x) ↔ x (cid:9)= c1 ∧ x (cid:9)= c2∼p(x) ↔ x = c2(cid:3).(cid:3)∧∧According to this formula, all objects other than c1 and c2 have property p (line 2); as to c1 and c2, it is not known whetherthe former has property p, but the latter certainly doesn’t (line 3).All stable models of (31) are coherent. But this will change if we drop the conjunctive term ab(c2) from that formula,that is to say, if we assert ∼p(c2) but do not restrict accordingly the default that leads to the opposite conclusion. Thecompletion formula will turn then into(cid:2)∀x(cid:2)∀x(cid:2)∀x(cid:3)∧ab(x) ↔ x = c1(cid:3)p(x) ↔ x (cid:9)= c1∼p(x) ↔ x = c2∧(cid:3).This sentence has no coherent models satisfying c1 (cid:9)= c2.9. Related workPropositional equilibrium logic [32] extends the stable model semantics from traditional programs to propositional for-mulas, and the definition of a stable model for first-order sentences proposed in this paper is a natural next step. It isclosely related to the extension of equilibrium logic to first-order formulas described in Appendices A.5.1 and A.5.2.Theorem 5 from [24] relates stable models of traditional programs to circumscription using a translation that introducesauxiliary predicate constants. Our approach to stable models is closer, however, to two more recent publications: [31],which shows how to express the semantics of propositional equilibrium logic by quantified Boolean formulas, and [23],which translates equilibrium logic into the logic of knowledge and justified assumptions from [21]. (An extended versionof [23] is published in this issue.)Non-Herbrand stable models, at least for traditional programs, can be defined on the basis of several characterizations ofthe stable model semantics proposed earlier, including [24,35,20].Extensional predicates are similar to input predicates in the sense of [30].10. ConclusionThe approach to stable models proposed in this paper is more general than the traditional definition because it isapplicable to syntactically complex formulas, because it covers non-Herbrand models, and because it allows us to distinguishbetween intensional and extensional predicates. Syntactically complex formulas are useful in the context of the stable modelsemantics in view of their relation to aggregates. Non-Herbrand models are related to the use of arithmetic functions in logicprograms. Extensional predicates provide a useful technical device, as discussed in [7].AcknowledgementsWe are grateful to Pedro Cabalar, Martin Gebser, Michael Gelfond, Fangzhen Lin, David Pearce and Hudson Turner foruseful discussions related to the topic of this paper. This work was partially supported by the National Science Foundationunder Grants IIS-0712113, IIS-0839821, and IIS-0916116.Appendix A. Proofs of theoremsA.1. Proof of Theorem 1Given a formula F without variables and a set X of ground atoms, by F X we denote the modified reduct of F relativeto X (Section 3.1), that is, the result of replacing all maximal subformulas of F that are not satisfied by X with ⊥. Similarnotation will be used for sets of ground formulas.Lemma 1. (See [5, Lemma 22].) X |(cid:17) F X iff X |(cid:17) F .Proof. Immediate from the definition of F X . (cid:2)Lemma 2. (See [5, Lemma 23].) (a) (F ∧ G) X is equivalent to F X ∧ G X ; (b) (F ∨ G) X is equivalent to F X ∨ G X .252P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263Proof. (a) If X satisfies F ∧ G then the formulas (F ∧ G) X and F X ∧ G X are equal to each other; otherwise, each of them isequivalent to ⊥. (b) Similar. (cid:2)The following lemma is a key to the proof of Theorem 1. It relates the modified reduct operator to the operator F (cid:18)→∗(u) introduced in Section 2.3. In the statement of the lemma,F• H(x) is a quantifier-free formula, x is the list of all its variables, and t is a list of ground terms of the same length as x;• p is the list of all predicate constants occurring in H(x), and q is a list of new predicate constants of the same lengthas p;• X is a set of ground atoms that contain a predicate constant from p, Y is a subset of X , and Yatoms obtained from Y by substituting the members of q for the corresponding members of p.pq is the set of groundLemma 3. The Herbrand interpretation Y satisfies H(t) X iff the Herbrand interpretation X ∪ Y∗(u, x) by substituting q for the predicate variables u and t for the object variables x.from Hpq satisfies the sentence H∗(q, t) obtainedProof. By induction on H .Case 2: H(x) has the form p(tCase 1: H(x) has the form t1(x) = t2(x). Then Hcorresponding to the member p of p; X ∪ Yp(t∗(q, t) is t1(t) = t2(t); X ∪ YOn the other hand, H(t) X is t1(t) = t2(t) if t1(t) equals t2(t), and ⊥ otherwise.(cid:15)(x) is a tuple of terms. Then H(cid:15)(x)), where tpq satisfies this sentence iff p(t(cid:15)(t)) if this atom belongs to X , and ⊥ otherwise. Since Y ⊆ X , Y satisfies H(t) X iff p(tCase 3: H(x) is ⊥; trivial.Case 4: H(x) is a conjunction or a disjunction; use Lemma 2.Case 5: H(x) is H1(x) → H2(x). Then H∗1(q, t) → H(cid:3)∗2(q, t)∗(q, t) isH(t) ∧H(cid:2).pq satisfies this sentence iff t1(t) equals t2(t).∗(q, t) is q(t(cid:15)(t)), where q is the member of q(cid:15)(t)) belongs to Y . On the other hand, H(t) X is(cid:15)(t)) belongs to Y .(A.1)Case 5.1: X |(cid:17) H(t). Then the Herbrand interpretation X ∪ Ypq satisfies the conjunction (A.1) iff it satisfies its second∗2(q, t). On the other hand, H(t) X is in this case H1(t) X → H2(t) X , and it remains to apply the induction∗1(q, t) → Hterm Hhypothesis.Case 5.2: X (cid:9)|(cid:17) H(t). Then X ∪ Ypq does not satisfy (A.1), and H(t) X is ⊥. (cid:2)Theorem 1. For any signature σ containing at least one object constant and finitely many predicate constants, any finite set Π ofquantifier-free formulas of σ , and any Herbrand interpretation X of σ , the following conditions are equivalent:• X is a stable model of Π in the sense of the 2005 definition;• X is a p-stable model of the conjunction of the universal closures of the formulas from Π , where p is the list of all predicateconstants of σ .Proof. Let Πg be the set of all ground instances of the formulas from Π , let x be the list of all variables occurring in Π ,and let F (x) be the conjunction of all formulas from Π . In view of Lemma 1, X is a stable model of Π in the sense of the2005 definition iff(i) X satisfies Πg , and(ii) no proper subset Y of X satisfies Π Xg .On the other hand, X is a p-stable model of ∀xF (x) iff(cid:15)(cid:15)(i(ii) X satisfies ∀xF (x), and) X does not satisfy ∃u((u < p) ∧ ∀xF∗(u, x)).It is clear that (i) is equivalent to (isatisfies all of the formulas (F (t)) X for arbitrary tuples t of ground terms. Condition (iituple of new predicate constants q: there is no proper subset Y of X such that, for every tuple t of ground terms, X ∪ Ysatisfies F). By Lemma 2(a), condition (ii) can be reformulated as follows: no proper subset Y of X) can be reformulated in terms of apq∗(q, t). By Lemma 3, it follows that (ii) is equivalent to (ii). (cid:2)(cid:15)(cid:15)(cid:15)A.2. Proof of Theorem 2Lemma 4. For any list p of predicate constants, Choice(p)∗(u) is equivalent to p (cid:2) u.Proof. (∀x(p(x) ∨ ¬p(x)))∗u(x) ∨∀x(cid:2)(cid:2)¬u(x) ∧ ¬p(x)is(cid:3)(cid:3)P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263253;p (cid:2) u is∀x(cid:2)(cid:3)p(x) → u(x).(cid:2)Theorem 2. For any first-order formula F and any disjoint lists p, q of distinct predicate constants, the following formulas are logicallyvalid:SMpq[F ] → SMp[F ],(cid:7)F ∧ Choice(q)SMpq(cid:6)↔ SMp[F ].The proof is not long, but there is a notational difficulty that we need to overcome before we can present it. The notation∗(u) introduced in Section 2.3 does not take into account the fact that the construction of this formula depends on theFchoice of the list p of intensional predicates. Since the dependence on p is essential in the proof of Theorem 2, we use herethe more elaborate notation F∗[p](u). For instance, if F is p(x) ∧ q(x) then∗[p](u)is u(x) ∧ q(x),∗[pq](u, v)is u(x) ∧ v(x).FFIt is easy to verify by induction on F that for any disjoint lists p, q of distinct predicate constants,∗[p]F(u) = F∗[pq](u, q).(A.2)Proof of Theorem 2. (i) In the notation introduced above, SMp[F ] is(cid:3)(u)(cid:2)F ∧ ¬∃u(u < p) ∧ F∗[p].By (A.2), this formula can be written also as(cid:2)F ∧ ¬∃u(u < p) ∧ F∗[pq](cid:3)(u, q),which is equivalent toF ∧ ¬∃u(cid:2)(cid:2)(cid:3)(u, q) < (p, q)∗[pq]∧ F(cid:3)(u, q).On the other hand, SMpq[F ] is(cid:2)(cid:2)(cid:3)(u, v) < (p, q)F ∧ ¬∃uv∗[pq]∧ F(cid:3)(u, v).To prove (ii), note that, by (A.2) and Lemma 4, the formula∗[pq]∗[pq](cid:2)(cid:2)(cid:3)∃uv(u, v) < (p, q)∧ F(u, v) ∧ Choice(q)(cid:3)(u, v)is equivalent to(cid:2)(cid:2)∃uv(u, v) < (p, q)(cid:3)∗[pq]∧ F(cid:3)(u, v) ∧ (q = v).It follows that it can be also equivalently rewritten as(u < p) ∧ F∗[pq](cid:3)(u, q).By (A.2), the last formula can be represented as∗[p](u < p) ∧ F(cid:3)(u).(cid:2)(cid:2)∃u(cid:2)∃uA.3. Proof of Theorem 3Lemma 5. The formula(u (cid:2) p) ∧ F∗(u) → Fis logically valid.Proof. By induction on F . (cid:2)254P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263Lemma 6. Formula(cid:2)u (cid:2) p →∗(¬F )(cid:3)(u) ↔ ¬Fis logically valid.Proof. Immediate from Lemma 5. (cid:2)Theorem 3. For any first-order formulas F and G, SM[F ∧ ¬G] is equivalent to SM[F ] ∧ ¬G.Proof. By Lemma 6,(cid:2)SMp[F ∧ ¬G] = F ∧ ¬G ∧ ¬∃u(cid:2)⇔ F ∧ ¬G ∧ ¬∃u(cid:2)⇔ F ∧ ¬∃u= SMp[F ] ∧ ¬G.(u < p) ∧ F(cid:2)∗(u < p) ∧ (F ∧ ¬G)(u < p) ∧ F(cid:3)∗(u)(u) ∧ ¬G∧ ¬G∗(cid:3)(u)(cid:3)A.4. Proof of Theorem 4Lemma 7. Assume that the set of intensional predicates is divided into two parts p, q so that every occurrence of every predicateconstant from p in F belongs to the antecedent of an implication. Then the formula(cid:2)∗F(u, q) ↔ F(cid:3)(u (cid:2) p) →is logically valid.(Lemma 6 is the special case of this assertion when F has the form ¬G, and q is empty.)Proof. By induction on F . We will consider the case when F is G → H ; the other cases are straightforward. Assume u (cid:2) p.By Lemma 5, it follows that G∗(u, q) → G; by the induction hypothesis, H∗(u, q) ↔ H . Consequently∗F(u, q) =⇔(cid:2)(cid:2)(cid:2)∗∗GG(u, q) → H(u, q) → H(cid:3)(u, q) ∨ G∧ (G → H)∗(cid:3)(cid:3)(u, q)∧ (G → H)→ H∗⇔G⇔ G → H(cid:2)= F .Theorem 4. For any first-order formula F and any intensional predicate p, if every occurrence of p in F belongs to the antecedent ofan implication then the formulaSM[F ] → False(p)is logically valid.Proof. Let q be the set of all intensional predicates other than p. The formula to be proved can be written asF ∧ ¬False(p) → ∃uv(cid:2)(cid:2)(cid:3)(u, v) < (p, q)∗∧ F(cid:3)(u, v).(A.3)Assume F ∧ ¬False(p), and take u such that u < p. By Lemma 7, it follows that F(cid:2)(cid:3)(u, q) < (p, q)∗∧ F(u, q),∗(u, q). Hencewhich implies the consequent of (A.3). (cid:2)A.5. Proofs of Theorems 5–8It is convenient to prove Theorems 7 and 8 before Theorems 5 and 6. As a preliminary step, in Lemma 9 below weextend the work on the relationship between stable models and propositional equilibrium logic described in [32] to thefirst-order case.P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263255A.5.1. Kripke semantics for SQHT=Notation: the universe of an interpretation I is denoted by |I|; for any signature σ and any set U , σ U stands for the, called names, for all ξ ∈ U as object constants. We will identifydefined by I(ξ ∗) = ξ . By σf we denote the part of σ consisting of itsextension of σ obtained by adding distinct new symbols ξ ∗an interpretation I of σ with its extension to σ |I|object and function constants.An HT-interpretation of σ is a triple I = (cid:23)I f, I h, I t(cid:24), where• I f is an interpretation of σf, and• I h, I t are sets of atomic formulas formed using predicate constants from σ and the names of elements of |I f| suchthat I h ⊆ I t.The symbols h (“here”) and t (“there”) are called worlds; they are ordered by the relation h < t. The value that I f assignsto a ground term t of signature σfThe satisfaction relation |(cid:17)htis defined recursively:|If|will be denoted by tI.between an HT-interpretation I, a world w, and a first-order sentence F of the signature σ |If|,htht• I, w |(cid:17)• I, w |(cid:17)• I, w (cid:9)|(cid:17)• I, w |(cid:17)• I, w |(cid:17)• I, w |(cid:17)hthththtII1 )∗, . . . , (tk )∗) ∈ I w ;I1= tp(t1, . . . , tk) if p((tIt1 = t2 if t2 ;⊥;F and I, w |(cid:17)F ∧ G if I, w |(cid:17)htF ∨ G if I, w |(cid:17)F or I, w |(cid:17)G;(cid:15)such that w (cid:2) wF → G if, for every world wG;hththt(cid:15),I, w(cid:15) (cid:9)|(cid:17)htFor I, w(cid:15) |(cid:17)htG;• I, w |(cid:17)• I, w |(cid:17)htht∀xF (x) if, for each ξ ∈ |I f|, I, w |(cid:17)∃xF (x) if, for some ξ ∈ |I f|, I, w |(cid:17)htF (ξ ∗);F (ξ ∗).htWe say that I satisfies F , and write I |(cid:17)I, t |(cid:17)F .htht=F , if I, h |(cid:17)htF . It is easy to check by induction on F that this condition impliesAs shown in [16], system SQHTtence F is derivable from Γ in SQHTis sound and complete relative to this semantics: for any set Γ of sentences, a sen-=iff F is satisfied by every HT-interpretation that satisfies all formulas from Γ .An interpretation I (in the sense of classical logic) of a signature σ can be represented as a pair (cid:23) J , X(cid:24), where J is therestriction of I to σ f , and X is the set of the atomic formulas, formed using predicate constants from σ and the namesof elements of |I|, which are satisfied by I . The lemma below uses this notation to describe the relationship between the∗(u) introduced in Section 2.3. We assume that σsatisfiability relation for HT-interpretations and the transformation F (cid:18)→ Fcontains finitely many predicate constants, and the list of these constants is denoted by p. By σ +we denote the signatureobtained from σ by adding new predicate constants q, one per each member of p. About an atomic formula formed usinga predicate constant from σ +and names of elements of |I| we say that it is a p-atom if its predicate constant belongs topq the set of the q-atomsp, and that it is a q-atom otherwise. As in Appendix A.1, for any set X of p-atoms we denote by Xthat are obtained from the elements of X by replacing their predicate constants by the corresponding predicate constantsfrom q.Lemma 8. For any HT-interpretation I and any first-order sentence F of the signature σ |If|,(i) I, t |(cid:17)(ii) I, h |(cid:17)htF iff (cid:23)I f, I t(cid:24) |(cid:17) F iff (cid:23)I f, (I h)pq∗(q).F iff (cid:23)I f, (I h)pq∪ I t(cid:24) |(cid:17) Fht∪ I t(cid:24) |(cid:17) F ;Proof. Each part is easy to check by induction on the size of F . Consider, for instance, the proof of (ii) for the case ofimplication. We will write I for (cid:23)I f, (I h)pq∪ I t(cid:24). By the induction hypothesis,I, h |(cid:17)I, h |(cid:17)hthtFiffG iffI |(cid:17) FI |(cid:17) G∗(q),∗(q).By part (i) of the lemma,I, t |(cid:17)I, t |(cid:17)hthtFiffG iffI |(cid:17) F ,I |(cid:17) G.256P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263Consequently(cid:7)(cid:7)(q)(cid:6)andI, t (cid:9)|(cid:17)F or I, t |(cid:17)and [I (cid:9)|(cid:17) F or I |(cid:17) G]htht(cid:7)GhtiffiffI, h |(cid:17)F → G(cid:6)htI, h (cid:9)|(cid:17)F or I, h |(cid:17)G(cid:6)ht∗∗I (cid:9)|(cid:17) F(q) or I |(cid:17) G∗I |(cid:17) F(q) → G(cid:2)∗I |(cid:17)(q) → GF∗I |(cid:17) (F → G)(q).iffiffiff∗(cid:3)(q)(q) and I |(cid:17) F → G∗∧ (F → G)(cid:2)A.5.2. First-order equilibrium logic and stable modelsAn HT-interpretation (cid:23)I f, I h, I t(cid:24) is total if I h = I t. A total HT-interpretation (cid:23)I, X, X(cid:24) is an equilibrium model of a sen-tence F of the signature σ |I|if(i) (cid:23)I, X, X(cid:24) |(cid:17)(ii) for any proper subset Y of X , (cid:23)I, Y , X(cid:24) (cid:9)|(cid:17)F , andhthtF .It is easy to check by induction on F that condition (i) above is equivalent to (cid:23)I, X(cid:24) |(cid:17) F .In the following lemma, σ is a signature containing finitely many predicate constants.Lemma 9. For any total HT-interpretation (cid:23)I, X, X(cid:24) of σ and any first-order sentence F of σ |I|iff (cid:23)I, X(cid:24) is a p-stable model of F , where p is the list of all predicate constants of σ ., (cid:23)I, X, X(cid:24) is an equilibrium model of FProof. From Lemma 8(ii) we conclude that condition (ii) from the definition of an equilibrium model can be reformulatedas follows: for any proper subset Y of X ,I, Ypq∪ X∗(cid:9)|(cid:17) F(q).(cid:12)(cid:12)(cid:13)(cid:13)I, Ypq∪ X|(cid:17) (q < p) ∧ F∗(q),This is equivalent to saying that there is no set Y of p-atoms such thatand consequently equivalent to the condition(cid:2)(cid:23)I, X(cid:24) |(cid:17) ¬∃u(u < p) ∧ F∗(cid:3)(u).It follows that (cid:23)I, X, X(cid:24) is an equilibrium model of F iff(cid:2)(cid:23)I, X(cid:24) |(cid:17) F ∧ ¬∃u(u < p) ∧ F∗(cid:3)(u).(cid:2)A.5.3. Proof of Theorems 7 and 8The assertions of Theorems 7 and 8 (Section 5.2) can be jointly reformulated as follows:For any first-order formulas F and G, the following conditions are equivalent:(i) F is strongly equivalent to G,(ii) for any formula H such that every object, function or predicate constant occurring in H occurs in F or in G, and for any occurrenceof F in H , SMpF G [H] is equivalent to SMpF G [H=(iii) formula F ↔ G is provable in SQHT.(cid:15)], where H(cid:15)is obtained from H by replacing the occurrence of F by G,The proof repeats, with minor modifications, the argument from [16].From (i) to (ii): Obvious.From (ii) to (iii): By x we will denote the list of variables that are free in F or in G, and we will write F as F (x), and Gas G(x). Our goal is to show that F (x) ↔ G(x) is provable in SQHT. Without loss of generality, we can assume that everypredicate constant in the underlying signature σ belongs to pF G . Take an HT-interpretation I and a tuple c of names of thesame length as x. We need to show that I satisfies F (c) iff I satisfies G(c). Assume, for instance, that I |(cid:17)F (c), and denotethe formula Choice(pF G ) by C . Case 1: I is total. By (ii),=htSMpF GF (x) ∧ Cis equivalent to SMpF G(cid:7)(cid:6)G(x) ∧ C(cid:7),and consequentlySMpF GF (c) ∧ C(cid:7)is equivalent to SMpF G(cid:6)G(c) ∧ C(cid:7).(cid:6)(cid:6)By Lemma 9, it follows that the sentencesP. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263257F (c) ∧ C, G(c) ∧ C(A.4)have the same equilibrium models. Since I is total and satisfies F (c), I is an equilibrium model of the first of the formu-G(c). Case 2: I is not total. Let J be the totallas (A.4). Consequently, it is an equilibrium model of the second, so that I |(cid:17)HT-interpretation (cid:23)I f, I t, I t(cid:24). From the assumption I |(cid:17)F (c), and, by Lemma 8(i), thatJ |(cid:17)htF (c). Furthermore, by reasoning as in Case 1 with J in place of I, we conclude that J |(cid:17)F (c) we can conclude that I, t |(cid:17)G(c). By (ii),hthththt(cid:2)(cid:3)(cid:7)SMpF GF (x) ∧G(x) → Cis equivalent toSMpF Gand consequentlyG(x) ∧SMpF GF (c) ∧is equivalent toSMpF GG(c) ∧(cid:2)G(x) → C(cid:3)(cid:7),(cid:2)G(c) → C(cid:2)G(c) → C(cid:3)(cid:7)(cid:3)(cid:7).(cid:6)(cid:6)(cid:6)(cid:6)By Lemma 9, it follows that the sentencesG(c) → C, G(c) ∧F (c) ∧(cid:3)(cid:2)(cid:2)G(c) → C(cid:3)(A.5)have the same equilibrium models. The latter can be rewritten asG(c) ∧ C.(A.6)Since J is a total HT-interpretation satisfying G(c), it is an equilibrium model of (A.6). Consequently, J is an equilibriummodel of the first of the formulas (A.5). Hence that formula is not satisfied by I. Since its first conjunctive term F (c) issatisfied by I, we conclude that I does not satisfy the second term G(c) → C . Since I, t |(cid:17)C , this is only possible whenI, h |(cid:17)ht(cid:15)as H(cid:15)(x). Our goal is to show that SMp[H(x)] is equivalent to SMp[Hbe obtained from H by replacing an occurrence of F by G, and let p be a list of predicate, and we will write Hconstants. We will denote by x the list of variables that are free in at least one of the formulas H , H(cid:15)(x)]. Without loss of generality weas H(x), and H(cid:15)(x), so that the set of predicatecan assume that every predicate constant in the underlying signature σ occurs in H(x) or Hconstants in σ is finite. Let q be the list of predicate constants from σ that do not belong to p. By Theorem 2, it is sufficient(cid:15)(x) ∧ Choice(q)] is equivalent to SMpq[H(x) ∧ Choice(q)]. Take an interpretation (cid:23)I, X(cid:24) of σ and ato prove that SMpq[H(cid:15)(c) ∧ Choice(q) and H(c) ∧ Choice(q) have the sametuple c of names, of the same length as x. We need to show that Hpq-stable models. By Lemma 9, this is equivalent to saying that these two sentences have the same equilibrium models. It, and consequently these sentencesremains to note that the equivalence between these two sentences is provable in SQHTare satisfied by the same HT-interpretations. (cid:2)=(cid:15)G(c), that is, I |(cid:17)From (iii) to (i): Let HG(c).(cid:15)hthtA.5.4. Proof of Theorem 5Theorem 5. For any first-order formulas F and G, if the formula F ↔ G is derivable in SQHTextensional predicates q then SM[F ] is equivalent to SM[G].=from the formulas Choice(q) for theProof. Let p be the list of intensional predicates, and let q be the list of all other predicate constants occurring in F or in G.=Since F ↔ G is derivable in SQHTfrom Choice(q), the formulaF ∧ Choice(q) ↔ G ∧ Choice(q)=. By Theorem 8, it follows that the left-hand side is strongly equivalent to the right-hand side. It followsis provable in SQHTthat SMpq[F ∧ Choice(q)] is equivalent to SMpq[G ∧ Choice(q)]. By Theorem 2, we can conclude that SMp[F ] is equivalent toSMp[G]. (cid:2)A.5.5. Proof of Theorem 6Lemma 10. If a formula G has no strictly positive occurrences of predicate constants from a list p then G ↔ ¬¬G is derivable inSQHTfrom the formulas Choice(q) for the predicate constants q that occur in G but do not belong to p.=Proof. By induction on G, using the fact that the equivalences¬¬(F ∧ G) ↔ ¬¬F ∧ ¬¬G,¬¬(F ∨ G) ↔ ¬¬F ∨ ¬¬G,¬¬(F → G) ↔ F → ¬¬Gare provable in SQHT=. (cid:2)258P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263Theorem 6. Let Fpositive occurrences of intensional predicates then SM[F(cid:15)] is equivalent to SM[F ].(cid:15)be the formula obtained from a first-order formula F by inserting ¬¬ in front of a subformula G. If G has no strictlyProof. Immediate from Lemma 10 and Theorem 5. (cid:2)A.6. Proof of Theorem 9Theorem 9. F is strongly equivalent to G iff the formula(cid:2)(cid:3)(cid:2)q (cid:2) pF G→∗F(q) ↔ G∗(cid:3)(q)(A.7)is logically valid.Proof. Without loss of generality, we can assume that every predicate constant in the underlying signature σ belongs∗(q)to pF G . By x we will denote the list of variables that are free in F or in G, and we will write F as F (x), G as G(x), Fas F∗(q, x), and pF G as p.∗(q) as G∗(q, x), GBy Theorem 8, the conditionF (x) is strongly equivalent to G(x)is equivalent to the condition=F (x) ↔ G(x) is provable in SQHT.It can be further reformulated as follows:for any HT-interpretation (cid:23)I, Y , X(cid:24)and for any tuple c of names of the same length as x,(cid:23)I, Y , X(cid:24) |(cid:17)htF (c)iff(cid:23)I, Y , X(cid:24) |(cid:17)htG(c).By Lemma 8(ii), the last line can be equivalently rewritten as(cid:12)(cid:13)(cid:12)(cid:13)I, Ypq∪ X∗|(cid:17) F(q, c)iffI, Ypq∪ X∗|(cid:17) G(q, c).Consequently F (x) is strongly equivalent to G(x) ifffor any interpretation I of σ f , any sets X and Y of p-atoms,and any tuple c of names of the same length as x,(cid:12)∗(cid:12)(cid:13)(cid:13)|(cid:17) q (cid:2) p ∧ F(q, c)iffI, Ypq∪ XI, Ypq∪ X|(cid:17) q (cid:2) p ∧ G∗(q, c).This condition is equivalent to the logical validity of (A.7). (cid:2)A.7. Proof of Theorems 10 and 12Theorem 10 follows from part (a) of Theorem 12, so that we only need to prove the latter. Let the intensional predicatesbe p1, . . . , pn. By ei(xi) we denote the tuplep1, . . . , pi−1, λyipi∧ yi (cid:9)= xi(cid:2)(cid:2)(cid:3)yi(cid:3), pi+1, . . . , pn,where yi is a tuple of new distinct variables.Lemma 11. For any formula F , the implications(cid:2)∗(cid:2)xieiF(cid:3)(cid:3)→ F(i = 1, . . . , n)are logically valid.Proof. Immediate from Lemma 5. (cid:2)Lemma 12. If a formula F does not contain strictly positive occurrences of pi then F∗(ei(xi)) is equivalent to F .P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263259Proof. Immediate from Lemma 7 with pi as p. (cid:2)Recall that a formula in Clark normal form can be written as(cid:2)∀xin(cid:10)i=1G i → pi(cid:3)(cid:3)(cid:2)xi,where each xi is a list of distinct variables.Lemma 13. If F is (A.8) then PSM[F ] is equivalent toF ∧n(cid:10)i=1(cid:3)(cid:2)(cid:2)pixi∀xi→ G(cid:2)(cid:2)∗ieixi(cid:3)(cid:3)(cid:3).Proof. As discussed in Section 7.2, PSM[F ] is equivalent to the first-order formula(cid:2)F ∧ ¬F∗(cid:3)(1)u (p).Formula (F(cid:8)(cid:2)∗)(1)u (p) can be written as(cid:3)(cid:3)(cid:3)(cid:3)(cid:2)∗.∧ Fxixiei(cid:2)(cid:3)(cid:2)(cid:2)∃xipiiConsequently, PSM[F ] can be equivalently rewritten as(cid:10)F ∧(cid:3)(cid:2)(cid:2)pixi∀xi→ ¬F(cid:3)(cid:3)(cid:3)(cid:2)∗(cid:2)xiei.iTo prove the assertion of the lemma, it remains to derive the equivalence between(cid:2)(cid:2)(cid:3)(cid:3)eixi∗¬Fand(cid:3)(cid:3)(cid:2)(cid:2)eixiG∗ifrom assumption F .Formula F(cid:2)∀y jG∗(u) can be rewritten, under assumption F , as the conjunction of the formulas∗j (u) → u jy j(cid:3)(cid:3)(cid:2)(A.8)(A.9)(A.10)j = 1, . . . , n. The j-th term of the tuple ei(xi) is λyi(pi(yi) ∧ yi (cid:9)= xi) if j = i, and p j otherwise. Consequently, thefor allj-th conjunctive term of F(cid:2)(cid:2)(cid:3)(cid:3)(cid:2)(cid:2)∗(ei(xi)) is(cid:3)(cid:2)∀yiG∗ieixi→piyi∧ yi (cid:9)= xi(cid:3)(cid:3),if j = i, and(cid:2)∀y jG(cid:3)(cid:3)(cid:2)(cid:2)∗jeixi(cid:3)(cid:3)(cid:2)y j→ p jotherwise. Lemma 11 shows that in the presence of the conjunctive term(cid:2)(cid:2)(cid:3)(cid:3)∀y jG j → p jy jof F , the conjunctive term (A.11) of F(cid:2)G∗i(cid:2)(cid:2)(cid:3)(cid:3)eixi∀yi(cid:3)→ yi (cid:9)= xi,∗(ei(xi)) can be rewritten asand the other conjunctive terms (A.12) can be dropped altogether. We conclude that formula (A.9) can be written as¬∀yi(cid:2)G∗i(cid:2)(cid:2)(cid:3)(cid:3)eixi(cid:3)→ yi (cid:9)= xi,which is equivalent to(cid:3)(cid:3)(cid:2)(cid:2)(cid:2)∃yiG∗ieixi∧ yi = xi(cid:3),and consequently to (A.10). (cid:2)(A.11)(A.12)(A.13)(A.14)260P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263Theorem 12. For any formula F in Clark normal form, (a) the implicationPSM[F ] → Comp[F ]is logically valid; (b) if F is pure then PSM[F ] is equivalent to Comp[F ].Proof. If F is (A.8) then Comp[F ] is equivalent to(cid:3)(cid:10)(cid:3)(cid:2)F ∧∀xipi→ G i(cid:2)xi.(A.15)i(cid:10)On the other hand, by Lemma 13, PSM[F ] is equivalent toF ∧(cid:2)(cid:3)(cid:2)xipi∀xi(cid:2)(cid:2)(cid:3)(cid:3)(cid:3).xiei→ G∗iiClaim (a) follows by Lemma 11. To prove claim (b), note that when F is pure then GLemma 12. (cid:2)∗i (ei(xi)) is equivalent to G i byA.8. Proofs of Theorems 11 and 13Since every tight program is pure, Theorem 11 follows from Theorem 12(b) and Theorem 13. Consequently we only needto prove Theorem 13.In the following lemma, F is a first-order formula, p is the list of intensional predicates p1, . . . , pn, and u is a tuple ofdistinct predicate variables u1, . . . , un.Lemma 14. Let S be the set of i’s such that pi has a strictly positive occurrence in F . The formula(cid:9)(cid:10)(u (cid:2) p) ∧(ui = pi)(cid:11)(cid:2)→F ↔ F∗(cid:3)(u)i∈Sis logically valid.Proof. By induction on F . We will consider the case when F is G → H ; the other cases are straightforward. It is sufficientto derive the implication(G → H) →(u) → H(cid:3)(u)(A.16)G(cid:2)∗∗from the assumption(cid:10)(u (cid:2) p) ∧(ui = pi).i∈S(A.17)Since every i such that pi has a strictly positive occurrence in H belongs to S, it follows from the induction hypothesis thatthe implication(cid:9)(cid:11)(cid:10)(u (cid:2) p) ∧(ui = pi)(cid:2)→H ↔ H∗(cid:3)(u)i∈Sis logically valid. By Lemma 5, the implication(u) → G(u (cid:2) p) ∧ G∗(A.18)(A.19)is logically valid also. It remains to observe that (A.16) is a propositional consequence of (A.17), (A.18), and (A.19). (cid:2)Recall that an occurrence of a predicate constant in a formula is called positive if the number of implications containingthat occurrence in the antecedent is even (Section 4.3); if that number is odd then the occurrence is negative. Negativeoccurrences should be distinguished from negated occurrences—those belonging to a subformula of the form F → ⊥ (Sec-tion 6.2). In the following lemmas, v is a tuple of distinct predicate variables disjoint from u.be the set of i’s such that pi has a positive nonnegated occurrence in F , and let S−be the set of i’s such that pi has+Lemma 15. Let Sa negative nonnegated occurrence in F . The formulas(cid:14)(cid:14)(a) ((u (cid:2) v) ∧ (v (cid:2) p) ∧(b) ((u (cid:2) v) ∧ (v (cid:2) p) ∧i∈S+ (ui = pi)) → (Fi∈S− (ui = pi)) → (F∗(v) → F∗(u) → F∗(u)),∗(v))are logically valid.P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263261Proof. Both parts are proved simultaneously by induction on F . We will only consider the proof of (a) in the case when Fis an implication G → H . Case 1: H is ⊥, so that F is ¬G. By Lemma 6, the formulasu (cid:2) p →v (cid:2) p →(cid:2)(cid:2)FF∗∗(u) ↔ F(cid:3)(v) ↔ F(cid:3),are logically valid. Consequently formula (a) is logically valid also. Case 2: H is different from ⊥. Then each pi that has anonnegated occurrence in G or H has a nonnegated occurrence in F as well. Denote the antecedent of (a) by Ant; then (a)can be written asAnt →(u) → H(v) → H(A.20)F ∧F ∧(u)(v)(cid:3)(cid:3)(cid:3)→(cid:3)(cid:3)(cid:2)(cid:2)GG(cid:2)(cid:2)(cid:2)∗∗∗∗.By part (b) of the induction hypothesis applied to G, the formula(cid:2)(cid:2)Ant →∗G(u) → G∗Ant →∗H(v) → H∗(cid:3)(v)(cid:3)(u)is logically valid. By part (a) of the induction hypothesis applied to H , the formulais logically valid. It remains to observe that (A.20) is a propositional consequence of (A.21) and (A.22). (cid:2)(cid:9)Lemma 16. Let D be the set of edges of the predicate dependency graph of F . The formula(cid:3)(v)(u (cid:2) v) ∧ (v (cid:2) p) ∧(u j = p j ∨ v i = pi)(u) → F(cid:10)→(cid:11)(cid:2)F∗∗is logically valid.i, j: (pi ,p j )∈DProof. By induction on F . We will only consider the case when F is an implication G → H . Let Ant be the antecedent(u (cid:2) v) ∧ (v (cid:2) p) ∧(u j = p j ∨ v i = pi)(cid:10)i, j: (pi ,p j )∈Dof the formula in question, and let S be the set of i’s such that pi has a strictly positive occurrence in F . It is sufficient toestablish the logical validity of the formulas(A.21)(A.22)(A.23)(A.24)(cid:9)(cid:9)Ant ∧(cid:10)i∈Sv i = pi(cid:2)→∗F(u) → F∗(cid:3)(v)and(Ant ∧ v i (cid:9)= pi) →(cid:2)∗F(u) → F∗(cid:3)(v)(i ∈ S).From Lemma 14 we conclude that the formulaAnt ∧(cid:10)i∈Sv i = pi(cid:2)→F ↔ F∗(cid:3)(v)(cid:11)(cid:11)is logically valid; (A.23) is a propositional consequence of this formula, in view of the fact that F is a conjunctive term of∗(u). Formula (A.24) is a propositional consequence ofF∗(cid:3)(cid:3)(cid:2)(cid:2)(cid:2)∗∗∗(Ant ∧ v i (cid:9)= pi) →G(u) → H→G(v) → H(v),(cid:3)(u)(A.25)so that the proof will be completed if we establish the logical validity of the latter for each i ∈ S.Note first that every edge of the dependency graph of H is an edge of the dependency graph of F . Consequently theinduction hypothesis implies that the formula(u) → H(cid:3)(v)Ant →H(cid:2)∗∗(A.26)is logically valid. Furthermore, it is clear from the definition of Ant that the formulais a tautology. Let Spredicate dependency graph, (pi, p j) ∈ D whenever i ∈ S and j ∈ S+be the set of j’s such that p j has a positive nonnegated occurrence in G. By the definition of the. Consequently(Ant ∧ v i (cid:9)= pi) →u j = p j(cid:10)j: (pi ,p j )∈D+(Ant ∧ v i (cid:9)= pi) →u j = p j(cid:10)j∈S+262P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263is a tautology also. In view of Lemma 15(a), it follows that the formula(Ant ∧ v i (cid:9)= pi) →∗G(v) → G∗(cid:2)(cid:3)(u)(A.27)is logically valid. It remains to observe that (A.25) is a propositional consequence of (A.26) and (A.27). (cid:2)Theorem 13. For any tight formula F , PSM[F ] is equivalent to SM[F ].(cid:10)Proof. We only need to prove the implication left-to-right. Since F is tight, we can assume without loss of generalitythat the members p1, . . . , pn of p are ordered in such a way that i < j for all edges (pi, p j) of the dependency graph∗(u). Let m be the largest i such that ui (cid:9)= pi . Take x such thatof F . Assume PSM[F ] and u < p; we need to derive ¬Fpm(x) ∧ ¬um(x). Choose v as follows: v i is λy(pi(y) ∧ x (cid:9)= y) if i = m, and pi otherwise. Then(u (cid:2) v) ∧ (v (cid:2) p) ∧(u j = p j ∨ v i = pi).(A.28)i, j: (pi ,p j )∈DIndeed, the conjunctive terms u (cid:2) v and v (cid:2) p are immediate, as well as the second disjunctive term of u j = p j ∨ v i = pifor any i different from m. Any j such that (pm, p j) ∈ D is greater than m; by the choice of m, we get the first disjunctiveterm u j = p j . From (A.28) and the formula from Lemma 16,∗F(u) → F∗(v).On the other hand, v1< p, so that, in view of PSM[F ], we can conclude that ¬F∗(v). Consequently ¬F∗(u). (cid:2)References[1] Keith Clark, Negation as failure, in: Herve Gallaire, Jack Minker (Eds.), Logic and Data Bases, Plenum Press, New York, 1978, pp. 293–322.[2] Esra Erdem, Vladimir Lifschitz, Tight logic programs, Theory and Practice of Logic Programming 3 (2003) 499–518.[3] Wolfgang Faber, Nicola Leone, Gerald Pfeifer, Recursive aggregates in disjunctive logic programs: Semantics and complexity,9 in: Proceedings of Euro-pean Conference on Logics in Artificial Intelligence (JELIA), 2004[4] François Fages, Consistency of Clark’s completion and existence of stable models, Journal of Methods of Logic in Computer Science 1 (1994) 51–60.[5] Paolo Ferraris, Vladimir Lifschitz, Mathematical foundations of answer set programming, in: We Will Show Them! Essays in Honour of Dov Gabbay,King’s College Publications, 2005, pp. 615–664.[6] Paolo Ferraris, Joohyung Lee, Vladimir Lifschitz, A new perspective on stable models, in: Proceedings of International Joint Conference on ArtificialIntelligence (IJCAI), 2007, pp. 372–379.[7] Paolo Ferraris, Joohyung Lee, Vladimir Lifschitz, Ravi Palla, Symmetric splitting in the general theory of stable models, in: Proceedings of InternationalJoint Conference on Artificial Intelligence (IJCAI), 2009, pp. 797–803.[8] Paolo Ferraris, Answer sets for propositional theories, in: Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning(LPNMR), 2005, pp. 119–131.[9] Michael Gelfond, Vladimir Lifschitz, The stable model semantics for logic programming, in: Robert Kowalski, Kenneth Bowen (Eds.), Proceedings ofInternational Logic Programming Conference and Symposium, MIT Press, 1988, pp. 1070–1080.[10] Michael Gelfond, Vladimir Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (1991) 365–385.[11] Carla P. Gomes, Henry Kautz, Ashish Sabharwal, Bart Selman, Satisfiability solvers, in: Frank van Harmelen, Vladimir Lifschitz, Bruce Porter (Eds.),Handbook of Knowledge Representation, Elsevier, 2008, pp. 89–134.[12] Joohyung Lee, Fangzhen Lin, Loop formulas for circumscription, Artificial Intelligence 170 (2) (2006) 160–185.[13] Joohyung Lee, Yunsong Meng, On loop formulas with variables, in: Proceedings of the International Conference on Knowledge Representation andReasoning (KR), 2008, pp. 444–453.[14] Joohyung Lee, Vladimir Lifschitz, Ravi Palla, A reductive semantics for counting and choice in answer set programming, in: Proceedings of the AAAIConference on Artificial Intelligence (AAAI), 2008, pp. 472–479.[15] Vladimir Lifschitz, David Pearce, Agustin Valverde, Strongly equivalent logic programs, ACM Transactions on Computational Logic 2 (2001) 526–541.[16] Vladimir Lifschitz, David Pearce, Agustin Valverde, A characterization of strong equivalence for logic programs with variables, in: Proceedings of Inter-national Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 2007.[17] Vladimir Lifschitz, Computing circumscription, in: Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), 1985, pp. 121–127.[18] Vladimir Lifschitz, Pointwise circumscription, in: Matthew Ginsberg (Ed.), Readings in Nonmonotonic Reasoning, Morgan Kaufmann, San Mateo, CA,1987, pp. 179–193.[19] Vladimir Lifschitz, Twelve definitions of a stable model, in: Proceedings of International Conference on Logic Programming (ICLP), 2008, pp. 37–51.[20] Fangzhen Lin, Raymond Reiter, Rules as actions: A situation calculus semantics for logic programs, Journal of Logic Programming 31 (1997) 299–330.[21] Fangzhen Lin, Shoham Yoav, A logic of knowledge and justified assumptions, Artificial Intelligence 57 (1992) 271–289.[22] Fangzhen Lin, Yuting Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, in: Proceedings of National Conference on ArtificialIntelligence (AAAI), MIT Press, 2002, pp. 112–117.[23] Fangzhen Lin, Yi Zhou, From answer set logic programming to circumscription via logic of GK, in: Proceedings of International Joint Conference onArtificial Intelligence (IJCAI), 2007.[24] Fangzhen Lin, A study of nonmonotonic reasoning, PhD thesis, Stanford University, 1991.[25] Victor Marek, Mirosław Truszczy ´nski, Stable models and an alternative logic programming paradigm, in: The Logic Programming Paradigm: A 25-YearPerspective, Springer-Verlag, 1999, pp. 375–398.[26] John McCarthy, Circumscription—a form of non-monotonic reasoning, Artificial Intelligence 13 (1980) 27–39, 171–172.[27] John McCarthy, Applications of circumscription to formalizing common sense knowledge, Artificial Intelligence 26 (3) (1986) 89–116.9 Revised version: http://www.wfaber.com/research/papers/jelia2004.pdf.P. Ferraris et al. / Artificial Intelligence 175 (2011) 236–263263[28] Robert Moore, Semantical considerations on nonmonotonic logic, Artificial Intelligence 25 (1) (1985) 75–94.[29] Ilkka Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Annals of Mathematics and Artificial Intelligence 25(1999) 241–273.[30] Emilia Oikarinen, Tomi Janhunen, Achieving compositionality of the stable model semantics for Smodels programs, Theory and Practice of Logic Pro-gramming 5–6 (2008) 717–761.[31] David Pearce, Hans Tompits, Stefan Woltran, Encodings for equilibrium logic and logic programs with nested expressions, in: Proceedings of PortugueseConference on Artificial Intelligence (EPIA), 2001, pp. 306–320.[32] David Pearce, A new logical characterization of stable models and answer sets, in: Jürgen Dix, Luis Pereira, Teodor Przymusinski (Eds.), Non-MonotonicExtensions of Logic Programming, in: Lecture Notes in Artificial Intelligence, vol. 1216, Springer-Verlag, 1997, pp. 57–70.[33] Raymond Reiter, A logic for default reasoning, Artificial Intelligence 13 (1980) 81–132.[34] Patrik Simons, Ilkka Niemelä, Timo Soininen, Extending and implementing the stable model semantics, Artificial Intelligence 138 (2002) 181–234.[35] Mark Wallace, Tight, consistent and computable completions for unrestricted logic programs, Journal of Logic Programming 15 (1993) 243–273.