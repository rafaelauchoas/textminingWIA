Artificial Intelligence 175 (2011) 2170–2197Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintFoundations of instance level updates in expressive description logicsHongkai Liu a, Carsten Lutz b, Maja Miliˇci ´c c, Frank Wolter d,∗a Institut für Theoretische Informatik, TU Dresden, Germanyb Fachbereich Informatik, Universität Bremen, Germanyc School of Computer Science, The University of Manchester, UKd Department of Computer Science, University of Liverpool, UKa r t i c l ei n f oa b s t r a c tArticle history:Received 9 July 2010Received in revised form 25 June 2011Accepted 14 August 2011Available online 23 August 2011Keywords:Description logicsABoxesUpdates1. IntroductionIn description logic (DL), ABoxes are used for describing the state of affairs in an applicationdomain. We consider the problem of updating ABoxes when the state changes, assumingthat update information is described at an atomic level, i.e., in terms of possibly negatedABox assertions that involve only atomic concepts and roles. We analyze such basic ABoxupdates in several standard DLs, in particular addressing questions of expressibility andsuccinctness: can updated ABoxes always be expressed in the DL in which the originalABox was formulated and, if so, what is the size of the updated ABox? It turns out thatDLs have to include nominals and the ‘@’ constructor of hybrid logic for updated ABoxes tobe expressible, and that this still holds when updated ABoxes are approximated. Moreover,the size of updated ABoxes is exponential in the role depth of the original ABox and thesize of the update. We also show that this situation improves when updated ABoxes areallowed to contain additional auxiliary symbols. Then, DLs only need to include nominalsfor updated ABoxes to exist, and the size of updated ABoxes is polynomial in the size ofboth the original ABox and the update.© 2011 Elsevier B.V. All rights reserved.Description Logics (DLs) are a traditional family of knowledge representation formalisms which, in recent years, haveplayed an important role as a logical underpinning of ontology languages such as the W3C recommendation OWL [1]. In DLs,a knowledge base (KB) typically consists of two parts: a TBox to store intensional knowledge, i.e., a general formalization ofthe relevant concepts and relationships of the application domain; and an ABox to store extensional knowledge, i.e., instancelevel assertions that describe the current state of affairs in the application. Just like database systems, DL knowledge basesare not static entities, but have to be modified when the application domain evolves. This raises the fundamental updateproblem, which consists of rewriting the knowledge base to incorporate new information from the application withoutunnecessarily losing any existing knowledge. In the case of a DL knowledge base, at least three different incarnations of theupdate problem can be distinguished:• TBox updates, triggered by changes of the intensional knowledge of the application domain;• ABox updates, which have to be carried out when the intensional knowledge remains stable, but the state of affairs inthe application changes;* Corresponding author.E-mail addresses: liuhkai@tcs.inf.tu-dresden.de (H. Liu), clu@uni-bremen.de (C. Lutz), maja.milicic@manchester.ac.uk (M. Miliˇci ´c), frank@csc.liv.ac.uk(F. Wolter).0004-3702/$ – see front matter © 2011 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2011.08.003H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972171• KB updates, which do not distinguish between the two levels of knowledge and allow simultaneous modification of theTBox and the ABox.In typical applications, instance level knowledge stored in the ABox tends to change frequently whereas intensional knowl-edge in the TBox often remains stable for longer periods of time. Moreover, automatic TBox modifications are rarely desiredbecause the TBox is typically the result of a careful and time-consuming manual modeling process, and thus its syntacticstructure should not be changed in a radical way.These observations lead us to study ABox updates as a fundamental and basic form of updates in a DL context. A centralproperty of DL ABoxes is that they store incomplete knowledge, reflected by an open world semantics and the use of com-pound logical expressions that can involve disjunction and existential quantification. It follows that, technically, updating DLABoxes is equivalent to updating logical theories, a problem with a long tradition in both the database and AI communities[4–8].In the database and AI literature, for a long time no proper distinction was made between updates as studied in thispaper and the related notion of a revision. While the purpose of update is to bring the knowledge base up to date whenthe world described by it changes, revision aims at incorporating new knowledge that was obtained about a static world.Katsuno and Mendelzon [6] discuss this distinction in detail, show that update and revision are fundamentally differentoperations, and give 8 postulates that any rational update operator should satisfy. The prototypical update semantics thatcomplies with these postulates is Winslett’s well-known PMA semantics [4] whose general idea can, in our context, bestated as follows. The models of the original knowledge base K are viewed as those states of the world that are consideredpossible; when K is to be updated with new information U , then the models of the resulting updated knowledge baseK(cid:3)should satisfy U , but also be ‘as close as possible’ to the models of K (the principle of minimal change). In the caseof updating propositional theories and logical databases as considered in [6,4], the difficulty of defining what ‘as close aspossible’ means mainly derives from the following two features: (i) the newly added information may be non-deterministic,e.g. when it involves disjunction; and (ii) the updated theory must satisfy additional domain constraints stated in theform of a logical background theory. As discussed in more detail in Section 6 of this paper, the combination of thesefeatures with the first-order quantification present in description logics leads to serious semantic difficulties and also tocomputational problems. For this reason, we concentrate on a simple, yet fundamental form of update where (i) the newlyadded information U consists of a set of ground literals, i.e., sets of ABox assertions A(a) or r(a, b) and their negations,where A is a concept name and r a role name (thus both are atomic); and (ii) no background theory is present, i.e., theknowledge base K comprises only an ABox, but no TBox. In this case, there seems to be only one sensible formalizationof ‘as close as possible’: the models of K(cid:3)are obtained from the models of K by (deterministically!) applying the changesdictated by the ground literals in U . This semantics, which we adopt in the current paper, can thus be viewed as anincarnation of Winslett’s semantic that avoids the potentially controversial cases.As a starting point for the current paper, we observe that, in standard ‘expressive’ DLs such as those between ALC andALCQIO, we can find an ABox A and update U of the restricted form described above such that the result of updatingA with U cannot be expressed in the given DL. As a concrete example, take the following ABox A, which is formulated inALC, the basic expressive DL with Boolean operators. It states that John is a parent with only happy children, that Peter ishis child, and that Mary is a person:john:Person (cid:4) ∃has-child.Person (cid:4) ∀has-child.(Person (cid:4) Happy)has-child(john, peter)mary:Person.Suppose now that the situation changes by Mary becoming unhappy. The result of updating A with U = {Mary : ¬Happy} canbe represented by the following ABox A(cid:3), which is formulated in ALCO, the extension of ALC with nominals (individualnames inside concept descriptions):john:Person (cid:4) ∃has-child.Person (cid:4) ∀has-child.(cid:2)Person (cid:4)(cid:2)Happy (cid:7) {mary}(cid:3)(cid:3)has-child(john, peter)mary:Person (cid:4) ¬Happy.To understand why A(cid:3)is appropriate, note that A provides no information about whether or not Mary is a child of John.Because we cannot exclude that this is the case, John may now have an unhappy child, which is Mary. Thus, the newknowledge concerning Mary also resulted in an update of the knowledge concerning John. Using the nominal {mary} inthe assertion for john is actually unavoidable as it can be shown that there is no ALC-ABox that is equivalent to theALCO-ABox A(cid:3). As a consequence, the update of the ALC-ABox A with U cannot be expressed in ALC.We say that a description logic L does not have updates if there are an L-ABox A and update U such that the resultof updating A with U cannot be expressed in L. The first main aim of this paper is to understand how the problem of non-expressibility of updated ABoxes can be overcome. In particular, we consider two options: (i) increasing the expressive power ofDLs by adding additional constructors and (ii) relaxing the definition of updated ABoxes.2172H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Regarding (i), we show that the addition of nominals (as in the example above) and the ‘@’ constructor from hybrid logicsuffices to ensure the existence of updated ABoxes in all DLs between ALC and ALCQIO. Intuitively, the ‘@’ constructorenables ‘jumps’ between individuals by allowing the formation of concepts such as @aC which is satisfied at any point of aninterpretation whenever the individual a satisfies the concept C . We also show that the ‘@’-constructor (but not nominals)can be replaced by Boolean ABoxes, i.e., ABoxes that admit Boolean operators to be applied to ABox assertions.Regarding (ii), we consider the following definitions of updated ABoxes. An ABox A(cid:3)is• a semantic update of A with U if the models of A(cid:3)are precisely those interpretations that can be obtained from modelsof A by making the assertions in U true (the standard definition);• an approximate update of A with U regarding a DL L if A(cid:3)entails exactly the same L-ABox assertions as the semanticupdate of A with U ;• a projective update of A with U if the models of A(cid:3)are precisely the models of the semantic update, after projectingboth to the symbols in A and U ;• a projective approximate update of A with U if A(cid:3)of A with U as long as ϕ uses only symbols from A and U .1entails exactly the same L-ABox assertions ϕ as the semantic updateObserve that projective updates allow the use of fresh, auxiliary symbols in A(cid:3), and so do projective approximate updates.Also note that (projective and non-projective) approximate updates have an additional parameter, which is the DL L inwhich entailed ABox assertions are formulated. It is not hard to see that every semantic update is also an approximateupdate and a projective update, which in turn are also projective approximate updates. Moreover, semantic updates andapproximate updates can be proved to be logically equivalent, if the former exists. Due to the new symbols, this is ingeneral not true for projective updates. Similar forms of updates have been considered e.g. in [9,11], see Section 7 for moredetails.Unfortunately, it turns out that the more relaxed definitions of updated ABoxes only rarely help to overcome the problemof DLs not having updates. More precisely, all DLs considered in this paper have approximate updates if, and only if, theyhave semantic updates. Projective updates are slightly more well-behaved: using a simple trick, one can see that a DL L hasprojective updates if the extension of L with the ‘@’ constructor has semantic updates. Thus, we can ensure the existence ofprojective updates in the DLs between ALC and ALCQIO by adding only nominals (but not the ‘@’ constructor). Furtherrelaxing projective updates to projective approximate updates turns out to not improve this situation.The second main question studied in this paper concerns the size of updated ABoxes. The first relevant observation is thatour construction of semantic updates in DLs that comprise nominals and the ‘@’ constructor incurs an exponential blowupin the size of the update U and in the role depth of the original ABox A, i.e., the nesting depth of existential and universalrestrictions in A. Although both measures are typically small in real applications, this raises the questions (i) whetheran exponential blowup of semantic updates can be avoided by a more careful construction and (ii) whether other formsof update help to avoid an exponential blowup. Concerning (i), we show that an exponential blowup cannot be avoidedunless NP ∩ co-NP is contained in the non-uniform version of the complexity class NC1, which is considered very unlikelyin complexity theory. Note that similar results such as those obtained by Cadoli et al. in [9] are not applicable due to therestricted form of updates considered in this paper (however, our results strengthen some of the results obtained by Cadoliet al.) Giving a positive answer to (ii), we then show that switching from semantic updates to projective ones dramaticallyimproves the situation: in DLs that comprise nominals, not only the existence of projective updates is guaranteed, but it iseven possible to construct projective updates whose size is polynomial both in the size of the original ABox and the update.Thus, projective updates are particularly well-suited for use in practical applications. We note that similar observationshave already been made for the case of propositional logic in [9], where it is shown that for some update semantics, theprojective version of updates is more succinct than the non-projective one.Finally, we extend our update constructions to conditional updates, which can express statements such as ‘ A(a) is trueafter the update if C(b) was true before’. We then apply the extended results to reasoning about actions in a DL context,as recently proposed and studied in [12–14]. In particular, we show that our construction of updated ABoxes can be usedto implement a progression approach to the central projection problem [7], reproving a number of tight upper complexitybounds for this problem that have originally been obtained using the method of regression.This paper is organized as follows. In Section 2, we provide a brief introduction to description logics, define the variouskinds of ABox updates studied in this paper, and present some basic results regarding these updates. In particular, weinterrelate the various definitions of updated ABoxes and prove that the ‘@’ constructor is intimately related to projectiveupdates, and to Boolean ABoxes.The non-existence of updated ABoxes in standard expressive DLs of the ALC family is established in Section 3. Weprove that DLs between ALC and ALCQI @ do not have approximate projective updates, and that DLs between ALCOand ALCQIO do not have approximate updates. This section is actually the only one where we explicitly consider1 Actually, the ‘real’ definitions of projective updates and projective approximate updates are slightly stronger and use different (but more complicatedto describe) sets of symbols. We refer to Definition 4 for full details.H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972173Fig. 1. Syntax and semantics of the description logic ALCQIO.(projective or non-projective) approximate updates since the positive results in subsequent sections all hold for stronger,non-approximating definitions of updated ABoxes.In Section 4, we show that adding nominals and the ‘@’ constructor to the DLs ALC, ALCI, ALCQ, and ALCQI suf-fices to have semantic updates. We also establish the single-exponential size of updated ABoxes announced before, both forthe case of single updates and iterated updates. We prove that an exponential blowup of updated ABoxes cannot be avoided,subject to the complexity-theoretic assumption that NP ∩ co-NP (cid:2) NC1. Finally, we consider an extension of ALCQIO@ withcertain role constructors which allows a simple construction of updated ABoxes that are exponential only in the size of theupdate, but not in the size of the original ABox.We then focus on projective updates in Section 5, showing that they are enjoyed by all DLs between ALCO andALCQIO@, including those that do not comprise the ‘@’ constructor. We also show that projective updates can be con-structed in polynomial time such that the resulting updated ABox is of polynomial size. With a small trick, these time andspace bounds also apply to the case of iterated updates.Section 6 is devoted to conditional updates and their application to reasoning about actions using DLs. Finally, Section 7wraps up the paper, analyzing some possible extensions of our results (e.g. with TBoxes) and discussing related work.This paper is a significantly extended and revised version of [15].2. Preliminaries and basic definitionsWe provide a brief introduction to description logics, define the various kinds of ABox updates studied in this paper, andpresent some basic observations regarding these updates. For the sake of readability, proofs for the results in this sectionare deferred to Appendix A.2.1. Description logics−We introduce the expressive description logic ALCQIO@ and its fragments studied in this paper. Our presentation willbe brief and the reader is referred to [1] for more details. In DLs, concepts are inductively defined with the help of a setof constructors, starting with a countably infinite set NC of concept names, a countably infinite set NR of role names, and(possibly) a countably infinite set NI of individual names. ALCQIO@-concepts are formed using the constructors shown inFig. 1. There, the inverse constructor is the only role constructor (used to construct compound roles), whereas the remainingseven constructors are concept constructors (used to construct compound concepts). A role is either a role name r or theinverse rof a role name r. In Fig. 1 and throughout the paper, we use #S to denote the cardinality of a set S, a and b todenote individual names, r and s to denote roles, A, B to denote concept names, and C , D to denote (possibly compound)concepts. As usual, we use (cid:9) as abbreviation for an arbitrary (but fixed) propositional tautology, ⊥ for ¬(cid:9), → and ↔ forthe usual Boolean abbreviations, ∃r.C (existential restriction) for ((cid:2) 1 r C), and ∀r.C (universal restriction) for ((cid:3) 0 r ¬C).The fragment of ALCQIO@ that allows only for negation, conjunction, disjunction, and universal and existential restric-tions is called ALC. The availability of additional constructors is indicated by concatenation of a corresponding letter: Qstands for number restrictions; I stands for inverse roles, O for nominals and superscript ‘@’ for the @ constructor. Thisexplains the name ALCQIO@ for our DL, and also allows us to refer to fragments in a simple way. In particular, when wespeak of all DLs between ALC and ALCQIO, we mean the logics L that can be obtained from ALC by all possible combi-nations of Q, I, and O. In particular, ALC and ALCQIO themselves are regarded as DLs between ALC and ALCQIO.In the same way, we speak about all DLs between ALC@ and ALCQIO@ and, in general, about all DLs between any twodescriptions logics. We note that, while the ‘@’ constructor from hybrid logic [16] is somewhat unusual in a DL context, itwill play an important role in the computation of updates later on.The semantics of ALCQIO@-concepts is defined in terms of an interpretation I = ((cid:3)I , ·I ). The domain (cid:3)Iis a non-empty set of individuals and the interpretation function ·Imaps• each concept name A ∈ NC to a subset AIof (cid:3)I,2174H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Ion (cid:3)I• each role name r ∈ NR to a binary relation rI ∈ (cid:3)I• each individual name a ∈ NI to an element a, andsuch that aI (cid:14)= bIassumption, UNA).whenever a and b are distinct (the unique nameThe extension of ·ITwo concepts C and D are equivalent, written C ≡ D, iff CI = DIfor all interpretations I.to inverse roles and arbitrary concepts is defined inductively as shown in the third column of Fig. 1.−(a, b) ∈ A if r(b, a) is contained in the ABox A; similarly, ¬rIn DLs, extensional knowledge is stored in an ABox. An ALCQIO@-ABox is a finite set of concept assertions C(a), roleassertions r(a, b), and negated role assertions ¬r(a, b), where r is a role name. For readability, we sometimes write concept−(a, b) ∈ Aassertions as a:C . As an abbreviation, we write rabbreviates ¬r(b, a) ∈ A. Observe that there is no need for explicitly introducing negated concept assertions due to theavailability of negation as a concept constructor in ALCQIO@ and its fragments. An ABox A is simple if C(a) ∈ A impliesthat C is a concept literal, i.e., a concept name or a negated concept name. We use Ind(A) to denote the set of all individualnames a used in the ABox A (i.e., all a such that there exists C(a) ∈ A or there exists C(b) ∈ A such that @a or {a} occursin C ) and role(A) to denote the set of role names used in A.An interpretation I satisfies a concept assertion C(a) iff a, a role assertion r(a, b) iff (a, and a negated. We write I |(cid:16) ϕ to denote satisfaction of an ABox assertion ϕ by an interpretationrole assertion ¬r(a, b) iff (aI. This notation is lifted to sets of interpretations Γ in the obvious way, i.e., we write Γ |(cid:16) ϕ iff I |(cid:16) ϕ for all I ∈ Γ . Aninterpretation I is a model of an ABox A, written I |(cid:16) A, if I |(cid:16) ϕ for all ϕ ∈ A.I ) /∈ rI ) ∈ rI ∈ Care equivalent, written A ≡ A(cid:3)We use M(A) to denote the set of all models of the ABox A. An ABox is consistent iff M(A) (cid:14)= ∅. Two ABoxes A, iff M(A) = M(A(cid:3)). An ABox assertion ϕ is a consequence of an ABox A, written, ifand A(cid:3)A |(cid:16) ϕ, if M(A) ⊆ M({ϕ}). This notion is lifted to ABoxes in the obvious way: A(cid:3)M(A) ⊆ M(A(cid:3)).is a consequence of A, written A |(cid:16) A(cid:3)I , bI , bIII2.2. Semantic updatesWe introduce the most natural form of ABox updates which we call ‘semantic’ because of their purely model-theoreticdefinition. Such updates have also been called ‘logical’ updates in the literature, see for example [9]. We start with consid-ering the update of an interpretation rather than an ABox.Definition 1 (Interpretation update). An update U is a consistent simple ABox. Let U be an update and I an interpretation.Define an interpretation IUby setting, for all individual names a, concept names A, and role names r:(cid:3)IUIUaIUAIUr= (cid:3)II= a(cid:2)=(cid:2)rA=I(cid:4)aI , b(cid:5)(cid:6)(cid:3) (cid:7) (cid:4)(cid:5) A(a) ∈ Ua(cid:3) (cid:5)(cid:6)(cid:3) (cid:7) (cid:4)(cid:2)(cid:5) r(a, b) ∈ UIa(cid:5)(cid:5) ¬ A(a) ∈ U(cid:3) (cid:5)(cid:5) ¬r(a, b) ∈ UI , bI ∪(cid:4)(cid:2)a(cid:6)III ∪(cid:6).IUis called the result of updating I with U .As the next step, updates are lifted to the level of ABoxes, which represent classes of models rather than single modelsas in Definition 1.Definition 2 (Semantic update). Let A be an ALCQIO@-ABox and U an update. Define the class of updated models asM(A)U =(cid:4)IU(cid:5)(cid:6)(cid:5) I ∈ M(A).An ALCQIO@-ABox A(cid:3)(cid:3)(cid:2)A(cid:3)= M(A)U .Mis a semantic update of A with U , written A (cid:16)⇒U A(cid:3), ifA description logic L has semantic updates if for every L-ABox A and update U , there is an L-ABox A(cid:3)with A (cid:16)⇒U A(cid:3).To illustrate Definition 2, consider the following ABox E , which we use as a running example:john : ∃has-child.Happymary : Happy (cid:4) Clever.The following ABox E (cid:3)is a semantic update of E with U = {¬Happy(mary)}:H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972175(cid:2)john : ∃has-child.mary : ¬Happy (cid:4) Clever.Happy (cid:7) {mary}(cid:3)To understand the disjunction, note that there are two kinds of models of E : those where John has a happy child thatis not Mary, and those where Mary is the only happy child of John. In models of the former kind, John still satisfies∃has-child.Happy after the update (first disjunct); in models of the latter kind, Mary is still a child of John after the update(second disjunct). For the sake of completeness, we provide a proof of the following in Appendix A:Observation 1. E (cid:16)⇒U E (cid:3).As captured by the following lemma, semantic updates are unique up to logical equivalence and do not depend on thesyntactic presentation of the original ABox. The lemma is an immediate consequence of the definition of semantic updates.Lemma 1. Let A1, A2, A(cid:3)1, A(cid:3)2 be ALCQIO@-ABoxes. Then A1 ≡ A2 and Ai (cid:16)⇒U A(cid:3)i for i ∈ {1, 2} imply A(cid:3)1≡ A(cid:3)2.We remark that making the UNA, as we do, has an impact on semantic updates. To show the difference between updateswith UNA and without, consider the ABox A = { A(a1)} and the update U = {¬ A(a2)}, where a1 (cid:14)= a2. Then A ∪ U is asemantic update of A with U under UNA, but the semantic update of A with U without UNA isU ∪(cid:2)(cid:4)a1 :{a2} (cid:7) A(cid:3)(cid:6).Thus, dropping the UNA results in a case distinctions regarding the identity of the individual names a1 and a2. Apart fromsuch case distinctions, dropping the UNA poses no major technical problems.Semantic updates are, in a sense, the ‘ideal’ kind of update. However, it turns out that many standard DLs such as ALCdo not have semantic updates. For example, it can be proved that for the above ALC-ABox A and update U , there is nosemantic update in ALC (and thus we had to resort to the ALCO-ABox A(cid:3)for presenting the semantic update). Thisproblem, which is studied in detail in Section 3, motivates the consideration of other, weaker forms of updates.2.3. Approximate updatesWe obtain a weaker form of update by considering the logical consequences of ABoxes instead of their models. Thisapproach to weakening updates has been introduced in a DL context in [11].Definition 3 (Approximate updates). Let A be an ALCQIO@-ABox, U an update, and L a description logic. An ALCQIO@-ABox A(cid:3)is an approximate update of A with U regarding L, written A −→L, if for all L-ABox assertions ϕ, we haveU A(cid:3)M(A)U |(cid:16) ϕ ⇔ M(cid:3)(cid:2)A(cid:3)|(cid:16) ϕ.A description logic L has approximate updates if for every L-ABox A and update U , there is an L-ABox A(cid:3)with A −→LU A(cid:3).As an example, reconsider the example ALC-ABox E and update U from Section 2.2. The following ALC-ABox E (cid:3)(cid:3)approximate update of E with U regarding ALC:is anjohn : ∃has-child.(Happy (cid:7) Clever)mary : ¬Happy (cid:4) Clever.Indeed, we prove in Appendix A:Observation 2. E −→ALCUE (cid:3)(cid:3).Recall that, in contrast, there is no ALC-ABox that is a semantic update of E with U .We now relate approximate updates to semantic updates in a precise way. If a semantic update exists, then an ABox isan approximate update regarding a DL L iff it has the same L-consequences as the semantic update. This is Point 1 of thefollowing lemma, and it is an immediate consequence of the definition of approximate updates. Point 2 follows from Point 1and asserts that semantic updates are approximate updates regarding any DL L.Lemma 2. Let A and A(cid:3)be ALCQIO@-ABoxes, U an update, and L a description logic. Assume A (cid:16)⇒U As. Then1. A −→L2. A −→LU A(cid:3)U As.iff for all L-ABox assertions ϕ, A(cid:3) |(cid:16) ϕ ⇔ As |(cid:16) ϕ;2176H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Note that, in contrast to the semantic case, the definition of approximate updates depends on the DL L used. Indeed,from Section 2.2 is a semantic update of E with U , thus byhave differentisthe choice of L can make a difference: the ALCO-ABox E (cid:3)Lemma 2 also an approximate update of E with U regarding ALCO. Since clearly E (cid:3)ALCO-consequences, E (cid:3)(cid:3)an approximate update of E with U regarding ALC.is not an approximate update of E with U regarding ALCO. However, as observed above, E (cid:3)(cid:3)and the above E (cid:3)(cid:3)We can derive interesting additional properties of approximate updates regarding a DL L when we demand that theupdated ABox is formulated in the same DL L, as in the definition of L ‘having approximate updates’. Then, approximateupdates are unique up to logical equivalence and also equivalent to semantic updates, if the latter exist. This is captured byPoints 1 and 2 of the following lemma.Lemma 3. Let A1 and A2 be ALCQIO@-ABoxes, U an update, L a description logic, and A(cid:3)1, A(cid:3)2L-ABoxes. Then1. A1 ≡ A2 and Ai −→L2. A1 −→LU A(cid:3)1 and A1 (cid:16)⇒U A(cid:3)i for i ∈ {1, 2} imply A(cid:3)≡ A(cid:3)2 imply A(cid:3)2.U A(cid:3)11≡ A(cid:3)2;Point 1 is an immediate consequence of the fact that for any two L-ABoxes A and A(cid:3)assertions ϕ implies A |(cid:16) A(cid:3)Note that, by Point 1 of Lemma 3, approximate updates do not depend on the syntactic presentation of the original ABox.and A(cid:3) |(cid:16) A, which in turn implies A ≡ A(cid:3): A |(cid:16) ϕ iff A(cid:3) |(cid:16) ϕ for all L-ABox. Point 2 follows together with Point 2 of Lemma 2.We remark that approximate updates are less generally useful than semantic ones. In particular, one main use of DLABoxes is for query answering, see for example [2,17,3]. While semantic updates give correct answers to queries formulatedin any query language, approximate updates do not. For example, it follows directly from the definition that approximateupdates regarding a DL L give correct answers to instance queries C(a) with C formulated in L, but this is not true forunions of conjunctive queries (UCQs): the individual name john is not included in the certain answer to the following UCQq(x) when posed to the approximate update E (cid:3)(cid:3)of E with U regarding ALC given above:q(x) = has-child(x, mary) ∨(cid:2)(cid:3)∃ y.has-child(x, y) ∧ Happy( y).In contrast,Section 2.2.john is included in the certain answer to q(x) when posed to the semantic update E (cid:3)of E with U given in2.4. Semantic projective updates and approximate projective updatesAlthough weaker, approximate updates turn out to be almost as elusive as semantic ones and are not enjoyed by manystandard DLs, see Section 3. For this reason and to overcome the exponential blowup that we will encounter in the con-struction of semantic updates (when they exist), we consider an additional way of relaxing updated ABoxes, namely to allowadditional ‘auxiliary’ symbols (concept names, role names, and individual names) in the updated ABox. This can be doneboth for semantic updates and approximate updates, which gives rise to the four forms of update studied in this paper.Updates admitting auxiliary symbols have been studied in [9,10] in a propositional logic context.Elements of NC ∪ NR ∪ NI are called symbols. A signature is a set of symbols. The signature sig(C) of a concept C is the setof symbols that occur in C . The signature sig(A) of an ABox A is defined likewise; in particular all individual names usedin A are included in sig(A). For a signature S, we use S to denote (NC ∪ NR ∪ NI) \ S. The reduct I(cid:2)S of an interpretationI to a signature S is the interpretation obtained from I by ‘forgetting’ the interpretation of all symbols that are not in S;i.e., I(cid:2)S interprets only the symbols in S, but not other symbols. The notion of reducts is lifted to classes of models M bysetting M(cid:2)S = {I(cid:2)S | I ∈ M}.Definition 4 (Projective updates). Let A and A(cid:3)sig(A(cid:3)) \ (sig(A) ∪ sig(U )) is the set of fresh symbols of A(cid:3). We call A(cid:3)abe ALCQIO@-ABoxes, U an update, and L a description logic. Then Fr(A(cid:3)) =• semantic projective update of A with U , written A (cid:16)⇒pU A(cid:3), if(cid:3)(cid:2)A(cid:3)M(cid:2)Fr(A(cid:3))= M(A)U(cid:2)Fr(A(cid:3));• approximate projective update of A with U regarding L, written A −→p,LU A(cid:3), if for all L-assertions ϕ with sig(ϕ) ⊆ Fr(A(cid:3)),we haveM(A)U |(cid:16) ϕ ⇔ M(cid:3)(cid:2)A(cid:3)|(cid:16) ϕ.A description logic L• has semantic projective updates iff for every L-ABox A and every update U , there is an L-ABox A(cid:3)such that A (cid:16)⇒pU A(cid:3);H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197• has approximate projective updates iff for every L-ABox A and every update U , there is an L-ABox A(cid:3)A −→p,LU A(cid:3).2177such thatAs an example, consider the following ABox Fjohn : ∃has-friend.Smartand update U = {¬has-friend(john, mary)}. We will show in the proof of Theorem 2 that there is no L-ABox that is asemantic update of F with U and neither an L-ABox that is an approximate update of F with U regarding L, for manyDLs L including ALC and ALCO. However, we find a semantic projective update F (cid:3)formulated in ALCO that consists ofU and(cid:2)john : (∃has-friend.Smart) (cid:7) ∃r.(cid:3){mary} (cid:4) Smart,where r is a fresh role name.Observation 3. F (cid:16)⇒pU F (cid:3).We leave a formal proof of Observation 3 to the reader and only give an intuition of why F (cid:3)is a semantic projectiveupdate. Again, there are two kinds of models of A: those where John has a smart friend that is not Mary, and those whereMary is the only smart friend of John. In models of the former kind, John still satisfies ∃has-friend.Smart after the update(first disjunct); in models of the latter kind, Mary is still smart after the update. This is expressed by the second disjunct,where the role name r only serves the technical purpose of ‘jumping’ from John to Mary in updated interpretations.It is not hard to establish the following analogue of Lemma 2.Lemma 4. Let A and A(cid:3) ALCQIO@-ABoxes, U an update, L a description logic, and assume A (cid:16)⇒pU As. Then1. A −→p,L2. A −→p,LU A(cid:3)U As.iff for all L-ABox assertions ϕ with sig(ϕ) ⊆ Fr(A(cid:3)) ∪ Fr(As), we have A(cid:3) |(cid:16) ϕ ⇔ As |(cid:16) ϕ;Concerning analogues of Lemmas 1 and 3, an obvious first observation is that, due to the use of fresh symbols, semanticprojective updates need not be logically equivalent to each other, and neither do approximate projective updates. However,it is still a consequence of Definition 4 that semantic projective updates and approximate projective updates do not dependon the syntactic form of the original ABox.Lemma 5. Let A1, A2, and A(cid:3)be ALCQIO@-ABoxes, U an update, and L a description logic. ThenU A(cid:3)1. A1 ≡ A2 and A1 (cid:16)⇒p2. A1 ≡ A2 and A1 −→p,LU A(cid:3)U A(cid:3)imply A2 (cid:16)⇒p;imply A2 −→p,LU A(cid:3).2.5. The ‘@’ constructor, Boolean ABoxes and projective updatesThe example in Section 2.2 illustrates that, sometimes, nominals can help to overcome the non-existence of updates.The example in Section 2.4 shows that the same is true for projective updates. Indeed, we will show that among theDLs introduced in Section 2.1, exactly the DLs that include nominals have semantic projective updates (but not necessarilynon-projective updates). Interestingly, the positive effects of projective updates (but not those of nominals) can also beattained in two other ways: by adding the ‘@’ concept constructor as introduced in Section 2.1 and by replacing ABoxeswith Boolean ABoxes. The latter are sets of Boolean ABox assertions, i.e., combinations of ABox assertions expressed in termsof the connectives ∧ and ∨ (recall that ABox assertions are already closed under negation).For illustration, reconsider the example from Section 2.4,{¬has-friend(john, mary)}. Recall that the semantic projective update F (cid:3)of F consists of U andi.e. the ABox F = {john : ∃has-friend.Smart} update U =(cid:2)john : (∃has-friend.Smart) (cid:7) ∃r.(cid:3){mary} (cid:4) Smart.To eliminate the auxiliary symbol r and thus obtain a semantic non-projective update, we can use the ‘@’ concept constructorand replace the above assertion withjohn : (∃has-friend.Smart) (cid:7) @marySmart.Alternatively, we can eliminate the symbol r by using Boolean ABoxes, replacing the above assertion with(john : ∃has-friend.Smart) ∨ (mary : Smart).2178H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197It is due to the simplicity of this example that the two presentations of the semantic non-projective update do not involvenominals: in general, we might still have to use nominals even when the ‘@’ constructor or Boolean ABoxes are admitted.Indeed, we will show that among the DLs introduced in Section 2.1, exactly those have semantic (non-projective!) updatesthat comprise nominals and the ‘@’ constructor. A similar statement can be formulated for Boolean ABoxes.The aim of the current section is to present some basic observations regarding the relationship between the ‘@’ construc-tor, Boolean ABoxes, and projective updates. The following lemma shows that non-Boolean L@-ABoxes have exactly the sameexpressive power as Boolean L-ABoxes provided that L contains nominals. This does not hold, e.g., for ALC: while everyALC@-ABox can be translated into an equivalent Boolean ALC-ABox, it can be proved that no non-Boolean ALC@-ABox isequivalent to the Boolean ALC-ABox { A(a) ∨ r(b, c)}. A proof of the following lemma can be found in Appendix A.Lemma 6.1. Let L be a DL between ALC and ALCQIO. Then for every Boolean L@-ABox, there exists an equivalent Boolean L-ABox;2. Let L be a DL between ALCO and ALCQIO. Then for every Boolean L-ABox, there exists an equivalent non-Boolean L@-ABox.We remark that the translation of a Boolean L-ABox into an L@-ABox involves an exponential blowup while the conversetranslation does not.Finally, the relationship between the ‘@’ constructor/Boolean ABoxes and projective updates can easily be established bysimulating the ‘@’ constructor with a fresh role, as in the ABox F (cid:3)in the above example.Lemma 7. Let L be a DL between ALCO and ALCQIO. Then for every L@-ABox A, there exists an L-ABox A(cid:3)such thatM(A)(cid:2){r} = M(cid:3)(cid:2)A(cid:3)(cid:2){r}where r is a role name that does not occur in A.Proof (sketch). Let A be an L@-ABox and U an update. Construct an L-ABox A(cid:3)as follows. First convert all concepts inA into negation normal form (NNF), in which negation occurs only in front of concept names, but not in front of complexconcepts [1]. Then replace every concept @aC with ∃r.({a} (cid:4) C), r a role name not used in A. It can be proved that theresulting ABox A(cid:3)is as required. (cid:2)3. Non-existence of updatesWe present two general non-existence results for updates. First, we show that among the DLs introduced in Section 2.1,those without nominals do not have approximate projective updates, thus no semantic updates, approximate updates, andsemantic projective updates either.Theorem 1. Let L be a DL between ALC and ALCQI @. Then L does not have approximate projective updates.Proof. We exhibit an ALC-ABox and update for which we show that no approximate projective update exists in any of theDLs listed in Theorem 1.Let A = {a : ∃r. A, r(b, a)}, U = {¬ A(b)}, andA(cid:3) =(cid:4)(cid:2)¬ A(b), r(b, a), a : ∃r.(cid:3)(cid:6)A (cid:7) {b}.II(cid:3)is a semantic update of A with U . Let I be a model of A. We have to show that IUWe first show that the ALCO-ABox A(cid:3). By definition, IU |(cid:16) r(b, a) and IU |(cid:16) ¬ A(b). It remains to show that IU |(cid:16) a : ∃r.( A (cid:7) {b}). First assumeis a model of A(cid:3)IUI , bI ) ∈ rI , bII ) ∈ rI , b. Then, since I |(cid:16). Then (athat (aIU. Again IU |(cid:16) a : ∃r.( A (cid:7) {b}).II , d) ∈ rIa : ∃r. A, there exists d (cid:14)= band d ∈ Awith (a. We have to show that there exists a model I of A such that IU = I(cid:3)Conversely, assume that I(cid:3)is a model of A(cid:3). Let II(cid:3)Icoincide with I(cid:3), band, therefore, IU |(cid:16) a : ∃r.( A (cid:7) {b}). Now assume (aIU. Then I is a model of A and I(cid:3) = IU. But then (aexcept that b, as required.and d ∈ AI , d) ∈ rI(cid:3) ∈ AI ) /∈ rWe show that there exists no ALCQI @-ABox B that is an approximate projective update of A with U regarding ALC.It follows that for all of the DLs L in Theorem 1, there is no L-ABox that is an approximate projective update of A with Uregarding L.) ∈ rif (aAssume to the contrary that such a B exists. We start with a high-level sketch of the proof. Let ∃rn.C denote the n-foldnesting ∃r. · · · .∃r.C , with ∃r0.C = C . We first observe that a : ∃r. A is not an ALC-consequence of B, while a : ∃r.( A (cid:7) (∃rn.(cid:9)))is an ALC-consequence of B for each n > 0. Since B is finite and formulated in ALCQI @, it cannot impose any constraintson domain element that exceed a certain ‘distance’ (in terms of the length of shortest role paths in an interpretation)from any individual name in B. Thus, to entail all assertions a : ∃r.( A (cid:7) (∃rn.(cid:9))) without entailing a : ∃r. A, B must enforcean r-cycle. Using a careful modification of the well-known unraveling technique [18,17] and certain guaranteed ALC-consequences of B, we show that no such cycle is actually enforced by B.We start with establishing some relevant (non)-entailments of B.I(cid:3)IH. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972179Claim 1.(i) B (cid:14)|(cid:16) a : ∃r. A;(ii) B |(cid:16) a : ∃r.( A (cid:7) (∃rn.(cid:9))), for all n (cid:2) 0;(iii) B (cid:14)|(cid:16) a : ∃r2.(cid:9).To prove (i), note that A(cid:3) (cid:14)|(cid:16) a : ∃r. A. We obtain that B (cid:14)|(cid:16) a : ∃r. A because B is an approximate projective update, a, r, A ∈sig(A) and since a : ∃r. A is an ALC-assertion.By the arguments used in the proof of (i), we know that (ii) can be proved by showing that A(cid:3) |(cid:16) a : ∃r.( A (cid:7) (∃rn.(cid:9))) forI,all n > 0. Due to the fact that A(cid:3) |(cid:16) a : ∃r.( A (cid:7) {b}), for every model I of A(cid:3)which in turn yields a ∈ (∃rn.(cid:9))Ifor all n (cid:2) 1 since r(b, a) ∈ A(cid:3)I /∈ (∃r. A)I, we have that aimplies (aI ) ∈ rTo prove (iii), note that the interpretation I with (cid:3)I = {a, b, x}, aI = {x} is a. Hence A(cid:3) (cid:14)|(cid:16) a : ∃r2.(cid:9). We obtain B (cid:14)|(cid:16) a : ∃r2.(cid:9) because B is an approximate projectiveI = {(b, a), (a, x)}, and AI = a, bI = b, rI /∈ (∃r2.(cid:9))Imodel of A(cid:3)update, a, r ∈ sig(A) and since a : ∃r2.(cid:9) is an ALC-assertion.such that aI , bNow take a model I of B with I (cid:14)|(cid:16) a : ∃r. A. We unravel I into a new model J of B that has a forest-like shape andstill satisfies J (cid:14)|(cid:16) a : ∃r. A. After the unraveling, we further modify J which allows us to derive a contradiction to Point (ii)of Claim 1..As we want to preserve all ALCQI @-concepts in concept assertions in B, we apply an unraveling construction in whichrole-predecessors are not duplicated. In detail, let (cid:3)Jbe the set of all words w = d0s0d1s1 · · · sk−1dk, k (cid:2) 0, such that;1. d1, . . . , dk ∈ (cid:3)I2. s0, . . . , sk−1 are roles (i.e. role names or their inverses);I3. there is a c ∈ NI such that d0 = c4. for all i < k, we have (di, di+1) ∈ sI0 and d1 = c5. if d0 = cI1 for c0, c1 ∈ NI, then B (cid:14)|(cid:16) s0(c0, c1).;Ii and if si = s−i+1, then di (cid:14)= di+2;Condition 4 is the standard approach for dealing with the presence of both number restrictions and inverse roles. Point 5will be explained below. Define the interpretation of symbols in J as follows:J := {d0 · · · dk ∈ (cid:3)J | dk ∈ B• B• for all s ∈ NR,I } for all B ∈ NC;J :=s(cid:4)(cid:2)c(cid:4)I2I1 , c(w, wsd)(cid:4)(cid:2)−(cid:3) (cid:5)(cid:6)(cid:5) B |(cid:16) s(c1, c2)(cid:5)(cid:5) w, wsd ∈ (cid:3)J(cid:3) (cid:5)(cid:5) w, ws∪d ∈ (cid:3)J∪(cid:6)−d, wws(cid:6).• cJ := cIfor all c ∈ NI.as is often done whenNote the careful definition of sunraveling models of ABoxes. Indeed, only this careful definition and Condition 5 above ensure that ABox elements are notduplicated during unraveling, which would cause conflicts with number restrictions., where we do not include all pairs (cI1 , cI2 ) with (cI1 , cI2 ) ∈ sIJClaim 2. For all ALCQI @-concepts C and all w = d0 · · · dk ∈ (cid:3)J, we have w ∈ CJiff dk ∈ CI.The proof is by induction on the structure of C . We only do the cases C = @c D and C = ((cid:3) n s D) from the inductionstep, leaving the remaining cases to the reader.and C = @c D. Then dk ∈ (@c D)ILet w = d0 · · · dk ∈ (cid:3)JJNow let C = ((cid:3) n s D) and w = d0 · · · dk. Assume first that k > 0. Let, for any e ∈ (cid:3)JI (dk) ∩ DJ (e). Now, using the IH and Condition 4, one can show that siff w ∈ ((cid:3) n s D)J. Therefore dk ∈ ((cid:3) n s D)Iand likewise for sJ (w) ∩ Ds, as required.iff (by IH) cJ ∈ DI ∈ Diff cJIiff w ∈ (@c D)J, sI.I },I (e) = {d ∈ (cid:3)I | (e, d) ∈ shas the same cardinality asNow assume that k = 0. Then w = d0 ∈ (cid:3)I ∩ (cid:3)Ja c ∈ NI with cJ(d0, d0sd) ∈ sthis bijection, that d0 ∈ ((cid:3) n s D)II = d and B |(cid:16) s(c0, c), then (d0, d) ∈ s. Thus, there exists a bijection between siff d0 ∈ ((cid:3) n s D)Jand there exists a c0 ∈ NI with cJI (d0) and s, as required.I (d0) and there isI (d0) and there is no such c, thenJ (d0) and we obtain, by applying the IH to the pairs in= d0. If d ∈ sby definition of s. If d ∈ sI0JClaim 2 implies that J (cid:14)|(cid:16) a : ∃r. A as intended. Moreover, we haveClaim 3. J is a model of B.To prove Claim 3, let ϕ ∈ B.2180H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Fig. 2. The interpretations I and I(cid:3).1. If ϕ = C(c) for an ALCQI @-concept C , then we have I |(cid:16) C(c), and thus J |(cid:16) C(c) by Claim 2.2. If ϕ = s(c1, c2) for a role s name, then we have B |(cid:16) s(c1, c2), and thus J |(cid:16) s(c1, c2) by definition of s3. If ϕ = ¬s(c1, c2), then we have B (cid:14)|(cid:16) s(c1, c2) (since B is consistent) and therefore J (cid:14)|(cid:16) s(c1, c2) by definition of sJ.Thus J |(cid:16) ¬s(c1, c2).J.This finishes the proof of Claim 3.We define the depth d(C) of an ALCQI @-concept C as the nesting depth of number restrictions in C , with a ‘reset’triggered by the ‘@’ constructor, i.e.,= 0d(B) = d(@aC)(cid:4)(cid:6)d(C (cid:4) D) = d(C (cid:7) D) = maxd(C), d(D)d((cid:3) n r C) = d((cid:2) n r C) = d(C) + 1d(¬C)= d(C).The depth d(B) of B is defined as max{d(C) | C(c) ∈ B}. As the next step, we further modify J by ‘cutting off’ all pathsin (cid:3)Jand sbe the restrictions ofJBis dropped by the restrictionof (cid:3)JJ (cid:3)that are not in B at length d(B). Thus, let (cid:3)J (cid:3) = {d0 · · · dk ∈ (cid:3)J | k (cid:3) d(B)}, let BJfor all c ∈ NI (clearly, no c). One can show by induction on the structure of C :for all B ∈ NC and s ∈ NR, and let cto (cid:3)J (cid:3)J (cid:3) = cand sJ (cid:3)JJClaim 4. For all ALCQI @-concepts C with d(C) = i (cid:3) d(B) and all w = d0 · · · dk ∈ (cid:3)Jw ∈ CJ (cid:3).with k (cid:3) d(B) − i, we have w ∈ CJiffClaims 3 and 4 imply that J (cid:3)is a model of B: role assertions ϕ ∈ B are clearly not invalidated when constructing J (cid:3)from J and concept assertions C(c) ∈ B are satisfied by Claim 4 and since they were satisfied in J .By Point (ii) of Claim 1, to obtain a contradiction it thus remains to show that there exists an n > 0 such thatJ (cid:3) (cid:14)|(cid:16) a : ∃r.( A (cid:7) (∃rn.(cid:9))). Set n = d(B) + 1. First observe that J (cid:3) (cid:14)|(cid:16) a : ∃r. A because J (cid:14)|(cid:16) a : ∃r. A. It remains to showthat J (cid:3) (cid:14)|(cid:16) a : ∃rn+1.(cid:9). Observe that by Point (iii) of Claim 1, in B there is no r-chain of length larger than 1 starting froma (more precisely: we have m (cid:3) 1 for any m with r(a, c1), r(c1, c2), . . . , r(cm−1, cm) ∈ B for some c1, . . . , cm ∈ NI). Thus,by construction of J (cid:3)have length k (cid:3) d(B) + 1. Thus, J (cid:3) (cid:14)|(cid:16) a : ∃rn+1.(cid:9), asrequired. (cid:2), all r-paths d0, . . . , dk in J (cid:3)with d0 = aJ (cid:3)Our second non-existence result for updates states that among the DLs introduced in Section 2.1 that include nominals,those that lack the ‘@’ constructor do not have approximate updates, thus no semantic updates either. In contrast to theDLs considered in the previous theorem, the DLs addressed here do have projective semantic updates (thus also projectiveapproximate updates), see Section 4.Theorem 2. Let L be a DL between ALCO and ALCQIO. Then L does not have approximate updates.Proof. Let L be a DL between ALCO and ALCQIO. We construct an ALC-ABox A and update U such that there is noALCQIO-ABox A(cid:3)that is an approximate update of A with U regarding ALC. Let A = {a : ∃r. A}, U = {¬r(a, b)} and.A(cid:3) =(cid:6)(cid:4)a : ∃r. A (cid:7) @b A, ¬r(a, b)It is not difficult to show that the ALC@-ABox A(cid:3)is a semantic update of A with U , thus also an approximate update.It suffices to show that there is no ALCQIO-ABox B with A(cid:3) |(cid:16) ϕ iff B |(cid:16) ϕ for all ALC-assertions ϕ. Assume to thecontrary that such a B exists, and choose a role name s that does not occur in A(cid:3)and B (such a role name exists sinceB is finite). Now consider the interpretations I and I(cid:3)displayed in Fig. 2. We assume that the individual names a and bare mapped to the individuals of the same name as shown in the figure. To satisfy the UNA, we also assume that there isan infinite set of additional points that interpret the individual names distinct from a and b. On these additional points, allconcept and role names are interpreted as empty. Note that I and I(cid:3). By Point 2 of Lemma 3, they arethus also models of B. Consider the additional interpretation I(cid:3)(cid:3)in Fig. 3. We show that I(cid:3)(cid:3) |(cid:16) B and I(cid:3)(cid:3) (cid:14)|(cid:16) B, thus derive acontradiction.are models of A(cid:3)H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972181Claim 1. I(cid:3)(cid:3) (cid:14)|(cid:16) B.Fig. 3. The interpretation I(cid:3)(cid:3).Assume I(cid:3)(cid:3) |(cid:16) B. Define C = ¬ A (cid:4) ∃s.({a} (cid:4) ∀r.¬ A). Clearly, I(cid:3)(cid:3) |(cid:16) C(b). Since I(cid:3)(cid:3) |(cid:16) B, it follows that B (cid:14)|(cid:16) ¬C(b). Hence,A(cid:3) (cid:14)|(cid:16) ¬C(b). This is a contradiction to the fact that A(cid:3) |(cid:16) ¬C(b) (note that ¬C ≡ A (cid:7) ∀s.({a} → ∃r. A)).Claim 2. I(cid:3)(cid:3) |(cid:16) B.To prove this claim we require an observation regarding models of ALCQIO-ABoxes. Assume that I1 and I2 areinterpretations whose domains are split into two non-empty disjoint parts, say (cid:3)I1 = (cid:3)1,1 (cid:24) (cid:3)1,2 and (cid:3)I2 = (cid:3)2,1 (cid:24) (cid:3)2,2such that(i) the interpretation of individual names is split in the same way, i.e., a(ii) no role name in I1 connects (cid:3)1,1 and (cid:3)1,2, i.e., s(iii) the same for I2.I1 ∩ ((cid:3)1,1 × (cid:3)1,2) = ∅ and sI1 ∈ (cid:3)1,1 iff aI2 ∈ (cid:3)2,1 for all a ∈ NI;I1 ∩ ((cid:3)1,2 × (cid:3)1,1) = ∅ for all s ∈ NR;Now swap the submodel of I1 induced by (cid:3)1,2 with the submodel of I2 induced by (cid:3)2,2 and use I1,2 to denote theresulting interpretation with domain (cid:3)1,1 (cid:24) (cid:3)2,2 and I2 to denote the resulting interpretation with domain (cid:3)2,1 (cid:24) (cid:3)1,2. Itcan be proved that(∗) for all ALCQIO-ABox assertions ϕ, we have that I1 |(cid:16) ϕ and I2 |(cid:16) ϕ iff I1,2 |(cid:16) ϕ and I2,1 |(cid:16) ϕ.Actually, (∗) is easily verified for (possibly negated) role assertions ϕ. To establish it for concept assertions, one can provei,i ; and for all d ∈ (cid:3)i,2, i ∈ {1, 2},by induction on the structure of C that for all d ∈ (cid:3)i,1, i ∈ {1, 2}, we have d ∈ Ci,i (where 1 = 2 and 2 = 1).we have d ∈ CIi iff d ∈ CIi iff d ∈ CIITo apply the above observation, we first modify I, I(cid:3), and I(cid:3)(cid:3)interpretations J , J (cid:3)suffices to show that J (cid:3)(cid:3) |(cid:16) B. Observe that J (cid:3)(cid:3)with the submodel J (cid:3)b of J (cid:3), and J (cid:3)(cid:3)by dropping the s-edge from b to a. Call the resulting, respectively. As s does not occur in B, we have J |(cid:16) B and J (cid:3) |(cid:16) B, and to show I(cid:3)(cid:3) |(cid:16) B itis the result of swapping the submodel Jb of J induced by the domain {b}induced by the domain {b}. Thus, (∗) yields that J (cid:3)(cid:3)is a model of B as required. (cid:2)4. Computing semantic updatesThe main result established in this section is that adding nominals and the ‘@’ constructor to the DLs ALC, ALCI,ALCQ, and ALCQI suffices to have semantic updates. We also analyze the size of the updated ABoxes showing that ourproof incurs a blowup that is exponential in the role depth of concepts used in the original ABox and in the size of theupdate, both in the case of a single update and of iterated updates. We then show that this blowup is very likely to beunavoidable, and that the somewhat unusual extension of ALCQIO with Boolean role constructors and ‘nominal roles’can be used to avoid the exponential blowup in the role depth of the original ABox (but not the blowup in the size of theupdate).4.1. Semantic updates in DLs with nominals and ‘@’We provide a detailed proof that ALCQIO@ has semantic updates, thus also approximate updates (and the projectiveversions of both). The proof can easily be adapted to the fragments ALCO@, ALCIO@, and ALCQO@.As a preliminary, we observe that assertions that are already contained in the original ABox A can be dropped from theupdate U .Lemma 8. Let A, A(cid:3)be ALCQIO@-ABoxes and U an update. Then A (cid:16)⇒U A(cid:3)iff A (cid:16)⇒U \A A(cid:3).Proof. Immediate consequence of the fact that for all models I of A, we have IU = IU \A. (cid:2)Consequently, from now on we assume w.l.o.g. that A ∩ U = ∅ whenever A is updated with U .2182H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Fig. 4. Constructing the concept update CU.UOur construction of semantic updates is an extension of the corresponding construction for propositional logic describedin [4]. We start with addressing the update of single concept assertions, where the central technical construction consiststhat can be used after the update with U to describe the set of exactly thoseof converting a concept C into a concept Cdomain elements that have been in the extension of C before the update. The conversion proceeds by induction on the−(a, b) ∈ U is simply an abbreviationstructure of C as detailed in Fig. 4. It seems appropriate to remind the reader that rfor r(b, a) ∈ U , and likewise for negated role assertions. To get to grips with the somewhat intricate translation of numberrestrictions, the reader may find it easier to first consider the more specialized clauses for existential restrictions anduniversal restrictions, which are for convenience given in Fig. 5. As an example, consider the concept C = ∃r. A and theupdate U = {¬ A(b), r(b, b)}. Modulo some minor simplifications, we obtain(cid:2)(cid:3)(cid:3)(cid:3)(cid:3)(cid:2)U =C(cid:2)¬{b} (cid:4) ∃r.A (cid:7) {b}(cid:7)(cid:2){b} (cid:4) ∃r.¬{b} (cid:4) A., where we use ¬U to denoteThe following lemma formally states the main property of the constructed concepts C{¬. ϕ | ϕ ∈ U } and ¬. ϕ is obtained from ¬ϕ by eliminating double negation (i.e., it denotes ψ if ϕ = ¬ψ for some ψ and ¬ϕotherwise). We will see later how to overcome the restriction that I has to violate all assertions in U .ULemma 9. For all interpretations I such that I |(cid:16) ¬U , we have CI = (CU )IU.Proof. Let I be an interpretation such that I |(cid:16) ¬U and E an ALCQIO@-concept. By induction on the structure of E, weshow that (EU )IU = EI.• If E = A, for A a concept name, then ( A(cid:10) (cid:11) (cid:9)(cid:9)(cid:8)IUA∪IU (cid:6)(cid:4)aU )IU(cid:4)aisIU (cid:6)(cid:8)(cid:8)(cid:8)(cid:8)==¬ A(a)∈U(cid:9)A(a)∈U(cid:9)(cid:4)aI(cid:4)aII ∪AI ∪AA(a)∈U(cid:6) (cid:11) (cid:9)¬ A(a)∈U(cid:6) (cid:11) (cid:9)(cid:10)(cid:10)(cid:6)(cid:4)aI(cid:6)(cid:4)aI∪∪(cid:10) (cid:11) (cid:9)(cid:9)IU (cid:6)(cid:4)aIU (cid:6)(cid:4)a¬ A(a)∈U(cid:9)(cid:10) (cid:11) (cid:9)A(a)∈U(cid:4)a(cid:6)I(cid:6)(cid:4)aIA(a)∈U¬ A(a)∈U¬ A(a)∈UA(a)∈U= AI .The last equality holds since, due to I |(cid:16) ¬U , we have A(cid:12)I ∩A(a)∈U {aI } = ∅ and(cid:12)¬ A(a)∈U {aI } ⊆ AI.• The case E = {a} is immediate since I and IUinterpret individual names in the same way.H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972183• The cases E = ¬C , E = C (cid:7) D, E = C (cid:4) D, and E = @aC are straightforward using the semantics and induction hypothesis.I• It remains to consider the cases E = ((cid:2) m r C) and E = ((cid:3) m r C). The central observation is that we have (d, e) ∈ riff eitherI– d (cid:14)= aI– d = afor all a ∈ Ind(U ) and (d, e) ∈ rfor an a ∈ Ind(U ) and exactly one of the following holds:I∗ e (cid:14)= bI∗ e = bfor all r(a, b) ∈ Ind(U ) and (d, e) ∈ rfor a b ∈ Ind(U ) with ¬r(a, b) ∈ U (which implies (d, e) ∈ r; orIU,IUsince (d, e) /∈ rIU).Isince I |(cid:16) ¬U and excludes the previous caseThis case distinction is directly reflected in the translation of the concepts ((cid:2) m r C) and ((cid:3) m r C). Using this and theinduction hypothesis, it is possible to verify that (E, as required. (cid:2)U )IU = EIThe concepts CUare used as a central building block for defining updates of ABoxes. Let A be an ALCQIO@-ABox and(cid:4)AU =by settingU an update. Define the ABox AU(cid:5)(cid:6)(cid:5) C(a) ∈ A∪(cid:5)(cid:5) r(a, b) ∈ A ∧ ¬r(a, b) /∈ U(cid:5)(cid:5) ¬r(a, b) ∈ A ∧ r(a, b) /∈ U(cid:4)r(a, b)(cid:4)¬r(a, b)U (a)(cid:6)C∪(cid:6).We now establish an analogue of Lemma 9, but formulated for ABoxes instead of concepts.Lemma 10. Let A be an ABox and U an update. For every interpretation I with I |(cid:16) ¬U , we have I |(cid:16) A iff IU |(cid:16) AU.Proof. “⇒” Let I |(cid:16) A. We show that IU |(cid:16) AUand IU, IU |(cid:16) ϕ. If ϕ = EU (a) for E(a) ∈ A, Lemma 9 yields IU |(cid:16) E. Let ϕ ∈ AUU (a).. If ϕ = r(a, b) or ϕ = ¬r(a, b), then, by the definition of AU“⇐” Let IU |(cid:16) AU. We show that I |(cid:16) A. Take ϕ ∈ A. First for the case ϕ = r(a, b). There are two subcases:1. ¬r(a, b) ∈ U . Then r(a, b) ∈ ¬U and since I |(cid:16) ¬U , we obtain that I |(cid:16) r(a, b);2. ¬r(a, b) /∈ U . Then r(a, b) ∈ AU, this yields I |(cid:16) r(a, b).IU, thus IU |(cid:16) r(a, b). We have r(a, b) /∈ U since we assume A ∩ U = ∅. By definition ofThe case ϕ = ¬r(a, b) is analogous to the previous one, and the case ϕ = E(a) is immediate by Lemma 9. (cid:2)USimilar to the concepts C, the construction of the ABox AUrelies on the fact that the model I of A violates all, where U (cid:3) = {ϕ ∈ U |assertions in U . For a fixed model I of A, we can overcome this problem by replacing Cwith CI (cid:14)|(cid:16) ϕ} is the update that consists of those assertions from U that are violated in I. However, the original ABox A canhave many different models I, which may give rise to different adjustments U (cid:3)of the update U . We address this issue byconsidering all subsets U (cid:3) ⊆ U of assertions that can potentially be violated in a model of A, and then taking the disjunctionof all the resulting updated ABoxes AU (cid:3)U (cid:3)U.Let A be an ABox and U an update. Define the updated ABox A(cid:3)as the Boolean ABox(cid:13)(cid:14)(cid:13)A(cid:3) =U ∧AU (cid:3).U (cid:3)⊆UHere, we use Boolean ABox operators only as an abbreviation for the “@” constructor, see Lemma 6.Lemma 11. A (cid:16)⇒U A(cid:3).Proof. We prove that both inclusions of M(A(cid:3)) = {IU | I ∈ M(A)} hold.. By definition of IU. Moreover, using the definition of U (cid:3)“⊇” Let I |(cid:16) A. We have to show that IU |(cid:16) A(cid:3)I (cid:14)|(cid:16) ϕ}. By Lemma 10, we have IU (cid:3) |(cid:16) AU (cid:3)thus IU |(cid:16) AU (cid:3)which yields IU |(cid:16) A(cid:3)., IU |(cid:16) U . Define a subset U (cid:3) ⊆ U as U (cid:3) = {ϕ ∈ U |, it can be verified that IU (cid:3) = IU,and IU (cid:3)“⊆” Let I(cid:3) |(cid:16) A(cid:3). We need to show that there exists an interpretation I such that I |(cid:16) A and I(cid:3) = IU. Since I(cid:3) |(cid:16) A(cid:3). Let I = (I(cid:3))¬(U (cid:3)), i.e., we undo all the modifications in the selected adjustment U (cid:3),.there is a U (cid:3) ⊆ U such that I(cid:3) |(cid:16) AU (cid:3)Then I(cid:3) = IU (cid:3) = IU. Moreover, Lemma 10 yields I |(cid:16) A. (cid:2)The presented construction of semantic updates can be adapted to the DLs ALCO@, ALCIO@, and ALCQO@. For thetranslation rather than number restrictions.former two, we have to treat existential and universal restrictions in the CThe corresponding clauses are shown in Fig. 5. The lemmas proved above for ALCQIO@ are then easily adapted.UTheorem 3. The DLs ALCO@, ALCIO@, ALCQO@, and ALCQIO@ have semantic updates.2184H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Fig. 5. Constructing CUfor existential and universal restrictions.4.2. The size of semantic updatesWe show that the above construction yields semantic updates whose size is at most exponential in the size of the roledepth of the original ABox and the size of the update. If the role depth of the original ABoxes is fixed, then the size of theupdate is polynomial in the size of the original ABox and exponential in the size of the update.The length of a concept C , denoted by |C|, is the number of symbols needed to write C . Numbers inside number re-strictions can be coded in unary or in binary, which yields |((cid:3) n r C)| ∈ O(n) and |((cid:3) n r C)| ∈ O(log n), respectively.Since all our results hold independently of the chosen coding scheme, we from now on assume binary coding. The roledepth of a concept C , denoted by rd(C), is the nesting depth of number restrictions in C , i.e., rd( A) = 0, rd(¬C) = rd(C),rd(C (cid:4) D) = rd(C (cid:7) D) = max(rd(C), rd(D)) + 1, and rd((cid:2) n r C) = rd((cid:3) n r C) = rd(C) + 1.The size of an ABox assertion C(a) is |C|, the size of r(a, b) and ¬r(a, b) is 1. The size of an ABox A, denoted by |A|, isthe sum of the sizes of all assertions in A. The role depth of an ABox A, denotes by rd(A), is max{rd(C) | C(a) ∈ A}.A close inspection of our construction of semantic updates reveals the following result.Theorem 4. Let L ∈ {ALCO@, ALCIO@, ALCQO@, ALCQIO@}. Then for every L-ABox A and update U , the semantic updateA(cid:3)of A with U computed by our algorithm satisfies(cid:5)(cid:5)A(cid:3)(cid:5)(cid:5) (cid:3) |A| · 2O(log(|A|)·|U|·rd(A)) · 22|U|and can be computed in time polynomial in |A(cid:3)|.Uis |C| · |U | and each ABox AU (cid:3)Proof. By inspection of the construction given in Section 4.1. We distinguish two cases. First, assume that rd(A) = 0. Thencomprisesthe size of each concept Csuch ABoxes AU (cid:3)|U |plus the update U , thus the overall size is clearly dominated by the given expression. Now assume2Uthat rd(A) > 0. View Cas a syntax tree in which all purely Boolean subtrees are collapsed into a single node, wherea subtree is Boolean if none of its nodes is labeled with the ‘@’ constructor or a number restriction. By construction, itO(|U |) and depth at most rd(C). Since every collapsed node represents at mosthas outdegree at most |C| · 2follows that CUO(|U |) syntax tree nodes, the size of C|C| · 2isbounded by |A| · 2plus the update U , thus theoverall size is again dominated by the given expression. (cid:2)O(log(|C|)·|U |·rd(C)). Analogously, the size of each ABox AU (cid:3)comprises 2is of size at most |A| · |U |. The semantic update A(cid:3)O(log(|A|)·|U |·rd(A)). The semantic update A(cid:3)such ABoxes AU (cid:3)is bounded by 2|U |UNote that the bound stated in Theorem 4 is polynomial in the overall size of the original ABox (which is potentiallylarge), and exponential only in the role depth of the original ABox and the size of the update, which are typically small. Inparticular, if the input ABox does not comprise any number restrictions (and neither existential and universal restrictions),then the size of updated ABoxes is exactly as in propositional logic [9].In many applications, the state of affairs evolves continuously which makes it necessary to update the ABox over andover again. It is then clearly important that the exponential blowups of the repeated updates do not add up, which wouldresult in a non-elementary growth of the produced semantic updates. The following theorem shows that this is indeed notthe case.Theorem 5. Let L ∈ {ALCO@, ALCIO@, ALCQO@, ALCQIO@}, A0, . . . , An L-ABoxes, U1, . . . , Un updates, and Ai+1 the se-mantic update of Ai with Ui+1 computed by our algorithm, for 0 (cid:3) i < n. Then|An| (cid:3) |A0| · 2O(log(|A0|)·(|U1|+···+|Un|)·rd(A0)) · 22(|U1|+···+|Un|).Proof. The argument is analogous to the proof of Theorem 4. In particular, viewing a concept ((Cwith collapsed nodes as in that proof, it is not hard to see that the outdegree is at most |C| · 2U1 )···)Un as a syntax treeO(|U1|+···+|Un|) and the depth isH. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972185Uat most rd(C). Since every collapsed Boolean node represents at most O(|C| · 2O(log(|C|)·(|U1|+···+|Un|)·rd(C)). Analogously, the size of each ABox ((ACis bounded by 2is bounded by |A0| · 2ABoxes and 2In summary, the size of An is thus bounded by the expression given in Theorem 5. (cid:2)ABoxes of the form ((U|U2|+···+|Un|O(log(|A0|)·(|U1|+···+|Un|)·rd(A0)). The semantic update An is a Boolean combination of 2O(|U1|+···+|Un|)) syntax tree nodes, the size of⊆ Un,suchn . The size of each of the latter ABoxes is bounded by |U1| · · · · · |Un|.⊆ U1, . . . , U (cid:3)n|U1|+···+|Un|n , with U (cid:3)1U (cid:3)0 )···)U (cid:3)1)···)U (cid:3)U (cid:3)i+1i4.3. A lower bound for the size of semantic updatesWe show that, in ALCQIO@ and its fragments, an exponential blowup of semantic updates cannot be avoided unlessNP ∩ co-NP ⊆ NC1,where NC1 is the class of problems that is solvable by a family of circuits of polynomial size and logarithmic depth. Wework with the non-uniform version of NC1 here, i.e., we do not demand that the circuit for a given input length can becomputed within certain resource bounds (or at all!). The stated inclusion is widely believed to not hold. It is intimatelyrelated to the important open question whether every problem that is efficiently solvable can be effectively parallelized,i.e., whether PTimeis a subset of uniform NC1, which is also not believed to be the case. In particular, there are reasons toassume that (non)-uniformity is irrelevant for inclusions of this sort, see e.g. [19].We obtain our result by relating semantic updates to Craig interpolants in propositional logic, which allows us to trans-fer known lower bounds for the size of such interpolants, see e.g. [20–22]. In what follows, we will deliberately confusepropositional formulas and concepts that use only the Boolean constructors ¬, (cid:4), and (cid:7). We use sig(ϕ) to denote the setof propositional letters that occur in the propositional formula ϕ, and sig(A) to denote the concept and role names thatoccur in the ABox A. Recall that, given two propositional formulas ϕ and ψ with ϕ |(cid:16) ψ , a Craig interpolant of ϕ and ψ is aformula ϑ with ϕ |(cid:16) ϑ |(cid:16) ψ and such that sig(ϑ) ⊆ sig(ϕ) ∩ sig(ψ). For a propositional formula ϕ and a set of propositionalletters S, we use ϕ[S/(cid:9)] to denote the result of replacing each letter from S in ϕ with (cid:9) (i.e., logical truth).Lemma 12. Let ϕ, ψ , and ϑ be propositional formulas with ϕ |(cid:16) ψ . If A = {ϕ(a)}, U = {p(a) | p ∈ sig(ϕ) \ sig(ψ)}, and A (cid:16)⇒U{ϑ(a)}, then ϑ[S/(cid:9)] is a Craig interpolant of ϕ and ψ where S = sig(ϑ) \ (sig(ϕ) ∩ sig(ψ)).Proof. Clearly, ϑ[S/(cid:9)] contains only propositional letters from sig(ϕ) ∩ sig(ψ) as required. It thus remains to show thatϕ |(cid:16) ϑ[S/(cid:9)] |(cid:16) ψ . We start with noting that(∗) ϑ[S/(cid:9)] ≡ ϑ[sig(U )/(cid:9)].To see (∗), note that (S \ sig(U )) ∩ (sig(A) ∪ sig(U )) = ∅, and thus A (cid:16)⇒U {ϑ(a)} implies that whenever I is a modelof ϑ and I and J differ only in the interpretation of symbols from S \ sig(U ), then J is also a model of ϑ . It followsthat ϑ[sig(U )/(cid:9)] has the same property. Thus, replacing all symbols from S \ sig(U ) in ϑ[sig(U )/(cid:9)] with (cid:9), which yieldsϑ[S/(cid:9)], is an equivalence preserving operation.We now show that ϕ |(cid:16) ϑ[S/(cid:9)] |(cid:16) ψ .• ϕ |(cid:16) ϑ[S/(cid:9)].• ϑ[S/(cid:9)] |(cid:16) ψ .Let I |(cid:16) ϕ(a). Then IU |(cid:16) ϑ(a). Moreover, IU |(cid:16) p(a) for all p ∈ sig(U ). It follows that IU |(cid:16) ϑ[sig(U )/(cid:9)](a), thusIU |(cid:16) ϑ[S/(cid:9)](a) by (∗). Since I and IUagree on the interpretation of all propositional letters from sig(ϕ) ∩ sig(ψ), weget I |(cid:16) ϑ[S/(cid:9)](a).Let J |(cid:16) ϑ[S/(cid:9)](a). By (∗), J |(cid:16) ϑ[sig(U )/(cid:9)](a). Let J (cid:3)J (cid:3) = (cid:3)J (cid:3)pJ (cid:3), and J agree on the interpretation of all propositional letters from sig(ψ), we get J |(cid:16) ψ(a). (cid:2). Clearly, J (cid:3) |(cid:16) ϑ(a). Thus there is a model I of A with IU = J (cid:3)be obtained from J by interpreting all p ∈ sig(U ) as true, i.e.,. Since I |(cid:16) ϕ(a), we have I |(cid:16) ψ(a). As I,As a side remark, we note that the formula ϑ[S/(cid:9)] in Lemma 12 is even a uniform interpolant for ϕ and sig(ψ): forany ψ (cid:3)with sig(ψ (cid:3)) ∩ sig(ϕ) ⊆ sig(ψ) and ϕ |(cid:16) ψ (cid:3)we have ϑ[S/(cid:9)] |(cid:16) ψ (cid:3).The semantic update {ϑ(a)} considered in Lemma 12 is of a rather particular form. To establish a lower bound for thesize of semantic updates in ALCQIO@, we observe that one cannot express ABoxes of the form {ϑ(a)}, ϑ a propositionalformula, more succinctly in ALCQIO@. The following lemma states this fact even for first-order logic (with equality), ofwhich ALCQIO@ is a fragment when concept names are confused with unary predicates and role names with binarypredicates [23]. The lemma can easily be proved by standard manipulations of FO formulas; details are left to the reader.Lemma 13. Let ϑ(a) be an ABox assertion, where ϑ is a propositional formula, and let ϕ be a first-order sentence that is equivalent toϑ(a). Then there exists a propositional formula ϑ (cid:3)that is equivalent to ϑ such that |ϑ (cid:3)(a)| (cid:3) |ϕ|.2186H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Together with the observation from [20] that the size of Craig interpolants cannot be bounded by a polynomial unlessNP ∩ co-NP ⊆ NC1, Lemmas 12 and 13 yield the desired result.Theorem 6. If there exists a polynomial p such that, for all propositional ABoxes A and updates U , there exists an ALCQIO@-ABoxA(cid:3)and |A(cid:3)| (cid:3) p(|A| · |U |), then NP ∩ co-NP ⊆ NC1.such that A (cid:16)⇒U A(cid:3)Proof. Assume there is a polynomial p as stated in Theorem 6. We show that then p2 bounds the size of Craig interpolantsin propositional logic, which implies NP ∩ co-NP ⊆ NC1 as observed in [20]. Let ϕ and ψ be propositional formulas andtake the ABox A = {ϕ(a)} and update U = {p(a) | p ∈ sig(ϕ) \ sig(ψ)}. Then there is an ALCQIO@-ABox A(cid:3)with A (cid:16)⇒Uand |A(cid:3)| (cid:3) p(|A| · |U |). By our algorithm computing semantic updates, there is a propositional formula ϑ such thatA(cid:3)A (cid:16)⇒U {ϑ(a)}. By Lemma 1, A(cid:3)is logically equivalent to an ABoxA(cid:3)(cid:3) = {ϑ (cid:3)(a)} with ϑ (cid:3)a propositional formula and |A(cid:3)(cid:3)| (cid:3) |A(cid:3)|. Finally, by Lemma 12 this implies that ϑ (cid:3)[S/(cid:9)], S = sig(ϑ (cid:3)) \(sig(ϕ) ∩ sig(ψ)), is a Craig interpolant of ϕ and ψ , whose size is bounded by p(|ϕ|2) (and independent of |ψ|). (cid:2)and {ϑ(a)} are logically equivalent. By Lemma 13, A(cid:3)As shown in [22], it is possible to replace the complexity-theoretic proviso in Theorem 6 with UP ⊆ P/poly, where UP isthe class of problems in NPaccepted by a non-deterministic Turing machine with unique accepting paths and P/poly is thenon-uniform version of PTime. Just like the statement used in Theorem 6, it is strongly believed that UP ⊆ P/poly does nothold.We note that the result stated as Theorem 6 is closely related to a similar result proved by Cadoli et al. which states thatfor semantic updates of propositional theories, an exponential blowup cannot be avoided unless the polynomial hierarchycollapses [9]. However, Cadoli et al.’s technique does not appear to work with the restricted form of updates U consideredin this paper, where we allow only literals but no compound concepts/formulas.4.4. Smaller updates in ALCQIO+An inspection of the construction of semantic updates presented in Section 4.1 reveals that, in the case where the updatebecomes a lot simpler: we only haveU contains only concept assertions but no role assertions, computing the concepts Cto replace every concept name A in C withU(cid:8)(cid:15){a}A (cid:7)(cid:10)(cid:8) (cid:15)(cid:4) ¬(cid:10){a}.¬ A(a)∈UA(a)∈UIn particular, the resulting semantic update AUis then only exponential in |U |, but no longer in the role depth of A.To understand why such a simple rewriting is not possible when roles are updated, note that the above constructionmakes essential use of nominals, the ‘@’ constructor, and the Boolean concept constructors. In standard DLs, none of theseconstructors is available for roles: we can neither construct the union of roles, nor their complement, nor a “nominalrole” {(a, b)} with a and b individual names. In this section, we consider a DL that comprises such slightly unusual roleconstructors and show that it admits simple semantic updates of the above form also in the case when the update comprisesrole assertions.Denote by ALCQIO+the DL that extends ALCQIO@ by means of the role constructors ∪ (role union), \ (set-theoreticdifference of roles), and {(a, b)} (nominal roles). In this language, compound roles are constructed by starting from rolenames and nominal roles, and then applying ∪, \, and the inverse role constructor ·−. The semantics of compound roles isas expected:I )}, for all a, b ∈ NI;I , b• {(a, b)}I = {(aII• (r1 ∪ r2)I = r∪ r2 ;1II• (r1 \ r2)I = r\ r2 .1We note that ALCQIO+counting quantifiers [24]. In particular, ALCQIO+the main result of this section.is of almost the same expressive power as C 2, the two-variable fragment of first-order logic with-ABoxes can easily be translated into formulas of C 2. The following isTheorem 7. There is a polynomial p such that, for every ALCQIO+such that-ABox A and every update U , there is an ALCQIO+-ABox A(cid:3)1. A (cid:16)⇒U A(cid:3)2. |A(cid:3)| (cid:3) |A| · 2p(|U |);3. A(cid:3);can be computed in time p(|A(cid:3)|).Proof. We modify the construction from Section 4.1. The construction of the concepts Cconcept name A in C withUis now as follows: replace every(cid:8)A (cid:7)(cid:15)(cid:10){a}(cid:8) (cid:15)(cid:4) ¬{a}¬ A(a)∈UA(a)∈UH. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197(cid:10)2187and every role name r in C with(cid:9)(cid:10) (cid:11) (cid:9)(cid:8)r ∪(cid:4)(cid:6)(a, b)(cid:4)(cid:6)(a, b).¬r(a,b)∈Ur(a,b)∈UThe concepts CSection 4.1. (cid:2)Uare thus of size polynomial in |A| · |U |. The ABox A(cid:3)can then be constructed in the same way as inClearly, Theorem 7 is independent of the coding of numbers, and iterated updates retain the same size bound, with |U |is to work directly withreplaced by |U1| + · · · + |Un|. An alternative to working with a description logic such as ALCQIO+the two-variable fragment with counting C 2. Then, a result analogous to Theorem 7 is easily obtained.5. Computing projective updatesWe consider projective updates and show that they are more well-behaved than semantic ones: first, projective updatesare enjoyed by all DLs between ALCO and ALCQIO@, including those that do not comprise the ‘@’ constructor; andsecond, projective updates can be constructed in polynomial time and without an exponential blowup. We prove this indetail for ALCQIO@ using an approach that can easily be adapted to all DLs between ALCO@ and ALCQIO@. Theseresults then transfer to the corresponding DLs without the ‘@’ constructor thanks to Lemma 7.Let A be an ALCQIO@-ABox and U an update. We show how to construct an ALCQIO@-ABox A(cid:3). Let sub(A) denote the closure under subconcepts of {C | C(a) ∈ A}. The general approach to constructing A(cid:3)such that A (cid:16)⇒pUA(cid:3)shares alot of similarity with the construction of semantic updates in Section 4.1. However, we need some subtle technical tricks toavoid the exponential blowups that occur there, namely (i) during the construction of the concepts Cand (ii) due to thefinal disjunction over all U (cid:3) ⊆ U . The central idea to overcome both blowups is to use fresh concept names XC and freshrole names ρr to explicitly reconstruct in A(cid:3)the extension of all concepts C ∈ sub(A) and all roles name r ∈ role(A) beforethe update. This allows us to eliminate blowup (i) because the concept names XC enable ‘structure sharing’, thus addressingon the right-hand side of the clauses in Fig. 4; moreover, the role names ρr help tothe multiple occurrences of concepts Cavoid the exponential case distinction ‘for all S ⊆ {b | ¬r(a, b) ∈ U }’ in the clauses for number restrictions. The use of the XCand ρr also allows us to eliminate blowup (ii) as the case distinction ‘for all U (cid:3) ⊆ U ’ can be replaced with some ‘freedom’that we will leave in the interpretation of the XC and ρr , and that intuitively corresponds to an existential quantificationover all U (cid:3) ⊆ U . More details are given below after the construction of A(cid:3)UU.. In what follows, we use ρr− to denote (ρr)−contains the update U . Second, we set up an ABoxThe projective update A(cid:3)will be the union of four ABoxes. First, A(cid:3)Ainit that stores the original ABox A using the concept names XC for C and role names ρr for r:Ainit =(cid:4)(cid:4)(cid:4)∪(cid:5)(cid:6)(cid:5) C(a) ∈ A(cid:5)(cid:6)(cid:5) a, b ∈ Ind(U), r(a, b) ∈ A∪(cid:5)(cid:6)(cid:5) a, b ∈ Ind(U), ¬r(a, b) ∈ A(cid:5)(cid:6)(cid:5) {a, b} (cid:2) Ind(U), r(a, b) ∈ A∪(cid:5)(cid:6)(cid:5) {a, b} (cid:2) Ind(U), ¬r(a, b) ∈ A∪.XC (a)ρr(a, b)¬ρr(a, b)(cid:4)r(a, b)(cid:4)¬r(a, b)The remaining two ABoxes establish the relationship between ρr and r and XC and C . First, we state that the interpretationof ρr coincides with r for all ABox individuals that are not affected by the update U :.U(cid:6)(cid:4)(cid:2)Ar =(cid:3)(a)∃ρr.{b} ↔ ∃r.{b}(cid:5)(cid:5) a, b ∈ Ind(U), r ∈ role(A), r(a, b) /∈ U, ¬r(a, b) /∈ USecond, we ensure that each concept name XC , C ∈ sub(A) represents the extension of C before the update (and thusbehaves like the concept C) by taking the conjunction Cbi of all concepts in Fig. 6, i.e., one biimplication for eachfresh concept name XC , C ∈ sub(A). Note that the biimplication for X A , A ∈ NC, which is given in the first line, statesthat X A is interpreted like A except on the individuals where an update of A occurred. In particular, if A /∈ sub(U ), thenA(a)∈U or ¬ A(a)∈U ¬{a}) is equivalent to (cid:9) and, therefore, the concept in the first line is equivalent to X A ↔ A. On those((cid:16)individuals where an update occurred, the only constraints for X A are those given in Ainit. It can thus be verified that thepossible extensions of X A are precisely the possible extensions of A before the update (in general, there is more than onepossibility, e.g. if A(a) ∈ U and { A(a), ¬ A(a)} ∩ A = ∅). The fresh roles ρr can be understood similarly, with the ABox Arplaying the role of the biimplications for X A . However, there is also one major difference: since we cannot express that ρrhas the same extension as r on non-ABox domain elements, we use r instead of ρr when dealing with such elements. Thisis reflected by the use of both r and ρr in the biimplications for number restrictions.2188H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197Fig. 6. The conjuncts of Cbi.Unfortunately, ALCQIO@ also lacks the expressive power to enforce that Cbi is satisfied by all domain elements. Wethus resort to enforcing that Cbi is satisfied by all ‘relevant’ domain elements, i.e., by all domain elements that can bereached from an ABox individual in A by a sequence of roles that occurs in some concept C ∈ sub(A). Formally, we induc-tively associate with each concept C ∈ sub(A) a set path(C) of words r1 . . . rn ∈ NRas follows, where ε denotes the emptysequence:∗(cid:3)(cid:2){a}= {ε}pathpath( A) = {ε}path(C1 (cid:4) C2) = path(C1) ∪ path(C2)path(C1 (cid:7) C2) = path(C1) ∪ path(C2)path(¬C) = path(C)path(@aC) = path(C)path((cid:2) m r C) =path((cid:3) m r C) =(cid:12)(cid:5)(cid:6)(cid:5) w ∈ path(C)(cid:5)(cid:6)(cid:5) w ∈ path(C)(cid:4)r w(cid:4)r w∪ {ε}∪ {ε}.{path(C) | C ∈ sub(A)}. Now choose a fresh individual name a(cid:4)(cid:3)(cid:3) (cid:5)(cid:6)(cid:6)(cid:5) w ∈ path(A)| b ∈ Ind(A),where ∀w.C abbreviates ∀r1. · · · .∀rn.C when w = r1 · · · rn. Finally, let∀u w.CbiArel =(cid:2)a(cid:2)a, b∪u∗∗Let path(A) =(cid:4)∗and a fresh role name u, and setA(cid:3) = Ainit ∪ Ar ∪ Arel ∪ U.Before proving that A (cid:16)⇒p, we give an example that also illustrates our approach to avoiding the exponential blowupof type (ii) described above. Let A = {a : ∃r. A, a : ∃s.¬ A} and U = { A(a1), ¬ A(a2)} and note that, due to the UNA and sincer does not occur in U , we can simplify a : (∃r. A)U. Thus, the conjunction of U with thefollowing assertion is a simplified version of the semantic update computed by our algorithm:to the equivalent assertion a : ∃r. AUU A(cid:3)a : ∃r. A ∧ a : ∃s.¬ A(cid:3)(cid:2)A (cid:4) ¬{a1}∨ a : ∃r.(cid:3)(cid:2)A (cid:7) {a2}∨ a : ∃r.(cid:2)(cid:2)∨ a : ∃r.A (cid:7) {a2}(cid:2)∧ a : ∃s.¬(cid:2)∧ a : ∃s.¬(cid:3)(cid:3)(cid:4) ¬{a1}A (cid:4) ¬{a1}(cid:3)A (cid:7) {a2}∧ a : ∃s.¬(cid:3)(cid:2)(cid:2)A (cid:7) {a2}(cid:3)(cid:4) ¬{a1}(cid:3).H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972189for U (cid:3) ⊆ U . Intuitively, thisHere, the four disjuncts are due to the fact that we have to take the disjunction over alldisjunction reflects the fact that each of A(a1) and ¬ A(a2) might or might not be satisfied already before the update. Theprojective update is the union of U and the following ABoxes (where we have simplified Cbi by taking into account that forany role r /∈ sig(U ), the right-hand side of the biimplication for ∃r.C is equivalent to ∃r. XC ):(cid:17)AU (cid:3)Ainit = {a : X∃r. A, a : X∃s.¬ A}Ar = ∅(cid:4)Arel =Cbi = (X∃r. A ↔ ∃r.X A) (cid:4) (X∃s.¬ A ↔ ∃s.X¬ A) (cid:4) (X¬ A ↔ ¬X A) (cid:4), ∀u.∀s.Cbi, ∀u.∀r.Cbi∀u.Cbi(cid:2)a(cid:2)a(cid:2)a(cid:2)a, a(cid:3)(cid:6)(cid:3)(cid:6)∪(cid:4)u(cid:3)(cid:3)∗∗∗∗where(cid:2)(cid:2)¬{a1} (cid:4) ¬{a2}(cid:3)(cid:3)→ (X A ↔ A).Observe that the interpretation of X∃r. A and X∃s.¬ A on a1 and a2 is not constrained using a case distinction but by demand-ing that Ainit is satisfied.Lemma 14. A (cid:16)⇒pU A(cid:3).Proof. Assume first that I ∈ M(A)Usymbols distinct from u, aexists a model I0 of A such that I = IU∗. We have to show that there exists a model I(cid:3)that coincides with I for all, the role names ρr , r ∈ role(A), and the concept names XC , C ∈ sub(A). By definition, thereof A(cid:3)0 . Now define I(cid:3)in the same way as I but extended by setting∗(cid:3)I(cid:3)(cid:2)aI(cid:3) :=uρI(cid:3)rI(cid:3)C:= d0,(cid:4)(cid:2)d0, bI0 ,I0 ,Ifor some d0 ∈ (cid:3)I ,(cid:3) (cid:5)(cid:6)(cid:5) b ∈ Ind(A)for r ∈ role(A),for C ∈ sub(A).,:= r:= CIt is easily verified that I(cid:3)XConversely, assume that I is a model of A(cid:3)all concept names A /∈ sub(A) ∩ sub(U ), set A. We construct a model I0 of A such that I = IUI0 = A. For all concept names A ∈ sub(A) ∩ sub(U ), set d ∈ AI0 . Define I0 as follows: forI0 iff:is a model of A(cid:3)and, therefore, as required.1. d ∈ A2. d ∈ XIand d /∈ {aIA and d ∈ {aI | a ∈ Ind(U )}; orI | a ∈ Ind(U )}.Similarly, for all role names r /∈ role(A) ∩ role(U ), set rI0 = rI. For all role names r ∈ roles(A) ∩ role(U ), set (d1, d2) ∈ rI0 iff:Iand {d1, d2} (cid:2) {a1. (d1, d2) ∈ r2. (d1, d2) ∈ ρIr and {d1, d2} ⊆ {aI | a ∈ Ind(U )}; orI | a ∈ Ind(U )}.We show that I0 is a model of A and I = IU0 .Claim 1. For all C(a) ∈ A, I0 |(cid:16) C(a) iff I |(cid:16) XC (a).We show that for all C ∈ sub(A), subconcepts E of C , and words w and d ∈ (cid:3)Ib ∈ Ind(A) and {w v | v ∈ path(E)} ⊆ path(C), we havesuch that (bI , d) ∈ wIfor somed ∈ EI0iff d ∈ XIE .Claim 1 then follows immediately by taking w = ε. The proof is by structural induction on E and uses Arel. We considerthe cases where E is a concept name or of the form ((cid:2) m r F ). First let E = A for a concept name A. Since path( A) = {ε},I | a ∈ Ind(U )},we have to consider all d with (bII | a ∈ Ind(U )}, thenthen d ∈ XA iff d ∈ AII0 iff d ∈ Xd ∈ AA , again by definition of AI(first biimplication in Fig. 6) iff d ∈ Afor some b ∈ Ind(A) and w ∈ path(C). Assume d is given. If d /∈ {aI0 . Otherwise, if d ∈ {aI0 , by definition of AI , d) ∈ wI0 .INow consider the case E = ((cid:2) m r F ). Assume (bI , d) ∈ wIfor some b ∈ Ind(A) and w v ∈ path(C) for all v ∈ path(E).Then wr v ∈ path(C) for all v ∈ path(F ).We distinguish the following cases:• d /∈ {aI | a ∈ Ind(U )}. By the biimplication for X((cid:3)m r F ) in Fig. 6, we have that d ∈ Xwe have that (d, x) ∈ rholds that x ∈ FI0 iff x ∈ XIiff (d, x) ∈ rIF . Thus we obtain d ∈ XI0 . Moreover, for all x such that (d, x) ∈ rIE iff d ∈ ((cid:2) m r F )I0 = EI0 .IIE iff d ∈ ((cid:2) m r X F )II , x) ∈ (wr)I, we have that (b. For all x. By IH, it2190• d ∈ {aH. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197I | a ∈ Ind(U )}. Again by the biimplication for X((cid:3)m r F ), we have that d ∈ Xm1 +m2 = m and m2 (cid:3) |Ind(U )| we have both d ∈ ((cid:2) m1 rThen d ∈ ((cid:2) m1 r(cid:16)previous case. Note that if x = cIF . Thus d ∈ ((cid:2) m2 ρriff cequivalences, we obtain that d ∈ Xb∈Ind(U )¬{b} (cid:4) X F )II(cid:16)I ∈ Xiff d ∈ ((cid:2) m1 rI0 iff (d, x) ∈ ρIfor some c ∈ Ind(A), then (d, x) ∈ r(cid:16){b} (cid:4) X F )Ib∈Ind(U )b∈Ind(U )E iff d ∈ ((cid:2) m r F )I0 = E(cid:16)iff d ∈ ((cid:2) m2 rI0 , as required.b∈Ind(U )¬{b} (cid:4) X F )IIE iff for some m1, m2 such that{b} (cid:4) X F )I.b∈Ind(U )¬{b} (cid:4) F )I0 can be proved analogously to theI0r . Moreover, by IH, c{b} (cid:4) F )I0 . Summing up the previousand d ∈ ((cid:2) m2 ρrI ∈ Fb∈Ind(U )(cid:16)(cid:16)IFrom Claim 1, the condition that I is a model of Ainit, and the definition of rIt remains to show that I = IU0 . First, interpretations of concept and role names which do not appear in U are identicalin I0 and I. Second, I and I0 interpret all role and concept names which appear in U in the same way on the part ofI0 , and the first biimplication inthe domain (cid:3)IFig. 6 imply that for all x ∈ (cid:3)I \ {a. Similarly, for role names r,I ) | r(a, b) ∈ U or ¬r(a, b) ∈ U } it holds thatthe definition of r(x, y) ∈ rI0 and I |(cid:16) Ar imply that for all (x, y) ∈ ((cid:3)I × (cid:3)I ) \ {(a. Thus, since I |(cid:16) U , we obtain that I = IUunaffected by the update U : for concept names A, the definition of AI | A(a) ∈ U or ¬ A(a) ∈ U } it holds that x ∈ AI0 , we obtain that I0 is a model of A.I0 iff (x, y) ∈ rI0 iff x ∈ AI , bII0 . (cid:2)We now analyze the size of A(cid:3)in terms of the size of A and U . Obviously, |Ainit| (cid:3) |A| and |Ar| = O(|U |3). Since|Cbi| = O(|U |3 · |A|) (independently from the coding of numbers inside number restrictions) and |path(A)| (cid:3) |A|2, we obtainthat |Arel| = O(|A|3 · |U |3). Summing up, we obtain |A(cid:3)| = O(|U |3 · |A|3).Together with Lemma 7, we thus obtain the following result, which in particular implies that all DLs between ALCOand ALCQIO@ have projective updates. It is independent of the coding of numbers inside number restrictions.Theorem 8. Let L be a DL between ALCO and ALCQIO@. Then there is a polynomial p such that, for every L-ABox A and everyupdate U , there is an L-ABox A(cid:3)such thatU A(cid:3)1. A (cid:16)⇒p2. |A(cid:3)| (cid:3) p(|A| · |U |);3. A(cid:3);can be computed in time p(|A(cid:3)|).In a context where also TBoxes are available, it might be more appropriate to store the conjuncts of Cbi in a TBox ratherand can avoid the paths of role names altogether.than in A(cid:3)It can be seen that an acyclic TBox suffices, please see [15] to get a more concrete idea.. In this way, we do not need to introduce the new individual a∗We close this section with a brief discussion of iterated updates in the projective case. To start with, we note thatit is possible to repeatedly compute projective updates using the presented construction by simply treating fresh symbolsintroduced by earlier updates as ‘normal’ symbols during all subsequent updates. These updates are then even stronger thannecessary since later updates preserve the meaning of fresh symbols introduced by earlier updates. Unfortunately, it is easyto see that the projective update A(cid:3)that is obtained by starting with an ABox A and then consecutively applying updatesU1, . . . , Un using our construction is exponential in n. In particular, if A = A0, . . . , An = A(cid:3)are the generated projectiveupdates, then it is easy to see that each Ai contains ki · |sub(A)| concept names XC , for some constant k. Despite thisproblem, it is still straightforward to carry out repeated updates without ever obtaining an ABox of exponential size. Thesimple workaround is to keep the original ABox A in memory and then to repeatedly update the updates Ui instead of theprojective updates Ai . More precisely, define a cumulative update(cid:18)Ui = Ui ∪ ((cid:18)Ui−1 \ ¬Ui+1)for 1 (cid:3) i (cid:3) n. When processing the stream of updates U1, . . . , Un, only keep A and the latest cumulative update (cid:18)Uiinmemory. At any time, the ‘current’ projective update is obtained by applying our construction to A and (cid:18)Ui . Clearly, allprojective updates obtained in this way are of size polynomial in |A| and |U1| + · · · + |Un|.6. Conditional updates and reasoning about actionUp to now, we have considered updates U that are unconditional in the sense that all assertions in U are necessarilytrue after the update, not subject to any conditions. In some applications, though, it is more useful to allow conditionalupdates that are able to express statements such as ‘ A(a) is true after the update if C(b) was true before’. In particular,such a generalization is important for reasoning about actions, which has recently been studied in a DL context [12] andwhere ABox updates play a crucial role for implementing the reasoning pattern of ‘progression’, as opposed to ‘regression’approaches [7]. In this section, we introduce conditional updates and show that all results that we have proved for uncon-ditional updates, both semantic and projective, are also true for the corresponding version of conditional updates. As anapplication, we put conditional updates to work for reasoning about action, using the progression approach to reprove theoptimal upper complexity bounds for the projection problem of DL actions that were first established using regression in[12]. The latter results will be based on projective updates.H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972191Let L be a DL between ALC and ALCQIO@. A conditional L-update U is a finite set of expressions ϕ/ψ , where theprecondition ϕ is an L-ABox assertion and the postcondition ψ is, as in the unconditional case, an assertion of one of theformsA(a), ¬ A(a),r(a, b), ¬r(a, b).Intuitively, ϕ/ψ ∈ U means that if ϕ holds before the update, then ψ holds after it. Analogously to the case of unconditionalupdates, we require a consistency condition: if ϕ/ψ and ϕ(cid:3)/¬ψ are both in U , then the ABox {ϕ, ϕ(cid:3)} has to be inconsistent.We now adapt the notion of an interpretation update to the case of conditional updates.Definition 5 (Conditional interpretation update). Let U be a conditional update and I an interpretation. Define an interpreta-tion IUby setting for all individual names a, concept names A, and role names r:(cid:3)IUIUa= (cid:3)II= a(cid:2)IUAIUr=(cid:2)r=AI(cid:4)aI , b(cid:5)(cid:5) ϕ/ A(a) ∈ U and I |(cid:16) ϕI(cid:6)(cid:3) (cid:7) (cid:4)a(cid:3) (cid:5)(cid:6)(cid:3) (cid:7) (cid:4)(cid:2)(cid:5) ϕ/r(a, b) ∈ U and I |(cid:16) ϕa(cid:5)(cid:5) ϕ/¬ A(a) ∈ U and I |(cid:16) ϕ(cid:3) (cid:5)(cid:5) ϕ/¬r(a, b) ∈ U and I |(cid:16) ϕI , bI ∪(cid:4)(cid:2)a(cid:6)III ∪(cid:6).IUis called the result of updating I with U .The conditional versions of semantic and projective updates are defined in the same way as for unconditional updates.We repeat the definition for the reader’s convenience.Definition 6 (Semantic (projective) conditional updates). Let A be an ALCQIO@-ABox and U a conditional update.is a semantic update of A with U , in symbols A (cid:16)⇒U A(cid:3), ifAn ALCQIO@-ABox A(cid:3)(cid:4)(cid:2)(cid:3)A(cid:3)=IUM(cid:5)(cid:6)(cid:5) I ∈ M(A).A description logic L has semantic conditional updates if for every L-ABox A and conditional L-update U , there is an L-ABoxA(cid:3)is a projective update of A with U , in symbols A (cid:16)⇒pU A, if.with A (cid:16)⇒U A(cid:3)An ALCQIO@-ABox A(cid:3)(cid:5)(cid:6)(cid:5) I ∈ M(A)(cid:3)(cid:2)Fr(A(cid:3))IUA(cid:3)=M(cid:4)(cid:2)(cid:2)Fr(A(cid:3)),where Fr(A(cid:3)) = sig(A(cid:3)) \ (sig(A) ∪ sig(U )) is the set of fresh symbols in A(cid:3)conditional updates if for every L-ABox A and conditional L-update U , there is an L-ABox A(cid:3). A description logic L has semantic projectivewith A (cid:16)⇒p.U A(cid:3)Note that conditional updates generalize unconditional ones since assertions ψ of unconditional updates can be ex-pressed as (cid:9)(a)/ψ , with a an arbitrary individual name. It follows that all non-existence results that we have proved inSection 3 for unconditional updates hold for conditional updates as well. Regarding results about the existence of updates,our first aim is to generalize Theorems 3, 4, and 8 from the unconditional to the conditional case. We leave the straightfor-ward generalization of other results such as Theorem 7 to the interested reader. We start with extending Theorem 3.Theorem 9. ALCO@, ALCIO@, ALCQO@, and ALCQIO@ have semantic conditional updates.Proof. Let A be an ABox formulated in one of the DLs in Theorem 9 and U a conditional update. The assertions that occuron the left-hand side of update statements in U is lhs(U ) = {ϕ | ϕ/ψ ∈ U }. Each D ⊆ lhs(U ) corresponds to one possiblechoice of preconditions that are true before the update. For each such D, the ABox(cid:6)(cid:4)PreD = D ∪¬ϕ(cid:5)(cid:5) ϕ ∈ lhs(U) \ Didentifies the models that realize the choice D andPostD = {ψ | ϕ/ψ ∈ U, ϕ ∈ D}is the unconditional update that has to be executed in those models. By Lemma 11, we have(A ∪ PreD) (cid:16)⇒PostD ADwhere2192H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197(cid:13)AD =PostD ∧(cid:14)(cid:13)(A ∪ PreD)U (cid:3).U (cid:3)⊆PostDBy the semantics of ABox updates, it follows that A (cid:16)⇒U A(cid:3)(cid:10)(cid:14)(cid:8)(cid:13)(cid:14)(cid:13)whereA(cid:3) =PostD ∧(A ∪ PreD)U (cid:3).(cid:2)D⊆lhs(U)U (cid:3)⊆PostDIt follows from the construction of A(cid:3)in the above proof that the upper bound on the size of semantic updates given inTheorem 4 still applies in the conditional case. We now consider projective conditional updates, generalizing Theorem 8.Theorem 10. Let L be a DL between ALCO and ALCQIO@. Then there is a polynomial p such that, for every L-ABox A and everyconditional L-update U , there is an L-ABox A(cid:3)such thatU A(cid:3)1. A (cid:16)⇒p2. |A(cid:3)| (cid:3) p(|A| · |U |);3. A(cid:3);can be computed in time p(|A(cid:3)|).Proof (sketch). Assume that A is an ALCQIO@-ABox and U a conditional ALCQIO@-update. To define a projectiveupdate, introduce fresh concept names X A for all A ∈ sub(A ∪ lhs(U )) and fresh role names ρr for all r ∈ role(A ∪ lhs(U )).The additional names for concepts and roles in lhs(U ) are used to represent the preconditions of U that hold in the originalinterpretation. The component Ainit is defined in the same way as in the proof of Theorem 8 by settingAinit =(cid:4)(cid:4)(cid:4)(cid:5)(cid:6)(cid:5) C(a) ∈ A∪(cid:5)(cid:6)(cid:5) r(a, b) ∈ A∪(cid:5)(cid:6)(cid:5) ¬r(a, b) ∈ AXC (a)ρr(a, b)¬ρr(a, b).Set(cid:4)(cid:2)∃ρr.{b} ↔ ∃r.{b}Ar =(cid:3)(a)(cid:5)(cid:5) a, b ∈ Ind(U), r ∈ role(cid:2)(cid:3)A ∪ lhs(U)(cid:6), r(a, b) /∈ rhs(U), ¬r(a, b) /∈ rhs(U)and define Cbiin the same way as in Theorem 8 with the exception that Cbi contains one biimplication for each XC ,C ∈ sub(A ∪ lhs(U )) and U is replaced by rhs(U ) in the implication for X A and the biimplications for qualified numberrestrictions. Let, as before, a(cid:3) (cid:5)(cid:4)(cid:5) w ∈ pathbe a fresh individual name and u a fresh role name, and set(cid:3) (cid:5)(cid:5) b ∈ IndA ∪ lhs(U)A ∪ lhs(U)(cid:3)(cid:6).(cid:2)a(cid:2)a, b(cid:3)(cid:6)∪(cid:4)u(cid:2)(cid:2)∗∗∀u w.CbiArel =∗Instead of including U in A(cid:3)triggered whose preconditions are satisfied. This can be achieved by the ABoxas in the case of unconditional updates, we have to make sure that only those updates areAcond =(cid:9)(cid:4)a(cid:6)∗ :(cid:18)p(ϕ) → p(ψ)∪ϕ/ψ∈U(cid:9)(cid:19)(cid:8)∗ :a(cid:10)¬(cid:18)p(ϕ)→(cid:20)(cid:3)(cid:2)(cid:18)p(ψ) ↔ p(ψ),ψ∈rhs(U)∩O(cid:15)ϕ/ψ∈Uwhere O denotes the set of ABox assertions using concept and role names from A ∪ lhs(U ) only,⎧⎨⎩p(ϕ) =∃u.({a} (cid:4) C)∃u.({a} (cid:4) ∃r.{b})∃u.({a} (cid:4) ∀r.¬{b})if ϕ = C(a)if ϕ = r(a, b)if ϕ = ¬r(a, b)and (cid:18)p is defined like p, but with C replaced by XC and r by ρr . The first line of Acond states that if ϕ holds in the originalinterpretation, then ψ holds in the updated interpretation, for every ϕ/ψ ∈ U . The second line says that if none of thepreconditions of an assertion ψ holds in the original interpretation, then ψ holds in the updated interpretation if, and onlyif, it holds in the original interpretation. Now setA(cid:3) = Ainit ∪ Ar ∪ Arel ∪ Acond.In the same way as in the proof of Theorem 8, one can show that A (cid:16)⇒ppolynomial p such that |A(cid:3)| (cid:3) p(|A| · |U |) and A(cid:3)can be computed in time p(|A(cid:3)|). (cid:2)U A(cid:3). Moreover, by construction, there is aH. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972193We now apply Theorem 10 to the projection problem in reasoning about action as introduced in a DL context in [12]; seealso [25,26,14] for related work. The projection problem means to decide whether a given action achieves a given goal in agiven situation, i.e., whether the goal necessarily holds true after the execution of the action. It is one of the fundamentalproblems in reasoning about action, and many other important reasoning problems can be reduced to it [7]. In the contextof a DL L, the projection problem for L can be formalized as deciding, given• an L-ABox A that describes the situation in which the action is executed,• a conditional L-update U that describes the action, and• an L-ABox assertion ϕ that represents the goal,whether for every model I of A it holds that IU |(cid:16) ϕ. In [12], algorithms for the projection problem for various DLs havebeen given based on the approach of regression, according to which one rewrites ϕ to a new assertion ϕ(cid:3)is aconsequence of the initial ABox if, and only if, ϕ holds after the conditional update. In effect, one thus reduces the projectionproblem to a standard reasoning problem for the initial ABox. The resulting algorithms yield tight upper complexity boundsfor the projection problem for all DLs between ALC and ALCQIO.such that ϕ(cid:3)Theorem 11. (See [12].) The projection problem is• PSpace-complete for ALC, ALCO, and ALCQO;• ExpTime-complete for ALCI and ALCIO;• co-NExpTime-complete for ALCQI and ALCQIO.Interestingly, we obtain an alternative proof of the upper bounds stated in Theorem 11 from our results on projectiveconditional updates. Let L be one of the DLs mentioned in the theorem. Given an L-ABox A, a conditional L-update U ,and an L-ABox assertion ϕ, we can simply compute in polynomial time a projective update A(cid:3)of A with U that is of sizepolynomial in the sizes of A and U and formulated in the extension LO of L with nominals (if not already present in L),and then decide whether A(cid:3) |(cid:16) ϕ. We thus obtain a polynomial time reduction from projection in L to ABox consequencein LO, a problem that is• in PSpace if LO is ALCO or ALCQO [27];• in ExpTime if LO is ALCIO [28];• in co-NExpTime if LO is ALCQIO [29].Thus, the upper bounds of Theorem 11 follow immediately. From the perspective of reasoning about action, this approachcorresponds to projection, i.e., instead of ‘regressing’ the goal ϕ back to the original ABox, we ’progress’ the original ABoxtowards the goal.We remark that the setup in [12] is somewhat more general than the one considered here as it adds acyclic TBoxes,so-called occlusions as part of an action description that allows some concept/role memberships to change freely during theexecution of the action, and establishes the algorithms and complexity bounds for sequences of actions rather than singleones. However, although it is out of the scope of the current paper to go into any details, we conjecture that our progressionapproach can be generalized in a straightforward way to handle all of these extensions. In particular, sequences of actionsdo not increase the complexity of progression-based projection, cf. the remark that closes Section 5.Our proof of the upper bounds in Theorem 11 and the matching lower bounds provided in [12] also have an interestingconsequence from the ABox update perspective taken in this paper. To express projective updates of ABoxes in the DLsALC, ALCQ, ALCI, and ALCQI, thus overcoming the problems identified in Section 3, we have added nominals tothe respective languages in Section 5. In the cases of ALCI and ALCQI, this actually means switching to a language inwhich the standard reasoning problems ‘ABox consistency’ and ‘ABox consequence’ have higher computational complexity:in ALCI, ABox consequence is PSpace-complete whereas it is ExpTime-complete in ALCIO; in ALCQI, ABox conse-quence is ExpTime-complete whereas it is co-NExpTime-complete in ALCQIO. Now, our proof of Theorem 11 and thelower bounds stated there entail that such an increase in complexity between the language for initial ABoxes and the targetlanguage for projective updates is unavoidable (modulo the assumption that the involved complexity classes are distinct) ifone wants projective updates to be of polynomial size and computable in polynomial time: for ALCI, a target languagewith PSpace complexity would prove that the projection problem for ALCI is in PSpace, thus showing PSpace = ExpTime;for ALCQI a target language with ExpTime complexity would prove that the projection problem for ALCQI is in ExpTime,thus showing ExpTime = co-NExpTime.7. Extensions and related workWe discuss some natural extensions of the framework considered in this paper, in particular with TBoxes and moregeneral forms of update. We also survey the relevant literature on updates in description logic and, to some reasonableextent, updates in propositional logic.2194H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21977.1. ExtensionsAs laid out in the introduction, this paper has concentrated on the rather special case of ABox updates where no domainconstraints are present (i.e., no TBox) and updates can only consist of ground literals. Both restrictions are severe fromthe point of view of many applications, and thus it is natural to try and alleviate them. In both cases, this gives rise tosignificant new research challenges, and we only make some basic observations in what follows.We first consider updates that admit compound ABox assertions, i.e., updates are sets of possibly negated assertions C(a)and r(a, b), where C can be a compound concept. Due to the presence of disjunction and existential restrictions, updatescan now be non-deterministic. Even in the propositional case, there is no one-and-only generally accepted semantics fornon-deterministic updates, which has led to many different proposals [8,4,30–34,7]. For the case of DLs, the benefits anddrawbacks of the available semantics still remain to be investigated. Unfortunately, at least under the rather natural WinslettPMA semantics [4], which is based on the idea of minimizing the changes between models of the original ABox and modelsof the updated ABox, it is known that it is impossible to compute the result of updating an ALCQI-ABox and representit in a formalism for which the consequence problem is decidable—no matter whether semantic, projective, approximate,or projective approximate updates are considered. This observation is a direct consequence of the result obtained in [27]that the projection problem for ALCQI (as defined in Section 6) under Winslett PMA semantics is undecidable. It does notseem unlikely that other model-based update semantics induce similar computational problems. It remains an interestingopen problem, however, whether undecidability results can be established already for ALC and ALCI.Next, we consider the addition of TBoxes to the framework studied in this paper. While doing so, we assume that updateshave the original restricted form, i.e., are sets of ground literals. We start with the simple case of acyclic TBoxes, where onlyprimitive concept names are allowed in the update, but no defined ones—see [1] for details on these notions. It has beenshown in [15] how the construction of semantic updates presented in Section 4.1 can be adapted to this case, and howacyclic TBoxes can help to achieve a more succinct presentation of updated ABoxes through structure sharing. All resultspresented in this paper can be easily extended to acyclic TBoxes under the described restrictions of updates. When thisrestriction is dropped, TBoxes (no matter whether acyclic, cyclic, or general) induce the same semantic and computationalproblems as compound concepts in the update. In fact, instead of putting C(a) into the update with C a compound concept,one can equivalently define the abbreviation A ≡ C in the TBox and then use the ground literal A(a) in the update. Thus, weneed an advanced semantics such as Winslett PMA and encounter the same computational problems that were describedabove for updates with compound ABox assertions. We refer the interested reader to [35] for a pragmatic approach to thisproblem in the context of projection.7.2. Related work in propositional logicWe discuss the relationship between updates of DL ABoxes as investigated in this paper and the existing literature onupdates and revisions of propositional logic theories. Since propositional logic is expressively complete, which means thatevery class of models can be described by a formula, the problem of non-expressibility of updates that we address in thecontext of DLs does not exist there. For the same reason, in propositional logic there is no difference between approximateand semantic updates. In contrast, the problem of determining the size of updated or revised propositional theories is ofgreat interest and has been extensively investigated. First examples of exponential blowups in the representation of revisedpropositional theories were given by Nebel [36] and Winslett [4]. A systematic discussion of succinctness issues for a largerange of different update and revision operators is provided by Cadoli et al. in [9]. In fact, [9] seems to be the first paperto make the distinction between semantic and projective updates and to study the impact that this distinction has on thesize of updates.2 We note, however, that the special case of updates by literals (as studied in this paper) is not consideredin [9], where all considered forms of update may involve any propositional formula.7.3. Related work in description logicThe update, revision and evolution of description logic knowledge bases has recently received considerable attention. Inour discussion, we focus on the update literature; summarizing the work on revision and evolution [41,42] is outside thescope of this paper, but see [37–40] and [41,42], respectively.Besides of the work presented here that is based on and extends [15], instance level updates have also been investigatedfor knowledge bases formulated in variants of the DL-Lite family of description logics [11,43]. This family consists of inex-pressive DLs tailored towards capturing conceptual modeling constructs while keeping reasoning, in particular conjunctivequery answering, of very low complexity [2]. Similarly to what we do in the current paper, Calvanese et al. [11,43] investi-gate the problem of updating a DL-Lite ABox by ground literals. In addition, DL-Lite TBoxes serve as domain constraints. Thework presented in [11] assumes a model-based Winslett style semantics for updates and gives a variety of results on the2 Note that Cadoli et al. use a slightly different terminology; e.g., they call an update operator query compactable if it has projective updates of polynomialsize and logically compactable if it has semantic updates of polynomial size. Thus, in the terminology of [9], we have shown that for DLs between ALCOand ALCQIO@, the update operator considered in this paper is query compactable.H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972195existence and size of semantic and approximate updates for the description logic DL-LiteF . Unfortunately, as observed in[43], the fundamental algorithm computeUpdate of [11] is unsound and some expressivity results for Winslett style updatesin DL-LiteF claimed in [11] do not hold. To solve the resulting expressivity problems (as well as examples of non-intuitiveupdates resulting from the interaction between the TBox and the updates), two formula-based approaches to instance levelupdates under TBoxes in DL-Lite are proposed in [43]. For these approaches, updates of polynomial size exist. It would beof interest to investigate in how far such formula-based approach can be extended to the expressive DLs considered in thispaper.TBox level updates have received much less attention than instance level updates. A main reason may be that modifi-cations of the TBox are typically not the result of changes in the application domain, but rather invoked due to the TBoxengineer changing her understanding of the application domain. Thus, on the TBox level the belief revision problem seemsmuch more relevant than the update problem, and the former is governed by different principles. Some pros and cons ofmodel-based and formula-based semantics in this context are presented in [44].8. ConclusionWe have studied updates of description logic ABoxes in the restricted, yet fundamental case where no compound con-cepts are admitted in the ABox and no TBoxes are present. Our results show that, while many description logics do nothave updates, by choosing the right DL (one that includes nominals), it is possible to guarantee the existence of updates.Moreover, by choosing the right notion of update (projective semantic), it is even possible to compute updated ABoxes inpolynomial time. We have also described an application of our results in reasoning about action.Regarding future work, it would be interesting to study less restricted cases where the update U is allowed to containcompound concepts and TBoxes are admitted. Note, though, that this involves some rather serious challenges that we haveidentified and discussed in Section 6. It would also be interesting to consider ABox revision instead of ABox update, forwhich a number of competing semantics are available; see [8,9] and references therein. We believe that the results andtechniques established in this paper would also be useful to deal with those semantics.AcknowledgementsWe would like to thank Franz Baader, Yursi Bong, Conrad Drescher, and Michael Thielscher for ideas and discussions. Thefirst author was supported by the DFG project BA1122/10-2 and the third author by the DFG Graduiertenkolleg 334. Finally,we would like to thank the anonymous referees for helpful comments.Appendix A. Proofs for Section 2Observation 1. E (cid:16)⇒U E (cid:3).Proof. Recall that(cid:4)E = {john : ∃has-child.Happy, mary : Happy (cid:4) Clever}U =E (cid:3) =(cid:6)¬Happy(mary)(cid:2)(cid:4)john : ∃has-child.Happy (cid:7) {mary}(cid:3)(cid:6), mary : ¬Happy (cid:4) Clever.First, let I be a model of E . By definition of IUassertion of E (cid:3)d (cid:14)= maryno such d, then we must have (johnassertion is satisfied.IU and maryis satisfied. For the first assertion, first assume that there is a d ∈ HappyIU and thus the secondandIU ∈ (∃has-child.Happy)IU and thus the first assertion is satisfied. If there isIU ∈ (∃has-child.{mary})IU and the first, we have johnI , mary. By definition of IUI , d) ∈ has-childIU . Thus johnI ) ∈ has-childI = has-childIU ∈ CleverI, we have marywith (john/∈ HappyIUIINow let J be a model of E (cid:3). Let I be the interpretation obtained from J by setting Happydefinition, IU = J and I satisfies the second assertion in E . Moreover, it is obvious that both johnand john, one of which must be the case, imply that I satisfies the first assertion in E . (cid:2)J ∈ (∃has-child.{mary})JI = HappyJ ∪ {maryJ }. ByJ ∈ (∃has-child.Happy)JObservation 2. E −→UALC E (cid:3)(cid:3).Proof. By Point 2 of Lemma 2, it is sufficient to show that the ABoxesE (cid:3) =E (cid:3)(cid:3) =(cid:4)(cid:6)(cid:2), mary : ¬Happy (cid:4) Cleverjohn : ∃has-child.(cid:6)(cid:4)john : ∃has-child.(Happy (cid:7) Clever), mary : ¬Happy (cid:4) CleverHappy (cid:7) {mary}(cid:3)have the same ALC-consequences, i.e., E (cid:3) |(cid:16) ϕ iff E (cid:3)(cid:3) |(cid:16) ϕ for all ALC-ABox assertions E . We have that E (cid:3) (cid:14)|(cid:16) ϕ implies. For the converse, let E (cid:3)(cid:3) (cid:14)|(cid:16) ϕ. If ϕ is a (possibly negated) roleE (cid:3)(cid:3) (cid:14)|(cid:16) ϕ since every model of E (cid:3)is also a model of E (cid:3)(cid:3)2196H. Liu et al. / Artificial Intelligence 175 (2011) 2170–2197assertion, we are done since E (cid:3)model I of E (cid:3)(cid:3)with ar, and individual names a as follows:I0 /∈ Cdoes not entail any such assertion. Hence, let ϕ = C0(a0) be a concept assertion and take a0 . Define a new model J with (cid:3)J = (cid:3)I × Ind(A) by interpreting concept names A, role namesI(cid:4)J =AJ =J =ra(cid:4)(cid:2)(cid:2)a(d, a)(cid:5)(cid:5) d ∈ A(d, a), (e, a)I , a(cid:3).(cid:6)Iand a ∈ Ind(E)(cid:3) (cid:5)(cid:5) (d, e) ∈ rI(cid:6)and a ∈ Ind(E)It can be proved by induction on the structure of C that d ∈ CJC . It follows that J |(cid:16) E (cid:3)(cid:3)0 . If J is a model of E (cid:3)0 /∈ Cthat there is a d ∈ (¬Happy (cid:4) Clever)Jsuch that (johnand aJJ , d) ∈ has-childIiff (d, a) ∈ CI, we are done. Otherwise, J |(cid:16) E (cid:3)(cid:3)for all d ∈ (cid:3)I, a ∈ Ind(E), and ALC-conceptsjointly implyand J (cid:14)|(cid:16) E (cid:3). Distinguish the following two cases:J1. a0 (cid:14)= mary.Then let J (cid:3)J (cid:3)/∈ Ca0J (cid:3)02. a0 = mary.be obtained from J by setting maryJ (cid:3)0J0 /∈ CJ0 , a= asince aJ0 , and C0 does not contain nominals.J (cid:3) = d. By construction and since J |(cid:16) A(cid:3)(cid:3), we have J (cid:3) |(cid:16) E (cid:3). Moreover,J (cid:3)Then let J (cid:3)remains to show that marybe obtained from J by setting has-childJ (cid:3)0 . Let Ω denote the elements reachable in J (cid:3)J (cid:3) ∈ Ω and if d ∈ Ω and (d, e) ∈ rand itfrom mary, i.e., Ω is the smallestfor some r ∈ NR, then e ∈ Ω . It can be shown by inductionfor all d ∈ Ω and ALC-concepts C ; a crucial element of the proof isJ0 /∈ Casset such that maryon the structure of C that d ∈ Cthe observation that, due to the definition of J and J (cid:3)required. (cid:2)J )}. We have J (cid:3) |(cid:16) E (cid:3)/∈ Ω . Obviously, athen yields maryJ ∪ {(johnJ , maryJ (cid:3) = has-childiff d ∈ C, johnJ (cid:3)0/∈ C/∈ CJ (cid:3)J (cid:3)J (cid:3)JJILemma 6.1. Let L be a DL between ALC and ALCQIO. Then for every Boolean L@-ABox, there exists an equivalent Boolean L-ABox;2. Let L be a DL between ALCO and ALCQIO. Then for every Boolean L-ABox, there exists an equivalent non-Boolean L@-ABox.Proof. Concerning (i), let A be a Boolean L@-ABox, and let ϕ be an assertion from A such that @b D is a subconcept ofsome concept occurring in ϕ. Then the ABox A(cid:3)is obtained from A by replacing ϕ with (D(b) ∧ ϕ[(cid:9)/@b D]) ∨ (¬D(b) ∧ϕ[⊥/@b D]), where C[ X/@b D] denotes the concept obtained from ϕ by replacing all occurrences of @b D with X . Using thesemantics, it is easy to see that A(cid:3)is equivalent to A. By iterating this replacement, we will eventually obtain a BooleanL-ABox.Concerning (ii), define a mapping ·∗from ABox assertions in L to L@-concepts as follows:C(a)∗ := @aC∗ := @a∃r.{b}∗ := @a∀r.¬{b}.r(a, b)¬r(a, b)The mapping is extended to Boolean ABox assertion ϕ as follows: ϕ∗∨ with (cid:7), and every assertion ψ with ψ ∗A(cid:3) := {(ϕ∗1to A. (cid:2)n )(a)}, where a is an arbitrary individual name. Using the semantics, it is easy to see that A(cid:3)is the L@-concept obtained by replacing ∧ with (cid:4),. Now, let A = {ϕ1, . . . , ϕn} be a Boolean L-ABox. Define a non-Boolean L@-ABoxis equivalent(cid:4) · · · (cid:4) ϕ∗References[1] F. Baader, D.L. McGuinness, D. Nardi, P. Patel-Schneider, The Description Logic Handbook: Theory, Implementation and Applications, Cambridge Univer-sity Press, 2003.[2] D. Calvanese, G.D. Giacomo, D. Lembo, M. Lenzerini, R. Rosati, Tractable reasoning and efficient query answering in description logics: The DL-Litefamily, Journal of Automated Reasoning 39 (3) (2007) 385–429.[3] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, M. Zakharyaschev, The combined approach to query answering in DL-Lite, in: Proceedings of the 12thInternational Conference on the Principles of Knowledge Representation and Reasoning (KR10), AAAI Press, 2010, pp. 247–257.[4] M. Winslett, Updating Logical Databases, Cambridge University Press, 1990.[5] R. Fagin, G.M. Kuper, J.D. Ullman, M.Y. Vardi, Updating logical databases, Advances in Computing Research 3 (1986) 1–18.[6] H. Katsuno, A.O. Mendelzon, On the difference between updating a knowledge base and revising it, in: Proceedings of the 2nd International Conferenceon the Principles of Knowledge Representation and Reasoning (KR91), Morgan Kaufmann, 1991, pp. 387–394.[7] R. Reiter, Knowledge in Action, MIT Press, 2001.[8] T. Eiter, G. Gottlob, On the complexity of propositional knowledge base revision, updates, and counterfactuals, Artificial Intelligence 57 (2–3) (1992)227–270.[9] M. Cadoli, F.M. Donini, P. Liberatore, M. Schaerf, The size of a revised knowledge base, Artificial Intelligence 115 (1) (1999) 25–64.[10] J. Lang, F. Lin, P. Marquis, Causal theories of action: A computational core, in: Proceedings of the 18th International Joint Conference on ArtificialIntelligence (IJCAI03), AAAI Press, 2003, pp. 1073–1078.H. Liu et al. / Artificial Intelligence 175 (2011) 2170–21972197[11] G.D. Giacomo, M. Lenzerini, A. Poggi, R. Rosati, On instance-level update and erasure in description logic ontologies, Journal of Logic and Computa-tion 19 (5) (2009) 745–770.[12] F. Baader, C. Lutz, M. Milicic, U. Sattler, F. Wolter, Integrating description logics and action formalisms: First results, in: Proceedings of the 20th NationalConference on Artificial Intelligence (AAAI05), AAAI Press/The MIT Press, 2005, pp. 572–577.[13] C. Drescher, H. Liu, F. Baader, S. Guhlemann, U. Petersohn, P. Steinke, M. Thielscher, Putting ABox updates into action, in: Proceedings of the 7thInternational Symposium on Frontiers of Combining Systems (FroCos09), in: LNCS, vol. 5749, Springer, 2009, pp. 214–229.[14] C. Drescher, M. Thielscher, Integrating action calculi and description logics, in: Proceedings of the 30th Annual German Conference on AI (KI07), in:LNCS, vol. 4667, Springer, 2007, pp. 68–83.[15] H. Liu, C. Lutz, M. Milicic, F. Wolter, Updating description logic ABoxes, in: Proceedings of the 10th International Conference on Principles of KnowledgeRepresentation and Reasoning (KR06), AAAI Press, 2006, pp. 46–56.[16] C. Areces, B. ten Cate, Hybrid logic, in: P. Blackburn, J. van Benthem, F. Wolter (Eds.), Handbook of Modal Logic, Elsevier, 2007, pp. 821–868.[17] C. Lutz, D. Toman, F. Wolter, Conjunctive query answering in the description logic EL using a relational database system, in: Proceedings of the 21stInternational Joint Conference on Artificial Intelligence (IJCAI09), AAAI Press, 2009, pp. 2070–2075.[18] P. Blackburn, J. van Benthem, Modal logic: A semantic perspective, in: P. Blackburn, J. van Benthem, F. Wolter (Eds.), Handbook of Modal Logic, Elsevier,2007, pp. 2–79.[19] R.M. Karp, R.J. Lipton, Some connections between nonuniform and uniform complexity classes, in: Proceedings of the 12th Annual ACM Symposiumon Theory of Computing (STOC80), ACM, 1980, pp. 302–309.[20] D. Mundici, Tautologies with a unique Craig interpolant, uniform vs. nonuniform complexity, Annals of Pure and Applied Logic 27 (1984) 265–273.[21] J. Krajícek, Interpolation theorems, lower bounds for proof systems, and independence results for bounded arithmetic, Journal of Symbolic Logic 62 (2)(1997) 457–486.[22] U. Schöning, J. Torán, A note on the size of Craig interpolants, in: Dagstuhl Seminar Proceedings, Internationales Begegnungs- und Forschungszentrumfuer Informatik (IBFI), vol. 06451, Schloss Dagstuhl, Germany, 2006.[23] A. Borgida, On the relative expressiveness of description logics and predicate logics, Artificial Intelligence 82 (1–2) (1996) 353–367.[24] C. Lutz, U. Sattler, F. Wolter, Modal logics and the two-variable fragment, in: Annual Conference of the European Association for Computer ScienceLogic CSL’01, in: LNCS, vol. 2142, Springer, 2001, pp. 247–261.[25] Y. Gu, M. Soutchanski, A description logic based situation calculus, Annals of Mathematics and Artificial Intelligence 58 (1–2) (2010) 1–81, doi:10.1007/s10472-010-9176-z.[26] L. Chang, F. Lin, Z. Shi, A dynamic description logic for representation and reasoning about actions, in: 2nd International Conference on KnowledgeScience, Engineering and Management (KSEM07), in: LNCS, vol. 4798, Springer, 2007, pp. 115–127.[27] F. Baader, M. Milicic, C. Lutz, U. Sattler, F. Wolter, Integrating description logics and action formalisms for reasoning about web services, LTCS-ReportLTCS-05-02, Chair for Automata Theory, Institute for Theoretical Computer Science, Dresden University of Technology, Germany, 2005, http://lat.inf.tu-dresden.de/research/reports.html.[28] C. Areces, P. Blackburn, M. Marx, A road-map on complexity for hybrid logics, in: Proceedings of the 13th Conference for Computer Science Logic(CSL99), in: LNCS, vol. 1683, Springer, 1999, pp. 307–321.[29] S. Tobies, The complexity of reasoning with cardinality restrictions and nominals in expressive description logics, Journal of Artificial IntelligenceResearch 12 (2000) 199–217.[30] K.D. Forbus, Introducing actions into qualitative simulations, in: Proceedings of the 11th International Joint Conference on Artificial Intelligence (IJ-CAI89), Morgan Kaufmann, 1989, pp. 1273–1279.[31] F. Lin, Embracing causality in specifying the indeterminate effects of actions, in: Proceedings of the 14th National Conference on Artificial Intelligence(AAAI-96), MIT Press, 1996, pp. 670–676.[32] M. Thielscher, Nondeterministic actions in the fluent calculus: Disjunctive state update axioms, in: Intellectics and Computational Logic, Kluwer Aca-demic, 2000, pp. 327–345.[33] Y. Zhang, N. Foo, Updating knowledge bases with disjunctive information, Computational Intelligence 16 (2000) 1–22.[34] A. Herzig, The PMA revisited, in: Proceedings of the 5th International Conference on the Principles of Knowledge Representation and Reasoning (KR96),Morgan Kaufmann, 1996, pp. 40–50.[35] H. Liu, C. Lutz, M. Milicic, F. Wolter, Reasoning about actions using description logics with general TBoxes, in: 10th European Conference on Logics inArtificial Intelligence (JELIA06), in: LNCS, vol. 4160, Springer, 2006, pp. 266–279.[36] B. Nebel, Base revision operations and schemes: Semantics, representation and complexity, in: Proceedings of the 11th European Conference onArtificial Intelligence (ECAI94), John Wiley and Sons, 1994, pp. 341–345.[37] G. Qi, W. Liu, D.A. Bell, Knowledge base revision in description logics, in: 10th European Conference on Logics in Artificial Intelligence (JELIA06), in:LNCS, vol. 4160, Springer, 2006, pp. 386–398.[38] G. Qi, F. Yang, A survey of revision approaches in description logics, in: Proceedings of the 2008 International Workshop on Description Logics (DL08),in: CEUR Workshop Proceedings, vol. 353, 2008.[39] G. Qi, J. Du, Model-based revision operators for terminologies in description logics, in: Proceedings of the 21st International Joint Conference onArtificial Intelligence (IJCAI09), AAAI Press, 2009, pp. 891–897.[40] Z. Wang, K. Wang, R.W. Topor, Revising general knowledge bases in description logics, in: Proceedings of the 12th International Conference on thePrinciples of Knowledge Representation and Reasoning (KR10), AAAI Press, 2010, pp. 599–601.[41] G. Flouris, M. d’Aquin, G. Antoniou, J.Z. Pan, D. Plexousakis, Special issue on ontology dynamics, Journal of Logic and Computation 19 (5) (2009)717–719.[42] G. Flouris, D. Manakanatas, H. Kondylakis, D. Plexousakis, G. Antoniou, Ontology change: classification and survey, Knowledge Engineering Review 23 (2)(2008) 117–152.[43] D. Zheleznyakov, D. Calvanese, E. Kharlamov, W. Nutt, Updating TBoxes in DL-Lite, in: Proceedings of the 2010 International Workshop on DescriptionLogics (DL10), in: CEUR Workshop Proceedings, vol. 573, 2010.[44] D. Calvanese, E. Kharlamov, W. Nutt, D. Zheleznyakov, Updating ABoxes in DL-Lite, in: Proceedings of the 4th Alberto Mendelzon International Work-shop on Foundations of Data Management (AMW10), 2010.