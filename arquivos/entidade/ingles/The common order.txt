Artificial Intelligence 95 ( 1997) 357-407 Artificial Intelligence The cornrnon order-theoretic structure of version spaces and ATMSs Carl A. Gunter a,*, Teow-Hin Ngair b, Devika Subramanianc a Department of Computer Science, University of Pennsylvania, 200 South 33rd Street, Philadelphia, PA 19103-6389, USA h National University of Singapore, Singapore c Rice UniversiQ, Houston, TX. USA Received August 1996 Abstract We demonstrate how order-theoretic abstractions can be useful in identifying, formalizing, and between relationships representation that perform computations seemingly dissimilar AI algorithms sets. In particular, we show how the order-theoretic exploiting on partially-ordered for such sets when they satisfy certain special can be used to provide an efficient properties. We use anti-chains and representation in the version space learning algorithm and the assumption-based truth maintenance optimizations system (ATMS). Our analysis allows us to (1) extend the known theory of admissibility of concept spaces for incremental version space merging, and (2) develop new, simpler label-update algorithms for ATMSs with DNF assumption formulas. @ 1997 Published by Elsevier Science B.V. to identify and analyze concept of an anti-chain the basic operations Keywords: Version spaces; ATMS; Concept learning; Truth maintenance; Label update algorithms; Anti-chains; Partial orders; Admissibility 1. Introduction This paper shows how the order-theoretic of partial concept of an anti-chain provides a useful is the for the representation abstraction isolation of a collection of eight primitive operations on anti-chains tion of how these operations representation and a demonstra- the efficient is a key concern. We call this set of operations information. The primary contribution in some circumstances where can be used information of partial * Corresponding author. Email: gunter@cis.upenn.edu. 0004-3702/97/$17.00 PII SOOO4-3702(97)00033-7 @ 1997 Published by Elsevier Science B.V. All rights reserved. 3.18 C.A. Gunter et al. /Art@cial Intelligence 95 (1997) 357-407 and basic properties of the operations is devoted of the paper the anti-chain algebra. The description in Section 2; the remainder algebra. The discovery of a useful algebra of expressions For example, Codd’s practical and semantically that an anti-chain algebra did for query when anti-chains significant are a good representation. algebra will do for knowledge introduction languages, clear database query languages. While of an algebra of relations aided the development of to think representation what Codd’s relational from recognizing it is ambitious insights can be obtained are given of the anti-chain technique. can be a powerful to applications of ATMSs information. in expressing representations truth maintenance The first of these, records dependencies learning based on forming between propositions by maintaining algebra can be useful two well-known for and refining is used for is the approaches the version space concept descriptions to manipulating (VS) algorithm, from examples. This (ATMS) system all of the support two parts: Section 4 the “basic” ATMS, which uses Horn clauses for its base of facts, while Section 5 the use of the “extended” ATM& which extends the basic ATMS by permitting to Horn clauses. Although only a cursory to see that structures to show To show how the anti-chain partial information, we examine partial inductive topic of Section 3. The second, assumption-based algorithm, sets for a proposition. Our discussion studies studies facts in disjunctive knowledge of the VS, ATMS, and extended ATMS representations is required the ideas they embody have many things in common, appropriate mathematical are needed how the methods can share notations, and even code modules. We show that the anti-chain describing for modules end of the paper. Such modules provide an ability based on the anti-chain facts supporting correctness proofs, optimizations, this. An appendix algebra achieves is provided at the algebra to obtain an account of this commonality to share software between algorithms that is rigorous enough form in addition our anti-chain implementing is broken interfaces algebra. normal into Each of the three treatments of partial information representation description techniques of the problem follows to be refinement. In particular, to optimization each of the techniques a similar pattern. First we provide a mathematical solved using ordered structures: notion of information approach of each approach pseudo-code correctness the anti-chain generalizations results of Hirsh provide a generalization extended ATMS. is based on an order-theoretic all employ a common the algorithms based on the use of operations on anti-chains. The essence in is given we explore the basic properties of algebra. For the VS and extended ATMS algorithms we conclude with In particular, we extend of known correctness and [3] for the [7] and Mellish 181 on the admissibility is then described the anti-chain of de Kleer’s choose construct in terms of the anti-chain criteria and algorithms. algebra and rendered of the VS algorithm for the algorithms and simplification interfaces. Once and optimization this description issues using using 2. Representing sets as anti-chains One way to represent a set is to maintain set elements, this can be optimized by maintaining a list of its elements. Given an ordering for the elements of a set in a structure C.A. Gunter et al./Art@cial Intelligence 95 (1997) 357-407 359 like a balanced as a predicate (such as the ability that it is impossible the primitive operations approaches when closure properties. tree. In special circumstances that tests set membership. This has the advantage of greater to represent sets of elements), to implement basic operations efficiently. infinite for a representation the sets being represented a set can be maintained more indirectly flexibility but it may be so general In this section we analyze two that can compromise are known between to have certain order-theoretic these string To begin like taking them as balanced can be used (even introduce to represent like testing whether a particular the discussion with an illustrative example, suppose we must maintain there are circumstances where something to represent in order to represent large sets in this way. We could then use predicates sets is in a of strings of digits, supporting operations set and binary operations the union or intersection of two such sets. We can order digit strings by the prefix order (for example, 01 is a prefix of 012 and 013 but trees of strings, but it may become costly not of 001) and represent a logic capable of expressing to maintain sets; properties of strings and the efficiency of this to use and how expensive approach will depend on the kinds of predicates we expect it will be to test them. However, like a list infinite sets), but where it is not essential of elements to include all elements the whole set. Suppose we know a special fact about the sets of strings that interest us: that they are pre$~ closed. In other words, if s E S for one of the sets S, and s is a prefix of s’. then s’ E S too. In this case we the presence of some do not need to maintain if 01 E S, then 012 and 013 are also can be inferred in S. In particular, we can represent S as a set of strings S’ having that in S’ are prefixes of one another and every element of S has an element no two strings for sets which are of S’ as one of its prefixes. This provides a compact infinite, although only sets that have finitely many distinct prefixes could be represented in this way. To determine of a string s whether has any of the elements of S’ as a prefix. if checking membership if it is not possible to carry out other basic operations with it. For example, given sets S and T represented by prefixes from S’ and T’, how does one represent a set like S U T? This could be done by testing membership this test by elements u E S’ U T’ if there is an using S’ U T’. This can be optimized by removing is a little more element u’ E S’ U T’ such that U’ is a proper prefix of U. The situation complicated in terms of S’, T’. operation, but S n T can also be calculated it is in S, one simply checks whether the representation will be useless from that of others. For instance, in S or T, but we can represent a tree of all of the elements for the intersection is no problem, representation in S because the property Even it 2.1. Upper sets and lower sets Let us now turn to identifying the idea underlying is a set P together with a binary (X 5 y and y 5 x implies x = y), and transitive above example. A poset (X 5 x), antisymmetric y 3 z implies x 3 z.). A set S C P is said to be downward closed or lower and y 5 x implies subset of P that contains S which is denoted by in the relation 5 that is reflexive (X 5 y and if x E S that y E S. Given a set S C P, there is a smallest downward-closed the representation employed 360 C.A. Gunier et ul. /Art@cial Intelligence 95 (1997) 357-407 A lower set Fig. 1. A lower subset of &-r(P), where P = {A, B, C}. Note that x 5 y denotes x > y An example only if, S = 1 S. Dually, S is said to be upward closed or upper if in Fig. 1. It is easy to see that S is downward-closed is pictured if, and It will save us some extra parentheses downward and upward closure bind more strongly For example, is the same as (1s) n (LT). ISn lT later if we assume that the unary operations of than various set-theoretic operations. Notation 1. For a set S, the collection collection of finite subsets of S is denoted FinPwr( S) . of all subsets of S is denoted Pwr( S). The of propositional atoms with a distinguished is finite and consider a specific I finite subset A C: C which we call be the collection of subsets of A; elements of I are the ordering < taking x < y if, form a poset under that the poset in question falsehood. We focus on a distinguished Let us begin by assuming example. Let L: be a language representing assumptions. Let E = Pwr(d) called environments. Environments and only if, x 5 y. Environments will arise later when we discuss as an intuition would allow one upward-closed {A, B, C, D}, then the set of all environments atoms C, D is about their meaning, sets of environments an environment the ATMS algorithms; is a set of assumptions whose truth to derive a given conclusion. We will be interested and operations on these sets. For example, the atom A or both of the in representing that contain atom if A = S = {{A, B, C, D}, {A, B, C}, {A, CD}, {A, B, D}, {A, B), {A,C), {A, D), {A), {CD}, {B, C, D)}. We need only keep the smallest elements S’ of S (the minimal elements), these we can test whether an environment of some X’ E S’. Now, the set of minimal elements of S is and from x is in S by testing whether x is a superset S’ = {{A}, {C, D}} CA. Gunter et d/Artificial Intelligence 95 (1997) 357-407 361 Fig. 2. Representing an upper subset of Pwr( P) by its lower boundary, where P = {A, E, C, D}. A CD the subset ordering is what we will call a boundary representation (for instance, {A} 5 {A, B}) . A picture of this is given under Fig. 2. This represents S via the boundary or set of minimal sets, and these can be represented with their maximal elements, which form their upper boundary. And, in the case of version spaces, we will be representing a subset of a poset in terms of both an upper and a lower boundary. it indirectly of S because in this case, is the lower boundary In other cases we will be working with downward-closed of the set, which, elements. in Returning now to the abstract development, let us say that an element x E S C P is maximal in S if, for every y E S, x 3 y implies y = X. It is said to be minimal in S if y E S and y 5 x implies y = x. Let us denote by max( S) and min( S) the respective elements of S. In a finite poset, lower and upper sets can sets of maximal be represented by their upper and lower boundaries: and minimal Lemma 2. Let P be a finite poset and suppose S 2 P. is a lowerset, then S= Jmax(S). IfS If S is an upper set, then S = Tmin(S). (1) (2) A generalization of this result will be needed later when we consider similar repre- sentations in an infinite poset: Lemma 3. Let P be a poset and suppose S’ is a j%ite subset of P. Then: (1) IS’ = lmax(S’), (2) TS’ = rmin(S>. To see that Lemma 3 is a generalization of Lemma 2, just note that a lower subset S of a finite poset is finite and 1 S = S. The proof of Lemma 3 is illustrative of issues that arise in the representation of infinite sets using finite boundaries. Proof. Let us consider is similar. It is clear that 1 max( S’) & J, S’. So take x E 1 S’. Is there some y E max( S’) such that x 3 y? Let us suppose, on the it must be the case that x is not itself maximal contrary, that there is no such y. Then ( 1)) the proof of (2) 362 CA. Gunter et d/Artificial Intelligence 95 (1997) 357-407 there is some element XI Z x such that x i: XI. Assuming in S’, and therefore we have built a chain of elements x = xa 5 xi 1 xi # x,i for distinct of S’ that is not in (x0,. is maximal that x, assumption that . . 5 X, such that each xi E S’ and i, j < n, we can always extend the chain with an additional element to conclude our . . , x,,} because otherwise we would be forced that S’ is infinite, contradicting and x 3 x,. But this implies otherwise. 0 2.2. Anti-chains What kinds of subsets of a poset can be the boundaries of its upper and lower subsets? Definition 4. Let P, 5 be a poset. A subset S c P is an anti-chain comparable pair of distinct elements, the notation Anti(P) if it contains no that is, if x, y E S and x 3 y, then x = y. We use for the set of anti-chains over P. Lemma 5. Let P be a finite poset. ( 1) The upward-closure operation S H r S is a bijection onto mapping) between anti-chains and upward-closed is, one-to-one and (that subsets of P. (2) The downward-closure downward-closed subsets of P. operation S c--t 1 S is a bijection between anti-chains and The lemma can be proved by demonstrating that min and max are inverses for upward closure and downward closure respectively. 2.3. Computing basic operations on posets using anti-chains The significance bility of representing downward-closed set of elements operations that will interest us: of the relationship operations sets indirectly described by Lemma 5 comes the possi- that we would and in terms of operations on anti-chains. Let S - T be the here are like to perform on upward-closed testing set membership, from from in S that are not in T. Aside l Difference: T ( S - T) where S and T are both upper sets and I( S - T) where S and T are both lower sets. l Union: S U T where S and T are both upper sets or both lower sets. l Heterogeneous intersection: 1 (U n L) and T ( U II L) where U is an upper set and L is a lower set. l Homogeneous intersection: S n T where S and T are both upper sets or both lower sets. A few notes on the form of these operations may clarify that the union and intersection to check It is easy uniformity. is again an upper set. A similar preservation S - T may not be an upper set even the upward-set difference ordinary sections. operation by taking set-theoretic difference. A similar consideration some apparent lack of of a pair of upper sets property holds for lower sets. However, to modify the upward closure T(S - T) of their inter- holds for heterogeneous if S and T are, so it is essential C.A. Gunter et al./Artijicial Intelligence 95 (1997) 357-407 363 Fig. 3. The lower difference S’ -’ T’ of anti-chains S’ and T’ representing boundary R’ of the region R in the figure. the lower sets S and T is the upper Our goal is to describe each of these mathematical chains by which they will be represented mathematically efficiently computationally. so long as it is clear how the collections from the given description. operations in terms of the anti- The description can be given in question can be computed Let us begin with the operation j, (S - T) where S and T are lower sets represented S’ and T’ where S = J. S’ and T = J, T’. We want the anti-chain R’ such to be the set of those elements x E S’ is easy to calculate: one takes each element of T’ in turn and removes all of the elements of S’ that in this way, we are It will be closure anti-chains, by anti-chains that I R’ = 1 (S - T). This set R’ can be shown such that there is no y E T’ such that x 5 y. This collection simply it dominates done. Now, we want helpful of a difference operation but is not itself the difference of the representing so we need to denote - when all of the elements of T’ have been it with a different symbol. We therefore write to describe that this operation this as a binary operation on anti-chains. the downward to remember to represent is intended treated S’ -’ T’ = {x E S’ ) Vy E T’. x $ y} where the superscript 1 is intended as a reminder (via their representation as anti-chains). The desired property is: that lower sets are being manipulated I(S’-‘T’)=J(lS’-LT’). Fig. 3 provides define a picture of the desired result. It is also possible to show that, if we S’ -I’ T’ = {x E S’ 1 ‘v’y E T’. x 2 y} where we write x 2 y to mean that y 5 x, then T(S’-“T’)=T(T,S’-TT’). The union of two sets is easy to represent 1 S’ U 1 T’ = 1 (S’ UT’) . Unfortunately, to take maxima: in these terms. If S’,T’ are anti-chains, then so it is essential S’ UT’ may not be an anti-chain, 364 C.A. Gunter et al. /Artijicial Intelligence 95 (1997) 357-407 Fig. 4. The lower union of anti-chains S’ and T’ representing in the figure. with boundary R’ shown the lower sets S and 7’ is the dark region R pYJGziq Fig. 4 pictures the desired result. Similarly, we define 1 S’U’T’=min(S’UT’) 1 and we have J(S’u’T’) =J,S’uI.T’, t(,S’u”T’) =tS’uIT’. Now, if U is an upper set and L is a lower set, then we wish to calculate lower set generated by) define (upper or of U and L in terms of their boundaries. We the intersection U’ *l L’ = {x E L’ 1 3y E U’. y 3 x} and &Y*‘L’) =y$mJL'). We deliberately tion because intersection has a similar representation: avoid using the intersection it will be used for homogeneous symbol n here for heterogeneous intersec- intersection. The upper heterogeneous u’ *U L’ = {y E U’ ) 3x E L’. y j x) which satisfies T(U’*“L’) =t(tu’nlL’). Fig. 5 provides a picture. (1) Actually, it was not essential to include heterogeneous intersection in our collection of anti-chain operations; it can be defined in terms of the difference operation: C.A. Gunter et al. /Artijicial Intelligence 9.5 (1997) 357-407 365 U’ U’ Fig. 5. The lower and upper heterogeneous intersection of anti-chains CJ’ and L’ representing the upper set Ii and the lower set L respectively. U’ *’ L’ is the thick upper boundary RI, while (I’ e” L’ is the thick lower boundary Ru. Proposition 6. Let P be a poset and suppose that S’ and T’ are anti-chains in P, then (1) S’*‘T’=S’-‘(S’-IT’), (2) S’*lT’=S’-’ (S’-,‘T’). and Proof. We prove the first equation; the proof of the second is similar. Let x be an element of P and let us consider what it means for it to be the case that x E S’ -I (S’ -l T’). By definition, that x E S’, but this means Vz E (S’ -I T’). x 2 z. (2) that x 6 S’ -’ T’. By definition, just in (2) Since S’ is an anti-chain, if, there is some means y E T’ such that x 3 y. But this, together with the fact that x E S’ is just the definition of x E S’ 9’ T’. this is the case if, and only to x # z, so the formula x $ z is equivalent 0 The operations U” and U” can also be defined in terms of difference operations, given the usual set union and intersection operations: Proposition 7. Let P be a poset and suppose that S’ and T’ are anti-chains in P, then (1) S’U’T’=(S’-‘T’)U(S’nT’)U(T’-‘S’),and s’V’T’=(S’J’T’)U(S’nT’)U(T’J’S’). (2) Proof. We prove ( I), the proof of (2) is similar. Suppose x E S’ U’ T’. There are two cases: x E S’ or x E T’. Let us consider the is similar. Now, either there is an y c: T’ such that x 3 y or there is no first, the second such y. If there is one, then the fact that x is maximal in S’ U T’ implies x = y. Thus x E S’ f? T’. If, on the other hand, there is no such y. then x E S’ -’ T’ by the definition of -I. Thus C holds between the sets on the left and right sides of 1. Suppose x E (S’ -’ T’) U (S’ n T’) U (T’ -’ S’). There are three possibilities. If x E S’ -l T’ and there is an element y E S’ UT’ of the lower difference operation, y cannot be an element of T’. If it is a member of S’, then x = y because S’ is an anti-chain. Thus x E max( S’ U T’). The second possibility such that x 5 y, then, by the definition 366 C.A. Gunter et al. /Artificial Intelligence 95 (1997) 357-407 there is some y E S’ U T’ such that x 3 y. If y E S’, then the is x E S’ n T’. Suppose fact that S’ is an anti-chain means x = y; a similar fact holds if y E T’. Thus x must be maximal in S’ UT’. The third case, x E T’ -I S’, has a proof similar to the first case. 0 2.4. Computing homogeneous intersections on lattices Of the eight basic operations we set out to describe, we have now covered six: (U’ and U’), and the two most intersection. (-I and and most homogeneous lower and upper union operations: upper (*I and *‘). This leaves -“‘), intersection lower and upper difference lower and upper the heterogeneous difficult interesting lower Let us focus on homogeneous of upper sets S intersection will be dual. Suppose we want to compute as anti-chains S’ and T’ where S = r S’ and T = t T’. and T from their representations incorrect. To see why, consider a poset P with Taking three elements are b 3 a and c 3 a. If S = {a, b} and T = {a, c}, then S’ = {b} and T’ = {c}. While S n T = {a}, we have S’ n T’ = 0. In this case, the value of S’ fl” T’ clearly needs to be {a} rather than 0. The question, the intersection S’ f? T’ is clearly {a, b, c} where lower and upper the issues with homogeneous the only order relationships the intersection intersection; therefore, Let us consider is how this is calculated. how the intersection example of the poset Pwr(A) particular where A is a finite set of propositional Pwr(A), are the minimal z E T’. This is equivalent to saying then an element x in S f’ T is an element of both S and T, so, atoms. If we are given upper sets S and T of if S’ and T’ elements of these sets, then it is a superset of some y E S’ and some that it is a superset of y U z. Hence of upper sets should be calculated of environments the the subset ordering, under for S n T = {x 1 x 2 y u z for some y E S’ and z E T’}. that it is clear But to the subset ordering) will all be sets of the form y U z where y E S’ and z E T’. So the desired operation of this collection the minimal is given by elements (relative S’ 0’ T’ = min{y U z / y t S’ and z E T’} (3) To calculate problem; removing that is a subset of x. the minimal elements of a finite collection R of environments is not a of R for each element x E R, compare those that are supersets and removing x itself if there is another element of R it to each of the other elements Rather than show that the equation in (3) gives us the desired property, let us look at to other posets besides the problem more abstractly Pwr(A). so that the equation can be applied Definition 8. A poset P, 5 is said to be a lattice if it satisfies is an element I such that _L 3 x for each x E P. is an element T such that x 5 T for each x E P. l There l There l For each pair of elements x, y E P, there is an element x A y called the meet of x and y such that, x A y 5 x and x A y 5 y and, for any z E P, if z 5 x and z 5 y, then z 5 x A y. the following conditions: C.A. Gunter et al. /Artificial Intelligence 95 (1997) 357-407 361 l For each pair of elements x, y E P, there is an element x V y called the join of x and y such that, x 3 x V y and y 5 x A y and, for any z E P, if z ?Z x and z ? y, then z ? x V y. is not the place for a lengthy discussion of the properties of lattices, but it is I, T and the operations A, V are uniquely determined to them by the definition. Other basic properties of lattices This important by the properties can be found to note that the elements ascribed in a source like [ 11. Example 9. The poset Pwr( A), C of environments The meet is x A y = x n y and the join is x V y = x U y. is a lattice where I = 8 and T = A. Let us now consider how to calculate intersections of lower and upper subsets of lattices in terms of anti-chains. Let P be a lattice. For anti-chains S’,T’ of P, define S’ n’ T’ = max{x A y 1 x E S’ and y E T’} (for lattices) and 1 S’ W T’ = min{x V y 1 x E S’ and y E T’} / (for lattices) It can be shown that the following equations are satisfied: J(S’n’T’) =iS’nLT’, T(S’fY’T’) =TS’nTT’. A generalization case in which P fails to be a lattice of these facts will be proved (Lemma 19 to be precise). in the next section when we consider the 2.5. Using pairs of anti-chains to represent convex spaces One of the key ideas exploited in this work is the representation of another kind of subset of a poset called a convex space. Formally: Definition each x, y, z E P, the conditions 10. Let P, 5 be a poset. A subset C C P is said to be a convex space if, for x 5 y 5 z and x, z E C imply that y E C. This defined contained is the order-theoretic to be convex analog of convexity if the elements on a line between any two points in the plane, where a region C is in C are also in C. Convex spaces can be described in a variety of ways. Lemma 11. Let P be a poset and suppose lower sets of P. Each of the following subsets of P is a convex space: that Ul, U2 are upper sets and Li , L2 are 6 nLl UI - Ll LI -u1 Ll -L2 u, - v2. 368 C.A. Gunter et al. /Art@ial Intelligence 95 (1997) 357-407 L’ I LnU Fig. 6. Representation of convex spaces using pairs of anti-chains. Fig. 6 pictures four of these combinations. Two of these will concern us in this paper: a convex space can be represented as l the intersection l the difference of two upper sets. In cases where upper and lower sets can be represented by anti-chains, of an upper set and a lower set, or it follows convex spaces can be represented convex space as the intersection of an upper set with a lower set, we have the following fact. by pairs of anti-chains. For the representation that of a Definition 12. Let P, 5 be a poset and suppose U, L C P. Define B( Cr, L) = {z E P 1 x 5 z 3 y for some x E U and z E L.} Lemma 13. Let P, 3 be a finite poset and suppose C 2 P. Then C is a convex space if, and only if, C = B(min(C),max(C)). In other words, a convex space maximal and minimal elements general, however. For instance, is a convex space, but it has no maximal or minimal element. A small generalization by its sets of - a pair of anti-chains. The result is not true of posets in the collection of rational numbers q such that 0 < q < 1 of in a finite poset can be represented C.A. Gunter et al./Artificial Intelligence 95 (1997) 357-407 369 the lemma would be to allow P to be any poset and restrict C to finite. However, we will also be interested in situations where C is infinite. 3. Version spaces Let us now consider how the anti-chain operations we have described are related the version space algorithm of Mitchell of Hirsh [ 71 and Mellish [ lo], The results add new insights [ 81, which generalize Mitchell’s original construction. to to the ideas For our purposes a concept space is a set of sets P such that 8 E P and UP E P where iYP={aIaEnforsomexEP}. space to note that nothing is partially ordered by set inclusion, in general instances and the elements of P are called concepts. The elements of UP are called that is, x 3 y iff x & y. It is A concept in important particular, P will not typically be the collection of all subsets of UP (this deviation If x 5 y then we say that being than x. A training set’ x is more speci$c the set of positive over a version instances and A & UP is called the set of negative instances. The version space K( r, A) determined by (r, A) is defined by the equation space P is a pair (r, A) where P C UP is called is known about the structure of this poset; than y or we say that y is more general [9] of the concept space). the “representational bias” where A is the complement consistent with the training version spaces as the training set is extended. {u},A) calculating idea was refined by Hirsh and K(r,AU [7] Ic(TU of A in UP. This collection set (r, A). Computationally, In [lo] represents the set of concepts the goal is to calculate new for for any instance a. This this was done by an algorithm from K(I’,A) to the question of how one efficiently calculates {u}) Icu7 Uf294 UA2) in terms of K ( rl, Al ) and K (r2, AZ). He aptly terms the solution for this, which can be viewed as a generalization version space merging algorithm. Our first goal is to show how this algorithm can be understood directly in terms of the anti-chain operations defined of Mitchell’s original approach, in the previous section. the incremental 3.1. Using pairs of anti-chains to version spaces The key observation concerning the representation of version spaces is that the version set is a convex space and may therefore be represented induced by any training space in one of the ways discussed earlier. In particular, [ lo] represents a version space as ’ This is a slight misnomer because a training “set” is actually a pair of sets. 370 C.A. Gunter et al. /Art@%1 Intelligence 95 (1997) 357-407 a pair of anti-chains merging algorithm consisting of its maximal and minimal elements. The incremental is defined in terms of this succinct data representation. Lemma 14. space K (r, A) is a convex space. I” P is a concept space and (r, A) is a training set, then the version by a pair consisting Lemmas 13 and I4 tell us that the version spaces over a finite concept space P can elements. Another of their maximal be represented and upper or lower way to view this, in light of the correspondence sets, is to view a convex space C as a pair consisting of an upper set, J’S, and a lower set, j, G, where S = min( C) is the set of most specific elements of C and G = max( C) is the set of its most general elements. is how to compute and minimal between anti-chains The key question the desired operations on version spaces in terms for equation of these anti-chains. To do this, we first note that we have the following training sets (rr, Al ) and (r2, AZ) : Ic(T1 Uf2,4 UA2) =K:(TI,AI)~K:(T~,A~). (4) that it suffices This means terms of the pairs of anti-chains quite succinctly definition: to be able to compute that represent the intersection in them. We can describe how to do this operations by the following of version spaces of anti-chain in terms of our collection (Sl,Gl) nc (S2,G2) = ((S, f-? g) 2 (cl n’ c2), (S, n* s,) *I cc, II’ c2)) (5) Correctness of the equation is described by the following: Theorem 15. Let P be a finite concept space and (Tz, AZ) are training sets with that is a lattice and suppose (rl , Al ) SI =min(K(Tl,Al)), GI =max(K(rl,Al)), S2 =min(K(r2,&)), G2 = max(K:(r2,A2)). If (&,Gj) and max(C) = G3. = (S,Gl) W (S2,G2) and C = KlTl U r2, AI U AT), then min(C) = S3 The theorem is an immediate consequence of following: Lemma 16. Let CI , C2 be convex spaces that are subsets of a finite lattice P and (S’,T’) = (min(Ct) ,max(Cr)) nC (min(C2),max(Cz)). Then min( Cr n CT) = S’ and max( Ct n C2) = T’. In particular, c, n C2 = B(S’,T’). CA. Gunter et al. /Artijicial Intelligence 95 (1997) 357-407 371 Table I Incremental version space merging algorithm function mergeVS((S1, Gi), let value u = Sl C-P 52 (S2, G2)) = and L = Gl n’ C2 and S3 = U *’ L and G3 = S3 *’ L (S3, G3) in endlet We omit (Lemma 20). the proof since it is similar to the one we give for a more general result From a computational perspective, there is some redundancy in Eq. (5) since the anti- twice each. Moreover, is an optimization the value of the first. A more realistic algorithmic presentation chains S = S, r-P S2 and G = G1 n” G2 are apparently there in calculating given merging appropriate in Table 1 where the program four anti-chain operations. one can make is described is given calculated the second component in pseudo-code if one is of version space the using The basic constructs a brief explanation, G). The form in this pseudo-code will be used in later examples as well. As (S , are written with parentheses and commas: tuples) (and pairs function f (x> = E declares a function describe pair of pairs as an argument. The form f with formal parameter x and body E. It will often be useful the formal parameter as a pattern. For example, the function mergeVS to takes a let D in E endlet evaluates expression E after establishing tion form value and and x1 = El x2 = E2 . . x, = E,, the bindings from declaration D. The declara- in Table 1 is essentially binds each xi in the environment obtained after establishing bindings for xj where j < i. It differs from The calculation in calculating S1 fS’ 82 and Gl n’ G2 only once, of course, the value described but also by using S3 to compute G3 rather than using U = SI n” S2 for this purpose. To see that it is equivalent the following to the value described by Eq. (5), we need only establish the same as those in [7, lo]. in Eq. (5) equation (u*“L)*iL=v*lL. for anti-chains ZJ and L. To see that this implies Table 1 matches the value calculated in Eq. (5), just let U = S, r-P S2 and L = G, nt G2 that the value (SS, G3) computed in (6) 312 C.A. Cunter et al. /Art@cial Intelligence 95 (1997) 357-407 Table 2 Version space learning learnVS(G,S) = (G,S) is good enough function if then else (G,S) let value and (newC, newS) be learned CbetterG, betters) = mergeVS((G,S), CnewG, news)) from new information in learnVS(betterG, betters) endlet endif and substitute have x E (U *’ L) *’ L. Unfolding intersection the assertion yields using Eq. (6). To see why (6) holds, the definitions let us analyze what it means of upper and lower heterogeneous to xELandCIyE(U*“L).yix which means x E L and 3y E U. (3x0 E L. y 3 x0) and y 5 x. But this is clearly equivalent to x E L and 3y E U. y 5 x which is the same as x E U *’ L. The version space learning algorithm itself proceeds by repeated merging of version in assumes that we are given a way to obtain new information spaces. The algorithm the form of a version space; this may be done by extending a training set by examining a new instance, but any method would suit the algorithm. The new information level of accuracy - is merged with the old until the desired is achieved. Pseudo-code of domain knowledge is given in Table 2. for this process the exploitation - including The code there uses a form if B then El else E2 endif a boolean B and, depending which evaluates evaluates expression El or E2 respectively, function is used by being invoked on an initial version space. on whether its value is true or false, the resulting value. The 1earnVS and returns 3.2. A simple concept learning example We illustrate simple concept of objects of UP. the theoretical learning problem in the context of a space UP is a set identified by their shape and color. The concept space P is a set of subsets in this section [ 10 J . The instance introduced from concepts adapted UP = {Redo, Redo, BlueO, BlueO}, C.A. Gunter et al. /Art$cial Intelligence 95 (I 997) 357-407 373 P = (8, {Redo}, {Redo}, {BlueO}, {BlueO}, {RedQRedO}, {RedO,BlueO}, {BlueO,BlueO}, {RedO,BlueO}, UP}. Note that only 10 of the 16 possible bias provides elements of P are ordered by subset the means of making non-trivial generalizations subsets are represented in P. This concept space instances. The of observed inclusion. Thus, {Redo} 3 {Redo, BlueO}. Consider the version space generated by the training set (0, {BlueO}): X(0, {BlueO}) = {x E P 1 8 C x L UP - {BlueO}} = (8, {Redo}, {Redo}, {BlueO}, {RedCt,RedO}, {RedO,Blueo}}. that represent the minimal and maximal boundaries of this version space The anti-chains are: Sl = {0}, Gt ={{Red~,RedO},{Red~,BlueO}}, NOW consider the version space generated by ({RedCl}, 0) : K({Redn}, 0) = {x E P / {Redo} c x C UP} = {{Redo}, {RedO,RedO}, {RedU,BlueO}, {Redo, BlueO, Redo, BlueO}}. The anti-chains that represent the boundaries of this version space are: SZ = {{Redn}}, G2 = {{Redo, Redo, Blueo, BlueO}}. We now show the steps in the computation of K( {Redo}, {BlueO}) = X(0, {BlueO}) x((Redn}, 8) in terms of the anti-chains them (Table 1). that represent r- x({Redo}, {BlueO}) = {{Redo}, {RedO,RedO}, {RedO,BlueCl}}, St nU 5’2 = {{RedO}}, GI n’ G2 = {{Redo, Redo}}, {Redo, Blueo}}, S3 = (St nu s2) *u (G, n’ G2) = {y E (Sl flu S-2) 1 3x E (Cl dG2) y -: x} = {{RedO}}, G3=(S3 *t (GI n’G2)) = {x E (GI d G2) 1 3y E S3. y I x} = {{Redo, Redo}, {Redo, BlueCi}}. We can easily see that a( S3, G3) = K( {Redo}, {BlueO}). 374 C.A. Gunter et nl. /ArtQicial Intelligence 95 (I 997) 357-407 Fig. 7. Quasi-meets and quasi-joins 3.3. More general concept spaces We have now shown how operations on version spaces are calculated if the concept space is a finite lattice, but is there a way to work with spaces that are not finite lattices? that the and sufficient condition We now describe a necessary incremental is usable, at least in principle. The key idea is to identify update algorithm what we need to be able to compute; this is given by the following: for when we are assured Definition 17. Let P, 3 be a poset x, y E P. The quasi-meet of x and y is defined by the equation xAy=max{z E P 1 z 5x and z 5~) and the quasi-join of x and y is defined by xOy=min{zEPIz?xandz>Y) In [8], JxAy If P is a lattice, is called bb(x,y) and fxOy is called aa(x,y). then it is easy to cheek that we are dealing with lattices, quasi-meets to meets and joins. However, are singletons. A graphical so, in the event correspond quasi-joins in Fig. 7 where x vy = {gt , a concept generalizations” space, it is not always that x A y = {x A y} and x v y = {x V y} basically and is given the poset P is and quasi-joins the case that quasi-meets using a Hasse diagram . . , s,}. When representation . . ,g,,} and x A y = {si,. the elements of set x V y are sometimes of x, y and those of x A y are called “most general specializations” the “most specialized called of x, y. It is not sufficient to know simply that these operations to know how to compute quasi-meets can be used to compute anti-chains it that are this is a special property of the concept and quasi-joins; to represent version spaces. However, is essential needed C.A. Gunter et al. /Artificial Intelligence 95 (1997) 357-407 375 space. Just as we defined a lattice to be a poset on which there are operations A, V with special properties, we need an analogous definition: Definition 18. A poset P is said to have property W if l min( P) is finite and P = r min( P) and, l for each X, y E P, the quasi-meet xii, .v is finite and l(xhy) = {z E P I z 5 x and z 5 y}. is said to have property M if l max( P) is finite and P = 1 max( P), and l for each X, y E P, the quasi-join x V y is finite and T(xVy) = {z E P I z k x and z t-y}. poset that has both properties is said to have property MW. from theory (where (where in topology Property M is familiar ideas mulation of an important property of compact subsets called “coherence” domain it is a necessary condition closure properties need for finite quasi-meets duced a top and bottom element hold. for- [ 151) and in for the bases of domains with good the of pairs of elements of P, and by fiat intro- for P so that the first part of the M and W properties it is an order-theoretic in [ 81; he too noted these conditions [ 141). Mellish and quasi-joins identified Given an MW poset P, we can now express in greater generality how the intersection of two upper sets or two lower sets can be carried out in terms of their representation as anti-chains. We define Sn’T’=max(U{x,iylxtS’andyET’)) (forMWposets) and S’ fY’ T’ = min(u{x D y / x E S’ and y E 7”}) (for MW posets) ,A that although P may be infinite, if S’ and T’ are finite, then S’ n’ T’ are also finite. The definition of fY is the same as given in Eq. (5) although Note, in particular, and S’ VT the operations used there should be taken on MW posets. That is, the definitions of *I and *’ are unchanged, but those for f? and nU are the ones just given. Lemma 19. Let P be a poset and suppose S’, T’ are anti-chains in P. (1) IfP hasproperty W, then L(S’f?T’) (2) IfP hasproperty M, then T(S’fFT’) =Is’nlT’. = TS’flTT’. Proof. We prove ( 1) ; the proof of (2) that x E J, (S’ f? T’) . Then there are elements y, U, u such that x 3 y where y E u A u and u E S’ and u E T’. This means that x 3 u and x _i ~1 so x E 1 S’ n I T’. is dual. First suppose 376 CA. Gunter et al./Art@cial Inrelligence 95 (1997) 357-407 Now suppose that x E 1 S’ and x E 1 T’. Then there are elements ua E S’ and uc E T’ such that n 5 ~0, ua. By property W we must therefore have x E J ( uo A ~0) , so x is an element of 1 X where ~=u{uAuIx~S’andy~T’} The set X is finite, so, by Lemma 3, 1 X = J(max( X) ) = 1 (S’ n’ T’) as desired. 0 Lemma 20. Suppose P is an MW poset and Cl, C2 C P are convex spaces where the sets S1 = min( Ct ), Cl = max(Ct), S2 = min(Cz), G:! = max(C;?). are finite and the equations Cl = B( S1, Cl ) and C2 = B( ST, G2) hold. If (S’,T’) = (min(Ci) ,max(Ct)) nYmin(C2),max(C2)), then min( Ci n C2) = S’ and max(Ct n C2) = T’. In particular, Cl n C2 = B(S’,T’). Proof. The desired result follows from Lemma 13 if we can show that min(Ci n C2) = (Si V S2) *’ (Gi f? G2) and max(Cr nC2) = (Si nU S2) *’ (Cl i-7 G2). Let us do the first of these, the second has a similar proof. Starting with Eq. (1) and Lemma 20 we calculate: T((Sl n”S2) *u (Gi n’G2)) =Tum ms2mwl fuG2)) =~((?‘slnlGl)n(rs2nlG2)) = T(B(SI,G) nB(S2,G2)) = wl n c2). It is not difficult The desired equation therefore follows. 0 to check that if U’ is an anti-chain and U = t U’, then U’ = min( U). 3.4. Necessity of properties M and W The MW property is not a difficult condition to satisfy. For instance, any finite poset has property MW and any lattice has property MW. But are there examples of concept is spaces on which not satisfied? We now show that it can essentially be claimed spaces for which the anti-chain in Table 1 depends can only make sense for a poset that satisfies space merging could be used but where MW on which the algorithm the MW property. representation that concept incremental version C.A. Gunter et al. /Art$cial Intelligence 95 (1997) 357-407 371 The key assumption underlying the anti-chain of a convex space is that in this way have the form a( S, G) where S and representation the convex spaces G are finite anti-chains. Some vocabulary that are represented is helpful here: if max (S) representable Definition 21. Let P be a poset. A lower subset S of P is said to be finitely repre- is finite and S = 1 max (S). A upper subset T C P is said to be sentable is finite and T = t min(T). A convex space C C_ P finitely is said to be finitely are both finite and C = a(min(C),max(C)). if min(r) representable if max( C) and min(C) In these version spaces: terms it is possible to express succinctly the Admissibility Theorem for Theorem 22 (Admissibility). If, for every Let P be a concept space that satisfies property ME! instance a, the convex spaces K({a},0) and K(Q), {u}) are finitely representable, then so is K( P, A) for any training set (P, A). for properties M and W concerning Proof. Note first that Ic( 8,Q)) = B(min( P), max( P) ) is finitely conditions Eq. (4) says that it is possible spaces of the forms K({a},0) that such collections representable. finitely by the the collections min( P) and max( P). of convex as intersections ase d on Lemma 20 and our assumption it follows and K(@,{a}>.B representable, that K(r, A) must also be to express other collections representable are finitely 0 Theorem 23. Let P be a poset. If the set min( P) representable upwards-closed (1) is finite with P = T min( P) and intersections of finitely- subsets are finitely representable, then P has prop- (2) erty W If the set max( P) representable upwards-closed is finite with P = J. max( P) and intersections of finitely- then P has prop- subsets arejnitely representable, erty M. ( 3) If the poset P is itself a finitely-representable convex space and if intersections of its finitely-representable convex subsets are finitely representable, then P has properties M and W the others have similar proofs. Let X, y E P and let L = l(x) f? Proof. We prove this Since l(y). such representable, max( L). Since L = {z 1 z 5 x and z 3 y}, it follows intersection so suppose L’ is an anti-chain (1); is an of finitely representable sets it must be finitely that L = I L’. In this case L’ = that L’ = x K y. Hence I(xAy) = {z E P 1 z 3 x and z 3 y) and this means that P has property W. q Theorems 22 and 23 significantly extend in [ 7,8, lo]. They provide a direct means the known for verifying whether theory of admissibility the anti-chain presented repre- 378 C.A. Gunter et al. /Artijicinl Intelligence 95 (1997) 357-407 adopted by the version sentation sequence and a concept on each element of the set of training language instances. space algorithm is correct that satisfies the MW property for an arbitrary training in terms of its behavior 3.5. A complex concept learning example We now turn to a more complex example of a concept space in order to illustrate of the version space (fr) subsets of fr subsets in the admissibility of finitely representable the role that properties M and W may play algorithm. Theorem 23 says that if intersections an fr poset P are always fr, then P has property MW. Since the version space algorithm this result is clearly relevant. However, relies on intersecting to get fr subsets, of all it may be the case that the algorithm does not actually need to take intersections then no possible pairs of fr subsets. problem will arise. To illustrate how this can happen, we examine axis-parallel was introduced learning methods. the task of learning labeled points on the plane. This problem in the geometric analysis of subsymbolic on a plane in [ lo] and has applications it does take are always If the intersections rectangles finite, from is represented as a conjunction Consider an integer grid imposed on the xy plane. Labeled examples are points (x, y) rectangle. The on the grid marked as either being inside or outside the target axis-parallel target rectangle intervals over the natural numbers N. We now formally define the set UP of instances and the set P of concepts composed of elements learning of example, instances. as the product of a pair of closed, half-open, or open intervals on x and y. To be precise, suppose R E { <, <}, and define: concept representational generalization In particular, P consists of those subsets of UP that can be represented that are subsets of UP. As in the previous in P to permit non-trivial bias is introduced of two closed P={{(x,y) j [ZRxRrlA[bRyRtl}/1,~,b,tENu{~}}, UP={(x,y) IxENandyEN}. in) open, half-open, or closed rectangles The elements of P are (points to whether both defining is half-closed, or both intervals are open, at least one interval intervals are closed. This poset has the empty rectangle as a least element and UP as a two elements p and 4 in P to yield greatest one. Let us define the A operation between in both p and q. Let us the largest axis-parallel define rectangle on the grid that contains the operation V between elements p and q in P to be the smallest rectangle on the grid that is contained them both if there is one. To see where this proviso about existence comes from, consider the rectangles corresponding RI = {(x,y) 10 < x < 20 and 0 < y < 30}, R2 = {(x, y) 1 10 < x < 30 and 0 < y < 30). is not an element of P, and it is not difficult Their union element of P that contains is true: property M fails! To see why, note that it is not just to see that there is no least them both. That is, RI V R2 is undefined. But more that this the case that there is no C.A. Gunter et al. /Artificial Intelligence 95 (1997) 357-407 319 least element it. in P containing RI U R2; there is also no minimal element in P containing Let us put these concerns aside for now and focus on how the algorithms the partially defined operations for conjunction is a closed target concept and 2 are carried out using tion. The Should 1 > r or b > t we have the empty set inclusion inclusion by checking construction 2. Because of the special representations of anti-chain for inclusion rectangle defined as I < x < r and b 6 y < t. rectangle. The ordering 5 on P is that of in P, we can check set in the x and y intervals. We will use this fact in the form of the elements of the version space. in Tables 1 and disjunc- We calculate the version space given by the training ( 11, 11) as a positive sume thatthey definition, arelearned instances and the point in thefollowingorder: set having (12, 12)) ( 13, 13) as a negative one. Let us as- the points +(12,12),-(13,13),+(11,11).By K({(12,12)},0) = {SE P \{(12,12)} c s c UP}. The anti-chains SI and Gl representing K( { ( 12,12)}, 0) are sets of elements of P. In and G, this example, Sl and Gi are singletons: St contains a point rectangle at (12,12) is the half-open left corner at (0,O) and its top right corner at (oo,co). rectangle with its bottom S, ={(x.y) 1 12 Q x < 12 and 12 < y < 12}, G, = {(x, y) IO 6 x < 03 and 0 < y < oc}. Now, (13,13) is a point outside of our target closed rectangle so, by definition: X(0, {( 13,13)}) = {S E P 1 0 C S c. UP- {(13,13)}}. While S2 is a singleton consisting of the empty rectangle, G:! consists of four elements in P denoting four rectangles on the plane the point ( 13,13) : that exclude s2 = {0}, G~={{(x,y) 10 6 x < 13 and 0 6 y < 13}, {(x,y) IO < x < 13 and 13 < y < co}, {(x,y) I 13 < x < co and 0 < y < 13}, {(&Y) I 13 < x < 00 and 13 < y < 00)). We now calculate the anti-chains representing the version space the construction in Table 1. Each element using or closed rectangle. The pairwise V between rectangle G1 yields in Sr. The pairwise A operation between elements the elements in G2 in turn. the elements in an anti-chain in SI and S2 yields is an open, half-open, the point in in G2 and the element 380 CA. Gunter et al. /Art@cial Intelligence 95 (1997) 357-407 SI flu S2 =min{p V q 1 p E 4 and q E &} ={(x,y) 1 12 < x < 12 and 12 6 y < 12}, Grf~‘G~=rnax{p~qIp~S~ andqE&} ={{(xvY) 0 < x < 13 and 0 < y < 13}, {<XT Y) {t&Y) I<% Y> 0 < x < 13 and 13 < y < oo}, 13 < x < 03 and 0 < y < 13}, 13 < x < 00 and 13 < y < CXI}}. To obtain the anti-chains Ss and Gs representing the boundaries of ~({(12,12)}~{(13~ 13))) we complete the last two steps in the algorithm in Table 1: Ss = (Sr nU Sz) *a (Gr n’ G2) = {P E 6% nU S2) I 3q E WI f-f G2) P 5 4) ={(x,y) I 12 <x < 12 and 12 < y < 12}, G3 = (Sr V S2) *’ ( GI n’ G2) = {q E (G1 n’ G2) I 3 E (SI ws2) P 15 4) ={(x,y) IO 6 x < 13 and 0 6 y < 13). As expected, Ss is the point rectangle at (12,12) its bottom not included in this rectangle. left corner at (0,O) and its top right corner at (13,13) where (13,13) and G:! is the half-open rectangle with is The version space for the positive instance ( 11,ll) is represented by the pair (S4, G4) where &={(x,y) I 11 <x < 11 and 11 < y < ll}, G4={(x,y) IO < x < cc and 0 < y < ce}. When we merge this with (Ss, Gs), boundary is the upper boundary remains Gs, but the new lower SS = {(x,y> I 11 <x < 12 and 11 < y < 12}, Let us return now to the question of why the algorithm since this is the value of S3 fP S4, a closed square with corners at ( 11, 11) and ( 12, 12). to work (at least on though property M fails. The need for property M arises from the the example) even lower set boundaries, which serve as the use in the algorithm of quasi-joins it is not hard to see that not lower boundaries every concept in P could arise as an element of a lower boundary S of a version space when only training sequences of points are used to generate version spaces. To see why, note that the lower boundary of a version space will always be a single closed rectangle, of the convex version spaces. However, to calculate seems C.A. Gunter et al. /Artificial Intelligence 95 (1997) 357-407 381 than training rectangle containing (most specific) in fact, be the smallest sequence. Our counter-example the positive which will, to property M was obtained instances of the training by attempting to take the union of a closed rectangle with an open one - a situation that will not arise in the algorithm unless new convex spaces are learned by some other the upper boundaries of version means that do not spaces in this concept space are always open rectangles that we cannot include stipulate since to Table 2, the test good-enough must be defined this will never happen! So, referring to test that S and G are singleton them is a border of width 1 around S. is “learned” when S and G in the version space coincide sets such that the difference between sequences of points. By contrast, their finite boundaries). has the consequence (that is, rectangles This heterogeneity that a concept to say this, space of closed rectangles while In general terms, space representation space. Another way rectangles. To incorporate the success of the version in a concept in one of open for this concept lie in special is that the specific concepts the general concepts theory our this section would three partial orders: one for upper bound- upper and lower boundaries. space can be seen as relying on the fact that upper and lower boundaries subsets of the concept are represented are represented such as the one we have described view of version aries, one for lower boundaries, The first of these must satisfy property M and the second must satisfy property W. The order for comparing upper and lower does not need to satisfy any order-theoretic properties, version space merging algorithm, where tersections. We will not attempt a further elaboration paper. to execute it will be used to compute heterogeneous in to accommodate but, of course, we must be able the in- in this and one for comparing of this generalization require generalizing this into a general to compute it in order spaces 4. Assumption-based truth maintenance systems relative involved to a given is a structure [2,3] which can be based in this section theory. Our goal An Assumption-Based System to compute in the ATMS can be expressed Truth Maintenance is intended (ATMS) sets of assumptions introduced on which a is to in terms of anti- the ATMS and reveals efficient for the calculations. the ATMS, we need some ideas from logic. We work with a language as falsehood. by de Kleer conclusion show how the computations chains. This provides a semantic basis for understanding representations Is To describe of propositional In general, atoms will be denoted with lower case letters a, 6, c from the beginning of the Latin alphabet. Propositions the usual logical connectives disjunction. A theory 3 where an atom a is interpreted M interprets 4 as true with the usual truth table interpretation of the logical connectives. We write 3 + C#J if each model of the elements of 3 a theory 3 is a set of propositions. A model M is a subset of C - {I} true if, and only if, a E M. We write M + C$ if that includes an atom I standardly if it has no models or, equivalently, 1 for negation, A for conjunction, is also a model of $. We say that 4, I/J are built from atoms using for implication, is inconsistent (or formulas) and V for if 3 k 1. interpreted as being atoms * 382 C.A. Gunter et ul. /ArtiJicial Intelligence 95 (1997) 3.57-407 As we discussed in an example earlier, we let A be a finite subset of C whose the subset ordering. Assumption elements we call assumptions under A, B, C to help distinguish lower case letters x, y, t from near the end of the alphabet. the poset of environments & to be Pwr(d) atoms may be written using upper case letters them from general atoms. Environments will be denoted with and define Given a theory .ZF and assumption set A, an ATMS is designed to efficiently calculate the collection of nogoods, defined as N(F) ={xEE~.RJx~:I} and, for each a E L, the set V(~,a)={xEE(~Ux#Iand3Ux/=a}. In practice, this function is invoked more often on different as than on different 3s so the primary computational goal of the ATMS is to calculate the function &(a) = V(F, a) typically notation, representing let us also write NT = N(F). it as a hash table look-up on the atoms in L. For uniformity of There are several important observations that aid the design of an efficient represen- tation of this computation. First, let us note that: Lemma 24. V’(a) S & is a convex space. as a pair of anti-chains. This is done in [ 2,3] as the diference So it can be represented of two upper subsets of &. The efficiency of this representation share a common upper boundary the subsets V’(a) in terms of the nogoods. In particular, we can simply maintain mapping atoms to anti-chains effectively in E: owes to the fact that that can be computed function the following J%(Q) = i min{xEEjFUx+J_} min{xEEI~Ux#_land~Ux~a} if a = I, ifa# 1. Knowing LF allows us to compute all of the desired values. Example 25. If _4 = {A, B, C, D} is an assumption set and F is a theory such that b_(a) = {{A, B}, {C}} and &(1) = {{CD}}, then &(a) = {{C},{A,~},{A,C},{A,D),(B,C},{~,~},{A,~,C},{A~B~~}} can be represented space V’(a) as the difference of the upper sets t L.ZF (a) and T LF( I). The convex is illustrated as the lightly shaded part of Fig. 8. Lemma 26. Given a theory F and assumption set A, (1) NF=tLF(j). (2) Ma> = (t LAa)) - (t LA-L>>. C.A. Gunter et al. /Arfificial Intelligence 95 (1997) 357-407 383 Fig. 8. The convex space VJZ(~) of environments represented as the difference of two anti-chains LF(N) = {{A,B},C} and LF(~) = {{C,D}}. In practice, it is more efficient to use a boundary representation and work with LF( I) and LF( a) -’ LF( 1) of I and a respectively. Knowing from them: than with NT and VF( a), These sets are called the labels [ 21 the labels is sufficient because we can reconstruct V3 7(&(a) -’ b(l)) - T LFLJ-) = l‘(I’b(a) - T b_(l)) - N3 =T(TWa) - NF) -NT = (Tk(a)) - NF = VF(LI). So, referring back to our earlier discussion mization represents the convex space of interest as the difference of two upper sets. surrounding Lemma 11, the proposed opti- 4.1. The ATMS interface type about assumptions as an abstract data that justify propositional above. It is used by a client problem-solving An ATMS can be understood described there of course. FinPwr( C) is the collection of finite sets of propositional creates an ATMS based on a given set of propositional in terms of the semantic to cache system atoms. The ATMS data type is in Table 3. The ATMS data type itself is denoted atoms. atoms that interpretation inferences defined by the three operators given atms The function which plays associates with each atom a E A, the label {{u}}, and with each atom b E L - A, the empty label is an anti-chain update this (finite subsets of A), The function and initatms the role of the assumption set A. This function generates an ATMS of the interface: given a theory in the poset I of environments the label of a propositional (set of propositions) label. The function is the work-horse computes atom; label 384 C.A. Gunter et nl.MrtQScial Intelligence 95 (1997) W-407 Table 3 The ATMS interface init_atms label update : FinFWr(L) + atms : L x atms + Anti(E) : theory x atms + atms an ATMS, it produces an “updated” ATMS with labels provided by the new theory into the labels determined which the initial ATMS has been updated. that incorporate the information by the previous theories with of the basic operations on anti-chains with the basic operations on the desired functionality implementable manner. For to compute can all be succinctly for the ATMS instance, The combination the ATMS provide clear, and efficiently is meant the ATMS The same is true for most of the functions latter, consider arguments if, in the label of a, there other words, x has a (consistent) In terms of our ATMS and anti-chain this is simply Tables 3, A.2, and A.3), is a consistent an atom a E /Z and an environment extension the function node-consistent-with? x E &; it returns environment to an environment interfaces (that in a modular, the functions semantically [2] in from that expressed using our interfaces. the from [4, p.4401. This takes as true y that is a superset of x. In from which a follows. in is, in terms of the operators the boolean value in [4]. To see some examples lowerrmember( label( a, theATMS), x) the upper [4] as useful of in theATMS where is a member ple, described supporting-antecedent? ronment x as arguments; x. In terms of our interfaces, mathematical is the ATMS of interest. upper-member(A, set corresponding to the anti-chain A. Another inference E) checks if element E exam- is a function . . , a,} and an envi- in S holds in S’, x) where, with some mixing of of the atoms engines” which it checks whether takes a set of atoms S = {al,. the conjunction this is upper-member( and programming notation, for “sophisticated S’ = label(ul , theATMS) fl” . . . flu label( a,, theATMS). the binary operation upperhomogeneousintersection, Using calculated by using We can extend our interface the analog of the Common Lisp utility apply. information to provide additional the anti-chain S’ is to a client problem solver. For example, we can include a function atoms : atms -+ FinPwr(L) set of atoms mentioned in the current to ask for the collection of atoms theory of the ATMS. that are “believed” to a given environment X. This collection it possible the (finite) which returns This would make relative it can be calculated by collecting is a superset of an element of L = label( of such an element holds just it seems unlikely that one will want a, theATMS). in case upperrmember(L,x) to actually is sometimes called the context of x; such that x In particular, x is a superset to true. However, form the context of an environment is equal all of the atoms a in atoms(theATMS) C.A. Gunter et al./Art$cial Intelligence 95 (1997) 357-407 385 solver. the function as a set; in most cases one will want to know only whether an atom is in the context determined and upper-member of the ATMS requires the client problem and this can be learned label to atoms. On the other hand, an implementation by a given environment, without so there is no cost in making from the functions the function it available recourse atoms, to explain-node in [4, p. 4421) described interface. This function as arguments; in [4] requires an extension of a takes (described it returns a proof for the atom based on of from from To provide different nature to our basic an atom and an environment the theory of the ATMS and the given environment. the ATMS we have chosen not to keep any information assumptions, retaining only which a atom can be derived. To add this function, we need to provide a propositional theorem prover assumptions very interesting are essentially the computational of for the ATMS is a of various choices system and interfaces in its own right; the appropriateness about proofs of atoms sets of assumptions associated with it. The design of appropriate the needs of the client problem-solving the proofs of the atoms the anti-chain of minimal the needed functionality. overhead of delivering that can reconstruct and rich subject For our present the anti-chain compromises formulation between instead from 4.2. The basic ATMS While we have imposed no restrictions on the theories that can be used with an ATMS, that function may involve computation in the absence of such restrictions is exponential efficiently expressive to be Horn clauses. A Horn clause is a proposition of the form in the size of A. One way to ensure for a reasonably is to restrict the update language that update can be calculated in theories the propositions al A... Aa,*a the proposition is just a, which we may write in the form =+ where n = 0 means a. For many applications expressiveness original paper computational decision problem F k a is linear size of A). this has proven to provide a good balance between and efficiency. The restriction [2], as well as in much of the discussion advantage to Horn clauses to Horn clauses was used of the ATMS lies in the size of F in the fact that the complexity to exponential (as opposed logical in de Kleer’s in [4]. The of the in the function update was specified The logical meaning of the interface to be the label function L3 where 3 is the theory associated with the ATMS. The question still remains is to be calculated. Our goal now is to provide an abstract descrip- of how this function called tion of how this can be done “closure operators”. * The idea is to do this as a declarative “executable” specification, in particular, as In other words, semantics of pro- the least fixed-point of a functional treatment can be realized gramming [ 6,121. The benefit of a mathematical as one does in the denotational is described as a mathematical using a class of functions in terms of anti-chains the computation languages entity: 2 The mathematical notion of a closure operator should not be confused with that of a “closure” in functional programming languages, where the term refers to a pair consisting of a code pointer and an environment. 386 CA. Gunter et al./Arfificial Intelligence 95 (1997) 357-407 is concerned) for computing semantics was given in [ 51. What we add to their treatment in proving correctness of algorithms based on a fixed-point far as the basic ATMS chain operations use of anti-chain operators makes pseudo-code first show how properties of closure operators allow one to describe algorithm for the ATMS relative labels. Indeed a proof of correctness (as in terms of our anti- together with a fuller discussion of the role of closure operators. The in description one might use. We the label update for the basic ATMS; in a later section we use them to develop a new algorithm that is quite close to an actual efficient to a more general class of propositions. the mathematical implementation is a succinct formulation it possible to capture Turning now to the technical details, let Anti(E) be the set of anti-chains Let us form a partial ordering of anti-chains by taking x 3 y if, and only Suppose C$ is a Horn clause at A . . . A a,, + a; the proposition C$ induces a functional which can be viewed as an operation atom a. Repeated application of such information-improving of the ATMS We can view F as describing Let us say that another such function G is ‘at least as informative’ from C to Anti(&). about the label function. label update algorithm. Suppose the “current state of knowledge” in a label for the is the key idea that F is a function for “improving” the information functionals as F and write F 5 G the information provided by C,?J is 3 G(b) if F(b) done by applying an operator for each atom b. Taking into account over 1. if, T x C T y. 4 : (C -+ Anti(l)) + (L ---f Anti(E)) which is defined by the equation F(b) if b + a, &F)(b) = F(a) U” n’{F(ai) 1 1 < i < n} if b = a. function There are three special characteristics all, if G is a labeling least as informative d(F) contains atom 6. Third, applying $(4(F)) as 2(F); at least as much = p(F). $ that is at least as informative that is, F 3 G implies of 4 whose proof we discuss below. First of is at Second, for any that is, as F, that $J( F) 1: 4(G). that is, F(b) adds no further 3 J(F) (b) information; information twice consecutively then J(G) as F; These are the defining properties of a closure operator: Definition 27. Let P be a poset and suppose closure operator if it is f : P --+ P is a function. Then f is a 0 monotone: x 5 y implies l inflationary: x 3 f(x) for any x E P, and l idempotent: 3 f(y), = f(x). f(f(x)) f(x) Lemma 28. For any Horn clause c$, the function 4 is a closure operator. Proof. Say 4 is al A is an atom. If b # a, then J(F) other hand, if b = a, then ’ + A a, =+ a. To see that C$ is monotone, (b) = F(b) 5 G( 6) = 4(G) suppose F 3 G and b (b) since F 5 G. On the CA. Gunter et al./Art@cial Intelligence 95 (1997) 357-407 387 t+(~)(b) = T(FW uu nU{F(ai) I I G i G 4) = (t F(U)) u nft F(Ui) I 1 < i < rl} 5 (t G(4) u nit G(Ui) I 1 < i < 4 / 1 G i 6 II}) = t (G(U) UL' n"'{G(ui) = t&G)(b) so C$ is monotone. To see that it is inflationary, suppose b # a, then F(b) = 4(F) (b). If b = a, then t&F)(b) = T (F(n) U” n%Yai) I 1 G i 6 4) = W(4) un{tWi) ( 16 i< n> 2 t F(b). To prove idempotence, we consider then 4 for all i. If the former holds p(F) calculate as follows = F for any F. If the latter holds, then 4(F) two cases. Either a = ai for some is “uninformative” i or a + ai that (ui) = F( ui) for each i and we can and it is easy to verify for the case in which the argument is a: &$(F))(a) =&(F)(a) uUn”{&F)(ai) I 1 <i < n} = (F(u) U” n’{F(u;) / 1 < i < n}) uU n%(F) (ui) I 1 G i G n> = F(u) U” nU{F(ui) ) 1 < i 6 n} =&F)(u). If the argument is b # a, then the result is immediate, so we are done. q The key point concerning closure operators and partial information of members of a family S of such operators eventually in which no new information application stability from S. This point of stability in S. We require a slightly more general is technically is added by additional a least common is that the repeated leads to a point of of operators fixed point of the operators applications fact which the next theorem expresses. Theorem 29. Suppose P is a jinite poset and S is u family of closure operators P + P. For any point x0 E P, there is a least common&ed is, there is an element x E P such that x0 3 x and .f (x) = x for each f E S. f : point of S above x0. That This is a corollary of the following lemma, which describes how such a fixed point can be computed. 388 CA. Gunter et al. /Artificial Intelligence 95 (I 997) 357-407 Lemma 30. Suppose that {fi 1 i E I} is a family of monotone and in$ationaryfunctions on a poset P indexed by some finite set I. Suppose be an infinite sequence of members of i such that every element of I appears &ix that P is finite and x0 E P. Let v in every of u. Let a[ n] be the nth element of LT. Consider the set This set has a least upper bound x. This point x is the least commonJixed point above x0 for the fu~tctions \ i f (fi I). Proof. The fact that r has a least upper bound a chain (that is, y 3 z or z 5 y for each y, z E r) follows from the observation and the poset P is finite. that it is To prove that x is a common fixed point, we need a convenient notation for composing sequences composition in non-decreasing the least upper bound of fis. We write (T,, for the length n prefix of u’. We write for the fo[nl 0 fvj,,_l 1 0 . . . o fa, 11. First, note that the elements of r are written order because all the fi are inflations. Second, because P is finite, is attained at some finite stage, that is, for some n, the least upper fg,, (x0). Let us or, using our notation, frrrnl(frrln-lI(...(f~lll(Xo)))) f, boundofris begin by noting that if 172 2 n, then x = fun,(x). (7) Since x is the least upper bound of r, we already know that fg, f CT[ n+I ] J . . . I f rrlkl are all inflations, we also know that x = fv,, (x0) 5 fvn, (x0). (x0) 3 n, and since Now, consider one of the functions let nz be a number greater an nz from the assumption x = f<,,,,_, (x0). Applying = f,,, which, by (7) again, is equal to x. Thus, n is a fixed point of any of the functions frrr,lll to both sides of this equation yields than n such that i appears f;. We must show that fi(X) that cr[m] = i; we know in every suffix of I+. By = x. To this end, there must be such that (7)) we know (x0), in r. fixed point, we have, by an easy induction on of the fi and the fact that x0 _i x’. fi(X) Suppose that x’ is any other common m, that for all m, f,,“, (x0) 3 x’ by the monotonicity Thus, x’ is an upper bound for r and, since x is the least upper bound, x 5 x’. 0 The upshot of this lemma is that if we wish to find the least common fixed point of in succession, not in any systematic order, and we will find the fixed point. The appearance of to formalize that only finitely many a set of closure operators we need only apply each one often enough necessarily the infinite sequence g in the proof is only the fact that P is finite ensures are required the notion of “often enough”; iterations of such applications in order to reach the desired fixed point. We now use this theorem to express the ATMS label update computation. Suppose that LB is the label function constructed of the label function Ls by a set F of Horn formulas from the set s of Horn clauses. The improvement is characterized as follows. Theorem 31 (Soundness atoms, and suppose & is the associated environment for A, E, and suppose of the basic ATMS algorithm). Let A be a set of assumption lattice. Let L be the label function If Lg : C + Anti(E) that 3 and G are sets of Horn clauses. C.A. Gunter et al. /Artijicial Intelligence 95 (1997) 357-407 389 Table 4 Converting a Horn clause q5 to a closure operator 6 function d;(F) (b) = if b + a then F(a) U” else endif F(b) (fold(n”, map(F)(S), {0})) where 4 is a Horn clause such that S is the set of its premises and a is its conclusion. is the label function functions relative to G, then there is a least common fixed point F of the above LG. Moreover, this jxed point satisjes the equation: &Fug(a) = F(a) -‘F(I) ifa f I, F(I) ifa= 1. (8) k relating involves entailment the semantic A proof of the theorem for the Horn clause formulas C#J to the least fixed point of the closure operators 4. This can be done the use of a minimal model for a collection of Horn clauses. Details sufficient through to construct a proof of Theorem 3 1 can be found It is worth noting how Theorem 31 reflects using a fixed point computation for a f of LB(U), into account, it is not necessarily although F is a monotone operator on labeling function of X (under an ordering of sets of formulas by subset arises from the upper difference F(a) monotonicity of labels despite operators. Since some members I, may become nogoods when deductions based on 3 are taken the case that Lg(a) 5 LFUB(~). Put more generally: functions, LX (a) may not be a monotone This non- in [ 51 and [ 111. the “non-monotonicity” based on monotonic taken in 8. inclusion). -‘I F(I) Using Lemma 30, 8 shows how to calculate L~ug from LG and 3 by the use of a least common into pseudo-code operation 4 H 4, which label functions, is given ,. fixed point. We can convert in the way Tables 1 and 2 did for version spaces. Pseudo-code this mathematics for ATMS computation for the closure operator on takes a Horn clause to the corresponding in Table 4. there, the following functions are taken from the anti-chains interface: In the program upper-union singleton upper_homogeneous_intersection empty before. The operation singleton anti-chain {x}. empty is the empty set, which the upper set that the anti-chain singleton(empty) takes an is is T(0) = E. Aside from the operations on anti-chains, we require two basic The first two of these we have encountered element x and forms itself an anti-chain. represents operations on sets: the singleton In particular, map fold 390 C.A. Gunter et al. /Artijicial Intelligence 95 (1997) 357-407 Table 5 Basic ATMS label update function improveLABEL = let L' = C(L) in ifL=L' then A(atom) => if atom = I then L(I) else L(atom) -II L(I) else improveLABEL endif endlet f fold fold the set ob- a function F and a set S; it returns The function map takes two arguments, ( I, 2,3) = tained by applying F to each of the elements of S. For instance map square { 1,4,9}. A Common Lisp analog for lists is mapcar. The function takes a binary operation *, a set T = {XI, . . . , x,,}, and an “end value” x; it returns XI *x2 * . *x,, *x. * T x = x. For then 0 = 6 and If T = 8, is similar but does not 8 42 = 42. The Common Lisp fold (which use the “end value” X. In Table 4, the end value used is not to be in which #J has the confused with In particular, note is taken between form + empty set. The upper union of these is the single- F(a) ton containing lattice; this in every environ- ment. the empty set. The upper set of this is the entire environment a so that S is the emptyset. In this case an upper union since a is a premise and the empty set itself). is (0) the case is what we expect, instance function and the singleton therefore holds fold apply containing { 1,2,3} + To use the operation 4 H 4 to calculate a label one can use a “label in Table 5. Since for a such a function pseudo-code appears function; evaluating must itself be a function, This is represented improveLABEL should be a new labeling function, in the pseudo-code using a form improvement” the result of the returned value A(x) => E which is an “anonymous” The algorithms in Tables 4 and 5 correctly ever, they are less efficient optimize (1) the algorithms for some cases. function with formal parameter x and body E. implement the ATMS computation. How- than they could be: at least three changes can be used to test. The test L’ = L in the third line of Table 5 can the this is accomplished by using a saving a second pass through of C(L), the calculation the termination Improving be combined with structures L and L' . In an actual implementation, flag that is set whenever a change by a test to check if this flag is set. Optimizing to determine not yield new information the label of an atom a is updated, the only “directly consider are those in which a occurs as an antecedent. as the computation the choice of application sequences of closure operators. It is possible that some of the closure operators will In particular, when to in the current state of information. relevant” Horn clauses proceeds to L occurs. The test C L = L is then replaced (2) CA. Gunter et al. /Artificial Intelligence 9.5 (1997) 357-407 391 Table 6 Basic ATMS label update algorithm Assume C$ is a Horn clause of the form c~~,....cL,, =$ CL function PROPAGATE (4, b, I) = let S = WEAVECb, I, {w,....c~n}) in if S # 0 then UPDATERS, a) endif endlet function UPDATERS, a) = if a=l then NOGOOD else L(a) := S U" L(a) for each C$ such that a is an antecedent of C#J do PROPAGATE($,a,S); S := [S U" L(a)1 -' L(i); if S is empty then return endif endfor endif; function WEAVE(b, I, {(II, . . . . cl”}) = for each u; do if (I, + b then I:= (I n" L(q)) -' L(I) endif endfor; return I function NOGOOD = L(I):= L(L) U" s; for each atom b # 1 do L(b):= L(b) -' S endfor (3) removing nogoods. Rather Incrementally calculation as in improveLABEL, the course of an update, as new environments nogoods. All these optimizations rithm. The Forbus-de Kleer algorithm anti-chain operations. The closure operators the ATMS are implemented in Table 6 using procedural in real implementations are found from [4] they can be eliminated than removing nogoods at end of the during of incrementally to the anti-chain are added is reconstructed that occur in the declarative of basic ATMS update algo- in Table 6 using our specification of iteration constructs. The chief labels in the algorithm insight in the update computation. We can define is to propagate changes the incremental to labels rather the than information entire provided by a Horn clause (b as the application of an operator A$ : (C --f Anti(E)) --t (C --t Anti(&)) which is defined by the equation A&‘)(b) = 0 if b # a, n”{P’( ai) 1 1 < i 6 n} if b = a. The procedure WEAVE in Table 6 implements A$. Nogoods are removed as they are algorithm. The procedure NOGOOD in Table 6 imple- discovered in the de Kleer-Forbus 392 C.A. Gunter et al. /Artificial Intelligence 95 (1997) 357-407 a # nogood to include incremental to eliminate the new labels to the evolving label set F(a), I, a E C is updated anti-chain of nogoods F(I), removal by in-place update of the evolving ments F. When an anti-chain S is added every those subsumed by S (i.e., F(a) updated the closure operator consisting of the “relevant” Horn clauses in the antecedent) of these Horn clauses with respect if there is no change reconstruction package label function then in S and -’ S). In procedure UPDATE, the label of an atom a is in the anti-chain S. In the for loop in this procedure in which a occurs and the label function F updated by each (by procedure PROPAGATE). PROPAGATE computes A$ label propagation (by using WEAVE) and terminates in the label set (S = 8). The compact semi-procedural/declarative allows us to use the anti-chains is constructed in turn to a given Horn clause of the optimizations in this algorithm implementation. incrementally environments for effective (ones 5. Extended ATM% Closure operators have a crucial but largely unappreciated that manipulate partial information. We now illustrate algorithms called the “extended ATMS”. The extended ATMS is defined of Horn clauses over L and disjunctions ATMS has the same interface of disjunctions to compute L~,,l(a) and 7 in theories, for propositional is a set of disjunctions to be given of assumptions. in [ 31 to be an ATMS where the input theory consists of assumptions Al V . . . V A,,. The extended (Table 3) as the basic ATMS, but permits certain kinds to Horn clauses. That is, the goal is is a set of Horn clauses in addition atoms a E C, where 3 importance for designing this for what de Kleer Example 32. If A = {A, B, C} is an assumption set, 3={A+u, B+b, C=sc, CAU+~, cr\b=%I} is a set of Horn clauses, and 7 = {A V B} is a set of disjunctions of assumptions, then LF(L) = {{A, C}, {B, C}}, LFUl(J-) = {{C>) since one of A or B is guaranteed to hold in models of 3 U 1. As de Kleer notes in [3], for Horn clause the label update algorithm theories, becomes for the basic ATMS, which incomplete when disjunctions is labels with respect labels computed with respect to 3 U 7, [ 31 uses two hyper- to 3 by the basic ATMS sound and complete are allowed. To correctly compute resolution algorithm. to “fix up” rules Our approach to an extended ATMS generalizes the disjunctions of assumptions used in [ 31, to formulas of the form r=q!q v4q v...vq&, C.A. Gunter et al. /Artijicinl Intelligence 95 (1997) 357-407 393 where each +i has the form 4; = A’, 17 . . ’ A A:,, and A,; E A. normal equivalent step, note to formulas in the form of In other words, simple disjunctions of assumptions form over assumptions. Let us refer to a formula having are generalized to ADNFs disjunctions is a natural to an environment like & is essentially that a conjunction {A:, like 7 can therefore be viewed as an anti-chain over E, provided disjunctive 7 as an Assumption Disjunctive Normal Form (ADNF) . To appreciate why generalizing from primitive assumptions formula not subsumed by one another. In effect, we are permitting chain to be directly asserted by the problem-solving To develop 7 and a set of environments. some 7, I’ operators theories optimizations formulation. of . . . , A:,} E E. A the &s are import of an anti- in the form of an ADNF. like that t = {A’;, . . . , A;(} for to &. We use symbols in terms of closure to In addition, new in this So we write is, t is the environment i < n. That for sets of ADNF that were otherwise hidden are revealed t E T to mean that corresponds allows us to derive a new algorithm the distinction between an ADNF assumption DNFs and to prove formulas. Our mathematical it will help us to confuse in label computations labels with respect for computing its soundness. that include the details the logical treatment system We now examine how the introduction in which a propositional of assumption DNF formulas over A changes atom holds. Continuing with Exam- the set of environments ple 32: NF = 1‘L~(l) NRJ~ = T L=IJ~(~) = {{~,C},{~,C},{~,~,C>}, = {{C}, {AC}, {R C}, {A B, C}}. The set of environments tion A V B to include environments To identify such environments the operator in which I holds expands with the introduction of the disjunc- x E E such that x U {A} E N3 and x U {B} E N3. added by the assumption DNF formula 7 E 7, we define q7 : Pwr(8) 4 Pwr(E) is intended which the upward closed sets V’u{7) (a) and N3v{7~ respectively. Given a set S C E, define the upward closed set of environments VF(a) and N3 to extend to ~~(S)={xE&/~tE7.XUtE1‘S}. It is easy to see that pT( S) is an upward closed set, i.e., 1‘ p,(S) given the theories defined in Example 32: = pT( S). For instance, N~FU{AVR} = ~{{A),{B}}(NF). Note also in working with operations on anti-chains of environments. We define the anti-chain analog = ly (T S) for any S. Ultimately, however, we are interested that p(S) Q7 : Anti(E) + Anti(E) 394 CA. Gunter et al. /Arti$cial Intelligence 95 (I 997) 357-407 of p7 as follows, or, equivalently, G,(S) is the unique anti-chain in & such that Lemma 33. The function P7 is a closure operator for any ADNF formula -r. Proof. Let S C: T, where S, T E Pwr(&). This means monotonicity. that 1‘ S C r T. We first establish xEP7(S) =+ vtEr.XUfEfS * V?E7.XUCETT =+ x eP‘,(T). To see that p, is inflationary, x E ?PT( S) . Thus S c q7( S) To demonstrate FT( S) _ We know that Yr( S) C W,(p,( 5’) ). To prove the opposite an environment: suppose x E S and t E r. Then clearly x u t c 7 S, so idempotence, we show that p’,( p7 (S) ) = let x be inclusion, x E FT(P,(S)> =+ v’t E 7. x u t E TP,(S) =-+ vtEr.XUtEP~(S) j j \JtE7.XUfE(xrEE/~?‘E7.X’Ut’ETS} vtET.xUtUtE~S =+ XE!PT(S). Hence ly, is idempotent and therefore a closure operator. 0 Corollary 34. The ,function Q7 is a closure operator for any ADNF formula r. Proof. Recall that S 3 T for anti-chains S, T means t S C: T T. Now, t Q,(S) = PAS) C PT(T) = t @T(T), so QD, is monotone. Moreover, t S C pT( T S) = p’,(S) means S=min(tS) 5min(ly,(S)) =@,(S), so Gj7 is inflationary. Finally, so Q7 ( 07( S) ) = cPi,( S) too. Hence Gp, is idempotent. q C.A. Cunrer et al. /Art@cial Intelligence 9.5 (1997) 357-407 395 In general, results sponding operators on isomorphic tively). like this corollary follow spaces (that is, on anti-chains from the fact that Cp and P are corre- and upper sets respec- Lemma 35. Suppose S E Anti(&) and r1,72 are ADNFs. Then @J,,(@,,(S>> =@%,(@,,(S)) =@,(S>, where 7- = min{x E E / 3tl E q3t2 E 72. x = tl U tz}. Proof. Let S be an anti-chain of environments and suppose y is an environment, then y E @JT, (@T?(S)) -3 vt, E 7,. y ut1 ‘3 vt, E 71 321 E @,z(S>. E T@T,(S) ZI L Y Ufl ~V~,E~~~ZI.(~~~~E~~.ZIU~~ETS)~~~~ICYU~I * v’t, E 3-l vt2 E 72. (y u t1> u t2 E T S @ y E @T(S) H Vt2 E 7-2 Vt1 E 71. (y U t2) U t1 E t S H ‘dt2 E r1 322. Oh1 E 71. 22 U tl E T S) and 22 (I Y U f2 ~~t:!Erl322E~+,(S).z2CyUt2 H Vt2 E 72. y U t2 E T Q7, (9 @ y E@,,(@T,(S)) q It is illuminating to note that the formula to the anti-chain viewed as anti-chains, that one could obtain that is r = r1 0’ 72. r in this lemma essentially from taking an upper intersection corresponds of 71 and r2 Lemma 36. For S E Anti(&) monfuedpointof{@,) 1 ~ii6}aboveSis~,,(~,(...(~,,(S)...))). , and for closure operators QT, , . . . , @jr,, , the least com- Proof. This is a consequence of Corollary 34, Lemma 35, and Lemma 30. 0 Given a set 7 = (71, . . . , 7,) of ADNF formulas, to be the least fixed point above S of the closure operators a,, , . . . , a7,,. Lemma 36 tells us how to compute @I ( S) let us define Qil (S) Our goal now is to show how to calculate the label function for the extended ATMS. This is done in two parts: first, we show how to compute and, second, we show how to compute @7(S) is the desired result: labels using the operators @Q- for anti-chains S. For the first step, here Theorem 37 (Extended ATMS algorithm). and let 7 = (71,. Let F be a set of Horn clauses over C, . . , r,} be a set of ADNF formulae over the assumption set A. Then 396 C.A. Gunter et ul./Artifcirrl Intelligence 95 (1997) 357-407 for every propositional atom a E C, km(a) = @dL3(a)) &-(&(a) i U” LF(I)) -’ LF.uI(J) ifa # 1. ifa=I, The proof of the theorem, which is a demonstration ATMS algorithm, Let F be any theory is best done by establishing (the formulas although ADNF. Then the following correspondence this is the case we are actually interested holds: of the soundness of the extended some general equations as a preliminary. in F do not need to be Horn clauses or ADNFs, that x E E and r is an in). Suppose FU(7)Uxka iff QtET..FUtUxka. (9) that any model of FU {T}UX is also a model To see why, let us look first at +. Suppose that M k F U t U x for some t E T. Then M k 3 U {T} U x too, so by of a, and suppose assumption, M k a. Thus Qt E T. 3 U t U x /= a. Turning now to a proof of +=, suppose that for any t E T, a model of F U t U x is also a model of a. If M h 3 U {T} U x, then M /= r, so M k t for some t E 7. Hence M k 3 U t U x and our hypothesis allows us to conclude that M + a too. This establishes (9). Now, it will be convenient for us to have a notation for the upper set of environments that prove a given conclusion. So, given a theory 3, we define UF(a) ={xEI /FUx+a}. Given a theory F and a collection 7 of ADNF formulas, U is the following: the main fact of interest about UF&r = P’I 0 u3. (10) This can be proved by induction on the number of elements 7 desired result is empty and there is nothing is known for 7’. Given an atom a, to prove. Suppose in 7. When this is 0, then r E 7 and ‘7’ = 7 - {r} and the U~u~(a)={xE~/3U7’U{7}Ux~a} ={xEEjQtE~..FU7’UtUxf=a} =W,(U3w(a>> = pT(P,t(U3(a))) =?PTou3 (11) (12) Eq. (11) follows from (9) and Eq. (12) follows from the inductive hypothesis. Proof of Theorem 37. To calculate L3”7-( I), min(UF”l(l))) to min(Pl(UF(l))) is equal which equal to @z-(&(1)). If a is an atom other than I, then note first that it is defined by Eq. 10. This, in turn, to be is CA. Gunter et al./Art$cial Intelligence 95 (1997) 357-407 397 @~(LF(u) U” b(l)) =min(P-r(t(&da) U” bF(~)))) =min(Fdt b(a) U t b(l))) =min(P7-(U7(a))) =min(Uml(a)) =hJ7(a) u” hJl(-L). Thus hJ7-(~> = (kw7(a> u” kJ7u-) 1 -u hJI(J-) =e-(b(a) U”b4l)) -“hJ7(l). 0 What S={s,,.. remains is showing how to calculate Gp,. Given a collection of anti-chains . , s,,}, it will be useful to write U s = S] u” . . . lJL’ s, and u YES s = S] flu . . . flu s,. h .XES The desired following: expression of Q,(S) in terms of anti-chain operations is given by the Lemma 38. For S E Anti(&) and ADNF formula r over d, G,(S) =$J{s- t> IE7 YES Proof. We calculate as follows: Q,(S) =min(!PT(S)) =min{xEI/~‘tE7.XUtErS} =min{xE&I~‘tE7.3sES.sCxUt} u =numin{xEEIsEaut) ET YES Now consider it contains The equation the sets es = {x E I 1 s C x U t}. An environment t. Hence s - t is the unique minimum x is in es just in case element of es. the environment in the lemma s - therefore follows. q The algorithms in Table 7 and Table 8 correctly implement the extended ATMS label computations. We now show two examples of the use of these algorithms. 398 CA. Gunter et ul. /Art@cial Intelligence 95 (I 997) 357-407 Example 39. We illustrate the computation of the label for _L in the example introduced at the start of this subsection. Recall that the assumption set A = {A, B, C}. Our aim is to calculate Z,F,T( I). First, we use the basic ATMS algorithm to compute LzK(-L) = {{AC}, {B, C}}. Next, the closure operator @T is constructed from Lemma 38 by the algorithm in Table 7. @{{A),(B)} = [ij+ - {A}}] nu [fib - {B)}] s s Finally, we use Theorem 37 and the algorithm in Table 8 to obtain the desired result. ~J{~A),JB))(~~ =@{{A),{B)}({{A,CI+ {B,C))) = [{{AS} - {A}} U” {{B,C} - {A}}1 n” [{{A,C) - {B)) U” {{KC} - {B}}l = f{(C)) u” {{BX))l 0’ [{{AC)} u” {(C))1 = UCH fI” tic>) = wu Example 40. We demonstrate the power of the anti-chains formulation of label compu- tations in the context of an example with a more complex T. Consider .F={A,h+B*b,C=+e,b+c,c+d}, 7={&‘BVC,Av?i} = wm {BL WIL {{Al, Gw. We need to calculate LF”T(~). From the basic ATMS algorithm, we know that LA4 = t(B), {C}) and LF(~) = {{A,A}}. Next, we use Lemma 35 to reduce 7 = (71, ~2) to a single ADNF formula 7. 7=min{x E & 13, E~~,ilt2 E 72,x=tl Ut2) =m~~{{~,A},{~},{B,A},{B,;i},{C,A},{C,~}} = {{$, {B, A}, {C, A}}. CA. Gunter et al. /Artijicial Intelligence 95 (1997) 357-407 399 Table 7 Converting an ADNF formula Q- to a closure operator @, function e7(S) = fold(rl”‘,map(At. foldW”,map(As.s - t)(S) ,0) CT)) ,{0}) where 7 is an ADNF formula and S is an anti-chain over &. Now we construct @{,I using the algorithm in Table 7. q,>(S) = [fi{s- sES {x}}] I-?’ [ij{s- .v {BJ}}] .‘I [ij,s- {CA}}]. s We can then calculate LF”I( I) and LF”l(d) using the algorithm in Table 8. LFM-(~) =@~({{A&)) = [{{&xii) - {Ti}}l 0’ [{{AA} - {B,A}}l 0’ [{{Ax} - {CA}}1 = &W n*’ {@H n” {{~)) = {{A z)}, LmT(d) =@7(LF(d) u” k(J-1) -’ LFU?-(~) =@T({{B}, {C}, {A,$}) -’ {{A>$), @z-({(B), ((3, {A&}) = I{(B) - {A}) u” {{C> - {x)) u” {{A>$ - {$)I n” I{(B)-{B,A}}UU{{C}-{&A}}U”{{A,A}-{B,A}}l ~“~{{~}-{~,~}}~lf{{~}-{~,~}}~U{{~,~}-{~,~}}l = [WI) u” {W u” HWI nz’ f(0) u” {{c)} u” {{@}I nu r WW uu 101 u* GWi = I(B), {Cl, {Al). Note that {A} has been added to the basic ATMS label of d by the extended ATMS that F U 7 U {A} /= d. W e note that this follows from the fact (since (sinceAVBVCistrue),andthat.FU(BVC) kd computation. This means that.FUIU{A}~BVC B+dandC+d). 400 CA. Cunter er al. /Art@cial Intelligence 95 (I 997) 357-407 Table 8 Extended ATMS label update function correctLABEL(LF,Qs7) = let L = @7(&(I)) /\(atom) => in if atom = i then L else +(lF(atorn) endif U” LF(I)) -I’ L endlet The computation of the label L~“l(a), (restricted [ 131. Thus, in the size of A. De Kleer in the general case, we expect in 7 (the cause of the exponentiality) for any atom a E C is essentially the enu- to atoms in A) of a in .FU 7. This task is to perform com- to incorporate into labels computed using the Horn in terms of closures rather meration of all minimal “models” to be #P-complete known putation exponential disjunctions theory 3. Our order-theoretic and anti-chains than indirectly is computationally more expensive there are multiple proofs of a literal a in 3 U 7 based on the same support set x E E. All of these proofs are enumerated label rules. correction labels directly allows us to enumerate in the space of proofs. A proof-theoretic in the space of models scheme in the course of the application of the hyper-resolution [ 31 uses hyper-resolution for label computation of the computation the model-theoretic approach when reconstruction than The fundamental computation in our framework to incorporate an ADNF formula 7 into an anti-chain S on &. r, = 6,s - t}. YES @r(S) = AL t&- , tn} and S = {st , . . . s,,}, where each ti, s.; E E, then a straightforward operations, mn upper requires mn set-difference intersections. Any reduction in the number of opera- in the sizes of the arguments of the upper unions and that can be If 7 = {t,,... implementation unions, and n upper homogeneous tions is a win, as is any reduction upper homogeneous implemented intersections. We now describe a list of optimizations to achieve both types of reductions. of this computation very cheaply in the @, computation, changes to labels caused by the introduction of 7. We compute rather than the entire new label. In effect, we the extended ATMS the new operator A@, shown below and use it to calculate ( 1) Computing to labels changes define label. Qi,(S) =Su’ A@,(S), A@,(S) =fjAyt, ET AY, = fi if {s - t} = {s} then 8 else {s - t}. YES C.A. Gunter et al. /Artificial Intelligence 95 (1997) 357-407 401 Table 9 The optimized G,(S) computation function Q,(S) = let d@,(S) infort = (0) E Tdo fl8 = 0 let in for .Y E S do if s - t # s then dyt = AK U” {s - t} endif endf or A@,(S) = A@,(S) n” Ayt endf or return S U” A@,(S) endlet For each s, t pair for which s - t = s, we save one upper union operation. the sizes of arguments with A& the same intuition shown in Table 6. to the remaining upper unions rather than the Y,s themselves. This optimization, as that used by De Kleer and Forbus In addition, is reduced, since we only work in Table 9, employs in their basic ATMS algorithm shown there the computation (2) Detection of early termination. During under which G,(S) = S, so that we can terminate of G7 (S) we can detect early. conditions is a t E T such that for all s E S, s -- t = s. It is easy to see that the Suppose corresponding Y, = S. We have [W&l 5 yt by the property of f?. But Q5,( S) = f7”K > S since Qr is a closure operator. Therefore, whenever K = S for some t E T then Q7 (S) = S, and we can stop the label computation. At best, we save (m - 1) n set differences, intersections. At worst, i.e., when this (m - 1) n upper unions and n upper homogeneous condition is true of the last t E 7 examined, we save n upper homogeneous intersections. involving U” and 0”. We use properties of nU and U” to simplify (3) SimpliJications the computation the computation of individual Y,s as well as Q7 (S) . ((8)) UU S={(8)} for any S E Anti(E), ((0)) Vk=S for any S E Anti(&). Thus, for instance, if we encounter an s, t pair in the computation such that s 2 t, then s - m - 1 upper unions and 1 upper intersection t = 8 and we can immediately in the computation report X = ((0)) of @r(S). of a specific K, saving upto Acknowledgements This project would not have come into existence without in AI representations Panangaden, who played a key role in inciting and helping us to explore usefulness in the semantics of concurrency. He is also responsible closures play in the ATMS. Haym Hirsh was helpful of abstractions for the VS algorithm. We also thank anonymous of the kinds of order-theoretic to us in understanding for showing the participation of Prakash the potential structures being used the key role that the usefulness referees who have read 402 C.A. Gunter et al./Artijicial Intelligence 95 (1997) 357-407 and Bonnie Webber. the paper as well as Ziqiang He, Leonid Libkin, Rona Machlin, Gunter’s work was supported Ngair’s work was supported by the Institute of Systems Science, Singapore. Subramanian’s work was supported by NSF grant IRI-8902721. in part by ONR grant N00014-95-1-0245. Appendix A. Anti-chain library interface In this appendix we describe signatures for a Standard Meta-Language implementation over lattices. With in an implementation the brief explanation we now provide, to readers not familiar with SML. An SML signature of anti-chains make sense expected to be present are called structures. Signatures values; and values. In a signature, a value name is given together with its type. For example, declare the line and in this section contain only names of types, exceptions, these should is a list of names implementations of the signature; the names of structures, such types, exceptions, denotes a value mapping elts that the name singleton the cases we consider to acs, one includes contain to val singleton : elt -> ac for anti-chains that an anti-chain structure contains a type called elt is also an exception called NotFound which is given at the end of the paper. It indicates, in the signature. The signature and a type called for example, to the failure ac. There is of type ac. The signature does not find an elt describe it does not say that elts will be viewed as elements of ac. It describes only the types of the values, and lists the names of exceptions in an ac and a value empty which the semantics of these objects. For instance, and types that are present. is used to signal Before giving a more detailed discussion of the particular values in the ANTICHAIN a lattice independently (sets of bindings) is defined and producing of the posets over which anti-chains are special kinds of subsets of a poset, so it makes no sense simply signature, we sketch the role that this signature plays in programming with anti-chains. Anti-chains speak of anti-chains are being The signature ANTICHAIN should be viewed as part of the “type” of an operator environments to environments, defining anti-chains over that lattice are provided. Like anti-chains, of operators we expect to be present; The particulars of this signature will be discussed anti-chains is an operator called afunctor that takes a lattice structure produces a anti-chain over that lattice structure. as follows: of the signature LATTICE) and of the signature ANTICHAIN) If we analogize with functions and types we might write this they are given as a signature LATTICE in Table A. 1. of taking as its parameter an environment (the SML term for a parameterized shortly. Now, an implementation lattices come with a collection (that is, an implementation (that is, an implementation to taken. from in which operations on a new environment structure) structure functor Lattice2AC: LATTICE -> ANTICHAIN In summary, such as this. the implementation of anti-chains is given by the coding of a transformation C.A. Gunter et al. /Artijcial Intelligence 9.5 (1997) 357-407 403 Table A.1 LATTICE signature LATTICE = sig type elt datatype relationship = Less I Greater I Equal datatype 'a option = Some of 'a i None val 1atOrd: elt * elt -> relationship option val bottom: elt val meet: elt * elt -> elt val top: elt val join: elt * elt -> elt val sort0rd: elt 1: elt -> relationship end (* LATTICE *) Let us begin by discussing the signature LATTICE for lattices given a lattice is a set together with a relation, In LATTICE, the lattice elements are drawn from a type called elt is represented as a function mapping pairs of elts in Table A.1. two constants, and to its definition, According two binary operators. and the order relation 1atOrd on elts to values of a type relationship h- (Greater), (Less), none of these relationships, produces a relationship either has the form Some x where x is a relationship constants are bottom, top and the binary operations and = (Equal). option. The values of relationship represent 3 In a lattice a given pair of elements may satisfy takes a pair of lattice elements and so the 1atOrd operation option as its output. An element of relationship option or has the form None. The are meet, join. The function sortOrd is not part of the the mathematical definition of a lattice. It is arises when we wish to form it is often useful to of lattice elements. To represent sets efficiently, given here for purposes of efficiency and its significance sets (or anti-chains) have a linear ordering of set elements are related). This allows sets to be represented an element can be done quickly. It is important trees generally must be different such balanced since a lattice need not be a linear ordering of 1atOrd if we are representing relationship between pairs of elements of the anti-chain! option rather relative in which any two elements (that is, an ordering for trees so that searching as balanced to appreciate that the ordering used for from the ordering 1atOrd on the lattice in the fact that the image (as reflected that than a relationship). Note in particular to the lattice ordering is a relationship anti-chains then there will be IZO to satisfy the stipulation is a linear order. An together with LATTICE is assumed Now let us turn to the signature ANTICHAIN which lattice axioms The semantics of the signature LATTICE is given by the mathematical that sortOrd of this semantics, although SML cannot check that it does. in Tables A.2 and A.3. is given are a self-evident mapping of the in the Table A.2 part are taken by analogy with library. The semantics of these (* and *>. The the same for The semantics described by the mathematics names). Constants other operations are described values described in the first half of ANTICHAIN are ones that are basically in notes delimited by the comment characters in the sets signature of the SML/NJ of most of the interface operations in Table A.3 of the signature in Section 2 (assuming and operations implementation succinctly 404 C.A. Gunter et d/Artificial Intelligence 95 (1997) 357-407 Table A.2 ANTICHAIN signature ANTICHAIN = sig type elt type ac exception NotFound val empty: ac (* Empty ac *) val singleton: elt -> ac (* Create a singleton ac *) val isEmpty: ac -> boo1 (* Return true if and only if the ac is empty. *) val equal: (ac * ac) -> boo1 (* Return true iff the two at's are equal *) val oumElts: ac -> int (* Return the number of elt's in the ac *) val 1istElts: ac -> elt (* Return a list of list the elt's in the ac *) val app: (elt -> 'b) -> ac -> unit (* Apply a function to the elt's in the 1: ac in decreasing order *) val revapp: (elt -> 'b) -> ac -> unit (* Apply a function to the elt's in the * ac in increasing order *) val fold: (elt + 'b -> 'b) -> ac -> 'b -7 'b (* Apply a folding function to the elt's * in the ac in decreasing order *) val revfold: (elt * 'b -> 'b) -> ac -7 'b -7 'b (* Apply a folding function to the elt's * in the ac in increasing order *) val exists: (elt -> bool) -7 ac -> elt option (* Return an elt in the ac satisfying the predicate t if any, return NONE if there is none *) both sets and anti-chains is whether an operation set that the anti-chain like singleton However, it is essential or that apply only to anti-chains. The important thing to note refers is meant to the anti-chain or to the downward- or upward-closed for functions to represent. This distinction means nothing is taken. gives the number of elements to note that the function numElts and equal which are the same regardless of which meaning C.A. Gunter et al. /Artijicial Intelligence 95 (1997) 357-407 405 Table A.3 ANTICHAIN (continued) val upper-add: ac * elt -> ac val lower-add: ac * elt -> ac (* Insert an elt *) val upper-find: ac * elt -> elt val lower-find: ac * elt -> elt (* Find an elt in an set, raise NotFound * if not found *) val val upper-peek: ac * elt -> elt option lower-peek: ac * elt -> elt option (* Look for an elt in a set, return NONE * if the elt is not there. *) val val upper-member: ac * elt -> boo1 lower-member: ac * elt -> boo1 (* Return true iff elt is in the set *) val val upper-subset: (ac * ac) -> boo1 lower-subset: (ac * ac) -> boo1 (* Subsets *) val val upper-difference: ac * ac -> ac lower-difference: ac * ac -> ac (* Difference. *) val val upper_union: ac * ac -> ac lower-union: ac * ac -> ac (* Union *) val val upper-homogeneous-intersection: ac * ac -> ac lower_homogeneous_intersection: ac t ac -> ac (* Homogeneous intersection. *) val val upper-heterogeneous-intersection: ac * ac -> ac lower_heterogeneous_intersection: ac * ac -> ac (* Heterogeneous intersection. *) end (* ANTICHAIN *) end in the representing set represented this distinction set. So, for instance, anti-chain rather than the number of elements by it. In the semantic description given as comments is made by distinguishing the comment consistently between in a lower or upper in the signatures, the anti-chain and the (* Return the number of elt’s in the anti-chain. *> that numElts means the number of elements takes a set represented in the representing as an anti-chain anti-chain. as an argument and returns to know how If we had wanted 406 C.A. Gunter et ~11. /Artificial Intelligence 95 (1997) 357-407 many elements were in the set that the anti-chain to know whether the anti-chain way of enumerating For the functions represents its elements or otherwise counting fold, app, revapp, and revf old, is meant to represent, we would need its upper set or its lower set (and have some them). the order that is increasing or decreasing must, of course, be sorttlrd. The values declared in the second column of ANTICHAIN come in two flavors, upper_ that the value of latOrd(x,y) in which case the value is simply S ‘. If we had applied the anti-chain is viewed as representing the application upperadd(S, representing S then this means an upper set or x> inserts x into the upper that x is added to S ) unless or instead, we for is not Greater the functions lower-add is not Less or Equal. Similarly, do their finding and peeking in upper or lower sets depending or lower- depending on whether a lower set. So, for instance, set S. If S ’ is the anti-chain there is an element y of S’ such Equal, would check whether sortClrd(x,y) and peek’ing f ind’ing on how they are prefixed. The key points about these these: interfaces and the way they have been described are (1) The semantics model (2) What of the interfaces is clear and does not over-constrain to include are given abstractly so that the mathematical the implementation. in the interface was based on a selection of the mathematical to express the algorithms which the implementations of the to support. in which supporting the sets of operations a substantial but computationally are described provides feasible part needed primitives interfaces are intended language interface (3) The types and abstractions of the task. techniques independent implementation and implementation Although an emphasis on mathematical the choice of interfaces will be significantly is desirable, available to achieve. The interfaces provide a vocabulary formally. Let us illustrate. inefficient. For example, although elements, it is possible cases where one has a lattice mathematically, be difficult to implement. Hence that omits LATTICE’ an implementation descriptions influenced by a tension between is trying and the kind of reuse that the programmer these trade-offs more in which to discuss In some contexts using Lattice2AC may prove awkward or of lattices calls for top and bottom in some one or the other of these elements may lattice signature, is still to implement ANTICHAIN without using them. Moreover, In SML an implementation it is often desirable to use a “thinner” top and bottom. the mathematics of LATTICE’ of LATTICE, so little is lost by this thinning. issue arises when one knows something lattice serious the input implementation in the efficient lattice over a finite set of atoms, about of anti-chains over it. For instance, that if one then the anti- that the lattice will be a boolean from implementation may optimized by taking advantage of this fact. A functor lacks interface to ANTICHAIN cannot do this because lattices because in terms it that takes an “atoms” model Another can be useful knows chain LATTICE or LATTICE’ the needed primitives. Moreover, all one needs of whatever probably makes more sense to organize code into a functor as its input. So, given a signature the lattice operations can all be defined to use. For these two reasons of sets of atoms one chooses to know are the atoms; to describe boolean it is quite simple representation its input like C.A. Gunter et al. /Artificial Intelligence 95 (19971 357-407 407 signature sig ATOMS = type elt val val elt eq: atoms = elt * elt list -> boo1 end (* ATOMS *> one implements functor Atoms2AC: ATOMS -> ANTICHAIN Whether anti-chains mathematical plementations will undoubtably differ. over a lattice are produced using Lattice2AC should remain semantics of the anti-chain operations or Atoms2AC, the the same. The im- References I I I B.A. Davey and H.A. Priestley, Introduction to httices and Order (Cambridge University Press, Cambridge, MA, 1990). 12 1 J. de Kleer, An assumption-based [ 3 ] J. de Kleer. Extending 14 1 K.D. Forbus and .I. de Kleer, Building Problem Solvers (MIT Press, Cambridge, MA, 1993). and S. Honiden, On logical IS I Y. Fujiwara, Y. Mizushima the ATMS, Artificial Intelligence 28 (1986) 163-196. TMS, Artijicial Intelligence 28 ( 1986) 127-162. foundations of the ATMS, ( 1990) in: Proceedings ECAI-90 Workshop on Truth Maintenance Systems, Stockholm, Sweden I6 1 C.A. Gunter, Semanfics of Programming Languages: Structures and Techniques, Foundations of Computing (7 I H. Hirsh, (MIT Press, Cambridge, MA, 1992). Incremental Version Space Merging: A General Framework jbr Concept Learning (Kluwer Academic Publishers, Dordrecht, Netherlands, 1990). 18 I C. Mellish, The description I9 I T.M. Mitchell, The need for biases identification problem, Artificial Intelligence 52 ( 1991) 15 l-167. in generalization, in: J. Shavlik and T. Dietterich, eds., Readings in Machine Learning (Morgan Kaufmann, Los Altos, CA, 1990). II0 I T.M. Mitchell, Version Space: an approach to concept leaning, Ph.D. Thesis, Stanford University, Stanford, CA ( 1978). Ill I T.-H. Ngair. Convex spaces as an order-theoretic basis for problem solving, Ph.D. Thesis, University of Pennsylvania, Philadelphia, PA ( 1992). II2 I D.S. Scott and C. Strachey, Towards a mathematical semantics for computer languages, in: J. Fox, ed., Computers and Automata (Polytechnic I 13 I J. Simon, On some central problems Institute of Brooklyn Press, 1971) 19-46. in computational complexity, Ph.D. Thesis, Come11 University, Ithaca, NY ( 1975). I 141 M. Smyth, The largest Cartesian closed category of domains, Theoret. Comput. Sci. 27 ( 1983) 109-I 19. I I5 I S. Vickers, Topology via Logic, Tracts Press, Cambridge, MA, 1989). in Theoretical Computer Science, Vol. 5 (Cambridge University 