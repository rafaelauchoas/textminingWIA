Artificial Intelligence 314 (2023) 103808Contents lists available at ScienceDirectArtificial Intelligencejournal homepage: www.elsevier.com/locate/artintAnswering regular path queries mediated by unrestricted SQontologiesVíctor Gutiérrez-Basulto a,∗Filip Murlak ca School of Computer Science and Informatics, Cardiff University, UKb Faculty for Mathematics, Natural Sciences, Economics and Computer Science, University of Hildesheim, Germanyc Faculty of Mathematics, Informatics and Mechanics, University of Warsaw, Poland, Yazmín Ibáñez-García a, Jean Christoph Jung b, a r t i c l e i n f oa b s t r a c tArticle history:Received 22 July 2021Received in revised form 11 October 2022Accepted 16 October 2022Available online 21 October 2022Keywords:Ontology-mediated query answeringDescription logicNumber restrictionsData complexityA prime application of description logics is ontology-mediated query answering, with the query language often reaching far beyond instance queries. Here, we investigate this task for positive existential two-way regular path queries and ontologies formulated in the expressive description logic SQu , where SQu denotes the extension of the basic description logic ALC with transitive roles (S) and qualified number restrictions (Q) which can be unrestrictedly applied to both non-transitive and transitive roles (·u). Notably, the latter is usually forbidden in expressive description logics. As the main contribution, we show decidability of ontology-mediated query answering in that setting and establish tight complexity bounds, namely 2ExpTime-completeness in combined complexity and coNP-completeness in data complexity. Since the lower bounds are inherited from the fragment ALC, we concentrate on providing upper bounds. As main technical tools we establish a tree-like countermodel property and a characterization of when a query is not satisfied in a tree-like interpretation. Together, these results allow us to use an automata-based approach to query answering.© 2022 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).1. IntroductionThe use of ontologies for data management has gained a lot of popularity in various research fields such as knowledge representation and reasoning, and databases. For instance, ontologies have been successfully used to integrate and access data [1,2]. The main characteristic of the ontology-based data access (OBDA) paradigm is that data can be queried through the lens of an ontology which comes with several benefits. On the one hand, the ontology enriches the data with domain knowledge, resulting in more complete answers to queries. On the other hand, the ontology can provide a more convenient vocabulary to the user for formulating queries.In the context of OBDA, the main reasoning problem is ontology-mediated query answering, which is defined as follows: the input consists of data A, a query ϕ, and an ontology T and the task is to compute all answers to the query over the data relative to the ontology. In this context, the data A is assumed to be incomplete, and a tuple a is an answer of ϕ over A relative to T if ϕ(a) is entailed by T and A.* Corresponding author.(J.C. Jung), f.murlak@uw.edu.pl (F. Murlak).E-mail addresses: gutierrezbasultov@cardiff.ac.uk (V. Gutiérrez-Basulto), ibanezgarciay@cardiff.ac.uk (Y. Ibáñez-García), jungj@uni-hildesheim.dehttps://doi.org/10.1016/j.artint.2022.1038080004-3702/© 2022 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808Depending on the application at hand, there are various options both for ontology and query language, that is, formalisms to express ontologies and queries, respectively. For the latter, one typically uses database-inspired query languages such as conjunctive or navigational queries. A popular choice for the former are description logics (DLs) which are a family of logic-based knowledge representation languages [3]. More precisely, they are fragments of first-order logic restricted to unary and binary symbols. Description logics are an attractive choice as ontology languages since they do offer a good balance between expressivity and complexity. Indeed, they provide the logical basis of the web ontology language OWL 2 [4].Ontology-mediated query answering has been extensively investigated for different combinations of DL and query lan-guages, resulting in a plethora of complexity results and algorithms. One line of research is the study of expressive DLswhere the main objective is to identify logics including as many features as possible, while supporting decidable reason-ing. In particular, considerable effort has been put into the study of query answering in expressive DLs featuring transitive roles and qualified number restrictions [5–8]. Transitive roles are needed to model intrinsically transitive relations such as hasDescendant or hasPart. Qualified number restrictions can then be used to express numerical properties of concepts as in every car has (as parts) four wheels. However, in all the aforementioned works the application of number restrictions to transitive roles is forbidden. Remarkably, this is reflected in the fact that the W3C ontology language OWL 2 forbids such interaction too [9]. As a consequence, users might not be able to properly model knowledge, e.g., about the number of parts a component or a piece has, using OWL languages. As a concrete example, consider the ontology T consisting of the following statements.(1)(2)(3)(4)Heart (cid:3) (≥1 hasPart.MitralValve) (cid:5)(≤1 hasPart.MitralValve)Heart (cid:3) (≥1 hasPart.LeftAtrium) (cid:5)(≥1 hasPart.LeftVentricle)LeftVentricle (cid:5) LeftAtrium (cid:3) ⊥LeftVentricle (cid:3) (≥1 hasPart.MitralValve)LeftAtrium (cid:3) (≥1 hasPart.MitralValve)(5)Intuitively, T models that the human heart has exactly one mitral valve, by (1), as well as a left atrium and a left ventricle, by (2). By (3), the last two are enforced to be distinct. By (4) and (5), both the left ventricle and the left atrium have as a part a mitral valve. Notably, the axiom (1) applies a non-trivial number restriction to the transitive role hasPart. Obviously, similar modelling issues arise in different application areas, for instance, when modelling that every car has four wheels, or that every human has ten fingers.This example demonstrates that in important application areas like medicine, there is a need for logics supporting counting on transitive relations. However, existing research shows that it is difficult to design such logics without losing decidability, see Related Work section. Motivated by the above, in this paper is we investigate ontology-mediated query answering in the case when the ontology language supports the application of qualified number restrictions to transitive roles. We focus on the most fundamental Boolean complete such DL which we denote SQu where letter S denotes the extension of the basic Boolean complete DL ALC with transitive roles while letter Q indicates the availability of qualified number restrictions. Throughout the paper we use the subscript ·u , for “unrestricted” to avoid confusion with traditional DL nomenclature where, even if both S and Q appear in the name of the DL, the interaction of qualified number restrictions and transitive roles is forbidden. As query language, we choose positive existential two-way regular path queries (P2RPQs), which is arguably one of the most expressive query languages, generalizing languages such as conjunctive queries (CQs) [10], unions of CQs, regular path queries (RPQs) [11], and conjunctive two-way regular path queries (C2RPQs) [12]. RPQs and C2RPQs, and thus also P2RPQs are instances of navigational queries, which go beyond the expressive power of CQs in that ∗(tarski, x) returns all (scientific) descendants they can express graph reachability. For instance, the query ϕ(x) = advisorOfof Tarski, using the transitive closure of the advisorOf relation. While (unions of) CQs have been the prime language for ontology-mediated query answering for a long time, navigational queries have recently gained considerable attention [13–16]. Indeed, motivated by applications in the semantic web, the latest W3C standard SPARQL 1.1 includes property paths, related to regular expressions.1.1. Contributions and structure of the paperThe goal of the paper is to pinpoint the computational complexity of answering P2RPQs mediated by SQu ontologies. For this reason, we study the decision problem associated to query answering, query entailment, which takes as input only Boolean queries, that is, queries without answer variables, and decides whether the query is entailed over the data and the ontology. We investigate both the combined complexity, where all the data, ontology and query form the input, and data complexity, where query and ontology are assumed to be fixed [17]. Our main results are decidability and tight complexity bounds for the entailment problem. In particular, we show that entailment of P2RPQs mediated by SQu ontologies is 2ExpTime-complete in combined complexity, and coNP-complete in data complexity.2V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808Since the lower bounds follow from previous results for the sublogic ALC of SQu [18,19], we concentrate on establish-ing upper bounds.Our main technical contribution is the development of an automata-based approach for query entailment which roughly consists of the following steps:1. establish a tree-like countermodel property, that is, show that if a query ϕ is not entailed by T and A, then there is a tree-like countermodel witnessing this,2. construct an automaton AT , A recognizing tree-like models of T and A,3. construct an automaton A¬ϕ recognizing tree-like models of ¬ϕ.Observe first that in the above example, the ontology (correctly) enforces that the left atrium and left ventricle have the same mitral valve as a part. From a technical perspective, this shows that SQu does not enjoy the tree model property. As a consequence, in Step 1, we have to resort to tree-like models, defined in terms of tree decompositions. The rationale behind this approach is that query entailment then reduces to the question whether there is a tree-like interpretation that is accepted by both AT , A and A¬ϕ , that is, whether the languages recognized by AT , A and A¬ϕ have non-empty intersection.To obtain our automata-based decision procedure, we thus have to realize each of the steps above. Section 2 provides the necessary background and definitions. In Section 3, we address Step 1 above. More precisely, we develop the notion of canonical tree decompositions, which intuitively are tree decompositions tailored to handle the interaction of transitivity and number restrictions. We then show via a novel unravelling operation for SQu that, if the query is not entailed, there is a witness interpretation which has a canonical tree decomposition of bounded degree and width. In Section 4, we develop the foundations for Step 3. In particular, we develop a characterization of when a query is satisfied in a tree-like interpretation. Since P2RPQs are not local, the characterization is based on a careful decomposition of the input query into subqueries. The query is then not satisfied iff there is a certain annotation of the tree-like interpretation with (sets of) subqueries obtained in this way. It is worth mentioning that this characterization does not depend on SQu and is thus of independent interest.Based on the results in Sections 3 and 4, we provide in Section 5 the automata constructions for Steps 2 and 3. We work with non-deterministic tree automata over infinite trees with weak acceptance conditions. In fact, we only require the existence of an infinite run. For such automata intersection non-emptiness can be decided in polynomial time [20]. Since the size of the automata we construct is bounded doubly exponentially in the size of the input data, ontology, and query, a 2ExpTime upper bound in combined complexity follows. Based on a careful analysis of the constructed automata, we also obtain a coNP upper bound in data complexity. These bounds are tight since entailment of positive existential queries mediated by ALC ontologies is 2ExpTime-hard in combined complexity [19], and entailment of instance queries mediated by ALC ontologies is coNP-hard in data complexity [18].In Section 6 we discuss related work and in Section 7 we conclude and point out some directions for future work.2. Preliminaries2.1. The description logic SQuWe consider a vocabulary consisting of countably infinite disjoint sets of concept names NC, role names NR, individual R and transitive role names NI. Further, we assume that NR is partitioned into two infinite sets of non-transitive role names Nntnames NtR. SQu -concepts C, D are defined by the grammarC, D ::= ⊥ | A | ¬C | C (cid:5) D | ((cid:2) n r C)where A ∈ NC, r ∈ NR, and n is a non-negative integer given in binary. We shall use ((cid:3) n r C) as an abbreviation for ¬((cid:2) n−1 r C), and other standard abbreviations such as (cid:9) and C (cid:10) D for ¬⊥ and ¬(¬C (cid:5) ¬D), respectively. Concepts of the form ((cid:2) n r C) and ((cid:3) n r C) are called at-most restrictions and at-least restrictions, respectively.As usual in DLs, ontologies are described by TBoxes and data is described by ABoxes. An SQu -TBox T is a finite set of (general) concept inclusions (CIs) of the form C (cid:3) D, where C, D are SQu -concepts. An ABox A is a finite non-empty set of concept and role assertions of the form A(a), r(a, b) where A ∈ NC, r ∈ NR and {a, b} ⊆ NI; we denote with ind(A) the set of individual names occurring in A. Whenever no confusion can arise we will drop the specification of the logic SQu and just talk about TBoxes instead of SQu -TBoxes.The semantics of SQu is defined as usual in terms of interpretations I = ((cid:3)I , ·I ), where (cid:3)II ⊆ (cid:3)Iis an interpretation function that maps each A ∈ NC to a subset A.the domain and ·II ⊆ (cid:3)I × (cid:3)Ir, and each a ∈ NI to an element aI ∈ (cid:3)Iis a non-empty set called , each r ∈ NR to a subset Notice that transitive role names are not required to be interpreted as transitive relations; this will be convenient when the transitive closure of I defined by setting R. We call an interpretation I transitive if working with tree decompositions for transitive relations. We denote with I∗(cid:3)I∗ = (cid:3)II∗ = rI = I∗. Naturally, entailment will be defined relative to transitive interpretations only.for A ∈ NC, rfor r ∈ Nntfor r ∈ NtR , and rI∗ = (rI∗ = AI )+, AII3V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808The interpretation of complex concepts is defined by taking(⊥)I = ∅ ,I ,(¬D)I = (cid:3)I − DI ∩ D(C (cid:5) D)I = CI ,(cid:2)d ∈ (cid:3)I | #{e ∈ C((cid:2) n r B)I =I | (d, e) ∈ rI } ≤ n(cid:3),Iwhere #M denotes the cardinality of a set M. An interpretation I is a model of a TBox T , written I |= T , if Call CIs C (cid:3) D ∈ T . It is a model of an ABox A, written I |= A, if ind(A) ⊆ (cid:3)Ir(a, b) ∈ A, and a ∈ Aover to the setting with the unique name assumption, where awhere individual names are interpreted freely.for for all for all A(a) ∈ A. The first two conditions constitute the standard name assumption; our results carry iff a = b for all a, b ∈ ind(A), as well as the setting I = a for each a ∈ ind(A), (a, b) ∈ ris a sub-interpretation of I, written as I(cid:14) ⊆ I, if (cid:3)I(cid:14) ⊆ (cid:3)Iand r ∈ NR. For (cid:4) ⊆ NC ∪ NR, I is a (cid:4)-interpretation if Arestriction of I to signature (cid:4) is the maximal (cid:4)-interpretation I(cid:14)sub-interpretation of I with domain (cid:3). The union I ∪ J of I and J is an interpretation such that (cid:3)I∪J = (cid:3)I ∪ (cid:3)JI∪J = AAfor all A ∈ NC, and rI = ∅ for all A ∈ NC − (cid:4) and r ∈ NR − (cid:4). The with I(cid:14) ⊆ I. The restriction of I to domain (cid:3) is the maximal , An interpretation I(cid:14)for all A ∈ NC and r ∈ NR.I = ∅ and rI∪J = rI(cid:14) ⊆ AI(cid:14) ⊆ rI = b, and rI ∪ AI ∪ r, A, aJJIIIII ⊆ DI2.2. Normal formThroughout the paper we will use a convenient TBox normal form. A concept inclusion is in normal form if it takes one of the following shapes:(cid:5)i Ai (cid:3) (cid:10) j B j,A (cid:3) ((cid:2) n r B),A (cid:3) ((cid:3) n r B),where A, Ai ∈ NC ∪ {(cid:9)}, B ∈ NC, B j ∈ NC ∪ {⊥}, and r ∈ NR. Note that (cid:9), (cid:10), and ((cid:3) n r B) are now treated as parts of the syntax, not abbreviations. A TBox T is in normal form if all CIs are in normal form and at-most restrictions involving transitive role names are propagated: with each CI of the form A (cid:3) ((cid:2) n r B) with A (cid:16)= (cid:9) and r ∈ NtR, T also contains CIsA (cid:3) ((cid:2) 0 r A(cid:14)) and (cid:9) (cid:3) A (cid:10) A(cid:14)(cid:14). Note that the latter is equivalent to requiring that T contains A (cid:3) ((cid:2) 0 r ¬ A), which, however, for some concept name Ais not in normal form. Note also that for A = (cid:9) the corresponding CI (cid:9) (cid:3) ((cid:2) 0 r ¬(cid:9)) is a tautology, which explains why it is not required in the normal form. Every TBox can be normalized in polynomial time by introducing fresh concept names for complex concepts and axiomatizing them accordingly. To make this precise, let us say that a TBox T (cid:14)is a conservative extension of a TBox T if each model of T (cid:14)is a model of T and each transitive model of T can be expanded to a model of T (cid:14).Proposition 1. For every SQu -TBox T one can compute in polynomial time an SQu -TBox T (cid:14)conservative extension of T .in normal form such that T (cid:14)is a Proof. Let us introduce a fresh concept name XC for every concept C that occurs in T , and additionally a fresh concept name X((cid:2)(n+1) r C) for each concept of the form ((cid:2) n r C) that occurs in T . Let T (cid:14)be the set of the following concept inclusions:• X⊥ (cid:3) ⊥, (cid:9) (cid:3) X(cid:9);• X A (cid:3) A, A (cid:3) X A for all concept names A used in T ;• XC(cid:5)D (cid:3) XC , XC(cid:5)D (cid:3) X D , XC (cid:5) X D (cid:3) XC(cid:5)D for all C (cid:5) D that occur in T ;• X¬C (cid:5) XC (cid:3) ⊥, (cid:9) (cid:3) X¬C (cid:10) XC for all ¬C that occur in T ;• (cid:9) (cid:3) X((cid:3)n r C) (cid:10) X((cid:2)(n+1) r C), X((cid:3)n r C) (cid:3) ((cid:2) n r XC ), X((cid:2)(n+1) r C) (cid:3) ((cid:3) (n + 1) r XC ) for all ((cid:2) n r C) that occur in T ;• X((cid:3)n r C) (cid:3) ((cid:2) 0 r X((cid:2)(n+1) r C)) for all ((cid:2) n r C) with r ∈ Nt• XC (cid:3) X D for all C (cid:3) D ∈ T .R that occur in T ;Observe that T (cid:14)most restrictions involving transitive role names are propagated. Clearly, T (cid:14)It is routine to verify that T (cid:14)is in normal form: all concept inclusions are in normal form and the penultimate bullet ensures that at-can be computed from T in polynomial time. is a conservative extension of T . (cid:2)4V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 1038082.3. Ontology-mediated query entailmentWe next introduce the query language. We concentrate on Boolean queries, that is, queries without answer variables. The extension to queries with answer variables is standard; see, for example, [6]. A positive existential two-way regular path query (P2RPQ) is a first-order formulaϕ = ∃x ψ(x)such that ψ(x) is constructed using ∧ and ∨ over atoms of the form E(t, tnames from NI, and E is a path expression defined by the grammar(cid:14)) where t, t(cid:14)are variables from x or individual E, E (cid:14) ::= r | r− | A? | E ∗ | E ∪ E (cid:14) | E ◦ E (cid:14),where r ∈ NR and A ∈ NC. Thus, E is essentially a regular expression over the (infinite) alphabet {r, rNC}. The set of individual names in ϕ is denoted with ind(ϕ).− | r ∈ NR} ∪ { A? | A ∈The semantics of P2RPQs is defined via matches. Let us fix a P2RPQ ϕ = ∃x ψ(x) and an interpretation I. A match for ϕin I is a functionπ : x ∪ ind(ϕ) → (cid:3)Isuch that π (a) = a, for all a ∈ ind(ϕ), and I, π |= ψ(x) under the standard semantics of first-order logic extended with a rule for atoms of the form E(t, t(cid:14)). More formally, we define:• I, π |= ψ1 ∨ ψ2 iff I, π |= ψ1 or I, π |= ψ2;• I, π |= ψ1 ∧ ψ2 iff I, π |= ψ1 and I, π |= ψ2;, where E I(cid:14)) iff (π (t), π (t• I, π |= E(t, t(cid:14))) ∈ E Iis defined inductively as follows:−(r(E ∗)I = {(e, d) | (d, e) ∈ r∗)I = (E I )I }( A?)I = {(d, d) | d ∈ AI }(E1 ∪ E2)I = E I1∪ E I2(E1 ◦ E2)I = E I1◦ E I2We write I |= ϕ if there is a match for ϕ in I. A query ϕ is entailed over an ABox A relative to a TBox T , denoted asT , A |= ϕ ,if I |= ϕ for every model I of T and A with I∗ = I. That is, entailment is defined as usual, relative to all interpretations that respect the transitivity of role names.Now, we are ready to define the reasoning problem that we study throughout the paper, ontology-mediated query entail-ment.Input: ABox A, SQu -TBox T , and a P2RPQ ϕ.Question: Is ϕ entailed over A relative to T ?We shall assume that the input TBox is in normal form. This is possible because replacing a TBox with its conservative extension does not affect entailment of queries over the original concept and role names. Complexity bounds are not af-fected either, because a normalized conservative extension of a given SQu -TBox can be computed in polynomial time, by Proposition 1.It is standard to show that it is without loss of generality to assume that input queries use no individual names [21]. In a nutshell, we can eliminate each individual name a from the query by replacing it uniformly with a fresh variable xaand adding to the query the conjunct Aa(xa) for a fresh concept name Aa; if a is mentioned in the ABox, we also add the assertion Aa(a) to the ABox. The modified query is entailed over the modified ABox if and only if the original query is entailed over the original ABox [21]. We stress that in spite of the input query using no individual names, our decision procedure will manipulate queries with individual names at intermediate stages.We shall explore both combined and data complexity of the ontology-mediated query entailment problem [17]. For the former, the complexity is measured in terms of the sizes of the TBox, ABox, and query, while for the latter, it is measured only in the size of the ABox. We assume a natural binary encoding of the input. We write (cid:22)A(cid:22), (cid:22)T (cid:22), and (cid:22)ϕ(cid:22) for the sizes of the representations of the ABox A, the TBox T , and the query ϕ, respectively.5V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808LeftAtriumHeartMitralValveBALeftVentricle(a) Diamond.(b) 3-clique.Fig. 1. Structures enforced by SQu TBoxes in Example 1.BB2.4. Tree decompositionsA tree is a prefix-closed subset T ⊆ (N − {0})∗. A node w ∈ T is a child of v ∈ T and v is the parent of w if w = v · ifor some i ∈ N. We write children(v) for the set of children of v. The degree of v is |children(v)|. We say that the node ε, corresponding to the empty sequence, is the root of T . A subset S ⊆ T is connected if every two nodes in S are connected by a path of nodes from S (possibly going up and down the tree). Every non-empty connected subset S of T can be seen as a tree and has a unique root: the element of S that is closest to the root of T .We use the standard notion of tree decompositions. Observe, however, that here it is essential to allow for interpretations that do not interpret transitive role names by transitive relations, since transitive relations are dense in the sense that they do not admit a tree decomposition of small width even if the transitive relation is induced by a relation of small width. Formally, a tree decomposition T of an interpretation I is a pair (T , I) where T is a tree and I is a function that assigns a (cid:4)v -interpretation Iv = ((cid:3)v , ·Iv ) to each v ∈ T such that(cid:4)(D1) I =(D2) for every d ∈ (cid:3)IIv ; andv∈T, the set {v ∈ T | d ∈ (cid:3)v } is connected in T .We often blur the distinction between a node v of T and the associated interpretation Iv , using the term bag for both. The |children(v)|. Because {v ∈ T | d ∈ (cid:3)v } is non-empty and connected width of T is supv∈Tfor each d ∈ (cid:3)I, there is a unique bag v closest to the root ε such that d ∈ (cid:3)v . We say that d is fresh in this bag, and write F (v) for the set of all elements fresh in v. Note that F (ε) = (cid:3)ε .|(cid:3)v | − 1; the degree of T is supv∈TIn this work we additionally assume that(D3) for all u, v ∈ T , the restrictions of Iu and Iv to domain (cid:3)u ∩ (cid:3)v and signature (cid:4)u ∩ (cid:4)v coincide.This is without loss of generality because one can always replace Iv by the restriction of I to domain (cid:3)v and signature (cid:4)v .3. Tree-like countermodel propertyIn this section we show a tree-like countermodel property for SQu : we show that if a query is not entailed over an ABox A relative to a TBox T , then there is a countermodel with a tree decomposition of bounded width and degree. Let us first demonstrate why SQu does not enjoy the tree model property.Example 1. Reconsider the TBox T defined in the introduction. The number restrictions ensure that every model of Tsatisfying Heart contains the structure in Fig. 1a, which is clearly not tree-shaped. In fact, in SQu one can even enforce a clique. Consider the TBoxT (cid:14) = { A (cid:3) ((cid:3) 3 r B), B (cid:3) ((cid:3) 3 r B), (cid:9) (cid:3) ((cid:2) 3 r B), A (cid:5) B (cid:3) ⊥} ,R is a transitive role name. In every model of T (cid:14)where r ∈ Nt, each element satisfying A is the root of a structure depicted in Fig. 1b where the elements satisfying B form an r-clique; that is, there are r-edges in both directions between the three elements satisfying B. Observe that the number 3 in T (cid:14)can be replaced by any number n; thus, large cliques can be enforced.Consequently, the best we can hope for is a tree-like countermodel property; that is, we have to move from trees to tree decompositions. Intuitively, fragments of the countermodel that cannot be unravelled, like the clique in Example 1, will constitute bags. Note that Example 1 shows that bags may need to be large, even exponentially large due to the binary representation of numbers. For the automata-based decision procedure to yield optimal upper bounds, it is useful to consider canonical decompositions which we define next.6V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 1038083.1. Canonical tree decompositionsProcessing generic tree decompositions is costly. For instance, to verify that the represented interpretation is a model of an ABox, the automaton needs to maintain the set of assertions to be witnessed in the current subtree, which leads to (at least) exponential data complexity. Similarly, to verify an at-most restriction or an at-least restriction for a single element, the automaton needs to scan unbounded fragments of the tree decomposition for the relevant neighbours. Canonical tree decompositions are designed to make these tasks easier.I∗if (d, e) ∈ rLet us fix an ABox A and an SQu TBox T in normal form. In canonical tree decompositions elements will be accom-is a directly relevant r-successor of and e ∈ B. For an interpretation Ir (d) of relevant r-successors of d in I is the least set that contains d and is from Example 1 and the interpretation I shown Ir (d) = {d, e1, e2, e3}. panied by certain key neighbours. For an interpretation I and r ∈ Ntd ∈ (cid:3)II, an element d ∈ (cid:3)Iclosed under directly relevant r-successors. For instance, for the TBox T (cid:14)in Fig. 1b, if AThe following is an immediate consequence of the definition.R, we say that e ∈ (cid:3)Iand there is a concept inclusion A (cid:3) ((cid:2) n r B) in T such that d ∈ A, and r ∈ NtI = {e1, e2, e3}, then e1, e2, e3 are directly relevant r-successors of d and relI = {d} and BR, the set relIILemma 1. For all r ∈ NtR, d ∈ (cid:3)IIIr (e) ⊆ rel, and e ∈ relr (d), we have relIr (d).Crucially, in models of T the sets of relevant r-successors have bounded size.Lemma 2. If I |= T , then for each r ∈ NtR and d ∈ (cid:3)Ir (d)| ≤ 2poly((cid:22)T (cid:22)).I, |relProof. Let us arrange the elements of relexhaustively: Choose a leaf e and add as its children all elements f ∈ relare not yet in T . This way all elements of relgiven byIr (d) into a tree T , as follows. Let d be the root of T and then apply the following Ir (d) that are directly relevant r-successors of e but Ir (d) → 2NCIr (d) will find their place in T . Now, consider the labelling (cid:8) : rel(cid:5)(cid:8)(e) =B | A (cid:3) ((cid:2) n r B) ∈ T , e ∈ A(cid:6)I.Let f be a child of e. By construction, we have– (cid:8)(e) ⊆ (cid:8)( f ) if f– (cid:8)(e) (cid:2) (cid:8)( f ) if fis a leaf in T , andis an inner node in T .Because (cid:8) only uses concept names occurring in T , the depth of T is bounded linearly in (cid:22)T (cid:22). Because I |= T , the number of directly relevant r-successors of any given element is bounded exponentially in (cid:22)T (cid:22): recall that numbers in at-most restrictions are represented in binary. Hence, the branching of T is at most exponential in (cid:22)T (cid:22). Overall, the size of T is at most 2poly((cid:22)T (cid:22)). (cid:2)Canonical tree decompositions are formalized in Definition 1 below. Intuitively, each non-root bag v keeps track of the interpretation of all concept names, but only a single role name rv . Condition (C1) ensures that all ABox assertions are already witnessed in the root bag. Conditions (C2)–(C4) express that T is respected locally: (C2) ensures that all elements satisfy all concept inclusions that do not mention role names, (C3) ensures that suitable at-most restrictions are locally satisfied for fresh elements, and (C4) does the same for at-least restrictions. Conditions (C2) and (C4) imply that the corre-sponding concept inclusions are globally satisfied in the represented interpretation. For (C3) this is no longer true, because more distant bags may add further successors, possibly violating some at-most restrictions. This is remedied by condition (C5), which restricts the ways in which neighbouring bags may overlap: if they represent different role names or the same non-transitive role name, then they share a single element, but if they represent the same transitive role name, they share an element accompanied by all its relevant successors.Definition 1. A tree decomposition T = (T , I) is (T , A)-canonical if (cid:4)ε = NC ∪ NR and for each w ∈ T − {ε} there exists r w ∈ NR such that (cid:4)w = NC ∪ {r w } and for each v ∈ T ,(C1) Iε |= A;(C2) Iv satisfies all CIs in T of the forms (cid:5)i Ai (cid:3) (cid:10) j B j and A (cid:3) ((cid:2) n r B) with r ∈ NtR;(C3) for each concept inclusion A (cid:3) ((cid:2) n r B) in T with r ∈ NntR and each d ∈ F (v) ∩ A(cid:4)r-successors satisfying B in Iv ∪w∈children(v)Iw ;(C4) for each concept inclusion A (cid:3) ((cid:3) n r B) in T and each d ∈ F (v) ∩ Aelement d has at least n r-successors satisfying B in Iv ∪ Iw ;(C5) for each child w of v there exists d ∈ F (v) such thatIv , the element d has at most nIv there exists a child w of v such that the 7V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808– if r w ∈ Nt– if r w ∈ NntR and r w ∈ (cid:4)v , then (cid:3)v ∩ (cid:3)w = relR or r w /∈ (cid:4)v , then (cid:3)v ∩ (cid:3)w = {d}.Ivr w (d) = relIwr w (d),Because T is in normal form, the sets of relevant successors are faithfully represented in each bag of a (T , A)-canonical tree decomposition.Lemma 3. Let T = (T , I) be a (T , A)-canonical tree decomposition of J . Then relNtR∩ (cid:4)v ,IvJr (d) for all v ∈ T , d ∈ (cid:3)v , and r ∈r (d) = relProof. As the first step towards the claim of the lemma, note that from (C5) it follows by Lemma 1 that for all u, v ∈ T , d ∈ (cid:3)u ∩ (cid:3)v , and r ∈ NtR∩ (cid:4)u ∩ (cid:4)v ,(6)relIur (d) = relIvr (d) .Next, we show that if an element f ∈ (cid:3)JJ, then (e, f ) ∈ rin J , then f ∈ relis a directly relevant r-successor of an element e ∈ (cid:3)JIur (e)for all u ∈ T with e ∈ (cid:3)u and r ∈ (cid:4)u . The proof is by induction on the length of the shortest r-path connecting e to f in J . IuIv for some v ∈ T with r ∈ (cid:4)v , and it follows immediately that f ∈ relIf (e, f ) ∈ rr (e)for all u ∈ T with e ∈ (cid:3)u . Suppose now that the claim holds for all e and f connected by an r-path in J of length at most k. Take e and f connected by an r-path in J of length k + 1. The first element on this path is an r-successor eof e, Iv and r ∈ (cid:4)v . By the definition of directly connected to f with a path of length at most k. Take v ∈ T such that (e, eJrelevant r-successors, there exists a concept inclusion A (cid:3) ((cid:2) n r B) in T , such that e ∈ A. Consequently, also Iv , e ∈ A(cid:14)), (cid:14) ∈ Aand so eis a directly relevant r-successor of e in Iv . and consequently (eConsequently, f ∈ relIv . Because at-most restrictions involving transitive roles are propagated, we can conclude from (C2) that ein J . By the inductive hypothesis, f ∈ relI∗v . Hence, also (e, f ) ∈ rIur (e) for all u ∈ T with e ∈ (cid:3)u and r ∈ (cid:4)u . This completes the proof of the claim.. This means that f(cid:14), f ) ∈ rIvr (e). By (6), f ∈ relIvJr (d) for all v ∈ T with d ∈ (cid:3)v and r ∈ Ntr (d) = relRIvJr (d) ⊆ relr (d) holds because Iv is the restriction of J to signature (cid:4)v and domain (cid:3)v . For the converse inclusion, it suffices to see that for each Ive ∈ relr (e). By Lemma 1, relis a directly relevant r-successor of eI∗v and it follows that f, if f is a directly relevant r-successor of e in J , then f ∈ relIvr (d). By the claim above, f ∈ relIvr (e). By (6), f ∈ relIvr (d), and we are done. (cid:2)∩ (cid:4)v . The inclusion relIvr (d) and f ∈ (cid:3)JLet us now see that relIvr (e) ⊆ rel(cid:14) ∈ AIvr (eand f ∈ B(cid:14)) ∈ rJJ(cid:14)(cid:14)Using Lemma 3, it is easy to show that respecting T locally in a canonical tree decomposition is sufficient to ensure that the decomposed interpretation is a model of T .Lemma 4. If J has a (T , A)-canonical tree decomposition, then J ∗ |= T ∪ A.Next, we show that each CI from T holds in J ∗Proof. Let T = (T , I) be a canonical tree decomposition of J . By (C1), Iε |= A. Because Iε ⊆ J ⊆ J ∗, we have J ∗ |= A.because they hold in Iv for each v ∈ T . For at-least restrictions, all necessary witnesses for element d are ensured by the condition (C4) applied to the node v with d ∈ F (v). It remains to deal with at-most restrictions.. CIs of the form (cid:5)i Ai (cid:3) (cid:10) j B j hold in J ∗Take a concept inclusion A (cid:3) ((cid:2) n r B) from T involving a non-transitive role name r and d ∈ F (v) ∩ Afor some bag v. It follows from (C5) that r-successors of d can be present only in v and its child bags. Consequently, the condition (C3) Jensures that d has at most n r-successors in J belonging to B, and the same holds in J ∗J.Finally, take a concept inclusion A (cid:3) ((cid:2) n r B) from T involving a transitive role name r and d ∈ (cid:3)v ∩ Abag v with r ∈ (cid:4)v . By definition, all r-successors of d in J ∗relIvr (d), so their number is bounded by n owing to (C2). (cid:2)Jr (d) = relbelonging to Bare included in relJJfor some Jr (d). By Lemma 3, 3.2. Tree-like countermodel propertyWe are now ready to establish the tree-like countermodel property. We employ a refined variant of unravelling to ensure not only bounded treewidth of the model, but also canonicity of the associated tree-decomposition, which will be instrumental in the construction of the automaton verifying the ABox and the TBox. Note however that the decomposition does not represent the countermodel itself, but an interpretation J whose transitive closure J ∗is a countermodel. This will make the job of the query automaton harder, forcing it to compute the transitive closure on the fly.Example 2. Consider the ABox A = { A(a)} and the TBoxT = { A (cid:3) ((cid:3) 1 r B) , B (cid:3) ((cid:3) 1 r C) , C (cid:3) ((cid:3) 1 r D) ,(cid:9) (cid:3) ((cid:2) 1 r D) , B (cid:3) ((cid:3) 1 s A) } ,8V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808ACACACDDDBBBAA(R3)BA(R2)A(R1)BB(R3)BDDDDCACDB(a) A model.(b) An unravelling(c) A canonical tree decomposition.Fig. 2. A model of the TBox in Example 2, an unravelling, and its canonical decomposition.where r is a transitive role name and s a non-transitive role name.Let I be the instance shown in Fig. 2a, where solid and dashed lines represent r-edges and s-edges, respectively, and the unique element satisfying A is the individual name a. It is straightforward to check that I |= T ∪ A. Observe that the unique element d satisfying D is a directly relevant r-successor of each element in I and for each e ∈ (cid:3)IIr (e) = {d, e}.we have relFig. 2b shows an unravelling J of I. We shall explain later how it is obtained. For now, note that our unravelling operation does not preserve neighbourhoods: for instance, elements satisfying C do not have s-neighbours satisfying Aany more. Indeed, only neighbours explicitly required by the TBox will be copied. Note also that J is not transitive, as the transitive role name r is not interpreted as a transitive relation. This is because the unravelling operation will be constructing directly a tree decomposition (of bounded bag size) and only edges between elements falling inside the same bag will be included.Fig. 2c shows a canonical tree decomposition of J of degree 2 and width 2; that is, the underlying tree is binary and bags have size at most 3. Bags are depicted as if they were disjoint, but elements connected by a dotted grey line should be identified with each other. For example, the root bag shares both its elements with its child bag. Note that elements satisfying A and C never meet in the same bag, which explains why there are no edges between them in J , even though their originals in I are connected with an s-edge and an r-edge.Theorem 1. Let A be an ABox, T an SQu TBox in normal form, and ϕ a P2RPQ such that T , A (cid:16)|= ϕ. Then there exists an interpretation J with a (T , A)-canonical tree decomposition of width and degree at most (cid:22)A(cid:22) · 2poly((cid:22)T (cid:22)) such that J ∗ |= T ∪ A, and J ∗ (cid:16)|= ϕ. Moreover, one can additionally guarantee that each non-root bag in the tree decomposition has size and degree bounded by 2poly((cid:22)T (cid:22)).Proof. Let us fix an interpretation I such that I |= T ∪ A and I (cid:16)|= ϕ. To build a canonical tree decomposition T, we unravel I. We start from the interpretation of the ABox together with its relevant successors and then apply the extension rules (R1)–(R3) below: (R1) performs unravelling of non-transitive role names, (R2) takes care of the change of roles to a transitive one, and (R3) realizes further unravelling of transitive role names. Each application of a rule will add a new bag, holding an interpretation obtained by restricting I and then replacing some elements d with fresh copies d. In such case we shall call d the original of d. The rules will ensure that mapping each element to its original gives a homomorphism from the constructed interpretation to I. We shall illustrate the construction using the ABox A, TBox T , and instance Idescribed in Example 2.(cid:14)(cid:14)For the root bag, we take the restriction of I to the domain(cid:3)ε = ind(A) ∪(cid:7)(cid:7)r∈NtRa∈ind(A)relIr (a) .IIn our example, ind(A) = {a}, relr (a) = {a, d}, and the resulting root bag is shown in Fig. 2c; note that it is the only bag that has unrestricted signature and represents all roles. Then, we use the following rules (R1)–(R3) ad infinitum, applying each rule only once to each previously added bag v: for each fresh element d in v and each role r, exactly one rule will fire and 9V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808it will add (at most) one bag containing all r-successors of d that are needed to satisfy the at-least restrictions enforced by the TBox (see Fig. 2c).(R1) For each r ∈ NntR and each d(cid:14) ∈ F (v), let d ∈ (cid:3)Ibe the original of d(cid:14)(cid:14)in Iv . Pick a minimal set W ⊆ (cid:3)Iof all r-successors of dIT , if d ∈ A, then d has at least n different r-successors in B(cid:4)w = NC ∪ {r} and domain (cid:3)w = {d} ∪ (W − W 0), with d replaced by dcopy e. If Ir,d(cid:14) (cid:3) Iv , add Ir,d(cid:14) as a child bag of v.(cid:14)(cid:14)(possibly d = d) and let W 0 be the set of originals containing {d} ∪ W 0 such that for each A (cid:3) ((cid:3) n r B) in I ∩ W . Let Ir,d(cid:14) be the restriction of I to the signature and each e ∈ W − W 0 replaced by a fresh (cid:14)(R2) For each r ∈ NtR(cid:14) ∈ F (v), let d ∈ (cid:3)IIr (d) such that for each A (cid:3) ((cid:3) n r B) in T , if d ∈ A− (cid:4)v and each drelIr,d(cid:14) be the restriction of I to the signature (cid:4)w = NC ∪ {r} and domain (cid:3)w =Iand each f ∈r (e) − {d} replaced by a fresh copy fe∈W relIr,d(cid:14) (cid:3) Iv , add Ir,d(cid:14) as a child bag of v.. Pick a minimal set W ⊆ (cid:3)Ibe the original of dI, then d has at least n different r-successors in B(cid:4)containing I ∩ W . Let I(cid:14), r (e), with d replaced by de∈W relIr (d) is included in Ir,d(cid:14) .) If . (Because d ∈ W , a copy of rel(cid:4)(cid:14)(cid:14)(R3) For each r ∈ NtRcopy f(cid:14)∩ (cid:4)v , proceed as in (R2) taking the same restriction of I but replace each element f ∈ rel(cid:4)from Iv , and each element f ∈Ir (e) − rele∈W relIr (d) by a fresh copy f(cid:14).Ir (d) by its (cid:14)Clearly, T is a tree decomposition: Conditions (D1)–(D2) are straightforward, and Condition (D3) holds because each Ivis isomorphic to a restriction of I. Let us see that T is canonical. The signatures (cid:4)v clearly satisfy the required conditions. Condition (C1) holds because Iε contains the restriction of I to ind(A). Condition (C2) holds because each Iv is isomorphic to a restriction of I.can be present only in v and the unique child w of v with dLet us check (C3). Take a concept inclusion A (cid:3) ((cid:2) n r B) from T involving a non-transitive role name r and d(cid:14) ∈Iv for some bag v. Because r is a non-transitive role name and rules are applied only once to each node v, r-F (v) ∩ A(cid:14) ∈ (cid:3)w and r ∈ (cid:4)w , created using rule (R1). successors of d(cid:14)in Iv ∪ Iw are also Hence, we can work with Iv ∪ Iw . We claim that the originals of any two different r-successors of d(cid:14) ∈ (cid:3)w , then (cid:14) ∈ (cid:3)v or e(cid:14)different. Let e(cid:14) ∈ (cid:3)w . Then, it follows the claim follows because Iv and Iw are isomorphic to restrictions of I. Assume that efrom (R1) that e ∈ W 0 and f ∈ {d} ∪ (W − W 0). Hence, e (cid:16)= f unless e = f = d. But in the latter case, (R1) ensures that (cid:14)(cid:14) = d(cid:14) = f, which completes the proof of the claim. Now, because Iv and Iw are isomorphic to restrictions of I, it follows eIIv ∪Iw are r-successors of d belonging to Bthat d ∈ A. By the and that the originals of r-successors of dIv ∪Iw is bounded by the number of r-successors of d belonging claim above, the number of r-successors of dto B(cid:14) ∈ (cid:3)v ∪ (cid:3)w be r-successors of d, which is at most n because I |= T .(cid:14), f(cid:14) ∈ (cid:3)v and f, and let e, f ∈ (cid:3)Ibe their originals. If ebelonging to Bbelonging to B(cid:14), f(cid:14), fII(cid:14)(cid:14)Condition (C4) holds because all necessary witnesses are provided by rule (R1) if the involved role name is non-transitive, or by rules (R2) and (R3) if it is transitive. Condition (C5) is easy to verify based on (R1)–(R3).r (d)| ≤ 2poly((cid:22)T (cid:22)) for all r ∈ NtIBy Lemma 2, |relR and d ∈ (cid:3)I. It follows that|(cid:3)ε| ≤ |ind(A)| · N1 · 2poly((cid:22)T (cid:22)) ,where N1 is the number of transitive role names that occur in T . Examining the rules (R1)–(R3) we see that for all w ∈ T − {ε},|(cid:3)w | ≤ (1 + |T | · N2) · 2poly((cid:22)T (cid:22)) ,where N2 is the maximal number in at-least restrictions in T . That is, |(cid:3)ε| ≤ (cid:22)A(cid:22) · 2poly((cid:22)T (cid:22)) and |(cid:3)w | ≤ 2poly((cid:22)T (cid:22)) for w (cid:16)= ε. The same bounds hold for the degrees of ε and w, because each bag has at most N3 child bags for each element of the domain, where N3 is the number of role names that occur in T .Iv . By Lemma 4, J ∗ |= T ∪ A. The function mapping each d(cid:14) ∈ (cid:3)Jto its original d ∈ (cid:3)Igives a homo-Let J =(cid:4)v∈Tmorphism from J to I, and consequently also from J ∗to I. It follows that J ∗ (cid:16)|= ϕ. (cid:2)This concludes the technical development of this section. The tree-like countermodel property from Theorem 1 shows that in our search for counter-models we can restrict our attention to tree-like models of T and A that admit canonical tree decompositions. In Section 5, we construct a tree automaton that works over (appropriately encoded) tree decompositions and accepts the input iff it is (T , A)-canonical. The forthcoming Section 4 lays foundations for the second ingredient of the decision procedure, which is checking that the interpretation represented by the tree decomposition falsifies the query; the corresponding automaton is also constructed in Section 5.4. Matching queries in tree decompositionsThe goal of this section is to characterize when a query is satisfied in an interpretation J , which is given by its tree decomposition (T , I), in a way that lends itself to a tree automata implementation. Our approach is rather general since it works for arbitrary tree decompositions; in particular, it does not rely on the canonicity of the tree decomposition. We believe that, as such, it is of independent interest.10V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808More specifically, we aim to use non-deterministic tree automata over infinite trees (a precise definition will be given in Section 5). Since such automata are inherently local, we face the challenge of dealing with non-locality of P2RPQs. Let us illustrate this using a simple example. Consider the queryq = ∃x ∃ y A(x) ∧ r∗(x, y) ∧ B( y).JJ, b ∈ BInformally, q has a match in the interpretation J given by a tree decomposition (T , I) if there are elements a, b such that a ∈ A, and there is an r-path from a to b. Such a path will typically use elements from different bags from (T , I)and it might go “up and down” in the tree decomposition. Moreover, a and b can be arbitrarily far away from each other in the tree decomposition. These points make it difficult for non-deterministic tree automata to check the existence of such paths.We resort to the following strategy: rather than treating the input query ϕ as a whole, we shall consider splits of ϕ into pieces. Intuitively, a split of a query ϕ is a set of queries P such that ϕ has a match if all the queries in P have a localmatch, that is, a match in a single bag. Thus, the idea is to annotate the nodes of tree decompositions with sets of queries which have local matches and analyze how these pieces can be put together. It will then be the case that a query ϕ is not entailed by (T , I) iff there is a valid annotation that does not contain ϕ. Let us formalize this idea.To ease the technical development in this section, we make two simplifying assumptions. First, we focus on conjunctive two-way regular path queries (C2RPQs) which are P2RPQs of the form∃x E1(t1, t(cid:14)1) ∧ . . . ∧ En(tn, t(cid:14)n),that is, P2RPQs that do not use disjunction ∨. In what follows, we denote C2RPQs with letters p, q, . . .. Moreover, we skip the existential quantifiers, view all variables of a C2RPQ q, denoted as var(q), as implicitly existentially quantified, and often treat a C2RPQ as the set of atoms that occur in it. Establishing the characterization for C2RPQs is sufficient because every P2RPQ is equivalent to a disjunction of C2RPQs, see Section 5 below.Second, we work with a representation of C2RPQs based on non-deterministic finite automata (NFA). Under that repre-(cid:14)), where B is an NFA. We assume that all NFA are over a sentation, a C2RPQ is a conjunction of atoms of the form B(t, tfinite alphabet (cid:9) with(cid:9) ⊆ {r, r− | r ∈ NR} ∪ { A? | A ∈ NC},and use a single initial state and a single final state. Given an NFA B and two states s, sNFA obtained from B by making s the initial state and sNFA-based representation by letting I, π |= B(t, tthatof B, we denote with Bs,s(cid:14) the the unique final state. We adjust the definition of match to the such (cid:14)) iff for some n ∈ N there exist ν1, . . . , νn ∈ (cid:9) and a0, . . . , an ∈ (cid:3)I(cid:14)(cid:14)• a0 = π (t), an = π (t• the word ν1 . . . νn is accepted by B;• for all i ∈ {1, . . . , n}, we have if νi = A?, then ai−1 = ai ∈ A(cid:14));Ir.I, if νi = r, then (ai−1, ai) ∈ rI, and if νi = r−, then (ai, ai−1) ∈As before, for a C2RPQ p we write I |= p if there is a match of p in I. For a set P of C2RPQs we write I |= P if I |= p for each p ∈ P .We can now formally define what we mean by a split. Let us fix a domain (cid:3). We say that a C2RPQ pis a (cid:3)-instantiationof a C2RPQ p if it can be obtained from p by consistently replacing an arbitrary number of existentially quantified variables in p with elements from (cid:3). A (cid:3)-subdivision of an atom B(t, t(cid:14)) is a conjunction of the form(cid:14)Bs0,s1 (t0, t1) ∧ Bs1,s2 (t1, t2) ∧ · · · ∧ Bsn,sn+1 (tn, tn+1)where n ∈ N, s0, s1, . . . , sn+1 are states of B, s0 is the initial state, sn+1 is the final state, t1, t2, . . . , tn ∈ (cid:3), t = t0, and (cid:14) = tn+1. Then, ptis a (cid:3)-subdivision of p if it can be obtained from p by replacing some atoms with their (cid:3)-subdivisions.(cid:14)Definition 2. Let p be a C2RPQ and let P be a set of C2RPQs obtained by partitioning (the set of atoms of) a (cid:3)-subdivision of a (cid:3)-instantiation of p. Then, P is called a (cid:3)-split of p if• var(p1) ∩ var(p2) = ∅ for all different p1, p2 ∈ P ;• each p ∈ P either is a single ground atom over (cid:3) or contains no ground atoms over (cid:3).We write cl(p, (cid:3)) for the union of all (cid:3)-splits of p.We illustrate the notion in the following example.11V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 1038080A?1B?C ?2r3I1aAdbBI2ecC(a) NFA B.(b) Interpretation I = I1 ∪ I2.Fig. 3. The automaton and interpretation in Example 3.Example 3. Consider the NFA B shown in Fig. 3a and the C2RPQq = B0,2(x, y) ∧ B1,1( y, x) ∧ B1,3( y, z) .∗ ◦ C ?, respectively. Consequently, qNote that B0,2, B1,1, and B1,3 correspond to path expressions A? ◦ rchecks whether there are elements x, y, z satisfying A, B, C , respectively, such that x and y lie on an r-cycle, and z is r-reachable from y. The function π mapping x to a, y to b, and z to c is a match of q in the interpretation I shown in Fig. 3b. Let (cid:3) = {b, d}. Then, queries∗ ◦ B?, r, and r∗q1 = B0,2(x, b) ∧ B1,1(b, x) ∧ B1,3(b, z) andq2 = B0,2(d, b) ∧ B1,1(b, d) ∧ B1,3(b, z)are (cid:3)-instantiations of q (the second cannot be matched in I). Moreover, the queryˆq1 = B0,1(x, d) ∧ B1,2(d, b) ∧ B1,1(b, x) ∧ B1,3(b, z)is a (cid:3)-subdivision of q1, obtained by replacing the atom B0,2(x, b) with its subdivision B0,1(x, d) ∧ B1,2(d, b), where B0,1and B1,2 correspond to path expressions A? ◦ r∗ ◦ B?, respectively. It can be verified that the setsand r∗(cid:2)(cid:2)(cid:3)B0,1(x, d) ∧ B1,1(b, x) ∧ B1,3(b, z) , B1,2(d, b)(cid:3)B0,1(x, d) ∧ B1,1(b, x) , B1,3(b, z) , B1,2(d, b),P =(cid:14) =P(cid:14)can be partitioned into P 1 =are (cid:3)-splits of q. Note that, by the second point in Definition 2, the ground atom B1,2(d, b) must occur as a single atom in the split, and, by the first point, atoms that share a variable must end up in the same element of the split. Note also that such that I1 |= P 1 and I2 |= P 2, and P 2 =Pwhere I1 and I2 are as indicated in Fig. 3b. We invite the reader to look at this with the intuition of splits provided above in mind, that is, to view I1 and I2 as two neighbouring bags in a tree decomposition. Then P i has a match in Ii , for i = 1, 2which induces the match of q in the union I1 ∪ I2. We show in Lemma 5 (2) below that it is always possible to find a (cid:3)I1 ∩ (cid:3)I2 -split of a query satisfied in I1 ∪ I2.(cid:3)B0,1(x, d) ∧ B1,1(b, x)(cid:3)B1,3(b, z) , B1,2(d, b)(cid:2)(cid:2)In the following lemma we collect some useful properties of splits.Lemma 5. Let p be a C2RPQ.1. Let I be an interpretation such that I |= P for some (cid:3)I2. Let I1 and I2 be interpretations such that I1 ∪ I2 |= p. Then there exists a (cid:3)I1 ∩ (cid:3)I2 -split P 1 ∪ P 2 of p such that I1 |= P 1 and -split P of p. Then I |= p.3. Each (cid:3)-split of a query from cl(p, (cid:3)) is a subset of cl(p, (cid:3)).4. If (cid:3) is finite and p has n atoms, each using an automaton with at most m states, then each q ∈ cl(p, (cid:3)) has at most 2n atoms and I2 |= P 2.|cl(p, (cid:3))| ≤ (6 · m2 · |(cid:3)|2)n.Let us comment on the claims of Lemma 5 before we move on to its proof. Item (1) makes precise the intuition of splits discussed at the beginning of the section: a match of a split of p induces a match of p; the correctness of our characterization relies on this. Item (2) states that one can always split matched p in a way compatible with a given decomposition of the interpretation; it will be used to show completeness of the characterization. Item (3) states that cl(p, (cid:3)) is closed under taking splits, which is also needed for the completeness proof. Finally, (4) provides upper bounds 12V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808both on the cardinality of cl(p, (cid:3)) and on the sizes of the queries therein; this is not relevant for the characterization itself, but it will matter for establishing precise complexity upper bounds in Section 5. The proof of the lemma, given below, is straightforward. The reader might prefer to skip it and first see how the lemma is used to prove the correctness and completeness of the characterization (Lemma 6).-instantiation of p, the claim follows.Proof. (1) If p(cid:3)Ieach (cid:3)I-subdivision of p(cid:14)is a (cid:3)I(cid:14)-split of p is a partition of a (cid:3)I(2) Let π be a match of p in I1 ∪ I2. Let p(cid:14)such that I |= p(cid:14)(cid:14), then I |= p(cid:14)-subdivision of a (cid:3)I-instantiation of p such that I |= p, then I |= p. By the semantics of NFA-based C2RPQs, if p(cid:14). Finally, if P is a partition of p(cid:14)(cid:14)such that I |= P , then I |= p(cid:14)(cid:14)is a . Because (cid:14)(cid:14)(cid:14)) or I2, π |= B(t, tbe the instantiation obtained from p by replacing every x ∈ var(p) satisfying π (x) ∈ (cid:3)I1 ∩ (cid:3)I2 with π (x). We shall construct a (cid:3)I1 ∩ (cid:3)I2 -subdivision (cid:8)p of p(cid:14)) in (cid:8)p, either (cid:14)(cid:14)). Based on (cid:8)p we can define the desired (cid:3)I1 ∩ (cid:3)I2 -split P 1 ∪ P 2 of p by letting P i contain I1, π |= B(t, tall ground atoms over (cid:3)I1 ∩ (cid:3)I2 that are satisfied in Ii , as well as the conjunction qi of all remaining atoms satisfied in Ii under the match π ; note that var(q1) ∩ var(q2) = ∅ because π (x) /∈ (cid:3)I1 ∩ (cid:3)I2 for all x ∈ var(q). Let us see how to construct (cid:8)p. Consider an atom B(t, tare initial and final states, respectively, of B. Because (cid:14)(cid:14)), and states s = s0, s1, . . . , sn = sI1 ∪ I2, π |= B(t, tof the automaton B such that for all i ∈ {1, . . . , n} the following conditions hold: (a) (si−1, νi, si) is a transition of B; I1∪I2 . Let (b) if νi = A?, then ai−1 = ai ∈ A0 = i0 < i1 < i2 < . . . ik < ik+1 = n be such that(cid:14)) of p and assume that s and s(cid:14)), there exist ν1, ν2, . . . , νn ∈ (cid:9), elements π (t) = a0, a1 . . . , an = π (tI1∪I2 ; (c) if νi = r, then (ai−1, ai) ∈ rsuch that for each atom B(t, tI1∪I2 ; (d) if νi = r, then (ai, ai−1) ∈ r−(cid:14)• ai ∈ (cid:3)I1 ∩ (cid:3)I2 for all i ∈ {i1, i2, . . . , ik}; and• ai /∈ (cid:3)I1 ∩ (cid:3)I2 for all i /∈ {0} ∪ {i1, i2, . . . , ik} ∪ {n}.We ensure the desired property of (cid:8)p by replacing B(t, t(cid:14)) with its subdivisionBs,si1(t, ai1 ) ∧ Bsi1 ,si2(ai1 , ai2 ) ∧ . . . ∧ Bsik,s(cid:14) (aik , t(cid:14)) .Indeed, for each j ∈ {0, 1, . . . , k}, {ai j +1, ai j +2, . . . , ai j+1−1} ⊆ (cid:3)I(cid:8) − ((cid:3)I1 ∩ (cid:3)I2 ) for some (cid:8) ∈ {1, 2}. Consequently, the con-ditions (a)–(d) above hold for all i ∈ {i j, i j + 1, . . . , i j+1 − 1} with I1 ∪ I2 replaced by I(cid:8), witnessing that the jth atom of the subdivision of B(t, t(cid:14)) holds in I(cid:8) under the match π .(3) Clearly, a (cid:3)-instantiation of a (cid:3)-instantiation of p is a (cid:3)-instantiation p. Similarly, a (cid:3)-subdivision of a (cid:3)-(cid:14)∪ Psubdivision of p is a (cid:3)-subdivision of p. Consequently, if P is a (cid:3)-split of p and Pis a (cid:3)-split of p; that is, (cid:14) ⊆ cl(p, (cid:3)) and the claim follows.(cid:9)(cid:14) ∈ P , then is a (cid:3)-split of pP − {pP − {p∪ P(cid:14)}(cid:14)}(cid:9)(cid:10)(cid:10)(cid:14)(4) It is not difficult to see that cl(p, (cid:3)) is contained in the set of queries that can be obtained from p by replacing each atom B(t1, t2) with one of the following, assuming that s1, s2 are the initial and final states, respectively, of B: (a) 2,s2 (d2, t2) for some d2 ∈ (cid:3) and some nothing; (b) itself; (c) Bs1,s(cid:14)(t1, d1) ∧ Bsstate s2,s2 (d2, t2) for 2 of B; (e) Bs(cid:14)2 of B. Consequently, each query q ∈ cl(p, (cid:3)) has at most 2n atoms and |cl(p, (cid:3))| ≤some d1, d2 ∈ (cid:3) and some states s(2 + 2 · |B| · |(cid:3)| + 2 · |B|2 · |(cid:3)|2)n ≤ (6 · m2 · |(cid:3)|2)n. (cid:2)(t1, d1) for some d1 ∈ (cid:3) and some state s(d1, d2) for some d1, d2 ∈ (cid:3) and some states s(cid:14)1 of B; (d) Bs(cid:14)2 of B; (f) Bs1,s(cid:14)1, s(cid:14)1, s(cid:14)1,s(cid:14)2(cid:14)1(cid:14)1(cid:14)(cid:14)Recall that the goal is to characterize when a C2RPQ q has no match into some tree-like interpretation represented by its tree decomposition, and that for this purpose we want to annotate the nodes in the tree decomposition with all relevant queries that ‘locally’ have a match, and ask for an annotation that avoids q. Here, a query is relevant if it is an element of a split of q. We next give a formal definition of annotations. Since we will need this not only for single C2RPQs but for unions (disjunctions) of C2RPQs, we directly do it for sets of C2RPQs.(cid:4)Definition 3. Let Q be a set of C2RPQs and let cl(Q , (cid:3)) =sition (T , I) is a mapping (cid:11) that assigns to each v ∈ T a set (cid:11)(v) ⊆ cl(Q , (cid:3)v ) such that, for each v ∈ T ,q∈Q cl(q, (cid:3)) for each set (cid:3). A Q -annotation of a tree decompo-(cid:2)(cid:3)p ∈ cl(Q , (cid:3)v ) | Iv |= p(A1)(A2) if some (cid:3)v -split of some p ∈ cl(Q , (cid:3)v ) is a subset of (cid:11)(v), then p ∈ (cid:11)(v);(A3) for each neighbour (child or parent) w of v,⊆ (cid:11)(v);(cid:11)(w) ∩ cl(Q , (cid:3)v ∩ (cid:3)w ) = (cid:11)(v) ∩ cl(Q , (cid:3)v ∩ (cid:3)w ) .Condition (A1) states that all queries satisfied in a bag Iv are contained in (cid:11)(v). Condition (A2) is responsible for piecing queries together from their splits, within (cid:11)(v). Finally, condition (A3) synchronizes neighbouring bags: intuitively, it says that if some relevant query has a match in a neighbouring bag w, then this fact should be known in bag v, and vice versa. In particular, it means that in a valid annotation all (cid:11)(v) agree on the set of Boolean queries.The main result of this section, Theorem 2 below, provides the announced characterization and will be the basis for developing tree automata that accept a tree decomposition iff the represented interpretation is a countermodel for all queries from Q .13V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808Theorem 2. Let Q be a set of C2RPQs without individual names and (T , I) a tree decomposition of some J . Then, J (cid:16)|=(T , I) admits a Q -annotation (cid:11) with Q ∩(cid:4)v∈T (cid:11)(v) = ∅.(cid:11)q∈Q q iff For the proof of the theorem, let us fix an interpretation J together with an arbitrary (not necessarily canonical) tree de-composition (T , I) thereof, and a set Q of C2RPQs. Because the mapping (cid:11)(v) = cl(Q , (cid:3)v ), for all v ∈ T , is a Q -annotation of (T , I) and pointwise intersection of an arbitrary family of Q -annotations of (T , I) is a Q -annotation of (T , I), there exists a unique pointwise minimal Q -annotation (cid:11)Q of (T , I). Intuitively, this minimal annotation (cid:11)Q assigns to every node v all queries from cl(Q , (cid:3)v ) which have a match in J .Lemma 6. For each v ∈ T and p ∈ cl(Q , (cid:3)v ),J |= p ⇐⇒ p ∈ (cid:11)Q (v) .Based on Lemma 6 and the fact that Q ⊆ cl(Q , (cid:3)), it is straightforward to prove the theorem. Suppose first that (T , I)v∈T (cid:11)Q (v) = ∅. q∈Q q. Conversely, suppose that admits a Q -annotation (cid:11) with Q ∩Thus, no query from Q is contained in (cid:11)Q (v), for any v ∈ T . Lemma 6 implies that J (cid:16)|=J (cid:16)|=v∈T (cid:11)(v) = ∅. Since (cid:11)Q is pointwise contained in (cid:11), it satisfies Q ∩q∈Q q. Lemma 6 yields q /∈ (cid:11)Q (v) for any q ∈ Q and v ∈ T , and thus, (cid:11)Q witnesses Q ∩v∈T (cid:11)Q (v) = ∅.(cid:4)(cid:11)(cid:11)(cid:4)(cid:4)We conclude the section with the missing proof of Lemma 6.Proof. Let us begin with the right-to-left implication. It is straightforward to see that (cid:11)Q can be obtained as the limit of the following process: for each v start with (cid:11)Q (v) =and then repeat the following steps ad infinitum:p ∈ cl(Q , (cid:3)v ) | Iv |= p(cid:3)(cid:2)• for each v, each neighbour w of v, and each p ∈ (cid:11)Q (w) ∩ cl(Q , (cid:3)v ∩ (cid:3)w ), add p to (cid:11)Q (v);• for each v and each p ∈ cl(Q , (cid:3)v ) that admits a (cid:3)v -split into queries from (cid:11)Q (v), add p to (cid:11)Q (v).By straightforward induction on the number of steps taken before p ∈ (cid:11)Q (v) is added to (cid:11)Q (v) one can show that J |= p, using Lemma 5 (1).For the converse, we only rely on (cid:11)Q being a Q -annotation, not on its minimality. A support for p in (T , I) is a Iu |= p. Because each match of p relies on a finite number of nodes and edges in J , connected set V ⊆ T such that it induces a finite support for p in (T , I). Hence, we can proceed by induction on the size of the support for p.The base case is that p ∈ cl(Q , (cid:3)v ) and Iu |= p for some u ∈ T . By (A1), p ∈ (cid:11)Q (u). Because bags containing any given u∈V(cid:4)set (cid:3) form a connected subtree in T , using (A3) we get that p ∈ (cid:11)Q (v).(cid:4)For the inductive step, take m > 1 and assume that the claim holds for all v and all queries in cl(Q , (cid:3)v ) admitting a support of size at most m − 1. Take any v ∈ T and p ∈ cl(Q , (cid:3)v ) with a support V of size m. We claim there exists a node v 1 ∈ V such that p ∈ cl(Q , (cid:3)v1 ). Let us assume that this is the case and see how to proceed from there. Because V is connected and contains at least two elements, some neighbour v 2 of v 1 belongs to V . Removing the edge between v 1 and v 2 induces a partition of V into two nonempty connected sets V 1 and V 2 such that v i ∈ V i and |V i| < m for i = 1, 2. Let Iu for i = 1, 2. Then I1 ∪ I2 |= p and Lemma 5 (2) yields a (cid:3)I1 ∩ (cid:3)I2 -split P 1 ∪ P 2 of p such that Ii |= P i for Ii =i = 1, 2. It follows that V i is a support for each query from P i for i = 1, 2. Consequently, each query from P 1 ∪ P 2 admits a support of size at most m − 1. Moreover, because (T , I) is a tree decomposition, (cid:3)I1 ∩ (cid:3)I2 ⊆ (cid:3)v1 , which means that P 1 ∪ P 2is a (cid:3)v1 -split of p. By Lemma 5 (3), it follows that P 1 ∪ P 2 ⊆ cl(Q , (cid:3)v1 ). By the induction hypothesis, P 1 ∪ P 2 ⊆ (cid:11)Q (v 1). By (A2), p ∈ (cid:11)Q (v 1). Like in the base case, it follows that p ∈ (cid:11)Q (v).u∈V iIt remains to prove the claim. Because V is a connected subset of the tree T , it is a tree too. Let v 1 be that node in Vfrom which the unique simple path to v is the shortest: either v itself, or the root of V , or one of its leaves. In order to show that p ∈ cl(Q , (cid:3)v1 ) it suffices to show that ind(p) ⊆ (cid:3)v1 . Let d ∈ ind(p). Then d ∈ (cid:3)v and also (cid:3)u for some u ∈ Vbecause each individual name used in p must occur in some node of each support of p. Because each connected set of nodes containing v and u must also contain v 1, we conclude that d ∈ (cid:3)v1 . This completes the proof of the claim and the whole lemma. (cid:2)5. Query entailment via automataWe shall now exploit the main results of the previous two sections in order to establish optimal complexity upper bounds. To describe the approach, let us fix an ABox A, an SQu TBox T in normal form, and a P2RPQ ϕ. By Theorem 1, ϕ is entailed over A relative to T iff there exists a (T , A)-canonical tree decomposition of width and degree at most (cid:22)A(cid:22) · 2poly((cid:22)T (cid:22)), representing an interpretation J such that J ∗ (cid:16)|= ϕ. We will follow an automata-based approach in the sense that we will effectively construct a non-deterministic tree automaton recognizing such tree decompositions, and thus reduce query entailment to the emptiness of these tree automata. More precisely, we will construct a tree automaton Athat takes as input tree decompositions of width and degree as specified above and verifies the following conditions:14V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 1038081. the tree decomposition in the input is (T , A)-canonical, and2. ϕ is not satisfied in the (transitive closure J ∗of the) interpretation J represented by the tree decomposition in the input.By Theorem 1, it is then the case thatA accepts some inputiffT , A (cid:16)|= ϕ,which provides the promised reduction of query entailment to the non-emptiness problem of the underlying automata model.We split the construction of A into two steps. First, in Lemma 7, we construct an automaton recognizing (T , A)-canonical tree decompositions; recall that, by Lemma 4, the transitive closures of the represented interpretations are models of T ∪ A. Then, in Lemma 8, we construct another automaton recognizing tree decompositions of interpretations whose transitive closures do not satisfy ϕ. In the construction of the latter automaton, we rely on the characterization of query matches in tree decompositions established in Theorem 2: essentially, the automaton will just guess the Q -annotation in its states. Finally, we take the product of the two automata to obtain the automaton A satisfying items 1 and 2 above. In order to obtain optimal bounds we have to ensure that the involved automata are of the right size and that they can be constructed in the required time. We analyze this general algorithm in terms of combined complexity in Theorem 3 and in terms of data complexity in Theorem 4 below.While the described approach is relatively simple, the development below is complicated by a certain mismatch between the capabilities of tree automata and the nature of tree decompositions. On the one hand, the input alphabet (that is, the set of allowed node labels) of a tree automaton has to be finite. On the other hand, in any bounded-width tree decomposition of an infinite interpretation, there will be infinitely many different node labels since the tree decomposition has to encompass the whole domain of the interpretation. Hence, tree automata cannot run directly on tree decompositions. This is a recurring problem when working with tree automata that process tree decompositions and the standard solution to this problem, used for instance in [22], is to encode tree decompositions by reusing elements according to a certain policy, described below.We first introduce the necessary notions for tree automata. A k-ary (cid:9)-labelled tree is a pair (T , τ ) where T is a tree each of whose nodes has at most k successors and τ : T → (cid:9) assigns a letter from the alphabet (cid:9) to each node. A non-deterministic tree automaton (NTA) over k-ary trees is a tuple A = (Q , (cid:9), I, (cid:13)), where Q is a finite set of states, (cid:9) is a finite alphabet, I ⊆ Q is the set of initial states, and (cid:13) ⊆i≤k(Q × (cid:9) × Q i) is a set of transitions. A run r on a k-ary (cid:9)-labelledtree (T , τ ) is a Q -labelled tree (T , r) such that r(ε) ∈ I and, for every x ∈ T with successors x1, . . . , xm, there is a transition (r(x), τ (x), r(x1), . . . , r(xm)) ∈ (cid:13). We say that A recognizes the set of all (cid:9)-labelled trees that admit a run. This corresponds to the weak parity condition where all states have rank 0. For such automata language intersection can be implemented simply by using the product construction and emptiness can be tested in polynomial time [20].(cid:4)We next describe the announced encoding of tree decompositions of bounded width using a finite alphabet. Intuitively, two different elements in the tree decomposition can be represented by the same element in the encoding if they never occur in the same bag nor in two neighbouring bags. Then, if some element is used in two different nodes u and v of the encoding, then it represents the same actual element in both nodes iff it is present in all nodes on the unique shortest path between u and v.To formalize this intuition, let N ≥ |ind(A)| be a bound on the bag size. We shall use a fixed domain (cid:3)N such that |(cid:3)N | = 2N + 2 and ind(A) ⊆ (cid:3)N . Let (cid:4)C, (cid:4)tR, (cid:4)ntR be the sets of concept names, transitive role names, and non-transitive R . The automaton’s alphabet will be the set (cid:9)N of all pairs ((cid:4), J )role names used in T and A, and let (cid:4)R = (cid:4)t∪ (cid:4)ntRsuch that (cid:4) ⊆ (cid:4)C ∪ (cid:4)R and J is a (cid:4)-interpretation with (cid:3)J ⊆ (cid:3)N . Note that such J can be finitely represented and that |(cid:9)N | ≤ 2poly(N,(cid:22)T (cid:22)). Let (T , τ ) be an (cid:9)N -labelled tree. We use (cid:4)v and Jv to refer to the two components of the label τ (v), that is, τ (v) = ((cid:4)v , Jv ). Given an element d ∈ (cid:3)N , we say that v, w ∈ T are d-connected iff d ∈ (cid:3)Ju for all u on the unique shortest path from v to w. In case d ∈ (cid:3)Jv , we use [v]d to denote the set of all w which are d-connected to v. We call (T , τ ) A-consistent if ind(A) ⊆ (cid:3)Jε . An A-consistent (cid:9)N -labelled tree (T , τ ) represents the tree decomposition (T , I)where I assigns to each node v ∈ T a (cid:4)v -interpretation Iv with(cid:6)(d, [v]d) | d ∈ (cid:3)Jv(d, [v]d) | d ∈ AJv(cid:6),,(cid:5)(cid:3)v =Iv =AIv =r(cid:5)(cid:5)((d, [v]d) , (e, [v]e)) | (d, e) ∈ r(cid:6),Jvfor all concept names A and role names r occurring in T and A; let I(T ,τ ) =Iw be the underlying interpretation. Modulo a harmless bijection we can assume that a = (a, [ε]a) for all a ∈ ind(A). Note that [ε]a is well-defined due to A-consistency. Conversely, given an interpretation I and a tree decomposition (T , I) of I of width and degree at most N, one can construct an A-consistent (cid:9)N -labelled tree (T , τ ) such that I(T ,τ ) is isomorphic to I [22]. As encoding and decoding preserves the degree, it suffices to consider N-ary trees throughout.w∈T(cid:4)15V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808Lemma 7. Given A, T , and N ≥ |ind(A)|, one can compute a nondeterministic tree automaton recognizing the set of encodings of (T , A)-canonical tree decompositions of width and degree at most N, in time O(cid:9)2poly(N,(cid:22)T (cid:22))(cid:10).Proof. Verifying that the input tree is an encoding of a (T , A)-canonical tree decomposition is not difficult. Condition (D1) is always satisfied for some I. Condition (D2) is guaranteed by the way we encode and decode tree decompositions. The remaining condition (D3), as well as the conditions of (T , A)-canonicity (Definition 1), can be checked by looking at the labels of each node and its neighbours. We implement this by storing the label of the parent, guessing the labels of children, checking that they satisfy all necessary conditions, and then verifying that we have guessed correctly. That is, the set of states is (cid:9)N × (cid:9)N . For the set of initial states we take(cid:12)(cid:9)(cid:10)((cid:4), J0), ((cid:4)C ∪ (cid:4)R, J )∈ (cid:9)N × (cid:9)N(cid:13)(cid:13)(cid:13)(cid:13) J |= A , (cid:3)J0 ∩ (cid:3)J = ∅(cid:14);the interpretation J0 with (cid:3)J0 ∩ (cid:3)J = ∅ will emulate the behaviour of the interpretation with the empty domain, which is appropriate for the non-existent parent of the root; the condition J |= A ensures (C1). Transitions are of the form(cid:9)(cid:10)(ω0, ω), ω, (ω, ω1), . . . , (ω, ωk)∈ ((cid:9)N )2 × (cid:9)N × ((cid:9)N )2 × · · · × ((cid:9)N )2(cid:18)(cid:15)(cid:16)(cid:17)k,where k ≤ N, ω is the label of the current node, ω0 is the stored label of the parent, and ω1, ω2, . . . , ωk are the guessed labels of the children. The transition above is present only if(cid:19)(cid:20)(ω0, ω, ω1, . . . , ωk) =(cid:4)0, J0,(cid:4), J,(cid:4)C ∪ {r1}, J1, . . . ,(cid:4)C ∪ {rk}, Jk(cid:9)(cid:10)(cid:9)(cid:10)(cid:9)(cid:10)(cid:9)(cid:10)for some r1, r2, . . . , rk ∈ (cid:4)R such that(cid:14)(D3) for each i ∈ {1, 2, . . . , k}, the restrictions of J and Ji to signature (cid:4) ∩ (cid:4)i and domain (cid:3)J ∩ (cid:3)Ji coincide;2) J satisfies all CIs in T of the forms (cid:5)i Ai (cid:3) (cid:10) j B j and A (cid:3) ((cid:2) n r B) with r ∈ (cid:4)tR;(cid:14)3) for each concept inclusion A (cid:3) ((cid:2) n r B) in T with r ∈ (cid:4)ntIv − (cid:3)J0 in J (cid:14) = J ∪R and each d ∈ A(cid:4)ki=1(cid:14)Ji the element d has at most n r-successors in BJ (cid:14);(cid:14)4) for each concept inclusion A (cid:3) ((cid:3) n r B) in T and each d ∈ AIv − (cid:3)J0 there exists i ∈ {1, 2, . . . , k} such that in J ∪ Jithe element d has at least n r-successors in BJ ∪Ji ;(cid:14)5) for each i ∈ {1, 2, . . . , k} there exists d ∈ (cid:3)J − (cid:3)J0 such that either ri ∈ (cid:4)ntJ∩ (cid:4) and (cid:3)J ∩ (cid:3)Ji = relri (d) = relri ∈ (cid:4)tRJiri (d).R∪ ((cid:4)tR− (cid:4)) and (cid:3)J ∩ (cid:3)Ji = {d} or (C(C(C(CNote that the above conditions are simply translations of conditions (D3) and (C2)–(C5) from the level of tree decompo-sitions to the level of their encodings.It remains to argue that the automaton can be constructed within the claimed time. Note first that |(cid:9)N | ≤ 2poly(N,(cid:22)T (cid:22))and the elements of (cid:9)N can be enumerated in time 2poly(N,(cid:22)T (cid:22)). Hence, the alphabet and the set of states the automaton can be computed in time 2poly(N,(cid:22)T (cid:22)). Conditions (D(cid:14)(cid:14)(cid:14)5) above can be tested in polynomial time in the total 3) and (C2)–(Csize of the representation of ω0, ω, ω1, ω2, . . . ωk and T . Consequently, the transition relation can be computed in time 2poly(N,(cid:22)T (cid:22)) by iterating over all possible choices of ω0, ω, ω1, ω2, . . . ωk and filtering out the ones that violate either of these conditions. Similarly, the conditions defining the set of initial states can be verified in time polynomial in the size of the representation of the state and A. Because |ind(A)| ≤ N, it follows that the set of initial states can be computed in time 2poly(N,(cid:22)T (cid:22)). Thus, the whole automaton can be constructed in time 2poly(N,(cid:22)T (cid:22)). (cid:2)(cid:22)ϕ(cid:22),(cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)) a non-Lemma 8. Given a P2RPQ ϕ without individual names and a positive integer N, one can compute in time 2poly((cid:22)T (cid:22),Ndeterministic tree automaton recognizing the set of encodings of tree decompositions of width and degree at most N of interpretations J such that J ∗ (cid:16)|= ϕ.Proof. In order to be able to evaluate ϕ directly over J , rather than over J ∗− ◦ (reach occurrence of r in ϕ with r ◦ rwithout affecting the semantics of ϕ over J ∗, and each occurrence of rwith r−∗., for each transitive role name r, we replace . This ensures that J ∗ |= ϕ iff J |= ϕ, −)∗−The next step is to move to the NFA-based representation. Path expressions in ϕ are regular expressions over the alphabet comprising all r, r, and A? used in ϕ. It is well-known that every regular expression can be converted in polynomial time to an equivalent NFA with linearly many states [23]. Without loss of generality, one can assume that the automaton has (cid:14)) where B is an NFA equivalent to only one initial and one final state. Hence, we can replace each atom E(t, tE (viewed as a regular expression).(cid:14)) with B(t, t16V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808Finally, it is well-known that ϕ can be rewritten (in exponential time) as a disjunction of at most (cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)C2RPQs of size at most (cid:22)ϕ(cid:22). Let q1 ∨ q2 ∨ · · · ∨ q(cid:8) be such an equivalent formulation of ϕ and let Q = {q1, q2, . . . , q(cid:8)}. By Theorem 2, if (T , I) is a tree decomposition of some J then J (cid:16)|= ϕ iff(cid:7)(T , I) admits a Q -annotation (cid:11) such that Q ∩(cid:11)(v) = ∅.(7)v∈TThus, it suffices to construct an automaton recognizing encodings of tree decompositions (T , I) satisfying (7).Intuitively, the automaton will guess a Q -annotation of the encoded tree decomposition and verify that it avoids Q as required in (7). Recall that all bags of the tree decomposition are encoded using elements from a fixed finite domain (cid:3)N : the elements of (cid:3)N are reused to represent different elements in different bags, the rule being that d ∈ (cid:3)N represents the same element in two bags iff d is present in each bag on the unique simple path between these bags. Consequently, it suffices to consider (cid:3)N -splits of queries from Q . Because these queries use no individual names, their (cid:3)N -splits use only individual names from (cid:3)N . In order to check correctness of the guessed annotation, the automaton needs access to the domains of children of the current node: we let the automaton guess them and verify them later on. Thus, the states of the automaton are pairs ((cid:3), (cid:11)) such that (cid:3) ⊆ (cid:3)N and (cid:11) ⊆ cl(Q , (cid:3)) − Q ; all states are initial and final. Transitions are of the form(cid:9)(cid:10)((cid:3)0, (cid:11)0), ((cid:4), J ), ((cid:3)1, (cid:11)1), ((cid:3)2, (cid:11)2), . . . , ((cid:3)k, (cid:11)k),where (cid:3)0 = (cid:3)J(cid:2), (cid:11)0 ⊆ cl(Q , (cid:3)0) and(cid:3)p ∈ cl(Q , (cid:3)0) | J |= p(cid:14)1)(A(cid:14)2) if some (cid:3)0-split of some p ∈ cl(Q , (cid:3)0) is a subset of (cid:11)0, then p ∈ (cid:11)0;(A(cid:14)3) for each i ∈ {1, 2, . . . , k},(A⊆ (cid:11)0;(cid:11)0 ∩ cl(Q , (cid:3)0 ∩ (cid:3)i) = (cid:11)i ∩ cl(Q , (cid:3)0 ∩ (cid:3)i) .From each run over the input tree (T , τ ) we can extract a Q -annotation of the encoded tree decomposition (T , I): in each node v ∈ T we take the second component (cid:11)0 ⊆ cl(Q , (cid:3)0) of the corresponding state ((cid:3)0, (cid:11)0) and replace constants (cid:14)(cid:14)(cid:14)from (cid:3)0 ⊆ (cid:3)N by the corresponding constants from (cid:3)v . Conditions (A3) above are direct translations of (A1), 2), (A1), (A(A2), (A3) to the encodings. Because neighbouring bags agree over the encoding of shared elements, it is easy to see that the extracted labelling of T is a correct Q -annotation of (T , I). Similarly, we can show that each Q -annotation of a tree decomposition (T , I) can be turned into an accepting run over each encoding of (T , I).Recall that we have |(cid:9)N | ≤ 2poly(N,(cid:22)T (cid:22)) and that queries in Q have size at most (cid:22)ϕ(cid:22), the automata used to represent path expressions in these queries have at most m = O ((cid:22)ϕ(cid:22)) states, and |Q | ≤ (cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22). Using Lemma 5 (4), we get|cl(Q , (cid:3)N )| ≤ |Q | ·(cid:9)6 · m2 · (2N)2(cid:10)(cid:22)ϕ(cid:22) ≤ poly(cid:9)(cid:22)ϕ(cid:22), (cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)N(cid:10).Consequently, the number of states in the constructed tree automaton is bounded by(cid:10)(cid:9)|(cid:3)N | · 2|cl(Q ,(cid:3)N )| ≤ 2poly2(cid:22)ϕ(cid:22),(cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)Nand the number of transitions is bounded by(cid:22)|(cid:9)N | ·N(cid:21)k=0|(cid:3)N | · 22|cl(Q ,(cid:3)N )|(cid:23)k+1(cid:9)≤ 2poly(cid:22)T (cid:22),N(cid:22)ϕ(cid:22),(cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)(cid:10),where k stands for the possible numbers of children of the current node. Condition (Apoly(|cl(Q , (cid:3)N )|, N(cid:22)ϕ(cid:22), (cid:22)T (cid:22)) because(cid:14)1) can be tested in time cl(Q , (cid:3)0) ⊆ cl(Q , (cid:3)N ) ,(cid:14)(cid:14)the size of the domain of J is linear in N, and the size of queries in cl(Q , (cid:3)0) is linear in (cid:22)ϕ(cid:22). Conditions (A3) 2) and (Acan be tested in time polynomial in the total size of the representations of the objects they mention. It follows that the (cid:22)ϕ(cid:22),(cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)). (cid:2)whole automaton can be constructed in time 2poly((cid:22)T (cid:22),NThe main results are now obtained by putting the pieces together. We begin with a simple argument establishing the combined complexity.Theorem 3. Entailment of P2RPQs relative to SQu TBoxes is 2ExpTime-complete.17V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808Proof. Let A, T , and ϕ be the input ABox, SQu TBox, and P2RPQ. As explained in Section 2.3, we can assume that T is in normal form and ϕ contains no individual names. Let N ≤ (cid:22)A(cid:22) · 2poly((cid:22)T (cid:22)) be a constant bounding the width and degree of tree decompositions, as guaranteed by Theorem 1; it can be easily computed from T and A. We will say that a tree de-composition is N-bounded if its width and degree is at most N. By Lemma 7, we can construct in time O (2poly(N,(cid:22)T (cid:22)))an automaton AT , A recognizing (T , A)-canonical N-bounded tree decompositions. By Lemma 8, we can construct in (cid:22)ϕ(cid:22),(cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)) an automaton A¬ϕ recognizing N-bounded tree decomposition of interpretations whose transi-time 2poly((cid:22)T (cid:22),Ntive closures falsify ϕ. The product A of these automata recognizes (T , A)-canonical N-bounded tree decompositions of interpretations whose transitive closures falsify ϕ. From Theorem 1 it follows that T , A |= ϕ iff A does not accept anything. We construct the product automaton and test its emptiness in time polynomial in the size of AT , A and A¬ϕ . Overall, this gives a decision procedure whose combined complexity is doubly exponential. The matching lower bound is inherited from positive existential query answering in the sublogic ALC [19]. (cid:2)The algorithm described in the proof of Theorem 3 explicitly constructs automata that are exponential in the size of the ABox. In order to establish a tight upper bound for data complexity, we will show that one can avoid constructing the whole automaton; the combined complexity of the resulting algorithm will be still doubly exponential.Theorem 4. Entailment of P2RPQs relative to SQu TBoxes is coNP-complete in terms of data complexity.Proof. As the lower bound carries over from the entailment of instance queries in ALC [18], we only need to prove the upper bound. Consider an ABox A, an SQu TBox T in normal form, and a P2RPQ ϕ without individual names. We shall rely on the additional claim of Theorem 1. Let M ≤ 2poly((cid:22)T (cid:22)) be a constant bounding the size and the degree of non-root bags, as in Theorem 1, and let it be large enough to ensure that the size and the degree of the root bag is at most N = (cid:22)A(cid:22) · M. Again, M is computable from T and A. We shall reuse the automata AT , A and A¬ϕ constructed in Lemmas 7 and 8. The idea is that we universally guess initial levels of the input tree and the corresponding fragment of a run of the product automaton of AT , A and A¬ϕ and then check that it cannot be completed to a tree accepted by the product automaton. The latter check will only explore limited fragments of the product automaton, computable in time independent of A. Notice that in each child of the root the bag size and the degree is already independent of A, but the state still stores full information about the root bag; this information is only forgotten when the next transition is taken. This is why we guess three initial levels, not just two.v , I(cid:14)((cid:4)(cid:14)⊆ (cid:3)N for some (cid:4)(cid:14)of the product automaton, where I(cid:14)We begin by guessing a tree of depth 2 in which the root has at most (cid:22)A(cid:22) · M children, and each of those has at most M children. For each guessed node v, we guess a label ((cid:4)v , Iv ) such that (cid:4)v ⊆ (cid:4)C ∪ (cid:4)R and Iv is a (cid:4)v -interpretation with domain (cid:3)v ⊆ (cid:3)N . Moreover, |(cid:3)v | ≤ M for all nodes v except the root. For each guessed node v we also guess (cid:10)(cid:10)v ), ((cid:4)v , Iv )v -interpretation with the corresponding state , ((cid:3)v , (cid:11)v )domain (cid:3)(cid:14)⊆ (cid:4)C ∪ (cid:4)R, and (cid:11)v ⊆ cl((cid:3)v , Q ) with Q the set of C2RPQs obtained by rewriting the input (cid:9)(cid:10)v|(cid:3)v |(cid:22)ϕ(cid:22), (cid:22)ϕ(cid:22)(cid:22)ϕ(cid:22)query ϕ as a disjunction of C2RPQs. As we have seen in the proof of Lemma 8, |(cid:11)v | ≤ |cl((cid:3)v , Q )| ≤ polyand each query from (cid:11)v ⊆ cl((cid:3)v , Q ) has size O ((cid:22)ϕ(cid:22)). Moreover, (cid:22)Iv (cid:22), (cid:22)I(cid:14)(cid:22) ≤ poly(N, (cid:22)T (cid:22)). Because we consider T and ϕfixed, it follows that we can store the guessed fragment of the input tree and the corresponding run in space polynomial in (cid:22)A(cid:22). As we have seen in the proofs of Lemmas 7 and 8, we can also check in polynomial time that the state in the root is initial and that the transition relation is respected. It remains to check that the guessed fragments of the input tree and the corresponding run cannot be extended to a full tree and a full accepting run. This is equivalent to checking that for some grandchild v of the root, the product automaton does not accept anything from the state guessed for v. We claim that this test can be performed in time independent of (cid:22)A(cid:22) for each grandchild v of the root. As the number of such nodes v is polynomial in (cid:22)A(cid:22), this gives a coNP decision procedure (in terms of data complexity).v is a (cid:4)(cid:14)(cid:9)(cid:9)vvTo see why the claim holds, let us fix a grandchild v of the root. Recall that we only need to consider tree decompositions with the size of non-root bags bounded by M. Whether the automaton accepts depends only on the tree decomposition, not on the encoding. Consequently, we can assume that all bags in the subtree rooted at v are encoded using a fixed domain M such that (cid:3)v ⊆ (cid:3)vT , A and Av(cid:3)v¬ϕ be the automata defined just like AT , A and A¬ϕ , (cid:10)v , I(cid:14)((cid:4)(cid:14)v ), ((cid:4)v , Iv )but with (cid:3)N replaced by (cid:3)vand ((cid:3)v , (cid:11)v ), respectively. These automata (cid:9)v , I(cid:14)((cid:4)(cid:14)do not depend on A any more: apart from T and ϕ, they depend only on and ((cid:3)v , (cid:11)v ). Because (cid:22) ≤ poly(M, (cid:22)T (cid:22)), the product automaton of Av|(cid:3)v | ≤ |(cid:3)vT , A and Av¬ϕ can be computed and tested Mfor emptiness in time constant with respect to (cid:22)A(cid:22). (cid:2)M , and the initial states set to | ≤ M and (cid:22)Iv (cid:22), (cid:22)I(cid:14)(cid:10)v ), ((cid:4)v , Iv )⊆ (cid:3)N and |(cid:3)vM| ≤ 2M. Let AvM(cid:9)v6. Related workWe begin with related work on fragments of FO with counting and transitivity. Then we move to description logics with counting and transitivity. Finally, we discuss existing work on answering navigational queries, such as regular path queries or extensions thereof, mediated by description logic ontologies.18V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 1038086.1. Related work on fragments of FO with counting and transitivityIn general, extending expressive decidable fragments of FO with counting and transitivity has turned out to be chal-lenging because their combination easily leads to undecidability. There has been some work on the extension of decidable first-order logic fragments, such as the guarded fragment, with transitivity and counting, see e.g., [24,25]. However, to en-sure decidability of the satisfiability problem the interaction of counting and transitivity is severely restricted [24]. In the context of existential rules, several efforts have been recently made to design languages with decidable QA supporting tran-sitivity [26–28]. However, extending decidable existential rules languages with counting (even without transitive relations) easily leads to undecidability [29]. Similarly, extending the unary negation fragment of FO with counting leads to undecid-ability [30,31]. In this sense our positive results are an important step to close the distance to the undecidability frontier. In fact, besides extensions based on SQu , we are not aware of more expressive decidable logics supporting counting and transitivity.6.2. Related work on DLs with number restrictions on transitive rolesThe initial investigations on SQu and extensions thereof concentrated on the limits of decidability of the satisfiabil-ity problem. Decision procedures for satisfiability in SQu and its extension SOQu with nominals were provided in [32]and [33], respectively; in both cases, the procedure gives a non-elementary upper bound. Shortly thereafter, concept satisfi-ability in SQu restricted to a single transitive role name was shown to be NExpTime-complete [34]; in fact, the result was shown for graded modal logics over transitive frames, which is a notational variant. The techniques for proving the NExpTime-upper bound were then adapted to prove also tight complexity bounds for the more general problem of TBox satisfiability (global consequence, in modal logic parlance) in the presence of an arbitrary number of transitive and non-transitive roles, and even in the presence of nominals: both for SQu and SOQu , TBox satisfiability is NExpTime-complete [35]. Further, it was shown that even modest extensions of SQu such as with role inclusions or inverse roles result in logics with an undecidable TBox satisfiability problem [32], which implies that query answering is undecidable as well. In fact, already supporting number restrictions on transitive roles in the lightweight DL-Lite[36] leads to undecidability [35]. Remark-ably, it has been observed that sometimes decidability of TBox satisfiability can be regained by disallowing the application of at-most restrictions to inverse transitive roles (but still allowing the application of at-least restrictions) [37,38].Recall that SQu does not enjoy the tree model property, which has ramifications here as well. Indeed, it has been shown that when transitive roles are interpreted as the transitive closure of the successor relation induced by a tree, satisfiability in SQu is decidable in NExpTime even if role inclusions are allowed [39]. This is in marked contrast with the mentioned undecidability result for SQu with role inclusions [32].HNcore6.3. Related approaches to navigational queriesPossibly closest to our approach is [8], where an automata-based approach consisting of Steps 1–3 described in Sec-tion 1.1 is followed, too. There, the query automaton A¬ϕ is obtained from an initial automaton via a projection and a subsequent complementation operation. This approach to constructing A¬ϕ is applicable here as well, but does not lead to optimal complexity, due to the higher treewidth. In [14], a query rewriting approach is followed. While this is in prin-ciple orthogonal to ours, it faces the same challenge, non-locality of path queries, and thus still needs a form of query decompositions or splits. Sometimes, the query can also be rewritten or incorporated into the ontology. For example, if the considered DL allows for the regular role inclusion constructor, usually abbreviated with R, then entailment of regular path queries can be reduced to entailment of conjunctive queries [13,40]. Finally, a query decomposition which is in spirit close to ours was recently developed for the extension of the unary negation fragment of first-order logic [31] with regular path expressions [16]; this extension captures answering (unions of) C2RPQs mediated by S ontologies, where S denotes the extension of ALC with transitive roles.A certain form of non-locality is also present in conjunctive queries with transitive atoms. Such queries are usually considered in ontology-mediated query answering when the ontology language subsumes S. It is known that in some cases entailment of CQs with transitive relations is indeed more complex than without. For instance, entailment of CQs with transitive atoms relative to SHQ ontologies is 2ExpTime-complete [6,7], while it is ExpTime-complete [41] without transitive atoms. In fact, this increase in complexity is already witnessed in S itself, for which entailment of CQs with transitive atoms is coNExpTime-hard [7].7. ConclusionsWe have studied the problem of answering positive two-way regular path queries (P2RPQs) relative to SQu , that is, unrestricted SQ, ontologies. Our main results are decidability and tight complexity bounds, both in data complexity and in combined complexity.These results are both of practical and theoretical interest. From a practical point of view, our complexity results meet the application demands and open up the possibility to include a profile based on SQu to OWL 2. Note that there is no increase in the computational complexity in comparison with that of SQ without counting over transitive roles. From a theoretical 19V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808perspective, some of the techniques we introduced here are of broader interest. Specifically, the annotations and the query automaton are developed independently of the ontology and can be applied for any ontology language enjoying the tree-like countermodel property. For instance, we recently generalized the tree-like countermodel property to the extensions of SQuwith nominals (SOQu ) and with controlled inverses (SIQ(cid:4)u ), where at-most restrictions are only applicable to role names, but not to inverses [38]. For these logics, recognizing tree-like models of T and A requires a different automaton AT , A, but the automaton A¬ϕ constructed in Section 5 can be reused, yielding the same complexity upper bounds.There are various directions of future work. With respect to the query language, we believe that our techniques can be lifted to nested P2RPQs, which extend P2RPQs with a form of tests. The feature of nesting has been introduced to navigational queries in the context of SPARQL [42], but has also been studied in the ontology-mediated setting to some extent [43,44]. It would also be interesting to look at more restricted query languages. For example, for CQs there is a gap in combined complexity between our 2ExpTime upper bound and the best known lower bound, which is coNExpTime and holds already for S ontologies [7].Declaration of competing interestThe authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.Data availabilityNo data was used for the research described in the article.AcknowledgementsFilip Murlak was supported by the NCN grant 2018/30/E/ST6/00042.References[1] M. Benedikt, B.C. Grau, E.V. Kostylev, Logical foundations of information disclosure in ontology-based data integration, Artif. Intell. 262 (2018) 52–95.[2] G. Xiao, D. Calvanese, R. Kontchakov, D. Lembo, A. Poggi, R. Rosati, M. Zakharyaschev, Ontology-based data access: A survey, in: J. Lang (Ed.), Proceedings of the 27th International Joint Conference on Artificial Intelligence (IJCAI), ijcai.org, 2018, pp. 5511–5519.[3] F. Baader, I. Horrocks, C. Lutz, U. Sattler, An Introduction to Description Logic, Cambridge University Press, 2017.[4] W3C OWL Working Group, OWL 2 Web Ontology Language, Available at http://www.w3 .org /TR /owl2 -overview/, 2009.[5] B. Glimm, I. Horrocks, U. Sattler, Unions of conjunctive queries in SHOQ, in: G. Brewka, J. Lang (Eds.), Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR), AAAI Press, 2008, pp. 252–262.[6] B. Glimm, C. Lutz, I. Horrocks, U. Sattler, Conjunctive query answering for the description logic SHIQ, J. Artif. Intell. Res. 31 (2008) 157–204.[7] T. Eiter, C. Lutz, M. Ortiz, M. Simkus, Query answering in description logics with transitive roles, in: C. Boutilier (Ed.), Proceedings of the 21st Interna-tional Joint Conference on Artificial Intelligence (IJCAI), 2009, pp. 759–764.[8] D. Calvanese, T. Eiter, M. Ortiz, Answering regular path queries in expressive description logics via alternating tree-automata, Inf. Comput. 237 (2014) 12–55.[9] W3C, OWL Web Ontology Language: Use Cases and Requirements, Available at https://www.w3 .org /TR /webont -req/, 2004.[10] A.K. Chandra, P.M. Merlin, Optimal implementation of conjunctive queries in relational data bases, in: J.E. Hopcroft, E.P. Friedman, M.A. Harrison (Eds.), Proceedings of the 9th Annual ACM Symposium on Theory of Computing (STOC), ACM, 1977, pp. 77–90.[11] P. Barceló, Querying graph databases, in: R. Hull, W. Fan (Eds.), Proceedings of the 32nd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS), ACM, 2013, pp. 175–188.[12] D. Calvanese, G.D. Giacomo, M. Lenzerini, M.Y. Vardi, Containment of conjunctive regular path queries with inverse, in: A.G. Cohn, F. Giunchiglia, B. Selman (Eds.), Proceedings of the 7th International Conference on Principles of Knowledge Representation and Reasoning(KR), Morgan Kaufmann, 2000, pp. 176–185.[13] G. Stefanoni, B. Motik, M. Krötzsch, S. Rudolph, The complexity of answering conjunctive and navigational queries over OWL 2 EL knowledge bases, J. Artif. Intell. Res. 51 (2014) 645–705.[14] M. Bienvenu, M. Ortiz, M. Simkus, Regular path queries in lightweight description logics: Complexity and algorithms, J. Artif. Intell. Res. 53 (2015) 315–374.[15] J. Baget, M. Bienvenu, M. Mugnier, M. Thomazo, Answering conjunctive regular path queries over guarded existential rules, in: C. Sierra (Ed.), Proceed-ings of the 26th International Joint Conference on Artificial Intelligence (IJCAI), ijcai.org, 2017, pp. 793–799.[16] J.C. Jung, C. Lutz, M. Martel, T. Schneider, Querying the unary negation fragment with regular path expressions, in: B. Kimelfeld, Y. Amsterdamer (Eds.), Proceedings of the 21st International Conference on Database Theory (ICDT), in: LIPIcs, vol. 98, Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2018, pp. 15:1–15:18.[17] M.Y. Vardi, The complexity of relational query languages (extended abstract), in: H.R. Lewis, B.B. Simons, W.A. Burkhard, L.H. Landweber (Eds.), Pro-ceedings of the 14th Annual ACM Symposium on Theory of Computing (STOC), ACM, 1982, pp. 137–146.[18] A. Schaerf, On the complexity of the instance checking problem in concept languages with existential quantification, J. Intell. Inf. Syst. 2 (3) (1993) 265–278.[19] M. Ortiz, M. Simkus, Revisiting the hardness of query answering in expressive description logics, in: R. Kontchakov, M. Mugnier (Eds.), Proceedings of the 8th International Conference on Web Reasoning and Rule Systems (RR), in: Lecture Notes in Computer Science, vol. 8741, Springer, 2014, pp. 216–223.[20] J. Neumann, A. Szepietowski, I. Walukiewicz, Complexity of weak acceptance conditions in tree automata, Inf. Process. Lett. 84 (4) (2002) 181–187.[21] S. Tessaris, Questions and answers: reasoning and querying in description logic, Ph.D. thesis, University of Manchester, 2001.[22] E. Grädel, I. Walukiewicz, Guarded fixed point logic, in: Proceedings of the 14th Annual IEEE Symposium on Logic in Computer Science (LICS), IEEE Computer Society, 1999, pp. 45–54.20V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung et al.Artificial Intelligence 314 (2023) 103808[23] M. Fürer, The complexity of the inequivalence problem for regular expressions with intersection, in: J.W. de Bakker, J. van Leeuwen (Eds.), Proceedings of the 7th Colloquium on Automata, Languages and Programming (ICALP), in: Lecture Notes in Computer Science, vol. 85, Springer, 1980, pp. 234–245.[24] L. Tendera, Counting in the two variable guarded logic with transitivity, in: V. Diekert, B. Durand (Eds.), Proceedings of the 22nd Annual Symposium on Theoretical Aspects of Computer Science (STACS), in: Lecture Notes in Computer Science, vol. 3404, Springer, 2005, pp. 83–96.[25] I. Pratt-Hartmann, The two-variable fragment with counting and equivalence, Math. Log. Q. 61 (6) (2015) 474–515.[26] G. Gottlob, A. Pieris, L. Tendera, Querying the guarded fragment with transitivity, in: F.V. Fomin, R. Freivalds, M.Z. Kwiatkowska, D. Peleg (Eds.), Proceedings of the 40th International Colloquium on Automata, Languages, and Programming (ICALP), in: Lecture Notes in Computer Science, vol. 7966, Springer, 2013, pp. 287–298.[27] J. Baget, M. Bienvenu, M. Mugnier, S. Rocher, Combining existential rules and transitivity: Next steps, in: Q. Yang, M.J. Wooldridge (Eds.), Proceedings of the 24th International Joint Conference on Artificial Intelligence (IJCAI), AAAI Press, 2015, pp. 2720–2726.[28] A. Amarilli, M. Benedikt, P. Bourhis, M. Vanden Boom, Query answering with transitive and linear-ordered data, J. Artif. Intell. Res. 63 (2018) 191–264.[29] A. Calì, D. Lembo, R. Rosati, On the decidability and complexity of query answering over inconsistent and incomplete databases, in: F. Neven, C. Beeri, T. Milo (Eds.), Proceedings of the 22nd ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), ACM, 2003, pp. 260–271.[30] D. Danielski, E. Kieronski, Finite satisfiability of unary negation fragment with transitivity, in: P. Rossmanith, P. Heggernes, J. Katoen (Eds.), Proceedings of the 44th International Symposium on Mathematical Foundations of Computer Science (MFCS), in: LIPIcs, vol. 138, Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2019, pp. 17:1–17:15.[31] L. Segoufin, B. ten Cate, Unary negation, Log. Methods Comput. Sci. 9 (3) (2013).[32] Y. Kazakov, U. Sattler, E. Zolin, How many legs do I have? non-simple roles in number restrictions revisited, in: N. Dershowitz, A. Voronkov (Eds.), Proceedings of 14th International Conference on Logic for Programming, AI, and Reasoning (LPAR), in: Lecture Notes in Computer Science, vol. 4790, Springer, 2007, pp. 303–317.[33] M. Kaminski, G. Smolka, Terminating tableaux for SOQ with number restrictions on transitive roles, in: Proceedings of 6th International Conference on Theoretical Computer Science (IFIP TCS), in: IFIP Advances in Information and Communication Technology, vol. 323, Springer, 2010, pp. 213–228.[34] Y. Kazakov, I. Pratt-Hartmann, A note on the complexity of the satisfiability problem for graded modal logics, in: Proceedings of the 24th Annual IEEE Symposium on Logic in Computer Science (LICS), IEEE Computer Society, 2009, pp. 407–416.[35] V. Gutiérrez-Basulto, Y.A. Ibáñez-García, J.C. Jung, Number restrictions on transitive roles in description logics with nominals, in: S.P. Singh, S. Markovitch (Eds.), Proceedings of the 31st AAAI Conference on Artificial Intelligence (AAAI), AAAI Press, 2017, pp. 1121–1127.[36] A. Artale, D. Calvanese, R. Kontchakov, M. Zakharyaschev, The DL-Lite family and relations, J. Artif. Intell. Res. 36 (2009) 1–69.[37] B. Bednarczyk, E. Kieronski, P. Witkowski, Completing the picture: Complexity of graded modal logics with converse, Theory Pract. Log. Program. 21 (4) [38] T. Gogacz, V. Gutiérrez-Basulto, Y. Ibáñez-García, J.C. Jung, F. Murlak, On finite and unrestricted query entailment beyond SQ with number restrictions on transitive roles, in: S. Kraus (Ed.), Proceedings of the 28th International Joint Conference on Artificial Intelligence (IJCAI), 2019, pp. 1719–1725.[39] L. Schröder, D. Pattinson, How many toes do I have? parthood and number restrictions in description logics, in: G. Brewka, J. Lang (Eds.), Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR), AAAI Press, 2008, pp. 307–317.[40] B. Bednarczyk, S. Rudolph, Worst-case optimal querying of very expressive description logics with path expressions and succinct counting, in: S. Kraus (Ed.), Proceedings of the 28th International Joint Conference on Artificial Intelligence (IJCAI), ijcai.org, 2019, pp. 1530–1536.[41] C. Lutz, The complexity of conjunctive query answering in expressive description logics, in: A. Armando, P. Baumgartner, G. Dowek (Eds.), Proceedings of 4th International Joint Conference on Automated Reasoning (IJCAR), in: Lecture Notes in Computer Science, vol. 5195, Springer, 2008, pp. 179–193.[42] J. Pérez, M. Arenas, C. Gutiérrez, nSPARQL: A navigational language for RDF, J. Web Semant. 8 (4) (2010) 255–270.[43] M. Bienvenu, D. Calvanese, M. Ortiz, M. Simkus, Nested regular path queries in description logics, in: C. Baral, G.D. Giacomo, T. Eiter (Eds.), Proceedingsof 14th International Conference on Principles of Knowledge Representation and Reasoning (KR), AAAI Press, 2014.[44] P. Bourhis, M. Krötzsch, S. Rudolph, How to best nest regular path queries, in: M. Bienvenu, M. Ortiz, R. Rosati, M. Simkus (Eds.), Proceedings of the 27th International Workshop on Description Logics, CEUR Workshop Proceedings, 2014, pp. 404–415.(2021) 493–520.21