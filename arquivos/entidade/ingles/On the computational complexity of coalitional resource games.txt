Artificial Intelligence 170 (2006) 835–871www.elsevier.com/locate/artintOn the computational complexity ofcoalitional resource gamesMichael Wooldridge, Paul E. Dunne ∗Department of Computer Science, University of Liverpool, Liverpool L69 7ZF, United KingdomReceived 15 July 2005; received in revised form 22 February 2006; accepted 29 March 2006Available online 2 May 2006AbstractWe study Coalitional Resource Games (CRGs), a variation of Qualitative Coalitional Games (QCGs) in which each agent isendowed with a set of resources, and the ability of a coalition to bring about a set of goals depends on whether they are collectivelyendowed with the necessary resources. We investigate and classify the computational complexity of a number of natural decisionproblems for CRGs, over and above those previously investigated for QCGs in general. For example, we show that the complexityof determining whether conflict is inevitable between two coalitions with respect to some stated resource bound (i.e., a limit valuefor every resource) is co-NP-complete. We then investigate the relationship between CRGs and QCGs, and in particular the extent towhich it is possible to translate between the two models. We first characterise the complexity of determining equivalence betweenCRGs and QCGs. We then show that it is always possible to translate any given CRG into a succinct equivalent QCG, and that it isnot always possible to translate a QCG into an equivalent CRG; we establish some necessary and some sufficient conditions for atranslation from QCGs to CRGs to be possible, and show that even where an equivalent CRG exists, it may have size exponential inthe number of goals and agents of its source QCG.© 2006 Elsevier B.V. All rights reserved.Keywords: Coalitional games; Resources; Computational complexity; Multi-agent systems1. IntroductionThe questions of why and how self-interested agents might choose to cooperate are central to several researchareas, of which multi-agent systems is an important recent example [4,44,46]. One problem that has received particularattention is that of coalition formation [20,34–36,39,40]. The main question in coalition formation is that of whichcoalition an agent should join: the main answer to this question is that an agent should join a coalition that is stable,that is, one such that no subset of agents from the coalition would have any rational incentive to defect from it [27,p. 255].In previous work, we introduced a model of coalitional games in which agents were assumed to cooperate withone another in order that they can mutually accomplish their goals [47]. Such Qualitative Coalitional Games (QCGs)seem a useful framework for modelling goal-oriented multi-agent systems. The basic idea in QCGs is that each agent* Corresponding author.E-mail address: ped@csc.liv.ac.uk (P.E. Dunne).0004-3702/$ – see front matter © 2006 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2006.03.003836M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871desires to achieve one of a set of goals, and every coalition has available to it a set of choices, where each choiceintuitively represents one way that the coalition could choose to cooperate. A choice is modelled as a set of goals,which would be achieved if the coalition chose to cooperate in the corresponding way. The incentive for an agent tojoin a coalition is that the individual choices available to this agent may not result in the satisfaction of its goals, butby cooperating, a coalition can achieve a set of goals to their mutual satisfaction. In [47], we presented a systematicsurvey of the complexity of decision problems associated with QCGs, and also defined an efficient representation forthem, based on propositional logic.Although QCGs seems appropriate for modelling and understanding the abstract properties of cooperation in goal-oriented multi-agent systems, they do not consider the origin of the choices available to coalitions. These choicesare simply ascribed to coalitions via a characteristic function, in much the same way as in conventional coalitionalgames [27, p. 257]. In this paper, we consider a special case of QCGs, which provides one answer to the question ofhow these choices arise. In a Coalitional Resource Game (CRG), the choices available to a coalition are dependenton the resources available to its members and the resources required to achieve goals. Thus, in CRGs, we assumethat agents have goals that they desire to achieve, exactly as in QCGs; but each agent is also assumed to have a fixedendowment of resources, while to achieve any given goal requires the expenditure of a certain profile of resources.A coalition will then form in order to pool resources to achieve a set of goals that satisfies all members of the coalition.Defined in this way, every CRG can also be understood as a QCG: given any CRG, it is possible to construct a QCG that is“equivalent”, in the sense of the choices available to coalitions. Thus, given a CRG, we can ask all the questions relatingto coalitions, goals sets, and QCGs generally that were studied in [47]. But it also becomes possible to ask questionsrelating to (for example) resource consumption (e.g., is the consumption of a given resource strictly necessary in orderto satisfy the goals of a given coalition?) and resource contention (e.g., is it the case that two given coalitions cannotachieve their goals without consuming more than some stated resource bound?). In this sense, CRGs enable us to askmore fine grained questions about cooperation in the scenarios for which they are applicable than is possible usingQCGs.Many naturally occurring scenarios in contemporary computing and AI can be understood as CRGs. One of the mosttimely and important is that of virtual organisations, (VOs), particularly within emerging software infrastructures suchas the Grid:VOs have the potential to change dramatically the way we use computers to solve problems, much as the Web haschanged how we exchange information. [. . . The] need to engage in collaborative processes is fundamental to manydiverse disciplines and activities. It is because of this broad applicability of VO concepts that Grid technology isimportant. [14]VOs are of particular interest in collaborative science projects, where a number of partners cooperate by sharingresources (e.g., particle accelerators, super-computers or Grid networks, gene sequencers) in order to accomplishindividual goals. In such situations, profit is not the motivation; the VO participants are primarily interested in accom-plishing their specific goals. Such scenarios naturally map to CRGs. When the participants in a VO are software agents,then the computational questions associated with them—particularly the complexity of these questions—naturallycome to the fore.We believe that the focus on resources is very natural, given the concerns of multi-agent systems and relateddisciplines: resource limitations, and the need to efficiently manage and share resources in a multi-agent environment,provides one of the fundamental motivations for distributed AI and multi-agent systems [4, p. 9]. Most consideration ofresources in the multi-agent systems community has been directed at the resource allocation problem, i.e., the problemof determining which agent or agents should have access to some scarce resource [4, p. 15]. Economic mechanisms(such as auctions) are currently the focus of much attention with respect to resource allocation [24,33]. In this paper,we focus not on the resource allocation problem, but rather on the properties of such allocations, and in particular,how and what coalitions may form, given a specific allocation, and what the properties of such allocations are withrespect to resources.Overall, the paper makes the following three key contributions to the computational study of games played withresources:M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871837• First, we present ten natural decision problems associated with CRGs, and classify their computational complex-ity.• Second, we investigate the relationship between CRGs and QCGs in detail. We define the notion of “equivalence”between a CRG and QCG, and show that the problem of deciding equivalence is co-NP-complete.• Third, we investigate a number of questions associated with “translating” between CRGs and QCGs. We estab-lish that, not only is it the case that any CRG can be represented by an equivalent QCG, but that for every CRG,there exists a succinct equivalent QCG. More precisely, we show that any CRG containing t resources, m goals,and n agents can be represented by a QCG of size O(bt (n + m + b)), where b is the number of bits used to en-code endowment and resource quantity values. The proof is constructive, in that we show how to build such anequivalent QCG. With respect to translating from QCGs to CRGs, we first show that in the general case, no suchtranslation is possible. We then define some necessary and some sufficient conditions for such a translation to bepossible, and show that, even when such a translation is possible, it may result in a CRG of size exponential inn + m.The paper also makes a more general contribution to the problem of how to represent coalitional games succinctly, aproblem which has attracted a number of researchers over the past five years or so (cf. [3,8,17]); see Section 6.The remainder of the paper is structured as follows. First, in Section 2, we motivate and introduce the formalframework of CRGs. Section 3 presents our main complexity results. Section 4 considers the relationship betweenCRGs and QCGs, Section 5 discusses variants of the CRG model in which some of the underlying assumptions arerelaxed, while Section 6 presents some related work. Finally, Section 7 presents some conclusions. We begin, in thefollowing subsection, with a summary of some key notational conventions and a very brief review of some relevantconcepts from complexity theory.1.1. NotationIf f : S → T is a function, then we denote the range of f by ran f , so ran f = {y: ∃x ∈ S such that y = f (x)}.We use the symbols (cid:6) and ⊥ as the Boolean constants for truth and falsity, respectively. In general, upper caseGreek letters—Φ, Ψ , etc.—are used as meta-language variables ranging over formulae of propositional logic. Inaddition to the standard Boolean operations of conjunction (∧), disjunction (∨), implication (⇒), and negation (¬),some constructions will make of the binary exclusive-or function, which we denote by ⊕. For a propositional formulaΦ(x1, . . . , xn) defined over the variables Xn = (cid:12)x1, . . . , xn(cid:13), given Z ⊆ Xn, we denote by Φ[Z] the result of evaluatingΦ under the instantiation xi = (cid:6) if xi ∈ Z, and xi = ⊥ if xi /∈ Z. Thus, Φ[Z] is equivalent to the value of Φ(ζ1, . . . , ζn)where the tuple ζ = (cid:12)ζ1, . . . , ζn(cid:13) describes the characteristic vector from {(cid:6), ⊥}n for Z with respect to Xn. Forexample, given the propositional formula Ψ (x1, x2, x3) = x1 ∧ (x2 ∨ x3), the expression Ψ [x2] evaluates to ⊥ ∧ ((cid:6) ∨⊥), which in turn evaluates to ⊥. Where no ambiguity arises, we frequently omit explicit indication of conjunction,(∧), writing ϕψ rather than ϕ ∧ ψ.Much of the paper concerns the computational complexity of several questions that may be asked of CRGs: we referthe reader to [15,18,28] for introductions to this subject, and [47] for a more detailed review of the key concepts. We areconcerned largely with the well-known complexity classes P, (of languages/problems that may be recognised/solvedin deterministic polynomial time), and NP (of languages/problems that may be recognised/solved in non-deterministicpolynomial time), and with the complement, co-NP, of NP. We also use the “difference” class, Dp [28, p. 412]: alanguage L is in Dp if there exist languages L1 ∈ NP and L2 ∈ co-NP such that L = L1 ∩ L2. Finally, we alsomake use of the slightly less well known notion of strong completeness [28, pp. 203–204]. Roughly speaking, aproblem is said to be NP-complete in the strong sense if it remains NP-complete even when an extremely inefficientrepresentation scheme is used for numbers appearing in instances of the problem. More formally, strong completenessfor complexity classes C closed under polynomial time reductions is defined as follows. First, if I is an instance of acomputational problem, then let number(I ) denote the largest integer appearing in I . If Π is a computational problem,and f : N → N is a function from natural numbers to natural numbers, then Πf denotes Π restricted to instances Isuch that number(I ) (cid:2) f (|I |), where |I | is the length of the encoding instance I . We then say Π is complete for C inthe strong sense if there exists a polynomial p : N → N such that Πp is C-complete. Thus, for example, problems that838M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871are NP-complete in the strong sense remain NP-complete even if we encode instances of them using unary instead ofbinary for representing numbers.12. Coalitional resource gamesIn this section, we present the formal framework of CRGs; we begin by informally introducing and motivatingthe components of these structures. First, the games we study contain a (non-empty, finite) set Ag = {a1, . . . , an} ofagents. A coalition, typically denoted by C, is simply a set of agents, i.e., a subset of Ag. The grand coalition is theset of all agents, Ag. Each agent i ∈ Ag is assumed to have associated with it a (finite) set Gi of goals, drawn from aset of overall possible goals G. The intended interpretation is that the members of Gi represent all the different waysthat agent i’s goals might be satisfied. That is, agent i would be happy if any member of Gi were achieved—but weare not concerned with preferences over individual goals. Thus, at this level of modelling, i is indifferent among themembers of Gi : it will be satisfied if at least one member of Gi is achieved, and unsatisfied otherwise. Note that caseswhere more than one of an agent’s goals are satisfied are not an issue—an agent’s aim will simply be to ensure that atleast one of its goals is achieved, and there is no sense of an agent i attempting to satisfy as many members of Gi aspossible.In order to bring about their goals, agents must expend resources. We assume a (fixed, finite, non-empty) set ofresources, R, and assume that each agent is endowed with a (possibly zero) natural number quantity of each resource.We denote the amount of resource r ∈ R that agent i ∈ Ag is endowed with by en(i, r), thus en(i, r) ∈ N. Differentgoals may require different quantities of each resource for their achievement. We denote the amount of resource rrequired to achieve goal g by req(g, r); again, we assume that req(g, r) ∈ N.Collecting these components together, we get coalitional resource games (CRGs).Definition 1. A coalitional resource game Γ is an (n + 5)-tuple:Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13)where:• Ag = {a1, . . . , an} is a set of agents;• G = {g1, . . . , gm} is a set of possible goals;• R = {r1, . . . , rt } is a set of resources;• for each i ∈ Ag, Gi ⊆ G is a set of goals, the intended interpretation being that any of the goals in Gi wouldsatisfy i—but i is indifferent between the members of Gi ;• en : Ag × R → N is an endowment function, with the intended interpretation that if en(i, r) = k, then agent i ∈ Agis endowed with quantity k ∈ N of resource r ∈ R; and• req : G × R → N is a requirement function, with the intended interpretation that if req(g, r) = k, then to achievegoal g ∈ G, it is necessary to expend quantity k ∈ N of resource r ∈ R.We will assume that no goal in G is “trivially” attainable, i.e., every goal requires a non-zero expenditure of atleast one resource. This assumption seems reasonable, since such “trivial” goals can be eliminated without alteringthe strategic structure of a game: since every agent can achieve such a goal, then these goals can have no effect on theformation or otherwise of specific coalitions. Formally, we assume that∀g ∈ G, ∃r ∈ R such thatreq(g, r) > 0We say a CRG is binary if the endowments and resources in that CRG are either zero or one, i.e., if ran en ⊆ {0, 1} andran req ⊆ {0, 1}. The significance of binary CRGs will become clear later, when we prove complexity results.1 The point being that unary is an extremely inefficient representation scheme: the natural number 1024 represented in unary is a string containing1024 symbols, whereas the binary representation of 1024 requires only 10 symbols: binary is thus exponentially more succinct than unary. Strongcompleteness implies that such clumsy representations have no effect on the complexity of the problem; note that there exist computational problemsthat are known to be NP-complete in the ordinary sense, but which are not NP-complete in the strong sense—KNAPSACK is an example of such aproblem [15, p. 247].M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871839We extend the endowment function en to coalitions via the function en : 2Ag × R → N, as follows.en(C, r) =(cid:2)en(i, r)i∈CThus if en(C, r) = k, then the total amount of resource r ∈ R available to coalition C ⊆ Ag is k. Similarly, we extendthe req function to sets of goals via the function req : 2G × R → N, as follows.(cid:17)req(G, r) =(cid:2)req(g, r)g∈G(cid:17)A set of goals G(cid:17) satisfies agent i if G(cid:17) ∩ Gi (cid:18)= ∅; we say that G(cid:17) satisfies coalition C ⊆ Ag if it satisfies everymember of C. We denote the set of goal sets that satisfy a coalition C by sat(C).sat(C) = {G(cid:17) ⊆ G: ∀i ∈ C, Gi ∩ G(cid:17) (cid:18)= ∅}A set of goals G(cid:17) is feasible for coalition C if that coalition is endowed with sufficient resources to achieve all thegoals in G(cid:17). We denote the set of feasible goal sets for coalition C by feas(C).feas(C) =(cid:17)(cid:17) ⊆ G: ∀r ∈ R, req(G(cid:3)G(cid:4), r) (cid:2) en(C, r)Notice that monotonically increasing coalitions have monotonically increasing feasible goal sets. That is, if C ⊆ C(cid:17),then feas(C) ⊆ feas(C(cid:17)). In the terminology of [47], CRGs are thus inherently coalition monotonic.Finally, we define the function sf : 2Ag → 2G to return the set of goal sets that both satisfy and are feasible for agiven coalition.sf (C) = sat(C) ∩ feas(C)Of course, unlike feas, sf is not monotonic: if C ⊆ C(cid:17), this does not necessarily imply sf (C) ⊆ sf (C(cid:17)).An example is called for.Example 1. Consider the following CRG, which we refer to as Γ1. We have three agents, Ag = {a1, a2, a3}, with twopossible goals, G = {g1, g2}, and two resources R = {r1, r2}. The goal sets for each agent are as follows.G1 = {g1}G3 = {g1, g2}G2 = {g2}The endowment function en is defined as follows.en(a1, r1) = 2en(a2, r1) = 0en(a3, r1) = 1en(a1, r2) = 0en(a2, r2) = 1en(a3, r2) = 2And the requirement function as follows.req(g1, r2) = 2req(g2, r2) = 1req(g1, r1) = 3req(g2, r1) = 2There are eight possible coalitions in the game, as follows.C0 = ∅C4 = {a3}C1 = {a1}C5 = {a1, a3}C2 = {a2}C6 = {a2, a3}C3 = {a1, a2}C7 = {a1, a2, a3}The endowments for these coalitions are summarised in Table 1, together with the feasible goal sets for each coalition,and the goal sets that are both feasible for and satisfy each coalition.Table 1Endowments, feasible goal sets, and satisfying feasible goal sets for coalitions in Example 1en(Cx , r1)en(Cx , r2)feas(Cx )sf (Cx )C000∅∅C120∅∅C201∅∅C321{g2}∅C412∅∅C532{{g1}, {g2}}{g1}C613∅∅C733{{g1}, {g2}}∅840M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–8712.1. A note on assumptionsThere are several observations to make about CRGs, particularly with respect to the assumptions underlying themodel.• First, we are only concerned here with one shot games: we are not concerned with repeated plays of a game,where an agent must factor in concerns about reserving resources for future consumption, or where resources arepotentially replenished in some way in the future. Clearly such concerns suggest themselves for future study, andsome preliminary investigations into Temporal QCGs have already begun [1].• Second, note that achieving a goal which satisfies two agents is assumed to cost no more than achieving the samegoal to satisfy one agent. There is thus a fixed resource profile for achieving goals, which does not change nomatter how many agents the goal satisfies.There are some natural scenarios that cannot be directly captured within the CRG framework. Perhaps the most obviousof these are as follows.• First, consider a scenario in which a resource, not possessed by every agent, is necessary for the accomplishmentof a goal but is not consumed in achieving the goal. We cannot directly model such cases, but since we are onlyconcerned with “one shot” CRGs (i.e., a single decision-making round, with no consideration of future resourceusage), then we can capture such necessary but non-consumable resources by introducing a resource for whichthe requirement is 1: those agents who are endowed with the resource are given an endowment of 2|Ag| units of it(i.e., enough for every possible coalition).• Second, suppose there are multiple possible ways to achieve a given goal (i.e., there is not just one resource profilecharacterising the requirements for a given goal). Again, we can indirectly capture such scenarios by introducingmultiple goals, one for each different way that a goal can be satisfied.We comment on extensions to the basic CRGs model in Section 5.Finally, it is worth commenting on the representation of CRGs. One of the main questions considered in [47] wasthat of how to represent QCGs, given that naive (extensive set theoretic) representations would be exponentially largein the number of agents and goals. To answer this question, a “succinct” representation of QCGs was proposed, basedon propositional logic formulae. Now, it should be immediately clear that this issue does not arise for CRGs, becauseit is possible to represent the endowment function as an n × t matrix of natural numbers (where n is the number ofagents and t is the number of resources), and the requirement function as a m × t matrix of natural numbers (wherem is the number of goals). This representation is very obviously of size polynomial in the number of agents, goals,and resources. This raises the interesting question of whether CRGs might be used as a succinct representation forQCGs. However, as we shall see in Section 4, it is not always possible to “translate” a QCG into an equivalent CRG,and even where such a translation is in principle possible, there are cases where it inevitably results in a CRG thatis exponentially large in n + m, i.e., translating from the original QCG to an equivalent CRG necessitates the use ofexponentially many distinct resources.3. The complexity of coalitional resource gamesIn this section, we present the first of our main results. We introduce and define a number of natural decisionproblems associated with CRGs, and then characterise their computational complexity: the results of this section aresummarised in Table 2.Before proceeding, it is worth remarking that, although we will not investigate the issue in depth until Section 4, itshould be clear now that every CRG induces a QCG that is “equivalent” with respect to what it says about the choicesavailable to coalitions, and the goal sets that coalitions can achieve. It follows that CRGs can be understood as asubset, or special case of QCGs, and hence all the questions proposed for QCGs in [47] may also be asked of CRGs. Itwould be legitimate to investigate whether or not there is any difference in complexity between those problems whenframed in the general case, for QCGs, and the special case, for CRGs. In fact, the only problem that we investigate herethat is directly equivalent to a corresponding QCG problem is SUCCESSFUL COALITION: the problem of determiningM. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871841Table 2Main complexity results relating to CRGsProblemSUCCESSFUL COALITIONMAXIMAL COALITIONMAXIMAL SUCCESSFUL COALITIONNECESSARY RESOURCESTRICTLY NECESSARY RESOURCE(C, G(cid:17), r)-OPTIMALR-PARETO OPTIMALITYSUCCESSFUL COALITION WITH RESOURCE BOUNDSCONFLICTING COALITIONSPOTENTIAL GOAL SETComplexityNP-completeco-NP-completeDp-completeco-NP-completeDp-completeNP-completeco-NP-completeNP-completeco-NP-completein PReferenceTheorem 1Theorem 2Theorem 3Theorem 4Theorem 5Theorem 6Theorem 7Theorem 8Theorem 9Theorem 10whether a given coalition would be able to cooperate in such a way as to achieve at least one goal for every memberof the coalition. This problem was shown to be NP-complete in the general QCG case, and as we shall see, it is alsoNP-complete for the special case of CRGs. Rather than investigating again the problems we previously investigatedin [47], we prefer here to focus on questions that may be asked of CRGs that cannot be asked of QCGs. However,we hypothesise that there is no difference in complexity between the QCG cases investigated in [47] for coalitionmonotonic characteristic functions, and the special case of CRGs discussed here.2We divide the problems we consider into four categories, as follows:• problems relating to coalitions;• problems relating to resources;• problems relating to resource bounds and resource conflicts; and• positive results.With respect to the first category, the first decision problem we consider is SUCCESSFUL COALITION (SC). Thisproblem was introduced in [47] as the most fundamental question that could be asked of a QCG; as we noted above,this is the only problem from [47] that was considered in the general QCG case that we also consider for CRGs. SUC-CESSFUL COALITION asks whether, given a particular CRG and a coalition in this CRG, is there a feasible choiceavailable to the coalition that will satisfy all its members? That is, is the coalition endowed with sufficient resourcesto bring about a set of goals that will satisfy all its members? While we cannot be sure that a coalition will form justbecause it is successful, we can be sure that an unsuccessful coalition will not form, because by definition such acoalition would leave at least one of its members unsatisfied. The MAXIMAL COALITION problem is that of determin-ing whether a coalition has reached a limit, beyond which adding members will make the coalition unsuccessful; thatis, the problem of checking whether every superset of a coalition is unsuccessful. Since the MAXIMAL COALITIONproblem does not require that the coalition in question is in fact successful itself, we also consider the MAXIMALSUCCESSFUL COALITION problem, which considers whether, not only is the coalition maximal, but whether it is alsosuccessful.The next set of problems we consider relate to resources. The NECESSARY RESOURCE problem is that of determin-ing whether, given a particular CRG and a particular resource, the exploitation of that resource is necessary by everysuccessful coalition. Knowing whether a resource is necessary can be useful in understanding the strategic structureof a scenario: for example, at least one such agent endowed with such resources will form part of every successfulcoalition. With respect to the real world, one only has to consider the role that resources such as oil play in the strategicplanning of industrialised nations to understand why the consideration of necessary resources is worthwhile. Neces-sary resources can be thought of as being analogous to veto players in conventional coalitional games and QCGs [47].(Indeed, it is immediately obvious that if a particular resource r is necessary, and only one agent i has a non-zeroendowment of r, then i will be a veto player for every agent in the game, while if C ⊆ Ag are the only agents holdinga non-zero endowment of r, then every coalition must have some member of C, and so C could collectively veto2 If it is not already obvious, it will become clear in Section 4 why we refer here to the case of monotonic QCGs.842M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871any coalition.) The STRICTLY NECESSARY RESOURCE problem considers a resource together with a coalition, andasks whether not only is the resource necessary, but that the coalition is successful—the point being that this coalitionwould then necessarily have to expend some of this resource, were they to form.Next, we consider the problem of optimal resource utilisation: whether a choice represents the most efficient wayof satisfying a coalition. We first consider the problem of optimality with respect to a single resource: the (C, G(cid:17), r)-OPTIMALITY problem asks whether the goal set G(cid:17) is optimal for C with respect to the usage of resource r; moreprecisely whether there is no way that C can succeed without expending more of resource r than they would bychoosing G(cid:17). Generalising to arbitrary sets of resources, the R-PARETO EFFICIENT GOAL SET problem asks whethera particular goal set, for a particular coalition, is Pareto efficient with respect to resource usage [27, p. 122]; that is,whether or not any other goal set that represents a feasible satisfying choice for the given coalition, and which usedstrictly less of some resource, would inevitably use more of some other resource.Very often, of course, a coalition will be interested in achieving some set of goals within some given resourcebound—even when there is in principle more of this resource available than is allowed by the resource bound. Suchscenarios are quite common when one considers the use of a finite resource (such as oil, as discussed above); here,even though we have in principle a large quantity of a resource available, we want to limit its usage now, in orderthat we can achieve our goals in the future. Similarly, we might wish to bound the usage of some resource for otherreasons: limiting pollution emission by manufacturing plants is one obvious relevant scenario that has previously beenstudied in the multi-agent systems literature [23, pp. 175–211]. Here, the expenditure of a particular resource (e.g.,oil) leads to the emission of pollutants, and so we seek to keep the usage of this resource within some given bound,while still satisfying our goals. The SUCCESSFUL COALITION WITH RESOURCE BOUND problem considers whethera coalition can be successful while at the same time respecting some resource bound.Of course, where resources are bounded, resource conflicts may occur. This motivates us to investigate the CON-FLICTING COALITIONS problem, which investigates when two given coalitions are in conflict with respect to somegiven resource bound. Two coalitions would be said to be in conflict with respect to a given resource bound if there isno way that they can both be successful without jointly exceeding the bound.Finally, we consider a problem relating to goal sets in CRGs: we show that the problem of determining whethera goal set has the “potential” to be achieved within the context of a CRG—i.e., whether there is some coalition ofagents such that this goal set is both feasible for and satisfies this coalition—is not only decidable by polynomial timesequential methods but also admits an efficient parallel realisation.33.1. Problems relating to coalitionsRecall that a coalition is successful if that coalition has a feasible choice that satisfies every member of the coalition.Example 2. With reference to the CRG Γ1 of Example 1, only one coalition is successful: namely, coalition C5 ={a1, a3}. This coalition has in fact just one goal set—{g1}—which both satisfies it and is feasible for it. To see this,simply note that req(g1, r1) = en(C5, r1), and req(g1, r2) < en(C5, r2).Formally, the decision problem is as follows:SUCCESSFUL COALITION: (SC)Instance: CRG Γ and coalition C.Answer: “Yes” if sf (C) (cid:18)= ∅.Theorem 1. SUCCESSFUL COALITION is NP-complete, even for binary CRGs, and hence SUCCESSFUL COALITIONis strongly NP-complete.3 More formally, we show “potential goal set for CRGs” is in the class NC1 of languages recognisable by polynomial size O(log N )-depth Booleannetworks. One consequence of this is that potential goal set for CRGs will not (under the usual assumption NC ⊂ P) be P-complete, i.e., a “hardest”problem within P. For further background on parallel time complexity classes and NC we refer the reader to [19,28].M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871843Proof. For membership, the following NP algorithm decides the problem: guess a subset G(cid:17) of G and verify that bothG(cid:17) ∈ sat(C) and G(cid:17) ∈ feas(C). Both steps can obviously be done in time polynomial in the size of Γ , and so theproblem is in NP.For NP-hardness, we reduce from SAT [28, p. 171]. An instance of SAT is given by a propositional logic formulaΦ(x1, . . . , xn), the aim being to answer “yes” if there is some valuation to the Boolean variables x1, . . . , xn thatsatisfies the formula. Without loss of generality, we assume that Φ(x1, . . . , xn) is presented in Conjunctive NormalForm (CNF), i.e.,Φ(x1, . . . , xn) =(cid:5)ψiiwhere each ψi is a clause—a disjunction of literals. We create an instance of SC as follows.• For each literal (cid:9) occurring in Ψ we create a goal g(cid:9).• For each clause ψi , we create an agent aψi , and define Gi to be the set of goals corresponding to the literals thatoccur in ψi . That is, if ψi = (cid:9)1 ∨ · · · ∨ (cid:9)k, then we define Gi = {g(cid:9)1, . . . , g(cid:9)k• For each propositional variable x, we create a resource rx .• For each goal g and resource rx , we define the quantity of rx required for g as follows:}.(cid:6)req(g, rx) =10if g = gx or g = g¬xotherwise.• We then pick the agent a1 corresponding to the first clause, ψ1, and define its endowment function so that for allresources r, we have en(a1, r) = 1. Every other agent is given an endowment of zero for every resource.We now prove that Ag is a successful coalition in the CRG ΓΦ if and only if Φ(x1, . . . , xn) is satisfiable:(⇒) Assume that Ag is successful, and let G(cid:17) be a goal set that is both feasible for and satisfies Ag. Then we cantrivially extract a satisfying assignment for Φ(x1, . . . , xn) from G(cid:17): for example, if G(cid:17) = {gx1 , g¬x2}, then thesatisfying assignment involves assigning (cid:6) to x1 and ⊥ to x2. The assignment is consistent, because there isonly sufficient resource corresponding to propositional variable xi to achieve gxi or g¬xi —the coalition cannotachieve both. Every clause is satisfied because every agent is satisfied, and agent i’s goal set Gi corresponds tothe literals in clause Ci : it must have at least one of its goals achieved, and hence must have one of these literalssatisfied.(⇐) Assume that Φ(x1, . . . , xn) is satisfiable; then from a satisfying assignment, we can extract a goal set that bothsatisfies the grand coalition and is feasible for this coalition: each clause must have at least one literal satisfied,and hence by construction each agent must have at least one goal satisfied; and the grand coalition must clearlyhave sufficient resources, since the amount of resource rxi required to achieve either gxi or g¬xi is 1, and thegrand coalition has exactly this much of every resource available.This concludes the proof that SUCCESSFUL COALITION is NP-complete in the regular sense. To see that it is stronglyNP-complete, note that the CRG created in the reduction is binary: all requirements and endowments are either zeroor one. Unary representations for instances of binary CRGs are clearly only polynomially larger than the size of thecorresponding binary representation. (cid:2)(Note that, in the proofs that follow, we will omit the corresponding argumentation for the strong completenessresults, merely noting where the reduction produces a binary CRG, which is enough to establish completeness in thestrong sense.)As is clear from the reduction used, Theorem 1 holds in the special case of C being the grand coalition. It will beuseful explicitly to define this special case, independently, as a decision problem which we denote by GCS. Formallywe have,GRAND COALITION SUCCESS: (GCS)Instance: CRG Γ .Answer: “Yes” if sf (Ag) (cid:18)= ∅.844M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871so that, from Theorem 1,Corollary 1. GCS is NP-complete, even for binary CRGs, and hence GCS is strongly NP-complete.The next problem we consider is that of whether or not a particular coalition is maximal; that is, whether addingany members to the coalition would lead to it being unsuccessful, in the sense of having insufficient resources tocollectively satisfy its goals.MAXIMAL COALITION: (MAXC)Instance: CRG Γ and coalition C.Answer: “Yes” if ∀C(cid:17) such that C(cid:17) ⊃ C, sf (C(cid:17)) = ∅.There are several points to note here. First, we require set inclusion between coalitions to be strict in this definition;second, the grand coalition will always be maximal; and, finally, that the formulation does not assume or require thatC itself be successful, i.e., have sf (C) (cid:18)= ∅.Example 3. With reference to the CRG Γ1 of Example 1, only coalitions C0, C1 and C4 are not maximal, but all othersare. Since there is a successful coalition (C5) certainly C0 cannot be maximal. To see that the other two coalitions arenot maximal, observe that there is only one successful coalition overall (C5), and both C1 and C4 are strict subsetsof C5.Theorem 2. MAXIMAL COALITION is co-NP-complete, even for binary CRGs, and hence MAXIMAL COALITION isstrongly co-NP-complete.Proof. For membership in co-NP, given (cid:12)Γ, C(cid:13) an instance of MAXC with Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) andC ⊆ Ag, it suffices to check that∀C(cid:17) ⊃ C, G(cid:17) ⊆ G,(cid:7)∀r ∈ R en(C(cid:17)(cid:17), r) (cid:3) req(G(cid:8), r)⇒ (∃ai ∈ C(cid:17): Gi ∩ G(cid:17) = ∅)since the condition can be evaluated in deterministic polynomial-time (recall that R is part of the instance so the test∀r ∈ R en(C(cid:17), r) (cid:3) req(G(cid:17), r) can be carried out in polynomial-time) it follows that MAXC is in co-NP.To prove it is co-NP-hard, we show that the complementary problem—non-maximal Coalition is NP-hard usinga reduction from GCS restricted to binary CRGs. Let Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) be such an instance ofGCS. We form an instance (cid:12)Γ (cid:17), C(cid:13) of non-maximal Coalition simply by choosing Γ (cid:17) = Γ and C = Ag \ {an}. If Γis accepted as an instance of GCS then sf (Ag) (cid:18)= ∅ and C ⊂ Ag, i.e., C is not a maximal coalition so that (cid:12)Γ, C(cid:13) isaccepted as an instance of non-maximal Coalition. On the other hand if (cid:12)Γ, C(cid:13) is accepted as an instance of non-maximal Coalition then, since the only strict superset of C is Ag, this indicates that sf (Ag) (cid:18)= ∅, hence Γ is acceptedas an instance of GCS. We note that the instance of non-maximal Coalition formed is binary giving the strong NP-completeness property claimed. (cid:2)Our formulation of MAXC does not require the coalition forming part of an instance to be successful itself. Ifwe require C to be maximal and successful then the resulting decision problem—Maximal Successful Coalition(MAXSC)—becomes rather more complex.MAXIMAL SUCCESSFUL COALITION: (MAXSC)Instance: CRG Γ and coalition C.Answer: “Yes” if sf (C) (cid:18)= ∅ and ∀C(cid:17) such that C(cid:17) ⊃ C, sf (C(cid:17)) = ∅Theorem 3. MAXSC is Dp-complete, even for binary CRGs, and hence MAXSC is strongly Dp-complete.Proof. For membership in Dp we need to exhibit languages L1 ∈ NP and L2 ∈ co-NP for which the set of positiveinstances of MAXSC is exactly the set formed by L1 ∩ L2. ChoosingM. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871845(cid:4)(cid:3)(cid:12)Γ, C(cid:13): sf (C) (cid:18)= ∅(cid:3)(cid:12)Γ, C(cid:13): ∀D ⊃ C, sf (D) = ∅(cid:4)L1 =L2 =we have L1 ∈ NP via Theorem 1 and L2 ∈ co-NP via Theorem 2. Membership of MAXSC is now immediate from thefact that the instances that should be accepted are precisely those in the set L1 ∩ L2.For Dp-hardness we show that the problem Critical Variable (CV) is polynomially reducible to MAXSC. Instancesof the former problem comprise a pair (cid:12)Φ, z(cid:13) with Φ a CNF-formula and z a propositional variable. An instance isaccepted if there is a satisfying instantiation for Φ in which z = (cid:6) and no satisfying instantiation of Φ in which z = ⊥.An easy proof that CV is Dp-complete is given in [12, Theorem 3].Consider an instance (cid:12)Φ, z(cid:13) of CV withΦ =m(cid:5)i=1Ψieach Ψi being a clause. The instance (cid:12)Γ, C(cid:13) of MAXSC is formed exactly as the instance of SC described in the proofof Theorem 1, but with the following modifications: in addition to the agents, ai , corresponding to the clauses Ψi wehave an agent am+1 for which Gm+1 = {g¬z} and for each r ∈ R, en(am+1, r) = 0. The instance of MAXSC is then(cid:12)Γ, Ag \ {am+1}(cid:13).Suppose that (cid:12)Φ, z(cid:13) is accepted as an instance of CV. From the fact that Φ has a satisfying instantiation in whichz = (cid:6), we may extract a subset G(cid:17) of G such that G(cid:17) ∈ sf (Ag \ {am+1}) using an identical argument to that ofTheorem 1, i.e., the coalition Ag \ {am+1} is successful. Similarly, from the fact that there is no satisfying instantiationof Φ in which z = ⊥ we see that Ag—the only possible strict superset of Ag \ {am+1} cannot succeed: if G(cid:17) ∈ sf (Ag)then g¬z ∈ G(cid:17) (otherwise am+1 fails to achieve its desired goal), and now it is not possible to identify goals for theremaining agents, i.e., literals within each clause, which can be effected using the resources available.Conversely, if (cid:12)Γ, Ag \ {am+1}(cid:13) is accepted as an instance of MAXSC then not only is it the case that Φ is satisfiable(from the fact that sf (Ag \ {am+1}) (cid:18)= ∅), it further holds that all such satisfying instantiations can have z = (cid:6): asatisfying instantiation in which z = ⊥ would contradict the fact that sf (Ag) = ∅.We deduce that (cid:12)Φ, z(cid:13) is accepted as an instance of CV if and only if (cid:12)Γ, Ag \ {am+1}(cid:13) is accepted as an instance ofMAXSC and thus that MAXSC is Dp-complete.It remains only to observe that the CRG in the instance of MAXSC is binary, yielding strong Dp-completeness. (cid:2)3.2. Problems relating to resourcesThe problems above were focused primarily on issues relating to coalitions—whether they were successful, andif so, how they related to other coalitions, successful or otherwise. In this subsection, we consider questions relatinginstead to resources and their usage by successful coalitions.The first problem we consider is NECESSARY RESOURCE. The idea of a necessary resource is somewhat analogousto that of veto players, as discussed in the context of conventional coalitional games [27, p. 187] and QCGs [47]. Thusa resource is said to be necessary if the accomplishment of any set of goals that would satisfy a coalition would implythe consumption of some of the resource. Necessary resources seem to be strategically important: a coalition cannotbe successful without such a resource and thus successful coalitions require at least one member to have a positiveendowment of such a resource. It follows that if a necessary resource is scarce (i.e., is possessed by only a few agents),then such agents are in a strategically important position. If only one agent has the resource, then this agent will be aveto player for every coalition. Formally, the decision problem is as follows.NECESSARY RESOURCE: (NR)Instance: CRG Γ , coalition C, and resource r.Answer: “Yes” if ∀G(cid:17) ∈ sf (C), we have req(G(cid:17), r) > 0.Example 4. With reference to the CRG Γ1 of Example 1, both resources r1 and r2 are necessary. To see this, note thatC5 is the only successful coalition, sf (C5) = {{g1}}: req(g1, r1) = 3 and req(g1, r2) = 2.846M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871Theorem 4. NECESSARY RESOURCE is co-NP-complete, even for binary CRGs, and hence NECESSARY RESOURCEis strongly co-NP-complete.Proof. For membership of co-NP, the following algorithm decides the problem:(1) Universally select each G(cid:17) ⊆ G;(2) check that if G(cid:17) ∈ sat(C) and G(cid:17) ∈ feas(C) then req(G(cid:17), r) > 0.Since we have a single universal alternation in step (1), and step (2) can be done in polynomial time, the algorithmcan be realised in co-NP.To see that the problem is co-NP-hard, we show that its complementary version—the problem redundant resource(RR) whose instances are triples (cid:12)Γ, C, r(cid:13), accepted if there is some G(cid:17) ∈ sf (C) for which req(G(cid:17), r) (cid:2) 0—to be NP-hard. We note that RR is the complement of NR as can be seen by the following observation concerning the languagesLNR and LRR of instances accepted(cid:17) ⊆ G(G(cid:17) ⊆ G(G(cid:4)(cid:17) ∈ sf (C)) ⇒ (req(G(cid:17), r) > 0)(cid:4)(cid:17)(cid:17) ∈ sf (C)) and (req(G, r) (cid:2) 0)(cid:3)(cid:12)Γ, C, r(cid:13): ∀G(cid:3)(cid:12)Γ, C, r(cid:13): ∃GLNR =LRR =That RR is NP-hard is easily shown by employing an reduction from GCS, again restricted to binary CRGs.Given an instance, Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) of the former, we construct an instance (cid:12)Γ (cid:17), Ag, s(cid:13) of RRin which(cid:9)Γ(cid:17) =Ag, G ∪ {gs}, G1 ∪ {gs}, . . . , Gn ∪ {gs}, R ∪ {s}, en(cid:17)with s a new resource and gs a new goal. For each a ∈ Ag, we fix,(cid:10), req(cid:17)(cid:6)en(cid:17)(a, r) =en(ai, r)0if r (cid:18)= sif r = sSimilarly, for g ∈ G ∪ {gs} and r ∈ R ∪ {s} we fixreq(g, r)001if r (cid:18)= s and g (cid:18)= gsif r (cid:18)= s and g = gsif r = s and g (cid:18)= gsif r = s and g = gs(g, r) =⎧⎪⎪⎨⎪⎪⎩req(cid:17)Suppose that (cid:12)Γ (cid:17), Ag, s(cid:13) ∈ LRR. Then there is some G(cid:17) ∈ sf (Ag) for some G(cid:17) ⊆ G ∪ {gs} and with req(cid:17)(G(cid:17), s) (cid:2) 0.Since req(cid:17)(gs, s) > 0 we must have gs /∈ G(cid:17), i.e., G(cid:17) ⊆ G with G(cid:17) ∈ sf (Ag): thus Γ is a positive instance of GCS.On the other hand suppose that Γ is accepted as an instance of GCS. Consider the goal set G(cid:17) witnessing this. Inthe CRG Γ (cid:17) this goal set is such that req(cid:17)(G(cid:17), s) = 0 and has G(cid:17) ∈ sf (Ag), i.e., (cid:12)Γ (cid:17), Ag, s(cid:13) ∈ LRR.It follows that RR is NP-complete, and therefore its complement problem, NR, is co-NP-complete as claimed. Notethat the CRG produced in the reduction is binary if the instance of GCS is binary, and hence the problem is stronglyco-NP-complete. (cid:2)Of course, the fact that a resource is necessary does not in fact mean that it will be used, because it could be thatthe coalition in question is in fact unsuccessful (in which case, every resource is trivially necessary). This conceptmotivates the following problem, in which we ask whether a resource really is necessary: that is, the coalition cansucceed, and in order for it to do so, it must make use of the resource.STRICTLY NECESSARY RESOURCE: (SNR)Instance: CRG Γ , coalition C, and resource r.Answer: “Yes” if sf (C) (cid:18)= ∅ and ∀G(cid:17) ∈ sf (C), we have req(G(cid:17), r) > 0.Example 5. With reference to the CRG Γ1 of Example 1, resources r1 and r2 are strictly necessary with respect to thecoalition C5 (in addition to simply being necessary).M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871847Theorem 5. SNR is Dp-complete, even for binary CRGs, and hence SNR is strongly Dp-complete.Proof. To establish membership in Dp, we must find two languages, L1 and L2, such that: (i) L1 ∈ NP; (ii)L2 ∈ co-NP; and (iii) STRICTLY NECESSARY RESOURCE = L1 ∩ L2 [28, pp. 412–415]. The language of the prob-lem SUCCESSFUL COALITION immediately suggests itself as a candidate for L1, but instances of this problem areconstituted by a CRG and a coalition, with no resource present. We therefore create an AUXILIARY problem, withinput instances being triples consisting of a CRG, a coalition, and a resource (i.e., taking the same form as instancesof NECESSARY RESOURCE). The acceptance condition for AUXILIARY, however is the same as that of SUCCESS-FUL COALITION: the additional input item is ignored. Clearly, the AUXILIARY problem is NP-complete, by the sameargument as Theorem 1. We then define the language L1 by(cid:4)(cid:3)x: AUXILIARY(x)L1 =Since AUXILIARY is NP-complete, L1 ∈ NP as desired. We then define L2 by(cid:4)(cid:3)x: NECESSARY RESOURCE(x)L2 =By Theorem 4, L2 ∈ co-NP. Now by definition,L1 ∩ L2 =(cid:4)(cid:3)x: STRICTLY NECESSARY RESOURCE(x)Thus the problem is in Dp.To see that the problem is Dp-hard, we use a reduction from the problem SAT-UNSAT, instances of which are a pairof CNF formulae, (cid:12)Φ1, Φ2(cid:13), with an instance accepted if Φ1 is satisfiable and Φ2 is unsatisfiable. Notice that, withoutloss of generality, we may assume that the propositional variables of Φ1 are disjoint from the propositional variablesof Φ2.Given an instance, (cid:12)Φ1, Φ2(cid:13), of SAT-UNSAT for whichq(cid:5)q(cid:5)ki(cid:15)p(cid:5)p(cid:5)Φ1 =Ci =xi,j ;Φ2 =Di =li(cid:15)yi,ji=1i=1j =1with xi,j a literal over the propositional variables {x1, . . . , xn} and yi,j a literal over the propositional variables{y1, . . . , yn}, consider the CNF formula Ψ of the 2n + 1 propositional variablesj =1i=1i=1{x1, . . . , xn, y1, . . . , yn, z}given byp(cid:5)Ψ =(¬z ∨ Ci) ∧q(cid:5)(z ∨ Di) =i=1i=1p+q(cid:5)i=1EiLet ΓΨ be the CRG constructed from Ψ following the reduction of Theorem 1, but in which the goal sets Gi (whichwe recall mapped to literal in clauses in the earlier reduction) now being given by(cid:6)Gi ={gw: w is a literal in the clause Ci}{gw: w is a literal in the clause z ∨ Di}if Ei = ¬z ∨ Ciif Ei = z ∨ DiThe only other modifications we make to the reduction are to introduce a resource rnull with req(g, rnull) = 1 ifg = g¬z and 0 otherwise; similarly en(ap+q , rnull) = 1. In addition for the resource rz we fix(cid:6)req(gw, rz) =1 if w = z0 otherwiseNotice that this now gives req(g¬z, rz) = 0 instead of 1.We claim that (cid:12)ΓΨ , Ag, rz(cid:13) is accepted as an instance of SNR if and only if (cid:12)Φ1, Φ2(cid:13) is accepted as an instance ofSAT-UNSAT.(⇒) Suppose (cid:12)ΓΨ , Ag, rz(cid:13) is a positive instance of SNR. Consider any G(cid:17) ∈ sf (Ag), noting that sf (Ag) (cid:18)= ∅, and theinstantiation of Ψ induced by G(cid:17). For i ∈ {1, . . . , p}, the goal satisfied for ai in Gi must correspond to one of848M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871the literals in Ci from which we deduce sf (Ag) (cid:18)= ∅ implies that Φ1 is satisfiable. Furthermore, from the factthat req(G(cid:17), rz) > 0 we must have gz ∈ G(cid:17) for every G(cid:17) ∈ sf (Ag). It follows that we cannot form a subset G(cid:17)(cid:17) ofG \ {gz} that satisfies each agent ai with i ∈ {p + 1, . . . , p + q} and is feasible, i.e., has en(Ag, r) (cid:2) req(G(cid:17)(cid:17), r)for each r. This suffices to prove via the reduction in Theorem 1 that Φ2 must be unsatisfiable.(⇐) Suppose that Φ1 is satisfiable and Φ2 is unsatisfiable. Then every satisfying instantiation of Ψ must set theliteral z to take the value (cid:6). Letting G(cid:17)(cid:17) be the goals corresponding to satisfied literals defined from a satisfyinginstantiation of Φ1, we see that G(cid:17) = G(cid:17)(cid:17) ∪ {gz} is in sf (Ag) thus this set is non-empty. Furthermore, it must bethe case that every G(cid:17) ∈ sf (Ag) has gz ∈ G(cid:17) for otherwise the unsatisfiability of Φ2 is contradicted. It thereforefollows that for all G(cid:17) ∈ sf (Ag) we have req(G(cid:17), rz) > 0, and thus (cid:12)ΓΨ , Ag, rz(cid:13) is a positive instance of SNR.Note that the CRGs produced by this reduction are binary, giving strong Dp-completeness as claimed. (cid:2)Next, we consider the issue of minimising resource usage. Our starting point is this: Suppose a coalition C hastwo feasible and satisfying goal sets, G1 and G2. Then clearly, the coalition will be happy with either of these goalsets being achieved: if satisfaction was the only concern, then all other things being equal, the coalition would beindifferent about which of G1 or G2 was actually achieved. However, it is unlikely that satisfaction will be the onlyconcern. In particular, we might expect coalitions to desire to minimise resource usage—the availability of unusedresources will enable coalitions to achieve goals in the future. This suggests the following problem.(C, G(cid:17), r)-OPTIMALITY: (CGRO)Instance: CRG Γ , coalition C, and goal set G(cid:17) with G(cid:17) ∈ sf (C), and resource r.Answer: “Yes” if ∀G(cid:17)(cid:17) ∈ sf (C), we have req(G(cid:17)(cid:17), r) (cid:3) req(G(cid:17), r).Notice that if a coalition is unsuccessful, then any goal set is optimal with respect to any resource for that coalition.Also, if a coalition has only one choice available that both satisfies and is feasible for that coalition, then that goal setis optimal for all resources for that coalition.Example 6. With reference to the CRG Γ1 of Example 1, goal set G1 = {g1} is optimal for coalition C5 with respectto all resources.Theorem 6. (C, G(cid:17), r)-OPTIMALITY is co-NP-complete, even for binary CRGs, and hence (C, G(cid:17), r)-OPTIMALITY isstrongly co-NP-complete.Proof. To see that CGRO is in co-NP it suffices to note that an instance (cid:12)Γ, C, G(cid:17), r(cid:13) is accepted if and only if for allG(cid:17)(cid:17) ⊆ G,G(cid:8)(cid:17)(cid:17) ∈ sf (C)(cid:17), r) (cid:3) req(G(cid:7)(cid:17)(cid:17)req(G(cid:8), r)⇒(cid:7)The predicate described can be evaluated in time polynomial in the size of the instance.To prove co-NP-hardness we consider the complementary problem, (C, G(cid:17), r)-sub-optimality. Instances for this area 4-tuple, (cid:12)Γ, C, G(cid:17), r(cid:13) as before, but with these accepted if and only if∃G(cid:17)(cid:17) ⊆ G: G(cid:17)(cid:17) ∈ sf (C)(cid:17)(cid:17)and req(G(cid:17), r) < req(G, r)Denoting this problem CGRSO, we show that GCS for binary CRGs is polynomial reducible to CGRSO.Given such an instance Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) of GCS we form an instance of (cid:12)Γ (cid:17), C, G(cid:17), s(cid:13) ofCGRSO in which(cid:17) =(cid:9)ΓAg, G ∪ {gs}, G1 ∪ {gs}, . . . , Gn ∪ {gs}, R ∪ {s}, en(cid:17)(cid:10), req(cid:17)where gs /∈ G is a new goal and s /∈ R a new resource. In Γ (cid:17), req(cid:17)(gs, s) = 1 and req(cid:17)(gs, r) = 0 for all r ∈ R withreq(cid:17)(g, s) = 0 for each g ∈ G; in addition en(cid:17)(ai, s) = 1 for each ai ∈ Ag. We complete the instance (cid:12)Γ (cid:17), C, G(cid:17), s(cid:13) byfixing C = Ag and G(cid:17) = {gs}.If (cid:12)Γ (cid:17), Ag, {gs}, s(cid:13) is accepted as an instance of CGRSO then there is some G(cid:17) ⊆ G ∪ {gs} such that G(cid:17) ∈ sf (Ag) andreq(G(cid:17), s) < req({gs}, s), from which if follows that gs /∈ G(cid:17) and thus, G(cid:17) witnesses to Γ being a positive instance ofGCS.M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871849Conversely if Γ is accepted as an instance of GCS, then there is some G(cid:17) ⊆ G with which G(cid:17) ∈ sf (Ag). ClearlyG(cid:17) ⊂ G ∪ {gs} and (from req(cid:17)(g, s) = 0 for each g ∈ G),(cid:7){gs}, s, s) = 0 < req(cid:17)req(G= 1(cid:8)so that (cid:12)Γ (cid:17), Ag, {gs}, s(cid:13) is a positive instance of CGRSO.This completes the proof that CGRSO is NP-complete and thus its complement—the problem CGRO—is co-NP-complete.Note that if the instance of GCS is binary then the CRG produced in the reduction is also binary, giving strongco-NP-completeness as claimed. (cid:2)(C, G(cid:17), r)-OPTIMALITY measures how good a goal set is with respect to the usage of one resource. An obviousquestion is how this generalises to the set of all resources. To measure the optimality of a goal set with respect to the setof all resources, we use the idea of Pareto efficiency. Pareto efficiency is often considered in the context of outcomesto bargaining—it is one of the three properties uniquely characterising the Nash solution to bargaining problems [27,p. 305]. However, the concept of Pareto efficiency has also found wide currency in other economic settings.In general, an outcome ω is said to be Pareto efficient with respect to a set of agents if there is no other outcome ω(cid:17)that is preferred at least as much as ω by every agent, and is strictly preferred over ω by at least one of the agents. Ifan outcome is not Pareto efficient, then intuitively, the agents can select another solution such that nobody would beworse off, and some would be strictly better off. In our setting, an “outcome” equates to a goal set for some coalition,and we consider whether an outcome is better or worse with respect to resource usage. Thus if G(cid:17) is a goal set andC is a coalition, then we say a goal set G(cid:17)(cid:17) which is both feasible for and satisfies every member of C, and whichrequires no more of every resource and strictly less of some resource than G(cid:17) is said to be an R-Pareto improvementover G(cid:17). A goal set G(cid:17) is said to be R-Pareto efficient (with respect to C) if there does not exist any goal set G(cid:17)(cid:17) whichrepresents R-Pareto improvement over G, i.e., if every other goal set that is both feasible for an satisfies all membersof C requires at least as much of every resource, and strictly more of some resource as G(cid:17).Formally, goal set G(cid:17) is R-Pareto efficient with respect to some coalition C iff:∀G(cid:17)(cid:17) ∈ sf (C):(cid:17)(cid:16)∃r1 ∈ R: req(G(cid:17)(cid:17), r1) < req(G(cid:17), r1)(cid:16)(cid:17)∃r2 ∈ R: req(G(cid:17)(cid:17), r2) > req(G(cid:17), r2)⇒The decision problem is then as follows.R-PARETO EFFICIENT GOAL SET: (RPOGS)Instance: CRG Γ , coalition C, and goal set G(cid:17).Answer: “Yes” if G(cid:17) is R-Pareto efficient for C.(As an aside, notice that the formulation of this problem does not require that G(cid:17) ∈ sf (C).) Although the statementof the R-Pareto efficiency condition seems somewhat involved, it turns out that there is an elegant reduction whichestablishes its complexity.Theorem 7. The R-PARETO EFFICIENT GOAL SET problem is strongly co-NP-complete.Proof. Membership is witnessed by the following algorithm:(1) Universally select all G(cid:17)(cid:17) ⊆ G;(2) Check that if G(cid:17)(cid:17) ∈ sf (C), then G(cid:17)(cid:17) is not an R-Pareto improvement over G(cid:17).Since the algorithm contains a single universal alternation, and step (2) can be checked in polynomial time, theproblem can be decided in co-NP.850M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871For hardness, we reduce GCS for binary CRGs to the complement of the problem, i.e., the problem of checkingwhether there exists some G(cid:17)(cid:17) ∈ sf (C) such that G(cid:17)(cid:17) represents an R-Pareto improvement over G(cid:17). More formally, thecomplement problem asks whether the following formula is true with respect to a given Γ , C, and G(cid:17):∃G(cid:17)(cid:17) ∈ sf (C):(cid:17)(cid:16)∃r1 ∈ R: req(G(cid:17)(cid:17), r1) < req(G(cid:17), r1)(cid:16)(cid:17)∀r2 ∈ R: req(G(cid:17)(cid:17), r2) (cid:2) req(G(cid:17), r2)∧Given an instance Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) of GCS we form an instance (cid:12)Γ (cid:17), C, G(cid:17)(cid:13) of co-RPOGS usingΓ(cid:17) =Ag, G ∪ {gs}, G1 ∪ {gs}, . . . , Gn ∪ {gs}, R ∪ {s}, en(cid:17)with gs /∈ G and s /∈ R a new goal and new resource. For en(cid:17) and req(cid:17) we use, req(cid:17)(cid:10)(cid:9)(cid:6)en(cid:17)(ai, r) =en(ai, r)1⎧1⎪⎪⎨req(G, r)0req(g, r)To complete the instance we set C = Ag and G(cid:17) = {gs}if r (cid:18)= sif r = sif g = gs and r = sif g = gs and r (cid:18)= sif g (cid:18)= gs and r = sif g (cid:18)= gs and r (cid:18)= s(g, r) =req(cid:17)⎪⎪⎩G(cid:17)(cid:17) ∈ sf (Ag) and for which(cid:7){gs}, r, r) (cid:2) req(cid:17)(cid:17)(cid:17)(Greq(cid:17), r∀r ∈ R ∪ {s}req(cid:17)) < req(cid:17)(cid:17)(cid:17)(G(cid:8)(cid:17)(cid:17)and(cid:7){gs}, r(cid:8)If (cid:12)Γ (cid:17), Ag, {gs}(cid:13) is a positive instance of co-RPOGS then we can identify G(cid:17)(cid:17) ⊆ G ∪ {gs} and some r (cid:17) ∈ R ∪ rs withFirst observe that any such G(cid:17)(cid:17) cannot contain gs : for otherwise we have req(cid:17)(G(cid:17)(cid:17), s) = 1 = req({gs}, s) and, in additionfor every r (cid:18)= s(cid:17)(cid:17)req(G(cid:7), r) = reqG(cid:17)(cid:17) \ {gs}, r(cid:8)(cid:7){gs}, r+ req(cid:8)(cid:7)(cid:3) req{gs}, r(cid:8)so that the requirement that strictly less of some resource be expended in realising G(cid:17)(cid:17) would fail to hold. We deducethat G(cid:17)(cid:17) ⊆ G with G(cid:17)(cid:17) ∈ sf (Ag) and hence, from (cid:12)Γ (cid:17), Ag, {gs}(cid:13) being a positive instance of co-RPOGS, Γ is a positiveinstance of GCS as required.Conversely, suppose there is some G(cid:17)(cid:17) ⊆ G such that G(cid:17)(cid:17) ∈ sf (Ag), i.e., that Γ is accepted as an instance of GCS.Consider the corresponding set of goals within the CRG, Γ (cid:17). From the fact that gs /∈ G(cid:17)(cid:17) we obtain,(cid:17)(cid:17)req(G(cid:7){gs}, s, s) = 0 < 1 = req(cid:8)Furthermore, for every resource other than s, since G(cid:17)(cid:17) ⊆ G(cid:17)(cid:17)req(G(cid:7){gs}, r, r) (cid:2) req(G, r) = req(cid:8)Thus there is a resource (s) requiring strictly less usage in realising G(cid:17)(cid:17) in comparison with realising {gs} and noresource requires strictly greater usage. In total these properties indicate that (cid:12)Γ (cid:17), Ag, {gs}(cid:13) is a positive instance ofco-RPOGS.We note that the CRG, Γ (cid:17), constructed in this reduction is not (necessarily) binary if Γ is. We may deduce strong NP-hardness for co-RPOGS by observing that (when Γ is binary) we may represent en(cid:17) and req(cid:17) in unary whilst retainingthe polynomial-time bound on the reduction: the only non-binary element in Γ (cid:17) arises in the form of req(cid:17)(gs, r) forr (cid:18)= s. This, however, is req(G, r), which when Γ is binary is at most |G|. Hence, were co-RPOGS efficiently decidableusing unary representation, our reduction would give an efficient decision procedure for deciding GCS restricted tobinary CRGs. (cid:2)M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–8718513.3. Problems relating to resource bounds and resource conflictsSo far, we have said nothing about resource bounds: whether it is possible for a coalition to achieve a particular setof goals using at most a given amount of each resource.A resource bound is a function b : R → N, with the intended interpretation that if b(r) = k, then only k units ofresource r are available in total, for all coalitions. As with CRGs in general, we say a resource bound is binary if thebound for every resource is either zero or one. We say a goal set G(cid:17) respects a resource bound b (with respect tosome given CRG) if the total amount of every resource required to achieve all goals in G(cid:17) is less than or equal to theassociated bound for that resource. We define a two place predicate respects(G(cid:17), b) to capture this idea.(cid:17)respects(G, b)(cid:17)iff ∀r ∈ R, req(G, r) (cid:2) b(r)The obvious decision problem, corresponding to SUCCESSFUL COALITION is as follows.SUCCESSFUL COALITION WITH RESOURCE BOUND: (SCRB)Instance: CRG Γ , coalition C, and resource bound b.Answer: “Yes” if ∃G(cid:17) ∈ sf (C) s.t. respects(G(cid:17), b).Example 7. With reference to the CRG Γ1 of Example 1, consider resource bounds b1, where b1(r1) = 3 and b1(r2) =2, and b2, where b2(r1) = 2 and b2(r2) = 2. Then coalition C5 is successful with respect to b1 but not b2.Theorem 8. SUCCESSFUL COALITION WITH RESOURCE BOUND is NP-complete, even for binary CRGs and resourcebounds, and hence SUCCESSFUL COALITION WITH RESOURCE BOUND is strongly NP-complete.Proof. Almost identical to that of Theorem 1. The membership argument is basically the same: verifying the addi-tional constraint (that respects(G(cid:17), b)) can clearly be done in polynomial time. For NP-hardness, the same reductionfrom SAT used in Theorem 1 works—in the instance of SCRB that we create, we set the resource bound to be 1, forevery resource. Notice that both the CRG and the resource bound that we create in this reduction are binary, givingstrong NP-completeness as claimed. (cid:2)Resource contention—when two agents or coalitions desire to use some resource that cannot be used by both—isperhaps the paradigm source of conflict in real and artificial social systems. Resource contention is a classic problemin distributed and concurrent systems, for example where an operating system must enforce mutual exclusion overresources such as memory, printers, and communication channels [2, p. 15]. And of course, the problem remainsin multi-agent systems, where the resources in question are typically more complex artifacts. In our framework, weconsider conflicts between sets of coalitions with respect to some resource bound.First, let us say that two goal sets over some CRG are in conflict with respect to some resource bound if the goalsets are individually achievable within this bound, and yet are not jointly achievable within it. We define a three placepredicate cgs(. . .), where cgs(G1, G2, b) is intended to mean that goal sets G1 and G2 are in conflict with respect toresource bound b.cgs(G1, G2, b)iff(cid:7)(cid:7)(cid:8)respects(G1, b) and respects(G2, b)(cid:8)and not respects(G1 ∪ G2, b).Notice that the predicate cgs(· · ·) can of course be computed in polynomial time. Given this predicate, we can definewhat it means for two coalitions to be in conflict. We will say two coalitions are in conflict with respect to some givenresource bound if there is no way that they can both be satisfied and jointly respect the resource bound. The decisionproblem is as follows.CONFLICTING COALITIONS: (CC)Instance: CRG Γ , coalitions C1, C2, and resource bound b.Answer: “Yes” if ∀G1 ∈ sf (C1), ∀G2 ∈ sf (C2), we have cgs(G1, G2, b).Theorem 9. CC is co-NP-complete, even for binary CRGs, and hence CC is strongly co-NP-complete.852M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871Proof. Membership in co-NP is immediate from the fact that an instance (cid:12)Γ, C1, C2, b(cid:13) is accepted if and only if∀G1, G2 ⊆ G(cid:8)(cid:7)G1 ∈ sf (C1) and G2 ∈ sf (C2)⇒ cgs(G1, G2, b)To see that CC is co-NP-hard, consider the complement problem in which an instance (cid:12)Γ, C1, C2, b(cid:13) is accepted if andonly if∃G1, G2 ⊆ G(cid:7)G1 ∈ sf (C1) and G2 ∈ sf (C2) and(cid:7)∀r ∈ R req(G1 ∪ G2, r) (cid:2) b(r)(cid:8)(cid:8)That this problem is NP-hard, is a trivial reduction from SCRB: given an instance (cid:12)Γ, C, b(cid:13) of the latter, simply formthe instance (cid:12)Γ, C, C, b(cid:13). If (cid:12)Γ, C, b(cid:13) is accepted as an instance of SCRB, via some goal set G(cid:17), then G1 = G2 = G(cid:17)satisfies(cid:7)(cid:8)(cid:8)G1 ∈ sf (C) and G2 ∈ sf (C) and(cid:7)∀r ∈ R req(G1 ∪ G2, r) (cid:2) b(r)On the other hand if there are sets G1, G2 in sf (C) for which every r ∈ R has req(G1 ∪ G2, r) (cid:2) b(r) thenreq(G1, r) (cid:2) b(r) and thus (cid:12)Γ, C, b(cid:13) is accepted as an instance of SCRB. It follows that the complementary prob-lem to CC is NP-hard and hence CC is co-NP-hard. (cid:2)3.4. Positive resultsAlthough the results above indicate that decision problems involving questions about coalitional properties in CRGstend to be hard, in the case of questions about properties of goal sets it is possible to find efficient algorithmic solutions.For example, consider the problem,POTENTIAL GOAL SET: (PGS)Instance: CRG Γ , and set of goals G(cid:17).Answer: “Yes” if ∃C ⊆ Ag: G(cid:17) ∈ sf (C).Theorem 10. PGS is polynomial-time decidable.Proof. Given Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) and G(cid:17) ⊆ G, consider the coalition, Cmax ⊆ Ag defined as(cid:18)Cmax ={ai: g ∈ Gi}g∈G(cid:17)If G(cid:17) ∈ sf (D) for some D ⊆ Ag, then it must be the case that D ⊆ Cmax: for every aj /∈ Cmax we have Gj ∩ G(cid:17) = ∅,hence D (cid:18)⊆ Cmax is inconsistent with G(cid:17) ∈ sf (D). It follows that in order to decide if (cid:12)Γ, G(cid:17)(cid:13) should be accepted itsuffices to test if G(cid:17) ∈ sf (Cmax), i.e., if for every r ∈ R, we have en(Cmax, r) (cid:2) req(G(cid:17), r). These tests can clearly beperformed in polynomial-time. (cid:2)We can, in fact, obtain a rather stronger result, indicating that PGS is decidable by an efficient parallel algorithm.Theorem 11. PGS ∈ NC1, i.e., there is a uniform family of N -input Boolean combinational logic networks,4 (cid:12)SN (cid:13)which: given an instance of PGS encoded as a binary N -tuple, SN returns (cid:6) if and only if the instance should beaccepted; the size of SN is polynomially-bounded (as a function of N ); and the (parallel) run-time of SN is O(log N).5Proof. The result follows directly from the translation given in proving Theorem 14. The details are presented fol-lowing this. (cid:2)4 A family of N -input Boolean combinational logic networks is uniform if there is a polynomial-time Turing machine program that given 1N asinput constructs the encoding of the N th member of the family.5 The formal definition of “parallel run-time” is as the “depth” of the combinational logic network, see, e.g. [11, p. 20].M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–8718534. CRGs and QCGsIn this section, we consider the relationship between CRGs, as introduced in this paper, and QCGs, as introduced in[47].6 Recall that a QCG is a structureQ = (cid:12)G, Ag, G1, . . . , Gn, Ψ (cid:13)in which the Ag, G, and Gi components have exactly the same intended interpretation as in CRGs, and Ψ is a formulaof propositional logic, which represents the characteristic function of the game. The characteristic function of a QCGcaptures the different ways in which coalitions in the game can cooperate, and in particular, the different sets of goalsthat coalitions can bring about. More precisely, Ψ is a formula of propositional logic over two sets of propositionalvariables, corresponding to agents and goals, respectively. The idea is that Ψ [C, G(cid:17)] = (cid:6) iff the goal set G(cid:17) ⊆ G isa feasible choice for coalition C ⊆ Ag, that is, if one of the ways that coalition C can cooperate will result in all thegoals G(cid:17) being achieved.4.1. CRG-QCG equivalence: basic definitions and complexityWe say that a CRG Γ and a QCG Q are comparable if their Ag, G, and Gi components are the same, i.e., if theycontain the same agents and possible goal sets, and the goal sets associated with each agent are the same in both. Inthe decision problems that follow, in which we compare CRGs and QCGs, we will assume that unless explicitly statedotherwise, the CRG and QCG in question are comparable.The first obvious formal question to ask is, given a comparable CRG and QCG, whether the two are equivalent, in thesense that they agree on the choices available to coalitions. Formally, given a CRG Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13)and QCG Q = (cid:12)G, Ag, G1, . . . , Gn, Ψ (cid:13), we say that they are C, G(cid:17)-equivalent if(cid:17)] = (cid:6)(cid:22)G(cid:19)(cid:17) ∈ feas(C)(cid:22)(cid:20)(cid:21)CRGiff Ψ [C, G(cid:20)(cid:21)(cid:19)QCGWe indicate that CRG Γ and QCG Q are C, G(cid:17) equivalent by writing Γ ≡C,G(cid:17) Q. We simply write Γ ≡ Q to indicatethat Γ ≡C,G(cid:17) Q for all C ⊆ Ag, G(cid:17) ⊆ G. We now come to the first decision problem that relates CRGs to QCGs.EQUIVALENCE: (EQUIV)Instance: CRG Γ and QCG Q.Answer: “Yes” if Γ ≡ Q.Theorem 12. EQUIVALENCE is co-NP-complete, even for binary CRGs, and hence EQUIVALENCE is strongly co-NP-complete.Proof. Membership of co-NP follows from the fact that the following algorithm decides the problem:(1) Universally select each C ⊆ Ag and G(cid:17) ⊆ G.(2) Check that Γ ≡C,G(cid:17) Q.To establish that the problem is co-NP-hard, we reduce from TAUT, the problem of determining whether a givenformula Φ(x1, . . . , xn) of propositional logic is satisfied by every valuation of its propositional variables. Given aninstance Φ(x1, . . . , xn) of this, we form an instance of EQUIV as follows. First, let Ag = {x1, . . . , xn}, i.e., we createan agent for each propositional variable. We then create a single “dummy” goal and set G = {gdummy} and Gi = G forall i ∈ Ag.6 For completeness, we give the relevant technical definitions relating to QCGs, but our presentation is brief, and in particular we do not reproduceany of the motivating discussion from [47].854M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871For the CRG ΓΦ that forms part of the instance of EQUIV, we define a single resource R = {rdummy}, and letreq(gdummy, rdummy) = 1; we then define en(i, rdummy) = 1, for each agent i ∈ Ag. We note that this constructionsatisfies(cid:6)feas(C) ={{gdummy}, ∅}{∅}if C (cid:18)= ∅if C = ∅Finally, for the QCG instance QΦ we create, we define the characteristic function formula Ψ by(cid:23)(cid:24)Ψ (x1, . . . , xn, gdummy) = Φ(x1, . . . , xk) ∧¬gdummy ∨n(cid:15)xii=1We now claim that Φ(x1, . . . , xn) is a tautology if and only if ΓΦ ≡ QΦ .(⇒) Assume Φ(x1, . . . , xn) is a tautology; then⎧⎨(cid:6) if C (cid:18)= ∅(cid:6) if C = ∅ and G(cid:17) = ∅⊥ if C = ∅ and G(cid:17) (cid:18)= ∅⎩Ψ [C, G(cid:17)] =From which it follows that G(cid:17) ∈ feas(C) (for the CRG ΓΦ ) if and only if Ψ [C, G(cid:17)] = (cid:6) (in the QCG QΦ ). That is,if Φ(x1, . . . , xn) is a positive instance of TAUT then ΓΦ ≡ QΦ .(⇐) Assume ΓΦ ≡ QΦ . Then for all G(cid:17) ⊆ G, C ⊆ Ag, we have G(cid:17) ∈ feas(C) if and only if Φ[C, G(cid:17)] = (cid:6). By theconstruction we have G(cid:17) ∈ feas(C) for G(cid:17) = {gdummy} and C any non-empty subset of Ag. Similarly G(cid:17) ∈ feas(∅)for G(cid:17) = ∅. From the construction Ψ [C, ∅] ≡ Φ[C], thus, since ∅ ∈ feas(C) from the assumption that ΓΦ ≡ QΦ ,we deduce that Φ[C] = (cid:6) for every choice of C, i.e., that Φ(x1, . . . , xn) is a tautology.Note that the CRGs produced in the reduction are binary, giving strong co-NP-completeness as claimed. (cid:2)This result suggests an obvious question: are CRGs and QCGs equivalent in expressive power? That is, can we“translate” an arbitrary CRG into an equivalent QCG, and vice versa? Thus, our main interest in subsequent subsectionsconcerns the following four questions:(1) Given a CRG, Γ , is there always a QCG, QΓ such that QΓ ≡ Γ ?(2) Given a QCG, Q, is there always a CRG, ΓQ such that ΓQ ≡ Q?(3) How “efficiently” can a given CRG be expressed as an equivalent QCG in those cases where such an equivalentstructure exists?(4) How “efficiently” can a given QCG be expressed as an equivalent CRG in those cases where such an equivalentstructure exists?The first two questions are answered by the following.Theorem 13. QCGs are strictly more expressive than CRGs. More precisely:(a) For every CRG Γ there exists a QCG QΓ such that Γ ≡ QΓ .(b) It is not the case that for every QCG Q there exists a CRG ΓQ such that ΓQ ≡ Q.Proof. The first part is proved in Theorem 14. For the second part, it suffices to note that any QCG corresponding toa given CRG must be coalition monotonic [47]. But as we noted in Section 2, there exist QCGs that do not have thisproperty, which hence have no equivalent CRG. (cid:2)4.2. Translating CRGs to QCGsTheorem 13 tells us that we can always translate a CRG into an equivalent QCG. Now CRGs and QCGs are basedon entirely different representations—in QCGs we use the propositional logic representation of a game’s characteristicM. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871855function, while we have no need of such a representation in CRGs, since the feasible choices available to a coalition areimplicit within the requirement and endowment functions. The fact that we can translate from CRGs to QCGs meansthat, in principle, when dealing with scenarios modelled by CRGs, we have a choice of representations available: wecan work with either the requirements and endowments representation of CRGs, or the propositional logic represen-tation of QCGs. The latter representation would make it possible to use the extensive technology of propositionallogic reasoning developed within AI when reasoning about CRGs. However, the fact that we can translate a CRG to anequivalent CRG does not imply that such a translation can be done efficiently. If the best translation we can find leadsto a propositional logic QCG representation that is (say) exponential in the size of the CRG, then the fact that we can inprinciple translate one to the other is likely to be of little practical value. Indeed, there is an “obvious” translation ofCRGS to QCGs which does indeed lead to an exponentially sized characteristic function formula. However, it turns outthat we can always do the translation efficiently. We prove in Theorem 14 that, not only is it the case that every CRGmay be described by an equivalent QCG, but also that this translation produces a QCG characteristic function formulathat has an O(b2t) overhead over the size of the original CRG, where b is the maximum number of bits required toencode the endowment and requirement values, and t is the number of resources.To make this precise, we first need to define our notions of “efficiency” and, in particular, the manner in whichthe “sizes” of CRGs and QCGs are captured. In what follows, recall that m = |G| is the number of goals n = |Ag| isthe number of agents, and t = |R| is the number of resources. Now, in both formalisms we have (cid:12)G, Ag, G1, . . . , Gn(cid:13)as elements in common, within CRGs the systems of feasible goal sets for coalitions are described via (cid:12)R, en, req(cid:13)and for QCGs via some propositional formula, Ψ over propositional variables Ag and G. For a CRG the significantcontributing factor is, therefore, the space required to encode the n × t matrix of endowments and the m × t matrix ofrequirements. Thus, how “efficiently” some system of feasible goal sets for coalitions is described within in a CRG isdetermined by two measures: t, the number of resources employed; and the number of bits used in representing thevalues en(a, r), req(g, r). For Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13), with |Ag| = n, |G| = m, and |R| = t, fixb = 1 +(cid:3)(cid:25)maxr∈R, a∈A, g∈G(cid:26)log2 en(a, r),(cid:25)(cid:26)(cid:4)log2 req(g, r)From which we may assume that each value of en(a, r), req(g, r) is represented in binary using exactly b bits.We can now define the size of a CRG, Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13), denoted M CRG(Γ ), as(cid:7)M CRG(Γ ) = b|R|(cid:8)|Ag| + |G|= bt (n + m)In contrast, for a representation via a QCG, we define the size of a QCG, Q, denoted M QCG(Q), as |Ψ |, i.e., thetotal number of occurrences of literals used in presenting the formula Ψ , where only binary Boolean operations andnegation may be used in forming Ψ . (Note that we consider some general issues respecting the measures M CRG andM QCG at the end of this sub-section.)Theorem 14. For every CRG, Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13), with |Ag| = n, |G| = m, and |R| = t, there existsa QCG, QΓ = (cid:12)G, Ag, G1, . . . , Gn, Ψ (cid:13) such that Γ ≡ QΓ and for which(cid:8)(cid:7)M CRG(Γ )(cid:8)(cid:7)bt (n + m + b)|Ψ | = O(cid:7)b2t= O+ O(cid:8)Proof. The proof is constructive. Given Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) we form an equivalent QCG, QΓ , asfollows. Since Ag, G, and (cid:12)G1, . . . , Gm(cid:13) are the same sets in Γ and QΓ , the major part of the construction is concernedwith building the formula Ψ within QΓ so that for C ⊆ Ag, and G(cid:17) ⊆ G, we have G(cid:17) ∈ feas(C) if and only ifΨ [C, G(cid:17)] = (cid:6).The formula Ψ comprises t sub-formulae, Φk(Ag, G) where 1 (cid:2) k (cid:2) t, there being one such formula for eachdistinct resource rk ∈ R. The formula Ψ is formed from these, viaΨ =t(cid:5)k=1Φk(Ag, G)856M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871The role of the sub-formula Φk(Ag, G) is to describe the conditions under which for C ⊆ Ag, and G(cid:17) ⊆ G, the coalitionC has a sufficient endowment of the resource rk to satisfy the total requirement of this needed to realise G(cid:17). In otherwords, Φk(Ag, G) will be such thatΦk[C, G(cid:17)] = (cid:6) ⇔en(ai, rk) (cid:3)req(gj , rk)(cid:2)(cid:2)ai ∈Cgj ∈G(cid:17)Recalling that the values en(ai, rk) and req(gj , rk) can be represented using exactly b bits, Φk(Ag, G) can be consid-ered as a formula having b × (n + m) arguments,Xk1, Xk2, Xk3, . . . , Xkn, Y k1 , Y k2 , . . . , Y km(cid:9)with(cid:9)(cid:10)(cid:10)(cid:9)==XkiY kji,b−1, xkxkj,b−1, ykyki,b−2, . . . , xkj,b−2, . . . , ykOf course, in order to implement Ψ , each of these xkvalue.i,1, xki,0j,1, ykj,0(cid:10)i,p and ykj,q must be specified as some a ∈ A, g ∈ G, or a constantSuppose that the b-bit binary representation of en(ai, rk) is ekj,b−1d kd kj,b−2 . . . d kj,0. So thaten(ai, rk) =(cid:7)eki,p(cid:8);× 2preq(gj , rk) =b−1(cid:2)(cid:7)d kj,qq=0(cid:8)× 2qj,1d kb−1(cid:2)p=0i,b−1eki,b−2 . . . eki,1eki,0 and that of req(gj , rk) isFor the formula Φk(Ag, G) the appropriate substitutions are given by(cid:27)xki,p:=ykj,q:=(cid:27)ai0gj0if eki,pif eki,pif d kj,qif d kj,q= 1= 0= 1= 0The sub-formula Φk(Ag, G) contains three separate parts:1. Endowk(Xk1, Xk2, . . . , Xkn) which computes ukz−1ukz−2 . . . uk1uk0 the z = (b + 1 + (cid:26)log2(nm)(cid:27))-bit binary represen-tation resulting by adding the n b-bit binary values described by the instantiation of (cid:12)Xk2. Requirek(Y k1 , Y k2 , . . . , Y km) which computes vkz−1vkz−2 . . . vk1vk0 the z = (1 + b + (cid:26)log2(nm)(cid:27))-bit binary represen-tation resulting by adding the m b-bit binary values described by the instantiation of (cid:12)Y k1, Xk2, . . . , Xkn(cid:13).1 , Y k2 , . . . , Y km(cid:13).3. Comparek(ukz−1, . . . , vk0) which returns the value (cid:6) if and only if0, vkz−1, . . . , ukz−1(cid:2)(cid:7)vkl× 2l(cid:3)(cid:8)l=0(cid:7)uklz−1(cid:2)l=0(cid:8)× 2l(cid:29)(cid:28)tBefore analysing the size of the formula Ψ =k=1 Φk(Ag, G) we first establish the correctness of our construction.(cid:29)For this it suffices to show that Φk[C, G(cid:17)] = (cid:6) if and only ifgj ∈G(cid:17) req(gj , rk). Thus considerany C ⊆ Ag and G(cid:17) ⊆ G. For the substitutions of xki,p by ai or 0, and of ykj,q by gj or 0 described above we see thatthe following holds of Φk[C, G(cid:17)]. If ai /∈ C then Xki is the b-bit representation of the value 0: ai does not contributeanything to satisfying the total requirement for rk. On the other hand, if ai ∈ C, then Xki is the b-bit representationof the value en(ai, rk). Similarly, if gj /∈ G(cid:17) then Y kj is the b-bit representation of the value 0; if gj ∈ G(cid:17) then Y kjis the b-bit representation of the value req(gj , rk). It follows that the value computed by Endowk[C, G(cid:17)] is exactly(cid:29)ai ∈C en(ai, rk) (with z bits sufficing to represent this value in binary). In the same way, the value computed byai ∈C en(ai, rk) (cid:3)M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871857gj ∈G(cid:17) req(gj , rk) (again with z bits sufficing to represent this value in binary). In total,(cid:29)[C, G(cid:17)] is exactlyRequirekfrom the description of Comparek() this yields(cid:17)] = Comparek(cid:30) (cid:2)(cid:7)Endowk[C, G(cid:2)Φk[C, G(cid:8)(cid:17)](cid:17)], Requirek[C, G(cid:31)=en(ai, rk) (cid:3)req(gj , rk)gj ∈G(cid:17)ai ∈C(cid:28)tThus the formula Ψ =the CRG, Γ .Regarding the size of this formula, it is clear that |Ψ | equalsk=1 Φk(Ag, G) correctly describes the feasible goal sets (G(cid:17)) for each coalition (C) within Φk(Ag, G) (cid:2) t × Compare1(cid:7)Endow1(Ag, G), Require1(Ag, G)(cid:8) t(cid:2)k=1The formulae Endow1(Ag, G) and Require1(Ag, G) implement addition of n (respectively m) b-bit values, eachreturning the answer using z bits. Formulae of size O(nb) and O(mb) for these operations are described in [21],see e.g., [11, p. 115]. Finally, the formula Compare1() involves 2 sets of z arguments, (cid:12)u1(cid:13) and(cid:12)v1(cid:13), returning the answer (cid:6) if and only ifz−2, . . . , u1z−1, u11, u10z−2, . . . , v11, v10z−1, v1z−1(cid:2)(cid:7)u1p(cid:8)(cid:3)× 2pz−1(cid:2)(cid:7)v1p(cid:8)× 2pp=0p=0This holds if and only if one of the following is true:(1) For each 0 (cid:2) p (cid:2) z − 1, u1= v1p, i.e., Endow1(Ag, G) = Require1(Ag, G)p(2) There is an index (l) for which u1l= 0, and for each l + 1 (cid:2) p (cid:2) z − 1 u1p= 1, v1lRequire1(Ag, G).= v1p, i.e., Endow1(Ag, G) >These conditions are described by the formula(cid:24)(cid:8)z−1(cid:15)z−1(cid:5)(cid:23)(cid:23)(cid:8)(cid:7)u1p≡ v1p∨(cid:7)¬v1l∧u1l∧(cid:24)(cid:8)z−1(cid:5)(cid:7)u1p≡ v1pp=0l=0p=l+1An easy analysis showing this to have size O(z2) and thus Compare1() can be realised in size O(b2 + (log n)2 +(log m)2). In total Ψ has size O(t (bn + bm + b2 + (log n)2 + (log m)2)) giving the bound O(bt (n + m + b)), via theobservations (log n)2 = o(n) and (log m)2 = o(m). (cid:2)Using the construction in the proof of Theorem 14 we can now establish that PGS ∈ NC1, i.e., present theProof of Theorem 11. Recall that an instance of PGS consists of a CRG, Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) to-gether with a subset G(cid:17) of G, with the instance accepted if there is some coalition C ⊆ Ag for which G(cid:17) ∈ sf (C).Consider the propositional formula, ΨΓ , constructed in the proof of Theorem 14. The sub-formula, Φk(Ag, G),was initially described as having n + m “blocks” of b propositional arguments—Xkj (with1 (cid:2) j (cid:2) m)—with the individual arguments in each block being set to constant values or propositional variables: ai(for Xkj ). In order to obtain an NC1 algorithm for PGS, we modify the mechanism used to replace thevariables Xki : the substitution of variables in G for variables in Y ki (with 1 (cid:2) i (cid:2) n) and Y ki ), gj (for Y kj remains unaltered.· · · eki,0. The variable xki,1eki,p of Xki is replaced by theSuppose the b-bit representation of en(ai, rk) is eki,b−1eki,b−1formula:xki,p:=(cid:27) !g∈Gi0g if eki,pif eki,p= 1= 0  858M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871Let ΨPGS(G) (which is defined solely in terms of propositional variables G) be the resulting formula. Choose anyG(cid:17) ⊆ G and consider ΨPGS[G(cid:17)]. The b-bit value described by Xki will be en(ai, rk) if G(cid:17) ∩ Gi (cid:18)= ∅ and 0 otherwise.It follows, from the analysis in Theorem 14, that ΨPGS[G(cid:17)] will output (cid:6) if and only if:(cid:17)∀r ∈ R en(Cmax, r) (cid:3) req(G, r)where Cmax = {ai: Gi ∩ G(cid:17) (cid:18)= ∅}. As we observed in the proof of Theorem 10, if C ⊆ Ag is such that G(cid:17) ∈ sf (C), thenit must be the case that C ⊆ Cmax, and this suffices to establish the correctness of ΨPGS(G). To complete the proofthat PGS ∈ NC1, first observe that |ΨPGS(G)| is polynomially-bounded in, N , the number of bits required to encodean instance of PGS. Since ΨPGS is a propositional formula, using the standard construction of [5], (described in [11,pp. 68–69]) yields a parallel algorithm with run-time O(log |ΨPGS|) = O(log N). (cid:2)4.3. Translating QCGs to CRGsNext, we consider the more difficult issue of translating QCGs to CRGs. We know from Theorem 13 that there areQCGs for which no equivalent CRG exists. This raises the question of exactly what conditions characterise QCGs thatdo have an equivalent CRG. Our next results give a partial characterisation of those QCGs for which an equivalent CRGexists:• First, Theorem 15 gives four necessary conditions on QCGs for the existence of an equivalent CRG. Intuitively,these conditions state that (i) monotonically increasing coalitions have monotonically increasing feasible goalsets; (ii) if a coalition can choose a goal set G(cid:17), then that coalition can choose every subset of G(cid:17); (iii) the emptycoalition has no choices; and (iv) disjoint coalitions have superadditive choices—they can achieve everythingtogether that they could achieve apart.7• Second, Theorem 16 defines some sufficient conditions on QCGs for the existence of an equivalent CRG. Roughly,these conditions state that equivalent CRGs exist for QCGs with characterictic function formulae corresponding tocertain types of monotonic Boolean functions.• Third, Theorem 17(a–c) establishes three properties regarding the relative efficiency of describing characteristicfunctions via QCGs and CRGs: that the size of a QCG need be (at worst) only quadratically larger than the size of anequivalent CRG; that there are instances for which CRG representations are possible, but any such representationis exponentially larger than a minimal equivalent QCG; and, finally, that there are instances for which the smallestQCG representation has size exponential in the number of goals, (and thus, an equivalent CRG is also exponentialsize).First, then, we will give some necessary conditions on QCGs for the existence of an equivalent CRG.We start by recalling that the abstraction underlying both the concepts of CRGs and QCGs concerns the relationshipbetween subsets of Ag (i.e., coalitions, C) and sets of goals, G(cid:17), deemed as “feasible” for these. Thus the fundamentalconstructs being modelled are mappingsF : 2Ag → 22Gassociating each C ⊆ Ag with a set of subsets of G: the sets of goals that are feasible for C.The formalism provided by QCGs is based on the observation that F can be viewed as a propositional logic functionvia its characteristic function χF (Ag, G), and therefore, using a propositional formula Ψ for which Ψ [C, G(cid:17)] = (cid:6) ifand only if χF [C, G(cid:17)] = (cid:6) obviates any need explicitly to enumerate F(C) for each C ⊆ Ag in order to describe F .The formalism offered by CRGs takes a rather different approach arising from the fact that for some F we cancharacterise each of the sets F(C) in terms of some choice, (cid:12)R, en, req(cid:13), of resources, agent endowments, and goalrequirements, so that F is effectively described, not by a propositional logic formula, but through two matrices whosevalues are whole numbers, i.e., the n × t matrix of agent endowments, and the m × t matrix of goal requirements. Ofcourse while it is self-evident that every system F can be modelled by a QCG, in consequence of Theorem 13(b) thereare systems that cannot be described by a CRG. This motivates the following definition,7 Readers with an interest in cooperation logics may wish to note that this last condition is essentially the same as axiom S in Pauly’s CoalitionLogic [30, p. 54], which in turn follows from the superadditivity property of playable games [30, p. 30].M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871859Definition 2. We say that the system F : 2Ag → 22G(cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) in which for all C ⊆ Ag and G(cid:17) ⊆ G,(cid:7)(cid:17)∀r ∈ R en(C, r) (cid:3) req(G(cid:8), r)(cid:7)G(cid:8)(cid:17) ∈ F(C)⇔is resource definable for (cid:12)Ag, G(cid:13) if there is a CRG, Γ =Over the next series of results we describe some sufficient conditions for F to be resource definable. These areexpressed in terms of properties of the characteristic function χF (Ag, G).Theorem 15. Let F ∈ {2Ag → 22G}. The system F is resource definable for (cid:12)Ag, G(cid:13) only if it satisfies all of thefollowing conditions.(C1) F is coalition monotonic, that is:(cid:7)C ⊆ D and G(cid:8)(cid:17) ∈ F(C)⇒ G(cid:17) ∈ F(D)(C2) F is goal anti-monotonic, that is:(cid:8)(cid:17) ∈ F(C)(cid:17)(cid:17) ⊆ G(cid:17) and G(cid:7)G⇒ G(cid:17)(cid:17) ∈ F(C)(C3) F(∅) = {∅}.(C4) F is superadditive, in the sense that if C ∩ D = ∅ and both G(cid:17) ∈ F(C), G(cid:17)(cid:17) ∈ F(D) then G(cid:17) ∪ G(cid:17)(cid:17) ∈ F(C ∪ D).Proof. Both (C1) and (C2) are trivial consequences of our formulation of CRG. (C3) is immediate from the factthat given any resource r in a CRG, en(∅, r) = 0 and req(∅, r) = 0. Finally, that (C4) must also hold of F followsfrom the observation that in any CRG, Γ , should en(C, r) (cid:3) req(G(cid:17), r) and en(D, r) (cid:3) req(G(cid:17)(cid:17), r) and C ∩ D = ∅,then C’s expenditure of r in realising G(cid:17)(cid:17) does not affect the quantity of resource r that is available to D, henceen(C ∪ D, r) (cid:3) req(G(cid:17) ∪ G(cid:17)(cid:17), r). (cid:2)We make two initial observations concerning the statement of this theorem. Firstly, we note the form of condition(C3): F(∅) = {∅} rather than ∅ ∈ F(∅). The latter would allow the possibility for non-empty G(cid:17) ⊆ G to be feasiblefor the empty coalition of agents, however such would arise only in the event of there being goals, g ∈ G for whichreq(g, r) = 0 for each r. As mentioned in our introductory formulation of CRGs we are assuming that “trivial” goalsof this nature are not present. It follows that the only goal set which is feasible for C = ∅ is G(cid:17) = ∅.As a second point, we note that G ∈ F(Ag) is not a necessary condition for a system to be resource definable asthe following simple example shows. Let(cid:9)(cid:10){g1, g2}, {a}, {g1, g2}, Ψ (a, g1, g2)Q =whereΨ (a, g1, g2) ≡ (¬g1)(¬g2) ∨ a(¬g1 ∨ ¬g2)An equivalent CRG, ΓQ is formed using R = {r1}, en(a, r1) = 1, req(g1, r1) = req(g2, r1) = 1. For these we haveΨ [a, {g1, g2}] = ⊥, however each of the three feasible sets for a, i.e., {∅, {g1}, {g2}} in Q is also a feasible set for ain ΓQ. Similarly, {g1, g2} is not a feasible set for a in ΓQ.In order to state some sufficient conditions, we must first recall some basic definitions and results concerning theclass of monotone propositional functions.Definition 3. Let Xn = {x1, . . . , xn} be set of n propositional variables. Given two propositional functions f (Xn) andg(Xn), we write f (cid:2) g if for all Y ⊆ Xn it holds that f [Y ] (cid:2) g[Y ], where the ordering of constant values is ⊥ < (cid:6).The function f (Xn) is monotone increasing if∀Y ⊂ Z ⊆ Xn f [Y ] (cid:2) f [Z]Similarly, f (Xn) is monotone decreasing if∀Y ⊂ Z ⊆ Xn f [Z] (cid:2) f [Y ]860M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871Fact 4. f (x1, . . . , xn) is monotone increasing(a) if and only if there is a unique setP(f ) = {P1, P2, . . . , Pk} ⊂ 2Xnfor which (Pi ⊆ Pj ) ⇔ (i = j ) and with(cid:5)k(cid:15)f (Xn) ≡xji=1We call P(f ) the product set for f .xj ∈Pi(b) if and only if there is a unique setQ(f ) = {Q1, Q2, . . . , Ql} ⊂ 2Xnfor which (Qi ⊆ Qj ) ⇔ (i = j ) and with(cid:15)l(cid:5)f (Xn) ≡xji=1We call Q(f ) the clause set for f .xj ∈Qi(c) if and only if f (x1, . . . , xn) ∈ {(cid:6), ⊥} (i.e., f is a constant function) or there is a propositional formula,Ψ (x1, . . . , xn), employing only the binary operations {∧, ∨} (i.e., negation, ¬, is not used in Ψ ) for which fΨ ,the propositional function represented by Ψ , is equivalent to f .(d) if and only if f (¬x1, . . . , ¬xn) is a monotone decreasing propositional function of {x1, . . . , xn}.For proofs of these properties the reader is referred to any standard monograph on Boolean function complexity,e.g., [11, pp. 15–17].We need a minor development of the ideas described in Definition 3 and Fact 4 to capture the concept of a propo-sitional function being monotone (increasing or decreasing) with respect to a subset of its arguments.We say that a propositional formula Ψ (Xn) is in standard form if Ψ is defined using the binary operations {∧, ∨}and unary negation (¬) with ¬ applied only to propositional variables, e.g., (¬x1 ∨ x2) is in standard form, however,its equivalent ¬(x1 ∧ ¬x2) is not. It is well-known that every propositional function can be represented by a formulain standard form.8 It is also the case that any formula, Φ (defined using binary operations) may be translated to anequivalent one, Ψ , with the latter in standard form and having |Ψ (Xn)| = O(|Φ(Xn)|2+c) (where c < 0.1 is a constantvalue), cf. the construction presented in [31].Definition 5. Let f (Xn) be a propositional function and Y a subset of Xn. We say that f is monotone increasing withrespect to the subset Y if for every Z ⊆ Xn \ Yf [Z ∪ U ] (cid:2) f [Z ∪ W ]∀U ⊂ W ⊆ YSimilarly, f is monotone decreasing with respect to the subset Y if for every Z ⊆ Xn \ Y∀U ⊂ W ⊆ Yf [Z ∪ W ] (cid:2) f [Z ∪ U ]It is straightforward to obtain the following development of Fact 4.Fact 6.(a) f (Xn) is monotone increasing with respect to a subset Y of Xn if and only if there is a propositional formulaΨ (Y, Xn \ Y ) in standard form with unary negation applied only to variables in Xn \ Y and for which fΨ (Xn)—thepropositional function represented by Ψ —is equivalent to f (Xn).8 For example, representations of propositional functions using CNF or DNF are examples of “standard form” formulae.M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871861(b) f (Xn) is monotone decreasing with respect to a subset Y of Xn if and only if there is a propositional formulaΨ (Y, Xn \ Y ) in standard form with no variables in Y occurring in positive (i.e., un-negated) form within Ψ andfor which fΨ (Xn)—the propositional function represented by Ψ —is equivalent to f (Xn).(c) f (Xn) is monotone increasing with respect to a subset Y and monotone decreasing with respect to the subsetXn \ Y if and only if there is a propositional formula Ψ (Y, Xn \ Y ) in standard form with no variable in Yoccurring in negated form and no variable in Xn \ Y occurring in positive (i.e., un-negated) form and for whichfΨ (Xn)—the propositional function represented by Ψ —is equivalent to f (Xn).Combining Fact 4(a–b) with Fact 6(b) one consequence that results is that for monotone decreasing functionsf (Xn) the product (respectively, clause) sets P(f ) (respectively, Q(f )) will be defined by subsets of 2{¬x1,¬x2,...,¬xn},i.e., as sets of negated variables. This interpretation will prove useful subsequently.Given these definitions, the following result gives some sufficient conditions on QCGs for the existence of anequivalent CRG.Theorem 16. F is resource definable for (cid:12)Ag, G(cid:13) for both of the following cases.χF (Ag, G) ≡(cid:30) (cid:5)(cid:31)a∧ h(G) ∨(cid:30) (cid:5)(cid:31)¬gwhere h(G) is any monotone decreasing function of G with h[∅] = (cid:6).a∈Agg∈G(cid:30) (cid:5)(cid:31)χF (Ag, G) ≡ f (Ag) ∨¬g(a)(b)where f (Ag) is any monotone increasing function of Ag with f [∅] = ⊥.g∈GProof. Our proof is constructive. We show how F may be translated to (cid:12)R, en, req(cid:13) in such a way that(cid:7)(cid:17)∀r ∈ R en(C, r) (cid:3) req(G(cid:17)] ≡ (cid:6) ⇔χF [C, G(cid:8), r)For part (a), with |Ag| = n, let F ∈ {2Ag → 22G} be such that(cid:31)(cid:31)(cid:30) (cid:5)(cid:30) (cid:5)χF (Ag, G) ≡a∧ h(G) ∨¬ga∈Agg∈Gwhere h[∅] = (cid:6) and h(G) is a monotone decreasing function of G. We define (cid:12)R, en, req(cid:13) so that χF [C, G(cid:17)] = (cid:6) ifand only if for each r ∈ R, en(C, r) (cid:3) req(G(cid:17), r). LetQ(h) = {E1, E2, . . . , Ep}be the (unique) set of subsets of {¬g1, . . . , ¬gm} defining the clause set of h.We call a set of goals, S ⊆ G a forbidden goal set if there is some E ∈ Q(h) for which{¬g: g ∈ S} = EIf S is any forbidden set (or a superset of such a set) it is certainly the case that χF [Ag, S] = ⊥ since there is someEi ∈ Q(h) for which(cid:30) (cid:15)(cid:31)h[S] ≡ Ei[S] ≡¬gj[S] ≡ ⊥¬gj ∈EiIn addition, however, χF [Ag, T ] = (cid:6) for any strict subset T of S. For if we suppose that g ∈ S \ T , then Ei[T ] ≡(¬g)[T ] ≡ (cid:6), and from Fact 4(b), it follows that Ej [T ] = (cid:6) for every Ej : were Ej [T ] = ⊥ then this would implyEj ⊂ Ei .We now have a sufficient basis for constructing the required components (cid:12)R, en, req(cid:13).Associated with each gk ∈ G we have a resource, rg,k for whichen(ai, rg,k) = 1(cid:6)req(gj , rg,k) =n if j = kif j (cid:18)= k0862M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871These settings suffice to ensure that feas[C] = {∅} for every C ⊂ Ag since each gj requires exactly en(Ag, rg,j ) unitsof the resource rg,j to be expended.For each forbidden set S ⊆ G, there is a resource rS ∈ R, havingen(ai, rS) = |S| − 1(cid:6)req(gj , rS) =n if gj ∈ Sif gj /∈ S0We note that since h(G) (cid:18)≡ ⊥, every forbidden set has at least one element, i.e., the empty clause is not in the clauseset Q(h). Furthermore if Q(h) = ∅, then we have h[G] ≡ (cid:6), i.e., χF [Ag, G(cid:17)] = (cid:6) for every G(cid:17) ⊆ G. In this case,there are no forbidden set resources needed and the collection (cid:12)R, en, req(cid:13) with R = {rg,j : 1 (cid:2) j (cid:2) m} suffices toform an equivalent CRG.We now show that(cid:6)∀G(cid:17) ⊆ GχF [Ag, G(cid:17)] = (cid:6) ⇒ ∀r ∈ R en(Ag, r) (cid:3) req(G(cid:17), r)χF [Ag, G(cid:17)] = ⊥ ⇒ ∃r ∈ R en(Ag, r) < req(G(cid:17), r)Suppose first that χF [Ag, G(cid:17)] = ⊥. From our analysis we must have S ⊆ G(cid:17) for some forbidden set S, since h[G(cid:17)] = ⊥indicates that some Ej ∈ Q(h) evaluates to ⊥. Consider the resource rS . We have(cid:2)(cid:2)(cid:17)req(G, rS) =req(g, rS) =req(g, rS) = n|S|g∈G(cid:17)g∈SHowever, en(Ag, rS) = n(|S| − 1), and thus G(cid:17) /∈ feas(Ag).On the other hand, suppose that χF [Ag, G(cid:17)] = (cid:6). It is certainly the case that en(Ag, rg,k) (cid:3) req(G(cid:17), rg,k) for each1 (cid:2) k (cid:2) m: if gk /∈ G(cid:17) then req(G(cid:17), rg,k) = 0; if gk ∈ G(cid:17) then req(G(cid:17), rg,k) = n = en(Ag, rg,k).Since χF [Ag, G(cid:17)] = (cid:6) it must hold that G(cid:17) ⊂ S for every forbidden set S: in each E ∈ Q(h) there must be at leastone literal ¬gj for which gj /∈ G(cid:17). Consider any of the forbidden set resources rS ∈ R, then(cid:17)req(G, rS) =req(g, rS) (cid:2) n(cid:7)|S| − 1(cid:8)(cid:2)g∈G(cid:17)(since req(g, r) (cid:2) n for every g ∈ G and r ∈ R).Now, since en(Ag, rS) = n(|S| − 1) for all rS ∈ R, it follows that G(cid:17) ∈ feas(Ag). This completes the proof ofpart (a).For part (b), letχF (Ag, G) ≡ f (Ag) ∨(cid:30) (cid:5)(cid:31)¬gg∈Gwhere f (Ag) is any monotone increasing function of Ag with f [∅] = ⊥. We first observe that the class of QCGsdescribed may be viewed as indicating the minimal coalitions C that must form in order to bring about any non-emptyset of goals. For such C, with any (non-empty) subset G(cid:17) of G, χF [C, G(cid:17)] = (cid:6) but χF [D, G(cid:17)(cid:17)] = ⊥ for any D ⊂ Cand any non-empty G(cid:17)(cid:17) ⊆ G. In addition, χF [C, ∅] = (cid:6) for every C ⊆ Ag. Let Q(f ) = {E1, . . . , Ek} be the set ofsubsets of Ag defined by the clause set of f (Ag). Via the convention that the empty disjunction is equivalent to ⊥, iff (a1, . . . , an) ≡ ⊥ then Q(f ) = {∅}, i.e., Q(f ) contains exactly one set.We form an equivalent CRG as follows. For each clause E ∈ {E1, . . . , Ek} there is a corresponding resource rE ∈ R.For the resource rE,(cid:6)en(ai, rE) =m|E|0if ai ∈ Eif ai /∈ Ereq(gj , rE) = |E|We claim that(cid:6)∀C ⊆ AgχF [C, G] = (cid:6) ⇒ ∀r ∈ R en(C, r) (cid:3) req(G, r)χF [C, gj ] = ⊥ ⇒ ∃r ∈ R en(C, r) < req(gj , r)M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871863Thus, suppose that C ⊆ Ag is such that χF [C, G] = (cid:6). It must be the case that f [C] = (cid:6) and thus for each E ∈{E1, . . . , Ek} we have C ∩ E (cid:18)= ∅. From this property, for each rE ∈ R,en(C, rE) (cid:3) m|E| = req(G, rE)and hence G ∈ feas(C) for the CRG formed.On the other hand, suppose that χF [C, gj ] = ⊥. In this case we have f [C] = ⊥, implying that is at least oneE ∈ {E1, . . . , Ek} for which C ∩ E = ∅. Consider the resource rE ∈ R. For each gj ∈ G we have req(gj , rE) = |E|,however, since no member of C occurs in E, these can contribute nothing towards meeting the quantity of resourcerE needed, i.e.,(cid:2)en(C, rE) =en(ai, rE) = 0 < |E|ai ∈CIt follows that {gj } /∈ feas(C).This completes the proof that for any QCG of the form in the theorem statement, an equivalent CRG exists. (cid:2)Aside from the specialisation in the latter result, we note one significant difference in the respective constructionsof Theorem 14 and Theorem 16 is that in the former case the translation from CRGs to QCGs operates directly onthe sub-structure (cid:12)R, en, req(cid:13), whereas the latter does not operate on the particular propositional formula, but anequivalent representation whose structure is determined from the propositional function characterised by χF (Ag, G).This equivalent representation may, of course, be exponentially large in m.Next, we turn to the issue of how efficiently (or otherwise) a QCG may be translated to a CRG, given that such atranslation is possible. In order to develop these results, we need to extend our definitions of M QCG and M CRG. Thestarting point for these extensions is the observation that given a resource definable system F its representation aseither a QCG or CRG is not unique.We have introduced already a notion of “equivalence” between CRGs and QCGs. It is straightforward to formulatethe idea of two QCGs,Q = (cid:12)G, Ag, G1, . . . , Gn, Ψ (cid:13)Q(cid:17) = (cid:12)G, Ag, G1, . . . , Gn, Φ(cid:13)being equivalent simply by defining this to be the case if the propositional functions, fΨ and fΦ described by theformulae Ψ and Φ are equivalent.It follows that we may define equivalence between CRGs,Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13)Γ (cid:17) = (cid:12)Ag, G, R(cid:17), G1, . . . , Gn, en(cid:17), req(cid:17)(cid:13)via Γ is equivalent to Γ (cid:17) if and only if: for all C ⊆ Ag, G(cid:17) ⊆ GG(cid:17) ∈ feas(C) for the CRG Γ⇔G(cid:17) ∈ feas(C) for the CRG Γ (cid:17)In summary each resource definable F for (cid:12)Ag, G(cid:13) induces equivalence classes [F]QCG (respectively, [F]CRG) cor-responding to the QCGs (respectively, CRGs) that could be used to represent F .Having developed these concepts, we can now present the extensions of M QCG and M CRG (which were couchedin terms of specific representations Ψ , (cid:12)R, en, req(cid:13)), to measures defined on the equivalence classes of QCGs andCRGs arising via the definitions above. We will denote by μQCG(F) the size of the smallest QCG that is equivalent toF , and by μCRG(F) the smallest CRG that is equivalent to F . Formally,Definition 7. Let F be resource definable for (cid:12)Ag, G(cid:13). The measures, μQCG(F) and μCRG(F) are defined as,(cid:3)M QCG(Q): Q ∈ [F]QCGμQCG(F) = min(cid:4)(cid:3)M CRG(Γ ): Γ ∈ [F]CRGμCRG(F) = min(cid:4)864M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871One consequence of using the translation described in Theorem 16(b), in which there is a distinct resource rq foreach clause q ∈ Q(f ), is that the resulting CRG could be significantly larger than an “optimal” equivalent CRG. As avery simple example of such behaviour consider the following system involving n agents and a single goal, g,F MAJ(C) =(cid:6){g}∅if |C| (cid:3) n/2if |C| < n/2The system F MAJ is resource definable, as it corresponds to the propositional majority function MAJ(Ag) ∨ ¬g whereMAJ is the n-argument function whose value is (cid:6) if and only if at least n/2 of its arguments are assigned the value (cid:6):since this function is monotone (increasing), an equivalent CRG can be constructed using the process described in theproof of Theorem 16(b). The clause set, Q(MAJ) of MAJ, however, has Q(MAJ) =(cid:7)(cid:27) (cid:7)(cid:8)nn−22nn−12(cid:8)if n is evenif n is odd(cid:31)(cid:30)2n/2√n= (cid:12)and thus the CRG formed would have exponentially many resources, for a propositional function that has polynomialsize formulae, see, e.g. [11, p. 331].9 The system F MAJ, however, is easily captured by the CRG, Γ MAJ with agentset Ag, goals G = {g}, and a single resource, r, for whichreq(g, r) = (cid:29)n/2(cid:30)en(a, r) = 1 ∀a ∈ AgAlthough the translation from QCGs to CRGs can be extremely inefficient, there are nonetheless, cases of “simple”resource definable systems that can be represented by linear (in n + m) size propositional formulae but can only bedescribed by exponential size CRGs: an example of such a system is presented in Theorem 17(b).More generally this theorem gives us some upper and lower bounds on the size of the QCGs and CRGs for caseswhere they exist. In particular, we prove that:• for any resource definable F , the minimum size of the QCG representing F is no more than quadratically largerthan the size of the smallest CRG representing F (Theorem 17(a));• there are resource definable F for which a linear size QCG representation of F is possible, but for which thesmallest CRG representing F has size exponential in the number of agents (Theorem 17(b)); and• there are resource definable F for which the smallest QCG that represents F is of size exponential in the numberof goals in F (Theorem 17(c)).We observe that by combining Theorem 15 with the first two results above it follow that not only are QCGs moreexpressive than CRGs (Theorem 15) but, in addition, QCGs can be exponentially more succinct than the smallestequivalent CRG (Theorem 17(b)) while, at worst, only quadratically larger than the smallest equivalent CRG (Theo-rem 17(a)). Formally, we have the following.Theorem 17.(a) For all resource definable FμQCG(F) = O(cid:7)(cid:7)(cid:8)μCRG(F)(cid:8)2(b) There exist resource definable F for whichμQCG(F) = O(n)μCRG(F) = (cid:12)(cid:8)(cid:7)2n9 This holds even if the formula basis comprises only the operations, {∧, ∨} as has been demonstrated by the construction of Valiant [42]. M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871865(c) There exist resource definable F for which,μQCG(F) = (cid:12)(cid:30)(cid:31)2mlog m√mProof. (a) This is immediate from Theorem 14, noting that we have conservatively bounded the translation of bt (n +m) (used in the minimal size CRG) to O(bt (n + m + b)) (arising in the proof of Theorem 14) by over-compensatingfor the term b2t to give O((bt (n + m))2) as the upper bound.(b) Our proof is constructive in that we present a specific resource-definable system with the properties claimed.For any n (cid:3) 1, let Ag be a set of 2n agentsA ∪ B = {a1, a2, . . . , an} ∪ {b1, b2, . . . , bn}and the goal set G consist of a single goal: G = {g}. The system F PAIRis given byn(cid:6)F PAIRn(C) ={g}∅if ∃1 (cid:2) i (cid:2) n: {ai, bi} ⊆ Cotherwiseis represented by the QCG Q = (cid:12){g}, Ag, G1, . . . , G2n, Ψ (cid:13) withFirst observe that F PAIRnn(cid:15)(cid:7)Ag, {g}(cid:8)Ψ=(ai ∧ bi) ∨ ¬gi=1a propositional formula of size 2n + 1. Furthermore, since, from Fact 6(a), the sub-formula ∨nmonotone increasing propositional function of Ag, it follows from Theorem 16(b) that F PAIRConsider any Γ ∈ [F PAIR]CRG, i.e., in the equivalence class of CRGs representing the system F PAIRshow that M CRG(Γ ) (cid:3) 2n−1 by arguing that any such CRG must employ a resource set of at least this size.nni=1(ai ∧ bi) describes ais resource-definable.. We nownLetRΓ = {r1, r2, . . . , rt }be the set of resources specified in Γ . For ai ∈ A, bi ∈ B denote by ai,k and bi,k the endowment values en(ai, rk) anden(bi, rk). Similarly, we denote by gk the requirement value req(g, rk) in the CRG Γ .It is easy to see that with each C ⊆ A we can associate a unique, maximal subset unpaired(C) of B with which(cid:8)(cid:7)C ∪ unpaired(C)= ∅F PAIRnThis set is given by,unpaired(C) = {bi: ai /∈ C}We first observe that, since Γ represents the system F PAIRnthe following inequalities must hold,∀i, ∀k∀C ⊆ A, ∃kai,k + bi,k (cid:3) gk(cid:2)ai,k +(cid:2)bj,k < gkai ∈Cbj ∈unpaired(C)For each C ⊆ A define the subset fail(C) of RΓ by(cid:6)fail(C) =rk:(cid:2)ai ∈Cai,k +(cid:2)bj,k < gkbj ∈unpaired(C)"Suppose, for the sake of contradiction, that |RΓ | (cid:2) 2n−1 − 1. Then since there are 2n subsets of A, it must be the casethat there is some resource, rk, that occurs in at least#2n2n−1 − 1$= 3different choices of fail(C), i.e., there are distinct choices C, D, E as subsets of A for which∃r ∈ RΓ : r ∈ fail(C) ∩ fail(D) ∩ fail(E)866M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871We will show that we may choose two of these sets in {C, D, E}—X and Y say—with the property:|X \ Y ∪ Y \ X| = (X ∪ Y ) \ (X ∩ Y ) (cid:3) 2To see this, assume without loss of generality, that |C| (cid:3) |D| (cid:3) |E| and that the difference in size between any two isat most 1: if we have |X| − |Y | (cid:3) 2 then the property sought follows immediately. Suppose that both, (C ∪ D) \ (C ∩ D) (C ∪ E) \ (C ∩ E) = 1 = 1(since C, D, and E are distinct, neither size can be zero; if either case has size at least 2 then the property is alreadyestablished).From the assumption |C| (cid:3) |D| (cid:3) |E| we deduce that,C = D ∪ {ai}and C = E ∪ {aj }where ai /∈ D and aj /∈ E. Now,(cid:7)(cid:7)ai /∈ D and C = E ∪ {aj }aj /∈ E and C = D ∪ {ai}(cid:8)(cid:8)⇒ ai ∈ E⇒ aj ∈ DD (cid:18)= E ⇒ ai (cid:18)= ajso that, ai ∈ E \ D and aj ∈ D \ E, i.e.,{ai, aj } ⊆ D \ E ∪ E \ D = (D ∪ E) \ (D ∩ E)giving the property claimed of C, D, and E.To summarise, we have two subsets—X and Y —of A and a resource rk ∈ RΓ with which, |X \ Y ∪ Y \ X| (cid:3) 2,andP1.P2.(cid:2)ai ∈X(cid:2)ai ∈Yai,k +ai,k +(cid:2)bj,k < gkbj ∈unpaired(X)(cid:2)bj,k < gkbj ∈unpaired(Y )Again without loss of generality suppose, {a1, a2} ⊆ (X ∪ Y ) \ (X ∩ Y ) and consider the setX ∪ unpaired(X) ∪ Y ∪ unpaired(Y )From a1 ∈ (X ∪ Y ) \ (X ∩ Y ) we deduce that either a1 /∈ X or a1 /∈ Y , and therefore from the definition of unpaired,b1 ∈ unpaired(X) ∪ unpaired(Y )Similarly, we deduce b2 ∈ unpaired(X) ∪ unpaired(Y ), so that in totalP3.{a1, a2, b1, b2} ⊆ X ∪ unpaired(X) ∪ Y ∪ unpaired(Y )Combining P1 and P2 gives,(cid:2)ai,k +(cid:2)bj,k < 2gkai ∈X∪Ybj ∈unpaired(X)∪unpaired(Y )From P3 and the definition of the system F PAIR(cid:2)ai,k +(cid:2), however, we get in contradictionnbj,k (cid:3) a1,k + b1,k + a2,k + b2,k (cid:3) 2gkai ∈X∪Ybj ∈unpaired(X)∪unpaired(Y )In consequence the assumption that Γ ∈ [F PAIR) = (cid:12)(2n) as claimed.μCRG(F PAIRnn]CRG may be chosen with |RΓ | < 2n−1 cannot be valid, and thus   M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871867(c) Theorem 16 indicates that each monotone propositional function of m arguments yields a resource definableset. The lower bound now follows via the counting argument of Riordan and Shannon [32], ([11, pp. 272–274])10 andthe fact that for Q(m) the class of monotone propositional functions of m arguments, Q(m) (cid:3) 2( m(cid:29)m/2(cid:30))(cid:2)5. Possible extensions of the CRG modelThe model of CRGs as developed over the preceding sections makes a number of simplifying assumptions concern-ing the nature of agents and goals within the system. We now, briefly, consider one possible development of the basicmodel and highlight some specific problems that might arise with this.Our model associates with each goal g ∈ G and resource r ∈ R a quantity of that resource which must be used inorder to achieve the goal: the requirement function req : G × R → N. Given R = {r1, . . . , rk} we can present theserequirements via a k-tuple,req(gi) =(cid:9)(cid:10)req(gi, r1), . . . , req(gi, rj ), . . . , req(gi, rk)describing a single “profile” of resource usage that suffices to bring about gi , i.e., if x ∈ Nk and x (cid:3) req(gi)11 thenexpending (for each j ) xj of resource rj will realise gi .In a number of applications, particularly in negotiation contexts, it is possible that there are a number of incom-parable methods of bringing about the same goal, e.g. with R = {r1, r2} both of the profiles (cid:12)0, 1(cid:13) and (cid:12)1, 0(cid:13) may beeffective methods of realising g.In summary, instead of the description Γ = (cid:12)Ag, G, R, G1, . . . , Gn, en, req(cid:13) presented in Definition 1, the compo-nent req describes for each g ∈ G the set of effective profiles, Π(g), any one of which would suffice to bring about g,i.e.,Π(g) = {x: expending, for each j , xj units of rj , realises g}LetM-CRG = (cid:12)Ag, G, G1, . . . , Gn, R, Π1, Π2, . . . , Πm, en(cid:13)be a multiple profile CRG. One suitable description for a profile x would be simply to present x as a vector in Nk. Itis trivial to see that, using this enriched model and associated representation, the basic successful coalition problemremains NP-complete. We note that, in such multiple profile models and in contrast to the basic CRG model, thequestion of whether a given coalition C ⊆ Ag has a sufficient collective endowment in order to bring about G(cid:17) ⊆ Gcould become rather more complicated, e.g. suppose |Π(g)| = 2 for each g ∈ G(cid:17) so that, in principle, there are 2|G(cid:17)|alternative mechanisms for realising G(cid:17). It may be that this decision problem can, in fact, be efficiently decided, (e.g.,using suitable integer programming formulations), however this remains open.Another obvious extension is to assume agents are in addition equipped with sets of “capabilities”, modelled asfunctions cap which transform a multiset of resources (i.e., a bag of resources) into another multiset of resources.Here, we are close to the realm of production planning systems, and operational research techniques may be usefulfor understanding and reasoning about them. We note that one technical difficulty in understanding the complexity ofreasoning about such systems lies in the representation of capabilities.Finally, another possible extension would be to consider cases where an agent is interested in trying to maximise thenumber of goals it achieves. There is an obvious decision problem associated with this extension, where in addition toa CRG Γ and a coalition C ⊆ Ag, we are given a target τi (cid:2) |Gi| ∈ N for each agent i ∈ C, representing the numberof goals that we desire i to accomplish. We are then asked whether there exists some G(cid:17) ∈ sf (C) such that for alli ∈ C, we have |G(cid:17) ∩ Gi| (cid:3) τi , i.e., whether there is some feasible goal set for C in which every agent i ∈ C satisfiesits target number of goals τi . It is easy to see that this problem is NP-complete, and hence no worse than the generalSUCCESSFUL COALITION problem: SUCCESSFUL COALITION is the special case of the “target” problem where weset τi = 1 for every i ∈ C.10 In very informal terms, this gives a lower bound on the formula size of propositional functions belonging to “large enough” classes Q(n), thebound being expressed in terms of |Q(n)|.11 For v. and w in Nk we write v (cid:3) w whenever vi (cid:3) wi for each 1 (cid:2) i (cid:2) k. 868M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–8716. Discussion and related workBefore discussing related work, it may be worth clarifying the extent to which CRGs (and indeed QCGs) may beconsidered as games, as opposed to simply optimisation problems [29]. For example, one domain for studying coordi-nation in multi-agent systems, which is currently receiving much attention, is the distributed constraint optimisation(DCOP) scenario of Modi et al. [25]. In DCOP, each agent in a system is assumed to control a set of variables; thegoal is for the agents to assign values to their variables in such a way that some overall objective function over thesevariables is minimised. DCOP problems are not usefully considered as games because there are no strategic concerns:every agent benevolently tries to minimise the global objective function, and there is no concept of self interest, in thesense of an agent attempting to do the best for itself. DCOP problems represent an important and useful abstraction ofmany coordinated problem solving settings [13], whence the current level of interest.In QCGs and CRGs, however, the issue is not simply one of optimisation, in the sense of (for example) minimisingresource usage. While such considerations may come into play, they are secondary to an agent’s primary goal ofsatisfying at least one of its goals. In order to accomplish one of its goals, an agent must typically cooperate withother agents because it does not have sufficient resources on its own. Strategic considerations arise in CRGs becausean agent must decide which other agents to cooperate with, and in doing so, must consider that these other agents willalso engage in reasoning of the same type.With respect to work that relates to CRGs and QCGs in general, we note that [47] provides a detailed review, andalso give more detailed references to the role of cooperative games and coalition formation in the multi-agent systemscommunity. Shehory and Kraus developed algorithms for coalition structure formation in which agents were modelledas having different capabilities, and were assumed to benevolently desire some overall task to be accomplished, wherethis task had some complex (plan-like) structure [37–39]. Sandholm et al [34] investigate the coalition structure gen-eration problem (i.e., the problem of partitioning a set of agents into teams). Conitzer and Sandholm also investigatedthe complexity of determining non-emptiness of the core [8], while Bilbao and colleagues survey the complexity ofa number of problems in cooperative game theory [3], and Tennenholtz and Moses investigated the cooperative goalachievement problem [26,41], showing it to be PSPACE-complete.One of the concerns that pre-occupies both this paper and its predecessor [47] is that of succinctly representingcoalitional games. Recall that the classic model of a coalitional game (with transferable payoff) is as a pair (cid:12)Ag, ν(cid:13),where Ag is a set of agents and ν is a characteristic function, ν : 2Ag → R, which assigns to every possible coalitiona numeric value, the idea being that this value can then be distributed between members of the coalition [27, p. 257].If we wish to consider the computational problems associated with reasoning about such games, (such as determiningwhether the core of a given game is non-empty), then the question of how to represent the game, and in particular, thecharacteristic function ν, becomes extremely significant. The main issue is that a naive, extensive representation ofν—as a set of pairs {(C, x) | C ⊆ Ag, x = ν(C)}—is both infeasible and entirely unrealistic, because it will be of sizeexponential in the number of agents. While we may get results indicating that for this representation, a particular prob-lem is tractable, the assumptions upon which these results are based—an unworkable representation of characteristicfunctions—render such results meaningless [10, p. 258].12Faced with this problem, there are two obvious lines of attack:• Give the characteristic function a specific interpretation in terms of combinatorial structures. This is the approachadopted in [10,17], and indeed the present paper. The advantage of such an approach is that the representation canalways be guaranteed to be succinct; the disadvantage is that not all characteristic functions can be represented.• Try to find a succinct general representation for ν, i.e., a succinct way of representing characteristic functions ingeneral. For example, this is roughly the approach adopted in [47], where a representation of QCG characteristicfunctions based on formulae of propositional logic was proposed. This representation is indeed general (in that itcan completely capture all QCG characteristic functions), although it is not always guaranteed to be succinct [47,pp. 36–37].12 Similar issues of course arise in many areas of AI, such as planning [16, p. 59].M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871869With respect to the former approach, Deng and Papadimitriou undertook arguably the first systematic investigation ofthe complexity of solution concepts in coalitional games [10]. They used a representation based on weighted graphs.To represent a coalitional game with agents Ag, they used an undirected graph on Ag, with integer weights wi,jbetween nodes i, j ∈ Ag. The value of a coalition C was then defined to be{i,j }⊆C wi,j , i.e., the value of a coalitionC ⊆ Ag is defined to be the weight of the subgraph induced by C. Given this representation, Deng and Papadimitrioushowed that the problem of determining emptiness of the core was NP-complete, while the problem of checkingwhether a specific imputation was in the core of such a game was co-NP-complete [10, p. 260]; they also showed thatthese problems could be solved in polynomial time for graphs with non-negative weights [10, p. 261].(cid:29)With respect to the latter approach, Conitzer and Sandholm consider a modular representation of coalitional games,where a characteristic function is represented as a collection of sub-games [9]; under this representation, they showedthat checking non-emptiness of the core is co-NP-complete. In related work, Ieong and Shoham propose a representa-tion of coalitional games called marginal contribution nets [17]. In this representation, a characteristic function overa set Ag of agents is represented as a set of rules, with the structurepattern −→ valueThe pattern is a conjunction of agents, and such a rule is said to apply to a group of agents S if S is a superset of theagents in the pattern conjunction. The value of a coalition in the marginal contribution network representation is thenthe sum over the values of all the rules that apply to the coalition. The following example, from [17], illustrates thisin more detail. Suppose the marginal contribution net is defined by the following rules:a ∧ b −→ 5b −→ 2Then given this representation, we would have ν({a}) = 0, ν({b}) = 2, and ν({a, b}) = 7. Ieong and Shoham showthat, under this representation, checking whether an imputation is in the core is co-NP-complete, while checkingwhether the core is non-empty is co-NP-hard.13 They also show that their representation can capture that of Conitzerand Sandholm [9].Moving more specifically to work that is related to the resource-based framework of CRGs, we note some similaritybetween our ideas and that of the classic model of a market economy [27, p. 260]. In a market economy, thereare assumed to be k different goods, each agent i is endowed with some number of each different good, and eachagent is also associated with a production function, which transforms bundles of goods into other bundles of goods.The classic question studied with respect to exchange economies is that of finding a competitive equilibrium, i.e., afeasible allocation of bundles of goods to agents at a particular price such that this allocation maximises each agent’sprofit, with respect to it’s production function, and the respective costs of input and output goods. Wellman’s seminalWALRAS system used an auction approach to compute competitive equilibria in a computational market framework[45]. Although there are similarities between CRGs and market economies, there is no distinction in the classic modelof a market economy between goals and resources: this framework works well when the domain at hand fits withmarket model of prices and transferrable goods, but is less well suited to goal-oriented systems, or systems wheregoods are not transferrable.We also note some similarities between our motivations and those of Chakrabati et al on resource interfaces [7].The idea of a resource interface is to represent the resources required by a particular process over time. The motivatingexample used by Chakrabati is that of the power requirements of a process controlling part of a mobile robot. In orderto see whether it is possible to combine two such processes, we try to find a winning strategy to schedule executionof the two processes such that the combined processes never exceed a particular resource bound. There are clearlysimilarities between the two models, although the concerns are rather different; one key idea in the work of Chakrabatiet al is that of resource requirements over time—see conclusions below.We should also point to the work of von Martial on the first-order axiomatisation of a coordination theory formulti-agent plans [43]. von Martial explicitly allows for multiple resources, for agents to be endowed with differentquantities of each resource, and for actions to require the consumption of different quantities of resources, very muchas in CRGs [43, pp. 90–94]. However, von Martial’s main focus was on the axiomatisation of his theory: he did not13 As noted in [17] whether non-emptiness of the core can be carried out by a co-NP algorithm using their representation is an open problem.870M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871investigate any computational properties of his model. Related work by Buzing et al. [6] develops a more rigorousmodel of multi-agent coordination, and considers the computational complexity of coordination in this setting. Themodel of Buzing et al allows for resources (“capabilities” in their parlance). The emphasis is again slightly different,as they do not focus on the coalitional game properties of their model.7. ConclusionsWe have presented Coalitional Resource Games, (CRGs), a specialisation of Qualitative Coalitional Games (QCGs)built around the notion of expending resources to accomplish goals. We investigated the computational complexity ofa range of natural decision problems associated with such games, and also investigated the extent to which CRGs andQCGs could be translated to one-another.There are many issues for future work. Perhaps the most interesting, suggested by the work of [7], and also byemerging work on dynamic coalition formation [22], is that of games (QCGs and CRGs) played over a period of time.It would be interesting to see what analogues our concepts have in such games, and how efficiently solutions could becomputed.AcknowledgementsWe are very grateful to the referees, who provided many excellent, detailed suggestions. The implementation ofthese suggestions has improved the paper considerably, and in particular has enabled us to simplify several proofs.References[1] T. Agotnes, W. van der Hoek, M. Wooldridge, Temporal qualitative coalitional games, in: Proceedings of the Fifth International Joint Confer-ence on Autonomous Agents and Multiagent Systems (AAMAS-2006), Hakodate, Japan, 2006.[2] M. Ben-Ari, Principles of Concurrent and Distributed Programming, Prentice Hall, Englewood Cliffs, NJ, 1990.[3] J. Bilbao, J. Fernández, J. López, Complexity in cooperative game theory, Manuscript.[4] A.H. Bond, L. Gasser (Eds.), Readings in Distributed Artificial Intelligence, Morgan Kaufmann, San Mateo, CA, 1988.[5] R. Brent, D.J. Kuck, K. Maruyama, The parallel evaluation of arithmetic expressions without division, IEEE Transactions Computers C-22(1973) 532–534.[6] P. Buzing, A. ter Mors, J. Valk, C. Witteveen, Task coordination for non-cooperative planning agents, in: Proceedings of the Second EuropeanWorkshop on Multi-Agent Systems (EUMAS-04), Barcelona, Spain, 2004, pp. 87–99.[7] A. Chakrabarti, L. de Alfaro, T.A. Henzinger, M. Stoelinga, Resource interfaces, in: Proceedings of the Third International Conference onEmbedded Software (EMSOFT), in: Lecture Notes in Computer Science, vol. 2855, Springer-Verlag, Berlin, 2003, pp. 117–133.[8] V. Conitzer, T. Sandholm, Complexity of determining nonemptiness of the core, in: Proceedings of the Eighteenth International Joint Confer-ence on Artificial Intelligence (IJCAI-03), Acapulco, Mexico, 2003, pp. 613–618.[9] V. Conitzer, T. Sandholm, Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issuedomains, in: Proceedings of the Nineteenth National Conference on Artificial Intelligence (AAAI-2004), San Jose, CA, 2004, pp. 219–225.[10] X. Deng, C.H. Papadimitriou, On the complexity of cooperative solution concepts, Mathematics of Operations Research 19 (2) (1994) 257–266.[11] P.E. Dunne, The Complexity of Boolean Networks, Academic Press, London, 1988.[12] P.E. Dunne, T.J.M. Bench-Capon, Complexity in value-based argument systems, in: Proc. 9th JELIA, in: Lecture Notes in Artificial Intelli-gence, vol. 3229, Springer-Verlag, 2004, pp. 360–371.[13] E.H. Durfee, Distributed problem solving and planning, in: G. Weiß (Ed.), Multiagent Systems, MIT Press, Cambridge, MA, 1999, pp. 121–164.[14] I. Foster, C. Kesselman, S. Tuecke, The anatomy of the grid: Enabling scalable virtual organisations, International Journal of SupercomputerApplications 15 (3) (2001) 200–222.[15] M.R. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman, New York, 1979.[16] M. Ghallab, D. Nau, P. Traverso, Automated Planning: Theory and Practice, Morgan Kaufmann, San Mateo, CA, 2004.[17] S. Ieong, Y. Shoham, Marginal contribution nets: A compact representation scheme for coalitional games, in: Proceedings of the Sixth ACMConference on Electronic Commerce (EC’05), Vancouver, Canada, 2005.[18] D.S. Johnson, A catalog of complexity classes, in: J. van Leeuwen (Ed.), Handbook of Theoretical Computer Science Volume A: Algorithmsand Complexity, Elsevier Science, Amsterdam, 1990, pp. 67–161.[19] R.M. Karp, V. Ramachandran, Parallel algorithms for shared-memory machines, in: J. van Leeuwen (Ed.), Handbook of Theoretical ComputerScience Volume A: Algorithms and Complexity, Elsevier Science, Amsterdam, 1990, pp. 869–942.[20] S. Ketchpel, Coalition formation among autonomous agents, in: C. Castelfranchi, J.-P. Müller (Eds.), From Reaction to Cognition—FifthEuropean Workshop on Modelling Autonomous Agents in a Multi-Agent World, MAAMAW-93, in: Lecture Notes in Artificial Intelligence,vol. 957, Springer-Verlag, Berlin, 1995, pp. 73–88.M. Wooldridge, P.E. Dunne / Artificial Intelligence 170 (2006) 835–871871[21] V.M. Khrapchenko, Asymptotic estimation of addition time of a parallel adder, Problemy Kibernet. 19 (1967) 107–122, in Russian. Transla-tion: Systems Theory Res. 19 (1970) 105–122.[22] M. Klusch, A. Gerber, Dynamic coalition formation among rational agents, IEEE Intelligent Systems 17 (3) (2002) 42–47.[23] S. Kraus, Strategic Negotiation in Multiagent Environments, MIT Press, Cambridge, MA, 2001.[24] V. Krishna, Auction Theory, Academic Press, London, 2002.[25] P.J. Modi, W.-M. Shen, M. Tambe, M. Yokoo, Adopt: asynchronous distributed constraint optimization with quality guarantees, ArtificialIntelligence 161 (2005) 149–180.[26] Y. Moses, M. Tennenholtz, Multi-entity models, in: K. Furukawa, D. Michie, S. Muggleton (Eds.), Machine Intelligence 14, Tokyo, Japan,1995, pp. 65–90.[27] M.J. Osborne, A. Rubinstein, A Course in Game Theory, MIT Press, Cambridge, MA, 1994.[28] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.[29] C.H. Papadimitriou, K. Steiglitz, Combinatorial Optimization, Prentice Hall International, Hemel Hempstead, 1982.[30] M. Pauly, Logic for social software, PhD thesis, University of Amsterdam, 2001. ILLC Dissertation Series 2001-10.[31] V.R. Pratt, The effect of basis on the size of Boolean expressions, in: Proceedings of the Sixteenth Symposium on Foundations of ComputerScience (FOCS), 1975, pp. 119–121.[32] J. Riordan, C.E. Shannon, The number of two-terminal series-parallel networks, J. Math. Phys. 21 (1942) 83–93.[33] T. Sandholm, Distributed rational decision making, in: G. Weiß (Ed.), Multiagent Systems, MIT Press, Cambridge, MA, 1999, pp. 201–258.[34] T. Sandholm, K. Larson, M. Andersson, O. Shehory, F. Tohmé, Coalition structure generation with worst case guarantees, Artificial Intelli-gence 111 (1–2) (1999) 209–238.[35] T.W. Sandholm, V.R. Lesser, Coalition formation among bounded rational agents, in: Proceedings of the Fourteenth International Joint Con-ference on Artificial Intelligence (IJCAI-95), Montréal, Québec, Canada, August 1995, pp. 662–671.[36] T.W. Sandholm, V.R. Lesser, Coalitions among computationally bounded agents, Artificial Intelligence 94 (1–2) (1997) 99–138.[37] O. Shehory, S. Kraus, Coalition formation among autonomous agents: Strategies and complexity, in: C. Castelfranchi, J.-P. Müller (Eds.),From Reaction to Cognition—Fifth European Workshop on Modelling Autonomous Agents in a Multi-Agent World, MAAMAW-93, in:Lecture Notes in Artificial Intelligence, vol. 957, Springer-Verlag, Berlin, 1995, pp. 56–72.[38] O. Shehory, S. Kraus, Task allocation via coalition formation among autonomous agents, in: Proceedings of the Fourteenth International JointConference on Artificial Intelligence (IJCAI-95), Montréal, Québec, Canada, August 1995, pp. 655–661.[39] O. Shehory, S. Kraus, Methods for task allocation via agent coalition formation, Artificial Intelligence 101 (1–2) (1998) 165–200.[40] O. Shehory, S. Kraus, Feasible formation of stable coalitions among autonomous agents in non-super-additive environments, ComputationalIntelligence 15 (33) (1999) 218–251.[41] M. Tennenholtz, Y. Moses, On cooperation in a multi-entity model: Preliminary report, in: Proceedings of the Eleventh International JointConference on Artificial Intelligence (IJCAI-89), Detroit, MI, 1989, pp. 918–923.[42] L.G. Valiant, Short monotone formulae for the majority function, Journal of Algorithms 5 (1984) 363–366.[43] F. von Martial, Coordinating Plans of Autonomous Agents, Lecture Notes in Artificial Intelligence, vol. 610, Springer-Verlag, Berlin, 1992.[44] G. Weiß (Ed.), Multi-Agent Systems, MIT Press, Cambridge, MA, 1999.[45] M.P. Wellman, A market-oriented programming environment and its applications to multicommodity flow problems, Journal of AI Research 1(1993) 1–23.[46] M. Wooldridge, An Introduction to Multiagent Systems, John Wiley & Sons, New York, 2002.[47] M. Wooldridge, P.E. Dunne, On the computational complexity of qualitative coalitional games, Artificial Intelligence 158 (1) (2004) 27–73.