Artificial Intelligence 84 (1996) 113-150 Artificial Intelligence Default reasoning using classical logic * Rachel Ben-Eliyahu ay*, Rina Dechter b~l a Matirematics and Computer Science Department, Ben-Gurion University of the Negev, Beer-Sheva 84105. Israel b Information & Computer Science, University of Calqornia, Irvine, CA 92717. USA Received December 1993; revised May 1995 Abstract In this paper we show how propositional default theories can be characterized by classical propo- sitional theories: for each finite default theory, we show a classical propositional theory such that there is a one-to-one correspondence between models for the latter and extensions of the former. This means that computing extensions and answering queries about coherence, set-membership and set-entailment are reducible to propositional satisfiability. The general transformation is expo- superset of network default theories and nential but tractable for a subset which we call Z-DT-a default theories. Consequently, coherence and set-membership for the class 2-DT disjunction-free is NP-complete and set-entailment is co-NP-complete. This work paves the way for the application of decades of research on efficient algorithms for the satisfiability problem to default reasoning. For example, since propositional satisfiability can be regarded as a constraint satisfaction problem (CSP), this work enables us to use CSP techniques for default reasoning. To illustrate this point we use the taxonomy of tractable CSPs to identify new tractable subsets for Reiter’s default logic. Our procedures allow also for computing stable models of extended logic programs. 1. Introduction in artificial Researchers it widely and have used areas, including diagnostic intelligence for declarative reasoning have found Reiter’s default logic [ 291 2 attractive in a variety of representations of problems [ 301, theory of speech acts [ 281, natural language *Most of this work was done while the first author was a graduate student at the Cognitive Systems Laboratory, Computer Science Department, University of California, Los Angeles, CA, USA. * Corresponding author. E-mail: rachelQcs.bgu.ac.il. ’ E-mail: dechter@ics.uci.edu. * In this paper, when we mention “default logic” we mean “Reiter’s default logic”. OOO4-3702/96/$15.00 @ 1996 Elsevier Science B.V. All rights reserved SSDIOOO4-3702(95)00095-X I14 R. Ben-Eliyuhu. R. Dechter/Ariijiciul Intelligence 84 (1996) Il3-150 concept of extension shown, there Recent research default propositional [ 251, and inheritance processing it has been shown default” can be embedded very naturally for logic programs semantics However, while knowledge [ 4,161. can be specified hierarchies with exceptions [ II]. Most importantly, that logic programs with classical negation and with “negation by in default logic, and thus default logic provides in a natural way in default as presented by Reiter is quite that computes extensions is no procedure tricky. Moreover, of an arbitrary default indicates that the complexity of answering basic queries on propositional the logic, as Reiter has theory. [ 17,34]), and that even for very simple logic is very high (X;- or II;-complete theories, In this paper we show how we can confront the problem default is NP-hard [ 19,331. into classical propositional theories a class of theories for which we have effective ways of computing set-membership logic. default and to the identification theories. Our approach and set-entailment, these difficulties by translating leads to the identification default of extensions and testing of new tractable subsets for functions We introduce rather than to logical symbols-and the concept of nzeta-interpretations-truth that assign truth val- is ues to clauses the properties of these models enables us to a model for a given default into a classical proposi- show that any finite propositional tional theory such that there is a one-to-one between models of the clas- sical theory and extensions of the default theory. Queries about coherence and entailment logic. in default logic to in propositional in default define when such a truth function default theory can be compiled is that it reduces computation to queries about satisfiability logic are thus reducible theory. Studying correspondence The main advantage of this mapping satisfiability, algorithm a deterministic there is a significant introduces default for computing theory, while previous algorithms 3 (e.g. propositional our method propositional an extension only for certain subsets of all default theories. Our translation in general. However, (2-DT), for which our translation theories-the rzetwork default the class of disjunction-free forbidden. embed extended former. Therefore, for computing a task that has already been explored extensively. Moreover, extensions of any finite ) produce is exponential theories the so-called [ 1 l] and are theories can logic programs; answer sets of the latter coincide with extensions of the for finding extensions default [ 161 that the class of disjunction-free logic version of inheritance in which sublanguage which we call 2-default is tractable. The class 2-DT formulas with disjunction logic programs as well. for 2-DT are applicable techniques developed It has been shown [ 11,18,19,33] networks theories, includes default default As a by-product of our translation, we learn that the coherence problem and the for the class 2-DT is NP-complete and that the set-entailment for the class 2-DT is co-NP-complete. 4 The translation additional NP-complete subclasses. Note that in general also provides a general these problem set-membership problem framework problems are Xc- or II;-hard. for identifying 3 Of course there also exists the brute-force algorithm, according clauses, whether or not it is an extension of the theory. Though finite number of such subsets, 4 See Section 5. I for details. this brute-force algorithm is extremely expensive. to which you check for every subset of to consider a it is clear that it is sufficient R. Ben-Eliyahu, R. Dechter/Arti&ial Intelligence 84 (1996) 113-150 115 Once a default theory is expressed as a propositional theory, we may apply many existing heuristics and algorithms on propositional satisfiability. In particular, we show how topological considerations can be used to identify new tractable subsets, and how constraint satisfaction techniques can be effectively applied to tasks of default reason- ing. The rest of the introduction is organized as follows: in the following section we discuss the connections between default logic, logic programming, and inheritance networks, to demonstrate that the work presented here has a direct influence on computational issues in these fields as well. In Section 1.2 we will then give an introductory discussion about the basic ideas and contributions of this paper and explain its organization. 1.1. Default logic, inheritance networks, and logic programs 1.1.1. Reiter’s default logic We begin with a brief introduction to Reiter’s default logic [ 291. Let C be a first-order language over a countable alphabet. A default theory is a pair A = (D, W), where D is a set of defaults and W is a set of closed well-formed formulas (wffs) in C. A default is a rule of the form cr:p1,...,p, Y ’ where Q,PI,...,& and y are formulas in C. 5 (1) A default IS can also be written using the syntax LY : pi,. (Y is called the prerequisite (notation: pre( 6) ) ; PI, . . . , P,, are the justifications (notation: just( 8)); and y is the conclusion (notation: concl( 6)). The intuition behind a default can be stated as “if I believe cy and I have no reason to believe that one of the pi is false, then I can believe y”. A default (Y : P/y is normal if y = /3. A default is semi-normal if it is in the form LY : /I A y/y. A default theory is closed if all the first-order formulas in D and W are closed. . . , &/y. The set of defaults D induces an extension on W. Intuitively, an extension is a maximal set of formulas that is deducible from W using the defaults in D. Let E* denote the logical closure of E in C. We use the following definition of an extension: Definition 1.1 (Extension and let (D, W) be a closed default theory. Define [ 29, Theorem 2.11). Let E G C be a set of closed wffs, (1) Eo= W, and (2) fori~O,Ei+l=Ei”U{yIa:pl,...,P,/yEDwhereaEEiand-pl,..., -Pn $ El. E is an extension for A iff for some ordering E = Uz Ei. (Note the appearance of E in the formula for Ei+l.) Many tasks on a default theory A may be formulated using one of the following queries: 5 Empty justifications are equivalent to the identically true proposition true [ 3 11. 116 R. Ben-Eliyahu. R. Dechter/Artijicial Intelligence 84 (1996) 113-150 l Coherence: Does A have an extension? a Set-membership: Given a set of clauses T, is T contained l Set-entailment: Given a set of clauses T, is T contained In Section 6 we will also consider a special case of set-membership which we call in every extension of A? in some extension of A? If so, find one. clause-membership, where the set T is a single clause. In this paper we focus on propositional default logic. It has been shown is X;-complete theories for this class and remains so even [ 17,341. Membership and entailment that the if restricted for the class of default theories were shown even if T is restricted to contain a single to be X;-complete literal [ 17,341. and @-complete, In this paper we for which these tasks are easier. 6 that the subclass 2-DT of all default networks and logic programs. The following theories is powerful enough two subsections default problem coherence to semi-normal normal propositional respectively, will show subclasses It has been shown to embed both inheritance elaborate on this. 1.1.2. Inheritance networks and network default theories An inheritance network is a knowledge representation thus allowing scheme in which the knowledge representational hierarchy, in a taxonomic is organized share a group of common properties, an abstraction of those properties many individuals is created, and all those individuals Inheritance can then “inherit” from multiple classes is also allowed. For more information on this subject, see [ 11,371. called network default a subclass of default for formal semantics and a notion of sound proposed for providing from that abstraction. compactness. inference theories, If Etherington [ II] theories, as suitable inheritance networks. Definition 1.2 (Network default iff it satisfies theov the following conditions: ( 1) W contains only [ 111) A default theory A is a network theory literals (a) (b) disjuncts of the form ( LY V /?) where cx and /I are literals. formulas or their negations) (i.e., atomic and (2) D contains only normal and semi-normal LY : p A y1 A . A y,,/P where (Y, /3, and yi are literals. defaults of the form (Y : /3/p or Etherington suggests formalizing inheritance relations in network default such a way that an extension of a network default of coherent conclusions Thus all the queries defined above (coherence, relevant when dealing with network default theories. that one could draw from the inheritance network set-membership, set-entailment) theory would correspond theories in to a set it represents. are still 1.1.3. Default theories and logic programs Logic programming is a paradigmatic way of representing logic. Originally, declarative manner using symbolic was restricted to Horn clauses. Its expressive power was greatly the language used by logic programs the improved after programs and data in a ’ Assuming the polynomial hierarchy does not collapse at this level. R. Ben-Eliyahu, R. Dechter/Artijicial Intelligence 84 (1996) 113-150 117 introduction of negation in the body of the rules. This negation was generally interpreted as “negation by default”, not classical negation, resulting in a grounded predicate being considered false iff it cannot be proved from the program. For an overview of this field, see [21]. One of the most prominent semantics for logic programs is stable model semunrics [4,14,16]. Gelfond and Lifschitz [ 161 have shown how stable model semantics can be naturally generalized to the class of extended logic programs, in which two types of negation-classical negation and negation by default-are used. An extended logic program is a set of rules of the form ~O-pl,...,pm,notq~,...,notqn, (2) where each of the r, p, and q are literals, and nor is a negation by default operator. Stable model semantics associates a set of models, or unwer sets, with such an extended logic program. Gelfond and Lifschitz established a one-to-one correspondence between extended logic programs and disjunction-free default theories by identifying a rule of the form (2) with the default p1 A***Apm :Nql,...,Nq” r0 where N q is the literal opposite to q (- P = 1P, N-P = P). They have shown that each extension of such a default theory corresponds to an answer set of its twin logic program. A similar idea was introduced by Bidoit and Froidevaux [4]. The above discussion suggests concluding that any algorithm that computes extensions of a default theory will also compute answer sets of logic programs under stable model semantics. Moreover, any semantics attached to a default theory provides meaning to a logic program as well. 1.2. The main contribution of this paper The exposition in some sections of this paper involves many technical issues, so we will first familiarize the reader with the basic ideas. In this paper we provide a way to translate any finite propositional default theory into a classical propositional theory so that the queries on the default theory are specifiable as queries about satisfiability or entailment in classical propositional logic. In order to give the reader a feel for this translation, we will present three default theories considered in Reiter’s original paper on default logic [ 29 1, and for each theory we will provide the corresponding propositional theory. We will explain, without delving into technical details, the principle behind our mapping. Example 1.3. Consider the following default theory [29, Example 2.31 D={$,$}, w=0. This theory has two extensions: {-C}” and {-D}*. We will now show how this result is realized using our translation. For each literal X in {IC, YD}, let lx be an atom with 118 R. Ben-Eliyahu, R. Dechter/Artifcial Intelligence 84 (1996) 113-150 the intuitive meaning “X is in the extension”. So, for example, 1-o has the meaning “7D is in the extension”. Applying this vocabulary, we will set constraints on the extension of (D, W). The default rule extension, then TD is in the extension”. We can write it in propositional the constraint in other words: “if -C then -D is in the extension”, “if C is consistent with the is not in the extension, logic as follows:7 imposes : C/-D Tl-,C > I,D. Accordingly, extension, the default rule “if 1D is in the extension”. We can write it in propositional the constraint imposes : D/X then -C +,D > 1-c. in is not logic as: (3) the (4) If TD is in the extension, is not in the extension, because is the only rule that can be used to derive TD, and it will be activated it must be the case that -C the default C/-D only if C is consistent. The same applies for -C. Therefore, we add the constraints: (5) (6) 14, 1 +,C. I,C > d+. If we combine M, and MZ. In Ml, 1,~ MI corresponds (3)-(6). the formulas we arrive at a theory which has two models: is false. is false. In kt2, I+ to the extension {+C}* and M2 corresponds {7D}*. is true and I,c to the extension is true and 1-o Example 1.4. Consider the following default theory 129, Example 2.21 D= w = 0. This theory has one extension: { TD, ?F}*. We will now show how this result is realized I-,E, I.+}. The default using our translation. This time we use the vocabulary {I,c, rule : C/lD the constraint imposes I,o, +,C > I-D, the default rule : D/lE imposes the constraint TI-.o > 1-E. and the default rule : E/TF imposes the constraint ++ > IYF. (7) (8) (9) Since extensions are supposed to be minimal, we assert that if -D is in the extension, it must be the case that -C only rule that can be used to derive TD, and it will be activated only if C is consistent. Same for -IE and TF. Therefore, we add the constraints: is not in the extension, because the default C/lD is the ’ > is the usual material implication in classical logic. R. Ben-Eliyahu, R. DechterIArtijicial Intelligence 84 (1996) 113-150 I-ID > -‘i-C, IYE > -‘z-d), I+ > -hE. Since there is no default which derives X, we also add the requirement 119 (10) (11) (12) (13) If we combine the formulas (7)-( 13), we arrive at a theory which has one model, where the only true atOm are 1-D and I.+. This model corresponds to the extension {lD, yF)*. Example 1.5. Consider the following default theory [29, Example 2.6, p.911 w =0. We will translate this theory as follows: The first formula constrains that the default rule should be satisfied. The second conveys the claim that since the extension is minimal, if it contains YA it must be the case that TA was derived using the only default in D, and therefore that TA is not in the extension. The propositional theory above is inconsistent, and indeed the default theory we consider has no extension. In the sequel to this section we will formally justify the translations illustrated above, present the general algorithms, and give more examples. The rest of the paper is orga- nized as follows: After introducing some preliminary definitions in Section 2, we provide in Section 3 the concept of a model for a default theory and explain the theory behind our translation. In Sections 4 and 5 we discuss how the models presented in Section 3 can be treated as classical models of propositional logic. We present algorithms that associate for each finite default theory a classical propositional theory that characterizes its extensions. Then, in Section 6 we use constraint satisfaction techniques to show how our approach leads to the discovery of new tractable subsets for default logic. Section 7 contains concluding remarks, and missing proofs appear in Appendix A. Before moving on, we would like to clarify a subtle but important point. Some of the decision problems we discuss here have been proven to be NE-complete or CO-NE- complete for some subsets of all propositional default theories [ 19,331. This means, almost by definition, that there actually exists a polynomial translation from these subsets to propositional theories such that queries on the translated default theories are answer- able by solving satisfiability of the corresponding classical theories. The consequences of the work presented here goes beyond this initial observation. First, we can show a direct and simple translation: our translation does not require the encoding of Turing 120 R. Ben-Eliyahu, R. Dechter/Artijicial Intelligence 84 (1996) 113-150 theory. In other words, even for subclasses of default logic for the complexity of in propositional Second, our translation being NP- or co-NP-complete. is much lower than the complexity machines which the above problems were shown to be NP- or co-NP-complete, the translation we provide problems that each model of the classical means to an extension of the original default of all finite propositional theories-not therefore also be used as a tool for identifying for which the problem of coherence, co-NP In general for some subclass, and membership set-entailment the complexity of our translation are in NP or in co-NP. only additional that for this subclass to restricted it means default theory derived from the translation theory. Third, our translation subclasses of default and set-membership is exponential, but if it is polynomial the problems of coherence, entailment applies is pe@zct 8 -which corresponds to the class can theories are in NP or in subclasses-and implied by these decision 2. Definitions and preliminaries -P) by lowercase symbols by uppercase We denote propositional letters P, Q, R, . . ., propositional letters p, q, I,. . ., formulas by (Y,& literals of by c, cl, ~2,. . . . The empty is denoted by LL The set of all resolvents of two clauses cr and c2 will be closure of a set of clauses T is the set obtained to T until a fixed the resolvents (e.g. P, literals by d, dl , . . ., and disjunctions clause denoted by res( ct ,c2). The resolution by repeatedly point resolving pairs of clauses of T and adding . . ., conjunctions is reached. of literals (clauses) A formula is in a conjunctive normal form (CNF) iff it is a conjunction of clauses. normal form (DNF) is in disjunctive iff it is a disjunction formula has equivalent of conjunctions in CNF and DNF. The function A formula of literals. Each C’NF( a) equivalent we assume formula each input formula. When convenient, we will refer to a clause as a set of literals, formula formulas9 (respectively DNF( cu) ) returns a formula to LY. Although a formula may have several equivalent CNF or DNF formulas, for to a in DNF as a set of sets of literals. formulas. An in T in CNF as a set of clauses, and to a formula (.S, f) where S is the set of atoms used in CNF (respectively DNF) that the functions CNF() for a theory T is a pair is a set of propositional return a unique output (in brief, a theory) A propositional and DNF() that is theory interpretation is a truth assignment and f that satisfies all the formulas premises T, and T /= a means (Y as well. In propositional interchangeably. in S. A model for T is an interpretation for the symbols in T. T t a means from that LY is propositionally that T entails a, that is, every model of T is a model for provable logic, T I- a iff T k a. Hence we will use these notations The relation < between interpretations true is a subset of the set of symbols is defined as follows: 81 ,< 82 iff the set of to which 82 assigns is no among a set of interpretations I iff there 0 is minimal to which 61 assigns symbols true. An interpretation 9’ # 0 in I such that 8’ 6 0. ’ We thank Mirek Truszczyfiski y Two formulas a and 0 are equivalent for suggesting this rather appropriate term. iff a /= p and p /= cy. R. Ben-Eliyahu, R. Dechter/Artijicial Intelligence 84 (1996) 113-150 121 the logical closure of a theory T? Since the logical closure The logical closure of a theory T, denoted T*, is the set (w ( T k w}. How do we is an infinite set, it is finite, we the notion of prime compute is obvious can compute implicates as presented by Reiter and de Kleer it explicitly. However, when the theory the logical closure by using that we cannot compute a set that will represent [ 321. Definition 2.1. A prime implicate of a set T of clauses is a clause c such that (1) Tbcand (2) there is no proper subset c’ of c such that T k c’. The prime implicates of a theory T will be denoted by PI(T). As Reiter and de resolve pairs of to T, and delete subsumed clauses, lo until a fixed point [26] ), improvements (see for example is to repeatedly to that method Kleer note, a brute-force method of computing PI(T) clauses of T, add the resolvents is reached. r1 There are some but it is clear Nevertheless, computed that the general problem for special cases such as size-2 clauses, is NP-hard in 0(n3) time. since it also solves satisfiability. implicates the prime can be Throughout the paper, and unless stated otherwise, we will assume without loss of theories are in CNR, W is a set of clauses, in the justification is a single clause, and each formula that all formulas we use in default generality the conclusion part of a default of each default is consistent.12 3. Propositional semantics for default logic in general interpretation cannot capture is a belief set, that is, it is a set of formulas An extension A single classical we cannot all formulas interpretation a formula nor its negation belongs to be true. that are believed the idea of a belief set. In other words, the set of that the model satisfies with the belief set. The reason is that a classical assigns a truth value to any formula, while it might be the case that neither represent a belief set by a single model by identifying to the agent’s set of beliefs. to use meta-interpretations to represent belief sets. In meta-interpretations We propose truth values is assigned we assign that a clause 7P are not in my belief set, they will both be assigned that represents my belief set. This motivates to clauses the truth value true iff it belongs rather than to propositional the following definition: atoms, with the intuition to the belief set. If both P and false by the meta-interpretation Definition 3.1 (Meta-interpretation) interpretation 8 over L is a pair (S, f), where S is a set of clauses over L and f classical propositional symbols. A meta- is a for the set of symbols Cs = {Zc ( c E S}. I3 That . Let L be a set of propositional interpretation lo A clause ct subsumes a clause cz iff ct c cs. ca is called a subsumed clause [ 5, Chapter 51. ” It is clear that this method will not generate all the tautologies, but these exceptions are easy to detect and handle. Hence, when computing prime implicates in the examples in this paper we omit tautologies. l2 Note that if a default has an inconsistent justification we can simply ignore it. t3 We chose this notation because intuitively, lC = true means that c is In the belief set. 122 K. Ben-Eliyahu, R. Dechter/ArtiJicial Intelligence 84 (I 996) I IS-150 is, f is a function atomic clause. from ls into {true, false}. A clause belonging to S will be called an We are usually interested in a belief set of an agent that is capable of making logical classical as manageable the meta-interpretation, spirit, an arbitrary true. These meta-interpretation inferences. Hence, in order to keep the size of the meta-interpretations as possible, we can assume that if a clause is assigned then it is as if all its supersets were assigned formula n will be considered true iff all the clauses the value true in true. In the same in CNF(cu) are in which we state when a ideas are summarized in the following definition, satisfies a formula. iff either c is a tautology Definition 3.2 (Satis$abifir]v). A meta-interpretation (~9 b c) atomic clause c’ C c such that f( f,t ) = true. A meta-interpretation the formula cl A cz A ’ A c, (0 /z cl A c? A meta-interpretation . A c,) satisfies a formula Ly in propositional in classical propositional 0 = (S, f) satisfies a clause c is an logic or there 8 = (S, f) satisjes iff for all 1 < i < n, B /a c;. A logic iff it satisfies CNF( cu). Note that this definition of satisfiability has the desirable property that it is not the case that, for a given formula a, 0 b (Y iff 6 &~a. Example 3.3. Consider the meta-interpretation M2 in Table 1. M2 RP, M2 &lP that are used by the theory. In analogy In classical propositional logic, an interpretation to the set of symbols values case, we now define which meta-interpretation for a default symbols. So symbols set of clauses this way we can make sure that each clause meta-interpretation. theory. Meta-interpretations the question in meta-interpretations that contains all the prime Hence is which set of clauses of a given default the following definitions: assign will be considered truth values for a theory is an assignment of truth to the classical an interpretation to clauses, not to atomic as atomic that it will be a implicates of every possible extension, because by the in an extension will be representable should be represented theory. We suggest Definition 3.4 (Closure). Let A = (D, W) be a default theory. We will say that a set of clauses S is a closure of A iff S is a superset of all prime implicates of every possible extension of A. Definition 3.5 (Interpretation). meta-interpretation (S, f), where S is a closure of A. Let A be a default theory. An interpretation for A is a Table I Three meta-interpretations Ml M2 M3 IA T F F I -A F I T Its T F T 1s T F T I -P F F F 17PVE T T T R. Ben-Eliyahu, R. Dechter/Artijicial Intelligence 84 (1996) 113-150 123 It is easy to find a closure S of a given a default we can choose S to be the set of all clauses closure of W union we would below, the set of all conclusions is a closure of A. theory A = (D, W). For example, in the language of A, or the resolution from D. However, in general, defined of defaults like the size of S to be small. We can show that the set prime(A), Definition 3.6 (prime(A)). Given a default following sets: theory A = (D, W), we first define the l Co is the set of all conclusions I4 of defaults in D, that is, ff:P1,...,Pn C l p(A) is the resolution closure of CD and PI(W). We can now define prime(A) : Let A = (D, W) be a default is the union of p(A) - {A} and PI{ W). l5 theory. The set prime(A) Proposition 3.7 (prime(A) closure of A. is a closure). Let A be a default theory. prime(A) is a Example 3.8. Consider the following default theory A: W=(TPVB). PZ( W) = {‘P V B}, Co = {e A, TA}, and p(A) = PZ( W) U CD U {B, A}. Therefore, prime(A) = {‘P V B, P, A, -A, B). As we will see later, this theory has two extensions: l extension 1 (El): {A,P,B}*, l extension 2 (E2): (7A,-P V B}*, and indeed prime(A) is a superset of all prime implicates of El and E2. We now want to build an interpretation (S, f) for A. For reasons we will choose s to be prime(A) U (7P}. So we get & = {I,PvB, Since of them. ICsj = 6, we have 26 different later, IA, I-A, 1~). over this fixed S. Table 1 lists three to be explained Ip, I-p, interpretations logic, a model for a theory is an interpretation satisfied by the model In classical propositional the theory. The set of formulas theory, and a formula same spirit, we want to define when an interpretation Ultimately, we want satisfies formula will be entailed by the default to be an extension of that default the set of all the formulas is entailed by the theory theory if it is true in all of its models. that satisfies is a set that is consistent with the In the is a model. theory a theory for the default for a default reasoning, that a model theory. If we practice skeptical if it belongs to all of its models. I4 Note that we have assumed that the conclusion of each default is a single clause. I5 Note that this definition means that A belongs to prime(A) iff it belongs to PI(W). 124 R. Ben-Eliyahu, R. Dechter/Artifrciul Intelligence 84 (1996) 113-150 Since each model is supposed theory, each model for a default c follows Formally, closed that if a clause from a set of clauses C and for each c’ E C, I,! is true, then Z, is true too. to represent an extension is required theory to have the property that is a deductively closure). A meta-interpretation 8 = (S, f) is deductively Definition 3.9 (Deductive closed iff it satisfies: ( 1) For each two atomic clauses c and c’ such that c c c’, if f(&) = true then f( I,/) = true. (2) For each two atomic clauses c and c’, if f( I,) = true and f( I,/ ) = true then 13 b res(c,c’). A model of a default theory will also have to satisfy each clause from W and each default from D, in the following sense: Definition 3.10 (Satisfying a default fault theory A iff: theop) A meta-interpretation 8 satisjies a de- ( 1) For each c E W, 0 /=z c. (2) For each default from D, if 6, satislies negation of each of its justifications, its preconditions and does not satisfy the then it satisfies its conclusion. We would also like every clause that a model for a default theory satisfies to have a “reason” to be true: Definition 3.11 (Being based on a default on a default following conditions B is based theory A iff, for each atomic clause c such that 0 b c, at least one of the A meta-interpretation theory). holds: is a clause cl such that ci c c and 0 /z cl. ( 1) c is a tautology. (2) There (3) There are clauses cl, c2 such that B /zcl,cz (4) c E w. (5) There is a default (Y : /?I,. , fin/c and c E res(cI,c2). in D such that 8 tZ: CX, and for each 1 < i < n, 0 &-Pi. Example 3.12. Consider the following default theory A: w = {}. Clearly, {Q} is a closure of A, and the meta-interpretation 1~ is an interpretation set {Q}* is NOT an extension of A. for A. Note that 0 satisfies A but it is not based on A. Indeed, B that assigns true only to the We first define when a meta-interpretation is a weak model for a default theories, every weak model theory A. is a As we will see later, for what we call acyclic default model. R. Ben-Eliyahu, R. Dechter/Artifcial Intelligence 84 (1996) 113-150 125 Definition 3.13 (Weak model). Let A be a default interpretation 8 for A such that closed, ( 1) 8 is deductively (2) 8 satisfies A, and (3) 8 is based on A. theory. A weak model for A is an In general, however, weak models are not models of a default that they satisfy has a proof, where a proof is a sequence of defaults theory, unless each that derive clause the clause from W. Definition 3.14 (Proof). Let A = (D, W) be a default tation of A. A proof of a clause c with respect St,... theory, and let 13 be an interpre- to 0 and A is a sequence of defaults , S,, such that the following (1) CE (WU{concl(St),...,concl(6”)})*. (2) For all 1 < i < n and for each pj E just( Si), the negation of pj is not satisfied three conditions hold: by 8. (3) Forall 1 <i<n,p~(ai) s (WU{CO~KZ(G~),...,~~TK~(&_~)})*. Example 3.15. Consider the following default theory A: Clearly, {P, Q, R} is a closure of A, and the meta-interpretation to IQ and Ip is an interpretation and Q do not have proofs with respect extension of A. 0 that assigns true only for A. Note that 0 is a weak model for A, but both P the set {Q, P}* is NOT an to 19 and A. Indeed, Definition 3.16 (Model). for A such that each atomic clause Let A be a default that t9 satisfies has a proof with respect theory. A model for A is a weak model 8 to 0 and A. Our central claim then the set of all formulas is that if a meta-interpretation is a model that it satisfies is an extension of A, and vice versa. Formally, for a default theory A, Theorem 3.17 (Model-extension). for A ifs there is a model 8 for A such that E = {s 1 0 /z s}. Let A be a default theory. A theory E is an extension This theorem suggests on this theory a set T of formulas satisfies T, and T is included to queries on its models as follows: A has an extension that given a default theory A = (D, W) we can translate queries iff it has a model, for A that iff it is satisfied by every model for A. in some extension in every extension is a model iff there is a member Example 3.18. Consider again the default theory A from Example 3.8, where: Recall that A has two extensions: 126 K. Ben-Ellvtrhu. K. Lkchter/Arttjicial Intelligence 84 (I 996) /13-150 o extension 1 (El): l extension 2 (E2): {A,P,B)*, {TA, -P V B}‘. M 1 and M2 in Table 1 are models to El. The set of formulas A, because M3 is not based on A: M3 satisfies of Definition 3.1 1 are satisfied for P. conditions that M2 satisfies for -1. The set of formulas is equal is equal that Ml satisfies to E2. M3 is not a model for the atomic clause P but none of the The idea behind the definition of a proof is that each clause the defaults and propositional this is to assign each atomic clause an index that is a nonnegative from W using that if this clause will be derivable way to ensure and require its proof have a lower index. Clauses well-foundedness The following to ensure that the justifications theorem conveys of the positive is satisfied by the meta-interpretation, that the model satisfies inference. An alternative integer the clauses used in from PI(W) will get index 0, and this way the on the clauses. in order technique integers will induce well-foundedness this idea. Elkan supporting [lo] used a similar a node in a TMS are non-circular. Theorem 3.19 (Indexing A if there is u function p : 5’ - conditions hold: and proofs). A weuk model 6 = (S, f) for A is a model for N i such that for each atomic clause c the following ( 1) c E w ifsp(c) = 0. ( 2 ) If c $ W then at least one of the following conditions hold: (a) There is a default 6 = cy : /?I, , p,,/c E D such that 0 satisjies (Y and there is an atomic does not satisjj any of -,B, and, for all cl E CNF(a), clause cz C cl such that P(O) < p(c). (b) There are two atomic clauses cl und q such that c is a resolvent of cl and c?, 19 satis$es cl and cz, and p(c1).p(c2) <p(c). (c) There is an atomic clause c’ C c’ such that B b c’ and p( c’) < p(c). The above theorem is very useful in proving that for what we call acyclic default theories every weak model is a model for A. Acyclicity is defined as follows: Definition 3.20 (Dependency The dependency follows: graph of A with respect gruph). Let -1 be a default theory and S a closure of A. to S, G J,S, is a directed graph defined as ( 1) For each c E S there is a node in the graph. (2) There is an edge from node c to node c’ iff c’ $ W and at least one of the holds: following conditions (a) c C c’. (b) There (c) There is a clause c” t S such that c’ t res( c, c”). is a default a : PI,. in D and c E (Y. .,&/c’ A default theory A is acyclic with respect to a closure S iff GJJ is acyclic. Hence, if A is acyclic with respect conditions of Theorem 3.19. So we can conclude the following: to S, the order that Cd,,y induces on S satisfies the R. Ben-Eliyahu, R. Dechter/Artijicial Intelligence 84 (I 996) 113-150 127 A --. P B --JP . .-A Fig. 1. Dependency graph. Theorem 3.21 (Models acyclic default theory A, then 8 is a model for A. for acyclic theories). If 8 = (S, f) is a weak model for an Example 3.22 (Example 3.8 continued). The dependency 1. A is acyclic with respect to S. graph of A is shown in Fig. We can also show that every model for a default theory is a minimal weak model. For is defined w.r.t. the is a subset that 8’ satisfies. We will say that 0 is minimal among a set meta-interpretations following partial order: 6’ < 8’ iff the set of atomic clauses of the set of atomic clauses of meta-interpretations I iff there is no 8’ + 8 in I such that 8’ 6 0. over a fixed set of atomic clauses, minimality that 0 satisfies Theorem 3.23 (Minimality weak model for A. of models). Every model of a default theory A is a minimal 4. Expressing an acyclic default theory as a propositional theory theory A may be viewed as a classical An interpretation (S, f) for a default over S: Treat each clause in S as a propositional interpretation of each such “symbol” will be the value assigned by f to its corresponding next task is to identify among those classical A. We will do this by constructing (in the classical Given a finite default we will show a propositional a classical model versa, if (S, f) section we will generalize logic symbol, and the truth value clause. Our the ones that are models of theory that these models must satisfy theories. to some closure of A, S, these models: is is a model for A; and, vice is a classical model for ‘PA,,. In the next theory P~,J that characterizes theory, then (S, f) In this section we will concentrate on acyclic default is a model for A, then (Cs, f) for the class of all finite default is acyclic with respect for that propositional theory A which a propositional this approach interpretations If ( Ls, f) theories. sense). We will first demonstrate our method with an example. Example 4.1 (Example 3.8 continued). Consider again ample 3.8, where: the default theory A from Ex- W={lPvB}. Recall that A has two extensions: l extension 1 (El): l extension 2 (E2): {TA,TP V B}*. {A,P,B}*, 12X R. BewEliyhu, R. Dechter/Arti$ciul Intelligence 84 (1996) 113-150 Let S={lPvB,l?+‘,A, -A, B} be a closure of A. A is acyclic with respect to S. For this theory, PA,, is the following set of formulas: (1) 1-P 2 IYPVB, (2) (3) I_ p,,B, IA A 71,P > [p, 71,A > 1.4. 71A > 1+, iA > 7l-A, 1-A > ‘IA, IP > I/, A II+‘, IB 1 IP A I,pvB, ++‘. IB 1 l+VB, IP A l,f’VB 2 IB, the requirement the requirements theory PA,.7 expresses from a model of A. The first group The classical closed. It of formulas expresses then 7P V B should be true too, since says that if one of B or 7P since B is a resolvent of 1P V B and P, if B and -P are subsets of -P V B. Similarly, both of them are true then B must be true too. Note that we do not have, for example, the formula that a model for A must be deductively is true in the model The second group of formulas expresses fYfr A i,p”B > lyp since -B does not belong the requirement to W, the first formula A. For example, since 1P V B belongs that TP v B must be true; since we have the default A : P/P formula should be true in the model. in the group, which says that if A is true in the model and 1P to S at all. that the model should satisfy in the second group says in A, we add the second is not, then P The third group of formulas says that a model in this group says that if A is true in the model, example, since the only way to add A to an extension the first formula not satisfy -A, otherwise of formulas itself), from W and consequences -P will not be in any extension, of defaults so PA., includes the default in A can derive 1P the formula -1,~. : A/A could not be activated; since no combination (except 1P for A should be based on A. For in A, then the model must is to use the default : A/A The reader can verify that Ml and M2 from Table 1 are the only models of PA,s. If that Ml is equal we see that the set of formulas that M2 satisfies to the extension El and the set of formulas we look at Ml and A42 as meta-interpretations, satisfies to the extension E2. is equal Before presenting that translates a default and definitions the algorithm theory, some assumptions that a closure S of a default theory into a classical propo- are needed. From now on we will in A theory A contains all the clauses sitional assume and all the clauses in one of the CNF of the negation of each justification. We will also need the following notational shortcuts: For a given A over C and a closure of A, S, we will define the macros in() and cons() which translate formulas over L into that is, in(~) formulas over ,Cs. Intuitively, for each clause c in CNF(cu), there is an atomic clause c’ such that c’ is a subset of c and I,, is true. in(a) says that cy is satisfied by the interpretation, is defined as follows: that appear that appear ( I ) If cy is a tautology, (2) (3) If (Y is an atomic clause c that is not a tautology, If LY is a non-atomic c and clause is not a then in(a) = f,. tautology, then in(a) = then in(a) = true. IS atomic,c’Cc ICI Vd Ifa=ci then in(a) =/\,Gr+in(c,). If a is not in CNF, then in(a) = in(CNF(a)). A...Ac,, (4) (5) The function cons(p) is defined using the function in( ). Intuitively, that the negation of j3 is not satisfied by the interpretation. lows: cons() cons(p) means is defined as fol- R. Ben-Eliyahu, R. Dechter/Artijcial Intelligence 84 (1996) 113-150 129 cons(P) = -[in(+l)I. The algorithm shown and a closure of A, S, into a propositional A. The appealing features of PAJ are summarized theory, Pb,s, that characterizes in the following theorems. in Fig. 2 compiles a given finite propositional default theory A the models of Theorem 4.2. Let A be a finite acyclic default classical model for PA,s iff 8 is a model for A. theory and S a closure of A. 13 is a Algorithm TRANSLATE-l begin: Step 1. PA,, = 0 Step 2. %,s = %,s + {L ( c E W} Step 3. PA,S =%,s+{in(~~)Acons(/?~)A~~~Acons(/3~) Step 4. PA,S = PA,S + {I,[ Step 5. PAJ = PAJ + {L, A I,, II L, 1 CI,CZ,C~ Step 6. For each atomic clause c, define: 2 Ic2 ) cl, c2 E ST cl c c2) > I, ) cr: /~I,...,/%/c E D} E S, and c3 E res(q,c2)} SC = {cl 1 cl E S and cl c c} R, = {(cI,c~) I CI,Q E S,C E res(ct,c2)) D,={(wP~,...,kh,) (~:PI,...,&‘cED} SUBSET-reasons(c) = V in(q ) Cl ES< 1 [ RESOLUTION-reasons(c) = [in(cl) A idc2) V (QXZ)E~L [ 1 1 DEFAULT-reasons(c) = V (4I....$“,E& I [in(a) Acons(j31) A-b-Acons(Pn)] Step 7. For each atomic clause c $i! W, if SC U R, U D, = 8, then PAJ = PA,S + {I, > false}; else PA,s = P~,s + {I, > [SUBSET-reasons(c) V RESOLUTION-reasons(c) V DEFAULT-reasons ( c) ] ) end. Fig. 2. An algorithm that translates an acyclic default theory into a propositional theory. 130 K. Ben-Eliyuhu, K. .!lrchter/Ani~ciul hleliigence 84 (1996) 113-150 Proof. PA,, states the conditions of Definition 3.13 in propositional weak model of an acyclic default 3.21 ), the assertion holds. is a mode1 of the default theory 0 logic, and since a theory (Theorem Corollary 4.3. Let A be u finite default closure of A, S. Suppose and let E = {c / c t S, 8 f= I(.}. Therl theory which is acyclic with respect to some Ipj.s is satisjiable and 8 = (S, f ) is a classical model for ?A,s, ( I ) E* is au extension of A. ( 2 ) E contains all its prime implicates (that is, PI(E) C: E). Proof. The first claim follows from Theorems 4.2 and 3.17. To prove the second claim, implicate of E and it is not a tautology. By definition of S, and suppose c is a prime c t S. Then, by the definition of PA,, and since 8 is since 3 has a consistent a model for P,,,$, it must be the case that 0 b f,.. So c E E. extension, 0 5. Translating cyclic default theories So t‘ar we have shown that for any finite acyclic default find a propositional theory, PA,J, such theory A and a closure is a if 0 = (S, f) that for default theory, Ihr P~,,s, then 0 is a model theories the questions of coherence, membership that might have cycles. This will for A. In this section we will general- that for re- satisfiability. We will use Theorem 3.19, which suggests the- that the interpretations imply and entailment in the default are grounded to solving propositional to verify 01‘ -I, S. WC can classical model i/e this result any finite default duct the use of indices ory. When finite default theories are under consideration, the requirement an index and the other’s can be expressed the fact that each atomic clause that an index of one atomic clause will be is assigned logic. Let #c stand for “the lower than stand for “the number associated with index associated with c”, and let [#cl < #c:] for (‘1 is less than the number associated with ~2”. We use these notations as shortcuts formulas (see Appendix B). Using these new index variables and formulas, we can express the conditions of Theorem 3.19 in propositional logic that express these assertions in propositional in propositional logic. The size of the formulas #c and to enforce indices we need. Note ine GA,J (the dependency of a default a prerequisite need for clauses never have to solve cyclicity between of the index variables common cycle. further by the maxima1 [ I 1. in G,,s that reside on cycles the partial order among that we do not have to index all the clauses is polynomial [#cl < #cz] in the range of the in S. We exam- graph of A with respect in to S): is not on a cycle with the default consequent, we do not Indices are needed only since we will the range that share a that do not share a cycle, number of clauses in the dependency two clauses If a clause appearing graph. Furthermore, two clauses. these is bounded by the maximum In fact, we can show that the index variable’s range can be bounded length of an acyclic path in any strongly connected component R. Ben-Eliyahu. R. Dechter/Artijcial Intelligence 84 (1996) 113-150 131 The strongly connected components that for each subset C in the partition of a directed graph are a partition of its set of and for each x,y E C, there are nodes such directed paths from x to y and from y to x in G. The strongly connected can be identified default is acyclic, we do not need any indexing. in linear theory time [ 351. Note that, as also implied by Theorem 3.21, if the components We summarize all the above discussions with an algorithm theory A and a closure of A, S. In addition finite default the algorithm uses a two-place macro of c”, or, in other words, “CY is true, and, for each clause c’ E cy, if c and c’ are in the same component lower than the index of c”. graph, then the index of c’ is strictly in( LY, c) which means “a to the one-place macro is true independently in the dependency for computing P4,s for a in( ), in( (Y, c) is defined as follows. I6 The function ( 1) If LY is a tautology, (2) then in( (Y, c) = true. If LY = c’ where c’ is a clause not in the same component graph as c, then in( (Y, c) = Z,, . If LY = c’ where c’ is a clause as c, then in(a,c) If CY = ci A.. then = A\l<iGnin(ci,c). If (Y is not in CNF, then in(ar,c) =in(CNF(a),c). in the same component = [I,/ A [#c’ <#cl]. . A c,, in(a,c) (3) (4) (5) Except for Step 6, which to algorithm TRANSLATE-l. in the dependency in the dependency graph is shown in Fig. 3, algorithm TRANSLATE-2 is identical The following theorems summarize the properties of our transformation. In all of these theorems, PA,J is the set of formulas theory A and a closure of A, S, using algorithm TRANSLATE-2 resulting translating from a finite propositional (see Fig. 3). Theorem 5.1. Let A be a default theory. Suppose %,s model for PA-~, and let E = {c 1 c is atomic, 8 /= Zc}. Then: is satisjable and 8 is a classical ( 1) E* is an extension of A. (2) E contains all its prime implicates. Proof. Part ( 1) follows conditions (2) from Theorem 3.17 and the observation of Definition 3.13 and Theorem 3.19 in propositional to the proof of part (2) of Corollary 4.3. is very similar that P4,s expresses the logic. The proof of part 0 Theorem 5.2. For each extension E* for a default P*,s such that a clause c is in E* iflO b c. theory A, there is a model 0 for Proof. Follows Theorem 5.1 above. from Theorem 0 3.17 and arguments similar to those used in proving These two theorems suggest a necessary and sufficient condition for the coherence of a finite propositional theory: I6 Note that in(a, c) may be undefined when c or (Y contains a non-atomic since we will use it only when this situation does not occur. clause, but that is not problematic 132 R. Ben-Eliyuhu, R. Dechter/Artijicial Intelligence 84 (1996) 113-150 Algorithm TRANSLATE-2, Step 6 Step 6. For each atomic clause c, define: S,. = {cl ) c,cl E S and cl c c} R, = {(c,,q) 1 cI,c2 E S, c E res(c,,c2)) Dc={(a,P,r . . . . Pi,) la:P~, . . . . P,,/ceD} SUBSET-reasons(c) = [(L, ir*(c,,c)] RESOLUTION-reasons ( c) = (~,~Fx~[in(cI,c) Ain(c*,c)l i I DEFAULT-reasons (c) = v (%Pl.....fA,)EJL [ in(a, c) A cons( p, ) A A cons( &) ] I Fig. 3. Step 6 of algorithm TRANSLATE2 Corollary 5.3. A default theory A has an extension iff P,,s is satisfiable. Corollary 5.4. A set of clauses T is contained there is a model 0 for P,,s such that for each c E T, B b in(c). in an extension of a defautt theory A iff Corollary 5.5. A clause c is in every extension of a default for P,,s satisfies in other words, iff PA,.7 k in(c). in(c), theory A @each model 0 These theorems suggest that we can first translate a given finite propositional theory A to P,,s and then answer queries as follows: To test whether A has an extension, we test satisfiability we test satisfiability in every extension, we test whether PA,, entails in some extension, / c E T}; and to determine whether T is included of Pd,s; to see whether a set T of clauses of PA.S + {in(c) [ /jcET in(c) 1. is a member the formula 5.1. Complexity considerations Clearly, the transformation presented above is exponential then are tractable subsets. For example, (2-DT), propositional is polynomial 2-DT is defined below. Note that this class is a superset of network default normal if the default theory is what we call a 2-default can be done the transformation theory produced in Sections 1.1.2 and 1.1.3. logic programs, discussed in the size of the default in polynomial in general. However, there theory time and the size of the theory. The class theories and R. Ben-Eliyahu, R. Dechter/Artijcial Intelligence 84 (1996) 113-150 133 Definition 5.6. A 2-default theory (2-DT) all the formulas in W are in 2-CNF and, for each default (Y : PI,. in 2-CNF, each /3i is in 2-DNF, and y is a clause of size 2 or less. is a propositional default theory A where in D, a is . . ,p,,/y A step-by-step analysis of the complexity of algorithm TRANSLATE-2 for a default theory A = (D, W) that belongs to the class 2-DT is shown below. Let n be the number of letters in .C, the language upon which A is built, and let d be the maximum size of a default (the total number of characters used to write it). the set of We assume that S, which is the closure of A, is the union of prime(A), all clauses appearing in A, and the set of all clauses that appear in the CNF of all negations of justifications. l7 Note that S can be computed in 0(n3 + ID(d) steps. I8 We denote by 1 the length of the longest acyclic path in any component of Gd,s, by d, the maximal number of defaults having the conclusion c, and by r the maximal number of pairs of clauses in S that yield the same clause when resolved. Note that r < n. Let p denote the maximum number of clauses that appear in any prerequisite and reside on the same cycle in the dependency graph (note that p is smaller than d and smaller or equal to the size of any component in the dependency graph, so P < min(d,n)). Step 2: Takes O(n*) time. Produces no more than O(n*) formulas of size 1. Step 3: The reason we require the justification to be in 2-DNF is that we can transfer the negation of it into a 2-CNF representation in linear time. So Step 3 can be done in time O(IDJd) and (DI f ormulas of size O(d) are generated. Steps 4-5: There are at most O(n*) clauses of size < 2. It takes O(n*) time to find all pairs cl, c2 such that cl c c2 (one way to do this, is to allocate an array of size 2n and store all clause with a common literal in the same bucket, and then produce all such pairs). Therefore, Step 4 takes O(n*) time and produces O(n*) formulas of size 2. Similarly, Step 5 takes O(n3) time (use the same array as in Step 4, but this time you have to go over two different buckets: the one for an atom, and the one for its negation), and produces 0(n3) formulas of size 3. Steps 6-7: For this step, we first have to build the dependency graph of A with respect to S. This takes 0( ri* + JDld) time. We assume that at the end of the graph-building phase, there is a pointer from each clause to its component and to all the defaults for which the clause is a conclusion. For each clause c in S, the size of S, is 6 2 , the size of R, is O(r), and the size of D, is 0( d,). For any clause c’, computing in( c’, c) takes 0( E*) time and produces a formula of size 0(1*); takes 0( 1*p) time and produces a formula of size 0(1*p). Therefore, for each clause c, computing takes 0( 1*) time and produces a formula of size 0( E*). Computing SUBSET-reasons DEFAULT-reasons takes 0( d,( d + pl*) ) time and produces a formula of this size. Computing RESOLUTION-reasons time and produces a formula of size O(r). Since we have O(n*) clauses, the whole step takes O(n*(1* + n*> + IDJ(d + for any prerequisite a, computing takes O(n*) in(cr, c) I7 Note that the justifications are in 2-DNF, and hence their negation translates very easily into a 2-CNE ‘* The reader can verify that the set of prime implicates of a set of clauses of size 2 can be computed in time 0(n3) where n is the number of letters in the language. of the translation theories p = 1 = I. The complexity 134 R. Ben-Eliyahu, R. Lkchter/Anificial lnlelligence 84 (1996) I IS-150 time and produces O(n*) formulas of size O(max(d,(d + pl*),r)). Note that ~1’)) lnax(d,(d+p12),r) < d,.(d+nl*). Proposition 5.7. For 2-DT, the above transformation takes 0( n2 ( l2 + n2) + ID ( (d + pl*)) time andproduces O(max(n-‘, ID])) formulas ofsize O(d,(d +n12)). The above proposition shows that there is a direct connection between and the cyclicity of the default theory translated, the complexity for acyclic since logic show that the satisfiability existence and membership logic is polynomially default extension in propositional 2-DT. Their results establish and the co-NP-hardness transformation existence, membership, we conclude the following: to satisfiability results obtained by Kautz and Selman [33] for to deciding in a subset of the class 2-DT, and that entailment [ 191 and Stillman is polynomially reducible problem reducible for a subset of the class the NP-hardness of the existence and membership problems for the class 2-DT. The polynomial to entailment of the entailment problem that we have presented that are in NP or in co-NP for the class 2-DT. Hence in the last section implies and entailment Corollary 5.8. The coherence problem NP-complete. (i.e. extension existence) for the class 2-DT is Corollary 5.9. Set-membership for the class 2-DT is NP-complete. Proof. By Corollary 5.4, in order to check if a theory T is contained of a 2-DT A, we should check whether PA., U in(T), where in(T) = {in(c) satisfiable. Since A is 2-DT both P A,J and in(T) in the size of A and T. can be computed 0 in some extension ) c E T}, is in time polynomial Corollary 5.10. Set-entailment ,for the class 2-DT is co-NP-complete. Proof. Follows from Corollary 5.5 above. i7 6. Tractable subsets for default logic Once queries on a default any of a number of techniques in default shown that it is reducible theory are reduced and heuristics to propositional to answer satisfiability, we can use them. For instance, entailment logic can be solved using any complete resolution technique, since we have to entailment in propositional logic. Our approach is useful especially for the class 2-DT, since our algorithm a 2-DT in polynomial queries on the knowledge subclass of 2-DT that translates a tractable subset for default time. So if a 2-DT translates it represents can be answered efficiently. compiles into an easy satisfiability problem, In other words, each is theories satisfiability into a tractable subclass of propositional logic. Consequently, we can identify easy default R. Ben-Eliyahu, R. Dechter/Artijcial Intelligence 84 (1996) 113-150 135 for default the characteristics of 2-DT that would translate into tractable propositional by analyzing theories. We will give an example of such a process by showing how some techniques developed by the constraints-based reasoning community can be used to identify new tractable subsets Constraint-based a set of constraints constraints. Some finding a setting through problem in terms of such of such constraints, and for specified, exploit the structure of the that will satisfy all the constraints the notion of a constraint graph. reasoning on some entities, without specifying methods the satisfiability for formulating is a paradigm for satisfying for testing knowledge techniques logic. The problem of the satisfiability of a propositional theory can be also formulated as related problem. These include a constraint satisfaction problem graph associates a node with each propositional associated were shown as crucially the satisfiability the size of the cycle-cutset, graph, and the size of the non-separable components [ 7,8,15]. the worst-case one of these parameters. Since processing of the graph, For instance, when the constraint graph is a tree, satisfiability time. (CSP) . For a propositional CNP theory, the constraint letter and connects any two nodes whose letters appear in the same clause. Various parameters of the constraints graph to the complexity of solving CSP and hence to solving the induced width, w* (also called tree width), the depth of a depth-first search spanning tree of this that bounded by any easily by a simple ahead of time. in linear these parameters they can be used for bounding It can be shown can be answered can be bounded is polynomially the complexity of deciding consistency complexity In the sequel we will focus on two specific CSP techniques: tree-clustering [9] and cycle-cutset decomposition [ 71. graph, while of the former is exponentially The tree-clustering The complexity constraint the complexity database generated by the tree-building building resulting details about tree-clustering in Appendix C. the tree tree is manageable scheme has a tree-building phase and a query-processing phase. of the dependent in the size of the even when the size of the and many queries on the same theory are expected. More in default logic can be found of the latter is always preprocessing it may pay off when phase. Consequently, on the sparseness and its application is computationally to reasoning expensive, linear One of the advantages of applying tree-clustering to default reasoning to assess the cost of the whole process by examining the default is that it is theory prior to the tractability of default theories as a function possible the translation of the topology of their interaction graph. step. We will characterize The interaction graph of a default theory A and a closure of A, S, is an undirected graph where each clause every default in S is associated with a node. Arcs are added such that for CI /I~..~cCn:d,,+ ,,.... d,,,, CO there are arcs connecting every exist c” such that c = res( c’, c”). two clauses c and c’ are connected co, cl,. . . , c,,, CM’( ldn+l), in a clique; . . . , CNF( ld,,+,,,) iff they can be resolved, or c C c’, or there 136 R. Ben-Eliyuhu. R. Dechter/Art$cial Intelligence 84 (1996) 113-150 A chord of’ a cycle is an arc connecting nodes in the cycle. A graph two non-adjacent iff every cycle of length at least 4 has a chord. The induced width (w*) of in any chordal graph that embeds in terms of the of our algorithm size of a maximal clique the complexity is chordal a graph G is the minimum G. t9 The next induced width (w*) of the interaction graph. summarizes theorem Theorem 6.1. For a 2-DT whose interaction graph has an induced width w* , existence, clause-membership, and set-entailment 2o can be decided in 0( (Y * 2w*+’ ) steps, where CY is polynomial in the size of the input. 2’ Note that w* is always at least as large as the size of the largest default in the theory, there are at most 2n2 clauses of size 6 2 in the language, w* < 2n2. We logic, the knowledge base to have a repetitive and since believe where the temporal persistence principle causes structure, as the following example demonstrates: is especially useful for temporal that this algorithm in default reasoning Example 6.2. Suppose not picked up by my husband, between during any time t; between theory I leave my son at the child-care services at time tt. If he was time t2 and t,,_l, I expect my son to be there in the following default t2 and t,. This can be formalized (D, W), where in D we have defaults of the form at-school ( t;) : at-school( t;+ I ) at-school ( ti,. I ) for i = 1, . . . , II -- 1, and in W we have formulas of the form: picked-at( ti) > Tat-school ( t;+ 1 ) fori=2,...,n- 1. For notational convenience, we abbreviate the above rules as follows: si : Si+l Si+ I The interaction S;, i = 1,. graph of this theory for the closure {si, us;, lpi, . , n - 1) is shown in Fig. 4. . ,n, for the Pi, i = 2,. ‘pi V -si+l} (for the The reader can verify that w* ,< 2 for this particular the number of time slots (n) grows, set-membership, coherence, linearly. Note of theories belongs NP-hard. that according the time complexity and set-entailment using to Selman and Kautz’s classification to a class for which the complexity of answering set of problems. Thus, as for answering queries about the tree-clustering method grows [ 191, this family is such queries ” A graph G’ embeds graph G iff G C G’ when we view graphs as sets of nodes and arcs. *” Recall the definition of these decision problems from Section I, I, I. ?’ The input is the default theory and the set of clauses for which we test membership or entailment. R. Ben-Eliyahu, R. Dechter/Artijicial Intelligence 84 (1996) 113-150 137 Fig. 4. Interaction graph for Example 6.2. The cycle-cutset algorithm is another method time, and that variable a cycle-cutset straint graph. The cycle-cutset method can be solved in linear nectivity of the constraint graph. The basic constitute that, once removed, remaining the rest of the problem. of the cycle-cutset exponentially this method, see [ 71. graph is a tree, and we can apply If no solution variables, render and so on. Clearly, bounded by the size of the cycle-cutset changes that exploits instantiation idea is to instantiate the structure of the con- is based on two facts: that tree-structured CSPs the effective con- that is a set of nodes the is instantiated, for solving instantiation tree algorithm is found, we have to try another a set of variables the linear-time of the constraint graph, where a cycle-cutset the graph cycle-free. After the cycle-cutset the complexity is that is used. For more details on of this approach We have the following complexity bound on reasoning tasks in 2-DT: Theorem 6.3. For a 2-DT whose interaction graph has a cycle-cutset of cardinal@ k, existence, clause-membership, and set-entailment can be decided in 0( a * zk) steps, where a is polynomial in the size of the input. 7. Relation to Clark’s predicate completion In this section we discuss the relationship between [6] made one of the first attempts the work presented here and to give to logic programs with negated atoms in a rule’s body (“normal programs”). Clark’s work on program completion. Clark meaning He shows how each normal program COMP( n), ZZ, the programmer program should be evaluated with respect the program iff COMP(l7) b Q. theory called its completion. His idea is that when a programmer writes a program the to COMP( II). So a formula Q is implied by Ii’ can be associated with a first-order actually has in mind COMP(IT), and thus all queries about For the comparison between Clark’s work and ours, we consider only normal propo- sitional programs, that is, a set of rules of the form Q t PI ,..., P,,,notRt ,..., notR, (14) where Q, PI,. . . , P,,, and RI,. . . , R, are atoms. As discussed in Section 1.1.3, normal logic programs can be viewed as disjunction- free default the default theories by taking W = 0 and by identifying a rule of the form (14) with 138 K. Ben-Eli.vuhu, K. Dechter/Artijiciul Intelligence 84 (I 996) I13-I.50 P, A.. A P,, : 7R1,. . , TR,,, Q Hence we can treat normal about extensions of normal ing default theories. logic programs as a subclass of all default theories, and talk logic programs: those are the extensions of their correspond- Given a propositional logic program Step 1: Replace each rule of the form ( 14) with the rule II, COMP( Z7) is obtained in two steps: Q + P, A. A f,, A -R, A A TR,,,. Step 2: For each symbol Q, let Support(Q) denote the set of all clauses with Q in the head. Suppose Support(Q) is the set Q-Body13 Q - Bodyk. Replace it with a single sentence, Q - Body, V v Bodyx. Note two special cases: If *‘Q +--” If Support(Q) is empty, replace it with 1Q. in Support(Q), simply replace Support(Q) by Q. Example 7.1. Consider the following program 77: P - Q, 7R. P-l! R - S, V-. The completion of 77 is the following propositional theory: P+-+[Q/\-R]vv R - S, 1! TS, -Q. (15) (16) (17) (18) (19) similarities There are interesting for the same logic program. it using algorithm TRANSLATE- 1, we get that PI, is the following is acyclic according If we take the program between COMP(f7) to our definitions): and the translation we provide in the previous example and translate theory (note that 77 R. Ben-Eliyahu, R. Dechter/Arti&ial Intelligence 84 (I 996) 113-1.50 Iv, IQA~IR>IP, IS 1 IR, Iv 3 IP, Ip > IQ A -'IR v IV, IR 1 IS, +,+Q,{~~L 1 L E {e Q,RS,V}}, {IL A 1,~ > false 1 L E {I? Q, R, S, V}}. 139 (20) (21) (22) (23) (24) (25) (26) (27) sentences Combining (22) and (25) and re- placing each symbol of the form IL, where L is positive, with L, we get the following equivalent and (24) and sentences to (15)-( 19)): (compare theory (21)) (23), P-[QATR]VY R t--) S, v 1s. (4,~ 1 L E {E Q, R, St V)}, {L A Z,L > false I L E {E Q, R & V)}. and that each model of the completion It is easy to see that each model for the above the program to be a model of the following previous work [ 31: theorem, which was proved theory independently is a model of the completion of of the program can be extended to a proof [ 131 and in our by Fages for this theory. The above example can easily be generalized Theorem 7.2. Let II be a normal acyclic propositional logic program. Then M is a model for COMP( Z7) iff {Ip 1 P E M} is a model for Pn. the theory obtained Proof (Sketch). Let 17 be an acyclic normal Ph P is an atom projected on C is equivalent logic program, C the language of 17, and each occurrence of the atom Zp, where in L: with the symbol P. It is easy to see that the set of models of 7’; to the set of models of COMP(lI). q from Pn by replacing Corollary 7.3. Let II be an acyclic normal propositional logic program. II has an extension iff COMP(l7) iff {P ( M(P) = true}* is consistent. Furthermore, M is a model for COMP(Il) is an extension of II. 140 R. Ben-Eliyuhu, R. Dechter/Artijiciul lnielli~ence 84 (1996) 113-1.50 Proof. Follows from the above theorem and Theorem 3.17. 0 Corollary 7.4. Let Il be an acyclic normal propositional is in the intersection of all the extensions of I7 iff COMP( I7) b P. logic program. An atom P Corollary 7.5. Let II be an acyclic normal propositional does not belong to any of the extensiorzs of II i# COMP( ZT) b 7P. logic program. An atom P the class of acyclic normal propositional logic semantics (under “skeptical reasoning”22 logic pro- ) is is different from Clark’s comple- The above observations identify grams as a class for which default equivalent to Clark’s predicate completion. Note that if r/ is a cyclic program, our translation tion: Example 7.6. Consider the following program ZIl: P + P. Q---P is the theory COMP(fIl) Ip 2 Ip A [#Ip < #III], that PI,, two models, true. PI,, has only one model, entails Q, while COMP(Z7,) the logical closure of {Q}. is the theory {P > P,P > PA in one of them P is true and Q is false, {P +~-- R Q -+ IO C-+ ~1~). Substituting ,P}. PII, [#P < #P],Q is the theory {Ip > Ip, lp with P and IQ with Q, we get ,P}. COMP(L71) has in the other P is false and Q is in which P is false and Q is true. Hence PII, is * does not entail Q. Indeed 171 has one extension which the model Another major difference between Clark’s completion logic and not only the subset default all propositional programs. and our work is that we handle logic that corresponds to normal 8. Conclusions and related work Reiter’s default logic is a useful formalism for nonmonotonic bility of default of conclusions for drawing such conclusions. logic, however, is limited by the lack of intuitive that the logic ratifies, and by the high computational reasoning. The applica- for the set required semantics complexity In this paper we have addressed some of these problems. We have shown how default logic, theories can be characterized by theories of the already well-studied propositional we have presented default that computes an extension theory, and we have identified new tractable default for any finite propositional theories. a procedure *’ “Skeptical answer sets. reasoning” means that a program entails an atom iff the atom belongs to all of the program’s R. Ben-Eliyahu, R. Dechter/Artificial Intelligence 84 (1996) 113-1.50 141 logic for a default of truth values it is consistent with of an AET as an assignment the usual to the notions of propositional interpretation of an auto-epistemic that are in the spirit of the semantics of Moore’s auto-epistemic and model The work presented here can also be viewed as an attempt to provide default logic with [ 271. theory are in some sense theory (AET) [27, Section 31. Moore defines a propositional semantics The concepts of meta-interpretation parallel and auto-epistemic model of an AET interpretation provided logic formula of the form LP, where L is the “belief” operator, as a propositional Similarly, we define a meta-interpretation to clauses AET T as an auto-epistemic and, (b) logic correspond to extensions shows that an AET T is stable epistemic model of T. We define a model the formulas theory. symbol). of a theory to be an assignment of truth values in the language of the theory. Moore defines an auto-epistemic model of an (a) all the formulas of T are true in auto-epistemic to be stable. Moore that is true in every auto- theory in such a way that all theory are an extension of the for a default satisfied by a certain model of the default in default iff T contains every formula for every formula P, LP is true iff P is in T. Expansions in the theory a (treating logic, and are supposed to the formulas interpretations interpretation for classical in which: Using the theory of meta-interpretations an algorithm theo- into a classical theory, such that models of the last coincide with extensions of the first. for propositional theory that compiles any finite default and models default theories are reducible to propositional explored. For instance, of a default theory, we no longer need satisfiability, in order to compute to logic is in default since the problem of entailment that queries on default ries, we presented propositional This means a problem whether compute or count all the extensions, provability. reduced that has been comprehensively is in every extension to propositional a formula In general, the translation algorithm to embed that membership DT, which is expressive enough leads to the observation is co-NP-complete identified reasoning Related for the class 2-DT. Using constraint subclasses tractable can be solved efficiently using results for auto-epistemic logic were reported the tree-clustering is exponential, but it is polynomial for the class 2- inheritance networks and logic programs. This and coherence are NP-complete and entailment of 2-DT. We have shown how problems satisfaction techniques, we have temporal in algorithm. in [24], where it was shown is reducible in every expansion provability. Also, Elkan that the question of an atom’s membership to propositional theory models of a logic program with no classical negation of propositional logic. In [ 31, we used a technique models of disjunctive relationship between predicate completion logic. Thus our work extends his results similar logic programs. We have also shown presented the translation [ 61. A preliminary [lo] has shown that stable as models for the full power of default stable that there is an interesting in this paper and what is called Clark’s to the one presented here for computing version of this work appears of an auto-epistemic can be represented in [ 21. There have been attempts reasoning monotonic [ 12,18,20,23]. We believe valuable of computational since classical knowledge. in the past to relate default systems, such as auto-epistemic default that embedding logic is a well-understood logic logic, circumscription, logic in classical formalism to other forms of non- and TMS logic is just as supported by a large body 142 K. LIeen-Eliyhu. K. L)echter/Art@iul Intelligence 84 (1996) l/3-/50 Appendix A. Proofs A. 1. Useful theorem and definitions Definition A.1 (see [ 22 ] ). If S is any set of clauses, by R(S), the pairs of members of S. is the set consisting then the resolution of S, denoted of the members of S together with all the resolvents of Definition A.2 (see 1221). If S is any set of clauses, denoted by R”(S), of S, then for n 3 0 as follows: R” = S, and for II > 0, R”+’ (S) = the nth resolution is delined R(R”(S)). Theorem A.3 (see [ 22 ] ). Given a set S of clauses, sequence of S wlhich is not a tuutology, c’ E R”(S) , .such that c’ C c. if a clause c is a logical con- then for some n 3 0, there exists a clause Proposition A.4 c E res( ~1, ~2). Then at least one of the following Suppose c’, ~‘1, c, c{ md ci are clauses, c{ i cl, ci C c2, and conditions must hold: ( 1) c; c: c. (2) c; c c. (3) There is c’ C c such that c’ E res(cl,cij. Proof. suppose C] =qvz? c2 = ca v -P, c = q v c.$. and suppose that both conditions ( 1) and (2) do not hold. Then it must be that c; = cs v P, c; = Ch v -P, where q of ci and ci and a subset of c. is a subset of ci and cb is a subset of cd. Clearly, cg V c(j is both a resolvent Theorem AS. consistent extension iff W is inconsistent. (see [29, Corollary 2.21) A closed default theory (D, W) has an in- A.2. Proofs of propositions und theorems Proposition 3.7 (prime(A) closure of A. is a closure)). Let A be a default theory. prime(A) is a Proof. Suppose E is an extension of A = (D, W). Since Pl( E) C E, it is sufficient to show that for each c E E there is a clause c’ in prime(A) such that c’ c c. If E so n E PZ( W), and so A E is inconsistent, then by Theorem A.5, W is inconsistent, R. Ben-Eliyahu, R. Dechter/Artificial Intelligence 84 (1996) 113-150 143 ptime( A). Suppose E is consistent. By Definition where Ei is as defined prime(A) the minimum 1.1, for some ordering, E = Us Ei, there. We will show that for each c E E, there is a clause c’ in fl E such that c’ C_ c. The proof is by induction on min(c), where min( c) is i such that c E Ei. PZ( W) c prime(A) Case min( c) = 0. In fl E. Induction step. Assume this case, it must be that c E W. Our claim is true since the claim is true for min(c) = n, where n > 0, show that it is true for n + 1. Note that c # A, since E is consistent. Suppose c was introduced such that c” 2 c. We will show by induction on a minimum first at E,,+l. So either c E CD or E, b c. If c E CD, then clearly our assertion holds. Assume E, k c. By Theorem A.3, for some j, there is c” E Rj(E,,) such j is c’ E prime(A) n E such that c’ G c. For j = 0, this is clear due to the that there in R’( E,), 1 < j, such that hypothesis on n. For j > 0, let cl, c2 be clauses induction there are c{, ci in prime(A) n E such c” E res( cl, ~2). By the induction that ci C cl, ci G ~2. By Proposition A.4, either c{ C c” or CL 2 c” or there is c3 in res( c{ , c&) such that c3 & c”. ptime( A) n E is closed by resolution the resolvent is A, but cg E E and hence c3 + A). So cg E prime(A) n E. hypothesis, (unless Theorem 3.17 (Model-extension). for A iff there is a model 19 for A such that E = {s 1 8 b s}. Let A be a default theory. A theory E is an extension Proof. Let A = (D, W) be a default set of all clauses We define that B satisfies. We will show that A is an extension23 of A. theory and 0 = (S, f) a model of A. Let A be the (1) Eo=W, (2) for i > 0, EL+, = Et! U {C ( LY : PI,. -/?,, $ A and c E A}, and . . ,&/c E D where (Y E Ei and --~pi,. . . , (3) E=&EEi. It is easy to verify A is an extension of A. that E C A. We will show that A 2 E, and thus by Definition 1.1, Let c E A. By definition, c has a proof with respect the number of defaults used in the shortest proof, we can easily show that c E E. to (S, f) and A. By induction on To prove the other direction, suppose E is an extension of A. Let S = prime( A). We will show that 0 = (S, f’) is a model of A, where f’ is defined as forallcES, f’(c>=true w CEE. It is easy to verify are sets Eo, El,. . . such that that 0 is deductively closed and satisfies A. By Definition 1.1, there (1) Eo=W, (2) for i > 0, Ei+l = Ef U {c 1 a : 01,. . . ,P,,/c -A, $! E}, and (3) E=UsEi. E D where LY 6 Ei and lpi,. . . , 23 Without loss of generality, we assume in this proof that an extension is a set of clauses, and all formulas in A are in CNF. 144 H. Ben-Eliycthu, Ii. LIechter/Artificid lntellrgence 84 (1996) 113-150 on the minimal i such that an arbitrary clause c belongs By induction show that c has a proof with respect has a proof with respect atomic clause. By induction on i, the minimum c, we will show that one of the conditions of Definition 3.11 holds for c. to E,, we can to 0 and A. So every atomic clause that 19 satisfies to 6’ and A. It is left to show that B is based on A. Let c be an number of defaults used in a proof for Case i = 0. It must be the case that W b c, and hence c is in every extension of A. Let E be an extension of A. Since S includes all prime implicates of E, and 0 satisfies c, there must be a clause c’ E S such that c’ C c and 8 satisfies c’. If c’ # c we are implicate of E, and so there must be two clauses cl, c2 in E done. Else, c is a prime such that c E res(ct , c2 1. By definition, 8 satisfies CI and ~2. So item (3) of Definition 3.11 holds for c. Case i > 0. So either c is a consequence of some default S and item (5) of Definition of some set of clauses C C E, in which 3.11 holds for c, or c is a logical consequence case one of items ( l)-(3) must hold for c. q Theorem 3.19 there conditions hold: is a function (1) CE w #p(c) (2) (Indexing and proofs). A weak model 0 = (S, f) for A is a model iff p : S + N+ such that for each atomic clause c the following =o. If c $! W then at least one of the following (a) There is a default 6 = a : PI, conditions hold does not satisfjt any of -/3,, and for all cl E CNF( a), clause c2 C cl such that p(q) < p(c). . . , p,/c E D such that 8 satisfies a and there is an atomic (b) There are two atomic clauses cl and c2 such that c is a resolvent of cl and CZ, B satisjiesc) andc2, andp(cl),p(cz) <p(c). (c) There is an atomic clause c’ c c such that 0 /z c’ and p(c’) < p(c). Proof. We can show that each atomic clause has a proof with respect induction on p(c). to 0 and A by Case p(c) = 0. In this case c t W, so clearly c has a proof. Case p(c) > 0. In this case c follows from other clauses using classical logic or the default rules. Those other clauses have proofs by the induction hypothesis. Hence c has a proof as well. 0 Theorem 3.21 acyclic default (Models theory A, then 6 is a model for A. for acyclic theories). If 0 = (S, f) is a weak model for an Proof. If the theory complies with the requirements is acyclic, the dependency stated in Theorem 3.19. q graph induces on S an ordering that Theorem 3.23 (Minimality weak model for A. of models). Ever?; model of a default theory A is a minimal Proof. Suppose want to show it is minimal. By definition, that 8 = (S, f) is a model for A. Obviously, it is a weak model. We for each atomic clause c in S there is a proof R. Ben-Eliyahu, R. Dechter/Artijicial Inielligence 84 (1996) 113-150 145 of c with respect must be a weak model 8’ = (S, f’) such that A- c A, where to 0 and A. Assume by contradiction that 8 is not minimal. So there A- = {c ) c is atomic, f’(c) = true}, A = {c 1 c is atomic, f(c) = true}. We will show that if c has a proof with respect and so A C_ A--a of defaults used in the proof of c. If n = 0, the assertion event that the proof of c uses the defaults 61,. . . , &+I, we observe, using hypothesis, 8’ must satisfy A, it must also satisfy concl(6 ,,+I), and since it is deductively must satisfy W U {concf(St ), . . . , co&( &+I)}*, to A and 13, it must be satisfied by 0’, contradiction. The proof will proceed by induction on n, the number is clear since c E W*. In the the induction since it that ( W U {concl( 61) , . . . , concl( 6,))) * is satisfied by 8’. Therefore, so it satisfies c. closed, 0 Theorem 6.3. For a 2-DT whose interaction graph has a cycle-cutset of canfinality k, existence, clause-membership, and set-entailment can be decided in O(a * 2&) steps, where cy is polynomial in the size of the input. interaction in the theory in time polynomial 5.3, A is coherent in time 0( a12~), where cq is polynomial in time O(cu02~) where CEO is polynomial theory A with a closure S is isomorphic of a theory whose constraint graph has a cycle-cutset of cardinality in time 0(n2k), where n is the number of letters graph of a default [ 71. to the graph of PQ. Now, let A be a 2-DT with a closure S. Since A is a 2-DT, in the in S is of size 6 2, and P 4,~ can be computed Proof. Satisfiability k can be solved The constraint any clause length of A. Since the constraint graph of P A,J has a cycle-cutset of size k, satisfiability of P4,s can be checked in the size of P,Q. iff P 4,s is satisfiable. Hence coherence of A can be By Corollary checked in the size of the input. By Corollary 5.4, to check whether a clause c is a member of an extension of A, we have to check whether to S. Since A is 2-DT, there are at most 0( ]c12) clauses c’ such that c’ C c, c’ E S, and so clause-membership in time O(c~22~) where 9 in the size of the input. By Corollary 5.5, to answer whether a set of is polynomial clauses T is included there is some clause c in T which some model of P4.s does not satisfy. Hence we have to check whether for some c’ E S which is a subset of some c E T. Since A is 2-DT, for any c in T there are at most 0( ]c12> clauses c’ such that c’ C c, c’ E S, and so set-entailment in time for the class 2-DT can be computed in the size of the input. Take LY to be the maximum O(~q2~) where cq is polynomial of {q 1 i=O,1,2,3}. there is a model of P4,s which satisfies some subset of c which belongs in all the extensions of A, it is enough there is a model of PA,S that satisfies for the class 2-DT can be computed to check whether lc’ Cl Appendix B. Expressing indexes in propositional logic Suppose we are given a set of symbols L to each of which we want to assign an index variable within the range l-m. 146 R. Ben-Eliyahu. R. lkchter/Artijiciul Intelligence 84 (1996) 113-150 We define a new set of symbols: L’ = {e P = 1, P = 2,. , m denote propositional . , P = m / P E L}, where letters with the intuition “P will get the it. For each P in C’, let #P be the following set of formulas: P = i for i = 1,. number i” behind P=IVP=2V..+P=m. P=l > [-(P=2)A -~(P=3)~...,?~1(P=m)], P=2>[-(P=3)Am7(P=4)A..A7(P=m)], P=m- 13 T(P=m) simply states that p must be assigned one and only one number. The set #P For each P and Q in C’, let [#P< is less than the number of Q”, denote #Q], which intuitively means “the number of P the disjunction of the following set of formulas: P=IAQ=2,P=lAQ=3 ,..., P=IAQ=m, P=2AQ=3, . . . . P=2/IQ=m. P=m-lr\Q=m Thus, for each symbol P to which we want to assign an index, we add #P theory, and indexes. then we can use the notation [#P < #Q] to express to the the order between Appendix C. Tree-clustering for default reasoning The tree-clustering scheme [9] has a tree-building phase. The first phase of tree-clustering It uses the triangulation by adding edges to it [36]. The triangulation for the nodes Step 1. Select an ordering available). in Fig. C.1. algorithm, which transforms any graph into a chordal 24 graph is restated for propositional phase and a query-processing theories algorithm consists of two steps: (various heuristics for good orderings are Step 2. Fill in edges recursively between any two non-adjacent nodes that are con- nected via nodes higher up in the ordering. Since the most costly operation within the tree-building (Step 4), the time and space complexity all is 0( 17’)n21cl), the submodels of each clique where ICI is the size of the largest clique in Step 1, jTI the size of the theory and n is the number of letters used in T. It can be induced width, this shown that /Cl = w* + 1. As a result, for classes having a bounded method in the chordal constraint graph generated is generating is tractable. algorithm 24 A graph is chordal if every cycle of length at least 4 has a chord R. Ben-Eliyahu, R. Dechter/Artificial Intelligence 84 (1996) 113-150 147 ‘Ike-building(Z’, G) Input: A propositional Output: A tree representation theory T and its constraint graph G. of all the models of T. Step 1. Step 2. Step 3. Step 4. Step 5. . . , C, be all such each Ci to an ancestor Cj (j < i) with whom all the maximal cliques in the graph. Let Cl,. indexed by the rank of their highest nodes. Use the triangulation algorithm to generate a chordal constraint graph. Identify cliques Connect set of letters. The resulting graph is called a join tree. Compute Mi, from T composed only of letters in Ci. For each Ci and for each Cj adjacent every model M that has no model their common letters (this amounts tree). tree, delete from Mi in Mj that agrees with it on the set of to performing arc consistency on the join the set of models over Ci that satisfy the set of all formulas to Ci in the join the largest it shares Fig. C. I. Propositional tree-clustering: tree-building phase. Once the tree is built it always allows an efficient query-answering process, types of queries is linear in the size of the tree generated phase is described below (m bounds the number of submodels that is, the [9]. for cost of answering many The query-processing each clique) : Propositional tree-clustering-query processing. (1) T is satisfiable iff none of the Mi is empty, a property that can be checked in O(n). (2) To see whether there (respectively in which some letter P is true (respectively in a table, and thus will be linear does not satisfy) P. This amounts is a model select a clique containing P and test whether one of its a in m. To check whether a set of letters to that satisfies if the letters are scattered over several cliques, we temporarily false), we arbitrarily models satisfies column A is satisfied by some common model, we test whether all the letters belong one cluster Ci. If SO, we check whether A. Otherwise, that disagree with A, and then re- eliminate apply arc consistency. A model satisfying A exists iff none of the resulting Mi becomes empty. The complexity of this step is O( 1 Alnm log m) . from each such clique all models to scanning is a model in Mi there We next summarize the class 2-DT25 the number of submodels extensions that the theory has): how tree-clustering can be applied (now n stands for the number of symbols reasoning within theory, m for in each clique; note that m is bounded by the number of the to default in the default 25 The process described here can be applied appropriate only for 2-DTs. to any default theory. The complexity analysis is the only issue 148 R. Ben-Eliyahu. R. Lkchter/ArtiJic~al Intelligence 84 (1996) 113-150 (1) (2) (3) I 1. tree: (b) the default theory into a propositional from the propositional theory T (See Section 5.1) formulas using the tree-building (takes O( ITI n* * exp( w* + 1) ) time, where ITI is the size of the theory theory using the produced is an extension, If so, no extension exists (bounded by 0( n*) steps). Translate Build a default database method generated at Step Answer queries on the default (a) To answer whether there clique. To find an extension, solve arbitrary node C; in the join each of its neighbors Cj a model M., that agrees with Mi on common combine all these models, and continue on. The set of all models can be generated by exhausting that agree on their common of submodels bounded by O( n* * m) steps). To answer whether check whether the tree in a backtrack-free manner: Pick an tree, select a model Mi from M;, select from letters, to the neighbors’s neighbors, and so there is an extension there is a model satisfying that satisfies a clause c of size k, (finding one model all combinations is an empty test whether letters there (cl is (this the extensions, takes 0( k2n2m log m) steps). To answer whether c is included in all check whether there is a solution that satisfies (bounded by 0( k’n’m logm) steps). Acknowledgements We thank Gerhard Brewka and Kurt Konolige version of this paper and Judea Pearl and Mirek Truszczynski and Vladimir Lifschitz drew our attention Michael Gelfond and Clark’s predicate completion. between our translation for very useful comments on an earlier for fruitful discussions. to the close connection in part by grants This work was supported from the Air Force Office of Scientific Research, AFOSR 900136, by NSF grants IRI-92009 18 and IRI-9 1573636, by Northrop from Toshiba of MICRO grant 92-123, by Rockwell MICRO grant 92-122, by grants America and Xerox Palo Alto research center, and by an IBM graduate to fellowship the first author. References I I I R. Ben-Eliyahu, Nonmonotonic reasoning in classical logic, Ph.D. Thesis, University of California, Los Angeles, CA ( 1993). R. Ben-Eliyahu, R. Dechter/Artijkial Intelligence 84 (1996) 113-150 149 [2] R. Ben-Eliyahu and R. Dechter, Default logic, propositional logic and constraints, in: Proceedings AAAI-91, Anaheim, CA (1991) 379-385. [3] R. Ben-Ehyahu and R. Dechter, Propositional semantics for disjunctive logic programs, Ann. Math. Artif: Intell. 12 (1994) 53-87; short version in: Proceedings 1992 Joint International Conference and Symposium on Logic Programming ( 1992). [ 41 N. Bidoit and C. Froidevaux, Minimalism subsumes default logic and circumscription in stratified logic programming, in: Proceedings IEEE Symposium on Logic in Computer Science, Ithaca, NY ( 1987) 89-97. [ 5 ] C.-L. Chang and R.C.-T. Lee, Symbolic Logic and Mechanical Theorem Proving (Academic Press, New York, 1987). ]6] K.L. Clark, Negation as failure, in: H. Gallaire and J. Minker, eds., Logic and Databases (Plenum Press, New York, 1978) 293-322. [7] R. Dechter, Enhancement schemes for constraint processing: backjumping, learning, and cutset decomposition, Artif: Intell. 41 (1990) 273-312. [ 81 R. Dechter and .I. Pearl, Network-based heuristics for constraint satisfaction problems, Artif Intell. 34 (1988) l-38. 191 R. Dechter and J. Pearl, Tree clustering for constraint networks, Artif Intell. 38 (1989) 353-366. [ lo] C. Elkan, A rational reconstruction of nonmonotonic truth maintenance systems, Artif lntell. 43 (1990) 219-234. [ 111 D.W. Etherington, Formalizing nonmonotonic reasoning systems, Artif Intell. 31 ( 1987) 41-85. [ 121 D.W. Etherington, Relating default logic and circumscription, in: Proceedings IJCAI-87, Milan, Italy (1987) 489-494. [ 131 F. Fages, Consistency of Clark’s completion and existence of stable models, Meth. Logic Comput. Sci. 2 (1992). [ 141 K. Fine, The justification of negation as failure, Logic Meth. Philos. Sci. 8 ( 1989) 263-301. [ 151 E.C. Freuder, A sufficient condition for backtrack-bounded search, J. ACM 32 (1985) 755-761. [ 161 M. Gelfond and V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Comput. 9 (1991) 365-385. [ 171 G. Gottlob, Complexity results for nonmonotonic logics, J. Logic Comput. 2 (1992) 397-425. [ 181 U. Junker and K. Konolige, Computing the extensions of autoepistemic and default logics with a TMS, in: Proceedings AAAI-90, Boston, MA (1990) 278-283. [ 191 H.A. Kautz and B. Selman, Hard problems for simple default logic?,, Artif Intell. 49 (1991) 243-279. [ 201 K. Konolige, On the relation between default and autoepistemic logic, Artif Intell. 35 (1988) 343-382. [21] R.A. Kowalski and C.J. Hogger, Logic programming, in: S.C. Shapiro, ed., Encyclopedia of Artificial Intelligence (Wiley, New York, 2nd ed., 1992) 873-891. [ 221 C.-T. Lee, A completeness theorem and a Computer Program for finding theorems derivable from given axioms, Ph.D. Thesis, University of California, Berkeley, CA (1967). [23] W. Marek and M. Tmszczynski, Relating autoepistemic and default logic, in: R.J. Brachman, H.J. Levesque and R. Reiter, eds., Proceedings First International Conference on Principles of Knowledge Representation and Reasoning, Toronto, Ont. (Morgan Kaufmann, San Mateo, CA (1989) 276-288. 1241 W. Marek and M. Truszczynski, Computing intersection of autoepistemic expansions, in: Proceedings First International Workshop on Logic Programming and Non-Monotonic Reasoning, Washington, DC (1991) 37-50. (251 R.E. Mercer, Using default logic to derive natural language presupposition, in: R. Goebel, ed., Proceedings Seventh Biennial Conference of the Canadian Society for Computational Studies of Intelligence, Edmonton, Alta. (Morgan Kaufmann, Los Altos, CA, 1988) 14-21. [ 261 E. Minicozzi and R. Reiter, A note on linear resolution strategies in consequence-finding, Arts Intell. 3 (1972) 175-180. [27] R.C. Moore, Semantical consideration on nonmonotonic logic, Artif Intell. 25 (1985) 75-94. [28] C.R. Perrault, An application of default logic to speech act theory, Tech. Rept. CSLI-87-90, SRI International, Menlo Park, CA ( 1987). [29] R. Reiter, A logic for default reasoning, Artif Intell. 13 ( 1980) 81-132. [30] R. Reiter, A theory of diagnosis from first principles, Artif Intell. 32 ( 1987) 57-95. [ 3 1 ] R. Reiter, Personal communication ( 1992). 150 K. Ben-Eliyahu, K. Dechter/Art$icial Intelligence X4 (1996) 113-150 1321 R. Reiter and J. de Kleer. Foundations of assumption-based truth maintenance systems: preliminary in: Proceedings AAAI-87, Seattle, WA ( 1987) I83- 188. of membership It’s not my default: the complexity problems in restricted propositional in: Proceedings AAAI-90. Boston. MA ( 1990) 571-578. report, I33 1 J. Stillman, default logics, 134 1 .I. Stillman, The complexity of propositional default logics, in: Proceedings AAAI-92, San Jose, CA ( 1992) 794-799. ( 35 1 R. Tarjan, Depth-first I36 1 R.E. Tarjan and M. Yannakakis, Simple linear-time algorithms search and linear graph algorithms, SIAM J. Cornput. 1 ( 1972) 146-160. to test chordality of graphs, test acyclicity of hypetgraphs I37 1 D.S. Touretzky, and selectively Implicit ordering of defaults reduce acyclic hypergraphs, SIAM J. Comput. 13 ( 1984) 566-579. systems. in: Proceedings AAAI-84, Austin, in inheritance TX (1984) 322-325. 