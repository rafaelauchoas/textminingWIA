Artificial Intelligence 172 (2008) 1837–1872Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintOutlier detection using default reasoning ✩Fabrizio Angiulli a, Rachel Ben-Eliyahu – Zohary b,∗,1, Luigi Palopoli aa DEIS, Università della Calabria, Via Pietro Bucci 41C, 87036 Rende (CS), Italyb Ben-Gurion University and Jerusalem College of Engineering, Beer-Sheva/Jerusalem, Israela r t i c l ei n f oa b s t r a c tArticle history:Received 5 March 2007Received in revised form 9 July 2008Accepted 29 July 2008Available online 15 August 2008Keywords:Default logicDisjunctive logic programmingKnowledge representationNonmonotonic reasoningComputational complexityData miningOutlier detection1. IntroductionDefault logics are usually used to describe the regular behavior and normal properties ofdomain elements. In this paper we suggest, conversely, that the framework of default logicscan be exploited for detecting outliers. Outliers are observations expressed by sets of literalsthat feature unexpected semantical characteristics. These sets of literals are selected amongthose explicitly embodied in the given knowledge base. Hence, essentially we perceiveoutlier detection as a knowledge discovery technique. This paper defines the notion ofoutlier in two related formalisms for specifying defaults: Reiter’s default logic and extendeddisjunctive logic programs. For each of the two formalisms, we show that finding outliers isquite complex. Indeed, we prove that several versions of the outlier detection problem lieover the second level of the polynomial hierarchy. We believe that a thorough complexityanalysis, as done here, is a useful preliminary step towards developing effective heuristicsand exploring tractable subsets of outlier detection problems.© 2008 Elsevier B.V. All rights reserved.This paper is about detecting outliers. In this work, outliers are unexpected observations, e.g., strange characteristics ofindividuals, in a given application domain. Exceptionality is determined here with respect to a given trustable knowledgebase, with which a given set of elements does not comply. The issue that we address is how to locate such unusual elementsautomatically.A first step towards automatically detecting outliers is to state their formal definition. In this work, it is assumed that thegiven knowledge base is expressed using a default reasoning language and hence we formalize our definition of outliers inthis framework. The languages mainly dealt with are propositional default logics and extended disjunctive logic programs.Default logic was originally developed as a tool for working with incomplete knowledge. Default rules allow one todescribe a normal behavior of a system and to draw consequent conclusions. As such, default rules can also be exploited fordetecting outliers—observations that are unexpected according to the default theory at hand. This is the basic idea behindthis paper. We refer to outliers as sets of observations that demonstrate some properties contrasting with those that canbe logically “justified” according to the given knowledge base. Along with outliers, their “witnesses” are singled out—thoseunexpected properties that characterize outliers.To illustrate, some informal application examples for outlier detection are described below.✩This manuscript is an extended and comprehensive report of results of which part have appeared in IJCAI-03 under the title “Outlier Detection UsingDefault Logic” and in ECAI-04 under the title “Outlier Detection Using Disjunctive Logic Programming”.* Corresponding author.E-mail addresses: f.angiulli@deis.unical.it (F. Angiulli), rachel@bgu.ac.il (R. Ben-Eliyahu – Zohary), palopoli@deis.unical.it (L. Palopoli).1 Part of this work was done while the author was a visiting scholar in the Division of Engineering and Applied Sciences, Harvard University, Cambridge,Massachusetts.0004-3702/$ – see front matter © 2008 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2008.07.0041838F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872Using outliers for diagnosis of computer hardware. Suppose that it usually takes about four seconds to download a giga-byte file from a server, but one day the system becomes slower, instead, eight seconds are needed to perform thesame task. While eight seconds may indicate a good performance, it is, nonetheless, helpful to find the source ofthe delay in order to prevent more critical faults in the future. In this case, the download operation is the outlierwhile the delay is its witness.Mechanical failure. Assume that someone’s car brakes are making a strange noise. Although they seem to be functioningproperly, this is not a normal behavior and the car is brought in for servicing. In this case, the car brakes are theoutlier and the noise is a witness for it.Knowledge base integrity.If an abnormal property is discovered in a database, the source that reported this informationwould have to be checked. Detecting abnormal properties, that is, detecting outliers, can also lead to an update ofdefault rules in a knowledge base. For example, suppose we have the rule that birds fly, and we observe a bird thatdoes not fly. This occurrence of such an outlier in the theory would be reported to the knowledge engineer. Theengineer investigates the case, finds out that the bird is actually a penguin, therefore he updates the knowledgebase with the default “penguins do not fly.”According to our approach, exceptions are not explicitly recorded in the knowledge base as “abnormals,” as is often donein logical-based abduction [16,23,47]. Rather, their “abnormality" is singled out precisely because some of the propertiescharacterizing them cannot be justified within the given theory.In this paper we formally define outliers in both the related formalisms of Reiter’s default logic and Extended disjunctivelogic programming (EDLP).Reiter’s Default Logic is a powerful nonmonotonic formalism to deal with incomplete information, while logic program-ming is a practical tool that is widely employed in KR&R. The paper mostly deals with the propositional fragment of theselogics. However, first-order default theories shall be also briefly discussed in the paper (see Section 5 below).In the logic programming framework, we focus on Answer Set Semantics, which is used in most advanced systems forknowledge representation [38,40,43]. Extended logic programs (ELP) under Answer Set Semantics allow both negation as fail-ure and classical negation to be used. These programs can be naturally embedded into default theories and therefore canbe considered as a subset of default logic. As a consequence, our results for default theories carry over quite simply to ELPs.However, unlike ELP, extended disjunctive logic programs (EDLP) under Answer Set Semantics, in which also head-disjunctionis allowed, cannot be viewed as a subset of default logic, although default logic in its full volume does include disjunction.Indeed, part of the motivation for developing disjunctive logic programming lies in the limitations of default logic in han-dling disjunctive knowledge (see the paper by Poole [47]). In this context, EDLP can be considered as a convenient tool forrepresenting and manipulating complex knowledge [38] due to its declarativity and expressive power.In what follows, we first introduce our formal definition of outliers. Then, we analyze the complexities involved inincorporating the outlier detection mechanism into knowledge bases expressed in default logic and extended disjunctivelogic programs. We believe that a thorough complexity analysis is a useful step towards singling out the more complexsubtasks involved in outlier detection. This first step is conducive to designing effective algorithms for implementationpurposes.According to the view adopted in this work, the witness that an observation is an outlier is a property or a behaviorthat is explicitly the opposite of what is expected. Representing such contradicting properties requires the usage of classicalnegation. Both default logic and extended logic programs make use of classical negation. Hence, these two languages repre-sent a natural setting for outlier detection. A different approach, which does not require that the negation of the exceptionalproperty is explicitly inferred but, rather, that it is simply not entailed by a logic program, is taken in [5]. As explainedthoroughly in this paper, the anomalies that can be singled out by the definition of [5] are quite different than the outliersdetected by the work presented here. This is mirrored in the different complexity figures we obtained: most of the outlierdetection problems investigated here lie at the third level of the polynomial hierarchy, whereas the most complex of theproblems considered in [5] are contained in its second level. In the sequel we will further elaborate on these differences.The rest of this paper is organized as follows: Section 2 provides preliminary definitions and Section 3 defines outliersand related notions. Section 4 discusses the complexity of finding outliers in general propositional as well as in disjunction-free default logics. Section 5 deals with first-order defaults. Section 6 discusses related work—in particular, the relationshipbetween outlier detection and abduction. Finally, Section 7 draws conclusions.2. Preliminary definitionsIn this section we briefly review preliminary definitions used in default logic and extended (disjunctive) logic programs.Note that only the propositional fragment of these logics is considered here. Outlier detection in first-order default languagesshall be briefly discussed in Section 5. Thus, whenever a default theory or a logic program with variables is used, it isreferred to as an abbreviation of its grounded version.F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–187218392.1. Default logicDefault logic was first introduced by Reiter in a first-order setting [49]. Next we recall basic definitions concerning thepropositional fragment of default logic. Let T be a propositional theory and S a set of propositional formulas. Then, we∗the logical closure of T and by ¬S the set {¬(s) | s ∈ S}. A set of literals L is inconsistent if, for some literaldenote by T(cid:2) ∈ L, ¬(cid:2) ∈ L.A propositional default theory (cid:3) is a pair (D, W ) consisting of a set W of propositional formulas and a set D of defaultrules. In this paper we deal with finite default theories. A default theory (cid:3) = (D, W ) is finite if both the set of default rulesD and the set of propositional formulas W are finite. A default rule δ has the formα : β1, . . . , βmγ(1)where α, each βi , 1 (cid:2) i (cid:2) m, and γ are propositional formulas. In particular, α is called the prerequisite, β1, . . . , βm arecalled the justifications, and γ is called the consequent (or conclusion) of δ. The prerequisite may be missing but the jus-tification and the consequent are required (an empty justification is tantamount to having the identically true literal true(Ray Reiter, Personal communication, 1992) specified in its place). If the conclusion of a default rule is included in its justi-fication, the rule is called semi-normal [25], while if the conclusion is identical to the justification the rule is called normal.A default theory containing only (semi-)normal defaults is called (semi-)normal. Given a default rule δ, pre(δ), just(δ), andconcl(δ) denote the prerequisite, justification, and consequent of δ, respectively. Analogously, given a set of default rulesD = {δ1, . . . , δn}, pre(D), just(D), and concl(D) denote, respectively, the sets {pre(δ1), . . . , pre(δn)}, {just(δ1), . . . , just(δn)}, and{concl(δ1), . . . , concl(δn)}.A propositional default theory (cid:3) = (D, W ) is disjunction free (DF for short) [33], if W is a set of literals, and pre(δ),just(δ), and concl(δ) are conjunctions of literals.The informal meaning of a default rule δ can be stated as follows: If pre(δ) is known to hold and if it is consistentto assume just(δ), then infer concl(δ). The formal semantics of a default theory (cid:3) is defined in terms of extensions, whichdenote maximal sets of conclusions that can be drawn from (cid:3). Thus, E is an extension for a theory (cid:3) = (D, W ) if it satisfiesthe following set of equations:– E0 = W ,– for i (cid:3) 0, E i+1 = E(cid:2)∞– E =i=0 E i .∗i∪ {γ | α:β1,...,βmγ∈ D, α ∈ E i, ¬β1 /∈ E, . . . , ¬βm /∈ E},An extension E of a finite propositional default theory (cid:3) = (D, W ) can be finitely characterized through the set DE of thegenerating defaults for E w.r.t. (cid:3) [49,58]. In fact, [58] shows that a finite propositional default theory (cid:3) = (D, W ) has anextension E iff there exists a set DE ⊆ D, the generating defaults for E w.r.t. (cid:3), that can be partitioned into a finite numberof strata D(n)E , such that:(1)E , . . . , D(0)E , D(0)E = {δ | δ ∈ DE , pre(δ) ∈ W– D– for each i, 1 (cid:2) i (cid:2) n, D– (∀δ ∈ DE )(∀β ∈ just(δ))(¬β /∈ (W ∪ concl(DE ))∗), and– (∀δ ∈ D)(pre(δ) ∈ (W ∪ concl(DE ))∗ ∧ (∀β ∈ just(δ))(¬β /∈ (W ∪ concl(DE ))∗ ⇒ δ ∈ DE ).( j)E , pre(δ) ∈ (W ∪ concl(∗},(i)E = {δ | δ ∈ DE −E ))∗},( j)i−1j=0 Di−1j=0 D(cid:2)(cid:2)If such a set DE exists, then E = (W ∪ concl(DE ))∗is an extension of (cid:3).For the case of DF theories, it is useful to rewrite the definition of extension, as done in [33]. Let (cid:3) = (D, W ) be a DFdefault theory. Then E is an extension of (cid:3) if there exists a sequence of defaults δ1, . . . , δn from D and a sequence of setsE0, E1, . . . , En, such that for all i > 0:– E0 = W ,– E i = E i−1 ∪ concl(δi),– pre(δi) ⊆ E i−1,– ((cid:10) ∃c ∈ just(δi))(¬c ∈ En),– ((cid:10) ∃δ ∈ D)(pre(δ) ⊆ En ∧ concl(δ) (cid:10)⊆ En ∧ ((cid:10) ∃c ∈ just(δ))(¬c ∈ En)),– E is the logical closure of Enwhere En is called the signature set of E and is denoted lits(E) and the sequence of rules δ1, . . . , δn is the set DE ofgenerating defaults of E .Although default theories are nonmonotonic, normal default theories satisfy the property of semi-monotonicity (see The-; then for each(cid:12), W ) be two default theories such that D ⊆ Dorem 3.2 of [49]). That is: Let (cid:3) = (D, W ) and (cid:3)(cid:12) = (Dextension E of (cid:3) there is an extension Eof (cid:3)(cid:12)such that E ⊆ E.(cid:12)(cid:12)(cid:12)1840F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872A default theory may not have any extensions, like in the theory ({ :β¬β}, ∅). Then, a default theory is called coherent ifit has at least one extension, and incoherent otherwise. Normal default theories are coherent. A coherent default theory(cid:3) = (D, W ) is called inconsistent if it has just one extension which is inconsistent. By Theorem 2.2 of [49], the theory (cid:3) isinconsistent iff W is inconsistent.The entailment problem is one of the basic problems in KR formalisms. For default theories, it is as follows: Given adefault theory (cid:3) and a propositional formula φ, does every extension of (cid:3) contain φ? In the affirmative case, we write(cid:3) |(cid:14) φ. For a set of propositional formulas S, we analogously write (cid:3) |(cid:14) S to denote (∀φ ∈ S) ((cid:3) |(cid:14) φ). The entailmentrealizes the form of reasoning called skeptical (or cautious) reasoning [18].2.2. Extended disjunctive logic programsA literal is an expression of the form (cid:2) or ¬(cid:2) where (cid:2) is a propositional letter and the symbol “¬” denotes classicalnegation. A propositional EDLP is a collection of rules of the formL1| . . . |Lk ← Lk+1, . . . , Lm, not Lm+1, . . . , not Lnwhere n, m, k (cid:3) 0, the symbol “not ” denotes negation by default and each Li is a literal. If k = 0, then the rule is called anintegrity clause. If 0 (cid:2) k (cid:2) 1 then the rule is said to be non-disjunctive. A propositional ELP is a collection of non-disjunctiverules.An EDLP is given semantics using answer sets [26], which are defined as follows: Let Lit(P ) denote the set of literalsobtained using the propositional letters occurring in P . By a context [12] we mean any subset of Lit(P ). Let P be a negation-by-default-free EDLP. A context is S closed under P if, for each rule L1| . . . |Lk ← Lk+1, . . . , Lm in P , if Lk+1, . . . , Lm ∈ S then,for some i = 1, . . . , k, Li ∈ S. An answer set of P is any minimal context S such that (1) S is closed under P and (2) if S isinconsistent, then S = Lit(P ).For general EDLPs answer sets are defined as follows: Let the reduct of P w.r.t. the context S, denoted by Red(P , S), be theEDLP obtained from P by deleting (i) each rule that has not L in its body, for some L ∈ S, and (ii) all remaining subformulasof the form not L from rule bodies. Then, any context S which is an answer set of Red(P , S) is an answer set of P .The collection of all consistent answer sets of an EDLP P is denoted ANSW(P ). An EDLP P is ANSW-consistent ifffor each S ∈ ANSW(P ). P |(cid:14) G,ANSW(P ) (cid:10)= ∅. An EDLP P entails a propositional formula F , written P |(cid:14) F , if F ∈ Sfor a set of propositional formulas G, means that (∀F ∈ G)(P |(cid:14) F ).∗2.3. Complexity theorySome basic definitions in complexity theory are recalled next, particularly that of the polynomial time hierarchy. Thereader is referred to [31,45] for more details.Decision problems are mappings from strings (encoding the input instance over a suitable alphabet) to {“yes”, “no”}. Thelanguage associated with a decision problem is the set of all and only the strings over the alphabet such that the decisionproblem outputs “yes” on them. A (possibly nondeterministic) Turing machine M answers a decision problem if on a giveninput x, (i) a branch of M halts in an accepting state iff x is a “yes” instance, and (ii) all the branches of M halt in somerejecting state iff x is a “no” instance.= NP(cid:9)Pk and (cid:10)P= co-(cid:9)PMore generally, classes (cid:9)PThe class P is the set of decision problems that can be answered by a deterministic Turing machine in polynomial time.The class of decision problems that can be solved by a nondeterministic Turing machine in polynomial time is denoted byNP, while the class of decision problems whose complementary problem is in NP, is denoted by co-NP.k, which form the polynomial hierarchy, are defined as follows: (cid:9)Pk . (cid:9)Pk (cid:3) 1, (cid:9)Pk−1 , and (cid:10)Pkkwhich may use an oracle for solving a problem in (cid:9)Pconstant computational cost. Thus, NP = (cid:9)Pas the conjunction of two independent problems, one from (cid:9)Planguage L is in DPproblem in (cid:10)Pk is modeled computability by a nondeterministic polynomial time Turing machinek−1. An oracle is, loosely speaking, a subprogram that can be run with ak, k (cid:3) 1, is the class of problems that are definedk. That is, a problem associated with ak , and L2, associated with ak if and only if there are two languages L1, associated with a problem in (cid:9)PkFinally, we need to recall the notion of reduction. A decision problem A1 is polynomially reducible to a decision prob-lem A2 if there is a polynomial time computable function h such that for every x, h(x) is defined and A1 output “yes” oninput x iff A2 outputs “yes” on input h(x). A decision problem A is complete for the class C of the polynomial hierarchy iffA belongs to C and every problem in C is polynomially reducible to A.2, such that L = L1 ∩ L2. Note that, for all k (cid:3) 1, (cid:9)Pk and one from (cid:10)P1 , and co-NP = (cid:10)P1. The class DP= P and for all= (cid:10)P0⊆ DPk⊆ (cid:9)Pk+1.0A well-known (cid:9)Pk -complete problem is to decide the satisfiability of a formula QBEk,∃, that is, a formula of the form∃ X1∀ X2 . . . Q Xk f ( X1, . . . , Xk), where Q is ∃ if k is odd and ∀ if k is even, X1, . . . , Xk are disjoint sets of variables, andf ( X1, . . . , Xk) is a propositional formula in conjunctive normal form if k is odd and in disjunctive normal form if k is even,on the set of variables X1, . . . , Xk. Analogously, deciding the validity of a formula QBEk,∀, that is a formula of the form∀ X1∃ X2 . . . Q Xk f ( X1, . . . , Xk), where Q is ∀ if k is odd and is ∃ if k is even, and f ( X1, . . . , Xk) is a propositional formulain disjunctive normal form if k is odd and in conjunctive normal form if k is even, on the set of variables X1, . . . , Xn,F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721841is complete for (cid:10)Pcomplete for DPk.k. Finally, deciding the conjunction (cid:11) ∧ (cid:12), where (cid:11) is a QBEk,∃ formula and (cid:12) is a QBEk,∀ formula, is3. OutliersNext, we shall formally define the notion of outlier in the context of default logic and extended disjunctive logic pro-gramming. Also, we shall introduce a number of significant decision problems (which we shall call queries) associated withsingling outliers out.3.1. Outliers in default logicWe start by defining the concept of outlier in default logic. To motivate the definition and clarify it, we present severalexamples.Example 3.1. Consider the following default theory which represents the knowledge that birds normally fly, but penguinsnormally do not fly. Moreover, we know that penguins are birds. Also, we have observed that Tweety is a bird, Pini is apenguin, and Tweety does not fly.(cid:3)D =W =(cid:5)Bird(x) : Fly(x)Fly(x),Penguin(x) : ¬Fly(x)¬Fly(x)(cid:4),Bird(Tweety), Penguin(Pini), ¬Fly(Tweety)(cid:6)(cid:6)(cid:5)Penguin( X) → Bird( X).∪This default theory has two extensions. One extension is the logical closure of W ∪ {Bird(Pini), ¬Fly(Pini)} and the other isthe logical closure of W ∪ {Bird(Pini), Fly(Pini)}. As ¬Fly(Tweety) ∈ W , both extensions include this literal. But Tweety’s notflying is quite strange. Indeed, it is known that birds normally fly, Tweety is a bird and there is no apparent justification forthe fact that Tweety does not fly (other than ¬Fly(Tweety) belonging to W ). Were Tweety a penguin, Tweety’s not flyingwould be promptly explained. But, as the theory stands, Tweety’s not flying is inexplicable. Moreover, if we try to nail downwhat makes all that exceptional, we may notice that if we had dropped the observation ¬Fly(Tweety) from W , the exactopposite would have been concluded, namely, that Tweety does fly. But if both ¬Fly(Tweety) and Bird(Tweety) are droppedfrom W , it can be no longer concluded that Tweety flies. Hence, Fly(Tweety) can be looked at as a “consequence” of the factthat Tweety is a bird. Thus Bird(Tweety) is the observation to be considered exceptional and ¬Fly(Tweety) determines thisexceptionality. A set of literals like {Bird(Tweety)} will be called an outlier, whereas a set of literals like {¬Fly(Tweety)} willbe called its witness set in the following.In sum, we can define an outlier as an observation characterized by some exceptional semantical property. In the logic,this observation will be denoted by a set of literals. Such sets of literals are going to denote anomalous characteristics ofelements of the world that our knowledge base encodes (e.g., a bird named Tweety in the example above). Therefore, in whatfollows, though we may sometime talk informally about outliers as individuals, it should be clear that, formally, outliers areobservations as encoded by sets of literals.We can now give a formal definition of outlier. We make use of the following notation: given a set W and a list of setsS1, . . . , Sn, W S1,...,Sn denotes the set W \ (S1 ∪ S2 ∪ · · · ∪ Sn).Definition 3.2 (Outliers and outlier witness set in default logic). L et (cid:3) = (D, W ) be a propositional default theory and let L ⊆ Wbe a set of literals.2 If there exists a nonempty set of literals S ⊆ W L such that:(i) (D, W S ) |(cid:14) ¬S, and(ii) (D, W S,L) (cid:10)|(cid:14) ¬Sthen we say that L is an outlier set in (cid:3) and S is an outlier witness set for L in (cid:3). If there is no Lthat Lin (cid:3), then we say that L is a minimal outlier set.is an outlier with witness set S(cid:12)(cid:12)(cid:12) ⊂ L and S(cid:12) ⊆ W L(cid:12) suchAccording to this definition, in the default theory of Example 3.1 we can conclude that {Bird(Tweety)} denotes an outlierset and {¬Fly(Tweety)} is its witness.Remark 3.3. (i) We point out that we regard outlier detection as a kind of data mining technique. Therefore, we mine fromexplicitly observed facts and, accordingly, outliers (as well as witnesses) are defined as sets of literals that are explicitlyincluded in the set of observations W .2 Note that in a preliminary version of this work [4], an outlier was defined as a single literal. In this work, we generalize that definition since, as wewill show in the sequel, in some scenarios the original definition might be too restrictive.1842F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872(ii) In some situations it may be useful for the analyst to be allowed to provide a specific set which outliers and witnessesshould be mined from. This is certainly a sensible and interesting idea from an application viewpoint. However, if weuse a different definition of outliers according to this idea, it will make no difference in the conceptual and theoreticaldevelopment we are going to present in the following.Next, we shall illustrate our definition by several further examples.Example 3.4. A well-known center for rare diseases is located in the small city of Lamezia in Calabria. One hot day insummer you are walking along the nice streets of Lamezia when you notice a young man wearing a heavy coat going inthe same direction. In this situation, if you are a student in a school of medicine interested in genetic diseases, you mightwant to ask that man about his rare illness. Another way to put it is to say that the fact that the man is wearing a coat ina hot summer day makes him an outlier, and one of the probable explanations at that time and place for such behavior isthat this man has a rare genetic disease. A default theory (cid:3) that describes this episode might be as follows:(cid:3)D =W =(cid:5)Day(x) ∧ Warm(x) ∧ Person( y) : ¬WearCoat( y, x)¬WearCoat( y, x)(cid:4),(cid:6)Day(Tuesday), Warm(Tuesday), Person(Jim), WearCoat(Jim, Tuesday).This theory claims that normally a person would not wear a coat on a warm day. The observations are that Tuesday is aday and Tuesday is warm and Jim is a person who is wearing a coat on Tuesday. This system would preferably concludethat Jim is the argument of an outlier. Indeed, the reader can verify that the following facts are true:(i) (D, W {WearCoat(Jim,Tuesday)}) |(cid:14) ¬WearCoat(Jim, Tuesday)1. (D, W {WearCoat(Jim,Tuesday)},{Person(Jim)}) (cid:10)|(cid:14) ¬WearCoat(Jim, Tuesday).2. (D, W {WearCoat(Jim,Tuesday)},{Day(Tuesday)}) (cid:10)|(cid:14) ¬WearCoat(Jim, Tuesday).3. (D, W {WearCoat(Jim,Tuesday)},{Warm(Tuesday)}) (cid:10)|(cid:14) ¬WearCoat(Jim, Tuesday).Hence, {Person(Jim)}, {Day(Tuesday)} and {Warm(Tuesday)} are all{WearCoat(Jim, Tuesday)} is the unique outlier witness set for each of them.the minimal outliers found in our theory andOutlier witnesses have been defined as sets because, in general, a single literal may not suffice to form a witness for agiven outlier. We illustrate this in the following example.Example 3.5. Consider the default theory (cid:3) = (D, W ), where the set of default rules D conveys the following informationabout weather and traffic:(i) SummerWeekend∧Traffic_Jam:Accident∨TornadoAccident∨Tornadoaccident has occurred or a tornado hit the freeway.—that is, normally, if there is a traffic jam during a summer weekend then an(ii) Accident:Police∧Ambulance(iii) Tornado:Police∧AmbulancePolice∧AmbulancePolice∧Ambulance—that is, normally, if an accident occurred then the police and ambulances are around.—that is, normally, if a tornado hits the freeway then the police and ambulances are around.Suppose also that W = {SummerWeekend, Traffic_Jam, ¬Police, ¬Ambulance}. Then, the set S = {Police, Ambulance} is an out-(cid:12) = {Traffic_Jam} as well). Note that there is nolier witness for the outlier L = {SummerWeekend} (and for the outlier Lsingleton witness for this outlier.Example 3.6. Consider the following default theory (cid:3):(cid:3)D =PlantOwner(x) : MakesMoney(x)MakesMoney(x),GoodWilling(x) : WantsReducedPollution(x)WantsReducedPollution(x),PlantOwner(x) ∧ GoodWilling(x) : Donates(x)Donates(x)(cid:5)W =PlantOwner(Johnny), GoodWilling(Johnny), ¬MakesMoney(Johnny),Donates(Johnny), ¬WantsReducedPollution(Johnny).(cid:4),and(cid:6)This theory claims that normally plant owners make money and that good-willed plant owners are interested in reducedpollution and in donations. The observations are that Johnny is a good-willed plant owner who does not make money and isnot interested in reduced pollution, but anyway makes donations. Therefore it would be interesting to have a KR system thatcould automatically conclude that Johnny is the argument of two outliers. Indeed, the reader can verify that the followingfacts are true:F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721843(i) (D, W {¬MakesMoney(Johnny)}) |(cid:14) MakesMoney(Johnny),(ii) (D, W {¬WantsReducedPollution(Johnny)}) |(cid:14) WantsReducedPollution(Johnny),(iii) (D, W {¬MakesMoney(Johnny)},{PlantOwner(Johnny)}) (cid:10)|(cid:14) MakesMoney(Johnny), and(iv) (D, W {¬WantsReducedPollution(Johnny)},{GoodWilling(Johnny)}) (cid:10)|(cid:14) WantsReducedPollution(Johnny).Hence, both {¬MakesMoney(Johnny)} and {¬WantsReducedPollution(Johnny)} are outlier witnesses, while {PlantOwner(Johnny)}and {GoodWilling(Johnny)} are the corresponding outliers.Finally, the following example demonstrates why it is sensible to define an outlier as a set, and not as a single literal.Example 3.7. Consider a set of default rules D conveying the following information about watering the grass:—normally, if the sprinkler is on, the grass is wet.WetGrass —normally, when it is raining the grass is wet.—the sprinkler does not normally operate during the winter.(i) SprinklerOn:WetGrassWetGrass(ii) Rain:WetGrass(iii) SprinklerOn:¬WinterTime(iv)¬WinterTime¬WinterTime:¬ChimneySmoke¬ChimneySmoke—normally, there is no smoke in the chimney when it is not winter time (since the fireplace isnot used).Now, suppose outliers have to be defined to be single literals. Then, for the observation W 1 = {Rain, ¬WetGrass} wewould have that {Rain} is an outlier with witness set {¬WetGrass}. Similarly, for the observations W 2 = {SprinklerOn,¬WetGrass}, we would have that {SprinklerOn} is an outlier with witness set {¬WetGrass}. However, for the observationW 3 = {SprinklerOn, Rain, ¬WetGrass} no outliers can be singled out. This is because:(i) (D, W {¬WetGrass}) |(cid:14) WetGrass, but(ii) (D, W {¬WetGrass,Rain}) |(cid:14) WetGrass and also (D, W {¬WetGrass,SprinklerOn}) |(cid:14) WetGrass.However, if both Rain and SprinklerOn are dropped from W , it is no longer possible to infer WetGrass and, as such,{Rain, WetGrass} is an outlier according to our definition with witness set {¬WetGrass}.For another example, suppose we have the set D as above, and W 4 = {SprinklerOn, ChimneySmoke}. Then {SprinklerOn}is an outlier, with the witness {ChimneySmoke}.thenfor the observations W 6 = {¬WinterTime,{¬WinterTime} is an outlier, with the witness {ChimneySmoke}. However,SprinklerOn, ChimneySmoke} we will not get any outliers if outlier would have been defined as a single literal while{¬WinterTime, SprinklerOn} is an outlier according to our definition with outlier witness {ChimneySmoke}.the observations are W 5 = {¬WinterTime, ChimneySmoke},IfThus, definition that restricts the outlier to be a single literal may be too restrictive. (cid:2)3.2. Outlier detection in extended disjunctive logic programsWe now define the concept of outlier in the context of EDLP. Within this reasoning framework, we assume that thegeneral knowledge about the world is encoded as an extended (disjunctive) logic program D, called the rule program, andthat the factual evidence about some aspects of the current status of the world is encoded in a set of literals W , called theobservations set.Thus, a rule-observations program P is a pair P = (D, W ) consisting of a rules program and an observations set. Intuitively,a rule-observations program relates the general knowledge encoded in D with the evidence about the world encoded in W .In the following we denote by P = (D, W ) the EDLP D ∪ W . Also, given two disjoint subsets L and S of W , we denoteby P S the logic program D ∪ (W \ S) and by P S,L the logic program D ∪ (W \ (S ∪ L)). In the context of EDLP knowledgebases, the definition of outlier is analogous to that given in the framework of default logic (Definition 3.2).Definition 3.8 (Outliers and outlier witness set in extended logic programs). Let a rule-observations program P = (D, W ) and aset of literals L ⊆ W be given. If there exists a nonempty set of literals S ⊆ W L such that:(i) P S |(cid:14) ¬S, and(ii) P S,L (cid:10)|(cid:14) ¬Sthen we say that L is an outlier set and S is an outlier witness set for L in P .All the motivating examples given in Section 3.1 for the default logic framework, except Example 3.5, can be translatedto EDLP. For instance, the default theory given in Example 3.1 can be translated to an EDLP as follows: Let P = (D, W ),where W = {Bird(Tweety), ¬Fly(Tweety)} ∪ {Bird( X) ← Penguin( X)} and D is the set1844(cid:5)F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872Fly( X) ← Bird( X), not ¬Fly( X),(cid:6)¬Fly( X) ← Penguin( X), not Fly( X).Analogous to what we showed in Section 3.1, if we are trying to understand what makes Tweety an exception, we noticethat if we drop the observation ¬Fly(Tweety), we would conclude the exact opposite, namely, that Tweety does fly. Thus,{¬Fly(Tweety)} is a witness according to Definition 3.8. Furthermore, if we drop both the observations ¬Fly(Tweety) andBird(Tweety), we are no longer able to conclude that Tweety flies. This implies that Fly(Tweety) is a consequence of the factthat Tweety is a bird, and thus Bird(Tweety) is an outlier.In the next example, we use disjunctive information represented in an EDLP which is not head-cycle-free [11]. We areinterested in a full-fledged EDLP for two main reasons. First, as noted by [11], head-cycle-free EDLPs can be faithfullytranslated into disjunction-free logic programs. Second, disjunction-free programs are equivalent to a subset of default logicand their expressive power is strictly less than that of general disjunctive programs [18].The following example is adapted from [15]. We assume a situation where goods from a set G are produced by companiesin a set C owned by a set of stock holders H . Each good is produced by at most two companies and each company mayproduce several goods. Suppose that currently H produces all goods in G by means of its companies, and this representsa business advantage over its competitors. Hence, the owners’ policy prescribes that for a company c ∈ C to be safely sold,H should not loose its capability of producing all goods. Therefore, the owners consider not safely sellable any companythat belongs to all minimal sets of companies producing all goods. The situation is further complicated by the presence ofa control relationship amongst companies: a company c might be controlled by a triplet of companies c1, c2, c3. If this isthe case, then c is considered safely sellable only if at least one among its controlling companies c1, c2, c3 is safely sellableas well. Call strategic a company that cannot be safely sold according to the owners’ policy. The owners need to knowwhich companies can be safely sold. The situation can be formalized in an EDLP as follows. There are literals of the formprod(g, c1, c2), one for each good g, to denote that good g is produced by companies c1 and c2. We will use the literalprod(g, c, c) to denote that good g is produced by only one company c. There are literals of the form contr(c, c1, c2, c3) todenote that c is controlled by c1, c2, c3. Rules in P are as follows:– a company is not strategic if it is consistent to assume so¬strategic( X) ← not strategic( X)– at least one of the companies producing a good is strategicstrategic(Y ) | strategic(Z ) ← prod( X, Y , Z )– a company controlled by three strategic companies is strategic as wellstrategic(W ) ← contr(W , X, Y , Z ), strategic( X), strategic(Y ), strategic(Z )– normally strategic companies are not sellableunsell( X) ← strategic( X), not ¬unsell( X).We recall that to establish whether a company c is indeed strategic in the above setting is a (cid:10)P2-complete problem [15]and, as such, cannot be expressed by means of any disjunction-free logic program (this is because disjunction-free logicprograms can express only problems that are at most as complex as co-NP). Now assume that the following literals havebeen observed(cid:5)W =prod(g1, c1, c2), prod(g2, c1, c3), prod(g3, c2, c3), prod(g4, c2, c4), prod(g5, c3, c4), prod(g6, c1, c4),(cid:6)prod(g7, c2, c5), contr(c5, c1, c2, c3), contr(c5, c1, c2, c4), contr(c5, c2, c3, c4), ¬unsell(c5).Then, it is evident that there is an outlier among the observations. Indeed, according to our formal definition, we have that{¬unsell(c5)} is an outlier witness with outlier {contr(c5, c1, c2, c3)}.3.3. Some more extensive examplesIn this section we describe in detail some further and more extensive application examples of the proposed framework.3.3.1. Learning and knowledge base integrityAssume a database of examples is given—both positive and negative examples. We want to acquire knowledge thatabstracts the examples. A way to go is to learn rules encoding the knowledge. Clear enough, the more expressive the rulelanguage employed for the learning purposes is, the richer the description of the example database properties as learntin this process will be. In this context, techniques to induce defaults from examples can be applied, which guarantee thecapability of encoding defeasible (cid:9)P2 properties of the database (whereas, for instance, learning Horn rules would resultin the possibility of encoding “certain” polynomial time properties). For instance, the techniques of [20,42] can be appliedF. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721845here. Once the set of default rules has been learned, outlier detection techniques might be applied for checking abnormalityoccurring in the knowledge base.Next we show an example of such application using the framework for learning default theories proposed in [20]. First,we recall the definition of a learned default theory provided there.3Definition 3.9 (Learning a default theory). [20] Given a set of positive examples E− = {eis, p(e) is assumed to be true for all e ∈ Etrue for all e ∈ Etheory consists of finding a set D of defaults such that(cid:9)+ = {e1, e2, . . . , en} of the predicate p (that(cid:12)} (that is, ¬p(e) is assumed be1, e) and an initial consistent set of first order formulas W containing no occurrence of p, learning a default), a set of negative examples E(cid:12)2, . . . , e(cid:12)m(cid:9)+−(cid:7) (cid:8)(cid:7) (cid:8)(D, W ) |(cid:14)p(e)∧¬p(e).e∈E+e∈E−Informally speaking,4 default rules learnt by the method reported in [20] have the following form:ϕ( X) : p( X) ∧ ¬ψ( X)p( X)ϕ( X) : ¬p( X) ∧ ¬ψ( X)¬p( X), resp.(cid:7)(cid:9)where the formula ϕ( X) generalizes some positive (negative, resp.) examples, and the formula ψ( X) generalizes all theexceptions to ϕ( X), that are the negative (positive, resp.) examples which are generalized by ϕ( X).Consider the following set of first-order formulas W :bird(4),bird(5), mam(6), mam(7), mam(8), mam(9),bat(10),superpen(11),bird(3),pen(2),pen(1),pen( X) → bird( X),superpen( X) → pen( X),bat( X) → mam( X),where pen stands for penguin and mam stands for mammal. Assume the following set of positive and negative examplesconcerning the predicate flies are given:+ = {3, 4, 5, 10, 11} ≡− = {1, 2, 6, 7, 8, 9} ≡EE(cid:5)(cid:6)flies(3), flies(4), flies(5), flies(10), flies(11)(cid:5)¬flies(1), ¬flies(2), ¬flies(6), ¬flies(7), ¬flies(8), ¬flies(9),(cid:6).Using the technique of [20] we will learn the following set of defaults D:δ1 = bird( X) : flies( X) ∧ ¬pen( X)δ3 = superpen( X) : flies( X)flies( X),flies( X)δ2 = pen( X) : ¬flies( X) ∧ ¬superpen( X),δ4 = bat( X) : flies( X),flies( X),¬flies( X)δ5 = mam( X) : ¬flies( X) ∧ ¬bat( X).¬flies( X)Let (cid:3) be (D, W ) where D and W are as defined above. Assume that the set of facts W ins = {bird(12), ¬flies(12)} is addedto the theory (cid:3) so that the theory (cid:3)ins = (D, W ∪ W ins) is obtained. Then, in the theory (cid:3)ins the set L = {bird(12)} is anoutlier with witness S = {¬flies(12)}. Indeed, (cid:3)(cid:12) = (D, W ∪ W insS ) is such that (cid:3)(cid:12) |(cid:14) flies(12) by means of the default rulebird( X):flies( X)∧¬pen( X), and (cid:3)(cid:12)(cid:12) = (D, W ∪ W insflies( X)S,L) is such that (cid:3)(cid:12)(cid:12) (cid:10)|(cid:14) flies(12), since bird(12) is no longer entailed by (cid:3)(cid:12)(cid:12).An outlier may indicate that something is functioning wrong and that some actions are to be taken. In the example athand, the individual 12 could be unhealthy and thus requires to be cured. If it is believed that the outlier must be “removed”from the knowledge base, then this can be basically accomplished using two different procedures, that we describe next inthe context of the example at hand. According to the first procedure, it is acknowledged that the bird 12 is a penguin and,hence, the literal pen(12) is added to the theory (cid:3)ins. According to the second procedure, it is recognized that 12 cannot flysince one of its wings is broken. Consequently, the fact sick(12) is added to the set W , 12 is added to the set of negativeexamples, and a novel set of defaults Drev (taking into account this kind of exception) will be learned. In particular, the setDrev will differ from the set D since the default rules δ1 and δ2 will be replaced by the two following ones:δrev1δrev2= bird( X) : flies( X) ∧ ¬pen( X) ∧ ¬sick( X)flies( X)= pen( X) ∨ sick( X) : ¬flies( X) ∧ ¬superpen( X)¬flies( X),.and3 A slightly different definition was also provided by the same authors in [42].4 The reader is referred to [20] for more details.1846F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872It is interesting to stress the relationships between outliers and learned default theories. Let (cid:3) = (D, W ) be a learnedis added to it. Assume that {¬p(c)} ⊆ Wtheory, and assume some set of facts Wis an outlier witness set for an outlier(cid:12){¬p(c)}) |(cid:14) p(c), that is, that c behaves as a positive example, while weL ⊆ (W ∪ Whave stated the exact opposite, that is, we have ¬p(c) as a negative example provided with the update set W. A similarreasoning can be followed in case where the witness set is {p(c)}.(cid:12)). Then, it is the case that (D, W ∪ W(cid:12)(cid:12)(cid:12)3.3.2. A biological rule databaseFor several reasons, the realm of biology is quite interesting for applying outlier detection techniques. First of all, rulesin biology often have exceptions. Second, the domain is not completely known. Third, knowledge base and data base toolsin bioinformatics applications are critically needed [44].With the aid of a biologist, we formalized the following knowledge base about the “central dogma” of molecular biology,that is, the process according to which DNA sequences are translated into proteins. The knowledge base (cid:3)bio = (Dbio, W bio)is as follows:Rule1 :Rule2 :Rule3 :Rule4 :Rule5 :Rule6 :Rule7 :Rule8 :DNA(S) : ¬transRNA(S)¬transRNA(S)DNA(S) ∧ prom(S) : transRNA(S)transRNA(S)transRNA(S) ∧ RBS(S) : transProtein(S)transProtein(S)transProtein(S) : ¬deg(S)¬deg(S)DNA(S) : ¬prom(S)¬prom(S)transRNA(S) : ¬RBS(S)¬RBS(S)recDeg(S) : foundSubseq(S)foundSubseq(S)transProtein(S) ∧ ¬deg(S) : foundProtein(S)foundProtein(S)Rule9 :: ¬foundProtein(S)¬foundProtein(S)old(S) : ¬foundSubseq(S)¬foundSubseq(S)Rule11 : prom(S) ∧ rep(S) → ¬transRNA(S)Rule10 :Rule12 : ¬prom(S) → ¬transRNA(S)Rule13 : deg(S) → recDeg(S) ∨ old(S)Rule14 : foundSubseq(S) → deg(S)Normally a generic DNA sequence is not transcribed to RNA.Normally a DNA sequence having a promotor is transcribed to RNA.Normally a transcribed DNA sequence that has a Ribosomal BindingSite is translated into a protein.Normally a translated protein is not degradated.Normally a DNA sequence doesn’t have a promotor.Normally a transcriptable RNA sequence has not a Ribosomal BindingSite.Normally, if a protein degradated just recently, some broken subse-quences are found in the wet lab experimental sample.Normally when a sequence is translated into a protein and the proteinis not degradated, the protein is found in the experimental sample.Normally proteins are not found in experimental samples.Normally if a degradated protein is an old one no subsequences arefound.It is known that if a repressor binds the promotor region of a DNAsequence, then the sequence is not transcribed.It is known that if no promoter region is in a DNA sequence, it is nottranscribed.It is known that degradated proteins are those which are either degra-dated recently or very old ones.It is known that if some broken subsequences are found in the experi-mental sample the protein is degradated.Assume, now, that the results of two different wet lab experiments are encoded in the two following sets of literals:(cid:5)(cid:5)Wexp1W exp2==DNA(seqA), prom(seqA), RBS(seqA), ¬foundProtein(seqA)(cid:6),and(cid:6)DNA(seqB), prom(seqB), rep(seqB), RBS(seqB), foundSubseq(seqB), foundProtein(seqB).Then in the theory (Dbio, W bio ∪ W exp) the sets {DNA(seqA)}, {prom(seqA)}, and {RBS(seqA)} are all outliers with witness{¬foundProtein(seqA)}. Indeed, these sets include all the indications that protein should be found. Therefore, it might beconcluded that a repressor binds the promotor region of the DNA sequence or the protein is degradated.Also in the theory (Dbio, W bio ∪ W exp) there are outliers. In particular, L = {rep(seqB), foundSubseq(seqB)} is a minimaloutlier having witness S = {foundProtein(seqB)}. In fact, it is surprising that the protein is found whereas a repressor ispresent and some broken subsequences are found in the lab sample.12F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721847Table 1Complexity results for outlier detectionQueryTheoryNormal default EDLPNormal DF default ELPOutlierOutlier[k]Outlier(L)Outlier(S)Outlier[k](S)Outlier(S)(L)Outlier-min(L)Outlier-min(S)(L)(cid:9)P(cid:9)P(cid:9)PDPDPDPDP3 -complete3 -complete3 -complete2-complete2-complete2-complete3-complete3-complete(cid:10)P(cid:9)P(cid:9)P(cid:9)P2 -complete2 -complete2 -completeDP-completeDP-completeDP-completeDP2-complete2-complete(cid:10)P4. Complexity resultsIn this section we study the computational complexity underlying outlier detection problems. Formal proofs of the resultswe present are reported in Appendix A (for results of Section 4.2 concerning default theories) and Appendix B (for results ofSection 4.3 concerning extended (disjunctive) logic programs). Below we provide all the theorems together with an informaloutline of the proofs. To start with, we define the outlier detection problems we are going to analyze.4.1. Outlier detection queries and result summaryIn order to analyze the computational complexity underlying outlier detection we refer to some decision problems, calledqueries, which are defined next. These queries refer to a given knowledge base KB, where KB is either a default theory(cid:3) = (D, W ) or an EDLP rule-observations program P = (D, W ):– Outlier: Given KB, does there exist at least one outlier set in KB?– Outlier[k]: Let k be a constant positive integer. Given KB, does there exist at least one outlier set with cardinality ofat most k in KB?– Outlier(L): Given KB and a set of literals L ⊆ W , is L an outlier in KB?– Outlier(S): Given KB and a set of literals S ⊆ W , is S a witness for some outlier set L in KB?– Outlier[k](S): Let k be a constant positive integer. Given KB and a set of literals S ⊆ W , is S a witness for any outlierset L of cardinality of at most k in KB?– Outlier(S)(L): Given KB, a set of literals S ⊆ W , and a set of literals L ⊆ W , is L an outlier with witness S in KB?Furthermore, we are interested in the complexity of some of the above-defined problems when only minimal outliers are tobe singled out. Thus, we also consider the following two additional queries:– Outlier-min(L): Given KB and a set of literals L ⊆ W , is L a minimal outlier in KB (that is, there is no other outlier– Outlier-min(S)(L): Given KB, a set of literals S ⊆ W , and a set of literals L ⊆ W , is L a minimal outlier and is S a(cid:12)Lin KB such that L(cid:12) ⊆ L)?witness set for L in KB?Note that the complexity of a query asking for the existence of a minimal outlier set is obviously the same as that ofquery Outlier, since an outlier exists in a given theory if and only if a minimal one is there as well.Complexity results are summarized in Table 1 and explained below. It is clear from Table 1 that answering outlierdetection problems on propositional normal general (disjunction-free, resp.) default theories turns out to be as hard asanswering them on propositional disjunctive (non-disjunctive, resp.) extended logic programs.4.2. Complexity of outlier detection using Reiter’s default logicIn this subsection we analyze the complexity associated with detecting outliers in general and in DF propositional de-fault logic. We preliminarily notice that all the membership results have been established for general theories and generaldisjunction-free theories, while hardness results have been established for a strict subset of them, that is, normal theories.Hence, complexity results hold overall for both normal default theories and general default theories.We start our analysis with the query Outlier, the most general of the set. Given a default theory, this query asks whetherthere exists an outlier in the theory.Theorem 4.1. On propositional default theories, Outlier is (cid:9)P3 -complete for general default theories, and (cid:9)P2 -complete for DF theories.1848F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872Proof outline. It follows from Definition 3.2 that the C-membership of the query Outlier given on a propositional defaulttheory (cid:3) = (D, W ), where C denotes a suitable complexity class, can be proved by building a nondeterministic Turingmachine T that simultaneously guesses two disjoint subsets L and S = {s1, . . . , sn} of W , and then verifies that(cid:12)– (D, W S ) |(cid:14) ¬s1 ∧ · · · ∧ ¬sn (entailment problem q– (D, W S,L) (cid:10)|(cid:14) ¬s1 ∧ · · · ∧ ¬sn (entailment problem q), and(cid:12)(cid:12)).is in the class co-Ce . Thus, T can employ a Ce oracle to solve both qLet Ce be the complexity class of the entailment problem for (cid:3). Then the problem q(cid:12)(cid:12)qC = NPco-NP for DF propositional default theories [33]. As a consequence, query Outlier belongs to the classes NP(cid:9)PNPNP = (cid:9)Pis in the class Ce , while the problem. Hence, the query Outlier is in the class2 for general propositional default theories [27,54], and is in3 and2 for general propositional default theories and for DF propositional default theories, respectively.Ce . Recall that the entailment problem is in (cid:10)P= co-(cid:9)P2 = (cid:9)Pand q(cid:12)(cid:12)2(cid:12)(cid:12)Completeness is proved by reducing the (cid:9)Pk -complete (k ∈ {2, 3}) problem of deciding the validity of a QBEk,∃ formulato Outlier. The reader is referred to the Appendix for the detailed proof. (cid:2)Let us now turn to analyzing the second query. Given a theory and a positive integer number k, the query Outlier[k]asks for the existence of an outlier of size at most k in the theory. The complexity of this query is stated below.Theorem 4.2. On propositional default theories, Outlier[k] is (cid:9)PDF default theories.3 -complete for general theories, and (cid:9)P2 -complete for propositionalProof outline. Bounding the size of the outlier does not change the complexity of singling it out. Indeed, as for the member-ship, both a witness set S and an outlier set L such that |L| (cid:2) k can be guessed, and the rest of the proof follows the sameline of reasoning outlined above for Theorem 4.1. As for hardness, the construction referred to in Theorem 4.1 still holds aswell, since the outlier set L we employ in the proof has size 1 and, hence, complies with any possible value of k. (cid:2)Next, we focus on query Outlier(L). It turns out that knowing the outlier set L in advance does not reduce the com-plexity w.r.t. the general Outlier query since, in particular, the number of possible outlier witness sets S ⊆ W L for L is stillexponential. This is summarized in the following theorem.Theorem 4.3. On propositional default theories, Outlier(L) is (cid:9)P3 -complete for general theories, and (cid:9)P2 -complete for DF theories.Proof outline. The same as for Theorem 4.1. (cid:2)Given a default theory and a set of literals S, query Outlier(S) asks whether S is a witness set for any outlier in thetheory. It turns out that the complexity of Outlier(S) is lower than the complexity of Outlier. This is so because, oncethe candidate outlier witness set S is given, there is no need to check all the potential outlier witnesses (and there is anexponential number of potential witnesses). The result is given in the following theorem.Theorem 4.4. On propositional default theories, Outlier(S) is DP2-complete for general theories and DP-complete for DF theories.(cid:12)is in (cid:10)P2, while for DF propositional default theories, it is in co-NP. As for problem qintroduced in the proofProof outline. In order to prove membership we refer, again, to the entailment problems qoutline of Theorem 4.1, but this time the outlier witness set S is fixed in advance. We recall that for general propositional2 and indefault theories, qNP for general theories and for DF theories, respectively, provided that L is known (these are standard entailment problemsfor general and DF default theories). However, it is possible to show that qbelongs to those classes also when L is un-can be answered by showing that there exists a set L in W S and an extension E of the theory (D, W S,L)known. Indeed, qsuch that ¬S /∈ E. Thus, a nondeterministic polynomial time Turing machine T M can be built that guesses simultaneouslythe set L ⊆ W S , the subset D E ⊆ D of generating defaults of an extension E of (D, W S,L), and an ordering of the rulesin D E . Then, T M proceeds as follows:, it is in (cid:9)Pand q(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)– for general propositional default theories, T M uses an NP oracle (a) to check the conditions that D E must satisfy to bea set of generating defaults for E, and (b) to verify that ¬s1 ∧ · · · ∧ ¬sn /∈ E. These steps can be performed by executinga polynomially bounded number of calls to the NP oracle;– for DF default theories, T M (a) checks the conditions that D E must satisfy to be a set of generating defaults for anextension E of a disjunction-free theory, and (b) verifies that ¬s1 ∧ · · · ∧ ¬sn /∈ E, by checking that for every i, 1 (cid:2) i (cid:2) n,¬si is not the conclusion of any default in D E . These steps can be performed in polynomial time.F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721849Thus, for general default theories, Outlier(S) is the conjunction of two independent problems belonging to (cid:10)Ptherefore, it is in DPthe other from NP and, hence, Outlier(S) is in DP.2 and,2. For DF default theories, Outlier(S) is the conjunction of two independent problems, one from co-NP,2 and (cid:9)PAs for hardness, we consider the following decision problem, which we call problem q. Given two independent defaulttheories (cid:3)1 and (cid:3)2, and two letters s1 and s2, the problem q is to verify whether the following is true:((cid:3)1 |(cid:14) s1) ∧ ((cid:3)2 (cid:10)|(cid:14) s2)(problem q).For general propositional default theories, q is a DP2-complete, whilethe problem of testing (cid:3)2 (cid:10)|(cid:14) s2 is (cid:9)P2 -complete [27,54]. For DF propositional default theories, q is a DP-complete problem,since testing (cid:3)1 |(cid:14) s1 is co-NP-complete, while testing (cid:3)2 (cid:10)|(cid:14) s2 is NP-complete [33]. Then, hardness of query Outlier(S) isproven by reducing q to query Outlier(S). Given an instance of q, a default theory (cid:3)(q) = (D(q), W (q)) is associated withq such that ¬s1, s2 ∈ W (q), and q is true iff {¬s1} is an outlier witness set for {s2} in (cid:3)(q). (cid:2)2-complete problem, since testing whether (cid:3)1 |(cid:14) s1 is (cid:10)PThe following result shows that, similarly to what was shown for query Outlier, bounding the size of the outlier set tobe associated with the provided witness set S in advance does not change the complexity figures.Theorem 4.5. On propositional default theories, Outlier[k](S) is DP2-complete for general theories, and DP-complete for DF theories.Proof outline. Both membership and hardness can be proved as discussed above for Theorem 4.4. To prove membership itsuffices to guess only outlier sets with size of at most k. As for hardness, the reduction proceeds as described in the proofoutline of Theorem 4.4, since outlier witness sets employed in the construction are singleton sets. (cid:2)Next, we analyze the query Outlier(S)(L). Note that this query is important because it might be the basic operator ina system for outlier detection using propositional default theories. We recall that, given a default theory and two sets ofliterals S and L, this query “simply” asks if S is an outlier witness set for the outlier L in that theory.Theorem 4.6. On propositional default theories, Outlier(S)(L) is DP2-complete for general theories, and DP-complete for DF theories.Proof outline. Complexity of query Outlier(S)(L) is the same as that of query Outlier(S). Similarly to what happens forquery Outlier(L) with respect to query Outlier, knowing the outlier set L in advance does not reduce the complexityof Outlier(S)(L) with respect to query Outlier(S). Indeed, recall that even if sets L and S are fixed, it is nonethelessdefined in the proof outline of Theorem 4.1, which are, respectively, (cid:10)P2-needed to solve entailment problems qcomplete (co-NP-complete, resp.) and (cid:9)P2 -complete (NP-complete, resp.) for propositional general (DF, resp.) default theories.Hence, the result. (cid:2)and q(cid:12)(cid:12)(cid:12)Given a default theory and a set of literals L, the query Outlier-min(L) asks whether L is a minimal outlier set in thetheory. Although the outlier set is given as input to this query, Outlier-min(L) turns out to be the most complex of theoutlier detection problems considered in this work, even more complex than the general Outlier query.Theorem 4.7. Outlier-min(L) on propositional default theories is DP3-complete for general theories, and DP2-complete for DF theories.2 for DF theories.3 -complete for general default theories and (cid:9)PProof outline. The membership part of the theorem can be proved as follows. First, consider the problem of verifying that Lis indeed an outlier, that is, that there exists a witness set S ⊆ W L for L. It has been shown in Theorem 4.3 that Outlier(L)is (cid:9)P2 -complete for DF theories. Once verified that L is an outlier it mustbe further shown that L is a minimal outlier, i.e., that for each nonempty subset Lof W L(cid:12) ,Ltogether do not satisfy Definition 3.2. The negation of the latter problem can be solved by a polynomial timeandnondeterministic Turing machine with an oracle for the entailment problem that guesses the two subsets Lthen verifies if they indeed satisfy Definition 3.2. As a consequence, the problem is in (cid:10)P3 for general default theories andin (cid:10)Pof L and for each subset Sand Sand S(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)It can be concluded that the overall query Outlier-min(L) on general (resp. DF) theories is the conjunction of twoindependent problems, one from (cid:9)P3 (resp. (cid:9)P2 ) and one from (cid:10)P3 (resp. (cid:10)P2) and, thus it lies in DP3 (resp. DP2).Hardness of query Outlier-min(L) for general theories is proved by reducing the problem of deciding the validity of aformulaF =(cid:11)(cid:10)(∃ X)(∀Y )(∃Z ) f ( X, Y , Z )(cid:11)(cid:10)(∀W )(∃U )(∀V )g(W , U , V )∧to the problem Outlier-min(L). Within F ,f ( X, Y , Z ) is a Boolean formula in conjunctive normal form and g( X, Y , Z ) isa Boolean formula in disjunctive normal form. Formula F is the conjunction of a QBE3,∃ and a QBE3,∀ and, hence, thisreduction establishes the completeness of Outlier-min(L) on general theories for the class DP3. A similar reduction, but1850F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872exploiting a conjunction of a QBE2,∃ formula and a QBE2,∀ formula, is used to prove the hardness of Outlier-min(L) for DFdefault theories. (cid:2)Let us now consider the query Outlier-min(S)(L). Recall that given a default theory and two disjoint sets S and L, thisquery asks if L is a minimal outlier set having S as a witness set in the theory. Note that this query is at least as complex asquery Outlier(S)(L) that checks whether L and S represent a pair of outlier (not necessarily a minimal one) and a witness.The precise complexity is stated next.Theorem 4.8. Outlier-min(S)(L) on propositional default theories is (cid:10)Ptheories.3-complete for general theories, and (cid:10)P2-complete for DFdo not satisfy Definition 3.2, i.e. (D, W S(cid:12) ) (cid:10)|(cid:14) ¬SProof outline. Let us first consider membership. In order to answer the query Outlier-min(S)(L) it must be verified that (a)S and L satisfy Definition 3.2, i.e., (D, W S ) |(cid:14) ¬S and (D, W S,L) (cid:10)|(cid:14) ¬S, and (b) for each subset Land(cid:12). The former query coincides with Outlier(S)(L),Land hence it is in DP2 (resp. DP) for general (resp. DF) theories. Vice versa, the query at (b) is in (cid:10)P2) for general(resp. DF) theories, since its negation can be answered by a nondeterministic polynomial time Turing machine that guesses(cid:12) ⊆ W L(cid:12) and then checks that they form an outlier and witness pair by using an oraclea pair of disjoint subsets Lin (cid:9)P2 . Thus, the overall problem is in (cid:10)PAs for hardness, in the case of general (resp., DF) theories, it is proved by reducing the problem of deciding the validityor (D, W S(cid:12),L(cid:12) ) |(cid:14) ¬S3 (resp. (cid:10)P2).3 (resp. (cid:10)P(cid:12) ⊆ L and Sof L, and Sof W L(cid:12) , S(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)of a QBE3,∀ (resp., QBE2,∀) formula to query Outlier-min(S)(L). (cid:2)4.3. Complexity results for extended (disjunctive) logic programsThis section discusses the complexity of detecting outliers when ELPs (Section 4.3.1) and EDLPs (Section 4.3.2) are con-sidered.4.3.1. Complexity of outlier detection in extended logic programsExtended logic programs, for which disjunction is not allowed, correspond to a subset of default theories. The correspon-dence between the two languages is as follows [26]. For each ELP rule r:L0 ← L1, . . . , Lm, not Lm+1, . . . , not Lnlet δ(r) denote the following default rule:L1 ∧ · · · ∧ Lm : ¬Lm+1, . . . , ¬LnL0,where the justification of δ(r) is the identically true literal true if r has no negation as failure literals (i.e., if n = m). Then,with every ELP P , we can associate a default theory (cid:3)P = ({δ(r) | r ∈ P }, ∅) such that the following holds [26]:(i) If M is an answer set of P , then the deductive closure of M is an extension of (cid:3)P , and(ii) every extension of (cid:3)P is the deductive closure of exactly one answer set of P .In the sequel, given an ELP rule-observations program P = (D, W ), (cid:3)(P ) will denote the associated default theory ({δ(r) |r ∈ D}, W ). Note that (cid:3)(P ) is disjunction-free. Similarly, given a disjunction-free default theory (cid:3) = (D, W ) such that foreach δ ∈ D, the consequent of δ is a literal and there is no conjunction in the justification of δ, P ((cid:3)) will denote theassociated rule-observations program ({r | δ(r) ∈ D}, W ).In order to state following complexity results, a technical Lemma is needed.Lemma 4.9. Let P = (D, W ) be an ELP rule-observations program and let (cid:3)(P ) be its associated DF default theory. Then L is an outlierset in P with witness set S iff L is an outlier set in (cid:3)(P ) with witness set S.Proof. By the relationship holding between the answer sets of the ELP P and the extensions of the default theory (cid:3)P statedin [26] (and recalled above), it follows that given an ELP rule-observations program P = (D, W ), for each subset Z of Wthe answer sets of P Z are in one-to-one correspondence with the extensions of (D(cid:12), W Z ) where (D(cid:12), W ) = (cid:3)(P ). (cid:2)All that given, the complexity results for general ELPs can be summarized in the following theorem.Theorem 4.10. The complexities of outlier detection problems over ELP are as follows:– Outlier, Outlier[k], and Outlier(L) are (cid:9)P– Outlier-min is DP– Outlier(S), Outlier[k](S), and Outlier(S)(L) are DP-complete.2-complete and Outlier-min(S)(L) is (cid:10)P2 -complete;2-complete, andF. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721851Proof. (Membership) Given an ELP rule-observations program P = (D, W ), by construction, (cid:3)(P ) is a disjunction-freedefault theory whose size is polynomially-bounded in the size of P . Thus, the claim follows from Lemma 4.9 and themembership parts of Theorems 4.1–4.8.(Hardness) Given a normal DF default theory (cid:3) = (D, W ) such that for each δ ∈ D, δ has the form L1∧···∧Lm:L0, P ((cid:3)) isan ELP rule-observations program whose size is, by construction, polynomially bounded in the size of (cid:3). Hence, hardnessfollows from Lemma 4.9 and the hardness parts of Theorems 4.1–4.8 concerning DF default theories. Indeed, we recall thatall the hardness parts of these theorems make use of a normal DF default theory such that the conclusion, and hence thejustification, of each default rule occurring in it consists in a single literal. (cid:2)L04.3.2. Complexity of outlier detection in disjunctive extended logic programsWe have analyzed the complexity of outlier detection problems for extended logic programs by exploiting results ob-tained for default theories. However, the more general class of extended disjunctive logic programs cannot be mapped to thelanguage of default theories. Therefore, we are not able to directly exploit the complexity results proved for default logicsin order to derive correspondent results for EDLPs. Nevertheless, it turns out that outlier detection problems on EDLPs areprecisely just as hard as the corresponding tasks evaluated on default logics, as summarized in the following theorem.Theorem 4.11. For general EDLPs, queries (1) Outlier, (2) Outlier[k], and (3) Outlier(L) are (cid:9)P(4) Outlier(S), (5) Outlier[k](S), and (6) Outlier(S)(L) are DP(8) Outlier-min(S)(L) is (cid:10)P3-complete.2-complete, query (7) Outlier-min(L) is DP3 -complete, queries3-complete, and query3 follows since, given a rule-observation pair P = (D, W ), the query can be answered byProof outline. (1) Membership in (cid:9)Pa polynomial-time nondeterministic Turing machine that guesses the outlier set L and the witness set W and then employs2 oracle to decide P S |(cid:14) ¬S (a (cid:10)Pa (cid:9)P(cid:9)P3 -hardness is proved by reducing the problem of the validity of a QBE3,∃ formula to query Outlier. The reductionassociates a negation-free EDLP rule-observation pair P ((cid:11)) = (D((cid:11)), W ((cid:11))) with a QBE3,∃ formula (cid:11) = ∃ X∀Y ∃Z f ( X, Y , Z )in conjunctive normal form. The properties of P ((cid:11)) are analogous to the properties of the default theory (cid:3)((cid:11)) which weredescribed when discussing query Outlier on default theories (see Theorem 4.1). However, differently from Theorem 4.1, asaturation technique is employed to guarantee those properties.2 problem) and P S,L (cid:10)|(cid:14) ¬S (a (cid:9)P2 problem).(2) and (3) The proof uses the same ideas illustrated for query Outlier.(4) Membership in DP2 can be proved by taking into account that the problem corresponds to the conjunction of twoindependent problems, namely, deciding whether P S |(cid:14) ¬S and whether P S,L (cid:10)|(cid:14) ¬S. While the former problem is in (cid:10)P2, itcan be shown that the latter is in (cid:9)P2 even though L is not provided as input to the problem. Indeed, one can proceed byguessing together the outlier set L and a (minimal) model M of P S,L such that ¬S (cid:10)⊆ M and then checking that it is indeedminimal by exploiting an NP oracle.(cid:12)(cid:12)DP2-hardness is proved by reducing to query Outlier(S) the problem of deciding whether a program P(cid:9)Pis inconsistent (a (cid:10)P2 check).2 check) and a program P(5) and (6) The results can be proved using the same line of reasoning as illustrated above for query Outlier(S).(7) Membership is analogous to that of Theorem 4.7. As for the hardness, the line of reasoning is analogous to thatof the hardness part of Point 1 of Theorem 4.7, but, from a technical point of view, the construction used in Point 1 ofTheorem 4.11, where a (cid:9)Pand(cid:12)(cid:12)r, representing two distinct copies of the program used in the reduction shown in Point 1 of this theorem, are used inorder to build a logic rule-observations program P (F ) such that the conjunction F = (cid:11) ∧ (cid:12) of a QBE3,∃ formula (cid:11) (encoded(cid:12)(cid:12)) is valid if and only if a suitable set L is a minimal outlier setvia rules rin P (F ).3 -complete problem is taken into account, is employed. Loosely speaking, two sets of rules, r) and of a QBE3,∀ formula (cid:12) (encoded via rules r(cid:12)(cid:12)(cid:12)is consistent (a(8) Both membership and hardness are analogous to that of Theorem 4.8 and the hardness exploits rules rPoint 7 of this proof. (cid:2)5. The first-order case(cid:12)(cid:12)used inWe now discuss the extension of our framework to the first-order case, where variables are allowed to occur in defaults.We will use a formal framework which is similar in several aspects to the one set down by Cadoli et al. [15].A finite first-order default theory (cid:3) = (D, W ) consists of a finite set W of first-order formulas and of a finite set D ofdefault rules of the form (1), with the prerequisite, justifications, and consequence being first-order formulas with freevariables among those in X = X1, . . . , Xn. A default is closed if none of α, β1, . . . , βn, and γ contains free variables. A defaulttheory is closed if all the formulas in W and in D are closed. A default or default theory which is not closed is called open.It is assumed that the Herbrand Universe U of a finite default theory is nonempty and finite (hence, no function symbolsare allowed to occur in the theory). In the following we will consider only finite first-order default theories.The semantics of a closed first-order default theory is based on the notion of extension, whose definition is analogousto the definition of extension provided in Section 2.1 in the context of a propositional default theory [15]. The definition of1852F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872extension is applied to open default theories by assuming that the defaults with free variables implicitly stand for the setof closed defaults obtained by replacing those free variables with terms of the Herbrand Universe U of the default theory.Let φ(X) be a formula whose free variables are among X = X1, . . . , Xn, and let ζ = ζ1, . . . , ζn be a list of objects from U .Then, we denote by φ[X/ζ ] the result of simultaneously substituting ζi for Xi in φ, for all i = 1, . . . , n. Let (cid:3) = (D, W ) be afirst-order default theory. We denote by INST(W ) the instantiation of W , which is the set of closed formulasφ[X/ζ ] | φ(X) ∈ W , ζ ∈ U n.(cid:6)(cid:5)(cid:3)Similarly, we denote by INST(D) the instantiation of D, which is the set of closed defaultsα[X/ζ ] : β1[X/ζ ], . . . , βm[X/ζ ]γ [X/ζ ]| α(X) : β1(X), . . . , βm(X)γ (X)(cid:4)∈ D, ζ ∈ U n,and serves the purpose of eliminating free variables from the formulas.The instantiation INST((cid:3)) of (cid:3) is (INST(D), INST(W )). For example, consider a group of friends who have to decidewhether to go together to watch a movie or not, given that some of them do not like going to the movies. This is encodedin the theory (cid:3)ex = (D, W ), whereThen U = {mary, jennie, movie}, and the instantiation INST((cid:3)ex) of (cid:3)ex is such that INST(W ) = W and INST(D) is(∃ X)(¬likes( X, Y )) : ¬watch(Y )¬watch(Y )(cid:4),andlikes(mary, movie), ¬likes(jennie, movie), watch(movie)(cid:6).(cid:3)D =W =(cid:5)(cid:3)(∃ X)(¬likes( X, mary)) : ¬watch(mary)¬watch(mary)(∃ X)(¬likes( X, movie)) : ¬watch(movie)¬watch(movie),(∃ X)(¬likes( X, jennie)) : ¬watch(jennie)¬watch(jennie)(cid:4),.Now we are in a position to extend the definition of outlier in the context of first-order default theories.Definition 5.1 (First-order outliers and outlier witness set). Let (cid:3) = (D, W ) be a first-order default theory and let L ⊆ W be aset of ground literals. If there exists a nonempty set of ground literals S ⊆ W L such that:(i) (INST(D), INST(W )S ) |(cid:14) ¬S, and(ii) (INST(D), INST(W )S,L) (cid:10)|(cid:14) ¬Sthen we say that L is an outlier set in (cid:3) and S is an outlier witness set for L in (cid:3).For example, consider the theory (cid:3)ex above. Then L = {¬likes(jennie, movie)} is an outlier with the witness S ={watch(movie)}.Given a finite default theory (cid:3), the instantiation of (cid:3) contains only closed formulas but it is not in general a ground theory,due to the possible presence of quantifiers. A finite propositional default theory can be anyway associated with (cid:3) as follows.Let F = ∀ Xφ( X) (F = ∃ Xφ( X), resp.) be a universally (existentially, resp.) quantified formula. Then, the propositionalversion PROP(F ) of F (under Domain Closure) is the formulaζ ∈U φ(ζ ), resp.). The propositional versionPROP(φ) of a quantifier-free formula φ is the formula φ itself. Let φ be a formula, then propositional version PROP(φ) of φ isobtained by recursively substituting each subformula ψ of φ with its propositional version PROP(ψ).ζ ∈U φ(ζ ) ((cid:13)(cid:12)Let (cid:3) = (D, W ) be a first-order default theory. We denote by PROP(W ) the propositional version of W , which is the setof propositional formulas(cid:5)(cid:6)PROP(φ) | φ ∈ INST(W ).(cid:3)Similarly, we denote by INST(D) the propositional version of D, which is the set of propositional defaults| α : β1, . . . , βmγPROP(α) : PROP(β1), . . . , PROP(βm)PROP(γ )∈ INST(D)(cid:4).The propositional version PROP((cid:3)) of (cid:3) is the propositional default theory (PROP(D), PROP(W )). Since it has been assumedthat the Herbrand Universe U of the theory (cid:3) is finite, the propositional default theory PROP((cid:3)) is finite. For example,consider the theory (cid:3)ex above. The propositional version PROP((cid:3)ex) of (cid:3)ex is such that PROP(W ) = W and PROP(D) is(cid:3)¬likes(mary, movie) ∨ ¬likes(jennie, movie) ∨ ¬likes(movie, movie) : ¬watch(movie)¬watch(movie)¬likes(mary, mary) ∨ ¬likes(jennie, mary) ∨ ¬likes(movie, mary) : ¬watch(mary)¬watch(mary)¬likes(mary, jennie) ∨ ¬likes(john, jennie) ∨ ¬likes(movie, jennie) : ¬watch(jennie)¬watch(jennie),,(cid:4).F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721853Let (cid:3) = (D, W ) be a first-order default theory, and let S, L ⊆ W two disjoint subsets of ground literals. Then, by constructionof PROP((cid:3)), if L is an outlier with witness S in (cid:3) then L in an outlier with witness S in the propositional default theoryPROP((cid:3)). The converse holds provided that outliers and witnesses are constrained to be subsets of W ∩ PROP(W ).5 Wehave already remarked that constraining outliers and witnesses to be singled out from a given subset of set of literalsin W does not change the complexity figures. Thus, if PROP((cid:3)) is a finite propositional default theory, complexity results ofSection 4.2 can be directly applied to the case in which the input theory is PROP((cid:3)). Thus, the complexity analysis presentedin Section 4.2 allows us to characterize the difficulty of the mining problem at hand once the propositional version of thefirst-order theory is available.For example, consider the theory (cid:3)ex = (D, W ). Since PROP(W ) = W , the outliers in the propositional theory PROP((cid:3)ex)are in one-to-one correspondence with the outliers in the first-order theory (cid:3)ex.As a matter of fact, it must be recalled that the theory PROP((cid:3)) can be exponentially larger than (cid:3). And, indeed, it canbe seen that, due to the exponential increase of the size of the theory, the complexity of deciding the existence of an outlierin a first-order theory is in NEXPTIME(cid:9)P2 , which is the exponential analogue for (cid:9)P3= NP(cid:9)P2 .Furthermore, as we have already pointed out, our approach is to regard outlier detection as a data mining technique, andtherefore we mine from explicitly observed facts belonging to W . These facts can be very naturally regarded as tuples ofa database from which we are interested in singling out anomalies. In the database scenario, a rather pertinent issue is tocharacterize the data complexity [57], i.e., the complexity of query evaluation when the database is assumed to vary, whereasthe query expression is assumed to be fixed. Next, we are going to address this issue in the context of outlier detection indefault theories scenario.Let (cid:3) = (D, W ) be a first-order default theory. We denote by W fact the extensional component of (cid:3), that is the subsetof W consisting in all the ground literals in W . The extensional component can be assimilated to a relational database. Thefirst-order component of (cid:3) is, conversely, the set W rule = W \ W fact.Definition 5.2 (Data complexity of outlier detection queries). The data complexity of an outlier query Q , where Q is one ofthe queries defined in Section 4.1, when the knowledge base is a first-order default theory (cid:3) = (D, W rule ∪ W fact), is thecomplexity of deciding Q measured in the size of the extensional component W fact of (cid:3).In other words, the data complexity of Q is the complexity of answering Q on a first-order default theory, under theassumption that the set of default rules and the first-order component are held fixed and the only component allowed tovary is the extensional one.Next we show that under data complexity measure, the query Outlier is (cid:9)P3 -complete, that is, it has the same complexityas that of its propositional counterpart.Theorem 5.3. The data complexity of Outlier is (cid:9)P3 -complete.Proof outline. Consider membership. Given a first-order default theory (cid:3) = (D, W rule ∪ W fact), let k be the maximumnumber of variables occurring in a default rule in D or in a formula in W rule, and let n be the number of distinct elementsin the Herbrand Universe U of (cid:3). The number n is at most linear in the size of the extensional component W fact of (cid:3),that is n = O(|W fact|). Hence, assuming that D and W rule are not part of the input, the size of the theory PROP((cid:3)) is O(nk),hence polynomial in the size of W fact which is the input of the Outlier query. In order to complete the proof, it is sufficientto recall that the query Outlier for finite general propositional default theories is in (cid:9)P3 , as shown in the membership partof Theorem 4.1, Point 1.As for hardness, it can be shown (see the appendix for details) that there exists a fixed set of default rules D FO anda fixed set of non-atomic formulas W FO, together with a mapping which given as input a QBE3,∃ formula (cid:11) outputs aset W ((cid:11)) of ground atoms, such that the theory PROP(((cid:3)FO, W FO ∪ W ((cid:11)))) is equivalent to the propositional theory (cid:3)((cid:11))described in the hardness part of Theorem 4.1, Point 1. The rest of the proof then follows from the above mentionedtheorem. Details of the reduction are reported in the appendix. (cid:2)The construction described in the proof of Theorem 5.3 can be used to adapt the other reductions depicted in thehardness part of theorems concerning general propositional default theories in order to obtain reductions valid under thedata complexity measure. Therefore, we obtain:Theorem 5.4. The data complexity of (i) Outlier is (cid:9)POutlier[k](S), and Outlier(S)(L) is DP3 -complete; (ii) Outlier[k] and Outlier(L) is (cid:9)P2-complete; (iv) Outlier-min(L) is DP3-complete, and (v) Outlier-min(S)(L) is (cid:10)P3 -complete; (iii) Outlier(S),3-complete.By construction, both Theorems 5.3 and 5.4 hold for finite normal first-order default theories.5 From a technical point of view, the transformation PROP((cid:3)) can be modified so that both directions hold immediately. To this aim it suffices to replaceopen (and, in the case there is a single constant in U , also non-ground) literals (cid:2) in W with formulas of the form f ∨ ¬ f → (cid:2).1854F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18726. Related workResearch related to the work presented in this paper can be divided into three groups: (i) abduction, (ii) outlier detectionfrom data, and (iii) outlier detection using logic programming under stable model semantics.6.1. AbductionThe research on logic-based abduction [16,19,22,23,32,39,47,51,52] is related to outlier detection. Generally speaking,in the framework of logic-based abduction, the domain knowledge is described using a logical theory T . A subset X ofhypotheses is an abduction explanation to a set of manifestations M if T ∪ X is a consistent theory that entails M.The work by Eiter, Gottlob, and Leone on abduction from default theories [24] is very relevant to the work presentedhere. In that paper, the authors present a basic model of abduction from default logic and analyze the complexity of someassociated abductive reasoning tasks. They also present two modes of abduction: one based on brave reasoning and theother on cautious reasoning. According to [24], a default abduction problem (DAP) is a tuple (cid:21)H, M, W , D(cid:22) where H is a setof ground literals called hypotheses, M is a set of ground literals called observations, and (D, W ) is a default theory. The goalis to explain observations from M by using hypotheses in the context of the default theory (D, W ). The authors proposethe following definition for an explanation:Definition 6.1. (See [24].) Let P = (cid:21)H, M, D, W (cid:22) be a DAP and let E ⊆ H . Then, E is a skeptical explanation for P iff(i) (D, W ∪ E) |(cid:14) M, and(ii) (D, W ∪ E) has a consistent extension.The relationship between outlier detection on normal propositional default theories and skeptical explanations is sum-marized by the following theorem.Theorem 6.2. Let (cid:3) = (D, W ) be a normal default theory, where W is consistent. Also, let L ⊆ W and S ⊆ W be two disjointsets. Then S is an outlier witness set for L in (cid:3) if and only if L is a minimal nonempty skeptical explanation for ¬S in the DAPP = (cid:21)L, ¬S, D, W S,L(cid:22).Proof.(i) (“Only If”) Let (cid:3) = (D, W ) be a normal default theory, L ⊆ W , and S ⊆ W an outlier witness set for L. By our definitionof outlier, it must be the case that (D, W S ) |(cid:14) ¬S, or in other words, (D, W S,L ∪ L) |(cid:14) ¬S. Moreover, since (D, W ) is anormal default theory, so is (D, W S,L ∪ L). In addition, since W is consistent, so is W S . Hence, (D, W S ) has a consistentextension. Therefore, by Definition 6.1, L is a skeptical explanation for ¬S in the DAP P .(ii) (“If”) Suppose L is a minimal nonempty skeptical explanation for ¬S in the DAP P = (cid:21)L, ¬S, D, W S,L(cid:22). By definition, wehave:(a) (D, W S ) |(cid:14) ¬S, and(b) (D, W S ) has a consistent extension.Moreover, since L is a minimal nonempty explanation, at least one of the following must be true:(a) (D, W S,L) (cid:10)|(cid:14) ¬S, or(b) (D, W S,L) does not have a consistent extension.Since (cid:3) = (D, W ) is a normal default theory and W is a consistent theory, it must be the case that (cid:3) = (D, W S,L) isalso a normal default theory and W S,L is consistent. Hence, the default theory (D, W S,L) has a consistent extension.Therefore it must be the case that (D, W S,L) (cid:10)|(cid:14) ¬S, and it can be concluded that S is an outlier witness set for Lin (D, W ). (cid:2)In sum, it follows that some sort of duality does hold in the context of normal default theories between abductionand outlier detection problems. Nonetheless, in outlier detection problems, the outlier witness set S (which according toTheorem 6.2 is the analog to the set of observations in abduction problems) has to be guessed, while the set of observationsin abduction is given in the input. We have shown in Section 4 that the high complexity of the outlier detection problemsarises from the fact that the set S is not given in advance. Hence, the fact that the witness set S is not given in input isquite significant from the computational complexity point of view and prevents us from borrowing complexity results fromabduction problems.Remark 6.3. Theorem 6.2 is valid also for ordered semi-normal default theories. This is because the second condition inDefinition 6.1 requires a default theory which has at least one consistent extension, and ordered semi-normal default the-ories are guaranteed to have this property (see [25]). For other subclasses of default theories, however, Theorem 6.2 mightnot hold. Consider for example the following default theory (cid:3) = (D, W ), where D = { l:¬s} and¬s ,¬s:¬q∧pp¬s:¬l∧qq¬s:¬p∧ll,,F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721855W = {l, s}. This default theory is semi-normal but not ordered. The reader can verify that {l} is an outlier set and {s} is itswitness set. However, since (D, W {s}) does not have a consistent extension, we cannot say that {l} is a minimal nonemptyskeptical explanation for ¬{s} in the DAP P = (cid:21){l}, ¬{s}, D, W {s},{l}(cid:22).Research on logic-based abduction from disjunctive logic programs [22,52] is also related to outlier detection, and hascomprehensibly been studied in the context of logic programming (see [19] for a survey). This issue has been exploredin two directions. The first line of work has used logic programs as an AI tool for knowledge representation and reasoningabout abduction, while the second approach has used the concept of abduction for defining the semantics of logic programs.In the context of disjunctive logic programming, research has focused on the relationship between semantics of DLP andabduction-based semantics of logic programs (see, for example, [52]).Eiter et al. [22] have studied abduction in the context of normal and disjunctive logic programs that have only one type ofnegation, namely, negation by failure, but have not considered extended logic programs where both classical negation andnegation by failure are allowed. In addition, unlike our framework, the model of Eiter et al. does not allow for an explicitexploitation of integrity constraints. Their abduction schema assumes that the inference operator is provided as an input.Eiter et al. define a logic programming abduction problem as follows:Definition 6.4. (See [22].) Let V be a set of propositional atoms. A logic programming abduction problem (LPAP) P over Vconsists of a tuple (cid:21)H, M, L P , |(cid:14)(cid:22), where H ⊆ V is a finite set of hypotheses, M ⊆ V ∪ {¬v | v ∈ V } is a finite set ofmanifestations, L P is a propositional logic program on V and |(cid:14) is an inference operator.They define a solution to an LPAP as:Definition 6.5. (See [22].) Let P = (cid:21)H, M, L P , |(cid:14)(cid:22) be an LPAP, and let S ⊆ H . Then S is a solution (or explanation) to P iffL P ∪ S |(cid:14) M.According to [22], abductive conclusions should not lead to inconsistency. Hence, they use a variant of skeptical inferencein which some answer set must exist. We cannot establish a formal relationship between outlier detection and abductionon disjunctive logic programs because the definition of outliers requires the ability to prove negative literals in the classicalnegation sense, while in the semantics used in [22], one can never prove negative literals since the program itself does notuse any negative literal.Sakama and Inoue have defined abduction in the context of EDLPs, and suggested a program transformation between“abductive programs” and disjunctive programs [52]. However, their techniques and complexity results do not apply to thecase of outlier detection since they have investigated credulous reasoning rather than skeptical reasoning, and since in theirframework an observation is constrained to be a single literal.However, if we use the framework of Eiter et al. as described in Definitions 6.4 and 6.5, and adapt it to a “skeptical”version of the work of Sakama and Inoue, we can show the following.Theorem 6.6. Let P = (D, W ) be a rule-observations program and let L, S ⊆ W . Then the following holds:(i) If S is an outlier witness set for L in P , then L is an explanation in the LPAP A = (cid:21)W , ¬S, P(cid:12) = (D, W S,L), |(cid:14)(cid:22), where |(cid:14) isentailment from EDLPs as defined in Section 2.2, and(ii) If L is a minimal explanation in the LPAP A = (cid:21)W , ¬S, PSection 2.2, then S is an outlier witness set for L in P .(cid:12) = (D, W S,L), |(cid:14)(cid:22), where |(cid:14) is entailment from EDLPs as defined inProof.(i) Let P = (D, W ) be a rule-observations program and let L, S ⊆ W . Assume S is an outlier witness set for L in P . Bydefinition of outlier, it must be the case that (D, W S,L ∪ L) |(cid:14) ¬S. Then, by Definition 6.5, L is an explanation for ¬S inthe LPAP A.(ii) Suppose L is a minimal explanation for ¬S in the LPAP A = (cid:21)W , ¬S, P(cid:12) = (D, W {S,L}), |(cid:14)(cid:22). By Definition 6.5, it is knownthat:(D, W S,L ∪ L) |(cid:14) ¬S.Therefore (D, W S ) |(cid:14) ¬S. Moreover, since L is a minimal explanation, the following must be true:(D, W S,L) (cid:10)|(cid:14) ¬S.Hence, it can be concluded that S is an outlier witness set for L in (D, W ). (cid:2)1856F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872As with default logic, there is a clear difference between those two frameworks. The construction given in the proof ofTheorems 6.2 and 6.6 does not provide a technique to solve outlier detection problems using abduction, since for outlierdetection both the outlier L and its outlier witness set S have to be singled out, while in abduction both hypotheses andobservations are fixed sets. In fact, outlier detection is a knowledge discovery technique: the task in outlier detection is tolearn the exceptional observations along with the information witnessing for it.6.2. Outlier detection from dataThe vast body of literature concerning outlier detection in databases largely exploits techniques borrowed from statistics,machine learning and other fields [9,28,56]. In almost all cases, the techniques deal with data organized as a single relationaltable. Often only numerical attributes are handled and a metrics relating pairs of rows in the table are first required. Theseapproaches can be classified as supervised-learning methods, where each example must be labeled as exceptional or not[37,50], and unsupervised-learning methods, where such labels are not required. The latter approach is obviously moregeneral. As the technique proposed in our work is unsupervised, the sequel of this section will focus on unsupervisedtechniques. These techniques can be categorized into various groups.Statistical-based methods, which assume that the given data set has a distribution model. Outliers, then, are those objectsthat satisfy a discordancy test, that is, that are significantly larger (or smaller) w.r.t. the values they are supposed to assumeaccording to the hypothesized distribution [9].Deviation-based techniques identify outliers by inspecting the typical characteristics of objects and defines them as ob-jects that deviate from those features [8,53].A rather different technique, which finds outliers by observing low dimensional projections of the search space, is presentedin [1]. In that paper, a point is considered an outlier if it is located in some low density subspace.Yu et al. [17] introduced a method based on wavelet transform, that identifies outliers by removing clusters from theoriginal data set. Wavelet transform has also been used in [55] to detect outliers in stochastic processes.A further group of methods use density-based techniques [14] and exploit a notion of locality that measures the plausi-bility for an object to be an outlier with respect to the density of the local neighborhood. To reduce the computational load,Jin et al. [30] proposed a method to determine only the top-n local outliers.Distance-based outlier detection was introduced by Knorr and Ng [34,35] to overcome the limitations of statistical meth-ods. A distance-based outlier is defined as follows: A point p in a data set is an outlier with respect to parameters k and R ifat least k points in the data set lie at a distance greater than R from p. This definition generalizes the definition of outlier instatistics and is appropriate when the data set does not fit any standard distribution. Ramaswamy et al. [48] modified theabove definition of outlier. They do not provide any ranking for outliers that are singled out. The definition they suggest isbased on the distance of the kth nearest neighbor of a point p, denoted by Dk(p), and proceeds as follows: Given k and n, apoint p is an outlier if no more than n − 1 other points q in the data set have a higher value for Dk(q) than p. This means that thepoints q having the n greatest Dk(q) values are singled out as outliers. A definition of outlier that considers for each pointthe sum of the distances from its k nearest neighbors is proposed in [2,6,7]. The authors present an algorithm that uses theHilbert space-filling curve which exhibits scaling results close to linear. Similarly, a near-linear time algorithm for detectionof distance-based outliers exploiting randomization is described in [10].The general differences and analogies between the approaches described above and the one suggested in the presentwork are significant. In fact, those approaches deal with “knowledge,” as encoded within one single relational table. Incontrast, our technique deals with complex knowledge bases, which though comprising relational-like information, generallyalso include semantically richer forms of knowledge, such as axioms, default rules and so forth. Hence, in the frameworkanalyzed in this paper, complex relations relating objects of the underlying theory can be expressed. As a consequence,even if the intuitive and general sense of computing outliers in the two contexts is analogous, the conceptual and technicaldevelopments are quite different as well as the formal properties of the computed outliers.Sometimes domain knowledge can help to single out outliers that would otherwise be difficult to identify via methodslike the ones surveyed above. The following example is intended to provide some intuition about this. The example alsoserves to highlight the different types of knowledge that can be mined using our approach as opposed to these others.For this purpose, we make a comparison between our approach and a typical distance-based approach. To facilitate thecomparison, we will use an example where literals included in the evidential knowledge denote facts concerning integernumbers.Example 6.7. Let I = {0, 1, 2, . . . , 99, 100}. Consider a binary predicate p(x, y), which normally is used to represent pairs(x, y) ∈ I 2 such that (a) x + y = 100 and (b) x (cid:10)= y, and assume the following set of observations is available:(cid:6)(cid:5)DB =p(0, 100), p(1, 99), p(2, 98), . . . , p(49, 51), p(50, 50), p(51, 49), . . . , p(98, 2), p(99, 1), p(100, 0).According to the knowledge informally stated above, the literal p(50, 50) is associated with an anomaly in D B, since thepair of integers x = 50 and y = 50 satisfies condition (a) but not condition (b).Now, suppose one wants to single out anomalous observations in DB. In that case, in the absence of domain knowl-edge, an unsupervised data mining technique could be used to mine outliers in DB. For example, the distance-based outlierF. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721857definition given in [34] would be suitable for this purpose. Assume that the Euclidean distance is employed and that pa-rameters k and R are set to k = 3 and R =2 (which is the distance separating each point (x, y) of DB from its nearest(cid:12)) in DB). According to these parameters, there are two outliers in DB, namely, (0, 100) and (100, 0). Theseneighbor (xtwo points are precisely the two extremes of the distribution associated with points in DB.(cid:12), y√Notice that, according to the distance-based definition, point (50, 50) is the worst candidate to represent an outlier in DB,since it is, in fact, the centermost point of DB. And indeed, for each combination of values for the parameter k and R, itholds that the point (50, 50) is a distance-based outlier in DB if and only if all the points in DB are distance-based outliers.A similar situation would characterize the other methods surveyed above in this subsection.Assume, conversely, that the domain knowledge informally stated above is available as encoded in a default theory(cid:3) = (D, W ) such that(cid:5)W = DB ∪(cid:3)s(x, y, x + y) | x, y ∈ I¬s(x, y, 100) ∨ e(x, y) : ¬p(x, y)¬p(x, y)∪D =(cid:6)(cid:5)e(x, x) | x ∈ I(cid:4)(cid:6),(cid:3)| x, y ∈ I∪and: ¬s(x, y, z)¬s(x, y, z)(cid:4)| x, y, z ∈ I,where the ternary predicate s(x, y, z) represents the sum (s(x, y, z) is in W if z = x + y) and the binary predicate e(x, y)represents the equality (e(x, y) is in W if x = y). By exploiting Definition 3.2, the abnormality perceived in the knowledgeencoded by theory (cid:3) can be singled out. Indeed(D, W {p(50,50)}) |(cid:14) ¬p(50, 50),(D, W {p(50,50)},{e(50,50)}) (cid:10)|(cid:14) ¬p(50, 50),andand the set S = {p(50, 50)} is an outlier witness set for the outlier set L = {e(50, 50)}. Loosely speaking, {e(50, 50)} beingan outlier can be interpreted as the number 50 behaving abnormally, while {p(50, 50)} being a witness can be interpretedas the explanation of its abnormality, that is that the point (50, 50) does not satisfy both conditions (a) and (b) but is,nonetheless, included in the set of observations DB concerning the predicate p. (cid:2)Before concluding, we want to emphasize that the framework developed in this paper relies heavily on the concept ofdefault rules. The default rules describe what is normally expected, and hence can be exploited for detecting observationswhich are not normal according to the default theory at hand. Such default rules are not given in advance in the frameworksdiscussed in this section. Furthermore, along with outliers, we single out their “witnesses”—those unexpected properties thatcharacterize outliers. As far as we know, no such justifications for outliers are provided by the approaches described above.6.3. Outlier detection using stable model semanticsWe have originally presented outlier detection in the context of default logics [4]. Outlier detection was successivelystudied in the context of non-disjunctive logic programs under stable model semantics in [5]. Next, we recall the notion ofstable model and the definition of outlier provided in [5].A propositional logic program (LP, for short) is a collection of classical-negation-free non-disjunctive propositional rules.Clearly, from a syntactic viewpoint, LPs form a subset of ELPs (precisely those consisting of all classical-negation-free ELPs).The stable model semantics of a LP P assigns to P the set of its stable models SM(P ), that corresponds to the set of theanswer sets of P .Let S be a set of propositional letters. Then, program P entails S (resp. ¬S), denoted by P |(cid:14) S (resp. P |(cid:14) ¬S), if for eachmodel M ∈ SM(P ) and for each letter L in S, L ∈ M (resp. L /∈ M).So, loosely speaking, logic programs rely on the closed world assumption (CWA for short), which states that everythingwhich is not explicitly inferred is false. Extended logic programs, on the other hand, relay on open world assumption (OWAfor short), which states that only what can be explicitly inferred is true, while all the rest is unknown.In the following, unless it is clear from the context, in order to differentiate the operator defined on logic programs(relying on the CWA) from the operator defined on extended logic programs (relying, vice versa, on the OWA), we willdenote the former by |(cid:14)cwa and the latter by |(cid:14)owa.A LP rule-observation pair P = (D, W ) is defined in [5] analogously to an ELP rule-observation pair, but D is a logicprogram and W is a set of letters (positive literals). Next, the definition of outlier in the context of logic programs understable model semantics is recalled.Definition 6.8. (Given in [5].) Let P = (D, W ) be a LP rule-observations program, and let L ⊆ W be a set of literals. If thereexists a nonempty set of literals S ⊆ W L such that:(i) P S |(cid:14)cwa ¬S, and(ii) P S,L (cid:10)|(cid:14)cwa ¬Sthen we say that L is an outlier set and S is an outlier witness set for L in P .1858F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872As already noted in the introduction, in [5] a weaker assumption is adopted to define outliers. Indeed, normal logicprograms under stable model semantics do not allow classical negation, but only negation as failure. As a consequence,in [5], the negation of the witness is not required to be explicitly inferred but, rather, that the witness is not entailed by thelogic program. This is in contrast to the view adopted in the present paper, by which the witnessing set for an outlier is aproperty that is explicitly observed and opposite to that which is expected. Hence, the approach of [5] singles out anomaliesof a different nature.These differences can be substantiated from a formal point of view by showing that Definitions 3.2 and 6.8 cannot bereduced one to the other by means of natural program transformations, which are usually employed in order to prove thatnormal logic programs are semantically equivalent to extended logic programs6 [26]. Given an (extended) logic program-observation pair P , we investigate two program transformations: the positive form Pof P which, informally speaking, isthe LP representing the counterpart of P under the stable model semantics, and the two-valued form Pof P , formallydefined next, which, loosely speaking, is the ELP representing the closed-world interpretation of P .−++we denote the propositional letter (cid:2) (resp., the propositional letter (cid:2)¬Definition 6.9. Let P = (D, W ) be an ELP rule-observation pair and let L be the set of the propositional letters occurringin P . For each (cid:2) ∈ L, let (cid:2)¬denote a novel propositional letter. Let L ∈ L be a positive literal (cid:2) (resp., negative literal+). Let S be a subset of L ∪ ¬L.¬(cid:2)), then by L++ | L ∈ S}. For each rule r = L1 ← L2, . . . , Lm, not Lm+1, . . . , not Ln, let rThen by Sdenote the rule+++) such that+, W+ = (D← L2 , . . . , LL1+ | r ∈ D} ∪ {C ← (cid:2), (cid:2)¬ | (cid:2) ∈ L} ∪ {(cid:2) ← C | (cid:2) ∈ L} ∪ {(cid:2)¬ ← C | (cid:2) ∈ L}, where C is a new letter. The last three sets are+ = {rDintroduced in order to assure that whenever a literal and its negation belong to an answer set, then the answer set is forcedto include all the literals appearing in the logic program.we denote the set {L+m+1, . . . , not Lof P is the LP rule-observation pair P+n . The positive form P+m, not L+By the results of [26], it holds that M is a consistent (resp., inconsistent) answer set for P if and only if Mresp.) is a stable model for P+.+(M+ ∪ {C},The definition of a two-valued form of an extended logic program (ELP) follows.Definition 6.10. Let P = (D, W ) be an ELP rule-observation pair and let L be the set of the propositional letters occurring− = D ∪{¬p ← not p | p ∈ L}in P . The two-valued form Pand Wof P is the ELP rule-observation pair P−) such that D− = W .− = (D−, W−Given an ELP (LP, resp.) rule-observation pair P , we denote by (cid:9)owa(P ) ((cid:9)cwa(P ), resp.) the set of pairs (S, L) such thatL is an outlier set in P and S is an outlier witness set for L in P according to Definition 3.2 (6.8, resp.).We show that the following three properties hold.– OP1: Let P be an ELP rule-observation pair, (S, L) ∈ (cid:9)owa(P ) (cid:2) (S+, L+) ∈ (cid:9)cwa(P+) and (S+, L+) ∈ (cid:9)cwa(P+) (cid:2)(S, L) ∈ (cid:9)owa(P ),– OP2: Let P be an ELP rule-observation pair, (S, L) ∈ (cid:9)owa(P ) (cid:2) (S, L) ∈ (cid:9)owa(P−) and (S, L) ∈ (cid:9)owa(P−) (cid:2) (S, L) ∈(cid:9)owa(P ),– OP3: Let P be a LP rule-observation pair, (S, L) ∈ (cid:9)cwa(P ) ⇔ (S, L) ∈ (cid:9)owa(P−).OP1 states that the outliers according to Definition 3.2 in a generic ELP program-observation pair P are incomparable with+of P ; OP2 states that the outliers according to Definition 3.2the outliers according to Definition 6.8 in the positive form Pin a generic ELP program-observation pair P are incomparable with the outliers according to Definition 3.2 in the two-valuedform Pof P ; and, finally, OP3 states that Definition 3.2 can be used to single out the outliers in a LP rule-observationpair P according to Definition 6.8, by means of the transformation P−−.It follows from these properties that the framework for mining outliers described here is more general than that de-scribed in [5].OP1, OP2 and OP3 are proved next.Theorem 6.11 (OP1). Let P be an ELP rule-observation pair. Then (S, L) ∈ (cid:9)owa(P ) (cid:2) (S(cid:9)cwa(P+) (cid:2) (S, L) ∈ (cid:9)owa(P ).+, L+) ∈ (cid:9)cwa(P+) and (S+, L+) ∈Next we prove the above statement by providing two counterexamples. Let us start with the first implication. Considerthe ELP pair (cid:14)P = (D, W ), where D includes the only rule¬p ← not p, q.6 We are grateful to an anonymous referee for suggesting this line of comparison.F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721859C ← p, pand W is the set {p, q}. Then, (cid:14)P+) is such that Dp ← C.is {p, q}. Consider the outlier L = {q} in (cid:14)P with the associated witness S = {p}. It is clear that L+, WC ← q, q¬ ← not p, q.p++ = (D¬and Wnot form an outlier-witness pair in (cid:14)P+¬, q} of (cid:14)P+M1 = {p{p}, the unique stable model M2 of the latter logic program is the empty set, and hence (cid:14)PAs for the second implication in OP1, consider the ELP pair (cid:15)P = (D, W ), where D includes only the ruledo. Indeed, while (cid:14)P+{p} |(cid:14)cwa ¬p, since p does not belong to the unique stable model+{p},{q} |(cid:14)cwa ¬p.¬ ← C.¬ ← C.q ← C.and Sisp+++q¬..p ← not q.and W is the set {p, q}. Then (cid:15)P¬+ = (D+, WC ← q, q+) is such that D¬+is¬ ← C.p ← not q.+p ← C..+ = {q} in (cid:15)P+and Wform an outlier-witness pair in P . Indeed, (cid:15)P {p} (cid:10)|(cid:14)owa ¬p, since the unique answer set of the ELP (cid:15)P {p} is {q}.C ← p, pis {p, q}. Consider the outlier Lq+ = {p}. It is clear that L and S do notwith the associated witness Sq ← C.p.¬ ← C.Theorem 6.12 (OP2). Let P be an ELP rule-observation pair. Then (S, L) ∈ (cid:9)owa(P ) (cid:2) (S, L) ∈ (cid:9)owa(P(S, L) ∈ (cid:9)owa(P ).−) and (S, L) ∈ (cid:9)owa(P−) (cid:2)Next we prove the above statement by providing two counterexamples. Let us start with the first implication in OP2.−), whereConsider again the ELP pair (cid:14)P of the preceding example, and the corresponding two-valued form (cid:14)PD− = (D−, Wis−is {p, q}. Consider the outlier L = {q} in (cid:14)P with the associated witness S = {p}. Also in this case, L and S do not−{p},{q} has the unique answer set {¬p, ¬q}, and{p} |(cid:14)owa ¬p, the ELP (cid:14)P. Indeed, while (cid:14)P−As for the second implication in OP2, consider again the ELP pair (cid:15)P of the preceding example, and the corresponding¬p ← not p.¬q ← not q.¬p ← not p, q.−and Wform an outlier-witness pair in (cid:14)P−hence (cid:14)P−{p},{q} |(cid:14)owa ¬p.two-valued form (cid:15)P−), where D−is− = (D−, W¬p ← not p.¬q ← not q.p ← not q.−is {p, q}. Consider the outlier L = {q} in (cid:15)P−and Woutlier-witness pair in (cid:15)P . Indeed, the unique answer set of (cid:15)P {p} is {q} and hence (cid:15)P {p} (cid:10)|(cid:14)owa ¬p.with the associated witness S = {p}. Then L and S do not form anNext we provide an intuition as to why those implications cited in Theorems 6.11 and 6.13 actually fail to hold.As for the positive form transformation (see Theorem 6.11), consider condition (ii) of Definition 3.2:P S,L (cid:10)|(cid:14)owa ¬S ≡(cid:11)(cid:10)(∃s ∈ S)(¬s /∈ M).∃M ∈ ANSW(P S,L)Following results from [26] and assuming consistency, condition (ii) of Definition 6.8 can be formulated as:++++ ≡(cid:11)(cid:10)(∃s ∈ S∃M ∈ ANSW(P S,L))(s ∈ M).PS+,L+ (cid:10)|(cid:14)cwa ¬SClearly, the first condition does not imply in general the second one since it might exist an answer set M such that both ¬s+). For the inverse implication a similar lineand s do not occur in M. Consequently, (S, L) ∈ (cid:9)owa(P ) (cid:2) (Sof reasoning can be followed.+) ∈ (cid:9)cwa(P+, LAs for the two-valued form transformation (see Theorem 6.13), consider again condition (ii) of Definition 3.2. Clearly,−this condition does not exclude that there exists an answer set M such that s /∈ M. Therefore, since in the program P−there is the rule ¬s ← not s, it might be the case that M is associated with an answer set Msuch that ¬s ∈ M−). For the inverse implication a similar line of reasoning can be drawn.Consequently (S, L) ∈ (cid:9)owa(P ) (cid:2) (S, L) ∈ (cid:9)owa(Pof P−−.Conversely, a faithful correspondence holds for (cid:9)cwa(P ) and (cid:9)owa(P−), as shown next.Theorem 6.13 (OP3). Let P be a LP rule-observation pair. Then (S, L) ∈ (cid:9)cwa(P ) ⇔ (S, L) ∈ (cid:9)owa(P−).Proof. It is well known that if M is a stable model of a LP P , then− = M ∪M(cid:5)(cid:6)¬(cid:2) | (cid:2) ∈ (L \ M),−where L is the set of all the propositional letters occurring in P , is an answer set of Pof Pcan be represented in the form shown above, where M is a stable model of P . Thus,(cid:10)(cid:11)(cid:10)∀M ∈ SM(P S )(s /∈ M) ⇔(cid:11)(cid:10)(s ∈ M) ⇔∃M ∈ SM(P S,L)− ∈ ANSW(P∀M(cid:10)∃M(cid:11)−(¬s ∈ MS )(cid:11)−− ∈ ANSW(P(¬s /∈ MS,L)−) ⇔ P−−S) ⇔ P|(cid:14)owa ¬S,and−S,L(cid:10)|(cid:14)owa ¬S.P S |(cid:14)cwa ¬S ⇔P S,L (cid:10)|(cid:14)cwa ¬S ⇔This completes the proof. (cid:2)−[26]. Moreover, every answer set1860F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872For example, consider the logic program P = (D, W ), where D consists of the only ruleq ← m, not e.and W is {q, m, e}. The ELP program P− = (D−, W−) is such that D−isq ← m, not e.−¬q ← not q.¬m ← not m.¬e ← not e.and Wpair also in Psince q belongs to the unique answer set of this program and consequently ¬q does not belong to it.is {p, m, e}. Consider the outlier L = {e} in P with the associated witness set {q}. L and P form an outlier-witness−{q},{e} (cid:10)|(cid:14)owa ¬q,−{q} |(cid:14)owa ¬q, due to the rule ¬q ← not q, and also that P. Indeed it can be verified that P−The following example helps in further clarifying the dissimilarities between the two frameworks. Consider a railroadcrossing scenario, and assume that the current state of the world viewed by Agent A is modeled by the proposition red_light,which represents the knowledge that the semaphore located near the railroad is red, and cross(B), representing the knowl-edge that Agent B is passing through the railroad track. The knowledge base of Agent A supposedly has a rule assertingthat normally the railroad should not be crossed when the light is red. Let us consider two formalisms for representing theknowledge base. First, assume that the knowledge of Agent A is encoded in a default theory, consisting of the single defaultrule red_light:¬cross(x)(or, equivalently, by the ELP rule under the answer set semantics ¬cross(x) ← not cross(x), red_light).Equipped with this knowledge, Agent A might conclude that something is wrong, since {cross(B)} is a witness for theoutlier {red_light}, in that removing cross(B) from the current state of the world explicitly derives the exact opposite, i.e.¬cross(B), while removing both cross(B) and red_light does not entail ¬cross(B). To conclude it is worth pointing out thatthe rule ¬cross(x) ← not cross(x), red_light plays the role of program (cid:14)P introduced in one of the counterexamples used toprove Theorem 6.11.¬cross(x)Second, assume that instead of being encoded in default logic, the knowledge of Agent A is encoded in a logic programunder stable model semantics. In this case, Agent A must rely on a kind of knowledge which is somewhat different andweaker than the knowledge encoded by the default rule above. Indeed, since there is no explicit negation in this formalism,a logic programming rule like cross(x) ← not red_light may be used. This rule models the somewhat hazardous decision:“if it is unknown that the semaphore light is red, then the railroad can be crossed”. According to the work of [5], in thissituation we will also conclude that red_light is an outlier and cross(B) is its witness. This is because after removing cross(B)from the current state of the world, cross(B) can no longer be explicitly inferred, and, consequently, ¬cross(B) is entailed,while after removing both cross(B) and red_light, cross(B) is explicitly inferred, and, consequently, ¬cross(B) is not entailed.Again, it is worth noticing the connection to the theorems proved above: in this case, the rule cross(x) ← not red_light playsthe role of program (cid:15)P introduced in one of the counterexamples used to prove Theorem 6.11.¬cross(x)This example demonstrates basic differences with the formalism adopted by [5]. Indeed, in the previous example, the de-fault rule red_light:¬cross(x)(or, equivalently, by the ELP rule under the answer set semantics ¬cross(x) ← not cross(x), red_light)captures the knowledge that normally the railroad should not be crossed when the light is red (unless, for example, thereis some state of emergency). One could claim that the rule we used under stable model semantics does not faithfully corre-spond to the default, since the rule states under which conditions one should cross, instead of saying, as done in the default,when one should not cross. The problem is that there is no natural way of saying anything similar in the language of normallogic programs under stable model semantics because this language has no classical negation and, by the previous theorem,classical negation cannot be faithfully simulated. To illustrate the other way around, note that with outlier detection understable model semantics of [5] all observations are encoded as positive literals. Now consider one such example where welook for outliers under stable model semantics. If we were to construct a perfectly corresponding example under defaultreasoning, with the same outliers and witnesses to be exactly there, then the involved default rules should have strongnegated literals as consequences according to Definition 3.2, but such consequences cannot be directly coded under stablemodel semantics, since strong negation is not allowed.It is also worth pointing out that complexity pictures derived for the fragment of non-disjunctive logic programs understable model semantics cannot be exploited to derive complexity results concerning disjunctive logic programs under answerset semantics, since the latter are more general. And, in fact, outlier detection using EDLPs is more complex than outlierdetection when disjunction-free logic programs under stable model semantics are considered. For instance, while it hasbeen shown in previous sections that the outlier existence problem is (cid:9)P3 -complete in the former case, the same problemis (cid:9)P2 -complete in the latter case (see [5]).7. ConclusionSuppose you are walking down the street and you see a blind person going in the opposite direction. You believe he isblind because he is feeling his way with a walking stick. Suddenly something falls out of his bag and to your surprise, hefinds it immediately without probing about with his fingers, as one would expect from a blind person. This kind of behaviorrenders that person to be blind a suspicious situation.In this paper we provided a formal framework for this type of commonsense reasoning. Our framework is essentially adata mining technique as it allows for automatic discovery of outliers. The user of a system built using our outlier detectionmethod does not have to specify the suspicious observations or provide a list of potential outliers. Rather, the systemF. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721861identifies the exceptional observations by analyzing the data and the default rules in the knowledge base at hand. Thismethod can be used in several applications such as diagnosis and homeland security.We used two related logics for our formal analysis: Reiter’s default logic and extended disjunctive logic programmingunder the answer set semantics. Reiter’s default logic was chosen because it constitutes a powerful nonmonotonic formalismthat deals with incomplete information, while logic programming was chosen for its practicality. Logic programming as atool of KR&R is widely employed in Artificial Intelligence, and some efficient implemented systems are available [38,40,43].We addressed several main issues related to this idea of outlier detection in the framework of default logics and ex-tended disjunctive logic programs under the answer set semantics. First, we introduced a formal definition of outliers andjustified it using several application examples. Second, we analyzed the complexities involved in incorporating the outlierdetection mechanism into knowledge bases expressed using default logic or extended logic programs. In our view, a thor-ough complexity analysis is essential for singling out the more complex subtasks involved in outlier detection. This first stepis conducive to designing effective algorithms for implementation purposes. We have also provided an extensive comparisonbetween our formalism and other methods that exist in the literature for outlier detection.Our approach relies on the existence of default rules in the knowledge base. Hence methods to automatically createdefaults are of interest for the application of our technique. For instance, the techniques developed by Nicholas and Duval[20,42], allow for learning default theories from examples. In Section 3.3 we demonstrated an example of outlier detectionin the context of learned default theories. Other techniques for learning rules deserve attention, and coupling our methodwith these techniques could be an interesting topic for future research. Among these other techniques, inductive logicprogramming deals with learning (variants of) logic programs in various settings [36]. For instance, Inoue and Kudoh [29]worked on learning extended logic programs. Learning rules can also be realized in semi-supervised settings using anapproach like metaquerying [3,13].This work can be extended in several directions. First, the concept of outliers in other frameworks of default reason-ing, like System Z [46], and Circumscription [41] should be studied. Second, intelligent heuristics that will enable theheavy computational task involved in efficient outlier detection should be investigated. In this respect, the identificationof tractable subsets for the task of outlier detection might be one possible step towards making the computation task moreefficient. Third, the ideas developed here might be exploited for using default logic for specifying semantically rich integrityconstraints on relational databases such that any tuple that does not comply with the constraints will be an outlier (cf.Section 3.3).Private and public organizations are overwhelmed with vast quantities of data and knowledge. Procedures that efficientlyanalyze the data and report only essential information are in great need. Our framework is one such knowledge discoveryprocedure as it is capable of identifying abnormal properties and abnormal observations automatically. It remains to find outhow the ideas developed in this paper will work in practice. To this end, we hope to develop a system for outlier detectionand test it on real-world data.AcknowledgementsThe authors thank Michael Gelfond for fruitful discussions and Francesco Scarcello and Gianluigi Greco for providinguseful insights into some of the computational complexity issues we have raised. The second author is grateful to BarbaraGrosz for inviting her to spend a year at Harvard DEAS as a visiting scholar. The authors are thankful to the anonymousreviewers for their valuable and constructive comments which have allowed to significantly improve the paper. We alsothank Estelle Schulgasser for proofreading this manuscript.Appendix A. Proofs for Section 4The following notations are used in this sequel.+Let L be a set of literals. Then we denote by Lthe set of positive literals occurring in L, and with L−the set of negativeliterals occurring in L.Let T be a truth assignment to the set x1, . . . , xn of variables. Then Lit(T ) denotes the set of literals {(cid:2)1, . . . , (cid:2)n}, suchthat (cid:2)i is xi if T (xi) = true and is ¬xi if T (xi) = false, for i = 1, . . . , n.Let T 1 and T 2 be two truth assignments on the disjoint sets X and Y of variables, respectively. Then T 1 ∪ T 2 denotes thetruth assignment T on the set of variables X ∪ Y such that T (x) = T 1(x), if x ∈ X , and T (x) = T 2(x), if x ∈ Y .Proof of Theorem 4.1. Outlier on propositional default theories is1. (cid:9)P2. (cid:9)P3 -complete, for general theories, and2 -complete, for DF theories.Proof. 1. (Membership) Given a theory (cid:3) = (D, W ), we must show that there exist two disjoint subsets L and S ={s1, . . . , sn} of W such that (D, W S ) |(cid:14) ¬s1 ∧ · · · ∧ ¬sn (problem q). Prob-2 -complete [27,54]. Thus, a polynomial-time nondeterministic Turing machinelem q) and (D, W S,l) (cid:10)|(cid:14) ¬s1 ∧ · · · ∧ ¬sn (problem q2-complete, while problem qis (cid:10)Pis (cid:9)P(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)1862F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872can be built with a (cid:9)Psolves problems q(cid:12)(cid:12)(cid:12)by two calls to the oracle.(Hardness) To prove the completeness of the query Outlier, the (cid:9)Pand qQBE3,∃ formula is reduced to it. A QBE3,∃ formula (cid:11) has the form∃ X∀Y ∃Z f ( X, Y , Z )2 oracle, which solves query Outlier as follows: the machine guesses both the sets L and S and then3 -complete problem of deciding the validity of awhere X, Y , Z are disjoint sets of variables, and f ( X, Y , Z ) is a propositional formula on X, Y , Z . Intuitively, the reductionassociates the default theory (cid:3)((cid:11)) = (D((cid:11)), W ((cid:11))) with the formula (cid:11) so that:– there exists one and only one literal l in W ((cid:11)) that may belong to an outlier set, but not to any witness set;– there exists a bijection between each of the possible outlier witness sets S from W ((cid:11)) and all the potential truthassignments of the variables in the set X ;– (cid:3)S ((cid:11)) = (D((cid:11)), W ((cid:11))S ) encodes (cid:11) so that (cid:3)S ((cid:11)) |(cid:14) ¬S iff ∀Y ∃Z f ( X, Y , Z ) is valid, subject to the truth assignmentof X induced by S;– {l} acts as a switch, that is, if removed from W ((cid:11))S then (D((cid:11)), W ((cid:11))S,{l}) (cid:10)|(cid:14) ¬S for each outlier witness set S.More formally, let (cid:11) = ∃ X∀Y ∃Z f ( X, Y , Z ) be a quantified Boolean formula, where X = x1, . . . , xn, Y = y1, . . . , ym, and Z aredisjoint set of variables. With (cid:11), the default theory (cid:3)((cid:11)) = (D((cid:11)), W ((cid:11))) is associated, where W ((cid:11)) is the set of literals{l, ¬φ, x1, . . . , xn}, and D((cid:11)) = D1 ∪ D2 ∪ D3 ∪ D4, where:(cid:12)xi : xi(cid:12)xi, δ1,2,i =: ¬xi¬xi, δ1,3,i =: ¬l¬l, δ2,3 =¬l : ¬φ¬φ, δ1,2,4 =(cid:12)¬xi : xi(cid:12)xi(cid:4)| i = 1, . . . , n,¬φ : xixi(cid:4),(cid:4)(cid:3)D1 =δ1,1,i =(cid:3)D2 =δ2,1 =(cid:3)(cid:3)D3 =D4 =δ4 = x, δ2,2 =: φφ: y jy j(cid:12)∧ · · · ∧ xn(cid:12)1δ3,1, j =, δ3,2, j =| j = 1, . . . , m,: ¬ y j¬ y j(cid:4)∧ ¬ f ( X, Y , Z ) : ¬φ¬φ(cid:12)(cid:12)(cid:12) = xn are new letters. Occurrences of these letters can be removed from the defaults in D((cid:11)) without affecting1, . . . , xand Xthe correctness of the reduction. However, their use makes the reduction easier to understand. Clearly, (cid:3)((cid:11)) can be builtin polynomial time. Now it is shown that (cid:11) is valid iff there exists an outlier in (cid:3)((cid:11)).First of all, we note that each extension E of the default theory (D((cid:11)), W ((cid:11))S ), where S is an arbitrary subset of W ((cid:11)),is the logical closure of a maximal consistent subset of the set U = ( X ∪ X(cid:12) ∪ Y ∪ Y(cid:12) ∪ {l, φ}) ∪ ¬( X ∪ Y ∪ {l, φ}).Claims 1–3 below take into account the role of the defaults belonging to the set D((cid:11)) defined above.Claim 1. Let S be a subset of W ((cid:11)), and (cid:3)(cid:12) = (D((cid:11)), W ((cid:11))S ). Then l ∈ S implies that (cid:3)(cid:12) (cid:10)|(cid:14) ¬s for each s ∈ W ((cid:11)) \ {l}.Proof of Claim 1. Assume that l ∈ S. Then, by applying rules δ2,2 and δ2,3, there exists an extension E of (cid:3)(cid:12)¬φ ∈ E. Consequently, for each xi ∈ S, by defaults δ1,3,i (1 (cid:2) i (cid:2) n), there exists an extension E i of (cid:3)(cid:12)such thatsuch that xi ∈ E i . (cid:2)Claim 2. Let S ⊆ W ((cid:11)) be an outlier witness for an outlier set L ⊆ W ((cid:11)) in (cid:3)((cid:11)). Then {¬φ} ⊆ S ⊆ W ((cid:11)) \ {l}.Proof of Claim 2. Let (cid:3)(cid:12)be the theory (D((cid:11)), W ((cid:11))S,L). Suppose that l ∈ S. FromClaim 1, l ∈ S implies that (cid:3)(cid:12) (cid:10)|(cid:14) ¬s, for each s ∈ W ((cid:11)) \ {l}. Hence, we can conclude that l ∈ S implies that S = {l}. But,because of rule δ2,3 and as there does not exist a rule in D((cid:11)) having l as its consequence, both (cid:3)(cid:12) |(cid:14) ¬l and (cid:3)(cid:12)(cid:12) |(cid:14) ¬l, nomatter what the value of L is. Thus, {l} cannot be an outlier witness for any set in W ((cid:11)), and S ⊆ W ((cid:11)) \ {l}.be the theory (D((cid:11)), W ((cid:11))S ) and let (cid:3)(cid:12)(cid:12)Suppose now that ¬φ does not belong to S, i.e., that S ⊆ {x1, . . . , xn}. Since the literal ¬φ belongs to W ((cid:11))S , there existssuch that E ⊇ {x1, . . . , xn} which is obtained by applying defaults δ1,3,i (1 (cid:2) i (cid:2) n), and S is not anan extension E of (cid:3)(cid:12)outlier witness set, a contradiction. (cid:2)Claim 3. Let T X be a truth assignment on the set X of variables and let S = {xi ∈ X | T X (xi) = false} ∪ {¬φ}. Then, for eachextension E of (D((cid:11)), W ((cid:11))S ), it holds that E ⊃ Lit(T X ).Proof of Claim 3. Assume that there exists an extension E of (D((cid:11)), W ((cid:11))S ) such that E (cid:10)⊇ Lit(T X ). Then it is the casethat there exists a letter xi , which is false according to T X , such that xi ∈ E. Since xi ∈ S, it is the case that rule δ1,3,i is agenerating default of E (while rule δ1,2,i is not). Notice now that the precondition of rule δ1,3,i is ¬φ. As ¬φ ∈ S, it is the(cid:12)case that rule δ4 is also a generating default of E applied before rule δ1,3,i . Since rule δ4 has the letter xi in its precondition,F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721863it can be concluded that δ1,2,igenerating default of E, or, equivalently, xi /∈ E, a contradiction. (cid:2)is a generating default of E applied before δ4 and that ¬xi ∈ E. Thus, δ1,3,i cannot be aWe now continue with the main proof.(⇒) Suppose that (cid:11) is valid. Then there exists a truth assignment T X on the set X of variables such that T X satisfies∀Y ∃Z f ( X, Y , Z ). Let S = {xi ∈ X | T X (xi) = false} ∪ {¬φ}. We will show that S is an outlier witness for {l} in (cid:3)((cid:11)).For each truth assignment T Y on the set of variables Y , consider the subset EY of the extensions of (D((cid:11)), W ((cid:11))S )consisting of the extensions E Y such that E Y ⊃ Lit(T Y ). In particular, by Claim 3, each E Y is such that E Y ⊃ Lit(T X ) ∪ Lit(T Y ).Since (cid:11) is valid, it is the case that there exists a truth assignment T Z to the set of variables Z such that T X ∪ T Y ∪ T Zsatisfies f ( X, Y , Z ). Hence, for each E Y ∈ EY , it holds that ¬ f ( X, Y , Z ) /∈ E Y , and the rule δ4 cannot be a generating defaultof the extension E Y . To conclude, the sets EY induce a partition of the set of all extensions of (D((cid:11)), W ((cid:11))S ), and hence(D((cid:11)), W ((cid:11))S ) |(cid:14) ¬S.(⇐) Suppose that there exists an outlier set L in (cid:3)((cid:11)). Then there exists a nonempty set of literals S such that S is anoutlier witness set for L in (cid:3)((cid:11)) and, from Claim 2, such that {¬φ} ⊆ S ⊆ W ((cid:11)) \ {l}.Let T X be the truth assignment to the set of variables X such that T X (xi) = false, if xi ∈ S, and T X (xi) = true, if xi /∈ S.Then, by Claim 3, for each extension E of (D((cid:11)), W ((cid:11))S ), it holds that E ⊇ Lit(T X ). Now it is shown that T X satisfies∀Y ∃Z f ( X, Y , Z ), i.e., that (cid:11) is valid. For each truth assignment T Y to the set of variables Y , there exists a subset EYof the extensions of (D((cid:11)), W ((cid:11))S ) that is the set of all the extensions E Y such that E Y ⊃ Lit(T Y ). We also recall thatE Y ⊃ Lit(T X ).Thus, in order for L to be an outlier in (cid:3)((cid:11)), it must be the case that, for each set of literals Lit(T Y ); for each set ofextensions EY ; and for each extension E Y ∈ EY , it holds that φ ∈ E Y . By defaults δ2,1 and δ4, φ ∈ E Y if and only if ¬φ /∈ E Yif and only if δ4 is not a generating default of E Y if and only if there exists a truth assignment to the set of variables Z suchthat T X ∪ T Y ∪ T Z satisfies f ( X, Y , Z ). As the sets of extensions EY form a partition of the extensions of (D((cid:11)), W ((cid:11))S ),we can conclude that (cid:11) is valid.As for the outlier set L, note that S is always an outlier witness set for L = {l} in (cid:3)((cid:11)). Indeed, consider the theory(cid:3)(cid:12)(cid:12) = (D((cid:11)), W ((cid:11))S,{l}). It follows from Claim 1 that (cid:3)(cid:12)(cid:12) (cid:10)|(cid:14) ¬S.(cid:9)P2. (Membership) Analogous to Point 1 of Theorem 4.1, the only difference being that an NP oracle is used in place of a2 oracle.(Hardness) Let (cid:11) = ∃ X∀Y f ( X, Y ) be a quantified Boolean formula in disjunctive normal form, where X = x1, . . . , xn andY = y1, . . . , ym are disjoint set of variables, and f ( X, Y ) = D1 ∨ · · · ∨ Dr , with Dk = tk,1 ∧ tk,2 ∧ tk,3, and each tk,1, tk,2, tk,3is a literal on the set X ∪ Y (k = 1, . . . , r). The default theory (cid:3)((cid:11)) = (D((cid:11)), W ((cid:11))) is associated with (cid:11), where W ((cid:11)) ={l, ¬φ, x1, . . . , xn} is a set of letters, with l and φ being new letters that are distinct from those occurring in (cid:11), and D((cid:11)) =D1 ∪ D2 ∪ D3 ∪ D4 is identical to the set of defaults reported in point 1 of Theorem 4.1 except for set D4 which is:(cid:3)D4 =δ4,h,k = x(cid:12)1(cid:12)∧ · · · ∧ xn¬dk∧ ¬tk,h : ¬dk| k = 1, . . . , r; h = 1, 2, 3∪(cid:4)(cid:3)δ4 =(cid:4)¬d1 ∧ · · · ∧ ¬dr : ¬φ¬φwhere d1, . . . , dr are new letters that are distinct from those occurring in (cid:11). Clearly, (cid:3)((cid:11)) can be built in polynomial time.By exactly following the same line of reasoning as in Theorem 4.1 Point 1, it can be shown that (cid:11) is valid iff there existsan outlier in (cid:3)((cid:11)). (cid:2)Proof of Theorem 4.3. Outlier(L) on propositional default theories is1. (cid:9)P2. (cid:9)P3 -complete, for general theories, and2 -complete, for DF theories.Proof.1. (Membership) The proof is analogous to that used in Point 1 of Theorem 4.1.(Hardness) The reduction is the same as that in Point 1 of Theorem 4.1. Clearly, (cid:11) is valid iff {l} is an outlier setfor (cid:3)((cid:11)).2. The proof is analogous to that used in Point 2 of Theorem 4.1. (cid:2)Proof of Theorem 4.4. Outlier(S) on propositional default theories is2-complete, for general theories, and1. DP2. DP-complete, for DF theories.Proof. 1. (Membership) See Section 4.2.(Hardness) Let (cid:3)1 = (D1, W 1) and (cid:3)2 = (D2, W 2) be two normal propositional default theories, let s1, s2 be two letters,and let q be the problem (((cid:3)1 |(cid:14) s1) ∧ ((cid:3)2 (cid:10)|(cid:14) s2)). W.l.o.g, it can be assumed that (cid:3)1 and (cid:3)2 contain different letters.1864F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872α:ββq is the conjunction of a (cid:10)PNotice that, given a normal default theory (D, W ) and a literal q, the problem of deciding if (cid:3) |(cid:14) q is (cid:10)Pin the case in which W is empty. Thus, in the following we assume that both W 1 and W 2 are empty sets.2-complete evenProblem q is associated with the default theory (cid:3)(q) = (D(q), W (q)) which is defined as follows. Let D(q) = { s2∧α:β|∈ D1} ∪ D2, and W (q) = {¬s1, s2}. We will show that q is true iff {¬s1} is a witness for some outlier in (cid:3)(q). Note thatβ2-hard and a (cid:9)P2 -hard problem, which proves DP2-hardness.(⇒) Suppose that q is true. We will show that {¬s1} is an outlier witness for {s2} in (cid:3)(q). Consider the theory (cid:3)(cid:12) =(D(q), W (q){¬s1}). First, we note that (cid:3)(cid:12) |(cid:14) s1. Indeed, from (cid:3)1 |(cid:14) s1 and s2 ∈ W (q){¬s1}, it can be concluded that (cid:3)(cid:12) |(cid:14) s1by means of defaults coming from the set D1.Consider now the theory (cid:3)(cid:12)(cid:12) = (D(q), W (q){¬s1},{s2}). As (cid:3)2 (cid:10)|(cid:14) s2, there exists an extension E of (cid:3)(cid:12)(cid:12)such that s2 does notbelong to E, and its associated set D E of generating defaults does not contain any rule from the set of defaults D(q) \ D2.We also note that (cid:3)(cid:12)(cid:12)is consistent, as both (cid:3)1 and (cid:3)2 are consistent. Thus it can be concluded that (cid:3)(cid:12)(cid:12) (cid:10)|(cid:14) s1. Hence, {¬s1}is an outlier witness for {s2} in (cid:3)(q).(⇐) Suppose that {¬s1} is a witness for some outlier set L in (cid:3)(q). Let (cid:3)(cid:12)and (cid:3)(cid:12)(cid:12)denote the theories (D(q), W (q){¬s1})and (D(q), W (q){¬s1},L) respectively.First, we note that (cid:3)(cid:12) |(cid:14) s1. As the literal s1 occurs only in the rules of D(q) coming from D1, and the rules in D2 haveno letters in common with these rules, except for letter s2, and s2 ∈ W (q){¬s1}, then it is the case that (cid:3)1 |(cid:14) s1.In order for (cid:3)(cid:12)(cid:12) (cid:10)|(cid:14) s1 to hold, L must include the letter s2. Since W (q) = {¬s1, s2}, L must be equal to {s2}. Clearly, itmust also be the case that (cid:3)(cid:12)(cid:12) (cid:10)|(cid:14) s2, i.e., that (cid:3)2 (cid:10)|(cid:14) s2. This proves that the problem q is indeed verified.2. Both membership and hardness are analogous to Point 1 of Theorem 4.4. (cid:2)Proof of Theorem 4.6. Outlier(S)(L) on propositional default theories is2-complete, for general theories, and1. DP2. DP-complete, for DF theories.Proof. The membership proof is identical to that of Theorem 4.4. The hardness proof is identical to that of Theorem 4.4,but with a minor addendum. Indeed, while in the problem considered in Theorem 4.4, the outlier set L is unknown and theoutlier witness set S is part of the input, in the problem considered here both the outlier set L and the witness set S arepart of the input. Note that the reduction employed in Theorem 4.4 outputs a default theory (cid:3)(q) = (D(q), W (q)) (we referto that theorem for the form of the formula q), with W (q) = {s1, ¬s2}, such that S = {¬s1} is a witness set in (cid:3)(q) if andonly if q is valid. It can be inferred also that S is a witness set if and only if L = {s2} is an outlier set. Thus, to conclude thehardness proof, it is sufficient to include the sets L = {s2} and S = {¬s1} together with the theory (cid:3)(q) as part of the inputfor the problem Outlier(S)(L). (cid:2)Proof of Theorem 4.7. Outlier-min(L) on general propositional default theories is1. DP2. DP3-complete, for general theories, and2-complete, for DF theories.(cid:12)Proof. 1. (Membership) Given a default theory (cid:3) = (D, W ) and a set of literals L ⊆ W , we must show (i) that L is anoutlier in (cid:3), i.e., that there exists a set S ⊆ W L such that (D, W S ) |(cid:14) ¬S and (D, W S,L) (cid:10)|(cid:14) ¬S (query q), and (ii) that L is a(cid:12)),minimal outlier, i.e., that for each nonempty subset L(cid:12)) ∨ ((D, W S(cid:12),L(cid:12) ) |(cid:14) ¬S(((D, W S(cid:12) ) (cid:10)|(cid:14) ¬SQuery qcan be solved by a polynomial time nondeterministic Turing machine with a (cid:9)Pand then calls the oracle twice to decide ((D, W S ) |(cid:14) ¬S) ∧ ((D, W S,L) (cid:10)|(cid:14) ¬S), and hence it is in (cid:9)Pnegation of query qthe two sets Lthe problem is the conjunction of two independent problems, one from (cid:9)Pproblem is in DP3.can be decided by a polynomial time nondeterministic Turing machine with a (cid:9)P(cid:12)and then calls the oracle two times to decide whether Q holds, and hence it is in (cid:10)P2 oracle that guesses the set S3 . Furthermore, the2 oracle, that guesses3. Summarizing,3, which implies that theis not an outlier in (cid:3), i.e., that for each subset S3 and the other from (cid:10)P(cid:12))) holds (query q(Hardness) Completeness of query Outlier-min(L) for general theories can be proved by reducing the problem of decid-(cid:12) ⊂ L, L(cid:12)(cid:12)).(cid:12) ⊂ (W \ Land S(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)ing the validity of the formula(cid:11)(cid:10)(∃ X)(∀Y )(∃Z ) f ( X, Y , Z )(cid:11)(cid:10)(∀W )(∃U )(∀V )g(W , U , V )∧F =to the problem Outlier-min(L), where f ( X, Y , Z ) is a Boolean formula in conjunctive normal form and g( X, Y , Z ) is aBoolean formula in disjunctive normal form. Formula F is the conjunction of a QBE3,∃ and a QBE3,∀ formula, a completeproblem for the class DP3. A similar reduction, but considering the conjunction of a QBE2,∃ formula and a QBE2,∀ formula,can be used to prove the result for DF default theories. In particular, the default theory (D(F ), W (F )) is associated to theformula F such that:F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721865(a) the outlier set L precisely consists of two literals, that is L = {l1, l2};(b) W (F )L is partitioned into two subsets S X and S W such that, for each subset S of W (F )L , there exists a bijectionbetween the sets S ∩ S X and S ∩ S W and each possible truth assignment for the variables X and W , respectively;(c) D(F ) is such that– (D(F ), W (F )S ) |(cid:14) ¬(S ∩ S X ), and– (D(F ), W (F )S,{l1}) |(cid:14) ¬(S ∩ S X ), and– (D(F ), W (F )S,{l2}) |(cid:14) ¬(S ∩ S X ), and– (D(F ), W (F )S,{l1,l2}) (cid:10)|(cid:14) ¬(S ∩ S X )iff (∀Y )(∃Z ) f ( X, Y , Z ) holds true subject to the truth assignment for the variables in the set X induced by S ∩ S X ;(d) D(F ) is such that– (D(F ), W (F )S ) |(cid:14) ¬(S ∩ S W ), and– (D(F ), W (F )S,{l1}) (cid:10)|(cid:14) ¬(S ∩ S W ), and– (D(F ), W (F )S,{l2}) (cid:10)|(cid:14) ¬(S ∩ S W )iff (∀U )(∃V )¬g( X, Y , Z ) holds true subject to the truth assignment for the variables in the set W induced by S ∩ S W .It follows from point (d) above that, in order for {l1, l2} to be a minimal outlier set, then it is the case that there doesnot exist a truth assignment to the variables of the set W such that (∀U )(∃V )¬g( X, Y , Z ) is true, that is, that the formula(∀W )(∃U )(∀V )g(W , U , V ) is true. As a consequence, a witness S for L must be such that S ⊆ S X and, from point 3 above,S encodes a truth assignment for the variables of the set X such that (∀Y )(∃Z ) f ( X, Y , Z ) is true. Note that by point (c)above, a subset S of S X represents a witness for neither {l1} nor {l2}, and this finally proves that L is a minimal outlier setin (D(F ), W (F )) iff the formula F is true.We now proceed to the detailed proof. Let (cid:11) = ∃ X∀Y ∃Z f ( X, Y , Z ) and (cid:12) = ∀W ∃U ∀V g(W , U , V ) be two quantifiedBoolean formulas, where X = x1, . . . , xn, Y = y1, . . . , ym, Z , W = w 1, . . . , w p , U = u1, . . . , uq, and V are disjoint set ofvariables. Let F be the formula (cid:11) ∧ (cid:12).The normal default theory (cid:3)(F ) = (D(F ), W (F )) is associated With F , where W (F ) is the set of letters {l1, l2, ¬φ, x1, . . . ,xn, ψ, w 1, . . . , w p} where l1, l2, φ, and ψ are new letters distinct from those occurring in F , and D(F ) is D1 ∪ · · · ∪ D8,where:∧ ¬ f ( X, Y , Z ) : ¬φ¬φ,(cid:12)l2 ∧ x1(cid:12)∧ · · · ∧ xn∧ ¬ f ( X, Y , Z ) : ¬φ¬φ(cid:4),(cid:3)D1 =D2 =D3 =D4 =D5 =D6 =D7 =D8 =(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:4)| i = 1, . . . , n,(cid:12)¬xi : xi(cid:12)xi,¬φ : xixi(cid:4)| j = 1, . . . , m,,,(cid:12)xi : xi(cid:12)xi: y jy j(cid:12)l1 ∧ x1: ¬xi¬xi: ¬ y j¬ y j(cid:12)∧ · · · ∧ xn,(cid:4),,,l2 : φφ: ¬wk¬wk(cid:12)kl1 : φφwk : w(cid:12)wk: uh: ¬uh¬uhuhl1 ∧ l2 ∧ w,(cid:12)1l1 ∧ l2 : ¬ψ¬ψ,¬wk : w(cid:12)wk(cid:12)k,(cid:4)(cid:4)| k = 1, . . . , p,ψ : wkwk| h = 1, . . . , q,∧ g(W , U , V ) : ψ(cid:4),(cid:12)p∧ · · · ∧ wψ(cid:4).Clearly W (F ) is consistent and (cid:3)(F ) can be built in polynomial time. Now it is shown that F is valid iff {l1, l2} is a minimaloutlier set in (cid:3)(F ).(⇒) Suppose that F is valid. We will show that {l1, l2} is a minimal outlier in (cid:3)(F ).Since F is valid, there exists a truth assignment T X to the variables in the set X such that T X satisfies ∀Y ∃Z f ( X, Y , Z ).Let S = {¬φ} ∪ {xi | T X (xi) = false}. We will show that S is a witness for the outlier set {l0, l1}. First note that, by rules inthe set D1, each extension E of (D(F ), W (F )S ) is such that xi ∈ E (¬xi ∈ E resp.) if xi is true (false resp.) according to T X .Furthermore, by rules in the set D2, each extension E of (D(F ), W (F )S ) can be associated with a truth assignment T Y tothe set Y of variables. In order for the literal ¬φ to belong to some extension of the theory (D(F ), W (F )S ), it must be thecase that, by the rules in the set D3, there exists a truth assignment T Y to the set Y of variables such that (∀Z )¬ f ( X, Y , Z )is true subject to the truth assignment T X ∪ T Y , or, equivalently, that the formula ¬(∀Y )(∃Z ) f ( X, Y , Z ) is true subject to thetruth assignment T X , and that contradicts the definition of T X . It follows then that ¬φ does not belong to every extensionof (D(F ), W (F )S ). By the rules in the sets D1 and D4, we can conclude that the negation of the variables in the set S isentailed by the default theory (D(F ), W (F )S ).1866F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872(cid:12)Finally, the default theory (D(F ), W (F )S,{l1,l2}) does not entail ¬S, since prerequisites of both the two rules in theset D4 are removed from W (F ) and do not appear in the conclusion of any default rule in (cid:3)(F ). Thus, {l1, l2} is an outlierset in (cid:3)(F ).Next, it is shown that {l1, l2} is a minimal outlier set in (cid:3)(F ), that is that neither {l1} nor {l2} are witness sets in (cid:3)(F ).First of all, note that neither l1 nor l2 can belong to a witness set (recall that both ¬l1 and ¬l2 do not appear in the(cid:12)(cid:12)denote the set S ∩ {¬φ, x1, . . . , xn} and Sconsequence of any rule in D(F )). Furthermore, for each subset S of W (F ), let S(cid:12) ⊆ {¬φ, x1, . . . , xn} cannot be a witness set for {l1} ({l2}denote the set S ∩ {ψ, w 1, . . . , w p}. Note that if S(cid:12)resp.). Indeed, as shown above, in order for (D(F ), W (F )S(cid:12) ) |(cid:14) ¬Sto hold, it is the case that Sencodes a truth assignmentto the variables in the set X and, consequently, that φ belongs to every extension of the default theory (D(F ), W (F )S(cid:12) ).Nevertheless, in this scenario, the default theory (D(F ), W (F )S(cid:12),{l1}) ((D(F ), W (F )S(cid:12),{l2}) resp.) will continue to entail φ dueto rules belonging to the set D4.(cid:12)(cid:12) = ∅ then S = S(cid:12)It can be concluded that if {l1} ({l2} resp.) is an outlier set in (cid:3)(F ), then its associated witness set S must be such that(cid:12)(cid:12) = S ∩ {ψ, w 1, . . . , w p} is not empty. Note that ψ must belong to S, for otherwise S does not encode a witness by rulesSψ:wk(1 (cid:2) k (cid:2) p) in the set D5. Now, for the sake of contradiction assume that {l1} ({l2} resp.) is an outlier set in (cid:3)(F ).wk(cid:12)(cid:12)∈ SNotice that by rules in the set D5, for each extension E of (D(F ), W (F )S ), wk ∈ E (¬wk ∈ E resp.) if sresp.). Hence, the set Sencodes a truth assignment to the variables in the set W . Furthermore, by the rules in the set D6,each extension E of (D(F ), W (F )S ) can be associated with a truth assignment T U to the variables in the set U . Since {l1}, and ¬ψ belongs to every extension E of({l2} resp.) is an outlier set, then the default theory (D(F ), W (F )S ) entails ¬S(D(F ), W (F )S ). By rules in the sets D7, it can be concluded that, for each truth assignment T U to the set of variables U ,there exists a truth variable assignment to the set of variables V which makes the formula g(W , U , V ) false, for otherwisethe literal ψ belongs to at least one extension of the default theory (D(F ), W (F )S ). It can be concluded that there existsa truth assignment T W to the set of variables W such that (∀U )(∃V )¬g(W , U , V ) is true, that is, that ¬(cid:12) is valid, whichcontradicts the fact that F = (cid:11) ∧ (cid:12) is valid. Hence, we can conclude that neither {l1} nor {l2} are outlier sets in (cid:3)(F ). Thus,{l1, l2} is a minimal outlier set in (cid:3)(F ).(⇐) Suppose that {l1, l2} is a minimal outlier in (cid:3)(F ). Since {l1, l2} is an outlier set, there exists a subset S of(cid:12) = S ∩ {¬φ, x1, . . . , xn}. Assume by contradiction thatis a witness set for {l1, l2}. The set Smust(cid:12)(cid:12){¬φ, x1, . . . , xn, ψ, w 1, . . . , w p} such that (D(F ), W (F )S ) |(cid:14) ¬S. Let S(cid:12)(cid:12)there exists a nonempty subset Scontain the literal ψ , by rules ψ:wkto hold, it must be thewkcase that ¬ψ is entailed by the default theory (D(F ), W (F )S ). Since ¬ψ is entailed only by the rule in the set D8, it canbe concluded that both {l1} and {l2} are outlier sets in (cid:3)(F ), having the associated witness set S, which contradicts thefact that {l1, l2} is a minimal outlier set. Hence, the set Sof {ψ, w 1, . . . , w p} such that S = S(1 (cid:2) k (cid:2) p) in the set D5. In order for (D(F ), W (F )S ) |(cid:14) ¬Smust be empty.(cid:12)k /∈ S(cid:12) ∪ S(cid:12)(sk(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)Since SAs already observed in the previous point, rules in the set D5 associate with each subset Sa truth assignment T Wto the set of variables W and rules in the set D6 associate with each extension of (D(F ), W (F )S ) a truth assignmentto the variables in the set U , while rules in the set D7 evaluate whether T W implies ∀U ∃V ¬g(W , U , V ) or not. Hence,from the fact that Smust be an empty set, it can also be concluded that there is no truth assignment T W such that∀U ∃V ¬g(W , U , V ), i.e. that (cid:12) = ∀W ∃U ∀V g(W , U , V ) is valid.is empty, it is the case that S = S(cid:12) ⊆ {s0, . . . , sn}. In order for S to be a witness set, it must be the case that(cid:12) ∈ E holds and, hence, that φ ∈ E. Now, note that by the rules in the set D1,for each extension E of (D(F ), W (F )S(cid:12) ), ¬Sresp.). Let T X be the truth assignment to the set of variables X such that T X (xi) = truexi ∈ E (¬xi ∈ E resp.) if si /∈ S(T X (xi) = false resp.) if si /∈ Sresp.). By the rules in the set D2, each E can be associated with a truth assignment T Eto the set of variables Y . In particular, T E is such that T E ( y j) = true (T E ( y j) = false resp.) if y j ∈ E ( y j /∈ E resp.). Since,for each extension E of (D(F ), W (F )S(cid:12) ), it holds that φ ∈ E, by the rules in the set D3 it follows that ¬ f ( X, Y , Z ) /∈ E, andhence it follows that for each truth assignment T E to the set of variables Y there exists a truth assignment T Z E to the setof variables Z such that T X ∪ T E ∪ T Z E satisfies the formula f ( X, Y , Z ). To conclude, it is the case that Sencodes a truthassignment T X for the variables in the set X such that T X implies ∀Y ∃Z f ( X, Y , Z ), and hence it follows that the formula (cid:11)is valid. It can be therefore eventually concluded that F = (cid:11) ∧ (cid:12) is a valid formula.(si ∈ S(si ∈ S(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)2. (Membership) This part is analogous to the membership part of Point 1 of this theorem.(Hardness) Let (cid:11) = ∃ X∀Y f ( X, Y ) and (cid:12) = ∀Z ∃W g(Z , W ) be two quantified Boolean formulas, where X = x1, . . . , xn, Y =y1, . . . , ym, Z = z1, . . . , zl, W = w 1, . . . , w p are disjoint sets of variables; f ( X, Y ) = d1 ∨ · · · ∨ dr is a formula in disjunctivenormal form, where each disjunct d j (1 (cid:2) j (cid:2) r) is the conjunction of three literals, that is, d j = t j,1 ∧ t j,2 ∧ t j,3; andg(Z , W ) = c1 ∧ · · · ∧ cs is a formula in conjunctive normal form, where each conjunct ch (1 (cid:2) h (cid:2) s) is the disjunction ofthree literals, that is, ch = uh,1 ∨ uh,2 ∨ uh,3.Let F be the formula (cid:11) ∧ (cid:12). We associate with F the default theory (cid:3)(F ) = (D(F ), W (F )), which is identical to thetheory described in Point 1 of this theorem, except for the sets of rules D3 and D7 that are as follows:(cid:4)(cid:3)(cid:4)(cid:3)∧ ¬t j,k : ¬dk(cid:12)li ∧ x1(cid:12)∧ · · · ∧ xn¬dk∧ · · · ∧ w(cid:12)1l1 ∧ l2 ∧ wD3 =D7 =(cid:3)| i = 1, 2; j = 1, . . . , r; k = 1, 2, 3(cid:12)p∧ ¬uh,1 ∧ ¬uh,2 ∧ ¬uh,3 : ψψ| h = 1, . . . , s.¬d1 ∧ · · · ∧ ¬dp : ¬φ¬φ,∪(cid:4)The rest of the proof is analogous to that of Point 1 of this theorem. (cid:2)F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721867Proof of Theorem 4.8. Outlier-min(S)(L) on general propositional default theories is1. (cid:10)P2. (cid:10)P3-complete, for general theories, and2-complete, for DF theories.and LProblem q(cid:12)Proof. 1. (Membership) In order to answer query Outlier-min(S)(L), it must be verified that (problem qDefinition 3.2, i.e., (D, W S ) |(cid:14) ¬S and (D, W S,L) (cid:10)|(cid:14) ¬S, and that (problem q(cid:12)Sdo not satisfy Definition 3.2, i.e., (D, W S(cid:12) ) (cid:10)|(cid:14) ¬Sor (D, W S(cid:12),L(cid:12) ) |(cid:14) ¬S) for each proper subset L(cid:12)(cid:12).(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)) S and L satisfy(cid:12)of W L(cid:12) ,of L, and S(cid:12)(cid:12)3 ((cid:10)Pis in (cid:10)Pcoincides with Outlier(S)(L), and hence it is in DP2 (DP resp.) for general (DF resp.) theories. Furthermore,2 resp.) for general (DF resp.) theories, since its negation can be answered by a nondeterministic(cid:12) ⊆ W L(cid:12) and then checks that they formproblem qpolynomial time Turing machine that guesses a pair of disjoint subsets Lan outlier and witness pair by using an oracle in (cid:9)P2 . Thus, the overall problem is in (cid:10)P(Hardness) Let (cid:12) = ∀W ∃U ∀V g(W , U , V ) be a quantified Boolean formula, where W = w 1, . . . , w p , U = u1, . . . , u p , andV are disjoint set of variables. With (cid:12), the default theory (cid:3)((cid:12)) = (D((cid:12)), W ((cid:12))) is associated, where W ((cid:12)) is the setof literals {l1, l2, s, ψ, w 1, . . . , w p} where l1, l2, s and ψ are new letters distinct from those occurring in (cid:12), and D((cid:12)) iscomposed of the default rules in the sets D5, D6, D7, and D8 reported in the reduction shown in Point 1 of Theorem 4.7,plus the set of rules D0 = { l1:¬s(cid:12) ⊆ L and S2 resp.).3 ((cid:10)PNext, it is shown that (cid:12) is valid iff L = {l1, l2} is a minimal outlier set with outlier witness set S = {s} in (cid:3)((cid:12)).It follows from Point 1 of Theorem 4.7, that {l1} and {l2} are outlier sets in (D((cid:12)) − D0, W ((cid:12))), with associated witnessset S W ⊆ {ψ, w 1, . . . , w p}, if and only if (cid:12) is not valid. Thus, in order for L to be a minimal outlier set, it must be the casethat (cid:12) is valid. Finally, by rules in the set D0, it holds that¬s , l1∧l2:¬s¬s , l2:¬s¬s}.– (D((cid:12)), W ((cid:12)){s}) |(cid:14) ¬s,– (D((cid:12)), W ((cid:12)){l1},{s}) |(cid:14) ¬s,– (D((cid:12)), W ((cid:12)){l2},{s}) |(cid:14) ¬s, and– (D((cid:12)), W ((cid:12)){l1,l2},{s}) (cid:10)|(cid:14) ¬s.Hence, the result follows.2. Both membership and hardness are analogous to Point 1 of this theorem. (cid:2)Appendix B. Proofs for Section 4.3Proof of Theorem 4.11. For general EDPLs,3 -complete,3 -complete,3 -complete,2-complete,1. Outlier is (cid:9)P2. Outlier[k] is (cid:9)P3. Outlier(L) is (cid:9)P4. Outlier(S) is DP5. Outlier[k](S) is DP6. Outlier(S)(L) is DP7. Outlier-min(L) is DP8. Outlier-min(S)(L) is (cid:10)P2-complete,2-complete,3-complete, and3-complete.Proof. 1. (Membership) Given a rule-observations program P = (D, W ), we must show that there exist two disjoint sets S ⊆(cid:12)(cid:12)W and L ⊆ W such that P S |(cid:14) ¬S (problem q) and P S,L (cid:10)|(cid:14) ¬S (problem q2-complete, while problem qis (cid:9)P2 -complete [21]. Thus, we can build a polynomial-time nondeterministic Turing machine equipped with a (cid:9)P2 oracle(cid:12)(cid:12)that solves query Outlier as follows: the machine will first guess the sets S and L and then solve queries qbycalling the oracle twice.). Problem qis (cid:10)Pand q(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(Hardness) Let (cid:11) = ∃ X∀Y ∃Z f ( X, Y , Z ) be a quantified Boolean formula, where X = x1, . . . , xn, Y = y1, . . . , ym and Z =f ( X, Y , Z ) =z1, . . . , zl are disjoint set of variables, and f ( X, Y , Z ) is a Boolean formula in conjunctive normal form, i.e.,C1 ∧ · · · ∧ C N , with Ch = th,1 ∨ th,2 ∨ th,3, and each th,1, th,2, th,3 is a literal in the set X ∪ Y ∪ Z , for h = 1, . . . , N. Weassociate with (cid:11) the rule-observations program P ((cid:11)) = (cid:21)D((cid:11)), W ((cid:11))(cid:22), where W ((cid:11)) = {o, x0, x1, . . . , xn} consists of theletters in the set X plus the new letters x0 and o which are distinct from those occurring in (cid:11), and D((cid:11)) is1868F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872r0 : ¬φ ← not or1,i : ¬xi | xi ← ¬φr2,i : ¬xi ← not xi, not ¬φ(cid:12)← not xir3,i : xi(cid:12)r4, j : y j | y←j(cid:12)←r5,k : zk | zkr6,k : zk ← ¬φ(cid:12)r7,k : z← ¬φkr8,h : ¬φ ← σ (¬th,1), σ (¬th,2), σ (¬th,3)(0 (cid:2) i (cid:2) n)(0 (cid:2) i (cid:2) n)(1 (cid:2) i (cid:2) n)(1 (cid:2) j (cid:2) m)(1 (cid:2) k (cid:2) l)(1 (cid:2) k (cid:2) l)(1 (cid:2) k (cid:2) l)(1 (cid:2) h (cid:2) N)(cid:12)(cid:12)(cid:12) = x1, . . . , xwhere also Xn, Yσ : X ∪ ¬ X ∪ Y ∪ ¬Y ∪ Z ∪ ¬Z (cid:28)→ X ∪ X(cid:12) = y(cid:12)1, . . . , y(cid:12)m, and Z(cid:12) ∪ Y ∪ Y(cid:12)(cid:12) = z1, . . . , z(cid:12)(cid:12) ∪ Z ∪ Zis the following mapping:(cid:12)l are new letters distinct from those occurring in (cid:11), andσ (t) =⎧⎪⎨⎪⎩(cid:12)xi(cid:12)yj(cid:12)zktif t = ¬xi (1 (cid:2) i (cid:2) n),if t = ¬ y j (1 (cid:2) j (cid:2) m),if t = ¬zk (1 (cid:2) k (cid:2) l),otherwise.Clearly, P ((cid:11)) can be built in polynomial time. Now we show that (cid:11) is valid iff there exists an outlier in P ((cid:11)).By contradiction, suppose that there exists an answer set MGiven a truth assignment T on a subset of X ∪ Y ∪ Z , let I(T ) denote the context σ (Lit(T )).(⇒) Suppose that (cid:11) is valid. We shall show that L = {o} is an outlier in P ((cid:11)). Then there exists a truth assignment T X tothe variables in the set X such that T X satisfies ∀Y ∃Z f ( X, Y , Z ). Let S = {x0} ∪ ¬(Lit(T X )−), We will show that P ((cid:11))S |(cid:14) ¬S.. By rules r2,i , it is the case(cid:12), where T Y denotes a truth(cid:12) (cid:10)= ¬S. As ais a set of the form {s | x ∈ S ∧ (s = x ∨ s = ¬x)} such that S(cid:12) ∪ {¬φ, o} ∪ ¬S, where T Y denotes a truth assignment to the set of variablesthat ¬φ ∈ M(cid:12)assignment to the set of variables in Y and Sconsequence, the set M = I(T X ) ∪ I(T Y ) ∪ Z ∪ Zin Y , is an answer set of P ((cid:11))S .(cid:12)of P ((cid:11))S such that ¬S (cid:10)⊂ M(cid:12) ∪ {¬φ, o} ∪ Sis of the form I(T X ) ∪ I(T Y ) ∪ Z ∪ Z. Furthermore, by rules r1,i , M(cid:12)(cid:12)(cid:12)As M is an answer set of P ((cid:11))S , and hence a minimal context closed under Red(P ((cid:11))S , M), it follows that for each truth(cid:12)(cid:12) = I(T X ) ∪ I(T Y ) ∪ I(T Z ) ∪ {o} ∪ ¬S of M is not a context closed. We canassignment T Z to the variables in the set Z , the subset Munder Red(P ((cid:11))S , M). Thus, for each T Z there exists an h ∈ {1, . . . , N} such that σ (¬th,1), σ (¬th,2), σ (¬th,3) ∈ Mconclude that there exists an answer set Mof P ((cid:11))S such that ¬S (cid:10)⊂ Mif and only if T X satisfies(cid:12)(cid:12)(cid:12)(cid:12)∃Y ∀ZN(cid:20)r=1(¬tr,1 ∧ ¬tr,2 ∧ ¬tr,3) ≡ ¬∀Y ∃Z f ( X, Y , Z )which contradicts the fact that T X satisfies ∀Y ∃Z f ( X, Y , Z ). Hence, P ((cid:11))S |(cid:14) ¬S. Let L = {o}; then, by rules r9 and r1,i ,P ((cid:11))S,L (cid:10)|(cid:14) ¬S. Thus, L = {o} is an outlier set with outlier witness set S.(⇐) Suppose that there exists an outlier L ⊆ W ((cid:11)) with witness S ⊆ W ((cid:11)) in P . As ¬o cannot be entailed by P ((cid:11))S ,it must be the case that S ⊆ X ∪ {x0}. From what is stated above, P ((cid:11))S |(cid:14) ¬S implies that the truth value assignment T Xon the set of variables X such that T X (xi) = false if and only if xi ∈ S, satisfies ∀Y ∃Z f ( X, Y , Z ), i.e., that (cid:11) is valid. Toconclude, the literal L = {o} is always an outlier having such a witness.2. The proof is analogous to that of Point 1.3. The proof is analogous to that of Point 1.4. (Membership) Given the rule-observations program P = (D, W ), and a subset S ⊆ W , we should verify that there) and P S,L (cid:10)|(cid:14) ¬S (problem qexists L ⊆ W S such that P S |(cid:14) ¬S (problem qis(cid:10)P2 -complete as it can be answered by a polynomial-time nondeterministic Turingmachine with an NP oracle as follows: the machine guesses both an outlier L ⊆ W S and a consistent context M of P S,Lsuch that ¬S (cid:10)⊆ M, verifies that M is closed under Red(P S,L, M), and decides whether Mis closedunder Red(P S,L, M) with a call to the NP oracle. Hence, we have to decide the conjunction q). We have already noted that problem q2-complete. As for problem q(cid:12) ⊂ M exists such that M, i.e., a DP, it is (cid:9)P(cid:12) ∧ q(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(Hardness) Let r be an EDLP rule, and let h(r) and b(r) denote respectively the head and the body of r. Let P(cid:12)(cid:12)be two EDLPs. W.l.o.g. assume that Pand l. Consider the rule-observations program P = (D, W ) where D = {h(r) ← b(r), l : r ∈ Pand W = {s, l}. By noting that ANSW(P(a (cid:10)Poutlier with witness {s} in P .contain no common letters and also that they do not contain the letters s(cid:12)(cid:12)}(cid:12)(cid:12)) = ANSW(P {s},{l}), it follows that Pis inconsistent2 -complete check, see [21], Theorem 40) iff {l} is an(cid:12)} ∪ {h(r) ← b(r), not l : r ∈ P(cid:12)2-complete check, see [21], Theorem 39) and P(cid:12)) = ANSW(P {s}) and ANSW(Pis consistent (a (cid:9)Pand Pand P(cid:12)(cid:12)(cid:12)2 problem.(cid:12)(cid:12)(cid:12)5. The proof is analogous to that of Point 4.6. The proof is analogous to that of Point 4.7. (Membership) Analogous to the membership part of Theorem 4.7.F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721869(Hardness) Let (cid:11) = ∃ X∀Y ∃Z f ( X, Y , Z ) be a quantified Boolean formula, where X = x1, . . . , xn, Y = y1, . . . , ym, and Z =f ( X, Y , Z ) is the Boolean formula in conjunctive normal form C1 ∧ · · · ∧ C N , with Ch =z1, are disjoint sets of variables,th,1 ∨ th,2 ∨ th,3, and each th,1, th,2, th,3 is a literal in the set X ∪ Y ∪ Z , for h = 1, . . . , N.Let (cid:12) = ∀W ∃U ∀V g(W , U , V ) be another quantified Boolean formula, where W = w 1, . . . , w p , U = u1, . . . , uq, and V =v 1, . . . , vr are disjoint sets of variables, and g(W , U , V ) is the Boolean formula in disjunctive normal form D1 ∨ · · · ∨ D M ,with Dh = sh,1 ∧ sh,2 ∧ sh,3, and each sh,1, sh,2, sh,3 is a literal in the set W ∪ U ∪ V , for h = 1, . . . , M.Let F be the formula (cid:11) ∧ (cid:12). We associate with F the rule-observations program P (F ) = (cid:21)D(F ), W (F )(cid:22), whereW (F ) = {o1, o2, x0, x1, . . . , xn, w 0, w 1, . . . , w p}consists of the letters in the set X ∪ W plus the new letters x0, w 0, o1 and o2 that are distinct from those occurring in F ,and D(F ) isrrrrrrrrr(cid:12)0(cid:12)1,i(cid:12)2,i(cid:12)3,i(cid:12)4, j(cid:12)5,k(cid:12)6,k(cid:12)7,k(cid:12)8,h: ¬φ ← not o1, not o2: ¬xi | xi ← ¬φ: ¬xi ← not xi, not ¬φ(cid:12): xi: y j | y(cid:12): zk | zk: zk ← ¬φ(cid:12): z← ¬φk: ¬φ ← σ (¬th,1), σ (¬th,2), σ (¬th,3)← not xi(cid:12)←j←(0 (cid:2) i (cid:2) n)(0 (cid:2) i (cid:2) n)(1 (cid:2) i (cid:2) n)(1 (cid:2) j (cid:2) m)(1 (cid:2) k (cid:2) l)(1 (cid:2) k (cid:2) l)(1 (cid:2) k (cid:2) l)(1 (cid:2) h (cid:2) N)rrrrrrr←(cid:12)j(cid:12)k← not w i←(cid:12)(cid:12)0,1(cid:12)(cid:12)0,2(cid:12)(cid:12)1,i(cid:12)(cid:12)2,i(cid:12)(cid:12)3,i(cid:12)(cid:12)4, j(cid:12)(cid:12)5,k(cid:12)(cid:12)6,k(cid:12)(cid:12)7,k(cid:12)8,0(cid:12)(cid:12)8,1,h(cid:12)(cid:12)8,2,h(cid:12)(cid:12)r8,3,h(cid:12)(cid:12) = w1, . . . , w: ¬ψ ← not o1: ¬ψ ← not o2: ¬w i | w i ← ¬ψ(0 (cid:2) i (cid:2) p): ¬w i ← not w i, not ¬ψ (0 (cid:2) i (cid:2) p)(cid:12)(1 (cid:2) i (cid:2) p): wi(1 (cid:2) j (cid:2) q): u j | u(1 (cid:2) k (cid:2) r): vk | v(1 (cid:2) k (cid:2) r): vk ← ¬ψ: v(1 (cid:2) k (cid:2) r)← ¬ψ: ¬ψ ← ¬d1, . . . , ¬dM: ¬dh ← σ (¬sh,1): ¬dh ← σ (¬sh,2): ¬dh ← σ (¬sh,3)(cid:12)1, . . . , u(1 (cid:2) h (cid:2) M)(1 (cid:2) h (cid:2) M)(1 (cid:2) h (cid:2) M)(cid:12) = v(cid:12)q, and V(cid:12) = u(cid:12)krrrrr(cid:12)(cid:12)(cid:12) = x1, . . . , xn, Y(cid:12)where also Xl , Wletters distinct from those occurring in F , and σ : X ∪ ¬ X ∪ Y ∪ ¬Y ∪ Z ∪ ¬Z ∪ W ∪ ¬W ∪ U ∪ ¬U ∪ V ∪ ¬V (cid:28)→ X ∪ XY ∪ Yis the following mapping:(cid:12)r are new(cid:12) ∪(cid:12)1, . . . , y(cid:12)1, . . . , v(cid:12)1, . . . , z(cid:12)m, Z(cid:12) = y(cid:12)p , U(cid:12) = z(cid:12)(cid:12) ∪ U ∪ U(cid:12) ∪ Z ∪ Z(cid:12) ∪ W ∪ W⎧(cid:12)i,x(cid:12)j,y(cid:12)k,z(cid:12)i,w(cid:12)j,u(cid:12)k,vt,(cid:12) ∪ V ∪ Vif t = ¬xi (1 (cid:2) i (cid:2) n),if t = ¬ y j (1 (cid:2) j (cid:2) m),if t = ¬zk (1 (cid:2) k (cid:2) l),if t = ¬w i (1 (cid:2) i (cid:2) n),if t = ¬u j (1 (cid:2) j (cid:2) m),if t = ¬vk (1 (cid:2) k (cid:2) l),otherwise.⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎩σ (t) =Clearly, P (F ) can be built in polynomial time. Now we show that F is valid iff {o1, o2} is a minimal outlier set in P (F ).The line of reasoning employed to prove the result is analogous to that of the hardness part of Theorem 4.7, Point 1.The reader is referred to the discussion preceding the reduction therein for the explanation of that line of reasoning. Next,technicalities concerning the reduction presented here are pointed out.First of all, in order to understand the role of rules r(rhave the same structure as the rules used in the reduction given in Point 1 of this proof, where a (cid:9)Pconsidered., resp.) in the reduction depicted above, we note that these rules3 -complete problem is(cid:12)In particular, rules rserve the purpose of guaranteeing that (D(F ), W (F )S ) |(cid:14) ¬(S ∩ S X ) if and only if the formula(cid:11) = ∃ X∀Y ∃Z f ( X, Y , Z ) is satisfiable (see Point (c) of the discussion recalled above), while rules rserve the purpose ofguaranteeing that (D(F ), W (F )S ) |(cid:14) ¬(S ∩ S W ) if and only if the formula (cid:12) = ∃W ∀U ∃V ¬g(W , U , V ) is satisfiable (seePoint (d) of the same discussion).(cid:12)(cid:12)As for the relationship between the minimality of the outlier set {o1, o2} and the satisfiability of the formula (cid:11) ∧ (cid:12), this(cid:12)(cid:12)0,2 (once again, refer to the discussion of Theorem 4.7, Point 1, and to Point 1 of this(cid:12)(cid:12)0,1 and r(cid:12)0, r(cid:12)(cid:12)(cid:12)is taken care of by rules rproof for details).8. Both membership and hardness are analogous to that of Theorem 4.8. For the hardness part, we can make use of rulesdefined in Point 7 of this proof, plus rules equivalent to the defaults in the set D0 defined in Point 1 of Theorem 4.8. (cid:2)(cid:12)(cid:12)rAppendix C. Proofs for Section 5Proof of Theorem 5.3. The data complexity of Outlier is (cid:9)P3 -complete.1870F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872Proof. (Membership) See Section 5.(Hardness) To prove the completeness of the query Outlier, the (cid:9)P3 -complete problem of deciding the validity of aQBE3,∃ formula is reduced to it. A QBE3,∃ formula (cid:11) has the form ∃ X∀Y ∃Z f ( X, Y , Z ), where X = x1, . . . , xn, Y = y1, . . . , ym,and Z are disjoint sets of variables, and f ( X, Y , Z ) is a propositional formula on X, Y , Z . Without loss of generality, it canbe assumed that the Boolean formula f ( X, Y , Z ) is in conjunctive normal form with exactly three literals per clause, thatis, that f ( X, Y , Z ) = c1 ∧ c2 ∧ · · · ∧ cr , with ck = tk,1 ∨ tk,2 ∨ tk,3, for k = 1, . . . , r.We now describe a fixed default theory (cid:3)FO = (DFO, W FO), where W FO does not contain atomic formulas, and amapping W ((cid:11)) from any QBE3,∃ formula (cid:11) to a set of ground literals, such that there exists an outlier in (cid:3)FO((cid:11)) =(DFO, W FO ∪ W ((cid:11))) if and only if the formula (cid:11) is satisfiable. We encode the formula (cid:11) in the extensional componentW ((cid:11)) of (cid:3)FO((cid:11)) by means of the following sets of atoms:W X =W Y =W f =(cid:5)(cid:5)(cid:6)e(xi, xi+1) | i = 1, . . . , n − 1∪(cid:6)u( y j, y j+1) | j = 1, . . . , m − 1(cid:11)(cid:10)ck, ck+1, sgn(tk,1), let(tk,1), sgn(tk,2), let(tk,2), sgn(tk,3), let(tk,3)(cid:5)c(cid:10)cr, c0, sgn(tr,1), let(tr,1), sgn(tr,2), let(tr,2), sgn(tr,3), let(tr,3)(cid:6)(cid:5)e(xn, x0)∪(cid:6)u( ym, y0)and(cid:5)c∪(cid:5),,(cid:11)(cid:6),(cid:6)| k = 1, . . . , r − 1where sgn((cid:2)) is the constant p if (cid:2) is a positive literal, and the constant n if (cid:2) is a negative literal, while let((cid:2)) is thepropositional letter occurring in the literal (cid:2). Intuitively, atoms with functor e list existential variables in the set X , atomswith functor u list universal variables in the set Y , and atoms with functor c list clauses of the formula f ( X, Y , Z ). Variablesin the set Z are not explicitly listed, since this is not needed for the sake of the reduction. In the following the set W X ∪W Y ∪ W fis denoted by W (cid:11).It must be avoided that atoms in the set W (cid:11) become part of an outlier or a witness, for otherwise the above encodingof the formula (cid:11) is invalidated. With this aim, the following rules, forming the set W FO, are employed:r0 : f ∨ ¬ f → t,r1 : t → t(x0),r2 : t → e(x0, x1),r3 : t → u( y0, y1),r4 : t → c(c0, c1, p, x0, p, x0, p, x0),(cid:11)(cid:10)r5 : (∀ A)(∀B)(∃C)e( A, B) → e(B, C),(cid:11)(cid:10)r6 : (∀ A)(∀B)(∃C)u( A, B) → u(B, C)(cid:11)(cid:10)c( A, B, V 1, V 2, V 3, V 4, V 5, V 6) → c(B, C, V 7, V 8, V 9, V 10, V 12, V 12)r7 : (∀ A)(∀B)(∃C)(∃V 1) . . . (∃V 12).,Rules r2, r3, and r4 introduce one additional existential variable, a universal variable, and a clause, respectively, whose rolesare clarified below. Rules r5, r6, and r7 serve the purpose of making the overall theory inconsistent whenever at least oneatom in the set W (cid:11) is removed from W ((cid:11)). Indeed, assume that an atom of the form e(xi, xi+1) is removed from W ((cid:11)).Then the formula e(xi−1, xi) → e(xi, xi+1), and consequently also the formula r5, evaluates to false. In particular, formula r5is true if and only if the atomic formulas of the form e(xi, x(i+1)mod(n+1)) are either all true or all false. Hence, it followsfrom formula r2 that if at least one of the atoms in the set W X is removed, then the theory is inconsistent. The samereasoning can be applied for all the other atoms in the set W (cid:11). Assume that L is an outlier with witness S in (cid:3)FO((cid:11)) suchthat (L ∪ S) ∩ W (cid:11) (cid:10)= ∅. Then, the default theory (DFO, W FO ∪ W ((cid:11))S,L) is inconsistent and (DFO, W FO ∪ W ((cid:11))S,L) |(cid:14) ¬S, acontradiction. Thus, outliers and witnesses cannot contain atoms belonging to the set W (cid:11).Given a propositional variable v, we use the literals t(v) and ¬t(v) to represent the information that v is true and thatv is false, respectively, in a certain truth value assignment. The truth value of a 3CNF formula whose clauses are encodedby means of the atoms above can be thus evaluated by using the following first-order formula:F = (∀ A)(∀B)(∀T 1)(∀T 2)(∀T 3)(cid:21)(cid:10)(cid:11)c( A, B, p, T 1, p, T 2, p, T 3) → t(T 1) ∨ t(T 2) ∨ t(T 3)(cid:10)(cid:11)c( A, B, n, T 1, p, T 2, p, T 3) → ¬t(T 1) ∨ t(T 2) ∨ t(T 3)(cid:10)(cid:11)c( A, B, p, T 1, n, T 2, p, T 3) → t(T 1) ∨ ¬t(T 2) ∨ t(T 3)(cid:11)(cid:10)c( A, B, n, T 1, n, T 2, p, T 3) → ¬t(T 1) ∨ ¬t(T 2) ∨ t(T 3)(cid:10)(cid:11)c( A, B, p, T 1, p, T 2, n, T 3) → t(T 1) ∨ t(T 2) ∨ ¬t(T 3)(cid:10)(cid:11)c( A, B, n, T 1, p, T 2, n, T 3) → ¬t(T 1) ∨ t(T 2) ∨ ¬t(T 3)(cid:10)(cid:11)c( A, B, p, T 1, n, T 2, n, T 3) → t(T 1) ∨ ¬t(T 2) ∨ ¬t(T 3)(cid:10)c( A, B, n, T 1, n, T 2, n, T 3) → ¬t(T 1) ∨ ¬t(T 2) ∨ ¬t(T 3)∧∧∧∧∧∧∧(cid:11)(cid:22).F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–18721871Indeed, according to formula F , for each clause ck at least one literal among tk,1, tk,2, tk,3 must be true in the consideredtruth value assignment.Now, we are in a position to complete the reduction (cid:3)FO((cid:11)). The set W ((cid:11)) is given byW (cid:11) ∪(cid:6)(cid:5)l, ¬φ, t(x1), . . . , t(xn),while DFO is the fixed set of defaults D1 ∪ D2 ∪ D3 ∪ D4, where:(cid:3)D1 =D2 =D3 =D4 =(cid:3)(cid:3)(cid:3)e( A, C) ∧ t( A) : ok( A)ok( A)e( A, C) : ¬t( A)¬t( A),e( A, C) ∧ ¬φ : t( A)t( A),e( A, C) ∧ ¬t( A) : ok( A)ok( A),(cid:4),¬l : ¬φ¬φ,,: ¬l: φ¬lφu(B, C) : t(B)t(B),u(B, C) : ¬t(B)¬t(B)(cid:4),((∀ A)(e( A, C) → ok( A))) ∧ ¬F : ¬φ¬φ(cid:4).(cid:4),The reader can verify that the grounded version PROP((cid:3)FO((cid:11))), which is a finite propositional general default theory, isequivalent to the default theory (cid:3)((cid:11)) described in the hardness part of Theorem 4.1, Point 1. Hence, from what is statedabove, and from Theorem 4.1, the result follows. (cid:2)References[1] C.C. Aggarwal, P.S. Yu, Outlier detection for high dimensional data, in: Proceedings of the ACM Int. Conf. on Management of Data, Santa Barbara,California, USA, 2001, pp. 37–46.[2] F. Angiulli, S. Basta, C. Pizzuti, Distance-based detection and prediction of outliers, IEEE Transactions Knowledge and Data Engineering 18 (2) (2006)145–160.[3] F. Angiulli, R. Ben-Eliyahu-Zohary, G. Ianni, L. Palopoli, Computational properties of metaquerying problems, ACM Transactions on ComputationalLogic 4 (3) (2003) 149–180.[4] F. Angiulli, R. Ben-Eliyahu-Zohary, L. Palopoli, Outlier detection using default logic, in: Proceedings of the Eighteenth International Joint Conference onArtificial Intelligence (IJCAI), 2003, pp. 833–838.[5] F. Angiulli, G. Greco, L. Palopoli, Outlier detection by logic programming, ACM Transactions on Computational Logic 9 (1) (2007).[6] F. Angiulli, C. Pizzuti, Fast outlier detection in high dimensional spaces, in: European Conference on Principles of Data Mining and Knowledge Discovery,Helsinki, 2002, pp. 15–26.[7] F. Angiulli, C. Pizzuti, Outlier mining in large high dimensional data sets, IEEE Transactions on Knowledge and Data Engineering 17 (2) (2005) 203–215.[8] A. Arning, C. Aggarwal, P. Raghavan, A linear method for deviation detection in large databases, in: Proc. Int. Conf. on Knowledge Discovery and DataMining, Portland, Oregon, USA, 1996, pp. 164–169.[9] V. Barnett, T. Lewis, Outliers in Statistical Data, John Wiley & Sons, 1994.[10] S.D. Bay, M. Schwabacher, Mining distance-based outliers in near linear time with randomization and a simple pruning rule, in: Proc. Int. Conf. onKnowledge Discovery in Databases, 2003, pp. 29–38.[11] R. Ben-Eliyahu, R. Dechter, Propositional semantics for disjunctive logic programs, Annals of Mathematics and Artificial Intelligence 12 (1994) 53–87.[12] R. Ben-Eliyahu-Zohary, R. Dechter, Propositional semantics for disjunctive logic programs, in: Proceedings of the Eighteenth Joint International Confer-ence (JICSLP-92), 1992, pp. 813–827.[13] R. Ben-Eliyahu-Zohary, E. Gudes, G. Ianni, Metaqueries: Semantics, complexity, and efficient algorithms, Artificial Intelligence 149 (1) (2003) 61–87.[14] M.M. Breunig, H. Kriegel, R.T. Ng, J. Sander, Lof: Identifying density-based local outliers, in: Proc. ACM Int. Conf. on Management of Data, Dallas, Texas,USA, 2000, pp. 93–104.[15] M. Cadoli, T. Eiter, G. Gottlob, Default logic as a query language, IEEE Transactions on Knowledge and Data Engineering 9 (3) (1997) 448–463.[16] L. Console, D.T. Dupré, P. Torasso, On the relationship between abduction and deduction, Journal of Logic and Computation 1 (5) (1991) 661–690.[17] D. Yu, S. Sheikholeslami, A. Zhang, Findout: Finding outliers in very large datasets, in: Tech. Report, 99-03, Univ. of New York, Buffalo, 1999, pp. 1–19.[18] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Computing Surveys 33 (3) (2001) 374–425.[19] M. Denecker, C. Kakas, Abductive logic programming, Journal of Logic Programming 44 (1–3) (2000) 1–4.[20] B. Duval, P. Nicolas, Learning default theories, in: ESCQARU, 1999, pp. 148–159.[21] T. Eiter, G. Gottlob, On the computational cost of disjunctive logic programming: Propositional case, Annals of Mathematics and Artificial Intelligence 15(1995) 289–323.[22] T. Eiter, G. Gottlob, N. Leone, Abduction from logic programs: semantics and complexity, Theoretical Computer Science 189 (1–2) (1997) 129–177.[23] T. Eiter, G. Gottlob, The complexity of logic-based abduction, Journal of the ACM 42 (1) (1995) 3–42.[24] T. Eiter, G. Gottlob, N. Leone, Semantics and complexity of abduction from default theories, Artificial Intelligence 90 (1–2) (1997) 177–223.[25] D.W. Etherington, Formalizing nonmonotonic reasoning systems, Artificial Intelligence 31 (1) (1987) 41–85.[26] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (1991) 365–385.[27] G. Gottlob, Complexity results for nonmonotonic logics, Journal of Logic and Computation 2 (3) (1992) 397–425.[28] V. Hodge, J. Austin, A survey of outlier detection methodologies, Artificial Intelligence Review 22 (2) (2004) 85–126.[29] K. Inoue, Y. Kudoh, Learning extended logic programs, in: IJCAI, 1997, pp. 176–181.[30] W. Jin, A.K.H. Tung, J. Han, Mining top-n local outliers in large databases, in: Proceedings of the ACM Int. Conf. on Knowledge Discovery and DataMining, San Francisco, California, USA, 2001, pp. 293–298.[31] D.S. Johnson, A catalog of complexity classes, in: J. van Leeuwen (Ed.), Handbook of Theoretical Computer Science, vol. A: Algorithms and Complexity,Elsevier/The MIT Press, 1990, pp. 67–161, Chapter 9.[32] A. Kakas, R. Kowalski, F. Toni, The role of abduction in logic programming, in: A.C. Kakas, R.A. Kowalski, F. Toni (Eds.), The Role of Abduction in LogicProgramming, in: Handbook of Logic in Artificial Intelligence and Logic Programming, vol. 5, Oxford University Press, 1998, pp. 235–324.[33] H.A. Kautz, B. Selman, Hard problems for simple default logics, Artificial Intelligence 49 (1–3) (1991) 243–279.1872F. Angiulli et al. / Artificial Intelligence 172 (2008) 1837–1872[34] E. Knorr, R. Ng, Algorithms for mining distance-based outliers in large datasets, in: Proc. Int. Conf. on Very Large Databases, New York, USA, 1998,pp. 392–403.[35] E. Knorr, R. Ng, V. Tucakov, Distance-based outlier: algorithms and applications, VLDB Journal 8 (3–4) (2000) 237–253.[36] N. Lavrac, S. Dzeroski, Inductive Logic Programming: Techniques and Applications, Ellis Horwood, New York, 1994.[37] W. Lee, S.J. Stolfo, K.W. Mok, Mining audit data to build intrusion detection models, in: Proc. ACM Int. Conf on Knowledge Discovery and Data Mining,New York, USA, 1998, pp. 66–72.[38] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The dlv system for knowledge representation and reasoning, ACM Transactionson Computational Logic 7 (3) (2006) 499–562.[39] F. Lin, J.-H. You, Abduction in logic programming: A new definition and an abductive procedure based on rewriting, in: IJCAI, 2001, pp. 655–666.[40] F. Lin, Y. Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, in: Proc. of the 8th National Conference on Artificial Intelligence andFourteenth Conference on Innovative Applications of Artificial Intelligence (AAAI/IAAI-02), Menlo Parc, CA, USA, 2002, pp. 112–118.[41] J. McCarthy, Circumscription—a form of non-monotonic reasoning, Artificial Intelligence 13 (1–2) (1980) 27–39.[42] P. Nicolas, B. Duval, Representation of incomplete knowledge by induction of default theories, in: LPNMR, 2001, pp. 160–172.[43] I. Niemelä, P. Simons, Smodels: An implementation of the stable model and well-founded semantics for normal LP, in: Proc. of the 4th InternationalConference on Logic Programming and Nonmonotonic Reasoning (LPNMR), Berlin, 1997, pp. 420–429.[44] L. Palopoli, S.E. Rombo, G. Terracina, Flexible pattern discovery with (extended) disjunctive logic programming, in: ISMIS, 2005, pp. 504–513.[45] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.[46] J. Pearl, System z: a natural ordering of defaults with tractable applications to nonmonotonic reasoning, in: Proceedings of the 3rd Conference onTheoretical Aspects of Reasoning about Knowledge, Monterey, CA, 1990, pp. 121–135.[47] D. Poole, Normality and faults in logic-based diagnosis, in: Proceedings of the International Joint Conference on Artificial Intelligence, Detroit, Michigan,USA, 1989, pp. 1304–1310.[48] S. Ramaswamy, R. Rastogi, K. Shim, Efficient algorithms for mining outliers from large data sets, in: Proc. ACM Int. Conf. on Management of Data,Dallas, Texas, USA, 2000, pp. 427–438.[49] R. Reiter, A logic for default reasoning, Artificial Intelligence 13 (1–2) (1980) 81–132.[50] S. Rosset, U. Murad, E. Neumann, Y. Idan, and G. Pinkas, Discovery of fraud rules for telecommunications-challenges and solutions, in: Proc. ACM Int.Conf on Knowledge Discovery and Data Mining, San Diego, California, USA, 1999, pp. 409–413.[51] C. Sakama, K. Inoue, On the equivalence between disjunctive and abductive logic programs, in: International Conference on Logic Programming, 1994,pp. 489–503.[52] C. Sakama, K. Inoue, Abductive logic programming and disjunctive logic programming: their relationship and transferability, Journal of Logic Program-ming 44 (1–3) (2000) 75–100.[53] S. Sarawagi, R. Agrawal, N. Megiddo, Discovery-driven exploration of olap data cubes, in: Proc. Sixth Int. Conf on Extending Database Technology,Valencia, Spain, March 1998, pp. 168–182.[54] J. Stillman, The complexity of propositional default logics, in: Proceedings of the 10th National Conference on Artificial Intelligence, San Jose, California,USA, July 1992, pp. 794–800.[55] Z.R. Struzik, A. Siebes, Outliers detection and localisation with wavelet based multifractal formalism, in: Tech. Report INS-R0008, CWI, Amsterdam,2000.[56] P.-N. Tan, M. Steinbach, V. Kumar, Introduction to Data Mining, Addison-Wesley, 2005.[57] M.Y. Vardi, The complexity of relational query language, in: Proc. 14th ACM Symp. on Theory of computing, San Francisco, CA, USA, May 1982, pp. 137–146.[58] A. Zhang, W. Marek, On the classification and existence of structures in default logic, Fundamenta Informaticae 13 (4) (1990) 485–499.