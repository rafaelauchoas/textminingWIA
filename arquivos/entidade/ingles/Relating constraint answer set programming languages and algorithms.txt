Artificial Intelligence 207 (2014) 1–22Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintRelating constraint answer set programming languages andalgorithmsYuliya LierlerDepartment of Computer Science, The University of Nebraska at Omaha, 6001 Dodge Street, Omaha, NE 68182, United Statesa r t i c l ei n f oa b s t r a c tArticle history:Received 9 October 2012Received in revised form 28 October 2013Accepted 29 October 2013Available online 11 November 2013Keywords:(Constraint) answer set programmingConstraint satisfaction processingSatisfiability modulo theoriesRecently a logic programming language AC was proposed by Mellarkod et al. [1] tointegrate answer set programming and constraint logic programming. Soon after that,a clingcon language integrating answer set programming and finite domain constraints,as well as an ezcsp language integrating answer set programming and constraint logic pro-gramming were introduced. The development of these languages and systems constitutesthe appearance of a new AI subarea called constraint answer set programming. All theselanguages have something in common. In particular, they aim at developing new efficientinference algorithms that combine traditional answer set programming procedures andother methods in constraint programming. Yet, the exact relation between the constraintanswer set programming languages and the underlying systems is not well understood.In this paper we address this issue by formally stating the precise relation between sev-eral constraint answer set programming languages – AC, clingcon, ezcsp – as well as theunderlying systems.© 2013 Published by Elsevier B.V.1. IntroductionConstraint answer set programming (CASP) is a novel, promising direction of research whose roots can be traced backto propositional satisfiability (SAT). SAT solvers are efficient tools for solving Boolean constraint satisfaction problems thatarise in different areas of computer science, including software and hardware verification. Answer set programming (ASP)extends computational methods of SAT using ideas from knowledge representation, logic programming, and nonmonotonicreasoning. As a declarative programming paradigm, it provides a rich, and yet simple modeling language that, among otherfeatures, incorporates recursive definitions. Satisfiability modulo theories (SMT) extends computational methods of SAT byintegrating non-Boolean symbols defined via a background theory in other formalisms, such as first order theory or aconstraint processing language. The key ideas behind such integration are that (a) some constraints are more naturallyexpressed by non-Boolean constructs and (b) computational methods developed in other areas of automated reasoning thanSAT may complement its technology in an effective manner processing these constraints.Constraint answer set programming draws on both of these extensions of SAT technology: it integrates answer set pro-gramming with constraint processing. This new area has already demonstrated promising results, including the developmentof the CASP solvers acsolver [1] (Texas Tech University), clingcon1 [2,3] (Potsdam University, Germany), ezcsp2 [4] (KO-DAK), idp3 [5] (KU Leuven). These systems provide new horizons to knowledge representation as a field by broadening theapplicability of its computational tools. CASP not only provides new modeling features for answer set programming but1 http://www.cs.uni-potsdam.de/clingcon/.2 http://marcy.cjb.net/ezcsp/index.html.3 http://dtai.cs.kuleuven.be/krr/software/idp.0004-3702/$ – see front matter © 2013 Published by Elsevier B.V.http://dx.doi.org/10.1016/j.artint.2013.10.0042Y. Lierler / Artificial Intelligence 207 (2014) 1–22also improves grounding and solving performance by delegating processing of constraints over large and possibly infinitedomains to specialized systems. The origins of this work go back to [6,7].Drescher and Walsh [8,9] (inca, NICTA, Australia), Liu et al. [10] (mingo, Aalto University, Finland) took an alternativeapproach to tackling CASP languages – a translational approach. In the former case, the CASP programs are translated intoASP programs (Drescher and Walsh proposed a number of translations). In the latter, the program is translated into integerlinear programming formalism. The empirical results demonstrate that this is also a viable approach towards tackling CASPprograms.The general interest towards CASP paradigms illustrates the importance of developing synergistic approaches in the au-tomated reasoning community. To do so effectively one requires a clear understanding of the important features of theCASP-like languages and underlying systems. Current CASP languages are based on the same principal ideas yet relatingthem is not a straightforward task. One difficulty lies in the fact that these languages are introduced together with a spe-cific system architecture in mind that rely on various answer set programming, constraint satisfaction processing, constraintlogic programming, and integer linear programming technologies. The syntactic differences stand in the way of clear un-derstanding of the key features of the languages. For example, the only CASP language that was compared to its earliersibling was the language ezcsp. Balduccini [4] formally stated that the ezcsp language is a special case of AC. Relating CASPsystems formally is an even more complex task. The variations in underlying technologies complicate clear articulation oftheir similarities and differences. For instance, the main building blocks of the CASP solver acsolver [1] are the ASP sys-tem smodels [11] and sicstus Prolog.4 The technology behind clingcon [2,3] is developed from the ASP solver clasp [12]and the constraint solver gecode [13]. In addition, the CASP solvers adopt different communication schemes among theirheterogeneous solving components. For instance, the system ezcsp relies on blackbox integration of ASP and CSP tools inorder to process the ezcsp language [4]. Systems acsolver and clingcon promote tighter integration of multiple automatedreasoning methods.The broad attention to CASP suggests a need for a principled and general study of methods to develop unifying ter-minology and formalisms suitable to capture variants of the languages and solvers. This work can be seen as a step inthis direction. First, it presents a formal account that illustrates a precise relationship between the languages of acsolver,clingcon, and ezcsp. Second, it formally relates the systems that take a hybrid approach to solving in CASP. In particular, itaccounts for systems acsolver, clingcon, and ezcsp.Usually backtrack search procedures (Davis–Putnam–Logemann–Loveland (DPLL)-like procedures [14]), the backbone ofCASP computational methods are described in terms of pseudocode. In [15], the authors proposed an alternative approachto describing DPLL-like algorithms. They introduced an abstract graph-based framework that captures what the “states ofcomputation” are and what transitions between states are allowed. This approach allows us to model a DPLL-like algorithmby a mathematically simple and elegant object, a graph, rather than a collection of pseudocode statements. We develop asimilar abstract framework for performing precise formal analysis on relating the constraint answer set solvers acsolver,clingcon, and ezcsp. Furthermore, this framework allows an alternative proof of correctness of these systems. This workclarifies and extends state-of-the-art developments in the area of constraint answer set programming and, we believe, willpromote further progress in the area.More on related work Another direction of work related to the developments in CASP is research on HEX-programs [16].These programs integrate logic programs under answer set semantics with external computation sources via external atoms.They were motivated by the need to interface ASP with external computation sources, for example, to allow the synergyof ASP and description logic computations within the context of the semantic web. CASP has a lot in common with HEX-programs. System dlvhex5 [17] computes models of such programs. It allows defining plug-ins for inference on externalatoms and as such can be used as a general framework for developing CASP solvers (but it does not provide any specificcomputational mechanism by default).Heterogeneous nonmonotonic multi-context systems [18] is another formalism related both to CASP and HEX-programs.CASP and HEX-programs can be seen as one of the possible incarnations of a special case of multi-context systems. Multi-context systems provide a more general formalism where “contexts” written in different logics relate with each other viabridge rules. Intuitively, CASP provides two contexts: one in the language of answer set programming and another one inthe language of constraint programming. Yet, the bridge rules are of extremely simplistic nature in CASP, in particular, theyrelate atoms in a logic program to constraints of constraint processing.Paper structure We start by reviewing AC programs introduced by Mellarkod et al. [1] and the notion of an answer setfor such programs. In the subsequent section we introduce the clingcon language and formally state its relation to the AClanguage. We then define a new class of weakly-simple programs and demonstrate that the acsolver algorithm is applicablealso to such programs. We review a transition system introduced by Lierler [19,20] to model smodels. We extend thistransition system to model the acsolver algorithm and show how the newly defined graph can characterize the computationbehind the system acsolver. We define a graph suitable for modeling the system clingcon and state a formal result on the4 http://www.sics.se/isl/sicstuswww/site/index.html.5 http://www.kr.tuwien.ac.at/research/systems/dlvhex/.Y. Lierler / Artificial Intelligence 207 (2014) 1–223relation between the acsolver and clingcon algorithms. At last we illustrate how the same graph may model the ezcspsystem. The final section presents the proofs of the formal results stated in the paper.A report on some of the results of this paper has been presented at [21] and [22]. This work extends earlier efforts by in-troducing a transition system that captures advanced CASP solvers clingcon and ezcsp featuring learning and backjumping.This paper also provides a complete account of proofs for the formal results.2. Review: AC programsA sort (type) is a non-empty countable collection of strings over some fixed alphabet. A signature Σ is a collectionof sorts, properly typed predicate symbols, constants, and variables. Sorts of Σ are divided into regular and constraintsorts. All variables in Σ are of a constraint sort. Each variable takes on values of a unique constraint sort. For example, letsignature Σ1 contain three regular sorts step = {0..1}, action = {a}, fluent = { f }; and two constraint sorts time = {0..200},computer = {1..2}; variable T , Tof constraint sort time; and predicates(cid:2)at(step, time) occurs(action, step) next(step, step) holds(fluent, step)on okTime(time) okComp(computer, time).A term of Σ is either a constant or a variable.An atom is of the form p(t1, . . . , tn) where p is an n-ary predicate symbol, and t1, . . . , tn are terms of the proper sorts.A literal is either an atom a or its negation ¬a. A constraint sort is often a large numerical set with primitive constraintrelations (examples include arithmetic constraint relations like (cid:2)).The partitioning of sorts induces a partition of predicates of the AC language:• Regular predicates denote relations among constants of regular sorts;• Constraint predicates denote primitive constraint relations on constraint sorts;• Defined predicates denote relations between constants that belong to regular sort and constants that belong to constraintsorts; such predicates can be defined in terms of constraint, regular, and defined predicates;• Mixed predicates denote relations between constants that belong to regular sort and constants that belong to constraintsorts. Mixed predicates are not defined by the rules of a program and are similar to abducible relations of abductivelogic programming [23].For example, for signature Σ1, we define at(step, time) to be a mixed predicate; occurs(action, step), on, next(step, step),holds(fluent, step) to be regular predicates; okTime(time) and okComp(computer, time) to be defined predicates.An atom formed by a regular predicate is called regular. Similarly for constraint, defined, and mixed atoms. We say thatan atom is a non-mixed atom if it is regular, constraint, or defined. For signature Σ1, atoms at(0, T ) and occurs(a, 1) aresample mixed and regular atoms respectively.A nested program is a finite set of rules of the forma0 ← a1, . . . , al, not al+1, . . . , not am,not not am+1, . . . , not not an,(1)where a0 is ⊥ or a ground non-constraint atom, and each ai (1 (cid:2) i (cid:2) n) is a ground non-constraint atom or symbols (cid:5),⊥. If a0 = ⊥, we often omit ⊥ from the notation. This is a special case of programs with nested expressions [24]. Theexpression a0 is the head of a rule (1). If B denotes the body of (1), the right hand side of the arrow, we write B pos forthe elements occurring in the positive part of the body, i.e., B pos = {a1, . . . , al}; Bneg for the elements occurring under singlenegation as failure, i.e., Bneg = {al+1, . . . , am}; and Bneg2 for the elements occurring under double negation as failure, i.e.,Bneg2 = {am+1, . . . , an}. We frequently identify the body of (1) with the conjunction of its elements (in which not is replacedwith the classical negation connective ¬):a1 ∧ · · · ∧ al ∧ ¬al+1 ∧ · · · ∧ ¬am ∧ ¬¬am+1 ∧ · · · ∧ ¬¬an.Similarly, we often interpret a rule (1) as a clause(2)a0 ∨ ¬a1 ∨ · · · ∨ ¬al ∨ al+1 ∨ · · · ∨ am ∨ ¬am+1 ∨ · · · ∨ ¬an(3)(in the case when a0 = ⊥ in (1) a0 is absent in (3)). Given a program Π , we write Π cl for the set of clauses (3) correspond-ing to the rules in Π .We restate the definition of an answer set due to Lifschitz et al. [24] for nested programs in a form convenient for ourpurposes. The reduct Π X of a nested program Π with respect to set X of atoms is obtained from Π by deleting each rule (1)such that X does not satisfy its body (recall that we identify its body with (2)), and replacing each remaining rule (1) bya0 ← Bpos where B stands for the body of (1). A set X of atoms is an answer set of a nested program Π if it is minimalamong sets of atoms satisfying (Π X )cl.According to [25], ach oice rule construct [11]{a}4Y. Lierler / Artificial Intelligence 207 (2014) 1–22of the lparse6 language can be seen as an abbreviation for a rulea ← not not a.We adopt this abbreviation in the rest of the paper. For a program that consists of this rule both ∅ and {a} form its answersets.The rules and programs are called regular if the bodies of the rules do not contain symbols (cid:5) or ⊥.An (AC) program is a finite set of rules of the form (1) where• a0 is ⊥, a regular, or a defined atom,• each ai , 1 (cid:2) i (cid:2) l, is a non-mixed atom if a0 is a defined atom,• each ai , l + 1 (cid:2) i (cid:2) n, is a non-mixed atom.We assume that any mixed atom occurring in AC program is of the restricted form m((cid:9)r, V ), where (cid:9)r is a sequence of regularconstants and V is a variable. This assumption does not impact applicability of the language but is made for the ease of thepresentation.For instance, a sample AC program over signature Σ1 followsokComp(1, T ) ← T (cid:2) 5, on.okComp(2, 106) ← on.okTime(T ) ← T (cid:2) 10, okComp(1, T ).okTime(T ) ← T (cid:3) 100, okComp(2, T ).← occurs(a, 0), at(0, T ), T (cid:10)= 1, not okTime(T ).← occurs(a, 0), at(0, T ), T (cid:3) 110.(cid:2) (cid:3) 110.← occurs(a, 1), at(1, Tholds( f , 1) ← occurs(a, 0), next(1, 0).next(1, 0).occurs(a, 0).{on}.), T(cid:2)(4)The implementation of such language requires the declaration of the signature Σ1 itself. In syntax proposed by Mellarkodet al. [1] we encode the declaration of Σ1 as follows:time(0..200).computer(1..2).step(0..1).action(a).fluent( f ).#csort(time).#csort(computer).#mixed at(step, time).#regular occurs(action, step).#regular on.#defined okTime(time).#defined okComp(computer, time).This sample program is inspired by Example 1 in [1] that encodes a small planning domain. It is well known that answerset programming provides a convenient language for encoding planning problems. Yet if in a problem actions have tobe mapped to real time that is represented by a large integer domain, grounding becomes a bottleneck for answer setprogramming. Mellarkod et al. illustrated how AC language allows us to overcome this limitation in Example 1.Mellarkod et al. [1] considered programs of different syntax than discussed here. For instance, in [1] classical negationmay precede atoms in rules. Also signature Σ may contain variables of regular sort. Nevertheless, the AC language discussedhere is sufficient to capture the class of programs covered by the acsolver algorithm.2.1. Semantics of the AC languageWe define the semantics of AC programs by transforming a program into a nested program using grounding. For anAC program Π over signature Σ , by the set ground(Π) we denote the set of all ground instances of the rules in Π . The∗(Π) is obtained from ground(Π) by replacing a constraint atom a by (cid:5) or ⊥ if a is true or false respectively.set ground6 http://www.tcs.hut.fi/Software/smodels/.Y. Lierler / Artificial Intelligence 207 (2014) 1–225A ground constraint atom evaluates to true or false under a standard interpretations of its symbols. For example, a constraint∗atom 1 = 1 evaluates to true, whereas a constraint atom 1 (cid:10)= 1 evaluates to false. It is easy to see that ground(Π) is a nestedprogram.For instance, let ground(Π) consist of two rulesokTime(100) ← 100 > 100, okComp(2, 100).okTime(101) ← 101 > 100, okComp(2, 101).← occurs(a, 0), at(0, 101), 101 (cid:10)= 1, not okTime(101).∗then ground(Π) isokTime(101) ← ⊥, okComp(2, 100).okTime(101) ← (cid:5), okComp(2, 101).← occurs(a, 0), at(0, 101), (cid:5), not okTime(101).If we define the semantics of an AC program as the semantics of a corresponding nested program ground(Π) thenmixed atoms will never be part of answer sets (indeed, mixed atoms never occur in the heads of the rules). This is differentfrom an intended meaning of these atoms that suppose to “connect” the values of regular constants and their constraintcounterpart. We now introduce notion of a functional set composed of mixed atoms that is crucial in defining answer setsof AC programs. We say that a sequence of (regular) constants (cid:9)r is specified by a mixed predicate m if (cid:9)r follows the sortsof the regular arguments of m. For instance, for program (4) a sequence 0 of constants (of type step) is the only sequencespecified by mixed predicate at. For a set X of atoms, we say that a sequence (cid:9)r of regular constants is bound in X by a(constraint) constant c w.r.t. predicate m if there is an atom m((cid:9)r, c) in X . A set M of ground mixed atoms is functionalover the underlying signature if for every mixed predicate m, every sequence of regular constants specified by m is boundin M by a unique constraint constant w.r.t. m. For instance, for the signature of program (4) sets {at(0, 1), at(1, 1)} and{at(0, 2), at(1, 1)} are functional, whereas {at(0, 1)} and {at(0, 1), at(0, 2)} are not functional sets.∗Definition 1. For an AC program Π , a set X of atoms is called an answer set of Π if there is a functional set M of ground∗mixed atoms of Σ such that X is an answer set of ground(Π) ∪ M.For example, sets of atoms(cid:2)(cid:3)at(0, 1), at(1, 1), occurs(a, 0), next(1, 0), holds( f , 1)and(cid:2)on, at(0, 0), occurs(a, 0), at(1, 1), next(1, 0), holds( f , 1),okComp(1, 0), . . . , okComp(1, 5), okComp(2, 106),(cid:3)okTime(0), . . . , okTime(5), okTime(106)(5)are among answer sets of (4).The definition of an answer set for AC programs presented here is different from the original definition in [1] (evenwhen we restrict our attention to programs without doubly negated atoms), but there is a close relation between them:Proposition 1. For an AC program Π over signature Σ such that Π contains no doubly negated atoms and the set S of all true groundconstraint literals over Σ , X is an answer set of Π if and only if X ∪ S is an answer set (in the sense of [1]) of Π .3. The CLINGCON languageConsider a subset of the AC language, denoted AC−, so that any AC program without defined atoms is an AC−The language of the constraint answer set solver clingcon defined in [2,3]7 can be seen as a syntactic variant of the AClanguage.We now review clingcon programs and show how they map into ACprograms. For a signature Σ , aclingcon variableis an expression of the form p((cid:9)r ), where p is a mixed predicate and (cid:9)r is a sequence of regular constants. For any clingconvariable p((cid:9)r ), by p((cid:9)r )0 we denote its predicate symbol p and by p((cid:9)r )s we denote its sequence of regular constants (cid:9)r.−program.−7 The system clingcon accepts programs of more general syntax than discussed in [2] (for instance, aggregates such as #count are allowed by clingcon).6Y. Lierler / Artificial Intelligence 207 (2014) 1–22We say that an atom is a clingcon atom over Σ if it has the following formv 1 ◦ · · · ◦ vk ◦ c1 ◦ · · · ◦ cm (cid:14) vk+1 ◦ · · · ◦ vl ◦ cm+1 ◦ · · · ◦ cn,(6)where v i is a clingcon variable; ci is a constraint constant; ◦ are primitive constraint operations (note that ◦ denotes anoccurrence of an operation so that a different operation can be used at each occurrence); and (cid:14) is a primitive constraintrelation.A clingcon program is a finite set of rules of the form (1) where (i) a0 is ⊥ or a regular atom, (ii) each ai , 1 (cid:2) i (cid:2) n, isa regular or clingcon atom. The system clingcon accepts rules where a0 is a clingcon atom but it should be seen as anabbreviation for the same rule with ⊥ as the head and not a0 occurring in the body.Any clingcon program Π can be rewritten in ACusing a function ν that maps the set of clingcon variables occurring−in Π to the set of distinct variables over Σ . For a clingcon variable v, vν denotes a variable assigned to v by ν.For each occurrence of clingcon atom (6) in some rule r of Π (i) add a set of mixed atoms v 0i (v si , vνi ) for 1 (cid:2) i (cid:2) l to thebody of r, and (ii) replace (6) in r by a constraint atomvν1◦ · · · ◦ vνk◦ c1 ◦ · · · ◦ cm (cid:14) vνk+1◦ · · · ◦ vνl◦ cm+1 ◦ · · · ◦ cn.We denote resulting AC−program by ac(Π).For instance, let clingcon program Π over Σ1 without defined predicates consist of a single rule← occurs(a, 0), at(0) (cid:3) 110.Given ν that maps at(0) to T(cid:2)← occurs(a, 0), at(cid:4)0, T, ac(Π) has the form(cid:2) (cid:3) 110., T(cid:5)(cid:2)(7)(8)The following proposition makes the relation between a clingcon program and its AC−counterpart precise.Proposition 2. For a clingcon program Π over signature Σ , a set X is a constraint answer set of Π according to the definition in [2,3]iff there is a functional set M of ground mixed atoms of Σ such that X ∪ M is an answer set of ac(Π).We demonstrated how any clingcon program can be seen as a program in the language of AC. There is an importantclass of AC programs called safe. In fact, Mellarkod et al. [1] only considered such programs in devising the algorithmprogram, we can syntactically transformfor processing the AC programs. We will now illustrate that given any safe ACand clingcon (for which the solving procedures have beenthis program into a clingcon one. Thus the languages of ACproposed) are truly only syntactic variants of each other. We now define a two step transformation that first transforms asafe ACprogram into what we call a super-safe program and then into a corresponding clingcon program.−−−−Rule (1) is called a defined rule if a0 is a defined atom. We say that an AC program Π is safe [1] if every variable occurringin a non-defined rule in Π also occurs in a mixed atom of this rule. In other words, any constraint variable occurring ina non-defined rule is mapped to some sequence of regular constants (cid:9)r specified by a mixed predicate. Consider, a safeof sort time maps to a regular constant 0 of sort step specified by mixed predicate at.program (8). A constraint variable T(cid:2)An AC program Π is super-safe if Π is safe and1. if a mixed atom m((cid:9)c, X) occurs in Π then a mixed atom m((cid:9)c, X(cid:2)) does not occur in Π (where X and X(cid:2)are distinct2. if a mixed atom m((cid:9)c, X) occurs in Π then neither a mixed atom m(cid:2)((cid:9)c(cid:2), X) such that (cid:9)c (cid:10)= (cid:9)c(cid:2)nor a mixed atom m(cid:2)((cid:9)c, X)variable names),such that m (cid:10)= m(cid:2)occurs in Π .For example, program (4) is super-safe. On the other hand, if we replace the sixth rule of (4) by semantically the samerule (8) the program is not super-safe (but safe) as both conditions 1 and 2 are violated. Intuitively, super-safeness ensuresthat a constraint variable maps uniquely to some sequence of (regular) constants (cid:9)r specified by a specific mixed predicatem and the other way around. For instance, in program (4) constraint variable T of sort time corresponds to regular constantof sort time corresponds to constant 1 of sort0 of sort step specified by mixed predicate at, whereas constraint variable Tstep specified by at.(cid:2)We note that any safe AC program Π can be converted to a super-safe program so that the resulting program has thesame answer sets:Proposition 3. For any safe AC program Π , there is a transformation on Π that produces a super-safe AC program which has the sameanswer sets as Π .Appendix A presents such a transformation.−For any super-safe ACprogram Π , by con(Π) we denote a clingcon program constructed as follows: (i) all mixed atomsin Π are dropped, (ii) every constraint variable X is replaced by an expression m((cid:9)c) where m((cid:9)c, X) is a mixed atom in ΠY. Lierler / Artificial Intelligence 207 (2014) 1–227in which X occurs (given the conditions of super-safeness we are guaranteed that there is a unique mixed atom of the formm((cid:9)c, X) for each constraint variable X in Π ).−program Π over Σ1 (without defined predicates) consist of a single rule (8). This program is clearlyFor instance, let ACsuper-safe. The corresponding clingcon program con(Π) is (7).The following proposition makes the relation between a super-safe AC−program and its clingcon counterpart precise.Proposition 4. For a super-safe program Π over signature Σ , there is a functional set M of ground mixed atoms of Σ such that X ∪ Mis an answer set of Π iff a set X is a constraint answer set of con(Π) according to the definition in [2,3].In other words, Proposition 4 suggests that the languages AC−and clingcon are syntactic variants of each other.4. Weakly-simple AC programsTo the best of our knowledge system acsolver was the first CASP solver implemented. The correctness of the acsolveralgorithm was shown for simple AC programs.8 We start this section by reviewing simple programs. We then define a moregeneral class of programs called weakly-simple. In Section 6 we present a generalization of the acsolver algorithm andstate its correctness for such programs.A part of the AC program Π that consists of defined rules is called a defined part denoted by ΠD . By ΠR we denote anon-defined part of Π , i.e., Π \ ΠD . For program (4), the rulesokComp(1, T ) ← T (cid:2) 5, onokComp(2, 106) ← onokTime(T ) ← T (cid:2) 10, okComp(1, T )okTime(T ) ← T (cid:3) 100, okComp(2, T )form its defined part whereas the other rules form ΠR .We say that an AC program Π is simple if it is super-safe and its defined part contains no regular atoms and has a uniqueanswer set. In weakly-simple programs that we define here we first lift the restriction that a defined part of a program hasa unique answer set. Second, weakly-simple programs allow regular atoms in defined rules under some syntactic conditionsthat we define by means of a predicate dependency graph. For any AC program Π , the predicate dependency graph9 of Π isa directed graph that• has all predicates occurring in Π as its vertices, and• for each rule (1) in Π has an edge from a00 to a0i where 1 (cid:2) i (cid:2) l.Definition 2. We say that an AC program Π is weakly-simple if• it is super-safe,• each strongly connected component of the predicate dependency graph of Π is a subset of either regular predicates ofΠ or defined predicates.It is easy to see that any simple program is also a weakly-simple program but not the other way around. For example,program (4) is weakly-simple but not simple since its defined part contains a regular atom on.5. Abstract SMODELSMost state-of-the-art answer set solvers are based on algorithms closely related to the dpll procedure [14]. Nieuwen-huis et al. described dpll by means of a transition system that can be viewed as an abstract framework underlying dpllcomputation [15]. Lierler [19,20] proposed a similar framework, smΠ , for specifying an answer set solver smodels followingthe lines of its pseudocode description [27]. Our goal is to design such a framework for describing an algorithm behindacsolver. As a step in this direction we review the graph smΠ that underlines an algorithm of smodels, one of the mainbuilding blocks of acsolver. The presentation follows [19].For a set σ of atoms, a record relative to σ is a list M of literals over σ , some possibly annotated by (cid:6), which marksthem as decision literals. A state relative to σ is a record relative to σ possibly preceding symbol ⊥. For instance, somestates relative to a singleton set {a} of atoms are8 The acsolver algorithm was proved to be correct for a class of “safe canonical” programs – a special case of simple programs. Any simple program maybe converted to a canonical program by means of syntactic transformations discussed in [1].9 A similar definition of predicate dependency graph was given in [26] for programs of more general syntax.8Y. Lierler / Artificial Intelligence 207 (2014) 1–22Unit Propagate:M (cid:15)⇒ M l if C ∨ l ∈ Π cl and C ⊆ MDecide:M (cid:15)⇒ M l(cid:6) if l is unassigned by MFail:(cid:6)M (cid:15)⇒ ⊥ ifM is inconsistent and different from ⊥,M contains no decision literalsBacktrack:(cid:6)P l(cid:6) Q (cid:15)⇒ P l ifAll Rules Cancelled:P l(cid:6) Q is inconsistent, andQ contains no decision literalsM (cid:15)⇒ M ¬a if B ∩ M (cid:10)= ∅ for all B ∈ Bodies(Π, a)Backchain True:(cid:6)M (cid:15)⇒ M l ifUnfounded:a ← B ∈ Π, a ∈ M, l ∈ B,B(cid:2) ∩ M (cid:10)= ∅ for all B(cid:2) ∈ Bodies(Π, a) \ BM (cid:15)⇒ M¬a if a ∈ U for a set U unfounded on M w.r.t. ΠFig. 1. The transition rules of the graph smΠ .∅, a, ¬a, a(cid:6), a ¬a, ⊥, a⊥, ¬a⊥, a(cid:6)⊥, a ¬a⊥.We say that a state is inconsistent if either ⊥ or two complementary literals occur in it, e.g., a and ¬a. For example,states a¬a and a⊥ are inconsistent. Frequently, we identify a state M with a set of literals occurring in it possibly with thesymbol ⊥, ignoring both the annotations and the order between its elements. In some cases we identify a set of literalswith a conjunction of its members, thus we can write M |(cid:15) φ where M is a state and |(cid:15) is understood as a satisfiabilityrelation. If neither a literal l nor its complement l occur in M, then l is unassigned by M. For a set M of literals, by Mandwe denote the set of atoms stemming from positive and negative literals in M respectively. For instance, {a, ¬b}+ = {a}Mand {a, ¬b}− = {b}.+−If C is a disjunction (conjunction) of literals then by C we understand the conjunction (disjunction) of the complementsof the literals occurring in C . In some situations, we will identify disjunctions and conjunctions of literals with the sets ofthese literals.By Bodies(Π, a) we denote the set of the bodies of all rules of a regular program Π with the head a. We recall that a setU of atoms occurring in a regular program Π is unfounded [28,29] on a consistent set M of literals with respect to Π if forevery a ∈ U and every B ∈ Bodies(Π, a), M |(cid:15) B (where B is identified with the conjunction of its elements), or U ∩ B pos (cid:10)= ∅.Each regular program Π determines its Smodels graph smΠ . The set of nodes of smΠ consists of the states relative to theset of atoms occurring in Π . The edges of the graph smΠ are specified by the transition rules presented in Fig. 1. A node isterminal in a graph if no edge leaves this node.The graph smΠ can be used for deciding whether a regular program Π has an answer set by constructing a path from∅ to a terminal node. Following proposition serves as a proof of correctness and termination for any procedure that iscaptured by the graph smΠ .Proposition 5. For any regular10 program Π ,(a) graph smΠ is finite and acyclic,(b) for any terminal state M of smΠ other than ⊥, M(c) state ⊥ is reachable from ∅ in smΠ if and only if Π has no answer sets.is an answer set of Π ,+6. Abstract ACSOLVER6.1. Query, extensions, and consequencesIn order to present the transition system suitable for capturing acsolver we introduce several concepts.Given an AC program Π and a set p of predicate symbols, a set X of atoms is a p-input answer set (or an input answer setw.r.t. p) of Π if X is an answer set of Π ∪ Xp where by Xp we denote the set of atoms in X whose predicate symbols aredifferent from the ones occurring in p. For instance, let X be a set {a(1), b(1)} of atoms and let p be a set {a} of predicates,then Xp is {b(1)}. The set X is a p-input answer set of a program a(1) ← b(1). On the other hand, it is not an input answerset for the same program with respect to a set {a, b} of predicate symbols. Intuitively set p denotes a set of intentionalpredicates [30]: The concept of p-input answer sets is closely related to “p-stable models” in [30].10 In [19], only programs without doubly negated atoms were considered. Extension of the results to regular programs is straightforward.Y. Lierler / Artificial Intelligence 207 (2014) 1–229Proposition 6. For a nested program Π , a complete set X of literals, and a set p of predicate symbols such that predicate symbolsis a p-input answer set of Π iff X is a model of SMp[Π] (i.e., p-stable model of Π ).occurring in the heads of Π form a subset of p, X+For a set S of literals, by S R , S D , and S C we denote the set of regular, defined, and constraint literals occurring in Srespectively. By S R,D and S D,C we denote the unions S R ∪ S D and S D ∪ S C respectively. By At(Π) we denote the set ofatoms occurring in a program Π . Recall that a substitution Θ is a finite set of the form{v 1/t1, . . . , vn/tn}where v 1, . . . , vn are distinct variables and each ti is a term other than v i . Given a substitution Θ and a set X of literals,we write XΘ for the result of a substitution.For an AC program Π , a (complete) query Q is a (complete) consistent set of literals over At(ΠD )R ∪ At(ΠR )D,C . For aquery Q of Π , a complete query E is a satisfying extension of Q w.r.t. Π if Q ⊆ E and there is a (sort respecting) substitutionγ of variables in E by ground terms so that the result of this substitution, Eγ , satisfies the conditions1. if a constraint literal l ∈ Eγ then l is true under the intended interpretation of its symbols, and2. there is an input answer set A of ΠD w.r.t. defined predicates of Π such that Eγ +R,D⊆ A and Eγ −R,D∩ A = ∅.We say that literal l is a consequence of Π and Q if for every satisfying extension E of Q w.r.t. Π , l ∈ E. By Cons(Π, Q ),we denote the set of all consequences of Π and Q . If there are no satisfying extensions of Q w.r.t. Π we identifyCons(Π, Q ) with the singleton {⊥}.Let Π be (4) and Q be {okTime(T ), T (cid:10)= 1}. A set(cid:2)on, okTime(T ), T (cid:10)= 1(cid:3)forms a satisfying extension of Q w.r.t. Π . Indeed, consider substitutions {T /106}. This is the only satisfying extensionof Q w.r.t. Π . Consequently, it forms Cons(Π, Q ). On the other hand, there are no satisfying extensions for a query{¬on, okTime(T )} so that {⊥} corresponds to Cons(Π, Q ).6.2. The graph ACΠFor each constraint and defined atom A of signature Σ , select a new symbol Aξ , called the name of A. By Σ ξ we denotethe signature obtained from Σ by adding all names Aξ as additional regular predicate symbols (so that Aξ itself is a regularatom).For an AC program Π , by Π ξ we denote a set of rules consisting of (i) choice rules {aξ } for each constraint and definedatom a occurring in ΠR , and (ii) ΠR whose mixed atoms are dropped, and constraint and defined atoms are replaced bytheir names. Note that Π ξ is a regular program.For instance, let Π be (4) then Π ξ consists of the rules(cid:2)(cid:3).okTime(T )ξ(cid:2)(cid:3)(cid:2)(cid:3)(cid:2)..T(cid:2) (cid:3) 110T (cid:10)= 1ξT (cid:3) 110ξ← occurs(a, 0), T (cid:10)= 1ξ , not okTime(T )ξ← occurs(a, 0), T (cid:3) 110ξ .(cid:2) (cid:3) 110ξ .← occurs(a, 1), Toccurs(a, 0).holds( f , 1) ← occurs(a, 0), next(1, 0).next(1, 0).occurs(a, 0).{on}.(cid:3).(9)For a set M of atoms over Σ ξ , by Mξ −we denote a set of atoms over Σ by replacing each name Aξ occurring in Mwith a corresponding atom A. For instance, {okTime(T )ξ , T (cid:10)= 1ξ }ξ −is {okTime(T ), T (cid:10)= 1}.Let Π be an AC program. The nodes of the graph ACΠ are the states relative to the set At(Π ξ ) ∪ At(ΠD )R of atoms.For a state M of ACΠ , by query(M) we denote the largest subset of Mξ −over At(ΠD )R ∪ At(ΠR )D,C . For example, forprogram (4) and the state Moccurs(a, 0) ¬on(cid:6) okTime(T )ξ (cid:6),query(M) is {¬on, okTime(T )}.The edges of the graph ACΠ are described by the transition rules of smPropagate presented in Fig. 2. We abuse notation and identify ⊥ξ with ⊥ itself.Π ξ and the additional transition rule QueryThe graph ACΠ can be used for deciding whether a weakly-simple AC program Π has an answer set by constructing apath from ∅ to a terminal node:10Y. Lierler / Artificial Intelligence 207 (2014) 1–22Query Propagate:M (cid:15)⇒ M lξif l ∈ Cons(Π, query(M)),Fig. 2. The transition rule Query Propagate.Proposition 7. For any weakly-simple AC program Π ,(a) graph ACΠ is finite and acyclic,+(b) for any terminal state M of ACΠ other than ⊥, (Mξ −)R is a set of all regular atoms in some answer set of Π ,(c) state ⊥ is reachable from ∅ in ACΠ if and only if Π has no answer sets.Proposition 7 shows that algorithms that find a path in the graph ACΠ from ∅ to a terminal node can be regarded as ACsolvers for weakly-simple programs.Let Π be an AC program (4). Here is a path in ACΠ with every edge annotated by the name of a transition rule thatjustifies the presence of this edge in the graph:(cid:15)⇒ occurs(a, 0) Decide(cid:15)⇒ occurs(a, 0) ¬on(cid:6) Decide(cid:15)⇒∅ Unit Propagateoccurs(a, 0) ¬on(cid:6) okTime(T )ξ (cid:6) Query Propagate(cid:15)⇒occurs(a, 0) ¬on(cid:6) okTime(T )ξ (cid:6) ⊥ Backtrack(cid:15)⇒occurs(a, 0) ¬on(cid:6) ¬okTime(T )ξ Unit Propagateoccurs(a, 0) ¬on(cid:6) ¬okTime(T )ξ ¬T (cid:10)= 1ξ Unit Propagateoccurs(a, 0) ¬on(cid:6) ¬okTime(T )ξ ¬T (cid:10)= 1ξ next(1, 0)occurs(a, 0) ¬on(cid:6) ¬okTime(T )ξ ¬T (cid:10)= 1ξ next(1, 0) holds( f , 1)Unit Propagate(cid:15)⇒(cid:15)⇒(cid:15)⇒(10)Since the last state in the path is terminal, Proposition 7 asserts that(cid:2)(cid:3)occurs(a, 0) next(1, 0) holds( f , 1)forms the set of all regular atoms in some answer set of Π . Indeed, recall answer set (5).6.3. acsolver algorithmWe can view a path in the graph ACΠ as a description of a process of search for a set of regular atoms in some answerset of Π by applying the graph’s transition rules. Therefore, we can characterize an algorithm of a solver that utilizes thetransition rules of ACΠ by describing a strategy for choosing a path in this graph. A strategy can be based, in particular, onassigning priorities to transition rules of ACΠ , so that a solver never follows a transition due to a rule in a state if a rulewith higher priority is applicable. A strategy may also include restrictions on rule’s applications.We use this approach to describe the acsolver algorithm [1, Fig. 1]. The acsolver selects edges according to the prioritieson the transition rules of the graph ACΠ as follows:Backtrack, Fail (cid:20)Unit Propagate, All Rules Cancelled, Backchain True (cid:20)Unfounded (cid:20) Query Propagate⊥ (cid:20) Decide,where by Query Propagate⊥ we denote a transition due to the rule Query Propagate if there are no satisfying extensions ofquer y(M) w.r.t. ΠD , i.e., Cons(Π, query(M)) = {⊥}. It is easy to show that Proposition 7 also holds for subgraphs of ACΠthat are constructed by dropping all other edges due to Query Propagate but Query Propagate⊥. Let Π be an AC program (4).Path (10) in ACΠ does not comply with the priorities of the acsolver algorithm. On the other hand, the pathUnit Propagate(cid:15)⇒Unit Propagate(cid:15)⇒ occurs(a, 0)(cid:15)⇒ occurs(a, 0) next(1, 0)∅ Unit Propagateoccurs(a, 0) next(1, 0) holds( f , 1) Decide(cid:15)⇒occurs(a, 0) next(1, 0) holds( f , 1) ¬on(cid:6) Decide(cid:15)⇒occurs(a, 0) next(1, 0) holds( f , 1) ¬on(cid:6) okTime(T )ξ (cid:6) Query Propagate(cid:15)⇒occurs(a, 0) next(1, 0) holds( f , 1) ¬on(cid:6) okTime(T )ξ (cid:6) ⊥ Backtrack(cid:15)⇒occurs(a, 0) next(1, 0) holds( f , 1) ¬on(cid:6) ¬okTime(T )ξ Unit Propagate(cid:15)⇒occurs(a, 0) next(1, 0) holds( f , 1) ¬on(cid:6) ¬okTime(T )ξ ¬T (cid:10)= 1ξ(11)is a valid path of acsolver. Indeed, this path respects the fact that the transition rule Unit Propagate has a higher prioritythan Decide.Y. Lierler / Artificial Intelligence 207 (2014) 1–2211Unfounded(cid:2) :(cid:6)M (cid:15)⇒ M¬a ifa ∈ U for a set U unfounded on Mw.r.t. Π ( At(F ∪ Π ) \ Head(Π ))Fig. 3. The transition rule Unfounded’.Mellarkod et al. [1] demonstrated the correctness of the acsolver algorithm for the class of safe canonical programsby analyzing the properties of its pseudocode. Proposition 7 provides an alternative proof of correctness for this algorithmfor a more general class of weakly-simple programs that relies on the transition system ACΠ . Furthermore, Proposition 7encapsulates the proof of correctness for a class of algorithms that can be described using ACΠ . For instance, it immediatelyfollows that the acsolver algorithm modified to follow different priorities of transition rules is still correct.Note that for a clingcon program Π , ac(Π) is a weakly-simple program (in fact, it is a simple program). It follows thata class of algorithms captured by the graph AC Π is applicable to clingcon programs after minor syntactic transformations.Nevertheless the graph ACΠ is not suitable for describing the clingcon system. In the next section we present anothergraph for this purpose.7. Abstract CLINGCONThe clingcon system is based on tight coupling of the answer set solver clasp and the constraint solver gecode. Theclasp system starts its computation by building a propositional formula called completion [31] of a given program so thatits propagation relies not only on the program but also on the completion. Furthermore, it implements such backtrackingsearch techniques as backjumping, learning, forgetting, and restarts. Lierler and Truszczynski [32] introduced the transitionsystem sml(asp)F ,Π and demonstrated how it captures the clasp algorithm. It turns out that sml(asp)F ,Π augmented withthe transition rule Query Propagate is appropriate for describing clingcon. The graph sml(asp)F ,Π extends a simpler graphsm(asp)F ,Π [32]. These extensions are essential for capturing such advanced features of clasp and clingcon as conflict-driven backjumping and learning. In this section we start by reviewing the graph sm(asp)F ,Π and showing that augmentingit with the rule Query Propagate captures basic clingcon algorithm implementing a simple backtrack strategy in place ofconflict-driven backjumping and learning. We call new graph conF ,Π . This abstract view on basic clingcon allows us tocompare it to acsolver in formal terms. To capture full clingcon algorithm we extend conF ,Π with the rules Backjump andLearn in a similar manner as the graph sm(asp)F ,Π was extended to the graph sml(asp)F ,Π in [32].We write Head(Π) for the set of non-empty heads of rules in a program Π . For a clause C = ¬a1 ∨ · · · ∨ ¬al ∨ al+1 ∨· · · ∨ am we write C r to denote the rule← a1, . . . , al, not al+1, . . . , not am.For a set F of clauses, we define F r = {C r | C ∈ F }. For a set A of atoms, by Π( A) we denote a program Π extended withthe rules {a} for each atom a ∈ A.The transition graph sm(asp)F ,Π for a set F of clauses and a regular program Π is defined as follows. The set ofnodes of sm(asp)F ,Π consists of the states relative to At(F ∪ Π). There are five transition rules that characterize theedges of sm(asp)F ,Π . The transition rules Unit Propagate, Decide, Fail, Backtrack of the graph smF r ∪Π , and the transitionrule Unfounded’ presented in Fig. 3.Lierler and Truszczynski [11] demonstrated how sm(asp)ED-Comp(Π),Π models basic clasp (without conflict-driven back-jumping and learning) where ED-Comp(Π) denotes classified completion with the use of auxiliary atoms. FormulaED-Comp(Π) exhibits an important property that Lierler and Truszczynski call Π -safe. We now extend this notion to ACprograms. For an AC program Π , a set F of clauses is Π -safe if1. At(Π ξ ) ∪ At(ΠD )R ⊆ At(F ),2. F |(cid:15) ¬a, for every a ∈ At(Π ξ ) \ Head(Π ξ ), and3. for every answer set X of Π ξ there is a model M of F such that X = M+ ∩ Head(Π ξ ).We note that, a set F of clauses is Π -safe if it is Π ξ -safe according to the “safeness” definition given in [32]. If all regularatoms in Π also occur in its regular part, formula Π ξ clis a straightforward example of Π -safe formula. Under the samerestriction, formulas Comp(Π ξ ) and ED-Comp(Π ξ ) are also Π -safe, where the former stands for the completion of Π ξwhose formulas are classified in a straightforward way by applying distributivity. We refer the reader to [32] for precisedefinitions of Comp(Π) and ED-Comp(Π) constructed from the Clark’s completion of Π [31]. We call AC programs, whichsatisfy the restriction that all regular atoms in Π also occur in its regular part, friendly. This restriction is inessential as forsuch atoms adding simple constraints will turn a non-friendly program into a friendly one.We now define the graph conF ,Π for AC programs that extends sm(asp)F ,Π in a similar way as ACΠ extends smΠ .For an AC program Π and a set F of clauses, the nodes of conF ,Π are the states relative to the set At(F ∪ Π ξ ) ∪ At(ΠD )R .The edges of conF ,Π are described by the transition rules of sm(asp)F ,Π ξ and the transition rule Query Propagate of ACΠ .12Y. Lierler / Artificial Intelligence 207 (2014) 1–22Proposition 8. For any weakly-simple AC program Π and a Π -safe set F of clauses,(a) graph conF ,Π is finite and acyclic,+(b) for any terminal state M of conF ,Π other than ⊥, (Mξ −)R(c) state ⊥ is reachable from ∅ in conF ,Π if and only if Π has no answer sets.∩ At(Π) is a set of all regular atoms in some answer set of Π ,For friendly programs, the algorithm behind basic clingcon is modeled by means of the graph conED-Comp(Π ξ ),Π withthe following prioritiesBacktrack, Fail (cid:20) Unit Propagate (cid:20) UnfoundedQuery Propagate (cid:20) Decide.(cid:2) (cid:20)Proposition 8 demonstrates that the basic clingcon algorithm is applicable not only to clingcon programs but also to abroader class of weakly-simple AC programs.7.1. On the relation of acsolver and basic clingconFollowing concept helps us to formulate the relation between ACΠ and conF ,Π precisely. An edge M (cid:15)⇒ Mgraph ACΠ (conF ,Π ) is singular if:(cid:2)in the• the only transition rule justifying this edge is Unfounded, and• some edge M (cid:15)⇒ M(cid:2)(cid:2)can be justified by a transition rule other than Unfounded or Decide.It is easy to see that due to priorities of acsolver and clingcon, singular edges are inessential. Indeed, given that Unfoundedis assigned lowest priority, the singular edges will never be followed as other transitions such as Unit Propagate are available(see the second condition of the definition of a singular edge).We define AC−Π (con−F ,Π ) as the graph obtained by removing all singular edges from ACΠ (conF ,Π ).Proposition 9. For a friendly AC program Π , the graphs AC−Π and con−Comp(Π ξ ),Πare equal.It follows that the graph con−also provides an abstract model of acsolver. Hence the difference betweenabstract acsolver and basic clingcon algorithms can be stated in terms of difference in Π -safe formulas Comp(Π ξ ) andED-Comp(Π ξ ) that they are applied to.Comp(Π ξ ),Π7.2. The conlF ,Π graphThe clingcon algorithm incorporates backjumping and learning, modern techniques of dpll-like procedures. Nieuwen-huis et al. [15] provide comprehensive description of these techniques. We start by briefly describing the main ideas behindthem. We then proceed to defining the graph conlF ,Π that will allow us to model the clingcon algorithm featuring back-jumping and learning.Consider a state(12)1 . . . l(cid:6)n Mn,M0l(cid:6)1 . . . l(cid:6)where l(cid:6)n are the only decision literals. We say that all the literals of each li Mi belong to decision level i. Consider astate of the form (12) such that the transition rule Backtrack is applicable to it. It is easy to see that the rule Backtrack hasan effect of backtracking from decision level n to level n − 1. At times, it is safe to backtrack to a decision level prior ton − 1. This process is called backjumping.Learning technique is responsible for augmenting the database of given clauses or logic rules in the hope that newlyacquired information is instrumental in future search. This technique proved to be of extreme importance to the success ofmodern SAT and ASP technology.We now define the graph conlF ,Π . To accommodate the fact that this graph has to capture learning, we introduce thenotion of an augmented state that includes not only currently assigned literals but also of “learned information”. Suchlearned information corresponds to newly derived constraints that become available for future propagations. In case ofclingcon these constraints are represented as clauses. We say that a regular program Π entails a clause C when for eachis an answer set for Π , then M |(cid:15) C . For instance, any regular programconsistent and complete set M of literals, if Mentails each rule (understood as a clause) occurring in it. For an AC program Π and a set F of clauses, an augmented staterelative to F and Π is either a distinguished state ⊥ or a pair M||Γ where M is a record relative to the set At(F ∪ Π ξ ) ∪At(ΠD )R , and Γ is a set of clauses over At(F ∪ Π ξ ) ∪ At(ΠD )R such that F |(cid:15) Γ or Π ξ |(cid:15) Γ .For an AC program Π and a set F of clauses, the nodes of conlF ,Π are the augmented state relative to F and Π . The rules(cid:2)||Γ (M||Γ (cid:15)⇒ ⊥, respectively)Decide, Unfounded, and Fail of sm(asp)F ,Π are extended to conlF ,Π as follows: M||Γ (cid:15)⇒ M+Y. Lierler / Artificial Intelligence 207 (2014) 1–2213Unit Propagate Learn:(cid:7)M||Γ (cid:15)⇒ M l||Γ ifBackjump:P l(cid:6) Q ||Γ (cid:15)⇒ Pl(cid:2)||Γ ifC ∨ l ∈ F ∪ Π ξ cl ∪ Γ andC ⊆ M(cid:6)P l(cid:6) Q is inconsistent and(cid:2) ∨ P(cid:2) ∨ P or Π ξ |(cid:15) lF |(cid:15) lLearn:M||Γ (cid:15)⇒ M||C, Γ if⎧⎨⎩every atom in C occurs in F or Π ξ ,F |(cid:15) C or Π ξ |(cid:15) C, andC /∈ Γ.Fig. 4. The additional transition rules of the graph conlF ,Π .(M (cid:15)⇒ ⊥) is an edgeis an edge in conlF ,Π justified by Decide or Unfounded (Fail, respectively) if and only if M (cid:15)⇒ Min sm(asp)F ,Π justified by Decide or Unfounded (Fail, respectively). The other transition rules of conlF ,Π are presented inFig. 4. The transition rule Backjump describes the essence of backjumping procedure that replaces backtracking. The ruleLearn captures the essence of learning in terms of hybrid constraint answer set solvers exemplified by clingcon. The ruleUnit Propagate Learn is a modification of the transition rule Unit Propagate in conF ,Π . This modification addresses the effectof learning. Indeed, this unit propagate derives atoms not only from given F and Π (that are identical in all sets of states inconlF ,Π ), but also from a set of learnt clauses Γ that depends on a particular state in conlF ,Π . We refer to the transition, Backjump, Decide, and Fail of the graph sml(asp)rules Unit Propagate Learn, UnfoundedF ,Π as basic. We say that a node inthe graph is semi-terminal if no rule other than Learn is applicable to it. We omit the word “augmented” before “state” whenthis is clear from a context.(cid:2)(cid:2)The graph conlF ,Π can be used for deciding whether a weakly-simple AC program Π has a model in the followingsense.Proposition 10. For any weakly-simple AC program Π and a Π -safe set F of clauses,(a) every path in conlF ,Π contains only finitely many edges justified by basic transition rules,+(b) for any semi-terminal state M||Γ of conlF ,Π reachable from ∅||∅, (Mξ −)R∩ At(Π) is the set of all regular atoms in some answerset of Π ,(c) state ⊥ is reachable from ∅||∅ in conlF ,Π if and only if Π has no answer sets.On the one hand, Proposition 10(a) asserts that if we construct a path from ∅||∅ so that basic transition rules periodicallyappear in it then some semi-terminal state is eventually reached. On the other hand, parts (b) and (c) of Proposition 10assert that as soon as a semi-terminal state is reached the problem of deciding whether Π has an answer set is solved.In other words, Proposition 10 shows that the graph conlF ,Π gives rise to a class of correct algorithms for computinganswer sets for weakly-simple AC programs. It gives a proof of correctness to every CASP solver in this class and a proof oftermination under the assumption that basic transition rules periodically appear in a path constructed from ∅||∅.Nieuwenhuis et al. [15] proposed transition rules to model such techniques as forgetting and restarts. The graph conlF ,Πcan easily be extended with such rules.7.3. clingcon algorithmThe algorithm behind clingcon is modeled by means of the graph conlED-Comp(Π ξ ), Π with the following prioritiesBackjump(Learn), Fail (cid:20) Unit Propagate Learn (cid:20) UnfoundedQuery Propagate (cid:20) Decide.(cid:2) (cid:20)By Backjump(Learn) we denote the fact that learning occurs in clingcon every time backjump occurs. Proposition 10 demon-strates that the clingcon algorithm is applicable not only to clingcon programs but also to a broader class of weakly-simpleAC programs.8. The EZCSP language and algorithm−language. ezcsp restricts the ACBalduccini [4] demonstrated that the ezcsp language may be seen as a subset of the AC language. In fact, it is a subsetof the ACby requiring that constraint atoms occur only in the rules whose head issymbol ⊥. Theezcsp system is based on loose coupling of answer set solvers, e.g., smodels or clasp, and constraint logicprogramming systems, e.g., sicstus Prolog. The system ezcsp treats a given program as a regular program (with slightmodifications accounting for the special treatment of constraint atoms) and allows an answer set solver to find an answerset. This answer set is used to form a query that is then processed by a constraint logic programming system. This processmay be repeated. To make these ideas precise we may model the system ezcsp that couples the answer set solver smodels−14Y. Lierler / Artificial Intelligence 207 (2014) 1–22and sicstus Prolog using the graph ACΠ . The ezcsp algorithm selects edges according to the priorities on the transitionrules of AC Π as follows:Backtrack, Fail (cid:20)Unit Propagate, All Rules Cancelled, Backchain True (cid:20)Unfounded (cid:20) Decide (cid:20) Query Propagate⊥.Note that this set of priorities highlights the difference between acsolver and ezcsp (based on smodels) as the differencein priorities on the transitions that the systems follow. Indeed, ezcsp always follows the transition Decide prior to exploringthe transition due to Query Propagate.Similarly, we can use the graph conlF ,Π to capture the ezcsp algorithm based on the answer set solver clasp. It willdemonstrate that the difference between clingcon and ezcsp (based on clasp) roots in the same place as the difference be-tween acsolver and ezcsp. Theezcsp selects edges according to the priorities on the transition rules of conlED-Comp(Π ξ ), Πas follows:Backjump(Learn), Fail (cid:20)Unit Propagate Learn (cid:20)Unfounded(cid:2) (cid:20) Decide (cid:20) Query Propagate⊥.ezcsp always follows the transition Decide prior to exploring the transition due to Query Propagate. Furthermore, unlikeclingcon which allows Query Propagate to propagate new atoms ezcsp uses only limited version of this transition rule, inparticular Query Propagate⊥. In other words, ezcsp may only conclude that constraint atoms of a program are conflicting butnot able to derive any inferences from it.9. Conclusions, discussions, and future workWe started this paper by listing a number of CASP languages and systems acsolver, clingcon, ezcsp, idp, inca, and mingothat recently have come into use as an attempt to broaden the applicability of automated reasoning methods. Distinguishingfeature of such CASP solvers as acsolver, clingcon, ezcsp is combining the inferences stemming from traditionally differentresearch fields. This general interest towards hybrid solving illustrates the importance of developing synergistic approachesin the automated reasoning community. A clear picture of the distinguishing features of CASP-like languages and underlyingsystems is of importance in order to facilitate further developments of the field. This is the prime focus of this work that(a) formally states the relation between the CASP languages of acsolver, clingcon, and ezcsp and (b) provides a systematicaccount on the algorithmic differences between the underlying solvers. For example, one take home lesson is that thelanguages of clingcon and ezcsp are the syntactic variants of AC. Another lesson is that despite all the technologicaldifferences in the newly developed solvers such as acsolver, clingcon, and ezcsp they have a lot in common. This alludesto a possibility of creating a general-purpose platform that would assist the creation of new architectures of CASP-liketechnology.−To summarize the technical contributions of this paper: we demonstrated a formal relation between the AC and clingconlanguages and the algorithms behind acsolver and clingcon. We designed transition systems ACΠ and conlF ,Π for describ-ing algorithms for computing (subsets of) answer sets of weakly-simple AC programs. We used these graphs to specify theacsolver, clingcon and ezcsp algorithms. Compared with traditional pseudocode descriptions of algorithms, transition sys-tems use a more uniform (i.e., graph-based) language and offer more modular proofs. The graphs ACΠ and conF ,Π offera convenient tool to describe, compare, analyze, and prove correctness for a class of algorithms. In fact we formally showthe relation between the subgraphs of ACΠ and conF ,Π , namely that the graphs ACComp(Π),Π are equal. Further-more, the transition systems for acsolver and clingcon result in new algorithms for solving a larger class of AC programs– weakly-simple programs introduced in this paper. Neither the acsolver nor clingcon systems, respectively, can deal withsuch programs. In the future we will consider ways to use current ASP/CLP technologies to design a solver for weakly-simpleprograms. Work by Balduccini et al. [33] is a step in that direction.Π and con−−In the future we would like to uncover the precise relationship with idp, and the translational solvers introduced in[8–10]. The idp language builds on top of the formalism called PC(ID) [34] that is strongly related to logic programs underanswer set semantics [32]. As of this point there is no formal account describing the insides of the idp system support-ing a CASP language. The translational solvers developed in [8,9] rely on transformations from a CASP language to an ASPformalism. A graph underlying an ASP solver (for instance, sml(asp)F ,Π for the case of clasp [32]) applied to a transfor-mation devised in [8,9] can be used to characterize such a solver. Even though we introduced similar graphs, ac and conl,for capturing hybrid solvers these graphs are not appropriate to formally compare translational and hybrid solvers. Thetransition rule Query Propagate of AC and conl is too crude to capture the details of solving that occurs on the side ofspecialized solvers (such as gecode or sicstus Prolog). To point at exact differences between a translational solver and itshybrid counterpart the computation done in a specialized solver has to be unfolded. The mingo solver [10] implementsCASP by translating its programs into integer linear programs. It is an interesting direction of research to study how thetechnology of integer linear programming compares to the technology of ASP and CASP.Y. Lierler / Artificial Intelligence 207 (2014) 1–2215AcknowledgementsWe are grateful to Yuanlin Zhang, Daniel Bailey, Marcello Balduccini, Broes de Cat, Michael Gelfond, Vladimir Lifschitz,Max Ostrowski, Peter Schueller, and Miroslaw Truszczynski for useful discussions related to the topic of this work as wellas their comments on earlier drafts of the paper. We are in debt to the reviewers of the paper for their valuable feedbackthat allowed to improve the presentation.Appendix A. Proofs of formal resultsWe start by introducing the necessary terminology used in [1].A consistent set S of ground atoms over the signature Σ is called a partial interpretation of an AC program Π if it satisfiesthe following conditions:1. A constraint atom l ∈ S iff l is true under its intended interpretation;2. The mixed atoms of S form the functional set w.r.t. the signature of Π .The definition of semantics of AC program follows [1]. By replacing “nested program” with “ground AC program”, thedefinition of reduct in Section 2 is trivially extended to ground AC programs. A partial interpretation S of Σ is an acc-answerset of an AC program Π if S is minimal (in the sense of set-theoretic inclusion) among the partial interpretations of Σsatisfying the rules of (ground(Π) ∪ M)S , where M is the set of all mixed atoms occurring in S. We note that this is ageneralization of the answer set definition presented in [1] to the case of programs with doubly negated atoms.Proposition 1. For an AC program Π over signature Σ and the set T of all true ground constraint literals over Σ , X is an answer setof Π if and only if X ∪ T is an answer set (in the sense of [1]) of Π .Proof. Left-to-right: Let X be an answer set of Π . By definition, there is a functional set M of ground mixed atoms such∗(Π) ∪ M, i.e., minimal among sets of atoms satisfyingthat X is an answer set of ground(cid:4)(cid:4)ground∗(Π) ∪ M(cid:5)X(cid:5)cl.(13)Obviously, M forms the set of all mixed atoms occurring in X .Let the set Y of atoms be any model of (13). It is easy to see that (i) Y ∪ T is a partial interpretation, and (ii) Y ∪ Tsatisfies(cid:4)(cid:4)ground(Π) ∪ M(cid:5)X∪T(cid:5)cl.(14)Indeed, from the construction of (13) and (14) it immediately follows that we obtain (13) from (14) by replacing everyatom from T with (cid:5). Thus Y ∪ T satisfies (14) iff Y satisfies (13). It follows that X ∪ T is a minimal partial interpretationsatisfying (14) (since X is minimal among sets of atoms satisfying (13)) and hence is an acc-answer set of Π .Right-to-left: Let X ∪ T be an acc-answer set of Π . By M we denote the set of all mixed atoms occurring in X .Let Y ∪ T be any partial interpretation satisfying (14). Using the argument from left-to-right direction we derive that Y isa model satisfying (13). From the fact that X ∪ T is a minimal partial interpretation satisfying (14) (i.e., it is an acc-answerset of Π ) it follows that X is a minimal model satisfying (13). (cid:2)A splitting set [35] for a nested program Π is any set U of atoms such that, for every rule r ∈ Π , if Head(r) ∩ U thenAt(r) ∈ U . The set of rules r ∈ Π such that At(r) ∈ U is called a bottom of Π relative to the splitting set U and denotedby bU (Π). The set Π \ bU (Π) is the top of Π relative to U . By eU (Π, X), we denote the program consisting of all rulesobtained from Π by replacing an atom a in U , if a ∈ X with (cid:5) and ⊥ otherwise.Proposition 11 (Splitting set theorem). (See [35].) Let U be a splitting set for a nested program Π . A set A of atoms is an answer setfor Π iff A = X ∪ Y where X is an answer set for bU (Π) and Y is an answer set for eU (Π \ bU (Π), X).For a set M of ground mixed atoms over Σ , by ˜M we denote the following set of atoms{m | m is a ground mixed atom over Σ, m /∈ M},i.e., the set consisting of all ground mixed atoms over Σ that are not in M.Observation 1. A set of atoms is an answer set of nested program Π if and only if it is an answer set of the regular program constructedfrom Π by16Y. Lierler / Artificial Intelligence 207 (2014) 1–22• dropping the rules where ⊥ occurs in Bpos ∪ Bneg2 and (cid:5) occurs in Bneg,• dropping (cid:5), not ⊥, and not not (cid:5) from the rest of the rules.This observation is due to equivalent transformations on programs with nested expressions [24].Proposition 2. For a clingcon program Π over signature Σ , a set X is a constraint answer set of Π according to the definition in [2,3]iff there is a functional set M of ground mixed atoms of Σ such that X ∪ M is an answer set of ac(Π).Proof. It is easy to see that ac(Π) is a super-safe program (by its construction and function V definition).Left-to-right: Let X be a constraint answer set of Π according to the definition in [2]. Then there is an assignment A :V [Π] → D[Π] such that X is an answer set of Π A defined in [2], where V [Π] denotes the set of all clingcon variablesoccurring in Π and D[Π] is a set of constraint constants. For a clingcon variable c in Π , by A(c) we denote a constraintconstant assigned by A to c. Let us construct a substitution γ using A as follows: for each clingcon variable c in Π addc V / A(c) to γ .For a clingcon variable p((cid:9)r) by p((cid:9)r)M we denote a mixed atom p((cid:9)r, p((cid:9)r)V ). We say that such mixed atom is matching forp((cid:9)r). Let S denote the set of matching mixed atoms constructed from all the clingcon variables occurring in Π . It is easy tosee that Sγ is a functional set of ground mixed atoms. Let M be Sγ . We now show that X ∪ M is an answer set of ac(Π).By the definition, X ∪ M is an answer set of ac(Π) if X ∪ M is an answer set of∗(cid:4)(cid:5)ac(Π)∪ M.groundBy Proposition 11, X ∪ M is an answer set of (15) iff X is an answer set of∗(cid:4)(cid:5)ac(Π).ground(15)(16)The transformation described in Observation 1 applied to (16) will result in Π A . We are given that X is an answer setof Π A . Consequently, it is an answer set of (16).Right-to-left: Let M be a functional set of ground atoms of Σ and X be a set of ground atoms such that X ∪ M is ananswer set of ac(Π). Let V [Π] denote the set of all clingcon variables occurring in Π . From the fact that M is a functionalset it follows that for every variable p((cid:9)r) ∈ V [Π] there is an atom of the form p((cid:9)r, c) in M. We can construct an assignmentA for V [Π] as follows: for every variable p((cid:9)r) ∈ V [Π], A(p((cid:9)r)) = c where p((cid:9)r, c) ∈ M.By the definition of an answer set for an AC program, X ∪ M is an answer set of (15). Furthermore, by Proposition 11,X is an answer set of (16). From Π A construction and it follows that the transformation described in Observation 1 appliedto (16) will result in Π A . We are given that X is an answer set of Π A . Consequently, X is an answer set of Π A and thereforea constraint answer set of Π . (cid:2)Proposition 3. For any safe AC program Π , there is a transformation on Π that produces a super-safe AC program which has sameanswer sets as Π .Proof. In this proof, (cid:9)c always denotes a sequence of regular constants, and m denotes a mixed predicate.Let T denote the following transformation.For each sequence of constants (cid:9)c and each m such that (cid:9)c is specified by mAssociate a unique new variable with (cid:22)m, (cid:9)c(cid:23) denoted by Y (cid:22)m,(cid:9)c(cid:23);For each rule r of Π(cid:2)Let rbe the same as r;For each variable X of rLet m1((cid:9)c1, X), . . . , mk((cid:9)ck, X) be the mixed atoms of rReplace mi( (cid:9)ci, X) in rwith mi( (cid:9)ci, Y (cid:22)mi , (cid:9)ci (cid:23)) for i ∈ 1..k;Add Y (cid:22)m1, (cid:9)c1(cid:23) = · · · = Y (cid:22)mi , (cid:9)ci (cid:23) to r;Replace each occurrence of X in r(cid:2)(cid:2)(cid:2)by Y (cid:22)m1, (cid:9)c1(cid:23).Let Π (cid:2)be the new program produced by the transformation T . It is easy to see that Π (cid:2)as a unique new variable is associated with every pair (cid:22)m, (cid:9)c(cid:23) and Π (cid:2)of super-safe program.is indeed a super-safe programis constructed from Π to preserve the requirementsTo prove that Π and Π (cid:2)∗set of ground∗Proposition 11, it follows that a set X of atoms is an answer set of groundhave the same answer sets, let M be any functional set. It is easy to see that˜M is a splitting(Π (cid:2)) ∪ M, where the bottom of both programs is formed by empty set of rules. By(Π) ∪ M (thus, of Π ) iff X is an answer set of∗(Π) ∪ M and ground(cid:4)e ˜Mground∗(Π) ∪ M, X(cid:5).(17)∗Similarly, X is an answer set of ground∗(cid:4)(cid:4)(cid:5)(cid:5)(cid:2)e ˜MgroundΠ∪ M, X.Y. Lierler / Artificial Intelligence 207 (2014) 1–22(Π (cid:2)) ∪ M (thus, of Π (cid:2)) iff it is an answer set of17(18)It is easy to see that the transformation described in Observation 1 applied to (17) and (18) results in the same program.Thus any set X of atoms is an answer set of Π iff it is an answer set of Π (cid:2). (cid:2)Proposition 4 is proved in the same spirit as Proposition 2.We refer the reader to [30] for the review of operator S M but we state several formal results from [30] and [26] in theform convenient for our presentation.Proposition 12 (Special case of Theorem 1). (See [30].) For any nested program Π and a complete set X of literals over At(Π), thefollowing conditions are equivalent+is an answer set of Π ,• X• X is a p-stable model [30], where p is the list of all predicate symbols in Π (i.e., X is a model of SMp[Π]).Proposition 13 (Special case of Symmetric Splitting Theorem). (See [26].) Let Π and Π (cid:2)tuples of distinct predicate symbols. Ifbe nested programs and let p, q be disjoint• each strongly connected component of predicate dependency graph of Π ∪ Π (cid:2)• no atom with predicate symbols in q occurs in any head in Π ,• no atom with predicate symbols in p occurs in any head in Π (cid:2),is a subset of p or a subset of q,then SMpq[Π ∪ Π (cid:2)] is equivalent to SMp[Π] ∧ SMq[Π (cid:2)].For a set A of atoms by pred( A) we denote the set of predicate symbols of atoms in A. We will sometime abuse thenotation and use pred(Π) to denote the set of predicate symbols occurring in program Π .Proposition 6. For a nested program Π , a complete set X of literals, and a set p of predicate symbols such that predicate symbolsoccurring in the heads of Π form a subset of p (i.e., pred(Heads(Π)) ⊆ p), Xis a p-input answer set of Π iff X is a model of S Mp[Π](i.e., p-stable model of Π ).+Proof. By the definition, Xan answer set of Π ∪ X+(p) iff X is a model ofis a p-input answer set of Π iff X+SMpred(Π ) pred( X +(p))(cid:11)Π ∪ X+(cid:12)(p).From the fact that pred(Heads(Π)) ⊆ p, it follows that+X(p) ∩ Heads(Π) = ∅,+is an answer set of Π ∪ X+(p). By Proposition 12, X+is(19)so that atoms with predicate symbols different from p occur in the heads only of the facts of XProposition 13, (19) is equivalent to+(p). Consequently, bySMpred(Π )[Π] ∧ SMpred( X +(p))(cid:11)(cid:12)(p).+X(20)Obviously, set X is a model of the second conjunct of (20). We derive that X is a model of (20) iff X is a model ofSMpred(Π)[Π]. Recall that pred(Heads(Π)) ⊆ p. By Proposition 13, the following expressions are equivalent• SMpred(Π)[Π],• SMpred(Heads(Π))[Π],• SMp[Π]. (cid:2)Weakly-simple AC programs satisfy important syntactic properties that allow to characterize their answer sets by meansof queries based on them. The proof of Proposition 7 relies on this alternative characterization that we make precise inLemma 1. To state the lemma we introduce several concepts that we rely on in the proof.For an AC program Π , we say that a query Q is based on Π if it is a complete and consistent set of literals overAt(ΠD )R ∪ At(ΠR )D,C . If Q is a satisfying extension of itself, then there is a substitution γ of variables in Q by groundterms such that the result, Q γ , satisfies the conditions 1 and 2 of the definition of satisfying extension. We say that Q γ isan interpretation of Q . We call such queries satisfiable (i.e., queries that are satisfying extensions).18Y. Lierler / Artificial Intelligence 207 (2014) 1–22For an AC program Π and a query Q based on Π , by Π(Q ) we denote a program constructed from Π by1. eliminating ΠD ,2. dropping removing each occurrence of a mixed atom,3. replacing an atom a by (cid:5) if a ∈ Q D,C ,4. replacing an atom a by ⊥ if ¬a ∈ Q D,C ,5. for each regular literal l ∈ Q R adding a rule• ← not l if l is an atom, and• ← a if l is a literal ¬a.It is easy to see that for a query Q based on an AC program Π , Π(Q ) is a nested program. For instance, let Π beprogram (4). A query Q consisting of literals(cid:2)on, okTime(T ), T (cid:10)= 1(cid:3)is based on Π . Program Π(Q ) follows← occurs(a, 0), (cid:5), not (cid:5)occurs(a, 0) ←{on}← not on.Let Q 1 be a query based on Π consisting of literals(cid:2)on, ¬okTime(T ), T (cid:10)= 1(cid:3).Program Π(Q ) follows← occurs(a, 0), (cid:5), not ⊥occurs(a, 0) ←{on}← not on.An expression is a term, an atom, or a rule. Given a substitution Θ and an expression e, we write eΘ for the result ofreplacing v i in e by ti for every i (cid:2) n.Recall that for a set S of literals, by S R , S D , and S C we denote the set of regular, defined, and constraint literals occurringin S respectively. By SMix we denote a set of mixed literals occurring in S.We call a rule (1) with a0 = ⊥ a constraint.Lemma 1. For a weakly-simple AC program Π , Π has an answer set iff there is a query Q based on Π such that Q is satisfiable w.r.t.+Π and Π(Q ) has an answer set. Furthermore, if I is a query interpretation for Q w.r.t. Π and X is an answer set of Π(Q ) then X ∪ IDis a subset of some answer set of Π such that X is the set of all regular atoms in it.Proof. Left-to-right: Assume that Π has an answer set. Let S be a complete and consistent set of ground11 literals over Σis an answer set of Π . By the definition of an answer set, there exists a functional set M of ground mixedsuch that Satoms over Σ such that S∗is an answer set of the nested program ground(Π) ∪ M.++It is sufficient to construct a satisfiable query based on Π such that Π(Q ) has an answer set. We start by constructinga query Q based on Π using S. Then we demonstrate that(i) this Q is satisfiable w.r.t. Π , and(ii) Π(Q ) has an answer set.Let ΠMix be a subset of ΠR that consists of all rules in ΠR whose bodies contain mixed, defined, or constraint literals.Since Π is a weakly-simple program and every weakly-simple program is safe, it follows that each rule in ΠMix containsa mixed atom. From the fact that M is a functional set of mixed atoms and Π is a weakly-simple program and hencesuper-safe (see conditions 1 and 2), it follows that for each rule r in ΠMix there is a substitution Θ such that rΘ ∈ ground(Π)so that every mixed atom m occurring in rΘ also occurs in M; furthermore, there is no substitution Θ (cid:2)different from Θsuch that every mixed atom m occurring in rΘ (cid:2)also occurs in M. Let us denote such rule rΘ that corresponds to r inground(Π) by r(ground(Π), M).11 We will sometimes omit the word “ground”, when it is clear from the context.We now construct a query Q as follows:Y. Lierler / Artificial Intelligence 207 (2014) 1–22191. Let Q contain every regular literal in S R whose atom occurs in ΠD .2. For each rule r in ΠMix, so that by Ξ we denote the substitution such that rΞ = r(ground(Π), M), let Q contain(a) defined atom d, if d occurs in r and dΞ ∈ S(b) defined literal ¬d, if atom d occurs in r and dΞ ∈ S(c) constraint atom c, if c occurs in r and cΞ is true under intended interpretation of its symbols,(d) constraint literal ¬c, if c occurs in r and cΞ is false under intended interpretation of its symbols.−D ,+D ,From the query Q construction (and the fact that ΠMix consists of all rules in ΠR whose bodies contain mixed, defined, orconstraint literals) it immediately follows that Q is based on Π . Let γ be the union of Ξ for each rule r in ΠMix such thatΞ is the substitution so that rΞ = r(ground(Π), M). From the fact that Π is a weakly-simple program and hence super-safeand the choice of Ξ that relies on a functional set M of mixed atoms it follows that γ is also a substitution.In order to demonstrate (i) and (ii) we introduce the following notation and state additional observations. By R(Π),D(Π), Mix(Π) we denote the set of regular, defined, and mixed predicates of Π respectively. From Propositions 12, 13 and+the fact that Π is a weakly-simple program it follows that Sis an answer set of Π iff S is a model ofSMR(Π )Mix(Π )(cid:11)ground∗(ΠR ) ∪ M(cid:12)∧ SMD(Π )(cid:11)ground∗(cid:12)(ΠD ).(21)Consequently, S is a model of(cid:11)(cid:12)(ΠD )SMD(Π )∗.ground+By Proposition 6, SD(Π). This constitutes observation (a).∗is an input answer set of ground(ΠD ) w.r.t. D(Π). Hence, S+is an input answer set of ΠD w.r.t.Similarly, S is a model ofSMR(Π ) Mix(Π )(cid:11)ground∗(ΠR ) ∪ M(cid:12).(22)Furthermore, from Proposition 13, (22), and the fact that mixed atoms appear in the heads only in facts in M, it followsthat S is a model of(cid:11)SMR(Π )ground∗(cid:12)(ΠR ).By Proposition 6, S+∗is an input answer set of ground(ΠR ) w.r.t. R(Π). This constitutes observation (b).(i) We now show that Q γ is a query interpretation for a query Q w.r.t. Π . From the Q construction (see conditions 2(c)and 2(d)) it follows that if a constraint literal l ∈ Q γ then l is true under the intended interpretation of its symbols. It is leftto show that there is an input answer set A of ΠD w.r.t. defined predicates of Π , so that Q γ +∩ A = ∅:R,DLet A be Sand recall observation (a) and the construction of Q (see conditions 2(a) and 2(b)).⊆ A and Q γ −R,D+(ii) We now show that Π(Q ) has an answer set. Recall observation (b). By the definition of an input answer set, San answer set ofground∗(ΠR ) ∪ S+R(Π ).+isRecall that for a set X of atoms, by Xp we denote the set of atoms in X whose predicate symbols are different from theones occurring in p. It is easy to see that S+Mix. In other words, ground+R(Π) is equal to(ΠR ) ∪ S+R(Π)= S∪ S+D∗∗ground(ΠR ) ∪ S+D+D∪ S∪ S+Mix+Mix.∪ SIt is easy to see that Sthe program constructed from (23) by−Mix is a splitting set of (23). By Proposition 11, S+ \ (S+D∪ S+Mix) is an answer set of(23)−D∪ S• eliminating facts S• replacing atom a by (cid:5) if a ∈ S• replacing atom a by ⊥ if a ∈ S∪ S+Mix,+D+D+D∪ S∪ S+Mix,+Mix.It is easy to see that the transformation described in Observation 1 applied to such program and to Π(Q ) without theconstraints introduced in step 5 of Π(Q ) construction results in the same program. It is easy to see that these constraints++Mix) is an answer set ofare satisfied by SDΠ(Q ). Consequently, it is an answer set of Π(Q ).+Mix). By the Theorem on Constraints [24] it follows that S+ \ (S+ \ (S∪ S∪ S+DRight-to-left: Assume that there is a query Q based on Π such that Q is satisfiable w.r.t. Π and Π(Q ) has an answerset. We show that Π also has an answer set.From the fact that Q is satisfiable it follows that there is an interpretation I for Q w.r.t. Π . By the definition of theinterpretation, there is a substitution γ such that Q γ is I itself.20Y. Lierler / Artificial Intelligence 207 (2014) 1–22By the safety condition on weakly-simple programs, any variable X that occurs in some rule in Π also occurs in somemixed atom in this rule. Let us define a substitution γ (cid:2)as follows: it extends the substitution γ by X/v X for each variableX such that in every rule that X occurs in, it occurs only once; v X is an arbitrary constant of the same sort as X (recall thatsorts are non-empty). By γ (cid:2). Let M be the ground set of mixedatoms At(Π)Mixγ (cid:2), mγ (cid:2) ∈ M). From the fact that Π is a super-safe program it followsthat M is a functional set over Σ .construction, every variable in At(Π)Mix also occurs in γ (cid:2)(i.e., for each atom m ∈ At(Π)Mixγ (cid:2)By the definition of an answer set of an AC program, to demonstrate that Π has an answer set, it is sufficient to showthat∗(Π) ∪ Mground(24)has the answer set. It is obvious that M ∪ ˜M is a splitting set of (24). By Proposition 11, (24) has an answer set iff a programconstructed from (24) by dropping facts M, dropping the rules that contain mixed atoms in ˜M, and removing atoms fromM from the remaining rules. We denote this ground program by [Π, M].By Proposition 12, [Π, M] has an answer set iff there is a model ofSMD(Π ),R(Π )(cid:11)(cid:12)[Π, M].Indeed, D(Π), R(Π) form the set of all predicate symbols of a program. By Proposition 13, (25) is equivalent to(cid:11)[Π, M]R(cid:12)∧ SMD(Π )(cid:11)[Π, M]D(cid:12).SMR(Π )That can be equivalently rewritten as(cid:11)ground∧ SMD(Π )[Π, M]RSMR(Π )(cid:12)(cid:11)∗(cid:12)(ΠD ).(25)(26)Consider a complete and consistent set Y of ground regular literals such that Yis an answer set of Π(Q ). (By ourassumption Y exists.) By the condition 5 of Π(Q ) construction it follows that I R ⊆ Y . By the Theorem on Constraints [24] itconstructed from Π(Q ) by dropping the constraints in Π(Q )follows that Yderived from the condition 5. We now note that the transformation described in Observation 1 applied to Π(Q )(cid:2)results ina program identical to [Π, M]R . We derive that Yis also an answer set of the program Π(Q )(cid:2)is an answer set of [Π, M]R .++++RFrom the fact that I⊆ A, Qis a query an interpretation, it follows that there is an input answer set A of ΠD w.r.t. D(Π)−∩ A = ∅. Furthermore, by Proposition 11, thesuch that (i) QRinput answer set definition and the fact that I R ⊆ Y , it follows that there is a complete and consistent set Z of ground+non-constraint literals over Σ such that Y ⊆ Z , I D ⊆ Z , and Zis an input answer set of ΠD w.r.t. D(Π). By Proposition 6,Z is a model of(cid:11)∩ A = ∅ (note that Q R = I R ), and (ii) I⊆ A, I+D−Dis an answer set of [Π, M]R and Proposition 12, it follows that Y is a model of∗(cid:12)(ΠD )+.SMD(Π )groundFrom the fact that Y(cid:11)(cid:12)SMR(Π )[Π, M]RSince Y ⊆ Z , Z is a model of (28) also..(27)(28)From (27) and (28) we derive that Z is a model of (26). Consequently Π has an answer set. (cid:2)We now establish the relation between answer sets of Π ξ and Π(Q ). For a set M of atoms over Σ , by Mξ we denote aset of atoms over Σ ξ by replacing each constraint and defined literal A occurring in M with a corresponding name Aξ . Forinstance, {T (cid:10)= 1, acceptTime(T )}ξ is(cid:2)T (cid:10)= 1ξ , acceptTime(T )ξ(cid:3).Lemma 2. For a weakly-simple AC program Π , a query Q based on Π , and a set X of atoms over At(Π)R so that Qanswer set of Π(Q ) iff X ∪ (Q+D,C )ξ is an answer set of Π ξ .+R⊆ X , X is anProof. By Π(Q )(cid:2)+D,C )ξ ∪ (Qcondition 5. It is easy to see that set (Qsplitting set) consists of choice rules for each atom occurring in (Q D,C )ξ . It follows that (Qbottom. Let U denote (Qwe denote a program constructed from Π(Q ) by dropping the constraints in Π(Q ) derived from the−D,C )ξ is a splitting set of Π ξ . The bottom part of Π ξ (relevant to this+D,C )ξ is an answer set of theD,C )ξ ) coincides with Π(Q )(cid:2)+D,C )ξ ∪ (QLeft-to-right: Let X be an answer set of Π(Q ). By the Theorem on Constraints [24] it follows that X is also an answer−D,C )ξ . Note that eU (Π ξ \ bU (Π ξ ), (Q+D,C )ξ is an answer set of Π ξ .. By Proposition 11, X ∪ (QD,C )ξ be an answer set of Π ξ . By Proposition 11, it follows that X is an answer set of Π(Q )(cid:2)set of the program Π(Q )(cid:2)Right-to-left: Let X ∪ (Q++..⊆ X the Theorem on Constraints [24] it follows that X is also an answer set for Π(Q ). (cid:2)From the fact that Q+RY. Lierler / Artificial Intelligence 207 (2014) 1–2221Proposition 7. For any weakly-simple AC program Π ,(a) graph ACΠ is finite and acyclic,+(b) for any terminal state M of ACΠ other than ⊥, (Mξ −)R is a set of all regular atoms in some answer set of Π ,(c) state ⊥ is reachable from ∅ in ACΠ if and only if Π has no answer sets.Proof. Part (a) is proved as in the proof of Proposition 1 in [19].(b) Let M be a terminal state. Recall that smset of Π ξ . It is obvious that query(M) forms a query based on Π , and query(M)+(Mξ −)R is an answer set of Π(query(M)). Furthermore, since Query Propagate is not applicable we conclude thatΠ ξ is a subgraph of ACΠ . From Proposition 5, it follows that Mis an answer+⊆ (Mξ −)R . By Lemma 2, it follows that+R+(cid:4)(cid:5)ΠD , query(M)Cons⊆ Mξ −+and therefore it is different from {⊥}. Consequently, query(M) is a satisfiable query. By Lemma 1, (Mξ −)R is a set of allregular atoms in some answer set of Π .(c) Left-to-right: Since ⊥ is reachable from ∅, there is an inconsistent state M without decision literals such that thereexists a path from ∅ to M and M has the form:Case 1. M is of the form l1 . . . ln⊥ . . . . From Lemma 5 in [19], it follows that any answer set of Π ξ satisfies l1 . . . ln. On theother hand, ⊥ appears in M due to the application of the transition rule Query Propagate so that Cons(ΠD , query(l1 . . . ln)) ={⊥}. In other words there exists no satisfying extension of query(l1 . . . ln) w.r.t. ΠD . From Lemmas 2 and 1, it follows thatΠ has no answer sets.Case 2. M is of the form l1 . . . ln where each li is an atom. From Lemma 5 in [19], it follows that any answer set of Π ξsatisfies l1 . . . ln. Since l1 . . . ln is inconsistent we conclude that Π ξ has no answer sets. From Lemmas 2 and 1, it follows thatΠ has no answer sets.Right-to-left: From (a) it follows that there is a path from ∅ to some terminal state. By (b), this state cannot be differentfrom ⊥, because Π has no answer sets. (cid:2)Proposition 14. (See [32, Proposition 5].) Let Π be a regular program. For every Π -safe [32] set F of clauses, a set X of atoms is ananswer set of Π if and only if X = M+ ∩ At(Π), for some model M of [F , Π].Proposition 15. (See [32, Proposition 7].) For any SM(ASP) theory [F , Π],(a) graph sm(asp)F ,Π is finite and acyclic,(b) for any terminal state M of sm(asp)F ,Π other than ⊥, M is a model of [F , Π],(c) state ⊥ is reachable from ∅ in sm(asp)F ,Π if and only if [F , Π] has no models.Proposition 8. For any weakly-simple AC program Π and a Π -safe set F of clauses,(a) graph conF ,Π is finite and acyclic,+(b) for any terminal state M of conF ,Π other than ⊥, (Mξ −)R(c) state ⊥ is reachable from ∅ in conF ,Π if and only if Π has no answer sets.∩ At(Π) is a set of all regular atoms in some answer set of Π ,Proof. The proof of this proposition follows the lines of the proof of Proposition 7 relying on Propositions 14 and 15. (cid:2)Proposition 9. For a friendly AC program Π , the graphs AC−Π and con−Comp(Π ξ ),Πare equal.Proof. The proof of this proposition immediately follows Proposition 8 in [32] and the fact that graphsAC−Π and con −Comp(Π ),Πdiffer fromsm−Π andsm(asp)−Comp(Π ),Πgraphs, respectively, by the same transition rule Query Propagate. (cid:2)Proof of Proposition 10 follows the lines of the proof of Proposition 7, Proposition 14, and Proposition 9 in [32].22ReferencesY. Lierler / Artificial Intelligence 207 (2014) 1–22[1] V.S. Mellarkod, M. Gelfond, Y. Zhang, Integrating answer set programming and constraint logic programming, Ann. Math. Artif. Intell. 53 (2008)251–287.[2] M. Gebser, M. Ostrowski, T. Schaub, Constraint answer set solving, in: Proceedings of 25th International Conference on Logic Programming (ICLP),Springer, 2009, pp. 235–249.[3] M. Ostrowski, T. Schaub, Asp modulo csp: The clingcon system, Theory and Practice of Logic programming, Theory Pract. Log. Program. 12 (2012)485–503.[4] M. Balduccini, Representing constraint satisfaction problems in answer set programming, in: Proceedings of ICLP Workshop on Answer Set Program-ming and Other Computing Paradigms (ASPOCP), 2009, https://www.mat.unical.it/ASPOCP09/.[5] J. Wittocx, M. Mariën, M. Denecker, The idp system: a model expansion system for an extension of classicalin: Proceedings ofWorkshop on Logic and Search, Computation of Structures from Declarative Descriptions (LaSh), 2008, pp. 153–165 (electronic), available athttps://lirias.kuleuven.be/bitstream/123456789/229814/1/lash08.pdf.logic,[6] I. Elkabani, E. Pontelli, T.C. Son, Smodels with clp and its applications: A simple and effective approach to aggregates in asp, in: B. Demoen, V. Lifschitz(Eds.), ICLP, in: Lect. Notes Comput. Sci., vol. 3132, Springer, 2004, pp. 73–89.[7] S. Baselice, P.A. Bonatti, M. Gelfond, Towards an integration of answer set and constraint solving, in: M. Gabbrielli, G. Gupta (Eds.), ICLP, in: Lect. NotesComput. Sci., vol. 3668, Springer, 2005, pp. 52–66.[8] C. Drescher, T. Walsh, Translation-based constraint answer set solving, in: Proceedings of the 22nd International Joint Conference on Artificial Intelli-gence (IJCAI), AAAI Press, 2011, pp. 2596–2601.[9] C. Drescher, T. Walsh, A translational approach to constraint answer set solving, Theory and Practice of Logic programming, Theory Pract. Log. Program.10 (2011) 465–480.[10] G. Liu, T. Janhunen, I. Niemelä, Answer set programming via mixed integer programming, in: Principles of Knowledge Representation and Reasoning:Proceedings of the 13th International Conference, AAAI Press, 2012, pp. 32–42.[11] I. Niemelä, P. Simons, Extending the Smodels system with cardinality and weight constraints, in: J. Minker (Ed.), Logic-Based Artificial Intelligence,Kluwer, 2000, pp. 491–521.[12] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Conflict-driven answer set solving, in: Proceedings of 20th International Joint Conference on ArtificialIntelligence (IJCAI’07), MIT Press, 2007, pp. 386–392.[13] C. Schulte, P.J. Stuckey, Efficient constraint propagation engines, Trans. Program. Lang. Syst. (2008).[14] M. Davis, G. Logemann, D. Loveland, A machine program for theorem proving, Commun. ACM 5 (7) (1962) 394–397.[15] R. Nieuwenhuis, A. Oliveras, C. Tinelli, Solving SAT and SAT modulo theories: From an abstract Davis–Putnam–Logemann–Loveland procedure toDPLL(T), J. ACM 53 (6) (2006) 937–977.[16] T. Eiter, G. Brewka, M. Dao-Tran, M. Fink, G. Ianni, T. Krennwallner, Combining nonmonotonic knowledge bases with external sources, in: S. Ghilardi, R.Sebastiani (Eds.), 7th International Symposium on Frontiers of Combining Systems (FroCos 2009), in: Lecture Notes in Artificial Intelligence, vol. 5749,Springer, 2009, pp. 18–42.[17] T. Eiter, G. Ianni, R. Schindlauer, H. Tompits, A uniform integration of higher-order reasoning and external evaluations in answer set programming, in:Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), Professional Book Center, 2005, pp. 90–96.[18] G. Brewka, T. Eiter, Equilibria in heterogeneous nonmonotonic multi-context systems, in: Proceedings of National Conference on Artificial Intelligence(AAAI), AAAI Press, 2007, pp. 385–390.[19] Y. Lierler, Abstract answer set solvers, in: Proceedings of International Conference on Logic Programming (ICLP), Springer, 2008, pp. 377–391.[20] Y. Lierler, Abstract answer set solvers with backjumping and learning, Theory Pract. Log. Program. 11 (2011) 135–169.[21] Y. Lierler, Y. Zhang, A transition system for AC language algorithms, in: Proceedings of ICLP Workshop on Answer Set Programming and Other Com-puting Paradigms (ASPOCP), 2011, http://www.dbai.tuwien.ac.at/proj/aspocp11/accepted.html.[22] Y. Lierler, On the relation of constraint answer set programming languages and algorithms, in: Proceedings of the AAAI Conference on ArtificialIntelligence, MIT Press, 2012.[23] A. Kakas, R. Kowalski, F. Toni, Abductive logic programming, J. Log. Comput. 2 (1992) 719–770.[24] V. Lifschitz, L.R. Tang, H. Turner, Nested expressions in logic programs, Ann. Math. Artif. Intell. 25 (1999) 369–389.[25] P. Ferraris, V. Lifschitz, Weight constraints as nested expressions, Theory Pract. Log. Program. 5 (2005) 45–74.[26] P. Ferraris, J. Lee, V. Lifschitz, R. Palla, Symmetric splitting in the general theory of stable models, in: Proceedings of International Joint Conference onArtificial Intelligence (IJCAI), IJCAI Press, 2009, pp. 797–803.[27] P. Simons, Extending the stable model semantics with more expressive rules, in: Logic Programming and Non-monotonic Reasoning: Proceedings FifthInt’l Conf., in: Lecture Notes in Artificial Intelligence, vol. 1730, Springer, 1999, pp. 305–316.[28] A. Van Gelder, K. Ross, J. Schlipf, The well-founded semantics for general logic programs, J. ACM 38 (1991) 620–650.[29] J. Lee, A model-theoretic counterpart of loop formulas, in: Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), ProfessionalBook Center, 2005, pp. 503–508.[30] P. Ferraris, J. Lee, V. Lifschitz, Stable models and circumscription, Artif. Intell. 175 (2011) 236–263.[31] K. Clark, Negation as failure, in: H. Gallaire, J. Minker (Eds.), Logic and Data Bases, Plenum Press, New York, 1978, pp. 293–322.[32] Y. Lierler, M. Truszczynski, Transition systems for model generators — a unifying approach, in: 27th Int’l. Conference on Logic Programming (ICLP’11),Theory Pract. Log. Program. Special Issue 11 (2011) 629–646.[33] M. Balduccini, Y. Lierler, P. Schueller, Prolog and ASP inference under one roof, in: Proceedings of 12th International Conference on Logic Programmingand Nonmonotonic Reasoning, Springer, 2013, pp. 148–160.[34] M. Mariën, J. Wittocx, M. Denecker, M. Bruynooghe, SAT(ID): Satisfiability of propositional logic extended with inductive definitions, in: Theory andApplications of Satisfiability Testing, 11th International Conference (SAT), Springer, 2008, pp. 211–224.[35] S.T. Erdo˘gan, V. Lifschitz, Definitions in answer set programming, in: V. Lifschitz, I. Niemelä (Eds.), Proceedings of International Conference on LogicProgramming and Nonmonotonic Reasoning (LPNMR), Springer, 2004, pp. 114–126.