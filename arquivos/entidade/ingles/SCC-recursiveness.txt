Artificial Intelligence 168 (2005) 162–210www.elsevier.com/locate/artintSCC-recursiveness: a general schemafor argumentation semanticsPietro Baroni, Massimiliano Giacomin ∗, Giovanni GuidaDipartimento di Elettronica per l’Automazione, Università di Brescia, Via Branze 38, I-25123 Brescia, ItalyReceived 12 January 2005; received in revised form 18 May 2005; accepted 31 May 2005Available online 14 July 2005AbstractIn argumentation theory, Dung’s abstract framework provides a unifying view of several alternativesemantics based on the notion of extension. In this context, we propose a general recursive schemafor argumentation semantics, based on decomposition along the strongly connected components ofthe argumentation framework. We introduce the fundamental notion of SCC-recursiveness and weshow that all Dung’s admissibility-based semantics are SCC-recursive, and therefore a special case ofour schema. On these grounds, we argue that the concept of SCC-recursiveness plays a fundamentalrole in the study and definition of argumentation semantics. In particular, the space of SCC-recursivesemantics provides an ideal basis for the investigation of new proposals: starting from the analysis ofseveral examples where Dung’s preferred semantics gives rise to questionable results, we introducefour novel SCC-recursive semantics, able to overcome the limitations of preferred semantics, whilediffering in other respects. 2005 Elsevier B.V. All rights reserved.Keywords: Argumentation semantics; Extensions; Defeat cycles* Corresponding author.E-mail addresses: baroni@ing.unibs.it (P. Baroni), giacomin@ing.unibs.it (M. Giacomin),guida@ing.unibs.it (G. Guida).0004-3702/$ – see front matter  2005 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2005.05.006P. Baroni et al. / Artificial Intelligence 168 (2005) 162–2101631. IntroductionArgumentation theory is a framework for practical and uncertain reasoning, where ar-guments supporting conclusions are progressively constructed and compared in order toidentify the set of conclusions that should be considered justified according to the currentstate of available knowledge. Since the construction of arguments proceeds by exploitingincomplete and uncertain information, conflicts between them may arise and their man-agement is regarded as an essential aspect of the theory. The ability to deal in this waywith uncertain and conflicting information plays an important role in a variety of appli-cation contexts, such as legal reasoning [19,21,26], intelligent agents [17], planning [16],inconsistency handling [1], negotiation and dialogue [3]. As a consequence, argumentationtheory is receiving an increasing interest both from the theoretical and application view-points, and a variety of approaches have been proposed in the literature, e.g., [2,6,13,14,25,27].An extensive survey of this research field is provided in [22], where the literatureproposals are examined along five dimensions, i.e., the underlying logical language, thedefinition of what an argument is, the criteria for identifying conflict between arguments,the definition of the relevant relation of defeat between them, and, finally, the definition ofthe justification status of arguments. As to the last point, each proposal is based on an ar-gumentation semantics which defines in a declarative way the criteria to determine, givena set of interacting arguments, which ones of them should emerge as justified from theconflict. To this purpose, almost all of the argumentation semantics rely on the notion ofextension, roughly consisting in a set of non-conflicting arguments: an argument is con-sidered as justified if it belongs to all extensions prescribed by the semantics. As pointedout in [22], two alternative approaches can be followed in this respect: in the unique-statusapproach a single extension is always identified, while in the multiple-status approach sev-eral extensions may exist for a given set of arguments. Moreover, specific proposals alsodiffer in the form the underlying semantics is introduced. For instance, in [6,9,27] a fixedpoint definition is exploited, while in [13] the semantics is defined inductively by means ofthe notion of level.A unifying framework, able to encompass a large variety of proposals, has been pro-posed by Dung in [9]. Abstraction is achieved by leaving unspecified the origin and thestructure of arguments, and by modeling the interaction between them simply as a binaryrelation indicating that an argument attacks another one. This way, Dung’s approach isgeneric with respect to the first four dimensions of the classification proposed in [22],and, as pointed out in [1], it allows one to focus exclusively on semantics issues, withoutgetting entangled in the details of what arguments are. Thanks to its generality, Dung’sproposal has been recognized as a unifying framework encompassing most of the existingapproaches to argumentation and has also inspired subsequent proposals of argumentationsystems, e.g., [21,27]. Moreover, Dung’s theory is relevant in several fields where con-flict management plays a central role, ranging from logic programming to nonmonotonicreasoning and game theory.As far as semantics is concerned, Dung’s framework captures several alternative seman-tics which are introduced in [9] by means of fixed point definitions, and are all based on thenotion of admissible set. Among them, preferred semantics is regarded as the most satisfac-164P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210tory approach, able to overcome the limitations of the previously proposed grounded andstable semantics. However, we show in this paper that preferred semantics is not exemptedfrom producing questionable results in some cases concerning cyclic attack relationships(see [4,5] for a preliminary discussion on this problem). In the search of alternative propos-als, able to retain the advantages of preferred semantics and, at the same time, to supportalternative treatments of such problematic cases, we carry out a broad conceptual analysisaimed at identifying a set of basic principles that can be regarded as universally acceptablein argumentation semantics and, in particular, underly all the approaches encompassed byDung’s framework.This analysis leads to the introduction of a novel general recursive schema for the defin-ition of extensions, based on the graph-theoretic notion of strongly connected componentsof an argumentation framework. Semantics adhering to this schema feature the property ofSCC-recursiveness, which entails that a specific semantics can be characterized in termsof a base function, which plays the role of a parameter in the recursive schema. SCC-recursiveness can be assumed as a basic unifying concept in argumentation theory for tworeasons: on the one hand, all semantics captured by Dung’s framework satisfy the SCC-recursiveness property and, on the other hand, the SCC-recursive schema supports in arather straightforward way the definition of new semantics, since basic desirable proper-ties of extensions—and therefore of the argumentation semantics itself—can be guaranteedby simple requirements on the base function. On these grounds, we introduce, to exemplifythe potential of the approach, four novel SCC-recursive semantics overcoming the abovementioned limitations of the preferred semantics, while differing in other aspects.The paper is organized as follows. In Section 2, we recall the basic notions of Dung’stheory and carry out a survey about argumentation semantics in this context, focusing onthe intuitive concepts underlying formal definitions and properties of extensions. Prob-lematic cases that point out some questionable behaviors of preferred semantics are thenpresented in Section 3. The general SCC-recursive schema is introduced in Section 4, whileSection 5 illustrates its role as a unifying concept in argumentation semantics, showing thattraditional semantics adhere to the schema. Section 6 analyzes some general properties ofSCC-recursive semantics, while in Section 7 four novel SCC-recursive semantics are in-troduced and compared. Finally, Section 8 concludes the paper.2. Dung’s theory2.1. Argumentation frameworkThe general theory proposed by Dung [9] is based on the primitive notion of argumen-tation framework:Definition 1. An argumentation framework is a pair AF = (cid:2)A, →(cid:4), where A is a set, and→⊆ (A × A) is a binary relation on A, called attack relation.The idea is that arguments are simply conceived as the elements of the set A, whoseorigin and structure are not specified, and the interaction between them is modeled by theP. Baroni et al. / Artificial Intelligence 168 (2005) 162–210165binary relation of attack. An argumentation framework AF = (cid:2)A, →(cid:4) can be represented asa directed graph, called defeat graph, where nodes are the arguments and edges correspondto the elements of the attack relation.In the following, the nodes that attack a given argument α are called defeaters of α andform a set which is denoted as parentsAF(α):1Definition 2. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a node α ∈ A, wedefine parentsAF(α) = {β ∈ A | β → α}. If parentsAF(α) = ∅, then α is called an initialnode.Since we will frequently consider properties of sets of arguments, it is useful to extendthe notations defined for the nodes:Definition 3. Given an argumentation framework AF = (cid:2)A, →(cid:4), a node α ∈ A and twosets S, P ⊆ A, we define:S → α ≡ ∃β ∈ S : β → αα → S ≡ ∃β ∈ S : α → βS → P ≡ ∃α ∈ S, β ∈ P : α → βoutparentsAF(S) = {α ∈ A | α /∈ S ∧ α → S}In Dung’s framework, an argumentation semantics is defined by specifying the criteriafor deriving, for a generic argumentation framework, the set of all possible extensions, eachone representing a set of arguments considered to be acceptable together. Given a genericargumentation semantics S, the set of extensions prescribed by S for a given argumentationframework AF = (cid:2)A, →(cid:4) is denoted as ES (AF).The set of extensions is then used to compute the justification status of the arguments,according to the following definition:Definition 4. Given an argumentation framework AF = (cid:2)A, →(cid:4), the arguments of A canbe partitioned, with reference to a given argumentation semantics S, into three sets:• the set of undefeated arguments US (AF) = {α ∈ A | ∀E ∈ ES (AF) α ∈ E};• the set of defeated arguments DS (AF) = {α ∈ A | ∀E ∈ ES (AF) α /∈ E};• the set of provisionally defeated arguments PS (AF) = {α ∈ A | ∃E1, E2 ∈ ES (AF):α ∈ E1 ∧ α /∈ E2}.1 We use the graph-theoretical term parents instead of attackers since, in the following, we will need to resortto other related graph-theoretical notions, in particular that of ancestors.166P. Baroni et al. / Artificial Intelligence 168 (2005) 162–2102.2. Argumentation semantics: a focused surveyIn this subsection, we carry out a conceptual analysis of the basic intuitive princi-ples underlying several extension-based argumentation semantics and identify their formalcounterpart by referring to definitions and properties in Dung’s theory [9].Starting from the intuition that an extension is a set of arguments considered to beacceptable together, one may envisage as a first requirement the fact that no conflict isallowed between arguments belonging to the same extension, since it should representan internally consistent choice (among possibly many) over the whole set of availablearguments. This amounts to require that an extension is conflict-free.Definition 5. Given an argumentation framework AF = (cid:2)A, →(cid:4), a set E ⊆ A is conflict-free if and only if (cid:1)α, β ∈ E such that α → β.Clearly not all conflict-free sets are reasonable candidates for the notion of extension.In fact, simply identifying the extensions with the conflict-free sets leads to consider theempty set, which is of course conflict-free, as an extension and, therefore, according toDefinition 4, no argument would ever be justified in any argumentation framework. Inorder to prevent this degenerate behavior, a completeness requirement is needed, to ensurethat the largest consistent choices of arguments are taken into account for the determinationof the justification status. In the case of conflict-free sets, this amounts to require that anextension is also maximal with respect to set inclusion.Definition 6. Given an argumentation framework AF = (cid:2)A, →(cid:4), a set E ⊆ A is maximalconflict-free if and only if it is maximal (with respect to set inclusion) among the conflict-free sets of AF. The set made up of all the maximal conflict-free sets of AF will be denotedas MCF AF.It is however easy to see that identifying extensions with maximal conflict-free setsgives rise to undesired behaviors even in very simple cases. For instance, in the case ofan argumentation framework consisting of a defeat chain (see Fig. 1) it is widely acceptedthat the initial node, which has no defeaters (α in our example), and all other nodes inodd positions, whose defeaters are defeated by undefeated nodes (only γ in our example)should be regarded as undefeated, while nodes in even positions (β and δ) should be re-garded as defeated. This is an instance of the reinstatement principle [22]. However, themaximal conflict-free sets in this example are {α, γ }, {α, δ}, and {β, δ}: no argument wouldbe included in all extensions and therefore the status of provisionally defeated would beassigned to all arguments.A first intuition to solve this problem is based on the idea that an extension shouldnot only be internally consistent but also able to reject the arguments that are outside theFig. 1. A chain of four nodes.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210167Fig. 2. A three-length cycle.extension, namely if an argument is not in an extension then it should be attacked by theextension itself. This reasoning leads to the notion of stable extension [9,23].Definition 7. Given an argumentation framework AF = (cid:2)A, →(cid:4), a set E ⊆ A is a stableextension of AF if and only ifE is conflict-free ∧ ∀α ∈ A: α /∈ E, E → αThe set of all the stable extensions of AF will be denoted as SE(AF) .Note that the above definition implies that a stable extension is a maximal conflict-freeset. In the example of Fig. 1 there is only one stable extension, namely {α, γ }, and thedesired result is thus achieved. However there are argumentation frameworks where nostable extension exists, as in the case of odd-length cycles. In fact, considering the simpleargumentation framework of Fig. 2, it is easy to see that none of the conflict-free sets ∅,{α}, {β}, {γ } attacks all the arguments outside it. Therefore, a semantics based on stableextensions fails to assign a justification status to arguments in these cases. A practicalexample of this kind of problem has been pointed out by Pollock in [14] and concerns thecase of three witnesses (Smith, Jones, and Robertson) which question each other reliabilityin the following way: Jones says that Smith is unreliable, Smith says that Robertson isunreliable, and Robertson says that Jones is unreliable. In a defeat graph representation, thiscorresponds to the three-length cycle shown in Fig. 3(a). Moreover suppose that Smith saysthat it is raining (node “rain” in Fig. 3(a)). Resorting to stable extensions, it is impossibleto assign a justification status to the nodes of this graph. However, if we have four ratherthan three witnesses (in general, an even-length rather than an odd-length cycle) stableextensions exists. In fact, considering Fig. 3(b) there are two stable extensions, namely{S, R, rain} and {P , J }, yielding all of the arguments provisionally defeated, as intuitivelyshould be. Pollock points out that this is a serious drawback since “surely, it should makeFig. 3. The witnesses example.168P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Fig. 4. A problematic defeat graph for stable semantics.no difference that the defeat cycle is of odd-length rather than even-length. We should getthe same result in either case” [14].One might be tempted to apply a local correction to stable semantics by prescribing thatwhen no stable extension exists, then the empty set should be considered as the uniquestable extension. Such a solution would however be unsatisfactory for several reasons.First of all, it still gives different results for odd-length and even-length cycles (defeatedvs. provisionally defeated for all nodes). Moreover, it gives incorrect results in graphswhere nodes which should be undefeated are present along with odd-length cycles. Forinstance, in the graph shown in Fig. 4 no stable extension exists, entailing that all nodesare not justified, however node δ, which has no defeaters and is not involved in the cycle,should be undefeated. A more appropriate way to solve this problem consists in takinga different perspective: rather than imposing the “aggressive” condition of attacking allexternal arguments, it is enough to require that, more pacifically, the extension is just able todefend itself from external attacks. This intuition has been formalized in [9] by introducingthe notions of acceptable argument and admissible set.Definition 8. Given an argumentation framework AF = (cid:2)A, →(cid:4), an argument α ∈ A isacceptable with respect to a set E ⊆ A if and only if∀β ∈ A: β → α, E → βThe set of the arguments acceptable with respect to a set E will be denoted using thecharacteristic function FAF(E):Definition 9. Given an argumentation framework AF = (cid:2)A, →(cid:4), the functionFAF : 2A → 2Awhich, given a set E ⊆ A, returns the set of the acceptable arguments with respect to E iscalled the characteristic function of AF.Definition 10. Given an argumentation framework AF = (cid:2)A, →(cid:4), a set E ⊆ A is admissi-ble if and only ifE is conflict-free and ∀β ∈ A: β → E, E → βnamely it is conflict-free and each argument in E is acceptable with respect to E. The setmade up of all the admissible sets of AF will be denoted as AS(AF).Building on these definitions, the notion of complete extension can be introduced, byimposing that an admissible set also satisfies a completeness requirement. Complete exten-P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210169Fig. 5. The ‘Nixon diamond’ example.sions play a key role in Dung’s theory, since all semantics encompassed by his frameworkselect their extensions among the complete ones. Intuitively, a complete extension is anadmissible set such that no argument outside the set is acceptable with respect to the setitself.Definition 11. Given an argumentation framework AF = (cid:2)A, →(cid:4), a set E ⊆ A is a com-plete extension if and only if E is admissible and every argument of A which is acceptablewith respect to E belongs to E, i.e.,E ∈ AS(AF) ∧ ∀α ∈ FAF(E), α ∈ EThe set of complete extensions of AF will be denoted as CE(AF).One might guess that the notion of complete extension entails maximality, since noacceptable argument is left outside the extension. However, this is not the case. In fact,the above property only states that nodes already defended by the extension are included,but it does not impose that nodes (or sets of nodes) that defend themselves are added tothe extension. For instance, in the case of Fig. 5, the empty set is a complete extension,while either of the nodes defends itself and therefore also {α} and {β} are complete exten-sions.As a consequence, a further notion of extension, called preferred extension, has beenintroduced in [9] by directly requiring maximality of admissible sets.Definition 12. Given an argumentation framework AF = (cid:2)A, →(cid:4), a set E ⊆ A is a pre-ferred extension of AF if and only if it is a maximal (with respect to set inclusion)admissible set, i.e., a maximal element of AS(AF). The set of preferred extensions ofAF will be denoted as PE(AF).Preferred semantics is able to cope with the problematic examples involving odd-lengthcycles presented above: in fact, in the graph of Fig. 2 there is a preferred extension (theempty set), while for the case of Fig. 4 the only preferred extension is {δ} as desired. Itcan be noted however that the treatment of odd and even-length cycles is still unequal (aspointed out for instance by Pollock in [18]).Note that all the proposals surveyed above belong to the area of multiple-status ap-proaches, where multiple extensions may exist for a given argumentation framework. Analternative research line has focused on unique-status approaches, that prescribe the exis-tence of exactly one extension for each argumentation framework. Grounded semantics [9,13] is probably the most representative proposal among unique-status approaches and hasplayed an important role in the development of argumentation theory.170P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210First of all, an alternative definition of justification status is required [13], since Defini-tion 4 is not appropriate in case of a unique-status approach:2Definition 13. Given an argumentation framework AF = (cid:2)A, →(cid:4), the arguments of A canbe partitioned, with reference to a given unique-status argumentation semantics S, intothree sets on the basis of the unique extension E ∈ ES(AF):• the set of undefeated arguments US (AF) = {α ∈ A | α ∈ E};• the set of defeated arguments DS (AF) = {α ∈ A | α /∈ E ∧ E → α};• the set of provisionally defeated arguments PS (AF) = {α ∈ A | α /∈ E ∧ E (cid:12)→ α}.Formally, the (unique) extension of the grounded semantics, called the grounded exten-sion, can be defined as the least fixed point of the characteristic function.Definition 14. Given an argumentation framework AF = (cid:2)A, →(cid:4), the grounded extensionof AF, denoted as GE(AF), is the least fixed point (with respect to set inclusion) of FAF.In more intuitive terms, the computation of the grounded extension can be understoodas the process of labeling the nodes of the defeat graph starting from the initial ones. As afirst step, initial nodes are labeled as undefeated and the nodes attacked by them are labeledas defeated. Then the already labeled nodes are suppressed and the step is repeated on theresulting subgraph, and so on. If in an iteration no initial node is found, all the unlabelednodes are labeled as provisionally defeated, and the process terminates. Note in particularthat, since there are no initial nodes in the graphs of Fig. 3(a) and Fig. 3(b), all nodes arelabeled as provisionally defeated in the first step. In Fig. 4 node δ is labeled undefeated inthe first step, then all other nodes are labeled provisionally defeated, as desired.According to the above analysis, grounded semantics fits well all the basic intuitionsabout the assignment of justification status and represents a sort of reference as far asundefeated and defeated arguments are concerned. In a sense, these assignments are un-questionable and should be agreed with by any alternative proposal. In Dung’s framework,this reference role has a formal counterpart in the following property: the grounded ex-tension is contained in any complete extension, and therefore in the extensions of anysemantics (in particular in any preferred extension).Proposition 15. Given an argumentation framework AF = (cid:2)A, →(cid:4):• the grounded extension GE(AF) is the least (with respect to set inclusion) completeextension of AF;• the preferred extensions in PE(AF) are the maximal (with respect to set inclusion)complete extensions of AF.2 The existence of two alternative definitions of justification status is actually unsatisfactory. In [8], we haveproposed a unified definition overcoming this limitation and introducing a more articulated classification. Theconsiderations and the results presented in this paper are however independent of the choice of justification statusdefinition.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210171Fig. 6. Argumentation framework with a floating argument.For these reasons, as well as for its computational advantages, variants of groundedsemantics have been considered in several works [10,13,21].Any unique-status approach is affected however by a limitation concerning the treat-ment of the so-called floating defeat, as pointed out in [12,24]. Consider the defeat graphpresented in Fig. 6: as it has no initial nodes, the grounded semantics directly labels allnodes as provisionally defeated. On the other hand, preferred semantics (as well as stablesemantics) prescribes two extensions {α, δ} and {β, δ}, thus yielding δ undefeated, α and βprovisionally defeated, and γ defeated. This seems to be the intuitively correct result sinceboth α and β, while preventing each other to be justified, defeat γ , thus enabling in anycase the acceptance of δ.3. Preferred semantics: problematic behaviorsAs discussed in the previous section, Dung’s work has played an influential role on ar-gumentation research in recent years, due to its generality, to the proposed unifying viewable to capture the most significant existing approaches, and to the importance of the spe-cific results presented. In particular, preferred semantics is able to overcome the limitationsof stable semantics as far as the existence of extensions in presence of defeat cycles is con-cerned, and the limitations of grounded semantics in the treatment of floating defeat.However, while preferred semantics can be considered a significant advancement withrespect to previous proposals, one can notice that the treatment of cycles does not appearcompletely satisfactory, since it is not as elegant as the one of grounded semantics. As amatter of fact, if the nodes of a defeat graph are arranged in a cycle of attack relationships,then they are not justified: this seems to be the intuitively right result, since all argumentsin a cycle should be treated equally for obvious symmetry reasons and considering themall justified would yield a contradiction. However, this result is obtained in rather differentways in the two semantics. In the context of the grounded semantics, all arguments forminga cycle are directly labeled as provisionally defeated, since the grounded extension turnsout to be the empty set. On the other hand, the preferred semantics features a sort of asym-metry, since it treats odd-length cycles differently from the even-length ones. Consideringthe argumentation framework of Fig. 5, consisting of a two-length cycle, two preferredextensions exist, namely {α} and {β}, therefore both arguments are provisionally defeatedaccording to preferred semantics. With reference to the argumentation framework of Fig. 2,consisting of a three-length cycle, Definition 12 identifies the empty set as the unique pre-ferred extension, therefore all the arguments are defeated. More generally, with odd-lengthcycles there is a unique empty extension, and then all arguments are defeated, while with172P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Fig. 7. A simple variant of the witnesses example.even-length cycles non-empty extensions exist but their intersection is empty, and then allarguments are provisionally defeated. This peculiar way of assigning a justification statusto odd-length cycles has recently been indicated as “puzzling” by Pollock [18].So far, this difference might be considered as a mere question of symmetry and elegance.However, as we show considering a simple variant of the witnesses example of Fig. 3,it can be recognized that the different treatment of odd-length cycles is a real problemsince it gives rise to counter-intuitive results. Let us suppose that an additional source ofinformation, e.g., a weather report, suggests that it is not raining, contradicting the claimmade by Smith; in the case of three witnesses, the resulting argumentation framework isshown in Fig. 7(a). In this case, it turns out that PE(AF) = {{¬rain}}, therefore ¬rain isundefeated while all the other arguments are not justified. On the other hand, in the caseof four witnesses we obtain the argumentation framework shown in Fig. 7(b): it admitsseveral preferred extensions whose intersection is empty, and therefore all arguments areprovisionally defeated. Notice that similar situations arise, in general, by replacing thethree-length and four-length cycle with any odd-length and even-length cycle, respectively.Therefore, the justification status of the argument supported by the weather report turnsout to depend (in an alternating way) on the number of conflicting witnesses. Note that thisdifference arises because an odd-length cycle has no extensions besides the empty one: as aconsequence, in the argumentation framework of Fig. 7(a) there is no extension where noderain is in and ¬rain is out and, therefore, ¬rain emerges as the only justified argument.Instead, such an extension exists with an even-length cycle and, therefore, both rain and¬rain turn out to be provisionally defeated.This seems to be rather questionable: as remarked in [14] the length of the leftmostcycle should not affect the justification status. More generally, it is counter-intuitive thatdifferent results in conceptually similar situations depend on the length of the cycle: sym-metry reasons suggest that all cycles should be treated equally and should yield the sameresults.Notice that, in the above example, the odd-length cycle is in a sense stronger than theeven-length one, since in the case of Fig. 7(a) the status of rain is the same as if it would beattacked by an initial node. The opposite happens however in the variant of this exampleshown in Fig. 8. Considering the argumentation framework of Fig. 8(a), it turns out thatthere is only one preferred extension, namely {α, φ}, therefore both α and φ are justifiedaccording to the preferred semantics. In fact, the absence of non-empty extensions for thethree-length cycle prevents the existence of extensions where φ is out and γ is in. Since φattacks γ , also α survives: as a consequence, α and φ emerge (questionably) undefeated.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210173Fig. 8. Problematic argumentation frameworks for preferred semantics.Fig. 9. A case of floating defeat and floating acceptance.On the other hand, by replacing the three-length cycle with a four-length cycle, we obtainthe argumentation framework of Fig. 8(b), whose arguments are all provisionally defeated(and a similar result is obtained with any other even-length cycle). In this case, therefore,the odd-length cycle is in a sense weaker than the even-length one, since it is not able toprevent φ from being justified.In summary, we notice that odd-length cycles are problematic for preferred semanticsfrom two points of view: first of all, they give radically different results with respect toeven-length cycles in situations where such a difference does not seem justified, moreoverthey change their capability of defeating other arguments depending on the topology of thedefeat graph.These problems have been first pointed out in our previous works [4,7]. Other specificdifficulties of preferred semantics related to the treatment of odd-length cycles have beennoticed in argumentation literature. In [22], a problem in the treatment of the argumentationframework shown in Fig. 9 is pointed out. This is a case of floating defeat against argumentγ by the nodes in the three-length cycle, namely it can be regarded as a variant of the argu-mentation framework shown in Fig. 6, where the even-length attack loop has been replacedby an odd-length loop. Again, regarding as irrelevant the distinction between even-lengthand odd-length cycles would yield to consider γ defeated and δ justified: although δ isattacked by γ , it is reinstated by arguments α, β and φ since any of them attacks γ . How-ever, it turns out that preferred semantics admits as preferred extension only the empty setand, therefore, no argument is justified. The authors underline that “this seems one of themain unsolved problems in argumentation-based semantics” [22].Problems also arise when considering the extreme case of odd-length cycles, namelyself-defeating arguments, which have received a special attention in the literature [14,22].The argumentation framework AF shown in Fig. 10 is yet another problematic case forpreferred semantics, as observed by Dung himself [9]. In fact, the only preferred extension174P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Fig. 10. The case of a self-defeating argument.here is the empty set, though one can argue that since α attacks itself, β should be justi-fied. Actually, both solutions are reasonable in some sense, since different treatments ofself-defeating arguments may be appropriate in different contexts: a discussion and someexamples about this point are provided in [15].Before drawing any conclusion from the previous discussion, it is fair to recognize thatdifferent points of view about the intuitive interpretation of the defeat graphs presentedabove are possible as well. In [22], it is suggested that, while these examples are prob-lematic if one adheres to an intuitive symmetry requirement, an alternative view can beconceived where “odd defeat loops are of an essentially different kind than even defeatloops”. For instance, one might state that odd-length cycles are like paradoxes, i.e., sit-uations where nothing can be believed, while even-length cycles are like dilemmas, i.e.,situations where a choice needs to be made. While, in our opinion, this remark is not ap-plicable to the above examples concerning witnesses, we agree that the matter is far fromadmitting a univocal solution. In this perspective, one should not look for just one rightsemantics, since the correct behavior is a matter of interpretation. Similarly, in [11] exam-ples are pointed out where the behavior of grounded semantics appears more appropriatethan the one of preferred semantics in the treatment of so-called floating conclusions. Froma more general stance, in [20] it is remarked that using intuition about specific examplesto derive general considerations about defeasible reasoning may be risky and inappropri-ate. This is due, in particular, to the specific nature of defeasible reasoning where it is afundamental standpoint that inferences are never conclusive and are always subject to beinvalidated in the light of additional information. For these reasons, alternative solutions tosome puzzling examples can be obtained by making explicit some information left implicitin their original formulation. Moreover, it can be argued that in these problematic cases thetopology of the defeat graph does not determine a univocal solution per se, since the sameabstract structure may give rise to different intuitively plausible justification status assign-ments when instantiated on distinct common sense reasoning examples: this is a downsideof the generality of abstract frameworks. As a consequence, Prakken suggests that “it isbetter to use intuitions not as critical tests but as generators for further investigation” [20].The work described in the present paper adheres to this suggestion. The problematiccases discussed above point out that different solutions can be considered reasonable indifferent contexts (or even in the same context by different people) and, in particular, pre-ferred semantics may be regarded as problematic in some cases. As a conclusion of thissurvey, we aim at investigating an extension of Dung’s theory able to capture a larger vari-ety of argumentation semantics, so that none of the reasonable intuitions arising in differentcontexts is excluded. The framework we are looking for should therefore be able to includethe traditional grounded, stable, and preferred semantics, as well as alternative treatmentsof the problematic examples discussed above. To achieve such a level of generality, weneed to single out a few basic principles which can be regarded as a sort of insuppressibleP. Baroni et al. / Artificial Intelligence 168 (2005) 162–210175conceptual core for any argumentation semantics. The relevant analysis is carried out inthe following section.4. A general recursive schema for argumentation semanticsIn our search for a minimal set of fundamental principles of argumentation semantics,we depart from the common practice of characterizing extensions by means of a set ofglobal properties they should respect: rather, we adopt a sort of constructive approach,where the structure of the defeat graph drives the incremental definition of extensions. Inthis perspective, an argumentation semantics can be viewed as the definition of a mecha-nism for constructing all possible extensions of an argumentation framework, and this, inturn, can be understood as an incremental process that step-wise chooses which nodes ofan argumentation framework should be included into an extension.We draw inspiration from the way the justification status can be computed accordingto the grounded semantics: as described in Section 2.2, computation proceeds from thefrontier of the defeat graph towards the inside. Considering, as an example, the chain shownin Fig. 1, the initial node α is assigned the status of undefeated, causing β, which is attackedby α, to be assigned the status of defeated; this in turn causes γ to be assigned the status ofundefeated, and so on. This node labeling procedure suggests that edges in the defeat graphrepresent not only the attack relation, but also a dependency relation in the assignment ofjustification status: roughly, the status of a node depends on those of its defeaters. However,this intuition has to be refined in order to cope with the case of cyclic attack relations, wheremutual dependence would prevent this reasoning to be applicable. To this purpose, let usconsider the case of floating defeat shown in Fig. 6. In a sense, the subgraph {α, β} playsthe role of initial node with respect to γ ; in fact, the status assignment within this subgraphdetermines the justification status of γ . For instance, in the case of preferred semanticsthe construction of the extensions might proceed by selecting either α or β within thesubgraph, and then propagating the effect of this choice on the subsequent nodes. For eachof these choices γ is attacked and then left out from the extension; as a consequence, theattack from γ to δ is ineffective and δ is included in both the extensions.This example brings to light a fundamental aspect: the dependency relation introducedat the level of single nodes may also hold at the level of subgraphs, that play, in a sense,the role of single virtual nodes in the propagation of defeat. However, in order to derive aconcrete result from this intuition, it is necessary to identify a decomposition of the defeatgraph which appropriately reflects the dependency relation mentioned above. It turns outthat such decomposition is provided by the graph-theoretical notion of strongly connectedcomponents.Definition 16. Given an argumentation framework AF = (cid:2)A, →(cid:4), the binary relation ofpath-equivalence between nodes, denoted as PEAF ⊆ (A × A), is defined as follows:• ∀α ∈ A, (α, α) ∈ PEAF,• given two distinct nodes α, β ∈ A, (α, β) ∈ PEAF if and only if there is a path from αto β and a path from β to α.176P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210The strongly connected components of AF are the equivalence classes of nodes under therelation of path-equivalence. The set of the strongly connected components of AF is de-noted as SCCSAF. Given a node α ∈ A, the strongly connected component α belongs to isdenoted as SCCAF(α).A particular case, to be considered in the following, is represented by the empty argu-mentation framework: when AF = (cid:2)∅, ∅(cid:4) we assume SCCSAF = {∅}.To exemplify Definition 16, in the graph of Fig. 1 there are four strongly connected com-ponents each consisting of a single node (i.e., SCCSAF = {{α}, {β}, {γ }, {δ}}), since thereis not any couple of mutually reachable nodes. On the other hand, the graphs of Fig. 2,Fig. 5, Fig. 8 consist of exactly one strongly connected component coinciding with thewhole set of nodes, since they are all mutually reachable. The graphs in Fig. 3, Fig. 4 andFig. 10 include two strongly connected components: one consisting of a cycle (a degener-ate one in the case of Fig. 10), the other one of a single node. Three strongly connectedcomponents are present in the graph of Fig. 6, namely {α, β}, {γ }, and {δ}, and a simi-lar decomposition applies to the graph of Fig. 9. Finally two distinct strongly connectedcomponents can easily be identified in the graphs of Fig. 7: for instance in the graph ofFig. 7(a), the nodes R, S, and J form a first strongly connected component S1, since theyare mutually reachable being arranged in a cycle, while the nodes rain and ¬rain form asecond distinct strongly connected component S2, since they are mutually reachable whilethere is not any path leading from them to any node of S1.We extend to strongly connected components the notion of parents, denoting the setof the other strongly connected components that attack a strongly connected componentS as sccparentsAF(S), and we introduce the definition of proper ancestors, denoted assccancAF(S):Definition 17. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a strongly connectedcomponent S ∈ SCCSAF, we definesccparentsAF(S) = {P ∈ SCCSAF | P (cid:12)= S and P → S}andsccancAF(S) = sccparentsAF(S) ∪(cid:1)sccancAF(P )P ∈sccparentsAF(S)A strongly connected component S such that sccparentsAF(S) = ∅ is called initial.It is well-known that the graph obtained by considering strongly connected componentsas single nodes is acyclic: this confirms that considering a dependency relation at the levelof SCCSAF is a sound starting point. Recalling the basic example of Fig. 1, where thestrongly connected components consist of single nodes, clearly the dependency amongjustification states of nodes has a direct counterpart in terms of strongly connected com-ponents. Turning to the example of Fig. 6, a similar consideration applies: the subgraph{α, β} is actually the only initial strongly connected component of the graph. The choicesconcerning extension construction carried out in this first strongly connected componentclearly do not depend on those concerning the other ones and directly affect the choiceP. Baroni et al. / Artificial Intelligence 168 (2005) 162–210177about the subsequent strongly connected component (actually consisting of {γ }), which inturn affects the last strongly connected component, namely {δ}. Similar considerations canbe easily applied to other examples.Generalizing this intuition, we assume a first basic principle, called directionality prin-ciple: with reference to a given extension E, for any strongly connected component S ofAF, the choice of the subset of S to be included in E (i.e., (E ∩ S)) only depends on thechoices made in the strongly connected components of sccancAF(S), i.e., those that areantecedent to S in the acyclic graph made up of strongly connected components.In particular, the choices in the antecedent strongly connected components determine apartition of the nodes of S into three subsets:3Definition 18. Given an argumentation framework AF = (cid:2)A, →(cid:4), a set E ⊆ A and astrongly connected component S ∈ SCCSAF, we define:• DAF(S, E) = {α ∈ S | (E ∩ outparentsAF(S)) → α};• PAF(S, E) = {α ∈ S | (E ∩ outparentsAF(S)) (cid:12)→ α ∧ ∃β ∈ (outparentsAF(S) ∩parentsAF(α)): E (cid:12)→ β};• UAF(S, E) = S \ (DAF(S, E) ∪ PAF(S, E)) = {α ∈ S | (E ∩ outparentsAF(S)) (cid:12)→ α ∧∀β ∈ (outparentsAF(S) ∩ parentsAF(α))E → β}.In words, the set DAF(S, E) consists of the nodes of S attacked by E from outside S, theset UAF(S, E) consists of the nodes of S that are not attacked by E from outside S and aredefended by E (i.e., their defeaters from outside S are all attacked by E), and PAF(S, E)consists of the nodes of S that are not attacked by E from outside S and are not defendedby E (i.e., at least one of their defeaters from outside S is not attacked by E). It is easy toverify that DAF(S, E), PAF(S, E) and UAF(S, E) are determined only by the elements ofE that belong to the strongly connected components in sccancAF(S).To exemplify the above definitions, consider again the defeat graph presented inFig. 7(a), which consists of two strongly connected components S1 = {R, S, J } andS2 = {rain, ¬rain}, where clearly S1 precedes S2. Accordingly, let us now show how dif-ferent choices of E ∩ S1 determine different partitions of S2.Let us first consider the case that (E ∩ S1) = {J }: then the node rain receives anexternal attack coming from a node included in E. Therefore it satisfies the conditionfor membership in DAF(S2, E), while the node ¬rain does not receive external attacksfrom E, and thus satisfies the condition for membership in UAF(S2, E). Therefore it turnsout that DAF(S2, E) = {rain} and UAF(S2, E) = {¬rain}. Note that the condition about¬rain does not depend on the choice of E ∩ S1, therefore it will always be the case that¬rain ∈ UAF(S2, E).Let us turn to the case (E ∩ S1) = {S}: now rain does not receive external attacksfrom E, but is attacked from outside S2 by the node J , which is not included in E nor3 The symbols D, P and U are meant to recall the terms “Defeated”, “Provisionally defeated” and “Unde-feated” respectively. It has to be noted, however, that here they refer to a relationship between arguments and aparticular extension E, rather than to the overall justification status of arguments.178P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210is attacked by E. Thus rain satisfies the condition for membership in PAF(S2, E) yieldingPAF(S2, E) = {rain}, and, of course, again UAF(S2, E) = {¬rain}.Finally, if (E ∩ S1) = {R}, the node rain is defended by E since its only external at-tacker J is in turn attacked by R ∈ E, so rain satisfies the condition for membership inUAF(S2, E), yielding UAF(S2, E) = {rain, ¬rain}.Now, we need to investigate further principles which drive the selection of E ∩ S on thebasis of the above three sets. First of all, as already discussed in Section 2.2, a conflict-freeprinciple is universally accepted: an extension cannot include conflicting arguments. Thisentails that arguments in DAF(S, E), being attacked by nodes in E, cannot be chosen inthe construction of the extension E (i.e., do not belong to E ∩ S). Selection of argumentsto be included in E is therefore restricted to (S \ DAF(S, E)) = (UAF(S, E) ∪ PAF(S, E)),which, for ease of notation, will be denoted in the following as UPAF(S, E).As far as this selection is concerned, we recall that it is generally agreed that undefeatednodes are able to make ineffective the attacks of nodes they attack, i.e., of defeated nodes.This reinstatement principle prescribes that nodes defeated by an extension E play norole in the selection of nodes to be included in E. Taking into account the decompositioninto strongly connected components, the application of this principle can be examinedconsidering separately, for a given strongly connected component S, the nodes defeatedby E inside and outside S. Inside S, the principle entails that the nodes in DAF(S, E) andthe relevant attack relations can be suppressed. This implies that the selection within Sof the nodes to be included in an extension E has to be carried out on a sort of reducedargumentation framework, consisting in UPAF(S, E), completely neglecting the nodes inDAF(S, E).To formalize this concept, we provide the definition of restriction of an argumentationframework to a given subset of its nodes:Definition 19. Let AF = (cid:2)A, →(cid:4) be an argumentation framework, and let S ⊆ A be a setof arguments. The restriction of AF to S is the argumentation framework AF↓S = (cid:2)S, →∩(S × S)(cid:4).Combining this definition with the reinstatement principle, we obtain that the selectionof nodes within a strongly connected component S has to be carried out on the restrictedargumentation framework AF↓UPAF(S,E) without taking into account the attacks comingfrom DAF(S, E).Let us turn to the suppression of nodes defeated by E outside S. For ease of description,let us call in the following outer attacker of a strongly connected component S, with respectto an extension E, any node α such that α /∈ S, α /∈ E, α → UPAF(S, E). Note that anyouter attacker α of S necessarily belongs to a strongly connected component parent of S,i.e., SCCAF(α) ∈ sccparentsAF(S). We will also refer to the outer attackers of a node β ∈ Sto denote the subset of the outer attackers of S attacking β. In general some of the outerattackers of S with respect to E are in turn attacked by E, while others are not.As to the first ones, according to the reinstatement principle the nodes of UPAF(S, E)should be treated as if the outer attackers that are attacked by E did not exist. To clarifythis point, consider the particular case where all outer attackers of S are in turn attackedby E (formally, UPAF(S, E) = UAF(S, E)): according to the above considerations, the se-P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210179lection of nodes to be included in the extension is carried out in AF↓UPAF(S,E) neglectingthe suppressed outer attacks and therefore following the same principles which are appliedto an unrestricted argumentation framework, i.e., selection is carried out in the same wayas if the argumentation framework was not the result of a restriction. For instance, usingagain the example of Fig. 7(a), when UPAF(S2, E) = UAF(S2, E) = {rain, ¬rain} the re-instatement principle entails that the selection of E ∩ S2 is analogous to the case of Fig. 5,namely to the case of a defeat graph featuring the same topology and not resulting fromrestriction.On the other hand, outer attackers that are not attacked by E may play a role in theconstruction of the extensions. Accordingly, the nodes of UPAF(S, E) can be partitionedinto defended nodes, i.e., nodes which have no outer attackers or whose outer attackers areall attacked by E, and undefended nodes, such that at least one of their outer attackers isnot attacked by E.Summing up, on the basis of the principles we have identified, the selection of (E ∩ S)turns out to depend only on:• the restricted argumentation framework AF↓UPAF(S,E);• the distinction between defended and undefended nodes within UPAF(S, E).A direct way to formalize these ideas consists in stating that the nodes to be included inthe extension are selected by means of a generic selection function, which will be denotedas GF . The function GF takes in input two parameters:• a generic, possibly restricted, argumentation framework AF = (cid:2)A, →(cid:4) to which selec-tion has to be applied;• the set C ⊆ A of defended nodes4and gives as output a set of subsets of A, which represents all possible choices for E ∩ A.Accordingly, we will use the notation GF(AF, C) for the function. For the sake of general-ity, besides specifying its input and output, we do not make any a priori assumption aboutGF and, in particular, about whether and how the parameter C is taken into account.Now, the next step is to define GF(AF, C) for a generic argumentation framework AF =(cid:2)A, →(cid:4) and a set C ⊆ A, representing the defended nodes of AF: two cases have to beconsidered in this respect.If AF consists of exactly one strongly connected component, it does not admit a de-composition where to apply the directionality principle, therefore it has to be assumed thatGF(AF, C) coincides in this case with a base function, denoted as BF S (AF, C), that mustbe assigned in order to characterize a particular argumentation semantics S. The definitionof this base function is, at least in principle, unconstrained.On the other hand, if AF can be decomposed into several strongly connected com-ponents, then, according to the directionality and reinstatement principles, GF(AF, C)4 This is just one of the ways of formalizing the distinction between defended and undefended nodes: this for-malization turned out to enable a more elegant and compact technical treatment with respect to other alternatives.180P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210is obtained by applying recursively GF to each strongly connected component of AF,deprived of the nodes in DAF(S, E). Formally, this means that for any S ∈ SCCSAF,(E ∩ S) ∈ GF(AF↓UPAF(S,E), C(cid:16)), where C(cid:16) represents the set of defended nodes of therestricted argumentation framework AF↓UPAF(S,E). The set C(cid:16) can be determined takinginto account both the attacks coming from outside AF (which can be actually present onlyif AF results in turn from restriction) and those coming from other strongly connectedcomponents of AF, namely from sccparentsAF(S). Since the set C consists of the nodesdefended from the former kind of attacks at the level of AF, while UAF(S, E) consists ofthose defended from the latter, it turns out that C(cid:16) = UAF(S, E) ∩ C.The above considerations suggest to introduce a new notion for argumentation seman-tics, called SCC-recursiveness:Definition 20. A given argumentation semantics S is SCC-recursive if and only if forany argumentation framework AF = (cid:2)A, →(cid:4), ES (AF) = GF(AF, A), where for any AF =(cid:2)A, →(cid:4) and for any set C ⊆ A, the function GF(AF, C) ⊆ 2A is defined as follows:for any E ⊆ A, E ∈ GF(AF, C) if and only if• in case |SCCSAF| = 1, E ∈ BF S (AF, C),• otherwise, ∀S ∈ SCCSAF (E ∩ S) ∈ GF(AF↓UPAF(S,E), UAF(S, E) ∩ C),where BF S (AF, C) is a function, called base function, that, given an argumentation frame-work AF = (cid:2)A, →(cid:4) such that |SCCSAF| = 1 and a set C ⊆ A, gives a subset of 2A.In particular, the set of all the extensions of the original unrestricted argumentationframework AF coincides with GF(AF, A), since obviously there are no attacks from out-side and, therefore, the set C coincides with the set A of all arguments.Note that the definition of GF(AF, C) is recursive with respect to the decompositionof AF into strongly connected components. Since GF(AF, C) is applied to progressivelymore restricted argumentation frameworks, the definition is well founded: in particular thebase of the recursion is given by the function BF S (AF, C), which returns the extensionsof a generic argumentation framework consisting of a unique strongly connected compo-nent. Therefore, in order to define a SCC-recursive semantics, it is sufficient to specify itsbehavior only on single-SCC argumentation frameworks.The definition given above has also a straightforward constructive interpretation: itsuggests an effective (recursive) procedure for computing all the extensions of an argu-mentation framework AF = (cid:2)A, →(cid:4) according to a given SCC-recursive semantics, oncea specific base function is assigned. A particular role in this context is played by theinitial strongly connected components. In fact, for any initial strongly connected com-ponent I , since by definition there are no outer attacks, UPAF(I, E) = UAF(I, E) = Ifor any E and the set of defended nodes coincides with I . This gives rise to the invoca-tion GF(AF↓I , I ), for any initial strongly connected component I . Since AF↓I obviouslyconsists of a unique strongly connected component, according to Definition 20 the basefunction BF S (AF↓I , I ) is invoked, which returns the extensions of AF↓I according tothe semantics S. Therefore, the base function can be first computed on the initial stronglyconnected components, where it directly returns the extensions prescribed by the seman-P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210181Fig. 11. An argumentation framework with two strongly connected components.tics, then the results of this computation are used to identify, within the subsequent stronglyconnected components, the restricted argumentation frameworks on which the procedureis recursively invoked.To support a better understanding of the concepts introduced above, we describe indetail their application to the argumentation framework presented in Fig. 11, which consistsof two strongly connected components, namely S1 = {α, β, γ } and S2 = {δ, ε, η, ϕ}. In theexample we refer to a generic unspecified semantics S. The set of extensions of the wholeargumentation framework is given by GF(AF, A) and, since AF consists of more thanone strongly connected component, the function GF is invoked recursively on them (withC = A), following their order. Formally, we have that E ∈ ES(AF) iff• (E ∩ S1) ∈ GF(AF↓UPAF(S1,E), UAF(S1, E)),• (E ∩ S2) ∈ GF(AF↓UPAF(S2,E), UAF(S2, E)).As explained above, for the initial strongly connected component S1 it holds thatUPAF(S1, E) = UAF(S1, E) = S1for any E:this gives rise to the invocationGF(AF↓S1 , S1). Since AF↓S1 consists of a unique strongly connected component, thebase function BF S (AF↓S1 , S1) is invoked, which returns the extensions of AF↓S1 accord-ing to the semantics S. For the sake of the example, let us assume that BF S (AF↓S1, S1) ={{α}, {β}, {γ }}, i.e., that, according to S, the extensions of AF↓S1 are the singletons in-cluded in S1. At the level of the whole argumentation framework, they represent thealternative choices for E ∩ S1. Now, each of these alternative choices for E ∩ S1 hasan impact on the subsequent strongly connected component S2 and determines a distinctUPAF(S2, E), since, for any E, UPAF(S2, E) = UPAF(S2, E ∩ S1). Thus, GF has to beapplied to AF↓UPAF(S2,{α}), AF↓UPAF(S2,{β}), and AF↓UPAF(S2,{γ }), to determine which sub-sets of S2 can be joined with {α}, {β}, and {γ } respectively to form extensions at the level ofthe whole graph. If other strongly connected components were present, the same reasoningwould apply to them.To continue our example, let us now consider the case whereE ∩ S1 = {α}As to the partition induced on S2 by this choice, since only node δ is attacked by α ∈ E,DAF(S2, {α}) = {δ} and, therefore, UPAF(S2, {α}) = {ε, η, ϕ}, which determines the firstparameter for the recursive invocation of GF . Within UPAF(S2, {α}), the only node whichreceives an outer attack is ϕ. Since its attacker γ is not included in E ∩ S1 nor is attacked182P. Baroni et al. / Artificial Intelligence 168 (2005) 162–2101= {ε}, S(cid:16)2= {η}, S(cid:16)32, E(cid:16) ∩ S(cid:16)by E ∩ S1, we have PAF(S2, {α}) = {ϕ}, which entails UAF(S2, {α}) = {ε, η}. Therefore,the recursive invocation on the second strongly connected component of the graph has theform (E ∩ S2) ∈ GF(AF(cid:16), {ε, η}), where AF(cid:16) = AF↓{ε,η,ϕ}.= {ϕ}. S(cid:16)1, E(cid:16)) = UAF(cid:16)(S(cid:16)Now, let us identify the sets E(cid:16) ∈ GF(AF(cid:16), {ε, η}) which represent the possible valuesfor (E ∩ S2): the function GF is applied to AF(cid:16) following the same reasoning lines asabove. First, note that AF(cid:16) is actually a chain of three nodes, therefore it consists of threesimple strongly connected components S(cid:16)1 is the only initial1strongly connected component of AF(cid:16), therefore UPAF(cid:16)(S(cid:16)1, E(cid:16)) = S(cid:16)= {ε}for any extension E(cid:16) of AF(cid:16). Following Definition 20, the possible values for (E(cid:16) ∩ S(cid:16)1)are given by GF(AF(cid:16)↓{ε}, {ε} ∩ {ε, η}) = GF((cid:2){ε}, ∅(cid:4), {ε}). Since (cid:2){ε}, ∅(cid:4) consists of asingle strongly connected component, the base function BF S ((cid:2){ε}, ∅(cid:4), {ε}) is in turninvoked: let us (reasonably) assume that it returns {{ε}} as result. Then, as it was intu-itively evident, there is only one possibility for E(cid:16) ∩ S(cid:16)1, whose effects on subsequentstrongly connected components of AF(cid:16) have to be determined. It is immediate to note2, E(cid:16) ∩ S(cid:16)= {η}, therefore UPAF(cid:16)(S(cid:16)that DAF(cid:16)(S(cid:16)1) = ∅, and also the setof defended nodes is empty. Formally, the possible values for E(cid:16) ∩ S(cid:16)2 are given byGF(AF(cid:16)↓∅, ∅ ∩ {ε, η}) = GF((cid:2)∅, ∅(cid:4), ∅). The base function is then invoked on the emptyargumentation framework, giving reasonably {∅} as result. Now we are ready to consider3: within AF(cid:16) it receives an attack only from S2 and it is clear from abovethe situation of S(cid:16)that E(cid:16) ∩ S2 = ∅. Therefore UAF(cid:16)(S(cid:16)3, E(cid:16)) =PAF(cid:16)(S(cid:16)3, E(cid:16)) = ∅ and UPAF(cid:16)(S(cid:16)3, E(cid:16)). Applying Definition 20, the possi-ble values for E(cid:16) ∩ S(cid:16)∩ {ε, η}) = GF((cid:2){ϕ}, ∅(cid:4), ∅). NoteS(cid:16)3that, in this case, the second parameter of the function GF , namely the set of defendednodes, differs from UAF(cid:16)(S(cid:16)3, E(cid:16)), due to the attack coming from γ and considered at aprevious level of recursion. Again, AF(cid:16)↓consists of a single strongly connected com-ponent, therefore the possible values of E(cid:16) ∩ S(cid:16)3 are given by BF S ((cid:2){ϕ}, ∅(cid:4), ∅). In thiscase, the result of the function is no more obvious since different semantics might ascribea different role to the set of defended nodes, as it will be discussed later. Supposing thatthe result is {{ϕ}}, we have a unique E(cid:16) ∈ GF(AF(cid:16), {ε, η}), and therefore a unique valuefor (E ∩ S2), i.e., {ε, ϕ}. Summing up, we obtain {α, ε, φ} as an extension of the origi-nal AF.3, E(cid:16)) = UAF(cid:16)(S(cid:16)3 are given by GF(AF(cid:16)↓3, ∅) = S(cid:16), S(cid:16)3= {ϕ}. Then DAF(cid:16)(S(cid:16)3, E(cid:16)) = UAF(cid:16)(S(cid:16)1) = S(cid:16)S(cid:16)332For the sake of brevity we do not carry out such a detailed analysis for the cases E ∩S1 = {β}, and E ∩ S1 = {γ }, rather a sketch is provided for the interested reader.In the case E ∩ S1 = {β}, there are no attacks from E to S2 and β defends ϕ, there-fore it turns out that DAF(S2, E) = ∅, PAF(S2, E) = {δ}, UAF(S2, E) = {ε, η, ϕ}, whichcoincides with the set of defended nodes within S2. Then UPAF(S2, E) = S2 givingrise to the following invocation: GF(AF↓S2 , {ε, η, ϕ}). Now, AF↓S2 consists of a uniquestrongly connected component, therefore the possible completions of extensions at thelevel of the whole graph are given by BF S (AF↓S2 , {ε, η, ϕ}), whose outcome dependson the specific semantics S considered and is not specified here: joining the elements ofBF S (AF↓S2 , {ε, η, ϕ}) with {β}, we obtain a set of extensions B ⊂ ES(AF), such that∀B ∈ B, B ∩ S1 = {β}.Finally, in the case E ∩ S1 = {γ }, E attacks the node ϕ and defends the nodeδ within S2. Therefore DAF(S2, E) = {ϕ}, PAF(S2, E) = ∅, and UAF(S2, E) =UPAF(S2, E) = {δ, ε, η}, which coincides also with the set of defended nodes. LettingP. Baroni et al. / Artificial Intelligence 168 (2005) 162–210183= {δ}, S(cid:16)2AF(cid:16) = AF↓{δ,ε,η}, GF(AF(cid:16), {δ, ε, η}) is invoked. AF(cid:16) is a chain of three nodes, thereforeits strongly connected components are the singletons S(cid:16)= {η}.11 is the initial one and we have GF(AF(cid:16)↓S(cid:16)∩ {δ, ε, η}) = GF((cid:2){δ}, ∅(cid:4), {δ}) =BF S ((cid:2){δ}, ∅(cid:4), {δ}), which reasonably gives {{δ}} as only possible choice for E(cid:16) ∩ S(cid:16)1. Tak-2, E(cid:16)) = ∅ and then we have GF(AF(cid:16)↓∅, ∅) = GF((cid:2)∅, ∅(cid:4), ∅)ing this into account, UPAF(cid:16)(S(cid:16)= BF S ((cid:2)∅, ∅(cid:4), ∅), which reasonably gives {∅} as only possible choice for E(cid:16) ∩ S(cid:16)2. This en-tails UPAF(cid:16)(S(cid:16)∩ {δ, ε, η}) = GF((cid:2){η}, ∅(cid:4), {η}) =BF S ((cid:2){η}, ∅(cid:4), {η}), which reasonably gives {{η}} as only possible choice for E(cid:16) ∩ S(cid:16)3.Summing up, we obtain {γ , δ, η} as an extension of the original AF, and finally ES(AF) ={{α, ε, φ}, {γ , δ, η}} ∪ B.3 and we have GF(AF(cid:16)↓= {ε}, and S(cid:16)33, E(cid:16)) = S(cid:16), S(cid:16)3, S(cid:16)1S(cid:16)1S(cid:16)3Partly due to their recursive nature, Definition 20 and its detailed application may appearcomplex.5 We argue, however, that the underlying basic ideas are relatively simple and canbe summarized as follows:(1) the argumentation framework is partitioned into its strongly connected components;they form a partial order which encodes the dependencies existing among them ac-cording to the directionality principle;(2) the possible choices for extensions within each initial strongly connected componentare determined using a semantic-specific base function which returns the extensions ofargumentation frameworks consisting of a single strongly connected component;(3) for each possible choice determined at step 2, according to the reinstatement princi-ple, the nodes directly attacked within subsequent strongly connected components aresuppressed and the distinction between defended and undefended nodes is (possibly)taken into account;(4) the steps 1–3 above are applied recursively on the restricted argumentation frameworksobtained at step 3.One may now wonder whether the property of SCC-recursiveness characterizes a suit-able family of semantics. On the one hand, such family should be general enough to includeall traditional approaches to argumentation semantics in Dung’s framework, on the otherhand it should be constrained enough to support the definition of novel proposals based onreasonable definitions of the base function.As far as the first requirement is concerned, it is reasonable to expect a positive answersince SCC-recursiveness has been derived using a very essential set of largely acceptedprinciples in argumentation semantics. This intuition is formally backed up in the follow-ing section, where it is shown that all the semantics encompassed by Dung’s theory areSCC-recursive. As to the second requirement, in Section 6 we show that SCC-recursivesemantics satisfies two desirable properties under very general constraints on the base func-tion, while in Section 7 we exploit SCC-recursiveness to introduce four novel semanticsable to cope in different ways with the problematic cases illustrated in Section 3.5 Other examples of application of the recursive schema will be given in Section 7.184P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Fig. 12. A ‘Nixon diamond’ attacking a node.5. SCC-recursive characterization of traditional semantics5.1. Generalizing Dung’s theoryIn order to develop an SCC-recursive characterization of traditional semantics, it isnecessary, first of all, to redefine Dung’s theory in generalized terms, by restating itsfundamental concepts with reference to a specific subset C ⊆ A, from which acceptablearguments (that compose the extensions) are selected, since it represents the subset of de-fended nodes within A, as explained in the previous section. Original Dung’s definitionscan be recovered letting C = A. Proofs are omitted throughout this subsection as they arestraightforward extensions of those in [9].Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set C ⊆ A, we define admissi-ble sets in C as follows:Definition 21. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set C ⊆ A, a setE ⊆ A is an admissible set in C if and only if E ⊆ C ∧ E ∈ AS(AF). The set of admissiblesets in C is denoted as AS(AF, C).Note that, in general, AS(AF, C) (cid:12)= AS(AF↓C). For instance, in the argumentationframework of Fig. 12, with C = {γ } we have that AS(AF, C) = {∅}, since γ is not anadmissible set because of the attack coming from β, while AS(AF↓C) = {{γ }}.We introduce now the notion of stable, complete and preferred extensions in the contextof the generalized framework.Definition 22. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set C ⊆ A, a setE ⊆ A is a stable extension in C if and only if E ⊆ C and E ∈ SE(AF). The set of stableextensions in C is denoted as SE(AF, C).Definition 23. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set C ⊆ A, a setE ⊆ A is a complete extension in C if and only if E ∈ AS(AF, C), and every argumentα ∈ C which is acceptable with respect to E belongs to E, i.e., ∀α ∈ C: α ∈ FAF(E),α ∈ E. The set of complete extensions in C is denoted as CE(AF, C).Definition 24. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsC ⊆ A, a preferred extension in C is a maximal element (with respect to set inclusion) ofAS(AF, C). The set of preferred extensions in C is denoted as PE(AF, C).In other terms, E ∈ PE(AF, C) if and only if E is a maximal set such that E ⊆ C andE is admissible in AF.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210185Given these definitions, an important question concerns the existence of a preferredextension for any argumentation framework AF and for any set C ⊆ A. The followingtheorem provides a positive answer to this question, extending Dung’s results:Theorem 25. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set C ⊆ A:• The elements of AS(AF, C), i.e., the admissible subsets of C, form a complete partialorder.• For all F ∈ AS(AF, C), there is E ∈ PE(AF, C) such that F ⊆ E.Corollary 26. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set C ⊆ A,PE(AF, C) is non empty, i.e., there is always a preferred extension E ∈ PE(AF, C).Also in the generalized framework, the grounded semantics can be defined in terms ofthe least fixed point of the characteristic function.Definition 27. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsC ⊆ A, the functionFAF,C : 2C → 2CFAF,C(Q) = {α | α ∈ C, α acceptable with respect to Q}is called the characteristic function of AF in C.It is easy to see that FAF,C is monotonic (with respect to set inclusion).Definition 28. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set C ⊆ A, thegrounded extension of AF in C, denoted as GE(AF, C), is the least (with respect to setinclusion) fixed point of FAF,C .Notice that by definition GE(AF, C) ⊆ C. Also in this case we provide a positive resultconcerning the existence of the grounded extension:Lemma 29. For any argumentation framework AF = (cid:2)A, →(cid:4) and for all sets C ⊆ A,GE(AF, C) exists and is unique.Finally, the following relations between grounded, preferred and complete extensionscan be drawn:Proposition 30. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsC ⊆ A, GE(AF, C) is the least (with respect to set inclusion) complete extension in C (i.e.,the least element in CE(AF, C)).Proposition 31. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsC ⊆ A, the preferred extensions PE(AF, C) are the maximal (with respect to set inclusion)complete extensions in C (i.e., the maximal elements in CE(AF, C)).186P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Since Dung’s original definitions are recovered by letting C = A, a SCC-recursive for-mulation of the extended definitions also covers the original ones: this is achieved in thefollowing subsections, where we show that all the traditional semantics covered by Dung’stheory allow a definition of extensions recursively characterized along strongly connectedcomponents.5.2. Stable semanticsThe following proposition shows that stable extensions are in correspondence with adecomposition along strongly connected components: the intersection of a stable extensionwith any strongly connected component S is itself a stable extension of the restriction ofthe argumentation framework AF to UPAF(S, E).Proposition 32. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsE ⊆ A, E ∈ SE(AF) if and only if ∀S ∈ SCCSAF(E ∩ S) ∈ SE(AF↓UPAF(S,E))Proof. First, let us prove that if E is a stable extension of AF then it satisfies local stabilityrelevant to a generic strongly connected component S ∈ SCCSAF, corresponding to thefollowing conditions:(1) (E ∩ S) ⊆ UPAF(S, E);(2) (E ∩ S) is conflict-free;(3) ∀α ∈ UPAF(S, E): α /∈ (E ∩ S), (E ∩ S) → α.Notice that, by definition, the second and third conditions should be verified with referenceto the argumentation framework AF↓UPAF(S,E), however it is easy to see that, accordingto the first condition and the definition of AF↓UPAF(S,E), it is sufficient to verify them inAF. As for the first condition, we have that ∀α ∈ (E ∩ S) α /∈ DAF(S, E), otherwise by thedefinition of DAF(S, E) we would have that E → α, therefore E would not be conflict-free contradicting the hypothesis that E is a stable extension of AF. As far as the secondcondition is concerned, it directly follows from the fact that E is conflict-free, entailedby the hypothesis that E is a stable extension of AF. As for the third condition, let usconsider a generic argument α ∈ UPAF(S, E) such that α /∈ (E ∩ S). Since α ∈ S andα /∈ (E ∩ S), α /∈ E, therefore by the hypothesis that E is a stable extension of AF wehave that E → α, i.e., ∃β ∈ E : β → α. Since α ∈ UPAF(S, E), taking into account thedefinitions of UPAF(S, E) it turns out that (cid:1)γ ∈ (E ∩ outparentsAF(S)) such that γ → α.As a consequence, it must be the case that ∃β ∈ E, β ∈ S : β → α, thus (E ∩ S) → α, andthe first part of the proof is complete.Turning to the other direction of the proof, we have to show that, with reference to theargumentation framework AF:(1) E is conflict-free;(2) ∀α ∈ A: α /∈ E, E → α.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210187Let us prove the first condition by contradiction, assuming that ∃α, β ∈ E: α → β, andlet us indicate SCCAF(β) as S. Let us notice that α cannot belong to S, since in this case(E ∩ S) would not be conflict-free in AF as well as in AF↓UPAF(S,E), thus contradictingthe hypothesis that (E ∩ S) ∈ SE(AF↓UPAF(S,E)). As a consequence, α ∈ E and α /∈ S,therefore β ∈ DAF(S, E) by the definition of DAF(S, E). However, this contradicts thefact that β ∈ (E ∩ S), which by the hypothesis is contained in UPAF(S, E).Let us finally turn to the second condition, considering a generic α ∈ A: α /∈ E, andlet us indicate SCCAF(α) as S. We can distinguish two cases for α. If α ∈ DAF(S, E),then E → α directly follows from the definition of DAF(S, E). In the other case, α ∈UPAF(S, E). Since α /∈ E, we have that α /∈ (E ∩ S), therefore the hypothesis (E ∩ S) ∈SE(AF↓UPAF(S,E)) entails that (E ∩ S) → α in AF↓UPAF(S,E). Obviously, (E ∩ S) → αholds also in AF, and the proof is complete. (cid:1)Exploiting the following lemma, the above result can be extended to the generalizeddefinition of stable extensions, yielding the desired recursive characterization in Proposi-tion 34.Lemma 33. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a stable extension Eof AF, ∀S ∈ SCCSAF, PAF(S, E) = ∅.Proof. Let us assume by contradiction that ∃S ∈ SCCSAF: PAF(S, E) (cid:12)= ∅, i.e., ∃α ∈PAF(S, E). According to the definition of PAF(S, E), we have that ∃β /∈ E, β → α: E (cid:12)→β, contradicting the hypothesis that E is a stable extension of AF. (cid:1)Proposition 34. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsE ⊆ A, ∀C ⊆ A, E ∈ SE(AF, C) if and only if ∀S ∈ SCCSAF(E ∩ S) ∈ SE(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)Proof. Let us start from the first direction of the proof, assuming that E ∈ SE(AF, C).According to the definition of SE(AF, C), we have that E ∈ SE(AF), thus Proposition 32entails that ∀S ∈ SCCSAF(E ∩ S) ∈ SE(AF↓UPAF(S,E))In order to prove the thesis, we have only to show that (E ∩ S) ⊆ (UAF(S, E) ∩ C). First,the hypothesis that E is stable and therefore conflict-free entails that (E ∩ DAF(S, E)) = ∅.Moreover, according to Lemma 33 PAF(S, E) = ∅. As a consequence, it must be the casethat (E ∩ S) ⊆ UAF(S, E). Furthermore, according to the hypothesis E ⊆ C, it holds that(E ∩ S) ⊆ (UAF(S, E) ∩ C).Let us turn to the other direction of the proof, assuming that ∀S ∈ SCCSAF(E ∩ S) ∈ SE(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)Taking into account the definition of SE(AF↓UPAF(S,E), UAF(S, E) ∩ C), Proposition 32entails that E ∈ SE(AF). Moreover, since ∀S ∈ SCCSAF (E ∩ S) ⊆ C we have that E ⊆ C,thus E ∈ SE(AF, C), and the proof is complete. (cid:1)188P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210It can be noted that, on the basis of Lemma 33, the same result would have been achievedby adopting an alternative definition of SE(AF, C), namely SE(AF, C) ≡ SE(AF). In fact,in the case of stable extensions C has no concrete role, since all arguments outside anextension are attacked by the extension itself, and therefore all arguments within a stronglyconnected component S are defended against attacks from outside S.5.3. Admissible setsSince admissible sets play a key role in Dung’s theory, their characterization accord-ing to SCC-recursiveness is needed as a basis for the analysis of other semantics. This isachieved by Proposition 38, which requires three preliminary lemmas.Lemma 35 (from [9, pp. 327]). Given an argumentation framework AF = (cid:2)A, →(cid:4), anadmissible set of arguments E ∈ AS(AF), and an argument α ∈ FAF(E) acceptable withrespect to E, E ∪ {α} is admissible, i.e., (E ∪ {α}) ∈ AS(AF).Lemma 36. Given an argumentation framework AF = (cid:2)A, →(cid:4), an admissible set of argu-ments E ∈ AS(AF), and an argument α ∈ FAF(E) acceptable with respect to E, denotingSCCAF(α) as S, it holds that:• α ∈ UAF(S, E); and• α is acceptable with respect to (E ∩ S) in the argumentation framework AF↓UPAF(S,E),i.e., α ∈ FAF↓UPAF(S,E)(E ∩ S).Proof. First of all, on the basis of Lemma 35 (E ∪ {α}) ∈ AS(AF), and in particular(E ∪ {α}) is conflict-free: as a consequence α /∈ DAF(S, E), otherwise by the definitionof DAF(S, E) it would be the case that E → α. Moreover, α /∈ PAF(S, E), otherwise bythe definition of PAF(S, E) we would have that ∃β ∈ E: β → α and E (cid:12)→ β, thus con-tradicting the fact that α ∈ FAF(E), namely the acceptability of α with respect to E. As aconsequence, the only possibility for α is that α ∈ UAF(S, E).Turning to the second part of the proof, let us first note that, on the basis of the hy-pothesis that E ∈ AS(AF), all the elements of E are acceptable with respect to E, i.e.,∀γ ∈ E, γ ∈ FAF(E). Thus, the above result entails that (E ∩ S) ⊆ UAF(S, E), therefore(E ∩ S) is actually a set of arguments in the argumentation framework AF↓UPAF(S,E). Letus consider now a generic argument β that attacks α in AF↓UPAF(S,E): we have to prove that(E ∩ S) → β holds in this argumentation framework. Of course, β → α also in AF, there-fore the acceptability of α with respect to E, i.e., α ∈ FAF(E), entails that there is γ ∈ Esuch that γ ∈ parentsAF(β). Now, since β ∈ UPAF(S, E), by definition of UPAF(S, E) allof its defeaters outside S do not belong to E, thus γ ∈ S and therefore γ ∈ (E ∩ S). Asa consequence, (E ∩ S) → β holds in AF, and obviously it also holds in the restrictedargumentation framework AF↓UPAF(S,E). (cid:1)Lemma 37. Given an argumentation framework AF = (cid:2)A, →(cid:4), let E ⊆ A be a set ofarguments such that, ∀S ∈ SCCSAF(E ∩ S) ∈ AS(cid:3)(cid:2)AF↓UPAF(S,E), UAF(S, E)P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210189Given a strongly connected component (cid:4)S ∈ SCCSAF and an argument α ∈ UAF((cid:4)S, E)which is acceptable with respect to (E ∩(cid:4)S ) in the argumentation framework AF↓UPAF((cid:4)S,E),(E ∩ (cid:4)S ), α is acceptable with respect to E in AF, i.e., α ∈ FAF(E).i.e., α ∈ FAF↓UPAF((cid:4)S,E)Proof. With reference to the argumentation framework AF, we have to prove that ∀β ∈A: β → α, then also E → β. We distinguish two cases for β.First, let us suppose that SCCAF(β) = SCCAF(α) = (cid:4)S. If β ∈ DAF((cid:4)S, E), then E → βholds in AF by definition of DAF((cid:4)S, E). If, on the other hand, β ∈ UPAF((cid:4)S, E), then β →α holds in AF↓UPAF((cid:4)S,E), therefore according to the hypothesis of acceptability concerningα it must be the case that (E ∩ (cid:4)S ) → β holds in AF↓UPAF((cid:4)S,E). Obviously, such relationholds also in AF, and entails that E → β.Let us consider the other case, i.e., SCCAF(β) (cid:12)= SCCAF(α) = (cid:4)S. In this case, β ∈(outparentsAF((cid:4)S) ∩ parentsAF(α)), while by the hypothesis α ∈ UAF((cid:4)S, E): on the basisof the definition of UAF((cid:4)S, E), it must be the case that E → β in AF, and the proof iscomplete. (cid:1)Proposition 38. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsE ⊆ A, ∀C ⊆ A, E ∈ AS(AF, C) if and only if ∀S ∈ SCCSAF(E ∩ S) ∈ AS(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)Proof. First, let us prove that if E is admissible then it satisfies the conditions relevantto a generic strongly connected component S ∈ SCCSAF. According to the definition ofAS(AF, C), E ⊆ C and ∀α ∈ E, α is acceptable with respect to E, i.e., α ∈ FAF(E). Asa consequence, on the basis of Lemma 36 we have that ∀α ∈ (E ∩ S), α ∈ UAF(S, E),therefore (E ∩ S) ⊆ (UAF(S, E) ∩ C). Moreover, by the same lemma α is acceptablewith respect to (E ∩ S) in the argumentation framework AF↓UPAF(S,E). This, as wellas the fact that E is admissible and therefore conflict-free, entails that (E ∩ S) is ad-missible in the argumentation framework AF↓UPAF(S,E), and therefore that (E ∩ S) ∈AS(AF↓UPAF(S,E), UAF(S, E) ∩ C).As far as the other direction of the proof is concerned, we first notice that, by the hy-pothesis, ∀S ∈ SCCSAF (E ∩ S) ⊆ (UAF(S, E) ∩ C) ⊆ (S ∩ C), therefore E ⊆ C: in orderto prove the claim, we have only to show that E is admissible in AF.Let us first show that E is conflict-free by reasoning by contradiction, i.e., let us supposethat ∃α, β ∈ E: β → α. Let us denote SCCAF(α) as S. Clearly, it cannot be the case thatSCCAF(α) = SCCAF(β), since in this case (E ∩ S) would not be conflict-free, thus contra-dicting the hypothesis concerning its admissibility in AF↓UPAF(S,E). As a consequence,β ∈ (E ∩ outparentsAF(S)), therefore α ∈ DAF(S, E) by the definition of DAF(S, E).However, this contradicts the fact that α ∈ (E ∩ S), which according to the hypothesisis contained in UAF(S, E).In order to complete the proof, we have to prove that a generic α ∈ E is accept-able with respect to E, i.e., α ∈ FAF(E). If we denote SCCAF(α) as (cid:4)S, we have thatUPAF( ˆS,E), UAF((cid:4)S, E) ∩ C). There-α ∈ (E ∩ (cid:4)S ), and by the hypothesis (E ∩ (cid:4)S ) ∈ AS(AF↓fore, α ∈ UAF((cid:4)S, E), and α is acceptable with respect to (E ∩ (cid:4)S ) in AF↓UPAF((cid:4)S,E).Since the hypothesis entails that ∀S ∈ SCCSAF (E ∩ S) ∈ AS(AF↓UPAF(S,E), UAF(S, E)),190P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Lemma 37 can be applied to α, entailing that α is acceptable with respect to E in AF, i.e.,α ∈ FAF(E). (cid:1)5.4. Complete semanticsExploiting the results in previous subsection, the following proposition shows that alsocomplete extensions are in correspondence with a recursive decomposition along stronglyconnected components.Proposition 39. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsE ⊆ A, ∀C ⊆ A, E ∈ CE(AF, C) if and only if ∀S ∈ SCCSAF(E ∩ S) ∈ CE(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)Proof. As for the first direction of the proof, if E ∈ CE(AF, C) then in particular E ∈AS(AF, C), therefore Proposition 38 entails that(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)(E ∩ S) ∈ AS∀S ∈ SCCSAF(1)As a consequence, we have only to show that ∀α ∈ (UAF(S, E) ∩ C) such that α isacceptable with respect to (E ∩ S) in AF↓UPAF(S,E), α ∈ (E ∩ S). First, we noticethat Lemma 37 can be applied to α, since (1) entails that ∀S ∈ SCCSAF (E ∩ S) ∈AS(AF↓UPAF(S,E), UAF(S, E)). On the basis of this lemma, α is acceptable with respect toE in AF, i.e., α ∈ FAF(E). Moreover, α ∈ (UAF(S, E) ∩ C), therefore in particular α ∈ C.As a consequence, from the hypothesis that E ∈ CE(AF, C) it follows that α ∈ E andtherefore α ∈ (E ∩ S).As for the other direction of the proof, according to Definition 23 we have that ∀S ∈SCCSAF the following conditions hold:(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)(E ∩ S) ∈ AS(cid:2)UAF(S, E) ∩ C∀α ∈(cid:3): α ∈ FAF↓UPAF(S,E)(E ∩ S), α ∈ (E ∩ S)(3)Thus, on the basis of (2) Proposition 38 entails that E ∈ AS(AF, C), therefore we haveonly to prove that ∀α ∈ C such that α is acceptable with respect to E, α ∈ E, i.e., ∀α ∈C: α ∈ FAF(E), α ∈ E. Denoting SCCAF(α) as S, on the basis of Lemma 36 we have thatα ∈ UAF(S, E), so that α ∈ (UAF(S, E) ∩ C), and α is acceptable with respect to (E ∩ S)in AF↓UPAF(S,E), i.e., α ∈ FAF↓UPAF(S,E)(E ∩ S). Then, taking into account (3) we have thatα ∈ (E ∩ S), therefore α ∈ E. (cid:1)(2)5.5. Preferred semanticsAlso preferred extensions fit the decomposition schema along strongly connected com-ponents, as shown by Proposition 41 based on the following lemma.Lemma 40. Given an argumentation framework AF = (cid:2)A, →(cid:4), an admissible set E ∈AS(AF), and a strongly connected component S ∈ SCCSAF, let (cid:4)E be a set of argumentssuch that:P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210191• (E ∩ S) ⊆ (cid:4)E ⊆ UAF(S, E);• (cid:4)E is admissible in the argumentation framework AF↓UPAF(S,E),AS(AF↓UPAF(S,E)).i.e., (cid:4)E ∈It holds that (E ∪ (cid:4)E ) is admissible in AF, i.e., (E ∪ (cid:4)E ) ∈ AS(AF).Proof. First, we prove that (E ∪ (cid:4)E ) is conflict-free. Of course, (cid:4)E is conflict-free inAF↓UPAF(S,E) by the hypothesis, and, as a consequence, (cid:4)E is conflict-free also in AF.Since also E is conflict-free in AF by the hypothesis of admissibility, we have to prove that(cid:4)E (cid:12)→ E and E (cid:12)→ (cid:4)E. Since E is admissible in AF, (cid:4)E → E entails that E → (cid:4)E, thereforewe have only to prove that E (cid:12)→ (cid:4)E. Since (cid:4)E ⊆ UAF(S, E), (E ∩ outparentsAF(S)) (cid:12)→ (cid:4)E,therefore E → (cid:4)E only if (E ∩ S) → (cid:4)E. However, this situation is not possible since(E ∩ S) ⊆ (cid:4)E and (cid:4)E is conflict-free.Now, with reference to the argumentation framework AF we have to prove that ∀β ∈ Asuch that β → (E ∪ (cid:4)E ), it is the case that (E ∪ (cid:4)E ) → β. In case β → E, the con-clusion follows from admissibility of E. On the other hand, if β → (cid:4)E, we have thatβ ∈ (outparentsAF(S) ∪ S) since (cid:4)E ⊆ S; we distinguish three cases for β:(1) if β ∈ outparentsAF(S), then, taking into account that β → (cid:4)E and (cid:4)E ⊆ UAF(S, E), itmust be the case according to the definition of UAF(S, E) that E → β;(2) if β ∈ DAF(S, E), then according to the definition of DAF(S, E) it must be the casethat E → β;(3) if β ∈ UPAF(S, E), then β → (cid:4)E holds also in AF↓UPAF(S,E). As a consequence, thehypothesis that (cid:4)E ∈ AS(AF↓UPAF(S,E)) entails that (cid:4)E → β holds in AF↓UPAF(S,E),and, of course, that (cid:4)E → β also holds in AF.In any case, (E ∪ (cid:4)E ) → β, and the proof is completed. (cid:1)Proposition 41. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsE ⊆ A, ∀C ⊆ A, E ∈ PE(AF, C) if and only if ∀S ∈ SCCSAF(E ∩ S) ∈ PE(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)Proof. As far as the first direction of the proof is concerned, let us assume that E ∈PE(AF, C). By definition, E ∈ AS(AF, C), therefore, on the basis of Proposition 38, wehave that ∀S ∈ SCCSAF(E ∩ S) ∈ AS(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(cid:3)Let us now reason by contradiction, assuming that ∃(cid:4)S ∈ SCCSAF such that (E ∩ (cid:4)S ) isUPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C). Accordingnot maximal among the sets included in AS(AF↓to Theorem 25, there must be a set (cid:4)E such that• (E ∩ (cid:4)S ) (cid:2) (cid:4)E ⊆ (UAF((cid:4)S, E) ∩ C), and• (cid:4)E ∈ AS(AF↓UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C).192P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Taking into account that, according to the definition of AS(AF, C), E ∈ AS(AF),Lemma 40 entails that the set E(cid:16) (cid:1) E ∪ (cid:4)E is admissible in AF. Moreover, since bothE and (cid:4)E are contained in C we have that E(cid:16) ⊆ C, therefore E(cid:16) ∈ AS(AF, C). However, itis easy to see that E is strictly contained in E(cid:16), contradicting the maximality of E amongthe sets of AS(AF, C).Let us turn now to the other direction of the proof, assuming that ∀S ∈ SCCSAF,(E ∩ S) ∈ PE(AF↓UPAF(S,E), UAF(S, E) ∩ C). On the basis of Proposition 38, E ∈AS(AF, C): in order to prove that E is also a preferred extension, we reason again bycontradiction, supposing that ∃E(cid:16) ⊆ C, E (cid:2) E(cid:16): E(cid:16) ∈ PE(AF, C) (notice that the exis-tence of E(cid:16) is imposed by Theorem 25). Since E (cid:2) E(cid:16), there must be at least a stronglyconnected component S ∈ SCCSAF such that (E ∩ S) (cid:2) (E(cid:16) ∩ S): taking into account theacyclicity of the strongly connected components, there exists in particular (cid:4)S ∈ SCCSAFsuch that∀S ∈ SCCSAF: S ∈ sccancAF((cid:4)S),(E ∩ (cid:4)S ) (cid:2) (E(cid:16) ∩ (cid:4)S )(E(cid:16) ∩ S) = (E ∩ S)(4)(5)Note that condition (4) is trivially verified if (cid:4)S is initial.Since E(cid:16) ∈ AS(AF, C), on the basis of Proposition 38 we have that (E(cid:16) ∩ (cid:4)S ) ∈UPAF((cid:4)S,E(cid:16)), UAF((cid:4)S, E(cid:16)) ∩ C). Taking into account (4), it is easy to see that(E(cid:16) ∩ (cid:4)S ) ∈UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C). However, on the basis of (5) we have that (E ∩ (cid:4)S ) (cid:2)UPAF((cid:4)S,E), UAF((cid:4)S, E)AS(AF↓UAF((cid:4)S, E(cid:16)) = UAF((cid:4)S, E)AS(AF↓(E(cid:16) ∩ (cid:4)S ), and this contradicts the hypothesis that (E ∩ (cid:4)S ) ∈ PE(AF↓∩ C). (cid:1)and PAF((cid:4)S, E(cid:16)) = PAF((cid:4)S, E),therefore5.6. Grounded semanticsFinally, in this subsection, we prove that the decomposition schema also holds forgrounded semantics, as shown by the following Proposition 42.Proposition 42. Given an argumentation framework AF = (cid:2)A, →(cid:4) and a set of argumentsE ⊆ A, ∀C ⊆ A, E = GE(AF, C) if and only if ∀S ∈ SCCSAF(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(E ∩ S) = GE(cid:3)Proof. Let us consider the first part of the proof, by supposing that E = GE(AF, C). On thebasis of Proposition 30, E is in particular a complete extension in C, i.e., E ∈ CE(AF, C),therefore Proposition 39 entails that ∀S ∈ SCCSAF (E ∩S) ∈ CE(AF↓UPAF(S,E), UAF(S, E)∩ C). Taking into account Proposition 30, we have to prove that ∀S ∈ SCCSAF (E ∩ S) isthe least element (with respect to set inclusion) in CE(AF↓UPAF(S,E), UAF(S, E) ∩ C). Wereason by contradiction, supposing that there is at least one strongly connected componentwhere the thesis is not verified. In particular, since the strongly connected components ofAF make up an acyclic graph, we can choose (cid:4)S ∈ SCCSAF such that(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C(E ∩ S) = GE∀S ∈ sccancAF((cid:4)S),(6)(cid:3)P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210and(cid:2)∃ (cid:4)E (cid:2) (E ∩ (cid:4)S ), (cid:4)E = GEAF↓UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C(cid:3)Note that condition (6) is trivially verified if (cid:4)S is initial.193(7)Moreover, the second condition follows from the fact that, on the basis of Lemma 29,UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C) must exist, and according to Proposition 30 it is in-UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C).GE(AF↓cluded in all the elements of CE(AF↓Now, taking again into account that the strongly connected components of AF make upan acyclic graph, it is easy to see that it is possible to construct a set E(cid:16) such that:• ∀S ∈ sccancAF((cid:4)S), (E(cid:16) ∩ S) = (E ∩ S);• (E(cid:16) ∩ (cid:4)S ) = (cid:4)E;• ∀S ∈ SCCSAF, (E(cid:16) ∩ S) = GE(AF↓UPAF(S,E(cid:16)), UAF(S, E(cid:16)) ∩ C).(cid:3)To this purpose, it is obviously possible to construct a set E(cid:16)∗ contained in the strongly con-nected components of ((cid:4)S ∪ sccancAF((cid:4)S)) which satisfies the first two conditions. Thus,it turns out that ∀S ∈ ((cid:4)S ∪ sccancAF((cid:4)S)) UAF(S, E(cid:16)∗) =PAF(S, E). Therefore, taking into account (6) and (7), E(cid:16)∗ satisfies the third condition toofor any such S, i.e.,∗) = UAF(S, E) and PAF(S, E(cid:16)(E∀S ∈∗), UAF(S, E(cid:3)(cid:2)(cid:4)S ∪ sccancAF((cid:4)S)(cid:2)(cid:16)AF↓UPAF(S,E(cid:16)∗ ∩ S) = GENow, E(cid:16) can be obtained constructively from E(cid:16)∗ by proceeding along the other stronglyconnected components of the defeat graph: in fact ∀S ∈ SCCSAF GE(AF↓UPAF(S,E(cid:16)),UAF(S, E(cid:16)) ∩ C) always exists by Lemma 29.On the basis of Proposition 30, we have that ∀S ∈ SCCSAF (E(cid:16) ∩ S) ∈CE(AF↓UPAF(S,E(cid:16)), UAF(S, E(cid:16)) ∩ C). As a consequence, by Proposition 39 it turns out thatE(cid:16) ∈ CE(AF, C), while since (E(cid:16) ∩ (cid:4)S ) = (cid:4)E (cid:2) (E ∩ (cid:4)S ) it is not true that E ⊆ E(cid:16). However,this contradicts the hypothesis that E = GE(AF, C), which according to Proposition 30 isthe least element of CE(AF, C), i.e., the least complete extension in C.(cid:16)∗) ∩ CLet us turn now to the other direction of the proof, by supposing that ∀S ∈ SCCSAF,(E ∩ S) = GE(AF↓UPAF(S,E), UAF(S, E) ∩ C). On the basis of Proposition 30, we havethat ∀S ∈ SCCSAF, (E ∩ S) ∈ CE(AF↓UPAF(S,E), UAF(S, E) ∩ C), therefore Proposition 39entails that E ∈ CE(AF, C). As a consequence, taking into account Proposition 30 wehave only to prove that E is the least element of CE(AF, C). We reason by contradiction,assuming that the grounded extension E(cid:16) = GE(AF, C), which must exist by Lemma 29and is a subset of E by Proposition 30, is strictly included in E. Thus, there must be atleast a strongly connected component S such that (E(cid:16) ∩ S) (cid:2) (E ∩ S): since the stronglyconnected components form an acyclic graph, there is in particular a strongly connectedcomponent (cid:4)S such that:∀S ∈ sccancAF((cid:4)S),(cid:16) ∩ (cid:4)S ) (cid:2) (E ∩ (cid:4)S )(E(9)Moreover, since E(cid:16) = GE(AF, C) ∈ CE(AF, C), Proposition 39 applied to (cid:4)S entails thatUPAF((cid:4)S,E(cid:16)), UAF((cid:4)S, E(cid:16)) ∩ C). Taking into account (8), it is easy to(E(cid:16) ∩ (cid:4)S ) ∈ CE(AF↓(cid:16) ∩ S) = (E ∩ S)(8)(E194P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210see that UAF((cid:4)S, E(cid:16)) = UAF((cid:4)S, E) and PAF((cid:4)S, E(cid:16)) = PAF((cid:4)S, E), therefore (E(cid:16) ∩ (cid:4)S ) ∈UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C). However, according to (9) we have that (E(cid:16) ∩ (cid:4)S ) isCE(AF↓strictly included in (E ∩ (cid:4)S ), contradicting the hypothesis (referred to (cid:4)S) that (E ∩ (cid:4)S ) =UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C) and therefore, on the basis of Proposition 30, thatGE(AF↓(E ∩ (cid:4)S ) is the least element of CE(AF↓UPAF((cid:4)S,E), UAF((cid:4)S, E) ∩ C). (cid:1)5.7. Traditional semantics as SCC-recursive semanticsAs discussed in Section 4, each specific SCC-recursive semantics is identified by its ownbase function. On the basis of the results obtained in the previous sections, it is possibleto identify the base functions corresponding to the traditional semantics introduced in [9]and, thus, to definitely prove that these traditional semantics fit the general SCC-recursiveschema.Theorem 43. The stable, complete, preferred and grounded semantics are SCC-recursive,characterized by the following base functions (defined for generic argumentation frame-works AF such that |SCCSAF| = 1):• BF ST (AF, C) ≡ SE(AF, C);• BF CO(AF, C) ≡ CE(AF, C);• BF PR(AF, C) ≡ PE(AF, C);• BF GR(AF, C) ≡ {GE(AF, C)}.Proof. Let us prove the claim with reference to stable semantics. First, E ∈ SE(AF)if and only if E ∈ SE(AF, A), since as noticed in Section 5.1 Dung’s original defi-nitions are recovered from the extended ones in case C coincides with the set of allarguments. Now, it is easy to see that SE(AF, C) for generic AF and C adheres to Defin-ition 20: if |SCCSAF| = 1, then SE(AF, C) coincides by definition with the base functionBF ST (AF, C), otherwise the decomposition schema along the strongly connected com-ponents follows from Proposition 34.As far as complete, preferred and grounded semantics are concerned, proofs are similarand are based on Propositions 39, 41 and 42, respectively. (cid:1)For the grounded semantics, the base function admits a simple explicit formulation.Proposition 44. For any argumentation framework AF = (cid:2)A, →(cid:4) such that |SCCSAF| = 1,and for any C ⊆ A, we have thatBF GR(AF, C) ==(cid:6)(cid:5)GE(AF, C)(cid:7){{α}},{∅},if C = A = {α} and →= ∅;otherwise.Proof. According to Definition 28, GE(AF, C) is the least fixed point of FAF,C . Let usconsider its computation in the following exhaustive cases.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210195First, if C = ∅ then ∀E ⊆ A FAF,C(E) = ∅ by definition, obviously entailing that theempty set is the least fixed point of FAF,C and BF GR(AF, C) = {∅}.Second, if |A| > 1 then it must be the case that ∀α ∈ A, parentsAF(α) (cid:12)= ∅, since AFis made up of a unique strongly connected component, while an initial node would not bereachable from another one. As a consequence, taking into account the definition of FAF,C ,it turns that, ∀C ⊆ A,FAF,C(∅) = {α ∈ C | ∀β ∈ A: β → α, ∅ → β}= {α ∈ C | parentsAF(α) = ∅}= ∅As a consequence, the least fixed point of FAF,C is the empty set, therefore againBF GR(AF, C) = {∅}.The remaining case to be considered is A = C = {α}. There are only two possibili-ties for the attack relation, namely either →= {(α, α)} or →= ∅. The first situation canbe treated as in the previous case, since the unique node α is not initial, yielding againBF GR(AF, C) = {∅}. In the other situation, i.e., C = A = {α} and →= ∅, it is easy to seethat FAF,C({α}) = {α} and FAF,C(∅) = {α}, therefore the least fixed point of FAF,C is madeup of the unique node α and BF GR(AF, C) = {{α}}. (cid:1)6. General properties of SCC-recursive semanticsHaving proved that SCC-recursiveness is general enough to include traditional seman-tics, we now show that it is also restrictive enough to ensure that the basic desirableproperties of an extension are satisfied by any SCC-recursive semantics, provided that verysimple and intuitive constraints on the base function are respected.6.1. Conflict-free propertyAs stated in Section 2.2, a basic requirement of any extension is the absence of conflicts,as expressed by the following definition:Definition 45. A semantics S satisfies the conflict-free property if and only if ∀AF, ∀E ∈ES (AF) E is conflict-free.Clearly, a necessary condition for a given SCC-recursive semantics to be conflict-freeis that its base function is conflict-free:Definition 46. The base function GF ∗and only if ∀AF = (cid:2)A, →(cid:4) and ∀C ⊆ A each element of BF S (AF, C) is conflict-free.S of a SCC-recursive semantics S is conflict-free ifWe also prove that this is a sufficient condition.196P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Proposition 47. Let S be a SCC-recursive semantics identified by the base function GF ∗S .If GF ∗S is conflict-free, then ∀AF = (cid:2)A, →(cid:4) and ∀C ⊆ A the elements of the functionGF(AF, C) based on GF ∗S are conflict-free as well.Proof. Let us consider a generic argumentation framework AF = (cid:2)A, →(cid:4) and a genericset C ⊆ A: we have to prove that, given a generic E ∈ GF(AF, C), E is conflict-free.Given the recursive characterization of E as in Definition 20, we first prove the claim inthe base case, namely |SCCSAF| = 1, then we assume as an inductive hypothesis that theclaim holds for any S ∈ SCCSAF at the level of AF↓UPAF(S,E) and show that this hypothesisentails the claim at the level of AF.If |SCCSAF| = 1, then, by Definition 20, E ∈ BF S (AF, C), and therefore is conflict-free by the hypothesis.In the other case, namely |SCCSAF| > 1, the inductive hypothesis can be expressed as∀S ∈ SCCSAF (E ∩ S) is conflict-free in AF↓UPAF(S,E)(10)Let us reason by contradiction, assuming the existence of two elements α, β ∈ E such thatα → β, and let us indicate SCCAF(β) as S. Clearly, α /∈ S, otherwise (E ∩ S) would notbe conflict-free in AF↓UPAF(S,E). As a consequence, α ∈ outparentsAF(S) ∩ E. However,this would entail that β ∈ DAF(S, E) by definition of DAF(S, E), while since β ∈ E thiswould contradict the fact that (E ∩ S) ⊆ UPAF(S, E), prescribed by (10). (cid:1)Theorem 48. Given a SCC-recursive semantics S, if its base function GF ∗then S satisfies the conflict-free property.S is conflict-freeProof. Since, according to Definition 20, any extension E ∈ ES (AF) belongs to GF(AF,A), the claim easily follows from Proposition 47 applied with C = A. (cid:1)6.2. Agreement with the grounded semanticsAs discussed in Section 2.2, the grounded semantics represents a sort of lower boundamong argumentation semantics, since in Dung’s framework the grounded extension isthe least among all conceivable extensions, namely complete extensions. More generally,the agreement with grounded semantics can be regarded as a fundamental requirementfor any argumentation semantics, as it appears evident considering the constructive char-acterization of grounded semantics recalled in the same subsection. As a confirmation ofthe well-foundedness of the property of SCC-recursiveness, we prove in Theorem 52 thatfor any SCC-recursive semantics each of its extensions includes the grounded extension,provided that a very simple condition on the base function is satisfied.First, we prove a general property of the SCC-recursive schema showing that inclusionbetween extensions entails inclusion relations between the elements of the partitions ofstrongly connected components introduced in Definition 18.Lemma 49. Given an argumentation framework AF = (cid:2)A, →(cid:4), let E1, E2 ⊆ A be two setsof arguments such that E1 ⊆ E2 and E2 is conflict-free (and therefore also E1). For anystrongly connected component S ⊆ SCCSAF, it holds that:P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210197• DAF(S, E1) ⊆ DAF(S, E2);• UPAF(S, E2) ⊆ UPAF(S, E1);• UAF(S, E1) ⊆ UAF(S, E2).Proof. As to the first point, we have by definition that DAF(S, E1) = {α ∈ S | (E1 ∩outparentsAF(S)) → α}. Since E1 ⊆ E2, it must be the case that DAF(S, E1) ⊆ {α ∈ S |(E2 ∩ outparentsAF(S)) → α} ≡ DAF(S, E2).The above result easily entails the second one, taking into account that UPAF(S, E2) =(S \ DAF(S, E2)): by the first point, (S \ DAF(S, E2)) ⊆ (S \ DAF(S, E1)) = UPAF(S, E1).As to the third point, let us first prove that(cid:3)(cid:2)E2 ∩ outparentsAF(S)∀α ∈ UAF(S, E1),(11)We reason by contradiction, assuming that ∃α ∈ UAF(S, E1), β ∈ (E2 ∩ outparentsAF(S)):β → α. In this case, we have in particular that β ∈ (outparentsAF(S) ∩ parentsAF(α)),therefore, according to the definition of UAF(S, E1) applied to α, E1 → β. However, sinceE1 ⊆ E2, also E2 → β holds, with β ∈ E2, contradicting the hypothesis that E2 is conflict-free.(cid:12)→ αNow, it is easy to see that∀α ∈ UAF(S, E1), ∀β ∈(cid:2)(cid:3)outparentsAF(S) ∩ parentsAF(α), E2 → β(12)since by definition of UAF(S, E1) applied to α we have that E1 → β and E1 ⊆ E2.Finally, on the basis of (11) and (12) it turns out that ∀α ∈ UAF(S, E1) (E2 ∩i.e., α ∈outparentsAF(S)) (cid:12)→ α ∧ ∀β ∈ (outparentsAF(S) ∩ parentsAF(α)) E2 → β,UAF(S, E2). (cid:1)The following lemma shows that an inclusion relation between two sets C1 and C2 alsoholds between the grounded extensions in C1 and C2, even if the latter is referred to arestricted argumentation framework.Lemma 50. Let AF1 = (cid:2)A1, →1(cid:4) and AF2 = (cid:2)A2, →2(cid:4) be two argumentation frameworkssuch that AF2 = AF1↓A2 . Given two sets C1 and C2 such that C1 ⊆ C2 ⊆ A2 ⊆ A1,GE(AF1, C1) ⊆ GE(AF2, C2).Proof. First, let us consider the characteristic functions FAF1,C1 and FAF2,C2 , respectivelydefined in 2C1 and 2C2 (with 2C1 ⊆ 2C2 ). We prove that, given two sets E1 ⊆ C1 andE2 ⊆ C2if E1 ⊆ E2then FAF1,C1(E1) ⊆ FAF2,C2 (E2)(13)Let us consider a generic element α ∈ FAF1,C1 (E1): by definition, α ∈ C1 and α is ac-ceptable with respect to E1 in AF1. Since C1 ⊆ C2, α ∈ C2, therefore to prove thatα ∈ FAF2,C2 (E2) we have only to show that α is acceptable with respect to E2 in AF2. Tothis purpose, let us consider a generic argument β ∈ A2 which attacks α in AF2, i.e., β ∈(α).parentsAF2Since α is acceptable with respect to E1 in AF1, E1 → β in AF1, and taking into account(α). Clearly, since A2 ⊆ A1, β attacks α also in AF1, i.e., β ∈ parentsAF1198P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210that E1 ⊆ C1 ⊆ A2 it is easy to see that E1 → β holds also in AF2. Moreover, E1 ⊆ E2,therefore we get the desired conclusion that E2 → β in AF2.(cid:8)Now, by extending an analogous result proved by Dung (see [9], pp. 342) in caseAF1 and AF2 are finitary, i.e., such that every argument has a finite number of de-(∅)featers, GE(AF1, C1) and GE(AF2, C2) can be respectively expressed as(∅): in order to prove the thesis, we show by induction on i thatand∀i (cid:2) 1 Fi(∅). The proof can be extended to the general case by us-ing transfinite induction on ordinal numbers instead of ordinary induction, however weresort to the latter for simplicity.(∅) ⊆ Fii(cid:1)1 Fii(cid:1)1 FiAF1,C1AF1,C1AF2,C2AF2,C2(cid:8)As for the base case, according to (13) FAF1,C1 (∅) ⊆ FAF2,C2 (∅), since obviously(∅): as a con-(∅)),∅ ⊆ ∅ ⊆ C1. In the induction step, we assume that Fisequence, on the basis of (13) it turns out that FAF1,C1 (Fii.e., Fi+1AF1,C1(∅), and the proof is complete. (cid:1)(∅) ⊆ FiAF2,C2(∅)) ⊆ FAF2,C2(Fi(∅) ⊆ Fi+1AF2,C2AF1,C1AF1,C1AF2,C2We now show that the agreement with grounded semantics is ensured if the base func-tion properly deals with the simplest possible case of argumentation framework, i.e., asingle node which does not attack itself and therefore should be justified.Proposition 51. Let S be a SCC-recursive semantics identified by a conflict-free base func-tion GF ∗S such that(cid:10)(cid:2)(cid:9)BF S{α}, ∅, {α}=(cid:3)(cid:6)(cid:5){α}For any argumentation framework AF = (cid:2)A, →(cid:4) and for any set C ⊆ A, it holds that∀E ∈ GF(AF, C), GE(AF, C) ⊆ Ewhere GF(AF, C) is the recursive function of the SCC-recursive schema characterized bythe base function GF ∗S .Proof. Given a generic AF = (cid:2)A, →(cid:4) and a set C ⊆ A, let us consider a generic set E ∈GF(AF, C): we have to prove that GE(AF, C) ⊆ E. Let us distinguish two cases for theargumentation framework AF.First, if SCCSAF = 1, then the base case of the recursive definition applies to E, i.e.,according to Definition 20 E ∈ BF S (AF, C). Of course, if GE(AF, C) is the empty setthen the thesis trivially holds for E. On the basis of Proposition 44, GE(AF, C) is nonempty only if AF = (cid:2){α}, ∅(cid:4) and C = {α}, and it turns out that GE(AF, C) = {α}. By thehypothesis, in this case BF S (AF, C) = {{α}}, thus the only possible case for E is E = {α},obviously entailing that GE(AF, C) ⊆ E.Let us now consider the case where SCCSAF > 1. Taking into account the recursivedefinition of E according to Definition 20 and the proof for the case |SCCSAF| = 1, wecan recursively assume that, if |SCCSAF| > 1, the thesis holds at the level of restrictedargumentation frameworks:(cid:2)∀S ∈ SCCSAF, GEAF↓UPAF(S,E), UAF(S, E) ∩ C⊆ (E ∩ S)(14)(cid:3)P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210199In order to simplify the notation, let us indicate GE(AF, C) as E∗: we proceed inductivelyalong the strongly connected components of the argumentation framework, by proving that∀S ∈ SCCSAF,(E∗ ∩ S) ⊆ (E ∩ S)which obviously entails the claim. Let us first notice that, according to Proposition 42∀S ∈ SCCSAF,(E(cid:2)∗ ∩ S) = GEAF↓UPAF(S,E∗), UAF(S, E(cid:3)∗) ∩ C(15)In the basis case, we consider the initial strongly connected components, namely we refer toa generic S ∈ SCCSAF such that sccparentsAF(S) = ∅, entailing that outparentsAF(S) = ∅.This, in turn, entails that, for any set E, DAF(S, E) = PAF(S, E) = ∅ and UAF(S, E) = S.As a consequence, according to (15) we have that (E∗ ∩ S) = GE(AF↓S, S ∩ C), which isin turn equal to GE(AF↓UPAF(S,E), UAF(S, E) ∩ C). Since by (14) the latter is containedin (E ∩ S), we get the desired result that (E∗ ∩ S) ⊆ (E ∩ S).In the inductive step, we can assume that∀P ∈ sccancAF(S),∗ ∩ P ) ⊆ (E ∩ P )(ENow, since E is conflict-free by Proposition 47 and the definitions of UAF(S, E) andPAF(S, E) only depend on the subset of E contained in the strongly connected compo-nents of sccancAF(S), Lemma 49 can be applied obtainingUAF(S, E∗) ⊆ UAF(S, E)andUPAF(S, E) ⊆ UPAF(S, E∗)On the basis of these results, it is possible to apply Lemma 50 with– AF1 = AF↓UPAF(S,E∗),– AF2 = AF↓UPAF(S,E) = AF1↓UPAF(S,E),– C1 = UAF(S, E∗) ∩ C,– C2 = UAF(S, E) ∩ Cobtaining(cid:2)AF↓UPAF(S,E∗), UAF(S, EGE∗) ∩ C(cid:3)(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ C⊆ GE(cid:3)Now, on the basis of (15) we have that(cid:2)∗ ∩ S) = GEAF↓UPAF(S,E∗), UAF(S, E(cid:3)∗) ∩ C(Ewhile by (14)(cid:2)AF↓UPAF(S,E), UAF(S, E) ∩ CGEentailing that (E∗ ∩ S) ⊆ (E ∩ S). (cid:1)(cid:3)⊆ (E ∩ S)Theorem 52. Let S be a SCC-recursive semantics identified by a conflict-free base functionGF ∗S such thatBF S(cid:2)(cid:9)(cid:10)(cid:3){α}, ∅, {α}=(cid:6)(cid:5){α}For any argumentation framework AF = (cid:2)A, →(cid:4), ∀E ∈ ES (AF), GE(AF) ⊆ E.200P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210Proof. The theorem directly follows from Proposition 51 applied in the case C = A, takinginto account that ES (AF) = GF(AF, A) and GE(AF) = GE(AF, A). (cid:1)Thanks to the above properties, defining an SCC-recursive semantics which is sound,i.e., conflict-free and in agreement with the grounded semantics, turns out to be a rela-tively easy task. In fact, in order for these properties to be satisfied it is sufficient thatthe base function is conflict-free and correctly treats the case of a single node without de-featers. In the following section we exploit the SCC-recursive schema to introduce fournovel semantics which can cope in different ways with the problematic examples affectingpreferred semantics. These semantics are introduced mainly for the purpose of demon-strating the potential of SCC-recursiveness: the possibility of defining novel semantics in arather straightforward way confirms that our formalism is a sound basis for further studiesin the spirit of the analysis of Section 3, where the need of a framework encompassing alarge variety of semantics has been pointed out. In this sense, the semantics presented inthe following section can be regarded more as illustrative than as definitive achievements:they represent an initial excursion in the space of SCC-recursive semantics, whose deeperand more complete exploration is indeed an interesting subject for future work. The defin-ition of the semantics is deliberately example-driven; however, at a more general level, thefour semantics are related by an underlying conceptual analysis, whose outcome seems tosuggest that, in the SCC-recursive context, simpler base functions are better.7. Supporting the definition of novel argumentation semanticsThe results of the previous section suggest that relatively simple base functions areappropriate in the context of our SCC-recursive schema. Therefore, our search of novelinteresting SCC-recursive semantics is driven by the idea of defining base functions basedon progressively simpler concepts. Accordingly, we adopt preferred semantics as a startingpoint, and we use the focused survey presented in Section 2.2 as a guideline, by followingit backward from more articulated concepts to the basic ones.7.1. Beyond preferred semanticsIn this subsection, we explore solutions which preserve the fundamental notion ofdefense, formally represented by the property of admissibility in Dung’s framework; com-plete admissible sets, i.e., complete extensions, are regarded as the most general familyof conceivable extensions in this context. As shown by Theorem 43, the recursive schematurns out to completely include this framework, since all complete extensions are recur-sively characterized. Therefore, considering the recursive schema does not introduce anylimitation in this respect.Since preferred extensions are maximal admissible sets, in order to devise an alternativeadmissibility-based proposal the only possible way is giving up the requirement of max-imality. Let us start our analysis by recalling the argumentation framework of Fig. 7(a),where the argument ¬rain turns out to be questionably justified according to preferred se-mantics. First of all, note that in any semantics based on the concept of admissibility, noneP. Baroni et al. / Artificial Intelligence 168 (2005) 162–210201of the arguments S, R, or J can be included in any extension, since any of them attacks itsonly possible defender. As a consequence, also rain cannot be included in any extension,since it cannot be defended against its defeater J . Therefore, the only complete extensionsof the argumentation framework AF of Fig. 7(a) are {¬rain} and ∅. While preferred se-mantics prescribes {¬rain} as the only extension, we aim at finding a semantics S whosedefinition admits the empty set as extension. Adopting the general SCC-recursive schemato identify such definition, we are led to investigate E ∩ S for all S ∈ SCCSAF = {S1, S2},where S1 = {R, S, J } and S2 = {rain, ¬rain}, as explained in Section 4. In particular, sincefor any complete extension E we have that (E ∩ S1) = ∅, it is necessarily the case thatPAF(S2, E) = {rain} and UAF(S2, E) = {¬rain}. As a consequence, Definition 20 yields(E ∩ S2) ∈ BF S (AF↓S2 , {¬rain}), and, therefore, we must look for a base function suchthat BF S (AF↓S2 , {¬rain}) = {∅}.A hint to obtain this property in general comes from the local correction to stable se-mantics sketched in Section 2.2, where the empty set is selected as an extension when thereis no set of nodes able to attack all the others. Similarly, we might select the empty set asan extension when the nodes of a restricted argumentation framework are not all defended,i.e., do not all belong to the set C. Formally, we impose to the base function that if C (cid:2) Athen BF S (AF, C) = {∅}. Taking this for granted, to complete the definition of the basefunction only the case where C = A remains to be specified. To this purpose, the moredirect approach is to consider the set of preferred extensions, thus obtaining the followingbase function (we denote the corresponding semantics as AD1):BF AD1(AF, C) =(cid:7)PE(AF, C){∅}if C = AotherwiseIt is easy to see that AD1 semantics solves the problem related to the argumen-tation framework of Fig. 7(a). In fact, on the first strongly connected component,BF AD1(AF↓S1 , S1) is invoked, which returns the set of preferred extensions of AF↓S1 :PE(AF, S1) = {∅}. Then, as explained above, BF AD1(AF↓S2 , {¬rain}) is invoked, whichalso returns {∅} as result. Summarizing we have that, for any possible extension E,E ∩ S1 = ∅ and E ∩ S2 = ∅, yielding the empty set as the unique extension of the wholeargumentation framework.However, AD1 fails with the argumentation framework presented in Fig. 8(a). In fact,in this case we have a single strongly connected component, and, therefore, AD1 inheritsfrom preferred semantics the counter-intuitive behavior discussed in Section 3, identifyingas the unique extension the set {α, φ}, which is also a stable extension. To overcome thisproblem, we need to rule out {α, φ} as an extension. Note that the only defeater of bothα and φ is γ , therefore the node γ should retain the capability of preventing α and φ tobe justified. Noting that one of the defeaters of γ , actually β, is not included in the exten-sion, to obtain the desired behavior we take a further step going back to a notion of more“aggressive” behavior, which strengthens the requirement of attacking all external nodes,typical of stable semantics. More precisely, we require that an extension fully attacks itsdefeaters, i.e., it includes all the defeaters of its defeaters. In particular, {α, φ} does notsatisfy this condition since it does not include β, while ∅ trivially satisfies it. These consid-202P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210erations lead to define the following base function (we denote the corresponding semanticsas AD2):(cid:7)BF AD2(AF, C) ={E | E maximal in AS∗AF{∅}}if C = AotherwisewhereAS∗AF=(cid:5)F ∈ AS(AF) | ∀α ∈ A: α → F, parentsAF(α) ⊆ F(cid:6)It can be verified that AD2 preserves the desired behavior in all cases presented inFigs. 1–8.Considering first the problematic example for AD1 of Fig. 8(a), the argumentationframework consists of a unique strongly connected component, and BF AD2(AF, A) istherefore invoked. Now AS∗= {∅}, as explained above, and therefore its only maximalAFset is ∅ which coincides with the unique extension.On the other hand, the behavior of AD1 is preserved in the case of the argumentationframework of Fig. 7(a). After recalling that it consists of two strongly connected compo-nents S1 = {R, S, J } and S2 = {rain, ¬rain}, it can be seen that the only admissible set inAF↓S1 is the empty set, which obviously belongs to AS∗. Then UAF(S2, ∅) = {¬rain},PAF(S2, ∅) = {rain}, and, as for AD1, (E ∩ S2) is determined by BF AD2(AF↓S2 , {¬rain}),which yields the empty set since C (cid:12)= A.AF↓S1In the other cases, it turns out that AD1 and AD2 prescribe the same extensions aspreferred semantics, whose behavior is fully justified from an intuitive point of view. Wedescribe in the following the treatment of these cases in order to provide other examples ofapplication of the SCC-recursive schema: since in all these cases BF AD2(AF, C) coincideswith BF AD1(AF, C), we will refer to AD2 only.The treatment of the argumentation framework of Fig. 3(a) is similar to that of Fig. 7(a),since, again, E ∩ S1 = ∅ with S1 = {R, S, J }, and, letting S2 = {rain}, then PAF(S2, ∅) =S2 and (E ∩ S2) is determined by BF AD2(AF↓S2 , ∅), yielding the empty set as the uniqueextension.As for the argumentation framework presented in Fig. 1, recall that its strongly con-nected components coincide with all the singletons. First, the base function will be invokedon the initial strongly connected component, obtaining BF AD2(AF↓{α}, {α}) = {{α}}.Then, DAF({β}, {α}) = {β} and the base function will be invoked in the trivial case ofan empty argumentation framework: BF AD2(AF↓∅, ∅) = {∅}, thus excluding β from anyextension. Then, for any E, UAF({γ }, E) = {γ }, and iterating the same reasoning as abovewe obtain the inclusion of γ and then the exclusion of δ from the (unique) extension ofAF.The argumentation frameworks presented in Figs. 2, 5, and 8(b) consist of a uniquestrongly connected component, therefore in all these cases the following invocation of thebase function applies: BF AD2(AF, A). It is easy to see that, in all cases, the set of maximalelements of AS∗AF coincide with the set of preferred extensions.A very similar reasoning applies to the argumentation framework of Fig. 4, whose twostrongly connected components are both initial. Letting S1 = {α, β, γ } and S2 = {δ} andapplying the base function to both of them we obtain, for any possible E, E ∩ S1 = ∅ andE ∩ S2 = {δ}, therefore {δ} is the unique resulting extension.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210203As to the argumentation framework of Fig. 3(b), first the base function is applied tothe initial strongly connected component S1 = {P , R, J, S}. Also in this case it is easyto see that the sets {R, S} and {P , J }, besides being the preferred extensions of the re-stricted argumentation framework AF↓S1 , are the maximal sets of AS∗. Consideringthe propagation of the two possible choices to the second strongly connected componentS2 = {rain}, we have in the former case UAF(S2, {R, S}) = S2 and therefore the invoca-tion BF AD2(AF↓S2 , S2) returning {rain}, while in the latter case DAF(S2, {P , J }) = S2and therefore the invocation BF AD2(AF↓∅, ∅) returning {∅}. Thus the same extensions{R, S, rain} and {P , J } are obtained as in preferred semantics.AF↓S1A similar reasoning applies to the example of Fig. 7(b). Given the partition S1 ={P , R, J, S} and S2 = {rain, ¬rain}, the possible choices for E ∩ S1 are {R, S} and{P , J }. In the former case, UAF(S2, {R, S}) = S2 and since S2 is a Nixon diamond,analogously to the case of Fig. 5, the possible choices for E ∩ S2 are {rain} and{¬rain}. In the latter case DAF(S2, {P , J }) = {rain} and UAF(S2, {P , J }) = {¬rain}, thenBF AD2(AF↓{¬rain}, {¬rain}) is invoked, obviously giving {¬rain} as result. Summing up,again the same extension as in preferred semantics are obtained, namely: {R, S, rain},{R, S, ¬rain}, and {P , J, ¬rain}.In the argumentation framework of Fig. 6 the initial strongly connected componentS1 = {α, β} is a Nixon diamond, thus, analogously to the case of Fig. 5, the possible choicesfor E ∩ S1 are {α} and {β}. Independently of this choice, considering the second stronglyconnected component S2 = {γ }, it holds that DAF(S2, E) = S2 therefore E ∩ S2 = ∅.Consequently, for the last strongly connected component S3 = {δ}, UAF(S3, E) = S3 andE ∩ S3 = S3. Therefore also in this case the same extensions {α, δ} and {β, δ} are obtainedas in preferred semantics.It is interesting to note that the requirement of including in an extension all of the de-featers of a node which attacks the extension, imposed in the base function of AD2, wouldbe harmful rather than useful outside the SCC-recursive schema: examples can easily befound where even initial nodes would not be justified. However, the SCC-recursive defini-tion rules the behavior of the semantics in such a way as to exploit this constraint correctly.Finally, we show in Proposition 53 that both AD1 and AD2 fit in Dung’s framework, asall their extensions are actually complete extensions.Proposition 53. For any argumentation framework AF = (cid:2)A, →(cid:4), the extensions pre-scribed by AD1 and AD2 are complete extensions.Proof. According to the characterization of complete semantics as SCC-recursive givenin Theorem 43, any set E which is decomposable according to Definition 20 with a basefunction whose elements belong to CE(AF, C) is a complete extension. Therefore, to provethe claim it is sufficient to show that the base functions introduced for AD1 and AD2 giveelements belonging to CE(AF, C) for any AF (consisting of a unique strongly connectedcomponent) and C.Considering first AD1, we distinguish two cases for the base function. If C = A, thenBF AD1(AF, C) = PE(AF, C), and the conclusion directly follows from Proposition 31. Inthe other case, i.e., C (cid:2) A, BF AD1(AF, C) = {∅}, therefore we have to prove that ∅ is acomplete extension in C: since ∅ is obviously admissible in C, the only thing to show is204P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210that any α ∈ C is not acceptable with respect to ∅. This trivially holds if C = ∅. Otherwise,a generic α ∈ C could only be acceptable with respect to ∅ if parentsAF(α) = ∅. However,this is impossible, since α ∈ C and C (cid:2) A: taking into account that the argumentationframework admits a unique strongly connected component, there must be an argumentβ ∈ A, β (cid:12)= α such that β → α.Let us turn now to AD2-semantics, and let us notice that, if C (cid:2) A, the relevant basefunction coincides with that of AD1-semantics, therefore the proof proceeds as in the pre-vious case. If instead C = A, then by definition any E ∈ BF AD2(AF, C) is a maximalelement of AS∗AF, i.e., it is a maximal set such that it is admissible in AF and the followingproperty holds:∀β ∈ A: β → E, parentsAF(β) ⊆ E(16)Since C = A and E is admissible, we have only to prove that ∀α ∈ A which is acceptablewith respect to E, α ∈ E. We reason by contradiction, assuming that ∃ ˆα ∈ A: ˆα /∈ E andˆα is acceptable with respect to E. In case E = ∅, the acceptability of ˆα would entail thatparentsAF( ˆα) = ∅, and therefore the set { ˆα} would be admissible. However, { ˆα} wouldclearly belong to AS∗AF, contradicting the maximality of E = ∅. Therefore, let us nowassume that E (cid:12)= ∅. Recalling that ˆα /∈ E and that |SCCSAF| = 1, there must exist a pathbetween ˆα and any element of E. In particular, there must be an element γ ∈ E such thatthe path from α to γ does not include other elements of E. In fact, since ˆα is acceptablewith respect to E, Lemma 35 entails that ˆα (cid:12)→ E, and the above mentioned path musthave the following structure: ˆα → β1 → · · · → βn → γ , with n (cid:2) 1, such that γ ∈ E andβi /∈ E for all i: 1 (cid:3) i (cid:3) n. In particular, this entails that βn → E and parentsAF(βn) (cid:3) E,contradicting (16). (cid:1)7.2. Beyond admissibilityIn the previous subsection, we have identified the suppression of the requirement ofmaximality among complete extensions as a possible way to solve the problems affectingpreferred semantics, while preserving the notion of admissibility. As already explained,in any admissibility-based semantics odd-length cycles admit only the empty extension,while handling floating defeat as in Fig. 6 requires multiple extensions for even-lengthcycles. As a consequence, both AD1 and AD2, as well as other possible proposals inspiredto the same ideas, feature an asymmetry in the treatment of cycles. In this subsection,we follow the idea that this asymmetry is the primary cause of questionable behaviors ofpreferred semantics and should be avoided to allow alternative treatments of cycles.Let us investigate the definition of a semantics driven by this perspective. Consider againthe simple case of a three length-cycle shown in Fig. 2: in order to enforce a symmetrictreatment of cycles, we need to look for a possible set of non-empty extensions for thisargumentation framework. To this purpose, note that, in order to preserve the conflict-freeproperty, each extension has to include exactly one node. Moreover, obvious symmetryreasons entail that all nodes should be treated equally, therefore the only possibility is toidentify as extensions the three sets {α}, {β} and {γ }.Two general hints can be drawn from this simple example. First, it appears that our di-rection of investigation cannot be constrained by the admissibility requirement, since, inP. Baroni et al. / Artificial Intelligence 168 (2005) 162–210205the considered example, the only sets that can be identified as extensions are not admissi-ble. Second, it turns out that these extensions coincide with the maximal conflict-free setsof the argumentation framework (see Definition 6), and the same holds in the even-lengthcycle case. This suggests to exploit the notion of maximal conflict-free set as a basis fora new definition of extension. In a sense, this corresponds to the final step in our routefrom articulated concepts to basic ones, since the notion of conflict-free set has been thestarting point of the survey in Section 2.2 and the conflict-free property is, actually, themost fundamental assumption underlying any definition of extension, that could never beremoved.The above intuition is confirmed by the fact that, by identifying the extensions as themaximal conflict-free sets, the problematic cases shown in Fig. 7 and Fig. 8 are handledcorrectly, since in all cases the intersection of maximal conflict-free sets is empty yieldingall arguments not justified. However, as already discussed in Section 2.2, this intuitionalone would not represent a satisfactory solution, since, due to the increased number ofextensions prescribed, it would tend to assign the status of provisionally defeated to a largenumber of arguments, often to all of them. In other words, replacing the admissibilityrequirement with the less demanding notion of maximal conflict-free set requires somefurther condition in order to properly constrain the set of extensions prescribed by thesemantics, i.e., to capture only a subset of the maximal conflict-free sets.As a matter of fact, the SCC-recursive schema directly offers the solution to this diffi-culty: as it will be shown in the following, simply requiring that the semantics S is SCC-recursive represents an appropriate additional condition. To this purpose, let us consideragain the example of Fig. 2 involving the three-length cycle. In this case, |SCCSAF| = 1,therefore, according to Definition 20, the base function, applied to the set of all argu-ments, directly returns the set of the extensions. As a consequence, identifying exten-sions as the maximal conflict-free sets yields BF S (AF, A) = MCF AF. Generalizing thisidea, we obtain the specification of the base function for the case where C = A, i.e.,BF S (AF, C) = MCF AF. Taking this for granted, to complete the definition of the basefunction only the case where C (cid:2) A remains to be specified. In this respect, it seemsreasonable to exploit again the notion of maximal conflict-free set to provide a uniformconceptual basis to the approach. Two ways of applying this notion can be envisaged, de-pending on the role ascribed to the set C of defended nodes.On the one hand, one may regard the inclusion of all the arguments in C as a require-ment, preserving, as far as possible, the role of defense in the base function. This gives riseto the following definition (we denote the corresponding semantics as CF1):BF CF1(AF, C) = MCF AF↓COn the other hand, one may note that the perspective we are following is based on theassumption that the concept of defense is unnecessary in some cases, since the nodes of athree-length cycle are admitted as extensions though not being able to defend themselves.Generalizing from this remark, one may regard the notion of defense as definitely unneces-sary. This leads to consider the following base function, where the requirement of inclusionof the arguments in C is overlooked (we denote as CF2 the corresponding semantics, firstproposed in our [4]):BF CF2(AF, C) = MCF AF206P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210It can be seen that both CF1 and CF2-semantics are able to treat appropriately all argu-mentation frameworks presented in Figs. 1–8, as it was the case for AD2. To give a detailedaccount of the proposed semantics, we analyze their treatment of the argumentation frame-work of Fig. 7(a).6Recall that SCCSAF = {S1, S2} with S1 = {R, S, J } and S2 = {rain, ¬rain}. As for S1,which is an initial strongly connected component, the base case of Definition 20 applies,yielding (E ∩ S1) ∈ BF S (AF↓S1 , S1). Therefore, according to CF1-semantics (E ∩ S1)must belong to MCF AF↓C with AF = AF↓S1 and C = S1, which is of course equal toMCF AF↓S1. This is the same set prescribed by CF2-semantics, therefore the two semantics= {{S}, {R}, {J }}, leading to three alternative possi-agree in this case. Now, MCF AF↓S1bilities for (E ∩ S1). Assuming that (E ∩ S1) = {J }, we have that DAF(S2, E) = {rain},UAF(S2, E) = {¬rain} and PAF(S2, E) = ∅. Therefore, the base function is applied tothe argumentation framework AF↓{¬rain} with C = {¬rain}, yielding for both semantics(E ∩ S2) = {¬rain}. Therefore, we have an extension E1 = {J, ¬rain} for both semantics.Let us turn now to the alternative (E ∩ S1) = {R}, which entails that UAF(S2, E) = S2 (asJ is attacked by R ∈ E). Then, the base function is applied to the argumentation frame-work AF↓S2 with C = S2: it is easy to see that both semantics give two alternatives for(E ∩ S2), namely {rain} and {¬rain}. Therefore, we have for both CF1 and CF2 the ad-ditional extensions E2 = {R, rain} and E3 = {R, ¬rain}. Finally, if (E ∩ S1) = {S}, wehave that PAF(S2, E) = {rain}, UAF(S2, E) = {¬rain} and DAF(S2, E) = ∅. Then, thebase function is applied to the argumentation framework AF↓S2 with C = {¬rain}. Inthis case, CF1 and CF2-semantics differ. In fact, CF1 gives MCF AF↓C which is equal toMCF AF↓{¬rain} , therefore (E ∩ S2) = {¬rain}, giving E4 = {S, ¬rain}. On the other hand,= {{rain}, {¬rain}}, yielding therefore the same extension E4 asCF2 gives MCF AF↓S2CF1 and an additional extension E5 = {S, rain}.In spite of this difference, both semantics provide the intuitively desirable result: noargument is justified, since the intersection of all extensions is empty. A similar treatmentis provided by CF1 and CF2 to the argumentation framework of Fig. 7(b), where theyidentify the same extensions as preferred semantics, yielding again an empty intersection.7.3. Comparing SCC-recursive semanticsHaving provided the definition of four novel semantics, we now need to discuss theirplacement with respect to the traditional semantics of Dung’s framework, in order to carryout a comparative analysis.First of all, the basic requirement of agreement with the grounded semantics is satis-fied by all the introduced proposals. In fact, it is easy to see that the sufficient conditionsfor agreement stated in Theorem 52 are respected by their base functions and, therefore,all the extensions of the proposed semantics contain the grounded extension. All seman-tics, in turn, differ from preferred semantics in the treatment of the problematic caseswhich have been the starting point of our investigation. In this respect, AD1 and AD2 are6 The treatment of other examples of Section 2.2 can be easily derived along the same lines, as well as thatof the examples of Fig. 8, where there is only one strongly connected component and the extensions, coincidingwith maximal conflict-free sets, have empty intersection.P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210207closer by construction to preferred semantics, since, by Proposition 53, they select theirextensions among complete extensions and, therefore, each one of their extensions is con-tained in a maximal complete extension, i.e., in a preferred extension. According to therelation of inclusion between extensions, AD1 and AD2 can be regarded as intermediateapproaches lying between grounded and preferred semantics. On the other hand, CF1 andCF2 radically depart from preferred semantics, relying only on the conflict-free propertyand SCC-recursiveness, while relaxing the admissibility requirement and thus admittingextensions which are not complete extensions.As remarked in the previous subsection, this departure supports a symmetric treatmentof odd-length cycles with respect to even-length ones, which represents a distinguishingproperty of CF1 and CF2 with respect to AD1 and AD2. As far as the examples consideredin previous subsections are concerned, this difference, though conceptually remarkable,does not give rise to significantly different results in the assignment of the justificationstatus. In particular, only an example where AD1 fails to provide an intuitively adequatetreatment has been pointed out, while AD2, CF1 and CF2 substantially agree in all ex-amples, though sometimes achieving the desired result in different ways. Actually, this isnot always the case: different behaviors are possible in other examples, which indeed showthat the symmetric treatment of cycles can be a real advantage and make the difference insome cases.To substantiate this statement, let us consider the argumentation framework shown inFig. 9, corresponding to a floating defeat against argument γ by the nodes in the three-length cycle. In this case, any admissibility-based semantics admits the empty set as theunique extension, and therefore this is the case for AD1 and AD2 as well, which do notregard as justified any argument. On the contrary, both CF1 and CF2 admit as exten-sions the sets {α, δ}, {β, δ} and {φ, δ}. In fact, in the initial strongly connected componentS1 = {α, β, φ} the maximal conflict-free sets, namely the singletons {α}, {β}, and {φ}, areselected as possible choices for E ∩S1. Then S2 = {γ } is ruled out from possible selections,since γ is attacked in any case by E and, therefore, DAF(S2, E) = S2. As a consequence,δ is always selected, since, letting S3 = {δ}, UAF(S3, E) = S3 and {δ} is of course the onlymaximal conflict free set of S3. As a result, α, β and φ are provisionally defeated, γ isdefeated and δ is undefeated. This behavior is coherent with that obtained in the case ofeven-length cycles, like that shown in Fig. 6. As a consequence, this kind of examplesdiscriminates admissibility-based semantics from the proposed novel semantics based onmaximal conflict-free sets.Considering now the case of a self-defeating argument shown in Fig. 10, it is easyto see that the only admissible set here is empty, therefore any admissibility-based se-mantics, including AD1 and AD2, is doomed to show the problematic behavior discussedin Section 3 and can not allow an alternative treatment where the self-defeating argu-ment is ruled out. Let us now consider how this case is handled by CF1 and CF2. First,note that the argumentation framework AF is composed of two strongly connected com-ponents, namely S1 = {α} and S2 = {β}. Starting from the initial strongly connectedcomponent S1, the base function applies to AF↓{α} with C = {α}: both CF1 and CF2prescribe that (E ∩ S1) is a maximal conflict-free set of S1. Since S1 consists just of aself-defeating argument, the only conflict-free set is the empty set, therefore both CF1and CF2 exclude α from any extension. This in turn entails that, for any extension E,208P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210PAF(S2, E) = {β} while UAF(S2, E) = DAF(S2, E) = ∅. Then, E ∩ S2 ∈ GF(AF↓{β}, ∅),and, since AF↓{β} has obviously only one strongly connected component, this entails thatE ∩ S2 ∈ BF CF(AF↓{β}, ∅), where CF stands for either CF1 or CF2. CF1 and CF2 behavedifferently in this case, due to the role of the parameter C in the definition of the relevantbase functions. In particular, according to CF1 (E ∩ S2) ∈ MCF (AF↓{β})↓∅ , i.e., (E ∩ S2)must be the empty set. On the other hand, C plays no role in the base function of CF2,yielding (E ∩ S2) ∈ MCF AF↓{β} , i.e., (E ∩ S2) = {β}. As a consequence, CF1 admits theempty set as the unique extension, thus sharing with admissibility-based semantics the in-ability to rule out self-defeating arguments. On the contrary, CF2 is able to select the onlydesired extension {β}, thus preventing the self-defeating argument α to exert a (possiblyundesired) effect on the rest of the graph.8. ConclusionsIn this paper, we have proposed a general recursive schema that, while including Dung’sframework as a special case, can be regarded as an alternative foundation of argumentationsemantics. In particular, the property of SCC-recursiveness has a basic unifying role inargumentation semantics, in a similar way as admissibility in Dung’s framework, and canensure the correct propagation of the fundamental semantic principles coded in the basefunction to a generic argumentation framework.In fact, SCC-recursiveness turns out to be an effective tool for supporting the devel-opment of new semantics. On the one hand, in order to define a particular SCC-recursivesemantics it is sufficient to identify a suitable base function defined over the argumentationframeworks consisting of a single strongly connected component. On the other hand, thefundamental requirements that all extensions are conflict-free and contain the groundedextension come almost for free, since it is sufficient that the base function is conflict-freeand correctly treats single nodes without defeaters.To exemplify the potential of the recursive schema, we have introduced four novel se-mantics all providing a different treatment with respect to preferred semantics in caseswhere its behavior can be regarded as problematic. Our investigation has been developedin two directions: semantics AD1 and AD2 remain in the area of Dung’s admissibility-based framework, while CF1 and CF2 more radically depart from traditional semantics,giving up the requirement of admissibility and resorting to simpler concepts. The mostsatisfactory behavior is achieved by CF2, which, in particular, is the only one able to dealwith a thorny example concerning self-defeating arguments. It is worth noting that such se-mantics corresponds to the last step in our exploration of the use of progressively simplerconcepts within the SCC-recursive schema, since it only relies on the notion of maximalconflict free set and completely overlooks the notion of defense in the definition of the basefunction.As for future work, three main directions of investigation are worth considering. First, afurther analysis of the general properties of the SCC-recursive schema will be carried out.In particular, in order to compare different proposals, it would be interesting to characterizethe relationships between SCC-recursive semantics in terms of the notion of skepticism,i.e., on the basis of the level of commitment concerning the choices about the justificationP. Baroni et al. / Artificial Intelligence 168 (2005) 162–210209status assigned to the arguments [8]. Second, the space of SCC-recursive semantics willbe extensively explored in order to identify further semantics, whose properties will beanalyzed both from a theoretical point of view and with respect to their meaning and usein different application contexts. Third, since, as shown in the examples, the definitionof SCC-recursiveness has a direct constructive interpretation, it is worth investigating thedevelopment of efficient and incremental algorithms based on local computation at thelevel of strongly connected components.AcknowledgementsWe are indebted to the anonymous referees for their helpful comments and suggestions.References[1] L. Amgoud, C. Cayrol, Inferring from inconsistency in preference-based argumentation frameworks, J. Au-tomat. Reason. 29 (2) (2002) 125–169.[2] L. Amgoud, C. Cayrol, A reasoning model based on the production of acceptable arguments, Ann. Math.Artificial Intelligence 34 (1–3) (2002) 197–215.[3] L. Amgoud, S. Parsons, N. Maudet, Arguments, dialogue, and negotiation, in: Proceedings of the 14thEuropean Conference on Artificial Intelligence (ECAI 2000), IOS Press, Berlin, 2000, pp. 338–342.[4] P. Baroni, M. Giacomin, Solving semantic problems with odd-length cycles in argumentation, in: Pro-ceedings of the 7th European Conference on Symbolic and Quantitative Approaches to Reasoning withUncertainty (ECSQARU 2003), in: Lecture Notes in Artificial Intelligence, vol. 2711, Springer, Aalborg,Denmark, 2003, pp. 440–451.[5] P. Baroni, M. Giacomin, A recursive approach to argumentation: motivation and perspectives, in: Proceed-ings of the 10th International Workshop on Non-Monotonic Reasoning (NMR 2004), Whistler, BC, Canada,2004, pp. 50–58.[6] P. Baroni, M. Giacomin, G. Guida, Extending abstract argumentation systems theory, Artificial Intelli-gence 120 (2) (2000) 251–270.[7] P. Baroni, M. Giacomin, G. Guida, On the notion of strength in argumentation: overcoming the epis-temic/practical dichotomy, in: Proceedings of the 2001 ECSQARU Workshop—Adventures in Argumen-tation Toulouse, France, 2001, pp. 1–8.[8] P. Baroni, M. Giacomin, G. Guida, Towards a formalization of skepticism in extension-based argumentationsemantics, in: Proceedings of the 4th Workshop on Computational Models of Natural Argument (CMNA2004), Valencia, Spain, 2004, pp. 47–52.[9] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logicprogramming, and n-person games, Artificial Intelligence 77 (2) (1995) 321–357.[10] A.J. Garcia, G.R. Simari, Defeasible logic programming: An argumentative approach, Theory Pract. LogicProgramming 4 (1) (2004) 95–138.[11] J.F. Horty, Skepticism and floating conclusions, Artificial Intelligence 135 (1–2) (2002) 55–72.[12] D. Makinson, K. Schlechta, Floating conclusions and zombie paths: Two deep difficulties in the ‘directlyskeptical’ approach to defeasible inheritance networks, Artificial Intelligence 48 (2) (1991) 199–209.[13] J.L. Pollock, How to reason defeasibly, Artificial Intelligence 57 (1) (1992) 1–42.[14] J.L. Pollock, Justification and defeat, Artificial Intelligence 67 (1994) 377–407.[15] J.L. Pollock, Cognitive Carpentry: A Blueprint for How to Build a Person, MIT Press, Cambridge, MA,1995.[16] J.L. Pollock, The logical foundations of goal-regression planning in autonomous agents, Artificial Intelli-gence 106 (2) (1998) 267–334.[17] J.L. Pollock, Perceiving and reasoning about a changing world, Comput. Intelligence 14 (4) (1998) 498–562.210P. Baroni et al. / Artificial Intelligence 168 (2005) 162–210[18] J.L. Pollock, Defeasible reasoning with variable degrees of justification, Artificial Intelligence 133 (1–2)(2001) 233–282.[19] H. Prakken, Logical Tools for Modeling Legal Argument: A Study of Defeasible Reasoning in Law, KluwerAcademic, Dordrecht, 1997.[20] H. Prakken, Intuitions and the modelling of defeasible reasoning: Some case studies, in: Proceedings of the9th International Workshop on Non-Monotonic Reasoning (NMR 2002), Toulouse, France, 2002, pp. 91–102.[21] H. Prakken, G. Sartor, Argument-based extended logic programming with defeasible priorities, J. Appl.Non-Class. Logics 7 (1997) 25–75.[22] H. Prakken, G.A.W. Vreeswijk, Logics for defeasible argumentation, in: D.M. Gabbay, F. Guenthner (Eds.),Handbook of Philosophical Logic, second ed., Kluwer Academic, Dordrecht, 2001.[23] R. Reiter, A logic for default reasoning, Artificial Intelligence 13 (1–2) (1980) 81–132.[24] K. Schlechta, Directly sceptical inheritance cannot capture the intersection of extensions, J. Logic Com-put. 3 (5) (1993) 455–467.[25] G.R. Simari, R.P. Loui, A mathematical treatment of defeasible reasoning and its implementation, ArtificialIntelligence 53 (2–3) (1992) 125–157.[26] B. Verheij, Artificial argument assistants for defeasible argumentation, Artificial Intelligence 150 (1–2)(2003) 291–324.[27] G.A.W. Vreeswijk, Abstract argumentation systems, Artificial Intelligence 90 (1–2) (1997) 225–279.