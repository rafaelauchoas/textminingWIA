Artificial Intelligence 175 (2011) 1479–1497Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintInstantiating abstract argumentation with classical logic arguments:Postulates and propertiesNikos Gorogiannis a, Anthony Hunter b,∗a Department of Computer Science, Queen Mary, University of London, London, E1 4NS, UKb Department of Computer Science, University College London, London, WC1E 6BT, UKa r t i c l ei n f oa b s t r a c tArticle history:Received 17 February 2010Received in revised form 22 December 2010Accepted 26 December 2010Available online 28 December 2010Keywords:Computational models of argumentAbstract argumentationLogical argumentationIn this paper we investigate the use of classical logic as a basis for instantiating abstractargumentation frameworks. In the first part, we propose desirable properties of attackrelations in the form of postulates and classify several well-known attack relations fromthe literature with regards to the satisfaction of these postulates. Furthermore, we provideadditional postulates that help us prove characterisation results for these attack relations.In the second part of the paper, we present postulates regarding the logical content ofextensions of argument graphs that may be constructed with classical logic. We thenconduct a comprehensive study of the status of these postulates in the context of thevarious combinations of attack relations and extension semantics.© 2011 Elsevier B.V. All rights reserved.1. IntroductionArgumentation is an important cognitive process that involves the generation and evaluation of arguments. There havebeen a number of proposals for capturing this cognitive process in computational models of argumentation (for example[1–6] and for reviews [7–10]). Amongst these proposals, two significant, intersecting and non-exclusive streams can bedistinguished.Abstract argumentation which focuses on the attack relations between arguments and usually considers arguments them-selves to be atomic objects (for example [11,3,12,13]). This approach offers insight into how arguments interactand achieve acceptability solely in terms of the attacks that may exist between them. Furthermore, this approachallows for harnessing tools from graph theory.Logical argumentation which considers arguments as complex entities with an internal structure that is governed by acertain logical language (for example [1,14,4–6,15]). In general, using logic for formalising argumentation enablesthe harnessing of natural concepts for disagreement, or attack between arguments, such as inconsistency. In ad-dition, this approach allows using logical entailment for drawing conclusions that may serve as the claims ofarguments.A wealth of research has been conducted in the context of these two streams, prompting the question whether theirderived knowledge can be combined to deliver models of argumentation that are more expressive, more natural or morepowerful. Proposals of frameworks that are situated in the intersection of these two areas exist (for example [16,4,5,17–20]) but (apart from [16,19,20]), they tend to focus on specialised, defeasible logics as their language of choice. Defeasible* Corresponding author.E-mail addresses: n.gorogiannis@cs.ucl.ac.uk (N. Gorogiannis), a.hunter@cs.ucl.ac.uk (A. Hunter).0004-3702/$ – see front matter © 2011 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.12.0031480N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497logics are a useful tool for many application areas where the expressiveness requirements are not great, but cannot readilyencompass applications where for example disjunction or true negation are required.Therefore, it would seem that an argumentation system that uses classical logic as its language, while explicitly employ-ing abstract argumentation-style semantics, is attractive for several reasons. It would benefit directly from the large numberof results on abstract argumentation frameworks produced in the last decade and, in addition, it would offer expressivenessthat is moderate but still higher than currently used defeasible logics for argumentation.It is the exploration of this gap, then, that this paper is aimed at. Proposing such a framework is not particularly compli-cated as there is a natural, if not unproblematic, way to instantiate an abstract argumentation framework using a knowledgebase in classical logic. What is little known about such systems is the properties they ought to satisfy for them to be usefuland predictable. While attempts have been made along these lines (e.g., [18] on rule-based systems and [19] on classicallogic) such work is far from complete. Moreover, after such postulates have been proposed and perhaps gained acceptance,the more important question remains as to which argumentation systems will satisfy them. Compounding the difficulty ofthese questions is the fact that components of both logical and abstract argumentation, such as attack relations and exten-sion semantics respectively, can be instantiated to a multiplicity of definitions, thus considerably enlarging the number ofcombinations to check. So we see that given the interesting possibilities raised in [16,18,19], there is a need to undertakea systematic analysis of instantiating abstract argumentation with classical logic that considers a comprehensive range ofattack relations and semantics for extensions. Furthermore, it is desirable that this is undertaken in a modular way using aframework of intuitive postulates.Given these concerns, in this paper we consider an intuitive way to generate a set of arguments, starting from aknowledge base in classical logic (along with preliminaries, in Section 2). We then review the attack relations for logi-cal argumentation in the literature and set out postulates that delineate desirable properties (Section 3). In addition, weinvestigate the status of these properties for these attack relations and then go on to propose additional postulates thatallow us to prove characterisation results, i.e., to show that an arbitrary attack relation is one of the reviewed ones if andonly if it satisfies a particular combination of postulates. Following that, we outline a set of postulates which express gen-eral properties of the logical content of the extensions of logical argument graphs (Section 4). To achieve that, we employand generalise properties found in the literature as well as novel postulates that specifically address the issues arising fromthe potential extension multiplicity that many extension semantics allow. The status of these postulates is examined next(Section 5), over the several combinations of extension semantics and attack relations possible. Finally, we conclude anddiscuss existing work that relates to this paper (Section 6).2. Preliminaries(cid:2)We will use a propositional logic (cid:3)L, (cid:4)(cid:5) with a countable set of propositional letters and constants (cid:6), ⊥ for truth andfalsum respectively. We write Φ (cid:4) ψ to mean that the set of formulae Φ entails the formula ψ , and φ (cid:4) ψ as shorthand for{φ} (cid:4) ψ . The notationΦ where Φ is a set of formulae, will be used to denote the conjunction of all formulae in Φ. Wealso use φ ≡ ψ to denote logical equivalence of the formulae φ and ψ in the meta-language (i.e., φ (cid:4) ψ and ψ (cid:4) φ), andΦ ≡Φ ≡ Ψ mean logical equivalence of sets of formulae, i.e.,Ψ . From now on (cid:6), the knowledge base, will stand fora finite set of individually consistent propositional formulae. We will denote the set of minimal inconsistent subsets of (cid:6)with MI((cid:6)) (that is to say, MI((cid:6)) = {Φ ⊆ (cid:6) | Φ (cid:4) ⊥ and for all Ψ ⊂ Φ, Ψ (cid:2) ⊥}).(cid:2)(cid:2)In order to give meaning and structure to the arguments in an abstract argumentation framework, we adopt the mostcommon definition in logical argumentation that separates the evidence, or support, from the claim, or conclusion of anargument.Definition 1. An argument is a pair (cid:3)Φ, φ(cid:5) such that Φ ⊆ (cid:6) is a consistent, finite set of formulae, φ is a formula such thatΦ (cid:4) φ, and no proper subset of Φ entails φ.The (countably infinite) set of all arguments is denoted by A. If A = (cid:3)Φ, φ(cid:5) is an argument, we will use the functionsS( A) = Φ to denote the support of A and C( A) = φ to denote the claim of A. We say that two arguments A, B areequivalent if S( A) = S(B) and C( A) ≡ C(B), and denote this by A ≡ B. Notice that this notion of equivalence is semanticwith respect to the claim, but syntactic with respect to the support. This compromise aims at accommodating the fact thatusers of a logical argumentation system may view the formulae in the input knowledge base as resources, in the sense thathaving two ways to prove the same thing should give rise to two different arguments that are not conflated together. Also,we will say that A is a sub-argument of B if S( A) ⊆ S(B).Definition 2. An argument graph (or simply, graph) is a pair (cid:3)N, R(cid:5) where N ⊆ A is a finite set of arguments and R is anon-reflexive binary relation on N. For each ( A, B) ∈ R, we say that A attacks B.We will only consider non-reflexive attack relations in this paper. While attack relations with self-loops have beenof some interest in the abstract argumentation community, they do not normally feature in logical argumentation sincearguments are usually required to be consistent, as above, and the attack relation definition ordinarily relates attack toinconsistency.N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971481Fig. 1. Is-a relationships between concepts in Definition 3. An arrow from X to Y denotes that any X -extension is also a Y -extension, or equivalently,EX(Γ ) ⊆ EY(Γ ).We use the convenience functions Nodes((cid:3)N, R(cid:5)) = N (the nodes of the graph) and Arcs((cid:3)N, R(cid:5)) = R (the arcs of thegraph). Whenever we are concerned with an argument graph Γ and there is no possibility of confusion, we will understandthe phrase ‘an argument A in Γ ’ to mean the qualified phrase ‘an argument A ∈ Nodes(Γ )’.We recall the following notions from abstract argumentation.Definition 3. Let Γ be an argument graph and S ⊆ Nodes(Γ ) a set of arguments.1. S attacks an argument B if there exists A ∈ S such that A attacks B.2. S defends an argument A if S attacks B for every argument B such that B attacks A.3. S is conflict-free if there is no A ∈ S such that S attacks A.4. S is admissible if it is conflict-free and it defends all of its members.5. S is a stable extension if S is conflict-free and S attacks A for all A ∈ Nodes(Γ ) \ S.6. S is a complete extension if it is admissible and contains every argument it defends.7. S is a preferred extension if it is a maximal (w.r.t. set inclusion) admissible set.8. S is the grounded extension if it is the least fixed point of F ( X) = { A ∈ Nodes(Γ ) | X defends A}.9. S is a semi-stable extension if it is a complete extension and the set S ∪ { A ∈ Nodes(Γ ) | S attacks A} is maximalw.r.t. set inclusion.10. S is the ideal extension if it is the maximal (w.r.t. set inclusion) admissible set that is contained within every preferredextension.Items 1–8 are due to Dung [3], item 9 is due to Caminada [12] and item 10 is due to Alferes, Dung and Pereira [11] andDung, Mancarella and Toni [13]. The notions 5–10 are also referred to as argumentation semantics or extension semantics inthe argumentation literature. Note that for a particular argument graph there may be no stable extensions. Also, there maybe more than one stable, complete, preferred and semi-stable extensions, but only one grounded and one ideal extension.In addition, the is-a relationships shown in Fig. 1 hold, proved in [3,12,13].For any extension semantics X we will use EX(Γ ) to denote the set of X-extensions of the argument graph Γ . We willuse the subscripts: ‘st’ for stable, ‘co’ for complete, ‘pr’ for preferred, ‘gr’ for grounded, ‘ss’ for semi-stable and ‘id’ for ideal.So, for example, Epr(Γ ) will stand for the set of preferred extensions of Γ . In addition, we define two sets of arguments fora graph Γ , meant to capture sceptical and credulous acceptance of arguments, respectively:πX(Γ ) =(cid:3)S∈EX(Γ )S,σX(Γ ) =(cid:4)SS∈EX(Γ )So, for example, we will say that an argument A in Γ is sceptically accepted in the preferred semantics if A ∈ πpr(Γ ).Clearly, πX(Γ ) ⊆ σX(Γ ) for any semantics X, σgr(Γ ) = πgr(Γ ) and σid(Γ ) = πid(Γ ). Note if EX(Γ ) = ∅, then we haveπX(Γ ) = σX(Γ ) = ∅.Now that we have defined the notion of a logical argument, the question of how to define the notion of attack arises.In the context of abstract argumentation, an attack relation is, as we have seen, a binary relation on a set of arguments.While this is an exact description of what kind of mathematical object we use, it is of no help in explaining how we mightdefine such a relation. Indeed, most, if not all, attack relations on logical arguments from the literature are defined by wayof a criterion that operates on a pair of logical arguments and uses no other information about the set of arguments thispair belongs in. Thus, a natural way for expressing this is through a function. An attack function D : A × A → {(cid:6), ⊥} is aboolean-valued function on ordered pairs of arguments. Such an attack function can be seen as the characteristic functionof an attack relation, i.e., a set of pairs of arguments. For this reason from now on we will abuse terminology slightly andtalk about attack functions and attack relations interchangeably.We review below several attack relations from the literature.1482N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497Fig. 2. Containment between attack relations. An arrow from D1 to D 2 indicates that D 1 ⊆ D 2.Definition 4. Let A and B be two arguments. We define the following attack functions by listing the conditions under whichD( A, B) = (cid:6). On the left we list the symbols for each attack function.(D D )(DDD)(D U )(DDU)(D C U )(D R )(DDR)(cid:2)S(B).A is a defeater of B if C( A) (cid:4) ¬A is a direct defeater of B if there is φ ∈ S(B) such that C( A) (cid:4) ¬φ.A is an undercut of B if there is Ψ ⊆ S(B) such that C( A) ≡ ¬Ψ .A is a direct undercut of B if there is φ ∈ S(B) such that C( A) ≡ ¬φ.A is a canonical undercut of B if C( A) ≡ ¬A is a rebuttal of B if C( A) ≡ ¬C(B).A is a defeating rebuttal of B if C( A) (cid:4) ¬C(B).S(B).(cid:2)(cid:2)It is straightforward to see that A is a defeater of B iff S(B) ∪ {C( A)} is inconsistent, and that A is a defeating rebuttalof B iff {C( A), C(B)} is inconsistent.The concepts behind these attack relations have been very widely employed in the literature, so citing originating paperswith exactness is difficult. It is safe to say, however, that rebuttals appear in [1] and also [21]. Direct undercuts appearin [2,22]. Undercuts and canonical undercuts were proposed in the above form and studied extensively in [23,6]. Note thatcanonical undercuts were originally defined using the notion of maximal conservativeness but for simplicity we use the aboveequivalent definition.Note that, if D1, D2 are two attack functions we will use them as relations in order to express a containment relation,e.g., D1 ⊆ D2, meaning that if D1( A, B) = (cid:6) then D2( A, B) = (cid:6). Then, it is easy to see that several containment relationshold as pictured in Fig. 2.Having chosen an attack function D and given a knowledge base (cid:6) the question remains as to how an argument graphis generated. There is a natural definition for this, which we call an argument generator.Definition 5. The argument generator G(cid:6)D is defined as follows, given an attack function D and a knowledge base (cid:6).G(cid:6)DN =R == (cid:3)N, R(cid:5)(cid:6)(cid:5)(cid:6) S( A) ⊆ (cid:6)A ∈ A(cid:6)(cid:7)(cid:6) A, B ∈ N and D( A, B) = (cid:6)( A, B)(cid:5)(cid:7)By definition, it is always the case that for any formula φ and knowledge base (cid:6),(cid:9)(cid:8)(cid:9)(cid:8)(cid:9)(cid:8)Nodes(cid:9)(cid:8)⊆ Nodes,G(cid:6)DG(cid:6)∪{φ}DG(cid:6)∪{φ}DIn this paper, we have focused on the most commonly considered definition for a logical argument (i.e. (cid:3)Φ, ψ(cid:5) is anargument iff Φ is a minimal consistent set of formulae that entails ψ ). However, there are other proposals that relaxthese conditions for an argument. For instance, in assumption-based argumentation [17], there is not a requirement for thepremises to be minimal. Further relaxations of these conditions for an argument have been considered in [24] resulting inapproximate arguments such as enthymemes which have insufficient premises for entailing the claim.⊆ ArcsG(cid:6)DArcsAn alternative definition for an argument has been proposed in [14], and revisited in [16], in which the consistencyconstraint is such that the premises Φ of an argument need to be consistent with the a designated subset of the knowl-edgebase. The idea behind this refinement is that there is a consistent subset Π of the knowledgebase that can be regardedas correct, and the support of any argument would need to be consistent with Π . This also leads to further instances ofcounterargument such as the following for arguments A and B:• A disagrees with B iff Π ∪ {C( A), C(B)} (cid:4) ⊥.• A counterargues B iff there is an argument C such that C is a subargument of B and A disagrees with C .• A weakly-undercuts B iff there is an argument C such that C is a subargument of B and A is a rebuttal of C .If we assume that Π = ∅, then we can compare these definitions with those given in Definition 4. For instance, A dis-agrees with B iff A is a defeating rebuttal of B. And, A counterargues B iff there is a subargument C of B and A is adefeating rebuttal of C .N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–149714833. Postulates concerning attack functionsIn this section, we propose postulates relevant to attack functions. From now on, A, B, C and their primed versions willstand for arguments.(D0)if A ≡ A(cid:15), B ≡ B(cid:15)then D( A, B) = D(cid:8)(cid:9)(cid:15)(cid:15)A, BThe above postulate is a classic syntax-independence requirement: the syntax of the components of two arguments shouldnot play a role in deciding whether there is an attack between those arguments.(D1)if D( A, B) = (cid:6) then {C( A)} ∪ S(B) (cid:4) ⊥Postulate D1 mandates that if an argument attacks another, then it must be that the claim of the former is inconsistentwith the support of the latter. This requirement reflects a fundamental assumption in logical argumentation, namely that iftwo arguments are logically consistent there cannot be any attack between them. In addition, a further expectation is thatnot only the supports of the arguments are inconsistent, but also the claim of the attacker with the support of the attackedargument. This fits in with the view that an argument can be decomposed into a claim and a set of evidence for that claim(here, the support). In this context, it is not enough to have inconsistent collections of evidence for an attack to take place;the attacking argument must make it specific in its claim that it contradicts the evidence offered by the attacked argument.Note also that since A is a defeater of B if and only if S(B) ∪ {C( A)} is inconsistent, we see that the D1 postulate mandatesthat an attack must be contained in the defeat relation.(D2)(D3)if D( A, B) = (cid:6) and C(C) ≡ C( A) then D(C, B) = (cid:6)if D( A, B) = (cid:6) and S(B) = S(C) then D( A, C) = (cid:6)The postulates D2 and D3 impose certain fairness restrictions on existing attacks: D2 requires that all arguments that haveequivalent claims with that of A should attack B; D3, similarly, requires that if A attacks B then all arguments with thesame support with that of B should also be attacked by A. It is of note that these two postulates have some overlap with D0,but they are not equivalent, since in each case the new argument is not necessarily ≡-equivalent to the existing argument.(cid:15)was proposed by Amgoud and Besnard [19].It is possible to strengthen these postulates as follows. Note, D3(D2(D3(cid:15)(cid:15)))if D( A, B) = (cid:6) and C(C) (cid:4) C( A) then D(C, B) = (cid:6)if D( A, B) = (cid:6) and S(B) ⊆ S(C) then D( A, C) = (cid:6)(cid:15)Again, suppose that A attacks B. Postulate D2logically entails that of A, should also attack anything A attacks. Postulate D3is a superset of that of B, and thus stronger than that of B, should also be attacked by A. Clearly, D2weaker versions, D2 and D3, respectively.requires that any argument with a stronger claim than A, i.e., one thatmandates that any argument whose support(cid:15)entail their(cid:15)and D3(cid:15)We list below another postulate that makes reference to the argument generator. This postulate essentially only con-strains D in relation to the input knowledge base (cid:6).(D4)if Arcs(cid:9)(cid:8)G(cid:6)D= ∅ then MI((cid:6)) = ∅This postulate can be read as follows: if we restrict D on the arguments that can be generated from (cid:6) and find that no twosuch arguments attack each other, then it must be that (cid:6) itself is consistent (hence it has no minimal inconsistent subsets).It should be easy to see that D1 entails the right-to-left version of D4 and, therefore, these two postulates together entailthat the resulting argument graph has no arcs iff (cid:6) is consistent.We examine now whether the attack functions described in Definition 4 satisfy the above postulates.Proposition 6. The attack functions in {D D , D U , D C U , DDU, DDD, D R , DDR} satisfy the attack function postulates according toTable 1.Table 1Postulates satisfied by the reviewed attack functions.D0D1D2(cid:15)D2D3(cid:15)D3D4D D(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)D DD(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)D U(cid:2)(cid:2)(cid:2)×(cid:2)(cid:2)(cid:2)D DU(cid:2)(cid:2)(cid:2)×(cid:2)(cid:2)(cid:2)D C U(cid:2)(cid:2)(cid:2)×(cid:2)×(cid:2)D R(cid:2)(cid:2)(cid:2)×××(cid:2)D DR(cid:2)(cid:2)(cid:2)(cid:2)××(cid:2)1484N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497Proof. We will omit the proofs that are trivial but give some comments instead:D0 is clearly satisfied by all the attack functions, as their definitions use logical equivalence or entailment for the claimsand the subset relation or equality for the supports.D1 is satisfied by all the attack functions.D2 is satisfied by all the attack functions due to the fact that all attack function definitions put conditions on the claim of(cid:15)D2the attacking argument that cannot distinguish between logically equivalent claims.will be satisfied by those attack functions that are tolerant to strengthening the claim of the attacking argument. Thus,all attack functions based on the notion of undercutting will fail this postulate.D3 is satisfied by all the attack functions except for those based on the notion of rebuttal for obvious reasons.(cid:15)D3is satisfied by all the attack functions that satisfy D3 except canonical undercutting, which by its definition does nottolerate changing the support of the attacked argument to a non-logically equivalent set.D4 is satisfied by all attack functions. Suppose that Arcs(G(cid:6)is a minimal inconsistent set it is easy to see that A = (cid:3)M \ {ψ}, ¬ψ(cid:5) is an argument in Nodes(G(cid:6)(cid:3){ψ}, ψ(cid:5) is an argument in Nodes(G(cid:6)thus Arcs(G(cid:6)D ) = ∅ but MI((cid:6)) (cid:16)= ∅ and let M ∈ MI((cid:6)) and ψ ∈ M. Since MD ). Also, trivially, B =D ). But for any attack function D ∈ {D D , D U , D C U , DDU, DDD, D R , DDR}, D( A, B) = (cid:6),D ) (cid:16)= ∅, a contradiction. (cid:2)The postulates D0–D4 are useful in classifying the attack functions we review, as evidenced by Table 1 in Proposition 6.We can also use these postulates for a characterisation of the attack functions reviewed here. By characterisation we meana result that guarantees that an arbitrary attack function D satisfies a specific list of postulates if and only if D is a specificmember of {D D , D U , D C U , DDU, DDD, D R , DDR}. To that end, we present a list of further postulates that will be useful incharacterising the reviewed attack functions. We first look at postulate D1 and two variations.(D1(D1(cid:15))(cid:15)(cid:15))if D( A, B) = (cid:6) then ∃φ ∈ S(B) s.t. C( A) (cid:4) ¬φif D( A, B) = (cid:6) then C( A) (cid:4) ¬C(B)Where D1 requires inconsistency of the attacking arguments’s claim and the attacked argument’s support, D1more stringent requirements on the claim of the attacker. Also, note that D1(cid:15)(cid:15)and D1imply D1.(cid:15)(cid:15)(cid:15)(cid:15)and D1putNext we introduce four postulates that work in tandem with one of the versions of D1 to provide one direction ofthe characterisation result. So each D1 variant works with a D5 variant to fix the nature of the relationship between thesays that for D( A, B) = (cid:6) to hold, C( A)support of an argument and the claim of a counterargument. For instance, D1(cid:15)(cid:15)entails ¬C(B), and D5say thatC( A) is equivalent to ¬C(B). It can be seen that D5 implies D5says that for D( A, B) = (cid:6) to hold, ¬C( A) entails C(B). Therefore, together D1(cid:15)(cid:15)implies D5, and that D5(cid:15)(cid:15)and D5(cid:15)(cid:15)and D5(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15).if D( A, B) = (cid:6) then ¬C( A) (cid:4)S(B)(cid:10)if D( A, B) = (cid:6) then ∃φ ∈ S(B) s.t. ¬C( A) (cid:4) φif D( A, B) = (cid:6) then ¬C( A) (cid:4) C(B)if D( A, B) = (cid:6) then ∃X ⊆ S(B) s.t. ¬C( A) ≡X(cid:10)(D5)(D5(D5(cid:15))(cid:15)(cid:15))(D5(cid:15)(cid:15)(cid:15))Finally, it is of note that all postulates presented up to now are universally quantified over arguments. This means that theycannot force the existence of attacks, but only constrain those present. Hence, the empty attack relation D∅( A, B) = ⊥ willtrivially satisfy all these postulates. Thus, for the purposes of providing characterisation results we need a set of postulatesthat guarantee the existence of attacks. We present these below:(D6)(cid:15)(D6)(cid:15)(cid:15)(D6)if {C( A)} ∪ S(B) (cid:4) ⊥ then there exists C s.t. C( A) (cid:4) C(C) and D(C, B) = (cid:6)if ∃φ ∈ S(B) s.t. C( A) (cid:4) ¬φ then there exists C s.t. C( A) (cid:4) C(C) and D(C, B) = (cid:6)if C( A) (cid:4) ¬C(B) then there exists C s.t. C( A) (cid:4) C(C) and D(C, B) = (cid:6)(D6(cid:15)(cid:15)(cid:15))if ∃X ⊆ S(B) s.t. C( A) ≡ ¬X then D( A, B) = (cid:6)(cid:10)It can be observed that for the first three of the above postulates, the consequent is the same, whereas the consequent ofthe fourth is more stringent about the nature of the attack, and each of the postulates guarantees existence of an argumentinvolved in an attack. Also, the conditions for the first three postulates match the consequent of the corresponding D1(cid:15)postulate. In addition, D6 implies D6(cid:15)(cid:15)and D6.For an attack function D that satisfies D1, D2 and D6, we show that D is a super-relation of D C U (i.e. D C U ⊆ D).Proposition 7. Suppose that D satisfies D1, D2 and D6 and that A, B are two arguments in G(cid:6)D( A, B) = (cid:6).D . If C( A) ≡ ¬(cid:2)S(B), thenN. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971485Table 2Attack functions and the postulates they are characterised by. Each attack function is characterised by the conjunction of the postulates located in theappropriate row, column and (optionally) cell.(cid:15)D2D2–D1, D6D DD C U (D5)–(cid:15)D1(cid:15), D6D DD(cid:15)D DU (D5–)(cid:15)(cid:15)D1(cid:15)(cid:15), D6D DR(cid:15)(cid:15)D R (D5–)(cid:15)(cid:15)(cid:15)D6––D U (D5(cid:15)(cid:15)(cid:15))Proof. The assumption C( A) ≡ ¬such that C( A) (cid:4) C(C) and D(C, B) = (cid:6). Note that C need not belong to Nodes(G(cid:6)This in turn means that C( A) ≡ C(C) ≡ ¬S(B) entails {C( A)} ∪ S(B) (cid:4) ⊥, thus postulate D6 applies, producing an argument CS(B).S(B). Applying D2 yields that D( A, B) = (cid:6). (cid:2)D ). By D1 it follows that C(C) (cid:4) ¬(cid:2)(cid:2)(cid:2)Next we look at the class of attack functions satisfying the postulates D1these postulates would be a super-relation of DDU (i.e. DDU ⊆ D).(cid:15)(cid:15), D2 and D6. An attack function satisfyingProposition 8. Suppose that D satisfies D1then D( A, B) = (cid:6).(cid:15)(cid:15), D2 and D6and that A, B are two arguments in G(cid:6)D . If C( A) ≡ ¬φ where φ ∈ S(B),Proof. The assumption C( A) ≡ ¬φ where φ ∈ S(B) allows us to use postulate D6, producing an argument C such that(cid:15)C( A) (cid:4) C(C) and D(C, B) = (cid:6). By D1it follows that C(C) (cid:4) ¬ψ for some ψ ∈ S(B). Combining these gives us that ψ (cid:4) φ,so in order to preserve the minimality of S(B) it must be that φ = ψ . This further means that C( A) ≡ C(C). Applying D2yields that D( A, B) = (cid:6). (cid:2)(cid:15)For an attack relation D that satisfies D1(cid:15)(cid:15)(cid:15)(cid:15), D2 and D6, we show that D is a super-relation of D R (i.e. D R ⊆ D).Proposition 9. Suppose that D satisfies D1D( A, B) = (cid:6).(cid:15)(cid:15)(cid:15)(cid:15), D2 and D6and that A, B are two arguments in G(cid:6)D . If C( A) ≡ ¬C(B), then(cid:15)(cid:15)Proof. Using postulate D6C(C) (cid:4) ¬C(B). Combining these gives us that C( A) ≡ C(C). Applying D2 yields that D( A, B) = (cid:6). (cid:2)produces an argument C such that C( A) (cid:4) C(C) and D(C, B) = (cid:6). By D1(cid:15)(cid:15)it follows thatWe now show that each D ∈ {D D , D U , D C U , DDU, DDD, D R , DDR} can be characterised using the postulates constrainingthe attack function.Proposition 10. The following characterisation results hold and they are summarised in Table 2.(cid:15)• D = D D iff D satisfies D1, D2and D6.(cid:15)(cid:15)(cid:15)• D = DDD iff D satisfies D1.and D6, D2(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)• D = DDR iff D satisfies D1and D6, D2• D = D C U iff D satisfies D1, D2, D5 and D6.(cid:15)(cid:15)(cid:15)• D = DDU iff D satisfies D1.and D6, D2, D5(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)• D = D R iff D satisfies D1and D6, D2, D5.(cid:15)(cid:15)(cid:15)• D = D U iff D satisfies D5.and D6(cid:15)(cid:15)(cid:15).Proof. We prove the desired results by showing that D ⊆ D x and D ⊇ D x iff the appropriate postulates are satisfied by D,for each appropriate D x. We will omit the proofs for the left-to-right direction as they are straightforward.(cid:15)(D D ) Suppose D satisfies D1, D2(cid:15)(DDD) Suppose D satisfies D1and D6. It is easy to see that D1 ensures that D ⊆ D D . To show that D ⊇ D D , supposethat D D ( A, B) = (cid:6) for some A, B. This means that {C( A)} ∪ S(B) (cid:4) ⊥, thus satisfying the conditions of D6, which inwe obtain that D( A, B) = (cid:6).turn provides an argument C such that D(C, B) = (cid:6) and C( A) (cid:4) C(C). By applying D2ensures that D ⊆ DDD. To show that D ⊇ DDD,suppose that DDD( A, B) = (cid:6) for some A, B. This means that ∃φ ∈ S(B) s.t. C( A) (cid:4) ¬φ thus satisfying the conditions(cid:15)of D6we obtainthat D( A, B) = (cid:6).(cid:15)(cid:15)(DDR) Suppose D satisfies D1, which in turn provides an argument C such that D(C, B) = (cid:6) and C( A) (cid:4) C(C). By applying D2(cid:15). It is easy to see that D1(cid:15)(cid:15). It is easy to see that D1(cid:15)(cid:15)and D6(cid:15)and D6(cid:15), D2(cid:15), D2(cid:15)(cid:15)pose that DDR( A, B) = (cid:6) for some A, B. This means that C( A) (cid:4) ¬C(B), thus satisfying the conditions of D6in turn provides an argument C such that D(C, B) = (cid:6) and C( A) (cid:4) C(C). By applying D2we obtain D( A, B) = (cid:6).(cid:15)ensures that D ⊆ DDR. To show that D ⊇ DDR, sup-, which(cid:15)(cid:15)(D C U ) Suppose D satisfies D1, D2, D5 and D6. D1 and D5 guarantee that if D( A, B) = (cid:6) then D C U ( A, B) = (cid:6). For theother direction, we apply Proposition 7 to get D ⊇ D C U .1486N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497(cid:15)and D6(cid:15), D2, D5(cid:15)(DDU) Suppose D satisfies D1yields that(cid:15)there is φ ∈ S(B) such that C( A) (cid:4) ¬φ and D5that there is ψ ∈ S(B) such that ¬C( A) (cid:4) ψ . Combining these givesus that ¬ψ (cid:4) ¬φ, or φ (cid:4) ψ . The definition of what is an argument enforces minimality, meaning that it must be thatφ = ψ , which in turn yields that C( A) ≡ ¬φ, completing the proof. For the other direction, we apply Proposition 8to get D ⊇ DDU .(cid:15)(cid:15)(D R ) Suppose D satisfies D1(cid:15). To show that D ⊆ DDU suppose that D( A, B) = (cid:6). Postulate D1together entail that D ⊆ D R . For the other direction, we(cid:15)(cid:15)and D5(cid:15)(cid:15)and D6(cid:15)(cid:15). D1(D U ) Suppose D satisfies D5(cid:15)(cid:15), D2, D5apply Proposition 9 to get D ⊇ D R .(cid:15)(cid:15)(cid:15)and D6exists X ⊆ S(B) such that ¬C( A) ≡D U ( A, B) = (cid:6), ∃ X ⊆ S(B) such that C( A) ≡ ¬(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15). To show that D ⊆ D U , assume that D( A, B) = (cid:6). Using D5(cid:2)X . Therefore, ∃ X ⊆ S(B) such that C( A) ≡ ¬X . Therefore, via D6(cid:2)(cid:15)(cid:15)(cid:15)(cid:2)we get that thereX . For the other direction, from, we get D( A, B) = (cid:6), and hence D ⊇ D U . (cid:2)In this section, we have provided a framework of postulates for the attack relation and shown it can be used for classi-fying and characterising instances of attack relation. In the next section, we will use these postulates for the attack relationin order to consider postulates for logical argument graphs. Our postulates D0–D4, and the variants D2, provideintuitive proposals for necessary constraints on attack relations, and then postulates D5 and variants, and D6 and variants,provide the extra constraints to characterise them in Proposition 10. If we only have D0–D4, then there is too much latitudein the constraints they provide, and as a result they permit undesirable attack relations (i.e. if we just seek to satisfy D0to D4, then we allow attack relations with counter-intuitive behaviour). We believe that new proposals for attack relationswill be made where the underlying logic is classical logic, or another rich formalism such as a description logic, a temporallogic, or a spatial logic, and so we believe having these characterisations as given in this paper will be helpful in definingattack relations for new situations.(cid:15)and D3(cid:15)4. Postulates for logical argument graphsThe intention behind the argument generator (given in Definition 5) is the generation of an argument graph that can beused with the extension definitions proposed in the literature and reviewed in Section 2. Doing so will yield in each caseone or more extensions, each of which is a set of arguments. From the perspective of abstract argumentation we would stopat this point since nothing more can be said about the result using only the information that is encoded in the argumentgraph. However, since these arguments are logical arguments, it is possible to examine the resulting extensions further.To this end, we discuss and propose some postulates about the content of extensions. We do not, however, desire toconstrain or propose definitions of extensions; this is beyond the scope of our paper and much existing work on alternativeextensions is easy to find. What we do desire, here, is to provide an extension-independent set of postulates that arereasonable and succinct.We introduce some additional phraseology and notation here. A set of formulae Ψ is called free if Ψ ⊆ (cid:6) \M∈MI((cid:6)) M.This definition is obviously dependent on (cid:6); we omit stating this for clarity and without danger of confusion. An argumentA is called a free argument if S( A) is free. The set of free arguments belonging to a graph Γ (that has been returned bythe generator G(cid:6)D ) is denoted by FreeArgs(Γ ) and the set of non-free arguments by NonFreeArgs(Γ ). We say that a set ofarguments S supports a formula φ and write S (cid:2) φ if there is an argument A ∈ S such that C( A) (cid:4) φ.(cid:11)In order to formulate the postulates we will assume that X is any of the reviewed semantics. We first look at consistencypostulates. Let D be an attack function and (cid:6) a knowledge base.(CN1)(CN2)(CN1(cid:15))(CN2(cid:15))S( A) (cid:2) ⊥(cid:4)(cid:9)(cid:8)G(cid:6)DA∈πX(cid:4)S( A) (cid:2) ⊥,for all S ∈ EX(cid:9)(cid:8)G(cid:6)DA∈S(cid:4)C( A) (cid:2) ⊥A∈πX(G(cid:6)D )(cid:4)C( A) (cid:2) ⊥,A∈Sfor all S ∈ EX(cid:9)(cid:8)G(cid:6)DNote that these postulates are understood to be universally quantified over (cid:6). The above postulates are variations of therequirement that certain arguments’ supports or claims must be consistent together. The expectation is that once an ex-tension is obtained, then the arguments contained in it present a somehow consistent set of assumptions. Applying thisrestriction to the supports of the arguments or to their claims, and to the sceptically accepted set of arguments or to allextensions individually, yields the versions of this principle listed above. The reason we provide all four versions is that itis not yet clear whether one form of the postulate is more appropriate than others. For example, consistency postulates(cid:15)similar to CN1have been proposed in [25] in the context of rule-based argumentation systems and versions ofCN1 and CN2 have been proposed in [19] for classical logics. It should be clear that CN2 entails CN1, CN2, CN1(cid:15)entails CN1(cid:15)and CN2 entails CN2(cid:15)entails CN1(cid:15)and CN2.(cid:15)N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971487Next we look at the relationship between the set of free arguments and the set of sceptically accepted arguments:(SC)(cid:8)FreeArgs(cid:9)(cid:8)(cid:9)G(cid:6)D⊆ πXG(cid:6)DThis postulate encodes our expectation that since free arguments are uncontroversial, they should be asserted in everyextension and, hence, in the sceptically accepted set as well.Finally, we introduce a postulate that captures the expectation that there exists a knowledge base which is inconsistentand for which some of the arguments, that can formed from the knowledge base, are not credulously accepted:(cid:8)(cid:16)= Nodes(cid:8)∃(cid:6) s.t. NonFreeArgs(cid:16)= ∅ and σX(CR)(cid:9)(cid:9)(cid:8)(cid:9)G(cid:6)DG(cid:6)DG(cid:6)DThis may seem like a relatively simple postulate, but we will see that it is a good postulate for differentiating the variousoptions we have for argumentation with classical logic. When the postulate fails, it means that for any knowledgebases (cid:6),and for any argument A, if S( A) ⊆ (cid:6), then A is credulously accepted. In other words, for any argument that can be formedfrom a knowledgebase, there is a preferred extension that contains that argument. So if it does fail for an attack function Dand an extension semantics X , then this indicates that the combination of D and X is, in a sense, very credulous.5. Status of postulates for argument graphsIn this section we examine the status of the postulates proposed in Section 4 under the various reviewed attack functions.5.1. Postulate SCFirst we show that when using any attack function satisfying D1, a free argument can neither be attacked by nor attackanother argument.Proposition 11. Let A be a free argument in G(cid:6)such that D(B, A) = (cid:6) or D( A, B) = (cid:6).D and let D be an attack function that satisfies D1. Then, there is no B ∈ Nodes(G(cid:6)D )D ) and suppose by way of contradiction that (B, A) ∈ Arcs(G(cid:6)D ), meaning that D(B, A) = (cid:6) byProof. Let B ∈ Nodes(G(cid:6)Definition 5. As D satisfies D1, this means that C(B) (cid:4) ¬S( A). This further entails that S( A) ∪ S(B) (cid:4) ⊥. Let M be theminimal inconsistent subset of S( A) ∪ S(B). If M ∩ S( A) (cid:16)= ∅ then A cannot be free, thus contradicting our assumption. IfM ∩ S( A) = ∅, then it must be that M ⊆ S(B), contradicting the consistency of the support of B. In both cases we have acontradiction. The case where A attacks B is proved in an identical way. (cid:2)(cid:2)Next we show that for any attack function satisfying D1, every complete extension will contain all free arguments in theargument graph.Proposition 12. Let S be a complete extension of G(cid:6)D and let D be an attack function that satisfies D1. Then, S ⊇ FreeArgs(G(cid:6)D ).Proof. Arguments in FreeArgs(G(cid:6)must contain them. (cid:2)D ) have no attacks whatsoever by Proposition 11, so trivially S defends them and thereforeWe can use the extension hierarchy to extend the previous result as follows.Proposition 13. Let D be an attack function that satisfies D1. All reviewed extensions of G(cid:6)postulate SC is satisfied.D contain all free arguments and thereforeProof. Follows directly from Proposition 12 and the extension hierarchy (Fig. 1). (cid:2)Since all attack functions in {D D , D U , D C U , DDU, DDD, D R , DDR} satisfy D1, the above result shows that they all satisfypostulate SC as well. Given that such a wide range of options for the attack function satisfy postulate SC, we may regard itas an uncontroversial postulate.5.2. Postulate CRHere we present results on the satisfaction of CR. We do this for the categories of attack functions delineated in Table 2.This means that we will use attack function postulates to prove that certain classes of attack functions satisfy or falsify CR.For reasons to do with the structure of the proofs and economy of space we will address these attack function classesfor the stable, semi-stable, preferred and complete semantics first, and then we will examine all these classes together forthe grounded and ideal semantics.1488N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14975.2.1. Attack functions based on canonical undercutsIn this section we examine the status of CR for the class of attack functions that satisfy D1, D2 and D6, and therefore aresuper-relations of D C U . We begin by introducing a definition of a set of arguments that is generated by a set of formulae.This is going to be a useful notion in the rest of this section.Definition 14. Let Φ ⊆ (cid:6) be a consistent set of formulae. The set of arguments SΦ is generated by Φ iff(cid:5)A ∈ A(cid:6)(cid:6) S( A) ⊆ Φ(cid:7)SΦ =It should be clear that for any consistent Φ ⊆ (cid:6), it is the case that SΦ ⊆ Nodes(G(cid:6)Next we show that for every consistent subset of Φ ⊆ (cid:6) we can find an admissible set of arguments that contains everyD ).argument based on Φ.Proposition 15. Suppose that D satisfies D1, D2 and D6, and let Φ ⊆ (cid:6) be a consistent set of formulae. Then, the set SΦ is admissiblein G(cid:6)D .Proof. First we show that SΦ is conflict-free. Suppose that A, B ∈ SΦ and that D( A, B) = (cid:6). Then as D satisfies D1 thismeans that S( A) ∪ S(B) (cid:4) ⊥, a contradiction since Φ was assumed consistent.We now show that SΦ defends itself. Let A ∈ SΦ and B an argument that attacks A, meaning that D(B, A) = (cid:6). ByS(B). We take Ψ to be the minimal subset of S( A) that entails(cid:2)D ) and by construction, C ∈ SΦ . By Proposition 7, we knowD1, it must be that S( A) ∪ S(B) (cid:4) ⊥, thus S( A) (cid:4) ¬(cid:2)¬that D(C, B) = (cid:6), completing the proof. (cid:2)S(B)(cid:5) is an argument in Nodes(G(cid:6)S(B). Then, C = (cid:3)Ψ, ¬(cid:2)We can now relate some consistent sets with stable extensions. For this, we require the notion of a maximal consistentsubset: For a set of formulae (cid:6), Φ ⊆ (cid:6) is a maximal consistent subset iff Φ is consistent and for all Φ(cid:15) ⊆ (cid:6), if Φ ⊂ Φ(cid:15),then Φ(cid:15)is not consistent.Proposition 16. Suppose that D satisfies D1, D2 and D6. Let Φ ⊆ (cid:6) be a maximal consistent set. Then, SΦ is a stable extensionof G(cid:6)D .Proof. Clearly, SΦ is conflict-free, since it is admissible (Proposition 15). Thus, SΦ is a stable extension iff SΦ attacks Afor any A /∈ SΦ . For the latter to be the case, it must be that S( A) (cid:3) Φ and from the maximality of Φ it follows thatΦ ∪ S( A) (cid:4) ⊥. Let Ψ be the minimal subset of S( A) such that Ψ (cid:4) ¬D . Itis also clear that B /∈ SΦ as otherwise the consistency of Φ would be contradicted. Consider the argument C = (cid:3)Φ(cid:15),Φ(cid:5) ∈SΦ , where Φ(cid:15) ⊆ Φ is the minimal subset that entails the claim. From Proposition 7 we know that D(B, C) = (cid:6) (since(cid:2)Φ). By the admissibility of SΦ it follows that there exists E ∈ SΦ such that D(E, B) = (cid:6). By D1, it follows that(cid:2)S(B) and thus S(E) (cid:4) ¬S( A), weS( A)(cid:5) ∈ SΦ and by applying Proposition 7 again it follows that D(F , A) = (cid:6), completing the proof. (cid:2)S( A). Taking Ψ (cid:15) ⊆ S(E) as the minimal set of formulae that entails ¬Φ(cid:15) ≡S(E) (cid:4) ¬obtain F = (cid:3)Ψ (cid:15), ¬Φ(cid:5) is an argument in G(cid:6)Φ. Then B = (cid:3)Ψ, ¬(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)We are now in a position to address the status of CR with regards to attack functions that satisfy D1, D2 and D6 and allextension semantics bar the grounded and ideal, which we address separately. Here, we prove that CR is falsified in thesecircumstances by showing that for any (cid:6), any argument is credulously accepted.Proposition 17. Suppose that D satisfies D1, D2 and D6, and let X be the stable, semi-stable, preferred or complete semantics. Then,for any (cid:6) and any argument A ∈ Nodes(G(cid:6)D ). Therefore, CR is not satisfied.D ), A ∈ σX(G(cid:6)Proof. Let A ∈ Nodes(G(cid:6)D ) be an argument and let Φ ⊆ (cid:6) be a maximal consistent set of formulae such that S( A) ⊆ Φ(such a set always exists by the consistency of supports of arguments). Then Proposition 16 applies confirming that the setof arguments SΦ is a stable (also semi-stable, preferred and complete) extension. Clearly, A ∈ SΦ . Thus, for any (cid:6) and anyargument A there is a stable, semi-stable, preferred and complete extension that includes it, completing the proof. (cid:2)5.2.2. Attack functions based on direct undercutsWe will look next at the class of attack functions satisfying the postulates D1these postulates would be a super-relation of DDU .(cid:15)(cid:15), D2 and D6. An attack function satisfyingWe again use maximally consistent sets to create stable extensions as follows. Note, a similar result to this was given byCayrol in [16]. The result may also be obtained via the correspondence established by Dung [3] relating stable extensionswith extensions of Reiter’s default logic where the attack relation is direct undercut, and the correspondence betweensupernormal default theories and maximal consistent subsets of knowledgebases [26].N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971489Proposition 18. Suppose that D satisfies D1in G(cid:6)D .(cid:15)(cid:15), D2 and D6. If Φ ⊆ (cid:6) is a maximally consistent set, then SΦ is a stable extensionProof. We first show that SΦ is conflict-free. If not, then there would be A, B ∈ SΦ such that D( A, B) = (cid:6), i.e., D( A, B) = (cid:6)(cid:15)and by D1, this means that S( A) ∪ S(B) (cid:4) ⊥, contradicting the consistency of Φ.We next show that SΦ attacks any argument not in SΦ . Let A ∈ SΦ and B ∈ Nodes(G(cid:6)D ) \ SΦ . By construction, thesupport of B must employ formulae not in Φ. Pick an arbitrary formula ψ ∈ S(B) \ Φ. As Φ is maximally consistent, itmust be that Φ ∪ {ψ} is inconsistent, therefore there is a minimal subset of Ψ ⊆ Φ such that Ψ (cid:4) ¬ψ . This means thatC = (cid:3)Ψ, ¬ψ(cid:5) is an argument and by construction C ∈ SΦ . Using Proposition 8 we obtain that D(C, B) = (cid:6), completing theproof. (cid:2)Using the above results we can show that the postulate CR is falsified.(cid:15)(cid:15), D2 and D6Proposition 19. Suppose that D satisfies D1D ), A ∈ σX(G(cid:6)for any (cid:6) and any argument A ∈ Nodes(G(cid:6), and let X be the stable, semi-stable, preferred or complete semantics. Then,D ). Therefore, CR is not satisfied.Proof. Let Φ ⊆ (cid:6) be a maximal consistent set of formulae such that S( A) ⊆ Φ. Then Proposition 18 applies confirmingthat the set of arguments SΦ is a stable (also semi-stable, preferred and complete) extension. Clearly, A ∈ SΦ . Thus, forany (cid:6) and any argument A there is a stable, semi-stable, preferred and complete extension that includes it, completing theproof. (cid:2)5.2.3. Attack functions based on rebuttalsHere we examine the status of CR in the context of attack functions that are super-relations of rebuttals, i.e., those that. For these attack functions, we show that we can construct a stable extension.(cid:15)(cid:15), D2 and D6(cid:15)(cid:15)satisfy D1(cid:15)(cid:15)Proposition 20. Suppose D satisfies D1tains A.(cid:15)(cid:15), D2 and D6, and A ∈ Nodes(G(cid:6)D ). Then there exists a stable extension of G(cid:6)D that con-Proof. A set of arguments generated by a maximally consistent subset of (cid:6) will be an admissible set. However it will notnecessarily be a stable extension since it partitions the set of all arguments on the basis of their supports and not on thebasis of their claims. It is for this reason that we need the following definition.Let Φ be a set of formulae such that:(a) There exists φ ∈ Φ such that φ = C( A).(b) If φ ∈ Φ then there exists B ∈ Nodes(G(cid:6)(c) For any φ, ψ ∈ Φ, it is the case that {φ, ψ} (cid:2) ⊥.(d) There is no Ψ which satisfies the above conditions and is a proper superset of Φ.D ) such that φ = C(B).Such a set must clearly always exist. We then define S ⊆ Nodes(G(cid:6)B ∈ S if and only if C(B) ∈ Φ.D ) to be the set of arguments whose claims are in Φ:First we show that S is conflict-free. Assuming the opposite, we obtain two arguments B, C ∈ S such that D(B, C) = (cid:6).(cid:15)(cid:15)Applying D1we get that C(B) (cid:4) ¬C(C), meaning that {C(B), C(C)} (cid:4) ⊥ contradicting condition (c) above.Now, we show that for any argument B ∈ Nodes(G(cid:6)D ) \ S, there is an argument C ∈ S such that D(C, B) = (cid:6). Beforedoing that we prove that Φ is closed under entailment. Suppose φ ∈ Φ and that φ (cid:4) ψ and that ψ /∈ Φ. This can only bebecause there is χ ∈ Φ such that {ψ, χ } (cid:4) ⊥, or that ψ (cid:4) ¬χ . But then φ (cid:4) ¬χ contradicting the assumption that φ, χ ∈ Φ.Next, we see that from the assumption that B /∈ S we obtain that C(B) /∈ Φ and, by condition (d) above, that there is C ∈S such that {C(B), C(C)} (cid:4) ⊥. Thus, C(C) (cid:4) ¬C(B). However, Φ is closed under entailment as shown above, therefore there(cid:15), B) = (cid:6), and thus, S attacks B. (cid:2)must be an argument C(cid:15)) ≡ ¬C(B). Applying Proposition 9 yields D(C(cid:15) ∈ S such that C(C(cid:15)(cid:15)(cid:15)(cid:15)Proposition 21. Suppose that D satisfies D1, D2 and D6D ), A ∈ σX(G(cid:6)for any (cid:6) and any argument A ∈ Nodes(G(cid:6)D ). Therefore, CR is not satisfied., and let X be the stable, semi-stable, preferred or complete semantics. Then,Proof. Proposition 20 applies confirming that the set of arguments S is a stable (also semi-stable, preferred and com-plete) extension. Clearly, A ∈ S. Thus, for any (cid:6) and any argument A there is a stable, semi-stable, preferred and completeextension that includes it, completing the proof. (cid:2)5.2.4. Attack functions based on undercutsFinally, we consider the status of CR in the case of the class of attack functions that satisfy D1, D2 and D6(cid:15)(cid:15)(cid:15). An attackfunction satisfying these postulates would be a superset of D U .Similarly to previous sections, we use maximally consistent sets of formulae to generate stable extensions as follows.1490N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497Proposition 22. Suppose that D satisfies D1, D2 and D6in G(cid:6)D .(cid:15)(cid:15)(cid:15). If Φ ⊆ (cid:6) is a maximally consistent set, then SΦ is a stable extensionProof. We first show that SΦ is conflict-free. If not, then there are A, B ∈ SΦ such that D( A, B) = (cid:6), and by D1, this meansthat S( A) ∪ S(B) (cid:4) ⊥, contradicting the consistency of Φ.We next show that SΦ attacks any argument not in SΦ . Let A ∈ SΦ and B ∈ Nodes(G(cid:6)D ) \ SΦ . By construction, thesupport of B must employ formulae not in Φ. As Φ is maximally consistent, it must be that Φ ∪ S(B) is inconsistent. Thus,Ψ (cid:5) is an argument. By construction, it is the casethere is a set Ψ ⊆ S(B) and a minimal set X ⊆ Φ such that C = (cid:3) X, ¬that C ∈ SΦ . Using D6, we obtain that D(C, B) = (cid:6), completing the proof. (cid:2)(cid:2)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)Proposition 23. Suppose that D satisfies D1, D2 and D6D ), A ∈ σX(G(cid:6)for any (cid:6) and any argument A ∈ Nodes(G(cid:6)D ). Therefore, CR is not satisfied., and let X be the stable, semi-stable, preferred or complete semantics. Then,Proof. Let Φ ⊆ (cid:6) be a maximal consistent set of formulae such that S( A) ⊆ Φ. Then Proposition 22 applies confirmingthat the set of arguments SΦ is a stable (also semi-stable, preferred and complete) extension. Clearly, A ∈ SΦ . Thus, forany (cid:6) and any argument A there is a stable, semi-stable, preferred and complete extension that includes it, completing theproof. (cid:2)5.2.5. The grounded and ideal extensionsWe now turn to the ideal and grounded extensions and examine these in the context of all four attack function classes wehave seen before. What distinguishes the ideal and grounded extension is that they are ‘sceptical’ extensions by definition,that is to say, there is exactly one ideal and one grounded extension at all times, and so some arguments will be excluded., the idealand grounded extensions can only contain free arguments. To prove this, we first show that any non-free argument has anattacker.In the case of an attack function that satisfies D2 and one of D1 and D6, or D1, or D1 and D6(cid:15)and D6(cid:15)(cid:15)(cid:15)(cid:15)Proposition 24. Let D be an attack function that satisfies D2 and one of D1 and D6, or D1NonFreeArgs(G(cid:6)D ) then there is an argument B ∈ Nodes(G(cid:6)D ) such that D(B, A) = (cid:6).(cid:15)(cid:15)and D6, or D1 and D6(cid:15)(cid:15)(cid:15). If A ∈Proof. As A is non-free, there exists a minimal inconsistent set M ∈ MI((cid:6)) such that M ∩ S( A) (cid:16)= ∅. It is easy to show thatD ) such that D(B, A) = (cid:6). For the case D satisfying D1 andin each case above, there exists an argument B ∈ Nodes(G(cid:6)D6, M ∩ S( A) (cid:16)= ∅ implies there is a C such that S(C) ⊆ M and C(C) ∪ S( A) (cid:4) ⊥. Therefore, C(C) (cid:4) ¬S( A). Therefore,there is a B such that S(B) ⊆ S(C) and C(C) (cid:4) C(B) and C(B) ≡ ¬S( A). Therefore, by the application of Proposition(cid:15)13, D(B, A) = (cid:6). For the case D satisfying D1, M ∩ S( A) (cid:16)= ∅ implies there is a φ ∈ S( A) such that M \ {φ} (cid:4) ¬φ.Therefore, there is a B such that S(B) = M \ {φ} and C(B) = ¬φ. Therefore, by the application of Proposition 8, D(B, A) = (cid:6)., M ∩ S( A) (cid:16)= ∅ implies there is an X ⊆ S( A) and an argument B such that S(B) =For the case D satisfying D1 and D6M \ X and C(B) ≡ ¬, D(B, A) = (cid:6). (cid:2)X . Therefore, by D6(cid:15)and D6(cid:2)(cid:2)(cid:2)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)We also obtain the following weaker result for an attack function that satisfies D2 and D1(cid:15)(cid:15)(cid:15)(cid:15)and D6.Proposition 25. Let D be an attack function that satisfies D2 and D1B, C ∈ Nodes(G(cid:6)(cid:15)(cid:15)and D6D ) such that S(B) = S( A) and D(C, B) = (cid:6) and D(B, C) = (cid:6).(cid:15)(cid:15). If A ∈ NonFreeArgs(G(cid:6)D ) then there are argumentsProof. As A is non-free, there exists a minimal inconsistent set M ∈ MI((cid:6)) such that M ∩ S( A) (cid:16)= ∅. Therefore, there existsan argument B such that S( A) = S(B) and C(B) =S( A). Since S( A) ⊆ M, there also exists an argument C such that(cid:2)S(C) ⊆ M and C(C) = ¬S( A). Therefore, by the application of Proposition 9, D(C, B) = (cid:6) and D(B, C) = (cid:6). (cid:2)(cid:2)Now we can prove that the ideal and the grounded extensions are equal to the set of free arguments for an attackfunction that satisfies D2 and one of D1 and D6, or D1(cid:15)(cid:15)and D6, or D1 and D6(cid:15)(cid:15)(cid:15).Proposition 26. Let D be an attack function that satisfies D2 and one of D1 and D6, or D1and grounded extensions are equal to the set of free arguments.(cid:15)(cid:15)and D6, or D1 and D6(cid:15)(cid:15)(cid:15). Then the ideal(cid:9)(cid:8)G(cid:6)Dσgr= σid(cid:8)G(cid:6)D(cid:9)(cid:8)= FreeArgsG(cid:6)D(cid:9)D ) ∩ NonFreeArgs(G(cid:6)Proof. We begin by showing that the intersection of all preferred extensions does not contain any non-free arguments,D ) = ∅. Suppose A is a non-free argument. From Propositions 17, 19, and 23, we know thator πpr(G(cid:6)there exists a preferred extension P A ∈ Epr(G(cid:6)D ) such that A ∈ P A . From Proposition 24 we obtain that there is an argumentD ) such that D(B, A) = (cid:6). By applying Propositions 17, 19 or 23, once again, we know that there is a preferredB ∈ Nodes(G(cid:6)N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971491extension P B ∈ Epr(G(cid:6)A /∈ πpr(G(cid:6)D ). Thus, πpr(G(cid:6)D ) ⊆ FreeArgs(G(cid:6)D ).D ) such that B ∈ P B . As both P A and P B are by definition conflict-free, A /∈ P A ∩ P B and thereforeIt is known that for any argument graph Γ , the grounded extension is a subset of the ideal extension which, in turn, isa subset of the intersection of all preferred extensions [13].σgr(Γ ) ⊆ σid(Γ ) ⊆ πpr(Γ )Combining Proposition 13 and the above result gives us(cid:9)(cid:8)(cid:9)(cid:8)(cid:8)(cid:9)(cid:9)G(cid:6)D⊆ σgrG(cid:6)D⊆ σidG(cid:6)D⊆ πprG(cid:6)D(cid:8)FreeArgs(cid:8)⊆ FreeArgs(cid:9)G(cid:6)Dor in other words,(cid:8)(cid:9)σgrG(cid:6)D= σid(cid:9)(cid:8)G(cid:6)D(cid:8)= FreeArgsG(cid:6)D(cid:9)(cid:2)Finally, we address the status of CR for the ideal and the grounded extensions.Proposition 27. Let D be an attack function that satisfies D2 and one of the following pairs of postulates: D1 and D6, or D1(cid:15)(cid:15)or D1. Then, the postulate CR is satisfied for the grounded and ideal extensions., or D1 and D6(cid:15)(cid:15)and D6(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)and D6,Proof. Suppose (cid:6) is inconsistent. This means that MI((cid:6)) (cid:16)= ∅, and thus, NonFreeArgs(G(cid:6)(cid:15)(cid:15)and D6and one of D1 and D6, or D1D ) = σid(G(cid:6)fore (by Proposition 26) σgr(G(cid:6)there are arguments A, B ∈ Nodes(G(cid:6)D ) or B /∈ σid(G(cid:6)A /∈ σid(G(cid:6)D ) (cid:16)= ∅. For D that satisfies D2D ) and there-, it will be the case thatD ) such that D(B, A) = (cid:6) and D( A, B) = (cid:6) (following from Proposition 25). Therefore,, it will be the case that FreeArgs(G(cid:6)(cid:15)(cid:15)and D6(cid:15)(cid:15)D ). For D that satisfies D2, D1(cid:15)(cid:15)(cid:15), or D1 and D6D ) (cid:16)= Nodes(G(cid:6)D ). Also since σgr(G(cid:6)D ). Hence, σid(G(cid:6)D ) ⊂ Nodes(G(cid:6)D ) (cid:16)= Nodes(G(cid:6)D ) (cid:16)= Nodes(G(cid:6)D ) ⊆ σid(G(cid:6)D ), σgr(G(cid:6)D ). (cid:2)The CR postulate has allowed us to differentiate the options for argumentation with classical logic where all argumentsthat can be constructed from the knowledgebase are considered in the argument graph. For the credulous semantics (i.e.stable, semi-stable, preferred, and complete semantics) we get that every non-free argument is contained in at least one, butnot all extensions, whereas for the sceptical semantics (i.e. grounded and ideal semantics) with the attack function satisfying(cid:15)(cid:15)(cid:15)(cid:15), we get that the extensions contain no non-free arguments.D2 and one of D1 and D6, or D1An interpretation of these results is that the credulous semantics is perhaps too credulous and the sceptical semantics isperhaps too sceptical. Furthermore, these results suggest that a different defeat function or extension semantics should beused or that an alternative to the argument generator (Definition 5) should be used. Alternatively, priorities over formulae,and thereby over arguments, can be harnessed (e.g. [27,28])., or D1 and D6(cid:15)and D65.3. ConsistencyIn this section we look at the status of the consistency postulates. For the attack functions that only have free argumentsin the grounded and the ideal extensions, it is easy to see that CN1 will hold.Proposition 28. Let D be an attack function that satisfies D2 and one of the following pairs D1 and D6, or D1D6. Then, the postulate CN1 is satisfied for the grounded and ideal extensions.(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)and D6, or D1 andProof. As shown in Proposition 26, the ideal and the grounded extensions are equal to the set of free arguments. Let Φ =(cid:11)D ) S( A) and suppose that Φ (cid:4) ⊥. This means that there is M ∈ MI((cid:6)) such that M ⊆ Φ. But this means thatD ) such that M ∩ S( A) (cid:16)= ∅, contradicting the definition of free arguments. (cid:2)there is at least one argument A ∈ FreeArgs(G(cid:6)A∈FreeArgs(G(cid:6)We can generalise this result for the other extensions as follows.Proposition 29. Let D be an attack function that satisfies D2 and one of the following pairs D1 and D6, or D1D6. Then, for any of the reviewed extension semantics X,(cid:15)(cid:15)(cid:15)(cid:15)(cid:15)and D6, or D1 and(cid:8)G(cid:6)DπX(cid:9)(cid:8)= FreeArgsG(cid:6)D(cid:9)Proof. We have already shown this result for the ideal and grounded extensions in Proposition 26. We do this here for thestable, semi-stable, preferred and complete semantics.From the extension hierarchy, we know that(cid:9)(cid:8)(cid:8)(cid:9)(cid:9)(cid:8)(cid:8)EstG(cid:6)D⊆ EssG(cid:6)D⊆ EprG(cid:6)D⊆ EcoG(cid:6)D(cid:9)1492N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497Thus, the sceptically accepted sets of arguments will obey an inequality in the opposite direction:(cid:8)(cid:9)(cid:8)(cid:9)(cid:8)(cid:9)(cid:8)(cid:9)πstG(cid:6)D⊇ πssG(cid:6)DFrom Proposition 12, we know that πco(G(cid:6)⊇ πco⊇ πprG(cid:6)DG(cid:6)DD ) ⊆ FreeArgs(G(cid:6)D ). Thus it suffices to show that πst(G(cid:6)D ) ⊇ FreeArgs(G(cid:6)D ).Suppose that a non-free argument A is a member of πst(G(cid:6)D ). This means that A belongs to every stable extension ofG(cid:6)D ) such that D(B, A) = (cid:6). By Propositions 17,19 and 23, it follows that there is a stable extension S B containing B. But this leads to a contradiction, since A, B ∈ S B andS B is a stable extension and, therefore, conflict-free. (cid:2)D . As shown in Proposition 24, there must be an argument B ∈ Nodes(G(cid:6)Thus, it is simple to show that CN1 is satisfied for attack functions that satisfy D2 and one of D1 and D6, or D1(cid:15), or D1 and D6D6(cid:15)(cid:15)(cid:15).(cid:15)andProposition 30. Let D be an attack function that satisfies D2 and either D1 and D6, or D1postulate CN1 is satisfied for the stable, semi-stable, preferred and complete extensions.(cid:15)(cid:15)and D6, or D1 and D6(cid:15)(cid:15)(cid:15). Then, the(cid:11)Proof. Let Core((cid:6)) =Free((cid:6)). So,(cid:11)(cid:11)Therefore,A∈πX(G(cid:6)D )A∈FreeArgs(G(cid:6)(cid:2) ⊥. (cid:2)M∈MI((cid:6)) M and let Free((cid:6)) = (cid:6) \ Core((cid:6)). Hence, Free((cid:6)) (cid:2) ⊥. Also, A ∈ FreeArgs(G(cid:6)A∈FreeArgs(G(cid:6)D )D ) S( A) ⊆ Free((cid:6)). Hence,(cid:2) ⊥. From Proposition 29, πX(G(cid:6)D ) iff S( A) ⊆D ) = FreeArgs(G(cid:6)D ).(cid:11)For an attack function that satisfies D2, and either D1 and D6, or D1(cid:15)satisfied, so is CN1(cid:15)CN1 and CN1by implication. Whereas for an attack function that satisfies D1are not satisfied using the following examples.(cid:15)(cid:15)and D6, or D1 and D6(cid:15)(cid:15), D2 and D6(cid:15)(cid:15), it is clear that as CN1 is, we show that postulates(cid:15)(cid:15)(cid:15)Example 31. Let (cid:6) = {a ∧ b, ¬a ∧ c}. Hence, (cid:3){a ∧ b}, b(cid:5) and (cid:3){¬a ∧ c}, c(cid:5) are arguments in πX(G(cid:6)(cid:15)(cid:15)when an attack function that satisfies D1, D2 and D6(cid:15)(cid:15)for an attack function that satisfies D1.D ) for the reviewed semantics, and clearly {a ∧ b, ¬a ∧ c} (cid:4) ⊥. Hence, postulate CN1 is not satisfied(cid:15)(cid:15), D2 and D6(cid:15)(cid:15)Example 32. Consider the (cid:6) = {a ∧ ¬c ∧ d, (¬a ∨ ¬b) ∧ c ∧ d, b ∧ c ∧ ¬d}. These formulae are pairwise inconsistent, andso each argument from this knowledgebase has only one premise. Now, consider the following arguments which can beformed from (cid:6):(cid:12)(cid:13)A1 =A2 =A3 ={a ∧ ¬c ∧ d}, a(cid:12)(cid:5)(¬a ∨ ¬b) ∧ c ∧ d{b ∧ c ∧ ¬d}, b(cid:13)(cid:12)(cid:7)(cid:13), ¬a ∨ ¬bFor each Ai ∈ { A1, A2, A3}, there is no argument B from (cid:6) such that B is a rebuttal of Ai . Therefore, A1, A2, and A3, belongto each preferred extension of (cid:6), and so { A1, A2, A3} ⊆ π X (G(cid:6)D ). However, {C( A1), C( A2), C( A3)} (cid:4) ⊥. Therefore, postulate(cid:15)is not satisfied for an attack function that satisfies D1CN1(cid:15)(cid:15), D2 and D6(cid:15)(cid:15).Next we turn our attention to postulates CN2 and CN2. It is easy to see that due to Proposition 29 and the fact that, whenthere is exactly one grounded and one ideal extension, these extension semantics will always satisfy CN2 and CN2the attack function satisfies D2 and one of D1 and D6, or D1. For an attack function that satisfies(cid:15)(cid:15)D1is notsatisfied. In what follows, we examine the remaining extension semantics. We begin by showing a general result regarding(cid:15)postulate D3, we can use Example 31 to show postulate CN2 is not satisfied and Example 32 to show postulate CN2, or D1 and D6(cid:15)(cid:15)and D6(cid:15)and D6(cid:15)(cid:15)(cid:15).(cid:15)(cid:15)(cid:15)(cid:15)Proposition 33. Let D be an attack function that satisfies D3(where A is a sub-argument of B when S( A) ⊆ S(B)).(cid:15). Then any complete extension of G(cid:6)D is closed under sub-argumentsProof. Suppose that S is a complete extension, A ∈ S, B is a sub-argument of A and that C is an argument that attacks B.(cid:15)As S(B) ⊆ S( A) it follows from D3that D(C, A) = (cid:6). But, as S is a complete extension it must defend A and thereforedefend B as well. Thus, B ∈ S. (cid:2)With Proposition 33 at our disposal we can approach the status of CN2 and CN2(cid:15). Next, we show that attack functions(cid:15)satisfying D2, D1(cid:15), D6(cid:15)and D3, satisfy both of these postulates. Such attack functions include DDD and DDU .Proposition 34. Let D be an attack function that satisfies D2, D1(cid:15)postulates CN2 and CN2hold.(cid:15)(cid:15), D6(cid:15)and D3. Then, for any of the reviewed extension semantics X,N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971493Fig. 3. Argument graph for Example 35.Fig. 4. Argument graph for Example 36.(cid:11)Proof. Having already discussed the status of these postulates regarding the grounded and the ideal extensions, we onlyneed to address the case of the stable, semi-stable, preferred and complete extensions. Once again we will make use of theextension hierarchy and prove that these postulates are satisfied for any complete extension. As all other extensions arealso complete, the result follows. Also, we will only show that CN2 is satisfied, as in that case, CN2will be satisfied byimplication. Suppose then that S ⊆ Nodes(G(cid:6)Let Φ =A∈S S( A). Aiming for a contradiction, assume that Φ (cid:4) ⊥, or in other words, that there exists M ∈ MI((cid:6)) suchthat M ⊆ Φ. Clearly, this means that there exists an argument A ∈ S such that M ∩ S( A) (cid:16)= ∅. Pick a formula ψ ∈ M ∩ S( A)and consider the argument B = (cid:3)M \ {ψ}, ¬ψ(cid:5). Using Proposition 8, we conclude that D(B, A) = (cid:6) and that, since S isa complete extension, S must defend A. Thus, there exists an argument C ∈ S such that D(C, B) = (cid:6). From D1followsthat there exists χ ∈ S(B), and therefore χ ∈ M, such that C(C) (cid:4) ¬χ . There also exists an argument E = (cid:3)Ψ, ¬χ (cid:5) suchthat Ψ ⊆ S(C) is the minimal subset that entails ¬χ . By Proposition 8, it follows that D(E, B) = (cid:6) and as E is a sub-argument of C it must be that E ∈ S, as shown in Proposition 33. As M ⊆ Φ and χ ∈ M there must exist an argument F ∈ Ssuch that χ ∈ S(F ). Another application of Proposition 8 yields that D(E, F ) = (cid:6), contradicting the assumption that S isconflict-free. (cid:2)D ) is a complete extension.(cid:15)(cid:15)(cid:15)The remaining attack functions, namely D D , D C U , D U , D R and DDR, do not satisfy CN2 nor CN2. We provide counterex-amples below.Example 35. Consider the knowledge base (cid:6) = {a, b, ¬a ∨ ¬b} and suppose we are using the attack function D C U . It can beseen that there is a stable extension containing all arguments, e.g., on the left column. Such an extension violates both CN2(cid:15)and CN2. (See the argument graph presented in Fig. 3.)Example 36. In a similar way to the last example, we will use the knowledge base (cid:6) = {a, b, ¬a ∨ ¬b} again with the attack(cid:15)function D U . We present the graph in Fig. 4: Here, there is a readily observable stable extension that violates CN2 and CN2,namely the five arguments marked with∗.Example 37. We again use the knowledge base (cid:6) = {a, b, ¬a ∨ ¬b} with the attack function D D . The relevant part of thegraph is shown in Fig. 37. We use ⊕ to denote concisely the XOR operation, i.e., φ ⊕ ψ ≡ (φ ∧ ¬ψ) ∨ (¬φ ∧ ψ). It can be seenthat the five arguments marked withform part of a stable extension, while the union of their supports is inconsistent, as(cid:15)well as the union of their claims. Thus D D fails to satisfy CN2 and CN2∗.(cid:15)Example 38. We use the knowledge base (cid:6) = {a ∧ b, a ∧ ¬b} and show that when using D R , the postulates CN2 and CN2are not satisfied. For this, we get the argument graph in Fig. 6. There are several stable extensions containing both thearguments marked with. Every such stable extension violates both CN2 and CN2∗.(cid:15)Note, Cayrol in [16] has also given an example that shows that DDR violates CN2.1494N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497Fig. 5. Argument graph for Example 37.Fig. 6. Argument graph for Example 38.Fig. 7. Argument graph for Example 39.Example 39. We show that DDR violates CN2 with the knowledge base (cid:6) = {a ∧ b, a ∧ ¬b}. The argument graph is given inFig. 7. It should be clear that the set of arguments marked withis a stable extension that violates CN2 as well as CN2∗.(cid:15)In conclusion, we can state the following. Postulates CN1 and CN1are satisfied by all combinations of extension seman-(cid:15)tics with all attack functions considered in this paper that satisfy D3. Postulates CN2 and CN2are satisfied by all attackfunctions considered in this paper that satisfy D3 in the case of the grounded and ideal extensions and only by D DD andDDU in the case of the complete, preferred, semi-stable and stable semantics. As DDU is the most widely considered defeatrelation in the literature, it is interesting that the CN2 and CN2postulates hold with credulous semantics. However, thefailure of these postulates with other defeat relations is an issue that may be interpreted as a weakness of the defeat rela-tion or of the specific semantics, and perhaps raising the need for alternatives to be identified. Another response is that itis not the defeat relation and dialectical semantics that should be responsible for ensuring that all the premises used in the(cid:15)(cid:15)N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971495winning arguments are consistent together. Rather, it could be argued that checking that the premises used are consistenttogether should be the responsibility of something external to the defeat relation and dialectical semantics, and so knowing(cid:15)whether the CN2 and CN2postulates hold or not influences what external mechanisms are required for checking. Further-more, checking consistency of premises of sets of arguments may be part of the graph construction process. For instance,in Garcia and Simari’s proposal for dialectical trees [29], there are constraints on what arguments can be added to the treebased on consistency with the premises of other arguments in the tree.6. DiscussionIn this paper we have investigated the use of classical logic for constructing argument graphs. The first component ofthis approach is an attack relation and we have explored various desirable properties for them in Section 3. Using theseproperties, we have been able to classify and characterise several concrete attack relations. We then proceeded to proposepostulates that express desirable requirements concerning the logical content of extensions of argument graphs constructedusing classical logic in Section 4. Now, we examine related work and discuss the ways that we can extend this research.Classical logic has been considered previously as a logic for constructing argument graphs. Wooldridge, Dunne and Par-sons, in [30], investigate the complexity of some decision problems on classical logic argumentation graphs with the directundercut attack relation. Although very interesting because of the computational issues raised, [30] does not examine theproperties of the content of extensions. In [27], Amgoud and Cayrol propose an argumentation framework with preferences,which uses classical logic. The focus of the paper is on the use of preferences and, therefore, the consequences of usingclassical logic are not investigated. In [19], Amgoud and Besnard have similar goals to ours and propose a consistency con-dition which we have drawn upon for our postulates. They examine special cases of knowledge bases and symmetric attackrelations and whether consistency is satisfied in this context. Then in [20], Amgoud and Besnard extend this analysis byshowing a correspondence between the maximal consistent subsets of a knowledgebase and the maximal conflict-free setsof arguments. Cayrol, in [16], presents results similar to Proposition 18 and Example 38. However, in all these cases, thefocus is on consistency and few other properties of the logical content of extensions are studied. In addition, there is a lackof consideration of the range of attack relations.Postulates regarding properties of logical argumentation graphs have been investigated before. Caminada and Amgoud[25,18] and Caminada [31], propose a consistency postulate and a closure postulate (which we discuss further below). Thisis done, however, in the context of a rule-based language as opposed to classical logic, and using a fixed attack relation.Similarly, Martínez, García and Simari, in [32], modify Dung’s definitions of acceptability to include the notion of warrant,, which they call conflict inheritance. In contrast to our work, [32]and in the process formulate a condition similar to D3stays at the level of abstract argument graphs and does not extend to the object-language level.(cid:15)Given that we want our framework to capture existing proposals, we have allowed for arguments with syntacticallydifferent supports to be differentiated. Hence, this means that we have specified that two arguments are equivalent if theyhave identical support and logically equivalent claims. However, the framework can be adapted so that arguments A and Bare equivalent if they have logically equivalent support and logically equivalent claims. This then raises the need to considerfurther postulates in future work such as the following:∗)∗∗(D3(D3if D( A, B) = (cid:6) and S(B) ≡ S(C) then D( A, C) = (cid:6)(cid:10))if D( A, B) = (cid:6) and S(C) (cid:4)S(B) then D( A, C) = (cid:6)With regards to further work, several questions remain open. An important question is whether there exist postulatesother than those we examine here, that are interesting to study. As mentioned above, Caminada and Amgoud have proposeda closure postulate in the context of rule-based argumentation systems. Such a principle could be encoded as follows in ourapproach:(CL1)if(CL2)if(CL1(cid:15))(CL2(cid:15))ifif(cid:4)S( A) (cid:4) φ then πX(cid:9)(cid:8)G(cid:6)D(cid:2) φA∈πX(G(cid:6)D )(cid:4)S( A) (cid:4) φ then S (cid:2) φ, for all S ∈ EXA∈S(cid:4)C( A) (cid:4) φ then πX(cid:9)(cid:8)G(cid:6)D(cid:2) φA∈πX(G(cid:6)D )(cid:4)C( A) (cid:4) φ then S (cid:2) φ, for all S ∈ EX(cid:9)(cid:8)G(cid:6)D(cid:9)(cid:8)G(cid:6)DA∈SHere, the intuition is that if the arguments in an extension carry the information required to prove a particular formula,then there should be an argument in the extension whose claim entails that formula. Once again there are several variationspossible on this principle, as seen above. Variations of the postulates CL1have appeared in [31,18]. Here, we(cid:15)and CL2(cid:15)1496N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–1497introduce CL1 and CL2 as well, as natural extensions in the context of classical logic. It is easy to see that CL1 entails CL2,(cid:15)CL1(cid:15)entails CL1 and CL2(cid:15)entails CL2entails CL2.(cid:15), CL1Another question for future work is the choice of definition for generating logical argument graphs. The definition forthe argument generator (Definition 5) which we use is a natural choice, but it would be useful to investigate alternativedefinitions to account for proposals such as the argument tree definition in [6,9].Recently, a number of interesting developments of abstract argumentation have been proposed. These build on Dung’sproposal to provide more sophisticated modelling of argumentation, such as value-based argumentation framework (whichallow for the moral values of the audience to be taken into account) [33], bipolar abstract frameworks (which allow forsupport relations to also be included) [34], argumentation frameworks with weighted attacks [35,36], extended frameworkswhere arguments can express preference between other arguments [37,38]. It would be interesting, in future work, toinvestigate the instantiation of these frameworks with classical logic, and at the same time identify new postulates toconstrain and justify these instantiations.Finally, we have identified that for some attack relations, when Φ is a maximal consistent set, and SΦ is the set ofarguments generated by Φ (as given in Definition 12), then SΦ is a stable extension. So another interesting question iswhether the converse holds.AcknowledgementsThe authors are very grateful to Philippe Besnard and to the anonymous reviewers for making a number of importantsuggestions for improving the paper.References[1] J. Pollock, Defeasible reasoning, Cognitive Science 11 (4) (1987) 481–518.[2] M. Elvang-Gøransson, P. Krause, J. Fox, Acceptability of arguments as ‘logical uncertainty’, in: Proceedings of the European Conference on Symbolic andQuantitative Approaches to Reasoning and Uncertainty (ECSQARU’93), Springer-Verlag, 1993, pp. 85–90.[3] P. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, ArtificialIntelligence 77 (2) (1995) 321–357.[4] A. Bondarenko, P. Dung, R. Kowalski, F. Toni, An abstract, argumentation-theoretic approach to default reasoning, Artificial Intelligence 93 (1997) 63–101.[5] H. Prakken, G. Sartor, Argument-based extended logic programming with defeasible priorities, Journal of Applied Non-Classical Logics 7 (1) (1997)25–75.[6] Ph. Besnard, A. Hunter, A logic-based theory of deductive arguments, Artificial Intelligence 128 (1–2) (2001) 203–235.[7] C. Chesñevar, A. Maguitman, R. Loui, Logical models of argument, ACM Computing Surveys 32 (4) (2000) 337–383.[8] T. Bench-Capon, P. Dunne, Argumentation in artificial intelligence, Artificial Intelligence 171 (10–15) (2007) 619–641.[9] Ph. Besnard, A. Hunter, Elements of Argumentation, MIT Press, 2008.[10] I. Rahwan, G. Simari, Argumentation in Artificial Intelligence, Springer, 2009.[11] J. Alferes, P. Dung, L. Pereira, Scenario semantics of extended logic programs, in: A. Nerode, L. Pereira (Eds.), Proceedings of the 2nd InternationalWorkshop on Logic Programming and Non-Monotonic Reasoning, MIT Press, 1993, pp. 334–348.[12] M. Caminada, Semi-stable semantics, in: P. Dunne, T. Bench-Capon (Eds.), Proceedings of International Conference on Computational Models of Argu-ment (COMMA’06), vol. 144, IOS Press, 2006, pp. 121–130.[13] P. Dung, P. Mancarella, F. Toni, Computing ideal sceptical argumentation, Artificial Intelligence 171 (10–15) (2007) 642–674.[14] G. Simari, R. Loui, A mathematical treatment of defeasible reasoning and its implementation, Artificial Intelligence 53 (1992) 125–157.[15] S. Parsons, M. Wooldridge, L. Amgoud, Properties and complexity of some formal inter-agent dialogues, Journal of Logic and Computation 13 (3) (2003)347–376.[16] C. Cayrol, On the relation between argumentation and non-monotonic coherence-based entailment, in: Proceedings of the Fourteenth InternationalJoint Conference on Artificial Intelligence (IJCAI’95), 1995, pp. 1443–1448.[17] P. Dung, R. Kowalski, F. Toni, Dialectical proof procedures for assumption-based admissible argumentation, Artificial Intelligence 170 (2006) 114–159.[18] M. Caminada, L. Amgoud, On the evaluation of argumentation formalisms, Artificial Intelligence 171 (5–6) (2007) 286–310.[19] L. Amgoud, Ph. Besnard, Bridging the gap between abstract argumentation systems and logic, in: Proceedings of the Third International Conference onScalable Uncertainty Management (SUM’09), in: Lecture Notes in Computer Science, vol. 5785, Springer, 2009, pp. 12–27.[20] L. Amgoud, Ph. Besnard, A formal analysis of logic-based argumentation systems, in: Proceedings of the Fourth International Conference on ScalableUncertainty Management (SUM’10), in: Lecture Notes in Computer Science, vol. 6379, Springer, 2010, pp. 42–55.[21] J. Pollock, How to reason defeasibly, Artificial Intelligence 57 (1) (1992) 1–42.[22] M. Elvang-Gøransson, A. Hunter, Argumentative logics: Reasoning with classically inconsistent information, Data and Knowledge Engineering 16 (2)(1995) 125–145.[23] Ph. Besnard, A. Hunter, Towards a logic-based theory of argumentation, in: Proceedings of the Seventeenth National Conference on Artificial Intelligence(AAAI’00), AAAI Press/The MIT Press, 2000, pp. 411–416.[24] A. Hunter, Real arguments are approximate arguments, in: Proceedings of the 22nd AAAI Conference on Artificial Intelligence (AAAI’07), MIT Press,2007, pp. 66–71.[25] M. Caminada, L. Amgoud, An axiomatic account of formal argumentation, in: Proceedings of the 20th National Conference on Artificial Intelligence(AAAI’05), AAAI Press, 2005, pp. 608–613.[26] G. Brewka, I. Niemela, M. Truszczynski, Nonmonotonic reasoning, in: V. Lifschitz, B. Porter, F. van Harmelen (Eds.), Handbook of Knowledge Represen-tation, Elsevier, 2007, pp. 239–284.[27] L. Amgoud, C. Cayrol, A reasoning model based on the production of acceptable arguments, Annals of Mathematics and Artificial Intelligence 34 (1–3)(2002) 197–215.[28] L. Amgoud, S. Vesic, Handling inconsistency with preference-based argumentation, in: Proceedings of the 4th International Conference on ScalableUncertainty Management (SUM’10), in: Lecture Notes in Computer Science, vol. 6379, Springer, 2010, pp. 56–69.[29] A. García, G. Simari, Defeasible logic programming: An argumentative approach, Theory and Practise of Logic Programming 4 (2004) 95–138.N. Gorogiannis, A. Hunter / Artificial Intelligence 175 (2011) 1479–14971497[30] M. Wooldridge, P. Dunne, S. Parsons, On the complexity of linking deductive and abstract argument systems, in: Proceedings of the 21st NationalConference on Artificial Intelligence (AAAI’06), AAAI Press, 2006, pp. 299–304.[31] M. Caminada, Contamination in formal argumentation systems, in: Proceedings of the Seventeenth Belgium–Netherlands Conference on Artificial Intel-ligence (BNAIC’05), Koninklijke Vlaamse Academie van Belie voor Wetenschappen en Kunsten, 2005, pp. 59–65.[32] D. Martínez, A. García, G. Simari, Modelling well-structured argumentation lines, in: Proceedings of the 20th International Joint Conference on ArtificialIntelligence (IJCAI’07), 2007, pp. 465–470.[33] T. Bench-Capon, Persuasion in practical argument using value-based argumentation frameworks, Journal of Logic and Computation 13 (3) (2003) 429–448.[34] L. Amgoud, C. Cayrol, M. Lagasquie-Schiex, P. Livet, On bipolarity in argumentation frameworks, International Journal Intelligent Systems 23 (10) (2008)1062–1093.[35] H. Barringer, D. Gabbay, J. Woods, Temporal dynamics of support and attack networks: From argumentation to zoology, in: Mechanizing MathematicalReasoning, in: Lecture Notes in Computer Science, vol. 2605, Springer, 2005, pp. 59–98.[36] P.E. Dunne, A. Hunter, P. McBurney, S. Parsons, M. Wooldridge, Inconsistency tolerance in weighted argument systems, in: Proceedings of the 8thInternational Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS 2009), IFAAMAS, 2009, pp. 851–858.[37] P. Baroni, F. Cerutti, M. Giacomin, G. Guida, Encompassing attacks to attacks in abstract argumentation frameworks, in: Symbolic and QuantitativeApproaches to Reasoning with Uncertainty (ECSQARU 2009), in: Lecture Notes in Computer Science, vol. 5590, Springer, 2009, pp. 83–94.[38] S. Modgil, Reasoning about preferences in argumentation frameworks, Artificial Intelligence 173 (9–10) (2009) 901–934.