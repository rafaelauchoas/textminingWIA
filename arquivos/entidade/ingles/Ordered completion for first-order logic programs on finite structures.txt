Artificial Intelligence 177–179 (2012) 1–24Contents lists available at SciVerse ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintOrdered completion for first-order logic programs on finite structuresVernon Asuncion a, Fangzhen Lin b, Yan Zhang a, Yi Zhou a,∗a Intelligent Systems Lab, School of Computing and Mathematics, University of Western Sydney, Penrith South DC, NSW 1797, Australiab Department of Computer Science, Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Konga r t i c l ei n f oa b s t r a c tArticle history:Received 20 October 2010Received in revised form 16 November 2011Accepted 17 November 2011Available online 25 November 2011Keywords:Answer set programmingOrdered completionKnowledge representationNonmonotonic reasoningIn this paper, we propose a translation from normal first-order logic programs under thestable model semantics to first-order sentences on finite structures. The translation is donethrough, what we call, ordered completion which is a modification of Clark’s completionwith some auxiliary predicates added to keep track of the derivation order. We show that,on finite structures, classical models of the ordered completion of a normal logic programcorrespond exactly to the stable models of the program. We also extend this result tonormal programs with constraints and choice rules.From a theoretical viewpoint, this work clarifies the relationships between normal logicprogramming under the stable model semantics and classical first-order logic. It followsthat, on finite structures, every normal program can be defined by a first-order sentence ifnew predicates are allowed. This is a tight result as not every normal logic program canbe defined by a first-order sentence if no extra predicates are allowed or when infinitestructures are considered. Furthermore, we show that the result cannot be extended todisjunctive logic programs, assuming that NP (cid:3)= coNP.From a practical viewpoint, this work leads to a new type of ASP solver by groundingon a program’s ordered completion instead of the program itself. We report on afirst implementation of such a solver based on several optimization techniques. Ourexperimental results show that our solver compares favorably to other major ASP solverson the Hamiltonian Circuit program, especially on large domains.Crown Copyright © 2011 Published by Elsevier B.V. All rights reserved.1. IntroductionThis work is about translating logic programs under the stable model (answer set) semantics [12] to first-order logic.Viewed in the context of formalizing the semantics of logic programs in classical logic, work in this direction goes back tothat of Clark [4] who gave us what is now called Clark’s completion semantics, on which our work, like most other work inthis direction, is based.In terms of the stable model semantics, Clark’s completion semantics is too weak in the sense that not all models ofClark’s completion are stable models, unless the programs are “tight” [8]. Various ways to remedy this have been proposed,particularly in the propositional case given the recent interest in Answer Set Programming (ASP) and the prospect of usingSAT solvers to compute answer sets [19]. This paper considers first-order logic programs, and the prospect of capturing theanswer sets of these programs in first-order logic.A crucial consideration for work of this kind is whether auxiliary symbols (in the propositional case) or predicates (inthe first-order case) can be used. For propositional logic programs, Ben-Eliyahu and Dechter’s translation [1] is polynomialin space but uses O (n2) auxiliary variables, while Lin and Zhao’s translation [19] using loop formulas is exponential in the* Corresponding author.E-mail addresses: vernon@scm.uws.edu.au (V. Asuncion), flin@cse.ust.hk (F. Lin), yan@scm.uws.edu.au (Y. Zhang), yzhou@scm.uws.edu.au (Y. Zhou).0004-3702/$ – see front matter Crown Copyright © 2011 Published by Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2011.11.0012V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24worst case but does not use any auxiliary variables. Chen et al. [2] extended loops and loop formulas to first-order case andshowed that for finite domains, the answer sets of a first-order normal logic program can be captured by its completionand first-order loop formulas. However, in general, a program may have an infinite number of loops and loop formulas.But this seems to be the best that one can hope for if no auxiliary predicates are used: it is well known that transitiveclosure, which can be easily written as a first-order logic program, cannot be captured by any finite first-order theory onfinite structures [5].The situation is different if we introduce auxiliary predicates. Our main technical result of this paper is that by usingsome additional predicates that keep track of the derivation order from bodies to heads in a program, we can modify Clark’scompletion into what we call the ordered completion that captures exactly the answer set semantics on finite structures.The rest of the paper is organized as follows. We recall some background knowledge in the next section. In Section 3, wedefine our ordered completions for first-order normal logic programs, and show that they capture exactly the stable modelsof the programs on finite structures. We then show that this result can be extended to normal programs with constraintsand choice rules. However, it cannot be extended to disjunctive logic programs and does not hold on arbitrary structures.Specifically, in Section 3 we show that, on arbitrary structures, there exist some normal logic programs that cannot becaptured by any first-order theory, and on finite structures, there exists some disjunctive logic program that cannot becaptured by any first-order sentence provided that NP (cid:3)= coNP. We then present some techniques for optimizing orderedcompletions in Section 4. These techniques are used in our implementation of a first-order solver. We describe this solverand some of the experimental results in Section 5. We discuss some related work in Section 6, and conclude the paper inSection 7.2. PreliminariesWe assume that readers are familiar with some basic notions and notations of classical first-order logic. Here, we considera finite first-order language without function symbols but with equality. In particular, an atom is called an equality atom ifit is of the form t1 = t2, and a proper atom otherwise.Let σ and σ1 be two signatures such that σ ⊆ σ1. Given a structure A of signature σ1, we say that the reduct of A on σ ,denoted by A ↑ σ , is the σ -structure that agrees with A on all interpretations of predicates and constants in σ . Conversely,we say that A is an expansion of A ↑ σ to σ1.A normal logic program (program for short) is a finite set of rules of the following formα ← β1, . . . , βk, not γ1, . . . , not γl,(1)where α is a proper atom, 0 (cid:2) k (cid:2) l, and βi (1 (cid:2) i (cid:2) k), γ j (1 (cid:2) j (cid:2) l) are atoms. Given a rule r of form (1), we call αthe head of r, denoted by Head(r), and {β1, . . . , βk, not γ1, . . . , not γl} the body of r, denoted by Body(r). In particular, we call{β1, . . . , βk} the positive body of r, denoted by Pos(r), and {γ1, . . . , γl} the negative body of r, denoted by Neg(r). We call avariable in a rule a body variable if it occurs in the body but not the head of the rule.Given a program Π , a predicate is called intensional if it occurs in the head of some rule in Π , and extensional otherwise.The signature of Π contains all intensional predicates, extensional predicates and constants occurring in Π .For convenience and without loss of generality, in the following we assume that programs are normalized in the sensethat for each intensional predicate P , there is a tuple (cid:7)x of distinct variables matching the arity of P such that for each rule,if its head mentions P , then the head must be P ((cid:7)x). So all the rules with P occurring in the heads in a program can beenumerated as:P ((cid:7)x) ← Body1, . . . , P ((cid:7)x) ← Bodyk.2.1. Clark’s completionOur following definition of Clark’s completion is standard except that we do not make completions for extensionalpredicates.Given a program Π , and a predicate P in it, Clark’s Completion of P in Π is the following first-order sentence [4]:∃(cid:7)yi(cid:2)Bodyi,(2)(cid:2)∀(cid:7)xP ((cid:7)x) ↔where(cid:3)1(cid:2)i(cid:2)k(cid:4)• P ((cid:7)x) ← Body1, . . . , P ((cid:7)x) ← Bodyk are all the rules whose heads mention the predicate P ;• (cid:7)yi is the tuple of body variables in P ((cid:7)x) ← Bodyi ;• (cid:2)Bodyi is the conjunction of elements in Bodyi by simultaneously replacing the occurrences of not by ¬.Clark’s Completion (completion for short if clear from the context) of Π , denoted by Comp(Π), is then the set of Clark’scompletions of all intensional predicates in Π .Example 1 (Transitive Closure (TC)). The following normal logic program TC computes the transitive closure of a given graph:V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–243S(x, y) ← E(x, y)S(x, y) ← E(x, z), S(z, y),where E is the only extensional predicate of TC, representing the edges of a graph, and S is the only intensional predicateof TC. Ideally, the intensional predicate computes the transitive closure (i.e. all the paths) of a given graph. The Clark’sCompletion of TC is the following first-order sentence:(cid:6)(cid:6)(cid:5)(cid:5)∀xyS(x, y) ↔E(x, y) ∨ ∃zE(x, z) ∧ S(z, y).2.2. The stable model semantics for propositional programsIn the propositional case, the stable model semantics for normal propositional programs was proposed by Gelfond andLifschitz [12], and later extended to become answer set semantics for propositional programs that can have classical nega-tion, constraints, disjunctions, and other operators [6,11,13,17,21,22]. Several equivalent characterizations are proposed,including the Gelfond–Lifschitz transformation [12], the logic of GK [20], loop formulas [19], equilibrium logic [26], gen-eral reduction [11], and so on. Here, we briefly review the standard Gelfond–Lifschitz transformation semantics [12] and theloop formula characterization in the propositional case [19], as they are needed in the proof of our main theorem.Let Π be a propositional program and A a set of atoms. We say that A satisfies a rule r in Π if Head(r) ∈ A wheneverPos(r) ⊆ A and Neg(r) ∩ A = ∅. Then, A satisfies Π if it satisfies all rules in Π . The reduct of Π relative to A, denotedby Π A, is the program obtained from Π by (i) deleting every rule r in Π whose negative body is not satisfied by A (i.e.not disjoint with A), and (ii) deleting all negative atoms in other rules. Then, A is said to be a stable model (or an answerset) of Π iff A satisfies Π and there does not exist A(cid:16) ⊂ A such that A(cid:16)satisfies Π A.An equivalent characterization of the stable model semantics is the loop formula approach [19]. Let Π be a program. The(positive) dependency graph of Π , denoted by GΠ , is the finite graph (V , E), where V is the set of atoms occurring in Π ,and (x, y) is an edge in E iff there exists a rule r ∈ Π whose head is x and its positive body contains y. A set of atoms L issaid to be a loop if there exists a cycle in GΠ that goes through only and all the nodes in L. Let x be a propositional atom.If there exists a rule r ∈ Π such that its head is x, then we say that the body of r is a support of x in Π . Let L be a loop,and x an atom in L. We say that a support Body of x in Π is an external support with respect to L if the positive part ofBody contains no atoms from L. Given a loop L, we use ES(L, Π) to denote the set of all external supports of some elementin L with respect to L in Π . Then, the loop formula of L in Π , denoted by LF(L, Π), is the following formula(cid:3)x →(cid:3)(cid:2)Body.x∈LBody∈ES(L,Π )Lin and Zhao [19] showed that, in the propositional case, a set of atoms is an answer set (stable model) of a finite programif and only if it is a model of the Clark’s completion together with all loop formulas of the program.2.3. The stable model semantics for first-order programsIn Gelfond and Lifschitz’s seminal work [12], the stable model/answer set semantics for first-order logic programs (i.e.programs with variables) is defined via grounding on Herbrand structures. Recently, there has been interest in definingthe stable model semantics for first-order programs directly on a first-order level [2,3,10,20,25,27]. Such semantics usuallyconsider arbitrary structures instead of Herbrand structures. Nevertheless, for normal logic programs, all of them coincidewith Gelfond and Lifschitz’s original semantics [12] when only considering Herbrand structures [3,10,16,20,27].We briefly review the translational semantics [10] by defining the stable model semantics of logic programs in second-order logic. Under our context, we only consider normal first-order logic programs.Given a normal logic program Π , let ΩΠ = {Q 1, . . . , Q n} be the set of all intentional predicates of Π . Let Ω ∗Π∗1 , . . . , Q} be a new set of predicates corresponding to ΩΠ , where each Q=Π has the same arity of predicatein Ω ∗∗n∗i{QQ i in ΩΠ . Given a rule r in Π of the formα ← β1, . . . , βm, not γ1, . . . , not γl,by (cid:7)r, we denote the universal closure of the following formulaβ1 ∧ · · · ∧ βm ∧ ¬γ1 ∧ · · · ∧ ¬γl → α;∗by r, we denote the universal closure of the following formula∗∧ · · · ∧ βm∗β1where α∗ = Q∗((cid:7)x) if α = Q ((cid:7)x) and∧ ¬γ1 ∧ · · · ∧ ¬γl → α∗,4V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24(cid:8)β∗i , (1 (cid:2) i (cid:2) m) =∗j ((cid:7)t j)Qβiif βi = Q j((cid:7)t j) and Q j ∈ ΩΠ ,otherwise.By (cid:7)Π , we denote the first-order sentencelogic program. By SM(Π), we denote the following second-order sentence:ˆr; by Π ∗r∈Π, we denote the first-order sentence(cid:9)(cid:9)r∈Π r∗. Let Π be a normal(cid:7)Π ∧ ¬∃Ω∗Π(cid:5)(cid:5)Ω∗Π < ΩΠ(cid:6)(cid:6)∗,∧ Πwhere Ω ∗Π < ΩΠ is the abbreviation of the formula(cid:10)(cid:10)(cid:5)∀(cid:7)xQ(cid:6)∗i ((cid:7)x) → Q i((cid:7)x)∧ ¬(cid:5)∀(cid:7)xQ i((cid:7)x) → Q(cid:6)∗i ((cid:7)x).1(cid:2)i(cid:2)n1(cid:2)i(cid:2)nThis second-order sentence is used to capture the stable models of Π . We call this the translational semantics.Here, for our purposes, we present an alternative characterization of this semantics by grounding. Similar to Gelfond andLifschitz’s grounding approach, we define the stable model semantics by grounding into the propositional case. However,we consider grounding on arbitrary structures instead of Herbrand structures. It is worth mentioning that, on arbitrarystructures, the unique name assumption (i.e. distinct constants must be interpreted differently) does not necessarily hold.Consequently, we will not assume it in our grounding procedure.Definition 1. The grounding of a program Π on a structure M, written ΠM below, is the union of the following three sets:1. The set of all instances of the rules in Π under M, here an instance of a rule under M is the result of simultaneouslyreplacing every constant in the rule by its interpretation in M, and every variable x in the rule by a domain object din M;2. EQM = {u = u | u is a domain object in M}1;3. ExtM = {P ((cid:7)u) | P is an extensional predicate and (cid:7)u ∈ PM}, here PMis the interpretation of P in M.We now have the following definition:Definition 2. Let Π be a normal logic program and M a structure. We say that M is a stable model (or an answer set) of Πif the following setEQM ∪ ExtM ∪ IntMis an answer set of ΠM in the propositional case, where IntM is the following set(cid:11)(cid:12)(cid:12) P is an intensional predicate, and (cid:7)u ∈ PM(cid:13).P ((cid:7)u)Example 2. Consider the following program Π0P (x) ← not Q (x),P (a1),Q (a2).According to Gelfond and Lifschitz’s original stable model semantics [12], the unique stable model/answer set of Π0 isX = {P (a1), Q (a2)}.Now, let us reconsider the program Π0 under the new semantics (i.e. Definition 2). Notice that both P and Q areintensional predicates. According to Definition 2, the following structure M0, whereM0 = {d1, d2},M0 = d1,a1M0 = d2,a2M0 = {d1},PM0 = {d2}Qis a stable model of Π0. In fact, this structure M0 corresponds to the unique stable model X of Π0 under the originalsemantics. Notice that, similar to classical first-order logic, we distinguish from a1 and d1 here (also a2 and d2) because theformer is a constant in the language while the latter is a domain element.However, under the new semantics, M0 is not the only stable model of Π0. The following structure M1, whereM1 = {d1},M1 = d1,a1M1 = d1,a2M1 = QPM1 = {d1}1 Note that here u = u is a propositional atom but not an equality atom.V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–245is also a stable model of Π0. Here, both a1 and a2 are mapped to the same domain element d1. This is allowed as theunique name assumption (i.e. distinct constants must be interpreted to different domain elements) is not assumed in thenew semantics.Also, the new semantics may allow new objects in the stable models. For instance, the following structure M2, whereM2 = {d1, d2, d3},a2is a stable model of Π0 as well. Notice that d3 ∈ PM2 = d1,M2 = d2,M2 although d3 is not mapped from any constants in the program.M2 = {d1, d3},M2 = {d2}a1QPIn fact, this definition of stable model (answer set) is nothing new. The grounding technique in Definition 1 is basicallythe same as the standard one in [12] except that here it is done on an arbitrary structure instead of the Herbrand structure.The only reason we propose this alternative definition is that it is more suitable for understanding the proof of our maintheorem (see Theorem 2). Also, the following theorem shows that this semantics by grounding on arbitrary structuresactually coincides with the translational semantics mentioned previously in this section.Theorem 1. Let Π be a normal logic program whose signature is σ , and A a finite σ -structure. Then, A is a stable model of Π (underDefinition 2) iff A is a model of SM(Π).Proof. For convenience, we use Gr(A) to denote EQ A ∪ ExtA ∪ IntA. First, Gr(A) satisfies ΠA iff Gr(A) satisfies all instancesof the rules in Π under A iff Gr(A) satisfies every rη, where r ∈ Π and η is an assignment iff A satisfies (cid:7)r for all r ∈ Π iffA |(cid:20) (cid:7)Π .Second, we show that A |(cid:20) ¬∃Ω ∗Π ((Ω ∗We have A |(cid:20) ∃Ω ∗constants and extensional predicates the same as A, butΠ < ΩΠ ) ∧ Π ∗) iff there exists a structure A(cid:16)Π ((Ω ∗Π < ΩΠ ) ∧ Π ∗) iff there does not exist X ⊂ Gr(A) such that X satisfies ΠAGr(A).has the same domain as A, interprets allsuch that A(cid:16)A(cid:16) ⊆ Q• for all intensional predicates Q of Π , Q, and for some intensional predicates Q , Q• for every assignment η and every rule r of form (1) in Π , if for all i (1 (cid:2) i (cid:2) k), βiη ∈ A(cid:16)AAA(cid:16) ⊂ Qand for all;γ jη /∈ A, then αη ∈ A(cid:16)j (1 (cid:2) j (cid:2) l),iff there exists X ⊂ Gr( A) satisfying (rη)Gr(A) for every pair r, η, where r ∈ Π and η is an assignment (let X = EQ A ∪ ExtA ∪IntA(cid:16) ) iff there exists X ⊂ Gr( A) satisfying ΠAGr(A).This shows that the original assertion holds. (cid:2)As a consequence of the above theorem and Theorem 1 in [10], Definition 2 basically coincides with Gelfond and Lifs-chitz’s original semantics on Herbrand structures. The main difference is that we consider not only Herbrand structures butalso arbitrary ones. For the latter, we do not need the unique name assumption (see Example 2).Notice that the above definitions can be applied to infinite structures as well since the stable model (answer set) se-mantics for infinite propositional programs is well defined by using Gelfond–Lifschitz transformation [12]. However, in thispaper, we are mainly concerned with finite structures unless stated otherwise (particularly in Section 3.5).3. The ordered completionIt is well known that Clark’s completion does not fully capture the answer set semantics because of positive cycles. As asimple example, the following programp ← qq ← phas one answer set ∅, but its Clark’s completion p ↔ q has two models {p, q} and ∅. Here, we propose a modification ofClark’s completion to address this issue. The main technical property of our new translation is that for each finite first-order logic program, our translation yields a finite first-order theory that captures exactly the finite stable models of theprogram. The ideas behind such translation can be best illustrated by simple propositional programs. Consider the programmentioned above. We introduce four auxiliary symbols T pq, T pp, Tqq, Tqp (read, e.g. T pq as from p to q), and translate thisprogram into the following theory(p → q) ∧ (q → p),p → (q ∧ T qp ∧ ¬T pq),q → (p ∧ T pq ∧ ¬T qp),T pq ∧ T qp → T pp,T qp ∧ T pq → T qq.6V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24The first sentence is the direct encoding of the two rules. The second one is similar to the other side of Clark’s completionfor p except that we add T qp and ¬T pq: for p to be true, q must be true and it must be the case that q is used to derive pbut not the other way around. The third sentence is similar, and the last two sentences are about the transitivity of the Tatoms. It can be checked that in all models of the above sentences, both p and q must be false.3.1. Definition of the ordered completionIn general, let Π be a first-order normal logic program, and ΩΠ its set of intensional predicates. For each pair ofpredicates (P , Q ) ( P and Q might be the same) in ΩΠ , we introduce a new predicate (cid:2)PQ , called the comparison predicate,whose arity is the sum of the arities of P and Q . The intuitive meaning of (cid:2)PQ ((cid:7)x, (cid:7)y), read as from P ((cid:7)x) to Q ((cid:7)y), is thatP ((cid:7)x) is used for deriving Q ((cid:7)y). In the following, we use infix notation for (cid:2)PQ and write (cid:2)PQ ((cid:7)x, (cid:7)y) as (cid:7)x (cid:2)PQ (cid:7)y.Definition 3 (Ordered completion). Let Π be a normal logic program. The ordered completion of Π , denoted by OC(Π), is theset of following sentences:• For each intensional predicate P , the following sentences:(cid:2) (cid:3)∀(cid:7)x(cid:4)∃(cid:7)yi(cid:2)Bodyi→ P ((cid:7)x),(3)1(cid:2)i(cid:2)k(cid:2)∀(cid:7)xP ((cid:7)x) →(cid:2)∃(cid:7)yi(cid:2)Bodyi∧(cid:3)1(cid:2)i(cid:2)k(cid:10)(cid:4)(cid:4)(cid:7)z (cid:2)QP (cid:7)x ∧ ¬(cid:7)x (cid:2)PQ (cid:7)z,Q ((cid:7)z)∈Posi ,Q ∈ΩΠwhere we have borrowed the notations used in the definition of Clark’s completion, and further assume that Posi is thepositive part of Bodyi and Q ((cid:7)z) ranges over all the intensional atoms in the positive part of Bodyi ;• For each triple of intensional predicates P , Q , and R (two or all of them might be the same) the following sentence:(cid:10)P ,Q ,R∈ΩΠ∀(cid:7)x(cid:7)y(cid:7)z((cid:7)x (cid:2)PQ (cid:7)y ∧ (cid:7)y (cid:2)Q R (cid:7)z → (cid:7)x (cid:2)P R (cid:7)z).(4)In the following, we use MComp(Π) to denote the set of the formulas (3) and (4), and TranS(Π) the set of formulas (4).So OC(Π) = MComp(Π) ∪ TranS(Π).Clearly, for finite programs, OC(Π) is finite, and the predicates occurring in OC(Π) are all the predicates occurring in Πtogether with all the comparison predicates {(cid:2)PQ | P , Q ∈ ΩΠ }.Notice that the Clark’s completion of a predicate can be rewritten as two parts:(cid:2) (cid:3)∀(cid:7)x(cid:4)∃(cid:7)yi(cid:2)Bodyi→ P ((cid:7)x),1(cid:2)i(cid:2)k(cid:2)∀(cid:7)xP ((cid:7)x) →(cid:4)∃(cid:7)yi(cid:2)Bodyi.(cid:3)1(cid:2)i(cid:2)kThus, the only difference between MComp(Π) and Comp(Π) is that the former introduces some assertions on the compar-ison predicates, which intuitively mean that there exist derivation paths from the intensional atoms in the body to headbut not the other way around (see Eq. (4)). In addition, TranS(Π) simply means that the comparison predicates satisfy“transitivity”.Proposition 1. Let Π be a normal logic program. Then, OC(Π) introduces m2 new predicates whose arities are no more than 2s, andthe size of OC(Π) is O (s × m3 + s × n), where m is the number of intensional predicates of Π , s the maximal arity of the intensionalpredicates of Π and n the length of Π .Example 3 (Transitive Closure continued). Recall the Transitive Closure program TC presented in Example 1. In this case, sincethe only intensional predicate is S, we only need to introduce one additional predicate (cid:2)S S , whose arity is 4. The orderedcompletion of TC consists of the following sentences:(cid:5)(cid:5)(cid:5)(cid:5)E(x, y) ∨ ∃z(cid:5)S(x, y) →∀xy∀xy∀xyuv zw(−→xy (cid:2)S SE(x, z) ∧ S(z, y)(cid:5)(cid:6)(cid:6)(cid:6)→ S(x, y),E(x, z) ∧ S(z, y) ∧ −→zy (cid:2)S S−−→zw).zw → −→−−→xy (cid:2)S SE(x, y) ∨ ∃zuv ∧ −→−→uv (cid:2)S Sxy ∧ ¬−→−→xy (cid:2)S S(cid:6)(cid:6)(cid:6)−→zy,(5)(6)(7)V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–247Fig. 1. An example graph.−→uv to mean that S(x, y) is used to establish S(u, v). So the sentence (6) means thatIntuitively, one can understandfor S(x, y) to be true, either E(x, y) (the base case), or inductively, for some z, E(x, z) is true and S(z, y) is used to establishS(x, y) but not the other way around.−→xy (cid:2)S STo see how these axioms work, consider the graph in Fig. 1 with four vertices a, b, c, d, with E representing the edgerelation: E(a, b), E(b, a), E(c, a), E(c, d). Clearly, if there is a path from x to y, then S(x, y) (by sentence (5)). We want toshow that if there is no path from x to y, then ¬S(x, y). Consider S(d, a). If it is true, then since ¬E(d, a), there must bean x such thatE(d, x) ∧ S(x, a) ∧ −→−→da (cid:2)S SThis is false as there is no edge going out of d.−→da ∧ ¬xa (cid:2)S S−→xa.Now consider S(a, c). If it is true, then there must be an z such thatac ∧ ¬−→−→E(a, z) ∧ S(z, c) ∧ −→−→zc.ac (cid:2)S Szc (cid:2)S SSo z must be b, andS(b, c) ∧−→bc (cid:2)S Sac ∧ ¬−→−→ac (cid:2)S S−→bc.(8)Since S(b, c) is true and there is no edge from b to c, there must be a y such that−→bc (cid:2)S SE(b, y) ∧ S( y, c) ∧ −→−→bc ∧ ¬yc (cid:2)S S−→yc.So y must be a, andS(a, c) ∧ −→ac (cid:2)S S−→bc ∧ ¬−→bc (cid:2)S S−→ac.However, this contradicts with (8).Notice that the Clark’s completion of TC, i.e. ∀xy(S(x, y) ↔ (E(x, y) ∨ ∃zE(x, z) ∧ S(z, y))) (see Example 1), does notassure that S is the transitive closure of the edge relation. For instance, for the above, the following interpretation on SS(a, b), S(b, a), S(a, c), S(c, a), S(b, c), S(c, b), S(a, d), S(b, d), S(c, d)satisfies the Clark’s completion of TC. However, there is no path from, e.g. a to c, in the graph shown in Fig. 1.3.2. The main theoremIn order to introduce the main theorem, we first consider a notion called derivation order, which is a reformulation ofFages’ “well-supportedness” under our context [7]. Roughly speaking, a derivation order is a sequence of ground atoms, inwhich the anterior ones are used to derive the posterior ones.Formally, a derivation order of a finite structure A on a program Π is a sequence of ground atoms P 1((cid:7)a1), . . . , P k((cid:7)ak)such that {P 1((cid:7)a1), . . . , P k((cid:7)ak)} = IntA (see Definition 2), and for all i (1 (cid:2) i (cid:2) k), there exists a rule r ∈ Π and an assignmentη such that• Head(r)η = P i((cid:7)ai),• for all intensional atoms Q ((cid:7)t) in Pos(r), Q ((cid:7)t)η ∈ {P 1((cid:7)a1), . . . , P i−1(• for all intensional atoms Q ((cid:7)t) in Neg(r), Q ((cid:7)t)η /∈ IntA,• for all extensional atoms Q ((cid:7)t) in Pos(r) (Neg(r) resp.), Q ((cid:7)t)η ∈ ExtA ( Q ((cid:7)t)η /∈ ExtA resp.).−−−→ai−1)},Example 4. Consider the following program Π1p1 ← p2,p2 ← p1,p1 ← not p3.8V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24Clearly, X = {p1, p2} is an answer set of Π1. According to the definition, p1, p2 is a derivation order of X on Π1 but p2, p1is not. This is because p1 is used to derive p2 but not the other way around.We show that derivation orders and answer sets are corresponded.Lemma 2. Let Π be a normal logic program whose signature is σ , and A a finite σ -structure. Then, A is an answer set of Π iff(i) A |(cid:20) (cid:7)Π ;(ii) there exists a (possibly many) derivation order of A on Π .Proof. According to the grounding definition (see Definition 1), it suffices to prove this assertion in the propositional case.On one hand, consider a finite propositional program Π and a set A of atoms. If A is an answer set of Π , then Asatisfies Π according to the Gelfond–Lifschitz transformation semantics. In addition, we construct a sequence of atoms{p1, p2, . . . , pk} ⊆ A as follows:• for any i (1 (cid:2) i (cid:2) k), there exists a rule r in Π such that Head(r) = pi , Pos(r) ⊆ {p1, . . . , pi−1} and Neg(r) ∩ A = ∅,• there does not exist r in Π such that Pos(r) ⊆ {p1, . . . , pk}, Neg(r) ∩ A = ∅ and Head(r) /∈ {p1, . . . , pk}.Then, {p1, p2, . . . , pk} = A. Otherwise, {p1, p2, . . . , pk} |(cid:20) Π Apk} is a derivation order of A on Π .but {p1, p2, . . . , pk} ⊂ A, a contradiction. Hence, {p1, p2, . . . ,On the other hand, suppose that A |(cid:20) (cid:7)Π and there exists a derivation order of A on Π . To prove that A is an answer set. Otherwise, let p be the atom in A\A(cid:16)of Π , it suffices to show that there does not exist A(cid:16) ⊂ A such that A(cid:16)with the least ordinal in the derivation order. Then, according to the definition, there exists a rule r such that Head(r) = p,Pos(r) ⊆ A(cid:16)(since p has the least ordinal in the derivation order) and Neg(r) ∩ A = ∅. Therefore, Neg(r) ∩ A(cid:16) = ∅. It followsthat A(cid:16) |(cid:20) Pos(r) but A(cid:16) (cid:3)|(cid:20) Head(r). Hence, A(cid:16), a contradiction. (cid:2)satisfies Π Adoes not satisfy rANow we are able to present the following main theorem.Theorem 2. Let Π be a normal logic program whose signature is σ , and A a finite σ -structure. Then, A is an answer set of Π if andonly if there exists a model M of OC(Π) such that A is the reduct of M on σ .Proof. On one hand, we show that every finite answer set A of Π can be expanded to a model of OC(Π). By Lemma 2,there exists a derivation order of A on Π . Then, based on it, we construct a finite structure M by expanding A with thefollowing interpretations on (cid:2)PQ for each pair (P , Q ) of intensional predicates in Π :(cid:7)b iff there exists a path from Q ((cid:7)b) to P ((cid:7)a) in the dependency graph of the ground program ΠA and the position(cid:7)a (cid:2)PQof P ((cid:7)a) is before the position of Q ((cid:7)b) in the derivation order,where (cid:7)a and (cid:7)b are two tuples of elements in the domain of A that match the arities of P and Q respectively. In this case,we say that there is a derivation path from P ((cid:7)a) to Q ((cid:7)b) (with respect to the derivation order).We need to prove that M is a model of both TranS(Π) and MComp(Π). Firstly, it is easy to see that M is a model ofTranS(Π) by contradiction. Secondly, we show that M is a model of MComp(Π) as well. Clearly, M is a model of the firstpart of MComp(Π), i.e. Eq. (3) since M is expanded from A, a model of the Clark’s completion of Π . For the second partof MComp(Π), i.e. Eq. (4), we prove it by contradiction. Suppose that M is not a model of Eq. (4). Then,M |(cid:20)(cid:3)P ∈ΩΠ(cid:2)∃(cid:7)xP ((cid:7)x) ∧(cid:10)1(cid:2)i(cid:2)k(cid:2)∀(cid:7)yi(cid:2)Bodyi→(cid:3)Q ((cid:7)z)∈Posi ∩ΩΠ(cid:4)(cid:4)¬(cid:7)z (cid:2)QP (cid:7)x ∨ (cid:7)x (cid:2)PQ (cid:7)z.Therefore, there exists P ((cid:7)a) ∈ M such that for all assignments η and all rules r whose head mentions P , if M |(cid:20) (cid:3)then there exists an intensional atom Q ((cid:7)z) in the positive body of r such that M |(cid:20) ¬(cid:7)z (cid:2)QP (cid:7)xη or M |(cid:20) (cid:7)x (cid:2)PQ (cid:7)zη.Now, consider the position of P ((cid:7)a) in the derivation order. There exists a rule r and an assignment η satisfying theconditions mentioned above. Hence, according to the conditions, for all intensional atom Q ((cid:7)t) in the positive body of r,we have that the ordinal of Q ((cid:7)t)η in the derivation order is less than the ordinal of P ((cid:7)a) in the derivation order. Hence,M |(cid:20) (cid:7)t (cid:2)QP (cid:7)xη and M (cid:3)|(cid:20) (cid:7)x (cid:2)PQ(cid:7)tη, a contradiction.This shows that M, expanded from A, is a model of OC(Π).On the other hand, we prove that the reduct of any finite model M of OC(Π) on σ must be an answer set of Π . Clearly,M ↑ σ is a model of Comp(Π) since MComp(Π) |(cid:20) Comp(Π). Hence, according to the loop formula characterization ofanswer set semantics in the propositional case [19], it suffices to show that for all loops L of the ground program ΠM↑σ ,the set of ground atoms EQM↑σ ∪ ExtM↑σ ∪ IntM↑σ is a model of its loop formula.Body(r)η,V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–249We prove this by contradiction. Suppose that there exists a loop L of the ground program ΠM↑σ such that the aboveset of ground atoms is not a model of LF(L, ΠM↑σ ). Then, there exists a ground atom P 0((cid:7)a0) ∈ L and P 0((cid:7)a0) ∈ IntM↑σ , andfor every Q ((cid:7)b) ∈ L, Q ((cid:7)b) has no external support with respect to L in the ground program ΠM↑σ .Since M is a model of MComp(Π), there exists a support Body0 of P 0((cid:7)a0) in the ground program ΠM↑σ such that forall ground atoms Q ((cid:7)b) in the positive body of Body0, (cid:7)b (cid:2)Q P 0(cid:7)b holds, where Q is an intensional predicateof Π and (cid:7)b a tuple of elements in M that matches the arity of Q . If every Q ((cid:7)b) is not in L, then Body0 is an externalsupport of P 0((cid:7)a0) with respect to L, a contradiction. Hence, there exists P 1((cid:7)a1) in the positive body of Body0 such thatP 1((cid:7)a1) ∈ IntM↑σ , P 1((cid:7)a1) ∈ L and (cid:7)a1 (cid:2)P 1 P 0(cid:7)a1 holds.Again, following the same procedure described above, there exists a support Body1 of P 1((cid:7)a1), and a ground atom P 2((cid:7)a2)in the positive body of Body1 such that P 2((cid:7)a2) ∈ IntM↑σ , P 2((cid:7)a2) ∈ L and (cid:7)a2 (cid:2)P 2 P 1(cid:7)a2 holds. Hence, we canget a sequence of ground atoms P 0((cid:7)a0), P 1((cid:7)a1), . . . , P i((cid:7)ai), . . . such that for all i, P i((cid:7)ai) ∈ IntM↑σ , P i((cid:7)ai) ∈ L. In addition,both(cid:7)a1 ∧ ¬(cid:7)a1 (cid:2)P 1 P 2(cid:7)a0 ∧ ¬(cid:7)a0 (cid:2)P 0 P 1(cid:7)a0 ∧ ¬(cid:7)a0 (cid:2)P 0 QNext, we show that this sequence cannot be infinite due to the finiteness of the structure M and the fact that thenew comparison predicates satisfy transitivity. Since M is finite, there exists k < l such that P k((cid:7)ak) = Pl((cid:7)al) in the above se-−−−→(cid:7)ai holds, we have that (cid:7)al (cid:2)Pl Pk+1quence. However, since for all i,ak+1 holds as well according to the transitivityak+1 holds since P k((cid:7)ak) = Pl((cid:7)al). This contradicts to the fact that ¬−−−→−−−→axioms. Hence, (cid:7)ak (cid:2)Pk Pk+1ak+1 (cid:2)Pk+1 Pk−−−→ai+1 (cid:2)P i+1 P i(cid:7)ak holds.(cid:7)ai and ¬(cid:7)ai (cid:2)P i P i+1−−−→ai+1 (cid:2)P i+1 P i−−−→ai+1 hold.This shows that M ↑ σ is an answer set of Π . (cid:2)From the proof of the main theorem, we see that the basic idea of the ordered completion is really that each atom inan answer set of a finite program must be justified step-by-step. In this sense, a finite structure A is an answer set of aprogram Π iff it is a model of Π and satisfies the following conditions:downgrading every ground atom P ((cid:7)a) in A has some supports from earlier stages. The “support” part is ensured by Clark’scompletion, and the “earlier stages” part is ensured by adding some assertions on the comparison predicates (seeEq. (4));loop-free the above downgrading procedure does not contain a loop. This is ensured by TranS(Π), which states that thecomparison predicates satisfy transitivity;well-foundedness the downgrading procedure will end at some step. This is ensured by finiteness, i.e., only finite structuresare taken into account.Together with the above three conditions, each ground atom P ((cid:7)a) in a finite answer set A can be justified step-by-step, inwhich the track of justifying this atom is captured by the comparison predicates.3.3. Normal logic program with constraintsRecall that we have required the head of a rule to be a proper atom. If we allow the head to be empty, then we haveso-called constraints:← β1, . . . , βk, not γ1, . . . , not γl,(9)where βi (1 (cid:2) i (cid:2) k) and γ j (1 (cid:2) j (cid:2) l) are atoms. A model is said to satisfy the above constraint if it satisfies the corre-sponding sentence:∀(cid:7)y¬(β1 ∧ · · · ∧ βk ∧ ¬γ1 ∧ · · · ∧ ¬γl),where (cid:7)y is the tuple of all variables occurring in (9). In the following, if c is a constraint of form (9), then we use ˆc todenote its corresponding formula above.A normal logic program with constraints is then a finite set of rules and constraints. The stable model (answer set) se-mantics can be extended to normal logic programs with constraints: a model is an answer set of a program with constraintsif it is an answer set of the set of the program and satisfies all the constraints.Both Clark’s completion and our ordered completion can be extended to normal logic programs with constraints: onesimply adds the sentences corresponding to the constraints to the respective completions.Proposition 3. Let Π be a normal logic program whose signature is σ , C a set of constraints, and A a finite σ -structure. Then, A isan answer set of Π ∪ C iff there exists a model M of OC(Π) ∪ {ˆc | c ∈ C}, such that A is the reduct of M on σ .Proof. A is an answer set of Π ∪ C iff A is an answer set of Π and A is a model of {ˆc | c ∈ C} iff there exists M, which is amodel of both OC(Π) and {ˆc | c ∈ C} and whose reduct on σ is A iff there exists M, which is a model of OC(Π) ∪ {ˆc | c ∈ C}such that A is the reduct of M on σ . (cid:2)10V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24Example 5. The following program checks whether all the nodes of a given graph can be reached from a given initial node.R(a)R(x) ← R( y), E( y, x)← not R(x),where E is the only extensional predicate representing the edges of the graph; a is a constant representing the initial node;and R is the only intensional predicate representing whether a node can be reached from a. The program has a stablemodel iff all the nodes in the graph can be reached from a. According to Proposition 3, this program can be captured bythe following sentence:R(a) ∧ ∀xy(cid:5)(cid:6)E( y, x) ∧ R( y) → R(x)(cid:5)R(x) → x = a ∨ ∃ y(cid:5)∧ ∀x∧ ∀xyz(x (cid:2)R R y ∧ y (cid:2)R R z → x (cid:2)R R z)∧ ∀xR(x).R( y) ∧ E( y, x) ∧ y (cid:2)R R x ∧ ¬x (cid:2)R R y(cid:6)(cid:6)3.4. Adding choice rulesAnother widely used extension of normal logic program is to allow choice rules of the following form:(cid:11)(cid:13)P ((cid:7)x),(10)where P is a predicate and (cid:7)x is the tuple of variables associated with P . Intuitively, this choice rule of P means that theintensional predicate P can be interpreted arbitrarily in the stable models.The stable model (answer set) semantics of normal logic programs with choice rules (possibly with constraints as well)can be defined similarly by grounding. More precisely, the set of ground rules of a choice rule of form (10) on a structureM contains all rules of the form:(cid:11)(cid:13)P ((cid:7)u),where (cid:7)u is a tuple of domain elements in M that matches the arity of P . The set of ground constraints of a constraint ofform (9) on a structure M contains all the instances of the constraint under M.The answer set semantics for propositional programs with choice rules and constraints can be defined by Gelfond–Lifschitz transformation as well [22]. Let p be a propositional atom and A a set of atoms. The reduct of the choice rule {p}relative to A is p itself if p ∈ A, and empty (i.e. (cid:21)) otherwise. Again, a set A of propositional atoms is said to be an answerset of a propositional program Π with choice rules and constraints if A |(cid:20) Π 2 and A is the minimal model of Π AThen, a structure A is said to be a stable model of a first-order normal program Π with choice rules and constraints if.EQ A ∪ ExtA ∪ IntA is an answer set of the ground program ΠA in the propositional case.The following proposition shows that programs with choice rules can also be captured by their ordered completions.Proposition 4. Let Π be a normal logic program whose signature is σ , Ω ⊆ σ a set of predicates in σ , C a set of constraints, Choice(Ω)the set of choice rules for every predicate in Ω , and A a finite σ -structure. Then, A is an answer set of Π ∪ C ∪ Choice(Ω) iff thereexists a model M of the following set of sentences such that A is the reduct of M on σ :• For each intensional predicate P , the following sentence:(cid:2) (cid:3)∀(cid:7)x1(cid:2)i(cid:2)k(cid:4)∃(cid:7)yi(cid:2)Bodyi→ P ((cid:7)x).• For each intensional predicate P not in Ω , the following sentence:(cid:2)(cid:2)(cid:3)∀(cid:7)xP ((cid:7)x) →∃(cid:7)yi(cid:2)Bodyi∧(cid:10)(cid:4)(cid:4)((cid:7)z (cid:2)QP (cid:7)x ∧ ¬(cid:7)x (cid:2)PQ (cid:7)z).1(cid:2)i(cid:2)kQ ((cid:7)z)∈Posi ,Q ∈ΩΠ \Ω• For each triple of intensional predicates P , Q , and R not in Ω , the following sentence:(cid:10)∀(cid:7)x(cid:7)y(cid:7)z((cid:7)x (cid:2)PQ (cid:7)y ∧ (cid:7)y (cid:2)Q R (cid:7)z → (cid:7)x (cid:2)P R (cid:7)z).P ,Q ,R∈ΩΠ \Ω• Finally, for each c ∈ C , the sentence ˆc.2 Firstly, this means that A satisfies all constraints. Secondly, A is regarded as a model of every choice rule.V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–2411Proof. This assertion follows directly from Proposition 3 and the following fact: the answer sets of Π ∪ C ∪ Choice(Ω) areexactly the same as the answer sets of Π ∗ ∪ C , where Π ∗is the program obtained from Π by rewriting each rule ofform (1), whose head mentions predicates from Ω , to the following constraint← β1, . . . , βk, not γ1, . . . , not γl, not α.(cid:2)Example 6. Consider the following normal program with constraints and choice rules for computing all Hamiltonian circuitsof a graph:(cid:11)(cid:13)hc(x, y)← hc(x, y), not E(x, y)← hc(x, y), hc(x, z), y (cid:3)= z← hc( y, x), hc(z, x), y (cid:3)= zR(x) ← hc(a, x)R(x) ← R( y), hc( y, x)← not R(x),where E is the only extensional predicate representing the edges of the graph; a is a constant representing a particularnode in the Hamiltonian circuit; hc(x, y) is an intensional predicate representing the Hamiltonian circuit; and R(x) is anintensional predicate to check that all vertices are in the Hamiltonian circuit. In particular, the first rule of the program is achoice rule to guess a possible Hamiltonian circuit.According to Proposition 4, this program can be captured by the following sentence:(cid:5)(cid:6)hc( y, x) ∧ R( y) → R(x)R( y) ∧ hc( y, x) ∧ y (cid:2)R R x ∧ ¬x (cid:2)R R y(cid:6)(cid:6)∧ ∀xy(cid:5)(cid:5)(cid:6)hc(a, x) → R(x)∀x(cid:5)R(x) → hc(a, x) ∨ ∃ y∧ ∀x∧ ∀xyz(x (cid:2)R R y ∧ y (cid:2)R R z → x (cid:2)R R z)(cid:6)(cid:5)∧ ∀xy¬hc(x, y) ∧ ¬E(x, y)(cid:5)hc(x, y) ∧ hc(x, z) ∧ y (cid:3)= z∧ ∀xyz¬(cid:5)∧ ∀xyz¬hc( y, x) ∧ hc(z, x) ∧ y (cid:3)= z∧ ∀xR(x).(cid:6)(cid:6)3.5. Arbitrary structuresIt is worth mentioning that the correspondence between classical first-order models of ordered completions and stablemodels of a logic program holds only on finite structures. In general, the result does not hold if infinite structures areallowed. For instance, the ordered completion of Transitive Closure (TC) in Example 3 on finite structures does not captureTC on some infinite structures.Example 7 (Transitive Closure continued). Consider the graph that contains an infinite chain and an individual vertex. Leta1, a2, . . . be an infinite chain such that E(aiai+1) for all i, and b a node different from all ai . Consider the structure M ofthe signature {E, S, (cid:2)S S } such that• S(ai, a j) for all i < j;• S(ai, b) for all i;• −−→aia j (cid:2)S S−→aib (cid:2)S S•−−→akal for all j − i (cid:2) l − k, where i < j and k < l;−−→a jb for all i < j.It can be checked that M is a model of the ordered completion of TC (see Example 3). However, clearly, S is not thetransitive closure of the graph given in this example.It still remains the question whether or not Transitive Closure can be captured by other first-order theories (even infinite)with auxiliary predicates. Unfortunately, the answer is negative either.Proposition 5. There does not exist a first-order theory whose signature contains the signature of TC, and the reducts of all its modelsare exactly corresponding to the stable models of TC on arbitrary structures.12V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24Proof. We prove this assertion by contradiction. Let σ be the signature of TC. We assume that φ is a first-order theory,whose vocabulary is σ1 such that σ ⊆ σ1, and the reducts of the models of φ on σ are exactly the stable models of TC.It is well known that TC can be defined by a universal second-order theory [5]. Therefore, the complement of TC can bedefined by an existential second-order theory. Hence, there exists a first-order theory whose signature contains σ , and thereducts of all its models on σ are exactly the complement of the class of stable models of TC on arbitrary structures. Let ψbe such as a theory of signature σ2. Without loss of generality, we can assume that σ1 ∩ σ2 = σ . Then, φ |(cid:20) ¬ψ in the first-order language σ1 ∪ σ2. Thus, according to Craig’s Interpolation Theorem, there exists a theory φ0 of the signature σ1 ∩ σ2(namely σ ) such that φ |(cid:20) φ0 and φ0 |(cid:20) ¬ψ . This shows that TC is exactly captured by the theory φ0, whose signature is σ .This contradicts to the well-known result that TC is not first-order definable on arbitrary structures [5]. (cid:2)3.6. Disjunctive logic programsDisjunctive logic programs is a very important extension of normal programs for dealing with incomplete information[6,13]. A disjunctive logic program is a finite set of disjunctive rules of the following formα1; . . . ; αn ← β1, . . . , βk, not γ1, . . . , not γl.(11)Similar to normal programs, we can distinguish intensional and extensional predicates here. The answer set semantics fordisjunctive logic programs can be defined similarly by grounding [6,13].A natural question arises as whether the ordered completion can be extended to first-order disjunctive programs. Un-fortunately, the answer is negative provided some well-recognized assumptions in the computational complexity theoryare true. Actually, our following proposition shows a stronger result that there exist disjunctive programs that cannot becaptured by any first-order sentences with a larger signature.Proposition 6. There exists a disjunctive program Π such that it cannot be captured by any first-order sentence with the same or alarger signature unless NP = coNP. That is, there is no first-order sentence φ whose signature contains the signature of Π , and thereducts of all its finite models are exactly the finite stable models of Π .Proof. We show that the following program 3-UNCOLOR (originated from Example 2 in [6]) cannot be captured by anyfirst-order sentences on finite structures if NP (cid:3)= coNP:R(x); G(x); B(x) ← ,NC ← E(x, y), R(x), R( y),NC ← E(x, y), G(x), G( y),NC ← E(x, y), B(x), B( y),R(x) ← NC,G(x) ← NC,B(x) ← NC,NC ← not NC,where E is the only extensional predicate to represent a graph; R, G and B are three different colors respectively, and NCis a 0-ary predicate to claim that this graph cannot be colored. It is not difficult to check that the program has answer setsiff the graph, represented by E, cannot be colored by the three colors. In addition, in this case, there is a unique answer setthat contains the given graph, NC and the full interpretation for R, G and B.Assuming that NP (cid:3)= coNP, no coNP complete problem is in NP. Hence, the problem of 3-uncolorability (a well-knowncoNP complete problem) is not in NP. By Fagin’s theorem [9], the Boolean query of 3-uncolorability for a given graph cannotbe defined by an existential second-order sentence. On the other hand, assume that there exists a first-order sentence φwhose signature contains the signature of 3-UNCOLOR, and the reducts of all its finite models are exactly correspondingto the finite stable models of 3-UNCOLOR. Then, the Boolean query of 3-uncolorability can be defined by the followingexistential second-order sentence∃Pφ,where P is a set of predicates including NC, R, G, B and all the other predicates in φ but not in 3-UNCOLOR, a contradiction.This shows that 3-UNCOLOR cannot be captured by any first-order sentences with a larger signature. (cid:2)V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–2413Following from the proof of Proposition 6 and Theorem 2, another negative result is that, most likely, first-order disjunc-tive logic programs cannot be reduced to normal programs on finite structures, even with new predicates.Corollary 7. Unless NP (cid:3)= coNP, there is no normal program whose signature contains the signature of 3-UNCOLOR, and the reducts ofall its finite stable models are exactly corresponding to the finite stable models of 3-UNCOLOR.Proof. Otherwise, according to Theorem 2, the program 3-UNCOLOR can be captured by a first-order sentence with a largersignature. (cid:2)In fact, the above two results coincide with the result presented in [6], stating that in terms of brave reasoning, disjunc-2 , while normal programs onlytive logic programs with the stable model semantics exactly capture the complexity class Σ Pcapture NP.4. OptimizationsIn this section, we present several techniques to optimize ordered completion introduced in Section 3. The goal of thesetechniques is for simplifying the translation, including reducing the number of new predicates, the arities of new predicatesand the overall length of the ordered completion. As we will see, the techniques presented below can be combined together.For the sake of clarity, we will introduce them step-by-step.4.1. Exploiting maximal predicate loopsIn the definition of our ordered completion, we introduce a comparison predicate between each pair of predicates. Thisis not necessary. We only need to do so for pairs of predicates that belong to the same strongly connected component inthe predicate dependency graph of the program.Formally, the predicate dependency graph of a first-order program Π is a finite graph PGΠ = (cid:22)V , E(cid:23), where V is the set ofall intensional predicates of Π and (P , Q ) ∈ E iff there is a rule whose head mentions P and whose positive body containsQ . Maximal predicate loops of the program Π are then strongly connected components of PGΠ . Since PGΠ can be constructedeasily, all the maximal predicate loops of Π can be identified in polynomial time with respect to the size of Π .The ordered completions on maximal predicate loops are the same as the ordered completions except that the com-parison predicates (cid:2)PQ are defined only when P and Q belong to the same maximal predicate loop. More precisely, theordered completion of Π on maximal predicate loops, denoted by OC1(Π), is of the similar form as the ordered completionof Π (see Definition 3), except that• Q ((cid:7)z) in Eq. (4) ranges over all the intensional atoms in the positive part of Bodyi such that Q and P are in the samemaximal predicate loop of Π ;• P , Q and R in Eq. (4) are intensional predicates that belong to the same maximal predicate loop of Π .The following proposition is a refinement of the main theorem.Proposition 8. Let Π be a normal logic program whose signature is σ , and A a finite σ -structure. Then, A is an answer set of Π ifand only if there exists a model M of OC1(Π) such that A is the reduct of M on σ .Proof. The “only if” part can be proved by using a similar construction except that the comparison predicates (cid:2)PQ are onlydefined over those pairs of (P , Q ) in the same maximal predicate loop. For the “if” part, we can prove it by contradictionagain. Similarly, we can get the same sequence of ground atoms P 0((cid:7)a0), P 1((cid:7)a1), . . . , P i((cid:7)ai), . . . such that for all i, P i((cid:7)ai) ∈−−−→IntM↑σ , P i((cid:7)ai) ∈ L, and bothai+1 hold. Notice that for all i (i (cid:3) 0), there exists an edge fromP i to P i+1 in PGΠ . Again, there exists k < l such that P k((cid:7)ak) = Pl((cid:7)al). Hence, P k, P k+1, . . . , Pl must be in a maximal predicate−−−→loop of Π , say L. Hence, according to the transitivity axioms with respect to L, (cid:7)al (cid:2)Pl Pk+1ak+1 holds. This contradicts to the−−−→facts that P k((cid:7)ak) = Pl((cid:7)al) and ¬(cid:7)ak (cid:2)Pk Pk+1ak+1 holds. (cid:2)(cid:7)ai and ¬(cid:7)ai (cid:2)P i P i+1−−−→ai+1 (cid:2)P i+1 P iIn many cases, restricting comparison predicates on maximal predicate loops results in a much smaller ordered comple-tion. As many benchmark logic programs have no predicate loops, in these cases, OC1(Π) is exactly the Clark’s completionof Π . Even for those programs with predicate loops, this optimization technique will also significantly simplify the orderedcompletion since, in many cases, not all predicates are in the same predicate loop. Let us consider the following programfor computing all Hamiltonian circuits.14V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24Example 8. The following program HC is another encoding for computing all Hamiltonian circuits of a given graph [22]:hc(x, y) ← arc(x, y), not otherroute(x, y),otherroute(x, y) ← arc(x, y), arc(x, z), hc(x, z), y (cid:3)= z,otherroute(x, y) ← arc(x, y), arc(z, y), hc(z, y), x (cid:3)= z,reached( y) ← arc(x, y), hc(x, y), reached(x), not init(x),reached( y) ← arc(x, y), hc(x, y), init(x),← vertex(x), not reached(x).This program has three intensional predicates: hc, otherroute and reached. According to the original version of the orderedcompletion (see Definition 3), we need to introduce 9 comparison predicates, and the maximal arity is 4.However, by using maximal predicate loops, only one auxiliary predicate is needed since HC has only one maximalpredicate loop, namely {reached}. The only comparison predicate needed is (cid:2)R R (x, y), which is binary. Hence, OC1(H C) isthe following set of sentences:∀xy∀xy(cid:5)(cid:6)hc(x, y) ↔ arc(x, y) ∧ ¬otherroute(x, y)(cid:5)otherroute(x, y) ↔ ∃z∃z,(cid:5)arc(x, y) ∧ arc(x, z) ∧ hc(x, z) ∧ y (cid:3)= z(cid:5)arc(x, y) ∧ arc(z, y) ∧ hc(z, y) ∧ x (cid:3)= z(cid:6)∨(cid:6)(cid:6),(cid:5)(cid:5)∀ y(cid:5)∀ y(cid:5)(cid:6)∃xarc(x, y) ∧ hc(x, y) ∧ reached(x) ∧ ¬init(x)(cid:5)(cid:6)(cid:6)∃xarc(x, y) ∧ hc(x, y) ∧ init(x)(cid:6)(cid:5)(cid:5)arc(x, y) ∧ hc(x, y) ∧ init(x)∃x(cid:5)∃xarc(x, y) ∧ hc(x, y) ∧ reached(x) ∧ ¬init(x) ∧ x (cid:2)R R y ∧ ¬ y (cid:2)R R x(cid:6)→ reached( y)∨reached( y) →∨,(cid:6)(cid:6)(cid:6),(cid:6)vertex(x) ∧ ¬reached(x)(cid:5)∀x¬∀xyz(x (cid:2)R R y ∧ y (cid:2)R R z → x (cid:2)R R z).,4.2. Folding reverse comparison predicatesIn the definition of the ordered completion, for a pair of intensional predicates (P , Q ), we introduce two new comparisonpredicates (cid:2)PQ and (cid:2)QP. This can be simplified by just introducing one of them because if there is a derivation path fromone ground atom to another, then there is none from the other way around.Formally, we abbreviate (cid:7)x (cid:2)PQ (cid:7)y ∧ ¬(cid:7)y (cid:2)QP (cid:7)x as (cid:7)x <PQ (cid:7)y, meaning that there is a derivation path from P ((cid:7)x) to Q ((cid:7)y) butnot the other way around. We rank all the intensional predicates occurring in Π as {P 1, . . . , Pn}, and define Rank(P i) = i(1 (cid:2) i (cid:2) n). For every maximal predicate loop L of Π , and for every two predicates P i, P j ∈ L, we introduce a new compar-ison predicate <P i P j if Rank(P i) (cid:2) Rank(P j). This method reduces almost half of the comparison predicates introduced.The new version of the ordered completion by folding reverse comparison predicates, denoted by OC2(Π), is definedbased on OC1(Π) except that• (cid:7)z (cid:2)QP (cid:7)x ∧ ¬(cid:7)x (cid:2)PQ (cid:7)z in Eq. (4) is replaced by (cid:7)z <QP (cid:7)x if Rank(Q ) (cid:2) Rank(P ), and ¬(cid:7)x <PQ (cid:7)z if Rank(Q ) > Rank(P );• the transitivity axioms, i.e. Eq. (4) with respect to a predicate loop L are replaced as follows:– for any P ∈ L, the sentence ∀(cid:7)x¬(cid:7)x <P P (cid:7)x, and– for any P i, P j, P k ∈ L such that Rank(P i) (cid:2) Rank(P j) (cid:2) Rank(P k), the following two sentences:∀(cid:7)x(cid:7)y(cid:7)z((cid:7)x <P i P j∀(cid:7)x(cid:7)y(cid:7)z(¬(cid:7)x <P i P j(cid:7)y ∨ (cid:7)y <P j Pk(cid:7)y ∨ ¬(cid:7)y <P j Pk(cid:7)z ∨ ¬(cid:7)x <P i Pk(cid:7)z ∨ (cid:7)x <P i Pk(cid:7)z),(cid:7)z).Proposition 9. Let Π be a normal logic program whose signature is σ , and A a finite σ -structure. Then, A is an answer set of Π ifand only if there exists a model M of OC2(Π) such that A is the reduct of M on σ .(cid:7)ai holds if Rank(P i+1) (cid:2) Rank(P i), and ¬(cid:7)ai <P i P i+1Proof. Again, the “only if” part is easy. Now we prove the “if” part by contradiction. Similarly, we can get a sequence ofground atoms P 0((cid:7)a0), P 1((cid:7)a1), . . . , P i((cid:7)ai), . . . such that for all i, P i((cid:7)ai) ∈ IntM↑σ , all P i((cid:7)ai) are in a ground loop L. In addition,−−−→−−−→ai+1 <P i+1 P iai+1 holds if Rank(P i+1) > Rank(P i). (Note that here i is notthe rank of P i .) Since all the <PQ , where Rank(P ) (cid:2) Rank(Q ), satisfy the new transitivity axioms, by induction, it can be(cid:7)a j holds if Rank(P j) > Rank(P i). Again,proved that for all i (cid:2) j,−−−→we can find k < l such that P k((cid:7)ak) = Pl((cid:7)al) in the sequence. Hence, (cid:7)al <Pl Pk+1ak+1 holds if Rank(Pl) (cid:2) Rank(P k+1), and¬−−−→ak+1 <Pk+1 Pl(cid:7)al holds if Rank(Pl) > Rank(P k+1). There are three cases:(cid:7)ai holds if Rank(P j) (cid:2) Rank(P i), and ¬−→−→a j <P j P iai <P i P jV. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–2415Case 1:Case 2:Case 3:Rank(P k) = Rank(Pl) < Rank(P k+1). Then, (cid:7)al <Pl Pk+1Pl((cid:7)al), a contradiction.Rank(P k) = Rank(Pl) > Rank(P k+1). Then, ¬−−−→Pl((cid:7)al), a contradiction.Rank(P k) = Rank(Pl) = Rank(P k+1). Then, (cid:7)al <Pl Pk+1(cid:7)ak holds. Then, according to the transitivity axioms, (cid:7)ak <Pk Pkak+1 <Pk+1 Pl−−−→ak+1 holds. Therefore (cid:7)ak <Pk Pk+1(cid:7)al holds. Therefore ¬−−−→ak+1 <Pk+1 Pk−−−→ak+1 holds since P k((cid:7)ak) =(cid:7)ak holds since P k((cid:7)ak) =−−−→ak+1 holds. Therefore (cid:7)ak <Pk Pk+1−−−→ak+1 holds. Also,(cid:7)ak holds, a contradiction. (cid:2)−−−→ak+1 <Pk+1 PkExample 9. Recall the program Π1 in Example 4p1 ← p2,p2 ← p1,p1 ← not p3.Then, according to the definition, OC2(Π1) is(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)∨¬p3)∧ (p1 → p2 ∧ ¬ <p1 p2∧ (p2 → p1∧ <p1 p2 )∧ (<p1 p1∧ (<p1 p1∧ (<p1 p2∧ (<p2 p2∧ ¬ <p1 p1which is equivalent to∨ <p1 p1∨ <p1 p2∨ <p2 p2∨ <p2 p2∧¬ <p2 p2 ,∨¬ <p1 p1 ) ∧ (¬ <p1 p1∨¬ <p1 p2 ) ∧ (¬ <p1 p1∨¬ <p1 p2 ) ∧ (¬ <p1 p2∨¬ <p2 p2 ) ∧ (¬ <p2 p2∨¬ <p1 p1∨¬ <p1 p2∨¬ <p2 p2∨¬ <p2 p2∨ <p1 p1 )∨ <p1 p2 )∨ <p1 p2 )∨ <p2 p2 )(p2 ∨ ¬p3 → p1) ∧ (p1 → p2) ∧ (p1 → p2 ∧ ¬ <p1 p2∨¬p3)∧ (p2 → p1∧ <p1 p2 ) ∧ ¬ <p1 p1∧¬ <p2 p2 .Then, OC2(Π1) has three models, namely {p3, <p1 p2{p1, p2}.4.3. Simplifying transitivity axioms}, {p3}, and {p1, p2, <p1 p2}. Hence, Π1 has two answer sets: {p3} andNow we consider to simplify the transitivity axioms. In the definition of the ordered completion and its variationspresented previously, we need to introduce the transitivity axioms for every three intensional predicates P , Q and R in amaximal predicate loop such that Rank(P ) (cid:2) Rank(Q ) (cid:2) Rank(R). In other words, we expand the maximal predicate loop toa complete graph and introduce the transitivity axioms for every three vertices. In fact, this can be reduced by expandingthe maximal predicate loop conservatively.Let Π be a program and L = {P 1, . . . , Pn} be a maximal predicate loop in PGΠ . The following procedure generates a setof triples among (the undirected version of) L:1. pick up the vertex P in the undirected version of L which has the least number of edges;2. for every two predicates Q and R connected to P in the undirected version of the graph, add an edge between Q andR, and then select the triples related to the three predicates P , Q and R;3. delete the vertex P in L;4. go to step 1 and repeat this procedure till all triples generated.Example 10. Consider the following program Π2P 1((cid:7)x1) ← P 2((cid:7)x2),P 2((cid:7)x2) ← P 3((cid:7)x3),P 3((cid:7)x3) ← P 4((cid:7)x4),P 4((cid:7)x4) ← P 1((cid:7)x1),P 1((cid:7)x1) ← not P 5((cid:7)x5).16V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24The predicate dependency graph of Π2 contains four nodes, i.e. P 1, P 2, P 3, P 4. In OC2(Π), for the transitivity axioms, weneed to consider every combination of three predicates, which counts 43 groups.According to the procedure above, we can reduce the number to 2 × 33 groups. First, we pick up a vertex, which hadthe least number of edges, say P 1. Then, we need to connect P 2 and P 4 as they are connected to P 1 in the predicatedependency graph. Now, one triple is selected, namely P 1, P 2, P 4. Then, we can delete the node P 1 from the dependencygraph. The rest is a triple now, namely P 2, P 3, P 4. Hence, we need 2 × 33 groups as there are two triples generated.It can be expected that the bigger the predicate dependency graph is, the more transitivity axioms can be reduced.Then, the ordered completion by simplifying transitivity axioms, denoted by OC3(Π), is defined based upon OC2(Π) byreplacing the transitivity axioms only for the triples of intensional predicates generated according to the above procedure.Proposition 10. Let Π be a normal logic program whose signature is σ , and A a finite σ -structure. Then, A is an answer set of Π ifand only if there exists a model M of OC3(Π) such that A is the reduct of M on σ .Proof. The “only if” can be proved similarly. For the “if” part, we prove it by contradiction. Otherwise, following again thesame proof techniques in Proposition 9, we can get a sequence of ground atoms P k((cid:7)ak), P k+1(−−−→ak+1), . . . , Pl((cid:7)al) such that• for all i (k (cid:2) i (cid:2) l), P i((cid:7)ai) ∈ IntM↑σ ;• for all i (k (cid:2) i (cid:2) l), P i((cid:7)ai) are in a ground loop of ΠM↑σ ;−−−→• for all i (k (cid:2) i (cid:2) l − 1),ai+1 <P i+1 P iRank(P i+1) > Rank(P i);• P k((cid:7)ak) = Pl((cid:7)al).(cid:7)ai holds if Rank(P i+1) (cid:2) Rank(P i), and ¬(cid:7)ai <P i P i+1−−−→ai+1 <P i P i+1 ((cid:7)ai,−−−→ai+1) holds ifAssume that L is a sequence of ground atoms that satisfies the above conditions and has the least number of groundatoms. Select the ground atom P i((cid:7)ai) (k (cid:2) i (cid:2) l) in L such that P i is the first predicate calculated according to the pro-−−−→ai+1). According tocedure, among all predicates occurred in the ground loop L. Now we consider P i−1(the procedure, the triple (cid:22)P i−1, P i, P i+1(cid:23) must be selected. Then, there are several cases about the order of ranks among−−−→the three predicates P i−1, P i and P i+1. It can be checked that, no matter the order of rank is,ai−1 holds ifRank(P i+1) (cid:2) Rank(P i−1), and ¬−−−→−−−→ai+1 holds if Rank(P i+1) > Rank(P i−1) since (cid:22)P i−1, P i, P i+1(cid:23) satisfy the newtransitivity axioms. Hence, L\{P i((cid:7)ai)} also satisfies the above conditions. This contradicts to our assumption that L has theleast number of ground atoms satisfying the conditions. (cid:2)−−−→ai−1) and P i+1(−−−→ai+1 <P i+1 P i−1ai−1 <P i−1 P i+14.4. Ordered completion in SMTIn worst case, the transitive formulas in ordered completion need to introduce O (m2) new predicates and O (s × m3)new formulas, where m is the number of intensional predicates and s is the maximal arity of the intensional predicatesof Π (e.g. consider the program whose predicated dependency graph is complete). This is sometimes a heavy burden forimplementation.To address this issue, we propose an alternative solution. Inspired by Niemelä’s translation [23], we use SatisfiabilityModulo Theories (SMT) [24] instead of classical first-order logic as the host language. That is, we translate every normallogic program under the stable model semantics to a sentence (again, its ordered completion) in SMT rather than in classicalfirst-order logic.Roughly speaking, Satisfiability Modulo Theories [24] are first-order theories together with some background theories,such as the theory of real numbers and theory of data structures. For our purpose, we need the theory of partial ordersto eliminate the transitivity axioms. The ordered completion in SMT (with the theory of partial orders as the backgroundtheory) is basically the same as the version in classical first-order logic except that we do not need the transitivity axioms(i.e. TranS(Π)). This is because the comparison predicates (cid:2)PQ can be regarded as built-in predicates in the theory of partialorders, which naturally satisfy transitivity. In this sense, the ordered completion of Π in SMT (with the theory of partialorders as the background theory) is simply the modified Clark’s completion of Π , namely MComp(Π).However, the theory of partial orders is not well-supported in many modern SMT solvers. To address this issue, we showthat, for capturing ordered completion, we can use linear arithmetic as the background theory in SMT as well. The mainreason to do so is that linear arithmetic is well supported by some modern SMT solvers, e.g. Z3.3Formally, the ordered completion in SMT (with linear arithmetic as the background theory) is defined as follows.Definition 4 (Ordered completion in SMT). Let Π be a normal logic program. The SMT-ordered completion of Π , denoted byOC(cid:16)(Π), is the following set of sentences for each intensional predicate P3 http://research.microsoft.com/en-us/um/redmond/projects/z3/V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–2417(cid:4)∃(cid:7)yi(cid:2)Bodyi→ P ((cid:7)x),(cid:2) (cid:3)∀(cid:7)x1(cid:2)i(cid:2)k(cid:2)∀(cid:7)xP ((cid:7)x) →(cid:2)∃(cid:7)yi(cid:2)Bodyi∧(cid:3)1(cid:2)i(cid:2)k(cid:10)(cid:4)(cid:4)n Q ((cid:7)z) < n P ((cid:7)x),Q ((cid:7)z)∈Posi ,Q ∈ΩΠwhere the notations used are borrowed from Definition 3. In addition,• for each intensional predicate P of arity n, n P is a function from domain tuples to integers, i.e. n P : Dn → N;• < is a built-in predicate in linear arithmetic, meaning “less than”.We show that the stable models of a program can be equivalently captured by its SMT-ordered completion as well.Theorem 3. Let Π be a normal logic program whose signature is σ , and A a finite σ -structure. Then the following statements areequivalent:1. A is an answer set of Π ;2. there exists a model M of OC(Π) such that A is the reduct of M on σ ;3. there exists a model M(cid:16)(cid:16)(Π) such that A is the reduct of M(cid:16)of OCon σ .Proof. Theorem 2 proves 1 ⇔ 2. Now we show 2 ⇒ 3. Suppose that we have a structure M of the signature σ ∪ {(cid:2)PQ |P , Q ∈ Ω(Π)}, which is a model of OC(Π), i.e. MComp(Π) ∪ TranS(Π). Since M satisfies TranS(Π), we can define an order(cid:4) on the set IntM of intensional ground atoms, i.e. {P ((cid:7)u) | P ∈ Ω(Π), (cid:7)u ∈ PM}, of Π as follows:• for every P ((cid:7)u) ∈ IntM, P ((cid:7)u) (cid:4) P ((cid:7)u);• for every pair P ((cid:7)u), Q ((cid:7)v) ∈ IntM, P ((cid:7)u) (cid:4) Q ((cid:7)v) iff ((cid:7)u, (cid:7)v) ∈ (cid:2)PQ• for every pair P ((cid:7)u), Q ((cid:7)v) ∈ IntM, we write P ((cid:7)u) = Q ((cid:7)v) iff P ((cid:7)u) (cid:4) Q ((cid:7)v) and Q ((cid:7)v) (cid:4) P ((cid:7)u).M;Clearly, (cid:4) is a partial order on IntM as the comparison predicates (cid:2)PQ satisfy the transitivity axioms, i.e. TranS(Π). There-fore, (cid:4) can be extended to a total order (also called linear order) (cid:4)(cid:16)on IntM. We can construct a mapping f from IntM tonatural numbers, i.e. f : IntM → N, such that for every P ((cid:7)u) ∈ IntM, f (P ((cid:7)u)) is the position of P ((cid:7)u) in this total order (cid:4)(cid:16).f (P ((cid:7)u)) = t iff there exist t elements E1, . . . Et ∈ IntM such that E i (cid:3)= E j for all 1 (cid:2) i < j (cid:2) t and E i (cid:4)(cid:16)P ((cid:7)u) for allThat is,1 (cid:2) i (cid:2) t. Now we construct M(cid:16)based on M and f as follows:has the same domain M and constant interpretations as M;• M(cid:16)M• for all P ∈ σ , P• for all Q ∈ Ω(Π) and (cid:7)u ∈ Mn, n Q ((cid:7)u) = f (Q ((cid:7)u)).M(cid:16) = P;(cid:16)(Π) since M is a model of MComp(Π) and for any two intensional groundIt can be shown that M(cid:16)atoms P ((cid:7)u), Q ((cid:7)v) ∈ IntM, (cid:7)u (cid:2)PQ (cid:7)v (i.e. ((cid:7)u, (cid:7)v) ∈ (cid:2)PQFor 3 ⇒ 2, suppose that we have a structure M(cid:16)is a model of OC(cid:16)(Π). We can constructMa structure M of σ ∪ {(cid:2)PQ | P , Q ∈ Ω(Π)} such that M agrees everything the same on the signature σ and ((cid:7)u, (cid:7)v) ∈ (cid:2)PQiff n P ((cid:7)u) < n Q ((cid:7)v) or n P ((cid:7)u) = n Q ((cid:7)v). Following the similar arguments, it can be shown that M is a model of MComp(Π). Inaddition, M is a model of TranS(Π) as well because the functions n P naturally yield a total order, thus a partial order, onIntM (the same as IntM(cid:16) ). Hence, M is a model of OC(Π). (cid:2)) iff n P ((cid:7)u) < n Q ((cid:7)v) or n P ((cid:7)u) = n Q ((cid:7)v).Mof σ ∪ {n P | P ∈ Ω(Π)}, which is a model of OC5. Implementation and experimental resultsTo the best of our knowledge, the ordered completions provide for the first time a translation from first-order normallogic programs under the stable model semantics to classical first-order logic on finite structures. Significantly, this trans-lation enables us to develop a new kind of ASP solvers by grounding on a program’s ordered completion instead of theprogram itself.5.1. ImplementationIn this section, we report on a first implementation of such a solver. In order to be consistent with existing ASP solvers,we consider Herbrand structures but not arbitrary structures at this stage. As stated in Section 2.3, under this context, ourproposed semantics coincides with Gelfond and Lifschitz’s original semantics [12]. Following the current practice, the inputprogram is divided into two parts:18V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24Fig. 2. Traditional ASP solvers.Fig. 3. Our new ASP solver.1. a first-order normal logic program, and2. a set of ground facts that defines the extensional predicates.4 We also call this set an extensional database.Our goal is to compute answer sets of the program based on the given set of ground facts, i.e. an answer set in whichthe interpretations of the extensional predicates coincide with the extensional database. It is worth mentioning that for thesame first-order logic program, different extensional databases can be provided.For instance, for the transitivity closure program TC (see Example 1), the extensional database can be any graph, whoseedges are represented by E (e.g. the graph in Fig. 1). Our goal is to compute one answer set of the program TC based on thegiven graph. What we need to do is to compute the interpretation of the intensional predicates, namely S in this example,which represents the transitive closure of the graph. Again, while the TC program is always the same, the extensionaldatabase can be any graph, and the purpose of TC is to compute the transitive closure of the given graph.Typically, existing ASP solvers have two components (see Fig. 2):1. A grounder, such as lparse5 and gringo,6 transforms a first-order logic program together with a set of ground facts intoa propositional program.2. A propositional ASP solver, such as clasp,7 cmodels8 and lp2diff,9 computes the answer sets of the propositional program,which correspond to the answer sets of the original first-order program based on those ground facts.Using our ordered completion, we can do it differently (see Fig. 3):(cid:16)(cid:16)(cid:16)123. A translator translates a first-order logic program to its ordered completion (see Definition 3).. A grounder transforms this ordered completion together with a set of ground facts to a propositional theory.. A SAT/SMT solver is called to compute the models of the propositional theory, which correspond to the answer sets ofthe original first-order program based on those ground facts (by Theorem 2/3).We can see the following potential benefits for our approach:• Grounding an ordered completion, which is a first-order sentence, is based on the semantics of classical logic. Therefore,many simplification techniques in classical first-order logic can be used that may not be available for logic programs4 Notice that the set of ground facts contains no information about the intensional predicates.5 http://www.tcs.hut.fi/Software/smodels/.6 http://sourceforge.net/projects/potassco/files/gringo/.7 http://www.cs.uni-potsdam.de/clasp/.8 http://www.cs.utexas.edu/~tag/cmodels/.9 http://www.tcs.hut.fi/Software/lp2diff/.V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–2419under the stable semantics. These simplification techniques may be crucial to scale up the grounding process to dealwith large extensional databases.• In addition to the simplification technique used in run time when doing grounding, the same or similar techniques canbe used to simplify the ordered completion of the “first-order” part of the program, before the extensional database isgiven. Importantly, this can be done “off line”, and done once and for all for each first-order logic program.• The SAT solver part is used as a black box. Any SAT solver can be used here. Hence, we can benefit from any progressin SAT.Based on Theorem 3, we have implemented a prototype of a new ASP solver, which contains three steps. First, we trans-(cid:16)(Π). Notice that some of the optimization techniques mentionedlate a program Π to its SMT-ordered completion, i.e. OC(cid:16)(Π) into a propositional SMT theory.in Section 4 can still be used here. Second, we use our grounder groc to ground OCFinally, we call the SMT solver Z3 to compute a model of the SMT theory, which, by Theorem 3, should be correspondingto an answer set of Π . Next, we report on some preliminary experimental results of our solver on the Hamiltonian Circuitprogram (see Example 8), compared to other major modern ASP solvers.5.2. Experimental resultsThe goal of our experiments is to compare our new ASP solver to the existing ASP solvers.Again, the input is divided into two parts: a first-order program as well as a set of ground facts (i.e. an extensionaldatabase). The output is to return an answer set of the program based on the extensional database if there exists such one,and to return “no” otherwise.As mentioned earlier,in order to solve this problem, existing ASP solvers normally use a 2-step approach. First,a grounder is used to transform the first-order program together with the extensional database to a propositional pro-gram. In our experiments, we use gringo (version 3.03) as the grounder. Secondly, a propositional ASP solver is called tocompute an answer set. In this paper, we consider three different propositional ASP solvers: clasp (version 2.0.1), cmodels(version 3.81), and lp2diff (version 1.27) with Z3 (version 3.2.18).Our solver, however, needs 3 steps. First, we translate a first-order program to its SMT-ordered completion. As this stepis normally very fast and can be done off line, we do not count the time used in this step. Secondly, we implementeda first-order theory grounder called groc, and use it to transform the ordered completion together with the extensionaldatabase to a proportional SMT theory. Finally, we call an SMT solver to compute a model of the SMT theory, which shouldbe an answer set of the program based on the extensional database by Theorem 3. We use Z3 (version 3.2.18) as the SMTsolver in this step.We consider the Hamiltonian Circuit benchmark program by Niemelä [22] (also see Example 8). The current benchmarkgraph instances for the HC program normally contain no more than 150 nodes. Here, instead, we consider much biggergraph instances. That is, we consider random graphs with nodes ranging from 200 to 1000, in which the numbers of edgesare ten times the numbers of nodes. The graph instances are named as rand_nodes_edges_number, where rand means this isa random graph, nodes represents the number of nodes in this graph, edges represents the number of edges in this graph,and number is the code of this graph in this category. For instance, rand_200_2000_6 is a random graph with 200 nodesand 2000 edges, and is the 6th graph instance in this category.Table 1 reports some runtime data of our experiments on the HC program with those relatively big graph instances. Theexperiments were performed on a CENTOS version 2.16.0 LINUX platform with 2 GB of memory and AMD Phenom 9950Quad-Core processor running at 2.6 GHz. For space reasons, we only report the overall time used by the following differentapproaches:• gringo as the grounder and clasp as the propositional ASP solver (gringo + clasp);• gringo as the grounder and cmodels as the propositional ASP solver (gringo + cmodels);• gringo as the grounder, lp2diff as the translator from propositional programs to SMT and Z3 as the SMT solver (gringo +• finally, our solver by using groc to ground the ordered completion together with extensional databases, and calling thelp2diff + Z3);SMT solver Z3 (groc + Z3).We set the timeout threshold as 900 seconds, which is denoted by “–” in our experimental results.In Table 1, the first column specifies the graph instances. In the second column, “y” (“n”) means that the correspondinggraph has a (no) Hamiltonian Circuit, while “?” means that this problem instance is not solved by any approaches withinlimited time. The rest four columns record the overall time in seconds used by the four different approaches. It is worthmentioning that, normally, the grounding time (i.e. for gringo and groc) is much less than the solving time.Table 1 shows that our solver compares favorably to the others on the Hamiltonian Circuit benchmark program, especiallyfor those big graph instances. For 200-node random graphs, our solver seems not as good as gringo + classp in general, butstill looks slightly better than the other two. However, when the graph goes bigger, our advantages emerge. For those 400-node and 600-node graphs, our solver clearly outperforms the other approaches. Moreover, for 1000-node random graphs,our solver is the only one capable of solving the problems within the time threshold. Also, it is interesting to take a closer20V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24Table 1Experimental results about the Hamiltonian Circuit program.Instancesrand_200_2000_1rand_200_2000_2rand_200_2000_3rand_200_2000_4rand_200_2000_5rand_400_4000_1rand_400_4000_2rand_400_4000_3rand_400_4000_4rand_400_4000_5rand_600_6000_1rand_600_6000_2rand_600_6000_3rand_600_6000_4rand_600_6000_5rand_1000_10000_1rand_1000_10000_2rand_1000_10000_3rand_1000_10000_4rand_1000_10000_5gringo + claspgringo + cmodelsgringo + lp2diff + Z3groc + Z3yynyyyy?yyyyyyyyyyyy0.3250.6040.1751.4530.329–24.110–––140.830–––––––––3.1303.3100.1507.9607.600––––––––––––––6.95410.1852.50718.4128.89949.506––46.938162.277114.973203.500340.21983.650403.075–––––1.791.950.001.6615.245.0859.31–8.108.0012.1638.4145.8452.139.20324.22133.6699.32256.91295.89look at the only instance with no answer sets, i.e. rand_200_2000_3. With our grounder groc, the inconsistency can beimmediately identified.More importantly, it is reasonable to believe that the performance of our solver can be further improved by employingmore optimization techniques. In particular, it is interesting to see if some technique can be developed to simplify theordered completion. As mentioned earlier, this can be done off line since it only needs to be done once for each program.We have observed that for some logic programs, their ordered completion can indeed be simplified to yield a first-ordersentence that is significantly smaller in size. To us, this is one of the most important future work.6. Related work and discussionsIn this section, we discuss and compare our translation to other translations from logic programs under the stable model(answer set) semantics to classical logic. In general, one can say that the intuitions behind most of the translations aresimilar. The main differences are in the ways that these intuitions are formalized.6.1. First-order caseOther first-order translations As the focus of this paper is to consider the first-order case, we first review the existingwork about translating first-order logic programs under the stable model semantics to standard first-order logic. To the bestof our knowledge, the only such translation is the loop formula approach [2,16]. From a syntactical viewpoint, the maindifference between this approach and ours is that the ordered completion results in a finite first-order theory (which canbe represented as a single first-order sentence) but uses auxiliary predicates, while the loop formula approach does not useany auxiliary predicates but in general results in an infinite first-order theory.From a semantical viewpoint, both approaches share some similar ideas. First of all, both of them are extended fromClark’s completion, and the extended parts play a similar role to eliminate those structures which are models of the Clark’scompletion but not stable models of the logic program. The main difference is that the loop formula approach uses loopformulas for this purpose, while the ordered completion uses additional comparison predicates to keep track of the deriva-tion order. Secondly, they both require that every ground atom in a stable model must be justified by certain derivationpath. However, for this purpose, the loop formula approach further claims that every loop (so is every ground atom) musthave some external supports, while the ordered completion approach explicitly enumerates such a derivation order (thus aderivation path) by the new comparison predicates.Similar translations in Datalog Another related work [15] is in the area of finite model theory and fixed-point logic. Al-though fixed-point logic and normal logic programming are not comparable, they have a common fragment, namely Datalog.Kolaitis [15] showed that every fixed-point query is conjunctive definable on finite structures. That is, given any fixed-point(cid:16)) is implicitly definable on finitequery Q , there exists another fixed-point query Qstructures. As a consequence, every Datalog query is also conjunctively definable on finite structures. From this result, al-though tedious, one can actually derive a translation from Datalog to first-order sentences using some new predicates notin the signatures of the original Datalog programs.such that the conjunctive query (Q , Q(cid:16)We will not go into details comparing our translation and the one derived from Kolaitis’ result since our focus here is onnormal logic programs. Suffice to say here that the two are different in many ways, not the least is that ours is based onV. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–2421Clark’s completion in the sense that some additional conditions are added to the necessary parts of intensional predicates,while the one derived from Kolaitis’ result is not. We mention this work because Kolaitis’ result indeed inspired our initialstudy on this topic. We speculated that if it is possible to translate Datalog programs to first-order sentences using somenew predicates, then it must also be possible for normal logic programs, and that if this is true, then it must be doable bymodifying Clark’s completion. As it happened, this turned out to be the case.6.2. Propositional caseTranslations in the propositional case The ordered completion can be viewed as a propositional translation from normallogic programs to propositional theories by treating each propositional atom as a 0-ary predicate. Several proposals in thisdirection have been proposed in the literature [1,14,18,19,23].An early attempt is due to Ben-Eliyahu and Dechter [1], who assigned an index (or level numbering) #p to each propo-sitional atom p, and added the assertions #p < #q to the Clark’s completion for each pair (p, q) similar to the orderedcompletion, where q is the head of a rule and p ranges over all atoms in the positive body of a rule. A closely related workis recently proposed by Niemelä [23], in which the level mappings and their comparisons are captured in difference logic,an extension of classical propositional logic. More precisely, each atom p is assigned to a number xp , meaning its level orstage. Then, the assertions xq − 1 (cid:3) xp are added to the Clark’s completion similar to Ben-Eliyahu and Dechter and the or-dered completion. In addition, in both approaches, the optimization technique of exploiting strongly connected componentsis discussed.Another translation, also sharing the basic idea of comparing stages (or indices), is due to Janhunen [14], who proposeda simplified translation by level numbering as well. Different from the above approaches, Lin and Zhao [18] translated anarbitrary normal logic program equivalently to a tight program first by adding some new atoms, and then use the Clark’scompletion of the new program to capture the answer sets of the original one. Finally, the loop formula approach in thepropositional case [19] yields another translation from propositional normal logic programming to propositional logic. Again,the loop formula approach requires no new atoms. However, it is not polynomial in the sense that a program may haveexponential loop formulas in worst case.Comparisons with Ben-Eliyahu and Dechter’s and Niemelä’s work Here, we discuss more about the relationships amongthe ordered completion, Ben-Eliyahu and Dechter’s translation and Niemelä’s work since these three translations are veryclosely related, while the others are slightly different. In fact, the above three translations basically share the same intuitionsin the propositional case. This is because all of them are modified from Clark’s completion by adding to it the comparisonsof indices/levels/stages. Specifically, the comparisons are represented by (cid:2)pq ∧¬ (cid:2)qp in the ordered completion, #p < #q inBen-Eliyahu and Dechter’s translation and xq − 1 (cid:3) xp in Niemelä’s work, where in all the above approaches, q is the headof a rule and p ranges over all atoms in the positive body of a rule. Indeed, these assertions play the same role to statethat the stage (or level) of p should be less than the one of q. In this sense, the modified completion part of all these threeapproaches can be transformed from each other.In Ben-Eliyahu and Dechter’s translation, one has to explicitly enumerate the “indices” #p and “comparisons” #p < #qin propositional logic [1], which turns out to be rather complicated. This is not an issue for Niemelä’s work [23] becausethe level numbering xp associated with atoms and the comparisons xq − 1 (cid:3) xp can be directly represented by the built-in predicates within the language of difference logic. Finally, in the ordered completion, we do not introduce the indicesdirectly but use additional atoms (cid:2)pq in classical propositional logic to explicitly represent the comparisons (cid:2)pq ∧¬ (cid:2)pq,which are further specified by the transitivity formulas.The similarities and differences among the three approaches can be illustrated by the following example.Example 11. Recall the program Π1 in Example 4:p1 ← p2,p2 ← p1,p1 ← not p3.According to the definitions, the modified completion part of Π1 for the ordered completion is(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)(cid:5)∧¬ (cid:2)p1 p2p1 → p2 ∧ [(cid:2)p2 p1∧¬ (cid:2)p2 p1p2 → p1 ∧ [(cid:2)p1 p2(cid:5)] ∨ ¬p3(cid:6)],(cid:6)∧∧while for Ben-Eliyahu and Dechter’s translation, this is(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)(cid:5)p1 → p2 ∧ [#p2 < #p1] ∨ ¬p3(cid:6)p2 → p1 ∧ [#p1 < #p2](cid:5),(cid:6)∧∧22V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24and finally, for Niemelä’s work, this is10(p2 ∨ ¬p3 → p1) ∧ (p1 → p2)(cid:5)p1 → p2 ∧ [xp1p2 → p1 ∧ [xp2− 1 (cid:3) xp2− 1 (cid:3) xp1] ∨ ¬p3(cid:6)](cid:5).(cid:6)∧∧It can be observed that, the modified completion part of the three approaches can be easily obtained from each other. Forinstance, from Niemelä’s work to the ordered completion, one only needs to replace each subformula of the form xp − 1 (cid:3) xq(e.g. xp1− 1 (cid:3) xp2 ) with its corresponding counterpart (cid:2)qp ∧ ¬ (cid:2)pq in the ordered completion ((cid:2)p2 p1∧ ¬ (cid:2)p1 p2 resp.).The main difference among the three approaches is another part of the translation, namely how to encode those newindices and comparisons. The host formalism for both Ben-Eliyahu and Dechter’s translation and our ordered completion ispropositional logic, but for Niemelä’s work, it is difference logic, which is an extension of classical propositional logic withlinear constraints but not propositional logic itself. As a result, the encoding problem of comparisons for Niemelä’s work is− 1 (cid:3) xp2 , can be naturally represented in the language of difference logicnot an issue because the comparisons, e.g. xp1with the built-in predicate (cid:3). However, for the other two approaches, more work need to be done.In the ordered completion, we use additionally transitivity formulas among new atoms (cid:2)pq for this purpose. For instance,for the program Π1, the transitivity formulas is11:(cid:2)p1 p2∧ (cid:2)p2 p1∧ (cid:2)p2 p1∧ (cid:2)p1 p2→ (cid:2)p1 p1→ (cid:2)p2 p2 .In Ben-Eliyahu and Dechter’s translation, one needs to explicitly encode the indices #p and the comparisons #p < #q inclassical propositional logic. This is rather complicated because one has to enumerate all the possibilities. For instance, forthe program Π1, the encoding of each index, e.g. #p1, is:(cid:5)(p1 = 1 ∨ p1 = 2) ∧(cid:6)p1 = 1 → ¬(p1 = 2),and the encoding of each comparison, for instance #p1 < #p2, is:p1 = 1 ∧ p2 = 2.6.3. First-order definability and weak definabilitySince the ordered completion is about translating logic programs to first-order logic, it is closely related to the conceptsof (first-order) definability for answer set programming [16,27].A program is ( first-order) definable (on finite structures) iff there exists a first-order sentence of the signature of the pro-gram such that its (finite) models are exactly the (finite) stable models of the program. It is well known that many programsare not first-order definable, e.g. the program TC in Example 1, both on arbitrary structures and on finite structures [5].A weaker notion of first-order definability is to allow new predicates. A program is ( first-order) weakly definable (on finitestructures) iff there exists a first-order sentence of a signature containing the signature of the program such that the reductsof its (finite) models on the signature of the program are exactly the (finite) stable models of the program. It is easy to seethat a program is weakly definable (on finite structures) if and only if it is defined by an existential second-order sentence(on finite structures).The following result immediately follows from Theorem 2.Corollary 11. Every normal logic program is weakly definable on finite structures. More precisely, every program is weakly defined byits ordered completion on finite structures.However, as shown in Proposition 5, this result does not hold on arbitrary structures. For instance, the TC program is notweakly definable on arbitrary structures. In fact, following a similar proof, Proposition 5 can be extended to the followingresult.Proposition 12. On arbitrary structures, if a normal logic program is not definable, then it is not weakly definable.10 It can be observed that the new atoms bdi11 All the other transitive formulas are trivially true.a in Niemelä’s work are not necessary.V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–2423New predicatesAllowedNot allowedNot allowedAllowedResulting theoryNo restrictionFiniteNo restrictionFiniteTranslationDoes not existDoes not existLoop formulaOrdered completionTable 2From normal ASP to FOL.StructuresArbitraryFiniteFiniteFinite7. ConclusionThe main contribution of this paper is introducing a notion of ordered completion that captures exactly the answerset semantics of first-order normal logic programs with constraints and choice rules on finite structures (see Theorem 2,Propositions 3 and 4). It can be summarized as follows:For first-order normal logic programs on finite structures,Answer set = Clark’s completion + Derivation order= Ordered completionThis seems to be a very tight result. First of all, as we have seen, this result cannot be extended to disjunctive logicprograms unless NP = coNP (see Proposition 6). For normal logic programs, with this result, we now have a rather completepicture of mappings from logic programs to first-order logic which is summarized by Table 2.The significance of our ordered completion can be seen from both a theoretical and a practical point of view. To thebest of our knowledge, it provides for the first time a translation from first-order normal logic programs under the stablemodel semantics to first-order sentences. Furthermore, it makes it possible to implement a new ASP solver by groundinga first-order theory instead of the program itself, an idea that motivated this and the work of [2] as well. We report ourfirst implementation of such a solver (Section 5), and did some experiments on the Hamiltonian Circuit problems, whichare by far the best known benchmark logic programs that have loops. Our results clearly showed that our new solver iscompetitive, with the edge over others on large problems (see Table 1). We are still working on improving our solver, andbelieve that we will have some new results to report in the near future.AcknowledgementsWe would like to thank the anonymous reviewers for their valuable comments. This research is supported in part byARC Discovery project grant DP0988396, HK RGC GRF 616909 and NSFC grants 90718009 and 60963009.References[1] Ben-Eliyahu Rachel, Rina Dechter, Propositional semantics for disjunctive logic programs, Annals of Mathematics and Artificial Intelligence 12 (1–2)(1994) 53–87.[2] Yin Chen, Fangzhen Lin, Yisong Wang, Mingyi Zhang, First-order loop formulas for normal logic programs, in: Proceedings of the 10th InternationalConference on Principles of Knowledge Representation and Reasoning (KR’06), 2006, pp. 298–307.[3] Yin Chen, Fangzhen Lin, Yan Zhang, Yi Zhou, Loop-separable programs and their first-order definability, Artificial Intelligence 175 (3–4) (2011) 890–913.[4] Keith L. Clark, Negation as failure, in: H. Gallaire, J. Minker (Eds.), Logics and Databases, Plenum Press, New York, 1978, pp. 293–322.[5] Heinz-Dieter Ebbinghaus, Jörg Flum, Finite Model Theory, Springer-Verlag, 1995.[6] Thomas Eiter, Georg Gottlob, Heikki Mannila, Disjunctive Datalog, ACM Transactions on Database Systems 22 (3) (1997) 364–418.[7] Fran ´cois Fages, A new fixpoint semantics for general logic programs compared with the well-founded and the stable model semantics, New GenerationComputing 9 (3–4) (1991) 425–443.[8] Fran ´cois Fages, Consistency of Clark’s completion and existence of stable models, Journal of Methods of Logic in Computer Science 1 (1994) 51–60.[9] Ronald Fagin, Contributions to the model theory of finite structures, PhD Thesis, UC Berkeley, 1973.[10] Paolo Ferraris, Joohyung Lee, Vladimir Lifschitz, A new perspective on stable models, Artificial Intelligence 175 (1) (2011) 236–263.[11] Paolo Ferraris, Answer sets for propositional theories, in: Proceedings of the 8th International Conference on Logic Programming and NonmonotonicReasoning (LPNMR’05), 2005, pp. 119–131.[12] Michael Gelfond, Vladimir Lifschitz, The stable model semantics for logic programming, in: Proceedings of the Fifth International Conference andSymposium (ICLP’88), 1988, pp. 1070–1080.[13] Michael Gelfond, Vladimir Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (3–4) (1991) 365–386.[14] Tomi Janhunen, Representing normal programs with clauses, in: Proceedings of the 16th European Conference on Artificial Intelligence (ECAI’04), 2004,pp. 358–362.[15] Phokion G. Kolaitis, Implicit definability on finite structures and unambiguous computations (preliminary report), in: Proceedings of the Fifth AnnualSymposium on Logic in Computer Science (LICS’90), 1990, pp. 168–180.[16] Joohyung Lee, Yunsong Meng, On loop formulas with variables, in: Proceedings of the Eleventh International Conference on Principles of KnowledgeRepresentation and Reasoning (KR’08), 2008, pp. 444–453.[17] Vladimir Lifschitz, R. Tang Lappoon, Hudson Turner, Nested expressions in logic programs, Annals of Mathematics and Artificial Intelligence 25 (3–4)(1999) 369–389.[18] Fangzhen Lin and Jicheng Zhao, On tight logic programs and yet another translation from normal logic programs to propositional logic, in: Proceedingsof the 18th International Joint Conference on Artificial Intelligence (IJCAI’03), 2003, pp. 853–858.24V. Asuncion et al. / Artificial Intelligence 177–179 (2012) 1–24[19] Fangzhen Lin, Yuting Zhao, ASSAT: computing answer sets of a logic program by SAT solvers, Artificial Intelligence 157 (1–2) (2004) 115–137.[20] Fangzhen Lin, Yi Zhou, From answer set logic programming to circumscription via logic of GK, Artificial Intelligence 175 (1) (2011) 264–277.[21] Victor W. Marek, Miroslaw Truszczynski, Stable models and an alternative logic programming paradigm, in: The Logic Programming Paradigm: A 25-Year Perspective, Springer-Verlag, 1999, pp. 375–398.[22] Ilkka Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Annals of Mathematics and Artificial Intelli-gence 25 (3–4) (1999) 241–273.[23] Ilkka Niemelä, Stable models and difference logic, Annals of Mathematics and Artificial Intelligence 53 (1–4) (2008) 313–329.[24] Robert Nieuwenhuis, Albert Oliveras, Cesare Tinelli, Solving SAT and SAT modulo theories: from an abstract Davis–Putnam–Logemann–Loveland proce-dure to DPLL(T), Journal of the ACM 53 (6) (2006) 937–977.[25] David Pearce, Agustín Valverde, Towards a first order equilibrium logic for nonmonotonic reasoning, in: Proceedings of the 9th European Conferenceon Logics in Artificial Intelligence (JELIA’04), 2004, pp. 147–160.[26] David Pearce, A new logical characterisation of stable models and answer sets, in: Non-Monotonic Extensions of Logic Programming (NMELP’96), 1996,pp. 57–70.[27] Yan Zhang, Yi Zhou, On the progression semantics and boundedness of answer set programs, in: Proceedings of the Twelfth International Conferenceon the Principles of Knowledge Representation and Reasoning (KR’10), 2010, pp. 518–527.