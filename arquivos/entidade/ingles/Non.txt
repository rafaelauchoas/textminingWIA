Artificial Intelligence 175 (2011) 25–48Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintNon-Markovian control in the Situation Calculus ✩Alfredo GabaldonCenter for Artificial Intelligence, New University of Lisbon, Lisbon, Portugala r t i c l ei n f oa b s t r a c tArticle history:Available online 3 April 2010Keywords:Reasoning about actionsSituation CalculusIn reasoning about actions,it is commonly assumed that the dynamics of domainssatisfies the Markov Property: the executability conditions and the effects of all actionsare fully determined by the present state of the system. This is true in particular inIn this paper, we generalizeReiter’s Basic Action Theories in the Situation Calculus.Basic Action Theories by removing the Markov property restriction, making it possibleto directly axiomatize actions whose effects and executability conditions may depend onpast and even alternative, hypothetical situations. We then generalize Reiter’s regressionoperator, which is the main computational mechanism used for reasoning with Basic ActionTheories, so that it can be used with non-Markovian theories.© 2010 Elsevier B.V. All rights reserved.Since the 1960’s when John McCarthy’s papers (in particular the 1969 paper with Pat Hayes) appeared introducing theSituation Calculus, researchers have been studying and working on this language for reasoning about dynamic domains. TheSituation Calculus, one of John’s many great inventions, is the topic of this paper and I am delighted to have this opportunityto make a contribution to a special issue in John’s honor.1. IntroductionAn assumption commonly made in formalisms for reasoning about the effects of actions is the so called Markov property:the executability of an action and its effects are entirely determined by the current state or situation. In particular, Reiter’sBasic Action Theories [2], a Situation Calculus [3,4] based axiomatization, define the value of a fluent after the executionof an action in terms of a formula that can only talk about the situation in which the action would be executed. Thepreconditions of an action are specified by formulas with the same restriction. In this paper we generalize Basic ActionTheories by removing this restriction. The generalized theories will allow the executability conditions and the effects of anaction to depend not only on what holds when the action is to occur, but also on whether certain conditions were satisfiedat different points in the past and even alternative hypothetical evolutions of the system.As an example, imagine a robot that works in a biological research facility with different safety-level areas. The dynamicsis such that a material will be considered contaminated after the robot touches it if the robot has been to a low safety areaor has directly been in contact with a hazardous material, and has not been to the disinfection station since then. So theeffect of touching the material depends on the history of robot activities. We could also imagine that the robot cannotexecute the action open(Entrance, Lab1) if temp(Lab1) > 30 was ever true since the last time closed(Entrance, Lab1) occurred.The latter is an example of an action with non-Markovian preconditions.In simple scenarios, it is not difficult to extend a theory to preserve the necessary history by means of new statevariables, especially when the domain is finite. But in complex domains it may not be obvious how to do it, and the✩A preliminary abstract of this paper appeared in Proc. of AAAI’02 (A. Gabaldon (2002) [1]).E-mail address: ag@di.fct.unl.pt.0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.04.01226A. Gabaldon / Artificial Intelligence 175 (2011) 25–48resulting theory may be substantially more complex, with a larger number of state variables and corresponding axiomsdescribing their dynamics.Our goal in this paper is to generalize Reiter’s Basic Action Theories [5,2] by removing the Markov property requirementand generalize the main reasoning mechanism used with these theories, namely the regression operator R, so that itcan be used with non-Markovian theories, and applied to Situation Calculus formulas that refer to the past, to alternativeevolutions, and to definite future situations.This generalized regression operator is not only useful in cases where the action theory is non-Markovian. Even if thebackground theory is Markovian, the operator is useful for answering queries that refer to past situations through quan-tification and the subsequence relation (cid:2). This is not possible with Reiter’s original regression operator. In [2, Section 4.8],Reiter presents a few specialized procedures for evaluating certain historical queries with respect to a database log (a se-quence of ground action terms) and a Markovian action theory. Those queries are a very small subset of the class of queriesthat the generalized regression operator we present here can handle.Our work is relevant to a variety of research problems that involve the formalization of dynamic properties:(1) Some work in database theory has been concerned with the semantics of dynamic integrity constraints [6,7]. Theseconstraints are typically expressed in Past Linear Temporal Logic, a logic with temporal connectives Previous, Sometimein the past, Always in the past, and Since. In a formalization of a database system in the Situation Calculus, suchtemporal connectives amount to references to past situations, and the constraints to restrictions on when a sequence ofactions can be considered a “legal” database system evolution. These past temporal logic connectives have an encodingas formulas in the non-Markovian Situation Calculus and hence the latter can be used as a logical framework forthe study, specification and modeling of databases with dynamic integrity constraints. The advantage of carrying outsuch work in this framework is that all the different aspects of the problem, i.e. database dynamics, transactions andconstraints, can be captured within the same Situation Calculus framework.(2) Also in the area of databases, more specifically in work on database transaction systems, the rollback operation, whichreverts a database back to its original state after a long transaction fails or is canceled, clearly has a non-Markovianflavor: its effects depend not on what is true in the state it is executed, but on the state right before the transactionbeing reversed started. Indeed, Kiringa [8] and Kiringa and Gabaldon [9,10] present logical specifications of databasetransactions in the non-Markovian Situation Calculus.(3) In planning, domain dependent knowledge for search control has been used with great success [11,12]. Bacchus andKabanza’s forward-chaining planning system, TLPlan, uses search control knowledge in the form of temporal logic for-mulas. The same approach has been applied in the Situation Calculus with some simple planners written in Golog [2].The latter planners perform a forward search, eliminating partial plans if they lead to “bad situations.” Search controlknowledge is encoded through a predicate badSituation(s) whose definition is restricted to properties of the currentsituation s. The generalization of the action theories and the regression operator we shall develop here allows the def-inition of this predicate to refer to any situation that precedes s and bounded future situations. As we mention above,past temporal logic expressions can be encoded as Situation Calculus formulas suitable for regression with our gen-eralized operator and be used in the definition of badSituation(s). In other words, the generalized regression operatorallows one to use temporal search control knowledge of a similar form and expressive power as used in TLPlan directlyin Golog planners with the badSituation(s) predicate. Search control knowledge in this context is further explored inour recent work [13,14].(4) Another area where non-Markovian features arise naturally is in specifying reward functions in decision theoretic plan-ning. There, agents are often rewarded based on their long-term behavior rather than just on the current state of affairs.Bacchus, Boutilier and Grove [15,16] have developed techniques for solving such non-Markovian Decision Processes.More recent work on non-Markovian rewards appears in [17,18].(5) Finally, some time ago John McCarthy [19] described a programming language called “Elephant 2000” which, amongother features, “does not forget.” This is a language that would allow one to write programs that explicitly and directlyrefer to past states of the programming environment. The generalized regression operator we present here could formthe foundation for a non-forgetting Golog [20]. Such a dialect of Golog would allow test conditions that refer to thepast, for instance, as in the statement if (P since Q ) then δ.This paper is organized as follows: we start in Section 2 with an overview of the Situation Calculus and Reiter’s BasicAction Theories. In Section 3 we introduce a class of Situation Calculus formulas that can refer to past and finite futuresituations and can be regressed, and based on this, our generalization of action theories for non-Markovian control. InSection 4 we present a regression operator that works for those formulas and theories and prove its correctness, followedby a Prolog implementation in Section 5 and our concluding remarks in Section 6.2. Overview of the Situation Calculus and Basic Action TheoriesThe Situation Calculus [3,4] is a dialect of classical logic for representing and reasoning about dynamically changingworlds. A theory in this language consists of a collection of axioms describing how the world changes when actions occur.Accordingly, the ontology of the Situation Calculus includes three main ingredients: actions, situations, and fluents. Situ-A. Gabaldon / Artificial Intelligence 175 (2011) 25–4827ations refer to possible evolutions or “histories” of the world and are identified with the sequences of actions that haveoccurred in such a history. Fluents are the properties of the world that change over time.Since McCarthy introduced it, the Situation Calculus has been adopted in various languages and differing axiomatizations.In this paper we use the version described in [5,21,2], whose formal definition we review next.2.1. Situation CalculusThe Situation Calculus (as we will refer to this version from now on), denoted by Lsitcalc, is a second-order languagewith equality and with three disjoint sorts called action, situation and object. In addition to standard logical symbols, itsvocabulary includes:• A countably infinite number of variable symbols of each sort and predicate variables of all arities.• The constant symbol S0, of sort situation, which is used to represent the initial situation of the world, before any actionoccurs.• The function symbol do of sort action × situation (cid:2)→ situation, which is used to form sequences of actions. A term do(a, s)represents the situation after action a is executed in situation s.• The binary predicate symbol (cid:2), used to represent an ordering relation on situations. Intuitively, s (cid:2) ssituation s precedes s, or, in terms of sequences of actions, that s is a proper prefix of the sequence of actions s• The binary predicate symbol Poss : action × situation. The intuitive meaning of Poss(a, s) is that in situation s, it is(cid:4)(cid:4)means that(cid:4).possible to execute action a.• For each n (cid:2) 0, a finite or countably infinite number of function symbols of sort (action ∪ object)n (cid:2)→ action calledaction functions. For example: move( A, B) and write(agent3, nextChapter(Thesis, s)). We will sometimes refer to an actionfunction as an action type, since each action function can have many instances.• For each n (cid:2) 0, a finite or countably infinite number of predicate symbols of sort (action ∪ object)n × situation calledrelational fluents, and a countably infinite number of function symbols of sort (action ∪ object)n × situation (cid:2)→ action ∪object called functional fluents. For example,(cid:2)on(cid:2)(cid:3)(cid:3)A, B, domove( A, B), S0.• For each n (cid:2) 0, a finite or countably infinite number of n-ary predicates and functions without a situation argumentwhich are used for expressing situation independent relations, i.e. properties of the world that do not change as a resultof actions. For example: distance(csDept, mathDept).The following four Foundational Axioms, denoted by Σ , characterize situations and the precedence relation (cid:2):do(a1, s1) = do(a2, s2) ⊃ a1 = a2 ∧ s1 = s2,(cid:4)(∀P ).P (S0) ∧ (∀a, s)¬s (cid:2) S0,(cid:2)s (cid:2) doa, s(cid:4) ∨ s = sP (s) ⊃ P≡ s (cid:2) sdo(a, s)(cid:3)(cid:5)(cid:2)(cid:3).(cid:4)(cid:4)⊃ (∀s)P (s),(1)(2)(3)(4)Axiom (1) is a unique names axiom for the function do, and it captures the intuition that different histories (sequences ofactions) are different situations. Axiom (2) defines how situations are built using the function do. This definition is inductiveand so this axiom is second-order. Axiom (3) stipulates that S0 has no preceding situations, thus capturing the intuitionthat it is the initial situation, and together with axiom (4) and the induction axiom it defines the precedence relation (cid:2).2.2. Basic Action TheoriesThe foundational axioms Σ are the domain independent part of a Situation Calculus axiomatization of a dynamic world.The domain dependent part consists of: a set of axioms describing the initial state of the world, a set of axioms describingthe conditions under which actions are executable and another set of axioms describing how each of the fluents changeswhen actions occur. The notion of a uniform formula is useful in describing these axioms.Definition 1 (Uniform formulas). Let σ be a term of sort situation. The Lsitcalc terms uniform in σ are inductively defined asthe smallest set of terms such that:(1) Any term that does not mention a term of sort situation is uniform in σ .(2) If g is an n-ary non-fluent function symbol, and t1, . . . , tn are terms that are uniform in σ and whose sorts are appro-priate for g, then g(t1, . . . , tn) is uniform in σ .(3) Iffis an (n + 1)-ary functional fluent symbol, and t1, . . . , tn are terms that are uniform in σ and whose sorts areappropriate for f , then f (t1, . . . , tn, σ ) is uniform in σ .28A. Gabaldon / Artificial Intelligence 175 (2011) 25–48The formulas of Lsitcalc that are uniform in σ are inductively defined as the smallest set of formulas such that:(1) Any formula that does not mention a term of sort situation is uniform in σ .(2) When F is an (n + 1)-ary relational fluent and t1, . . . , tn are terms uniform in σ whose sorts are appropriate for F , thenF (t1, . . . , tn, σ ) is a formula uniform in σ .(3) If U 1 and U 2 are formulas uniform in σ , then so are ¬U 1, U 1 ∧ U 2 and (∃v)U 1 provided v is a variable not of sortsituation.For each action type A((cid:12)x),1 a dynamic world axiomatization includes an axiom defining when such an action is exe-cutable. These axioms define the relation Poss(a, s):Definition 2 (Action precondition axiom). An action precondition axiom is a sentence of the form:(cid:2)(cid:3)PossA(x1, . . . , xn), s≡ Π A(x1, . . . , xn, s),where A is an n-ary action function symbol and Π A(x1, . . . , xn, s) is a formula with free variables among x1, . . . , xn, s thatis uniform in s.For each fluent, relational or functional, an axiom defining the fluent’s value after the execution of an action is includedin the dynamic world axiomatization:Definition 3 (Successor state axioms). A successor state axiom for an (n + 1)-ary relational fluent F is a sentence of the form:(cid:2)(cid:3)x1, . . . , xn, do(a, s)F≡ ΦF (x1, . . . , xn, a, s),where ΦF (x1, . . . , xn, a, s) is a formula with free variables among x1, . . . , xn, a, s that is uniform in s.A successor state axiom for an (n + 1)-ary functional fluent fis a sentence of the form:(cid:2)(cid:3)x1, . . . , xn, do(a, s)f= y ≡ φ f (x1, . . . , xn, y, a, s),where φ f (x1, . . . , xn, y, a, s) is a formula with free variables among x1, . . . , xn, y, a, s that is uniform in s.The right-hand sides of action precondition and successor state axioms are required to be uniform in situation variable s.This is exactly how the Markov property is enforced in these theories. Intuitively, the executability conditions of an actionand the value of fluents in a successor situation can only be defined in terms of the current situation.A collection of axioms of the above forms is known as a Basic Action Theory:Definition 4 (Basic Action Theories). An Lsitcalc Basic Action Theory, D, is a collection of axioms D = Σ ∪ Dss ∪ Dap ∪ Duna ∪ DS0where:• Σ are the foundational axioms (1)–(4).• Dss is a set of successor state axioms, one for each fluent.• Dap is a set of action precondition axioms, one for each action type.• Duna is a set of unique name axioms for actions, such as: pickup(x) (cid:13)= putdown( y) and stack(x, y) = stack(x(cid:4), y(cid:4)) ⊃ x =(cid:4) ∧ y = yx(cid:4).• DS0 is a set of first order sentences that are uniform in S0. These axioms describe the initial state of the world and aresometimes referred to as the initial database.3. Non-Markovian theoriesIn this section we introduce Non-Markovian Basic Action Theories. In Markovian action theories, the Markov assumptionis realized by requiring that the formulas in the action precondition axioms and successor state axioms refer only to one sit-uation, a variable s, which is prenex universally quantified in the axioms. In non-Markovian action theories, situation termsother than s will be allowed under the restriction that they refer to the past or to an alternative, explicitly bounded evolu-tion. To make this formal, we need to introduce the notion of situation-bounded formulas. Intuitively, an Lsitcalc formula isbounded by a situation term σ if all the situation variables it mentions are restricted, through equality or the (cid:2) predicate,to range over subsequences of σ . This notion is useful because in order to apply regression to a formula, one needs to knowhow many actions there are in each situation, i.e., how many regression steps to apply. A formula that mentions a situationvariable can be regressed provided that the variable is restricted to be a subsequence of some situation term with a knownnumber of actions in it. This intuitions are made precise below.1 (cid:12)t denotes a tuple of terms t1, . . . , tn .A. Gabaldon / Artificial Intelligence 175 (2011) 25–4829Fig. 1. Intuitively, that a formula is bounded by a situation term rooted at ρ, say by σ rooted at S0 (shown as a solid line in the tree of situations), meansthat (a) any quantified situation variable s in the formula is restricted to range over situations between S0 and σ (it must fall on the solid line, as depicted)and (b) any successor situation of s mentioned in the formula, say σ (cid:4)(cid:4)must be rootedat s. The formula may in turn have a subformula bounded by a situation term rooted at s, say σ (cid:4)(cid:4), which may quantify over variables as long as they fallon the solid line from S0 to σ (cid:4)(cid:4), and so on. A formula bounded by σ can be regressed because it is possible to determine the length of all its situationterms during the regression. For example, if we choose a value for s, we will know its length because we know the length of σ , and we will then know∗), for example, with a situation variable ranging over the situations on thethe length of σ (cid:4)(cid:4)dotted branches, cannot be regressed since it is not possible to put a bound on the length of s, must explicitly enumerate the actions that occur after s, i.e., σ (cid:4)(cid:4)as well. On the other hand, the formula (∃s∗)σ (cid:4) (cid:2) s∗ ∧ F (s∗.The following notation is used throughout: for n (cid:2) 0, we write do([α1, . . . , αn], ρ) to denote the term do(αn, do(αn−1, . . . ,do(α1, ρ) . . .)) of sort situation, where α1, . . . , αn are terms of sort action and ρ stands for a variable s of sort situation orthe constant S0. For such a situation term, we will refer to ρ as the root of the term. If n = 0, do([α1, . . . , αn], ρ) stands forthe root ρ. Also, for each i = 1, . . . , n, we say that the term do([α1, . . . , αi], ρ) is a prefix of do([α1, . . . , αn], ρ). If i < n thenwe say it is a proper prefix. For any term do([α1, . . . , αn], ρ), n (cid:2) 0, we say n is the length of the term.Definition 5 (Rooted situation terms). For n (cid:2) 0, let α1, . . . , αn be terms of sort action. A term do([α1, . . . , αn], s) is rooted ats iff s is the only (if any) variable of sort situation mentioned by α1, . . . , αn. A term do([α1, . . . , αn], S0) is rooted at S0 iffα1, . . . , αn mention no variables of sort situation.Recall that action functions may take terms of sorts object and action as arguments and that the language includes(cid:4)))), s) is a perfectly legal situation term.functional fluents, which may appear in these terms. For instance, do( A( f (do(B, sNotice that according to the above definition, this term is not rooted. The reason is that s is not the only variable the term(cid:4)).mentions, there is also sNext, we introduce the related notion of uniformly rooted formulas. These formulas have situation terms with a commonin the functional fluent term f (B, s(cid:4)root and thus, intuitively, their truth value is relativized to such a root.Definition 6 (Uniformly rooted formulas). Let ρ be the constant S0 or a variable of sort situation. The Lsitcalc formulas uniformlyrooted at ρ are inductively defined as follows:(1) If σ1, σ2 are terms of sort situation rooted at ρ, then σ1 (cid:2) σ2 is uniformly rooted at ρ;(2) If t1, t2 are terms of any sort all of whose subterms of sort situation are rooted at ρ, then t1 = t2 is uniformly rootedat ρ;(3) If W is a formula that does not mention terms of sort situation, then W is uniformly rooted at ρ;(4) If F (t1, . . . , tn, σ ) is a relational fluent atom, all terms of sort situation mentioned by t1, . . . , tn are rooted at ρ and σ isrooted at ρ, then F (t1, . . . , tn, σ ) is a formula uniformly rooted at ρ;(5) If W 1, W 2 are formulas uniformly rooted at ρ, then so are ¬W 1, W 1 ∧ W 2 and (∃v)W 1 provided v is different than ρ.3.1. Bounded and strictly bounded formulasWe define next the class of bounded and strictly bounded formulas of Lsitcalc upon which Non-Markovian Basic ActionTheories will be based. The following abbreviations will be very useful for writing this kind of formulas:(cid:2)(cid:2)∃s: σ (cid:4) (cid:2) σ (cid:4)(cid:4) (cid:2) σ∀s: σ (cid:4) (cid:2) σ (cid:4)(cid:4) (cid:2) σ(cid:3)(cid:3)W(cid:4)def= (∃s)def= (∀s)σ (cid:4) (cid:2) σ (cid:4)(cid:4) ∧ σ (cid:4)(cid:4) (cid:2) σ ∧ W(cid:4)(cid:2)σ (cid:4) (cid:2) σ (cid:4)(cid:4) ∧ σ (cid:4)(cid:4) (cid:2) σ(cid:3)⊃ W(cid:5).(cid:5),W(5)is rooted at s. Any (cid:2) may be replaced by (cid:15) or =. We will sometimes write (∃s: σ (cid:4)(cid:4) (cid:2) σ )W as a shorthand forHere, σ (cid:4)(cid:4)(∃s: S0 (cid:15) σ (cid:4)(cid:4) (cid:2) σ )W ((∀s)S0 (cid:15) s is a logical consequence of the foundational axioms Σ ).The regression operator as defined in [5,21] requires all terms of sort situation to be of the form do( (cid:12)α, S0). Intuitively,this allows determining how many iterations are required in order to regress a formula into one relative to S 0 only. Ourgoal is to generalize regression for formulas that refer to situations through quantified variables. Since it is not possibleto regress formulas with variables that refer to arbitrary situations, e.g. (∃s)F (s), we define a class of regressable formulasbased on the notion of bounded formulas, which we introduce below. Quantified situation variables are restricted in theseformulas in such a way that the number of regression steps remains bounded. Fig. 1 explains the intuition behind them.30A. Gabaldon / Artificial Intelligence 175 (2011) 25–48Fig. 2. Situation tree from Example 1. The existentially quantified variable s(cid:4)must be equal either to do(get_coffee, S0) (top tree) or to S 0 (bottom tree).Definition 7 (Bounded formulas). Let ρ be a situation variable or the constant S 0. The formulas of Lsitcalc bounded by asituation term rooted at ρ are the smallest set of formulas such that:(1) If W is an atom uniformly rooted at ρ, then W is bounded by a situation term rooted at ρ.(2) If(a) W is a propositional combination of formulas each bounded by a situation term rooted at s or at ρ,(b) σ (cid:4)does not mention variable s,(c) σ (cid:4)(cid:4)is rooted at s,(d) σ is rooted at ρ,then2 (∃s: σ (cid:4) (cid:2) σ (cid:4)(cid:4) (cid:2) σ )W is a formula bounded by a situation term rooted at ρ.(3) If W 1, W 2 are formulas bounded by situation terms rooted at ρ, then ¬W 1, W 1 ∧ W 2 and (∃v)W 1, where v is of sortaction or object, are formulas bounded by a situation term rooted at ρ.In the definition of bounded formulas above, no particular situation term σ is defined as the bound of a formula. Weonly say that a formula is bounded by “a situation term rooted at ρ.” The reason for this is that the situation terms arenot what is important, but the root ρ is. Indeed, in the last item of the definition, W 1, W 2 may have no situation term incommon other than ρ. But if each is bounded by a term rooted at ρ, that is enough to guarantee that the combinationbe bounded by a term rooted at ρ. Throughout the paper, we will often talk about a formula being bounded by a specificterm σ , usually one that occurs in the formula.The following example attempts to illustrate these definitions.Example 1. Suppose that σ denotes the following situation term:[get_coffee, deliver_coffee, gotoMailRm], S0(cid:2)do(cid:3)and consider the sentence:(cid:2)(∃a)∃s: S0 (cid:15) do(a, s) (cid:2) σ(cid:3)batteryCharged(cid:2)(cid:3)do(chargeBatt, s).Intuitively, this sentence says that there is a situation s strictly preceding σ , after which some action a occurs, and inwhich action chargeBatt would have successfully charged the battery. This sentence is bounded by a term rooted at S 0,in particular by σ . Indeed, all situation variables mentioned by it are restricted to range over subsequences of σ . ThesubformulabatteryCharged(cid:2)(cid:3)do(chargeBatt, s)is in turn bounded by a term rooted at s, do(chargeBatt, s). The existentially quantified variable s ranges over the subse-quences of do(get_coffee, S0). Notice that the subformula refers to the situation do(chargeBatt, s) which is not a prefix of σ .See Fig. 2 for a depiction of the situation tree of this example.In the above example, we showed that bounded formulas may refer to situations that do not directly lie on the boundingsequence of actions. This allows reasoning about what would have held if the evolution of the world had diverted in a2 As before, any (cid:2) may be replaced by (cid:15) or =.A. Gabaldon / Artificial Intelligence 175 (2011) 25–4831Fig. 3. In contrast to bounded formulas, in strictly bounded formulas the term σ (cid:4)(cid:4)situations.rooted at the quantified variable s must itself be one of σ ’s precedingdifferent direction starting from some past point. Another class of formulas with a further restriction will be useful laterfor defining Non-Markovian Basic Action Theories. Formulas in this class are only allowed to refer to situations that arepredecessors of the bounding situation. In terms of Fig. 1, situation variables would be restricted to the situations betweens and σ . They would not be allowed to deviate from this line as does σ (cid:4)(cid:4)in that figure. Formally, we introduce a strictversion of boundedness below.Definition 8 (Simple situation terms). A situation term do([α1, . . . , αn], s) is simple iff all the terms of sort situation mentionedby α1, . . . , αn are prefixes of do([α1, . . . , αn], s).Clearly, simple situation terms are rooted. The situation term(cid:2)do(cid:2)Af(cid:2)do(B, s)(cid:3)(cid:3), s(cid:3)is rooted but not simple since do(B, s) is not a prefix of it. The term(cid:2)do(cid:2)(cid:3)f (s)A, s(cid:3)is simple.Definition 9 (Strictly bounded formulas). Let σ be a simple situation term. The formulas of Lsitcalc strictly bounded by σ arethe smallest set of formulas such that:(1) If W is an atom whose terms of sort situation are all prefixes of σ , then W is strictly bounded by σ .(2) Ifis a simple situation term that does not mention variable s,is a simple situation term rooted at s, and(a) σ (cid:4)(b) σ (cid:4)(cid:4)(c) W is a propositional combination of formulas each strictly bounded by σ (cid:4)(cid:4)then3 (∃s: σ (cid:4) (cid:2) σ (cid:4)(cid:4) (cid:2) σ )W is a formula strictly bounded by σ .or by σ ,(3) If W 1, W 2 are formulas strictly bounded by σ , then ¬W 1, W 1 ∧ W 2 and (∃v)W 1, where v is of sort action or object,are formulas strictly bounded by σ .Clearly, the formula from Example 1, whose possible situation instances are shown in Fig. 2, is not a strictly boundedformula. If we replace the situation term do(chargeBatt, s) in that formula with do(a, s) we obtain the following formulawhich is strictly bounded:(cid:2)(∃a)∃s: S0 (cid:15) do(a, s) (cid:2) σbatteryCharged(cid:3)(cid:2)(cid:3)do(a, s).The following example shows that strictly bounded formulas are expressive enough to encode Past Linear Temporal Logicmodalities.formulas that capture the intuitive meaning of the past linear temporal logic connectives S (since),Example 2. In the Situation Calculus, referring to the past means referring to past situations. In this sense, one can write←(cid:3) (sometime in the←−! (previous) as follows (the ϕ’s below denote Situation Calculus formulas with a singlepast),free variable of sort situation that has been suppressed. ϕ[s] denotes a situation suppressed formula with a variable sreinstated):←(cid:4) (always in the past), and(ϕ1 S ϕ2)[s] def=(cid:2)(cid:4)∃s(cid:4) (cid:2) s: s(cid:3)(cid:6)(cid:2)ϕ2[s(cid:4)] ∧(cid:4)(cid:4)∀s(cid:4) (cid:2) s(cid:4)(cid:4) (cid:15) s: s(cid:3)(cid:5)(cid:7)(cid:4)(cid:4)(cid:4)s,ϕ13 Any (cid:2) may be replaced by (cid:15) or =.32A. Gabaldon / Artificial Intelligence 175 (2011) 25–48(cid:4)(cid:3)(cid:2)(cid:3): s∃s[s] def=(cid:2)←(cid:3) ϕ(cid:2)←(cid:4) ϕ: s(cid:3)(cid:2)(cid:2)←−[s] def= (∃a)!ϕ[s] def=∀s(cid:2)(cid:4)∃s(cid:4) (cid:2) s(cid:4) (cid:2) s(cid:4)sϕ(cid:2)a, s: do(cid:4)(cid:3)(cid:4)ϕ(cid:3)s(cid:4)(cid:4)(cid:4)(cid:5),(cid:5),(cid:3)(cid:3)(cid:4)(cid:5).(cid:4)sϕ= sIt is easy to see that the above formulas are strictly bounded.3.2. Non-Markovian Basic Action TheoriesWe are now ready to define action precondition axioms and successor state axioms for Non-Markovian Basic ActionTheories.Definition 10 (Action precondition axioms). An action precondition axiom is a sentence of the form:(cid:2)(cid:3)PossA(x1, . . . , xn), s≡ Π A(x1, . . . , xn, s),where A is an n-ary action function symbol and Π A(x1, . . . , xn, s) is a first order formula with free variables amongx1, . . . , xn, s that is bounded by a situation term rooted at s and does not mention the predicate symbol Poss.Example 3. Suppose that a robot works in a lab where there is a door that must not be opened if the temperature insidereached some dangerous level d after it was closed. The robot’s theory would include a precondition axiom:Poss(cid:2)(cid:3)open(Door), s(cid:2)(cid:2)∃s1: S0 (cid:15) do(cid:2)≡close(Door), s1∀a, s2 : s1 (cid:2) do(a, s2) (cid:15) s(∀s2: s1 (cid:2) s2 (cid:15) s)temp(Door, s2) < d.(cid:3)(cid:15) s(cid:3)a (cid:13)= open(Door) ∧(cid:3).Using the above temporal logic abbreviations plus the abbreviation occ(a)[s] def= (∃s(cid:4))do(a, s(cid:4)) = s we can put this formulain the following more readable form:(cid:2)(cid:2)(cid:2)(cid:3)Possopen(Door), s≡¬occ(cid:3)open(Door)∧ temp(Door) < d(cid:3)(cid:2)(cid:3)close(Door)[s].S occThe rhs of action precondition axioms is not required to be strictly bounded but only bounded, which allows referring tosituations branching away into “hypothetical futures.” For instance, the above axiom could include a condition saying thatafter the robot does open(Door) it should not be possible for a human or robot to do something to get the human hurt:Poss(open(Door), s) ≡ · · · ∧ ¬(∃a)hurt(person, do(a, do(open(Door), s))).Definition 11 (Successor state axioms). A successor state axiom for an (n + 1)-ary relational fluent F is a sentence of the form:(cid:2)(cid:3)x1, . . . , xn, do(a, s)F≡ ΦF (x1, . . . , xn, a, s),where ΦF (x1, . . . , xn, a, s) is a first order formula with free variables among x1, . . . , xn, a, s that is strictly bounded by s anddoes not mention the constant S0 nor the predicate symbol Poss.A successor state axiom for an (n + 1)-ary functional fluent fis a sentence of the form:(cid:2)(cid:3)x1, . . . , xn, do(a, s)f= y ≡ φ f (x1, . . . , xn, y, a, s),where φ f (x1, . . . , xn, y, a, s) is a first order formula with free variables among x1, . . . , xn, y, a, s that is strictly bounded by sand does not mention the constant S0 nor the predicate symbol Poss.The requirement that S0 not appear in the rhs of successor state axioms is a technical detail introduced to simplify theproofs and is not essential (after all, it is variables, not S0, which can cause trouble and require restrictions through notionslike bounded formulas). Moreover, it is still possible to express conditions on the initial situation by referring to it indirectly.For instance, a condition that P hold initially can be expressed as (∃s1: s1 (cid:2) s){P (s1) ∧ ¬(∃s2: s2 (cid:2) s1)True}.On the other hand, the condition that the rhs of successor state axioms be strictly bounded cannot be relaxed. Boundedbut not strictly bounded formulas can cause regression to fail. Consider the following successor state axioms:(cid:3)(cid:3),P(cid:2)(cid:2)(cid:2)(cid:3)(cid:4)(cid:3)≡do(a, s)(cid:2)(cid:3)do(a, s)≡Q∃s(cid:2)∃s(cid:4) (cid:2) s(cid:4) (cid:2) s: s(cid:4): sQ(cid:3)(cid:2)P(cid:2)do(cid:2)do[B1, B2, B3], s(cid:4)[C1, C2, C3], s(cid:4)(cid:3)(cid:3).Applying a few steps of regression to the atom P (do([ A1, A2], S0)), for instance, results in the atom Q (do([B 1, B2, B3],S0)) and this in turn is regressed into∨ P[B1, C1, C2, C3], S0(cid:2)do(cid:3)(cid:3)P(cid:2)(cid:2)(cid:2)do[C1, C2, C3], S0(cid:3)(cid:3).Clearly, regression is not working here since the situation terms will continue to lengthen. For action precondition axiomsthis problem does not occur because the predicate Poss is not allowed to appear on the rhs of these axioms.A. Gabaldon / Artificial Intelligence 175 (2011) 25–4833Example 4. Consider again the robot that works at a bio-research lab. One of the successor state axioms in its theory couldbe:(cid:2)polluted(cid:3)≡ polluted(mat, s) ∨mat, do(a, s)a = touch(mat) ∧ (∃loc).safetyLevel(loc, Low) ∧(cid:3)(cid:2)¬atLoc(DisinfSt) S atLoc(loc)[s].Definition 12 (Non-Markovian Basic Action Theories). A Non-Markovian Basic Action Theory D is a theory of Lsitcalc consistingof the following set of axioms:• The foundational axioms Σ .• A set of successor state axioms Dss as in Definition 10.• A set of action precondition axioms Dap as in Definition 11.• A set of unique names axioms for actions Duna.• A set of first order sentences DS0 that mention no situation terms other than S0 and represent the initial state of theworld.3.3. Two relativity propertiesIntuitively, a strictly bounded formula has the property that its truth value depends only on the past relative to thesituation that is the bound, i.e., its truth value depends only on the truth value of fluents throughout such a situation(history) and on situation independent predicates and functions. The following theorem confirms this intuition.(cid:4)be structures of Lsitcalc with the same domain Act for sort action, Obj for sort object and Sit for sort situation, andTheorem 1. Let S, Slet v be a variable assignment ranging over these domains. Furthermore, let φ be an Lsitcalc formula that is strictly bounded by σ , doesnot mention Poss, and whose only free variable of sort situation, if any, is the root of σ . If(cid:4)is the same;satisfy the foundational axioms Σ ;(1) S and S(cid:4)(2) S(3) the interpretation of all action functions and situation independent functions and predicates in S and S(cid:4) (cid:15) σ ) then(cid:4)), if S, v |(cid:17) (s(4) for each relational fluent F ((cid:12)x, s(cid:3)(cid:4)(cid:4)(cid:12)x, s, v |(cid:17) F;(cid:4)), if S, v |(cid:17) (s(cid:3)(cid:3)(cid:2)v((cid:12)x), v(5) for each functional fluent f ((cid:12)x, s(cid:4) (cid:2)v((cid:12)x), v(cid:4) (cid:15) σ ) then4S, v |(cid:17) F= f S(cid:12)x, sf S(cid:3)(cid:3)iff(cid:2)(cid:3)(cid:2)(cid:2)(cid:2)Sss(cid:4)(cid:4)(cid:4)(cid:4)is the same;thenS, v |(cid:17) φ iff(cid:4)S, v |(cid:17) φ.Intuitively, conditions (1)–(3) make sure the structures S, S(cid:4)the situation independent part of the language. Then conditions (4) and (5) require S, Sfluents at situations preceding σ . Then, according to the theorem, under these conditions structures S, Struth value of every formula φ that is strictly bounded by σ .coincide on the interpretation of the tree of situations andto coincide on the value of allcoincide on the(cid:4)(cid:4)Lemma 1. Let σ be a simple situation term, S, Ssatisfied. Let t be a term of any sort such that all its subterms of sort situation are prefixes of σ . Then, v S (t) = v S, and v be as in the statement of Theorem 1 and suppose the conditions (1)–(5) are(t).(cid:4)(cid:4)Proof. If t is a variable, the lemma is obvious. Suppose that t is not a variable. Suppose that v S (t) (cid:13)= v S(t). Then there mustbe a subterm g(r1, . . . , rn) of t such that v S (ri) = v S(ri), i = 1, . . . , n, and g S (v S (r1), . . . , v S (rn)) (cid:13)= g S(r1), . . . , v S(v S(rn)).If g is the function do, we get a contradiction by condition (2). If g is an action or a situation independent function, bycondition (3) we get a contradiction. Finally, if g is a functional fluent symbol, then its last argument must be a prefix of σ .Then by condition (5) we get a contradiction. (cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)Corollary 1. Let S, S(cid:4)and v be as in Lemma 1 above, and let σ (cid:4), σ be simple situation terms. ThenS, v |(cid:17) σ (cid:4) = σ iffS, v |(cid:17) σ (cid:4) (cid:2) σ iff(cid:4)(cid:4), v |(cid:17) σ (cid:4) = σ ;, v |(cid:17) σ (cid:4) (cid:2) σ .SSand4 v((cid:12)x) denotes v(x1), . . . , v(xn) where the xi ’s are the variables in (cid:12)x. v(xi ) is the value assigned to xi by the variable assignment v.34A. Gabaldon / Artificial Intelligence 175 (2011) 25–48Proof. Since both σ (cid:4)then follows from this and condition (1). (cid:4)and σ are simple situation terms, by Lemma 1 v S (σ (cid:4)) = v S(cid:4)(σ (cid:4)) and v S (σ ) = v S(cid:4)(σ ). The corollaryProof of Theorem 1. Let the structures S, Stheorem and suppose that the conditions (1)–(5) are satisfied.(cid:4), variable assignment v, and formula φ be as described in the statement of theThe proof is by induction on the syntactic structure of φ. We have the following cases:(1) Suppose φ is an atom of the form σ (cid:4) (cid:2) σ or σ (cid:4) = σ . Then by definition of strictly bounded formulas, all terms of sortsituation in σ (cid:4)must be prefixes of σ and hence σ (cid:4)is simple. The theorem then follows from Corollary 1.(2) Suppose φ is an atom of the form t1 = t2 where t1, t2 are terms of sort action or object. As before, all terms of sortsituation in t1, t2 must be prefixes of σ . The theorem then follows from Lemma 1.(3) Suppose φ is a situation independent relational atom P ((cid:12)t), where (cid:12)t are terms of sort action or object. Then all terms ofsort situation in (cid:12)t are prefixes of σ . The theorem then follows from Lemma 1 and condition (3).(4) Suppose φ is a relational fluent atom F ((cid:12)t, σ (cid:4)). Then all terms of sort situation in (cid:12)t, σ (cid:4)are prefixes of σ . The theoremthen follows from Lemma 1 and condition (4).(5) Suppose φ is a non-atomic formula of the form (∃s(cid:4)sitional combination of formulas each strictly bounded by σ (cid:4)except for mapping the variable ssituation terms. Thus by Corollary 1, S, v s |(cid:17) σ (cid:4)(cid:4) (cid:2) σ (cid:4) = σ iff SSuppose that S, v (cid:13)|(cid:17) (∃sand SSuppose that S, v |(cid:17) (∃ssubformula Wsubformula W(cid:4), v (cid:13)|(cid:17) φ and thus the theorem holds.(cid:4): σ (cid:4)(cid:4) (cid:2) σ (cid:4) = σ ). Then by the corollary, S(cid:4)(cid:4)to element s of Sit. By definition of strictly bounded formulas, σ (cid:4)(cid:4)(cid:4): σ (cid:4)(cid:4) (cid:2) σ (cid:4) = σ )W or (∃s(cid:4): σ (cid:4)(cid:4) (cid:2) σ (cid:4) (cid:2) σ )W ,5 where W is a propo-or by σ . Let v s be a variable assignment identical to vare simpleand σ (cid:4)(cid:4), v s |(cid:17) σ (cid:4)(cid:4) (cid:2) σ (cid:4) = σ , for any s.(cid:4)(cid:4), v (cid:13)|(cid:17) (∃s: σ (cid:4)(cid:4) (cid:2) σ (cid:4) = σ ). It follows that S, v (cid:13)|(cid:17) φ: σ (cid:4)(cid:4) (cid:2) σ (cid:4) = σ ). By induction, for each. Similarly, by induction, for each. It follows that the theorem holds.(6) For non-atomic formulas of the form ¬φ, φ1 ∧ φ2, and (∃u)φ (see item (3) of Definition 9) the theorem follows byof W that is strictly bounded by σ , we have S, v |(cid:17) W(cid:4)of W that is strictly bounded by σ (cid:4), we have S, v |(cid:17) W(cid:4)(cid:4), v |(cid:17) (∃s(cid:4)iff S, v |(cid:17) W(cid:4)iff S, v |(cid:17) W: σ (cid:4)(cid:4) (cid:2) σ (cid:4) = σ ). Then by the corollary S(cid:4)(cid:4)induction on the structure of φ. (cid:4)An important property of Markovian basic action theories, called Relative Satisfiability, says that if the initial databaseDS0 together with a set Duna of unique names axioms for actions is satisfiable, then adding the foundational axioms, Σ ,and any set of action precondition and successor state axioms, results in a satisfiable theory, provided the successor stateaxioms for functional fluents satisfy a consistency property (see Eq. (6) below).We prove next that satisfiability is also preserved after adding non-Markovian action precondition and successor stateaxioms to a satisfiable initial database with unique names axioms.Theorem 2 (Relative satisfiability). A Non-Markovian Basic Action Theory D is satisfiable iff Duna ∪ DS0 is satisfiable.Proof. Starting from a model M0 of Duna ∪ DS0 , we construct a model M of D.(1) Satisfying Σ :Let Act and Obj be the domains for sorts action and object, respectively, in M0. We define a structure M by completeinduction.(a) Let the same Act and Obj be the domains for sorts action and object in M. We define the domain Sit for sort situationas the set of all finite sequences of elements of Act. That is, if {α1, . . . , αn} ⊆ Act then [α1, . . . , αn] ∈ Sit.(b) Next define the interpretation of S0 and do in M as follows:S M0doM= [ ],(cid:2)(cid:3)α, [α1, . . . , αn]where α ∈ Act and [α1, . . . , αn] ∈ Sit.= [α1, . . . , αn, α],whenever σ is a proper prefix of σ (cid:4)(c) Define the interpretation of (cid:2) to be σ (cid:2)M σ (cid:4)It is easy to verify that M as defined so far satisfies the foundational axioms Σ .We continue by defining the interpretation of all the predicates other than Poss, whose interpretation is defined after-ward, and (cid:2) whose interpretation is already defined. We will also define now the interpretation of all functions, exceptfor do whose interpretation is given above. The predicates and functions include fluents, and so we need to provide aninterpretation with respect to all situations. This is where the use of a definition by complete induction is needed. Weuse induction on the length of the sequences and complete induction is required as the successor state axioms mayrefer to past situations. After giving such an interpretation, the only remaining step will be to define the interpretation.5 The proof is the same if the first (cid:2) is replaced with (cid:15) or =.A. Gabaldon / Artificial Intelligence 175 (2011) 25–4835of Poss, which will be straight forward since action precondition axioms do not themselves mention the Poss predicatein their rhs (see Definition 10).Let us proceed to define the interpretation under M of predicate and function symbols other than do, Poss, and (cid:2).(2) Interpretation of situation independent predicates and functions:For situation independent predicates and functions, the sort situation and its domain Sit are irrelevant and the domainsAct and Obj are the same in M as in M0. Thus, let M interpret situation independent predicates and functions just asthey are in M0. It follows that since M0 satisfies Duna so does M.(3) Interpretation of fluents:Let σ be a sequence in Sit and assume that for every variable assignment v that assigns σ to s, the following holds:(cid:4)) and assigns a value in Obj ∪ Act to every functionalif M, v |(cid:17) sfluent f ((cid:12)x, s(a) Interpretation of fluents in the initial situation:(cid:4) (cid:15) s then M, v interprets every relational fluent F ((cid:12)x, s(cid:4)).= σ . Let F be a relational fluent, f a functional fluent and v 0 aSuppose that σ is the empty sequence [ ]. Then S M0variable assignment for variables of sorts object and action (for either structure since they share domains for thesesorts). Define M such that:M, v 0 |(cid:17) F ((cid:12)x, S0)(cid:12)x[v 0], S Mf M0(cid:2)(cid:3)iff M0, v 0 |(cid:17) F ((cid:12)x, S0),(cid:2)= f M0(cid:12)x[v 0], S M00(cid:3).Recall that functional fluents range over sorts action or object. They cannot range over sort situation. Also, all thesentences in DS0 are uniform in S0. This and the fact that M0 satisfies DS0 implies that M is also a model of DS0 .(b) Interpretation of fluents in situations other than S0:Suppose that σ is the sequence [α1, . . . , αn], n (cid:2) 1.Let F be a relational fluent and let its successor state axiom be(cid:2)(cid:3)(cid:12)x, do(a, s)F≡ ΦF ((cid:12)x, a, s).(cid:4)).For every variable assignment v assigning σ to s we have by induction that if M, v |(cid:17) srelational fluents F ((cid:12)x, sFrom Theorem 1, it follows that M, v must assign a value to ΦF ((cid:12)x, a, s), which is strictly bounded by s and does notmention Poss. If M, v did not assign a value to this formula, then we could extend M so that it does assign a valuethat assigns a different value to ΦF ((cid:12)x, a, s), which would contradictto it, and construct another extended model Mthe theorem.Furthermore, since M satisfies the foundational axioms Σ , we have that M, v |(cid:17) s (cid:2) do(a, s), which implies thatM, v (cid:13)|(cid:17) do(a, s) (cid:15) s by the same axioms Σ . Thus M, v does not yet assign a value to F ((cid:12)x, do(a, s)).We can then define M to interpret F ((cid:12)x, do(a, s)) as follows:(cid:4) (cid:15) s then M, v interprets all(cid:4)M, v |(cid:17) F(cid:2)(cid:3)(cid:12)x, do(a, s)iff M, v |(cid:17) ΦF ((cid:12)x, a, s).The interpretation of functional fluents in situation do(a, s) is defined similarly. For each functional fluent f withsuccessor state axiom(cid:2)(cid:3)(cid:12)x, do(a, s)f= y ≡ φ f ((cid:12)x, y, a, s)and each variable assignment v assigning σ to s, define(cid:3)(cid:12)x, do(a, s)= y iff M, v |(cid:17) φF ((cid:12)x, y, a, s).M, v |(cid:17) f(cid:2)A similar argument to the one above shows that this is well defined. Furthermore, the functional fluent consistencyproperty which states that:Duna ∪ DS0(6)together with the fact that M satisfies Duna ∪ DS0 , guarantee that one and only one value y is assigned tof ((cid:12)x, do(a, s)) above.This completes the inductive definition of how M interprets fluents. By construction, M satisfies all successor stateaxioms.|(cid:17) (∀a, s, (cid:12)x).(∃ y)φ f ((cid:12)x, y, a, s) ∧(cid:3).φ f ((cid:12)x, y, a, s) ∧ φ f⊃ y = y∀ y, y(cid:12)x, y, a, s(cid:5),(cid:4)(cid:2)(cid:2)(cid:3)(cid:4)(cid:4)(cid:4)It remains to specify how M interprets Poss(a, s).(4) Interpretation of Poss(a, s):Consider an element α ∈ Act. There are two possible cases:(a) There is a variable assignment v such that v assigns α to a and there is an action function A((cid:12)x) such that M, v |(cid:17)a = A((cid:12)x).By definition, Dap includes an axiom Poss( A((cid:12)x), s) ≡ Π A((cid:12)x, s) and Π A((cid:12)x, s) does not mention predicate Poss. Hence,M already assigns a value to Π A((cid:12)x, s). We specify that(cid:3)(cid:2)M, v |(cid:17) PossA((cid:12)x), siff M, v |(cid:17) Π A((cid:12)x, s).Since M satisfies the unique names axioms for actions, the value assigned to Poss is unique.36A. Gabaldon / Artificial Intelligence 175 (2011) 25–48(b) For every variable assignment v that assigns α to a and every function A((cid:12)x), M, v (cid:13)|(cid:17) a = A((cid:12)x). In this case, anyvalue assigned to Poss(a, s) will satisfy the action precondition axioms.By construction, M satisfies all the action precondition and successor state axioms of D. This completes the proof ofrelative satisfiability. (cid:4)4. Regression of bounded formulasThe particular syntactic form of action precondition and successor state axioms is computationally advantageous. Theseaxioms are definitions: the right-hand side serves as the definition of the predicate on the left-hand side, and this makesthem exchangeable in a logically equivalent way. Reiter’s regression operator [5,21], R, exploits this property to provide aspecialized theorem proving mechanism for the Lsitcalc class of regressable formulas.In this section, we make two generalizations:• we define a strictly larger class of formulas that includes Reiter’s original class of regressable formulas;• we define a generalized operator for regressing these formulas and prove that it is sound and complete.The generalized class of regressable formulas is based on the notion of bounded formula defined earlier. This will allowus to apply regression with respect to Non-Markovian Action Theories. We remark, however, that even when the backgroundtheory consists of standard Markovian axioms, the generalized operator is useful since it allows regressing many formulaswhich are not regressable by the original operator. In particular, it will allow us to prove entailment of formulas thatmention the (cid:2) relation, which is not possible with the original regression operator. We make further comments on thisbelow.4.1. Regressable formulasWe start by generalizing the class of formulas on which the regression operator will be applicable.Definition 13 (Regressable formulas). A formula W of Lsitcalc is regressable iff(1) W is first order; and(2) W is bounded by a situation term rooted at S0 and has no free variables of sort situation; and(3) for every atom of the form Poss(α, σ ) mentioned by W , α has the form A(t1, . . . , tn) for some n-ary action functionsymbol A of Lsitcalc.Example 5. The original definition of regressable formulas requires all terms of sort situation to be rooted at S 0, does notallow quantifying over situations, nor the mention of predicate (cid:2), nor equality between situation terms.The above definition of regressable formulas also includes, for example, the following: Suppose that σ is a groundsituation term, e.g., a database transaction log or a ground plan. We can use regression to answer queries such as:• has block x always been on top of block y during (the execution of) σ ?(∀s: s (cid:15) σ )on(x, y, s);• is there an action that would have resulted in block x being on top of block y ever during σ ?(∃a)(∃s: s (cid:15) σ )on(cid:2)(cid:3)x, y, do(a, s);• same as the previous query, but also requiring that the action actually be executable:(∃a)(∃s: s (cid:15) σ )Poss(a, s) ∧ on(cid:2)(cid:3)x, y, do(a, s);• was action shoot ever possible during σ and would it have killed the turkey?(∃s: s (cid:15) σ )Poss(shoot, s) ∧ dead4.2. Generalized regression operator(cid:2)(cid:3)turkey, do(shoot, s).Let us proceed to generalize Reiter’s regression operator R for the above class of formulas. We assume henceforth,without loss of generality, that formulas have had their quantified variables renamed to be distinct from all free variables.We use W |t1t2to denote the formula obtained from W by replacing the term t1 with t2.Definition 14 (Prime functional fluent term). (See [21].) A functional fluent term is prime iff it has the form f ((cid:12)t, do([α1, . . . , αn],S0)) for n (cid:2) 1 and each of the terms (cid:12)t, α1, . . . , αn is uniform in S0.A. Gabaldon / Artificial Intelligence 175 (2011) 25–4837Situation Calculus terms without free variables of sort situation have the property of containing a prime functional fluent:Remark 1. (See [21].) Let g((cid:12)t, do(α, σ )) be an Lsitcalc term without free variables of sort situation, i.e., all its subterms ofsort situation are of the form do([α1, . . . , αn], S0), n (cid:2) 0. Then g((cid:12)t, do(α, σ )) mentions a prime functional fluent term.Definition 15 (Generalized regression operator). Let W be a regressable formula of Lsitcalc.(1) If W is an atom, then by the definition of regressable it is bounded by a situation term rooted at S 0 and from this andthe definition of bounded formulas, it follows that W must be uniformly rooted at S 0. Reiter’s regression operator asoriginally defined6 works for these formulas. For completeness we define the operator here anyway. By virtue of beingregressable, the atom W must be of one of the following forms:(a) An equality atom of the form(cid:5)1, . . . , α(cid:4)α(cid:4), S0If m = n = 0, R[W ] = true.If m (cid:13)= n, R[W ] = false.If m = n (cid:2) 1 then R[W ] = R[α(cid:4)1[α1, . . . , αn], S0= α1 ∧ · · · ∧ α(cid:4)(cid:2)= do= αm].do(cid:2)(cid:4)m(cid:3)(cid:3)m.(b) A (cid:2)-atom of the form(cid:5)(cid:2)(cid:4)1, . . . , α(cid:4)α(cid:4), S0dom(cid:3)(cid:2)(cid:2) do[α1, . . . , αn], S0(cid:3).If m = 0 and n (cid:2) 1, then R[W ] = true.If m (cid:2) n, then R[W ] = false.If 1 (cid:3) m < n, then R[W ] = R[α(cid:4)1= α1 ∧ · · · ∧ α(cid:4)m= αm].(c) An atom Poss(α, σ ) where α and σ are terms of sort action and situation respectively. By definition of regress-able formulas, the term α is of the form A((cid:12)t), where A is an action function symbol with a corresponding actionprecondition axiom Poss( A((cid:12)x), s) ≡ Π A((cid:12)x, s) in Dap . Then,(cid:5)Π A((cid:12)t, σ )R[W ] = R(cid:4).The remaining possible cases are the following:(d) An atom whose only situation term is S0 or a situation independent atom.Then R[W ] = W .(e) An atom that mentions a functional fluent term of the form(cid:2)(cid:4)(cid:12)tg(cid:2), doα(cid:4), σ (cid:4)(cid:3)(cid:3).Since it is an atom bounded by a situation term rooted at S0, by definition of bounded it must be uniformly rootedat S0. Hence, the atom does not mention any variables of sort situation and thus, by Remark 1, it must mention aprime functional fluent term f ((cid:12)t, do(α, σ )). This fluent term is such that α is uniform in S0 and σ is rooted at S0.Let f ((cid:12)x, do(a, s)) = y ≡ φ f ((cid:12)x, y, a, s) be this functional fluent term’s successor state axiom in Dss. Then,(cid:4)R[W ] = R(∃v).φ f ((cid:12)t, v, α, σ ) ∧ W(cid:8)(cid:8) f ((cid:12)t,do(α,σ ))v(cid:5),where v is a fresh new variable.(f) A relational fluent atom F ((cid:12)t, do(α, σ )) that contains no functional fluent terms.Let F ((cid:12)x, do(a, s)) ≡ ΦF ((cid:12)x, a, s) be this fluent’s successor state axiom in Dss.Then R[W ] = R[ΦF ((cid:12)t, α, σ )].(2) When W is a regressable formula of the form7 (∃s: σ (cid:4) (cid:2) σ (cid:4)(cid:4) (cid:2) σ )W(cid:4)or (∃s: σ (cid:4) (cid:2) σ (cid:4)(cid:4) = σ )W(cid:4)we have the followingsubcases:(a) Suppose W is a regressable formula of the form1, . . . , α(cid:4)α(cid:4)∃s: σ (cid:4) (cid:2) do(cid:2)(cid:2) do(cid:5), s(cid:2)(cid:4)m(cid:2)(cid:3)[α1, . . . , αn], S0(cid:3)(cid:3)(cid:4),Wwhere m (cid:2) 0.If m (cid:2) n, then R[W ] = false.If m < n, then(cid:4)(cid:2)(cid:4)(cid:2)R[W ] = RR(cid:2)(cid:4)(cid:2)(cid:4)∃s: σ (cid:4) (cid:2) do∃s: σ (cid:4) (cid:2) do1, . . . , α(cid:4)α(cid:4)1, . . . , α(cid:4)α(cid:4)mm(cid:3)(cid:3)(cid:5), s(cid:5), s(cid:2)(cid:4)(cid:2)(cid:4)= do(cid:2) doα1, . . . , αn−1α1, . . . , αn−1(cid:3)(cid:3)(cid:3)(cid:3)(cid:5), S0(cid:5), S0(cid:4)(cid:4)WW∨(cid:5)(cid:5).6 We are referring to the definition of the regression operator as it appears in [21], which is slightly more general than the definition given in [2].7 The definition of regression of the corresponding formulas with σ (cid:4) = σ (cid:4)(cid:4)instead of σ (cid:4) (cid:2) σ (cid:4)(cid:4)is defined in the same way.38A. Gabaldon / Artificial Intelligence 175 (2011) 25–48(cid:2)(cid:2)(cid:4)(b) Suppose W is a regressable formula of the form1, . . . , α(cid:4)α(cid:4)∃s: σ (cid:4) (cid:2) doWmwhere m (cid:2) 1. By the same argument as in the previous case, σ (cid:4)If m > n, then R[W ] = false.If m (cid:3) n, then[α1, . . . , αn], S0(cid:2)= do(cid:5), s(cid:3)(cid:3)(cid:3)(cid:4),is rooted at S0.(cid:4)(cid:2)(cid:2)(cid:4)1, . . . , α(cid:4)α(cid:4)∃s: S0 (cid:15) dom−1(cid:3)(cid:2)∧ σ (cid:4) (cid:2) do[α1, . . . , αn], S0(cid:3)(cid:5), s∧ W(cid:2)= do(cid:5)(cid:4),[α1, . . . , αn−1], S0(cid:3)(cid:3)where α(cid:4)(cid:4)(cid:3)(cid:2)R[W ] = Rα(cid:4)(cid:4)= αnm stands for α(cid:4)mm(cid:2)(cid:2)∃s: σ (cid:4) (cid:2) s = do|sdo([α1,...,αn−m],S0).8(cid:3)(cid:3)[α1, . . . , αn], S0(cid:4).W(c) Suppose W is a regressable formula of the formBy definition of bounded formulas, σ (cid:4)can only be introduced through the abbreviations (5). Hence, if σ (cid:4)be a free variable. This is not possible by definition of regressable, thus σ (cid:4)The regression is then defined as follows:R[W ] = R(cid:4)(cid:2)σ (cid:4) (cid:2) do[α1, . . . , αn], S0(cid:3)(cid:4)∧ W(cid:8)(cid:8)sdo([α1,...,αn],S0)(cid:5).does not mention the variable s. Moreover, quantifiers on situation variablesdoes mention a variable, then this variable mustmust be rooted at S0.(3) For the remaining possibilities, regression is defined as follows:R[¬W ] = ¬R[W ],R[W 1 ∧ W 2] = R[W 1] ∧ R[W 2].For a variable v of any sort other than situation:= (∃v)R[W ].(∃v)WR(cid:5)(cid:4)Example 6. Consider a sentence G(s) saying that at some point in the past relative to s, doing action putdown(x), for someblock x, would have made action stack( A, B) possible:(cid:2)G(s) def=(cid:4)∃s: S0 (cid:15) s(cid:4) (cid:15) s(cid:3)(∃x)Poss(cid:2)(cid:2)stack( A, B), doputdown(x), s(cid:3)(cid:3)(cid:4).Suppose that we want to determine whether G holds after executing the sequence [unstack(D, B), stack(D, A)], i.e., whetherD |(cid:17) G(cid:2)(cid:2)do(cid:2)(cid:3)(cid:3)(cid:3)stack(D, A), dounstack(D, B), S0.It is easy to check that G(do(stack(D, A), do(unstack(D, B), S0))) is regressable according to Definition 13. Applying re-gression to this formula yields the following:stack(D, A), do(cid:2)unstack(D, B), S0(cid:3)(cid:3)(cid:3)(cid:5)(cid:2)(cid:2)do(cid:4)G(cid:4)(cid:2)R=R(cid:4): S0 (cid:15) s(cid:4) (cid:15) do(cid:2)∃sstack(D, A), do(cid:2)(∃x)Poss(cid:2)(cid:3)(cid:3)(cid:3)unstack(D, B), S0(cid:2)stack( A, B), doputdown(x), s(cid:3)(cid:3)(cid:5)(cid:4)(cid:4)(cid:2)=R(cid:4)∃s: S0 (cid:15) s(cid:4)(cid:2)(cid:4)∃s: S0 (cid:15) s(cid:2)(cid:4) = do(cid:2)(cid:4) (cid:2) doR=RRR(cid:2)(cid:4)(∃x)Poss(cid:4)(cid:2)(cid:4)∃s: s(cid:4)(cid:2)(cid:4)∃s: s(cid:3)(cid:3)(cid:3)(by Case 3)(cid:2)unstack(D, B), S0(cid:2)stack( A, B), do(cid:2)putdown(x), s(cid:3)(cid:3)(cid:3)unstack(D, B), S0(cid:2)stack( A, B), doputdown(x), s∨(cid:3)(cid:3)(cid:5)(cid:3)(cid:3)(cid:5)(cid:4)(cid:4)stack(D, A), do(cid:2)(∃x)Possstack(D, A), do(cid:2)(∃x)Poss(cid:2)(cid:4)stack( A, B), do(cid:5)unstack(D, B), stack(D, A), putdown(x)(by Cases 2c, 2a), S0(cid:3)(cid:3)(cid:5)unstack(D, B), S0(cid:2)(cid:4) = do(cid:2)unstack(D, B), S0(cid:4) (cid:2) do(cid:3)(cid:3)(∃x)Poss(cid:3)(cid:3)(∃x)Poss(cid:2)(cid:2)(cid:2)stack( A, B), doputdown(x), s(cid:2)stack( A, B), doputdown(x), s(cid:4)(cid:4)∨(cid:3)(cid:3)(cid:5)∨(cid:3)(cid:3)(cid:5)8 Replacing s with do([α1, . . . , αn−m], S 0) is only necessary to comply with the definition of bounded formulas. In fact, the replacement would take placein subsequent regression steps if it were not done here.A. Gabaldon / Artificial Intelligence 175 (2011) 25–4839=RRRR=RRR(cid:2)(cid:2)(cid:4)(∃x)Poss(cid:4)(∃x)Poss(cid:4)(cid:4)(∃s: s(cid:4)(cid:2)∃s: s(cid:4)(cid:4)(∃x)Poss(cid:4)(∃x)Poss(cid:4)(∃x)Possstack( A, B), dostack( A, B), do(cid:4) = S0)(∃x)Poss(cid:3)(cid:4) (cid:2) S0(∃x)Poss(cid:2)(cid:2)(cid:2)stack( A, B), dostack( A, B), dostack( A, B), do(cid:2)(cid:4)(cid:2)(cid:4)(by Cases 2c, 2a)(cid:5)∨unstack(D, B), stack(D, A), putdown(x)(cid:5), S0unstack(D, B), putdown(x)(cid:3)(cid:3)(cid:5)(cid:2)(cid:4)∨putdown(x), s(cid:3)(cid:3)(cid:5)(cid:2)putdown(x), s, S0(cid:3)(cid:3)(cid:5)(cid:3)(cid:3)(cid:5)∨(cid:4)(by Cases 2c, 2a)(cid:5)∨unstack(D, B), stack(D, A), putdown(x)(cid:5)unstack(D, B), putdown(x)putdown(x), S0(cid:3)(cid:3)(cid:5)., S0, S0(cid:3)(cid:3)(cid:5)(cid:3)(cid:3)(cid:5)∨(cid:2)stack( A, B), do(cid:2)stack( A, B), do(cid:2)(cid:4)(cid:2)(cid:4)(cid:2)The remaining steps are the same as with Reiter’s original regression operator.4.3. Correctness of regressionOur proof of correctness of operator R is based on the proof of correctness of the original regression operator [21]. Themain technical difficulty here is that with Non-Markovian Action Theories and the generalized regressable formulas, duringregression situation terms can grow “longer” before they start “shrinking” down to S 0, which makes the induction a bitmore complicated.Theorem 3. Suppose W is a regressable formula of Lsitcalc and D is a basic Non-Markovian Action Theory. Then,(1) R[W ] is a formula uniform in S0.(2) D |(cid:17) (∀).W ≡ R[W ].Proof. The proof is by induction based on an ordering relation ≺ on tuples of integers. We start by defining this ordering.Let Λ be the set of all countably infinite sequences of natural numbers with a finite number of nonzero elements. Definethe binary relation ≺ on this set as the reverse lexicographic ordering:(λ1, λ2, . . .) ≺λ(cid:4)1, λ(cid:4)2, . . .ifffor some m, λm < λ(cid:4)m, and for all n > m, λn = λ(cid:4)n.(cid:2)(cid:3)The set Λ satisfies well ordering. Next, overload ≺ by defining the following lexicographic ordering on Λ × N:(cid:4)and λ ≺ λor n = n(λ, n) ≺n < n(cid:2)λ, niff(cid:3).(cid:4)(cid:4)(cid:4)(cid:4)Clearly, any subset of Λ × N has a minimal element and so ≺ provides a well-ordering on this set. It is worth remarkingthat the ordering priority in tuple elements increases from left to right.Before we define our mapping from Lsitcalc regressable formulas to tuples in Λ × N we need the following notions.If g(t1, . . . , tn) is an Lsitcalc term, then t1, . . . , tn are said to be proper subterms of g(t1, . . . , tn). An occurrence of a situationterm in an Lsitcalc formula W is said to be maximal iff its occurrence is not as a proper subterm of some situation term.Intuitively, the occurrence of all terms do([α1, . . . , αi], σ ), i = 0, . . . , n − 1, in a term do([α1, . . . , αn], σ ) are not maximalsince each is a proper subterm of do([α1, . . . , αi+1], σ ).For a regressable formula W , let L(W ) be the sum of the length of σ for each occurrence of σ in W such that:• σ is a term of sort situation rooted at a situation variable;• the occurrence of σ in W is maximal;• if the occurrence is in a quantifier expression (Q s: σ (cid:4) (cid:2) σ (cid:4)(cid:4) (cid:2) σ ), then its length is larger than the length of σ (cid:4)(cid:4).We are now ready to define the mapping. Define index(W ) to be:index(W ) def=(cid:2)(C, E, I, λ1, λ2, . . .), P,(cid:3)where(1) C is the number of connectives and quantifiers,(2) E is the number of equality atoms between situation terms,(3) I is the number of (cid:2)-atoms,(4) for m (cid:2) 1, λm is the number of maximal occurrences in W of situation terms of length m − L(W ) that are rooted at S 0,(5) P is the number of Poss atoms mentioned by W .Notice that the λ’s here are “shifted” to the right a number L(W ) of places. In other words, if one maximal term oflength k occurs in W , then λk+L(W ) = 1. The reason behind this is that after a regression step on a formula with a situationvariable, it is possible that a situation term that mentions such a variable be replaced by a longer one. For instance, theformula (∃s: s = do( A, S0))P (do(B, s)) which has λ1 = 0, λ1+1 = 1, would be regressed into P (do([ A, B], S0)) which also has40A. Gabaldon / Artificial Intelligence 175 (2011) 25–48λ1 = 0, λ0+2 = 1. Without the shift of the λ’s, the former formula would have λ1 = 1, λ2 = 0 while the latter would havethe same λ1 = 0, λ0+2 = 1. Thus the index of the first formula would precede the index of the second one, which has beenregressed one step. With the shifted λ’s, the precedence in this case is decided based only on the number of connectivesand quantifiers.Let us proceed with the proof. Consider a regressable formula W and assume the theorem for all regressable formulaswith index ≺ index(W ).(1) Suppose that W is a regressable atom. Then W is an atom bounded by a situation term rooted at S 0 and has no freevariables of sort situation. By definition of bounded formulas, W is uniformly rooted at S 0. This implies that L(W ) = 0.We have the following cases:(a) Suppose that W is an equality atom of the form(cid:5)(cid:2)[α1, . . . , αn], S0, S0This atom is regressed into true if m = n = 0, false if m (cid:13)= n. Otherwise, we have that= αm= α1 ∧ · · · ∧ α(cid:4)1, . . . , α(cid:4)α(cid:4)R[W ] = R(cid:4)α(cid:4)= do(cid:5).do(cid:2)(cid:4)m(cid:3)(cid:3).1m∗∗∗m= αm.= α1 ∧ · · · ∧ α(cid:4)is bounded by a situation term rooted at S0 and thus regressable.differs from the index of W in that λm is smaller by at least two in index(W= αi is also uniformly rooted at S0 and hence that the conjunction WIn the former two cases, the theorem follows immediately. Consider the case where m = n (cid:2) 1 and let Wα(cid:4)1Since W is a regressable atom, it is bounded by a situation term rooted at S 0, and therefore uniformly rooted at S0.This implies that each α(cid:4)is uniformly rootediat S0. Therefore WThe index of Wber P and all other λi remain the same. For instance, if αi ’s and α(cid:4)index(WThus index(WAlso from the induction hypothesis, we have that D |(cid:17) (∀)Wing entailment from the foundational axioms Σ := αm.∗ ≡ R[W∗) while the num-j ’s do not mention any situation terms, then∗) ≺ index(W ). Hence, by the induction hypothesis, we have that R[W ] = R[W∗) = ((m, 0, 0, 0, . . .), 0) and index(W ) = ((0, 1, 0, 0, . . . , 2, 0, . . .), 0).∗]. Furthermore, it is easy to prove the follow-∗] = R[W ] as wanted.∗] is uniform in S0.Σ |(cid:17) (∀)W ≡ α(cid:4)∗ ≡ R[Wstand for∗= α1 ∧ · · · ∧ α(cid:4)mTherefore we have that D |(cid:17) (∀).W ≡ W(b) Suppose that W is a (cid:2)-atom of the form1(cid:2)(cid:4)do1, . . . , α(cid:4)α(cid:4)m(cid:3)(cid:5), S0(cid:2)(cid:2) do[α1, . . . , αn], S0(cid:3).(cid:5).When m = 0 and n (cid:2) 1, R[W ] = true; and when m (cid:2) n R[W ] = false. In both of these cases the theorem followsimmediately from Σ |(cid:17) (∀)W ≡ true (false, respectively).In the remaining case, when 1 (cid:3) m < n, we have that(cid:4)α(cid:4)1stand for α(cid:4)1R[W ] = R∗= α1 ∧ · · · ∧ α(cid:4)= α1 ∧ · · · ∧ α(cid:4)Let Wabove. By the same argument as in the equality case, Win that λm and λn decrease by at least one in index(WPoss-atoms, P , is zero in both cases. The number of (cid:2)-atoms, I , is also smaller by one in index(Wof connectives, C , increases but, being the leftmost element, it has the lowest priority. Clearly, then, index(Windex(W ). Furthermore, it is easy to prove the entailment:[α1, . . . , αn], S0= αmm= αm. The proof proceeds in a similar way as in the case of equality atoms∗) differs from index(W )is regressable. The index(W∗). Other λ values remain the same and the number of∗). The number∗) ≺Σ |(cid:17) (∀).do(cid:2)(cid:2) do(cid:5), S0≡ W(cid:2)(cid:4)(cid:3)(cid:3)m∗∗1, . . . , α(cid:4)α(cid:4)mAs in the previous case, we have by induction that D |(cid:17) (∀).Wfrom this and the above entailment..∗ ≡ R[W∗] = R[W ], and finally the theorem follows(c) Suppose W is a regressable atom of the form Poss(α, σ ) for terms α and σ of sorts action and situation respectively.Then α must be of the form A((cid:12)t) and there must be a corresponding action precondition axiom Poss( A((cid:12)x), s) ≡Π A((cid:12)x, s) in D. After suitably renaming variables if necessary, we have thatD |(cid:17) (∀).W ≡ Π A((cid:12)t, σ ).(7)By definition, Π A((cid:12)x, s) does not mention predicate Poss. Therefore, index(Π A((cid:12)t, σ )) ≺ index(W ). (Recall that in thedefinition of index(W ), the number P of Poss-atoms is the rightmost element, and the ordering priority increasesfrom left to right.)Moreover, since Poss( A((cid:12)t), σ ) is a regressable atom, σ and all terms of sort situation mentioned by (cid:12)t must be rootedat S0. From this and the fact that Π A((cid:12)x, s) is by definition bounded by a situation term rooted at s, it follows thatΠ A((cid:12)t, σ ) is regressable. Therefore, by induction, R[Π A((cid:12)t, σ )] is uniform in S0 and(cid:5)Π A((cid:12)t, σ ).By definition, R[W ] = R[Π A((cid:12)t, σ )]. The theorem follows from this, (7) and (8).D |(cid:17) (∀).Π A((cid:12)t, σ ) ≡ R(8)(cid:4)A. Gabaldon / Artificial Intelligence 175 (2011) 25–4841(d) The remaining cases when W is an atom are the following:(i) Suppose W is an atom that does not mention any terms of sort situation or whose only term of this sort is S 0.Then W is uniform in S0. Hence R[W ] = W by definition of regression and the theorem is immediate. Notethat for such a W , index(W ) = ((0, . . .), 0).(ii) Suppose W is an atom that mentions a functional fluent term. Since W is regressable, it has no free variablesof sort situation and hence, by Remark 1, it mentions a prime functional fluent term f ((cid:12)t, do(α, σ )). Let thesuccessor state axiom corresponding to this fluent be:(cid:2)(cid:3)(cid:12)x, do(a, s)f= y ≡ φ f ((cid:12)x, y, a, s).Assuming suitable variable renaming, it is easy to see that(cid:8)(cid:8) f ((cid:12)t,do(α,σ ))yD |(cid:17) (∀).W ≡ (∃ y).φ f ((cid:12)t, y, α, σ ) ∧ W.(9)∗∗∗is regressable and that index(Wdenote the rhs of the above equivalence. Let us show that W∗) ≺Let Windex(W ). First, since W is an atom and it is bounded by a situation term rooted at S 0, then σ must be rootedat S0. Since, by definition of successor state axioms, φ f ((cid:12)x, y, a, s) is bounded by s, Wis bounded by a situationterm rooted at S0 and hence is regressable.Second, φ f ((cid:12)x, y, a, s) does not mention the predicate Poss, so the number of Poss-atoms P is zero for both. Further, since f ((cid:12)t, do(α, σ )) is a prime functional fluent term (see Definition 14), the only termW and Wof sort situation mentioned by (cid:12)t, α is S0. Thus replacing f ((cid:12)t, do(α, σ )) in W does not change any of the λvalues except for λk+1+L(W ), where k + 1 is the length of do(α, σ ), which decreases. By definition of successorstate axioms, φ f ((cid:12)x, y, a, s) is strictly bounded by s and does not mention the constant S0. Then all terms ofsort situation mentioned by φ f ((cid:12)t, y, α, σ ) which are different from σ are rooted at a situation variable. Thismeans that the conjunct (∃ y).φ f ((cid:12)t, y, α, σ ) contributes only to one λ value, namely to λk+L(W ), which haslower ordering priority than λk+1+L(W ). Therefore, index(WAs an example, consider the atom f (do(B, do( A, S0))) = c and a successor state axiom(cid:4)∗) ≺ index(W ).(cid:3)(cid:2)(cid:3)(cid:2)∗(cid:4)(cid:2)(cid:3)do(a, s)f= y ≡∃s(cid:4) (cid:2) s: sPy, s.In the case of this W ,(cid:2)and for Windex(W ) =(cid:4)∗ = (∃s(cid:3)(cid:2)∗index(0, 0, 0, 0, . . . , λ1 = 0, λ2 = 1, 0, . . .), 0(cid:4) (cid:2) do( A, S0))P ( y, s: s(cid:2)(1, 0, 1, 0, . . . , λ1 = 1, λ2 = 0, 0, . . .), 0(cid:4)) we have=(cid:3).(cid:3)W∗) ≺ index(W ).Thus index(WBy induction, then, R[W∗], and (9).R[Wcorresponding to this fluent be:(cid:2)(cid:3)(cid:12)x, do(a, s)F≡ ΦF ((cid:12)x, a, s).Assuming suitable variable renaming as before, we have thatD |(cid:17) (∀).W ≡ ΦF ((cid:12)t, α, σ ).∗] is uniform in S0 and D |(cid:17) (∀).W∗ ≡ R[W∗]. The theorem follows from this, R[W ] =(iii) Suppose otherwise that W is a relational fluent atom of the form F ((cid:12)t, do(α, σ )). Let the successor state axiom∗∗denote the rhs of the above equivalence. We need to show that WLet Windex(W ).Since F ((cid:12)t, do(α, σ )) is regressable, σ and all the terms of sort situation mentioned by (cid:12)t and α must be rootedat S0. Since, by definition, ΦF ((cid:12)x, a, s) is bounded by s, ΦF ((cid:12)t, α, σ ) is bounded by σ , which is rooted at S0, andtherefore regressable.Now, by definition, ΦF ((cid:12)x, a, s) does not mention the predicate Poss nor constant S0. Since F ((cid:12)t, do(α, σ )) isa regressable atom, all subterms of sort situation of (cid:12)t, α and σ are uniformly rooted at S0. Moreover, sinceΦF ((cid:12)x, a, s) is strictly bounded by s, it follows that all terms of sort situation mentioned by ΦF ((cid:12)t, α, σ ) eitherappear in (cid:12)t, α and σ or are rooted at a situation variable. Therefore, index(WAs an example, consider the atomis regressable and that index(W∗) ≺ index(W ).(10)∗) ≺(cid:2)Fg(cid:3)(cid:2)do(C, S0)(cid:2), doB, do( A, S0)(cid:3)(cid:3)and the successor state axiom F (x, do(a, s)) ≡ P (x, s).In the case of this W ,(cid:2)(cid:3)index(W ) =(0, 0, 0, λ1 = 1, λ2 = 1, 0, . . .), 042A. Gabaldon / Artificial Intelligence 175 (2011) 25–48and for W∗ = P (g(do(C, S0)), do( A, S0)) we have(cid:2)(cid:3)(cid:2)(cid:3)indexW∗=By induction, R[WR[W∗], and (10).(0, 0, 0, λ1 = 2, λ2 = 0, 0, . . .), 0.∗] is uniform in S0 and D |(cid:17) (∀).W∗ ≡ R[W∗]. The theorem follows from this, R[W ] =(2) When W is a regressable non-atomic formula, we have the following possible cases:(a) Suppose W is a regressable formula of the form1, . . . , α(cid:4)α(cid:4)∃s: σ (cid:4) (cid:2) do(cid:2)(cid:2) do, s(cid:2)(cid:4)m(cid:2)(cid:3)(cid:5)[α1, . . . , αn], S0(cid:3)(cid:3)(cid:4).WIf m (cid:2) n, then R[W ] = false. Then the theorem follows immediately from D |(cid:17) W ≡ false.If m < n, the it is easy to prove thatD |(cid:17) (∀).W ≡ W 1 ∨ W 2,(11)(12)(14)wheredef=W 1(cid:2)(cid:2)∃s: σ (cid:4) (cid:2) do∃s: σ (cid:4) (cid:2) do(cid:2)(cid:4)(cid:2)(cid:4)def=α(cid:4)1, . . . , α(cid:4)1, . . . , α(cid:4)α(cid:4)m(cid:3)(cid:3)(cid:5), s(cid:5), s(cid:2)= do(cid:2)(cid:2) do[α1, . . . , αn−1], S0(cid:3)(cid:3)(cid:3)(cid:3)(cid:4),W(cid:4)mW 2[α1, . . . , αn−1], S0(13)Clearly, both W 1 and W 2 are regressable. It is also clear that L(W ) = L(W 1) = L(W 2). Since λn+L(W ) is smaller inindex(W 1) and index(W 2) than in index(W ) and the values λi , i > n + L(W ), are identical as is the number of Possatoms, we have that index(W 1) ≺ index(W ) and similarly index(W 2) ≺ index(W ).By the induction hypothesis R[W 1] and R[W 2] are both uniform in S0, D |(cid:17) (∀).R[W 1] ≡ W 1, and D |(cid:17)(∀).R[W 2] ≡ W 2. The theorem follows from this, R[W ] = R[W 1] ∨ R[W 2] and (11).W.(b) Suppose W is a regressable formula of the form(cid:2)∃s: σ (cid:4) (cid:2) s = do[α1, . . . , αn], S0(cid:3)(cid:3)W(cid:2).(cid:4)It is easy to see that, after suitable variable renaming,(cid:8)(cid:8)sdo([α1,...,αn],S0).[α1, . . . , αn], S0(cid:2)D |(cid:17) (∀).W ≡ σ (cid:4) (cid:2) do∗∧ W(cid:3)(cid:4)(cid:4)∗∗is regressable.∗) ≺ index(W ). Clearly Wmust be rooted at S0. Moreover, since Wstand for the rhs of the above equivalence. By definition of regression, R[W ] = R[W∗]. As we show inis a propositional combination of formulas(cid:4)|sdo([α1,...,αn],S0) is bounded by a situation term rootedLet Witem (2) of Definition 15, σ (cid:4)each bounded by a situation term rooted at S0 or at s, then Wat S0. Therefore, WLet us show that index(Wthat the λ values are the same for both formulas. Consider a maximal term do( (cid:12)α1, s) from Wlength. Let do( (cid:12)α2, S0) stand for do([α1, . . . , αn], S0) and Wof the value λ that accounts for term do( (cid:12)α2, S0) in index(W ) and n + m + L(Waccounts for do( (cid:12)α1, do( (cid:12)α2, S0)). Also, since L(Wthe substitution that results in W∗) have the same λ’s.at s, index(W ) and index(WFrom the above argument it follows that index(W∗). Therefore, index(Wwhich is smaller in index(WThen, by induction, R[W∗], and (14).R[Wcontains the same number P of Poss atoms as W . Let us showand let m be its(cid:4)|do(α1,s)do(α1,do(α2,S0)). Note that n + L(W ) is the index(cid:4)(cid:4)) the index of the value λ that(cid:4)(cid:4)). This implies that afterthe λ’s are the same. Since this is true after the substitution of any term rooted∗) differs from index(W ) only in the number of equality atoms, E,∗) ≺ index(W ).∗]. The theorem follows from this, R[W ] =(cid:4)(cid:4)) = L(W ) − m, n + L(W ) = n + m + L(W∗] is uniform in S0 and D |(cid:17) (∀).W∗ ≡ R[Wfor W(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:2)(cid:2)(cid:4)∃s: σ (cid:4) (cid:2) do(c) Suppose W is a regressable formula of the form1, . . . , α(cid:4)α(cid:4)where m > 1 (otherwise we are in the previous case).If m > n, R[W ] = false by definition and, clearly, D |(cid:17) W ≡ false. The theorem then is immediate.For m (cid:3) n, it is easy to prove that[α1, . . . , αn], S0(cid:2)= do, s(cid:3)(cid:3)Wm(cid:3)(cid:5),(cid:4)(cid:2)(cid:3)(cid:2)(cid:4)D |(cid:17) (∀).W ≡(cid:3)(cid:5)α(cid:4)1, . . . , α(cid:4)∃s: do, s(cid:3)(cid:2)∧ σ (cid:4) (cid:2) do[α1, . . . , αn], S0|sdo([α1,...,αn−m],S0).(cid:2)α(cid:4)(cid:4)= αnm stands for α(cid:4)denote this formula. By definition of regression, R[W ] = R[W[α1, . . . , αn−1], S0,(cid:2)= do(cid:4)∧ Wm−1mm∗where α(cid:4)(cid:4)Let Wis rooted at S0, and thus theLet us show that Wconjunct σ (cid:4) (cid:2) do([α1, . . . , αn], S0) is uniformly rooted at S0. Since W is bounded by a situation term rooted at S0,do([α(cid:4)m are], s) must be rooted at s. This means that all the terms of sort situation mentioned by the α(cid:4)(cid:4)is regressable. For the same reason as in the previous case, σ (cid:4)1, . . . , α(cid:4)∗].m∗(cid:3)(cid:3)(15)A. Gabaldon / Artificial Intelligence 175 (2011) 25–4843∗m. Clearly, the number of Poss atoms is the same in W and W= αn is also uniformly rooted at S0. Finally, Wrooted at S0 and therefore that the conjunct α(cid:4)(cid:4)is a propositionalcombination of formulas each bounded by a situation term rooted at S 0 or at s. Hence formula (15) is bounded bya situation term rooted at S0 and therefore regressable.Consider next the index of Wthere are two possible cases:• Suppose that all the terms of sort situation mentioned by α(cid:4)L(W ), the lengths of the terms in α(cid:4)such term in α(cid:4)has length n − m + m − k = n − k.We thus have that n + L(W ) = n + L(W(by one) than in index(W ). All λi , i > n + L(W ), are equal for either formula. Therefore, index(Wm are of length smaller than m. Then, by definition of∗) = L(W ). Let σ be anydo([α1,...,αn−m],S0) in α(cid:4)(cid:4)∗) and that λn+L(W ) is smaller in index(W∗)∗) ≺ index(W ).m and let m − k, m (cid:2) k > 0, be its length. Then the corresponding term σ |sm are not included in L(W ). This implies that L(W∗) > n −k + L(W ) = n −k + L(W. Based on L(W∗),m∗(cid:4)∗) = L(W ) − m − k. The corresponding term σ |sm mentions terms of sort situation of length at least m. For simplicity, assume there is only onesuch term, σ , and let its length be m+k, k (cid:2) 0. Then, by definition of L(W ), the length of σ was included in L(W ).do([α1,...,αn−m],S0) in α(cid:4)(cid:4)m has length n − m + m + k = n + k.Hence L(W∗)We thus have that n + k + L(W∗) all λi , i > n + L(W ) are equal for either formula. Itbut λn+L(W ) is smaller. Since n > n − m and L(W ) > L(W∗) ≺ index(W ).follows that index(W∗) = n + k + L(W ) − m − k = n − m + L(W ). Then, λn−m+L(W ) is larger in index(W∗] is uniform in S0 and D |(cid:17) (∀).W∗ ≡ R[W∗]. The theorem follows from this,• Suppose that α(cid:4)Therefore, by induction, R[WR[W ] = R[W∗], and (15).(3) The cases when W is a regressable formula of the forms ¬W 1, W 1 ∧ W 2 and (∃v)W 1 are straightforward. (cid:4)Soundness and completeness of the regression operator R follows from Theorems 2 and 3:Theorem 4. Suppose W is a regressable sentence of Lsitcalc and D is a basic non-Markovian theory of actions:D |(cid:17) W iff DS0∪ Duna |(cid:17) R[W ].As is the case with Markovian theories, this theorem is computationally very important. It tells us that, for the classof regressable formulas, we can prove that a Basic Action Theory entails a formula by first applying regression, a purelysyntactic procedure, and then proving that the initial database plus unique names axioms entail the regressed formula. Inparticular, it tells us that for the second part, proving entailment of the regressed formula, the only second order axiom inthe Basic Action Theory, i.e. the induction axiom, is no longer relevant.5. ImplementationIn this section we present an implementation in Prolog of a bounded formula evaluator. The evaluator is of course basedon regression, but instead of computing a regressed formula uniform in S 0, it actually evaluates it against a backgroundaction theory and initial (Prolog) database and returns the answer.Bounded formulas are encoded as Prolog terms of the following forms:somes(sit-var, lower-bnd, upper-bnd, W)alls(sit-var, lower-bnd, upper-bnd, W)corresponding to formulas of the form (∃s1: ssit-var is the quantified variable of sort situation, s1. The arguments lower-bnd and upper-bnd correspond to sand s1 ∼ s, respectively, where ∼ stands for either of =, (cid:2), or (cid:15). The third argument is the subformula W .(cid:4) ∼ s1 ∼ s)W , respectively. The first argument(cid:4) ∼ s1(cid:4) ∼ s1 ∼ s)W and (∀s1: sBounded Formula Regression Evaluator%%%%% (Case 1) %%%%%%% Equality between situations and <-atomsregr(s0 =$= s0).regr(do(A,S) =$= do(A,S)).regr(S1 << do(_,S)):- regr(S1 =$= S) ; regr(S1 << S).regr(S1 <<= S):- regr(S1 =$= S) ; regr(S1 << S).%% Poss, fluent, and situation independent atomsregr(W):- isAtomEx(W), W.%% case Sv is already a Prolog variable44A. Gabaldon / Artificial Intelligence 175 (2011) 25–48regr(somes(Sv,S1 =$= Sv, Sv =$= S2,W)):-var(Sv), !, Sv=S2,regr(S1 =$= S2 & W).regr(somes(Sv,S1 << Sv, Sv =$= S2,W)):-var(Sv), !, Sv=S2,regr(S1 << S2 & W).regr(somes(Sv,S1 <<= Sv, Sv =$= S2,W)):-var(Sv), !, Sv=S2,regr(S1 <<= S2 & W).%%%%% (Case 2) %%%%%% (2a)regr(somes(Sv,LBound,Sm <<= Sn,W)):- !,(regr(somes(Sv,LBound, Sm =$= Sn,W)) -> true ;regr(somes(Sv,LBound, Sm << Sn,W))).regr(somes(Sv,LBound,Sm << do(_,Sn),W)):- !,(regr(somes(Sv,LBound, Sm =$= Sn,W)) -> true ;regr(somes(Sv,LBound, Sm << Sn,W)) ).%% (2b)regr(somes(Sv, S1 =$= do(A,S), do(A,S) =$= do(A,S2),W)):- !,regr(somes(Sv,s0 <<= S, S =$= S2, (S1 =$= do(A,S2)) & W)).regr(somes(Sv,S1 << do(A,S), do(A,S) =$= do(A,S2),W)):- !,regr(somes(Sv,s0 <<= S, S =$= S2, (S1 << do(A,S2)) & W)).regr(somes(Sv,S1 <<= do(A,S), do(A,S) =$= do(A,S2),W)):- !,regr(somes(Sv,s0 <<= S, S =$= S2, (S1 <<= do(A,S2)) & W)).%% (2c)% Sv is a constant representing a sitcalc variableregr(somes(Sv,S1 =$= Sv, Sv =$= S2,W)):-sub(Sv,SNew,W,W1) ,SNew = S2,regr(S1 =$= S2 & W1).regr(somes(Sv,S1 << Sv, Sv =$= S2,W)):-sub(Sv,SNew,W,W1),SNew = S2,regr(S1 << S2 & W1).regr(somes(Sv,S1 <<= Sv, Sv =$= S2,W)):-sub(Sv,SNew,W,W1),SNew = S2,regr(S1 <<= S2 & W1).%% (Case 3)regr(-(S1 =$= S)):- not regr(S1 =$= S).regr(-(S1 << S)):- not regr(S1 << S).regr(- somes(Sv,LBound, UBound,W)):- not regr(somes(Sv,LBound,UBound,W)).regr(alls(Sv,LBound, UBound, W)):- regr(-somes(Sv,LBound,UBound,-W)).regr(-alls(Sv,LBound, UBound, W)):- regr(somes(Sv,LBound,UBound,-W)).regr(P & Q):- regr(P), regr(Q).regr(P v Q):- regr(P) -> true ; regr(Q).regr(P => Q):- regr(P) -> regr(Q) ; true.regr(P <=> Q):- regr((P => Q) & (Q => P)).regr(-(-P)):- regr(P).regr(-(P & Q)):- regr(-P v -Q).regr(-(P v Q)):- regr(-P & -Q).regr(-(P => Q)):- regr(-(-P v Q)).regr(-(P <=> Q)):- regr(-((P => Q) & (Q => P))).regr(-all(V,W)):- regr(some(V,-W)).regr(-some(V,W)):- not regr(some(V,W)).regr(-W):- isAtomEx(W), not regr(W).regr(all(V,W)):- regr(-some(V,-W)).regr(some(V,W)):- sub(V,_,W,W1), regr(W1).%% extended atom definitionisAtomEx(A) :- not (A = -W ; A = (W1 & W2) ; A = (W1 => W2) ;A = (W1 <=> W2) ; A = (W1 v W2) ; A = some(X,W) ; A = all(X,W) ;A = (S1 <<= S2) ; A = (S1 << S2) ; A = (S1 =$= S2) ;A = somes(_,_,_,_) ; A = alls(_,_,_,_) ).A. Gabaldon / Artificial Intelligence 175 (2011) 25–4845We use the following simple blocks world implementation.Blocks World Basic Action Theoryposs(pickup(X),S):- clear(X,S), ontable(X,S), handempty(S).poss(putdown(X),S):- holding(X,S).poss(stack(X,Y),S):- holding(X,S), clear(Y,S).poss(unstack(X,Y),S):- handempty(S), clear(X,S), on(X,Y,S).clear(X,do(A,S)):- A=putdown(X) ; A=stack(X,Y) ; A=unstack(Y,X) ;clear(X,S), not A=pickup(X),not ( A=stack(Y,X) ; A=unstack(X,Y) ).on(X,Y,do(A,S)):-A=stack(X,Y) ;on(X,Y,S), not A=unstack(X,Y).ontable(X,do(A,S)):- A=putdown(X) ;ontable(X,S) , not A=pickup(X).handempty(do(A,S)):- A=putdown(X) ;A=stack(X,Y) ;handempty(S), not A=pickup(X), not A=unstack(X,Y).holding(X,do(A,S)):- A=pickup(X) ; A=unstack(X,Y) ;holding(X,S), not A=putdown(X), not A=stack(X,Y).% Primitive actionsprimitive_action(pickup(X)).primitive_action(stack(X,Y)). primitive_action(unstack(X,Y)).primitive_action(putdown(X)).% Restore atoms.restoreSitArg(clear(X),S,clear(X,S)). restoreSitArg(on(X,Y),S,on(X,Y,S)).restoreSitArg(ontable(X),S,ontable(X,S)). restoreSitArg(handempty,S,handempty(S)).restoreSitArg(holding(X),S,holding(X,S)).% Initial Situationon(d,b,s0). on(a,c,s0).clear(d,s0). clear(a,s0).ontable(b,s0). ontable(c,s0).handempty(s0).block(a). block(b). block(c). block(d).Consider the following query:(cid:2)∃s1: S0 (cid:2) s1 (cid:15) do(cid:2)(∃x, y)(∀a2)∀s2: S0 (cid:2) do(a2, s2) (cid:15)(cid:2)(cid:4)(cid:5)unstack(D, B), stack(D, A)(cid:3)(cid:3), S0(cid:2)(cid:4)(cid:5)putdown( y), unstack( A, x), stack( A, B)(cid:3)(cid:3), s1doPoss(a2, s2)This query says: is there any situation s1 in history(cid:2)(cid:4)(cid:5)unstack(D, B), stack(D, A)do(cid:3), S0after S0, such that the sequence(cid:2)(cid:4)(cid:5)putdown( y), unstack( A, x), stack( A, B)do(cid:3), s1is “legal” (i.e. all actions in it are executable) for some blocks x, y?Intuitively, the only chance for executing this sequence is after unstack(D, B) but before stack(D, A). That means block ymust be D and x must be C . Any other sequence is impossible. We obtain the following results with the implementation.A sample query[eclipse 2]: regr(somes(s1,s0<<s1,s1<<=do(stack(d,a),do(unstack(d,b),s0)),some(x, some(y,all(act2,alls(s2,s0<<do(act2,s2),do(act2,s2)<<=do(stack(a,b),do(unstack(a,x),do(putdown(y),s1))),poss(act2,s2) )))))).Yes (0.00s cpu)46A. Gabaldon / Artificial Intelligence 175 (2011) 25–48%%% Same query but requiring ’s1’ to be after ’do(unstack(d,b),s0)’[eclipse 3]: regr(somes(s1,do(unstack(d,b),s0)<<s1,s1<<=do(stack(d,a),do(unstack(d,b),s0)),some(x, some(y,all(act2,alls(s2,s0<<do(act2,s2),do(act2,s2)<<=do(stack(a,b),do(unstack(a,x),do(putdown(y),s1))),poss(act2,s2) )))))).No (0.00s cpu)%%% Using variables and predicate block(_) to get actual blocks[eclipse 5]: regr(somes(S1,s0<<S1,S1<<=do(stack(d,a),do(unstack(d,b),s0)),some(X, some(Y, block(X) & block(Y) &all(act2,alls(s2,s0<<do(act2,s2),do(act2,s2)<<=do(stack(a,b),do(unstack(a,X),do(putdown(Y),S1))),poss(act2,s2) )))))).X = cY = dS1 = do(unstack(d,b),s0)Yes (0.01s cpu)As an illustration of an action theory with non-Markovian features, consider modifying the action precondition axiom ofstack(x, y) to include the condition that on(x, y) must not have held in the past unless it holds since the initial situation.This condition is a form of planning search control that prevents repeating stack actions:(cid:2)Poss(cid:3)stack(x, y), s(cid:2)¬(∃s1: s1 (cid:2) s)≡ holding(x, s) ∧ clear( y, s) ∧(cid:3)on(x, y, s1) ∧ (∃s2: s2 (cid:2) s1)¬on(x, y, s2).The corresponding, modified Prolog rule would beposs(stack(X,Y),S):- holding(X,S), clear(Y,S),regr( -somes(s1, s0<<=s1, s1<<=S, on(X,Y,s1) &somes(s2, s0<<=s2, s2<<s1, -on(X,Y,s2)))).Here we use evaluator regr to handle the bounded formula. In general, a better option would perhaps be to reify allthe fluent formulas and refer to them through the holds predicate. We refrain from doing that here though.The following are the results obtained with two simple queries and the blocks world theory with the modified precon-dition axiom:Simple query with Non-Markovian APA%% This is possible because on(a,c) holds only in s0.[eclipse 2]: poss(stack(a,c),do(unstack(a,c),s0)).Yes (0.00s cpu)[eclipse 3]: poss(stack(a,d),do(unstack(a,d),do(stack(a,d),do(unstack(a,c),s0)))).No (0.00s cpu)6. ConclusionWe have presented a generalization of Reiter’s Basic Action Theories [5,21] where the Markov property is not assumed,hence allowing representing and reasoning with non-Markovian systems. The main challenge in doing this is to developa framework that still supports regression as a computational device. We have identified a syntactically restricted class offormulas, which we have called bounded, to which regression can be applied and that form the basis of our generalizationof Basic Action Theories for non-Markovian control. We have then generalized Reiter’s regression operator, R, to handlethe extended class of regressable formulas. The modified operator, as the original, can be used to compute entailment ofregressable formulas with respect to a background action theory. This problem intuitively consists in reducing the task ofproving the entailment of the original formula into the task of proving entailment of the regressed formula with respect tothe initial first-order database plus the unique names axioms for actions. This is especially important because it makes theonly second-order axiom in these theories irrelevant with respect to solving this problem. Finally, we have proved that thegeneralized regression operator is correct and shown a simple Prolog implementation of a formula evaluator based on thisoperator.A. Gabaldon / Artificial Intelligence 175 (2011) 25–4847Removing the Markov assumption from Basic Action Theories without any changes to the Situation Calculus ontologyand language is possible thanks to the fact that histories are first class objects in these theories. Considerably more effortwould have been required to remove this assumption from other formalizations where this is not the case.Some recent work has considered non-Markovian features of domains described in A type languages [22]. In [23],Giunchiglia and Lifschitz are concerned with problems where actions have ramifications, i.e., indirect effects. In particular,they are concerned with ramifications due to fluents whose truth value depends on that of other fluents, but where thisdependency is unknown or implicit. In this case, knowledge about past states may be useful to determine the value offluents with an implicit dependency on others, so their framework is non-Markovian to some degree. Although their for-malism does not allow one to explicitly write non-Markovian definitions for fluents, the problem they are concerned withalso serves as a motivation for a formalism that can handle non-Markovian systems.Mendez et al. [24] essentially consider the same problem we do here: reasoning about actions whose dynamics dependson past states. They extend the language A with the Past Linear Temporal logic connectives previous and since. This languageis propositional and so there is no quantifying into temporal modalities. More recently, Gonzalez et al. [25] introducedan A-like language for modeling non-Markovian domains. One of their motivations is the practical problem of modelingmultimedia presentations that involve temporal conditions constraining how a presentation evolves. Similar to the languagein [24], this language does not allow quantifying into temporal modalities since it is also propositional. Computation in thislanguage is done through a translation into logic programming with answer set semantics [26] and systems such as Smodels[27] and DLV [28]. Answer sets of a domain description contain every state (set of literals) the system goes through for agiven set of action occurrences, which may be disadvantageous in large domains. In Non-Markovian Action Theories, all thereasoning is done in terms of a sequence of actions and the initial database, hence the size of the domain does not have asbig an impact.An important question that we have not addressed in this paper is whether Non-Markovian Action Theories are moreexpressive than standard action theories. In [13] we introduced a procedure for compiling the class of non-Markoviantheories that refer to past situations only through Past LTL-like formulas as in Example 2. In [29] we give a procedurefor a much larger class of action theories, and conjecture that the transformation can be extended to the general case.In developing this transformation for a larger class of formulas, we gain the insight that a transformation for the generalcase would likely have to essentially produce formulas and axioms that “simulate” the steps of the generalized regressionprocedure. In this case, it seems more reasonable and practical simply to use the generalized regression operator on theNon-Markovian Action Theories instead of applying a transformation.AcknowledgementsI am very grateful to Fahiem Bacchus, Gerhard Lakemayer, Yves Lespérance and Hector Levesque for lots of commentsand suggestions that helped improve this paper. We also thank the anonymous reviewers for their extremely useful anddetailed feedback.References[1] A. Gabaldon, Non-Markovian control in the Situation Calculus, in: Proc. of the 18th National Conference on Artificial Intelligence (AAAI’02), Edmonton,Canada, 2002, pp. 519–524.[2] R. Reiter, Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems, MIT Press, Cambridge, MA, 2001.[3] J. McCarthy, Situations, actions and causal laws, Tech. Rep., Stanford University, 1963; reprinted in: M. Minsky (Ed.), Semantic Information Processing,MIT Press, Cambridge, MA, 1968, pp. 410–417.[4] J. McCarthy, P. Hayes, Some philosophical problems from the standpoint of artificial intelligence, in: B. Meltzer, D. Michie (Eds.), Machine Intelligence,vol. 4, Edinburgh University Press, 1969, pp. 463–502, also appears in: N. Nilsson, B. Webber (Eds.), Readings in Artificial Intelligence, Morgan–Kaufmann, Edmonton, 1987, pp. 431–450.[5] R. Reiter, The frame problem in the Situation Calculus: A simple solution (sometimes) and a completeness result for goal regression, in: V. Lifschitz(Ed.), Artificial Intelligence and Mathematical Theory of Computation, Academic Press, 1991, pp. 359–380.[6] G. Saake, U.W. Lipeck, Foundations of temporal integrity monitoring, in: C. Rolland, F. Bodart, M. Leonard (Eds.), Proc. of the IFIP Working Conferenceon Temporal Aspects in Information Systems, North-Holland, Amsterdam, 1988, pp. 235–249.[7] J. Chomicki, Efficient checking of temporal integrity constraints using bounded history encoding, ACM Transactions on Database Systems 20 (2) (1995)148–186.[8] I. Kiringa, Simulation of advanced transaction models using Golog, in: Proc. 8th Biennial Workshop on Data Bases and Programming Languages (DB-PL’01), Rome, 2001.[9] I. Kiringa, A. Gabaldon, Expressing transactions with savepoints as non-Markovian theories of actions, in: F. Bry, C. Lutz, U. Sattler, M. Schoop (Eds.),10th International Workshop on Knowledge Representation Meets Databases, CEUR, Hamburg, Germany, 2003, http://ceur-ws.org/Vol-79.[10] I. Kiringa, A. Gabaldon, Synthesizing advanced transaction models using the Situation Calculus, Jounal of Intelligent Information Systems (2009).[11] F. Bacchus, F. Kabanza, Using temporal logics to express search control knowledge for planning, Artificial Intelligence 116 (2000) 123–191.[12] J. Kvarnström, P. Doherty, TALplanner: A temporal logic based forward chaining planner, Annals of Mathematics and Artificial Intelligence 30 (2000)119–169.[13] A. Gabaldon, Compiling control knowledge into preconditions for planning in the Situation Calculus, in: Proc. 18th International Joint Conference onArtificial Intelligence (IJCAI’03), Acapulco, Mexico, 2003.[14] A. Gabaldon, Precondition control and the progression algorithm, in: Proc. of the 9th International Conference on Principles of Knowledge Representa-tion and Reasoning (KR’04), Whistler, B.C., Canada, 2004.[15] F. Bacchus, C. Boutilier, A. Grove, Rewarding behaviors, in: Proc. of 13th National Conference on Artificial Intelligence (AAAI-96), 1996, pp. 1160–1167.48A. Gabaldon / Artificial Intelligence 175 (2011) 25–48[16] F. Bacchus, C. Boutilier, A. Grove, Structured solution methods for non-Markovian decision processes, in: Proc. 14th National Conference on ArtificialIntelligence (AAAI-97), 1997, pp. 112–117.[17] S. Thiébaux, F. Kabanza, J. Slaney, Anytime state-based solution methods for decision processes with non-Markovian rewards, in: Proc. of the 18thConference on Uncertainty in Artificial Intelligence (UAI’02), Morgan Kaufmann, Edmonton, Canada, 2002, pp. 501–510.[18] C. Gretton, D. Price, S. Thiébaux, Implementation and comparison of solution methods for decision processes with non-Markovian rewards, in: Proc. ofthe 19th Conference on Uncertainty in Artificial Intelligence (UAI’03), Morgan Kaufmann, Acapulco, Mexico, 2003.[19] J. McCarthy, Elephant 2000: A programming language based on speech acts, available at http://www-formal.stanford.edu/jmc/, 1992.[20] H. Levesque, R. Reiter, Y. Lespérance, F. Lin, R.B. Scherl, Golog: A logic programming language for dynamic domains, Journal of Logic Programming 31 (1–3) (1997) 59–83.[21] F. Pirri, R. Reiter, Some contributions to the metatheory of the Situation Calculus, Journal ACM 46 (3) (1999) 325–364.[22] M. Gelfond, V. Lifschitz, Action languages, Electronic Transactions on Artificial Intelligence 3 (1998) 195–210, http://www.ep.liu.se/ea/cis/1998/016.[23] E. Giunchiglia, V. Lifschitz, Dependent fluents, in: Proc. of IJCAI-95, 1995, pp. 1964–1969.[24] G. Mendez, J. Lobo, J. Llopis, C. Baral, Temporal logic and reasoning about actions, in: Third Symposium on Logical Formalizations of CommonsenseReasoning (Commonsense’96), 1996.[25] G. Gonzalez, C. Baral, M. Gelfond, Alan: An action language for non-Markovian domains, in: Proc. of the NonMonotonic Reasoning, Action and ChangeWorkshop (NRAC’03), Acapulco, Mexico, 2003.[26] M. Gelfond, V. Lifschitz, Representing actions and change by logic programs, Journal of Logic Programming 17 (1993) 301–322.[27] I. Niemelä, P. Simons, Smodels—An implementation of the stable models and well-founded semantics for normal logic programs, in: Proc. 4th Interna-tional Conference on Logic Programming and Non-Monotonic Reasoning, 1997.[28] S. Citrigno, T. Eiter, W. Faber, G. Gottlob, C. Koch, N. Leone, C. Mateis, G. Pfeifer, F. Scarcello, The dlv system: Model generator and application frontends,in: F. Bry, B. Freitag, D. Seipel (Eds.), Proc. of the 12th Workshop on Logic Programming (WLP’97), LMU München, 1997, pp. 128–137.[29] A. Gabaldon, Non-Markovian control in dynamical systems and planning, PhD thesis, University of Toronto, Toronto, Canada, 2004.