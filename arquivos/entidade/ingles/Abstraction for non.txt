Artificial Intelligence 300 (2021) 103563Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintAbstraction for non-ground answer set programs ✩Zeynep G. Saribatur∗, Thomas Eiter, Peter SchüllerInstitute of Logic and Computation, TU Wien, Favoritenstraße 9-11, A-1040 Vienna, Austriaa r t i c l e i n f oa b s t r a c tArticle history:Received 20 December 2019Received in revised form 11 May 2021Accepted 21 July 2021Available online 28 July 2021Keywords:AbstractionAnswer set programmingDeclarative problem solvingKnowledge representation and reasoningNonmonotonic formalismsExplaining unsatisfiabilityCounterexample-guided abstraction and refinementAbstraction is an important technique utilized by humans in model building and problem solving, in order to figure out key elements and relevant details of a world of interest. This naturally has led to investigations of using abstraction in AI and Computer Science to simplify problems, especially in the design of intelligent agents and automated problem solving. By omitting details, scenarios are reduced to ones that are easier to deal with and to understand, where further details are added back only when they matter. Despite the fact that abstraction is a powerful technique, it has not been considered much in the context of nonmonotonic knowledge representation and reasoning, and specifically not in Answer Set Programming (ASP), apart from some related simplification methods. In this work, we introduce a notion for abstracting from the domain of an ASP program such that the domain size shrinks while the set of answer sets (i.e., models) of the program is over-approximated. To achieve the latter, the program is transformed into an abstract program over the abstract domain while preserving the structure of the rules. We show in elaboration how this can be also achieved for single or multiple sub-domains (sorts) of a domain, and in case of structured domains like grid environments in which structure should be preserved. Furthermore, we introduce an abstraction-&-refinement methodology that makes it possible to start with an initial abstraction and to achieve automatically an abstraction with an associated abstract answer set that matches an answer set of the original program, provided that the program is satisfiable. Experiments based on prototypical implementations reveal the potential of the approach for problem analysis, by its ability to focus on the parts of the program that cause unsatisfiability and by achieving concrete abstract answer sets that merely reflect relevant details. This makes domain abstraction an interesting topic of research whose further use in important areas like Explainable AI remains to be explored.© 2021 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).1. IntroductionAbstraction is a technique applied in human reasoning and understanding, by reasoning over the models of the world that are built mentally [30,68]. Although its meaning comes from “to draw away”, there is no precise definition that is capable of covering all meanings that abstraction has in its utilizations. There is a variety of interpretations in different Some of the results in this article were presented in preliminary form at JELIA 2019 [113] and XAI 2019 [45]. This work has been partially supported ✩by the Austrian Science Fund (FWF) grant W-1255 and by the EU’s H2020 research and innovation programme under grant agreements 825619 (AI4EU) and 952026 (HumanE-AI Net).* Corresponding author.E-mail addresses: zeynep@kr.tuwien.ac.at (Z.G. Saribatur), eiter@kr.tuwien.ac.at (T. Eiter), ps@kr.tuwien.ac.at (P. Schüller).https://doi.org/10.1016/j.artint.2021.1035630004-3702/© 2021 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 10356322blue14536red145green36red76 5981249(a) 3-coloring of a graph(b) SudokuFig. 1. Use of abstraction.disciplines such as Philosophy, Cognitive Science, Art, Mathematics and Artificial Intelligence, with the shared consensus of the aim to “distill the essential” [108]. Among them is the capability of abstract thinking, which is achieved by removing irrelevant details and identifying the “essence” of a problem [71]. The notion of relevance is especially important in problem solving, as a problem may become too complex to solve if every detail is taken into account. A good strategy to solve a complex problem is to start with a coarse solution and then refine it by adding back more details. When planning a trip, for instance, one may first pick the destination and determine a coarse travel plan; fleshing out the precise details of the travel, such as taking the subway to the airport, comes later. This may be done in a hierarchy of levels of abstraction, with the lowest level containing all of the details. Another view of abstraction is the generalization aspect, which is singling out the relevant features and properties shared by objects. For example, features of an airplane such as color and cargo capacity with their possible differences may be irrelevant to the travel plan; we are (mostly) only interested in the fact that there is an airplane that takes us from Vienna to New York, say. Overall, the general aim of abstraction is to simplify the problem at hand to one that is easier to understand and deal with.For solving combinatorial problems and figuring out the key elements, humans arguably employ abstraction. In Artificial Intelligence, such problems vary from planning problems like in which order to move blocks to achieve a final configuration, to solving constraint problems such as finding an admissible coloring of the nodes of a given graph. In the latter problem, for instance, isolated nodes can be viewed as a single node and colored the same without thinking about the specific details (Fig. 1a). If a given graph is non-colorable, then we may try to find some subgraph (e.g., a clique) which causes the unsolvability, and we would not care about other nodes in the graph. Similarly with the blocks: if the labels are not important, we would disregard them when figuring out the actions. If the goal configuration cannot be achieved from the initial one, we would aim to find out the particular blocks that cause this.Notably, such disregard of detail also occurs for problems with multi-dimensional structures such as grid-cells in the well-known Sudoku problem, where a partially filled 9 × 9 board must be completed by filling in numbers 1..9 into the empty cells under constraints. If an instance is unsolvable, the reason can only be meaningfully grasped by a human by focusing on the relevant sub-regions, as looking at the whole grid is too complex. For illustration, Fig. 1b shows the sub-regions of an instance that contain the reason why no solution exists: as 6 and 7 occur in the middle column, they must appear in the sub-region below in the left column, which is unfeasible as there is only one empty cell. All these examples demonstrate abstraction abilities of humans that come naturally.Due to its important role in knowledge representation and in reasoning, abstraction has been explored in AI research early on as a useful tool for problem solving: solve a problem at hand first in an abstracted space, and then use the abstract solution as a heuristic to guide the search for a solution in the original space [70,92,106]. This approach was used in planning for speeding up the solving [64] and especially for computing heuristic functions to guide the plan search in the state space. Several abstraction methods were introduced towards this direction, especially to automatically compute abstractions that give a good heuristic [38,61,116]. However, it is well known that the success in solving a problem relies on how “good” the abstraction is. For this, theoretical approaches for defining abstractions with desired properties have been investigated [59,90]. Apart from gaining efficiency (which however may not always materialize [8,63]), abstraction forms a basis to obtain high-level explanations and an understanding of a problem. For more details on these and other related works see Section 7.3.Abstraction has been studied in other areas of AI and Computer Science as well, among them model-based diagnosis [23,89], constraint satisfaction [13,52], theorem proving [102], to name a few. Particularly fruitful were applications in model checking, which is a highly successful approach to computer aided verification [27], to tackle the state explosion problem by property preserving abstractions [26,32,82]. Furthermore, the seminal counterexample guided abstraction refinement (CEGAR) method [25] allows for automatic generation of such abstractions, by starting from an initial abstraction that over-approximates the behavior of a system to verify, and then stepwise refining the abstraction as long as needed, i.e., as long as spurious (false) counterexamples exist.Abstraction for Answer Set Programming. Answer Set Programming (ASP) [18,79] is a declarative problem solving paradigm that is rooted in knowledge representation, logic programming, and nonmonotonic reasoning. A problem is represented by a non-monotonic logic program whose answer sets (also called “stable models” [57]) correspond to the solutions of the problem. Thanks to the availability of efficient solvers and the expressiveness of the formalism, ASP has been gaining 2Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563popularity for applications in many areas of AI and beyond, cf. [47–49] and references therein, from combinatorial search problems (e.g. configuration, diagnosis, planning) over system modeling (e.g., behavior of dynamic systems, beliefs and actions of agents) to knowledge-intensive applications (e.g., query answering, explanation generation), to name a few [47]. The declarative nature of ASP enables a flexible use for solving different reasoning problems, and it provides a useful basis for investigating ways to help in understanding a problem with its key elements. Studies in understanding how ASP programs find a solution (or none) to a problem have been conducted, which mainly focus on debugging answer sets [16,55,93] or finding justifications [20,103,115]. These approaches could be used to aid in understanding the problem at hand; however, as noted in [50], the explanations offered may contain a high number of details which prevent one from seeing the crucial parts. This is where abstraction would come in handy and could be very fruitfully used.Somewhat surprisingly, abstraction has not been considered much in the context of nonmonotonic knowledge represen-tation and reasoning, including ASP as a premier formalism in this area. Simplification methods such as equivalence-based rewriting [53,97], partial evaluation [17,67], or forgetting (see [73] for a recent survey), have been extensively studied; however, they strive for preserving semantics, while abstraction provides an approximation of the answer sets of a logic program, in a modified language. We aim here at an approximation in which no answer set is lost, i.e., each answer set of the original program corresponds to some answer set of the abstract program. This enables us to distill all answer sets of the original program from the abstract answer sets and to perform sound reasoning from the abstract answer sets. Specif-ically, spurious answer sets, i.e., abstract answer sets that do not correspond to some answer set of the original program, may be discarded, while under this over-approximation cautious reasoning from all abstract answer sets ensures soundness with respect to cautious reasoning from all answer sets of the original program; moreover, in case no spurious answer set exists we also have completeness (in particular, if no abstract answer set exists). This makes abstraction an interesting topic for research.In a recent work [110,111], a notion of abstraction for ASP was introduced that focuses on omission of atoms from the vocabulary and ensures over-approximation by rewriting the rules of a given program. That approach is propositional in nature and related to forgetting [112], with the difference of over-approximation vs. preserving the answer sets. Further-more, it is for unsatisfiable programs related to minimal unsatisfiable subset/core (MUS) extraction from SAT instances and propositional answer set programs, which aims at identifying a smallest set of clauses, respectively rules or asserted literals, that prohibit to have a model, respectively answer set, cf. [1,2,5,76,85]. This may be exploited to give an explanation of non-3-colorability of a graph or non-solvability of a Sudoku instance as in Fig. 1 in terms of clauses, respectively ground literals and rules; however, such an explanation lacks structure in terms of showing subgraphs or subareas, say, which must be extracted in post processing from the propositional encoding. For further discussion of omission abstraction and MUS extraction, we refer to [111].We follow an orthogonal approach to [110,111] and introduce in this work a notion of abstraction for ASP on the first-order level that is concerned with collapsing (i.e., clustering) objects in the (Herbrand) domain of a program. It is that in this way, multiplicity is removed in the spirit of Occam’s razor.1 If the graph in Fig. 1a is represented by facts node(1), . . . , node(6) and edge(1, 2), edge(1, 3), edge(2, 3), then collapsing the nodes 4, 5, and 6 into an abstract node a would not affect 3-colorability of the graph; we thus expect that an abstract version of an ASP program that encodes all 3-colorings of the graph would yield answer sets from which these 3-colorings can be recovered. However, if there were an edge between 4 and 5, then over-approximation would yield that this abstract program will have spurious answer sets, as the abstract node a may have a single color in some abstract answer set Iwhile 4 and 5 must have in every original answer set I different colors, thus I cannot be mapped to I. Similarly, if nodes 1 and 2 were collapsed, the graph would become 2-colorable (where 1 and 2 share the same color), while the original graph is not 2-colorable. These simple examples show that a naive use of domain abstraction – just replace individuals by a cluster of elements – does not work; and yet more subtle effects may surface when programs have recursive definitions such as reachability.(cid:3)(cid:3)In fact, suitable domain abstraction for ASP is non-trivial and has several challenges. First, the abstract program should be automatically constructed, while the structure of the original rules should be preserved if this is feasible. Second, abstraction refinement, i.e., unclustering of objects for eliminating spurious answer sets, should be automated as well. This is non-trivial, given a large space of possible refinements and that objects might be related among each other in multiple ways, e.g. in temporal or spatial relationships as in reasoning about actions, for instance. And third, the capability of dealing with structure and to support hierarchical abstraction that can handle objects of different granularities at different levels of abstraction is needed.Contributions. We address the issues above in this work, whose main contributions can be summarized as follows.(cid:3)over D(1) We formally introduce the notion of domain abstraction for ASP programs. To this end, we define abstraction map-, and construct an abstract program pings m from the original (concrete) domain D of the program to an abstract domain D(cid:2)(cid:3). We propose a systematic approach for such that each answer set I of (cid:2) maps to an abstract answer set Ithe construction of such an abstract program, which works modularly on the syntactic level and transforms each rule in (cid:2)into a set of abstract rules with a similar structure. In the transformation, built-in relations and in particular equality, whose treatment provides the backbone of the method, are lifted to the abstract level, and uncertainty caused by the abstracted of (cid:2)(cid:3)(cid:3)(cid:3)1 Often referred to as “Entia non sunt multiplicanda praeter necessitatem.” that is, entities should not be multiplied beyond necessity.3Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563(cid:3)domain Dis carefully respected. Our notion of abstraction can be used for different applications such as obtaining abstract solutions from ASP programs or showing reasons of unsatisfiability in case no answer set exists. We illustrate this on various problems expressed in ASP, among them problems from combinatorial search, planning, and agent behavior assessment.(cid:3)(cid:3)(2) We present a method which, in case an abstract answer set Iof the abstraction in order to eliminate I(cid:3)constructed from Iof a program (cid:2) w.r.t. mapping m is spurious, computes (cid:3). To this end, we reduce the test for spuriousness to unsatisfiability a refinement mof a non-ground ASP program (cid:2)(cid:3), (cid:2), and m. As unsatisfiability of (cid:2)(cid:3)as such leaves one clueless about how to modify m in order to eliminate spuriousness, we present a method for catching causes of the unsatisfiability. The method uses a debugging technique via meta-programming for ASP and obtains useful information for computing a promising refinement mthat removes the spuriousness. Building on an ASP solver, it uses under the hood assumption-based search. To this end, we lift the SPOCK approach [16] for tight programs to the non-ground level such that decisions on refinements can be based on special atoms computed during the debugging. Intuitively, these atoms single out changes for a spurious answer set Itowards a corresponding answer set I of the original program (cid:2), where always some such atoms will be found; based on heuristics, we introduce different refinement strategies to eliminate spurious answer sets. These strategies are employed in a CEGAR-style [25] methodology of iterative abstraction and refinement, which starts with a highly coarse abstraction and automatically searches for and outputs an abstraction with a non-spurious (concrete) answer set if one exists.(cid:3)(cid:3)(3) We introduce the possibility of multi-dimensional abstraction mappings over a domain. While the abstraction method from above can deal with sorts, we have to modify it to form an abstraction over the relations that is akin to existential abstraction [25], which can be viewed as a simplification of the initially presented abstraction method, in order to enable that elements at mixed levels of abstraction can be handled properly. This in fact is needed to relate in Fig. 1b cells like the top-left corner with abstract cells such as the mid-left 3 × 3 sub-region, and to express their abstract locations such as being above, left-of etc. We extend the abstraction-&-refinement methodology with handling the structural aspects of grid-cells by using an abstraction of quad-trees, a tree structure often used to partition 2-dimensional spaces, and we consider more sophisticated decision making for the refinement to observe its effects on the resulting abstractions.(4) We analyze semantic and computational properties of the abstraction approach, which can be exploited for modeling and for guiding the design of suitable implementations. Among other results, we establish that abstractions for sequences of refinements can be built incrementally (Proposition 3.6), and that abstractions of independent sorts can be naturally composed (Proposition 3.7). Furthermore, the two variants of domain abstractions we consider are semantically equivalent, which we demonstrate here for the basic case (Theorem 5.1), but have features making them attractive in different contexts. As regards complexity, we show that checking whether an abstract answer set of a normal logic program is spurious is coNEXP-complete and that deciding whether an abstraction mapping is faithful, i.e., has no spurious abstract answer sets, is coNEXPNP-complete. Thus, the worst case complexity of these problems coincides with the one of unsatisfiability testing of normal respectively disjunctive non-ground ASP programs [33]. Furthermore, if predicate arities are bounded by a constant, the problems are (cid:2)pp -complete, respectively, and thus again have the same complexity as unsatisfiability testing of normal and disjunctive non-ground ASP programs, respectively in the bounded predicate case [39]. Reducing spurious checking to unsatisfiability testing of normal logic programs is thus worst-case optimal in both settings.2 -complete and (cid:2)3(cid:3)(cid:3)and an abstract answer set Ifor the abstract program (cid:2)(cid:3)(5) We have implemented the abstraction-&-refinement approach in prototypical tools DASPAR and mDASPAR for plain and multi-dimensional abstraction, respectively. They take as input a non-ground program (cid:2) and an initial coarse do-main mapping m (which by default is the trivial mapping that clusters all elements), and output a refinement mapping that is non-spurious, if one exists; otherwise, i.e., in case (cid:2)mhas no abstract answer sets. The is unsatisfiable, they provide a refinement mapping mimplementations include different refinement strategies and support independent sorts as well as 2-dimensional abstrac-tions with a quad-tree-style refinement process. Based on these tools, we have conducted an experimental evaluation of the approach, where one set of experiments focused on finding non-trivial abstractions for problems expressed by well-known ASP programs (graph coloring, scheduling), while another one consisted in detecting the unsolvability of several benchmark problems involving grid-cells. In the experiments, different debugging strategies were considered and a measure for assess-ing the quality of multi-dimensional abstraction was developed. The results show the potential of the approach, where in particular a small user-study for a natural grid-cell problem indicates its capability of putting a human-like focus on the grid to show unsatisfiability.that is faithful, i.e., such that (cid:2)(cid:3)(cid:3)Summarizing, our work on domain abstraction for ASP opens an intriguing line of research which aims at making it possible to identify the gist of a program’s domain that is responsible for matters such as inconsistency or certain solutions of interest. The approach that we present provides the ability to adjust the granularity of abstraction towards the details relevant for a problem in an (semi-)automated way. The experimental results indicate the value of domain abstraction for program analysis, whose further use in important areas like Explainable AI remains to be explored.Organization. The remainder of this article is organized as follows. The next section recalls notions from ASP as needed for this work, and reviews the seminal approach to abstraction over (in essence) propositional ASP programs introduced in [110,111]. After that, in Section 3, we turn to domain abstraction for non-ground ASP programs, where we present an abstraction procedure, consider various extensions, and study semantic and computational properties of the approach. In the subsequent Section 4, we present our refinement methodology that is based on debugging of ASP programs. After Sections 34Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563and 4 we are well equipped to apply the CEGAR-style abstraction and refinement procedure for answer set programs. As a further consideration, in Section 5, we focus on multi-dimensional abstraction and an alternative abstraction method, based on existential abstraction, that is needed for it, which can also be combined with the refinement method from Section 4 to apply the CEGAR-style procedure. Implementation and evaluation of the approach for both abstraction types is considered in Section 6, while in Section 7 we discuss further notions of abstraction and possible use cases, as well as related work. The final Section 8 provides a summary and outlines issues for future research.In order not to distract from the flow of reading, longer proofs and further details have been moved to the Appendix (Aand B), which also provides a further use case in agent behavior assessment (C).2. Background2.1. Answer set programmingIn this section, we recall the concepts and notions of Answer Set Programming (ASP) that we need for this article. We refer to [18,19,114] for more background and references. We start with syntax and semantics of ASP programs and then recall some notions that are useful for this work.Syntax. We consider a first-order vocabulary V = (P, C) consisting of non-empty finite sets P of predicates and C of constants. Let X represent the set of variable symbols. A term is either a constant from C or a variable from X . An atom is an expression α of the form p(t1, . . . , tn) where p ∈ P and each ti is a term; n ≥ 0 is the arity of p, and arg(α) = {t1, . . . , tn}denotes the set of arguments of α. Atoms are called propositional if n = 0 and ground if they do not contain variables. A literal is either a formula α (positive literal) or not α (negative literal), where α is an atom. Intuitively, a negative literal not αis true if α cannot be derived using rules, and false otherwise; not is called weak or default negation.Definition 2.1. A normal logic program (cid:2) is a finite set of rules. A rule r is an expression of the formα0 ← α1, . . . , αm, not αm+1, . . . , not αn, 0 ≤ m ≤ n.(1)We refer to α0 as the head of r, and α1, . . . , αm, not αm+1, . . . , not αn as the body or r. We also write r as α0 ← B(r), +(r) = {α1, . . . , αm} is the positive body and +(r) etc. if r is clear. We refer to “normal logic such that H(r) = α0 denotes the head or as H(r) ← B−(r) = {αm+1, . . . , αn} is the negative body of r. We may omit r from B(r), BBprograms” as “programs” unless otherwise noted.−(r), where B+(r), not BA rule r is a constraint if α0 is the propositional atom ⊥ (then also omitted), where ⊥ is a predicate constant for falsity. Furthermore, r is a fact if n = 0 and no variable occurs in r, and r is positive if n = m. A rule is ground if all literals occurring in it are ground.A program (cid:2) is positive and ground if the rules in it have the respective property; it is safe if every variable that occurs in a rule also occurs in the same rule in some positive body literal. We assume safety of the programs which usually is achieved by making use of domain predicates, which are unary predicates that are given as facts and are true for all constants that the variables in the program are being grounded over. We use predicate dom for the domain predicate. For simplicity of presentation, we omit dom in the representation, unless it is necessary to ensure safety, and from the answer sets.Choice rules are syntactic sugar of the form {a} ← B, which stands for the rules a ← B, not a and a ← B, not a, where a is a new atom.Semantics. The answer set semantics is defined via ground programs. For a program (cid:2), we define its ground instantiationas follows.Given a program (cid:2), its Herbrand universe, denoted by HU(cid:2), is the set of all constant symbols C ⊆ C appearing in (cid:2); in case there is no constant symbol, then HU(cid:2) = {c} for some arbitrary constant symbol. The Herbrand base of a program (cid:2), denoted by HB(cid:2), is the set of all ground atoms constructed using predicates from P and constants from C.The ground instances of a rule r ∈ (cid:2), denoted by grd(r), is the set of rules obtained by replacing all variables in r with constant symbols in HU(cid:2) in all possible ways. The grounding of a program (cid:2) is then grd((cid:2)) =r∈(cid:2) grd(r). To group the rules in grd((cid:2)) with the same head α, we use def (α, (cid:2)) = {r ∈ grd((cid:2)) | H(r) = α}, to group non-ground rules in (cid:2) that define atoms with predicate p, we use pdef (p, (cid:2)) = {r ∈ (cid:2) | H(r) = p(t1, . . . , tn)}.Let (cid:2) be a ground program. An interpretation I is a subset of HB(cid:2) and I satisfies a rule r ∈ (cid:2), denoted by I |= r, if −(r) ∩ I = ∅. An interpretation is a model of (cid:2), denoted by I |= (cid:2), if I |= r for all r ∈ (cid:2). +(r) ⊆ I and BH(r) ∈ I whenever BA model I is minimal if there is no model J of (cid:2) such that J ⊂ I .(cid:2)Example 2.1. Consider the program (cid:2) below and the interpretation I = {a, b, d}.c ←not d.d ←not c.a ←not b, c.5Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563b ←d.I is a model of (cid:2), but it is not minimal, since the interpretation I(cid:3) = {b, d} is also a model of (cid:2).Definition 2.2 (GL-reduct). The Gelfond-Lifschitz (GL-)reduct of a program (cid:2) relative to an interpretation I ⊆ HB(cid:2), denoted by (cid:2)I , is the ground positive program obtained from grd((cid:2)) when each rule H(r) ← B+(r), not B−(r)(i) with B(ii) is replaced by H(r) ← B−(r) ∩ I (cid:13)= ∅ is deleted, and+(r), otherwise.Informally, the first step is to remove the rules where I contradicts a default negated literal, and from the remaining rules, the second step removes their negative body.Definition 2.3. An interpretation I is an answer set of a program (cid:2) if it is the minimal model of the GL-reduct (cid:2)I .Apart from the GL-reduct which is considered to be the standard definition for stable models (i.e., answer sets), a collection of other definitions can be found in [78].The set of answer sets of a program (cid:2) is denoted as A S((cid:2)). A program (cid:2) is unsatisfiable if A S((cid:2)) = ∅.Example 2.2 (ctd). (cid:2) has two answer sets, viz. I1 = {c, a} and I2 = {d, b}; indeed,• (cid:2)I1 = {c.; a ← c.; b ← d.} and I1 is the minimal model of (cid:2)I1 ; similarly,• (cid:2)I2 = {d.; b ← d.} has I2 as its minimal model.Dependencies. The dependency graph of a ground program (cid:2) is a directed graph G(cid:2) = (V , E), where the vertices V equal −−++ ∪ EHB(cid:2), and the edges E = E−(r), for all r ∈ (cid:2).from any q = H(r) to any p2 ∈ Bfrom any q = H(r) to any p1 ∈ B+(r) and negative edges Econsist of positive edges EExample 2.3 (ctd). G(cid:2) has positive edges a → c and b → d and negative edges c → d, d → c and a → b.The positive dependency graph is the dependency graph containing only the positive edges, denoted by G+(cid:2). A program (cid:2)+(cid:2) is acyclic. A non-empty set L of ground atoms describes a positive loop of (cid:2) if for each pair p, q ∈ L there is a is tight if Gpath τ from p to q in G+(cid:2) such that each atom in τ is in L.As we consider non-ground programs, we need to take care of cyclic dependencies of atoms at the non-ground level. = (V , E) where the vertices V are the +(r)−(r), for all r ∈ (cid:2). A non-ground negative dependency cycle of For that, for a given non-ground (cid:2), we consider a non-ground dependency graph G ng(cid:2)atoms appearing in (cid:2), and the edges E = E−and negative edges Elength n ≥ 2 is of the formfrom any a1(x1) = H(r) to any a2(x2) ∈ Bfrom any a1(x1) = H(r) to any a2(x2) ∈ Bconsist of positive edges E+ ∪ E+−a1(x1) → a2(x2) → . . . → an(xn) → a1(x1)denotes that there is a path τ in G ngwhere α → α(cid:3)including only one negative edge. For example, a choice rule consists of a non-ground negative dependency cycle of length 2. In this article, we focus on the predicates ai of the atoms to determine the dependency, and we thus consider negative dependency cycles of form a1 → a2 → . . . → an → a1. Accordingly, we will consider a set Lc of atoms as cyclic if for each pair α1, α2 ∈ Lc a chain pred(α1) → . . . → pred(α2) exists. Two cyclic sets Lc1 , Lc2 of atoms are called independent if they do not share an atom, i.e., Lc1∩ Lc2ASP solvers first generate a grounding of the given program, and then the search for an answer set is conducted over the (cid:2) from α to some atom α(cid:3)(cid:3)that unifies with α(cid:3)= ∅.ground program.2.2. Abstraction in ASPAbstraction aims at discarding some details of a problem to obtain a more high-level view of a solution. This can be done in an over-approximation, which means that each original solution has some corresponding solution in the abstraction but one may encounter abstract solutions which do not have a corresponding original solution.In [110], the authors introduced such a notion of abstraction in ASP for over-approximating a given ground program (cid:2) on , i.e., |A| ≥ |A(cid:3)|, More formally, abstraction on a smaller vocabulary A(cid:3)vocabulary A, by constructing a ground program (cid:2)(cid:3)was defined at the semantic level as follows.6Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563216753482134Fig. 2. Non-3-colorable graph., respectively, and a mapping m : A → A(cid:3) ∪ {(cid:16)}, where (cid:16) is a propositional constant for truth, we call (cid:2)(cid:3)with |A|≥|A(cid:3)|, where A, A(cid:3)(cid:3) = {m(α) | α ∈ I} is an answer set of (cid:2)(cid:3)are sets of ground atoms of (cid:2) and an abstractionis an . Furthermore, (cid:2)(cid:3)Definition 2.4 (cf. [110]). Given two programs (cid:2) and (cid:2)(cid:3)(cid:2)(cid:3)of (cid:2) with respect to m, if for every answer set I of (cid:2), Iabstraction of (cid:2), if some such mapping m exists.We refer to m as an abstraction mapping which often will be tacitly assumed to be given. This notion of abstraction on the smaller vocabulary A(cid:3), an . In [110], the focus was on gives us the possibility to do clustering over atoms of the program. The (abstract) program (cid:2)(cid:3)serves to represent abstract answer sets. While the reduced vocabulary eases the search for an (abstract) answer set Iadditional check is needed whether the original program (cid:2) has some answer that maps to Iabstraction by omitting atoms from a program, i.e., by clustering them into (cid:16).(cid:3)(cid:3)Example 2.4. Consider the program that describes the graph 3-coloring problem below (adapted from the coloring encoding in the ASP Competition 2013) and the graphs shown in Figs. 1a and 2.color(red). color(green). color(blue).{chosenColor(N, C)} ← node(N), color(C).colored(N) ← chosenColor(N, C).⊥ ← not colored(N), node(N).⊥ ← chosenColor(N, C1), chosenColor(N, C2), C1 (cid:13)= C2.⊥ ← chosenColor(N1, C), chosenColor(N2, C), edge(N1, N2).(2)If we omit in the (ground version) of the encoding (2) with the instance shown in Fig. 1a all atoms involving the nodes 4, 5, 6, the resulting abstract program will have answer sets which all correspond to some answer set of the original pro-gram, as the omitted nodes can be colored arbitrarily without destroying 3-colorability.We could likewise map all atoms α involving 4, 5, 6 to atoms α(cid:3)in which these nodes are replaced by a new node k; e.g., node(4) would become node(k), node(5) becomes node(k) etc. The abstract answer sets correspond then again to original answer sets, as the coloring of 4, 5, 6 does not matter. On the other hand, if we consider the graph in Fig. 2 and omit all atoms that involve nodes 5, 6, 7, 8, then the resulting abstract program has no answer sets, as the remaining clique 1 − 2 − 3 − 4 is not 3-colorable; also the original program has no answer set.The latter observations are not by accident but in fact a useful property.Proposition 2.1. Let (cid:2)(cid:3)be an abstraction of (cid:2). If A S((cid:2)(cid:3)) = ∅, then we have A S((cid:2)) = ∅.In general, over-approximation can cause abstract answer sets that have no corresponding original answer set.Definition 2.5 (spurious & concrete answer sets). Let (cid:2)(cid:3)is concrete if there exists an answer set I ∈ A S((cid:2)) such that m(I) = Ibe an abstraction of (cid:2) for the mapping m. The answer set I; otherwise, it is spurious.(cid:3)(cid:3) ∈ A S((cid:2)(cid:3))In these terms, the abstract answer sets of the first abstract program constructed in Example 2.4 are all concrete, while if we drop all atoms involving nodes 1, 2, 3, 4 from the graph in Fig. 2, the abstract answer sets of the resulting abstract program are all spurious.7Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 1035632greengreen2blue31red1red1redFig. 3. Abstraction refinement upon spurious graph colorings.uncolorable3421Input: (cid:2), mStep 1Construct (cid:2)(cid:3)Step 2A S((cid:2)(cid:3))(cid:13)= ∅?yesnoOutput: (cid:2)(cid:3), mGet IStep 3(cid:3)A S((cid:2)(cid:3))from Step 5Refine mnoStep 4(cid:3)Iis concrete?yesOutput: (cid:3)(cid:2)(cid:3), m, IFig. 4. Abstraction & Refinement Methodology.2.2.1. Abstraction refinement methodologyTo get rid of spurious abstract answer sets, the abstraction mapping m needs to be refined to a more fine-grained abstraction; in case of omission abstraction, the refinement would be to add back some of the omitted atoms.We consider a CEGAR-style [25] abstraction refinement approach which refines an initial abstraction repeatedly until a concrete solution is found or inconsistency (i.e., absence of solutions) is detected.Before describing the general methodology, we first illustrate the idea with the graph coloring example.Example 2.5 (ctd). Fig. 3 shows the abstraction of omitting 7 of the 8 nodes and their edges. Deciding on a color for the remaining node is easy. However, in the original domain, no coloring can match node 1 colored red as the graph is uncolorable. A refinement of this abstraction would be to add back some of the nodes and the knowledge about the edges. Until an abstraction is achieved where the four nodes causing the uncolorability are distinguished, a spurious coloring always occurs.exists. If in turn the abstract program (cid:2)(cid:3)Fig. 4 depicts the methodology introduced in [110]. For a program (cid:2), we start with an initial abstraction mapping m to construct an abstract program (cid:2)(cid:3)(Step 1) that over-approximates the original program (cid:2) and then compute the abstract answer sets. Over-approximation guarantees that if (cid:2) has an answer set I , then a corresponding abstract answer set m(I)of the abstract program (cid:2)(cid:3)has no answer set (Step 2), by Proposition 2.1 (cid:2) is unsatisfiable. In this case, the abstract program (cid:2)(cid:3)and the mapping m are returned. When we pick an abstract answer is concrete, it shows a solution to (cid:2); in this case, the set Iabstract program (cid:2)(cid:3)(cid:3)is spurious, we refine the abstraction mapping m to m(Step 5) and loop back to Step 1. This loop continues until either a picked abstract answer set is concrete, or the abstract program has no answer sets. Termination is guaranteed as in the extreme case m is refined to the trivial identity mapping, i.e., each element of the original domain is mapped to itself; (cid:2)(cid:3)will coincide with (cid:2). Thus, if (cid:2) is unsatisfiable, the procedure will stop at Step 2, otherwise at Step 4.(cid:3) ∈ A S((cid:2)(cid:3)) (Step 3), we check for concreteness (Step 4). If I, the mapping m and the concrete abstract answer set Iare returned. If I(cid:3)(cid:3)(cid:3)In the next section, we introduce the new abstraction method to be used in Step 1. We investigate an abstraction over non-ground ASP programs given a mapping over their domain (i.e., the Herbrand universe) that singles out the domain elements. The correctness checking of an abstract answer set (Step 4) and then deciding on a refinement (Step 5) is done using a debugging approach which is introduced in Section 4.8Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 1035633. Domain abstractionThe omission-based abstraction approach in [110,111] is propositional in nature and does not account for the fact that in ASP, non-ground rules talk about a domain of discourse, where for the (non)existence of an answer set, the precise set of elements may not matter, but rather how certain elements are related. For example, the graph coloring encoding (2)expresses that each node should be colored differently from its neighbors. The names of the neighbor nodes are not relevant to the color determination, rather the relation of having a neighbor with a certain chosen color.In this section, we tackle the issue of automatically constructing and evaluating a suitable abstract program (cid:2)(cid:3)given non-ground ASP program (cid:2) with an abstraction over its domain.To illustrate the abstraction and its various challenges, we use the following example.Example 3.1 (running example). Consider the following example program (cid:2) with domain D = {1, . . . , 5}:a(1). a(3). c(2). d(5).b(X, Y ) ← a(X), d(Y ).e(X) ← c(X), a(Y ), X (cid:13)= Y .⊥ ← b(X, Y ), e(X).for a (3)(4)(5)(6)Note that (cid:2) has the answer set I = {a(1), a(3), d(5), c(2), b(1, 5), b(3, 5), e(2)}.The abstraction mapping is defined over the Herbrand universe of (cid:2), called domain, by merging the constants.Definition 3.1. Given a domain D of (cid:2), a (domain abstraction) mapping is a surjective function m : D → (cid:3)D for a set (cid:3)D (the abstracted domain).Thus, a domain abstraction mapping divides D into clusters {dˆd ∈ (cid:3)D. If unambiguous, we also write ˆd for its cluster m−1(ˆd).(cid:3) ∈ D | m(d(cid:3)) = ˆd} of elements that are seen as equal, where Example 3.2 (ctd). The Herbrand universe for the program (cid:2) is HU(cid:2) = {1, 2, 3, 4, 5}. A possible mapping for (cid:2)with (cid:3)D1 = {k1, k2, k3} clusters 2, 3 to the element k2, 4, 5 to the element k3 and 1 to singleton cluster k1, i.e., m1 = {{1}(cid:17)→k1, {2, 3}(cid:17)→k2, {4, 5}(cid:17)→k3}.2 A naive mapping is m2 = {{1, . . . , 5}(cid:17)→k} with (cid:3)D2={k}.Abstracting the elements in the Herbrand universe induces an abstraction of the Herbrand base. Each domain abstraction mapping m naturally extends to ground atoms α = p(v 1, . . . , vn) bym(α) = p(m(v 1), . . . , m(vn));we say that α is mapped to a singleton cluster if |m−1(m(α))| = 1, and is mapped to a non-singleton cluster otherwise.Example 3.3 (ctd). In the Herbrand base HB(cid:2) the atoms with the predicates a, b, c, d, e will also be modified according to m, i.e., a(1), b(1, 5), e(2) get changed to a(k1), b(k1, k3), e(k2); a(1) is mapped to a singleton cluster while b(1, 5), e(2) are mapped to non-singleton clusters.Given a program (cid:2) and an induced mapping m : A → ˆA from the Herbrand base A of (cid:2) to ˆA = m(A) = {m(α) | α ∈ A}, we want an abstract program (cid:2)(cid:3)that achieves over-approximation as in Definition 2.4. However, even in the ground case, simply applying m to (cid:2) does not work in general. Moreover, we want domain abstraction that for non-ground (cid:2) results in a non-ground program (cid:2)(cid:3)turns out to be challenging and needs to solve several issues, which we discuss in the next section.. Building a suitable (cid:2)(cid:3)3.1. Towards an over-approximationGiven a mapping m that describes an abstraction over the domain of a program (cid:2), we start with the intuition of applying m to each rule, i.e., each atom in a rule is modified according to m, in order to obtain an abstraction (cid:2)(cid:3)of (cid:2).To this end, we extend the mapping m to the non-ground case as follows.2 By abuse of notation, we write {e1, . . . , en}(cid:17)→ˆd for e1(cid:17)→ˆd, . . . , en (cid:17)→ ˆd, where {e1, . . . , en} = m−1(ˆd).9Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Definition 3.2 (extended non-ground mapping). For any domain mapping m: D → (cid:3)D, we let m( X) = X for each X ∈ X (i.e., variables remain unchanged). Furthermore, we extend m to atoms α = p(t1, . . . , tn), negated atoms not α, and sets L of literals by m(p(t1, . . . , tn)) = p(m(t1), . . . , m(tn)), m(not α) = not m(α), and m(L) = {m(λ) | λ ∈ L}, respectively.One may think that simply keeping the rules in (cid:2) and considering the abstract domain for evaluation should be enough to achieve an over-approximation. However, this does not hold in general.Example 3.4 (ctd). If we keep the (non-fact) rules (4)-(6) in the program (cid:2) the same, but lift the domain and the facts to (cid:3)D1 with the mapping m1, the resulting program becomes unsatisfiable. Indeed, lifting the facts yields a(k1), a(k2), c(k2), and d(k3). Thus rule (4) derives b(k1, k3) and b(k2, k3), while rule (5) derives e(k2). Consequently, the constraint (6) fires for X = k2 and Y = k3. If we lift the domain to (cid:3)D3 = {k1, k2} with the mapping m3 = {{1, 2, 3}(cid:17)→k1, {4, 5}(cid:17)→k2}, then the resulting program has the answer set {a(k1), d(k2), c(k1), b(k1, k2)} as lifting the facts yields a(k1), c(k1), and d(k2), from which rule (4) derives b(k1, k2) while rules (5) does not fire. The original answer set I is not mapped to this abstract answer set as m3(e(2)) = e(k1) does not occur in it.We will now look into why the naive approach may fail to achieve over-approximation and present the idea of our approach to deal with the arising issues.If we consider the rule (4), then keeping this rule unchanged in the abstraction does not cause issues: it ensures that b( X, Y ) holds true in the answer set whenever a( X) and d(Y ) hold true, where X and Y can take any value. This is similar for rules in which the arguments of body literals are unconstrained, i.e., they can take independently of each other any value from the domain and no (in)equality relations occur in the body. Issues arise if this is not the case.Shared arguments. Arguments in a rule body that are shared may cause an issue depending on the abstraction mapping. This is because if an atom p(k) in the abstract program holds true for a cluster k, then this represents that for some, but not necessarily all, original domain elements x in the cluster k the atom p(x) holds true. If another atom q(k) occurs in the (cid:3)) might have different truth body, then both p(k) and q(k) might be true while for some x, xvalues, and the original rule would not fire. Hence the interaction of shared arguments at the abstract level must be treated by considering different cases of how the involved predicates might behave at the original level.in k the atoms p(x) and q(x(cid:3)Instead of doing this ad hoc, we adopt a uniform approach in which the treatment is relegated to auxiliary atoms. To this end, we are standardizing apart the shared arguments, which effects that non-relation literals can remain untouched.Example 3.5 (ctd). The constraint (6), i.e., ⊥ ← b( X, Y ), e( X), has a shared use of the variable X . If the constraint is kept the same, then for the mapping m1 the rules (4) and (5) derive b(k2, k3) and e(k2) from a(k2), d(k3) and c(k2), a(k1), respectively. As (6) excludes that both b(k2, k3) and e(k2) are true, no abstract answer set exists. This issue arises as k2 ={2, 3} is a non-singleton cluster and for X = k2, Y = k3 not every atoms b(x, y) and e(x) that are mapped to b(k2, k3) and e(k2), respectively, hold both true in the original answer set, e.g., b(3, 5), e(2). We address this by standardizing apart the multiple occurrence of X , i.e., we replace its second occurrence by a fresh variable X1 that is equated to X , leading to the rule⊥ ← b(X, Y ), e(X1), X = X1.(7)In this way, the focus of abstraction is directed towards the relation, i.e., X = X1, in the rule.In a similar way, also constants that may interact with other arguments in rule bodies are standardized apart. Details are given in Section 3.1.1.(In)equality relation over the abstract domain. The domain clustering might cause that (in)equality relations in the abstract domain fail to hold in the original domain, resulting in an uncertainty to be treated in the abstraction process.Example 3.6 (ctd). The uncertainty caused by applying relation = on the abstract domain is observed in Example 3.5, where although k2 = k2 holds in the abstraction, not all elements mapped to k2 satisfy this relation, e.g., 2 (cid:13)= 3.Consider now the rule (5) and the domain (cid:3)D3 with the mapping m3 from Example 3.4. There we saw that simply keeping the rules results in an abstract answer set which does not contain e(k1). This happens since having a(k1) and c(k1) makes rule (5) inapplicable as k1 (cid:13)= k1 does not hold true. However, there are elements mapped to k1 for which relation (cid:13)= holds in the original domain, e.g., 2 (cid:13)= 3.Table 1 shows all the cases of the behavior of the relations in the abstract domain for particular mappings.In Section 3.1.2, we handle such uncertainties caused by domain clusters by assigning types to the relations with respect to the mappings. For example, we will refer to the case where X = X1 holds true in the abstract program while not all elements mapped to X, X1 satisfy = as type III. The case where X (cid:13)= Y is false while in the original domain some elements mapped to X, Y satisfy (cid:13)= will be referred to as type IV. For these cases, we turn the head of a rule into a choice in order to capture the possible firing and the non-firing of the original rule in alternative abstract answer sets.10Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Table 1Behavior of the relations =, (cid:13)= in (cid:3)D 1 with the mapping m1, and in (cid:3)D 3 with the mapping m3, assuming symmetry.(cid:13)=k1 (cid:13)= k31 (cid:13)= 41 (cid:13)= 5k2 (cid:13)= k32 (cid:13)= 42 (cid:13)= 53 (cid:13)= 43 (cid:13)= 5=k2 = k22 = 23 = 32 (cid:13)= 3k2 = k24 = 45 = 54 (cid:13)= 5(cid:3)D 1D(cid:3)D 3Dk1 = k11 = 1k1 = k11 = 12 = 23 = 31 (cid:13)= 21 (cid:13)= 32 (cid:13)= 3k3 = k34 = 45 = 54 (cid:13)= 5k1 (cid:13)= k21 (cid:13)= 21 (cid:13)= 3k1 (cid:13)= k21 (cid:13)= 41 (cid:13)= 52 (cid:13)= 42 (cid:13)= 53 (cid:13)= 43 (cid:13)= 5Default negation. For non-singleton clusters, negative literals may also result in losing an original answer set. This is because default negation has issues with uncertainty, similar to (in)equality relations. However, an important difference is that the interpretation of relations depends on the domain, thus they can be evaluated and removed from a program during the instantiation process. So the treatment by looking at the behavior of the relations in the abstract domain for a mapping is capable of handling the uncertainty. This is not possible for defined predicates, since when constructing an abstract program (cid:2)(cid:3)from (cid:2), the original program reduct (cid:2)I , for each answer set I of (cid:2), must be appropriately reflected, such that no answer set I gets lost.Example 3.7 (ctd). Suppose we modify the rule (4) by adding default negation in front of d:b(X, Y ) ← a(X), not d(Y ), dom(Y ).(8)The answer set of the modified program (cid:2) is then I = {a(1), a(3), d(5), c(2), b(1, 1), . . . , b(1, 4), b(3, 1), . . ., b(3, 4), e(2)}. When the modified rule remains unchanged by abstraction in (cid:2)(cid:3), we obtain with the mapping m3 = {{1, 2, 3}(cid:17)→k1, {4, 5}(cid:17)→k2} in the abstract domain (cid:3)D3 the answer set I(cid:3) = {a(k1), d(k2), c(k1), b(k1, k1)}, which for the atoms b(1, 4) and e(2) does not contain their abstractions m3(b(1, 4)) = b(k1, k2) and m3(e(2)) = e(k1). The reason is that not d(k2) is false in (cid:3)I, and hence the body of the rule (8) is not satisfied. This makes the reduct (cid:2)(cid:3) Icontain for (8) only the rule(cid:3)b(k1, k1) ← a(k1), dom(k1).and no rule with k2. However, if we look at the cluster k2 = {4, 5}, even though the literal not d(5) is false in the original answer set I , still not d(4) is true in I . So the original reduct (cid:2)I also has the rulesb(1, 4) ← a(1), dom(4).b(3, 4) ← a(3), dom(4).for (8), which are not represented in (cid:2)(cid:3) I(cid:3).The example shows that having a negative literal not α false, i.e., α true in an abstract interpretation Idoes not allow mapped to α are true in an original interpretation I , even if I is an answer set. However, is mapped to α; the latter is ensured if each argument ˆdi of α = p(ˆd1, . . . , ˆdn) is a us to conclude that all atoms α(cid:3)it would be possible if only one atom α(cid:3)singleton cluster.(cid:3)We deal with this issue by adding a rule for non-singleton clusters, where in the original rule the polarity of not α is shifted and the head is turned into a choice. Specifically, for the rule (8) above, the rule{b(X, Y )} ← a(X), d(Y ), not isSingleton(Y ).(9)will be added in the abstract program; here isSingleton is an auxiliary predicate that will be introduced in Section 3.2.In conclusion, we need a fine-grained systematic approach to deal with uncertainties. Furthermore, for Example 3.7 the treatment described above would be sufficient, since the predicate d is not defined in terms of other predicates. One has to pay a particular attention to cycles through negation, which, as well-known in ASP, may create alternative answer sets.11Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Table 2Cases for lifting a binary relation ◦ ∈ {=, (cid:13)=} from D to (cid:3)D according to a map-ping m : D → (cid:3)D and applying the relation to some ˆd1, ˆd2 ∈ (cid:3)D. The symbol ◦stands for the complement of the relation ◦.I (ˆd1, ˆd2) : ˆd1 ◦ ˆd2 ∧ ∀x1 ∈ mτ ◦II (ˆd1, ˆd2) : ˆd1 ◦ ˆd2 ∧ ∀x1 ∈ mτ ◦III(ˆd1, ˆd2) : ˆd1 ◦ ˆd2 ∧ ∃x1 ∈ mτ ◦IV(ˆd1, ˆd2) : ˆd1 ◦ ˆd2 ∧ ∃x1 ∈ mτ ◦−1(ˆd1), ∀x2 ∈ m−1(ˆd1), ∀x2 ∈ m−1(ˆd1), ∃x2 ∈ m−1(ˆd1), ∃x2 ∈ m−1(ˆd2). x1 ◦ x2−1(ˆd2). x1 ◦ x2(cid:4)−1(ˆd2). x1 ◦ x2−1(ˆd2). x1 ◦ x2(cid:4)certain casesuncertain cases3.1.1. Standardizing apartA rule is standardized apart if all non-relational atoms (i.e., those with predicates not in {=, (cid:13)=, dom}) contain only vari-ables and no two non-relational atoms share a variable. In order to allow for a uniform treatment of the interaction of arguments in rule bodies for abstraction, rules are rewritten as follows. Suppose r : α ← B(r) is a rule of form (1). Then the following steps are performed as long as possible:1. If a variable X occurs in non-relational atoms αi = pi(ti) ∈ B(cid:3)j , respectively, then replace t j in α2 with a fresh variable Xi and t2t1allowed but then i (cid:13)= j is required, i.e., X occurs in the same atom α at different argument positions i and j.−(r), i = 1, 2, i.e., p1, p2 /∈ {=, (cid:13)=, dom}, as to the rule body; here, α1 = α2 is +(r) ∪ Band add X = X1, . . . , tini(cid:3)2. If a constant symbol c occurs in a non-relational atom α = p(t1, . . . , tn) ∈ B(cid:3)and add X(cid:3) = c to the rule body.replace t j in α with a fresh variable X+(r) ∪ B−(r), where p (cid:13)= dom, as t j , then If none of the steps 1-2 is applicable, r is standardized apart.Example 3.8 (ctd). Applying the above procedure to the rule (6), we obtain the standardized apart form (7). The ruleq(X) ← p(X, X, Z ), q(Y , W ), not r(3, Y , V ), dom(V ), Z (cid:13)= 1, Y (cid:13)= W .is standardized apart by rewriting the second occurrence from left of X , of Y , and the occurrence of 3 in this order:q(X) ← p(X, X1, Z ), q(Y , W ), not r(Y 2, Y 1, V ), dom(V ), Z (cid:13)= 1, Y (cid:13)= W , X = X1, Y = Y 1, Y 2 = 3.(10)(11)Clearly, any rule r can be transformed into standardized apart form, which is equivalent under answer set semantics, in linear time; the order in which the steps are applied and the choice of variables and their occurrence does not matter. Notably, as a result, all arguments of non-relational atoms different from dom atoms are distinct variables; we do not need to standardize the arguments of dom literals apart, as both in the original domain D and in the abstract domain D, every dom atom always evaluates to true.3.1.2. Lifted equality relationAs shown above, the (in)equality relations in the rules may cause issues in the abstraction process. To deal with them, we focus on rules r of the formr : l ← Bstd(r), (cid:6)rel(r)(12)where Bstd(r) are the non-relation atoms standardized apart, and (cid:6)rel consists of relation atoms that constrain the variables in Bstd(r). If r contains no relation, then (cid:6)rel = (cid:16); an arbitrary rule r is easily rewritten to this form. We use B std,+(resp. Bstd,−) to refer to positive (resp. negative) non-relational literals standardized apart.The uncertainty that arises during the abstraction is caused by relation restrictions over non-singleton clusters (cid:3)d (i.e., |(cid:3)d| > 1) or by negative literals mapped to non-singleton abstract literals. In order to address the uncertainty due to relation restrictions in the rules, we consider a notion of relation types with respect to the abstraction. For simplicity, we focus on a binary relation ◦ ∈ {=, (cid:13)=} and a relation part (cid:6)rel(r) with at most one relation atom. Later in Section 3.3, we show how other forms of relations can be addressed.When the relation ◦ is lifted to the abstract domain (cid:3)D, applying the relation to some ˆd1, ˆd2 ∈ (cid:3)D with ˆd1 ◦ ˆd2 may result in outcomes different than in the original domain, depending on the mapping, as we have seen in Example 3.6 and Table 1.II , are the cases of no uncertainty; they hold for abstract elements ˆd1, ˆd2 if the relation ˆd1 ◦ ˆd2 is true resp. false and if for every original elements x1, x2 mapped to ˆd1, ˆd2, respectively, that x1 ◦ x2 is true resp. false in the original domain as well.Table 2 shows the computation of the facts representing these types for a relation ◦. Type I, τ ◦I , and type II, τ ◦Example 3.9. Consider the mapping m1 = {{1}(cid:17)→k1, {2, 3}(cid:17)→k2, {4, 5}(cid:17)→k3} in Table 1. The relation k1 = k1 holds and for any x1, x2 ∈ k1 = {1}, x1 = x2 holds and type I applies for having k1 = k1 true. Further, k1 = k2 does not hold, i.e., k1 (cid:13)= k2, and for any x ∈ k1 = {1} and y ∈ k3 = {2, 3}, x = y does not hold and so type II applies for k1 = k2 false.12Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563As for the relation (cid:13)=, we have that k1 (cid:13)= k2 holds true, and for x ∈ k1 = {1} and y ∈ k3 = {2, 3}, x (cid:13)= y holds true, so type I applies for having k1 (cid:13)= k2 true. Further, the relation k1 (cid:13)= k1 does not hold, and for any x1, x2 ∈ k1 = {1}, x1 (cid:13)= x2 does not hold and type II applies for having k1 (cid:13)= k1 false.As for type III and type IV in Table 2, they are the cause for uncertainty. Type III, τ ◦IV) holds for the abstract elements ˆd1, ˆd2 when ˆd1 ◦ ˆd2 is true (resp. is not true), but for some x1, x2 that can be mapped to ˆd1, ˆd2, x1 ◦ x2does not hold true (resp. holds true) in the original domain.III, (resp. Type IV, τ ◦Example 3.10 (Example 3.9 ctd). Consider again the mapping m1 in Table 1. The relation k2 = k2 holds but for some x1, x2 ∈k1 = {2, 3}, x1 = x2 does not hold, e.g., 2 (cid:13)= 3, thus type III applies. Further, k2 (cid:13)= k2 does not hold, i.e., k2 = k2, but for some x, y ∈ k2 = {2, 3}, x (cid:13)= y does hold, e.g., 2 (cid:13)= 3 and so type IV applies.If ˆd1 ◦ ˆd2 holds for some ˆd1, ˆd2 ∈ (cid:3)D, type III is more common in practice in domain abstractions with clusters due to the standardization and as the relation = often occurs, while type I occurs for singleton mappings (i.e., |ˆd1| = |ˆd2| = 1) or for the relation (cid:13)=. If ˆd1 ◦ ˆd2 does not hold for some ˆd1, ˆd2 ∈ (cid:3)D, type II is common (again as the relation =), whereas type IV may occur for the relation (cid:13)=. In order to refer to the abstract relation atoms, we introduce the following notation.Definition 3.3 (Tm). For an abstraction m, we let Tm be the set of all atoms τ ◦binary relation ˆd1 ◦ ˆd2 for m.ι (ˆd1, ˆd2) where ι ∈ {I, . . . , IV} is the type of the We remark that Tm is easily computed. Armed with these techniques, we now proceed to construct an abstract program for a given program (cid:2) and an abstraction mapping m, where we use Tm as facts.Example 3.11 (Example 3.9 ctd). For the mapping m1 shown in Table 1, we have the factsTm1= {τ =I (k1, k1), τ =. . . , τ(cid:13)=I (k1, k2), τIII (k2, k2), τ =III (k3, k3), τ =II (k1, k2), τ =II (k1, k3), τ =(cid:13)=I (k1, k3), τ(cid:13)=I (k2, k3), . . . , τ(cid:13)=II (k1, k1), τII (k2, k3),(cid:13)=(cid:13)=IV (k3, k3)}.IV (k2, k2), τ3.2. Abstract program constructionBy our analysis in Section 3.1, the basic idea to construct an abstract program (cid:2)(cid:3)for a program (cid:2) with a domain mapping m is as follows. We either just abstract each atom in a rule, or in case of uncertainty due to domain abstraction, we guess rule heads to catch possible cases, or we treat negated literals by shifting their polarity depending on the abstract domain clusters.We use an auxiliary fact isSingleton(ˆd) for the abstract domain elements ˆd ∈ (cid:3)D to denote that ˆd is a singleton cluster, i.e., −1(ˆd)| = 1. These atoms can also be used to represent whether an abstract atom m(α) is a singleton cluster, i.e., no other exists such that m(α(cid:3)) = m(α): if every term t ∈ arg(m(α)) satisfies isSingleton(t), then m(α) is a singleton cluster, |matom α(cid:3)otherwise not.Example 3.12 (Example 3.1 ctd). Consider the domain mapping m1 = {{1}(cid:17)→k1, {2, 3}(cid:17)→k2, {4, 5}(cid:17)→k3}. For the abstract domain, we have isSingleton(k1). For the literals, the singleton clusters are a(k1), c(k1), d(k1), e(k1) and b(k1, k1), while the remaining literals are non-singletons.We remark that due to their definition, if either τ ◦III(ˆd1, ˆd2) or τ ◦IV(ˆd1, ˆd2) holds true for some ˆd1, ˆd2 ∈ (cid:3)D, this means that either ˆd1 or ˆd2 is a non-singleton cluster.For ease of presentation and a systematic treatment of the issues that we have identified in Section 3.1, we shall first deal in Section 3.2.1 with programs under restrictions, which are then gradually lifted in Section 3.2.2 to arrive at arbitrary programs.3.2.1. Restricted caseWe first consider programs (cid:2) with rules that fulfill the following conditions:(R-1) Unique negative literal. Each rule has at most one negative body literal.(R-2) Unique relation atom. Each rules has no or a single, binary relation atom.(R-3) No negative cycles. There are no negative cyclic dependencies between non-ground literals occurring in (cid:2).For rules r with no relation, i.e., (cid:6)rel = (cid:16), we introduce for convenience a dummy relation rel(cid:16)( X, Y ) that holds for all pairs of elements of the domain D and add in the body of r an atom rel(cid:16)( X, Y ); in every lifting of rel(cid:16) from D to (cid:3)D by 13Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563some mapping m, the relation type τ rel(cid:16)for all other types. We then can assume that rules have a single binary relation atom t1 ◦ t2 in the body.(ˆd1, ˆd2) similar as in Table 2 will for all ˆd1, ˆd2 ∈ (cid:3)D be true for type T = I and false TWe next define how to construct from a given rule r an abstract (set of) rule(s) rm.Definition 3.4 (rule abstraction rm). Given a rule r : α ← Bstd(r), t1 ◦ t2 as above and a domain mapping m, the set rm con-tains the following rules:(a) m(α) ← m(Bstd(r)), m(t1) ◦ m(t2), τ ◦(b) {m(α)} ← m(Bstd(r)), m(t1) ◦ m(t2), τ ◦(c) {m(α)} ← m(Bstd(r)), m(t1) ◦ m(t2), τ ◦(d) For every t ∈ arg(αi) where Bstd,−(r) = {αi}:III(m(t1), m(t2)).IV(m(t1), m(t2)).I (m(t1), m(t2)).(i) {m(α)} ← m(Bshαi(ii) {m(α)} ← m(Bshαi(r)), m(t1) ◦ m(t2), not isSingleton(m(t)).(r)), m(t1) ◦ m(t2), τ ◦IV(m(t1), m(t2)), not isSingleton(m(t)).where Bshαi(r) = Bstd,+(r) ∪ {αi}.In step (a), we have the case of no uncertainty due to abstraction. Steps (b) and (c) are for the cases of uncertainty due to the behavior of the relations. The head becomes a choice, and for case IV, we flip the relation, ◦, in order to catch the case where the relation holds true (which actually is the reason for the uncertainty). No rules are added for case II, since the body of the rule will never be satisfied as the relation does not hold true in the abstract domain (similar as in the original domain). As for constraints (e.g., (6)), we note that m(⊥) = ⊥. Consequently, in (a) the head is unchanged; as an optimization, all other steps (b)-(d) can be omitted, since the choice {⊥} is ineffective (we always can choose that ⊥ is false). Recall that the lifted relation rel(cid:16) will only have type I, thus for rel(cid:16)(t1, t2) only the rules in steps (a) and (d.i) in case must be added, where rel(cid:16)(m(t1), m(t2)) and τ rel(cid:16)(m(t1), m(t2)) can be omitted as they are always true.IExample 3.13 (ctd). The abstract rules for (5) and (7) (the standardized apart version of (6)) becomee(X) ← c(X), a(Y ), X (cid:13)= Y , τ{e(X)} ← c(X), a(Y ), X (cid:13)= Y , τ{e(X)} ← c(X), a(Y ), X = Y , τ(cid:13)=I (X, Y ).(cid:13)=III (X, Y ).(cid:13)=IV (X, Y ).(13)(14)(15)⊥ ← b(X, Y ), e(X1), X = X1, τ =Here the rule (14) can be omitted as X (cid:13)= Y , τbody is unsatisfiable.I (X, X1).(cid:13)=III ( X, Y ) is unsatisfiable (since X (cid:13)= Y cannot have type III) and thus the rule (16)In step (d) of Definition 3.4, we grasp the uncertainty arising from negation by adding rules that shift the negative literal only if it shares arguments that are mapped to a non-singleton cluster.Example 3.14 (ctd). The abstract rules for the rule (8) in Example 3.7 with a default negated literal will then be3b(X, Y ) ← a(X), not d(Y ), dom(Y ).{b(X, Y )} ← a(X), d(Y ), not isSingleton(Y ).(17)(18)We remark that simply omitting all default negated literals in the abstract rule is also possible. However, this would then cause to trigger choice rules in every case, thus resulting in more abstract answer sets than necessary, as shown below.Example 3.15. Let the rule (8) in Example 3.7 contain in addition the relation X (cid:13)= Y :b(X, Y ) ← a(X), not d(Y ), X (cid:13)= Y , dom(Y ).If instead of adding the ruleb(X, Y ) ← a(X), not d(Y ), X (cid:13)= Y , τ(cid:13)=I (X, Y ).we would omit d(Y ) and turn the head into a choice, thus have(19)(20)3 When the negated literal contains more than one argument, rules of form (18) will be added for each argument.14Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563{b(X, Y )} ← a(X), X (cid:13)= Y , not isSingleton(Y ), dom(Y ).,(21)then for the case where Y is a cluster while X (cid:13)= Y holds true, the choice would unnecessarily trigger even if actually not d(Y ) was true. To see this, consider the mapping m = {{1} → k1, {2, . . . , 5} → k2}. The original program with the rule (19) has the answer set I = {a(1), a(3), d(5), c(2), b(1, 2), b(1, 3), b(1, 4), b(3, 1), b(3, 2), b(3, 4), e(2)}. Even though in the abstract program the fact d(k1) does not exist, the added choice rule (21) causes a guess on b(k2, k1) which results in four (cid:3) = {a(k1), a(k2), c(k2), d(k2), e(k2), b(k1, k2), b(k2, k2)}. spurious answer sets not containing b(k2, k1), one of them being IAdding instead the rule (20) in the abstract program avoids these spurious answer sets.Distinguishing the different cases helps to avoid unnecessary answer sets when actually no uncertainty is caused. Thus, the abstract rules for (19) would beb(X, Y ) ← a(X), not d(Y ), X (cid:13)= Y , τ{b(X, Y )} ← a(X), not d(Y ), X = Y , τ{b(X, Y )} ← a(X), d(Y ), X (cid:13)= Y , not isSingleton(Y ).{b(X, Y )} ← a(X), d(Y ), X = Y , τ(cid:13)=I (X, Y ).(cid:13)=IV (X, Y ).where again the rule for case (b) is omitted ( X (cid:13)= Y , τ(cid:13)=IV (X, Y ), not isSingleton(Y ).(cid:13)=III ( X, Y ) is unsatisfiable).(22)(23)(24)(25)Semantically, the rules added in steps (a)-(b) of Definition 3.4 are to ensure that each model I of (cid:2) carries over to a model m(I) of the rule abstraction, as either the original rule is kept or changed to a choice rule. As regards an answer set I , steps (c)-(d) serve to catch in particular the cases that may violate the minimality in the abstraction due to a negative literal or a relation over non-singleton clusters. The abstract program is now as follows.Definition 3.5 (abstract program (cid:2)m, restricted case). Given a (standardized apart) program (cid:2) as above and a domain abstrac-tion m, the abstract program for m, denoted (cid:2)m, consists of the rules(cid:5)(cid:2)m =r: α←Bstd(r),t1◦t2∈(cid:2)rm ∪ {x. | x ∈ Tm} ∪ {m(p((cid:22)c)). | p((cid:22)c). ∈ (cid:2)} ∪ {isSingleton(ˆd) | |m−1(ˆd)| = 1}.(26)Notably, the construction of (cid:2)m is modular, rule by rule. The following result states that this abstraction works.Theorem 3.1 (restricted program abstraction). Let m be a domain mapping of a (standardized apart) program (cid:2) under the above assumptions (R-1)–(R-3). Then for every I ∈ AS((cid:2)), it holds that m(I) ∪ Tm ∈ AS((cid:2)m).The proof of this result proceeds along the intuition above more formally, where for showing that the abstraction m(I)of an answer set I is a minimal model also recursive dependencies through negative literals ought to be considered. Since no negative cyclic dependencies between ground literals exist, counterexamples to minimality along such dependencies can be excluded.3.2.2. General caseWe now describe how to remove the restrictions (R-1)–(R-3) on programs from above.(G-1) Multiple negative literals. If rule r has multiple negative literals, i.e., |Bshares arguments that are mapped to a non-singleton cluster. Thus, instead of shifting one literal αi ∈ B−(r).shifting multiple literals L ⊆ B−(r) at a time and all combinations of (non-)shifting the literals in B−(r)|>1, we shift each negative literal that −(r), we consider Definition 3.6 (treating multiple negative literals). Step (d) of Definition 3.4 is modified as(d) For each L = {α1, . . . , αn} ⊆ Bstd,−(r), n ≥ 1 and each t1, . . . , tn where ti ∈ arg(αi), i = 1, . . . , n:(i) {m(α)} ← m(Bsh(ii) {m(α)} ← m(BshL (r)), m(t1) ◦ m(t2), not isSingleton(m(t1)), . . . , not isSingleton(m(tn)).L (r)), m(t1) ◦ m(t2), τ ◦IV(m(t1), m(t2)), not isSingleton(m(t1)), . . . , not isSingleton(m(tn)).where BshL (r)=Bstd,+(r) ∪ L, not (Bstd,−(r)\L).Shifting all the negated atoms L is for the case where all these atoms give rise to non-singleton clusters, which occurs when for each atom αi some argument ti is mapped to a non-singleton cluster; in the original domain, the negative rule body on L could thus evaluate to true and the rule could possible fire. The rules added for all arguments t1, . . . , tn ensure that all cases are covered. Steps (d.i) and (d.ii) coincide with steps (d.i) and (d.ii) of Definition 3.4, respectively.15Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Table 3(cid:3)Cases for lifting an n-ary relation rel.(cid:3)(ˆd1, . . . , ˆdn) :τ relrelI(cid:3)(ˆd1, . . . , ˆdn) : ¬relτ relII(cid:3)III (ˆd1, . . . , ˆdn) :τ relrel(cid:3)IV (ˆd1, . . . , ˆdn) : ¬relτ rel(cid:3)(cid:3)(cid:3)(cid:3)(ˆd1, . . . , ˆdn) ∧ ∀x1 ∈ m(ˆd1, . . . , ˆdn) ∧ ∀x1 ∈ m(ˆd1, . . . , ˆdn) ∧ ∃x1 ∈ m(ˆd1, . . . , ˆdn) ∧ ∃x1 ∈ m(cid:3)−1(ˆd1), . . . , ∀xn ∈ m−1(ˆd1), . . . , ∀xn ∈ m−1(ˆd1), . . . , ∃xn ∈ m−1(ˆd1), . . . , ∃xn ∈ m−1(ˆdn). rel−1(ˆdn). ¬rel−1(ˆdn). ¬rel−1(ˆdn). rel(cid:3)(x1, . . . , xn)(cid:3)(x1, . . . , xn)(x1, . . . , xn)(cid:3)(x1, . . . , xn)Example 3.16. Consider the ruled(X) ← not c(X), not a(X1), X = X1, dom(X), dom(X1).The constructed non-ground abstract rules following step (d.i) of Definition 3.6 will be{d(X)} ←c(X), not a(X1), X = X1, not isSingleton(X), dom(X1).{d(X)} ←not c(X), a(X1), X = X1, not isSingleton(X1), dom(X).{d(X)} ←c(X), a(X1), X = X1, not isSingleton(X), not isSingleton(X1).Step (d.ii) is similarly applied.(G-2) Multiple relation atoms. A simple approach to handle multiple relations, i.e.,(cid:6)rel = t1,1 ◦1 t2,1, .. , t1,k ◦k t2,k, k > 1,is to view it as an atom of an 2k-ary relation relrelations t1,1 ◦1 t2,1, .. , t1,k ◦k t2,k are true, and it is false, i.e., ¬relfalse. The abstract version of such rel(cid:3)(cid:3)(cid:3)(t1,1, t2,1, .. , t1,k, t2,k). The atom rel(t1,1, t2,1, .. , t1,k, t2,k) is true if all (t1,1, t2,1, .. , t1,k, t2,k) is true, if some relation t1,i ◦i t2,i is (cid:3)and the cases I-IV are then lifted from x1, x2 to x1, .. , xn as in Table 3.(27)( X1, X2, X3, X4). If for abstract values ˆd1, .. , ˆd4, (cid:3)Example 3.17. For (cid:6)rel = ( X1= X2, X3= X4), we use a new relation relˆd1 = ˆd2 ∧ ˆd3 = ˆd4 holds, then we have type τI when all ˆdi are singleton clusters and type τIII when some ˆdi is non-singleton; (cid:3)otherwise (i.e., ¬rel(ˆd1, ˆd2, ˆd3, ˆd4) holds) type τII applies.(G-3) Cyclic negative dependencies. Rules which are involved in a negative cyclic dependency need special consideration.Example 3.18 (Example 3.1 ctd). Now consider adding the following rules to the program (cid:2) and removing the facts d(5), c(2).c(X) ← not d(X), dom(X).d(X) ← not c(X), dom(X).(28)(29)These rules create further answer sets for (cid:2) containing different appearances of c and d. The abstract rules will be as follows.c(X) ← not d(X), dom(X).{c(X)} ← d(X), not isSingleton(X).d(X) ← not c(X), dom(X).{d(X)} ← c(X), not isSingleton(X).(30)(31)(32)(33)Now consider an answer set I of (cid:2) which contains d(1), c(2), d(3), c(4), and d(5), and the naive mapping m2 ={{1, . . . , 5}(cid:17)→k}. The mapping ˆI = m(I) of the answer set I contains c(k) and d(k). Although ˆIis a model of ((cid:2)m)I , ei-ther c(k) or d(k) is unfounded; hence ˆI is not minimal, i.e., not an answer set of (cid:2)m . The reason is that the negative cyclic dependency (i.e., “choice”) of c- and d-atoms does not occur for c(k) and d(k) in the constructed (cid:2)m.To resolve this, the literals of (cid:2) that are involved in a negative cycle are treated specially. We can lift the restriction (R-3) in the restricted case as follows.Definition 3.7 (treating negative cyclic dependency). Suppose that Lc1 , . . . , Lcl are all independent sets of literals involved in a negative cyclic dependency. If l > 0, item (d) of Definition 3.4 is changed as follows:(d) For every t ∈ arg(αi) where Bstd,−(r) = {αi}, for every j = 1, . . . , l:16Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563(i) {m(α)} ← m(Bsh(ii) {m(α)} ← m(Bshαi ,Lc j(r)), m(t1) ◦ m(t2), not isSingleton(m(t)).(r)), m(t1) ◦ m(t2), τ ◦IV(m(t1), m(t2)), not isSingleton(m(t)).αi ,Lc jwhere(cid:6)Bshαi ,Lc j(r)=Bstd,+(r) ∪ {αi}Bstd,+(r)if {αi, α} (cid:2) Lc j ,if {αi, α} ⊆ Lc j .In the generalization of step (d) of Definition 3.4, the newly defined Bsh(r) eliminates the atoms αi that are involved in a negative cycle with the head α of the rule r, i.e., {αi, α} ⊆ Lc j for some j, from the body instead of shifting their polarity. Since the sets Lc1 , . . . , Lcl are independent, a rule can be involved with at most one cyclic set Lc j of literals, and thus the cycles can be treated one at a time.αi ,Lc jExample 3.19 (ctd). For the program (cid:2) consisting of the rules (4)-(6) and (28)-(29), the abstract non-ground rules arec(X) ← not d(X), dom(X).{c(X)} ← not isSingleton(X), dom(X).d(X) ← not c(X), dom(X).{d(X)} ← not isSingleton(X), dom(X).b(X, Y ) ← a(X), d(Y ).e(X) ← c(X), a(Y ), X (cid:13)= Y , τ{e(X)} ← c(X), a(Y ), X = Y , τ(cid:13)=I (X, Y ).(cid:13)=IV (X, Y ).(34)(35)(36)(37)(38)(39)(40)⊥ ← b(X, Y ), e(X1), X = X1, τ =(41)For the mapping m = {{1, . . . , 5}(cid:17)→k}, the facts {a(1), a(3)} in (cid:2) get lifted to {a(k)} and the type facts become Tm =(cid:13)={τ =IV (k, k)}. Note that the fact {isSingleton(k)} is not true. The abstract program (cid:2)m consists of all the abstract rules and the mentioned facts. Notice that when the rules are grounded to the relation type facts Tm , only the rules (34)-(38)and (40) remain to be used for the answer set computation.III (k, k), τI (X, Y ).(G-1)–(G-3), i.e., arbitrary programs. Lifting (R-2) to (G-2) can be easily done jointly with lifting (R-1) to (G-1) and (R-3) to (G-3), respectively. The joint lifting of (R-1) and (R-3) is achieved by a generalization of Definition 3.4 that combines the ideas of Definitions 3.6 and 3.7.Definition 3.8 (treating cyclic dependency with multiple negative literals). Suppose that Lc1 , . . . , Lcl are all independent sets of literals involved in a negative cyclic dependency. Then item (d) of Definition 3.4 is changed as in Definition 3.6 if l = 0, and otherwise as follows:(d) For each L = {α1, . . . , αn} ⊆ Bstd,−(r), n ≥ 1, and t1, . . . , tn where ti ∈ arg(αi), i = 1, . . . , n, and for every j = 1, . . . , l:(r)), m(t1) ◦ m(t2), not isSingleton(m(t1)), . . . , not isSingleton(m(tn)).(r)), m(t1) ◦ m(t2), τ ◦IV(m(t1), m(t2)), not isSingleton(m(t1)), . . . , not isSingleton(m(tn)).(i) {m(α)} ← m(BshL,Lc j(ii) {m(α)} ← m(BshL,Lc jwhere(cid:6)BshL,Lc j(r) =Bstd,+(r) ∪ L, not Bstd,−(r) \LBstd,+(r) ∪ (L \ Lc j ), not Bstd,−(r) \Lif α /∈ Lc j or Lc jif α ∈ Lc j and Lc j∩ L = ∅,∩ L (cid:13)= ∅;(42)that is, the negative literals in L get their polarity shifted if they do not occur in some Lc j with the head α of rule r, otherwise they are omitted.As mentioned in Example 3.15, simply omitting all negated literals is also possible, though can cause more spurious abstract answer sets. Thus in Definition 3.6 we considered the positive shift of the negated atoms by considering all combi-nations. As for negated atoms that are involved in a negative cycle with the rule head, Example 3.18 showed that a positive shift on them can prevent over-approximation. Definition 3.8 combines these two insights, and ensures that the atoms in the subset L of Bstd,−(r) are omitted from shifting if they are involved in a cycle with the head, while the remaining atoms in L are shifted. As we consider all subsets L of B std,−(r), we also construct abstract rules where these literals remain untouched.17Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Example 3.20. Consider the rulesc(X) ← not d(X), dom(X).d(X) ← not c(X), not a(X1), X = X1, dom(X), dom(X1).a(X) ← not b(X), dom(X).b(X) ← not a(X), dom(X).(43)with independent cycles Lc1ing step (d.i) of Definition 3.8 will be= {d( X), c( X)} and Lc2= {a( X), b( X)} The constructed non-ground abstract rules of (43) follow-{d(X)} ← not a(X1), X = X1, not isSingleton(X), dom(X), dom(X1).{d(X)} ← c(X), not a(X1), X = X1, not isSingleton(X), dom(X1).{d(X)} ← not c(X), a(X1), X = X1, not isSingleton(X1), dom(X).{d(X)} ← a(X1), X = X1, not isSingleton(X), not isSingleton(X1), dom(X).{d(X)} ← c(X), a(X1), X = X1, not isSingleton(X), not isSingleton(X1).(44)(45)(46)(47)(48)Observe that (44), constructed with Bshof c( X). The rule (46) gets constructed with Bshinvolved in a negative cycle with d( X). The rule (47) is an outcome of Bshis shifted, which is a stronger rule than (48) constructed with Bsh{a( X1)},Lc2{a( X1)},Lc1{c( X)},Lc1and Bsh{a( X1),c( X)},Lc1.{a( X1),c( X)},Lc2, is a stronger rule than (45), constructed with Bsh, due to the omission {c( X)},Lc2, where a( X1) does not get omitted, since it is not where c( X) gets omitted, while a( X1)The non-subsumed rules constructed following step (d.i) of Definition 3.8 then become the rules (44), (46), (47) together with{c(X)} ← not isSingleton(X), dom(X).{a(X)} ← not isSingleton(X), dom(X).{b(X)} ← not isSingleton(X), dom(X).Step (d.ii) is similarly applied.We now have all bits in order to define the abstract version of an arbitrary program (cid:2).Definition 3.9 (abstract program (cid:2)m, general case). Given a (standardized apart) program (cid:2) and a domain abstraction m, the abstract program for m, denoted (cid:2)m, consists of the rules as in (26), where rm for each r ∈ (cid:2) is as in Definition 3.8 (the (cid:3)modified version of Definition 3.4), and multiple relations as in (27) are replaced by a relation relas described in the respective case (G-2).Note that for programs that fulfill the restrictions (R-1)–(R-3), the Definitions 3.9 and 3.5 coincide, and thus (cid:2)m is well-defined. The main result of this section is then as follows.Theorem 3.2 (general program abstraction). Let m be a domain mapping of a (standardized apart) program (cid:2). Then for every I ∈ AS((cid:2)), the abstract interpretation ˆI = m(I) ∪ Tm is an answer set of (cid:2)m.This result is shown by an extension of the proof of Theorem 3.1, in which the more general conditions are taken into account.Example 3.21 (ctd). The constructed abstract program (cid:2)m has the five answer sets ˆI1 = {a(k), d(k), b(k, k)}, ˆI2 ={a(k), c(k)}, ˆI3 = {a(k), c(k), d(k), b(k, k)}, ˆI4 = {a(k), c(k), e(k)}, ˆI5 = {a(k), c(k), d(k), e(k), b(k, k)}. Furthermore, for every answer set I of (cid:2), m(I) is an answer set of (cid:2)m.The abstraction yields in general an over-approximation of the answer sets of a program. The notion of spurious and concrete answer sets amounts to the following.Definition 3.10 (cf. Definition 2.5). An abstract answer set ˆI ∈ AS((cid:2)m) is concrete if there exists an answer set I ∈ AS((cid:2)) such that ˆI = m(I) ∪ Tm, else it is spurious.18Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563A spurious abstract answer set has no corresponding concrete answer set.Example 3.22 (ctd). The abstract answer sets ˆI2 = {a(k), c(k)} and ˆI3 = {a(k), c(k), d(k), b(k, k)} are spurious.3.2.3. Abstract program size vs. over-approximation qualityThe abstract program (cid:2)m in Definition 3.9 can in general be exponentially larger than the original program (cid:2), owing to the fact that dealing with multiple negative literals may introduce for every subset L ⊆ B std,−(r) of the negative literals in a rule r some rules in item (d) of Definition 3.8 respectively 3.6. On the other hand, multiple negative cycles do not cause an exponential blowup, since the number of independent negative cycles is bounded by the number of atoms that occur in the program (cid:2). The items (a)–(c) of Definition 3.8 introduce few rules, which are akin to the original rules and preserve in a way their structure.This blowup seems to be unpleasant, both from a cognitive and a computational perspective. However, it is mitigated by the following observations. First, the rules in item (d) of Definition 3.8 are generated systematically, and one may view them as a subprogram that is expanded on demand, if the user wants to inspect it; this can be similarly exploited for evaluation algorithms that avoid exponential space consumption (see Section 3.5). Second, in many cases the number of negative literals in a rule will be bounded by a constant, which means that no exponential blowup happens. Furthermore, grounding the rules to the relation type facts Tm may remove many of them. The size of the abstract program may also be kept smaller at the price of a weaker over-approximation. Specifically, we may in Definition 3.8 replace each negative cycle Lc j by an arbitrary superset S ⊇ Lc j of literals in (cid:2), while the resulting abstract program (cid:2)m is still an over-approximation of (cid:2). For example, we may choose S = Lc1∪ · · · ∪ Lcl , i.e., merge all negative cycles into one set, which may save half of the rules in item (d) of Definition 3.8. As many programs in practice, including those we considered here, do not have multiple negative cycles, we obtain the same abstraction. In fact, it can be seen that the latter also holds for multiple negative cycles (see Appendix A.1). If we let S be the set of all literals in the program (cid:2), then (42) amounts to replacing systematically negated atoms not αi by cluster information not isSingleton(ti). However, in the worst case, for an unbounded number of negative literals this still incurs an exponential blowup of (cid:2)m.We may avoid this by simply dropping in item (d) from rule r all negative literals, without adding further auxiliary literals; this still results in an over-approximation, at the price of further spurious answer sets. For example, consider the simple program a( X) ← not d( X), dom( X). for domain {1, 2, 3} with the fact d(3). If in the abstract program we omit d( X), then a choice on a( X) will always occur, no matter if d(3) is mapped to a singleton or not. Having further auxiliary atoms to distinguish this case then becomes useful.Furthermore, we can reduce the number of rules in item (d) by using auxiliary predicates hasClusterk( X1, . . . , Xk) of arity i ≥ 1, which express that some argument Xi , 1 ≤ i ≤ k, is a non-singleton cluster; instead of using not isSingleton(m(ti)), we then simple add for αi = p(s1, .., sk) the atom hasClusterk(s1, . . . , sk) to the rule bodies.Another possibility is to simplify (for a chosen set S of literals as above) the program (cid:2)m by eliminating subsumed rules as in Example 3.20, or by replacing multiple rules with other rules such that the answer sets of the program are not affected; e.g., one may think of replacing the rules in (b) and (d.i) (resp. (c) and (d.ii)) of Definition 3.4, when some atom αi ∈ Bstd,−(r) exists, by a merged rule from which the atom αi is removed, for suitable terms t (when t is among t1and t2 of t1 ◦ t2, for instance). To this end, program rewriting and optimization techniques for ASP could be exploited (see Section 7.3.1 for more information). However this could change the structure of the resulting program significantly, such that it may be more difficult for the user to understand the working of the abstraction program, and obtaining intuitive explanations for spuriousness can be more difficult than when using the systematic approach. Furthermore, extending the approach to more language constructs might be more difficult to accomplish. Exploring the tradeoff between semantic accuracy of over-approximation, the size of the abstract program in the space of possible choices for supersets S, and possible structure-preserving optimizations is an interesting issue but beyond this article.3.3. Syntactic extensions and further considerations3.3.1. Other forms of relationsIt is customary to use in ASP programs other relations apart from =, (cid:13)= such as comparison <, ≤ or non-binary relations such as addition X + Y = Z or multiplication X ∗ Y = Z . ASP solvers support them in the input syntax as built-in relations, which are typically pre-evaluated during program grounding.A simple way to treat such relations is as follows: (1) rewrite the relations by adding instead auxiliary atoms to represent them, (2) standardize apart the auxiliary atom arguments similarly as the remaining atoms, and (3) add to the original program facts of the auxiliary atom to show for which domain elements the relation holds true. In the abstraction procedure, the facts added will be lifted to the abstract domain, and the abstraction is handled over relations for the arguments which were standardized apart. We illustrate this on a small example.Example 3.23. Consider the ruleb(X, Y ) ← a(X), d(Y ), X + 1 = Y .19Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563For the addition relation, an auxiliary atom plusOne( X, Y ) is introduced by adding the facts plusOne(1, 2), plusOne(2, 3), plusOne(3, 4), plusOne(4, 5)} to (cid:2) stating on which domain elements this relation holds.The respective rule gets standardized apart into the following form.b(X, Y ) ← a(X), d(Y ), plusOne(X1, Y 1), X= X1, Y =Y 1.Fortunately, standardizing shared arguments in frequently used built-in atoms X ≤ Y , X < Y etc. apart, which introduces new variables and auxiliary atoms, can be avoided; to this end, the relation types in Table 2 may be extended to the relations ◦ ∈ {=, (cid:13)=, <, ≤, >, ≥} directly.Respecting the order relation. If the original domain D has an order relation among its elements, i.e., x1 ◦ x2 where ◦ ∈{<, ≤}, then ◦ should be defined in (cid:3)D such that ˆd1 ◦ ˆd2 can be evaluated for abstract values ˆd1 and ˆd2. Furthermore, the abstraction mapping should respect the ordering of elements to avoid unnecessary uncertainty.(cid:3) = {{4}(cid:17)→k1, {1, 5}(cid:17)→k2, {2, 3}(cid:17)→k3}, which does not allow to respect the usual Example 3.24 (ctd). Consider the mapping mordering < in the abstraction: as 1 < 4 < 5 we would need an ordering k2 < k1 < k2 which is not possible (even resorting to a non-strict ordering ≤ would fail). While the relation types can still be defined for m, they will for < be mostly of type III and IV, resulting in many uncertainties.(cid:3)3.3.2. Strong negation and function symbolsOur abstraction method can also be applied to programs that contain strongly (“classically”) negated atoms ¬a. The simple way to achieve this is to apply the traditional transformation where each strongly negated atom ¬p(t1, . . . , tn)is replaced by an atom neg p(t1, . . . , tn) where neg p is a fresh auxiliary predicate and a constraint “⊥ ← p(t1, . . . ,tn), neg p(t1, . . . , tn).” is added to the program [57].For programs with uninterpreted function symbols, auxiliary atoms that emulate terms containing function symbols with new constant symbols can be used, similarly as discussed in [41, Section 6]. For illustration, the rule p( f ( f ( X))) ← q( X) can be rewritten as p(Y ) ← q( X), aux f ( X, U ), aux f (U , V ) where informally the predicate aux f (c1, c2) links a constant symbol c1 representing a term t1 to a constant symbol c2 that represents f (t1). Nested function terms can then be represented, as in the example rule, using multiple atoms. The predicate aux f is precomputed and provided as facts. Notably, ASP programs are generally evaluated on a finite grounding of the input program [3]; hence the potentially infinite Herbrand universe does not prevent one to apply this method to such programs.3.3.3. Treating choice rules and cardinality constraintsSo far, we have considered choice rules as a shorthand for two ordinary rules (which is the standard definition of the semantics). It make sense, however, to consider them as primitive constructs with dedicated treatment to achieve more structure preservation. To this end, choice rules are treated by ensuring that the body is abstracted and the choice over the abstracted head is kept.Definition 3.11. Given a choice rule r : { α } ← Bstd(r), t1 ◦ t2 and a domain mapping m, the set rm contains the rules of Definition 3.4 for steps (b)-(d), and for step (a), it contains{ m(α) } ← m(Bstd(r)), m(t1) ◦ m(t2), τ ◦I (m(t1), m(t2)).Cardinality constraints and conditional literals are further common syntactic extensions [117]; in particular, i(cid:8){a( X) :b( X)}iu is true whenever at least i(cid:8) and at most iu instances of a( X) subject to b( X) are true. Choice rules that involve cardinality constraints, e.g., n1 ≤ { α } ≤ n2 ← B(r), cannot immediately be treated similarly. Lifting the cardinality constraints analogously to the abstract rule causes to force the occurrence of abstract atoms for ensuring the lower bound.Example 3.25 (ctd). Consider instead of (4) the rule2 ≤ { b(X, Y ) : d(Y ) } ≤ 4 ← a(X).(49)which gets lifted to the same abstract rule. However, for the mapping m = {{1, 2, 3, 4, 5}(cid:17)→k}, if a(k) and d(k) holds true, this would cause to have b(k, k) hold true and no other atoms with the same predicate. Thus, the lower bound cannot be satisfied, causing the abstract program to become unsatisfiable.The issue arises from the fact that if the atom in the choice head is involved in some non-singleton cluster, then multiple original atoms may be mapped to it, thus still satisfying the lower bound constraint in the original program. Such choice rules can be treated by modifying the lower bounds in the abstract program and adding a constraint to ensure that the original lower bound is met if the atom is only involved with singleton clusters.20Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Definition 3.12. Given a rule r : n1 ≤ {α} ≤ n2 ← Bstd(r), t1 ◦ t2, in the abstraction procedure the choice head is changed to {m(α)} ≤ n2, and an additional constraint of the following form is added.⊥ ← {m(α) : isSingleton(m(s1)), . . . , isSingleton(m(sk))}<n1, Bstd(r), m(t1) ◦ m(t2), τ ◦I (m(t1), m(t2)),{m(α) : not isSingleton(m(s1)); . . . ; m(α) : not isSingleton(m(sk))} < 1.(50a)(50b)where α = p(t1, . . . , tn) and s1, . . . , sk are the terms among t1, . . . , tn that are local variables in r, i.e., variables not occurring in Bstd(r), t1 ◦ t2.The idea with the additional constraint is to ensure that if the lower bound n1 is not satisfied through literals mapped to singleton clusters (50a), then some literal with a non-singleton cluster (50b) should also occur.Example 3.26 (ctd). Instead of lifting the choice rule as in Example 3.25, we add the following abstract rules:{b(X, Y ) : d(Y )} ≤ 4 ← a(X).⊥ ← {b(X, Y ) : isSingleton(Y )} < 2, a(X),{b(X, Y ) : not isSingleton(Y ), dom(Y )} < 1.This way there is no lower bound on the number of occurrences of b( X, Y ) that causes unsatisfiability at the abstract program. Furthermore, for the mapping m = {{1}(cid:17)→k1, {2, 3, 4, 5}(cid:17)→k2}, for an answer set containing b(k1, k1) the constraint ensures it also contains b(k1, k2) so that the original lower bound is met.By taking numeric information about cluster sizes into account, a more fine-grained treatment of the lower bound n1is possible. On the one hand, one can eliminate in more cases than those captured by the constraint (50a)-(50b) abstract models for which an overestimate of the number of atoms in the original answer set does not exceed n1, where the overestimate is computed using aggregates and size of all clusters. In a dual approach, we can adjust n1 to an underestimate (cid:3)≤ n1 of the number of atoms that must be present in the abstract answer set, depending on the size of the largest cluster n1of an abstract constant used to instantiate a local variable (in the example, Y in d(Y )). To illustrate, if in (49) the lower bound would be 5 and variable Y would be instantiated with abstract constants of maximum cluster size 4, then we would know that we need at least two of the abstractly instantiated atoms b( X, Y ) to satisfy the concrete lower bound of 5. In = (cid:24)n1/mcsnlv(cid:25) where general, we can adapt the lower bound n1 in the abstract version of the cardinality constraint to nmcs (= mcs(m, r)) is the maximum cluster size of an abstract constant in the mapping m that is used to instantiate a local variable in r, and nlv (= nlv(r)) is the number of all local variables. In the example, the computation adapts the lower bound = (cid:24)5/(41)(cid:25) = 2. However, these adaptations depend on a concrete mapping m, and the numbers have to be n1 = 5 to nprovided with (non-abstracted) auxiliary atoms or computed by a (non-abstracted) subprogram. For space reasons, we omit here working out concrete encoding techniques.(cid:3)1(cid:3)13.3.4. Concreteness with projectionUsually the problem encodings contain auxiliary atoms that are insignificant for solutions. When constructing the abstract program, such auxiliary atoms are treated the same, by introducing choices whenever there is an uncertainty. However, this causes many spurious guesses over the auxiliary atoms, and making sure that the abstract answer set is concrete w.r.t. all of these atoms becomes too ambitious, as encountering a concrete abstract answer set among many spurious ones is more difficult. For this reason, we consider a projected notion of determining concreteness of an abstract answer set by only focusing on a certain set of atoms.Definition 3.13. For a set A of atoms, an abstract answer set ˆI ∈ AS((cid:2)m) is concrete w.r.t. A if ˆI| ˆAset I ∈ AS((cid:2)), where ˆA = m( A).= m(I| A) ∪ Tm for an answer Example 3.27. Consider a modified instance of graph coloring where the isolated nodes are connected as shown in Fig. 5. For the abstraction, the abstract coloring is spurious as the nodes in the cluster {4, 5, 6} cannot all be colored to red in the original graph due to the edges. However, the abstract coloring is concrete w.r.t. the nodes {1, 2, 3}.Such a notion of concreteness becomes useful when abstraction is applied to analyze problems, as one can focus on the atoms deemed to be important. For this, the user should have an idea of the atoms that matter for determining a valid solution. E.g. for planning problems, this notion can help in focusing on the actions and directly affected objects, which serve to describe a solution. One then obtains abstract answer sets that have concrete truth assignments of these atoms, while the auxiliary atoms and their concrete truth assignments become irrelevant.21Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563blue2red1green3red456Fig. 5. Concreteness w.r.t. projection over nodes {1, 2, 3}.3.4. Properties of domain abstractionWe now consider some basic semantic properties of our formulation of program abstraction. (Non-)existing spurious answer sets allow us to infer properties of the original program.Proposition 3.3. For any program (cid:2),(i) AS((cid:2)mid ) = {I ∪ Tmid(ii) AS((cid:2)m) = ∅ implies that AS((cid:2)) = ∅.(iii) AS((cid:2)) = ∅ iff some (cid:2)m has only spurious answer sets.| I ∈ AS((cid:2))} for the identity mapping mid = {{x}(cid:17)→x | x ∈ D}.Proof.(i) Having the identity mapping id causes to only have singleton clusters in the abstract domain, thus resulting in only τI and τII type facts in Tmid . This causes for only the rules of step (a) in Definitions 3.4 and 3.11 to remain when the rules are grounded to the relation types. Hence, the same answer sets are obtained.(ii) Corollary of Theorem 3.2.(iii) If AS((cid:2)) = ∅, then no ˆI ∈ AS((cid:2)m) for any m has a concrete answer set in (cid:2); thus, all abstract answer sets of (cid:2)mare spurious. Now assume the latter holds but AS((cid:2)) (cid:13)= ∅. Then (cid:2) has some answer set I , and by Theorem 3.2, m(I) ∪ Tm ∈ AS((cid:2)m), which would contradict that (cid:2)m has only spurious answer sets. (cid:2)The abstract program is built by a syntactic transformation. The abstraction over the domain can also be done incre-mentally which in the end amounts to the overall abstraction. To establish this formally, recall from Definition 3.3 that Tmcontains all type atoms τ ◦◦ Tm j where mi ◦ m j is the composition of mi and m j .ι (ˆd1, ˆd2) for a mapping m; we let Tmi ,m j= TmiLemma 3.4. For any program (cid:2) and mappings m, m1, m2 such that m2(m1(D)) = m(D), we have grdTm2,m1grdTm ((cid:2)m), where grdT∗ denotes the grounding of the program to the relation type facts T∗.(((cid:2)m1 )m2 ) =For proving Lemma 3.4, we use the following result.Lemma 3.5. For a relation d1 ◦ d2 and mappings m, m1, m2 such that m2(m1(D)) = m(D), we have T ◦the set of type atoms only related with the relation ◦.m2,m1= T ◦m , where T ◦∗ denotes Proof. The relation type computation T ◦m1m2(m1(d1)) ◦ m2(m1(d2)) = m(d1) ◦ m(d2), resulting in the same relation type facts of T ◦is done for m1(d1) ◦ m1(d2) and then the relation type computation T ◦m2,m1m . (cid:2)for Proof of Lemma 3.4. From the rules of (cid:2)m1 , the rules for ((cid:2)m1 )m2 will be constructed according to Definitions 3.4 and 3.11. Consider a rule r with body B std(r), t1 ◦ t2 in (cid:2). The set rm1 ∈ (cid:2)m1 contains rules with body m1(Bstd(r)), ˆt1 ◦ ˆt2, τ ◦i (ˆt1, ˆt2)where ˆtk = m1(tk) if tk is a constant; ˆtk = tk otherwise.(cid:3) ∈ rm1 , its body will be abstracted tois a constant; (51)ˆˆtk = tk otherwise. Since For the set rm1 of rules, a new set (rm1 )m2 will be constructed. Let rˆˆt2)m2(B(r)), rel(ˆˆt1,ˆˆt1,ˆˆt2), τ ◦j ((cid:3)where m2(B(rm2(τ ◦i (ˆt1, ˆt2)) and (cid:3))) = m2(m1(Bstd(r))), m2(τ ◦ˆˆt1, ˆˆt2), (51) will take the formi (m2(ˆt1), m2(ˆt2)) = τ ◦i (ˆˆt2), τ ◦ˆˆt1,ˆˆt2), rel(j (ˆˆtk = tk otherwise.i (ˆt1, ˆt2)) = τ ◦ˆˆt1,ˆˆt1,m(Bstd(r)), τ ◦i (ˆˆtk = m(tk) if tk is a constant; ˆˆt2).where ˆˆt j = m2(m1(tk)) if tk22Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563c( X) ← not d( X), dom( X).{c( X)} ← not isSingleton( X), dom( X).d( X) ← not c( X), dom( X).{d( X)} ← not isSingleton( X), dom( X).b( X, Y ) ← a( X), d(Y ).e(k0) ← c(k0), a(k1).e(k2) ← c(k2), a(k1).e(k0) ← c(k0), a(k2).e(k2) ← c(k2), a(k2).e(k1) ← c(k1), a(k2).{e(k0)} ← c(k0), a(k0).e(k1) ← c(k1), a(k0).{e(k1)} ← c(k1), a(k1).e(k2) ← c(k2), a(k0).⊥ ← b(k2, k2), e(k2).c( X) ← not d( X), dom( X).{c( X)} ← not isSingleton( X), dom( X).d( X) ← not c( X), dom( X).{d( X)} ← not isSingleton( X), dom( X).b( X, Y ) ← a( X), d(Y ).{e(a0)} ← c(a0), a(a0).(a) grdTm1((cid:2)m1 )(b) grdTm2 ,m1(((cid:2)m1 )m2 )Fig. 6. Abstract programs of Example 3.28 with m1 = {{1, 2}(cid:17)→k0, {3, 4}(cid:17)→k1, {5}(cid:17)→k2} and m2 = {{k0, k1, k2}(cid:17)→a0}.The rules in (rm1 )m2 where types of the relation differ, i.e., i (cid:13)= j for τ ◦i (ˆˆt2), are insignificant as the atoms cannot both hold true in Tm2,m1 , i.e., they do not appear in grdTm2,m1((rm1 )m2 ). As for the remaining rules in (rm1 )m2 , they correspond to the rules in rm. Thus, by Lemma 3.5 and {m2(m1(p((cid:22)c))). | p((cid:22)c). ∈ (cid:2)} = {m(p((cid:22)c)). | p((cid:22)c). ∈ (cid:2)}, we obtain grdTm2,m1(((cid:2)m1 )m2 ) = grdTm ((cid:2)m). (cid:2)ˆˆt2), τ ◦j (ˆˆt1, ˆˆt1, Example 3.28 (Example 3.1 ctd). Applying first the mapping m1 = {{1, 2}(cid:17)→k0, {3, 4}(cid:17)→k1, {5}(cid:17)→k2} and then the mapping m2 = {{k0, k1, k2}(cid:17)→a0} yields the mapping m = {{1, 2, 3, 4, 5}(cid:17)→a0}. Fig. 6 shows the constructed abstract programs. Notice that the program in Fig. 6b is the same as the non-ground program in Example 3.19 updated for the mapping m, i.e., a0 is replaced with k, when it is grounded to Tm2,m1 .An easy induction argument shows then the possibility of doing abstraction sequentially, by having abstract mappings defined over previously abstracted domains.Proposition 3.6. For any program (cid:2) and mappings m, m1, . . . , mn such that mn(. . . (m1(D))) = m(D), we have grdTm ((cid:2)m) =grdTmn ,...,m1((((cid:2)m1 )...)mn ).In Section 5.2 below, we demonstrate further uses of having a hierarchy of abstractions.We remark that general properties of spurious answer sets from over-approximation apply to domain abstraction as an instance of it. Examples of such properties, mentioned for omission abstraction in [110,111], are non-reoccurrence after elimination, i.e., if a spurious answer ˆI set of a program (cid:2)m has no corresponding (cannot be mapped to some) answer set will have an answer set ˆI (cid:3)(cid:3) corresponding to ˆI either, and convexity, ˆI (cid:3) in a refinement mof m, then no refinement mi.e., if on the contrary ˆI has some corresponding answer set ˆI (cid:3) under mand madmits a spurious answer set ˆI (cid:3)(cid:3) of (cid:2)mthat corresponds with ˆI ., then every refinement min between mof m(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)3.4.1. Abstraction over sortsApplications of ASP usually contain sorts that form subdomains of the Herbrand universe. For example, in graph coloring there are sorts for nodes and colors. We define an abstraction over a sort as follows.Definition 3.14. An abstraction is limited to a sort D i ⊆ D, if all elements x ∈ D \ D i form singleton clusters {x}(cid:17)→x.Example 3.29. In graph coloring, we have sorts node and color in the domain {1, . . . , 6, red, green, blue} for the instance in Fig. 1a. An abstraction mapping m limited to the sort node means m(x) = {x} for x ∈ {red, blue, green}.In order to obtain much coarser abstractions, applying abstraction over multiple sorts is also possible, given that the individual sorts fulfill the following property.Definition 3.15 (sort independence). For a program (cid:2) and domain D, subdomains D1, . . . , Dn ⊆ D are independent if D i ∩ D j =∅ for all i (cid:13)= j.For independent sorts, abstractions can be composed.23Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563{green,blue}2{green,blue}2red1{green,blue}{green,blue}{green,blue}36red4514536red(a) A concrete answer set(b) A spurious answer setFig. 7. Abstraction over the set of nodes and the set of colors.Proposition 3.7. For every domain mappings m1 and m2 over independent subdomains D1 and D2, it holds that grdTm1,m2= grdTm2,m1(cid:7)(cid:2)m1((cid:8)m2 ).(cid:7)(cid:2)m2((cid:8)m1 )Proof. The mapping mi : D(cid:17)→(cid:3)D is of form {{x}(cid:17)→x | x ∈ D \ D i} ∪ mD i , i ∈ {1, 2}, where mD i describes the mapping over D ito the abstract domain (cid:3)D i . We know that mi(D \ D i) = D \ D i , and since D1 and D2 are independent, we have D1 ⊆ m2(D)and D2 ⊆ m1(D). Consequently, we can apply the mappings independently from each other as m2(m1(D)) = m1(m2(D)) to (cid:3)(cid:3)D. By achieve an abstract domain Lemma 3.4 we get the result. (cid:2)(cid:3)(cid:3)D = (D \ (D1 ∪ D2)) ∪ (cid:3)D1 ∪ (cid:3)D2. Another mapping m can then be defined to map D to 3.4.2. Cartesian abstractionGiven domain mappings m1, . . . , mn limited to subdomains D1, . . . , Dn, respectively, a cartesian abstraction of the map-pings corresponds to the abstract domain m(D1) × · · · × m(Dn). Assuming that the subdomains D1, . . . , Dn are independent, Definition 3.4 can be altered to be applied over a rule of the formr : α ← Bstd(r), t1 ◦D1 t2, . . . , t1 ◦Dn t2by considering all possible combinations of τ ◦Diby applying abstraction over each subdomain one step at a time, by extending Proposition 3.7 to multiple sorts.(m(t1), m(t2)), j = 1, . . . , n. Alternatively, we can define cartesian abstraction jProposition 3.8. For domain mappings m1, . . . , mn over independent domains D1, . . . , Dn, it holds that (cid:2)m1×...×mn =(((cid:2)mπ (1) )...)mπ (n) where π is any permutation of {1, . . . , n}.Example 3.30 (Example 2.4 ctd). In the graph coloring instance of Fig. 1a, consider the mappings mn = {{4, 5, 6}(cid:17)→ˆ4} and mc = {{red}(cid:17)→ˆr, {green, blue}(cid:17)→ ˆgb} over the sorts nodes and colors, respectively. The abstract program ((cid:2)mn )mc has the concrete answer set{chosenColor(1, ˆr), chosenColor(2, ˆgb), chosenColor(3, ˆgb), chosenColor(ˆ4, ˆr)}(shown in Fig. 7a) that chooses the color cluster ˆgb for nodes 2 and 3, which matches the intuition of coloring the neighbor nodes of node 1 to some color different than its own color.Notably, ((cid:2)mn )mc also has the spurious answer set (shown in Fig. 7b){chosenColor(1, ˆgb), chosenColor(2, ˆgb), chosenColor(3, ˆgb), chosenColor(ˆ4, ˆr)}due to the guesses introduced for the uncertainty.In Section 7.2 we demonstrate further uses of such an multi-step abstraction over the subdomains.3.5. Computational complexityIn this section, we turn to the computational complexity of reasoning tasks that are associated with program abstraction. We build on the complexity results in [33,39], which cover the basic reasoning tasks for arbitrary non-ground programs and for non-ground programs with bounded predicate arities, i.e., the maximum arity of a predicate occurring in the program is bounded by a constant.Lemma 3.9. Given an arbitrary non-ground program (cid:2), a mapping m, and an abstract interpretation ˆI, checking whether ˆI ∈ A S((cid:2)m)holds is feasible in (cid:10)p2 .24Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Intuitively, this holds because we can nondeterministically generate each rule r in (cid:2)m in polynomial time, and if I is not a model of the reduct ((cid:2)m)I also an instance of r witnessing this fact. The minimality of I for ((cid:2)m)I can be shown by a polynomial-size proof tree that can be guessed and checked.Armed with this lemma, we consider the problem of identifying concrete abstract answer sets.Theorem 3.10. Given a program (cid:2), a domain mapping m, and an abstract interpretation ˆI, deciding whether ˆI is a concrete abstract answer set of (cid:2)m is NEXP-complete in general and (cid:11)p2 -complete for bounded predicate arities. Furthermore, the complexity remains unchanged if ˆI ∈ AS((cid:2)m) is asserted.That is, the worst case complexity is the one of answer set existence for non-ground programs [33,39]; the two problems can be reduced to each other in polynomial time. Intuitively, in general an abstract atom in ˆI may be mapped back to exponentially many atoms in an answer set I of the original program (cid:2) that witnesses the concreteness of ˆI ; such an Ican be guessed and checked in nondeterministic exponential time. Accordingly, the complexity drops to (cid:11)p2 if the domain size |D| is polynomial in the abstracted domain size |(cid:3)D| and interpretations are represented as bitmaps (as customary); e.g., it drops if each abstract cluster is small (and multiple clusters exist). Under bounded predicate arities, each abstract atom maps back to polynomially many original atoms, such that the guess I has polynomial size and checking I can be done with an NP oracle in polynomial time (cf. Lemma 3.9). The matching lower bounds are shown by reductions from deciding whether a given non-ground program has some answer set.As an immediate consequence of Theorem 3.10, we obtain the following result for spuriousness checking.Corollary 3.11. Given a program (cid:2), a domain mapping m, and an abstract interpretation ˆI, deciding whether ˆI is a spurious abstract answer set of (cid:2)m is coNEXP-complete in general and (cid:2)p2 -complete for bounded predicate arities. Furthermore, the complexity remains unchanged if ˆI ∈ AS((cid:2)m) is asserted.Next we consider deciding whether the abstract program has some spurious answer set. This problem turns out to have higher complexity.Theorem 3.12. Given a program (cid:2) and a domain mapping m, deciding whether some ˆI ∈ AS((cid:2)m) exists that is spurious is NEXPNP-complete in general and (cid:11)p3 -complete for programs with bounded predicate arities.Intuitively, compared to the previous problem we first must make a guess for ˆI such that it is an abstract answer set of (cid:2)m but not concrete; the size of ˆI may be exponential in the input of the problem, and relative to this testing concreteness is feasible in nondeterministic polynomial time, i.e., with an NP oracle. The matching hardness is shown by reductions from evaluating second-order logic formulas of a suitable form over finite relational structures.Faithful abstraction. An abstract program that does not have a spurious answer set is a faithful abstraction of the original program.Example 3.31 (Example 2.4 ctd). In the graph coloring instance of Fig. 1a, the mapping m = {{4, 5, 6}(cid:17)→ˆ4}, which maps nodes 1, 2, 3 to singleton clusters, yields an abstract program (cid:2)m that has 42 answer sets, which are the combinations of 6 possible correct colorings of the nodes 1 − 3 with 7 possible colorings {{red}, {blue}, {green}, {red, blue}, {red, green}, {green, blue}, {red, green, blue}} of the node cluster ˆ4, thus resulting in a faithful abstraction.Ideally, we have faithfulness, but this is hard to achieve in general. From Theorem 3.12, we immediately obtain:Corollary 3.13. Given a program (cid:2) and a domain mapping m, deciding whether (cid:2)m is faithful is coNEXPNP-complete in general and (cid:2)p3 -complete for bounded predicate arities.4. Refinement by debugging non-ground spuriousnessOver-approximation of an answer set program unavoidably introduces spurious answer sets. Once a spurious abstract answer set is encountered, one can either continue searching for a concrete abstract answer set, or refine the abstraction to reach one where less spurious answer sets occur.Definition 4.1. Given a domain mapping m : D → (cid:3)Dm−1(m(x)).(cid:3)(x)) ⊆ m(cid:3) −1(m(cid:3), a mapping m(cid:3) : D → (cid:3)D(cid:3)(cid:3)is a refinement of m if for all x ∈ D, That is, refinement is on dividing the abstract clusters to a finer grained domain.25Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Example 4.1 (Example 3.21 ctd). The mapping mm= {{1, . . . , 5}(cid:17)→k}. Furthermore, (cid:2)manswer set ˆI2 of (cid:2)m is eliminated.has no answer set ˆI(cid:3)(cid:3) = {{1}(cid:17)→k1, {2, 3}(cid:17)→k2, {4, 5}(cid:17)→k3} is a refinement of the mapping (cid:3))) = ˆI2 = {a(k), c(k)}; hence the spurious such that m(m(cid:3) −1(ˆI(cid:3)In the CEGAR methodology [25], the decision in a refinement step depends on the correctness checking of the spurious abstract solution, through which the problematic part of the abstraction is detected. Inspired by this, we develop an alter-native for checking the correctness of abstract answer sets that can be used to determine how the refinement should be made.Correctness checking using constraints. That an abstract answer set ˆI is spurious means the original program (cid:2) has no answer set matching ˆI . In other words, querying (cid:2) for a match to an abstract answer set ˆI would return no result exactly if ˆI is spurious.Definition 4.2 (query of an answer set). Given an abstract answer set ˆI and a mapping m, a query Q mˆImatches ˆI is described by the following constraints.for an answer set that ⊥ ← {α | m(α) = ˆα} ≤ 0.⊥ ← α.ˆα ∈ ˆI \ Tm,ˆα /∈ ˆI \ Tm, m(α) = ˆα.(52)(53)Here (52) ensures that a witnessing answer set I of (cid:2) (i.e., m(I) = ˆI ) contains for every non-τι abstract atom in ˆI some atom that is mapped to it, while (53) ensures that no atom in I is mapped to an abstract atom not in ˆI . The following is then easy to establish.Proposition 4.1. Suppose m is a domain abstraction mapping for a program (cid:2), then an abstract answer set ˆI ∈ A S((cid:2)m) is spurious iff (cid:2) ∪ Q mˆIis unsatisfiable.Proof. As ˆI is spurious, there exists no I ∈ A S((cid:2)) such that m(I) = ˆI \ Tm, i.e., there is no match of an original answer set Ifor ˆI where the atoms in I can be mapped to the abstract atoms contained in ˆI \ Tm and the atoms not in I can be mapped to the abstract atoms not contained in ˆI \ Tm. Q ˆI enforces such a match, thus returns unsatisfiability.Having no match for ˆI means that no original answer set can be mapped to it, thus ˆI is spurious. (cid:2)Correctness checking with debugging. We will employ an ASP debugging approach to debug the inconsistency of the original program (cid:2) caused by checking a spurious answer set ˆI , referred to as inconsistency of (cid:2) w.r.t. ˆI , in order to get hints for refining the abstraction. Different from a usual ASP program debugging approach, we need to shift the focus from “debugging the original program” to “debugging the inconsistency caused by the spurious answer set”. Unfortunately an immediate application of the available ASP debugging tools is not possible. For our purposes, we make use of the meta-level debugging language in [16], which is based on a tagging technique that allows one to control the building of answer sets and to manipulate the program evaluation.The meta-program constructed by spock [16] introduces tags to control answer set building. Given a ground program (cid:2) that is viewed as program over a propositional alphabet (i.e., ground atoms are propositional atoms) and a set N of names for all rules in (cid:2), it creates an enriched alphabet by adding propositional atoms such as ap(nr), bl(nr), ok(nr), ko(nr)where nr ∈ N for each r ∈ (cid:2). The atoms ap(nr), bl(nr) express whether a rule r is applicable or blocked, respectively, while ok(nr), ko(nr) are used for manipulating the application of r.For domain abstraction, debugging the non-ground program has its own difficulties. The approach in [16] is on the propositional level, thus cannot be immediately applied. Also debugging non-ground programs is not as straightforward as in the propositional case, as there is the additional need to debug the checking for an original answer set that can be mapped to the given abstract answer set. However, non-ground program debugging approaches such as [36,93] are not easily adjustable due to the need for shifting the focus towards debugging the correctness check.Using available debuggers. Debugging non-ground ASP programs through a meta-programming [55] approach has been studied by [93], with the drawback of considering all possible explanations why a given interpretation I is not an answer set of the program (cid:2). For the given input I , in order to prove that I is not an answer set of (cid:2), the debugging considers many possible guesses of variable assignments that matches I with a faulty behavior. In our case, the input I is an abstract answer set stating that there should be some original answer set Ican be mapped to some abstract atom ˆα in I . This adds a guess of some original atom that could be mapped to ˆα. However, as the debugging aims at showing that I is not an answer set of (cid:2), when this additional guessing comes into play, it guesses original atoms to create some faulty behavior for I even if these atoms do not occur in an original answer set. Thus, an immediate application of the meta-programming approach is infeasible.of (cid:2) such that each atom in I(cid:3)(cid:3)In order to use the available non-ground debugging tools off-the-shelf, one possibility is to first guess all possible com-binations of the original atoms to match the abstract answer set ˆI , and then separately debug each of them. If ˆI is in fact 26Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563spurious, this will be caught as each possible guess would return some inconsistency. If ˆI is concrete, then at some point some guess will correspond to an original answer set, with no inconsistency. However, this approach is too cumbersome, as there can be many possible concrete guesses for an abstract I and checking each of them one by one until a concrete one is found (if it exists) is highly inefficient.Our approach to debugging. As existing non-ground debugging tools are not readily applicable, we debug the unsatisfiability for a spurious abstract answer set ˆI following the debugging approach based on [16] from above. In previous of (cid:2) ∪ Q mˆIwork on domain abstraction [113], we considered a simplified debugging approach inspired from the ko atoms of [16], which is based on detecting the rules that must be deactivated in order to keep the satisfiability while checking the concreteness of an abstract answer set ˆI , in case it is spurious. As the naive debugging cannot address all debugging cases, in this work we show an extension of the refinement method by lifting the spock [16] debugging approach to the non-ground case, confining to a class of programs that subsumes tight programs.When demonstrating the different debugging approaches, we use a non-ground version of Q mˆI.Definition 4.3 (non-ground query). Given an abstract answer set ˆI and a mapping m expressed as a set of facts of form m(x, (cid:3)d) (where m(x) =(cid:3)d), a (non-ground) query for an answer set that matches ˆI is described as follows:⊥ ← inp( ˆX1, . . . , ˆXk), {p(X1, ..., Xk) : m(X1, ˆX1), . . . , m(Xk, ˆXk)} ≤ 0.⊥ ← p(X1, ..., Xk), not inp( ˆX1, . . . , ˆXk), m(X1, ˆX1), . . . , m(Xk, ˆXk).inp(ˆd1, . . . , ˆdk).for all p(ˆd1, ..., ˆdk) ∈ ˆI \ Tm,where p (cid:13)= dom is a non-relational predicate.(54)(55)(56)Example 4.2 (Example 3.1 ctd). For the program (cid:2) and the mapping m = {{1, 2, 3, 4, 5}(cid:17)→k} given as facts m(1, k), m(2, k), m(3, k), m(4, k), m(5, k), the abstract program (cid:2)m has an answer set ˆI = {a(k), c(k)}. The query Q mˆIis⊥ ← not ind( A1), d(X1), m(X1, A1).⊥ ← not inc( A1), c(X1), m(X1, A1).⊥ ← not ina( A1), a(X1), m(X1, A1).⊥ ← not ine( A1), e(X1), m(X1, A1).⊥ ← not inb( A1, A2), b(X1, X2), m(X1, A1), m(X2, A2).⊥ ← inb( A1, A2), {b(X1, X2) : m(X1, A1), m(X2, A2)} ≤ 0.ina(k).inc(k).⊥ ← ind( A1), {d(X1) : m(X1, A1)} ≤ 0.⊥ ← inc( A1), {c(X1) : m(X1, A1)} ≤ 0.⊥ ← ina( A1), {a(X1) : m(X1, A1)} ≤ 0.⊥ ← ine( A1), {e(X1) : m(X1, A1)} ≤ 0.4.1. Non-ground debugging using taggingWe extend the refinement method described in [113] by lifting the “tagging” approach of spock [16] to the non-ground case, confining to a class of programs that makes it possible to avoid unfounded loop checking when debugging the spuriousness query. Given (cid:2), we construct the meta program Tmeta[(cid:2)] similar to spock [16], but with an extension of having arguments in the apnr , blnr atoms to have information for which constants the rules are applicable and blocked.Definition 4.4. Given a non-ground program (cid:2), the program Tmeta[(cid:2)] over the vocabulary Vmeta that enriches the vocabu-lary V of (cid:2) with predicates apnr , blnr , apnr , konr for each nr ∈ N , consists of the following rules for r ∈ (cid:2) with {c1, . . . , cn}denoting the set of terms that are arguments of H(r), and {d1, . . . , dn(cid:3) } denoting the set of terms that are arguments of literals in B(r):If B(r) = ∅ :If H(r) (cid:13)= ⊥ ∧ n > 0 :If H(r) = ⊥ ∨ n = 0 :r⎧⎨⎩⎧⎪⎪⎨⎪⎪⎩H(r) ← apnr (c1, . . . , cn), not konr .apnr (c1, . . . , cn) ← B(r).blnr (c1, . . . , cn) ← not apnr (c1, . . . , cn).H(r) ← apnr (d1, . . . , dn(cid:3) ), not konr .apnr (d1, . . . , dn(cid:3) ) ← B(r).← apnr (d1, . . . , dn(cid:3) ).apnr← not apnr .blnrIn case the head of rule r is ⊥ or does not contain arguments in the atom, we use the arguments from the body to know whether r is applicable.27Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563We have abnormality atoms to indicate the actions that are required to avoid the inconsistency:• ab_deactnr signals that r was applicable under some interpretation, but had to be deactivated;• similarly for ab_deactConsnr which only talks about the constraints; and• ab_act p(c1, . . . , cn) for α = p(c1, . . . , cn) says that atom α must be made true while no rule deriving α was applicable (i.e., α is unsupported4).Definition 4.5. Given a non-ground program (cid:2) with vocabulary V , the following additional meta-programs are constructed over the vocabulary Vdebug which enriches Vmeta with abnormality predicates ab_deactnr , ab_deactConsnr , and ab_act p ; and with c1, . . . , cn, d1, . . . , dn(cid:3) as in Definition 4.4, as follows:1. Rule Deactivation: Tdeact [(cid:2)]: for all r ∈ (cid:2) with B(r) (cid:13)= ∅ and H(r) (cid:13)= ⊥:konr .{H(r)} ← apnr (c1, . . . , cn).ab_deactnr (c1, . . . , cn) ← apnr (c1, . . . , cn), not H(r).2. Constraint Deactivation: TdeactCons[(cid:2)]: for all r ∈ (cid:2) with H(r) = ⊥:}.ab_deactConsnr (d1, . . . , dn(cid:3) ) ← apnr (d1, . . . , dn(cid:3) ), konr .{konr3. Rule Head Activation: Tact [(cid:2), V]: for all rule heads α = p(c1, . . . , cn) in (cid:2) with α ∈ V and pdef (p, (cid:2)) = {r1, ..., rk} and k ≥ 1:{α} ← blnr1(c1, . . . , cn), ..., blnrk(c1, . . . , cn).ab_act p(c1, . . . , cn) ← α, blnr1(c1, . . . , cn), ..., blnrk(c1, . . . , cn).The arguments of ab_deact only contain the ones from the head of the rule. This is a representation choice, to avoid dealing with many variables involved in the body while only few of them are used in the head of the rule. For the definition of ab_deactCons however, the variables of the body must be used. Having a different representation for the deactivation of the constraints will allow to steer the debugging towards the constraints by assigning different costs for their occurrence when computing the answer sets with the smallest number of ab atoms.Definition 4.6 (debugging program (cid:2)debug ). For a program (cid:2) over vocabulary V , we let the program (cid:2)debug over Vdebug be defined by(cid:2)debug = Tmeta[(cid:2)] ∪ Tdeact[(cid:2)] ∪ TdeactCons[(cid:2)] ∪ Tact[(cid:2), V].We use (cid:2)debug for checking the correctness of an abstract answer set and then deciding on the refinement. Adding weak constraints over the abnormality atoms yields an answer set with fewest ab atoms. We here use weak constraints [74] of the form⊥ :∼ α1, . . . , αm, not αm+1, . . . , not αn. [w, t1, . . . , tk]where w (the weight) is a positive integer constant or variable, and t1, . . . , tk are terms from α1, . . . , αn. For each answer set, the set of all tuples (w, t1, . . . , tk) of violated weak constraints is computed, and the sum of the first components of this set is assigned to the answer set as a cost. Among all answer sets, those whose cost is smallest are chosen as optimal answer sets. Using weak constraints is a convenient way of performing optimizations.Example 4.3 (Example 4.2 ctd). The program (cid:2)debug with additional weak constraints on abnormality atoms is shown in Fig. 8. The minimal answer set of (cid:2)debug ∪ Q mˆIis then{ab_deactr4(1), ab_deactr4(2), . . . , ab_deactr4(5)}.This debugging approach is also able to handle the shortcomings of the naive approach [113], as Tact [(cid:2), V] is used to activate original atoms if it is necessary for achieving satisfiability for (cid:2)debug ∪ Q mˆI.4 An atom α is unsupported by an interpretation I if for each r ∈ def (α, (cid:2)), B+(r) (cid:2) I or B−(r) ∩ I (cid:13)= ∅ [120].28Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563c( X) ← apr1( X), not kor1.apr1( X) ← not d( X).blr1( X) ← not apr1( X).d( X) ← apr2( X), not kor2.apr2( X) ← not c( X).blr2( X) ← not apr2( X).b( X, Y ) ← apr3( X, Y ), not kor3.apr3( X, Y ) ← a( X), d(Y ).blr3( X, Y ) ← not apr3( X, Y ).e( X) ← apr4( X), not kor4.apr4( X) ← c( X), a(Y ), X (cid:13)= Y .blr4( X) ← not apr4( X).⊥ ← apr5( X, Y ), not kor5.apr5( X, Y ) ← b( X, Y ), e( X).apr5 ← apr5( X, Y ).blr5 ← not apr5.a(1). a(3).kor1.{c( X)}← apr1( X).ab_deactr1( X)← apr1( X), not c( X).⊥:∼ ab_deactr1( X). [1, r1, X]kor2.{d( X)}← apr2( X).ab_deactr2( X)← apr2( X), not d( X).⊥:∼ ab_deactr2( X). [1, r2, X]kor3.{b( X, Y )}← apr3( X, Y ).{kor5}.ab_deactConsr5( X, Y ) ← kor5, apr5( X, Y ).⊥:∼ ab_deactConsr5( X, Y ). [1, r5, X, Y ]{c( X)} ← blr1( X).ab_actc ( X) ← c( X), blr1( X).⊥:∼ ab_actc ( X). [1, X]{d( X)} ← blr2( X).ab_actd( X) ← d( X), blr2( X).⊥:∼ ab_actd( X). [1, X]ab_deactr3( X, Y )← apr3( X, Y ), not b( X, Y ).{b( X, Y )} ← blr3( X).⊥:∼ ab_deactr3( X, Y ). [1, r3, X, Y ]ab_actb( X, Y ) ← b( X, Y ), blr3( X).⊥:∼ ab_actb( X, Y ). [1, X, Y ]kor4.{e( X)}← apr4( X).ab_deactr4( X)← apr4( X), not e( X).⊥:∼ ab_deactr4( X). [1, r4, X]{e( X)} ← blr4( X).ab_actc ( X) ← e( X), blr4( X).⊥:∼ ab_acte( X). [1, X]Fig. 8. Debugging program (cid:2)debug for Example 4.2 with weak constraints.As a first property, we show that (cid:2)debug ∪ Q mˆIalways has an answer set, i.e., no abstract answer set ˆI is dismissed provided the program (cid:2) at hand obeys the following property. We call (cid:2) positive-dependency founded if no negative edge +in G(cid:2) points to a cycle in G(cid:2), i.e., atoms in positive loops are not negatively conditioned to any atom. Note that positive-dependency founded programs subsume tight programs, where G+(cid:2) is acyclic.Proposition 4.2. Given a positive-dependency founded program (cid:2) and a mapping m, for each answer set ˆI ∈ A S((cid:2)m), (cid:2)debug ∪ Q mˆIhas an answer set.The next result now shows that we can use (cid:2)debug ∪ Q mˆIto obtain hints for the spuriousness reason of ˆI .Proposition 4.3. Given a positive-dependency founded program (cid:2) and a mapping m, if an answer set ˆI ∈ A S((cid:2)m) is spurious, then ) either (i) ab_deactnr (c1, . . . , cn) ∈ S or ab_deactConsnr (d1, . . . , dn(cid:3) ) ∈ S for some r ∈ (cid:2), for every answer set S ∈ AS((cid:2)debug ∪ Q mˆIor (ii) ab_act p(c1, . . . , cn) ∈ S for some r ∈ grd((cid:2)) with H(r) = {p(c1, . . . , cn)}.Less surprisingly, for programs that are not positive-dependency founded, debugging the correctness check could result in unsatisfiability (see Appendix B.1 for an example). To avoid this, unfounded loop checking can be handled by introduc-ing an additional abnormality atom, say abloop as in [16], and lifting it to the non-ground setting. However, this solution causes further guessing rules involved in the non-ground debugging. Also the existence of abloop(α) sometimes does not even indicate that a loop formula is violated and just makes the search more difficult due to considering many possibili-ties of the guesses. Therefore, we choose to focus only on positive-dependency founded programs and concentrate on the determination of a refinement.The obtained debugging atoms during a correctness check give hints on which domain elements should not be involved in a cluster.Definition 4.7 (refinement-hint program (cid:2)hint ). The refinement-hint gathering program (cid:2)hint for a program (cid:2) contains the following rules, with c1, . . . , cn, d1, . . . , dn(cid:3) as in Definition 4.4:• For ci ∈ arg(ab_deactnr (c1, . . . , cn)):refine(c1, . . . , cn) ← ab_deactnr (c1, . . . , cn), m(ci, ai), not isSingleton(ai).29Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Algorithm 1: decideRefinement with Search.Input: program (cid:2), domain mapping mOutput: refinement mof m(cid:3)1 if m has non-singleton clusters thenrefinecosts = []; allrefs = [];2/* compute all 1-distance refinements of mrefs = computeRefinements(m, 1)forall m(cid:3) ∈ refs doc = getCostOfMapping((cid:2), mif c = 0 then /* found a concrete abstract answer set(cid:3));345678910return m;(cid:3)elseallrefs.append(mrefinecosts.append(c)(cid:3));1112minrefs = getRefsMinCost(refinecosts, allrefs)m = pickRandomRef (minrefs)13 return m1415 def getCostOfMapping((cid:2), m)1617(cid:2)m = constructAbsProg((cid:2), m);(cid:2)debug = constructDebugProg((cid:2));Pick some ˆI ∈ A S((cid:2)m)Find optimum answer set I/* s = |Ireturn |I(cid:3)|ab|(cid:3)181920of (cid:2)debug ∪ Q mˆI(cid:3)|ab|/* with smallest number s of ab-atoms*/*/*/*/• For di ∈ arg(ab_deactConsnr (d1, . . . , dn(cid:3) )):refine(d1, . . . , dn(cid:3) ) ← ab_deactConsnr (d1, . . . , dn(cid:3) ), m(di, ai), not isSingleton(ai).• For ci ∈ arg(p(c1, . . . , cn)):refine(c1, . . . , cn) ← ab_actp(c1, . . . , cn), m(ci, ai), not isSingleton(ai).From (cid:2)hint we get as hints the domain elements that are mapped to abstract cluster elements and cause ab atoms in the debugging.4.2. Deciding on a refinementThe introduced debugging approach finds a set of abnormality atoms in case the abstract answer set is spurious. We consider two ways of using the obtained debugging output for deciding on a refinement.(v1) The smallest number of ab atoms occurring in an answer set is the cost of the corresponding mapping.(v2) The inferred refine atoms are used to decide on a refinement of the abstraction.In (v1), the cost is used for a local search among the possible refinements of an abstraction, where the one with the minimum cost is picked. Approach (v2) is closer to the CEGAR-like approach [25], where a refinement is determined from the spuriousness check. We now describe the approaches in more detail and report on a comparison in Section 6.3.(v1) Local Refinement Search. The idea is to search among possible refinements of a mapping for deciding on a refinement. (cid:3)) between a mapping m:D → (cid:3)D and a refinement To single out close refinements, we measure the distance dist(m, m(cid:3)) = |(cid:3)Da of it by the number of additional clusters, i.e., dist(m, mm1-distance refinement of m.(cid:3)| − |(cid:3)D|. In case dist(m, m(cid:3)) = 1, we call m(cid:3):D → (cid:3)D(cid:3)(cid:3)Example 4.4. Each mapping mrefinement of m = {{1, 2, 3, 4, 5}(cid:17)→k}.(cid:2)(cid:3) ∈C∈C{C(cid:17)→k1, {1, . . . , 5} \ C(cid:17)→k2}, where C = {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}}, is a 1-distance Algorithm 1 shows the procedure of deciding on a refinement for a given mapping m, by doing a distance-based search among all possible refinements of the mapping and picking the one with the least cost. All 1-distance refinements of mare computed, and then the cost of each of them is determined, by calling getCostOfMapping. This function constructs the abstract program (cid:2)m according to the mapping and picks an abstract answer set ˆI . It then finds the answer set with smallest number s of ab-atoms of the program (cid:2)debug ∪ Q mhas cost 0, it is returned. ˆIOtherwise, all the refinements and their costs were collected. In Line 11 the refinements with minimum cost are gathered, and then a random pick is made over them. If the given mapping contains only singleton clusters, this means the original domain has been reached.and returns s. If some refinement m(cid:3)30Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563(v2) Abstraction Refinement Using Hints. The abstract answer set correctness checking returns ab-atoms that contain the domain elements involved in the debugging of the unsatisfiability. The latter can be used as hints on which part of the mapping to refine. The idea of the refine atoms is to get hints about which domain elements should not be involved in a cluster. Given a hint atom refine(c1, . . . , cn), we consider two actions to describe a refinement mof m:(cid:3)(1) For refine(c1, . . . , cn) and i ∈ {1, . . . , n} such that m(2) For refine(c1, . . . , cn) and ci (cid:13)= c j ∈ {c1, . . . , cn} such that m(ci) = m(c j), the refinement m−1(m(ci)) > 1, the refinement msatisfies m(cid:3)(cid:3) −1(msatisfies m(cid:3)(cid:3)(ci)) = 1.(cid:3)(ci) (cid:13)= m(cid:3)(c j).Applying refinement action (1) means to refine the abstraction by mapping all elements occurring in some refine atom to singletons, while the refinement action (2) should ensure that distinct elements occurring in the same refine atom are no longer mapped to the same cluster.Example 4.5 (Example 4.3 ctd). The hint atoms for the minimal answer set of (cid:2)debug ∪ Q mˆIApplying refinement action (1) means to map each of the elements 1, . . . , 5 to singletons in mtrivial abstraction m(cid:3) = {{1}(cid:17)→k1, {2}(cid:17)→k2, {3}(cid:17)→k3, {4}(cid:17)→k4, {5}(cid:17)→k5}.are {refine(1), . . . , refine(5)}. , making the refinement the (cid:3)As for the other spurious answer set ˆI3 = {a(k), c(k), d(k), b(k, k)} of (cid:2)m (from Example 3.21), the minimal answer is {ab_deactr4(1)} resulting in the hint atom refine(1). When the abstraction mapping is refined to set of (cid:2)debug ∪ Q mˆI3m(cid:3) = {{1}(cid:17)→k1, {2, 3, 4, 5}(cid:17)→k2}, the spurious answer set no longer appears.Note that obtaining some refine atom during the correctness checking is not guaranteed whenever ˆI is spurious, as the ab atoms may contain only domain elements that are mapped to singleton clusters. In this case, another abstract answer set ˆIof (cid:2)m can be picked for the correctness checking.(cid:3)5. Multi-dimensional domain abstractionWith the methods for abstraction and refinement in Sections 3 and 4 at hand, we are well equipped to run a CEGAR-style abstraction and refinement procedure for answer set programs. As we have seen from Proposition 3.8, it is possible to deal with sorts, which is important for some practical applications. We can construct an abstract program over multiple sorts in the manner of cartesian abstraction, which is achieved by doing abstraction over the sorts one at a time. However, this has the drawback that we cannot take certain interdependencies among the sorts into account, which in some scenarios may be needed. We illustrate this need on some examples and will then present an alteration of the abstraction method that can take interdependencies between sorts into account.Example 5.1 (Example 3.30 ctd). An interesting abstraction would be to assign a color cluster (cid:13)rgb only for the nodes {4, 5, 6}, which are clustered to a node ˆ4, while for nodes {1, 2, 3} the original colors are considered (see Fig. 9). Such an abstraction cannot be achieved with a cartesian style abstraction, since the color cluster (cid:13)rgb is only meant to be considered for the node cluster ˆ4. Thus, the desired abstraction can only be defined with a multi-dimensional mapping m : Dn × Dc → (cid:3)Dn × (cid:3)Dcas follows:(cid:6)m(i, j) =(i, j)(ˆ4, (cid:13)rgb)i ∈ {1, 2, 3}, j ∈ {red, green, blue}i ∈ {4, 5, 6}, j ∈ {red, green, blue} .To further motivate the need for multi-dimensionality, we consider grid-cell domains, which are commonly used.Example 5.2 (grid-cell domains). Usually the grid-cells are represented by using two sorts row and column. The following rules show the part of a Sudoku encoding that guesses an assignment of symbols to the cells and ensures that each cell has a number.{sol(X, Y , N)} ← not occupied(X, Y ), num(N), row(X), column(Y ).hasNum(X, Y ) ← sol(X, Y , N), row(X), column(Y ).⊥ ← not hasNum(X, Y ), row(X), column(Y ).Further constraints ensure that cells in the same column (58) or same row (59) do not contain the same symbol.⊥ ← sol(X, Y 1, M), sol(X, Y 2, M), Y 1 < Y 2.⊥ ← sol(X1, Y , M), sol(X2, Y , M), X1 < X2.A further more involved constraint (cf. Appendix B.2) ensures that the cells in the same sub-region also satisfy this.31(57)(58)(59)Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563blue2red145green36{red,green,blue}Fig. 9. Joint abstraction of nodes and colors.xy1234xy12341234AB(a)1234AB234xy12341AB(b)(c)Fig. 10. Abstractions over grid-cells.An abstraction over the grid-cells would be to cluster the rows and columns together in order to define an abstract grid-cell. Although abstraction over the sorts one at a time can achieve certain abstract cell structures, to obtain more so-phisticated abstractions these sorts must be jointly abstracted. Consider for example the abstractions in Fig. 10. Those in Figs. 10a-10b can be achieved by independent mappings over the rows and columns such as mrow = mcol = {{123}(cid:17)→a123, {4}(cid:17)→a4} and mrow = mcol = {{12}(cid:17)→a12, {34}(cid:17)→a34}. For a given program (cid:2), one can construct the abstract program ((cid:2)mrow )mcol . However to achieve Fig. 10c, rows and columns must be jointly abstracted. While the cells (ai, b j), 1 ≤ i, j ≤ 2are singletons mapped from (i, j), the other abstract regions are only given bymrow,col(x, y) =⎧⎨⎩(a12, b34) x ∈ {1, 2}, y ∈ {3, 4}(a34, b12) x ∈ {3, 4}, y ∈ {1, 2}(a34, b34) x ∈ {3, 4}, y ∈ {3, 4}(60)Observe that the abstract row a12 describes a cluster that abstracts over the individual abstract rows a1, a2. The original rows {1, 2} are mapped to {a12} only in combination with columns {3, 4}, otherwise they are mapped to {a1, a2}.5.1. Existential abstraction on relationsThe abstraction method described in Section 3.1.2 aims at keeping the built-ins in the abstract program and finds a way to handle their different behavior in the abstract domain. However, this approach cannot be used to achieve the above mentioned multi-dimensional abstraction. Consider the rule (58) standardized apart over rows and columns, thus having relations X1 = X2 and Y 1 < Y 2. If for the mapping mrow,col in Fig. 10c these relations are lifted following Section 3.1.2, while the relation over the y-axis is still defined (as A is located above of B), i.e., AY ≤ B Y , the relation A X = B X is unclear as the abstract clusters for X -values are different due to different levels of abstraction.To tackle this issue, an alternative abstraction method is needed that also abstracts over the built-in relations and reasons over the abstracted relation (in the abstract domain). This leads us to a notion of abstraction that is similar in spirit to so called existential abstraction [25] and allows us to introduce domain mappings over multiple sorts such asm : D1 × . . . × Dn → (cid:3)D1 × . . . × (cid:3)Dn,and to handle relations over different levels of abstraction.For this, we introduce an abstract relation (cid:3)rel for a k-ary relation rel as follows:ˆdi ∈ (cid:3)D) (cid:3)rel(ˆd1, . . . , ˆdk) ⇔ ∃k(∀ki=1ˆdi ∈ (cid:3)D) neg_ (cid:3)rel(ˆd1, . . . , ˆdk) ⇔ ∃ki=1xi ∈ mi=1xi ∈ m−1(ˆdi).rel(x1, . . . , xk).−1(ˆdi).¬rel(x1, . . . , xk).(∀ki=1(62)I.e., (cid:3)rel(ˆd1, . . . , ˆdk) is true if for some corresponding original values the original relation holds; the opposite of (cid:3)rel(ˆd1, . . . , ˆdk), i.e. neg_ (cid:3)rel(ˆd1, . . . , ˆdk), is true otherwise. Notably, both versions may hold simultaneously, depending on the domain clusters.(61)32Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Example 5.3 (Example 3.1 ctd). For the mapping {1, . . . , 5}(cid:17)→k the abstract relation k (cid:3)≤ k holds true, as X ≤ Y for all X, Ymapped to k. Both k (cid:3)= k and k neg_(cid:3)= k hold true, as X1 = X2 holds only for some X1, X2 values mapped to k.Notice that having both rel and neg_rel hold means an uncertainty on the truth value of the relation in the abstract clusters. This brings us to determining the types of the relations over the abstract clusters, similar as before.Abstract relation types. The following cases τI − τIII occur in a mapping for the abstract relation predicates (cid:3)rel(ˆd1, . . . , ˆdk)and neg_ (cid:3)rel(ˆd1, . . . , ˆdk):(ˆd1, . . . , ˆdk) :(cid:3)rel(ˆd1, . . . , ˆdk) ∧ not neg_ (cid:3)rel(ˆd1, . . . , ˆdk)(cid:3)relτI(cid:3)relII (ˆd1, . . . , ˆdk) : neg_ (cid:3)rel(ˆd1, . . . , ˆdk) ∧ not (cid:3)rel(ˆd1, . . . , ˆdk)τ(cid:3)rel(cid:3)rel(ˆd1, . . . , ˆdk) ∧ neg_ (cid:3)rel(ˆd1, . . . , ˆdk)III (ˆd1, . . . , ˆdk) :τ(63)Type I is the case where the abstraction does not cause uncertainty for the relation, thus the rules that contain (cid:3)relwith type I can remain the same in the abstract program. Type II shows the cases where (cid:3)rel does not hold in the abstract domain. Type III is the case of uncertainty, which needs to be dealt with when creating the abstract rules. To ensure that an over-approximation is achieved, the head of the respective rule will be changed into a choice.For an abstraction m, we compute the set Tm∃ of all atoms τfor m.(cid:3)relι (ˆd1, . . . , ˆdk) where ι ∈ {I, II, III} is the type of (cid:3)rel(ˆd1, . . . , ˆdk)5.1.1. Abstraction procedureFor simplicity and ease of presentation, we consider programs with rules having (i) a single relation atom; and (ii) no cyclic dependencies between non-ground literals.Definition 5.1 (rule abstraction). Given a rule r : α ← Bstd(r), rel(t1, . . . , tk) and a domain mapping m, the set rmfollowing rules.∃ contains the (cid:3)rel(ˆt1, . . . , ˆtk).(a) m(α) ← m(Bstd(r)), τI(cid:3)relIII (ˆt1, . . . , ˆtk).(b) {m(α)} ← m(Bstd(r)), τ(c) For all L ⊆ Bstd,−(r):{m(α)} ← m(Bsh{m(α)} ← m(Bsh(cid:3)rel(ˆt1, . . . , ˆtk), not isSingleton(m(t)).L (r)), τI(cid:3)relIII (ˆt1, . . . , ˆtk), not isSingleton(m(t)).L (r)), τwhere BshL (r)=Bstd,+(r) ∪ L, not Bstd,−(r)\L.t ∈ arg(αi), αi ∈ LThe idea is to introduce guesses when there is an uncertainty over the relation holding in the abstract domain (b), or over the negated atoms due to the abstract clusters (c) (by considering all combinations of the negative literals), and otherwise just abstracting the rule (a).The abstraction procedure introduced in Definition 5.1 obtains semantically the same abstract program as in Defini-tion 3.4 for rules of formα ← Bstd(r), rel(t1, t2).where rel(t1, t2) = t1 ◦ t2 is a binary relation with ◦ ∈ {=, (cid:13)=, <, ≤, >, ≥}.Definition 5.2 (existential abstract program (cid:2)m(cid:5)∃ ). Given a program (cid:2) and a domain mapping m, we denote by(cid:2)m∃ =∃ ∪ {x. | x ∈ Tm∃ } ∪ {m(p((cid:22)c)). | p((cid:22)c). ∈ (cid:2)} ∪ {isSingleton(ˆd) | |mrm−1(ˆd)| = 1}.(64)r: α←Bstd(r),rel(t1,t2)∈(cid:2)the program obtained from (cid:2) under existential abstraction using m.We then haveTheorem 5.1. For any domain mapping m of a (standardized apart) program (cid:2) with rules having a single relation atom and no cyclic dependencies between non-ground literals, A S((cid:2)m) and A S((cid:2)m∃ ) coincide (modulo auxiliary atoms).A generalization to multiple relation atoms and handling cyclic dependencies by removing the restrictions (i)-(ii) can be done similarly as in cases (G-II) and (G-III) of Section 3.2.33Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Example 5.4 (Example 3.1 ctd). For the program (cid:2) in (4)-(6) with the choice rules (28)-(29) and m = {{1, . . . , 5}(cid:17)→k}, the program (cid:2)m∃ is:c(X) ← not d(X), dom(X).{c(X)} ← not isSingleton(X), dom(X).d(X) ← not c(X), dom(X).{d(X)} ← not isSingleton(X), dom(X).b(X, Y ) ← a(X), d(Y ).ˆ(cid:13)=I (X, Y ).e(X) ← c(X), a(Y ), τ{e(X)} ← c(X), a(Y ), τ⊥ ← b(X, Y ), e(X1), τ ˆ=ˆ(cid:13)=III (X, Y ).I (X, X1).(65)(66)with the abstract fact a(k); furthermore, we have Tm∃ = {τin (65) and (66) respectively, as they are involved in a negative cycle, similar as in rules (35) and (37) of Example 3.19.III (k, k)}. Note that the atoms d( X) and c( X) are omitted ˆ(cid:13)=III (k, k), τ ˆ=The abstract program is similar to the one constructed by lifting the relations in Example 3.19. As can be easily checked, the programs have modulo the auxiliary atoms the same abstract answer sets.We note that the previous refinement methods can be applied to the abstract program constructed in this way as well, since nothing changes with regard to how this program can be refined. Furthermore, we observe that for treating n-ary relations where n > 2, we can modify Definition 5.1 to create finer abstractions.Example 5.5. Consider the argument Z of the following rule involving addition:r : e(Z ) ← c(X), a(Y ), Z = X + Y .(67)We denote Z = X + Y with the relation plus( X, Y , Z ). Regarding the arguments, we have arg(e(Z )) ∩ arg(plus( X, Y , Z )) = {Z } (cid:13)= ∅ while arg(e(Z )) ∩ { X, Y } = ∅, where X, Y are the shared arguments of the body literals with the relation plus, i.e., arg(B(r)) ∩ arg(plus( X, Y , Z )) = { X, Y }. Consider the mapping m : {1} (cid:17)→ a1, {2, 3} (cid:17)→ a23, {4, 5} (cid:17)→ a45 and X=a1, Y =a1. For the abstract relation (cid:13)plus, both (cid:13)plus(a1, a1, a23) and neg_(cid:13)plus(a1, a1, a23) hold true, due to 1 + 1 = 2 and 1 + 1 (cid:13)= 3. As Zis not used in the body literals, it does not cause uncertainties for applying the rule in the abstraction, which is caught bye(Z ) ← c(X), a(Y ), τ(cid:3)rel( X,Y , Z )III, isSingleton(X), isSingleton(Y ).In general, by adding in Definition 5.1 the rulem(α) ← m(Bstd(r)), τ(cid:3)relIII (ˆt1, . . . , ˆtk),ˆti ∈argi (rel)\arg(α) isSingleton(ˆti).if arg(α) ∩ arg(rel) (cid:13)= ∅ and arg(α) ∩ arg(Bstd(r) ∩ arg(rel)) = ∅.(cid:14)the guess in (b) can be avoided, if all arguments of rel not involved in the head l are singleton clusters.The use of abstract relations opens a wide range of possible applications, as it simplifies the use of a given program without preprocessing it to match the restrictions over the forms of the relations for the previous abstraction method.5.1.2. Computing joint abstract relation typesAbstract relations can be easily employed with abstraction mappings over several sorts in the domain as m : D 1 × · · · ×Dn → (cid:3)D1 × · · · × (cid:3)Dn. If a rule has relations over the sorts, a joint abstract relation combining them must be computed. We show an example of grid-cell abstraction for illustration.Example 5.6 (abstracting grid-cells). Consider the relations rel1( X1, X2): X1 = X2 and rel2(Y 1, Y 2): Y 1 < Y 2 for X1, X2 ∈ row, Y 1,(cid:15)relIII , where (cid:15)rel combines Y 2 ∈ column, from standardizing apart the variables in (58). The rules to compute the types τrel1 and rel2, are as follows:(cid:15)relI, τ1. Define the abstract relations. This step corresponds to the existential abstraction (61).(cid:13)rel1(( ˆX1, ˆY 1), ( ˆX2, ˆY 2)) ← rel1(X1, X2), m((X1, Y 1), ( ˆX1, ˆY 1)), m((X2, Y 2), ( ˆX2, ˆY 2)).(cid:13)rel2(( ˆX1, ˆY 1), ( ˆX2, ˆY 2)) ← rel2(Y 1, Y 2), m((X1, Y 1), ( ˆX1, ˆY 1)), m((X2, Y 2), ( ˆX2, ˆY 2)).34Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 1035631, ... , dn21, ... , dn21 ), ˆc1), . . . , m((d11 ), ˆc1), . . . , m((d1k , ... , dn2k , ... , dn2k ), ˆck).k ), ˆck).(cid:3)reli(ˆc1, ... , ˆck) ← reli(dineg_ (cid:3)reli(ˆc1, ... , ˆck)← ¬reli (di1, ... , dik), m((d1ττk), m((d11, ... , di(ˆc1, . . . , ˆck) ← (cid:3)reli(ˆc1, . . . , ˆck), not neg_ (cid:3)reli (ˆc1, . . . , ˆck).(ˆc1, . . . , ˆck) ← not (cid:3)reli(ˆc1, . . . , ˆck), neg_ (cid:3)reli (ˆc1, . . . , ˆck).(cid:3)reliI(cid:3)reliII(cid:3)reliIII (ˆc1, . . . , ˆck) ← (cid:3)reli(ˆc1, . . . , ˆck), neg_ (cid:3)reli(ˆc1, . . . , ˆck).τ(cid:2)rel1,...,reln1I(cid:2)rel1,...,reln1IIIττ(ˆc1, . . . , ˆck) ← τ(ˆc1, . . . , ˆck) ← τ(ˆc1, . . . , ˆck), . . . , τ(cid:3)rel1I(cid:3)reliIII (ˆc1, . . . , ˆck),(cid:14)(ˆc1, . . . , ˆck).(cid:3)rel jIIn2j=1: j(cid:13)=i not τ(ˆc1, . . . , ˆck).(cid:3)reln1Ii = 1, . . . n1i = 1, . . . n1i = 1, . . . , n1i = 1, . . . , n1i = 1, . . . , n1i = 1, . . . , n1Fig. 11. Computation of multi-dimensional relation types (ˆc j = (ˆd1j , . . . , ˆdn2j ), 1 ≤ j ≤ k).The negations neg_(cid:13)rel1, neg_(cid:13)rel2 are computed similarly as (62).neg_(cid:13)rel1(( ˆX1, ˆY 1), ( ˆX2, ˆY 2)) ← ¬rel1(X1, X2), m((X1, Y 1), ( ˆX1, ˆY 1)), m((X2, Y 2), ( ˆX2, ˆY 2)).neg_(cid:13)rel2(( ˆX1, ˆY 1), ( ˆX2, ˆY 2)) ← ¬rel2(Y 1, Y 2), m((X1, Y 1), ( ˆX1, ˆY 1)), m((X2, Y 2), ( ˆX2, ˆY 2)).2. Compute the types of each abstract relation (cid:3)reli, i ∈ {1, 2} with the objects ˆCi = ( ˆXi, ˆY i), i ∈ {1, 2} as (63).( ˆC1, ˆC2) ← (cid:15)reli( ˆC1, ˆC2), not neg_ (cid:15)reli( ˆC1, ˆC2).( ˆC1, ˆC2) ← not (cid:15)reli( ˆC1, ˆC2), neg_ (cid:15)reli( ˆC1, ˆC2).(cid:15)reliτI(cid:15)reliτII(cid:15)reliIII ( ˆC1, ˆC2) ← (cid:15)reli( ˆC1, ˆC2), neg_ (cid:15)reli( ˆC1, ˆC2).τ3. Compute the types of the joint abstract relation (cid:3)rel over (cid:3)reli, i ∈ {1, 2}:( ˆC1, ˆC2), τ(cid:13)rel1II(cid:13)rel2I(cid:15)rel(cid:13)rel1( ˆC1, ˆC2) ← ττII(cid:15)relIII ( ˆC1, ˆC2) ← not ττ(cid:13)rel1(cid:15)relIII ( ˆC1, ˆC2) ← ττIII( ˆC1, ˆC2).(cid:13)rel2III(cid:13)rel2II( ˆC1, ˆC2).( ˆC1, ˆC2).( ˆC1, ˆC2), τ( ˆC1, ˆC2), not τThe mapping (60) shown in Fig. 10c gives the types τing abstract pairs.(cid:15)relI(cid:15)rel((a1, b1), (a1, b2)), τI((a2, b1), (a2, b2)) and τ(cid:15)relIIIfor the remain-Fig. 11 presents the multi-dimensional case, that is computing abstract k-tuple relations for given relations rel1, ... , reln1over variables from (cid:3)D1, . . . , (cid:3)Dn2 . We assume for simplicity a uniform arity k.Note that for the joint abstract relation (cid:15)rel, type τcomputation is not needed, as the abstract rule construction only (cid:15)rel with the combination of the deals with types I and III. To emphasize the abstracted relations, we may denote (cid:15)rel in τrelations the abstract relation is built on; e.g., for the joint relation type of rel1( X1, X2): X1 = X2 and rel2(Y 1, Y 2): Y 1 < Y 2we write τ =,<, τ =,<.(cid:15)relIIThe multi-dimensional abstraction constructs an abstract structure, i.e., object, over the abstracted sorts where not all combinations of the abstract sorts yield a valid object. To illustrate this, in Example 5.1 the color cluster (cid:13)rgb can only be considered with the node cluster ˆ4. This also needs to be taken into account when constructing the abstract program.IIIIExample 5.7. The abstract program for Sudoku (57)-(59), where the occurrences of row( X), column(Y ) are replaced by cell( X, Y ), is as follows.hasNum(X, Y ) ← sol(X, Y , N), cell(X, Y ).{sol(X, Y , N)} ← not occupied(X, Y ), num(N), cell(X, Y ).{sol(X, Y , N)} ← occupied(X, Y ), num(N), not isSingleton(X), cell(X, Y ).{sol(X, Y , N)} ← occupied(X, Y ), num(N), not isSingleton(Y ), cell(X, Y ).⊥ ← not hasNum(X, Y ), cell(X, Y ).⊥ ← sol(X1, Y 1, M), sol(X2, Y 2, M), τ =,<⊥ ← sol(X1, Y 1, M), sol(X2, Y 2, M), τ <,=II(X1, Y 1, X2, Y 2), cell(X, Y 1), cell(X2, Y 2).(X1, Y 1, X2, Y 2), cell(X1, Y ), cell(X2, Y 2).35Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563a1a2a34a5a6a78(1)(2)b12(3)b34b1b2b3b4b5678(4)b5678Fig. 12. Quad-tree representation for regions.a1234a56785.1.3. Refinement of multi-dimensional abstractionsThe refinement method introduced in Section 4 can be used for multi-dimensional abstractions as well. For this to work, we need the k-tuples, on which the abstraction will be made, to occur in the rules. For example, for a 2-dimensional ab-straction, the pairs X, Y should appear in the rules together. This will ensure that when the meta-programs are constructed as in Definitions 4.4 and 4.5, the abnormality atoms will contain these tuples.The non-ground query Q mˆIin Definition 4.3 must be updated with mappings of form m(( X1, Y 1), ( ˆX1, ˆY 1)) instead of m( X1, ˆX1). The program (cid:2)hint that gets hints refine(c1, . . . , cn) about which cluster to refine in Definition 4.7 also needs to be updated, so that it can be used to refine the multi-dimensional abstraction mapping. For example, in case of a 2-dimensional abstraction mapping, for cxi , c yi∈ arg(ab_deactnr (cx, y)), where cx, y = cx1 , c y1 , . . . , cxn , c yn , we will haverefine(cx, y) ← ab_deactnr (cx, y), m(cxi , c yi , axi , a yi ), not isSingleton(axi ).refine(cx, y) ← ab_deactnr (cx, y), m(cxi , c yi , axi , a yi ), not isSingleton(a yi ).(68)(69)In fact, if we focus only on the abstract region that needs to be refined, we may use atoms refine(axi , a yi ) in the heads of the rules (68) and (69), and then decide on a refinement for the region (axi , a yi ). A similar change will be needed for ab_deactConsnr and ab_act.After these changes the refinement method can be applied to multi-dimensional abstractions. More information on our approach to deciding on a refinement in the implementation is given in Section 6.2.2.5.2. Quad-tree abstractionGrid-cell environments are a particular type of environment which describes a structure. For problems over grid-cells, it is often the case that certain parts of the environment are crucial to finding a solution. In order to obtain an abstraction over a grid-cell that allows to adjust its granularity, multi-dimensionality must be considered. Multi-dimensional abstraction allows us to express abstractions where one sort in the domain (e.g., an X coordinate) is abstracted depending on its context, i.e., depending on a second sort in the domain it occurs with (e.g., a Y coordinate).For a systematic refinement of abstractions on grid-cell environments, we consider a generic quad-tree representation (Fig. 12), which is a concept used, e.g., in path planning [69]. Initially, an environment may be abstracted to four regions of n/2 × n/2 grid-cells each. This amounts to a tree with four leaf nodes that correspond to the main regions. Each region then contains 4 leaves of smaller regions. The leaves of the quad-tree are then the original cells of the grid-cell at level 0. A refinement of a region amounts to dividing it into four subregions, i.e., sprouting the respective node to four children. Given the original X and Y coordinates a1, . . . , an and b1, . . . , bn, respectively, we represent the coordinates of an abstract region with level log2(k+1), for 0 ≤ k < n, defined over the cells within the coordinates ai, . . . , ai+k and b j, . . . , b j+k, respectively, by the shorthand notation (ai...i+k, b j... j+k).Starting with an initial abstraction of level log2(n), using quad-tree split operations as abstraction refinement operations, we can automatically search for suitable quad-tree-structured abstractions in grids (see Section 6.2.2). Importantly, multi-dimensional abstraction refinement is structure aware: refining one of the squares of a quad-tree (e.g., area (3) in Fig. 12) maintains the structure of the abstraction of all other squares.We illustrate next how such a structure can be used to adjust the granularity of the abstraction over the grid-cell.Example 5.8 (Reachability). Suppose one wants to check whether all cells are reachable from a given starting point in a grid with obstacles. In case there are unreachable cells, this is due to obstacles separating them from other cells. For a person, a glance over the area with the obstacles will be sufficient to realize that some cells are unreachable. The rules below compute the obstacle-free cells (i.e., points) that are reachable from the starting point; an additional constraint (75) checks whether all points are reachable.point(X, Y ) ← not obsAt(X, Y ), row(X), column(Y ).(70)36Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563•Fig. 13. Original grid-cell domain.(a) Initial abstraction(b) Distinguishing the obstacles that cause unreachability•start(a1234, b1234).obs At(a1234, b1234).obs At(a1234, b5678).obs At(a5678, b1234).obs At(a5678, b5678).•start(a12, b12).obs At(a1, b4). obs At(a2, b4).obs At(a3, b5). obs At(a4, b6).obs At(a3, b7). obs At(a4, b8).obs At(a12, b12).obs At(a5678, a1234).obs At(a5678, a5678).Fig. 14. Abstractions over the grid-cell domain with obstacles in Fig. 13.reachable(X, Y ) ← start(X, Y ).reachable(X1, Y 1) ← reachable(X, Y ), point(X1, Y 1), neighbor(X, Y , X1, Y 1).neighbor(X, Y , X1, Y ) ← | X − X1| = 1, column(Y ).neighbor(X, Y , X, Y 1) ← |Y − Y 1| = 1, row(X).⊥ ← point(X, Y ), not reachable(X, Y ), row(X), column(Y ).(71)(72)(73)(74)(75)Fig. 13 shows an instance of a grid-cell domain with obstacles; the program is unsatisfiable on it due to the unreachable cells in the lower left area. Fig. 14 shows two abstractions over the grid-cells, including the abstracted start and obstacle positions, the initial abstraction dividing the grid-cell into 4 regions (Fig. 14a), and an abstraction that distinguishes the area which shows the obstacles causing unreachable cells in the lower-left corner (Fig. 14b). Appendix B.3 provides a detailed example of applying automatic refinement (Section 5.1.3) and the mDASPAR tool (Section 6.2.2) to this example.6. Implementation and evaluation6.1. Overall methodologyThe abstraction and refinement method for domain abstraction is shown in Algorithm 2. In the initialization phase, the abstract program is constructed for the mapping m depending on the mode of abstraction (lifted or existential) on the built-ins (Line 2); the relation types are also computed in this step. After constructing the debugging program (Line 3), some abstract answer set is computed (Lines 5), and its concreteness checked with a call to the function getASWithMinAbAtomson the non-ground query Q mwith ˆIminimal number of ab atoms. If the latter is positive (i.e., ˆI is spurious), m is refined given the ab atoms found in the check (Line 9) and the abstract program and the relation types are recomputed before looping back to evaluation. Among possible variations of the algorithm, we want to mention the following.(Definition 4.3) for m and ˆI (Line 6), which returns an answer set of (cid:2)debug ∪ Q mˆIAbstraction over subdomains/sorts For abstraction over a particular subdomain resp. sort, Algorithm 2 can be extended with a predicate name s for the sort in the input and the computation of the abstract program, the relation types and the debugging program focused on the domain elements related with s.Correctness checking for relevant atoms The correctness checking of abstract answer sets can be confined to the relevantatoms describing the solution by constructing Q m(Line 6) only for these atoms. An abstract answer set will then pass as ˆIconcrete as long as it describes a concrete solution with respect to them.37Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Algorithm 2: Domain-Abs&Ref .Input: program (cid:2), domain mapping minit , mode (lifted or existential)Output: (cid:2)m , a mapping m refining minit , and an abstract answer set ˆI of (cid:2)m resp. ∅ if (cid:2)m is unsatisfiable.);*/1 m = minit ;2 [(cid:2)m, Tm] = constructAbsProg((cid:2), m, mode);3 (cid:2)debug = constructDebugProg((cid:2));4 while A S((cid:2)m ∪ Tm) (cid:13)= ∅ doGet ˆI ∈ A S((cid:2)m ∪ Tm);5C = getASWithMinAbAtoms((cid:2)debug ∪ Q m6ˆIif C|ab = ∅ then /* ˆI is concrete7return (cid:2)m, m, ˆI891011 return (cid:2)m, m, ∅m = decideRefinement(m, C|ab);[(cid:2)m, Tm] = constructAbsProg((cid:2), m, mode);Diverse abstract answer sets The refinement decision may be made by looking at multiple abstract answer sets rather than a single one. Lines 5-8 are changed to collect the checking results C1, . . . , Cn for abstract answer sets I1, . . . , In; then decideRefinement can use the collected results C1|ab, . . . , Cn|ab (all assumed to be nonempty) for deciding on a refinement. We call (v1) the refinement approach where the answer set Ci with the least cost (aggregated from the collection) is picked, while refinement approach (v2) decides by choosing the refine atom that occurs most frequently in the answer sets C1, . . . , Cn.6.2. ImplementationThe methodology in Section 6.1 has been implemented in tools called DASPAR and mDASPAR based on clingo 5.2.2, Python and the Ouroboros debugging tool [93], whose MetaTranslator is exploited to obtain a reified program for which then the debugging program is constructed (cf. Section 4); negative cycles are merged as described in Section 3.2.3. More de-tails are provided in the next subsections. The implementations are online available at http://www.kr.tuwien .ac .at /research /systems /abstraction/.6.2.1. DASPARThe program DASPAR supports abstraction from sorts, but the input program (cid:2) must adhere to certain restrictions: each variable in a rule must be guarded by a domain predicate; if the abstraction should be on some subset S of sorts, then the variables referring to the sorts in S must be standardized apart. For example, a rule of forma(X) ← b(X, X1), c(X2), d(X2), X ≤ X1.needs to be converted intoa(X) ← b(X, X1), c(X2), d(X3), X ≤ X1, X2 = X3, dom(X), dom(X1), dom(X2), dom(X3).with domain predicate dom. In order to support the case of having more than one relation, a syntactic change on the rule has to be made. These relations need to be combined into an auxiliary relation atom which represents the combination of the relations. The above rule needs to be converted intoa(X) ← b(X, X1), c(X2), d(X3), leqEqu4(X, X1, X2, X3).where leqEqu4( X, X1, X2, X3) is an auxiliary atom which holds true whenever the respective relation holds true for its arguments. A basic set of auxiliary relation combinations are built into the tool, and more can easily be added.DASPAR is invoked as follows.python daspar.py prog mapping pred ref_type <focus_atoms>Here prog contains the original program in the input format and the mapping the abstraction mapping information. DASPAR supports abstraction on one sort (see Section 6.2.2 for multi-dimensional tool mDASPAR), thus pred should be the name of the sort to the abstracted. The parameter ref_type allows to specify whether the refinement should respect an order relation (1) or not (0) (see Section 3.3.1). If 1 is given, the refinement step considers only splitting the domain, while when 0 is given the refinement step is unrestricted. The parameter <focus_atoms> is an optional input for projection in the correctness check (see Section 6.1).DASPAR has different settings for picking abstract answer sets and for deciding on a refinement. For the former, by default the first computed answer set is picked. This can be changed to considering a diverse set of abstract answer sets. For deciding on a refinement, the two forms mentioned in Section 4 are implemented. Later, we evaluate the effects of having these different settings in the methodology on the achieved resulting abstractions.38Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563point(X,Y) :- not obsAt(X,Y), row(X), column(Y).reachable(X,Y) :- start(X,Y), row(X), column(Y).reachable(X1,Y1) :- reachable(X,Y), point(X1,Y1), neighbor(X2,Y2,X3,Y3),equEqu4(X,X2,X1,X3), equEqu4(Y,Y2,Y1,Y3),row(X), column(Y), row(X1), column(Y1),row(X2), column(Y2), row(X3), column(Y3).:- point(X,Y), not reachable(X1,Y1), X=X1, Y=Y1,row(X), column(Y), row(X1), column(Y1).neighbor(X,Y,X1,Y1) :- dist1(X,X1), Y=Y1, row(X), column(Y), row(X1), column(Y1).neighbor(X,Y,X1,Y1) :- X=X1, dist1(Y,Y1), row(X), column(Y), row(X1), column(Y1).Fig. 15. Input program with the rules (70)-(75). Subdomain predicates are row and column.For practical purposes, sorts can be overlapping, provided that all occurrences of a sort are guarded by subdomain predicates. E.g., the blocksworld has sorts block and time which both can use integers. Note that this restriction is to aid the machine knowing about the relations of the arguments, which the user implicitly knows when encoding the problem. With this guidance, it becomes clear which arguments in the rule the abstraction should focus on.6.2.2. mDASPARThe program mDASPAR extends DASPAR to multi-dimensional domain abstraction. It handles 2-dimensional abstractions with a quad-tree style refinement process, and it can be applied to problems over cells in grids of size n = 2k for k ≥ 2. We discuss some challenges of multi-dimensional abstractions that are tackled in the system.Abstract objects A multi-dimensional abstraction creates abstract objects for tuples of concrete objects; not all combinations of the abstracted sorts, e.g., row and column, correspond to a valid object. To avoid such combinations, the constructed abstract program should comply to only using the abstract objects in the rules. For this, mDASPAR post-processes the abstract program and replaces the occurrence of the abstracted sorts with a new object name.Note that for “grouping” objects automatically and correctly, the system needs some guidance. For a given encoding, humans are capable of detecting the cells implicitly, whereas a machine cannot do this readily. The user must provide it with some guidelines to recognize the objects, by adjusting the encoding so that the grids are explicitly shown. For this, we impose some syntactic restrictions on the input program, on which the post-processing technique relies.Given two sorts s1, s2 for a 2-dimensional abstraction, the input program should adhere to the following restrictions in order to achieve a correct object naming:(1) The rules should have atoms that contain pairs X, Y of variables where X ∈ s1, Y ∈ s2, and(2) the subdomain predicates for sorts s1, s2 should be written in the order of the pairs.If these restrictions are satisfied, then mDASPAR can correctly convert the sort names to the abstract object name cell. For example, row( X1), column(Y 1) is changed to cell( X1, Y 1).Example 6.1 (ctd). The rule (72) will be standardized apart intoreachable(X1, Y 1) ← reachable(X, Y ), point(X1, Y 1), neighbor(X2, Y 2, X3, Y 3),X = X2, X1 = X3, Y = Y 2, Y 1 = Y 3.Then the multiple relations related with a sort should be converted into an auxiliary relation atom:reachable(X1, Y 1) ← reachable(X, Y ), point(X1, Y 1), neighbor(X2, Y 2, X3, Y 3),equEqu4(X, X2, X1, X3), equEqu4(Y , Y 2, Y 1, Y 3).The subdomain predicates for the rule above also need to be written in a format where the pairs ( X, Y ), ( X1, Y 1), ( X2, Y 2), and ( X3, Y 3) appear together. Fig. 15 shows the resulting rules in the input program, including all subdomain predicates.Relation type computation When abstracting a rule, mDASPAR gathers the relations in it related with the abstracted sorts and creates an abstract relation atom following the description in Section 5. The relation type facts (τ ) are computed using auxiliary programs.The program mDASPAR is invoked similarly to DASPAR, but with an additional parameter size which is the number n. The next example shows the input format of mDASPAR and the created abstract program.Example 6.2 (ctd). Fig. 15 shows the input program for mDASPAR with the rules (70)-(75) where variables are standardized apart. The program constructed for abstracting over the sorts row, column is shown in Fig. 16, where the occurrence of the sorts are renamed with a new object cell. The rules of the original program are numbered (r1, . . . , r6) and the relation 39Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563point(X,Y) :- cell(X,Y), not obsAt(X,Y).{ point(X,Y) } :- cell(X,Y), obsAt(X,Y),not isSingleton(X).{ point(X,Y) } :- cell(X,Y), obsAt(X,Y),not isSingleton(Y).reachable(X,Y) :- start(X,Y), cell(X,Y).reachable(X1,Y1) :- reachable(X,Y), point(X1,Y1), neighbor(X2,Y2,X3,Y3),cell(X2,Y2), cell(X3,Y3), cell(X,Y), cell(X1,Y1),relr3(X,Y,X2,Y2,X1,Y1,X3,Y3,i).{ reachable(X1,Y1) } :- reachable(X,Y), point(X1,Y1), neighbor(X2,Y2,X3,Y3),cell(X2,Y2), cell(X3,Y3), cell(X,Y), cell(X1,Y1),relr3(X,Y,X2,Y2,X1,Y1,X3,Y3,iii).:- point(X,Y), cell(X,Y), cell(X1,Y1),not reachable(X1,Y1), relr4(X,Y,X1,Y1,i).neighbor(X,Y,X1,Y1) :- dist1(X,X1), cell(X,Y), cell(X1,Y1), relr5(Y,Y1,i).{ neighbor(X,Y,X1,Y1) } :- dist1(X,X1), cell(X,Y), cell(X1,Y1), relr5(Y,Y1,iii).neighbor(X,Y,X1,Y1) :- dist1(Y,Y1), cell(X,Y), cell(X1,Y1), relr6(X,X1,i).{ neighbor(X,Y,X1,Y1) } :- dist1(Y,Y1), cell(X,Y), cell(X1,Y1), relr6(X,X1,iii).Fig. 16. Non-ground abstract program constructed by mDASPAR.atoms in the abstract program are named w.r.t. the rule number. For example, the constraint (75) is numbered r4, and the standardization creates the relations X = X1 and Y = Y 1; in the abstraction the joint relation type atom becomes τ =,=( X, Y , X1, Y 1), in its Ibody is unsatisfiable and gets omitted in the abstraction (similar to omitting (14) in Example 3.13).( X, Y , X1, Y 1) for type I. The abstracted constraint containing the type III relation atom, i.e., τ =,=IIIFurthermore, standardizing apart the variables of the negative literal in (75) relaxes its aim of ensuring that all points are reachable to hold only when the abstraction is refined enough to satisfy the relation atom relr4(X,Y,X1,Y1,i). Having (75) without standardization would ensure it is satisfied in coarser abstractions. We standardized apart the variables of the negative literal as well to obtain more fine-grained abstractions that distinguish the original cells to reach a concrete solution. This makes it easier to visualize the resulting abstractions and understand solutions obtained.6.2.3. Implementation aspects of mDASPARTwo-phase debugging. The multi-dimensionality of the domain mapping gives rise to many possible causes of spuriousness. Debugging the non-ground spuriousness by searching for the answer set with smallest number of ab atoms can become more difficult. To handle this, we implemented a two-phase debugging approach. In phase 1, the debugging program (cid:2)debugis created by modifying the debugging atoms ab_deact, ab_deactCons of Definition 4.5 to have only the rule name as argu-ments. We denote this program by (cid:2)debug0. This then results in an easier computation of an answer set with minimal abatoms. In phase 2 a new program (cid:2)debug is created according to the original definition, but the ab atoms are only created for the rule names or atoms occurring in the ab atoms of I . This way, the search for an optimal answer set focuses on the trouble-making rules/atoms.Steer debugging towards constraints. In the problems we focus on, the constraints in the program cause to have unsatisfi-ability or to obtain a particular solution for a given instance. In order to help with reaching abstractions where the relevant constraints are distinguished, we assign less cost to obtaining answer sets with ab_deactCons atoms in the optimal answer set search during debugging.Getting hints. Since the refinement of a region means to split it into four subregions, we only need to get the hint of which region to refine. This is different from the hints obtained for DASPAR, as there a decision for refinement relies on the domain elements occurring in the debugging atoms. We alter the refine atoms to get the information of which abstract domain occurs as a reason for spuriousness.Modular concreteness checking. In some cases, even the two-phase checking may not help with easily finding the optimal answer set during the debugging step as the original domain is large or many atoms cause to consider many possible concretizations. We thus considered two orthogonal approaches:(1) For programs that are modular and contain a clear order on the atoms (e.g. in a plan), the checking is done incrementally over the approach, similar in spirit to [53] which builds on the concept of modules [94].(2) Using a hierarchy of abstractions (as possible by Proposition 3.6), the checking is done via incrementally concretizing the abstract domain, following an iterative deepening style (Fig. 17).The aim of Approach (1) is to avoid checking the whole ordered sequence of atoms (e.g., a plan), and catching the spuriousness in some prefix. Approach (2) is applied to avoid making the concreteness check directly at the original domain. If the abstract answer set is spurious, this may be detected in the partially concretized domain. We then check correctness of ˆI on the abstract level mi using (cid:2)mi . If ˆI is concrete w.r.t. the partially concretized abstraction, the concretization is 40Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Fig. 17. Step-wise partial concretization of a grid-cell abstraction.increased for redoing the check. However, if spuriousness is detected, the mapping is refined and the partial concretization continues from the updated mapping.Further details on the implementation can be found in Appendix B.4.6.3. Evaluation: obtaining abstract solutionsThe main aim of our evaluation was to see whether the domain abstraction and refinement method from above can find automatically non-trivial domain abstractions that yield concrete answer sets. We also wanted to observe the effect of variants of picking abstract answer sets (Section 6.1) or making refinement decisions (Section 4).6.3.1. ExperimentsWe used DASPAR v0.2 for the experiments, which employs the sophisticated debugging program for concreteness check-ing.5 The variations we considered are as follows.• When computing abstract answer sets, we either (s) pick a single abstract answer set or (div) pick a (diverse) set of answer sets w.r.t. the focus atoms.• Deciding on a refinement is either done (v1) by assigning costs to possible refinements and picking the one with smallest cost or (v2) by using the hints obtained from the debugging atoms while checking. For (v2), it is ensured that the distinct domain elements in the picked debugging atom do not occur in the same cluster.We conducted experiments on two benchmark problems from ASP competitions, viz. graph coloring and disjunctive scheduling. For graph coloring, we randomly generated 20 graphs on 10 nodes with edge probability 0.1, 0.2, . . . , 0.5 each; out of the 100 graphs, 74 were 3-colorable. We used two different graph coloring encodings shown in Fig. 18, to see their effect in the resulting abstractions. In the first encoding GCenc1 (Fig. 18a), a color assignment to each node is guessed as (76)-(78) with the common approach of using default negation, the auxiliary atom hasEdgeTo( X, C) shows which colors Cthe node X has as its neighbors. The second encoding GCenc2 (Fig. 18b) uses a choice rule (83) to guess an assignment and then ensures with (84) that a node is not assigned more than one color. The rules (85)-(86) are an alternative way of writing the rule ⊥ ← chosenColor( X1, C), chosenColor( X2, C), edge( X1, X2), X1 < X2. so that when the variables are standardized apart for the sort node, fewer relation atoms occur in one rule. Also notice that GCenc2 imposes an order relation among the nodes, to reduce duplications of the constraints.For disjunctive scheduling, for each t ∈ {10, 20, 30}, we generated 20 instances with 5 tasks over time {1, . . . , t}. We used the encoding6 from ASP Competition 2011 and precomputed the deterministic part (i.e., not involved in unstratified negation resp. guesses) of the program, so that they are lifted to the abstract program without introducing (unnecessary) nondeterminism (see Appendix B.2). The initial abstraction mapping is the single-cluster abstraction, i.e., clustering all nodes into one for graph coloring and all time points into one for disjunctive scheduling.In the experiments, we use the lifted relation approach. While in existential abstraction on the relations (Section 5.1) there are fewer relation types to consider, we observed no improvement in the computation effort, since type III for abstract relations is a combination of type III and IV of lifted relations. Thus, it does not make a difference which relation type approach is used in the experiments.5 Results for version v0.1 were reported in [113].6 www.mat .unical .it /aspcomp2011 /files /DisjunctiveScheduling /disjunctive _scheduling .enc .asp.41Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563chosenColor( X, r) ← not chosenColor( X, g), not chosenColor( X, y), node( X).chosenColor( X, g) ← not chosenColor( X, r), not chosenColor( X, y), node( X).chosenColor( X, y) ← not chosenColor( X, g), not chosenColor( X, r), node( X).hasEdgeTo( X, C) ← edge( X, Y ), chosenColor(Y , C).⊥ ← hasEdgeTo( X, C), chosenColor( X, C).colored( X) ← chosenColor( X, C).⊥ ← node( X), not colored( X).{chosenColor( X, C)} ← node( X), color(C).(a) GCenc1⊥ ← chosenColor( X, C1), chosenColor( X, C2), C1 (cid:13)= C2.adj( X, Y ) ← edge( X, Y ), X < Y .⊥ ← adj( X, Y ), chosenColor( X, C), chosenColor(Y , C).colored( X) ← chosenColor( X, C).⊥ ← node( X), not colored( X).(b) GCenc2(76)(77)(78)(79)(80)(81)(82)(83)(84)(85)(86)(87)(88)Fig. 18. Two encodings of the Graph Coloring problem: GCenc1 and GCenc2.Table 4Experimental results for graph coloring.GCenc1GCenc2number of stepsabstraction domain sizefaithful abstraction domain sizetrivial abstractions (id)faithful & non-id abstractionsnon-faithful abstractionsnumber of stepsabstraction domain sizefaithful abstraction domain sizetrivial abstractions (id)faithful & non-id abstractionsnon-faithful abstractionsfullprojected(s)(div)(s)(div)(v1)7.388.386.8413%30%57%7.018.018.8819%22%59%(v2)7.838.848.0423%32%45%6.408.648.6213%24%63%(v1)7.048.046.124%29%67%6.567.567.975%25%70%(v2)7.698.697.5112%27%61%6.378.298.6613%22%65%(v1)5.246.246.022%56%42%3.534.534.863%54%43%(v2)6.487.485.711%61%38%3.766.735.442%59%39%(v1)4.835.835.652%50%48%3.404.404.753%54%43%(v2)6.147.145.822%47%51%3.526.365.722%48%50%6.3.2. ResultsWe report the average results over 10 runs for each variation. To ease presentation, we discuss the results for each benchmark separately by concentrating on the different observations made throughout the experimental evaluation.Graph coloring. The evaluation results of the obtained abstractions are presented in Table 4. The first two rows show the average number of refinement steps and the average domain size (i.e., the number of clusters) of the resulting abstractions. The best abstraction (i.e., with smallest domain size) found for each instance in the runs is further checked for faithfulness, to observe whether the corresponding abstract program only contains concrete answer sets. The domain size of the faithful abstractions is shown in the third row. The frequencies of the abstractions that are trivial (thus faithful), non-trivial and faithful, and non-faithful are shown in the last three rows.The left column shows the results of full concreteness checking with different variations. We can observe that deciding on a refinement based on single abstract answer set (s) results in finer abstractions (i.e., with larger domain size) than on diverse set of abstract answer sets (div). The number of trivial abstractions obtained is also smaller for (div) (better decisions are made) and the chance of encountering a concrete abstract answer set is larger. The latter causes to obtain more non-faithful abstractions, as then no refinement to an abstraction with less spurious answer sets is made. As for using(v2), i.e., to decide on refinements, we can observe that this is not better for obtaining coarser abstractions than the minimal 42Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Table 5Experimental results for scheduling.timet = 10t = 20t = 30number of stepsabstract domain sizecalls abstract programcalls debugging programnumber of stepsabstract domain sizecalls abstract programcalls debugging programnumber of stepsabstract domain sizecalls abstract programcalls debugging program(v1)7.228.2241.3540.9014.7115.71168.48168.2822.8223.82391.88391.43(s)(v2)4.818.485.815.367.6514.168.658.459.5719.0210.5710.12(v2’)3.568.464.564.115.4714.126.476.277.7619.128.768.31(v1)6.047.0440.7256.3012.0013.00157.41244.4520.5721.57366.09580.23(div)(v2)4.818.385.816.877.5314.168.5312.089.5619.0710.5614.59(v2’)3.548.354.545.445.3313.816.338.747.6818.688.6812.24cost method (v1) in general; it also yields more trivial abstractions than (v1), as splitting the domain repeatedly to break up clusters of certain abstract elements quickly ends up with the original domain.The right column shows the results for a projected notion of concreteness that limits checking to a set of relevant atoms; for this, we picked the nodes 1,2,3 and their assigned colors. As expected, a concrete abstract answer set is encountered in much coarser abstractions, as the colors assigned to the other nodes do not matter. In case of projection, the trivial abstraction is reached much less often; moreover, more non-trivial faithful abstractions are reached. This is beneficial, as the computed abstractions can be used to obtain all (concrete) solutions over the nodes focused on.The main difference of the various encodings is the size of the achieved abstract domains. GCenc2 requires fewer refine-ment steps to achieve an abstraction with a concrete solution than GCenc1, as the need to preserve the node ordering leaves fewer refinement possibilities. On average, the resulting abstractions are coarser than by GCenc1 while the domain sizes of the faithful abstractions are larger. This may be due to the choice rule in GCenc2, causing spurious answer sets that must treated by further refinement steps.Disjunctive scheduling. We compared the effects of the variations for the resulting abstractions and the calls to the ASP solver to obtain an abstract answer set, respectively, to check concreteness with debugging; Table 5 shows the collected results. For the refinement search, we considered besides (v1) and (v2) the variant (v2’) of (v2) where each abstract element in the obtained debugging atom is mapped to a singleton cluster in the refinement.As expected, the minimal cost method (v1) causes much more calls to the ASP solver, as the cost for each possible refinement must be computed. While it achieves coarser abstractions in half of the cases, the large number of calls is a clear disadvantage. For example, for the case t = 20, (v1) achieves with (div) on average an abstract domain of 13.00 clusters with 400 calls to the ASP solver, while (v2’) achieves an average of 13.81 clusters with only around 15 calls.For the instances with t = 20, refinement through hints (v2) achieves coarser abstractions than (v1) when single abstract answer sets are picked. Here hints guide the refinement much better than the cost from a single abstract answer set. For the cost from a diverse set of abstract answer sets, significantly coarser abstractions are achieved. Looking at t = 30, we can ), which observe that the cost approach (v1) results in much finer abstractions than the hint based approaches (v2) and (v2provide better guidance. This shows that a local search over the 1-step refinements does not always yield the best outcome, and it is moreover also more expensive.(cid:3)We can also observe that (v2) mostly achieves coarser abstractions than (v2); immediately singling out the domain elements connected with the spuriousness helps. It also needs the smallest number of refinement steps compared to other approaches, as it reaches a concrete solution much faster with the refinement decisions.The results show that with larger domains, the effect of the abstraction can be seen much better; e.g., the best abstract domain size reached for t = 10 on average is 70.4% (= 7.04/10) of the original domain size, while for t = 30 it shrinks to 62% (= 18.68/30).Summary. The results show that with domain abstraction it is possible to achieve concrete solutions while abstracting over some of the details of the program. Reaching faithful abstractions is desired; however it does not occur often, unless a projected concreteness check is considered that only distinguishes the details relevant for a solution of the problem. Obtaining hints from a set of abstract spurious answer sets instead from a single such answer set results in better decisions and thus coarser abstractions.6.4. Evaluation: unsolvable problem instances in grid-cellsWe investigated obtaining explanations of unsatisfiable grid-cell problems by achieving an abstraction over the instance to focus on the troubling area. We considered the following benchmark problems:43(cid:3)Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563(a) cm = 4∗2+3∗164∗2+16∗1= 0.076(b) cm = 20∗2+3∗164∗2+16∗1= 0.299• Reachability (R): This problem needs the neighboring cell information and can be encoded without introducing guesses. Fig. 19. Measure for quality of a quad-tree abstraction.We check whether every cell is reachable; unsatisfiability is due to the layout of the obstacles.• Knight’s Tour (KT): This problem is on finding a tour on which a knight visits each square of a board once and returns to the starting point. It is commonly used in ASP Competitions, with possible addition of forbidden cells. Unsolvability is due to forbidden cells that prevent the knight from moving. In ASP competitions, this problem is encoded by guessing a set of move( X1, Y 1, X2, Y 2) atoms and ensuring that each cell has only one incoming and one outgoing movement.7There is no time sort (as in planning) which would describe an order.• Visitall: We extended the planning problem of visiting every cell (without revisiting a cell) with obstacles. This problem needs the neighboring cell information and can be encoded in two forms;(V) as a planning problem, in order to find a sequence of actions that visits every cell, or(VKT) as a combinatorial problem similar to the Knight’s Tour encoding.To allow for shorter plans, we encoded (V) using go( X, Y , T ) actions that can move horizontally/vertically to a cell X, Y(without passing through obstacles) and the passed cells become visited; we set a limit of 30 time steps.• Sudoku (S): This problem has also been used in ASP competitions.8 Its encoding consists of a guess of numbers in the cells combined with simple constraints such as one symbol per column, one symbol per subregion etc. The unsolvability occurs due to violation of these constraints.We generated 10 unsatisfiable instances complying to the following properties so that the unsolvability can be explained by focusing on a troubling area9:• In Reachability instances, a group of neighboring cells is unreachable due to the obstacles surrounding them.• For Knight’s Tour instances, one or two cells are picked to have only one valid movement to an obstacle-free cell. This way, these cells and the obstacles that do not allow the valid movements become a reason for unsolvability.• The Visitall instances consist of either two dead-end cells or areas with only one cell passage, so that one is forced to pass some cells more than once, which is not allowed.• For Sudoku, we generated a layout of numbers that force to violate the constraints when solving the problem.Measuring abstraction quality We consider a quality measure of the quad-tree abstraction by normalizing the number of abstract regions of certain size and their level in the quad-tree. The cost of a mapping m over an n × n grid isc(m) =(cid:8)(cid:16)i=0r2i (m)((cid:8) − i)(cid:17) (cid:8)(cid:16)i=0−i2n22((cid:8) − i),where (cid:8) = log2(n) − 1 is the level, r2i (m) is the number of abstract regions of size 2i × 2i in m, and n22is the number of abstract regions of size 2i × 2i in the n × n-sized cell. The factor (cid:8)−i is a weight that gives higher cost to abstractions with more low-level regions. An abstraction mapping with the smaller cost, i.e., intuitively smaller level of detail, is considered to be of better quality.−i2Fig. 19 shows measures of two abstraction mappings. The abstraction in Fig. 19a is coarser than the one in Fig. 19b, and this is reflected in the computed measures. Assigning more weight to having coarser regions would stress the importance of having a coarse abstraction even more. The computation of the measure is purely structural and domain-independent. Other measures can be defined that are dependent on the domain which considers further aspects, e.g., such that an abstraction that singles out the smallest number of cells with obstacles is preferred.7 www.mat .unical .it /aspcomp2013 /KnightTour.8 dtai .cs .kuleuven .be /events /ASP-competition /Benchmarks /Sudoku .shtml.9 All benchmark instances and encodings as well as user explanations for Visitall and Reachability are available at www.kr.tuwien .ac .at /research /systems /abstraction /mdaspar _material .zip.44Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Table 6Evaluation results of applying different debugging approaches.debuggingtypedefault2-phasedefault2-phase2-phasegrid-inc2-phaseatime-inc2-phasegrid-incaverageminimumsteps5.45.56.54.314.310.116.216.315.713.0cost0.2270.2330.6960.4760.6430.4420.7080.7120.6930.569steps5.45.35.13.410.46.313.913.513.010.3cost0.2270.2220.5500.3910.4600.2770.6080.5690.5720.449RSKTVVKTbeststepscost5.03.25.68.77.60.2080.3710.2450.3600.317a A total of 16 runs could not be completed due to memory errors. The results are computed among the runs that have been completed.•(a) inst. #10(b) V - spurious action transitions(c) VKT - separate action sequences that visit the cells reachable with single-cell passagesFig. 20. Spurious plans in abstractions that distinguish the single-cell passages.6.4.1. Effects of different debugging approachesWe compared different debugging approaches from Section 6.2.3 to observe their effects on the resulting abstractions and the taken refinement steps. Due to their encodings and constraints, the Knight’s Tour and Visitall problems are the challenging ones. To observe whether an incremental checking could help in deciding on a refinement and achieve better abstractions, we applied for KT and VKT partial concretization and for V incremental time checking. To evaluate how far a re-sulting abstraction is from the best possible abstraction showing unsolvability, we also checked whether a coarser abstraction with this property exists.Table 6 shows the main evaluation results. We compare different debugging approaches in terms of the average re-finement steps and average costs of the resulting abstractions over 10 runs, and also on the best outcome obtained (with minimum refinement steps and minimum mapping cost). The two right-most columns concern the existence of a coarser abstraction for best outcome obtained. The time to find an optimal solution in the debugging step was limited to 50 seconds. If exceeded, the refinement is decided on the basis of suboptimal analyses by considering the optimal debugging solution that could be computed within the time limit.For Reachability and Sudoku, we observe that abstractions close to the best possible ones can be obtained. Better ab-stractions were obtained with 2-phase debugging in these cases (the majority with a clear margin for S), as after the first step the focus was on the right part of the abstraction. For Knight’s Tour and Visitall, we observe that incremental checking can obtain better abstractions. This is because for 2-phase debugging, the programs mostly had due to timeouts to decide on suboptimal concreteness checking outputs. Moreover, for the V encoding 2-phase debugging caused memory outages (limit 500 MB) on some runs for some instances, thus not all 10 runs could be completed.We can also see a difference of the resulting abstractions for the two encodings of Visitall. The planning encoding achieves unsatisfiability with less coarse abstractions. Guesses of spurious sequences of actions in the abstraction cause the debugging to decide on refinements that avoid these sequences. The focus moves towards the unsolvability when the abstract action sequence is not executable due to an obstacle. In some instances where the reason for unsolvability is not easily caught by having two dead-ends, focusing on the existence of obstacles does not achieve unsatisfiability: the abstract encoding manages to find a plan passing through different sized regions by avoiding the constraints due to uncertainty. For these instances, the abstraction needs to be fine-grained enough to get rid of most of the uncertainty.Fig. 20a shows an example of such an instance. An abstraction that distinguishes the one-passage-entries and the obsta-cles that surround the cells cannot achieve unsatisfiability for encoding V. Fig. 20b shows some spurious action transitions 45Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Fig. 21. Explanatory abstractions for unsatisfiable Reachability instances.that are determined in a plan found with the V encoding among regions by avoiding the constraints due to uncertainty. Unsatisfiability cannot be achieved for VKT as well. This is due to guess of move atoms which achieve that every cell is visited, but lack a corresponding original order of movements. Fig. 20c shows the spurious order of movements that is split to visit each cell that is only reachable through a one-passage-entry. If the abstraction is refined to distinguish the cells in the respective corners, then unsatisfiability is realized.6.4.2. User study on unsatisfiability explanationsWe were interested in checking whether the obtained abstractions match the intuition behind a human explanation. For Reachability and Visitall, finding the reason for unsolvability of an instance is possible by looking at the obstacle layout. Thus, we conducted a user study for these problems in order to obtain the regions that humans focus on to realize the unsolvability of the problem instance.As participants, we had ten PhD students of Computer Science at TU Wien. We asked them to mark the area which shows the reason for having unreachable cells in the Reachability instances and the reason for not finding a solution that visits all the cells in the Visitall instances; multiple reasons are to mark with different colors. Explanations for 10 instances of each problem were collected.9 We discuss the results for both problems by showing two of the responses (expected and unexpected) and the best abstraction obtained from mDASPAR when starting with the initial mapping.Reachability. The expected explanations (e.g., Figs. 21a and 21d) focus on the obstacles that surround the unreachable cells, as they prevent them from being reachable. When their respective abstraction mappings are given to mDASPAR, the constructed abstract program is also unsatisfiable. The explanation in Fig. 21b puts the focus on the unreachable cells themselves, and Fig. 21e distinguishes a particular obstacle as a reason. The mark in Fig. 21e is actually a possible solution to the unreachability of the cells, since removing the marked obstacle makes all the cells reachable. When the respective abstraction mappings are given to mDASPAR, it needs to refine the abstraction further to distinguish more obstacles and to realize the unsatisfiability.In ASP, checking whether all cells are reachable is straightforward, without introducing guesses. This is also observed to be helpful for mDASPAR, as most of the resulting abstractions were similar to the gathered answers. Since in the initial abstraction, the abstract program only knows that the agent is located in the upper-left abstract region, in instance #10, mDASPAR follows a different path in refining the abstraction, and reaches the abstraction shown in Fig. 21f. Although different from the one by the users, it also shows a reason for having unreachable cells. Humans use the implicit knowledge that the agent is located in the upper-left corner in order to determine the reason for unreachability of the cells, and thus focus on a different area than mDASPAR. Such an abstraction can also be achieved with the method, by influencing the refinement decisions towards singling out the initial location of the agent.The abstractions achieved by mDASPAR are more general as the precise initial location of the agent is immaterial to distinguish the unreachable cells: it can be in any of the cells mapped to the respective abstract region. The precise obstacle layout in the abstracted regions also plays no role in determining the unreachability of the distinguished cells.46Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Fig. 22. Explanatory abstractions for unsatisfiable Visitall instances.Visitall. Most of the users picked two dead-end cells in the instances (if such occur) as an explanation for unsatisfiability, instead of the obstacles surrounding these cells (see Fig. 22a), which are the actual cause for them being dead-end cells. Even with abstraction mappings that also distinguish the surrounding obstacles of these dead-end cells, the corresponding abstract program still remains satisfiable. Then mDASPAR needs to further refine the abstraction to distinguish the neigh-boring cells (as in Fig. 22c) and to realize that it can only pass through one grid-cell when reaching the dead-end cells, and thus achieve unsatisfiability. Unexpectedly, some users marked only one of the dead-end cells as an explanation (Fig. 22b), which is actually focusing on a possible solution to the unsolvability, since if the marked area was not a dead-end, all cells could have been visited.Some instances do not contain two dead-end cells, but single-cell passages to some regions. Fig. 22d shows an entry that distinguishes these passages, while again focusing only on the cells themselves. For these instances, the results of mDASPAR are quite different. A discussion on why having an abstraction that distinguishes the one-passage-entries and the obstacles that surround the cells cannot achieve unsatisfiability was given for Fig. 20 in Section 6.4.1. Fig. 22f shows the best abstraction achieved for VKT. Instead of focusing on the passages, it distinguishes all cells in the one-passage-entry regions to realize that a desired action sequence that will manage to visit all cells without revisiting one cannot be found.The generality of the achieved abstractions is also here observable: the precise agent position and obstacle layout in the abstracted areas do not change the unsatisfiability result as not all cells in the distinguished parts can be visited.Observations The abstraction method can demonstrate the capability of human-like focus on certain parts of the grid to show the unsolvability reason. However, humans implicitly also use their background knowledge and do not need to explic-itly state the relations among the objects. Empowering machines with such capabilities remains a challenge. The study also showed a difference in understanding the meaning of “explanation”. For some study participants, showing how to get rid of unsolvability was also seen as an explanation. This discrepancy shows that one needs to clearly specify what is wanted (e.g., “mark only the obstacles that cause to have unreachable cells”), to achieve less variety of results.7. DiscussionIn this section, we first discuss a possible way to achieve abstraction over predicates using our method, and we then focus on the ASP planning use case in order to highlight the potential of domain abstraction in finding the essence of planning problems. After that, we discuss related work in the literature.7.1. Predicate abstractionPredicate abstraction in ASP would introduce literals involving new predicates that describe an abstraction of original literals, and rewriting the program to mention only the new literals. Naively replacing literals with the abstract ones would not always achieve an over-approximation.47Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Example 7.1 (Example 3.1 ctd). Consider a predicate abstraction that maps the atoms a( X) and d( X) to ad( X), i.e., if a(d) or d(d) holds true for some d ∈ D, then ad(d) holds true. When we replace the a- and d-atoms in Example 3.1, we obtain the following program:b(X, Y ) ← ad(X), ad(Y ).e(X) ← c(X), ad(Y ), X (cid:13)= Y .⊥ ← b(X, Y ), e(X).ad(1). ad(3). c(2). ad(5).However, the answer set of the program contains {b(1, 1), b(3, 1), . . . } and it does not match the original answer set.A simple way to achieve predicate abstraction is via domain abstraction after reification of predicates of the original program. For example, p( X, Y ) is written to x(p, X, Y ) and a sort of predicate names (viewed as constants) is introduced. By standardizing apart the variables, predicate names can be clustered via the built-in relations.Example 7.2 (ctd). Rewriting the atoms a( X) and d( X) to x(a, X) and x(d, X), respectively, yields the programb(X, Y ) ← x(P 1, X), x(P 2, Y ), P 1 = a, P 2 = d, pred(P 1), pred(P 2).e(X) ← c(X), x(P , Y ), P = a, pred(P ), X (cid:13)= Y .⊥ ← b(X, Y ), e(X).x(a, 1). x(a, 3). c(2). x(d, 5).pred(a). pred(d).Then an abstraction m over the sort pred such as {a, d}(cid:17)→ad can be applied.This approach works for predicate abstraction where the corresponding literals have arguments from the same sort in the same argument position. In case a literal has fewer arguments, dummy values can be used to fill in the remaining argument positions.Another way to achieve predicate abstraction is by following the motivation behind existential abstraction of the rela-tions. The idea is to introduce a new set of predicates along with their relation types according to the abstraction; then the abstract rules will be formed for all combinations of the abstraction types in the bodies, where choice is added to the head unless all are type I.Example 7.3 (ctd). Similar to Example 7.1, the abstract predicate name ad is introduced with the relation type τ adIII . Note that the arguments of the literal are not important, as the abstraction is over the predicate name and not over domain elements. The abstract program is then as follows:{b(X, Y )} ← ad(X), ad(Y ), τ adIII .{e(X)} ← c(X), ad(Y ), τ adIII , X (cid:13)= Y .⊥ ← b(X, Y ), e(X).ad(1). ad(3). c(2). ad(5).We remark that this approach is similar to using the rewriting of the original program with reification of predicates, and applying existential abstraction on the relations.7.2. Use case: abstraction in ASP planningDomain abstraction gives us the possibility to adjust the granularity of a problem towards the relevant details. By achiev-ing abstract answer sets that are concrete and thus catch all the relevant details, it also allows for problem solving over abstract notions, which can be useful in a wide range of applications. We discuss here the possible use of domain abstraction in ASP planning, in particular, in understanding planning problems expressed in ASP by abstracting over the unnecessary details. Another use case about policy refutation is described in Appendix C.Planning problems in ASP are represented by using a time sort to describe the sequence of states and the changes according to actions taken [77]. There are usually two types of objects, represented with different sort types:• objects on which the actions have a direct effect, e.g., the blocks in the blocksworld which can be moved, and48Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Fig. 23. Initial state of a blocksworld with multiple tables (concretem→ abstract).• other objects unaffected by the actions but involved in the decision making, e.g., the table in the blocksworld onto which blocks can be moved.We discuss how to use domain abstraction over these objects such that we can talk about abstract states and plans.Describing actions in ASP First, we emphasize on the blocksworld example the different ways of expressing planning prob-lems in ASP. The effects of moving a block on top of another block are expressible by the following rules:onB(B, B1, T + 1) ← moveToBlock(B, B1, T ).¬onB(B, B2, T ) ← onB(B, B1, T ), B1 (cid:13)= B2.where (89) models the direct and (90) the indirect effect. Alternatively, all effects are expressed as direct effects byonB(B, B1, T + 1) ← moveToBlock(B, B1, T ).¬onB(B, B2, T ) ← moveToBlock(B, B1, T ), B1 (cid:13)= B2.(89)(90)(91)(92)The preconditions of an action can either be described through constraints, or as a condition for an action to become applicable. For example, that a block cannot sit on a block with a smaller name can be expressed as a constraint⊥ ← onB(B, B1, T ), B1 ≤ B.Alternatively, the respective action can be forbidden if the condition is not satisfied using the following rules:⊥ ← moveToBlock(B, B1, T ), not precondmtb(B, B1, T ).precondmtb(B, B1, T ) ← B < B1, block(B), block(B1).Note that the alternative version is much closer to the PDDL-style encoding. The law of inertia is described by the ruleonB(B, B1, T +1) ← onB(B, B1, T ), not ¬onB(B, B1, T + 1).7.2.1. Abstracting over irrelevant detailsWe first show the possibility of abstraction over the details of the objects that are indirectly affected by the actions. For demonstration, we consider two extensions of well-known planning domains.• Multi-table blocksworld (MTB): here blocks can be moved onto one of multiple tables (where each table can hold multiple blocks); a plan is needed that piles the blocks up on a given specific table.• Package delivery with checkpoints (PDC): packages must be carried from an initial to a goal location, while passing through a checkpoint reachable from the initial location.Multi-table blocksworld. Fig. 23 illustrates an instance of MTB where the blocks must be piled up on table t1 such that b1is above b2 and b2 is above b3. Here reaching the goal state does not depend on the concrete tables to which blocks are moved before moving them to the goal table. However, when computing a plan based on the original program, the planner has to consider all possible movements.Fig. 24 shows a (natural) encoding of the problem with the actions moveToT(B, Ta, T ) and moveToB(B, B, T ) for moving (cid:3)block B onto table Ta and onto block B, resp., at time T . Consider the initial state shown in Fig. 23:(cid:3)onT(b1, t1), onB(b2, b3), onT(b3, t2), chosenTable(t1).After ensuring that all variables are guarded by domain predicates and those related with the table sort are standardized apart, we run DASPAR with the initial mapping {{t1, . . . , tn}(cid:17)→ˆt}. The abstraction obtained is shown in Fig. 23; it singles out the chosen table ˆt1 and clusters all others into ˆt2. We then can compute a concrete abstract answer set{moveToT(b2, ˆt2, 0), moveToT(b3, ˆt1, 1), moveToB(b2, b3, 2), moveToB(b1, b2, 3)}.49Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563% action choice{moveToB(B, B1, T ) : bl(B), bl(B1); moveToT(B, L, T ) : bl(B), tbl(L)} ≤ 1 ← T < tmax.% no gaps between movesdone(T ) ← moveToB(B, B1, T ).done(T ) ← moveToT(B, L, T ).⊥ ← done(T +1), not done(T ), T < tmax.% preconditions⊥ ← moveToB(B, B2, T ), onB(B1, B, T ).⊥ ← moveToB(B, B2, T ), onB(B1, B2, T ).⊥ ← moveToT(B, L, T ), onB(B1, B, T ).⊥ ← moveToT(B, L, T ), onT(B, L, T ).% effectsonB(B, B1, T +1) ← moveToB(B, B1, T ), T <tmax.onT(B, L, T +1) ← moveToT(B, L, T ), T <tmax.¬onB(B, B2, T ) ← onB(B, B1, T ), B1(cid:13)=B2.¬onT(B, L, T ) ← onB(B, B1, T ).¬onB(B, B1, T ) ← onT(B, L, T ).¬onT(B, L1, T ) ← onT(B, L2, T ), L1(cid:13)=L2.% inertiaonB(B, B1, T +1) ← onB(B, B1, T ),onT(B, L, T +1) ← onT(B, L, T ),not ¬onB(B, B1, T +1), T <tmax.not ¬onT(B, L, T +1), T <tmax.% state constraints⊥ ← onB(B1, B, T ), onB(B2, B, T ), B1(cid:13)=B2.⊥ ← onB(B, B1, T ), onB(B, B2, T ), B1(cid:13)=B2.⊥ ← onB(B, B1, T ), onT(B, L, T ).⊥ ← onB(B, B1, T ), B1 ≤ B.⊥ ← onT(B, L1, T ), onT(B, L2, T ), L1 (cid:13)= L2.% goal constraintsnotblockgoal(T ) ← onT(B, L, T ), onT(B1, L1, T ), B(cid:13)=B1.⊥ ← notblockgoal(T ), T = tmax.⊥ ← not notblockgoal(T ), onT(B, L, T ), not chosenT able(L).Fig. 24. Encoding for Multi-table Blocksworld.Fig. 25. Initial state of a package delivery with checkpoints (concretem→ abstract).that describes a plan without going into detail on which table the blocks are moved. The abstraction shows that for solving the problem, it is essential to distinguish the picked table from all others; the number of tables is irrelevant. Furthermore, this abstraction is faithful for projection to the actions moveToB, moveToT.Package delivery with checkpoints. Fig. 25 illustrates an instance of PDC where the packages in location l1 must be carried to location l10. As these locations are not directly connected, the truck has to pass through a middle point; through which point the truck passes is immaterial for reaching the goal state.For this problem, we used the Nomystery encoding from ASPCOMP2015 and altered it to have no fuel computation (shown in Fig. 26). Furthermore, for a dri ve(T , L1, L2, S) action to be possible we added an additional condition that the locations L1 and L2 should be connected by an edge, edge(L1, L2). Consider the initial state shown in Fig. 25: {at T (t, l1, 0), at P (p1, l1, 0), at P (p2, l1, 0), at P (p3, l1, 0), at P (p4, l1, 0), goal(p1, l10), goal(p2, l10), goal(p3, l10), goal(p4, l10)} with the de-picted edge facts. Running DASPAR with the mapping {{l1, . . . , l10}(cid:17)→ˆl} over the sort location results in the abstraction mapping {{l1}(cid:17)→ˆl1, {l2, . . . , l9}(cid:17)→ˆl2, l10(cid:17)→ ˆl3} (shown in Fig. 25). With this abstraction, the following concrete abstract answer set is computed:{load(p4, t,ˆl1, 1), load(p3, t,ˆl1, 2), load(p1, t,ˆl1, 3), load(p2, t,ˆl1, 4),dri ve(t,ˆl1,ˆl2, 5), dri ve(t,ˆl2,ˆl3, 6),unload(p3, t,ˆl3, 7), unload(p1, t,ˆl3, 8), unload(p4, t,ˆl3, 9), unload(p2, t,ˆl3, 10)}.It describes a plan that loads all the packages, moves to the middle cluster location, moves to the goal location, and unloads the packages; the resulting abstraction is faithful for the projection to the actions load, unload, dri ve.Domain abstraction simplified details that are unimportant for the essence of whether the plan is feasible. The faithful abstraction gives an understanding of the problem by realizing its neuralgic points. If however there are further constraints over details needed to construct a plan, then faithfulness might not be achievable in a non-trivial abstraction.7.2.2. Computing abstract plansAbstracting over the objects directly affected by the actions would empower us to talk about abstract plans. How-ever, in ASP-style encodings, abstracting over the object sort only causes the abstract program to compute plans with the original time sort. For example, say in the Package Delivery problem (with no checkpoints and two locations 50Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563% action choice{ unload(P , T , L, S) : package(P ), truck(T ), loc(L);load(P , T , L, S) : package(P ), truck(T ), loc(L);dri ve(T , L1, L2, S) : edge(L1, L2), loc(L1), loc(L2), truck(T ) } ≤ 1 ← step(S), S > 0.% no gaps between movesdone(S) ← unload(P , T , L, S).done(S) ← load(P , T , L, S).done(S) ← dri ve(T , L1, L2, S).⊥ ← done(S+1), not done(S).% effectsat P (P , L, S) ← unload(P , T , L, S).¬in(P , T , S) ← unload(P , T , L, S).¬at P (P , L, S) ← load(P , T , L, S).in(P , T , S) ← load(P , T , L, S).¬at T (T , L1, S) ← dri ve(T , L1, L2, S).at T (T , L2, S) ← dri ve(T , L1, L2, S).% precondition check⊥ ← unload(P , T , L, S), not precondu(P , T , L, S).precondu(P , T , L, S) ← at T (T , L, S−1),in(P , T , S−1).⊥ ← load(P , T , L, S), not precondl(P , T , L, S).precondl(P , T , L, S) ← at T (T , L, S−1),at P (P , L, S−1).⊥ ← dri ve(T , L1, L2, S), not precondd(T , L1, L2, S).precondd(T , L1, L2, S) ← at T (T , L1, S−1).% inertiaat T (T , L, S) ← at T (T , L, S−1), not ¬at T (T , L, S).at P (P , L, S) ← at P (P , L, S−1), not ¬at P (P , L, S).in(P , T , S) ← in(P , T , S−1), not ¬in(P , T , S).% goal check⊥ ← goal(P , L), not at P (P , L, S), maxstep(S).Fig. 26. Encoding for Package Delivery.l1, l2) we cluster the packages into one abstract package, ˆp0. Then, the abstract program will have the abstract actions load( ˆp0, t, l, s), unload( ˆp0, t, l, s) which then lead to a planload( ˆp0, t, l1, 1), dri ve(t, l1, l2, 2), unload( ˆp0, t, l2, 3).However, this plan is clearly spurious as no original action can match load( ˆp0, t, l1, 1), which loads all packages in one step; thus many spurious answer sets will result. In order to avoid this, also abstraction over the time sort is necessary. By doing this, we can talk about abstract instances of actions and abstract from the concrete order of their application. Given that the sorts (i.e., blocks and time, respectively, packages and time) are independent, multiple calls of DASPAR to abstract over each sort one-by-one achieves the desired abstract program.For the Package Delivery problem, consider two abstraction mappings mpackage = {{p1, p2, p3, p4}(cid:17)→ ˆp} and mtime ={{1, 2, 3, 4}(cid:17)→ˆt1, {5}(cid:17)→ˆt2, {6, 7, 8, 9}(cid:17)→ˆt3}. The constructed abstract program yields the abstract planload( ˆp, t, l0, ˆt1), dri ve(t, l1, l2, ˆt2), unload( ˆp, t, l2, ˆt3)which abstracts over the order of package (un)loading and includes abstract actions over time clusters.Unfortunately, finding a suitable abstraction over multiple sorts, especially if one is over the time domain, is non-trivial. The abstraction over time via time clusters steers the plan computation and the action ordering. For example, for the time mapping {{1}(cid:17)→ˆt1, {2, 3}(cid:17)→ˆt2, {4, 5, 6, 7, 8, 9}(cid:17)→ˆt3} the abstract plan from above is spurious.To summarize, while the use of abstraction in ASP planning appears to be attractive from a cognitive perspective, further research on several issues is needed in order to unleash the potential of this approach.7.3. Related workIn the context of logic programming, abstraction has been considered many years back in the classic work of Cousot and Cousot [29]. However, the focus of their studies was on the use of abstract interpretations and termination analysis of programs, and moreover stable semantics was not addressed.The work most related to our notion of abstraction in ASP are the simplification methods that strive for preserving the semantics. Such methods have been extensively studied over the years; we give here an overview of some notions. Notice that, different from these simplification methods, abstraction may lead to an over-approximation of the answer sets of a program, which changes the semantics, in a modified language.Over-approximation by abstraction reduces the vocabulary which makes it different from relaxation methods [58,81]. These methods translate a ground program into its completion [24] and search for an answer set over the relaxed model. As they focus only on ground programs, they can be compared with the abstraction that omits atoms from the program, which does not need to account for loop formulas when searching for a concrete abstract answer set. However, finding the reason for spuriousness of an abstract answer set is trickier than finding the reason why a model of the program completion is not an answer set of the original program, since the abstract answer set contains fewer atoms and a search over the original program is needed to detect the reason why no matching answer set can be found.7.3.1. Equivalence-based rewriting and program transformations in ASPEquivalence of logic programs is considered under answer set semantics as follows: a program (cid:2)1 is equivalent to a program (cid:2)2 if AS((cid:2)1) = AS((cid:2)2). Strong equivalence [80] is a much stricter condition: (cid:2)1 and (cid:2)2 are strongly equivalent 51Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563if, for any set R of rules, (cid:2)1 ∪ R and (cid:2)2 ∪ R are equivalent. This notion makes it possible to replace a part Q of a (cid:3)logic program by a strongly equivalent (simpler) program Q, without looking at the rest; [42,95,97,119] show ways of transforming programs by ensuring that the property holds. A more liberal notion is uniform equivalence [86,107] where R is are equivalent with respect to all factual inputs [40]. The notions of strong and restricted to a set of facts; that is Q and Quniform equivalence have been generalized to relativized equivalence [43], where the alphabet of R is restricted and further to a notion where in addition the occurrence of atoms in heads and bodies of the rules in R can be distinguished [122]; relativized strong equivalence with projections [56,104] allows to remove from answer sets auxiliary atoms. Relativized equivalence is related to our projected notion of concreteness, where certain (usually auxiliary) atoms are not considered for concreteness checking, see Section 3.3.4.(cid:3)In terms of abstraction, there is the abstraction mapping that needs to be taken into account, since the constructed program may contain a modified language and the mapping may relate it back to the original language. Thus, to define equivalence between the original program (cid:2) and its abstraction (cid:2)m according to a mapping m, we need to compare m(AS((cid:2))) with AS((cid:2)m). The equivalence of (cid:2) and (cid:2)m then becomes similar to the notion of faithfulness. However, as we have shown, even if the abstract program (cid:2)m is faithful, refining m may lead to an abstract program having spurious answer sets. Thus, simply lifting the current notions of equivalence to abstraction may not achieve useful results.Refinement-safe faithfulness, however, would allow one to use of (cid:2)m instead of (cid:2), as it preserves the answer sets. This property is achieved when the abstract program is unsatisfiable (which then implies that the original program was unsatisfiable). However, for original programs that are consistent, reaching an abstraction that is refinement-safe faithful is not easy; dividing the domain cluster may immediately cause a guess that introduces spurious solutions.The notions of equivalence from above have been complemented with further ones that allow for relating logic programs over different alphabets. Correspondence frameworks for ASP programs [46] are triples of the form F = (U , C, ρ), where U is a set of propositional atoms, C (the context) is a class of programs over U , and ρ is a binary relation over 2; two programs P and Q over U are then corresponding (with respect to F ) if for every R ∈ C the answer sets of P ∪ R and Q ∪ Rare in relation ρ. These very generic frameworks allow one to capture the notions of equivalence from above; furthermore, the notion of over-approximation can be simply expressed by setting C = { ∅ }, i.e., to consist of the empty program, and ρU (cid:3) to check for over-approximation of the answer sets of P ∪ R by the answer sets of Q ∪ R, relative to a set of atoms U (cid:3). However, while [46] discussed how to characterize equivalence for correspondence frameworks with ρU (cid:3) in semantic terms using non-classical here-and-there models [98] and presented some general complexity results, the issue of how to obtain programs Q that over-approximate the answer sets of Q was not addressed; furthermore, the setting was propositional.USynonymous theories [99,101] aimed to lift the notion of strong equivalence between programs to a setting where the programs have been formulated in different languages, but each language is bijectively interpretable in the other. To this end, the authors developed the notion of synonymous theories for quantified equilibrium logic, which is a well-known extension of the quantified logic of here-and-there that provides a logical reconstruction of answer set semantics [98,100]. In this notion, the equilibrium models of synonymous theories T 1 and T 2 (representing logic programs) are in a one-to-correspondence and remain so under addition of new formulas in a suitable sense. It builds on definability and interpretation as in classical logic, which are extended to the non-classical setting. For Herbrand models as in our setting, synonymous theories do not allow for domain shrinking, and the faithful and bijective interpretation property preserves in a sense equilibrium models and does not permit strict over-approximation; the same would apply to non-Herbrand models with static domains, where elements would be clustered while preserving equivalence. Exploring our notion of over-approximation in the framework of [98,100] and to consider its possible application is an interesting issue for future research.Other transformation methods, especially to help with grounding and solving of ASP programs, were investigated. A preprocessing technique was considered in [54] along with an assignment and a relation expressing equivalences among the parts of the program that could be assigned. Another form of preprocessing in [12,88] was applied to each rule of a program by computing a tree decomposition and then splitting the rule into multiple, smaller rules accordingly.7.3.2. Abstraction in planning and agent verificationStarting from the early years of AI planning, applications of abstraction to help with the search and planning for complex domains have received a lot of attention. One main research focus has been on hierarchical planning, which considers different abstraction levels over the problem space. A plan is searched at the abstract level and then the solution is refined successively to more detailed levels in the abstraction hierarchy, until a concrete plan is computed at the original level. Sacerdoti [106] showed an abstraction notion that keeps the “critical” preconditions of actions and ignores the rest. For example, Knoblock [70] proposed an ordered monotonicity property to ensure that solving the subproblems by refining certain parts of the plan does not change the remainder of the abstract plan. A similar property was considered by Bacchus and Yang [7], which states that if the original problem is solvable, then any abstract solution must have a refinement. Anderson and Farley [4] constructed operator hierarchies by having classes of operators that share common effects and forming new abstract operators with the shared preconditions.Another research focus has been on using abstractions to compute heuristics, which are estimates of the distances to the solution that guide the plan search. Pattern databases [31] are constructed from the results of projecting the state space to a set of variables of the planning task, called a pattern, which is to be solved optimally. The omission abstraction in [110] matches the intuition behind this projection notion. Edelkamp [38] was the first to apply this technique in planning. 52Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563He showed that a pre-compiled look-up table with the costs of abstract solutions can help the heuristic search in finding optimal solutions. The merge & shrink abstraction method of Helmert et al. [61] starts with a suite of single projections and then computes an abstraction by merging them and shrinking. A CEGAR-inspired method was proposed by Seipp and Helmert [116] based on cartesian abstractions, which form a general class of abstractions. The reason for the abstract plan being spurious is detected when trying to construct a concrete plan, and the abstraction is refined by splitting the states. Obtaining such a cartesian abstraction is also possible with domain abstraction introduced in Section 3; we further empower abstraction with a multi-dimensional handle in Section 5 that has the capability of representing a hierarchy of abstraction levels.Giunchiglia and Walsh [59] presented a theory of abstractions which provided a basis to understand different types of ab-stractions, while characterizing abstractions as syntactic mappings between programs. Later, Nayak and Levy [90] considered a semantic theory, where first the original domain is abstracted and then the domain model gets abstracted to capture the abstracted domain. Their notion of model increasing (MI) abstractions is similar to our abstraction by over-approximation notion in ASP.Although not investigated in detail, notions related to domain abstraction were also considered in heuristic-search plan-ning. Hernádvölgyi and Holte [62] presented a domain abstraction notion over the states which are represented as fixed length vectors of labels; they also noted the possibility of encountering spurious states with some abstractions. Hoffman et al. [63] considered variable domain abstraction by modifying the add and delete lists of the operators accordingly. They argued that obtaining efficient results from abstraction in planning mostly relies on the how much irrelevance is in the problem; this is an observation we similarly made in our experiments. To further investigate the structure of problems that can obtain good results, especially in the context of ASP, is an interesting research direction.The notion of irrelevant information and its effects were analyzed for planning by Nebel et al. [91], in which different heuristics were introduced to omit such information. Fox and Long [51] described a method for detecting symmetries in a problem which are then treated as indistinguishable to help the planner.Abstraction was studied for situation calculus action theories by Banihashemi et al. [9], who imposed a bisimulation restriction on the abstraction in order to ensure that reasoning about the actions of an agent at the abstract level can be mapped to concrete reasoning. They later showed how this restricted notion of abstraction can be used in reasoning about a strategy for an agent to achieve a goal at the high level and then mapping it back into a low-level strategy [10]. However, their focus was not on how such an abstraction can be found.For verifying the behavior of multi-agent systems, the use of abstraction has been investigated by Lomuscio et al. for ab-stracting over each agent to construct an abstract system while preserving the properties expressed in a temporal-epistemic logic [28] or alternating-time temporal logic [83]. In [28] the focus is not on how such an abstraction can be built. In [83], an abstraction over the states is made that have the same possible actions to execute and action abstraction keeps the ac-tions of certain agents while omitting the rest. They considered a three-valued logic and the abstraction also preserves the behavior of not satisfying a property. Spuriousness may occur for the case of achieving an “uncertain” result for checking a specification in the abstract level, which then forces one to refine the abstraction by splitting the states after investigating the subformulas of the specification. They later extended this work to infinite state models [84] and abstracted them to finite models using predicate abstraction, and they presented an interpolant-based refinement method [11].In the context of ASP and action languages, Dix et al. [35] proposed a way of formulating and solving hierarchical planning under the ASP semantics, with a focus on ordered task decomposition, which is planning each step in the order it will later be executed. For a particular application of mobile robot planning, Zhang et al. [123] performed hierarchical planning using the action language BC.7.3.3. Generalized planningFinding a plan that can achieve the goal for a class of problem instances can give an understanding of the details relevant for these problems. The plan can then be used for any particular problem instance without the need for further search. Note that, as discussed in Section 7.2, the plans that are computed with our domain abstraction method can also be seen as generalized plans as they work for any original problem instance that maps to the abstract instance.Srivastava et al. [118] proposed an abstraction method for constructing generalized plans with loops, by focusing on classical planning; however, selecting a good abstraction was beyond their scope. Bonet and Geffner [15] considered a setting where uncertainty is represented by a set of states, by clustering the states that provide the same observations. This view is similar to the indistinguishability notion we proposed in [109]. They studied the conditions for a policy (i.e., plan) to be general enough to work on other instances. Later they considered also trajectory constraints [14].Illanes and McIlraith [65] studied abstraction for numeric planning problems by compiling them into classical planning. Recently, they used abstraction for problems with quantifiable objects [66], e.g., a number of packages to deliver to points A and B, to find by abstracting from the quantification generalized plans that work for multiple instances. For this, they built a quantified planning problem by clustering indistinguishable objects using reformulation techniques [105] to reduce symmetry, and then compute a general policy. While the quantifiability conditions of [66] restrict applicability, our method has the potential drawback of spurious answers.53Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 1035638. ConclusionAbstraction is an important aspect of Artificial Intelligence aiming at the omission of detail and fine-grained structure in problem solving, to reduce the cognitive and/or the computational complexity in order to better understand respectively effectively find solutions. In this spirit, we have introduced the notion of domain abstraction to Answer Set Programming, where the size of the domain of an ASP program shrinks while the collection of its answer sets is over-approximated, i.e., every original answer set can be mapped to some abstract answer set. We have shown how this can be applied to single or multiple sorts of the domain, and how multi-dimensionality can be handled that enables a hierarchical view of abstraction, with quad-tree abstractions as a showcase for multi-granular abstraction over grids.More specifically, we have introduced two structure-preserving approaches that apply abstraction to the rules. The first approach keeps built-in relations in rules, which then must be lifted to the abstract domain, while the second approach, existential abstraction, loses their original format at the benefit of the ability to handle different levels of abstractions among the abstract elements, as needed in hierarchical abstraction.As over-approximation may result in spurious abstract answer sets that do not correspond to original answer sets, we have presented a method for refining abstractions which uses ASP-debugging techniques to obtain hints for refinements and a CEGAR-style methodology of iterated abstraction refinement [25]. The approach has been implemented in tools DASPAR and mDASPAR (for multi-dimensional domain mappings), which given an ASP program and an initial abstraction, auto-matically refine it until for the induced abstract program either a concrete answer set is encountered or unsatisfiability is detected (which proves that the original program is unsatisfiable).Our experiments showed the potential of the approach for understanding the core parts of an ASP program. In case of satisfiability, abstract answer sets focus on relevant details, as in case of planning problems such as Blocksworld and Package Delivery; a justification technique in ASP (cf. [20,103]) can be used to understand why a particular abstract answer set is computed, and moreover, if the abstraction is faithful, to identify details which are irrelevant for finding a solution. In case of unsatisfiability, the automatic abstraction refinement was able to catch the unsatisfiability without refining back to the original program. Furthermore, in grid-cell problems, a multi-dimensional view of abstraction enables zooming in to the area of the grid-cell which shows the reason for unsolvability; compared to the results of a small user study, explanations of decent quality were achieved, which suggests to continue this line of research.8.1. OutlookThis article has provided seminal concepts and notions for domain abstraction in ASP, an assessment of semantic and computational properties, and results for a prototypical evaluation. The work on domain abstraction can be continued and extended in several directions.One direction is to obtain more general notions of abstraction, and to apply abstraction to larger classes of ASP programs. As for the former, we remark that domain abstraction can be combined with omission abstraction [110] to obtain an abstraction that omits certain details and also abstracts over some part of the domain. This can be achieved with the current definitions, by first applying the desired domain abstraction to the program and then grounding the constructed non-ground abstract program to omit some of the atoms from it. The refinement decisions then need to take into account two causes for spuriousness; bad clustering of domain elements or bad omission of atoms. As regards larger classes of ASP programs, further language constructs like disjunction in rule heads, aggregates, or weak constraints as in the ASP Core-2 standard [21] are natural targets. Furthermore, extensions with nested rules, external atoms, or constraint solving are interesting other target languages.An important aspect of the abstraction&refinement method is the inital abstraction mapping. Starting with too coarse abstractions may mislead the method into refining irrelevant parts of the abstraction. To overcome this, an understanding of a good initial abstraction needs to be investigated. Employing symmetry breaking techniques [34,37] in order to get hints on a good initial abstraction is a promising subject of future research. Furthermore, as the use of abstraction depends on the problem structure at hand, characterizations of different problem types and a better understanding of the effects of abstraction are necessary.Another research direction concerns abstraction refinement. Different methods can be explored to help with the decision making in the refinement step. On the one hand, further heuristics for deciding about a refinement from a collection of abstract answer sets may be considered, where the range for local search may be increased and in addition domain-specific knowledge is exploited. On the other hand, by using justification methods such as [20,103] we can obtain an explanation of how an abstract answer set is built and check it on the original program. In case of failure, a reason for the spuriousness of the abstract justification may be distilled and exploited for abstraction refinement.Related to this is the issue of abstraction assessment, where the question of what is a “good” abstraction needs to be further studied. Different criteria can be relevant in this respect, from technical ones like the degree of spuriousness (measured e.g. by the number of spurious answer sets) or the level of abstraction (measured e.g. by the granularity of clustering), to the cognitive appeal from a human user perspective in terms of understandability of the abstraction and the abstract program. Addressing the latter appears to be challenging and harder than developing measures for technical criteria, given that humans have implicit background knowledge about the domain.54Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563A further research direction is advanced implementations beyond tuning the current prototypes. An apparent bottleneck is concreteness checking, which can be costly due to the need for grounding the original program in this process. Here one could explore the use of lazy-grounding, e.g. [22,72,96,121] and non-ground ASP solving, e.g. [6,87], or develop native techniques for concreteness checking. Further improvements may be using justification methods to explain abstract answer sets (as mentioned above), which as a further benefit mitigates the grounding issue and can yield substantial gains, or to embed the debugging program into the evaluation of the abstract program, such that hints can be obtained during the embedded checking; however, to achieve that this works efficiently is non-trivial.Last but not least, the use of domain abstraction remains to be explored for applications. Different possibilities can be envisaged, with ASP program development as an obvious candidate. Different from common debugging techniques, domain abstraction aims to not just show the rules themselves that effect a certain behavior, but can moreover be used to identify the gist of the domain that is responsible for the latter and thus aids in gaining more insight into a program at hand. Another possible use of domain abstraction is as a solving technique to address scalability. While the state-of-the-art ASP solvers are quite efficient in solving problems, they may struggle with problems that create huge search spaces or require optimization. For such problems, abstraction could be useful. However, achieving a good abstraction that could help with solving is non-trivial, and advances in performance and in particular of concreteness checking would be necessary for a fruitful deployment. Finally, we believe that domain abstraction has potential for building systems that explain matters to a human end user, and thus can be a useful tool for realizing explainable AI. Our experiments with grid cell puzzles have nurtured this view, since the reasons for unsolvability obtained in an automated way by our tools are a good match with human intuition. However, this is just an initial step, and significant research efforts will have to be invested to make this view become reality.Declaration of competing interestThe authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.AcknowledgementsWe are grateful to the reviewers for their helpful and constructive comments to improve this work and its presentation.Appendix A. ProofsProof of Theorem 3.1. Let ˆI and (cid:3)(cid:2) denote m(I) and (cid:2)m, respectively. Towards a contradiction, assume that there exists ˆI∪Tm or (ii) ˆI ∪ Tm is not a some I ∈ A S((cid:2)) s.t. ˆI ∪ Tm /∈ A S((cid:3)(cid:2)). This can occur either because (i) ˆI ∪ Tm is not a model of (cid:3)(cid:2)minimal model of (cid:3)(cid:2)ˆI∪Tm where ˆI ∪ Tm |= B(ˆr) and ˆI ∪ Tm (cid:3) H(ˆr). ˆI∪Tm . Then there exists some rule ˆr ∈ (cid:3)(cid:2)By construction of (cid:2), ˆr is only obtained by step (a), otherwise ˆr would be a choice rule with head H(ˆr) = {m(α)}, and ˆrwould be satisfied. Consequently ˆr is a rule from step (a) for r in (cid:2).ˆI∪Tm .(i) Suppose ˆI ∪ Tm is not a model of (cid:3)(cid:2)Since ˆI ∪ Tm |= m(Bstd(r)), ˆd1 ◦ ˆd2, τ ◦I (ˆd1, ˆd2), we have ˆI ∪ Tm |= m(Bstd(r)). If we have p(ˆe1, . . . , ˆen) ∈ m(Bstd,+(r)), some ei ∈ ˆei exists such that p(e1, . . . , en) ∈ I as all variables are standardized apart, I |= B std,+(r) for this choice. As for p(ˆe1, . . . , ˆen) ∈ m(Bstd,−(r)), then p(e1, . . . , en) /∈ I for all ei ∈ ˆei . So we can instantiate the abstract body m(B std(r)) to some I (ˆd1, ˆd2) means I |= d1 ◦ d2 for all di ∈ ˆdi , thus we have original body Bstd(r) where I |= Bstd(r). Also having ˆI |= ˆd1 ◦ ˆd2, τ ◦I |= Bstd(r), d1 ◦ d2. So r : α ← Bstd(r), d1 ◦ d2 is in (cid:2)I . As I is a model, it follows that I |= α, which then means ˆI |= m(α); this is a contradiction.(ii) Suppose there exists some (cid:3)J ⊂ ˆI such that (cid:3)J ∪ Tm is a model of (cid:3)(cid:2)−1((cid:3)J ) ∩ I is a model of (cid:2)I ; as J ⊂ I holds, this would contradict that I ∈ A S((cid:2)). Assume J (cid:3) (cid:2)I . Then J does not satisfy some rule r : α ←Bstd(r), d1 ◦ d2 in (cid:2)I , i.e., J |= Bstd(r), d1 ◦ d2 but J (cid:3) α. As J ⊂ I and I is a model of (cid:2)I , we have I |= α, thus, α ∈ I \ J .ˆI∪Tm . We claim that J = mNow, we look at the cases for applying the mapping m to r, by considering the abstractions m(B std(r)) and m(d1) ◦ m(d2), and show that a contradiction is always achieved.First, assume that ˆI |= m(Bstd(r)). There are the following cases for m( J ): (1-1) m( J ) |= m(B std(r)), or (1-2) m( J ) (cid:3)m(Bstd(r)).(1-1) As m( J ) |= m(Bstd(r)), we look at m(d1) ◦ m(d2). We know that J |= d1 ◦ d2.• If m(d1) ◦ m(d2) has the relation type τ ◦I (m(d1), m(d2)), this means that we have m( J ) |= m(d1) ◦ m(d2), and thus m( J ) ∪ Tm |= m(d1) ◦ m(d1), τ ◦I (m(d1),m(d2)), thus the non-ground rule created by step (a) has an instantiation m(α) ← m(B std(r)), m(d1) ◦ m(d2), ˆI∪Tm . As ˆJ and ˆI are models of (cid:3)(cid:2)−1( ˆJ ) and I (m(d1), m(d2)) in (cid:3)(cid:2)τ ◦α ∈ I ; by definition of J , we get α ∈ J thus J |= α, which is a contradiction.I (m(d1), m(d2)). As ˆJ = m( J ) and ˆJ ⊂ ˆI , we also get ˆI ∪ Tm |= m(d1) ◦ m(d2), τ ◦ˆI∪Tm , we have ˆJ |= m(α) and ˆI |= m(α). Thus, α ∈ m• If m(d1) ◦ m(d2) has the relation type τ ◦thus m( J ) ∪ Tm |= m(d1) ◦ m(d2), τ ◦III(m(d1), m(d2)), this again means that we have m( J ) |= m(d1) ◦ m(d2), and III(m(d1), m(d2)). Thus, as m(α) ∈ ˆIIII(m(d1), m(d2)) and ˆI ∪ Tm |= m(d1) ◦ m(d2), τ ◦55Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563the non-ground choice rule created by step (b) amounts to m(α) ← m(B std(r)), m(d1) ◦ m(d2), τ ◦(cid:3)(cid:2)ˆI∪Tm , which again achieves ˆJ |= m(α), thus J |= α, a contradiction.III(m(d1), m(d2)) in • If m(d1) ◦ m(d2) has the relation type τ ◦and thus m( J ) ∪ Tm |= m(d1) ◦ m(d2), τ ◦the non-ground rule created by step (c) and achieve J |= α, a contradiction.IV(m(d1), m(d2)), then we have m( J ) (cid:3) m(d1) ◦ m(d2), i.e., m( J ) |= m(d1) ◦ m(d2), IV(m(d1), m(d2)). With similar reasoning as above, we find an instantiation of (1-2) We show that there is no possibility to have ˆJ (cid:3) m(Bstd(r)), for ˆJ = m( J ), while ˆI |= m(Bstd(r)). In order to have ˆJ (cid:3) m(Bstd(r)), some positive literal ˆαi ∈ m(Bstd,+(r)) must occur in ˆI \ ˆJ so that ˆJ (cid:3) m(Bstd,+(r)). However, this contra-dicts with J |= Bstd,+(r).Now, assume that ˆI (cid:3) m(Bstd(r)). As I |= B(r), we know that ˆI |= m(Bstd,+(r)) holds. So we have the rule r in the form l ← Bstd,+(r), not αi, d1 ◦ d2 (according to restriction (R-1) on having at most one negative literal) where αi (cid:13)= α and ˆI (cid:3) m(Bstd(r)) means ˆI |= m(αi) for αi ∈ Bstd,−(r) while I (cid:3) αi , i.e., αi /∈ I . So we get ˆI |= m(Bsh(r)). Then there are the αifollowing cases for m( J ): (2-1) m( J ) |= m(B shαi(r)), or (2-2) m( J ) (cid:3) m(Bshαi(r)).(r)), we look at m(d1) ◦ m(d2). We know that J |= d1 ◦ d2.(2-1) As we have m( J ) |= m(BshαiI (m(d1), m(d2)) and τ ◦• For cases τ ◦III(m(d1), m(d2)), as we have J |= d1 ◦ d2, we get ˆJ |= m(d1) ◦ m(d2) and ˆI |=m(d1) ◦ m(d2). Notice that since m(αi) ∈ ˆI , there must be some αi(cid:3)), thus αi is mapped to a non-singleton cluster m(αi). So the atom not isSingleton(m( j)) holds true in ˆJ and ˆI for some j ∈ arg(αi) for which |m(r)), m(d1) ◦ m(d2), not isSingleton(m( j)) of the non-ground rule created by (step d-i), and again achieve J |= α, which is a contradiction.ˆI∪Tm we get an instantiation m(α) ← m(B shαi(cid:3) ∈ I such that m(αi) = m(αi−1(m( j))| > 1. Thus in (cid:3)(cid:2)• For the case τ ◦IV(m(d1), m(d2)), with similar reasoning as in (1-1), we find instantiations of the non-ground rules created by (step d-ii) and achieve J |= α, which is a contradiction.(r)), while ˆI |= m(Bshαi(cid:3) ∈ I (such that m(αi) = m(αi(2-2) We show that there is no possibility to have m( J ) (cid:3) m(B shαim( J ) |= m(Bstd,+(r)) holds. So m( J ) (cid:3) m(Bshαithere must be some αi(cid:2)I . We then take a look at the abstraction of r(cid:3)), i.e., m( J ) |= m(αi), which yields a contradiction. As for (2-2), this means the rule rm( J ) |= m(αi(cid:3)), not αi2 , d(cid:3) ← Bstd,+(rαi(cid:3)(cid:3) : α(cid:3)← Bstd(rof form ri2the atoms, this recursive process eventually ends, say, after n steps, at some rule rcase (2-2) is not applicable, and m( J ) |= m(α(cid:3)inThus m( J ) (cid:3) m(Bshαi(r)). As J |= B(r), we know that (r)) means m( J ) (cid:3) m(αi) while ˆI |= m(αi). Now, we take a look at (cid:2)I . As (cid:3)2 in . By doing the same case analysis of (1-1), (1-2) and (2-1), we achieve (cid:3) :in (cid:2)I) = m(αi2 ). By restriction (R-3) on no negative cyclic dependency among (cid:3) n2 where ) is achieved. Then by tracing the rules back to r we get m( J ) |= m(αi). (cid:3)2 where we want to claim m( J ) (cid:3) m(αi2 ). For this, we take a look at another rule r◦ d(cid:3))), this means that there is some rule r(r)) is not possible. (cid:2)is of form r(cid:3)(cid:3)2 with m(α(cid:3)(cid:3)◦ d1(cid:3)(cid:3)(cid:3)(cid:3)), d1(cid:3) ← Bstd(r(cid:3) n : α(cid:3)in← Bstd(r(cid:3) n), d(cid:3) : αi(cid:3)), d◦ d◦ d(cid:3) n1(cid:3)1i2(cid:3)(cid:3)(cid:3)(cid:3)(i) Let ˆI ∪ Tm be not a model of (cid:3)(cid:2)Proof of Theorem 3.2. Similar to proof of Theorem 3.1, we assume towards a contradiction that there exists some I ∈ A S((cid:2))ˆI∪Tm or (ii) ˆI ∪ Tm is not a minimal such that ˆI ∪ Tm /∈ A S((cid:3)(cid:2)). This can occur either because (i) ˆI ∪ Tm is not a model of (cid:3)(cid:2)model.ˆI∪Tm where ˆI ∪ Tm |= B(ˆr) and ˆI ∪ Tm (cid:3) H(ˆr). For cases (G-1) and (G-3), the contradiction is achieved similar to the proof of Theorem 3.1, since ˆr is a rule from step (a). As (ˆd), where ˆd is a shorthand for ˆd1,1, ˆd2,1, . . . , ˆd1,k, ˆd2,k; then by definition for case (G-2), we will have ˆI ∪ Tm |= rel(cid:3)this means I |= Bstd(r), d1,1 ◦1 d2,1, . . . , d1,k ◦k d2,k for some d1,1 ∈ ˆd1,1, d2,1 ∈ ˆd2,1, . . . , d1,k ∈ ˆd1,k, d2,k ∈ ˆd2,k and r in (cid:3)of rel(cid:2)I . This reaches a contradiction as I is a model and I |= α, which means ˆI |= m(α).ˆI∪Tm . Then there exists some rule ˆr ∈ (cid:3)(cid:2)(ii) Now let there be (cid:3)J ⊂ ˆI such that (cid:3)J ∪ Tm is a model of (cid:3)(cid:2)−1((cid:3)J ) ∩ I ⊂ I is a model of (cid:3)(cid:2)I ; which would contradict that I ∈ A S((cid:2)). Assume J (cid:3) (cid:2)I . J does not satisfy some rule r : α ← B std(r), rel(d) in (cid:2)I , i.e., J |= Bstd(r), d1,1 ◦1 d2,1, . . . , d1,k ◦k d2,k but J (cid:3) α, i.e., α /∈ J . As J ⊂ I and I is a model of (cid:2)I , we have I |= α, i.e., α ∈ I \ J . We consider the abstractions m(B std(r)) and m(d1,1) ◦1 m(d2,1), . . . , m(d1,k) ◦k m(d2,k).ˆI∪Tm . We claim that J = m(ˆd), τ relFirst, assume ˆI |= m(Bstd(r)). There are the following cases for m( J ): (1-1) m( J ) |= m(B std(r)), or m( J ) (cid:3) m(Bstd(r)).I(cid:3)(1-1) As m( J ) |= m(Bstd(r)), we look at m(d1,1) ◦1 m(d2,1), . . . , m(d1,k) ◦k m(d2,k). We know that J |=d1,1 ◦1 d2,1, . . . , d1,k ◦k◦iI (m(d1,i) ◦i m(d2,i)), this means that we have m( J ) |= m(d1,1) ◦1d2,k.(1-1-a) If all m(d1,i) ◦i m(d2,i) have the relation type τm(d2,1), . . . , m(d1,k) ◦k m(d2,k), and thusm( J ) ∪ Tm |= rel(cid:3)(ˆd), τ relI(cid:3)(ˆd).As ˆJ = m( J ) and ˆJ ⊂ ˆI , we also get ˆI ∪ Tm |= rel(cid:3)(cid:3)instantiation m(α) ← m(Bstd(r)), relˆI |= m(α). Thus, by definition of J , we get J |= α, which is a contradiction.(ˆd) in (cid:3)(cid:2)(ˆd), τ rel(ˆd), τ relI(cid:3)(cid:3)(93)(ˆd), thus the non-ground rule created by step (a) has an ˆI∪Tm , we have ˆJ |= m(α) and ˆI∪Tm . As ˆJ and ˆI are models of (cid:3)(cid:2)I56Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563(1-1-b) If at least one m(d1,i) ◦i m(d2,i) has the relation type τrelation type τ ◦IV(ˆd1, j, ˆd2, j), above (93) is achieved for τ relIII (ˆd) in place of τ relI(cid:3)(cid:3)(ˆd).◦iIII (m(d1,i), m(d2,i)), while no m(d1, j) ◦ j m(d2, j) has the (1-1-c) If at least one m(d1,i) ◦i m(d2,i) has the relation type τ(cid:3). . . , m(d1,i) ◦i m(d2,i), . . .. Thus, for rel(ˆd) we have m( J ) (cid:3) rel(cid:3)◦iIV (m(d1,i), m(d2,i)), this means that we have m( J ) |=(ˆd) but m( J ) |= rel(ˆd), and(cid:3)(cid:3)m( J ) ∪ Tm |= rel(cid:3)(ˆd), τ relIV (ˆd).(94)By the same reasoning in (1-1-a), we get that the non-ground choice rule created by step (c) amounts to ˆI∪Tm , and thus we reach a contradiction.(cid:3)m(α) ← m(Bstd(r)), rel(ˆd), τ rel(cid:3)IV (ˆd) in (cid:3)(cid:2)(1-2) This case is handled the same as in proof (1-2) of Theorem 3.1.Now, we focus on the case ˆI (cid:3) m(Bstd(r)). As I |= B(r), we know that ˆI |= m(Bstd,+(r)) should hold. Then ˆI (cid:3) m(Bstd(r))means that for a non-empty set L ⊆ B std,−(r) of atoms, we have ˆI |= αi for each αi ∈ L, 1 ≤ i ≤ n, while I (cid:3) αi , i.e., αi /∈ I . Assume we further have a set Lc j of atoms involved in a negative cycle with α. Since in B sh(r) the literals αi in L either get shifted or get omitted if {αi, α} ∈ Lc j (by (42)), we get ˆI |= m(Bsh(r)) and ˆI |= m(not Bstd,−(r) \ L).L,Lc jThen there are the following cases for m( J ): (2-1) m( J ) |= m(B sh(r)) and m( J ) |= m(not Bstd,−(r) \ L), or (2-2) L,Lc jL,Lc jm( J ) (cid:3) m(BshL,Lc j(r)) or m( J ) (cid:3) m(not Bstd,−(r) \ L).L,Lc jˆd2,1, . . ., ˆd1,k ◦k(2-1) As m( J ) |= m(Bshabstraction ˆd1,1 ◦1(2-1-a) By (1-1-a) and (1-1-b), we get the case (93) and same for τ rel(r)) and m( J ) |= m(not Bstd,−(r) \ L), similar to proof (1-1) above and (2-1) of Theorem 3.1, the ˆd2,k on relations is considered, and the contradiction J |= l is achieved.III (ˆd). We know that for each αi ∈ L, 1 ≤ i ≤ n as m( J ) |= m(αi) and as αi /∈ J (since J ⊆ I and αi /∈ I ), this means that not isSingleton(m( ji)) holds true in m( J ) and (ˆd), not isSingleton(m( j1)), . . ., not isSingleton(m( jn)), which ˆI for some ji ∈ arg(αi). Thus we have m( J ) ∪ Tm |= rel(cid:3)means that m(α) ∈ ˆI , thus α ∈ I and by definition of J , α ∈ J , which is a contradiction.(cid:3)(2-1-b) By (1-1-c), we get the case (94) and by a similar reasoning as in (2-1-a) we also have m( J ) |=isSingleton(ˆj1), . . . ,(cid:3)isSingleton(m( jn)), hence m( J ) ∪ Tm |= relisSingleton(m( j1)), . . . , not(ˆd), τ rel(cid:3)IV (ˆd), notnotnot isSingleton(ˆjn). Thus we similarly achieve a contradiction.(2-2) We first show that there is no possibility to have m( J ) (cid:3) m(B shthat m( J ) |= m(Bstd,+(r)) should hold. So m( J ) (cid:3) m(Bsh{αi, α} /∈ Lc j , while ˆI |= m(αi). Now, we take a look at (cid:2)I . As there must be some αi(cid:3) ← Bstd(rmeans that there is some rule rof ryields a contradiction. As for (2-2) (i.e., m( J ) (cid:3) m(B shL,Lcis of formthis means the rule r(cid:3)), d. By doing the same case analysis of (1-1), (1-2) and (2-1), we achieve m( J ) |= m(αi(r)). As J |= B(r), we know L,Lc j(r)) means m( J ) (cid:3) m(αi) for some αi ∈ L \ Lc j , showing that (cid:3))), this (cid:3)2,k in (cid:2)I . We then take a look at the abstraction (cid:3)), i.e., m( J ) |= m(αi), which (cid:3) ), (cid:3) with αi(cid:3))) for some L ⊆ Bstd,−(r) and for some Lc j(cid:3) ∈ I (such that m(αi) = m(αi(cid:3)2,1, . . . , d(cid:3) ∈ Lc j(cid:3) : αi(r)), while ˆI |= m(Bsh◦1 d◦k d(cid:3)1,1(cid:3)1,kL,Lc jL,Lc j(r(cid:3)(cid:3)(cid:3)j(cid:3)(cid:3)(cid:3)(cid:3)r(r(r), d(cid:3)1,k(cid:3)1,1◦k d◦1 d(cid:3) : αi), Bstd,−(cid:3) ← Bstd,+(cid:3)2,1, . . . , din (cid:2)I of form r∈ Bstd,−(r) exists s.t. li2(cid:3)2,k,(cid:3)} /∈ Lc j(cid:3) ) and we want to claim m( J ) (cid:3) m(li2 ). For this, we take where some li2(cid:3)(cid:3)), d) = m(αi2 ). Since this ◦1 da look at another rule rbackwards traverse is done over the negated literals not involved in negative cycles with the head of the respective rules, this recursive process eventually ends, say, after n steps, at some rule rwhere case (2-2) is not applicable, and m( J ) |= m(α(cid:3)inm( J ) |= m(αi) actually holds. Thus m( J ) (cid:3) m(Bsh(r)) is not possible.The case m( J ) (cid:3) m(not Bstd,−(r) \ L) also cannot hold, since that would mean that there exists some αi ∈ Bstd,−(r) \ Lsuch that m( J ) |= m(αi), while ˆI (cid:3) m(αi) (since ˆI |= m(not Bstd,−(r) \ L)), which is a contradiction to m( J ) ⊂ ˆI . (cid:2)(cid:3) n2,k) is achieved. Then by tracing the rules back to r we get that 2,k with m(α(cid:3)(cid:3) n(cid:3) n), d1,1(cid:3) (i.e., {li2 , αi← Bstd(r∈ L \ Lc j(cid:3)(cid:3) : α(cid:3)i2(cid:3) n2,1, . . . , d(cid:3)(cid:3)2,1, . . . , d(cid:3) n : α(cid:3)in← Bstd(r◦1 d◦k d◦k d(cid:3)(cid:3)1,1(cid:3) n1,k(cid:3)(cid:3)1,kL,Lc ji2(cid:3)(cid:3)Proof of Lemma 3.9. By definition, we need to check (1) that ˆI is a model of ((cid:2)m)model of ((cid:2)m)ˆI .ˆI and (2) that ˆI is minimal, no ˆJ ⊂ ˆI is a As for (1), we can refute the property by guessing a rule r ∈ (cid:2)m and a variable substitution θ and verifying that ˆI does ˆI , where rθ denotes the ground instance of r obtained by applying θ to its variables; note that in this case not satisfy (rθ)ˆI ∈ ((cid:2)m)(rθ)Each rule r ∈ (cid:2)m has polynomial size in the input. Checking whether r ∈ (cid:2)m holds is feasible in polynomial time, as computing the independent negative cycles Lc1 , . . . , Lcl of the program (cid:2) is feasible in polynomial time as well. Furthermore, ˆI holds.57Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563checking whether an instance rwith respect to ˆI is feasible in polynomial time. Overall, refuting (1) is consequently in NP.(cid:3) = rθ of r over the abstract domain is in the GL-reduct ((cid:2)m)As for (2), ˆI is minimal if each atom a ∈ I has a proof, given by a sequence r1, r2, . . . rk of applications of rules from ˆI where each positive body literal of ri occurs in some head of r j , j < i. Note that w.l.o.g. ˆI = {a1, . . . , ak} and ri ∈ ((cid:2)m)ai has as proof r1, . . . , ri , i = 1, . . . , k. As the proof can be guessed and nondeterministically verified in polynomial time, it follows that (2) is in NP. Hence it follows that the problem is in (cid:10)p2 (more precisely, in the class DP). (cid:2)ˆI of the abstract program (cid:2)mProof of Theorem 3.10. To show that ˆI is a concrete abstract answer set of (cid:2)m, we can guess an interpretation J of (cid:2) and check that (a) m( J ) = ˆI , (b) m( J ) ∈ AS((cid:2)m), and (c) J ∈ AS((cid:2)). Testing (a) is clearly polynomial in the size of J , and by 2 in the size of J and (cid:2) (and thus in exponential time in the size of ˆI and (cid:2)); Lemma 3.9, (b) and (c) are feasible in (cid:10)pconsequently, deciding whether ˆI is a concrete abstract answer set of (cid:2)m is in NEXP. For bounded predicate arities, the guess for J has polynomial size in the input, and we can check the conditions (b) and (c) by Lemma 3.9 with an NP oracle in polynomial time; this establishes (cid:11)pThe matching lower bounds are shown by a reduction from deciding whether a given non-ground program (cid:2) has some 2 membership.answer set, which is NEXP-complete in the general case and (cid:11)p2 -complete for bounded predicate arities [33,39].Without loss of generality, (cid:2) involves a single predicate p (which can be achieved by reification and padding arguments) and contains some fact p((cid:22)d). The mapping we define is m = {{d1, . . . , dn}(cid:17)→ˆd} where d1, . . . , dn form the Herbrand domain. Then ˆI = {p(ˆd, . . . , ˆd)} is a concrete abstract answer set of (cid:2)m iff (cid:2) has some answer set. Note that actually ˆI ∈ AS((cid:2)m)holds; thus the overall complexity does not change if this property is asserted. This proves the result. (cid:2)Proof of Theorem 3.12. For the membership, one can guess an interpretation ˆI of (cid:2)m such that ˆIis an answer set of (cid:2)m, and then check whether ˆI is spurious. By Theorem 3.10, the spuriousness check can be done with a coNEXP oracle in general and with a (cid:11)p2 oracle in the bounded predicate case. However, by applying standard padding techniques,10 it follows that a coNP oracle is sufficient in the general case. This proves membership of the problem in NEXPNP in the general case and in (cid:11)p3 in the bounded predicate case, respectively.The NEXPNP-hardness in the general case is shown by a reduction from evaluating second-order logic formulas of a suitable form over finite relational successor structures, i.e., relational structures S = (D, R S ) with a universe D and inter-for the relations R i in R = R1, . . . , Rk, which include the relations first(x), next(x, y) and last(x) associated pretations R Siwith a linear ordering ≤ of D.Lemma A.1. Given a second-order (SO) sentence of the form (cid:14) = ∃P ∀Q .ϕ where P = P 1, . . . , P m1 and Q = Q 1, . . . , Q m2 are predi-cate variables and ϕ =j ϕ j is FO such that each ϕ j is of the form ϕ j = ∃x1, . . . , xnl j,1 ∧ · · · ∧ l j,k where each li, j is a FO-literal, and a finite relational successor structure S, deciding whether S |= (cid:14) is NEXPNP-complete.(cid:18)This lemma can be obtained from the facts that (1) evaluating SO-sentences of the form (cid:16) = ∃P ∀Q .ϕ, where ϕ is a first-order formula, over finite relational successor structures is NEXPNP-complete, cf. [60], and (2) that (cid:16) can be transformed into some (cid:14) of the form described in polynomial time; the latter is possible using second-order skolemization and auxiliary predicates for quantifier elimination, cf. [44] and for denoting subformulas, such that ϕ((cid:22)x) ≡ P ϕ((cid:22)x) and ϕ((cid:22)x) = ϕ1((cid:22)x) ∧ ϕ2((cid:22)x)is expressed by P ϕ((cid:22)x) ≡ P ϕ1 ((cid:22)x) ∧ P ϕ2 ((cid:22)x) etc.We first describe how to encode evaluating the sentence (cid:14)(cid:3) = ∃P ∃Q ¬ϕ into an ordinary program (cid:2)0, and then extend the encoding to prove the result. We define the rules of (cid:2)0 as follows, where D serves as a domain predicate for constants C = {x1, . . . , xn}:P j,i(X1, . . . , Xn) ← not P j,i(X1, . . . , Xn), D(X1), . . . , D(Xn).P j,i(X1, . . . , Xn) ← not P j,i(X1, . . . , Xn), D(X1), . . . , D(Xn).Q j,i(Y 1, . . . , Yn) ← not Q j,i(Y 1, . . . , Yn), D(Y 1), . . . , D(Yn).Q j,i(Y 1, . . . , Yn)} ← not Q j,i(Y 1, . . . , Yn), D(Y 1), . . . , D(Yn).∧ · · · ∧ l.¬/notj,k¬/notj,1sat ← lok ← not ok.ok ← not sat.for each P j,i ∈ Pfor each P j,i ∈ Pfor each Q j,i ∈ Qfor each Q j,i ∈ Q(95)(96)(97)(98)(99)(100)(101)where l¬/not denotes the replacement of ¬ in l by not.1110 The input x to the oracle is changed to (x, y), where y is an (exponentially) long string y, and the oracle query considers x from the input only. This artificially lowers the time bound within the query (measured in the size of (x, y)) can be answered.11 To make the rules (99) safe, in their body atoms D( X) can be added for unsafe variables X .58Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Informally, the rules (95), (96) and (97), (98) guess extensions for the predicates in P and Q , respectively, while the rules (99) evaluate the formula ϕ. A guess for P and Q yields an answer set of (cid:2)0 augmented with S (provided as positive facts) iff ϕ evaluates over S to false; in this case, no rule (99) fires and thus sat cannot be derived, which means in turn that ok can be derived by (101) and thus the constraint (100) is satisfied. On the other hand, deriving ok is necessary to have an answer set, which means that sat must not be derived from the guess for P and Q .(cid:3) = { y1, . . . , yn} and link xi to yi via a predicate eq(x, y) that holds for x, y ∈ D ∪ DWe extend the program (cid:2)0 now for spuriousness checking. To this end, we introduce for the domain D = {x1, . . . , xn} at iff x = xi ∧ y = yi for hand a copy Dsome i = 1, . . . , n. The idea is to use D and Dinto a single element, such that for every guess χ for P , some abstract answer set ˆIχ of the abstract program (cid:2)m will exist; and that, moreover, ˆIχ will be concrete if for some guess for Q , we have an answer set of (cid:2), where the latter program is equivalent to (cid:2)0; thus ˆIχ will be spurious iff no guess for Q will yield an answer set of (cid:2)0, which means that the formula ∃P ∀Q .ϕevaluates to true.in the predicates from P and Q , respectively, and to abstract D(cid:3)(cid:3)(cid:3)We make the following adjustments.1. First, we replace in (97) and (98) the predicate D with D.2. Next, for each rule r from (99) we add for each term t that occurs in the rule body a “typing” atom D(t), we replace each term t that occurs in a Q -literal with a fresh variable Xt and add the atoms D(cid:3)( Xt) and eq(t, Xt ).3. To each rule r obtained from the previous step we add not succ( y1, y1) in the body; this literal evaluates to true with (cid:3)no abstraction, while under abstraction it will cause uncertainty and thus lead to a choice rule.(cid:3)( yi), for i = 1, . . . , n.4. We add facts eq(xi, yi) and D(xi), D5. We add facts Q j,i( y0, . . . , y0), Q j,i( y0, . . . , y0) for all Q j,i ∈ Q , where y0 is a fresh constant.It is not hard to establish that the answer sets I of the resulting program (cid:2) (over S) correspond to the answer sets I0 of (cid:2)0over S; each I is obtained from some I0 by replacing in the Q j,i - and Q j,i -atoms the constant xl with the corresponding yl, adding all facts Q j,i( y0, . . . , y0), Q j,i( y0, . . . , y0), and adding the eq(xi, yi), D(cid:3)( y j) facts, i = 1, . . . , n.The mapping that we construct is m = {{x1}(cid:17)→x1, . . . , {xn}(cid:17)→xn} ∪ {{ y0, y1, . . . , yn}(cid:17)→ ˆy}. In the abstract program (cid:2)m, the rules (95), (96) are carried over, while the modified rules (97), (98) are turned into rules to derive abstract atoms over Q j,iresp. Q j,i . However, since (cid:2)m contains the abstracted facts Q j,i( ˆy, . . . , ˆy), Q j,i( ˆy, . . . , ˆy), these rules are redundant.The modified rules (99) are turned into guessing rules for sat, while the other rules (100) and (101) remain unchanged. The abstract answer sets of (cid:2)m correspond to guesses χ for P to which ok and all Q j,i( ˆy, . . . , ˆy), Q j,i( ˆy, . . . , ˆy) are added (sat is guessed false); denote this answer set by Iχ .The answer set Iχ is concrete, if there is some guess μ for Q such that we obtain an answer set I of the program (cid:2)that is mapped to Iχ , i.e., m(I1) = Iχ ; this I1 corresponds to some answer set I0 as described above. Thus Iχ is spurious, if no such guess μ for Q exists.Putting it all together, it holds that (cid:2) has with respect to the mapping m = {{x1}(cid:17)→x1, . . . , {xn}(cid:17)→xn} ∪ {{ y0, y1, . . . , yn}(cid:17)→ ˆy} some spurious answer iff the formula (cid:14) in Lemma A.1 evaluates over S to true. Since (cid:2) and m are constructable in polynomial time from (cid:14) and S, this proves coNEXPNP hardness in the general case.For the bounded predicate arities case, the evaluation of a formula (cid:14) as in Lemma A.1 is (cid:11)psteps in producing the program (cid:2) preserves bounded arities. Thus with the same argument, we obtain (cid:11)pdeciding whether some spurious answer set exists for bounded predicate arities. This proves the result. (cid:2)3 -complete; furthermore, all 3 -hardness for Proof of Proposition 4.2. Let X be any interpretation over V such that m( X) = ˆI . We will show that with the help of the auxiliary rules/atoms, some interpretation Xcan be built starting from X . To this end, we first add all facts α from (cid:2) to X and all atoms konr , where H(r) = ⊥ or B(r) (cid:13)= ∅for a rule in r ∈ grd((cid:2)). The resulting Xdebug , that are facts from (cid:2) or have either not konr in the body or konr in the head. Furthermore, by construction X. We now satisfy the remaining rules (i) in Tmeta[(cid:2)] by adding apnr and blnr atoms, in this order and (ii) in Tdeact[(cid:2)] ∪ TdeactCons[(cid:2)] ∪ Tact [(cid:2), V]by auxiliary atoms p(c1, . . . , cn) for the choice-rules and ab_∗ atoms for the deactivation/activation rules.over Vdebug which is a minimal model of (cid:2)(cid:3) Xwill satisfy all rules in grd((cid:2)debug ), and thus in (cid:2) Xwhere (cid:2)(cid:3) = (cid:2)debug ∪ Q mˆIwill satisfy Q mˆI(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(i) For every instance rof a rule r ∈ (cid:2) such that X(cid:3) |= B(r(cid:3)), we add to X(cid:3){c1, . . . , cn}, if H(r) (cid:13)= ⊥ and n > 0, and (b) the atoms apnr , apnr (d1, . . . , dn(cid:3) ) where arg(B(ror B(r) = 0. After that, we add to Xapnr /∈ X, respectively.all ground atoms blnr (c1, . . . , cn) and blnr such that apnr (c1, . . . , cn) /∈ X(cid:3)(cid:3)(a) the atom apnr (c1, . . . , cn) where arg(H(r(cid:3))) =(cid:3))) = {d1, . . . , dn(cid:3) } if H(r) = ⊥and (cid:3)(ii) For every instance rof a rule r ∈ (cid:2) with B(r) (cid:13)= ∅ and H(r) (cid:13)= ⊥ where arg(H(r(cid:3)(cid:3)we add H(r(cid:3)) and ab_deactnr (c1, . . . , cn) to X(cid:3)(cid:3))) = {d1, . . . , dn(cid:3) }, if apnr (d1, . . . , dn(cid:3) ) ∈ X(cid:3)(cid:3)(cid:3)) /∈ Xand H(rH(r) = ⊥ where arg(B(revery atom p(c1, . . . , cn) ∈ A, if no instance r(that is, blnr (c1, . . . , cn) ∈ Xab_actp(c1, . . . , cn) to Xif p(c1, . . . , cn) ∈ X.(cid:3)(cid:3)(cid:3)(cid:3)for all rules r defining p), then we add (a) p(c1, . . . , cn) to Xof a rule r ∈ (cid:2) exists such that H(r; furthermore, for every instance rwe add ab_deactConsnr (d1, . . . , dn(cid:3) ) to X(cid:3)(cid:3)(cid:3))) = {c1, . . . , cn}, if apnr (c1, . . . , cn) ∈ Xof a rule r ∈ (cid:2) with . Finally, for (cid:3))(cid:3) |= B(r(cid:3)and (b) (cid:3)) = p(c1, . . . , cn) and Xif p(c1, . . . , cn) /∈ X(cid:3)(cid:3)59Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563As X(cid:3)(cid:3)and X coincide on V (i.e., X(cid:3) ∩ HB(cid:2) = X ∩ HB(cid:2) = X ) we have Xis a minimal model of (cid:2)(cid:3) XXi.e., no U ⊆ HB(cid:2)(cid:3) such that U, we can by [75] show that (cid:2)(cid:3)(cid:3) (cid:13)= ∅ and for each atom α ∈ HB(cid:2)(cid:3) and each r(cid:3)(cid:3)(cid:3) |= Q mˆIas claimed, and thus X(cid:3) |= (cid:2)(cid:3) X(cid:3)such that Uhas no unfounded set U w.r.t. X(cid:3)) or B(cid:3) (cid:13)|= B(r(cid:3) ∈ grd((cid:2)(cid:3)), either X. To show that (cid:3) := U ∩ X(cid:3) (cid:13)= ∅, +(r(cid:3)) ∩ U (cid:13)= ∅.(cid:3), it is easily checked that for every α ∈ X, every such rule r, must satisfy no blnr -atoms and no konr atoms can (cid:3)(cid:3)(cid:3)(cid:3)some r(cid:3)) ∩ U+(rBoccur in UTowards a contradiction, suppose such an U exists. By construction of X(cid:3) ∈ grd((cid:2)(cid:3)) exists such that H(r(cid:3)) = α and X(cid:3) |= B(r(cid:3)). Thus in particular for α ∈ U(cid:3) (cid:13)= ∅. Inspecting the rules in (cid:2)(cid:3)(cid:3), and α atoms and ab_∗-atoms only if U(cid:3), we can see that by construction of X(cid:3)(cid:3)+(r+(rfor rcontains some apnr -atoms resp. atom α from HB(cid:2).(cid:3)) in U(cid:3)(cid:3)) in U(cid:3)Now in the case apnr (c1, . . . , cn) ∈ U(cid:3)); similarly if apnr (d1, . . . , dn(cid:3) ) ∈ U(cid:3)(cid:3)). In turn, if α ∈ U(cid:3), we must have some atom α ∈ B, we must have some atom α ∈ B(cid:3), we must have some atom apnr (c1, . . . , cn) ∈ UB(rB(rα = p(c1, . . . , cn) (from the choice rule {H(r)} ← apnr (c1, . . . , cn)).Continuing this argument, we obtain that each atom α ∈ U(cid:3)dependency founded, every rule r ∈ (cid:2) that has an instance rDefine now the abstract interpretation ˆIonly the rules (a)-(c) from Definition 3.4, but no rules with body shifts or literal removals. Hence, each instance r(cid:3) ∩ HB(cid:2). Consequently, ˆI(cid:3)a rule to derive m(α) for α ∈ U((cid:2)m)U as supposed cannot exist. Consequently, Xresult. (cid:2)+(cid:2)(cid:3) . Since (cid:2) is positive-+(r) (cid:13)= ∅. −(r) = ∅ and B(cid:3) ∩ HB(cid:2)} and consider (cid:2)m. The abstraction of r introduces there of such satisfies ˆI , which contradicts ˆI ∈ AS((cid:2)m). Thus, an unfounded set , which proves the ˆI . However, this means that ˆI is not a minimal model of (cid:2)(cid:3) ∩ HB(cid:2) is on a positive cycle in G(cid:3)) = α must thus have Bwith H(r(cid:3)has the form apnr (c1, . . . , cn) ←has the form apnr (d1, . . . , dn(cid:3) ) ←of the form α ← apnr (c1, . . . , cn), not α where (cid:3) ∩ HB(cid:2) has some atom m(β) in Band thus an answer set of (cid:2)(cid:3)is a minimal model of (cid:2)(cid:3) X+(r) such that β ∈ U(cid:3) = ˆI \ {m(α) | α ∈ Uwhere r(cid:3)where r(cid:3)(cid:3)(cid:3)Proof of Proposition 4.3. If ˆI is spurious, by Proposition 4.1 the program (cid:2) ∪ Q mis unsatisfiable. We focus on debugging ˆIthe cause of inconsistency. Since (cid:2) is positive-dependency founded, this inconsistency can either be due to (i) an unsatisfied rule, (ii) an unsupported atom, or (iii) a supported atom that is on a positive cycle and has only positive atom dependencies. Indeed, if all rules are satisfied by (cid:2) and S is not an answer set of (cid:2), then some unfounded set U of (cid:2) w.r.t. S exists such +that U ∩ S (cid:13)= ∅, cf. [75]; if all atoms in S are supported, then every atom α ∈ U ∩ S is on a positive cycle in G(cid:2) with nodes in U ∩ S and α has only positive atom dependencies as (cid:2) is positive-dependency founded. Consider now the three cases:(i) Let r ∈ (cid:2) be an unsatisfied rule w.r.t. S. This means that the constraints in Q mˆIis causing H(r) to be false while B(r)is satisfied. By the program Tmeta[(cid:2)], depending on r, either apnr (c1, . . . , cn) or apnr (d1, . . . , dn(cid:3) ) is true. By Tdeact[(cid:2)], ∈ S (else ⊥ ∈ S by Tmeta[(cid:2)]), and we get ab_deactnr (c1, . . . , cn) ∈ S. If H(r) = ⊥, then by TdeactCons[(cid:2)], we have konrwe get ab_deactConsnr (d1, . . . , dn(cid:3) ) ∈ S.(ii) Let α = p(c1, . . . , cn) ∈ S be an unsupported atom in (cid:2) w.r.t. S for the domain elements c1, . . . , cn. Then, for each rule instance r deriving α, we have blnr (c1, . . . , cn) ∈ S and by Tact [(cid:2), V], we have ab_act p(c1, . . . , cn) ∈ S.(iii) Assuming all rules in (cid:2) are satisfied and all atoms in S are supported, we show that this case is not possible by of a rule r : α ← B(r) in (cid:2) such that α ∈ U ∩ Sderiving a contradiction. For some U as described, every instance r−(r) = ∅. Thus, the abstract program (cid:2)m includes for r only and S satisfies B(rrules without body-shifts, i.e., rules (a)–(c) in Definition 3.4. By positive-dependency foundedness, the interpretation S \ (U ∩ S) satisfies all rules in (cid:2). Consequently, the abstract interpretation ˆI \ m(U ∩ S) satisfies the rules (a)–(c) constructed for r and is a model of (cid:2)m; this means that ˆI is not a minimal model of the GL-reduct of (cid:2)m w.r.t. ˆI , which contradicts ˆI ∈ AS((cid:2)m). (cid:2)(cid:3)) = ∅, which means B(cid:3)) has B−(r(cid:3)Proof of Theorem 5.1. For an assignment I , we need to show that I ∪ Tm∃ is a minimal model of ((cid:2)mis a minimal model of ((cid:2)m)I .∃ )I if and only if I ∪ Tm(⇒) Towards a contradiction, assume I ∪ Tm∃ is a minimal model of ((cid:2)m∃ )I but I ∪ Tm is not a minimal model of ((cid:2)m)I . Then either (i) I ∪ Tm is not a model of ((cid:2)m)I , or (ii) I ∪ Tm is not a minimal model of ((cid:2)m)I .(i) There is a rule ˆr ∈ ((cid:2)m)I such that I ∪ Tm |= B(ˆr) but I (cid:3) H(ˆr). By construction of (cid:2)m, ˆr is only obtained by step (a) of Definition 3.4, otherwise ˆr would be a choice rule with head H(ˆr) = {m(l)}, and ˆr would be satisfied. Consequently I (ˆd1, ˆd2). Since the definitions of ˆr is a rule from step (a) for r in (cid:2). Thus, we have I ∪ Tm |= m(Bstd(r)), ˆd1 ◦ ˆd2, τ ◦I (ˆd1, ˆd2) ⇐⇒relation type I for lifted relations and abstract relations correspond to each other, we have Tm |= τ ◦(cid:3)rel(ˆd1, ˆd2) which is the abstract rule of r constructed by Tm∃ |= τI∃ )I , I |= H(ˆr). Hence, we reach a contradiction.step (a) of Definition 5.1. Since I ∪ Tm∃ is a minimal model of ((cid:2)m(ˆd1, ˆd2). This means we get I ∪ Tm∃ |= m(Bstd(r)), τ(cid:15)relI(ii) Let there be J ⊂ I such that J ∪ Tm is a model of ((cid:2)m)I . We claim that J ∪ Tm∃ is a model of ((cid:2)m∃ )I , which would ∃ )I such that J ∪ Tm∃ |= B(ˆr) but contradict I ∪ Tm∃ ∈ AS((cid:2)mJ (cid:3) H(ˆr), while I |= H(ˆr). We need to show that there is a corresponding rule in ((cid:2)m)Ifor ˆr, which would then achieve the contradiction that is J |= H(ˆr). Below, we denote by B(ˆr) \ ˆ(cid:6)r , the abstract body excluding the abstracted relation (and its relation type atom).∃ )I . Then there is a rule ˆr ∈ ((cid:2)m∃ ). Assume J ∪ Tm∃ (cid:3) ((cid:2)m60Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563• If ˆr contains τ(ˆd1, ˆd2) (step (a) or (c) of Definition 5.1), then since we know Tm |= τ ◦(cid:3)relI(ˆt1, ˆt2), we achieve J ∪ Tm |= ˆd1 ◦ ˆd2, τ ◦(cid:3)relτIand also I |= B(ˆr) \ ˆ(cid:6)r . Thus we get H(ˆr) ← B(ˆr) \ ˆ(cid:6)r, ˆd1 ◦ ˆd2, τ ◦J ∪ Tm is a model of ((cid:2)m)I , we get J |= H(ˆr), which is a contradiction.I (ˆd1, ˆd2) (also J ∪ Tm |= ˆd1 ◦ ˆd2). Since ˆr ∈ ((cid:2)mI (ˆd1, ˆd2) ⇐⇒ Tm∃ |=∃ )I , we know that I |= B(ˆr)I (ˆd1, ˆd2) (also H(ˆr) ← B(ˆr) \ ˆ(cid:6)r, ˆd1 ◦ ˆd2) in ((cid:2)m)I . Since (cid:3)relIII (ˆd1, ˆd2) (step (b) or (c) of Definition 5.1), then J ∪ Tm∃ |= τ• If ˆr contains τd11, d12 ∈ mthe following cases for ˆd1 ◦ ˆd2: (1) J |= ˆd1 ◦ ˆd2, or (2) J (cid:3) ˆd1 ◦ ˆd2.−1(ˆd1), d21, d22 ∈ m−1(ˆd2) and some J−1( J ) such that J(cid:3) ∈ m(cid:3)relIII (ˆd1, ˆd2) means that there exist some (cid:3) (cid:3) d12 ◦ d22. There are (cid:3) |= d11 ◦ d21 and J(1) Since we know J(cid:3) (cid:3) d12 ◦ d22, this case obtains τ ◦soning as above on obtaining H(ˆr) ← B(ˆr) \ ˆ(cid:6)r, ˆd1 ◦ ˆd2, τ ◦((cid:2)m)I ), we achieve J |= H(ˆr), a contradiction.(2) Since we know J(cid:3) |= d11 ◦ d21, this case obtains τ ◦reasoning as above we reach a contradiction.III(ˆd1, ˆd2), thus J ∪ Tm |= ˆd1 ◦ ˆd2, τ ◦III(ˆd1, ˆd2). With similar rea-III(ˆd1, ˆd2) in ((cid:2)m)I (also H(ˆr) ← B(ˆr) \ ˆ(cid:6)r, ˆd1 ◦ ˆd2 in IV(ˆd1, ˆd2), thus J ∪ Tm |= ˆd1 ◦ ˆd2, τ ◦IV(ˆd1, ˆd2). With similar (⇐) Towards a contradiction, assume I ∪ Tm is a minimal model of ((cid:2)m)I but I ∪ Tm∃ is not a minimal model of ((cid:2)mThen either (i) I ∪ Tm∃ is not a model of ((cid:2)m∃ )I , or (ii) I ∪ Tm∃ is not a minimal model of ((cid:2)m∃ )I .∃ )I . (i) There is a rule ˆr ∈ ((cid:2)m∃ )I such that I ∪ Tm∃ |= B(ˆr) but I (cid:3) H(ˆr). By construction of (cid:2)m∃ , ˆr is only obtained by step (a) of Definition 5.1. With an analogous reasoning as above item (i), we achieve a contradiction.(ii) Let there be J ⊂ I such that J ∪ Tm∃ is a model of ((cid:2)m(cid:3)relI∃ )I which achieves J |= H(ˆr) a contradiction.∃ )I . We claim that J ∪ Tm is a model of ((cid:2)m)I , which would contradict I ∪ Tm ∈ AS((cid:2)m). Assume J ∪ Tm (cid:3) ((cid:2)m)I . Then there is a rule ˆr ∈ ((cid:2)m)I such that J ∪ Tm |= B(ˆr) but J (cid:3) H(ˆr), while I |= H(ˆr). We need to show that there is a corresponding rule in ((cid:2)m∃ )I for ˆr, which would then achieve the contradiction that J |= H(ˆr).• If ˆr contains ˆd1 ◦ ˆd2, τ ◦H(ˆr) ← B(ˆr) \ ˆ(cid:6)r, τ• If ˆr contains ˆd1 ◦ ˆd2, τ ◦I (ˆd1, ˆd2) (step (a) of Definition 3.4), an analogous reasoning as above item (ii) obtains and there exist some d1 ∈ mrelation type τ{1, 2}. With similar reasoning as above on obtaining H(ˆr) ← B(ˆr) \ ˆ(cid:6)r, τcontradiction.(ˆd1, ˆd2) in ((cid:2)mIII(ˆd1, ˆd2) means that J |= ˆd1 ◦ ˆd2III(ˆd1, ˆd2) (step (b) of Definition 3.4), then J ∪ Tm |= ˆd1 ◦ ˆd2, τ ◦−1(ˆd2) and some J(cid:3) (cid:3) d1 ◦ d2. This obtains abstract −1( J ) such that J(cid:3)relIII (ˆd1, ˆd2). Notice that also J |= not isSingleton(ˆdi) holds for some i ∈(cid:3)relIII (ˆd1, ˆd2) in ((cid:2)m∃ )I , we achieve J |= H(ˆr), a IV(ˆd1, ˆd2) means that (cid:3) |= d1 ◦ d2. This again IV(ˆd1, ˆd2) (step (c) or (d.ii) of Definition 3.4), then J ∪ Tm0−1(ˆd1), d2 ∈ m(cid:3)relIII (ˆd1, ˆd2), thus J ∪ Tm∃ |= τJ (cid:3) ˆd1 ◦ ˆd2 and there exist some d1 ∈ mobtains abstract relation type τ−1(ˆd1), d2 ∈ m(cid:3)relIII (ˆd1, ˆd2), i.e., J ∪ Tm∃ |= τ• If ˆr contains only ˆd1 ◦ ˆd2 (step (d.i) of Definition 3.4), then this means either J ∪ Tm∃ |= τ ◦I (ˆd1, ˆd2) or J ∪ Tm∃ |=III(ˆd1, ˆd2) holds. Also we know that J |= not isSingleton(ˆdi) holds for some i ∈ {1, 2}. So similar as above, we achieve τ ◦a contradiction. (cid:2)(cid:3)relIII (ˆd1, ˆd2), thus reaches a contradiction as above.|= ˆd1 ◦ ˆd2, τ ◦−1( J ) such that J• If ˆr contains ˆd1 ◦ ˆd2, τ ◦−1(ˆd2) and some J(cid:3) ∈ m(cid:3) ∈ mA.1. Merged vs. individual independent cyclesLet (cid:2)Lc1 ,...,Lcldenote the program constructed in Definition 3.8 for Lc1 , . . . , Lcl , and let (cid:2)S denote the program con-∪ . . . ∪ Lcl (i.e., using S in instead of Lc j for defining BshL,S (r)). Then we obtain the structed by considering a big cycle S = Lc1following result.Proposition A.2. For every program (cid:2), it holds that AS((cid:2)Lc1 ,...,Lcl) = AS((cid:2)S ).Proof. Let L = Lc1 , . . . , Lcl . We first observe that the rules in (cid:2)L and (cid:2)S are related in the following way. We say that a +(rrule r is a tightening of a rule r, if H(r) = H(r−(r) ⊆ B+(r) ⊆ B(cid:3)) and B(cid:3)), B−(r(cid:3)).(cid:3)Lemma A.3. For each rule r ∈ (cid:2)L according to (d), there exists a tightening rthere exists a tightening rof r in (cid:2)L.(cid:3)(cid:3)of r in (cid:2)S , and for each rule r ∈ (cid:2)S according to (d), with BshTo see the first part, if α ∈ Lc j then α ∈ S, and if α ∈ L ∩ Lc j then α ∈ L ∩ S. Suppose a rule r in (d) is included in (cid:2)Lof r will be ∩ L = ∅ applies, then (r0) for some rule r0 ∈ (cid:2). If in (42) the condition α ∈ Lc j and Lc j∩ L (cid:13)= ∅; if in (42) the condition α /∈ Lc j or Lc j∩ L (cid:13)= ∅ applies, then a tightening rL,S (r0) by condition α ∈ Lc j and Lc jincluded in (cid:2)S for BshL,Lc j(cid:3)61Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563likewise a tightening ror by the condition α ∈ Lc j and Lc j(cid:3)∩ L (cid:13)= ∅.of r will be included in (cid:2)S for BshL,S (r0) by either the condition α /∈ Lc j or Lc j∩ L = ∅ (then (r = r(cid:3)) For the second part, r stems from a rule r0 ∈ (cid:2) for S and some L. For each Lc j , from r0 some rule rfor L and Lc j is (cid:3)added to (cid:2)L; If r = r(cid:3)Consider now the set L(cid:2), we are done. Otherwise, it follows that α ∈ Lc j and L ∩ Lc j(cid:3) . As each cycle Lc j(cid:3)(cid:3)(cid:13)= ∅ must hold.(cid:3) (cid:13)= j, is disjoint from Lc j , we have α ∈ Lc j and Land Lc j by the condition α ∈ Lc j and Lc j(cid:3) , jis put in (cid:2)L for L(cid:3) = L \j(cid:3)(cid:13)= j Lc j(cid:3)(cid:3) ∩ Lc j(cid:13)= ∅. ∩ L (cid:13)= ∅ in Consequently, in (d) stemming from r0 some rule r= L \ S and L(42). Since L(cid:3) ⊆ L, the rule r(cid:3)(cid:3)(cid:3) \ LciThe result follows now from this and the following lemma.is a tightening of r. This proves the lemma.Lemma A.4. Let (cid:2)1 and (cid:2)2 be programs that differ only on choice rules and such that, for each choice rule r in (cid:2)1, some tightening (cid:3)rof r in (cid:2)2 exists. Then AS((cid:2)1) ⊆ AS((cid:2)2).Indeed, consider I ∈ AS((cid:2)1) and any choice rule r(cid:3) ∈ (cid:2)2. If r(cid:3)I |= H(r), then we keep r for building an nswer set; otherwise, if I |= B(rsince for each rule r in (cid:2)Iwould not be the least model of (cid:2)I1 such that I |= B(r) a tightening in (cid:2)Iis the tigthening of some rule r ∈ (cid:2)1 such that I |= B(r) and 2, and 2 is possible (otherwise I(cid:3)) we discard r2 exists, no smaller model J of (cid:2)I. Then by construction I |= (cid:2)I(cid:3)1). Thus, I is answer set of (cid:2)2, which proves the lemma.Putting things together, the programs (cid:2)L and (cid:2)S differ only on choice rules according to (d), and by Lemma A.3 the condition of Lemma A.4 is verified to conclude AS((cid:2)L) ⊆ AS((cid:2)S ) and AS((cid:2)S ) ⊆ AS((cid:2)L), respectively, which completes the proof. (cid:2)Appendix B. Further detailsB.1. Correctness checking failure for non-positive-dependency founded programsThe following example shows that the procedure for correctness checking does not work for programs that are not positive-dependency founded in general.Example B.1. Consider the program below which is unsatisfiable and also contains a positive loop.r1 : a(X) ← not a(X), dom(X).r2 : a(X) ← a(X).dom(1). dom(2). dom(3).For the mapping m = {{1, 2, 3}(cid:17)→k}, the constructed abstract program (cid:2)m isa(X) ← not a(X), dom(X).{a(X)} ← not isSingleton(X), dom(X).a(X) ← a(X).dom(k).which has the abstract answer set ˆI = {a(k)}. Checking the correctness using (cid:2)debug ∪ Q mˆIit requires to have some a(c) for c ∈ mMore in detail, the program (cid:2)debug contains among others the following rules:results in unsatisfiability, because −1(k) to hold true through a loop, which is not covered in the definition of (cid:2)debug . {a(X)} ← apr1 (X).apr1 (X) ← not a(X), dom(X).blr1 (X) ← not apr1 (X), dom(X).{a(X)} ← apr2 (X).apr2 (X) ← a(X).blr2 (X) ← not apr2 (X), dom(X).{a(X)} ← blr1 (X), blr2 (X).as in the proof of Proposition 4.2. Following the steps, we obtain Xof (cid:2)(cid:3) = (cid:2)debug ∪Then we may pick X = {a(1)} (omitting the domain facts) as starting set for building an answer set X(cid:3) = {a(1), apr2 (1), blr1 (1), apr1 (2), blr2 (2), a(2), Q mˆI+apr1 (3), blr2 (3), a(3), . . .}. This is not an answer set of (cid:2)(cid:3)(cid:2)(cid:3) that is an unfounded set of (cid:2)(cid:3). Notice that m(a(1)) = a(k) has in (cid:2)m founded support from the choice rule, which allows for having ˆI as answer set of (cid:2)m. We would obtain a similar picture if we would choose any other X ⊆ A such that m( X) = ˆI as a starting set, viz. that for each c ∈ {1, 2, 3} such that a(c) ∈ X , we have apr2 (c) ∈ Xconstructed and U = {a(c), apr2 (c)} is an unfounded set of (cid:2)m w.r.t. X, however, as the atoms a(1), apr2 (1) form a cycle in Gfor the Xw.r.t. X.(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)62Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563B.2. Grid-cell problem encodingsIn this appendix, we provide details about the slight modifications made from the existing (or common) encodings, in order to use them in our experiments. The full encodings can be found in www.kr.tuwien .ac .at /research /systems /abstraction /mdaspar _material .zip.Sudoku We used the encoding from DLV group in ASPCOMP09 with slight modifications. The guessing of the assignment of numbers to the free cells is written as{sol(X, Y , N) : num(N)} ← not occupied(X, Y ), row(X), column(Y ).hasNum(X, Y ) ← sol(X, Y , N).⊥ ← not hasNum(X, Y ), row(X), column(Y ).The constraints of assigning one symbol per column and one symbol per row are the same as in the original encoding, but with standardizing apart over the sorts row and column.⊥ ← sol(X, Y 1, M), sol(X2, Y 2, M), X = X2, Y 1 < Y 2.⊥ ← sol(X1, Y , M), sol(X2, Y 2, M), X1 < X2, Y = Y 2.For the constraint of assigning one symbol per subregion, standardizing apart the original rules caused to have relations with many arguments, thus we converted them into the rules⊥ ← sol(X1, Y 1, M), sol(X2, Y 2, M),sameSubSquareLessThan(X1, Y 1, X2, Y 2).sameSubSquareLessThan(X1, Y 1, X2, Y 2) ← sameSubSquare(X1, Y 1, X2, Y 2), X1 < X2.sameSubSquareLessThan(X1, Y 1, X2, Y 2) ← sameSubSquare(X1, Y 1, X2, Y 2), Y 1 < Y 2.sameSubSquare(X1, Y 1, X2, Y 2) ← subrangeR(X1, M), subrangeR(X2, M),subrangeC(Y 1, R), subrangeC(Y 2, R).with the hardcoded facts subrangeR( X, M) and subrangeC(Y , R) for subregions w.r.t. rows and columns, respectively.Knight’s tour We used the encoding from ASPCOMP1112 with slight modifications. At most one move atom is made for each valid movement among the cells.{move(X1, Y 1, X2, Y 2)}1 ← valid(X1, Y 1, X2, Y 2).In the original encoding, the valid cells computations were done using rules of the formvalid(X1, Y 1, X2, Y 2) ← point(X1, Y 1), point(X2, Y 2), X1 = X2 + 2, Y 1 = Y 2 + 1.which are modified asvalidcell(X1, Y 1, X2, Y 2) ← dist1(X1, X2), dist2(Y 1, Y 2).validcell(X1, Y 1, X2, Y 2) ← dist2(X1, X2), dist1(Y 1, Y 2).valid(X1, Y 1, X2, Y 2) ← validcell(X1, Y 1, X2, Y 2), point(X1, Y 1), point(X2, Y 2).where the auxiliary facts dist1( X1, X2), dist2( X1, X2) represent the arithmetic operations X1 = X2 + 2, Y 1 = Y 2 + 1.The constraints to ensure that exactly one entering/leaving movement is made for each cell is the same as the original encoding. Having each cell visited is ensured by the following rulesreached(X, Y ) ← move(X1, Y 1, X, Y ), start(X1, Y 1).reached(X2, Y 2) ← reached(X1, Y 1), move(X1, Y 1, X2, Y 2).⊥ ← point(X, Y ), not reached(X, Y ), row(X), column(Y ).where the atom start( X, Y ) is used to show the starting point, instead of having in the rule the atom move(1, 1, X, Y ) as it is originally. This change makes treating the program more convenient, as the rules do not contain constants that need to mapped to different abstract constants depending on the mapping.12 www.mat .unical .it /aspcomp2011 /files /KnightTour /knight _tour.enc .asp.63Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Visitall We encoded a planning problem along the guidelines in Section 7.2 on representing actions and change. We con-sidered go( X, Y , T ) actions that can move horizontally/vertically to a cell X, Y . For such an action, we must ensure that the action does not pass through an obstacle or a previously visited cell, and that all the passed cells become visited. A common way of encoding this is to have auxiliary atoms that keep track of the cells that are in between, such asaux_passed(X, Y 2, T + 1) ← r At(X, Y , T ), go(X, Y 1, T ), Y < Y 2, Y 2 ≤ Y 1.aux_passed(X, Y 2, T + 1) ← r At(X, Y , T ), go(X, Y 1, T ), Y 1 < Y 2, Y 2 ≤ Y .aux_passed(X2, Y , T + 1) ← r At(X, Y , T ), go(X1, Y , T ), X < X2, X2 ≤ X1.aux_passed(X2, Y , T + 1) ← r At(X, Y , T ), go(X1, Y , T ), X1 < X2, X2 ≤ X.passed(X, Y ) ← aux_passed(X, Y , T ).which are then used to ensure the above conditions.⊥ ← passed(X, Y ), obs At(X, Y ).visited(X, Y , T ) ← aux_passed(X, Y , T ).⊥ ← aux_passed(X, Y , T + 1), visited(X, Y , T ).We follow the remark in Section 5 on handling different abstraction levels on variables in a rule. For example, for the first rule, in addition to the standardizing apart the rule asaux_passed(X, Y 2, T + 1) ← r At(X, Y , T ), go(X1, Y 1, T ), X = X1, Y < Y 2, Y 2 ≤ Y 1.we add the additional ruleaux_passed(X1, Y 2, T + 1) ← r At(X, Y , T ), go(X1, Y 1, T ), X = X1, Y < Y 2, Y 2 ≤ Y 1.We proceed similarly with the remaining rules.Furthermore, knowing that the action go( X1, Y 1, T ) will only be picked in a horizontal (resp. vertical) direction of r At( X, Y , T ), we drop the relation X = X1 (resp. Y = Y 1) from the body to make it smaller.B.3. Example run of mDASPARTo illustrate further considerations for debugging and refinement, we show an example run of mDASPAR.Example B.2 (ctd). We run mDASPAR with the input program (Fig. 15) and the instance shown in Fig. 13, with the initial mapping m of clustering the grid-cell into four regions (Fig. 14a).Step 1After constructing the non-ground abstract program (Fig. 16) and computing the relation types, mDASPAR com-putes an abstract answer set{reachable(a1234, b1234), reachable(a5678, b1234), reachable(a1234, b5678)}.Step 2Correctness checking first uses (cid:2)debug0answer set{ab_deactConsr3, ab_deactr2}.where the ab atoms only contain rule names (Fig. 27) to obtain the optimal Step 3 (cid:2)debug is constructed only for r2, r3 now respecting variables in the rules, and by defining ab_deactr2( X1, Y 1) asab_deactr2(X1, Y 1) ← apr2(X1, Y 1), not reachable(X1, Y 1).⊥ :∼ ab_deactr2(X1, Y 1). [1, r2, X1, Y 1]⊥ :∼ ab_deactr2(X1, Y 1), mapTo(X1, Y 1, A1, B1),isSingleton( A1), isSingleton(B1). [20, r2, X1, Y 1]refine( A1, B1) ← ab_deactr2(X1, Y 1), mapTo(X1, Y 1, A1, B1), not isSingleton( A1).refine( A1, B1) ← ab_deactr2(X1, Y 1), mapTo(X1, Y 1, A1, B1), not isSingleton(B1).and similarly ab_deactConsr3( X, Y , X1, Y 1). Correctness checking finds an optimal answer set with the atomsrefine(a1234, b5678), refine(a5678, b5678).64Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563kor1.{reachable( X, Y )} ← apr1( X, Y ).ab_deactr1 ← apr1( X, Y ), not reachable( X, Y ).⊥ :∼ ab_deactr1. [1, r1]kor2.{reachable( X1, Y 1)} ← apr2( X1, Y 1).ab_deactr2 ← apr2( X1, Y 1), not reachable( X1, Y 1).⊥ :∼ ab_deactr2. [1, r2]kor3.ab_deactConsr3 ← kor3, apr3( X, Y , X1, Y 1).⊥ :∼ ab_deactConsr3. [1, r3]kor5.kor6.{neighbor( X, Y , X1, Y 1)} ← apr5( X, Y , X1, Y 1).ab_deactr5 ← apr5( X, Y , X1, Y 1), not neighbor( X, Y , X1, Y 1).⊥ :∼ ab_deactr5. [1, r5]{neighbor( X, Y , X1, Y 1)} ← apr6( X, Y , X1, Y 1).ab_deactr6 ← apr6( X, Y , X1, Y 1), not neighbor( X, Y , X1, Y 1).⊥ :∼ ab_deactr6. [1, r6]{neighbor( X, Y , X1, Y 1)} ← blr5( X, Y , X1, Y 1), blr6( X, Y , X1, Y 1).ab_act(neighbor( X, Y , X1, Y 1)) ← blr5( X, Y , X1, Y 1), blr6( X, Y , X1, Y 1),neighbor( X, Y , X1, Y 1).⊥ :∼ ab_actneighbor(X, Y , X1, Y 1). [1, X, Y , X1, Y 1]{reachable( X, Y )} ← blr1( X, Y ), blr2( X, Y ).ab_act(reachable( X, Y )) ← blr1( X, Y ), blr2( X, Y ), reachable( X, Y ).⊥ :∼ ab_actreachable( X, Y ). [1, X, Y ]Fig. 27. Constructed debugging program Tdeact [(cid:2)] ∪ TdeactCons[(cid:2)] ∪ Tact [(cid:2), A].Step 4Step 5The region (a1234, b5678) is randomly picked to refine to {(a12, b56), (a12, b78), (a34, b56), (a34, b78)} by updating the corresponding mapping m.Relation types according to the new mapping are computed and the loop goes back to step 1 to compute a new abstract answer set.The loop continues until unsatisfiability is achieved. The abstraction shown in Fig. 14b is one such abstraction where unsatisfiability is observed.B.4. Modular concreteness checkingOrdered modularity An incremental approach to ASP solving proposed by Gebser et al. [53] builds on the concept of modules [94] and gradually increases the bound to the solution size, represented by a parameter k, to help with both grounding and solving. They are searching for an answer set with minimum size over k, thus they increment the parameter until an answer set is computed. We use a similar idea to detect the spuriousness of an abstract answer set by gradually increasing the parameter. However, in our case, the increment is continued until the spuriousness is realized with debugging, i.e., an answer set with an abnormality atom is obtained. We take a simpler view by limiting the generated grounding of the program to the parameter.Let (cid:2) be a program with the Herbrand base HB(cid:2) = LB ∪ Lk, for parameter k ranging over the natural numbers, where LB represents the static literals with arguments independent of parameter k, and Lk represents the dynamic literals which have an argument k. For a set X of literals, we denote by grd((cid:2))| X = {r | H(r) ∪ B(r) ⊆ X} the set of ground rules that Lk/ j , contain only literals over X . Let Xi ⊆ HB(cid:2) denote the set of literals until the parameter value i, i.e., Xi = LB ∪where Lk/ j denotes the set of literals with the respective argument of value j. The rules of grd((cid:2)) until parameter value iare then given by grd((cid:2))| Xi , simply denoted grd((cid:2))|i .(cid:2)Let I≤i denote the projection of an interpretation I to the literals related with the parameter value i, i.e., I≤i = I ∩ (LB ∪Li). We say that (cid:2) is ordered modular, if for each I ∈ A S((cid:2)) it holds that I≤i ∈ A S(grd((cid:2))|i) for all 0 ≤ i ≤ k. We 0≤ j≤ithen know that determining the occurrence of a literal l in an answer set I≤i relies only on the decisions made until point i.ij=0(cid:2)Proposition B.1. Let (cid:2) be an ordered modular program, m a domain mapping for (cid:2), and let ˆI ∈ AS((cid:2)m). If ˆI≤i ⊆ ˆI is spurious for some i ≤ n, then ˆI is spurious.Proof. Assume ˆI is concrete. This means that there exists some I ∈ (cid:2) such that m(I) = ˆI . As (cid:2) is ordered modular, I≤i ∈A S(grd((cid:2))|i). Thus, m(I≤i) = ˆI≤i is concrete. (cid:2)We describe in detail the implementation of these approaches.65Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Incrementing time. Approach (1) is implemented in mDASPAR to handle planning problems with atoms having time argu-ments. By Proposition B.1, we know that if the first few actions of a potential plan described by the abstract answer set have no corresponding original plan, one can conclude that this plan is spurious.A common description of the planning problem in ASP uses two sorts for time: timea = {0, . . . , n − 1}, which is used for action atoms, and time = {0, . . . , n} which is used to for the fluents. For a given program (cid:2) with a description of a planning problem that contains facts for sort time, mDASPAR works as follows. We denote by Tmeta[(cid:2)]|i the meta-program Tmeta[(cid:2)]which contains time facts (resp. timea) until domain element i (resp. i − 1), and by (cid:2)debug|i the analogous restricted version of (cid:2)debug . For a computed abstract answer set ˆI encoding a plan !s0, a0, s1, . . . , sn−1, an−1, sn" we denote by ˆI|i the part of the plan until time point i.Starting with i = 1, we continue the iteration below while i ≤ n.Step (1) Create Tmeta[(cid:2)]|i−1 and (cid:2)debug|i .Step (2) Check correctness of ˆI|i with (cid:2)debug|i ∪ Tmeta[(cid:2)]|i−1 ∪ Q mˆI|iStep (3)If ˆI|i is spurious, exit loop; otherwise, increase i by 1..This way, we check the correctness of ˆI for the action taken at time i, by debugging only for time point i as the guessing for time points t < i is restricted by using Tmeta[(cid:2)]|i−1. The time is increased incrementally while the partial solution yields a concrete partial plan. Once spuriousness is observed, the checking is stopped.Partial concretization. For approach (2), we use the possibility to have a hierarchy of abstractions mentioned in Propo-sition 3.6. The idea is to partially concretize the abstract domain, by fully concretizing certain regions and keeping the remaining ones abstract. Fig. 17 shows the hierarchy of some partial concretizations of the initial mapping. For a given mapping m, we consider a set of possible partial concretizations. We then check the correctness of an abstract answer set I over the program with partially concretized domain. As the latter still describes an abstraction compared to the original domain, this check cannot be immediately done over the original program. For that, we have must check correctness with debugging over the abstract program relative to the partial concretization.The approach is implemented in mDASPAR as follows. For a given mapping m, starting with j = 1, the iteration focuses on concretizing j regions at a time, and checks the correctness in each such j-region combination. The iteration continues until spuriousness is detected or m = mid:step (1) Compute j-region concretizations of m, say m1, . . . , mn.step (2) For every mi ∈ {m1, . . . , mn};1. Create (cid:2)mi with Tmi and the set {mi(p(c)). | p(c). ∈ (cid:2)} of facts, and (cid:2)mi2. Create the mapping m3. Check correctness of I with (cid:2)mi4..If spurious, exit loop with debug answer C .(cid:3)(mi(D)) = m(D).∪ Q mIsuch that mdebug(cid:3)(cid:3)debug .step (3)If C (cid:13)= ∅, refine m according to C and go back to step (1); otherwise, increase j by 1, and go back to step (1)We do correctness checking on the abstract level mi using (cid:2)mi . If I is concrete w.r.t. the partially concretized abstraction, this does not guarantee that I is concrete; thus, the concretization is increased to redo the check. If spuriousness is detected, the mapping is refined and the partial concretization continues from the updated mapping.Appendix C. Use case: abstraction for policy refutationAs a further example, consider checking whether an agent always manages to find a missing person with a given policy in a grid environment with obstacles. If the policy does not work, a counterexample trajectory over some part of the environment will reveal this; by inspecting the latter, one may guess why it fails. Depending on the problem, the focus points may have different nature. For the reachability example shown in Section 5.2, the focus area in the environment can remain local, while for the person search example the path of a trajectory needs to be distinguished.For illustration, we use the following running example.Example C.1 (Example 5.8 cont’d). Consider the reachability problem described in the following encoding, where reachability ((72)-(74)) is redefined by prioritizing the east neighbor over the rest, and in case the east neighbor has an obstacle, choosing the south neighbor.point(X, Y ) ← not obsAt(X, Y ), row(X), column(Y ).reachable(X, Y ) ← start(X, Y ).66(102)(103)Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563(a) Original domain(b) Distinguishing the cells reachable under the restrictions••start(a1, b1).obs At(a6, b1).obs At(a7, b4).obs At(a56, a34).obs At(a1234, a5678).obs At(a4, b1).obs At(a2, b2).obs At(a12, a34).obs At(a56, a56).Fig. 28. Reachability abstraction under east neighbor prioritization.neighborE(X, Y , X1, Y ) ← X1 − X = 1, column(Y ).neighborS(X, Y , X, Y 1) ← Y 1 − Y = 1, row(X).reachableE(X, Y , X1, Y ) ← reachable(X, Y ), point(X1, Y ),neighborE(X, Y , X1, Y ).hasNeighborE(X, Y ) ← reachableE(X, Y , X1, Y 1).reachable(X1, Y 1) ← reachableE(X, Y , X1, Y 1).reachable(X, Y 1) ← reachable(X, Y ), point(X, Y 1),(104)(105)(106)(107)(108)(109)neighborS(X, Y , X, Y 1), not hasNeighborE(X, Y ).For the instance shown in Fig. 28a the reachable cells are determined in the order →2↓→5↓6. The abstraction shown in Fig. 28b singles out the area that contains the cells that are reachable according to the restrictions.We now focus on using the abstraction over grid-cells for the problem of checking policies on whether they manage to guide the agent towards the goal. We consider two versions of this problem and discuss the use of abstraction.As a running example, we consider an agent trying to find its way in a maze towards a goal point (similar in spirit to the example of finding a missing person). For representing and generating the mazes, we use an altered version of the Maze Generation encoding from ASP Competition 2011.13 A policy that may come to one’s mind when talking about mazes is the well-known “right-hand rule”, which is known to work in many maze instances, except when the goal is in the middle area and the agent is forced to loop due to the obstacle layout.Does the policy work on a given instance? For fixed problem instances, this check is done by a search of a counterexample trajectory which follows the policy but does not reach the goal. If none is found (i.e., unsatisfiability is achieved), we conclude that the policy works for this instance. Abstraction can be used to focus on the part of the instance which is enough to show that the policy fails or works; notice that the latter case becomes similar to having unsatisfiable problems. The necessary granularity of the abstraction depends on the complexity of the policy. As demonstrated in Fig. 30, for refuting the “right-hand rule” policy the abstraction must refine at least the outer area (if not more).To observe how the policy type affects the resulting abstraction, we did some experiments. To help with the refinement decisions, the initial abstraction distinguishes the starting point of the agent and abstracts over the rest.We consider the following two policies:(A) Right-hand rule: Follow the wall on the right-hand side.(B) Naive policy: Choose the direction to move to with the priority right > down > left > up.We generated 20 instances where on some of them both, one, or none of the policies work. For the debugging method we picked time increment, as we wanted it to focus on each step of the abstract trajectory starting from the beginning, and on whether or not the steps match the policy’s decisions in the corresponding original trajectory. Furthermore, the refinement decision is made only from one abstract answer set, to avoid that a concrete answer set is encountered among spurious ones; this would finalize the search and achieve a clearly non-faithful abstraction.Table 7 shows the results of using mDASPAR to achieve an abstraction with a concrete solution. Obtaining SAT means that the program found a concrete solution, i.e., a concrete counterexample trajectory, which shows that the policy does not work, while having UNSAT means that the policy works. As expected, the naive policy failed to work for most of the 13 https://www.mat .unical .it /aspcomp2011 /files /MazeGeneration /maze _generation .enc .asp.67Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Table 7Policy checking in maze instances.sat/unsatavg. stepavg. costavg. best stepavg. best costnaiveright-hand16/46/147.212.50.3910.6306.511.80.3620.599Fig. 29. Abstractions on policy checking in maze instances (with the supporting/refuting paths).instances. Since the right-hand rule forces to traverse the environment more, mDASPAR required to have finer abstractions to figure out the concrete solution. In both cases, the obtained abstractions were not too distant from the best possible ones, although still sometimes the focus was shifted to the irrelevant parts of the grid. All of the obtained resulting abstractions were faithful, which means that they were able to show the actual behavior of the policy. Fig. 29 shows the resulting abstractions for three of the instances.Does the policy always work? This is a more involved check, since a set of possible instances has to be considered and a search of a counterexample trajectory among each instance needs to be done. If the policy works, then all possible policy trajectories in all instances have to be checked to conclude this result. For this case, considering an abstraction that focuses on a certain part of the grid may not be useful, since depending on the structure of the instances different parts of the grid may need to be singled out. However, if the policy does not work, it is enough to find an instance in which a counterexample policy trajectory can be shown. Thus, an abstraction that focuses on a certain part of the grid where some instance can show a counterexample would be useful.68Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563Fig. 30. Can we refute the right-hand rule policy in all maze instances with one abstraction?In ASP, such a check can be done by making two sets of guesses: (1) choose a valid instance, by guessing the layout of the environment and the position of the goal, and (2) determine a counterexample trajectory, by guessing the movements of the agent following the policy which do not achieve the goal in the instance. If the policy is deterministic (i.e., chooses exactly one action at a state), then the second guessing part becomes straightforward. However, for nondeterministic policies, a choice of possible actions to take exists, which adds to the complexity of the search.The experiments showed that combining these guesses and those introduced in the syntactic transformation causes many spurious abstract answer sets, which sometimes force refinement decisions towards useless parts of the grid. For example, in general policy checking for the right-hand rule, mDASPAR must go back to the original domain to catch an instance with a counterexample trajectory, as the policy forces to traverse the environment and in the abstract encoding the guesses of the instance and the movements cause to create many spurious trajectories. As for the naive policy, mDASPAR can encounter a counterexample trajectory in few refinement steps: it is sufficient to realize that this policy fails by creating a partial instance where the agent enters a dead-end and has to leave by moving left; it then starts looping by moving right and left.We remark that for a failing policy we may not expect to have one abstraction mapping that can be applied with any possible instance and catch a counterexample trajectory, the less a mapping that is faithful for any instance. Fig. 30a shows an instance in which the right-hand policy is unable to reach the (green) goal point from the (red) entry point in the upper left corner. An abstraction such as Fig. 30b is enough to realize that a loop occurs and a goal cannot be reached (it is a faithful abstraction for this instance). However, this abstraction does not always distinguish the cells that force to obtain a counterexample trajectory in each possible refuting instance. For example, the instance in Fig. 30c also forces the agent to loop; since with the same abstraction (Fig. 30d) there is uncertainty among the abstract regions, it is still possible to create spurious counterexample trajectories. Thus, faithfulness cannot be achieved. Here the identity abstraction would be the one that can be used to (faithfully) refute the policy in all possible instances.References[1] M. Alviano, C. Dodaro, Anytime answer set optimization via unsatisfiable core shrinking, Theory Pract. Log. Program. 16 (2016) 533–551.[2] M. Alviano, C. Dodaro, M. Järvisalo, M. Maratea, A. Previti, Cautious reasoning in ASP via minimal models and unsatisfiable cores, Theory Pract. Log. Program. 18 (2018) 319–336, https://doi .org /10 .1017 /S1471068418000145.[3] M. Alviano, W. Faber, N. Leone, Disjunctive ASP with functions: decidable queries and effective computation, Theory Pract. Log. Program. 10 (2010) 497–512, https://doi .org /10 .1017 /S1471068410000244.AAAI 1988, 1988, pp. 100–104.[4] J.S. Anderson, A.M. Farley, Plan abstraction based on operator generalization, in: Proceedings of the 7th National Conference on Artificial Intelligence, [5] B. Andres, B. Kaufmann, O. Matheis, T. Schaub, Unsatisfiability-based optimization in clasp, in: Technical Communications of the 28th International Conference on Logic Programming, ICLP 2012, Schloss Dagstuhl-Leibniz-Zentrum Fuer Informatik, 2012, pp. 211–221.[6] J. Arias, M. Carro, E. Salazar, K. Marple, G. Gupta, Constraint answer set programming without grounding, Theory Pract. Log. Program. 18 (2018) 337–354.[7] F. Bacchus, Q. Yang, Downward refinement and the efficiency of hierarchical problem solving, Artif. Intell. 71 (1994) 43–100.69Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563[8] C. Backstrom, P. Jonsson, Planning with abstraction hierarchies can be exponentially less efficient, in: Proceedings of the 14th International Joint Conference on Artificial Intelligence, vol. 2, IJCAI 1995, Morgan Kaufmann Publishers Inc., 1995, pp. 1599–1604.[9] B. Banihashemi, G. De Giacomo, Y. Lespérance, Abstraction in situation calculus action theories, in: Proceedings of the 31st AAAI Conference on Artificial Intelligence, AAAI 2017, 2017, pp. 1048–1055.[10] B. Banihashemi, G. De Giacomo, Y. Lespérance, Abstraction of agents executing online and their abilities in the situation calculus, in: Proceedings of the 27th International Joint Conference on Artificial Intelligence, IJCAI 2018, 2018, pp. 1699–1706.[11] F. Belardinelli, A. Lomuscio, J. Michaliszyn, Agent-based refinement for predicate abstraction of multi-agent systems, in: Proceedings of the 22nd European Conference on Artificial Intelligence, ECAI 2016, IOS Press, 2016, pp. 286–294.[12] M. Bichler, M. Morak, S. Woltran, The power of non-ground rules in answer set programming, Theory Pract. Log. Program. 16 (2016) 552–569.[13] S. Bistarelli, P. Codognet, F. Rossi, Abstracting soft constraints: framework, properties, examples, Artif. Intell. 139 (2002) 175–211.[14] B. Bonet, G. De Giacomo, H. Geffner, S. Rubin, Generalized planning: non-deterministic abstractions and trajectory constraints, in: Proceedings of the 26th International Joint Conference on Artificial Intelligence, IJCAI 2017, 2017, pp. 873–879.[15] B. Bonet, H. Geffner, Policies that generalize: solving many planning problems with the same policy, in: Proceedings of the 24th International Joint Conference on Artificial Intelligence, IJCAI 2015, AAAI Press, 2015.[16] M. Brain, M. Gebser, J. Pührer, T. Schaub, H. Tompits, S. Woltran, Debugging asp programs by means of asp, in: Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR 2007, Springer, 2007, pp. 31–43.[17] S. Brass, J. Dix, Characterizations of the disjunctive stable semantics by partial evaluation, J. Log. Program. 32 (1997) 207–228.[18] G. Brewka, T. Eiter, M. Truszczy ´nski, Answer set programming at a glance, Commun. ACM 54 (2011) 92–103.[19] G. Brewka, T. Eiter, M. Truszczy ´nski (Eds.), Answer Set Programming, AI Mag. 37 (3) (2016), AAAI Press.[20] P. Cabalar, J. Fandinno, M. Fink, Causal graph justifications of logic programs, Theory Pract. Log. Program. 14 (2014) 603–618.[21] F. Calimeri, W. Faber, M. Gebser, G. Ianni, R. Kaminski, T. Krennwallner, N. Leone, M. Maratea, F. Ricca, T. Schaub, ASP-core-2 input language format, arXiv:1911.04326, 2019.https://doi .org /10 .1613 /jair.4591.[22] B.D. Cat, M. Denecker, M. Bruynooghe, P.J. Stuckey, Lazy model expansion: interleaving grounding with search, J. Artif. Intell. Res. 52 (2015) 235–286, [23] L. Chittaro, R. Ranon, Hierarchical model-based diagnosis based on structural abstraction, Artif. Intell. 155 (2004) 147–182.[24] K.L. Clark, Negation as failure, in: Logic and Data Bases, Springer, 1978, pp. 293–322.[25] E. Clarke, O. Grumberg, S. Jha, Y. Lu, H. Veith, Counterexample-guided abstraction refinement for symbolic model checking, J. ACM 50 (2003) 752–794.[26] E.M. Clarke, O. Grumberg, D.E. Long, Model checking and abstraction, ACM Trans. Program. Lang. Syst. (1994) 1512–1542.[27] E.M. Clarke, T.A. Henzinger, H. Veith, R. Bloem, Handbook of Model Checking, Springer, 2018.[28] M. Cohen, M. Dam, A. Lomuscio, F. Russo, Abstraction in model checking multi-agent systems, in: International Conference on Autonomous Agents and Multiagent Systems, vol. 2, 2009, pp. 945–952.[29] P. Cousot, R. Cousot, Abstract interpretation and application to logic programs, J. Log. Program. 13 (1992) 103–179.[30] K.J.W. Craik, The Nature of Explanation, vol. 445, CUP Archive, 1952.[31] J.C. Culberson, J. Schaeffer, Pattern databases, Comput. Intell. 14 (1998) 318–334.[32] D. Dams, R. Gerth, O. Grumberg, Abstract interpretation of reactive systems, ACM Trans. Program. Lang. Syst. 19 (1997) 253–291.[33] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Comput. Surv. 33 (2001) 374–425.[34] J. Devriendt, B. Bogaerts, M. Bruynooghe, M. Denecker, On local domain symmetry for model expansion, Theory Pract. Log. Program. 16 (2016) [35] J. Dix, U. Kuter, D. Nau, Planning in answer set programming using ordered task decomposition, in: Annual Conference on Artificial Intelligence, [36] C. Dodaro, P. Gasteiger, B. Musitsch, F. Ricca, K. Shchekotykhin, Interactive debugging of non-ground asp programs, in: Logic Programming and Non-636–652, https://doi .org /10 .1017 /S1471068416000508.Springer, 2003, pp. 490–504.monotonic Reasoning, LPNMR, Springer, 2015, pp. 279–293.[37] C. Drescher, O. Tifrea, T. Walsh, Symmetry-breaking answer set solving, AI Commun. 24 (2011) 177–194, https://doi .org /10 .3233 /AIC -2011 -0495.[38] S. Edelkamp, Planning with pattern databases, in: Proceedings of the 6th European Conference on Planning, ECP 2001, 2001, pp. 13–24.[39] T. Eiter, W. Faber, M. Fink, S. Woltran, Complexity results for answer set programming with bounded predicate arities and implications, Ann. Math. Artif. Intell. 51 (2007) 123.Springer, 2003, pp. 224–238.[40] T. Eiter, M. Fink, Uniform equivalence of logic programs under the stable model semantics, in: International Conference on Logic Programming, [41] T. Eiter, M. Fink, T. Krennwallner, C. Redl, HEX-programs with existential quantification, in: M. Hanus, R. Rocha (Eds.), Declarative Programming and Knowledge Management - Declarative Programming Days, KDPD 2013, Unifying INAP, WFLP, and WLP, Kiel, Germany, September 11–13, 2013, Springer, 2013, pp. 99–117, Revised Selected Papers, https://doi .org /10 .1007 /978 -3 -319 -08909 -6 _7.[42] T. Eiter, M. Fink, H. Tompits, S. Woltran, Simplifying logic programs under uniform and strong equivalence, in: V. Lifschitz, I. Niemelä (Eds.), Proceed-ings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR 2004, Springer, 2004, pp. 87–99.[43] T. Eiter, M. Fink, S. Woltran, Semantical characterizations and complexity of equivalences in answer set programming, ACM Trans. Comput. Log. 8 [44] T. Eiter, G. Gottlob, Y. Gurevich, Normal forms for second-order logic over finite structures, and classification of NP optimization problems, Ann. Pure (2007) 17, https://doi .org /10 .1145 /1243996 .1244000.Appl. Log. 78 (1996) 111–125.[45] T. Eiter, Z.G. Saribatur, P. Schüller, Abstraction for zooming-in to unsolvability reasons of grid-cell problems, in: Proceedings of the IJCAI 2019 Work-shop on Explainable Artificial Intelligence (XAI), 2019, pp. 7–13, Online available at https://drive .google .com /file /d /1ma5wilaj31A0d5KC4I2fYaTC _Lqm _d9X /view and http://arxiv.org /abs /1909 .04998.[46] T. Eiter, H. Tompits, S. Woltran, On solution correspondences in answer-set programming, in: L.P. Kaelbling, A. Saffiotti (Eds.), IJCAI-05, Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence, Edinburgh, Scotland, UK, July 30 - August 5, 2005, Professional Book Center, 2005, pp. 97–102, http://ijcai .org /Proceedings /05 /Papers /1177.pdf.[47] E. Erdem, M. Gelfond, N. Leone, Applications of answer set programming, AI Mag. 37 (2016) 53–68.[48] E. Erdem, V. Patoglu, Applications of ASP in robotics, Künstl. Intell. 32 (2018) 143–149.[49] A.A. Falkner, G. Friedrich, K. Schekotihin, R. Taupe, E.C. Teppan, Industrial applications of answer set programming, Künstl. Intell. 32 (2018) 165–176.[50] J. Fandinno, C. Schulz, Answering the “why” in answer set programming - a survey of explanation approaches, Theory Pract. Log. Program. 19 (2019) [51] M. Fox, D. Long, The detection and exploitation of symmetry in planning problems, in: Proceedings of the 16th International Joint Conference on 114–203.Artificial Intelligence, IJCAI 1999, 1999, pp. 956–961.[52] E.C. Freuder, Eliminating interchangeable values in constraint satisfaction problems, in: AAAI, 1991, pp. 227–233.[53] M. Gebser, R. Kaminski, B. Kaufmann, M. Ostrowski, T. Schaub, S. Thiele, Engineering an incremental ASP solver, in: Proceedings of the 24th Interna-tional Conference on Logic Programming, ICLP 2008, 2008, pp. 190–205.[54] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Advanced preprocessing for answer set solving, in: Proceedings of the 18th European Conference on Artificial Intelligence, ECAI 2008, IOS Press, 2008, pp. 15–19.70Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 103563[55] M. Gebser, J. Pührer, T. Schaub, H. Tompits, A meta-programming technique for debugging answer-set programs, in: Proceedings of the 23rd AAAI Conference on Artificial Intelligence, AAAI 2008, 2008, pp. 448–453.[56] T. Geibinger, H. Tompits, Characterising relativised strong equivalence with projection for non-ground answer-set programs, in: F. Calimeri, N. Leone, M. Manna (Eds.), Logics in Artificial Intelligence - 16th European Conference, Proceedings, JELIA 2019, Rende, Italy, May 7-11, 2019, Springer, 2019, pp. 542–558.[57] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Gener. Comput. 9 (1991) 365–385.[58] E. Giunchiglia, Y. Lierler, M. Maratea, Sat-based answer set programming, in: Proceedings of the 19th National Conference on Artificial Intelligence, AAAI 2004, 2004, pp. 61–66.[59] F. Giunchiglia, T. Walsh, A theory of abstraction, Artif. Intell. 57 (1992) 323–389.[60] G. Gottlob, N. Leone, H. Veith, Succinctness as a source of complexity in logical formalisms, Ann. Pure Appl. Log. 97 (1999) 231–260.[61] M. Helmert, P. Haslum, J. Hoffmann, et al., Flexible abstraction heuristics for optimal sequential planning, in: Proceedings of the 17th International Conference on Automated Planning and Scheduling, ICAPS 2007, 2007, pp. 176–183.[62] I.T. Hernádvölgyi, R.C. Holte, Psvn: A Vector Representation for Production Systems, 1999.[63] J. Hoffmann, A. Sabharwal, C. Domshlak, Friends or foes? An AI planning perspective on abstraction and search, in: Proceedings of the 16th Interna-tional Conference on Automated Planning and Scheduling, ICAPS 2006, 2006, pp. 294–303.[64] R.C. Holte, T. Mkadmi, R.M. Zimmer, A.J. MacDonald, Speeding up problem solving by abstraction: a graph oriented approach, Artif. Intell. 85 (1996) [65] L. Illanes, S.A. McIlraith, Numeric planning via search space abstraction, in: Proceedings of the Workshop on Knowledge-Based Techniques for Problem [66] L. Illanes, S.A. McIlraith, Generalized planning via abstraction: arbitrary numbers of objects, in: Proceedings of the 33rd AAAI Conference on Artificial [67] T. Janhunen, I. Niemelä, D. Seipel, P. Simons, J.H. You, Unfolding partiality and disjunctions in stable model semantics, ACM Trans. Comput. Log. 7 321–361.Solving and Reasoning, 2016.Intelligence, AAAI 2019, 2019.(2006) 1–37.[68] P.N. Johnson-Laird, Mental Models: Towards a Cognitive Science of Language, Inference, and Consciousness, Harvard University Press, 1983.[69] S. Kambhampati, L. Davis, Multiresolution path planning for mobile robots, IEEE J. Robot. Autom. 2 (1986) 135–145.[70] C.A. Knoblock, Automatically generating abstractions for planning, Artif. Intell. 68 (1994) 243–302.[71] J. Kramer, Is abstraction the key to computing?, Commun. ACM 50 (2007) 36–42.[72] C. Lefèvre, C. Béatrix, I. Stéphan, L. Garcia, Asperix, a first-order forward chaining approach for answer set computing, Theory Pract. Log. Program. 17 [73] J. Leite, A bird’s-eye view of forgetting in answer-set programming, in: Proceedings of the 14th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR 2017, Springer, 2017, pp. 10–22.[74] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Trans. (2017) 266–310.Comput. Log. 7 (2006) 499–562.[75] N. Leone, P. Rullo, F. Scarcello, Disjunctive stable models: unfounded sets, fixpoint semantics, and computation, Inf. Comput. 135 (1997) 69–112.[76] M.H. Liffiton, K.A. Sakallah, Algorithms for computing minimal unsatisfiable subsets of constraints, J. Autom. Reason. 40 (2008) 1–33.[77] V. Lifschitz, Answer set planning, in: International Conference on Logic Programming, ICLP, 1999, pp. 23–37.[78] V. Lifschitz, Twelve definitions of a stable model, in: M. Garcia de la Banda, E. Pontelli (Eds.), Logic Programming, Springer, Berlin Heidelberg, 2008, pp. 37–51.[79] V. Lifschitz, What is answer set programming?, in: Proceedings of the 23rd AAAI Conference on Artificial Intelligence, AAAI 2008, 2008, pp. 1594–1597.[80] V. Lifschitz, D. Pearce, A. Valverde, Strongly equivalent logic programs, ACM Trans. Comput. Log. 2 (2001) 526–541.[81] F. Lin, Y. Zhao, Assat: computing answer sets of a logic program by sat solvers, Artif. Intell. 157 (2004) 115–137.[82] C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, S. Bensalem, D. Probst, Property preserving abstractions for the verification of concurrent systems, Form. Methods Syst. Des. 6 (1995) 11–44.[83] A. Lomuscio, J. Michaliszyn, An abstraction technique for the verification of multi-agent systems against atl specifications, in: Proceedings of the 14th International Conference on Principles of Knowledge Representation and Reasoning, KR 2014, AAAI Press, 2014.[84] A. Lomuscio, J. Michaliszyn, Verification of multi-agent systems via predicate abstraction against ATLK specifications, in: Proceedings of AAMAS, 2016, [85] I. Lynce, J.P.M. Silva, On computing minimum unsatisfiable cores, in: Proceedings of the 7th International Conference on Theory and Applications of [86] M.J. Maher, Equivalences of logic programs, in: E. Shapiro (Ed.), Third International Conference on Logic Programming, Springer, Berlin Heidelberg, pp. 662–670.Satisfiability Testing, SAT 2004, 2004.1986, pp. 410–424.[87] K. Marple, E. Salazar, G. Gupta, Computing stable models of normal logic programs without grounding, arXiv:1709 .00501, 2017.[88] M. Morak, S. Woltran, Preprocessing of complex non-ground rules in answer set programming, in: Technical Communications of the 28th International Conference on Logic Programming, 2012, p. 247.[89] I. Mozetiˇc, Hierarchical model-based diagnosis, Int. J. Man-Mach. Stud. 35 (1991) 329–362.[90] P.P. Nayak, A.Y. Levy, A semantic theory of abstractions, in: Proc. International Joint Conference on Artificial Intelligence, 1995, pp. 196–203.[91] B. Nebel, Y. Dimopoulos, J. Koehler, Ignoring irrelevant facts and operators in plan generation, in: European Conference on Planning, Springer, 1997, pp. 338–350.[92] A. Newell, H.A. Simon, Human Problem Solving, Prentice-Hall, 1972.[93] J. Oetsch, J. Pührer, H. Tompits, Catching the ouroboros: on debugging non-ground answer-set programs, Theory Pract. Log. Program. 10 (2010) [94] E. Oikarinen, T. Janhunen, Modular equivalence for normal logic programs, in: Proceedings of the 17th European Conference on Artificial Intelligence, [95] M. Osorio, J.A. Navarro, J. Arrazola, Equivalence in answer set programming, in: A. Pettorossi (Ed.), Logic Based Program Synthesis and Transformation, 513–529.ECAI 2006, IOS Press, 2006, pp. 412–416.Springer, Berlin Heidelberg, 2002, pp. 57–75.[96] A.D. Palù, A. Dovier, E. Pontelli, G. Rossi, Gasp: answer set programming with lazy grounding, Fundam. Inform. 96 (2009) 297–322.[97] D. Pearce, Simplifying logic programs under answer set semantics, in: Logic Programming, 2004, pp. 210–224.[98] D. Pearce, Equilibrium logic, Ann. Math. Artif. Intell. 47 (2006) 3–41.[99] D. Pearce, A. Valverde, Synonymus theories in answer set programming and equilibrium logic, in: R.L. de Mántaras, L. Saitta (Eds.), Proceedings of the 16th Eureopean Conference on Artificial Intelligence, ECAI’2004, Including Prestigious Applicants of Intelligent Systems, PAIS 2004, Valencia, Spain, August 22-27, 2004, IOS Press, 2004, pp. 388–392.[100] D. Pearce, A. Valverde, Quantified equilibrium logic and foundations for answer set programs, in: M.G. de la Banda, E. Pontelli (Eds.), Logic Program-ming, 24th International Conference, Proceedings, ICLP 2008, Udine, Italy, December 9-13 2008, Springer, 2008, pp. 546–560.[101] D. Pearce, A. Valverde, Synonymous theories and knowledge representations in answer set programming, J. Comput. Syst. Sci. 78 (2012) 86–104, https://doi .org /10 .1016 /j .jcss .2011.02 .013.71Z.G. Saribatur, T. Eiter and P. SchüllerArtificial Intelligence 300 (2021) 1035631987, pp. 349–362.[102] D.A. Plaisted, Theorem proving with abstraction, Artif. Intell. 16 (1981) 47–108.[103] E. Pontelli, T.C. Son, O. Elkhatib, Justifications for logic programs under answer set semantics, Theory Pract. Log. Program. 9 (2009) 1–56.[104] J. Pührer, H. Tompits, Casting away disjunction and negation under a generalisation of strong equivalence with projection, in: E. Erdem, F. Lin, T. Schaub (Eds.), Logic Programming and Nonmonotonic Reasoning, 10th International Conference, Proceedings, LPNMR 2009, Potsdam, Germany, September 14-18, 2009, Springer, 2009, pp. 264–276.[105] P. Riddle, J. Douglas, M. Barley, S. Franco, Improving performance by reformulating PDDL into a bagged representation, in: Proceedings of the Work-shop on Heuristics and Search for Domain-Independent Planning, HSDIP 2016, 2016, pp. 28–36.[106] E.D. Sacerdoti, Planning in a hierarchy of abstraction spaces, Artif. Intell. 5 (1974) 115–135.[107] Y. Sagiv, Optimizing datalog programs, in: Proceedings of the 6th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, ACM, [108] L. Saitta, J.D. Zucker, Abstraction in Artificial Intelligence and Complex Systems, vol. 456, Springer, 2013.[109] Z.G. Saribatur, T. Eiter, Reactive policies with planning for action languages, in: Proceedings of the 15th European Conference on Logics in Artificial Intelligence, JELIA 2016, in: Lecture Notes in Computer Science, vol. 10021, Springer, 2016, pp. 463–480.[110] Z.G. Saribatur, T. Eiter, Omission-based abstraction for answer set programs, in: Proceedings of the 16th International Conference on Principles of Knowledge Representation and Reasoning, KR 2018, AAAI Press, 2018, pp. 42–51.[111] Z.G. Saribatur, T. Eiter, Omission-based abstraction for answer set programs, Theory Pract. Log. Program. (2020) 1–51, Extended version of [110].[112] Z.G. Saribatur, T. Eiter, A semantic perspective on omission abstraction in ASP, in: Proceedings of the 17th International Conference on Principles of Knowledge Representation and Reasoning, KR 2020, IJCAI Organization, 2020, pp. 733–737.[113] Z.G. Saribatur, P. Schüller, T. Eiter, Abstraction for non-ground answer set programs, in: Proceedings of the 16th European Conference on Logics in Artificial Intelligence, JELIA 2019, in: Lecture Notes in Computer Science, Springer, 2019, pp. 576–592.[114] T. Schaub, S. Woltran, Answer set programming unleashed!, Kidney Int. 32 (2018) 105–108.[115] C. Schulz, F. Toni, ABA-based answer set justification, Theory Pract. Log. Program. (2013) 4–5.[116] J. Seipp, M. Helmert, Counterexample-guided Cartesian abstraction refinement, in: Proceedings of the 23rd International Conference on Automated Planning and Scheduling, ICAPS, 2013, 2013.[117] P. Simons, I. Niemelä, T. Soininen, Extending and implementing the stable model semantics, Artif. Intell. 138 (2002) 181–234.[118] S. Srivastava, N. Immerman, S. Zilberstein, A new representation and associated algorithms for generalized planning, Artif. Intell. 175 (2011) 615–647.[119] H. Turner, Strong equivalence made easy: nested expressions and weight constraints, Theory Pract. Log. Program. 3 (2003) 609–622.[120] A. Van Gelder, K.A. Ross, J.S. Schlipf, The well-founded semantics for general logic programs, J. ACM 38 (1991) 619–649.[121] A. Weinzierl, Blending lazy-grounding and CDNL search for answer-set solving, in: Logic Programming and Nonmonotonic Reasoning - 14th Interna-tional Conference, Proceedings, LPNMR 2017, Espoo, Finland, July 3-6, 2017, 2017, pp. 191–204.[122] S. Woltran, A common view on strong, uniform, and other notions of equivalence in answer-set programming, Theory Pract. Log. Program. 8 (2008) 217–234, https://doi .org /10 .1017 /S1471068407003250.[123] S. Zhang, F. Yang, P. Khandelwal, P. Stone, Mobile robot planning using action language BC with an abstraction hierarchy, in: Proc. International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR, Springer, 2015, pp. 502–516.72