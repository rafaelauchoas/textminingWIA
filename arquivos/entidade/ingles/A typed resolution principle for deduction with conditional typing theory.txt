Artificial Intelligence 75 (1995) 161-194 Artificial Intelligence A typed resolution principle for deduction with conditional typing theory Tie-Cheng Wang * Kestrel Institute, 3260 Hillview Avenue, Palo Alto, CA 94304, USA Received October 1992; revised March 1994 Abstract The formal reasoning involved in solving a real world problem usually consists of two parts: type reasoning associated with the type structure of the problem domain, and general reasoning associated with the kernel formulation. This paper introduces a typed resolution principle for a typed predicate calculus. This principle permits a separation of type reasoning from general reasoning even when the background typing theory shares the same language constructs with the kernel formulation. Such a typing theory is required for an accurate formulation of the type structure of a computer program which contains partial functions and predicate subtypes, and also is useful for efficiently proving certain theorems from mathematics and logic by typed (sorted) formulation and deduction. The paper presents a typed deduction procedure which employs type reasoning as a form of constraints to general reasoning for speeding up the proof discovery. The paper also discusses further refinements of the procedure by incorporating existing refinements of untyped resolution. 1. Introduction The theory of data types often plays a fundamental role in the formal reasoning involved in solving a real world problem. Type specification is indispensable both for restricting the categories, or data types, of individuals involved in the kernel specification of the problem, and for formulating the data type theories about the problem domain. Consequently, the formal reasoning usually consists of two parts: one associated with type relations, called type reasoning, and the other associated with general relations, called general reasoning. * E-mail: wang@kestrel.edu. 0004-3702/95/$09.50 @ 1995 Elsevier Science B.V. All rights reserved SSDIOOO4-3702(94)00027-X 162 Tie-Cheng Wang/Art$cial Intelligence 75 (1995) 161-194 type reasoning The simplest approach to handling relations are specified by standard that it permits a direct application of all existing proof techniques The disadvantage problem mixes for which more efficient methods can be applied. In addition, type formulae. This approach has the advantage theory. to solve a special it it is inelegant: is to use predicate calculus: it uses a general method is that it is inefficient: the type calculus for first-order first-order into the deductive is hybrid knowledge to carry out inference of general reasoning. representation type reasoning, sorted reasoning and uses algorithms to the general Another approach uses specialized a form of constraints This approach programming, calculus computer programs and efficiently proving certain (sorted) constructors Particularly, we need to deal with conditional and reasoning. This approach as for speeding up the proof discovery. logic typed predicate to this approach. However, motivated by reasoning about from mathematics by typed the capability of handling type partial functions, and subtypes. and deduction, we shall emphasize and relations associated with polymorphism, includes constrained reported here belongs or order-sorted) resolution, logic, constraint type reasoning typing rules. (many-sorted formulation resolution, etc. The theorems theory and A conditional typing rule is a typing rule having a hypothetical condition on general relations. Conditional ( 1) It is needed for accurately typing rule is needed in a number of important cases. typing partial functions. For example, div( X, y) : int/ formally as a language. For example, in the next section.) subranges and enumeration y # O/x: int A y: int. (The symbols “/” and “:” will be introduced part of our typed language It is needed for specifying ventional programming and x: weekend/x E {saturday, sunday}. It is needed x: integer. It may be needed a typed formula. For example, x: string/vhf(x) It may be needed x $ Z/x: dpt (see Example 2.4). for some typing rules created naturally for typing some Skolem for specifying predicate (see Example 2.3). (2) (3) (4) (5) from normalization of functions. For example, q(x) : xpt/ types occurring in a con- i: dbid/lb < i A i 6 ub/i: integer, subtypes. For example, X: odd/-even(x)/ Due to the existence of conditional typing rules, existing techniques on many-sorted (to be addressed sorting or order-sorted predicate calculus may be inefficient, or difficult few exceptions later), most of previous studies that the underlying no hypothetical solved by our typed approach when typing the background for general language components for solving theory relations. Thus, a crucial problem type reasoning logical is how to separate theory and the kernel relations. The typed resolution principle (typing) on general is nonconditional formulation condition to apply directly. With in sorted logic assume in the sense of having that must be from general reasoning share the same is introduced principle permits a normalization this problem. resolution into two subsets of clauses. One is a set of typing of the denial of a theorem The typed being proved rules, called a typing theory, and the other is a set of typed clauses. The principle consists of two special forms of binary resolution. One is the binary resolution of two typed clauses upon their kernels, called kernel resolution. The other is the binary the type restriction of a typed clause and the head of a typing rule, called TP-resolution. Kernel resolution upon resolution the completeness to reduce prove permits one typing of these clauses deduction procedures theory lie-Cheq Wang/Artificial Intelligence 7.5 (1995) 161-194 163 to deduce consequences is used formulation. TP-resolution and TP-deduction. Type-checking type restrictions consequences cannot be satisfied to the general related from the general relations is used to carry out type reasoning: contained namely, the kernel in type-checking detects those consequences in the given relations contained typing of kernel resolution whose deduces theory. TP-deduction in the typing theory. We shall prove a typed version of the Herbrand of the typed resolution principle. The typed Herbrand the proof of the unsatisfiability theorem, and based on this theorem, theorem in a of a set of typed clauses to the search for an unsatisfiable in the typing theory. It thus provides from untyped deduction. subset of untyped a basis logical consequences for developing typed to general problem solving, and demonstrate Despite the gain in the efficiency by specializing type reasoning, (sorted) deduction this problem, we shall devote a good deal of discussion main cost of proving a theorem by a typed reasoning. By noting design of typed deduction procedures which can also be efficient in general In particular, we shall define a TP-second deduction procedure, and investigate resolution. the existing improvements from general prob- Besides from program analysis, many in our typed language in a nontrivial manner, such that can be effectively applied. The paper will present some refinements of untyped theorems reasoning. its further theorems derived by incorporating in many cases the is still due to general to the lem solving can be formulated the typed deduction techniques examples which apply improvements The basic typed deduction both in the clarity of representation type reasoning idea of specializing [ 241. Since famous paper on non-resolution theorem proving then, much research Bledsoe’s typed deductive databases focused on the sorted predicate calculus Schmidt-Schauss formulate handle deduction on sort relations. This approach has demonstrated over unsorted approach in solving certain problems taxonomic (Walther [ 27 1, etc.). The sorted predicate calculus employs sorted languages relations, and uses special algorithms, mainly sorted unification, and in the efficiency of reasoning. systems dates back to in deductive [3] and Reiter’s work on in this direction has been [ 111, Frisch[ 131, and to to [ 311, Cohn a great advantage intelligence. from logic and artificial The typed predicate calculus presented here extends to appear general predicates [ 121 of Cohn allows certain to include general predicates by allowing this extension, we must mention deduction Regarding [ 381 also has the ability LLAMA However, most of these systems were produced give no answer be incorporated, whereas our typed approach emphasizes refinements of untyped resolution. Thus, our typed approach substitution transforming for systematically of the corresponding an unsorted deduction transforming to the question of how existing sorted deduction. a completeness framework system that the logic of Weidenbach in typing in the underlying typing the existing approach of sorted theory. and Ohlbach theory. The sorted prover in the sort theory. that they can of existing the incorporation is in the direction of Frisch’s in the sense resolution from scratch refinements of unsorted into a sorted one. It also provides a method into one proof for an unsorted deduction [ 13,141. Frisch’s framework provides a method of systematically limited use of general predicates Besides sorted deduction, our typed approach cation system (RQS) [ 7,8], constraint logic programming is closely related (CLP) to Btirckert’s quantifi- [ 17,161, and Stickel’s 164 Tie-Cheng Wang/Arti$cial Intelligence 75 (1995) 161-194 [ 281. All of these systems improve on automated deduction by sep- theory resolution arating out the reasoning associated with those parts of problem solving for which more efficient knowledge representation and reasoning methods are known, or can be developed. However, both Frisch’s substitution framework and Btirckert’s RQS require the back- ground theory to use a set of predicates disjoint from the set of predicates for general relations. ’ CLP has the additional restriction that the kernel logical formulation must be a Horn set. In contrast, Stickel’s theory resolution has no general restriction on the language of background theory; and there exist certain similarities between Stickel’s total wide theory resolution ( [ 28, Lemma 71) and a special version of our typed deduc- tion (TP-first deduction). The difference is that theory resolution requires an immediate solution of the unsatisfiability of some subclauses (constraints) in the entire background theory in each theory resolution step. For our typed deduction, such a solution can be postponed. The remainder of this paper is organized as follows. Section 2 introduces the typed first-order language. Section 3 presents a least Herbrand model for a typing theory, and based on this model proves the typed Herbrand theorem. Section 4 presents the typed resolution principle. Section 5 presents TP-second deduction and proves its completeness. Section 6 discusses issues about the refinements of typed resolution. Section 7 presents a summary of some results obtained by a computer implementation of a typed theorem prover. Section 8 concludes this paper. 2. The typed first-order language 2.1. Basic definition The typed language introduced here is an ordinary first-order language expanded with a set of special constructs associated with type relations. The language contains the usual function and predicate symbols, variables, and logic connectives of a first-order language. The set of special constructs consists of type descriptions (TD), typed quantifiers, type restrictions (TR), typing rules, and typed clauses. A TD (type description) is an atom of form t: r, where “:” is a special symbol of the language, and t and r are both terms of is a conjunction of TDs. Typing rules and typed the language. A TR (type restriction) clauses are normal forms of the language to be defined soon. There are two kinds of type quantifiers V( X: 7) and 3 (x: 7) , which are used as abbreviations of certain language components according to the following rules: for every formula 4 of the language, V(x:7)(4) =V(x)(x:7*4). 3(x:7)(+) =3(x)(x:rAr$). Semantically, a form t: T usually has an intuitive meaning that t is of type r. (The word “type” in this paper is a synonym of the word “sort” of the sorted predicate ’ Thgequality predicate is an exception for RQS, where it is used as a constraint predicate. See [71 for detail. lie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 165 t and T can be any terms; calculus.) But syntactically, T are terms that must be interpreted by such semantics. there is no restriction that t and 2.2. Typing rules and typed clauses Similar to the design of efficient proof procedures clausal normal cedures normal forms will play a fundamental role in developing for typed predicate calculus. For our typed language, we define forms. One is called a typing rule, and the other is called a typed clause. for untyped predicate calculus, efficient proof pro- two kinds of Definition 2.1. A typing rule is a formula of form D/H/R, where D is a TD, R is a TR (a conjunction (i.e. literals whose atoms are not ‘IDS). H is called the general condition of the typing rule. of ‘IDS), and H is a conjunction of literals on general relations Semantically, a typing order formula, R + use true for the empty conjunction, DJJR for DJtrueJtrue) is equivalent rule D/H/R to the universal closure of the first- (H + 0). The following are some examples of typing rules. (We and D for DJtrueJR, DJH for DJHJtrue, I. 2. 3. 4. 5. 6. 7. 8. 9. x + y: intJ Jx: int A y: int x + y: reaZJJ( x: real A y: int) V (x: int A y: real) V (x: real A y: real). concat(x,y):seq(cu)JJx:seq(a) Ay:seq(a) size(x) : intJ Jx: seq( a) size(x) : intJJx: set(a) x: stringJJx: seq( char) x: seq( char) J/x: string x: small-int/ - 100 < x A x < 100/x: int x: weekendlx E {Saturday, sunday} 10. Jirst( x) : a/x # [ ] lx: seq( a) 11. M(x): real/O < x A x < 9/x: int 12. div( x, y) : intJy # OJx: int A y: int 13. div( x, y) : stringly = OJx: int A y: int 14. 15. 16. reduce{ op, S) : CY J Jop: CY x (Y -+ CY A S: set(a) image( f, S) : set( p> JJf: LY --f p A S: set(a) *:int x int + int Rules 1 and 2 indicate that + is overloaded. Rule 2 is used to represent three individual rules (i.e., a conjunction function polymorphic [ 2 11. Rules 4 and 5 indicate of three typing rules). Rule 3 indicates typing a polymorphic (parametric) string and seq( char). Rule 8 is an axiomization for an enumeration type. Rule 10 is a typing 11 is a type specification that concat is and relation between of a subtype of integer. Rule 9 is given first. Rule rule for the partial for an array M of reals. If division by zero is handled by [ 91. Rules 6 and 7 specify a type equality that size is both overloaded function 166 lie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 such as rule 16. A collection of typing that returns an error message can be formulated by rules 12 and 13. A meta-function an exception mechanism division function that takes functors as arguments. The functions 15 are meta-functions. functors for the is a function reduce and image given in Rules 14 and The typing rules for meta-functions make use of typing rules for then the typing string, rules a typing is called a typing theory. In the practical application theory may consist of three sources of typing to rules. One is of rules for data types and functions. The third is a set of typing rules for Skolem language. The second is an axiomatization rules, say, a basic is a set of typing theory, which typing program analysis, a set of basic typing the type system of the programming the user-defined functions created by normalization of the input formulae. For a given typing of elements llT[l to denote instances TDs, and TITD = {d//r iff T = /Tll = TITD. theory T, we shall use (T)Rr to denote of T, T1 TD to denote the entire set of ground set of the restriction typing of T in the entire rules of T. Symbolically, I d//r E T}. Clearly, T is nonconditional the set of nonconditional I d/h/r E T}, and /lTjl = {d//r Definition 2.2. A typed clause literals on general the kernel and the type restriction of the clause, respectively. relations, and R is a TR (a conjunction is a formula of form K/R, where K is a disjunction of of TDs). K and R are called first-order procedures formula F into normal each clause of S into a typing a typed form, we first transform F To transform into an ordinary formula F’ by replacing every V(x: r) (4) and 3(x: r) (4) of F with V(x) (x: r =+ 4) and 3(x) (x: r A q5), respectively. Then we use the standard Skolem- to transform F’ into a set S of ordinary clauses. ization and normalization Finally, we transform rule or a typed clause according to its syntax. There may be some cases in which a clause cannot be transformed typing rule, nor a typed clause is outside of the scope of this paper. Frisch presents mation system, which can avoid the introduction functions under certain assumptions, typed formulae rules and typed clauses. into a (e.g. a: ri V b: 72 V a = b) . How to deal with such cases form transfor- typing rules for Skolem some of those into a set of typing form which cannot be directly converted and may be useful for transforming in [ 141 a normal of conditional into normal 2.3. Relations to some other languages The typed language, as described above, is close to Frisch’s sorted language is a first-order in the structure of the sorted sublanguage: [ 13,141. SFOPC is more specific bols from ordinary non-logical a distinction schema of typed deduction procedures, but not with concrete algorithms soning; only essential. (SFOPC) language with sorted syntax sugar. However, SFOPC sort sym- language of this paper, such is because here we are concerned mainly with the for type rea- is symbols used for specifying the restriction on predicate symbols. For the typed is unimportant. it distinguishes type relations This Tie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 167 typed to incorporate sorted We wish to point out that in order to have efficient algorithms for type reasoning, results from previous sublanguages must be studied specifically. For this study, it is possible existing research unification [ 111, and Frisch’s etc. [ 3 I] for a forest sort structure, Cohn’s sorted logic and sort array computation tree structure, [ 141 for monomorphic in sorted deduction, such as Walther’s sorted unification algorithm Our typed language is a form of constraint first-order system language, which (RQS) is close to some notions restricted quantification (i.e. C//R) the language of Biirckert’s we have borrowed be viewed as a restriction considering made by RQS is more general: RQS permits any theory of constraints; set of models can be the models of a non-Horn theory of RQS expanded with general the exclusion of general predicates, the approach theory. [ 7,8]. In particular, theory can relations. Without resolution for example, the from RQS. Actually, a typing to constrained 2.4. Examples We now present a number of examples These examples will show that conditional a typed formula will be presented later. into normal form. A summary of computer solutions to demonstrate the use of our typed language. typing rules play a key role in transforming for these examples Example 2.3 (VKD-T). This example verification of a computer program. The theorem states that, given of them are valid key data (vkd), must also be a valid key data. With our typed language, then they can be concatenated is a typed from two strings, the formal if both together and the result is formulated theorem obtained the theorem as Y(x:string,y:string)(vkd(x) Avkd(y) =+ vkd(concat(x,y)), where vkd is defined by V( st) (vkd( st) = (St: string) A Y( ch: char) (ch E st * (#2 < ch A ch 6 #7) ) ) . The entire set of clauses obtained theory * of the program domain (a, b and k are Skolem symbols). the the from the denial of the theorem and from language consists of 5 typing rules and 10 typed clauses 1. concat(x, y) : string//x: string A y: string 2. 3. z : string/vkd( z ) k(z): char/~vkd(z)/z: string 4. a: string 5. b: string * The domain theory contains actually several hundreds of rules (typed clauses). 168 ‘lie-Cheng Wang/Arti$cial Intelligence 75 (1995) 161-194 6. -vkd(z) v 7(x E z) v (x <=#7)/x:char 7. 8. -vkd(z) V 1(x E z) V (#2 <= x)/x: char v/d(z) V ~(#2 <= k(z)) V 1(/c(z) <=#7)/z:string 9. vkd(z) V (k(z) E z)/z:string 10. (x E concut( u, 0) ) V 1(x E u)/x: char A u: string A u: string 11. (xEconcut(u,u))V~(xEu)/x:churAu:stringAu:string 12. (x E u) V (x E u) V (7x E concut(u,u))/x:churAu:stringAv:string 13. vkd(u)/true 14. vkd( b) /true 15. 7vkd( concut( a, b) )/true Clause 1 is a typing by normalizing the definition are typed clauses lo-12 Clauses < and concut can be overloaded operators, adding soundness of these rules. Note that clause 2 is a conditional demonstrates typing rules may be produced if the background rule for the operator concut. Clauses 2-3 and 6-9 are obtained them, clauses 2 and 3 are typing rules. from axioms about concut. Since both is important to the typing rule. This example for proving a theorem, even of vkd. Among transformed that conditional typing is nonconditional. type restrictions theory translation theorem AM8 for the minimum is the well-known The original example a set of TDs for specifying them, x:xpt means Example 2.4 (AM&T). formulated by Bledsoe AM8-T given here is a direct contains Among means closed interval model of this translation. AM8-T consists of a basic typing kl-k5, two typed clauses b,, b2, and a typed formula Fo. (maximum) of AM8 the boundary [34] value theorem from real analysis. to a typed language. This language in the theorem. f, y:fpt that x is a point of the for an intuitive rules in the range of f, and x: dpt means [a, b] in the domain off. The reader may refer to [34]] in the domain of the function theory of five typing that x is a point that y is a point conditions stated Fo: 3( 1: dpt) (Wx:xpt)(u<xAx<Z+f(l)<f(x))) AWx:dpt)W(y:xpt)((u<yAy<xx.f(x) <f(y)) +xxO) A v’(w: W (3~: 44 ( f(y) < f(w) A W,(x: dpt) (f(x) 6 f(w) * Y < xl 1) 1 * 3(u:dpt)(V(t:dpt>(f(u) <f(t))). The set of clauses obtained by normalizing Fa consists of four typing and six typed clauses b3-bg. Each of k6-kg corresponds during the normalization. to a Skolem rules, k6-k9, created function Ee-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 169 kl. a:xpt k3. x: dpt/a 6 x A x < blx:xpt k2. b:xpt k4. x: xpt//x: dpt kg. f(x):fpt//x:dpt kg. 1:dpt kg. h(x) : dpt//x: dpt k7. k(x): dpt1l.x: dpt kg. q(x):xpt/x < l/x:dpt bl. a < x/x:dpt b2. x 6 blx:dpt 63. f(l)< f(x)Va~xVx~l/x:xpt 64. x < 1 V q(x) < x/x: dpt bs. x<lVa<q(x)/x:dpt be. x < lVf(x) d f(q(x))/x:dpt b7. bs. h(w) <xv f(x) < f(w)/x:dptAw:dpt bs. f(u) With the typed language, the set of inequality axioms for AM8-T are given as follows. (standard) typed clauses, K/RI,. . . , K/R,.) (Note that a clause of form K/R* V . . . V R, f(h(w)) 6 f(w)lw:dpt d f(Wu))lu:dpt is also typed, which is treated as n’s aI. a2. ax. x < x/x: xpt v x: fpt x<yVy<x/(x:xptAy:xpt)V(x:fptAy:fpt) x~yVy~zVx~~/(x:xptAy:xptAz:xpt)V(x:fptAy:fptAz:fpt) a4. xgYVygxVf(x) <f(y)/(x:xptAy:xpt) Example 2.5 (Z%!LS-7’) . The set of clauses given below typed language, we have divided Clearly, using shown the theory and a set of typed clauses. the typed language adds to the clarity of the representation. As it will be for deriving a refutation. is unsatisfiable. With later, it also improves the set into a typing the efficiency 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. a:$xnum b:,fixnum x: int//x: nut x: nut/O 6 x/x: int x: nat/lx:$xnum x:,fixnum/x 6 100/x: nut x + y: int//x: int A y: int int A y: int x - y: int//x: plus(x, y): finumll minus(x, y): finum//x:Jixnum .P x. xnum A y:jixnum A x + y:fiwnum A y:jixnum A x - y:fixnum 11. x<yAy<z =+x 6 z/(x:intAy:intAz:int) V (x:realAy:realAz:real) 12. plus( x, y) = x + y/x:Bxnum A y:finum A x + y:finum 13. minus( x, y) = x - y/x: fixnum A y:mum A x - y: fixnum 14. x + (y -x) = y/(x: intV x: real) A (y: intV y: real) 170 lie-Cheng Wang/Art@cial Intelligence 75 (1995) 161-194 15. 16. 17. yqx*o< (x-y)/( x: int V x: real) A (y: int V x: real) x < x/(x: int) V (x: real) 0 < x/x: nut 18. x 6 1OO/x:Jixnum 19. 0 Q a 20. 0 < b 21. 22. a<b plus( a, minus( b, a) > # b/true 3. The typed Herbrand theorem theorem one to reduce to the satisfiability of the set of ground is the basis of resolution-based to the search of an unsatisfiable of a set of clauses thus permitting Herbrand the satisfiability of these clauses, of clauses pose is to develop efficient deductive procedures instead of starting procedures Herbrand typing the theory. This section proof methods. This theorem relates instances of the set instances. Our pur- for typed predicate calculus. However, existing deductive them by extending calculus. For this extension, we need a typed version of the in the given in the satisfiability of untyped to developing theorem which relates to the satisfiability logical consequences such a theorem. from scratch, we will develop the proof of unsatisfiability of a set of typed clauses subset of these ground of these clauses of predicate is devoted theory two notations We introduce for the following discussion: l U[ TD] : the entire set of ground TDs of the language, l U [ KA] : the entire set of ground (kernel) atoms on general relations of the language. Note that U[ 7”] U U[ KA] is the Herbrand base of the language. 3.1. The least Herbrand model of a typing theory We start from the study of a special Herbrand model, called the least Herbrand model of a typing theory. Definition 3.1 (Ground ro be a ground TR (type restriction). r-0 in T is denoted by gtp(T, ro), where typing precondition-gtp). The set of ground typing preconditions Let T be a typing theory, and let (gtp) of gtp(T, ro) = { hl A . . . A h, 1 {dtlhlrl,... ,&/hnlrn) {4//r19. . . , &l/r,, vo} c Vlgr ad is minimally unsatisfiable}. Definition 3.2 (Weakest ro be a ground TR. The expression wtp(T, r-0) defined below is called a weakest precondition typing precondition-wtp). (wtp) of r-0 in T: Let T be a typing theory, and let typing Ee-Cheng Wang/Art@cial Intelligence 75 (1995) 161-194 171 w~p(l;ro) = v (WI. WEgtpKro) Intuitively, a gtp of ra in T is a precondition under which ra is implied by T, and the wtp of ro in T is the weakest precondition under which re is implied by T. Example 3.3. Let do,dI, d2,. . . be each a ground TD (i.e. a member of U[TD]), let {PO,PI,P~, relations). and (i.e. a subset of ground atoms on general . . .} b e a subset of U[KA] Let TI ={4,ddm,&Jm ~~2Jdltd4Jw A~p2,d4/~3Jd,,d6JJd5}. (We use [7 for empty disjunction, results. the following and use true for empty conjunction.) Then we have @p(Tt , dl) = {true}, gfp(Tl 9 6) = {PI}, wtp(T~ , dl ) = true, wtp(Tl,d2) =PI, @pUi 9 4) = (~1 A ~21, wqdTl,d3) =pl Ap2, gWi 3 4) = (~‘1 A 7p2$3}~ wtpUl,4> = (7~1 A -PZ) vp3, gfp(T 7 ds) = 6 wtp(Tl,&) =O. Proposition 3.4. Let L be a typed language, and let T be a typing theory. For every is logically equivalent to wtp(T, el) A e, of ground TDs, wtp(T, el A . * . A e,) el,..., . . A wtp(T, e,). such that [ wtp(T, el A . . s A e,)] M = true. 3 From such that [g] M = true. such that To c (T)gr unsatisfiable. Then for each j, 1 < j < k, there Proof. Let A4 be an interpretation, Definition 3.2, there exists a member g of grp(T, el A .. . A e,), 3.1, there exists To = {dl/hl/rl,. From Definition V. . . V Te,} and TaU{lel is minimally exists Tj = {djl /hiI /rjl , . . . , djk/hjk Jrjk}, unsatisfiable. Let gj = hji A. . .A hjk. The gj C gtp( T, ej) . From [g] M = true, and the fact that gj contains only conjuncts of g, we conclude [w@(T,ej)lM = true. Hence wtp( T, el A . . . A e,) entails wtp( T, el ) A . . . A wtp( T, e,) . is similar. We leave it to the reader. 0 The proof for other direction of the equivalence that [gjlM = true, and consequently such that Tj C To and Tj U{Tej} . . , dk/hk/rk}, is minimally For every typing theory T and every Herbrand a special Herbrand model for T, called a B-based interpretation B on I!/[ KA] , we define least Herbrand model of T. Definition 3.5 (Least Herbrand model). Let T be a typing of U[KA], let theory. For every subset B A4; = {d E U[TD] 1 [wtp(T,d)lB = true}. Then B U MT” is called the B-based least Herbrand model of T. 3 In this paper, we use [e] M to denote the truth value of e in M for every formula e and every interpretation M. 172 Tie-Cheng Wang/Artificial Intelligence 75 (1995) 161-I94 Example 3.6. Herbrand model of Tl for different values of B in the following the set T, given in Example 3.3, we present For table. the B-based least B 0 {PII {PI.PZI IP33 G, (4, d4) {dl7&) BUM;, {dl.d4) {Pl.~l~~Z) {(tlsdZ.d3) {pl>p2~dl.~2.d3} {dl. d4) {P3rdl,d4) {PI.P~,P~) {d1.&,d3.d4} (pI,p2,p3,dl,d2.d3,d4} 1. 2. 3. 4. 5 _ B [Trl B”%, true true true true true The significance of Definition 3.5 is justified by the following theorem. Theorem 3.7 (Least Herbrand model subset B of U [ KA], De$nition 3.5, is indeed a model of T. the B-based theorem). Let T be a typing theory. For every least Herbrand model of T, B U I@, defined in that from [dj]@ of Mf, = true. Then there exists a set Tj C (T),,, Tj = {dj,/hj,/rj,, that I = B U MT” is not a model of T. We are going the definition 3.1, there exists at least one element gj of gtp(T,dj) which to deduce a Proof. Assume contradiction from this assumption. Since I is not a model of T, then there exists at least one member do/h/d, A. . . Ad, of (T),, which is false in 1. Then we must have [do] ’ = false, [ h] t = true, and for every j, 1 6 j < n, [ dj] ’ = true. Since dj 6 B, [ dj] ’ = true [ wtp(T, dj)lB = true. implies From Definition is true in B. Consequently, such that gj = hj, A . . . A hjk, and TjlTn U {ldj} unsatisfiable. Let To = Tl u . . . u T,, u {do/h/d1 A . . . A d,}. TO]TD U { Tdo} must be unsatisfiable. Let TA = {d’/h’/r’, Then g’ = h’ A . . . A h” must be a member of gtp(T, do), and hence a unsatisfiable. disjunct of wtp(T, do). However, each conjunct h’ of g’ must be either h (if h’ comes from do/h/d, A. . .Ad,) or a conjunct hji of gj for some j, 1 6 j < n, jl < jt < jk (if h’ comes from an element of Sj) . For each case, it is easy to determine [ h] B = true, and so that [g’] B = true. Since g’ is a disjunct of wtp( T, do), [ wtp( T, do) ] B = true. we conclude the earlier assertion Consequently, that [do] ’ = false. [do] t = true. This result contradicts be a subset of To, such that T;]T~ U {ldo} . . . ,dj,/hj,/rj,}, . . . ,dS/hS/rS} is minimally is minimally do E @, and il 3.2. The typed Herbrand theorem Lemma 3.8. Let T be a typing theory, and let SO be a set of ground typed clauses. So is iff the set SW = {KV Twtp(T, R) 1 K/R E SO, T-unsatisfiable (i.e., TUSc is unsatisjable) wtp(T, R) SO} is unsatisfiable. that S, is satisfiable. Let B be a Herbrand model of S,. Since S, Proof. Assume that B is a subset of U [ KA] . Let I = B U MT”, where contains no TDs, we can assume MF = {d E U[TD] 1 [wtp(T, d)lB = true}. By Theorem 3.7, Z is a model of T. Let K’/R’ be an arbitrary element of SO. We now show that K’/R’ is true in I. Assuming Tie-Cheng Wang/Art$cial Intelligence 75 (1995) 161-194 173 [R’] t = true. Since B is a model [K’ V ywtp(T R’) 1’ = true. Then [ wtp(T, R’)]’ = [ wtp(T, R’) ] B = false. Since . . A d,, for some TDs dl, . . . , d,,. By Proposition that [K’] ’ = false, and [K’] ’ = false, we conclude [K’ V lwtp(T, R’)] B = true. Consequently, [ K’IR’] t = false, we must have of S,, from R’ is a ground TR, then R’ = dl A 3.4, wtp(T, R’) = wtp(T, d,) A . . A wtp(T, d,). Then [ wtp(T, dj)] B = false. Hence, of TDs of R’ is disjoint [R’] ’ = false, which contradicts K’/R’ must be true in 1. Note that K’/R’ be a model of So. We have noted earlier model of T U So. This result contradicts the definition from B, dj # MF implies the assertion the hypothesis from there must exist a dj of R’, the set of h4;, dj $ h4;. Since that [ dj] t = false. Consequently, that [R’]’ = true derived earlier. Therefore I must I is a from SO. Then that I is also a model of T. Therefore is chosen arbitrarily that SO is T-unsatisfiable. On the other hand, since each element of S, is a logical consequence of T U SO, if S, cl then SO must be T-unsatisfiable. is unsatisfiable, Definition 3.9 (Gtp-descendant) . Let T be a typing clause. A ground clause C’ is called a gtp-descendant ground g = true, then C’ is called a proper gtp-descendant of K/R in T. instance K’IR’ of K/R and a gtp g of R’ in T, such theory, and let K/R be a typed of K/R in T iff there exists a that C’ = K’ V Tg. If Example 3.10. Consider 3.3 and a clause K/d1 A d2 A d3. Note that PI A p2 is a gtp of dl A d2 A d3 in Tl. Then for any ground instance Kr of K, K’ V 1~1 V 7~2 is a gtp-descendant of K/d, A d2 A ds. Now consider the clause K/d,. Since wtp( T’, dl ) = true, K’ is a proper gtp-descendant theory Tl given in Example the typing of K/dl. Theorem 3.11 (Typed Herbrand Let T be a conditional typing theory, and let S be a set of typed clauses. S is T-unsatisjiable i# there exists a finite unsatisfiable set S’ of gtp-descendants of clauses of S in T. theorem). theorem, S is T-unsatisfiable lwtp(T’, R’) ) K’/R’ E S’} is unsatisfiable. To complete to the Herbrand instances of clauses of T and a finite set S’ of ground iff there exists a finite Proof. According instances of set T’ of ground iff the clauses of S such that St is T’-unsatisfiable. By Lemma 3.8, S’ is T’-unsatisfiable the proof of the set S, = {K’V theorem, we now need only to show that S, is a finite set of gtp-descendants of clauses of S in T. Note that T’ is finite. Then for each ground TR R’, gtp(T’, R’) is finite, and then wtp(T’, R’) must be a disjunction of a finite number of gtps. Then, by Definition 3.9, each K’ V -wtp( T’, R’) of S, stands for a finite set (or say, a finite conjunction) of gtp-descendants set of gtp-descendants that S’ is finite, S, must be a finite of K/R in T. Therefore, given of clauses of S in T. 0 3.3. Remarks Remark 1. The set of clauses contained conditional Horn set (cHs) . Let L be a first-order L, which to R iff the restriction of S on R, SIR, is a Horn set. A typing theory forms a special class, call language. Let R be a set of atoms of is called a cHs with respect is a special form is closed under substitutions. A set S of clauses in a typing theory 174 lie-Cheng Wang/ArtQicial Intelligence 75 (1995) 161-194 of cHs, which is a cHs with respect theorem, Theorem 3.7, can be generalized to any cHs [ 351. to the entire set of TDs. The least Herbrand model It is well known set of ground atoms consistent with this classical that can be deduced result in the following from S [ 301. We claim sense: that each Horn set S has a least Herbrand model, which equals the that Theorem 3.7 is Proposition 3.12. If T is nonconditional, then for every Herbrand interpretation B, the set MT” = {d E U[ TD] 1 [ wtp( T, d) ] B = true} given in Theorem 3.7 is exactly the least Herbrand model of T: {d E U[ TD] 1 T b d}. Proof. It follows immediately from the following proposition. cl Proposition 3.13. If T is a nonconditional typing theory, then for every d of U[ TD], wtp( T, d) = true ifs T k d; and wtp( T, d) = 0 iff T k d. Consequently, for every Her- [ wtp( T, d) ] B = true ifs T b d, and [ wtp( T, d) ] B = brand interpretation B on U[ KA], false iff T k d. then if T b d, gtp( T, d) must contain Proof. If T is nonconditional, the empty clause true, and so wtp( T, d) = true. If T k d, then gtp( T, d) must be empty, and so wtp( T, d) = q . On the other hand, then then wtp(T, d) = q , and wtp(T, d) = true, and so T + d. If [wtp(T, d)] B = false, gtp(T, d) = 4. So T p d. 0 if [wtp(T, d)] B = true, then since T is nonconditional, sorted Herbrand Remark 2. For nonconditional Frisch’s that for every set 2 of nonconditional set cr of typed clauses is the set of those ground to 2. According in typing theorem given theory, our typed Herbrand [ 131. The sorted Herbrand to states typing rules (i.e., S-sentences of [ 131) and every iff CX~~, is, where ag, instances of members of (Y that are well sorted with respect LY U 2 is unsatisfiable is similar theorem theorem (i.e., R-sentences), to our Lemma 3.8, (Y U 2 is unsatisfiable iff S, = {K V lwtp( 2, R) 1 K/R E ( CX)~,. A wtp( 2, R) $0) Since 2 is nonconditional, 3.13, wtp( 2, R) $ Cl, iff 2 k R, and iff wtp( 2, R) = true. Then for each element of S,, we have K V -wtp( 2, R) = K. Hence S,,, = {K 1 K/R E ( LY)~~ A 2 k R}. Then by the definition of a~~,, S, equals “4,. by Proposition is. We now show S, = ‘~4,. A general version of the Herbrand theorem does not require in [ 7,8]. This a Horn set. The sorted Herbrand the restriction on Horn sets to a certain extent. However, limited It may be an interesting these existing Herbrand theorems becomes a special case. topic to develop a super Herbrand in the applicability to those constraint theorem with constraint that the underlying theorem described by Frisch theory is given by Biirckert constraint theory must be [ 141 also releases in theorems are these Herbrand theories that contain no general predicates. theorem of which each of i’Ze-Cheng Wang/ArtQicial Intelligence 7.5 (1995) 161-I 94 175 4. The typed resolution principle theory T and a T-unsatisfiable Given a typing of T U S by applying (recall five kinds of binary clause, and a formula of form D/H/R the classical resolution set S of typed clauses, a refutation proof resolution principle may require all of the following a typed that a formula of form K/R represents represents a typing rule): too much redundancy, for our typed calculus, and Dz/Hz/R2 upon D2 and a literal of --IRI; and Dz/Hz/Rz upon literals of lH1 and yH2. resolution of KI /RI and Kz/Rz upon literals of KI and K2; resolution of KI /RI and D/H/R upon D and a literal of lR1; resolution of KI/RI and D/H/R upon literals of K1 and -H; resolution of DI/HI/RI resolution of DI/HI/RI ( 1) binary (2) binary (3) binary (4) binary (5) binary to use. Not only may Clearly, but they may also create some problems which they contribute are difficult since the third and fourth kinds of resolution may produce a resolvent which is a typing rule, they will force us to deal with a changeable typing it may a resolvent of the form Di V D!JH’IR’, where Di and 04 are both TDs, produce which these kinds of unwanted in this section a special version of the resolution principle, second kinds of binary is neither a typed clause nor a typing resolution, we introduce the typed resolution principle. This principle will use only the first and theory. The use of the fifth kind of resolution rule. In order to avoid using some of these are not good to handle. For instance, troublesome: resolution. is more called Definition 4.1. Let T be a typing and K/R a typed clause. R is called T-acceptable iff T~TD k 3(R); R is called T-provable iff ljT[l k 3(R). K/R is called T-acceptable iff R is T-acceptable (T-provable). theory, R a type restriction, (T-provable) The kernel resolution defined below is close to the RQ-resolution rule of [ 71. Definition 4.2 (Kernel resolution). Let K1 /RI and Kz/Rz be two typed clauses con- in common. Let Li be a literal of K1, and & a literal of K2. If taining no variables L1 and lL2 are unifiable, (mgu) of L1 and 7L2, then (K~\L~)B/(RI A Rz)B is called a binary kernel resolvent (BKR) of KI/R~ (Kl\Ll)BV and K2/R2. and 6 is a most general unifier to the factoring Similar is an inference or two or more TDs of R have a mgu CT, then Kc/Ra called a factor of K/R. As was mentioned problem proof procedure. This remark applies also to our typed resolution. rule for an ordinary clause, factoring for a typed clause K/R rule which deduces factors from the clause. If two or more literals of K, obtained by applying u to K/R is is often not used in actual of a the completeness solving, but it needs in [ 401, factoring to be incorporated for establishing Let Cl and C2 be typed clauses. A kernel resolvent of Ci and C2 is a BKR of Ci and C2, a BKR of Ci and a factor of C2, a BKR of a factor of Ci and C2, or a BKR of a factor of Cl and a factor of C2. 176 Tie-Cheng Wang/Art@cial Intelligence 75 (1995) 161 -I 94 Definition 4.3 ( TP-resolution) . Let Kt/Rt be a typed clause and let dt be a conjunct of RI. Let D/H/R in common with Kl/Rl. If dt and D are unifiable, and 0 is a mgu of dt and D, then Kt0 V 7HB/( Rl\dl and D/H/R is called a TP-resolvent steps starting upon dt. from a typed clause will be called a rule that contains no variables of TP-resolution A sequence be a typing of KI/RI )O A RB TP-deduction. Definition 4.4 ( TP-descendant, TP-deduction) . Let T be a typing theory, and let Ka/ Ro in T iff is called a TP-descendant be a typed clause. A typed clause K,,/R, . . , K,,/R,,, such that for each i, 1 < i 6 n, there exists a sequence D: Ko/Ro, Kl/Rl,. Ki/Ri from Ko/Ro in T. D is called a TP-deduction of K,/R, is a TP-resolvent in T. of Ki_1 /Ri_1 of Ko/Ro Our typed resolution principle consists of two deduction and TP-resolution. With this principle, we can propose a general version of typed deduction, TPO deduction, by the following definition. rules: kernel resolution Definition 4.5 (TPO deduction). clauses. A finite sequence D: KI/RI, Kz/Rz,. deduction of K/R from S in T iff each Ki/Ri Let T be a typing is theory, and let S be a set of typed is called a TPO (= K/R) . . , K,,/R, ( 1) a clause of S, or (2) a T-acceptable (3) a T-provable TP-descendant A TPO deduction of n/true kernel resolvent of two typed clauses of D preceding Ki/Ri, or of a clause of D preceding Ki/Ri. from S in T is called a TPO refutation of S in T. The process of verifying if a kernel resolvent is T-acceptable or T-provable is called that a kernel resolvent be T- (TPO in our typed deduction procedures be T-provable type-checking. We need to point out that the requirement acceptable and a TP-descendant deduction and those to be defined flexibly. In one extreme, be applied and implemented This argument has been made in the constrained it can be abandoned In between, flexibly by choosing different to each resolvent. later) is optional. Type-checking can be implemented In the other extreme, completely. it may be applied it may to a subset of resolvents, levels of reasoning and resource bounds. resolution literature (see [ 8,161). Example 4.6. Let T4., = { tl , t2, t3, t4) be a typing be a set of typed clauses. Prove that $1 is T4.t-unsatisfiable. theory, and let S4.t = {ht , h2, h3, h4) tl. t2. t3. t4. a:E a: P hl. s(x,f(x>> V v(x>/x: E h2. c(f(x)) v u(x)/x: E f(x): Q//x: E x: Pls(a,x)lx: Q h3. h4. +x)/x: P lC( x) lx: P First, we deduce a TP-descendant cl of h4 and a TP-descendant CT of h3. (We shall use TP and KR to stand for TP-deduction and kernel resolution, respectively.) i?e-Cheng Wang/Artijicial intelligence 75 (1995) 161-194 177 Cl. -(f(x>> v-(a,.f(x))/x:E (p. h4vt4,t3) ~2. -(f(x)) v -(a,f(x>>/x:E (‘II’. h3,t4,t3) Then, we deduce four kernel resolvents, C3-Cg, by kernel resolution, and finally, deduce the empty clause from Cg by TP-deduction. c3. q. c5. s(n,f(x))/x:EAx:P c(f(x)>/x: EA x: P -s(a,f(x))/x:EAx: P c6. n/x: E A x: P cl. U/true (I= hl,h3) h2vh3) (=. (KR. c4,c1) (m. c5,c3) (p. C6,tl,t2). Note that for nonconditional typing theory T, a typed clause is T-acceptable iff it is that TP-deduction is found once a T-provable kernel-empty can be replaced completely by type-checking, resolvent T-provable. This means and a refutation kernel-empty similar clause is essentially special version of the completeness to Btirckert’s RQ-resolution [7], and Frisch’s theory) is a typed clause of form U/R.) the restriction (when sorted deduction a special version of the completeness resolvent is deduced. (A In such a case, TPO will be theory is given by a definite [ 141. Thus theorem the following and a theorem of RQS deduction theorem of Frisch’s sorted deduction. Theorem 4.7. Let T be a typing theory, and let S be a set of typed clauses. If T is nonconditional (i.e., T = llT[l), and if S is T-unsatis$able, then there must exist a TPO refutation of S in T. The theorem can be proved by using the refutation and by lifting formal proof to the reader. for a ground case in the conventional way. We leave the typed Herbrand theorem (Theorem 3.11) the For conditional typing theory, TPO deduction be established on the basis of the typed Herbrand given below. is also complete. This completeness can theorem, Theorem 4.7, and a lemma Lemma 4.8. Let T be a typing theory, and let K/R be a typed clause. If C’ is a gtp-descendant of K/R in T, then there exists a TP-deduction of K,,/R, from K/R such that K,,/R, is T-provable and C’ is a proper gtp-descendant of K,,/R,. Proof. This lemma can be viewed as a special case of Lemma 5.8 to be proved next section. in the 0 Theorem 4.9 (Completeness clauses, then there must exist a TPO refutation of S in T. theorem of TPO). If S is a T-unsatisfiable set of typed Proof. By the typed Herbrand gtp-descendants of S. By Lemma 4.8, there exists a TP-deduction theorem, of clauses of S in T. Let C’ E S,, be a gtp-descendant set S,, of of a clause K/R from K/R in T, such that there exists a finite unsatisfiable of Kj/Rj 178 lie-Cheng Wang/ArtiJScial Intelligence 75 (1995) 161-194 is T-provable. Since each such C’ is a proper gtp-descendant of KjlRj in T, and Kj/Rj TP-deduction consists of only a finite number of steps of TP-resolution, there must exist a deduction Dt of a set Sk from S by TP-deduction, such that each element of S,, is a proper gtp-descendant of a clause of S U Sk in T. Then S U Sk is /TII-unsatisfiable. By Theorem 4.7, there exists a TPO refutation 02 of S U Sk in [[Tll. Then the entire deduction formed by appending D2 onto the end of D1 is a TPO refutation of S in T. 0 We point out that this completeness theorem is not strong enough to support the practical use of our typed resolution principle. This is because the proof requires that one must apply TP-deduction first to derive a set of consequences that is unsatisfiable in the nonconditional subset of the given typing theory. This process is called weakening. (However, our use of “weakening” may be in a different sense from the use in a sorted calculus literature, such as [ 331.) A TPO deduction with weakening is called a TP-jrst deduction. It has been known that weakening may be very inefficient because, in general, there exist no criteria, except the final derivation of the empty clause, by which one can decide when the TP-deduction phase should be terminated; but during weakening, many useless TP-resolvents may have to be deduced. The TP-descendant c2 of h2 in Example 4.6 is such a redundant TP-resolvent. Assuming there exist in T4.1 additional N conditional typing rules, {do: P/~/Q,. . . , 4: P/h/r,}, since each of them can be used to contribute two TP-descendants (one with h3 and the other with h4), there will possibly be additional 2N TP-resolvents generated. It turns out that the general TP-deduction may be inefficient when it is used in the earlier stages of a proof; we should delay the application of the general TP-deduction if this is possible. The TP-second deduction to be presented next is motivated by this consideration. 5. TP-second deduction 5.1. Basic definitions We first introduce a special form KI P/R for a typed clause, called a divided typed clause. KIP is called a divided clause; and K and P are called the left-kernel and the right-kernel, respectively. Semantically, K/P is the same as a standard clause K V P. However, for a standard clause, we assume that it contains no duplicated literal occurrences. That is, K V P indicates a clause obtained by removing each literal of P which has an occurrence in K (i.e. merging right). For a divided typed clause KI P/R, we assume only that there exist no duplicated literal occurrences within the subclauses K and P, respectively. But K and P may share some literal occurrences. Note that, because R is a type restriction, 1R cannot share a literal occurrence with K or P. Correspondingly, a factor of a divided clause KIP/R is obtained from an instantiation KOlPe/RO of the clause by merging the same literal occurrences in K8 and in P0, respectively. Such a factor is called a divided factor. Tie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 179 the left-kernel from, a kernel (general) Normally, or inherited is used typed clause for simplicity). to hold inherited from an input set will usually be in the form KID/R relations A kernel-empty clause and is used to hold relations contained in, from the right-kernel the typing (i.e., P of KIP/R) theory. Thus, a divided (written by K/R its TF’-descendants will be in the form (i.e. K of KIP/R) formulation, whereas 01 P/R. Why do we use divided typed clauses ? Note that the general relations contained typing from kernel theory will be hidden in the underlying inherited by the kernel of a TP-descendant TP-deduction will have the side effect of restricting general we need to keep track of these relations special Divided clause they are the use of the reasoning associated with these In order to avoid the proof failure possibly caused by this side effect, for a proof, and use in the course of searching to deal with the deduction on these relations. is introduced here partly for this purpose. through TP-deduction. Restricting rules or control strategies resolution relations. inference until Why are the subclauses K and P of a divided to share the same literal occurrences? This is because a literal L of the clause P may stand for a theory by TP-deduction. Before the inheritance, L literal to be inherited is implicit, into K even if K contains an occurrence L. Of course, when L is explicitly presented, L can be removed by merging. But this merging needs to be considered typed clause KIP/R allowed instead of a default operation. so cannot be merged from the typing as a refinement, Definition 5.1. Let T be a typing divided typed clauses of KlIPl/R 1 and K21 P2/R2 theory, and let KI IPl/Rl and K~[Pz/R~ be two in common. A binary kernel resolvent the in T is a form KI P/R defined by considering that contain no variables (Bm) following three cases. (1) L1 E Kl, L2 E K2, 8 is a mgu of L1 and 1L2, K = (Kl\Ll)O V (Kz\Lz)B, P = (P, V P2)e, and R = RIB A R20; (2) LI E Kl, K2 = 0, LZ E Pz, 8 is a mgu of LI and 7L2, K = (Kl\Ll)B, P=P,8v(P2\L2)0,and R=R,0AR2& (3) K1 = II, K2 = q , LI E PI, L2 E P2, 0 is a mgu of L1 and 7L2, K = 0, P=(P~\L,)BV(P2\L2)6,andR=R1BAR28. Let Ct and C:! be divided Cl and C2, a BKR of Ct and a divided and C2, or a BKR of a divided typed clauses. A kernel resolvent of Ct and C2 is a BKR of factor of Ct factor of C2, a BKR of a divided factor of Ct and a divided factor of C2. We now extend the concepts of gtp-descendant, TF’-resolvent, and TP-descendant introduced earlier to divided clauses. Definition 5.2. Let T be a typing typed clause. A ground clause K’I W’ is called a gtp-descendant iff there exist a ground instance K’I P’/R’ of KI P/R and a gtp g of R’ in T such that W’ = P’ V Tg. If g = true, then K’I W’ is called a proper divided gtp-descendant theory, and let KIP/R be a divided of K( P/R in T. of K(P/R Definition 5.3. Let KI IPI /RI be a typed clause, and let dl be a conjunct of RI. Let in common with KI I PI /RI. If dl and D/H/R be a typing rule that contains no variables 180 lie-Cheng Wang/Artijicial Intelligence 75 (1995) 161-194 D are unifiable and 8 is a mgu of dl and D, then KIC?I(PI V TH)f?/(Rl\dl)B called a divided TP-resolvent of K~IPI/RI and D/H/R upon dl. A R8 is Definition 5.4. Let T be a typing theory, and let Ko[Po/R,J be a typed clause. A typed is called a divided TP-descendant of Kol Po/Ro in T iff there exists a clause K,, 1 P,/R,, sequence such that for each i, 1 < i < II, KiIPi/Ri T. D is called a TP-deduction of K,, 1 P,,/ R,, from Ko:,) PO/ Ro in T. is a divided TP-resolvent of Ki-1 IPi-l/Ri_l in Definition 5.5 ( TP-second deduction). of typed divided clauses. A finite sequence D: KllPl/Rl, K~~P~/Rz,. KI P/R) Let T be a typing theory, and let S be a set (= is called a TP-second deduction of KI P/R from S in T iff each KilPi/Ri . . , K,,jP,,/R, is ( 1) a clause of S, or (2) a T-acceptable kernel resolvent of two typed clauses of D preceding Kil Pi/Ri, or (3) a T-provable TP-descendant of a kernel-empty clause of D preceding KifPi/Ri. from S in T is called a TP-second refutation of S A TP-second deduction of q lO/true in T. TP-second deduction is complete and that is to be proved in Section 5.3. As was mentioned earlier, the requirement that a kernel resolvent be T-acceptable and a TP- descendant be T-provable is optional. The purpose of including them in the definition is to obtain a stronger version of completeness theorem. 5.2. Examples Example 5.6. Use TP-second deduction to solve Example 4.6. Since $1 contains no kernel-empty clause, only kernel resolution (KR) is applicable at the beginning of the deduction. We have the following kernel resolvents (note that Kin/R is written as K/R for the simplicity): PI. s(x, f(x))/x: E A x: P c(f(x))/x: P2. p3. q /x:EAx:PAf(x):P E/Ix: P (l=. (m. hrh3) h2r'+3) (KR. p2,h4) Note that p3 is a kernel-empty clause, to which TP-deduction can be applied. This will produce a TP-descendant ~4, and eventually empty clause p6. ~4. I7~~s(a,f(x))/x: EAx: P (Tp. p3,t4,t3) ps. O/a: E A a: P P6. a/true (m. P4rP1) UP. P5,fl.f2) In comparing the above derivation with that given in Example 4.6, the search space for a TP-second refutation is reduced, because only kernel resolution can be applied before Ee-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 181 p3 is deduced. There are only three kernel resolvents that can possibly be produced. All of them are useful. Note that the need of deducing a kernel-empty resolvent before obtaining finally a refutation can serve as a strong heuristic. According to this heuristic, a kernel-empty resolvent (e.g., P3 in this example) should be given higher priority to develop. Example 5.7. Use TP-second deduction to prove AM8-T given in Example 2.4. The TP-second deduction proof-tree presented below was found automatically by our typed prover in proving this theorem. We shall give an analysis of this proof-tree in Section 7. $3. g2. f(u) d f(wu))lu:dPt u 6 f(k(u)) v f(u) 6 u/r2 g3. g4. g5. g6. a. g8. f(u) x f(WUu)))/rs a X h(k(0) V h(k(0) g//r4 h(k(U) d l/r5 a 6 dh(k(l)))/r6 q(fdk(0)) < Mk(U)/r7 .f(h(k(l))) 6 f(q(h(k(l))))/r8 Given (b) KR. &Pas KR. g2,b7 KR. g3,b3 KR. g4,h KR. gsvb5 m. gsvb4 m. g5,b6 .!?9* dh(k(0)) d h(U0) vh(k(0) d dMM0))/r9 g10. 0 sf f(dh(k(l)))) vf(h(k(l))) d u/r10 at. g8,a3 g11. h(k(0) X dWU0))lnl g12. u ff q(WU0)) V h(WU) d u/r12 g13. f(dMW0))) 6 f(Q0)/rl3 814. f(Q0) 6 f(q(h(WU)))/rl4 g15. .f(MVU)) d f(U0>/m g16. n/r16 817. q b d dh(UU)) KR. g9,g7 KR. g11,a3 m. &l,b8 KFc g13va2 KR. g14vg10 KR. gl5rh V h(UU) < 1V (Wk(U)) X b/w -iI’. gl6, k3-k9 g18. q lq(MW0)) x bv h(k(0) 6 l/r18 m. g17vg6 g19. b < q(h(k(0))lh(k(0) < l/r19 KR. g18, a2, k2, k6-k9 g20 * h(k(U) d blh(k(l)) 6 l/r20 KR. gl9,&2, k2. k4, ka-k9 g21. q llMk(0) 6 l/r21 g22. Cl/r22 g23. q lh(k(l)) g24. Cl/ true KR. gzo, b2, ks-ks KR. g21vg5 < Z/true ‘II’. g22. k2, k4. k6-k9 KR. g23 9 g5 182 lie-Cheng Wang/Art@cial Intelligence 75 (1995) 161-194 The type restrictions r-2-r-22 are given bellow. For simplicity, only r2-r4 with their full expressions. The rest are given only with their simplified on the right hand of -+>, produced by a simplification described briefly results procedure TR-simplifier later). are given (those (to be ~2: f(u):fpt~v:fptAf(k(u)):fptAu:dpt --f v:jjrt A u: dpt r-3: k(u):dptA f(u):fptA f(h(k(u))):fptA f(k(u)):fptA u:dpt r-4: h(k(l)):xptA k(Z):dptA f(l):fptA f(h(k(l))):fptA f(k(l)):&tA + u: dpt 1:dpt --+ true + true r59r69rlTr8: r-9: rlo: rll: 112: 113: r14, r15, rl6: r17,r1Svr19: r20,r21Tr22: 5.3. Completeness theorem --) h(k(l)):xptAq(h(k(Z))):xpt + f(h(k(O)):.@tAv:fptAf(q(h(k(O)):fpt ---f h(k(l)):xptAq(h(k(l))):xpt + v:xptA h(k(l)):xptAq(h(k(Z))):xpt -+ h(k(l)):xptAq(h(k(l))):dpt -4 ~f(q(h(k(O))):.@Aq(h(k(O)):dptAh(k(O):~pt + (b:xpt) A (h(k(Z)):xpt) Aq(h(k(l))):xpt --+ true We now give a formal proof of the completeness of TP-second deduction. Besides this formal discussion provides a theoretical base for the confirming further refinement of TP-second deduction. the completeness, lemma for TP-deduction). Lemma 5.8 (Lifting Let T be u typing theory, and let KI P/R be a divided typed clause. If K' 1 W’ is a gtp-descendant of KI P/R in T, then there exists a TP-descendant Kt(Pt/Rt of KIP/R such that K’I W’ is a proper gtp-descendant of KtlPt/Rt. completeness . . . , d,/h,/r,}, is unsatisfiable, W’ = P’VThlV. Proof (Outline), By Definitions 3.1 and 5.2, and well-known property of instance K’IP’/R’ of KIP/R and a input resolution on Horn sets, there exist a ground where for each i, 1 < i 6 n, di/hi/ri E (T),,, multiset To = {dt/hl/rl, . .VTh,, and there exists an input such that T&U{~R’} refutation D’: 7Rh (= 7R') , 7 Ri , . . . ,lRi (= Cl), where for each i, ‘RI is a resolvent and an element di//ri of Tol~p. Let W: = P’ V Thl V *. . V Thi, and let 0: of lR[_, be the deduction KhIWL/Rb (= K’IP’/R’), K{IW,‘/R’,, . . . , KLIWA/RL (= K’IW’/true). and di/ri/hi. By treating Clearly, each K,‘IW,‘/R: is a TP-resolvent [ 101 lemma each typed clause or typing from KI P/R for ordinary and T, such Wi’ = Piei, Rf = RiOi). By Definition KI P/ R in T. Let j be n or the smallest of Ki_,IW;_,/Ri_, rule as an ordinary clause, and by the lifting into a deduction D, of K,,I P,/R, 5.4, D, from index for which hj+l = . . . = h, = true. Then we clause, 0; can be “lifted” that K,‘IW,‘/Ri is an instance of Kil Pi/R, is a TP-deduction of K,jP,/R, for some Bi, K,! = KiOiy (i.e., Ee-Cheng Wang/Art$cial Intelligence 75 (1995) 161-194 183 must have Wj = W! =. +. = WA = W’ and ]lTa]l k R$, . . . , llToll b RL. Thus, for every = KiI W(, and true is a gtp of RI in T. By Definition 5.2, K’I W’ is a I, j < 1 6 n, K’IW proper gtp-descendant rl of Kt IPt/Rt in T. i+’ Corollary 5.9. Zf K’I W’ is a proper gtp-descendant of KI P/R in T, then there exists a TP-deduction of KtIPt/true from KIP/R in j/Tjl such that K’I Wr is a ground instance of KtIPt. Zf q /a is a proper gtp-descemfant of O/n/R, then q /Cl can be deduced from [7/O/R by a TP-deduction in T. To prove that TP-second deduction of a divided ground resolution. The divided ground deduction, the typing is a ground clause whose type restriction the following example. KI W). Consider is assumed for which theory is complete, we need a lemma for the completeness is a special TP-second to be empty, and each typed clause form is true (so it can be written in a simpler resolution Example 5.10. Let Sh consist of four divided ground clauses dt-d4 given below. It is is a refutation of Sh obtained by easy to check divided ground that Sh is unsatisfiable. The following resolution. dt. PV~IP d2. p V yqltrue ‘P v 4l’P 7p V 741 true [given] [given] [given] [given] PIP TPITP [dl(ql),&(~ql)l [&(qI),d4(-ql)l 01~ V ‘P [&(pl),ds(d)l 4. &. 4. & &. 4. 4. 4l’P +p 01-p dto. dtt. qlp -qltrue 42. d13. q IIP 17lcI d14. MlpWdd)l [ddlpLUd)l [dx(ql),ddd)l [4o+P)~4(~l)l [dlo(l~P)9d2(PI)l Mll(qlL42(+1 [dlo(l-p),43(IP)l For divided ground resolution, we do not allow that the duplicated be merged. This restriction left-kernels literal occurrences is useful and right-kernels refutation to a divided later for typed refutation by means of a lifting between lifting a divided ground lemma for divided kernel resolution (Lemma 5.12 to be given soon). Lemma 5.11. Let S be a set of ground divided clauses. If S is unsatis$able, then there exists a deduction of empty clause I-J/C] from S by divided ground resolution. 4 Proof. If q I]CI is in S, then let us proceed by induction on the number of excess literal occurrences of S [ 11, EX( S) = CcES (size( c) - I), where size( KI W) = size(K) + size(W) and size(O) = 0. trivially. Otherwise, the lemma holds 4 According to the talk “Resolution Completeness Proofi” given by Ken Kunen at The 4th Annual Frontiers in Computing Symposium Honoring Professor W. W. Bledsoe, November 1991, Austin, Texas, this lemma appears to be a reinvention of Ken Kunen’s research results reported in the Symposium. L.emma 5.11 was originally reported by the author in a manuscript (a preliminary version of this paper) submitted to CADE-11 in October 1991. 184 lie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 Case 1: EX( S) = 0. Then S contains only unit clauses. Since S is unsatisfiable, there must exist two complementary units Kil Wi, for i = 1,2, in S. From Definition 5.1, 010 must be a divided resolvent of Kt 1 W1 and K21 W2. Case 2: EX( S) > 0. Assume that for all S’, EX( S’) < N, the lemma is true. Case 2.1. For each Kj W of S, W = Cl. Let Sk = {K 1 KI W E S}. Then SK must be unsatisfiable. Since SK is a set of ordinary clauses, there exists a deduction DK of the empty clause from SK by any complete resolution procedure for propositional logic. Let D be obtained from DK by replacing each clause C of DK by a divided clause ClO. Then each clause of D is a divided clause of S, or a divided resolvent of D. Since q ]O must be in D, then D is a refutation of S by divided resolution. Case 2.2. For every KIW of S, K = q . Let SW = {W I KI W E S}. Then SW is unsatisfiable. Thus, there exists a deduction DW of the empty clause from SW by any complete resolution procedure for propositional logic. Let D be obtained from DW by replacing each clause C of DW by a divided clause q IIC. Then each clause of D is a divided clause of S, or a divided resolvent of D. Since El]U must be in D, D is a refutation of S by divided resolution. - and {KoIWO}) U {Ko~EI}. let SW, = (S-{KolWo}) Case 2.3. S contains a divided clause Kol WO such that neither KIJ = Cl nor Wo = 0. U{UlWu}. Then both Let SK,, = (S SW,, and SK, are unsatisfiable. Since each of EX( S&) and EX(&,,) is less than N, by the induction hypothesis, there exists a refutation DK~ of SK, by divided resolution and a refutation Dw, of SW, by divided resolution. Let D1 be the deduction obtained from DK~ by putting WO back to the right-kernel of K01[7 and to the right-kernel of each of its descendants in DK~. Then D1 must be a deduction by divided resolution with S, and or a node q I[ WO. If it is the former, the lemma has been D1 contains either a node (cid:144)1~ proved. If it is the latter, the deduction D obtained by appending Dw, onto the end of D1 must form a refutation of S by a divided resolution. 0 Lemma 5.12 (Lifting lemma for divided kernel resolution). Let T be a typing theory, and let K1 I PI/RI and K~IP~/Rz be typed clauses containing no variables in common. Let Ki I Wl and K;I Wi be gtp-descendants of K1 I PI/RI and K2l Pz/Rz, respectively. If K’I W’ is a kernel resolvent of K{ I Wi and Ki I Wi, then there exists a kernel resolvent such that K’IW’ is a gtp-descendant of K(P/R KIP/R of KIIIP~,/R~~ and KzlPz/Rz in T, where for i = 1,2, if Ki #a then KiilPii/Rii is identical to Kil Pi/R,, otherwise Kiil PiiIRii is a T-provable TP-descendant of Kil Pi/Ri. Proof. From the definition of gtp-descendant (Definition 5.2) and the hypothesis of the lemma that K;l W; is a gtp-descendant of Kil Pi/Ri (i = 1,2), there exists a ground instance Kil P,‘/Rf of Kil Pi/R, and a gtp gi of Rf such that W; = P/ V lgf. By Definition 5.1, we need only to consider the following three cases: Case 1: Ki $ q , Ki $ q . Then by the definition, K’ is a resolvent of Ki and Ki, and W’ = W{ V WJ. Consider the clause C’ = K’I (P,’ V Pi) /R{ A Rk. Clearly, C’ is a kernel resolvent of Ki I P[/R{ and K.$I Pi/R$. Then if we treat divided clauses as ordinary clauses and apply the standard lifting lemma [lo], there must exist a kernel resolvent C of K1) PI /RI (or a divided factor of it) and K2 I P2/R2 (or a divided factor of it) such that C’ is an instance of C. However, because no merging exists between K:, P,‘, lie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 185 and RI in producing C’, then C must be a form K/P/R, a,K’ = Ku, P,’ V P; = PC, and R’, A Rb = Rg. Since gi is assumed in T, by Definition note that W[ V Wi = Pi V Pl V -gi V -gk. Then by Definition 5.2, K’I (W[ V W.) gtp-descendant to be a gtp of Ri 3.1 gi A g: is a gtp of R’, A RG in T, and hence a gtp of Ra. Also is a such that for some substitution of KI P/R. Case 2: Kj $ Cl, K.$ = 17, L’, of Ki equals ‘Li of W& Then by the definition, the TP-deduction resolvent of K{IP,‘/R{ of 01 P22/R22 from K2 (Pz/R2 obeys the clause C’ = (Ki\L’; ) I P( V (P22A\Li) is, for some substitution A, 0 = K&, Wi = P22A and K’ = (Ki \ L{ ) , and W’ = Wi V ( Wi\ Lg) . By Lemma 5.8, there exists a TP-deduction of K22I P22/R22 from K21 Pz/ RZ such that 01 Wi is a proper gtp-descendant of KZZ[ Pzz/R~z llTl[ k R22A. Thus in T. That 01 P22/R22 must be T-provable. Note that since K.$ = q , K2 must be the empty clause of TF’- I-J. Then second deduction. Now consider /Ri A R22A. upon a literal of Kl Clearly, C’ is a kernel there must exist a and a literal of P22A. Similar factor of it) and q IP22/R22 (or a resolvent C = K/P/R factor of it) upon a literal LI of K1 and a literal L2 of P22, such that C’ is an divided u, K{ \Li = Ku, P[ V (P22A\L$) = PO, and instance of C. That is, for some substitution Ri A R22A = Ra. From we have W’ = PI V (P22h\L$) V Tgi, and hence W’ = Pu V lgl 5.2, in order to finally prove that K’I W’ is a gtp-descendant of KI P/R, we need only to show that g’, is a gtp of Rcr. But this is true by the facts that Rcr = R’, A R22A, g{ is a gtp of R’,, and true is a gtp of R22A. the facts W[ = P[ V -g{, Wi = P22A, and W’ = Wi V (Wi\Lk), . Thus, by Definition and q lP22A/R& of Case 1 above, to the discussion ( or a divided the definition of KllPl/Rl such of KiilPii/Rii the definition lITI1 b RiiAi. ThUS, of KiilPii/Rii. That of TP-second deduction. Now consider Case 3: Ki = 0, Ki = 0. Then by the definition, K’ = I-J, and W’ is a resolvent of from Wi and W.$. By Lemma 5.8, for i = 1,2, there exists a TF-deduction is, for some that c]I W; is a proper gtp-descendant KilPi/Ri [7lPii/Rii must be T-provable. Note Ai, 0 = KiiAi, W: = PiiAi, and of q ( Pii/Rii that since K: = a, Ki must be the empty clause 0. Then the TP-deduction the clause from KilPi/Ri obeys resolvent of C’ = ~71 (PI 1 Al \ L’, ) V (P22Az\Li) of Cases 1 and 2 IIll PI 1 A1 /RII Al and cl1 P22A2/ R22A2. Then similar there must exist a kernel resolvent C = KI P/ R of 01 PI 1 /RI 1 (or a divided factor above, factor of it) such that C’ is an instance of C. That of it) and 01 P22/R 22 ( or a divided (T, (PI 1 Al \L’, ) V (P22A2\Li) = Pu, and RI, A1 A R22A2 = Rcr. is, for some substitution we have W’ = that from Note that (PI 1 AI \Li ) V (P22A\Li) = Pa. Then by Definition 5.2, in order to finally prove K’I W’ is a gtp-descendant to show that true is a gtp of Ru. But this is true by the facts that Ru = RI 1 A1 A R22A2, and true is a gtp of RI 1 Al and a 0 gtp of R&2. the facts Wi = Piihi, and W’ = (Wi\L’,) V (Wi\Li), /RI, A1 A R22 AZ. Clearly, C’ is a kernel of K( P/R, we need only to the discussion Theorem 5.13 (Completeness let S be a set of divided TP-second refutation of S in T. of TP-second deduction). typed clauses. If S is T-unsatisjable, Let T be a typing theory, and there exists a then Proof. Since S is T-unsatisfiable, set Sgfp of gtp-descendants by the typed Herbrand theorem, of clauses of S in T such that S,, there exists a finite is unsatisfiable. Assume 186 lie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 is written in the form of a divided gtp-descendant as defined that each member of S,, by Definition 5.1. Then by Lemma 5.11, there exists a refutation D’ of SgP by divided resolution. We now show that we can transform D’ into a TE-second refutation D of S in T. First, for each leaf node of D’, replace the divided clause by the clause in S of which the divided clause is a gtp-descendant. Then for each non-leaf node, if its two parent nodes have been replaced by clauses of S or typed clauses deduced from S by TP-second deduction, replace it with the typed clause that can be deduced from these parent clauses by TP-second deduction in T confirmed by Lemma 5.12. Finally, replace the empty clause l-JO of D’ by a typed clause, of which cl]l~ is a gtp-descendant. This clause must be of form q ]O/R, and q ]O is a proper gtp-descendant of q ]O/R. Then by Corollary 5.9, q ]U can be deduced from q ]O/R by a TP-deduction in T. II 6. On the refinements of typed binary resolution We have described the typed resolution principle for providing the basic inference rules for the typed predicate calculus. However, unlimited application of the principle may produce many redundant resolvents. Although there exists a TP-second deduction for which the redundancy from TE-resolution can be reduced significantly, many redundant resolvents may be produced by unconstrained kernel resolution. By noting that the kernel resolution is close to the classical binary resolution, it is natural to consider the improvement of the kernel resolution by extending existing refinements of binary resolution. A formal study of this extension is outside of the scope of this paper. Here we only present an overview of the results from our preliminary study in this extension. 6.1. On the refinements with nonconditional typing theory If only nonconditional typing theory is considered, then a refinement of resolution can be extended to typed deduction by a direct transformation similar to Frisch’s framework [ 141 for transforming an unsorted deduction procedure to a sorted one. Actually, each sort in the sorted logic corresponds to an atomic type in our typed language; and a nonconditional typing theory can be viewed as a kind of sorting theory which has a least Herbrand model. Frisch indicated that each of those refinements of resolution that can be proved to be complete by usual method based on Herbrand theorem (i.e. first proving the ground completeness, then lifting the ground proof) can be extended to be a completeness-preserving refinement of sorted deduction by a direct transformation. This result holds in our typed domain. Thus, following Frisch’s framework, we outline the transformation by the following steps. Let P be a resolution-based deduction procedure. ( 1) Transform each clause of P into a typed clause. (2) Transform each resolution rule of P into a typed resolution rule in a similar manner to transforming binary resolution into the kernel binary resolution stated in Definition 4.2. (3) Extend all constraints attached to the clauses and resolvents of P into the corre- sponding restrictions to the typed clauses and typed resolvents. lie-Cheng Wang/Arti#cial Intelligence 75 (1995) 161-194 187 (4) Apply type-checking to kernel resolvents (this is optional to non kernel-empty resolvents) . 6.2. On the refinements with conditional typing theory In dealing with conditional typing theory, a simple approach is to use the direct transformation as outlined above, plus a use of TP-deduction. However, such a simple approach may result in a deduction system that is incomplete. Consider the problem of Example 4.6. By treating TDs and TRs as ordinary literals and conjunctions of ordinary literals, respectively, and by using an untyped linear deduction procedure starting from linear refutation of the set of h, = s(x, f(x)) V u(x>/x: E, we can obtain a (ordered) clauses, T4.1 U S~.J. Assuming that the left-most literal of the goal, i.e., s(x, f(x)) of hl, was the literal resolved upon, then the clause t4 = x: P/s(a, x)/n: Q must be used as a side clause of the goal hl for this refutation. Now let us use a typed (ordered) linear deduction, directly transformed from the linear deduction to solve the problem, and again use hl as the starting goal. Note that, now t4 becomes a part of the underlying typing theory, which can no longer be a side clause for the goal hl . Then the proof will fail immediately. It turns out that in dealing with conditional typing theory, an important question is how to make a typed refinement complete. A simple approach is to use weakening, that first for deriving a set of consequences which is unsatisfiable is, to apply IT-deduction in the nonconditional subset of the given typing theory. After that, because only the nonconditional portion of the typing theory is used, the direct transformation mentioned earlier can be used for incorporating refinements of untyped resolution. However, as we have mentioned earlier, weakening is unsatisfactory. 6.3. On the completeness-preserving refinements of TP-second deduction A more interesting question is how to transform a refinement of resolution into TP-second deduction without introducing incompleteness. Note that for IT-second de- duction, the left-kernel of a typed clause can be freely used in the deduction. But a literal of the right-kernel of a typed clause is usually inherited from a general condi- tion of the given typing theory, which has been prevented to be resolved upon before the inheritance. Then, a strategy for avoiding incompleteness is to attach the additional constraints to the left-kernel only. For example, we can require that the left-kernel of each kernel resolvent produced by TP-second deduction not be a tautology. One can prove with a proof similar to the proof of the completeness of TP-second deduction that this strategy is complete. However, if we require that the entire kernel not be a tautology, then the procedure will no longer be complete. For a counterexample, note that a tautology d7 in Example 5.10 is needed for the proof. [ 101, lock resolution [6], and semantic resolution Our preliminary study indicates that, with this strategy, it is possible to extend unit into IT-second resolution deduction without introducing incompleteness. The extension can be done by essentially the same steps described earlier for handling nonconditional typing theory. However, in order to avoid introducing incompleteness, we need to extend it in such a manner, that [lo], 188 7ie-Cheng Wang/Art$cial Intelligence 75 (1995) 161-194 for extending to the left-kernel the lock deduction typed clause only. For instance, associated with the refinement will be attached the constraints divided deduction, we attach an index only to each literal of left-kernels of input divided clauses and their divided kernel the same as binary kernel resolution resolvents. Thus, (Definition ( 1) only the left-kernels of two given clauses resolved upon (2) if the literal Li (i = 1,2) be the “lowest” among the indices of Ki; if Ki = 0, and SO Li is from Pi, then Li can be any literal of Pi. 5.1), except (Kt [PI/RI and KzlPz/Rz) are indexed; is from Ki, then the index of Li must into TP-second typed the locked kernel resolution will be (3) In a similar manner, one can extend the untyped semantic resolution of a [lo] to a typed PI-clash. The typed PI-clash associated with PI-clash are only applicable to a typed one, by to PI-clash, is similarly to the left-kernels of extending PI-clash except all constraints the clauses. 6.4. On other refinements of TP-second deduction [lo], of resolution, such as the set of support strategy [ 391, [ 361, there may exist no them into TP-second deduction without In the following, we give a brief discussion about some possible and hierarchical deduction that can be used for extending For some other refinements refinements the linear-like general methods causing extensions on a case by case basis. First consider how to extend incompleteness. set {h, = s( x, f(x)) (from hl and h3). Then the set of support strategy then there will be only one resolvent into TP-second deduction. Clearly, an unrestricted use of this strategy in a typed deduction may cause proof failure. is chosen Consider Example 4.6. If the singleton E Ax: P that as the set of support, can be deduced the completeness, we need to add certain to the selection of the set of support. that the set of support must include all those typed clauses, For example, we can require type if type restriction whose there in type, but E and Q are not, then a set of support chosen Example 4.6, P is a conditional for Example 4.6 should include both h3 and h4. It is easy to check that with such a set of support, type (r is a conditional that H # true). For example, the proof will fail. In order to preserve is associated with a conditional is a rule of form X: r/H/R there does exist a TP-second refutation of S4.t in T4.1. V o(x) /cc: E} s( X, f(x))/x: in T, such restrictions since typing Unfortunately, for a linear-like the proof failure theory. However, since refinement of resolution, such as linear resolution, ME [ 181, there may exist no typed version of it which is complete [ 201, or SL-resolution is mainly in dealing with conditional that a typing rule cannot be used as a side clause for the goal caused by the restriction to the selection of clauses, a proof failure may be avoided by giving certain that an input clause G cannot be used the starting goal. For example, we may require there exists a model for the set of kernels of all other clauses as the starting goal unless of S. The reader may verify then for such a goal G, there must exist at least one member of S - {G} which can be used as a side clause for G. Applying for Example 4.6, the previous selection of hl as the starting goal is illegal, since the set of kernels of h2, h3, ha is unsatisfiable. But under such a requirement, each of hz, h3, h4 can be chosen as the starting goal, and that, if S is T-unsatisfiable, to the goal selection this requirement restriction lie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 189 each of them can lead to a typed linear refutation. linear-like those of a typed that can be produced deduction obtained by extending hierarchical deduction is also incomplete. However refinement. Unlike searches a proof along with a tree of nodes, each of which contains from the parent goal. In light of this feature, The typed hierarchical into TP-second deduction than duction resolvents archical deduction permits one to lock some literals of the input clauses them to be resolved upon) partial set of support strategy the constraints are quite similar these relations. Although PSS is not complete, many [ 361 the failure cases should be fewer de- linear deduction, hierarchical all legal the hier- (i.e. disallow is the so-called in [ 361. For typed hierarchical deduction, theory the literals associated with it has been used to help efficiently prove (PSS) defined associated with the general relations contained of PSS, that is, locking the redundancy. This restriction in the given typing to the application for reducing theorems, theorems. It has been noted that the success of a goal-oriented some challenge including a theorem is closely in the refinement. Associated with in proving guidance the further research is also very interesting refinements problem reduction [ 221, Sandford’s hereditary system deduction of resolution, format is how to extend related of incorporating to the possibility this relation, one refinement of TP-second deduction semantic for It to see how this typed approach can be used to enhance other such as Bibel’s connection [5], Plaisted’s [ 231, Nie and Plaisted’s semantic back chaining proof system linear into the typed domain. the semantic guidance graph deduction interesting subject guided [ 261, Sutcliffe’s [ 291, and Lee and Plaisted’s hyper-linking lock resolution semantically strategy [ 191. 6.5. On the procedures for type reasoning How to carrying out type-checking is an important question not and TP-deduction in this paper. The answer to this question depends on the properties of the type In for reasoning about computer programs, a typing it may contain only the entire set into account, results answered theories considered by a particular many practical applications, theory often possesses certain additional typing rules of certain of types may have a tree-like efficient in sorted unification may be incorporated. type reasoning procedures can be designed. For this design, types, and these constraints of the typed deduction procedure. it may contain no empty constraints. For instance, structure, etc. By taking implementation the existing structures; especially 6.6. About equality reasoning The typed logic considered here does not have equality as a logical symbol. (general) words, the logic treats equality relations as ordinary uses the symbol “=” for specifying the meaning of equality the set of equality axioms supply symbol “=” and the corresponding is no essential difference calculus. inference the way of handling from a general relation. to our typed deduction procedures, (typed or untyped), or enrich equality In other relations, and in particular, In order to use “=” for conveying one needs to explicitly the logic with a logical There in an untyped predicate rules (e.g. paramodulation). equality 190 i’Te-Cheng Wang/ArtiJScial Intelligence 75 (1995) 161-194 7. Some implementation results A typed theorem prover [ 371 has been implemented by extending a resolution-based theorem prover into TP-second deduction. The type reasoner of the prover consists of a number of special purpose procedures based on certain assumption about the underlying typing theory. The assumption about the nonconditional portion of a typing theory T (i.e. T/TD) is close to Walther’s forest structure of sorts [ 311 and Frisch’s tree-structure restriction [ 13 J. Besides carrying out the normal TP-deduction and type-checking, this reasoner also makes simplification of some type restrictions by means of a TR-simplifier. The TR-simplifier is a special TP-deduction procedure, which is used to simplify the type restriction of each newly generated kernel resolvent. For example, it can reduce k(a) : d’t to true in proving AM&T of Example 2.4, reduce K/x: int A K/n: nat to K/x: nat in proving PLUS-T of Example 2.5, and detect ill-typed resolvents, e.g., K/x: fox A x: wolf in proving SSR-T (see Table 1 and Remarks l-4). The simplification is also done by deleting (merging) a portion of the typing precondition associated with the type restriction under certain conditions. This typed prover has been used to efficiently prove many (typed) theorems, including VKD-T, AM8-T, and PLUS-T given in Examples 2.3, 2.4, and 2.5. These experiments indicate that the typed prover is better than the untyped prover both in the efficiency of proving a theorem, and in the clarity of knowledge representation. A summary of some implementation results is given in Table 1. After a brief explanation of the content of this table, we shall give an analysis of the computer proof of AM&T. Table 1 A summary of the implen ntation results Theorem Prover Input typing rules Input kernel clauses Input kernel litemls AMI-T VKD-T PLUS-T SSR-T typed untyped typed untyped typed untyped typed untyped Accepted kernel resolvenl 238 2495 Kernel-empty clauses Ill-typed resolvents Useful kernel resolvents Useful goal resolvents Total CPU seconds CPU seconds for typing 4 3 23 19 12.5 4.51 1 0 42 37 9 13 25 0 26 13 5 10 22 24 2 0 17 14 0 15 44 50 1 0 22 17 12 11 19 29 3 0 10 10 0 23 63 64 1 0 36 36 15 8 12 52 1 85 14 14 96.4 0 1.32 0.07 2.58 0 1.80 0.60 3.18 0 4.98 2.08 0 27 66 1085 1 0 64 64 32.5 0 Remark 1. The untyped prover is simply the typed prover running in an untyped mode. In the untyped mode, the prover used the same input data as that for the typed prover, except it treated an expression t: 7 as an ordinary literal instead of a TD (type descriptor), and treat both typing rules and typed clauses as ordinary clauses. lie-Cheng Wang/Artificial Intelligence 75 (I 995) 161-l 94 191 is counted as the total number of Remark 2. The number of input kernel liter& literals of the input data on general relations, including those contained in the kernels of typed clauses and those contained in typing rules. CPU seconds for typing is the total CPU seconds spent for type reasoning, including type-checking, TP-deduction, and simplification. Total CPU seconds is the total CPU seconds used for the entire proof. Remark 3. SSR-T is a standard example (Schubert’s Steamroller) in the literature of sorted calculus. The proof for SSR-T found by our typed prover is longer than some other published proofs. This proof consists of 14 steps (i.e. 14 useful goal resolvents). Whereas the published proof in [ 321 consists of 10 steps. This is because our prover did not do factoring during the deduction. But for the shorter proof, a factoring resolvent is needed (see [ll] and [32]). Remark 4. The prover merged automatically a list of typed clauses K/R,, , . . . , K/R, into one formula K/RI V . . . V R,, and treated it as one clause. This caused the total number of input clauses (typing rules and kernel clauses) for the typed prover to be less than the total number of clauses for the untyped prover for some problems, such as AMS-T and SSR-T. An analysis of the computer proof of AM&T AM8 mentioned in Example 2.4 was acknowledged a challenge theorem for automated theorem prover. Up to now, very few automated proofs of it were reported [ 22,361. For untyped provers, AM8-T should be a little harder than AM8, because it uses typed inequality axioms, which contain more literals than the untyped ones. (Please consult Example 2.4 for the set of clauses, and Example 5.7 for the proof-tree.) In comparison with the untyped proof, which took 96.4 seconds with the acceptance of 2495 resol- vents, 5 the typed prover can prove AMS-T fair efficiently: it took only 12.5 seconds with the acceptance of 238 kernel resolvents. Why can the typed proof be much more efficient than an untyped proof? In answering this question, we shall give an illustration of the general feature and advantage of the typed predicate calculus based on TP-second deduction. a For TP-second deduction, the branching factor of the search tree may be reduced. This is because, by classifying many clauses (i.e. kt , . . . , kg) into typing rules, and many literals (i.e. a < x A x < b) of the clauses into TDs or the general relations of the typing theory, the number of clauses (kernel clauses) and literals (kernel literals) that must be considered by kernel resolution is reduced. Note that, for TP- second deduction, kernel resolution is the main inference rule in generating new resolvents. Another inference rule, TP-resolution, is used mainly as a constraint to kernel resolution. Specifically, TP-resolvents produced by type-checking do not 5 This typed prover (in untyped mode) performs worse than the HD-prover described in [36] for solving certain problems. For example, it created 1478 resolvents to prove AM8, and 577 msolvents to prove IMV, but the HD-prover created only 204 resolvents to prove AM8, and only 149 resolvents to prove IMV. This is partly because that the HD-prover employs special heuristics, based on twin-symbol matching (see [ 361) , which am not fully incorporated by this typed prover, 192 Tie-Cheng Wang/Arr@cial Intelligence 75 (1995) 161-194 the type consistency contribute checking transform a kernel resolvent by TP-deduction contribute because, as shown be generated. to the search space; they are intermediate results produced only of kernel resolvents. The role of TR-simplifier into a simpler form. Although TP-descendents to the space of search, their number few kernel-empty produced is usually small, that can clauses in Table 1, there are usually for is to l The need for deducing a kernel-empty resolvent provides a direction the only determined to the search goal for untyped deduction, for TP-second usually deduction, is a determined clause (such as g16 of the proof-tree of Example 5.7), it should be given a very In comparison with the deduction of the empty clause by for deducing the number of steps (i.e., useful goal resolvents) clauses. Once a kernel-empty the kernel-empty there the empty clause. This reduction, plus the reduction clause must be smaller in the search space. As was shown than or equal to the number of steps for in the branch factor, in Table 1, the untyped the empty clause, for which it has to generate and to took only 10 steps (goals) the typed prover resolution, to develop. the empty clause, goal-deducing for a refutation. While is deducing intermediate is deduced high priority untyped a kernel-empty deducing leads prover accept 2495 resolvents. Whereas, deduce took 37 steps to deduce to a reduction the kernel-empty l The use of specialized procedures clause g16 with 186 resolvents accepted. and implementation strategy (e.g., caching) for If we count the total then, strictly speaking, needed (resolvents) the deduction, also contributes to the gain in the efficiency. generated during in the total number of steps for a (i.e. those produced by applying TP- reasoning typing number of TP-resolvents there may be no savings typed proof. However, except TP-descendants are used only as intermediate to kernel empty clauses), TP-resolvents deduction results. They need not be produced, evaluated, and maintained as ordinary kernel resolvents. As was shown in Table 1, for proving AMS-T by the typed prover, a total of 4.57 seconds was spent on type reasoning. We may assume to the generation of each kernel resolvent, 5 TP-resolvents for type-checking produced total of 238 resolvents generated, each TP-resolvent = 0.00384 seconds. This is about 10 time faster as the (12.5 - 4.57)/238 = 0.033 seconds spent for generating there were, in a virtually sense, at least Since there were a x 5) seconds seconds that, corresponding a kernel resolvent. and simplification. took 4.57/(238 8. Conclusion reasoning from general We introduced principle by extending a typed and constrained resolution resolution. This principle deduction soning relations with the kernel formulation. We proved a typed Herbrand on this theorem, established to improve introduced of general TP-deduction in sorted type rea- theory shares general theorem, and based In order of the typed resolution principle. theorems by using the typed resolution principle, we the efficiency a TP-second deduction procedure which allows one to restrict the application results existing is capable of separating even when the background resolvents. We discussed the refinements of the the completeness to kernel-empty in proving typing Tie-Cheng Wang/Artificial Intelligence 75 (1995) 161-194 193 existing typed deduction by extending a number of interesting advantage of our typed approach using tion of a typed prover. We compared our approach with the existing work in the field, and referred refinements of untyped for future research. We demonstrated results, based on which, our conclusion the results obtained by a computer and identified the to the existing can be made. and analyzed implementa- resolution, subjects Acknowledgment The author would gestions have helped and D. Smith at the Kestrel R. Furst and M. Pryce for proofreading like to thank in improving Institute the drafts. the anonymous and clarifying and sug- thank A. Goldberg for fruitful discussion on the subject, and thank referees whose comments the presentation, References [ 1 J R. Anderson and W.W. Bledsoe, A linear format for resolution with merging and a new technique for establishing completeness, J. ACM 17 ( 1970) 525-534. [ 21 HP. Barendregt, The Lambda Calculus (Elsevier Science Publishers, B.V. (North-Holland), Amsterdam, 1985). [3 ] W.W. Bledsoe, Non-resolution theorem proving, Artif Intell. 9 (1977) l-35. [4] W.W. Bledsoe, The UT interactive prover, University of Texas at Austin, Mathematics Department Memo ATP-17b, Austin, TX (1983). [ 51 W. Bibel, On matrices with connections, J. ACM 28 (4) (1981) 633-645. [ 61 R.S. Boyer, Locking: a restriction of resolution, Ph.D. Thesis, University of Texas at Austin, TX (1971). [ 71 H.-J. Biirckert, A resolution principle for clauses with constraints, in: Proceedings 10th International Conference on Automated Deduction, Kaiserslautem, Germany (1989) 178-202. [ 8 ] H.-J. Btlrckert, A Resolution Principle for a Logic with Restricted Quantifiers, Lecture Notes in Artificial Intelligence 568 ( Springer-Verlag. Berlin, 199 1) [9 ] L. Cardelli and P. Wegner, On understanding types, data abstraction, and polymorphism, Comput. Sun! 17 (4) (1985) 472-522. [lo] C.L. Chang and R.C. Lee, Symbolic Logic and Mechanical Theorem Proving (Academic Press, New York, 1973). [ 11 ] A.G. Cohn, A more expressive formulation of many sorted logic, J. Automated Reasoning 3 (2) ( 1987) 113-200. [ 121 A.G. Cohn, On the appearance of sorted literals: a nonsubstitutional framework for hybrid reasoning, in: H.J. Levesque and R. Reiter, eds., Proceedings First International Conference on Principles of Knowledge Representation and Reasoning, Toronto, Ont. (1989) 55-66. [ 131 A.M. Frisch, A general framework for sorted deduction: fundamental results on hybrid reasoning, in: H.J. Levesque and R. Reiter, eds., Proceedings First International Conference on Principles of Knowledge Representation and Reasoning, Toronto, Ont. (1989) 126-136. [ 141 A.M. Frisch, The substitutional framework for sorted deduction: fundamental results on hybrid reasoning, Artif Intell. 49 (1991) 161-198. [ 15 1 A.M. Frisch and A.G. Cohn, An abstract view of sorted unification, in: D. Kapur, ed., Proceedings 11 th International Conference on Automated Deduction, Lecture Notes in Artificial Intelligence 607 (1992) 178-192 [ 161 M. Hiifeld and G. Smolka, Define relations over constraint languages, LILGG-Report 53, IBM Deutschland (1988). [ 171 J. Jaffar and J.-L. Lassez, Constraint logic programming, in: Proceedings 14th ACM Symposium on Principles ofprogramming fanguages, Munich, Germany (1987) 11 l-120. 194 ‘lie-Cheng Wang/Art@cial Intelligence 75 (1995) 161-194 I 181 R. Kowalski and D. Kuehner, Linear resolution with selection function, Artif: Intell. 2 ( 197 1) 227-260. [ 191 S.-J. Lee and D.A. Plaisted, Eliminating duplication with the hyper-linking strategy, J. Automated Reasoning 9 (3) ( 1992) 2.5-42 [20] D.W. Loveland, Mechanical theorem-proving by model-elimination, J. ACM 15 (1968) 236-251. [21 I R. Milner, A theory of type polymorphism in programming, J. Comput. Syst. Sci. 17 (1978) 348-375. [22] X. Nie and D.A. Plaisted, A semantic backward chaining proof system, Art@Y Intell. 55 (1992) 109-128. I23 I D.A. Plaisted, Non-Horn clause logic programming without contrapositives, J. Automated Reasoning 4 (3) (1988) 287-325. [24] R. Reiter, On the integrity of typed first-order data bases, in: H. Gallaire, J. Minker and J. Nicolas, eds., Advances in Data Base Theory, Vol. I (Plenum, New York, 1981) 137-157. [25] J.A. Robinson, A machine oriented logic based on the resolution principle, J. ACM 12 (1) (1965) 23-41. [26] D.M. Sandford, Using Sophisticated Models in Resolution Theorem Proving (Springer-Verlag, New York, 1980). [ 271 M.S. Schmidt-Schauss, Computational Aspects of an Order-Sorted Logic with Term Declarations, Lecture Notes in Computer Science 395 ( Springer-Verlag, Berlin, 1989). [28] M.E. Stickel, Automated deduction by theory resolution, J. Automated Reasoning 1 (4) (1985) 333-355. 1291 G. Sutcliffe, The semantically guided linear deduction system, in: D. Kapur, ed., Proceedings 11th International Conference on Automated Deduction, Lecture Notes in Artificial Intelligence 607 (1992) 677-680. [30] M.H. van Emden and R.A. Kowalski, The semantics of predicate logic as a programming language, J. ACM 23 (4) (1976) 733-742. [ 3 11 C. Walther, A many-sorted calculus based on resolution and paramodulation, in: Proceedings IJCAI-83, Karlsruhe, Germany ( 1983) 882-891. [ 321 C. Walther, A mechanical solution of Schubert’s Steamroller by many-sorted resolution, Artij Intell. 26 (1985) 217-224. [33] C. Walther, Many-sorted unification, J. ACM 35 (1) (1988) 1-17. [ 341 T.C. Wang, Designing examples for semantically guided hierarchical deduction, Proceedings IJCAI-85, Los Angeles, CA (1985) 1201-1207. [35] T.C. Wang, On the least Herbrand model for conditional Horn sets, Assoc. Automated Reasoning Newslen. 24 (1993). [ 361 T.C. Wang and W.W. Bledsoe, Hierarchical deduction, J. Automated Reasoning 3 (1) ( 1987) 35-71. 1371 T.C. Wang and A. Goldberg, KITP-93: an automated inference system for program analysis, in: A. Bundy, ed., Proceedings 12th httemationaf Conference on Automated Deduction, Lecture Notes in Artificial Intelligence (Springer-Verlag, Berlin, 1994). [ 381 C. Weidenbach and H.J. Ohlbach, A resolution calculus with dynamic sort structures and partial functions, in: Proceedings ECAI-90, Stockholm, Sweden ( 1990) 6-10. [39] L. Wos, G.A. Robinson and D.F. Carson, Efficiency and completeness of the set of support strategy in theorem proving, J. ACM 12 (4) (1965) 484-489. [40] L. Wos, R. Overbeek, E. Lusk and J. Boyle, Automated Reasoning: Introduction and Applications (Prentice Hall, Englewood Cliffs, NJ, 1992). 