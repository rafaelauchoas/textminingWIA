Artificial Intelligence 245 (2017) 115–133Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintAn initial study of time complexity in infinite-domain constraint satisfactionPeter Jonsson a, Victor Lagerkvist b,∗a Department of Computer and Information Science, Linköping University, SE-581 83 Linköping, Swedenb Institut für Algebra, TU Dresden, 01069 Dresden, Germanya r t i c l e i n f oa b s t r a c tArticle history:Received 6 November 2015Received in revised form 9 January 2017Accepted 25 January 2017Available online 27 January 2017Keywords:Constraint satisfactionInfinite domainTime complexityThe constraint satisfaction problem (CSP) is a widely studied problem with numerous applications in computer science and artificial intelligence. For infinite-domain CSPs, there are many results separating tractable and NP-hard cases while upper and lower bounds on the time complexity of hard cases are virtually unexplored. Hence, we initiate a study of the worst-case time complexity of such CSPs. We analyze backtracking algorithms and determine upper bounds on their time complexity. We present asymptotically faster algorithms based on enumeration techniques and we show that these algorithms are applicable to well-studied problems in, for instance, temporal reasoning. Finally, we prove non-trivial lower bounds applicable to many interesting CSPs, under the assumption that certain complexity-theoretic assumptions hold. The gap between upper and lower bounds is in many cases surprisingly small, which suggests that our upper bounds cannot be significantly improved.© 2017 Elsevier B.V. All rights reserved.1. IntroductionThis introductory section is divided into three parts: we begin by motivating our work, continue by discussing the problems that we study, and finally briefly present our results.1.1. MotivationThe constraint satisfaction problem over a constraint language (cid:2) (CSP((cid:2))) is the problem of finding a variable assignment which satisfies a set of constraints, where each constraint is constructed from a relation in (cid:2). This problem is a widely studied computational problem and it can be used to model many classical problems such as k-coloring and the Boolean satisfiability problem, in a natural and uniform way. In the context of artificial intelligence, CSPs have been used for for-malizing a wide range of problems, cf. Rossi et al. [55]. Efficient algorithms for CSP problems are hence of great practical interest. If the domain D is finite, then a CSP((cid:2)) instance I with variable set V can be solved in O (|D||V | · poly((cid:3)I(cid:3))) time by enumerating all possible assignments. Hence, we have an obvious upper bound on the time complexity. This bound can, in many cases, be improved if additional information about (cid:2) is known, cf. the survey by Woeginger [65] or the textbook by Gaspers [29]. There is also a growing body of literature concerning lower bounds [34,39,42,61].* Corresponding author.E-mail addresses: peter.jonsson@liu.se (P. Jonsson), victor.lagerqvist@tu-dresden.de (V. Lagerkvist).http://dx.doi.org/10.1016/j.artint.2017.01.0050004-3702/© 2017 Elsevier B.V. All rights reserved.116P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133When it comes to CSPs over infinite domains, there is a large number of results that identify polynomial-time solvable cases, cf. Ligozat [45] or Rossi et al. [55]. However, almost nothing is known about the time complexity of solving NP-hard CSP problems. One may conjecture that a large number of practically relevant CSP problems do not fall into the tractable cases, and this motivates a closer study of the time complexity of hard problems. Thus, we initiate such a study in this article.1.2. Computational problemsAssume that we are given an instance of CSP((cid:2)) where (cid:2) is a constraint language over an infinite domain. Which upper bounds can we provide for CSP((cid:2))? Clearly, the method for finite-domain CSPs, based on enumerating all possible variable assignments, no longer work since the domain is infinite. In fact, infinite-domain CSPs are in general undecidable [7]. A first step is therefore to only consider decidable infinite-domain CSPs. However, even for such problems, for every recursive function, one can find a decidable CSP problem which cannot be solved faster than this [4]. Hence, we first need to fix a class of constraint languages X such that CSP((cid:2)) is included in a reasonable complexity class for every (cid:2) ∈ X . Througout this article we exclusively study the case when CSP((cid:2)) is included in NP, since this is a natural and well-studied class of problems. However, when considering CSPs over infinite domains, representational issues also become highly important. A relation in a finite-domain CSP problem is easy to represent by simply listing the allowed tuples. When considering infinite-domain CSPs, the relations need to be implicitly represented. A natural way is to consider disjunctive formulas over a finite set of basic relations. Let B denote some finite set of basic relations such that CSP(B) is tractable. Let B∨ω denote the closure of B under finitary disjunctions, and let B∨k be the subset of B∨ω containing only disjunctions of length at most k. We first consider a finite-domain example for illustrative purposes: let D = {true, false} and let B = {B 1, B2} where B1 = {true} and B2 = {false}. In other words a unary constraint of the form B 1(x) forces the variable x to be mapped to true, and B2( y) forces the variable y to be mapped to false. It is then easy to see that CSP(B∨ω) corresponds to the Boolean SAT problem while CSP(B∨k) corresponds to the k-SAT problem. Early examples of disjunctive constraints over infinite-domains can be found in, for instance, temporal reasoning [43,37,58], reasoning about action and change [26], and deductive databases [41]. More recent examples include interactive graphics [48], rule-based reasoning [46], and set constraints (with applications in descriptive logics) [10]. There are also works studying disjunctive constraints from a general point of view [16,21] but they are only concerned with the separation of polynomial cases from NP-hard cases, and do not further investigate the time complexity of the hard cases.There is also an important connection to constraint languages containing first-order definable relations (see Section 2.2for details). Assume (cid:2) is a finite constraint language containing relations that are first-order definable in B, and that the first order theory of B admits quantifier elimination. Then, upper bounds on CSP((cid:2)) can be inferred from results such as those that will be presented in Sections 3 and 4. This indicates that studying the time complexity of CSP(B∨ω) is worthwhile, especially since our understanding of first-order definable constraint languages is rapidly increasing [8].CSPs in certain AI applications are often based on binary basic relations and unions of them (instead of free disjunctive formulas). This is the predominant way of representing constraints in, for instance, spatial reasoning. Clearly, such relations are a subset of the relations in B∨k and we let B∨=denote this set of relations. We do not explicitly bound the length of disjunctions since they are bounded by |B|. The literature on such CSPs is voluminous and we refer the reader to Renz and Nebel [54] for an introduction. We remark that there exists examples of undecidable CSP problems over constraint languages of the form B∨=[32]. Hence, even for such restricted problems it is impossible to give general upper bounds, unless additional restrictions are imposed on the set B of basic relations.1.3. Our resultsThroughout the article, we primarily measure time complexity in the number of variables. Historically, this has been the most common way of measuring time complexity: the vast majority of work concerning finite-domain CSPs concentrates on the number of variables. One reason for this is that an instance may be massively larger than the number of variables — a SAT instance I = (V , C) (where V is the set of variables and C is the set of clauses) may contain up to 22|V |distinct clauses if repeated literals are disallowed — and measuring in the instance size may give far too optimistic figures. This may be quite detrimental since naturally appearing test examples tend to contain a moderate number of constraints. In light of |V | · poly((cid:3)I(cid:3))) time (where (cid:3)I(cid:3) denotes the total this, it is much more informative to know that SAT can be solved in O (2(cid:3)I(cid:3) · poly((cid:3)I(cid:3))) time (which number of bits needed for representing I ) instead of merely knowing that it is solvable in O (2|V | · poly((cid:3)I(cid:3))) that increasing of course is true since |V | ≤ (cid:3)I(cid:3)). For instance, we immediately conclude from the bound O (2the number of variables increases the run time much more rapidly than increasing the number of clauses. This is something (cid:3)I(cid:3) · poly((cid:3)I(cid:3))).that one cannot immediately infer from the bound O (2Let us now turn to the time complexity of solving infinite-domain CSPs. To solve such problems in practice, backtracking algorithms are usually employed. The literature on heuristically guided backtracking algorithm and empirical analyses of such algorithms is huge: we refer the reader to any good textbook (such as Dechter [24] or the handbook edited by Rossi et al. [55]) on constraint satisfaction for more information about this. What we find lacking in the literature are analyses of the asymptotical performance of such algorithms, i.e. their worst-case behavior. Unfortunately, we show in Section 3that they can be highly inefficient in the worst case. Let p denote the maximum arity of the relations in the set of basic P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133117relations B, let m = |B|, and let |V | denote the number of variables in a given CSP instance. We show (in Section 3.1) that the time complexity ranges from O (22m·|V |p ·log(m·|V |p ) · poly((cid:3)I(cid:3))) (which is doubly exponential with respect to the number of variables) for CSP(B∨ω) to O (22m·|V |p ·log m · poly((cid:3)I(cid:3))) time for B∨=|V |p log m ·poly((cid:3)I(cid:3))) if B consists of pairwise disjoint relations). The use of heuristics can probably improve these figures in some cases, but we have not been able to find such results in the literature and it is not obvious how to analyze backtracking combined with heuristics. At this stage, we are mostly interested in obtaining a baseline: we need to know the performance of simple algorithms before we start studying more sophisticated ones. However, some of these bounds can be improved by utilizing standard methods described in the literature: we demonstrate this in Section 3.2 by applying the highly influential sparsification method by Impagliazzo, Paturi, and Zane [36].(and the markedly better bound of O (2In Section 4 we switch strategy and show that disjunctive CSP problems can be solved significantly more efficiently via enumerative methods. By an enumerative method, we mean a method that is based on enumerating some kind of objects that can be used for determining whether the given instance has a solution or not. Let us for a moment go back to the simplest possible method for solving CSPs over a finite domain D: enumerate all assignments of values from D to the variable set V . This process yields a (very simple) algorithm running in O (|D||V | · poly((cid:3)I(cid:3))) time. This is the archetypical example of an enumerative method. However, it is not directly applicable to infinite-domain CSPs due to the size of the set D.We introduce two enumerative methods in this article: structure enumeration and domain enumeration. Structure enumer-ation is inspired by model checking for finite structure: we enumerate a sequence of structures (which themselves are small CSP instances) and check whether the given instance is satisfied by the (implicitly represented) solutions of the structures. Domain enumeration is more closely related to the enumerative approach to finite-domain CSPs. In certain cases, one can identify finite sets of ‘canonical’ domain elements with the following property: there exists a solution if and only if there is a solution that only uses the canonical elements. There are several important differences between these two methods but there is a general rule of thumb: structure enumeration is typically easier to apply and it has a greater range of applicability but it gives worse complexity figures than domain enumeration.By using structure enumeration, we obtain the upper bound O (2|V |p ·m · poly((cid:3)I(cid:3))) for CSP(B∨ω). If we additionally as-|V |p ·log m · poly((cid:3)I(cid:3))). sume that B is jointly exhaustive and pairwise disjoint then the running time is improved further to O (2This bound beats or equals every bound presented in Section 3. We then proceed to show even better bounds for certain choices of B by using domain enumeration. For instance, we consider certain temporal CSPs.In the last part of the article (Section 5), we consider the problem of determining lower bounds for CSP(B∨ω), i.e. identifying functions f such that no algorithm for CSP(B∨ω) has a better running time than O ( f (|V |)). We accomplish this by relating CSP problems and certain complexity-theoretical conjectures, and obtain strong lower bounds for the majority of the problems considered in Section 4. As an example, we show that the temporal CSP({<, >, =}∨ω) problem, where <, >|V | log |V | · poly((cid:3)I(cid:3))) but, assuming a conjecture known as the and = are the order relations on Q, is solvable in time O (2|V |) time for any c > 1. Hence, even though the algorithms strong exponential time hypothesis (SETH), not solvable in O (cwe present are rather straightforward, there is, in many cases, very little room for improvement, unless the SETH fails. It appears much more difficult to obtain lower bounds for problems of the type CSP(B∨=). However, we succeed in giving the 2)|V |) for Allen’s interval algebra. This bound is not based on the (strong) exponential time hypothesis lower bound O ((but on bounds on computing the chromatic number of graphs. The upper bound for Allen’s algebra is O (22|V |·(1+log |V |)) so there is plenty of room for improvements in this case.√This article is a revised and extend version of an earlier conference publication [38].2. PreliminariesIn this section, we formally define the constraint satisfaction problem, discuss first-order definable relations, and provide some basic definitions concerning SAT problems and the exponential time hypothesis.2.1. Constraint satisfactionWe begin by providing a formal definition of the CSP problem when it is parameterized by a set of relations.Definition 1. Let (cid:2) be a set of finitary relations over some set D of values. The constraint satisfaction problem over (cid:2)(CSP((cid:2))) is defined as follows:Instance: A set V of variables and a set C of constraints of the form R(v 1, . . . , vk), where k is the arity of R, v 1, . . . , vk ∈ Vand R ∈ (cid:2).Question: Is there a function f : V → D such that ( f (v 1), . . . , f (vk)) ∈ R for every R(v 1, . . . , vk) ∈ C ?The set (cid:2) is referred to as the constraint language. Observe that we do not require (cid:2) or D to be finite. Given an instance I of CSP((cid:2)) we write (cid:3)I(cid:3) for the number of bits required to represent I . We now turn our attention to constraint languages based on disjunctions. Let D be a set of values and let B = {B 1, . . . , Bm} denote a finite set of relations over D, i.e. B i ⊆ D jfor some j ≥ 1. Let the set B∨ω denote the set of relations defined by finitary disjunctions over B. That is, B∨ω contains every p-ary relation R such that R(x1, . . . , xp) if and only if B1(x1) ∨ · · · ∨ Bt(xt) where x1, . . . , xt are sequences of variables 118P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133from {x1, . . . , xp} such that the length of x j equals the arity of B j , and B1, . . . , Bt ∈ B. We refer to B1(x1), . . . , Bt(xt) as the disjuncts of R. We assume, without loss of generality, that a disjunct occurs at most once in a disjunction. For k ≥ 1we define B∨k as the subset of B∨ω where each relation is defined by a disjunction of length at most k. Hence, we also allow relations definable by disjunctions of length exactly k since, as was pointed out in Section 1.2 and will be evident in Section 2.3, it gives CSP(B∨k) a natural relationship to k-SAT. It is common, especially in qualitative temporal and spatial constraint reasoning, to study a restricted variant of B∨k where all relations in B have the same arity p. Define B∨=to contain every p-ary relation R such that R(x) if and only if B 1(x) ∨ · · · ∨ Bt(x), where x = (x1, . . . , xp).We adopt a simple representation of relations in B∨ω : every relation R in B∨ω is represented by its defining disjunctive (cid:11) ∈ B∨ω may denote the same relation. Hence, B∨ω is not a constraint language in the formula. Note that two objects R, Rsense of Definition 1. We avoid tedious technicalities by ignoring this issue and view constraint languages as multisets. Given an instance I = (V , C) of CSP(B∨ω) under this representation, we letDisj(I) = {B i1 (x1), . . . , B it (xt) | B i1 (x1) ∨ · · · ∨ B it (xt) ∈ C}denote the set of all disjuncts appearing in I .We close this section by introducing some notions that are common in qualitative spatial and temporal reasoning prob-lems. Let B = {B1, . . . , Bm} be a set of relations (over a domain D) such that all B 1, . . . , Bm have arity p. We say that B is B = D p and that B is pairwise disjoint (PD) if B i ∩ B j = ∅ whenever i (cid:14)= j. If B is both JE and PD jointly exhaustive (JE) if we say that it is JEPD or, in mathematical terminology, B is a partitioning of the set D p . Observe that if B1, . . . , Bm have different arity then these properties are clearly not relevant since the intersection between two such relations is always empty.(cid:2)Let (cid:2) be an arbitrary set of relations with arity p ≥ 1. We say that (cid:2) is closed under intersection if R 1 ∩ R2 ∈ (cid:2) for all choices of R1, R2 ∈ (cid:2). Let R be an arbitrary binary relation. We define the converse R(cid:4) of R such that R(cid:4) = {( y, x) | (x, y)∈ R}. If (cid:2) is a set of binary relations, then we say that (cid:2) is closed under converse if R(cid:4) ∈ (cid:2) for all R ∈ (cid:2).2.2. First-order definable relationsLanguages of the form B∨ω have a close connection to languages defined over first-order structures admitting quantifier elimination, i.e. every first-order definable relation can be defined by an equivalent formula without quantifiers. We have the following lemma.Lemma 2. Let (cid:2) be a finite constraint language first-order definable over a relational structure (D, R 1, . . . , Rm) admitting quantifier elimination, where R1, . . . , Rm are JEPD. Then there exists a k such that1. CSP((cid:2)) is polynomial-time reducible to CSP({R1, . . . , Rm}∨k) and2. if CSP({R1, . . . , Rm}∨k) is solvable in O ( f (|V |) · poly((cid:3)I(cid:3))) time, then CSP((cid:2)) is solvable in O ( f (|V |) · poly((cid:3)I(cid:3))) time.Proof. Assume that every relation R ∈ (cid:2) is definable through a quantifier-free first-order formula φi over R1, . . . , Rm. Let ψibe φi rewritten in conjunctive normal form. We need to show that every disjunction in ψi can be expressed as a disjunction over R1, . . . , Rm. Clearly, if ψi only contains positive literals, then this is trivial. Hence, assume there is at least one negative literal. Since R1, . . . , Rm are JEPD it is easy to see that for any negated relation in {R1, . . . , Rm} there exists (cid:2) ⊆ {R1, . . . , Rm}such that the union of (cid:2) equals the complemented relation. We can then reduce CSP((cid:2)) to CSP({R 1, . . . , Rm}∨k) by replacing every constraint by its conjunctive normal formula over R1, . . . , Rm. This reduction can be done in polynomial time with respect to (cid:3)I(cid:3) since each such definition can be stored in a table of fixed size. Moreover, since this reduction does not increase the number of variables, it follows that CSP((cid:2)) is solvable in O ( f (|V |) · poly((cid:3)I(cid:3))) time whenever CSP(B∨k) is solvable in O ( f (|V |) · poly((cid:3)I(cid:3))) time. (cid:2)As we will see in Section 4, this result is useful since we can use upper bounds for CSP(B∨k) to derive upper bounds for CSP((cid:2)), where (cid:2) consists of first-order definable relations over B. There is a large number of structures admitting quantifier elimination and interesting examples are presented in every standard textbook on model theory, cf. Hodges [33]. A selection of problems that are highly relevant for computer science and AI are discussed in Bodirsky [8].2.3. SAT and the exponential time hypothesisThe propositional satisfiability problem (SAT) will be important both for obtaining upper and lower bounds in later parts of this article. We define the SAT problem as usual: given a set of propositional clauses, decide whether there is a satisfying assignment or not. We sometimes consider the SAT problem restricted to clauses of length at most k and we denote this problem k-SAT. We pointed out the following fact in the introduction but it is worth repeating: if D = {true, f alse} and B = {B1, B2} where B1 = {true} and B2 = { f alse}, then CSP(B∨ω) corresponds to SAT while CSP(B∨k) corresponds to k-SAT. Note that the problem CSP(B∨=) is different in this respect since it can be seen as an alternative formulation of 1-SAT, i.e., SAT restricted to unary clauses. SAT and k-SAT are NP-complete problems when k ≥ 3 while 2-SAT and 1-SAT are solvable in polynomial time. We often use the domain {0, 1} for Boolean values where 1 is interpreted as ‘true’ and 0 as ‘false’.P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133119NP-hardness does not give us any information concerning the running times of algorithms for solving such problems (besides the fact that they are superpolynomial under the side condition that P (cid:14)= NP). For instance, under the sole assump-tion P (cid:14)= NP, we cannot, for instance, rule out that SAT can be solved in O (|V |log |V |) time. The existence of such efficient algorithms are considered unlikely and to rule out such algorithms we need complexity assumptions that are stronger than P (cid:14)= NP. The exponential time hypothesis (ETH) and the strong exponential time hypothesis (SETH) have been suggested as plau-sible stronger assumptions. These two hypotheses have been used quite intensively in the study of central problems in AI such as planning and constraint satisfaction, cf. Bäckström and Jonsson [2,3], Kanj and Szeider [42], and Traxler [61].The ETH states that there exists a δ > 0 such that 3-SAT is not solvable in O (2δ|V |) time by any deterministic algorithm, i.e. it is not solvable in subexponential time [34]. If the ETH holds, then there is an increasing sequence δ3, δ4, . . . of reals such that k-SAT cannot be solved in time 2(δk−(cid:8))|V |time for arbitrary (cid:8) > 0. The strong exponential-time hypothesis (SETH) is the conjecture that the limit of the sequence δ3, δ4, . . . equals 1, and, as a consequence, that SAT is not solvable in time O (2δ|V |) for any δ < 1 [34]. These conjectures have in recent years successfully been used for proving lower bounds of many NP-complete problems [47]. The plausibility of the (S)ETH is debatable due to the same reasons as the plausibility of P (cid:14)= NP is debatable: our understanding of this kind of complexity questions is not sufficient. One ought to note, however, that the failure of any of these hypotheses would have far-reaching and surprising consequences in connection with, for instance, the existence of subexponential algorithms for many NP-complete problems [36,39,56], the complexity and approximability of optimization problems [18,49], and parameterized complexity theory [19,20].but it can be solved in 2(δk+(cid:8))|V |3. Fundamental algorithmsIn this section we investigate the complexity of algorithms for CSP(B∨ω) and CSP(B∨k) based on branching on the disjuncts in constraints (Section 3.1) and the sparsification method (Section 3.2). Throughout this section we assume that B is a set of basic relations such that CSP(B) is in P. The reason behind this assumption is that the algorithms that we investigate in this section works by repeatedly choosing a set of disjuncts, and then checks whether this instance of CSP(B)is satisfiable or not. Clearly, this assumption is not the only possible one, but in practice it is not a great restriction, since the most frequently studied problems of the form CSP(B∨ω) satisfy this condition.3.1. Branching on disjunctsLet B = {B1, . . . , Bm} be a set of basic relations with maximum arity p ≥ 1. Assume we have an instance I of CSP(B∨ω)distinct constraints. Each such constraint contains at most with variable set V . Such an instance contains at most 2m·|V |pm · |V |p disjuncts so the instance I can be solved inO ((m · |V |p)2m·|V |p· poly((cid:3)I(cid:3))) = O (22m·|V |p ·log(m·|V |p ) · poly((cid:3)I(cid:3)))time by enumerating all possible choices of one disjunct out of every disjunctive constraint. The satisfiability of the resulting sets of constraints can be checked in polynomial time due to our initial assumptions. How does such an enumerative approach compare to a branching search algorithm? In the worst case, a branching algorithm without heuristic aid will go through all of these cases so the bound above is valid for such algorithms. Analyzing the time complexity of branching algorithms equipped with powerful heuristics is a very different (and presumably very difficult) problem.Assume instead that we have an instance I of CSP(B∨k) with variable set V . There are at most m · |V |p different disjuncts i=0(m|V |p)i ≤ k · (m|V |p)k distinct constraints. We can thus solve instances with |V | variables in (cid:3)kwhich leads to at most O (kk·(m|V |p )k · poly((cid:3)I(cid:3))) = O (2k·log k·(m|V |p )k · poly((cid:3)I(cid:3))) time.Finally, let I = (V , C) be an instance of CSP(B∨=) with variable set V . We analyze the size of C : given the variable set V , there are |V |p variable sequences of length p and there are 2m different disjunctive relations over B. Thus, there are at most 2m · |V |p distinct constraints in C and each such constraint has length at most m. Non-deterministic guessing gives that instances of this kind can be solved inO (m2m·|V |p · poly((cid:3)I(cid:3))) = O (22m·|V |p·log m · poly((cid:3)I(cid:3)))time. This may appear to be surprisingly slow but this is mainly due to the fact that we have not imposed any additional restrictions on the set B of basic relations. Hence, assume that the relations in B are PD. Given two relations R 1, R2 ∈ B∨=, it is now clear that R1 ∩ R2 is a relation in B∨=is closed under intersection. Let I = (V , C) be an instance of CSP(B∨=). For any sequence of variables (x1, . . . , xp), we can assume that there is at most one constraint R(x1, . . . , xp) in C . This implies that we can solve CSP(B∨=) in O (m|V |p log m · poly((cid:3)I(cid:3))) time. Combining everything so |V |p · poly((cid:3)I(cid:3))) = O (2far we obtain the following upper bounds., i.e. B∨=Lemma 3. Let B be a set of basic relations with maximum arity p and let m = |B|. Then• CSP(B∨ω) is solvable in O (22m·|V |p ·log(m·|V |p ) · poly((cid:3)I(cid:3))) time,• CSP(B∨k) is solvable in O (2k·log k·(m|V |p )k · poly((cid:3)I(cid:3))) time,120P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133Fig. 1. A sunflower {C1, . . . , Cm(cid:11) , . . . , Cm} with a heart C and m pairwise disjoint petals.• CSP(B∨=) is solvable in O (22m·|V |p ·log m · poly((cid:3)I(cid:3))) time, and• CSP(B∨=) is solvable in O (2|V |p log m · poly((cid:3)I(cid:3))) time if B is PD.A bit of fine-tuning is often needed when applying highly general results like Lemma 3 to concrete problems. For in-|V |2stance, Renz and Nebel [54] show that the RCC-8 problem can be solved in O (c2 ) for some (unknown) c > 1. This problem can be viewed as CSP(B∨=) where B contains JEPD binary relations and |B| = 8. Lemma 3 implies that CSP(B∨=)can be solved in O (23|V |2) which is significantly slower if c < 82. However, it is well known that B is closed under con-verse. Let I = ({x1, . . . , xn}, C) be an instance of CSP(B∨=). Since B is closed under converse, we can always assume that if R(xi, x j) ∈ C , then i ≤ j. Thus, we can solve CSP(B∨=) in O (mlog m · poly((cid:3)I(cid:3))) time. This figure matches the bound by Renz and Nebel better when c is small.· poly((cid:3)I(cid:3))) = O (2|V |22|V |223.2. SparsificationThe complexity of the algorithms proposed in Section 3 is dominated by the number of constraints. An idea for improving these running times is therefore to reduce the number of constraints within instances. One way of accomplishing this is by using sparsification [36]. This method was originally used for the k-SAT problem with the aim of proving that k-SAT instances with only a linear number (in |V |) constraints are still NP-complete and, in fact, that the ETH is still true for such instances. Recall from Section 2.3 that the ETH states that 3-SAT is not solvable in subexponential time. Sparsification can intuitively be described as the process of picking a disjunct that appears in a relatively large number of constraints, and create two instances I1 and I2, corresponding to the case where this disjunct is either true or false. In I1 we can safely remove all constraints where this disjunct appears, and in I2 all such constraints contain at least one less disjunct. We can then check the satisfiability of I by answering yes if and only if I1 or I2 is satisfiable. By repeating this process, we end up with a sequence of instances I1, . . . , Ik such that at least one of I1, . . . , Ik is satisfiable if and only if the original instance is satisfiable.To concretize this idea, a sunflower is defined to be a set of clauses {C1, . . . , Cm}, containing the same number of disjuncts, such that C1 ∩ . . . ∩ Cm (cid:14)= ∅. Here, we tacitly view a clause Ci as a set of literals, and with this interpretation, the above condition states that the clauses have at least one literal in common. The clause C1 ∩ . . . ∩ Cm = C is the heart of the sunflower and the clauses C1 \ C, . . . , Cm \ C the petals of the sunflower. This structure is visualized in Fig. 1. By searching after a sunflower C1, . . . , Cm where m is as large as possible we obtain the two instances I1 and I2 corresponding to the case where we branch on either the heart or the petals, and thus reducing either the number of constraints or the number of disjuncts in constraints. Sunflowers and related structures are important in combinatorics and there are several connections with central problems in computer science, cf. Alon et al. [1] or Jukna [40, Sec. 6]. For a more thorough and formal introduction to sparsification see Chapter 16.3 in Flum and Grohe [28]. Analyzing such a seemingly simple recursive strategy as described above is by no means trivial and we will not present the details. The analysis can be found in Impagliazzo et al. [36].We will now use sparsification for solving infinite-domain CSPs. We need a few additional definitions. A family of k-sets(U , C) consists of a finite set U (the universe) and a collection C = {S1, . . . , Sm} where S i ⊆ U and |S i| ≤ k, 1 ≤ i ≤ m. A hitting set for C is a set C ⊆ U such that C ∩ S i (cid:14)= ∅ for each S i ∈ C. Let σ (C) be the set of all hitting sets of C. T is a restriction of C if for each S ∈ C there is a T ∈ T with T ⊆ S. If T is a restriction of C, then σ (T ) ⊆ σ (C). We then have the following result.11 We remark that Impagliazzo et al. [36] use a slightly different terminology.P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133121Theorem 4 (Impagliazzo et al. [36]). For all ε > 0 and positive k, there is a constant K and an algorithm that, given a family of k-sets (U , C) where |U | = n, produces a list of t ≤ 2ε·n restrictions T1, . . . , Tt of C so that σ (C) =i=1 σ (Ti) and so that for each Ti , |Ti| ≤ K n. Furthermore, the algorithm runs in time poly(n) · 2ε·n.(cid:2)tLemma 5. Let B be a set of basic relations with maximum arity p and let m = |B|. Then CSP(B∨k) is solvable in O (2(ε+K log k)·|V |p ·m ·poly((cid:3)I(cid:3))) time for every ε > 0, where K is a constant depending only on ε and k.Proof. Let I = (V , C) be an instance of CSP(B∨k) with C = {c1, . . . , cm}. To avoid unnecessary notation, we view each con-straint c = (R1(x1) ∨ · · · ∨ Rn(xn)) as a set {R1(x1), . . . , Rn(xn)} in this proof. Note that I has a solution if and only if there exists a set X ⊆ Disj(I) such that1. (V , X) is satisfiable and2. X ∩ ci (cid:14)= ∅, 1 ≤ i ≤ m, i.e. X is a hitting set of C .We will now apply Lemma 5 on the family of k-sets (U , C) where U = Disj(I): choose some ε > 0 and let {T1, . . . , Tt}be the resulting set of restrictions. Note that each (V , Ti) can be viewed as an instance of CSP(B∨k) under the convention of viewing disjunctions as sets.We claim the following: there exists a 1 ≤ i ≤ t such that Ti is satisfiable if and only if I is satisfiable. Assume that I is satisfiable. Then there exists a hitting set X ⊆ Disj(I) of C such that (V , X) is satisfiable. Hence, X ∈ σ (C). This implies that there exists a 1 ≤ i ≤ t such that X ∈ σ (Ti) since σ (C) =i=1 σ (Ti). Since (V , X) is satisfiable, (V , Ti) is satisfiable, too.Assume instead that there exists a (V , Ti), 1 ≤ i ≤ t, such that (V , Ti) is satisfiable. Let s be a solution to Ti . Let X ={R(x) ∈ Disj(I) | s satisfies R(x)} and note that (V , X) is satisfiable and X is a hitting set of Ti . The set Ti is a restriction of C so for every c ∈ C , there exists a T ∈ Ti such that T ⊆ c. It follows that X is a hitting set for (V , C) which implies that sis a solution to (V , C).We conclude that in order to prove that I is satisfiable, it is sufficient to find a satisfiable instance (V , Ti). Each instance (V , Ti) contains at most K · |U | ≤ K · |V |p · m distinct constraints, where K is a constant depending on ε and k, and can therefore be solved in time O (poly((cid:3)I(cid:3)) · kK ·|V |p ·m) by exhaustive search as in Section 3.1. This gives a total running time of(cid:2)tpoly(|V |p · m) · 2ε·|V |p ·m + 2ε·|V |p ·m · kK ·|V |p ·m · poly((cid:3)I(cid:3)) ∈O (2ε·|V |p·m · 2K ·|V |p ·m·log k · poly((cid:3)I(cid:3))) = O (2(ε+K log k)·|V |p·m · poly((cid:3)I(cid:3)))since t ≤ 2ε·n. (cid:2)This procedure can be implemented using only polynomial space, just as the methods presented in Section 3.1. This follows from the fact that the restrictions T1, . . . , Tt of C can be computed one after another with polynomial delay [17, The-orem 5.15]. Although this running time still might seem excessively slow observe that it is significantly more efficient than algorithm for CSP(B∨k) in Lemma 3. However, in Theorem 6, Theorem 7, and Theorem 8 in Section 4.1the 2k·log k·(m|V |p )kwe will be able to improve upon this running time even further, by directly enumerating the hitting sets corresponding to the disjuncts of an instance, rather than reverting to backtracking algorithms as in Lemma 5. As we will demonstrate in Theorem 13, these bounds can also be strengthened for certain CSP(B∨k) problems, by using an idea influenced by sparsification.4. Improved upper boundsIn this section, we show that it is possible to obtain markedly better upper bounds than the ones presented in Sec-tion 3. In Section 4.1 we consider algorithms for CSP(B∨ω) based on structure enumeration, and in Section 4.2, we consider algorithms for CSP(B∨ω) and CSP(B∨k) based on domain enumeration.4.1. Structure enumerationWe begin by presenting a general algorithm for CSP(B∨ω) based on the idea of enumerating all variable assignments that are implicitly described in instances. As in the case of Section 3 we assume that B is a set of basic relations such that CSP(B) is solvable in O (poly((cid:3)I(cid:3))) time.Theorem 6. Let B be a set of basic relations with maximum arity p and let m = |B|. Then CSP(B∨ω) is solvable in O (2m|V |p ·poly((cid:3)I(cid:3))) time.Proof. Let I = (V , C) be an instance of CSP(B∨ω). Let S = Disj(I) and note that |S| ≤ m|V |p . For each subset S i of S first determine whether S i is satisfiable. Due to the initial assumption this can be done in O (poly((cid:3)I(cid:3))) time since this set of disjuncts can be viewed as an instance of CSP(B). Next, check whether S i satisfies I by, for each constraint in C , determine 122P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133whether at least one disjunct is included in S i . Each such step can determined in time O (poly((cid:3)I(cid:3))) time. The total running time for this algorithm is therefore in O (2m|V |p · poly((cid:3)I(cid:3))). (cid:2)The advantage of this approach compared to the branching algorithm in Section 3 is that enumeration of variable assign-ments is much less sensitive to instances with a large number of constraints. At this point, it may be interesting to discuss what is actually meant by ‘a large number of constraints’. Assume we have a set B = {B 1, . . . , Bm} of p-ary basic relations. Let us consider CSP(B∨2) instances with |V |2p constraints. The number of constraints is thus polynomially bounded in the number of variables. Theorem 6 shows that we solve such instances in O (2m|V |p · poly((cid:3)I(cid:3))) time. A backtracking algorithm, |V |2p · poly((cid:3)I(cid:3))) time if we reason in the same way as in Section 3.1, i.e. we need to choose on the other hand, needs O (2one disjunct out of every constraint and we need to try all possibilities in the worst case. Obviously, 2even for quite small |V | and this indicates that structure enumeration beats branching algorithms even when the number of constraints are polynomially bounded in the number of variables.> 2m|V |pWe can speed up this result even further by making additional assumptions on the set B. This allows us to enumerate |V |2psmaller sets of constraints than in Theorem 6.Theorem 7. Let B be a set of basic relations with maximum arity p and let m = |B|. Then CSP(B∨ω) solvable in O (2poly((cid:3)I(cid:3))) time if B is JEPD.|V |p ·log m ·Proof. Let I = (V , C) be an instance of CSP(B∨ω). Observe that every basic relation has the same arity p since B is JEPD. Let F be the set of functions from |V |p to B and for every f ∈ F , we let S f = {B j(x) | x ∈ V p, f (x) = B j}. The set S f contains the constraints that are specified by the function f so it contains one constraint for each tuple in V p . The size of the set is polynomially bounded in (V , C) since p is a fixed constant that only depends on the choice of basic relations. We begin by proving two claims.Claim 1. I is satisfiable if and only if there exists an f ∈ F such that (V , C ∪ S f ) is satisfiable. If I is not satisfiable, then there trivially is no f ∈ F such that (V , C ∪ S f ) is satisfiable. Assume instead that I has a solution s. Arbitrarily choose a tuple (x1, . . . , xp) ∈ V p . Since B is JEPD, the tuple (s(x1), . . . , s(xp)) is a member of exactly one B ∈ B. Thus, for every tuple (x1, . . . , xp) ∈ V p , there exists a unique B ∈ B such that (s(x1), . . . , s(xp)) ∈ B. Define the function g : V p → B such that it returns this relation. By definition, g is a member of F . The function s is a solution to the CSP instance (V , S f ) due to the choice of f and this implies that s is a solution to the instance (V , C ∪ S f ), too.Claim 2. If (V , S f ) is satisfiable for some f ∈ F , then we can check in polynomial time whether (V , C ∪ S f ) is satisfiable or not. Let s be a solution to (V , S f ). Arbitrarily choose a constraint c = (c1 ∨ · · · ∨ ck) ∈ C . Consider c1 = B i(x1) where B i ∈ B. There is a constraint B j(x1) in S f by the construction of S f . If i = j, then s satisfies the disjunct c1 and thus the constraint c. If i (cid:14)= j, then s does not satisfy c1 since B is PD. Otherwise, check the next disjunct and so on. If no disjunct c1, . . . , ck passes the test, then C ∪ S fis not satisfiable. By repeating this process for all constraints in C , we can check whether (V , C ∪ S f ) is satisfiable or not. This can be done in polynomial time in the size of (V , C) since the size of the set S fConsider the following algorithm for solving CSP(B∨ω):is polynomially bounded in the size of (V , C), as we noted in the beginning of the proof.1. ans := f alse2. for every f ∈ F do the following3.4.5.6. return anscompute S fif (V , S f ) is satisfiable thenif (V , C ∪ S f ) is satisfiable then ans := trueWe first verify that the algorithm is correct. If (V , C) is not satisfiable, then (V , C ∪ S f ) is not satisfiable for any choice of f ∈ F and the algorithm will answer f alse. If (V , C) is satisfiable, then there exists an f ∈ F such that (V , C ∪ S f ) is satisfiable by Claim 1 and the algorithm answers true. Note here that (V , S f ) is satisfiable, too, so the algorithm will indeed perform the test in Line 5.We continue by analyzing its time complexity. Computing S f takes polynomial time in the size of (V , C) since p and |B|are fixed constants that only depends on the choice of B. Checking whether (V , S f ) is satisfiable or not takes polynomial time since CSP(B) is a polynomial-time solvable problem. Finally, checking whether (V , C ∪ S f ) is satisfiable or not takes polynomial time due to Claim 2. The set F contains |B||V |p = 2|V |p log m functions and these functions can be incrementally computed with negligible overhead. We conclude that the algorithm runs in O (2|V |p ·log m · poly((cid:3)I(cid:3))) time. (cid:2)Let us reconsider the RCC-8 example from Section 3.1 and let B denote the corresponding set of eight basic relations. We |V |22 ) time for some c > 1, and we obtained the concrete · poly((cid:3)I(cid:3))) time by utilizing a simple branching algorithm. Theorem 7(1) gives that CSP(B∨ω) is solvable in know (from Renz and Nebel [54]) that CSP(B∨=) is solvable in O (cbound O (23|V |22P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133123O (23|V |2 · poly((cid:3)I(cid:3))) time. We can once again exploit the fact that B is closed under converse and instead of enumerating all functions from V 2 to B (as in the proof of Theorem 7), we assume that V = {x1, . . . , xn} and we merely enumerate the · poly((cid:3)I(cid:3))), i.e. we can solve CSP(B∨ω) as functions from {(xi, x j) | 1 ≤ i < j ≤ n} to B. This gives us the time bound O (2fast as the severely restricted problem CSP(B∨=). This indicates that there may be more efficient algorithms for CSP(B∨=).3|V |22If the set of basic relations B are PD but not JE, then we get a slightly slower algorithm for CSP(B∨ω).Theorem 8. Let B be a set of basic relations with arity p and let m = |B|. Then CSP(B∨ω) is solvable in O (2time if B is PD.|V |p ·log(m+1) · poly((cid:3)I(cid:3)))(cid:11)Proof. Let I = (V , C) be an instance of CSP(B∨ω). We introduce a symbol (cid:16) for indicating that we do not care about the (cid:11)be the set of functions from |V |p to B ∪ {(cid:16)} and for every exact relation between the variables in a variable tuple. Let Ff ∈ Flet S f = {B j(x) | x ∈ V p, f i(x) = B j (cid:14)= (cid:16)}.We say that a function f ∈ Fbegin by proving an auxiliary result: I is satisfiable if and only if there exists a compatible f ∈ Fsatisfiable. Assume there exists an f ∈ Fleast one disjunct in each constraint in C is satisfied by s. Thus, (V , C) is satisfiable.is compatible if f (x) = B (cid:14)= (cid:16) for at least one disjunct B(x) in each constraint in C . We such that (V , S f ) is is compatible implies that at such that (V , S f ) has a solution s. The fact that f(cid:11)(cid:11)(cid:11)Assume instead that (V , C) has the solution s. Let the set S contain one disjunct that is satisfied by s from each con-is . Also straint in C . Define the function f : V p → B ∪ {(cid:16)} such that f (x) = B if B(x) ∈ S and f (x) = (cid:16) otherwise. Note that fa well-defined function since it cannot be the case (due to PD) that B(x) and Bnote that fConsider the following algorithm for solving CSP(B∨ω):is compatible since the solution s satisfies at least one disjunct in each constraint.(cid:11)(x) are simultaneously in S if B (cid:14)= B(cid:11)1. ans := f alse2. for every compatible f ∈ F3.4.5. return anscompute S fif (V , S f ) is satisfiable then ans := true(cid:11)do the followingThe correctness of the algorithm was verified above. We continue by analyzing its time complexity. Computing S f takes polynomial time in the size of (V , C) since p and |B| are fixed constants that only depends on the choice of B. Checking whether (V , S f ) is satisfiable or not takes polynomial time since CSP(B) is a polynomial-time solvable problem. The set F|V |p log(m+1) functions and these functions can be incrementally computed with negligible overhead. contains (|B| + 1)|V |p = 2Furthermore, checking whether a function f ∈ Fis compatible or not can be done in polynomial time. We conclude that the algorithm runs in O (2|V |p ·log(m+1) · poly((cid:3)I(cid:3))) time. (cid:2)(cid:11)4.2. Domain enumerationA fundamental problem with structure enumeration is that the number of instances to be enumerated increases rapidly with the number of variables. This phenomenon is particularly noticeable if the basic relations have high arity: if the arity of the basic relations {B1, . . . , Bm} is p, then we need to consider between 2m|V |pinstances (in the general case) and 2log m·|V |pinstances (in the JEPD case). We will suggest an alternative enumeration method in this section, domain enumeration, that offers a partial solution to the problems with structure enumeration. This section contains four parts: we begin by presenting the method and giving temporal reasoning examples in Sections 4.2.1 and 4.2.2, respectively. We continue by elaborating upon the method in Sections 4.2.3 and 4.2.4.4.2.1. BasicsA possible solution to the problem outlined above is to enumerate domain elements instead — a method that is analogous to the basic algorithm for solving finite-domain CSPs. This approach presents certain difficulties, though:1. there needs to exist some finite selection of elements that guarantees that solvable instances have solutions restricted to these elements,2. the elements need to be representable in some suitable way, and3. we need an efficient method for verifying whether a variable assignment using these elements is a solution or not.We concretize these requirements in the next theorem.Theorem 9. Let B be a set of basic relations with maximum arity p and m = |B|. Assume there exist functions t, u : N → N such that for arbitrary n > 0124P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–1331. there exist finite sets Sn1, . . . , Snanexists a solution f : V → Sni for some 1 ≤ i ≤ an,2. the set {Sni3. it can be verified in u((cid:3)I(cid:3)) time whether a function f : V → S| 1 ≤ i ≤ n} can be generated in t(n) time, andfor some an > 0 such that for every solvable instance I = (V , C) of CSP(B) with |V | = n, there |V |iis a solution to a given instance I = (V , C) of CSP(B∨ω).Let bi = max{|S i1|, . . . , |S iai|}. Then CSP(B∨ω) is solvable in O (t(|V |) + a|V | · 2|V | log b|V | · u((cid:3)I(cid:3)) · poly((cid:3)I(cid:3))) time.Proof. Let I = (V , C) be an arbitrary instance of CSP(B∨ω). If I has a solution, then there is a solution f : V → Sfor some 1 ≤ i ≤ a|V | by condition (1). Condition (2) allows us to compute the set S = {Sn| 1 ≤ i ≤ n}. For each S ∈ S, we igenerate every function from V to S and check whether it is a solution or not — there is a method for this by condition (3). Generating the set S takes t(|V |) time by (2). Given an S ∈ S, there are at most (b|V |)|V | = 2|V |·log b|V | functions from V to S, and the size of S is at most a|V | by (1). Checking whether such a function is a solution or not can be done in u((cid:3)I(cid:3))|V | log b|V | · u((cid:3)I(cid:3)) · poly((cid:3)I(cid:3))) time. (cid:2)time by (3). Taken together, it follows that CSP(B∨ω) is solvable in O (t(|V |) + a|V | · 2|V |iA basic requirement for structure enumeration is that CSP(B) is in P (or, at least, does not have too high time complexity).Observe that this is irrelevant in domain enumeration since it is sufficient to check whether concrete variable assignments are solutions or not.4.2.2. Two examples from temporal reasoningLet T = {<, >, =} denote the JEPD order relations on Q. The CSP problem for T ∨=is often referred to as the time point algebra and it has been intensively studied within the temporal reasoning community. It was realized quite early that CSP(T ) is tractable [63] and, soon after, that CSP(T ∨=) is tractable [62], too. It is also well-known that CSP(T ∨ω) is NP-complete. This follows from general results by Broxvall et al. [16] but it was known earlier: it can, for instance, quite easily be inferred from the original NP-hardness proof for Allen’s algebra [63].We now recall that Theorem 7 implies that CSP(T ∨ω) can be solved in O (2|V |2·log 3 · poly((cid:3)I(cid:3))) time. We improve this bound using domain enumeration as follows.Theorem 10. CSP(T ∨ω) is solvable in O (2|V | log |V | · poly((cid:3)I(cid:3))) time.Proof. Let I = (V , C) be an arbitrary instance of CSP(T ∨ω). If I has a solution, then we claim that there is a solution (cid:11)(v) | v ∈ V } = {a1, . . . , ap} where f : V → {1, . . . , |V |}. To see this, let fa1 < a2 < · · · < ap . Define f : V → {1, . . . , |V |} such that f (v) = i if and only if fis a solution to I(cid:11)) if and only if since f (v) < f (v(cid:11)(v) > ff(cid:11) : V → Q be an arbitrary solution to I . Assume { f(cid:11)(v) = ai . We see that f(cid:11)), and f (v) > f (v(cid:11)) if and only if f(cid:11)) if and only if f(cid:11)), f (v) = f (v(cid:11)(v) < f(cid:11)(v) = f(cid:11)(v(cid:11)(v(cid:11)(vThe set {1, . . . , |V |} has cardinality |V | and it can be computed in O (|V | · log(|V |)) time. In other words, a|V | = 1, (cid:11)).b|V | = |V |, and t, u are polynomials. Theorem 9 gives that CSP(T ∨ω) can be solved inO (t(|V |) + a|V | · 2= O (poly(|V |) + 1 · 2= O (2|V | log |V | · poly((cid:3)I(cid:3)))|V | log b|V | · u((cid:3)I(cid:3)) · poly((cid:3)I(cid:3)))|V | log |V | · poly((cid:3)I(cid:3)))since |V | ≤ (cid:3)I(cid:3). (cid:2)As our second example, we consider CSPs for branching time temporal reasoning. Here, we will use domain enumeration in a more substantial way that in the previous example. The branching time model has been used in, for instance, plan-ning [23] and the analysis and verification of concurrent systems [27]. Let F be the forest containing all oriented, finite trees where the indegree of each node is at most one and let D F be the nodes in F . We then define the following four relations on F . Arbitrarily choose x, y ∈ D F .1. x =F y if and only if there is a path from x to y and a path from y to x,2. x <F y if and only if and there is a path from x to y but no path from y to x,3. x >F y if and only if there is a path from y to x but no path from x to y, and4. x(cid:3)F y if and only if there is no path from x to y and no path from y to x.These four basic relations are known as the point algebra for branching time. We let P = {=F , <F , >F , (cid:3)F } and we note that P is JEPD. The problem CSP(P ∨=) is in P [31] while the problem CSP(P ∨ω) is NP-complete [15].Example 11. Let I = (V , C) be an instance of CSP(P ∨ω) where V = {x1, x2, x3, x4, x5} and C contains the constraints{x1 <F x4, x5(cid:3)F x4, x3 ≤F x5, x5 ≤F x3, x2(cid:3)F x5, x1 <>F x2, x1 <>F x5},P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133125Fig. 2. The forest in Example 11.where xi ≤F x j is an abbreviation of (xi <F x j) ∨ (xi =F x j) and xi <>F x j an abbreviation of (xi <F x j) ∨ (xi >F x j). This instance is satisfiable by e.g. the function f (x1) = a, f (x2) = b, f (x3) = d, f (x4) = e and f (x5) = d, where a, b, d, e are (cid:11)(x) = f (x) for x ∈ {x1, x3, x4, x5} and fthe points in the forest in Fig. 2. But if we let fis not satisfying assignment since the constraint x1 <>F x2 is not satisfied by the partial order in Fig. 2.(cid:11)(x2) = g, then f(cid:11)From a formal viewpoint, we need to work with the structure F and view solutions as functions from variables to D F . It is, however, quite impractical to work with the large and opaque structure F directly. It is easier to use the following observation: an instance (V , C) of CSP(P ∨ω) has a solution if and only if there exist an oriented forest T with the property that1. the indegree of each node in T is at most one and2. the number of nodes in T equals |V |,such that the relations in C are satisfied by T (according to the interpretation of the basic relations given above). In particular, Theorem 9 is still applicable but we do not have to explicitly give unique names to all elements in D F and invent algorithms that work with this representation.We know from Theorem 7 that CSP(P ∨ω) can be solved in O (2|V |2·log 4 · poly((cid:3)I(cid:3))) = O (22|V |2 · poly((cid:3)I(cid:3))) time. We will now improve upon this result. Let τ (n) denote the number of unlabeled trees on n vertices. Otter [51] has shown that there exist constants C, α such that limn→∞= 1 where C > 0.53 and α < 2.96.τ (n)Cαnn−5/2Theorem 12. CSP(P ∨ω) is solvable in O (2|V |+log(τ (|V |))+|V | log |V | · poly((cid:3)I(cid:3))) time.1, . . . , SnanProof. In this proof, we will utilize Theorem 9 so we need to define the constants a1, a2, . . . , b1, b2, . . . , the sets Sn1, . . . , Snanfor arbitrary n, and the functions t and u. We will use the alternative representation of solutions that we outlined after Example 11 so the sets Snwill be concrete forests and not subsets of D F .Given some n > 0, we first estimate the number of directed forests with n nodes where each node has indegree at most one. To enumerate all forests instead of trees, we can enumerate all unlabeled trees with n + 1 vertices and only consider the trees where the extra vertex is connected to all other vertices. By removing this vertex we obtain a forest with n vertices (which implies that bn = n). Hence, there are at most 2nτ (n + 1) directed forests with n nodes. The factor 2n stems from the observation that each forest contains at most n edges, where each edge has two possible directions. We then filter out the directed forests containing a tree where the indegree of any vertex is more than one, and we let Sndenote these forests. It follows that we can upper bound an with 2nτ (n + 1).1, ..., SnanNext, we need a way to compute the set of all directed forests where each node has indegree at most one. The only non-constructive argument above is the generation of all directed labeled trees with n nodes. However, these can be efficiently enumerated (with polynomial delay) as demonstrated by Wright et al. [66]. Thus, t(n) = 2nτ (n + 1) · poly(n).Finally, we need a way of checking whether a function f : V → Sis a solution to an instance (V , C) of CSP(P ∨ω). is a forest, we can directly use the definitions of the basic relations in P when verifying this condition. This can Since Sbe done in polynomial time so the function u is some polynomial.|V |i|V |iPutting the pieces together with the aid of Theorem 9, we see that CSP(P ∨ω) is solvable in timeO (2|V |τ (|V | + 1) · poly(|V |) + 2= O (2|V |+log(τ (|V |))+|V | log |V | · poly((cid:3)I(cid:3)))|V | log |V | · poly((cid:3)I(cid:3)))|V |τ (|V | + 1) · 2(cid:2)A simpler algorithm is obtained if we enumerate all labeled trees (by, for instance, using Prüfer sequences [53]) instead of the unlabeled trees. However, there are nn−2 such trees on n vertices according to Cayley’s formula. This implies that the |V |+2|V | log |V | · poly((cid:3)I(cid:3))) time. This is substantially slower than the algorithm in Theorem 12resulting algorithm runs in O (2since log τ |V | ≤( 1 + (cid:8))|V | (for arbitrary (cid:8) > 0) when |V | is sufficiently large.4.2.3. Bounded disjunctionsThis section contains a more efficient method for solving CSP(B∨k) when k is a fixed constant. In particular, such prob-lems are interesting when studying finite constraint languages due to Lemma 2. The idea is to construct a number of k-SAT 126P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133instances with the property that at least one of them is satisfiable if and only if the original instance has a solution. More or less similar ideas have been used frequently in the literature and examples include algorithms for k-SAT [22], algorithms for combinatorial optimization [60, Sec. 8], and derandomization of probabilistic CSP algorithms [50]. One may also see certain similarities to the sparsification method that we presented in Section 3.2: sparsification is also based on the idea of trans-forming a single CSP instance into a set of CSP instances with advantageous properties. In the statement of the following theorem, let ck denote an arbitrary real number ck < 1 such that there exists a deterministic algorithm solving k-SAT in O (2ck·|V |) time.Theorem 13. Let B be a set of basic relations with maximum arity p and m = |B|. Assume that the following holds for every n > 0.1. there exist finite sets Snsome 1 ≤ i ≤ an and2. the set {Sni| 1 ≤ i ≤ n} can be generated in u(n) time.1, . . . , Snansuch that for every solvable instance I = (V , C) of CSP(B), there exists a solution f : V → Sni for Let bi = max{|S i1|, . . . , |S iai|}. Then CSP(B∨k) is solvable in O (u(|V |) + a|V | · 2|V |(log b|V |−1+log(ckp )) · poly((cid:3)I(cid:3))) time.|V |iProof. Let I = (V , C) be an arbitrary instance of CSP(B∨k). Assume V = {x1, . . . , xs}. If I has a solution, then there is a solution f : V → S| 1 ≤ i ≤ n}. This is possible due to Condition (2). We assume, without loss of generality, that |S| is even for every S ∈ S and, for simplicity, we additionally assume that S = {1, . . . , 2t} for some t ≥ 1. For each S ∈ S, we construct a set of k-SAT instances F 1, . . . , F psuch that there exists (at least) one F i that is satisfiable if and only if there is a solution f : V → S to I . We describe this construction next.for some 1 ≤ i ≤ a|V | by Condition (1). Thus, we begin by computing the set S = {SniArbitrarily choose a vector z = (z1, . . . , z|V |) where zi ∈ {1, 3, 5, . . . , 2t − 1}, 1 ≤ i ≤ |V |. We let F z denote the k-SAT } where we interpret variable xiinstance associated with the vector z. The instance F z contains variable set V(cid:11)i is false, then variable xi has value zi and, otherwise, xi has value zi + 1. Arbitrarily choose a constraint in C . as follows: if xFor simplicity, we assume that the constraint has maximal arity kp and that it equals R(x1, . . . , xkp). For each tuple(cid:11)(cid:11)(cid:11) = {x1, . . . , xsr ∈ {z1, z1 + 1} × {z2, z2 + 1} × · · · × {zkp, zkp + 1}that is not a member of the setR ∩ ({z1, z1 + 1} × {z2, z2 + 1} × · · · × {zkp, zkp + 1}),add the clause that ‘forbids’ this assignment to the variables, given the interpretation of variables described above. Note that this clause has arity kp, too. Do this for all constraints in C . It follows that F is satisfiable if and only if there exists a satisfying solution f : V → {1, . . . , 2t} to I such that f (x1) ∈ {z1, z1 + 1}, f (x2) ∈ {z2, z2 + 1}, and so on.By choosing all possible vectors z, we end up with (2t/2)|V | = (b|V |/2)|V |kp-SAT instances such that at least one of them is satisfiable if and only if I has a solution. We need to verify the time complexity of this procedure. Note first that computing F z can be done in polynomial time since the number of assignments that are forbidden by a constraint is at most 2p , and p is a fixed constant. Finally, the time needed for verifying the satisfiability of F a is O (2ckp ·|V |), and computing the set S takes u(|V |) time due to condition (2). It follows thatu(|V |) + (b|V |/2)|V | · 2ckp·|V | = u(|V |) + 2= u(|V |) + 2|V | log(b|V |/2) · 2|V |(log b|V |−1+log(ckp))|V | log(ckp)which concludes the proof. (cid:2)The change in time complexity may seem minimal in comparison with Theorem 9. However, note that|V | log b|V | = 2|V | · 22|V |(log b|V |−1)so there is an exponential speed-up even if we do not take the negative term log ckp into account. We remind the reader that the bounded length of disjunctions is vital for this method to work. If the length is unbounded, then there may be an exponential number of assignments that must be excluded by adding clauses to F z . This implies that the time needed for constructing F z adds an exponential factor to the complexity figure in Theorem 13.We will now turn our attention towards finite temporal constraint languages. Let us first consider total-ordered time. The computational complexity of such CSP problems has been intensively studied in the literature. In a breakthrough result, Bodirsky and Kára [13] have determined the complexity of CSP((cid:2)) for all such (cid:2) and their result shows that CSP((cid:2)) is either tractable or NP-complete. It is well known that the first-order theory of (Q, <) admits quantifier elimination [13,33]. Hence, we can exploit Lemma 2 and Theorem 13 to obtain the following corollary.Corollary 14. Let (cid:2) be a finite constraint language that is first-order definable in (Q, <). If CSP((cid:2)) is NP-complete, then it is solvable |V |(log |V |−1−s(cid:2) ) · poly((cid:3)I(cid:3))) where 0 ≤ s(cid:2) ≤ 1 is a constant that only depends on the choice of (cid:2). Otherwise, CSP((cid:2)) is in time O (2polynomial-time solvable.P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133127Unfortunately, we cannot give a similar result for branching time since branching time does not admit quantifier elimi-nation [8, Section 4.2] (so Lemma 2 is not applicable) and there is no complexity classification available. However, there are closely connected constraint languages on trees that have this property. Examples include the triple consistency problem with important applications in bioinformatics [14]: here we have both quantifier elimination and a complexity classification [11].4.2.4. Improved domain enumerationIn the proof of Theorem 9, we compute a set {S1, . . . , Sn} of finite variable domains and then consider all possible functions V → S1, V → S2, . . . , V → Sn. There are obviously cases where we do not need to enumerate all functions and this may lead to improved complexity figures. We demonstrate this by considering equality languages. An equality language is a set of relations definable through first-order formulas over the structure (D, =). Such languages are of fundamental interest in complexity classifications for infinite domain CSPs, since a classification of CSP problems based on first-order definable relations over some fixed structure typically includes the classification of equality constraint language CSPs.Let E = {=, (cid:14)=} over some countably infinite domain D. Note that E ∨ω is a sublanguage of T ∨ω so CSP(E ∨ω) can be |V | log |V | · poly((cid:3)I(cid:3))) time by Theorem 10 (which, in turn, is based on Theorem 9). We will now improve upon solved in O (2this bound but first we need some additional machinery. A partition of a set X with n elements is a pairwise disjoint set { X1, . . . , Xm}, m ≤ n such that i=1 Xi = X . A set X with n elements has Bn partitions, where Bn is the n-th Bell number. Let L(n) = 0.792nln(n+1) . It is known that Bn < L(n)n [5] and that all partitions can be enumerated in O (nBn) time [25,59].(cid:2)mTheorem 15. CSP(E ∨ω) is solvable in O (|V |2|V |·log L(|V |) · poly((cid:3)I(cid:3))) time.Proof. Let I = (V , C) be an instance of CSP(E ∨ω). For every partition S1 ∪ . . . ∪ Sn of V we interpret the variables in S ias being equal and having the value i, i.e. a constraint (x = y) holds if and only if x and y belong to the same set and (x (cid:14)= y) holds if and only if x and y belong to different sets. Then check in poly((cid:3)I(cid:3)) time if this partition satisfies I using the above interpretation. The complexity of this algorithm is therefore O (|V |L|V | · poly((cid:3)I(cid:3))) ⊆ O (|V |L(|V |)|V | · poly((cid:3)I(cid:3))) =O (|V |2|V |·log L(|V |) · poly((cid:3)I(cid:3))). (cid:2)The approach taken in Theorem 15 can be viewed as an opposite extreme of Theorem 9: here, we only consider onefunction per set of possible values.It is well known that equality constraint languages admit quantifier elimination [12]. Hence, we can use Lemma 2 to extend Theorem 15 to cover arbitrary equality constraint languages.Corollary 16. Let (cid:2) be a finite set of relations first-order definable over (D, =). Then CSP((cid:2)) is solvable in O (|V |2poly((cid:3)I(cid:3))) time.|V |·log L(|V |) ·Recall that T ∨k (and consequently E ∨k) can be solved in time O (2|V |(log |V |−1−sk) · poly((cid:3)I(cid:3))) where 0 ≤ sk ≤ 1. This bound is beaten by Corollary 16 whenever log L(|V |) < (log |V | − 1 − sk) and this occurs even for fairly small |V | sincelog L(|V |) ≤ log(0.792|V |) − log(ln |V |) ≤ log |V | − log 1.26 − log(ln |V |).5. Lower boundsThe algorithms presented in Section 4 give improved upper bounds (compared to the bounds given in Section 3) for many constraint satisfaction problems. It is natural to also ask, given reasonable complexity theoretical assumptions, how much room there is for improvement. Even though providing systematic lower bounds appears to be a challenging problem, non-trivial lower bounds can be given in certain cases. Such results are typically obtained by reducing a problem, which is believed to have a particular lower bound, to the problem in question. The reduction needs to have certain properties in order to be useful: basically, the reduction is not allowed to blow up the parameter that we are interested in too much. Since we measure time complexity in the number of variables, we need reductions that introduce only a small number of additional variables.This section is divided into two parts. Section 5.1 contains lower bounds for CSP(B∨ω) and CSP(B∨k) based on the (strong) exponential time hypothesis, and Section 5.2, where we obtain lower bounds for Allen’s interval algebra based on the Chromatic Number problem.5.1. Lower bounds based on (S)ETHWe begin by providing a general lower bound for CSP(B∨ω) (Theorem 17) and we immediately observe (Corollary 18) that this reduction is useful for analyzing CSP(B∨k) when k ≥ 3, too. We continue by refining our results in Theorem 19: if B is JEPD and contains the equality relation, then there is a stronger lower bound for CSP(B∨ω) than the one given in Theorem 17. This result is not useful for studying CSP(B∨k) since it introduces disjunctive constraints with many disjuncts.128P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133Theorem 17. Let B = {R1, R2, . . . , Rm}, m > 1, be a set of nonempty p-ary basic relations such that R1 ∩ R2 = ∅. If the SETH holds, then CSP(B∨ω) cannot be solved in O (2δ|V |) time for any δ < 1.Proof. If the SETH holds then SAT cannot be solved in O (2δ|V |) time for any δ < 1. We provide a polynomial-time many-one reduction from SAT to CSP(B∨ω) which only increases the number of variables by a constant (that only depends on the choice of B) — hence, if CSP(B∨ω) is solvable in O (2δ|V |) time for some δ < 1 then SAT is also solvable in O (2δ|V |) time, contradicting the original assumption. We begin by constructing a useful gadget. Consider the following CSP instance:I1 : R1(u1, . . . , u p) ∧ R2(v 1, . . . , v p).This instance is satisfiable since both R1 and R2 are non-empty relations. Consider instead the instanceI2 : R1(z1, u2, . . . , u p) ∧ R2(z1, v 2, . . . , v p).In this case, the instance can be either satisfiable or not satisfiable. If it is not satisfiable, then one may note that every solution f to instance I1 has the property f (u1) (cid:14)= f (v 1). If I2 is satisfiable, then we can continue the process of identifying variables until we reach a non-satisfiable instanceI3 : R1(z1, . . . , z1(cid:7)(cid:4)(cid:5)(cid:6)k times, uk+1, . . . , u p) ∧ R2(z1, . . . , z1(cid:7)(cid:5)(cid:6)(cid:4), vk+1, . . . , v p).k timesWe thus have the following satisfiable instanceI4 : R1(z1, . . . , z1(cid:4)(cid:7)(cid:5)(cid:6)k−1 times, uk, . . . , u p) ∧ R2(z1, . . . , z1(cid:4)(cid:7)(cid:5)(cid:6)k−1 times, vk, . . . , v p)and we can continue the process of identifying variables by introducing a fresh variable z2 and arrive at the instanceI5 : R1(z1, . . . , z1(cid:4)(cid:7)(cid:5)(cid:6)k−1 times, z2, uk+1, . . . , u p) ∧ R2(z1, . . . , z1(cid:4)(cid:7)(cid:5)(cid:6)k−1 times, z2, vk+1, . . . , v p)Just as in the case when we introduced z1, this instance may or may not be satisfiable. If it is not satisfiable, then I4 is satisfiable and every solution f satisfies f (uk) (cid:14)= f (vk). Otherwise, we can continue the process described above. In the end, we will end up with a satisfiable instanceI∗ : R1(z1, . . . , z1(cid:7)(cid:4)(cid:5)(cid:6), z2, . . . , z2(cid:7)(cid:5)(cid:6)(cid:4)k1 timesk2 times, . . . , zm, . . . , zm(cid:7)(cid:5)(cid:6)(cid:4), y, uk1+···+km+2, . . . , u p)∧R2(z1, . . . , z1(cid:7)(cid:5)(cid:6)(cid:4), z2, . . . , z2(cid:7)(cid:5)(cid:6)(cid:4), . . . , zm, . . . , zm(cid:7)(cid:5)(cid:6)(cid:4)km times, y(cid:11), vk1+···+km+2, . . . , v p)k1 timesk2 timeskm times(cid:11)). Note that the property PD guarantees that the process above will stop at such that every solution f satisfies f ( y) (cid:14)= f ( ysome point since R1(x) ∧ R2(y) is not satisfiable when the variable vectors x and y are identical. We abbreviate the resulting instance R1(z, y, u) ∧ R2(z, y(cid:11), v) and let K = k1 + · · · + km + 2. Let f∗ be an arbitrary solution to I∗.We are now ready to present the reduction. Let I = (V , C) be an instance of SAT, where V is a set of variables and Ca set of clauses. First observe that since m ≥ 2 and since B is PD, B must be defined over a domain with two or more elements. Introduce the variables z1, . . . , zm, v K , . . . , v p, u K , . . . , u p . Given a variable x, defineφ(x) = R1(z, x, u)andφ(¬x) = R2(z, x, v).For every clause ((cid:13)1 ∨ . . . (cid:13)k) ∈ C , create the constraint (φ((cid:13)1) ∨ . . . ∨ φ((cid:13)k)). We prove that the resulting instance Jsatisfiable if and only if I is satisfiable.Assume first that I has a solution f : V → {0, 1}. We construct a solution g : V ∪ {z1, . . . , zm, v K , . . . , v p, u K , . . . , u p} → Dto J as follows. First let g(zi) = f∗(zi) (1 ≤ i ≤ m), g(ui) = f∗(ui) (K ≤ i ≤ p), and g(v i) = f∗(v i) (K ≤ i ≤ p). Furthermore, let g(x) = f∗( y) if f (x) = 1 and let g(x) = f∗( y(cid:11)) if f (x) = 0.Arbitrarily choose a clause C = ((cid:13)1 ∨ · · · ∨ (cid:13)m) in C and recall that there is a corresponding constraint C(cid:11) = (φ((cid:13)1) ∨ · · · ∨φ((cid:13)m)) in J . Assume without loss of generality that (cid:13)1 is satisfied by f . If (cid:13)1 = x1, then f (x1) = 1 and the corresponding ) is indeed satisfied by g, If (cid:13)1 = ¬x1, then relation in Cf (x1) = 0 and the corresponding relation in Cis satisfiable.is R1(z, x, u). Note that this relation (and thus the constraint Cis R2(z, x, v). Once again, the constraint Cis satisfied by g, and J(cid:11)(cid:11)(cid:11)(cid:11)is Assume instead that J has a solution f . This solution makes at least one disjunct in each constraint satisfied so we let the set S contain exactly one satisfied disjunct from each constraint. The set S cannot simultaneously contain the constraints R1(z, x, u) and R1(z, x, v) for any variable x ∈ V . Thus we can construct a solution g for I as follows: if R 1(z, x, u) ∈ S, then P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133129g(x) = 1 and g(x) = 0 otherwise. Since there is a one-to-one correspondence between clauses in I and the disjunctive constraints in J , it follows that g must be a satisfying assignment to I . (cid:2)If the SAT instance I in the proof of Theorem 17 has clauses of length at most k, then the resulting CSP instance J is an instance of CSP(B∨k). The ETH immediately gives us the following result.Corollary 18. Let B = {R1, R2, . . . , Rm}, m > 1, be a set of nonempty p-ary basic relations such that R1 ∩ R2 = ∅. If the ETH holds, then CSP(B∨k), k ≥ 3, cannot be solved in O (2δk|V |) time.Theorem 17 and Corollary 18 have a wide range of applicability since the only restriction on the set B is that it contains two distinct relations R1, R2 such that R1 ∩ R2 = ∅. There are significantly better lower bounds if we impose additional restrictions on the set B. By assuming that the relations are JEPD and that we have access to = (as usual, we let =denote the equality relation on a given domain), we can view several variables as a single variable and thus obtain stronger lower bounds. Similar techniques have been used when proving lower bounds by, for instance, Traxler [61] and Gutin andWahlström [30].Theorem 19. Let B = {=, R1, . . . , Rm} be a set of binary JEPD relations over a countably infinite domain. If the SETH holds, then CSP(B∨ω) cannot be solved in O (c|V |) time for any c > 1.i=1 R i since B is JEPD. In the proof we Proof. First observe that the binary inequality relation (cid:14)= over D can be defined as i=1 R i . Let I = (V , C) be an instance of SAT with variables V = {x1, . . . , xn} and the therefore use (cid:14)= as an abbreviation for mset of clauses C . Let K be an integer such that K > log c. Assume without loss of generality that n is a multiple of K . We will construct an instance of CSP(B∨ω) with n+ O (1) variables. First, introduce 2K fresh variables v 1, . . . , v 2K and Kmake them different by imposing (cid:14)= constraints. Second, introduce n}impose the constraint, and for each i ∈ {1, . . . , nKK fresh variables y1, . . . , y n+ 2K = nK(cid:2)mK(cid:2)( yi = v 1 ∨ yi = v 2 ∨ · · · ∨ yi = v 2k ).Kbe a partition of V such that each |V i| = K . We will represent each set V i of Boolean variables by one yiLet V 1, . . . , V nvariable over D. To do this we will interpret each auxiliary variable zi as a K -ary Boolean tuple. Let h : {v 1, . . . , v 2K } →{0, 1}K be an injective function which assigns a Boolean K -tuple for every variable v i . Let g+ be a function from {1, . . . , K }to subsets of {v 1, . . . , v 2K } such that v i ∈ g( j) if and only if the j-th element in h(v i) is equal to 1. Define g− in the analogous way. Observe that |g+( j)| = |g−( j)| = 2K −1 for each j ∈ {1, . . . , K }.For the reduction, let ((cid:13)i1= ¬xi j , be a clause in C . We assume that n= xi j or (cid:13)i jcontains repeated literals otherwise. For each literal (cid:13)i j let V i(cid:11) ⊆ V be the set of variables such that xi jis then replaced by(cid:8)∨ . . . ∨ (cid:13)in(cid:11) ), (cid:13)i j(cid:11) ≤ n since the clause ∈ V i(cid:11) . Each literal (cid:13)i jyi(cid:11) = zz∈g+(i j )if (cid:13)i j= xi j , and with(cid:8)z∈g−(i j )yi(cid:11) = zif (cid:13)i jconstraint with n= ¬xi j . This reduction can be done in polynomial time since a clause with n(cid:11)literals is replaced by a disjunctive (cid:11)2K −1 disjuncts (since K is a constant depending only on c). It follows that SAT can be solved inO (cnK+O (1) · poly((cid:3)I(cid:3))) = O (2( nK+O (1))·log c · poly((cid:3)I(cid:3))) = O (2δ·n · poly((cid:3)I(cid:3)))for some δ < 1, since K > log c . Thus, the SETH does not hold. (cid:2)As an illustrative use of the theorem we see that the temporal problem CSP(T ∨ω) is solvable in O (2|V | log |V | · poly((cid:3)I(cid:3)))|V |) time for any c > 1 if the SETH holds. Lower bounds can also be obtained for the branching time time but not in O (cproblem CSP(P ∨ω) since there is a trivial reduction from CSP(T )∨ω which does not increase the number of variables: simply add a constraint (x < y ∨ x > y ∨ x = y) for every pair of variables in the instance. Similarly, the equality constraint satisfaction problem CSP(E ∨ω) is not solvable in O (c|V |) time for any c > 1 either, unless the SETH fails. Hence, even though the algorithms that were presented in Section 4 might appear to be quite simple, there is very little room for improvement.130P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133Table 1The thirteen basic relations in Allen’s interval algebra. The endpoint relations xs < xe and ys < ye that are valid for all relations have been omitted.Basic relationx precedes yy preceded by xx meets yy met-by xx overlaps yy overl.-by xx during yy includes xx starts yy started by xx finishes yy finished by xx equals ypp−1mm−1oo−1dd−1s−1sf−1f≡ExamplexxxyyyxxxxyyyyxxxxyyyyxxxyyyyyyyxxxyyyyyyyxxxyyyyyyyxxxxyyyyEndpointsxe < ysxe = ysxs < ys < xe ,xe < yexs > ys,xe < yexs = ys,xe < yexe = ye ,xs > ysxs = ys,xe = ye5.2. Lower bounds based on Chromatic NumberThe results in Section 5.1 show that the (S)ETH can be used for obtaining lower bounds for problems such as CSP(B∨ω)and CSP(B∨k). Unfortunately, it is not obvious how to obtain lower bounds for CSP(B∨=) using this assumption. In this section, we present lower bounds for Allen’s interval algebra using a conjecture concerning the time complexity of computing the chromatic number of graphs. The bound will not be as strong as the ones obtained by using the (S)ETH and it does not seem to (easily) generalize to other CSP(B∨=) problems.We first recapitulate the basics of Allen’s interval algebra. Allen’s algebra is a well-known formalism for temporal rea-soning where one considers relations between intervals of the form [x, y], where x, y ∈ R is the starting and ending point, respectively. Let Allen be the 213 = 8192 possible unions of the set of the thirteen relations in Table 1. For convenience we write constraints such as (p ∨ m)(x, y) as x{p, m} y, using infix notation and omitting explicit disjunction signs. The problem CSP(Allen) is NP-complete and all tractable fragments have been identified [44].Given an instance I = (V , C) of CSP(Allen) we first create two fresh variables xsfor every x ∈ V , intended to represent the startpoint and endpoint of the interval x. Then observe that a constraint x{r1, . . . , rm} y ∈ C , where each ri is a basic relation, can be represented as a disjunction of temporal constraints over xs, xe, ys and ye by using the definitions of each basic relation in Table 1. Applying Theorem 10 to the resulting instance gives the following result.i and xeiCorollary 20. CSP(Allen) is solvable in O (22|V |(1+log |V |) · poly((cid:3)I(cid:3))) time.We will now relate CSP(Allen) to the Chromatic Number problem, i.e. the problem of computing the number of colorsneeded to color a given graph.Theorem 21. If CSP(Allen) can be solved in O (time for arbitrary (cid:8) > 0.√c|V |) time for some c < 2, then Chromatic Number can be solved in O ((c + (cid:8))|V |)Proof. We first present a polynomial-time many-one reduction from k-Colourability to CSP(Allen) which introduces k fresh variables. Given an undirected graph G = ({v 1, . . . , vn}, E), introduce the variables z1, . . . , zk and v 1, . . . , vn, and:1. impose the constraints z1{m}z2{m} . . . {m}zk,2. for each v i , 1 ≤ i ≤ n, add the constraints v i{≡, s3. for each (v i, v j) ∈ E, add the constraint v i{s, s−1}v j .−1}z1, v i{p, m, f−1, d−1}z j (2 ≤ j ≤ k − 1), and v i{p, m, f−1}zk,Consulting Table 1, we see that for each v i , it holds that its right endpoint must equal the right endpoint of some zi , and its left endpoint must equal the left endpoint of z1. Thus, there are exactly k possible choices for the right endpoint −1}v j which ensures that the right endpoints of the of v i . If there is an edge (v i, v j), then we have the constraint v i{s, scorresponding variables differ. It follows that the resulting instance has a solution if and only if G is k-colorable. Hence, there is a polynomial-time Turing reduction from Chromatic Number to CSP(Allen) by combining binary search (that will evaluate log n Allen instances) with the reduction above (recall that O (log n · cn) ⊆ O ((c + (cid:8))n) for every (cid:8) > 0). Observe that if k = n then the reduction introduces n fresh variables, which is where the constant ) stems from. (cid:2)c in the expression O (√c|V |√P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133131The exact complexity of Chromatic Number has been analyzed and discussed in the literature. Björklund et al. [6] have |V | · poly((cid:3)I(cid:3)) time. Impagliazzo and Paturi [35] poses the following question: ), c < 2, algorithm for shown that the problem is solvable in 2‘Assuming SETH, can we prove a 2n−o(n) lower bound for Chromatic Number?’. Hence, an O (CSP(Allen) would also be a major breakthrough for Chromatic Number.√c|V |6. Research directionsThe study of infinite-domain CSP time complexity is still in its infancy, and there is a large amount of open questions that need to be addressed. We present a small selection below.Analysis of algorithms. We have investigated several novel algorithms for solving disjunctive CSP problems, which, with re-spect to worst-case time complexity, are much more efficient than e.g. backtracking algorithms without heuristics. These bounds can likely be improved, but, due to the lower bounds in Section 5, probably not to a great degree. Despite this, algorithms for solving infinite domain constraint satisfaction problems are in practice used in many non-trivial applica-tions. In light of this the following research direction is particularly interesting: how to formally analyze the time complexity of branching algorithms equipped with (powerful) heuristics? In the case of finite-domain CSPs and, in particular, DPLL-like al-gorithms for the k-SAT problem there are numerous results to be found in the literature, cf. the survey by Vsemirnov et al. [64]. This is not the case for infinite-domain CSPs, even though there is a considerable amount of empirical evidence that infinite-domain CSPs can be efficiently solved by such algorithms, so one ought to be optimistic about the chances of actually obtaining non-trivial bounds. Yet, sharp formal analyses appear to be virtually nonexistent in the literature.Quantified constraint satisfaction. In our article, we have limited ourselves to infinite-domain CSP problems included in NP. A natural generalization of the CSP problem is to consider instances which are allowed to also contain universally quantified variables, in addition to existentially quantified variables. This problem is in general known as the quantified constraint satisfaction problem (QCSP). For finite domains this problem is included in PSPACE, and this is also known to hold for many well-studied languages over infinite domains. For example, QCSP problems over equality constraint languages and temporal constraint languages are in general PSPACE-complete [9]. Would it be possible to exploit the algorithms for CSP(E ∨ω) and CSP(T ∨ω) in order to obtain upper bounds for their QCSP counterparts?Upper bounds. A natural step is to obtain upper bounds for spatial formalisms such as RCC-5 or RCC-8. We have encountered structure enumeration for formalisms with binary basic relations B several times during the course of the article: the problem CSP(B∨ω) can be solved in cwhere the constant c depends on B. This bound is clearly applicable to RCC-5 and RCC-8 and it raises the question whether domain enumeration may lead to improved algorithms or not. A starting point may be to analyze the complexity of the point algebra for partially ordered time since the relations in this algebra is expressible in both RCC-5 and RCC-8. One possibility here is to construct an algorithm based on the algorithm for branching time in Section 4.2.2. It is known that there are slightly more than 2n2/4 partial orders on n nodes [52]. Thus, this approach will not immediately lead to a significantly faster algorithm than the ctime algorithm based on structure enumeration, even if we have a polynomial delay algorithm for enumerating partial orders. It may, though, exist a domain enumeration algorithm running in (c(cid:11) < c. Such a speed-up may still be considered important.time with c(cid:11))|V |2|V |2|V |2Lower bounds. Another obvious research direction is to strengthen the lower bounds in Section 5 even further. The probably most challenging problem here is to obtain stronger lower bounds for CSP(B∨=). It appears that the (strong) exponen-tial time hypothesis is not so useful since the use of disjunctions seems essential. We have seen that the conjecture forChromatic Number was useful when studying Allen’s algebra, even though the achieved bound is weaker than those ob-tained for more expressive disjunctive constraints. Unfortunately, it is not obvious how to generalize the Allen result to other problems of the type CSP(B∨=).It would also be interesting to prove stronger lower bounds for CSP(B∨k) for some concrete choices of B and k. As an example, consider the temporal problem CSP(T ∨4). From Corollary 18 we see that CSP(T ∨4) is not solvable in O (2s4|V |)time for some s4 < log 1.6, assuming the ETH holds, since the currently best deterministic algorithm for 4-SAT runs in ) time for some c < 2, then Chromatic NumberO (1.6can be solved in O ((c + (cid:8))|V |) time for arbitrary (cid:8) > 0. This can be proven similar to the reduction in Theorem 21 but by making use of temporal constraints instead of interval constraints. Hence, for certain choices of B and k it might be possible to improve upon the general bounds given in Section 5.|V |) time [57]. On the other hand, if CSP(T ∨4) is solvable in O (√c|V |AcknowledgementsPeter Jonsson is partially supported by Swedish Research Council (VR) under Grant 621-2012-3239. Victor Lagerkvist is supported by the National Graduate School in Computer Science (CUGS), Sweden, and the DFG-funded project “Homogene Strukturen, Bedingungserfüllungsprobleme, und topologische Klone” (Project number 622397).References[1] N. Alon, A. Shpilka, C. Umans, On sunflowers and matrix multiplication, Comput. Complex. 22 (2) (2013) 219–243.132P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133[2] C. Bäckström, P. Jonsson, All PSPACE-complete planning problems are equal but some are more equal than others, in: Proceedings of the 4th Annual Symposium on Combinatorial Search (SOCS-2011), 2011.[3] C. Bäckström, P. Jonsson, A refined view of causal graphs and component sizes: SP-closed graph classes and beyond, J. Artif. Intell. Res. 47 (2013) 575–611.[4] B. Bauslaugh, The complexity of infinite H -coloring, J. Comb. Theory, Ser. B 61 (2) (1994) 141–154.[5] D. Berend, T. Tassa, Improved bounds on Bell numbers and on moments of sums of random variables, Probab. Math. Stat. 30 (2) (2010) 185–205.[6] A. Björklund, T. Husfeldt, M. Koivisto, Set partitioning via inclusion–exclusion, SIAM J. Comput. 39 (2) (2009) 546–563.[7] M. Bodirsky, Constraint satisfaction problems with infinite templates, in: N. Creignou, P.G. Kolaitis, H. Vollmer (Eds.), Complexity of Constraints, in: Lecture Notes in Computer Science, vol. 5250, Springer, Berlin, Heidelberg, 2008, pp. 196–228.[8] M. Bodirsky, Complexity classification in infinite-domain constraint satisfaction, Mémoire d’habilitation à diriger des recherches, Université Diderot – [9] M. Bodirsky, H. Chen, Collapsibility in infinite-domain quantified constraint satisfaction, in: Proceedings of Computer Science Logic 2006 (CSL 2006), Paris 7, 2012, Available at arXiv:1201.0856.Springer, Berlin, Heidelberg, 2006, pp. 197–211.[10] M. Bodirsky, M. Hils, Tractable set constraints, J. Artif. Intell. Res. 45 (2012) 731–759.[11] M. Bodirsky, P. Jonsson, T.V. Pham, The complexity of phylogeny constraint satisfaction, in: 33rd Symposium on Theoretical Aspects of Computer Science, STACS 2016, February 17–20, 2016, Orléans, France, 2016, pp. 20:1–20:13.[12] M. Bodirsky, J. Kára, The complexity of equality constraint languages, Theory Comput. Syst. 43 (2) (2008) 136–158.[13] M. Bodirsky, J. Kára, The complexity of temporal constraint satisfaction problems, J. ACM 57 (2) (2010) 9:1–9:41.[14] M. Bodirsky, J.K. Mueller, The complexity of rooted phylogeny problems, Log. Methods Comput. Sci. 7 (4) (2011).[15] M. Broxvall, P. Jonsson, Point algebras for temporal reasoning: algorithms and complexity, Artif. Intell. 149 (2) (2003) 179–220.[16] M. Broxvall, P. Jonsson, J. Renz, Disjunctions, independence, refinements, Artif. Intell. 140 (1/2) (2002) 153–173.[17] C. Calabro, The Exponential Complexity of Satisfiability Problems, PhD thesis, University of California, San Diego, CA, USA, 2009.[18] J. Chen, B. Chor, M. Fellows, X. Huang, D.W. Juedes, I.A. Kanj, G. Xia, Tight lower bounds for certain parameterized NP-hard problems, Inf. Comput. 201 (2) (2005) 216–231.[19] J. Chen, X. Huang, I. Kanj, G. Xia, Strong computational lower bounds via parameterized complexity, J. Comput. Syst. Sci. 72 (8) (2006) 1346–1367.[20] Y. Chen, M. Grohe, An isomorphism between subexponential and parameterized complexity theory, SIAM J. Comput. 37 (4) (2007) 1228–1258.[21] D. Cohen, P. Jeavons, P. Jonsson, M. Koubarakis, Building tractable disjunctive constraints, J. ACM 47 (5) (2000) 826–853.[22] E. Dantsin, A. Goerdt, E. Hirsch, R. Kannan, J. Kleinberg, C. Papadimitriou, O. Raghavan, U. Schöning, A deterministic (2 − 2/(k + 1))n algorithm for k-SAT based on local search, Theor. Comput. Sci. 289 (2002) 69–83.[23] T.L. Dean, M.S. Boddy, Reasoning about partially ordered events, Artif. Intell. 36 (3) (1988) 375–399.[24] R. Dechter, Constraint Processing, Elsevier/Morgan Kaufmann, 2003.[25] B. Djokic, M. Miyakawa, S. Sekiguchi, I. Semba, I. Stojmenovic, A fast iterative algorithm for generating set partitions, Comput. J. 32 (3) (June 1989) 281–282.[26] T. Drakengren, M. Bjareland, Reasoning about action in polynomial time, Artif. Intell. 115 (1) (1999) 1–24.[27] E. Emerson, J. Srinivasan, Branching time temporal logic, in: J. de Bakker, W.-P. de Roever, G. Rozenberg (Eds.), Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, Springer-Verlag, New York, 1989, pp. 123–172.[28] J. Flum, M. Grohe, Parameterized Complexity Theory, Texts in Theoretical Computer Science, An EATCS Series, Springer, 2006.[29] S. Gaspers, Exponential Time Algorithms – Structures, Measures, and Bounds, VDM, 2010.[30] G. Gutin, M. Wahlström, Tight lower bounds for the workflow satisfiability problem based on the strong exponential time hypothesis, Inf. Process. Lett. 116 (3) (2016) 223–226.[31] R. Hirsch, Expressive power and complexity in algebraic logic, J. Log. Comput. 7 (3) (1997) 309–351.[32] R. Hirsch, A finite relation algebra with undecidable network satisfaction problem, Bull. Interest Group Pure Appl. Log. 7 (4) (1999) 547–554.[33] W. Hodges, A Shorter Model Theory, Cambridge University Press, New York, NY, USA, 1997.[34] R. Impagliazzo, R. Paturi, On the complexity of k-SAT, J. Comput. Syst. Sci. 62 (2) (2001) 367–375.[35] R. Impagliazzo, R. Paturi, Exact complexity and satisfiability, in: G. Gutin, S. Szeider (Eds.), Parameterized and Exact Computation, in: Lecture Notes in Computer Science, vol. 8246, Springer International Publishing, 2013, pp. 1–3.[36] R. Impagliazzo, R. Paturi, F. Zane, Which problems have strongly exponential complexity?, J. Comput. Syst. Sci. 63 (4) (2001) 512–530.[37] P. Jonsson, C. Bäckström, A unifying approach to temporal constraint reasoning, Artif. Intell. 102 (1) (1998) 143–155.[38] P. Jonsson, V. Lagerkvist, Upper and lower bounds on the time complexity of infinite-domain CSPs, in: Proceedings of the 21st International Conference on Principles and Practice of Constraint Programming (CP-2015), 2015, pp. 183–199.[39] P. Jonsson, V. Lagerkvist, G. Nordh, B. Zanuttini, Complexity of SAT problems, clone theory and the exponential time hypothesis, in: Proceedings of the 24th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA-2013), 2013, pp. 1264–1277.[40] S. Jukna, Extremal Combinatorics – With Applications in Computer Science, Texts in Theoretical Computer Science, Springer, 2001.[41] P.C. Kanellakis, G.M. Kuper, P.Z. Revesz, Constraint query languages, J. Comput. Syst. Sci. 51 (1) (1995) 26–52.[42] I. Kanj, S. Szeider, On the subexponential time complexity of CSP, in: Proceedings of the Twenty-Seventh AAAI Conference on Artificial Intelligence (AAAI-2013), 2013.2003) 591–640.[43] M. Koubarakis, Dense time and temporal constraints with (cid:14)=, in: Proceedings of the 3rd International Conference on Principles of Knowledge Repre-sentation and Reasoning (KR’92), 1992, pp. 24–35.[44] A. Krokhin, P. Jeavons, P. Jonsson, Reasoning about temporal relations: the tractable subalgebras of Allen’s interval algebra, J. ACM 50 (5) (September [45] G. Ligozat, Qualitative Spatial and Temporal Reasoning, Wiley-ISTE, 2011.[46] B. Liu, J. Jaffar, Using constraints to model disjunctions in rule-based reasoning, in: Proceedings of the Thirteenth National Conference on Artificial Intelligence, AAAI-96, Portland, Oregon, August 4–8, 1996, vol. 2, 1996, pp. 1248–1255.[47] D. Lokshtanov, D. Marx, S. Saurabh, Lower bounds based on the exponential time hypothesis, Bull. Eur. Assoc. Theor. Comput. Sci. 3 (105) (2013).[48] K. Marriott, P. Moulder, P.J. Stuckey, A. Borning, Solving disjunctive constraints for interactive graphical applications, in: Proc. 7th International Confer-ence on Principles and Practice of Constraint Programming (CP-2001), 2001, pp. 361–376.[49] D. Marx, On the optimality of planar and geometric approximation schemes, in: Proceedings of the 48th Annual IEEE Symposium on Foundations of [50] R.A. Moser, D. Scheder, A full derandomization of Schöning’s k-SAT algorithm, in: Proceedings of the 43rd ACM Symposium on Theory of Computing Computer Science (FOCS-2007), 2007, pp. 338–348.(STOC-2011), 2011, pp. 245–252.[51] R. Otter, The number of trees, Ann. Math. 49 (3) (1948) 583–599.[52] H.J. Prömel, Counting unlabeled structures, J. Comb. Theory, Ser. A 44 (1987) 83–93.[53] H. Prüfer, Neuer beweis eines satzes über permutationen, Arch. Math. Phys. 27 (1918) 742–744.[54] J. Renz, B. Nebel, Efficient methods for qualitative spatial reasoning, J. Artif. Intell. Res. 15 (1) (2001) 289–318.P. Jonsson, V. Lagerkvist / Artificial Intelligence 245 (2017) 115–133133[55] F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Elsevier, 2006.[56] R. Santhanam, S. Srinivasan, On the limits of sparsification, in: Proceeding of the 39th International Colloquium on Automata, Languages, and Program-ming (ICALP-2012), 2012, pp. 774–785.[57] U. Schöning, A probabilistic algorithm for k-SAT based on limited local search and restart, Algorithmica 32 (4) (2002) 615–623.[58] K. Stergiou, M. Koubarakis, Backtracking algorithms for disjunctions of temporal constraints, Artif. Intell. 120 (1) (2000) 81–117.[59] I. Stojmenovi ´c, An optimal algorithm for generating equivalence relations on a linear array of processors, BIT Numer. Math. 30 (3) (1990) 424–436.[60] J. Thapper, Aspects of a Constraint Optimization Problem, PhD thesis, Linköping University, Linköping, Sweden, 2010.[61] P. Traxler, The time complexity of constraint satisfaction, in: Proceeding of the Third International Workshop on Parameterized and Exact Computation [62] P. van Beek, Approximation algorithms for temporal reasoning, in: Proceedings of the 11th International Joint Conference on Artificial Intelligence [63] M.B. Vilain, H.A. Kautz, Constraint propagation algorithms for temporal reasoning, in: Proceedings of the 5th National Conference on Artificial Intelli-[64] M. Vsemirnov, E. Hirsch, E. Dantsin, S. Ivanov, Algorithms for SAT and upper bounds on their complexity, J. Math. Sci. 118 (2) (2003) 4948–4962.[65] G. Woeginger, Exact algorithms for NP-hard problems: a survey, in: M. Juenger, G. Reinelt, G. Rinaldi (Eds.), Combinatorial Optimization – Eureka! You (IWPEC-2008), 2008, pp. 190–201.(IJCAI-1989), 1989, pp. 1291–1296.gence (AAAI-86), 1986, pp. 377–382.Shrink!, 2000, pp. 185–207.[66] R. Alan Wright, L. Bruce Richmond, A.M. Odlyzko, B.D. McKay, Constant time generation of free trees, J. Comput. Syst. Sci. 15 (2) (1986) 540–548.