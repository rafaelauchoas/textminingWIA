Artificial Intelligence 174 (2010) 316–361Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintAutomated composition of Web services via planning in asynchronousdomainsPiergiorgio Bertoli∗, Marco Pistore, Paolo TraversoFondazione Bruno Kessler, via Sommarive 18, 38100 Povo (Tn), Italya r t i c l ei n f oa b s t r a c tArticle history:Received 9 April 2008Received in revised form 13 November 2009Accepted 26 November 2009Available online 16 December 2009Keywords:PlanningWeb servicesAutomated program synthesisThe service-oriented paradigm promises a novel degree ofinteroperability betweenbusiness processes, and is leading to a major shift in way distributed applications aredesigned and realized. While novel and more powerful services can be obtained, in suchsetting, by suitably orchestrating existing ones, manually developing such orchestrationsis highly demanding,time-consuming and error-prone. Providing automated servicecomposition tools is therefore essential to reduce the time to market of services, andultimately to successfully enact the service-oriented approach.In this paper, we show that such tools can be realized based on the adoption and extensionof powerful AI planning techniques, taking the “planning via model-checking” approachas a stepping stone. In this respect, this paper summarizes and substantially extends aresearch line that started early in this decade and has continued till now. Specifically, thiswork provides three key contributions.First, we describe a novel planning framework for the automated composition of Webservices, which can handle services specified and implemented using industrial standardlike ws-bpel. Since theselanguages for business processes modeling and execution,languages describe stateful Web services that rely on asynchronous communicationprimitives, a distinctive aspect of the presented framework is its ability to model andsolve planning problems for asynchronous domains.Second, we formally spell out the theory underlying the framework, and provide algorithmsto solve service composition in such framework, proving their correctness andcompleteness. The presented algorithms significantly extend state-of-the-art techniquesfor planning under uncertainty, by allowing the combination of asynchronous domainsaccording to behavioral requirements.Third, we provide and discuss an implementation of the approach, and report extensiveexperimental results which demonstrate its ability to scale up to significant cases forwhich the manual development of ws-bpel composed services is far from trivial and timeconsuming.© 2009 Elsevier B.V. All rights reserved.1. IntroductionSince its inception, the Web has maintained a fast growth rate in terms of quantity and variety of contained information,becoming a reference information source for billions of users and business entities world-wide. In particular, in the last fewyears, the economical impact of the Web has grown substantially, due to the fact that the Web is not used anymore just topresent static information, but, more and more, to expose services with which a Web user (or a different Web-exposed ser-* Corresponding author.E-mail addresses: bertoli@fbk.eu (P. Bertoli), pistore@fbk.eu (M. Pistore), traverso@fbk.eu (P. Traverso).0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2009.12.002P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361317vice) can actively interact. This has enacted a range of Web-based solutions for commercial, learning and health-care activ-ities, and gave a substantial push to e-Commerce, e-Learning, and e-Health initiatives (see e.g. [99,51,35,55,92,80,52,33,68]).This has been the starting point for the emergence of a Service Oriented Computing paradigm, which envisages theadoption of standards for the publication and access of services over the Web, so to allow the interoperability of inde-pendently developed procedures over the Web. In such a setting, existing services can be suitably combined by means ofWeb-based “orchestration” services, so to realize novel and more complex procedures that satisfy some given user or busi-ness requirement. For instance, different services taking care of specific aspects related to the organization of a trip (e.g.flight booking, lodging, bank payment, and so on) can be suitably coordinated by an integrated “trip adviser” service, whoseadoption may save a customer considerable time and effort in setting up a trip. Indeed, being able to build new services bycomposing existing ones is crucial to the actual enactment of the service-oriented paradigm. However, the task of manuallydeveloping such orchestrations is extremely difficult, time-consuming and error-prone, even for experienced designers andprogrammers. This calls for the design of effective support techniques and automated tools capable of synthesizing serviceorchestrations starting from suitable high-level composition requirements.In this context, planning has proved to be one of the most promising techniques for the automated composition of Webservices. Several works in planning have addressed different aspects of this problem, see, e.g., [100,59,34,65,83,17,73,8,84,4,43]. In these works, automated composition is described as a planning problem: services that are available and published onthe Web, the component services, are used to construct the planning domain, composition requirements can be formalized asplanning goals, and planning algorithms can be used to generate composed services, i.e., plans that compose the componentservices. These works, which provide different technical solutions, share the conception of services as stateless entities,which enact simple query–response protocols.An even more difficult challenge for planning is the automated composition of Web services at the process level, i.e., thecomposition of component services that consist of stateful business processes, capable to establish complex multi-phaseinteractions with their partners. Indeed, in the large majority of real cases, services cannot be considered simply as atomiccomponents, which, given some inputs, return some outputs, in a single request–response step. On the contrary, in mostapplication domains, they need to be represented as stateful processes that realize interaction protocols which may involvedifferent sequential, conditional, and iterative steps. For instance, we cannot in general interact with a “flight booking” ser-vice in an atomic step. The service may require a sequence of different operations including an authentication, a submissionof a specific request for a flight, the possibility to submit iteratively different requests, acceptance (or refusal) of the offer,and finally, a payment procedure. In these cases, the process, i.e. the published interaction flow, is the key aspect to beconsidered when (automatically) composing services.The planning problem corresponding to the automated composition of services that are published as processes is farfrom trivial. First, component services cannot be simply represented as atomic actions of the planning domain. As a con-sequence, it is not obvious, like in the case of atomic component services, which is the planning domain that correspondsto the composition problem. Second, in realistic cases, component services publish nondeterministic and partially observ-able behaviors, since, in general, the outputs of a service cannot be predicted a priori and its internal status is not fullyavailable to external services. For instance, whether a payment transaction will succeed cannot be known a priori of itsexecution, and whether there are still seats available on a flight cannot be known until a specific request is submitted tothe service. Third, the plan that coordinates the component services cannot be simply a sequence of actions that call atomiccomponents; rather, it needs to interleave the (partial execution of) component services with typical programming languageconstructs such as conditionals and loops. Finally, Web service interactions are typically asynchronous: each process evolvesindependently and with unpredictable speed, and interacts with the other processes only through asynchronous messageexchanges. Message queues are used in practical implementations to guarantee that processes do not lose messages thatthey are not ready to receive.As a consequence of all these characteristics of Web services, it is far from obvious how their automated compositioncan be adequately represented as a planning problem. Moreover, their nondeterministic, partially observable, and asyn-chronous behavior poses strong requirements and introduce novel problems for the planning techniques that can be used.This has led the authors of this paper and their colleagues to investigate a research line on service oriented composition,that started with [71,95], and continued with [78,79,74,61,62], up to date [60,63,72,64,21]. While distinct for the technicalsolutions and degree of maturity, these works share two general ideas. The first consists in taking, as an algorithmic andtechnological baseline, the “planning via model checking” approach devised by the authors of this paper together with othercolleagues [16,77,32,15]. Such approach combines state-of-the-art performance with the ability to deal with general formsof nondeterminism, therefore tackling effectively one of the critical aspects implied by the nature of Web services. Thesecond idea is to face actual composition problems by pragmatically considering services expressed using de-facto standardlanguages such as ws-bpel [1,31]. While this choice renders the problem further complex, it is strongly motivated by theobjective to provide usable tools.This paper summarizes and significantly extends a large portion of the corpus of work presented in [71,95,78] and [79,74,61,62,60,63,72,64], providing for the first time both a comprehensive survey of the framework underlying the approach,and a thorough account of the formal and empirical features of the underlying algorithms. In particular, in this paper, wefocus on a form of automated process-level composition of Web services where services can be represented as finite stateautomata, and composition requirements command the finite termination of (the execution of) component services. Whileextensions to consider infinite-state services and infinite component iterations are possible, and indeed considered in [74,318P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–36162,60,21], this form of composition is already expressive enough to cover a large variety of relevant service compositionscenarios. Focusing on this setting allows us to keep the presentation compact and self-contained, while comprehensivelysurveying all the formal and empirical aspects at a sufficient level of detail.In detail, this work provides the following results:• We formalize the automated process-level composition of services (considering reachability composition requirements,and finite-state representations of services) as a planning problem. The planning domain is constructed from processesthat describe component services and results in a nondeterministic, partially observable, and asynchronous domain.• We devise a novel planning approach that is able to work in nondeterministic, partially observable, asynchronous do-mains. We prove formally its properties, its correctness and its completeness.• We embed the planning framework in a real industry-wide adopted environment for describing, composing, and execut-ing Web services. In this environment, Web services are described using ws-bpel (Business Process Execution Languagefor Web Services [1,31]), one of the most used industrial standard languages for describing and executing Web services.We generate automatically the planning domain from the ws-bpel specification of the component services. We then au-tomatically translate back the generated plans into executable ws-bpel processes that implement the composed serviceand that can be run on standard execution engines.• We discuss our implementation of the proposed framework and perform an extensive experimental evaluation. We showthat our approach can be used in practice to automatically compose Web services described in ws-bpel. The techniquecan scale up to significant cases in which the manual development of ws-bpel composite services is not trivial and timeconsuming.1.1. RoadmapOur roadmap for the paper is following. First, in Section 2, we describe informally the automated composition problem,introducing an explanatory example that will be used all along the paper, and showing how the component services, andthe intended orchestration, can be expressed using the ws-bpel language and its complementary wsdl interface definitions.In Section 3, we show how ws-bpel specifications of component services can be interpreted as state transition systems(STSs), that is as automata that describe the behavior of services, and we discuss how it is possible to perform automaticallysuch a translation.Based on these grounds, in Section 4 we provide the formal definition of the composition problem. In particular, we firstintroduce the key notion of deadlock-free controller of an STS, which identifies the adequacy requirements that an STS mustsatisfy in order to act as a suitable orchestrator for some other STSs. Then, we clarify what kind of composition requirementsare considered in our setting, and what does it mean to satisfy them. This allows us to model the composition problemas one of synthesizing a deadlock-free controller for the set of concurrently executing STSs associated to the componentservices, such that its behaviors satisfy a given composition requirement. Once the formal definition of the compositionproblem is set up, in Section 5, we describe an algorithm for the automated composition and prove its properties. To do so,we first rephrase the problem in a way that makes it explicit how it can be solved by constructing and visiting a (portion ofa) specific search space. In particular, the elements of such a search space must represent beliefs of the orchestration serviceover the current status of the (STSs associated with the) component services. Our approach consists in first pre-computingsuch belief-level search space, and then searching it by means of effective techniques inspired by model-checking basedplanning, for which we provide and discuss algorithmic descriptions.In Section 6, we discuss the implementation of the planning algorithm, and we describe the experimental evaluation. Forthis purpose, on top of our reference scenario, we introduce a variety of scalable scenarios, report data on experiments runon all of them, and wrap up by synthesizing our empirical findings about the features of our approach. Finally, Sections 7and 8 discuss in detail work related to ours, and draw conclusions about our approach, as well as about possible directionsof future work.2. The problemIn this section, we describe the service composition problem, introducing a scenario which will be then used as areference throughout the paper. The scenario will allow us to better discuss the way services taking part to a compositioncan be expressed by means of a standard language, and to highlight some relevant assumptions underlying our approach.Taking a general view, the service composition problem amounts to construct a new service (the composed service) thatperforms some desired functionality by interacting with available services (the component services).In our approach, we consider the case where stateful component services require complex interaction protocols to per-form their task. This is a very expressive setting which enables capturing a large variety of real-life scenarios. However, asingle paper would not be enough to expose and solve the problem in its full width, considering fully generic componentsand behavioral requirements. We therefore take two key assumptions that serve to constrain the discussion, and we leaveto Section 7 an analysis on how to relax such assumptions.The first key assumption concerns the nature of composition requirements. In this work, we consider composition re-quirements that constrain the data exchanged during the orchestration and the final admissible states of component services.P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361319Fig. 1. The P&S scenario.Such requirements, therefore, imply that the execution of each component service terminates in a finite number of steps;that is, in our setting, we can only admit component services whose loops (if any) can be proven to exit after a finitenumber of iterations. This has the further consequence that also the orchestration terminates in a finite number of steps,and therefore, without lack of generality, we will be able to focus on the synthesis of acyclic orchestration services.The second assumption is the ability to represent services in terms of finite-state automata. Of course, this assumptionholds immediately for services whose number of internal states is finite. However, this does not rule out services whoseinternal states are infinite, insofar it is possible to identify an adequate finite-state abstraction, as we will discuss in moredetail in Section 7. This is indeed the case in many realistic composition scenarios, such as the one described in the followingreference example.Example 1. Our goal is to implement a composed service for furniture purchasing and delivering, the P&S service, bycomposing two independent existing services: a furniture purchase service Producer, and a delivery service Shipper. TheP&S service should allow a User to ask for desired products that should be delivered at a desired location, see Fig. 1.The component services are not atomic, i.e., they cannot be executed in a single request–response step; they are statefulprocesses, and require establishing an interaction protocol that involve different sequential and conditional steps. In ourexample, the Producer accepts requests for given products. If the requested product is available, it provides some informationabout it, among which for instance its size; then, if the requester acknowledges the interest to buy, the Producer makes anoffer with a cost and a production time. This offer can be accepted or refused by the requester. In both cases the Producerterminates execution, with success or failure, respectively.Also the behavior of the Shipper is stateful. Once it receives a request to deliver an object of a given size to a certainlocation, the Shipper may refuse to process the request, or may produce an offer where the cost and the time to deliver arespecified. In the latter case, the invoker can either confirm the order, or cancel it.Similarly, the User performs a two-step interaction with the P&S: first it sends his/her request, then it gets either arefusal or an offer, and finally (in the latter case) it either confirms or disconfirms the request. Notice that, as shown inFig. 1, the user is perceived analogously to the Shipper and Producer, as one of the components with which P&S will need tointeract; as such, we assume the user’s behavior to be modeled as a service, representing a software front-end to a humanentity.The goal of the P&S is to sell a product at a destination, as requested by a customer. To achieve this, the P&S has tointeract with the customer on the one side and with Producer and Shipper on the other side, trying to reach a situationwhere the three interactions reach a successful completion, i.e., three final confirmations are obtained. Clearly, the goal ofselling a product at destination may be not always achievable by the P&S, since this depends on decisions taken by thirdparties that are out of its control: the Producer and the Shipper may refuse to provide the service for the requested productand location (e.g., since the product is not available or the location is out of the area of service of the shipper), and thecustomer may refuse the offer by the P&S (e.g., since it is too expensive). If this happens, the P&S should step back fromboth orders and it should not commit to the customer. Indeed, we do not want the P&S to buy something that cannot bedelivered, as well as we do not want it to promise a product at destination that it will not be able to buy.The order in which the interactions with the different services are interleaved in the implementation of the P&S iscritical. For instance, when the P&S gets a request for a given item from a customer, it has to obtain the size of the itemfrom the producer before it can call the shipper. Two offers, from the Producer and from the Shipper, are necessary to theP&S in order to make an overall offer to the customer. Moreover, the offers from Producer and Shipper can be acceptedby the P&S only after the customer has accepted the offer from the P&S. The necessity to figure out and realize all theseconstraints makes the implementation of the P&S a complex task, also in simple scenarios like the one described above.320P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Table 1Synopsis table for wsdl.ConstructMeaningtypesmessageThe types element encloses data type definitions that are relevant for the exchanged messages. In particular, types are used via thetype system in the wsdl XML schema definition (XSD for short).Messages consist of one or more logical parts. Each part is associated with a type from some type system. wsdl defines twodifferent message-typing attributes: element, which refers to an XSD element using a qualified XML name, or type, which refers toan XSD simpleType or complexType (using, again, a qualified XML name).portTypeA portType is a named set of operations.operationAn operation is a named entity that specifies, through the output and input elements, the abstract message format for the solicitedrequest and response, respectively. wsdl defines four types of operation:• One-way, the operation can receive a message but will not return a response• Request–response, the operation can receive a request and will return a response• Solicit–response, the operation can send a request and will wait for a response• Notification, the operation can send a message but will not wait for a responseportWhile portTypes define abstract functionality by using abstract messages, ports provide actual access information, includingcommunication endpoints and (by using extension elements) other deployment-related information, such as public keys forencryption. These are associated by means of so-called bindings.serviceA service is viewed simply as a group of ports.2.1. Specifying services: the ws-bpel and wsdl languagesIn this paper, we assume that the component and composed services are expressed using the ws-bpel language. ws-bpel (the “Business Process Execution Language”) [1,31] is the de-facto standard for describing the stateful behavior ofWeb services. In ws-bpel, a set of atomic communication operations (i.e., invoke, receive, and reply activities) are combinedwithin a workflow that defines the process implemented by the stateful service. The atomic communications correspondto atomic Web service operations, and are defined in a wsdl (Web Service Description Language [28]) specification. wsdlis an extensible markup language (XML) format, and is the standard language for describing operations implemented asWeb services along with the input and output data of these operations. Table 1 reports a synopsis of the fundamental wsdlkeywords, together with their informal semantics.Table 2 reports the key ws-bpel constructs, providing their informal semantics. It is important to remark that there aretwo flavors of ws-bpel, namely executable ws-bpel programs, that are used to implement the process defining a service,and can be run by standard engines such as the Active BPEL Open Engine or the Oracle BPEL Process Manager [3,69],and abstract ws-bpel specifications, which are used to publish the interaction protocol with external Web services. Thatis, an abstract ws-bpel process is meant to describe a public interface, whereas an executable process defines an actualimplementation. ws-bpel programs are identified as being abstract or executable by appropriately setting an abstractProcessattribute, and share the vast majority of the constructs; however, only in abstract programs it is possible to hide details overthe assignment of variables and the flow control conditions (by an opaque construct).Given our choice for the specification of services, our general statement of the composition problem can be describedas follows: “Let W be a set of component services, whose interactions are described as abstract ws-bpel specifications, and let ρ besome composition requirement that describes the desired functionalities of a composed service. The problem of service composition forW and ρ requires constructing a new executable ws-bpel that, when executed, satisfies the requirements ρ by interacting with thecomponent services in W ”.In the following, prior to detail our view of composition requirements, we go more in detail about our reference scenario,discussing the component service specifications that serve as input to the composition problem in that case.Example 2. Fig. 2 presents the wsdl specification for the Producer, abridged from technical details irrelevant to our discus-sion. The wsdl specification starts with the definition of the data types used in the interactions. In the case of the Producer,they are the requested Item and its Size, Cost, and production Delay. The actual definition of these data types is notrelevant to our purposes, and is also omitted from the wsdl specification.The wsdl specification then describes the structure of the messages relevant for the interactions with the Producer.According to the specification, a requestMsg message contains the requested article, art. The infoMsg and offerMsgmessages contain, respectively, the size and the production cost and delay for an article. The other three messages(unavailMsg, ackMsg, nackMsg) do not carry data values.Then, the wsdl specification defines the invocation and reply operations provided by the service. Operations are collectedin port types that are associated to different communication channels of the producer service with its partners. In ourexample, we define two port types, namely P_PT and PC_PT (for “Producer Port Type” and “Producer Callback Port Type”P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361321Table 2Synopsis table for ws-bpel.ConstructMeaningpartnerLinkvariableassignIn ws-bpel a Web service that is involved in the process is always modeled as a partnerLink. Every partnerLink is characterized by apartnerLinkType which is defined in the wsdl definition. The role of the process in the communication is specified by a myRoleattribute, and the role of the partner is specified by the attribute partnerRole.Variables offer the possibility to store data. The messages that get stored are most of the time either coming from partners orgoing to partners. Variables also offer the possibility to store data that is only state based and never send to partners. There arethree types of variables: wsdl message type, XML Schema simple type and XML Schema element.It allows to copy the data from one source (a variable or an expression written using XPath, the XML path language, to address andcombine parts of variables) to a target variable. Only in abstract processes, an assignment source can be opaque, in which case thetarget variable is meant as being nondeterministically assigned with any value in its domain range. This may reflect into anondeterministic service behavior, as the variable can be used within control constructs. Finally, the assign activity can be toperform dynamic binding of partners, by copying endpoint references to and from partner links.correlation setEach correlation set in ws-bpel is a named group of properties that, taken together, serve to define a way of identifying anapplication-level conversation within a business protocol instance. After a correlation set is initiated, the values of the propertiesfor a correlation set must be identical for all the messages in all the operations that carry the correlation set and occur within thecorresponding scope until its completion.receivereplyinvokesequenceswitchwhilepickflowA receive activity specifies the partner link it expects to receive from, and the port type and operation that it expects the partner toinvoke, and a variable that is to be used to store the message data received. In addition, receive activities play a role in thelife-cycle of a business process. The only way to instantiate a business process in ws-bpel is to annotate a receive activity with thecreateInstance attribute set to “yes”.A reply activity is used to send a response to a request previously accepted through a receive activity. Such responses are onlymeaningful for synchronous interactions. An asynchronous response is always sent by invoking the corresponding one-wayoperation on the partner link.This construct is used to invoke a service operation. Such an operation can be a synchronous request/response or an asynchronousone-way operation. ws-bpel uses the same basic syntax for both with some additional options for the synchronous case. Anasynchronous invocation requires only the input variable of the operation because it does not expect a response as part of theoperation. A synchronous invocation requires both an input variable and an output variable.A sequence activity contains one or more activities that are performed sequentially, that is, in the order in which they are listedwithin the corresponding XML element.The switch activity consists of an ordered list of one or more conditional branches defined by case elements, followed optionally byan otherwise branch. The case branches of the switch are considered in the order in which they appear. The first branch whosecondition holds true is taken and provides the activity performed for the switch. If no branch with a condition is taken, then theotherwise branch is taken.The while activity supports repeated performance of a specified iterative activity. The iterative activity is performed until the givenBoolean loop condition no longer holds true.The pick activity awaits the occurrence of one of a set of events and then performs the activity associated with the event thatoccurred. After a pick activity has accepted an event for handling, the other events are no longer accepted by that pick. Possibleevents are the arrival of some message in the form of the invocation of an operation, which is handled within a correspondentonMessage sub-activity analogous to a receive, or a “timer alarm”, handled within an onTimer sub-activity. Similarly to the receiveactivity, a pick can initiate a process by setting the createInstance attribute (in which case no timer events are permitted).The flow activity is the most visible remnant of the WSFL language, which was into the ws-bpel specification. Its most fundamentaleffect is to enable concurrency of activities: a flow completes when all of the activities it contains have completed. Furthermore, toallow for complex concurrency scenarios, the flow construct allows the expression of synchronization dependencies between theenclosed activities. In particular, execution of an activity can be dependent on other activities and certain conditions. Thesynchronization dependencies are expressed by means of link constructs A named link is defined as a sub-element of the flowactivity, and then attached to a source and a target activities. As a consequence, the target activity will only be executed upontermination of the source activity.respectively), which will be used for the incoming requests and the outgoing messages by the Producer service.1 Finally, thewsdl specification defines bi-directional links between the service and its partners. In our case, there is only one of suchlinks, P_PLT, between the Producer and the customer invoking it.Fig. 3 shows the abstract ws-bpel of the Producer (again, abridged from some low-level technical details). It starts witha declaration of the links with external parties that are exploited within the process. In this case, only one external partnerexists, the client of the producer. The type of the link is P_PLT (see the wsdl file), for “Producer Partner Link Type”,1 In our example, we only exploit one-way operations, i.e., operations that consist of a communication from the sender to the receiver. wsdl and ws-bpel also support invoke-and-response operations, which define an input message and an output message (plus a failure message to manage non-nominaloutcomes). Since the invocation has a non-blocking behavior in ws-bpel, invoke-and-response operations can always be realized as pairs of unidirectionaloperations. Therefore, in the paper we can limit to discuss unidirectional operations without giving up generality, based on the possibility of such atranslation.322P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 2. The wsdl for the Producer process.and the two port types associated with it (P_PC and P_PT) are given separate roles that correspond to the direction of themessages, following their definition.Then the variables that are used in input/output messages are declared (see lines 5–13), together with their typing,referring either to the types defined in the wsdl file, or to standard wsdl types (e.g. xsd:boolean). The rest of theabstract ws-bpel specification (lines 14–55) describes the interaction flow.The Producer is activated by a customer request of information for a specified product (see the receive instruction atline 15). The item specified by the requester is stored in variable reqVar. The operation="request" identifies whichwsdl operation is performed. The partnerLink="client" and portType="P_PT" fields serve to identify the linkP. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361323Fig. 3. The abstract ws-bpel for the Producer process.along which the request is received (of course, these fields become useful when there are more than one partners for thews-bpel process).At lines 17–19, Producer decides on the availability of the requested product. We remark that in this case, by markingthe source of the data as “opaque”, the abstract ws-bpel hides the actual implementation of the internal logic that governsthe Producer’s choice. This capability of abstract ws-bpel is crucial whenever, as it is often the case, a business entity doesnot want to disclose details about internal procedures and choice criteria to the world via its Web exposure. Then, in theswitch activity named checkAvail, the service decides on the basis of the availability.If the Producer is not available, it signals this to its partner (see activity invoke on line 22) and terminate; otherwise,it prepares and send the information regarding the size of the required item (lines 26–29).The information regarding the size is (internally and opaquely) computed within the assign statement namedprepareInfo.After sending the information, the Producer suspends (instruction pick at line 31), waiting for the customer either to ac-knowledge or to refuse to proceed to buy the specified product. If the customer refuses to proceed (statement onMessageon line 32), the Producer terminates the execution. If, otherwise, a message is received that corresponds to operation ack(line 35), meaning that the customer confirms its interest in the item, then the Producer prepares and sends and offer to324P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 4. The abstract ws-bpel for the User process.the customer, which contains a cost, and an expected delivery time (lines 35–41). Again, opaqueness is used to hide theactual way in which the production time (line 38) and the cost (line 39) are computed.After sending the offer, the Producer suspends waiting for a final acknowledgment of refusal of the offer by the client.and terminates after receiving it either with success or failure, respectively (lines 43–50).The wsdl and abstract ws-bpel specifications for the Shipper are similar to that of the Producer, so we do not reportthem.For the purposes of composition, we assume to start from a situation where the abstract ws-bpel of the Producer and ofthe Shipper are published, and available as input to potential users of the services, as well as to the composition task. Ontop of this, we also assume the availability of a description of the interaction protocol that the User is intended to carry outwith the composite service: the implementation of the P&S will depend on the protocols of all of the interacting partners,i.e., the Producer, the Shipper, and the User.Example 3. Fig. 4 shows the abstract ws-bpel of the User. After determining the content of its request (lines 14–17), theuser invokes the composite service (line 18) and suspends for a reply. The reply can signal that the request cannot besatisfied, or propose an offer. In the first case, the service simply terminates (line 23). In the second case, the user thendecides whether to accept or not such offer, and signals his decision before terminating (lines 24–40).2.2. Goal and solutionConsidering our reference example, the goal of the composition task is to generate the executable code of the P&S servicein such a way that the following criteria are obeyed: (i) sell a product at destination whenever possible, and (ii) wheneverthis is not possible, guarantee that no pending commitments with the partners are left, that is, handle consistently all thecases where some partner prevents the successful selling to take place. Of course, in achieving this goal, the P&S has torespect the protocols described by the three abstract ws-bpel specifications of Producer, Shipper, and User. Furthermore,P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361325we impose additional crucial constraints, capturing the way data exchanged between the services are related as well asthe nature of the business: namely, P&S must obey a constraint that associates the cost paid by the User with the pricesproposed by the Producer and Shipper, including a profit margin.Example 4. Fig. 5 shows a possible implementation of the P&S as an executable ws-bpel process.As we see, the service features three partnerLinks, one for each of the three component services it has to in-Its variables refer to the typed declared in the wsdl files associated to each component; for instance,teract with.the U_RequestVar has the requestMsg type declared for the User, which contains an item and a location, whileS_RequestVar has the requestMsg type declared for the Shipper, and contains a size and a location.The P&S is activated by a request from the customer — the request specifies the desired product and delivery location(line 28). The P&S asks the Producer for information about the product, namely its size (line 35). If the item can beproduced, then the Producer gives the P&S information about the size, the cost, and the time required for the service(line 45). The P&S then asks the delivery service the price and time needed to transport an object of such a size to thedesired locations (line 58). If the Shipper makes an offer to deliver the item, then the P&S sends an aggregated offer to thecustomer. This offer takes into account the overall production and delivery costs and time (line 93). If the customer sends aconfirmation, the final acknowledgment is sent both to the Producer and to the Shipper (lines 99–108), via a flow constructthat specifies that the associated invoke activities can be executed concurrently. As a consequence, all three componentservices terminate successfully.While we have described only the nominal flow of interaction, the executable ws-bpel of the P&S takes also into accountthe cases in which the service cannot succeed, i.e., the cases in which either the Producer cannot provide the product, orthe Shipper cannot deliver, or the customer does not accept the offer, by canceling the pending orders (see lines 41, 66–69,and 114–123) (see Figs. 5 and 6).Notice that the executable ws-bpel for the P&S is much more complex than any of the abstract components. Indeed,while the abstract ws-bpel s only describe the protocols exported by the partners, the executable P&S must implementall the communication with the three component services (the User, the Producer and the Shipper), as well as all thecomputations over the internal variables, e.g., those computing the total cost and time for the offer to the customer.It is important to remark that the component and composed services in our P&S example comply with the assumptionsdiscussed at the start of this section. First, every component service is guaranteed to terminate in a finite number of steps;this is trivially established, in this case, since the User, Producer and Shipper protocols are completely loop-free. Second,the requirement expressed for the P&S service implies the termination of all partners activated by the orchestration, eitherby succeeding in the transaction, or by unrolling all commitments. That is, the kind of composition requirement is one ofreachability: upon termination of the orchestration, a certain set of properties must hold. As a consequence of these twoassumptions, also the composed P&S service is loop-free. Finally, although the types of the variables of the componentservices are not explicitly reported and may be of infinite range, we remark that, insofar as the variables are many-valued,the structure of a P&S service that orchestrates them according to the requirements is independent of their ranges andconcrete values. Indeed, we observe that if one considers components with single-valued variables, it is possible to devise aP&S orchestrator which, while satisfactory in that specific case, may not work in the general case: since the values producedby component services are predictable regardless of their inputs, P&S might exploit this, and route foreseen results a priorifrom receiving them. Vice versa, as soon as one considers components whose variables have two or more values, theorchestration must actually ask component services to operate and produce outputs which then can be routed accordingly,considering all possible cases. That is, in our scenario, considering binary (disjoint) types for the variables of the componentservices is enough to separate all conceptually distinct behaviors of the components, and as such, to obtain generic P&Sorchestrator. In general, in this paper, we assume that, in case it is needed, a suitable finitization of component services isidentified in a pre-processing phase, and we leave a more detailed discussion of finitization techniques in Section 8.3. Processes as state transition systemsIn this section, we discuss how services expressed using the standard ws-bpel language can be recasted into a well-known formal model which can be more easily manipulated to solve the composition problem, and we show how ourapproach works on the reference example. Specifically, we encode ws-bpel processes as finite state transition systems. Whileour choice to adopt finite STSs will require particular care to appropriately encode (possibly infinite-state) services, it guaran-tees the possibility to build upon effective synthesis and representation techniques which are not available for infinite-statetransition systems. In the following, we first formally define the notion of STS, and then describe the way services can betranslated into STSs and back.3.1. State transition systemsA finite state transition system (STS) describes a dynamic system that can be in one of its possible states (some of whichare marked as initial states). A state can be understood as a collection of propositional properties that hold in that state, andit can evolve to new states as a result of performing some actions. In a state transition system, actions are distinguished in326P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 5. The executable ws-bpel for the P&S process (pt.1).input actions, which represent the reception of messages, output actions, which represent messages sent to external services,and a special action τ , called internal action. The action τ is used to represent internal evolutions that are not visible toexternal services, i.e., the fact that the state of the system can evolve without producing any output, and independentlyfrom the reception of inputs. A transition relation describes how the state can evolve on the basis of inputs, outputs, or ofP. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361327Fig. 6. The executable ws-bpel for the P&S process (pt.2).the internal action τ . Finally, a labeling function associates to each state the set of properties that hold in the state. Theseproperties will be used to define the composition requirements.Definition 5 (State transition system). A state transition system Σ defined over a set of propositions Prop is a tuple(cid:3)S, S 0, I, O, R, L(cid:4) where:• S is the finite set of states;• S 0 ⊆ S is the set of initial states;• I is the finite set of input actions;• O is the finite set of output actions;• R ⊆ S × (I ∪ O ∪ {τ }) × S is the transition relation;Prop is the labeling function.• L : S → 2We require that I ∩ O = ∅ and that τ /∈ I ∪ O.328P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361We now recall some standard definitions on state transition systems, see e.g. [56,7,32]. We say that an action a ∈ (I ∪(cid:11)) ∈ R. A state of anO ∪ {τ }) is applicable on a state s ∈ S, denoted with Appl(a, s), if there exists a state sSTS is final if no action a ∈ (I ∪ O ∪ {τ }) is applicable in s, i.e., if there is no transition leaving s. The execution of an STS isrepresented by its set of possible runs, i.e., of sequences of states s0, s1, . . . such that s0 ∈ S 0 and (si, a, si+1) ∈ R for somea ∈ I ∪ O ∪ {τ }. In general, such executions may be finite or infinite.2 A run is said to be completed if it is finite, and ifits last state is final. A state s ∈ S will be said reachable if and only if either s0 ∈ S 0, or there exists a state s0 ∈ S 0 and asequence s0, s1, . . . , sn such that sn = s, and for all i = 0, . . . , n − 1 there is some a ∈ (I ∪ O ∪ {τ }) such that (cid:3)si, a, si+1(cid:4) ∈ R.We will denote the set of reachable states of the STS Σ with Reachable(Σ) ⊆ S.(cid:11) ∈ S s.t. (s, a, sFinally, we say that a state s ∈ S is divergent if there exists an infinite sequence of τ transitions starting from s, i.e., ifthere is an infinite sequence of states s = s1, s2, s3, . . . such that (si, τ , si+1) ∈ R for all i (cid:2) 1. Infinite τ -sequences startingfrom divergent states correspond to behaviors where the service never interacts with the domain, and thus cannot becontrolled or accessed in any way. For instance, in a ws-bpel implementation of a service, this might originate from havingan infinite while loop whose body never performs any communication. Having in mind that the main purpose of servicesis to interoperate with external entities, it is clear such a behavior is undesirable and corresponds to a bad design of theservice. Divergent states may as well appear due the adoption of inappropriate abstractions when encoding services in termsof STSs. For instance, consider a service containing a while loop that repeatedly increments a variable v and exits as soonas v gets a fixed value. If the encoding of the service abstracts away that variable, the entry point of that loop is mappedinto a divergent state. We assume both that services are designed correctly, and that, in case an abstraction step is neededto encode a service into an STS, such abstraction does not originate divergent states. As such, in the rest of this paper, wewill assume that STSs will not have divergent states.Properties can be combined using the standard propositional logical connectives, and we adopt a standard notion ofsatisfaction to identify whether a formula corresponding to a combination of properties is valid onto a given state.Definition 6 (Satisfaction of property formula). Let Σ = (cid:3)S, S 0, I, O, R, L(cid:4) be an STS defined over a set of propositions Prop.Let ρ, φ, ψ be propositional formulas over Prop. Then state s ∈ S satisfies ρ, denoted s |(cid:12) ρ, if and only if one of thefollowing holds:• if ρ ∈ Prop, then ρ ∈ L(s);• if ρ = ¬φ, then s |(cid:12) φ does not hold;• if ρ = φ ∨ ψ , then s |(cid:12) φ holds, or s |(cid:12) ψ holds;• if ρ = φ ∧ ψ , then s |(cid:12) φ holds and s |(cid:12) ψ holds;• if ρ = φ (cid:12)⇒ ψ , then either s |(cid:12) φ does not hold, or s |(cid:12) ψ holds.3.2. Translating ws-bpel services as STSsWe have implemented a translation that associates a STS to each component service, starting from its abstract ws-bpelspecification. The translation currently covers a significant subset of the ws-bpel language, which we report in Table 2.More precisely, we support all ws-bpel basic and structured activities, like invoke, reply, receive, sequence, switch, while, pick,onMessage, terminate, empty and flow (without links). Moreover we support restricted forms of assignments (specifically, werestrict the expressions that can appear in the from part of the copy statements) and of correlations.3The translation works in two steps, which are both conceptually simple, and is discussed at length in [49,57]; we givehere a compact, yet comprehensive summary of its workings. In a nutshell, the first step translates a service into an automawhose states are represented by means of variables whose range may not be determined; as such, this is in general aninfinite-state automa. In the second step, all variables are associated to finite ranges, therefore obtaining a finite-state tran-sition system. For both steps, we adopt a convenient, compact and fairly standard symbolic representation, where states arerepresented using a fixed set of variables, and actions and transitions are represented by means of schemata. Specifically,our representation has the following features:(1) The states of the STS correspond to complete assignments to a set of typed variables, corresponding to the parts of thestructured ws-bpel variables; on top of these, a special variable pc (for “program counter”) is used to represent thecurrent execution step of the service.2 We remark that we do not rely on a bisimulation semantics, and we do not exploit any bisimilarity relation to define equivalent STSs based on runs.We will use runs exclusively to identify infinite and finite executions of an STS (which may or may not traverse some states more than once).3 The considered subset does not deal at the moment with ws-bpel constructs like scopes, fault, event and compensation handlers, which are used to dealwith run-time events into concrete ws-bpel specifications. This choice keeps the translation simple, and is pragmatic. In fact, in our experience, we neverfound cases where some of the abovementioned constructs appears in an available abstract ws-bpel specification. As such, the considered subset appearsexpressive enough for describing the way business processes are actually exposed using abstract ws-bpel. Nevertheless, extensions are of course possible,as we discuss in Section 8.P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361329(2) The input and output actions of an STS are represented in terms of schemata, composed of an action name and a (pos-sibly empty) set of argument types. In general, an action schema corresponds to several possible action instantiationsinside the STS, one for each combination of ground values associated to the arguments.(3) It is possible to declare functions, taking as input some typed arguments and returning one typed argument.(4) The transitions are also represented schematically. A transition schema corresponds to a set of transitions of the STS,and defines a set of preconditions, at most one input or output action, and a set of post-conditions. Pre-conditionsidentify source states by postulating over the value of the pc variable and, possibly, over values of other (non-pc) statevariables. An action is described by an action name, and as many (non-pc) variables as specified in the argument list ofthe action declaration. Similar to pre-conditions, post-conditions define the target states by postulating over the valuesof the pc and, possibly, non-pc variables, which can be assigned with values, variables, or functional expressions.This schematic representation is of great practical help for two main reasons. First, its schematic nature makes it verycompact. Second, it allows a simple translation of the declaration of ws-bpel variables, functions and input/output actionsinto corresponding declarations inside the schematic STS.More in detail, in the first step of the translation, we convert the service into such a schematic representation, using bothenumerative types and ‘abstract’ types to describe variables: enumerative types correspond to enumerative ws-bpel types,while ‘abstract’ types, whose range is not yet defined at this stage, correspond to ws-bpel types whose range is infinite.In this step, the translation of the workflow body of the ws-bpel specification takes place in a compositional way: foreach activity, a translation pattern is defined, and it is enough to recursively analyze the structure of the process, and totranslate each ws-bpel activity in turn.More specifically, a basic ws-bpel activity (i.e. invoke, reply, receive, onMessage, assign, empty, terminate) is directly trans-lated into a single loop-free STS featuring one initial state, one final state, and one or more transitions. Table 3 reportsthe translation schemata for the receive, empty (synchronous and asynchronous) invoke activities, and for assignments ofvariables, using a graphical notation to depict the schematic STS representation explained above. In the graphical notation,a transition schema is represented as an arc between two nodes. The nodes are labeled with the conditions over the pcvariable, while pre- and post-conditions on non-pc variables appear as labels at the start and end of the transition. Inparticular, for the sake of easier understanding, we use curly braces to denote pre-conditions, and square brackets to denotepost-conditions. Input and output actions label the arcs, and are identified by prepending them with a “?” and a “!” marksrespectively. Transitions that feature neither input nor output actions are marked with the internal action τ . We remark herethat the STS translation for the basic reply, onMessage, terminate activities correspond to those for invoke, receive, empty ac-tivities respectively: at the level of STSs, reply and invoke both map to output actions, receive and onMessage both mapto input actions, and terminate and empty both map to τ actions. The differences between the respective pairs of activitiesreside exclusively at the syntactic ws-bpel level and therefore have no impact at the level of composition of STSs. Of course,when translating the composed service back from STS into ws-bpel, some care must be taken so to translate correctly e.g.an STS output either into an invoke or a reply, by recovering some information which was abstracted away during theirconversion as STSs. Concretely, this is realized by storing some simple ‘action correspondence’ maps when stepping fromws-bpel to STS, and recovering information from them when going back to ws-bpel.Based on the above translations of basic activities, a structured ws-bpel activity (sequence, pick, switch, while, flow) istranslated by first translating its sub-activities, and then linking the resulting STSs (namely their initial and final states) toobtain a single STS which corresponds to the structured activity, and which features a single initial state (the entry point tothe activity) and a single final state (its exit point). Table 4 gives an account of such a translation mechanism, using again agraphical notation (and, for the flow activity, showing the case of two activities; a generic flow of n activities results into anSTS allowing every possible interleaving combination of these n activities).This first phase of the translation is concluded by a simple reduction phase, where transitions that do not perform anyinput/output, nor affect the values of variables, are eliminated, and their corresponding entry and exit states are unified.Then, the second step of the translation consists of the instantiation of the schematic representation obtained so far, toget to a finite STS model. In the representation we adopted, this boils down to identify finite ranges that replace the abstracttypes, and, concerning possibly existing interpreted functions, to describe their behavior on ground values.In this phase, it is crucial that all the relevant behaviors of the original service are nonetheless captured by the groun-dized service; as we will discuss in Section 8, it is easy to devise such an instantiation in a naive way, but this can lead toproblems related to the large model size; on the contrary, looking for size-optimal instantiations is harder. In the follow-ing, we will work under the hypothesis that either the starting ws-bpel specification is finite-state, or that such a suitablefinitization is identified as a pre-processing step.Once finite variable ranges and interpreted function behaviors are made explicit, our schematic representation can bevery easily mapped into the formal model of the STS. First, interpreted functions are compiled away as constants, whileuninterpreted functions are mapped into sets of variables corresponding to their applications on ground values, whosevalues are unknown but remain constant at each transition. Then, the set of states simply consists of all the combinatorialassignments of variables, while the transitions correspond to the instantiations of assignments and input/output actionswith the concrete values of the variables and of the input/output arguments. Finally, the set Prop of properties over whichthe STS is defined consists simply of all the possible value assignments to each typed variable and ground function term,and the labeling function is the obvious one. It is important to remark, however, that while this groundization is required330P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Table 3Translating basic ws-bpel activities to STSs.ws-bpel activityreceiveoperation="op" variable="x"STSinvokeoperation="op"inputVariable="x"invokeoperation="op"inputVariable="x1"outputVariable="x2"assigncopy from variable="x1"part="p1"to variable="x2" part="p2"assigncopy from expression="fun(y)"to variable="x" part="p"emptyfor our theoretical development, our implementation will largely operate over schematic STS representations, to leverage ontheir compactness.We illustrate the translation through the example of the Producer abstract ws-bpel introduced in the previous section,breaking it into the two translation phases.Example 7. Fig. 7 shows the STS for the abstract ws-bpel process of the Producer, represented in the internal language thatis used by the ws-bpel to STS translator. The specification starts with a list of TYPEs (Article, Size, Cost, Delay)exploited in the STS, which are derived from the wsdl specification of the Producer. Then, the STATE of the STS is defined,using a set of typed variables, among which the pc “program counter” variable. Notice that the values of pc are closelyrelated to the start points of activities. For example, pc has value getRequest when the process is waiting to receiveP. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361331Table 4Translating structured ws-bpel activities into STSs.ws-bpel activitysequenceactivity a1activity a2STS translationswitchcase condition="c1"activity a1case condition="c2"activity a2otherwiseactivity a3while condition="c"activity apickonMessageoperation="op1"variable="var1"activity a1onMessageoperation="op2"variable="var2"activity a2flowactivity a1activity a2a request for an item, and value checkAvail when it is ready to check whether the item is available, and these valuescorrespond to the receive and switch statements at lines 15 and 20 of the ws-bpel in Fig. 3, respectively. In fact, wheneverws-bpel associates a name to an activity, our translation uses that name as the value attained by the program counter atthe start of that activity; for instance, line 51 is associated to the activity named prepareInfo in the code. Otherwise,a unique pc value is created by the translator (e.g. in the case of the (cid:3)/pick(cid:4) activity at line 31). If an activity takes placeimmediately prior to termination, its name (if defined) is also used to describe the final value of the Program Counter,prepending a DONE_ prefix (see for instance line 59 and line 60).The other variables that define the state of the STS (e.g., offerVar_delay, offerVar_cost) correspond to the partsof the ws-bpel message variables. In the INITial states, all the variables are undefined, except pc which is set to the initialws-bpel activity main.The INPUT declarations represent schematically the input actions of the STS, modeling all the incoming requests to theprocess and the information they bring (i.e., request is used for the receiving of the product request, and has a singleparameter of type Article). Similarly, the OUTPUT declarations model the outgoing messages (e.g., unavail is used332P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 7. The STS for the Producer process.when the article is not available in stock, and offer is used to bid the production of an item at a particular price and witha particular production time).The schematic presentation of the transitions of the STS is given in terms of a set of TRANS statements. Each TRANSstatements essentially corresponds to an arc in the representation of Tables 3 and 4; as discussed above, it defines itsapplicability conditions on a set of source states, its firing action, and the corresponding destination states. For instance,“pc = main -[TAU]-> pc = getRequest” (line 45) states that an action τ can be executed in any state where theproperty pc = main holds, leading to a state where pc = getRequest holds (and all other properties have retainedtheir former value). Transitions such as the one above are directly associated to ws-bpel activities, e.g. in this case thestarting main activity; other transitions are inserted by the translation mechanism, e.g. to link two activities that must beperformed in sequence (see for instance “pc = seq2 -[TAU]-> pc = prepareOffer”, line 56). ws-bpel assignmentsare mapped into transitions whose effects also affect variables different from the program counter; for instance, this is thecase for the assignment at line 52, corresponding to line 27 in the ws-bpel code. Notice that at this stage, opaque ws-bpelassignments correspond to giving a variable any possible value in the range defined by its type, denoted by the “Values”notation for abstract types, and with sets of concrete values for finite types. Fig. 8 reports the graphical representation ofthe STS for the Producer, corresponding to its schematic textual representation of Fig. 7.Once the types (Article, Size, Cost, and Delay) are instantiated with finite ranges, as required by our finite-ness assumption, we easily obtain a concrete finite-state STS. States S correspond to assignments to the variables, inputsI and outputs O to the instantiations of the messages defined in the INPUT and OUTPUT sections. Each TRANS clauseof Fig. 7 corresponds to the different elements in the transition relation R: e.g. “pc = checkAvail, availVar =False -[TAU]-> pc = sendUnavail” generates different elements of R, depending on the values of variables re-qVar_article, offerVar_cost and so on. The properties associated to the STS are expressions of the form <vari-P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361333Fig. 8. The graphical representation of the STS for the Producer process.able> = <value>, where <variable> is one of the variables in the STATE declaration, and <value> one of itspossible values. The labeling function is the obvious one. As remarked, however, our implementation will never explicitlyproduce a groundized STS represented with a human-readable language such as the one described so far. Rather, as we willdiscuss more extensively in Section 5, it will leave to low-level symbolic mechanisms based on Binary Decision Diagrams[26] the enactment and representation of the groundization.A similar mapping from ws-bpel process to STS holds also for the Shipper and the User processes.334P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–3613.3. Translating STSs as ws-bpel servicesOur composition approach also requires the ability to convert back an STS into ws-bpel, since it extracts the desiredorchestration as an STS. This process is actually easier than that of obtaining STSs from ws-bpel specifications, due to a keyobservation on the nondeterministic nature of services.Namely, in general, STSs such as those resulting from ws-bpel conversion may feature nondeterminism of two differentnatures, often referred to as “external” and “internal” nondeterminism. The first, “external” nondeterminism, is related to thefact that the domain interacting with an STS may behave in ways which the STS may not predict a priori. For instance, in ourexample, an offer given by the Producer may be answered positively or not, and this is outside the control of the Producer.In these cases, an STS must be able to handle different requests, responding adequately to the possible behaviors of thepartners that interact with it. This kind of nondeterminism occurs for instance in state pc = pick1, where messages ackand nack can be received. The second, “internal” nondeterminism, refers to the fact that an STS may evolve in differentways according to internal decisions that are not explicit in the STS. For instance, the fact that a variable can be assignedone of several values (e.g. availVar in state pc = setAvail) models the presence of a decision on the variable value inan “abstract” way, without describing the logics behind such decision within the STS. Of course, this can reflect in differentSTS behaviors driven on the basis of the value of the availVar variable. Similar considerations hold for states wheredifferent output transitions can be performed. Example 7 shows that both forms of nondeterminism are necessary to modelthe published services which we intend to compose (in our case, Producer, Shipper and User).However, it is important to remark that, for what concerns the executable orchestration services which we aim to syn-thesize, we shall focus on STS that only feature the “external” nondeterminism which is needed to respond correctly tovarious messages coming from the component services. Indeed, we need to avoid generating composite services featuring“internal” nondeterminism, since, in order for a service to be executable on an engine, it must not contain any “abstract”choices which would make its run-time behavior not uniquely determined.We will capture this distinction by calling an STS deterministic if it does not contain “internal” nondeterminism (while itmay contain “external” nondeterminism). Basically, a deterministic STS has a single initial state and admits, for each state,either a unique τ -transition, or a unique output transition, or a nonempty set of input transitions — as formally spelled outin the following definition:Definition 8 (Deterministic STS). An STS Σ = (cid:3)S, S 0, I, O, R, L(cid:4) is deterministic if and only if:(1) |S 0| = 1;(2) for each state s ∈ S, if (s, τ , s(3) for each state s ∈ S, if (s, a, s(cid:11)) ∈ R, then no other transition from s belongs to R;(cid:11)) ∈ R, with a ∈ O, then no other transition from s belongs to R.The fact that, in our framework, we aim to synthesize deterministic automata implies a significant simplification forwhat concerns the translation of such synthesized STSs to (executable) ws-bpel. In fact, due to the deterministic and loop-free nature of the orchestration STSs we generate, such a translation turns out to be conceptually simple. The extraction ofinput/output ws-bpel operations is immediate, as well as that of a set of ws-bpel variables that represent the STS variables(apart from the pc and the variables associated to uninterpreted functions). For what concerns the reconstruction of thews-bpel workflow starting from the set of STS transitions, we first perform a simple optimization step that eliminates all τ -transitions which only affect the program counter. Then, it is enough to perform a recursive top-down visit of the transitiontree starting from the initial state, applying transformation patterns that essentially invert those in Tables 3 and 4. Forinstance, output transitions are converted into invoke or reply (depending on whether their corresponding operations in thews-bpel components are asynchronous or synchronous). Assignments are converted into assign activities. An input transitionwhich originates alone from a state is converted into a receive activity; tuples of input transitions sharing their starting statecorrespond to a pick and a tuple of onMessage sub-activities, and so on. Transitions that feature preconditions over non-pcvariables originate switch activities. The sequence activity is inserted at the start, and inside any branch of a structuredactivity (a case within a switch, or an onMessage within a pick).4. Modeling the composition problemIn this section, based on our interpretation of services in terms of STSs, we formalize the problem of composing Webservices, and we describe its solution by means of planning techniques. Our modeling and solution rely on the compositionframework represented in Fig. 9. Its inputs consist of a set of component services W 1, . . . , W n and a reachability composi-tion requirement ρ, and its output is a novel process W that can be deployed and run to coordinate W 1, . . . , W n in orderto achieve ρ. Internally, the framework goes through two crucial steps: constructing a domain Σ(cid:16), which is an STS thatrepresents all the possible behaviors of the component services that need to be controlled, and identifying a suitable “con-troller” Σc for Σ(cid:16), that is an STS which interacts with Σ(cid:16) to make the requirement ρ satisfied, and which as discussed inthe previous chapter, is deterministic and loop-free. Fig. 9 also highlights that, to break down the complexity of this secondstep, a pre-processing phase transforms Σ(cid:16) into an intermediate STS Bel(Σ(cid:16)), which intuitively represents the behaviorsP. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361335Fig. 9. The approach.of the component services “as recognizable by an external observer”, and which can be analyzed more easily than Σ(cid:16) toextract Σc .The next two subsections introduce the key formal elements for performing the steps discussed above. First, in Sec-tion 4.1, we discuss the notion of domain in terms of a parallel product Σ(cid:16), showing the way it models the independentlyevolving components Σ1, . . . , Σn. Based on this, we can define what it means to control Σ(cid:16) by an STS Σc , and we representthe behaviors of the controlled system as an STS Σc (cid:17) Σ(cid:16).Then, in Section 4.2, we define the notions of composition problem and solution. To do so, we first formalize compositionrequirements, and the conditions to satisfy them. This allows stating the conditions under which a controller satisfies somerequirements, and consequently, to spell the composition problem as that of finding a controller Σc such that Σc (cid:17) Σ(cid:16)satisfies a given composition requirement ρ.4.1. Domain and controllerThe automated composition problem has two inputs (see Fig. 9): the formal composition requirement ρ and the set ofcomponent services W 1, . . . , W n, associated to STSs ΣW 1 , . . . , ΣW n . The components ΣW 1 , . . . , ΣW n evolve independently;together, they build up an environment whose behaviors need to be driven, and represent, in planning terms, the domainwhich we aim to control. Such domain Σ(cid:16) is obtained as the first step of the composition, by combining ΣW 1 , . . . , ΣW n bymeans of a parallel product operation which essentially follows the notion of asynchronous product of [45].Definition 9 (Parallel product). Let Σ1 = (cid:3)S1, S 0O1) ∩ (I2 ∪ O2) = ∅, and L1 ∩ L2 = ∅. The parallel product Σ1 (cid:16) Σ2 of Σ1 and Σ2 is defined as:1 , I1, O1, R1, L1(cid:4) and Σ2 = (cid:3)S2, S 02 , I2, O2, R2, L2(cid:4) be two STSs with (I1 ∪(cid:2)S1 × S2, S 01× S 02 , I1 ∪ I2, O1 ∪ O2, R1(cid:16)R2, L1(cid:16)L2(cid:3)Σ1(cid:16)Σ2 =where:• (cid:3)(s1, s2), a, (s• (cid:3)(s1, s2), a, (s1, s(cid:11)1, s2)(cid:4) ∈ (R1(cid:16)R2) if (cid:3)s1, a, s(cid:11)2)(cid:4) ∈ (R1(cid:16)R2) if (cid:3)s2, a, s(cid:11)1(cid:11)2(cid:4) ∈ R1;(cid:4) ∈ R2;and (L1(cid:16)L2)(s1, s2) = L1(s1) ∪ L2(s2).The system representing (the parallel evolutions of) the component services W 1, . . . , W n of Fig. 9 is formally defined asΣ(cid:16) = ΣW 1(cid:16) · · · (cid:16) ΣW n .We remark that our definition of parallel product requires that the inputs/outputs of Σ1 and those of Σ2 are disjoint.This means that the component services may not communicate directly with each other. While an extension to the casewhere such component services may directly communicate is possible (and rather simple), we will not consider it, sincein our scenario, we intend to compose independent existing services, which we assume not to be aware of each other.Also notice that, in order to obtain a consistent labeling of Σ(cid:16), Σ1 and Σ2 must be defined over disjoint proposition sets.This means, in essence, that the corresponding services must refer to different internal variables. This is actually the case,since service variables have a local scope, and even when name clashes take place, homonym variables must be made notambiguous within the models (by applying appropriate renamings).The automated composition problem consists in generating a STS Σc that controls Σ(cid:16) so that its executions satisfy therequirement ρ (according to a formal notion of requirement satisfaction).336P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361In particular, since we aim at generating controllers which are executable, we can safely restrict to consider them asbeing internally deterministic, according to Definition 8.Moreover, we require that the inputs of a controller coincide with the outputs of its corresponding domain, and viceversa: situations where some I/O only appears on either the controller or the domain are useless, and may cause deadlocksituations.Definition 10 (Controller). A controller for Σ(cid:16) = (cid:3)S, S 0, I, O, R, L(cid:4) is a deterministic STS Σc = (cid:3)Sc, S 0∀s ∈ Sc : L∅(s) = ∅.c , O, I, Rc, L∅(cid:4), whereThe behaviors of a STS Σ when driven by a controller Σc can be represented as an STS, which we call the controlledsystem, and whose definition, essentially, extends the standard notion of synchronous product of STSs [45] with an appropriatehandling of τ transitions:Definition 11 (Controlled system). Let Σ = (cid:3)S, S 0, I, O, R, L(cid:4) be a state transition system, and let Σc = (cid:3)Sc, S 0c , O, I,Rc, L∅(cid:4) be a controller for Σ . The STS Σc (cid:17) Σ , describing the behaviors of system Σ when controlled by Σc , is defined as:(cid:2)Sc × S, S 0c× S 0, I, O, Rc (cid:17) R, L(cid:3)Σc (cid:17) Σ =where:• (cid:3)(sc, s), τ , (s• (cid:3)(sc, s), τ , (sc, s(cid:11)• (cid:3)(sc, s), a, (sc, s(cid:11)c, s)(cid:4) ∈ (Rc (cid:17) R) if (cid:3)sc, τ , s(cid:11))(cid:4) ∈ (Rc (cid:17) R) if (cid:3)s, τ , s(cid:11))(cid:4) ∈ (Rc (cid:17) R), with a (cid:19)= τ , if (cid:3)sc, a, s(cid:11)(cid:4) ∈ Rc ;c(cid:11)(cid:4) ∈ R;(cid:11)c(cid:4) ∈ Rc and (cid:3)s, a, s(cid:11)(cid:4) ∈ R.Notice that, although the systems are connected so that the output of one is associated to the input of the other,the resulting transitions in Rc (cid:17) R are labeled by input/output actions. This allows us to distinguish the transitions thatcorrespond to τ actions of Σc or Σ from those deriving from communications between Σc and Σ .In general, an STS Σc may not be adequate to control a system Σ . In particular, deadlocks may occur in case Σc performsan output at a point in time where Σ is not able to accept it, or vice versa. Of course, we want to only consider controllersthat prevent these situations — guaranteeing that, whenever Σc performs an output transition, then Σ is able to accept it,and vice versa. Moreover, for sake of generality, we need to do so in a way which is independent from low-level, engine-dependent implementation details, and in particular from the way message queuing mechanisms are realized. To achievethis, we follow a careful, conservative approach that guarantees that deadlocks are avoided regardless of what specificmessage queuing mechanisms are put in place by the run-time engine.We do so by defining a deadlock–freedom condition that assumes that messages are associated to a buffer, but doesnot rely on the existence of any specific message queuing/buffering mechanism. In particular, we assume that s can accepta message a if there is some successor scan, and message a is sent to Σ , thenperform an input transition labeled with a. Vice versa, if state s has no such successor sa deadlock situation is reached.4(cid:11) ∈ S of s, reachable from s through a chain of τ transitions, such that s(cid:11)(cid:11)In the following definition, and in the rest of the paper, we denote by τ -closure(s) the set of the states reachable froms through a sequence of τ transitions, and by τ -closure(S) the union of the τ -closures on all the states of a set S ⊆ S(remember that, due to the absence of divergent states, chains of τ transitions are finite).Definition 12 (τ -closure). Let Σ = (cid:3)S, S 0, I, O, R, L(cid:4) be a STS, and s ∈ S. Then τ -closure(s) = {t: ∃n ∈ N : ∃s0, s1, . . . , sn :s = s0, t = sn, ∀i ∈ [0, n − 1] : (cid:3)si, τ , si+1(cid:4) ∈ R}. Moreover if S ⊆ S, then τ -closure(S) =(cid:4)s∈S τ -closure(s).Definition 13 (Deadlock-free controller). Let Σ = (cid:3)S, S 0, I, O, R, L(cid:4) be a STS and Σc = (cid:3)Sc, S 0for Σ . Σc is deadlock free for Σ if all states (sc, s) ∈ Reachable(Σc (cid:17) Σ) satisfy the following conditions:c , O, I, Rc, L∅(cid:4) be a controller(1) if (cid:3)s, a, s(2) if (cid:3)sc, a, s(cid:11)(cid:4) ∈ R with a ∈ O then there is some s(cid:11)c(cid:11)c(cid:4) ∈ Rc with a ∈ I then there is some s(cid:11)(cid:11)(cid:11)(cid:4) ∈ Rc for some s∈ τ -closure(sc) such that (cid:3)sc, a, sc(cid:11)(cid:11)(cid:4) ∈ R for some s(cid:11), a, s(cid:11) ∈ τ -closure(s) such that (cid:3)s(cid:11)(cid:11)c(cid:11)(cid:11) ∈ S.∈ Sc ; andWe remark that it is also possible to adopt a different formulation that maintains requirement (1), and replaces (2) witha condition which closely reflects the idea that all τ -successors of states in R must be considered:(cid:11)(2) if (cid:3)sc, a, s(cid:11)c(cid:4) ∈ Rc with a ∈ I then ∀s(cid:11) ∈ τ -closure(s) there is a s(cid:11)(cid:11) ∈ R such that (cid:3)s(cid:11), a, s(cid:11)(cid:11)(cid:4) ∈ R.4 We remark that, if there is such a successor sof s, a deadlock can still occur. This can happen if a different chain of τ transitions is executed from s(cid:11)that leads to a state sfor which a cannot be executed anymore. In this case, the deadlock is recognized in s(cid:11)(cid:11)(cid:11)(cid:11).P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361337Fig. 10. Some examples of deadlock-prone and deadlock-free controllers.The two formulations are equivalent due to the fact that, in Definition 13, (1) and (2) are both applied to all states (sc, s) ∈Reachable(Σc (cid:17) Σ).Independently from its formulation, our deadlock–freedom definition corresponds to the minimal requirement that allowsfor asynchronous execution of ws-bpel services, and as such is guaranteed to be supported by any Web-service executionengine, regardless of their specific implementation of queuing and buffering mechanisms.Example 14. The top section of Fig. 10 shows an example of a controller Σc which is not deadlock-free for an STS Σ . Thisis due to the fact that Σ may nondeterministically evolve, from its initial state s1, into one of s2 or s3, and only in theformer state it can handle the output produced by the controller Σc . That is, in the state (c1, s3) of the controlled systemΣc (cid:17) Σ , the requirement (1) of Definition 13 is violated.Vice versa, as shown in the middle section of the figure, if the output of the controller can also be handled in the states3, then no deadlock may occur — that is, Σc is deadlock-free for Σ .The bottom part of the figure stresses the fact that inputs and outputs do not play symmetric roles in the definitionof deadlock–freedom. Namely, in this case, we consider a variation of the STSs Σc and Σ of the middle section, whereinputs are turned into outputs and vice versa. The resulting controlled system is just the same of that in the middle section;however, in this case, the controller is not deadlock-free, since in the situation corresponding to the state (c1, s3) of thecontrolled system, it cannot handle the output b.Notice that our definitions of controller and deadlock–freedom rule out the cases where, in a controlled system, bothinput and output actions can be executed on the same state, or on states connected by just a sequence of τ -transitions. Thisis because, at each step of execution, the controller, which we recall is a deterministic STS, may uniquely perform, as its next338P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 11. Controllers and input/output.action, either some input or a single output. Indeed, it is highly desirable to avoid situations where both input and outputscan be executed on the same state (or on states connected just by a sequence of τ -transitions): in those cases, the relativespeeds of the I/Os would decide whether the controller gets deadlocked or not. This is shown by the following example.Example 15. Consider Fig. 11; we intend to control Σ in such a way that some dark shaded states (namely, s8 or s9) arereached.Driving Σ to always get to s8 or s9 is not possible without incurring into the possibility of a deadlock. Indeed, thecontroller STS Σc in the upper part of the figure (left) is designed in order to attempt driving Σ to either s8 or s9, byallowing either an input or an output while in state c2. However, as a result of such behavior, the corresponding controlledsystem Σc (cid:17) Σ is nondeterministic, and critical runs may occur in states (c2, s5) and (c2, s6), thus breaking the deadlock–freedom requirements in Definition 13.Let us now relax our requirement, and also admit reaching the bright shaded state s7. The deterministic controller inthe bottom part of the figure satisfies such a requirement. The associated controlled system is deadlock-free, and as one cansee, at each step of its execution, it is fully determined whether (apart from internal evolutions) the next step will be aninput or an output operation.4.2. Requirements and problem statementTo define the notion of composition problem, we first discuss which kind of properties can be required for the orches-tration of services, by means of an example within the context of our reference scenario.Example 16. A reasonable requirement for the P&S is to sell the product at destination as requested by the customer.This means to conclude successfully a transaction started by a customer request. In terms of the interaction flows specifiedby the three available abstract ws-bpel, this means to reach the situation where the User, the Producer, and the Shipperreceive a final confirmation. This can be put in correspondence with ws-bpel activities; for instance, concerning the User,this means it should get to execute line 36 in Fig. 4.However, this requirement may be not always satisfiable by the composed service, since it depends on decisions takenby third parties that are out of its control: the Producer and the Shipper may refuse to provide the service for the requestedproduct and location (e.g., since the product is not available or the location is out of the area of service of the shipper), andthe User may refuse the offer by the P&S (e.g., since it is too expensive). If this happens, we require that the P&S shouldP. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361339step back from both orders, since we do not want the P&S to buy something that cannot be delivered, as well as we do notwant it to spend money for delivering an item that we cannot buy. Again, in terms of abstract ws-bpel, this can be put incorrespondence with ws-bpel activities; for instance, concerning the User, this means it should terminate execution eitherat line 32 or at line 21 in Fig. 4.Requirements like the one above can be formulated in terms of reachability over sets of states of the component services.In particular, we can structure our requirements as the conjunction of requirements over the flow of data amongst thecomponents, and requirements over the control logics.In the control part, we specify that, in case all partners are available, they should all terminate in a “successful” state,i.e. a state where the final agreement to buy or sell has been achieved with the P&S. Otherwise, each partner must eitherremain inactive, or terminate in a “failure” state where (a) the partner is aware that no agreement to buy/sell is possible,and (b) the partner no commitment to buy or sell.In order to more compactly define this part of the requirements, we semantically annotate ws-bpel activities usingtwo annotations, Fail and Succ. These identify the final failure and success states for each of the partners, and are inter-preted as the sets of program counter values associated to failing and successful terminations respectively. For instance,Producer.Succ := (Producer.pc := DONE_getAccepted), and Producer.Fail := (Producer.pc IN {DONE_getRefused, DONE_Nack}).Similarly, we introduce an Init annotation that indicates, for each component, that the program counter for that compo-nent has its initial value. This said, the control flow part ρc of the requirement goes as follows:(cid:5)(Prod.AvailVar ∧ Ship.AvailVar ∧ User.AcceptsVar) →(cid:6)(Prod.Succ ∧ Ship.Succ ∧ User.Succ)(cid:5)(cid:5)∧¬(Prod.AvailVar ∧ Ship.AvailVar ∧ User.AcceptsVar) →(Prod.Fail ∨ Prod.Init) ∧ (Ship.Fail ∨ Ship.Init) ∧ (User.Fail ∨ User.Init)(cid:6)(cid:6)The data flow part of the requirements identifies the data dependencies amongst the partners. More specifically, weexpect that the Producer and Shipper receive (from P&S) the request data sent by the User, that the Producer is the one toprovide the size information to the Shipper, and that costs and times are coherently computed and communicated to theUser by P&S. Of course there may be cases where some data are not actually produced nor circulated, e.g., if the Producer isunavailable to provide the item, he will not communicate any location or article data to the other partners. This is capturedby stating that “only in case the a component responsible for generating some data actually provides it, then it has to becommunicated to the partner” — i.e., by a logical implication. The data section of the requirement, ρd, is thus as follows,where DEF(d) is a condition that holds if d has a value different from a default ‘indefiniteness‘ value:DEF(Producer.reqVar_loc) → Producer.reqVar_loc = User.reqVar_loc ∧DEF(Producer.reqVar_art) → Producer.reqVar_art = User.reqVar_art ∧DEF(Shipper.reqVar_size) → Shipper.reqVar_size = Producer.infoVar_size ∧DEF(Shipper.reqVar_loc) → Shippher.reqVar_loc = User.reqVar_loc ∧DEF(Shipper.reqVar_art) → Shippher.reqVar_art = User.reqVar_art ∧DEF(User.offerVar_delay) →User.offerVar_delay = Shipper.offerVar_delay + Producer.offerVar_delay ∧DEF(User.offerVar_cost) →User.offerVar_cost = Shipper.offerVar_cost + Producer.offerVar_cost∧Intuitively, a controller is a solution for the requirement ρ = ρc ∧ ρd iff it guarantees that ρ is achieved. We can formallyexpress this by requiring that every execution of the controlled system Σc (cid:17) Σ(cid:16) ends up in a state where ρ holds. Thisis immediate to do, since the requirement ρ in fact refers to values of the program counter, and values of the variables,possibly linked by means of functional expressions. As such, taking into account the finiteness of types, ρ can be easilycompiled, reasoning by cases in the case of uninterpreted functions, into a formula over the propositions associated to Σ(cid:16).Definition 17 (Satisfiability). We say that an STS Σ satisfies a propositional formula p, denoted with Σ |(cid:12) p, if and only if• there exists no infinite run of Σ ;• every final state of Σ satisfies p according to Definition 6.340P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Definition 18 (Solution controller). A controller Σc is a solution for goal ρ iff Σc (cid:17) Σ(cid:16) |(cid:12) ρ.We can now formally characterize a (Web service) composition problem as follows:Definition 19 (Composition problem). Let Σ1, . . . , Σn be a set of state transition systems, and let ρ be a composition require-ment. The composition problem for Σ1, . . . , Σn and ρ is the problem of finding a deadlock-free controller Σc such thatΣc (cid:17) (Σ1 (cid:16) · · · (cid:16) Σn) |(cid:12) ρ.We stress once more that, due to our definition of satisfiability, we do not admit, as solutions to our problem, con-trollers that may lead to infinite runs, entering into interaction loops with no guarantee to terminate. This kind of solution,which is strictly connected to the fact that requirements are formulated in terms of reachability conditions, is fully generalwhen composing services which are guaranteed to terminate, as we assume to have as a starting point. Of course, severalextensions are possible and meaningful, relaxing our assumption over the finite termination of components, consideringcomposition requirements of a different nature, and correspondingly relaxing the definition of satisfiability. However, inorder not to dilute the presentation, and to provide a self-contained and detailed discussion of the approach, we will stickto the above definitions, and restrict to (loop-free) controllers which do not imply infinite runs. We stress that, at the sametime, this does not imply that we restrict to composing loop-free services. Indeed, for scenarios where (some) componentsfeature loops, and where the composition requirement can be reached after they traverse such loops a finite number oftimes, our approach is capable to build an appropriate controller; specifically, the controller will handle each loop traversalinto a different portion of its loop-free structure.5. The synthesis algorithmsThe statement of composition problem given by Definition 19 can be directly exploited to verify whether a given con-troller Σc can be used to satisfy a requirement ρ, e.g. by applying model-checking techniques. However, for the purposes ofautomatically generating a controller that solves the problem, we need to conveniently rephrase the problem in a way thatmakes explicit how such a controller can be identified by constructing and visiting a (prefix of a) search space. This willallow us to tackle the problem by first realizing the construction of such search space, and then by making use of effectivesearch techniques taken from the planning area. In the following, we first discuss such reformulation, and then provide thealgorithms for solving the reformulated problem.5.1. Belief-level search reformulationWe start by observing that Σ(cid:16) = Σ1 (cid:16) · · · (cid:16) Σn is a (nondeterministic) STS that is only partially observable by Σc . Thatis, at execution time, the composite service Σc cannot in general get to know exactly what is the current state of thecomponent services modeled by ΣW 1 , . . . , ΣW n . This uncertainty has two different sources. The first is the presence ofnondeterministic transitions in a situation where direct observation of the domain state is impossible; this is somethingalso considered by several approaches to planning. The second source of uncertainty is due to the fact that we are modelingan asynchronous framework, where entities may evolve internally through τ -transitions. While asynchronous behaviors arewell known and studied in process algebra, and have been consequently considered in different approaches to programsynthesis, this aspect has never been considered so far in planning. All classical approaches to planning rely over theassumption that the domain of discourse has a synchronous nature, i.e. actions take place, possibly in concurrence, on thebasis of a unique discrete timeline. This cannot model our situation, where independent actors evolve with unrelated anduncontrollable speed. Neither this can be modeled using recent planning approaches and languages that consider actionswhose effects are continuous in time, since the triggering of such actions is still synchronous.In this setting, the incomplete knowledge on the runtime state of the environment under control must be taken intoaccount by grouping together the executions which may not be perceived as distinct by an external observer of the environ-ment. In particular, at each step of the execution, we need to consider that a set of different states may be equally plausiblegiven the partial knowledge that we have of the system. Such a set of states is called a belief state, or simply belief. Whileseveral approaches in planning rely on this kind of representation to model finite-state uncertainty, see e.g. [18,81,93,24],we remark again that their use of beliefs is different, due to the absence of asynchronicity in their models.Recalling Definition 12, it is easy to see that the initial belief for the execution is the τ -closure of the initial states S 0of Σ(cid:16), since it must consider all the states that each component may have reached, since their activation, only by means ofinternal transitions. This belief is updated whenever Σ(cid:16) performs an observable (input or output) transition. More precisely,(cid:11) = Evolve(B, a) is defined as the setif B ⊆ S is the current belief and an action a ∈ I ∪ O is applied, then the new belief Bof states reachable by first applying a, and then considering every (possibly empty) sequence of internal transitions on theresulting states. We remark that a has to be applicable over the belief; however, such notion of applicability cannot simplybe defined by requiring the applicability of a over all states of the belief, due to two reasons. First of all, a state in B mayevolve within B due to τ -transitions, and during such internal evolution (which we recall is finite, due to the absence ofdivergent states) it is perfectly admissible that transient states are traversed where the action a is not handled. Moreover,P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361341since output actions are executed just on some states, depending on the choice performed by the STS under exam, we shallnot require that they are executable on every state of B, but just on some state of B.Definition 20 (Belief applicability and evolution). Let B ⊆ S be a belief of some state transition system Σ . We say that anaction a ∈ I ∪ O is applicable on a belief B, denoted Appl(B, a), iff:• a ∈ O, and ∃s ∈ B : Appl(s, a), or• a ∈ I, and ∀s ∈ B : ∃s(cid:11) ∈ τ -closure(s) : Appl(s(cid:11), a).The evolution of B under action a is the belief B(cid:11) = Evolve(B, a), where• if Appl(B, a), then Evolve(B, a) = τ -closure({s• otherwise, Evolve(B, a) = ∅.(cid:11).∃s ∈ B, a ∈ I ∪ O: (cid:3)s, a, s(cid:11)(cid:4) ∈ R});By starting from the τ -closure of S 0, and iteratively evolving the belief via every applicable action, we obtain the set ofbeliefs ReachableB(Σ) reachable from S 0:• τ -closure(S 0) ∈ ReachableB(Σ);• if B ∈ ReachableB(Σ) and ∃a ∈ I ∪ O : ∅ (cid:19)= B(cid:11) = Evolve(B, a), then B(cid:11) ∈ ReachableB(Σ).To evaluate whether a system satisfies a given reachability goal, we must not consider “transient” states of beliefs, i.e.those that can be traversed while the components are performing their internal transitions. This is because of two reasons:first, we may not understand whether the system is in one of those states (since this depends on unobservable events),and second, we cannot control the system so to execute (or prevent) some internal transitions. Rather, we need to considerexclusively those “stable” states of beliefs that are reached after every possible internal evolution has been performed, andprior to any further execution of I/Os. This is what we call the τ -frontier of B:Definition 21 (τ -frontier). Let B ⊆ S be a belief; we call the τ -frontier of B the set τ -frontier(B) = {s ∈ B: ∃sI ∪ O : (s, a, s(cid:11) ∈ S : (s, τ , s(cid:11)) ∈ R ∨ ∀s(cid:11)) /∈ R}.(cid:11) ∈ S, a ∈Since we deal with reachability goals, we can state that a belief satisfies a propositional property p by just consideringits τ -frontier: it satisfies p iff every state in its τ -frontier does.Definition 22 (Belief satisfying a property). Let Σ = (cid:3)S, S 0, I, O, R, L(cid:4) be a STS, p ∈ Prop be a property for Σ , and B ⊆ S bea belief. We say that B satisfies p, written B |(cid:12)Σ p, if and only if for any state s ∈ τ -frontier(B), p ∈ L(s).We can now define a “belief-level” STS for Σ(cid:16), whose states are the beliefs that may be traversed by the executions ofΣ(cid:16), and whose transitions describe belief evolutions:Definition 23 (Belief-level system). Let Σ = (cid:3)S, S 0, I, O, R, L(cid:4) be a STS. The corresponding belief-level STS is Bel(Σ) =(cid:3)SB, {s0B}, I, O, RB, LB(cid:4), where:• SB = ReachableB(Σ);B = τ -closure(S 0);• s0• transitions RB are defined as follows: if Evolve(B, a) = B• LB(B) = {p ∈ Prop : B |(cid:12)Σ p}.(cid:11) (cid:19)= ∅ for some a ∈ I ∪ O, then (cid:3)B, a, B(cid:11)(cid:4) ∈ RB;Therefore, the belief-level system for Σ(cid:16) is an STS, exempt from τ transitions and with a single initial state, whichcollects together all the possible executions of Σ(cid:16) which are equivalent from the point of view of an external observerof Σ(cid:16): all the states that are reached by means of equivalent transitions (under such viewpoint) are collected into onestate of Bel(Σ(cid:16)). This allows us to recast the definition of composition problem by imposing conditions not on the con-troller, but on the observable induced executions of the controlled domain, represented in Bel(Σ(cid:16)). This means that wecan search for a suitable controller by identifying a subset (namely, a prefix) of Bel(Σ(cid:16)) such that every possible executionsatisfies the composition requirement. More specifically, as justified in the previous Section, since we consider reachabilitygoals, we can restrict our attention to controllers whose execution is loop-free; this corresponds to searching just for DAG-structured prefixes of Bel(Σ(cid:16)). Moreover, the fact that we intend to generate deterministic controllers, and the requirementof deadlock–freedom, imply two further constraints on the kind of subsets of Bel(Σ(cid:16)) we are interested into. First, the de-terminism of controllers imposes that, in our subtree, at each point, we will need to consider at most one input transition.Second, deadlock–freedom implies that such controllers never discard outputs of the controlled system; that is, if our subset342P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361contains a state B that originates some output transitions in Bel(Σ(cid:16)), then the subset must contain every output transitionsof Bel(Σ(cid:16)) from B.Putting together all the above constraints, we conclude that we only need to consider portions of Bel(Σ(cid:16)) structured asfollows:Definition 24 (Execution subtree). Let Bel(Σ) = (cid:3)SB, S 0B, I, O, R(cid:11)(cid:3)S, S 0, I, O, R, L(cid:4). We say that Σ (cid:11)B = (cid:3)S(cid:11)B, S 0B, I, O, RB, LB(cid:4) be the belief-level system for a domain Σ =B, L(cid:11)B(cid:4) is an execution subtree of ΣB if and only if:B ⊆ SB and R(cid:11)(1) S(cid:11)(2) ∀(cid:3)B, o, B(cid:11)(cid:4) ∈ RB : ((o ∈ O ∧ B ∈ S(cid:11)outputs it originates in the belief-level STS.B) → (BB ⊆ RB, that is, Σ (cid:11)B is a subgraph of Bel(Σ).(cid:11) ∈ S(cid:11)B ∧ (cid:3)B, o, B(cid:11)(cid:4) ∈ R(cid:11)B)), that is, a belief of the subtree must originate all the(3) ∀B ∈ S(cid:11)(cid:11) ∨ Binput transition starts from a belief B, only one such transition may start from B in the subtree.(cid:11) ∈ SB, a ∈ I : (B, a, BB) → (¬∃B(cid:11) ∈ I : (B, aB ∧ (a (cid:19)= aB : (∃B(cid:11)(cid:11)) ∈ R(cid:11)(cid:11)) ∈ R(cid:11)(cid:11)(cid:11) ∈ S(cid:11)B, a(cid:11), B(cid:11) (cid:19)= B(cid:11)(cid:11))), that is. If some(4) No run of Σ (cid:11)B can traverse the same belief more than once, i.e. any belief may only appear once in any path that canbe constructed by concatenating transitions of Σ (cid:11)B is the function restriction of LB to the states in S(cid:11)(5) L(cid:11)B. This implies that all such paths have finite length.B ⊆ SB (that is, L(cid:11)B = LB|S(cid:11)).BWe will denote with Σ (cid:11)relation can applied to generic STSs, we will make use of it only by referring to subtrees of belief-level systems.)B is an execution subtree of Bel(Σ). (Notice that, while the subtreeB ⊆ Bel(Σ) the fact that Σ (cid:11)It can be seen that:• conditions (1) and (4), and the fact that the initial belief of the subtree is the same of the originating belief-level system,ensure that the subtree is a DAG-structured portion of the belief-level system;• condition (2) requires that no output generated from the environment is disregarded;• condition (3) states that, in the subtree, we only need to consider a uniquely determined way of driving the environ-ment, since the controller is deterministic;• since the controller is deterministic, it is never the case that both an input and an output transitions start from thesame state B.Given its acyclic structure, a subtree can be associated to a notion of subtree depth: the maximal length of the sequencesB0, B1, . . . , Bn such that B i, a, B i+1 ∈ RB. Intuitively, the depth of a subtree identifies the number of steps needed, in theworst case, to terminate the execution of the controlled system.A subtree π of Bel(Σ(cid:16)) can be associated to a controller that, once connected to Σ(cid:16), drives it in such a way that onlythe beliefs of π can be traversed during the execution of the controlled system. Amongst the controllers that satisfy thisrequirement, we can focus on a synchronous controller for which we can give an immediate constructive definition: thestructure of the controller mirrors the one of the subtree, featuring one state for each state of the subtree and contraposingone-to-one its I/O operations with those of the subtree.Definition 25 (Controller associated to a subtree). Let Σ (cid:11)Bel(Σ). We say that the STS Contr(Σ (cid:11)empty labeling function.B) = (cid:3)S(cid:11)B, S 0B, O, I, R(cid:11)B = (cid:3)S(cid:11)B, S 0B, I, O, R(cid:11)B, L(cid:11)B, L∅(cid:4) is the controller associated to Σ (cid:11)B(cid:4) ⊆ Bel(Σ) be an execution subtree forB, where L∅ denotes theLemma 26. Let Σ be an STS, and Σ (cid:11)B ⊆ Bel(Σ). The STS Contr(Σ (cid:11)B) is a controller for Σ .Proof. Since the labeling of Contr(Σ (cid:11)need to show that Contr(Σ (cid:11)B) is a deterministic STS:B) is empty by definition and the input/outputs correspond to those of Σ , we only• Since the belief-level system Bel(Σ) has a single initial state, and so its execution subtree Σ (cid:11)B, clause (1) of Definition 8is satisfied.• Since the belief-level system Bel(Σ) contains no τ -transition, also the subtree Σ (cid:11)B and its associated controller containno τ -transition. Thus clause (2) of Definition 8 is satisfied.• From clause (3) of the definition of subtree, it is immediate that at most one output transition can originate from anystate of the controller associated to a subtree. Thus also clause (3) of Definition 8 is satisfied. (cid:2)Thus, if Σ (cid:11)B ⊆ Bel(Σ), then Contr(Σ (cid:11)deadlock-free for Σ , we need to first show that the execution of Contr(Σ (cid:11)(remember that the states of Contr(Σ (cid:11)B) are beliefs of Σ ).B) can be used to control Σ . However, to prove that such a controller is alsoB) (cid:17) Σ(cid:16) traverses states (B, s) such that s ∈ BP. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361343Lemma 27. Let Σ be an STS. Let Σ (cid:11)that s ∈ B.B ⊆ Bel(Σ) = (cid:3)SB, S 0B, I, O, RB, LB(cid:4). Every state (B, s) ∈ Reachable(Contr(Σ (cid:11)B) (cid:17) Σ(cid:16)) is suchProof. The proof goes by induction on the number i of input/output actions traversed to reach (B, s) (which equals thelength of the sequence of beliefs of the subtree traversed to reach B).Basis: i = 0. Thus B is the τ -closure of S 0. Since no input nor output have been executed, s must be reachable by achain of τ transitions from an initial state, so it belongs to B.(cid:11)) ∈ R(cid:11)B ⊆ RB, with BInduction step. We assume the theorem holds for (B, s) with i = k, and we prove it for i = k + 1. Then, there is an actionconsist of the, there is a least a(cid:11)(cid:11)) ∈ RB, and (b) there is a (possibly empty) sequence of(cid:11), sB) (cid:17) Σ(cid:16)). In particular, since, by(cid:11)) isB, s0), with s0 ∈ S 0(cid:11) = Evolve(B, a)} are all the states reachablea ∈ I ∪ O such that (B, a, Bτ -closure of the states of B that can be progressed via the action a. That is, considering a state sstate ¯s ∈ B such that (a) ¯s can be progressed via a, i.e. ∃sτ -transitions in RB that leads from sthe inductive hypothesis, (B, s) can be reached in k input/output actions (from some state (S 0reachable in k + 1 input/output actions. Then, the set of states {(Bin k + 1 input/output actions starting from states of the form (S 0(cid:11) = Evolve(B, a). By the definition of Evolve, the states of B(cid:11)(cid:11) : (¯s, a, s. This means that (B(cid:11), s(cid:11) ∈ BB, s0) (with s0 ∈ S 0(cid:11)) ∈ Reachable(Contr(Σ (cid:11)B). (cid:2)B), (B(cid:11) ∈ B(cid:11) ∧ B(cid:11)) : s(cid:11), sto s(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)Lemma 28. Let Σ be an STS. Let Σ (cid:11)free for Σ .B ⊆ Bel(Σ) be an execution subtree of (the belief-level system for) Σ . Then Contr(Σ (cid:11)B) is deadlock-Proof. To prove the statement, we prove in turn that Σc = Contr(Σ (cid:11)B) obeys clauses (1) and (2) of Definition 13.Concerning clause (1), we recall that every output transition from a reachable state has a correspondent transition withinthe belief-level system, and that if a belief is part of the subtree, every output transition from it must also appear into the(cid:11))(cid:11)) ∈ R for some output a ∈ O and (B, s) ∈ Reachable(Σc (cid:17) Σ), since s ∈ B, some transition (B, a, Bsubtree. Thus, if (s, a, smust be part of the subtree. But then, it also belongs to Contr(Σ (cid:11)B), which proves clause (1) of Definition 13 (whereτ -closure(sc) = sc given the absence of τ -transitions in the controller).Concerning clause (2) of Definition 13, we observe that, if (B, a, BB for some (B, s) ∈ Reachable(Σc (cid:17) Σ), then two(cid:11)) ∈ R(cid:11)cases are possible:• the only input from the controller is applicable on s ∈ B, i.e. s is in the τ -frontier of B; then, clause (2) is trivially true.(cid:11)) belongs to the belief-level system of Σ , there must be a• s is not in the τ -frontier of B. In this case, since (B, a, Bsequence of τ -transitions from s, such that every state in the sequence is still in B, and a is applicable on the last(cid:11) ∈ τ -closure(s). This shows clause (2) holds. (cid:2)state — i.e. (s(cid:11)(cid:11)) ∈ R for some s(cid:11), a, sWe are finally in a position to recast the notion of solution controller so to refer to it as an execution subtree, i.e. asubgraph of the constructively defined Bel(Σ(cid:16)): it is enough to require that every final state of the subtree is a beliefsatisfying ρ.Definition 29 (Solution subtree). Let Σ = (cid:3)S, S 0, I, O, R, L(cid:4) be a domain defined over propositions Prop. Let ρ be a propo-sitional formula over Prop. The execution subtree Σ (cid:11)B ⊆ Bel(Σ) is a solution for the requirement ρ if every final state B ofΣ (cid:11)B is such that B |(cid:12)Σ ρ.Indeed, a solution subtree π is associated to a solution controller Contr(π ), and vice versa, as shown by the followinglemma:Lemma 30. Let π be a solution subtree of Bel(Σ(cid:16)) for the problem of service composition over the requirement ρ. Then Contr(π ) is asolution controller for the same problem.Proof. The statement is easily proved based on Lemma 27. If the subtree is a solution, then every state of every final state ofπ is a goal state; but then, due to Lemma 27, every final state reachable by execution Contr(π ) is a goal state, so Contr(π )is a solution controller. (cid:2)To associate a subtree of Bel(Σ(cid:16)) with a controller Σc , we observe that, following Definition 11, Σc constrains thebehaviors of Σ(cid:16): only certain states and transitions of Σ(cid:16) can ever be traversed during the execution of Σc (cid:17) Σ(cid:16). That is,Σc induces a constrained subset of Σ(cid:16), which we denote with Σ(cid:16)(Σc). We now show that Σ(cid:16)(Σc) is a solution subtree ifΣc is a solution controller:Definition 31 (Induced STS). Let Σ(cid:16) = (cid:3)S, S 0, I, O, R, L(cid:4) be an STS describing a set of component services, and let Σc =(cid:3)Sc, S 0c , O, I, Rc, L∅(cid:4) be a controller for Σ(cid:16).The STS Σ(cid:16)(Σc) = (cid:3)S, S 0, I, O, R(cid:11), L(cid:4), where R(cid:11) = {(s, a, s(cid:11)) : ∃sc, s: ((sc, s) ∈ Reachable(Σc (cid:17) Σ(cid:16)) ∧ ((sc, s), a, (s(cid:11)c, s(cid:11))) ∈(cid:11)cRc (cid:17) R)}, is called the STS induced by Σc on Σ(cid:16).344P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Lemma 32. If Σc (cid:17) Σ(cid:16) |(cid:12) ρ, then the execution subtree corresponding to the controlled system, Bel(Σ(cid:16)(Σc)) ⊆ Bel(Σ(cid:16)) is a solutionsubtree for the composition problem.Proof. The proof relies on the fact that we restrict to controllers that induce finite, loop-free executions over the controlledsystem; i.e. a state of the controlled system is never traversed more than once. Under that proviso, according to Definition17 and, Σc (cid:17) Σ(cid:16) |(cid:12) ρ means that every execution of Σc (cid:17) Σ(cid:16) is finite, and its final state satisfies ρ (according to Definition6). In turn, considering Definition 31 above, this means that the final states of the STS Σ(cid:16)(Σc) induced by Σc on Σ(cid:16)satisfy ρ. Due to the definition of belief-level system, such final states will be states in the τ -frontiers of the final beliefsof the induced subtree Bel(Σ(cid:16)(Σc)). That is, each final belief Bel(Σ(cid:16)(Σc)) satisfies ρ, according to Definition 22. FollowingDefinition 29, this means that Bel(Σ(cid:16)(Σc)) is a solution subtree for the composition problem, proving the statement. (cid:2)The above lemmas can be combined to associate in a one-to-one way the existence of a solution with that of a solutionsubtree:Theorem 33 (Composition problem at the belief-level). Let Σ1, . . . , Σn be a set of state transition systems, defined over propositionsProp1, . . . , Propn respectively. Let ρ be a composition requirement, that is a propositional formula over Prop1, . . . , Propn. A solutioncontroller for the problem exists if and only if a solution subtree of Bel(Σ1(cid:16) · · · (cid:16)Σn) exists.Proof. This theorem descends directly from Lemmas 30 and 32. Namely: if there exists a solution subtree π , Lemma 30guarantees that there exists a solution controller Contr(π ). Vice versa, if there exists a solution controller Σc , Lemma 32guarantees that Bel(Σ(cid:16)(Σc)) is a solution subtree. (cid:2)Relevant to the purposes of automatically constructing a controller, Lemma 30 states that if a solution subtree π has beenfound, a solution controller Contr(π ) can be obtained: a controller Σc that induces a solution subtree of Bel(Σ1 (cid:16) . . . (cid:16) Σn)is a solution to the composition problem. Thus we can recast the composition problem as that of identifying a solutionsubtree π ⊆ Bel(Σ1 (cid:16) · · · (cid:16) Σn), taking the loop-free controller Contr(π ) as the solution of the problem.Based on these considerations, our approach will be structured as follows:(1) Construct, for each component service, an STS Σi ;(2) Construct the parallel product Σ(cid:16) of Σ1, . . . , Σn, and then its belief-level counterpart Bel(Σ(cid:16));(3) Search the execution structure in Bel(Σ(cid:16)) to identify one execution tree associated to a solution controller;(4) Extract, from the execution tree, the controller Σc , and emit it as a ws-bpel program.In the following subsections, we detail the core of this approach, i.e. the algorithm used for constructing Bel(Σ(cid:16)), and theone for searching a solution subtree inside it.5.2. AlgorithmsFollowing the ideas stated in the previous section, we solve the composition problem by first constructing the belief-level machine Bel(Σ(cid:16)), and then searching for a solution subtree π inside it. Once such a solution is found, the (loop-free)controller Contr(π ) is extracted and constitutes a solution to the composition problem.To construct the belief-level machine Bel(Σ(cid:16)), we rely on an algorithm that implements Definition 23 by a simple fix-point algorithm that performs a forward search of the space of beliefs, starting from the initial belief. At each iteration ofthe fix-point, a τ -closure operator is used that realizes Definition 12, so that indistinguishable states of the STS are groupedtogether.While it is possible to apply the algorithm directly on Σ(cid:16), we can do better. In particular, we exploit the fact thatBel(Σ1 (cid:16) Σ2) = Bel(Σ1) (cid:16) Bel(Σ2). This stems from the way states and transitions of the two individual STSs cohabit inde-pendently within Σ1 (cid:16) Σ2, therefore allowing for projecting them back when constructing the belief-level system. Therefore,we can separately compute the belief-level system for each component service, and to represent the overall belief-level sys-tem as a modular composition of the various Bel(Σi), where modules evolve on the basis of a parallel product semantics.The impact of this approach on the effectiveness of the belief-level construction is clear: since the algorithm, given an, the monolithic approachSTS Σ , explicitly enumerates the reachable beliefs of Bel(Σ), and since they can be up to 2|S1| + · · · + 2may have to enumerate 2beliefs, while the partitioned approach only 2|S1|+···+|Sn||S||Sn|.Once the belief-level system is built, we exploit a variant of the algorithm for strong planning presented in [32] to extracta solution subtree from it. Such algorithm receives as input the STS representing Bel(Σ(cid:16)), produced by the belief-levelconstruction algorithm, and performs a symbolic regression search, where frontiers of states of Bel(Σ(cid:16)) are manipulatedat once. We remark that a state of Bel(Σ(cid:16)) corresponds to a belief, i.e. a set of states of the component services; that is,symbolically manipulating sets of states of Bel(Σ(cid:16)) means symbolically manipulating sets of sets of states of the componentservices. This is an extremely powerful technique, that avoids handling enumeratively large sets of sets of service states.In difference to the original planning algorithm presented in [32], our algorithm must explicitly deal with the con-straints coming from the way subtrees are defined, and from the requirement that the controlled system is deadlock-free.P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361345Fig. 12. The search algorithm.This specifically affects the key primitive over which the algorithm is built, namely the so-called strong pre-image primi-tive StrongPreImage.Given a set S of states of Bel(Σ(cid:16)), the pre-image primitive returns a set of pairs {(cid:3)s, a(cid:4)}, associating a state s with aninput/output action a. Such pairs identify all the predecessors of the states in S via some input/output action, such that theexecution of the action a associated to s is guaranteed to lead to states inside S, regardless of nondeterminism. The set ofstate–action pairs constitutes a so-called state–action table (see [32]), which represents a (partial) function between states ofthe domain and actions to be executed on them. Our pre-image primitive is defined as follows:(cid:11) :(cid:11) :StrongPreImage(S)∈ R → s(cid:6)(cid:11)s, i, s(cid:5)(cid:11) ∈ S.=(cid:7)(cid:8)(cid:5)(cid:6)(cid:11)(cid:7)(s, i) : i ∈ I ∧ ∀s(s, o) : o ∈ O ∧ ∃s(cid:5)(cid:11) ∈ S, o∀s(cid:11) ∈ O :s, o, s(cid:6)(cid:11)∈ R → s(cid:11) ∈ S∈ R → s(cid:11)s, o, s∪(cid:11) ∈ S ∧(cid:8).Here, due to the deadlock–freedom requirement, input and output actions are treated differently. In particular, since outputscorrespond to uncontrollable choices taken by the component services, once we consider an output from a service, we haveto consider every possible outputs from it, and guarantee that every outcome is in the target set.This is necessary to guarantee conditions (1) and (2) in Definition 13, avoiding situations such as that shown in Fig. 10(low), where some output generated by a component may not be handled by its controller. Indeed, the definition of Strong-PreImage is such that its application consists in generating a portion of execution subtree; the asymmetry between thehandling of inputs and outputs closely corresponds to requirements (2) and (3) of Definition 24, which in turn derivethemselves from Definition 13.We remark that the deadlock–freedom requirement has no correspondence in the formulation of strong planning of [32],where only the controller is responsible for taking actions. Indeed, [32] relies on a different StrongPreImage primitive,where actions are handled uniformly (and analogously to how we treat inputs).The other important primitive for the algorithm is the so-called pruning primitive PruneStates, and is used after exe-cuting a pre-image, to remove, from a state–action table π , all the pairs (cid:3)s, a(cid:4) such that a solution is already known for sand stored into S. It is defined as:PruneStates(π , S)(cid:7)(cid:3)s, a(cid:4) ∈ π : s /∈ S.=(cid:8).This pruning is important to guarantee that only the shortest solution from any state appears in the state–action table.The search algorithm is depicted in Fig. 12, and basically consists of a fix-point iteration that incrementally constructs astate–action table. The state–action table S A is initialized as empty, and enriched, at each iteration, with states from whichit is possible to control the system to achieve states in S A. The algorithm terminates either when no more states can beadded to the state–action table, or when the current state–action table already includes the initial states, in which case asolution has been found.The arguments for proving that the algorithm always terminates, and it is correct and complete, are similar to thosepresented in [32]. In particular, termination is proved by observing that the number of states in the visited domain is finite,and that the number of states in the state–action table grows up monotonically.Theorem 34 (Termination). Let ΣB = (cid:3)SB, S 0plan(I, G) on ΣB terminates.B, I, O, RB, LB(cid:4) be a (belief-level) STS; let I ∈ SB and G ⊆ SB. The execution ofProof. We prove that the main loop of the algorithm (lines 4–9) exists after a finite number of iterations. To do so, wefirst recall that SB contains a finite number of states. Moreover, we observe that the state–action table S A grows up346P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361monotonically (see line 8 of the algorithm). This implies that, after at most |SB| iterations of the main loop, no new state–action pair will be added to S A at line 8. But, as soon as no new state–action pair is added to S A at line 8, the main loopexits, since then, at line 4, O ldS A = S A, and the “while” condition becomes false. That is, the main loops exits after at most|SB| iterations. (cid:2)To prove correctness and completeness, we rely on proving that, at each iteration of the main loop at lines 4–9, thestate–action table contains states for which a solution tree exists, and such tree is indeed represented by (a portion of) thestate–action table. Indeed, starting from a set of initial states, a state–action table induces an STS defined as follows:Definition 35 (STS induced by state–action table). Let S A = {(cid:3)s, a(cid:4): s ∈ S, a ∈ I ∪ O} be a state–action table referring to theactions and states of an STS Σ = (cid:3)S, S 0, I, O, R, L(cid:4). Let I ⊆ {s: ∃a ∈ I ∪ O.(cid:3)s, a(cid:4) ∈ S A} be a set of initial states, and letG ⊆ S be a set of goal states.The STS induced by I on S A, denoted STSof (S A, I, G) = (cid:3)SS A, I, I, O, RS A, LS A(cid:4), is defined as follows:(1) I ⊆ SS A ;(2) if s ∈ SS A , and there exists a sequence (cid:3)s0, a0(cid:4), . . . , (cid:3)sn, an(cid:4) such that s0 = s, (cid:3)si, ai(cid:4) ∈ S A, ∀i ∈ [0, n − 1] : (cid:3)si, ai, si+1(cid:4) ∈ R,then sn ∈ SS A ;(3) SS A contains no other state than those induced by the above conditions (1) and (2);(4) if s ∈ SS A and (cid:3)s, a, s(5) LS A is the function restriction of L to the states in SS A , i.e. LS A = L|SS A .(cid:11)(cid:4) ∈ R, then (cid:3)s, a, s(cid:11)(cid:4) ∈ RS A ;Lemma 36 (Invariant property of the state–action table). At the i-th iteration of the main loop at lines 4–9, G ∪ StatesOf(S A) containsall the states for which a solution subtree of depth up to i exists. In particular, if s ∈ G ∪StatesOf(S A), then STSof (S A, I, G) is a solutionsubtree rooted at s.Proof. The proof goes by induction on the number i of iterations of the main loop of the algorithm (lines 4–9).Basis (i = 0). The state–action table is empty, and G ∪ StatesOf(S A) = G consists of exactly those states for which asolution exists that requires 0 steps to achieve the goal (i.e. for which a solution subtree of depth 0 exists).Induction step. We assume that the theorem holds at the i-th iteration, and prove it for the i + 1-th iteration. At line 5,due to the definition of StrongPreImage, every tuple of states in G ∪ StatesOf(S A) is considered as a possible targetstarting from any state s, either by some input action or by all possible output actions. Due to the inductive hypothesis andthe definition of StrongPreImage, the produced state–action pairs P r will be such that the goal will be achievable fromtheir states in at most i + 1 steps, that is, if (cid:3)s, a(cid:4) ∈ P r, then STSof (S A ∪ P r, s, G) is a subtree of depth up to i + 1 (in otherwords, given the inductive hypothesis and the correspondence between the definition of StrongPreImage and requirements(2) and (3) in Definition 24, the application of StrongPreImage extracts exactly the states and transitions corresponding toa subtree of depth i + 1). At line 6, only state–action pairs in P r for which the goal is reachable in exactly i + 1 steps willbe stored in NewSA, since due to the inductive hypothesis, all those for which the goal can be reached in up to i steps arein S A already. At line 8, such state–action pairs are added to S A, which as a consequence will hold all of the state–actionpairs from which the goal is reachable in up to i + 1 steps. (cid:2)Theorem 37 (Correctness and completeness). If the algorithm returns a state–action table S A, then S A contains a solution subtree tothe composition problem. If the algorithm returns Fail, then no solution subtree to the composition problem exists.Proof. This is a direct consequence of Lemma 36: if and only if I ∈ G ∪ StatesOf(S A), a (finite) solution subtree for I exists,and in that case, it is contained in SA. Depending on such condition, either S A or Fail is returned (lines 10–14). (cid:2)The implementation of the algorithms for belief-level domain construction, and for searching the solution subtree, relyon a symbolic machinery to effectively represent and manipulate sets of states, where Binary Decision Diagrams (BDDs [26])are used as a canonical representation for formulas over state variables. This symbolic representation technology has beenlargely investigated in the areas of Model Checking, Diagnosis, Program Synthesis and Planning (see e.g. [13,58,32,39,88,47]),and is at the core for the improved performances of state-of-the-art tools in these areas (see e.g. [27,14,48]).While, within the two phases (belief-level construction and search), the states of the symbolic representation assumevery different meanings, we uniformly adopt the SMV language to describe STSs: in belief construction, both for the domaingiven in input and the outputted belief-level STSs; in search, as the input domain. SMV is the native language used in model-checking systems such as NuSMV [27]. It is a rich language, allowing a variety of constructs and mechanisms to compactlyrepresent STSs. On top of a fairly standard representation of the states and actions by means of state and action variables, itallows representing transitions by combining an explicit enumeration of corresponding trans statements, and a descriptionof the evolution of variables by means of (possibly conditional) assignments. Indeed, the representation of STSs via SMVis schematic, and very close to the one depicted in Section 3. Moreover, a very relevant feature for our purpose stands inthe possibility to define independent “modules”; semantically, independent modules are equivalent to their parallel product,P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361347while internally, a disjunctively partitioned transition relation is stored so to save significant space and computation time.As mentioned, this is very useful in belief-level construction: given the disjointness of input/outputs amongst componentservices, it holds that Bel(Σ1 (cid:16) · · · (cid:16) Σn) = Bel(Σ1) (cid:16) · · · (cid:16) Bel(Σn), and as such, we can build the belief-level independentlyfor each component, and implicitly combine them by representing them as modules.Thus, in belief-level construction, the states of the input domain correspond to states of the STS associated to a com-ponent Web service; in this case, a BDD represents a set of indistinguishable states of one service, i.e. a belief. Based onsuch representation, belief-level construction explicitly enumerates the beliefs for a single component service, but symbol-ically evolves the sets of states they represent, by internal or input/output actions. The resulting belief-level domain for acomponent service is emitted as a module in the SMV language, featuring input/output variables that correspond to thosein the STS (which, in turn, are connected to parts of input/output operations in the original ws-bpel input). The state ofsuch belief-level system consists of a single enumerative SMV variable that names all the possible beliefs traversed bythe component. The dynamics of such belief-level system is represented via a list of trans statements describes the wayinput/output actions connect beliefs. Then, the modules corresponding to the components services are then simply gluedtogether within a unique SMV file, which represents the overall domain to be searched upon, and whose states correspondto beliefs of Bel(Σ1 (cid:16) · · · (cid:16) Σn), i.e. to tuples (cid:3)B1, . . . , Bn(cid:4) where B i ∈ Bel(Σi). This means that symbolically evolving a setof states, as performed by the search algorithm, corresponds to evolving a set of state sets of the component services; thiswould be extremely demanding, and practically unfeasible, by an explicit enumeration of the states, making our symbolicfactored representation technique virtually necessary.We remark that, as it is well known from the literature on binary decision diagrams, e.g. [26,13], symbolic repre-sentations, in principle, may blow-up as badly as enumerative ones. However, as witnessed in the huge literature onmodel-checking, diagnosis and monitoring, BDDs are capable, in the vast majority of cases, to represent formulas in asize polynomial in the number of propositions, and therefore, due to the polynomial complexity of the key BDD operations,to manipulate them effectively. This result is due in good part to the usage of advanced heuristics and optimizations in-side the realization of software BDD packages, and it holds independently from the fact that formulas may (and often do)feature exponentially many models in the number of propositions. That is, BDD representations are in most cases compactand effective, even when a corresponding model-enumerative representation may not be handled in practice. Naturally, itis possible to design “pathological” formulas that cause the blow-up of BDD representations, and it is known that also fora very limited set of practical cases (e.g. combinatorial multiplier circuits in hardware verification), BDD representationsare not polynomial. In the following section, we empirically test the approach, and we will therefore be able to discusswhether the good practical results on BDDs shown in the literature on model-checking and the related areas of planning asmodel-checking, symbolic diagnosis and monitoring also apply to the problem of Web service composition.6. Experimental evaluationIn order to test the effectiveness of the proposed technique, we have implemented the architecture proposed in Fig. 9,realizing the translations between ws-bpel and STS described in Section 3, the belief-level construction of Definition 23and the search algorithm in Fig. 12. Our platform makes use of CUDD [85], an effective BDD package that offers effectiveprimitives including highly advanced memory and space optimizations [25,91].On our platform, we conducted a set of experiments, executing them over a 1.2 GHz Pentium machine, equipped with4 GByte memory, running Linux. All of our tests have been run setting a timeout at 3600 seconds of CPU usage.Our analysis aims at identifying which structural and dimensional features of Web services impact on the performanceof our composition platform, and in which way. This allows us to discuss the scalability and limits of our approach.More specifically, our analysis focuses on the composition of loop-free services, for which the complexity of orchestratingprotocols can be more easily analyzed observing their structure, and, before tackling more general scenarios, starts byconsidering a set of symmetric scenarios where all services play the same role. These symmetric scenarios allow evaluatingthe scalability over the number of asynchronous component services, and are organized as follows:(1) We first consider “simple” services, which encode question-and-answer procedures that simply receive a message, pro-duce an output and terminate. We will study both deterministic services, whose answer is a function of the input, andnondeterministic ones, which may also return a failure message based on an internal choice.(2) Then, we consider more complex services, encoding procedures that are more lengthy, and which feature sources ofinternal nondeterminism. This means that, in order to satisfy a requirement, a composed service will be forced to takecomplex choices, depending on the behavior of the components. In particular, in order to study the impact of structuralfactors over the composition, we will consider in turn:(a) “binary unbalanced procedures”, where, at each step, a conclusive failure may be signaled by the procedure; in fact,these procedures correspond to “concatenations” of simple nondeterministic services;(b) “binary balanced procedures”, where two possible answers are possible at each interaction, none of which signalinga conclusive failure;(c) “n-ary balanced procedures”, which (at a high level) generalize binary balanced procedures in terms of number ofpossible answers.348P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 13. Combining N atomic services.For both sets, we will vary the size of the sets of services that need to be composed, analyzing the performance of thevarious phases in the composition task: construction of the belief-level domain, internalization and search. This will allow usto draw some considerations about the relationship of the results in the various settings and the structural characteristics ofthe involved services. Finally, as an example of a non-symmetric, more realistic scenario, we will consider the performanceover the P&S example, discussing its relationship with the symmetric scenarios introduced above.We remark that, to have experiments comparable, we will keep a fixed arity for the types of the objects handled by thecomponent services of all the scenarios. In particular, all services will rely on disjoint binary types, since this is sufficientto guarantee, for all the cases we consider, that the synthesized orchestration enacts a fully generic protocol. We leave toSection 8 a further discussion on different ways to ground variable types.6.1. Simple servicesWe start by considering the simpler services that may be thought of, which model a (fully deterministic, predictable)function computation: each component W i receives an input D, computes a (non-interpreted) function f i(D) and returns itas an output D, terminating into a state s f .(cid:11)Given a set of such components, the composition requirement consists of having the n-th service return the nestedfunction fn( fn−1(. . . ( f 1(D)))) (and have each component terminate successfully). In terms of elements of the finite STSsaccording to Section 3, the goal consists of a formula that (a) for all services, requires the state to be s f , and (b) describesthe nested computation as a disjunction of equalities between service variables and ground function terms.To achieve the goal, insofar functions refer to many-valued ranges, a composed procedure must suitably interleave theinvocations to the components, passing at each step the current result; we remark again that this would not be the case,should functions feature unary domains or co-domains.The results are shown in Fig. 13. The three lines report the timings required in the respective phases of our approachto service composition: Bel constr. refers to the construction of the belief-level search space; Read/compile refers to the timespent for reading and internalizing the representation of such space; and Synthesis refers to the search and emission of theorchestration service. We are able to combine up to 20 services within a very reasonable time. We observe that belief-levelconstruction has a significant relative cost; however, as expected, the partitioned representation helps out, and the timespent in this phase grows only linearly with the number of component services.Once the belief-level system has been represented, it has to be internalized; constructing its internal representation,which implies computing the parallel product of each module, has a marginal cost, which however grows polynomially inthe number of components.For large sets of components, the most relevant cost is due to the search phase, which seems to grow up quasi-exponentially, with some notable oscillations.We remark that, in the vast majority of cases, exponentially large sets of states can be represented by polynomially largeBDD structures, and thus manipulated within polynomial time. Since we adopt a breadth-first backward search style, giventhe domain under exam, composing N services will require computing a number of layers proportional to N; the number ofnodes in each layer can be thought, at a high level of approximation, as growing polynomially at each backward iteration.All this would then result in an overall search time polynomial in N.However, breadth-first search is very memory-demanding, and when N is high, the garbage collection mechanism ofthe BDD package enters into play to rearrange data structures, and remove unused ones. This is what influences most theperformance of the search for high values of N, in particular with N > 15.P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361349Fig. 14. Combining N branching services.We then step to the smaller possible Web services that encode a possibly failing procedure; i.e., each Web service willaccept a request, and either compute a function, or fail. In the former case, the service will wait for an ack/nack signal,depending on which it finally fails or terminates successfully. Thus such services will feature two branching points; the firstone in the procedure encodes a form of “internal” nondeterminism, while the second represents and “external” nondeter-minism which is necessary in order to be capable to drive the service to fail or to succeed. The requirement for combininga number of such services consists in asking for the set of services to compute a nested function fn( fn−1(. . . ( f 1(D))))of a datum D, and have each component terminate successfully. In sub-order, we require to have every started componentterminate with failure. We remark that allowing the externally commanded refusal is necessary so to have services “control-lable” enough to be able to compose them according to the requirement. That is, the goal is similar to the one consideredin the previous case, but adds as alternative (that is, “in or”) a formula stating that, for all services, the state is either theinitial one, or the one associated to failure. The composed procedure must implement the following behavior, which com-bines transferring data “in the right order” between services, and detecting and handling failure situations by appropriatelydriving each suspended service to fail.• invoke the service W in computing f in , passing it D• if the service answers with failure, terminate• receive Dn from W in , and invoke the service W in−1 computing f in−1 , passing it Dn• if W in−1 answers with failure, send a nack to W in and terminate• . . .• receive D1 from W i1 , and invoke the service W i0 computing f i0 , passing it D1• if W i0 answers with failure, send a nack to every service W i1 , . . . , W in and terminate• send ack to every service W i0 , . . . , W in and terminate.The results for this test are reported in Fig. 14.We observe that it is possible to achieve, in a reasonable time, the composition of a rather high number of such ser-vices — approximately 20. In this case, the harder phase in the composition consists in the construction of the belief-levelsystem Σ(cid:16). Again, thanks to the modular modeling allowed by the SMV language, the weight of constructing and emittingΣ(cid:16) grows only linearly with the number of component services — while its interpretation to build the internal representa-tion of Σ(cid:16) is polynomial. Both costs are about an order of magnitude higher than in the case of deterministic components.The complexity of searching for a controller grows according to a polynomial curve, not unlikely the one for the pre-dictable services. Indeed, the cost of the composition is only marginally higher than the one for predictable services.This result is somehow to be expected: the cost of the search basically depends on the number of states to be representedin the number N of layers generated by the backward search, and N amounts to the length of the longer interaction neededto compose the services. But, in this test, given a set of n components, N is the same regardless of whether the componentsare predictable or not, and the number of visited states do not differ significantly.These first tests on simple services hint at the fact that our approach might be particularly suited to deal with nonde-terministic services: not only our representation is general enough to capture nondeterminism, but also the performance ofcomposition seems to be affected only marginally by the need of handling different contingencies. In fact, for the specificcase of fully predictable atomic services, it is possible to adopt simpler formalisms (such as STRIPS [38]) and more focusedsearch techniques (e.g. forms of classical heuristic planning, see [44]) to obtain a better scalability. We remark, however,350P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 15. A 3-cell binary unbalanced component.that we provide an approach that is more general, and encompasses practical situations where services obey to an internallogic and expose a nondeterministic behavior.6.2. Complex servicesWe now consider services that encode multiple interactions, where each interaction may possibly lead to a failure of theservice, and such that a large variety of functions may be computed.6.2.1. Binary unbalanced proceduresWe start by analyzing services which generalize the kind of nondeterministic service used in the “simple” test, by encod-ing a “sequential” pattern of nondeterministic interaction. Each “cell” of the pattern represents one interaction analogous tothe one explained in the previous subsection: a request is received, and either a refusal message is given back, or a functionf i is computed, and the service suspends for either an ack or a nack message. As such, each cell may fail (because it refusescomputing f i , or because it receives a nack) or succeed. Failure of the cell corresponds to failure of the service; successof the cell, instead, activates the next “cell”, and the success of the service corresponds to the success of the last cell. Wecall such components “binary unbalanced”; the number of their branches grows linearly with the number of cells, and sodoes the length of the longer possible sequence of query–response interactions, which we name the “depth” of the service.Fig. 15 schematically show a component service with 3 cells.We first consider the combination of a number of services containing 1, 2, 3, 4 cells each, where the goal is, once more, tocompute a nested function, or to have every component fail. The results are shown in Fig. 16, again distinguishing betweentime spent for building the search space, time spent for internalizing it, and time spent for searching it.In general, we observe that, similarly to the case of simple nondeterministic services, (a) the performance of belief-levelconstruction degrades quasi-linearly with the number of the involved services, (b) its internalization and the search degradepolynomially, and (c) the search degrades polynomially (with a higher polynomial factor).On top of this, we can observe the following:• Regarding belief-level construction and interpretation, as expected, their costs grow up when the components are morecomplex: approximately, of one order of magnitude for each additional cell. Similarly to the previous tests, belief-levelconstruction grows up linearly with the number of components, and belief-level internalization grows up polynomially.• The performance of the search phase of our composition chain depends mainly on the total number of “cells” in theset of components, and quite marginally on whether the cells are glued together in few, large component services,P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361351Fig. 16. Combining N binary unbalanced services of depth 1, 2, 3, 4.or distributed over several, small ones. For instance, we observe that to compose 12 cells, it takes about 10 seconds,regardless of whether we use 12 components with 1 cell each, 6 with two cells, or 4 with three cells. For large numbersof cells, fewer complex services are somehow preferable; this is due to the fact that in this case, the search is moreconstrained, since a smaller variety of input/output actions can be performed at each interaction step, and the cellordering inside a component W i also constrains the ordering of the input/outputs concerning the functions computedby W i .• When composing the more complex amongst these services, memory consumption becomes a major issue, mainly dueto the breadth-first style adopted by our search algorithm. Indeed, instances where services have depth d (cid:2) 3, as wellas the composition of large sets of services with depth d = 2, are terminated not due to timeouts, but due to exceedingthe 4 GByte memory bound.To study in more detail the relationships sketched above, we also analyze the combination of a fixed set of such services,where we vary the average number of cells in the component services. Fig. 17 reports the results for the composition of 2to 5 services. These graphics show clearly that both the belief-level construction and internalization, and the search times,grow up exponentially with the number of cells in the components. Concerning belief-level construction and internalization,this is due to the fact that the size of the belief-level system of a component is (potentially) exponential in the number ofstates, and thus in the number of cells. Concerning search, this is due to the fact that the length of the composed service is,in this case, also proportional to the number of cells. Also, we can observe a sort of “step” discontinuity in the curves thatrefer to belief-level construction and internalization times. This comes from the fact that the time required for the largercomponent in the set dominates the overall performance in such phases.6.2.2. Binary balanced proceduresThe pattern above is asymmetric, and such that there exists only one successful path for each service. As a consequence,similar to what happens for simple services, the combination of the services fails as soon as one of the involved servicesfails.To model a more general situation, where different success paths exist for the combination of services, and to analyzethe combination of services with a non-trivial branching factor, we generalize the pattern above into a “balanced binary352P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 17. Combining 2, 3, 4, 5 branching services of increasing depth.Fig. 18. A 2-depth “balanced branch” component.P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361353Fig. 19. Combining N binary balanced services of fixed depth (1, 2).tree” of nondeterministic interaction cells. In this case, an interaction cell computes one of two different functions, sendingout two different messages, and in each case awaiting for an ack/nack message to either terminate with success or fail.A balanced tree of such cells is such that the each success state of a cell coincides with the start cell of another one; thesuccess of such a tree is the success of a leaf cell of the tree. Fig. 18 shows a schema of such a balanced component ofdepth 2.(. . . ( f in jA goal for a set of such Web services consists in computing one of several possible combinations of functions(D)))) and having every component service succeed, or in sub-order to have every service fail. Again, in( f i1 jf i0 jterms of finite STS, this goal is compiled into a disjunctive formula that represents the control flow as a union of possiblecombinations of states of the components, and the data flow as a union of possible combinations of equalities of values withvariables and ground function terms. To achieve this goal, the composed service must decide “on the fly” in which order toinvoke the component services, since the answer of one service may not only make it impossible to achieve success, butalso determine which of the possible combinations of functions can still be pursued.We first consider combining increasingly large sets of balanced components of a fixed depth. The results are shown inFig. 19.Analogously to what we have seen for the composition of unbalanced nondeterministic components, the computationalcost of performing the belief-level construction grows up quasi-linearly with the number of the component services, andsimilarly, the cost of the search seems to grow up only polynomially. The cost of belief-level construction is largely predom-inant over that of the search unless many services are combined, or services are small — but even for the smaller balancedcomponents possible, the cost of the search becomes significant only with N > 7.Similarly to what we did for unbalanced components, we also combine sets of fixed size of balanced branching compo-nents, and we vary the their average depth (i.e. their average number of “cells”). The results are presented in Fig. 20. Again,we witness an exponential dependency of the performance of both belief-level composition and search upon the depth ofthe component services. The fact the time for belief-level construction grows by steps, being dominated by the one of thelarger component, is even more evident in this case, where the size of a component is exponential (rather than linear) inits depth. Indeed, it is just because of the “step” introduced by components of depth 3 that tests fail for larger instances ofthe problems.6.2.3. N-ary balanced proceduresFinally, we remark that, while the services considered above generalize the structure of simple ones by combining sets of“interaction cells”, they all share the fact that only binary choices are involved: either two input messages can be received,or two different branches can be nondeterministically taken by the service.We consider a variation in this aspect which generalizes in the structural dimension of width. In particular, we combinetwo services which implement a short nondeterministic procedure admitting a variety of choices, either because of internalnondeterminism, or because different external controls are possible.The first service S1, upon receiving an input datum D, performs an internal choice and decides which function f i(D),out of a set of n, it will compute. After computing it, it returns the results and suspends for an ack/nack signal that leads itto success or failure states respectively. The second service S2 may receive one of m different input signals, together with adatum D; depending on which signal did it receive, it computes one of m functions gi(D), and returns the result. After this,it suspends for an ack/nack signal that leads it to success or failure states respectively. These two services can be composedgi( f j(D)) is computed; similarly to the case of balancedby requiring that one of the possible function combinationsbranching tree, this requires an “on-the-fly” decision, on the part of the composite service, that depends on the internaldeterminism of S1.(cid:9)354P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361Fig. 20. Combining sets of 2 to 7 balanced branching services of varying average depth.The results are shown in Fig. 21, and highlight that belief-level construction is the crucial bottleneck for such a kind ofcomposition, growing exponentially with the branching factor and dominating the search.6.3. The P&SscenarioWe also tested our architecture considering the P&S scenario introduced in Example 1, considering the ws-bpel specifi-cations and composition requirements discussed throughout the paper. We remark that the P&S scenario is not symmetric,and therefore cannot be perceived as a direct instantiation of one of the scenarios tested so far. At the same time, someparts of the User, Shipper and Producer components exhibit patterns similar to those featured by the symmetric scenarios.Fig. 22 shows schematically the P&S scenario, highlighting a connection with some patterns from the “binary balanced”P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361355Fig. 21. Combining two branching services of increasing branching factor.Fig. 22. Schematic comparison of the P&S components and a binary balanced service.scenario. As one can see, the Producer and Shipper look like a slightly more complex (and not fully symmetric) version ofa binary balanced service, whereas the User is fairly different but reuses, twice, a query–response pattern also appearingthere.Our platform is capable to perform the composition for the P&S scenario in a very reasonable time: it takes 0.8 secondsto read the models, 8.4 seconds to perform the belief-level construction, and 1.0 seconds to synthesize the P&S controller.The resulting executable ws-bpel code appears to be of very reasonable quality and size: as an experiment, we asked anexperienced ws-bpel programmer to hand-code a P&S controller for the scenario, and the resulting code follows the samelines, only reducing the number of internal variables by intelligently re-using them for different purposes at different stagesof the service.6.4. Comparative analysis of resultsGiven the variety of scenarios adopted in the tests, we find it convenient to provide here a synthetic analysis of ourresults, considering the impact of the various features of the domains over the performance of the composition task, de-composed in the various phases: belief-level construction, internalization, and search. This will allow us to draw someconclusions on the applicability of our approach to different settings of the composition problem. In particular:• Construction of the belief-level STS Bel(Σ1 (cid:16) · · · (cid:16) Σn) scales up nicely, in a linear way, with the number n of com-ponents into play. This is essentially due to our ability to handle the belief-level construction of each Bel(Σi) in-dependently, representing their product in terms of modules of the obtained representation. Vice versa, belief-levelconstruction times grow up quasi-exponentially with the size of the components, represented by the number of theirstates (see e.g. Fig. 17). This is explained by the potentially exponential size of the belief-level counterpart of an STS.356P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361The presence of nondeterminism in the components has only a minor impact, due to the need, during belief-levelconstruction, to consider a larger number of possible transitions, see e.g. Figs. 13 and 14.• Concerning the internalization phase, which converts the modularized representation of Bel(Σ1 (cid:16) · · · (cid:16) Σn) into aninternal format of a unique STS, performance is polynomial with the number n of components, as shown e.g. in Fig. 13.Again, size of modules has a stronger impact, and performance degrades quasi-exponentially with it, see Fig. 17. In thisphase, the adoption of symbolic representation techniques essentially annihilates the impact of having nondeterminismin the services being composed.• The performance of synthesis appears to degrade sub-exponentially with the size of the components in all the domainswe considered; and in the vast majority of cases, it degrades only polynomially with the number of components. Thiscomes essentially from the breadth-first search style adopted during the search, in conjunction with the fact that itoperates on a symbolic representation where whole frontiers of states of Bel(Σ1 (cid:16) · · · (cid:16) Σn) are regressed at once.Again, nondeterminism in the components does not seem to have a significant impact on the performance.The above analysis on the results indicates that the approach lends particularly well to treat large numbers of Web serviceswhose description, taken in isolation, is not particularly complex (but which may embed internal choices, presented interms of nondeterminism). Dealing with the composition of large Web services may be practically difficult because of thecomplexity in obtaining their belief-level representation.More in general, from a bird’s eye view at the results over the various scenarios, we can observe that the approachproves capable to effectively tackle significantly complex composition problems, whose ad-hoc solution would have beenfar from trivial, time-demanding and error prone. For instance, the automated composition of a dozen nondeterministic,branching ws-bpel services is obtained within a couple of minutes, whereas the manual design and implementation ofsuch orchestration would take several hours. This is also shown by the performance of our platform over the P&S scenario,which improves by large the time a programmer would spend to hard-code the controller. Indeed, such a performance ranksconsistently between those of the complex binary scenarios, considering the complexity of the involved components.A good portion of the effectiveness of our approach must be acknowledged to the symbolic, BDD-based representationused by the algorithms. This confirms that, similarly to what happens in the vast majority of model-checking and diagnosisscenarios, symbolic representations are practically effective in most practical cases, in spite of their exponentially largeworse-case resource requirements.7. Related workThis paper presents a framework for composing asynchronous ws-bpel processes which is clearly framed within thecontext of a long-standing research line on service composition using planning techniques, developed at the IRST institute.Such a research line started in 2004 with [71,95], continued with [78,79,74,61,62,60,63,64], and is still evolving to date[72,21]. Indeed, this paper summarizes and significantly extends a large portion of the wealth of work cited above, actingas well as a useful pointer to further possible extensions and studies of the approach.Among the works cited above, this paper is more closely related with [71,95,78,79,62,64]; however, it significantly differsfor technical choices, and for the degree of maturity, which here allows a fully automated end-to-end provision of servicesexpressed in a de-facto standard language such as ws-bpel. As well, this is the first work that provides a clear, full-fledgedand self-contained statement of the underlying theory, and the full proofs for the correctness of the approach.More in detail, [71,95,78] are to be regarded as preliminary contributions that provided the basis to our approach. In [71,95], the general framework is presented, but (i) only high-level service descriptions are considered, and (ii) the constructionof the belief-level system is not modular. This, together with the fact that the modeling of services as a planning domain isbased on an explicit representation of message buffers, leads to rather poor practical performances. In [78], a more formalaccount of the representation of service composition in terms of planning is presented, but still no technical discussion isreported for what concerns the adopted algorithms, neither in terms of theoretical and practical scalability, nor in terms ofthe correctness of the approach. We remark that [71,95,78] stand on composition requirements based on the EaGLelanguage[36], whose high expressiveness would lead to extremely complex proofs for such properties.The above works have been extended in various directions, which are not considered here but can be perceived asrelevant pointers where to pursue a full-fledged analysis and formalization. The structuring of requirements into controland data flow sections is the core subject of [62,60], which propose and enact an advanced methodology to requirementspecification, based on the idea of “data nets” which link, by means of modular forms of constraints, the inputs and outputsof the services participating to the orchestration. Again, as also reported into the more applicative papers [72,64], theunderlying requirements rely on the EaGLespecification language, and no full algorithmic account and analysis is presented.In [74], service composition is dealt with by modeling services as well as requirements at a more abstract “knowledge”level. This allows describing the relationships between exchanged data at a conceptual level which abstracts away from theneed to mention concrete values. While this makes the approach attractive, encoding of the problem in this way results intoa non-modular planning domain and has a strong negative impact on the scalability of the performance.In common with all the works cited above, this work relies on the expressiveness and performance provided by the“planning via model checking” approach (see [16,77,32,15]), adopting its technological baseline and taking inspiration interms of general framework and approaches to search. In particular, the composition of services requires coordinating non-P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361357deterministic and partially observable entities, and is therefore conceptually close to approaches such as [16]. However, thespecific nature of service composition (due to the asynchronicity of services, and to the fact that we orchestrate multipleindependent entities, rather than control a monolithic domain), has led us to design and develop radically different algorith-mic and data representation solutions. Specifically, the solution presented here takes as a starting point the strong planningapproach of [32], which in turn is inspired by Schopper’s notion of “universal plan” [82] (but makes use of radically dif-ferent search and representation tools). On top of this, our approach applies very significant extensions which are requiredto confront with service composition: first, non-trivial pre- and post-processing phases are needed to recast the synthesisof an asynchronous controller into a form of belief-level search, and second, different algorithms are in order, due to thespecific semantics of message passing (and deadlock) between services.Our approach is also related, but significantly different, with the large variety of planning-based approaches that havebeen proposed to tackle the problem of service composition at various levels. In particular, automated (discovery and)composition of semantic Web services, e.g., based on OWL-S or WSML, is presented in [90,59,43]. A similar line is followedby [100,83], considering DAML-S [6] annotated services instead; DAML-S services are considered as well by [8], whichrecasts composition as a constraint satisfaction problem, by [65], which adopts an interpreter for an extended version of theConGolog language to adapt and compose services, and by [67], which provides a framework for simulating, verifying andcomposing Web services, by translating them into Petri Nets.Other works have been proposed to support forms of compositions starting from wsdl-like specifications of Web services,see, e.g., [73,84], or based on description in the Universal Service-Semantics Description Language (USDL) developed in thesemantic Web community [50]. Similar issues are dealt with by [4], where the composition of data access is tackled byobtaining a workflow and making use of “adapter” services.All of the above works, be they based on OWL-S, WSML, DAML-S, wsdl or USDL service specifications do not take intoaccount behavioral descriptions of Web services, like our approach does with ws-bpel. Therefore, they view automatedcomposition as a sequential composition of atomic services. This is also true of the work in [2,29], in spite of the fact thatthe result of the composition is expressed as ws-bpel. That is, none of the techniques they adopt can deal with the problemaddressed in this paper, where the domain under exam consists of nondeterministic, partially observable and asynchronouscomponent services. Recent extension to works on ConGolog [87], which consider first-order logic specifications of services,are capable to deal with more complex composition requirements, but do not analyze the connections with programminglanguages for services such as ws-bpel.Within the planning field, the need to address requirements beyond reachability is well known and established, andseveral approaches tackle the problem using different means. Temporal logics such as LTL and CTL [37] are used either todescribe planning goals or to constrain the search [53,19,77]. The Hierarchical Task Network approach followed, e.g., in [87]envisages a procedural format to express goals. In [89], procedural and declarative goals are fused to allow better flexibilityin expressing goals. While of great potential interest, all these works do not consider the problem of composing Webservices. While a general connection between planning and service composition is clear, these works start from significantlydifferent assumptions and the adoption of their approaches in the context of service composition would be far from trivial.Planning techniques have also been applied to related but somehow orthogonal problems in the field of Web services.The interactive composition of information gathering services has been tackled in [94] by using data integration techniques.Works in the field of Data and Computational Grids are more and more moving toward the problem of composing complexworkflows by means of planning and scheduling techniques [17].In the field of e-services, synthesis techniques have been proposed to solve problems related with the one we tacklehere. In particular, the work in [46,42] presents a formal framework for composing e-services from behavioral descriptionsgiven in terms of automata. This work focuses on the theoretical foundations, without providing practical implementations.Moreover, the considered composition problem is fundamentally different from ours, since it is seen as the problem ofcoordinating the executions of a given set of available services. No concrete and executable processes can be generated withthat approach.Concerning the works in [9–11,40,41,86,12] instead, it has to be remarked that they focus on fundamental aspects, morethan on application in current service oriented technologies. Moreover, while considering problems which are conceptuallyrelated to ours, they take significantly different underlying assumptions and technical choices. In [9,11,41,12], services aredescribed as fully observable entities, and are given a different communication semantics; in [10], the authors considerservices of a semantic nature, inspired by the OWL-S specification; in [40,86], the target of the composition is different andconsists of a set of de-centralized orchestration entities.Some different work tackle the composition of stateful services in a semi-automated way; this is the case of [22], thatpresents an approach stepping through their conversion in terms of YAWL [98] workflows. Again, no details on a possi-ble implementation of the approach are provided, but for a constrained scenario of interface adaptation amongst pairs ofprocesses [23].Considering a broader perspective, our work is conceptually close to those in the field of automata-based synthesis ofcontrollers, where a given domain (often referred to as the environment) can be driven by a controller, and the aim isto automatically synthesize such a controller (see, e.g., [76,97,54,66,5,75]). Indeed, the composed service can be seen asa module that controls an environment which consists of the published services. Most works in the area, however, focuson theoretical foundations and analysis, and, also due to the high theoretical and empirical complexity of the task in anunconstrained setting, do not provide practical implementations which can be useful to the automated compositions of Web358P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361services. Some efforts in this sense have been attempted by constraining to selected forms of applications. Amongst these,some work such as [48] start from assumptions, and exploit techniques, radically different from ours, while remarkably,in other cases, e.g., [96,20], the technological baseline is similar to ours, as they introduce approaches where formulas arerepresented and manipulated by means of Binary Decision Diagrams.8. ConclusionsAutomated composition of Web services constitutes an exciting novel applicative area for planning technologies. Whilethe service-oriented paradigm is strongly pushed by world-level industrial players such as IBM or Oracle, and complexdevelopment environments and languages have been provided and are continuously refined, the success of such an approachwill strongly depend on the development of powerful automated support functionalities which have lacked so far. Planninghas been identified as a first-class candidate by which it is possible to provide such functionalities; still, the particularsetting of Web services poses significant challenges that require overcoming the limitations of current planning approaches,both in terms of expressiveness and effectiveness.In this work, we provided a clear formal modeling of the problem of composing stateful Web services according tocomplex behavioral requirements. As a result, we provided a framework capable of dealing with significantly difficult com-position of services expressed in standard languages such as ws-bpel. The complexity of this task has been dealt by anappropriate pre-compilation of asynchronous behaviors, and by carefully designed search algorithms which rely on symbol-ically represented domains. We provide an extensive testing of our approach, witnessing the ability of our system to tacklesignificantly complex problems, and identifying the impact of various structural aspects of the composition in terms of theperformance and outcomes of the composition.The approach presented here is a crucial step forward to introduce automated support for service composition withinthe standard development phases of services. The approach stands on clearly defined assumptions, which we introduced inSection 2, concerning the kind of services that can be considered for composition and the kind of composition requirementsthat can be applied. In turn, this reflects on the kind of orchestrations that can be achieved. As such, this paper clearlylends to several extensions that may improve the expressiveness, flexibility, effectiveness, and ultimately the usability of ourapproach.A first important hypothesis underlying our work, as well as essentially all the works on the composition of statefulservices developed so far, is that services can be interpreted as finite automata, in spite of being realized by means of alanguage such as ws-bpel that allows infinitely-ranged variables. This implies the need to carry out a pre-processing phasethat performs an abstraction over component services, by identifying finite ranges such that coordinating the resultingfinitely-ranged ws-bpel components still requires a fully general orchestrator, whose behavior is independent from theconsidered ranges. Indeed, in all the scenarios we encountered, and in those we test, we found that it is enough to considereach variable as belonging to a binary type, and to have ranges of different types disjoint. We remark that, since our kindof requirements lead to orchestrations whose executions are finite, it is easy to devise a finitization of the componentssuch that their (finite-state) orchestration has a structure independent from the type ranges. Of course, identifying effectivefinitizations, that is finding the smallest type ranges which guarantee a general coordination of some components, is nottrivial, and this is a topic for further investigation. This problem of grounding may as well be tackled in a conceptuallydifferent way, using abstraction techniques that encode services into finite state machines which do not directly map ws-bpel operations over (finitely ranged) ws-bpel variables, but rather define the behaviors of the services at a higher level.In particular, knowledge-level encodings in the style of [70] may be used to represent symbolically the way the variablesof services relate to each other, therefore stemming away from the need of mentioning concrete variable values. Somepreliminary results using a knowledge-level encoding (different from the one in [70]) have been presented in [74]. A fullinvestigation in this respect, and a combination of knowledge-level representation with the ground-level representationadopted here, are in our agenda.The second assumption we took concerns the nature of composition requirements. We focused on reachability require-ments which specify admissible final configurations of the component services. A first implication of this is that we stick tocomponent services whose execution is guaranteed to terminate in a finite number of steps; that is, we ruled out servicesthat embed some loop which is not guaranteed to exit. A possible and somehow obvious relaxation in this sense consists inhaving more expressive requirements where infinite behaviors are allowed. For instance, one can consider problems wherethe only way to interact with components implies some iterative trial-and-error strategy. In this case, even still keeping“reachability” requirements, it is possible to relax the definition of satisfiability to consider those looping situations wherea chance of terminating still exists, therefore identifying so-called “strong cyclic” solutions [32]. This is considered in [78,74,62,60], where services with cyclic behaviors are admitted, insofar they still admit final configurations which are usedas targets for the requirements. Under this setting, it is possible to rely on specific “strong cyclic” search algorithms thatmay produce cyclic trial-and-error strategies which indefinitely keep achieving the target configurations. A further extensionmay consider composition requirements of a different nature, describing constraints over the evolution in time of compo-nents services, and/or considering preferences. For instance, in [71,78], service composition is tackled using EaGLe [77,36],a language which is inspired by the LTL temporal logic [37], but (differently from LTL) allows expressing user preferencesamongst subgoals, by handling a notion of “goal failure” and layering subgoals according to different user-defined strengths.Such extensions are especially interesting since services are only partially controllable, and therefore orchestrating themP. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361359may require dealing with a variety of more or less preferable situations. Indeed, preferences are also tentatively addressedin [78,74,62,60], since the EaGLerequirement language [36] they adopt embeds them.We also took some assumption on the language used to express services, restricting to a subset of the de-facto ws-bpelstandard which appears sufficient to support the abstract service specifications needed as input to the composition. Never-theless, we plan to cover a broader portion of such a language. This investigation does not appear particularly compellingunder a theoretical perspective, but it may require substantial effort to avoid huge blow-ups of the models when certainspecific ws-bpel features are exploited.While all the extensions are extremely relevant and clearly pointed out by the assumptions taken in this work, and whilesome work along those directions has been conducted already, we remark that the form of composition we consider here isalready expressive enough to cover a large variety of relevant service composition scenarios. Focusing on this setting allowsus to keep the presentation reasonably compact and self-contained, while at the same time comprehensively surveying allthe formal and empirical aspects at a sufficient level of detail.Of course, a further clear direction of work stands in investigating techniques for further improving the scalability. In thissense, devising new requirement languages that constrain service behaviors to follow some easy-to-specify pattern seemsa promising option. Finally, we intend to tackle the issue of associating semantics to the activities of stateful Web services,in order to be able to respond to composition requirements specified according to some semantics. In particular, we planto extend the work to the automated composition of semantic Web services, e.g., described in owl-s [30] or wsmo [101],along the lines of the work done in [95].References[1] T. Andrews, F. Curbera, H. Dolakia, J. Goland, J. Klein, F. Leymann, K. Liu, D. Roller, D. Smith, S. Thatte, I. Trickovic, S. Weeravarana, Business ProcessExecution Language for Web Services (version 1.1), 2003.[2] V. Agarwal, G. Chafle, K. Dasgupta, N. Karnik, A. Kumar, S. Mittal, Biplav B. Srivastava, Synthy: A system for end to end composition of Web services,Journal of Web Semantics: Science, Services and Agents on the World Wide Web 3 (4) (2005) 311–339.[3] ActiveBPEL, The Open Source BPEL Engine, http://www.activebpel.org.[4] J.L. Ambite, D. Kapoor, Automatically composing data workflows with relational descriptions and shim services, in: Proc. of ISWC’07, 2007.[5] E. Asarin, O. Maler, A. Pnueli, J. Sifakis, Controller synthesis for timed automata, in: IFAC Symposium on System Structure and Control, 1998, pp. 469–474.[6] A. Ankolekar, DAML-S: Web service description for the semantic Web, in: Proc. ISWC’02, 2002.[7] A. Arnold, Finite Transition Systems: Semantics of Communicating Systems, Prentice Hall International, 1994.[8] R. Aggarwal, K. Verma, J.A. Miller, W. Milnor, Constraint driven Web service composition in METEOR-S, in: Proc. of SCC’04, IEEE Computer Society,2004, pp. 23–30.[9] D. Berardi, D. Calvanese, G. De Giacomo, M. Lenzerini, M. Mecella, Automatic composition of e-services that export their behaviour, in: Proc. ICSOC’03,2003.[10] D. Berardi, D. Calvanese, G. De Giacomo, R. Hull, M. Mecella, Automatic composition of transition-based semantic Web services with messaging, in:Proc. of VLDB’05, 2005, pp. 613–624.[11] D. Berardi, D. Calvanese, G. De Giacomo, M. Mecella, Composition of services with nondeterministic observable behaviour, in: Proc. ICSOC’05, 2005.[12] D. Berardi, F. Cheikh, G. De Giacomo, F. Patrizi, Automatic service composition via simulation, Int. J. Found. Comput. Sci. 19 (2) (2008) 429–451.[13] J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, L.J. Hwang, Symbolic model checking: 1020 states and beyond, Information and Computation 98 (2)(June 1992) 142–170.[14] P. Bertoli, A. Cimatti, M. Pistore, M. Roveri, P. Traverso, MBP: a model based planner, in: Proc. of IJCAI’01 Workshop on Planning under Uncertaintyand Incomplete Information, 2001.[15] P. Bertoli, A. Cimatti, M. Pistore, P. Traverso, A framework, for planning with extended goals under partial observability, in: Proc. ICAPS’03, 2003.[16] P. Bertoli, A. Cimatti, M. Roveri, P. Traverso, Planning in nondeterministic domains under partial observability via symbolic model checking, in: Proc.IJCAI’01, 2001.[17] J. Blythe, E. Deelman, Y. Gil, Planning for workflow construction and maintenance on the grid, in: Proc. of ICAPS’03 Workshop on Planning for WebServices, 2003.[18] B. Bonet, H. Geffner, Planning with incomplete information as heuristic search in belief space, in: Proc. of AIPS’00, 2000, pp. 52–61.[19] F. Bacchus, F. Kabanza, Using temporal logic to express search control knowledge for planning, Artificial Intelligence 116 (1-2) (2000) 123–191.[20] B. Bonakdarpour, S. Kulkarni, Exploiting symbolic techniques in automated synthesis of distributed programs with large state space, DistributedComputing Systems (2007).[21] P. Bertoli, R. Kazhamiakin, M. Paolucci, M. Pistore, H. Raik, M. Wagner, Control flow requirements for automated service composition, in: Proc. ofICWS’09, 2009.[22] A. Brogi, R. Popescu, Towards semi-automated workflow-based aggregation of Web services, in: Proc. ICSOC’05, 2005.[23] A. Brogi, R. Popescu, Automated generation of BPEL adapters, in: Proc. of ICSOC’06, 2006, pp. 27–39.[24] F. Bacchus, R. Petrick, Modeling an agents incomplete knowledge during planning and execution, in: Proc. of KR’08, 2008, pp. 432–443.[25] K. Brace, R. Rudell, R. Bryant, Efficient implementation of a BDD package, in: Proceedings of the 27th ACM/IEEE Conference on Design Automation,1990, pp. 40–45.[26] R.E. Bryant, Graph-based algorithms for Boolean function manipulation, IEEE Transactions on Computers C-35 (8) (1986) 677–691.[27] A. Cimatti, E.M. Clarke, F. Giunchiglia, M. Roveri, NuSMV: a new symbolic model checker, International Journal on Software Tools for TechnologyTransfer (STTT) 2 (4) (2000).[28] E. Christensen, F. Curbera, G. Meredith, S. Weerawarana, Web Service Definition Language (WSDL 1.1), http://www.w3.org/TR/wsdl, 2001.[29] G. Chafle, G. Das, K. Dasgupta, A. Kumar, S. Mittal, S. Mukherjea, B. Srivastava, An integrated development environment for Web service composition,in: Proc. of ICWS’07, 2007.[30] OWL-S Coalition, OWL-S: Semantic markup for Web services, Technical White paper (OWL-S version 1.0), 2003.[31] OASIS Web Services Business Process Execution Language (WSBPEL) Technical Committee, Web Services Business Process Execution Language Version2.0 – OASIS Standard, 2007.[32] A. Cimatti, M. Pistore, M. Roveri, P. Traverso, Weak, strong, and strong cyclic planning via symbolic model checking, Artificial Intelligence 147 (1–2)(2003) 35–84.360P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361[33] M.D. Denz, Charting the evolving eHealth ecosystem, in: Proc. of eHealth’08, 2008.[34] D. Mc Dermott, Estimated-regression planning for interactions with Web services, in: Proc. AIPS’02, 2002, pp. 204–211.[35] A. Dogac, G.B. Laleci, S. Kirbas, Y. Kabak, S. Sinir, A. Yildiz, Y. Gurcan, Artemis: deploying semantically enriched Web services in the healthcare domain,Information Systems 31 (4–5) (2006) 321–339.[36] U. Dal Lago, M. Pistore, P. Traverso, Planning with a language for extended goals, in: Proc. AAAI’02, 2002.[37] E.A. Emerson, Temporal and modal logic, in: J. van Leeuwen (Ed.), Handbook of Theoretical Computer Science, Volume B: Formal Models and Seman-tics, Elsevier, 1990.[38] R.E. Fikes, N.J. Nilsson, STRIPS: a new approach to theorem proving in problem solving, Journal of Artificial Intelligence 2 (1971) 189–208.[39] H. Foster, S. Uchitel, J. Magee, J. Kramer, Model-based verification of Web service compositions, in: Proc. ASE’03, 2003.[40] G. De Giacomo, M. de Leoni, M. Mecella, F. Patrizi, Automatic workflows composition of mobile services, in: Proc. of ICWS’07, 2007, pp. 823–830.[41] G. De Giacomo, S. Sardina, Automatic synthesis of new behaviors from a library of available behaviors, in: Proc. of IJCAI’07, 2007, pp. 1866–1871.[42] R. Hull, M. Benedikt, V. Christophides, J. Su, E-services: a look behind the curtain, in: Proc. PODS’03, 2003.[43] J. Hoffmann, P. Bertoli, M. Pistore, Web service composition as planning, revisited: In between background theories and initial state uncertainty, in:Proc. of AAAI’07, 2007.[44] J. Hoffmann, B. Nebel, The FF planning system: fast plan generation through heuristic search, Journal of Artificial Intelligence Research 14 (2001)253–302.[45] G. Holzmann, The Spin Model Checker: Primer and Reference Manual, Addison-Wesley, November 2003, preview available at http://safari.ibmpressbooks.com/0321228626/app01?close=0.[46] R. Hull, Web services composition: a story of models, automata, and logics, in: Proc. of ICWS’05, 2005.[47] B. Jobstmann, R. Bloem, Optimizations for LTL synthesis, in: Proc. of Formal Methods in Computer Aided Design (FMCAD’06), 2006, pp. 117–124.[48] B. Jobstmann, S. Galler, M. Weiglhofer, R. Bloem, Anzu: a tool for property synthesis, in: Proc. of CAV’07, 2007, pp. 258–262.[49] R. Kazhamiakin, Formal analysis of Web service compositions, PhD thesis, International Doctorate School in ICT – DIT University of Trento, Trento,Italy, March 2007.[50] S. Kona, A. Bansal, G. Gupta, Automatic composition of semantic Web services, in: Proc. of ICWS’07, 2007.[51] T. Zeng, K. Kim, C.J. Bonk, Surveying the future of workplace e-learning: the rise of blending, interactivity, and authentic learning, eLearn Maga-zine 2005 (6) (2005), available at http://www.elearnmag.org/.[52] W.B. Korte, General practitioner use of ICT and eHealth in Europe 2002–2007 – Results from a pan-European survey, in: Proc. of eHealth’08, 2008.[53] F. Kabanza, S. Thiebaux, Search control in planning for temporally extended goals, in: Proc. of 15th International Conference on Automated Planningand Scheduling (ICAPS-05), 2005, pp. 130–139.[54] O. Kupferman, M. Vardi, Synthesis with incomplete information, in: Proc. of ICTL’97, 1997.[55] S.M. Lee, T. Hwang, J. Kim, An analysis of diversity in electronic commerce research, International Journal of Electronic Commerce 12 (1) (2007).[56] S.S. Lam, A.U. Shankar, A relational notation for state transition systems, IEEE Transactions on Software Engineering 16 (7) (1990) 755–775.[57] A. Marconi, Automated process-level composition of Web services: From requirements specification to process run, PhD thesis, International DoctorateSchool in ICT – DIT University of Trento, Trento, Italy, April 2008.[58] K.L. McMillan, Symbolic Model Checking, Kluwer Academic Publ., 1993.[59] S. McIlraith, R. Fadel, Planning with complex actions, in: Proc. NMR’02, 2002.[60] A. Marconi, M. Pistore, P. Poccianti, P. Traverso, Automated Web service composition at work: the Amazon/MPS case study, in: Proc. ICWS’07, 2007.[61] A. Marconi, M. Pistore, P. Traverso, Implicit vs. explicit data-flow requirements in Web service composition goals, in: Proc. ICSOC’06, 2006.[62] A. Marconi, M. Pistore, P. Traverso, Specifying data-flow requirements for the automated composition of Web services, in: Proc. SEFM’06, 2006.[63] A. Marconi, M. Pistore, P. Traverso, Process-level composition of Web services: a semi-automated iterative approach, Annals of Mathematics, Comput-ing and Teleinformatics 1 (5) (2007).[64] A. Marconi, M. Pistore, P. Traverso, Automated composition of Web services: the ASTRO approach, IEEE Data Eng. Bull. 31 (2008).[65] S. McIlraith, S. Son, Adapting Golog for composition of semantic Web services, in: Proc. KR’02, 2002.[66] R.v.D. Meyden, M. Vardi, Synthesis from knowledge-based specifications, in: Proc. of CONCUR’98, 1998, pp. 34–49.[67] S. Narayanan, S. McIlraith, Simulation, Verification and automated composition of Web services, in: Proc. WWW’02, 2002.[68] G. Nemirovskij, M. Wolters, E. Heuel, Distributed study: a semantic Web services approach for modelling a common educational space, in: Proc. ofWorld Conference on Educational Multimedia, Hypermedia and Telecommunications 2008, 2008.[69] Oracle, Oracle BPEL Process Manager, http://www.oracle.com/products/ias/bpel/.[70] R. Petrick, F. Bacchus, A knowledge-based approach, to planning with incomplete information and sensing, in: Proc. AIPS’02, 2002.[71] M. Pistore, P. Bertoli, F. Barbon, D. Shaparau, P. Traverso, Planning and monitoring Web service composition, in: Proc. AIMSA’04, 2004.[72] M. Pistore, P. Braghieri, P. Bertoli, A. Biscaglia, A. Marconi, S. Pintarelli, M. Trainotti, At Your Service: Service-Oriented Computing from an EU Perspec-tive, MIT Press, 2009 (Chapter 8).[73] S. Ponnekanti, A. Fox, SWORD: A developer toolkit for Web service composition, in: Proc. WWW’02, 2002.[74] M. Pistore, A. Marconi, P. Bertoli, P. Traverso, Automated composition of Web services by planning at the knowledge level, in: Proc. of IJCAI’05, 2005.[75] N. Piterman, A. Pnueli, Y. Saar, Synthesis of reactive designs, in: Proc. of VMCAI, 2006, pp. 364–380.[76] A. Pnueli, R. Rosner, On the synthesis of an asynchronous reactive module, in: Proc. ICALP’89, 1989.[77] M. Pistore, P. Traverso, Planning as model checking for extended goals, in: Proc. IJCAI’01, 2001.[78] M. Pistore, P. Traverso, P. Bertoli, Automated composition of Web services by planning in asynchronous domains, in: Proc. ICAPS’05, 2005.[79] M. Pistore, P. Traverso, P. Bertoli, A. Marconi, Automated synthesis of composite BPEL4WS Web services, in: Proc. ICWS’05, 2005.[80] R. Ruffolo, The ultimate e-commerce software shopping list, Computer World on Line, available at http://www.computerworld.com.au/, 2008.[81] T. Son, C. Baral, Formalizing sensing actions: a transition function based approach, Artif. Intell. 125 (1-2) (2001) 19–91.[82] M. Schopper, Universal plans for robots in unpredictable environments, in: Proc. of 10th International Joint Conference on Artificial Intelligence(IJCAI’87), 1987, pp. 1039–1046.[83] M. Sheshagiri, M. desJardins, T. Finin, A planner for composing services described in DAML-S, in: Proc. AAMAS’03, 2003.[84] D. Skogan, R. Gronmo, I. Solheim, Web service composition in UML, in: Proc. EDOC’04, 2004.[85] F. Somenzi, CUDD: CU decision diagram package release 2.3.1, available at http://vlsi.colorado.edu/fabio/CUDD/, 2001.[86] S. Sardina, F. Patrizi, G. De Giacomo, Automatic synthesis of a global behavior from multiple distributed behaviors, in: Proc. of AAAI’07, 2007, pp.1063–1069.[87] S. Sohrabi, N. Prokoshyna, S. McIlraith, Web service composition via generic procedures and customizing user preferences, in: Proc. of ISWC’06, 2006,pp. 597–611.[88] A. Schumann, Y. Pencolè, S. Thièbaux, Diagnosis of discrete event systems using binary decision diagrams, in: Proc. of the 15th International Workshopon Principles of Diagnosis (DX’04), 2004.[89] D. Shaparau, M. Pistore, P. Traverso, Fusing procedural and declarative planning goals for nondeterministic domains, in: Proc. of AAAI’08, 2008, pp.983–990.P. Bertoli et al. / Artificial Intelligence 174 (2010) 316–361361[90] E. Sirin, B. Parsia, D. Wu, J. Hendler, D. Nau, HTN planning for Web service composition using SHOP2, Journal of Web Semantics 1 (4) (2004) 377–396.[91] J. Sanghavi, R. Ranjan, R. Brayton, A. Sangiovanni-Vincentelli, High performance BDD package by exploiting memory hierarchy, in: Proceedings of the33rd annual conference on Design automation, 1996, pp. 635–640.[92] E. Sakkopoulos, E. Sourla, A. Tsakalidis, M.D. Lytras, Integrated system for eHealth advisory Web services provision using broadband networks, Inter-national Journal of Social and Humanistic Computing 1 (1) (2008) 36–52.[93] L. Tuan, C. Baral, X. Zhang, T. Son, Regression with respect to sensing actions and partial states, in: Proc. of AAAI’04, 2004, pp. 556–561.[94] S. Thakkar, C. Knoblock, J.L. Ambite, A view integration approach to dynamic composition of Web services, in: Proc. of ICAPS’03 Workshop on Planningfor Web Services, 2003.[95] P. Traverso, M. Pistore, Automated composition of semantic Web services into executable processes, in: Proc. ISWC’04, 2004.[96] E. Tronci, Automatic synthesis of controllers from formal specifications, in: Proc. of Second IEEE International Conference on Formal EngineeringMethods (ICFEM’98), 1998.[97] M.Y. Vardi, An automata-theoretic approach to fair realizability and synthesis, in: Proc. CAV’95, 1995.[98] W.M.P. van der Aalst, A.H.M. ter Hofstede, YAWL: yet another workflow language, Information Systems 30 (4) (2005) 245–275.[99] G. Vossen, P. Westerkamp, E-learning as a Web service, in: Proc. of IDEAS03, 2003.[100] D. Wu, B. Parsia, E. Sirin, J. Hendler, D. Nau, Automating DAML-S Web services composition using SHOP2, in: Proc. ISWC’03, 2003.[101] WSMO, The Web service modeling framework, SDK WSMO working group, http://www.wsmo.org/, 2004.