Artificial Intelligence 103 (1998) 273-294 Artificial Intelligence Applications of the situation calculus to formalizing control and strategic information: the Prolog cut operator Department of Computer Science, The Hong Kong University of Science and Technology, Clear Water Bq Kowloon, Hong Kong Fangzhen Lin ’ Abstract is a natural formalism We argue that the situation calculus and reasoning about information. As a case study, in this paper we provide a situation calculus control and strategic in Prolog. We show that semantics to this our semantics semantics, operator using cut is provably correct with respect to the stable model semantics. 0 1998 Elsevier Science B.V. All rights reserved. is well-behaved when the programs are properly stratified, and that according implementation of the negation-as-failure the central search control operator for the Prolog cut operator, the conventional for representing 1. Introduction The situation calculus reasoning about actions some reserved predicate and function that block A is initially clear, we write: (McCarthy and Hayes [Sl) is a formalism in dynamic domains. and It is a many-sorted predicate calculus with in the blocks world to say symbols. For example, for representing H(clear(A), So), where H is a reserved binary predicate symbol denoting causes on(x, y) to be true, we write: * the initial situation. As an another example, that stands for “holds”, and SO is a reserved constant to say that action stuck(x, y) H(ofi(x, Y), ~~MWx, ~1, s)), ’ E-mail: flin@cs.ust.hk. 2 In this paper, free variables in a displayed formula are assumed to be universally quantified. 0004-3702/98/$ PII: SOOO4-3702(98)00054-X - see front matter 0 1998 Elsevier Science B.V. All rights reserved 214 E Lin /Artijcinl Intdli~mcr 103 (IWX) 27.1-294 where the reserved function do(u, s) denotes in the situation s. This is an example of how the effects of an action can be represented the situation calculus. Generally, the resulting situation of doing the action a in in the situation calculus: l situations are first-order objects that can be quantified over; l a situation carries information about its history, i.e., the sequence of actions that have been performed so far. For example, the history of the situation do(stack(A. B), do(stuck(B, C), SO)) is [stuck(B, C), stuck(A, B)], i.e., the sequence of actions in the initial situation enforce a one-to-one correspondence to reach it. As we shall see later, our foundational that have been performed axioms will between situations and sequences of actions. information in AI planning, thus isomorphic i.e., sequences of actions according to situations. So control knowledge for a plan in planning, and reasoning about control knowledge. For example, Although our long term goal is to develop a general We believe that these two features of the situation calculus make it a natural formalism representing is a sequence of actions, which often are constraints on desirable plans, becomes constraints on situations Similarly, when we talk about control to constraints on derivations, (Lin [6]). in logic programming, we are referring to (Lin and Reiter [7]). for representing and reasoning the situation calculus, our focus in this paper is the Prolog cut operator, the central search control operator in Prolog. for logic programs with cut, and show semantics We shall provide a situation calculus stratified. We also is well-behaved when the programs are properly that our semantics show that according of the negation-as- implementation the conventional to this semantics, failure operator using cut is provably correct with respect to the stable model semantics of Gelfond and Lifschitz has been shown between a declarative semantics of negation and that of cut. [3]. To the best of our knowledge, this is the first time a connection in problem solving using about control knowledge framework This paper is organized as follows. Section 2 briefly reviews Section 3 reviews the basic concepts in the situation calculus and logic programming. the situation calculus semantics of (Lin and Reiter [7]) for cut-free logic programs. For the purpose of this paper, the key property of this semantics are identified with situations. Section 4 extends this semantics to logic programs with cut. This is done by an axiom on accessible situations, are not “cut off” by cut. Section 5 shows that our semantics stratified programs. Section 6 shows that the conventional failure using cut is provably correct. Finally Section 7 concludes that is, those situations whose corresponding derivations for a class of in logic programming is that derivations is well-behaved implementation of negation-as- this paper. 2. Logical preliminaries 2.1. The situation calculus The language of the situation calculus is a many-sorted We assume propositional for everything the following sorts: situation for situations, action fluents such as clear whose truth values depend on situations, else. As we mentioned above, we assume second-order one with equality. fluent for for actions, and object that Se is a reserved constant E Lin / Art$cial lntelligenre IO3 ( 1998) 273-294 21s c do(la,b.cl,SO) d do([a,b,c,dl,SO) a f 0 SO do(a,SO) do(la,cl,SO) Fig. 1. A function f as required by the axiom (6). denoting in a situation, do a reserved binary function denoting addition, we assume the following the initial situation, H a reserved predicate for expressing properties about fluents the result of performing an action. In two partial orders on situations: l C: following convention, we write c in infix form. By s c s’ we mean that s’ can for from s by a sequence of actions. As usual, s C s’ will be a shorthand be obtained s c s’ v s = s’. l C: we also write c in infix form. By s c s’ we mean that s can be obtained by deleting some of its actions. Similarly, s C s’ stands for s c s’ v s = s’. from s’ We shall consider only the discrete situation calculus with the following foundational axioms: So #do@, s). do(ul, sl) = do(a2, ~2) > (al = a2 A s1 = s2), WP)[P(So) A (Vu, s>(P(s> > f’(do(a, s))) 3 (Vs)~C~)l, 7s c so, s c do(a, s’) 3 s c s’, s c s’ = s #s’ A (3f){(Vq 1 SZ>(Sl E $2 3 f@l) c f(s2)) A (‘da, sl>kW, sI) E s 3 do(a, .f@l>> C .y’)l. (1) (2) (3) (4) (5) (6) It amounts from the initial one by repeatedly applying The first two axioms are unique names assumptions for situations. The third axiom is second order induction. to the domain closure axiom that every situation has to be obtained the function do. In other words, a it says that every situation sequence of actions in the initial situation, exactly the isomorphism between situations and sequences of actions that we mentioned earlier. As can be expected, induction will play an important Axioms is either the initial situation So or the result of performing (4) and (5) define C inductively. The partial order c role in this paper. the “prefix” , . . . , a,], SO), S’ & S iff there is a 0 < k < II such is really relation: 3 Given a situation S = do([al that 5” = do([al. . . . , ak], SO). In particular, we have (Vs)So E s. Axiom (6) defines C. Informally, s C s’ iff s can be obtained of its actions. More precisely, suppose S’ = do([al , . from s’ by deleting some . a,], So). Then S C S’ iff there 3 Given a sequence of actions [al,. , a,], we use &([a~, a,], S) to denote the resulting situation of performing the sequence of actions in S. Inductively, &I([]. .s) = s and do([aJL], S) = d&L, &(a, s)). 216 E Lin /Artificial Intelligence 10.3 (1998) 273-294 are integers 1 < il < illustrates a function . < ik < n, 0 6 k < n, such that 5’ = dO([oi, , . . . , ai,], SO). Fig. 1 f as required by axiom (6) for proving the following relation: Ma, cl, So) c doGa, 6, c. 4, So) Notice that c is a special case of C: if s c s’ then s c s’. As we shall see, the partial order c will play a crucial role in this paper. In the following, we shall denote by C the set of the above axioms (l)-(6). 2.2. Logic programs We consider definite logic programs with cut. An atom p is a fluent term F(tl , . , tn), where F is a fluent of arity objectn, and tl , . . , t, are terms of sort object. A goal G is an expression of the form 11 & ... & I, where n 3 0, and for each 1 < i < n, li is either an atom, an equality atom of the form t=t’,or !. Without loss of generality, we assume that a clause (rule) is an expression of the form F(xl,...,x,) :- G where F is a fluent of the arity objecf , x1 , . , x, are distinct variables of sort object, and G is a goal. Notice that the more common form of a clause F(tl,...,t,,) :- G. can be taken to be a shorthand for the following clause: F(xl,....x,) : - xl =tl & ... & xn =tn & G. wherext,..., xn are fresh variables not in G and tl . . , t, Finally, a (definite) program is a finite set of clauses. The dejinition of a fluent symbol F in a program P is the set of clauses in P that have F in their heads. Since a goal is not a situation calculus values. Given a goal G = 11 & . . . & In, and a situation truth value of G in the situation S, to be the situation calculus formula formulas, we need a way to refer to its truth term S, we define H(G, S), the H(ll,S)r\...r\ H(l,,S), where for each 1 < i 6 n: (1) If li is t = t’, then H (li , S) is li (2) If li is ! , then H (1,. S) is the tautology For example, H (x = a & parent(x, y) & ! , SO) is true. x = a A H @arent(x, y), SO) A true. 3. A logical semantics The cut operator in Prolog plays a search control operator, it prevents a Prolog two roles. As a goal, it succeeds interpreter from backtracking immediately. As past it. F: Lin /Arr$cial Intelligence 103 (1998) 273-294 211 to the program. The rest of this section our semantics for programs with cut will come in two stages. First, we Consequently, the “pure logical” semantics of the programs when cut is taken to be a goal that consider for immediately. For this purpose, we shall use the situation calculus semantics succeeds [7]. For our purpose here, the logic programs without cut proposed by Lin and Reiter in key of this semantics thus the situation calculus, the effect of a cut on the search tree isomorphically, can then be modeled by restrictions on situations. So our second step in formalizing the cut operator is to define a relation call Act on situations so that Act(s) holds with respect to a logic program to a successful derivation according is that program clauses are identified with the effects of actions so a branch in a search tree becomes a sequence of actions, a situation. This is important because if the sequence of actions in s corresponds is basically a review of [7] with a minor notational difference: while we reify fluents and use the special predicate H, Lin and Reiter [7] treat fluents as predicate symbols. For example, H(broken, s) would be written as broken(s) in [7]. According to [7], clauses are treated as rules, so that the application of such a rule in the process of answering a query is like performing an action. Formally, given a clause of the form F(xl,...,x,) :- G. Lin and Reiter [7] introduce a unique action A of the arity &jecP + action clause. The only effect of this action is the following: to name this ($)H(G, s) 3 H(F(x’), MA(i), s)), where x’ is (xl, . . . , x,), and < is the tuple of variables example, suppose gp(x. y) is the action that names the following clause: that are in G but not in 2. For gparent(x,y) :- parent(x,z) & parent(z,y) then we have the following effect axiom: (%)]H@arerzt(x, z), s) A H@arent(z, y), s)l > H(gparent(n, y), do(gp(x, y), s)). Now suppose that P is a program and F a fluent. Suppose the definition of F in P is A,(;): F(x) :- Cl Ak(x) : F(x) : - Gk where A 1, . . , Ak are the action names for the corresponding following corresponding effect axioms for the fluent F: clauses. Then we have the (YflV;)ff(G~> $1 1 H(FGh do(A~(;), s)), @$)H(Gk. s> 3 H(F(i), do(Ak(i), s)), where yi, 1 < i < k, is the tuple of variables the following successor state axiom (Reiter [IO]) for F: in Gi which are not in x’. We then generate 278 E Lin / ArtiJiciul Intelligmc~ 10.1 (1998) 27.j-294 H(F(;),do(a,s))= (a=Al(~)~(3y;)H(G,,s) v...v (a = Ak(i) A @.Y;oH(Gk, s)) v H(F(i), s)l. (7) this axiom says that F is true in a successor situation Intuitively, or the action is one that corresponds clause is satisfied initially. then (7) becomes H(F(Z), do(a, s)) = H(F(x), In particular, s). iff either it is true initially to a clause in the definition of F and the body of the if the definition of F in the program P is empty, In the following, we call (7) the successor state axiom for F with respect to to P. Given a logic program P, the set of successor state axioms with respect to P, together with some domain independent axioms, is then the “pure logical meaning” of P: Definition 1. The basic action theory V for P is 2) = c u Dss u 2),,, u 2)s0 where l C is the set of foundational l DD,, is the set of successor state axioms for the fluents according l Vu*, is the following set of unique names axioms: axioms given in Section 2.1. to P. f(2) # g(3 for every pair f, g of distinct function symbols, and ,f(x) = f(_?, 3 x = _; (8) (9) for every function actions. 0 Vs,, is: symbol ,f. Notice that D,,, includes unique names axioms for (H(F(.?), So) -false 1 F is a fluent]. Definition 2. Let P be a program, and ‘D its corresponding basic action theory. A situation term S is called a plan for a goal G iff V /= (V,?)H(G, S), where x’ are the variables in G and S. Given a query G, we then look for a tuple of terms z and a plan S for G (ii. Deductively, s), where to find a constructive proof of the entailment: V + (%, s)H(G, literally becomes in the style of (Green [4]) in the situation calculus. This semantics has some nice the Clark completion this amounts x’ are the variables planning properties. For example, in G. Therefore query answering in logic programs it generalizes semantics: Theorem 1 (Lin and Reiter [7]). Let P be a program, V its action theory, and F afluent. Suppose the successor state axiom for F in 2) is (7), and Gi is li 1 & . . & liki for 1 < i < n. Then V entails the Clark completion for F: E Lin /Art@ial Intelligencr 103 (1998) 273-294 27’) This semantics is also closely related to a recent proposal by Wallace to Gelfond and Lifschitz’s stable model semantics [ 121, and in the [3]. For propositional details, see (Lin and Reiter [7]). case, equivalent Example 1. Consider {X. y]: 4 the following program for max(x. y. z), ; is the maximum of A~(x,y.z): max(x,y,z) :- leq(x,y) & ! SC z=y A2(x, y. z) : max(x,y,z) :- 2=x RI 6, J) : leq(x,y) :- x=1 & y=2 B2(X, y): leq(x,y) :- x=1 & y=l &(x, .Y): leq(x,y) :- x=2 & y=2. Here leq(x, y) means that x is less than or equal to y, and 1 and 2 are constants. We have the following successor state axioms for max and leq: H(mux(x, y, z), d&z, s)) = u = Al(x, y, z) A H(leq(x, y), s) A z = y v (u = A2(x, y. z) A z =x> v H(mux(x, J, z), s), H(leq(x, y), &(a, s)) E {u=Bl(x,y)Ax=lAy=2v u=B~(x,y)Ax=lny=lv (u = B3(X, y) AX = 2 A y = 2) v H(/eq(x. y), s)]. From these successor state axioms, A1 (I, 2,2) in SO will result following desirable conclusion: it is easy to see that performing satisfying m&l, first Bt (1,2), then 2,2). Thus we have the in a situation D + (3s)H(mux( 1,2,2). s). On the other hand, it is also clear that the action Az(x, y, X) will make mux(x, y, X) true, so we also have: 2) I= (Vx, y)(3s)ff(ma-4x, .Y, xl. s), the reason the effects of ! on the search space. According theory D does which is not so desirable. Of course, not take into account to Prolog’s search strategy, which attempts rules in the order as they are given, the second rule (AZ) for mux ! in the first rule for max succeeds. will not be attempted leq(x, y) before if Therefore there is a derivation for leq(x, y), which is the case here if x = 1 and y = 2. to &~(Az(x, y, x), So) will not be considered is that the basic action if the subgoal the derivation corresponding 4 Thk is a typical example of improper uses of cut. We’ll return to this point later 280 E Lin /Art$cial Intelligence 103 (1998) 273-294 Let us call a situation accessible if the derivation corresponding legal, i.e., not ruled out by the cut. Our goal in defining a semantics then to characterize next section. is for the cut operator is the set of accessible situations. This is what we are going to do in the to this situation5 4. A semantics for cut A clause containing cut: cut(x’) : F(2) : - Gt & ! & G2 means that if G 1 succeeds, then any derivation of F(.?) must use either (1) a rule before this one; or (2) this rule with the first derivation of G 1. We now proceed to formalize this informal reading. First, notice that we need precedence of rules, and the other on situations two ordering relations: one on rules for defining “the first derivation”. for deciding the In the following, we shall assume that we are given an ordering x on actions (rules), and if o < #3, then during the process to j3. For instance, according will define an ordering on situations using <. Intuitively, of search, the action a will be considered before the action Prolog’s ordering rule, for our max example, (2) -x AZ(;). (Vi!, ;)A, Given a partial order on actions, there are many ways situations, actions, can be ordered, depending on particular problem a query is answered using a goal-directed is returned, If we read s 4 s’ as that the sequence of actions we have the following definition: then it must be the case that a,, is first decided, search strategy, so if a plan do([ot solving strategies. i.e., sequences of In Prolog, , . . , a,], So) then on_ 1, . , and finally a! 1. in s is considered before that in s’, then Definition 3. Given a partial order < on actions, name < on situations is defined by the following axiom: the derived partial order with the same s < s’ E @a, 6, SI, s2)(s = do@, SI) A s’ = do(b, ~2) A [a 4 b v (a = b A sl < s2)]). (10) With this partial order on situations, we can then say, roughly, that a situation derivation” of a goal G if it is a derivation of G that is minimal according to make this precise we first need a space of derivations We do not want it to be the set of all plans for G because according 2) is a basic action theory for a logic program, then is a “first to +. However, to define the notion of minimality. to our definition, if D /= (Vu, s).H(G, S) > H(G, do@, s)). So if s is a plan for G, then for any action a, &(a, S) is also a plan for G. This means to it some that a plan for G can always be made “smaller” according irrelevant actions. To avoid this problem, we define the notion of minimal plans: to + by appending ’ In the following, the terms situations and derivations will be used interchangeably. E Lin /Artijcial Intelligence 103 (1998) 273-294 281 Definition 4. For any situation following formula: term S, any goal G, we denote by minimal(G, S) the H(G, S) A -(E!s)[s c S A H(G, s)]. Intuitively, minimal(G, S) holds if no actions in it can be deleted for it continue to be a plan of G. For our mux program in Section 3. it is easy to see that D~minimal(leq(l,2),do(Br(1,2),Su)). But 2) ~minimal(leq(l,2),do([B1(1,2), A1(1,2,2)1,So)). because &I( Bt ( 1,2), So) c do( [ B1 (1,2), A I ( 1,2,2)], So). It can be seen that for any goal G, if there is a plan for it, then there is a minimal plan for it: C + (Vs).H(G, s) > (3s’)(s’ C s r\minimal(G, s’)). We are now ready to formalize ! at the beginning of this section. For this purpose, we introduce a new predicate Act(s), meaning that s is not “cut off” by cut. reading of a clause containing the informal If a program contains to hold, it must be the case that for every minimal plan st of F in s, either it uses a rule before this cut rule or it uses this cut rule with the first derivation of G 1: the cut rule cut ($, and the goal G 1 succeeds, then for Act(s) Act(s) > (V~){(3s')[Acc(s') A ($)H(G,, s’)] > (Vsl)[sl csr\minimal(F(_?),sl)> (3a,s2)(q =do(a,s2)Aa -c cut(.?))v (II) (3s2. SS)(Sl = do(cut(xt), s2) A sj C s2 A first-der(Gl,ss))]], where < is the tupleofthe stands for the following freevariables that are in Gt but not in.?, and f irst-der(Gt , sg) formula: @$)minimal(Gt, ~3) A -($)[s; < sg r\Acc(s$) A @)minimal(Gl, si)], where < is the tuple of variables (11): l The formula that are in Gr but not in x’. We remark that in the axiom @s’)(Acc(s’) A (%)H(Gt, s’)) corresponds l The disjunct to “G 1 succeeds” @a, s2)(st = &?(a, $2) A a < cut(x’)) corresponds to “the derivation st of F(2) uses a rule before the cut rule”. 282 F: Lin /Art$ciul Intelligence 103 (1998) 273-294 l The disjunct (3.~2, .Q)(s~ = do(cut(i). $2) A ~3 C sz A f irst-der(GI, ~3)) corresponds replace the above formula by the following more straightforward one: to “uses this rule with the first derivation of G I”. Notice that we cannot (3s2)(sl = do(cut(z), ~2) A f irst-der(GI, ~2)) because $2 may not be a minimal plan for G 1. In the following, we call sentence occurrence of ! in clause cut(i) than one occurrences of ! , thus generate more than one accessibility to the after the subgoal G 1. Notice that a clause may have more constraint corresponding (11) the uccessibility constraints. Now given a program P, suppose Act(s) > ‘&(s). are all the accessibility of P: constraints. We call the following sentence the accessibility axiom Act(s) = ‘& (s) A . . A ‘&k(s). (12) Notice that this axiom attempts since the predicate also occurs to define Act recursively in the right hand side of the equivalence. This should not be surprising. For example, the logical fixed-point constructions, in logic programs normally of negation is usually implemented by cut. and negation formalization requires Definition 5 (Extended Action Theory). Let P be a program, and A a given set of axioms about < on actions. The extended action theory I of P is the the following set: E=DUAU(Acc,(lO)}. where D is the basic action theory for P, and Act form (12). is the accessibility axiom of P of the Definition 6. Let P be a program, E its extended action theory, and G a goal. A situation term S is an uccessible plan for G iff I + (V,?). Act(S) A H (G, S), where ,? are the variables in G and S. Now given a query G, we answer it by looking for a constructive proof of the following entailment: E + (3i. s).Acc(.s) A H(G, s), this method of where x’ are the variables It is well known that in the answering presence of cut, according a program may answer a query like F(u) positively but fail to return x = u as a possible answer when presented with queries does not exactly agree with Prolog’s that when G contains variables, to most Prolog implementations, in G. Notice F: Lin /ArtiJcial Intelligence 103 (1998) 273-294 283 the query F(x). However, returned as an answer according a constructive proof of (3x, s) Act(s) A H(F(.u), this oddity of Prolog does not show up here: x = a will be is to our construction because an accessible plan for F(a) s). We illustrate the definitions with our max example. Suppose we use Prolog’s search strategy, and order the actions as: A = (a < b = @)a = A1 (2) A (3j)b = AZ(~)}. that we do not care about how the rules about Notice occurrence of ! is in A 1, the accessibility axiom is leq are ordered. Since the only Act(s) = (Vx, y, z)((3s’)(Acc(s’) A H(leq(x, y), s’)) > (Vsl)[sl 2 s Aminimal(mux(x, y. z), sj) 3 (3a, sz)(sl = &(a, s?) A a -C Al@, y, z)) v (13 (32, S~)(SI = do(A~(x, y. z), 32) A sg C: s2 A f irst-der(kq(x, y), Q))]}. Now let E be the extended action theory of the program. First of all, we can show that E t== (Vx, y. z, s).minimal(leq(x, y), s) > [AC(S) A --H(max(x, y, z), s)], thus & I= (Vx, y)[(3.y)H(leq(x, Y), 8) = (3s)(Acc(s) A H(leq(x, y), s)>l. This is intuitively presence of ! has no effect on leq. right since the only appearance of ! is in the definition of mux, and the Now let SI =do(Bl(l, 2), SO), and S2 = do(A1(1,2,2), SI). Clearly E + H(leq(l,2), Sl) Aminimal(mux(l,2,2). &). We claim that E + Acc(S2) that so that S2 is an accessible plan for mux( I, 2,2). Notice first E k @s).Acc(s) A H(leq(l,2),s), I t= (Vx, y, z). H(mux(x, y, z), S2) 3 (x = 1 A y = 2 A z = 2), ~~~(~~,s).~~=do(U,s)Aa~A~(1,2.2). Therefore by ( 13) E +Acc(&) = (3s3)(s3 C St A first-der(leq(l,2), ~3)). Let ,s3 be SI , then & b Acc(S2) if I I= first_der(leq(l,2), Sl), that is E kminimal(leq(l, 2). sl) A -(3s).Acc(s) Am in imal(leq(l,2),s)As<S]. This follows from & + (Vs).minimal(leq(l, 2), s) ES = SI. 284 F: Lin /Artificial Intelligence 103 (1998) 273-294 So we have proved that & ‘F Acc(S2). On the other hand, there are no accessible plans for max ( 1,2, 1). The proof is as follows. it must be the case that term S, I + max(l,2, for some situation 1, S). Then Suppose do(A2(1,2, l), So) 5 S. Since E + (!ls).Acc(s) A H(leq(l,2), s), I + (Vs).minimal(max(l, 2, l), s) 3 s = do(Az(1.2, l), SO), it follows from (13) that for Act(S) to hold, it must be the case that (3a,s)[do(A2(1, 2, l), So) =do(a,s) AU x Al(1.2, l)] v (3s,s’)[do(A2(1,2, l), So) =do(Al(l,2, l),s) AS’ cs A first_der(leq(l,2), s’)], which is obviously Generalizing impossible. the above reasoning, we have: I I= (Vx, Y){ (~~)~(k(~, Y), s) AX # Y 3 [(3s)(Acc(s) A ff(max(x, Y, Y), s)) A -(3s)(Acc(s) A H(max(x, y, x), s))]}. So the max program indeed defines max correctly. However since E F (Vx, y, z)[(3s)N(max(x, y, z), s) = (3s)(A&) A H(max(x, Y, z), s))l, this use of cut is not ideal in the sense that it does more than search control, “red” cut. i.e., it is a 5. Stratified programs As we have noticed, the accessibility axiom attempts to define Act recursively. A natural question then is if the recursion will yield a unique solution for the predicate. In general, the answer is negative. However, if a program is properly stratified, then the axiom will yield a unique solution. To show this, we first present two simple lemmas about our axiomatization of cut. The following lemma says that ifs to do with rules about F: has nothing is not a derivation of F, then whether s is accessible Lemma 1. Let P be a program, and & its extended action theory. Suppose the accessibility axiom for P is as (12): Act(s) = @, (s) A . . . A ‘@j,(s). Let F be a fluent. Without loss generality, let (Vs)Acc(s) > *I, . . . , (Vs)Acc(s) > ‘J’k I;: Lin /Arrijicial Intelligence 103 (1998) 273-294 285 be the accessibility constraints of the form (11) f or all the occurrences of ! in the dejinition sf F. Under E, we have: -@x^)H(F($, s) > [Act(s) = pk+l A ... A ‘&I. (14) Proof. Under E, if a situation derivation: is not a derivation for an atom, then no part of it can be a -H(F(,?), s) AS’ s s 3 -H(F($, s’). Therefore if ly (s) is the right hand side of (1 l), then -(X)H(F(,?), s) 3 P(s). From this, (14) follows. q The following lemma says that if there is an accessible plan for G, then there is a accessible minimal plan for G. Lemma 2. Let P be a program and E its extended action theory. For any goal G, we have: (3s)(Acc(s) A H(G, s)) E @s)(Acc(s) A minimal(G, s)). Proof. By induction on situations, it: if there is a plan for G, then there is a minimal plan for C /= (Vs).H(G,s) > @s’)(s’Cs r\minimal(G.s’)). From this and the fact that (Vs, s’)(Acc(s) A s’ E s > Acc(s’)), the lemma follows. o Let P be a program, and F a fluent. We say that the definition of F in P is cut-free to F if, if none of the clauses inductively, either it’s in the definition of F or it’s relevant to another fluent that appears in the definition of F. For example, is cut-free. For cut-free fluents, Act does not play a role: the definition of leq in the max example that are relevant to F contains ! . Here a clause is relevant Proposition 1. Let P be a program, and & its extended action theory. For any goal G, if the definition of each fluent F mentioned in G is cut-free, then under & we have: minimal(G, s) > Act(s), (3s)H(G, s) = (3s)(Acc(s) A H(G, s)). If minimal(G, s), then s cannot be a derivation for any fluent that is not relevant Proof. this means that s cannot be a derivation to a fluent in G. Since every fluent in G is cut-free, for any fluent whose definition contains a rule that mentions cut. From this, the desired result follows directly from Lemma 1. III Cut-free fluents are the ground case of stratified programs: Definition 7. A program P is strati$ed if there is a function numbers such that (1) If F is cut-free in P, then f(F) = 0. f from fluents in P to natural 286 El Lin /Artificial Intellipxce 103 (1998) 273-294 (2) If F is not cut-free, then f(F) is 1 + max( f( F’) ( F’ appears in the definition of F}. It is clear that if P is stratified, then for any fluent F in P, f(F) is uniquely determined by the above two rules. In such case, we shall call the uniquely determined number the rank of F in P, and the maximum of the ranks of all the fluents in P the rank of the program the rank of leq is 0, and the rank of mux is 1. So the P. For instance, rank of the program in our max example, is 1, in a recursion-free We now show that if P is stratified, alently Acco, Acct , . . . , Accn , . . . . Intuitively, Accn (s) holds if s is accessible rules that mention a fluent of rank > n are deleted from P. Formally, follows: axiom can be written equiv- form. To that end, we introduce a new set of unary predicates (reachable) when all they are defined as then its accessibility Acco(s) z frue. For 12 > 0, suppose CUtl(x; ) : Fl(x;) :- Gl&!&G;. (15) a& (A$) : Fk(x;) : - Gk&! &G;,. are all of the occurrences of ! in the definitions of the fluents of rank rz. Then Accn is defined by the following axiom: Act,(s) rAcc,_l(s) A @l(s) A ... A @k(s), (16) where for any 1 < i < k, @i(s) is obtained as follows: suppose (Vs).Acc(s) > pi(s) is the accessibility then @i(s) is the result of replacing every occurrence of Act in pi(s) by Accn_l . constraint of the form (11) for the occurrence of ! in the rule CUQ (X;.), Now the axiom (16) defines Accn inductively since its right hand mentions only Act+ 1. We have: Theorem 2. Let P be a strutijed program, M its rank, and E its corresponding extended action theory. We have E b Act(s) = AccM (s) Proof. We prove by induction we have that for any goal G that mentions only fluents of rank < i, (3s)[Acc(s) A H(G, s)] = @s)[Acci(s) A H(G, s)]. (17) For i = 0, this follows from Proposition show that it holds for i + 1 as well. 1. Inductively, suppose that this holds for i We E Lin /Art$cial Intelligence 103 (1998) 273-294 287 By Lemma 2, (3s)[Acc(s) A H(G, s)] = (3s)[Acc(s) r\minimal(G, s)]. Let (Vs)(Acc(s) > ‘PI(S)), . ., (Vs)(Acc(s) > ‘P,~(s)) be all of the accessibility constraints of rank < IZ + 1. By Lemma 1 and the fact that if minimal(G, for any fluents of rank > n + 1, we have derivation for the occurrences of ! in the definitions of fluents s), then s cannot be a (3s)[Acc(s) r\minimal(G, s)] z (L)[@l(,l(s) A ... A qm(s) r\minimal(G,s)]. According tively, by inductive assumption, we have to the way that @I(S). . . . @,n (s) are obtained from P/(s), . . . , W/y,(s), respec- @s)[P~(.s) A ... A Pm(s) r\minimal(G,s)] (%)[@/(.F) A ..’ A QrTl (s) A minimal(G, = s)]. But by the definition of Acc,+l (s), Acc,+~ (s) = @l(s) A . . A &, (s). Therefore proof that (17) holds for all i. From (17) the theorem follows immediately. (17) holds for i + 1 as well. This completes our inductive proof, and thus the q 6. Negation-as-failure by cut In last section we showed that for stratified programs, our axiom for Act yields a unique solution. As can be expected, program: this does not hold in general. Consider the following t-1 : Y2 : 4 : rd : us : r6 : p :- q’. q :- P’. P’ :- p & ! & fail. P' . q’ :- q & ! & fail. CT’ . Notice that the definition off% stratified. Its accessibility axiom is: is empty, so (Vs)lH (fail, s). This program is clearly not 288 F: Lin /Arrijicial Intelligence 103 (1998) 273-294 Act(s) c (3s’>(Acc(s’) A H(p, s’)) > (Vsl)[sl Cs Aminimal(p',sl)> (3a,s2)(sl =do(a,s2) Aa -c ~3) V (3.~2, sg)(sl = do(r3, $2) As3 C s2 A f irst-der(p, sg))] A (b’)(Acc(s’) A H(q, s’)) > (Vsl)[sl C s Aminimal(q',sl)> (3a,s2)(sl = do(a,~2)Au -x rs) V (3~2, s3)(s1 = do(rs, ~2) A s3 C s2 A f irst-der(q, sg))]. Since r4 is the only rule by which p’ can be established, we have: minimal(p',s) 3 s = do(r4,So). Similarly, (Vs)[minimal(q',s) > s = dO(rg,$)]. Thus if we assume ordering on the rules: the following A = ((Va, b)[a -c b z (a = t-g A b = r4) v (a = rg A b = rg)]), then we have Act(s) = [H(p’, s) 3 -(3s’)(Acc(s’) A H(p, s’))] A [H(q’, s) > -(3s’)(Acc(s’) A H(q, s’))]. Let & be the extended action theory of this program, we then have E + (3s)(Acc(s) A ff(p, s)) A +s)(Acc(s) A ff(q, s)) V (3s)(Acc(s) A ff(q, ~1) A +s)@cc(s) A ff(p, s)), that is, there is an accessible plan for p iff there is not an accessible plan for q, and the other way around as well. Notice that the program is a rendition of the following logic program: p :- notq. :- notp. 9 withnegationimplementedby cut as: not F :- F & ! & fail. notF. If we identify an answer set (Gelfond and Lifschitz accessible derivations, following [3]) with a set of atoms that have then for this program, our semantics agrees with that of [3]. Our theorem shows that this equivalence holds for arbitrary normal programs as well. that for each fluent F in P, F’ is a new fluent of the same arity. Let P’ be the logic program obtained Let P be a logic program with negation (not) but without cut. Suppose F: Lin /Arti$cial Intelligence 103 (1998) 273-294 289 by replacing every literal of the form not F(z) in P by F’(f), and by adding, for each new fluent F’, the following two clauses: AF(;) A;(X) : : F’(2) : - F(i) & ! & fail. F’(g). Suppose that for each fluent F, the action AF is ordered before the action A>. Theorem 3. Let & be the extended action theory of PI, and V the action theory for P as defined in (Lin and Reiter [7]). For any$uent F in P, and any tuple i of terms, we have: (1) If M is a model of D, then there is a model M’ of & such that M /= (3s) H (F(y), s) ifsM’ b (S).Acc(s) A H(F(i), s). (2) If M’ is a model of E, then there is a model M’ of 2) such that M + (3s) H(F(i), s) ifsM + (3s).Acc(s) A H(F(i), s). Proof. The proof of this theorem is given in Appendix A because it is relatively needs some results from [7]. q long, and that the usual implementation From this theorem, we conclude of negation using cut is correct with respect to the semantics given in (Lin and Reiter [7]). As noted in (Lin and the same Reiter [7]), the semantics given results as that given in (Wallace to [3]) when only Herbrand models are the stable model semantics of (Gelfond and Lifschitz considered. Therefore we can also conclude in for logic programs with terms of cut is correct with respect to the stable model semantics case: negation there for logic programs with negation yields [ 12]), and the latter has been shown to be equivalent that the usual implementation in the propositional of negation Corollary 4. Let P be a propositional logic program with negation but without cut. Let P’ be the logic program obtained from P as described above. For any set W of atoms, W is an answer set of P according ifs there is a model M of the extended action theory of P' such to Gelfond and Lifschitz that W = (p / M + (b).Acc(s) A H(p, s)). 7. Concluding remarks We have applied the situation calculus programs with cut. We have shown that this semantics has some desirable properties: well-behaved when the program is stratified, and that according implementation Gelfond and Lifschitz’s stable model semantics. to it is the usual operator by cut is provably correct with respect to by giving a semantics to logic programming of negation-as-failure to this semantics, There has been relatively few formal work on cut compared to that on negation Previous work on the semantics of cut includes an operational programming. by Podelski dynamic algebra semantics by Borger [2], a paralogical a simple completion-style semantics by Stroetmann [9], a denotational and Smolka semantics by Jones and Mycroft [5], a [l] and and Glal3 [ 111 for a very special class semantics by Andrews in logic semantics 290 E Lin /Artificial Intelligence 103 (1998) 273-294 to clarify is to use that they considered. for the special class of programs and to study the possibility of a better control mechanism the proper roles of cut in in logic these different semantics and between our semantics of programs. Comparisons among for two reasons: most of the semantics have been and the others have been difficult mathematically quite involved, and the formalisms used are very different. However, as part of our future work, we shall attempt to show that our semantics and the one given by Stroetmann and Glal3 are equivalent More importantly, we shall try to use this semantics logic programming, programming. term goal long Our representing and reasoning about control and strategic information this regard, we have made some preliminary progress in applying formalizing control knowledge a plan is a sequence of actions, planning, which often are constraints on desirable plans, becomes constraints on situations, Based on this idea, in (Lin [6]), we formulate precisely a subgoal ordering in planning in the situation calculus, and show how information about this subgoal ordering can be deduced from a background action theory, and, for both linear and nonlinear planners, how knowledge about this ordering can be used in a provably correct way to avoid unnecessary backtracking. We believe other control knowledge in planning can be similarly axiomatized and made into good use as well. in problem solving. the situation calculus to situations. So control knowledge in planning. As we mentioned in Section 1, in AI planning, thus isomorphic as a general the situation for In to framework calculus in Acknowledgement Much of this work was done while I was with the Cognitive Robotics Group in the Department of Computer Science at the University of Toronto, and I thank Ray Reiter and Hector Levesque for making this possible. This work was also supported Kong under Direct Allocation Grant DAG96/97.EG34 Research Grant HKUST6091/97E. in part by the Research Grants Council of Hong and under Competitive Earmarked I would like to thank Eyal Amir, Yves Lesperance, Hector Levesque, and especially Ray Reiter for helpful discussions earlier versions of this paper. relating to the subject of this paper and/or comments on Appendix A This appendix proves Theorem 3. Recall that in this theorem, P is a logic program with negation but without cut, and P’ is the logic program obtained by replacing every literal of the form not F(f) in P by F’(T), and by adding, for each new fluent F’, the following two clauses: A&) A’&) : : F’(i) : - F(i) & ! SC fail. F’(i) . We also assume that for each fluent F, the action A ,G is ordered before the action A>. F: Lin /Art$cial Intelligencr 103 (1998) 273-294 291 In Section 3, we review the action theory semantics of [7] for logic programs without for programs with negation have the same form but with the s). Notice that H(not p, s) negation. Action following semantics is in fact independent of the situation argument. For example, given the following clauses: for negation: H(not p, s) is -(3s’)H(p, theories rt(x): p(x) :- notq(x) r2(x): p(x) :- x=u the successor state axiom for F is: H@(x), do(u, s)) = a = r)(x) A H(not q(x), s) V (a = q(x) Ax = u) v H(p(x), s). Theorem 3. Let E be the extended action theory of P’, and 2) the action theoryfor P as defined in (Lin and Reiter [7]). For any fluent F in P, and any tuple i of terms of sort object, we have: (1) IfMisamodelofD, ifsM’ + (S).Acc(s) thenthereisamodelM’of&suchthatM~((3s)H(F(i),s) A H(F(?), s). (2) If M’ is a model of I, then there is a model M’ of V such that M b (3s) H (F (ii, s) ifsM’ /= @s).Acc(s) A H(F(i), s). Proof. Suppose example in Section 6, we can show that that F;, . . . , FL are the new fluents in P’. Observe first that, as for the I k Act(s) = (A.]) (Vx;)(H(F;(x;,s) >-(%‘)[Acc(s’)A H(F,(x;),s’)]}r\...r\ (V.a${H(F;(.$), s) > -(L’)[Acc(s’) A H(Fk(x$. s’)]). Suppose now that M is a model of V. Construct an interpretation M’ as follows: (1) (2) The domain of M’ for sort object is the same as that in M. The domain of M’ for sort action is the union of the action domain of M and the following set: (A r, (d), A>[ (2) 1 1 < i < k, d’ is a tuple of elements in the object domain). (3) (4) The truth values of fluents are always false in SO, and computed according successor state axioms of E in successor situations. The interpretation for Act is defined as follows: For any s^ in the situation domain of to the I 6 M, iff for any I < i < k and any tuple ii of elements in the object domain, whenever M’ + H(F:(tTi). s^) 6 To simplify our presentation, if u is an element in the domain of a model M and q(x) is a formula, then we’ll use M + q(u) to stand for M, o + q(n), where o is a variable assignment such that (T(X) = u. 292 E Lin /Artificial Intelligence 103 (IWK) 273-294 then M + 1(3S’)fi(LZi, S’). We need to show that M’ is a model of E, and that for any fluent F and any tuple ii of objects, M I= &)H(F($, s) * M’ /= (3s)Acc(s) A H(F($, s) (A.2) By the construction of M’, the fact that M’ is a model of & follows directly from (A. 1) and the equivalence (A.2). We now prove the equivalence. Suppose M I= (b)H(F($, s). for some actions at, Then for some s^ in the situation domain of M, M k minimal( on situations, . . , a,], SO). Because none of the . . , a,, s^ = &([a], fluents are true in the initial situation SO, by the form of the successor state axioms in 27, ai must be the action name for some of the rules in P, for each 1 < i < II. Furthermore, since Jn is a minimal plan for F(i), for each i, the body of ai must be satisfied in the situation do([al, . .ai_t]. So). Now suppose F(G), .F). By induction not 4, (~7,)~. . . , not fi,(6,,,) are the negative the situation literals, then the rules in s: literals appearing in the rules corresponding that uses first the rules A> for the new fluents corresponding to a I, . . . , a,. Then let s^’ be to the above s^’ = do(]Ak,, (~7, ), . . , A>,,n (~7~1, al, . , anl, So). (A.3) By the construction of M’, it can be verified that s^’ is in the situation domain of M’, and M’ +Acc(i’) i’). A H(F(;), Conversely, suppose M’ + (b)Acc(s) A H(F(Li), s). Then there are al, . . , a, in the action domain of M’ such that M’ bAcc(do([aI, . , a,], So)) A minimal(F(G), &([a],. . . , a,], So)). Because we don’t have any rules about fail, this means any 1 < 1 <k. If ai is A>,(;), then F,‘(G) must be true in do([al,...,a,l,So). that ai’s cannot be Aq(U) for Since is accessible this situation This means the form A;,(d) that if c = in [at,. in M’, by the construction [al,, . . , al,,,] is the list resulted . , a,], then do(<, SO) is a situation of M’, M + -(b)H(F($, from deleting s). the actions of in the domain of M, and M + H(F($, theorem. do(c, SO)). This proves the equivalence (A.2) and the first half of the To prove the second half of the theorem, suppose now that M’ is a model of E. Construct an interpretation M as follows: (1) M and M’ share the domains for all sorts. F: Lin /Artificial Intelligence 103 (1998) 273-294 293 (2) The truth values of fluents are defined as follows: Initially, all fluents are false: M b (V,+F(2, So) for every fluent F. Inductively, the action domain, and any tuple ii of objects, the truth value of F(a) in do(i. defined by the following for any s^ in the situation domain, any action ri in .?) is two cases: Case 1. 6 is not an action that corresponds in P. In this case, to one of clauses in the definition of F M + H(F(ii), du(ii, i)) iff M + H(F(i), ;). Case 2. 6 is an action that corresponds in P. To simplify our presentation, to one of the clauses suppose the instantiation in the definition of F of this clause is F(.ii) : - G & not Fi(f). where G does not contain not . Then M b H(F(ii), &I(& i)) iff and M b H(G, St), M’ I= -(3s’).Acc(s’) A H(Fi(;). s’). Again, we need to show that the equivalence satisfies the successor state axioms in V. (A.2) holds, and that M is a model of D. i.e., The proof of the equivalence (1) if M b (3s)H(F($, (A.2) is similar to the one given above: s), then there is a situation s^ such that M + minimal(F($,ct). Let i’ be the situation obtained from s^ in the way described by (A.3). Then from the construction of M and (A.l), it can be verified that M’ bAcc(?) A H(F(ii), i’). (2) if M’ + (3s)Acc(s) A H(F(ii), s), then there is a s^ in the situation domain such from s^ by to actions in P. Then M ‘F H (F (ii). .?I). that M’ + Acc(s”) A minimal(F($, i). Let s^' be the situation obtained eliminating actions that do not correspond From the equivalence (A.2), we have that for any fluent F, M’ + (b).Acc(s) A H(F’(i), s) iff A4 b -@s)H(F(ii), s). From this, it is easy to show that M satisfies the successor state axioms in 2). q 294 15: Lin /Artificial Intelligence 103 (1998) 273-294 References [ I1 J. Andrews, A paralogical semantics for the prolog cut. in: Proc. Internat. Logic Programming Symposium, 199.5, pp. 591-605. 121 E. Borger, A logical operational semantics of full Prolog, in: Cotnputer Science Logic, CSL-89, Lecture Notes in Computer Science, Vol. 440, Springer, Berlin, 1989, pp. 36-64. 131 M. Gelfond, V. Lifschitz, The stable model semantics Conference and Symposium on Logic Programming, for logic programming, in: Proc. Fifth International 1988, pp. 1070-1080. 141 CC. Green, Application of theorem proving to problem solving, in: Proc. International Joint Conference on Artificial Intelligence (IJCAI-69) Washington, DC, 1969, pp. 219-239. [51 N.D. Jones, A. Mycroft. Stepwise development of operational Proc. 1984 International Symposium on Logic Programming, and denotational 1984, pp. 28 I-288. semantics for Prolog, in: 161 F. Lin, An ordering on subgoals for planning, Annals of Mathematics and Artificial Intelligence 2 1 ( 1997) 321-342. [7] E Lin, R. Reiter, Rules as actions: A situation calculus 3 1 (1-3) (I 997) 2999330. Programming semantics for logic programs, Journal of Logic 181 J. McCarthy, P. Hayes, Some philosophical B. Meltzer, D. Michie (Eds.). Machine 4633.502. problems from the standpoint of artificial intelligence, Intelligence 4, Edinburgh University Press, Edinburgh, in: 1969, pp. [9] A. Podelski, G. Smolka, Operational semantics of constraint 1995 International Conference on Logic Programming, Kanagawa. Cambridge, MA, 1995, pp. 449463. logic programs with cocoutining, in: Proc. Japan. 13-18 June 199.5, MIT Press, [IO] R. Reiter, The frame problem result Computation: Papers in Honor OF John McCarthy, Academic Press, San Diego, CA, 199 1, pp. 4 18420. in the situation calculus: a simple solution (sometimes) and a completeness Intelligence and Mathematical in: V. Lifschitz (Ed.), Artificial regression, for goal Theory of [Ill K. Stroetmann, T. GlaR, A declarative semantics for the Prolog cut operator, in: Proc. 5th Internat. Workshop on Extensions of Logic Programming. 1996, pp. 255-27 1. [ 121 M.G. Wallace, Tight, consistent, and computable completions for unrestricted logic programs, Journal of Logic Programming 15 (1993) 243-273. 