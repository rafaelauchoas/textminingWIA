Artificial Intelligence 321 (2023) 103936Contents lists available at ScienceDirectArtificial Intelligencejournal homepage: www.elsevier.com/locate/artintPolynomial combined first-order rewritings for linear and guarded existential rules ✩Georg Gottlob a, Marco Manna b, Andreas Pieris c,d,∗a Department of Computer Science, University of Oxford, UKb Department of Mathematics and Computer Science, University of Calabria, Italyc School of Informatics, University of Edinburgh, UKd Department of Computer Science, University of Cyprus, Cyprusa r t i c l e i n f oa b s t r a c tArticle history:Received 4 May 2021Received in revised form 19 April 2023Accepted 25 April 2023Available online 2 May 2023Keywords:OntologiesExistential rulesTuple-generating dependenciesGuardednessConjunctive queriesQuery answeringQuery rewritingCombined approachWe consider the problem of ontological query answering, that is, the problem of answering a database query (typically a conjunctive query) in the presence of an ontology. This means that during the query answering process we also need to take into account the knowledge that can be inferred from the given database and ontology. Building, however, ontology-aware database systems from scratch, with sophisticated optimization techniques, is a highly non-trivial task that requires a great engineering effort. Therefore, exploiting conventional database systems is an important route towards efficient ontological query answering. Nevertheless, standard database systems are unaware of ontologies. An approach to ontological query answering that enables the use of standard database systems is the so-called polynomial combined query rewriting, originally introduced in the context of description logics: the conjunctive query q and the ontology (cid:2) are rewritten in polynomial time into a first-order query q(cid:2) (in a database-independent way), while the database D and the ontology (cid:2) are rewritten in polynomial time into a new database D(cid:2) (in a query-independent way), such that the answer to q in the presence of (cid:2) over D coincides with the answer to q(cid:2) over D(cid:2). The latter can then be computed by exploiting a conventional database system.In this work, we focus on linear and guarded existential rules, which form robust rule-based languages for modeling ontologies, and investigate the limits of polynomial combined query rewriting. In particular, we show that this type of rewriting can be successfully applied to (i) linear existential rules when the rewritten query can use the full power of first-order queries, (ii) linear existential rules when the arity of the underlying schema is fixed and the rewritten query is positive existential, namely it uses only existential quantification, conjunction, and disjunction, and (iii) guarded existential rules when the underlying schema is fixed and the rewritten query is positive existential. We can show that the above results reach the limits (under standard complexity-theoretic assumptions such as PSpace (cid:3)= ExpTime) of polynomial combined query rewriting in the case of linear and guarded existential rules.© 2023 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons .org /licenses /by /4 .0/).✩This paper is an extended and revised version of the papers [1], [2] and [3].* Corresponding author.E-mail addresses: georg.gottlob@cs.ox.ac.uk (G. Gottlob), manna@mat.unical.it (M. Manna), apieris@inf.ed.ac.uk (A. Pieris).https://doi.org/10.1016/j.artint.2023.1039360004-3702/© 2023 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons .org /licenses /by /4 .0/).G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 1039361. IntroductionOver the past two decades we have seen a shift from a world where most data used by public and private organizations was stored in well-structured relational databases of modest size and treated as complete to a world where data is very large, heterogeneous, distributed in different sources, and incomplete. This makes the task of extracting useful information from such data by means of queries extremely tedious and complex. At the same time, not only do we have massive amounts of data, but we also have very large amounts of knowledge about the application domain of the data in the form of taxonomies, or even full-fledged ontologies. This gave rise to a new research field, recently dubbed knowledge-enriched data management [4], that lies at the intersection of data management and knowledge representation and reasoning. A major challenge for knowledge-enriched data management is to provide end users with flexible and integrated access to data by exploiting the available knowledge about the underlying application domain. This builds on the hypothesis that end users may have a deep understanding of a specific domain of interest, but are not able to formulate complex queries and understand performance implications.Ontology-based data access (OBDA) [5], also known as ontology-based data integration, has been proposed as a general paradigm for addressing the above central challenge. It facilitates access to data by separating the end user from the raw data sources. This is done by using an ontology, which models the underlying application domain and is semantically linked with the data via declarative mappings, as a mediator between the data sources and the end user. The purpose of the ontology is two-fold:1. It provides an integrated global view of the data that is very close to the conceptual model of the underlying application domain of which the end user has a good understanding. This makes the raw data accessible via database queries formulated solely in the vocabulary of the ontology, without requiring any knowledge of the actual structure of the data sources.2. It enriches the possibly incomplete data sources with domain knowledge. This allows us to infer new knowledge, not explicit in the data, enabling more complete answers to queries.The main algorithmic task underlying the OBDA paradigm is querying knowledge-enriched data, or, in other words, querying data in the presence of an ontology. This means that during the query answering process we also need to take into account the inferred knowledge. This problem is known as ontological query answering.1.1. Query rewritingBuilding ontology-aware database systems from scratch, with sophisticated optimization techniques, is a highly non-trivial task that requires a great engineering effort. An alternative route towards efficient ontological query answering is to use conventional database management systems (DBMSs). The fact that DBMSs are unaware of ontologies can be addressed by query rewriting: the database query q (typically a conjunctive query) and the ontology (cid:2) are rewritten into a new query q(cid:2), the so-called rewriting, which computes the answer to q in the presence of (cid:2) over all input databases. It is, of course, essential that q(cid:2) is expressed in a language that can be handled by standard DBMSs. The typical language is that of first-order (FO) queries.The Pure Approach. What has been described above is the so-called pure approach to FO rewritability in the sense that the FO rewriting q(cid:2) should be powerful enough to compute the correct answer to the given query q under the given ontology (cid:2) over all input databases. This essentially means that the construction of q(cid:2) should be independent of any database. The advantage of such a pure approach to FO rewritability should be clear: we can pre-compute q(cid:2) offline, and whenever the database D changes, we simply need to re-evaluate q(cid:2) over D, without having to re-compute it. This approach has been successfully applied to a range of lightweight description logics, mainly the members of the DL-Lite family [6], as well as classes of existential rules such as linear existential rules [7,8]; details on existential rules are given below. On the other hand, such a pure approach to FO rewritability comes with two inevitable shortcomings:1. Query rewriting algorithms generate from a reasonably sized conjunctive query a very large FO query, which can be prohibitive for efficient execution by a standard database system. We actually know that even for lightweight ontology languages such as DL-LiteR [6], the logical underpinning of the OWL 2 QL profile of OWL 2,1 there is no FO rewriting of polynomial size, unless the polynomial hierarchy collapses [9]. Further strong evidence for the non-existence of an FO rewriting of polynomial size in the case of DL-LiteR was given in [10]. In particular, it was shown that the existence of such an FO rewriting is equivalent to a major open problem in computational complexity such as NC1 = NP/poly.2 We also know that an exponential blow-up is provably unavoidable when the rewriting should be an existential positive FO query (i.e., an FO query that uses only existential quantification, conjunction, and disjunction) [9].1 https://www.w3 .org /TR /owl2 -profiles /#OWL _2 _QL.2 NC1 is the class of decision problems decidable by uniform Boolean circuits with a polynomial number of gates of at most two inputs and depth O (log n), whereas NP/poly is the non-uniform analogue of NP.2G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 1039362. FO rewritability applies only to lightweight ontology languages for which the data complexity of ontological query answering (i.e., when the query and the ontology are considered fixed) is very low. More precisely, the problem of eval-uating a fixed FO query over an input database is known to be in AC0,3 a class that is properly contained in DLogSPace. Therefore, useful formalisms with PTime-hard (or even DLogSpace-hard) data complexity, such as the description logic EL [11], are immediately excluded.The Combined Approach. To overcome the above shortcomings, a finer approach to FO rewritability has been proposed in the context of description logics, known as the combined approach [12]. The crucial difference compared to the pure approach is that rewriting the database in a query-independent way is also possible. More precisely, the conjunctive query q and the ontology (cid:2) are rewritten into a new query q(cid:2) (in a database-independent way), while the database D and the ontology (cid:2) are rewritten into a new database D(cid:2) (in a query-independent way), such that the answer to q in the presence of (cid:2) over D coincides with the answer to q(cid:2) over D(cid:2).It has been shown that, indeed, the two shortcomings of the pure approach to FO rewritability discussed above can be overcome by adopting the combined approach. It has been successfully applied to a range of lightweight description logics, mainly members of the DL-Lite and EL families, with the guarantee that both the database and the query rewriting are feasible in polynomial time [12–14]. It has been also applied to description logics that go beyond the members of the DL-Lite and EL families [15].1.2. Research challengesAll the results discussed above concerning the combined approach to FO rewritability are about description logics. But what about rule-based ontology languages? It is generally agreed that rule-based ontologies are well-suited for data-intensive applications such as OBDA, since they allow us to conveniently deal with higher-arity relations, which naturally appear in standard relational databases. Therefore, studying whether the combined approach to FO rewritability can be applied to rule-based ontology languages is a highly relevant task that deserves our attention.Towards this direction, we focus on ontologies modeled using existential rules, also called tuple-generating dependencies, i.e., first-order sentences of the form∀¯x∀ ¯y (φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z))with φ and ψ being conjunctions of atoms. Sentences of the above form are also known in the literature as Datalogrules [16]. However, ontological query answering under arbitrary existential rules is undecidable (see, e.g., [17]). This has led to an intensive research activity during the last decade for identifying restrictions on existential rules that lead to decidability. The basic decidable paradigms that emerged from this effort are guardedness [17,18], (weak-)acyclicity [19,20], stickiness [21], and shyness [22].±In this work, we concentrate on guardedness and investigate the limits of the polynomial combined approach to FO rewritability – the term polynomial refers to the fact that both the database and the query rewriting should be feasible in polynomial time. An existential rule as the one above is guarded if φ has an atom that contains (or guards) all the universally quantified variables [17]. A central subclass of guarded existential rules is that of linear existential rules, i.e., existential rules where φ consists of a single atom [7]. Interestingly, the main members of the EL family of description logics are (up to a certain normal form) special cases of guarded existential rules, while the main members of the DL-Lite family (modulo some easily handled features) are special cases of linear existential rules. By employing simple complexity-theoretic arguments, we can delineate the limits of the polynomial combined approach to FO rewritability in the case of guarded and linear existential rules:Targeting Arbitrary FO Queries. Evaluation of FO queries is known to be PSpace-complete. Thus, when the rewritten query has the freedom to use the full power of FO queries, it is unlikely that the polynomial combined approach can be applied to ontology languages for which the complexity of ontological query answering is beyond PSpace. This immediately excludes guarded existential rules, for which ontological query answering is 2Exptime-complete [17]. It actually excludes the class of guarded existential rules even when the arity of underlying schema is fixed (unless PSpace = ExpTime) as in this case ontological query answering is known to be ExpTime-complete [17].On the other hand, ontological query answering for linear existential rules is PSpace-complete. Therefore, there is no complexity-theoretic argument against the polynomial combined approach being applied to linear existential rules.Targeting Existential Positive FO Queries. The problem of evaluating positive existential FO queries is known to be NP-complete. Hence, when the rewritten query should be a positive existential FO query, it is unlikely that the polynomial combined approach can be applied to linear existential rules (unless NP = PSpace).On the other hand, ontological query answering for guarded existential rules when the underlying schema is fixed, as well as for linear existential rules when the arity of the underlying schema is fixed, is NP-complete (this is actually 3 The class AC0 consists of those languages that are accepted by polynomial-size circuits of constant depth and unbounded fan-in (the number of inputs to their gates).3G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936a result of the present work – further details are given below). Hence, there is no complexity-theoretic argument against the polynomial combined approach being applied to those cases when the rewritten FO query should be positive existential.The above discussion leads to the following fundamental research questions concerning the limits of the polynomial combined approach to FO rewritability:1. Is it applicable to linear existential rules when the rewritten query can use the full power of FO queries?2. Is it applicable to linear existential rules when the arity of the underlying schema is fixed, and the rewritten FO query should be positive existential?3. Is it applicable to guarded existential rules when the underlying schema is fixed, and the rewritten FO query should be positive existential?1.3. Summary of contributionsThe goal of the present work is to provide answers to the above challenging questions. Our main results can be summa-rized as follows:• In Section 3, we show that linear existential rules enjoy the so-called bounded witness property (Theorem 3.1). This re-sult essentially tells us that for ontological query answering under linear existential rules it suffices to apply a bounded number of inference steps, while the bound depends only on the set of rules and the CQ, but not on the input database. This is a result of independent interest and it allows us to provide answers to our main research questions. Note that such a result can be obtained from [23] for single-head linear existential rules, that is, linear existential rules with only one atom in the right-hand side of the implication. However, this result cannot be straightforwardly transferred from single-head to multi-head linear existential rules. We now provide a proof that deals with linear existential rules in their full generality.• In Section 4, we show that (i) the polynomial combined approach is applicable to linear existential rules, and (ii) it is also applicable when the rewriting should be a positive existential FO query providing that the arity of the underlying schema is fixed (Theorem 4.1). This result heavily relies on the fact that linear existential rules enjoy the bounded witness property. As a corollary, ontological query answering in the case of linear existential rules over schemas of fixed arity is in NP since evaluating positive existential FO queries is in NP.Note that the results for linear existential rules over schemas of fixed arity, i.e., item (ii) of Theorem 4.1, as well as the NP upper bound for ontological query answering, were known only for single-head linear existential rules [9,23]. We now provide proofs that deal with linear existential rules in their full generality.• Finally, in Section 5, we show that the polynomial combined approach is applicable to guarded existential rules when the rewriting should be a positive existential FO query providing that the underlying schema is fixed (Theorem 5.1). This result exploits item (ii) of Theorem 4.1, i.e., the fact that the polynomial combined approach is applicable to linear existential rules when the rewriting should be a positive existential FO query providing that the arity of the underlying schema is fixed. In fact, we provide a polynomial-time combined reduction from ontological query answering under guarded existential rules over fixed schemas, to ontological query answering under linear existential rules over schemas of fixed arity, and then apply item (ii) of Theorem 4.1. As a corollary, ontological query answering in the case of guarded existential rules over fixed schemas is in NP.The latter complexity result was only known for single-head guarded existential rules [17]. This was recently brought to our attention by a colleague of ours [24], and it is also explicitly discussed in [25]. We now have a proof that deals with guarded existential rules in their full generality.Single-head vs. Multi-head Existential Rules. We conclude this introductory section by discussing further the subtle issue regarding single-head and multi-head existential rules. As mentioned above, some of our results were only known for single-head existential rules. This, however, may sound contradictory to the general assumption that, for ontological query answering purposes, allowing for a conjunction of atoms in the right-hand side of an existential rule is actually syntactic sugar. This is because we can always convert a set (cid:2) of existential rules into a set (cid:2)1 of existential rules with only one atom in the right-hand side such that (cid:2) and (cid:2)1, although not logically equivalent, are equivalent for ontological query answering. This, in fact, relies on a very simple transformation that replaces each existential rule σ ∈ (cid:2) of the form(cid:2)∀¯x∀ ¯yφ(¯x, ¯y) → ∃¯z R1(¯x1, ¯z1) ∧ · · · ∧ Rn(¯xn, ¯zn)),where ¯xi ⊆ ¯x and ¯zi ⊆ ¯z, with the set of existential rules(cid:2)∀¯x∀ ¯yφ(¯x, ¯y) → ∃¯z Auxσ (¯x, ¯z))∀¯x∀¯z(Auxσ (¯x, ¯z) → R i(¯xi, ¯zi)), for i ∈ {1, . . . , n},4G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936with Auxσ being a fresh predicate not occurring in (cid:2). Notice further that if (cid:2) is linear (resp., guarded), then also (cid:2)1 is linear (resp., guarded).Due to the above transformation, it is usually the case that ontological query answering for linear and guarded existential rules is studied under the assumption that in the right-hand side of an existential rule we have only one atom. The reason is purely technical, i.e., to simplify the technical definitions and proofs. Although this simplifying assumption can be made, in general, without affecting the generality of the results, this is not true for schemas of fixed arity, as well as for fixed schemas. This is because, even if we start from a set of existential rules over a fixed schema, the obtained set of single-head existential rules after the transformation mentions an unbounded number of new predicates each of unbounded arity (see the auxiliary predicates).2. PreliminariesWe consider the disjoint countably infinite sets C, N and V of constants, nulls and variables, respectively. We refer to constants, nulls and variables as terms. For an integer n ≥ 1, we may write [n] for the set {1, . . . , n}.Relational Instances. Consider a countably infinite set Rel of relation symbols (also called predicates) with associated arity. We write ar(R) for the arity of a predicate R. A (relational) schema S is a finite subset of Rel. We write ar(S) for the arity of S, i.e., the number maxR∈S{ar(R)}. An atom over S is an expression of the form R(¯t), where R ∈ S and ¯t is a tuple of terms. For an atom α, dom(α), null(α) and var(α) is the set of its terms, nulls, and variables, respectively; these notations naturally extend to sets of atoms. Given a set of terms T , we define B(T , S) = {R(¯t) | R ∈ S and ¯t ∈ T ar(R)}, that is, the set of atoms that can be formed using terms of T and predicates of S. An instance over S is a (possibly infinite) set of atoms over S with constants and nulls, while a database over S is a finite instance over S with only constants. We write D for the family of all databases. We also write D[S], where S is a (finite or infinite) family of schemas, for the family of all databases over a schema S ∈ S.Homomorphisms. A homomorphism from a set of atoms A to a set of atoms B is a function h : dom( A) → dom(B) that is the identity on C with R(h(¯t)) ∈ B for every R(¯t) ∈ A. We write A → B for the fact that there is a homomorphism from Ato B. For a set of terms S, we say that A and B are S-isomorphic, denoted A (cid:11)S B, if there is a 1-1 homomorphism h from A to B that is the identity on S and h−1 maps B to A.Queries. A first-order query (FO) over a schema S is an expression of the fromq(¯x) := {¯x | φ},+where φ is a first-order formula that uses predicates from S and mentions only constants and variables, ¯x is a tuple (possibly with repetitions) over the free variables of φ, and each free variable of φ occurs at least once in ¯x. We say that q is existential positive (∃FO) if φ uses only existential quantification, conjunction, and disjunction. For a database D over S, the evaluation of q(¯x) over D, denoted q(D), is the set of tuples(cid:4)|¯x| | ¯c ∼ ¯x and D |=FO φ(¯c)(cid:3)¯c ∈ dom(D),where ¯c ∼ ¯x denotes the fact that ¯c = (c1, . . . , cn) is compatible with ¯x = (x1, . . . , xn), i.e., xi = x j implies ci = c j , φ(¯c) is the sentence obtained after instantiating each free variable of φ with the corresponding constant in ¯c, and |=FO denotes the standard active domain semantics of first-order logic. Recall that by active domain semantics we essentially mean that the quantified variables range over the terms occurring in the underlying database, i.e., its active domain; hence the name “active domain semantics”. Let FO and ∃FObe the family of all FO and ∃FOA subclass of first-order queries that is central for the present work is that of conjunctive queries, which actually corre-sponds to first-order queries that use only existential quantification and conjunction. In particular, a conjunctive query (CQ) over a schema S is a formula of the formqueries.++q(¯x) := ∃ ¯y(cid:6)(cid:2)(cid:5)R1( ¯v 1) ∧ · · · ∧ Rm( ¯vm),(cid:9)(cid:7)(cid:8)φwhere each R i( ¯v i) is an atom without nulls, each variable mentioned in the ¯v i ’s appears either in ¯x or ¯y, ¯x is tuple (possibly with repetitions) over the free variables of φ, and each free variable of φ occurs at least once in ¯x. If ¯x is empty, then q is a Boolean CQ. For an instance I over S, the evaluation of q(¯x) over I , denoted q(I), is the set(cid:3)¯c ∈ (dom(I) ∩ C)|¯x| | ¯c ∼ ¯x and q(¯c) → I,(cid:4)i.e., are the tuples of constants ¯c such that q(¯c) can be mapped via a homomorphism to I ; notice that, by abuse of termi-nology, we may treat a conjunction of atoms as a set of atoms. Let CQ be the family of all CQs. For a family of schemas S, let CQ[S] be the family of all CQs over a schema of S. Note that the evaluation of CQs is defined not only for databases but also for instances. This is not needed for arbitrary FO (or even ∃FO) queries since in the rest of the paper will always be evaluated over databases.+5G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936Tuple-generating Dependencies. A tuple-generating dependency (TGD) σ over a schema S is a first-order sentence of the form(cid:2)(cid:5)φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z),∀¯x∀ ¯ywhere φ and ψ are (non-empty) conjunctions of atoms over S that mention only variables. For brevity, we write σ as φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z) and use comma instead of ∧ for joining atoms. We call φ and ψ the body and head of σ , denoted body(σ ) and head(σ ), respectively. An instance I over S satisfies σ , written I |= σ , if, whenever φ(¯x, ¯y) → I via a homo-morphism h, then ψ(¯x, ¯z) → I via a homomorphism hthat agrees with h on ¯x. The instance I satisfies a set (cid:2) of TGDs, written I |= (cid:2), if I |= σ for each σ ∈ (cid:2). Let T GD be the family of all finite sets of TGDs.4 A class C of TGDs is a subset of T GD. We also write C[S], where S is a family of schemas, for the class of TGDs {(cid:2) ∈ C | (cid:2) is over a schema of S}.(cid:14)Guardedness and Linearity. A TGD σ is guarded if there exists an atom in body(σ ), called guard, that contains all the body variables. By convention, the leftmost body atom of a guarded TGD σ is the guard, denoted guard(σ ), and all the other atoms are the side atoms of σ . We write G for the class of sets of guarded TGDs. A subclass of G, which is crucial for our work, is the class of linear TGDs, denoted L, which collects all the sets of TGDs with only one body-atom.Ontological Query Answering. Given a database D and a set (cid:2) of TGDs, both over a schema S, a model of D and (cid:2) is a (possibly infinite) instance I ⊇ D such that I |= (cid:2). We write mods(D, (cid:2)) for the set of models of D and (cid:2). The certain answers to a CQ q over S w.r.t. D and (cid:2) is defined as the set of tuplescert(q, D, (cid:2)) =(cid:10)q(I).I∈mods(D,(cid:2))Ontological query answering is the problem of computing the set cert(q, D, (cid:2)). The associated decision problem is defined as follows. Let C be a class of TGDs:PROBLEM :INPUT :QUESTION :OQA(C)A database D, a set (cid:2) ∈ C of TGDs, a CQ q(¯x),and a tuple ¯c ∈ dom(D)|¯x|Does ¯c ∈ cert(q, D, (cid:2))?.Polynomial Combined Rewritability. We now introduce the central notion of polynomial combined first-order rewritabil-ity. As discussed in the Introduction, this has been proposed as an alternative to query rewriting with the aim of overcoming the limitations of the standard first-order rewritability approach for ontological query answering.A database rewriter is a function that takes as input a database and a set of TGDs, and outputs a database, while a query rewriter is a function that takes as input a CQ and a set of TGDs, and outputs an FO query. We will always make clear what is the domain and codomain of database and query rewriters.+A class C ⊆ T GD of TGDs is polynomially combined FO-rewritable (resp., ∃FO-rewritable) if there are polynomial-time computable database and query rewritersf DB : D × C → D andf Q : CQ × C → FO (resp., f Q : CQ × C → ∃FOrespectively, such that, for every database D, set (cid:2) ∈ C, and CQ q, cert(q, D, (cid:2)) = q(cid:2)(D(cid:2)) with D(cid:2) = f DB(D, (cid:2)) and q(cid:2) =f Q(q, (cid:2)).),The above are defined analogously in case we focus on a family of schemas S. More precisely, C[S] is polynomially +combined FO-rewritable (resp., ∃FO-rewritable) if there are polynomial-time computable database and query rewriters+f SDB: D[S] × C[S] → D andf SQ: CQ[S] × C[S] → FO (resp., f SQ: CQ[S] × C[S] → ∃FO+),Q (q, (cid:2)).respectively, such that, for every database D ∈ D[S], set (cid:2) ∈ C[S], and CQ q ∈ CQ[S], cert(q, D, (cid:2)) = q(cid:2)(D(cid:2)) with D(cid:2) =DB(D, (cid:2)) and q(cid:2) = f Sf SThe Chase Procedure. The chase procedure is a useful algorithmic tool when reasoning with TGDs. Let us first define a single chase application. A trigger for a set (cid:2) of TGDs on an instance I is a pair (σ , h), where σ ∈ (cid:2) and h is a homomor-(cid:14)(head(σ )), where hphism from body(σ ) to I . An application of (σ , h) to I returns an instance J = I ∪ hextends h in such (cid:14)(z) ∈ N \ dom(I), and (ii) for distinct existentially quantified a way that (i) for each existentially quantified variable z of σ , hvariables z and w of σ , h(cid:14)(w). Such a trigger application is denoted by I(cid:17)σ , h(cid:18) J .(cid:14)(z) (cid:3)= h(cid:14)The main idea of the chase is, starting from a database D, to exhaustively apply distinct triggers for the given set (cid:2) of TGDs on the instance constructed so far, and keep doing this until a fixpoint is reached. This is formalized as follows:4 We work with finite sets of TGDs. Thus, in the rest of the paper, a set of TGDs is always finite.6G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936• A finite sequence of instances (Ii)0≤i≤n, with D = I0 and n ≥ 0, is a chase derivation of D w.r.t. (cid:2) if: (i) for each 0 ≤ i < n, there is a trigger (σ , h) for (cid:2) on Ii such that Ii(cid:17)σ , h(cid:18)Ii+1, (ii) for each 0 ≤ i < j < n, assuming that Ii(cid:17)σi, hi(cid:18)Ii+1 and I j(cid:17)σ j, h j(cid:18)I j+1, σi = σ j implies hi (cid:3)= h j , and (iii) there is no trigger (σ , h) for (cid:2) on In such that (σ , h) /∈ {(σi, hi)}0≤i<n. In this case, the result of the chase is the (finite) instance In .• An infinite sequence of instances (Ii)i≥0 is a chase derivation of D w.r.t. (cid:2) if: (i) for each i ≥ 0, there exists a trig-ger (σ , h) for (cid:2) on Ii such that Ii(cid:17)σ , h(cid:18)Ii+1, (ii) for each i, j > 0 such that i (cid:3)= j, assuming that Ii(cid:17)σi, hi(cid:18)Ii+1 and I j(cid:17)σ j, h j(cid:18)I j+1, σi = σ j implies hi (cid:3)= h j , and (iii) for each i ≥ 0 and for every trigger (σ , h) for (cid:2) on Ii , there exists j ≥ isuch that I j(cid:17)σ , h(cid:18)I j+1. The latter is called the fairness condition, and it ensures that all the triggers will be applied. The result of the chase is the infinite instance is (cid:11)i≥0 Ii .We write chaseδ(D, (cid:2)) for the result of a (finite or infinite) chase derivation δ of D w.r.t. (cid:2). The key property of the chase follows:Proposition 2.1. Consider a database D, a set (cid:2) of TGDs, and a chase derivation δ of D w.r.t. (cid:2). For every instance I ∈ mods(D, (cid:2)), it holds that chaseδ(D, (cid:2)) → I .In our later technical proofs, we will silently use a crucial consequence of the above result, namely a tuple ¯c belongs to cert(q, D, (cid:2)) iff there exists a prefix (Ii)0≤i≤n, for n ≥ 0, of a chase derivation of D w.r.t. (cid:2) such that ¯c ∈ q(In).We conclude our discussion on the chase procedure by defining a useful relation on the result of chase derivations. Consider a chase derivation δ = (Ii)i≥0 of a database D w.r.t. a set (cid:2) of TGDs, and assume that for each i ≥ 0, Ii(cid:17)σi, hi(cid:18)Ii+1. The parent relation of δ, denoted ≺pδ β iff there is i ≥ 0 such that α ∈ hi(body(σi)) and β ∈ Ii+1 \ Ii . Let ≺p,+δ forms a (possibly infinite) directed acyclic graph.δ , is a binary relation over chaseδ(D, (cid:2)) such that α ≺pbe the transitive closure of ≺pδ . Note that ≺pδ3. Bounded witness property and linearityWe start our analysis by introducing the so-called bounded witness property for a class of TGDs and then show that the class of linear TGDs enjoys this property. This essentially tells us that for ontological query answering purposes it suffices to apply a bounded number of chase steps, while the bound depends only on the set of TGDs and the CQ, but not on the input database. As we shall see, the fact that linear TGDs enjoy the bounded witness property is crucial for obtaining the desired polynomial combined first-order rewritings, which is the subject of Sections 4 and 5.Definition 3.1 (Bounded Witness Property). A class C of TGDs enjoys the bounded witness property due to f , where fis a computable function from C × CQ to the natural numbers, if, for every database D, set (cid:2) ∈ C of TGDs, CQ q(¯x), and , ¯c ∈ cert(q, D, (cid:2)) implies the existence of a sequence (Ii)0≤i≤n, with n ≤ f ((cid:2), q), that is a prefix of a chase tuple ¯c ∈ Cderivation of D w.r.t. (cid:2), and ¯c ∈ q(In). We simply say that C enjoys the bounded witness property if it enjoys the bounded witness property due to some computable function f from C × CQ to the natural numbers.5 (cid:2)|¯x|We now proceed with main result of this section, that is, the class of linear TGDs enjoys the bounded witness property. We first define the function fL that maps L × CQ to the natural numbers. Given a set (cid:2) of TGDs and a CQ q, both over a schema S:fL((cid:2), q) = |(cid:2)| · |S| · (2 · |q| · ar(S) + ar(S))ar(S).It is clear that fL is a computable function. We proceed to show that:Theorem 3.1. L enjoys the bounded witness property due to fL.The proof of Theorem 3.1 proceeds in two main steps:1. We characterize when L enjoys the bounded witness property due to fL via parsimonious quasi chase derivations, i.e., sequences that are “almost” a prefix of a chase derivation, and the number of distinct triggers involved is bounded by fL.2. We then show that, when we focus on L, the fact that a tuple is a certain answer can be witnessed via a parsimonious quasi chase derivation.5 When fis a polynomial function, this is known in the literature as the polynomial witness property [9].7G. Gottlob, M. Manna and A. Pieris3.1. Some auxiliary notionsArtificial Intelligence 321 (2023) 103936Before we give the technical details for the above two steps, we first need to introduce some auxiliary technical notions that are needed for the proof.(cid:14)(head(σ )), while h(cid:14)(cid:14)(z) ∈ N \ dom(I), and for distinct existentially quantified variables z and w of σ , hQuasi Chase Derivations. Let (σ , h) be a trigger for a set (cid:2) of TGDs on an instance I . A partial application of (σ , h)to I returns an instance J = I ∪ K , where K ⊆ hextends h in such a way that for each existentially (cid:14)(w). quantified variable z of σ , hSuch a partial application is denoted I(cid:17)σ , h(cid:18)p J . A sequence of instances (Ii)0≤i≤n, for n ≥ 0, is a quasi chase derivation (resp., quasi chase derivation with total applications) of D w.r.t. (cid:2) if, for each 0 ≤ i < n, there exists a trigger (σ , h) for (cid:2) on I isuch that Ii(cid:17)σ , h(cid:18)p Ii+1 (resp., Ii(cid:17)σ , h(cid:18)Ii+1). Observe that a quasi chase derivation with total applications is trivially a quasi chase derivation, but the opposite is not necessarily true. A quasi chase derivation δ = (Ii)0≤i≤n, with Ii(cid:17)σi, hi(cid:18)p Ii+1, is k-parsimonious, for k ≥ 0, if | {(σi, hi)}| ≤ k, i.e., at most k distinct triggers are involved in δ. The parent relation of δ, denoted ≺pδ , and its transitive closure ≺p,+, are defined as usual.In a nutshell, a quasi chase derivation is “almost” a chase derivation, but it is not exactly a chase derivation for the (cid:14)(z) (cid:3)= h0≤i<n(cid:11)δfollowing three reasons:1. applications may be partial, i.e., during a trigger application some atoms are not generated,2. triggers may repeat, i.e., the same trigger is used in different applications, and3. some triggers have not been applied.Of course, in the case of quasi chase derivations with total applications only the last two reasons apply. Moreover, although triggers may repeat in a k-parsimonious quasi chase derivation, at most k distinct triggers are used for its generation.Contractions. Consider a database D, a set (cid:2) ∈ L of TGDs, and a quasi chase derivation δ = (Ii)0≤i≤n, for n ≥ 0, of D w.r.t. (cid:2). Let A ⊆ In and h a function from dom( A) to dom(In). The ( A, h)-contraction of δ is the sequence of instances δ(cid:14) = ( J i)0≤i≤n such that, for each 0 ≤ i ≤ n,6(cid:4)(cid:4)J i = Ii \(cid:3)α | α ∈ Ii and A ≺p,+δ α(cid:3)h(α) | α ∈ Ii and A ≺p,+∪δ α.For notational convenience, we write A ≺p,+δ α for some atom β ∈ A. To understand the essence of the notion of contraction, observe first that, since we consider linear TGDs, ≺pδ actually forms a forest with the atoms of D being the roots, and thus, we can talk about the subtree of an atom. Now, in simple words, the ( A, h)-contraction of δis essentially what we obtain after updating, according to the function h, the atoms in the subtrees of ≺pδ rooted at A. A simple example that illustrates the notion of contraction follows.δ α for the fact that β ≺p,+Example 3.1. Consider the database D = {R(a, b)} and the set (cid:2) ∈ L consisting ofσ1 = R(x, y) → ∃z∃w P (x, z), P ( y, w),σ2 = P (x, y) → S( y, x),σ3 = S(x, y) → ∃z T (x, z), T ( y, z).Let δ = I0, I1, . . . , I6 be the quasi chase derivation of D w.r.t. (cid:2) withI0 = DI1 = I0 ∪ {P (a, ⊥1), P (b, ⊥2)}I2 = I1 ∪ {S(⊥1, a)}I3 = I2 ∪ {P (a, ⊥3), P (b, ⊥4)}I4 = I3 ∪ {S(⊥3, a)}I5 = I4 ∪ {T (⊥3, ⊥5), T (a, ⊥6)}I6 = I5 ∪ {S(⊥4, b)}.It is easy to verify that δ is indeed a quasi chase derivation of D w.r.t. (cid:2). Let A = {P (a, ⊥3), P (b, ⊥4)} ⊆ I6, and h be the function from dom( A) to dom(I6) such that h(a) = a, h(b) = b, h(⊥3) = ⊥1 and h(⊥4) = ⊥2. The ( A, h)-contraction of δ is the sequence of instances δ(cid:14) = J 0, J 1, . . . , J 6 with6 Note that this notion is different than the well-known notion of homomorphism contraction.8G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936J 0 = DJ 1 = J 0 ∪ {P (a, ⊥1), P (b, ⊥2)}J 2 = J 1 ∪ {S(⊥1, a)}J 3 = J 2 ∪ {P (a, ⊥3), P (b, ⊥4)}J 4 = J 3J 5 = J 4 ∪ {T (⊥1, ⊥5), T (a, ⊥6)}J 6 = J 5 ∪ {S(⊥2, b)}.In other words, the sequence δ(cid:14)α ∈ Ii such that A ≺p,+δ α with h(α). (cid:2)is obtained from δ as follows: for each i ∈ {0, 1 . . . , 6}, J i is obtained by replacing each We can now discuss the details of the proof for Theorem 3.1.3.2. Bounded witness property and parsimonious quasi chase derivationsThe characterization of the bounded witness property due to fL via parsimonious quasi chase derivations (step 1 of the proof of Theorem 3.1) is as follows:Proposition 3.1. The following are equivalent:1. L enjoys the bounded witness property due to fL.2. For every database D, set (cid:2) ∈ L, CQ q(¯x), and tuple ¯c ∈ C|¯x|quasi chase derivation with total applications (Ii)0≤i≤n of D w.r.t. (cid:2) such that ¯c ∈ q(In)., ¯c ∈ cert(q, D, (cid:2)) implies there exists an fL((cid:2), q)-parsimonious Let k = fL((cid:2), q). It is clear that (1) implies (2) since a prefix of a chase derivation of length k of D w.r.t. (cid:2) is by definition a k-parsimonious quasi chase derivation of D w.r.t. (cid:2). The other direction, however, is not immediate since a k-parsimonious quasi chase derivation δ of D w.r.t. (cid:2) with total applications is not necessarily a prefix of length at most k of a chase derivation of D w.r.t. (cid:2) since triggers may repeat. Thus, if we could eliminate from δ the repeated triggers, without introducing more repetitions of triggers, then we will end up with a finite prefix of a chase derivation of D w.r.t. (cid:2)of length at most k, which in turn implies the bounded witness property due to fL. This can be achieved via iterative contractions as we explain next.Assume that a trigger (σ , h) has been applied at steps i, j, for i < j, with H i and H j being the set of atoms generated at the i-th and j-th step, respectively. The key observation is that H i (cid:11)S H j , where S = dom(H i) ∩ dom(H j). Due to linearity, we can safely move the subtrees rooted at H j under the corresponding atoms of H i , and consistently update the atoms without introducing more repetitions of triggers. This is essentially what the (H j, μ)-contraction of δ does with μ being the S-isomorphism from H j to H i . This can be seen in Example 3.1. Observe that the instances I1 and I3 of the quasi chase derivation δ are obtained by applying the same trigger (σ1, h) with h(x) = a and h( y) = b, and δ(cid:14)is obtained by moving the subtrees rooted at {P (a, ⊥3), P (b, ⊥4)} under the corresponding atoms of {P (a, ⊥1), P (b, ⊥2)} and consistently updating the atoms. The above discussion is formalized by the following technical lemma. For a quasi chase derivation δ = (I i)0≤i≤n with (cid:14)Ii(cid:17)σi, hi(cid:18)Ii+1, we write H ii is the δ for the set of atoms generated at the i-th step, i.e., the set of atoms hextension of hi employed during the trigger application Ii(cid:17)σi, hi(cid:18)Ii+1.(cid:14)i(head(σi)), where hLemma 3.1. Consider a database D, a set (cid:2) ∈ L, a CQ q(¯x), and a tuple ¯c ∈ C. Let δ = (Ii)0≤i≤n be a quasi chase derivation with total applications of D w.r.t. (cid:2) with Ii(cid:17)σi, hi(cid:18)Ii+1, and assume ¯c ∈ q(In). For a pair of indices 0 ≤ k < (cid:9) < n with (σk, hk) = (σ(cid:9), h(cid:9)), let δk,(cid:9) = ( J i)0≤i≤n be the (H (cid:9)δ . The following hold:δ, μ)-contraction of δ with μ being the (dom(H kδ ))-isomorphism from H (cid:9)δ) ∩ dom(H (cid:9)δ to Hk|¯x|1. δk,(cid:9) is a quasi chase derivation with total applications of D w.r.t. (cid:2) such that, for each i ∈ {0, 1, . . . , n − 1}, there is a homomor-phism μi from body(σi) to J i such that J i(cid:17)σi, μi(cid:18) J i+1.≺p,+2. There is no α ∈ J n such that H (cid:9)δδk,(cid:9)3. For each i, j ∈ {0, 1, . . . , n − 1}, (σi, hi) = (σ j, h j) iff (σi, μi) = (σ j, μ j).4. ¯c ∈ q( J n \ (H (cid:9)δ\ Hkδ)).α.Proof. For each i ∈ {0, 1, . . . , n}, we define the sets of atoms(cid:3)(cid:4)=I iniα ∈ Ii | H (cid:9)δ≺p,+δ αandI outi= Ii \ I ini .9G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936In simple words, I incontraction. By construction,i are the atoms of Ii reachable by an atom from H (cid:9)δ , and thus, those atoms are updated by μ during the ii ) ∪ I outi ) ∪ μ(I outJ i = μ(I in= μ(I in= μ(Ii) ∪ (H (cid:9)δi∩ I outi),) ∪ (H (cid:9)δ∩ I outi)which implies that μ(Ii) ⊆ J i , for each i ∈ {0, 1, . . . , n}. We also define, for each i ∈ {0, 1, . . . , n}, the functionμi = μ ◦ hi.We proceed to prove the four statements claimed in Lemma 3.1:1. We need to show that, for each i ∈ {0, . . . , n − 1}, J i(cid:17)σi, μi(cid:18) J i+1, i.e., J i+1 = J i ∪ μ(cid:14)⊇ μi . We first show that (σi, μi) is indeed a trigger for (cid:2) on J i . We know that hi(body(σi)) ∈ Ii . Since μ(Ii) ⊆ J i , we get that μ(hi(body(σi))) ∈ J i . Since, by definition, μi = μ ◦ hi , we get that (σi, μi) is a trigger for (cid:2) on J i . It remains to show that there exists μ(cid:14)⊇ hi such that i(cid:14)Ii+1 = Ii ∪ hi(head(σi))) ⊆ J i+1. Since μ is an isomorphism, it is clear that μ(cid:14)i(cid:14)i(head(σi)). Since μ(Ii+1) ⊆ J i+1, we conclude that μ(h(cid:14)i is an extension of μi , and the claim follows.i(head(σi)). By hypothesis, we know that there exists h⊇ μi such that J i+1 = J i ∪ μ(cid:14)i(head(σi)) for some μ(cid:14)2. This is a consequence of the contraction operator and the triggers defined above. In fact, via an easy induction, it is δ . (Note that δ )) since μ replaces those terms with terms of possible to show, by following the new triggers, that all the atoms in μ(I ineach atom in μ(I inδ) \ (dom(Hkdom(Hkn ) contains no term of dom(H (cid:9)δ) ∩ dom(H (cid:9)n ) are now descendants of Hk3. This statement is a direct consequence of the fact that μi = μ ◦ hi , μ j = μ ◦ h j , and that μ is an isomorphism.4. By hypothesis, q(¯c) → In due to a homomorphism h. This implies that μ ◦ h maps q(¯c) to J n. Observe that μ(In) ∩ (H (cid:9)δδ ) \ (dom(Hkδ) ∩ dom(H (cid:9)= μ ◦ hδ )).)\(cid:14)iiδ) = ∅, which immediately implies that μ ◦ h maps q(¯c) to J n \ (H (cid:9)Hkδ\ Hkδ), as needed.This completes the proof of Lemma 3.1. (cid:2)We can now explain how the direction (2) implies (1) of Proposition 3.1 is shown. Assume that ¯c ∈ cert(q, D, (cid:2)). By hypothesis, there exists an fL((cid:2), q)-parsimonious quasi chase derivation with total applications δ = (Ii)0≤i≤n of D w.r.t. (cid:2)such that ¯c ∈ q(In). By iteratively applying Lemma 3.1, we can eventually construct an fL((cid:2), q)-parsimonious quasi chase derivation with total applications δ(cid:14) = ( J i)0≤i≤n of D w.r.t. (cid:2) with J i(cid:17)σi, hi(cid:18) J i+1 such that, for each 0 < j < n for which there exists 0 ≤ i < j with (σi, hi) = (σ j, h j):• there is no α ∈ J n such that Hj• ¯c ∈ q( J n \ (Hδ\ H iδ)).jδ≺p,+δ(cid:14) α, andTherefore, we can drop the applications in δ(cid:14)(K i)0≤i≤m, where m ≤ fL((cid:2), q), that is a prefix of a chase derivation of D w.r.t. (cid:2) and ¯c ∈ q(Km), as needed.that use a trigger that has been applied before in order to obtain δ(cid:14)(cid:14) =3.3. Ontological query answering via parsimonious quasi chase derivationsWe now proceed with the second step of the proof of Theorem 3.1 and show that, for the class of linear TGDs, the fact that a tuple is a certain answer can be witnessed via a k-parsimonious quasi chase derivation, where k is given by the function fL.Proposition 3.2. Consider a database D, a set (cid:2) ∈ L, a CQ q(¯x), and a tuple ¯c ∈ Cparsimonious quasi chase derivation with total applications ( J i)0≤i≤n of D w.r.t. (cid:2) such that ¯c ∈ q( J n).|¯x|. If ¯c ∈ cert(q, D, (cid:2)), then there exists an fL((cid:2), q)-To establish the above result it suffices to show that the prefix (Ii )0≤i≤n of some chase derivation of D w.r.t. (cid:2) that wit-nesses the fact that ¯c ∈ cert(q, D, (cid:2)), i.e., ¯c ∈ q(In), can be converted into an fL((cid:2), q)-parsimonious quasi chase derivation with total applications ( J i)0≤i≤n of D w.r.t. (cid:2) such that ¯c ∈ q( J n). To this end, we can rely again on iterative contractions as we explain next.Consider two S-isomorphic atoms α and β of In, where α does not appear in the subtree rooted at β, and S is the set of terms occurring in h(q(¯c)) with h being a homomorphism that maps q(¯c) to In. Due to linearity, we can safely move the subtree rooted at β under α, and consistently update its atoms, without affecting the fact that ¯c is a certain answer. We can achieve this via the (β, μ)-contraction of (Ii)0≤i≤n with μ being the S-isomorphism from β to α.7 Notice, however, 7 For a singleton instance {γ } we simply write γ .10G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936that such a contraction may create partial applications and repeated triggers. Hence, the result is not necessarily a prefix of a chase derivation, but a quasi chase derivation. This is formalized by the following technical lemma.Lemma 3.2. Consider a database D, a set (cid:2) ∈ L, a CQ q(¯x), and a tuple ¯c ∈ Cw.r.t. (cid:2) such that q(¯c) → In via h. For atoms α, β ∈ In such that β ⊀p,+be the (β, μ)-contraction of δ with μ being the S-isomorphism from β to α. The following hold:. Let δ = (Ii)0≤i≤n be a quasi chase derivation of Dδ α and α (cid:11)S β, where S = dom(h(q(¯c))), let δα,β = ( J i)0≤i≤n|¯x|1. δα,β is a quasi chase derivation of D w.r.t. (cid:2).2. There is no γ ∈ J n such that β ≺p,+δα,β3. For each γ , γ (cid:14) ∈ J n, γ (cid:11)S γ (cid:14)4. q(¯c) → J n via h.γ .iff μ−1(γ ) (cid:11)S μ−1(γ (cid:14)).Proof. For each i ∈ {0, 1, . . . , n}, we define the sets of atoms(cid:3)(cid:4)=I iniγ ∈ Ii | β ≺p,+δγandI outi= Ii \ I ini .In simple words, I inMoreover, we define the set of integersi are the atoms of Ii reachable from β, and thus, those atoms are updated by μ during the contraction. X = {i | hi(body(σi)) = β} ∪ {i | β ≺p,+We finally define, for each i ∈ {0, 1, . . . , n}, the functionδhi(body(σi))}.μi =(cid:12)μ ◦ hiif i ∈ Xhiotherwise.We proceed to show the four statements of Lemma 3.2.1. We show that, for each i ∈ {0, 1, . . . , n}, J i(cid:17)σi, μi(cid:18)p J i+1. By hypothesis, there exists h(cid:14)i⊇ hi such that Ii+1 = Ii ∪(cid:14)i(head(σi)). We proceed by case analysis:hand hi(body(σi)) (cid:3)= β• hi(body(σi)) ∈ I outiSince i /∈ X , μi = hi . Since I outJ i+1 \ J i = Ii+1 \ Ii whenever i /∈ X , we conclude that J i(cid:17)σi, μi(cid:18)p J i+1 due to hi⊆ J i , we get that μi(body(σi)) ∈ J i , and thus, (σi, μi) is a trigger for (cid:2) on J i . Since (cid:14)i⊇ μi .• hi(body(σi)) ∈ I outand hi(body(σi)) = βiSince i ∈ X , μi = μ ◦ hi . Clearly, μ(β) = μ(hi(body(σi))) = α. Since α ∈ I out⊆ J i , we have that μi(body(σi)) ∈J i , and thus, (σi, μi) is a trigger for (cid:2) on J i . Since J i+1 \ J i = μ−1(Ii+1 \ Ii) whenever i ∈ X , we conclude that J i(cid:17)σi, μi(cid:18)p J i+1 due to μ ◦ hand I out⊇ μi .ii(cid:14)i• hi(body(σi)) ∈ I iniSince μ(I inμ(Ii+1 \ Ii) whenever i ∈ X , we get that J i(cid:17)σi, μi(cid:18)p J i+1 due to μ ◦ hi ) ⊆ J i , μ(hi(body(σi))) = μi(body(σi)) ⊆ J i , and thus, (σi, μi) is a trigger for (cid:2) on J i . Since J i+1 \ J i =⊇ μi .2. This is a consequence of the contraction operator and the triggers defined above. Actually, via an easy induction, it is n ) are now descendants of α. (Note that each possible to show, by following the new triggers, that all the atoms in μ(I inatom in μ(I inn ) contains no term of dom(β) \ S since μ replaces those terms with terms of dom(α) \ S.)(cid:14)i3. This statement follows from the fact that μ−1 is an S-isomorphism.4. This holds since {γ ∈ J n | dom(γ ) ⊆ S} = {γ ∈ In | dom(γ ) ⊆ S}.This completes the proof of Lemma 3.2. (cid:2)We are now ready to explain how Proposition 3.2 is shown. By hypothesis, there exists a prefix δ = (Ii)0≤i≤n, for n ≥ 0, of a chase derivation of D w.r.t. (cid:2) such that q(¯c) → In via a homomorphism h. By definition, δ is a quasi chase derivation of D w.r.t. (cid:2). The binary relation (cid:11)S over In, where S = dom(h(q(¯c))), is an equivalence relation. Let In/(cid:11)S be the set of all equivalence classes in In w.r.t. (cid:11)S . For each equivalence class C in In/(cid:11)S , its canonical atom is arbitrarily chosen from the set of atoms {α ∈ C | there is no β ∈ C such that β ≺p,+δ α}. For an atom α ∈ In, we write [α] for the canonical atom of its equivalence class, and ια for the S-isomorphism that maps α to [α]. We proceed to construct an fL((cid:2), q)-parsimonious quasi chase derivation with total applications δ(cid:14) = ( J i)0≤i≤n of D w.r.t. (cid:2) such that ¯c ∈ q( J n).Let α ∈ In with α (cid:3)= [α]. By Lemma 3.2, the (α, ια)-contraction δα = (Iαi )0≤i≤n of δ enjoys the following properties:• δα is a quasi chase derivation of D w.r.t. (cid:2),• there is no β ∈ J n such that α ≺p,+δαβ,11G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936• for each β, β(cid:14) ∈ J n, β (cid:11)S β(cid:14)• q(¯c) → J n via h.iff ι−1α (β) (cid:11)S ι−1α (β(cid:14)), andWe can therefore iteratively apply Lemma 3.2 as discussed above, until we get a quasi chase derivation δ(cid:23) = (Iw.r.t. (cid:2) such that the following hold:(cid:23)i )0≤i≤n of D1. For each α ∈ I2. q(¯c) → I(cid:23)n , α (cid:3)= [α] implies there is no β ∈ I(cid:23)n via h.(cid:23)n such that α ≺δ(cid:23) β.Note that δ(cid:23)is not necessarily with total applications. However, it can be converted into one with total applications by simply adding the atoms that are needed in order to ensure that every application in δ(cid:23)is total. Let δ(cid:14) = ( J i)0≤i≤n be the resulted quasi chase derivation with total applications of D w.r.t. (cid:2). It is clear that q(¯c) → J n via h, and thus ¯c ∈ q(In). It remains to show that δ(cid:14)is fL((cid:2), q)-parsimonious.Since in δ(cid:14)only canonical atoms trigger TGDs (the first property of δ(cid:23)stated above, which is inherited by δ(cid:14)), it suffices to count how many triggers for (cid:2) on the instanceK = {α | α is the canonical atom of a set C ∈ Jn/(cid:11)S }can be formed. Due to linearity, we can assume, without loss of generality, that in δ(cid:14)at most |q| atoms from D trigger a TGD of (cid:2), which implies that K contains at most |q| atoms of D. Therefore, assuming that (cid:2) and q are both over the schema S,|K | ≤ |S| ·(cid:2)(cid:5)2 · |q| · ar(S) + ar(S)ar(S),which is the number of non-Sconsists of the set S and the set of constants T occurring in the atoms of D that trigger a TGD. Actually, the above upper bound is a consequence of the fact that |S| ≤ |q| · ar(S) and |T | ≤ |q| · ar(S). Since each atom of K can trigger several TGDs of (cid:2), the total number of triggers for (cid:2) on K that can be formed is fL((cid:2), q), as needed.-isomorphic atoms over S that can be formed, where S++Theorem 3.1 follows from Propositions 3.1 and 3.2.3.4. Bounded witness property and linear TGDs in normal formIn the proofs of Section 4, where we show that the class of linear TGDs is polynomially combined first-order rewritable, it will be technically convenient to work with linear TGDs in normal form, i.e., TGDs with only one atom in the head that contains at most one occurrence of an existentially quantified variable that appears at the last position of the head-atoms. To this end, we establish a result similar to Theorem 3.1 for linear TGDs in normal form. Let us first recall the normalization procedure.Consider a linear TGD σ over a schema S of the formP (¯x, ¯y) → ∃z1 · · · ∃zm R1(¯x1, ¯z1), . . . , Rn(¯xn, ¯zn),where n, m ≥ 0, ¯xi ⊆ ¯x and ¯zi ⊆ {z1, . . . , zm} for each i ∈ [m], ¯x =the set of linear TGDs consisting of(cid:11)i∈[n] ¯xi , and {z1, . . . , zm} =(cid:11)i∈[n] ¯zi . We define N(σ ) as Aux1P (¯x, ¯y) → ∃z1 Aux1σ (¯x, z1) → ∃z2 Aux2...σ (¯x, z1)σ (¯x, z1, z2)Auxm−1σAuxm(¯x, z1, . . . , zm−1) → ∃zm Auxmσ (¯x, z1, . . . , zm) → R1(¯x1, ¯z1)σ (¯x, z1, . . . , zm)...Auxmσ (¯x, z1, . . . , zm) → Rn(¯xn, ¯zn),σ , . . . , Auxm(cid:11)where the auxiliary predicates Aux1set N((cid:2)) as the set N(·):σ do not belong to the schema S. Given a set (cid:2) of linear TGDs, we define the σ ∈(cid:2) N(σ ). The next easy lemma collects some useful facts concerning the normalization procedure Lemma 3.3. Consider a set (cid:2) ∈ L over a schema S. The following hold:1. N((cid:2)) can be computed in polynomial time in the size of (cid:2).12G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 1039362. Given a database D and a CQ q(¯x) over S, cert(q, D, (cid:2)) = cert(q, D, N((cid:2))).Note that item (2) of Lemma 3.3 holds due to the fact that the auxiliary predicates introduced during the normalization do not occur in D or q. Recall that our goal is to establish a result similar to Theorem 3.1 for the class of linear TGDs in normal form, more precisely, the class of TGDs LN = {N((cid:2)) | (cid:2) ∈ L}. Of course, it should not be surprising that LN enjoys the bounded witness property due to fL since LN ⊆ L; this is an immediate consequence of Theorem 3.1. Thus, the goal of this new result is not to simply show that LN enjoys the bounded witness property, but to show that the property holds due to a function that provides a bound w.r.t. the original set of TGDs before the normalization. Since the normalization procedure does not preserve the arity of the predicates,8 this result will be particularly important for showing in the next section that in the case of schemas of fixed arity, the class of linear TGDs is polynomially combined ∃FO-rewritable.+It is not difficult to verify that, for every pair of sets of TGDs (cid:2)1, (cid:2)2 ∈ L, N((cid:2)1) = N((cid:2)2) implies (cid:2)1 = (cid:2)2; this is actually a consequence of the normalization procedure. Therefore, given a set (cid:2) ∈ LN of TGDs, there exists a unique set of , such that (cid:2) = N((cid:2)−). In simple words, (cid:2)−TGDs from L, which we denote by (cid:2)−is the (unique) set of linear TGDs that we obtain after “denormalizing” (cid:2). We also write exvar(σ ) for the set of existentially quantified variables occurring in a TGD σ . We define the function fLN that maps LN × CQ to the natural numbers as follows:(cid:13)(cid:14)fLN ((cid:2), q) =maxσ ∈(cid:2)−{|exvar(σ )|} + maxσ ∈(cid:2)−{|head(σ )|}· fL((cid:2)−, q)It is clear that fLN is computable since fL is computable. We proceed to show that:Theorem 3.2. LN enjoys the bounded witness property due to fLN .Proof. Consider a database D, a set (cid:2) ∈ LN, a CQ q(¯x), and a tuple c ∈ C. We need to show that ¯c ∈ cert(q, D, (cid:2)) implies the existence of a sequence (Ii)0≤i≤n, with n ≤ fLN ((cid:2), q), that is a prefix of a chase derivation of D w.r.t. (cid:2), and ¯c ∈ q(In). By Lemma 3.3, we get that cert(q, D, (cid:2)) = cert(q, D, (cid:2)−). Since, by construction, (cid:2)− ∈ L, by Theorem 3.1 we conclude the following: ¯c ∈ cert(q, D, (cid:2)) implies the existence of a sequence ( J i)0≤i≤m, with m ≤ fL((cid:2)−, q), that is a prefix of a chase derivation of D w.r.t. (cid:2)−, and ¯c ∈ q( J n). Our goal is to convert ( J i)0≤i≤m into the desired sequence (Ii)0≤i≤n, with n ≤ fLN ((cid:2), q), that is a prefix of a chase derivation of D w.r.t. (cid:2), and ¯c ∈ q(In), which in turn shows our claim.|¯x|Assume that J j(cid:17)σ j, h j(cid:18) J j+1, for j ∈ {0, . . . , m − 1}, with σ j being of the formP (¯x, ¯y) → ∃z1 · · · ∃zk j R1(¯x1, ¯z1), . . . , R(cid:9) j (¯x(cid:9) j , ¯z(cid:9) j ).(cid:14)j(head(σ j)), i.e., h(cid:14)j is the extension of h j that has been employed during the application We also assume that J j+1 = J j ∪ hof (σ j, h j). We define the sequence of instances1, . . . , Ik1+(cid:9)1−10, . . . , Ik0+(cid:9)0−10, I 1I 01, I 1, I 010, . . . , I 0m−1, I 1m−1, . . . , Ikm−1+(cid:9)m−1−1m−1, I 0m,where• for each j ∈ {0, . . . , m}, I 0j• for each j ∈ {0, . . . , m − 1} and i ∈ {1, . . . , k j},(cid:4)(¯x, z1, . . . , zi))= I i−1= J j ,(cid:3)h(cid:14)j(Auxiσ jI ij∪j,• for each j ∈ {0, . . . , m − 1} and i ∈ {k j + 1, . . . , k j + (cid:9) j − 1},I ij= I i−1j∪(cid:3)h(cid:4)(cid:14)j(R i−k j (¯xi − k j, ¯zi−k j )).j , . . . , σ k j +(cid:9) jWe proceed to show that the above is indeed the desired sequence of instances. For j ∈ {0, . . . , m − 1}, let σ 1be the linear TGDs of N(σ j), i.e., the TGDs obtained after normalizing σ j , in the order that are presented in the definition (¯x, z1, . . . , zi), and for i ∈ {k j + 1, . . . , k j + (cid:9) j}, σ iof N(σ j). In other words, for i ∈ {1, . . . , k j}, σ ij is the TGD with head Auxiσ jjis the TGD with head R i−k j (¯xi−k j , ¯zi−k j ). It is not difficult to verify that, for each j ∈ {0, . . . , m − 1}, the following hold:j(cid:17)σ 1j , h j(cid:18)I 1j ,• I 0j• for each i ∈ {1, . . . , k j − 1}, I ij(cid:17)σ i+1j, hi+1j(cid:18)I i+1j with hi+1jbeing the restriction of h(cid:14)j over the variables ¯x ∪ {z1, . . . , zi},8 In fact, even if we consider a set of TGDs over a schema of fixed arity, the normalized set will, in general, contain predicates of unbounded arity (see the auxiliary predicates).13G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936• for each i ∈ {k j, . . . , k j − (cid:9) j − 2}, I ij• I, h(cid:17)σ k j +(cid:9) jk j +(cid:9) j −1jj+1.(cid:18)I 0(cid:14)jj(cid:17)σ i+1j, h(cid:14)j(cid:18)I i+1j, andTherefore, the sequence of instances defined above is a prefix of a chase derivation of D w.r.t. (cid:2)−to show that(cid:13)(cid:14), and ¯c ∈ q(I 0m). It remains maxj∈{0,...,m−1}{k j} + maxj∈{0,...,m−1}{(cid:9) j}· m ≤ fLN ((cid:2), q).Observe thatmaxj∈{0,...,m−1}maxj∈{0,...,m−1}{k j} ≤ maxσ ∈(cid:2)−{(cid:9) j} ≤ maxσ ∈(cid:2)−m ≤ fL((cid:2){|exvar(σ )|},{|head(σ )|},−, q),and the claim follows. (cid:2)4. Polynomial combined rewritability and linearityWe proceed to study the notion of polynomial combined rewritability in the case of linear TGDs. We say that a family of schemas S is of fixed arity if there exists an integer k ≥ 0 such that, for every schema S ∈ S, it holds that ar(S) ≤ k.Theorem 4.1. The following hold:1. L is polynomially combined FO-rewritable.2. For a family of schemas S of fixed arity, L[S] is polynomially combined ∃FO+-rewritable.Since the evaluation problem for ∃FOquery q(¯x), and a tuple ¯c ∈ dom(D)|¯x|, that is, given a database D, an ∃FO, decide whether ¯c ∈ q(D), is in NP, an immediate consequence of Theorem 4.1 is the following complexity result, which, as discussed in the Introduction, closes a complexity gap for the problem OQA(L) in the case of schemas of fixed arity. In fact, the following result is known for single-head (i.e., only one atom in the head) linear TGDs [23], but it cannot be straightforwardly transferred to multi-head (i.e., more than one atom in the head) linear TGDs.++Corollary 4.1. OQA(L) is NP-complete for schemas of fixed arity.The proof of Theorem 4.1 heavily relies on Proposition 4.1 below, which is actually the main technical result of this section. For a database D, we defineD01 = D ∪ {Zero(0), One(1)},where 0 and 1 are new constants not in dom(D), while Zero and One are new predicates not mentioned in D. In other words, D01 is obtained by adding to the domain of D the new constants 0 and 1 that we can access via the unary predicates Zero and One, respectively. Moreover, for a family of schemas S, we write LSN for the class{(cid:2) ∈ LN | (cid:2)− ∈ L[S]},which essentially collects all the sets of linear TGDs in normal form that after “denormalizing” them we get a set of linear TGDs over a schema of S.Proposition 4.1. The following hold:1. There is a polynomial-time computable query rewriter f Q : CQ × LN → FO such that, for every database D, set (cid:2) ∈ LN of TGDs, and CQ q, cert(q, D, (cid:2)) = q(cid:2)(D01) with q(cid:2) = f Q(q, (cid:2)).2. For a family of schemas S of fixed arity, there is a polynomial-time computable query rewriter f SQQ (q, (cid:2)).N , and q ∈ CQ[S], cert(q, D, (cid:2)) = q(cid:2)(D01) with q(cid:2) = f Ssuch that, for every D ∈ D[S], (cid:2) ∈ LS: CQ[S] × LSN→ ∃FO+Before giving the proof of Proposition 4.1, let us explain how we get Theorem 4.1 by exploiting Proposition 4.1. For item (1), we need to show that there are polynomial-time computable database and query rewriters gDB and gQ, respectively, 14G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936such that, for every database D, set (cid:2) ∈ L, and CQ q, cert(q, D, (cid:2)) = q(cid:2)(D(cid:2)) with D(cid:2) = gDB(D, (cid:2)) and q(cid:2) = gQ(q, (cid:2)). We define the database rewritergDB(D, (cid:2)) = D01,which is clearly computable in constant time,9 and the query rewritergQ(q, (cid:2)) = f Q(q, N((cid:2)))with f Q being the polynomial-time computable rewriter provided by item (1) of Proposition 4.1; recall that N((cid:2)) ∈ LN is the normalized version of (cid:2). Since, by Lemma 3.3, N((cid:2)) is computable in polynomial time, gQ is also computable in polynomial time. Moreover, by item (1) of Proposition 4.1, cert(q, D, N((cid:2))) = q(cid:2)(D(cid:2)) with D(cid:2) = gDB(D, (cid:2)) and q(cid:2) = gQ(q, (cid:2)). By Lemma 3.3, cert(q, D, (cid:2)) = cert(q, D, N((cid:2))), and thus, cert(q, D, (cid:2)) = q(cid:2)(D(cid:2)), as needed. Item (2) of Theorem 4.1 is shown via a similar argument, but relying on item (2) of Proposition 4.1.The rest of the section is devoted to showing Proposition 4.1. Here is a roadmap of the rather long proof.• We start in Section 4.1 by introducing our main technical tool, the so-called witness generator, which formalizes the intuitive idea that for linear TGDs, ontological query answering can be realized as a reachability problem on the di-rected graph (which is actually a forest due to linearity) that is formed by the parent relation of a chase derivation. In particular, given a database D, a set (cid:2) ∈ LN, a CQ q(¯x), and a tuple ¯c ∈ dom(D)|¯x|, we characterize the fact that ¯c ∈ cert(q, D, (cid:2)) via the existence of a witness generator for q(¯c) w.r.t. D and (cid:2).• The above characterization essentially tells us that the desired query rewriters should build first-order queries that check whether, on an input database D, there exists a witness generator for q(¯d), with ¯d ∈ dom(D)|¯x|being a candidate certain answer, w.r.t. D and (cid:2). To this end, we need to encode such a witness generator in a way that a first-order query can talk about it. This is done in Section 4.2 by representing predicates and nulls via binary strings, i.e., strings consisting of 0 and 1, which in turn leads to the notion of binary witness generator.• We then proceed in Section 4.3 and 4.4 to establish item (1) and (2), respectively, of Proposition 4.1 by constructing the desired query rewriters.4.1. Witness generatorBefore delving into the formal definitions, let us first illustrate the key ideas underlying the notion of witness generator via a simple example.Example 4.1. Consider the databaseD = {P (a, b, c), P (b, c, d)}the set (cid:2) consisting of the linear TGDsβ → ∃w P (x, y, w), β → ∃w P (z, x, w), β → P (z, y, x), β → ∃w P ( y, z, w),where β = P (x, y, z), and the Boolean CQq = ∃x∃ y∃z∃w P (x, a, y) ∧ P (z, y, b) ∧ P (w, c, b).As illustrated in the following figure, there is a homomorphism h (dashed arrows in the figure) that maps q to an initial segment of the forest formed due to the parent relation of a chase derivation δ of D w.r.t. (cid:2), and thus, cert(q, D, (cid:2)) (cid:3)= ∅.9 Notice that the result of gDB(D, (cid:2)) does not depend on (cid:2); we simply add to D the constants 0 and 1.15G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936It is interesting to observe that the nulls occurring in h(q), namely the nulls ⊥1, ⊥3, ⊥4 and ⊥5, form the rooted forest Fwith the following properties; let ν(⊥) be the atom of chaseδ(D, (cid:2)), where the null ⊥ has been invented (see shaded atoms above for ν(⊥1), ν(⊥3), ν(⊥4), and ν(⊥5)):• for every root node ⊥, ν(⊥) is reachable from D,• for every edge (⊥, ⊥(cid:14)), ν(⊥(cid:14)) is reachable from ν(⊥), and• for every atom α ∈ h(q), there is a unique path π in F that contains all the nulls in α, and, assuming that the leaf node of π is ⊥, α is reachable from ν(⊥).Indeed, it is easy to see that ν(⊥1) and ν(⊥5) are reachable from D, ν(⊥3) and ν(⊥4) are reachable from ν(⊥1), and finally, h(P (x, a, y)) = P (⊥3, a, ⊥1) is reachable from ν(⊥3), h(P (z, y, b)) = P (⊥4, ⊥1, b) is reachable from ν(⊥4), and h(P (w, c, b)) = P (⊥5, c, b) is reachable from ν(⊥5). Roughly speaking, the triple consisting of1. the homomorphism h, which maps q to chaseδ(D, (cid:2)),2. the function ν, which gives the atoms of chaseδ(D, (cid:2)) where the nulls occurring in h(q) were invented, and3. the forest F , which encodes how the nulls of h(q) depend on each other, as well as the order of their generation,is what we call a witness generator for q w.r.t. D and (cid:2). The existence of such a triple allows us to generate a prefix of the chase derivation δ, i.e., a witness (hence the name “witness generator”), that entails the query q. (cid:2)Let us now formalize the intuition underlying the notion of witness generator described in Example 4.1. To this end, we first need to introduce some auxiliary notions.Rooted Forests. A rooted tree T over a set V is a directed tree with V being the node set of T , where one node, denoted root(T ), is the root, and the edges have an orientation away from the root. The tree-order of T is the (non-strict) partial order (cid:24)T over V such that v (cid:24)T u iff the unique path from the root to u passes through v. The corresponding strict partial order is given by: v ≺T u iff v (cid:24)T u and v (cid:3)= u. A rooted forest F over a set V is a collection of rooted trees T 1, . . . , Tn over V 1, . . . , V n, respectively, where {V 1, . . . , V n} is a partition of V . We define root(F ) =i∈[n]{root(T i)}. The forest-order of F is the partial order (cid:24)F =i∈[n] (cid:24)T i , while v ≺F u iff v (cid:24)F u and v (cid:3)= u. Let U ⊆ V such that, for v, u ∈ U , v (cid:24)F u or u (cid:24)F v. It can be verified that there exists a unique v ∈ U , denoted maxF (U ), such that u ≺F v, for each u ∈ U .(cid:11)(cid:11)Witness Generator Scheme. As discussed above, a witness generator for a Boolean CQ q w.r.t. a database D and a set (cid:2) ∈ LN, is a triple consisting of a function h that maps var(q) to constants and nulls, a function ν that assigns to each null ⊥ ∈ null(h(q)) an atom that corresponds to the atom in which ⊥ has been invented, and a rooted forest F over null(h(q)). Such a triple, though, in order to be a valid candidate for a witness generator, must satisfy certain properties: (1) the atoms of h(q), as well as the atoms where the nulls of h(q) were invented, do not contain incomparable (w.r.t. (cid:24)F ) nulls of h(q), 16G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936and (2) for each ⊥ ∈ null(h(q)), ⊥ is the most recently generated null among the nulls in ν(⊥). These are formalized via the notion of witness generator scheme. Recall that, for a set T of terms and a schema S, B(T , S) is the set that collects all the atoms that can be formed using terms of T and predicates of S.Definition 4.1 (Witness Generator Scheme). Consider a Boolean CQ q over a schema S. A witness generator scheme for q is a triple (h, ν, F ), where h : var(q) → C ∪ N, ν : null(h(q)) → B(C ∪ N, S), and F is a rooted forest over null(h(q)), such that1. for each α ∈ (h(q) ∪ {ν(⊥) | ⊥ ∈ null(h(q))}), and for each pair of nulls ⊥1, ⊥2 ∈ (null(α) ∩ null(h(q))), ⊥1 (cid:24)F ⊥2 or ⊥2 (cid:24)F ⊥1, and2. for each ⊥ ∈ null(h(q)), ⊥ = maxF (null(ν(⊥)) ∩ null(h(q))). (cid:2)Witness Generator. We are now ready to define the key notion of the witness generator. A witness generator is essen-tially a witness generator scheme that indeed gives rise to a witness of the given query. Consider a set (cid:2) ∈ LN over a schema S. We first need to inductively define the binary relation (cid:25)k(cid:2) over B(C ∪ N, S), for k ≥ 0, as follows:• α (cid:25)0• α (cid:25)k(cid:2) β if α = β, or {α}(cid:17)σ , h(cid:18){α, β} with (σ , h) being a trigger for (cid:2) on {α};(cid:2) β if there exists an atom γ ∈ B(C ∪ N, S) such that dom(α) ∩ dom(β) ⊆ dom(γ ), and α (cid:25)k−1(cid:2) γ and γ (cid:25)k−1(cid:2) β.Intuitively, α (cid:25)krelation α (cid:25)k,⊥(cid:2) β, where ⊥ is a null, as follows:(cid:2) β means that β is derivable from α in at most 2k chase steps using TGDs from (cid:2). We further define the • α (cid:25)0,⊥• α (cid:25)k,⊥(cid:2) β if ⊥ ∈ dom(β) \ dom(α), and {α}(cid:17)σ , h(cid:18){α, β} with (σ , h) being a trigger for (cid:2) on {α};(cid:2) β if there exists an atom γ ∈ B(C ∪ N, S) such that dom(α) ∩ dom(β) ⊆ dom(γ ), and α (cid:25)k−1(cid:2) γ and γ (cid:25)k−1,⊥(cid:2)β.Roughly, α (cid:25)k,⊥The notion of witness generator follows.(cid:2) β means that β is derivable from α in at most 2k chase steps using TGDs from (cid:2), and ⊥ is invented in β. Definition 4.2 (Witness Generator). Consider a database D over a schema S, a set (cid:2) ∈ LN of TGDs over S, and a Boolean CQ q over S. A k-witness generator, where k ≥ 0, for q w.r.t. D and (cid:2) is a witness generator scheme (h, ν, F ) for q such that1. For each ⊥ ∈ root(F ), there exists α ∈ D such that α (cid:25)k,⊥2. For each edge (⊥1, ⊥2) of F , ν(⊥1) (cid:25)k,⊥23. For each α ∈ h(q) with ⊥ = maxF (null(α)), ν(⊥) (cid:25)k4. For each α ∈ h(q) with null(α) = ∅, there exists β ∈ D such that β (cid:25)k(cid:2) ν(⊥).ν(⊥2).(cid:2) α.(cid:2)(cid:2) α. (cid:2)Note that for a witness generator (h, ν, F ) for q w.r.t. D and (cid:2), it holds that the range of h is dom(D) ∪ N and the range of ν is B(dom(D) ∪ N, S); otherwise, conditions (3) and (4) trivially fail. We proceed to characterize when a candidate answer is indeed a certain answer via the existence of an appropriate witness generator.Lemma 4.1. Consider a database D, a set (cid:2) ∈ LN of TGDs, a CQ q(¯x), and a tuple ¯c ∈ dom(D)|¯x|. The following are equivalent:1. ¯c ∈ cert(q, D, (cid:2)).2. There exists a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2).Proof. (1) ⇒ (2). By Theorem 3.2, LN enjoys the bounded witness property due to fLN . Thus, since ¯c ∈ cert(q, D, (cid:2)), there exists a prefix (Ii)0≤i≤n, with n ≤ LN((cid:2), q), of a chase derivation δ of D w.r.t. (cid:2) such that ¯c ∈ q(In). This in turn implies that there is a homomorphism h that maps q(¯c) to In. For a null ⊥ ∈ null(h(q)), there exists a unique integer i ∈ [n] such that ⊥ ∈ dom(Ii) \ dom(Ii−1). We write α⊥ for the single atom in Ii \ Ii−1, that is, the atom where ⊥ is invented according to δ, and we define the function ν : null(h(q)) → chaseδ(D, (cid:2)) in such a way that ν(⊥) = α⊥ for each ⊥ ∈ null(h(q)). We finally define the rooted forest F over null(h(q)) as follows:• if null(h(q)) = ∅, then F is the empty forest,• if null(h(q)) = {⊥}, then F consists of the single node ⊥, and• if null(h(q)) = {⊥1, . . . , ⊥m} for m > 1, then, for every i, j ∈ {1, . . . , m} with i (cid:3)= j, there exists an edge from ⊥i to ⊥ j iff δ α⊥ j . Note that F is indeed a α⊥iforest since ≺p,+δ α⊥ j , and there is no integer k ∈ [m] \ {i, j} such that α⊥iforms a forest over chaseδ(D, (cid:2)) due to linearity.δ α⊥k and α⊥k≺p,+≺p,+≺p,+δ17G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936We show that the triple (h, ν, F ) is a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2). The fact that (h, ν, F )is a witness generator scheme for q can be easily verified due to linearity. It remains to show that the four conditions in Definition 4.2 hold with k = (cid:26)log fLN ((cid:2), q)(cid:27). To this end, it suffices to show that, for every two distinct atoms α, β ∈((cid:2),q)(cid:27)chaseδ(D, (cid:2)) such that α ≺p,+β, and, if β is the atom where a null ⊥ is invented, it holds (cid:26)log fLNthat α (cid:25)(cid:2)(cid:26)log fLNβ, it holds that α (cid:25)(cid:2)β. Assume that((cid:2),q)(cid:27),⊥δα = α1 ≺pδ α2 ≺pδ· · · ≺pδ α(cid:9) = β,for 1 < (cid:9) ≤ fLN ((cid:2), q), i.e., α1, . . . , α(cid:9) is the path from α to β in the forest formed by ≺p(cid:9)(cid:14) = 2((cid:2),q)(cid:27) − (cid:9) + 1, the sequence of atoms(cid:26)log fLNδ . It is easy to verify that, with , α1, α2, . . . , α(cid:9)α1, . . . , α1(cid:9)(cid:7)(cid:8)(cid:6)(cid:9)(cid:14)(cid:26)log fLNwitnesses the fact that α (cid:25)(cid:2)according to δ, as needed.((cid:2),q)(cid:27)(cid:26)log fLNβ, and the fact that α (cid:25)(cid:2)((cid:2),q)(cid:27),⊥β in case β is the atom where ⊥ is invented (cid:11)ni=0 hiδ .(2) ⇒ (1). We first observe that for a quasi chase derivation (Ii )0≤i≤n, for n ≥ 0, of D w.r.t. (cid:2), the following holds: for every chase derivation δ of D w.r.t. (cid:2), there exists a homomorphism hδ that maps In to chaseδ(D, (cid:2)). This can be established via an easy inductive argument, which shows that, for every i ∈ {0, 1, . . . , n}, there exists a homomorphism hiδfrom Ii to chaseδ(D, (cid:2)), and, for i > 0, hiδ is well-defined. Therefore, hδ can be defined as δ is compatible with hi−1, i.e., hi−1From the above observation, to show our claim, it suffices to show that the existence of a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2) implies the existence of a quasi chase derivation (Ii)0≤i≤n, for n ≥ 0, of D w.r.t. (cid:2) such that ¯c ∈ q(In). Indeed, in such a case, since q(¯c) → In and In → chaseδ(D, (cid:2)), where δ is a chase derivation of D w.r.t. (cid:2), we get that q(¯c) → chaseδ(D, (cid:2)), and thus, ¯c ∈ cert(q, D, (cid:2)), as needed. The rest of the proof is devoted to showing that (2)implies the existence of a quasi chase derivation (Ii)0≤i≤n, for n ≥ 0, of D w.r.t. (cid:2) such that ¯c ∈ q(In).Let (cid:14) = (h, ν, F ) be a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2). The construction of the desired quasi ∪ hiδδchase derivation proceeds in three main steps:• We first construct the forest F (cid:14) over atoms induced by (cid:14). As we shall see, the leaves of this forest are precisely the atoms of h(q(¯c)).• We then apply a renaming step over the atoms in F (cid:14), which leads to the forest F (cid:15)occurrences of the same null are semantically the same. Then, we show that the leaves of F (cid:15)of h(q(¯c)), that is, the renaming step does not alter the atoms at the leaves of F (cid:14).(cid:14). This step ensures that different (cid:14) are precisely the atoms • We finally convert F (cid:15)(cid:14) into a sequence of instances (Ii)0≤i≤n that is a quasi chase derivation of D w.r.t. (cid:2) (the latter is guaranteed by the renaming step), and ¯c ∈ q(In) since the leaves of F (cid:15)(cid:14) are the atoms of h(q(¯c)).Step 1: Construction of F (cid:14)We now explain how the rooted forest F (cid:14) is constructed. To this end, we first construct an auxiliary forest F(cid:14)(cid:14) over the atoms D ∪ {ν(⊥) | ⊥ ∈ null(h(q))} ∪ h(q) with the following edges (and only those edges). For brevity, let k = (cid:26)log fLN ((cid:2), q)(cid:27).• For each ⊥ ∈ root(F ), assuming that α ∈ D is the atom provided by (cid:14) with α (cid:25)k,⊥(cid:2) ν(⊥), there is an edge from α to • For each edge (⊥1, ⊥2) of F , there is an edge from ν(⊥1) to ν(⊥2).• For each α ∈ h(q) with ⊥ = maxF (null(α)), there is an edge from ν(⊥) to α.• For each α ∈ h(q) with null(α) = ∅, assuming that β ∈ D is the atom provided by (cid:14) with β (cid:25)k(cid:2) α, there is an edge from ν(⊥).β to α.2k−1, β, where γ eWe now construct the forest F (cid:14) from F1 , . . . , γ e(cid:14)(cid:14) with the path of atoms (cid:2) β in case β = ν(⊥)). is the sequence of atoms that witnesses α (cid:25)kα, γ e2k−1(cid:14)(cid:14)} is non-empty. (cid:14), it might be the case that {γ e1 , . . . , γ eLet us clarify that, for distinct edges e, eof FNevertheless, the common atoms give rise to different nodes in F (cid:14). This completes the construction of F (cid:14). It is easy to see that the leaves of F (cid:14) are precisely the atoms of h(q(¯c)) since the leaves of F(cid:14)(cid:14) as follows: replace each edge e = (α, β) of F(cid:2) β (or α (cid:25)k,⊥} ∩ {γ e2k−1(cid:14)(cid:14) are precisely the atoms of h(q(¯c)).1 , . . . , γ e1 , . . . , γ e(cid:14)2k−1(cid:14)Step 2: Renaming of NullsThe goal of this step is to ensure that different occurrences of a null in F (cid:14) are semantically the same. It might be the ⊥case that, for a certain null ⊥, the subforest F(cid:14) induced by ⊥, that is, the subforest obtained by keeping only the nodes ⊥(i.e., atoms) containing ⊥, is disconnected. In such a case, the occurrences of ⊥ in different connected components of F(cid:14)are semantically different, despite the fact that they have the same name. On the other hand, the occurrences of ⊥ that 18G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936appear in the same connected component are semantically the same since they are invented and propagated via valid chase steps. We now explain how the renaming step works, which leads to the forest F (cid:15)(cid:14).⊥1 , . . . , T⊥m⊥ , for m⊥ ≥ 1, be the connected components of the subforest F⊥(cid:14) induced by Let ⊥ be a null in F (cid:14), and let T⊥. We consider the following two cases:1. Assume that ⊥ /∈ null(h(q(¯c))). We rename each occurrence of ⊥ in T2. Assume now that ⊥ ∈ null(h(q(¯c))). By construction, there exists j⊥ ∈ [m⊥] such that T⊥j⊥ is rooted at ν(⊥). We rename , for i ∈ [m⊥] \ { j⊥}, into ⊥i . The only difference of this case is that the occurrences of ⊥⊥j⊥ remain unchanged. This captures the intuition that these are the “real” occurrences of ⊥ invented (in ν(⊥)) and , for i ∈ [m⊥], into ⊥i .⊥ieach occurrence of ⊥ in Tin Tpropagated via valid chase steps.⊥iThis completes the construction of F (cid:15)(cid:14). We proceed to establish the following claim:Claim 4.1. The following hold:1. For a null ⊥ in F (cid:15)2. Let L be the set of atoms occurring as leaves in F (cid:15)(cid:14), the subforest F (cid:15)(cid:14) induced by ⊥ is connected.(cid:14). Then L = h(q(¯c)).Proof. It is easy to see that item (1) holds by construction. It remains to show item (2). Recall that the leaves of F (cid:14)are precisely the atoms of h(q(¯c)). It is also clear that there is an 1-1 correspondence between the leaves of F (cid:14) and the leaves of F (cid:15)(cid:14) since the renaming step does not alter the structure of F (cid:14). Thus, for a leaf node β in F (cid:14), we can refer to its corresponding leaf node β(cid:15) in F (cid:15)(cid:14). Therefore, it suffices to show that, for each leaf node β in F (cid:14), β and β(cid:15) are (syntactically) the same atom.Consider an arbitrary leaf node β in F (cid:14), and let α1, α2, . . . , α(cid:9), β be the unique path in F (cid:14) from a root node to β. We proceed to show that the renaming step does not alter β, which in turn implies that β and β(cid:15) are the same atom, as needed. The proof is by case analysis on whether β contains no null, one null, or more than one null:1. Assume that null(β) = ∅, which means that dom(β) ⊆ dom(D). In this case, the claim holds trivially since during the renaming step constants from dom(D) are not renamed, and thus, β = β(cid:15).2. Assume that null(β) = {⊥}, i.e., β contains only one null. Since, by definition, (cid:14) is a witness generator scheme for q(¯c), we conclude that there exists an atom γ ∈ {α2, . . . , α(cid:9)} such that γ = ν(⊥). Furthermore, since ⊥ occurs in both βand γ , i.e., ⊥ ∈ dom(β) ∩ dom(γ ), we get that ⊥ occurs in every atom between γ and β. Thus, ⊥ in β is not renamed during the renaming step, and thus, β = β(cid:15).3. Assume that null(β) = {⊥1, . . . , ⊥m} for m > 1, i.e., β contains more than one null. Since (cid:14) is a witness generator scheme for q(¯c), the nulls ⊥1, . . . , ⊥m are comparable w.r.t. (cid:24)F ; let ⊥1 (cid:24)F ⊥2 (cid:24)F · · · (cid:24) ⊥m. Furthermore, we conclude that, for each i ∈ [m − 1], ν(⊥i) does not contain a null from {⊥i+1, . . . , ⊥m}. Therefore, there are atoms γ1, . . . , γm ∈ {α2, . . . , α(cid:9)}such that γi = ν(⊥i) for each i ∈ [m], and the path from α1 to β in F (cid:14) is of the formα1, . . . , γ1, . . . , γ2, . . . , γm, . . . , β.Moreover, for each i ∈ [m], the null ⊥i ∈ dom(β) ∩ dom(γi) occurs in every atom between γi and β. Therefore, none of the nulls ⊥1, . . . , ⊥m in β has been renamed during the renaming step, and thus, β = β(cid:15).This completes the proof of Claim 4.1. (cid:2)Step 3: Construction of a quasi chase derivationIn this last step, we explain how F (cid:15)−sequence of edges obtained by traversing F (cid:15)(cid:14) in a breadth-first fashion.10 Let also sfrom s by removing all the edges of the form (α, α), where α ∈ D. For example, if F (cid:15)(cid:14) is of the form(cid:14) is converted into the desired quasi chase derivation of D w.r.t. (cid:2). Let s be the be the sequence of edges obtained 10 Here we simply need a mechanism to traverse F (cid:15)(cid:14). We could also traverse F (cid:15)(cid:14) in a depth-first fashion.19G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936thens = (α1, α4), (α1, α1), (α3, α5), (α1, α1), (α5, α6), (α5, α7)− = (α1, α4), (α3, α5), (α5, α6), (α5, α7).sWe inductively define a sequence of instances; let s− = e1, . . . , en for n ≥ 0:• I0 = D, and• for each i ∈ [n], with ei = (α, β), Ii = Ii−1 ∪ {β}.It is now easy to see, due to Claim 4.1, that (Ii)0≤i≤n is a quasi chase derivation of D w.r.t. (cid:2) with ¯c ∈ q(In). Let us conclude the proof by clarifying that (Ii)0≤i≤n is not a prefix of a chase derivation of D w.r.t. (cid:2), as one might think, since triggers may repeat, i.e., the same trigger may be used in different applications. (cid:2)4.2. Binary witness generatorLemma 4.1 essentially tells us that the desired query rewriters that are needed for establishing Proposition 4.1 should build first-order queries that check whether there is a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2). To this end, we need to encode such a witness generator in a way that a first-order query can talk about it. The key idea underlying this encoding is to represent predicates and nulls via binary strings, i.e., strings consisting of 0 and 1; hence the name “binary witness generator”. In the rest of the paper, we write ok for the string o . . . o of length k, where o is some symbol and k ≥ 0; whenever k = 0, ok is the empty string.Encoding/Decoding of Atoms. Consider a set (cid:2) ∈ LN and a CQ q(¯x) both over the schema S = {P 1, . . . , P m}, where m ≥ 1. We consider the integer(cid:15)τ =(cid:16)log(|q| · ar(S) · fLN ((cid:2), q) + 1),which is sufficiently large to ensure that all the nulls occurring in a witness induced by a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator can be represented via binary strings of length τ . We define the set of binary strings(cid:4)(cid:3)0i−110m−i | i ∈ [m]BS =that collects the encodings of the predicates from S. In particular, the predicate P i ∈ S is encoded via the binary string 0i−110m−i . We further define the set of strings(cid:18)(cid:17)cτ | c ∈ CBC =that collects the encodings of constants from C. Note that a constant c ∈ C is represented via the string cτ . The reason why c is represented via such a string of length τ , instead of c itself, is purely technical: we need all the terms, constants or nulls, in a witness induced by a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator to be represented via strings of the same length. We finally define the set of binary stringsBN = {b1 . . . bτ | bi ∈ {0, 1} for each i ∈ [τ ]} \(cid:18)(cid:17)0τthat collects the encodings of null values that can appear in a witness induced by a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator. Note that the string 0τ is reserved for padding purposes and this is why is excluded from the set BN; this will be made clear later.Having the sets of strings BS, BC and BN in place, we can now explain how an atom is encoded. Consider an atom α =P i(t1, . . . , tn) ∈ B(C ∪ BC ∪ BN, S), for some i ∈ [m]. The encoding of α, denoted enc(α), is the string of length (m + ar(S) · τ )0i−110m−iar(S)−ar(P i )(cid:8) (cid:9)(cid:6) (cid:7)0τ . . . 0τf (t1) . . . f (tn),where(cid:12)f (t) =tτtif t ∈ C,if t ∈ (BC ∪ BN).Note that if ar(P i) < ar(S), then the first ar(S) − ar(P i) positions of the encoded atom are padded with the special string 0τ ; this is the reason why 0τ /∈ BN. Now, for a string t of length (m + ar(S) · τ ) of the form0i−110m−iar(S)−ar(P i )(cid:8) (cid:9)(cid:6) (cid:7)0τ . . . 0τ t1 . . . tar(P i ),20G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936where t j ∈ (BC ∪ BN) for each j ∈ [ar(P i)], let dec(t) be the atom P i(t1, . . . , tar(P i )), that is, the decoding of t. For an atom α ∈ B(C ∪ BC ∪ BN, S), let bnull(α) be the set of strings dom(α) \ (C ∪ BC), i.e., the binary strings in α that encode nulls; this notation extends to sets of atoms. The following example, which builds on Example 4.1, illustrates the encoding of atoms and how a binary witness generator looks like.Example 4.2. Consider again the databaseD = {P (a, b, c), P (b, c, d)}the set (cid:2) consisting of the linear TGDsβ → ∃w P (x, y, w), β → ∃w P (z, x, w), β → P (z, y, x), β → ∃w P ( y, z, w),where β = P (x, y, z), and the Boolean CQq = ∃x∃ y∃z∃w P (x, a, y) ∧ P (z, y, b) ∧ P (w, c, b)introduced in Example 4.1. In the following, since (cid:2) is already in normal form, we assume that (cid:2) and N((cid:2)) coincide. Recall that the normal form for TGDs is discussed in Section 3. Observe that D, (cid:2) and Q are over the schema S = {P }. Clearly, |S| = 1, ar(S) = 3, |(cid:2)| = 4 and |q| = 3. Therefore, we have thatfLN ((cid:2), q) = |(cid:2)| · |S| · (2 · |q| · ar(S) + ar(S))ar(S)= 4 · 1 · (2 · 3 · 3 + 3)3= 37044,which in turn implies thatτ ==(cid:15)(cid:15)(cid:16)log(|q| · ar(S) · fLN ((cid:2), q) + 1)(cid:16)log(3 · 3 · 37044 + 1)= 19.Therefore, we get that(cid:4)(cid:3)0i−110m−i | i ∈ [|S|](cid:4)(cid:3)c19 | c ∈ CBS =BC == {1}BN = {b1, . . . , b19 | bi ∈ {0, 1} for i ∈ [19]} \ {019}.Consider now the atom α = P (a, b, c). Since |S| = 1 and ar(S) − ar(P ) = 0, its encoding enc(α) is the string1a19b19c19.Now, the atom P (a, b, ⊥1) from Example 4.1, first has to be encoded as an atom of B(C ∪ BC ∪ BN, S), namely α = P (a, b, t)witht = 0181being the first tuple of BN (according to the lexicographic order) that encodes ⊥1. Then, α can be encoded via the string1a19b190181.The chase forest and rooted forest F of nulls from Example 4.1 remain structurally the same, with the key difference that atoms and nulls are encoded as described above. In particular, we have h(q) = {P (t3, a, t1), P (t4, t1, b), P (t5, c, b)}, wheret1 = 0181t3 = 01711This completes our example. (cid:2)t4 = 016100t5 = 016101.Binary Witness Generator Scheme. The notion of binary witness generator scheme is defined in the same way as the notion of witness generator scheme (see Definition 4.1), with the difference that we use the binary encoding of terms and atoms discussed above.21G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936Definition 4.3 (Binary Witness Generator Scheme). Consider a Boolean CQ q over a schema S. A binary witness generator schemefor q is a triple (h, ν, F ), where h : var(q) → BC ∪ BN, ν : bnull(h(q)) → {enc(α) | α ∈ B(BC ∪ BN, S)}, and F is a rooted forest over bnull(h(q)), such that:1. For each α ∈ (h(q) ∪ {dec(t) | t ∈ bnull(h(q))}), and for each pair of distinct strings t1, t2 ∈ (bnull(α) ∩ bnull(h(q))), t1 (cid:24)F t2or t2 (cid:24)F t1.2. For each t ∈ bnull(h(q)), t = maxF (bnull(dec(ν(t))) ∩ bnull(h(q))). (cid:2)Binary Witness Generator. We proceed to define the notion of binary witness generator. Consider a set (cid:2) ∈ LN over (cid:2), for k ≥ 0, over encodings of atoms, i.e., over {enc(α) | α ∈a schema S. We first need to define the binary relation (cid:25)kB(BC ∪ BN, S)}:• t (cid:25)0• t (cid:25)k(cid:2) u if t = u, or {dec(t)}(cid:17)σ , h(cid:18){dec(t), dec(u)} with (σ , h) being a trigger for (cid:2) on {dec(t)};(cid:2) u if there is v ∈ {enc(α) | α ∈ B(BC ∪ BN, S)} such that dom(dec(t)) ∩ dom(dec(u)) ⊆ dom(dec(v)), and t (cid:25)k−1(cid:2) u.v (cid:25)k−1(cid:2) v and Intuitively, t (cid:25)kdefine the relation (cid:25)k,v(cid:2) , where v ∈ BN, as follows:(cid:2) u means that dec(u) is derivable from dec(t) in at most 2k chase steps using TGDs from (cid:2). We further • t (cid:25)0,v• t (cid:25)k,v(cid:2) u if v ∈ dom(dec(u)) \ dom(dec(t)), and {dec(t)}(cid:17)σ , h(cid:18){dec(t), dec(u)} with (σ , h) being a trigger for (cid:2) on {dec(t)};(cid:2) u if there is w ∈ {enc(α) | α ∈ B(BC ∪ BN, S)} such that dom(dec(t)) ∩ dom(dec(u)) ⊆ dom(dec(w)), and t (cid:25)k−1(cid:2) wand w (cid:25)k−1,vu.(cid:2)Roughly, t (cid:25)k,vin dec(u). Let us clarify that during a chase step {dec(t)}(cid:17)σ , h(cid:18){dec(t), dec(u)} the invented nulls are strings from BN.(cid:2) u means that dec(u) is derivable from dec(t) in at most 2k chase steps using TGDs from (cid:2), and v is invented Definition 4.4 (Binary Witness Generator). Consider a database D over S, a set (cid:2) ∈ LN over S, and a Boolean CQ q over S. A binary k-witness generator, where k ≥ 0, for q w.r.t. D and (cid:2) is a binary witness generator scheme (h, ν, F ) for q such that:1. For each t ∈ root(F ), there exists α ∈ D such that enc(α) (cid:25)k,t2. For each edge (t1, t2) of F , ν(t1) (cid:25)k,t23. For each α ∈ h(q) with t = maxF (bnull(α)), ν(t) (cid:25)k4. For each α ∈ h(q) s.t. bnull(α) = ∅, there is β ∈ D with enc(β) (cid:25)k(cid:2) enc(α).(cid:2) ν(t2).(cid:2) ν(t).(cid:2) enc(α). (cid:2)Note that for a binary witness generator (h, ν, F ) for q w.r.t. D and (cid:2), the range of h is {cτ | c ∈ dom(D)} ∪ BN, and the range of ν is {enc(α) | α ∈ B({cτ | c ∈ dom(D)} ∪ BN, S)}; otherwise, conditions (3) and (4) trivially fail. The next easy lemma, which follows by definition, shows the correspondence between (cid:26)log fLN ((cid:2), q)(cid:27)-witness generators and binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generators.Lemma 4.2. Consider a database D, a set (cid:2) ∈ LN of TGDs, a CQ q(¯x), and a tuple ¯c ∈ dom(D)|¯x|. The following are equivalent:1. There exists a (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2).2. There exists a binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2).4.3. Item (1) of Proposition 4.1We now have all the ingredients for showing Proposition 4.1. We start with the first item, which we recall again here:there is a polynomial-time computable query rewriter f Q : CQ × LN → FO such that, for a database D, (cid:2) ∈ LN, and CQ q, By Lemmas 4.1 and 4.2, it suffices to define f Q in such a way that, given a database D, a set (cid:2) ∈ LN, a CQ q(¯x), and a cert(q, D, (cid:2)) = q(cid:2)(D01) with q(cid:2) = f Q(q, (cid:2)).tuple ¯c, the following are equivalent:1. ¯c ∈ q(cid:2)(D01) with q(cid:2) = f Q(q, (cid:2)).2. There exists a binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2).Consider a set (cid:2) ∈ LN and a CQ q(¯x) both over the schema S = {P 1, . . . , P m}, where m ≥ 1. We proceed to define the first-order query f Q(q, (cid:2)). Henceforth, for brevity, we write ω for ar(S). We also assume that the CQ q(¯x) is of the form22G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936Table 1U, W (possibly with subscripts) and V are τ -tuples of variables that represent terms, while R is an |S|-tuple of variables that represents a predicate. Yi , Ai and Bi are variables of Q.ShortcutU = WU < WDom(U)Null(U)QNull(U)Atom(R, U1, . . . , Uω)U ≺1 WU ≺i+1 WU ≺ WMin(U)Max(U, W1, . . . , Wω)Definition(cid:19)i∈[|U|] (U[i] = W[i])(cid:21)(cid:19)(cid:20)i∈{0,...,|U|−1}j∈{1,...,i} U[ j] = W[ j] ∧Zero(U[i + 1]) ∧ One(W[i + 1]))(cid:19)¬(Zero(u) ∨ One(u))u∈Uu∈U (Zero(u) ∨ One(u)) ∧(cid:20)(cid:19)(cid:2)(cid:20)(cid:5)Null(U) ∧(cid:21)(cid:20)i∈[(cid:9)] U = Yi(cid:19)u∈U One(u)(cid:19)(cid:19)One(R[i]) ∧i∈[m]j∈[ω−ar(P i )] U j = (0)τ ∧j∈{ω−ar(P i )+1,...,ω}j∈[m]\{i} Zero(R[ j]) ∧(cid:5)(cid:22)(cid:2)Dom(U j ) ∨ Null(U j )(cid:2)(cid:20)(cid:5)i∈[(cid:9)−1] U = Ai ∧ W = Bi¬(U = W) ∧∃V (U ≺i V ∧ V ≺1 W)(cid:20)i∈[(cid:9)−1] U ≺i W(cid:5)V∈A U = Vi∈[ω] U = Wii∈[ω](QNull(Wi ) → U = Wi ∨ Wi < U)(cid:5)V∈B U = V(cid:2)(cid:20)(cid:19)∧ ¬(cid:5)(cid:2)(cid:20)(cid:2)(cid:20)∧q(x1, . . . , xk) = ∃ y1 · · · ∃ y(cid:9) (P a1 (¯t1) ∧ · · · ∧ P an (¯tn)).The first-order query q(cid:2) = f Q(q, (cid:2)) is the conjunction of the following three components; let D be the input database on which q(cid:2) will be evaluated:Component 1. Guess a candidate binary witness generator (h, ν, F ) such that, for each i ∈ [k], h(xi) ∈ {cτ | c ∈ dom(D)}.Component 2. Assuming that h(xi) = cτi , for each i ∈ [k], verify that (h, ν, F ) is a binary witness generator scheme for q(¯c), where ¯c = (c1, . . . , ck).Component 3. Finally, verify that (h, ν, F ) is a binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2).Before giving the syntactic shape of the query f Q(q, (cid:2)), let us introduce the variables, and their underlying meaning, that we will use:• For each i ∈ [k], Xi = x1i , . . . , xτi represents the string from {cτ | c ∈ dom(D)} to which the free variable xi of q is mapped to via h.• For each i ∈ [(cid:9)], Yi = y1i , . . . , yτimapped to via h.• For each i ∈ [(cid:9)], Ai = Pi, T1represents the string fromrepresents the string from {cτ | c ∈ dom(D)} ∪ BN to which the variable yi of q is i , . . . , Tωi, where Pi = p1i , . . . , p|S|i, and Tji a τ -tuple of distinct variables, for each j ∈ [ω], {enc(α) | α ∈ B({cτ | c ∈ dom(D)} ∪ BN, S)}to which h( yi) is mapped to via ν whenever h( yi) ∈ BN.• For each i ∈ [(cid:9) − 1], the pair (Ai, Bi), where Ai, Bi are τ -tuples of distinct variables, represents an edge in the rooted forest F over bnull(h(q)). For brevity, we write A and B for the sets {A1, . . . , A(cid:9)−1} and {B1, . . . , B(cid:9)−1}, respectively.We define Q as the set that collects all the variables introduced above apart from the variables x1syntactic shape of q(cid:2) is1, . . . , x1k . The general ∃Q (Triple(Q) ∧ WitnessGeneratorScheme(Q) ∧ WitnessGenerator(Q)) ,where the subquery Triple corresponds to Component 1 discussed above, the subquery WitnessGeneratorScheme to Compo-nent 2, and the subquery WitnessGenerator to Component 3. In what follows, whenever we write Name(Q) we mean that the free variables of the subquery Name are among Q. With the aim of simplifying the definition of q(cid:2), we use some useful shortcuts given in Table 1; as usual, by X[i] we refer to the i-th element of the tuple X. The intuitive meaning of those shortcuts follows:• U = W checks whether the τ -tuples U and W are equal.23G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936• U < W checks whether the binary string of length τ that corresponds to U, which can be seen as a binary number, is strictly less than the binary string (or binary number) that corresponds to W.• Dom(U) checks whether U corresponds to an element of BC. This is done by checking that U does not contain 0 or 1.• Null(U) checks whether U corresponds to an element of BN.• QNull(U) checks whether U corresponds to an element of BN that occurs in the image (via h) of the query, i.e., corre-sponds to a null value and is the image of an existentially quantified variable yi of q.• Atom(R, U1, . . . , Uω) checks whether R, U1, . . . , Uω corresponds to the encoding of some atom, or, in other words, whether it corresponds to an element of {enc(α) | α ∈ B(BC ∪ BN, S)}.• U ≺1 W checks whether (U, W) corresponds to an edge in the forest F .• U ≺i+1 W checks if w is reachable in F from u via a path of length i + 1, assuming that U and W correspond to the strings u and w, respectively.• U ≺ W checks if w is reachable in F from u via some path, assuming that U and W correspond to the strings u and w, respectively. Note that such a path is of length at most (cid:9) − 1 since (cid:9) is the maximum number of strings from BNthat can appear in the image of the query q (there are (cid:9) existentially quantified variables in the query), and thus, the maximum number of nodes in F .• Min(U) checks whether U corresponds to a root node u in F , which boils down to checking that u does not have any incoming edge in F .• Max(U, W1, . . . , Wω) checks whether u corresponds to the greatest element (w.r.t. (cid:24)F ) among w 1, . . . , wω, assuming that U, W1, . . . , Wω correspond to the strings u, w 1, . . . , wω, respectively.We are now ready to define the queries Triple(Q), WitnessGeneratorScheme(Q) and WitnessGenerator(Q), which will give rise to the desired FO query q(cid:2).The Subquery Triple(Q). The goal of this subquery is to perform some consistency checks to ensure that indeed the guessed triple is of the right syntactic form.We first need to ensure that the free variables of q are mapped to strings of {cτ | c ∈ dom(D)}, while the existentially quantified variables are mapped to strings of {cτ | c ∈ dom(D)} ∪ BN. This is achieved via the query VariableConsistency(Q):⎛⎛⎞⎞(cid:23)i∈[k]Dom(Xi) ∧(cid:23)j∈{2,...,τ }x1i= xji∧(cid:23)i∈[(cid:9)]⎝⎝Dom(Yi) ∧(cid:23)j∈{2,...,τ }y1i= yji⎠ ∨ Null(Yi)⎠ .We also need check that the tuples Ai indeed represent strings from {enc(α) | α ∈ B({cτ | c ∈ dom(D)} ∪ BN, S)}, done via the query AtomConsistency(Q):Atom(Ai).(cid:23)i∈[(cid:9)](cid:23)We then check that ν is a (total) function via the query TotalFunction(Q):(cid:2)Null(Yi) ∧ Null(Y j) ∧ Yi = Y j → Ai = A j(cid:5)∧(cid:23)(cid:2)Null(Yi) → Yi = Tωi(cid:5).i, j∈[(cid:9)]i∈[(cid:9)]The above query essentially checks the following: (i) for every two existentially quantified variables yi, y j in q that are mapped via h to the same string from BN, it holds that ν(h( yi)) = ν(h( y j)) (i.e., ν is a function), and (ii) for each existen-tially quantified variable yi in q, if h( yi) ∈ BN, then h( yi) is indeed invented in the atom represented by Ai (i.e., ν is total); recall that Tωiis the last term of Ai that represents h( yi).We check that F is a rooted forest over bnull(h(q)) via the query RootedForest(Q):(cid:23)i∈[(cid:9)−1](QNull(Ai) ∧ QNull(Bi)) ∧(cid:23)i∈[(cid:9)](cid:28)Null(Yi) →(cid:29)(cid:30)Yi = U∧U∈A∪B(cid:23)Ai < Bi ∧(cid:23)(cid:2)Bi = B j → Ai = A j(cid:5).i∈[(cid:9)−1]i, j∈[(cid:9)−1]Recall that the pair (Ai, Bi) represents an edge in F . Hence, the above query checks that (i) the nodes of F are tuples from bnull(h(q)), (ii) each tuple of bnull(h(q)) occurs in F , and (iii) the edges (A1, B1), . . . , (A(cid:9)−1, B(cid:9)−1) indeed form a rooted forest.Consequently, Triple(Q) is defined as the first-order query:VariableConsistency(Q) ∧ AtomConsistency(Q) ∧ TotalFunction(Q) ∧ RootedForest(Q).The Subquery WitnessGeneratorScheme(Q). We now check that the guessed triple represents a binary witness generator scheme for q(¯c), where ¯c = (h(x11), . . . , h(x1k )). But let us first introduce some auxiliary notation.24G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936For each i ∈ [n] (recall that P ai (¯ti) is an atom of q), TTi is defined as the tupleω−ar(Pai )(cid:9)(cid:6)(cid:8)0, . . . , 0(cid:6) (cid:7)(cid:8) (cid:9)τ(cid:7), . . . , 0, . . . , 0(cid:6) (cid:7)(cid:8) (cid:9)τ, f (¯ti[1]), . . . , f (¯ti[ar(P ai )]),wheref (t) =⎧⎨⎩t, . . . , t(cid:6) (cid:7)(cid:8) (cid:9)τt1, . . . , tτif t ∈ C,if t ∈ ¯x ∪ ¯y.Moreover, we defineTTji=⎧⎨⎩0, . . . , 0(cid:6) (cid:7)(cid:8) (cid:9)τf (¯ti[ j])if j ∈ {1, . . . , ω − ar(P ai )},if j ∈ {ω − ar(P ai ) + 1, . . . , ω}.For example, if ω = 4, ¯ti = c, y3, y1, and τ = 2, then TTi = 0, 0, c, c, y1and TT4i1, y2= y11. We are now ready to proceed with the queries that check for the two conditions of Definition 4.3.3, y23, y11, y21, while TT1= 0, 0, TT2i= c, c, TT3iThe first condition “for each α ∈ (h(q) ∪ {dec(ν(t)) | t ∈ bnull(h(q))}), and for each pair of distinct strings t1, t2 ∈ (bnull(α) ∩3, y23= y1ibnull(h(q))), t1 (cid:24)F t2 or t2 (cid:24)F t1” is checked via the query WGS1(Q):(cid:23)(cid:23)(cid:21)i∈[n]j,r∈[ω]Null(TTji ) ∧ Null(TTri ) →(TTji= TTri ) ∨ (TTji≺ TTri ) ∨ (TTri(cid:22)ji )∧≺ TT(cid:23)(cid:23)(cid:21)i∈[(cid:9)]j,r∈[ω]QNull(Tji ) ∧ QNull(Tri ) →(Tji= Tri ) ∨ (Tji≺ Tri ) ∨ (Tri(cid:22)ji ).≺ TThe first conjunction of implications checks that, for each α ∈ h(q), every two distinct strings of bnull(α) are comparable w.r.t. (cid:24)F . The second conjunction of implications takes care of the atoms {ν(t) | t ∈ bnull(h(q))}. In particular, for each such atom α, it checks whether every two distinct strings of bnull(α) are comparable w.r.t. (cid:24)F .The second condition of Definition 4.3, namely “for each t ∈ bnull(h(q)), t = maxF (bnull(dec(ν(t))) ∩ bnull(h(q)))”, is checked via the query WGS2(Q):(cid:2)(cid:23)QNull(Tωi ) → Max(Tωi , T1(cid:5)i , . . . , Tωi ).i∈[(cid:9)]Note that the query WGS2(Q) assumes the following: for each existentially quantified variable yi in q, if h( yi) ∈ BN, then h( yi) is invented in the atom dec(ν(h( yi))), i.e., Yi = Tωi. This is guaranteed by the query TotalFunction(Q) defined above.Hence, WitnessGeneratorScheme(Q) is defined as the first-order queryWGS1(Q) ∧ WGS2(Q).The Subquery WitnessGenerator(Q). We finally check whether the guessed triple (h, ν, F ) is a binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. the input database D and (cid:2), where ¯c = (h(x1k )). Note that the check whether it is a witness generator scheme is taken care by the previous query. Therefore, the remaining task is to check the four conditions given in Definition 4.4.1), . . . , h(x1We assume, for the moment, that we have available the subqueries π and πG . Intuitively speaking, given A, B that represent the strings tA and tB from {enc(α) | α ∈ B({cτ | c ∈ dom(D)} ∪ BN, S)}, respectively,π (A, B) ≡ tA (cid:25)((cid:2),q)(cid:27)(cid:26)log fLN(cid:2)tBandπG (A, B) ≡ tA (cid:25)((cid:2),q)(cid:27),t(cid:26)log fLN(cid:2)tB,where t ∈ BN is the last string of length τ in tB; π and πG are defined below.The first condition of Definition 4.4, namely “for each t ∈ root(F ), there exists α ∈ D such that enc(α) (cid:25)k,t(cid:2) ν(t)”, is checked via the query WG1(Q):25G. Gottlob, M. Manna and A. Pieris(cid:13)(cid:23)QNull(Tωi ) ∧ Min(Tωi ) → ∃p1 . . . ∃pm∃s1 · · · ∃sωArtificial Intelligence 321 (2023) 103936i∈[(cid:9)](cid:29)Atom(p1, . . . , pm, (s1)τ , . . . , (sω)τ ) ∧(cid:13)One(p j) → P j(sω−ar(P j )+1, . . . , sω) ∧j∈[m](cid:14)(cid:14)πG (p1, . . . , pm, (s1)τ , . . . , (sω)τ , Ai).The second condition, namely “for each edge (t1, t2) of F , ν(t1) (cid:25)k,t2(cid:2) ν(t2)”, is checked via the query WG2(Q):(cid:13)(cid:23)i, j∈[(cid:9)]QNull(Tωi ) ∧ QNull(Tωj ) ∧ (Tωi(cid:14)j ) → πG (Ai, A j).≺1 TωThe third condition, i.e., “for each α ∈ h(q) with t = maxF (bnull(α)), ν(t) (cid:25)k(cid:2) enc(α)”, is checked via the query WG3(Q):(cid:13)(cid:23)(cid:23)i∈[n]j∈[(cid:9)]QNull(Tωj ) ∧ Max(Tωj , TTi) → π (A j, 0, . . . , 0(cid:6) (cid:7)(cid:8) (cid:9)ai −1, 1, 0 . . . , 0(cid:6) (cid:7)(cid:8) (cid:9)m−ai, TTi).(cid:14)Finally, the fourth condition, namely “for each α ∈ h(q) s.t. null(α) = ∅, there is β ∈ D with enc(β) (cid:25)k(cid:2) enc(α)”, is checked via the query WG4(Q):(cid:23)(cid:13) (cid:23)i∈[n]j∈[ω]Dom(TTji ) → ∃p1 . . . ∃pm∃s1 · · · ∃sω(cid:29)Atom(p1, . . . , pm, (s1)τ , . . . , (sω)τ ) ∧(cid:13)One(p j) → P j(sω−ar(P j )+1, . . . , sω) ∧j∈[m]π (p1, . . . , pm, (s1)τ , . . . , (sω)τ , 0, . . . , 0(cid:6) (cid:7)(cid:8) (cid:9)ai −1, 1, 0 . . . , 0(cid:6) (cid:7)(cid:8) (cid:9)m−ai(cid:14)(cid:14), TTi).Consequently, WitnessGenerator(Q) is defined as the first-order queryWG1(Q) ∧ WG2(Q) ∧ WG3(Q) ∧ WG4(Q).It remains to define the crucial subqueries π and πG .The Subqueries π and πG . Assume, for the moment, that we have the query πi(A, B, s), where A, B represent the strings (cid:2) tB, with tA and tB from {enc(α) | α ∈ B({cτ | c ∈ dom(D)} ∪ BN, S)}, that states the following: tA (cid:25)it being the last substring of length τ in tB, if s = 1. Then, we define the crucial queries as:(cid:2) tB if s = 0, and tA (cid:25)i,t(cid:21)π (A, B) = ∃sπG (A, B) = ∃sπ(cid:26)log fLN(cid:21)π(cid:26)log fLN(cid:22)((cid:2),q)(cid:27)(A, B, s) ∧ Zero(s)(cid:22)((cid:2),q)(cid:27)(A, B, s) ∧ One(s).Let us now proceed with the formal definition of πi . To this end, given two tuples A, B that represent the strings tA and tB from {enc(α) | α ∈ B({cτ | c ∈ dom(D)} ∪ BN, S)}, we need a way to check whether dec(tB) can be obtained from dec(tA)via a single chase step that uses a linear TGD σ ∈ (cid:2). This is achieved via the subquery "σ (AB, s), where AB denotes the tuple A, B (i.e., the tuple obtained by appending B after A) that has the following meaning: if s = 0, then dec(tB) can be obtained from dec(tA) by applying σ , and if s = 1, then in addition the string of length τ from BN occurring at the last position of dec(tB) is invented in dec(tB). Before giving the formal definition, we need an auxiliary function.Assume that σ is a linear TGD of the formR(tω+2−ar(R), . . . , tω+1) → P (t2ω+3−ar(P ), . . . , t2ω+2).Let Ind = {1, . . . , ω + 1 − ar(R), ω + 2, . . . , 2ω + 2 − ar(P )}. These are the positions in the encodings of body(σ ) and head(σ )where either the encoding of the predicates, or the special string 0τ occurs. In other words, in those positions a non-valid term appears. We can now define the function ξσ : [2ω + 2] → [2ω + 2] as follows:26G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936⎧⎪⎨⎪⎩ξσ (i) =iif i ∈ Ind,if ti /∈ {ti+1, . . . , t2ω+2} \ {t j | j ∈ Ind},iμi otherwise,where μi = min{ j | j ∈ {i + 1, . . . , 2ω + 2} \ Ind and ti = t j}. In words, given the position i of a variable v occurring in σ , ξσ (i) is the next position (from left-to-right) where the same variable v (if any) occurs in σ . For example, assuming that ω = 3 andσ = R(x1, x2) → ∃x3 P (x2, x1, x3),we have that ξσ (1) = 1, ξσ (2) = 2, ξσ (3) = 7, ξσ (4) = 6, ξσ (5) = 5, ξσ (6) = 6, ξσ (7) = 7, and ξσ (8) = 8.We are now ready to define ˆσ . In what follows, A and B should be seen as tuples consisting of ω + 1 tuples, where the first one is of length |S|, while the rest are of length τ , and by A[i] or B[i] we refer to the i-th tuple of A and B, respectively. We also write AB[i] for the i-th tuple of AB. We consider the following two cases where σ contains or not an existentially quantified variable.• If σ contains an existentially quantified variable, then "σ (AB, s) is defined asNull(B[ω + 1]) ∧ (Zero(s) ∨ One(s)) ∧(cid:23)i∈[2ω+2]AB[i] = AB[ξσ (i)] ∧(cid:23)i∈{2,...,ω+1}¬(A[i] = B[ω + 1]).• If σ does not contain an existentially quantified variable, then "σ (AB, s) isZero(s) ∧(cid:23)i∈[2ω+2]AB[i] = AB[ξσ (i)].We now have all the ingredients to define πi . This is done inductively as follows. The query π0(A, B, s) is defined asA = B ∨(cid:29)σ ∈(cid:2)ˆσ (AB, s).Note that the shortcut A = B is not defined in Table 1, but it can be defined in the same way as U = W. Then, πi+1(A, B, s)is defined as∃C (Atom(C) ∧⎛(cid:23)⎝(cid:29)A[i] = B[ j] →i∈{2,...,ω+1}(cid:13)∀D∀E∀s(cid:14)j∈{2,...,ω+1}Atom(D) ∧ Atom(E) ∧(cid:13)(cid:2)⎞A[i] = C[ j]⎠ ∧(cid:29)j∈{2,...,ω+1}D = A ∧ E = C ∧ Zero(s(cid:14)(cid:5))∨(cid:2)D = C ∧ E = B ∧ s = s(cid:14)(cid:5)(cid:14)(cid:14)→ πi(D, E, s(cid:14)).It checks whether there exists a string tC ∈ {enc(α) | α ∈ B({cτ | c ∈ dom(D)} ∪ BN, S)}, represented by C, such that, assuming A, B correspond to the strings tA, tB, respectively, tA (cid:25)2i(cid:2) tC and tC (cid:25)2i(cid:2) tB if s = 1, with t being the last substring of length τ in tB.(cid:2) tB if s = 0, and tC (cid:25)2i ,tThe definition of the query f Q(q, (cid:2)) is now complete. It can be verified that the following technical lemma holds – in fact, it follows by construction – which essentially states the correctness of the query rewriter f Q.Lemma 4.3. Consider a database D, a set (cid:2) ∈ LN of TGDs, a CQ q(¯x), and a tuple ¯c ∈ dom(D)|¯x|hold:. Let q(cid:2) = f Q(q, (cid:2)). The following 1. ¯c ∈ q(cid:2)(D01) iff there exists a binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2).2. q(cid:2) can be computed in polynomial time.By combining Lemmas 4.1, 4.2 and 4.3, we get that there exists a polynomial-time computable query rewriter f Q such that, for every database D, (cid:2) ∈ LN, and CQ q, cert(q, D, (cid:2)) = q(cid:2)(D01) with q(cid:2) = f Q(q, (cid:2)), and item (1) of Proposition 4.1follows.27G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 1039364.4. Item (2) of Proposition 4.1Let us now proceed with the second item of Proposition 4.1, which we recall here:for a family of schemas S of fixed arity, there is a polynomial-time computable query rewriter f SQQ (q, (cid:2)).N , and q ∈ CQ[S], cert(q, D, (cid:2)) = q(cid:2)(D01) with q(cid:2) = f Sthat for every D ∈ D[S], (cid:2) ∈ LS: CQ[S] × LSN→ ∃FO+such By Lemmas 4.1 and 4.2, it suffices to define f SN of TGDs, a CQ q(¯x) ∈ CQ[S], and a tuple ¯c, the following are equivalent; we can assume, without loss of generality, that D, (cid:2), and qare over the same schema S ∈ S that collects all the predicates occurring in D, (cid:2), and q:Q in such a way that, for a database D ∈ D[S], a set (cid:2) ∈ LS1. ¯c ∈ q(cid:2)(D01) with q(cid:2) = f S2. There exists a binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2).Q (q, (cid:2)).Consider a set (cid:2) ∈ LS+∃FON and a CQ q(¯x) ∈ CQ[S], and assume that both (cid:2) and q are over the same schema S ∈ S. The TripleQ (q, (cid:2)) is+query f S(cid:2)∃Q+(Q), where N ∈ {Triple, WitnessGeneratorScheme, WitnessGenerator}, being an adaptation of the query N(Q) defined +(Q), but without with Nin the previous section. In fact, the goal is to convert the FO query N(Q) into an equivalent ∃FOlosing the crucial property that it can be constructed in polynomial time.(Q) ∧ WitnessGeneratorScheme(Q) ∧ WitnessGenerator(cid:5)(Q)query N+++++The Subqueries Triple(Q) and WitnessGeneratorScheme(Q). We first observe that Triple(Q) and WitnessGeneratorScheme(Q)can be transformed in polynomial time into equivalent queries Triplennf(Q) and WitnessGeneratorSchemennf(Q) in negation normal form, that is, the negation operator is only applied to atoms, and the only other allowed Boolean operators are ∧and ∨. It is easy to verify that the only reasons why the obtained queries in negation normal form are not positive are:• expressions of the form ¬(s = s(cid:14)), i.e., inequalities, where the witnesses for the variables s, s(cid:14)can only be 0 and 1 (not constants from the input database), and• atoms of the form ¬Zero(s) or ¬One(s).Since the variables s and sinequalities with the positive expression(cid:2)Zero(s) ∨ Zero(s(cid:14)∧One(s) ∨ One(s(cid:2)(cid:5))(cid:14)(cid:5)).(cid:14)in expressions ¬(s = s(cid:14)) can only take the values 0 and 1, we can simply replace this kind of We can also replace ¬Zero(s) and ¬One(s) with the equivalent positive expressionOne(s) ∨ ADom(s)andZero(s) ∨ ADom(s),respectively, where ADom(s) is a subquery that computes the active domain of the input database, i.e., the set of constants occurring in the input database. More precisely, the query ADom(s) is defined as∃s1 · · · ∃si−1∃si+1 · · · ∃sar(R) R(s1, . . . , si−1, s, si+1, . . . , sar(R)).(cid:29)(cid:29)R∈Si∈[ar(R)]The above replacements in Triplennf(Q) and WitnessGeneratorSchemennf(Q) lead to the positive existential queries Tripleand ProofGeneratorScheme(Q).++(Q)+(Q). We now convert WitnessGenerator(Q) into an equivalent positive existential query The Subquery WitnessGeneratorby applying the following three steps:• We first redefine the subqueries π and πG by relying on a different definition of π(cid:26)log fLN((cid:2),q)(cid:27)(A, B, s). In particular, the query π0(A, B, s) is defined as(cid:29)A = B ∨ˆσ (AB, s),σ ∈(cid:2)which is actually the same as before, and then πi+1(A, B, s) is defined as(cid:13)(cid:14)∃C∃sAtom(C) ∧(cid:23)Null(A[i]) →i∈{2,...,ω+1}⎛(cid:29)⎝A[i] = B[ j] →⎞(cid:29)A[i] = C[ j]⎠ ∧j∈{2,...,ω+1}j∈{2,...,ω+1}(cid:14)πi(A, C, s(cid:14)) ∧ Zero(s(cid:14)) ∧ πi(C, B, s).28G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936Note that during the propagation check we focus on null values (see the expression Null(A[i]) that checks first whether A[i] encodes a null), which in turn guarantees that the equalities used are among variables that can only be instantiated with the values 0 and 1. This can be done without affecting the correctness of the construction since, assuming that tA, tB, tC are the atom encodings represented by A, B and C, respectively, if dec(tC) does not contain a string from BCthat occurs in both dec(tA) and dec(tB), then πi(C, B, s) is trivially evaluated to false. Let WitnessGenerator(cid:15)(Q) be the query defined as WitnessGenerator(Q) but using the new definition of π and πG given above.((cid:2),q)(cid:27)(A, B, s) can be con-Before we proceed further, it is important to stress that, since S is of fixed arity, π(cid:26)log fLN((cid:2),q)(cid:27)(A, B, s) takes structed in polynomial time. Without assuming that the arity is fixed, the construction of π(cid:26)log fLNexponential time. This is precisely the reason why this simpler construction, which avoids the use of universally quan-tified variables, cannot be used in the proof of item (1) of Proposition 4.1.• We now observe that WitnessGenerator(cid:15)(Q) can be transformed into an equivalent query WitnessGeneratornnf(Q) in (cid:14)), where the witnesses for the negation normal form, where the negation operator is only applied to equalities (s = scan only be 0 and 1, and atoms of the form Zero(s) or One(s).variables s, s(cid:14)• We finally convert WitnessGeneratornnf(Q) into the positive existential query WitnessGenerator(cid:14)) with (Zero(s) ∨ Zero(s(cid:14))) ∧ (One(s) ∨ One(s+(Q) by eliminating (cid:14))), ¬Zero(s) with negation as explained above: simply replace ¬(s = sOne(s) ∨ ADom(s), and ¬One(s) with Zero(s) ∨ ADom(s).It is not a difficult task to verify that the following technical lemma holds, which essentially states the correctness of the query rewriter f SQ .Lemma 4.4. Let S be a family of schemas of fixed arity. Consider a database D ∈ D[S], a set (cid:2) ∈ LSand a tuple ¯c ∈ dom(D)|¯x|Q (q, (cid:2)) the following statements hold11:. With q(cid:2) = f SN of TGDs, a CQ q(¯x) ∈ CQ[S], 1. ¯c ∈ q(cid:2)(D01) iff there exists a binary (cid:26)log fLN ((cid:2), q)(cid:27)-witness generator for q(¯c) w.r.t. D and (cid:2)+2. q(cid:2) is an ∃FOquery that can be computed in polynomial time.By Lemmas 4.1, 4.2 and 4.4, we conclude that, for a family of schemas S of fixed arity, there exists a polynomial-+N , and q ∈ CQ[S], time computable query rewriter f S: CQ[S] × LSNQcert(q, D, (cid:2)) = q(cid:2)(D01) with q(cid:2) = f SQ (q, (cid:2)), as needed. This completes the proof of Proposition 4.1.such that, for every D ∈ D[S], (cid:2) ∈ LS→ ∃FO5. Polynomial combined rewritability and guardednessWe now concentrate on the notion of polynomial combined rewritability for guarded TGDs. A family of schemas S is of fixed size if there exists an integer k ≥ 0 such that, for every schema S ∈ S, |S| ≤ k and ar(S) ≤ k. Our goal is to show the following:+Theorem 5.1. For a family of schemas S of fixed size, G[S] is polynomially combined ∃FO-rewritable.Recall that the evaluation problem for ∃FOis in NP. Therefore, an immediate consequence of Theorem 5.1 is the following complexity result, which, as discussed in the Introduction, closes a complexity gap for OQA(G) in the case of schemas of fixed size. In fact, the following result is known for single-head guarded TGDs [17], but it cannot be straightfor-wardly transferred to multi-head guarded TGDs.+Corollary 5.1. OQA(G) is NP-complete for schemas of fixed size.The proof of Theorem 5.1 exploits Proposition 5.1 below, which is the main technical result of this section. It essentially provides a polynomial-time combined reduction from ontological query answering under guarded TGDs over schemas of fixed size, to ontological query answering under linear TGDs over schemas of fixed arity. Before introducing Proposition 5.1, we need some auxiliary notions.A TGD rewriter is a function that takes as input a set of TGDs and outputs a set of TGDs. For families of schemas S and , we say that G[S] is polynomially combined reducible to L[S(cid:14)], written G[S] ≤pc L[S(cid:14)], if there existS(cid:14)• a polynomial-time computable database rewriter f SDB• a polynomial-time computable TGD rewriter f ST• a polynomial-time computable query rewriter f SQ: D[S] × G[S] → D[S(cid:14)],: G[S] → L[S(cid:14)], and: CQ[S] × G[S] → CQ[S(cid:14)],11 We assume, without loss of generality, that D, (cid:2), and q are over the same schema S ∈ S.29G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936such that, for every D ∈ D[S], (cid:2) ∈ G[S], and q ∈ CQ[S], it holds that cert(q, D, (cid:2)) = cert( f SWe show the following:Q (q, (cid:2)), f SDB(D, (cid:2)), f ST ((cid:2))). Proposition 5.1. For a family of schemas S of fixed size, there is a family of schemas S(cid:14)of fixed arity such that G[S] ≤pc L[S(cid:14)].Observe that polynomial combined ∃FO-rewritability is closed under ≤pc. Since, by Theorem 4.1, L[S(cid:14)] is polynomially -rewritable, Proposition 5.1 immediately implies Theorem 5.1. The rest of the section is devoted to showing ++combined ∃FOProposition 5.1. This is done in three main steps:1. We define the database, TGD and query rewriters f S2. We then establish their correctness, that is, for every D ∈ D[S], (cid:2) ∈ G[S], and q ∈ CQ[S], cert(q, D, (cid:2)) =Q , respectively.T and f SDB, f Scert( f SQ (q, (cid:2)), f S3. We finally show that f SDB(D, (cid:2)), f SDB, f ST ((cid:2))).T and f SQ are polynomial-time computable.Before proceeding with the above three steps, we first need to introduce a notion that is central when reasoning with guarded TGDs, known as the type of an atom. This notion will play an important role in all of the above steps.5.1. Guarded typesConsider a database D and a set (cid:2) ∈ G. Let δ = (Ii)i≥0 be a (finite or infinite) chase derivation of D w.r.t. (cid:2) with Ii(cid:17)σi, hi(cid:18)Ii+1. Given an atom α ∈ chaseδ(D, (cid:2)), its δ-type (w.r.t. D and (cid:2)), is the set of atomstypeδ(α) = {β ∈ chaseδ(D, (cid:2)) | dom(β) ⊆ dom(α)}that collects all the atoms in the result of δ that mention only terms occurring in α. The key property of the type has been shown in [17] for single-head guarded TGDs, and it can be easily extended to multi-head guarded TGDs. It roughly states that the set of atoms in chaseδ(D, (cid:2)) that can be derived from α (used as a guard) is determined by its δ-type. To make this precise we need some auxiliary notions.δ , is a binary relation on chaseδ(D, (cid:2)) such that α ≺gpThe guarded parent relation of δ, denoted ≺gpδ β iff there exists i ≥ 0with α = hi(guard(σi)) and β ∈ Ii+1 \ Ii . Let ≺gp,+forms a forest with the atoms of D being the roots. We can now define the notion of projection of δ, which will allow us to state the key property of the type. Consider an atom α ∈ chaseδ(D, (cid:2)), and let (i j) j>0 be the sequence of indices with 0 ≤ i1 < i2 < i3 < · · ·such that, for each (cid:9) ≥ 0, (cid:9) ∈ {i j} j>0 iff h(cid:9)(guard(σ(cid:9))) = α or α ≺gp,+h(cid:9)(guard(σ(cid:9))). Simply stated, (i j) j>0 collects all the applications in δ, in ascending order, that use α or a ≺gpδ -descendant of α as the guard. The α-projection of δ, denoted δ[α], is the sequence of instances ( J i)i≥0, with J 0 = typeδ(α), and, for each j > 0,be the transitive closure of ≺gpδ . Note that ≺gpδδδ(cid:17)J j = J j−1 ∪β ∈ Ii j +1 | hi j (guard(σi j )) ≺gpδ β(cid:18).We can now state the key property of the notion of type, which relies on guardedness:Lemma 5.1. Consider a database D and a set (cid:2) ∈ G. For a chase derivation δ of D w.r.t. (cid:2) and an atom α ∈ chaseδ(D, (cid:2)), δ[α] is a chase derivation of typeδ(α) w.r.t. (cid:2).Proof. Let δ = (Ii)i≥0 with Ii(cid:17)σi, hi(cid:18)Ii+1. By definition, δ[α] = ( J i)i≥0, with J 0 = typeδ(α), and, for each j > 0,(cid:18)(cid:17)J j = J j−1 ∪β ∈ Ii j +1 | hi j (guard(σi j )) ≺gpδ β,where (i j) j>0 is the sequence of indices, with 0 ≤ i1 < i2 < i3 < · · · such that, for each (cid:9) ≥ 0, (cid:9) ∈ {i j} j>0 iff h(cid:9)(guard(σ(cid:9))) =α or α ≺gp,+h(cid:9)(guard(σ(cid:9))). We proceed to show the following three statements, which in turn imply that δ[α] is a chase derivation of typeδ(α) w.r.t. (cid:2), as needed:δ1. For each j > 0, J j−1(cid:17)σi j , hi j2. For j, k > 0 such that j (cid:3)= k, (σi j , hi j ) (cid:3)= (σik , hik ).3. For each j ≥ 0, and for every trigger (σ , h) for (cid:2) on J j , there exists k ≥ j such that (σ , h) = (σik+1 , hik+1 ).(cid:18) J j .Item (1) is a consequence of the following observations, which in turn hold due to the fact that (cid:2) is guarded; for brevity, for a guarded TGD σ , we write side(σ ) for the side atoms of σ , i.e., the set of atoms body(σ ) \ {guard(σ )}:• hi1 (side(σi1 )) ⊆ typeδ(α).• For each j > 1, hi j (side(σi j )) ⊆ typeδ(α) ∪ {β ∈ Ii j−1+1 | α ≺gp,+δβ}.30G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936Items (2) and (3) hold since, by hypothesis, δ is a chase derivation. Indeed, by contradiction, if (2) (resp. (3)) does not hold, then δ applies a certain trigger more than once (resp., is not fair), which contradicts the fact that it is a chase derivation. (cid:2)With the notion of type in place, we are now ready to proceed with the proof of Proposition 5.1. In the rest of the section, let S be a family of schemas of fixed size.5.2. The database, TGD and query rewritersBefore we define the desired rewriters, we first need to introduce some auxiliary technical notions that are crucial for the definitions.Auxiliary Notions. We need to encode the equality type of a guard atom (i.e., which of its positions mention the same term), as well as the equality type of the atoms occurring in the type of such a guard. This is done via the notion of S-type, where S is a schema. The equality type of an atom can be encoded via an atom that mentions only integer values. For example, the equality type of R(a, b, a, c) can be encoded via the atom R(1, 2, 1, 3). Formally, an S-type τ is a pair (α, T ), where α = R(t1, . . . , tn), R ∈ S, t1 = 1, ti ∈ {t1, . . . , ti−1, ti−1 + 1} for i ∈ {2, . . . , n}, and T ⊆ B({t1, . . . , tn}, S) \ {α}. We write guard(τ ) for the atom α, atoms(τ ) for the set of atoms ({α} ∪ T ), and ar(τ ) for the maximum integer occurring in guard(τ ). for the schema S ∪ {[τ ] | τ is an S-type}, where [τ ] is a new predicate not in S of arity ar(τ ); it is clear We further write Sthat ar(S) = ar(Sis of fixed arity since S is of fixed size (and thus, of fixed arity). We say that a tuple ¯u = (u1, . . . , un) is isomorphic to ¯t = (t1, . . . , tn), written ¯u (cid:11) ¯t, if ui = u j iff ti = t j . Given a tuple ¯u such that ¯u (cid:11) ¯t, the instantiation of τ with ¯u, denoted τ ( ¯u), is the set of atoms obtained from atoms(τ ) after replacing ti with ui . The projection of τ over P ⊆ {1, . . . , ar(τ )} is+). The family of schemas S++ | S ∈ S}. It is clear that S+is defined as {S+(cid:19)P (τ ) = {β ∈ atoms(τ ) | dom(β) ⊆ P }.The completion of an instance I over S w.r.t. a set of TGDs (cid:2) over S is the instancecomplete(I, (cid:2)) = {R( ¯u) | R ∈ S and ¯u ∈ cert(R(¯x), I, (cid:2))},where ¯u = (u1, . . . , un) and ¯x = (x1, . . . , xn). Note that the completion of an instance w.r.t. a set of TGDs relies on the notion of certain answers. At first glance, this might seem circular since we are trying to devise a machinery for computing certain answers via the combined approach to FO-rewritability. However, the definition of completion only needs to compute the certain answers of atomic full queries, that is, CQs consisting of a single atom without existentially quantified variables, which is a much simpler task. Further details on the problem of computing the certain answers to atomic full queries, known as instance checking, are given in Section 5.4, where the polynomial-time computability of the rewriters is shown.The Database Rewriter. Given a database D ∈ D[S] and a set (cid:2) ∈ G[S], and assuming that both D and (cid:2) are over a schema S ∈ S,DB(D, (cid:2)) =f S⎧⎨⎩[τ ](¯c)$$$$$$R(¯c) ∈ Dτ is an S-type of the from (R(¯t), T ) with ¯c (cid:11) ¯tτ (¯c) ⊆ complete(D, (cid:2))⎫⎬⎭ .It is clear that f Sof the database rewriter introduced above follows.DB is a database rewriter of the form D[S] × G[S] → D[S+]. A simple example that illustrates the notion Example 5.1. Let S = {P , Q , R, S, T } ∈ S. Consider the databaseD = {R(a, a, b, c)}over S and the set (cid:2) of guarded TGDs over S consisting ofσ = P (x, y, x, u, w), S(x, u) → ∃z1∃z2 R(u, y, x, z1), T (z1, z2, x),σ (cid:14) = R(x, x, y, z) → Q (x, z).It is clear that the pairτ = (R(1, 1, 2, 3), {Q (1, 3)})is an S-type with (a, a, b, c) (cid:11) (1, 1, 2, 3), and there is no other such S-type. Moreover, it is easy to verify that{R(a, a, b, c), Q (a, c)} ⊆ complete(D, (cid:2)),which in turn implies that f SR(a, a, b, c) and its type. (cid:2)DB(D, (cid:2)) = {[τ ](a, a, b, c)}. In simple words, [τ ](a, a, b, c) is a compact encoding of the guard 31G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936The TGD Rewriter. Given a set (cid:2) ∈ G[S] over a schema S ∈ S, f ST ((cid:2)) is defined as the union of the sets of linear TGDs (cid:2)tg and (cid:2)ex, where• (cid:2)tg is the so-called type generator, which is responsible for generating new S-types from existing ones, and• (cid:2)ex is the so-called expander, which is responsible for expanding a derived S-type τ , i.e., it explicitly constructs the atoms over S encoded by τ .The type generator is defined as follows. For each σ ∈ (cid:2)ϕ(¯x, ¯y) → ∃z1 · · · ∃zm R1( ¯u1), . . . , Rn( ¯un)with guard(σ ) = G( ¯u) and (¯x ∪ {zi}i∈[m]) being the variables occurring in head(σ ), and for every S-type τ such that there is a homomorphism h from ϕ(¯x, ¯y) to atoms(τ ) and h(G( ¯u)) = guard(τ ), we add to (cid:2)tg the linear TGD[τ ]( ¯u) → ∃z1 · · · ∃zm [τ1]( ¯u1), . . . , [τn]( ¯un),where, for each i ∈ {1, . . . , n}, [τi] is defined as follows. Let f be the function from the variables in head(σ ) to the natural numbers such that(cid:12)f (t) =h(t)ar(S) + iif t ∈ ¯x,if t = zi.With ¯ui = (u1i , . . . , uar(R i )i) and αi = R i( f (u1i ), . . . , f (uar(R i )i)), we define the setT i = {β ∈ complete(I, (cid:2)) | dom(β) ⊆ dom(αi)} \ {αi}withI = {α1, . . . , αn} ∪ (cid:19){h(x)|x∈¯x}(τ ).Note that (αi, T i) is not a proper S-type since the integers in atoms do not appear in the correct order. Let ρ be the renaming function that renames the integers in atoms in order to appear in increasing order starting from 1 (e.g., ρ(R(2, 2, 4, 1)) = R(1, 1, 2, 3); the formal definition is omitted since it is clear what the function ρ does). We then define τi as the S-type (ρ(αi), ρ(T i)).The expander constructs the guard atom of τ , for each S-type τ . To this end, for each S-type τ , we add to (cid:2)ex the linear TGD[τ ](x1, . . . , xk) → R(x1, . . . , xk),where R is the k-ary predicate of guard(τ ). It is clear that f Ssimple example that illustrates the notion of the TGD rewriter introduced above follows.T is indeed a TGD rewriter of the form G[S] → L[S+]. A Example 5.2. Let (cid:2) = {σ , σ (cid:14)} be the set of guarded TGDs given in Example 5.1. Consider the S-typeτ = (P (1, 2, 1, 2, 3), {S(1, 2), S(1, 1)}).It is easy to verify that h = {x → 1, y → 2, u → 2, w → 3} is a homomorphism from body(σ ) to atoms(τ ) = {P (1, 2, 1, 2, 3),S(1, 2), S(1, 1)} and h(P (x, y, x, u, w)) = P (1, 2, 1, 2, 3). Therefore, the linear TGD[τ ](x, y, x, u, w) → ∃z1∃z2 [τ1](u, y, x, z1), [τ2](z1, z2, x)withτ1 = (R(1, 1, 2, 3), {S(2, 1), S(2, 2), Q (1, 3)})belongs to the type generator (cid:2)tg. Moreover, the linear TGDsandτ2 = (T (1, 2, 3), ∅)[τ ](x1, . . . , x5) → P (x1, . . . , x5),[τ1](x1, . . . , x4) → R(x1, . . . , x4),[τ2](x1, x2, x3) → T (x1, x2, x3)belong to the expander (cid:2)ex. (cid:2)The Query Rewriter. Due to the expander (cid:2)ex defined above, which explicitly constructs the atoms over the original schema S ∈ S encoded by an S-type τ , we can leave the query untouched. In other words, for q ∈ CQ[S] and (cid:2) ∈ G[S],f SQ (q, (cid:2)) = q.32G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 1039365.3. Correctness of the rewritersWe now proceed to establish the correctness of the database, TGD and query rewriters defined above. In fact, we need to show the following:Lemma 5.2. Consider a database D ∈ D[S], a set (cid:2) ∈ G[S] of TGDs, and a CQ q ∈ CQ[S]. It holds that cert(q, D, (cid:2)) =cert(q, f SDB(D, (cid:2)), f ST ((cid:2))).The proof of Lemma 5.2 relies on the following technical lemma; in fact, Lemma 5.2 is an immediate consequence of Lemma 5.3 shown below. We say that two instances I, J are homomorphically equivalent if I → J and J → I . We also write I|S for the restriction of I over a schema S, i.e., the set of atoms {R(¯t) ∈ I | R ∈ S}. For brevity, we simply write D(cid:15) and (cid:2)(cid:15)for f SDB(D, (cid:2)) and f ST ((cid:2)), respectively.Lemma 5.3. Consider a database D ∈ D[S] and a set (cid:2) ∈ G[S] both over S ∈ S. Let δ be a chase derivation of D w.r.t. (cid:2) and δ(cid:14)chase derivation of D(cid:15) w.r.t. (cid:2)(cid:15). It holds that chaseδ(D, (cid:2)) and chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15))|S are homomorphically equivalent.be a Proof. We first need to establish two auxiliary technical results that reveal the relationship between chaseδ(D, (cid:2)) and chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)). For an atom α ∈ chaseδ(D, (cid:2)), let γα be the function that renames the arguments of α into integers in an increasing order; e.g., if α = R(a, ⊥, a, b), then γα(α) = R(1, 2, 1, 3). The definition of γα is obvious and is omitted. We α for the S-type (γα(α), γα(typeδ(α) \ {α})). We are now ready to present and show the first auxiliary technical also write τ δresult.Lemma 5.4. Let δ be a chase derivation of D w.r.t. (cid:2) and δ(cid:14)that R(¯t) ∈ chaseδ(D, (cid:2)) implies [τ δ](h(¯t)) ∈ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)).R(¯t)be a chase derivation of D(cid:15) w.r.t. (cid:2)(cid:15). There is a homomorphism h such Proof. Assume that δ = (Ii)i≥0. We show by induction that, for each k ≥ 0, there is hk such that R(¯t) ∈ Ik implies ](hk(¯t)) ∈ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)), whereas, for k > 0, hk is compatible with hk−1. This implies that the claim holds with [τ δR(¯t)(cid:11)h =i≥0 hi .Base Case. Consider an atom R(¯t) ∈ I0 = D. By construction, [τ δ](¯t) ∈ D(cid:15). Since D(cid:15) ⊆ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)), the claim follows R(¯t)with h0 being the identity on dom(D).Inductive Step. Assume now that R(¯t) has been generated during the k-the step for k > 0, i.e., R(¯t) ∈ Ik \ Ik−1. Assume also that Ik−1(cid:17)σ , μ(cid:18)Ik with (σ , μ) being a trigger for (cid:2) on Ik−1; let σ be of the formϕ(¯x, ¯y) → ∃z1 · · · ∃zm R1( ¯u1), . . . , Rn( ¯un)with guard(σ ) = G( ¯u), and (¯x ∪ {zi}i∈[m]) be the variables occurring in head(σ ). Clearly, μ is a homomorphism that maps ϕ(¯x, ¯y) to Ik−1, and Ik = Ik−1 ∪ μ(cid:14)(head(σ )). By the induction hypothesis, we conclude that[τ δG(μ( ¯u))](hk−1(μ( ¯u))) ∈ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)).Observe that (γG(μ( ¯u)) ◦ μ) maps ϕ(¯x, ¯y) to atoms(τ δtion, (cid:2)(cid:15) contains a linear TGD σL of the formG(μ( ¯u))) with γG(μ( ¯u))(μ(G( ¯u))) = guard(τ δG(μ( ¯u))). Therefore, by construc-[τ δG(μ( ¯u))]( ¯u) → ∃z1 · · · ∃zm [τ1]( ¯u1), . . . , [τn]( ¯un).Furthermore, by Lemma 5.1, we can conclude that, for each i ∈ [n], τi = τ δto chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)). Therefore, there exists an extension λ(cid:14)R i(μ(cid:14)( ¯ui)) for some i ∈ [n], we conclude that [τ δ](λ(cid:14)( ¯ui)) ∈ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)). LetR i (μ(cid:14)( ¯ui )). Observe that λ = hk−1 ◦ μ maps body(σL)of λ that maps {[τi]( ¯ui)}i∈[n] to chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)). Since R(¯t) =R( ¯y)hk = hk−1 ∪ {μ(cid:14)(zi) → λ(cid:14)(zi)}i∈[m];note that, if σ has no existentially quantified variables, then hk = hk−1. It is clear that hk is well-defined since none of the μ(cid:14)(z1), . . . , μ(cid:14)(zm) occurs in the domain of hk−1. It is also easy to verify that [τ δ](λ(cid:14)( ¯ui)) ∈chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)). (cid:2)](hk(¯t)) = [τ δR(¯t)R(¯t)We now proceed with the second technical claim needed for establishing Lemma 5.3. Let us note that, by construction, if [τ ](¯t) ∈ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)), where guard(τ ) = R( ¯u), then ¯t (cid:11) ¯u. This means that, given an atom [τ ](¯t) ∈ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)), we can always refer to the instantiation of τ with ¯t, i.e., τ (¯t) is well-defined.Lemma 5.5. Let δ be a chase derivation of D w.r.t. (cid:2) and δ(cid:14)that [τ ](¯t) ∈ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15)) implies h(τ (¯t)) ⊆ chaseδ(D, (cid:2)).be a chase derivation of D(cid:15) w.r.t. (cid:2)(cid:15). There is a homomorphism h such 33G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936Proof. Assume that δ(cid:14) = (Ii)i≥0. We show by induction that, for each k ≥ 0, there exists hk such that [τ ](¯t) ∈ Ik implies hk(τ (¯t)) ⊆ chaseδ(D, (cid:2)), whereas, for k > 0, hk is compatible with hk−1. This implies that the claim holds with h =i≥0 hi .Base Case. Consider [τ ](¯t) ∈ I0 = D(cid:15). By construction, τ (¯t) ⊆ complete(D, (cid:2)). Since complete(D, (cid:2)) ⊆ chaseδ(D, (cid:2)), h0 is (cid:11)the identity on dom(D).Inductive Step. Assume now that [τ ](¯t) has been generated during the k-th step for k > 0, i.e., [τ ](¯t) ∈ Ik \ Ik−1. Assume also that Ik−1(cid:17)σ , μ(cid:18)Ik with (σ , μ) being a trigger for (cid:2)(cid:15) on Ik−1; let σ be of the form[τ ]( ¯u) → ∃z1 · · · ∃zm [τ1]( ¯u1), . . . , [τn]( ¯un).Clearly, μ is a homomorphism that maps [τ (cid:14)]( ¯u) to Ik−1, and Ik = Ik−1 ∪ μ(cid:14)(head(σ )). By the induction hypothesis, we conclude thathk−1(τ (cid:14)(μ( ¯u))) ⊆ chaseδ(D, (cid:2)).By construction, there exists a TGD σG ∈ (cid:2) of the formϕ(¯x, ¯y) → ∃z1 · · · ∃zm R1( ¯u1), . . . , Rn( ¯un)with guard(σ ) = G( ¯u) such that ϕ(¯x, ¯y) is mapped to atoms(τ (cid:14)) via a homomorphism λ, while λ(G( ¯u)) = guard(τ (cid:14)). Clearly, there is an isomorphism γ from atoms(τ (cid:14)) to τ (cid:14)(μ( ¯u)), which implies that μ = γ ◦ λ. Thus, ν = hk−1 ◦ μ maps ϕ(¯x, ¯y)to chaseδ(D, (cid:2)). Therefore, there is an extension ν(cid:14)of ν that maps {R i( ¯ui)}i∈[n] to chaseδ(D, (cid:2)). By Lemma 5.1, we can conclude that, for i ∈ [n], τi = τ δR i (ν(cid:14)( ¯ui )). Lethk = hk−1 ∪ {μ(cid:14)(zi) → ν(cid:14)(zi)}i∈[m];note that if σ has no existentially quantified variables, then hk = hk−1. It is clear that hk is well-defined since none of the μ(cid:14)(z1), . . . , μ(cid:14)(zm) occurs in the domain of hk−1. It is also easy to verify that hk(τ (¯t)) = τi(ν(cid:14)( ¯ui)) for some i ∈ [n]. Sinceτi(ν(cid:14)( ¯ui)) = typeδ(R i(ν(cid:14)( ¯ui))) ⊆ chaseδ(D, (cid:2)),we conclude that hk(τ (¯t)) ⊆ chaseδ(D, (cid:2)), and the claim follows. (cid:2)Having Lemmas 5.4 and 5.5 in place, we can now conclude the proof of Lemma 5.3. We first show thatchaseδ(D, (cid:2)) → chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15))|S.Let h be the homomorphism provided by Lemma 5.4. Due to the expander in (cid:2)(cid:15), that is, the set of TGDs of the form [τ ](¯x) → R(¯x), where τ is an S-type and R ∈ S, we can conclude that, for each atom R(¯t) ∈ chaseδ(D, (cid:2)), R(h(¯t)) ∈chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15))|S. Therefore, h(chaseδ(D, (cid:2))) ⊆ chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15))|S, as needed.We finally show thatchaseδ(cid:14) (D(cid:15), (cid:2)(cid:15))|S → chaseδ(D, (cid:2)).Let h be the homomorphism provided by Lemma 5.5. It is clear that⎞⎛(⎝h[τ ](¯t)∈chaseδ(cid:14) (D(cid:15),(cid:2)(cid:15))Since, by construction,chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15))|S ⊆τ (¯t)⎠ ⊆ chaseδ(D, (cid:2)).(τ (¯t),[τ ](¯t)∈chaseδ(cid:14) (D(cid:15),(cid:2)(cid:15))we get that h(chaseδ(cid:14) (D(cid:15), (cid:2)(cid:15))|S) ⊆ chaseδ(D, (cid:2)), and the claim follows. (cid:2)As already said, Lemma 5.2, which establishes the correctness of the database, TGD and query rewriters defined above, is an immediate consequence of Lemma 5.3.34G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 1039365.4. Polynomial-time computability of the rewritersWe finally proceed to establish that the rewriters defined above are polynomial-time computable. Actually, we only need to concentrate on the database and TGD rewriters since the query rewriter f SQ is trivially computable in polynomial time. Let us recall that the family of schemas S is of fixed size, that is, for every schema S ∈ S, |S| and ar(S) are bounded by some integer. This is crucial for the validity of the next lemma:Lemma 5.6. The functions f SDB and f ST are polynomial-time computable.Observe that the definitions of both f ST heavily rely on instance checking, which is a simpler version of on-tological query answering where the query is an atomic full query, that is, a single atom without existentially quantified variables. Indeed, the notion of completion, which is used in the definitions of f ST , exploits instance checking. Therefore, to show Lemma 5.6, we first need to pinpoint the complexity of instance checking defined as follows; let C a class of TGDs:DB and f SDB and f SPROBLEM :INPUT :QUESTION :IC(C)A database D, a set (cid:2) ∈ C, a CQ R(¯x), and ¯c ∈ dom(D)ar(R).Does ¯c ∈ cert(R(¯x), D, (cid:2))?It is clear that an S-type, for a schema S ∈ S, depends only on S. Since S is of fixed size, only a constant number of S-types for schemas S ∈ S can be formed that can be constructed in constant time. This implies that, if instance checking for G[S] is feasible in polynomial time, then Lemma 5.6 follows, which, together with Lemma 5.2, establishes Proposition 5.1. The rest of the section is devoted to showing the following:Lemma 5.7. IC(G[S]) is in PTime.Before we proceed further, let us clarify that the above result has been shown in [17] assuming single-head guarded TGDs, i.e., TGDs with only one atom in the head, via a sophisticated alternating algorithm that uses logarithmic space. However, the result from [17] cannot be straightforwardly transferred to multi-head guarded TGDs with an arbitrary con-junction of atoms in the head. The fact that we need to directly deal with multi-heads causes non-trivial complications that require novel ideas. Those complications were not an issue for single-head TGDs. To better understand the different nature of the two settings, let us stress that in the case of single-head guarded TGDs, by fixing the size of the underlying schema we implicitly fix the whole set of TGDs. Indeed, the number of different guarded non-isomorphic TGD-bodies that can be formed over a schema of fixed size is constant, which in turn implies that we can only have a constant number of different single-head guarded TGDs (up to variable renaming). This is not true for multi-head guarded TGDs since we can have an unbounded number of different TGDs with the same guarded body due to the unguarded multi-heads.We now establish Lemma 5.7 via a novel alternating algorithm that is designed to directly operate on multi-head guarded TGDs. But first we need an auxiliary result.Pivotal Atoms. Our alternating algorithm exploits the existence of some special atoms, called pivotal, for guarded subsets of the result of a derivation. Roughly, to check if a guarded set of atoms Q is in the result of some chase derivation δ, it suffices to check whether Q is in the result of the α-projection of δ with α being a pivotal atom for Q .Consider a database D and a set of TGDs (cid:2) ∈ G, both over a schema S. A finite set Q ⊆ B(C ∪ N, S) is guarded if there is α ∈ Q such that dom(α) = dom(Q ). We say that Q is ungrounded if each of its atoms contains at least one null of N. Consider now a chase derivation δ = (Ii)i≥0 of D w.r.t. (cid:2) with Ii(cid:17)σi, hi(cid:18)Ii+1 and a set of atoms Q ⊆ B(C ∪ N, S) that is guarded and ungrounded. An atom α is called δ-pivotal for Q if α = hi(guard(σi)), for some i ≥ 0, such that null(Q ) (cid:4)dom(Ii), while null(Q ) ⊆ dom(Ii+1). In simple words, a δ-pivotal atom for Q is an atom of chaseδ(D, (cid:2)) in which the nulls in Q occur together for the first time according to δ. The key lemma concerning pivotal atoms follows:Lemma 5.8. Consider a database D and a set of TGDs (cid:2) ∈ G, both over a schema S. Let δ be a chase derivation of D w.r.t. (cid:2) and Q ⊆ B(C ∪ N, S) be a guarded and ungrounded set of atoms. The following are equivalent:1. Q ⊆ chaseδ(D, (cid:2)).2. There exists exactly one δ-pivotal atom α ∈ chaseδ(D, (cid:2)) for Q such that Q ⊆ chaseδ[α](typeδ(α), (cid:2)).Proof. Clearly, (2) ⇒ (1) since chaseδ[α](typeδ(α), (cid:2)) ⊆ chaseδ(D, (cid:2)); δ[α] is a chase derivation of typeδ(α) w.r.t. (cid:2) due to Lemma 5.1. It remains to show (1) ⇒ (2). Let γ ∈ Q be the atom that contains all the terms of dom(Q ) and α, β ∈ chaseδ(D, (cid:2)) be atoms such that α ≺gpγ , null(α) (cid:4) null(β), and null(β) ⊆ null(γ ). By guardedness, we conclude that α is the δ-pivotal atom for Q , and, for each α(cid:14) ∈ Q , it holds that α ≺gp,+or α(cid:14) ∈ typeδ(α). Hence, Q ⊆ chaseδ[α](typeδ(α), (cid:2)). (cid:2)δ β, β ≺gp,+α(cid:14)δδ35G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936We now have all the ingredients that are needed for introducing our new alternating algorithm, which will lead to the desired complexity result stated in Lemma 5.7.Algorithm 1: Instance Checking.Entail(D, (cid:2), R(¯x), ¯c)if R(¯c) ∈ D thenreturn Acceptelseguess σ ∈ (cid:2) and h : dom(body(σ )) → dom(D) ∪ (cid:23)(cid:15)(cid:2)if R(¯c) /∈ h(head(σ )) thenreturn Rejectelsereturn Proof(h(body(σ )))Proof(Q )(cid:17)(cid:18)R(¯c) ∈ Q | ¯c ∈ Car(R)(cid:14))(cid:14) := Q \QN := null(Quniversally do:! universally select every atom R(¯c) ∈ Q \ Q(cid:14)return Entail(D, (cid:2), R(¯x), ¯c)! if N = ∅ thenreturn Acceptelseguess (D, (cid:2))-step (σ , h, s, T ) for s(cid:2)(σ , h)if N ⊆ null(h(guard(σ ))) or N (cid:3) {s1, . . . , s(cid:9)σ } thenreturn Rejectelseuniversally do:! universally select every atom β ∈ Qreturn Reach(σ , h, s, T , β)! return Proof(T )Reach(σ , h, s, T , β)guess an atom α ∈ (cid:2)σ , h, s(cid:3)if α = β thenreturn AcceptelseS := s(cid:2)(σ , h) ∪ {s} ∪ s(cid:2)(null(β))guess (D, (cid:2))-step (σ (cid:14), h(cid:14), T(cid:14), s(cid:14)(guard(σ (cid:14))) (cid:3)= α thenif hreturn Reject(cid:14)) for Selseuniversally do:! return Reach(σ (cid:14), h! universally select every atom β(cid:14) ∈ T(cid:14), β)(cid:14), T(cid:14), sreturn Reach(σ , h, s, T , β(cid:14))(cid:14) \ T(cid:14) \ TThe Alternating AlgorithmConsider a database D, a set (cid:2) of guarded TGDs, a CQ R(¯x), and a tuple ¯c ∈ dom(D)ar(R). We assume that D, (cid:2), and R(¯x) are over a schema S ∈ S. Checking whether ¯c ∈ cert(R(¯x), D, (cid:2)) boils down to checking whether R(¯c) ∈ chaseδ(D, (cid:2))for some chase derivation δ of D w.r.t. (cid:2). Lemma 5.8 suggests the following strategy for the latter task: find σ ∈ (cid:2) and a function h from the variables in body(σ ) to dom(D) ∪ N such that R(¯c) ∈ h(head(σ )), and check whether there exists a δ-pivotal atom for the ungrounded subset of h(body(σ )), for some chase derivation δ of D w.r.t. (cid:2), while for each ground atom in h(body(σ )) recursively apply the above. Our alternating algorithm, which is described in detail next, performs the above steps in parallel universal computations, which ensures that only logarithmic space is needed. Recall that polynomial time coincides with alternating logarithmic space [26].Some Preparation. We first introduce some auxiliary notions. Since we can use only logarithmic space, we cannot ex-plicitly store all the atoms generated via a single chase step since we deal with unguarded multi-heads; note that this could be possible in the case of single-head TGDs. Therefore, we need a way to compactly represent such a set of atoms, while such a representation should take only logarithmic space. This is done via a so-called (D, (cid:2))-step, which is a compact representation of the guard atom of a chase step, together with its type, and the atoms that are generated via this chase step.Let (cid:23)(cid:2) = {⊥1, . . . , ⊥2·(ar((cid:2))+1)} be the set that collects all the different sorts of nulls that are needed to perform our = {s j | s ∈check using a bounded number of nulls, which in turn will ensure that we use only logarithmic space. Let (cid:23)(cid:15)(cid:2)36G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936(cid:23)(cid:2)} j∈[(cid:9)(cid:2)] ⊆ N, where (cid:9)(cid:2) = maxσ ∈(cid:2){(cid:9)σ } with (cid:9)σ being the number of existential variables in σ . A (D, (cid:2))-step for a set S (cid:5) (cid:23)(cid:2) is a tuple (σ , h, s, T ), where• σ ∈ (cid:2),• h : dom(body(σ )) → dom(D) ∪ (cid:23)(cid:15)(cid:2),• s ∈ (cid:23)(cid:2) \ S, and• h(body(σ )) ⊆ T ⊆ B(dom(h(guard(σ ))), S).(cid:14)(head(σ )), where h(cid:14)Such a (D, (cid:2))-step should be interpreted as follows. The triple (σ , h, s) encodes the set of atoms h(cid:14)(zi) = si , i.e., the sort s and the variable ziextends h as follows: if z1, . . . , zk are the existential variables of σ , then huniquely determine the null that is assigned to zi . We refer to this set of atoms as (cid:2)σ , h, s(cid:3). Note that the fresh nulls of sort s in (cid:2)σ , h, s(cid:3) do not occur in h(guard(σ )) since h(guard(σ )) does not contain a null of sort s. The set T corresponds to the type of h(guard(σ )). For a set N ⊆ (cid:23)(cid:15)(cid:2), it would be useful to be able to extract the set of sorts of nulls occurring in N, i.e., the set s(cid:2)(N) = {s | s j ∈ N} ⊆ (cid:23)(cid:2). For brevity, we simply write s(cid:2)(σ , h) instead of the formal s(cid:2)(null(h(body(σ )))).Description of the Algorithm. Our alternating algorithm is presented in Algorithm 1. Recall that alternation is an extension of non-determinism where, apart from existential steps, one can also perform universal steps where several independent computations can run in parallel. Indeed, Algorithm 1 is an alternating one since, not only existential guesses are performed, but also universal steps. The latter is expressed by either using the key word universally do, followed by a list of steps starting with the symbol ! that should be executed in parallel, or the key word universally select, which essentially means that, for each element of the set from which we select elements, we execute in parallel the command that follows. Here is a detailed description of our algorithm:(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)(cid:14)• The procedure Entail implements the strategy discussed above: find σ ∈ (cid:2) and a function h that maps var(body(σ )) to (cid:2) with R(¯c) ∈ h(head(σ )), and check, via the procedure Proof, that h(body(σ )) is derivable via some chase dom(D) ∪ (cid:23)(cid:15)derivation. Note that we cannot afford to use an unlimited number of nulls since we have limited space. The nulls of (cid:23)(cid:15)(cid:2) are enough for performing this check.; if null(Q ) is empty, which means that Q• The procedure Proof checks whether a set of atoms Q is derivable via some chase derivation. Each ground atom of Qis proved in a parallel universal computation by recursively calling the procedure Entail. The remaining atoms form a is empty, then the algorithm accepts. In a guarded and ungrounded set Qparallel universal computation, it checks whether there is a δ-pivotal atom α for Q, for some chase derivation δ, such that Qis derivable by applying chase steps starting from the δ-type of α (this is enough due to Lemma 5.8; notice that here we simply exploit the existence of a δ-pivotal atom). The guessed (D, (cid:2))-step (σ , h, s, T ), actually h(guard(σ )), corresponds to the δ-pivotal atom for Q, and the algorithm performs in parallel universal computations the following checks: (i) each atom β of Q, which is not already in the δ-type of h(guard(σ )) given by T , is derivable by applying chase steps starting from T , which is done in parallel universal computations by calling the procedure Reach, and (ii) T is indeed the δ-type of h(guard(σ )), which is done by recursively calling the procedure Proof.• The procedure Reach actually checks whether, for some chase derivation δ of T w.r.t. (cid:2), h(guard(σ )) ≺gp,+(cid:14), T(cid:14)(guard(σ (cid:14))) = α, the sort of the fresh nulls that will appear in the generated atoms, that is, sβ. It starts by guessing an atom α from (cid:2)σ , h, s(cid:3). If α is the atom that we are targeting, namely β, then it accepts; otherwise, it proceeds to check whether α ≺gp,+β. Due to Lemma 5.1, to check whether α ≺gp,+β, it suffices to consider only the δ-type of α. In fact, the guessed (D, (cid:2))-step (σ (cid:14), h(cid:14))with h, and the δ-type is indeed the δ-type of α. The former check is done of α, that is, T(cid:14)). For the latter check, one may suggest that the by recursively calling the procedure Reach with input (σ (cid:14), h(cid:14)algorithm can simply call Proof(Tmay share null values, and this (cid:14)) in a parallel universal computation, we loose this connection fact should be preserved. However, by calling Proof(T(cid:14) \ T is a guarded and ungrounded between β and T(cid:14) \ T (the set of atoms from which β is coming from), which, by set of atoms that has the same δ-pivotal atom as Qitem (2) of Lemma 5.8, is unique; this atom is h(guard(σ )). Hence, to prove T, the algorithm recursively calls for each atom β(cid:14) ∈ T(cid:14) \ T , in a parallel universal computation, Reach(σ , h, s, T , β(cid:14)).(cid:14)) provides the trigger to apply at the next step, that is, (σ (cid:14), h, which may lead to unsound results. The key observation is that T(cid:14)). It should not be overlooked, though, that β and T. It remains to verify that (i) α ≺gp,+β, and (ii) T(cid:14), s(cid:14)(cid:14), T(cid:14), sδδδδ(cid:14)(cid:14)(cid:14)(cid:14)By Lemmas 5.1 and 5.8, the algorithm Entail is correct, i.e., Entail(D, (cid:2), R(¯x), ¯c) accepts iff R(¯c) ∈ chaseδ(D, (cid:2)), for some chase derivation δ of D w.r.t. (cid:2). Furthermore, at each step of its computation, the algorithm uses logarithmic space for storing elements of dom(D) and auxiliary pointers; recall that S is coming from the family of schemas S of fixed size. Since polynomial time coincides with alternating logarithmic space, Lemma 5.7 follows.6. ConclusionWe considered the classes of linear and guarded existential rules, and investigated the limits of the polynomial combined approach to FO rewritability. We proved that it can be successfully applied to (i) linear existential rules when the rewritten query can use the full power of first-order queries, (ii) to linear existential rules when the arity of the underlying schema is fixed, and the rewritten query is a positive existential first-order query, and (iii) to guarded existential rules when the 37G. Gottlob, M. Manna and A. PierisArtificial Intelligence 321 (2023) 103936underlying schema is fixed, and the rewritten query is a positive existential first-order query. As immediate corollaries, we get that ontological query answering for linear existential rules over schemas of fixed arity and guarded existential rules over fixed schemas is in NP. This closes a gap in the complexity picture of ontological query answering under linear and guarded existential rules, which passed unnoticed until recently when it was brought to our attention by a colleague of ours [24] and also discussed in [25].The results of this work are, for the moment, of theoretical nature, and they simply tell us that the exploitation of conventional database systems for ontological query answering purposes in the case of linear and guarded existential rules is, in principle, possible. We do not claim that they will directly lead to efficient algorithms. A smart implementation and an evaluation of the obtained rewritings is the obvious next step.Declaration of competing interestThe authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.Data availabilityNo data was used for the research described in the article.AcknowledgementsGottlob is a Royal Society Research Professor and acknowledges support by the Royal Society in the context of the project “RAISON DATA” (project reference: RP/R1/201074). Part of Gottlob’s work was done while visiting the University of Cyprus. Manna has been supported by MISE under the project “S2BDW” (F/050389/01-03/X32) - Horizon 2020 PON I&C2014-20, by Regione Calabria under the project “DLV LargeScale” (CUP J28C17000220006) - POR Calabria 2014-20, and by “PNRR MUR project PE0000013-FAIR, Spoke 9 - Green-aware AI – WP9.1”. Pieris was supported by the EPSRC grant EP/S003800/1 “EQUID”.References[1] G. Gottlob, M. Manna, A. Pieris, Polynomial combined rewritings for existential rules, in: KR (2014), 2014.[2] G. Gottlob, M. Manna, A. Pieris, Polynomial rewritings for linear existential rules, in: IJCAI (2015), 2015, pp. 2992–2998.[3] G. Gottlob, M. Manna, A. Pieris, Multi-head guarded existential rules over fixed signatures, in: KR (2020), 2020.[4] S. Abiteboul, M. Arenas, P. Barceló, M. Bienvenu, D. Calvanese, C. David, R. Hull, E. Hüllermeier, B. Kimelfeld, L. Libkin, W. Martens, T. Milo, F. Murlak, F. Neven, M. Ortiz, T. Schwentick, J. Stoyanovich, J. Su, D. Suciu, V. Vianu, K. Yi, Research directions for principles of data management (abridged), SIGMOD Rec. 45 (2016) 5–17.[5] A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, R. Rosati, Linking data to ontologies, J. Data Semant. 10 (2008) 133–173.[6] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, Tractable reasoning and efficient query answering in description logics: the DL-Lite family, J. Autom. Reason. 39 (2007) 385–429.[7] A. Calì, G. Gottlob, T. Lukasiewicz, A general datalog-based framework for tractable query answering over ontologies, J. Web Semant. 14 (2012) 57–83.[8] G. Gottlob, G. Orsi, A. Pieris, Query rewriting and optimization for ontological databases, ACM Trans. Database Syst. 39 (2014) 25:1–25:46.[9] G. Gottlob, S. Kikot, R. Kontchakov, V.V. Podolskii, T. Schwentick, M. Zakharyaschev, The price of query rewriting in ontology-based data access, Artif. Intell. 213 (2014) 42–59.via circuit complexity, J. ACM 65 (2018) 28:1–28:51.[10] M. Bienvenu, S. Kikot, R. Kontchakov, V.V. Podolskii, M. Zakharyaschev, Ontology-mediated queries: combined complexity and succinctness of rewritings [11] F. Baader, S. Brandt, C. Lutz, Pushing the EL envelope, in: IJCAI (2005), 2005, pp. 364–369.[12] C. Lutz, D. Toman, F. Wolter, Conjunctive query answering in the description logic EL using a relational database system, in: IJCAI (2009), 2009, pp. 2070–2075.[13] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, M. Zakharyaschev, The combined approach to query answering in DL-Lite, in: KR (2010), 2010.[14] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, M. Zakharyaschev, The combined approach to ontology-based data access, in: IJCAI (2011), 2011, [15] C. Feier, D. Carral, G. Stefanoni, B. Cuenca Grau, I. Horrocks, The combined approach to query answering beyond the OWL 2 profiles, in: IJCAI (2015), [16] A. Calì, G. Gottlob, T. Lukasiewicz, B. Marnette, A. Pieris, Datalog+/-: a family of logical knowledge representation and query languages for new appli-[17] A. Calì, G. Gottlob, M. Kifer, Taming the infinite chase: query answering under expressive relational constraints, J. Artif. Intell. Res. 48 (2013) 115–174.[18] J.-F. Baget, M. Leclère, M.-L. Mugnier, E. Salvat, On rules with existential variables: walking the decidability line, Artif. Intell. 175 (2011) 1620–1654.[19] R. Fagin, P.G. Kolaitis, R.J. Miller, L. Popa, Data exchange: semantics and query answering, Theor. Comput. Sci. 336 (2005) 89–124.[20] T. Lukasiewicz, M.V. Martinez, A. Pieris, G.I. Simari, From classical to consistent query answering under existential rules, in: AAAI (2015), 2015, pp. 1546–1552.[21] A. Calì, G. Gottlob, A. Pieris, Ontological query answering under expressive entity-relationship schemata, Inf. Syst. 37 (2012) 320–335.[22] N. Leone, M. Manna, G. Terracina, P. Veltri, Fast query answering over existential rules, ACM Trans. Comput. Log. 20 (2019) 12:1–12:48.[23] D.S. Johnson, A.C. Klug, Testing containment of conjunctive queries under functional and inclusion dependencies, J. Comput. Syst. Sci. 28 (1984) 167–189.[24] M. Benedikt, Personal communication, 2018.[25] K. Kappelmann, Decision procedures for guarded logics, CoRR, arXiv:1911.03679 [abs], 2019.[26] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, 1994.38pp. 2656–2661.2015, pp. 2971–2977.cations, in: LICS (2010), 2010, pp. 228–242.