Artificial Intelligence 229 (2015) 105–125Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintVariable symmetry breaking in numerical constraint problems ✩Alexandre Goldsztejn a, Christophe Jermann b,∗Carme Torras ca IRCCyN, CNRS, Nantes, Franceb LINA, Université de Nantes/CNRS, Nantes, Francec Institut de Robòtica i Informàtica Industrial, CSIC-UPC, Barcelona, Spain, Vicente Ruiz de Angulo c, a r t i c l e i n f oa b s t r a c tArticle history:Received 10 December 2014Received in revised form 6 August 2015Accepted 16 August 2015Available online 20 August 2015Keywords:Constraint programmingSymmetriesNumerical constraintsVariable symmetriesSymmetry breaking has been a hot topic of research in the past years, leading to many theoretical developments as well as strong scaling strategies for dealing with hard applications. Most of the research has however focused on discrete, combinatorial, problems, and only few considered also continuous, numerical, problems. While part of the theory applies in both contexts, numerical problems have specificities that make most of the technical developments inadequate.In this paper, we present the rlex constraints, partial symmetry-breaking inequalities corresponding to a relaxation of the famous lex constraints extensively studied in the discrete case. They allow (partially) breaking any variable symmetry and can be generated in polynomial time. Contrarily to lex constraints that are impractical in general (due to their overwhelming number) and inappropriate in the continuous context (due to their form), rlex constraints can be efficiently handled natively by numerical constraint solvers. Moreover, we demonstrate their pruning power on continuous domains is almost as strong as that of lex constraints, and they subsume several previous work on breaking specific symmetry classes for continuous problems. Their experimental behavior is assessed on a collection of standard numerical problems and the factors influencing their impact are studied. The results confirm rlex constraints are a dependable counterpart to lexconstraints for numerical problems.© 2015 Elsevier B.V. All rights reserved.1. IntroductionNumerical constraint solvers are nowadays beginning to be competitive and even to outperform, in some cases, classical methods for solving systems of equations and inequalities over the reals. As a consequence, their application has raised interest in fields as diverse as neurophysiology and economics [2], biochemistry, crystallography, robotics [3] and, more generally, in those related to global optimization [4]. Symmetries naturally occur in many of these applications, and it is advisable to exploit them in order to reduce the search space and, thus, to increase the efficiency of the solvers.E-mail addresses: alexandre.goldsztejn@irccyn.ec-nantes.fr (A. Goldsztejn), christophe.jermann@univ-nantes.fr (C. Jermann), ruiz@iri.upc.edu✩This paper is an extended version of [1] presented at the conference CP 2011.* Corresponding author.(V. Ruiz de Angulo), torras@iri.upc.edu (C. Torras).http://dx.doi.org/10.1016/j.artint.2015.08.0060004-3702/© 2015 Elsevier B.V. All rights reserved.106A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125Numerical solvers follow the Branch&Prune scheme, similarly to discrete constraint solvers: At each iteration, a sub-domain is selected, pruned according to the constraints, and then split into several sub-domains to be further explored. The main differences with discrete solvers are that (sub)domains being continuous only their boundaries are contracted, and that a sub-domain is declared to be a solution whenever it reaches some prescribed computational precision. Because of the resemblance of the solving processes, it is tempting to port symmetry breaking methods designed for discrete Constraint Satisfaction Problems (CSPs) to numerical ones.Considerable work on symmetry breaking has been done for discrete CSPs in the last decades [5–7]. Two main symmetry-breaking strategies have been pursued: 1) to devise specialized search algorithms that avoid symmetric portions of the search space [8,9]; and 2) to add symmetry-breaking constraints (SBCs) that filter out redundant subspaces [10,11]. Contrarily, there exists very little work on symmetry breaking for numerical problems. For cyclic variables permutations, an approach divides the initial space into boxes and eliminates symmetric ones before the solving starts [12]. SBCs have also been pro-posed, but only for either specific problems [13,14] or specific symmetry classes [15–17], and often only partially breaking the considered symmetries.In this paper, we propose the first general SBCs for numerical constraint problems that (partially) break any variable symmetry. These SBCs take the form of simple binary inequalities of the form xi ≤ x j where xi and x j are two distinct variables of the problem and i < j. Thus, at most n(n−1)inequalities are generated to deal with any symmetry. They can be generated in polynomial time knowing a generator of the symmetry group, using classical group theory algorithms. Moreover we demonstrate that these SBCs are suitable and optimal for numerical problems, i.e., they enclose tightly an asymmetric search subspace and thus have a better, or similar, pruning power than other SBCs.2The outline of the paper is as follows: Section 2 provides the necessary background on numerical problems and sym-metries; Section 3 introduces our SBCs as a relaxation of the lexicographic-ordering based SBCs [18] widely used by the discrete CSP community, and it also establishes the good properties of this relaxation; Section 4 introduces the state-of-the-art and compares our SBCs to existing alternatives; Section 5 assesses the practical interest of our SBCs on a benchmark of standard problems and analyzes the factors influencing their impact. Section 6 concludes the paper with future research directions.2. Principles of variable symmetry breakingA CSP is defined as a triple (cid:4)x, d, c(cid:5), where x = (x1, . . . , xn) is a list of variables, d = (d1, . . . , dn) is a list of domains for the variables, and c = (c1, . . . , cm) is a list of constraints. The focus of this paper is on numerical CSPs (NCSPs), whose variables are continuous, and thus domains are subsets of R, typically represented as a set of intervals (box) x. To conform mathematical notations in use for numerical problems, the same symbols are used for variables and their valuations, i.e., x will often denote a point in Rn. For the same reason, we adopt a functional notation for the evaluation of a constraint ci : Rn → {true, false} and for the evaluation of the conjunction of the constraints c : Rn → {true, false}. Hence a solution of a NCSP is a point x ∈ x that satisfies c(x), and its solution set is χ = {x ∈ x : c(x)}.A bijective function s : Rn → Rn is a symmetry of a (N)CSP if it maps solutions to solutions,1 i.e., for any x ∈ x such that c(x) = true, s(x) ∈ x and c(s(x)) = true. We say x and s(x) are symmetric points and, in case they are solutions, symmetric solutions. The symmetries of a (N)CSP form a group for the composition law. This symmetry group is denoted (cid:3) in the following. Though the identity function is forcibly part of (cid:3), since it is a trivial symmetry of any CSP, it is not considered in the following as it is irrelevant to break.In this paper, we consider only symmetries that are permutations of variables. Let Sn be the set of all permutations of {1, . . . , n}. The image of i by a permutation σ is denoted by iσ . Any permutation σ is completely defined by the image of each integer in {1, . . . , n}, and it is usually described as a vector [1σ , 2σ , . . . , nσ ]. A symmetry s is a variable symmetry iff there is a permutation σ ∈ Sn such that for any point x ∈ x, s(x) = (x1σ , . . . , xnσ ). We identify such symmetries with their associated permutations and denote both by σ in the following. Consequently, the group of variable symmetries of a CSP is isomorphic to a permutation subgroup of Sn, which are both identified and denoted by (cid:3) in the following. The application of a variable symmetry σ to a point x is denoted by xσ , this notation being extended to sets (discrete or continuous) of points X ⊆ x by X σ = {xσ : x ∈ X}.Example 1. The 3-cyclic roots problem consists in finding all (x1, x2, x3) ∈ R3 satisfying (x1 + x2 + x3 = 0) ∧ (x1x2 + x2x3 +x3x1 = 0) ∧ (x1x2x3 = 1). This problem has six variable symmetries (including identity):(cid:3) = {[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]},(1)i.e., (cid:3) = S3. Indeed, all the variables are syntactically interchangeable within all the constraints by the commutativity laws of product and sum.1 Nothing is required for non-solution points, i.e., we consider only solution symmetries [19].A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125107We can define the symmetry class of any point x ∈ x as the set of the images s(x) for all the symmetries s of the problem. In the case of variable symmetries, it can be noted x(cid:3) = {xσ : σ ∈ (cid:3)}. Provided that the domain satisfy the symmetries, i.e. x = xσ for all σ ∈ (cid:3), being in the same class is an equivalence relation and thus the symmetry classes form a partition of x.The symmetries of a (N)CSP are broken when a single representative in each symmetry class is retained. To this end, it is possible to add symmetry-breaking constraints (SBCs) which exclude all but a single representative in each symmetry class [5,7,20]. Crawford et al. [18] proposed lexicographic ordering constraints (lex) to address variable symmetry breaking. Recall that given x and y in Rn, the lexicographic order is defined inductively as:for n = 1,for n > 1,x (cid:10)lex y ≡ (x1 ≤ y1)x (cid:10)lex y ≡ (x1 < y1) ∨(cid:2)(cid:3)(x1 = y1) ∧ (x2:n (cid:10)lex y2:n)where, given a list z = (z1, z2, . . . , zn), zi: j denotes the sublist (zi, zi+1, . . . , z j).Given a variable symmetry σ , Crawford et al. define the corresponding SBClexσ (x) ≡ x (cid:10)lex xσ .(2)(3)Intuitively, this constraint imposes a total order on the symmetric points, hence allowing to retain a single one w.r.t. a given symmetry σ . One such constraint is thus imposed for each of the symmetries of a problem in order to break them all, yielding the complete symmetry-breaking constraint(cid:4)lex(cid:3)(x) ≡lexσ (x)σ ∈(cid:3)(4)Example 2. The lex constraints for the symmetries of the 3-cyclic-roots problem are:(x1, x2, x3) (cid:10)lex (x1, x3, x2) , (x1, x2, x3) (cid:10)lex (x2, x1, x3)(x1, x2, x3) (cid:10)lex (x2, x3, x1) , (x1, x2, x3) (cid:10)lex (x3, x1, x2)(x1, x2, x3) (cid:10)lex (x3, x2, x1).lex constraints can be efficiently propagated over finite domains (e.g., [21]). However, this approach has the critical drawback that the number of symmetries in (cid:3) can be factorial in the number of variables even in some simple situations (e.g., |Sn| = n!). While in general the corresponding SBCs cannot be simplified to a polynomial number of constraints (in line with the NP-hardness of symmetry breaking proved in [18] and further explored in [20]), simplifying specific symme-try groups into tractable ones has been the topic of several works in the symmetry breaking literature (e.g., [18,11,22]). For instance, Crawford et al. noted that when (cid:3) = Sn, the n! terms in lex(cid:3) can be simplified to the n − 1 inequalities (cid:5)i∈{1,...,n−1} xi ≤ xi+1.3. Symmetry-breaking constraints for numerical CSPsIn this section we first explain the reason why lex SBCs are impractical for numerical CSPs. We also point out the intuition behind the partial SBCs we introduce, and we discuss their properties in the rest of the section.3.1. lex intractability and impracticality for NCSPsThe first and foremost reason why lex SBCs are intractable, whether domains are continuous or discrete, is because they can be overwhelmingly numerous. However, even when the symmetry group is of reasonable size or when lex SBCs can be reduced to a reasonable number, they remain impractical in the context of NCSPs.A geometric interpretation of lex constraints highlights their complexity and indicates the intuition behind the relaxation we propose in the next section. Let us denote Lσ (x) (resp. L(cid:3)(x)) the solution set of a lex constraint breaking a symmetry σ (resp. a whole symmetry group (cid:3)) on a domain x, i.e.,Lσ (x) := {x ∈ x : lexσ (x)},L(cid:3)(x) := {x ∈ x : lex(cid:3)(x)}.For convenience, we will omit the domain x when it spans the whole set of real vectors Rn.(5)(6)Breaking the symmetries of a NCSP by adding the SBC lex(cid:3)(x) to its constraints allows restricting its search space to L(cid:3)(x), hence retaining only one solution by symmetric class. We first remark that lex(cid:3)(x) being the conjunction of all lexσ (x), L(cid:3)(x) is thus the intersection of all Lσ (x), i.e.,L(cid:3)(x) =Lσ (x)(7)(cid:6)σ ∈(cid:3)108A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125Fig. 1. The lex[2,1] constraint components in 2D (blue = included, red = excluded).Fig. 2. The lex[2,3,1] constraint components in 3D (blue = included, red = excluded).Second, the recursive definition of the lexicographic relation in Equation (2) indicates that the form of each lexσ (x) is the union of 1) an open half-space (x1 < x1σ ) and 2) a portion of its boundary “plane” (x1 = x1σ ), this portion being itself recursively defined similarly as the union of 3) a half-plane (x2 < x2σ ) and 4) a portion of its boundary “line”, etc. Hence, the structure of Lσ (x) becomes more and more complicated as the number of variables increases.Example 3. When n = 2 the only possible symmetry is the interchangeability of x1 and x2, i.e., permutation [2, 1]. It yields the lex constraintx1 < x2 ∨ (x1 = x2 ∧ (x2 < x1 ∨ (x2 = x1))),(8)which boils down to x1 ≤ x2, i.e., the union of 1) the open half-plane x1 < x2 with 2) the line x1 = x2, as depicted in Fig. 1.Things get more complicated when n = 3. Consider for instance permutation [2, 3, 1] and the corresponding lex SBCx1 < x2 ∨ (x1 = x2 ∧ (x2 < x3 ∨ (x2 = x3 ∧ (x3 < x1 ∨ (x3 = x1))))),which simplifies to(x1 < x2) ∨ (x1 = x2 ∧ x2 < x3) ∨ (x1 = x2 = x3),(9)(10)i.e., the union of 1) the open half-space (x1 < x2) with 2) the open half-plane (x1 = x2 ∧ x2 < x3) and with 3) the line (x1 = x2 = x3) as depicted in Fig. 2.Though it becomes impossible to depict the geometry of a lex constraint when n > 3, one can easily imagine its general structure, and thus its complexity in the numerical context.As a consequence, the geometric shape of L(cid:3)(x) is the intersection of a (potentially factorial) number of complex asymmetric subspaces Lσ (x), resulting in a very complex subspace having the form of a polyhedral cone, whose essen-tial complexity lies on the boundaries while its main part is the simple intersection of open half-spaces xi < x j , whose number is at most n(n−1)in dimension n.2Example 4. LC3 for the cyclic symmetry group in 3D is the intersection of two subspaces corresponding to lex[2,3,1] and lex[3,1,2], as depicted in Fig. 3.In conclusion, the complexity of lex SBCs,2 which makes them impractical for NCSPs, lays in the boundaries of their so-lution sets while these boundaries are somehow negligible in numerical domains (this will be formalized in Subsection 3.3). In the following subsection, we propose a relaxation of lex constraints that consists in accepting all their boundaries, leading to partial SBCs much better suited to NCSPs.2 Note that various formulations of lex constraints are proposed in the literature, but in the continuous context they are either equivalent to the considered formulation (3) and thus define an identical, complex, half-open, subspace, or they are not equivalent (see Section 4.4 for more details).A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125109Fig. 3. The lex constraint components for the cyclic symmetry group in 3D. In blue, inner components, in red, excluded boundaries.3.2. Definition of the rlex partial SBCsPartial symmetry-breaking constraints (PSBCs) can be defined by considering a tractable subset of complete symmetry-breaking constraints [22]. The key idea of our approach is instead to simplify every lex SBC by considering the closure of the geometric space it defines, i.e. the main open half-space together with its boundary. The main half-space of an SBC lexσ corresponds to the inequality x ˆσ < x ˆσ σ , where ˆσ is the smallest integer in {1, . . . , n} such that ˆσ (cid:13)= ˆσ σ (e.g., for σ = [1, 2, 3, 5, 4] we have ˆσ = 4). Note that this integer is well-defined for all symmetries except the identity permutation, which cannot be broken and is thus disregarded in the following. We define the relaxed lex constraint byrlexσ (x) ≡ x ˆσ < x ˆσ σ ∨ x ˆσ = x ˆσ σ ⇐⇒ x ˆσ ≤ x ˆσ σ .Accordingly, the acceptance of x by the whole set of rlex constraints isrlex(cid:3)(x) ≡(cid:4)σ ∈(cid:3)rlexσ (x).(11)(12)The following proposition shows that this is indeed a relaxation of lex, and that it can thus be used as a PSBC.Proposition 1. lexσ (x) =⇒ rlexσ (x).Proof. Since i < ˆσ implies i = iσ , we have xi = xiσ for all i < ˆσ . Therefore lexσ (x), which is x (cid:10)lex xσ , is actually equivalent , which logically implies (x ˆσ < x ˆσ σ ) ∨ (x ˆσ = x ˆσ σ ), (cid:10)lex x ˆσ :nto x ˆσ :nthat is rlexσ (x). (cid:2)(x ˆσ = x ˆσ σ ) ∧ (x ˆσ +1:nσ , i.e., (x ˆσ < x ˆσ σ ) ∨(cid:10)lex x ˆσ +1:n(cid:8)σ )(cid:7)Similarly to what we have done for lex constraints, we define the portions of a domain x satisfying rlex constraints asRσ (x) := {x ∈ x : rlexσ (x)},R(cid:3)(x) := {x ∈ x : rlex(cid:3)(x)}.(13)(14)For convenience, we will omit the domain x when it spans the whole set of real vectors Rn.Example 5. The rlex constraint for the cyclic symmetry groups C2 is just rlex[2,1] := x1 ≤ x2. That for C3 are rlex[2,3,1] :=x1 ≤ x2 and rlex[3,1,2] := x1 ≤ x3. The corresponding domains are depicted in Fig. 4, which illustrates their relation to the corresponding lex constraints (see Figs. 1 and 3 above).Also, the rlex constraints corresponding to Example 2 are the two inequalities x1 ≤ x2 and x2 ≤ x3 (x1 ≤ x3 also appears, but is redundant).3.3. Properties of the rlex PSBCsThe rlex PSBCs are now compared to the lex SBCs. We first show in Subsection 3.3.1 that rlex are suitable for NCSPs. We also provide a detailed analysis of the difference between rlex PSBCs and lex SBCs in Subsection 3.3.2, indicating that the former are in fact complete SBCs, just as powerful as the latter, in many cases.3.3.1. On the suitability of rlex constraints for NCSPsWe now establish some properties of the rlex PSBCs that make them suitable for breaking variable symmetries in NCSPs, i.e., both reasonable in number whatever the symmetry group, natively handleable by numerical constraint solvers, and optimal in terms of pruning capabilities.110A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125Fig. 4. rlex constraints for the cyclic symmetry groups in 2D and 3D.Number of constraints and their generation There are at most n(n−1)rlex constraints whatever the symmetry group since they all have the form xi ≤ x j with i < j. This number can even be reduced to n − 1 using transitivity reduction [23] and according to Theorem 4 in [24].2The naive way of generating rlex PSBCs is to generate all lex SBCs and relax them. However, this entails generating all lex SBCs, which is intractable.The very same indexes of variables are used in [24] where SBCs of the form x ˆσ < x ˆσ σ are derived for discrete CSPs including an alldiff global constraint. In that paper, a polynomial-time algorithm is proposed to generate these variables index, based on Shreier–Sims group theory algorithm [25]. This method can be used to generated rlex constraints as well.For simplicity, we recall this generation algorithm3 here:Input : group G (acting on the set of variable indices)Output : list I of variable indices pairsI = []while G.order()!=1 :x = G.smallest_moved_point()for y in G.orbit(x) :I += [(x,y)]G = G.stabilizer(x)where function smallest_moved_point returns the smallest index ˆσ of all permutations σ ∈ G and functions orbitand stabilizer compute the corresponding classical group theory elements.The relationship between rlex PSBCs and the SBCs proposed in [24] is further investigated in Subsection 4.1.Pruning optimality for numerical solvers At the heart of the unsuitability of lex constraints lies the open-set nature of the subspace they delimit. Numerical constraint solvers based on intervals4 cannot take advantage of the difference between the subspace defined by the problem constraints and its closure. We now prove that rlex constraints define just the closure of the subspace defined by lex constraints, which implies that numerical constraint solvers cannot distinguish lex and rlexconstraints in general.53 Given in Python/SageMath language for convenience of reusability ; easily rewritten for other formal computation software, e.g., GAP, Mathematica.4 Interval computations are typically based on closed intervals, computations with open sets being complicated, expensive, and often useless due to outward rounding necessity. Note that typical numerical algorithms do not handle strict inequalities neither.5 Singular cases, e.g., when the considered box has some interval dimensions degenerated into a single real, could in theory make a difference betweenlex and rlex constraints, provided the solver implements lex constraints filtering which is not the case of any numerical solver we know of.A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125111Proposition 2. R(cid:3) = cl(L(cid:3)).Proof. Consider the interior and closure sets of the subspace defined by a single lex constraint. Both int(Lσ ) = {x ∈ Rn :x ˆσ < x ˆσ σ } and cl(Lσ ) = {x ∈ Rn : x ˆσ ≤ x ˆσ σ } = Rσ obviously hold for any permutation σ . By definition, R(cid:3) = ∩σ ∈(cid:3)Rσand L(cid:3) = ∩σ ∈(cid:3)Lσ , therefore R(cid:3) ⊇ cl(L(cid:3)) is a direct consequence of the property that the closure of an intersection is a subset of the intersection of the closures. For the reverse inclusion, note that y = (1, 2, 3, 4, . . . , n) ∈ int(L(cid:3)), and consider an arbitrary x ∈ R(cid:3) . For each σ ∈ (cid:3) we thus have y ˆσ < y ˆσ σ and x ˆσ ≤ x ˆσ σ . For λ ∈ [0, 1], define zλ = λx + (1 − λ) y, and note ˆσ σ and thus zλ ∈ int(Lσ ). As that for 0 ≤ λ < 1 we have both λx ˆσ ≤ λx ˆσ σ and (1 − λ) y ˆσ < (1 − λ) y ˆσ σ , which implies zλthis holds for each σ ∈ (cid:3), we conclude that zλ ∈ int(L(cid:3)). As a consequence, x = limλ→1 zλ ∈ cl(int(L(cid:3))) ⊆ cl(L(cid:3)), which proves the reverse inclusion. (cid:2)ˆσ < zλFinally, we remark that rlex constraints must be more efficient to propagate than lex constraints. Indeed, they are just binary inequalities while lex constraints involve all the variables of the symmetries in a large combination of logical operations. Hence, pruning rlex constraints requires no specific algorithm since simple non-strict inequalities are natively handled by most numerical solvers; and their propagation, following the AC3-like fix-point process in use in most numerical constraint solvers, triggers only constraints depending on two variables at most instead of n at most (entailing all constraints are enqueued).Search-space reduction factor In the context of NCSPs, the size of the search space cannot be measured using the number of elements it contains, since there are infinitely many elements in any continuous set S. Instead, we can quantify it using its hypervolume,6 denoted vol S. For example, the search space ([−1, 1], [−1, 1], [−1, 1]) has a (hyper)volume equal to 8, while its half ([0, 1], [−1, 1], [−1, 1]) has a (hyper)volume equal to 4.The aim of this section is to study the hypervolume reduction of the search space provided by the rlex constraints in comparison to the corresponding lex constraints. As rlex is a relaxation of lex, we have L(cid:3)(x) ⊆ R(cid:3)(x). In fact, we have a more accurate relationship between these sets: Informally, any solution accepted by some rlexσ constraint and rejected by the corresponding lexσ constraint has to have at least two equal components, namely x ˆσ = x ˆσ σ . We define the set of vectors that have at least two equal components as H := {x ∈ Rn : ∃(i, j), i (cid:13)= j ∧ xi = x j}, and note that vol H = 0 since it is only composed of (hyper)planes, i.e., flat sets. We therefore see that lex(cid:3) and rlex(cid:3) solution sets have the same hypervolume, which is proved in the following proposition.Proposition 3. vol L(cid:3)(x) = vol R(cid:3)(x).Proof. Since L(cid:3)(x) ⊆ R(cid:3)(x) we have vol L(cid:3)(x) ≤ vol R(cid:3)(x). Now note that x ∈ R(cid:3)(x) ∧ x /∈ L(cid:3)(x) obviously implies x ∈ H , so R(cid:3)(x) ⊆ L(cid:3)(x) ∪ H and hence using the rule for measuring unions of sets vol R(cid:3)(x) ≤ vol L(cid:3)(x) + vol H −vol (L(cid:3)(x) ∩ H). Since vol H = 0, vol (L(cid:3)(x) ∩ H) = 0 and we obtain vol R(cid:3)(x) ≤ vol L(cid:3)(x). (cid:2)The following proposition quantifies the reduction performed by the lex constraints, therefore by rlex constraints as well by Proposition 3, in term of hypervolume.Proposition 4. Provided the domain x is symmetric, i.e. x = xσ for all σ ∈ (cid:3),vol L(cid:3)(x) = vol x|(cid:3)|.Proof. We suppose that |(cid:3)| ≥ 2, otherwise (cid:3) = {id} and the statement is trivial. First note that vol L(cid:3)(x) = vol (L(cid:3)(x)σ )because the map x → xσ is an isometry and thus preserves the measure. Now note that for x ∈ L(cid:3)(x) and σ , φ ∈ (cid:3), σ (cid:13)= φobviously implies xσ (cid:13)= xφ or x ∈ H (indeed if xσ = xφ then x = xφσ −1and hence x ∈ H ). Therefore, L(cid:3)(x)σ ∩ L(cid:3)(x)φ ⊆ H . Recalling that vol H = 0, we obtain using the rule for measuring unions of setsL(cid:3)(x)σ= |(cid:3)| vol L(cid:3)(x).(15)(cid:2) (cid:9)volσ ∈(cid:3)(cid:3)(cid:10)It remains to prove that one representative of each symmetry class, we haveσ ∈(cid:3)(cid:9)(cid:9)L(cid:3)(x)σ = x. Since the symmetry classes form a partition of x and L(cid:3)(x) contains exactly xσ = x.(16)x∈L(cid:3) (x)σ ∈(cid:3)6 A generalization of the area in 2D and the volume in 3D, also called Lebesgue measure.112A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125The proof is concluded by commuting the two unions. (cid:2)By Proposition 3, we can conclude that the same hypervolume reduction is enforced by the rlex constraints. In other words, rlex and lex constraints reduce the search space to a portion with identical hypervolume, the difference lying only on the boundaries of the remaining search space. The rlex PSBCs are optimal in this regard.3.3.2. A detailed look at the difference between rlex and lex filtering powerslex are always SBCs while rlex are PSBCs, hence the former have in principle a superior filtering power than the latter. However, in a continuous context, rlex act as SBCs in a set of points occupying the whole domain volume. Indeed, we have already explained that a point retained by rlex and not retained by lex must belong to the set H . Note also that all points of a class lies either in H or in H . Hence rlex are SBCs in H . Since H has no volume, the set H for which rlex can be guaranteed to be SBCs has the same volume as the domain. At the end of this section we will further conclude that rlexare also SBCs in a non-empty subset of H .The number of symmetric points of x satisfying rlex constraints is |R(cid:3)(x(cid:3))|, and we denote by |x(cid:3)| = |{xσ : σ ∈ (cid:3)}| the number of different elements in the symmetry class of x. Both indicators are indeed properties of the symmetry class of the point rather than properties of the point itself. The pruning power of a PSBC on the symmetry class of a point x is optimal when |R(cid:3)(x(cid:3))| = 1 and |x(cid:3)| = |(cid:3)|. Indeed, in this case the PSBC acts as an SBC (|R(cid:3) (x(cid:3))| = 1) and allows the greatest |(cid:3)| ). By abuse of language, we say a point x is rlex-optimal if it belongs to an optimally possible reduction (reduced symmetry class. Therefore, any point x in H is rlex-optimal since rlex being SBCs means that |R(cid:3) (x(cid:3))| = 1, and x ∈ H means x does not have equal components, thus implying that all its permutations are different, i.e., |x(cid:3) | = |(cid:3)|.|R(cid:3) (x(cid:3) )||x(cid:3) |= 1With a more detailed analysis we will show that rlex-optimality, and therefore the fact rlex perform as SBCs, can be guaranteed for a set larger than H , i.e., even in a subset of H . At the same time we will characterize completely rlex-optimal points.From a topological point of view, we can divide the subspace R(cid:3) (x) into two sets: interior points and frontier points. Interior points are those satisfying the strict part of the inequalities of rlex (i.e., points satisfying the constraints in [24]). Frontier points are those for which the equality in some of the rlex holds. The main result we will prove in this subsection is that interior points and optimal points are coincident.For this purpose, we will rely mainly on an intermediate characterization, Proposition 6, stating that the class of a point is optimal if and only if every symmetry of the point but one is rejected by rlex. Another interesting result in the way is Proposition 7: any symmetry of an interior point (except identity) will be rejected by rlex. Combined with the former it implies directly the main result, Proposition 8. The following statement is required by Proposition 6:Proposition 5. All elements of x(cid:3) are generated with the same number of symmetries of (cid:3), i.e., |{σ ∈ (cid:3) : xσ = y}| = |{σ ∈ (cid:3) : xσ =z}|, ∀ y, z ∈ x(cid:3) .· σ2 is a permutation that transforms y into z, because yφ = yσ −1Proof. Let (cid:7) = {σ ∈ (cid:3) : xσ = y} and ϒ = {σ ∈ (cid:3) : xσ = z} and let σ1 ∈ (cid:7), σ2 ∈ ϒ be elements of these sets, i.e., xσ1 = y, xσ2 = z. Then φ = σ −1·σ2 = xσ2 = z. As a consequence, ∀σ ∈ (cid:7) we have xσ ·φ = yφ = z. Therefore, every permutation in (cid:7) φ belongs to ϒ . The application fφ(σ ) = σ φfrom (cid:3) to (cid:3) is known to be bijective, hence it must also be bijective in the restricted (cid:7) domain, which implies |(cid:7) φ| = |(cid:7)|. Therefore ϒ has at least |(cid:7)| symmetries, |ϒ| ≥ |(cid:7)|. Inverting the roles of y and z and those of ϒ and (cid:7) at the beginning of the proof, we get |ϒ| ≤ |(cid:7)|, leading to |ϒ| = |(cid:7)|. (cid:2)·σ2 = (xσ1 )σ −1111In the next step we characterize optimal and non-optimal classes with the following proposition.Proposition 6. The class x(cid:3) of a point x ∈ Rn is optimal, i.e.,1. |x(cid:3)| = |(cid:3)| and |R(cid:3)(x(cid:3))| = 1if and only if2. ∃σ1 ∈ (cid:3) : rlex(cid:3)(xσ1 ) = true and ∀σ2 ∈ (cid:3) \ σ1, rlex(cid:3)(xσ2 ) = false.Proof. We first prove 1 ⇒ 2 by contradiction: suppose ∃ σ1, σ2, σ1 (cid:13)= σ2 such that rlex(cid:3)(xσ1 ) = rlex(cid:3)(xσ2 ) = true. There are two possibilities. If xσ1 = xσ2 then, since the two symmetries are different, we have |x(cid:3) | < |(cid:3)| and we have arrived to a contradiction. In the opposite case, xσ1 (cid:13)= xσ2 , since both symmetries are accepted, we have |R(cid:3) (x(cid:3))| > 1, which is again a contradiction.Second, we prove 2 ⇒ 1: since σ1 is the only symmetry accepted by rlex, obviously |R(cid:3)(x(cid:3))| = 1. For the other state-ment, we note that |x(cid:3)| = |(cid:3)| is equivalent to xσ1 (cid:13)= xσ2 ∀ σ1, σ2 ∈ (cid:3), σ1 (cid:13)= σ2. Since σ1 is the only permutation of x that is accepted by rlex, no other permutation can yield the same result as σ1. Therefore, |{σ ∈ (cid:3) : xσ = xσ1 }| = 1. By Propo-sition 5, this leads to |{σ ∈ (cid:3) : xσ = xφ}| = 1 ∀φ ∈ (cid:3), which implies that each φ ∈ (cid:3) yields a result different from all the other permutations in the group, i.e., xσ1 (cid:13)= xσ2 ∀ σ1, σ2 ∈ (cid:3), σ1 (cid:13)= σ2, as was required. (cid:2)A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125113As a consequence, the class of x is non-optimal iff ∃ σ1, σ2, σ1 (cid:13)= σ2 such that rlex(cid:3)(xσ1 ) = rlex(cid:3)(xσ2 ) = true.Proposition 7. x is interior ⇒ ∀ σ ∈ (cid:3) \ Id, rlex(cid:3)(xσ ) = false.Proof. Let’s define x ≺lex y as in (2), but being equivalent for n = 1 to (x1 < y1). That is, x ≺lex y ≡ (x (cid:10)lex y) ∧ (x (cid:13)= y) and y (cid:10)lex x ≡ ¬(x ≺lex y). If a point x is interior then x ˆσ < x ˆσ σ ∀ σ ∈ (cid:3) \ Id. This means that x (cid:13)= xσ ∀ σ ∈ (cid:3) \ Id, but at the same time x (cid:10)lex xσ , since x satisfies rlex. Thus, if x is interior, x ≺lex xσ ∀ σ ∈ (cid:3) \ Id. Now we investigate whether xσsatisfies rlex ∀ σ ∈ (cid:3) \ Id. When the rlex associated to σ −1 is applied to xσ it results in xσ (cid:10)lex (xσ )σ −1 ≡ xσ (cid:10)lex x. But, because x is interior, x ≺lex xσ , which falsifies that rlex. Therefore, xσ does not satisfy rlex ∀ σ ∈ (cid:3) \ Id. (cid:2)Let I(cid:3) denote the set of pairs of variable indexes involved in an rlex constraint, i.e., I(cid:3) := {(i, j) : xi ≤ x j is a constraint inrlex(cid:3)}. The next proposition is the main result of this subsection: for a point, being interior is equivalent to being optimal.Proposition 8. For any x ∈ x such that rlex(cid:3)(x) = true (i.e., for any x ∈ R(cid:3)(x)), x is interior ⇔ the class x(cid:3) is optimal.Proof. Interior ⇒ optimal: Applying Proposition 7 to x we obtain the conditions for Proposition 6 to be applied with σ1 = Id.Optimal ⇒ interior: The statement “in an optimal class the member retained by rlex is interior” is equivalent to “if a point is frontier, its class is non-optimal”. We will prove the latter statement. So we assume that x is a frontier point, i.e., ∃ (i, j) ∈ I(cid:3) : xi = x j . To prove the non-optimality of x(cid:3) it is enough to show that ∃ σ ∈ (cid:3) \ Id such that rlex(cid:3)(xσ ) = true. Let δ := min{|xr − xs| : xr (cid:13)= xs}/2, i.e., half of the smallest non-null difference between any two components in x, and z = (z1, . . . , zn) such that zk = xk, if k (cid:13)= i and zk = xk + δ, if k = i.Since zi > z j and (i, j) ∈ I(cid:3) , z must be rejected by rlex. However, at least one element of its class must by accepted by rlex. Thus, ∃σ ∈ (cid:3) \ Id such that rlex(cid:3)(zσ ) = true. We can show that this same permutation σ of x is also accepted by rlex(cid:3) . Let E(i) := {r : xr = xi}. We can divide the set of rlex(cid:3) constraints into two subsets. The first one corresponds to {(k, l) ∈ I(cid:3) : kσ ∈ E(i) ∧ lσ ∈ E(i)}, and for the elements of this set we know that xkσ = xlσ and, therefore, the corresponding constraint for xσ , xkσ ≤ xlσ , is satisfied. By construction of z, it is easy to verify that for any (s, r) such that r /∈ E(i) or s /∈E(i), if zr ≤ zs we have also xr ≤ xs. Therefore, in the remaining second set of constraints, {(k, l) ∈ I(cid:3) : kσ /∈ E(i) ∨ lσ /∈ E(i)}, the fact that zσ is accepted by rlex means that zkσ ≤ zlσ , which in turn implies that xkσ ≤ xlσ . The conclusion is that all rlex(cid:3) constraints are satisfied at xσ and at x, thus its class is not optimal. (cid:2)Example 6. The 4-cyclic roots problem has a formulation similar to that of Example 1 in R4. It has the following eight symmetries:(cid:3) = {[1, 2, 3, 4], [4, 3, 2, 1], [2, 3, 4, 1], [1, 4, 3, 2],[3, 4, 1, 2], [2, 1, 4, 3], [4, 1, 2, 3], [3, 2, 1, 4]}One can easily check that the non-redundant rlex for this set of permutations is x1 ≤ x2, x1 ≤ x3, x1 ≤ x4 and x2 ≤ x4. An interior point of the constrained space R(cid:3)(x) must satisfy x1 < x2, x1 < x3, x1 < x4 and x2 < x4, but can have some components equal, if they are not linked by the relaxed constraints. For instance, (0.0, 1.5, 1.5, 2.0) is an interior point even if x2 = x3.A consequence of the last proposition is that frontier points can be identified with non-optimal points. Thus, a frontier point must satisfy at least one of these conditions:1. It belongs to a class with less than |(cid:3)| members.2. Some of its symmetries are not broken by rlex(cid:3) .All the possibilities not forbidden by the above statement can be found in the set of frontier points:• Points whose symmetric points have not been completely eliminated by rlex, and having |(cid:3)| symmetries.For example, considering again the 4-cyclic roots problem, (0.0, 0.0, 1.5, 2.0) is a point with eight symmetries, which is retained by rlex(cid:3) jointly with one of its symmetric points, (0.0, 0.0, 2.0, 1.5).• Points for which all symmetries are broken and belonging to classes with less than |(cid:3)| members. For these classes,rlex are equivalent to lex.Examples for the 4-cyclic roots problem are the points (0.0, 1.0, 0.0, 1.0) and (−2.0, 5.0, 5.0, 5.0), which are the only members of their classes (of cardinality two and four, respectively) in the constrained subspace.• Points that belong to classes with less than |(cid:3)| members for which symmetries are not completely broken.An example for the 4-cyclic roots problem is (−5.0, −5.0, 2.0, −5.0), a point of a four-members class that has two representatives in the constrained subspace, namely the same point and (−5.0, −5.0, −5.0, 2.0).114A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125In sum, the frontier of the constrained subspace R(cid:3) (x) is the union of two non-disjoint sets of points belonging to classes with either less than |(cid:3)| members, or whose symmetries have not been entirely broken.Finally we want to remark that the SBC character of rlex is not limited to H , or even to interior points, a superset of H. Let’s outline the situation in this respect. rlex always are, of course, SBCs in H , which has the same volume as the domain. rlex are also SBCs for two subsets of H : a) Interior points belonging to H ; b) Frontier points with all symmetries broken. Moreover, at least one of these subsets is not empty. If the set of rlex imposes a total order on the variables, they are SBCs in the whole domain including the set of frontier points, which coincides with H (because in this case rlex and lex are equivalent) and, thus, the set in b) is not empty. If rlex do not impose a total order then the set in a) is not empty, because there are interior points with variables not related by rlex constraints with equal values. The conclusion is that rlex are SBCs in a set always strictly greater than H .4. Related workThe related work we present in this section concerns only variable symmetry breaking. It can be divided into two categories. The first one (Sections 4.1, 4.2 and 4.3) includes the simplified SBCs or PSBCs for general symmetries developed in the discrete constraint programing field. In general, they are not suited to numerical problems and they have never been applied to numerical solvers. The second group of related works (Sections 4.5 and 4.6) are those specifically addressing symmetries in numerical problems. They deal only with particular cases of symmetries and/or problems.4.1. Puget’s SBCsIn the case where a CSP contains an all-different constraint, Puget has proved in [24] that the lex SBCs can be drastically simplified. In fact, as shown in Subsection 3.1, the complexity of lex SBCs lays in their boundaries, which correspond to some equality between two distinct variables, while the presence of an all-different constraint implies that there is no solution on these boundaries. The comparison between Puget’s SBCs and rlex PSBCs is summarized in Fig. 5: An arbitrary lex SBC is equivalent to Puget’s x ˆσ < x ˆσ σ SBC under the hypothesis that an all-different constraint is enforced, while this lex SBC implies the corresponding x ˆσ ≤ x ˆσ σ rlex PSBC in general. Since the same indices are involved in both cases, the polynomial algorithm used by Puget to generate his constraints, which is based on the Shreier–Sims algorithm, can also be used for generating rlex PSBCs. Finally, although less natural than the derivation of rlex PSBCs given in Section 3.2, the following proposition shows that rlex PSBCs can be derived directly from Puget’s SBCs. It is provided here for clarifying the relationship between Puget’s SBCs and rlex PSBCs.Proposition 9. The fact Puget’s constraints are SBCs in conjunction with an all-different constraint implies that rlex are PSBCs in general.Proof. Consider a CSP with n variables and an arbitrary variable symmetry group (cid:3). Let x be an arbitrary variable instanti-ation. We are going to prove that the constraints rlex(cid:3) retain at least one element of x(cid:3) , hence that they are PSBCs, only using the fact that Puget’s constraints are SBCs.Let δ := min{|xi − x j| : xi(cid:13)= x j}, i.e. the smallest non-null difference between any two components in x, and y =( y1, . . . , yn) such that yi = xi + iδn . Then all the components yi are different. Indeed, yi − y j = (xi − x j) + (i − j) δnis not zero for i (cid:13)= j, since when xi − x j = 0 the second summand is not null and, otherwise, we have |i − j| < n and |i − j| δn < δ ≤ |xi − x j|, which implies (xi − x j) (cid:13)= −(i − j) δn .Because y satisfies the all-different constraint, Puget’s SBCs on (cid:3) retain exactly one element of its symmetric class, i.e., there exist σ ∈ (cid:3) such that yσ satisfies all Puget’s constraints. We now show that xσ satisfies all rlex constraints on (cid:3) as well.Consider the application to yσ of an arbitrary Puget’s constraint yiσ < y jσ and suppose that the corresponding rlexn < x jσ + jσ δn , . Since we supposed xiσ − x jσ > 0 and by definition of δ, we have δ ≤ xiσ − x jσ <constraint does not hold, i.e., xiσ > x jσ . By definition of y, Puget’s constraint yiσ < y jσ is equivalent to xiσ + iσ δwhich is equivalent to xiσ − x jσ < δ jσ −iσδ jσ −iσ, but because jσ − iσ < n this is contradictory. (cid:2)nn4.2. Jefferson’s PSBCsPSBCs in the discrete context follow two distinct principles: either (1) they completely break a subset of the symmetry group, or (2) they partially break the whole symmetry group.7 Jefferson and Petrie have investigated the two approaches in [22]: following principle (1), they use lex constraints to completely break random subsets of permutations, or the gen-erators computed by Nauty [26], or the generators obtained using a modification of Nauty; following (2), they use rlexconstraints (called ArityOne in their work and informally derived from Puget’s SBCs) to partially break all symmetries. Their 7 Though it is also possible to partially break a subset of the symmetry group, this approach is in general inferior to the two others.A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125115Fig. 5. Parallel derivation of Puget’s SBCs and rlex showing both the similitude and the difference of the two approaches.experiments show that, in the context of discrete CSP, rlex are quite efficient but not the best PSBCs: the lex constraints on the generators computed using their modification of Nauty appears more efficient in general. These conclusions cannot however be transposed to the continuous context, since approaches following principle (1) are not suitable for continuous solvers due to the impracticality of lex constraints in this context (see Section 3.1).4.3. Friedman’s PSBCsFriedman et al. introduce the notion of fundamental domains for (binary) integer programs [27] then for continuous domains [28]. They are defined as subsets F of the initial domain D such that F (cid:3) = D, i.e., F contains at least one repre-sentative of the symmetry class of any point by (cid:3) in D. This definition applies in particular to L(cid:3) (D) and to R(cid:3)(D). They also define minimal fundamental domains as fundamental domains with no proper closed subset being itself a fundamental domain, a property which also applies to L(cid:3)(D) and to R(cid:3)(D) (see Proposition 2).Considering domains restricted to [0, 1]n for simplicity,8 they propose a method for constructing a fundamental domain F c considering an ordering vector c ∈ Rn (where n is the number of variables of the problem)9:F c((cid:3)) = {x ∈ [0, 1]n : c T x ≤ c T xσ , ∀σ ∈ (cid:3)}.It is easy to see that the constraint fdσ := c T x ≤ c T xσ is a PSBC for the permutation σ , and fd(cid:3) :=for the symmetry group (cid:3).They introduce the universal ordering vector ˆc = (2n−1, 2n−2, . . . , 2, 1) and prove F ˆc is a minimal fundamental domain. We illustrate the universal fundamental domain for the cyclic symmetry groups C2 and C3 in Fig. 6.As this illustration clearly shows, F ˆc((cid:3)) is equivalent to L(cid:3) and to R(cid:3) in 2D (see Figs. 1 page 108 and 4a page 110). However, contrarily to the situation for discrete domains, where they are also equivalent for higher dimensions, F ˆc ((cid:3)) is in general not directly related to L(cid:3) (nor to R(cid:3) ) in higher dimension. For instance, Fig. 4d (page 110) shows RC3 ([0, 1]3), which is significantly different from F ˆc(C3) shown in Fig. 6d. Still, it has the property of being a (closed) minimal funda-mental domain and thus benefits from the same properties as rlex constraints. For instance, the volume of F ˆc(C3) can be 3 , which is the same volume of RC3 ([0, 1]3), computed using Proposition 3formally computed and shown to be equal to 1and Proposition 4. We however consider rlex PSBCs superior to fd PSBCs for several reasons:(17)fdσ is a PSBC (cid:5)σ ∈(cid:3)• The number of fdσ constraints is by essence equal to the number of symmetries σ in the considered symmetry group, i.e., up to factorial, while there is no obvious simplification of this intractable set of constraint;• There is no known efficient (poly-time) way of generating them;• Like lex constraints, each individual fd constraint involves all the variables and is thus costly to prune and propagate;• The coefficients in ˆc induce a numerical instability in floating-point computations since adding 2n−1xn−1 and x0 can yield cancellation when n is large, leading to inaccurate comparisons.4.4. Frisch’s SBCsFrisch et al. propose in [29,30] several alternative encodings of lex constraints. These encodings are equivalent to lexconstraints in discrete domains. Some of them seem appropriate for numerical solvers, but they are in fact not equivalent to lex constraints in continuous domains.For instance, the arithmetic encoding is in fact equivalent to a fundamental domain F c with c = (dn−1, dn−2, . . . , d, 1), where d is the size of the discrete variable domains taken as {0, 1, . . . , d − 1}n. Transposed in the normalized continuous 8 Note that continuous domains in the form of intervals can be mapped to [0, 1]n by subtracting to each interval its lower-bound and dividing it by its width.9 The mentioned paper in fact use the relation ≥ instead of ≤, which is strictly equivalent in terms of symmetry breaking. We change it for an easier comparison to lex and rlex constraints.116A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125Fig. 6. Universal fundamental domains for the cyclic symmetry group in 2D and 3D.Fig. 7. Satisfaction domain of hlexδ[2,3,1] constraint (blue = included, red = excluded).domain [0, 1]n, this encoding thus becomes just the fd constraints, which we have shown to be different of both lex and rlex constraints in the previous section. These constraints are still PSBCs (not SBCs) in the numerical context, but we have explained why rlex constraints should be preferred.Another example is the Harvey encoding which employs a reification of binary comparison:hlexσ := x1 <(cid:7)(cid:8)x1σ + (cid:10)(x2 < (x2σ + (cid:10)(. . . + (cid:10)(xn < (xnσ + (cid:10)(true))) . . .))),(18)where (cid:10) is the reification function which maps true to the integer 1 and false to the integer 0. In the discrete context, hlex constraints are equivalent to lex constraints, but it is not the case in the continuous context since there is no gap of size 1.0 between two possible valuations of a variable. hlex constraints can be adapted by changing the definition of the function (cid:10), making it closer and closer to lex constraints in the continuous context as true is mapped to smaller and smaller values δ ∈ (0, 1], see Fig. 7, giving birth to hlexδ constraints which are valid PSBCs in the continuous context.10 The space they delimit however strictly contains L and it has a volume strictly larger than R, making hlexδ a weaker (P)SBC than both lex and rlex.Again, and similarly to most proposed lex encodings, the first and foremost reason why such encodings are not appro-priate in the continuous context is that they come in factorial number with respect to the number of variables in the worst case, without an efficient (poly-time) method for generating them, and involve all the variables implied in the symmetry in a formula much more complex than rlex constraints. These are the reasons why we consider rlex the most appropriate PSBCs in the continuous context.10 hlex0 is not a valid PSBC since it makes true indistinguishable from false.4.5. Specific PSBCs for NCSPsA. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125117The ad-hoc inequalities proposed in [15,17,16] to partially break specific classes of variable symmetries in NCSPs are just special cases of the rlex constraints. For instance, Gasca et al. [15] proposed PSBCs xi ≤ xi+1 (i ∈ {1, . . . , n − 1}) for full permutations ((cid:3) = Sn), and PSBCs x1 ≤ xi (i ∈ {2, . . . , n}) for cyclic permutations ((cid:3) = Cn). Similar PSBCs have been proposed Spi in [16].for numerical optimization problems with more peculiar symmetry groups, e.g., (cid:3) = C2 × S nLiberti et al. [13,14] suggest some general PSBCs for MINLP (Mixed Integer NonLinear Programming) problems involving inequality constraints only. However no analysis is provided regarding the completeness and optimality of these PSBCs for this class of problems.in [17] and (cid:3) =(cid:11)2i4.6. Symmetric boxes for single-cycle symmetriesA very different strategy from the preceding previous works, not relying on the addition of SBCs, is [12]. From the fact that numerical solvers process only boxes, the authors suggest the utility of the notion of box symmetry, which is the set of points symmetric to those belonging to the box. In the context of variable permutations, the symmetry of a box can be understood as a permutation of its component intervals and, therefore, is another box. Classes of box symmetry are naturally defined, as well as representatives, a member of the class representing the whole class. The approach works by producing a set of representatives, whose symmetries cover the whole domain. The solver is launched with the original problem using each representative as domain, and solutions symmetric to those found within it are generated according to the symmetries of the representative. This approach has been followed in [12] in the context of cyclic permutations. Its main advantage is that the potential burden that SBCs add to the original problem is avoided. However it needs a small program to manage the launching of the representatives. A more serious disadvantage of the algorithm is that the number of representatives grows exponentially with the dimension, which becomes unmanageable when n is large.5. Experimental resultsIn this section, we provide experimental evidence of the important performance gains rlex constraints can bring when solving symmetric NCSPs. For this purpose, we will use a single measure, called gain in the following: the ratio of time11to solve the problem without rlex over that to solve the problem with rlex. Indeed, we expect rlex constraints to quickly eliminate symmetric portions of the search space, isolating an asymmetric search subspace whose volume is divided by |(cid:3)|w.r.t. the initial search space. As a result, we expect to observe gains proportional to |(cid:3)|.All experiments are conducted on a dual-core equipped machine (2.5 GHz, 4 Gb RAM) using the Realpaver [31] con-straint solver with default settings, i.e., AC3-like fixed-point propagation loop using Hull-consistency and Box-consistency contracting operators followed by an Interval Newton application, and balanced bisection splitting following a round-robin principle.We consider a benchmark composed of standard problems picked from [32–35]. The selected test set has representative characteristics: fixed or scalable dimension, various constraint types and complexity, satisfiable or unsatisfiable problems, discrete or continuous solution sets, and of course various symmetry groups. Tables 1 and 2 provide the characteristics (columns “n” and “|(cid:3)|”) of the considered problems and the experimentally obtained gain (column “time”) and number of solutions (column “|χ |”), summarizing 68 individual experiments on problems instances with (columns “rlex”) and without (columns “standard”) our PSBCs. For each scalable problem, the obtained ratios are also graphically depicted in Fig. 8 in comparison to their symmetry group order.We do not compare rlex performances to the related work mentioned in the previous section because, as explained there, they either do not apply in the continuous context, or are subsumed by rlex, and are thus identical to rlex for the classes of symmetry for which they can be applied.5.1. Global analysis of the resultsWithout rlex, the solving time varies from 0.8 s to 3 818 828 s (44d04h47m08s12), with a total solving time of 7 851 611 s (90d21h00m11s) for the 68 experiments. With rlex, the solving time varies from 0.13 s to 132 070 s (1d12h41m10s13), with a total solving time of 228 253.1 s (2d15h24m13s) for the 68 experiments. The gain varies from 0.9814 to 10 166.2,15 for an overall gain (ratio of total solving times for the 68 instances) of 34.4. These figures are a bit biased because our test set comprises problems solved in widely different times. In order to allow a more precise comparison, Table 3 partitions 11 The ratio in number of search nodes could also be interesting but it has two drawbacks: First, it does not measure the impact of the additional rlexconstraints in the propagation cost at each node; Second, contrarily to discrete CSPs, the search tree of numerical CSPs explored when SBCs are added is not a subpart of the search-tree without SBCs since split-point location are affected by the SBCs’ propagation.12 Sparse at dimension n = 7.13 Reimer at dimension n = 614 Eiger at dimension n = 100.15 Extended-Powell at dimension n = 30.118A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125Table 1Characteristics and results for the selected benchmark (part 1). Timings and ratios rounded to (nearest) one decimal, except when too large.ProblemBoonBrownCpdmaCyclic-rootscEigerExtended FreudensteinExtended PowellFeigenbaumn|(cid:3)||χ |Standard6567893456456710020030040050060040608010012014022242628301113151719424120720504040 32062412072081012141002003004005006002.43E182.65E328.16E473.04E648.32E811.18E1008.78E81.15E101.62E112.44E123.92E13111315171983232391 105b23318 81930 57426 148b10245622222211111120484096819216 38432 768200522136835729350rlex33232316 489b222121203319b17422222211111111111204296212503Ratio2.71.01.01.01.01.05.510.588.7254.87.910.03.414.01.01.01.01.01.01.01.01.01.01.01.01.02048.04096.08192.016 384.032 768.010.012.414.216.818.5Time (seconds)Standard34.70.86.979.41419.415 965.7386.796.92856.853 587.458.823.63352.5135 960.122.3348.41634.74927.811 636.622 556.38.841.0124.4291.5638.31173.2135.5342.8854.32095.55083.117.258.4277.3712.61217.0rlex11.20.30.92.510.534.857.85.843.6218.87.62.8284.511 607.722.6281.91375.04224.910 285.017 747.41.98.123.554.6118.5212.50.20.30.40.40.52.05.524.557.5105.7Ratio3.12.77.731.8135.2458.86.716.765.5244.97.78.411.811.71.01.41.21.21.11.34.65.15.35.35.45.5677.51142.72135.75238.710 166.28.610.611.312.411.5a Continuous solution set at n = 3, discrete at n = 4, 5, 6.b Number of enclosing boxes at precision 0.001.c No solution at n = 3, continuous solution set at n = 4, discrete solution set at n = 5, 6, 7.our test set into three classes with respect to their solving time without rlex: easy instances solved in less than an hour, hard instances solved in less than day and intractable instances solved in more than a day. For each category, we provide the total, minimum and maximum solving times and gains. These statistics are complemented by Table 4 which depicts, for the same three classes, the total number of instances, those with gains lower than 1.0, between 1.0 and 10.0 (excluded), between 10.0 and 100.0 (excluded), and larger than 100.0.A counter-productive performance occur for only 1 run out of the 68 experiments, the instance of problem Eiger at dimension n = 100, and the loss in solving time is 2% of 22.3 s, i.e., 0.3 s. A more detailed look at this problem reveals it has only a cyclic symmetry group (order n), very simple binary quadratic constraints and only two fully frontier solutions (see Section 5.2.1 for a detailed analysis of the influence of these features). Another problem in our benchmark has similar characteristics: Vrahatis. As expected, its gains, though never counter-productive, also appear very small in comparison to its symmetry group order. The fact rlex constraints are inefficient for these two problems is easily explained: the original constraints in both problems are already efficiently filtered (as testified by the very large dimensions that can be tackled, and the fact their solving require a single split) and thus propagating rlex constraints (numerous due to the large considered dimensions) does not bring useful additional reductions while it induces a small additional cost.Oppositely, very good performances (i.e., gains greater than 10.0) occur for 33 runs out of 68, 17 of them providing gains even greater than 100.0. Such outstanding gains are obtained for problems Brown, Cpdm, Extended-Powell, Noon and Wright at large enough dimensions. This is again easily explained: these problems have factorial-order symmetry groups and, in general,16 an exponentially growing solution set with n, also exponentially reduced by rlex.16 It is not the case for Brown and Noon.A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125119Table 2Characteristics and results for the selected benchmark (part 2). Timings and ratios rounded to (nearest) one decimal, except when too large.Problemn|(cid:3)|HénonIkedaNoonReimerSparseVirasoroVrahatisWright20304050681012145678945645678100200300400500600789101015202534567120720504040 320362 880412362412072050408100200300400500600504040 320362 8803 628 800|χ |Standard104108210 808112 45291723537313159101182472000028802222221282565121024rlex1475567452757713133322222200001822222222891011Ratio7.414.419.124.81.82.43.34.15.64.35.04.55.05.54.012.036.01.01.01.01.01.581.01.01.01.01.01.01628.451.293Time (seconds)Standard15.6549.213 070.3212 440.07.073.5471.03072.121 806.435.161.5158.0590.41607.24.12193.23.29E61.062.66164.73.82E6146 938.649.1508.42088.05923.313 454.025 346.711.5117.81367.016 623.1rlex2.350.4873.610 291.93.424.9137.8754.94447.10.70.50.71.01.51.1242.0132 070.00.11.729.21845.317 399.132.7249.2832.41959.03827.36324.80.20.51.63.7Table 3Timings (in seconds) and gains statistics classified in easy (less than an hour), hard (less than a day) and intractable (more than a day) instances.EasyStd31 353.60.773352.5TotalMinMaxrlex5062.80.131375.0Gain6.191.05238.7HardStd216 145.34927.853 587.4rlex49 976.20.517 747.4Gain4.31.110 166.2IntractableStd7.60E61.35E53.82E6rlex1.73E51845.31.32E5Ratio6.810.915.020.62.12.93.44.14.950.1123.0225.7590.41071.53.79.024.910.036.8211.12070.18.41.52.02.53.03.54.057.5235.6854.44492.7Gain43.98.42070.1Table 4Partition of the benchmark with respect to the observed gains, classified easy (less than an hour), hard (less than a day) and intractable (more than a day) instances.GainsAll[0, 1)[1, 10)[10, 100)[100, +∞)Easy501261211Hard130715Intractable50041To sum up, these general statistics demonstrate that rlex constraints can provide important gains in solving time and seem harmless to use since the additional propagation cost they may induce is only slightly counter-productive in the worst case. In our opinion, this validates their practical relevance.5.2. Detailed analysis of the resultsA detailed look at Tables 1 and 2 reveals that rlex performance does not live up to our expectations in many cases, i.e., the gain is often much lower than, and even not proportional to, the order of the symmetry group of the considered instance. Apart from the cases where rlex constraints are counter-productive and that we have already explained, one can note that for most of the problems with factorial-order symmetry groups, the gains seem smaller than factorial, apparently 120A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125Fig. 8. Results for scalable problems: ratios in number of solutions (o) and in solving time (+); symmetry group order (plain line).exponential for many problems, and even polynomial for Sparse and constant for Extended-Freudenstein (see Fig. 8). In fact the observed gain is always lower than the order of the symmetry group, with the exception of Virasoro for which rlexconstraints strangely perform even better than expected.This leads us to examine more closely the rationale behind our gain expectation, and to suggest that there are two very general factors affecting such gain, which emerge from the ways the rationale can be falsified in our benchmark. Then, we A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125121exemplify the dependency of the gain on the features of the solver. Finally, we offer some insights on the potential effect of using different variations of rlex, like transitive closure application and lex ordering.5.2.1. Rationale for the gain expectationFrom now on, we will call Constrained Space (CS) the space previously denoted by R(cid:3) (x). The argument for an expected gain given by the ratio between the domain volume and the CS volume, |(cid:3)|, relies on the following assumptions:A The time for processing a box inside CS is approximately the same with or without rlex constraints. The base of this assumption is that rlex constraints are much simpler than typical nonlinear constraints. For this reason, the cost of propagating rlex should be negligible compared to the cost of propagating the constraints of the problem.B The time for discarding boxes outside CS with rlex can be neglected with respect to the global solving time. This assumption relies on the fact that a box outside CS violates some rlex constraint which, when considered during the propagation loop, will discard the box instantly at a very low cost. Then we can consider that, when rlex constraints are added, the domain of the problem is virtually restricted to CS at no cost.C The processing time is homogeneous across the domain. That is, the time to process a fixed-size volume is the same everywhere.If the above assumptions hold, one can then conclude that the time to solve the problem without and with rlex should respectively be proportional to the initial domain volume and to the CS volume, yielding a gain equal to |(cid:3)|. The first two assumptions can be easily trusted for most problems of interest (i.e., difficult ones), which are composed of complex non-linear constraints. The cases when they are evidently not valid are the counter-performing ones we have already discussed. The validity of the third assumption is less obvious as the following paragraphs reveal.Solution processing prevalence Assumption (C) gets too far away from reality in many problems. Indeed, the processing time is often concentrated in the areas around the solutions whereas large infeasible portions of the domains are discarded instantly. For that specific kind of problems it is appropriate to substitute Assumption (C) by:D A distinct box exists for each solution such that the cost of processing such boxes of symmetric solutions is the same and that the time to process the space outside all these boxes is negligible.If we further assume that the processing cost of such a box is the same for all classes, assumptions (A), (B) and (D) together yield the conclusion that the solving time gain should be the ratio of the number of solutions without rlex over that with rlex. This ratio depends on the cardinality and the number of elements satisfying rlex for each solution class:(cid:12)(cid:12)x∈lex(cid:3) (χ )|x(cid:3)||R(cid:3)(x(cid:3))| .x∈lex(cid:3) (χ )(19)For an interior solution x, we have |x(cid:3)| = |(cid:3)| and |R(cid:3)(x(cid:3))| = 1. Thus, if a problem has only interior solutions the above ratio is |(cid:3)|. Therefore, in this kind of problems, homogeneity and solution processing prevalence assumptions yield the same gain expectation. In our test set, only problems Cyclic-roots in dimensions n = 5, 7 and Reimer are of this kind.The gains observed for problems Feigenbaum, Henon and Ikeda are also clearly influenced by this factor and they follow quite closely (19) though these problems do not have only interior solutions. In fact, it turns out they have a large majority of interior solutions and only a few frontier solutions, explaining the observed behavior.Although the set of frontier points has zero volume, in practice it is not so rare that symmetric problems have frontier solutions. The existence of frontier solutions makes (19) smaller than |(cid:3)|. This is particularly striking for problems Brown, Extended-Freudenstein, Eiger and Vrahatis which have only fully-frontier solutions (i.e., the same set of solutions is found with and without rlex). The two latter problems have already been discussed as they present inefficient gains. The two former ones have factorial order symmetry groups but only exponential and constant gains, respectively.Problems with continuous solution sets, like Cyclic-roots of dimension n = 4 and Cpdm of dimension n = 3, are another case of the solution prevalence type. Moreover, in most cases they have a gain not too far from |(cid:3)|. Although their solution manifolds may intersect with the frontier of CS, it is sufficient that the dimensionality of the overlap is lower than that of their solution set to have a majority of boxes enclosing interior solutions. Therefore gains of the order of |(cid:3)| are generally obtained, sometimes with significant accuracy.In order to confirm the impact of solution prevalence on the expected gain, we have prepared a specific problem gener-ator parameterized by the dimension of the problem n, the number of repetitions r of the smallest coordinate in the single solution class representative s to the problem, and the symmetry group (cid:3). The generated problems have a single constraint of the form⎛⎞(cid:13)⎝(cid:16)σ ∈(cid:3)i∈[1,n](xi − siσ )2⎠ = 0,(20)122A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125Fig. 9. Experimental time ratio (plain) and number of solutions ratio (19) (dashed) for generated problems (20) of dimension n = 6 under Cyclic symmetry (order n, squares), 2-Cyclic+Mirror symmetry (order n2, circles) and Full permutation symmetry (order n!, triangles).where the solution class representative s satisfies si = max(0, i − r − 1)2, i.e., the solutions are all symmetries of s =, 1, 4, 9, . . .). When r = 0, the generated problems have only interior solutions, all members of the same sym-(0, . . . , 0(cid:19) (cid:20)(cid:21) (cid:22)r+1 timesmetry class. In this case, we expect the gains to be proportional to the order of the considered symmetry group at the considered dimension. When r increases, the size of the solution class decreases, eventually reaching 1 when r = n − 1, in which case the solution is s = (0, . . . , 0). The gains should also decrease according to (19). Fig. 9 displays the evolution of the gain in dimension n = 6 for three different symmetry groups when the number of repetitions r varies. In all cases, it is clear that the gain decreases with the increase in the number of repetitions, i.e., the degree of frontierness of the solutions, which in turn determines the numbers of solutions with and without rlex, having an important impact on the gain. The shapes of gain evolution and ratios of solution numbers are indeed strikingly proportional. Still they are not identical and the gains are always worse than the expected ones according to (19). We explain this phenomenon with another factor: the frontier effect.Frontier effect There are problems with no solution prevalence or without solutions at all in which gains are very different from |(cid:3)|. Something besides homogeneous processing is failing in the premises of Subsection 5.2.1. One symptom is box classification in inside and outside CS; frontier boxes, partially inside and partially outside CS are neglected. And they turn out to be a significant fraction, or even the predominant type of boxes in some problems, e.g., Ext.-Freudenstein, Wright and, in minor degree, Feigenbaum.The reason is that the assumption of constant time cost for a fixed volume size can be falsified not only by the position but also by the shape of the volume when using a box-oriented solver. Suppose we have to pave the domain and CS with boxes. If only one box is used, the tightest enclosing one, the box is the same in both cases and coincides with the domain, itself a frontier box. Thus, there is no difference in the paving despite CS is |(cid:3)| times smaller. If we allow a greater number of boxes, they become smaller, the volumes covered in the CS and the domain case differ progressively. Asymptotically, the ratio of volumes covered tend to |(cid:3)| and the fraction of frontier boxes in CS tends to zero.Another facet of the same frontier effect phenomenon, is considering the size of the leaf boxes in the search tree whenrlex are added. It can happen that the size of a leaf is too big to be completely inside CS (because of its shape, the leaf can be at the same time much smaller than the domain), but small enough to be discarded or to converge to a solution in the given problem. It is, thus, a frontier box, eventually one scarcely overlapping CS. This would mean that the pruning power of rlex has not been exploited effectively. The smaller the CS size with respect to the domain size, the more easily this may occur. On the opposite side, given a fixed a symmetry and its associated CS, the smaller the leaf boxes, the more immune the problem to the frontier effect.The frontier effect thus depends on two factors: the relative volumes of CS and initial domain, and the precision at which the problem is solved.To sum up, solution processing prevalence overrides the importance of the volume in the time cost. When there is no solution prevalence, the ratio of volume processing cost is mainly influenced by the frontier effect.5.2.2. Impact of rlex variantsThe set of rlex constraints for a given symmetry group is in general not unique. We study here the impact of various possible sets on the observed gains.Transitive closure The set of rlex constraints of a given symmetry group can be minimized, keeping only inequalities which are not transitively implied by other inequalities in the set. Such a minimal set comprises at most n inequalities for a problem in dimension n. Conversely, it can be maximized considering the transitive closure of all inequalities, yielding A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125123at most n2 inequalities for a problem in dimension n. Of course, all intermediate sets between these two extremes also constitute a valid set of PSBCs.In theory, the maximal set could be preferred because it may accelerate interval propagation. For instance, the reduction of the domain of x1 in a problem with full permutation symmetry can be propagated instantly to the domain of xn if therlex inequality x1 ≤ xn is imposed, while it will require n − 1 propagation loops if only rlex inequalities of the form xi ≤ xi+1are considered. On the other hand, the minimal set could be preferred since it may comprise significantly less constraints, possibly reducing importantly the number of applied contracting operators to achieve a fix-point of interval propagation. For example, in order to realize that no reduction at all is possible on the domain of any variable, each contracting operator must be applied once, i.e., only n for the minimal set in contrast with n2 for the maximal set.In practice, however, we have observed that considering either the minimal set or the maximal set results in very similar timings for most problems. This is in particular the case for problems Brown, Cyclohexane, Extended-Powell, Noon, Sparse and Wright, i.e., problems with very different minimal and maximal sets (typically n and n2 inequalities, respectively) and for which the gain with maximal PSBCs over that with minimal PSBCs vary between 0% and 8%, sometimes in favor of the maximal set, sometimes in favor of the minimal set. The only exception is for problem Extended-Freudenstein for which solving times are approximately 3 times faster with the maximal set than with the minimal set. This problem, like the Extended-Powell problem, has a very specific structure: it is made of the repetition n2 times of a subsystem of 2equations. But unlike Extended-Powell, this one has a single solution. Hence, the contraction of the domain of the variables in any subproblem of 2 equations can be immediately propagated to the domains of the variables of all other duplicated subproblems. It appears that the maximal set of rlex, with its redundant inequalities, exploits this property to its best, allowing a much faster convergence of the solver towards the unique solution.Except for such peculiar cases, we should thus conclude that using a minimal set of rlex or a maximal set of rlex has almost no impact, and so we recommend using the minimal, non-redundant, set as it involves a lot fewer constraints in general.Lexicographic order The variable ordering underlying the considered lexicographic order also impacts the set of generatedrlex, not only in the name of the involved variables but even in cardinality. For instance, consider the symmetry group generated by compositions of σ = [2, 1, 4, 5, 6, 3]. It is composed of two synchronized cyclic symmetries, one on the first two variables, the other one on the last four variables. The two corresponding rlex constraints obtained with the standard variable order are x1 ≤ x2 and x3 ≤ x5. If the variable order chosen to build rlex begins by x3 instead of x1, we obtain the rlex constraints x3 ≤ x4, x3 ≤ x5 and x3 ≤ x6, i.e., a set of three PSBCs instead of two.Besides the variables involved and cardinality of the generated rlex, the variable order can influence also the number of symmetries broken for the solutions and, thus, the number of symmetric solutions found with rlex. Indeed, a variable order can confer a frontier character to a solution while another one can make it an interior point. However, it is difficult to take advantage from this in practice because it requires the previous knowledge of the solutions.For the problems in our benchmark more prone to be impacted by a change in variable ordering (we have excluded those with full permutation of all variables and those with full cycle of all variables), we have compared runs with several variable orderings and it appears this factor does not have a very important impact on the observed gains: 0% to 10% difference in solving time.We conclude the variable ordering does not have a very important role in the performance of rlex constraints in general.5.2.3. Interest of rlex in other solving contextsIn the whole previous section, we have considered only the problem of finding all solutions (up to a given precision) of the considered problems, whether they have continuous solution sets, discrete solution sets or empty solution sets. Another perspective on rlex efficiency consists in searching for a single solution of the considered NCSPs, i.e., solving them as decision problems.Part of the answer is already included in Tables 1 and 2: for problems having no solution (Sparse), a single solution (Extended Freudenstein), or an identical (and small) solution set with or without rlex constraints (Brown, Eiger, Vrahatis), the obtained gains validate their interest in such settings too.Considering the other problems in our test set, those with large, or largely varying with and without rlex constraints, solution sets, the figures are very unstable: for problems with continuous solution sets (CPDM at n = 3, Cyclic-roots at n = 4), the decision problem is answered identically fast (< 0.05 s) with and without rlex; For other problems, either the decision problem is solved faster without rlex (CPDM at n = 4, 5, 6, Cyclic-roots at n = 5, 7, Extended Powell at n =22, 24, 26), or it is solved almost as fast with and without rlex (Feigenbaum at n = 11, 13, Ikeda at all considered n, Noon at n = 5, 6, 7), or else it is solved faster with rlex constraints (all other 48 instances).The fact no predictable behavior is observed is easily interpreted: the search with and without rlex constraints proceeds in a totally different way since, due to contracting boxes with rlex constraints, the split points are generally different in both cases yielding a totally unrelated search tree, unlike what happens in the discrete case where the search-tree with PSBCs is a subpart of that without PSBCs.124A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125The overall statistics are however in favor of rlex constraints since when they are counter-productive the solving time are typically small17 and the gain remains above 0.2 in all cases, while solving time vary from small to significant (>100 s) and gains grow up to 81618 when rlex constraints are used. The most favorable gains are in fact observed when the first solution found is identical with and without rlex, indicating the search strategy operates similarly in both cases, just avoiding unnecessary branches that are pruned by our PSBCs.6. Conclusion and future prospectslex constraints are known to break exactly every variable symmetry retaining only a representative member of each class. They are valid for all kinds of problems, independently of the nature of the domains. However, the number of lexconstraints is potentially factorial in the number of variables. Moreover, we have shown they are impractical for numerical solvers.To overcome these drawbacks, we have proposed the rlex PSBCs, a set of simple inequalities between two variables. The maximum number of non-redundant constraints in rlex is linear in the number of variables. Besides they are easily handled by numerical solvers, which are able to quickly propagate them. They can be considered a generalization of PSBCs proposed for particular symmetry groups in some previous works.We have shown that rlex are a relaxation of lex with optimal properties. In fact, they enclose a space which is the closure of that enclosed by lex SBCs, and we have proved both have the same volume. A detailed analysis of rlex PSBCs also shows that their filtering power is almost identical to complete SBCs in the context of numerical CSPs.The experiments we have conducted on a benchmark of standard problems with various characteristics and sizes demon-strate the practical efficacy of rlex constraints: (almost) never counterproductive, they induce gains in solving time which can be factorial for problems with symmetry groups of large orders. Still, the presented results also demonstrate these gains are not always directly proportional to the symmetry group order, and we have thoroughly analyzed the reasons why.All the arguments we have used are also valid for continuous (constrained) optimization. rlex can also be interesting in discrete domains, though Jefferson and Petrie [22] have demonstrated there exist superior PSBCs in this context. Still, in discrete domains with many values for each variable, the frontier (in which reside the only symmetry classes not completely broken by rlex) will be small with respect to the domain. Hence, we should also consider Mixed-Integer Nonlinear Pro-gramming and Integer Linear Programming for which some of the PSBCs we have generalized have been proposed [17,36].AcknowledgementsThe authors have been financially supported by the following grants for this research: Spanish project RobCab (DPI2014-57220-C2-2-P), Robotics Group of the Generalitat de Catalunya (SGR2014-1102), University of Nantes international exchanges program (CURI-2009).References[1] A. Goldsztejn, C. Jermann, V. Ruiz de Angulo, C. Torras, Symmetry breaking in numeric constraint problems, in: CP 2011, in: LNCS, vol. 6876, Springer, [2] X.-H. Vu, H. Schichl, D. Sam-Haroud, Interval propagation and search on directed acyclic graphs for numerical constraint solving, J. Glob. Optim. 45 (4) 2011, pp. 317–324.(2009) 499–531.[3] J.-P. Merlet, Interval analysis for certified numerical solution of problems in robotics, Appl. Math. Comput. Sci. 19 (3) (2009) 399–412.[4] A. Goldsztejn, Y. Lebbah, C. Michel, M. Rueher, Capabilities of constraint programming in safe global optimization, in: International Symposium on Nonlinear Theory and Its Applications, 2008, pp. 601–604.[5] I. Gent, K. Petrie, J.-F. Puget, Symmetry in constraint programming, in: Handbook of Constraint Programming, Elsevier, 2006, pp. 329–376.[6] T. Walsh, Breaking value symmetry, in: Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence, 2008, pp. 1585–1588.[7] T. Walsh, Parameterized complexity results in symmetry breaking, in: Parameterized and Exact Computation, Proc. 5th International Symposium IPEC, in: LNCS, vol. 6478, Springer, 2010, pp. 4–14.[8] P. Meseguer, C. Torras, Exploiting symmetries within constraint satisfaction search, Artif. Intell. 129 (1–2) (2001) 133–163.[9] I. Gent, Groups and constraints: symmetry breaking during search, in: CP 2002, in: LNCS, vol. 2470, Springer, 2002, pp. 415–430.[10] P. Flener, A. Frisch, B. Hnich, Z. Kiziltan, I. Miguel, Breaking row and column symmetries in matrix models, in: CP ’02: Proceedings of the 8th Interna-tional Conference on Principles and Practice of Constraint Programming, Springer, 2002, pp. 462–476.[11] J.-F. Puget, Symmetry breaking revisited, Constraints 10 (1) (2005) 23–46.[12] V. Ruiz de Angulo, C. Torras, Exploiting single-cycle symmetries in continuous constraint problems, J. Artif. Intell. Res. 34 (2009) 499–520.[13] L. Liberti, Reformulations in mathematical programming: automatic symmetry detection and exploitation, Math. Program. 131 (1–2) (2012) 273–304.[14] L. Liberti, J. Ostrowski, Stabilizer-based symmetry breaking constraints for mathematical programs, J. Glob. Optim. 60 (2) (2014) 183–194.[15] R. Gasca, C.D. Valle, V. Cejudo, I. Barba, Improving the computational efficiency in symmetrical numeric constraint satisfaction problems, in: 11th Conference of the Spanish Association for Artificial Intelligence, CAEPIA, 2005, pp. 269–279.[16] X. Ji, F. Ma, J. Zhang, Solving global unconstrained optimization problems by symmetry-breaking, in: 8th IEEE/ACIS International Conference on Com-puter and Information Science, 2009, pp. 107–111.[17] A. Costa, L. Liberti, P. Hansen, Formulation symmetries in circle packing, Electron. Notes Discrete Math. 36 (2010) 1303–1310.[18] J. Crawford, M. Ginsberg, E. Luks, A. Roy, Symmetry-breaking predicates for search problems, in: KR, 1996, pp. 148–159.17 Except for Cyclic-roots at n = 7 solved in 380 s without rlex and 1320 s with rlex.18 Noon at n = 8 is solved in 490 s without rlex and in 0.6 s with rlex.A. Goldsztejn et al. / Artificial Intelligence 229 (2015) 105–125125[19] D. Cohen, P. Jeavons, C. Jefferson, K. Petrie, B. Smith, Symmetry definitions for constraint satisfaction problems, Constraints 11 (2–3) (2006) 115–137.[20] N. Narodytska, T. Walsh, Breaking symmetry with different orderings, in: Principles and Practice of Constraint Programming, in: LNCS, vol. 8124, 2013, pp. 545–561.[21] A. Frisch, B. Hnich, Z. Kiziltan, I. Miguel, T. Walsh, Propagation algorithms for lexicographic ordering constraints, Artif. Intell. 170 (2006) 803–834.[22] C. Jefferson, K. Petrie, Automatic generation of constraints for partial symmetry breaking, in: CP 2011, in: LNCS, vol. 6876, Springer, 2011, pp. 729–743.[23] A.V. Aho, M.R. Garey, J.D. Ullman, The transitive reduction of a directed graph, SIAM J. Comput. 1 (2) (1972) 131–137.[24] J.-F. Puget, Breaking symmetries in all different problems, in: Proc. 19th International Joint Conference on Artificial Intelligence, IJCAI, 2005, pp. 272–277.[25] C. Sims, Computational methods in the study of permutation groups, in: Computational Problems in Abstract Algebra, Pergamon Press, 1970, pp. 169–183.[26] B.D. McKay, A. Piperno, Practical graph isomorphism, II, J. Symb. Comput. 60 (2014) 94–112.[27] E.J. Friedman, Fundamental domains for integer programs with symmetries, in: First International Conference on Combinatorial Optimization and Applications, in: LNCS, vol. 4616, Springer, 2007, pp. 146–153.[28] F. Diaz y Diaz, E. Friedman, Signed fundamental domains for totally real number fields, Proc. Lond. Math. Soc. 108 (4) (2014) 965–988.[29] A.M. Frisch, B. Hnich, Z. Kiziltan, I. Miguel, T. Walsh, Propagation algorithms for lexicographic ordering constraints, Artif. Intell. 170 (10) (2006) 803–834.[30] H.A. Elgabou, A.M. Frisch, Encoding the lexicographic ordering constraint in sat modulo theories, in: Thirteenth International Workshop on Constraint Modelling and Reformulation, ModRef 2014, 2014, pp. 85–96, http://web.udl.es/usuaris/q4374304/modref2014.pdf.[31] L. Granvilliers, F. Benhamou, Algorithm 852: Realpaver: an interval solver using constraint satisfaction techniques, ACM Trans. Math. Softw. 32 (2006) 138–156.[32] COPRIN, The COPRIN examples page, http://www-sop.inria.fr/coprin/logiciels/ALIAS/Benches/, 2011.[33] COCONUT European Project, The COCONUT benchmark, http://www.mat.univie.ac.at/~neum/glopt/coconut/Benchmark/Benchmark.html, 2003.[34] PHCPack, The database of polynomial systems, http://homepages.math.uic.edu/~jan/demo.html, 2003.[35] A. Goldsztejn, L. Granvilliers, C. Jermann, Constraint based computation of periodic orbits of chaotic dynamical systems, in: 19th International Confer-ence on Principles and Practice of Constraint Programming, CP’13, in: LNCS, vol. 8124, 2013, pp. 774–789.[36] F. Margot, Symmetry in integer linear programming, in: 50 Years of Integer Programming 1958–2008, Springer, 2010, pp. 647–686.