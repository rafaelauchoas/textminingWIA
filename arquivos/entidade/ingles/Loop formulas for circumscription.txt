Artificial Intelligence 170 (2006) 160–185www.elsevier.com/locate/artintLoop formulas for circumscriptionJoohyung Lee a, Fangzhen Lin b,∗a Department of Computer Science and Engineering, Arizona State University, AZ, USAb Department of Computer Science, Hong Kong University of Science and Technology, Clear Water Bay,Kowloon, Hong KongReceived 4 April 2005; received in revised form 13 September 2005; accepted 14 September 2005Available online 2 November 2005AbstractClark’s completion is a simple nonmonotonic formalism and a special case of several non-monotonic logics. Recently there has been work on extending completion with “loop formulas” sothat general cases of nonmonotonic logics such as logic programs (under the answer set seman-tics) and McCain–Turner causal logic can be characterized by propositional logic in the form of“completion + loop formulas”. In this paper, we show that the idea is applicable to McCarthy’s cir-cumscription in the propositional case, with Lifschitz’s pointwise circumscription playing the roleof completion. We also show how to embed propositional circumscription in logic programs and incausal logic, inspired by the uniform characterization of “completion + loop formulas”. 2005 Elsevier B.V. All rights reserved.Keywords: Nonmonotonic reasoning; Commonsense reasoning; Knowledge representation; Circumscription;Clark’s completion; Loop formulas; Logic programming1. IntroductionClark’s predicate completion [5] is a simple and intuitive nonmonotonic formalism.Normally it is applicable when the knowledge base is given as a set of rules, and workswhen the rules do not yield a “cycle”.* Corresponding author.E-mail address: flin@cs.ust.hk (F. Lin).0004-3702/$ – see front matter  2005 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2005.09.003J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185161Despite these limitations, surprisingly perhaps, predicate completion has been used tosolve many problems that were thought to require more sophisticated nonmonotonic logics.For instance, Reiter [34] showed that under certain reasonable assumptions, successor stateaxioms can be computed from action effect axioms by predicate completion, and thussolved the frame problem when there are no state constraints. For state constraints, Lin[25] argued that they should be encoded using a notion of causality, and once they areencoded this way, successor state axioms can once again be computed using predicatecompletion for a class of causal rules that includes almost all of the benchmark planningdomains [25,27].For the “definite” fragment of McCain–Turner causal logic [10,28], the problem of de-termining whether a theory is consistent can be reduced to the satisfiability problem forpropositional logic by the process of “literal completion”—a translation similar to Clark’scompletion. This idea has led to the creation of the Causal Calculator (CCALC),1 a systemfor representing commonsense knowledge about action and change. After turning a definitecausal theory into a classical propositional theory, CCALC finds the models of the latterby invoking a satisfiability solver, such as CHAFF,2 SATO3 and RELSAT,4 which in turncorrespond to the models of the given causal theory. CCALC has been successfully appliedto several challenge problems in the theory of commonsense knowledge [1,4,18,23] and tothe formalization of multi-agent computational systems [2,3].In logic programming where predicate completion is best known and commonly re-ferred to as program completion semantics, its relationships with other semantics, espe-cially the answer set semantics (also known as the stable model semantics) of Gelfondand Lifschitz [9], have been studied quite extensively. First of all, it is well known that ananswer set for a normal logic program is also a model of its completion, while the con-verse, generally, does not hold. Fages [8] showed that a certain syntactic condition, whichis now called “tightness”, is sufficient for establishing the equivalence between them. Er-dem and Lifschitz [7] generalized Fages’ theorem and extended it to programs with nestedexpressions (in the sense of [17]) in the bodies of rules.Instead of looking for conditions that will guarantee the equivalence between the com-pletion semantics and the answer set semantics, Lin and Zhao [24] considered how tostrengthen completion to make it equivalent to the answer set semantics. The idea is that,since the presence of cycles is what causes the mismatch between the models of the com-pletion and the answer sets for a program, one should address the problem raised by themdirectly. The completion semantics captures the intuition that for an atom to be true, oneof the bodies of the rules with the atom as the head must be true. Similarly, Lin and Zhaoassociated with each loop a “loop formula” that captures the intuition that for the atoms ina loop to be true, there must be a rule whose head belongs to the loop, and whose bodyis true but its positive part does not have any atom in the loop. They showed that a set ofatoms is an answer set for a nondisjunctive logic program iff it is a model of the completionand all loop formulas of the program. This idea allows SAT solvers to be used for finding1 http://www.cs.utexas.edu/users/tag/ccalc/.2 http://www.ee.princeton.edu/~chaff/.3 http://www.cs.uiowa.edu/~hzhang/sato.html.4 http://www.almaden.ibm.com/cs/people/bayardo/resources.html.162J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185answer sets and thus has led to the creation of SAT-based answer set solvers ASSAT [24]and CMODELS-2 [11].As it turned out, program completion and loop formulas are not limited to nondisjunc-tive logic programs. Lee and Lifschitz [12] extended the Lin/Zhao theorem to disjunc-tive logic programs and, more generally, to arbitrary programs with nested expressions.Lee [13] showed that a similar result can be obtained for McCain and Turner causal logicand based on this, showed how to embed logic programs in causal logic.Given these results, one wonders how far this idea of “completion + loop formulas”can go. Is it general enough to capture other nonmonotonic logics? In this paper, we an-swer this question positively for circumscription [29,30] in the propositional case. Thus itis interesting to observe that these apparently different nonmonotonic formalisms have auniform view of “completion + loop formulas”. Using this idea, we show how to embedcircumscription in logic programs and in McCain–Turner causal logic.Hopefully, these results will lead to good implementations of propositional circumscrip-tion using SAT solvers and/or answer set solvers. This would be a significant progress innonmonotonic reasoning as circumscription has found applications in commonsense rea-soning, model-based diagnoses, discourse understanding, and others. While many of theseapplications in general make use of first-order circumscription, they can be solved usingpropositional circumscription when their domains are given and finite.This paper is organized as follows. In Section 2, we introduce some notations that wewill use in the rest of the paper, and recast the definition of circumscription in the propo-sitional case. In Section 3, we discuss Clark’s completion, and compare it with Lifschitz’spointwise circumscription [20], as the latter will serve as “completion” for our purpose. InSection 4, we introduce the notion of a loop via the notion of a dependency graph. Section 5contains the main technical results of the paper, which shows that circumscription can becharacterized by completion plus loop formulas. It also discusses some related work. Basedon the results in Section 5, Section 6 shows how circumscription can be embedded in logicprograms under the answer set semantics and in McCain–Turner causal logic. We concludein Section 7.2. Logical preliminariesA literal is a (propositional) atom or the negation of an atom. A (propositional) formulais formed from literals using propositional connectives. A clause is a finite set of literals.We identify a clause C with the disjunction of its elements. It is well known that anyformula can be transformed into an equivalent set of clauses.We use variables that range over 0-place connectives (cid:2) and ⊥, and quantify overthem. For instance, if A(z, p1, . . . , pk) is a propositional formula built with propo-sitional variables z, p1, . . . , pk, we write ∀zA(z, p1, . . . , pk) to denote the formulaA((cid:2), p1, . . . , pk) ∧ A(⊥, p1, . . . , pk), and similarly ∃zA(z, p1, . . . , pk) to denote the for-mula A((cid:2), p1, . . . , pk) ∨ A(⊥, p1, . . . , pk).In the following, we sometimes write a formula A as A(P ) or A(P , Q) for tuples P andQ of atoms. This way, when X is a tuple of variables and atoms of the same length as P ,we use A(X) or A(X, Q) to denote the result of simultaneously replacing all elementsJ. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185163of P in A by the corresponding elements of X. We sometimes identify a tuple with thecorresponding set when there is no confusion.For P = (p1, . . . , pn), Q = (q1, . . . , qn),P (cid:1) Q stands forP = Q stands forP < Q stands for(cid:1)(pi ⊃ qi),1(cid:1)i(cid:1)n(cid:1)(pi ≡ qi),1(cid:1)i(cid:1)n(P (cid:1) Q) ∧ ¬(P = Q).Let P and Z be tuples of atoms, and A(P , Z) a formula. The circumscription of P inA(P , Z) ∧ ¬∃XYA(P , Z) with atoms in Z allowed to vary, is the following formula:(cid:2)A(X, Y ) ∧ X < P(cid:3).(1)The formula is denoted by CIRC[A(P , Z); P ; Z], which may also be written asCIRC[A(P ); P ] when Z is empty.The second conjunct of formula (1) is actually a propositional formula as in the follow-ing example:CIRC[p ∨ q; p] = (p ∨ q) ∧ ¬∃x(cid:4)(cid:2)= (p ∨ q) ∧ ¬(cid:3)(cid:2)(x ∨ q) ∧ (x ⊃ p) ∧ (x (cid:10)≡ p)(cid:3)((cid:2) ∨ q) ∧ ((cid:2) ⊃ p) ∧ ((cid:2) (cid:10)≡ p)(cid:2)(⊥ ∨ q) ∧ (⊥ ⊃ p) ∧ (⊥ (cid:10)≡ p)(cid:3)(cid:5)∨≡ (p ∨ q) ∧ ¬(p ∧ q).(2)The models of the circumscription are {p} and {q}.5There is a weaker notion of circumscription that will turn out to be important here. Thisis Lifschitz’s pointwise circumscription [20]. In the propositional case, given an atom pand a tuple Z of atoms, the pointwise circumscription of p in A(p, Z) with Z allowed tovary isA(p, Z) ∧ ¬∃xYA(x, Y ) ∧ x < p(cid:2)(cid:3),(3)and the pointwise circumscription of a tuple P of atoms in A with Z allowed to vary is theconjunction of the pointwise circumscription of each p ∈ P in A with Z allowed to vary.It can be seen that (3) is equivalent to CIRC[A; p; Z]. Thus the pointwise circumscriptionof a tuple P of atoms in A with Z allowed to vary isp∈P CIRC[A; p; Z].(cid:6)For two interpretations (i.e., truth assignments) I , J of the same signature, we writeI (cid:1)P ;Z J 6 if• I and J agree on all atoms that are not in P and Z, and• for each pi in P , if pi ∈ I then pi ∈ J .We write I <P ;Z J if I (cid:1)P ;Z J but not J (cid:1)P ;Z I .5 We identify an interpretation with the set of atoms that are true in it.6 We may even write I (cid:1)P J when Z is empty.164J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185The following proposition (Proposition 1 from [19]) provides a model-theoretic accountof circumscription.Proposition 1. An interpretation I is a model of CIRC[A; P ; Z] iff it is minimal7 on Pwith Z allowed to vary, that is,• I is a model of A, and• there is no model J of A such that J <P ;Z I .For example, among the three models of p ∨ q, {p, q} is not a model of CIRC[p ∨ q; p]because {q} <p {p, q}.3. Completion and pointwise circumscriptionClark’s completion turns “if” conditions into “if and only if” conditions. For instance,given the following rules about Wet,Raining ⊃ WetSprinklerOn ⊃ Wet,Clark’s completion, when applied to Wet, yieldsWet ≡ Raining ∨ SprinklerOn.The underlying assumption here is what has been called the closed world assumption [32]:the given knowledge base contains complete knowledge about what can make Wet true.In particular, if there is no rule about a proposition, say p, then it is assumed to be false:p ≡ ⊥.In general, we have the following definition.Definition 1. Let A be a set of formulas of the form G ⊃ p where G is a formula and p is anatom, and suppose that the following are the only implications in A with the consequent q:G1 ⊃ q, . . . , Gn ⊃ q. Then Clark’s completion of A on q is q ≡ G1 ∨ · · · ∨ Gn. Noticethat when n = 0, this is q ≡ ⊥. For a set P of atoms, Clark’s completion of A on P is theconjunction of Clark’s completions of A on p, for all p ∈ P .Logically, Clark’s completion on q is equivalent to adding to A the sentence q ⊃ G1 ∨· · · ∨ Gn, i.e., making the weakest sufficient condition of q also its necessary condition.Unfortunately, Clark’s completion is not quite fit here for the following reasons. Oneproblem is that it is defined for formulas of the form G ⊃ p, rather than for arbitrary for-mulas. Thus Clark’s completion can be compared with circumscription only when formulasare given in this special form. Moreover, Clark’s completion is sensitive to the syntacticform of the given knowledge base. For instance, while ¬p ⊃ q and ¬q ⊃ p are logicallyequivalent, their Clark’s completions on {p, q} are not.7 Recall Footnote 5.J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185165Fortunately, there is another notion from the literature, Lifschitz’s pointwise circum-scription [20], that generalizes Clark’s completion, and is syntax independent. To see this,notice first that, as we have mentioned above, Clark’s completion on p essentially turns a“weakest” sufficient condition of p into its necessary condition. Formally, we can definethe notion of weakest sufficient conditions as follows [26].Given a propositional formula A and an atom q, a formula ϕ that does not mention q iscalled a weakest sufficient condition of q if• A (cid:2) ϕ ⊃ q, and• for any other formula ψ such that it does not mention q and A (cid:2) ψ ⊃ q, we have thatA (cid:2) ψ ⊃ ϕ.For any A and q, weakest sufficient conditions of q always exist and are unique up tological equivalence under A. In the following, given a formula A and a set P of atoms, we⊥ to denote the result of replacing all occurrences of atoms from P in A by ⊥. Inuse APthis section, P will always be a singleton.Proposition 2 [26]. For any formula A and any atom q, the formula ¬Asufficient condition of q.{q}⊥ is a weakestThus we could extend Clark’s completion to arbitrary formulas as follows: Given anyformula A and any set P of atoms, the generalized Clark’s completion of A on P is the{p}⊥ for all p ∈ P . As it turned out, this is exactlyconjunction of A and formulas p ⊃ ¬ALifschitz’s pointwise circumscription of P in A.Proposition 3. For any formula A and any atom q, CIRC[A; q] is equivalent to A ∧ (q ⊃¬A{q}⊥ ).Proof. ¬∃x(A(x) ∧ x < q) is equivalent to(cid:2)A(⊥) ∧ ⊥ < qA((cid:2)) ∧ (cid:2) < q(cid:4)(cid:2)¬∨(cid:3)(cid:3)(cid:5),which is equivalent to(cid:4)(cid:2)¬A((cid:2)) ∧ q ∧ ¬qwhich is equivalent to q ⊃ ¬A(cid:3)∨(cid:3)(cid:5),(cid:2)A(⊥) ∧ q{q}⊥ . (cid:1)So in the following, we shall use the term “completion” and “pointwise circumscription”interchangeably, and for our purpose here, we also call the pointwise circumscription of Pin A with Z allowed to vary, the completion of A on P with Z allowed to vary.The following proposition shows that the completion of A is equivalent to Clark’s com-pletion of B for some B that is equivalent to A.Proposition 4. Let A be a formula, and P the set of atoms in it. There is a formula B ofthe required form in the definition of Clark’s completion such that A is equivalent to B,and the completion of A on P is equivalent to Clark’s completion of B on P .166J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185Proof. Let B0 be a set of non-tautological clauses that is equivalent to A. Now for eachq ∈ P , each clause that contains q, say G ∨ q, generate the rule ¬G ⊃ q, and let B be theresulting theory. Clearly B is equivalent to B0, thus to A as well. Clark’s completion of B{q}on P is the conjunction of B and q ⊃ ¬B⊥ for all q ∈ P . But B is equivalent to A, andB{q}⊥ . So the proposition follows. (cid:1){q}⊥ is equivalent to ALifschitz [20] showed that circumscription always entails pointwise circumscription(completion), but the converse does not hold in general. For instance, CIRC[p ≡ q; p, q]yields ¬p ∧ ¬q. But the pointwise circumscription of (p, q) in p ≡ q is equivalent top ≡ q. The reason is that pointwise circumscription (completion), like Clark’s completion,does not handle “loops”, such as the one between p and q in the formula p ≡ q. The mainpurpose of this paper is to formally define what we mean by loops in a formula, associatea constraint with each loop, and show that propositional circumscription is equivalent tothe conjunction of pointwise circumscription and the constraints for all loops. We beginby defining the notion of a loop. Like in logic programs, we appeal to the notion of adependency graph.4. Dependency graphs and loopsA clause like p ∨ q ∨ ¬r can be rewritten as (r ∧ ¬q) ⊃ p or (r ∧ ¬p) ⊃ q. So if onewants to count ways an atom can be “derived”, this clause needs to be counted for both pand q. In general, if a clause C contains an atom p, then it can be rewritten as ¬(C\{p}) ⊃p.8 This motivates the following definition of a dependency graph of a set of clauses.Definition 2. Let A be a set of clauses, and P a set of atoms. The (positive) dependencygraph of A on P is the directed graph such that• the vertices are the atoms in P , and• an edge goes from vertex p to vertex q if there is a clause C in A such that p, ¬q ∈ C.A nonempty subset L of P is called a loop of A on P if, for every pair p, q of atomsin L, there exists a path of non-zero length from p to q in the dependency graph of A on Psuch that all vertices in this path belong to L. For example, consider the following set A1of clauses:{p ∨ ¬q, ¬p ∨ q, r ∨ ¬s, ¬r ∨ s, p ∨ r}.This theory has two loops on {p, q, r, s}, {p, q} and {r, s}, as shown by its dependencygraph in Fig. 1.We can make the definition of a loop slightly more general by dropping the requirementthat the paths be of non-zero length. That is, a nonempty subset L of P is called a gener-alized loop of A on P if, for every pair p, q of atoms in L, there exists a path from p to q8 Recall that ¬(C\{p}) is equal toconvention of identifying a clause with the disjunction of its literals.l∈C\{p}¯l where ¯l denotes a literal complementary to l, according to the(cid:6)J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185167Fig. 1. The dependency graph of A1 on {p, q, r, s}.in the dependency graph of A on P such that all vertices in this path belong to L. In otherwords, a nonempty subset L of P is a generalized loop of A on P if the subgraph of thedependency graph of A on P induced by L is strongly connected. Note that a singletonsubset {p} of P is a loop if and only if there is an edge from p to itself in the dependencygraph. On the other hand, every singleton subset of atoms is a generalized loop, regard-less of the presence of such edges. For instance, in addition to the loops that we foundbefore, A1 has four other generalized loops on {p, q, r, s}: {p}, {q}, {r}, {s}. As we willsee later, the notion of a generalized loop simplifies the statements of many of our resultssuch as Theorem 1 below. It will also allow us to view loop formulas as a generalization ofcompletion.For an arbitrary formula A, its dependency graph can be defined by considering a set Bof clauses that is equivalent to A:Definition 3. Given a formula A, if B is a finite set of clauses that is equivalent to A,then the dependency graph of B on P is called the dependency graph of A on P under B.Similarly, the loops of B on P are called the loops of A on P under B, and the generalizedloops of B on P are called the generalized loops of A on P under B.5. Computing the models of propositional circumscriptionWe begin with the simple case when there are no constants (atoms) allowed to vary.5.1. The basic caseRecall that for any formula A and any set P of atoms, by AP⊥ we denote the result ofreplacing all occurrences of atoms from P in A by ⊥.Theorem 1. Let A be a formula, and B a finite set of clauses that is equivalent to A. Thefollowing formulas are equivalent to each other.(a) CIRC[A; P ].(b) The conjunction of A and(cid:7)K ⊃ ¬AK⊥9for all subsets K of P .(cid:8)9 Whensimilar.is applied to a set K as in the antecedent, it stands for the disjunction of all elements of K.(cid:6)is168J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185(c) The conjunction of A and(cid:1)L ⊃ ¬AL⊥(4)for all generalized loops L of A on P under B.In view of the theorem, circumscribing a theory can be regarded as just adding to itformulas (4) for all generalized loops. When L is a loop, we call formula (4) the conjunctiveloop formula of L for CIRC[A; P ]. Notice that (c) can also be viewed as the conjunctionof the completion of A on P and all conjunctive loop formulas.Since conditions (b) and (c) are equivalent to each other, any intermediate conditionbetween the two is also equivalent to (a)–(c):Corollary 1. The following formulas are equivalent to each of formulas (a)–(c) of Theo-rem 1.(d) The conjunction of A andK ⊃ ¬AK⊥for all nonempty subsets K of P .(e) The conjunction of A and(cid:1)(cid:7)L ⊃ ¬AL⊥(5)for all generalized loops L of A on P under B.Note that in (d), K should be nonempty. Otherwise, the formula is unsatisfiable. WhenL is a loop, we call formula (5) the disjunctive loop formula of L for CIRC[A; P ]. Notealso that (4) and (5) are the same when L is a singleton. The two formulas can be differentonly when L is a loop.Another corollary of Theorem 1 is when the theory has no loops:Corollary 2. For any formula A, if there is an equivalent set B of clauses such that thereare no loops of B on P , then CIRC[A; P ] is equivalent to the completion of A on P .Corollary 2 is more general than Proposition 3 in that P is not required to be a singleton.We can still compute circumscription by completion if there are no loops. For instance,CIRC[p ∨ q; p, q] is equivalent to the completion of p ∨ q on {p, q}. On the other hand,Corollary 2 does not apply even when P is a singleton if B has a loop. However, such aloop can only come from a tautological clause, which can be dropped without affecting themodels. After then Proposition 3 follows from Corollary 2.For an example theory that has loops, consider the theory A1 and the tuple P =(p, q, r, s) in the previous section. This theory has three models, {p, q}, {r, s} and{p, q, r, s}, among which the last is not a model of CIRC[A1; P ] because {p, q} <P{p, q, r, s}. Theorem 1 tells us that the models of the circumscription can be found bycomputing the models of the completion and loop formulas. As we have seen in the pre-vious section, there are two loops of A1 on P , {p, q} and {r, s}. Their loop formulas areJ. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185169p ∧ q ⊃ ¬r and r ∧ s ⊃ ¬p, respectively. Among the models of the completion of A1on P , {p, q, r, s} does not satisfy loop formula p ∧ q ⊃ ¬r (or r ∧ s ⊃ ¬p), so that it is nota model of CIRC[A1; P ]. The other two satisfy all loop formulas, and thus are the modelsof the circumscription.The view of circumscription in terms of “completion + loop formulas” sometimes helpsus observe why two circumscriptions are equivalent to each other. For instance in the ex-ample above, even if we restrict atoms to be circumscribed in to be only {p, q}, the resultremains the same. The completion of A1 on {p, q} is a subset of the completion of A1 on P ,so that all three models of A1 still satisfy the completion of A1 on {p, q}. Set {p, q, r, s}still does not satisfy loop formula p ∧ q ⊃ ¬r for CIRC[A1; p, q], which is also a loopformula for CIRC[A1; P ].According to Theorem 1, to compute the circumscription of P in A with all other atomsfixed,(1) one first converts A into a finite set B of clauses,(2) constructs the dependency graph of B on P ,(3) finds the loops of the dependency graph, and then(4) computes loop formulas.In the first step, a formula may be equivalent to many different sets of clauses, which inturn may yield different dependency graphs. (For instance, formulas{p ∨ q ∨ ¬r, p ∨ ¬q ∨ ¬r, ¬p ∨ ¬q ∨ r, ¬p ∨ ¬q ∨ ¬r}and{p ∨ ¬r, ¬p ∨ ¬q}are equivalent to each other, but their dependency graphs on {p, q, r} are different.) Forour purpose, everything else being equal, the fewer loops that a dependency graph has thebetter. We believe that in general, given a formula A, it is computationally hard to find anequivalent set of clauses that would yield the smallest number of loops. But we do not havea proof, and it remains an open question.A standard way of converting a formula A (assuming all connectives other than ¬, ∧,∨ are eliminated) into an equivalent set of clauses is first to distribute ¬ over ∧ and ∨ untilit applies to atoms only, and then to distribute ∨ over ∧ until it applies to literals only.However, when distributing ∨ over ∧, the size of the formula could grow exponentially inthe number of atoms in A. To avoid the problem, one can introduce new atoms. We willsee in Section 5.2 that these new atoms can be treated similarly to atoms that are allowedto vary.Once converted into an equivalent set B of clauses (without introducing new atoms),its dependency graph can be constructed in time polynomial to the number of atoms in A.However, the number of loops can be exponential in the worst case. From the complexitypoint of view, we cannot do much better about this as it turned out inevitable assuminga conjecture from the theory of computational complexity which is widely believed tobe true. Lifschitz and Razborov [16] showed that any equivalent translation from logicprograms to propositional formulas involves a significant increase in size assuming the170J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185conjecture. A modification of their theorem holds for circumscription as well (VladimirLifschitz, personal communication).One can also construct a dependency graph directly without actually generating a setof clauses. Given a formula A, NNF(A) denotes the negation normal form of A, that is,a formula obtained from A by distributing ¬ over ∧ and ∨ until it applies to atoms only.Every formula A can be written in the form C1 ∧ · · · ∧ Cn (n (cid:3) 1) where each Ci is not aconjunction. We call each Ci conjunctive component of A.Definition 4. Let A be a formula, and P a set of atoms. The (positive) dependency graphof A on P is the directed graph such that• the vertices are the atoms in P , and• an edge goes from vertex p to vertex q if there is a subformula F ∨ G of some con-junctive component of NNF(A) such that p occurs in F and ¬q occurs in G, or theother way around.Theorem 1 still holds if we replace “for all generalized loops L of A on P under B”with “for all generalized loops L of A on P ” under this definition. This is justified by thefollowing lemma:10Lemma 1. Let A be a formula in negation normal form. There exists an equivalent set B ofclauses such that two literals l1, l2 belong to the same clause in B iff there is a subformulaF ∨ G of A such that l1 ∈ F and l2 ∈ G, or the other way around.Proof. This can be proved by structural induction. (cid:1)When we are given a set of clauses rather than an arbitrary formula to circumscribe in,Theorem 1 may yield a shorter reformulation of circumscription:Corollary 3. For any finite set A of clauses, CIRC[A; P ] is equivalent to the conjunctionof A and(cid:1)(cid:7)L ⊃¬(C\L)C∈AC∩L(cid:10)=∅, C∩L=∅for all generalized loops L of A on P .Proof. Note first that for every clause C such that C ∩ L = ∅, CLBy Theorem 1, it is sufficient to show that every model of A does not satisfy ¬CLthat C ∩ L (cid:10)= ∅ or C ∩ L = ∅:⊥ is equivalent to C\L.⊥ such• For every clause C in A such that C ∩ L (cid:10)= ∅, CL⊥ is a tautology, so that ¬CL⊥ isunsatisfiable.10 The lemma is due to Paolo Ferraris.J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185171• For every clause C in A such that C ∩ L = ∅, C entails CL⊥, so that every model of A,which satisfies C, does not satisfy ¬CL⊥. (cid:1)5.2. Varying constantsThe following proposition [19, Proposition 2] shows how to eliminate varied constantsin general:Proposition 5. CIRC[A(P , Z); P ; Z] is equivalent toA(P , Z) ∧ CIRC(cid:4)∃zA(P , z); P(cid:5).Thus circumscription with varied constants reduces to the basic case to which Theo-rem 1 applies: we consider the dependency graph of ∃zA(P , z).Alternatively, we can generalize the definitions of a dependency graph and a loop. Intu-itively, paths are allowed to have varied atoms and their negations as intermediate vertices.Given a set X of literals, X is the set of literals complementary to literals in X.Definition 5. Let A be a set of clauses, and P , Z be sets of atoms. The (positive) depen-dency graph of A on P with Z varied is the directed graph such that• the vertices are the literals in P ∪ Z ∪ Z, and• an edge goes from vertex l1 to vertex l2 if there is a clause C in A such that l1, ¯l2 ∈ C.The definition is a generalization of Definition 2 in that it reduces to Definition 2 when Zis empty. Similarly to Definition 3, we can also extend Definition 5 to an arbitrary formulaby referring to an equivalent set of clauses.Let L0 be the set of literals such that, for every pair l1, l2 of literals in L0, there exists apath of non-zero length from l1 to l2 in the dependency graph of A on P with Z allowedto vary such that all vertices in this path belong to L0. A nonempty set L = L0\(Z ∪ Z)is called a loop of A on P with Z allowed to vary. A generalized loop of A on P withZ allowed to vary is defined similarly to the case when no atoms are allowed to vary, bydropping the requirement that the paths be of non-zero length.For example, A2 is the set of clauses{p ⊃ ¬z, ¬z ⊃ q, q ⊃ p},and its dependency graph on {p, q} with {z} allowed to vary is shown in Fig. 2. There arethree generalized loops: {p}, {q}, {p, q}, and only the last one is a loop.Fig. 2. The dependency graph of A2 on {p, q} with {z} varied.172J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185The definition of a loop above is intuitive, but here is another definition that is moreeconomical in terms of the number of loops we get. Given a set A of clauses and a tuple ofatoms Z = (zn, . . . , z1), Ak (0 (cid:1) k (cid:1) n) is defined as follows:• A0 = A,• Ak = Ak−1 ∪ {C1 ∪ C2: C1 ∪ {zk}, C2 ∪ {¬zk} ∈ Ak−1}.The Z-collapsed set of A is obtained from An by removing clauses C such that Ccontains a pair of complementary literals, or there is a proper subset C(cid:15) of C such thatC(cid:15) ∈ An.Let AZ be the Z-collapsed set of A, and A(cid:15)Z the set of clauses in AZ that do not mentionatoms in Z. We could then define the loops and the generalized loops of A on P with Zallowed to vary to be the loops and the generalized loops of A(cid:15)Z on P . A loop (generalizedloop, respectively) according to this alternative definition is also a loop (generalized loop,respectively) according to the definition above, but not vice versa. The following resultholds under either definition.Theorem 2. Let A(P , Z) be a formula, and B a finite set of clauses equivalent to A(P , Z).The following formulas are equivalent to each other.(a) CIRC[A(P , Z); P ; Z].(b) The conjunction of A(P , Z) andK ⊃ ∀z¬A(P , z)K⊥for all subsets K of P .(c) The conjunction of A(P , Z) and(cid:7)(cid:1)L ⊃ ∀z¬A(P , z)L⊥(6)for all generalized loops L of A(P , Z) on P under B with Z varied.When L is a loop, we call formula (6) the conjunctive loop formula of L forCIRC[A(P , Z); P ; Z].Theorem 2 follows from Theorem 1, Proposition 5 and the following lemma.Lemma 2. Let A(P , Z) be a finite set of clauses. Formula ∃zA(P , z) is equivalent to theset of all clauses in the Z-collapsed set of A that do not mention atoms in Z.Similarly to Theorem 1, we have the following corollary to Theorem 2.Corollary 4. The following formulas are equivalent to each of formulas (a)–(c) of Theo-rem 2.(d) The conjunction of A(P , Z) and(cid:1)K ⊃ ∀z¬A(P , z)K⊥J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185173for all nonempty subsets K of P .(e) The conjunction of A(P , Z) and(cid:7)L ⊃ ∀z¬A(P , z)L⊥for all generalized loops L of A on P under B with Z varied.When L is a loop, we call formula (6) the disjunctive loop formula of L forCIRC[A(P , Z); P ; Z]. We can again divide each of (c) and (e) into two parts: comple-tion and loop formulas. Recall that the completion of a formula A(P , Z) on P with Zallowed to vary is defined to be the pointwise circumscription of P in A with Z allowed tovary, which is equivalent to the conjunction of A(P , Z) and formulas{p}p ⊃ ∀z¬A(P , z)⊥for all atoms p in P .Similarly to Corollary 2, we get the following corollary to Theorem 2:Corollary 5. For any formula A, if there is an equivalent set B of clauses such that thereare no loops of A on P under B with Z varied, then CIRC[A; P ; Z] is equivalent to thecompletion of A on P with Z varied.In Section 5.1 we mentioned the use of new atoms to avoid exponential blow-up inconverting a formula into a conjunctive normal form. Here is one standard way to do so:CLAUSIFY*(F ,Γ )if F is a conjunction of clauses C1 ∧ · · · ∧ Ck, then exit with {C1, . . . , Ck} ∪ Γ ;G := a minimal non-literal subformula of F ;u := a new atom;F := the result of replacing G in F by u;CLAUSIFY*(F, Γ ∪ CLAUSIFY(u ≡ G)).(CLAUSIFY(F ) returns a set of clauses equivalent to F by the method described in Sec-tion 5.1.)Let A(P , Z) be a formula and A(cid:15)(P , Z, S) the result of CLAUSIFY*(A(P , Z), ∅) whichintroduces a set S of new atoms. Then A(P , Z) is equivalent to ∃sA(cid:15)(P , Z, s). Accordingto Proposition 5,(cid:4)A(P , Z); P ; Z(cid:5)CIRC(cid:4)(cid:15)∃sA(P , Z, s); P ; Z≡ CIRC(cid:15)≡ ∃sA(cid:5)(cid:4)(cid:15)∃zsA(cid:5)(P , Z, s) ∧ CIRCSo it is sufficient to find the loops of the dependency graph of ∃zsA(cid:15)(P , z, s). By Lemma 2,we can consider the dependency graph of (Z ∪ S)-collapsed set of A(cid:15)(P , Z, S) that do notmention atoms in Z ∪ S.(P , z, s); P.Similarly to Definition 4, we can also define a dependency graph and a loop of anarbitrary formula, without referring to an equivalent set of clauses.174J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185Definition 6. Let A be a formula, and P , Z be sets of atoms. The (positive) dependencygraph of A on P with Z varied is the directed graph such that• the vertices are the literals in P ∪ Z ∪ Z, and• an edge goes from vertex l1 to vertex l2 if there is a subformula F ∨ G of some con-junctive component of NNF(A) such that l1 occurs in F and ¯l2 occurs in G, or theother way around.Once we define a dependency graph, the definition of a loop is the same as before.Theorem 2 still holds if we replace “for all generalized loops L of A(P , Z) on P under B”with “for all generalized loops L of A(P , Z) on P ” under this definition.Similarly to Corollary 3, when we are given a set of clauses rather than an arbitrary for-mula to circumscribe in, Theorem 2 may yield a shorter reformulation of circumscription:Corollary 6. For any finite set A of clauses, CIRC[A; P ; Z] is equivalent to the conjunc-tion of A and(cid:1)(cid:7)L ⊃ ∀z¬(C\L)C∈A, C∩L=∅for all generalized loops L of A on P with Z varied.Note that unlike Corollary 3 we do not restrict the disjunction to be over C ∩ L (cid:10)= ∅.Indeed, if we did, the statement of the corollary would become incorrect. Consider a set A3of clauses{¬p ∨ q, ¬q ∨ p, ¬r ∨ s, ¬s ∨ q}.Set {p, q, r, s} is one of the models of CIRC[A3; p, q; s], but it does not satisfy the modi-fied (wrong) loop formula, p ∧ q ⊃ ⊥.Proof of Corollary 6. Note first that for every clause C such that C ∩ L = ∅, CL⊥ isequivalent to C\L. By Theorem 2, it is sufficient to show that every model of A does notsatisfy ¬CL⊥ is atautology, so that ¬CL⊥ such that C ∩ L (cid:10)= ∅: for every clause C in A such that C ∩ L (cid:10)= ∅, CL⊥ is unsatisfiable. (cid:1)5.3. Relating to some known resultsReiter [33] was the first one to show some relationships between Clark’s predicate com-pletion and circumscription. He proved that if a theory is Horn in a predicate P , then thecircumscription of P logically entails the completion on P . In the propositional case, ournew contributions are as follows. We showed that Lifschitz’s pointwise circumscriptionextends Clark’s completion to arbitrary theories, not just those that are Horn. With thisextension of completion, we gave a general syntactic condition that guarantees the equiv-alence between circumscription and completion. Also, we defined notions of loops andloop formulas, and showed that circumscription can be reduced to “completion + loopJ. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185175formulas” like answer sets in logic programming but with completion here defined to bepointwise circumscription.Traditionally, computing circumscription means finding classes of first-order theoriesfor which their circumscriptions are equivalent to first-order theories (e.g., [6,19,20]). Inthe propositional case, circumscription is always equivalent to a propositional theory. Sothe problem in the propositional case is not whether circumscription can be reduced topropositional logic, but how economically this can be done.In logic programming, when the positive dependency graph of a program has no loops,the program is called “tight”, and the answer sets for a tight program are exactly the modelsof the completion. Corollaries 2 and 5 in this paper address a similar syntactic conditionfor circumscription in the propositional case. In the following, we show that some of theknown results about circumscription can easily be explained by our corollaries.We say that an occurrence of an atom in a formula is positive if it is in the range ofan even number of negations, and negative otherwise (assuming that ⊃ and ≡ have beeneliminated in favor of other connectives). A formula A is positive relative to P if all occur-rences of P in it are positive, and negative if all occurrences of P are negative. We see thatif A is positive (or negative) relative to P , then there is an equivalent set of clauses whosedependency graph on P has no loops, so that CIRC[A; P ] is equivalent to the completionof A on P . The result can also be extended when some atoms are allowed to vary. Thefollowing proposition, which is from the propositional case of Proposition 2a from [20], iseasy to prove.Proposition 6. For any tuple of atoms P = (p1, . . . , pn) and any formula A that is positiverelative to each pi , CIRC[A; P ; Z] is equivalent to the completion of A on P with Zallowed to vary.Proof. This follows from the fact that there exists a set of clauses equivalent to A suchthat the dependency graph of A under it has no loops. (cid:1)Note that Corollary 5 provides a more general syntactic condition for the equivalencebetween circumscription and pointwise circumscription, than the one in Proposition 6. Forexample, consider CIRC[(p ⊃ q) ∧ (q ⊃ r); q, r]. The formula has no loops, and conse-quently the circumscription is equivalent to its corresponding pointwise circumscriptionby Corollary 5. But the conjunction in the formula cannot be divided into two parts so thatq, r are positive in one part and negative in the other, so Proposition 6 does not apply.Sometimes it is easy to observe that the dependency graphs of some circumscriptionshave the same loops. For instance, this observation provides an easy proof of the followingproposition from [20].Proposition 7. For any formula A and B, if B is negative relative to a tuple P of atoms,then CIRC[A ∧ B; P ] is equivalent to CIRC[A; P ] ∧ B.Proof. There exists a set B(cid:15) of clauses which is equivalent to B and is negative relativeto P . Notice that A ∧ B(cid:15) and A have the same dependency graph on P , hence have the176J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185same loops. We see that loop formulas of A ∧ B(cid:15) on P and those of A on P are equivalentto each other when we notice that (B(cid:15))L⊥ for any loop L is entailed by B(cid:15). (cid:1)However, if some atoms are allowed to vary, then A ∧ B may have more loops than A(A2(P , z) in Section 5.2 with B = {p ⊃ ¬z} for example), and B may not be “factoredout”.6. Embedding circumscription in other nonmonotonic logicsAs mentioned in the introduction, the idea of “completion + loop formulas” has beenapplied to logic programs [12,24] and to McCain–Turner causal logic [13]. The charac-terizations of these nonmonotonic logics in terms of propositional logic are useful toolsfor comparing these formalisms. Based on this idea, Lee [13] showed how to embed logicprograms in causal logic.Inspired by a similar characterization for circumscription, we show how to embedcircumscription in logic programs and in causal logic. The propositions are proved in Ap-pendix A by turning each formalism into equivalent propositional formulas, and then showthat the translations are equivalent to each other (in propositional logic).6.1. Embedding circumscription in disjunctive logic programsFor the semantics of disjunctive logic programs, we refer the reader to Section 5.1of [21].For a literal l, by lnot we denote not l if l is positive, and ¯l otherwise. Let A be a finite setof clauses, and P a tuple of atoms. For each clause C ∈ A, the corresponding rule RP (C)is;p∈C∩Pp ← ,q∈C\Pqnot.For example, R(p,q,r)(p ∨ q ∨ ¬r ∨ s) = p ; q ← r, not s.By σA we denote the set of all atoms that occur in A.Proposition 8. For any finite set A of clauses, a set of atoms is a model of CIRC[A; P ] iffit is an answer set for logic program(cid:9)(cid:10)RP (C): C ∈ A∪(cid:9)a ; not a: a ∈ σA\P(cid:10).We can also embed circumscription with varied constants in logic programs. Given afinite set A of clauses, let AZ be the Z-collapsed set of A. Program ΠA;P ;Z consists of thefollowing rules:• RP (C) for all clauses C in AZ that do not mention atoms in Z,• ← ,p∈Cpnot for all other clauses C in AZ,• a ; not a for all atoms a ∈ σA\P .J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185177Proposition 9. For any finite set A of clauses, a set of atoms is a model of CIRC[A; P ; Z]iff it is an answer set for logic program ΠA;P ;Z.For example, CIRC[A1; p, q, r] can be turned into:p ← qq ← pr ← s← r, not sp ; r ←s ; not s ←As in the example, the translation gives us disjunctive programs in general. Thus one couldimplement circumscription in logic programming systems like DLV11 and GnT12 usingPropositions 8 and 9.136.2. Embedding circumscription in causal logicThe semantics of McCain–Turner causal logic is given in [28].Let A be a finite set of clauses, and P a tuple of atoms. For each clause C ∈ A, thecorresponding causal rule CRP (C) is(cid:3)(cid:2)C\(P ∪ P ).C ∩ (P ∪ P ) ⇐ ¬By σA we denote the set of all atoms that occur in A.Proposition 10. For any finite set A of clauses, an interpretation is a model of CIRC[A; P ]iff it is a model of causal theory(cid:10)(cid:9)CRP (C): C ∈ A∪ {¬a ⇐ ¬a: a ∈ σA} ∪ {a ⇐ a: a ∈ σA\P }.whose signature is σA.Proposition 10 is similar to the propositional case of Proposition 1 of [22].Extending the result to circumscription with varied constants is similar to the case withlogic programs. Given a finite set A of clauses, let AZ be the Z-collapsed set of A. Causaltheory CT A;P ;Z consists of the following causal rules:• CRP (C) for all clauses C in AZ that do not mention atoms in Z,• ⇐ ¬C for all other clauses C in AZ,11 http://www.dbai.tuwien.ac.at/proj/dlv/.12 http://www.tcs.hut.fi/Software/gnt/.13 Strictly speaking, the current versions of these systems do not allow negation as failure in the head of a rule,so it cannot handle such a rule as a; not a. However, there is a well-known technique to “simulate” rules of thiskind using additional atoms.178J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185• ¬a ⇐ ¬a for all atoms a ∈ σA,• a ⇐ a for all atoms a ∈ σA\P .Proposition 11. For any finite set A of clauses, an interpretation is a model ofCIRC[A; P ; Z] iff it is a model of causal theory CTA;P ;Z whose signature is σA.7. ConclusionTo recast, the following are our main contributions (all in the propositional case):• Showed that pointwise circumscription is an extension of Clark’s completion fromHorn clauses to arbitrary formulas.• Introduced a notion of a dependency graph for a finite set of clauses, and based on it,notions of loops and loop formulas.• Showed that circumscription is equivalent to completion (pointwise circumscription)plus loop formulas, and based on this result, showed how to embed circumscription inother nonmonotonic logics which have similar characterizations.These results are of both theoretical interest and practical importance. A major obstacle inimplementing a reasoning system for propositional circumscription is that checking if anassignment is a model of a circumscription is NP-hard. In comparison, checking if an as-signment is a model of a formula in propositional logic or an answer set for a nondisjunctivelogic program can be done efficiently. According to Theorems 1 and 2, if a given formulahas no loops or has only a polynomial number of loops and these loops can be computed inpolynomial time, then checking if an assignment is a model of circumscription can be donein polynomial time as well. Hopefully, many applications of circumscription will belongto this class, just as many logic programs for practical problems are “tight” or “tight on themodels of completion”.For future work, there is a need to better understand how loops can be computed. Moreimportantly, there is a need to extend the results of this paper to the first-order case.AcknowledgementsWe are grateful to Selim Erdo˘gan, Paolo Ferraris, Hudson Turner, and the anonymousreferees who reviewed this paper or the short version of this paper presented in AAAI’04for their useful comments. Special thanks to Vladimir Lifschitz who provided us with valu-able advice and pointers to earlier work and helped us improve the presentation. JoohyungLee was partially supported by the Texas Higher Education Coordinating Board underGrant 003658-0322-2001. Fangzhen Lin was partially supported by HK RGC under CERGHKUST6205/02E, CERG HKUST6170/04E, and by China NSFC under grant 60496322.Most of this work was done while Joohyung was at the University of Texas at Austin.J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185179Appendix A. ProofsThe proof of the main theorem is based on the following fact and the main lemma below.Fact 1. For any formula A and any sets I , K of atoms,I (cid:2) AK⊥ iffI \K (cid:2) A.Proof. The proof is immediate by structural induction. (cid:1)Main Lemma. Let A be a formula, B a finite set of clauses equivalent to A, I a modelof A, P a set of atoms, and K a nonempty subset of P . If I does not satisfy AL⊥ for anygeneralized loop L of A on P under B such that L ⊆ K, then I does not satisfy AK⊥ .The proof is given in Section A.2.A.1. Proof of Theorem 1Theorem 1. Let A be a formula, and B a finite set of clauses that is equivalent to A. Thefollowing formulas are equivalent to each other.(a) CIRC[A; P ].(b) The conjunction of A andfor all subsets K of P .(c) The conjunction of A and(cid:7)(cid:1)K ⊃ ¬AK⊥L ⊃ ¬AL⊥for all generalized loops L of A on P under B.Proof. From (b) to (c) is clear.From (a) to (b): Let I be a model of CIRC[A; P ]. Let K be any subset of P such thatI ∩ K (cid:10)= ∅. Since I \K <P I , it follows that I \K (cid:1) A. By Fact 1, it follows that I (cid:1) AK⊥ .From (c) to (a): Let I be a model of the conjunction of A and(cid:1)L ⊃ ¬AL⊥for all generalized loops L of A on P under B. Let J be any set of atoms such that J <P I .We will show that J (cid:1) A. Let K = I \J . For every generalized loop L that is containedin K, since I (cid:2)⊥ for any gen-eralized loop L that is contained in K, by the main lemma, it follows that I (cid:1) AK⊥ , which isequivalent to I \K (cid:1) A, i.e., J (cid:1) A by Fact 1. Therefore I is a model of CIRC[A; P ]. (cid:1)⊥. Since K is nonempty and I (cid:1) ALL, we have that I (cid:1) AL(cid:6)180J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185A.2. Proof of the Main LemmaLemma 3. Let A be a formula, B a finite set of clauses equivalent to A, I a model of A, P aset of atoms, K a subset of P , and L a nonempty subset of K. Suppose that the dependencygraph of B has no edge from an atom in L to an atom in K\L. If I (cid:1) AL⊥, then I (cid:1) AK⊥ .Proof. We prove it for the special case when A = B. The general case follows becausewhen A and B are equivalent to each other, AL⊥ for any set L of atoms.⊥, or by Fact 1,⊥. There exists a clause C of A such that I (cid:1) CL⊥ is equivalent to BLAssume that I (cid:1) ALI \L (cid:1) C.For this C, we will show that I (cid:1) CK⊥ , from which it follows that I (cid:1) AK⊥ .Since I (cid:2) A,I (cid:2) C(A.1)(A.2)also. From (A.1) and (A.2), it follows that C contains at least one positive occurrence ofan atom from L. On the other hand, since the dependency graph of A has no edge from anatom in L to an atom in K\L, C does not contain any negative occurrence of atoms fromK\L. Then it follows from (A.1),I \K (cid:1) C,which is equivalent to I (cid:1) CK⊥ by Fact 1. (cid:1)Proof of the Main Lemma. In view of Lemma 3, it is sufficient to show that there existsa generalized loop L in K such that the dependency graph of B does not have any edgefrom an atom in L to an atom in K\L. To see that there is indeed such a generalized loop,let G be the subgraph of the dependency graph of A which is induced by K, and let G(cid:15)be the graph obtained from G by collapsing strongly connected components of G, i.e., thevertices of G(cid:15) are the strongly connected components of G and G(cid:15) has an edge from avertex V to a vertex V (cid:15) iff G has an edge from an atom in V to an atom in V (cid:15). Since K isnonempty, there is at least one generalized loop in K. Consequently, there is at least onevertex in G(cid:15). From the fact that the vertices of G(cid:15) are the strongly connected componentsof G, it follows that there is a terminal vertex in G(cid:15). Let L be that vertex. It is clear thatthere is no edge from an atom in L to an atom in K\L in the dependency graph of B. (cid:1)A.3. Proof of Lemma 2Lemma 2. Let A(P , Z) be a finite set of clauses. Formula ∃zA(P , z) is equivalent to theset of all clauses in the Z-collapsed set of A that do not mention atoms in Z.Proof. Since the Z-collapsed set of A is equivalent to A|Z| (Section 5.2), it is sufficientto prove that ∃zA(P , z) is equivalent to the set of all clauses in A|Z| that do not mentionatoms in Z. The proof is by strong induction on the length of z. Assume that∃zk−1, . . . , z1A(P , zk, zk−1, . . . , z1)J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185181is equivalent to the set of all clauses in Ak−1(zk) that do not mention atoms in zk−1, . . . , z1.Let’s denote the set by A(cid:15)k−1(zk). Then ∃zk, . . . , z1A(P , zk, . . . , z1) is equivalent toA(cid:15)k−1((cid:2)) ∨ A(cid:15)k−1(⊥), from which a conjunctive normal form can be obtained by distrib-uting ∨ over ∧. Let’s denote the resulting set of clauses by Bk. One can check that Bk isequivalent to the set of all clauses in Ak that do not mention atoms in zk, . . . , z1:• Bk contains all clauses in A(cid:15)• Every other clause in Bk is entailed by a clause in A(cid:15)k−1(zk) that do not mention zk.k−1(zk) that does not mention zkexcept for clauses C1 ∨ C2 that are obtained by taking a disjunction of C1 ∨ ¬zk fromk−1((cid:2)) and C2 ∨ zk from A(cid:15)A(cid:15)k−1(⊥). (cid:1)A.4. Proof of Theorem 2Theorem 2. Let A(P , Z) be a formula, and B a finite set of clauses equivalent to A(P , Z).The following formulas are equivalent to each other.(a) CIRC[A(P , Z); P ; Z].(b) The conjunction of A(P , Z) andK ⊃ ∀z¬A(P , z)K⊥for all subsets K of P .(c) The conjunction of A(P , Z) and(cid:7)(cid:1)L ⊃ ∀z¬A(P , z)L⊥for all generalized loops L of A(P , Z) on P under B with Z varied.Proof. By Proposition 5, CIRC[A(P , Z); P ; Z] is equivalent to(cid:4)∃zA(P , z); PA(P , Z) ∧ CIRC(cid:5),(A.3)and by Theorem 1(b), (A.3) is equivalent to the conjunction of A(P , Z) and(cid:7)K ⊃ ¬∃zA(P , z)K⊥for all subsets K of P . By Theorem 1(c), (A.3) is also equivalent to the conjunction ofA(P , Z) and(cid:1)L ⊃ ¬∃zA(P , z)L⊥(A.4)for all generalized loops L of ∃zA(P , z) under (the clausal form of) ∃zB(P , z). ByLemma 2, ∃zB(P , z) is equivalent to the set of all clauses in the Z-collapsed set of B thatdo not mention atoms in Z, from which we get the generalized loops of A on P under Bwith Z varied. (cid:1)A.5. Proof of Proposition 9Given a disjunctive logic program Π without classical negation, by Π K⊥ we denote theprogram obtained from Π by replacing all occurrences of atoms from K that are not in thescope of negation as failure with ⊥.182J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185When Π is finite, propositional theory T (Π) is the conjunction of Π and(cid:1)K ⊃ ¬Π K⊥for all nonempty sets K of atoms that occur in Π .14The following proposition is from Corollary 6 of [15].Proposition 12. For any finite disjunctive logic program Π without classical negation, aset of atoms is an answer set for Π iff it is a model of T (Π).(cid:1)(cid:1)Proof of Proposition 9. According to Corollary 4, CIRC[A; P ; Z] is equivalent to theconjunction of A andK ⊃ ¬∃zA(P , z)K⊥(A.5)for all nonempty subsets K of P ; according to Proposition 12, T (ΠA;P ;Z) is equivalent tothe conjunction of ΠA;P ;Z andK ⊃ ¬(ΠA;P ;Z)K⊥(A.6)for all nonempty sets K of atoms from σA.We will show that these two theories are equivalent to each other in propositional logic.First it is easy to check that ΠA;P ;Z is equivalent to A in propositional logic. One can alsocheck that every formula (A.6) where K contains an atom from σA\P is a tautology dueto the presence of rules a; not a for a ∈ σA\P .We will now show that under ΠA;P ;Z (or A) the set of formulas (A.5) for all nonemptysubsets K of P is equivalent to the set of formulas (A.6) for all nonempty subsets Kof P . It is sufficient to show that under the same assumption ∃zA(P , z)K⊥ is equivalent to⊥ for every nonempty subset K of P . It follows from Lemma 2 that ∃zA(P , z)K(ΠA;P ;Z)K⊥is equivalent to the conjunction of RP (C)K⊥ for all clauses C in AZ that do not mentionatoms in Z; for all rules r other than such RP (C)’s in ΠA;P ;Z, it is easy to check that r K⊥is entailed by ΠA;P ;Z, so that ∃zA(P , z)K⊥ is equivalent to (ΠA;P ;Z)K⊥ as well. (cid:1)A.6. Proof of Proposition 11Given a formula F and a consistent set K of literals, by FK we denote the formulaobtained from formula F by replacing all occurrences of atoms a in F by• ⊥ if a ∈ K, and• (cid:2) if ¬a ∈ K.Given a causal theory CT, by CT K we denote the theory obtained from CT by replacingall rules F ⇐ G in CT with FK ⇐ G.14 We identify a logic program with a propositional theory by identifying ‘not’ with ‘¬’, ‘,’ with ‘∧’, and ‘;’with ‘∨’.J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185183When CT is finite, propositional theory T (CT) is the conjunction of CT and(cid:1)K ⊃ ¬CT Kfor all nonempty sets K of literals from the signature of CT.15Similarly to Proposition 12, the following proposition holds [14, Chapter 10.3, Theo-rem 3]:Proposition 13. Let CT be a finite causal theory whose signature is σ . An interpretationof σ is a model of CT iff it is a model of T (CT).(cid:1)(cid:1)Proof of Proposition 11. According to Corollary 4, CIRC[A; P ; Z] is equivalent to theconjunction of A andK ⊃ ¬∃zA(P , z)K⊥(A.7)for all nonempty subsets K of P ; according to Proposition 13, T (CT A;P ;Z) is equivalentto the conjunction of CT A;P ;Z andK ⊃ ¬(CT A;P ;Z)K(A.8)for all nonempty sets K of literals from σA.We will show that these two theories are equivalent to each other in propositional logic.First CT A;P ;Z is equivalent to A in propositional logic. One can also check that everyformula (A.8) where K contains a negative literal l or a literal l from σA\P is a tautologydue to the presence of rules l ⇐ l.We will now show that under CT A;P ;Z (or A) the set of formulas (A.7) for all nonemptysubsets K of P is equivalent to the set of formulas (A.8) for all nonempty subsets Kof P . It is sufficient to show that under the same assumption ∃zA(P , z)K⊥ is equivalent to(CT A;P ;Z)K for every nonempty subset K of P . It follows from Lemma 2 that ∃zA(P , z)K⊥is equivalent to the conjunction of CRP (C)K for all clauses C in AZ that do not mentionatoms in Z; for all causal rules r other than such CRP (C)’s in CT A;P ;Z, it is easy tocheck that rK is entailed by CT A;P ;Z, so that ∃zA(P , z)K⊥ is equivalent to (CT A;P ;Z)K aswell. (cid:1)References[1] V. Akman, S. Erdo˘gan, J. Lee, V. Lifschitz, H. Turner, Representing the Zoo World and the Traffic World inthe language of the Causal Calculator, Artificial Intelligence 153 (1–2) (2004) 105–140.[2] A. Artikis, M. Sergot, J. Pitt, An executable specification of an argumentation protocol, in: Proceedings ofConference on Artificial Intelligence and Law (ICAIL), ACM Press, New York, 2003, pp. 1–11.[3] A. Artikis, M. Sergot, J. Pitt, Specifying electronic societies with the Causal Calculator, in: F. Giunchiglia,J. Odell, G. Weiss (Eds.), Proceedings of Workshop on Agent-Oriented Software Engineering III (AOSE),in: Lecture Notes in Comput. Sci., vol. 2585, Springer, Berlin, 2003.15 We identify a causal theory with a propositional theory by identifying ‘⇐ ’ with material implication.184J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185[4] J. Campbell, V. Lifschitz, Reinforcing a claim in commonsense reasoning, in: Working Notes of the AAAISpring Symposium on Logical Formalizations of Commonsense Reasoning, 2003, http://www.cs.utexas.edu/users/vl/papers/sams.ps.[5] K. Clark, Negation as failure, in: H. Gallaire, J. Minker (Eds.), Logic and Data Bases, Plenum Press, NewYork, 1978, pp. 293–322.[6] P. Doherty, W. Łukaszewicz, A. Szałas, Computing circumscription revisited: A reduction algorithm, J. Au-tomat. Reasoning 18 (3) (1997) 297–336.[7] E. Erdem, V. Lifschitz, Tight logic programs, Theory and Practice of Logic Programming 3 (2003) 499–518.[8] F. Fages, Consistency of Clark’s completion and existence of stable of stable models, J. Methods of Logicin Computer Science 1 (1994) 51–60.[9] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: Proc. Fifth InternationalConference and Symposium on Logic Programming, 1988, pp. 1070–1080.[10] E. Giunchiglia, J. Lee, V. Lifschitz, N. McCain, H. Turner, Nonmonotonic causal theories, Artificial Intelli-gence 153 (1–2) (2004) 49–104.[11] E. Giunchiglia, Y. Lierler, M. Maratea, SAT-based answer set programming, in: Proc. AAAI-04, San Jose,CA, 2004, pp. 61–66.[12] J. Lee, V. Lifschitz, Loop formulas for disjunctive logic programs, in: Proc. ICLP-03, 2003, pp. 451–465.[13] J. Lee, Nondefinite vs. definite causal theories, in: Proc. 7th Internat. Conference on Logic Programmingand Nonmonotonic Reasoning, 2004, pp. 141–153.[14] J. Lee, Automated reasoning about actions, PhD thesis, University of Texas at Austin, 2005.[15] J. Lee, A model-theoretic counterpart of loop formulas, in: Proc. IJCAI-05, Edinburgh, UK, 2005, pp. 503–508.[16] V. Lifschitz, A. Razborov, Why are there so many loop formulas? ACM Trans. Comput. Logic (2005),submitted for publication.[17] V. Lifschitz, L.R. Tang, H. Turner, Nested expressions in logic programs, Ann. Math. Artificial Intelli-gence 25 (1999) 369–389.[18] V. Lifschitz, N. McCain, E. Remolina, A. Tacchella, Getting to the airport: The oldest planning problem inAI, in: J. Minker (Ed.), Logic-Based Artificial Intelligence, Kluwer, Dordrecht, 2000, pp. 147–165.[19] V. Lifschitz, Computing circumscription, in: Proc. IJCAI-85, Los Angeles, CA, 1985, pp. 121–127.[20] V. Lifschitz, Pointwise circumscription, in: M. Ginsberg (Ed.), Readings in Nonmonotonic Reasoning, Mor-gan Kaufmann, San Mateo, CA, 1987, pp. 179–193.[21] V. Lifschitz, Foundations of logic programming, in: G. Brewka (Ed.), Principles of Knowledge Representa-tion, CSLI Publications, 1996, pp. 69–128.[22] V. Lifschitz, On the logic of causal explanation, Artificial Intelligence 96 (1997) 451–465.[23] V. Lifschitz, Missionaries and cannibals in the Causal Calculator, in: Principles of Knowledge Representa-tion and Reasoning: Proc. Seventh Internat. Conf., 2000, pp. 85–96.[24] F. Lin, Y. Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers. in: Proc. AAAI-02,Edmonton, AB, 2002, pp. 112–117.[25] F. Lin, Embracing causality in specifying the indirect effects of actions, in: Proc. IJCAI-95, Montreal, Que-bec, IJCAI Inc., 1995, pp. 1985–1993, Distributed by Morgan Kaufmann, San Mateo, CA.[26] F. Lin, On strongest necessary and weakest sufficient conditions, Artificial Intelligence 128 (1–2) (2001)143–159.[27] F. Lin, Compiling causal theories to successor state axioms and STRIPS-like systems, J. Artificial Intelli-gence Res. 19 (2003) 279–314.[28] N. McCain, H. Turner, Causal theories of action and change, in: Proc. AAAI-97, Providence, RI, 1997,pp. 460–465.[29] J. McCarthy, Circumscription—a form of non-monotonic reasoning, Artificial Intelligence 13 (1980) 27–39,171–172. Reproduced in [31].[30] J. McCarthy, Applications of circumscription to formalizing common sense knowledge, Artificial Intelli-gence 26 (3) (1986) 89–116. Reproduced in [31].[31] J. McCarthy, Formalizing Common Sense: Papers by John McCarthy, Ablex, Norwood, NJ, 1990.[32] R. Reiter, On closed world data bases, in: H. Gallaire, J. Minker (Eds.), Logics and Data Bases, PlenumPress, New York, 1978, pp. 55–76.J. Lee, F. Lin / Artificial Intelligence 170 (2006) 160–185185[33] R. Reiter, Circumscription implies predicate completion (sometimes), in: Proc. AAAI-82, Pittsburg, PA,1982, pp. 418–420.[34] R. Reiter, The frame problem in the situation calculus: A simple solution (sometimes) and a completenessresult for goal regression, in: V. Lifschitz (Ed.), Artificial Intelligence and Mathematical Theory of Compu-tation: Papers in Honor of John McCarthy, Academic Press, San Diego, CA, 1991, pp. 418–420.