Artificial Intelligence 175 (2011) 120–141Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintA unifying action calculusMichael ThielscherSchool of Computer Science and Engineering, The University of New South Wales, Australiaa r t i c l ei n f oa b s t r a c tArticle history:Available online 3 April 2010Keywords:Knowledge representationReasoning about actionsSituation CalculusMcCarthy’s Situation Calculus is arguably the oldest special-purpose knowledge represen-tation formalism, designed to axiomatize knowledge of actions and their effects. Fourdecades of research in this area have led to a variety of alternative formalisms: Whilesome approaches can be considered instances or extensions of the classical Situation Cal-culus, like Reiter’s successor state axioms or the Fluent Calculus, there are also specialplanning languages like ADL and approaches based on a linear (rather than branching)time structure like the Event Calculus. The co-existence of many different calculi has twomain disadvantages: The formal relations among them is a largely open issue, and a lot oftoday’s research concerns the transfer of specific results from one approach to another. Inthis paper, we present a unifying action calculus, which encompasses (well-defined classesof) all of the aforementioned formalisms. Our calculus not only facilitates comparisons andtranslations between specific approaches, it also allows to solve interesting problems forvarious calculi at once. We exemplify this by providing a general, calculus-independent so-lution to a problem of practical relevance, which is intimately related to McCarthy’s questfor elaboration tolerant formalisms: the modularity of domain axiomatizations.© 2010 Elsevier B.V. All rights reserved.1. IntroductionJohn McCarthy’s Situation Calculus [22] is arguably the oldest special-purpose knowledge representation formalism. Theaim is to use classical logic to axiomatize knowledge of actions and their effects. This is relevant for a variety of areas in AI,including planning, intelligent agents, high-level cognitive robotics, natural language understanding, and general game play-ing. While the Situation Calculus is the classical approach for this purpose, a variety of different logic-based formalisms haveemerged in the course of the past decades, motivated mainly by the fundamental Frame Problem [25]. Besides prominentvariants of the Situation Calculus like Reiter’s successor state axioms [31] or the Fluent Calculus [41], planning languageslike STRIPS, ADL, and PDDL [5,29,26] have been developed, which allow for simple operational solutions to the Frame Prob-lem at the expense of a significantly limited expressiveness. Furthermore, the underlying branching time structure of theSituation Calculus has been replaced by a linear time structure in the Event Calculus and a number of other approaches[18,36,4,10]. The basic principles of knowledge representation for actions are also used in special-purpose formalisms likethe Game Description Language [8].The co-existence of a multitude of knowledge representation languages for actions has two significant consequences forthe research in this area. Firstly, there is a growing need both for comparative analysis of the expressiveness of differentapproaches as well as for translations from one specific language into another one. Previous studies along this line are [17,28,35,3], each of which concerns the comparison of two specific formalisms. However, a method that encompasses a widevariety of alternative formalisms at the same time may allow for a more uniform way of assessing and translating calculi.Secondly, issues of general interest need to be separately addressed within each individual language. This often leads to aE-mail address: mit@cse.unsw.edu.au.0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.04.010M. Thielscher / Artificial Intelligence 175 (2011) 120–141121multiplication of research efforts. A notorious example is the Ramification Problem, that is, the problem of determining theindirect effects of actions [9], for which a variety of individual solutions have been developed for different formalisms, e.g.,[19,21,11,40,38,27]. A general method which enables a uniform treatment of problems across different calculi would help toavoid this multiplication of research efforts.In this paper, we address both of these issues at the same time by proposing a unifying action calculus, which isindependent of a specific solution to the Frame Problem and which is shown to be general enough to encompass a varietyof different action representation formalisms. Most notably, it abstracts from the underlying time structure (branching orlinear) and thus can be instantiated with both Situation Calculus-style approaches as well as Event Calculus-like languages.In so doing, our general calculus provides a uniform method for translating a variety of specific formalisms into eachother. Moreover, the unifying approach allows to abstract from specific formalisms when investigating problems of generalinterest. We exemplify this by providing a new, calculus-independent solution to a problem of practical relevance for anyaction representation language: the modularity of domain axiomatizations [13]. Our result is a contribution to McCarthy’squest for elaboration tolerant formalisms [24], since modularity is a prerequisite for elaboration tolerance: theories with avariety of dependencies among different parts may not allow for the addition of new information without disrupting theentire axiomatization [14]. We use our unifying action calculus to develop a general method for verifying that a given set ofdomain constraints, precondition axioms, and effect formulas is free of undesired, implicit dependencies. We exemplify therange of applicability of this result by instantiating it for several specific approaches, in particular the Situation-, Fluent-,and Event Calculus.The remainder of this paper is organized as follows. In the next section, we formally define an action calculus whichabstracts from a specific underlying time structure and is independent of a specific solution to the Frame Problem. Weillustrate the expressiveness of our definition by formalizing several example domains known from the literature, includingnondeterministic actions, indirect effects, and actions with duration. In Section 3, we show how our unifying calculus canbe used as an intermediary language for translations between specific languages. Specifically, we present two new results:a translation from ADL planning problems into the Event Calculus and a translation from the basic Fluent Calculus into anew extension—suitable for nondeterministic actions—of Reiter’s basic Situation Calculus. In the second part of the paper,in Section 4, we show how the unifying action calculus can be used to provide a calculus-independent solution to theproblem of implicit dependencies among domain axioms, and we again exemplify the range of applicability of this result byinstantiating it for several action formalisms. We conclude with a discussion in Section 5.2. A unifying action calculusThe purpose of this section is to develop a unifying action calculus that abstracts from a variety of existing axioma-tization techniques for describing actions and change. Logic-based action representation formalisms have in common twofundamental elements: Fluents [22] (sometimes called features [33]) represent properties of the domain that may change inresponse to the execution of actions (or events [18]). Fluents and actions are therefore basic sorts in the sorted logic languagewe are going to define. Action calculi also need to distinguish different points in time in order to axiomatize the changescaused by actions. We assume an abstract notion of time—which may be linear or branching—as the third fundamental sort.The three basic sorts are used for three fundamental predicates: The relation t1 < t2 denotes a (possibly partial) orderingon the time structure. Predicate Holds( f , t) is used to say that fluent fis true at time t. Finally, the intended meaning ofexpression Poss(a, s, t) is that it is possible to do action a beginning at time s and ending at time t. These three predicates,along with the three fundamental sorts, form the basis of a domain signature in our unifying action calculus.Definition 1. A domain signature is a finite, sorted logic language which includes the sorts fluent, action, and time alongwith the predicates<: time × timeHolds: fluent × timePoss: action × time × timeWe tacitly assume that a signature always includes the standard predicate “=”, interpreted as true equality. As usual, then,s (cid:2) t stands for s < t ∨ s = t.Throughout the paper we will denote variables of sort action by the letter a, variables of sort fluent by f and g, andvariables of sort time by s and t. We tacitly assume uniqueness-of-names [1] for all functions into fluent and action, whichis a common assumption in all standard action calculi.Next, we define the notion of a state formula, which allows to express properties of a domain at given times.Definition 2. Let (cid:3)t be a non-empty sequence of variables of sort time in a given domain signature. A state formula in (cid:3)t is afirst-order formula Φ[(cid:3)t] in which the variables in (cid:3)t occur free and such that1. for each occurrence of Holds( f , t) in Φ we have t ∈ (cid:3)t;122M. Thielscher / Artificial Intelligence 175 (2011) 120–1412. predicate Poss does not occur in Φ.Similar notions are used in many existing calculi but usually restricted to a single time point. As will be shown later inthis section, the more general concept is useful, for instance, when axiomatizing actions with ramifications.We are now in a position to formalize, in our calculus, three fundamental categories of domain axioms: domain con-straints, which describe state properties that hold at all times; precondition axioms, which define the conditions for actionsto be applicable in a state; and effect axioms, which define the consequences of actions. For the latter, we use a generalform that allows to define nondeterministic actions with the help of different possible “cases” i = 1, . . . , k of updates Υi[s, t](cf. axiom (1) below). Each of these sub-formulas defines the fluents that hold after the action, at time t, relative to thestate when the action starts, at time s. This does not only concern all (possibly conditional) effects of an action but also allnon-effects. This formulation is general enough to subsume specific solutions to the Frame and Ramification Problem.Definition 3. Consider a domain signature, and let A be a function into sort action.1. A domain constraint is of the formδ[t]which is a state formula in t.12. A precondition axiom is of the form(cid:2)PossA((cid:3)x), s, t(cid:3)≡ π A[s]where π A[s] is a state formula in s with free variables among s, t, (cid:3)x.3. An effect axiom is of the form(cid:2)PossA((cid:3)x), s, t(cid:3)⊃ Υ1[s, t] ∨ · · · ∨ Υk[s, t]where k (cid:3) 1 and each Υi[s, t] (1 (cid:2) i (cid:2) k) is a formula of the form(cid:2)(∃(cid:3)yi)(cid:4)Φi[s] ∧ (∀ f )Γ(cid:4)∧ (∀ f )Γ+i−i(cid:5)[s, t] ⊃ Holds( f , t)[s, t] ⊃ ¬Holds( f , t)(cid:5)(cid:3)(1)(2)in which Φi[s] is a state formula in s with free variables among s, (cid:3)x, (cid:3)y,2 and both Γformulas in s, t with free variables among f , s, t, (cid:3)x, (cid:3)y.+i[s, t] and Γ−i[s, t] are stateA domain axiomatization consists of precondition and effect axioms, one each for every function into sort action, along witha finite set of domain constraints and a finite set of foundational axioms without the predicates Holds and Poss.The purpose of the foundational axioms is to define the underlying time structure. In the following we present exam-ple axiomatizations of several domains known from the literature to illustrate the wide range of phenomena that can beexpressed in this unifying calculus.Example 1 (Branching time, nondeterministic actions). The Situation Calculus and related axiomatization techniques are basedon a branching time-structure, where the situations are commonly defined by the constant S 0 : time and the functionDo : action × time (cid:10)→ time. A standard example for a nondeterministic action is that of dropping a pin on a checkerboard[20]. The pin may land on a white square, a black square, or both. Let the fluents Pin(x), White(x), and Black(x) denotethat x is a pin and that it is, respectively, on a white and a black square. The action Drop(x) can then be axiomatized bythe following precondition and effect axiom.(cid:2)(cid:2)PossPoss(cid:3)Drop(x), s, t(cid:2)≡ HoldsPin(x), s(cid:2)∧ t = DoDrop(x), s(cid:3)(cid:2)∧ ¬Holds(cid:3)White(x), s(cid:3)(cid:2)∧ ¬HoldsBlack(x), s(cid:3)(3)Drop(x), s, t(cid:3)⊃(cid:2)(cid:4)(cid:5)(∀ f )f = White(x) ∨ Holds( f , s) ⊃ Holds( f , t)(cid:4)f (cid:12)= White(x) ∧ ¬Holds( f , s) ⊃ ¬Holds( f , t)∧ (∀ f )(cid:5)(cid:4)(cid:2)f = Black(x) ∨ Holds( f , s) ⊃ Holds( f , t)(∀ f )∨(cid:5)(cid:3)1 Throughout the paper, free variables are assumed universally quantified.2 The purpose of sub-formula Φi [s] is to define conditions for case i to apply. Whenever it is tautology, we will simply omit this formula.M. Thielscher / Artificial Intelligence 175 (2011) 120–141(cid:4)f (cid:12)= Black(x) ∧ ¬Holds( f , s) ⊃ ¬Holds( f , t)∧ (∀ f )(cid:2)(cid:5)(cid:4)(∀ f )∨f = White(x) ∨ f = Black(x) ∨ Holds( f , s) ⊃ Holds( f , t)(cid:4)f (cid:12)= White(x) ∧ f (cid:12)= Black(x) ∧ ¬Holds( f , s) ⊃ ¬Holds( f , t)∧ (∀ f )(cid:5)(cid:3)(cid:5)(cid:3)123(4)The three disjuncts in the effect axiom encode the three possible outcomes of the nondeterministic action, including thecase where the pin lands on both white and black. Each of the sub-formulas describing the update includes a solutionto the Frame Problem: all fluents except possibly Black(x) and White(x) retain their value in the successor situationt = Do(Drop(x), s). As an example, suppose given the initial state description,(cid:3)(cid:3)(cid:3)(cid:2)HoldsPin(A), S0(cid:2)∧ ¬HoldsWhite(A), S0(cid:2)∧ ¬HoldsBlack(A), S0(5)along with the observation ¬Holds(White(A), Do(Drop(A), S0)). Together with the domain axioms this implies thatHolds(Black(A), Do(Drop(A), S0)). To see why, from (5) and precondition axiom (3) it follows that Poss(Drop(A), S 0,Do(Drop(A), S0)). The first and third disjunct in effect axiom (4) then imply Holds(White(A), Do(Drop(A), S 0)), whichcontradicts the observation. Therefore the claim follows by the second disjunct.It is worth mentioning that some nondeterministic actions can be formulated in the unifying calculus without a disjunc-tive effect axiom, namely by simply excluding one or more fluents from the frame assumption. An example is the followingaxiomatization of the effect of tossing a coin.(cid:2)Toss(c), s, t(cid:3)Poss(cid:4)⊃ (∀ f )(cid:5)f (cid:12)= Heads(c) ∧ Holds( f , s) ⊃ Holds( f , t)(cid:4)∧ (∀ f )(cid:5)f (cid:12)= Heads(c) ∧ ¬Holds( f , s) ⊃ ¬Holds( f , t)where fluent Heads(c) denotes that coin c shows heads. This corresponds to the notion of occlusion or release as used in,e.g., [34] and [37].Example 2 (Branching time, ramifications). Consider a variant, introduced in [2], of the famous Yale Shooting scenario [12]with fluents Loaded, Alive, and Walking representing that a gun is loaded and that the turkey is alive and walking,respectively. The following domain constraint says that the turkey can walk only if it is alive.Holds(Walking, t) ⊃ Holds(Alive, t)(6)Let Load, Wait, and Shoot denote the actions of loading the gun, waiting, and shooting, respectively. Their preconditionsshall be as follows.Poss(Load, s, t) ≡ t = Do(Load, s)Poss(Wait, s, t) ≡ t = Do(Wait, s)Poss(Shoot, s, t) ≡ t = Do(Shoot, s)(7)The following schema for the effect axioms encodes a combined solution to the Frame and Ramification Problem which is areformulation of the causal approach described in [10].(cid:5)(cid:4)CausedT( f , a, s, t) ∨ ¬CausedF( f , a, s, t) ⊃ Holds( f , t)Poss(a, s, t) ⊃ (∀ f )(cid:5)(cid:4)CausedF( f , a, s, t) ∨ ¬CausedT( f , a, s, t) ⊃ ¬Holds( f , t)∧ (∀ f )whereCausedT( f , a, s, t) def= Holds( f , s) ∧ Holds( f , t)∨ f = Loaded ∧ a = LoadCausedF( f , a, s, t) def= ¬Holds( f , s) ∧ ¬Holds( f , t)∨ f = Alive ∧ Holds(Loaded, s) ∧ a = Shoot∨ f = Walking ∧ ¬Holds(Alive, t)(8)(9)Macro CausedT( f , a, s, t) combines a positive frame assumption (that is, Holds( f , s) ∧ Holds( f , t)) with the possible positiveeffects in the domain; here, the fact that the gun becomes loaded by loading it. Likewise, CausedF( f , a, s, t) combinesa negative frame assumption with the possible negative effects: if the gun is loaded when shooting it, then the turkeydies; and if in a successor situation the turkey is not alive, then this causes it not to be walking. The latter describes anindirect effect related to the domain constraint, (6), but conveying additional, causal information to solve the Ramification124M. Thielscher / Artificial Intelligence 175 (2011) 120–141Problem [10]. (Note also that, after two decades of shooting a turkey in Yale, so doing no longer unloads the gun.) It is easyto see that action variable a in schema (8) can be instantiated by the three actions of this domain in order to obtain effectaxioms that are actually of the form required by Definition 3.The domain axiomatization entails, for example, ¬Holds(Walking, Do(Shoot, Do(Wait, Do(Load, S 0)))). To see why,let S1 = Do(Load, S0), S2 = Do(Wait, S1), and S3 = Do(Shoot, S2). Precondition axioms (7) imply Poss(Load, S0, S1),Poss(Wait, S1, S2), and Poss(Shoot, S2, S3). From definition (9), we obtain CausedT(Loaded, Load, S0, S1); hence, effectaxiom (8) entailsHolds(Loaded, S1)(10)loaded through the subsequent Wait action: given uniqueness-of-names,The gun remainsthatCausedF(Loaded, Wait, S1, S2) is equivalent to ¬Holds(Loaded, S1) ∧ ¬Holds(Loaded, S2). Because of (10), this actuallyimplies ¬CausedF(Loaded, Wait, S1, S2). It follows from (8) thatimplies(9)Holds(Loaded, S2)(11)(It is worth mentioning that this, together with (10), implies CausedT(Loaded, Wait, S 1, S2). This is how the Frame Prob-lem is solved in the axiomatization technique used here: fluent Loaded is “caused” to be true in S 2 simply by staying truefrom S1 to S2.) Given that the gun is still loaded, the Shoot action has the effect that the turkey dies and, as an indirecteffect, that it stops walking: from (9) and (11) it follows that CausedF(Alive, Shoot, S 2, S3). Hence, ¬Holds(Alive, S3)by (8). This, in turn, implies CausedF(Walking, Shoot, S2, S3) according to (9), from which the claim follows by (8) again.Example 3 (Linear time, actions with duration). The Event Calculus and other axiomatization techniques use a linear timestructure, like for example the natural numbers. The following scenario is adapted from [33]. Let the fluents Assembledand Instr denote, respectively, the state of an assembly kit and the availability of assembly instructions. To representthe occurrence of actions, we add a fluent called Occurs(a, s, t), which describes the fact that action a actually happens,starting at time s and ending at time t. We consider two actions: Assemble, which has the effect that the kit is assembledin the end; and the special action Inert, which is used to axiomatize the frame assumption between two time pointswhen nothing else happens:(cid:4)Poss(Assemble, s, t) ⊃ (∀ f )(cid:5)f = Assembled ∨ Holds( f , s) ⊃ Holds( f , t)(cid:4)∧ (∀ f )(cid:5)f (cid:12)= Assembled ∧ ¬Holds( f , s) ⊃ ¬Holds( f , t)(cid:5)(cid:4)Holds( f , s) ⊃ Holds( f , t)Poss(Inert, s, t) ⊃ (∀ f )(cid:5)(cid:4)¬Holds( f , s) ⊃ ¬Holds( f , t)∧ (∀ f )The preconditions for the two actions are as follows.(cid:2)Poss(Assemble, s, t) ≡ Holds(cid:3)(cid:4)Occurs(Assemble, s, t), s(cid:5)Holds(Instr, s) ⊃ t = s + 20∧(cid:4)¬Holds(Instr, s) ⊃ t = s + 60(cid:5)∧(cid:2)Poss(Inert, s, t) ≡ ¬(cid:13)∃a, s, t(cid:13)(cid:3)(cid:2)(cid:2)Holds(cid:2)Occursa, s(cid:13), t(cid:3)(cid:13), s(cid:3)(cid:13)∧ s< t ∧ t(cid:13)> s(cid:3)(12)(13)Put in words, assembling has a variable duration, depending on the availability of instructions. The generic Inert action ispossible between any two time points s and t whenever there is no action that starts before t and ends after s. In order thatthe second precondition axiom in (13) complies with Definition 3, the right-hand side must be a state formula in s. This, inturn, requires all action occurrences to be “known” at all times, which can be easily obtained by the generic definition ofdomain constraints via the following macro.Happens(a, s, t) def=(cid:2)(cid:3)(cid:2)Holds(cid:13)∀tOccurs(a, s, t), t(cid:3)(cid:13)As an example, consider a scenario in which only a single action occurs,(cid:2)(∃ta)(cid:4)Poss(Assemble, 100, ta) ∧ (∀a, s, t)Happens(a, s, t) ≡ a = Assemble ∧ s = 100 ∧ t = ta(cid:5)(cid:3)(14)(15)along with the observation ¬Holds(Assembled, 130). This, together with the domain axioms, implies ¬Holds(Instr, 0);that is to say, if the kit is not yet assembled at time 130 then the instructions were not present from the beginning. To seewhy, suppose, for the sake of argument, that Poss(Assemble, 100, 120). We show that this leads to a contradiction: from(12) it follows thatHolds(Assembled, 120)(16)M. Thielscher / Artificial Intelligence 175 (2011) 120–141125(15), definition (14), and Poss(Assemble, 100, 120) along with (13)there is no instanceMoreover,(cid:13) > 120. Therefore, Poss(Inert, 120, 130) according to (13). In turn, this and (16)Holds(Occurs(a, simply Holds(Assembled, 130) by (12), which contradicts the observation. Hence, ¬Poss(Assemble, 100, 120). This andPoss(Assemble, 100, ta) entail ¬Holds(Instr, 100) due to (13). The claim ¬Holds(Instr, 0) then follows from (12) andthe fact that Poss(Inert, 0, 100) (which the reader may easily verify from (14) and (15)).(cid:13)), 120) such that timply that(cid:13), tThese examples show that the unifying calculus allows to model a variety of ontological features. We conclude thissection by defining three important sub-classes of domain axiomatizations, which will be used later in the paper. To beginwith, a domain axiomatization is called progressing if there is a least time point and if time always moves forward when anaction is executed.Definition 4. A domain axiomatization with precondition axioms Π and foundational axioms Ω is progressing if1. Ω |(cid:14) (∃s : time)(∀t : time)s (cid:2) t and2. Π ∪ Ω |(cid:14) Poss(a, s, t) ⊃ s < t.A domain axiomatization is called sequential if it is progressing and no two actions overlap.Definition 5. A domain axiomatization with precondition axioms Π and foundational axioms Ω is sequential if it is pro-gressing andΠ ∪ Ω |(cid:14) Poss(a, s, t) ∧ Poss(cid:2)a(cid:13)(cid:13), s, t(cid:3)(cid:13)(cid:2)t < t⊃(cid:13) ⊃ t (cid:2) s(cid:13)(cid:3)(cid:2)t = t∧(cid:13) ⊃ a = a(cid:13) ∧ s = s(cid:13)(cid:3)In Example 2 we have seen how ramifications of actions are obtained if an effect depends on conditions of the successorstate, as inf = Walking ∧ ¬Holds(Alive, t) ⊃ ¬Holds( f , t)(cf. (9) and (8), respectively). This gives rise to the following definition.Definition 6. A domain axiomatization is ramification-free if each Υi[s, t] in an effect axiom (1) is of the form(cid:2)(∃(cid:3)yi)(cid:4)Φi[s] ∧ (∀ f )Γ(cid:4)∧ (∀ f )Γ−i[s] and Γ+i+i−i(cid:5)[s] ⊃ Holds( f , t)[s] ⊃ ¬Holds( f , t)(cid:5)(cid:3)where both Γ[s] are state formulas in s.3. Translations based on the unifying approachIn this section, we show how the unifying calculus can be used as an intermediary language for translating specificcalculi into each other. The general idea is to map domain descriptions in one language into domain axiomatizations in theunifying calculus, and then to re-write those into the target language. This provides a uniform method for embedding (well-defined classes) of domains in a variety of existing approaches, which also allows to compare their relative expressiveness.The advantage of using the unifying action calculus as a middle language is two-fold:1. A mapping from the source language into the unifying calculus results in a generic representation, which can then befurther mapped onto a variety of different target languages, thus avoiding the need for complete translations in eachcase.2. Once a mapping into a target language has been developed for a specific class of domains in the unifying calculus, itsuffices to map a source language into that class to obtain a full translation from source to target.We exemplify our method by two new results: an axiomatic characterization of ADL planning problems in the Event Cal-culus, and a translation of the basic Fluent Calculus into the Situation Calculus. As a by-product we define an extension ofReiter’s basic Situation Calculus which is suitable for nondeterministic actions and which is somewhat more general thanthe approach proposed in [20].3.1. Translating ADL into the event calculus3.1.1. From ADL . . .In order to give an Event Calculus characterization of the planning language ADL, introduced in [29], we first interpretADL in our unifying calculus. For the definition of this planning language we follow [6].126M. Thielscher / Artificial Intelligence 175 (2011) 120–141Definition 7. An ADL signature consists of: a finite set of types, possibly including definitions of types as disjunctive unionsof other types; a finite set of typed constants; a finite set of typed fluents; and a finite set of typed action names.An ADL planning problem is composed of the following elements.1. For each operator name A((cid:3)x) a precondition π , which is a first-order formula with free variables among (cid:3)x and whoseatoms are fluents F ((cid:3)t) or equalities t1 = t2.2. For each operator name A((cid:3)x) a finite set of effect specifications, which are of either of the forms(cid:2)(∀(cid:3)yi)γ +i(cid:3)⇒ F i((cid:3)yi)(cid:2)(∀(cid:3)y j)γ −j(cid:3)⇒ ¬F j((cid:3)y j)(17)j are first-order formulas with free variables among, respectively, (cid:3)x, (cid:3)yi and (cid:3)x, (cid:3)y j , andwhere the conditions γ +whose atoms are fluents F ((cid:3)t) or equalities t1 = t2.3iorand γ −3. A conjunction of ground fluent literals as the (possibly incomplete) initial state specification and a closed first-orderformula as the planning goal.Example 4. Consider the following specification of the action Move(object, old, new) in the well-known blocksworld:Precondition: On(object, old) ∧ ¬(old = new)Effects:∧ ¬(∃z)On(z, object) ∧ ¬(∃z)On(z, new)(cid:2)(∀x, y)(cid:2)(∀x, y)(cid:2)(∀x, y)(cid:2)(∀x, z)(cid:2)(∀x, z)(cid:3)x = object ∧ y = new ⇒ On(x, y)(cid:3)x = object ∧ y = old ⇒ ¬On(x, y)(cid:3)x = object ∧ y = new ⇒ Above(x, y)(cid:3)x = object ∧ Above(new, z) ⇒ Above(x, z)(cid:3)x = object ∧ Above(x, z) ⇒ ¬Above(x, z)(18)The bottommost two expressions specify an unbounded number of effects, which is one of the characteristic features of ADLthat go beyond the expressiveness of STRIPS.The semantics of an ADL domain description requires the definition of a transition function on complete states. Theseare represented as ground sets of fluents S, and the basis for entailment is the definition S |(cid:14) F ((cid:3)t) iff F ((cid:3)t) ∈ S for a groundfluent F ((cid:3)t).Definition 8. Consider an ADL planning problem, and let S and S (cid:13)of an action with precondition π and effect specifications (17), thenbe two sets of ground fluents and A((cid:3)t) a ground instanceS (cid:2)A((cid:3)t)S(cid:13)if the action is applicable in S, that is, S |(cid:14) π {(cid:3)x (cid:10)→ (cid:3)t}, and if S(cid:13) = S \ D ∪ A, where the delete-list D is the set of allground fluents F j((cid:3)r) such that S |(cid:14) γ −{(cid:3)x (cid:10)→ (cid:3)t, (cid:3)y j (cid:10)→ (cid:3)r} and the add-list A is the set of all ground fluents F i((cid:3)r) such thatS |(cid:14) γ +{(cid:3)x (cid:10)→ (cid:3)t, (cid:3)yi (cid:10)→ (cid:3)r}.A sequence α1, . . . , αn of ground actions is a solution to the planning problem if for every S0 which satisfies the initialjistate,S0 (cid:2)α1· · · (cid:2)αnsuch that Sn entails the planning goal.SnBecause it is not a purely logical axiomatization, an ADL description does not presuppose a particular time structure. Thisallows for various interpretations; for example, [3] uses branching time for an embedding of ADL in the Situation Calculus.In view of a translation into the Event Calculus, we map ADL planning problems into our unifying calculus using a lineartime structure, specifically the natural numbers. To begin with, the type declarations are taken as a specification of domainsorts. The ADL operator names are mapped onto functions into sort action, and the ADL fluents are mapped onto functionsinto sort fluent. Much like in Example 3, we add the special fluent Occurs(a : action, t : N) to represent the occurrenceof an action at a specific time. An ADL domain description can then be translated into a domain axiomatization using ourunifying calculus as follows.3 The original definition actually allows to partially instantiate the arguments of the fluents F i ((cid:3)yi ) and F j((cid:3)y j ) in (17). For the sake of simplicity, weassume that this is equivalently represented by equations in γ +, respectively.and γ −ijM. Thielscher / Artificial Intelligence 175 (2011) 120–1411271. The foundational axioms define the time structure to be the natural numbers N with least element 0.2. The precondition axioms are,(cid:2)(cid:3)(cid:2)≡ Holds(cid:2)Occurs(cid:3)(cid:3)A((cid:3)x), s, tPoss(19)where π A[s] is the ADL precondition for operator A((cid:3)x) but with every occurrence of a fluent φ replaced by Holds(φ, s).A((cid:3)x), s, s∧ t = s + 1 ∧ π A[s]3. The effect axioms are,(cid:3)(cid:2)A((cid:3)x), s, tPosswhere(cid:4)(cid:2)⊃ (∀ f )+ΓA(cid:4)(cid:2)∧ (∀ f )Γ∨ Holds( f , s) ∧ ¬Γ−A∨ ¬Holds( f , s) ∧ ¬Γ(cid:3)−A(cid:5)⊃ Holds( f , t)+A(cid:5)⊃ ¬Holds( f , t)(cid:3)Γ+Adef=(cid:6)(cid:2)(∃(cid:3)yi)γ +i(cid:3)[s] ∧ f = F ((cid:3)yi)i(cid:6)(cid:2)(∃(cid:3)y j)Γ−Adef=(cid:3)[s] ∧ f = F ((cid:3)y j)γ −j(20)(21)j[s] and γ −Here, γ +replaced by Holds(φ, s).ji[s] are as γ +iand γ −jin the ADL effect specifications for action A((cid:3)x) but with every fluent φ4. An initial state I is mapped to the formula I[0] where every fluent φ is replaced by Holds(φ, 0).5. A sequence of actions α1, . . . , αn is mapped onto the formula(cid:2)(cid:2)(∀t)HoldsOccurs(a, s), t(cid:3)≡ a = α1 ∧ s = 0 ∨ · · · ∨ a = αn ∧ s = n − 1(cid:3)(22)Example 4 (Continued). Recall effect specifications (18). These are mapped onto the general effect axiom (20) forMove(object, old, new) withΓ+MoveΓ−Movedef= f = On(object, new) ∨ f = Above(object, new)(cid:2)∨ (∃z)(cid:2)HoldsAbove(new, z), s(cid:3)(cid:3)∧ f = Above(object, z)def= f = On(object, old)(cid:2)∨ (∃z)(cid:2)HoldsAbove(object, z), s(cid:3)(cid:3)∧ f = Above(object, z)(23)The mapping of ADL into the unifying calculus can be easily proved correct under the assumption that the effect speci-fications (17) for every action are consistent, that is,(cid:7)(cid:6)(cid:8)γ +i∧(cid:6)γ −j|(cid:14) ¬(24)ijwhere i and j range over all effect formulas for the same fluent.Proposition 9. Let Σ be the domain axiomatization obtained from a consistent ADL domain with goal G, then a sequence of actionsα1, . . . , αn is a solution to the planning problem iff(cid:9)(cid:10)(22)Σ ∪|(cid:14) G[n]where G[n] is G but with every fluent φ replaced by Holds(φ, n).be two sets of ground fluents, s a time point, and A((cid:3)t) a ground action. In the following, by S[s] we denoteProof. Let S, S(cid:13)the conjunction of all atoms Holds(φ, s) for which φ ∈ S, plus all ¬Holds(φ, s) for ground fluents such that φ /∈ S. This ispossible because there are only finitely many fluent functions and object constants.Since the fluent for action occurrences does not feature in the ADL effect specifications, effect axiom (20) implies that(cid:3)(cid:3)(cid:2)(cid:3)(cid:2)HoldsOccurs(a, s), t⊃(cid:13)∀t(cid:2)HoldsOccurs(a, s), t(cid:13)From (19) it then follows that A((cid:3)t) is applicable in S iff(cid:2)(cid:2)Occurs|(cid:14) S[s] ⊃ Poss(cid:2)HoldsA((cid:3)t), sΣ ∪(cid:3)(cid:10), s(cid:9)(cid:3)A((cid:3)t), s, s + 1(cid:3)Under the consistency assumption (24), effect axiom (20) then implies that S (cid:2)S(cid:13)iffA((cid:3)t)128M. Thielscher / Artificial Intelligence 175 (2011) 120–141(cid:9)(cid:2)PossΣ ∪A((cid:3)t), s, s + 1(cid:3)(cid:10)|(cid:14) S[s] ⊃ S(cid:13)[s + 1]since, by Definition 8, for any ground fluent we have F i((cid:3)r) ∈ A iff S |(cid:14) γ +{(cid:3)x (cid:10)→ (cid:3)t, (cid:3)y (cid:10)→ (cid:3)r} iff S[s] |(cid:14) Γ +{(cid:3)x (cid:10)→ (cid:3)t, (cid:3)y (cid:10)→ (cid:3)r}, andiF j((cid:3)r) ∈ D iff S |(cid:14) γ −{(cid:3)x (cid:10)→ (cid:3)t, (cid:3)y (cid:10)→ (cid:3)r} iff S[s] |(cid:14) Γ −{(cid:3)x (cid:10)→ (cid:3)t, (cid:3)y (cid:10)→ (cid:3)r}. Hence, F ((cid:3)t) ∈ S \ D ∪ A iff {(20)} ∪ {Poss( A((cid:3)t), s, s + 1)} |(cid:14)S[s] ⊃ Holds(F ((cid:3)t), s + 1), and, conversely, F ((cid:3)t) /∈ S \ D ∪ A iff {(20)} ∪ {Poss( A((cid:3)t), s, s + 1)} |(cid:14) S[s] ⊃ ¬Holds(F ((cid:3)t), s + 1). Thisshows that the precondition and effect axioms correctly encode the update of states in ADL according to Definition 8. Theclaim then follows by straightforward induction on n. (cid:3)j3.1.2.. . . to the Event CalculusThe Event Calculus uses a linear time structure, which allows us to adopt directly the natural numbers used in theaxiomatization of an ADL planning problem from above. In the simple Event Calculus [37], the predicate Happens(a, t)denotes the occurrence of an action (a.k.a. event) at a given time point. Effects of actions are axiomatized based on thepredicates Initiates(a, f , t) and Terminates(a, f , t) representing, respectively, the initiation and termination of fluent f attime t by action a. The Frame Problem is then solved in two steps. First, by minimizing predicates Initiates and Terminatesusing circumscription [23], and then by applying the following foundational axioms, where Init P ( f ) and InitN ( f ) are usedto specify positive and negative initial conditions.Holds( f , t) ⊂ Init P ( f ) ∧ ¬Clipped(0, f , t)(cid:2)∨ (∃a, s)(cid:3)Happens(a, s) ∧ Initiates(a, f , s) ∧ s < t ∧ ¬Clipped(s, f , t)¬Holds( f , t) ⊂ InitN ( f ) ∧ ¬Declipped(0, f , t)(cid:2)∨ (∃a, s)(cid:3)Happens(a, s) ∧ Terminates(a, f , s) ∧ s < t ∧ ¬Declipped(s, f , t)Clipped(s, f , t) def=(cid:2)Declipped(s, f , t) def=∃a, t∃a, t(cid:2)(cid:3)(cid:2)(cid:13)(cid:13)(cid:3)(cid:2)a, tHappens(cid:2)(cid:3)(cid:2)a, tHappens(cid:13)(cid:2)a, f , t(cid:3)(cid:13)∧ s < t(cid:13)∧ Terminates(cid:2)(cid:3)a, f , t∧ Initiates(cid:13)(cid:3)(cid:13)∧ s < t(cid:13)(cid:3)< t(cid:3)< t(25)Put in words, a fluent holds at time t if it is true initially or is initiated by an earlier action and not terminated in between(definition Clipped). Conversely, a fluent does not hold at time t if it is false initially or terminated by an earlier action andnot initiated in between (definition Declipped).In the following we show how the domain axiomatization resulting from mapping an ADL planning problem into ourunifying calculus can be translated into the simple Event Calculus. Generally, the translation of a domain axiomatizationinto a language based on a linear time structure would require to introduce a special “occurrence” fluent Occurs(a, s) andto identify, in case of the simple Event Calculus with natural numbers, the predicate Happens(a, s) with Poss(a, s, s + 1) ∧Holds(Occurs(a, s), s). For the sake of simplicity, however, we can exploit the fact that this fluent is already present in thedomain axiomatizations of ADL planning problems. In this way, we obtain the following translation into the Event Calculus.1. The sorts, actions, and fluents are the same.2. The foundational axioms on the time structure are augmented by (25).3. The precondition axioms (19) are re-written to(cid:3)(cid:2)HappensA((cid:3)x), s⊃ π A[s]4. The set of effect axioms (20) is translated into the formulasΓΓ+A−A⊃ Initiates⊃ Terminates(cid:2)(cid:2)(cid:3)A((cid:3)x), f , s(cid:3)A((cid:3)x), f , sPredicates Initiates and Terminates are circumscribed locally, which results in the second-order axiomCIRC(cid:11)(cid:6)A( 27); Initiates, Terminates(cid:12)(26)(27)(28)5. The initial formula I[0] is mapped onto a formula where each Holds( f , 0) is replaced by Init P ( f ) and each ¬Holds( f , 0)by InitN ( f ).6. The encoding of a plan, (22), remains unchanged.Example 4 (Continued). Recall the sub-formulas (23) of the general effect axiom (20). Assuming that Move is the only actionin this domain with an actual effect, the corresponding Event Calculus definition of initiation and termination is equivalentto the following.M. Thielscher / Artificial Intelligence 175 (2011) 120–141129(cid:2)Move(object, old, new), On(object, new), s(cid:2)Move(object, old, new), Above(object, new), s(cid:2)Move(object, old, new), Above(object, z), s(cid:3)(cid:3)(cid:3)InitiatesInitiatesInitiates(cid:2)(cid:2)TerminatesTerminatesMove(object, old, new), On(object, old), sMove(object, old, new), Above(object, z), s(cid:3)(cid:2)⊂ HoldsAbove(object, z), s(cid:3)Above(new, z), s(cid:3)(cid:2)⊂ Holds(cid:3)The equivalence of the domain constraints and precondition axioms are obvious. The correctness of the translation of theeffect axioms is given by the following result.Proposition 10. Let Σ be a domain axiomatization resulting from an ADL planning problem, and let α1, . . . , αn be an action sequencesuch that Σ |(cid:14) Poss(α1, 0, 1) ∧ · · · ∧ Poss(αn, n − 1, n). Let ΣEC be the mapping of Σ into the Event Calculus, then for any fluent φΣ |(cid:14) (¬)Holds(φ, t)iff ΣEC |(cid:14) (¬)Holds(φ, t)for all t = 1, . . . , n.Proof. Suppose Σ |(cid:14) Holds(φ, t), then by (20), Σ |(cid:14) Γ +αtimply that if ΣEC |(cid:14) Holds(φ, t), then ΣEC entails either∨ Holds(φ, t − 1) ∧ ¬Γ −αt. Correspondingly, foundational axioms (25)1. Initiates(αt, φ, t − 1), or2. (∃m, s)(Initiates(αm, φ, m − 1) ∧ m < n − 1 ∧ ¬Clipped(m, φ, n)), or3. Init P (φ) ∧ ¬Clipped(0, φ, n).By (28), the first case is equivalent to Γ +αtwhile the other two, by (25) and (28), are equivalent to Holds(φ, t − 1) ∧ ¬Γ −αt.Suppose Σ |(cid:14) ¬Holds(φ, t), then by (20), Σ |(cid:14) Γ −αtimply that if ΣEC |(cid:14) ¬Holds(φ, t), then ΣEC entails either∨ ¬Holds(φ, t − 1) ∧ ¬Γ +αt. Correspondingly, foundational axioms (25)1. Terminates(αt, φ, t − 1), or2. (∃m, s)(Terminates(αm, φ, m − 1) ∧ m < n − 1 ∧ ¬Declipped(m, φ, n)), or3. InitN (φ) ∧ ¬Declipped(0, φ, n).By (28), the first case is equivalent to Γ −αt¬Γ +αt. (cid:3)while the other two, by (25) and (28), are equivalent to ¬Holds(φ, t − 1) ∧Together with Proposition 9 this shows that we have obtained a correct translation of ADL planning problems into theEvent Calculus.3.2. Translating the Fluent Calculus into the Situation CalculusAs a second result, we present a translation from the simple Fluent Calculus via the unifying calculus into the SituationCalculus based on Reiter’s solution to the Frame Problem. As a by-product we obtain an extension of the latter suitable fornondeterministic actions.3.2.1. From the Fluent Calculus . . .The Fluent Calculus is a variant of the Situation Calculus which uses the same branching time structure (cf. Example 2)and which adds to it a sort state as an explicit representation for states. Intuitively, a state is identified with the fluents thathold in it. The state in situation s is denoted by the standard function State(s). By definition, each fluent itself is a (singleton)state, and if z1 and z2 are states, then so is their composition denoted by z1 ◦ z2. The empty state is represented by thespecial constant ∅. The behavior of the function “◦” is governed by the following foundational axioms, which essentiallydefine states as non-nested sets of fluents. In the following, Holds( f , z) is used as an abbreviation for the equational formula(∃z, which amounts to an axiomatic characterization of set membership.4(cid:13))z = f ◦ z(cid:13)(z1 ◦ z2) ◦ z3 = z1 ◦ (z2 ◦ z3)¬Holds( f , ∅)Holds( f , z1 ◦ z2) ⊃ Holds( f , z1) ∨ Holds( f , z2)(∀P )(∃z)(∀ f )(Holds( f , z) ≡ P ( f ))z1 ◦ z2 = z2 ◦ z1Holds( f 1, f ) ⊃ f 1 = f(∀ f )(Holds( f , z1) ≡ Holds( f , z2)) ⊃ z1 = z2(29)4 Below, the letter z always denotes variables of sort state.130M. Thielscher / Artificial Intelligence 175 (2011) 120–141The last axiom, where P is a second-order predicate variable of sort fluent, stipulates the existence of a state for any(possibly infinite) set of fluents. These axioms are accompanied by the foundational axioms on situations, inherited fromthe Situation Calculus of [30]:(cid:2)(∀s)¬s < S0(cid:3)(cid:2)(cid:2)(cid:13)(cid:13)∀a, a, s, s(cid:3)(cid:2)(cid:13)∀a, s, s(cid:2)(∀P )(cid:2)(cid:13)Do(a, s) = Do, sa(cid:3)(cid:2)(cid:13)(cid:13)≡ s (cid:2) sa, ss < Do(cid:3)(cid:2)P (s) ⊃ P (Do(a, s))P (S0) ∧ (∀a, s)⊃ a = a(cid:3)(cid:3)(cid:13)(cid:3)(cid:13)(cid:13) ∧ s = s(cid:3)⊃ (∀s)P (s)(30)The last axiom, where P is a second-order predicate variable of sort sit, defines an induction principle over situations: ifthe initial situation satisfies a property P and this property is preserved through the execution of actions, then P is true forall situations.Effects of actions are specified in the Fluent Calculus with the help of a purely axiomatic characterization of subtractionand addition of fluents from and to states:z2 = z1 + fz2 = z1 − fdef= z2 = z1 ◦ fdef= (z2 = z1 ∨ z2 ◦ f = z1) ∧ ¬Holds( f , z2)These macros can be straightforwardly generalized to the subtraction and addition of finitely many fluents. On this ba-sis, domains are axiomatized in the simple Fluent Calculus as follows, where the expression Holds( f , s) in uniform stateformulas (in the sense of Definition 2) stands for Holds( f , State(s)).(31)(32)(33)+iDefinition 11. A simple Fluent Calculus domain is composed of the following elements.1. Domain constraints, which are of the formδ[s]where δ is a state formula in s.2. Precondition axioms, one for every action A((cid:3)x), which are of the form(cid:2)PossA((cid:3)x), s(cid:3)≡ π A[s]where π A[s] is a state formula in s with free variables among s, (cid:3)x.3. So-called state update axioms, one for every action A((cid:3)x), which are of the form(cid:3)(cid:3)(cid:3)(cid:3)(cid:2)(cid:2)PossA((cid:3)x), s(cid:2)⊃ (∃(cid:3)y1)Φ1[s] ∧ State(cid:2)DoA((cid:3)x), s−= State(s) − ϑ1++ ϑ1∨ · · · ∨(cid:2)(∃(cid:3)yn)Φn[s] ∧ State(cid:2)(cid:2)DoA((cid:3)x), s(cid:3)(cid:3)−= State(s) − ϑn++ ϑn(cid:3)where each Φi[s] is a state formula in s with free variables among s, (cid:3)x, (cid:3)yi and ϑ(the positive effects) stand for zero or more subtractions and additions, respectively, of fluent terms with variablesamong (cid:3)x, (cid:3)yi .(the negative effects) and ϑ−iThe basic theorem of the Fluent Calculus (see, e.g., [42]) says that the equations in state update axioms provide a solutionto the Frame Problem.Theorem 12. Foundational axioms (29) entail that(cid:3)(cid:2)(cid:13)sStateimplies= State(s) − g1 − · · · − gm + f 1 + · · · + fn(cid:2)Holdsf , State(cid:6)(cid:3)(cid:3)(cid:2)(cid:13)s≡f = f i ∨iand vice versa.(cid:11)(cid:2)Holds(cid:3)f , State(s)∧(cid:12)f (cid:12)= g j(cid:13)jA state update axiom (33) specifies an action with indeterminate effects if n > 1 and the conditions Φi are not mutuallyexclusive. But an action can also be nondeterministic if its state update axiom has a single update equation which isaccompanied by an underspecified condition.M. Thielscher / Artificial Intelligence 175 (2011) 120–141Example 5. Consider the following axiom, which specifies alternative forms of payments.(cid:2)Poss(Pay, s) ⊃ (∃ y)(cid:2)HoldsHasPayment( y), s(cid:3)∧ State(cid:2)(cid:3)Do(Pay, s)(cid:3)= State(s) − HasPayment( y)131(34)Suppose, for example, Holds(HasPayment( y), S0) ≡ y = Cash ∨ y = Cheque, then according to Theorem 12 this stateupdate axiom implies(cid:2)¬Holds(cid:3)HasPayment(Cash), Do(Pay, S0)(cid:2)∨ ¬Holds(cid:3)HasPayment(Cheque), Do(Pay, S0)but neither of the disjuncts alone is entailed.Based on Theorem 12, the translation of basic Fluent Calculus theories into our unifying calculus is straightforward.Domain constraints are taken as they are. A precondition axiom (32) is re-written as(cid:2)PossA((cid:3)x), s, t(cid:3)(cid:2)≡ π A[s] ∧ t = DoA((cid:3)x), s(cid:3)A state update axiom (33) is mapped onto the effect axiom(cid:14)⊃ (∃(cid:3)y1)Φ1[s] ∧ (∀ f )A((cid:3)x), s, t(cid:15)(cid:6)Poss(cid:2)(cid:3)f = f 1i ∨ Holds( f , s) ∧(cid:13)(cid:16)f (cid:12)= g1 j ⊃ Holds( f , t)(35)(cid:16)(cid:17)∧ (∀ f )f = g1 j ∨ ¬Holds( f , s) ∧f (cid:12)= f 1i ⊃ ¬Holds( f , t)i∨ · · · ∨(cid:14)(∃(cid:3)yn)Φn[s] ∧ (∀ f )f = fni ∨ Holds( f , s) ∧(cid:13)(cid:16)f (cid:12)= gnj ⊃ Holds( f , t)(cid:16)(cid:17)j(cid:13)j(cid:13)i(cid:15)(cid:6)(cid:15)(cid:6)(cid:15)(cid:6)jij∧ (∀ f )f = gnj ∨ ¬Holds( f , s) ∧f (cid:12)= fni ⊃ ¬Holds( f , t)i(36)−+k and ϑHere, the fki and gkj are the fluent terms that occur in ϑk , respectively. The equivalence of this mapping is obviousfor both domain constraints and precondition axioms. As the following proposition shows, correctness of the effect axiomsfollows if the updates are consistent, that is,(cid:13)(cid:13)fki (cid:12)= gkj(37)ijfor all k = 1, . . . , n.Proposition 13. Suppose Poss( A((cid:3)x), s) and Poss( A((cid:3)x), s, t) ≡ t = Do( A((cid:3)x), s), and assume that (37) holds for a state update axiom(33), then the foundational axioms of the Fluent Calculus imply that (33) and (36) are equivalent.Proof. Under the consistency assumption, the implication(cid:11)(cid:12)f = gkj ∨¬Holds( f , s) ∧f (cid:12)= fki⊃ ¬Holds( f , t)(cid:6)j(cid:13)iis logically equivalent to(cid:11)(cid:13)Holds( f , t) ⊃(cid:12)f (cid:12)= gkj ∧ Holds( f , s)∨(cid:6)f = fkijiHence, (36) can be equivalently written as(cid:2)PossA((cid:3)x), s, t(cid:3)⊃(cid:6)(cid:7)(∃(cid:3)yk)Φk[s] ∧ (∀ f )ki(cid:11)(cid:6)f = fki ∨ Holds( f , s) ∧(cid:13)j(cid:12)(cid:8)f (cid:12)= gkj ≡ Holds( f , t)(38)The equivalence of this effect axiom and state update axiom (33) follows immediately from Theorem 12. (cid:3)Example 5 (Continued). Recall state update axiom (34) for the Pay action. The corresponding effect axiom isPoss(Pay, s, t) ⊃(cid:2)(∃ y)(cid:2)HoldsHasPayment( y), s(cid:3)(cid:5)(cid:4)∧ (∀ f )Holds( f , s) ∧ f (cid:12)= HasPayment( y) ⊃ Holds( f , t)(cid:4)¬Holds( f , s) ∨ f = HasPayment( y) ⊃ ¬Holds( f , t)∧ (∀ f )(cid:5)(cid:3)132M. Thielscher / Artificial Intelligence 175 (2011) 120–141which can be equivalently written asPoss(Pay, s, t) ⊃(cid:2)(∃ y)(cid:2)HoldsHasPayment( y), s(cid:3)(cid:4)Holds( f , s) ∧ f (cid:12)= HasPayment( y) ≡ Holds( f , t)∧ (∀ f )(cid:5)(cid:3)(39)3.2.2.. . . to the Situation CalculusIn the following, we show how a domain axiomatization resulting from a Fluent Calculus domain can be mapped ontothe Situation Calculus using so-called successor state axioms [31] for each fluent F ((cid:3)u) as a solution to the Frame Problem.The general form of these axioms in the reified version (that is, where fluents are represented as terms) is(cid:4)(cid:2)Holds(cid:3)F ((cid:3)u), Do(a, s)(cid:2)[s] ∨ Holds+F(cid:3)(cid:5)[s]−F≡ Γ+F and Γ∧ ¬ΓPoss(a, s) ⊃(40)−F describe the conditions on a, s, (cid:3)u under which fluent F ((cid:3)u) is, respectively, a positive or a negative effect.Here, ΓReiter’s basic action theories do not, however, allow to axiomatize nondeterministic actions. In [20], it has been shownhow a generic predicate Case(k, a, s), where k : N, can be used in the sub-formulas Γto model nondeterministiceffects by distinguishing different “cases” of updates. For a correct mapping of effect axioms of the form (38), however, thisconcept needs to be generalized in view of actions which are characterized by an underspecified condition, like action Pay(cf. axiom (34)). To this end, we introduce, for every action A((cid:3)x) with effect axiom (36), the more general predicates+F and ΓF ((cid:3)u), s−FCase Ak ((cid:3)x, (cid:3)yk, s)for every k = 1, . . . , n. The behavior of these predicates is governed by the following axioms.5(cid:2)PossA((cid:3)x), s(cid:3)⊃(cid:18)(cid:2)(∃(cid:3)yk)Case A(cid:3)k ((cid:3)x, (cid:3)yk, s) ∧ Φk[s](cid:3)(cid:2)(cid:2)∀(cid:3)yk, (cid:3)y(cid:13)kkCase Ak ((cid:3)x, (cid:3)yk, s) ∧ Case Ak(cid:3)(cid:2)(cid:3)x, (cid:3)y(cid:13)k, s⊃ (cid:3)yk = (cid:3)y(cid:3)(cid:13)k(41)Put in words, for every situation s in which the action is possible, there exists a unique applicable “case” k with a uniqueinstance (cid:3)yk.We are now in a position to map an axiomatization characterizing a Fluent Calculus domain into the Situation Calculus,provided the original Fluent Calculus domain satisfies the consistency assumption (37). Domain constraints are taken asthey are while precondition axioms (35) are re-written to(cid:2)PossA((cid:3)x), s(cid:3)≡ π A[s](42)Given in their equivalent form (38), the effect axioms are all together mapped onto the following schema for the (possiblynondeterministic) successor state axioms.Poss(a, s) ⊃(cid:11)(cid:2)Holds(cid:3)f , Do(a, s)≡(cid:6)(cid:7)(∃(cid:3)x)a = A((cid:3)x) ∧(cid:6)(cid:7)(∃(cid:3)yk)Case AA(cid:7)k∨ (∃(cid:3)x)a = A((cid:3)x) ∧ Holds( f , s) ∧ ¬(cid:8)(cid:8)(cid:6)if = fkiCase Ak ((cid:3)x, (cid:3)yk, s) ∧k ((cid:3)x, (cid:3)yk, s) ∧(cid:7)(cid:11)(cid:6)(∃(cid:3)yk)k(cid:6)jf = gkj(cid:8)(cid:12)(cid:8)(cid:12)(43)The fluent variable f in this schema can then be instantiated by all fluents of the domain in order to obtain actual successorstate axioms.Example 5 (Continued). Recall general effect axiom (34) for the Pay action. Assuming this to be the only action in thedomain, we obtain the following successor state axiom schema.Poss(a, s) ⊃(cid:4)(cid:2)Holds(cid:3)f , Do(a, s)(cid:4)(∃ y)Case≡ a = Pay ∧ Holds( f , s) ∧ ¬Pay1( y, s) ∧ f = HasPayment( y)(cid:5)(cid:5)(44)along with the “case” axiom6(cid:2)Poss(Pay, s) ⊃ (∃! y)PayCase1Instantiating (44) for fluent { f (cid:10)→ HasPayment( y)}, we obtain(cid:3)( y, s) ∧ HasPayment( y, s)Poss(a, s) ⊃(cid:4)(cid:2)Holds(cid:3)HasPayment( y), Do(a, s)(cid:2)≡ a = Pay ∧ HoldsHasPayment( y), s(cid:3)Pay∧ ¬Case1(cid:5)( y, s)5 Below, the notation6 Below, the notation (∃! y)F means the existence of a unique instance y such that sub-formula F is true.k Fk means that exactly one of the sub-formulas Fk is true.(cid:19)M. Thielscher / Artificial Intelligence 175 (2011) 120–141133It is easy to prove that the mapping of the effect axioms into successor state axioms is correct.Proposition 14. Suppose Poss( A((cid:3)x), s) and Poss( A((cid:3)x), s, t) ≡ t = Do( A((cid:3)x), s), then (36) and (43), instantiated by {a (cid:10)→ A((cid:3)x)}, areequivalent under axioms (41).Proof. Instantiating (43) by {a (cid:10)→ A((cid:3)x)}, we obtain(cid:2)Holds(cid:2)f , DoA((cid:3)x), s(cid:6)(cid:3)(cid:3)≡k(cid:7)(∃(cid:3)yk)(cid:8)f = fki(cid:6)iCase Ak ((cid:3)x, (cid:3)yk, s) ∧(cid:11)(cid:6)∨ Holds( f , s) ∧ ¬(∃(cid:3)yk)Case Ak ((cid:3)x, (cid:3)yk, s) ∧k(cid:12)f = gkj(cid:6)jGiven (41), this can be re-written to(cid:6)(cid:7)(∃(cid:3)yk)(cid:11)Φk[s] ∧ (∀ f )(cid:2)Holds(cid:2)f , DoA((cid:3)x), s(cid:6)(cid:3)(cid:3)≡f = fki ∨ Holds( f , s) ∧ ¬(cid:11)(cid:6)(cid:12)(cid:12)(cid:8)f = gkjkijwhich, given Poss( A((cid:3)x), s, t) ≡ t = Do( A((cid:3)x), s), is equivalent to (38). (cid:3)We have thus obtained, with the help of the unifying calculus, an embedding of the full basic Fluent Calculus into theSituation Calculus using a variant of successor state axioms which is suitable for nondeterministic actions and somewhatmore general than [20]. The translation itself generalizes an earlier result that was restricted to deterministic actions [35].3.3. Translations into different time structuresThe two example translations presented above have in common that the target language uses the same time structure asthe input language. Since the unifying action calculus is not confined to a particular time structure, it can also serve as in-termediary language for translating approaches with different time structures into each other. Domain axiomatizations withbranching time, such as situations in the Situation- or the Fluent Calculus, can be mapped onto a linear time structure byintroducing a special fluent to denote the actual occurrence of an action, like Occurs, and adding this to the preconditionso that the possibility of an action can be identified with its actual occurrence. Conversely, domain axiomatizations withlinear time (with time points t) can be mapped onto a branching time structure (with time points s) by adding a specialfluent Time(s, t) to denote that t is the “actual” time of a branching time point s. Precondition and effect axioms in thetarget language then inherit the relation between the beginning and end of an action as specified in the domain axiomswith the linear time structure.4. Modularity of domain axiomatizationsIn this second part of the paper, we show how the unifying action calculus allows us to analyze and solve problemsof general interest across different formalisms. The motivation for using the unifying approach is that it enables proofsof results without being confined to a specific approach. Once established, instantiating such a result to a particular actioncalculus is likely to be much easier than solving the problem individually and from the scratch for each individual formalism.We exemplify this by providing a new, calculus-independent solution to a problem that arises across different approaches:the question whether a domain axiomatization is modular. This problem, which has recently gained interest [15], is ofparticular relevance for the practical use of domain axiomatizations in high-level action programming languages like GOLOG[32] or FLUX [42], and it is intimately related to McCarthy’s concept of elaboration tolerance [24].The problem of modularity arises from the fact that axiomatizations of action domains combine different categories offormulas which serve different purposes. Domain constraints describe static properties which hold in all states; preconditionaxioms define the conditions for actions to be applicable; and effect axioms define the consequences of actions. As a uniformlogical theory, however, a domain axiomatization may easily give rise to dependencies among the different kinds of axioms:effect formulas can entail implicit preconditions, domain constraints can entail implicit effects, etc. [13]. Implementationslike GOLOG or FLUX, on the other hand, rely on the assumption that dependencies like these do not exist. The reason isthat, for the sake of efficiency, the implementations use domain axiomatizations in a modular fashion: agents refer to thedomain constraints only when they initialize their world model, they check the applicability of an action merely against theprecondition axioms, and they update their world model entirely on the basis of the effect axioms. Agent programs wouldbe much less efficient if the entire domain theory had to be taken into account for each specific reasoning task. However,this modular use of a domain axiomatization is incorrect whenever there is a dependency between axioms of different kind.As a consequence, the modularity of a domain axiomatization must always be verified prior to using it as the knowledgebase for an agent. This is an excellent example of the value of McCarthy’s elaboration tolerance principle [24]: the more134M. Thielscher / Artificial Intelligence 175 (2011) 120–141dependencies there are between different types of axioms, the less elaboration tolerant is a formalism, because the additionof new information may disrupt an entire existing axiomatization if it is not modular [14].In the following, we use our unifying action calculus as the formal basis for a general, calculus-independent analysis ofthe problem of modularity of domain constraints, precondition axioms, and effect formulas in domain axiomatizations. Wepresent conditions for modularity against which a domain axiomatization can be checked. As the main result, we prove thatthe class of sequential and ramification-free domain axiomatizations, as defined at the end of Section 2, are guaranteed tobe free of dependencies if they satisfy these conditions. We then show how this result can be straightforwardly instantiatedto several concrete formalisms. In this way, our general conditions for independence can be easily checked, e.g., by applyingautomated theorem proving, for a given domain theory in a specific action calculus.4.1. Examples for implicit dependencyIn order to illustrate the universality of the problem of modularity, we first present three simple example axiomatizationsin three different calculi which entail implicit domain constraints, preconditions, and effects, respectively.4.1.1. Implicit domain constraintsThe first example, axiomatized in the Situation Calculus, shows how effect axioms—successor state axioms in this case—may entail additional, implicit domain constraints.Example 6. For a scheduling domain consider the fluents Job(m, j) and Free(m), respectively representing that machine mhas been allocated job j and that machine m is free. Two actions Schedule( j, m) and Unschedule( j) are for allocatingjob j to machine m and for deallocating job j.Consider the single domain constraint7(cid:2)⊃ ¬(∃ j) Holds(cid:2)HoldsJob(m, j), tFree(m), t(45)(cid:3)(cid:3)Let the action precondition axioms be(cid:2)(cid:2)PossPoss(cid:3)Schedule( j, m), s(cid:3)Unschedule( j), s(cid:2)≡ Holds≡ (∃m)Holds(cid:2)(cid:3)Free(m), sJob(m, j), s(cid:3)The successor state axioms for the two fluents are as follows.Poss(a, s) ⊃(cid:4)(cid:2)Holds(cid:3)Job(m, j), Do(a, s)≡ a = Schedule( j, m)(cid:3)(cid:2)∨ HoldsJob(m, j), s(cid:5)∧ a (cid:12)= Unschedule( j)Poss(a, s) ⊃(cid:4)(cid:2)Holds(cid:3)Free(m), Do(a, s)(cid:2)≡ (∃ j)(cid:2)Job(m, j), sHolds(cid:2)∨ HoldsFree(m), s(cid:3)∧ a = Unschedule( j)(cid:5)∧ ¬(∃ j)a = Schedule( j, m)(cid:3)(cid:3)(46)(47)Put in words, Job(m, j) holds in a successor situation if job j was just allocated to machine m, or if Job(m, j) was truebeforehand and j was not deallocated. Similarly, Free(m) holds in a successor situation if the job allocated to m just gotunscheduled, or if machine m was free beforehand and has not just got some job j.We claim that this axiomatization entails the following implicit domain constraint (which does not follow from (45)alone):(cid:2)HoldsJob(m, j), s(cid:3)(cid:2)⊃ ¬(∃i)(cid:2)HoldsJob(m, i), s(cid:3)(cid:3)∧ j (cid:12)= iTo see why, suppose Holds(Job(m, j), s), then (46) implies Poss(Unschedule( j), s). By (47),(cid:2)HoldsFree(m), Do(cid:2)Unschedule( j), s(cid:3)(cid:3)Hence, from (45) it follows that(cid:2)¬(∃i)HoldsJob(m, i), Do(cid:2)Unschedule( j), s(cid:3)(cid:3)Also, by (47) and uniqueness-of-names,(cid:2)HoldsJob(m, i), Do(cid:2)Unschedule( j), s(cid:3)(cid:3)(cid:2)≡ HoldsJob(m, i), s(cid:3)∧ j (cid:12)= iThis and (49) imply ¬(∃i)(Holds(Job(m, i), s) ∧ j (cid:12)= i).(48)(49)7 It should be stressed that the converse of the following implication is left out intentionally; that is to say, for many other reasons a machine may notbe available even if it has not been allocated a job.M. Thielscher / Artificial Intelligence 175 (2011) 120–1411354.1.2. Implicit preconditionsThe next example, which is axiomatized in the simple Event Calculus as introduced in Section 3.1.2, shows how effectaxioms can give rise to implicit preconditions of actions.Example 7. To model the movement of a robot, consider the fluent At(x) representing that the robot is at position x. Theaction Go(x, y) denotes the movement of the robot from x to y. Let the domain axiomatization consist of the single domainconstraint(cid:2)HoldsAt(l1), t(cid:3)(cid:2)∧ HoldsAt(l2), t(cid:3)⊃ l1 = l2(50)Put in words, the robot must be at a unique location at any time. Let the precondition of the only action be axiomatized as(cid:2)HappensGo(x, y), s(cid:3)(cid:2)⊃ HoldsAt(x), s(cid:3)The effects in this domain are determined by the following circumscribed definition of initiation and termination.(cid:2)(cid:3)Initiates(a, f , s) ≡ (∃x, y)f = At( y) ∧ a = Go(x, y)(cid:2)Terminates(a, f , s) ≡ (∃x, y)(cid:3)f = At(x) ∧ a = Go(x, y)(51)(52)We claim that, under the assumption that the Go action can be performed in isolation, this axiomatization entails thefollowing implicit precondition (which does not follow from (51) alone):(cid:2)HappensGo(x, y), s(cid:3)⊃ x (cid:12)= y(53)To see why, (52) implies both Initiates(Go(x, y), At( y), s) and Terminates(Go(x, y), At(x), s). Suppose Happens(a, s) ≡ a =Go(x, y), then foundational axioms (25) entail both Holds(At( y), t) as well as the negation ¬Holds(At(x), t) for t > s, whichin turn implies x (cid:12)= y.4.1.3. Implicit effectsThe last example, given in the basic Fluent Calculus, shows how domain constraints can give rise to additional, impliciteffects.Example 8. To model the operation of two elevators, consider the fluent AtFloor(e, n) with e ∈ {E1, E2} and n ∈{0, 1, . . . , 9}, representing the current floor of each elevator. The only action Call(n) means to activate the call buttonat floor n. Let the domain axiomatization consist of the two domain constraints,(cid:2)(∃!k)Holds(cid:2)¬HoldsAtFloor(e, k), t(cid:3)AtFloor(E1, 0), t(cid:3)(54)that is to say, both elevators are at a unique floor in every situation, and the first elevator does not serve the basement. Weassume that it is possible to activate the call button at any floor as long as there is no elevator at this floor, that is,(cid:2)Call(n), s(cid:3)Poss≡ 0 (cid:2) n (cid:2) 9 ∧ ¬(∃e)Holds(cid:2)AtFloor(e, n), s(cid:3)(cid:2)(cid:3)⊃Poss(cid:2)Call(n), sThe following state update axiom specifies a nondeterministic effect.(cid:2)(cid:2)(∃m)Holds(cid:2)(cid:2)∧ StateDo(cid:2)(cid:2)(∃m)∨(cid:2)∧ StateAtFloor(E1, m), s(cid:3)(cid:3)(cid:2)Holds(cid:2)DoAtFloor(E2, m), sCall(n), sCall(n), s(cid:3)(cid:3)(cid:3)(cid:3)= State(s) − AtFloor(E1, m) + AtFloor(E1, n)= State(s) − AtFloor(E2, m) + AtFloor(E2, n)(cid:3)(cid:3)(cid:3)(cid:3)(55)(56)Put in words, calling an elevator to a floor n has the indeterminate effect that either of the two elevators arrives.We claim that this domain axiomatization entails the following implicit effect (which does not follow from (56) alone):(cid:2)Call(0), s(cid:3)(cid:2)⊃ HoldsPossAtFloor(E2, 0), Do(cid:2)Call(0), s(cid:3)(cid:3)(57)To see why, note that State(Do(Call(0), s)) = State(s) − AtFloor(E1, m) + AtFloor(E1, 0) implies(cid:2)HoldsAtFloor(E1, 0), Do(cid:2)Call(0), s(cid:3)(cid:3)according to Theorem 12. By (54), therefore, the first disjunct in state update axiom (56) is false if substituted by {n (cid:10)→ 0}.This entails (57) according to (56) and Theorem 12.136M. Thielscher / Artificial Intelligence 175 (2011) 120–1414.2. A general method for verifying modularityThe examples in the previous section show that the problem of domain axiomatizations not being modular arises inmany different action formalisms. With the help of our unifying action calculus, we can give a general, formal definitionof what are implicit domain constraints, preconditions, and effects. To this end, we introduce the following notation for agiven action A((cid:3)x). In a domain axiomatization with precondition axioms Π , by Π A we denote the one which is for A((cid:3)x),with π A[s] being its right-hand side as usual. Likewise, if Υ are the effect axioms, then by Υ A we denote the one for actionA((cid:3)x). For notational convenience, we will refrain from stating the foundational axioms of a domain axiomatization. Theseare tacitly assumed to be satisfiable, and entailment (|(cid:14)) and consistency of sets of formulas is always meant to be modulothem.Definition 15. Consider a domain axiomatization Σ = Δ ∪ Π ∪ Υ consisting of domain constraints Δ, precondition axiomsΠ , and effect axioms Υ .1. The domain axiomatization is free of implicit domain constraints if for every state formula δ[t],Σ |(cid:14) δ[t]implies Δ |(cid:14) δ[t].2. The domain axiomatization is free of implicit preconditions if for every action A((cid:3)x) and state formula π [s],Σ |(cid:14) Poss(cid:2)A((cid:3)x), s, t(cid:3)⊃ π [s]implies Δ ∪ Π A |(cid:14) Poss( A((cid:3)x), s, t) ⊃ π [s].3. The domain axiomatization is free of implicit effects if for every action A((cid:3)x) and state formula ε[t],Σ |(cid:14) Poss(cid:2)A((cid:3)x), s, t(cid:3)⊃ ε[t]implies Δ[S] ∪ Π A[S] ∪ Υ A[S, T ] |(cid:14) Poss( A((cid:3)x), S, T ) ⊃ ε[T ], for any constants S, T of sort time.Put in words, an implicit domain constraint is a (universally quantified) state formula which is entailed by the entiredomain axiomatization but which cannot be derived from the given domain constraints Δ alone. An implicit preconditionis entailed by the entire domain axiomatization but does not follow from the precondition axioms alone in a state thatsatisfies the domain constraints. The rationale behind this definition is the following: given a state that satisfies the domainconstraints Δ, the precondition axiom for an action A alone should suffice to entail all executability conditions for thisaction. Finally, an implicit effect follows from the entire domain axiomatization but not from an effect axiom alone in astate that satisfies the preconditions of an action and the domain constraints. The rationale behind this definition is this:given a state that satisfies both the domain constraints Δ and the preconditions of an action A, the instantiated effectaxiom for this action alone should suffice to infer everything that can be concluded of the resulting state. The use of timeconstants in item 3 is motivated by the desire to verify modularity in a local fashion, that is, by instantiating the domainconstraints and precondition axioms by a single time point, and the effect axioms by this time point and its successor.We now use our unifying calculus to provide three conditions which will then be shown to guarantee that a domainaxiomatization is free of implicit dependencies. Informally speaking, the first condition below, (C1), essentially says that forevery state at some time S which is consistent with the domain constraints and in which an action A((cid:3)x) is applicable, thecondition Φi[S] for at least one case i in the effect axiom for A holds. Condition (C2) implies that none of the applicableeffect specifications is self-contradictory, and (C3) requires that any possible update leads to a state that satisfies the domainconstraints. Here and in the following, we consider only ramification-free domain axiomatizations according to Definition 6,so that the sub-formulas Γin effect axioms (cf. (2)) are state formulas solely in s.and Γ+i−iDefinition 16. Let S, T be constants of sort time. A domain axiomatization Δ ∪ Π ∪ Υ is called modular if the followingholds for every action A((cid:3)x) with effect axiom (1): there exist arbitrary time constants S, T such that|(cid:14) Δ[S] ∧ π A[S] ⊃k(cid:6)i=1(∃(cid:3)yi)Φi[S]and, for all i ∈ {1, . . . , k},|(cid:14) Δ[S] ∧ π A[S] ∧ Φi[S] ∧ Γ|(cid:14) Δ[S] ∧ π A[S] ∧ Υi[S, T ] ⊃ Δ[T ]+i[S] ⊃ ¬Γ−i[S](C1)(C2)(C3)M. Thielscher / Artificial Intelligence 175 (2011) 120–141137These conditions can in principle be checked for a given domain axiomatization by automated theorem proving.8 Whenso doing, an advantage is that these conditions can be verified separately for each action of a domain signature.We are now ready to prove our main result, which says that modular domain axiomatizations are free of implicit domainconstraints, preconditions, and effects. We begin by proving that if a state formula is consistent with the domain constraints,then it is also consistent with the entire domain axiomatization.Lemma 17. Consider a sequential and ramification-free domain axiomatization Δ ∪ Π ∪ Υ which satisfies conditions (C1)–(C3). LetS be an arbitrary constant of sort time and ψ(S) a state formula in S, thenΔ[S] ∪(cid:9)(cid:10)ψ[S]is consistentimplies that Δ ∪ Π ∪ Υ ∪ {ψ[S]} is consistent.(58)Proof. Let I(cid:13)the least element of <I. We then construct a model J as follows.be an arbitrary model for Δ[S] ∪ {ψ[S]}. From this we can straightforwardly obtain a model I in which SIis1. For every fluent ϕ,Holds(ϕ, S)Jiff Holds(ϕ, S)I(59)2. Given that the domain axiomatization is sequential, we can iteratively construct the following assignment for every σin the domain of I for sort time, starting with S(a) Let πα be the right-hand side of the precondition axiom for A, then, and for every action α = A((cid:3)x)IIand time point τ >I σ :Poss(α, σ , τ )Jiff J |(cid:14) πα{s (cid:10)→ σ , t (cid:10)→ τ }(60)(b) Let (1) be α’s effect axiom. If Poss(α, σ , τ )Jthen choose some i = 1, . . . , k and some (cid:3)yi such that Φi[σ ]J, and forevery fluent ϕ letHolds(ϕ, τ )J¬Holds(ϕ, τ )Jif J |(cid:14) Γ+iif J |(cid:14) Γ[σ ]{ f (cid:10)→ ϕ}−i[σ ]{ f (cid:10)→ ϕ}(61)The existence of some such i and (cid:3)yifollows from assumption (C2).is guaranteed by assumption (C1), and consistency of the assignment (61)Then J is a model for ψ[S] due to (59), for Π due to (60), for Υ due to (61), and for Δ due to (58) and (C3). (cid:3)Next, we show that a state formula ψ[T ] is consistent with the entire domain axiomatization if only it is consistentwith an instance of an update Υ A[S, T ] for a state at time S that satisfies the domain constraints and the preconditions ofaction A.Lemma 18. Consider a sequential and ramification-free domain axiomatization Σ = Δ ∪ Π ∪ Υ which satisfies conditions (C1)–(C3).Let A((cid:3)x) be an action, S, T be arbitrary constants of sort time, and ψ[T ] a state formula in T , then(cid:9)(cid:9)(cid:10)Δ[S] ∪π A[S]{t (cid:10)→ T }∪ Υ A[S, T ] ∪(cid:10)ψ[T ]is consistentimplies(cid:9)(cid:2)PossΣ ∪A((cid:3)x), S, T(cid:3)(cid:10)(cid:9)(cid:10)ψ[T ]∪is consistent.Proof. Let I be a model for Δ[S]∪{π A[S]{t (cid:10)→ T }}∪Υ A[S, T ]∪{ψ[T ]}. We construct a model J as in the proof of Lemma 17and with a specific assignment for the state at time T :Holds(ϕ, T )Jiff Holds(ϕ, T )I(62)for every ϕ in the domain of I for sort fluent. This is consistent with Υ because I is a model for Υ A[S, T ]. As above, Jis a model for Σ , a model for ψ[T ] due to (62), and for Poss( A((cid:3)x), S, T ) since I is a model for π A[S]{t (cid:10)→ T }. (cid:3)With the help of these two lemmas we can now prove our main result.8 It is worth noting that condition (C2) is trivially true for both successor state axioms in the Situation Calculus and (consistent) state update axioms inthe Fluent Calculus, because the corresponding formulas Γand Γin the general effect axioms are always negations of each other (cf. axiom (38)).+i−i138M. Thielscher / Artificial Intelligence 175 (2011) 120–141Theorem 19. Any sequential and ramification-free domain axiomatization which is modular is free of implicit domain constraints,preconditions, and effects.Proof. Let Σ be a modular domain axiomatization with domain constraints Δ, precondition axioms Π , and effect axioms Υ .Consider an arbitrary state formula δ[t]. If Σ |(cid:14) δ[t] then Σ ∪ {¬δ[t]} is inconsistent. By Lemma 17, Δ ∪ {¬δ[t]} isinconsistent, hence Δ |(cid:14) δ[t]. This shows that Σ is free of implicit domain constraints.Consider a state formula π [s]. If Σ |(cid:14) Poss( A((cid:3)x), s, t) ⊃ π [s] then Σ |(cid:14) π A[s] ⊃ π [s], where π A is the right-hand side ofthe precondition axiom for A((cid:3)x). Hence, Σ ∪ {π A[s] ∧ ¬π [s]} is inconsistent. By Lemma 17, Δ ∪ {π A[s] ∧ ¬π [s]} is inconsis-tent, hence Δ |(cid:14) π A[s] ⊃ π [s], hence Δ ∪ Π |(cid:14) Poss( A((cid:3)x), s, t) ⊃ π [s]. This shows that Σ is free of implicit preconditions.Finally, consider an action A((cid:3)x) along with a state formula ε[t]. If Σ |(cid:14) Poss( A((cid:3)x), s, t) ⊃ ε[t] then Σ ∪ {π A[S]{t (cid:10)→ T } ∧¬ε[T ]} is inconsistent for any S, T of sort time. By Lemma 18, Δ[S] ∪ {π A[S]{t (cid:10)→ T }} ∪ Υ A[S, T ] ∪ {¬ε[T ]} is inconsistent,hence Δ[S] ∪ Π A[S] ∪ Υ A[S, T ] |(cid:14) Poss( A((cid:3)x), S, T ) ⊃ ε[T ]. This shows that Σ is free of implicit effects. (cid:3)We conclude our analysis by illustrating how the general method can be easily instantiated and applied in order to verifyindependence in each of the specific approaches of the Situation-, Event-, and Fluent Calculus.4.2.1. Modularity in the situation calculusIn Section 3.2.2 we have seen how a specific class of domain axiomatizations in the unifying action calculus can bemapped onto successor state axioms. The converse translation of action theories in the Situation Calculus consisting ofdomain constraints, precondition axioms, and basic successor state axioms in the sense of [31] is straightforward: domainconstraints are taken as they are, precondition axioms of the form (42) are re-written into the form (35), and the successorstate axioms (40) for all fluents F together are mapped onto the effect axiom schemaPoss(a, s, t) ⊃ (∀ f )(cid:11)(cid:6)(cid:2)f = F ((cid:3)u) ∧(cid:2)Γ+F[s] ∨ Holds( f , s) ∧ ¬Γ(cid:3)[s](cid:3)⊃ Holds( f , t)−F(cid:12)F(cid:11)(cid:6)(cid:2)∧ (∀ f )f = F ((cid:3)u) ∧(cid:2)Γ−F[s] ∨ ¬Holds( f , s) ∧ ¬Γ(cid:12)(cid:3)⊃ ¬Holds( f , t)(cid:3)[s]+FFThe action variable a in this schema can then be instantiated by all actions of the domain in order to obtain actual effectaxioms in the unifying calculus. By definition, these axiomatizations are ramification-free, and the foundational axioms ofthe Situation Calculus, (30), imply sequentiality according to Definition 5. Based on this translation, the verification of themodularity conditions in Situation Calculus axiomatizations is straightforward.Example 6 (Continued). We have seen that the given axiomatization entails an implicit domain constraint. Indeed, in-dependence condition (C3) is not entailed. To see why, take arbitrary time constants S and T and consider the actionUnschedule( j). Successor state axioms (47) determine an update formula which is equivalent to(cid:2)≡ Holds(cid:3)Υ1[S, T ] :=∧ i (cid:12)= j(cid:3)Job(m, i), T(cid:3)(cid:5)(cid:3)(cid:3)(cid:5)(cid:4)Job(m, i), S(cid:2)≡ HoldsJob(m, j), S(cid:2)∨ HoldsFree(m), S(cid:2)Holds(cid:4)(cid:2)Holds∧Free(m), TAlong with(cid:2)Δ[S] := HoldsπUnschedule[S] := (∃m)HoldsFree(n), S(cid:3)(cid:2)⊃ ¬(∃k)Holds(cid:2)(cid:3)Job(n, k), S(cid:3)Job(m, j), Sthis does not entail(cid:2)Δ[T ] := HoldsFree(n), T(cid:3)⊃ ¬(∃k)Holds(cid:2)Job(n, k), T(cid:3)To see why, consider an interpretation that satisfies(cid:3)(cid:3)(cid:2)HoldsJob(M, J ), S(cid:2)¬HoldsJob(M, J ), T(cid:2), Holds(cid:3)Job(M, I), S(cid:2), HoldsJob(M, I), T(cid:2), ¬Holds(cid:3)Free(M), S(cid:2), HoldsFree(M), T(cid:3)(cid:3)It is easy to verify that this is a model for the conjunction Δ[S] ∧ πUnschedule[S] ∧ Υ1[S, T ]{i (cid:10)→ I, j (cid:10)→ J } but not for Δ[T ].99 The reader may verify that (C3) is entailed, however, once the implicit domain constraint (48) is added.M. Thielscher / Artificial Intelligence 175 (2011) 120–1411394.2.2. Modularity in the Event CalculusIn Section 3.1.2 we have seen how a specific class of domain axiomatizations in the unifying action calculus can bemapped onto the simple Event Calculus. This translation can be easily reversed. The only required generalization is toadditionally axiomatize the special action Inert as in Example 3 to capture arbitrary sequential narratives, based on anarbitrary linear time structure (like, e.g., the positive real numbers) and where actions may not immediately follow eachother. With regard to verifying modularity, it is easy to see that the axioms for Inert (cf. (12) and (13)) satisfy theconditions (C1)–(C3).Example 7 (Continued). We have seen that the given axiomatization entails an implicit precondition. Indeed, independencecondition (C2) is not entailed. To see why, take an arbitrary time constant S and consider the action Go(x, y). Initiation andtermination axioms (52) determine effect formulas in the unifying action calculus where[S] := f = At( y) ∨ Holds( f , S) ∧ f (cid:12)= At(x)[S] := f = At(x) ∨ ¬Holds( f , S) ∧ f (cid:12)= At( y)+Γ1−Γ1+1Then Γ(cid:2)∧ HoldsAt(l2), S(cid:3)⊃ l1 = l2[S] in conjunction with(cid:3)(cid:2)Δ[S] := HoldsΦ1[S] := (cid:20)(cid:2)πGo[S] := HoldsAt(l1), SAt(x), S(cid:3)does not entail ¬Γ−1[S]. This can be easily seen by an interpretation that satisfies x = y.104.2.3. Modularity in the Fluent CalculusIn Section 3.2.1 we have shown how basic Fluent Calculus theories can be mapped onto domain axiomatizations in theunifying calculus. This mapping can be directly applied to verify modularity of these theories with the help of our generalmethod.Example 8 (Continued). We have seen that the given axiomatization entails an implicit effect. Indeed, independence condi-tion (C3) is not entailed. To see why, take arbitrary time constants S and T and consider the action Call(n). State updateaxiom (56) determines an effect formula in the unifying action calculus where(cid:2)Υ1[S, T ] := (∃m)(cid:2)(cid:2)HoldsAtFloor(E1, m), S(cid:3)(cid:2)∧∧(cid:3)f = AtFloor(E1, n) ∨ Holds( f , S) ∧ f (cid:12)= At(E1, m) ⊃ Holds( f , T )f = At(E1, m) ∨ ¬Holds( f , S) ∧ f (cid:12)= AtFloor(E1, n) ⊃ ¬Holds( f , T )(cid:2)Υ2[S, T ] := (∃m)(cid:2)AtFloor(E2, m), S(cid:3)f = AtFloor(E2, n) ∨ Holds( f , S) ∧ f (cid:12)= At(E2, m) ⊃ Holds( f , T )f = At(E2, m) ∨ ¬Holds( f , S) ∧ f (cid:12)= AtFloor(E2, m) ⊃ ¬Holds( f , T )(cid:2)Holds∧∧(cid:3)(cid:2)(cid:3)(cid:3)(cid:3)(cid:3)For the instance {n (cid:10)→ 0}, Υ1[S, T ] along with(cid:3)(cid:2)Δ[S] := (∃!k)HoldsAtFloor(e, k), S(cid:2)πCall[S] := 0 (cid:2) n (cid:2) 9 ∧ ¬(∃e)Holds(cid:2)∧ ¬HoldsAtFloor(E1, 0), S(cid:3)(cid:3)AtFloor(e, n), simplies Holds(At(E1, 0), T ). This, however, contradicts Δ[T ].115. DiscussionWe have proposed a unifying action calculus which abstracts from a concrete time structure and a specific solution tothe Frame Problem and thus encompasses a variety of existing, specific languages for axiomatizing action domains. Thisunifying approach can be used as an intermediary language to facilitate translations of specific calculi into each other. Wehave exemplified this by obtaining two new results: a characterization of ADL planning problems in the Event Calculus andan embedding of the full basic Fluent Calculus into a variant of the Situation Calculus with nondeterministic successor stateaxioms. Generally speaking, the use of an intermediary axiomatization has two major advantages. First, it makes explicit10 The reader may verify that (C2) is entailed, however, once the implicit precondition (53) is added.11 The reader may verify that (C3) is entailed, however, once the implicit effect (57) is incorporated into the state update axiom.140M. Thielscher / Artificial Intelligence 175 (2011) 120–141how the specific solution to the Frame Problem in the input language determines the effects and non-effects of an action.This often makes it easier to find an appropriate translation into a different solution to the Frame Problem. As an example,the domain axiomatization we have obtained in Section 3.2.1 from a basic Fluent Calculus theory not only gives a clearindication of how the effect axioms can be translated into successor state axioms, it also illustrates very explicitly whatextension of Reiter’s basic action theories is needed in order to capture the various ways in which nondeterministic actionscan be axiomatized by state update axioms in the Fluent Calculus. Second, the prior translation of an input language into anintermediary language should allow for a generic and uniform way of embedding the input formalism into different targetlanguages. The domain axiomatization we have obtained in Section 3.1.1 as a characterization for ADL planning problems,for example, can be readily used to define mappings into approaches other than the Event Calculus.Among the variety of potential applications of inter-calculi translations, we consider the following ones most important.1. Translations can be used to prove that (a well-defined class of) a specific calculus can be formally embedded in anothercalculus.2. The use of an implementation of a calculus to solve problems given in a different input language requires a priortranslation; examples are the problem specification languages used for the Planning Competitions [6] or the GeneralGame Description Language used for the General Game Playing Contest [8].3. In order to use a different platform to run knowledge-based agent programs written in languages like GOLOG or FLUX,the background knowledge of the agent needs to be transformed into an appropriate encoding.In comparison to related work, much like the systematic assessment methods of [33] or the Action Description LanguageA [7] and extensions thereof, our unifying calculus can be used to analyze the relative expressiveness of different axiom-atization techniques in comparison. The main difference is that the former define a specific semantics for action domainsrather than providing a purely logical axiomatization. This implies that the assessments are always restricted to problemclasses that can be defined within the special semantics. For example, Action Description Language A has been translatedinto both successor state axioms [16] and state update axioms [39]. These results can be combined into a translation fromthe Fluent Calculus into the Situation Calculus and vice versa, but this translation is confined to domains that can be ex-pressed in A and therefore does not allow for a full embedding of basic Fluent Calculus theories into the Situation Calculus.In the second part of the paper, we have used the unifying calculus to develop a general method for verifying inde-pendence of domain constraints, preconditions, and effects in axiomatizations of action domains. We have shown how thisgeneral method can be easily instantiated for various specific calculi. Existing results on the problem of implicit dependen-cies are restricted to specific calculi and less general classes of domains. In [30], it has been shown that precondition axiomsand deterministic successor state axioms in the Situation Calculus are always independent, provided that there are no do-main constraints at all. In [15], algorithms have been presented for inferring implicit domain constraints and preconditionsfrom domain axiomatizations given in propositional modal logic. A conceptually different approach has been pursued in[27], where it has been shown how a particular class of domain constraints can be compiled into successor state axioms(deterministic only). Incidentally, condition (C3) in our Definition 16 is already known in this context as a way to ensurethat, if satisfied by a given initial situation, the result of such a compilation allows to ignore the domain constraints. In ourcontext, however, this condition serves a different purpose: instead of showing that, for specific initial situations, the givendomain constraints are redundant, it shows that no further domain constraints are entailed (independent of the initial situ-ation). With regard to the Event Calculus, it should be stressed that our result is restricted to sequential domains. However,our unifying calculus can be readily used to express concurrent actions, simply by taking as the elements of the sort actioncollections of (simultaneous or overlapping) actions. It remains an issue for future work to define a concrete sound andcomplete mapping of domains with concurrent actions given, say, in the Event Calculus, into our unifying calculus in whichsingle actions may represent collections of actual actions, which would then allow to apply our modularity conditions asthey are.For future work along a different line, our unifying action calculus can be readily used for comparing and assessingaction formalisms other than those considered in this paper, and to generalize the specific translations we have developedto more general classes of domain axiomatizations. Most notably, our approach to abstract from concrete solutions to theFrame Problem should facilitate formal comparisons of the many different existing solutions to the Ramification Problem,thus going beyond comparisons based on specific example scenarios only.With regard to the result in the second part of the paper, it would be worthwhile for the future to develop a general sys-tem for the automatic verification of modularity. By extracting implicit domain constraints, preconditions, and effects fromfailed attempts to prove the independence conditions, such a system could assist knowledge engineers with the design of“good” axiomatizations. A different line of future work could be the use of the unifying calculus as a method of abstractionfor analyzing other problems of general interest across specific calculi.AcknowledgementsThis paper would have no ground to stand on if it were not for John McCarthy’s seminal and ever inspiring work onartificial intelligence, knowledge representation, and commonsense reasoning. I am also deeply grateful for John’s continuinginterest in my work over the years.M. Thielscher / Artificial Intelligence 175 (2011) 120–141141I want to thank the anonymous referees for helpful comments and suggestions on an earlier version of the paper.References[1] A.B. Baker, A simple solution to the Yale Shooting problem, in: R. Brachman, H. Levesque, R. Reiter (Eds.), Proceedings of the International Conferenceon Principles of Knowledge Representation and Reasoning (KR), Morgan Kaufmann, Toronto, Canada, 1989, pp. 11–20.[2] A.B. Baker, Nonmonotonic reasoning in the framework of situation calculus, Artificial Intelligence 49 (1991) 5–23.[3] J. Claßen, P. Eyerich, G. Lakemeyer, B. Nebel, Towards an integration of golog and planning, in: Proceedings of the International Joint Conference onArtificial Intelligence (IJCAI), AAAI Press, Hyderabad, India, 2007.[4] P. Doherty, J. Gustafsson, L. Karlsson, J. Kvarnström, Temporal action logics (TAL): Language specification and tutorial, Electronic Transactions on Artifi-cial Intelligence 2 (3–4) (1998) 273–306.[5] R.E. Fikes, N.J. Nilsson, STRIPS: A new approach to the application of theorem proving to problem solving, Artificial Intelligence 2 (1971) 189–208.[6] M. Fox, D. Long, PDDL2.1: An extension to PDDL for expressing temporal planning domains, Journal of Artificial Intelligence Research 20 (2003) 61–124.[7] M. Gelfond, V. Lifschitz, Representing action and change by logic programs, Journal of Logic Programming 17 (1993) 301–321.[8] M. Genesereth, N. Love, B. Pell, General game playing, AI Magazine 26 (2) (2006) 73–84.[9] M.L. Ginsberg, D.E. Smith, Reasoning about action I: A possible worlds approach, Artificial Intelligence 35 (1988) 165–195.[10] E. Giunchiglia, J. Lee, V. Lifschitz, N. McCain, H. Turner, Nonmonotonic causal theories, Artificial Intelligence 153 (1–2) (2004) 49–104.[11] J. Gustafsson, P. Doherty, Embracing occlusion in specifying the indirect effects of actions, in: L.C. Aiello, J. Doyle, S. Shapiro (Eds.), Proceedings of theInternational Conference on Principles of Knowledge Representation and Reasoning (KR), Morgan Kaufmann, Cambridge, MA, 1996, pp. 87–98.[12] S. Hanks, D. McDermott, Nonmonotonic logic and temporal projection, Artificial Intelligence 33 (3) (1987) 379–412.[13] A. Herzig, I. Varzinczak, Domain descriptions should be modular, in: R.L. de Mántras, L. Saitta (Eds.), Proceedings of the European Conference onArtificial Intelligence (ECAI), IOS Press, 2004, pp. 348–352.[14] A. Herzig, I. Varzinczak, Cohesion, coupling and the meta-theory of actions, in: L. Kaelbling, A. Saffiotti (Eds.), Proceedings of the International JointConference on Artificial Intelligence (IJCAI), Edinburgh, UK, 2005, pp. 442–447.[15] A. Herzig, I. Varzinczak, Metatheory of actions: Beyond consistency, Artificial Intelligence 171 (16–17) (2007) 951–984.[16] G.N. Kartha, Soundness and completeness theorems for three formalizations of actions, in: R. Bajcsy (Ed.), Proceedings of the International JointConference on Artificial Intelligence (IJCAI), Morgan Kaufmann, Chambéry, France, 1993, pp. 724–729.[17] R. Kowalski, F. Sadri, The situation calculus and event calculus compared, in: M. Bruynooghe (Ed.), Proceedings of the International Logic ProgrammingSymposium (ILPS), MIT Press, Ithaca, NY, 1994, pp. 539–553.[18] R. Kowalski, M. Sergot, A logic based calculus of events, New Generation Computing 4 (1986) 67–95.[19] F. Lin, Embracing causality in specifying the indirect effects of actions, in: C.S. Mellish (Ed.), Proceedings of the International Joint Conference onArtificial Intelligence (IJCAI), Morgan Kaufmann, Montreal, Canada, 1995, pp. 1985–1991.[20] F. Lin, Embracing causality in specifying the indeterminate effects of actions, in: B. Clancey, D. Weld (Eds.), Proceedings of the AAAI National Conferenceon Artificial Intelligence, MIT Press, Portland, OR, 1996, pp. 670–676.[21] N. McCain, H. Turner, A causal theory of ramifications and qualifications, in: C.S. Mellish (Ed.), Proceedings of the International Joint Conference onArtificial Intelligence (IJCAI), Morgan Kaufmann, Montreal, Canada, 1995, pp. 1978–1984.[22] J. McCarthy, Situations and Actions and Causal Laws, Stanford Artificial Intelligence Project, Memo 2, Stanford University, CA, 1963.[23] J. McCarthy, Circumscription—a form of non-monotonic reasoning, Artificial Intelligence 13 (1980) 27–39.[24] J. McCarthy, Mathematical logic in artificial intelligence, Daedalus 117 (1) (1988) 297–311.[25] J. McCarthy, P.J. Hayes, Some philosophical problems from the standpoint of artificial intelligence, Machine Intelligence 4 (1969) 463–502.[26] D. McDermott, The 1998 AI planning systems competition, AI Magazine 21 (2) (2000) 35–55.[27] S. McIlraith, An axiomatic solution to the ramification problem (sometimes), Artificial Intelligence 116 (1–2) (2000) 87–121.[28] E. Mueller, Event calculus and temporal action logics compared, Artificial Intelligence 170 (11) (2006) 1017–1029.[29] E. Pednault, ADL: Exploring the middle ground between STRIPS and the situation calculus, in: R. Brachman, H. Levesque, R. Reiter (Eds.), Proceedingsof the International Conference on Principles of Knowledge Representation and Reasoning (KR), Morgan Kaufmann, Toronto, 1989, pp. 324–332.[30] F. Pirri, R. Reiter, Some contributions to the metatheory of the situation calculus, Journal of the ACM 46 (3) (1999) 261–325.[31] R. Reiter, The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression, in: V. Lifschitz(Ed.), Artificial Intelligence and Mathematical Theory of Computation, Academic Press, 1991, pp. 359–380.[32] R. Reiter, On knowledge-based programming with sensing in the situation calculus, ACM Transactions on Computational Logic 2 (4) (2001) 433–457.[33] E. Sandewall, Features and Fluents. The Representation of Knowledge about Dynamical Systems, Oxford University Press, 1994.[34] E. Sandewall, The range of applicability of some non-monotonic logics for strict inertia, Journal of Logic and Computation 4 (5) (1994) 581–615.[35] S. Schiffel, M. Thielscher, Reconciling situation calculus and fluent calculus, in: Proceedings of the AAAI National Conference on Artificial Intelligence,AAAI Press, Boston, MA, 2006, pp. 287–292.[36] M. Shanahan, A circumscriptive calculus of events, Artificial Intelligence 77 (1995) 249–284.[37] M. Shanahan, Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia, MIT Press, 1997.[38] M. Shanahan, The ramification problem in the event calculus, in: T. Dean (Ed.), Proceedings of the International Joint Conference on Artificial Intelli-gence (IJCAI), Morgan Kaufmann, Stockholm, Sweden, 1999, pp. 140–146.[39] M. Thielscher, Representing actions in equational logic programming, in: P.V. Hentenryck (Ed.), Proceedings of the International Conference on LogicProgramming (ICLP), MIT Press, Santa Margherita Ligure, Italy, 1994, pp. 207–224.[40] M. Thielscher, Ramification and causality, Artificial Intelligence 89 (1–2) (1997) 317–364.[41] M. Thielscher, From situation calculus to fluent calculus: State update axioms as a solution to the inferential frame problem, Artificial Intelli-gence 111 (1–2) (1999) 277–299.[42] M. Thielscher, FLUX: A logic programming method for reasoning agents, Theory and Practice of Logic Programming 5 (4–5) (2005) 533–565.