Artificial Intelligence 175 (2011) 1390–1409Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintOn the modelling and optimization of preferences in constraint-basedtemporal reasoning ✩Michael D. Moffitt11400 Burnet Rd., Austin, TX, United Statesa r t i c l ei n f oa b s t r a c tArticle history:Received 28 February 2009Received in revised form 12 August 2010Accepted 15 September 2010Available online 8 December 2010Keywords:PreferencesOverconstrained problemsConstraint satisfactionOptimizationBranch and boundTemporal reasoningIn this paper, we consider both the modelling and optimization of preferences inproblems of constraint-based temporal reasoning. The Disjunctive Temporal Problemswith Preferences (DTPP) – a formulation that combines the rich expressive power ofthe Disjunctive Temporal Problem with the introduction of metric preference functions –is studied, and transformed into a corresponding constraint system that we name theValued DTP (VDTP). We show that for a broad family of optimization criteria, the VDTPcan express the same solution space as the DTPP, under the assumption of arbitrarypiecewise-constant preference functions. We then generalize the powerful search strategiesfrom decision-based DTP literature to accomplish the efficient optimization of temporalpreferences.In contrast to the previous state-of-the-art system (which addresses theoptimization of temporal preferences using a SAT formulation), we instead employ a meta-CSP search space that has traditionally been used to solve DTPs without preferences.Our approach supports a variety of objective functions (such as utilitarian optimalityor maximin optimality) and can accommodate any compliant valuation structure. Wealso demonstrate that key pruning techniques commonly used for temporal satisfiability(particularly, the removal of subsumed variables and semantic branching) are naturallysuited to prevent the exploration of redundant search nodes during optimization that mayotherwise be encountered when resolving a typical VDTP derived from a DTPP. Finally, wepresent empirical results showing that an implementation of our approach consistentlyoutperforms prior algorithms by orders of magnitude.© 2010 Elsevier B.V. All rights reserved.1. IntroductionThe need to accommodate preferences has increasingly become an important problem in many fields related to artificialintelligence. While the topic spans several subjects – including decision theory, planning and scheduling, and machinelearning – the area of constraint satisfaction [9,29] affords many of the greatest opportunities for both the representation andreasoning of preferences [6,28]. The application of preferences to constraint-based systems presents at least three principalchallenges. The first of these challenges is determining a means to achieve preference elicitation, either through explicitmechanisms or by indirect inference through a series of observations and interactions with a user [34,35]. Secondly, onemust address the adequate modelling of local preference values and their global aggregation; the burden of translating theknown preference values of the real world to a specific standalone representation is seldom straightforward, and, in somecases, impossible. The third challenge deals with the necessary adaptation of classical search strategies to transform thegoal of satisfaction into one of optimization, requiring the generalization of highly specialized techniques to navigate a richer✩This paper includes and extends preliminary work from Moffitt and Pollack (2005, 2006) [18,19].E-mail address: mdmoffitt@us.ibm.com.0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.11.016M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091391search space [16]. Whether optimization can be done practically depends largely on the choice of model and the choice ofsearch strategy, resulting in a well-known tradeoff between expressive power and efficient reasoning.To be sure, existing literature on classical finite-domain CSPs is rich with techniques for encoding and resolving prefer-ence criteria. Among the various formalisms proposed, two popular representations are dominant: The Valued CSP [30] andthe Semiring CSP [7]. In the Valued CSP, constraints are annotated with scalar valuations that reflect the cost of their viola-tion. In the Semiring CSP, the various relational tuples that may satisfy a constraint are themselves labeled with preferences.Aside from the unique ability of the semiring to encode a partial ordering over the solution space, the two representationsare comparable, and can be readily converted to one another [8]. Both approaches unify the expressive power of the classicalCSP and the efficient algorithms for their satisfaction under the larger scope of preference optimization.Closely related to the finite-domain CSP, the temporal CSP is a common representation for many planning and schedul-ing problems in which the relationships between events (in time) are expressed by constraining their pairwise difference.Preferences have been proposed in this framework as well, with the most common variant augmenting traditional temporalconstraints [10] with local preference functions that express how well a particular assignment satisfies the correspondingconstraint [13]. These functions might convey that a certain activity should be as long as possible, or that it is desirablefor a pair of activities to be scheduled very close to one another. While the literature-to-date has introduced representa-tions with generously expressive preference functions, they have often been applied to relatively inexpressive underlyingconstraint systems, limiting the reasoning of complex preferences to only a relatively small class of problems [14,15,20,24].As preference-based temporal models continue to become more and more commonplace in industrial constraint engines[5,4,25], modern optimization tools must be able to respond to a wider range of problem instances.The Disjunctive Temporal Problems with Preferences (DTPPs) [23], a powerful representation that subsumes many com-mon temporal formalisms, attempts to provide the best of both worlds: a rich model for complex disjunctive constraints(to handle, for instance, non-overlap conditions that commonly arise in planning and scheduling) in addition to a rich lan-guage for expressing preference profiles over their domains. Early work in this problem space focused on maximizing theminimum of such preference values, while later developments have begun to address the more challenging problem ofutilitarian optimization [26], where the sum of the individual preference values is maximized. In either case, the problemof optimization is divided from the core satisfiability engine (i.e., of the wealth of techniques used to find feasible solu-tions, relatively few are extended toward finding good solutions). This division is due, in part, to a fundamental dichotomybetween the preference model and the search space of temporal problems: preference values are attributed to grounded dif-ferences between temporal events, whereas the meta-CSP algorithms for temporal reasoning refrain from instantiating theseobject-level variables. Recent work has shown that SAT formulations can demonstrate orders of magnitude of improvementas compared to these techniques [31], suggesting that advances in SAT technology may be the key to rapid search. Hence,prior art has yet to reveal a unified approach for both the expressive modelling and efficient optimization of preferenceswithin a classic CSP framework.In this work, we consider an alternative to the DTPP – the Valued DTP (or VDTP). We show that for a broad familyof optimization criteria, the VDTP can express the same solution space as the DTPP, under the assumption of arbitrarypiecewise-constant preference functions. We furthermore argue that the valued constraint representation eliminates thedichotomy between the object-level preference model and the meta-CSP solution space, and thus offers unique advan-tages when used to guide the search strategies employed in temporal constraint satisfaction algorithms. We then generalizedecision-based DTP literature to accomplish the efficient optimization of temporal preferences. Our approach supports avariety of objective functions (such as utilitarian optimality or maximin optimality) and can accommodate any compliantvaluation structure. We also demonstrate that key pruning techniques commonly used for temporal satisfiability (partic-ularly, the removal of subsumed variables and semantic branching) are naturally suited to prevent the exploration ofredundant search nodes during optimization that may otherwise be encountered when resolving a typical VDTP derivedfrom a DTPP. Finally, we present empirical results showing that an implementation of our approach consistently outper-forms prior algorithms by orders of magnitude, including the SAT-based approach.The remainder of the paper is organized as follows. Section 2 covers background material related to classical CSPs andtheir corresponding preference models. Sections 3 and 4 cover constraint-based temporal reasoning and extensions to tem-poral preferences, respectively. In Sections 5 and 6, we present the Valued DTP, and establish its relationship with the DTPwith Preferences. In Section 7, we demonstrate how to adopt the preference model of the VDTP to construct a meta-CSPsearch framework for optimization. In Section 8, we provide an empirical evaluation of approaches. Finally, we conclude inSection 9 with a summary of our approach along with future works.2. Preference optimization in finite-domain constraint networksWe begin by briefly reviewing the formulation of classical CSPs, followed by a description of two preference models thathave been used to augment the original framework.2.1. Finite-domain constraint networksA Constraint Satisfaction Problem (or constraint network) [9] is defined by a triple (cid:2) X, D, C(cid:3), where X = {x1, . . . , xn} is aset of variables, D = {D1, . . . , Dn} contains a domain D i = {v 1, . . . , vk} for each variable that lists the possible values it1392M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409may take, and C = {C1, . . . , Ct} is a set of constraints, where each constraint Ci is a relation R i defined over a subset ofvariables S i ⊆ X . A solution to a constraint network is an assignment ¯a = (a1, . . . , an) such that each ai ∈ D i , and for eachconstraint Ci , the projected assignment ¯a[S i] ∈ R i .A solution to a CSP is typically found by way of a recursive, depth-first, backtracking search, in which values are chosenfor variables one at a time until an inconsistency is detected (i.e., if there are no legal values remaining in the domainof some variable). If a search node cannot be expanded, backtracking occurs and a different value for the most recentlyinstantiated variable is chosen. The search process continues in this way until a solution has been found or the spaceof assignments has been exhausted. This computationally expensive procedure is improved with the use of heuristics andinference. A heuristic uses information about the current state in search to determine an effective variable and value ordering.In contrast, inference attempts to rule out possible values for the uninstantiated variables, given only those decisions thathave been made in search thus far.2.2. Semiring CSPsA constraint satisfaction problem can be associated with a semiring structure that specifies preference values for eachtuple of values of the variables’ domains. Depending on the choice of aggregation operation, different global objectivefunctions may be constructed based on the local semiring values.A semiring is a tuple ( A, +, ×, 0, 1) such that:• A is a set and 0, 1 ∈ A;• +, the additive operation, is a closed (i.e., a, b ∈ A implies that a +b ∈ A), commutative (i.e., a +b = b +a) and associative(i.e., a + (b + c) = (a + b) + c) operation such that a + 0 = 0 = 0 + a (i.e., 0 is its unit element);• ×, the multiplicative operation, is a closed and associative operation such that 1 is its unit element and a × 0 = 0 = 0 ×a(i.e., 0 is its absorbing element);• × distributes over + (i.e., a × (b + c) = (a × b) + (a × c)).One of the principal advantages of using a semiring to model preferences in a constraint system is that a large familyof optimization criteria can be expressed as instantiations of the same broad problem definition. For instance, a classicalCSP (i.e., one where the only notion of preference is the distinction between feasible and infeasible) is an SCSP with thec-semiring SCSP = (cid:2){0, 1}, ∨, ∧, 0, 1(cid:3). Weighted constraint satisfaction (where the sum of preferences values is maximized) isexpressed with the semiring SWCSP = (cid:2)(cid:8)−, max, +, −∞, 0(cid:3).2.3. Valued CSPsA valuation structure is a tuple (cid:2)E, (cid:2), (cid:10)(cid:3) such that:• E is a set (whose elements are called of valuations) and is totally ordered by (cid:10), with a maximum element (cid:11) and aminimum element ⊥;• (cid:2) is a commutative, associative closed binary operation on E that satisfies:– Identity: ∀a ∈ E, a (cid:2) ⊥ = a;– Monotonicity: ∀a, b, c ∈ E, (a (cid:3) b) ⇒ ((a (cid:2) c) (cid:3) (b (cid:2) c));– Absorbing element: ∀a ∈ E, (a (cid:2) (cid:11)) = (cid:11).A Valued CSP is defined by a classical CSP (cid:2)V , D, C(cid:3), a valuation structure S = (E, (cid:2), (cid:10)), and an application ϕ from Cto E, where ϕ(c) maps any constraint of a classical CSP to a valuation denoting the impact of its violation.The valuation of an assignment A of the variables W ⊂ V is defined by:(cid:2)V P ( A) = (cid:2)c∈C,V c⊂W ,violates( A,c)(cid:3)ϕ(c)The VCSP effectively establishes a total ordering over the set of complete assignments, giving highest preference toassignments that achieve the minimum valuation.2.4. ComparisonThe SCSP and the VCSP cast the modelling of preferences in fairly different lights. In one aspect, there is a distinctionbetween whether preference values are attributed to the tuples of a constraint, or instead to the constraint themselves.Beyond that, the two formulations also employ different mathematical mechanisms to achieve the aggregation of localpreferences. It has been shown that under the assumption of a total order, the two formulations admit an equivalentsolution space [8], allowing one to freely pass between the two without loss of expressive power. However, the methodsused to achieve pruning, inference, and bounding are dependent on the representation.M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–140913933. Temporal Constraint Satisfaction ProblemsIn contrast to classical CSPs (whose variables span a finite number of unordered values), temporal CSPs define variableswhose domains span the set of reals (or integers), representing time. Hence, they model flavors of scheduling problems inwhich the relationships between events (in time) are expressed by constraining their pairwise difference.3.1. Simple Temporal ProblemsThe Simple Temporal Problem (STP) is the most restricted form of quantitative TCSP. It is defined by a pair (cid:2) X, C(cid:3), whereX is a set of time points having continuous domains, and C is a set of constraints of the form:ai j (cid:4) X j − Xi (cid:4) bi jThis dual-bounded inequality can be converted into a single-bounded form simply by constructing a pair of linear inequali-ties for each constraint. An STP has an equivalent graph-based network, where each node in the graph G corresponds to atime point in the STP, and each directed edge between nodes i and j corresponds to a linear inequality.3.2. Binary TCSPsThe Binary Temporal Constraint Satisfaction Problem (Binary TCSP) [10] admits a greater expressive power than the STP.It is defined by a pair (cid:2) X, C(cid:3), where X is a set of time points having continuous domains, and C is a set of disjunctiveconstraints of the form:ai j1 (cid:4) X j − Xi (cid:4) bi j1 ∨ · · · ∨ ai jn (cid:4) X j − Xi (cid:4) bi jnAs with the STP, this dual-bounded representation can be converted into a single-bounded representation, although the sizeof the encoding grows exponentially with the number of disjuncts in each constraint.A solution to a Binary TCSP may be viewed in one of two ways. The first is as an assignment of a numeric value toeach of the time points in X that satisfies all the constraints in C . Another type of solution – called a meta-CSP solution –considers the creation of a meta-variable Ci for every constraint Ci , as described formally in the following section.3.3. Disjunctive Temporal ProblemsA Disjunctive Temporal Problem (DTP) [32] is a constraint satisfaction problem defined by a pair (cid:2) X, C(cid:3), where each el-ement Xi ∈ X designates a time point, and each element Ci ∈ C is a constraint of the form: ci1 ∨ ci2 ∨ · · · ∨ cini where inturn, each ci j is of the form: ai j (cid:4) xi j − yi j (cid:4) bi j with xi j, yi j ∈ X and ai j, bi j ∈ (cid:8) (we will refer to the interval [ai j, bi j] asthe feasible region for ci j ). DTPs are thus a generalization of Simple Temporal Problems (STPs), in which each constraint islimited to a single disjunct, and Binary Temporal Constraint Satisfaction Problems (Binary TCSPs), where the same pair oftime points must participate in every disjunct belonging to a single constraint.To illustrate the Disjunctive Temporal Problem, consider the following scenario. Meetings A and B are both to last40 minutes, and cannot overlap. Furthermore, meeting A must begin between 11:00 and 11:30, and meeting B must finishbetween 11:30 and 12:00. This problem can be cast as a DTP with constraints shown in Fig. 1(a). The time points [ A S , A E ]represent the start and end of meeting A, and likewise, the time points [B S , B E ] represent the start and end of meetingB. A temporal reference point T R represents an arbitrary fixed time (such as midnight), and is used to express constraintswith respect to wall clock time.As with the Binary TCSP, there are generally two ways of defining a solution to a DTP. The first of these is as an object-level assignment of a numeric value to each of the time points in X , such that all the constraints in C are satisfied. A secondtype of solution is a meta-CSP assignment. Here, instead of directly considering assignments to the time points in X , a meta-}, representing thevariable Ci is created for each constraint in the DTP. The domain D(Ci) is simply the set {ci1, ci2, . . . , cinivarious disjuncts one can choose to satisfy that disjunctive constraint. A complete assignment in the meta-CSP thus involvesa selection of a single disjunct for each constraint, commonly referred to as a component STP. One meta-CSP solution maycorrespond to many feasible object-level solutions, and vice versa.Within this meta-CSP formulation, the constraints are implicitly defined by the underlying semantics of the disjuncts:the values (disjuncts) assigned to each meta-variable must be mutually consistent. The consistency of a set S of suchinequalities can be determined by first constructing its distance graph, a graph that includes a node for each time point andan arc with weight b from y to x whenever x − y (cid:4) b is in S. Then S is consistent if and only if its distance graph containsno negative cycles, which can be determined in polynomial time by computing its all-pairs shortest path (APSP) matrix andchecking the entries along the main diagonal [10].In the meeting example, the assignment:(C1, C2, C3, C4, C5) ← (c11, c21, c31, c41, c51)is the only consistent meta-CSP solution. One cannot choose c32 as the value for C3 (requiring meeting A to precedemeeting B) since this would force meeting B to finish late even if meeting A begins as early as possible.1394M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409Fig. 1. (a) The constraints in the meeting example. (b)–(e) Preference functions over disjuncts c(cid:17)11, c(cid:17)21, c(cid:17)31, and c(cid:17)32.4. Temporal preferences: formalisms and algorithmsThe earliest adaptation of preferences in temporal reasoning problems [13] constructed a formalism known as the SimpleTemporal Problem with Preferences. While this structure overcame the inability of the Simple Temporal Problem to encodeoptimization variants, it remained fundamentally limited in the same way that the STP could not encompass the broadrange of problems allowed by the DTP.In this section, we focus specifically on preferences in the case of disjunctive constraints. It will be shown in futuresections that the ability to reason about disjunctions can be useful even when all constraints are simple in nature.4.1. Disjunctive Temporal Problems with PreferencesA DTP can be extended to a DTP with Preferences (DTPP) [23] by augmenting each disjunct ci j: ai j (cid:4) xi j − yi j (cid:4) bi j with apreference function (cid:2) f i j : t ∈ [ai j, bi j] → {0, (cid:8)+}(cid:3), mapping every feasible temporal difference to a preference value expressingits relative utility [13].1 Given a solution S to the DTPP D, the preference value of a disjunctive constraint Ci in C is definedto be the maximum value achieved by any of its disjuncts:valD (S, Ci) = maxci j∈D(Ci)(cid:4)(cid:5)S(xi j) − S( yi j)f i jExample. Consider a variation on the earlier meeting example, in which the duration of meeting A is no longer fixed,and can instead have length between 20 and 60 minutes, with values closer to 40 being more preferable. A preference(cid:17)function reflecting this over the new variables AS is shown in Fig. 1(b). Fig. 1(c) expresses that meeting B can lastbetween 30 and 60 minutes, with durations closer to either of these extremes being preferred over values in between. Also,imagine that the content of meeting A covers much of the material that meeting B builds upon, and so it is highly desiredthat meeting A precede meeting B. Figs. 1(d) and 1(e) reflect this strong preference, along with a weaker preference that5 minutes be allocated between meetings for a short break.2(cid:17)E and A1 Variations on this model – such as replacing feasibility intervals with universally defined preference functions – have been suggested [17] and can beextended to subsequent formulations without issue.2 For the sake of simplicity, we leave C4 and C5 as hard constraints with preference functions that map to the constant 2 within their feasible regions.M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091395With the addition of preferences, we are no longer concerned with simply finding a feasible solution; we also want asolution of high quality. This requires us to specify a scheme for aggregating preference values across constraints. One ofthe earliest objectives to be considered is maximin or Weakest Link Optimality (WLO) [13], in which the global value of anassignment S is equal to the minimal preference value satisfied by the assignment:valD (S) = minivalD (S, Ci)WLO compares solutions myopically using only the “weakest link” in each solution; no credit is given for satisfying otherconstraints at very high levels. Despite this drawback, WLO can be appropriate in some situations [14].An alternative optimality criterion is the useful utilitarian objective, where the global value of a solution S is equal tothe sum of the preference values of the all constraints [20]:(cid:6)valD (S) =valD (S, Ci)iUtilitarianism corresponds to optimality with the weighted semiring, and is considerably more sensitive than WLO to thelevels at which individual constraints are satisfied.Example. The solution S : ( Atemporal constraint. For the case of utilitarian optimality, it results in a global preference value of 7:(cid:17)E ) ← (690, 730, 650, 690) is feasible, as it falls within the feasible region of each(cid:17)S , A(cid:17)E , B(cid:17)S , Bf 1(S) + f 2(S) + · · · + f 5(S) = 2 + 1 + 0 + 2 + 2 = 7where f i corresponds to the highest preference value achieved within constraint Ci for a solution S. In contrast, WLOoptimality would give S the score of 0, as this is the lowest level at which any constraint is satisfied. We can obtain a better(cid:17)E ) ← (660, 685, 690, 720), which gives us a utilitarian preference value of 12solution Sand a WLO score of 1:(cid:5)(cid:5)with the assignment ( A(cid:17)S , A(cid:17)E , B(cid:17)S , B(cid:5)(cid:4)(cid:4)(cid:4)(cid:17)(cid:17)f 1S+ f 2(cid:17)S+ · · · + f 5(cid:17)S= 1 + 2 + 5 + 2 + 2 = 12By inspection, we observe that this is a utilitarian optimal solution, meaning that there exists no other object-level assign-ment that can achieve a higher objective value.Other forms of preference value aggregation (corresponding to different instantiations of the c-semiring) are possible,though have yet to be considered explicitly in the literature on disjunctive temporal reasoning.4.2. Solving DTPPs4.2.1. Weakest link optimalityWhen introduced, the DTPP was accompanied with an algorithm to compute WLO-optimal solutions with an approachnot entirely dissimilar to a traditional DTP search. It began by treating the DTPP as if all preference values were fixed (orprojected) at their the lowest levels of 0. Using the meta-CSP approach common to many DTP solvers, it would search thisspace looking for a satisfying solution. Upon the discovery of a consistent solution (which, by construction, would have aWLO score of 0), all constraints in the DTP would be tightened to match the next highest preference level of the DTPP(perhaps level 1). Search would then resume, with each subsequent solution triggering another tightening of the DTP’sconstraints. This process continues until the highest level has been reached, or search has been exhausted.The overall approach is described as “low-cost”, for the reason that the space explored was guaranteed to be no largerthan that of | A| copies of the largest projected DTP, where A is the set of all preference levels.4.2.2. Utilitarian optimalitySince the development of the WLO algorithm, two approaches have been proposed for performing utilitarian optimizationof a DTPP. Both can handle problems containing complex preference functions, requiring only that they be piecewise-constant in shape.3The first is based on a SAT reformulation of a DTPP [31]. It involves the creation of a Mixed Logical Linear Programming(MLLP) problem composed of two types of constraints: logical constraints over Boolean variables, and Unit-Two-Variable-Per-Inequality (UTVPI) integer constraints of the form ax − by (cid:4) d, where a, b ∈ {−1, 0, 1}. The disjuncts in the DTPP areconverted to a set of UTVPI constraints, a Boolean indicator variable is created for each constraint, and a SAT problem isconstructed in which these indicator variables are used to represent the logical structure of the DTPP. The reformulatedproblem is then solved by a Satisfiability Modulo Theories (SMT) system named ARIO, composed of a tightly integratedUTVPI engine and SAT solver. Since this approach can handle only the decision variant of the DTPP, optimization is achieved3 DTPPs containing other preference function shapes can be approximated by piecewise-constant functions via discretization.1396M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409by repeatedly calling the combined constraint engine on a sequence of satisfaction problems with increasingly higher ob-jectives until no feasible solution can be found. Efficient SAT-solving techniques [21] make the approach taken by ARIOparticularly attractive.The second approach, named GAPD (Greedy Anytime Partition algorithm for DTPPs) was designed exclusively for the purposeof solving DTPPs [26]. It is based largely on the GAPS algorithm [24] for computing utilitarian optimal solutions to STPPs.It begins by first searching for a consistent component STP S to the DTP D induced by fixing all constraints in the DTPPat their bottommost preference level of 0. It then either uses the GAPS algorithm to find an optimal solution to the STPPto the DTP D, and repeats. In this way, the disjunctive search forSfeasible solutions is decoupled from the process of optimization. Although both GAPS and GAPD have been shown to beseveral orders of magnitude slower than ARIO for finding optimal solutions, these algorithms have been shown to exhibitdesirable anytime properties.corresponding to S, or computes another solution S(cid:17)(cid:17)(cid:17)5. Valued disjunctive temporal problemsThe DTP with Preferences has typically been regarded as a type of semiring formulation [7], in which preference valuesare attributed to the (infinitely many) legal object-level tuples that comprise a constraint. While expressive, this modelof preferences makes the task of optimization somewhat nebulous. Recall that search strategies for disjunctive temporalreasoning operate on the meta-CSP rather than invoking object-level assignments directly; therefore, the set of object-level solutions to a single meta-CSP solution may vary wildly in quality, and no one preference value can be determinedfor a component STPP. In response, we introduce a variation of the DTP where the disjunctive constraints themselves areassociated with costs, making our representation comparable to early versions of the Valued CSP formalism for finite-domainconstraints [30].Definition. A Valued Disjunctive Temporal Problem (or VDTP) is a tuple (cid:2) X, C, S, ϕ(cid:3), where X and C are as in a DTP, S is avaluation structure (E, (cid:2), (cid:10)), and ϕ is a mapping from C to E.For instance, consider the weighted case of the VDTP, where E = (cid:8)+ ∪ {∞} and (cid:2) = + (i.e., arithmetic sum), using theusual ordering <. In other words, each constraint Ci is associated with a positive numeric weight ϕ(Ci), and the objectiveis to find an assignment S that imposes the minimal cost, where the cost is defined to be the weighted sum of violatedconstraints in the VDTP D:cost D (S) =(cid:6)(cid:7)ϕ(Ci)(cid:8)(cid:9)(cid:8) violates(S, Ci)iAs an example, we present the following (very small) instance of our weighted VDTP:C1: {c11: 1 (cid:4) x − y (cid:4) 2}C2: {c21: 3 (cid:4) x − y (cid:4) 4} ∨ {c22: 5 (cid:4) x − z (cid:4) 6}C3: {c31: 1 (cid:4) y − z (cid:4) 2}C4: {c41: 0 (cid:4) x − z (cid:4) 7}ϕ(C1) = 1ϕ(C2) = 2ϕ(C3) = 4ϕ(C4) = ∞Clearly there is no assignment that will satisfy all the constraints of this problem, since c21 conflicts with c11, and c22conflicts with the constraint induced by the composition of c11 and c31. In addition, C4 is a hard constraint having infiniteweight, and therefore must be satisfied in any solution.Once again, we can consider object-level and meta-level solutions to our VDTP. For instance, the object-level assignment(x, y, z) ← (6, 3, 1) violates only constraint C1. This has a cost of 1, and since we know that no solution exists with acost of 0, it is an optimal solution. Importantly, when we move to the meta-CSP, a solution is no longer necessarily a totalassignment; instead a (meta-)variable may be left unassigned, signifying that none of the disjuncts associated with it shouldbe enforced.6. The relationship between DTPPs and VDTPsThe previous example illustrates an important distinction between DTPPs and VDTPs. While constraints in both for-malisms serve to bound the pairwise temporal difference between events, the preferences apply to orthogonal elementsof the encoding. In the DTPP, a preference value is ascribed to a specific value of an object-level assignment; hence, anassignment to the meta-CSP (i.e., the selection of one disjunct per constraint) is alone insufficient to determine the valueof any object-level solution. In contrast, each VDTP constraint has a single valuation that expresses the cost of its violation(with infinite valuation reflecting a truly hard constraint). Thus, a consistent partial assignment to the meta-CSP (in whichsome meta-level variables are uninstantiated) has known cost.(cid:17)Despite the difference in preference model, we can show that when assuming a total ordering over solutions, any DTPPiff it is a solution to D, andhas an equivalent VDTP D in the following sense: (i) an assignment S is a solution to D(S1 (cid:10)D(cid:17) S2), iff S1 is also at least as preferred as S2 in D (S1 (cid:10)D S2). InD(ii) solution S1 is at least as preferred as S2 in D(cid:17)(cid:17)M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091397fact, we show that in addition, given any VDTP D, there is an equivalent DTPP D, and hence the VDTP and DTPP formalismsshare the same expressive power. This relationship requires only that the preference functions be piecewise-constant, i.e., thateach function f (x) may be expressed as(cid:17)n(cid:6)i=0αiχi(x)where χi(x) returns 1 if x lies within the range of interval i, and 0 otherwise. The piecewise-constant assumption is madein virtually all prior work on DTPPs.6.1. Converting a VDTP into a DTPPWe begin by showing how to convert a VDTP into an equivalent DTPP. Let D be a VDTP with constraints {C1, . . . , Cn}where Ci = ci1 ∨· · · ∨ cini and ci j = ai j (cid:4) xi j − yi j (cid:4) bi j and valuation structure S = (cid:2)E, (cid:2), (cid:10)(cid:3) with ϕ(Ci) being the valuation of(cid:17)(cid:17)Ci . Create the derived DTPP Di from each constraint Ci(cid:17)= −∞ (cid:4) xi j − yi j (cid:4) ∞ with preference function (cid:2) f i j : t ∈ [ai j, bi j] → ⊥, t /∈ [ai j, bi j] →∨ · · · ∨ cin D, where Ciϕ(Ci)(cid:3).with c-semiring (cid:2)E, +, (cid:2), (cid:11), ⊥(cid:3) by constructing a derived constraint Cand c= c(cid:17)ini(cid:17)i1(cid:17)i jIn what follows, we distinguish the constraint component (i.e., the disjunctive constraints themselves) from the valuationsor the preference functions. It will also be useful to refer to the valuation of a VDTP solution S, which is the aggregation ofvaluations of constraints violated by S:(cid:2)(cid:3)ϕ(Ci)V (S) = (cid:2)Ci ∈C,violates(S,Ci)We now show that every VDTP has an equivalent DTPP.Lemma 6.1. An assignment S is a solution to D if and only if it is a solution to D(cid:17).Let S : X → (cid:8) be an object-level assignment. First, assume S is a solution to the VDTP D. Then, for any arbitrary hardconstraint Ci in D, S satisfies Ci . Since the constraint component of each hard-derived constraint Cis identical tothat of the hard constraint in D from which it was derived, S satisfies all hard-derived constraints in D; it also satisfiesall soft-derived constraints, since each of those contain only disjuncts with infinite feasible regions, and are thus satisfied. Since it satisfies allby any assignment. So S is a solution to Dhard-derived constraints C, it must satisfy every hard constraint in D, because again, the corresponding constraintshave identical constraint components. Since S need not satisfy the soft constraints in D, it is thus also a solution to D.. Similarly, assume that S is a solution to the DTPP D(cid:17)i in D(cid:17)(cid:17)i in D(cid:17)(cid:17)(cid:17)(cid:17)Lemma 6.2. If S1 and S2 are solutions to D (and D(cid:17)), then S1 (cid:10)D S2 iff S1 (cid:10)D(cid:17) S2.As per [8], a total ordering over solutions is preserved when moving from the valuation structure to the c-semiring.Theorem 6.1. VDTP D and its derived DTPP D(cid:17)are equivalent (following directly from Lemmas 6.1 and 6.2).6.2. Converting a DTPP into a VDTPThe conversion of a DTPP to a VDTP is slightly more complicated, and relies on the notion of preference projections [24].An STPP preference projection “slices” an STPP constraint into a set of intervals that produce a preference value greater thanor equal to some specified level l. A DTPP preference projection generalizes this notion to all intervals (disjuncts) in a DTPPconstraint.Definition (STPP preference projection). Given an STPP constraint Ci j = (cid:2)ai j (cid:4) xi j − yi j (cid:4) bi j, f i j(cid:3), the preference projectionis Pi j[l] = {c1, c2, . . . , cn}, where ck = (cid:2)ak (cid:4) xi j − yi j (cid:4) bk(cid:3), bk < ak+1 for 1 (cid:4) k < n and[ak, bk] =at level l for Ci j{t| f i j(t) (cid:5) l}.(cid:10)nk=1Definition (DTPP preference projection). Given a DTPP constraint Ci = ci1 ∨ ci2 ∨ · · · ∨ cin, the preference projection at level lfor Ci is Pi[l] =Pi j[l].(cid:10)nj=1In converting a DTPP into an equivalent VDTP, the basic idea will be to create multiple VDTP constraints for each indi-vidual DTPP constraint: one for each distinct preference level. Valuations will be assigned in such a way that satisfying allprojected constraints through level k will result in an aggregate value of k. The procedure is as follows:(cid:17)Let Dbe a DTPP with constraints {C(cid:17)1, . . . , C(cid:17)n}. Then create the derived VDTP D as follows. For each constraint C(cid:17)i in D(cid:17):• Create a hard constraint C(cid:2)i,0(cid:3) in D, where C(cid:2)i,0(cid:3) =• Find the smallest l(cid:17) > l such that Pi[l(cid:17)] (cid:20)= Pi[l].(cid:11)Pi[0] and ϕ(Ci,0) = ⊥. Set l to zero.1398M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409Disjunctive constraintsC1,0:C1,1:C1,2:C2,0:C2,1:C2,2:C3,0:C3,1:C3,4:C3,5:C4,0:C4,2:C5,0:C5,2:20 (cid:2) A E − A S (cid:2) 6025 (cid:2) A E − A S (cid:2) 5530 (cid:2) A E − A S (cid:2) 5030 (cid:2) B E − B S (cid:2) 6030 (cid:2) B E − B S (cid:2) 40 ∨50 (cid:2) B E − B S (cid:2) 6030 (cid:2) B E − B S (cid:2) 35 ∨55 (cid:2) B E − B S (cid:2) 600 (cid:2) A S − B E ∨ 0 (cid:2) B S − A E5 (cid:2) A S − B E ∨ 0 (cid:2) B S − A E0 (cid:2) B S − A E5 (cid:2) B S − A E660 (cid:2) A S − T R (cid:2) 690660 (cid:2) A S − T R (cid:2) 690690 (cid:2) B E − T R (cid:2) 720690 (cid:2) B E − T R (cid:2) 720Valuations(weighted case)ϕ(C1,0) = ∞ϕ(C1,1) = 1ϕ(C1,2) = 1ϕ(C2,0) = ∞ϕ(C2,1) = 1Valuations(maximin case)ϕ(C1,0) = 0ϕ(C1,1) = 1ϕ(C1,2) = 2ϕ(C2,0) = 0ϕ(C2,1) = 1ϕ(C2,2) = 1ϕ(C2,2) = 2ϕ(C3,0) = ∞ϕ(C3,1) = 1ϕ(C3,4) = 3ϕ(C3,5) = 1ϕ(C4,0) = ∞ϕ(C4,2) = 2ϕ(C5,0) = ∞ϕ(C5,2) = 2ϕ(C3,0) = 0ϕ(C3,1) = 1ϕ(C3,4) = 4ϕ(C3,5) = 5ϕ(C4,0) = 0ϕ(C4,2) = 2ϕ(C5,0) = 0ϕ(C5,2) = 2Fig. 2. The weighted VDTP and maximin VDTP corresponding to the meeting example with preferences.• Create a soft constraint C(cid:2)i,l(cid:17)(cid:3) in D, where C(cid:2)i,l(cid:17)(cid:3) =(cid:17)] = (cid:21).• Iterate until an lis reached such that Pi[l(cid:17)(cid:11)Pi[l(cid:17)] such that ϕ(Ci,l(cid:17) ) (cid:2) ϕ(Ci,l) = l(cid:17). Set l to l(cid:17).Just as in the conversion of an SCSP to a VCSP [8], the number of constraints typically increases when passing from aDTPP to a VDTP.Example. As illustration of this procedure, Fig. 2 shows the VDTP corresponding to our DTPP example in Fig. 1. Many of theweighted valuations (shown in the second-to-last column) have unit cost; this is because our preference functions typicallychange by increments of 1 unit (one exception to this is C3,4, which has a valuation of 3; this is due to the strong preferencethat meeting A precede meeting B). Also, due to the non-convexity of f 2, the preference projections of the simple temporalconstraint C2 have been projected into a pair of disjunctive constraints C2,1 and C2,2. One can verify that the optimal solu-tion ( A S , A E , B S , B E ) ← (660, 685, 690, 720) identified earlier satisfies all constraints except C1,2, and thus has a cost of 1.Lemma 6.3. An assignment S is a solution to D(cid:17)if and only if it is a solution to D.(cid:17)Suppose S is a solution to D. By definition, it must necessarily satisfy every C(cid:17). As in Lemma 6.1, we note thati in D(cid:17)every hard constraint C(cid:2)i,0(cid:3) in D has a constraint component identical to that of the Ci from which it was derived; thus,these must be satisfied as well, as must D as a whole (since the soft constraints may be violated by any solution). Nowassume that S is a solution to D. It then necessarily satisfies every hard constraint C(cid:2)i,0(cid:3) (and observe that these are the(cid:17)since the constraint components are again identical. Hence,only hard constraints). It must then also satisfy every CS is a solution to D(cid:17)i in D.(cid:17)(cid:17)Lemma 6.4. If S1 and S2 are solutions to D(cid:17)(and D), then S1 (cid:10)D S2 iff S1 (cid:10)D(cid:17) S2.Again, a total ordering over solutions is preserved when moving from the c-semiring to the valuation structure, as shownin [8].Theorem 6.2. DTPP D(cid:17)and its derived VDTP D are equivalent (following directly from Lemmas 6.3 and 6.4).Theorem 6.3. For the assumption of a total order, DTPPs and VDTPs are equivalent in expressive power.This follows directly from Theorems 6.1 and 6.2.For a DTPP with |C| constraints and | A| distinct preference levels (where A is the set of all such levels), the number ofconstraints in the corresponding VDTP is bounded from above by |C| × | A|. Of course, due to the meta-CSP encoding, theseadditional constraints in fact become meta-level variables, and thus contribute to additional branches in the correspondingsearch tree.The VDTP easily captures the representation of various optimality criteria that arise from different instantiations of thevaluation structure. For instance, in the final column of Fig. 2, we provide a different set of valuations – here, each constraintis assigned its original preference level, as opposed to the difference in between it and the next lowest level. If aggregatedwith the min operator, this alternate VDTP corresponds to the case of Weakest Link Optimality.Observe that in this construction, several (valued) disjunctive constraints may be generated from a single non-disjunctiveSTPP constraint in the event that its preference function is not semi-convex. A similar (though not equivalent) observationis made by Peintner [26]. Any non-semi-convex STPP constraint can be converted into a DTPP constraint whose disjunctsexclusively contain semi-convex preference functions. The difference in VDTP conversion is the extent to which such dis-junctions must be generated. In particular, disjunctive splits need only occur above the level at which non-convexity begins;M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091399Fig. 3. (a) The semi-convex DTPP conversion suggested by Peintner [26]. (b) The semi-convex VDTP conversion.Solve-VDTP( A, U , cost, upperbound)If (cost > upperbound) returnIf (U = (cid:21))best-solution-so-far ← Aupperbound ← costreturn(cid:17) ← U − {Ci}EndIfCi ← select-variable(U ), UFor each disjunct ci j of D(Ci)(cid:17) ← A ∪ {Ci ← ci j}A))If (consistent( A(cid:17)Solve-VDTP( AEndIf(cid:17)(cid:17), U, cost, upperbound)EndFor(cid:17) ← A ∪ {Ci ← (cid:5)}A(cid:17), USolve-VDTP( A(cid:17), cost (cid:3) ϕ(Ci), upperbound)Fig. 4. Solving a VDTP by searching the space of partial component STPs.any preference projections below this point are maintained as contiguous simple constraints. The distinction is illustrated inFig. 3. This formulation offers the advantage that the algorithm may freely commit to lower preference levels while deferringthe decision of whether to commit to a higher region (and, if so, which of the regions resulting from the disjunction).7. Solving valued DTPsWe have just shown that any DTPP with piecewise-constant preference functions can be translated into an equivalentVDTP, in which individual constraints are tagged with valuations. To allow the possibility that any one of these constraintsmay be violated, a partial assignment in the meta-CSP space must be extended to include an empty value (which we de-note ‘(cid:5)’) in the domain of each meta-variable. The (cid:5)-relaxation, originally proposed to enable nonweighted partial constraintsatisfaction [18,19], is required to support the explicit violation of constraints at the meta-level space. A solution that vio-lates a constraint Ci with an assignment of (cid:5) will incur cost ϕ(Ci).4The augmented partial assignment for the alternative VDTP representation gives rise to a means to search through thespace of partial component STPs.7.1. Searching the space of partial component STPsPseudocode for the solving the VDTP is given in Fig. 4. The input variable A is the current set of assignments to meta-variables, and is initially (cid:21); variable U is the set of unassigned meta-variables (initially the entire set C ); cost is theaggregate of the valuations of violated constraints (initially zero); and upperbound is the stored cost of the best solutionfound so far. Note that unlike ARIO, we require no MLLP module or SAT-solving component, and unlike GAPD our memoryrequirements are polynomial in the size of the problem.4 The (cid:5)-relaxation bears a strong resemblance to the clause selectors used in Max-SAT, as both serve to disable constraints. However, the (cid:5) relationcorresponds to a variable in the original search space of the decision problem (i.e., the meta-CSP), whereas the clause selector directly corresponds to aconstraint in the original search space.1400M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409This algorithm resembles the meta-CSP backtracking search commonly used for solving traditional DTPs with two notabledifferences. First, backtracking occurs only when the combined valuation of the violated constraints (cost) equals or exceedsthat of the current best solution (upperbound); in a standard DTP solver, backtracking would occur whenever cost becamenonzero (i.e., when any constraint had been violated). Second, in addition to the values in the original domains of themeta-variables, there is the possibility of the empty assignment ‘(cid:5)’ that serves to explicitly violate a constraint, increasingthe branching factor by exactly one. This latter modification, in combination with the meta-CSP search space employed intemporal reasoning, sets the algorithm apart from previous applications of preference optimization to classical CSPs.The basic framework of Fig. 4 may be invoked in one of two ways to achieve optimization:• branch-and-bound (B&B): By initially setting upperbound to ∞, a single call to Solve-VDTP will cause solutions ofprogressively higher quality to be found and stored. The costs of solutions found early in search are used to set boundson the allowed number of violations in the tree.• iterative weakening (I.W.): An initial setting of upperbound to 0 will cause Solve-VDTP to conservatively search forsolutions with no violations. In the event of failure, a second call to Solve-VDTP will search more broadly for solutionswith a single violation. The process continues by executing a sequence of independent searches until a solution withthe specified cost is found.In cases where relatively few violations are required, the approach taken by iterative weakening tends to explore smalltrees with comparatively limited depth.7.2. Advantages of the meta-CSPThe meta-CSP reformulation of DTPP optimization offers several key advantages as opposed to the approaches takenby GAPD and ARIO. First and foremost, it embeds classical cost-based pruning (i.e., elimination of search nodes based onthe lower-bound of partial solution value) into all nodes of search; in contrast, the decision-based ARIO solver is forcedto explore a sequence of increasingly harder satisfaction problems, many of which are similar to one another and requireredundant search. Second, by encoding the relaxation (or violation) of a constraint as an additional empty disjunct, itallows the direct incorporation of powerful techniques previously developed in decision-based DTP literature [32,1,22,33].Previous CSP-based algorithms applied these only to the small portion of the search space corresponding to the DTPP’slowest preference level, a possible explanation of their poor performance compared to the SAT-based solver. Finally, itgeneralizes to any VDTP with a compliant valuation structure (i.e., having totally ordered valuations and a commutative,associative closed binary operator), extending to the popular criteria of utilitarian and maximin optimality.7.3. Prevention of superfluous searchThe algorithm described in the previous section has one apparent deficiency: no attempt has been made to ensure thatmeta-assignments made to constraints projected from a single preference function do not draw from different areas of thepreference profile. This nuance is a direct consequence of the meta-CSP, and can potentially lead to superfluous or redundantpartial assignments. As an example, consider a single disjunctive DTPP constraint projected at several levels:C1: {c(cid:2)1,1(cid:3): a1,1 (cid:4) x1 − y1 (cid:4) b1,1} ∨ {c(cid:2)2,1(cid:3): a2,1 (cid:4) x2 − y2 (cid:4) b2,1}, ϕ(C1) = k1C2: {c(cid:2)1,2(cid:3): a1,2 (cid:4) x1 − y1 (cid:4) b1,2} ∨ {c(cid:2)2,2(cid:3): a2,2 (cid:4) x2 − y2 (cid:4) b2,2}, ϕ(C2) = k2C3: {c(cid:2)1,3(cid:3): a1,3 (cid:4) x1 − y1 (cid:4) b1,3} ∨ {c(cid:2)2,3(cid:3): a2,3 (cid:4) x2 − y2 (cid:4) b2,3}, ϕ(C3) = k3· · ·C L: {c(cid:2)1,L(cid:3): a1,L (cid:4) x1 − y1 (cid:4) b1,L} ∨ {c(cid:2)2,L(cid:3): a2,L (cid:4) x2 − y2 (cid:4) b2,L}, ϕ(C L) = kLWe make no assumptions about the specific temporal intervals on these constraints, nor the specific values of the val-uations, with the exception that for all i, j, ai, j (cid:5) ai, j+1 and bi, j (cid:4) bi, j+1 (in other words, preference profiles must tightenmonotonically at higher levels). Naturally, we would expect that a solution will satisfy either the difference x1 − y1 or thedifference x2 − y2 up to a particular (not necessarily the highest) preference level. Following this logic, there should beno more than 2 × L possible ways in which to satisfy this set of constraints. The following two assignments reflect thisexpectation:(C1, C2, C3, . . . , C L−1, C L) ← (c(cid:2)1,1(cid:3), c(cid:2)1,2(cid:3), c(cid:2)1,3(cid:3), . . . , c(cid:2)1,L−1(cid:3), (cid:5))(C1, C2, C3, . . . , C L−1, C L) ← (c(cid:2)2,1(cid:3), c(cid:2)2,2(cid:3), c(cid:2)2,3(cid:3), . . . , (cid:5), (cid:5))However, note that in the process of creating these valued constraints, no direct links have been established to tietogether disjuncts in the VDTP that were obtained from the same ancestral disjunct in the DTPP. For instance, any of thefollowing assignments are legitimate meta-CSP solutions:(C1, C2, C3, . . . , C L−1, C L) ← (c(cid:2)1,1(cid:3), (cid:5), c(cid:2)2,3(cid:3), . . . , c(cid:2)1,L−1(cid:3), (cid:5))(C1, C2, C3, . . . , C L−1, C L) ← (c(cid:2)2,1(cid:3), c(cid:2)1,2(cid:3), (cid:5), . . . , c(cid:2)2,L−1(cid:3), (cid:5))M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091401These assignments are peculiar in two aspects: first, disjuncts are drawn from portions of both preference profiles, asopposed to only one. Second, we observe that some (cid:5)-relaxations occur at preference levels below those of constraints thatare legitimately instantiated (i.e., a more difficult constraint is satisfied while a strictly less restrictive constraint is violated).Thus, if one were to explore all possible combinations, a grand total of 3L assignments would be enumerated. In the generalcase of a DTPP constraint with m disjuncts, a worst case scenario would explore (m + 1)L partial assignments instead of thenecessary m ∗ L. The search space is further exacerbated by the combinatorial explosion of satisfying all constraints in theoriginal problem, making this subtle peculiarity a serious practical concern for achieving optimization. We refer to any suchsuperfluous assignment encountered during search as a degenerate solution.Definition (degenerate solution). Given a meta-CSP solution S = {C(cid:2)i,L(cid:3) → D(C(cid:2)i,L(cid:3))} to a VDTP D constructed from a DTPP(cid:17)as described in Section 6.2, we say that S is a degenerate solution iff there exist two constraints C(cid:2)i,l(cid:3) and C(cid:2)i,l(cid:17)(cid:3) such thatD(cid:17) > l, and the disjunct c(cid:2)i,l(cid:17)(cid:3) = S(C(cid:2)i,l(cid:17)(cid:3)) does not subsume c(cid:2)i,l(cid:3) = S(C(cid:2)i,l(cid:3)) (i.e., the disjuncts are drawn from different regionslof the preference profile).5The algorithms presented in [26] and [31] make explicit attempts to prevent the combinatorial explosion that mightresult from such allowances. In the former case, a tree-based encoding ensures that assignments proceed strictly upwardsin the profile, neither skipping levels nor borrowing from adjacent regions. In the latter case, additional boolean clauses areadded to prevent the SAT representation from encountering such solutions.In this section, we argue that these mechanisms are largely unnecessary if traditional DTP pruning strategies are in-voked. In particular, we show how the well-established techniques of removal of subsumed variables and semantic branchingprevent unwanted redundancy, regardless of whether meta-level variable heuristics are made to prefer low-level or high-level preference projections. Both of these techniques are unique to the meta-CSP formulation, and have been known fornearly a decade; their efficacy in reducing computational effort in temporal reasoning has been extensively studied in priorwork [33], with semantic branching providing the most significant savings. Here, we expose their effect on the structuralrelationship between constraints that are created in the conversion of a DTP with Preferences to a Valued DTP.7.3.1. High-level assignments preceding low-level assignmentsConsider a search tree in which meta-variables corresponding to high preference levels occur earlier than those corre-sponding to lower levels. A portion of such a tree is depicted in Fig. 5; to reflect that other constraints may be consideredearlier or later in search, incoming and outgoing arrows are placed on nodes at the top and bottom of the figure.In the absence of traditional meta-CSP pruning techniques, the following possible progression of assignments is possible:Search node #1kk + 1k + mk + m + nPartial solutionC L ← c(cid:2)1,L(cid:3)· · ·C L ← c(cid:2)1,L(cid:3)C L ← c(cid:2)1,L(cid:3)· · ·C L ← c(cid:2)1,L(cid:3)· · ·C L ← c(cid:2)1,L(cid:3)· · ·C L−1 ← c(cid:2)2,L−1(cid:3)C L−1 ← c(cid:2)2,L−1(cid:3)C L−1 ← c(cid:2)2,L−1(cid:3)C L−1 ← c(cid:2)2,L−1(cid:3)C L−2 ← c(cid:2)1,L−2(cid:3)C L−2 ← c(cid:2)2,L−2(cid:3)C L−2 ← (cid:5)Observe that all partial assignments considered between nodes k and k + m + n include one disjunct taken from thepreference profile of c1, and another disjunct from the preference profile of c2 (where c1 and c2 are disjuncts derived froman ancestral DTPP constraint C = c1 ∨ c2).However, consider the application of removal of subsumed variables [22], a pruning technique that refrains from makingassignments to any meta-variable if an inequality contained in one of its disjuncts is less constraining than the constraintimposed by the existing temporal network. The invocation of the disjunct c(cid:2)1,L(cid:3) (i.e., a1,L (cid:4) x1 − y1 (cid:4) b1,L ) has the effect ofsubsuming constraint C L−1, which contains the strictly looser disjunct c(cid:2)1,L−1(cid:3) (i.e., a1,L−1 (cid:4) x1 − y1 (cid:4) b1,L−1). This area ofpruned space is labeled B. Furthermore, all disjuncts c(cid:2)1,i(cid:3) (and thus all meta-variables Ci ) such that i < L are subsumed bythis assignment to C L (for instance, the region labeled A corresponds to the removal of subsumed variable C L−2).Similarly, when C L is assigned the disjunct c(cid:2)2,L(cid:3) (i.e., a2,L (cid:4) x2 − y2 (cid:4) b2,L ), all other constraints Ci such that i < L areagain subsumed. In Fig. 5, these pruned regions are labeled C, D, E, and F.After both of these disjuncts have been attempted, C L is given the empty value (cid:5); since such an assignment does notinvoke any changes to the temporal network, no meta-variables are subsumed. However, when assignments to C L−1 aremade, we encounter a familiar pattern: the selection of c(cid:2)1,L−1(cid:3) subsumes constraints at all lower levels (pruning the regionlabeled G), as does the selection of c(cid:2)2,L−1(cid:3) (pruning the regions labeled H and I).5 Note that c(cid:2)i,l(cid:3) may, in fact, be the empty assignment (cid:5).1402M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409Fig. 5. Removal of subsumed variables prevents the exploration of redundant search nodes when high-level assignments precede low-level assignments.Fig. 6. Semantic branching prevents the exploration of redundant search nodes when low-level assignments precede high-level assignments.7.3.2. Low-level assignments preceding high-level assignmentsConsider a search tree in which meta-variables corresponding to low preference levels occur earlier than those corre-sponding to high levels. A portion of such a tree is depicted in Fig. 6.In the absence of traditional meta-CSP pruning techniques, the following possible progression of assignments is possible:Search node #12kk + 1k + mPartial solutionC1 ← c(cid:2)1,1(cid:3)C1 ← c(cid:2)1,1(cid:3)· · ·C1 ← c(cid:2)1,1(cid:3)C1 ← c(cid:2)1,1(cid:3)· · ·C1 ← c(cid:2)1,1(cid:3)· · ·C2 ← c(cid:2)1,2(cid:3)C2 ← c(cid:2)2,2(cid:3)C2 ← c(cid:2)2,2(cid:3)C2 ← c(cid:2)2,2(cid:3)C3 ← c(cid:2)1,3(cid:3)C3 ← c(cid:2)2,3(cid:3)Once again, we observe that some partial assignments include disjuncts from the preference profiles of both c1 and c2.In particular, the assignment at search node k + 1 includes C2 ← c(cid:2)2,2(cid:3) and C3 ← c(cid:2)1,3(cid:3). While the latter of these valuessubsumes the disjunct c(cid:2)1,2(cid:3), its corresponding meta-variable C2 cannot be subsumed since it is instantiated prior to C3(and thus cannot receive an alternate assignment).M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091403Now consider the application of semantic branching [1], a pruning technique that enforces the negation of a constraintat a particular level in search if all assignments extending that constraint have been explored exhaustively; the additionof the negated expression has the effect of tightening the temporal network and preventing the expansion of unnecessarysubsequent nodes. The exploration of the disjunct c(cid:2)1,2(cid:3) (i.e., a1,2 (cid:4) x1 − y1 (cid:4) b1,2) will be followed by a subtree in whichboth c(cid:2)2,2(cid:3) (i.e., a2,2 (cid:4) x2 − y2 (cid:4) b2,2) and ¬c(cid:2)1,2(cid:3) (i.e., a1,2 > x1 − y1 ∨ x1 − y1 > b1,2) are enforced. Note that this latterconstraint is in direct conflict with c(cid:2)1,3(cid:3), a phenomenon that can be understood intuitively: if the satisfaction of a low levelof search has been explored (including extensions that do and do not satisfy the next highest level), then there is no benefitin reexamining those assignments that satisfy the next higher level again. This area of pruned space is labeled A. In fact, alldisjuncts c(cid:2)1,i(cid:3) such that i > 2 will be ignored at deeper levels of search.Similarly, when the disjunct c(cid:2)2,2(cid:3) has been explored and C2 is assigned the empty value (cid:5), there will be two negationsenforced on all nodes below: ¬c(cid:2)1,2(cid:3) and ¬c(cid:2)2,2(cid:3). Since all remaining unassigned meta-variables belong to higher preferencelevels, the only viable assignments that do not conflict with these negations are the (cid:5)-relaxations. In Fig. 6, we see theeffect of this pruning in the region labeled B.As failures propagate higher and higher into the tree, the effect of semantic branching becomes more and more sig-nificant. This is due to looser values toward the top of search tree providing tighter negations upon retraction, therebypreventing redundant extensions to several subsequent preference levels that would otherwise follow.7.3.3. Optimality of degenerate assignmentsWhile the superfluous search space created by preference projections creates a combinatorial explosion in theory, wehave shown that it is prevented in practice by enabling the well-established pruning techniques of removal of subsumedvariables and semantic branching. Even if one chooses not to employ these advanced pruning techniques, we can neverthe-less guarantee that the partial component STP corresponding to any degenerate meta-level assignment encompasses a setof object-level solutions to a non-degenerate assignment of equal or greater value. This final step ensures the soundness ofthe algorithm, e.g., that the final solutions it generates will not have suboptimal global preference values.Theorem 7.1. For any degenerate solution S, there exists a non-degenerate solution Ssolutions are a superset of those in S.(cid:17)of equal or greater value whose object-level(cid:17), consider any pair of assignments C(cid:2)i,l(cid:17)(cid:3) ← c(cid:2)i,l(cid:17)(cid:3) and C(cid:2)i,l(cid:3) ← c(cid:2)i,l(cid:3) in S, where l(cid:17) > l. If child(c(cid:2)i,l(cid:17)(cid:3), l)Proof. To construct S(cid:17)denotes the disjunct in the preference projection at level l that falls directly under c(cid:2)i,l(cid:17)(cid:3) in the preference profile of D,we can safely replace the disjunct c(cid:2)i,l(cid:3) with child(c(cid:2)i,l(cid:17)(cid:3), l), since child(c(cid:2)i,l(cid:17)(cid:3), l) is strictly less constraining than the currentlyenforced constraint c(cid:2)i,l(cid:17)(cid:3).This process is repeated for all pairs of mismatched disjuncts until there remains no evidence of degeneracy. Sinceno additional (cid:5)-relaxations are introduced, the cost of the solution cannot degrade. Furthermore, since each replacement(cid:17)is performed without tightening the temporal network, the set of object-level solutions in the final global assignment Sincludes all assignments contained in S. Hence, any solution extracted from the degenerate solution S also belongs to the, and is guaranteed to be optimal provided that S is itself an optimal meta-level assignment. (cid:2)non-degenerate solution S(cid:17)8. Experimental resultsIn this section, we describe the results of a set of experiments that were performed to compare an implementation ofvalued constraint satisfaction approach (which we name MAXILITIS-V) against the two previous systems for solving DTPPs:ARIO [31] and the GAPD solver [26]. MAXILITIS-V incorporates both semantic branching and removal of subsumed variables,though it does not utilize the variants of conflict-directed backjumping that have been used by some prior solvers. Wealso employ a minimum remaining values (or MRV) variable ordering heuristic [12] that dynamically chooses variables toinstantiate based on the fewest number of feasible disjunctive clauses remaining in the domain. As in [33], several tiebreaking methods are employed, including the number of pairwise conflicts with other disjuncts, as well as the amountof slack on the edges involved in the inequalities. Since the meta-variables of the VDTP correspond directly to constraints,we also easily modify the heuristic to prefer the instantiation of any “hard” constraint that must be satisfied prior to any“soft” constraints having finite valuations (constraints of both types are common in converted DTPP instances). Many otherstrategies for variable ordering – including variants of those explored in recent studies of finite-domain CSPs [2] – arepossible and are worthy of continued research.Unfortunately, there remains an absence of real-world benchmarks in temporal preference literature with which to pro-vide an empirical comparison of solvers.6 Consequently, we must employ the same problem generator used in prior DTPPstudies, which takes as parameters (cid:2)E, C, D−, D+, L, R−, R+(cid:3). The DTPP is constructed by generating a set of E events{x1, x2, . . . , xE } and a set of C constraints, where each constraint Ci consists of exactly 2 disjuncts. Each disjunct ci j is as-signed a pair of events xi j and yi j , and the lower and upper bounds ai j and bi j on the feasible difference between those6 The benchmarks used in the SMT competition [3] contain no optimization component, and are thus incapable of representing the local and globalpreference objectives in the problems of interest.1404M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409Fig. 7. Median running times for GAPD, ARIO, and MAXILITIS-V for DTPPs of varying sizes.events are selected from the interval [D−, D+]. To define the preference function for each temporal difference, the valuesai j and bi j serve as the endpoints for preference level 0. To construct preference level l, a reduction factor is chosen fromthe interval [R−, R+] ⊂ [0, 1] with uniform probability, and is applied to the interval at preference level l − 1; the resulting(smaller) interval is placed randomly between its endpoints. This process is repeated until preference level L is reached oran interval having zero length is created.We ran four sets of experiments, in which we evaluated the effect of problem size, the number of preference levels, theconstraint density, and their relevance to anytime performance. For all experiments, we generate 50 trials for each settingof parameters, and report the median running time for each solver over the 50 trials. A timeout of 300 seconds is enforcedon all problems. The time required to convert the DTPP into the VDTP is included in these runtimes, but is negligible.8.1. Varying problem sizeIn the first experiment, we explore the abilities of ARIO, GAPD, and MAXILITIS-V to scale with the size of the problem.The ability to perform well on this set of tests is especially important, since unlike other problem parameters (such as thenumber of preference levels), the size of the problem is often difficult for a knowledge engineer to control directly. We holdfixed the following parameters: {D− = −50, D+ = 100, L = 5, R− = 0.5, R+ = 0.9}. These settings are identical to those usedin previously published work [31]. We vary the number of constraints C from 10 to 50, and set the number of events E to45 C to maintain a constant constraint density.Fig. 7 displays the results of this experiment. The number of constraints in the problem is shown on the x-axis, and onthe y-axis is the median running time (note the logarithmic scale). GAPD quickly reaches the timeout limit of 300 secondsonce the number of constraints equals C = 25. The median runtime of ARIO consistently remains far below the cutoffthreshold, and reaches 43.62 seconds when C = 50. Recall that the presence of an efficient SAT solver has been labeled asthe key ingredient in achieving this substantial improvement. Yet, the branch-and-bound and iterative weakening versionsof MAXILITIS-V surpass both GAPD and ARIO on all problem sizes, without the aid of SAT techniques. For C = 50 (the largestset of problems), the median runtime of the iterative version is 0.01 seconds, over three orders of magnitude faster thanARIO.8.2. Varying the number of preference levelsIn the second experiment, we examine the effect of the number of preference levels on the performance of these solvers.We hold fixed the parameters {E = 24, C = 30, D− = −50, D+ = 100, R− = 0.5, R+ = 0.9}, and vary the number of prefer-ence levels L between 2 and 8.Fig. 8 provides the results of this experiment. Once again, GAPD tends to be much slower than ARIO, and ARIO is in turnconsiderably slower than either incarnation of MAXILITIS-V. For the case where the number of preference levels is seven,their respective median running times are 300, 62.71, and 0.16 seconds (this last being for the iterative version; the branch-and-bound variant requires 10.735 seconds on average). When eight preference levels are allowed, all solvers experiencesignificant difficulty. Overall, a difference of one to two orders of magnitude is observed between ARIO and the iterativeweakening incarnation of valued constraint satisfaction for cases where the number of preference levels is between fourand seven.8.3. Varying constraint densityIn the third experiment, we explore the abilities of these solvers to scale with constraint density, which is the ratio ofconstraints to events (C/E). We hold fixed the parameters {C = 30, D− = −50, D+ = 100, L = 5, R− = 0.5, R+ = 0.9}, andvary the number of events E between 3 and 36.M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091405Fig. 8. Median computation time for GAPD, ARIO, and MAXILITIS-V for DTPPs with varying numbers of preference levels.Fig. 9. Median running times for GAPD, ARIO, and MAXILITIS-V for DTPPs of varying constraint density.In Fig. 9 we present the results. For problems having constraint densities less than or equal to 2.5, both incarnationsof MAXILITIS-V typically achieve a performance improvement between one and two orders of magnitude over ARIO; fordensities larger than this, the difference in speed becomes less evident. It is also near this point that the branch-and-boundversion of MAXILITIS-V begins to overtake the iterative version. This is likely because the costs of the optimal solutions forthese extremely constrained problems are quite large, and thus several iterations are required before a solution is discovered.8.4. Anytime performancePrior work has underscored the particular importance for a temporal optimization engine to exhibit desirable anytimeproperties [26]. The reason for this is clear: extremely large, complex problems that contain many preference levels andtemporal events are often too difficult to solve to optimality. Furthermore, optimality is often of little use in practice,especially if there is considerable error involved in the preference modelling phase. If computational methods for preferentialoptimization are incapable of producing high-quality solutions early in search, then there is little guarantee for successfulintegration of this technology into applications that stress the real-time response of a system.In order to determine the anytime behavior of MAXILITIS-V, we conducted one final set of experiments. Nine differentproblem sizes were obtained by varying two dimensions of the generator’s parameters: the number of preference levels(selected from the range {5, 10, 15}), and the number of events/constraints (selected from the following settings: 10 events/30 constraints, 20 events/40 constraints, and 40 events/100 constraints). We hold fixed the remaining parameters at {D− =−400, D+ = 500, R− = 0.5, R+ = 0.9}, and enforce a timeout limit of 60 seconds. These parameters are all identical to thoseused in [26] for a similar set of anytime experiments. As in previous tests, 50 instances of each problem size were created,and all graphs reflect an average solution cost over all problem instances as a function of time.The results for the simplest set of problems (shown in Fig. 10) suggest that when the number of preference levels issmall, ARIO consistently outperforms GAPD in regards to time taken to generate an initial solution as well as the finalaverage solution cost; when the number of levels is increases, GAPD becomes more effective in the very early stages ofsearch, but is eventually overtaken by ARIO. In contrast, MAXILITIS-V outperforms both solvers on either measure and for all1406M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409Fig. 10. Anytime curves for GAPD, ARIO, and MAXILITIS-V on DTPPs with a small number of preference levels (L = 5).preference level parameters. Not only does MAXILITIS-V find an initial solution almost immediately, but the quality of thesolution is often improved to an extraordinary level before either ARIO or GAPD begin producing output of any kind. Thiseffect is most noticeable on the problems that have the greatest size.The results for problems with moderate and large numbers of preference levels are shown in Figs. 11 and 12. While therelative performance of GAPD continues to improve as problems become larger in size and taller in their preference profiles,we observe that MAXILITIS-V remains considerably far ahead of both its competitors.8.5. Analysis of resultsIn summary, the valued constraint satisfaction approach – achieved by adapting a state-of-the-art DTP engine to accom-modate the (cid:5)-relaxation and a branch-and-bound pruning strategy – consistently outperforms the previous DTPP solvers,including the SAT-based ARIO system and the specialized GAPD solver, on several dimensions (including the runtime neededto obtain optimal solutions, and the anytime performance on large problems that are too difficult to solve completely). Whilewe suspect that continued focus on optimization techniques within the SAT and Satisfiability Modulo Theories communi-ties will lead to improved performance in future solvers, these results clearly demonstrate that well-established CSP-basedmethods remain among the most successful approaches for constraint-based optimization to date.9. ConclusionsIn this paper, we have explored the modelling and optimization of preferences within the context of metric temporalreasoning. We have proposed the Valued DTP, a cousin of the DTP with Preferences that provides an alternative frameworkfor expressing optimization variants of the DTP. We have proven the equivalence of the VDTP and the DTPP when profiles areassumed to be piecewise-constant. We have identified the principal advantages of the Valued DTP representation; namely,that by exploiting the (cid:5)-relaxation to achieve the explicit violation of constraints (and their associated meta-variables), wepermit the straightforward representation of a meta-level assignment as a partial component STP. This enables the creationof a powerful algorithm for computing optimal solutions to the Valued DTP, deviating only slightly from the existing meta-CSP framework used to solving traditional temporal constraint problems. We have demonstrated that the pruning techniquescommonly used in state-of-the-art engines – namely, the removal of subsumed variables and semantic branching – naturallycope with redundant solutions in the context of optimization, eliminating the need for additional mechanisms that previousalgorithms have incorporated into their internal encodings. We have shown empirically that the runtime of MAXILITIS-V isconsiderably faster than other engines; in problems with varying size, constraint density, and numbers of preference levels,the efficiency of MAXILITIS-V was consistently competitive. For large problems, several orders of magnitude improvement wasM.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091407Fig. 11. Anytime curves for GAPD, ARIO, and MAXILITIS-V on DTPPs with a moderate number of preference levels (L = 10).Fig. 12. Anytime curves for GAPD, ARIO, and MAXILITIS-V on DTPPs with a large number of preference levels (L = 15).observed. Furthermore, we have shown empirically that the anytime properties of MAXILITIS-V far surpass those of previoussolvers (including those designed specifically for the purpose of anytime performance) on a wide variety of benchmarks.There remains great potential for continued research in the context of preference optimization for constraint-based tem-poral reasoning. First, the question of which encoding to use (either the VDTP or the DTPP) may depend on the application.1408M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–1409While the approach presented here exploits a one-way conversion, some domains may be more naturally expressed in oneor the other. In addition, more complex aggregation models may be required when considering the translation of temporalconstraints to the conjunctive normal form of the DTPP (to prevent the “doubling-up” of preference contribution from cor-related constraints). Finally, it would be valuable to consider a class of problems where the preference profiles of temporalconstraints are known only partially, and optimization must thus move forward with an incomplete model of the valuationstructure [11,27].AcknowledgementsThe author is indebted to Prof. Martha E. Pollack for insight and assistance with preliminary versions of this work. Theauthor is also grateful to Dr. Bart Peintner and Dr. Neil Yorke-Smith for several useful discussions, and to the anonymousreviewers for their valuable feedback. Dr. Moffitt is supported by the Josef Raviv Memorial Postdoctoral Fellowship.References[1] A. Armando, C. Castellini, E. Giunchiglia, SAT-based procedures for temporal reasoning, in: Proceedings of the 5th European Conference on Planning(ECP 1999), 1999, pp. 97–108.[2] T. Balafoutis, K. Stergiou, On conflict-driven variable ordering heuristics, in: Proceedings of the ERCIM workshop on Constraint Solving and ConstraintLogic Programming (CSCLP-2008), 2008.[3] C. Barrett, L. de Moura, A. Stump, SMT-COMP: Satisfiability modulo theories competition, in: Proceedings of the 17th International Conference onComputer Aided Verification (CAV 2005), 2005, pp. 20–23.[4] P. Berry, M. Gervasio, B. Peintner, N. Yorke-Smith, The design of a user-centric scheduling system for multi-faceted real-world problems, in: Proceedingsof ICAPS’07 Workshop on Moving Planning and Scheduling Systems Into the Real World, 2007.[5] P. Berry, M. Gervasio, B. Peintner, N. Yorke-Smith, A preference model for over-constrained meeting requests, in: Proceedings of AAAI 2007 Workshopon Preference Handling for Artificial Intelligence, 2007.[6] S. Bistarelli, Semirings for Soft Constraint Solving and Programming, Springer, 2004.[7] S. Bistarelli, U. Montanari, F. Rossi, Semiring-based constraint satisfaction and optimization, Journal of the ACM 44 (2) (1997) 201–236.[8] S. Bistarelli, U. Montanari, F. Rossi, T. Schiex, G. Verfaillie, H. Fargier, Semiring-based CSPs and valued CSPs: Frameworks, properties, and comparison,Constraints 4 (3) (1999) 199–240.[9] R. Dechter, Constraint Processing, Morgan Kaufmann, 2003.[10] R. Dechter, I. Meiri, J. Pearl, Temporal constraint networks, Artificial Intelligence 49 (1–3) (1991) 61–95.[11] M. Gelain, M.S. Pini, F. Rossi, K.B. Venable, Dealing with incomplete preferences in soft constraint problems, in: Proceedings of the 13th InternationalConference on Principles and Practice of Constraint Programming (CP 2007), 2007, pp. 286–300.[12] R.M. Haralick, G.L. Elliott, Increasing tree search efficiency for constraint satisfaction problems, Artificial Intelligence 14 (3) (1980) 263–313.[13] L. Khatib, P. Morris, R. Morris, F. Rossi, Temporal constraint reasoning with preferences, in: Proceedings of the 17th International Joint Conference onArtificial Intelligence (IJCAI 2001), 2001, pp. 322–327.[14] L. Khatib, P. Morris, R. Morris, K.B. Venable, Tractable Pareto optimal optimization of temporal preferences, in: Proceedings of the 18th InternationalJoint Conference on Artificial Intelligence (IJCAI 2003), 2003, pp. 1289–1294.[15] T.K.S. Kumar, A polynomial-time algorithm for simple temporal problems with piecewise constant domain preference functions, in: Proceedings of the19th National Conference on Artificial Intelligence (AAAI 2004), 2004, pp. 67–72.[16] J. Larrosa, F. Heras, S. de Givry, A logical approach to efficient Max-SAT solving, Artificial Intelligence 172 (2–3) (2008) 204–233.[17] M.D. Moffitt, B. Peintner, N. Yorke-Smith, Multi-criteria optimization of temporal preferences, in: Proceedings of the 8th International Workshop onPreferences and Soft Constraints, 2006.[18] M.D. Moffitt, M.E. Pollack, Partial constraint satisfaction of disjunctive temporal problems, in: Proceedings of the 18th International FLAIRS Conference(FLAIRS 2005), 2005, pp. 715–720.[19] M.D. Moffitt, M.E. Pollack, Temporal preference optimization as weighted constraint satisfaction, in: Proceedings of the 21st National Conference onArtificial Intelligence (AAAI 2006), 2006, pp. 110–116.[20] P. Morris, R. Morris, L. Khatib, S. Ramakrishnan, A. Bachmann, Strategies for global optimization of temporal preferences, in: Proceedings of the 10thInternational Conference on Principles and Practices of Constraint Programming (CP 2004), 2004, pp. 408–422.[21] M.W. Moskewicz, C.F. Madigan, Y. Zhao, L. Zhang, S. Malik, Chaff: Engineering an efficient SAT solver, in: Proceedings of the 38th Design AutomationConference (DAC 2001), 2001, pp. 530–535.[22] A. Oddi, A. Cesta, Incremental forward checking for the disjunctive temporal problem, in: Proceedings of the 14th European Conference on ArtificialIntelligence (ECAI 2000), 2000, pp. 108–112.[23] B. Peintner, M.E. Pollack, Low-cost addition of preferences to DTPs and TCSPs, in: Proceedings of the 19th National Conference on Artificial Intelligence(AAAI 2004), 2004, pp. 723–728.[24] B. Peintner, M.E. Pollack, Anytime, complete algorithm for finding utilitarian optimal solutions to STPPs, in: Proceedings of the 20th National Conferenceon Artificial Intelligence (AAAI 2005), 2005, pp. 443–448.[25] B. Peintner, P. Viappiani, N. Yorke-Smith, Preferences in interactive systems: Technical challenges and case studies, AI Magazine 29 (4) (2008) 13–24.[26] B.M. Peintner, Algorithms for constraint-based temporal reasoning with preferences, PhD thesis, University of Michigan, 2005.[27] M.S. Pini, F. Rossi, K.B. Venable, T. Walsh, Incompleteness and incomparability in preference aggregation, in: Proceedings of the 20th International JointConference on Artificial Intelligence (IJCAI 2007), 2007, pp. 1464–1469.[28] F. Rossi, Preference reasoning, in: Proceedings of the 11th International Conference on Principles and Practice of Constraint Programming (CP 2005),2005, pp. 9–12.[29] F. Rossi, P. van Beek, T. Walsh, Handbook of Constraint Programming, Elsevier, 2006.[30] T. Schiex, H. Fargier, G. Verfaillie, Valued constraint satisfaction problems: Hard and easy problems, in: Proceedings of the 14th International JointConference on Artificial Intelligence (IJCAI 1995), 1995, pp. 631–639.[31] H.M. Sheini, B. Peintner, K.A. Sakallah, M.E. Pollack, On solving soft temporal constraints using SAT techniques, in: Proceedings of the 11th InternationalConference on Principles and Practice of Constraint Programming (CP 2005), 2005, pp. 607–621.[32] K. Stergiou, M. Koubarakis, Backtracking algorithms for disjunctions of temporal constraints, in: Proceedings of the 15th National Conference on Artifi-cial Intelligence (AAAI 1998), 1998, pp. 248–253.M.D. Moffitt / Artificial Intelligence 175 (2011) 1390–14091409[33] I. Tsamardinos, M.E. Pollack, Efficient solution techniques for disjunctive temporal reasoning problems, Artificial Intelligence 151 (1–2) (2003) 43–90.[34] T. Walsh, Uncertainty in preference elicitation and aggregation, in: Proceedings of the 22nd AAAI Conference on Artificial Intelligence (AAAI 2007),2007, pp. 3–8.[35] T. Walsh, Complexity of terminating preference elicitation, in: Proceedings of the 7th International Joint Conference on Autonomous Agents and Mul-tiagent Systems (AAMAS 2008), 2008, pp. 967–974.