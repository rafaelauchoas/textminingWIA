Artificial Intelligence 171 (2007) 185–196www.elsevier.com/locate/artintDetermining the consistency of partial tree descriptionsManuel Bodirsky a,∗, Martin Kutz ba Humboldt-Universität zu Berlin, Germanyb Max-Planck-Institut für Informatik, Saarbrücken, GermanyReceived 1 June 2006; received in revised form 27 November 2006; accepted 15 December 2006Available online 22 December 2006AbstractWe present an efficient algorithm that decides the consistency of partial descriptions of ordered trees. The constraint languageof these descriptions was introduced by Cornell in computational linguistics; the constraints specify for pairs of nodes sets ofadmissible relative positions in an ordered tree. Cornell asked for an algorithm to find a tree structure satisfying these constraints.This computational problem generalizes the common-supertree problem studied in phylogenetic analysis, and also generalizes thenetwork consistency problem of the so-called left-linear point algebra. We present the first polynomial time algorithm for Cornell’sproblem, which runs in time O(mn), where m is the number of constraints and n the number of variables in the constraint.© 2006 Elsevier B.V. All rights reserved.Keywords: Tree descriptions; Constraint satisfaction problems; Graph algorithms; Left-linear point algebra1. IntroductionTree description languages became an important tool in computational linguistics over the last twenty years. Gram-mar formalisms have been proposed that derive logical descriptions of trees representing the syntax of a string [15,23,26]. Membership in a language is then equivalent to the satisfiability of the corresponding logical formula. In se-mantics, the paradigm of underspecification aims at manipulating the partial description of tree-structured semanticrepresentations of a sentence rather than at manipulating the representations themselves [17,25]. One of the key issuesin both constraint-based grammar and constraint-based semantic formalisms is to collect partial descriptions of treesand to solve them, i.e., to find a tree structure that satisfies all constraints.Cornell [13] introduced a simple but powerful tree description language, which contains constraints for dominance,precedence, and equality between nodes, and disjunctive combinations of these (a formal definition is given is Sec-tion 2). Cornell also gave a saturation algorithm based on local propagations, which turned out to be incomplete. Foran example of a tree description that shows this, see Section 3.4 in [3].In this article we present the first polynomial-time algorithm that tests satisfiability of a tree description from Cor-nell’s tree description language and directly constructs a solution to the problem instance, if one exists. A predecessorof this algorithm, which applies to a restricted language, was presented in [4]. The present algorithm, which solves the* Corresponding author.E-mail addresses: bodirsky@informatik.hu-berlin.de (M. Bodirsky), mkutz@mpi-inf.mpg.de (M. Kutz).0004-3702/$ – see front matter © 2006 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2006.12.004186M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196general problem of Cornell’s full tree description language, runs in time O(nm), where n is the number of variablesand m the number of constraints in the input. The performance is achieved by a recursive strategy that works directlyon the constraint graph, and avoids local consistency techniques a la [14,19] that are frequently used in constraintsatisfaction.Significance of the results. Computational linguistics is not the only area in computer science and artificial intelli-gence where partial tree descriptions become relevant. In fact, a fragment of Cornell’s language has been introducedindependently in [12] (also see [16,21]), and is known there as the left-linear point algebra. The best known algorithmfor the so-called network satisfaction problem for the left-linear point algebra has a running time which is in O(n5),where n denotes the size of the input [21]. Since the left-linear point algebra is a fragment of Cornell’s language, ourquadratic time algorithm also yields a new and asymptotically faster algorithm for the left-linear point algebra. Detailsof this connection will be given in Section 3.1.The consistency problem we study can also be posed as a constraint satisfaction problem (CSP), as formalizedin e.g. [8]. The catch here is that the variables might take values from an infinite domain (it can be shown that theproblem cannot be modeled as a CSP with a finite domain); see also Section 3. One important direction of research inthis area is to systematically identify constraint languages that can be solved in polynomial time. In this context, ouralgorithmic result is interesting because it is neither based on group-theoretic techniques such as Gaussian elimination,nor on Datalog and local consistency techniques. This is in contrast to CSPs with finite domains, where all knownalgorithms for polynomial-time solvable algorithms involve at least one of the above two techniques [9,18].In computational biology, phylogenetic analysis is a field where we have to deal with partial information aboutevolutionary trees. An evolutionary tree for a set of species is a rooted tree where the leaves are bijectively labeledwith the species from the set. Constructing evolutionary trees from biological data is a difficult problem for a varietyof reasons (see [20]). Many approaches assume that the evolutionary tree is built from a set of taxa based on thecomparison of a single protein or a single position in aligned protein sequences, but very often the resulting tree willbe different depending on which particular protein or position is used. Several trees, each from a different protein orposition, must be built and be shown to be “generally consistent” before the implied evolutionary history is consideredreliable. The question whether such consistency tests can be automated motivates the so-called common-supertreeproblem [20]. We will describe in Section 3.2 how the common-supertree problem can be modeled in (a fragment of)Cornell’s tree description language. Therefore, the algorithm presented here also yields a new algorithm for (and anew perspective on) the common-supertree problem.Outline. In Section 2, we introduce standard terminology for rooted trees and define Cornell’s tree description lan-guage. This allows us to clearly describe in Section 3 the relationship between our results and results in qualitativetemporal reasoning in artificial intelligence, phylogenetic analysis in computational biology, the left-linear point al-gebra in the theory of relation algebras, and the general framework of constraint satisfaction problems. In Section 5,we introduce an algorithm for a small fragment of Cornell’s language. This fragment is already expressive enough tocapture the common-supertree problem mentioned above. The corresponding consistency-problem is non-trivial in thesense that the algorithm proposed by Cornell is inconsistent already for this fragment (see [3]). However, the simplic-ity of the language allows for a smaller and simpler description of an algorithm that decides consistency. Discussingthis language first will be instructive to deal with the consistency problem for the full language, which is far moreinvolved. For the full language, we first reduce the problem to a simpler tree description language (Section 5), provefundamental results for constraint-graphs that are associated to a partial tree description (Section 6), and finally usethese results to present our algorithm and prove its correctness (Section 7). Section 8 summarizes and poses questionsfor future research.2. Tree descriptionsThe trees considered here are always rooted, and we consider the edges as directed, pointing away from the root.By an ordered tree we mean a rooted tree with a linear order on the children of each vertex and we use the terms leftand right to compare them.We follow the notation of [2]. The set of vertices of a tree T is denoted by VT , and the vertices are usually calledu, v, or w. The expression u (cid:3) v denotes that u is the father of v and u (cid:3)∗ v (and v ∗(cid:4) u) means that u dominates v, i.e.,u is an ancestor of v in the tree (including u = v). We write u (cid:3)+ v (and v +(cid:4) u) if u (cid:3)∗ v and u (cid:5)= v. If for two verticesu and v neither u (cid:3)∗ v nor v (cid:3)∗ u, we say that u and v are disjoint, in symbols u ⊥ v. In this situation we distinguishM. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196187Fig. 1. The translation of the partial tree description of Fig. 1 into the restricted language.two cases: either u precedes or succeeds v. A vertex u precedes a vertex v (and v succeeds u), in symbols u ≺+ v(and v +(cid:8) u), if there is a common ancestor of u and v in the tree that has two children w1 and w2 with w1 (cid:3)∗ u andw2 (cid:3)∗ v and such that u is to the left of v. We write u ≺∗ v if either u ≺+ v or u = v.The right picture in Fig. 1 shows an example of a rooted tree with root α(x). In pictures we indicate the orderingof the children of a vertex by distinguishing between left and right. Here, α(v) ≺+ α(w) and α(y) ≺+ α(v), andα(x) (cid:3)+ α(w), for example.In an ordered tree, for every pair u, v of vertices exactly one of the following relations holds:+(cid:8) v,+(cid:4) v,u = v.u ≺+u (cid:3)+v,v,uuIt is important to note that the union of the relations (cid:3)+ and ≺+ forms a strict linear order on the set of all verticesof an ordered tree, which is easily seen to be the pre-order that results from a (recursive) tree traversal that lists eachnode before its descendants.We now define partial tree descriptions, due to Cornell [13], that allow to partially describe the structure of anordered tree using arbitrary disjunctions of these five cases. To distinguish clearly between equality in this languageand the common usage of the symbol ‘=’, we denote the former relation by ‘≡’.Definition 1. A partial tree description (V , C) consists of a set of variables V and a set C of binary constraints of theform xRy, where x, y ∈ V and R ⊆ {(cid:3)+, +(cid:4), ≺+,+(cid:8), ≡}. A constraint xRy is satisfied by a pair (T , α), where T isan ordered tree and α : V → VT is a mapping from the variables to the vertices of the tree, if α(x)Rα(y) holds in thetree for some relation R ∈ R. A pair (T , α) that satisfies all the constraints in C is called a solution for (V , C).Note that the mapping α in the above definition is not required to be surjective. In particular, the induced graphon the image of α need not be connected but can be a forest. A partial tree description that has a solution is calledsatisfiable or consistent.Fig. 1 shows a partial tree description and one of its solutions on the right. In this picture, a directed edge from xto x(cid:13) that is labeled by R denotes a constraint xRx(cid:13).3. Related workCornell’s tree description language is closely related to problems in various fields of computer science and arti-ficial intelligence. We focus here on fields that are distinct from the origins of Cornell’s language in computationallinguistics.3.1. The left-linear point algebraThe left-linear point algebra is studied in the area of binary relation algebras and algebraic logic, and can be usedto model flows of time which branch into the future, but where the past is fixed [12,16,21]. Formally, a semi-linear (orleft-linear) order (O, <) is a partial order such that if s, t, u ∈ O, s < u, and t < u, then either s < t, t < s, or s = t.188M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196In [21], the case that neither u < v nor v < u holds for two distinct elements u and v in a semilinear order is denotedby u # t. Semi-linear orders give rise to an (abstract) relation algebra, called the left-linear point algebra, which haseight elements, and three atoms, represented by <, >, and #. A typical question in this context is the complexity ofthe so-called network satisfaction problem. In case of the left-linear point algebra, the network satisfaction problemcan be solved in quintic time, i.e., in time O(n5), where n denotes the size of the network.It is straightforward to see from the definitions given in [21] that the network satisfaction problem for the left-linear point algebra is just another formulation of the consistency problem for partial tree descriptions (V , C), wherewe restrict the constraint in C to be of the form x{(cid:3)+}y or x{≺+, +(cid:8)}y. In Section 4, we discuss an algorithm thatsolves the consistency problem for partial tree descriptions for this restricted language. The algorithm we present hasa running time which is quadratic in the size of the partial tree description, and therefore outperforms the previouslyknown algorithm for the network satisfaction problem for the left-linear point algebra.3.2. The common-supertree problemThe common-supertree problem is a computational problem that was introduced and studied in computationalbiology [7,27], and is defined as follows. Let S be a set of trees with common leaf set L. The computational task is todecide whether there is a tree T on the leaf set L such that every tree in S is a refinement of T , i.e., can be obtainedby a series of contractions of edges from T . If such a refinement exists, we say that the trees in S are compatible.The common-supertree problem can be easily formulated with tree descriptions. In fact, we only have to use theconstraint types {(cid:3)+} and {≺+, +(cid:8)}. Let S be a set of trees over a common leaf set L. The variables of the treedescription are the vertices of the trees in S, where the inner nodes of all the trees become different variables, butthe leaves are represented by the same set of variables for all trees. Tree-edges xy translate to dominance constraintsx{(cid:3)+}y. Siblings x, y in a tree from S will be related via the constraint x{≺+, +(cid:8)}y.See Fig. 2 for an example of an incompatible set that contains two rooted trees, and its translation into an (unsatisfi-able) partial tree description. In this picture, solid arcs stand for the constraint {(cid:3)+} and dashed arcs for the constraint{≺+, +(cid:8)}.The size of the resulting tree description is clearly O(Δ2n), where n is the total number of nodes in S and Δ denotesthe maximum degree in any tree of S. It is not hard to show that it has a solution if and only if there is a commonsupertree for the trees from S.Note that the above definition of compatible should not be confused with the notion of compatible given in [24].They say that a tree T is compatible with T (cid:13) if there exists a subset A of the leaves of T such that the minimalsubtree of T that connects all nodes in A and suppresses all nodes of degree two equals T (cid:13). In contrast, the notion ofcompatibility we used here is studied e.g. in [27], and was called weak compatibility in [24].Fig. 2. Two incompatible trees and the translation into an (unsatisfiable) partial tree description.M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–1961893.3. Allen’s Interval AlgebraAs already observed by Cornell [13], it is possible to translate a partial tree description into a set of constraintsfrom Allen’s Interval Algebra [1]. In Allen’s Interval Algebra, the variables denote intervals over the real line. Theconstraints from Allen’s Interval Algebra describe possible relationships between intervals, e.g., one can impose theconstraint that two intervals do not overlap. Allen’s full interval constraint logic is NP-complete in its unrestrictedform, but there are fragments of this logic that can be solved in polynomial time [10,22].If the translation mentioned above only produces constraints that fall into one of the tractable fragments of Allen’sInterval Algebra, we could use the translation to obtain a polynomial-time algorithm for partial tree descriptions.The idea for the translation of partial tree description (V , C) into Allen’s Interval Algebra is as follows. We use Vas the set of variables that denote intervals in the translation. If C contains x{(cid:3)+}y, then the translation contains aninterval constraint that requires that the interval for x contains the interval for y. If C contains x{≺+, +(cid:8)}y, then thetranslation contains an interval constraint that requires that the interval for x and the interval for y are disjoint. All theother partial tree descriptions can be translated analogously.Solutions the translation only correspond to trees, if the set of intervals in the translation is laminar, i.e., for anypair of intervals that is not disjoint, one interval must completely contain the other. In other words, intervals mustnot overlap. To ensure this, we also have to add interval constraints that require that the intervals for x and y do notoverlap, for all distinct variables x and y in V . It is then easy to show that the translation preserves satisfiability.Consulting the classification of the tractable fragments of Allen’s Interval Algebra given in [22], it turns out thatthe interval constraints obtained from translating constraints of the form x{(cid:3)+}y and x{≺+, +(cid:8)}y in the above way,together with the necessary non-overlap interval constraints, do not fall into one of the tractable fragments of Allen’sInterval Algebra. Hence, we cannot use this approach to solve partial tree descriptions in polynomial time.3.4. General constraint satisfaction problems (CSPs)The problems studied in this article (as well as the constraint satisfaction problem for Allen’s Interval Algebraand its fragment) fall into a class of computational problems known as constraint satisfaction problems (CSPs), seee.g. [8]. Every problem in this class can be described as a homomorphism problem with respect to a fixed relationalstructure. To be precise, for a fixed structure Γ over a relational signature τ , also called the template, the constraintsatisfaction problem of Γ is the following computational problem:CSP(Γ )INSTANCE: A finite τ -structure S.QUESTION: Is there a homomorphism from S to Γ ?For relational structures Γ over a finite domain the computational complexity of the problems CSP(Γ ) was inten-sively studied; see e.g. [9,18]. The most systematic approach here is based on a connection to universal algebra, whichessentially says that the computational complexity of CSP(Γ ) is described by a universal-algebraic object called theclone of polymorphisms of Γ [9].However, the consistency problem for partial tree descriptions cannot be formulated with a finite template. But itcan be formulated with a ω-categorical countable template described e.g. in [11]; see [3,6] for constraint satisfactionwith infinite templates. The concept of ω-categoricity is fundamental in model-theory. It turns out that the universal-algebraic approach can also be applied to study the complexity of CSP(Γ ) if Γ is ω-categorical [5].It is interesting to observe that the algorithm presented here does not apply local consistency techniques or group-theoretic techniques, whereas all known tractable CSPs with finite templates having a finite domain make use of atleast one of these two techniques [9,18].4. An algorithm for a restricted signatureWe first illustrate the idea of our algorithm for a small fragment of the tree description language, which is thefragment that corresponds to the left linear point algebra described in Section 3. We have also seen that this fragment190M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196Fig. 3. An inconsistent partial tree description.is already expressive enough to cover the common-supertree problem from phylogenetic analysis mentioned in theintroduction. In this reduced constraint language we only allow constraints of the typesx{(cid:3)+}yand x{≺+,+(cid:8)}y.The first constraint is called (strict) dominance and the second disjointness, and we use the shorthands x (cid:3)+ y andx ⊥ y, respectively, for these two types of literals.Such a set of constraints can be viewed as a graph (V ; (cid:3)+, ⊥) with two types of edges, namely directed edges(cid:3)+ and undirected edges ⊥. Observe that the binary relations (cid:3)+ and ⊥ are now defined both on the vertices of atree and on the nodes of an instance. The reference, however, should always be clear. We would like to stress thatthe two constraints do not allow for equality, i.e., x (cid:3)+ y means that in any solution, x must lie strictly above y. Wesay that a constraint graph G has a solution (T , α) (and is satisfiable) if the corresponding partial tree descriptionhas this solution (and is satisfiable). We also use some of the standard graph theory notation, e.g., the subgraph ofG = (V ; (cid:3)+, ⊥) induced by a subset S of V is denoted by G[S], and G − S denotes the constraint graph G[V \ S].In pictures we draw this constraint graph with two different types of arcs. For a dominance edge x (cid:3)+ y we drawa directed arc from x to y, for a disjointness edge x ⊥ y we draw a dashed line without direction. Fig. 3, for instance,shows such a constraint graph.The basic idea behind our algorithm to find a solution to a partial tree description (V , C) (if one exists) is to picka node x of V as the root of our solution, then to decompose (V , C) into smaller parts, and to recursively determinesolutions to these parts, which will become the subtrees below x. With this perspective, the following definition comesnaturally.Definition 2. Let (V , C) be a partial tree description. Then a variable x ∈ V is free if (V , C) has a solution (T , α) inwhich α(x) is the root of T .By definition, a partial tree description with a free node is satisfiable. We shall see soon that under a simpleconnectivity condition for the constraint graph, the converse is also true: a satisfiable instance with a “connected”constraint graph must have a free node, i.e., a node that dominates all others.The crucial point here is, of course, in what sense the constraint graph, which contains directed and undirectededges, should be connected. Let us briefly recall some conventions. An undirected path in a directed graph (alsocalled digraph) may use arcs in any direction, ignoring their orientation. A digraph D = (V ; E) is strongly (weakly)connected if there is a directed (an undirected) path from a to b for any two vertices a, b ∈ V . A strongly (weakly)connected component of D is a maximal strongly (weakly) connected induced subgraph U of D.Now, we say that a constraint graph (V ; (cid:3)+, ⊥) is dominance-connected if the digraph (V ; (cid:3)+) is weakly con-nected. This notion of connectivity is crucial for our desired characterization of free nodes. The following lemmamarks the first step.Lemma 1. Let G = (V ; (cid:3)+, ⊥) be a dominance-connected constraint graph, and let y and y(cid:13) be variables in V . Thenfor every solution (T , α) of G there exists a variable x ∈ V such that α(x) (cid:3)∗ α(y) and α(x) (cid:3)∗ α(y(cid:13)) in T .Proof. Since the vertices y and y(cid:13) are weakly connected in (V ; (cid:3)+) there exists a chain of nodes (y1, . . . , yr ) that startsat y = y1, ends at y(cid:13) = yr , and where (yi, yi+1) ∈ (cid:3)+ or (yi+1, yi) ∈ +(cid:4) for 1 (cid:2) i (cid:2) r − 1. We prove by induction onr that for every solution (T , α) of (V , C) there exists an index j ∈ {1, . . . , r} with α(yj ) (cid:3)+ α(y0) and α(yj ) (cid:3)+ α(yr )in T . If r = 0 or r = 1 then we can choose x to be either α(y0) or α(yr ). Otherwise, we can apply the inductionhypothesis to the chain (y1, . . . , yr−1). Thus, there exists a j , 0 (cid:2) j (cid:2) r − 1, such that α(yj ) is a common ancestorM. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196191of α(y1) and α(yr−1) in T . If α(yr−1) (cid:3)+ α(yr ) then α(yj ) is also a common ancestor of α(y1) and α(yr ), so we canchoose x = yj . Otherwise, α(yr ) (cid:3)+ α(yr−1) in T . Hence, both α(y1) and α(yr ) are ancestors of yr−1 in T . Since Tis a tree, it follows that α(yr ) (cid:3)∗ α(yj ) or α(yj ) (cid:3)∗ α(yr ) in T . In the first case, we choose x = yr , and in the secondx = yj . (cid:2)As promised, we now show that every satisfiable dominance-connected constraint graph has a free node.Proposition 1. A satisfiable partial tree description (V , C) with a dominance-connected constraint graph has a freenode.Proof. Assume there is a solution (T , α) for (V , C) and consider the vertices v that are topmost in T with respect to(cid:3)+ such that v = α(x) for some node x ∈ V . If there is only one such vertex v, then the subtree rooted at v togetherwith α is also a solution of (V , C). But since there is a node x ∈ V such that v = α(x), this contradicts the assumptionthat x is not free. If there are two distinct topmost nodes v, v(cid:13), then v and v(cid:13) are disjoint in T . Since the constraintgraph is dominance-connected, we can apply Lemma 1, and obtain a contradiction to the assumption that v and v(cid:13) lietopmost in T . (cid:2)For the algorithm we need a concise graph-theoretic characterization of free nodes that can be checked efficiently.Proposition 2. Let G = (V ; (cid:3)+, ⊥) be the constraint graph of a satisfiable partial tree description. Then a node x ∈ Vis free if and only if(C1) there is no arc y (cid:3)+ x in G and(C2) there is no edge x ⊥ y in G.Proof. If there is another y such that y (cid:3)+ x, then the vertex x cannot be topmost in any solution of G, and thus cannot be free. If the vertex x is involved in a disjointness constraint it can also not be free, since the root of a tree is notdisjoint to the other nodes in the tree.Conversely, assume that the node x of a satisfiable set of constraints satisfies (C1) and (C2). The dominance-connected components of G[V −{x}] are also satisfiable and must thus by Proposition 2 have free nodes. Then we havethe following solution for G: introduce a tree node x and let the solutions of the dominance-connected componentsbecome the subtrees of this node. The disjointness constraints between the different dominance-connected componentsare thus satisfied by construction and it is clear from (C1) and (C2) that all the constraints on x are also satisfied. (cid:2)Example. Let us revisit the example shown in Fig. 3. Note that instance does not contain a node x that satisfies (C1)and (C2). By Proposition 2, there is no free node, and hence the instance has no solution. But if any constraint in theinstance is removed, we find a node satisfying both conditions, and hence any such instance has a solution.Fig. 4 shows the algorithm for the restricted constraint language with the two relations (cid:3)+, ⊥. For a dominance-connected constraint graph, the function Solve first selects a free node x as root and then links the recursively computedSolve(G)// input: a dominance-connected constraint graph G = (V ; (cid:3)+, ⊥)// constructs a tree T and a mapping α: V → VTpick a node x of G satisfying (C1) and (C2);if no such free node exists then return “problem has no solution”;create a new tree node r and let α(x) := r;compute the dominance-connected components C1, . . . , Ck of G − {x};for i = 1 to k docall Solve(G[Ci ]) and make the returned root a new child of r;odreturn root r;Fig. 4. The function Solve for constraints of the type (cid:3)+and ⊥.192M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196solutions to the dominance-connected components Ci of the remainder G − {x} below the α-image r of x in the correctorder.Theorem 1. There is an algorithm that decides satisfiability of a given partial tree description (V , C) in the restrictedconstraint language in O(|V ||C|) time.Proof. It is clear that we can construct the constraint graph (V ; (cid:3)+, ⊥) of the given partial tree description in lineartime. We then apply the algorithm shown in Fig. 4 on the constraint graph. For an instance that is not dominance-connected, we can first introduce a dummy node z together with a (cid:3)+-arc from z to each other node to make the graphconnected. The node z then becomes the root of the output, and since α is not required to be onto the solution will bevalid also for the original graph without z.If the algorithm detects a weakly connected component without a free node, we know by Proposition 1 that theconstraints do not have a solution. Otherwise Proposition 2 guarantees that we can proceed and make a node xsatisfying (C1) and (C2) the root of our solution. The running time is dominated by the repeated computations of theconnected components of constraint graphs. We can use depth first search to compute the connected components intime O(|V | + |C|), and this will be done at most |V | times. We can assume that |V | is smaller than |C| − 1, otherwisethe first call of the algorithm divides the problem into instances where the assumption holds. Hence the algorithm runsin time O(|V ||C|). (cid:2)5. Reduction to four basic constraintsWe now turn to the general problem of deciding the consistency of a partial tree description for the full languageintroduced by Cornell. In order to get control over the 25 subsets of the relation set R ⊆ {(cid:3)+, +(cid:4), ≺+,+(cid:8), ≡}, we firstshow how to express each of them with a smaller language that contains the following four different constraint typesonly:x{(cid:3)+x{(cid:3)+, ≡}y,+(cid:4), ≺+,,x{≺++(cid:8)}y,, ≡}y,x{≺+,+(cid:8), ≡}y.(1)We reduce each of the 32 subsets either directly to an intersection of constraints from (1), or we build small gadgetswith new dummy variables that can simulate the original constraint.The constraints {+(cid:4), ≡} and {+(cid:8), ≡} are simply the first and second constraint of (1) flipped, and the singletons{(cid:3)+}, {≺+}, and {≡} can be written as intersections of these. The two extremal sets {+(cid:4), (cid:3)+, ≺+,+(cid:8), ≡} and ∅ arenot needed since the former imposes no restrictions on the tree and the latter is, by definition, unsatisfiable. If we showhow to express the constraintsx{(cid:3)+x{(cid:3)++(cid:4), ≡}y,,, ≺+, ≡}y,+(cid:8), ≡}y,x{(cid:3)+x{(cid:3)+, ≺+,+(cid:8), ≡}y,(2)with those in (1) we are done, since the remaining constraints are easily representable as flippings and intersections ofconstraints from (1) and (2).For each constraint x{(cid:3)+, +(cid:4), ≡}y, we introduce a new variable z and replace it by the two constraints x{(cid:3)+, ≡}zand y{(cid:3)+, ≡}z. By the properties of a tree, these two constraints imply x{(cid:3)+, +(cid:4), ≡}y. Conversely, every solution forthe original constraints can be modified to satisfy also the new constraints.Constraints of the form x{(cid:3)+, ≺+, ≡}y are replaced by the two constraints x{(cid:3)+, ≡}z and z{≺+, ≡}y, where z isa new variable. Similarly, we can replace x{(cid:3)+, +(cid:8), ≡}y by the two constraints x{(cid:3)+, ≡}z and z{+(cid:8), ≡}y. Finally,we replace x{(cid:3)+, ≺+, +(cid:8), ≡}y by x{(cid:3)+, ≡}y and z{≺+, +(cid:8), ≡}y, where z is again a new variable.Thus we can express all constraints in Cornell’s language with the four basic binary relations from (1). Our algo-rithm works on tree descriptions consisting of such basic constraints only. We therefore introduce special names andnotation for these four types:– x{(cid:3)+, ≡}y: the dominance constraint x (cid:3)∗ y,– x{≺+, ≡}y: the precedence constraint x ≺∗ y,M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196193Fig. 5. The translation of the example from Fig. 1 into the basic constraints.– x{≺+, +(cid:8), ≡}y: the disjoint-or-equal constraint x(cid:3) y,– x{(cid:3)+, +(cid:4), ≺+, +(cid:8)}y: the inequality constraint x (cid:5)≡ y.Note that from now on, the notions of dominance and precedence relation are to be considered non-strict, i.e., theystand for reflexive relations.In the following we apply this reduction to the example presented in Fig. 1. The result is shown in Fig. 5. Since thedisjoint-or-equal and the inequality constraint are symmetric, we indicate them as undirected edges and not as arcs.6. Constraint graphs and freenessOur algorithm for the full tree description language uses the ideas that we discussed for the restricted setting. Thefirst important difference to the restricted setting is that now several variables may map to the same tree node. Hence,we shall need a generalized notion of freeness.Definition 3. Let (V , C) be a partial tree description. Then S ⊆ V is called free if there is a solution (T , α) for (V , C)such that S = α−1(r), where r is the root of T .Similarly to the restricted setting we want to show that under a certain connectedness condition free sets must exist,and we also want to find practical characteristics of free sets to identify them algorithmically. To this end, we adaptthe concept of the constraint graph from Section 4. The concept of weak connectedness with respect to dominanceedges must be replaced by a more complex definition that is based on an auxiliary graph containing dominance andprecedence arcs. We define the directed P -graph (V , P ) on V with arc sety or x (cid:3)∗P := {xy | C contains x ≺∗y or y (cid:3)∗x}and call a partial tree description (V , C) dominance connected if its P -graph is strongly connected.Example. Consider the instance drawn in Fig. 5. The P -graph of this example is strongly connected. However, ifwe consider the graph where the vertex x and all constraints imposed on x are removed, then the P -graph has fourconnected components.The following proposition is the analog of Proposition 1 for the restricted case.Proposition 3. A satisfiable partial tree description with a strongly connected P -graph has a free set.Proof. Suppose (T , α) is a solution of C. We consider the set S of nodes in C that map to the minimum of the linearorder (cid:3)+ ∪ ≺+ in T , i.e., the nodes that map to the leftmost and topmost vertex u in T . If the vertex u dominates allvertices in α(V ) then S is actually a free set. We claim that this must always be the case. So assume for contradiction194M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196that there is a variable y ∈ V such that α(y) is not dominated by u. Since the P -graph of C is strongly connected itcontains a path y, x1, x2, . . . , xk from y /∈ S to some xk ∈ S. The path α(y), α(x1), α(x2), . . . , α(xk) must eventuallyenter the subtree rooted at u, with α(xj ), say. Then α(xj −1) comes before u in (cid:3)+ ∪ ≺+, contradicting the minimalityof u with respect to the linear order (cid:3)+ ∪ ≺+. (cid:2)For the analogy to Proposition 2, the graph-theoretic characterization of free sets, we define a directed graph (V , D)(called the D-graph) that is based on the (cid:3)∗ relation but in addition also takes precedence constraints into account.Precisely, we letD := {xy | C contains x (cid:3)∗y or x(cid:3) y or x ≺∗y or y ≺∗x}.Example. Again, consider the instance drawn in Fig. 5. The strongly connected components of the P -graph has fivestrongly connected components.We would like to remark that the digraphs (V , D) and (P , D) have an interesting symmetry: D is based on dom-inance constraints and contains bidirected precedence constraints, while P is the union of the precedence constraintsand all bidirected dominance constraints. However, a deeper reason for this similarity is elusive. The purposes of thetwo digraphs are very different in nature.The characterization of Proposition 2 now becomes a similar statement about the D-graph, with the old conditions(C1) and (C2) merged into one, (C). On the other hand, inequality now has to be handled explicitly, which again givesa second condition, (I).Proposition 4. Let (V , C) be a satisfiable partial tree description. Then S ⊆ V is a free set of nodes if and only if thefollowing two conditions hold:(C) there is no edge xy ∈ D such that x /∈ S and y ∈ S and(I) there is no pair x, y ∈ S such that x (cid:5)≡ y.Proof. The two conditions are clearly necessary, because a free set denotes the root of a tree, which dominates allother vertices, and because a constraint x (cid:5)≡ y explicitly forbids to map x and y to the same tree node.For the other implication, let S be a set of nodes that satisfies conditions (C) and (I). Let C1, . . . , Ck be the stronglyconnected components of the P -graph without S. Fix an arbitrary linear extension of the acyclic structure that isdefined by the P -graph on C1, . . . , Ck. Since C is satisfiable, the subgraph Gi of C induced by the component Ci hasa solution (Ti, αi), for all 1 (cid:2) i (cid:2) k. Introduce a new vertex v, and add T1, . . . , Tk as subtrees according to this linearorder of the components. The resulting tree is denoted by T . Now consider the mapping α that is the extension of allthe αi and maps the vertices in S to v.We claim that (T , α) is a solution for (V , C), and therefore S is a free set of nodes. It is clear that (T , α) satisfiesall inequality constraints, because by (I) all inequality constraints are either within one of the components, or betweendifferent components, or between S and a component, and in all these cases the inequality is satisfied in (T , α). IfC contains a disjointness constraint between x and y, then condition (C) implies that one out of the following casesapplies. Either x and y are both in S, in which case the disjointness is satisfied by (T , α). Or, x and y are in the samecomponent Ci , in which case the constraint is satisfied, because it is satisfied in (Ti, αi) as well. By the definition ofthe P -graph it cannot be that x and y are in different components.If C contains a dominance constraint between x and y, then condition (C) implies that y cannot be in S. Moreover,x and y cannot be in different components C1, . . . , Ck, by the definition of the P -graph. Therefore, either x and y areboth in the same component or both in S, or x is in S and y is in S; in all cases the dominance constraint is satisfiedby (T , α).Finally, suppose C contains a precedence constraint between x and y. Again, we see that the constraint is satisfiedif both x and y lie in S or both lie in the same component C1, . . . , Ck. If they lie in different components, then theprecedence constraint is satisfied because the subtrees below v in T were arranged according to a linear extension ofthe acyclic structure defined by the P -graph on the components C1, . . . , Ck. (cid:2)M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196195Solve(C):Compute the scc’s of the P -graph of (C),and let C1, . . . , Ck be a linear extension of their acyclic structurecreate a new vertex r with childrenSolve_con(C[Ci ]), for 1 (cid:2) i (cid:2) k, in this orderreturn rSolve_con(C):precondition: The P -graph of C is strongly connectedif no set of nodes satisfying (C) and (I) existsthen return “problem has no solution”else choose a set of nodes S satisfying (C) and (I )let r be the root of the tree Solve(C[V − S]) and set α(S) to rreturn rFig. 6. The function Solve for the full tree description language.7. The algorithmWe now turn the Propositions 4 and 3 on free sets of nodes into an algorithm for Cornell’s full language. From agiven input with constraints (cid:3)∗, ≺∗, (cid:3) , and (cid:5)≡, we first create the D-graph and P -graph and then recursively createa tree by decomposing the vertex set into dominance-connected components and extracting free sets as roots.Fig. 6 shows the algorithm, which consists of two procedures, Solve and Solve_con. We abuse notation and denotea partial tree description (V , C) simply by C. Initially, for a given instance C, we call Solve(C), which partitionsthe variable set into the strongly connected components of P -graph. If the P -graph of C is strongly connected, theprocedure Solve_con can be applied to C. The algorithm contains a statement choose, that influences which free setof nodes is selected for the solution. We discuss the issue of how to find such a free set in the running-time analysisbelow.Proposition 5. The algorithm Solve of Fig. 6 decides satisfiability of a given partial tree description (V , C) in timeO(|V ||C|).Proof. In Solve, the strongly connected components of the precedence graph of C can be computed in linear time inthe input size. We then call the procedure Solve_con on the strongly connected components. If it returns “problemhas no solution”, the constraints were unsatisfiable by Proposition 3. Otherwise, Proposition 4 guarantees that we canconstruct a solution by selecting a free set as root. Because of (C1), a free set must be the union of strongly connectedcomponents of the D-graph into which no D-arcs enter. Any strongly connected component contained in a free set isa free set as well. These strongly connected components can easily be found by depth-first search in time O(n + m).The strongly connected components are computed at each level of the recursion. Since we take out at least onevertex in each call of Solve_con, and since in all calls of Solve_con (except possibly the first call) n is in O(m), theoverall running time is in O(nm). (cid:2)8. Conclusion and outlookWe presented an efficient algorithm that decides whether a partial tree description is consistent; if this is the case,the algorithm constructs a solution. This solves an open problem by Cornell, who introduced these tree descriptionsin computational linguistics [13]. The consistency test and construction of one solution can be done in quadratic timein the input size.We would like to conclude with a series of open problems for future research that are motivated in the variousrelated areas mentioned in Section 3.– As mentioned in Section 3, the consistency problem for partial tree descriptions can be formulated as a constraintsatisfaction problem for an ω-categorical template Λ. For ω-categorical templates, the universal-algebraic ap-proach applies, and in particular it can be shown that the complexity of CSP(Λ) is captured by the polymorphism196M. Bodirsky, M. Kutz / Artificial Intelligence 171 (2007) 185–196clone of Λ. The open problems in this context are: 1) Describe the polymorphism clone of Λ. 2) What are thepolymorphism responsible for the tractability of CSP(Λ)? An answer to these questions would give us descrip-tions of constraint languages with higher-ary constraints (all constraints considered in this article were binary)that can still be solved in polynomial time.– In Section 3, we pointed to two different notions of compatibility of phylogenetic trees that were studied in theliterature. Only for one of them we described how it can be modeled with partial tree descriptions. Is it possibleto come up with a tree-description language that allows to model the common-supertree problem for the othernotion of compatibility that was used by [24]?– The known algorithms for the tractable fragments of Allen’s Interval Algebra are all based on local-consistencytechniques. Is it possible to find algorithms with better running times for these fragments, using the algorithmictechniques developed in this article? In particular, can we avoid local consistency techniques, similarly to thealgorithm presented here?AcknowledgementsWe would like to thank Pierre Flener for drawing our attention to the notion of compatibility of trees used in [24].References[1] J.F. Allen, Maintaining knowledge about temporal intervals, Communications of the ACM 26 (11) (1983) 832–843.[2] R. Backofen, J. Rogers, K. Vijay-Shanker, A first-order axiomatization of the theory of finite trees, Journal of Logic, Language, and Informa-tion 4 (1995) 5–39.[3] M. Bodirsky, Constraint satisfaction with infinite domains, Dissertation, Humboldt-Universität zu Berlin, 2004.[4] M. Bodirsky, M. Kutz, Pure dominance constraints, in: Proceedings of the 19th Annual Symposium on Theoretical Aspects of ComputerScience (STACS’02), in: Lecture Notes in Computer Science, vol. 2285, Antibes, Juan le Pins, Springer, Berlin, 2002, pp. 287–298.[5] M. Bodirsky, J. Nešetˇril, Constraint satisfaction with countable homogeneous templates, in: Proceedings of Computer Science Logic (CSL’03),Vienna, 2003, pp. 44–57.[6] M. Bodirsky, J. Nešetˇril, Constraint satisfaction with countable homogeneous templates, Journal of Logic and Computation 16 (3) (2006)359–373.[7] D. Bryant, Building trees, hunting for trees, and comparing trees, PhD thesis at the University of Canterbury, 1997.[8] A. Bulatov, P. Jeavons, A. Krokhin, The complexity of constraint satisfaction: An algebraic approach, in: Structural Theory of Automata,Semigroups and Universal Algebra, Montreal, 2003, NATO Science Series II: Mathematics, Physics, Chemistry 207 (2005) 181–213.[9] A. Bulatov, A. Krokhin, P.G. Jeavons, Classifying the complexity of constraints using finite algebras, SIAM Journal on Computing 34 (2005)720–742.[10] H.-J. Bürckert, B. Nebel, Reasoning about temporal relations: A maximal tractable subclass of Allen’s interval algebra, Journal of theACM 42 (1) (1995) 43–66.[11] P.J. Cameron, Oligomorphic Permutation Groups, Cambridge University Press, Cambridge, 1990.[12] S. Comer, A remark on chromatic polygroups, Congressus Numerantium (1983) 85.[13] T. Cornell, On determining the consistency of partial descriptions of trees, in: 32nd Annual Meeting of the ACL (ACL’94), 1994, pp. 163–170.[14] R. Dechter, P. van Beek, Local and global relational consistency, Journal of Theoretical Computer Science 173 (1) (1997) 283–308.[15] D. Duchier, S. Thater, Parsing with tree descriptions: A constraint-based approach, in: Sixth International Workshop on Natural LanguageUnderstanding and Logic Programming (NLULP’99), 1999, pp. 17–32.[16] I. Düntsch, Relation algebras and their application in temporal and spatial reasoning, Artificial Intelligence Review 23 (2005) 315–357.[17] M. Egg, A. Koller, J. Niehren, The constraint language for lambda structures, Journal of Logic, Language, and Information 10 (2001) 457–485.[18] T. Feder, M. Vardi, The computational structure of monotone monadic SNP and constraint satisfaction: A study through Datalog and grouptheory, SIAM Journal on Computing 28 (1999) 57–104.[19] E.C. Freuder, A sufficient condition for backtrack-free search, Journal of the ACM 29 (1) (1982) 24–32.[20] D. Gusfield, Algorithms on Strings, Trees, and Sequences, Computer Science and Computational Biology, Cambridge University Press, NewYork, 1997.[21] R. Hirsch, Expressive power and complexity in algebraic logic, Journal of Logic and Computation 7 (3) (1997) 309–351.[22] P. Jeavons, P. Jonsson, A.A. Krokhin, Reasoning about temporal relations: The tractable subalgebras of Allen’s interval algebra, Journal of theACM 50 (5) (2003) 591–640.[23] M.P. Marcus, D. Hindle, M.M. Fleck, D-theory: Talking about talking about trees, in: Proceedings of the 21st Annual Meeting of the ACL(ACL’83), 1983, pp. 129–136.[24] M.P. Ng, M. Steel, N.C. Wormald, The difficulty of constructing a leaf-labelled tree including or avoiding given subtrees, Discrete AppliedMathematics 98 (2000) 227–235.[25] M. Pinkal, Radical underspecification, in: Proceedings of the 10th Amsterdam Colloquium, 1996, pp. 587–606.[26] J. Rogers, V. Shanker, Reasoning with descriptions of trees, in: Proceedings of the 30th Meeting of the ACL (ACL’92), 1992, pp. 72–80.[27] M. Steel, The complexity of reconstructing trees from qualitative characters and subtrees, Journal of Classification 9 (1992) 91–116.