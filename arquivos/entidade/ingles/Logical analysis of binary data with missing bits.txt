E L S E V I E R Artificial Intelligence 107 (1999) 219-263 Artificial Intelligence Logical analysis of binary data with missing bits Endre Boros a, l, Toshihide Ibaraki b,*, Kazuhisa Makino c,2 a RUTCOR, Rutgers University, 640 Bartholomew Road, Piscataway, NJ 08854-8003, USA b Department of Applied Mathematics and Physicw, Graduate School ofb~grmatics, Kyoto UniversiO; Kyoto 606-8501, Japan c Department of Systems and Human Science, Graduate School of Engineering Science, Osaka Universi~, Toyonaka, Osaka 560-8531, Japan Received 21 November 1997 Abstract We model a given pair of sets of positive and negative examples, each of which ma~ contain missing components.as a partially defined Boolean function with missing bits (pBmb) (T, F), where T c {0, 1, ,}n and F c {0, 1, .}n, and "*" stands for a missing bit. Then we consider the problem of establishing a Boolean function (an extension) f : { 0 ,  1} n ~ {0, l}belonging to a given function class C, such that f is true (respectively, false) for every vector in T (respectively, in F). This is a fundamental problem, encountered in many areas such as learning theory, pattern recognition, example-based knowledge bases, logical analysis of data, knowledge discovery and data mining. In this paper, depending upon how to deal with missing bits, we formulate three types of extensions called robust, consistent and most robust extensions, for various classes of Boolean functions such as general, positive, Horn, threshold, decomposable and k-DNF. The complexity of the associated problems are then clarified; some of them are solvable in polynomial time while the others are NP- hard. © 1999 Elsevier Science B.V. All rights reserved. Keywords: Knowledge discovery; Data mining; Logical analysis of data; Boolean functions; Partially defined Boolean functions; Missing bits; NP-hardness This research was partially supported by ONR (Grants N00014-92-J-1375 and N00014-92-J-4083), and the Scientific Grants in Aid by the Ministry of Education, Science, Sports and Culture of Japan. The visit of the first author to Kyoto University was made possible by the grant (06044112) of the Ministry of Education, Science, Sports and Culture of Japan. * Corresponding author. Emaih ibaraki@kuamp.kyoto-u.ac.jp. 1 Emalh boros@rutcor.rutgers.edu. 2 Email: makino@sys.es.osaka-u.ac.jp. 0004-3702/99/$ - see fi'ont matter © 1999 Elsevier Science B.V. All rights reserved. PII: S0004-3702(98)001 10-6 220 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 1. Introduction In analyzing data of some phenomena from a logical viewpoint, we often encounter the following problem: Given a pair of data sets (T, F) of "positive" and "negative" examples, where T, F c {0, 1 }n, establish a Boolean function (extension) f in a specified function class C, such that f is true (respectively, false) for every vector in T (respectively, in F). A pair of sets (T, F) is called a partially d~ned Boolean function (pdBJ). For instance, a data vector x may represent the symptoms to diagnose a disease, e.g., xl denotes whether temperature is high (xj = 1) or not (Xl ----- 0), and x2 denotes whether blood pressure is high (x2 = 1) or not (x2 = 0), etc. Establishing an extension f , which is consistent with the given data set.. then amounts to finding its logical diagnostic explanation. This type of problems is studied, for example, in learning theory (e.g., 3,32,38), where it is called the consistency problem. In the process of learning, it is fundamental to find an extension of the current set of data (T, F). The learner tries to find an extension of small (i.e., polynomial) size as it leads to interesting theoretical consequences 7. In pattern recognition, a function separating two categories of data T and F is usually called a discriminant function (e.g., 28). If the data are binary, this is essentially the same as an extension of a pdBf (T, F). In example-based knowledge bases, we encounter a similar problem of establishing an extension, but in this case it is usually asked to describe the extension by rules. Finding extensions is also one of the main goals in such areas as data analysis, knowledge acquisition, knowledge discovery and data mining (e.g., 1,9,16,17, 34), which are recently receiving increasing attention. In many of the above applications, some knowledge or hypothesis about the extension f is usually available beforehand. Such knowledge may be obtained from experience or from the analysis of mechanisms that may or may not cause the phenomena under consideration. In the above example of diagnosing diseases, it would be natural to assume that we somehow know the direction of each variable that tends to cause the disease to appear. By changing the polarities of variables if necessary, therefore, the extension f(x) can be assumed to be positive (i.e., monotone increasing) in all variables. As the above observation is essential, we consider in this paper to find an extension f that belongs to a specified class of functions C. The classes of functions considered in this paper include general, positive (or monotone), Horn, threshold, decomposable and k-DNE The class of positive functions may be the most natural special class to investigate in this respect. Horn functions are important in the sense that the satisfiability problem of Horn CNF (conjunctive normal form) can be solved in polynomial time 4,19, and, for this reason, logic programs and expert systems are often built on Horn rules. If an extension is Horn, its true set (or false set, depending on the definition) can be described by a f Horn CNE Threshold functions 30 have all appealing geometrical interpretation of linear separation, and hence is a major tool to describe discriminant functions used in pattern recognition (e.g., 28). Decomposable functions 5,8,35 are important because they can provide us additional information regarding the hierarchical structure underlying the given data sets. Finally the class of k-DNF should also be included in the list, since DNF is a standard form of representation of Boolean functions. The prime implicants in DNF of an E. Boros et al. / Artificial Intelligence 107 (1999) 219-263 221 extension are also called "association rules" in data mining (e.g.,  1,29), and "patterns" in papers on logical analysis of data 16 and its applications 10. Unfortunately, real-world data might not be complete, adding another dimension of complication. In other words, the values of some elements xj in a given data vector x may not be available for various reasons, such as the test to measure the xj was not conducted because it takes too much time or is expensive, or the data bits are simply lost. Therefore, it is indispensable to admit incomplete data in order to be usable in practical applications. We denote the missing bits by "*" in this paper. A set of data (T, F), which includes missing bits, is called a partially defined Boolean function with missing bits (pBmb), where T c_ {0, 1, .}n (respectively, P c_ {0, 1, .}n) denotes the set of "positive examples" (respectively, "negative examples"). We introduce in this paper three types of extensions of a pBmb (T, F), called robust, consistent and most robust extensions, depending upon how we deal with the missing is called (i) a robust bits. More precisely, given.a pBmb (T, F), a Boolean function f extension if for every fi ~ T (respectively, fi c/~), any 0-1 vector a obtained from fi by fixing its missing bits arbitrarily satisfies .f(a) = 1 (respectively, f ( a )  = 0). It is called (ii) a consistent extension if for every fi 6 T (respectively, fi 6 F), there exists a 0-1 vector a obtained from ~ by fixing its missing bits appropriately, for which f ( a )  = 1 (respectively, f ( a )  = 0) holds. Finally, f is called (iii) a rnost robust extension if it is a robust extension of the pBmb (T', F I) obtained from (T, F) by fixing a smallest set of missing bits appropriately (the remaining missing bits in T / U F ~ are assumed to take arbitrary values). All of these extensions provide logical explanations of a given pBmb (T, F) with varied freedom given to the missing bits i,,n T and F. Let us remark that by definition,if f ~ C is a most robust extension of (T, F), then it is also consistent; furthermore, if (T, F) has a robust extension in a class C, then it also has a most robust one (and hence a consistent one, too). Let us add that the process of finding consistent and most robust extensions will also provide us with conditions on the values of missing bits, required for (T, F) to have a consistent extension in the given class C. This type of information can also be useful in analyzing incomplete data sets. In the above example of diagnosing diseases, not all medical tests are usually performed on each patient, because the tests may be painful, expensive or even dangerous. Such attributes thus naturally become missing. In this case, a robust extension provides very useful information, if it exists, since it is a diagnostic explanation of the disease under consideration regardless of the interpretation of the missing bits. That is, it says that the current data set carries enough information to derive a meaningful explanation. It may happen, however, that the data set has no robust extension. Even in this case, there may be an extension if we can supply correct interpretation of all or part of the missing bits; such an extension may help or even improve diagnostic procedures. This leads to the concepts of consistent and most robust extensions. The most robust extension is important in practice as it minimizes the number of "corrected" bits in order to have an extension. There are other possible treatments of missing bits appearing in the context of learning theory (see, e.g., 6,18,23,25,36,37,39). In this paper, we study the problems of deciding the existence of these extensions for various special classes of Boolean functions C, mainly from the viewpoint of their 222 E. Boros et al. / Artificial Intelligence 107 (1999) 219-263 computational complexity. We obtain computationally efficient algorithms in some cases, and prove NP-hardness in some other cases. For all the cases with efficient algorithms, we also provide efficient algorithms to construct the corresponding extensions. It should also be interesting to note that all such extensions are short (i.e., of linear size of input length). For a summary of the results obtained, see Tables 1 and 2 in the last section. A part of these results was already presented in  13,14, and a more comprehensive discussion can be found in the technical report  12. 2. Preliminaries 2.1. Boolean functions A Boolean function, or a function in short, is a mapping f : ~n ~ ~, where ll~ = {0, 1 }, is called a Boolean vector (or a vector in short). If f ( x )  ----- 1 (respectively, 0), and x 6 (cid:127)n then x is a true (respectively, false) vector of f .  The set of all true (respectively, false) vectors is denoted by T ( f ) (respectively, F ( f ) ) .  Two special functions with T ( f )  = 0 and F ( f )  = 0 are, respectively, denoted by f -- __ and f = T. For two functions f and g on the same set of variables, we write f ~< g if f ( x )  ----- 1 implies g(x) = 1 for all x c B n, and we write f < g if f ~< g and f :fi g. A function f is called positive if x ~<~ y (i.e., xi <<, Yi for all i 6 {1,2 . . . . .  n}) always implies f ( x )  <~ f ( y ) .  A positive function is also called monotone. The variables Xl, x2 . . . . .  xn and their complements ~1, x2 . . . . .  Yen are called literals. A term is a conjunction of literals such that at most one o f x i  and xi appears for each i. The constant 1 (viewed as the conjunction of an empty set of literals) is also considered as a term. A disjunctive normal form (DNF) is a disjunction of terms. Clearly, a DNF defines a function, and it is well known that every function can be represented by a DNF (however, such a representation may not be unique). Throughout this paper, unless otherwise stated, we usually do not distinguish a DNF q9 from the function it represents. It is well known that a Boolean function f is positive if and only if f can be represented by a DNF, in which all the literals in each of the terms are uncomplemented. We shall call f a k-DNF if it has a D N F with at most k literals in each term, and it will be called Horn if it has a DNF with at most one complemented literal in each term. Let us denote, respectively, by Can, C +, C~-DNF, C~_DN v and Cnorn the classes of all, positive, k-DNF, positive k-DNF and Horn Boolean functions. Note that, when we say k-DNF, k is considered to be general (i.e., it is a parameter included in the problem specification). However, since the problems may become easier to solve if k is fixed, we shall also investigate the cases of fixed k extensively. + A function f for which there exist n + 1 real numbers wj, w2 . . . . .  wn and t such that: f(x)---- 1, 0, if~_,wixi >/t, i f ~ w i x i < t (1) is called threshold. Let us denote by CTH the family of threshold Boolean functions. It is known (see, e.g., 30) that a threshold function f can equivalently be defined as f ( x ) _  1, 0, I if E w~xi ~ t', i f ~ w ~ x i  ~< t ' -  1 (2) E. Boros et al./Artificial Intelligence 107 (1999) 219-263 223 for some (other) real numbers w 1, 11)2 . . . . . definition (2) instead of (1), in order to simplify the presentation of some of the proofs. ' and t ~. In this paper, we shall employ tOn ~ ' Let V = {1, 2 . . . . .  n} denote the index set of variables. For a vector x 6 ~n and S c V, x S denotes the projection of x on S. To simplify notation, for a Boolean function h depending only on variables of S c_ V, we write h (S) instead of h (x IS). For given Si c_ V, i = 0, 1 . . . . .  k, a function f is called G(So, G(SI), G(S2) . . . . .  G(Sk))-decomposable (see, e.g., 5,8,27,35), where G stands for the general Boolean functions, if there exist Boolean functions h l . . . . .  hk and g satisfying the following three conditions: (i) hi depends only on variables in Si, i = 1 . . . . .  k, (ii) g depends on the variables in So and on the binary values h i ( S i )  for i = 1 . . . . .  k, (i.e., g :  {0, 1} Is°l+k ~ {0, 1}), (iii) f = g(So, hi(S1 ), h2($2) . . . . .  hk (Sk)). Let us note that So, Sl . . . . .  Sk are not necessarily assumed to be disjoint. Also, for given is called positive G(So, G(SI), G(S2) . . . . .  G(Sk))- Si _c V, i = 0, 1 . . . . .  k, a function f decomposable if f is G(So, G ($1), G ($2) . . . . .  G(Sk))-decomposable, and the functions g and hi, i = 1,2 . . . . .  k, are all positive. Let us denote by CG~So,G(Sp) and CG(so,G(Sp) the families of G(So, G(S1))-decomposable and positive G(S0, G(Sj))-decomposable functions, respectively. + 2.2. Partially defined Boolean functions and their extensions A partially defined Boolean function (pdB~ is defined by a pair of sets (T, F) such is called an extension of the pdBf (T, F) if T c T ( f )  and that T, F c ~n. A function f F c_ F ( f ) .  We shall also say in this case that the function f correctly classifies all the vectors a c T and b 6 F. Evidently, the disjoinlness of the sets T and F is a necessary and sufficient condition for the existence of an extension. It may not be evident, however, how to find out whether a given pdBf has a extension that belongs to a class of functions C. Therefore, we have extensively studied the following problems in 11. (As noted in Section 1, the first problem is called the consistency problem in learning theory, and some results obtained therein (e.g., 32) overlap with those in 11.) Problem EXTENSION(C) Input: a pdBf (T, F), where T, F _ ~n. Question: Is there an extension f c C of (T, F)? Problem BEST-FIT(C) Input: a pdBf (T, F), where T, F c__ ~n, and a weight function w : T U F ~ K+ (nonnegative reals). Output: Subsets T* and F* such that T* n F* = 13 and T* U F* = T U F, for which the pdBf (T*, F*) has an extension in C, and w(T N F*) + w ( F N T*) is minimum. We denote the minimum weight sum of erroneously classified vectors by a best-fit extension of (T, F) as ~(T, F) = min{w(T n F*) + w(F N T*)}. (3) 224 E. Boros et al. /Artificial .Intelligence 107 (1999) 219-263 As a p d B f does not allow missing bits, we shall introduce the set 1~ = {0, 1 , . } , and interpret the asterisk components * of v E 1~ n as missing bits. For a vector v E 1VII n, let O N ( v ) ~ { j  I vj = 1, j..= 1,2 . . . . .  n} and OFF(v) = {j f vj = 0 , j = 1,2 . . . . .  n}. F o r a subset S c 1~ n, letAS(S) = {Iv, j) Iv E S, j ~ V \ (ON(v) U OFF(v))} be the collection of all missing bits of the vectors in S. If S is a singleton {v}, we also denote AS({v}) as AS(v). Clearly, ~n c l~lI n, and v E ~n holds if and only if AS(v) = 0. Let us consider a binary assignment ot E ~ Q  to a subset Q c AS('S) o f the missing bits. Then v '~ denotes the vector obtained from v by replacing the • components which belong to Q by the binary values assigned by or, i.e., / Vj ot vj = l a i r ,  j) if IV, j )  ¢ Q, i f ( v , j )  e Q , and S~ denotes {v~J v E 7}. For example, S = {u = ( 1 , . ,  0, 1), v = (0, 1, *, . ) ,  w = (1, 1 , . ,  0)} has AS(S) = {(u, 2), Iv, 3), Iv, 4), (w, 3)}. If Q = {(u, 2), Iv, 4)}, an assign- ment ( o e ( u , 2 ) , c ~ ( v , 4 ) ) =  (1,0) yields S ~ =  {uC~= (1, 1,0, 1), vc~ = (0, 1 , , , 0 ) , w a  = (1, l , . ,  0)}. For vectors v, w E 1V~ n, we shall write v~w> (respectively, v ~< w) if there exists an assignment a E ~AS(Iv,w}) for which v ~ ~.> w a (respectively, v ~ ~< w a) holds, and we say that v is potentially greater (respectively, smaller) than w. If both v~w~ and v ~~ w hold then we write v ~ w, and say that v is potentially identical with w. Note that v --~ w holds if and only if there is an assignment o t ~  AS({v, w}) such that v c' = w c'. For example, v = (1,0, , ,  1, *) and w = (0, 0, 0, 1, . )  satisfy v ~  w, and v' = (*, 0, 1, *, 1) and w' = (1,0, *, *, 1) satisfy v' ~ w'. <2 A pdBf with missing bits (or in short pBmb) is a.pair IT, F ) ,  where T, F __c 1~ n. To a p B m b  IT, F )  we always associate the set AS --= AS(T U F) of its missingbits. For a p B m b IT, F )  and an assignment ot 6 ~AS let (T~,/7'~) be the pdBf defined by T '~ = {a a I a ~ T} and/7~ = {b a I b E F}. Let us call a function f a robust extension of the pBmb (T, F )  if f ( a ~) = 1 and f(b ~) = 0 for all a E T, b E / 7  and for all a ~ ~AS. We first consider the problem o f deciding the existence of a robust extension of a given pBmb (T, F )  in a specified class C. Problem RE(C) Input: A p B m b  IT, FQ, where T, F ___ NI ~. Question: Does IT, F )  have a robust extension in class C? In case of YES, a robust extension f 6 C must also be provided, either by a direct algebraic form, or by a polynomial time membership oracle. (A membership oracle for a function f is an algorithm that returns the value f(v) for any given vector v E II~ ~ .) Note that a vector a 6 NI n can be seen as a subhypercube {a ~ I c~ E ASIa)} of I3 n. Therefore, a robust extension can be r e g a r d e d a s  an extension of two sets o f hypercnbes T a n d / 7 . It may happen that a pBmb IT, F )  has no robust extension in C, but it has an extension is called if we change some (or all) the • bits to appropriate binary values. A function f E. Boros et al. / Artificial Intelligence 107 (1999) 219-263 225 a consistent extension of pBmb (T, F), if there exists an assignment ~ 6 ~AS such that f(a ~) = 1 and f(b ~) = 0 for all a 6 T and b 6/~. In other words, a pBmb (T, F) is said to have a consistent extension in C if, for some assignment c~ 6 B As, the pdBf (T'~, Fa) has an extension in C. Problem CE(C) Input: A pBmb (T_ F), where T, F _ 1V~ n. Question: Does (T, F) have a consistent extension in class C? In case of YES, an assignment t~ 6 ~AS, for which the pdBf (T'~, F~) has an extension in C, together with such an extension f 6 C, must also be provided. Let us finally consider the case in which there is a consistent extension of the considered pBmb in the specified class, but for which not all missing bits should necessarily be specified. Let us call an assignment tr 6 B Q for a subset Q c AS a robust assignment (with respect to a class C) if the resulting pBmb (T ~ , F ~) has a robust extension in class C. We are interested in finding such a robust assignment with the smallest size I Q I. Such an extension will be called a most robust extension of the given pBmb (T, F) in the class C. N Problem MRE(C) Input: A pBmb ( T , F ) ,  where T, F c 1VE n. Output: NO if (T, F) does not have a consistent extension in class C; otherwise a robust assignment t~ 6 ~Q for a subset Q c AS, which minimizes I a l . Similarly to the previous problems, if (T, F )  has a consistent extension in class C, a most robust extension f E C of the pBmb (T '~, F '~) must also be provided. Let us denote the minimum size of Q c AS having a robust assignment by p(C; (T,/~)) = min QCAS :10tE~ Q s.t. (~ct,/~a) has a robust extension in C IQI, (4) where p(C; (T,/~)) ----- +o~ if there is no Q satisfying the stated condition. To simplify notation, we shall use sometimes p(T, F) in place of p(C; (T, F)), unless confusion arises. Observe that a pBmb (T, F) has a robust extension if and only if p(T, F) = 0, and it has a consistent extension if and only if p(T, F) <<. IAS. N ~ ~ It follows therefore that if RE(C) or CE(C) are NP-hard, then MRE(C) is NP-hard, and conversely, if MRE(C) is solvable in polynomial time, then both RE(C) and CE(C) are polynomially solvable. It seems also that RE(C) is, in general, easier thanCE(C), since RE(C) can be seen as the extension problem of sets of hypercubes T and F. Let us also note that, if AS = (3 (i.e., (T, F) is a pdBf), then the notions of extension, robust extension and consistent extension all coincide. Thus, RE(C) and CE(C) are both at least as difficult as EXTENSION(C). As we shall see in this paper that many of the above problems for various classes are NP-hard, we also extensively consider the following case: IAS(a)L <~ k for all a 6 T U F, (5) where k is a positive constant. This is important because such constraints may often be met in real situations if the number of missing bits in the data is relatively small, and the 226 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 problems then tend to become easier. For example, many of the data sets which appear in the Machine Learning Repository of the Computer Science Department of the University of California at Irvine 31 satisfy the above condition with a small constant k. Note that, in this case, the complexity ofRE(C) is polynomially equivalent to that of EXTENSION(C). This is because a pBmb (T, F) has a robust extension if and only if the pdBf (T', F ' ) has an extension in C, where T' (respectively, F') is obtained by expanding each a c T (respectively, /~) by assigning all possible ~ c IB As(a) to the missing bits in a, and the size of (T', F )  is at most 2k-times the size of (T, F). Furthermore, we shall show that, for several classes C, if k - 1 in (5), then the problem is tractable, but becomes intractable (unless P=NP) if k ~> 2 holds; i.e., k = 1 is a critical value of the problem. In fact, all the problems considered in this paper has either no critical value or a critical value of k = 1. In this paper, we consider all function classes C defined in Section 2.1. Further interesting classes, such as regular, unate, renamable Horn, dual-minor, dual-major, self- dual, read-once and h-term k-DNFs are discussed in 12. 3. Problems RE and CE In this section, we study the decision problems CE(C) and RE(C) for various classes of functions C. Let us point out first that a basic difference between these two problems is in the verification of a positive answer. On one hand, it is easy to see that problem CE(C) belongs to NP, whenever problem EXTENSION(C) is in NP. Namely, a pBmb (T, F) has a consistent extension if the pdBf (T a, F a) has an extension in C for only one assignment a E It~ As, and this can be accomplished in nondeterministic polynomial time by the assumption that EXTENSION(C) belongs to NP. On the other hand, problem RE(C) may not belong to NP, due to the condition "for all c~ c I~ As'' which a robust extension f must satisfy. For example, if f 6 C is a robust extension of a pBmb (T, F), and a 6 T, then checking the equation f ( a ~) = 1 for all c~ ~ B As(a) may amount to a tautology problem in those variables xj with (a, j )  ~ AS(a). In fact, we shall see later that RE(C) is co-NP- complete for some classes C. After summarizing implications of EXTENSION(C) in the next subsection, we consider problems RE(C) and CE(C) for respective classes C in the subsequent subsections. 3.1. Implications by problem EXTENSION Let us observe that, as mentioned earlier, EXTENSION(C) is a special case of both RE(C) and CE(C). Hence we have the following theorem. Theorem 1. If problem EXTENSION(C) is NP-complete, then problem CE(C) is NP- complete, and problem RE(C) is NP-hard. The slight difference between the conclusions for CE(C) and RE(C) comes from the fact that problem RE(C) may not belong to class NP, as we pointed out it earlier. We immediately have the following corollary from the results of 11. E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 227 Corollary 1. Problem CE(C) is NP-complete and problem RE(C) is NP-hard f o r  the classes of k-DNFfimctions and positive k - D N F functions. We also can derive the following positive result. Theorem 2. If problem EXTENSION(C) can be solved in pol)znomial time, then problem RE(C) is also polynomially solvable f o r  pBmb instances (T, F) satis~'ing AS(a)I = O(logn) f o r  all a c T U F, where T, F c_ NI n. Proof. It follows from the definition that a pBmb (T, F) has a robust extension in C if and only if the pdBf (T I, F') has an extension in C, where T ~ and F t are defined by T' = {a ~ l a e T, ot E wAS(a)}, F' = {b c~ I b ~ F, ct c wAS(b)}. (6) (7) Since IT'D + IF'I = O(n(ITt + IFI)) holds by IaS(a)l = O(logn) for all a c T U/~, the polynomiality of EXTENSION(C) then implies the polynomiality of RE(C). C o r o l l a r y 2. Let a pBmb (T, F) satisfy aS(a)l = O(logn) f o r  all a ~ T U F, where T, F c M n. For such instances problem RE(C) can be solved in polynomial time, if C is one of the following classes: (1)general, (2)positive, (3)Horn, (4)threshold, (5) (positive) g(So, hi(S1 ))-decomposable, and (6) (positive) k-DNF with fixed k. Proof. Combine Theorem 2 and the results in  11 . 3.2. General extensions Let us consider problems RE and CE for the class Call of all Boolean functions. We shall start with an easy result. Theorem 3. Problem RE(Call) can be solved in polynomial time. Proof. It is easy to see that a pBmb (T, F) has a robust extension if and only if for each ot ~ A S ( T )  and for each/3 6 A S ( F )  the sets of b~nary vectors T~ and F~ are disjoint, in other words, if and only if for every pair of a 6 T and b 6 / ~  there exists an index j such that aj 7 & bj and {aj, bj = 0, 1} (i.e., either aj = 0 and bj = 1, or aj = 1 and bj ---- 0). Obviously, this condition can be checked in O(nlTl FI) time. Let us turn to problem CE(CalI). Observation 1. If IAS(a )  > 0 holds f o r all a ~ T U F, then ( T, F) always has a consistent extension f . In other words, problem CE(Can) can be trivially solved. Proof. Let us consider an assignment ot 6 I~ As such that ON(a c~)  is odd for all a 6 T, and ON(bC~) is even for all b ~ F. (Since every vector contains at least one missing bit, we  228 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 have such an assignment or.) Let f be the parity function, i.e., for which f ( v )  = 1 if and only if ON(v)l is odd. Then f is clearly a consistent extension of (T, F). Problem CE(Catt) becomes more complicated when not all input vectors have missing bits, although it remains polynomially solvable if each input vector contains at most one missing bit. T h e o r e m  4. Problem CE(CaH) can be solved in polynomial time for a pBmb (T, F) for which ever)" a ~ T U F satisfies IAS(a) <<. 1. Proof. By definition, (T, F) has a consistent extension if and only if there exists an ~ ~AS such that ~c~ fq ff,~ = 0. The latter condition is broken into the following two cases. For every pair of a c T and b c F, (i) if a, b E ~n (i.e., a, b contain no missing bits), then a # b must hold, and (ii) if either a or b (or both) contains a missing bit and a ~ b, then a c' # b '~ must hold. Condition (i) is easy to check, and (ii) can be turned into a set of quadratic Boolean equations for a ~ ~AS, which will be explained below. Let Ja denote the index of the • in each vector a c T U F (i.e., AS(a) = {(a, jo)}), if any. Then (ii) can equivalently be formulated as the existence of an assignment ot 6 ~AS satisfying the conditions or(a, j,,) # bj, ¢x(b, jh) # a jb or(a, j . )  # b j. or or(b, jb) # ajb if IAS(a)I = 1 and AS(b ) = 0, if AS(a) = 0 and IAS(b) = 1, if IAS(a)I = 1, IAS(b)l -- 1 and ja # jb, ~(a, ja) # or(b, jb) if IAS(a)I = l, IAS(b)I = 1 and j ,  = jb, (8) (9) (10) (1 1) for everj¢ pair of a c T and b E F with a ~ b. Obviously, condition (i) can be checked in O(nLTIIF) time. To check (ii), let us observe that each of the conditions (8)-(l 1) can equivalently be represented as clauses in the variables et(v, j )  for (v, j )  c AS. Namely, (8) and (9) can be represented by unit (or linear) clauses, (10) by a clause containing two variables, and (11) by the conjunction of two clauses, each of which contains two variables. For example, (11) is equivalent with the condition 1 = (or(a, ja) v or(b, jb))(ot(a, ja) V or(b, jb) )" In total, we have a 2-SAT problem containing at most 2 T I F clauses, which is solvable in time linear in its input size (see, e.g., 4). This shows that problem CE(Call) can be solved i n O ( n l T F ) time. N Example 1. Consider T,/~ c {0, 1} 3 such that a (l) = (1, 1 , , ) = a (z) = (0, 0, 1) a (3) = (0, 1, , ) a (4) .---_ (,, 0, 0) b (1) = (1, 1, 1) b (2) = ( 0 , . ,  1) b (3) = (*, 0, 0)  E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 229 Then we have the following 2-SAT: ot(a (1), 3)ff(b (2), 2)(or (a (3) , 3) v o~(b (2), 2)) (ot(a (4), 1) v ot(b (3) , 1)) (ot(a (4), 1 ) v o t ( b (3), 1)) =-- 1. For this equation, the assignment c~ 6 I~ As given by ot(a (l~, 3) = ot(a (3), 3) = ot(a (4), 1) ---= 0 and ot(b (2), 2) = ot(b (3), 1) = 1, is a satisfying solution. In general, however, we have the following negative result. Theorem 5. Problem CE (Call) is NP-complete, even if IAS( a )  ~< 2 holds for all a ~ T U F. The highly technical proof is included in Appendix A. 3.3. Positive extensions Let us consider subclasses of positive functions C __c C +. We shall see that all the cases of positive functions unresolved in Section 3.1 can be derived from the results about EXTENSION in 1 1 with the help of the following lemmas. Recall that a 6 M ~ (i.e., the set {a ~ I~ E AS(a)}) represents a subhypercube of It~ n . The following two lemmas show that (T, F) has a robust extension f in C _ C + if and only if f classifies the bottom element of each a E T and the top element of each b 6 F into 1 and 0, respectively, and that (T, F) has a consistent extension f in C ___ C + if and only if f classifies the top element of each a E T and the bottom element of each b 6 F into 1 and 0, respectively. L e m m a  1. Consider a class of functions C c C +. For a pBmb (7, F), let us associate a pdBf ( T - ,  F + ) by defining T - : { a O l a E T } , F + = { b l l b E F } , where 0 E B As(v) (respectively 1 E Baslv)) denotes the assignment of O's (respectively l's) to all (v, i) ~ AS(v). Then, the pBmb (T, F) has a robust extension in the class C if and only if the pdBf ( T - ,  F +) has an extension in class C. Proof. Let us assume first that the pBmb (T, F) has a robust extension f 6 C. Then, by definition, f is an extension of the pdBf ( T - ,  F + ) .  For the converse direction, let us assume that the pdBf ( T - ,  F +) has an extension g in class C. For any assignment fl E (cid:127)AS and a E T, the vector a ° 6 T -  satisfies a ° ~< a ~, and hence g ( J )  = 1 is implied by g(a ~) >~ g(a °) = 1. Similarly, for any assignment fl ~ I~ AS and b E /~, the vector b I E F + satisfies b 1 ~> b ~, and hence g(b ~) = 0 follows analogously. Therefore, g is a robust extension of the pBmb (T, F) in the class C. L e m m a  2. Consider a class of functions C c_ C +. For a pBmb (T, F), let us associate the pdBf (T +, F - )  defined by T + = { a ' I a E T } , F - = I b ° I b E F } .  230 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 Then, the pBmb (T, F) has a consistent extension in the class C if and only if the pdBf (T +, F - )  has an extension in the same class. Proof. Let us assume first that the pBmb (T, F) has a consistent extension f 6 C, i.e., that there exists an assignment fl c B As such that f is an extension of the pdBf (T~, F~). Since C ___ C +, for any a 6 T (respectively, b ~ F), f ( a ~) = 1 (respectively, f ( b ~) = 0) implies f ( a  l) = 1 (respectively, f ( b O) = 0) by a t~ ~< a ! (respectively, b ~ ~> b°). This implies that f is also an extension of the pdBf (T +, F - ) .  The converse direction is immediate, since (T +, F - )  = (T", F~) for the assignment o~ ~ B AS defined by ~e(v, i) = 1 if v 6 T, (v, i) c AS(v), and c~(u, j )  = 0 if u ~ F, (u, j )  ~ AS(u). The following theorem and its corollary directly follow from Lemmas 1 and 2, and from the results in 11. Theorem 6. If C q C + and problem EXTENSION(C) can be solved in polynomial time, then problems RE(C) and CE(C) can also be solved in polynomial time. Corollary 3. Problems RE(C) and CE(C) can be solved in polynomial time for the following classes of functions C: (1) positive, (2) positive g(S0, hi ( Sl ) )-decomposable, and (3) positive k-DNF with fixed k. 3.4. Threshold and Horn extensions Let us consider the classes CTH of threshold, and CHorn of Horn functions. For these two classes, we shall see below that, although RE(C) is p olynomially solvable, CE(C) is NP- complete even if IAS(a)I ~< 1 is assumed for all a 6 T U F. For the related results on the existence of threshold and Horn extensions of a pdBf see, e.g.,  11,24,26. Theorem 7. Problem RE(CTH) c a n  be solved in polynomial time. Proof. For a pBmb (T, F), where T, F _ NI n, let us consider the following linear programming (LP) problem: ± zi i=1 max ~ = z..,, Yi i=1 subject to E w/+ E y, >t i60N(a) (a,i)~AS(a) Va E "if, wi + E i60N(b) E (b,i) ~AS(b) Z i < ' t - - 1 Vb~ ~, Yi ~ w i ,  Yi ~ 0 zi >l wi, zi >>l O i = 1 , 2 . . . . .  n, i = 1 , 2 . . . . .  n. (12) E. Boros et al./ Artificial Intelligence 107 (1999) 219-263 231 We claim that the LP problem (12) has a feasible solution with a finite optimum value ~ if and only if (T, F) has a robust extension in C3"H. Informally, maximizing the objective function together with the last two constraints of (12) implies that Yi = min{0, wi} and zi = max{0, wi} hold in the optimal solution. Therefore, this forces the left hand sides of the first two constraints in (12) to take their lowest possible values mind,aS(a) ~-~'i'=1 wi (a,~)i for all a E T, and their highest possible values max~eAS(b) z...,i=l w i (b~)i for all b c F, respectively. \ ~ n ~ Let us assume first that (T, F) has a robust extension f 6 CTH, and let wi, i = 1, 2 . . . . .  n, and t be the coefficients in a realization (2). Then, since min{wia~ I ol ~} = min{0, wi} and max{wia~ I c¢ 6 ~} = max{0, wi} hold for all i, Yi = rain{0, wi} and zi = max{0, wi} give a feasible solution to (12). The objective value satisfies ~ ---- ~ i = 1  Yi -- ~ i = 1 Z i  <~ 0, and (12) has a finite optimum. r / n Conversely, assume that wi, Yi, zi, i ---- 1,2 . . . . .  n, and t are an optimal solution of problem (12) (with a finite optimum). Then Yi = min{0, wi} and zi = max{0, wi} hold since otherwise it could not be an optimum. This implies that wi, i ---- 1,2 . . . . .  n, and t are finite, and define a threshold function that is a robust extension of (T, F). T h e o r e m 8 .  Problem CE(CTH) is NP-complete, even if IAS(a)I <. 1 holds for all a T U F . Proof. This problem is obviously in NP. To show its NP-hardness, consider a cubic CNF = A ck, k=l Ck = (u~ V vk V wk), where u~, vk and wk for k = 1, 2 . . . . .  m are literals from set L = {xl, Y l , . . . ,  xn, Yen}. Let L t Xn}, and define T, F c l~ tuL' as follows. i -I - ! ! ---~ {Xl,X l , . . - , x n ~ T = { a X i =  ({x;}; {xi}),cl y i =  ({x;}; {.~i})li (cid:127) 1,2 . . . . .  n}, = {b (°) = (0; 0)} U {(b x' = {xi, xi}; 0), b x; = ({x;, Y;}; 0), l i = 1,2 . . . . .  n} U{b c k : ( { u ~ , v k , w k , u ~ , v  k,wk};0) i k = l , 2 ! t . . . . .  m}, (13) where (R; S) denotes the vector v 6 ~/g~uL' such thatON(v) = R and AS(v) : {(v, j ) j  j ~ s}. it is easy to see that IAS(a)t ~< 1 holds for all a 6 T U F. We claim that this pBmb (T, F) has a consistent threshold extension if and only if the 3-SAT problem for the CNF ~/' has a solution, which will complete the proof. Let us assume that c~ 6 B As is an assignment such that (T~, F " )  has a threshold extension: f ( d )  = 110 if ~z~LUL' Wzdz ~ t' if ~z~CuL' wzdz <~ t - 1, where d 6 ~LUL'. Note first that t ~> 1 follows from f ( b  (°)) = 0 and ~ z ~ c u L ' wzb~ °) = O. We shall show that ot(aXi,xi) 5& ot(aY~i,~ci) must hold for (aXi,xi), (aXi,fci) E AS. If a(a x~, x i ) =  ~(a ~, x i ) =  1 holds, then (aXe) ~ c T~ and (a~) ~ c T~, respectively, imply Wx~ + w , ~ t and w~ + w-, >t t, and hence X i X i wxi + Wx~ + w~i + w~ ~ 2t. (14) 2 3 2 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 However, b xi ~ Fa and bX~ E F ~ ,  respectively, imply wxi + w~i < t and Wx~ + w ~  < t, and hence Wx~ + Wx~ + w ~  + w~, < 2t, which is a contradiction to (14). Furtherm6re, if oe(a xi , x i ) =  ot(a ~ ,  2 i ) =  0 holds, then (aXe) ~ ~ T~ and (a~e) a c T~, respectively, imply Wxj >~ t and wx~ ~> t, and hence wxl + w)7;/> 2t > t (by t > 0), which is a contradiction to f ( b X j )  = 0. Hence ot(a x~ , xi) ~ ot(a yi , 2i) holds. Let us n o w define a b i n a r y vector x* E I~ n by { 1 . xi = i f o t ( a X i , x i ) = O , otherwise, and show that this y satisfies q~(x*) = 1. For this, assume otherwise that there is a clause Ck that satisfies Ck(x*) = 0 (i.e., uk = vk = wk = 0 holds by x*), that is, et(aUk,uk) = ot(a vk, vk) = ot(a wk, wk) = I. T h e n  taking three vectors (aUk) ~, (ark) ~, (atOk) ~ E T ~, we have w~ k + Wu, ~ >1 t, w~, k + Wv, k >~ t and wtok + ww,~ >~ t, and hence w,~ + wv~ + w~,~ + Wu; + wv, ~ + Ww~ ) 3t > t, which is a contradiction to f ( b  c~) = O. For the converse direction, let us a s s u m e  that q~ (x*) = 1 holds for some x* 6 I~ ~ . Let us . n, - * a n d e t ( a  ~i Y c i ) * f o r i = l = x i . . . . 2, , define an a s s i g n m e n t  ~ E BAS by o~ (a x~ , xi) = x i and let - 3 if e i t h e r z xi andx/* = 1 o r z  = x i  a n d x i + 2 if either z = xi and x  = 0, or z = $i and x i = 1, I/) z + 1 if either z = x~ and x; ~ = 1, or z = 2~ and x* = 0, - 1 if either z = x i ' and x' = 0, or z = 2~ and x  = i, and t = 1. T h e n  Y~z~L~L' Wzaz ~> 1 holds for all a E T~, and ~-~z~Lu~' wzbz <~ 0 holds for all b E , ~ .  H e n c e  (T, F )  has a consistent threshold extension. T h e o r e m 9. Problem RE(CHorn) can be solved in p o l y n o m i a l  time. P r o o f .  Let (T, F )  be a pBmb. For each a 6 T, let us define B ( a )  = {b ~ F I b ~ a } .  We claim that ( T , / ~ )  has a robust H o r n  extension if and o n l y if for every a E T, there exists an index j such t h a t a j  = 0 and bj = 1 for all b E B ( a ) .  The latter c o n d i t i o n can be easily checked in O(n T  F ) time. To prove the claim, let us assume first that, for every a E T, there exists an index j such that a j  = 0 and bj = 1 for all b E B(a). T h e n  for any ot 6 I13 As, all b ~ ~ B(a) ~ satisfies bj '~ = 1. Thus, for the H o r n  term Ia = (i60~IN(a)Xi)ffJ' we have ta(a ~) = 1 and ta(b ~) = 0 for all a 6 $AS and b E F .  Hence, the Horn D N F ¢p=- V ta aET provides a H o r n extension o f  (T, F ) .  E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 233 For the converse direction, let us assume that for some a E T, every index j with aj = 0 has a vector b ~ B(a) with bj E {0, *}. For such a vector a, consider the assignments ot E ~B As(a) U ~B As(B(a)) defined by or(a, i) = / 1--IbeB(a) s.t. bi#* bi  1 if there is a vector b E B(a) with bi E {0, 1 }, otherwise, for (a, i) E AS(a), and ~(b, i) = a~ for (b, i) ~ AS(B(a)). Then {b '~ 6 /7~ I b ~/> a ~} = B ( a ) ~ satisfies a~ ----- A {b~6F ~ I b=>/a a} b~' by the above assumption on a and B(a), where A denotes the component-wise AND operation, e.g., (0l 011 l) A (100101) = (000101). However, it is known  11,26 that a pdBf (T, F) has an extension in CHorn if and only if a 5& A b6F s.t. b~a b (15) holds for all a E T. Hence, (T~,/7~) has no extension in CHorn. T h e o r e m  10. Problem CE(CHorn) is NP-complete, even if IAS(a)I ~ 1 holds f o r  all a E T U F . Proof. It can be proved by a reduction from the 2-coloring problem of 3-uniform hypergraphs (for the details see 12). 3.5. Decomposable extensions Let us consider two basic classes of decomposable functions, CG(So,G(SI)), and C+(So,G(Sl)), where So, $1 c__ V. It is known that EXTENSION(CG(so, G(&))) and EXTEN- SION(C+(so, G(Sl))) can be solved in polynomial time 8. Let us first consider RE(CG(So,G(SO)),where it is emphasized that So A $1 ~ 0 generally holds. For a s u b s e t  S" c_ M v, let ASk(S) ~ {(v, j )  ~ AS(S) I J E Sk} for k = 0, 1, and ASk = A S ~ ( T  U F). For a given pBmb (T, F), we define a graph G(F,~) = (W, El U E2) by W = {w, w' I there exist a 6 T, b E 17, c~ E B as°(a) and/~ 6 ~ ASO(b) such that a a So = b E So and w = a c~ $1 , w ~ = b E $1  } ( c  B s~nso x M s~\s°) El -= { (w, w")  there exist a E T, b E /7, a E. IB As°(a) and fl E B As°(b) such that aUS0 = b/~S0 and w --= auSl, w I - b~Sl} E2 ---- {(u, v)  u, v E W with u = aaS1 and v = b~Sl f o r a ,  b E T t_J/? and ¢x E B As°(a), fl E B As°(b), for which aUSl ~ b/~S1 holds}.  234 E. Boros et al./Artificial Intelligence 107 (1999) 219-263 (1,1,*) G C (1:0,0) (1,1,*) O C )  (1,o,o) .) ? (o,0 o) ( 0 , 1 , 0 ) ~ ( 0 , 0 , * ) . (0,0,1) (0,1,*) O (o,l,o) Q (0,0, 0) (o,o,,) (0,0,1) E 1 - - Fig. 1. Graphs G(~,~) and Gr~ ~ of (T,/~) in Example 2. (T,F) I / Furthermore, denote by G (7, ~) the graph obtained from G (7, ~) by contracting all edges in E2. Note that G(7,~ ) has self-loops if there are edges (w, w') in El N E2, and any graph containing a self-loop is not bipartite. E x a m p l e  2. Let So = {1,2, 3, 4}, Sl = {4, 5, 6} and V = So U $1 (i.e., V = {1, 2 . . . . .  6}), and define T , / ~  _ {0, 1 } v by a O) = (1, 1, 1, 1 , , , 0 ) ~= a (2) = (0, *, 1, *, 1, , ) ~= a (3) = (0, 0, 0, 0, 1,0) b(l) = (0, 1, ,, ,, 0, 0) b (2) = (0, 0, 1,0, 0, *) b (3) = (0, 0, 0, 0, 0, 1) I Graphs G(7.I7 ) and G(7,t7) are given in Fig. 1, where solid edges stand for E1 and dotted edges for E2. Note that, for exan~ple, G(7,y ) does not have vertex ( 1 , . ,  0) ss, nso × Msl\so, which is obtained from a (1) c T, since there is no b 6 F such that holds for some ot ~ B aso(a(~)) and fl ~ ~ASo(b). (a(1))aSo = bfSo L e m m a  3. Let (T, F) be a pBmb. Then (T, F) has a robust G(So, G(Sl))-decomposable extension if and only if G~(7,y ) is bipartite. Proof. Let us first show the only-if part. Assume that (T, F) has a robust G(S0, G(S1))- decomposable extension, but G(7,~ ) is not bipartite. In other words, there is a cycle ! N w (°) --~ w (1) --~ -.. --~ w (1) ( =  w (°)) in G(7,t7 ) = (W, E1 U E2) such that El fq {(w (i), w (i+1)) i = 0, 1 . . . . .  1 -- 1} is odd. (16) Let us consider the values of hi on {(w(i)) '~ lot ~ BAS~(w(~))}, i = 0, 1 . . . . .  I -- 1. For each (w (i), w (i+l)) E El, by the definitions of E1 and a robust extension, we must have E. Boros et al. / Artificial Intelligence 107 (1999) 219-263 235 hl ((w(i)) fl) (cid:127) hl ((w(i+l)) g) for all assignments/3 6 II~ As~(w(i)) and y 6 l~ ASl(w(i+l)). This means that hi ((1/3(i))/~) = p for all/3 E ~ ASl(w(i)) , hl((to(i+l))r) =- p for all g ~ I~ as~(w(i+~)), for some p E {0, 1}. On the other hand, if (w (i), w (i+1)) E E2, hi ((w(i))/~) --=- hi ((w(i+l)) ~') (17) (18) E ~ASI (//)(i+l)), because the definition of W and (17) imply holds for all/3 c ~AS~ tw ) and 2/ that hl((W(i))~)= p for all/3 ~ 115 As'(w"'), ht((w(i+l))Y)= q for all ~, 6 1$ As~(w(~+')), and p = q by (w (i), w (i+1)) E E2. Thus (17) and (18) contradict (16). (i) Conversely, if Gr(~37 ) is bipartite, then there is a partition (Y, W \ Y) of W such that E1 ___ Y x (W \ Y), E2 ___ (Y x Y) U ((W \ Y) × (W \ Y)). By (19), we can define the value of hi for W by 1 hi ((w)~)= 0 if w 6 Y and/3 6B a&(w), if w ~ W \ Y and/3 6 ~ASl(tO). The hi values for other vectors (v) 7 are determined arbitrarily, where v 6 (T U F)S1 and Y E AS~(v). Furthermore, define g by g(a~ So, ht (aU S1) )= l for all a 6 T and ot 6 B As(a), g(b~So,h~(b~S1))=O f o r a l l b 6 F a n d o t 6 ~  as~b). (19) (20) \ W If aaSo with Wa "~ a~S~ h~(baS~) has a robust G(So, G(Sl))-decomposable extension. ----- baS0 holds for some a 6 T, b E /~ and a E ~as({~,b}), then Wa, Wb E W # by (19) and (20). Hence g is also well-defined. Therefore, we see that (T, F) satisfy (w~, Wb) ~ El, and we have h~(aUSL) and Wb ~ b~S1 In general, however, the size of graph G(~,y) can be exponential in IS01, and the above I lemma does not lead to an efficient algorithm of RE(CG(so,G(Sp)). Theorem 11. Problem RE(CG(So,G(SI))) is co-NP-complete. Proof. First we show that the problem is in co-NP. For a pBmb (T, F), we show that every simple cycle C in G(~,y) satisfies IC ~< ITI + LFI. By the definition of EL and E2, wSo n $1 = w~S0 N $1 holds for all edges (w, w ~) 6 E1 U E2. Thus ? wSo n a l l := w'So n S 1 (21) holds if there is st path from w to w I in G(~,y). In particular, all vertices in a cycle C in G(;7,y) have this property, and, by the definition of G(~,y), all vertices w in C have ! / 236 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 \ So, i m p l y i n g  that they are generated from different vectors in T U F. different wS1 This proves CI ~< ITI + IFI. Since (T, F )  has a robust G(So, G(Sl))-decomposable a negative answer extension if and only if there is no cycle C of odd length in G ~- - (T.F)' f or RE(6o(So,G(S~))) can be certified by an odd cycle of length no more than TI + IF, hence RE(C~(So,G(Sj))) belongs to co-NR . . . . .  n}, E = { H i l i =  1 . . . . .  m}, IHil = 3 We next show its co-NP-hardness. Let 9~ = (U, E) be a 3-uniform hypergraph, where U = { 1 is odd. Let S o = {1,2 . . . . .  n + m } ,  $l = {1,2 . . . . .  n} U {n + m + l , n  + m + 2 . . . . .  n + 2m}. Obviously, V = So U $1 = { 1, 2 . . . . .  n + 2m } and U = So n S = { 1, 2 . . . . .  n } hold in this case. Then define T, F c M v as follows. for all i, a n d r e T =  ( A i U { n + i } U { n + m W i } :  U \ Hi) lAi C Hi,Ai=/=~,i E {l,2 . . . . .  m}} F =  {(Ai C{n + i } C { n  + m + ( i  ( m o d m ) ) + l } ;  U \ Hi) lAi C Hi, Ai ~ 0, i E { I , 2  . . . . .  m}}, where C denotes the proper inclusion, and (R; S) denotes the vector v E M v such that ON(v) = R and AS(v) = {(v, i) I i 6 S}. We claim that this pBmb (T F) has a robust extension in CG(s0, o(st)) if and only if 7-/is not 2-colorable, where 7-( is called 2-colorable if there exists a partition (C, U \ C) of U such that Hi ~: C and Hi ~ U \ C holds for all Hi ~ E. This completes the proof because deciding if 7- is 2-colorable is NP-complete (see, e.g., 21), even i f m  is restricted to be odd. For this G(~,y) = (W, El U E2), we have E2 = ~, because any (v, j) EAS satisfies j E So N SI, implying that v E ~Sj holds for any vertex v in G(f,y). This means that G(f,~) is bipartite if and only if so is G(f,~). Thus ! Lemma 3 tells that (T, F) has a robust G(So, G(Sl))-decomposable extension if and only if G(~,y) is bipartite. Let us first assume that (C, U \ C) is a 2-coloring of ~ , i.e., C n Hi 7 ~ ~ and (U \ C) N H / ¢  0 for all Hi ~ E. Then C can be represented by m C = U A  ~ i=1 (22) for some 0 7 ~ A* C Hi, i = 1,2 . . . . .  m, and we have ((C U {n + m  + i}; 0), (C U {n + m + ( i ( m o d m ) ) + l } ;  0))E El, fori = 1,2 . . . . .  m. Hence, we have a cycle w d) ~ w (2) --+ .- • -+ w (m) --+ w (1) in G(f, t7 ), where w ( i ) = ( C u { n + m + i } ; O ) , i = 1 , 2 . . . . .  m. Since m is chosen to be odd, this implies that (T, F) has no robust extension in Co(so, 6(s~)). For the converse direction, let us assume that G(f, ~) has a cycle. By property (21), we for some C C U, where Wc = {w E is the subgraph of G(~.y) induced by Wc. By the can assume that the cycle belongs to G(T~,j~)Wc W I ON(wU) = C} a n d G j , y)Wc definition of the above (T, F), such a cycle must be of the form E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 237 (C U{n-+-m + 1}; 0) --+ (C U{n + m  +2}; 0)-->...--> (C U{n +2m}; ~) (C U {n + m  + 1}; 0). Thus the length of this cycle is odd. This C obviously satisfies (22) and is a 2-coloring o f ~ . However, we can point out an important special case in which RE(CG(So,G(SO)) is polynomially solvable. Theorem 12. f f So F) S1 = 3, problem RE(CG(So,G(SO)) can be solved in polynomial time. Proof. In this case, graph G(~,y) ---- (W, E1 U E2) can be represented by W = {aS1,hSlla ~ 7",b ~ F and aS0 ~ bS0}, E1 ---- {(aSl, bS~) a 6 T, b E/~ and aSo ~ bS0}, E2 = {(aS~, bS~)laSx, bS1 ~ W and alSo ~ bSl}. It is easy to see that this graph G'(~,y) has polynomially many vertices and can be constructed in polynomial time. Then, by applying Lemma 3, RE(CG(So,G(SO)) can be solved in polynomial time. Similarly to other classes, CE (C6 (s0, G (Sl))) appears more difficult than RE (CG t so, 6 (S~))). Theorem 13. Problem CE(CG(So,G(S~))) IAS(a)I <<. l for all a ~ T U F. is NP-complete, even if So n S1 = 0 and Proof. The proof can be done again by a reduction from the 2-colorability of 3-uniform hypergraphs 21 . For the details see  12. Let us remark finally that problems RE(C6(So,G(S j ))) and CE(CS(So,G(S ~))) can be solved + in polynomial time by Corollary 3. 3.6. k - D N F  extensions Let us consider the classes Ck-DNF and Ck_DY F. Recall that a DNF + i=1 jeP~ jcNi is a k-DNF if Ni U Pil <~ k for i ---- 1 . . . . .  m, and it is a positive k-DNF if, in addition, Ni ---- (3 for i = 1 . . . . .  m. For general k (i.e., k is a parameter included in the problem specification), Corol- lary 1 tells that problems CE(Ck-DNF) and CE(C+DNF) are NP-complete, and problems RE(Ck-DNF) and RE(C~_DNF) are NP-hard. However, for a fixed k, problems RE(C+DNF ) and CE(C+DNF ) can be solved in polynomial time, by Corollary 3.  238 E. Boros et aL /Artificial Intelligence 107 (1999) 219-263 Among the remaining problems, we start with problem RE(~k-DNF) for a fixed k. For a vector v e 1V~ n, let A ( v )  denote the assignment to the variables xi defined by A(v) = (xi 4-- V i I vi ~ *). (23) then A(v) = (xl <--- 1,x3 +--0,x4 ~--0). Let fA(v) For example, if v = ( 1 , . , 0 , 0 , . ) , (respectively, ~OA(v)) denote the function (respectively, DNF) obtained by fixing the variables xi as specified by A(v). L e m m a  4. Consider a vector v c I~ n and a term t = r - i j ~ p X j I-IjeN.~j. Then t(v u) = 0 holds f o r all assignments ~ e B As(v) if and only if ON(v) (3 N ~ 0 or OFF(v) N P ~ 0. Proof. It is easy to see that the if part holds. For the only-if part, assume ON(v) ¢q N = OFF(v) fq P = ~3, and define an assignment ~ ~ 1B Ashy) by c ~ ( v , i ) = 1, 0, if i E P , ( v , i ) if i e N , ( v , i ) c A S ( v ) , e A S ( v ) . This assignment o t e  B As(v) obviously satisfies t (v ~) = 1. L e m m a  5. Let ~o be a DNF o f n variables, and let v c 1V~ n. For a subset Q c AS(v) and an assignment ct E B Q, (i) qg(v ~a'~)) = 1 holds f o r all assignments fl e ~AS(v)\Q (ii) ~p(v (a'/~)) = 0 holds f o r all assignments fl ~ B As(v)\o if and only if q~a(v,) = _L, if and only i f  qga(vC~ ) = T, and where (ct, r )  is the concatenation o f assignments ot and ft. Proof. Similar to the proof of L e m m a 4. For a k-DNF ~p, the problem of checking if ~0 ~ T is called k - N O N T A U T O L O G Y 21. It is known that its complexity is the same as of k-SAT. For k ~< 2, k-SAT can be solved in polynomial time, but for k .-'~> 3, k-SAT is NP-complete 21 . The problem of checking if q~ = T is called k-TAUTOLOGY. It follows from the result about k-SAT that k-TAUTOLOGY is solvable in polynomial time for k ~< 2 but is co-NP-complete for k > / 3 . T h e o r e m  14. If k <<. 2, then problem RE(Ck-DNF) c a n  be solved in polynomial time. Proof. The following algorithm solves problem RE(Ck-DNF). A l g o r i t h m  CHECK-RE(Ck-ONF) Input: a pBmb (T, F), where T, F ___ IV n. Output: If a pBmb (T, F) has a robust extension in Ck-ONF, then output such a DNF ~o; otherwise, NO. Step 1. Generate all possible terms with at most k literals. Let ~p be the disjunction of all those terms t for which t(b ~) = 0 holds for all b 6 F' and oe e B As~b). Step 2. If qgA(a) = -- for all a e T, then output ~0; otherwise, output NO.  E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 239 It is easy to see that the ~0 obtained in step 1 is a k-DNF, and furthermore it is the m a x i m u m k-DNF (with respect to T(~0)) such that ~0(b '~) = 0 for all b ~ F and ct ~ B Asfb) . By L e m m a  5 (the case of Q = 13), if ~0 passes the test of step 2, then qg(a '~) = 1 must hold for all a ~ 7 and t~ 6 B As(a). Hence this ~o represents a robust extension of (7,/~); otherwise there is no robust extension. Let us next consider its time complexity. In Step 1, by L e m m a 4, checking of each term t can be done in O(n I,~)time. Since there are at most M = Y~=0 (2in) = O(n k) such terms, Step..) can be done in O(n k+l I,~1) time. In Step 2, we solve a k-TAUTOLOGY for each a ~ T to check whether ~OA(a) = T holds. Hence if k ~< 2, this can be solved in O(l~OA(a)I) time 4, where I~pl denotes the number of literals in ~0. Since qgA(a) c a n  be constructed from ~0 in O(I~Pl) time and I~Oa~a) l ~ kol = O(kn k) holds, Step 2 can be done in O(knk171) time. Totally, CHECK-RE(Ck-DNF) can be executed in O(n k (kTI + n lFI)) time. For k/> 3, however, CHECK-RE(Ck-DNF) does not run in polynomial time since it must check if ~0A(v) = T, which is co-NP-complete. In fact, we have the next theorem. T h e o r e m  15. For any fixed k ~ 3, problem RE(Ck-DNF) is co-NP-complete. Proof. Apply algorithm CHECK-RE(Ck-DNF) given in the proof of Theorem 14. Step 1 is carried out in polynomial time as noted therein. Step 2 consists of checking if qgA(a) = -I- for polynomially many a, each of which is obviously a computation in co-NP. Therefore, RE(Ck-DNF) for k ~ 3 belongs to co-NE The proof for the co-NP-hardness can be done by a reduction from the non-2-colorability problem of 3-uniform hypergraphs 21 for details). (see 12 We now turn to Eroblem CE(Ck-DNF) for a fixed k, and first consider problem CE(CI-DNF). Let (T, F) be a pBmb, where T, F _ M v and V = { 1,2 . . . . .  n }. For a vector v E M v and a subset I ___ V, let vI denote the projection of v on 1. Furthermore, for a set S _c 1VIY and a subset I c V, let 711 denote the projection of S on I (we assume that this projection keeps its multiplicity). If I is a singleton, say / = {j }, we write simply Sj instead of S{j}. We shall show that the following algorithm can solve problem CE(C~-DNF) in polynomial time. Algorithm FIND-CE(CI_DNF) Input: A pBmb (7, F), where T, F ___ 1Vii v and V = {1, 2 . . . . .  n}. Output: If the pBmb (T, F) has a consistent extension in CI-DNF, then output an assignment t~ 6 B As such that (T'~, F a )  has an extension in CI-DNF together with its 1-DNF expression ~o; otherwise, NO. Step 1. Let I0 := {j ~ V fO ~ / ~ j , lol := {j 6 V l O, 1 6  Fj}, contains only .). Define an assignment a by Ii :----- {j ~ V I 1 ~ F j , and I := V \ (Io O Il U Iol) (i.e., Fj 1 ~/~j}, 0 ¢/~j}, for j E l 1 ifeither ( i ) j 6 1 0 1 ,  o r ( i i ) a 6 T a n d j 6 l o , or a ( a ,  j )  := (iii) a 6 F and ~ 6  I1, (24) 0 if either (iv) a c F and j 6 I0, or (v) a 6 7 and j 6 I1,  240 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 and 1-DNF ~:= Vx~v V~. i~lo i~ll Step 2. Define a pBmb (T', F ' )  with T', F '  c 1M I by T' :---- (T \ S'I)I, /~' : = / ~ I , (25) where I was defined in Step 1, and Sl = {a E T taj e {1, *} for some j 6 I0} U {a 6 T l aj ~ {0, *} for some j 6 11 }. Step 3. For each j 6 I, introduce a binary variable yj (these variables define an assignment 13 ~ ~zs(~'uT") such that/3(a, j )  = yj for all (a, j )  6 A S ( T ' )  and fl(b, j )  = 9j for all (b, j )  E AS(F')). Let T" := T' n ~1, and construct a CNF (conjunctive normal form) A a~T" co= V y, v V y,. jEON(a) j¢OFF(a) Find a solution satisfying • (y) = 1 (i.e., solve problem SAT). If there exists a solution y*, then let qg' = Vj~ON(y*)xj v VjEOFF(y*) ~J, and output ~p := ~p v qF and the concatenated assignment (or, fl), where fl is obtained by substituting yj = yj ,* in the way as shown above; otherwise, output NO. To see the correctness of algorithm FINI)-CE(CI-DNF), let us show the following lemma. Lemma 6. A pBmb (T, F) has a consistent extension in C~-DNF if and only if (T', F') obtained in Step 2 of FIND-CE( C I-I)NF ) has a consistent extension in C I -DNF. Proof. Let ~o be the I - D N F of (25), and let qg' be a 1 -DNF consistent extension o f ( T ' ,  F'). Then we claim that the I - D N F  ~o v q/ defines a consistent extension of (T, F), which will prove the if part. By the assignment ot of (24), ~p(a ~) = 1 holds for all a E & ,  and qg(b ~) ----- 0 holds for all b E F. Furthermore, since ~p' is a consistent extension of (T', F'), some assignment fl e B As(f'UY') satisfies 9(a t~) = 1 for all a 6 ~i and ~o(b ~) = 0 for all b 6 F'. Hence, by the definition of ~,, q~(b(C~,~)) = 0 holds for all b 6 F. This implies that ~p v q91 is a 1-DNF extension of (~(,~,~0,/~(c~,t~)), that is, ~0 v ~p' is a 1-DNF consistent extension of (T, F). Conversely, let y c B As be an assignment such that (TY, F~') has a 1-DNF extension qg*= V Xi V V - ~ i . icP icN Then the following properties hold: 101 n (P U N) = 0 , Io n N  = 0 , ll N P =~3, E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 241 since otherwise some vector b 6 F would satisfy f(b ×) = 1, a contradiction. Let ~o'= V x i v  V Yi, iEN\ll i6P\lo (i.e., fl ~ ~AS(T'UF') is the projection of y on AS(T' U ~r)). and let/3 = yAS(T' U/~r) By the above properties, tp' is defined on I. We now show that ~o ~ is an extension F f ((T~)~, (F')~), which will prove the only-if part. By the definition of ~0', all b satisfy ~0~(b ~) = 0. Assume that al E T' of some a 6 T satisfies ~o'(a ~) = 0. Then (Vi6toZi V Vi6tdi)(afl ) = 1 holds by ~0*(a ×) = 1 and by the definition of ~p'. However, since T' = (T \ Sl)l, we have aj = 0 for j 6 I0 and aj = 1 for j ~ I~, which is a contradiction. Hence ~0' is an extension of ((TI)~, (F0~). Let us now consider how to obtain a consistent extension of (T ~, F'), that is, an assignment /3 6 B as(~'uT') such that ((T')~, (F')~) has a 1-DNF extension. Note that AS(b) = I holds for all b 6 /~, i.e., all vectors in F '  are {(,, • . . . . .  ,)}. Furthermore, if fl(b, j )  = 1 (respectively, 0) holds for some b 6 F ' ,  then no 1-DNF extension ~p~ of ((T')¢~, (/~i)~) has term xj (respectively, x.i). Since ~0'(a ~) = 1 must holds for all a 6 T I, we would like to make T(~Y)I as large as possible, under the condition that tp'(b ~) = 0 holds for all b 6 ~F,. This means that we only need to consider an assignment fl E ~AS(T'UF') such that fl(a, j )  = yj for "all (a, j) c AS(T') and/3(b, j )  = y j  for all (b, j) EAS(I~'), where y E I~ t, and a I-DNF ~ ' =  V Xj V V fi~J j6ON(3 jEOFF(y) (26) is an extension of ((T~)/~, (FI)~). For ~0 t to be an extension, we must choose a y 6 I~ l such that ~0'(a ~) = 1 figr all a 6 ~r (-11~ l. This condition can be written as ~ ( y )  = 1 in Step 3. Therefore, (T', F ' )  has a 1-DNF consistent extension ~o' of (26) if and only if ~ ( y )  = 1 holds. T h e o r e m  16. Problem CE(Ct-DNF) can be solw'd in polynomial time. Proof. The correctness of algorithm FIND-CE(CI-DNF) is immediate from the above discussion. Therefore, let us consider its time complexity. Obviously, we can execute Steps 1 and 2 in O(n(IT + I/~l)) time. In Step 3, we must find a solution of ~ ( y )  = Aa~U,, Ca = 1 (i.e., by solving an exact Ill-SAT, where exact k-SAT is a SAT satisfying that each of clauses has exact k literals). Exact k-SAT is in general NP-complete, but in this case, k = I I I, that is, k is equal to the dimension of SAT. Hence, this can be solved by checking if the number of different vectors in ~,I is equal to 2 III (in this case, @ (y) is not satisfiable). Otherwise, we find a vector y* c B I such that ~ -  ~ T", and this y* is a solution to @ (y) = 1. This can be done in O(nlT~"f) time by using the binary tree of 33 as a data structure. In total, we need O(n(lTI + IF I)) time. For k ~> 2, however, we have the following negative result.  242 E. Boros et al./ Artificial Intelligence 107 (1999) 219-263 Theorem 17. For any fixed k ~ 2, problem CE(Ck-DNF) is NP-complete, even if AS(a) <~ 1 holds for all a ~ T U F. Proof. This problem is obviously in NP. To show its NP-hardness, let m c I ) = A C i , C i = ( U i V U i V W i ) , i = 1 , 2 . . . . .  m i=1 be a cubic CNF, where ui, vi and w i for i = 1, 2 . . . . .  m are literals from the set L = {Xl, £1 . . . . .  xn, 2n}. We use notation like xj E Ci by regarding Ci as the set {ui, vi, wi}. Let VI = {1,2 . . . . .  n}, V2 = { n + l , n + 2 . . . . .  n + m + k - 2} and V = Vl U V2 U V3. We construct T , / ~  ___ 1~ v as follows. . . . . .  n + m } ,  V3 = { n + m + l , n + m + 2 f ~-- {a (i) = (Wi U {n f = {(0; 0), 0)} + i } ;  0 ) i  = 1,2 . . . . .  m}, U{({j};O) Ij E V1} U {b (i) = (Wi U {n + i }  U {l}; 0) li = 1,2 . . . . .  m, I E V3} U {c (i) =- ( W 7 U{n ÷ i } ;  0) Ii =- 1,2 . . . . .  m} u{a i = U/)IJ where W/ = {j Ixj E Ci}, W~ = {j 2j ~ C i }  and Uj = {n + i Ixj ~ C i or.~j E Ci}. As before, (R; S) denotes the vector v E 1VII v such that O N ( v )  = R andAS(v) = {(v, j )  i j S}. Note that V3 and the set of b (i) in F are both empty if k = 2. It is easy to see that AS(a) ~< 1 holds for all a 6 T U F .  We claim that this p B m b  (T, F )  has a consistent k- D N F  extension if and only if 3-SAT for q5 has a solution (i.e., if there is a binary vector y 6 {0, 1} n for which ~ ( y )  = 1). This will complete the proof, because 3-SAT is NP- complete 21. To prove the claim, let ~ 6 ~AS be an assignment such that (T~,/7~) has a k - D N F extension (p, and let ti = I-IjEPi x j  l-IjENi.~J' where P i n  N/ = 0 and Pi U Nil <~ k, be a term in ~o such that ti (a (i)) -= 1 for a (i) ~ T. Then such terms ti, i = 1, 2 . . . . .  m, satisfy the following properties: (a) Ni D V3 and I(Pi U Ni) \ V31 ~< 2 hold. If the first property does not hold, we have ti (b (i)) = 1, a contradiction. The second property then follows from 1V31 = k - 2. (b) I(Pi U Ni) M V2 = 1 holds. Otherwise, we have I(Pi U Ni) n V21 = 0 or 2 by (a). If I(PiUNi)NV21 = 0, then at least one vector b in {(0; 0), (V1; 0)}U{({j}; 0) l j  ~ V1} (___ F ) satisfies ti ( b )  = 1, which is a contradiction. Furthermore, if I (Pi U Ni) n V21 = 2, then I(Pi N Ni) N Vtl = 0 holds, and ti(a (i)) = 1 implies that c (i) ~ F satisfies ti (C (i)) = l ,  which is again a contradiction. (c) P / n  V2 = {n + i} holds. First if IPi N V2I = 1, then ti(a (i)) = 1 implies P i n  V2 = {n + i}. Otherwise, (b) implies N / N  V2 = {n + h} for some h E {1, 2 . . . . .  m} with i, and then, by I(Pi U Ni) N VII ~< 1, at least one vector of b = (0; 0) and h # b = (V1; 0) (E/~) satisfies ti (b) = 1, which is a contradiction. This means that either ti = Xn+i (1-IIEv3 Xt) or ti = ZjXn+i (NIEV3 xI) with Zj E L holds. E. Boros et al./Artificial Intelligence 107 (1999) 219-263 243 (d) ti : UiXn+i(Hl6V3 Xl), l)iXn+i(I-16V3 X1) or WiXn+i(I-Ii~v3 Xl) holds. If ti : Xn+i (l--ItEv3 xl), then c (i) ~ F satisfies ti (c (i)) : 1, which is a contradiction. Therefore ti = ZjXn+i( ~vaXl)l for some zj ~ L. If zj E L \ {ui, vi, wi}, then zj must be a negative literal xl in order to have ti(a (i)) = 1, and l ¢ W~ holds by the assumption on zj. This means ti (c (i)) = l, which is again a contradiction. (e) There is no pair of terms tp and tq such that tp : XjXn+p(I-IlEv3.~l) and tq : YCjXn+q(1--Ilev3 fCl). If tp and tq are such terms, then (tp V tq)((d(J)) ~) = 1 holds for any assignment/~ 6 gAS, which is a contradiction. Based on these, let us define a binary vector y 6 ~n by 1 0 if ti =XjXn+i(I-Ilev3xl) f o r s o m e i  c {1,2 . . . . .  m}, otherwise. YJ = Then properties (d) and (e) show that this y satisfies • (y) = 1. To prove the converse direction, given a binary vector y E ~n satisfying @ (y) = 1, define an assignment el c ~AS by if yj : O, l °t(d(J)'J)= 0 otherwise, and a k-DNF function ~o* by m qg* = V i=1 t*, t i* = ZjXn+i t 21 (l__i IEV3 , (27) where zj ~ {ui_ Ui,tl)i} : Ci and zj = 1 is implied by y. Then_ we~ can see that q~* is an extension of (T ~, F~), that is, ~0" is a consistent extension of (T, F). 4. Problem MRE In this section we study the problem of finding most robust extensions. Let us recall that whenever problem CE(C) is NP-complete, problem MRE(C) must also be NP-hard. This leaves unresolved only about half of the considered cases. We shall see in the next subsection that some other cases can also be resolved as direct consequences of BEST-FIT. The remaining cases will then be discussed in the subsequent subsections. 4.1. Implications by problem BEST-FIT T h e o r e m  18. If C z C + and problem BEST-FIT(C) can be solved in polynomial time, then MRE(C) can be solved in polynomial time for any pBmb (T, F) that satisfies AS(v) <<, 1 for all v E T U F. 244 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 Proofi For the above pBmb (T,/~), define the pdBf (T ~, F ~) by T' = {a °, a 1 a 6 T} and F '  = {b °, b 1 I b 6 F}, where c o and c 1 are defined as in L e m m a  1. Also define the weights of the vectors in T' and F ~ by w(a l) = + o ~ i f a  ~ T, w(b O) = + c ~ i f b  6/~, w(a O) = 1 if a 6 T and AS(a) ¢ 0, w(b 1) = 1 if b ~ F andAS(a) ¢ 0. Note that by definition, w(a 1) = w(a) = +oQ (respectively, w(b °) = w(b) = +ocz) holds for all vectors a 6 T (respectively, b 6 F )  having no missing bit. We claim that p ( T , F ) = E ( T ' , F ' ) holds, where p and s are defined in (4) and (3), respectively. This will prove the theorem since s(T', F ~) can be computed by solving BEST-FIT(C). First, if s(T I, F ' )  < + o o ,  then clearly, there is a consistent extension of (T, F) by the definition of w. Conversely, if there is a consistent extension f of (T, ,~), then f ( a 1) = 1 holds for all a 6 T and f ( b °) = 0 holds all b 6 F by the positivity of f ,  which implies s(T ~, F r) < +o¢~. Let us assume next that there is a solution of MRE(C) for (T, F); i.e., a subset Q c_ AS with IQI = p ( T ,  F) and an assignment fl ~ ~Q for which (T~, F~) has a robust extension f in C. Then f correctly classifies all vectors in T' U F ' ,  except for a ¢~ 6 T ~ U F ~ with AS(a) n Q ~ 0 (where/~ denotes the complement of fl). Hence P ( T ,  F) = QI = ~ w(aO) + Z w(bl) ~> e(T', F'). a ° c T ' s.t. f ( a ° ) = 0 b l E F ~ s.t. f ( b l ) = l For the converse inequality, consider a solution (T*, F*) to BEST-FIT(C) for the pdBf (Tq F'), i.e., T* O F* = 0, T* U F* = T' U U ,  the pdBf (T*, F*) has an extension f in C, and e(Tq F ~) = w(T ~ n F*) + w(F' N T*) < +oo. Then, by the positivity of f ,  we have a 1 ~ T* for all a 6 T and b ° c F* for all b 6/~. Thus define Q = Q~ u Q0, where Q1 = {(a, j ) a  E T', (a,j) cAS(a) a n d a 0 ~ F*}, Q0 = {(b, j) lb c F', (b, j) ~AS(b) and b I ~ T*}, and an assignment fl 6 B o by/3(a, j )  = 1 for (a, j )  E Q1, and fl(b, j )  = 0 for (b, j )  ~ Q0. The resulting (T#, F # )  has a robust extension f 6 C. Consequently, e ( T ' , F ' ) = I Q x I ÷ I Q o I = I Q I > . p ( T , F ) . Combining these with the results in 11, we obtain the next corollary. Corollary 4. Let a pBmb (T, F) satis~, AS(a) <<, 1 for all a ~ T U F. Then problem MRE(C) is polynomially solvable for the class of positive functions C = C +. E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 245 4.2. General extensions Let us consider theclass Call. As a result of Theorem 5, problem MRE(Cat0 is NP-hard, unless instances (T, F) satisfy IZS(a) ~< 1 f o r a l l a  E T U  F. We shall show below that, for such pBmb instances, a most robust extension can be found in polynomial time. Let us remark first that any assignment a 6 ~AS for which (T~,/~a) has an extension must satisfy the conditions (i) and (ii) in the proof of Theorem 4. Hence, some components of such an a may be forced to take a unique binary value by conditions (8) and (9). Let us assume therefore that we fix all such missing • bits in advance, and let us consider only conditions (10) and (11) in the sequel. Let us define next a bipartite multi-graph with labeled edges. GAS = (V, E), V --- A S ( T )  U A S ( F ) , E = {(q, r; t~)lq = (a, i) ~ A S ( T ) ,  r = (b, j )  e A S ( F ) , there exists an assignment a 6 ~{q,r/such that a s = b a . (28) The label c(e) of each edge e = (q, r; c(e)), as defined in (28)_ is called the configuration o f e .  Let us note that, since IAS(a) ~< 1 holds for all a c T U F, every pair o f q  = (a, i) A S ( T )  and r = (b, j )  ~ A S ( F )  has at most two assignments ot c ~(q.rl such that a a = b a. If there are two assignments ot 6 ~{q.r/ for some q E A S ( T )  and r c A S ( F ) ,  for which a ~ = b a (this occurs if q = (a, i) and r = (b, j )  satisfy i = j), then the graph GAS has parallel edges corresponding to such different configurations. Example 3. Let us define T,/~ _ {0, 1 }6 by a (1) = (., 1, 1, 1, 1) a (2) = (1, l, 1, 1,*) F = a ( 3 ) = ( 1 , 1 , 1 , , , 1 ) , a (4) : (1, 1 , . ,  1, 1) a (5) = (1, ,, O, 1, O) b (1) = (1,*, 1, 1, 1) b (2) = (l, 1, 1, 1 , . ) b (3) = (1, 1 , . ,  1,0) b (4) : (1, 1, 0, 1, *) Then the graph GAS is given in Fig. 2. Although the configurations of edges are not indicated, they are easily found out. For example, the edge e = ((a (1), 1), (b 0), 2)) has c(e) = (al l) = 1, b~ U = 1), and the parallel edges e ~ = ((a (~), 5), (b (2), 5)) and e" ----- ((a (2), 5), (b (2), 5)) have c(e t) ---- (a~ 2) = O, b~ 2) = 0) and c(e') = (a~ 2) = 1, b~ 2) = 1), respectively. Lemma 7. Given a pBmb (T,/~), an assignment ~ ~ ~Q for a subset Q c AS is a robust assignment o f ( T ,  F) (i.e., (T~,/~¢~) has a robust extension) if and only if, for every edge 246 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 GAS P (~(~, 5) ( a (3) , 4) (~('), 3) (b (~) , s) ( b (3) , 3) ( F ' I ,  ~) Fig. 2. The graph GAS of the pBmb (T, F) in Example 3. e = (q, r; ol) of GAS, we have either q = (a, i) c Q and a ~ # a ~, or r = (b, j )  ~ Q and b l~ 5~ b ~, or both. P r o o f .  Let us first show the o n l y - i f part. Let f be a robust extension of (T~, ~-t~), and let e = (q, r; c~) be an edge of GAS. A s s u m e  that either q ~ Q or a ~ = a u holds. T h e n we have f ( a ~) = 1. Indeed, if q = (a, i) ~ Q, then (a~) ~ = a ~, and s i n c e / 3  E ~ a  is a robust assignment, f ( a ~) = 1 must hold. On the other hand, if a ~ = a ~, then o b v i o u s l y f ( a ~) = f ( a t~) = 1 must hold, since a c T. We then show that f ( a ~) = 1 implies r = (b, j )  ~ Q and b t~ 7~ b ~, which proves the o n l y - i f part. If r ~ Q, then (b/~)" = b ~ =: a c~, and hence f ( a ~) = f ( b ~) = 0 b y  b 6 /~, which is a contradiction. Similarly b ~ = b ~ leads to the same contradiction. Hence r 6 Q and b ~ ~ b ~ m u s t  hold. T o p r o v e  the if part, assume that/3 c s Q  for a subset Q ~ AS is not a r o b u s t a s s i g n m e ~ of (T, F ) .  Then, b y the definition of robustness, we have a pair of vectors a c T and b 6 F such that a ~ -~ b/~. T h e n  the edge e = (q, r; ~) with q = (a, i) and r = (b, j )  does not satisfy the statement of the lemma. For a vector d c It~ n, let E(d) denote the set of edges e = (q, r; c¢) 6 E such that a ~ = b a = d, where q = (a, i) and r = (b, j ) .  T h e n  E = UaE(d). Let us define a coherent domain D(d) as the set of vertices incident to some edges of E ( d ) ,  and let Do denote the set of isolated vertices (i.e., incident to no edge e c E). No vertex in Do belongs to a coherent domain. In the following discussion, we o n l y consider nonem, pty coherent domains. Fig. 3 shows all n o n e m p t y coherent d o m a i n s of the graph GAS of (T, F )  in E x a m p l e  3. L e m m a  8. Every coherent domain D(d) c_ V of GAS induces a complete bipartite subgraph of GAS. E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 247 Gas P D(11110) D(11011) D(llm) D(li010) Fig. 3. Coherent domains of the graph GAS of (T, F) in Example 3. P r o o f .  Take any pair q = (a, i) E A S ( T )  and r = (b, j )  e A S ( F )  that satisfy q, r E D(d). T h e n there exist assignments c~ e ~{q} and fl 6 ~{r} such that d = a ~ --- b ~. We concatenate for which a 7 = b;" = d, these assignments to have an a s s i g n m e n t  y = (or, fl) 6 B q'r} i m p l y i n g that there is an edge (q, r; F )  6 E(d). L e m m a  9. Let D(d) and D ( d t) be two coherent domains o f  GAS, where d, d r E IB n and d ~ d r. I f D ( d )  N D(d') # 3, then II d - d '  II = 1 holds, where l x II---- yin-1 Ixil. P r o o f .  Let q = (a, i) E D(d) N D(d'). T h e n  there exist two assignments or,/3 E B {q} ( = {0, 1 }) such that a ~ = d and a ~ = d r. Since AS(a~I ~< 1 is assumed, this implies lid - d r II = 1. L e m m a  10. Let D(d) and D ( d r) be two coherent domains o f GAS, where d, d' c I~ n and d ~k d'. Then ID(d) N D ( d ' ) l  ~< 2 holds. Furthermore, i f D ( d )  N D ( d r) = {q, r}, then the graph GAS has two parallel edges between q and r. P r o o f .  If q = (a, i), r = (b, j )  E D(d) N D(dr), then by assigning 0 and 1 to q and r, each of a and b can b e c o m e  both d and d r. Since 11 d - d '  I= 1 by L e m m a  9, this can  248 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 only happen if the vectors a and b are identical, missing the s a m e c o m p o n e n t  i = j. Therefore D(d) O D(d') ~ AS(T)I ~< 1 and ID(d) (3 D(d') N AS(F)I ~< 1, and hence ID(d) N D(d')l ~< 2. Finally, if D(d) N D(d') ---- {q, r}, where q = (a, i) ~ A S ( T )  and r = (b, j )  ~ A S ( F ) ,  then q = r implies that there are two assignments ~,/3 6 ~{q,r} SUCh that a '~ = b ~ = d and a ~ = b ~ = d', i.e., the graph GAS has two parallel edges between q and r. Let us now color the edges of GAS by "yellow" and "blue", so that all edges of a set E(d) have the same color, and every pair of sets E(d) and E(d') with D(d) (~ D(d t) ¢ 0 has different colors. We call such a two coloring alternating. The following lemma shows that an alternating coloring is always possible. Furthermore, it can be uniquely completed after fixing the color of one set E(d) in each connected component of Gas. L e m m a  11. Let D(d(°)), D(d (1)) . . . . .  D(d (l)) denote a cycle of coherent domains such that d (i-l) 5~ d (i) and D(d (i-l)) fq D(d (i)) 5~ ~ hold for all i = 1,2 . . . . .  l - 1, and D(d (t)) = D(d(°)). Then l is even. Proof. Lemma 9 implies that II d (i-1) - d~i) II = 1 holds for all i = 1, 2 . . . . .  l - 1. Since II d (°) - d (t) II = 0 is even, l must be even. Finally, let us orient the edges of GAS according to a g ~ e n  alternating coloring, as to r ~ A S ( F ) ,  and every follows. Every yellow edge (q, r) is oriented from q 6 A S ( T ) blue edge (q, r) is oriented from r ~ A S ( F )  to q ~ AS(T). Let G~AS denote the resulting directed graph. For example, Fig. 4 shows the directed graph G~as corresponding to the pBmb (T, F )  of Example 3. Let us observe that every directed path of this graph is alternating in colors, and every alternating undirected path is either forward directed or backward directed. The next lemma characterizes a robust assignment by a directed path of Gras. L e m m a  12. Let (T, F) be a pBmb. Then fl ~ ~Q for Q c AS is a robust assignment if and only if the following two properties hold for every directed path q(O) e-~ q(1) q (2) __+ ... __+ q (!- 1) ~ q it) in G~AS , where q (i) = (a (i), ji ) and oti = c (ei) for all i. (i) If q (°) ~ Q or (a(°))/3 = (a(°)) al, then q(i) E Q and (a(i)) fl 5~ (a(i)) c~i hold for all i ---- 1, 2 . . . . .  I. (ii) If q (l) ¢ Q or (a(1)) ~ = (a(l))~t for l, then q(i) ~ Q and (a(i)) ~ ~ (a(i)) ~+~ hold for alli = 0 ,  1 . . . . .  l -  1. Proof. We first prove the only-if part. For condition (i), we first consider e~ = (q~O) q~l)). By Lemma 7, q(O) ~ Q or (a(°)) t3 = (a(°)) '~ implies that qO) ~ Q and (a(1)) ~ ~ (aO)) ~1 . Now, since el = (q(O), q(1)) 6 E(d) and e2 = (qO), q(2)) E E ( d I) have different colors, we must have d # d I and q(l) 6 D(d) N D(dt), and hence I d - d' II= 1 by Lemma 9. Therefore, (a(1)) ~ # (a~l)) ~ ( =  d) implies (a(l)) ~ = (a(2)) a2 ( =  dl), and hence q(2) satisfies q(2) 6 Q and (a(2))/3 5 & (a(2)) a2 by Lemma 7. This assignment can proceed in a similar manner to q(i), i = 2, 3 . . . . .  l. Case (ii) is similar to (i).  E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 249 c'~s D ( l l l l l ) a (1) a (~) . E a (3) E- 0(11010) b(1) b (~) - D(11110) 4 D(11011) Fig. 4. The directed ~ a p h  GIAS of (T,/~) in Example 3. Conversely, if conditions (i) and (ii) hold, then, by L e m m a  7, fl 6 ~Q is a robust assignment. Let Ci, i = 1,2 . . . . .  s, denote all the strongly connected components of this directed graph G~AS . Furthermore, let G~s denote the transitive closure of GtAS (i.e., (s, t) is an arc in G'AS if there is an s-t directed path in G'AS), and let GOAs denote the directed subgraph of G~s induced by W = U i s.t. lCil=l Ci. (29) It is easy to see that the set of isolated vertices Do in GAS satisfies Do ___ W. Fig. 5 gives the graph G°AS of (7, F) in Example 3, in which arcs (u, v), having a directed path of length at least 2 from u to v, are not indicated for simplicity. L e m m a  13. Let (T, F) be a pBmb, let el ~ ~9_ fi~r some Q c_ AS be a robust assignment, and let Ci, W and G°AS be defined as above. Then the following two conditions hold: (i) Ci c_ Q for all Ci with I Ci I > 1, and 250 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 b ( 4 ~ a(5) Fig. 5. The graph GOAs corresponding to G~AS of (T, F) in Example 3. (ii) W \ Q is an antichain in G°s (i.e., for an3' pair of q, r ~ W \ Q, there is no directed path from q to r in Go, and vice versa). l Proof. Consider a robust assignment ~ 6 ~Q. Assume q ~ Ci \ Q for some Ci with ICil > 1. Then there is a directed cycle q(0) ( =  q), q(J), q(2) . . . . .  q(l) ( _  q) of length I > 1 in GAS, and q ¢~ Q implies q E Q by L e m m a  12, which is a contradiction. Hence condition (i) holds. To prove condition (ii), let us assume that for some pair of q, r 6 W \ Q, there exists a directed path from q to r in GAS. This is again a contradiction since q ~ Q implies r E Q by L e m m a  12. L e m m a  14. Let (T, F) be a pBmb, and let S c W be any maximal antichain in G°s . Then for Q = A S \  S, there is a robust assignment fl c B Q o f ( T ,  F). Proof. For Q = AS \ S, we shall construct a robust assignment fl E ~Q. In the following, we shall consider the directed graph G'AS, and let us note that, by definition, S is also an antichain in G'AS. L e m m a  12 implies that, starting from a vertex q 6 S (i.e., q ¢ Q), a robust assignment fl for all vertices t which are either reachable from q or reachable to q is uniquely determined, unless the following cases of conflicts are encountered. (i) For q, r c S, there is a vertex t for which there are two directed paths P1 = q(0) r (1) ( =  t) ( =  q) __+ q(1) __+ . . .  __+ q(k) ( =  t) and /°2 = r (°) ( =  r) ~ such that t a # t a', where ~ = c(q (k-l), t) and d = c(r (t-l>, t). r (l) ~ ... ~ (ii) For q, r E S, there is a vertex t for which there are two directed paths P1 = qf°) r (1) --+ . . .  --+ r (t) ( =  r) ( =  t) --~ q(l) __+ . . .  __+ q(k) ( =  q) and P2 = r ~°) ( =  t) ~ such that t ~ # t a', where a = c(t, q(l)) and ~' = c(t, r(1)). If one o f  these conflicts occurs, L e m m a  12 implies that t must be assigned in different ways, and hence we cannot construct an appropriate robust assignment 3. However, we now show that none of these conflicts can occur. Let us consider case (i) only, since case (ii) can be analogously treated. Now t ~ # t u' implies (q(k-l), t) ~ E(d) and (r (/-1), t) ~ E(d') for some d -¢ d ' ,  and hence t ~ D(d) M D ( d ) .  Thus (q(k-l), t) and (r (l-l), t) have different colors, by D(d) ~ D(d') 5~ 0. By the rule of orienting edges (yellow edges are oriented from A S ( T )  to A S ( F ) ,  and blue edges are oriented from A S ( F ) to AS(T)), this means that one of (q(k-l), t) and (r (l-1), t) is oriented towards t, and the other is away from t, a contradiction to the assumption in (i). E. Boros et al. / Artificial Intelligence 107 (1999) 219-263 251 Let us denote by R the set of all vertices t ~. S such that either t is reachable from some q • S or some q • S is reachable from t. The above argument shows that a robust assignment/3 for R can be uniquely determined by Lemma 12. Finally, we consider an assignment 13 • ~AS\(SUR). By the maximality of S, every vertex t • AS \ (S U R) has an incoming arc e = (r, t) • E(d). Therefore, determine the robust assignment fl of this t so that t/~ = d holds. This is well-defined because all incoming arcs to t belong to the same E(d) by the definition of G:AS. It is then easy by Lemma 7 to see that the resulting/3 over AS is in fact a robust assignment. Lemmas 13 and 14 imply that problem MRE(Call) is equivalent to the problem of finding a maximum antichain of G°s . Since G°s is acyclic, we can find such an antichain in polynomial time by applying a maximum flow algorithm (see Dilworth's theorem, e.g., 20). Hence, we have shown the following theorem. T h e o r e m  19. Problem MRE(Call) can be solved in polynomial time for a pBmb (T, F) in which all a • T U F satisfy. IAS(a)I <<, 1. 4.3. Positive extensions Let us consider the class C + of positive functions. Corollary 4 implies us that problem MRE(C+) can be solved in polynomial time for the restricted case of IAS(a)I ~< 1 for all a • T U F. However, problem MRE(C +) is in general NP-hard. T h e o r e m  20. Problem MRE(C +) is NP-hard, even if lAS(a )l <~ 2 holds for all a • T U F. Proof. Let G = (V, E) be an arbitrary graph, where V = {1,2 . . . . .  n}, and define T, F _ NI v as follows. = {a (/'j) = (0; {i, j}) (i, j) ~ E}, /~ = {b (°) = (0; 0)} U {b (i) = (~t; {i}) I i e V}, where (R; S) denotes the vector v • M v such that ON(v) = R and AS(v) = {(v, j )  I J • S}. It is easy to see that AS(a)I ~< 2 holds for all a • T U F. We claim that p ( T , / 7 )  = IEI + r ( a ) holds, where p ( T ,  17) is defined by (4), and r ( G )  denotes the cardinality of a minimum vertex cover of G. This will complete the proof of the theorem, since finding r ( G )  is known to be NP-hard 21. Let us first observe that, if (T/~,/7/~) has a robust positive extension for some fl • ~O, j )  = 1 (or both) holds for every (i, j )  • E, Q c AS, then e i t h e r / 3 ( a  (i'j), i) = 1 o r / 3 ( a  (i'.), since otherwise we have b (°) ------ (a(i'J)) fl • F ,  which is a contradiction. Let E1 = {(i, j )  • EI exactly one of/3(a (i'j), i) -- 1 and/3(a (i'j), j )  = 1 holds}, E2 = {(i, j )  • E  fl(a (i'j), i) = fl(a (i'j), j )  = 1 . 252 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 If (i, j )  6 E1 and fl(a (i'j), i) = 1 (respectively, fl(a (i'j), j )  = 1), then /3(b (i), i) = 0 (respectively, fl(b (i), j )  = 0) (otherwise (a(i'J)) ~ ,~ (b(i)) ~ (respectively, (a(i,J)) ~0 (b(J)) ~) and/3 is not a robust assignment). This implies that C = {il fl(b (i), i) = 0} U {i  i < j, (i, j )  6 E2} is a vertex cover of G. Hence I a l  t> tEll + 21E21 + I{i I/3(b(i),i) =0} I = (IEil + IE21) + (lEvi + {il/3(b (i), i) = 0}) = IEI + I f l / >  IEI + r ( G ) . For the converse direction, let C ___ V be a minimum vertex cover, and let us define a set Q c AS and an assignment/3 E ~Q by Q = {(a (i'j),i) either (i E C, j ~ C) or (i, j 6 C , i  < j)} U {(b (i),i)i ~ C}, /3(a (i'j), i) ~--- 1 for (a (i'j), i) c O and/3(b (i), i) = 0 for (b u), i) ~ Q. By L e m m a  1, it is easy to see that/3 is a robust assignment, and I QI = I EI + r (G) holds. 4.4. Decomposable extensions As in Section 3.5, we consider two basic classes of decomposable functions, CG(So,G(S I)) and C+(so,G(sl)). As noted at the end of Section 2.2, Theorem 13 immediately implies that problem MRE(CG(So,G(Sl))) is NP-hard even if IAS(a)I <~ 1 holds for all a c T U F. For problem MRE (C+(so, G (S~))), we also have the following negative result. T h e o r e m  21. Problem MRE(C+(so, G(Sp)) is NP-hard, even if AS(a) <<, 1 holds for all a E T U F . Proof. The proof is done by modifying the NP-hardness proof of BEST-FIT (C+(s0, c (s~))) in  11 . A complete proof can be found in 12. 4.5. k-DNF extensions Let us consider the classes Ck-DNF and C + For general k, these problems are NP- hard since the corresponding CEs are NP-complete by Corollary 1. Therefore, we consider only the cases of fixed k. k-DNF" T h e o r e m  22. For any fixed k >~ 1, problems MRE(Ck-DNF) and MRE(C+DNF) are NP- hard, even if AS(a)I <~ 1 holds for all a ~ T U F. Proof. Let G = ( V , E )  be a graph, where V = {1,2 . . . . .  n}, and let W = {n + 1, n + 2 . . . . .  n + k - 1 }. Let us define T, F c ~/I vuw as follows. = {a (i'j) = ({i, j} U W; 0) (i, j )  ~_ E}, = {b (°) = (W; 0)} U {b (i) = (W; {i}) i E V} U {b (i'j) = ({i, j} U (W \ {/}); 0)I (i, j )  E E, 1 E W},  E. Boros et al. / A rtificial Intelligence 107 (1999) 219-263 253 where (R; S) denotes the vector v E M vuw such that ON(v) = R and AS(v) = {(v, j )  I J S}. It is easy to see that AS = {(b (i), i) I i E V} and IAS(a)I <~ 1 for all a 6 T U/~ hold. We claim that P(Ck-DNF; ?)) : P(Ck-DNF, + . = (30) holds, where r ( G )  denotes the cardinality of a minimum vertex cover of graph G. This will complete the proof because finding r (G) is known to be NP-hard 21. To prove the claim, we show first that P(Ck-DNF; (T, F ) )  ~ P(Ck_DN F, (T, ? ) )  ~ ~(G). + ( 3 1 ) The first inequality follows from Ck-DNF D C + k-DNF goc to any subset C c V by defining -- k-DNF" For the second one, let us associate a qgC = V XiXn+lXn+2 " " "Xn+k- l, i6C and let us consider ~0c*, where C* ___ V is a minimum vertex cover of G. Define Q c AS andcx E ~Q by Q = {(b (i), i )  l i ~ C*} and ~((b (i), i)) = 0 for all (b (i) , i) E Q, respectively. Then ~0c* is a robust extension of (T u, F~), i.e., p(Ck_DN F, • (T, F)) ~< IC*l = r ( G ) . + Next, we show that P(Ck-DNF; (T, ? ) )  ~ r ( G ) , (32) which together with (31) will imply (30). For this end, let a E I~ a for Q c AS be an assignment such that (T u, F ~) has a robust k-DNF extension, and let = V t i , iEl be such a k-DNF with a minimal I, where ti = I-Ij~p~ xj I-Ij~N~ x j, Pi N Ni = 0 and I Pi U Ni I ~ k for all i ~ I. Then the minimality of I implies that for every term ti, there is an a (h~,l~) E T~ such that ti(a (hMJ) = 1. Thus Pi ~ W holds for every i E I, since otherwise the vector b (h~ l~) E F~ also satisfies ti(b (hi'li)) -~- l ,  which is a contradiction. This implies I(Pi U Ni) 71VI ~ 1 by IPi U Ni ~ k. Furthermore, I P i ~  VI = 1 holds for every i ~ I; otherwise (i.e., Pi M V = ~), ti (b (0)) == 1 holds for b (°) ~ F a, which is again a contradiction. Let us now define C = {j I{j} = P~ n V, i ~ I} ( c  V). Then this set C is a vertex cover, since for every a (h'l) E ~u, there exists a term ti such that P i n  V = {h} or {1}. Hence q9 ----- ~Pc holds for some vertex cover C __c_ V, and this implies (32) by applying a discussion similar to that of (31). t~ 5. Conclusion and discussion In this paper, we extensively studied three types of extensions, consistent, robust and most robust, for partially defined Boolean functions that contain missing bits. In Tables 1 and 2, we summarize their complexity results for the function classes C considered in this 254 E. Boros et al. / Artificial Intelligence 107 (1999) 219-263 Table 1 Complexity results for typical function classes (indicated in square brackets are where the proofs can be found) Function classes EXTENSION BEST-FIT General P 11 P 11 Positive P  11 P  11 Threshold P  1 l NPH 2 Horn P 11 NPH 11 RE CE MRE IAS(a)l <~ 1, V a E T U F General case IAS(a)t <~ 1, V a E T U F General case IAS(a)l <~ 1, V a E T U F General case P Cor.2, Th.3 P Th.4 P Th.19 P Th.3 NPC Th.5 NPH Th.5 P Cor.2, Cor.3 P Cor.3 P Cor.4 P Cor.3 P Cor.3 NPH Th.20 P Cor.2, Th.7 NPC Th.8 NPH Th.8 P Th.7 NPC Th.8 NPH Th.8 P Cot.2, Th.9 NPC Th.10 NPH Th.10 P Th.9 NPC Th.10 NPH Tb.10 G(So, G(St) )- decomposable P 8 NPH 11 P Cor.2 NPC Th.13 NPH Th.13 co-NPC THAI NPC Th.13 NPH Th. ll,13 Positive G(So, G(S1))- decomposable P8l NPH 11 P Cor.2, 3 P Cor.3 P Cor.3 P Cor.3 NPH Tb.21 NPH Tb.21 P: Polynomial, NPC: NP-complete, NPH: NP-hard, co-NPC: co-NP-complete. paper. More c o m p r e h e n s i v e  results can be found in  12, in which other function classes such as regular, unate, r e n a m a b l e  Horn, dual-minor, dual-major, self-dual, read-once and h - t e r m  k - D N F  are also discussed. Let us note at this point that a slightly modified definition of robust extension m a y  also deserve attention o n its own right. Instead of having a robust extension f ,  w h i c h is c o m m o n to all a s s i g n m e n t s ~  ~ ~AS, we define that a p B m b  (T, F )  is fully consistent with a class C if the p d B f  (T a, F ~) has an extension f~ b e l o n g i n g to C for every ~ ~ B As. This gives rise to the following problem. P r o b l e m FC(C) Input: A p B m b ( T ,  F ) ,  where T, F ___ 1VII n. Question: Is (T, F )  fully consistent in class C? Let us r e m a r k that a p B m b  m a y  be fully c o n s i s t e n t even if it has no robust extension. As an example, let us consider the p B m b  (T, F )  defined by = {(,, 1, 1, 1), (0, O, O, 0)1, ~7={(1, l, 1,0), (o, 1,0, 1), (0,0, ,,l)}, E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 255 Table 2 Complexity results for k-DNF classes (indicated in square brackets are where the proofs can be found) Function classes EXTENSION BEST-FIT (Positive) k-DNF NPC 11 NPH 1 l RE CE MRE IAS(a)I ~ 1, V a E T U F General case IAS(a)I <~ 1, V a E T U F General case NPC Cor. 1 NPC Cor. 1 NPH Col'. 1 NPC Cor. 1 IAS(a)I <~ 1, V a E T U F General case NPH Cor. 1 NPH Cor. 1 (Positive) I-DNF P ll NPH 11 P Cor.2, 3, Th.14 P Cor.3, Th.16 NPH Th.22 P Cor.3, Th.14 P Cor.3, Th.16 NPH Th.22 2-DNF P 11 NPH 1 l P Cor.2, Th. 14 NPC Th. 17 NPH Th. 17, 22 P Th.14 NPC Th.17 NPH Th.17, 22 Positive 2-DNF P 1l NPH 111 P Cor.2, 3 P Cor.3 P Cor.3 P Cor.3 NPH Th.22 NPH Th.22 k-DNF with fixed k ~> 3 Positive k-DNF with fixed k >~ 3 P I l l NPH 111 P Cor.2 NPC Th.17 NPH lTh.17, 22 co-NPC Th.15l NPC Th.17 NPH Th.15, 17, 22 P I l l NPH 11 P Cor.2, 3 P Cor.3 P Cor.3 P Cor.3 NPH Th.22 NPH Th.22 P: Polynomial, NPC: NP-complete, NPH: NP-hard, co-NPC: co-NP-complete. and let C = CTH be the class of threshold B o o l e a n  functions. There are two possible interpretations of the one missing bit, yielding T l  = {(1, 1, 1, 1), (0,0, 0, 0)}, T° = {0, 1, 1, 1), (0, 0, 0, 0)}. It is easy to verify that the threshold Boolean function defined b y  5Xl - 3x2 - 3x3 -q- 2x4/> 0 is an extension of the p d B f  (T l , / 7 ) ,  and that - 5 x l  + 2x2 + 2x3 - 3x4 > / 0  defines a threshold extension of (T ° , / ~ ) ,  Hence, this p B m b  is fully consistent with CTU. However, (T, F )  has no robust threshold extension, since the fractional vector (½, 23, 23, 2) belongs to the convex hulls of both T and F . It should also be noted that p r o b l e m s  RE(C) and FC(C) are equivalent for m a n y  other classes, such as general, positive, regular, Horn and k - D N E  These results are reported in 15. Finally, although this p a p e r  was written mainly f r o m  a theoretical viewpoint, these p r o b l e m s  had arisen f r o m  r e a l - w o r l d  applications, in which the sizes of such p B m b instances are usually large. Hence it would be important to develop fast heuristic algorithms for all the p r o b l e m s  discussed in this paper, particularly for the N P - h a r d  cases. A n  attempt in this direction is found in 10. 256 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 Acknowledgement The authors express their gratitude to the referees whose constructive comments helped significantly improve this paper. Appendix A. Proof of Theorem 5 Theorem 5. Problem CE(CalI) is NP-complete, even if AS(a) <, 2 holds for all a E T U F. Proof. Given an assignment a ~ ~AS, we can check in polynomial time if ( ~ u , / ~ )  has an extension in Call (see  11 ). Hence problem CE(CaH) belongs to NP. Let us now consider a cubic CNF m q~= A Ck, k--l Ck = (u~ v vk v w~), where u~, vk and wk for k = 1,2 . . . . .  m are literals from set L : {Xl,21 . . . . .  Xn,Xn}. The 3-SAT problem, i.e., deciding the existence of a binary vector y E {0, 1 }n for which qS(y) = l, is one of the well-known NP-complete problems (see 21). We shall associate to q~ a pBmd (T, F), as follows, which has a consistent extension in Calt if and only if the 3-SAT • = 1 has a solution. Let us introduce subsets Az = {PzL,Pz2}, z ~ L, and B~ : {qkl,qk2, qk3}, k : 1, 2 . . . .  , m, such that A z N L : B ~ N L = A z N B ~ : O , A z N A z , : O for z ~ z ~', and Bi N Bj : f~ for i ~ j. Let V : L ' J ( z ~ L A Z )  U(~-JBk)'k:I Let us denote by (R; S) the vector v 6 1VF for which ON(v) = R and AS(v) = {(v, j )  I J c S}. (Then OFF(v) = V \ (R u S), i.e., if S = 0, then v denotes a binary vector.) Let us construct T, F ___ 1VJ v by setting T :~q u:r2, ~=Y~ uP2, where T1 : {(r \ {x,,.~i}; {xi,xi}) lxi E t I U {((L \ {z}) U {Pzj}; ~ ) l z  E L, j ----- 1, 2}, E. Boros et al./ Artificial Intelligence 107 (1999) 219-263 257 a k = ((L \ aU~ 1 = ((L a uk2 = ((L a uk3 = ((L a uk4 = ((L {uk, ilk, vk, Vk, wk, if k}) tJ {qkl }; {qk2, qk3}) \ {"k}) U Auk; {qkl}) \ {uk, ilk, vk}) tO Auk tO {qkl}; {Vk}) \ {uk, ilk, v~, vk, wk) U Auk tO {qkl; {Wk}) \ {Uk, ik, Vk, Vk, Wk,/,bk }) U {Puke} U {qkl}; {Pukl}) = a vkl = ((L \ {Vk} ) El (qk2}; {qkl}) k = l , 2 . . . . .  m , a vk2 = ((L \ {vk, fJk, Wk}) U (qkl, qk2}; {Wk}) a vk3 --= ((L \ {Vk, fJk, Wk, ifk, uk}) U {qkl, qk2}; {uk}) a wkl = ((L \ {wk}) LI {qk3}; {qkl}) a wk2 ---- ((L \ {wk, ffok, uk}) to {qkl, qk3}; {uk}) a wk3 = ((L \ {wk, ifk, Uk, ik, Ok}) tJ {qkl,qk3}; {vk}) /~t = {(L; 0)} U {(L \ {xi,xi}; 0)Ixi E L} U {(L \ {z}; A z ) I z  E L}, b k = ((L \ {uk, ilk, vk, Ok, wk, tbk}) U Bk; 0) b ukl = ((L \ {Uk, ilk}) U Auk U {qkl}; {ik}) b uk2 -~ ((L \ {uk, ik, vk, Vk}) U au~ tJ {qkl}; {Ok}) b uk3 -~ ((L \ {uk, ik, Ok, fJk, Wk, tbk}) U Auk U {qkl}; {tbk}) b uk4 ----- ((L \ {Uk, Ftk, Vk, Ok, Wk, ifk}) El {qkl}; {Puk2}) b vkl -- ((L \ {vk}); {qk2}) = b vk2 -~- ((L \ {Vk, Ok}) tO {qkl, qk2}; {Ok}) k = l , 2 . . . . .  m b vk3 -~ ((L \ {Ok, vk, liCk, ifk}) tJ {qkl, qk2}; {ifk}) b vk4 = ((L \ {Vk, Ok, Wk, ifk, Uk, t~k}) I.J {qkl, qk2}; {ilk}) b wkl = ((L \ {Wk}); {qk3}) b wk2 -~- ( ( t  \ {11) k, tbk}) I j {qkl, qk3}; {ifk}) b wk3 -= ((L \ {Wk, if&, Uk, ik}) tJ {qkl, qk3}; {ilk}) b wk4 -=- ((L \ {Wk, ifk, Uk, ik, Vk, Vk}) U {qkl,qk3}; {Vk}) It is easy to verify that IAS(a)I <~ 2 holds for all a ~ T U F. T o  prove our claim, let us first assume that there exists a consistent extension f of (T, F), and show that q~ is satisfiable. Now (L \ {xi,xi}; {Xi,.~i}) E TI and (L; 0), 258 E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 (L \ {yi,-~i}; ~) E F1 imply that either f ( L  \ {xi}; 0) = 1 or f ( L  \ {£i}; 13) = 1 (or both) holds for each of i = 1, 2 . . . . .  n. Let us define a binary vector y ~ ~n by 110 if f(L\{xi};93)=O, otherwise, Yi = and show that this y satisfies q~(y) = 1. By the definition of y, Yi = 1 (respectively, Yi -~ O) implies f ( L  \ {xi}; 0) = 1 (respectively, f ( L  \ {xi}; 13) = 1). Assuming that there exists a clause Ck = (uk v v~ v Wk), which is 0, we derive a contradiction. (i) If Uk = 0, then f ( L  \ {uk}; 13) ----- 1. Therefore ((L \ {uk}); Au~) E F1 and ((L \ {Uk}) U {Pukj}; 0) ~ T1 for j = 1,2 implying T((L \ {Uk}) to Auk; 13) = O. (A. 1) Let us consider the sequence aukl( E T2), bUkl ( C F2) . . . . .  ctuk4( E T2), bUk4( E F2). Eq. (A.1) and a u~l c T2 imply f ( ( L  \ {u~}) tO Auk to {q~1}; 0) = 1, which also yields f ( ( L  \ {uk, tTk}) tO Aue U {qkl}; 13) = 0 by b uel E F2. By applying a similar argument, we have f ( (L \ tuk, Ftk, vk, Vk, wk, (ok }) to {qkl }; 13) = 0. (A.2) (ii) If vk = 0, then f ( L  \ {v~}; 13) = 1 nmst hold. Let us consider the sequence bY\l( E F2),avkl( E T2) . . . . .  ark3( E ~2), bY\4( E F2). Then f ( L  \ {vk}; 0) = 1 and b vkl E F2 imply f ( ( L  \ {v~) tO {qk2}; ~) = 0, from which f ( ( L  \ {vk }) tO {qkl, qk2}; 0) = 1 follows by a re1 c T2. By applying a similar argument, we have f ( ( L  \ {uk, ~k, Vk, fJi, Wk, tvk}) tO {qkl, qk2}; 0) = 0. (A.3) (iii) If w~ = 0, then similarly to (ii), we have f ( ( L  \ {uk, ilk, vk, f)k, wk, tbk}) tO {qkl,qk3}; ~) = 0 . (A.4) The three equations (A.2)-(A.4), and the fact that b k 6 F2 together imply that no binary assignment to the missing bits of a k 6 T2 can make it a true vector of f ,  contradicting the fact that f is a consistent extension of (T, F). For the converse direction, let y* E ~n be a satisfying solution to ~ ,  and let P o = { ( L \ { x i } ; O ) ly?=O, i = 1 , 2 . . . . .  n} U{(L \ {£i}; 13)Y* = 1, i = 1, 2 . . . . .  n} U { ( ( L \ { z } ) U { p z j } ; O ) z ¢ L , j =  1,2}. E. Boros et aL /Artificial Intelligence 107 (1999) 219-263 259 For each clause Ch ---- (uk v vk V wh), let us define sets Phi, Pk2 and Pk3 as follows. If uk = 1 holds for the assignment y*, then (ak) ' = ((L \ {uk, t~k, oh, vk, wh, tbk}) U {qkl}; O) (aUkl)' = ((L \ {Uh)) tO au~; 13) Pkl = (aUk2)t=((L\{uk, uh})LJJu~U{qkl};O ) k = l , 2 . . . . .  m ; (aUk3) ' = ((L \ {uk, Uk, Vk, Vk}) U Auk U {qkl}; 0) (aUk4) ' ---- ((L \ {Uk, th, Vk, Ok, tOk, lbk) U Auk t.3 {qkl; 13) otherwise let (a"~l)' = ((L \ {uh}) U Auk U {qkl}; 0) (aUk2) ' = ((L \ {Uh, t~h, vk}) U Auk U {qhl}; O) Pkl = k (aUk3)' = ((L \ {uh, uh, Vk, Oh, Wk}) U Auk U {qkl}; O) = 1, 2 . . . . .  m (aUk4) ' : ((L \ {Uk, Uk, Vk, Ok, Wk, tbk}) t J {Puk2} U {qkl}; 0) If Vk = holds for the assignment y*, then (ak) H : ((L \ {Uk, Uk, Ok, ~)k, Wk, ~)3k}) U {qkl, qk2}; 13) k Pk2= ( a V k l ) ' : ( ( L (ark2) ' = ((L \ {vh, ~k}) U {qkl,qk2}; 0) \ {Vk})U{qk2};13) = 1,2 . . . . .  m ; (ark3) ' ---- ((L \ {Vk, Vk, wh, tVk}) t0 {qkl, qk2}; 0) otherwise, (ark l ) , =  ((L \ {Vk )) U {qkl, qh2}; 9)) Pk2 = (ark Z) ' ((L \ {Vh, Ok, Wh }) LI {qkl, qk2}; O) Ik = 1,2 . . . . .  m (aOk3) ' ((L \ {vk, vk, wk, CVk, Uh}) U {qkl, qh2}; 0) Finally, if wh = 1 holds for the assignment y*, then let (a ) h i11 --= ((L \ {Uk, uk, Ok, Vk, Wk, 1Fk}) U {qkl, qk3}; - - (aWkl) ' = ((L \ {Wk}) U {qk3; 13) Pk3 = (aW~2) ' = ((L \ {wk, tbk}) U {qkl, qk3}; 13) (aWk3) ' : ((L \ {Wk, tOk, Uk, t~k}) t_J {qkl, qk3}; 0) otherwise set 13) k = 1 , 2  . . . . .  m (aWkl)' =- ((L \ {Wk}) U {qkl,qk3}; 0) Pk3 = (aWk2) ' = ((L \ {Wk, CVk, uh) U {qkl, qk3}; 13) Ik = 1 , 2  . . . . .  m . (aWk3) ' = ((L \ {Wk, tOk, Uh, (tk, Vk}) U {qkl,qk3}; 0)  260 E. Boros et al, /Artificial Intelligence 107 (1999) 219-263 Let us define a function f by 1 0 if a 6 P , otherwise, f ( a ) = where P ~- /90~U (Uk=l extension of (T, F). ( P k l m (_1 ek2 U Pk3)). We claim that this function f is a consistent It is easy to see that for every a e T1, there exists an assignment ~ e 1~ As(a) such that a ~ ¢ Po, and for every a e T2 \ {a k  k = 1, 2 . . . . .  m}, there exists an assignment a e NAS(a) such that a ~ = (a)'. Finally, since y* satisfies C/C = 1 for each a/c ~ T2, at least one of (a/c) ', (a/c)" or (ak) "' belongs to P, and hence f is a consistent extension of pBmd (7, 0). Let us show next that f is a consistent extension of (0; F). Let a 0 =  {(t; 0)} u {(t \ { x i , x i } ; O ) x i  G L} U {((L \ {xi}) U Axi" 0), (L \ {2i}; ~) lY = O,i = 1,2 . . . . .  n} U {(L \ {xi }; 0), ((L \ {Yi }) U A2i ; 0) Y? = 1, i -=-- 1,2 . . . . .  n } tO {b/C ¢ .F2 Ik = 1,2 . . . . .  m}. For each clause C/C = (uk V v/c v Wk), let us define sets Qkl, Qk2 and Qk3 as follows. If u/c = 1 holds for the assignment y*, then (bUkl) = ((L \ {Uk}) U Auk U {qkl}; 0) / Ok l --~ (bU~2)'=((L\{uk'u/c'vk})UA"~U{q/cl};O) (bUk3) ' = ((L \ {uk, {tk, vk, vk, wk}) U Auk U {qkl}; 0) O) k = l , 2 . . . . .  m  ; (bUk4) ' = ( (L \ {u/c, (t/c, v/c, f)k, w/C, tb/c}) U {P,,~2} U {qkl }; otherwise let I (bUkl)'=((L\{Uk,{tk})UAukU{qkl};O) i Qkl = (bUk2) ' = ((L \ {uk, tik, vk, fJk}) U Au~ U {qkl}; 0) (bUk3)' = ((L \ {uk, ilk, v/c, vk, Wk, tb/c}) U Auk U {qkl}; ~3) (bU~4) ' = ((L \ {Uk, {tk, V/C, O/C, Wk, tbk}) U {q/el}; 0) k = 1 , 2  . . . . .  m If vk = 1 holds for the assignment y*, then Qk2 = (bY\Z) ' = ((L \ {Vk}) U {qkl, qk2}; 0) (bY\3) ' = ((L \ {vk, Vk, Wk}) U {qkl, qk2}; ~1) (by*4) ' = ((L \ {vk, Vk, Wk, (ok, Uk}) U {qkl, qk2}; O) I (bVkl) = ((L \ {t,k}); 0) k = 1 , 2  . . . . .  m E. Boros et al. / Artificial Intelligence 107 (1999) 219-263 261 otherwise, Qk2 = (bVkl) ' = ((L \ {vk}) U {qk2}; 0) (bye2) ' = ((L \ {Vk, Vk}) U {qkl, qk2}; 13) (bVk3) ' = ((L \ {Vk, Vk, tOk, tbk}) U {qkl, qk2}; 0) (bVk4) ' : ((L \ {vk, ~3k, Wk, Wk, Uk, ilk}) U {qkt, qk2}; 0) k = l , 2 . . . . .  m Finally, if Wk = 1 holds for the a s s i g n m e n t  y*, then let (bU'kl)' = ((L \ {wk}); t3) (bU'k2) ' = ((L \ {wk}) U {qkl, qk3}; 13) ~ 13) k = 1 , 2 . . . . .  m ; Ok3 = I (bWk3) ' = ((L \ {wk, tbk, uk}) U {qkl, qk3}; 13) (bWk4) ' : ((L \ {Wk, tbk, Uk, {tk, rk}) U {qkl, qk3}; otherwise set Qk3 = (b wkl ) ' = ((L \ {Wk}) U {qk3}; 13) (bWk2) ' = ((L \ {Wk, tbk}) U {qkl, qk3}; 13) 13) k = 1,2 . . . . .  m (bWk3) ' : ((L \ {Wk, if)k, Uk, t~k}) U {qkl, qk3}; 13) (bW~4) ' : ((L \ {Wk, COk, Uk, ick, Vk, Vk}) U {qkl,qk3}; It is easy to see that for every b 6/71 U {b k k = 1 , 2 . . . . .  m}, there exists an a s s i g n m e n t a ~ (cid:127)AS(a) such that a ~ 6 Qo, and for every a c 172 \ {b k t k = 1, 2 . . . .  m}, there exists an is a consistent extension o f the p B m d assignment ~ c B AS(a) such that a u = (a)'. Hence f (0, F ) . Finally, let Q = Q0 u (Ukm__l (Q~I U Qk2 U Qk~)). Then P N Q -- 13 holds. Therefore, by is a consistent extension o f  the c o m b i n ~ g t h e  above two results, we can c o n c l u d e  that f p B m d  (T, F ) . R e f e r e n c e s 1  R. Agrawal, T. Imielinski, A. Swami, Mining association rules between sets of items in large databases, in: Proc. International Conference on Management of Data (SIGMOD-93), 1993, pp. 207-216. 2 E. Amaldi, V. Kasm, The complexity of approximability of finding maximum feasible subsystems of linear relations, Theoret. Comput. Sci. 147 (1995) 181-210. 3 D. Angluin, Queries and concept learning, Machine Learning 2 (1988) 319-342. 4 B. Apswall, M.E Plass, R.E.Tarjan, A linear-time algorithm for testing the truth of certain quantified Boolean formulas, Inform. Process. Lett. 8 (1979) 121-123. 5 R.L. Ashenhurst, The decomposition of switching functions, in: Proc. International Symposium on the Theory of Switching, Part I, Harvard University Press, Cambridge, MA, 1959, pp. 75-116. 6 S. Ben-David, E. Dichterman, Learning with restricted focus of attention, in: Proc. 6th Annual Workshop on Computational Learning Theory, 1993, pp. 287-296. 7 A. Blumer, A. Ehrenfeucht, D. Haussler, M.K. Warmuth, Occam's razor, Inform. Process. Lett. 24 (1987) 377-380. 262 E. Boros et al./Artificial Intelligence 107 (1999) 219-263 8 E. Boros, V. Gurvich, P.L. Hammer, T. Ibaraki, A. Kogan, Decompositions of partially defined Boolean functions, Discrete Appl. Math. 62 (1995) 51-75. 9 E. Boros, EL. Hammer, J.N. Hooker, Predicting cause-effect relationships from incomplete discrete observations, SIAM J. Discrete Math. 7 (1994) 531-543. 10 E. Boros, EL. Hammer, T. Ibaraki, A. Kogan, E. Mayoraz, I. Muchnik, An implementation of logical analysis of data, RUTCOR Research Report RRR 22-96, Rutgers University, Piscataway, NJ, 1996. 11 E. Boros, T. lbaraki, K. Makino, Error-free and best-fit extensions of a partially defined Boolean function, Inform. and Comput. 140 (1998) 254-283. 12 E. Boros, T. Ibaraki, K. Makino, Extensions of partially defined Boolean functions with missing data, RUTCOR Research Report RRR 06-96, Rutgers University, Piscataway, NJ, 1996. 13 E. Boros, T. Ibaraki, K. Makino, Boolean analysis of incomplete examples, in: R. Karlsson, A. Lingas (Eds.), Algorithm Theory--SWAT-96, Lecture Notes in Computer Science, Vol. 1097, Springer, Berlin, 1996, pp. 440-451. 14 E. Boros, T. Ibaraki, K. Makino, Monotone extensions of Boolean data sets, in: M. Li, A. Maruoka (Eds.), Algorithmic Learning Theory--ALT-97, Lecture Notes in Artificial Intelligence, Vol. 1316, Springer, Berlin, 1997, pp. 440--451. 15 E. Boros, T. Ibaraki, K. Makino, Working paper. 16 Y. Crama, P.L. Hammer, T. Ibaraki, Cause-effect relationships and partially defined Boolean functions, Ann. Oper. Res. 16 (1988) 299-326. 17 R. Dechter, J. Pearl, Structure identification in relational data, Artificial Intelligence 58 (1992) 237-270. 18 L. De Raedt, Logical settings for concept-learning, Artificial Intelligence 95 (1997) 187-201. 19 D.W. Dowling, J.H. Gallier, Linear-time algorithms for testing the satisfiability of propositional Horn formulae, J. Logic Programming 3 (1984) 267-284. 20 L.R. Ford, D.R. Fulkerson, Flows in Networks, Princeton University Press, Princeton, NJ, 1962. 21 M.R. Garey, D.S. Johnson, Computers and Intractability, Freeman, New York, 1979. 22 S.A. Goldman, S.S. Kwek, S.D. Scott, Learning from examples with unspecified attribute values, in: Proc. COLT-97, 1997, pp. 231-242. 23 R. Greiner, A. Grove. A. Kogan, Exploiting the omission of irrelevant data, Artificial Intelligence 97 (1997) 345-380. 24 D. Kavvadias, C.H. Papadimitriou, M. Sideri, On Horn envelopes and hypergraph transversals, in: K.W. Ng et al. (Eds.), Algorithms and Computation~ISAAC-93, Lecture Notes in Computer Science, Vol. 762, Springer, Berlin, 1993, pp. 399-405. 25 R. Khardon, D. Roth, Learning to reason with a restricted view, in: Proc. COLT-95, 1995, pp. 301-310. 26 K. Makino, K. Hatanaka, T. Ibaraki, Horn extensions of a partially defined Boolean function, RUTCOR Research Report RRR 27-95, Rutgers University, Piscataway, N J, 1995; also: SIAM J. Comput. (to appear). 27 K. Makino, K. Yano, T. Ibaraki, Positive and Horn decomposability of partially defined Boolean functions, Discrete Appl. Math. 74 (1997) 251-274. 28 O.L. Mangasarian, R. Setiono and W.H. Wolberg, Pattern recognition via linear programming: Theory and applications to medical diagnosis, in: T.E Coleman, Y. Li (Eds.), Large-Scale Numerical Optimization, SIAM, Philadelphia, PA, 1990, pp. 22-30. 29 H. Mannila, H. Toivonen, A.I. Verkamo, Efficient algorithms for discovering association rules, in: U.M. Fayyad, R. Uthurusamy (Eds.), AAAI Workshop on Knowledge Discovery in Database, Seattle, WA, 1994, pp. 181-192. 30 S. Muroga, Threshold Logic and Its Applications, Wiley-Interscience, New York, 1971. 31 EM. Murphy, D.W. Aha, UCI Repository of machine learning databases http://www.ics.uci.edu/-mlearn/ MLReposilory.html, University of California, Department of Information and Computer Science, Irvine, CA, 1994. 32 L. Pitt, L.G. Valiant, Computational limitations on learning from examples, J. ACM 35 (1988) 965-984. 33 J.S. Provan, M.O. Ball, Efficient recognition of matroids and 2-monotonic systems, in: R. Ringeisen, E Roberts (Eds.), Applications of Discrete Mathematics, SIAM, Philadelphia, PA, 1988, pp. 122-134. 34 J.R. Quinlan, Induction of decision trees, Machine Learning 1 (1986) 81-106. 35 K.G. Ramamurthy, Coherent Structures and Simple Games, Kluwer Academic Publishers, Dordrecht, Netherlands, 1990. E. Boros et al. /Artificial Intelligence 107 (1999) 219-263 263 36 D. Roth, Learning to reason: The non-monotonic case, in: Proc. IJCAI-95, Montreal, Quebec, 1995, pp. 1178-1184. 37 D. Schuurmans, R. Greiner, Learning default concepts, in: Proc. 20th Canadian Conference on Artificial Intelligence (CSCSI-94), 1994. 38 L.G. Valiant, A theory of the learnable, Comm. ACM 27 (1984) 1134-1142. 39 L.G. Valiant, Rationality, in: Proc. Workshop on Computational Learning Theory (COLT-95), 1995, pp. 3-14. 