Artificial Intelligence 235 (2016) 1–25Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintA formalization of programs in first-order logicwith a discrete linear orderFangzhen LinDepartment of Computer Science, The Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Konga r t i c l e i n f oa b s t r a c tArticle history:Received 17 December 2014Received in revised form 23 August 2015Accepted 28 January 2016Available online 11 February 2016Keywords:Program semanticsReasoning about programsFirst-order logicWe consider the problem of representing and reasoning about computer programs, and propose a translation from a core procedural iterative programming language to first-order logic with quantification over the domain of natural numbers that includes the usual successor function and the “less than” linear order, essentially a first-order logic with a discrete linear order. Unlike Hoare’s logic, our approach does not rely on loop invariants. Unlike the typical temporal logic specification of a program, our translation does not require a transition system model of the program, and is compositional on the structures of the program. Some non-trivial examples are given to show the effectiveness of our translation for proving properties of programs.© 2016 Elsevier B.V. All rights reserved.1. IntroductionIn computer science, how to represent and reason about computer programs effectively has been a major concern since the beginning. For imperative, non-concurrent programs that we are considering here, notable approaches include Dijkstra’s calculus of weakest preconditions [1,2], Hoare’s logic [3], dynamic logic [4], and separation logic [5]. For the most part, these logics provide rules for proving assertions about programs. In particular, for proving assertions about iterative loops, these logics rely on what have been known as Hoare’s loop invariants. In this paper, we propose a way to translate a program to a first-order theory with quantification over natural numbers. The properties that we need about natural numbers are that they have a smallest element (zero), are linearly ordered, and each of them has a successor (plus one). Thus we are essentially using first-order logic with a predefined discrete linear order. This logic is closely related to linear temporal logic, which is a main formalism for specifying concurrent programs [6].Given a program, we translate it to a first-order theory that captures the relationship between the input and output values of the program variables, independent of what one may want to prove about the program. For instance, trivially, the following assignmentX = X+Ycan be captured by the following two axioms:(cid:2) = X + Y ,(cid:2) = Y ,XYE-mail address: flin@cs.ust.hk.http://dx.doi.org/10.1016/j.artint.2016.01.0140004-3702/© 2016 Elsevier B.V. All rights reserved.2F. Lin / Artificial Intelligence 235 (2016) 1–25where X and Y denote the initial values of the corresponding program variables and Xtheir values after the statement is performed. Obviously, the question is how the same can be done for loops. This is where quantification over natural numbers comes in. Consider the following while loopand Y(cid:2)(cid:2)while X < M do { X = X+1 }It can be captured by the following set of axioms:(cid:2) = X,(cid:2) = X(N),(cid:2) = M,MX ≥ M → XX < M → XX(0) = X,∀n.X(n + 1) = X(n) + 1,X(N) ≥ M,∀n.n < N → X(n) < M,where N is a natural number constant denoting the total number of iterations that the loop runs to termination, and X(n)the value of X after the nth iteration. Thus the third axiom says that if the program enters the loop, then the output value of the program variable X , denoted by X, is X(N), the value of X when the loop exits.The purpose of this paper is to describe how this set of axioms can be systematically generated, and show by some examples how reasoning can be done with this set of axioms. Without going into details, one can already see that unlike Hoare’s logic, our axiomatization does not make use of loop invariants. One can also see that unlike typical temporal logic specification of a program, we do not need a transition system model of the program, and do not need to keep track of program execution traces. We will discuss related work in more detail later.(cid:2)2. PreliminariesWe use a typed first-order language. We assume a type for natural numbers (non-negative integers). Depending on the programs, other types such as integers may be used. For natural numbers, we use constant 0, linear ordering relation <(and ≤), successor function n + 1, and predecessor function n − 1. We follow the convention in logic to use lower case letters, possibly with subscripts, for logical variables. In particular, we use m and n for natural number variables, and x, y, and z for generic variables. The variables in a program will be treated as functions in logic, and written as either upper case letters or strings of letters.We use the following shorthands. The conditional expression:e1 = if ϕ then e2 else e3is a shorthand for the conjunction of the following two sentences:∀(cid:7)x.ϕ → e1 = e2,∀(cid:7)x.¬ϕ → e1 = e3,where (cid:7)x are all the free variables in ϕ and ei , i = 1, 2, 3. Typically, all free variables in ϕ occur in e1.Our most important shorthand is the following expression which says that e is the smallest natural number that satisfies ϕ(n):smallest(e, n, ϕ)is a shorthand for the following formula:ϕ(n/e) ∧ ∀m.m < e → ¬ϕ(n/m),where n is a natural number variable in ϕ, m a new natural number variable not in e or ϕ, ϕ(n/e) the result of replacing n in ϕ by e, similarly for ϕ(n/m). For example, smallest(M, k, k < N ∧ found(k)) says that M is the smallest natural number such that M < N ∧ found(M):M < N ∧ found(M) ∧ ∀n.n < M → ¬(n < N ∧ found(n)).Finally, we use the convention that free variables in a displayed sentence are implicitly universally quantified from outside. For instance, the following displayed formulan < M → ¬(n < N ∧ found(n))F. Lin / Artificial Intelligence 235 (2016) 1–253stands for ∀n.n < M → ¬(n < N ∧ found(n)), where the universal quantification is over the domain of natural numbers as nis a natural number variable. Notice however, in the macro smallest(M, k, k < N ∧ found(k)), k is not a free variable.The following are some useful properties about the smallest macro.Proposition 1. Let (cid:7)x be the free variables other than n in ϕ(n), and m a variable not in ϕ(n). We have that∀(cid:7)x.∃nϕ(n) → ∃m.smallest(m, n, ϕ(n)).Proposition 2. Let (cid:7)x be the free variables other than n in ϕ(n), and m a variable not in ϕ(n). We have that∀(cid:7)x, m.[smallest(m, n, ϕ(n)) ∧ m > 0] → [ϕ(m) ∧ ¬ϕ(m − 1)].Furthermore,∀(cid:7)x{∃n[(∀k.k > n → ϕ(k)) ∧ (∀k.k ≤ n → ¬ϕ(k))] →∀m[smallest(m, n, ϕ(n)) ≡ ϕ(m) ∧ ¬ϕ(m − 1)]},where k is a variable not in ϕ(n).Proof. For any given (cid:7)x and m, suppose smallest(m, n, ϕ(n)) ∧ m > 0. Then ϕ(m) and ∀k.k < m → ¬ϕ(k). Since m > 0, thus ¬ϕ(m − 1). Now suppose that ϕ(m) ∧ ¬ϕ(m − 1) and for some M,[(∀k.k > M → ϕ(k)) ∧ (∀k.k ≤ M → ¬ϕ(k))].This means that M = m − 1, and smallest(m, n, ϕ(n)). (cid:2)To motivate our next proposition, consider again the following loopwhile X < M do { X = X+1 }Given input M, the number N(M) of the iterations for this loop to exit is captured by the formula smallest(N(M), n, ¬ X(n) <M). It can be seen that N(M + 1) = N(M) + 1, i.e. the number of iterations before the loop exits on input M + 1 is one more than that of on input M. This can be proved using the following proposition.Proposition 3. Let (cid:7)x be the free variables other than n in ϕ1(n) and ϕ2(n), and m1, m2, k and t variables not in ϕ1 or ϕ2. We have∀(cid:7)x, t, m1, m2.[∀k(ϕ1(k) ≡ ϕ2(k + t)) ∧ ∀k(k < t → ¬ϕ2(k)) ∧smallest(m1, n, ϕ1(n)) ∧ smallest(m2, n, ϕ2(n))] →m2 = m1 + t3. A simple class of programsConsider the following simple class of programs P constructed from a set of array identifiers array, a set of functions operator, and a set of Boolean operators boolean-op:E ::= array(E,...,E) |operator(E,...,E)B ::= E = E |boolean-op(B,...,B)P ::= array(E,...,E) = E |if B then P else P |P; P |while B do PHere E denotes expressions, B boolean expressions, and P programs. Notice that instead of, for example “array[i][j]” commonly used in programming languages to refer to an array element, we use the notation “array(i,j)” more com-monly used in mathematics and logic.As one can see, programs here are constructed using assignments, sequences, if-then-else, and while loops. Other con-structs such as if-then and for-loop can be defined using these constructs. For instance, “if B then P” can be defined as “if B then P else X = X”.We assume a base first-order language L that contains functions and predicates that are static in the sense that their semantics are fixed and cannot be changed by programs. They include functions that correspond to operator, predicates 4F. Lin / Artificial Intelligence 235 (2016) 1–25that correspond to boolean-op, and possibly other functions and predicates for formalizing the domain knowledge. In the following, we call L the base language.Given a program P , we extend the base language L by functions to represent program variables in the program. These functions are dynamic in that their values may be changed during the execution of a program. We assume that program variables are new, not already used in L. We also assume that there is no overloading so that two different program variables cannot have the same name but different arities. Thus we can use the same program variables as functions in our first-order language. Specifically, if V is a program variable for an n-ary array, then we add V and Vas new n-ary (cid:2)(x1, ..., xn) denote the values of the (x1, ..., xn)th cell in V at the input and the output, functions to L: V (x1, ..., xn) and Vrespectively, of the program P . For their values during the execution of P , we’ll introduce temporary function symbols to denote them. These temporary function symbols can be systematically named using statement labels (see Section 6 below) and are useful when one is interested about properties that hold during the execution of a program. For now, we assume that we are interested only in the program outputs.Given a program P and a set (cid:7)X of program variables including all variables used in P , we define inductively the set of (cid:2)axioms for P and (cid:7)X , written (cid:3)(cid:7)XP , as follows:• If P isV(E1,...,Ek) = Ethen (cid:3)(cid:7)XP consists of following axioms that say that only the value of V(E1,...,Ek) is possibly changed:(cid:2)V((cid:7)x) = if (x1 = E 1 ∧ · · · ∧ xk = Ek) then Eelse V ((cid:7)x),(cid:2)((cid:7)y) = X((cid:7)y), X ∈ (cid:7)X and X different from VXwhere (cid:7)x = (x1, ..., xk), and k is the arity of the program variable (array) V . We assume here that for each program expression E, there is a corresponding term E in our first-order language. Recall that by our convention, these variables are universally quantified. The domains of these variables depend on the type of the program variable V .• If P isif B then P1 else P2then (cid:3)and (cid:3)(cid:7)XP 2as follows:(cid:7)X(cid:7)XP is constructed from (cid:3)P 1(cid:7)X,P 1(cid:7)X¬B → ϕ, for each ϕ ∈ (cid:3)P 2B → ϕ, for each ϕ ∈ (cid:3).We assume here that for each boolean expression B, there is a corresponding formula B in our first-order language.• If P isP1; P2then (cid:3)and (cid:3)(cid:7)X(cid:7)XP is constructed from (cid:3)P 1(cid:7)Xϕ( (cid:7)X (cid:2)/ (cid:7)Y ), for each ϕ ∈ (cid:3)P 1(cid:7)Xϕ( (cid:7)X/ (cid:7)Y ), for each ϕ ∈ (cid:3)P 2,,(cid:7)XP 2by connecting the outputs of P 1 with the inputs of P 2 as follows:(cid:2)where (cid:7)Y = (Y 1, ..., Yk) is a tuple of new function symbols such that each Y i is of the same arity as Xi in (cid:7)X , ϕ( (cid:7)X (cid:2)/ (cid:7)Y ) is i by Y i , and similarly for ϕ( (cid:7)X/ (cid:7)Y ). The new function symbols in (cid:7)Y are the result of replacing in ϕ each occurrence of Xcalled temporary functions and used to denote the values of program variables during the execution of the program. By our inductive construction, (cid:3)may already have some temporary function symbols introduced this way. Furthermore, if P 1 and/or P 2 have loops, then they may also have some new natural number constants (see below for how axioms are constructed for while loops). By renaming if necessary, we assume here that (cid:3)do not have only common symbols from share any of these temporary symbols. In other words, we assume that (cid:3)L ∪ (cid:7)X ∪ (cid:7)Xand (cid:3)and (cid:3)and (cid:3)(cid:7)XP 1(cid:7)XP 2(cid:7)XP 2(cid:7)XP 1(cid:7)XP 2(cid:7)XP 1.(cid:2)• If P iswhile B do P1F. Lin / Artificial Intelligence 235 (2016) 1–255(cid:7)XP is constructed by adding an index parameter n to all dynamic functions in (cid:3)Then (cid:3)the body P 1 has been executed n times. Formally, it consists of the following axioms:(cid:7)XP 1to record their values after (cid:7)XP 1,ϕ[n], for each ϕ ∈ (cid:3)Xi((cid:7)x) = Xi((cid:7)x, 0), for each Xi ∈ (cid:7)Xsmallest(N, n, ¬B[n]),i((cid:7)x) = Xi((cid:7)x, N), for each Xi ∈ (cid:7)XX(cid:2)(cid:7)XP 1where n is a new natural number variable not already in ϕ, and N a new natural number constant not already used in and for each formula or term α, α[n] denotes the value of α after the body P 1 has been executed n times, and is (cid:3)obtained from α as follows:1. (∃xα)[n] is ∃x(α[n]), (α1 ∨ α2)[n] is α1[n] ∨ α2[n], and (¬α)[n] is ¬(α[n]).2. F (e1, ..., ek)[n] is F (e1[n], ..., ek[n]) if F is a predicate or a function in the base first-order language L. In particular, (cid:2)(e1 = e2)[n] is e1[n] = e2[n].i(e1, ..., ek)[n] is Xi(e1[n], ..., ek[n], n + 1), if Xi is in (cid:7)X .3. X4. V (e1, ..., ek)[n] is V (e1[n], ..., ek[n], n), if V is a non-primed function not in L.While we have used (cid:3)(cid:7)XP to denote “the” set of axioms for P and (cid:7)X , the construction above does not yield a unique set of axioms as the temporary functions introduced when constructing axioms for program sequences and while-loops are not (cid:7)Xunique. However, (cid:3)P is unique up to the renaming of these new functions. In particular, any two different sets of these axioms are logically equivalent when considering only program variables from (cid:7)X , i.e. when the temporary functions are “forgotten”. More precisely, given two theories (cid:5)1 and (cid:5)2, we say that they are equivalent when considering a subset (cid:6) of their vocabularies if any model M1 of (cid:5)1 can be modified into a model M2 of (cid:5)2 such that M1 and M2 agree on (cid:6), and conversely any model of (cid:5)2 can be similarly modified into a model of (cid:5)1.(cid:7)XP under an operational semantics. In the following, we give some simple prop-Appendix A proves the correctness of (cid:3)erties about our axiomatization.The following proposition says that a program is local, in that it has effects only on variables in it.Proposition 4. Let (cid:7)Y be a tuple of program variables that are not in P and not used in (cid:3)equivalent to the union of (cid:3)(cid:7)XP and the set of following “frame axioms”:(cid:7)XP . Then considering only (cid:7)X ∪ (cid:7)Y , (cid:3)(cid:7)X∪ (cid:7)YPis (cid:2)((cid:7)y) = Y ((cid:7)y), for each Y ∈ (cid:7)YYThe construction rule for a sequence P ; Q can also be modified so that temporary functions only need to be introduced for those that occur in both P and Q .Proposition 5. Let (cid:7)X be a tuple of program variables including those used in either P or Q , and (cid:7)V = (V 1, ..., V k) the tuple of program variables used in both P and Q (thus a subset of (cid:7)X). When considering only (cid:7)X , (cid:3)(cid:7)XP ;Q is equivalent to the set of following axioms:(cid:7)Xϕ( (cid:7)V (cid:2)/ (cid:7)Y ), for each ϕ ∈ (cid:3)P ,(cid:7)Xϕ( (cid:7)V / (cid:7)Y ), for each ϕ ∈ (cid:3)Q ,where (cid:7)Y = (Y 1, ..., Yk) is a tuple of temporary functions such that each Y i is of the same arity as V i in (cid:7)V . Again we assume that, by renaming if necessary, (cid:3)(cid:7)XQ have no common function symbols other than those in (cid:7)X or in the base language L.(cid:7)XP and (cid:3)The following important property about our axiomatization says that we do not need to wait until we have the full set of axioms to do simplification. During the construction of the axioms for a program, we can simplify first the axioms for its subprograms. This greatly simplifies the above recursive procedure for constructing axioms of a program.Proposition 6. Let (cid:7)X be a tuple of program variables, including all those that occur in program P . For any subprogram P(cid:7)XP (cid:2) when considering only (cid:7)X , then if we use T instead of (cid:3)equivalent to (cid:3)when considering only (cid:7)X as well.(cid:7)XP , the resulting theory is equivalent to (cid:3)(cid:7)XP (cid:2) in computing (cid:3), if T is (cid:7)XP(cid:2)Notice that in the above proposition, when we use T instead of (cid:3)(cid:7)XP , we assume that we will also rename temporary function symbols when necessary to avoid name conflicts. For example, if P is P 1; P 2, and a theory equivalent to (cid:3)in computing (cid:3)(cid:7)XP (cid:2)(cid:7)XisP 1(cid:2) = Y ∧ Y = X + 1.X(1)6F. Lin / Artificial Intelligence 235 (2016) 1–25also uses the temporary function symbol Y , then we need to rename either the Y in (1) or the Y in (cid:3)(cid:7)XP 2when (cid:7)XP 2If (cid:3)constructing (cid:3)(cid:7)XP .Before we consider more interesting examples, we illustrate our construction of (cid:3)3.1. A simple sequence(cid:7)XP using two simple programs.Consider the following program P and two program variables X1 and X2 (notice that X1 is used in P , but X2 is not):X1 = 1; X1 = X1+1(cid:3)( X1, X2)X1=1is the set of the following two sentences(cid:2)1(cid:2)2XX= 1,= X2and (cid:3)( X1, X2)X1= X1+1 the set of following two sentences:(cid:2)1(cid:2)2XX= X1 + 1,= X2Thus (cid:3)( X1, X2)PisY 1 = 1,Y 2 = X2,(cid:2)1(cid:2)2XX= Y 1 + 1,= Y 2Eliminating the temporary constants Y 1 and Y 2, we get X(cid:2)1= 2 and X(cid:2)2= X2.3.2. A simple loopConsider the following program P with a simple loop.while I < N doif X < A(I) then X = A(I);I = I+1Notice that the program variables are X , A, I , and N. Among them, A is unary (a list), and the rest are 0-ary (constants).is equivalent to the set of following sentences (up to the choice of temporary Let P 1 be the body of the loop. (cid:3)( X, A,I,N)P 1names Y 1, Y 2, Y 3, Y 4):Y 1 = if X < A(I) then A(I) else X,Y 2(x) = if X < A(I) then A(x) else A(x),Y 3 = if X < A(I) then I else I,Y 4 = if X < A(I) then N else N,(cid:2) = Y 1,(cid:2)(x) = Y 2(x),A(cid:2) = Y 3 + 1,(cid:2) = Y 4.NXIInstead of using this set to compute (cid:3)( X, A,I,N)get the following equivalent set of axioms:P, by Proposition 6, we can simplify it first by eliminating Y 1, Y 2, Y 3, Y 4, and F. Lin / Artificial Intelligence 235 (2016) 1–257X(cid:2) = if X < A(I) then A(I) else X,(cid:2)(x) = A(x),A(cid:2) = I + 1,(cid:2) = N.NThus (cid:3)( X, A,I,N)PisIX(0) = X,A(x, 0) = A(x),I(0) = I,N(0) = N,X(n + 1) = if X(n) < A(I(n), n) then A(I(n), n)else X(n),A(x, n + 1) = A(x, n),I(n + 1) = I(n) + 1,N(n + 1) = N(n),smallest(M, n, ¬I(n) < N(n)),X(cid:2) = X(M),(cid:2)(x) = A(x, M),A(cid:2) = I(M),(cid:2) = N(M).NIClearly A(x) and N do not change: A(x, n) = A(x) and N(n) = N. So we get the following sentences by expanding the smallest macro:X(0) = X,I(0) = I,X(n + 1) = if X(n) < A(I(n)) then A(I(n))else X(n),I(n + 1) = I(n) + 1,I(M) ≥ N,n < M → I(n) < N,X(cid:2) = X(M),(cid:2)(x) = A(x),A(cid:2) = I(M),(cid:2) = N.NINow suppose that initially I = 0. Solving the recurrence:I(0) = 0,I(n + 1) = I(n) + 1we have I(n) = n. Thus we haveM ≥ N,n < M → n < N,which imply that M = N. So we can eliminate I(n) and M and get the following axioms:8F. Lin / Artificial Intelligence 235 (2016) 1–25X(0) = X,X(n + 1) = if X(n) < A(n) then A(n)else X(n),X(cid:2) = X(N),(cid:2)(x) = A(x),A(cid:2) = N,(cid:2) = N.NIAn example assertion to prove about the program is the following0 ≤ n < N → X(cid:2) ≥ A(n),which is equivalent to0 ≤ n < N → X(N) ≥ A(n),(2)which can be proved by induction on N. The base case of N = 0 is trivial. For the inductive case, suppose the result holds for N = K . Let N = K + 1. There are two cases to consider: X(K ) < A(K ) and X(K ) ≥ A(K ). We show the first case here. The second case is similar. In the first case, X(K + 1) = A(K ) and we need to show that0 ≤ n < K + 1 → A(K ) ≥ A(n).Two cases for 0 ≤ n < K + 1: 0 ≤ n < K or n = K . The second case is trivial. For the first case, A(K ) ≥ A(n) follows from the inductive assumption and that X(K ) < A(K ).3.3. Partial and total correctnessA program is partially correct w.r.t. a specification if the program satisfies the specification when it terminates. It is totally correct if it is partially correct and terminates.(cid:2)from (cid:3)In our framework, a program P with variables (cid:7)X is represented by a set of sentences, (cid:3)(cid:7)XP . Whatever properties that one wants to show about P are proved using this set of sentences. A partial correctness result corresponds to proving a sentence (cid:7)Xabout (cid:7)X and (cid:7)XP . An example is the assertion (2) above for the simple loop. On the other hand, termination of a program is proved by showing that the new natural number constants introduced by the loops and used in the smallest(cid:7)Xmacro expressions are well-defined, which in logic means that the resulting theory (cid:3)P is consistent, thus there is a model where the new constants are mapped to natural numbers. For instance, for the above simple loop, the smallest macro is smallest(M, n, ¬I(n) < N(n)). By Proposition 1 and the fact that I(N) ≥ N holds, it can be verified that the theory is consistent because there is indeed a natural number M that satisfies this macro expression.If a loop does not terminate, then its smallest macro will cause a contradiction. For instance, consider the following loop:while I < M doif I>0 then I = I+1.If initially I = 0 and M > 0, then it will loop forever. Our axioms for the loop are:(cid:2) = I(N) ∧ M(cid:2) = M,II(0) = I,I(n + 1) = if I(n) > 0 then I(n) + 1 else I(n),n < N → I(n) < M,I(N) ≥ M.If we add I = 0 ∧ 0 < M to these axioms, we will conclude ∀n.I(n) < M, which contradicts the last axiom I(N) ≥ M. Of course in logic, this also means that the axioms for the loops will entail that ¬(I = 0 ∧ 0 < M), which can be taken as a pre-condition of the loop.F. Lin / Artificial Intelligence 235 (2016) 1–2594. Related workOur formalization of the simple loop above also illustrates the difference between our approach and Hoare’s logic, ar-guably the dominant approach for reasoning about non-parallel imperative computer programs. To begin with, an assertion like (2) would be represented by a triple like{I = 0}P {∀m(0 ≤ m < N → X ≥ A(m))}in Hoare’s logic. To prove this assertion, one would need to find a suitable “loop invariant”, a formula that if true initially will continue to be true after each iteration. In general, there are infinite number of such loop invariants. The key is to find one that, in conjunction with the negation of the loop condition, can entail the postcondition in the assertion. For this simple loop, the following is such a loop invariant:∀m(I0 ≤ m < I → X ≥ A(m)).Finding suitable loop invariants is at the heart of Hoare’s logic, and it is not surprising that there has been much work on discovering loop invariants (e.g. [7–11]).In comparison, our proof of (2) uses ordinary mathematical induction and recurrences on I(n) and X(n). See Appendix Bfor more details.Another difference between our approach and Hoare’s logic is that Hoare’s logic is a set of general rules about program assertions, while we provide a translation from programs to first-order theories with quantification over natural numbers. Once the translation is done, assertions about it are proved with respect to the translated first-order theory, without ref-erence to the original program. This is similar to Pnueli’s temporal logic approach to program semantics [6]. According to a common classification used in the formal methods community (cf. [12,13]): approaches like Hoare’s logic and dynamic logic are exogenous in that they have programs explicitly in the language, while in the temporal logic approach, program semantics is typically endogenous in that a fixed program is often assumed and a program execution counter is part of the specification language. Our approach is certainly not exogenous. It is a little endogenous as we use natural numbers to keep track of loop iterations, but not as endogenous as typical temporal logic specifications which requires program counters to be part of states. In particular, our mapping from programs to theories is compositional, built up from the structure of the program. Barringer et al. [14] proposed a compositional approach using temporal logic, but only in the style of Hoare’s logic, using Hoare triples. However, a caveat is that so far the temporal logic approach to program semantics have been mainly for concurrent programs, while what we have proposed is for non-parallel programs. Given the close relationship between temporal logics and first-order logic with a linear order, if there are no nested loops, then our translation can be reformulated in a temporal logic. It is hard to see how this can be done when there are nested loops, as this will lead to nested time lines, modeled here by predicates with multiple natural number arguments. Of course, one can always construct a transition graph of a program, and model it in a temporal logic. But then the structure of the original program is lost.We are certainly not the first to use first-order logic with a linear order to model dynamic systems. For instance, it has been used to model Turing machines in the proof of Trakhtenbrot’s theorem in finite model theory (see, e.g. [15]).A closely related work is Charguéraud’s characteristic formulas for functional programs [16,17]. However, these formulas are higher-order formulas that reformulate Hoare’s rules by quantifying over preconditions and postconditions.Our use of natural numbers as “indices” to model iterations is similar to Wallace’s use of natural numbers to model rule applications in his semantics for logic programs [18].While we use natural numbers to formalize loops, Levesque et al. [19] used second-order logic to capture Golog programs with loops in the situation calculus. Recently, Lin [20] showed that under the foundational axioms of the situation calculus, Golog programs can be defined in first-order logic as well. However, the crucial difference between the work here and the work in the situation calculus on Golog is that our axioms try to capture the changes of states in terms of values of program variables, while the semantics of Golog programs is more about defining legal sequences of executions. To illustrate the difference here, consider a program that consists of assignments that make no change (nil actions). For this program, it would still be non-trivial to define sequences of legal executions, although it does not matter which sequences are legal as none of them change the values of program variables. Another difference is that we consider only assignments and deterministic programs, while Golog programs allow any actions that can be axiomatized by successor state axioms, and can have nondeterministic choices.5. Cohen’s integer division algorithmFor a more complex example, consider the following program P which implements the well-known Cohen’s integer division algorithm [21] (our program below is adapted from [11]). It has two loops, one nested inside another. The program variables are A, B, Q , R, X, Y , where X and Y are inputs, and Q is the output. Let (cid:7)X = ( A, B, Q , R, X, Y ). There are two (cid:7)Xloops. Let’s name the inner loop Inner, and outer loop Outer. When computing (cid:3)P , we again consider only equivalence under (cid:7)X and use Proposition 6 to simplify the process.10F. Lin / Artificial Intelligence 235 (2016) 1–25// X and Y are two input integers; Y > 0Q=0; // quotientR=X; // remainderwhile (R >= Y) do {A=1; // A and B are some that at any time forB=Y; // some n, A=2^n and B=2^n*Ywhile (R >= 2*B) do {A = 2*A;B = 2*B;}R = R-B;Q = Q+A}// return Q = X/Y;It is easy to see that (cid:3)(cid:7)XP is equivalent to (cid:3)(cid:7)XOuter∪ {Q = 0, R = X}. To compute (cid:3)(cid:7)XOuter, we compute first (cid:3)(cid:7)XInner, which is equivalent to the set of following sentences:A(n + 1) = 2 A(n),B(n + 1) = 2B(n),Q (n + 1) = Q (n),R(n + 1) = R(n),X(n + 1) = X(n),Y (n + 1) = Y (n),A(0) = A,B(0) = B,Q (0) = Q ,R(0) = R,X(0) = X,Y (0) = Y ,BAsmallest(N, n, R(n) < 2B(n)),(cid:2) = A(N),(cid:2) = B(N),(cid:2) = Q (N),Q(cid:2) = R(N),(cid:2) = X(N),(cid:2) = Y (N).XRYSolving the recurrences, we haveA(n) = 2n A,B(n) = 2n B,Q (n) = Q ,R(n) = R,X(n) = X,Y (n) = Ysmallest(N, n, R < 2n+1 B),(cid:2) = 2N A,A(cid:2) = 2N B,BF. Lin / Artificial Intelligence 235 (2016) 1–2511R(cid:2) = Q ,Q(cid:2) = R,(cid:2) = X,(cid:2) = Y .XYWe can now eliminate terms like A(n) and B(n), expand the smallest macro expression, and obtain (cid:3)following sentences:(cid:7)XInner as the set of R < 2N+1 B,m < N → R ≥ 2m+1 B,BA(cid:2) = 2N A,(cid:2) = 2N B,(cid:2) = Q ,Q(cid:2) = R,(cid:2) = X,(cid:2) = Y .XRYThus the set of sentences for the body of the loop Outer is equivalent to the set of the following sentences:R < 2N+1Y ,m < N → R ≥ 2m+1Y ,(cid:2),BA(cid:2) = 2N ,(cid:2) = 2N Y ,(cid:2) = Q + AQ(cid:2)(cid:2) = R − B(cid:2) = X,(cid:2) = Y .XR,Y(cid:7)XOuterThus (cid:3)∪ {Q = 0, R = X} is equivalent toR(n) < 2N(n)+1Y (n),m < N(n) → R(n) ≥ 2m+1Y (n),A(n + 1) = 2N(n),B(n + 1) = 2N(n)Y (n),Q (n + 1) = Q (n) + 2N(n),R(n + 1) = R(n) − 2N(n)Y (n),X(n + 1) = X(n),Y (n + 1) = Y (n),A(0) = A,B(0) = B,Q (0) = 0,R(0) = X,X(0) = X,Y (0) = Y ,smallest(M, n, R(n) < Y (n)),(cid:2) = A(M),A12F. Lin / Artificial Intelligence 235 (2016) 1–25B(cid:2) = B(M),(cid:2) = Q (M),Q(cid:2) = R(M),(cid:2) = X(M),(cid:2) = Y (M).XRYNow get rid of X(n) and Y (n) as they do not change: X(n) = X and Y (n) = Y , get rid of A and B as they are irrelevant now, and expand the smallest macro expression, we obtain (cid:3)(cid:7)XP as the set of following sentences:R(n) < 2N(n)+1Y ,m < N(n) → R(n) ≥ 2m+1Y ,Q (n + 1) = Q (n) + 2N(n),R(n + 1) = R(n) − 2N(n)Y ,Q (0) = 0,R(0) = X,R(M) < Y ,m < M → R(m) ≥ Y ,(cid:2) = Q (M),Q(cid:2) = R(M).RFrom these axioms, we can show the partial correctness of Cohen’s algorithm by proving the following two properties, under the precondition that X ≥ 0 and Y ≥ 1:(cid:2)0 ≤ RX = Q< Y ,(cid:2)Y + R(cid:2).For the first property, RR(M − 1) − 2N(M−1)Y . By the axiomm < N(n) → R(n) ≥ 2m+1Y ,(cid:2) < Y trivially follows from the condition of the Outer loop. For R(cid:2) ≥ 0, we have R(cid:2) = R(M) =let n = M − 1 and m = N(M − 1) − 1, we have R(M − 1) ≥ 2(N(M−1)−1)+1Y = 2N(M−1)Y . Thus Rwe have(cid:2) ≥ 0. For the second property, (cid:2)Y + R(cid:2)Q= Q (M)Y + R(M)= (Q (M − 1) + 2N(M−1))Y + R(M − 1) − 2N(M−1)Y= Q (M − 1)Y + R(M − 1)= · · · = Q (0)Y + R(0) = X.Again this is partial correctness. To prove the termination, we need to show that the new terms introduced by the smallest macro expressions are all well-defined. For this program, it means that M (the outer loop counter) is bounded, and for every n, N(n) (the inner loop counter for each outer loop iteration) is bounded. By Proposition 1, these can be proved by showing the following two properties:∃m.R(m) < Y ,∀n∃m.R(n) < 2m+1Y .Notice that these properties must be proved without those axioms about M and N(n). Since R(n + 1) is inductively defined in terms of N(n), we prove the second property by induction on n, thus showing that N(n) is well-defined. Since R(0) = Xand Y > 1, ∃m.R(0) < 2m+1Y is easy to see: we can let m = X . Thus N(0) is well-defined. Inductively, suppose N(k) is well-defined and ∃m.R(k) < 2m+1Y . Since R(k + 1) < R(k), we have ∃m.R(k + 1) < 2m+1Y as well. Thus N(k + 1) is well-defined. Now to show the first property ∃m.R(m) < Y , observe that R(m) ≤ X − mY , thus ∃m.R(m) < 0 < Y .F. Lin / Artificial Intelligence 235 (2016) 1–2513It may not seem obvious how properties like these can be proved in general. As we mentioned, logical consistency is what we meant for terms like N(n) to be well-defined. Thus all one needs to show is that the set of axioms is consistent under the assumption that Y > 0 and X ≥ 0. Using Proposition 1 is just one way of showing this: if the axioms that do not mention N are consistent and entail ∃n.ϕ(n), then adding smallest(N, n, ϕ(n)) to the axioms will also be consistent.Again we remark that we relied on mathematical induction in our proof and made no use of loop invariants. Notice also that our proof actually shows that for integer division, any program of the following form is correct:// X and Y are two input integers; Y > 0Q=0; // quotientR=X; // remainderwhile (R >= Y) do {A=1;B=Y;while (R >= k*B) do {A = k*A;B = k*B;}R = R-B;Q = Q+A}// return Q = X/Y;where k > 1 can be any constant.6. Properties of programs during executionAs we mentioned, our proposed translation to first order logic has been tailored for the program behaviors in terms of input and output conditions. Sometimes one may be interested in properties of a program during its execution. We have been using temporary function symbols to denote the values of program variables during the execution of a program. So to reason about properties of a program during its execution, all we need to do is to give these temporary functions explicit names. One way to do this is to label program statements and use these labels as the point of reference. Consider the following class of labeled programs:E ::= array(E,...,E) |operator(E,...,E)B ::= E = E |boolean-op(B,...,B)P ::= L: array(E,...,E) = E |L: if B then P else P |L: while B do P |P; PHere L is a label, typically a natural number. Notice that there is no label in front of a sequence. In general, a program P is a sequence of statements:(L1 : P 1); (L2 : P 2); · · · ;( Lk : P k)where P i is either an assignment, a conditional or a while loop. We call P k the last statement of P , and the output of P is the same as the output of P k.Again assume that program variable names are unique and not in the base language L. Now given a program P , for each program variable V and label L, we add functions V and V L to L. Again, V ((cid:7)x) denotes the value at the input, where (cid:7)x are the indices of the corresponding array. The value at the end of a statement L is now denoted by V L((cid:7)x). Of course, Vis V Lwhen L is the label of the last statement in the program.(cid:2)Given a program P and a set (cid:7)X of program variables including all variables used in P , we again use (cid:3)(cid:7)XP to denote the set of axioms for P and (cid:7)X :• If P isL: V(E1,...,Ek) = Ethen (cid:3)(cid:7)XP consists of following axioms:14F. Lin / Artificial Intelligence 235 (2016) 1–25V L((cid:7)x) = if (x1 = E 1 ∧ · · · ∧ xk = Ek) then Eelse V ((cid:7)x),X L((cid:7)y) = X((cid:7)y), X ∈ (cid:7)X and X different from V• If P isL: if B then P1 else P2then (cid:3), (cid:3)(cid:7)XP is the union of (cid:3)(cid:7)XP 1B → X L((cid:7)x) = X L1 ((cid:7)x),B → X L((cid:7)x) = X L2 ((cid:7)x),(cid:7)XP 2and the set of the following axioms: for each X ∈ (cid:7)X ,where L1 and L2 are the labels of the last statements in P 1 and P 2, respectively.• If P isP1; P2then (cid:3)(cid:7)XP is the union of (cid:3)ϕ( (cid:7)X/(cid:7)X L1 ), for each ϕ ∈ (cid:3)(cid:7)XP 2,(cid:7)XP 1and the set of the following axioms:where L1 is the label of the last statement in P 1.• If P isL: while B do P1Then (cid:3)(cid:7)XP is constructed from (cid:3)(cid:7)XP 1as follows:(cid:7)XP 1,ϕ[n], for each ϕ ∈ (cid:3)i ((cid:7)x, 0) = Xi((cid:7)x), for each Xi ∈ (cid:7)XX Li ((cid:7)x, n + 1) = X L1X Lsmallest(N, n, ¬B[n]),i ((cid:7)x) = X LX Li ((cid:7)x, N), for each Xi ∈ (cid:7)Xi ((cid:7)x, n),where L1 is the label of the last statement of the loop body P 1, n is a new natural number variable not already in and for each formula or term α, α[n] is defined ϕ, and N a new natural number constant not already used in (cid:3)similarly as before:1. (∃xα)[n] is ∃x(α[n]), (α1 ∨ α2)[n] is α1[n] ∨ α2[n], and (¬α)[n] is ¬(α[n]).2. F (e1, ..., ek)[n] is F (e1[n], ..., ek[n]) if F is a predicate or a function in the base first-order language L.3. X(e1, ..., ek)[n] is X L(e1[n], ..., ek[n], n), for each X ∈ (cid:7)X ,4. for each label t in P 1, X t(e1, ..., ek)[n] is X t (e1[n], ..., ek[n], n), for each X ∈ (cid:7)X .(cid:7)XP 1As an example, consider the simple loop in Section 3.2, with labels added:1:2:3:4:while I < N doif X < A(I) thenX = A(I);I = I+1The axioms for the body of the loop are (we ignore A(x) and N as they do not change):X 4 = X 2 ∧ I 4 = I 2 + 1,X 2 = if X < A(I) then X 3 else X,I 2 = if X < A(I) then I 3 else I,X 3 = A(I) ∧ I 3 = I.Thus the axioms for the program are:F. Lin / Artificial Intelligence 235 (2016) 1–2515X 4(n) = X 2(n),I 4(n) = I 2(n) + 1,X 2(n) = if X 1(n) < A(I 1(n)) then X 3(n) else X 1(n),I 2(n) = if X 1(n) < A(I 1(n)) then I 3(n) else I 1(n),X 3(n) = A(I 1(n)),I 3(n) = I 1(n),X 1(0) = X ∧ I 1(0) = I,X 1(n + 1) = X 4(n),I 1(n + 1) = I 4(n),n < M → I 1(n) < N,¬I 1(M) < N,X 1 = X 4(M) ∧ I 1 = I 4(M).This set of axioms looks more complicated, which is natural as it has more information. One could query it about the values of program variables at any point during the execution of the program. For instance, to say that statement 2 does not change the value of I during the execution, we write ∀n.I 2(n) = I 1(n). Notice that I 1(n) denotes the value of I at the beginning of the nth iteration of the loop.7. FunctionsOne may ask how general our proposed approach is. Can it be done for programs with more complex structures like pointers, functions, classes, concurrency? We believe so. We have extended it to pointers and functions. Classes should present no problem as they are basically user defined types. We are currently working on extending it to handle Java-like threads. In this section, we describe how the same approach can be used to axiomatize programs with user defined functions. We consider pointers in the next section.In practice, a program consists of a set of functions. To illustrate how we can handle functions, including recursive functions, consider the following class of programs:E ::= array(E,...,E) |operator(E,...,E) |function(E,...,E) |B ::= E = E |boolean-op(B,...,B)Body ::= array(E,...,E) = E |if B then P else P |P; P |while B do P |return EF ::= function(variable,...,variable){ Body }P ::= F | P; PThus a program is a collection of functions. Presumably, one of them is the “main” function, the one that will be executed first when the program is run. In some programming languages, these functions can communicate by sharing some global variables. To simplify things, we assume here that there are no global variables, and that all program variables in the body of a function must occur in the parameter list of the function.If P is F 1; · · · ; Fk, then the set of axioms for P is the union of the sets of axioms for F i , 1 ≤ i ≤ k, with renaming of program variables in them if needed to avoid conflict of names.Given a function definition f ( (cid:7)X){Body}, we first capture the return value of the function on input (cid:7)X by using a special keyword Result. Then the function is defined by universally quantifying over (cid:7)X . More precisely, the set of sentences for f , written (cid:3) f , consists of the following ones:∀(cid:7)xϕ( (cid:7)X/(cid:7)x)(Result(cid:2)/ f ((cid:7)x)), ϕ ∈ (cid:3)(cid:7)X∪{Result}Body,where16F. Lin / Artificial Intelligence 235 (2016) 1–25(cid:2)• ϕ( (cid:7)X/(cid:7)x)(Result/ f ((cid:7)x)) is the result of replacing in ϕ each Xi in (cid:7)X by xi , Xby f ((cid:7)x). We assume that Result is a reserved word used to denote the value of the function. Notice that once we replace (cid:2)each Xi by a variable xi , Xi , the value of Xi when the function exits, is no longer relevant. Here we just replace it by a dummy new function g.i by a new function name g((cid:7)x), and Result(cid:2)(cid:2)• (cid:3)(cid:7)X∪{Result}Bodyis defined as before, except that when Body is return E, the axioms are(cid:2) = E,Result(cid:2)i((cid:7)x) = Xi((cid:7)x), Xi is a program variable.XNotice that according to our axiomatization here, while the body of a function may execute the return statement multiple times, only the last time matters. For example, givenfoo() { return 1; return 2 }(cid:2)only the second return statement is meaningful because Resultfrom the first return statement is replaced by a temporary variable when constructing axioms for the sequence, and thus discarded. So the function is captured by the axiom foo() = 2. One could argue that it does not make sense for more than one instance of the return statement to be executed, and it is the programmer’s responsibility to make sure that this does not happen. Alternatively, one can assume that as soon as a return statement is executed, the function exits. This can be modeled by introducing a special flag Exit, and replace each return statement byif -Exit then {return E; Exit = true}For a more meaningful example, consider the following two mutually defined functions isEven and isOdd:isEven(N) {if N=0 then return trueelse return isOdd(N-1) }isOdd(N) {if N=0 then return falseelse return isEven(N-1) }Suppose that we denote the body of isEven(N) by Body1, and that of isOdd(N) by Body2. Then (cid:3)(N,Result)following axioms:Body1consists of the (cid:2) = N,NResult(cid:2) = if N = 0 then true else isOdd(N − 1)and similarly for (cid:3)(N,Result)(cid:2) = N,Body2N:(cid:2) = if N = 0 then false else isEven(N − 1)ResultThus (cid:3)isOdd ∪ (cid:3)isEven isf (x) = x,isEven(x) = if x = 0 then true else isOdd(x − 1),g(x) = x,isOdd(x) = if x = 0 then false else isEven(x − 1),where f and g are two new functions used to denote the values of x when the functions isEven(x) and isOdd(x), respectively, return. They are irrelevant, so the two corresponding axioms can be deleted. By induction on n, it is easy to prove that the following hold for all n ≥ 0:isEven(2n) = true,isOdd(2n) = false,isEven(2n + 1) = false,isOdd(2n + 1) = true.Now consider the following program with a type definition:F. Lin / Artificial Intelligence 235 (2016) 1–2517List ::= [] | a::Listlength(X:List) {if X=[] then return 0else return length(tail(X))+1}tail(X:List) {if X=[] then return []else if X=a::X1 then return X1}append(X:List, Y:List) {if X=[] then return Yelse if X=a::X1then return a::append(X1,Y)}where a::List is list concatenation: the new list is obtained by adding a into List as the first element.To model the data type List, we introduce a corresponding List sort in our first-order language, and write (x : List) to mean that x is of sort List. In first-order terms, the definition of List yields the following axioms:(∀x : List).x = [] ∨ ∃a(∃ y : List)x = a :: y,∀a, b(∀x, y : List).a :: x = b :: y → (a = b ∧ x = y),∀a(∀x : List)[] (cid:14)= a :: x,and the three functions yield the following axioms:(∀x : List).length(x) = if x = [] then 0else length(tail(x)) + 1,(∀x : List).tail(x) = if x = [] then []else if ∃a(∃ y : List)x = a :: y then y,(∀x, y : List).append(x, y) = if x = [] then yelse if ∃a(∃x1 : List)x = a :: x1then a :: append(x1, y).With these axioms, one can prove, for example length(a :: b :: []) = 2. However, they are not sufficient for proving general properties like the following simple one:(∀x, y : List)length(append(x, y)) = length(x) + length( y).To prove properties like this, we need induction on lists. This can be done by using a second-order axiom on sort List, similar to the one on natural numbers. However, since we already have natural numbers, this is not necessary. We can introduce lists of n elements, and define a list to be a list of n elements, for some n. This way, we can use mathematical induction on natural numbers to prove inductive properties about lists. We show how this is done here. We introduce a binary predicate List(x, n), meaning that x is a list with exactly n elements:(∀x : List)∃n.List(x, n),List(x, 0) ≡ x = [],List(x, n + 1) ≡ (∃a)(∃ y : List).x = a :: y ∧ List( y, n)We first show that if x is a list, then there is a unique n such that List(x, n) holds:List(x, n) ∧ List(x, m) → m = n.(3)Suppose x is a list, and List(x, m) and List(x, n) are true. We do simultaneous induction on n and m. If n = 0, then x = []. If m (cid:14)= 0, then for some k, m = k + 1 and x = [] = a :: y for some a and list y, a contradiction with one of our axioms about lists. Thus m = 0 as well. Similarly, if m = 0, then n = 0 as well. Suppose n = k1 + 1 and m = k2 + 1, and suppose inductively that for any i, j < max{m, n}, we have thatList( y, i) ∧ List( y, j) → i = jfor any list y. We then have x = y1 :: z1 for some list z1 such that List(z1, k1) holds, and x = y2 :: z2 for some list z2 such that List(z2, k2) holds. From y1 :: z1 = y2 :: z2, we have z1 = z2, thus by the inductive assumption, k1 = k2. So m = n. This concludes the inductive step, thus the proof of (3).18F. Lin / Artificial Intelligence 235 (2016) 1–25Using (3), we can then prove the induction schema on lists: for any formula ϕ(x),ϕ([]) ∧ ∀a(∀x : List)(ϕ(x) → ϕ(a :: x)) → (∀x : List)ϕ(x).Suppose the premise is true and for some list x, ¬ϕ(x). By (3) there is a unique n such that List(x, n). Suppose x is a shortest such list: for any list y, if List( y, m) ∧m < n, then ϕ( y) holds. If n = 0, then x = [], which satisfies ϕ, a contradiction. Suppose n = m + 1, then there are some a and y such that x = a :: y ∧ List( y, m). By our assumption about x, ϕ( y) holds. By the premise, ϕ(a :: y) holds as well, a contradiction.The same idea can be used to axiomatize in first-order logic other inductively defined data structures such as trees.For recursive functions, a challenge is to distinguish between cycles and undefined values. Consider the following exam-ple.foo(X) { if X=0 then return foo(X)else if x=1 then return 1}With our axiomatization, the set of axioms for foo(x) is equivalent to a single fact foo(1) = 1. It leaves completely open the possible values for foo(x) when x (cid:14)= 1. One could argue whether this is a right formalization. But operationally, there is a difference between function calls foo(0) and foo(2): calling foo(0) will cause a cycle, but calling foo(2) will terminate without any value being returned. The former causes stack overflow and the latter abnormal exit.In the following, we provide an axiomatization of functions that can differentiate these two cases. The key idea is to keep a counter of the number of times a recursive function has been called.Let f 1, f 2, ..., fk be functions that are mutually defined recursively: f i( X1, ..., Xm){B i}. Extend these functions with one more argument:f i(X1, ..., Xm, M) {if M = 0 then B i0 else B i1}where• B i0 is the result of replacing each function call f j(T 1, ..., Tm) in B i by Cycle, and• B i1 is the result of replacing each function call f j(T 1, ..., Tm) in B i by f j(T 1, ..., Tm, M − 1).• M is a natural number, and Cycle is a new constant.The set (cid:3) f i of axioms for f i is thenf i((cid:7)x) = y ≡ ∃n∀m ≥ n. f i((cid:7)x, m) = y.This axiomatization is similar to the iterated version of the least fixed-point semantics for recursive functions: B i0 is the base case and B i1 is the inductive case.Consider again function foo() defined above. We havefoo(X,M) { if M=0 then{if X=0 then return Cycle elseif X=1 then return 1} else{if X=0 then return foo(X,M-1) elseif X=1 then return 1}and the following axioms for foo( X) and foo( X, M):foo(x) = y ≡ ∃m∀n ≥ m.foo(x, n) = y,foo(0, 0) = Cycle,foo(1, 0) = 1,foo(0, n + 1) = foo(0, n),foo(1, n + 1) = 1Thus ∀n.foo(0, n) = Cycle and ∀n.foo(1, n) = 1. So foo(0) = Cycle and foo(1) = 1. The axioms again leave open the possible values for foo(x) when x is not equal to 0 or 1.8. PointersTo illustrate how this approach can handle pointers and reference variables, we consider here a language with some simple pointer operations similar to those in C. In particular, for a program variable X, we use &X to refer to the address of the memory location assigned to X, and for a pointer variable L, use #L to refer to the value in the location pointed toby L. Thus for a variable X, #(&X) and X return the same value when evaluated in an expression.F. Lin / Artificial Intelligence 235 (2016) 1–2519E ::= IE | PE | BIE ::= id |operator(E,...,E) |#PEPE ::= pointer | &id | pointer-op(E,...,E)B ::= E = E |boolean-op(E,...,E)P ::= id = IE |pointer = PE |#PE = E |if B then P else P |P; P |while B do PHere id is an integer program variable, and pointer a pointer program variable. For simplicity, we do not consider arrays here. operator is a function that returns an integer value, pointer-op a pointer value, and boolean-op a truth value.Our axiomatization of this class of programs will model directly how the compiler works. We assume a set of storage locations which can hold a value which is either an integer or the location of another storage cell. A program variable will be assigned to a location by the compiler at the beginning and this will not be changed during the execution of the program. The value of a program variable will be the value stored at the location.Thus we assume a location sort in our language. In our axiomatization above, we represent a program variable V by a function (of the same name) in our language. The value of this function denotes the value of the program variable in the program. Here, we are going to make a conceptual shift: we are going to represent a program variable by a function of location sort so that the value of the function denotes the location assigned to the program variable by the compiler. So for a program variable V, while before its corresponding function V in the first-order language was dynamic as its value changes during the execution of the program, now V is static as the location assigned to this program variable by the compiler will not change. What is changing during the program execution is the values stored in the memory locations, and this will be modeled by a dynamic function val:val : location → int ∪ location.Thus if V is an integer variable, then val(V ) will be an integer. If V is a pointer, then val(V ) will be a location.To summarize, given a program and a program variable V, instead of using V and Vto denote its values at the input and output of the program, respectively, we now use V to denote a memory location and val(V ) and val(V ) to denote these two values, respectively. We need to do a similar translation from an expression E in the program to a term val(E)(and similarly val(E)) in our first-order language:(cid:2)(cid:2)(cid:2)1. val(&id) is id, if id is an integer program variable.2. val(#PE) is val(val(PE)), if PE is a pointer expression.3. val( f (E 1, ..., Ek)) is f (val(E 1), ..., val(Ek)), if f is either an operator, pointer-op, or boolean-op, assuming that we have a corresponding function fin our language.Given a program P , our axioms for it, denoted (cid:3)P , will be in terms of val and val(cid:2).• If P isV = Ewhere V is an (integer or pointer) program variable and E an (integer or pointer) expression, then we have the following axiom:(cid:2)val(x) = if x = V then val(E) else val(x),where x ranges over locations.• If P is#PE = Ewhere PE is a pointer expression, then the axioms are as follows:(cid:2)val(x) = if x = val(PE) then val(E) else val(x).20F. Lin / Artificial Intelligence 235 (2016) 1–25• If P isP1;P2then (cid:3)P is constructed from (cid:3)P 1 and (cid:3)P 2 as follows:(cid:2)/tmp), for each ϕ ∈ (cid:3)P 1 ,ϕ(valϕ(val/tmp), for each ϕ ∈ (cid:3)P 2 ,where tmp is a new function of the same arity as val and val• The cases for conditionals and while loops are similar as before.(cid:2)and not already used in (cid:3)P 1 and (cid:3)P 2 .Consider the programL = &V;#L = 1where V is an integer variable and L a pointer. Given that val(&V ) = V , we have the following axioms:tmp(x) = if x = L then V else val(x),(cid:2)val(x) = if x = tmp(L) then 1 else tmp(x).Assuming that L (cid:14)= V (they are assigned different locations by the compiler), we have val(cid:2)(cid:2)(V ) = 1, val(L) = V , andx (cid:14)= V ∧ x (cid:14)= L ⊃ val(cid:2)(x) = val(x).Now consider the following program:while X < Y doif Max < #next(A,X) then Max = #next(A,X);X = X+1where A is a pointer variable and next(A,X) is a pointer pointing to the X th location after the one pointed to by A. In C notation, next(A,X) would be A+X and “+” is addition in pointer arithmetic. We use next in order to distinguish it from the normal addition operator arithmetic. We assume the following unique names axioms on locations:∀n.(X (cid:14)= Y (cid:14)= Max (cid:14)= next( A, n)).Again we compute the axioms for the body of the loop first, which can be simplified into the following axioms under the above unique names axioms:(cid:2)(X) = val(X) + 1,valval(Max) < val(val(next( A, X))) →(cid:2)val(Max) = val(val(next( A, X))),x (cid:14)= X ∧ (x (cid:14)= Max ∨ ¬val(Max) < val(val(next( A, X)))) →(cid:2)val(x) = val(x).Thus the axioms for the program areval(x, 0) = val(x),val(X, n + 1) = val(X, n) + 1,val(Max, n) < val(val(next( A, X), n), n) →val(Max, n + 1) = val(val(next( A, X), n), n),x (cid:14)= X ∧ (x (cid:14)= Max ∨ ¬val(Max) < val(val(next( A, X), n), n)) →val(x, n + 1) = val(x, n),n < M → val(X, n) < val(Y , n),¬val(X, M) < val(Y , M),(x) = val(x, M).val(cid:2)F. Lin / Artificial Intelligence 235 (2016) 1–2521From these axioms, we can deduce thatval(X, n) = val(X, 0) + n ∧ val(Y , n) = val(Y , 0).Thus if we assume that val( X, 0) = 0 and val(Y , 0) = N for a natural number N, then we have M = N andval(x, 0) = val(x),val(Max, n) < val(val(next( A, X), n), n) →val(Max, n + 1) = val(val(next( A, X), n), n),x (cid:14)= X ∧ (x (cid:14)= Max ∨ ¬val(Max) < val(val(next( A, X), n), n)) →val(x, n + 1) = val(x, n),(x) = val(x, N).(cid:2)valCompared to the formalization in Section 3, the one here looks more compact as it quantifies over program variables which are locations. This representation is more low level. For instance, some axioms about the next function will be needed before they can be used to infer anything interesting about the program. For more details on how this can be done, see [22].9. Concluding remarksOur goal is to construct a translator from a full programming language like C or Java to first-order logic. Once this is done, reasoning about programs can then be done in logic using techniques including but not limited to induction and loop invariants. In this paper, we show how this is possible for a core procedural programming language with loops, functions, and simple pointers. We have extended it to more complex mutable data structures including lists and trees and are working on extending it to thread-based concurrency.The complexity of the translated first-order theory of a given program depends on what the program is about. If all program variables are propositional, then the resulting first-order theory is decidable for proving both partial and total correctness of the program with respect to any given propositional specification. If the program is about natural numbers and involves addition and multiplication, then we may need full arithmetic to reason about it. If the program is about predicting the trajectory of a planet, then a theory of physics is needed in order to prove anything interesting about it. How to integrate logical reasoning with a domain theory has long been a challenge in AI as well as in computer science.AcknowledgementsI thank Yin Chen, Shing-Chi Cheung, Yongmei Liu, Pritom Prajkhowa, Yidong Shen, Bo Yang, Charles Zhang, Mingyi Zhang, Yan Zhang, and Yi Zhou for many useful discussions related to the subject of this paper. I also thank the anonymous reviewers for both KR-2014 and this journal for sharing their insights on the topic of this paper and for their valuable comments on earlier versions of this paper. This work was supported in part by HK RGC under GRF 616013.Appendix A. Correctness under an operational semanticsIn this appendix we provide an operational semantics to the language in Section 3 and show the correctness of our axiomatization with respect to this semantics.Given a program, we define its models to be sequences of states from its executions. We represent states by first-order structures. As before, we assume a base language that contains functions and predicates corresponding to build-in functions and operators. Given a program P , and a tuple (cid:7)X of functions that includes all program variables used in P , we extend the base language to a new language L (cid:7)X by adding functions in (cid:7)X . Notice that this means that if V is a program variable in Pfor an n-ary array, then we assume that V ∈ (cid:7)X is an n-ary function. Again, we assume that the program variable names are unique and there is no overloading of names.For the class of programs that we consider here, executing a program in a state either does not terminate or yields a finite sequence of assignments. This can be defined in a standard way. Now a finite sequence [M1, · · · , Mn] of L (cid:7)X structures is a model of P if when executed in M1, P terminates with a sequence of assignments α1, · · · , αn−1 such that for each 1 ≤ i < n, Mi+1 is the result of executing αiis the result of executing the assignment in Mi : given a structure M, MV (t1, ..., tk) = e in M if M and Mhave the same domains, same interpretation for predicates, same interpretation for functions except V , and for V , its value in Mis defined as follows:(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)V M(u1, ..., uk) =eM ,V M (u1, ...., uk), otherwiseif (u1, ..., uk) = (t M1 , ..., t Mk )22F. Lin / Artificial Intelligence 235 (2016) 1–25Now consider our translation (cid:3)(cid:7)XP . It uses a language that is an extension of L (cid:7)X . In particular, for each variable V , it (cid:7)XP , we can project it on L (cid:7)X as usual. Furthermore, we say that a has a new “primed” function V(cid:7)Xstructure I of L (cid:7)X is the primed-projection of M if for any symbol τ in L (cid:7)X , if τ does not have a primed version in (cid:3)P , then its interpretation in I is the same as its in M, but if τ has a primed version, then its interpretation in I is according to τ (cid:2)in M. We have. Given a model M of (cid:3)(cid:2)Proposition 7. If M is a model of (cid:3)(cid:7)XP , then there is a model [M1, ..., Mk] of P such thatM1 is the projection of M on L (cid:7)X ,Mk is the primed-projection of M on L (cid:7)X .(A.1)(A.2)Conversely, if [M1, ..., Mk] is a model of P , then there is a model M of (cid:3)(cid:7)XP such that (A.1) and (A.2) hold.Proof. We prove the first half of the proposition. The second half is similar and easier. We prove by induction on P . The base case is when P is an assignmentV(E1,...,Ek) = ERecall that (cid:3)(cid:7)XP consists of following axioms:((cid:7)x) = if (x1 = E 1 ∧ · · · ∧ xk = Ek) then E(cid:2)Velse V ((cid:7)x),(cid:2)((cid:7)y) = X((cid:7)y). X ∈ (cid:7)X and X different from VXIt is easy to see that M is a model of (cid:3)a model of P .(cid:7)XP if M1, M2, the projection and the primed projection of M on L (cid:7)X , respectively, is Inductively suppose the result holds for the subprograms of P . There are three cases: conditional statements, sequences and loops. Suppose P isif B then P1 else P2then a sequence [M1, ..., Mk] of states is a model of P iff either B is true in M1 and [M1, ..., Mk] is a model of P 1 or B is false in M1 and [M1, ..., Mk] is a model of P 2.Recall that (cid:3)(cid:7)XP is constructed from (cid:3)(cid:7)XP 1and (cid:3)as follows:(cid:7)XP 2B → ϕ, for each ϕ ∈ (cid:3)(cid:7)X,P 1(cid:7)X¬B → ϕ, for each ϕ ∈ (cid:3)P 2.(cid:7)XP satisfies B iff the projection of M on L (cid:7)X , M (cid:7)X , satisfies B. Thus M is a model of (cid:3)(cid:7)XP iff Observe that a model M of (cid:3). By inductive assumption, either B is true in M (cid:7)X and M is a model of (cid:3)(cid:7)XP . Then either B is true in M (cid:7)X and for some Mi , [M (cid:7)X , M1, ..., Mk, M (cid:7)X (cid:2) ] is a model of P 1suppose now M is a model of (cid:3)or B is false in M (cid:7)X and for some Mi , [M (cid:7)X , M1, ..., Mk, M (cid:7)X (cid:2) ] is a model of P 2, where M (cid:7)X (cid:2) is the primed projection of M on L (cid:7)X . In either case, for some Mi , M (cid:7)X , M1, ..., Mk, M (cid:7)X (cid:2) is a model of P ., or B is false in M (cid:7)X and M is a model of (cid:3)(cid:7)XP 2(cid:7)XP 1Suppose P isP1; P2then a sequence of states [M1, ..., Mk] is a model of P iff for some 1 < i < k, [M1, ..., Mi] is a model of P 1 and [Mi, ..., Mk]is a model of P 2.(cid:7)XP is constructed from (cid:3)Recall that (cid:3)by connecting the outputs of P 1 with the inputs of P 2 as follows:and (cid:3)(cid:7)XP 2(cid:7)XP 1(cid:7)Xϕ( (cid:7)X (cid:2)/ (cid:7)Y ), for each ϕ ∈ (cid:3)P 1(cid:7)Xϕ( (cid:7)X/ (cid:7)Y ), for each ϕ ∈ (cid:3)P 2,,where (cid:7)Y = (Y 1, ..., Yk) is a tuple of new function symbols such that each Y i is of the same arity as Xi in (cid:7)X . Now suppose (cid:2)i , M is a model of (cid:3)its interpretation in M1 is the same as the interpretation of Y i in M; and M2 is the same as M except that for each Xi , (cid:7)XP . Construct two models M1 and M2 from M as follows: M1 is the same as M except that for each XF. Lin / Artificial Intelligence 235 (2016) 1–2523its interpretation in M2 is the same as the interpretation of Y i in M. Then M i is a model of (cid:3)is because (cid:7)Y is a tuple of new functions not in (cid:3)of P i , i = 1, 2, such that M i1. Thus [M1M11, ..., M1k1k1temporary variables. This assumption is not needed here but needed for the second half of the proposition.is the projection and the primed projection of M i , respectively. By our construction, do not share any , i = 1, 2. By the inductive assumption, there is a model [M i] is a model of P . Notice that we also assume that (cid:3), i = 1, 2. Notice that this ]1 and M iko2, ..., M2, M2k21, ..., M ikiand (cid:3)= M2(cid:7)XP 2(cid:7)XP 1(cid:7)XP i(cid:7)XP iOur last case is loops. Suppose that P iswhile B do P1Then [M1, ..., Mk] is a model of P iff there are some Q ≥ 0, some 1 = k0 ≤ k1 < · · · < k Q = k such that] is a model of P 1, 0 ≤ i < Q .• [Mki , ..., Mki+1• Mki• Mk Q|= B, 0 ≤ i < Q .|= ¬B.Recall that (cid:3)(cid:7)XP consists of the following axioms:(cid:7)XP 1,ϕ[n], for each ϕ ∈ (cid:3)Xi((cid:7)x) = Xi((cid:7)x, 0), for each Xi ∈ (cid:7)Xsmallest(N, n, ¬B[n]),i((cid:7)x) = Xi((cid:7)x, N), for each Xi ∈ (cid:7)XX(cid:2)where n is a new natural number variable not already in ϕ, and N a new natural number constant not already used in (cid:3)(cid:7)X.P 1. Notice that every symbol in LP 1 not in the base language Let LP be the language of (cid:3)(cid:7)XP , and LP 1 the language of (cid:3)(cid:7)XP 1is also in LP but extended by a natural number argument, as described in the construction of ϕ[n].Suppose M is a model of (cid:3)(cid:7)XP . Let Q be the value of N in M (notice that N is a constant in the language and Q a natural number in the domain). For all 0 ≤ i < Q , M |= B[i] and M |= ¬B[Q ]. For each natural number i, let M i be constructed from M as follows: M i is the same as M except that for each symbol X in (cid:3)that has been extended by a natural number parameter, the interpretation of X in M i is the same as the interpretation of X(i) in M and the interpretation of Xin M iis the same as the interpretation of X(i + 1) in M. Notice that M is a structure for language LP and M i a structure for LP 1 . It can be seen that for all i, M i is a model of (cid:3)of states that is a model of P 1 and that M iM iki1, ..., M ikiare the projection and primed projection of M i on L (cid:7)X . Observe that ] is a model of P . (cid:2). By our inductive assumption, for each i, there is a sequence M i, it is not hard to see then that the sequence [M0(cid:7)XP 11 and M iki, ..., M Q −1k Q −1, ..., M Q −11, ..., M0k02, ..., M1k1= M i+1, M1(cid:7)XP 112(cid:2)Appendix B. Loop invariantsOur approach translates programs to first-order theories. Once the translation is done, properties of programs can be proved using whatever methods that are valid in first-order logic. In particular, for programs with loops, one can use loop invariants.Consider a loop of the form while C do P. A condition ϕ is a loop invariant if whenever ϕ and C are true initially, ϕwill continue to hold after P is performed. In our notation, this means that the theory corresponding to the program entails the following sentence:∀n.C[n] ∧ ϕ[n] → ϕ[n + 1].Now if a postcondition Q can be proved using the invariant ϕ:¬C ∧ ϕ → Q ,then we can prove in our theory that Q(cid:2)holds as Q(cid:2)is Q [N] for the N that satisfies smallest(N, n, ¬C[n]).Consider the simple example of the following loop for computing factorials:F=1;I=0;while I<X doI=I+1;F = I*F24F. Lin / Artificial Intelligence 235 (2016) 1–25Given a non-negative integer input X , the output value of F is the factorial of X : F(cid:2) = fact( X).To prove the correctness of this program, we first need to assume a definition of factorial, which can be defined induc-tively as: fact(0) = 1 and ∀n.fact(n + 1) = n × fact(n).One can see that the following is a loop invariant:I ≤ X ∧ F = fact(I).Given that this condition is true when the loop initiates, if the loop terminates, then we have:¬(I < X) ∧ I ≤ X ∧ F = fact(I)which implies I = X and F = fact( X).(B.1)We have implemented a translator1 for programs in Section 3. The direct translation of the program without any simpli-fication gives the following axioms:F 1 = 1,I1 = I,X1 = X,I2 = 0,F 2 = F 1,X2 = X1,F (0) = F 2,I(0) = I2,X(0) = X2,n < N1 → I(n) < X(n),I(N1) ≥ X(N1),I4(n) = I(n) + 1,F 4(n) = F (n),X4(n) = X(n),F (n + 1) = I4(n) ∗ F 4(n),I(n + 1) = I4(n),X(n + 1) = X4(n),(cid:2) = F (N1),F(cid:2) = I(N1),(cid:2) = X(N1)XIFrom this set of equations, it is easy to verify the loop invariant:I(n) < X(n) ∧ (I(n) ≤ X(n) ∧ F (n) = fact(I(n))) →I(n + 1) ≤ X(n + 1) ∧ F (n + 1) = fact(I(n + 1)).Thusn < N1 → I(n + 1) ≤ X(n + 1) ∧ F (n + 1) = fact(I(n + 1))Instantiate n = N1 − 1 in the above equation, we have I(N1) ≤ X(N1). Thus I(N1) = X(N1). So Ffact( X(N1)) = fact( X(cid:2)).(cid:2) = F (N1) = fact(I(N1)) =Our translator simplifies the translated theory as much as possible by getting rid of temporary variables and making use of Mathematica2 to solve recurrences as much as possible. For the factorial program, it generates the following set (cid:3) of formulas:1 This system is implemented by Pritom Prajkhowa and is available upon request.2 http :/ /www.wolfram .com /mathematica/.F. Lin / Artificial Intelligence 235 (2016) 1–2525F (0) = 1,n < N1 → I(n) < X(n),I(N1) ≥ X(N1),F (n + 1) = (n + 1) × F (n),(cid:2) = N1,(cid:2) = F (N1),(cid:2) = XXFINotice that I(n) has been eliminated: from the recurrences I(0) = 0 and I(n + 1) = I(n) + 1, Mathematica computes the closed form solution I(n) = n. Thus the loop invariant (B.1) cannot be used anymore.Looking at the formulas in (cid:3), it is clear that F (n) = fact(n) (e.g. this can be verified using Mathematica). Thus to show that F(cid:2) = fact( X), it all comes down to proving that N1 = X , which also proves that the program terminates.By the definition of the smallest macro, to prove that N1 = X , we need to prove the following two assertions:n ≤ X − 1 → n < X,¬(X < X)which are obvious – they can be easily verified using, e.g. Mathematica.References[1] E. Dijkstra, A Discipline of Programming, Prentice Hall, Englewood Cliffs, N.J., 1976.[2] E.W. Dijkstra, C.S. Scholten, Predicate Calculus and Program Semantics, Springer-Verlag, New York, 1990.[3] C. Hoare, An axiomatic basis for computer programming, Commun. ACM (1969) 576–580.[4] D. Harel, First-Order Dynamic Logic, Lecture Notes in Computer Science, vol. 68, Springer-Verlag, New York, 1979.[5] J.C. Reynolds, Separation logic: a logic for shared mutable data structures, in: Proceedings of 17th Annual IEEE Symposium on Logic in Computer Science, IEEE, 2002, pp. 55–74.[6] A. Pnueli, The temporal semantics of concurrent programs, Theor. Comput. Sci. 13 (1981) 45–60.[7] B. Wegbreit, The synthesis of loop predicates, Commun. ACM 17 (2) (1974) 102–113.[8] N. Bjørner, A. Browne, Z. Manna, Automatic generation of invariants and intermediate assertions, Theor. Comput. Sci. 173 (1) (1997) 49–87, http://dx.[9] M.D. Ernst, J. Cockrell, W.G. Griswold, D. Notkin, Dynamically discovering likely program invariants to support program evolution, IEEE Trans. Softw. [10] M.D. Ernst, J.H. Perkins, P.J. Guo, S. McCamant, C. Pacheco, M.S. Tschantz, C. Xiao, The daikon system for dynamic detection of likely invariants, Sci. [11] T. Nguyen, D. Kapur, W. Weimer, S. Forrest, Using dynamic analysis to discover polynomial and array invariants, in: Proceedings of 34th International Conference on Software Engineering, ICSE 2012, IEEE, 2012, pp. 683–693.[12] D. Kozen, J. Tiuryn, Logics of programs, in: Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics (B), Elsevier, 1990, pp. 789–840.[13] E.A. Emerson, Temporal and modal logic, in: Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics (B), Elsevier, 1990, pp. 995–1072.[14] H. Barringer, R. Kuiper, A. Pnueli, Now you may compose temporal logic specifications, in: STOC, 1984, pp. 51–63.[15] L. Libkin, Elements of Finite Model Theory, Springer, 2004.[16] A. Charguéraud, Program verification through characteristic formulae, ACM SIGPLAN Not. 45 (9) (2010) 321–332.[17] A. Charguéraud, Characteristic formulae for the verification of imperative programs, ACM SIGPLAN Not. 46 (9) (2011) 418–430.[18] M.G. Wallace, Tight, consistent, and computable completions for unrestricted logic programs, J. Log. Program. 15 (1993) 243–273.[19] H. Levesque, R. Reiter, Y. Lespérance, F. Lin, R. Scherl, GOLOG: a logic programming language for dynamic domains, J. Logic Program. 31 (1997) 59–84, special issue on Reasoning about Action and Change.[20] F. Lin, A first-order semantics for Golog and ConGolog under a second-order induction axiom for situations, in: Proceedings of KR 2014, 2014.[21] E. Cohen, Programming in the 1990s: An Introduction to the Calculation of Programs, Springer-Verlag, 1990.[22] F. Lin, B. Yang, Reasoning about mutable data structures in first-order logic with arithmetic: lists and binary trees, Technical report, Department of Computer Science, Hong Kong University of Science and Technology, http://www.cs.ust.hk/faculty/flin/papers/dsw2015.pdf.doi.org/10.1016/S0304-3975(96)00191-0.Eng. 27 (2) (2001) 99–123.Comput. Program. 69 (1) (2007) 35–45.