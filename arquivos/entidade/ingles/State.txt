Artificial Intelligence 172 (2008) 103–139www.elsevier.com/locate/artintState-set branching: Leveraging BDDs for heuristic search ✩Rune M. Jensen ∗, Manuela M. Veloso, Randal E. BryantComputer Science Department, Carnegie Mellon University, 5000 Forbes Ave., Pittsburgh, PA 15213-3891, USAReceived 22 February 2006; received in revised form 30 May 2007; accepted 30 May 2007Available online 7 June 2007AbstractIn this article, we present a framework called state-set branching that combines symbolic search based on reduced ordered BinaryDecision Diagrams (BDDs) with best-first search, such as A* and greedy best-first search. The framework relies on an extensionof these algorithms from expanding a single state in each iteration to expanding a set of states. We prove that it is generallysound and optimal for two A* implementations and show how a new BDD technique called branching partitioning can be used toefficiently expand sets of states. The framework is general. It applies to any heuristic function, evaluation function, and transitioncost function defined over a finite domain. Moreover, branching partitioning applies to both disjunctive and conjunctive transitionrelation partitioning. An extensive experimental evaluation of the two A* implementations proves state-set branching to be apowerful framework. The algorithms outperform the ordinary A* algorithm in almost all domains. In addition, they can improvethe complexity of A* exponentially and often dominate both A* and blind BDD-based search by several orders of magnitude.Moreover, they have substantially better performance than BDDA*, the currently most efficient BDD-based implementation of A*.© 2007 Elsevier B.V. All rights reserved.Keywords: Heuristic search; BDD-based search; Boolean representation1. IntroductionInformed or heuristic best-first search (BFS) algorithms1 such as greedy best-first search and A* [27] are consideredimportant contributions of AI. The advantage of these algorithms, compared to uninformed or blind search algorithmssuch as depth-first search and breadth-first search, is that they use heuristics to guide the search toward the goal andin this way significantly reduce the number of visited states. The algorithms differ mainly by the way they evaluatenodes in the search tree. A* is probably the most widely known BFS algorithm. Each search node of A* is associated✩ This work is an extended version of a paper presented at AAAI-02 [R.M. Jensen, R.E. Bryant, M.M. Veloso, SetA*: An efficient BDD-basedheuristic search algorithm, in: Proceedings of 18th National Conference on Artificial Intelligence (AAAI-02), 2002, pp. 668–673]. The work wassupported in part by the Danish Research Agency and the United States Air Force under Grants Nos F30602-00-2-0549 and F30602-98-2-0135.The views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the officialpolicies or endorsements, either expressed or implied, of the Defense Advanced Research Projects Agency (DARPA), the Air Force, or the USGovernment.* Corresponding author.E-mail addresses: runej@cs.cmu.edu (R.M. Jensen), mmv@cs.cmu.edu (M.M. Veloso), bryant@cs.cmu.edu (R.E. Bryant).URLs: http://www.cs.cmu.edu/~runej (R.M. Jensen), http://www.cs.cmu.edu/~mmv(M.M. Veloso), http://www.cs.cmu.edu/~bryant(R.E. Bryant).1 In this article, BFS always refers to best-first search and not breadth-first search.0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2007.05.009104R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139with a cost g of reaching the node and a heuristic estimate h of the remaining cost of reaching the goal. In eachiteration, A* expands a node with minimum expected completion cost f = g + h. A* can be shown to have muchbetter performance than uninformed search algorithms. However, an unresolved problem for this algorithm is that thenumber of expanded search nodes may grow exponentially even if the heuristic has only a small constant relative error[46]. Such heuristic functions are often encountered in practice, since many heuristics are derived from a relaxationof the search problem that is likely to introduce a relative error. Furthermore, in order to detect duplicate states andconstruct a solution, A* must keep all expanded nodes in memory. For this reason, the limiting factor of A* is oftenspace rather than time.In symbolic model checking [42], a quite different approach has been taken to verify systems with large state spaces.Instead of representing and manipulating sets of states explicitly, this is done implicitly using Boolean functions.2Given a bit vector encoding of states, characteristic functions are used to represent subsets of states. In a similarway, a Boolean function can be used to represent the transition relation of a domain and find successor states viaBoolean function manipulation. The approach potentially reduces both the time and space complexity exponentially.Indeed during the last decade, remarkable results have been obtained using reduced ordered Binary Decision Diagrams(BDDs [9]) as the Boolean function representation. Systems with more than 10100 states have been successfullyverified with the BDD-based model checker SMV [42]. For several reasons, however, only very limited work onusing heuristics to guide these implicit search algorithms has been carried out. First of all, the solution techniquesconsidered in formal verification often require traversal of all reachable states making search guidance irrelevant.Secondly, it is non-trivial to efficiently handle cost estimates such as the g and h-costs associated with individualstates when representing states implicitly.In this article, we present a new framework called state-set branching that combines BDD-based search and best-first search (BFS) and efficiently solves the problem of representing cost estimates. State-set branching applies toany BFS algorithm and any transition cost function, heuristic function, and node-evaluation function defined over afinite domain. The state-set branching framework consists of two independent parts. The first part extends a generalBFS algorithm to an algorithm called best-set-first search (BSFS) that expands sets of states in each iteration. Thesecond part is an efficient BDD-based implementation of BSFS using a partitioning of the transition relation of thesearch domain called branching partitioning. Branching partitioning allows sets of states to be expanded implicitlyand sorted according to their associated cost estimates. The approach applies both to disjunctive and conjunctivepartitioning [15].Two implementations of A* based on the state-set branching framework called FSETA* anf GHSETA* have beenexperimentally evaluated in 10 search domains ranging from VLSI-design with synchronous actions, to classicalAI planning problems such as the (N 2 − 1)-puzzles and problems used in the international planning competitions1998–2004 [2,29,39,40]. We apply four different families of heuristic functions ranging from the minimum Hammingdistance to the sum of Manhattan distances for the (N 2 − 1)-puzzles, and HSPr [8] for the planning problems. In thisexperimental evaluation, the two A* implementations outperform implementations of the ordinary A* algorithm inall domains except one where an efficient Boolean state encoding seems to be challenging to find.3 In addition, theresults show that they can improve the complexity of A* exponentially and that they often dominate both the ordinaryA* algorithm and blind BDD-based search by several orders of magnitude. Moreover, they have substantially betterperformance than BDDA*, the currently most efficient symbolic implementation of A*.The main limitation of the state-set branching framework is that a Boolean state encoding with a compact BDDrepresentation must be found for a target domain. In most cases this is easy, but for general domain representation lan-guages such as PDDL [24] it may be challenging to define automated encoding techniques. Another issue is whetherbranching partitionings are easy to obtain for all heuristics. The experiments in this article show that additive heuris-tics like the sum of Manhattan distances and the HSPr heuristic can be represented compactly. A recent study [32],however, shows that branching partitionings of the max-pair heuristic [28] may be prohibitively large. It is not ourimpression, though, that strong domain dependent heuristics are as combinatorial complex as the max-pair heuristic.2 By an explicit representation, we mean an enumerative representation that uses space linear in the number of represented elements. By animplicit representation, we mean a non-enumerative representation using Boolean expressions to characterize elements.3 By ordinary A* we refer to the graph-search version of A* that maintains a closed list for duplicate elimination and uses an explicit staterepresentation.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139105The remainder of this article is organized as follows. We first describe related work in Section 2. We then definesearch problems in Section 3 and describe the general BFS algorithm in Section 4. In Section 5, we extend this algo-rithm to expand sets of states and study a number of example applications of the new best-set-first search algorithm.In Section 6, we introduce branching partitioning and other BDD-based techniques to efficiently implement thesealgorithms. The experimental evaluation is described in Section 7. Finally, we conclude and discuss directions forfuture work in Section 8.2. Related workState-set branching is the first general framework for combining heuristic search and BDD-based search. All previ-ous work has been restricted to particular algorithms. BDD-based heuristic search has been investigated independentlyin symbolic model checking and AI. The pioneering work is in symbolic model checking where heuristic search hasbeen used to falsify design invariants by finding error traces. Yuan et al. [60] study a bidirectional greedy best-firstsearch algorithm pruning frontier states according to their minimum Hamming distance4 to error states. BDDs rep-resenting Hamming distance equivalence classes are precomputed and conjoined with BDDs representing the searchfrontier during search. Yang and Dill [59] also consider minimum Hamming distance as heuristic function in an ordi-nary greedy best-first search algorithm. They develop a specialized BDD operation for sorting a set of states accordingto their minimum Hamming distance to a set of error states. The operation is efficient with linear complexity in thesize of the BDD representing the error states. However, it is unclear how such an operation can be generalized toother heuristic functions. In addition, this approach finds next states and sorts them according to their cost estimatesin two separate phases. Recent applications of BDD-based heuristic search in symbolic model checking include errordirected search [51] and using symbolic pattern databases for guided invariant model checking [49].In general, heuristic BDD-based search has received little attention in symbolic model checking. The reason is thatthe main application of BDDs in this field is verification where all reachable states must be explored. For ComputationTree Logic (CTL) checking [15], guiding techniques have been proposed to avoid a blow-up of intermediate BDDsduring a reachability analysis [7]. However, these techniques are not applicable to search since they are based ondefining lower and upper bounds of the fixed-point of reachable states.In AI, Edelkamp and Reffel [21] developed the first BDD-based implementation of A* called BDDA*. BDDA*can use any heuristic function defined over a finite domain and has been applied to planning as well as model checking[51]. Several extensions of BDDA* have been published including duplicate elimination, weighted evaluation func-tion, pattern data bases, disjunctive transition relation partitioning, and external storage [18,19]. BDDA* is currentlythe most efficient symbolic implementation of A*. It contributes a combination of A* and BDDs where a single BDDis used to represent the search queue of A*. In each iteration, all states with minimum f -costs are extracted from thisBDD. The successor states and their associated f -cost are then computed via arithmetic BDD operations and addedto the BDD representing the search queue.There are two major differences between BDDA* and the SETA* algorithms presented in this article.(1) Our experimental evaluation of BDDA* shows that its successor state function scales poorly (see Section 7.6).A detailed analysis of the computation shows that the complexity mainly is due to the symbolic arithmetic opera-tions. For this reason, a main philosophy of state-set branching is to use BDDs only to represent state information.Cost estimates like the f -cost of a state is represented explicitly in a search tree.(2) State-set branching introduces a novel approach called branching partitioning that makes it possible to use atransition relation partitioning to propagate cost estimates efficiently between sets of states during search. In thisway, a best-first search algorithm called best-set-first search that expands sets of states in each iteration can beefficiently implemented with BDDs. As shown by our experimental evaluation in Section 7, this has a dramaticpositive effect on the efficiency of the algorithms.An ADD-based5 implementation of A* called ADDA* has also been developed [26]. ADDs [3] generalize BDDsto finite valued functions and may simplify the representation of numeric information like the f -cost of states [58].4 The Hamming distance between two Boolean vectors is the number of bits in the two vectors with different value.5 ADD stands for Algebraic Decision Diagram [3].106R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Similar to BDDA*, however, ADDA* performs arithmetic computations via complex ADD operations. It has not beenshown to have better performance than BDDA* [26].A recent comparison of A* and a symbolic implementation of A* called SA* on 500 random 8-puzzle problemsshows that SA* consistently uses more memory than A* and is outperformed by A* if the heuristic is strong [45].These results are not confirmed by the experimental evaluation in this article where GHSETA* typically uses lessmemory than A* and often finds solutions much faster than A*. We believe that there are several reasons for theobserved differences. First, SA* does not use state-set branching to compute child nodes but instead relies on theless efficient two phase approach developed by Yuan et al. Second, SA* stores expanded nodes without mergingnodes with the same g-cost. This is done by GHSETA* and may lead to significant space savings. Third, 8-puzzleproblems are very small (<106 states) compared with the benchmark problems considered in our evaluation. It isunclear to what extent symbolic approaches pay off on such small problems. Fourth, the state-space of an (N 2 − 1)-puzzle is a subspace of a permutation space consisting of all possible permutations of n elements. It is easy to showthat a BDD representation of a permutation space is exponentially more compact than an explicit representation. Itis, however, still exponential in the number of elements in the permutation. For this reason, we may expect a highmemory consumption of BDD-based search on (N 2 − 1)-puzzles. Indeed, we get fairly weak results for FSETA* andGHSETA* on the 24- and 35-puzzle benchmarks.Other related applications of BDDs for search include HTN planning [37], STRIPS planning [10,12,16,23,33,56], universal planning [13,34], adversarial planning [17,35], fault tolerant planning [36], conformant planning [14],planning with extended goals [47], planning under partial observability [5,6], and shortest path search [52,53].3. Search problemsA search domain is a finite graph where vertices denote world states and edges denote state transitions. Transitionsare caused by activity in the world that changes the world state deterministically. Sets of transitions may be defined byactions, operator schemas, or guarded commands. In this article, however, we will not consider such abstract transitiondescriptions. If a transition is directed from state s to state s(cid:3), state s(cid:3) is said to be a successor of s and state s is saidto be the predecessor of s(cid:3). The number of successors emanating from a given state is called the branching factor ofthat state. Since the domain is finite, the branching factor of each state is also finite. Each transition is assumed to havepositive transition cost.Definition 1 (Search domain). A search domain is a triple D = (cid:4)S, T , c(cid:5) where S is a finite set of states, T ⊆ S × Sis a transition relation, and c : T → R+ is a transition cost function.A search problem is a search domain with a single initial state and a set of goal states.Definition 2 (Search problem). Let D = (cid:4)S, T , c(cid:5) be a search domain. A search problem for D is a triple P =(cid:4)D, s0, G(cid:5) where s0 ∈ S and G ⊆ S.A solution π to a search problem is a path from the initial state to one of the goal states. The solution length is thenumber of transitions in π and the solution cost is the sum of the transition costs of the path.Definition 3 (Search problem solution). Let D = (cid:4)S, T , c(cid:5) be a search domain and P = (cid:4)D, s0, G(cid:5) be a search problemfor D. A solution to P is a sequence of states π = s0, . . . , sn such that sn ∈ G, and T (sj , sj +1) for j = 0, 1, . . . , n − 1.An optimal solution to a search problem is a solution with minimum cost. We will use the symbol C∗ to denote theminimum cost. Fig. 1 shows a search problem example and an optimal solution.4. Best-first searchBest-first search algorithms are characterized by building a search tree superimposed over the state space during thesearch process. Each search node in the tree is a pair (cid:4)s, (cid:9)e(cid:5) where s is a single state and (cid:9)e ∈ Rd is a d-dimensional realvector representing the cost estimates associated with the node (e.g., (cid:9)e could be a two dimensional vector containingR.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139107Fig. 1. An example search problem consisting of four states, five transitions, initial state s0 = C, and a single goal state G = {B}. The dashed pathis an optimal solution. The h-costs associated with each state define the heuristic function used in Section 4.frontier ← MAKEQUEUE((cid:4)s0, (cid:9)e0(cid:5))loopfunction BFS(s0, (cid:9)e0, G)123456if |frontier| = 0 then return failure(cid:4)s, (cid:9)e(cid:5) ←REMOVETOP(frontier)if s ∈ G then return EXTRACTSOLUTION(frontier, (cid:4)s, (cid:9)e(cid:5))frontier ← ENQUEUEALL(frontier, EXPAND((cid:4)s, (cid:9)e(cid:5)))Fig. 2. The general best-first search algorithm.Fig. 3. Search tree example.the g and h-cost associated with a search node of A*). Fig. 2 shows a general BFS algorithm. We assume that theinitial state is associated with cost estimate (cid:9)e0. The solution extraction function in line 5 simply obtains a solution bytracing back the transitions from the goal node to the root node. EXPAND in line 6 finds the set of child nodes of asingle node, and ENQUEUEALL inserts each child in the frontier queue.A* is a BFS algorithm6 that sorts the unexpanded nodes in the priority queue in ascending order of the a costestimate given by a heuristic evaluation function f . The evaluation function is defined byf (n) = g(n) + h(n),where g(n) is the cost of the path in the search tree leading from the root node to n, and h(n) is a heuristic functionestimating the cost of a minimum cost path leading from the state in n to some goal state.7 Thus f (n) measures theminimum cost over all solution paths constrained to go through the state in n. The search tree built by A* for theexample problem and heuristic function defined in Fig. 1 is shown in Fig. 3.6 However, practical implementations of A* includes a closed list to detect duplicate states.7 For a heuristic function to be valid, we require that h(n) (cid:2) 0 for all n and h(n) = 0 for all n containing a goal state.108R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139A* is sound and complete, since the node expansion operation is assumed to be correct, and infinite cyclic pathshave unbounded cost. A* further finds optimal solutions if the heuristic function h(n) is admissible, that is, if h(n) (cid:3)h∗(n) for all n, where h∗(n) is the minimum cost of a path going from the state in n to a goal state. The heuristicfunction is called consistent if h(n) (cid:3) c(n, n(cid:3)) + h(n(cid:3)) for every successor node n(cid:3) of n. The complexity of A*is directly tied to the accuracy of the estimates provided by h. When A* employs a perfectly informed heuristic(h(n) = h∗(n)) and f -cost ties are broken by giving highest priority to the node with lowest h-cost, it is guideddirectly toward the closest goal. At the other extreme, when no heuristic at all is available (h(n) = 0), the searchbecomes exhaustive, normally yielding exponential complexity. In general, A* with duplicate elimination using aconsistent heuristic has linear complexity if the absolute error of the heuristic function is constant, but it may haveexponential complexity if the relative error is constant. Subexponential complexity requires that the growth rate of theerror is logarithmically bounded [46](cid:4)(n)(cid:2)(cid:2)h(n) − h∗(cid:2)(cid:2) ∈ O(n)(cid:3)∗log h.The complexity results are discouraging due to the fact that practical heuristic functions often are based on a relaxationof the search problem that causes h(n) to have constant or near constant relative error. The results show that practicalapplication of A* still may be very search intensive. Often better performance of A* can be obtained by weighting theg- and h-component of the evaluation function [48]f (n) = (1 − w)g(n) + wh(n), where w ∈ [0, 1].(1)Weights w = 0.0, 0.5, and 1.0 correspond to uniform cost search, A*, and greedy best-first search. Weighted A*is optimal in the range [0.0, 0.5] if the heuristic function is admissible but often finds solutions faster in the range(0.5, 1].5. State-set branchingThe state-set branching framework has two independent parts: a modification of the general BFS algorithm to anew algorithm called best-set-first search (BSFS), and a collection of BDD-based techniques for implementing thenew algorithm efficiently. In this section, we will describe the BSFS algorithm. In the next section, we show how it isimplemented with BDDs.5.1. Best-set-first searchAssume that each transition T (s, s(cid:3)) for a particular heuristic search algorithm changes the cost estimates withδ(cid:9)e(s, s(cid:3)). Thus if s is associated with cost estimates (cid:9)e and s(cid:3) is reached by T (s, s(cid:3)) then s(cid:3) will be associated withcost estimates (cid:9)e + δ(cid:9)e(s, s(cid:3)). For A*, the cost estimates can be one or two dimensional: either it is the f -cost orthe g and h-cost of a search node. In the first case δ(cid:9)e(s, s(cid:3)) is the f -cost change caused by the transition. The δfcosts of our example problem are shown in Fig. 4. The BSFS algorithm shown in Fig. 5 is almost identical to theBSFS algorithm defined in Fig. 2. However, the state set version traverses a search tree during the search processwhere each search node contains a set of states associated with the same cost estimates. Multiple states in each nodeemerge because child nodes having identical cost estimates are coalesced by STATESETEXPAND in line 6 and becauseFig. 4. The example search problem with δf costs.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139109frontier ← MAKEQUEUE((cid:4){s0}, (cid:9)e0(cid:5))loopfunction BSFS(s0, (cid:9)e0, G)123456if |frontier| = 0 then return failure(cid:4)S, (cid:9)e(cid:5) ← REMOVETOP(frontier)if S ∩ G (cid:12)= ∅ then return EXTRACTSOLUTION(frontier, (cid:4)S ∩ G, (cid:9)e(cid:5))frontier ← ENQUEUEANDMERGE(frontier, STATESETEXPAND((cid:4)S, (cid:9)e(cid:5)))Fig. 5. The best-set-first search algorithm.child ← emptyMapforeach state s in Sfunction STATESETEXPAND((cid:4)S, (cid:9)e(cid:5))123456foreach transition T (s, s(cid:3))(cid:9)ec ← (cid:9)e + δ(cid:9)e(s, s(cid:3))child[(cid:9)ec] ← child[(cid:9)ec] ∪ {s(cid:3)}return MAKENODES(child)Fig. 6. The state set expand function.Fig. 7. State-set search tree example.ENQUEUEANDMERGE may merge child nodes with nodes on the frontier queue having identical cost estimates. Thestate-set expansion function is defined in Fig. 6. The next states of some child associated with cost estimates (cid:9)e arestored in child[(cid:9)e]. The outgoing transitions from each state in the parent node are used to find all successor states.The function MAKENODES called at line 6 constructs the child nodes from the completed child map. Each child nodecontains states having identical cost estimates. However, there may exist several nodes with the same cost estimates.In addition, MAKENODES may prune some of the child states (e.g., to implement duplicate elimination in A*).As an example, Fig. 7 shows the search tree traversed by the BSFS algorithm for A* applied to our exampleproblem. In order to reduce the number of search nodes even further, ENQUEUEANDMERGE of the BSFS algorithmmay merge nodes on the search frontier having identical cost estimates. This transforms the search tree into a DirectedAcyclic Graph (DAG), but as proven in Appendix A this does not affect the soundness of the BSFS algorithm. TheEXTRACTSOLUTION function in line 5 uses the backward traversal described in the proof of Lemma 7 to extract asolution. It is not possible to show completeness of the BSFS algorithm since it covers incomplete algorithms such asgreedy best-first search.5.2. The FSETA* and GHSETA* algorithmsThe BSFS algorithm can be used to implement variants of greedy best-first search, A*, weighted A*, uniformcost search, and beam search. To simplify the presentation of BSFS, we have only described its tree-search version,where states may be repeated many times in the search tree. In a concrete application of BSFS, however, a closed110R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139list of expanded states is maintained to eliminate many of these duplicates. The elimination strategy depends on theapplication and will be discussed independently for each algorithm below.8Greedy best-first search is implemented by using the values of the heuristic function as cost estimates and sortingthe nodes on the frontier in ascending order, such that the top node contains states with least h-cost. The cost estimateof the initial state is (cid:9)e0 = h(s0) and each transition T (s, s(cid:3)) is associated with the change in h, that is, δ(cid:9)e(s, s(cid:3)) =h(s(cid:3)) − h(s). In each iteration, this greedy best-first search algorithm will expand all states with least h-cost on thefrontier. A strategy for eliminating duplicates that does not compromise completeness is to subtract all the states inthe closed list from the set of states to expand.A* can be implemented by setting (cid:9)e0 = h(s0) and δ(cid:9)e(s, s(cid:3)) = c(s, s(cid:3)) + h(s(cid:3)) − h(s) such that the cost estimatesequal the f -cost of search nodes. Again nodes on the frontier are sorted in ascending order and the node with leastf -cost is expanded in each iteration. If the heuristic is consistent, a strategy for eliminating duplicates that does notcompromise optimality is to subtract all the states in the closed list from the set of states to expand. However, sincethis is not possible in general for admissible heuristics, we consider an implementation without duplicate eliminationcalled FSETA*. The FSETA* algorithm always merges nodes on the frontier associated with the same f -cost.9An A* implementation with duplicate elimination that does not require the heuristic function to be admissibleor consistent must keep track of the g and h-cost separately and prune child states reached previously with a lowerg-cost. To achieve this, we can define (cid:9)e0 = (0, h(s0)) and δ(cid:9)e(s, s(cid:3)) = (c(s, s(cid:3)), h(s(cid:3)) − h(s)). The frontier is, as usual,sorted according to the evaluation function f (n) = g(n) + h(n). An implementation that uses the above strategy foreliminating duplicates is called GHSETA*. Compared to FSETA*, GHSETA* merges nodes that have identical g andh-costs. Thus there may be several nodes on the frontier with same f -cost but different g and h-costs. In each iteration,GHSETA* may therefore only expand a subset of the states on the frontier with minimum f -cost. A number of otherimprovements have been integrated in GHSETA*. First, it applies the usual tie breaking rule for nodes with identicalf -cost choosing the node with the least h-cost. Thus, in situations where all nodes on the frontier have f (n) = C∗,the algorithm focuses the search in a DFS fashion. The reason is that a node at depth level d in this situation musthave greater h-cost than a node at level d + 1 due to the non-negative transition costs. In addition, it only merges twonodes on the frontier if the space used by the resulting node is less than an upper-bound u. This may help to focusthe search further in situations where there is an abundance of solutions, but space requirements of the frontier nodesgrow fast with the search depth.Both GHSETA* and FSETA* can easily be extended to the weighted A* algorithm described in Section 4. Using anapproach similar to the one used by Pearl [46], FSETA* and GHSETA* can be shown to be optimal given an admissibleheuristic. In particular this is true when using the trivial admissible heuristic function h(n) = 0 of uniform cost search.The proofs are given in Appendix A.106. BDD-based implementationThe motivation for defining the BSFS algorithm is that it can be efficiently implemented with BDDs. In thissection, we describe how to represent sets of states implicitly with BDDs and develop a technique called branchingpartitioning for expanding search nodes efficiently.6.1. The BDD representationA BDD is a decision tree representation of a Boolean function on a set of linearly ordered arguments. The treeis reduced by removing redundant tests on argument variables and reusing structure. This transforms the tree intoa rooted directed acyclic graph and makes the representation canonical. BDDs have several advantages: first, manyfunctions encountered in practice (e.g., symmetric functions) have polynomial size, second, graphs of several BDDscan be shared and efficiently manipulated in multi-rooted BDDs, third, with the shared representation, equivalenceand satisfiability tests on BDDs take constant time, and finally, fourth, the 16 Boolean operations on two BDDs x andy have time and space complexity O(|x||y|) [9]. A disadvantage of BDDs is that there may be an exponential size8 The graph-search version of BSFS never re-expands a state. This strategy, however, may compromise optimality for some applications.9 Another reason for studying this algorithm is that it expands the same set of states as BDDA*.10 Notice that it follows from the optimality proof given in Appendix A that FSETA* and GHSETA* are complete.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139111Fig. 8. Boolean state encoding of the example search problem.difference depending on the ordering of the variables. However, powerful heuristics exist for finding good variableorderings [44]. For a detailed introduction to BDDs, we refer the reader to Bryant’s original paper [9] and the books[44,58].6.2. BDD-based state space explorationBDDs were originally applied to digital circuit verification [1]. More relevant, however, for the work presented inthis article, they were later applied in model checking using a range of techniques collectively coined symbolic modelchecking [42]. During the last decade BDDs have successfully been applied to verify very large transition systems.The essential computation applied in symbolic model checking is an efficient reachability analysis where BDDs areused to represent sets of states and the transition relation.Search problems can be solved using the standard machinery developed in symbolic model checking. Let D =(cid:4)S, T , c(cid:5) be a search domain. Since the number of states S is finite, a vector of n Boolean variables (cid:9)v ∈ Bn can beused to represent the state space. In the remainder, let Z denote the set of variables in (cid:9)z. The variables V of (cid:9)v arecalled state variables. A set of states S can be represented by a characteristic function S((cid:9)v) on (cid:9)v. Thus, a BDD canrepresent any set of states. The main efficiency of the BDD representation is that the cardinality of the representedset is not directly related to the size of the BDD. For instance, the BDD of the constant function True has a singlenode and can represent all states in the domain no matter how many there are. In addition, the set operations union,intersection and complementation simply translate into disjunction, conjunction, and negation on BDDs.In a similar way, the transition relation T can be represented by a characteristic function T ((cid:9)v, (cid:9)v (cid:3)). We refer to (cid:9)v and(cid:9)v (cid:3) as current and next state variables, respectively. To make this clear, two Boolean variables (cid:9)v = (v0, v1) are used inFig. 8 to represent the four states of our example problem.11 The initial state s0 and goal state G are represented bytwo BDDs for the expressions ¬v0 ∧ ¬v1 and v0 ∧ v1, respectively. The transition relation is represented by a BDDequal to the Boolean functionT ((cid:9)v, (cid:9)v (cid:3)) = ¬v0 ∧ ¬v1 ∧ v(cid:3)0∨ ¬v0 ∧ v1 ∧ v(cid:3)0∨ v0 ∧ ¬v1 ∧ ¬v(cid:3)0∨ ¬v0 ∧ ¬v1 ∧ ¬v(cid:3)∧ ¬v(cid:3)10∧ ¬v(cid:3)∨ v0 ∧ v1 ∧ v(cid:3)∧ v(cid:3)110∧ ¬v(cid:3)1.∧ v(cid:3)1The crucial idea in BDD-based or symbolic search is to stay at the BDD level when finding the next states of a set ofstates. A set of next states can be found by computing the image of a set of states S encoded in current state variablesIMG(S) =(cid:3)∃(cid:9)v . S((cid:9)v) ∧ T ((cid:9)v, (cid:9)v(cid:3)(cid:4))(cid:3)[(cid:9)v/(cid:9)v].The previous states of a set of states is called the preimage and are computed in a similar fashion. The operation [(cid:9)v/(cid:9)v]is a regular variable substitution. Existential quantification is used to abstract variables in an expression. Let vi be oneof the variables in the expression e(v0, . . . , vn), we then have∃vi . e(v0, . . . , vn) = e(v0, . . . , vn)[vi/False] ∨ e(v0, . . . , vn)[vi/True].11 Readers interested in studying the structure of BDD graphs representing sets of states and transition relations are referred to the work byEdelkamp and Reffel [16,21]. In this article, we consider BDDs an abstract data type for manipulating Boolean functions and focus on explaininghow implicit search can be performed by manipulating these functions.112R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139← s0; i ← 0reached ← ∅; forwardFrontier0∧ G = ∅while forwardFrontierifunction FORWARD BREADTH-FIRST SEARCH(s0((cid:9)v))1234567i ← i + 1forwardFrontierireached ← reached ∨ forwardFrontieriif forwardFrontierireturn EXTRACTSOLUTION(forwardFrontier)= False return failure← IMG(forwardFrontieri−1) ∧ ¬reachedExistentially quantifying a Boolean variable vector involves quantifying each variable in turn.Fig. 9. BDD-based forward breadth-first search.To illustrate the image computation, consider the first step of a search from s0 in the example problem. We haveS(v0, v1) = ¬v0 ∧ ¬v1. ThusIMG(S) =(cid:3)∃(v0, v1) . ¬v0 ∧ ¬v1 ∧ T (v0, v1, v(cid:3)(cid:3)(cid:3)∧ v= (v001= v0 ∧ ¬v1 ∨ ¬v0 ∧ v1,∨ ¬v(cid:5)(cid:3)1)∧ ¬v(cid:3)1)(cid:6)(cid:3)1)/(v0, v1)(cid:3)0, v(cid:3)0, v(v(cid:4)(cid:5)(cid:6)(cid:3)1)/(v0, v1)(cid:3)0, v(vwhich as expected corresponds to state (1, 0) and (0, 1). It is straightforward to implement uninformed or blind BDD-based search algorithms using the image and preimage computations. The forward breadth-first search algorithm,shown in Fig. 9, computes the set of frontier states with the image computation. The set reached contains all exploredstates and is used to prune a new frontier from previously visited states. A solution is constructed by traversing theforward frontiers backward from a reached goal state to the initial state. This computation always has much lowercomplexity than the forward search, since the preimage computation in each iteration can be restricted to a BDDrepresenting a single state.Backward breadth-first search can be implemented in a similar fashion using the preimage to find the frontier states.The two algorithms are easily combined into a bidirectional search algorithm. In each iteration, this algorithm eithercomputes the frontier states in forward or backward direction. If the set of frontier states is empty the algorithm returnsfailure. If an overlap between the frontier states and the reached states in the opposite direction is found the algorithmextracts and returns a solution. Otherwise the search continues. A good heuristic for deciding which direction to searchin is simply to choose the direction where the previous frontier took least time to compute. When using this heuristic,bidirectional search has similar or better performance than both forward and backward search, since it will transforminto one of these algorithms if the frontiers always are faster to compute in a particular direction.126.3. PartitioningA common problem when computing the image and preimage is that the intermediate BDDs tend to be largecompared to the BDD representing the result. Another problem is that the transition relation may grow very large ifrepresented by a single BDD (a monolithic transition relation). In symbolic model checking one of the most successfulapproaches to solve these problems is transition relation partitioning [11]. The technique relies on the observation thata system often can be characterized as either asynchronous with interleaved activity or synchronous with simultaneousactivity. Consider the system model shown in Fig. 10. During each transition of the system, the state variables V areupdated. Assume that subsystem i determines the next value of the state variables Y (cid:3)i given the current value of thestate variables Xi and is characterized by the transition relation Pi((cid:9)xi, (cid:9)y (cid:3)i). If the system is asynchronous, only asingle of the m subsystems is active during a transition and only the next state variables of this subsystem changevalue. Otherwise, if the system is synchronous, each subsystem is active during a transition. In the asynchronous case,the total transition relation is given bym(cid:7)(cid:9)(cid:8)T ((cid:9)v, (cid:9)v) =Pi((cid:9)xi, (cid:9)y(cid:3)i) ∧i=1(vv(cid:3) /∈Y (cid:3)i(cid:10)(cid:3) ⇔ v).12 Unless a first step in an inferior direction dominates the total search time. However, we have not experienced this in practice.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139113To ease the presentation, assume that Yi for i = 1..m in the synchronous case is a partitioning of the state variables.13The transition relation in the synchronous case is then given byFig. 10. System model.T ((cid:9)v, (cid:9)v) =m(cid:9)i=1Pi((cid:9)xi, (cid:9)y(cid:3)i).Thus, the transition relation is either represented by a disjunctive partitioning or a conjunctive partitioning of subre-lations.The main point about partitioning is that the complete transition relation never needs to be computed since both theimage and preimage computations can be carried out directly on the subrelations. The asynchronous system model fitsto most search problems since these often are characterized by changing a small subset of the state variables duringeach transition. The image computation in the asynchronous case isIMG(S) =m(cid:7)(cid:3)∃(cid:9)yi . S((cid:9)v) ∧ Pi((cid:9)xi, (cid:9)y(cid:4)(cid:3)i)[(cid:9)y(cid:3)i/(cid:9)yi].i=1A similar approach can be used to simplify the preimage computation. Notice that we exploit that all variables exceptthe ones modified by the active subsystem are unchanged. Thus, no quantification over these variables is necessary.This often has a substantial positive effect on the complexity of the computation. The reason is that the complexity ofquantification on BDDs may be exponential in the number of quantified variables. In practice, it is often an advantageto merge some of the subrelations [50] and combine the quantification and disjunction operation to a single specializedBDD operation.For the domain shown in Fig. 8, we can merge the transitions into two partitions P1 and P2 of a disjunctivepartitioning, where P1 only modifies v0 and P2 only modifies v1. P1 consists of transitions (0, 0) → (1, 0), (0, 1) →(1, 1), and (1, 0) → (0, 0), and P2 consists of transitions (0, 0) → (0, 1) and (1, 1) → (1, 0)(cid:3)(v0, v1), (v(cid:3)(v0, v1), (v(cid:4)(cid:3)0)(cid:4)(cid:3)1)(cid:3)0,(cid:3)0(cid:3)1P1P2∨ ¬v0 ∧ v1 ∧ v∨ v0 ∧ v1 ∧ ¬v= ¬v0 ∧ ¬v1 ∧ v= ¬v0 ∧ ¬v1 ∧ v(cid:3)∨ v0 ∧ ¬v1 ∧ ¬v0(cid:3)1.The synchronous system model fits to search problems where each transition is due to simultaneous activity (e.g.,centralized multi-agent planning [34]). The image computation is more complicated in the conjunctive case due to thefact that existential quantification does not distribute over conjunction. However, a subrelation can be moved out ofscope of an existential quantification if it does not depend on any of the variables being quantified. This technique isoften referred to as early quantification. We get(cid:4)(cid:3)(cid:3)(cid:3)IMG(S) =∃(cid:9)z1 . S((cid:9)v) ∧ P1((cid:9)x1, (cid:9)y· · ·1)(cid:11)mmi=1 Zi = V . Again, a similar approach can be used to simplify thej =i+1 Xj = ∅ for 1 (cid:3) i < m and∧ Pm((cid:9)xm, (cid:9)y(cid:3)∃(cid:9)zm .(cid:4)(cid:3)m)/(cid:9)v],· · ·[(cid:9)v(cid:11)(cid:4)(cid:3)where Zi ∩preimage computation.13 It is easy extend the approaches to the general case.114R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139As an example, consider a system with two state variables v0 and v1 and two concurrent activities P1(v0, v(cid:3)0) =1. An image computation using early quantification from the state S((cid:9)v) = ¬v0 ∧¬v10 and P2(v1, v(cid:3)1) = ¬v1 ∧v(cid:3)¬v0 ∧v(cid:3)would then beIMG(S) ==(cid:3)(cid:4)(cid:3)(cid:3)∃(cid:9)v1 .∃(cid:9)v0 . S((cid:9)v) ∧ P1(v0, v0)(cid:3)(cid:3)0) ∧ P2(v1, v∃(cid:9)v1 . (∃(cid:9)v0 . ¬v0 ∧ ¬v1 ∧ v(cid:3)(cid:3)(cid:3)(cid:3)/(cid:9)v]0) ∧ ¬v1 ∧ v∃(cid:9)v1 . (¬v1 ∧ v1(cid:4)(cid:3)∧ P2(v1, v1)(cid:4)(cid:3)[(cid:9)v1)(cid:4)[(cid:9)v/(cid:9)v](cid:3)[(cid:9)v(cid:3)/(cid:9)v]== v0 ∧ v1.Thus as expected, the image contains a single state where the value of both state variables has been changed fromFalse to True.A large number of heuristics have been developed for choosing and arranging partitions in the conjunctive case(e.g., [43,50]). The main idea is to avoid a blow up of the intermediate BDDs of the image and preimage computationby reducing the life span of variables. Assume that a variable is introduced in the computation by partition i and thatthe variable is removed again by the existential quantification associated with partition j . The life span of the variableis then j − i.6.4. The BDD-based BSFS algorithmThe BSFS algorithm represents the states in each search node by a BDD. This may lead to exponential spacesavings compared to the explicit state representation used by the BFS algorithm. In addition, search nodes with similarBDDs may share structure in the multi-rooted BDD representation. This may further reduce the memory consumptionsubstantially.However, if we want an exponential space saving to translate into an exponential time saving, we also need animplicit approach for computing the expand operation. The image computation can be applied to find all next states ofa set of states implicitly, but we need a way to partition the next states into child nodes with the same cost estimates.The expand operation could be carried out in two phases, where the first finds all the next states using the imagecomputation, and the second splits this set of states into child nodes [59]. A more direct approach, however, is to splitup the image computation such that the two phases are combined into one. We call this a branching partitioning.6.4.1. Disjunctive branching partitioningFor disjunctive partitioning the approach is straightforward. We simply ensure that each partition contains transi-tions with the same cost estimate change. The result is called a disjunctive branching partitioning.Definition 4 (Disjunctive branching partitioning). A disjunctive branching partitioning is a disjunctive partitioningP1((cid:9)x1, (cid:9)y(cid:3)m) where each subrelation represents a set of transitions with the same cost estimate change.1), . . . , Pm((cid:9)xm, (cid:9)y(cid:3)Notice, that there may exist several partitions with the same cost estimate change. This makes it possible to optimizedisjunctive branching partitionings such that each partition only modifies a small set of next states variables.So far, an unresolved problem is how to find the cost estimate change of each transition efficiently. Since costestimates are based on a heuristic function h, this involves determining δh for each transition. It is intractable tocompute h(s) explicitly for each state since the number of states grows exponentially with the number of state variablesof the domain. In practice, however, it turns out that δh of an action often is independent of which state it is applied in.This is not a coincidence. Heuristics are relaxations that typically are based on ignoring interactions between actionsin the domain. Thus, the effect of an action can often be associated with a particular δh value. In the worst case, it maybe necessary to encode the heuristic function symbolically with a BDD h((cid:9)b, (cid:9)v) where the vector of Boolean variables(cid:9)b encodes the heuristic value in binary of the state represented by (cid:9)v. We can then compute δh(s, s(cid:3)) symbolically withδh((cid:9)v, (cid:9)v(cid:3), (cid:9)d) ≡ h((cid:9)b, (cid:9)v) ∧ h((cid:9)b(cid:3), (cid:9)v) ∧ (cid:9)d = (cid:9)b(cid:3) − (cid:9)b,where (cid:9)d encodes the value of δh(s, s(cid:3)) in binary. This computation avoids iterating over all states. In addition, it onlyneeds to be carried out once prior to search. For all of the heuristics studied in this article (including several classicalR.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139115function DISJUNCTIVESTATESETEXPAND((cid:4)S((cid:9)v), (cid:9)e(cid:5))12456child ← emptyMapfor i = 1 to |P|(cid:9)ec ← (cid:9)e + δ(cid:9)eichild[(cid:9)ec] ← child[(cid:9)ec] ∨ IMGi (S)return MAKENODES(child)Fig. 11. The state set expand function for a disjunctive branching partitioning.heuristics), it has not been necessary to perform this symbolic computation. Instead, the δh value of each action hasbeen independent or close to independent of the state the action is applied in.For the domain shown in Fig. 8, a valid disjunctive branching partitioning is(cid:3)(cid:4)(v0, v1), (v0)(cid:3)(cid:4)(v0, v1), (v0)(cid:3)(cid:4)(v0, v1), (v1)(cid:3)(cid:4)(v0, v1), (v1)P1P2P3P4(cid:3)0,(cid:3)= ¬v0 ∧ ¬v1 ∧ v∨ ¬v0 ∧ v1 ∧ v0(cid:3)= v0 ∧ ¬v1 ∧ ¬v0,(cid:3)= ¬v0 ∧ ¬v1 ∧ v1,(cid:3)= v0 ∧ v1 ∧ ¬v1,δf1 = 0,δf2 = 2,δf3 = 0,δf4 = 3.Assume that P is a disjunctive branching partitioning where the cost estimate change associated with subrelation i isδ(cid:9)ei . Let IMGi(S) denote the image of the transitions in subrelation iIMGi(S) ≡(cid:3)∃(cid:9)yi . S((cid:9)v) ∧ Pi((cid:9)xi, (cid:9)y(cid:4)(cid:3)[(cid:9)yi)(cid:3)i/(cid:9)yi].The STATESETEXPAND function in Fig. 6 can then be implemented with BDDs as shown in Fig. 11. We assume thatchild[(cid:9)e] = False if no entry exists in child with key (cid:9)e.6.4.2. Conjunctive branching partitioningAn efficient implicit node expansion computation is also possible to define for a conjunctive partitioning. Considerthe synchronous composition of the m subsystems in Fig. 10. Assume that the cost estimate change of a joint activityequals the sum of cost estimate changes of each activity. We can then represent a conjunctive branching partitioningas m disjunctive branching partitionings where each disjunctive branching partitioning represents the subrelations ofthe activities.Definition 5 (Conjunctive branching partitioning). A conjunctive branching partitioning P1, . . . , Pm is a set of dis-junctive branching partitionings Pi((cid:9)xi, (cid:9)y(cid:3)i), . . . , Rrii) for 1 (cid:3) i (cid:3) m.i ((cid:9)xi, (cid:9)y(cid:3)i ((cid:9)xi, (cid:9)y(cid:3)i) = R1Since the subsystems are synchronous, we require that the sets of variables in (cid:9)y(cid:3)i ((cid:9)xi, (cid:9)y(cid:3)i) is δ(cid:9)eji . As an example, Rj1, . . . , (cid:9)y(cid:3)m form a partitioning of thei could represent actionstate variables V (cid:3). Assume that the cost estimate change of Rjtransitions with cost estimate change δ(cid:9)ejFurther leti of agent i in a multi-agent system consisting of m synchronized agents.(cid:3)i),j(cid:11)i ((cid:9)xi, (cid:9)ySUBCOMPmj =i+1 Xi = ∅ for 1 (cid:3) i < m andi (φ) ≡ ∃(cid:9)zi . φ((cid:9)v, (cid:9)v) ∧ Rjwhere φ represents an intermediate computation result. As for an ordinary conjunctive image computation, we require(cid:11)nZi ∩i=1 Zi = V . The conjunctive state-set expansion function is then defined asshown in Fig. 12. The outer loop of the function performs m iterations. In iteration i, the next value of the variables (cid:9)yiis computed. In the end, the map layeri contains sets of next states of subsystem 1 to i with identical cost estimates.[(cid:9)e] = False if no entry exists in layeri with key (cid:9)e. In the worst case, the number of child nodes willWe assume layerigrow exponentially with the number of activities. However, in practice this blow-up of child nodes may be avoideddue to the merging of nodes with identical cost estimates during the computation.As an example consider computing CONJUNCTIVESTATESETEXPAND((cid:4)S, 5(cid:5)) for some set of states S for a prob-lem with a scalar cost estimate e and four concurrent subsystems each with transitions either changing e with −1, 0,= 1 for i = 1..4. Fig. 13 shows the entries in layer0, . . . , layer4. As depicted,or 1. Thus δe1ithe number of entries in the final layer is 9. For the kind of activities considered in this example, the number of childnodes only grows linearly with the number of concurrent activities.= 0, and δe3i= −1, δe2i116R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139← emptyMaplayer0[(cid:9)e] ← Slayer0for i = 1 to mlayeriforeach entry (cid:4)φ, (cid:9)ei−1(cid:5) in layeri−1function CONJUNCTIVESTATESETEXPAND((cid:4)S((cid:9)v), (cid:9)e (cid:5))1234567(cid:9)ei ← (cid:9)ei−1 + δ(cid:9)ejilayeri [(cid:9)ei ] ← layeri [(cid:9)ei ] ∨ SUBCOMPfor j = 1 to ri← emptyMapji (φ)8910child ← layerm[(cid:9)v(cid:3)/(cid:9)v]return MAKENODES(child)Fig. 12. The STATESETEXPAND function for a conjunctive branching partitioning.Fig. 13. Entries in layeri of CONJUNCTIVESTATESETEXPAND((cid:4)S, 5(cid:5)) for a problem with four concurrent subsystems each with transitions asso-ciated with cost estimate changes {−1, 0, 1}.Table 1The six search algorithms compared in the experimental evaluationGHSETA*FSETA*BIDIRA*BDDA*iBDDA*The GHSETA* algorithm with evaluation function f (n) = g(n) + h(n).The FSETA* algorithm with evaluation function f (n) = g(n) + h(n).BDD-based blind breadth-first bidirectional search using the heuristic for choosing search direction described in Section 6.2.Ordinary A* with duplicate elimination, explicit state representation, and evaluation function f (n) = g(n) + h(n).15The BDDA* algorithm as described in [21].An improved version of BDDA* described below.7. Experimental evaluationEven though weighted A* and greedy best-first search are subsumed by the state-set branching framework, theexperimental evaluation in this article focuses on algorithms performing search similar to A*. There are several reasonsfor this. First, we are interested in finding optimal or near optimal solutions, and for greedy best-first search, the wholeemphasis would be on the quality of the heuristic function rather than the efficiency of the search approach. Second,the behavior of A* has been extensively studied, and finally, we compare with BDDA*. Readers interested in theperformance of state-set branching algorithms of weighted A* with other weight settings than w = 0.5 (see Eq. (1))are referred to the work by Jensen et al. [30].We have implemented a general search engine in C++ using the BuDDy BDD package14 [38]. This package hastwo major parameters: (1) the number of BDD-nodes allocated to represent the shared BDD (n), and (2) the numberof BDD nodes allocated to represent BDDs in the operator caches used to implement dynamic programming (c). Theinput to the search engine is a search problem defined in the STRIPS part of PDDL [41] or an extended version ofNADL [34] with action costs. The output of the search engine is a solution found by one of the six search algorithmsdescribed in Table 1.14 We also made experiments using the CUDD package [55], but did not obtain significantly better results than with the BuDDy package.15 For planning problems each state is represented by the set of true facts in the state. Since a set of states for a fixed number of facts uses spacelinear in the size of the set, we consider it an explicit state representation.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139117open( (cid:9)f , (cid:9)v) ← h( (cid:9)f , (cid:9)v) ∧ s0((cid:9)v)while (open (cid:12)= ∅)function BDDA*(s0((cid:9)v))1234567(fmin, min((cid:9)v), open(cid:3)( (cid:9)f , (cid:9)v)) ← GOLEFT(open)if (∃(cid:9)v . (min((cid:9)v) ∧ G((cid:9)v)) return fminopen(cid:3)(cid:3)( (cid:9)f (cid:3), (cid:9)v) ← ∃(cid:9)v . min((cid:9)v) ∧ T ((cid:9)v, (cid:9)v)∧∃(cid:9)e . h((cid:9)e, (cid:9)v) ∧ ∃(cid:9)e(cid:3) . h((cid:9)e(cid:3), (cid:9)v) ∧ ( (cid:9)f (cid:3) = fmin + (cid:9)e(cid:3) − (cid:9)e + 1)open( (cid:9)f , (cid:9)v) ← open(cid:3)( (cid:9)f , (cid:9)v) ∨ open(cid:3)(cid:3)( (cid:9)f (cid:3), (cid:9)v)[ (cid:9)f (cid:3) \ (cid:9)f , (cid:9)v(cid:3) \ (cid:9)v]Fig. 14. The BDDA* algorithm.Table 2The performance parameters of the search enginettotaltreltsearch|sol||expand||Q|max|T |itThe total elapsed CPU time of the search engine.Time to generate the transition relation. For BDDA* and iBDDA*, this also includes building the symbolic representation of theheuristic function and f -formulas.Time to search for and extract a solution.Solution length.For BIDIR this is the average size of the BDDs representing the search frontier. For FSETA* and GHSETA*, it is the average size ofBDDs of search nodes being expanded. For BDDA* and iBDDA*, it is the average size of open(cid:3)(cid:3)Maximal number of nodes on the frontier queue.Sum of number of nodes of BDDs representing the partitioned transition relation.Number of iterations of the algorithm..The GHSETA*, FSETA*, and BIDIR search algorithms have been implemented as described in this article. Theordinary A* algorithm manipulates and represents states explicitly. For FGk, DxV yM z, and the (N 2 − 1)-puzzles,specialized algorithms with customized state representations have been developed to minimize the space consumption.For planning problems states have been encoded explicitly as sets of facts and actions have been represented in theusual STRIPS fashion. All of the ordinary A* algorithms use the same strategy as GHSETA* to eliminate duplicates.Thus, all states that already have been visited previously with lower or equal g-costs are eliminated. The BDDA*algorithm has been implemented as described in [21]. The algorithm presented in this article is shown in Fig. 14. Itcan only solve search problems in domains with unit transition costs. The search frontier is represented by a singleBDD open( (cid:9)f , (cid:9)v). This BDD is the characteristic function of a set of states paired with their f -cost. The state isencoded as usual by a Boolean vector (cid:9)v and the f -cost is encoded in binary by the Boolean vector (cid:9)f . Similar toFSETA*, BDDA* expands all states min((cid:9)v) with minimum f -cost (fmin) in each iteration. The f -cost of the childstates is computed by arithmetic operations at the BDD level (lines 5 and 6). The change in h-cost is found by applyinga symbolic encoding of the heuristic function to the child and parent state. BDDA* is able to find optimal solutions,but the algorithm only returns the path cost of such solutions. In our implementation, we therefore added a functionfor tracing a solution backward. In the domains we have investigated, this extraction function has low complexity,as did those for GHSETA* and FSETA*. Our implementation of BDDA* shows that it often can be improved by:(1) defining a computation of open(cid:3)(cid:3) using a disjunctive partitioned transition relation instead of monolithic transitionrelation as in lines 5 and 6, (2) precomputing the arithmetic operation at the end of line 6 for each possible f -cost, (3)interleaving the BDD variables of (cid:9)f , (cid:9)e, and (cid:9)e(cid:3) to improve the arithmetic BDD operations, and (4) moving this blockof variables to the middle of the BDD variable ordering to reduce the average distance to dependent state variables.All of these improvements except the last have been considered to some degree in later versions of BDDA* [16]. Thelast improvement, however, is actually antagonistic to the recommendation of the BDDA* inventors who locate the (cid:9)fvariables at the beginning of the variable ordering to simplify the GOLEFT operation. However, we get up to a factorof two speed up with the above modification. The improved algorithm is called iBDDA*.In order to factor out differences due to state encodings and BDD computations, all BDD-based algorithms use thesame bit vector representation of states, the same variable ordering of the state variables, and similar space allocationand cache sizes of the BDD package. This is necessary since a dissimilarity in just one of the above mentioned proper-ties may cause an exponential performance difference. All algorithms share as many subcomputations as possible, butredundant or unnecessary computations are never carried out for a particular instantiation of an algorithm. The perfor-mance parameters of the search engine are shown in Table 2. Time is measured in seconds. The time ttotal − trel − tsearchis spent on allocating memory for the BDD package, parsing the problem description and in case of PDDL problems118R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139analyzing the problem in order to make a compact Boolean state encoding (the domain analysis method is explained inSection 7.4). For all domains, the size of the state space is given as the number of possible assignments to the Booleanstate variables used to represent the domain. All experiments except the ones on the Pipes World and Free Cell do-main are carried out on a Linux 2.4 PC with a 500 MHz Pentium III CPU, 512 KB L2 cache, and 512 MB RAM.Experiments on the Pipes World and Free Cell domain has been carried out on a Linux 2.6 PC with a 3.20 GHz IntelXeon CPU, 1024 KB L2 cache, and 3 GB RAM. Time out and out of memory are indicated by Time and Mem. Timeout changes between the experiments. The algorithms are considered out of memory when they start page faulting tothe hard drive.Our experiments cover a wide range of search domains and heuristics. The first domain FGk uses the minimumHamming distance as heuristic function. It has been artificially designed to demonstrate that GHSETA* may have ex-ponentially better performance than single-state A*. Next, we consider another artificial domain called the DxV yM zpuzzle again using the minimum Hamming distance as heuristic function. The purpose of this domain is to showthe scalability of state-set branching as a function of the dependency between objects in the domain. In particular, itdemonstrates how the u parameter of GHSETA* can be used to focus the search on a subset of optimal paths whenthere is an abundance of these. We then turn to studying several well-known search domains including the (N 2 − 1)-puzzles and STRIPS [22] planning problems from the international planning competitions 1998–2004. We start byexamining the 24- and 35-puzzles using the usual sum of Manhattan distances as heuristic function. The planningdomains include Blocks World, Logistics, Gripper, Zeno Travel, Pipes World, and Free Cell. The experiments onplanning domains are interesting since they consider a backward search guided by an approximation to the HSPrheuristic [8]. In the final experiment, we show an example of state-set branching using a conjunctive branching parti-tioning. We study a range of channel routing problems from VLSI design produced from two circuits of the ISCAS-85benchmarks [57] using a specialized heuristic function.7.1. FGkThis problem is a modification of Barret and Weld’s D1S1 problem [4]. The problem is easiest to describe inSTRIPS. Thus, a state is a set of facts and actions are fact triples defining sets of transitions. In a given state S, anaction defined by (cid:4)pre, add, del(cid:5) is applicable if pre ⊆ S, and the resulting state is S(cid:3) = (S ∪ add) \ del. The actionsareA11pre : {F ∗}add : {G1}del : {}i = 2, . . . , nA1i ,pre : {F ∗, Gi−1}add : {Gi}del : {}i = 1, . . . , nA2i ,pre : {}add : {Fi}del : {F ∗}.Each action is assumed to have unit cost. The initial state is {F ∗} and the goal state is {Gi | k < i (cid:3) n}. Action A1iproduces Gi given that Gi−1 and F ∗ belong to the current state. In each state, however, the actions A2n arealso applicable and they consume F ∗. Thus, if one of these actions is applied no further A1i actions can be applied.n. The purpose of the A2This means that the only solution is A1i actions is to make the decision of which actionto apply in each state non-trivial. Without guidance the average number of states that must be visited in order to finda solution grows exponentially with the search depth.1, . . . , A11, . . . , A2This domain has been artificially designed to demonstrate the advantage of using BDDs to implicitly representsets of states as done by GHSETA* compared to representing states explicitly as done by the ordinary single-state A*algorithm.A state is represented by a vector of Boolean state variables(G1, . . . , Gn, F1, . . . , Fn, F∗).Hence, in the initial state F ∗ is true, while all the other state variables are false. In a goal state, the state variablesGk+1, . . . , Gn are true while all other state variables may have arbitrary truth value. The heuristic value h(s) of a states is the minimum Hamming distance to a goal states. That is the number of goal state variables (Gk+1, . . . , Gn) thatare false in the state s. Since the heuristic function gives no information to guide the search on the first k steps, wemay expect the complexity of the ordinary A* algorithm to grow exponentially with k.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139119Fig. 15. Total CPU time of the FGk problems.In this experiment, we only compare the total CPU time and number of iterations of GHSETA* and single-stateA*. The FGk problems are defined in NADL. A specialized poly-time BDD operation for splitting NADL actions intotransitions with the same cost estimate change is used for GHSETA* in the preprocessing phase. No upper bound(u = ∞) is used by GHSETA* and no upper limit of the branching partitions is applied. For the FGk problemsconsidered, n equals 16. This corresponds to 33 bits in the BDD encoding of the domain. The parameters of the BDDpackage are hand tuned in each experiment for best performance. Time out is 600 seconds. The results are shownin Fig. 15. The performance of A* degrades quickly with the number of unguided steps. A* gets lost expanding anexponentially growing set of states. The GHSETA* algorithm is hardly affected by the lack of guidance. An analysis ofthe unguided frontier layers shows that these form expressions that can be represented by symmetric functions. Sincethese functions can be represented by polynomial sized BDDs, GHSETA* is able to perform an ordinary BDD-basedblind forward search on the unguided frontier layers using only polynomial time. Thus, the performance differencebetween A* and GHSETA* grows exponentially.7.2. DxV yM zThe DxV yM z domain is an artificial puzzle domain where the dependency between objects in the domain can beadjusted without changing the number of bits in the state encoding. The domain has the minimum Hamming distanceas an admissible heuristic. It consists of a set of sliding tokens that can be moved between the corner positions ofhypercubes. In any state, a corner position can be occupied by at most one token. Each action moves a single token toan empty adjacent corner. The dimension of the hypercubes is y. That is, the hypercubes are described by y Booleanvariables. For y = 3 the hypercubes are regular three dimensional cubes with 8 corners. Each corner is associatedwith a particular assignment of the y Boolean variables. We enumerate the corners according to the value encodedin binary of the Boolean variables. Hence, an action simply flips the value of one of these Boolean variables. Thereare z tokens of which x are moving on the same hypercube. The remaining z − x tokens are moving on individualhypercubes. This means that there is a total of z − x + 1 hypercubes. Tokens on individual hypercubes do not interactwith other tokens. Thus, the x parameter can be used to adjust the dependency between tokens without changing thenumber of bits in the state encoding.The tokens are numbered. Initially, each token is located at a corner position with the same number. There are 2ycorners on each hypercube. The goal is to move a token with number n to the corner with number 2y − n − 1. Eachaction is assumed to have unit cost. Fig. 16 shows the initial state of D3V 3M 6.120R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Fig. 16. The initial state of D3V 3M6.Fig. 17. Total CPU time of the Dx V 4M15 problems.When x = z all tokens are moving on the same cube. If further x = 2y − 1 all corners of the cube except one willbe occupied making it a permutation problem similar to the 8-puzzle. The key idea about this problem is that the xparameter allows the dependency of tokens to be adjusted linearly without changing the number of bits used to encodea state. In addition, it demonstrates how the u parameter of the GHSETA* algorithm can be used to focus the searchwhen there is an abundance of optimal paths to explore. For the BDD-based algorithms, the DxV 4M 15 problems aredefined in NADL. Again a specialized poly-time BDD operation for splitting NADL actions into transitions with thesame cost estimate change is applied by GHSETA* and FSETA*. For all problems, the number of bits in the BDDencoding is 60. For GHSETA* the upper bound for node merging is 200 (u = 200). All BDD-based algorithms exceptBDDA* utilize a disjunctive partitioning with an upper bound on the BDDs representing a partition of 5000. Timeout is 500 seconds. For all problems, the BDD-based algorithms use 2.3 seconds on initializing the BDD package(n = 8000000 and c = 700000).16 The results are shown in Table 3. Fig. 17 shows a graph of the total CPU time forthe algorithms.All solutions found are 34 steps long. For BDDA* and iBDDA* the size of the BDD representing the heuristicfunction is 2014 and 1235, respectively. Both the size of the monolithic and partitioned transition relation growsfast with the dependency between tokens. The problem is that there is no efficient way to model whether a positionis occupied or not. The most efficient algorithm is GHSETA*. The FSETA* algorithm has worse performance thanGHSETA* because it has to expand all states with minimum f -cost in each iteration, whereas GHSETA* focus on a16 Notice that we choose to allocate a large number of nodes even for the small problems. The reason is that we mainly care about the asymptoticperformance of the algorithms. Better results can be obtained on the small problems by adjusting the number of nodes to the size of the problem(e.g., by doubling an initially small number of nodes every time the BDD package runs out of free nodes).R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Table 3Results of the Dx V 4M15 problemsAlgorithmGHSETA*FSETA*BDDA*iBDDA*A*BIDIRx123456789101112123456789101234567891234567123456123456ttotal2.72.83.13.23.13.33.94.98.129.546.9Mem2.72.83.13.35.19.637.563.4408.3Time3.63.94.65.510.256.4214.8312.1Time4.04.25.16.233.7117.6Time1.11.11.01.00.9Time2.72.73.25.2278.9Timetrel0.30.30.40.50.40.61.01.95.014.343.80.30.30.40.40.50.61.02.04.90.50.50.60.81.33.410.852.70.40.40.50.40.40.50.20.20.30.20.2tsearch0.20.20.30.40.40.40.50.60.812.80.80.20.20.40.62.36.634.259.1401.10.40.61.32.06.250.4201.1256.10.81.11.93.030.4113.9|expand|307.3307.3671.0441.7194.8139.9128.4115.9132.0146.1107.3307.3307.3671.0671.01778.62976.59046.79046.724175.4314.3314.3678.0678.01785.62983.59053.79053.7307.3307.3671.0671.01778.62976.50.10.20.72.6276.4568.5630.82305.13131.130445.0|Q|max33333372120212322438557510333611111111118841882177017501626|T |7101472407010292209744597810435823227870595619704065537402710147240701029220974459781043582322787059563557722128648420050649592347579983463557722128679125298845593557722128515910610121it34343434343434343437334343434343434343434343434343434343434343434343434343434343434343434122R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Fig. 18. Goal state of the 24-puzzle.subset of them by having u = 200. A subexperiment shows that GHSETA* has similar performance to FSETA* whensetting u = ∞. The impact of the u parameter is significant for this problem since, even for fairly large values of x, ithas an abundance of optimal solutions. As can be seen for problem 10, however, the low value of u may also lead tomore search. BDDA* has much worse performance than FSETA* even though it expands the exact same set of statesin each iteration. As we show in Section 7.6, the problem is that the complexity of the computation of open(cid:3)(cid:3) growsfast with the size of the BDD representing the states to expand. Surprisingly the performance of iBDDA* is worsethan BDDA*. This is unusual, as the remaining experiments will show. The reason might be that only a little space issaved by partitioning the transition relation in this domain. This may cause the computation of open(cid:3)(cid:3) for iBDDA* todeteriorate because it must iterate through all the partitions. A* performs well when f (n) is a perfect or near perfectdiscriminator, but it soon gets lost in keeping track of the fast growing number of states on optimal paths. It times outin a single step going from about one second to more than 500 seconds. The problem for BIDIR is the usual for blindBDD-based search algorithms applied to hard combinatorial problems: the BDDs representing the search frontiersblow up.7.3. The 24- and 35-puzzleWe have further analyzed “non-artificial” domains. We aim at using domains that embed a search with a potentialsignificant large number of search states. We turned to investigating the (N 2 − 1)-puzzles, in particular the 24-puzzle(n = 5) and the 35-puzzle (n = 6). The domain consists of an n × n board with n2 − 1 numbered tiles and a blankspace. A tile adjacent to the blank space can slide into the space. The task is to reach the goal configuration as shownfor the 24-puzzle in Fig. 18. For our experiments, the initial state is generated by performing r random moves from thegoal state.17 We assume unit cost transitions and use the well-known sum of Manhattan distances of the tiles to theirgoal position as heuristic function. This heuristic function is admissible. For GHSETA* and FSETA* a disjunctivebranching partitioning is easy to compute since δh of an action changing the position of a single tile is independentof the position of the other tiles. The two algorithms have no upper bound on the size of BDDs in the frontier nodes(u = ∞). For the BDD-based algorithms, the problems are defined in NADL and the best results are obtained whenhaving no limit on the partition size. Thus, BDDA*, iBDDA*, and BIDIR use a monolithic transition relation. Thenumber bits in the BDD encoding of the 24-puzzle is 125. The results of this experiment are shown in Table 4. For all24-puzzle problems, the BDD-based algorithms spend 3.6 seconds on initializing the BDD package (n = 15000000and c = 500000). Time out is 10000 seconds. For BDDA* and iBDDA* the size of the BDD representing the heuristicfunction is 33522 and 18424, respectively. For GHSETA* and FSETA* the size of the transition relations is 70582,while the size of the transition relation for BDDA* and iBDDA* is 66673. Thus a small amount of space was saved byusing a monolithic transition relation representation. However, GHSETA* and FSETA* have better performance thanBDDA* and iBDDA* mostly due to the their more efficient node expansion computation. Interestingly, both BDDA*and iBDDA* spend significant time computing the heuristic function in this domain. The GHSETA* and FSETA*17 In each of these steps choosing the move back to the previous state is illegal.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Table 4Results of the 24-puzzle problemsAlgorithmGHSETA*FSETA*BDDA*iBDDA*A*BIDIRr140160180200220240260280300320140160180200220240260140160180200220240260140160180200220240260140160180200220240260140160180200220240ttotal28.830.031.443.736.3199.35673.7Mem4772.7Mem29.732.234.350.141.8205.2Mem98.5114.7129.8425.0267.74120.1Time79.885.393.6314.6156.92150.3Mem0.10.90.67.42.387.1Mem68.196.0214.71286.03168.8Memtrel22.122.222.221.922.222.023.920.921.020.921.021.021.021.083.083.282.983.182.883.166.765.765.765.865.665.936.636.836.836.836.8tsearch2.73.85.314.910.1173.25644.54743.974.77.49.525.317.0180.511.327.442.7337.1180.64032.85.911.820.0240.983.52076.627.955.6174.31245.63128.4|sol||expand|26283236365056602628323636502628323636502628323636502628323636502628323636187.5213.2270.2786.2411.12055.510641.29761.3669.91051.61207.05276.03117.618243.3676.91058.61214.05283.03124.618250.3669.91051.61207.05276.03117.618243.334365.255388.4106166.0359488.0421307.0|Q|max23242831314448531111113007251470159275228159231it1239317525357549015432576270542576993881564257699388156425769938815622154611061253941471334182628323636algorithms also scale better than A* and BIDIR. A* has good performance because it does not have the substantialoverhead of computing the transition relation and finding actions to apply. However, due to the explicit representationof states, it runs out of memory for solution depths above approximately 50. For BIDIR, the problem is the usual: theBDDs representing the search frontiers blow up. Fig. 19 shows a graph of the total CPU time of the 24- and 35-puzzle.Again time out is 10000 seconds.124R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Fig. 19. Total CPU time for the 24- and 35-puzzle problems.7.4. Planning domainsIn this section, we consider six planning problems from the STRIPS track of the international planning compe-titions 1998–2004. The problems are defined in the STRIPS part of PDDL. An optimal solution is a solution withminimal length, so we assume unit cost actions. A Boolean representation of a STRIPS domain is trivial if using asingle Boolean state variable for each fact. This encoding, however, is normally very inefficient due to its redundantrepresentation of static facts and facts that are mutually exclusive or unreachable. In order to generate a more compactencoding, we analyze the STRIPS problem in a three step process.(1) Find static facts by subtracting the facts mentioned in the add and delete sets of actions from the facts in the initialstate.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139125(2) Approximate the set of reachable facts from the initial state by performing a relaxed reachability analysis, ignoringthe delete set of the actions.(3) Find sets of single-valued predicates [25] via inductive proofs on the reachable facts.If a set of predicates are mutual exclusive when restricting a particular argument in each of them to the same objectthen the set of predicates is said to be single-valued. Consider for instance a domain where packages can be eitherinside a truck in(P , T ) or at locations at(P , L). Then in and at at are single-valued with respect to the first argument.The reachability analysis in step 2 is implemented based an approach described in the work by Edelkamp and Helmert[20]. It is fast for the problems considered in this article (for most problems less than 0.04 seconds). The algorithmproceeds in a breadth-first manner such that each fact f can be assigned a depth d(f ) where it is reached. Similar tothe MIPS planning system [16], we use this measure to approximate the HSPr heuristic [8]. HSPr is an efficient butnon-admissible heuristic for backward search. For a state given by a set of facts S, the approximation to HSPr is givenbyh(S) =(cid:12)d(f ).f ∈SA branching partitioning for this heuristic is efficient to generate given that each action (pre, add, del) leading from Sto S(cid:3) = (S ∪ add) \ del satisfiesdel ⊆ preand add ∩ pre = ∅.These requirements are natural and satisfied by all the planning domains considered in this article. Due to the con-straints, we getδh = h(S(cid:3)) − h(S)= h(add \ S) − h(del)(cid:12)=d(f ) −(cid:12)d(f ).f ∈add\Sf ∈delThus, each action is partitioned in up to 2|add| sets of transitions with different δh-cost.The HSPr heuristic is applied in a backward search rather than a regression search.18 This affects computingthe h-cost of a goal state. Consider a planning problem with k facts {f1, . . . , fk} and goal description G = (f1).In a regression search, G represents a single state with h(G) = d(f1). In a backward search, on the other hand, Grepresents 2k−1 states that in principle each may have different h-cost. To avoid this problem, we have extended thegoal descriptions of the planning problems so they correspond to single states. This may increase the solution lengthof the problems. In addition, it makes the backward exploration more similar to forward exploration in that it onlyconsiders valid states. Thus, by extending the goal description we also avoid a common deterioration of BDD-basedsearch when applied backward due to an exploration of an unstructured space consisting of a mixture of valid andinvalid states.Since the HSPr heuristic for most states in many of the studied domains either under- or overestimates the truedistance to the initial state, we have manually scaled it to be as accurate as possible. The reason for this is to givea comparison with the optimal BIDIR algorithm that is as fair as possible. If the heuristic overestimates, the A*algorithms may be fast but give poor solutions. If the heuristic underestimates, the A* algorithms may give optimalsolutions but be overly slow. However, despite of these adjustments the complexity difference between suboptimaland optimal search makes a direct comparison between BIDIR and the A* algorithms impossible when using aninadmissible heuristic like HSPr.7.4.1. Blocks worldThe Blocks World is a classical planning domain. It consists of a set of cubic blocks sitting on a table. A robot armcan stack and unstack blocks from some initial configuration to a goal configuration. The problems, we consider, are18 Using BDDs for regression search is an interesting direction for future work.126R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Table 5Results of the Blocks World problemsAlgorithmGHSETA*FSETA*BDDA*iBDDA*A*BIDIRp45678910111213141545678910111213141545678910456789104567891045678910ttotal2.62.72.63.14.117.0116.2133.514.8Time112.1Time2.52.72.73.23.930.0217.0259.839.2Time274.3Time3.33.63.64.96.0100.8Time2.72.82.93.76.2113.7Time0.00.20.41.331.9233.9Time2.62.62.73.69.7146.8Timetrel0.00.10.10.20.30.40.60.71.01.70.00.10.10.20.30.40.60.81.01.70.00.20.20.50.51.10.00.10.10.30.40.60.00.10.10.20.30.4tsearch0.00.10.10.41.314.1113.1130.211.2107.80.00.10.10.51.127.1213.8256.435.7270.00.10.20.21.22.296.50.00.10.10.73.2110.30.00.20.41.231.6232.90.00.00.10.86.8143.9|sol||expand|612122018323832343861212201832383234386121220183261212201832612122018326121220183019.533.457.753.8540.4331.8744.91404.9410.31067.829.868.7126.8121.91328.8935.52594.44756.0817.01555.137.876.7134.8129.91336.8943.529.868.7126.8121.91328.8935.5124.5228.3438.81931.311181.875040.9|Q|max11194812941119112012514282101291313862115287778738221it631301527299123091200557106162320923561010986718601462623209235610623209235610157010228752523183161212201830|T |7061346260846857475871711392161221873430707706134626084685747587171139216122187343070770613652334466969599923706136523344669712310361706142325675263815711443R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139127Fig. 20. Total CPU time for the Blocks World and Gripper problems.from the untyped STRIPS track of the AIPS 2000 planning competition. The number of bits in the BDD encodingis in the range [17, 80]. The HSPr heuristic is scaled by a factor of 0.4. The GHSETA* and FSETA* algorithmshave no upper bound on the size of BDDs of the nodes on the frontier (u = ∞). For all BDD-based algorithms, thepartition limit is 5000. For each problem, these algorithms spend about 2.5 seconds on initializing the BDD package(n = 8000000 and c = 800000). Time out is 500 seconds in all experiments. The results are shown in Table 5. Thetop graph of Fig. 20 shows the total CPU time of the algorithms. For BDDA* and iBDDA* the size of the BDDrepresenting the heuristic function is in the range of [8, 1908] and [8, 1000], respectively. The GHSETA* and FSETA*algorithms have significantly better performance than all other algorithms. As usual BDDA* and iBDDA* sufferfrom an inefficient expansion computation while the frontier BDDs blow up for BIDIR. The general A* algorithm forSTRIPS planning problems is less domain-tuned than the previous A* implementations. In particular, it must check128R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139the precondition of all actions in each iteration in order to find the ones that are applicable. This, in addition to theexplicit state representation, may explain the poor performance of A*.7.4.2. GripperThe Gripper problems are from the first round of the STRIPS track of the AIPS 1998 planning competition. Thedomain consists of a robot with two grippers which can move between two rooms connected by a door. Initially, anumber of balls are located in the first room, and the goal is to move them to the other room. The number of bitsin the BDD encoding is in the range [12, 88]. The GHSETA* and FSETA* algorithms have no upper bound on thesize of BDDs in the frontier nodes (u = ∞). For all BDD-based algorithms no partition limit is used, and they spendabout 0.8 seconds on initializing the BDD package (n = 2000000 and c = 400000). All algorithms generate optimalsolutions. The results are shown in Table 6. The bottom graph of Fig. 20 shows the total CPU time of the algorithms.Interestingly BIDIR is the fastest algorithm in this domain since the BDDs representing the search frontier only growsmoderately during the search. The GHSETA* and FSETA* algorithms, however, have almost as good performance.BDDA* and iBDDA* has particularly bad performance in this domain. The problem is that the BDDs of frontiernodes grow quite large for the harder problems.7.4.3. LogisticsThe Logistics domain considers moving packages with trucks between locations in the same city and with airplanesbetween cities. The problems considered are from the STRIPS track of the AIPS 2000 planning competition. Thenumber of bits in the BDD encoding is in the range [21, 86]. The GHSETA* and FSETA* algorithms have no upperbound on the size of BDDs in the frontier nodes (u = ∞). For all BDD-based algorithms a partition limit of 5000is used and they spend about 2.0 seconds on initializing the BDD package (n = 8000000 and c = 400000). Due tosystematic under estimation, the HSPr heuristic is scaled with a factor of 1.5. The top graph of Fig. 21 shows the totalCPU time of the algorithms. Only GHSETA* and FSETA* are able to solve large instances of this problem. The BDDencoding based single-valued predicates is particularly efficient in this domain. Moreover, the HSPr heuristic is quitestrong which gives the A* algorithms an edge over BIDIR.7.4.4. Zeno TravelZeno Travel is from the STRIPS track of the AIPS 2002 planning competition. It involves transporting peoplearound in planes, using different modes of movement: fuel-efficient and wasteful. The number of bits in the BDDencoding is in the range [9, 165]. The GHSETA* and FSETA* algorithms have no upper bound on the size of BDDsin the frontier nodes (u = ∞). For all BDD-based algorithms a partition limit of 4000 is used. About 2.7 secondsare spent on initializing the BDD package (n = 10000000 and c = 700000). The bottom graph of Fig. 21 shows thetotal CPU time of the algorithms. The results are fairly similar to the results of the Logistics problems except that theadvantage of GHSETA* and FSETA* is less significant.7.4.5. Pipes WorldThe task in the Pipes World domain is to transport oil derivative products through a pipeline system. Since addinga product to a pipeline affects all the products in the pipeline, the structure of the domain is quite different from thestructure of the Logistics and Zeno Travel domain. If a pipe can hold more than one product, two actions are used tomodel a state change of a pipeline. The first adds the product to the sender end of the pipe, while the second removesthe product that is pushed out at the receiver end of the pipe. The problems, we consider, are from the typed STRIPStrack of the International Planning Competition 2004. The problems have been changed manually to an untypedversion. The number of bits in the BDD encoding is in the range [62, 118]. The HSPr heuristic is scaled by a factorof 0.7 due to systematic over estimation. For GHSETA* no upper bound on the size of BDDs of the nodes on thefrontier is used (u = ∞). For all BDD-based algorithms, the partition limit is 10000 for small problems and 20000 forlarge problems. The number of nodes allocated by the BDD package (n) is in the range [2M, 107M] and the cachesize (c) is adjusted to approximately 10% of the number of nodes. Time out is 3600 seconds in all experiments. Theresults are shown in Table 7.19 The top graph of Fig. 22 shows the total CPU time of the algorithms. For BDDA*19 The |Q|max data have not been gathered for A* in the Pipes World and Free Cell domain. Moreover due to time limitations, we have notinvestigated the performance of FSETA* on these domains.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Table 6Results of the Gripper problemsAlgorithmGHSETA*FSETA*BDDA*iBDDA*A*BIDIR*p24681012141618202468101214161820246810121416182024681012141618202462468101214161820ttotal0.91.01.31.51.82.33.03.64.55.71.01.01.21.62.02.53.13.75.05.71.82.43.46.116.940.781.7149.3240.4391.11.21.62.33.66.212.223.544.876.1120.93.9422.9Time0.91.01.21.41.72.22.63.23.84.5trel0.10.10.20.30.40.50.70.91.11.40.10.10.20.30.40.60.80.91.21.50.10.20.30.60.91.21.62.23.13.90.10.10.30.40.60.91.11.62.22.70.10.10.20.30.40.50.70.91.21.5tsearch0.020.080.270.340.540.881.331.782.463.370.10.10.20.30.61.01.41.92.93.20.20.61.54.014.437.978.5145.4235.5385.50.10.41.02.24.59.221.342.172.4116.73.9422.30.00.10.10.30.50.81.01.31.72.1|expand|68.8168.9314.9504.8738.11014.71334.51697.52103.72553.195.4231.2423.9673.4979.91343.31763.52240.72774.73365.6103.4239.2431.9681.4987.91351.31771.52248.72782.73373.695.4231.2423.9673.4979.91343.31763.52240.72774.73365.6125.4290.9589.7958.21404.31611.02025.63265.64074.44944.9|Q|max56666666661111111111it214365871091311531751972191729415365778910111312517294153657789101113125172941536577891011131256982643412868546817294153657789101113125129|T |594100214101818222626343042345038584266594100214101818222626343042345038584266323539755971118714031619183520512267323539755971118714031619183520512267323539755971118714031619183520512267130R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Fig. 21. Total CPU time for the Logistics and Zeno Travel problems.and iBDDA* the size of the BDD representing the heuristic function is in the range [2244, 18577] and [988, 9743],respectively. The performance of GHSETA* and BIDIR is fairly similar while the performance of BDDA*, iBDDA*,and A* is substantially lower. Looking closer at the results of GHSETA*, A*, and BIDIR, we observe that GHSETA*and A* use considerably longer time on problem 10 compared with problem 9, while the opposite is true for BIDIR.Since BIDIR and GHSETA* represent states in the same way, the results indicate that GHSETA* traverse a largerfraction of the state space than BIDIR on problem 10. Thus, the HSPr heuristic seems to be somewhat weak onthis domain sometimes guiding the exploration in the right direction (problem 9) and sometimes not (problem 10).Interestingly, the performance of A* is better than GHSETA* on problem 8. An inspection of Table 7 shows that bothalgorithms spend little time on search on this problem, but that GHSETA* spends considerable time constructing theBDD representation of the transition relation. Thus, this is an example of a situation where the search problem is toosmall for BDD-based search to pay off.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139131Fig. 22. Total CPU time for the Pipes World and Free Cell problems.7.4.6. Free CellThe Free Cell domain is a solitaire game shipped with Windows. The cards are distributed face up in 8 columns.The goal is to arrange the cards in order in four home cells. In addition to the home cells, there are four free cells.A legal action is to move a card from the bottom of a column or a free cell to a home cell holding the predecessorwith matching suit, an empty free cell, an empty column, or the bottom of a column holding one of the two successorswith opposite color. The problems, we consider, are from the untyped STRIPS track of the International PlanningCompetition 2002. The number of bits in the BDD encoding is in the range [58, 199]. The HSPr heuristic is scaled bya factor of 0.6 due to systematic over estimation. The GHSETA* algorithm has no upper bound on the size of BDDsof the nodes on the frontier (u = ∞). For all BDD-based algorithms, the partition limit is 10000 for small problemsand 20000 for large problems. The number of nodes allocated by the BDD package (n) is in the range [2M, 107M]and the cache size (c) is adjusted to approximately 10% of the number of nodes. Time out is 3600 seconds in all|Q|max3161605654111127132R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Table 7Results of the Pipes World problemsAlgorithmGHSETA*BDDA*iBDDA*A*BIDIRp4567891045678910456789104567891045678910ttotal2.04.54.87.914.779.9168.33.311.317.950.324.2TimeTime2.47.37.513.817.51136.02696.80.36.017.813.71.1207.7555.52.07.04.77.014.8166.339.5trel1.22.21.62.84.89.03.51.73.12.95.39.01.11.91.73.14.88.23.71.01.81.52.63.76.53.1tsearch0.21.21.73.00.461.2161.10.56.613.242.65.40.33.43.87.51.21112.92687.80.23.81.72.21.6149.732.7|sol||expand|8132016142130813201614813201614213081320161421308132016142130185.9389.1334.6457.9171.11356.3741.2204.3599.3414.2683.6453.7198.1593.3406.2675.6448.82105.8902.02646.912146.57236.410860.69841.6260428.048667.4it139224520363680442714654573945414654573945443845201069125942782651139208811042218132016142130|T |38123579924729774988116758195345850222102031406251664039560901395366257837335615688015316490169929395126100037299610017170813850468261experiments. The results are shown in Table 8. The top graph of Fig. 22 shows the total CPU time of the algorithms.For BDDA* and iBDDA* the size of the BDD representing the heuristic function is in the range of [553, 4427] and[366, 2060], respectively. Again, we observe that BDDA* and iBDDA* have substantially lower performance thanGHSETA*. In this domain, however, A* outperforms GHSETA*. The reason for this is that the Boolean encodingof the domain is very weak. The domain does not contain any single-valued predicates which forces each groundedpredicate to be represented by a Boolean variable. Thus, a more sophisticated planning domain analysis than the oneused in this experimental evaluation is necessary. Whether an efficient Boolean encoding exists for this domain is outof the scope of this article. It may be observed, however, that by not deleting the home predicate of the top card of ahome cell when moving a new card to the cell, the predicates on, incell, bottomcol, and home become single-valuedin the first argument. The encoding of the on predicate is similar to the one used in the Blocks World. The reduction,however, is not as efficient as in the Blocks World. In the Blocks World, a block can be on any other block, but in FreeCell, a card can be on at most three other cards: the one it is on initially and the two successors with opposite color.For problem 6, the number of bits in the BDD encoding is only reduced from 199 to 125, and the performance of theBDD-based algorithms is not improved significantly.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139133|Q|max245261126147trel0.73.88.512.934.81.25.915.60.73.65.70.73.65.67.7tsearch0.14.55.5282.1133.20.862.291.00.323.932.10.414.511.0422.9212.7926.90.12.831.1402.4|sol||expand|8141829308141881418814182930358141826221.3418.5416.71116.51046.1518.83022.71871.9510.83014.71863.91687.122252.192794.4389276.0it19210193181688516601251660125138219312543765512190359208141826|T |13192300486265112785421525937358933171533735893326009373589332513658746Table 8Results of the Free Cell problemsAlgorithmGHSETA*BDDA*iBDDA*A*BIDIRp123456123456123456123456123456ttotal1.19.516.7302.8176.9Mem2.870.1110.4MemMemMem1.630.251.3MemMemMem0.514.711.2431.3214.1939.21.17.739.7418.7MemMemFig. 23. A solution to a channel routing problem with 5 columns, 3 tracks, and 2 nets (labeled I and II). The pins are numbered according to whatnet they belong.7.5. Channel routingChannel routing is a fundamental subtask in the layout process of VLSI-design. It is an NP-complete problemwhich makes exact solutions hard to produce. Channel routing considers connecting pins in the small gaps or channelsbetween the cells of a chip. In its classical formulation two layers are used for the wires: one where wires go horizontal(tracks) and one where wires go vertical (columns). In order to change direction, a connection must be made betweenthe two layers. These connections are called vias. Pins are at the top and bottom of the channel. A set of pins thatmust be connected is called a net. The problem is to connect the pins optimally according to some cost function. The134R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139Table 9Results of the ISCAS-85 channel routing problems. A problem, c–t–n, is identified by its number of columns (c), tracks (t ), and nets (n)CircuitAddC432c–t–n38–3–1047–5–2741–3–1246–7–2025–4–683–4–3389–11–58101–9–5799–8–5897–10–63101–7–5395–9–4895–10–4884–5–23ttotal0.20.80.25.00.10.4Mem286.134.0295.015.7223.8Time3.2trel0.10.70.13.50.00.261.513.599.711.558.90.7tsearch0.20.10.11.50.10.2206.620.5195.34.2164.92.5|Q|max124156101355912990590it40464289309311344810910139992cost function studied here equals the total number of vias used in the routing. Fig. 23 shows an example of an optimalsolution to a small channel routing problem. The cost of the solution is 4. One way to apply search to solve a channelrouting problem is to route the nets from left to right. A state in this search is a column paired with a routing of thenets on the left side of that column. A transition of the search is a routing of live nets over a single column. A* can beused in the usual way to find optimal solutions. An admissible heuristic function for our cost function is the sum of thecost of routing all remaining nets optimally ignoring interactions with other nets. We have implemented a specializedsearch engine to solve channel routing problems with GHSETA* [31]. The important point about this application isthat GHSETA* utilizes a conjunctive branching partitioning instead of a disjunctive branching partitioning as in allother experiments reported in this article. This is possible since a transition can be regarded as the joint result ofrouting each net in turn.The performance of GHSETA* is evaluated using problems produced from two ISCAS-85 circuits [57]. For each ofthese problems the parameters of the BDD package are hand tuned for best performance. There is no upper bound onthe size of BDDs in frontier nodes (u = ∞) and no limit on the size of the partitions. Time out is 600 seconds. Table 9shows the results. The performance of GHSETA* is similar to previous applications of BDDs to channel routing [54,57]. However, in contrast to previous approaches, GHSETA* is able to find optimal solutions.7.6. Additional comparative experimentsThe major challenge for BDDA* is that the arithmetic computations at the BDD level scales poorly with the size ofthe BDD representing the set of states to expand (lines 5 and 6 in Fig. 14). This hypothesis can be empirically verifiedby measuring the CPU time used by FSETA* and iBDDA* to expand a set of states. Recall that both FSETA* andiBDDA* expand the exact same set of states in each iteration. Any performance difference is therefore solely causedby their expansion techniques. The results are shown in Fig. 24. The reported CPU time is the average of the 15-puzzlewith 50, 100, and 200 random steps, Logistics problem 4 to 9, Blocks World problem 4 to 9, Gripper problem 1 to 20,and DxV 4M 15 with x varying from 1 to 6. For very small frontier BDDs, iBDDA* is slightly faster than FSETA*.This is probably because small frontier BDDs mainly are generated by easy problems where a monolithic transitionrelation used by iBDDA* is more efficient than the partitioned transition relation used by FSETA*. However, for largefrontier BDDs, iBDDA* needs much more expansion time than FSETA*.7.7. State-set branching versus single-state heuristic searchHeuristic search is trivial if the heuristic function is very informative. In this case, state-set branching may haveworse performance than single-state heuristic search due to the overhead of computing the transition relation. We haveseen an example of this in problem 8 of the Pipes World. Moreover, if we use an inefficient Boolean encoding of adomain, the performance of state-set branching may deteriorate and become worse than single-state heuristic searchR.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139135Fig. 24. Node expansion times of FSETA* and BDDA*.as we have seen for the Free Cell domain. When neither of these issues are present, however, state-set branching hasoutperformed single-state heuristic search in our experiments.In order to control the experimental setting and in particular use the same heuristics for all algorithms, we havehandcoded our single-state A* implementations. Thus, we are not using state-of-the-art implementations of single-state A* and our experiments do not show that state-set branching can outperform state-of-the-art implementations ofsingle-state A*. Only a direct comparison can verify this.On the other hand, specialized versions of single-state A* that take advantage of the domain structure have beendeveloped for FGk, DxV yM z, and the (N 2 − 1)-puzzles. The state representation used by single-state A* in thesedomains is at the same level of sophistication as the node representation used by the BuDDy package. For that reason,we consider the comparison in these domains quite fair. For the planning domains, on the other hand, the generalrepresentation of states as sets of facts may be improved by using representation techniques from the planning com-munity that we are not aware of. This may reduce the memory consumption of single-state A* by a factor. However,no matter which explicit state representation is used, the space consumption of a set of states will be linear in the sizeof the set.Another issue when comparing state-set branching and single-state heuristic search is whether the heuristic functioncan be chosen as freely for state-set branching as for single-state heuristic search. As described earlier, all of theheuristics applied in our experimental evaluation can be represented compactly by a branching partitioning. This isprobably the case for most additive heuristics like the sum of Manhattan distances and HSPr. It is less clear, however,that compact branching partitionings exist for sophisticated heuristics that may have a combinatorial nature or maycover many special cases in an irregular way. Indeed in a recent study, a disjunctive branching partitioning of themax-pair heuristic [28] turned out to be prohibitively large in some domains [32]. We believe that the reason for thisis the artificial and combinatorial nature of the max-pair heuristic. The size of the branching partitioning could bedramatically reduced, however, by making it a function of the h-cost of the search node to expand. Developing thiskind of representation techniques for complex heuristics is an interesting direction for future work.7.8. State-set branching versus blind BDD-based searchBlind BDD-based search has been successfully applied in symbolic model checking and circuit verification. It hasbeen shown that many problems encountered in practice are tractable when using BDDs [58]. The classical searchproblems studied in AI, however, seems to be harder and have longer solutions than the problems considered informal verification. When applying blind BDD-based search to these problems, the BDDs used to represent the search136R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139frontier often grow exponentially. The experimental evaluation of state-set branching shows that this problem can besubstantially reduced when efficiently splitting the search frontier according to a heuristic evaluation of the states.7.9. State-set branching versus BDDA*State-set branching implementations of A* such as GHSETA* and FSETA* are fundamentally different fromBDDA*. BDDA* imitates the usual explicit application of the heuristic function via a symbolic computation. It wouldbe reasonable to expect that the symbolic representation of practical heuristic functions often is very large. However,this is seldom the case for the heuristic functions studied in this article. The major challenge for BDDA* is that thearithmetic computations at the BDD level scales poorly with the size of the BDD representing the set of states toexpand (lines 5 and 6 in Fig. 14). Another limitation of BDDA* is the inflexibility of BDD-based arithmetic. It makesit hard to extend BDDA* efficiently to general evaluation functions and arbitrary transitions costs.8. ConclusionIn this article, we have presented a framework called state-set branching for integrating symbolic and heuristicsearch. The key component of the framework is a new BDD technique called branching partitioning that allows setsof states to be expanded implicitly and sorted according to cost estimates in one step. State-set branching is a generalframework. It applies to any heuristic function, any search node evaluation function, and any transition cost functiondefined over a finite domain. An extensive experimental evaluation of state-set branching proves it to be a powerfulapproach. Except for one case with a weak Boolean encoding, state-set branching outperforms single-state heuristicsearch. In addition, it can improve the complexity of single-state search exponentially and for several of the best-known AI search problems, it is often orders of magnitude faster than single-state heuristic search, blind BDD-basedsearch, and the most efficient current BDD-based A* implementation, BDDA*.It is an important direction for future work to develop techniques for representing branching partitionings com-pactly for sophisticated heuristics that may have a combinatorial nature or may cover many special cases in an irregularway. Other directions for future work include applying state-set branching to regression search and linear space heuris-tic search algorithms such as IDA*.AcknowledgementsWe thank Robert Punkunus for initial work on efficient Boolean encoding of PDDL domains. We also wish tothank Kolja Sulimma for providing channel routing benchmark problems. Finally, we thank our anonymous reviewersfor their valuable comments and suggestions.Appendix ALemma 6. The search structure build by the BSFS algorithm is a DAG where every node (cid:4)S(cid:3), (cid:9)e(cid:3)(cid:5) different from a rootnode (cid:4){s0}, (cid:9)e0(cid:5) has a set of predecessor nodes. For each state s(cid:3) ∈ S(cid:3) in such a node, there exists a predecessor (cid:4)S, (cid:9)e(cid:5)with a state s ∈ S such that T (s, s(cid:3)) and (cid:9)e(cid:3) = (cid:9)e + δ(cid:9)e(s, s(cid:3)).Proof. By induction on the number of loop iterations. We get that the search structure after the first iteration is aDAG consisting of a root node (cid:4){s0}, (cid:9)e0(cid:5). For the inductive step, assume that the search structure is a DAG with thedesired properties after n iterations of the loop (see Fig. 5). If the algorithm in the next iteration terminates in line 3or 5, the search structure is unchanged and therefore a DAG with the required format. Assume that the algorithm doesnot terminate and that (cid:4)S, (cid:9)e(cid:5) is the node removed from the top of frontier. The node is expanded by forming childnodes with the STATESETEXPAND function in line 6. According to the definition of this function, any state s(cid:3) ∈ S(cid:3)in a child node (cid:4)S(cid:3), (cid:9)e(cid:3)(cid:5) has some state s ∈ S in (cid:4)S, (cid:9)e(cid:5) such that T (s, s(cid:3)) and (cid:9)e(cid:3) = (cid:9)e + δ(cid:9)e(s, s(cid:3)). Thus (cid:4)S, (cid:9)e(cid:5) is a validpredecessor for all states in the child nodes. Furthermore, since all child nodes are new nodes, no cycles are createdin the search structure which therefore remains a DAG. If a child node is merged with an old node when enqueuedon frontier the resulting search structure is still a DAG because all nodes on frontier are unexpanded and thereforeR.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139137have no successor nodes that can cause cycles. In addition, each state in the resulting node obviously has the requiredpredecessor nodes. (cid:2)Lemma 7. For each state s(cid:3) ∈ S(cid:3) of a node (cid:4)S(cid:3), (cid:9)e(cid:3)(cid:5) in a finite search structure of the BSFS algorithm there exists a(cid:13)path π = s0, . . . , sn in D such that sn = s(cid:3) and (cid:9)e = (cid:9)e0 +n−1i=0 δ(cid:9)e(si, si+1).Proof. We will construct π by tracing the edges backwards in the search structure. Let b0 = s(cid:3). According to Lemma 6there exists a predecessor (cid:4)S, (cid:9)e(cid:5) to (cid:4)S(cid:3), (cid:9)e(cid:3)(cid:5) such that for some state b1 ∈ S we have T (b1, b0) and (cid:9)e(cid:3) = (cid:9)e + δ(cid:9)e(b1, b0).Continuing the backward traversal from b1 must eventually terminate since the search structure is finite and acyclic.Moreover, the traversal will terminate at the root node because this is the only node without predecessors. Assumethat the backward traversal terminates after n iterations. Then π = bn, . . . , b1. (cid:2)Theorem 8. The BSFS algorithm is sound.Proof. Assume that the algorithm returns a path π = s0, . . . , sn with cost estimates (cid:9)e. Since sn ∈ G it follows fromLemma 7 and the definition of EXTRACTSOLUTION that π is a solution to the search problem associated with costestimates (cid:9)e. (cid:2)Lemma 9. Assume FSETA* and GHSETA* apply an admissible heuristic and π = s0, . . . , sn is an optimal solution,then at any time before FSETA* and GHSETA* terminates there exists a frontier node (cid:4)S, (cid:9)e(cid:5) with a state si ∈ S suchthat (cid:9)e (cid:3) C∗ and s0, . . . , si is the search path associated with si .Proof. A node (cid:4)S, (cid:9)e(cid:5) containing si with associated search path s0, . . . , si must be on the frontier since a node con-taining s0 was initially inserted on the frontier and FSETA* and GHSETA* terminates if a node containing the goalstate sn is removed from the frontier. We have (cid:9)e = cost(s0, . . . , si) + h(si). The path s0, . . . , si is a prefix of an optimalsolution, thus cost(s0, . . . , si) must be the minimum cost of reaching si . Since the heuristic function is admissible, wehave h(si) (cid:3) h∗(si) which gives (cid:9)e (cid:3) C∗. (cid:2)Theorem 10. Given an admissible heuristic function FSETA* and GHSETA* are optimal.Proof. Suppose FSETA* or GHSETA* terminates with a solution derived from a frontier node with (cid:9)e > C∗. Since thenode was at the top of the frontier queue, we have∗C< f (n) ∀n ∈ frontier.However, this contradicts Lemma 9 that states that any optimal path has a node on the frontier any time prior totermination with (cid:9)e (cid:3) C∗. (cid:2)References[1] S.B. Akers, Binary decision diagrams, IEEE Transactions on Computers C-27 (6) (1978) 509–516.[2] F. Bacchus, AIPS-00 Planning Competition: The Fifth International Conference on Artificial Intelligence Planning and Scheduling Systems,AI Magazine 22 (3) (2001) 47–56.[3] R. Bahar, E. Frohm, C. Gaona, E Hachtel, A Macii, A. Pardo, F. Somenzi, Algebraic decision diagrams and their applications, in: IEEE/ACMInternational Conference on CAD, 1993, pp. 188–191.[4] A. Barrett, D.S. Weld, Partial-order planning: Evaluating possible efficiency gains, Artificial Intelligence 67 (1) (1994) 71–112.[5] P. Bertoli, A. Cimatti, M. Roveri, Conditional planning under partial observability as heuristic-symbolic search in belief space, in: Proceedingsof the 6th European Conference on Planning (ECP-01), 2001, pp. 379–384.[6] P. Bertoli, M. Pistore, Planning with extended goals and partial observability, in: Proceedings of the 14th International Conference on Auto-mated Planning and Scheduling (ICAPS-04), 2004, pp. 270–278.[7] R. Bloem, K. Ravi, F. Somenzi, Symbolic guided search for CTL model checking, in: Proceedings of the 37th Design Automation Conference(DAC-00), ACM, 2000, pp. 29–34.[8] B. Bonet, H. Geffner, Planning as heuristic search: New results, in: Proceedings of the 5th European Conference on Planning (ECP-99),Springer, 1999, pp. 360–372.[9] R.E. Bryant, Graph-based algorithms for boolean function manipulation, IEEE Transactions on Computers 8 (1986) 677–691.[10] D. Bryce, D.E. Smith, Planning graph heuristics for belief space search, Journal of Artificial Intelligence Research 26 (2006) 35–99.138R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139[11] J.R. Burch, E.M. Clarke, D.E. Long, Symbolic model checking with partitioned transition relations, in: International Conference on VeryLarge Scale Integration, North-Holland, 1991, pp. 49–58.[12] A. Cimatti, E. Giunchiglia, F. Giunchiglia, P. Traverso, Planning via model checking: A decision procedure for AR, in: Proceedings of the4th European Conference on Planning (ECP-97), Springer, 1997, pp. 130–142.[13] A. Cimatti, M. Pistore, M. Roveri, P. Traverso, Weak, strong, and strong cyclic planning via symbolic model checking, Artificial Intelli-gence 147 (1–2) (2003).[14] A. Cimatti, M. Roveri, Conformant planning via symbolic model checking, Journal of Artificial Intelligence Research 13 (2000) 305–338.[15] E. Clarke, O. Grumberg, D. Peled, Model Checking, MIT Press, 1999.[16] S. Edelkamp, Directed symbolic exploration in AI-planning, in: AAAI Spring Symposium on Model-Based Validation of Intelligence, 2001,pp. 84–92.[17] S. Edelkamp, Symbolic exploration in two-player games: Preliminary results, in: Proceedings of the Sixth International Conference on AIPlanning and Scheduling (AIPS-02) Workshop on Model Checking, 2002.[18] S. Edelkamp, Symbolic pattern databases in heuristic search planning, in: Proceedings of the Sixth International Conference on AI Planningand Scheduling (AIPS-02), 2002, pp. 274–283.[19] S. Edelkamp, External symbolic heuristic search with pattern databases, in: Proceedings of the 15th International Conference on AI Planningand Scheduling (ICAPS-05), 2005, pp. 51–60.[20] S. Edelkamp, M. Helmert, Exhibiting knowledge in planning problems to minimize state encoding length, in: Proceedings of the 6th EuropeanConference on Planning (ECP-99), 1999, pp. 135–147.[21] S. Edelkamp, F. Reffel, OBDDs in heuristic search, in: Proceedings of the 22nd Annual German Conference on Advances in ArtificialIntelligence (KI-98), Springer, 1998, pp. 81–92.[22] R.E. Fikes, N.J. Nilsson, STRIPS: A new approach to the application of theorem proving to problem solving, Artificial Intelligence 2 (1971)189–208.[23] M.P. Fourman, Propositional planning, in: Proceedings of the AIPS-00 Workshop on Model-Theoretic Approaches to Planning, 2000,pp. 10–17.[24] M. Fox, D. Long, PDDL2.1: An extension to PDDL for expressing temporal planning domains, Journal of Artificial Intelligence Research(JAIR) 20 (2003) 61–124.[25] A. Gerevini, L. Schubert, Inferring state constraints for domain-independent planning, in: Proceedings of the 15th National Conference onArtificial Intelligence (AAAI-98), 1998, pp. 905–912.[26] E. Hansen, R. Zhou, Z. Feng, Symbolic heuristic search using decision diagrams, in: Symposium on Abstraction, Reformulation and Approx-imation SARA-02, 2002.[27] P.E. Hart, N.J. Nilsson, B. Raphael, A formal basis for heuristic determination of minimum path cost, IEEE Transactions on SSC 100 (4)(1968).[28] P. Haslum, H. Geffner, Admissible heuristics for optimal planning, in: Proceedings of the 5th International Conference on Artificial Intelli-gence Planning System (AIPS-00), AAAI Press, 2000, pp. 140–149.[29] J. Hoffmann, S. Edelkamp, The deterministic part of IPC-4: An overview, Journal of Artificial Intelligence Research (JAIR) 24 (2005) 519–579.[30] R.M. Jensen, R.E. Bryant, M.M. Veloso, SetA*: An efficient BDD-based heuristic search algorithm, in: Proceedings of 18th National Confer-ence on Artificial Intelligence (AAAI-02), 2002, pp. 668–673.[31] R.M. Jensen, R.E. Bryant, M.M. Veloso, SetA* applied to channel routing. Technical report, Computer Science Department, Carnegie MellonUniversity, 2002. CMU-CS-02-172.[32] R.M. Jensen, E.A. Hansen, S. Richards, R. Zhou, Memory-efficient symbolic heuristic search, in: Proceedings of the 16th InternationalConference on Automated Planning and Scheduling (ICAPS-06), 2006, pp. 304–313.[33] R.M. Jensen, M.M. Veloso, OBDD-based deterministic planning using the UMOP planning framework, in: Proceedings of the AIPS-00Workshop on Model-Theoretic Approaches to Planning, 2000, pp. 26–31.[34] R.M. Jensen, M.M. Veloso, OBDD-based universal planning for synchronized agents in non-deterministic domains, Journal of ArtificialIntelligence Research 13 (2000) 189–226.[35] R.M. Jensen, M.M. Veloso, M. Bowling, Optimistic and strong cyclic adversarial planning, in: Proceedings of the 6th European Conferenceon Planning (ECP-01), 2001, pp. 265–276.[36] R.M. Jensen, M.M. Veloso, R.E. Bryant, Fault tolerant planning: Toward probabilistic uncertainty models in symbolic non-deterministicplanning, in: Proceedings of the 14th International Conference on Automated Planning and Scheduling (ICAPS-04), 2004, pp. 335–344.[37] U. Kuter, D. Nau, M. Pistore, P. Traverso, A hierarchical task-network planner based on symbolic model checking, in: Proceedings of the 15thInternational Conference on Automated Planning and Scheduling ICAPS-05, 2005, pp. 300–309.[38] J. Lind-Nielsen, BuDDy—A Binary Decision Diagram Package, Technical Report IT-TR: 1999-028, Institute of Information Technology,Technical University of Denmark, 1999, http://sourceforge.net/projects/buddy.[39] D. Long, M. Fox, The AIPS-02 planning competition, http://planning.cis.strath.ac.uk/competition/, 2002.[40] D. Long, H.A. Kautz, B. Selman, B. Bonet, H. Geffner, J. Koehler, M. Brenner, J. Hoffmann, F. Rittinger, C.R. Anderson, D.S. Weld, D.E.Smith, M. Fox, The AIPS-98 planning competition, AI Magazine 21 (2) (2000) 13–33.[41] D. McDermott, M. Ghallab, A. Howe, C. Knoblock, A. Ram, M. Veloso, D. Weld, D. Wilkins, PDDL—the planning domain definitionlanguage, Technical report, Yale Center for Computational Vision and Control, 1998.[42] K.L. McMillan, Symbolic Model Checking, Kluwer Academic Publ., 1993.[43] C. Meinel, C. Stangier, A new partitioning scheme for improvement of image computation, in: Proceedings ASP-DAC’2001, 2001, pp. 97–102.R.M. Jensen et al. / Artificial Intelligence 172 (2008) 103–139139[44] C. Meinel, T. Theobald, Algorithms and Data Structures in VLSI Design, Springer, 1998.[45] A. Nymeyer, K. Qian, Heuristic search algorithms based on symbolic data structures, in: Proceedings of the 16th Australian Conference onArtificial Intelligence, in: Lecture Notes in Computer Science, vol. 2903, Springer, 2003, pp. 966–979.[46] J. Pearl, Heuristics: Intelligent Search Strategies for Computer Problem Solving, Addison-Wesley, 1984.[47] M. Pistore, R. Bettin, P. Traverso, Symbolic techniques for planning with extended goals in non-deterministic domains, in: Proceedings of the6th European Conference on Planning (ECP-01), 2001, pp. 253–264.[48] I. Pohl, First results on the effect of error in heuristic search, Machine Intelligence 5 (1970) 127–140.[49] K. Qian, A. Nymeyer, Guided invariant model checking based on abstraction and symbolic pattern databases, in: Proceedings of the 10thInternational Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS-04), 2004, pp. 497–511.[50] R.K. Ranjan, A. Aziz, R.K. Brayton, B. Plessier, C. Pixley, Efficient BDD algorithms for FSM synthesis and verification, in: IEEE/ACMProceedings of the International Workshop on Logic Synthesis, 1995.[51] F. Reffel, S. Edelkamp, Error detection with directed symbolic model checking, in: Proceedings of World Congress on Formal Methods (FM),Springer, 1999, pp. 195–211.[52] D. Sawitzki, Experimental studies of symbolic shortest-path algorithms, in: Proceedings of the 3rd International Workshop on Experimentaland Efficient Algorithms (WEA-04), 2004, pp. 482–498.[53] D. Sawitzki, A symbolic approach to the all-pairs shortest-paths problem, in: Proceedings of the 30th International Workshop on Graph-Theoretic Concepts in Computer Science (WG-04), 2004, pp. 154–168.[54] F. Schmiedle, R. Drechsler, B. Becker, Exact channel routing using symbolic representation, in: Proceedings of IEEE International Symposiumon Circuits and Systems (ISCAS-99), 1999.[55] F. Somenzi, CUDD: Colorado University Decision Diagram Package, ftp://vlsi.colorado.edu/pub/, 1996.[56] H.-P. Störr, Planning in the fluent calculus using binary decision diagrams, AI Magazine (2001) 103–105.[57] K. Sulimma, W. Kunz, An exact algorithm for solving difficult detailed routing problems, in: Proceedings of the 2001 International Symposiumon Physical Design, 2001, pp. 198–203.[58] I. Wegener, Branching Programs and Binary Decision Diagrams, Society for Industrial and Applied Mathematics (SIAM), 2000.[59] C.H. Yang, D.L. Dill, Validation with guided search of the state space, in: Proceedings of the 35th Design Automation Conference (DAC-98),ACM, 1998, pp. 599–604.[60] J. Yuan, J. Shen, J. Abraham, A. Aziz, Formal and informal verification, in: Conference on Computer Aided Verification (CAV-97), 1997,pp. 376–387.