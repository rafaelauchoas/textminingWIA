Artificial Intelligence 234 (2016) 219–271Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintSemi-equilibrium models for paracoherent answer set programs ✩Giovanni Amendola a, Thomas Eiter b,∗João Moura ca Department of Mathematics and Computer Science, University of Calabria, Via P. Bucci, Cubo 30b, 87036 Rende (CS), Italyb Institute of Information Systems, Vienna University of Technology, Favoritenstraße 9-11, A-1040 Vienna, Austriac NOVA LINCS, Departamento de Informática, Universidade Nova de Lisboa, 2829-516 Caparica, Portugal, Michael Fink b, Nicola Leone a, a r t i c l e i n f oa b s t r a c tArticle history:Received 22 December 2014Received in revised form 14 October 2015Accepted 21 January 2016Available online 4 February 2016Keywords:Answer set programmingEquilibrium logicParacoherent reasoningSplitting sequencesInconsistency managementThe answer set semantics may assign a logic program to model, due to logical contradiction or unstable negation, which is caused by cyclic dependency of an atom on its negation. While logical contradictions can be handled with traditional techniques from paraconsistent reasoning, instability requires other methods. We consider resorting to a paracoherent semantics, in which 3-valued interpretations are used where a third truth value besides true and false expresses that an atom is believed true. This is at the basis of the semi-stable model semantics, which was defined using a program transformation. In this paper, we give a model-theoretic characterization of semi-stable models, which makes the semantics more accessible. Motivated by some anomalies of semi-stable model semantics with respect to basic epistemic properties, we propose an amendment that satisfies these properties. The latter has both a transformational and a model-theoretic characterization that reveals it as a relaxation of equilibrium logic, the logical reconstruction of answer set semantics, and is thus called the semi-equilibrium model semantics. We consider refinements of this semantics to respect modularity in the rules, based on splitting sets, the major tool for modularity in modeling and evaluating answer set programs. In that, we single out classes of canonical models that are amenable for customary bottom-up evaluation of answer set programs, with an option to switch to a paracoherent mode when lack of an answer set is detected. A complexity analysis of major reasoning tasks shows that semi-equilibrium models are harder than answer sets (i.e., equilibrium models), due to a global minimization step for keeping the gap between true and believed true atoms as small as possible. Our results contribute to the logical foundations of paracoherent answer set programming, which gains increasing importance in inconsistency management, and at the same time provide a basis for algorithm development and integration into answer set solvers.© 2016 Elsevier B.V. All rights reserved.Some of the results were presented in preliminary form at KR 2010 [17] and JELIA 2014 [2]. This work was partially supported by Regione Calabria ✩under the EU Social Fund and project PIA KnowRex POR FESR 2007–2013, by the Vienna Science and Technology Fund (WWTF) grant ICT 08-020, the Austrian Science Fund (FWF) grant P20841, and by the Italian Ministry of University and Research under PON project Ba2Know (Business Analytics to Know) S.I.-LAB n. PON03PE_0001. The work of J. Moura was supported by grant SFRH/BD/69006/2010 from Fundação para a Ciência e a Tecnologia (FCT) from the Portuguese Ministério do Ensino e da Ciência.* Corresponding author.E-mail addresses: amendola@mat.unical.it (G. Amendola), eiter@kr.tuwien.ac.at (T. Eiter), fink@kr.tuwien.ac.at (M. Fink), leone@mat.unical.it (N. Leone), joaomoura@yahoo.com (J. Moura).http://dx.doi.org/10.1016/j.artint.2016.01.0110004-3702/© 2016 Elsevier B.V. All rights reserved.220G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2711. IntroductionAnswer Set Programming (ASP) is a premier formalism for nonmonotonic reasoning and knowledge representation, mainly because of the existence of efficient solvers and well-established relationships with common nonmonotonic log-ics. It is a declarative programming paradigm with a model-theoretic semantics, where problems are encoded into a logic program using rules, and its models, called answer sets (or stable models) [26], encode solutions; see [6,11,24].As is well-known, not every logic program has some answer set. This can be due to different reasons: (1) an emerging logical contradiction, as e.g. for the programP = { locked(door) ← not open(door); −locked(door) }where “−” denotes strong (sometimes also called classical) negation and “not” denotes weak (or default) negation; according to the first rule, a door is locked unless it is known to be open, and according to the second rule it is not locked. The problem here is a missing connection from −locked(door) to open(door).1 (2) Due to cyclic dependencies which pass through negation, as e.g. in the following simplistic program.Example 1. Consider the barber paradox, which can be regarded as an alternative form of Russell’s famous paradox in naive set theory2: in some town, the barber is a man who shaves all men in town, and only those, who do not shave themselves. The paradox arises when we ask “Who shaves the barber?”. Assuming that Joe is the barber, the knowledge about who is shaving him is captured by the logic programP = {shaves(joe, joe) ← not shaves(joe, joe)},(where joe is the barber), which informally states that Joe shaves himself if we can assume that he is not shaving him-self. Under answer set semantics, P has no model; the problem is a lack of stability, as either assumption on whether shaves(joe, joe) is true or false cannot be justified by the rule.In general, the absence of an answer set may be well-accepted and indicates that the rules cannot be satisfied under stable negation. There are nonetheless many cases when this is not intended and one might want to draw conclusions also from a program without answer sets, e.g., for debugging purposes, or in order to keep a system (partially) responsive in exceptional situations; in particular, if the contradiction or instability is not affecting the parts of a system that intuitively matter for a reasoning problem.In order to deal with this, Inoue and Sakama [49] have introduced a paraconsistent semantics for answer set programs. While dealing with logical contradictions can be achieved with similar methods as for (non-) classical logic (cf. also [9,1,37]), dealing with cyclic default negation turned out to be tricky. We concentrate in this article on the latter, in presence of constraints, and refer to it as paracoherent reasoning, in order to distinguish reasoning under logical contradictions from reasoning on programs without strong negation that lack stability in models.With the idea that atoms may also be possibly true (i.e., believed true), Inoue and Sakama defined a semi-stable seman-tics which, for the program in Example 1, has a model in which shaves(joe, joe) is believed true; this is (arguably) reasonable, as shaves(joe, joe) cannot be false while satisfying the rule. Note however that believing shaves(joe, joe) is true does not provide a proof or founded justification that this fact is actually true; as a mere belief it is regarded to be weaker than if shaves(joe, joe) would be known as a fact or derived from a rule.In fact, semi-stable semantics approximates answer set semantics and coincides with it whenever a program has some answer set; otherwise, under Occam’s razor, it yields models with a smallest set of atoms believed to be true. That is, the intrinsic closed world assumption (CWA) of logic programs is slightly relaxed for achieving stability of models.In a similar vein, we can regard many semantics for non-monotonic logic programs that relax answer sets as paracoherent semantics, e.g. [4,19,39,43,44,47,48,51,56,59]. Ideally, such a relaxation meets for a program P the following properties:(D1)(D2)(D3)Every (consistent) answer set of P corresponds to a model (answer set coverage).If P has some (consistent) answer set, then its models correspond to answer sets (congruence).If P has a classical model, then P has a model (classical coherence).In particular, (D3) intuitively says that in the extremal case, a relaxation should renounce to the selection principles imposed by the semantics on classical models (in particular, if a single classical model exists).Widely-known semantics, such as 3-valued stable models [47], L-stable models [19], revised stable models [43], regular models [59], and pstable models [39], satisfy only part of these requirements (see Section 8.2 for more details). Semi-stable models however, satisfy all three properties and thus have been the prevailing paracoherent semantics.1 Constraints (rules with empty head) may be considered as descriptions of cases when inconsistency arises, if ⊥ (falsum) is added to the head; however, also an instability view is possible, cf. Section 6.2.2 Namely, that the set of all sets that are not members of themselves cannot exist.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2712211.1. Use case scenariosParacoherent semantics may be fruitfully employed in different use cases of ASP, such as model building respectively scenario generation, but also traditional reasoning from the models of a logical theory. The semi-stable model semantics is attractive as it (1) brings in “unsupported” assumptions as being believed, (2) remains close to answer sets in model building, but distinguishes atoms that require such assumptions from atoms derivable without them, not creating justified truth from positive beliefs, and (3) keeps the CWA/LP spirit of minimal assumptions.Let us consider two possible use cases for illustration.1.1.1. Model buildingIn ASP, one of the principal reasoning tasks is model building, which means to compute some, multiple or even all answer sets of a given program. Each answer set encodes a possible world or solution to a problem that is represented by the program.The standard answer set semantics may be regarded as appropriate when a knowledge base, i.e., logic program, is properly specified adopting the CWA principle to deal with incomplete information. It may then be perfectly ok that no answer set exists, as e.g. in the Gedanken-Experiment of the barber paradox. However, sometimes the absence of an answer set is unacceptable as a possible world is known to exist, and in this case a relaxation of the answer set semantics is desired.Example 2. Suppose we have a program that captures knowledge about friends of a person regarding visits to a party, where go( X) informally means that X will go:⎧⎨P =⎩go(John) ← not go(Mark);go(Peter) ← go(John), not go(Bill);go(Bill) ← go(Peter)⎫⎬⎭It happens that P has no answer set. This is unacceptable as we know that there is a model in reality, regardless of who will go to the party, and we need to cope with this situation. Semi-stable semantics is a tool that allows us to gain an answer set, by relaxing the CWA and adopting beliefs without further justifications. In particular, the semi-stable models of this program are Iκ1 and Iκ1concerns the beliefs on Mark and John. In Iκ2 Mark does not go, and, consequently, John will go (moreover, Bill is believed to go, and Peter will not go). In Iκ1 , instead, we believe Mark will go, thus John will not go (likewise Peter and Bill). Notably, and different from other related formalisms (cf. Section 8.2), positive beliefs do not create justified truth: if we had a further rule fun ← go(Mark) in P , then from just believing that Mark will go we cannot derive that fun is true; Iκ1 would remain a semi-stable model.= {go(John), Kgo(John), Kgo(Bill)}. Informally, the key difference between Iκ= {Kgo(Mark)} and Iκ22As already mentioned, paracoherent semantics can serve as a starting point for debugging and also repairing a program. Indeed, if all believed atoms were justified true, then we would obtain an answer set of the program.3 Therefore, we might investigate reasons for the failure to derive these atoms justified, and possibly add new rules or modify existing ones. However, dealing with this issue and linking it to existing work on debugging and repair of answer set programs (e.g., [50,52,25,4,38]) is beyond the scope of this article; we will briefly address it in Section 8.2.1.1.2. Inconsistency-tolerant query answeringQuery answering over a knowledge base resorts usually to brave or cautious inference from the answer sets of a knowl-edge base, where the query has to hold in some or in every answer set, respectively; let us focus on the latter here. However, if incoherence of the knowledge base arises, then we lose all information and query answers are trivial, since every query is vacuously true. This, however, may not be satisfactory and be problematic, especially if one cannot modify the knowledge base, which may be due to various reasons (no permission for change, the designer or administrator of the knowledge base might be unavailable, no clear way to fix the problem etc). Paracoherent semantics can be exploited to overcome this problem and to render query answering operational, without trivialization. We illustrate this on an extension to the barber paradox (but could equally well consider other scenarios).Example 3. Consider a variant of the barber paradox, cf. [49]:P = {shaves(joe, X) ← not shaves(X, X), man(X); man(paul); man(joe)}.While this program has no answer set, the semi-stable model semantics gives us the model {man(joe), shaves(joe, paul), man(paul), K shaves(joe, joe)}, in which shaves(joe, joe) is believed to be true (as expressed by the prefix ‘K ’); here the inco-herent rule shaves(joe, joe) ← not shaves(joe, joe), man(joe), which is an instance of the rule in P for joe, is isolated from the 3 As we shall see, this actually holds for the amended semi-stable semantics.222G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271rest of the program to avoid the absence of models4; this treatment allows us to derive, for instance, that shaves(joe, paul)and man(paul) are true; furthermore, we can infer that shaves(joe, joe) cannot be false. Such a capability seems to be very attractive in query answering: to tolerate inconsistency (that is, incoherence) without a “knowledge explosion.”The well-founded semantics (WFS) [56]is the most prominent approximation of the answer set semantics and in par-ticular useful for query answering, since an atom that is true (resp. false) under WFS is true (resp. false) in every answer set of a program. The WFS has similar capabilities, but takes intuitively a coarser view on the truth value of an atom, which can be either true, false, or undefined; in semi-stable semantics, however, undefinedness has a bias towards truth, expressed by “believed true” (or stronger, by “must be true”); in the example above, under WFS shaves(joe, joe) would be undefined. Furthermore, undefinedness is cautiously propagated under WFS, which may prevent one from drawing expected conclusions.Example 4. Consider the following extension of Russell’s paraphrase:(cid:8)P =shaves(joe, joe) ← not shaves(joe, joe);visits_barber(joe) ← not shaves(joe, joe)(cid:9).Arguably one expects that visits_barber(joe) is concluded false from this program: to satisfy the first rule, shaves(joe, joe)cannot be false, and thus the second rule cannot be applied; thus under CWA, visits_barber(joe) should be false. However, under well-founded semantics all atoms are undefined; in particular, the undefinedness of shaves(joe, joe) is propagated to visits_barber(joe) by the second rule.The single semi-stable model of P from its epistemic transformation is {K shaves(joe, joe)}, according to which shaves(joe, joe) is believed true while visits_barber(joe) is false.Furthermore, it is well-known that the well-founded semantics has problems with reasoning by cases.Example 5. From the program⎧⎨P =⎩shaves(joe, joe) ← not shaves(joe, joe);angry(joe) ← not happy(joe); happy(joe) ← not angry(joe);smokes(joe) ← angry(joe); smokes(joe) ← happy(joe)⎫⎬⎭ ,which is still incoherent with respect to answer set semantics, we cannot conclude that smokes(joe) is true under WFS: as angry(joe) and happy(joe) mutually define each other by negation, WFS remains agnostic and leaves both atoms undefined; their undefinedness is propagated to smokes(joe) by the rules for this atom. In contrast, we can conclude that smokes(joe)is true under semi-stable semantics and its relatives: we have two semi-stable models, one in which angry(joe) is true and happy(joe) is false, and one in which angry(joe) is false and happy(joe) is true; in both models, however, smokes(joe) is true. Moreover, under these semantics we can e.g. not derive that angry(joe) is true, which means that trivialization is avoided.We elucidate the relationship between paracoherent semantics and WFS in more detail in Section 8.1.2. ContributionsDespite the model-theoretic nature of ASP, semi-stable models have been defined by means of a program transformation, called epistemic transformation. A semantic characterization in the style of equilibrium models for answer sets [41] was still missing. Such a characterization is desired because working with program transformations becomes cumbersome, if properties of semi-stable models should be assessed; and moreover, while the program transformation is declarative and the intuition behind is clear, the interaction of rules does not make it easy to understand or to see how the semantics works in particular cases.Starting out from these observations, we have addressed the problem making the following main contributions.– We characterize semi-stable models by pairs of 2-valued interpretations of the original program, similar to so-called here-and-there (HT) models in equilibrium logic [40,41]. Equilibrium logic is the logical reconstruction of the answer set semantics and has proven immensely useful to understand it better from a proof-theoretic perspective based on intuition-istic logic, and to characterize important properties such as strong equivalence of answer set programs [32]; furthermore, it naturally extends to richer classes of programs. The logic of here-and-there, on which equilibrium logic is based, can be seen as the monotonic core of answer set semantics; its semantics is captured by HT-models, which are pairs ( X, Y ), where X ⊆ Y are sets of atoms that are true and believed true, respectively. Thus, to characterize the semi-stable models in terms of HT-models or similar structures is a natural and important issue. In the course of this, we point out some anomalies of 4 A similar intuition underlies the CWA inhibition rule in [42] that is used for contradiction removal in logic programs.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271223the semi-stable semantics with respect to basic rationality properties in modal logics (K and N) which essentially prohibit a 1-to-1 characterization5 in terms of HT-models. Roughly speaking, the epistemic transformation misses some links between atoms encoding truth values of atoms, which may lead in some cases to counterintuitive results.– These anomalies of the semi-stable model semantics lead us to propose an alternative paracoherent semantics, called semi-equilibrium (SEQ) model semantics, which remedies them. It satisfies the properties (D1)–(D3) from above and is fully characterized using HT-models. Informally, semi-equilibrium models are 3-valued interpretations in which atoms can be true, false or believed true; the gap between believed and (derivably) true atoms is globally minimized. That is, SEQ-models can be seen as relaxed equilibrium models respectively answer sets where a smallest set of atoms is believed to be true, without further justification, such that an answer set can be built. Note that the semantic distinction between believed true and true atoms in models is important. Other approaches, e.g. CR-Prolog [4], make a syntactic distinction at the rule level which does not semantically discriminate believed atoms; due to truth propagation, this may lead to more models. Notably, SEQ-models can be obtained by an extension of the epistemic transformation that adds further rules which take care of the anomalies; we thus have both an appealing model-theoretic and a declarative-operational view of the semantics.– Different from equilibrium models, semi-equilibrium models do in general not obey a well-known syntactic modularity property that allows one to build all models of a program by extending the models of a bottom part to the rest of the program. More precisely, splitting sets [31], the major tool for modularity in ASP, cannot be blindly used to decompose an arbitrary program under semi-equilibrium semantics. This shortcoming affects in fact two aspects: (1) program evaluation, which for answer set programs in practice proceeds from bottom to top modules, and (2) problem modeling, where user-defined subprograms are hierarchically organized. To address this, we define split SEQ-models, where a concrete sequence S = (S1, . . . , Sn) of splitting sets S i , called splitting sequence, is used to decompose the program into hierarchically organized subprograms P 1, . . . , P n that are evaluated bottom up.– In general, the resulting split SEQ-models depend on the particular splitting sequence. E.g., the party program in Ex-ample 2 has two SEQ-models, which result from different splitting sequences (see Section 6). This is a drawback, as e.g. in program evaluation a solver may use one of many splitting sequences. In order to make the semantics robust, we thus introduce canonical splitting sequences, with the property that the models are independent of any particular member from a class of splitting sequences, and thus obtain canonical models (Section 6). This is analogous to the perfect models of a (disjunctive) stratified program, which are independent of a concrete stratification [3,46]. We concentrate on program eval-uation and show that for programs P with a benign form of constraints, the class derived from the strongly connected components (SCCs) of P warrants this property, as well as modularity properties. For the party program in Example 2, the single canonical SEQ-model is Iκ2 , as there is no rule from which go(Mark) can be derived. For arbitrary programs, independence is held by a similar class derived from the maximal joined components (MJCs) of P , which intuitively merge SCCs that are involved in malign constraints. A compact summary of the relationships of the different notions of models is shown in Fig. 1 in Section 6.3.– We study major reasoning tasks for the semantics above and provide precise characterizations of their computational complexity for various classes of logic programs. Besides brave and cautious reasoning, deciding whether a program has a model, respectively recognizing models, is considered. Briefly, the results show that semi-stable and SEQ-model semantics reside in the polynomial hierarchy one level above the answer set semantics, and is for brave and cautious reasoning from disjunctive programs (cid:3) p2 -complete. This increase in complexity is intuitively explained by the congruence property (D2), which imposes another layer of op-timization. Notably, split SEQ- and canonical SEQ-models have the same complexity as SEQ-models for these problems, but the model existence problem (which is NP-complete for SEQ-models) is harder ((cid:3) p2 -complete). Intuitively, this is explained by the fact that classical coherence (D3) already ensures SEQ-model existence, but split SEQ- and canon-ical SEQ-models must fulfill further conditions that are a source of complexity.– We compare the SEQ-model semantics to a number of related semantics in the literature. It turns out that it coincides with the evidential stable model semantics for disjunctive logic programs [51]. The latter has been defined like the semi-stable model semantics in terms of a two stage program transformation, but using a rather different program. Thus our results provide as a byproduct also a semantic and computational characterization of the evidential stable model semantics. Another notable result is that the SEQ-model semantics of a slightly enriched program P wf refines the WFS of a given program P , by making in general more atoms true resp. false; hence the query answers from SEQ-models are in general more informative than under WFS (cf. Example 5). Moreover, the same holds for split SEQ-models.3 -complete; for normal programs, the problems are (cid:3) p2 - respectively (cid:4)p3 - respectively (cid:4)p3 - resp. (cid:3) pOur results contribute to enhanced logical foundations of paracoherent answer set programming, which gains increas-ing importance in inconsistency management. They provide a model-theoretic characterization and an amendment of the semi-stable semantics, given by the semi-equilibrium semantics, linking it to the view of answer sets semantics in equilib-rium logic; this also provides the basis for immediate extensions to richer classes of logic programs (see Section 9.3 and Section 10). Furthermore, the split SEQ-model semantics, and in particular the SCC-models semantics, lends itself for a modular use and bottom up evaluation of programs. Cautious merging of components, as done for MJ C-models, aims at 5 By 1-to-1 we mean a one to one and onto (i.e., bijective) correspondence.224G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271preserving independence of components and thus possible parallel evaluation. This makes the refined semantics attractive for incorporation into answer set solvers and evaluation frameworks, in order to offer paracoherent features. Notably, the bottom-up evaluation allows one to switch on the fly to a paracoherent mode when facing an incoherence, i.e., no an-swer set exists. Furthermore the notions and main results for SCC-models can be generalized to user-defined subprograms (Section 9.2).1.2.1. OrganizationThe remainder of this article is organized as follows. In the next section, we review answer set programs, equilibrium logic and semi-stable model semantics. After that, we provide in Section 3 the semantic characterization of semi-stable models and point out some anomalies, which leads us to introduce semi-equilibrium models in Section 4. The refinement of the latter relative to splitting sets and arbitrary splitting sequences is considered in Section 5, while canonical semi-equilibrium models are introduced in Section 6. Section 7 is devoted to characterize the complexity of various semantics and to computational issues in this context. Related work is discussed in Section 8, followed by Section 9 that addresses possible extensions. Section 10 concludes the article with open issues and an outlook. In order not to disrupt the flow of reading, most proofs have been moved to the Appendix.2. PreliminariesIn this paper, we consider a propositional setting of logic programs; extensions to the usual non-ground setting are straightforward. Since we are primarily interested in paracoherence, we also disregard aspects devoted to paraconsistency, i.e., logical contradictions; more specifically, we exclude strong negation. A discussion of how the work extends to non-ground programs and strong negation is given in Section 9.3.We first recall the answer set semantics of disjunctive logic programs, and then its reconstruction as equilibrium logic based on a non-classical logic.2.1. Answer set programsGiven a propositional signature, i.e., a set of propositional atoms (cid:3), a (disjunctive) rule r is of the forma1 ∨ · · · ∨ al ← b1, . . . , bm, not c1, . . . , not cn,(1)where l + m + n > 0, such that all ai , b j and ck are atoms.6 As usual, “not” stands for weak or default negation. The head+(r) = {b1, . . . , bm} (respectively of r is the set H(r) = {a1, . . . , al}, and the positive (respectively negative) body is the set B−(r), where for any set S of atoms, not S = {not a | a ∈ S}. By abuse −(r) = {c1, . . . , cn}); the body of r is B(r) = BBof notation, we will denote r also by+(r) ∪ not BH(r) ← B(r)or H(r) ← B+(r), not B−(r).A rule r is a (disjunctive) fact, if B(r) = ∅ (we then omit ←); a constraint, if H(r) = ∅; normal, if |H(r)| ≤ 1; and positive, if −(r) = ∅.BA (disjunctive logic) program P is a finite set of disjunctive rules (over (cid:3)). A program P is called normal (resp. positive) if each r ∈ P is normal (resp. positive); P is constraint-free, if P contains no constraints.Example 6. Several programs have already been considered in the Introduction. As an example of a disjunctive program, considerP = {assistant ∨ student ← not professor; discount ← student, not assistant}.It intuitively captures that in some department members who are not known to be professors are assistants or students, and a student who is not known to be assistant gets a discount for coffee.We now recall the stable models (also called answers sets) of a program; intuitively, these are models that can be reconstructed from the rules if negation is pre-evaluated according to the model itself. An interpretation is any set I ⊆ (cid:3) of −(r) ∩ I = ∅, and I is atoms. An interpretation I satisfies a rule r, denoted I |= r, if I ∩ H(r) (cid:12)= ∅ whenever Ba model of a program P (denoted I |= P ), if I |= r for each rule r ∈ P . A model I of P is minimal, if no model J ⊂ I of Pexists; MM(P ) denotes the set of all minimal models of P .+(r) ⊆ I and BAn interpretation I is a stable model (or answer set) of P , if I ∈ MM(P I ), where P I is the well-known Gelfond–Lifschitz −(r) ∩ I (cid:12)= ∅}. The program P I(GL) reduct [26] of P w.r.t. I , which is the positive program P I = {H(r) ← Bincorporates the value of negation given by I into the program; if I ∈ MM(P I ) holds, I can be reconstructed under the “guess” for negation given by I . We denote by AS(P ) the set of all answer sets of P .+(r) | r ∈ P , B6 Occasionally, we use as in Example 3 schematic rules with variables which are instantiated to propositional rules.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271225Example 7 (continued). Reconsider the program P in Example 6, where for simplicity we use a, b, c and d for professor, student, assistant, and discount, respectively; that is, we have P = {b ∨ c ← not a; d ← c, not b}. This program has the minimal models MM(P ) = {{a}, {b}, {c, d}} and the answer sets AS(P ) = {{b}, {c, d}}. Note that I = {a} is not an answer set, as I is not a minimal model of P I = {d ← c}; intuitively the truth of a in I is unfounded, as it cannot be derived from rules.2.1.1. Stratified and headcycle-free programsAmong various syntactic classes of programs that are important for the use in practice are stratified programs [3,46]and headcycle-free (hcf) program [8]. In the following, we characterize these notions in terms of the strongly connected components of a logic program.+(r) ∪ BThe dependency graph of a program P is the directed graph DG(P ) = (cid:14)V DG, E DG(cid:15) whose nodes V DG are the atoms in Pand with an edge (a, b) if a occurs in the head of a rule r and either b occurs in the body of r or in the head of r and is −(r) ∪ (H(r) \ {a}), r ∈ P }. The strongly connected components (SCCs)different from a, i.e., E DG = {(a, b) | a ∈ H(r), b ∈ B(cid:16) ∈ Cof P , denoted SCC(P ), are the SCCs of DG(P ), i.e., the maximal node sets C ⊆ At(P ) such that every pair of nodes v, vis connected by some path in G with nodes only from C . Informally, the dependency graph captures dependencies of the truth of an atom a that occurs in the head of a rule r from the other occurrences of atoms in r; their value potentially influences the value of a.A program P is stratified, if for each r ∈ P and C ∈ SCC(P ) either H(r) ∩ C = ∅ or B−(r) ∩ C = ∅. Note that the notion of stratified program introduced here applies also to programs with constraints, while the original notion [3,46] considers only constraint-free normal respectively disjunctive logic programs. It conservatively generalizes the traditional notion and simply disregards constraints, as H(r) ∩ C = ∅ trivially holds for each constraint r. If all other rules r satisfy the condition, then no atom a can depend via rules in P on its negation: no path a = a0, a1, . . . , ak = a where every (ai, ai+1), 0 ≤ i < k, is an edge in DG(P ) exists thats leads from a in the head of some rule through a literal a1 resp. not a1 in its body recursively to not ain some rule body. This makes it possible to evaluate negation in layers (also called strata). Indeed, every constraint-free stratified normal program P has a unique stable model which coincides with the perfect (stratified) model of P that is defined along strata (see [3,46]).A program P is headcycle-free (hcf), if |H(r) ∩ C| ≤ 1 for each r ∈ P and C ∈ SCC(P+(r) | r ∈ P , a ∈H(r)}. Headcycle-freeness means that distinct atoms a and b that occur in the head of the same rule do not mutually depend on each other by recursion through the positive parts of the rule bodies; this allows for tractable minimal model checking, which is intractable for arbitrary disjunctive logic programs.(cid:16)), where P(cid:16) = {a ← BExample 8 (continued). The program P = {b ∨ c ← not a; d ← c, not b} is stratified and also headcycle-free. Informally, the value of a, which does not depend on any other atom, can be determined first, next the value of b and c, and finally the value of d; this gives rise to three respective strata. The program is headcycle-free, as b and c do not mutually depend (cid:16) = P ∪ {b ← d}: while b positively on each other through positive rule bodies. This also holds for the extended program Pdepends on c (via b ← d and d ← c), c does not positively depend on b.Notation. It is convenient to introduce further notation. For any rule r, we denote by At(r) = H(r) ∪ Ball atoms occurring in r, and for any program P , we let At(P ) =i.e., the signature is the one generated by the considered program P .−(r) the set of r∈P At(r). We assume as usual that by default (cid:3) = At(P ), +(r) ∪ B(cid:10)2.1.2. Splitting sets and sequencesStratified programs come with the modularity property that atoms in lower layers (in Example 8 e.g. a) have their value solely determined by rules there. This modularity property in fact generalizes to a more abstract view of a program that is based on splitting sets of program [31]. Informally, a splitting set allows one to divide a program P into a lower and a higher part which can be evaluated bottom up. More formally, a set S ⊆ (cid:3) is a splitting set of P , if for every rule r in P such that H(r) ∩ S (cid:12)= ∅ we have that At(r) ⊆ S. We denote by b S (P ) = {r ∈ P | At(r) ⊆ S} the bottom part of P , and by t S (P ) = P \ b S (P ) the top part of P relative to S. Note that the union S = S1 ∪ S2 of splitting sets S1, S2 of a program P is also a splitting set of P .As shown in [31], it holds that(cid:11)AS(P ) =AS(t S (P ) ∪ M),(2)M∈AS(b S (P ))where as usual, “∪M” means adding all atoms in M as facts, and S is a splitting set of P . That is, we can obtain the answer sets of a program P by first evaluating its bottom part b S (P ) with respect to a splitting set S; this part contains rules that are entirely formulated over atoms from S. After that, we evaluate the remaining part of the program, t S (P ), in which the atoms from S can only occur in rule bodies but not in rule heads, augmented with facts for the atoms that are found true in an answer set.Example 9 (continued). For the program P = {b ∨ c ← not a; d ← c, not b}, the set S = {a, b, c} is a splitting set, and we have b S (P ) = {b ∨ c ← not a} and t S (P ) = {d ← c, not b}; as AS(b S (P )) = {{b}, {c}}, we get AS(P ) = AS(t S (P ) ∪ {b}) ∪ AS(t S (P ) ∪{c}) = {{b}, {c, d}}.226G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Splitting sets naturally lead to splitting sequences. A splitting sequence S = (S 1, . . . , Sn) of P is a sequence of splitting sets S i of P such that S i ⊆ S j for each i < j; note that usually Sn ⊂ (cid:3); the characterization in (2) can be extended accordingly.Example 10 (continued). A splitting sequence for P = {b ∨ c ← not a; d ← c, not b} is S = (S 1, S2) where S1 = {a} and S2 = {a, b, c}; b S1 (P ) = ∅, b S2 (P ) = {b ∨ c ← not a} and t S2 (P ) = {d ← c, not b}.With an eye on practical implementation, we do not consider infinite splitting sequences here, but will comment on them at the end of Section 5. An important note is that splitting sets and sequences are an important tool not only for modular representation, but also for the implementation of answer set semantics. Advanced answer set solvers such as DLV and clasp exploit this tool heavily, and while the SCCs yield the most fine-grained splitting sequences, in practice coarser splittings may be more advantageous.2.2. Equilibrium logicThe definition of answer set in Section 2.1 uses the GL-reduct, and thus in a sense has an operational flavor. This raised the question whether a characterization of answer sets in terms of a suitable logic is possible; and as constructibility of answer sets by rules is crucial, whether in particular (a variant of) intuitionistic logic could serve this purpose. David Pearce showed that the answer is positive and presented equilibrium logic [40,41], which is a natural non-monotonic extension of Heyting’s logic of here-and-there (HT) [27]. The latter is an intermediate logic between (full) intuitionistic and classical logic, and it coincides with 3-valued Gödel logic. As it turned out, HT-logic serves as a valuable basis for characterizing semantic properties of answer set semantics and equilibrium logic can be regarded as a logical reconstruction of answer set semantics that has many attractive features.As such, HT-logic considers a full language L(cid:3) of formulas built over a propositional signature (cid:3) with the connectives ¬, ∧, ∨, →, and ⊥. We restrict our attention here to formulas of the formb1 ∧ . . . ∧ bm ∧ ¬bm+1 ∧ . . . ∧ ¬bn →a1 ∨ · · · ∨ al,(3)which correspond in a natural way to rules of form (1) where for l = 0, the formula a1 ∨ · · · ∨ al is ⊥; every program Pcorresponds then similarly to a theory (set of formulas) (cid:5)P .Example 11. For example, the program P = {a ← b; b ← not c; c ← not a}, corresponds to the theory (cid:5)P = {b → a; ¬c →b; ¬a → c}, while P = {b ∨ c ← not a; d ← c, not b} corresponds to (cid:5)P = {¬a → b ∨ c; ¬b ∧ c → d}.In the rest of the article, we tacitly use this correspondence. We note, however, that the key notions extend to the full language L(cid:3) , and in this way some of the results to extensions of the rule language that we consider (see Section 9.3) also apply to the full language.As a restricted intuitionistic logic, HT can be semantically characterized by Kripke models, in particular using just two worlds, namely “here” and “there” (assuming that the here world is ordered before the there world). An HT-interpretation is a pair ( X, Y ) of interpretations X, Y ⊆ (cid:3) such that X ⊆ Y ; it is total, if X = Y . Intuitively, atoms in X (the here part) are considered to be true, atoms not in Y (the there part) to be false, while the remaining atoms (from Y \ X ) are undefined.Assuming that X |= φ denotes satisfaction of a formula φ by an interpretation X in classical logic, satisfaction of φ in HT-logic (thus, an HT-model), denoted ( X, Y ) |= φ, is defined recursively as follows:1. ( X, Y ) |= a if a ∈ X , for any atom a,2. ( X, Y ) (cid:12)|= ⊥,3. ( X, Y ) |= ¬φ if Y (cid:12)|= φ (that is, Y satisfies ¬φ classically),4. ( X, Y ) |= φ ∧ ψ if ( X, Y ) |= φ and ( X, Y ) |= ψ ,5. ( X, Y ) |= φ ∨ ψ if ( X, Y ) |= φ or ( X, Y ) |= ψ ,6. ( X, Y ) |= φ → ψ if (i) ( X, Y ) (cid:12)|= φ or ( X, Y ) |= ψ , and (ii) Y |= φ → ψ .Note that the condition in item 3 is equivalent to ( X, Y ) |= φ → ⊥, thus we can view negation ¬φ as implication φ → ⊥. Then, an HT-interpretation ( X, Y ) is a model of a theory (cid:5), denoted ( X, Y ) |= (cid:5), if ( X, Y ) |= φ for every formula φ ∈ (cid:5). As regards negative literals and rules, the following is not hard to see.Proposition 1. Given a HT-interpretation ( X, Y ), for an atom a it holds that ( X, Y ) |= ¬a iff a /∈ Y , and ( X, Y ) |= r for a rule r of form (1) iff either H(r) ∩ X (cid:12)= ∅, or B+(r) (cid:2) Y , or B−(r) ∩ Y (cid:12)= ∅.In terms of the GL-reduct, we have ( X, Y ) |= P for a program P iff Y |= P and X |= P Y [54].A total HT-interpretation (Y , Y ) is an equilibrium model (EQ-model) of a theory (cid:5), if (Y , Y ) |= (cid:5) and for every HT-interpretation ( X, Y ), such that X ⊂ Y , it holds that ( X, Y ) (cid:12)|= (cid:5); the set of all EQ-models of (cid:5) is denoted by EQ((cid:5)). The equilibrium models of a program P are then those of (cid:5)P , i.e., EQ(P ) = EQ((cid:5)P ). For further details and background see, e.g., [41].G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271227Example 12 (continued). For the program P = {b ∨ c ← not a; d ← c, not b}, the sets (∅, a), (a, a), (b, b), (∅, ab), (a, ab), (b, bc), (c, bc), (cd, cd) are some HT-models ( X, Y ) of the corresponding theory (cid:5)P .7 The equilibrium models of P resp. (cid:5)Pare (b, b) and (cd, cd), i.e., EQ(P ) = EQ((cid:5)P ) = {(b, b), (cd, cd)}.In the previous example, the program P has the answer sets I1 = {b} and I2 = {c, d}, which amount to the equilibrium models (b, b) and (cd, cd), respectively. In fact, the answer sets and equilibrium models of a program always coincide.Proposition 2. (See [40].) For every program P and M ⊆ At(P ), it holds that M ∈ AS(P ) iff (M, M) is an EQ-model of (cid:5)P .In particular, as AS(P ) = MM(P ) for any positive program P , we have EQ(P ) = {(M, M) | M ∈ MM(P )} in this case.We call a logic program incoherent, if it lacks answer sets due to cyclic dependency of atoms among each other by rules through negation; that is, no answer set (equivalently, no equilibrium model) exists even if all constraints are dismissed from the program.Example 13. Reconsider the barber paradox; the HT-models of the corresponding program P = {a ← not a}, where a stands for shaves(joe, joe), are (∅, a) and (a, a); the single total HT-model is (a, a), which however is not an equilibrium model. Similarly, the program P = {a ← b; b ← not a} has the HT-models (∅, a), (∅, ab), (a, a), (a, ab), and (ab, ab); likewise, the total HT-models (a, a) and (ab, ab) are not equilibrium models.We next recall the semi-stable model semantics which deals with such incoherence.2.3. Semi-stable modelsInoue and Sakama [49] introduced semi-stable models as an extension of paraconsistent answer set semantics (called PAS semantics, respectively p-stable models by them) for extended disjunctive logic programs. Their aim was to provide a framework which is paraconsistent for incoherence, i.e., in situations where stability fails due to cyclic dependencies of a literal on its default negation.We consider an extended signature (cid:3)κ = (cid:3) ∪ {K a | a ∈ (cid:3)}. Intuitively, K a can be read as a is believed to hold. Semanti-cally, we resort to subsets of (cid:3)κ as interpretations Iκ and the truth values false ⊥,8 believed true bt, and true t, which are ordered by a binary relation (cid:19) (a truth ordering) such that ⊥ (cid:19) bt (cid:19) t. The truth value assigned by Iκ to a propositional variable a is defined by⎧⎪⎨tIκ (a) =⎪⎩if a ∈ Iκ ,if K a ∈ Iκ and a /∈ Iκ ,bt⊥ otherwise.The semi-stable models of a program P are obtained from its epistemic transformation P κ .Definition 1 (Epistemic Transformation P κ [49]). Let P be a disjunctive program. Then its epistemic transformation is defined −(r) (cid:12)= ∅, as the positive disjunctive program P κ obtained from P by replacing each rule r of the form (1) in P , such that Bwith:λr,1 ∨ . . . ∨ λr,l ∨ K c1 ∨ . . . ∨ K cn ← b1, . . . , bm,ai ← λr,i,← λr,i, c j,λr,i ← ai, λr,k,for 1 ≤ i, k ≤ l and 1 ≤ j ≤ n, where the λr,i , λr,k are fresh atoms.(4)(5)(6)(7)Intuitively, the atom K c j means that c j must be believed to be true, and λr,i means that in the rule r, the atom ai in the head must be true. With this meaning, the rule (1) is naturally translated into the rule (4): if all atoms in B(r) are true, −(r) must be believed to be true then either some atom in H(r) is true, and thus some λr,i is true, or some atom ci in B(then not ci is false). The rule (5) propagates the value of λr,i to ai , which then is visible also in other rules. The rules (6)and (7) restrict the choice of λr,i for making the head of r true: if c j is true, the rule r is inapplicable and no atom in H(r)has to be true (6). Furthermore, if the atom ai in the head is true (via some other rule of P or by (5)), then whenever some 7 We write (as common) sets {a1, a2, . . . , an} also as juxtaposition a1a2 · · · an of their elements.8 In [49] ⊥ is called ‘undefined’, as it should be if strong negation is considered as well.228G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271atom ak in H(r) must be true, also ai must be true (7); the minimality of answer set semantics effects that only ai must be true.Example 14. Reconsider the barber paradox program P = {a ← not a}, where a stands for shaves(joe, joe). ThenP κ = {λ1 ∨ K a ← ; a ← λ1; ← a, λ1; λ1 ← a, λ1}.Consider the similar program P = {b ← not a}, which is stratified. Its epistemic transformation isP κ = {λ1 ∨ K a ← ; b ← λ1; ← a, λ1; λ1 ← b, λ1}.Finally, let us also reconsider the stratified program P = {b ∨ c ← not a; d ← c, not b}. Its epistemic transformation is⎧⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩P κ =λr1,1 ∨ λr1,2 ∨ K a ←b ← λr1,1c ← λr1,2← λr1,1, a← λr1,2, aλr1,1 ← b, λr1,1λr1,1 ← b, λr1,2λr1,2 ← c, λr1,1λr1,2 ← c, λr1,2λr2,1 ∨ K b ← cd ← λr2,1← λr2,1, bλr2,1 ← d, λr2,1⎫⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎬⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎭,where r1 and r2 name the first and second rule, respectively.Note that for any program P , its epistemic transformation P κ is a positive program. Models of P κ are defined in terms of a fixpoint operator in [49], with the property that for positive programs, according to Theorem 2.9 in [49], minimal fixpoints coincide with minimal models of the program. Therefore, for any program P , minimal fixpoints of P κ coincide with answer sets of P κ .Semi-stable models are then defined as maximal canonical interpretations among the minimal fixpoints (answer sets) of P κ as follows. For every interpretation Iκ over (cid:3)(cid:16) ⊇ (cid:3)κ , let gap(Iκ ) = {K a ∈ Iκ | a /∈ Iκ } denote the atoms that are believed true but not assigned true.Definition 2 (maximal canonical). Given a set S of interpretations over (cid:3)(cid:16), an interpretation Iκ ∈ S is maximal canonical in S, if no J κ ∈ S exists such that gap(Iκ ) ⊃ gap( J κ ). By mc(S) we denote the set of maximal canonical interpretations in S.Then we can equivalently paraphrase the definition of semi-stable models in [49] as follows.Definition 3 (semi-stable models). Let P be a program over (cid:3). An interpretation Iκ over (cid:3)κ is a semi-stable model of P , if Iκ = S ∩ (cid:3)κ for some maximal canonical answer set S of P κ . The set of all semi-stable models of P is denoted by SST (P ), i.e., SST (P ) = {S ∩ (cid:3)κ | S ∈ mc(AS(P κ ))}.Example 15 (continued). For P = {a ← not a}, the epistemic transformation P κ , has the single answer set M = {K a}; hence, {K a} is the single semi-stable model of P , in which a is believed true. For the program P = {b ← not a}, the epistemic transformation P κ has the answers sets M1 = {K a} and M2 = {λ1, b}; as gap(M1) = {a} and gap(M2) = ∅, among them M2is maximal canonical, and hence M2 ∩ (cid:3)κ = {b} is the single semi-stable model of P . This is in fact also the unique answer set of P .Finally, the epistemic transformation of P = {b ∨ c ← not a; d ← c, not b} has the answer sets M1 = {λr1,1, b}, M2 ={λr1,2, c, λr2,1, d}, M3 = {λr1,2, c, K b}, and M4 = {K a}, as may be checked using an ASP solver. Among them as gap(M1) =gap(M2) = ∅ while M3 and M4 have nonempty gap, M1 and M2 are maximal canonical and hence the semi-stable models of P ; they correspond with the answer sets of P , {b} and {c, d}, as expected.For a study of the semi-stable model semantics, we refer to [49]; notably,Proposition 3. (See [49].) The SST -models semantics, given by SST (P ) for arbitrary programs P , satisfies properties (D1)–(D3).Arguably, the transformational definition of semi-stable models makes it difficult to grasp at the semantic level what makes an interpretation of a semi-stable model, in particular if we focus on the original language and forget about the auxiliary symbols. This raises the question of a characterization of semi-stable models from first principles that can serve as an alternative definition under a pure model-theoretic view. In the next section, we present such a characterization.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2712293. Semantic characterization of semi-stable modelsAs opposed to its transformational definition, we aim in this section at a model-theoretic characterization of semi-stable models. Given that equilibrium logic and HT-models have been successfully used to characterize stable models, it is natural to attempt to give such a characterization in the line of model-theoretic characterizations of the answer set semantics by means of HT models. Recall that in such a model ( X, Y ), the set X contains the atoms that are true while Y contains the atoms that are believed true. Let us reconsider how HT-models work on the barber paradox.Example 16. Reconsider P = {a ← not a} in Examples 13 and 14, and recall that HT-models of P are (∅, a) and (a, a). One might aim at characterizing the semi-stable model {K a} by (∅, a). Indeed, while (a, a) is inappropriate, (∅, a) perfectly describes the situation: a is believed true but not assigned true, as this cannot be proven.However, resorting to HT-interpretations will not allow us to uniquely characterize semi-stable models, as illustrated by the following example.Example 17. Consider the programP = {a; b; c; d ← not a, not b; d ← not b, not c}.The program is coherent, with a single answer set {a, b, c}, while SST (P ) = {{a, b, c, K b}, {a, b, c, K a, K c}}. This is due to the fact that the epistemic transformation P κ contains rules λr3,1 ∨ K a ∨ K b ← and λr4,1 ∨ K b ∨ K c ← and the constraints (6), given that a, b, and c are true by facts, enforce that all λr,i are false; thus, either K b or K a, K c must be true in every answer set of P κ . Note that neither (abc, b) nor (abc, ac) is a HT-interpretation.Hence, for a 1-to-1 characterization we have to resort to different structures. Sticking to the requirement that, given a program P over (cid:3), pairs of two-valued interpretations over (cid:3) should serve as the underlying semantic structures, we say that a bi-interpretation of a program P over (cid:3) is any pair (I, J ) of interpretations over (cid:3), and define:Definition 4 (bi-model). Let φ be a formula over (cid:3), and let (I, J ) be a bi-interpretation over (cid:3). Then, (I, J ) is a bi-modelof φ, denoted (I, J ) |=β φ, if1. (I, J ) |=β a if a ∈ I , for any atom a,2. (I, J ) (cid:12)|=β ⊥,3. (I, J ) |=β ¬φ if J (cid:12)|= φ,4. (I, J ) |=β φ ∧ ψ if (I, J ) |=β φ and (I, J ) |=β ψ ,5. (I, J ) |=β φ ∨ ψ if (I, J ) |=β φ or (I, J ) |=β ψ ,6. (I, J ) |=β φ → ψ if (i) (I, J ) (cid:12)|=β φ, or (ii) (I, J ) |=β ψ and I |= φ.Moreover, (I, J ) is a bi-model of a program P , if (I, J ) |=β φ, for all φ of the form (3) corresponding to a rule r ∈ P .Note that the only difference in the recursive definition of bi-models and HT-models is in item 6, i.e., the case of implication. While HT-models require that the material implication φ → ψ holds in the there-world, bi-models miss such a connection between φ and ψ . This makes it possible that a bi-interpretation (I, J ) such that I ⊆ J is a bi-model but not an HT-model of an implication (3); a simple example is given by (∅, a) and a → b. On the other hand, each HT-model of an implication (3) is also a bi-model of it.Similar to the condition for HT-models in Proposition 1, we can alternatively characterize satisfaction of rules by bi-models as follows.Proposition 4. Let r be a rule over (cid:3), and let (I, J ) be a bi-interpretation over (cid:3). Then, (I, J ) |=β r if and only if BJ ∩ B−(r) = ∅ implies that I ∩ H(r) (cid:12)= ∅ and I ∩ B−(r) = ∅.+(r) ⊆ I and We now link bi-interpretations to interpretations of the extended signature (cid:3)κ and the epistemic transformation of a program P , respectively. To every bi-model of a program P , we associate a corresponding interpretation (I, J )κ over (cid:3)κ by (I, J )κ = I ∪ {K a | a ∈ J }. Conversely, given an interpretation Iκ over (cid:3)κ its associated bi-interpretation β(Iκ ) is given by (Iκ ∩ (cid:3), {a | K a ∈ Iκ }).For illustration consider the following example.Example 18. Let P = {a ← b; b ← not b}. Its bi-models are all pairs (I, J ), where I ∈ {∅, {a}, {a, b}} and J ∈ {{b}, {a, b}}. Then for (∅, b), we have (∅, b)κ = {K b}, and for (a, ab) we have (a, ab)κ = {a, K a, K b}. Conversely, for Iκ = {a, K b} we have β(Iκ ) = (a, b).230G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271In order to relate these constructions to models of the epistemic transformation P κ , which builds on additional atoms of the form λr,i , we construct an interpretation (I, J )κ,P of P κ from a given bi-interpretation (I, J ) of P as follows:(I, J )κ,P = (I, J )κ ∪ {λr,i | r ∈ P , B−(r) (cid:12)= ∅, ai ∈ I, I |= B(r), J |= B−(r) },where r is of the form (1).Example 19 (continued). Reconsider P = {a ← b; b ← not b} in Example 18 and (∅, b). Then (∅, b)κ,P = (∅, b)κ ∪ {λr2,1} ={K b, λr2,1}, as the rule b ← not b fulfills the conditions for I = ∅ and J = {b}.We now can establish the following correspondence between bi-models of a program P and models of the epistemic transformation P κ .Proposition 5. Let P be a program over (cid:3). Then,(1) if (I, J ) is a bi-model of P , then (I, J )κ,P |= P κ ;(2) if M |= P κ then β(M ∩ (cid:3)κ ) is a bi-model of P .Based on bi-models, we obtain a 1-to-1 characterization of semi-stable models by imposing suitable minimality criteria.Theorem 1. Let P be a program over (cid:3). Then,(1) if (I, J ) is a bi-model of P such that (i) (I(cid:16), J(cid:16)) of P that satisfies (i) and gap(I(cid:16), J(I(cid:16), J ) (cid:12)|=β P , for all I(cid:16)) ⊂ gap(I, J ), then (I, J )κ ∈ SST (P );(cid:16) ⊂ I , (ii) (I, J(2) if Iκ ∈ SST (P ), then β(Iκ ) is a bi-model of P that satisfies (i)–(iii).(cid:16)) (cid:12)|=β P , for all J(cid:16) ⊂ J , and (iii) there is no bi-model Intuitively, Conditions (i) and (ii) filter bi-models that uniquely correspond to (some but not all) answer sets of P κ : due to minimality every answer set satisfies (i); there may be answer sets of P κ that do not satisfy (ii), but they are certainly not maximal canonical. Eventually, Condition (iii) ensures that maximal canonical answer sets are selected. More formally, the proof of this theorem builds on the following relationship between bi-models of P and answer sets of P κ .Corollary 1. Let P be a program over (cid:3). If M ∈ AS(P κ ), then β(M ∩ (cid:3)κ ) satisfies (i). If (I, J ) is a bi-model of P that satisfies (i) and (ii), then there exists M ∈ AS(P κ ), such that β(M ∩ (cid:3)κ ) = (I, J ).For illustration, we consider the following example.Example 20 (continued). Recall that P = {a ← b; b ← not b} has as bi-models all pairs (I, J ) where I ∈ {∅, {a}, {a, b}} and J ∈ {{b}, {a, b}}. Condition (i) of Theorem 1 holds for bi-models such that I = ∅, and Condition (ii) holds only if J = {b}. Thus, {K b} is the unique semi-stable model of P .The examples given so far also exhibit some anomalies of the semi-stable semantics with respect to basic rationality properties considered in epistemic logics. In particular, knowledge generalization (or necessitation, resp. modal axiom N) is a basic principle in respective modal logics. For a semi-stable model Iκ , it would require thatProperty N: a ∈ Iκ implies K a ∈ Iκ , for all a ∈ (cid:3).This property does not hold as witnessed by Example 17.Another basic requirement is the distribution axiom (modal axiom K). Assuming that we belief the rules of a given program (which might also be seen as the consequence of adopting knowledge generalization) the distribution property can be paraphrased for a rule of the form (1) as follows:Property K:If Iκ |= K b1 ∧ . . . ∧ K bm and Iκ (cid:12)|= K c1 ∨ . . . ∨ K cn, then Iκ |= K a1 ∨ . . . ∨ K al.Note that this does not hold for the rule a ← b in Example 18, as the single semi-stable model of the program P is {K b}(see Example 20).Arguably, these anomalies should be avoided. This leads us to propose an amendment to the semi-stable model seman-tics, which we present in the next section.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2712314. Semi-equilibrium modelsIn this section, we define and characterize an alternative paracoherent semantics which we call semi-equilibrium semantics(for reasons which will become clear immediately). The aim for semi-equilibrium models is to enforce Properties N and Kon them.Let us start considering bi-models of a program P which satisfy these properties. It turns out that such structures are exactly given by HT-models.Proposition 6. Let P be a program over (cid:3). Then,(1) if (I, J ) is a bi-model of P , such that (I, J )κ satisfies Property N and Property K, for all r ∈ P , then (I, J ) is an HT-model of P ;(2) if (H, T ) is an HT-model of P , then (H, T )κ satisfies Property N and Property K, for all r ∈ P .In order to define semi-equilibrium models, we follow the basic idea of the semi-stable semantics and select subset minimal models that are maximal canonical. For any program P , let us define H T κ (P ) = {(H, T )κ | (H, T ) |= P } and denote by MM(H T κ (P )) the minimal elements of H T κ (P ) with respect to subset inclusion.Definition 5 (semi-equilibrium models). Let P be a program over (cid:3). An interpretation Iκ over (cid:3)κ is a semi-equilibrium (SEQ) model of P , if Iκ ∈ mc(MM(H T κ (P ))). The set of semi-equilibrium models of P is denoted by SEQ(P ).Let us revisit some examples from the previous section.Example 21. For P = {a ← not a}, its semi-stable-model {K a} corresponds to the HT-interpretation (∅, a); thus {K a} is the single minimal element of H T κ (P ) and the single SEQ-model of P .For the program P = {a; b; c; d ← not a, not b; d ← not b, not c} in Example 17, every HT-model of P must be of the form ( X, Y ) such that {a, b, c} ⊆ X ; hence, {a, b, c, K a, K b, K c} is the single minimal element of H T κ (P ) and the single semi-equilibrium model of P .Finally, for the program P = {a ← b; b ← not b} in Example 18, by the rule b ← not b every HT-model ( X, Y ) of P must fulfill b ∈ Y , and thus by the rule a ← b also a ∈ Y ; the single minimal element of H T κ (P ) is then {K a, K b}, which is also the single SEQ-model of P .A model-theoretic characterization for the semi-equilibrium semantics is obtained as before, by replacing bi-models with HT-models and dropping Condition (ii). Intuitively, Condition (ii) is not needed as it is subsumed by Condition (iii) (i.e., Condition (ii(cid:16)) below) if Property N and Condition (i) hold.To formulate the result, we extend the notion of gap from (cid:3)κ -interpretations to HT-interpretations as follows. For any HT-interpretation ( X, Y ), let gap( X, Y ) = Y \ X , i.e., gap( X, Y ) = gap(β(( X, Y )κ )) = {a | K a ∈ gap(( X, Y )κ )}.Theorem 2. Let P be a program over (cid:3). Then,(1) if (H, T ) is an HT-model of P such that (i) (H(cid:16)(cid:16), T ) (cid:12)|= P , for all H(cid:16) ⊂ H , and (ii(cid:16)) no HT-model (H(cid:16), T(cid:16)) of P exists that satisfies (i(cid:16))and gap(H(cid:16), T(cid:16)) ⊂ gap(H, T ), then (H, T )κ ∈ SEQ(P );(2) if Iκ ∈ SEQ(P ), then β(Iκ ) is an HT-model of P that satisfies (i(cid:16)) and (ii(cid:16)).We refer to the condition (i(cid:16)(cid:16)) as gap-minimality of an HT-model of a program P . Informally, this characterization says that the SEQ-models are obtained by relaxing the condition for EQ-models in that a globally smallest set of atoms, expressed by gap-minimality, may be believed true without further justification, where justification is expressed by h-minimality. Note that the EQ-models are obtained if we just would require that H = T .(cid:16)) as h-minimality and to the condition (iLike semi-stable models, semi-equilibrium models may be computed as maximal canonical answer sets, i.e., equilibrium models, of an extension of the epistemic program transformation.Definition 6 ( P H T ). Let P be a program over (cid:3). Then its epistemic HT-transformation P H T is defined as the union of P κwith the set of rules:K a ← a,K a1 ∨ . . . ∨ K al ∨ K c1 ∨ . . . ∨ K cn ← K b1, . . . , K bm,for a ∈ (cid:3), respectively for every rule r ∈ P of the form (1).The extensions of the transformation naturally ensure Properties N and K on its models and its maximal canonical answer sets coincide with semi-equilibrium models.232G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Theorem 3. Let P be a program over (cid:3), and let Iκ be an interpretation over (cid:3)κ . Then, Iκ ∈ SEQ(P ) if and only if Iκ ∈ {M ∩ (cid:3)κ |M ∈ mc(AS(P H T ))}.We note at this point that an alternative, less involving encoding of semi-equilibrium models can be found in Section 8.The resulting semantics is classically coherent, i.e., fulfills property (D3) from the Introduction.Proposition 7. Let P be a program over (cid:3). If P has a classical model, then it has a semi-equilibrium model.Another simple property is a 1-to-1 correspondence between answer sets and semi-equilibrium models.Proposition 8. Let P be a coherent program over (cid:3). Then,(1) if Y ∈ AS(P ), then (Y , Y )κ is a semi-equilibrium model of P ;(2) if Iκ is a semi-equilibrium model of P , then β(Iκ ) is an equilibrium model of P , i.e., β(Iκ ) is of the form (Y , Y ) and Y ∈ AS(P ).An illustration of the 1-to-1 relationship between answer sets and semi-equilibrium modelsis given by Example 17, which we reconsidered in Example 21. Note that this example also gave evidence that semi-stable models do not satisfy Property N, which in contrast is the case for semi-equilibrium models.From Propositions 7 and 8, we thus obtain that semi-equilibrium models behave similarly as semi-stable models with respect to the properties (D1)–(D3) in the Introduction.Proposition 9. The SEQ-models semantics, given by SEQ(P ) for arbitrary programs P , satisfies properties (D1)–(D3).Furthermore, an immediate consequence of Proposition 8 is the following property.Corollary 2. For every positive program P , SEQ(P ) = {( X, Y )κ | ( X, Y ) ∈ EQ(P )} = {(M, M)κ | M ∈ MM(P )}.As a consequence of Property K, semi-equilibrium semantics differs from semi-stable semantics not only with respect to believed consequences.Example 22. Consider the program P = {a ← b; b ← not b; c ← not a}, which extends the program in Example 18 with the rule c ← not a. The single semi-stable model of P is {c, K b} (which corresponds to the bi-model (c, b)), while the single SEQ-model is {K a, K b} (which corresponds to the HT-model (∅, ab)). Thus while c is true under SST -model semantics, it is false under SEQ-model semantics: due to lacking belief propagation, the CWA assigns a false in the SST -model which in turn causes c to get true; in the SEQ-model, as a is believed to be true the rule with c in the head is defeated. As there is no other way to derive c, the CWA assigns it false.Convention. As each SEQ-model Iκ of P is uniquely determined by the HT-model β(Iκ ), we shall in the rest of this article also identify these models and refer to the set {β(Iκ ) | Iκ ∈ SEQ(P )} as the SEQ-models of P and denote it in abuse of notation by SEQ(P ). For illustration, the programs in Example 21 have the SEQ-models {K a}, {a, b, c, K a, K b, K c}, and {K a, K b}, respectively, which are identified with the HT-models (∅, a), (abc, abc), and (∅, ab), respectively.5. Split semi-equilibrium semanticsWhile the SEQ-semantics has nice properties and fulfills the properties (D1)–(D3) from the Introduction, it does not en-sure the modularity property of answer sets respectively equilibrium models that is expressed by Equation (2). To illustrate this, consider the following examples.Example 23. Recall the party program from Example 2:go(John) ← not go(Mark);go(Peter) ← go(John), not go(Bill);P =⎧⎨⎫⎬⎭ .⎩go(Bill) ← go(Peter)The semi-equilibrium models of P are Iκ1= {Kgo(Mark)} and Iκ2= {go(John), Kgo(John), Kgo(Bill)}, or written as HT-models, M1 = (∅, {go(Mark)}), and M2 = ({go(John)}, {go(John), go(Bill)}). None of the two models provides a fully coherent view (on the other hand, the program is incoherent, having no answer set). Nevertheless, M2 appears preferable over M1, since, according with a layering (stratification) principle, which is widely agreed in LP, one should prefer go(John) rather than go(Mark), as there is no way to derive go(Mark) (which does not appear in the head of any rule of the program). We remark that according to the well-founded semantics of P , go(Mark) is false and go(John) is true, while all other atoms are undefined; the SEQ-model M2 is more informative since it tells us in addition that go(Peter) is false.Example 24. Consider the following simplistic program capturing knowledge about workers in a company:G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271233⎧⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎩P =← employee(X), not has_social_sec(X), core_staff (X);← ssnr(X, Y ), not #int(Y );has_social_sec(X) ← employee(X), ssnr(X, Y );employee(X) ← manager(X);core_staff (X) ← manager(X);manager(sam)⎫⎪⎪⎪⎪⎪⎬⎪⎪⎪⎪⎪⎭.Informally, the rules state that employees with a social security registry number (SSNR) have social security, that managers are employees and core staff, and that Sam is a manager. The constraints enforce that all core staff employees must have social security, and that SSNRs range over integers, where #int is a builtin predicate. This program has (over its Herbrand universe9) no answer set: while employee(sam) and core_staff (sam) can be proven from the rules, this is not the case for has_social_sec(sam), and thus the constraint in P is violated. The program has the SEQ-model Iκ = {manager(sam), employee(sam), core_staff (sam), K has_social_sec(sam)} in which Sam is believed to have social security.It is not hard to see that S = {manager(sam), employee(sam), ssnr(sam, sam), has_social_sec(sam)}, is a splitting set for P . The bottom part b S (P ) has the single answer set (thus single SEQ-model) M = {manager(sam), employee(sam)}, according to which ssnr(sam, sam), has_social_sec(sam) are false. Based on this, in the top part t S (P ) we obtain that core_staff (sam) is true; however, this means that the constraint ← employee(sam), not has_social_sec(sam), core_staff (sam), is violated. Conse-quently, no SEQ-model for the top part exists and Equation (2) (adapted for SEQ-models) is violated.Modularity via rule dependency as it emerges from Equation (2) is widely used in ASP for two related but different pur-poses: (1) for efficient evaluation of programs by ASP solvers and (2) for problem modeling, where a program is structured into modules that are organized in a hierarchical fashion.As for (1), program decomposition is in fact crucial for efficient answer set computation in practice. For the program Pabove, advanced answer set solvers like DLV and clasp immediately set go(Mark) to false, as go(Mark) does not occur in any rule head. In a customary bottom up computation along program components, solvers gradually extend answer sets until the whole program is covered, or an incoherence is detected at some component (in our example for the last two rules). But rather than to abort the computation, we would like to switch to a paracoherent mode and continue with building semi-equilibrium models, as an approximation of answer sets. Such a behavior would be desirable, as computationally, we do not waste effort for obtaining such an approximation, and conceptually, we relax the equilibrium condition under Occam’s razor as little as possible along the hierarchy of components.As regards (2), it is customary and natural in modeling that a program P is divided into subprograms P 1, . . . , P m which serve to define the values of specific sets of atoms respectively properties in a way such that each subprogram P iis considered as a module whose rules should be evaluated en bloc. These modules are then evaluated bottom-up exploiting Equation (2) repeatedly to obtain the answer sets of the program P . For example, the program in Example 2, possibly extended to further persons, could be the bottom part of a program Pthat based on the go predicate determines which location to pick for the party, e.g. using(cid:16)← balcony, #count({ X : go(X)}) > 3;balcony ∨ living_room;here #count({ X : go( X)}) > 3 is an aggregate that evaluates to true if more than 3 persons go to the party.Similarly, we can imagine that the last three rules of the program in Example 24 form a subprogram about employees and staff, and the other rules cover social security aspects on top of it. The single SEQ-model Iκ of P is in fact compatible with this view, and would be an intuitive result.To overcome this limitation, we introduce a refined paracoherent semantics, called split semi-equilibrium semantics. It coincides with the answer sets semantics in case of coherent programs, and it selects a subset of the SEQ-models otherwise based on a given splitting sequence that induces a modular decomposition of a program at hand. The main results of this section are two model-theoretic characterizations which identify necessary and sufficient conditions for deciding whether a SEQ-model is selected according to a splitting sequence. As it turns out (and can be seen from the examples above), different splitting sequences can yield different selection results, which is not the case for EQ-models. Based on the results of this section, we will present in Section 6 canonical SEQ-models that are independent of a particular splitting sequence. The canonical SEQ-models ensure robustness of modular evaluation, as like for the EQ-models the concrete bottom-up evaluation order taken by a solver does not matter; furthermore, the notion can be easily generalized to programs that are hierarchically organized in user-defined subprograms, which we shall briefly address in Section 9.2.9 To keep the example and the universe simple, we avoid to introduce number ranges here.234G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2715.1. Split semi-equilibrium modelsWe now introduce the notion of SEQ-models relative to a splitting set. First given a splitting set S for a program P and an HT-interpretation (I, J ) for b S (P ), we letP S (I, J ) = P \ b S (P ) ∪ {a | a ∈ I} ∪ {← not a | a ∈ J } ∪ {← a | a ∈ S \ J }.(8)Informally, the bottom part of P w.r.t. S is replaced with rules and constraints which fix in any SEQ-model of the remainder (= t S (P )) the values of the atoms in S to (I, J ).Definition 7 (Semi-equilibrium models relative to a splitting set). Let S be a splitting set of a program P . Then the semi-equilibrium models of P relative to S are defined asSEQS (P ) = mc(cid:13)(cid:11)(I, J )∈SEQ(b S (P ))(cid:14)SEQ(P S (I, J )).(9)Example 25. Reconsider the party program in Example 2, P = {b ← not a; d ← b, not c; c ← d}, where a, b, and c, dstand for go(Mark), go(John), go(Bill), and go(Peter), respectively. We have SEQ(P ) = { (∅, a), (b, bc) }, where (b, bc) is more appealing than (∅, a) because a is not derivable, as no rule has a in the head. Moreover, intuitively, P 1 = {b ← not a} is a lower (coherent) part feeding into the upper part P 2 = {d ← b, not c; c ← d}. This is formally captured by the splitting set S = {a, b}, which yields b S (P ) = P 1 and SEQ(b S (P )) = {(b, b)}. Hence, P S (b, b) = {d ← b, not c; c ← d; b; ← a} and SEQS (P ) = SEQ(P S (b, b)) = {(b, bc)}.In what follows, we establish a semantic characterization of the SEQ-models relative to a splitting set as those SEQ-models of the program that extend SEQ-models of the bottom part.Notation. For any HT-model ( X, Y ) and set S of atoms, we define the restriction of ( X, Y ) to S as ( X, Y )|S = ( X ∩ S, Y ∩ S).Proposition 10. Let S be a splitting set of a program P . If ( X, Y ) ∈ SEQS (P ), then ( X, Y )|S ∈ SEQ(b S (P )).The following result shows that each semi-equilibrium model relative to a given splitting set is always a semi-equilibrium model of the program.Proposition 11 (Soundness). Let S be a splitting set of a program P . If ( X, Y ) ∈ SEQS (P ), then ( X, Y ) ∈ SEQ(P ).This result is proven by establishing first that HT-models of the program P S (I, J ) are HT-models of the program P , and then the h-minimality and gap-minimality of ( X, Y ). More precisely, the first step uses the following lemma:Lemma 1. Let S be a splitting set of a program P and let (I, J ) ∈ SEQ(b S (P )). If ( X, Y ) is an HT-model of P S (I, J ), then ( X, Y ) is an HT-model of P .However, the converse of Proposition 11 does not hold in general; in fact if we consider the program of Example 25 and the splitting set S = {a, b} we have SEQS (P ) = {(b, bc)}, while SEQ(P ) = {(∅, a), (b, bc)}. Clearly, SEQS (P ) depends on the choice of S; in fact if we choose S = ∅, then SEQ∅(P ) = SEQ(P ).Moreover for Proposition 11 to hold, the selection of maximal canonical HT-models is necessary.Example 26. For P = {a ← not b; b ← not a; c ← b, not c} and the splitting set S = {a, b}, we have SEQ(b S (P )) ={(a, a), (b, b)}; hence SEQ(P S (a, a)) ∪ SEQ(P S (b, b)) = {(a, a), (b, bc)}, while SEQ(P ) = {(a, a)}.So far, we have presented two properties of an HT-model that are necessary conditions to qualify as a SEQ-model relative to a given splitting set. The natural question is whether these conditions are also sufficient; this is indeed the case.Proposition 12 (Completeness). Let S be a splitting set of a program P . If ( X, Y ) ∈ SEQ(P ) and ( X, Y )|S ∈ SEQ(b S (P )), then ( X, Y ) ∈ SEQS (P ).Putting the results above together, we obtain the following semantic characterization of SEQ-models relative to a split-ting set.Theorem 4 (SEQ-model characterization). Let S be a splitting set of a program P . Then ( X, Y ) ∈ SEQS (P ) iff ( X, Y ) ∈ SEQ(P ) and ( X, Y )|S ∈ SEQ(b S (P )).G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271235Proof. The only-if direction follows from Propositions 10 and 11; the if direction holds by Proposition 12. (cid:2)Like the ordinary SEQ-models, also the split SEQ-models coincide with the answer sets of a program if some answer set exists.Corollary 3. Let P be a program such that EQ(P ) (cid:12)= ∅. Then for every splitting set S of P , SEQS (P ) = EQ(P ); in particular, if P is positive, then SEQS (P ) = {(M, M) | M ∈ MM(P )}.We observe that a program which has some model does not necessarily have split semi-equilibrium models (but always semi-equilibrium models) as seen in Example 24. We give another example of a much simpler program.Example 27. Let us consider P = {← b; b ← not a} and the splitting set S = {a}. Then we obtain SEQ(b S (P )) = {(∅, ∅)} and so SEQS (P ) = ∅. However (a, a) and (∅, a) are HT-models of P .Note that occurrence of a constraint in the previous example is not accidental; in fact,Proposition 13. For every constraint-free program P and splitting set S of P , it holds that SEQ(P S ) (cid:12)= ∅.In summary, the split SEQ-models have the following profile with respect to the properties (D1)–(D3).Proposition 14. The split SEQ-models semantics of a program P relative to a splitting set S of P , given by SEQS (P ), satisfies properties (D1)–(D2), and if P is constraint-free, also (D3).5.2. Split sequence semi-equilibrium modelsNow we generalize the use of splitting sets to SEQ-models of a program via splitting sequences. To this end, we naturally reduce a splitting sequence to its head and its remainder and apply splitting sets recursively.Definition 8 (Semi-equilibrium models relative to a splitting sequence). Let S = (S1, . . . , Sn), n ≥ 1, be a splitting sequence for a program P . Then the semi-equilibrium models of P relative to S are given bySEQS (P ) = mc(cid:13)(cid:11)(cid:16)(cid:14)(P S1 (I, J )),SEQS(I, J )∈SEQ(b S1 (P ))(10)(cid:16) = (S2, . . . , Sn) and SEQ()(P ) = SEQ(P ) (recall that P S1 (I, J ) adds rules to P that fix the truth values of all atoms where Sin S1 according to (I, J )).Example 28. Reconsider the program in Examples 2 and 25, P = {b ← not a; d ← b, not c; c ← d}. Then S = ({a}, {a, b},{a, b, c, d}) is a splitting sequence for P , and we obtain that SEQS (P ) = {(b, bc)}. Indeed b S1 (P ) = ∅ and thus (cid:16) = P S1 (∅, ∅) = P ∪ {← a}, we get SEQ(b S1 (P )) = {(∅, ∅)}; for the remainder sequence S1 (b, b) = P ∪ {← a;bsb ←}, we obtain b S(cid:16)) = {b ← not a, ← a} and thus SEQ(b S(cid:16)(cid:16)) = P(cid:16))) = {(b, b)}. Finally, for S(P(cid:16)(cid:16)) = {(b, bc}), which is the final result.(Pand thus SEQ(b S(cid:16) = ({a, b}, {a, b, c, d}) and P(cid:16)(cid:16) = ({a, b, c, d}) and P(cid:16)(cid:16) = P S(P(P(cid:16)1(cid:16)1(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)1(cid:16)(cid:16)1The SEQ-models relative to a splitting sequence can be characterized similarly as those relative to a splitting set, namely as SEQ-models of the program that remain by filtering the SEQ-models along the splitting sequence.To ease presentation, for a given program P and splitting sequence S = (S 1, . . . , Sn), we let P 0 = P and P k =(P k−1)Sk (Ik, J k), where (Ik, J k) ∈ SEQ(b Sk (P k−1)), k = 1, . . . , n; that is, P k is not uniquely defined but ranges over a set of programs.The main result of this section is now as follows.Theorem 5. Let S = (S1, . . . , Sn) be a splitting sequence of a program P . Then ( X, Y ) ∈ SEQS (P ) iff ( X, Y ) ∈ SEQ(P ) and ( X, Y )|Sk∈ SEQ(b Sk (P k−1)), for some P k, for k = 1, . . . , n.The proof proceeds by induction using Theorem 4. Corollary 3 of Theorem 4 also generalizes to splitting sequences.Corollary 4. Let P be a program such that EQ(P ) (cid:12)= ∅. Then for every splitting sequence S of P , SEQS (P ) = EQ(P ); in particular, if P is positive, then SEQS (P ) = {(M, M) | M ∈ MM(P )}.236G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Proof. [Sketch] Using Theorem 5, this can be shown by induction, using Corollaries 2 and 3. (cid:2)Another consequence of Theorem 5 is that, written in other form, the split sequence SEQ-models of a program can be bottom up constructed, taking into account that at each stage only the respective rules (i.e., b S j+1 (P ) \ b S j (P )) need to be considered. More formally,Corollary 5. For every splitting sequence S = (S1, . . . , Sn) of a program P , it holds that SEQS (P ) = Sn, where for j = n, . . . , 1 we have(cid:13) (cid:11)(cid:14)SEQ(Q j(X, Y )),S j = mc( X,Y )∈S j−1where Q j = b S j+1 (P ) \ b S j (P ) with b Sn+1 (P ) = P and S0 = SEQ(b S1 (P )).This form is in fact a suitable starting point for computation; we refer to Section 6.1 for further discussion.Regarding the existence of split sequence SEQ-models, we obtain a generalization of Proposition 13.Proposition 15. For every splitting sequence S of a constraint-free program P , it holds that SEQ(P S ) (cid:12)= ∅.Proof. [Sketch] This can be shown by an inductive argument, along the lines of the proof of Proposition 13, using Proposi-tions 7 and 13. (cid:2)In particular, we obtain from this the following result for stratified programs.Corollary 6. For every splitting sequence S of a stratified program P that is constraint-free, it holds that SEQS (P ) = EQ(P ).In conclusion, we obtain the following profile of split sequence SEQ-models with respect to the properties (D1)–(D3).Proposition 16. The split sequence SEQ-models semantics of a program P relative to a splitting sequence S of P , given by SEQS (P ), satisfies properties (D1)–(D2), and if P is constraint-free, also (D3).6. Canonical semi-equilibrium modelsAs we have pointed out in the discussion at the beginning of the previous section, the split semi-equilibrium semantics depends in general on the choice of the particular splitting sequence. For illustration, let us revisit the examples there.Example 29. In the party program of Example 2, we obtain the first SEQ-model of P with respect to the splitting set S = {go(Mark)}, but not the second SEQ-model. Similarly, in the company Example 24 we obtained with respect to the (cid:16) =considered splitting set S no SEQ-model, while we obtain the single SEQ-model of the program with respect to S{manager(sam), employee(sam), core_staff (sam, sam)}. This behavior is unfortunate, the more as in program evaluation, it is not known which splitting sequence is actually used by a solver for the evaluation, and this aspect should not matter from user perspective. Likewise, it should not matter in which order independent subprograms of a program are evaluated.We thus consider a way to obtain a refined split SEQ-semantics that is independent of a particular splitting sequence, but imposes conditions on sequences that come naturally with the program and can be easily tested. Along with this the question rises what information about the splitting sequences that are (potentially) used for evaluation is available. If we just have a plain program P and no further information, in principle any splitting sequence needs to be considered; if the program P is composed of subprograms P 1, . . . , P m, then only splitting sequences that are “compatible” with the hierarchical ordering of the subprograms need to be respected.We base our development on the first setting, as it is at the core of program evaluation, and moreover a generalization to the setting with subprograms is not hard to accomplish, once the notions and results for this setting are established; we shall address this in Section 9.2.The smallest possible splitting sets of a program are strongly connected components (SCCs) of the program, which are at the heart of bottom up evaluation algorithms in ASP systems. Thus in lack of further information on program decomposition, we shall base our development on splitting sequences that are formed from SCCs of the program.We then get the desired independence of a particular splitting sequence, such that we can then talk about the SCC-models of a program.Example 30. The program in the party Example 2 has two SCCs, namely C1 = {go(Mark)} and C2 = {go(John), go(Bill),go(Peter)}), which form a single splitting sequence S = (C1, C2); thus, the model Iκ1 is selected as the single SCC-model of the program.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271237However, a closer look reveals that independence might fail in presence of certain constraints that join information in unrelated SCCs of a program. An illustration is given by the company program in Example 24.Example 31. The SCCs of the program in Example 24 are all singleton sets {a} where a is a ground atom. For the emerg-ing splitting sequences S = (S1, . . . , Sn) where core_staff (sam) occurs before has_social_sec(sam) (i.e., core_staff (sam) ∈ S iand has_social_sec(sam) ∈ S j \ S i with i < j), we obtain no SEQ-model, but we obtain the single SEQ-model Iκ in the other cases. Intuitively, the constraint in P accesses unrelated information from independent SCCs; if has_social_sec(sam)has already been evaluated (to false), no beliefs help to make the constraint body false; otherwise, believing that has_social_sec(sam) is true achieves this.For this reason, we present a split SEQ-model semantics where the selected SEQ-models are truly independent of the concrete admissible splitting sequence. The semantics is the maximal joinable components (MJ C) model semantics, which results by a lean merging of SCCs that violate independence due to interaction with constraints. In the company example, the SCCs {core_staff (sam)} and {has_social_sec(sam)} will be merged; this prevents that the constraint on social security is considered only after has_social_sec(sam) has already been decided. The single MJ C-model of the program is then its single SEQ-model.6.1. SCC-split sequences and modelsWe start with recalling further notions. The supergraph of a program P is the graph SG(P ) = (cid:14)V SG, E SG(cid:15), whose nodes V SG(cid:16)iff the dependency graph of P has an edge from some are the SCCs of P and with an edge from an SCC C to a distinct SCC C(cid:16), (a, b) ∈ E D G }. Note (cid:16)) | C (cid:12)= C; i.e., formally V SG = SCC(P ) and E SG = {(C, Catom in C to one in Cthat SG(P ) is a directed acyclic graph (dag); recall that a topological ordering of a dag G = (cid:14)V , E(cid:15) is an ordering v 1, v 2, . . . , vnof its vertices, denoted ≤, such that for every (v i, v j) ∈ E we have i > j. Such an ordering always exists, and the set O(G)of all topological orderings of G is nonempty. Any such ordering of SG(P ) naturally induces a splitting sequence as follows.(cid:16) ∈ SCC(P ), ∃a ∈ C, ∃b ∈ C(cid:16)Definition 9. Let P be a program and let ≤ = (C1, . . . , Cn) be a topological ordering of SG(P ). Then the splitting sequence induced by ≤ is S≤ = (S1, . . . , Sn), where S1 = C1 and S j = S j−1 ∪ C j , for j = 2, . . . , n.We call any such S≤ a SCC-splitting sequence; note that S≤ is indeed a splitting sequence of P .We now show that for constraint-free programs, the split SEQ-models relative to SCC-split sequence are independent of the concrete such sequence; in fact, we establish this result for programs in which certain constraints do not occur.Definition 10. A constraint r in P is a cross-constraint, if r intersects distinct SCCs Ci, C j in SCC(P ) that are incomparable in SG(P ), i.e., Ci ∩ At(r) (cid:12)= ∅, C j ∩ At(r) (cid:12)= ∅, and SG(P ) has topological orderings of the forms (. . . , Ci, . . . , C j, . . .) and (. . . , C j, . . . , Ci, . . .).For example, the constraint ← b in the program P of Example 27 is trivially not a cross-constraint, and likewise an addi-tional constraint ← a, b. However, an additional constraint ← b, c would be a cross-constraint. Intuitively, a cross-constraint joins information from different parts Ci and C j of the program that might be evaluated in either order under EQ-model semantics. If under SEQ-model semantics the literals in the constraint over Ci evaluate to true, then making some atoms in C j believed true may effect that the constraint body becomes false, and we thus obtain a SEQ-model; if we proceed in the other order and start with C j , those atoms might be simply set to false and then there is no chance to arrive at a SEQ-model when processing Ci . We illustrate this on a simple example.Example 32. Consider the program P = { b; ← b, not a }. It has the SCCs {a} and {b} which are incomparable in the super-graph SG(P ); we may now set Ci = {a} and C j = {b}. If we evaluate P along the SCC-sequence S = ({a}, {b}), we obtain no SEQS -model; however, if we evaluate P along S(cid:16) = ({b}, {a}), then we obtain the (single) SEQS-model (b, ba).(cid:16)We obtain the following result.Theorem 6. Let P be a program without cross-constraints. Then for every ≤, ≤(cid:16)∈ O(SG(P )), we have that SEQS≤ (P ) = SEQS≤(cid:16) (P ).Corollary 7. For every constraint-free program P , the SEQ-models of P relative to an SCC-split sequence S are independent of the choice of S.The proof of Theorem 6 is technically involving as it needs to be shown that changes in the ordering of the SCCs do not matter in the end. It uses a series of lemmas which assert certain properties of semi-equilibrium models (Ik, J k) of the programs P k that emerge in the bottom up characterization of Theorem 5, and independence properties in certain cases; in 238G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271particular, where for any sets M and M(cid:16)( X(cid:16)) ∈ M(cid:16)}:(cid:16), Yof HT-models, their product is given by M × M(cid:16) = {( X ∪ X(cid:16), Y ∪ Y(cid:16)) | ( X, Y ) ∈ M, Proposition 17. Let P be a program in which each constraint r fulfills either At(r) ⊆ S or At(r) ⊆ At(P ) \ S. If S ⊆ At(P ) is such that both S and At(P ) \ S are splitting sets of P , thenSEQ(P ) = SEQ(b S (P )) × SEQ(t S (P )).Theorem 6 is an analog of the Stratification Theorem [3,46] which states that the perfect (stratified) model of a logic program relative to a stratification is independent of the concrete stratification, and thus one can simply refer to the perfect model of a stratified program; similarly, we thus can define the strongly connected components models of a program as follows.Definition 11 (SCC-models). For every program P without cross-constraints, the SCC-models of P are given as MSEQS≤ (P ) for an arbitrary topological ordering ≤ of SG(P ).SCC(P ) =Let us consider some examples.Example 33. The party program P in the Example 25 is constraint-free; hence, it has some SCC-model. The splitting sequence S for P given in Example 27 is in fact an SCC-splitting sequence, and thus the single SEQS -model (b, bc) is the singe SCC-model of P .Example 34. The program P = {← b; b ← not a} in Example 27 is cross-constraint free. It has the SCCs {a} and {b}, and for the single SCC-split sequence S = ({a}, {a, b}), no split sequence SEQ-model exists; does P has no SCC-model. As this example shows, SCCs may be too fine-grained sometimes to obtain modular SEQ-models in the presence of constraints. This can be remedied by using coarser modules that are defined by the user (cf. Section 9.2).Example 35. Consider the program(cid:8)P =← a, d; a ← c, not a; a ← not b; b ← not e; b ← f ;c ← not d; c ← g, not h;f ← b, not f ; g ← h; h ← c, g(cid:9).Its SCCs are C1 = {a}, C2 = {b, f }, C3 = {c, g, h}, C4 = {d} and C5 = {e}; as a depends on d, the single constraint ← a, d is not a cross-constraint. For the ordering ≤= (C4, C5, C3, C2, C1), we obtain thatSEQS≤ (P ) = SEQ(S2,S3,S4,S5)(P S1 (∅, ∅)) = SEQ(S3,S4,S5)(P S2= SEQ(S4,S5)(P S32 (c, c)) = SEQ(S5)(P S41 (∅, ∅))3 (bc, bc f )) = {(bc, abc f )};SCC(P ) = {(bc, abc f )}. For ≤(cid:16)= (C5, C2, C4, C3, C1), we obtain SEQS≤(cid:16) (P ) = {(bc, abc f )}, in line with Theorem 6. hence MNote that SEQ(P ) = {(bc, abc f ), (b, bdf ), (ac, ace)}.Regarding the properties (D1)–(D3) of a paracoherent semantics in the Introduction, we obtain from Proposition 16immediatelyCorollary 8. The SCC-models semantics, given by Mand it satisfies (D3) for programs without constraints.SCC(P ) for programs P without cross-constraints, satisfies properties (D1)–(D2), As for the properties of SCC-models, we focus here on a particular aspect that is important with respect to an envisaged exploitation for paracoherent answer set construction; computational aspects are considered in Section 7.6.1.1. Modularity of SCC-modelsIn the definition of split SEQ-models, we made use of splitting sets as a major tool for modular computation of equilib-rium models (answer sets) of a logic program. Indeed, for any splitting set S of P , as follows from [31] we have thatEQ(P ) =EQ(t S (P ) ∪ {a | a ∈ X} ∪ {← a | a ∈ S \ X}).(11)( X, X)∈EQ(b S (P ))Note the similarity to the equation in (9) which we used to define SEQ-models of a program relative to a splitting set; the major difference is that we use the mc(·) operator to single out smallest gaps at a global level. And, in general for different S we shall obtain different SEQ-models from (9). However, if we confine to SCC-models, then an analog to (11) and its generalization to splitting sequences holds.That is, if we replace in Equation (10) SEQ, SEQS , and SEQSall by M, then the resulting equation holds.(cid:16)SCC(cid:11)G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Theorem 7. Let S be a splitting set of a program P without cross-constraints. Then(cid:13)(cid:11)SCC(P ) = mcM(cid:14)SCC(P S (I, J )).M(I, J )∈MSCC (b S (P ))239(12)Thanks to this result, we can compute the SCC-models of a given program modularly bottom up along an arbitrary splitting sequence (using always M); in particular, if an algorithm has processed a bottom part b S (P ) of a program P and found equilibrium models (answer sets) for it, and it encounters that an extension of these equilibrium models using (11)SCC (b S (P )) = EQ(b S (P )), does not yield any answer set, then it can switch to a “paracoherent mode” and apply (7); as Mwe obtain the same result as if we would compute the SCC-models of P from scratch. That is, no backtracking or restarting of the computation is necessary.SCCWe note none of the occurrences of Min general, that is compute and use simply the semi-equilibrium models respectively the split semi-equilibrium models of ; in addition to all SCC-models, we might get some the bottom part and/or the remainder of the program relative to Ssemi-equilibrium models of the program P where the particular splitting sequence Smatters. Formally, the following property holds, which is an easy consequence of Theorem 5.in the equation (12) can be replaced with SEQ or an arbitrary SEQS(cid:16)(cid:16)SCC(cid:16)Proposition 18. Let S be a splitting sequence of a program P without cross-constraints. ThenSCC(P ) ⊆ SEQS (P ) and MSCC(P ) =M(cid:15)S∈SQ(P )SEQS (P ),where SQ(P ) is the set of all splitting sequences of P .6.2. MJ C-split sequences and modelsUnfortunately, Theorem 6 fails if we allow arbitrary constraints in P , as witnessed e.g. by the programs in Examples 32and 24. To deal with this situation, different ways are possible.(1) One way is to exclude constraints (or less restrictive, cross-constraints), and resort instead to the usage of rules which create unstable negation; that is← Bodyis replaced withf ← Body, not f ,(13)(14)is a fresh atom. Indeed, on some (early) implementations of answer set solvers constraints have been provided in where fthis way. The SEQ-model semantics is able to distinguish between (13) and (14); this can be exploited to use (14) as a soft constraint that may intuitively be violated if needed to achieve an EQ-model resp. answer set; indeed, this rule can always be satisfied by considering f as believed true.(2) Another possibility is to remedy situations in which constraints are not embedded in ordered SCCs. To this end, we con-sider merging of SCCs in such a way that (i) independence of concrete topological orderings is preserved and, furthermore, (ii) merging is performed conservatively, that is only if it is deemed necessary. This is embodied by the maximal joinable components of a program, which lead to so called MJ C-split sequences and models. Informally, relevant SCCs that are incomparable (thus unproblematic in evaluation if we disregard cross-constraints) are merged if they both intersect with a constraint. The merging is repeated until no cross-constraint violation exists with respect to the new (merged) components. In the rest of this subsection, we formalize this approach on a declarative basis.We start with introducing the notions of related pairs and joinable pairs of SCCs. We call a pair (K 1, K2) of SCCs of P a related pair, if either K1 = K2 or some constraint r ∈ P intersects both K1 and K2, i.e., At(r) ∩ K1 (cid:12)= ∅ and At(r) ∩ K2 (cid:12)= ∅. By C(K1,K2)(P ) we denote the set of all such constraints r.Definition 12. A related pair (K1, K2) is a joinable pair, if K1 = K2 or some ordering (C1, . . . , Cn) in O(SG(P )) exists such that (i) K1 = C s and K2 = C s+1 for some 1 ≤ s < n, (ii) (K2, K1) /∈ E SG and (iii) some r ∈ C(K1,K2)(P ) exists such that At(r) ⊆ C1 ∪ . . . ∪ C s+1. By JP(P ) we denote the set of all joinable pairs of P .Intuitively item (i) states that in some topological ordering K 1 immediately precedes K2; item (ii) states that no atom in K2 directly depends on an atom from K1. If this does not hold, joining K1 and K2 to achieve independence is not necessary as their ordering is fixed. Finally item (iii) requires that some constraint must access the two SCCs (which thus must be a cross-constraint) and appear in the evaluation in the bottom of the program computed so far.240G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Example 36. Reconsider the program P = { b; ← b, not a } in Example 32 with the incomparable SCCs {a}, {b} and the cross-constraint ← b, not a. The pair (K1, K2) for K1 = {a} and K2 = {a, b} is related and also joinable.Example 37. For P = {← b, not a; ← b, not c; d ← not a; c ← not e; b ← c}, we have SCC(P ) = {{a}, {b}, {c}, {d}, {e}}. We observe that ({c}, {b}) is a related, but not a joinable pair, because ({c}, {b}) satisfies conditions (i) and (iii), but not (ii). On the other hand, ({a}, {b}) is a joinable pair.Example 38. Reconsider the company program P in Example 24, and recall that the SCCs (of the ground version) of P are all sets {a}, where a is a ground atom; for brevity, we abbreviate predicate names to the first letter. In the supergraph SG(P ), we then have the edges ({c(sam)}, {m(sam)), ({e(sam)}, {m(sam)), ({h(sam)}, {e(sam)}), and ({h(sam)}, {s(sam, sam)}).10 For K1 = {c(sam)} and K2 = {h(sam)}, we obtain that (K1, K2) is a related and also joinable pair. Similarly, ({c(sam)}, {e(sam)})is a related and joinable pair; while ({h(sam)}, {e(sam)}) is a related pair, it is not joinable (condition (ii) fails).We now extend joinability from pairs to any number of SCCs.Definition 13. Let P be a program. Then K1, . . . , Km ∈ SCC(P ) are joinable, if m = 2 and some K ∈ SCC(P ) exists such that (K1, K ), (K , K2) ∈ JP(P ), or otherwise K i, K j are joinable for each i, j = 1, . . . , m. We let JC(P ) = { i=1 K i | K1, . . . , Km ∈SCC(P ) are joinable} and call(cid:10)mMJ C(P ) = { J ∈ JC(P ) | ∀ J(cid:16) ∈ JC(P ) : J (cid:12)⊂ J(cid:16)}the set of all maximal joined components (MJ Cs) of P .Note that (K1, K2) ∈ JP(P ) implies that K1 and K2 are joinable (choose K = K1).Example 39 (continued). The program P = { b; ← b, not a } has the single joinable pair ({a}, {b}) and thus the single maximal joined component {a, b}.Example 40 (continued). In Example 37, ({a}, {b}) is the only nontrivial joinable pair; hence MJ C(P ) = {{a, b}, {c}, {d}, {e}}.Example 41 (continued). For the company program P in Example 24, the nontrivial joinable components are ({c(sam)},{h(sam)}) and ({c(sam)}, {e(sam)}); hence MJ C(P ) = {{e(sam), h(sam), c(sam)}, {m(sam)}, {s(sam)}}.As easily seen, MJ C(P ) is a partitioning of At(P ) that results from merging SCCs. We define a dependency graph on them, called the MJ C graph of P and denoted JG(P ), that is analogous to the supergraph on the SCCs. Formally, JG(P ) = (cid:14)V JG, E JG(cid:15), (cid:16), (a, b) ∈ E DG}. Note that JG(P ) is like SG(P ) a (cid:16) ∈ MJ C(P ), ∃a ∈ J , ∃b ∈ Jwhere V JG = MJ C(P ) and E JG = {( J , Jdirected acyclic graph, and hence admits a topological ordering; we denote by O(JG(P )) the set of all such orderings. We thus define(cid:16)) | J (cid:12)= JDefinition 14. Let P be a program and ≤ = ( J 1, . . . , J m) be a topological ordering of JG(P ). Then the splitting sequence induced by ≤ is S≤ = (S1, . . . , Sm), where S1 = J 1 and Sk = Sk−1 ∪ J k, for k = 2, . . . , m.The sequence S≤ is again indeed a splitting sequence, which we call a MJ C-splitting sequence. We obtain a result analogous to Theorem 6, but in presence of constraints.Theorem 8. Let P be a program. For every ≤, ≤(cid:16)∈ O(JG(P )), we have SEQS≤ (P ) = SEQS≤(cid:16) (P ).The proof of this result is similar to the one of Theorem 6, but uses different lemmas.Similarly as SCC-models, we thus can define the MJ C-models of a program.Definition 15 (MJ C-models). For any program P , the MJ C-models of P are given as Marbitrary topological ordering ≤ of JG(P ).MJ C(P ) = SEQS≤ (P ) for an Example 42 (continued). Reconsider P in Example 37. Then for the ordering ≤= ({a}, {d}, {e}, {c}, {b}) we obtain SEQS≤ (P ) =∅, while for ≤(cid:16)= ({e}, {c}, {b}, {a}, {d}) we obtain SEQS≤(cid:16) (P ) = {(bc, abc)}. On the other hand, JG(P ) has the single topo-MJ C(P ) = {(bc, abc)}. Note that SEQ(P ) =logical ordering ≤= ({e}, {c}, {a, b}, {d}), and SEQS≤ (P ) = {(bc, abc)}; hence M{(bc, abc), (d, de)}.10 Fixed builtin predicates like #int(·) can be disregarded in dependency analysis.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271241The problem in Section 6.2 disappears when we use the MJCs.Example 43 (continued). For P = { b; ← b, not a } in Example 32, the graph JG(P ) has the single node {a, b} and SEQS (P ) ={(b, ab)} for S = {a, b}. Thus the single MJ C-model of P is (b, ab), as desired.Example 44 (continued). For the company program P in Example 24, the join graph JG(P ) has the edges ({e(sam), h(sam),c(sam)}, {m(sam)}) and ({e(sam), h(sam), c(sam)}, {s(sam)}). Thus two MJ C-split sequences are possible, viz. S =(S1, S2, S3) where S1 = {m(sam)}, S2 = {m(sam), s(sam)}, and S3 = {m(sam), s(sam), e(sam), h(sam), c(sam)}; and (cid:16) = (S(P ) have the single SEQ-model SIκ = {m(sam), e(sam), c(sam), K h(sam)}, which is then the single MJ C-model of P .= S3. Both SEQS (P ) and SEQS= {s(sam)}, and S(cid:16)3) where S= S2, and S(cid:16)1, S(cid:16)2, S(cid:16)3(cid:16)1(cid:16)2(cid:16)Note that trivially, the MJ C- and the SCC-semantics coincide for constraint-free programs (in fact, also in absence of cross-constraints). As for the properties (D1)–(D3), again from Proposition 16 we obtain:Corollary 9. The MJ C-models semantics, given by Mfree, also (D3).MJ C(P ) for any program P , satisfies (D1)–(D2), and if P is cross-constraint-Program coherence (D3) is not ensured by MJ C-models, due to lean component merging that fully preserves depen-dencies. To obtain a SEQ-model, blurring strict dependencies can be necessary, where two aspects need to be taken into account.(A1) Inconsistency may still emerge from cross-constraints.Example 45. Consider the program P = {← b, not a; b; b ← a}. It has the SCCs {a} and {b}; as they are not join-able, MJ C(P ) = {{b}, {a}}. The single MJ C-splitting sequence is ({a}, {a, b}), which however does not admit a split SEQ-model; consequently, P has no MJ C model.This can be remedied by suitably merging components that intersect the same constraint.(A2) A second, orthogonal aspect is dependence.Example 46. The program P = { ← b; b ← not a } has no MJ C-model, as the MJ C-splitting sequence S = ({a}, {a, b})admits no split SEQ-model; the culprit is a, which does not occur in the constraint.Clearly, the problem extends to dependence via an (arbitrarily long) chain of rules; e.g. change in Example 46 the rule b ← not a to b ← c1, c1 ← c2, . . . , cn−1 ← cn, cn ← not a. Again, this can be remedied by merging components. Many merging policies to ensure (D3) are conceivable; however, such a policy should ideally not dismiss structure unless needed, and it should be efficiently computable; we defer a discussion to Section 8, as the complexity results in the next section will provide useful insight for it.6.2.1. Modularity of MJ C-modelsA naive generalization of the modularity property of SCC-models in Theorem 7 fails, as it does not hold for arbitrary splitting sets. To wit, for P = {b; ← b, not a} and the splitting set S = {a}, the modular computation (similar as in the right MJ C(P ) = {(b, ba)}. However, if we properly restrict S, then the generalization hand side of (12)) yields no models, while Mholds.Theorem 9. Let S be a splitting set of a program P such that S =(cid:10)M for some M ⊆ MJ C(P ). ThenMJ C(P ) = mcM(cid:13)(cid:11)(cid:14)MJ C(P S (I, J )).M(I, J )∈MMJ C (b S (P ))(15)Thus, the same evaluation strategy as for SCC-models can be applied. Furthermore, we have an analogue to Proposition 18. We say that a split-sequence S = (S1, . . . , Sn) of a program P is MJ C-compatible, if for every J ∈ MJ C(P ) and 1 ≤ i ≤ n, either J ⊆ S i or J ∩ S i = ∅ holds; intuitively, no maximal joint component of P is split across different layers of S. Then,Proposition 19. Let S be an MJ C-compatible splitting sequence of a program P . ThenMJ C(P ) ⊆ SEQS (P ) and MMJ C(P ) =MSEQS (P ),where MSQ(P ) is the set of all MJ C-compatible splitting sequences of P .S∈MSQ(P )(cid:15)242G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271MJ C(P ) on them; MFig. 1. Inclusion between different semantics, where S is an arbitrary split sequence. MMP (resp., the maximal joined components of P ). MEQ(P ) (cid:12)= ∅.SCC(P ) applies only to cross-constraint free P and coincides with MJ C(P )) coincides with SEQS for any S induced by a topological sort of the strongly connected components of MJ C(P ) is included in SEQS (P ) for MJ C-compatible S (dashed symbol). All semantics coincide if SCC(P ) (resp., M6.3. Summary of model relationshipsAt the end of this section, we summarize the relationships between the various semantics introduced in this paper. Fig. 1 shows the inclusion relation between different notions of models, viewed as HT-models respectively bi-models. Notably all inclusions collapse if the program has equilibrium models (EQ(P ) (cid:12)= ∅); otherwise, the semi-stable (SST ) models are in general incomparable to the semi-equilibrium (SEQ) models and any of its refinements, as can be seen e.g. from Example 22. The SCC-models are only defined for programs without cross-constraints; each of them is a split SEQ-model with respect to an arbitrary splitting sequence; in fact, the SCC-models are exactly the HT-models which are split models under every splitting sequence. Furthermore, they coincide with the MJ C-models, which for programs with cross-constraints may not all be split SEQ-models with respect to an arbitrary splitting sequence. However, the inclusion holds for MJ C-compatible splitting sequences (dashed symbol), and the MJ C-models are exactly the HT-models which are split models under every MJ C-compatible splitting sequence.7. Complexity and computationIn this section, we turn to the computational complexity of the paracoherent model semantics that we have considered in the previous sections. In this, we deal with the SEQ-model and the split SEQ-model semantics in detail, while we treat the SST -model semantics more in passing; the reason is that the complexity of SST -model semantics has been elucidated in more detail in [17], while the SEQ-model semantics has been only briefly considered there.Regarding SEQ-model semantics, we study the following major reasoning tasks:(MCH)(INF)(COH)Given a program P and an HT-interpretation ( X, Y ), decide whether ( X, Y ) ∈ SEQ(P ).Given a program P , an atom a and v ∈ {t, f, bt}, decide whether a is a brave [resp. cautious] SEQ-consequence of SEQ a [resp. P |=c,vP with value v, denoted P |=b,vSEQ a], i.e., a has value v in some (every) ( X, Y ) ∈ SEQ(P ) value v.Given a program P , decide whether SEQ(P ) (cid:12)= ∅.The generalizations of these problems to split SEQ-semantics, where in addition a split sequence S is part of the input and SEQ is replaced with SEQS , are denoted with MCH-S, INF-S, and COH-S, respectively. We consider all problems for several classes of programs, viz. normal, disjunctive, stratified, and headcycle-free programs11 and the split SEQ-models problems also for SCC- and MJ C-splitting sequences S.The attentive reader might ask why positive programs are not considered here; they are of less interest, as the (split sequence) SEQ-models coincide with the minimal models of P (see Corollaries 2 and 4). Furthermore, we note that hcf-programs are under SEQ-semantics sensitive to body shifts; e.g., P = {a ∨ b; a ← not a; b ← not b} has the SEQ-models (a, ab) and (b, ab), while its shift P → = {a ← not b; b ← not a; a ← not a; b ← not b} has the single SEQ-model (∅, ab). Thus results for hcf-programs do not immediately carry over to normal program.7.1. Overview of complexity resultsOur complexity results are summarized in Tables 1 and 2. They show that SEQ-model semantics is with respect to model checking (MCH) and inference (INF) one level higher up in the polynomial hierarchy than the EQ-model (i.e., answer set) semantics; this is not surprising as the characterization of a SEQ-model in Theorem 2 involves besides h-minimality also gap-minimality, while the EQ-model definition involves only h-minimality. As gap-minimality is a global property and has to be checked across all h-minimal HT-models of a program, intuitively an (additional) quantifier is needed to express that no h-minimal HT-model with smaller gap exists; in particular, this causes SEQ-model checking for normal programs to become intractable. The additional quantifier is then also needed for brave and cautious reasoning, where we 11 Note that [17] did not consider stratified and hcf-programs.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271243Table 1Complexity of SEQ-models (completeness results). The same results hold for SST models.Problem / Program P :Normal, strat. normal, headcycle-freeDisj. stratified, disjunctive(MCH) Model checking:(INF)Brave reasoning:Cautious reasoning:(COH)Existence:( X, Y ) ∈ SEQ(P )?P |=b,vSEQ a?P |=c,vSEQ a?SEQ(P ) (cid:12)= ∅?coNP-c(cid:3) p2 -c(cid:4)p2 -cNP-c(cid:4)p2 -c(cid:3) p3 -c(cid:4)p3 -cNP-cTable 2Complexity of split SEQ-models (completeness results). The same results hold for canonical models (SCC-, MJ C-split sequences S).Problem / Program P :Normal, strat. normal, headcycle-freeDisj. stratified, disjunctive(MCH-S) Model checking:(INF-S)Brave reasoning:Cautious reasoning:(COH-S)Existence:( X, Y ) ∈ SEQS (P )?P |=b,vSEQS a?P |=c,vSEQS a?SEQS (P ) (cid:12)= ∅?coNP-c(cid:3) p2 -c(cid:4)p2 -c(cid:3) p2 -c(cid:4)p(cid:3) p(cid:4)p(cid:3) p2 -c3 -c3 -c3 -cneed to find a suitable SEQ-model that establishes respectively refutes the query atom, with one exception (this will be discussed below). For the coherence problem, however, the complexity is different compared to the EQ-models semantics as it resorts to classical coherence, and thus to SAT; for some programs it is lower (e.g., for programs without constraints, where EQ-model existence is NP-complete resp. (cid:3) p2 -complete, while COH is polynomial), while for others it is higher (e.g., for normal stratified programs with constraints COH is NP-complete, while EQ-model existence is polynomial).The results in Table 2 show that split SEQ-models have the same complexity as SEQ-models (i.e., structural information does not affect complexity) except on Problem COH, which is harder. Problems MCH and INF do not become harder, as MCHreduces to polynomially many MCH instances without splitting; the hardness results for arbitrary splitting sequences are inherited from respective results without splitting.The reason for the complexity increase of COH is that coherence (D3) no longer holds for split SEQ-model semantics. In particular, this means that imposing a structural condition on building SEQ-models along SCCs may eliminate such models. The increase in complexity has a further important implication. Namely, that under usual complexity hypotheses, no polynomial-time method μ exists that associates with P a splitting sequence S = μ(P ), using a polynomial-time checkable criterion on P , such that (i) μ respects structure and does not become trivial, i.e., μ(P ) (cid:12)= ( At(P )) if SEQS (P ) (cid:12)= ∅ for some S (cid:12)= ( At(P )), and (ii) μ preserves coherence, i.e., SEQ(P ) (cid:12)= ∅ implies SEQS (P ) (cid:12)= ∅. This negative result holds even if the method μ is allowed to be nondeterministic, i.e., can for example “guess” a suitable splitting sequence S for P . In other words, the price for ensuring coherence of a splitting sequence with tractable (or NP) effort is to merge sometimes more components than necessary.For SCC and MJ C splitting sequences, we obtain analogous results; informally, the problems do not get easier as splitting (which is a purely syntactic notion) can be blocked by irrelevant rules.7.1.1. Semi-stable modelsFor semi-stable models, similar results hold as for SEQ-models in Table 1. The reason is that model checking for semi-stable models amounts, by the characterization of Theorem 1, to a test that is similar to the one for SEQ-models according to Theorem 2: testing (I, J ) |=β P is like testing (I, J ) |= P feasible in polynomial time, and the conditions (i) and (ii) are (cid:16)). Similar arguments as for SEQ-models establish then the membership results for analog to the conditions (iSST -models. The matching hardness results are derived, however, using different reductions, which can be found in [17]. Noticeably, the proofs there establish hardness also under the restrictions to hcf, stratified normal, and disjunctive stratified programs; for hcf-programs, membership of model checking in coNP follows from the fact that deciding item (i) in Theo-rem 1 is feasible in polynomial time: as easily seen, this test amounts to deciding whether I ∈ MM(P J ); as P J is hcf and minimal model checking for hcf programs is polynomial [8], the tractability follows.(cid:16)) and (ii7.2. Derivation of the resultsIn the following, we formally state and derive the results in Tables 1 and 2. Rather than going into tiring technical details, we shall confine in the membership parts to the essential points and describe in the hardness parts the constructed programs without proving the correctness in each case, which is routine.We exploit that in most cases the split-variant (cid:4)-S of a problem (cid:4) features its full complexity already for the trivial split sequence S = ( At(P )); thus (cid:4)-S and (cid:4) have the same complexity.244G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Theorem 10. Given a program P , a splitting sequence S and an HT-interpretation ( X, Y ) recognizing if ( X, Y ) ∈ SEQS (P ) is(i) coNP-complete for each of normal, stratified, and headcycle free P , and(ii) (cid:4)p2 -complete for disjunctive and stratified disjunctive P .In all cases, coNP- resp. (cid:4)p2 -hardness holds for S = ((cid:3)), i.e., SEQ-model semantics.Proof. The membership parts for MCH can be derived as follows. Given an HT-interpretation ( X, Y ) of a program P , we can verify by Theorem 2 whether it is a SEQ-model of P by checking that ( X, Y ) |= P , which obviously is feasible in (cid:16)), a guess for a polynomial time, and proving h-minimality (item (i(cid:16) ⊂ X can be verified in polynomial time; thus h-minimality can be tested in coNP. (cid:16), Y ) of P such that XHT-model ( X(cid:16)) ⊂ gap( X, Y )(cid:16)) on top can be decided using an oracle for (cid:4)pCondition (ii(cid:16))exists; this establishes membership in (cid:4)pamounts to X ∈ MM(P Y ); if P is hcf then also P Y is hcf, and minimal model checking for such programs is polynomial [8]; if P is normal, then P Y is Horn and minimal model checking is well-known to be polynomial.2 . In case that P is hcf or normal, deciding h-minimality is polynomial, since (i(cid:16))) and gap-minimality (item (ii2 that no h-minimal model ( X(cid:16))) of ( X, Y ); as for (i(cid:16)) with gap( XAs for split SEQ-models, by Theorem 5 deciding whether ( X, Y ) is a SEQ-model of P w.r.t. S = (S1, . . . , Sn) reduces to checking whether ( X, Y ) and all ( X, Y )|Sk are SEQ-models of P resp. b Sk (P k−1), for k = 1, . . . , n. Each program b Sk (P k−1)is normal (stratified normal, hcf, stratified disjunctive) if P has this property. Hence the already established membership results for SEQ-models generalize to the case of splitting sequences.The matching hardness results for item (ii) and SEQ-models are proved in Appendix C.1; for stratified normal programs, which covers also normal and hfc-programs, we give a simple reduction from minimal model checking of positive programs P (which is well-known to be coNP-complete, cf. [16]). For any rule r, let cs(r) be its constraint rewriting, i.e., cs(r) =−(r), not H(r), and let cs(P ) = {cs(r) | r ∈ P }. Then M ∈ MM(P ) iff (∅, M) ∈ SEQ(cs(P )). All hardness results ← Btrivially extend to arbitrary splitting sequences, which establishes the result. (cid:2)+(r), not B(cid:16), Y(cid:16), YTheorem 11. Given a program P , a splitting sequence S, an atom a and a value v ∈ {t, f, bt}, deciding whether(i) P |=b,vSEQS a is (cid:3) p2 -complete for each of normal, stratified normal, and hcf P and (cid:3) p3 -complete for disjunctive and stratified dis-(ii) P |=c,vSEQS a is (cid:4)p2 -complete for each of normal, normal stratified, and hcf P and (cid:4)p3 -complete for disjunctive and stratified dis-junctive P ;junctive P .In all cases, (cid:3) p2 /(cid:4)p2 - resp. (cid:3) p3 /(cid:4)p3 -hardness holds for S = ((cid:3)), i.e., SEQ-model semantics.3 /(cid:4)pProof. Membership of brave (resp. cautious) reasoning from SEQ-models w.r.t. S in (cid:3) p3 ) for disjunctive programs follows from Theorem 10, and similarly membership for normal, normal stratified and hcf-programs in (cid:3) p2 ]. The (cid:3) p3 -hardness for brave [resp. cautious] reasoning from SEQ-models from stratified disjunctive programs is proven in Appendix C.1 resp. Appendix C.2. The (cid:3) p2 -hardness for stratified normal programs (and thus for normal and hcf-programs) follows by a reduction from brave (resp. cautious) reasoning from positive disjunctive programs P , which is (cid:3) p2 -2 -hard (see Appendix C.1). For every such P and atom a, we have that a ∈ M for some M ∈ MM(P ) iff cs(P ) |=b,btresp. (cid:4)paSEQ a); indeed, the SEQ-models of P and cs(P ) are the HT-models (M, M) resp. (∅, M), where (resp. P |=fM ∈ MM(P ). (cid:2)c a iff cs(P ) |=c,f2 [resp. (cid:4)p3 (resp. (cid:4)p2 /(cid:4)pSNotably brave reasoning has the same complexity in all cases, if we fix the truth value v arbitrarily, already for S = At(P )(i.e., for SEQ-models). For cautious reasoning, this similarly holds, except that for v = bt and S = At(P ), the complexity drops to coNP resp. (cid:4)P2 (see Appendix C.2).Theorem 12. Given a program P and a splitting sequence S, deciding whether SEQS (P ) (cid:12)= ∅ is2 -complete for each of normal, stratified normal, and hcf P ; and3 -complete for stratified disjunctive and disjunctive P ; and(i) (cid:3) p(ii) (cid:3) p(iii) NP-complete for all program classes considered, if S = ((cid:3)) (i.e., for SEQ in place of SEQS ).Proof. The membership parts of (i) and (ii) follow easily from the results for MCH in Theorem 10, as a candidate SEQ-model of P w.r.t. S can be guessed and checked with an NP resp. (cid:3) p2 oracle in polynomial time. The hardness parts b a in Problem INF. The (cid:3) pof (i) and (ii) can be obtained via a reduction from brave reasoning P |=v2 -hard) b a iff some SEQ-model ( X, Y ) of P exists with a ∈ Y . Let b be a fresh atom and instances are of a form such that P |=v3 -hard (resp. (cid:3) pG. Amendola et al. / Artificial Intelligence 234 (2016) 219–271245define then P(resp. (cid:3) p2 -) hardness.(cid:16) = P ∪ {← b; b ← not a}. Then P(cid:16)has a SEQ-model w.r.t. S = ( At(P ), At(P(cid:16))) iff P |=vb a; this proves the (cid:3) p3 -The result in (iii) is an immediate consequence of the NP-completeness of SAT (satisfiability of a clause set) in proposi-tional logic and the classical coherence property (D3) of SEQ-model semantics. (cid:2)Canonical split SEQ-semantics. For SCC- and MJ C-splitting sequences, we haveTheorem 13. The results on Problems MCH, INF and COH in Table 2 continue to hold if S is restricted to SCC- (resp. MJ C-) splitting sequences.Proof. Indeed, the respective hardness proofs are extended to this setting. For a program P , let p be a fresh atom and let P cl = P ∪ {a ← a, p; p ← p, a | a ∈ (cid:3)}. Clearly, P and P cl have the same SEQ-models, and P cl has the single SCC(cid:3)(cid:16) = (cid:3) ∪ {p}. Exploiting this, the programs for MCH and INF have the single splitting sequence S = ((cid:3)(cid:16)) and those for Problem COH have Swe conclude that no method μ as in Subsection 7.1 exists (under usual complexity hypotheses). (cid:2)(cid:16) = ((cid:3)(cid:16), (cid:3)(cid:16) ∪ {b}); these are SCC- and MJ C-splitting sequences. Furthermore, from S(cid:16)7.3. Constructing and recognizing canonical splitting sequencesIt is well-known that SCC(P ) and SG(P ) are efficiently computable from P (using Tarjan’s [53] algorithm even in linear time); hence, it is not hard to see that one can recognize a SCC-splitting sequence S in polynomial time, and that every such S can be (nondeterministically) generated in polynomial time (in fact, in linear time). We obtain similar tractability results for MJ C(P ) and MJ C-splitting sequences. To this end, we first note the following useful proposition.Proposition 20. Let P be a program and let K1, K2 ∈ SCC(P ). Then K1 and K2 satisfy (i) and (ii) of Definition 12 iff they are disconnected in SG(P ), i.e., no path from K1 to K2 and vice versa exists.Based on this proposition, we can characterize the joinable pairs that are witnessed by a constraint from r as follows. As usual, let us call a SCC Ci in a set C ⊆ SCC(P ) of SCCs maximal, if no C j in C exists that is comparable to Ci in SG(P ) and ordered after Ci , i.e., every topological ordering of SG(P ) is of the form (. . . , C j, . . . , Ci, . . .).Corollary 10. Given a constraint r ∈ P , let C1, . . . , Cl be the maximal SCCs C of P in SG(P ) such that At(r) ∩ C (cid:12)= ∅. Then (K 1, K2)where K1 (cid:12)= K2 is a joinable pair of P witnessed by r (i.e., satisfies (iii) for r) iff K 1, K2 ∈ {C1, . . . , Cl}.By exploiting this characterization, we can construct MJ C(P ) and furthermore JG(P ) by the following steps:1. compute DG(P ), SCC(P ) and SG(P );in SCC(P ) such that C r2. for every constraint r ∈ P , determine all maximal C ril , and set MC := {C r | r ∈ P , H(r) = ∅} and NMI := SCC(P ) \ {C r| r ∈ P , H(r) = ∅};3. let C r = C r14. merge J 1, J 2 ∈ MC such that J 1 ∩ J 2 (cid:12)= ∅ (i.e., set MC := (MC \ { J 1, J 2}) ∪ { J 1 ∪ J 2}) until no longer possible;5. set MJ C(P ) := MC ∪ NMI and JG(P ) = (V JG, E JG) where V JG = MJ C(P ) and E JG = {( J 1, J 2) | J 1 (cid:12)= J 2 ∈ MJ C(P ), ∃a ∈∩ At(r) (cid:12)= ∅;1, . . . , C r1, . . . , C r∪ · · · ∪ C rllJ 1, ∃b ∈ J 2, (a, b) ∈ E DG}.Example 47. Reconsider the program P from Example 37, which contains the constraints r1: ← b, not a and r2: ← b, not c. We recall that SCC(P ) = {{a}, {b}, {c}, {d}, {e}}. In Step 2 of the procedure, the maximal SCCs of r1 are {a}, {b} and the single maximal one of r2 is {b}; thus in Step 3, we have MC = {{a, b}, {b}} and NMI = {{c}, {d}, {e}}. In Step 4, {a, b} and {b}are merged, resulting in MC = {{a, b}}. Finally, in Step 5 MJ C(P ) is assigned MC ∪ NMI = {{a, b}, {c}, {d}, {e}}; this is the correct result.The following result states the correctness of the procedure and that it can be implemented to run in bilinear time.Theorem 14. Given a program P , MJ C(P ) and JG(P ) are computable in time O(cs·(cid:25)P (cid:25)), where cs = |{r ∈ P | H(r) = ∅}| is the number of constraints in P and (cid:25)P (cid:25) is the size of P .In particular, the algorithm runs in linear time if the number of constraints is bounded by a constant. It remains as an interesting open issue whether the same time bound is feasible without this constraint.246G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2718. Related workIn this section, we first review some general principles for logic programs with negation, and we then consider the relationship of semi-stable and semi-equilibrium semantics to other semantics of logic programs with negation. Finally, we address some possible extensions of our work.8.1. General principlesIn the context of logic programs with negation, several principles have been identified which a semantics desirably should satisfy. Among them are:• the principle of minimal undefinedness [59], which says that a smallest set of atoms should be undefined (i.e., neither true nor false);• the principle of justifiability (or foundedness) [59]: every atom which is true must be derived from the rules of the pro-gram, possibly using negative literals as additional axioms;• the principle of the closed world assumption (CWA), for models of disjunctive logic programs (Eiter et al. [19]): “If every rule with an atom a in the head has a false body, or its head contains a true atom distinct from a w.r.t. an acceptable model, then a must be false in that model.”It can be shown that both the semi-stable and the semi-equilibrium semantics satisfy the first two principles (properly rephrased and viewing bt as undefined), but not the CWA principle; this is shown by the simple program P = {a ← not a}and the acceptable model {K a}. However, this is due to the particular feature of making, as in this example, assumptions about the truth of atoms; if the CWA condition is restricted to atoms a that are not believed by assumption, i.e., Iκ (a) (cid:12)= btin a semi-stable resp. semi-equilibrium model Iκ , then the CWA property holds.We eventually remark that Property N can be enforced on semi-stable models by adding constraints ← a, not a for all atoms a to the (original) program. However, enforcing Property K on semi-stable models is more involved and efficient encodings seem to require an extended signature.8.2. Related semanticsIn this section, we relate the semi-stable and semi-equilibrium semantics to several semantics in the literature that allow for models even if a no answer set of a program exists.8.2.1. Evidential stable modelsMotivated by the fact that a disjunctive deductive database (DDDB) may lack stable models or even P-stable models, Seipel [51] presented a paracoherent semantics, called the evidential stable model (ESM) semantics, which assigns some model to every DDDB (that is, to every constraint-free disjunctive logic program), such that the properties (D1)–(D3) in the Intro-duction are satisfied. Similar to [49], but guided by slightly different intuition, he defined the evidential stable models of a program P in a two-step process. First P is transformed into a positive disjunctive program P, called the evidential trans-form of P , whose answer sets, i.e., its minimal models are considered. Among them are in the second step those selected that are informally preferred according to the amount of reasoning by contradiction that they involve. While Seipel did not consider constraints, his approach naturally extends to programs with constraints, and we consider this extension in the sequel.Formally, for a given (cid:3) let (cid:3)E = (cid:3) ∪ {Ea | a ∈ (cid:3)}, where Ea intuitively means that there is evidence that a is true. Given consists of the following rules:a program P , its evidential transformation PEE−(r) ← B1. H(r) ∪ E B−(r) ← E B2. E H(r) ∪ E B3. Ea ← a, for each a ∈ (cid:3),+(r) and+(r), for each rule r ∈ P of form (1), andwhere for every set S ⊆ (cid:3) of atoms, E S = {Ea | a ∈ S}. Intuitively, the rules in (2) and (3) correspond to the rules that are added to Sakama and Inoue’s program P κ in the epistemic transformation to ensure the Properties N and K (see Definition 6); the rules in (2), however, are quite different from P κ . They intuitively infer evidence for the truth of some atom b j under negation (m < j ≤ n) from the violation of the positive part of the rule (i.e., if all b j , 1 ≤ j ≤ m are true and no ai , 1 ≤ i ≤ l is true).An interpretation I over (cid:3)Eminimal models of PEis an evidential stable model, if (1) I is a minimal model of Pa ⊆-minimal E -violation set VE (I), which is defined as V(I) = {a ∈ (cid:3) | Ea ∈ I, a /∈ I}., and (2) I has among all Now the following can be shown. For every bi-interpretation ( X, Y ) let ( X, Y )E = X ∪ E Y , and for every I ⊆ (cid:3)E, let β(I)Ebe the inverse of ·E, i.e., β(I) = ( X, Y ) such that ( X, Y )E = I .Theorem 15. Let P be a program over (cid:3). Then for every bi-interpretation ( X, Y ) over (cid:3), it holds that ( X, Y ) ∈ SEQ(P ) iff ( X, Y )Ean evidential stable model of P .is G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271247Thus the SEQ-model semantics coincides with the evidential stable model semantics for disjunctive logic programs. The Etheorem above gives a characterization of evidential stable models in terms of HT-logic, and in turn we obtain with Pa simpler program to describe the SEQ-models than the epistemic transformation P κ in Section 4. Note, however, that the program is not a straightforward encoding of the semantic characterization of SEQ-models in Theorem 2; the class of -models does not contain all h-minimal HT-models of P , but sufficiently many to single out all the SEQ-models by gap Pminimization.E8.2.2. CR-PrologIn order to deal with inconsistency in answer set programs, Balduccini and Gelfond introduced CR-Prolog [4] as a declar-ative approach for inconsistency removal from program. Roughly speaking, each program P is equipped with a further set of rules CR of the formr :h1 or . . . or hk+← l1, . . . , lm, not lm+1, . . . , not ln,where intuitive reading is: if l1, . . . , lm are accepted beliefs while lm+1, . . . , ln are not, then one of h1, . . . , hk “may possibly” be believed. In addition, a preference relation on the rules may be provided.(cid:16)(cid:16)Rules from this pool CR can be added to restore consistency of the program P if no answer set exists, applying Occam’s (cid:16) = P ∪ Rrazor. Informally, a subset-minimal set R ⊆ CR of rules is chosen such that Pis R cast to the are then accepted as CR-answer sets of P . Formally, P and CR are compiled into a single ASP syntax; the answer sets of Pabductive logic program where an abducible atom appl(r) is used for the each rule r from CR to control (and be aware of) its applicability; a minimal set of abducibles may be assumed to be true without further justification. For simplicity, however, we use the abstract description from above.is coherent, where RThe CR-Prolog approach is different from semi-stable and SEQ-model semantics in several respects. First, it provides a (syntactic) inconsistency management strategy, not a semantic treatment of incoherence at the semantic level of interpre-tations. Second, it remains with the user to ensure coverage of all cases of incoherence; this bears risk that some cases are overlooked. On the other hand, depending on the application it might be preferred that this is pointed out.Even if CR consists of all atoms in P , CR-answer sets and SEQ-models may disagree, as adding facts, as done in this case by CR-Prolog, is stronger than blocking negated atoms as in semi-stable and SEQ-models semantics (which then admits more answer sets).(cid:16)Example 48. Consider the program P = {a ← not a; c ← not b; b ∨ c ← a}. This program has the unique SEQ-model (c, ac); i.e., c is true, b is false, and a is believed true.+←; rb : b +←} and assume that there are no preferences. Then R(cid:16) = {ra} is the single minimal (cid:16) = {a ← not a; c ← not b; b ∨ c ← a; a ←} has two answer sets, viz. Let CR = {ra : a subset of CR such that Pis coherent, and P{a, c} and {a, b}, which are then both CR answer sets.+←; rc : c(cid:16) = P ∪ R(cid:16)The program in the previous example shows that adding a as a fact is stronger than blocking the use of a under negation. We remark that this similarly applies to the generalized stable model semantics [30], in which abducible facts may be added to the program P in order to obtain a stable model.8.2.3. Well-founded semanticsThe most prominent approximation of the stable semantics is the well-founded semantics (WFS) [56]. It assigns each normal logic program P , in our terminology, an HT-model WF(P ) = (I, J ) (called the well-founded model) such that all atoms in I are regarded as being true and all atoms not in J being false; all the remaining atoms (i.e., those in gap(WF(P ))) are regarded as undefined (rather than possibly true, as in HT-logic). Intuitively, the false atoms are those which can never become true, regardless of how the undefined atoms will be assigned. Extending WFS to disjunctive program is non-trivial and many proposals have been made, but there is no general consensus on the “right” such extension (see [57,13] for more recent proposals); we comment on the proposal of Cabalar et al. [13] in the subsection on partial stable models below.The well-founded semantics has many different characterizations; among them is the well-known alternating fixpoint-characterization, cf. [55,5]: for normal constraint-free programs P , the operator γP ( X) = LM(P X ), X ⊆ (cid:3) is anti-monotonic, where LM(Q ) denotes the unique minimal model of Q (which for Q = P X exists). We then have WF(P ) = (I, J ) where IP ( X) = γP (γP ( X)), and J = γP (I). Furthermore, the well-founded model is is the least fixpoint of the monotonic operator γ 2the least partial stable model (see Section 8.2.4 below); it has been characterized in the logic HT2 in terms of the partial equilibrium model that leaves the most atoms undefined [14].With regard to Section 8.1, WFS does not satisfy minimal undefinedness, but justifiability and naturally the CWA prin-ciple. It does not satisfy answer set coverage (D1) nor congruence (D2) (even if a single answer set exists), but coherence (D3). Roughly speaking, the well-founded model remains agnostic about atoms that are involved in cycles through negation whose truth value cannot be determined from other parts of the program, and it propagates undefinedness. This may effect that all atoms remain undefined; e.g., the program in Example 22 has this property.It is well-known that the well-founded model WF(P ) = (I, J ) approximates the answer sets of P in the sense that I ⊆ M ⊆ J for each answer set M of P ; it is thus geared towards approximating cautious inference of literals from all answer 248G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271sets of P , rather than towards approximating individual answer sets. If no answer set exists, WFS avoids trivialization and still yields a model; however, the notion of undefinedness and the associated propagation may lead to less informative results, as shown in Example 4.SEQ-refinement of the WFS. A closer look at the WFS reveals that the SEQ-model semantics refines it in the following sense.Notation. Let for HT-interpretations M = ( X, Y ) and Mrefinement of Mthat results by assigning atoms in gap(M(cid:16)) either true of false.12(cid:16)) denote M (cid:26) M(cid:16) ⊆ X and Y ⊆ Y, i.e., M is a (cid:16) = ( Xthat X(cid:16), Y(cid:16)(cid:16)(cid:16)Recall that an HT-interpretation ( X, Y ) of a program P is h-minimal, if no HT-model ( Xnormal P , this means that X is the least model of P Y .(cid:16), Y ) exists such that X(cid:16) ⊂ X ; for Proposition 21. Let M = ( X, Y ) be an h-minimal model of a (constraint-free) normal program P . If gap(M) ⊆ gap(WF(P )), then M (cid:26) WF(P ), i.e., M is a refinement of the well-founded model of P .Note that this proposition is not immediate as we just compare gaps, not models themselves. The result follows from some well-known properties of WF(P ) and its relationship to the answer set semantics.First, as already mentioned above, WFS is an approximation of the stable semantics:Lemma 2. For every equilibrium (stable) model M = (Y , Y ) of P , it holds that M (cid:26) WF(P ).Furthermore, WF is such that by making yet unassigned atoms true, the values of the already assigned atoms are not affected. That is,Lemma 3. For every set G ⊆ gap(WF(P )), it holds that WF(P ∪ G) (cid:26) WF(P ).Intuitively, this is because for each atom a outside gap(WF(P )), a rule already fires resp. all rules are definitely not applicable. Next, h-minimality allows for unsupported atoms (the gap). By making them facts, we get an answer set:Lemma 4. If M = ( X, Y ) is a h-minimal model of P , then M(cid:16) = (Y , Y ) is an answer set of P(cid:16) = P ∪ gap(M).Indeed, X is the least model of P Y , so each atom in X can be derived from P Y ; by adding gap(M) = Y − X , all atoms of Y(cid:16) Y , and clearly no proper subset can be derived.can be derived from P Y ∪ gap(M) = PArmed with these lemmas, we now prove the proposition.Proof of Proposition 21. Let M = ( X, Y ) be a h-minimal model of P such that gap(M) ⊆ gap(WF(P )), and let WF(P ) = (I, J ). (cid:16)) (cid:26) WF(P ). By Lemma 4, N = (Y , Y ) is an answer set of PAs refinement is transitive, we obtain N (cid:26) WF(P ); it follows that Y ⊆ J .(cid:16) = P ∪ gap(M). By Lemma 2, N (cid:26) WF(P(cid:16)), and by Lemma 3, WF(PRegarding X , by the alternating fixpoint characterization of WF(P ) we have I = LM(P J ), and thus WF(P ) is a h-minimal model of P ; as M is a h-minimal model of P , we have X = LM(P Y ). As γP (I) = LM(P I ) is anti-monotonic and Y ⊆ J , it follows that X ⊇ I .Thus, we get M = ( X, Y ) (cid:26) (I, J ) = WF(P ). This proves the proposition. (cid:2)From this proposition, we obtain a refinement result for arbitrary normal programs, i.e., programs that may contain is the constraint-free ; otherwise, WF(P ) does not exist. Note that each constraint r in P must have a false body −(r) is true in WF(P ) (this can be seen from the constraints. For such a program P , we define its well-founded model as WF(P ) = WF(Ppart of P , if WF(Pin WF(P ), i.e., either some bi ∈ Balternating fixpoint characterization).+(r) is false in WF(P ) or some c j ∈ B(cid:16)), where P(cid:16)) |= P \ P(cid:16)(cid:16)Corollary 11 (of Proposition 21). Every normal program P such that WF(P ) exists has a SEQ-model M such that M (cid:26) WF(P ). In fact, every SEQ-model M of P such that gap(M) ⊆ gap(WF(P )) satisfies M (cid:26) WF(P ).Proof. Indeed, SEQ-models are special h-minimal models (global gap-minimization), so the result follows from Proposi-tion 21 and the fact that WF(P ) = WF(Pis the constraint-free part of P . (cid:2)(cid:16)) = (I, J ) is h-minimal (as I = LM(P J ) = LM(P(cid:16) J )), where P(cid:16)Note, however, that not every SEQ-model refines the well-founded model. E.g., take P = {a ← not a, not b}. Then WF(P ) = (∅, {a}) but the SEQ-models are M1 = (∅, {a}) and M2 = (∅, {b}), and M2 has a gap outside the gap of WF(P ).12 That is, M (cid:26) M(cid:16)iff M(cid:16) ≤p M, where ≤p is the precision ordering.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271249If desired, one can easily restrict the SEQ-models of a program P to those which refine its well-founded model WF(P ) =(I, J ), by replacing P withP wf = P ∪ I ∪ {← A | A ∈ (cid:3) \ J }.Note that WF(P wf ) exists whenever WF(P ) exists. We then obtain the following result.Proposition 22. For every normal program P such that WF(P ) exists, SEQ(P wf ) = {M ∈ SEQ(P ) | gap(M) ⊆ gap(WF(P ))}.By combining Corollary 11 and Proposition 22, we get a paracoherent way to refine the well-founded semantics for query answering, which coincides with the answer set semantics for coherent programs and provides in general more informative results and reasoning by cases (see Examples 4 and 5).8.2.4. Partial stable model semanticsP-stable (partial stable) models, which coincide with the 3-valued stable models of [47], are one of the best known approximation of answer sets. Like the well-founded model, P-stable models can be characterized in several ways (cf. [19]); with respect to equilibrium logic, Cabalar et al. [14] semantically characterized P-stable models in the logic HT2 in terms of partial equilibrium models. For the concerns of our discussion, we use here a characterization of P-stable models ( X, Y ) in terms of the multi-valued operator ˆγP ( X) = MM(P X ) as the HT-interpretations ( X, Y ) such that Y ∈ ˆγP ( X) and X ∈ ˆγP (Y ); this characterization is easily obtained from [19]. In particular, for normal programs WF(P ) is a P-stable model of P (and in fact the least refined such model w.r.t. (cid:26)), and every answer set M of P (as M = LM(P M )) amounts to a P-stable model (M, M) of P ; in this vein, according to Cabalar et al. [13,14] the well-founded models of a disjunctive program P are the least refined P-stable models M of P (i.e., no P-stable model M); however, no well-founded model might exist.(cid:16) (cid:12)= M of P exists such that M (cid:26) M(cid:16)The P-stable models, while more fine-grained than the well-founded model, behave similarly with regard to the proper-ties in Subsection 8.1 and the properties (D1)–(D3) in the Introduction. Among the refinements of P-stable models in [19], the one that is closest in spirit to semi-stable and SEQ-models are the L-stable models, which are the P-stable models that leave a minimal set of atoms undefined.In fact, L-stable models satisfy all properties in Subsection 8.1 and (D1)–(D3), with the exception that coherence (D3) fails for disjunctive programs, as such programs may lack a P-stable model, and thus also an L-stable model.Example 49. The programP = {a ← not b; b ← not c; c ← not a; a ∨ b ∨ c }(16)has no P-stable models, while it has multiple SEQ-models, viz. (a, ac), (b, ab), and (c, bc), which coincide with the SST -models. Intuitively, one of the atoms in the disjunctive fact a ∨ b ∨ c, say a, must be true; then c must be false and in turn b must be true. The resulting (total) interpretation (ab, ab), however, does not fulfill that {a, b} is a minimal {a,b} = {b ←; a ∨ b ∨ c}. With a symmetric argument for b and c, we conclude that no P-stable model of P exists. model of PHowever, by adopting in addition that c is believed true, we arrive at the SEQ-model (a, ac).The main difference between that L-stable semantics and semi-stable resp. semi-equilibrium semantics is that the former takes—like P-stable semantics—a neutral position on undefinedness, which in combination with negation may lead to weaker conclusions.For example, the program P in Example 4 has a single P-stable model, and thus P has a single L-stable model which coincides with its well-founded model; thus we cannot conclude under L-stable semantics from P that visits_barber(joe) is false.Also the program in Example 22 has a single P-stable (and L-stable) model in which all atoms are undefined, while c is true under SEQ-model semantics. Similarly, the programP = {a ← not b; b ← not c; c ← not a}(17)has a single P-stable (and thus L-stable) model in which all atoms are undefined; if we add the rules d ← a, d ← b, and d ← c to P , the new program cautiously entails under both semi-stable and SEQ-model semantics that d is true, but not under L-stable semantics.Possible SEQ-refinement of the L-stable semantics. As the SEQ-semantics refines the WFS as shown in Section 8.2.3, the natural question is whether a similar refinement property holds for L-stable models. Unfortunately this is not the case, even for normal programs without constraints (which always possess L-stable models); this is witnessed e.g. by the following example.Example 50. Consider the program(cid:8)P =a ← not b, d; b ← not a, d; c ← not cd ← not c; d ← not a, not e; d ← not b, not e(cid:9)∪ {e ← not a, not b}.250G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Intuitively, the rules with heads a and b make a guess a or b, if d is true; c must be undefined as there is no other way to derive c than from its negation; d is true if one of a and b is false but not both, i.e., we have a guess for a and b. Thus proper guessing on a and b makes the gap smallest.Under WFS, all atoms must be undefined as each atom occurs in P only on cycles with negation. Furthermore, N1 =(ad, acd) and N2 = (bd, bcd) are L-stable models, because they are partially stable and no smaller gap than gap(N1) =gap(N2) = {c} is possible. There is no further L-stable model (d would need to be true in it, which means that e must be false and hence either a false or b false; thus we end up with N1 or N2), and actually also no other P-stable model.As one can check, M = (e, ec) is a h-minimal model of P , and gap(M) = {c}. Thus M is an “additional” h-minimal model of P , and M does neither refine N1 nor N2.If we slightly extend P in (17) to(cid:16)},(cid:16) ← not c, not c(cid:16) = P ∪ {cP(18)then we get a similar situation. Again, as c only occurs in the head of the rule c ← not c, it must be undefined in each (cid:16)(cid:16)partial stable model, and hence the same follows also for cd) are (cid:16)(cid:16)(cid:16)}. On the other hand, M is also an h-minimal model of 2) = {c, c1) = gap(Nthe L-stable models of P(cid:16)P, and gap(M) = {c}; thus M is the unique SEQ-model of P, and the models are unrelated.. Thus we obtain that N, and they have gap(N= (bd, bcc= (ad, accd) and N(cid:16)2(cid:16)1(cid:16)(cid:16)(cid:16)Possible SEQ-refinement of disjunctive P-stable models. The previous example showed that SEQ-models with smaller gaps than L-stable models do not necessarily refine them. However, as they refine always some P-stable model (the WFM) of a normal program, it does not rule out that they refine some P-stable model of a disjunctive program P , and in particular a well-founded model (i.e., a least refined (w.r.t. (cid:26)) P-stable model). It appears that this refinement property does not hold.Example 51. Consider the following variant of the program on line (16) in Example 49:P = {a ← not b; b ← not c; c ← not a; a ∨ b ∨ c ← d; d ∨ e; d ← e, not d }.By the disjunctive fact d ∨ e, either d or e must be true in each h-minimal model (and thus in each P-stable resp. SEQ-model of P ). If d is true, then the clauses containing a, b, c, do not admit a P-stable model; if e is true, the single P-stable model is M = (e, abcde). On the other hand, the SEQ-models of P are M1 = (ad, acd), M2 = (bd, abd), and M3 = (cd, bcd); note that each h-minimal model of P in which e is true must have d and some atom from a, b, c believed true but not true, and thus cannot be gap-minimal. As each Mi has smaller gap than M but does not refine it, the refinement property does not hold.Note that the example shows even more: different from normal programs, for disjunctive programs the SEQ-models do not refine the intersection of all P-stable models (i.e., the HT-interpretation ( X, Y ) where X resp. (cid:3) \ Y is what is true resp. false in every P-stable model of P ). Thus in conclusion, for disjunctive programs, P-stable and SEQ-models are in general unrelated.8.2.5. Further semanticsThe regular model semantics [59] is another 3-valued approximation of answer set semantics that satisfies least unde-finedness and foundedness, but not the CWA principle. However, it is classically coherent (satisfies (D3)). For the odd loop program P in (17) the regular models coincide with the L-stable models; the program Pin (18) has the regular models {a}, {b}, and {c}. While regular models fulfill answer set coverage, they do not fulfill congruence. For more discussion of 3-valued stable and regular models as well as many other semantics coinciding with them, see [19].(cid:16)Revised stable models [43] are a 2-valued approximation of answer sets; negated literals are assumed to be maximally true, where assumptions are revised if they would lead to self-incoherence through odd loops or infinite proof chains. For example, the odd-loop program P in (17) has three revised stable models, viz. {a, b}, {a, c}, and {b, c}. The semantics is only defined for normal logic programs, and fulfills answer set coverage (D1) but not congruence (D2), cf. [43]. Similarly, the so called pstable models in [39], which should not be confused with P-stable models, have a definition for disjunctive programs however, satisfy answer set coverage (D1) (but just for normal programs) and congruence (D2) fails. Moreover, every pstable model of a program is a minimal model of the program, but there are programs, e.g. P in (17) again, that have models but no pstable model, thus classical coherence does not hold.8.3. ModularityTo our knowledge, modularity aspects of paracoherent semantics have not been studied extensively. A noticeable excep-tion is [19], which studied the applicability of splitting sets for several partial models semantics, among them the P-stable and the L-stable semantics that were already considered above. While for P-stable models a splitting property similar to the one of answer sets holds, this is not the case for L-stable models, due to global gap-minimization however, an analogue to Theorem 7, with L-stable models in place of SCC-models is expected to hold.Huang et al. [28] showed that hybrid knowledge bases, which generalize logic programs, have modular paraconsistent semantics for stratified knowledge bases; however, the semantics aims at dealing with classical contradictions and not with incoherence in terms of instability through cyclic negation.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271251Pereira and Pinto [45], using a layering notion that is similar to SCC-split sequences, introduce layered models (LM) semantics which is an alternative semantics that extends the stable models semantics for normal logic programs. The layered models of a program P are a superset of its answer sets, and this inclusion can be strict even if P is coherent; thus, property (D2) does not hold. In a sense, the CWA is relaxed more than necessary in the model construction process.Faber et al. [20] introduced a notion of modularity for answer set semantics, based on syntactic relevance, which has paracoherent features. However, this notion was geared towards query answering rather than model building, and did not incorporate gap minimization at a semantic level.Finally, we look at models related to a splitting sequence. Not every SEQ-model of P that is a refinement of WF(P ) is a SCC-model of P ; we might “lose” SEQ-models by splitting. E.g.,P = { a ← not a; b ← not b, not a; c ← not b, not c }has the SCCs C1 = {a}, C2 = {b} and C3 = {c}, and WF(P ) = (∅, abc); the single SCC-model of P is M = (∅, ac), while P(cid:16) = (∅, ab); the latter is lost along the splitting sequence S = (a, ab, abc), as restricted to C1, Mhas a further SEQ-model Mhas smaller gap (viz. {a}) than M(whose gap is {a, b}). However, we get an analogue to Corollary 11 (recall that normal programs with constraints lack a well-founded model if the constraints are violated).(cid:16)Proposition 23. Let P be a normal program (possibly containing constraints) such that WF(P ) exists and let S be an arbitrary splitting sequence of P . Then P has some SEQS -model M such that M (cid:26) WF(P ), and moreover every SEQS -model M of P such that gap(M) ⊆gap(WF(P )) satisfies M (cid:26) WF(P ).The reason is that the well-founded semantics satisfies modularity with respect to splitting sequences. This is a conse-quence of the following lemma.Lemma 5. For every splitting set S of a normal program P (possibly containing constraints) such that WF(P ) exists, it holds that1. WF(P )|S is a partial stable model of b S (P ) (recall that |S denotes restriction to S), and2. WF(P ) = WF(t S (P ) ∪ I ∪ { A ← not A | A ∈ J \ I}), where WF(b S (P )) = (I, J ).This lemma in turn follows from Proposition 12 in [19], which states this property for partial stable models of constraint-free (even disjunctive) programs, and WF(P ) is the least partial stable model; note also that constraints in P merely determine the existence of WF(P ) but do not influence the truth valuation of atoms.An immediate corollary to Proposition 23 is that normal programs P for which the well-founded model exists and the SCC-model semantics is applicable have some SCC-model that refines the well-founded model WF(P ), and moreover that every SCC-model of P which adopts some the undefined atoms in WF(P ) as believed true refines WF(P ); the same holds for MJ C-models.We finally note that we can, as in the case of all SEQ-models of P , restrict the split SEQ-models of P to those which refine WF(P ) by adding respective constraints; recall that P wf = P ∪ I ∪ {← A | A /∈ J } where WF(P ) = (I, J ).Proposition 24. Let P be a normal program (possibly containing constraints) such that WF(P ) exists. Then for every splitting sequence S of P , it holds that SEQS (P wf ) = {M ∈ SEQS (P ) | gap(M) ⊆ gap(WF(P ))}.Proof. [Sketch] By Proposition 22, SEQ(P wf ) = {M ∈ SEQ(P ) | gap(M) ⊆ gap(WF(P ))}. The result can then be shown by induction along the split sequence S, using Theorem 5 and Lemma 5. (cid:2)As a consequence of Propositions 23 and 24, in particular the SCC- and MJ C-models of a normal program can be easily restricted such that they refine its well-founded semantics in a paracoherent manner, as discussed at the end of Subsection 8.2.3.9. Further issues9.1. Infinite splitting sequencesAs mentioned earlier, we concentrate in this article on finite splitting sequences; however split SEQ-models can be easily extended to infinite splitting sequences S = (S1, S2, . . . , S i, . . .). To this end, we can define the split-SEQ models of SEQS[1..i](P ), where S[1..i] = (S1, . . . , S i) is the initial segment of P relative to a splitting sequence S by SEQS (P ) =S of length i. Indeed, any extension of the finite sequence S[1..i] by some S i+1 may lead to the loss of SEQ-models; on the other hand, after passing S i , no new model candidates relative to S i will be encountered.(cid:16)∞i≥1252G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2719.2. User-defined subprograms and focusingIn the previous sections, we were considering the issue of paracoherence at a principled level without further input from the user. Important such input could be, for example, an intended modular structure of the program and/or a focus of attention when looking for a paracoherent model. As we briefly discuss, our notions and results can be easily extended to such settings.9.2.1. User-defined subprogramsIn the design of an ASP program, users often proceed by defining (implicitly) subprograms that are composed in a hierarchically manner to a global program. That is, the latter is of the form P = P 1 ∪ · · · ∪ P m where each P i is a subprogram that “defines” atoms in a signature (cid:3)i , such that (cid:3) = (cid:3)1 ∪· · · ∪(cid:3)m, where the (cid:3)i are pairwise disjoint, and S = (S1, . . . , Sm), j≤i (cid:3) j , 1 ≤ i ≤ m, is a splitting sequence of P .13 A particular example are stratified logic programs, where each P i is S i =meant to define atoms (cid:3)i that form the i-th layer.(cid:10)Example 52. A more elaborated version of the company program in Example 24 could have more complex subprograms that define different categories of workers (core staff, employees), and social security regulations; the current program P just contains single-rule definitions of the concepts. Note that P is stratified, and it is reasonable to expect that more elaborated versions will also have this property.However, the programs P i may, in general, also include unstratified negation.Example 53. The barber program in Example 3, extended with a rule shaved( X) ← shaves(Y , X) might be a subprogram P 1defining shaved, and P 2 a subprogram on top that classifies persons, e.g., with rulesboy(X) ← male(X), not shaved(X);adult(X) ← shaved(X).Example 54. As mentioned earlier in Section 5, the program P composed of P 1 being the party program in Example 2and P 2 = {← balcony, #count({ X : go( X)}) > 3; balcony ∨ living_room} could be used to determine the location for the party. Each of the SEQ-models of the given P 1 would be extended to two SEQ-models of P , one with balcony true and one with living_room true, as the constraint is not violated.Exploiting the notions of Section 5, we can readily define the SEQ-models of P , viewing subprograms as atomic blocks, as the SEQS -models of P for the sequence S above. However, if subprograms P i and P j are mutually independent, i.e., (cid:3)ihas empty intersection with each rule body in P j and vice versa, the order of P i and P j may matter for the result. As in the case of SCCs, we can make the semantics robust by requiring that SEQ S (P ) = SEQSπ (P ) for every Sπ = (Sπ (1), . . . , Sπ (m))where π (1), π (2), . . . , π (m) is a permutation of 1, . . . , m, and Sπ (i) = (cid:3)π (1) ∪ · · · ∪ (cid:3)π (i), 1 ≤ i ≤ m; then, every constraint-free program P has well-defined subprogram SEQ-models that are induced by {(cid:3)1, . . . , (cid:3)m}. Furthermore, this can be extended to programs P that have no cross-module constraints, i.e., no constraints r that have nonempty intersection with “incomparable”14 (cid:3)i and (cid:3) j , and one can define maximal joinable subprograms SEQ-models analogous as for SCCs.Note that the SCCs C1, . . . , Cm of a program P can be viewed as atom sets (cid:3)i = Ci defined by subprograms P i that con-tain all rules r from P with nonempty head contained in (cid:3)i . The subprogram SEQ-models of P induced by {C1, . . . , Cm}coincide then with the SCC-models of P . Thus, we can view the “syntactic” SCC-models as extremal case of a user defini-tion with no information about modules.Furthermore, we can reduce the subprogram semantics of program P w.r.t. (cid:3)1, . . . , (cid:3)m to SCC-semantics of another = P ∪ {a ← pi, a; pi ← pi, a | a ∈ (cid:3)i}. program PClearly, the rules added to P i are tautologic and thus have no semantic effect on (cid:3)i ; however they enforce that all atoms in (cid:3)i are in the same SCC of Pby a simple rewriting. For each P i , we use a fresh atom pi and let P∪ · · · ∪ P(cid:16) = P(cid:16)i(cid:16)(cid:16)m.(cid:16)19.2.2. FocusingAnother aspect is focusing the use of paracoherence at the semantic level. One natural way to incorporate this is to constrain the atoms that can be believed true without further justification to a set B of atoms. This corresponds to adopting a set of assumptions or hypotheses in abduction. The effect of such focusing is that simply all SEQ-models ( X, Y ) of a program are pruned which do not satisfy gap( X, Y ) ⊆ B.Example 55. Let us reconsider the party visit program in Example 2 again. It may perfectly make sense to question for each person whether we are comfortable with adopting an unjustified belief. If we require provable evidence for Mark and Peter, then B = {go(John), go(Bill)} and from the original SEQ-models M2 = ({go(John)}, {go(John), go(Bill)}) remains. If on the 13 For technical reasons, we assume here w.l.o.g. that in each constraint r in P i some atom from (cid:3)i occurs.14 That is, (cid:3)i ⊆ Sπ (k) ∧ (cid:3) j (cid:2) Sπ (k) and (cid:3) j ⊆ Sπ (cid:16)(k(cid:16)) ∧ (cid:3)i (cid:2) Sπ (cid:16)(k(cid:16)) for some π , π (cid:16), k, k.(cid:16)G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271253other hand, we would simply require provable evidence for all persons but Mark, then the SEQ-model M1 = (∅, {go(Mark)})remains.Example 56. In the company Example 24, it is natural to put a focus on B = {has_social_sec(sam)}, as it does not make sense to believe the (syntactic) atom ssnr(sam, sam); furthermore, even if we would have considered a modeling in which realistic social security numbers are considered, to believe any particular social security number (SSNR) out of a (big) range might be too strong an assumption; believing has_social_sec(sam), which would be implied by the former releases us from adopting a particular SSNR.In general, such pruning can be easily accomplished. The computational complexity of the reasoning tasks that we considered in Section 7 (Tables 1 and 2) remains the same except that Problem COH is (cid:3) p2 -complete for disjunctive and disjunctive stratified programs (the problem amounts to deciding whether some h-minimal HT-model ( X, Y ) of the program P exists such that gap( X, Y ) ⊆ B, which is in (cid:3) p2 ; the matching hardness follows immediately from the results on answer set existence in [16]).9.3. Language extensionsAs already mentioned, semi-stable semantics has originally been developed as an extension to p-minimal model seman-tics [49], a paraconsistent semantics for extended disjunctive logic programs, i.e., programs which besides default negation also allow for strong (classical) negation. A declarative characterization of p-minimal models by means of frames was given by Alcantara et al. [1], who coined the term Paraconsistent Answer-set Semantics (PAS) for it. This characterization has been further simplified and underpinned with a logical axiomatization in [37] by using Routley models, i.e., a simpler possible worlds model.Our characterizations for both, semi-stable models and semi-equilibrium models, can be easily extended to this setting if they are applied to semantic structures which are given by quadruples of interpretations rather than bi-interpretations, respectively to Routley here-and-there models rather than HT-models. Intuitively, this again amounts to considering two ‘worlds’, each of which consists of a pair of interpretations: one for positive literals (atoms), and one for negative liter-als (strongly negated atoms). The respective epistemic transformations are unaffected except for the fact that literals are considered rather than atoms. One can also show for both semantics that there is a simple 1-to-1 correspondence to the semi-stable (resp. semi-equilibrium) models of a transformed logic program without strong negation: A given extended pro-(cid:16) | a ∈ (cid:3)} without strong negation by replacing each negative literal of gram P is translated into a program Pthe form −a by aover (cid:3) ∪ {a. If (I, J ) is a semi-stable (semi-equilibrium) model of P(cid:16) ∈ J })(cid:16) ∈ I}, J ∩ (cid:3), {−a | a(I ∩ (cid:3), {−a | a, then(cid:16)(cid:16)(cid:16)is a semi-stable (semi-equilibrium) model of P . Note that semi-stable (semi-equilibrium) models of extended logic programs obtained in this way generalize the PAS semantics, which means that they are paraconsistent as well as paracoherent. Logi-cally this amounts to distinguishing nine truth values rather than three, with the additional truth values undefined, believed false, believed inconsistent, true with contradictory belief, false with contradictory belief, and inconsistent. The computational com-plexity for extended programs is the same.Compared to [49], we have confined here to propositional programs, as opposed to programs with variables (non-ground programs). However, respective semantics for non-ground programs via their grounding are straightforward. Alternatively, in case of semi-equilibrium models one can simply replace HT-models by Herbrand models of quantified equilibrium logic [41]. Similarly for the other semantics, replacing interpretations in the semantic structures by Herbrand interpretations over a given function-free first-order signature, yields a characterization of the respective models.Finally, as equilibrium logic is a conservative extension of answer sets of programs consisting of rules to the full proposi-tional language, the notion of SEQ-model immediately extends to richer classes of programs with propositional connectives, e.g., to programs with negation in the head [34] and nested logic programs [33]. Furthermore, it can also be easily extended to programs with weight constraints [22], aggregates [21], or more general external atoms [18], and to hybrid knowledge bases [12] (for the latter, see [23]).9.4. Parametric merging semanticsBy the results of Section 7, tractable merging policies that ensure classical coherence (D3) will sometimes merge more components than necessary. To deal with the issues (1) and (2) in Section 6.2, i.e., with all cross-constraints and depen-dence, a parametric approach that gradually merges more SCCs seems attractive. We briefly outline here one possible such approach, which merges components within bounded distance.Denote for every C ∈ SCC(P ) by Dk(C) the set of all descendants of C in SG(P ) within distance k ≥ 0; then we may proceed as follows.1. Create a graph Gk with a node vr for each constraint r in P , which is labeled with the set(cid:13) (cid:11)(cid:14)λ(vr) = clp{Dk(Ci) | Ci ∈ SCC(P ), Ci ∩ At(r) (cid:12)= ∅}254G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271of SCCs; that is, all SCCs within distance k to a SCC Ci that intersects with r are collected into one set, and on the resulting collection D of SCCs a function clp(D) is applied. The latter closes D with respect to SCCs C that are on some path between members C1 and C2 of D in SG(P ).2. Merge then nodes vr and vr(cid:16) (and their labels, using clp ) such that λ(vr) ∩ λ(v3. After that, create a node v for each SCC C that does not occur in any label of the graph, and set λ(v) = {C};4. add an edge from v to vand SG(P ) has some edge (Ci, C j) where Ci ∈ λ(v) and C j ∈ λ(v(cid:16)r) (cid:12)= ∅ as long as possible., if v (cid:12)= v(cid:16)).(cid:16)(cid:16)The resulting graph Gk is acyclic and distinct nodes have disjoint labels. Similar as for JG(P ), any topological ordering ≤λ(v) of the SCCs they contain); of Gk induces a splitting sequence S≤ (via the node labels λ(v), which are taken as union thanks to an analog of Theorem 8, one can define the Mk-models of P as Mk(P ) = SEQS≤ (P ) for an arbitrary ≤.For k = 0, we have Dk(C) = {C} and thus the node vr in the initial graph G 0 contains in its label λ(vr ) the SCCs that intersect r; the final graph G 0 is such that each J x <∈ MJ C(P ) is included in some node label (i.e., J ⊆ λ(v) for some MJ C(P ) ⊆ M0(P ) holds. As clearly Mk(P ) ⊆ Mk+1(P ) holds for every k ≥ 0, and Mk(P ) = SEQ(P )node v). Hence, MMJ C(P ) and SEQ(P ) which eventually establishes for large enough k; as holds, we have a hierarchy of models between M(D3); however, the results of Section 7 imply that predicting the least k such that Mk(P ) (cid:12)= ∅ is intractable.(cid:10)Other relaxed notions of models (using different parameters for cross-constraints and direct dependency) are conceivable; we leave this for future study.10. ConclusionIn this paper, we have studied paracoherent semantics for answer set programs, that is, semantics that ascribes mod-els to (disjunctive) logic programs with non-monotonic negation even if no answer set (respectively stable model) exists, due to a lack of stability in models caused by cyclic dependency through negation, or due to constraints. Ideally, such a semantics approximates the answer set semantics faithfully and delivers models whenever possible, as expressed by the properties (D1)–(D3); this can be beneficially exploited in scenarios where unexpected inconsistency arises and one needs to stay operational, such as in inconsistency tolerant query answering. Among few well-known semantics which feature these properties are the semi-stable model semantics [49], and the novel semi-equilibrium model semantics, which amends the semi-stable model semantics by eliminating some anomalies. For both semantics, which are defined by program transfor-mations, we have given model-theoretic characterizations in terms of bi-models and HT-models, respectively; in particular, semi-equilibrium models relax the notion of equilibrium models, which reconstruct answer sets in HT-logic, by allowing for minimal sets of unsupported assumptions. We have then refined the semi-equilibrium model semantics with regard to modular program structure, by defining models via splitting sets and splitting sequences; this constrains the set of semi-equilibrium models, in a way that is amenable to modular bottom up evaluation of programs. For that, we have presented canonical semi-equilibrium models for which, in analogy to the classical Stratification Theorem for logic programs, the par-ticular evaluation order does not matter, and we have identified modularity properties for these semantics that allow for flexible rearrangement in evaluation.Furthermore, we have characterized the complexity of major reasoning tasks of all these semantics, and we have com-pared semi-equilibrium semantics to related proposals for paracoherent semantics and approximations of answer sets in the literature. Notably, it appeared that semi-equilibrium models coincide with evidential stable models in [51]; our semantic and computational results thus carry over to them. Different from other formalisms such as CR-Prolog [4] or generalized stable models [30], unsupported assumptions in semi-stable and semi-equilibrium models serve to block rules but not to establish positive evidence for deriving atoms from rules. Furthermore, we have shown that the well-founded model of a normal logic program is refined by semi-equilibrium models, and that the program can be easily modified such that all semi-equilibrium models refine the well-founded model; the same holds also for canonical semi-equilibrium models. This provides a paracoherent way to refine the well-founded semantics for inconsistency-tolerant query answering, which co-incides with the answer set semantics for coherent programs and is in general more informative than the well-founded semantics and supports reasoning by cases, being as close to answer sets as possible.As for computation, an attractive feature is that canonical semi-equilibrium semantics allows for easy switching from a coherent (answer set) mode to a “paracoherent” evaluation mode in the bottom up evaluation of a program, if incoherence is encountered. And notably, this is possible also for disjunctive logic programs.10.1. Open issues and outlookSeveral issues remain for future work and investigations. A natural issue is to introduce paracoherence for further lan-guage extensions besides strong negation and non-ground programs. Fortunately, the generic framework of equilibrium logic makes it easy to define SEQ-semantics for many such extensions, among them those mentioned in Section 9.3. It remains to consider modularity in these extensions and to define suitable refinements of SEQ-models. Particularly interesting are modular logic programs [29,15], where modules can be organized non-hierarchically and explicit (by module encapsula-tion) and implicit modularity (by splitting sets) occur at the same time. Related to the latter are multi-context systems [10], in which knowledge bases exchange beliefs via non-monotonic bridge rules; based on ideas and results of this paper, paracoherent semantics for certain classes of such multi-context systems may be devised.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271255Besides language extensions, another issue is generalizing the model selection. To this end, preference in gap mini-mization may be supported, especially if domain-specific information is available; subset-minimality is a natural instance of Occam’s razor in lack of such information. Furthermore, preference of higher over lower program components may be considered; however, this intuitively requires more guessing and hinders bottom up evaluation.On the computation side, developing efficient algorithms and their implementation remain to be done, as well as integra-tion into an answer set building framework. Currently, experimental prototypes for computing SST (P ) and SEQ(P ) based on the semantic characterizations are available. Another computation method is filtering the answer sets of the epistemic transformation P κ resp. its extension P H T or the evidential transform P, which are computed with an ASP solver. How-3 /(cid:4)Pever such simple postprocessing is not efficient in general; indeed, the (cid:3) P3 -completeness of brave/cautious reasoning, respectively, calls for better methods. An interesting issue in this context is a polynomial transformation of the evaluation of normal and hcf-programs into disjunctive ASP, which by our results is feasible.EWe have considered paracoherence based on program transformation, as introduced by Inoue and Sakama [49]. Other notions, like forward chaining construction and strong compatibility [58,35] might be alternative candidates to deal with paracoherent reasoning in logic programs; this remains to be explored.Finally, another issue is to investigate the use of paracoherent semantics in AI applications such as diagnosis, where assumptions may be exploited to generate candidate diagnoses, in the vein of the generalized stable model semantics [30], or in systems for planning and reasoning about actions based on ASP, where emerging incoherence should be meaningfully tolerated.AcknowledgementsWe would like to thank the reviewers of preliminary conference versions of parts of this paper and of this article for their helpful and constructive comments, as well as José Alferes and Tomi Janhunen for interesting discussions and suggestions. We are grateful to Diemar Seipel for pointing us to his work on evidential stable models.Appendix A. Appendix: proofsA.1. Section 3Proof of Proposition 4. Let r be a rule over (cid:3), and let (I, J ) be a bi-interpretation over (cid:3).(⇐) Suppose that (I, J ) satisfies (a), i.e., B+(r) ⊆ I and J ∩ B−(r) = ∅ implies I ∩ H(r) (cid:12)= ∅ and I ∩ B−(r) = ∅. We prove that (I, J ) |=β r, considering three cases:1) Assume that B2) Assume that J ∩ B+(r) (cid:2) I . Then (I, J ) (cid:12)|=β a, for some atom a ∈ B+(r), and thus (I, J ) (cid:12)|=β B(r) which implies (I, J ) |=β r.−(r) (cid:12)= ∅. Then (I, J ) (cid:12)|=β ¬a, for some atom a ∈ B−(r), and thus (I, J ) (cid:12)|=β B(r) which implies +(r) ⊆ I and J ∩ B−(r) = ∅. Then, since (I, J ) satisfies (a), it also holds that I ∩ H(r) (cid:12)= ∅ and I ∩ B−(r) = ∅. −(r) = ∅, we conclude that I |= B(r). Moreover, I ∩ H(r) (cid:12)= ∅ implies (I, J ) |=β H(r). Thus, +(r) ⊆ I and I ∩ B(I, J ) |=β r.3) Assume that BFrom B(I, J ) |=β r.By our assumption, one of these three cases applies for (I, J ), proving the claim.(⇒) Suppose that (I, J ) |=β r. We prove that (I, J ) satisfies (a), distinguishing two cases:1) Assume that (I, J ) (cid:12)|=β B(r). Then either (I, J ) (cid:12)|=β a, for some atom a ∈ B−(r) (cid:12)= ∅, which implies that (I, J ) satisfies (a).+(r) (cid:2) I or J ∩ BHence, B2) Assume that (I, J ) |=β H(r) and I |= B(r). Then I ∩ H(r) (cid:12)= ∅ and I ∩ B+(r), or (I, J ) (cid:12)|=β ¬a, for some atom a ∈ B−(r). −(r) = ∅, and thus (I, J ) satisfies (a).By our assumption, one of the two cases applies for (I, J ), which proves the claim. (cid:2)Proof of Proposition 5. Let P be a program over (cid:3). Part (1). First, let (I, J ) be a bi-model of P . We prove that (I, J )κ,P |= P κ .. Suppose that (cid:16)) ⊆ I implies (cid:16)) ⊆ (I, J )κ,PTowards a contradiction assume the contrary. Then there exists a rule r−(ris not transformed, i.e., r(cid:16)) (cid:12)= ∅ (recall that B(cid:16), by Proposition 4 we conclude that B(cid:16)) = ∅). By construction (I, J )κ,P restricted to (cid:3) coincides with I . Therefore, Bin P κ , such that (I, J )κ,P (cid:12)|= r(cid:16) ∈ P and B−(r(cid:16)) = ∅. Since (I, J ) |=β r(cid:16)+(r+(r(cid:16)(cid:16)(cid:16)) (cid:12)= ∅, i.e., (I, J )κ,P |= r(cid:16), a contradiction.is obtained by the epistemic transformation of a corresponding rule r ∈ P of the form (1), and rI ∩ H(rimplies (I, J )κ,P ∩ H(rNext, suppose that rconsider the following cases:(cid:16)– ris of the form (3): then {b1, . . . , bm} ⊆ (I, J )κ,P , which implies B(cid:16)sumption that (I, J )κ,P (cid:12)|= rthat I ∩ H(r) (cid:12)= ∅ and that I ∩ B(cid:16). By construction of (I, J )κ,P , this implies J ∩ B−(r) = ∅. Consequently, J |= B+(r) ⊆ I . Moreover, H(r(cid:16)) ∩ (I, J )κ,P = ∅ by the as-−(r) = ∅. Since (I, J ) |=β r, we also conclude −(r), ai ∈ I for some ai ∈ H(r), and I |= B(r). Note also, 256G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271– r– r– r(cid:16)(cid:16)) ∩ (I, J )κ,P = ∅.is of the form (5): in this case, (I, J )κ,P (cid:12)|= ris of the form (4): in this case, (I, J )κ,P (cid:12)|= r−(r) (cid:12)= ∅ by definition of the epistemic transformation. According to the construction of (I, J )κ,P , it follows that that Bλr,i ∈ (I, J )κ,P , a contradiction to H(r(cid:16)λr,i ∈ (I, J )κ,P implies ai ∈ I ; from the latter, again by construction, we conclude ai ∈ (I, J )κ,P , a contradiction.(cid:16)implies λr,i ∈ (I, J )κ,P and b j ∈ (I, J )κ,P . Note that b j ∈ (I, J )κ,P iff b j ∈ I . A consequence of the latter is that I (cid:12)|= B(r), contradicting a requirement for λr,i ∈ (I, J )κ,P (cf. the construction of (I, J )κ,P ).(cid:16)(cid:16), it holds that λr,k ∈ (I, J )κ,P and ai ∈ (I, J )κ,P , but λr,i /∈(I, J )κ,P . From the latter we conclude, by the construction of (I, J )κ,P , that ai /∈ I , since all other requirements for the −(r)) must be satisfied as witnessed by λr,k ∈ (I, J )κ,P . inclusion of λr,i (i.e., r ∈ P , BHowever, if ai /∈ I , then ai /∈ (I, J )κ,P (again by construction), contradiction.implies λr,i ∈ (I, J )κ,P and ai /∈ (I, J )κ,P . However, by construction is of the form (6): by the assumption that (I, J )κ,P (cid:12)|= r−(r) (cid:12)= ∅, I |= B(r), and J |= B(cid:16)This concludes the proof of the fact that if (I, J ) is a bi-model of P , then (I, J )κ,P |= P κ .Part (2). Let M be a model of P κ . We prove that β(M ∩ (cid:3)κ ) = (I, J ) is a bi-model of P . Note that by construction −(r) = ∅ and −(r) = ∅. Then r ∈ P κ , J ∩ B+(r) ⊆ (M ∩ (cid:3)) implies (M ∩ (cid:3)) ∩ H(r) (cid:12)= ∅. Since r ∈ P κ , +(r) ⊆ M, then M ∩ H(r) (cid:12)= ∅. Since r is I = M ∩ (cid:3) and J = {a | K a ∈ M}. First, we consider any rule r in P such that BI ∩ Bthis follows from the assumption, i.e., M |= P κ implies M |= r, and therefore if Bover (cid:3), this proves the claim for all r ∈ P such that B−(r) = ∅. Hence, by Proposition 4, we need to show that BIt remains to show that (I, J ) |=β r for all r ∈ P such that B−(r) (cid:12)= ∅. Towards a contradiction assume that this is not −(r) = ∅, and either [(iii)] (M ∩ (cid:3)) ∩ H(r) = ∅ or (iv) (M ∩ (cid:3)) ∩ B−(r) (cid:12)= ∅ hold +(r) ⊆ (M ∩ (cid:3)), (ii) J ∩ Bthe case, i.e., (i) B−(r) (cid:12)= ∅. Conditions (i) and (ii), together with M |= P κ , imply that λr,i is in for some r ∈ P of the form (1), such that BM, for some 1 ≤ i ≤ l (cf. the rule of the form (3) in the epistemic transformation of r). Consequently, ai is in M (cf. the corresponding rule of the form (4) in the epistemic transformation of r), and hence ai ∈ (M ∩ (cid:3)). This rules out (iii), so (iv) must hold, i.e., b j ∈ (M ∩ (cid:3)), for some m + 1 ≤ j ≤ n. But then, M satisfies the body of a constraint in P κ (cf. the corresponding rule of the form (5) in the epistemic transformation of r), contradicting M |= P κ . This proves that there exists −(r) (cid:12)= ∅ and (I, J ) (cid:12)|=β r, and thus concludes our proof of (I, J ) |=β r. Since r ∈ P was arbitrary, it no r ∈ P such that Bfollows that β(M ∩ (cid:3)κ ) is a bi-model of P . (cid:2)−(r) = ∅.Proof of Theorem 1. Let P be a program over (cid:3). The proof uses the following lemmas.Lemma 6. If M ∈ AS(P κ ), then β(M ∩ (cid:3)κ ) satisfies (i).(cid:16), J ) of P , such that I(cid:16) ⊂ I . By Proposition 5, (I(cid:16), J )κ,P } and let S = {λr,i | λr,i ∈ M}. We show that Sand λr,i /∈ S, for some r ∈ P of the form (1) and 1 ≤ i ≤ l. By the construction of (IProof. Towards a contradiction assume that M ∈ AS(P κ ) and β(M ∩ (cid:3)κ ) = (I, J ) does not satisfy (i). Then, there exists (cid:16), J )κ,P |= P κ . Note that (I(cid:16) = {λr,i |a bi-model (I(cid:16) ⊆ S. Suppose that this is not the case and assume that λr,i ∈ (I(cid:16)(cid:16)λr,i ∈ S, +(r). Consider the rule of the form (3) of the (cid:16) |= B(r), and J |= BI+(r)), and that M (cid:12)|= K c1 ∨ . . . ∨ K cn (due to epistemic transformation of r. We conclude that {b1, . . . , bm} ⊆ M (due to I |= B−(r)). But M |= P κ , hence λr,k is in M, for some 1 ≤ k ≤ l. However, considering the corresponding rule of the form J |= B(cid:16) ⊆ S holds, and since (6) of the epistemic transformation of r, we also conclude that λr,i ∈ M, a contradiction. Therefore S(cid:16), J )κ,P ⊂ M. The latter contradicts the assumption that M is an answer-set, i.e., a (Iminimal model, of P κ . This concludes the proof of the lemma. (cid:2)(cid:16) ⊂ I , it also holds that ai ∈ I and that I |= B(cid:16), J )κ ⊂ (M ∩ (cid:3)κ ), we conclude that (I(cid:16), J )κ,P , we conclude that ai ∈ I(cid:16), J )κ ⊂ (M ∩ (cid:3)κ ). Let S−(r). Since ILemma 7. If (I, J ) is a bi-model of P that satisfies (i) and (ii), then there exists some M ∈ AS(P κ ), such that β(M ∩ (cid:3)κ ) = (I, J ).(cid:16)(cid:16), J(cid:16) ⊆ I and Jimplies B(cid:16) ∩ Bof P κ , such that M(cid:16) ∩ (cid:3)κ ). Then I(cid:16) ⊂ I . We show that then (I(cid:16) ∩ B+(r) ⊆ I , and since (I, J ) is a bi-model of P , we conclude I ∩ H(r) (cid:12)= ∅ and I ∩ BProof. Let (I, J ) be a bi-model of P that satisfies (i) and (ii). If (I, J )κ,P ∈ AS(P κ ), then (c) holds since β((I, J )κ,P ∩ (cid:3)κ ) =(cid:16)(cid:16) ⊂ (I, J )κ,P . Let (I, J ). If (I, J )κ,P /∈ AS(P κ ), then there exists a minimal model, i.e. an answer set, M(cid:16) ⊂ (I, J )κ,P . Towards a contradiction, (cid:16) ⊆ J hold by construction and the fact that M(cid:16)) = β(M(I(cid:16), J ) is not a bi-model of P . Then, by (cid:16), J ) is a bi-model of P . Suppose that (Iassume that I−(r) (cid:12)= ∅. Note (cid:16) ∩ H(r) = ∅ or I−(r) = ∅, and either IProposition 4, there exists r ∈ P , such that B−(r) = ∅. The +(r) ⊆ Ithat B(cid:16) (cid:12)|= r, contradiction. Thus, latter implies I(cid:16) ⊆ J together −(r) (cid:12)= ∅. However, in this case the epistemic transformation of r is in P κ . Since J ∩ BB−(r) = ∅, we conclude that for the rule of the form (3) of the epistemic transformation of r, it holds that imply J(cid:16) |= P κ , hence λr,i{b1, . . . , bm} ⊆ M(cid:16), for some 1 ≤ i ≤ l. Considering the corresponding rule of the form (4) of the epistemic transformation of r, we also is in M(cid:16), J ) is a bi-model of P , and thus contradicts the conclude that ai ∈ M(cid:16) ⊂ J , then we obtain a contradiction with the assumption assumption that (I, J ) satisfies (i). Consequently, Ithat (I, J ) satisfies (ii). Therefore also J(cid:16) ∩ H(r) = ∅. This proves that (I(cid:16) = I . Now if J(cid:16) = J , which concludes the proof of the lemma. (cid:2)−(r) = ∅, then r is in P κ and M(cid:16) (cid:12)|= K c1 ∨ . . . ∨ K cn (due to J(cid:16) ∩ H(r) = ∅ holds. If B−(r) = ∅). Moreover M−(r) = ∅, hence I, a contradiction to I−(r) = ∅ and J), and that M+(r) ⊆ I+(r) ⊆ I(due to B, J ∩ B(cid:16) ∩ B(cid:16) ∩ B(cid:16)(cid:16)(cid:16)(cid:16)G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271257(cid:16)(cid:16)(cid:16), J(cid:16), J(cid:16), J(cid:16)(cid:16), J(cid:16) \ I(cid:16)(cid:16) = I(cid:16)(cid:16) ⊆ J. Let (I(cid:16)(cid:16) ⊂ MThe proof of Theorem 1 is then as follows.Part (1). Let (I, J ) be a bi-model of P that satisfies (i)–(iii). We prove that (I, J )κ ∈ SST (P ). By Lemma 7, we conclude that there exists some M ∈ AS(P κ ) such that β(M ∩ (cid:3)κ ) = (I, J ). It remains to show that M is maximal canonical. Towards (cid:16) ∩ (cid:3)κ ). (cid:16)) = β(Ma contradiction assume the contrary. Then, there exists M(cid:16) ⊂ J \ I . However, this By Lemma 6, (Icontradicts the assumption that (I, J ) satisfies (iii). Therefore, M is maximal canonical, and hence (I, J )κ ∈ SST (P ).(cid:16)) satisfies (i), and by construction since gap(M(cid:16) ∈ AS(P κ ) such that gap(M(cid:16)) ⊂ gap(M), it holds that J(cid:16)) ⊂ gap(M). Let (I(due to B(cid:16)(cid:16)(cid:16)(cid:16) ∩ B(cid:16)(cid:16)) = β(M(cid:16)(cid:16) ∩ B(cid:16) ∩ BPart (2). Let Iκ ∈ SST (P ). We show that β(Iκ ) is a bi-model of P that satisfies (i)–(iii). Let (I, J ) = β(Iκ ) and let M be a maximal canonical answer set of P κ corresponding to Iκ . Then, β(M ∩ (cid:3)κ ) = (I, J ) by construction, and (I, J ) satisfies (i) by Lemma 6.(cid:16)(cid:16) ∈ AS(P κ ), such that M(cid:16))κ,P and note that if M(cid:16)) is a bi-model of P , and thus by (i) it follows that I(cid:16) ⊂ J \ I . Let M(cid:16) = (I(cid:16)) ⊂ gap(M). Thus, there exists MTowards a contradiction first assume that (I, J ) does not satisfy (iii). Then there exists a bi-model (I(cid:16), J(cid:16), J(cid:16)) is not a bi-model of P . Then, by Proposition 4, there exists r ∈ P , such that B, and since (I(cid:16)(cid:16) ∩ H(r) = ∅ holds. If B(cid:16)) of P such that (cid:16) ∈ AS(P κ ), we arrive at a contradiction to (cid:16) \ I(cid:16)) satisfies (i) and J(I(cid:16)(cid:16) ∩ (cid:3)κ ). (cid:16)(cid:16), JM ∈ mc(AS(P κ )), since gap(M. Towards a contradiction, suppose that We show that (I−(r) = ∅, and either (cid:16)(cid:16), J(I(cid:16)) is a bi-model of P , we conclude (cid:16)(cid:16) ∩ H(r) = ∅ or II−(r) = ∅, then r is in P κ and (cid:16) ∩ H(r) (cid:12)= ∅ and II−(r) = ∅−(r) (cid:12)= ∅. However, in this case the epistemic transformation of r is in P κ . Since J(cid:16)(cid:16) (cid:12)|= r, contradiction. Thus, BM−(r) = ∅, we conclude that for the rule of the form (3) of the epistemic transformation (cid:16)(cid:16) ∩ Btogether imply Jand J−(r) = ∅). Moreover (cid:16)(cid:16)of r, it holds that {b1, . . . , bm} ⊆ M, for some 1 ≤ i ≤ l. Considering the corresponding rule of the form (4) of the epistemic is in MM(cid:16)) is a bi-model transformation of r, we also conclude that ai ∈ M(cid:16)) holds, which implies of P . From the assumption that (Igap(M(cid:16)(cid:16) ∩ H(r) = ∅. This proves that (I, a contradiction to I(cid:16)(cid:16)(cid:16) = I. Therefore gap(M(cid:16)(cid:16)) ⊂ gap(M), a contradiction to M ∈ mc(AS(P κ )). This proves (I, J ) satisfies (iii).−(r) (cid:12)= ∅. Note that B+(r) ⊆ I−(r) = ∅. The latter implies I(cid:16)(cid:16)(cid:16)) satisfies (i), it follows that I+(r) ⊆ I(cid:16)implies B−(r) = ∅, hence I(cid:16)(cid:16) (cid:12)|= K c1 ∨ . . . ∨ K cn (due to J(cid:16)(cid:16) |= P κ , hence λr,i+(r) ⊆ I(cid:16), J(cid:16)) satisfies (i). Since (I, J ) satisfies (iii), we conclude that JNext assume that (I, J ) does not satisfy (ii). Then, there exists a bi-model (I, J(cid:16)) satisfies (i). Otherwise, there exists a bi-model (I(cid:16)) of P , such that I(I, Jof P . To see the latter, assume that there exists a rule r ∈ P , such that B(r) ⊆ I−(r) (cid:12)= ∅. Since Jor Ibi-model of P , hence (I(I, J(cid:16) (cid:2) S (otherwise (I, JS = {λr,i | λr,i ∈ M}. It holds that Sthe form (1) and 1 ≤ i ≤ l, such that λr,i ∈ S and λr,i /∈ Sthat I |= B(otherwise (I, JHowever, since ai ∈ I , and thus ai ∈ (I, Jrule of form (6) of the epistemic transformation of r). This contradicts λr,i /∈ S(cid:16) ⊂ J . We show that (cid:16), J ) is a bi-model (cid:16) ∩ H(r) = ∅(cid:16) ⊂ J , it then also holds that J(cid:16)) is a (cid:16), J ) |=β P . The latter is a contradiction to the assumption that (I, J ) satisfies (i), proving that (cid:16))κ,P } and let (cid:16))κ,P ⊂ M, a contradiction to M ∈ AS(P κ )), i.e., there exists r ∈ P of (cid:16). From the former, since M is a minimal model of P κ , we conclude (cid:16) ⊂ J , also J, for some 1 ≤ k (cid:12)= i ≤ l(cid:16))κ,P |= P κ ). (cid:16))κ,P (cf. the respective , and thus proves that (I, J ) satisfies (ii). (cid:2)(cid:16) ∩ B(cid:16))κ,P does not satisfy the rule of form (3) corresponding to r in P κ , a contradiction to (I, J(cid:16)) of P , such that J(cid:16) ⊂ I ; but then also (I(cid:16), J ∩ B−(r) = ∅. This contradicts the assumption that (I−(r) = ∅. This implies that λr,k ∈ S(cid:16))κ,P , we conclude that λr,i ∈ (I, J(cid:16))κ,P , and since λr,k ∈ (I, J(cid:16) \ I = J \ I . Now let S+(r), ai ∈ I , and J ∩ B−(r) = ∅ and either I(cid:16) = {λr,i | λr,i ∈ (I, J−(r) = ∅. Since J), and that M(cid:16)(cid:16)) ⊆ gap(M+(r) ⊆ I(cid:16)(cid:16) ∩ B(cid:16) ∩ B(cid:16) ∩ B(cid:16) ∩ B(cid:16) ∩ B(cid:16)(cid:16), J(cid:16), J(cid:16), J(cid:16), J, J(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)A.2. Section 4Proof of Proposition 6. Let P be a program over (cid:3).Part (1). Let (I, J ) be a bi-model of P , such that (I, J )κ satisfies Property N and Property K, for all r ∈ P . We show that (I, J ) is an HT-model of P . Since (I, J )κ satisfies Property N, it holds that a ∈ I implies a ∈ J , therefore I ⊆ J , i.e., (I, J ) is an HT-interpretation. For every rule r ∈ P , (I, J ) |=β r implies (I, J ) (cid:12)|=β B(r), or (I, J ) |=β H(r) and I |= B(r). First suppose that (I, J ) (cid:12)|=β B(r). Then (I, J ) (cid:12)|= B(r) (note that for a conjunction of literals, such as B(r), the satisfaction relations do not differ). Moreover, since (I, J )κ satisfies Property K for r, it holds that J |= r. To see the latter, let K r denote the rule obtained from r by replacing every a ∈ (cid:3) occurring in r by K a, and let K J denote the set {K a ∈ (I, J )κ | a ∈ (cid:3)}. Then, (I, J )κsatisfies Property K for r iff K J |= K r. Observing that K J = {K a | a ∈ J }, we conclude that J |= r. This proves (I, J ) |= r, if (I, J ) (cid:12)|=β B(r). Next assume that (I, J ) |=β H(r) and I |= B(r). We conclude that (I, J ) |= H(r) (the satisfaction relations also coincide for disjunctions of atoms). As (I, J )κ satisfies Property K for r, it follows J |= r. This proves (I, J ) |= r, for every r ∈ P ; in other words, (I, J ) is an HT-model of P .Part (2). Let (H, T ) be an HT-model of P . We show that (H, T )κ satisfies Property N and Property K, for all r ∈ P . As a consequence of H ⊆ T , for every a ∈ (H, T )κ such that a ∈ (cid:3), it also holds that K a ∈ (H, T )κ , i.e., (H, T )κ satisfies Property N. Moreover, (H, T ) |= P implies T |= r, for all r ∈ P . Let K T = {K a | a ∈ T } and let K r be as above; T |= r implies K T |= K r, for all r ∈ P . By construction of (H, T )κ and definition of Property K for r, we conclude that (H, T )κ satisfies Property K for all r ∈ P . (cid:2)Proof of Theorem 2. Let P be a program over (cid:3).Part (1). Let (H, T ) be an HT-model of P that satisfies (i(cid:16)) and (iicontradiction, first assume that (H, T )κ /∈ MM(H T κ (P )). Then, there exists an HT-model (H(cid:16) ⊂ H . Then (H(cid:16) ⊆ T , and at least one of the inclusions is strict. Suppose that HTknown property of HT), a contradiction to the assumption that (H, T ) satisfies (i(cid:16)). We show that (H, T )κ ∈ SEQ(P ). Towards a (cid:16) ⊆ H , (cid:16), T ) is an HT-model of P (by a well-(cid:16) ⊂ T must (cid:16) = H and T(cid:16)). Hence, H(cid:16)) of P , such that H(cid:16), T258G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271(cid:16), T(cid:16) \ H(cid:16)). But, since Thold. Moreover, by the same argument (Hto the assumption that (H, T ) satisfies (iisuming that (H, T )κ /∈ mc(MM(H T κ (P ))), i.e., there exists an HT-model (H(cid:16)) satisfies (i(cid:16), T(Hfies (ii(cid:16))κ ∈ MM(H T κ (P )). The latter obviously implies that (H(cid:16)), which proves that (H, T )κ ∈ SEQ(P ).(cid:16), T(cid:16) ⊂ T \ H , this is in contradiction (cid:16)). Consequently, (H, T )κ ∈ MM(H T κ (P )). We continue the indirect proof as-(cid:16), T(cid:16) ⊂ T \ H and (cid:16)). Again, this contradicts that (H, T ) satis-(cid:16)) of P , such that T(cid:16)) also satisfies (iPart (2). Let Iκ ∈ SEQ(P ). We show that β(Iκ ) is an HT-model of P that satisfies (i(cid:16)). Let β(Iκ ) = (H, T ). To-wards a contradiction first assume that (H, T ) is not an HT-model of P . Then by the definition of SEQ(P ), and the fact that Iκ uniquely corresponds to sets H and T , we conclude that Iκ /∈ mc(MM(H T κ (P ))), i.e., Iκ /∈ SEQ(P ); contradiction. (cid:16), T )Next, suppose that (H, T ) does not satisfy (i(cid:16)). Therefore, Iκ /∈ mc(MM(H T κ (P ))), i.e., Iκ /∈ SEQ(P ); contra-(cid:16) ⊂ H , which exists if (H, T ) does not satisfy (isuch that H(cid:16)). Then, Iκ /∈ mc(MM(H T κ (P ))), as witnessed by (Hdiction. Eventually assume that (H, T ) does not satisfy (iifor (cid:16)) exists if (H, T ) does not sat-(cid:16)) satisfies (i(cid:16), Tan HT-model (H(cid:16))κ ∈ MM(H T κ (P )) or there (cid:16), T(cid:16)). To see that (Hisfy (ii(cid:16) ⊂ T \ H ). This (cid:16)(cid:16) \ Hexists an HT-model (H(which implies T(cid:16))proves that Iκ /∈ SEQ(P ), again a contradiction. This concludes the proof that β(Iκ ) is an HT-model of P that satisfies (iand (ii(cid:16), Tis a witness for Iκ /∈ mc(MM(H T κ (P ))), observe that either (H(cid:16)), such that T(cid:16))κ(cid:16)(cid:16)), such that (H(cid:16)). Then, Iκ /∈ MM(H T κ (P )), as witnessed by (H(cid:16)(cid:16))κ ∈ MM(H T κ (P )) and T(cid:16) ⊂ T \ H and (Hfor an HT-model (H(cid:16))—note that (H(cid:16)) and (ii(cid:16), T(cid:16), T(cid:16)). (cid:2)(cid:16), T )κ(cid:16)(cid:16) ⊂ T(cid:16) \ H(cid:16) ⊂ T(cid:16) \ H(cid:16) \ H(cid:16), T(cid:16), T(cid:16), T(cid:16))κ(cid:16)Proof of Theorem 3. Let P be a program over (cid:3), and let Iκ be an interpretation over (cid:3)κ . The proof uses the following lemmas.Lemma 8. If M |= P H T , then β(M ∩ (cid:3)κ ) is an HT-model of P .Proof. Let (I, J ) = β(M ∩ (cid:3)κ ). Since M |= P κ , (I, J ) is a bi-model of P by Proposition 5. Moreover, M ∩ (cid:3)κ = (I, J )κ and (I, J )κ satisfies Property N, otherwise there is an atom a ∈ M such that K a /∈ M, a contradiction to M |= K a ← a. Also, (I, J )κ satisfies Property K for all r ∈ P ; otherwise, if Property K does not hold for some r ∈ P of the form (1), then M |= K b1 ∧ . . . ∧ K bm and M (cid:12)|= K a1 ∨ . . . ∨ K al ∨ K c1 ∨ . . . ∨ K cn, i.e., M (cid:12)|= P H T ; contradiction. Hence by Proposition 6, (I, J )is a HT-model of P . (cid:2)Next, we prove:Lemma 9. If (H, T ) is an HT-model of P , then (H, T )κ,P |= P H T .Proof. Note that every HT-model of P is a bi-model of P . Assume the contrary; then (H, T ) |= r and (H, T ) (cid:12)|=β r, for some −(r) ∩ H = ∅, and r ∈ P . Then, H (cid:12)|= B(r), while (H, T ) |= B(r), must hold. However, (H, T ) |= B(r) implies Btherefore H |= B(r); contradiction. This proves that (H, T ) is a bi-model of P . Consequently, (H, T )κ,P |= P κ by Proposition 5. Moreover, since (H, T ) is an HT-model, (H, T )κ satisfies Property N (and Property K for all r ∈ P ) by Proposition 6. Because (H, T )κ,P ∩ (cid:3)κ = (H, T )κ , this implies that (H, T )κ,P |= r, for all rules of the form K a ← a in P H T \ P κ (this is an obvious consequence of Property N). For the remaining rules r in P H T \ P κ , (H, T )κ,P |= r is a simple consequence of T |= P . This proves (H, T )κ,P |= P H T . (cid:2)+(r) ⊆ H and BLemma 10. For every M ∈ AS(P H T ), β(M ∩ (cid:3)κ ) satisfies (i(cid:16)) in Theorem 2.(cid:16) ⊂ H . Note Proof. Towards a contradiction assume the contrary. Then there exists an HT-model (Hthat M ∈ AS(P H T ) implies M = β(M ∩ (cid:3)κ )κ,P . Since the latter is a model of P H T by Lemma 9, M must be a subset thereof; however it obviously cannot be a strict subset on (cid:3)κ . By construction of β(M ∩ (cid:3)κ )κ,P and the rules of form (6) of the epistemic transformation, we also conclude that λr,i ∈ β(M ∩ (cid:3)κ )κ,P implies λr,i ∈ M, for any r ∈ P of the form (1) and (cid:16) |= P H T by (cid:16) = (H1 ≤ i ≤ l. This proves M = β(M ∩ (cid:3)κ )κ,P . Now consider M(cid:16)). (cid:2)Lemma 9. This is a contradiction to the assumption that M ∈ AS(P H T ), and thus proves that β(M ∩ (cid:3)κ ) satisfies (i(cid:16) ⊂ M by construction, and M(cid:16), T ) of P such that H(cid:16), T )κ,P . Then, MLemma 11. For every HT-model (H, T ) of P that satisfies (igap((H, T )κ ).(cid:16)) of Theorem 2, there exists some M ∈ AS(P H T ) such that gap(M) ⊆Proof. Since (H, T )κ,P |= P H T by Lemma 9, there exists M ∈ AS(P H T ), such that M ⊆ (H, T )κ,P . To prove the lemma, it (cid:16) ⊂ Hsuffices to show that M ∩ (cid:3) = H . Assume the contrary; then by (d) there exists an HT-model (H(cid:16), T ) |= P , which contradicts the assumption that (H, T ) satisfies (iand T(cid:16) ⊆ T . However, then (H(cid:16)) of P , such that H(cid:16), T(cid:16)). (cid:2)The proof of Theorem 3 is then as follows.(⇐) Suppose that Iκ ∈ {M ∩ (cid:3)κ | M ∈ mc(AS(P H T ))}. We prove Iκ ∈ SEQ(P ) via Theorem 2. Let M ∈ mc(AS(P H T )), (cid:16)) in such that Iκ = M ∩ (cid:3)κ , and let (I, J ) = β(M ∩ (cid:3)κ ). Then, (I, J ) is an HT-model of P by Lemma 8 and (I, J ) satisfies (iG. Amendola et al. / Artificial Intelligence 234 (2016) 219–271259Theorem 2 by Lemma 10. We prove that (I, J ) satisfies (iithe case, then there exists an HT-model (H, T ) of P , such that T \ H ⊂ J \ I and (H, T ) satisfies (ithere exists Mcontradicts the assumption that M ∈ mc(AS(P H T )), and thus proves that (I, J ) satisfies (iithat Iκ ∈ SEQ(P ).(cid:16)) in Theorem 2. Towards a contradiction, assume that this is not (cid:16)). According to Lemma 11, (cid:16)) ⊂ gap(M) due to T \ H ⊂ J \ I . This (cid:16)) in Theorem 2. We conclude (cid:16)) ⊆ gap((H, T )κ ), which implies gap(M(cid:16) ∈ AS(P H T ), such that gap(M(cid:16)) and (ii(⇒) Suppose that Iκ ∈ SEQ(P ). We prove Iκ ∈ {M ∩ (cid:3)κ | M ∈ mc(AS(P H T ))}. Let (H, T ) = β(Iκ ). By Theorem 2, (H, T )(cid:16)). We show that there exists M ∈ mc(AS(P H T )) such that β(M ∩ (cid:3)κ ) = (H, T ). (cid:16)), it holds that M ∩ (cid:3) =(cid:16)) is an (cid:16)) due to Lemma 10. Hence, β(M ∩ (cid:3)κ ) = (H, T ). It remains (cid:16) \ H(cid:16) ⊂ T \ H . (cid:16)), which again (cid:16), T(cid:16)). This proves that M ∈ mc(AS(P H T )). As M ∩ (cid:3)κ = Iκ , we is an HT-model of P that satisfies (iSince (H, T )κ,P |= P H T , there exists M ∈ AS(P H T ) such that M ⊆ (H, T )κ,P . Since (H, T ) satisfies (iH . Moreover, M ∩ (cid:3)κ ⊂ (H, T )κ contradicts the fact that (H, T ) satisfies (ii(cid:16) \ H ⊂ T \ H and (H, THT-model of P , such that Tto show that M ∈ mc(AS(P H T )). If this is not the case, then some HT-model (H(cid:16) ∩ (cid:3)κ ) for some MSince (Hleads to a contradiction of the fact that (H, T ) satisfies (iiconclude that Iκ ∈ {M ∩ (cid:3)κ | M ∈ mc(AS(P H T ))}. (cid:2)(cid:16) ∈ AS(P H T ), we conclude by Lemma 10 that (H(cid:16)) of P exists such that T(cid:16)) satisfies (i(cid:16)), because then β(M ∩ (cid:3)κ ) = (H, T(cid:16)) satisfies (i(cid:16)) = β(M(cid:16), T(cid:16), TProof of Proposition 7. Let P be a program over (cid:3). If P has a model M, then (M, M) is an HT-model of P . Therefore H T κ (P ) (cid:12)= ∅, which implies MM(H T κ (P )) (cid:12)= ∅, and thus mc(MM(H T κ (P ))) (cid:12)= ∅. We conclude that SEQ(P ) (cid:12)= ∅, i.e., P has a semi-equilibrium model. (cid:2)Proof of Proposition 8. Let P be a coherent program over (cid:3), and let Y ∈ AS(P ). Then (Y , Y ) is an HT-model of P that (cid:16)) because Y \ Y = ∅. Hence, satisfies (i(Y , Y )κ ∈ SEQ(P ).(cid:16)) in Theorem 2, since it is in equilibrium. Moreover, it trivially satisfies also (iiAs P is coherent, there exists (T , T ) ∈ H T (P ) that satisfies (i(cid:16)) in Theorem 2 and (trivially) (ii(cid:16)). Hence, gap(Iκ ) = ∅ for all Iκ ∈ SEQ(P ). Moreover, β(Iκ ) is of the form (Y , Y ), and Y ∈ AS(P ). (cid:2)A.3. Section 5Proof of Proposition 10. If ( X, Y ) ∈ SEQS (P ), then there exists some (I, J ) ∈ SEQ(b S (P )) such that ( X, Y ) ∈ SEQ(P S (I, J )). We will prove that (I, J ) = ( X, Y )|S . Obviously I ⊆ J ⊆ S. Moreover because ( X, Y ) |= a for each a ∈ I , we have a ∈ X for all a ∈ I , so I ⊆ X ; because ( X, Y ) |= {← not a | a ∈ J }, then a ∈ Y for all a ∈ J , so J ⊆ Y ; and because ( X, Y ) |= {← a | a ∈ S \ J }, then a /∈ Y for all a ∈ S \ J , so (S \ J ) ∩ Y = ∅. In particular we obtain that I ⊆ X ∩ S and J ⊆ Y ∩ S. We know that ( X, Y ) |= P S (I, J ). So if we consider a ∈ X ∩ S, then a ∈ H(r) for some rule r ∈ P \ b S (P ) ∪ {a | a ∈ I}. But because a ∈ S, it follows that r /∈ P \ b S (P ), so r ∈ {a | a ∈ I}. Therefore a ∈ I , that is I = X ∩ S. Moreover if we consider an atom a ∈ Y ∩ S, then a ∈ Y and a ∈ S, and because (S \ J ) ∩ Y = ∅, we obtain that a ∈ J , that is J = Y ∩ S. In conclusion, we have that ( X ∩ S, Y ∩ S) = (I, J ) is a semi-equilibrium model of b S (P ). (cid:2)Proof of Lemma 1. Suppose that ( X, Y ) is an HT-model of P S (I, J ). Hence, ( X, Y ) |= P \ b S (P ). It remains to show that ( X, Y ) |= r for every r ∈ b S (P ). Suppose that r has the form (1). By assumption (I, J ) ∈ SEQ(b S (P )), hence we conclude that (I, J ) |= b S (P ).some ck ∈ BIf (I, J ) |= ai for some ai ∈ H(r), then ai ∈ I and because ( X, Y ) |= P S (I, J ), we have ( X, Y ) |= ai , i.e. ( X, Y ) |= r.If we assume that (I, J ) (cid:12)|= b1 ∧ . . . ∧ bm ∧ ¬c1 ∧ . . . ∧ ¬cn, then there exists some b j ∈ B+(r) such that (I, J ) (cid:12)|= b j or −(r) such that (I, J ) (cid:12)|= ¬ck, that is, by definition of HT-satisfaction that b j /∈ I respectively ck ∈ J .In the first case, b j is not in the head of any other rule in P \ b S (P ), for which b j /∈ X and so ( X, Y ) |= r.In the second case, we have in P S (I, J ) the rule ← not ck; this implies ck ∈ Y , and therefore, also in this case, ( X, Y ) |= r. (cid:2)Proof of Proposition 11. Let ( X, Y ) ∈ SEQS (P ). Then there exists (I, J ) ∈ SEQ(b S (P )) such that ( X, Y ) ∈ SEQ(P S (I, J )). By Lemma 1, ( X, Y ) is an HT-model of P . So, by definition of semi-equilibrium model, remains to prove the h-minimality and (cid:16), Y ) |=the gap-minimality of ( X, Y ). Suppose by contradiction that there exists some ( X(cid:16) ∩ S, Y ∩ S) |= b S (P ), but by Proposition 10, ( X ∩t S (P ) and ( XS, Y ∩ S) ∈ SEQ(b S (P )). So by the h-minimality of the semi-equilibrium model ( X ∩ S, Y ∩ S) of the bottom of P , we (cid:16) ∩ S = X ∩ S. So that have that ( X( X(cid:16), Y ) |= b S (P ). By this last sentence we also obtain that ( X(cid:16) ∩ S, Y ∩ S) = ( X ∩ S, Y ∩ S) = (I, J ). Therefore(cid:16) ∩ S) ⊆ ( X ∩ S), then necessarily X(cid:16) ∩ S) (cid:12)⊂ ( X ∩ S). But because X(cid:16) ⊂ X implies that ( X(cid:16) ⊂ X . So that ( X(cid:16), Y ) |= P with X(cid:16) ∩ S, Y ∩ S) |= {a | a ∈ I} ∪ {← not a | a ∈ J } ∪ {← a | a ∈ S \ J }.(X(cid:16), Y ) |= t S (P ), we conclude that (cid:16), Y ) |= P S (I, J ) against the h-minimality of ( X, Y ) respect to P S (I, J ). Similarly, suppose by contradiction that there (cid:16), Y ) |= {a | a ∈ I} ∪ {← not a | a ∈ J } ∪ {← a | a ∈ S \ J }. And because ( XIn particular ( X( Xexists some ( X(cid:16), Y(1) there is no ( X(cid:16) ⊂ Y \ X .(cid:16) \ X(2) Y(cid:16)) |= P and(cid:16)(cid:16), Y(cid:16)) |= P such that X(cid:16)(cid:16) ⊂ X(cid:16)and260G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Moreover, we suppose that(3) gap( X, Y ) is minimal among the gaps of the HT-models that satisfy (1) and (2).Because ( X(cid:16)) |= P , it holds that ( X(cid:16)) |= t S (P ) and ( X(cid:16)) |= b S (P ). From this we obtain that ( X(cid:16), Y(cid:16), Y(cid:16), Y(cid:16) ∩ S, Y(cid:16) ∩ S) |= b S (P )and by condition (2) we obtain that(cid:16) ∩ S) = (Y(cid:16) \ X(cid:16)) ∩ S ⊆ (Y \ X) ∩ S = (Y ∩ S) \ (X ∩ S).(Y(cid:16) ∩ S) \ (X(cid:16), Y(cid:16)(cid:16), Y(cid:16) ⊂ X(cid:16) \ S), Y(cid:16) \ S) = X(cid:16) ∩ S) \ ( X(cid:16) \ S) ⊂ ( X(cid:16) ∩ S) ∪ ( X(cid:16)) |= P and I(cid:16) ∩ S, then (I(cid:16), Y(cid:16) ∩ S) \ ( X(cid:16))|S satisfies the h-minimality with respect to b S (P ). In fact if by contradiction there exists (I(cid:16) ∪ ( XMoreover ( X(cid:16) ∪ ( Xb S (P ), such that IBy Proposition 10, ( X ∩ S, Y ∩ S) ∈ SEQ(b S (P )), so we have necessarily that (YOtherwise ( X, Y )|S could not be a semi-equilibrium model of b S (P ), because ( X( X, Y )|S . Therefore ( Xand ˆJ \ ˆI ⊂ (Yassumed. Now we show that ( Xand ( X(cid:16) ∩ S). If by contradiction there exists ( ˆX, Yto P S ( Xagainst the hypothesis (1). Finally we prove the gap-minimality of ( Xthere exists ( ˆX, ˆY ) |= P S ( Xexists ( ˆX, ˆY ) |= P (by Lemma 1) that satisfies the h-minimality property and ˆY \ ˆX ⊂ Yconclusion we have proved that ( X( X, Y ) would not be a semi-equilibrium model relative to S. And so we come to a contradiction, so a supposed ( Xcannot exist. Therefore ( X, Y ) satisfies the gap-minimality property respect to P , so that ( X, Y ) ∈ SEQ(P ). (cid:2)(cid:16) ∩ S) |=against the condition (1). (cid:16) ∩ S) = (Y ∩ S) \ ( X ∩ S) = J \ I . (cid:16))|S contradicts the gap-minimality of (cid:16))|S ∈ SEQ(b S (P )), because if there exists (ˆI, ˆJ ) |= b S (P ), that satisfies the h-minimality property(cid:16) ∩ S), then ˆJ \ ˆI ⊂ (Y ∩ S) \ ( X ∩ S), and therefore ( X, Y )|S /∈ SEQ(b S (P )), contrary to what is (cid:16)) |= t S (P )(cid:16), Y(cid:16)) with respect (cid:16)) |= P(cid:16) ∩ S). If by contradiction (cid:16)(cid:16) \ X, then there , against the hypothesis (3). In (cid:16) ⊂ Y \ X , it follows that (cid:16))(cid:16) ∩ S, Y(cid:16) ∩ S). We prove the h-minimality of ( X(cid:16) ∩ S, Y(cid:16), Y(cid:16) ∩ S), that satisfies the h-minimality property and, moreover, ˆY \ ˆX ⊂ Y, then, by Lemma 1, ( ˆX, Y(cid:16)(cid:16) ∩ S, Y(cid:16)) must be a semi-equilibrium model of P S ( X(cid:16) ∩ S). First since ( X(cid:16), Y(cid:16))|S ∈ SEQ(b S (P )), it follows that ( X(cid:16) ∩ S) with ˆX ⊂ X(cid:16)) respect to P S ( X(cid:16) ∩ S)) and since hypothesis (2), Y(cid:16) ∩ S, Y(cid:16)) |= P S ( X(cid:16)) ∈ SEQ(P S ( X(cid:16), Y(cid:16) ∩ S, Y(cid:16)) |= P S ( X(cid:16) ∩ S, Y(cid:16) ∩ S, Y(cid:16) \ X(cid:16) \ X(cid:16), Y(cid:16), Y(cid:16), Y(cid:16), Y(cid:16), Y(cid:16)Proof of Proposition 12. Let ( X, Y ) ∈ SEQ(P ) and ( X, Y )|S ∈ SEQ(b S (P )). To demonstrate that ( X, Y ) ∈ SEQS (P ), first we will prove that ( X, Y ) is a semi-equilibrium model of P S ( X ∩ S, Y ∩ S). Since ( X, Y ) ∈ SEQ(P ), we obtain in particular that ( X, Y ) |= t S (P ). Now because X ∩ S ⊆ X then ( X, Y ) |= {a | a ∈ X ∩ S}, because Y ∩ S ⊆ Y then ( X, Y ) |= {← not a | a ∈ Y ∩ S}, and because (S \ (Y ∩ S)) ∩ Y = ∅ then ( X, Y ) |= {← a | a ∈ S \ (Y ∩ S)}. So that ( X, Y ) is an HT-model of P S ( X ∩ S, Y ∩ S). So it remains to prove the h-minimality and the gap-minimality of ( X, Y ) as regards to P S ( X ∩ S, Y ∩ S). If, by contradic-(cid:16), Y ) |= Ption, we suppose that there exists Xand this contradicts the h-minimality of ( X, Y ) as regards to P . Similarly if, by contradiction, we assume that there (cid:16) ⊂ Y \ X , then by Lemma 1, we exists ( X(cid:16)) |= P and this contradicts the gap-minimality of ( X, Y ) as regards to P . Finally, it must be shown that obtain that ( Xthere is no ( ˆX, ˆY ) ∈ SEQ(P S (I, J )) with (I, J ) ∈ SEQ(b S (P )), such that gap( ˆX, ˆY ) ⊂ gap( X, Y ). In fact if, by contradiction, there exists such a ( ˆX, ˆY ), then ( ˆX, ˆY ) |= P (by Lemma 1), ( ˆX, ˆY ) satisfies the h-minimality property respect to P and gap( ˆX, ˆY ) ⊂ gap( X, Y ); i.e. ( X, Y ) does not satisfy the gap-minimality property respect to P , against the hypothesis. There-fore, in conclusion, ( X, Y ) ∈ SEQS (P ). (cid:2)(cid:16)) |= P S ( X ∩ S, Y ∩ S) that satisfies the h-minimality property and Y(cid:16), Y ) |= P S ( X ∩ S, Y ∩ S), then, by Lemma 1, ( X(cid:16) ⊂ X and ( Xsuch that X(cid:16) \ X(cid:16), Y(cid:16), Y(cid:16)Proof of Corollary 3. By Theorem 4, SEQS (P ) = {( X, Y ) ∈ SEQ(P ) | ( X, Y )|S ∈ SEQ(b S (P ))}. As SEQ(P ) (cid:12)= ∅, by Propo-sition 8 SEQ(P ) = EQ(P ), and SEQ(b S (P )) = EQ(b S (P )); by Proposition 2 and the identity (2) (i.e., by identity (11), it follows that SEQS (P ){( X, Y ) ∈ EQ(P ) | ( X, Y )|S ∈ EQ(b S (P ))} = EQ(P ). As for any positive program P , EQ(P ) = {(M, M) |M ∈ MM(P )}, the result follows. (cid:2)Proof of Proposition 13. If P is constraint-free, then P has some model, hence also b S (P ) (⊆ P ) has some model, and thus by Proposition 7, SEQ(b S (P )) (cid:12)= ∅. For any (I, J ) ∈ SEQ(b S (P )), the program P S (I, J ) also has a model, e.g. J ∪ ((cid:3) \ S). Thus, SEQ(P S (I, J )) (cid:12)= ∅ by Proposition 7, and hence it follows SEQ(P S ) (cid:12)= ∅. (cid:2)Proof of Theorem 5. We proceed by induction on the length n ≥ 1 of the splitting sequence. If n = 1, then we have S = (S 1)(cid:16) = ∅, so SEQS (P ) = SEQS1 (P ) and, by Theorem 4, we obtain that ( X, Y ) ∈ SEQS (P ) if and only if ( X, Y ) ∈ SEQ(P )and S∈ SEQ(b S1 (P )). We assume that the statement is valid for a splitting sequence and ( X, Y )|S ∈ SEQ(b S (P )), that is ( X, Y )|S1(cid:16) = (S2, . . . , Sn). Then of length n − 1 and consider a splitting sequence S = (S1, . . . , Sn) of length n. As usual, we put S( X, Y ) ∈ SEQS (P ) if and only if there exists (I1, J 1) ∈ SEQ(b S1 (P )) such that ( X, Y ) ∈ SEQS(P 1) and ( X, Y ) is a maximal canonical HT-interpretation. Applying the induction hypothesis to ( X, Y ) ∈ SEQS(P 1), we know that ( X, Y ) ∈ SEQ(P 1) and ∈ SEQ(b Sk (P k−1)), for k = 2, . . . , n. Now ( X, Y ) ∈ SEQ(P 1) with (I1, J 1) ∈ SEQ(b S1 (P )) and ( X, Y ) is a maximal ( X, Y )|Skcanonical HT-interpretation is equivalent, by definition, to ( X, Y ) ∈ SEQS1 (P ). So that, by Theorem 4, ( X, Y ) ∈ SEQ(P ) and ∈ SEQ(b S1 (P )). In conclusion we have demonstrated that ( X, Y ) ∈ SEQS (P ) if and only if ( X, Y ) ∈ SEQ(P ) and ( X, Y )|S1∈ SEQ(b Sk (P k−1)), for some P k−1, for k = 1, . . . , n. (cid:2)( X, Y )|Sk(cid:16)(cid:16)Proof of Corollary 6. This is immediate from Proposition 15 and Corollary 4, given that as well-known EQ(P ) (cid:12)= ∅ for every stratified program. (cid:2)G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271261Appendix B. Section 6Proof of Theorem 6. The proof uses the following lemmas.Lemma 12. Let P be a program and let S = (S1, . . . , Sn) be a splitting sequence of P . We let as above P 0 = P and P k =(P k−1)Sk (Ik, J k), where (Ik, J k) ∈ SEQ(b Sk (P k−1)), with k = 1, . . . , n. Furthermore, we let Ak = {a|a ∈ Ik} ∪ {← not a|a ∈ J k} ∪ {←a|a ∈ Sk \ J k}. ThenP k = P \ b Sk (P ) ∪ Akfor k = 1, . . . , n.Proof. We will prove this statement by induction on k ≥ 1. If k = 1, we obtain by definition thatP 1 = (P 0)S1 (I1, J 1) = P 0 \ b S1 (P 0) ∪ A1 = P \ b S1 (P ) ∪ A1.We assume that the statement is true for k = j − 1 and consider P j . By definition we have that P j = (P j−1)S j (I j, J j) =P j−1 \ b S j (P j−1) ∪ A j . Now we can apply the inductive hypothesis on P j−1 and we obtain thatP j = (P \ b S j−1 (P ) ∪ A j−1) \ b S j (P \ b S j−1 (P ) ∪ A j−1) ∪ A j.Since S j−1 ⊆ S j , we have that b S j ( A j−1) = A j−1, and soP j = (P \ b S j−1 (P ) ∪ A j−1) \ (b S j (P \ b S j−1 (P )) ∪ A j−1) ∪ A j= (P \ b S j−1 (P )) \ b S j (P \ b S j−1 (P )) ∪ A j.Moreover since b S j−1 (P ) ⊆ b S j (P ), we can conclude thatP j = (P \ b S j−1 (P )) \ (b S j (P ) \ b S j−1 (P )) ∪ A j = P \ b S j (P ) ∪ A j.(cid:2)Lemma 13. Let P be a program. Let S = (S1, . . . , Sn) be a splitting sequence of P . Let P 0 = P and let P k and (Ik, J k) for k =1, . . . , n − 1 be defined as above. If ( X, Y ) ∈ SEQ(Sk+1,...,Sn)(P k), then Ik ⊆ X , J k ⊆ Y and (Sk \ J k) ∩ Y = ∅ for k = 1, . . . , n − 1.Proof. Let ( X, Y ) ∈ SEQ(Sk+1,...,Sn)(P k). We remember that P k = (P k−1)Sk (Ik, J k), where (Ik, J k) ∈ SEQ(b Sk (P k−1)), for k =1, . . . , n and P 0 = P . By Theorem 5 we have that ( X, Y ) ∈ SEQ(P k) and by Lemma 12,P k = P \ b Sk (P ) ∪ {a | a ∈ Ik} ∪ {← not a | a ∈ J k} ∪ {← a | a ∈ Sk \ J k}.So that Ik ⊆ X , J k ⊆ Y and (Sk \ J k) ∩ Y = ∅. (cid:2)Lemma 14. Let P be a program. Let S = (S1, . . . , Sn) be a splitting sequence of P such that At(P ) = Sn. If ( X, Y ) ∈ SEQ(S1,...,Sn)(P ), then there exists (Ik, J k) ∈ SEQ(b Sk (P k−1)) for k = 1, . . . , n such that(X, Y ) = (I1 ∪ (I2 \ I1) ∪ . . . ∪ (In \ In−1), J 1 ∪ ( J 2 \ J 1) ∪ . . . ∪ ( Jn \ Jn−1))with (Ik \ Ik−1) ⊆ ( J k \ J k−1) ⊆ (Sk \ Sk−1), for k = 2, . . . , n.Proof. We proceed by induction on the length n ≥ 1 of the splitting sequence. If n = 1, then At(P ) = S 1 and ( X, Y ) ∈SEQS1 (P ) imply that there exists some (I1, J 1) ∈ SEQ(b S1 (P )) such that ( X, Y ) ∈ SEQ(P S1 (I1, J 1)), but P S1 (I1, J 1) =P \ b S1 (P ) ∪ A1 = A1, so thatSEQ(P S1 (I1, J 1)) = SEQ( A1)= SEQ({a | a ∈ I1} ∪ {← not a | a ∈ J 1} ∪ {← a | a ∈ S1 \ J 1}) = {(I1, J 1)},that is ( X, Y ) = (I1, J 1).Now we suppose that the statement is valid for splitting sequence of length n − 1 and we consider ( X, Y ) ∈SEQ(S1,...,Sn)(P ). Then there exists (I1, J 1) ∈ SEQ(b S1 (P )) such that ( X, Y ) ∈ SEQ(S2,...,Sn)(P 1) and At(P 1) = Sn, so by the inductive hypothesis there exists (Ik, J k) ∈ SEQ(b Sk (P k−1)) for k = 2, . . . , n such that ( X, Y ) = (I2 ∪ (I3 \ I2) ∪ . . . ∪ (In \In−1), J 2 ∪ ( J 3 \ J 2) ∪ . . . ∪ ( J n \ J n−1)) with Ik \ Ik−1 ⊆ J k \ J k−1 ⊆ Sk \ Sk−1, for k = 3, . . . , n. Moreover, by Lemma 13, I1 ⊆ X , J 1 ⊆ Y and (S1 \ J 1) ∩ Y = ∅ and because (I2, J 2) ∈ SEQ(b S2 (P 1)) we obtain that I1 ⊆ I2, J 1 ⊆ J 2 and (S1 \ J 1) ∩ J 2 = ∅. These last results imply that I2 \ I1 ⊆ J 2 \ J 1 ⊆ S2 \ S1. (cid:2)Lemma 15. Let P be a program and let S ⊆ At(P ) such that both S and At(P ) \ S are splitting sets of P . If for each constraint r, At(r) ⊆ S or At(r) ⊆ At(P ) \ S, thenSEQ(P ) = SEQS (P ).262G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Proof. The inclusion SEQS (P ) ⊆ SEQ(P ) follows from Proposition 11. So we have just to prove that SEQ(P ) ⊆ SEQS (P ).Let ( X, Y ) ∈ SEQ(P ). We want to prove that ( X ∩ S, Y ∩ S) ∈ SEQ(b S (P )).We know that ( X, Y ) |= b S (P ). As S is a splitting set of P , At(b S (P )) ⊆ S and so ( X ∩ S, Y ∩ S) |= b S (P ).Now we prove the claim showing that ( X ∩ S, Y ∩ S) satisfies h-minimality and gap-minimality.If by contradiction some I ⊂ X ∩ S exists such that (I, Y ∩ S) |= b S (P ), then X(cid:16) = I ∪ ( X ∩ ( At(P ) \ S)) ⊂ X and ( X(cid:16), Y ) |= Pwhich contradicts the h-minimality of ( X, Y ).Similarly, if by contradiction, some (I, J ) |= b S (P ) exists such that (I, J ) satisfies h-minimality and J \ I ⊂ (Y ∩ S) \( X ∩ S), (cid:16)) |= P , satisfies the h-minimality (cid:16) = J ∪(Y ∩( At(P ) \ S)), we obtain that ( X(cid:16) = I ∪( X ∩( At(P ) \ S)) and Y(cid:16), Ythen having set X(cid:16) \ Xand Y(cid:16) ⊂ Y \ X in contradiction to the gap-minimality of ( X, Y ).Therefore ( X ∩ S, Y ∩ S) ∈ SEQ(b S (P )). Then, by Theorem 4, ( X, Y ) ∈ SEQS (P ); hence SEQ(P ) = SEQS (P ). (cid:2)For any sets M and M(cid:16)of HT-models, define their product M × M(cid:16)as the set of HT-models given by M × M(cid:16) ={( X ∪ X(cid:16), Y ∪ Y(cid:16)) | ( X, Y ) ∈ M, ( X(cid:16), Y(cid:16)) ∈ M(cid:16)}.Lemma 16. Let P be a program in which each constraint r fulfills either At(r) ⊆ S or At(r) ⊆ At(P ) \ S. If both S and At(P ) \ S are splitting sets of P , thenSEQS (P ) = SEQ(b S (P )) × SEQ(t S (P )).Proof. If SEQ(b S (P )) = ∅, thenSEQ(b S (P )) × SEQ(t S (P )) = ∅andSEQS (P ) = mc(cid:13)(cid:11)(cid:14)SEQ(P S (I, J ))= ∅.(I, J )∈SEQ(b S (P ))Let (I, J ) ∈ SEQ(b S (P )). For each rule r ∈ b S (P ), no atom of r is in some rule of t S (P ) and vice versa, that is At(b S (P )) ∩At(t S (P )) = ∅. HenceSEQ(t S (P ) ∪ {a | a ∈ I} ∪ {← not a | a ∈ J } ∪ {← a | a ∈ S \ J })= {(X, Y ) | X = X1 ∪ I, Y = Y 1 ∪ J , (X1, Y 1) ∈ SEQ(t S (P ))}= SEQ(t S (P )) × {(I, J )}.ThenSEQS (P ) = mc(cid:13)(cid:11)SEQ(t S (P )) × {(I, J )}(cid:14)(I, J )∈SEQ(b S (P ))= mc (SEQ(b S (P )) × SEQ(t S (P )))= SEQ(b S (P )) × SEQ(t S (P )).(cid:2)Proof of Proposition 17. The proof follows immediately from Lemmas 15 and 16. (cid:2)Lemma 17. Let P be a program without cross-constraints. Let (C1, . . . , Cn) and (C1, . . . , Ci−1, Ci+1, Ci, Ci+2, . . . , Cn) be two topo-logical orderings of SCC(P ). If we put Sk = C1 ∪ . . . ∪ Ck for k = 1, . . . , n and S= S i−1 ∪ Ci+1 then(cid:16)i(P \ b S i−1 (P )) = b S i+1 (P \ b S i (P )).b S(cid:16)i(cid:16)iProof. In general we know that b S i (P ) \ b S i−1 (P ) = b S i (P \ b S i−1 (P )). Hence it is sufficient to prove that b S i+1 (P ) \ b S i (P ) =b S(P ) \ b S i−1 (P ).Let r ∈ P , and assume that r ∈ b S i+1 (P ) and r /∈ b S i (P ). If r is a constraint, then At(r) ∩ Ci+1 (cid:12)= ∅. As P has no cross-constraints, it follows that At(r) ∩ Ci = ∅. If r is not a constraint, then there exists some a ∈ H(r) such that a ∈ Ci+1. But because there is no edge between Ci and Ci+1, we obtain again that At(r) ∩ Ci = ∅. Therefore r ∈ b S i−1∪Ci+1 (P ) and clearly r /∈ b S i−1 (P ).Conversely, assume that r ∈ b S i−1∪Ci+1 (P ) and r /∈ b S i−1 (P ). Then r ∈ b S i−1∪Ci+1 (P ) ⊆ b S i+1 (P ). Moreover r ∈ b S i−1∪Ci+1 (P )implies that At(r) ∩ Ci = ∅, and because r /∈ b S i−1 (P ), it follows that r /∈ b S i (P ). (cid:2)Lemma 18. Let P be a program without cross-constraints. Let (C1, . . . , Cn) and (C1, . . . , Ci−1, Ci+1, Ci, Ci+2, . . . , Cn) be two topo-logical orderings of SCC(P ). If we put Sk = C1 ∪ . . . ∪ Ck for k = 1, . . . , n and S= S i−1 ∪ Ci+1 then(cid:16)iSEQ(S1,...,S i−1,S i ,S i+1,S i+2,...,Sn)(P ) = SEQ(S1,...,S i−1,S(cid:16)i,S i+1,S i+2,...,Sn)(P ).G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271263Proof. Let ( X, Y ) ∈ SEQ(S1,...,S i−1,S i ,S i+1,S i+2,...,Sn)(P ). Since At(P ) = C1 ∪ . . . ∪ Cn = Sn, by Lemma 14 we obtain that(X, Y ) = (I1 ∪ (I2 \ I1) ∪ . . . ∪ (In \ In−1), J 1 ∪ ( J 2 \ J 1) ∪ . . . ∪ ( Jn \ Jn−1))where (Ik, J k) ∈ SEQ(b Sk (P k−1)) for k = 1, . . . , n, with(Ik \ Ik−1) ⊆ ( J k \ J k−1) ⊆ (Sk \ Sk−1) = Ckfor k = 2, . . . , n.First we show that(X, Y )|∈ SEQ(b S(cid:16)iS(cid:16)i(P i−1)).We know that(X, Y )|S(cid:16)i= (X, Y )|S i−1∪C j+1= (Ii−1 ∪ (Ii+1 \ Ii), J i−1 ∪ ( J i+1 \ J i)).Moreover, using Lemma 17, we obtain(P i−1) = b S i−1∪C j+1 (P i−1) = b S i−1∪Ci+1 (P \ b S i−1 (P ) ∪ Ai−1)b S(cid:16)i= b S i−1∪Ci+1 (P \ b S i−1 (P )) ∪ Ai−1= b S i+1 (P \ b S i (P )) ∪ Ai−1.And we note thatb S i+1 (P i) = b S i+1 (P \ b S i (P ) ∪ Ai)= b S i+1 (P \ b S i (P )) ∪ Ai−1 ∪ ( Ai \ Ai−1).Now in the program b S i+1 (P i) both S i−1 ∪ Ci+1 and Ci are splitting sets and in particularb S i−1∪Ci+1 (b S i+1 (P i)) = b S i+1 (P \ b S i (P )) ∪ Ai−1andbCi (b S i+1 (P i)) = Ai \ Ai−1.Therefore by Proposition 17 we obtain thatSEQ(b S i+1 (P i)) = SEQ(b S i+1 (P \ b S i (P )) ∪ Ai−1) × SEQ( Ai \ Ai−1).So we have thatSEQ(b S i+1 (P i)) = SEQ(b S i−1∪C j+1 (P i−1)) × {(Ii \ Ii−1, J i \ J i−1)},and since(X, Y )|S i+1= (Ii−1 ∪ (Ii \ Ii−1) ∪ (Ii+1 \ Ii), J i−1 ∪ ( J i \ J i−1) ∪ ( J i+1 \ J i)) ∈ SEQ(b S i+1 (P i)),it follows(Ii−1 ∪ (Ii+1 \ Ii), J i−1 ∪ ( J i+1 \ J i)) ∈ SEQ(b S i−1∪C j+1 (P i−1)).By Theorem 5, we know that if ( X, Y ) ∈ SEQ(S1,...,S i−1,S i ,S i+1,S i+2,...,Sn)(P ), then(X, Y ) ∈ SEQ(P ), (X, Y )|S1(X, Y )|S i(X, Y )|S i+2∈ SEQ(b S i (P i−1)), (X, Y )|S i+1∈ SEQ(b S i+2 (P i+1)), . . . ( X, Y )|SnWe want to prove that ( X, Y ) ∈ SEQ(S1,...,S i−1,S(cid:16)∈ SEQ(b S1 (P )), . . . , ( X, Y )|S i−1∈ SEQ(b S i+1 (P i)),∈ SEQ(b Sn (P n−1)).∈ SEQ(b S i−1 (P i−2)),i ,S i+1,S i+2,...,Sn)(P ). That is, by Theorem 5:(X, Y ) ∈ SEQ(P ), (X, Y )|S1(X, Y )|∈ SEQ(b S(X, Y )|S i+2(P i−1)), (X, Y )|S i+1∈ SEQ(b S i+2 (P i+1)), . . . , ( X, Y )|Sn∈ SEQ(b S1 (P )), . . . ( X, Y )|S i−1∈ SEQ(b S i+1 (P \ b SS(cid:16)i(cid:16)i(cid:16)i∈ SEQ(b Sn (P n−1)).∈ SEQ(b S i−1 (P i−2)),(P ) ∪ Ai−1 ∪ ( Ai+1 \ Ai))),So it remains to prove that(X, Y )|S i+1We know that∈ SEQ(b S i+1 (P \ b S(cid:16)i(P i−1) ∪ Ai−1 ∪ ( Ai+1 \ Ai))).264G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271b S i+1 (P \b S(cid:16)i(P ) ∪ Ai−1 ∪ ( Ai+1 \ Ai))= b S i+1 (P \ b S i−1∪Ci+1 (P )) ∪ Ai−1 ∪ ( Ai+1 \ Ai)= b S i (P \ b S i−1 (P )) ∪ Ai−1 ∪ ( Ai+1 \ Ai)= b S i (P \ b S i−1 (P )) ∪ Ai−1) ∪ ( Ai+1 \ Ai)= b S i (P i−1) ∪ ( Ai+1 \ Ai).Now in this program both S i and Ci+1 are splitting sets and in particularb S i (b S i (P i−1) ∪ ( Ai+1 \ Ai)) = b S i (P i−1)andbCi+1 (b S i (P i−1) ∪ ( Ai+1 \ Ai)) = Ai+1 \ Ai.Therefore by Proposition 17 we obtain thatSEQ(b S i+1 (P \b S(cid:16)i(P i−1) ∪ Ai−1 ∪ ( Ai+1 \ Ai)))= SEQ(b S i (P i−1)) × SEQ( Ai+1 \ Ai)= SEQ(b S i (P i−1)) × {(Ii+1 \ Ii, J i+1 \ J i)}.Now since (Ii, J i) ∈ SEQ(b S i (P i−1)), we obtain that∈ SEQ(b S i+1 (P \ b S(Ii+1, J i+1) = (X, Y )|S i+1In conclusion, we have proved that(cid:16)i(P i−1) ∪ Ai−1 ∪ ( Ai+1 \ Ai))).SEQ(S1,...,S i−1,S i ,S i+1,S i+2,...,Sn)(P ) ⊆ SEQ(S1,...,S i−1,S(cid:16)i,S i+1,S i+2,...,Sn)(P ).The proof of the reverse inclusion is similar. (cid:2)Theorem 6 is then proven as follows. Let (Ci1 , . . . , Cin ) ∈ O(SG(P )). We define a functiont(Ci1,...,Cin ) : O(SG(P )) −→ O(SG(P )).Let (C j1 , . . . , C jn ) ∈ O(SG(P )). If Cirthen= C jr for r = 1, . . . , l, Cil+1(cid:12)= C jl+1 and there exists k + 1 > l + 1 such that C jk+1= Cil+1 , t(Ci1,...,Cin )(C j1 , . . . , C jn ) = t(Ci1,...,Cin )(Ci1 , . . . , Cil , C jl+1 , . . . , C jk−1 , C jk , Cil+1 , C jk+2 , . . . , C jn )= (Ci1 , . . . , Cil , C jl+1 , . . . , C jk−1 , Cil+1 , C jk , C jk+2 , . . . , C jn ),,...,Cin )(C j1 , . . . , C jn ) = (C j1 , . . . , C jn ) = (Ci1 , . . . , Cin ). This function is well-defined because there are no edges from else t(Ci1Cim to Cil+1 for m = l + 2, . . . , n. That is there are no edges from C jk to Cil+1 , therefore (Ci1 , . . . , Cil , C jl+1 , . . . , C jk−1 , Cil+1 , C jk ,C jk+2 , . . . , C jn ) is another topological ordering of SCC(P ). Moreover for each (C j1 , . . . , C jn ) ∈ O(SG(P )), there exists some finite N such thatt N(Ci1,...,Cin )(C j1 , . . . , C jn ) = (Ci1 , . . . , Cin ).During the proof, in order not to introduce additional symbols, we shall denote the splitting sequence S i with (Ci1 , . . . , Cin )and S j with (C j1 , . . . , C jn ).Let N be such that t N(Ci1,...,Cin )(C j1 , . . . , C jn ) = (Ci1 , . . . , Cin ). We will prove the theorem using induction on N. If N = 1, ,...,Cin )(C j1 , . . . , C jn ) = (Ci1 , . . . , Cin ), i.e. (C j1 , . . . , C jn ) and (Ci1 , . . . , Cin ) differ at most by the exchange of two con-,...,C jn )(P ). Now we suppose that ,...,Cin )(C s1 , . . . , C sn ) = (Ci1 , . . . , Cin ). We consider then t(Ci1secutive strongly connected components. Then, by Lemma 18, SEQ(Ci1the theorem is valid for topological orderings (C s1 , . . . , C sn ) such that t N−1(Ci1(C j1 , . . . , C jn ) such that t N,...,Cin )(C j1 , . . . , C jn ) = (Ci1 , . . . , Cin ). By definition of the function t(Ci1,...,Cin ), we know that,...,Cin )(P ) = SEQ(C j1(Ci1t(Ci1,...,Cin )(C j1 , . . . , C jn ) = (Ci1 , . . . , Cil , C jl+1 , . . . , C jk−1 , Cil+1 , C jk , C jk+2 , . . . , C jn ).Therefore, by Lemma 18, we have that,...,C jn )(P ) = SEQt(Ci1,...,Cin)(C j1,...,C jn )(P ).SEQ(C j1But now t N−1(Ci1,...,Cin )(t(Ci1,...,Cin )(C j1 , . . . , C jn )) = (Ci1 , . . . , Cin ) such that, by the induction hypothesis, we obtain thatG. Amendola et al. / Artificial Intelligence 234 (2016) 219–271265SEQt(Ci1(P ) = SEQ(Ci1In conclusion, we have proved that SEQ(C j1,...,Cin,...,C jn ))(C j1,...,Cin )(P ).,...,C jn )(P ) = SEQ(Ci1,...,Cin )(P ). (cid:2)Proof of Theorem 7. First we observe that for every splitting set S of a program P , we can always write S as the union of some SCCs of P . More in detail, if SCC(P ) = {C1, . . . , Cn}, then we can assume that S = C1 ∪ . . . ∪ Ck, where C1, . . . , Ck are consecutive in some topological ordering (C1, . . . , Ck, . . . , Cn) of SCC(P ).By definition, we have thatSCC(P ) = SEQ(S1,...,Sn)(P ),Mwhere S j = ∪ ji=1Ci , for 1 ≤ j ≤ n; note that S = Sk.If we explicate the computation of SEQ(S1,...,Sn)(P ) up to k-th union, we obtainSCC(P ) = mcM(cid:13) (cid:11)(cid:14)SEQ(Sk+1,...,Sn)(P \ b Sk (P ) ∪ Mk)Mk∈Mk(B.1)where Mk is last in a sequence Mi , 1 ≤ i ≤ k of sets Mi of HT-models Mi = (Ii, J i), over S i , such that M1 = SEQ(b S1 (P ))SEQ((b S i+1 (P ) \ b S i (P )) ∪ Mi), 1 ≤ i < k, where in abuse of notation “∪Mi ” stands for ∪{a | a ∈and Mi+1 = mc(Ii} ∪ {← not a | a ∈ J i} ∪ {← a | a ∈ S i \ J i}. Note that all Mi (cid:12)= M∈ Mi have incomparable gaps, i.e., gap(Mi) (cid:2) gap(MMi ∈Mi(cid:10)(cid:16)i).(cid:16)iSCC (b S (P )). Indeed, by definition, we know thatNow we show that the set Mk coincides with MSCC(b S (P )) = SEQ(S1,...,Sk)(b S (P )).MTherefore, applying k-times the definition of semi-equilibrium models relative to a splitting sequence, we obtainSEQ(S1,...,Sk)(b S (P )) = mcSEQ(b S (P ) \ b Sk (P ) ∪ M(cid:14)(cid:16)k)(cid:13) (cid:11)M(cid:16)k∈M(cid:16)k(B.2)(cid:16)k and M(cid:10)where M(cid:16)M(cid:16)SEQ((b S i+1 (b S (P )) \ b S i (b S (P ))) ∪ Mi+1M(cid:16)i coincide; as b S (P ) = b Sk (P ), we thus obtain from (B.2)k are analogously defined to Mk and Mk using b S (P ) instead of P , i.e., M(cid:16)= SEQ(b S1 (b S (P ))) and (cid:16)i), 1 ≤ i < k. As b S i (b S (P )) = b S i (P ) for each i, the Mi and the = mc(∈M(cid:16)iM1(cid:16)iSEQ(S1,...,Sk)(b S (P )) = mc(cid:13) (cid:11)(cid:14)SEQ(Mk)Mk∈Mk(cid:11)=Mk∈MkMk = Mk;here we use that the Mk have incomparable gaps. This proves the claim that Mk = MTo prove the result, it remains by (B.1) to show that for each Mk ∈ Mk,SCC(b S (P )).SEQ(Sk+1,...,Sn)(P \ b S (P ) ∪ Mk) = MSCC(P \ b S (P ) ∪ Mk).We observe that the programs Q = P \ b S (P ) ∪ Mk and P have the same atoms but in general different SCCs. However it is easy to see that every atom in a ∈ Sk induces a SCC Ca = {a} w.r.t. Q , and thus Sk = Ca1∪ · · · ∪ Ca(cid:12) where Sk = {a1, . . . , a(cid:12)}. Furthermore, Q contains only constraints r such that either At(Q ) ⊆ Sk or At(Q ) ∩ Sk = ∅. As (Ca1 , . . . , Ca(cid:12) , Ck+1, . . . Cn) is a topological ordering of SCC(Q ), we obtainSCC(Q ) = SEQ(Sa1 ,...,Sa(cid:12) ,Sk+1,...,Sn)(Q ) = SEQ(Sk+1,...,Sn)(Q ),M(cid:10)=where Sai(where Mk|Sa jQ \ b Sa jj≤i Ca j . The last equality can be seen by noting that, for each j = 1, . . . , (cid:12), we have SEQ(b Sa jdenotes the restriction of Mk to Sa j ) and thus for each ( X j, Y j) ∈ SEQ(b Sa j) ∪ (X j, Y j) = Q .(Q ) ∪ (X j, Y j) = (Q \ Mk|Sa j(Q )),(Q )) = {Mk|Sa j}In conclusion, by replacing in Equation (B.1) Mk ∈ Mk with (I, J ) ∈ MMSCC(P \ b Sk (P ) ∪ (I, J )) and reminding that Sk = S and P S (I, J ) = P \ b Sk (P ) ∪ (I, J ), we have proved thatSCC(b Sk (P )) and SEQ(Sk+1,...,Sn)(P \ b Sk (P ) ∪ Mk) with SCC(P ) = mcM(cid:13)(cid:11)M(I, J )∈MSCC (b S (P ))(cid:14)SCC(P \ b S (P ) ∪ (I, J )).(cid:2)(cid:16)≤ =Proof of Proposition 18. Suppose that S = (S1, . . . , Sn), where n ≥ 1. Then there exists a splitting sequence S, for every 1 ≤ i ≤ n; (Ssuch a sequence can be obtained by refining S i \ S i−1, 1 ≤ i ≤ n where S0 = ∅ along strongly connected components in (cid:16)n) induced by some topological ordering ≤ of SG(P ) such that S i = S, for some 1 ≤ ki ≤ n(cid:16)1, . . . , S(cid:16)ki(cid:16)266G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271SG(P ) to S i,1, . . . , S i, ji such that S i, jidiate consequence of Theorem 5 (for given ( X, Y ), SSCC (P ) =membership in SEQS (P )); the equation M= S i . As M(cid:16)(cid:16)SCC(P ) = SEQS(cid:16)(P ), the inclusion Mimposes more conditions for membership in SEQSS∈SQ(P )SEQS (P ) follows as S(cid:16) ∈ SQ(P ). (cid:2)SCC (P ) ⊆ SEQS (P ) is then an imme-(P ) than S for (cid:16)Proof of Theorem 8. For the proof of Theorem 8, we use the following lemmas.Lemma 19. Let P be a program. Let M J C(P ) = { J 1, . . . , J m}. Let ( J 1, . . . , J i−1, J i, J i+1, J i+2, . . . , J m) and ( J 1, . . . , J i−1, J i+1, J i,J i+2, . . . , J m) be two topological orderings. If we put Sk = J 1 ∪ . . . ∪ J k for k = 1, . . . , m and S= S i−1 ∪ J i+1 then(cid:16)i(P \ b S i−1 (P )) = b S i+1 (P \ b S i (P )).b S(cid:16)i(cid:16)iProof. In general we know that b S i (P ) \ b S i−1 (P ) = b S i (P \ b S i−1 (P )). So that is sufficient to prove that b S i+1 (P ) \ b S i (P ) =b S(P ) \ b S i−1 (P ).Let r ∈ P . We assume that r ∈ b S i+1 (P ) and r /∈ b S i (P ).If r is not a constraint, then there exists some a ∈ H(r) such that a ∈ J i+1. But because there is no edge among J i and J i+1, we obtain that At(r) ∩ J i = ∅. Therefore r ∈ b S i−1∪ J i+1 (P ) and clearly r /∈ b S i−1 (P ).+(r) ∪ B+(r) ∪ BIf r is a constraint then there exists a ∈ (B−(r)) ∩ J i+1. If, by contradiction, we assume that there exists some −(r)) ∩ J i , then there exist K i, K i+1 ∈ SCC(P ) such that K i+1 ⊆ J i+1 and K i ⊆ J i with r ∈ C K i ,K i+1 (P ). But b ∈ (Bbecause there is no edge among J i and J i+1, then there exists a topological ordering of strongly connected components of P that are in J i and J i+1, such that K i precedes K i+1. So there exists (C1, . . . , Cn) ∈ O(P ) in which Cl = K i and Cl+1 = K i+1for some l = 1, . . . , n − 1 and moreover At(r) ⊆ C1 ∪ . . . ∪ Cl+1. Then (K i, K i+1) is a joinable pair and therefore K i, K i+1−(r)) ∩ J i = ∅. That is are joinable components, but this contradicts the maximality of J i and J i+1. So that (Br ∈ b S i−1∪ J i+1 (P ) and clearly r /∈ b S i−1 (P ).Conversely we assume that r ∈ b S i−1∪Ci+1 (P ) and r /∈ b S i−1 (P ). Then r ∈ b S i−1∪Ci+1 (P ) ⊆ b S i+1 (P ). Moreover r ∈+(r) ∪ Bb S i−1∪Ci+1 (P ) implies that At(r) ∩ Ci = ∅, and because r /∈ b S i−1 (P ), then r /∈ b S i (P ). (cid:2)Lemma 20. Let P be a program. Let MJ C(P ) = { J 1, . . . , J m}. Let ( J 1, . . . , J i−1, J i, J i+1, J i+2, . . . , J m) and ( J 1, . . . , J i−1, J i+1,J i, J i+2, . . . , J m) be two topological orderings. If we put Sk = J 1 ∪ . . . ∪ J k for k = 1, . . . , m and S= S i−1 ∪ J i+1 then(cid:16)iSEQ(S1,...,S i−1,S i ,S i+1,S i+2,...,Sm)(P ) = SEQ(S1,...,S i−1,S(cid:16)i ,S i+1,S i+2,...,Sm)(P ).Proof. The proof is mutatis mutandis the same as that of Lemma 18, and one identifies b Susing Lemma 19 instead of Lemma 15. (cid:2)(cid:16)i(P \ b S i−1 (P )) and b S i+1 (P \ b S i (P ))The proof of Theorem 8 is the same as that of Theorem 6, but uses Lemma 20 instead of Lemma 18. (cid:2)Proof of Theorem 9. The proof is very similar to the one of Theorem 7: under the premise, the MJCs which form S re-spectively the SCCs constituting them are in the initial segment of some topologic ordering, like the SCCs in the proof of Theorem 7. Thus the same line of argumentation applies. (cid:2)Proof of Proposition 19. The proof is analogous to the one of Proposition 18. Similarly, for every MJ C-compatible split (cid:16)(cid:16)sequence S = (S1, . . . , Sn), n ≥ 1, an MJ C-split sequence Sn) induced by some topological ordering ≤ of ≤ = (S(cid:16)by refining S i \ S i−1, 1 ≤ i ≤ nJG(P ) exists such that S i = Skiwhere S0 = ∅ along maximal joined components in JP(P ) to S i,1, . . . , S i, ji such that S i, ji(P ), M(cid:16)1, . . . , S, for every 1 ≤ i ≤ n; we can obtain SMJ C(P ) ⊆ SEQS (P ) follows from Theorem 5, and M= S i . As MSEQS (P ) follows as SMJ C(P ) = SEQS(cid:16) ∈ MSQ(P ). (cid:2), for some 1 ≤ ki ≤ nMJ C(P ) =(cid:16)(cid:16)(cid:16)(cid:16)S∈MSQ(P )Appendix C. Section 7C.1. Hardness results for semi-equilibrium semanticsSeveral results about Problem MCH and INF for disjunctive program under semi-equilibrium model semantics (S =( At(P ))) can be shown using a reduction from deciding the validity of a quantified Boolean formula (QBF) of the form(cid:13) = ∃Z ∀Y ∃X.E(X, Y , Z )where X = {x1 . . . xr}, Y = { y1 . . . ys} and Z = {z1 . . . zt}. We may assume without loss of generality that E( X, Y , Z ) =(cid:17)i=1(li1 ∨ li2 ∨ li3) where each li j is a literal over X ∪ Y ∪ Z (i.e., 3-CNF form). We define a program P 0 with the following mrules:G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2712671. p ← l∗i1, l∗i2, l∗i3, where l∗i j=(cid:18)v, if li j = vv, if li j = ¬vand v ∈ X ∪ Y ∪ Z ;2. x ← p and x ← p for each x ∈ X ;3. y ∨ y for each y ∈ Y ;4. x ∨ x for each x ∈ X .We assume for the moment that Z is void (i.e., Z = ∅); then one can show the following property [16]:Some M ∈ MM(P 0) exists s.t. p ∈ M iff ¬(∀Y ∃X.E(X, Y )) is true.(C.1)As P 0 is positive, SEQ(P 0) = {(M, M) | M ∈ MM(P 0)}; it follows from this that brave reasoning from the SEQ-models of a positive disjunctive program, i.e., deciding P |=b,t2 -hard; furthermore, cautious reasoning P |=c,fNow we construct a new program P 1 that is obtained by adding a fresh atom q in each rule head of P 0 and the following SEQ p, is (cid:4)PSEQ p, is (cid:3) P2 -hard.rules:(cid:16) ← p and5. p6. ← not p.(cid:16)It is easy to see that {q} is a minimal model of P 1. Now the following property holds:(cid:16)}) ∈ SEQ(P 1) if and only if ∀Y ∃X.E(X, Y ) is true.({q} , {q, p(C.2)Clearly, the program is stratified; consequently, Problem MCH under SEQ-semantics is (cid:4)Pdisjunctive programs, which proves the hardness part of item (ii) in Theorem 10.2 -hard for disjunctive and stratified Eventually, we consider the target case in which Z (cid:12)= ∅. We construct a final program P given by the union of P 1 with the following rules:7. z ∨ z for each z ∈ Z and8. ← z, not bz and ← z, not bz for each z ∈ Z where bz and bz are fresh atoms.Intuitively, the effect of these rules is that in each SEQ-model (I, J ), either bz or bz but not both must be contained in (cid:16) ⊆ Z , the HT-interpretation (I Z , J Z ) = ({bz |gap(I, J ), for each z ∈ Z ; this serves to emulate quantification over Z . For each Z(cid:16)) is z ∈ Ztrue. Formally, one can show:(cid:16)}) is a HT-model of P ; it will be a SEQ-model of P precisely if ∀Y ∃ X.E( X, Y , Z = Z(cid:16)} ∪ {bz | z ∈ Z \ Z(cid:16)} ∪ {q}, {q, pSome (I, J ) ∈ SEQ(P ) exists s.t. p(cid:16) ∈ J \ I iff (cid:13) = ∃Z ∀Y ∃X.E(X, Y , Z ) is true.(C.3)Note that the program P is stratified; it follows that brave reasoning under SEQ-semantics is (cid:3) P3 -hard for disjunctive and stratified disjunctive programs; this proves the respective hardness parts of item (i) in Theorem 11. For cautious reasoning from disjunctive and stratified disjunctive programs under SEQ-semantics, (cid:4)P3 -hardness of item (ii) in Theorem 11 is shown by a slight extension of the reduction, which is carried out in Appendix C.2 to derive this result for fixed truth value v.C.2. Hardness results for problem INF with fixed truth valueC.2.1. Brave reasoningThe construction in Section 7.2 for normal, stratified normal and hcf programs uses bt, but in no SEQ-model any atom is true (all rules are constraints); thus we can add b ← not a and ask for b about the truth value f, and add further c ← not band ask for c about the truth value t.For disjunctive programs, we consider the (cid:3) PThen for the program P constructed from the QBF (cid:13) and the particular atom q, we have that P |=b,tSEQ q is equivalent to P |=b,btevaluates to true, and P |=b,t(cid:16) = P ∪ {qthe program P ; if we let PSEQ qfrom the SEQ-models of a (stratified) disjunctive program is (cid:3) Parbitrary splitting sequences S.3 -hardness proof for brave reasoning under SEQ-semantics in Appendix C.1. SEQ q iff the QBF (cid:13). Furthermore, q has never value bt in the SEQ-models of SEQ q. So for each fixed value v, brave inference 3 -hard; this trivially generalizes to SEQ-models relative to (cid:16) ← not q}, then PSEQ p(cid:16) |=b,fiff P |=b,t(cid:16)(cid:16)C.2.2. Cautious reasoningFor fixed truth value v = bt, the cautious inference problem is for SEQ-models easier than for a truth value given in the input:Proposition 25. Given a program P and an atom a, deciding whether P |=c,btand hcf P and (ii) in (cid:4)p2 for disjunctive P .SEQ a is (i) in coNP for each of normal, normal stratified, 268G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271This holds because in this case, P (cid:12)|=c,btSEQ a iff some h-minimal HT-model ( X, Y ) of P exists such that a /∈ Y \ X ; such a h-minimal model can be guessed and verified in polynomial time in case (i) resp. in polynomial time with an NP oracle in case (ii).For the other truth values, the construction in Section 7.2 for normal, stratified normal and hcf programs uses truth value f for cautious reasoning, and as in no SEQ-model any atom is true, we can add b ← not a and ask whether b has cautiously value t; if we add another split layer with a rule b ← not b, not a (such that S = (S 1, S2) and b ∈ S2 \ S1), then we can ask whether b has cautiously value bt.Regarding disjunctive programs, we had above in the programs P and P(cid:16)for brave reasoning with fixed truth values tand always true or false; so we 3 -hardness for cautious reasoning. If we add another split layer with b ← not b, p similarly as whose truth values are opposite in the SEQ-models of P(cid:16)and f query atoms q resp. qimmediately obtain the (cid:4)Pabove, then we can ask whether b has cautiously value bt.(cid:16)C.3. Constructing and recognizing canonical splitting sequences(cid:16)m(cid:16)1, . . . , KProof of Proposition 20. Let P be a program. First we prove that conditions (i) and (ii) in Definition 12 imply that there is no path from K1 to K2 and vice versa. By contradiction, first suppose that there is a path from K 1 to K2, i.e., there (cid:16)(cid:16)∈ SCC(P ) such that K1 = Ki+1) ∈ E SG for 1 ≤ i < m. As in each topological ordering 1, Kexist K(cid:16)(cid:16)(C1, . . . , Cn) ∈ O(SG(P )) Ki , for 1 ≤ i < m, it follows that K2 precedes K1, which contradicts condition i+1 must precede K(cid:16)∈ SCC(P ) be an arbitrary such path, (i). Otherwise, suppose that there exists some path from K 2 to K1. Let Km= K1. By condition (ii) we know that (K2, K1) /∈ E SG. Hence m > 2 and i.e., K(cid:16)(cid:16)m−i precedes Km−1K2, which contradicts condition (i).(cid:16)i+1) ∈ E SG for 1 ≤ i < m and K(cid:12)= K2; thus in every topological ordering (C1, . . . , Cn) ∈ O(SG(P )), K1 precedes K(cid:16)= K2, (K1(cid:16)(cid:12)= K1, Km−1(cid:16)m−i and K= K2 and (K(cid:16)1, . . . , K(cid:16)i , K(cid:16)i , K(cid:16)m(cid:16)mNow we prove that the disconnectedness hypothesis implies conditions (i) and (ii). As there is no path from K 2 to K1, condition (ii) trivially holds. Moreover for each topological ordering of SCC(P ) there exist maximal (possibly empty) sets (cid:16)Ai ⊆ SCC(P ) such that for each Ki precedes K i , i = 1, 2. Because there is no path from K1 to K2, it follows that K2 /∈ A1 and because there is no path from K2 to K1, it follows that K1 /∈ A2. Therefore we can construct a topological ordering in which all strongly connected components in A1 ∪ A2 precede K1 (this is possible because if there exists some K ∈ A2 such that K1 precedes K , then K1 precedes K and K precedes K2; this contradicts the hypothesis that no path from K2 to K1 exists), and K1 precedes immediately K2, i.e., condition (i) holds (this is possible because there is no K ∈ A1 such that K2 precedes K ). (cid:2)∈ Ai , K(cid:16)iProof of Corollary 10. (⇒) If (K1, K2) is a joinable pair witnessed by r, then by Proposition 20 K1 and K2 are disconnected in SG(P ); i.e., they are incomparable in the partial order on SCC(P ) induced by SG(P ). By condition (iii), At(r) ⊆ C1 ∪ · · · ∪C s+1 holds with C s = K1 and C s+1 = K2; as every SCC C (cid:12)= K1, K2 such that At(r) ∩ C (cid:12)= ∅ occurs in C1, . . . , C s−1, no path in SG(P ) from C can reach K1 or K2; consequently, K1 and K2 are maximal SCCs in SG(P ) such that At(r) ∩ C (cid:12)= ∅.(⇐) Suppose without loss of generality that K1 = C1 and K2 = C2. Then, K1 and K2 must be disconnected; hence by Proposition 20, K1 and K2 satisfy condition (i) and (ii) of a joinable pair. Furthermore, as all Ci , C j , 1 ≤ i (cid:12)= j ≤ l, must be pairwise disconnected, by extending the argument in the proof of Proposition 20, we can build from a topological ordering ≤ = (C1, . . . , Cn) of SG(P ) another topological ordering of SG(P ) in which all SCCs in A =i=1 Ai ∪ {C3, . . . , Cl} precede K1 and K1 immediately precedes K2, where Ai = {K ∈ SCC(P ) | K < Ci}; this is possible since no K ∈ A exists such that K2 precedes K . As A ∪ {C1, C2} must contain all SCCs C such that At(r) ∩ C (cid:12)= ∅, it follows that condition (iii) holds; hence (K1, K2) is a joinable pair. (cid:2)(cid:10)l1, . . . , C rj from C rProof of Theorem 14. By Corollary 10, the joinable pairs (K1, K2), K1 (cid:12)= K2 witnessed by constraint r are given by all l computed in Step 2, 1 ≤ i (cid:12)= j ≤ l; hence, this collection is joinable, if l > 1; if l = 1, K 1 = C rC ri , C r1, 1 is trivially joinable. Thus, in Step 3 C r ∈ JC(P ) holds. Furthermore, merging J 1 and J 2 in Step 4 results in a set K2 = C rJ 1 ∪ J 2 ∈ JC(P ): by an inductive argument, all C rithat have been merged into J i , i = 1, 2 are joinable; thus if J 1 ∩ J 2 (cid:12)= ∅, jithen some J ∈ J 1 ∩ J 2 exists such that all (C r1, C) and (C, C r2j merged into J 1 ∪ J 2 are j2j1joinable and J 1 ∪ J 2 ∈ JC(P ). Finally, suppose that after Step 4 MJ C(P ) (cid:12)= MC ∪ (SCC(P ) \ NMI); by construction of MC(cid:16) ∈ MJ C(P ) and J ∈ MC ∪ (SCC(P ) \ NMI exist such and the maximality condition on MJ C(P ), it follows that some Jare joinable and that J ∈ MC must hold; otherwise, that J ⊂ Jj merged into J must be joinable to some SCC J, C rC merged into Jj, C were merged into (cid:16)(cid:16) (cid:12)= ∅, and hence Step 4 for MC would not have been completed, a contradiction. Thus some JMJ C(P ) = MC ∪ NMI holds. The correctness of the constructed JG(P ) is then obvious.. From Corollary 10, it follows that all SCCs C merged into Jj, C) is witnessed by some constraint ris a non-joinable SCC, which implies J = Jbut not into J ; as the joinable pair (C r(cid:16)(cid:16) ∈ MC; but this means J ∩ J) are joinable pairs; hence all C r. Furthermore, some SCC C r(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)Regarding the time complexity, we note the following:In Step 1, DG(P ), SCC(P ) and SG(P ) are constructable in linear time;We can compute the SCCs C r1, . . . , C rl efficiently, e.g. by using a stratified program P r with the following rules:1. r j ←, for each C j ∈ V SG such that C j ∩ At(r) (cid:12)= ∅;G. Amendola et al. / Artificial Intelligence 234 (2016) 219–2712692. r j ← ri and n_max_r j ← ri , for each (Ci, C j) ∈ E SG;3. max_r j ← r j, not n_max_r j , for each Ci ∈ V SG.Informally, the atom r j encodes reachability of the component C j in the SCC-graph from a component that contains atoms from the constraint r; max_r j and n_max_r j are used to single out the topmost (maximal) reached components using double negation. The single answer set of P r yields then the desired maximal components C rl ; as P r can be built and evaluated in linear time, Step 2 is feasible in linear time for each r.1, . . . , C rStep 3 is clearly feasible in linear time; also Step 4 (iterative merging the J 1, J 2) is feasible (if properly done) in linear time, and similarly Step 5 given MJ C(P ) and SG(P ).Thus in total, MJ C(P ) and JG(P ) are computable in time O(cs·(cid:25)P (cid:25)), which proves the result. (cid:2)Appendix D. Section 8EProof of Theorem 15. The proof proceeds as follows. We first show that (1) the models of Pmodels ( X, Y ) of P via ·Eh-minimal and (3) that every SEQ-model of P is among the models in (2), i.e., {( X, Y )E | ( X, Y ) ∈ SEQ(P )} ⊆ MM(Pthe E -violation set V(I) of any model I = ( X, Y )Efollows that I ∈ MM(Pof P .correspond to the HT-, the corresponding HT-model of P is E ). As corresponds to the gap of ( X, Y ) (precisely, V(I) = Egap( X, Y )), it E ) has a ⊆-minimal E -violation set, i.e., is an evidential stable model of P , iff ( X, Y ) is a SEQ-model ; next, we establish that (2) for every minimal model PAs for (1), it is readily seen that for every HT-model ( X, Y ) of P , I = ( X, Y )E = X ∪ E Y is a model of Pare satisfied as Y |= P , and all rules (3) as X ⊆ Y . Finally for the rules (1), as ( X, Y ) |= r, either H(r) ∩ X (cid:12)= ∅, or B(which implies BP: all rules (2) +(r) (cid:2) Y−(r) ∩ Y (cid:12)= ∅; hence I satisfies the rules (1). The proof of the converse, for every model I of +(r) (cid:2) X ), or Bof PEEEEE ), in particular no model J ⊂ I of PEexists such that I \ (cid:3) = J \ (cid:3); thus if β(I) = ( X, Y ), no , β(I) is a HT-model of P , is similar.Regarding (2), if I ∈ MM(PHT-model ( X(cid:16), Y ) of P exists such that X(cid:16) ⊂ X .As for (3), towards a contradiction assume that some ( X, Y ) ∈ SEQ(P ) fulfills I = ( X, Y )E /∈ MM(P(cid:16), YJ = ( XP Y ⊆ P Yby (2) ( X(cid:16)(cid:16))E ∈ MM(Pit follows that X(cid:16), YE ) exists such that J ⊂ I . As X(cid:16) ⊆ X , Y(cid:16) ⊆ Y , and ( X, Y ) is h-minimal, it follows that Y(cid:16) |= P Y ; since X ∈ MM(P Y ) and X(cid:16) ⊆ X , it follows X(cid:16) = X . Therefore, gap( X(cid:16), Y(cid:16)) is h-minimal, ( X, Y ) /∈ SEQ(P ), which is a contradiction. This proves the result. (cid:2)E ). Hence, some (cid:16) ⊂ Y . As (cid:16)) ⊂ gap( X, Y ); as Proof of Proposition 22. (⊆) If M = ( X, Y ) is a SEQ-model of P wf , then M is a h-minimal model of P wf and gap(M) ⊆gap(WF(P wf )) = gap(WF(P )). Corollary 11 implies that M (cid:26) WF(P wf )) = WF(P ) = (I, J ), and thus Y ⊆ J . By antimonotonicity of γP (.), we have γP (Y ) ⊇ γP ( J ) = I , and thus γP wf (Y ) = γP (Y ) ∪ I = γP (Y ) = X . Thus M is also a h-minimal model of P . (cid:16)) ⊂ gap(M) would be a If M were not a SEQ-model of P , then by Corollary 11 some refinement MSEQ-model of P . But Mwould then be a h-minimal model of P wf and contradict that M is a SEQ-model of P wf . Thus Mis a SEQ-model of P .of WF(P ) with gap(M(⊇) Let M be a SEQ-model of P such that gap(M) ⊆ gap(WF(P )). Then by Corollary 11 M refines WF(P ) and thus is of P wfis also a h-minimal model of P , which contradicts clearly a model of P wf , and moreover h-minimal. If M were not a SEQ-model of P wf , then some SEQ-model Mwith smaller gap exists; we can then as in the case (⊆) infer that Mthat M is a SEQ-model of P . (cid:2)(cid:16)(cid:16)(cid:16)(cid:16)Proof of Proposition 23. Consider any splitting sequence S = (S1, S2, . . .) of the program P and let M = ( X, Y ) be any SEQ-model of P such that M (cid:26) WF(P ) (by Corollary 11 such an M exists). Let M1 = M|S1 and P 1 = b S1 (P ).Then, M1 is a HT-model of P 1 and moreover h-minimal for P 1 (for otherwise, M would not be h-minimal for P : we could make X on S1 smaller, as we can keep the same valuation for the atoms in (cid:3) \ S1; note that P Y is positive and atoms from S1 occur in t S1 (P ) only in rule bodies). Furthermore, we have M1 (cid:26) WF(P )|S1 . Now some SEQ-model N1 = ( X1, Y 1) of P 1must exist such that gap(N1) ⊆ gap(M1); as gap(M1) ⊆ gap(WF(P )|S1 ), Corollary 11 and Lemma 5 imply that N1 (cid:26) WF(P 1)(observe that WF(P )|S1= WF(P 1), which follows from items 1 and 2 of Lemma 5).If we consider the program P 2 = P S1 ( X1, Y 1), then by an inductive argument on the length of the splitting sequence it (cid:16) = (S2, . . . , Sn) such that N2 (cid:26) WF(P 2), provided WF(P 2) exists; however, P S1 ( X1, Y 1) adds has some SCC-model N2 w.r.t. Sa constraint ← not a for each a ∈ Y 1 \ X1, and as a does not occur in any rule head of P 2, WF(P 2) does not exist if X1 ⊂ Y 1. To address this, we use in the argument a variant of the transformation P S1 ( X1, Y 1), denoted ˆP S1 ( X1, Y 1), that adds a rule a ← not a for each a ∈ Y 1 to P S1 ( X1, Y 1); clearly, P S1 ( X1, Y 1) and ˆP S1 ( X1, Y 1) have the same splitting sets and the same SEQ-models w.r.t. any splitting sequence; let ˆP 2 = ˆP S1 ( X1, Y 1). Then we claim that WF( ˆP 2) exists and WF( ˆP 2) (cid:26) WF(P )denotes the (constraint-free) holds. Indeed, consider the constraint-free part Pof P ; then WF(Pall constraints of P , program for Pthen the resulting program Q fulfills WF(Q ) = WF(P ). If we modify Q by (i) adding from ˆP S1 ( X1, Y 1) all facts a ∈ X1 and all constraints {a ← not a | a ∈ Y 1} ∪ {← a | a ∈ S1 \ Y 1}, and (ii) remove all rules a ← not a such that a ∈ S1 \ Y 1, the resulting (cid:16)(cid:16)) exists, as assigning any atoms in gap(WF(P )) true or false program Qdoes not affect the already assigned atoms. But as every constraint r in P has some body literal that is false in WF(P ), this holds also for Qaccording to item 2 of Lemma 5, we have WF(Q(cid:16)(cid:16)) exists. Now we note that Q(cid:16)(cid:16)) (cid:26) WF(Q ) = WF(P ) if WF(Q(cid:16)) = WF(P ). If we add to Q(cid:16)(cid:16) = ˆP 2; this proves the claim.(cid:16)) = WF(P ) and, if Qis such that WF(Q, and thus WF(Q(cid:16)) = WF(P(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)270G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271Consequently, N2 is an SCC-model of ˆP 2 and N2 (cid:26) WF( ˆP 2) (cid:26) WF(P ) holds. Now the SEQS -models of P are, by defini-tion,(cid:13)(cid:11)SEQS (P ) = mc= mc( X,Y )∈SEQ(b S1 (P ))(cid:11)(cid:13)( X,Y )∈SEQ(b S1 (P ))(cid:16)(cid:16)SEQSSEQS(cid:14)(P S1 (X, Y )(cid:14)( ˆP S1 (X, Y ).(cid:16)) ⊆ gap(WF(P )), it follows from Corollary 11 that NIf the model N2 appears in this set, then it is an SEQS -model of P that refines WF(P ) and proves the first claim of the proposition. Otherwise, some SEQS -model Nis a SEQ-model of P and of P must exist such that gap(N(cid:16) (cid:26) WF(P ), and also in this case an SEQS -model of P that refines gap(NWF(P ) exists; this proves the first claim of the proposition. As for the second claim, by Corollary 11 every SEQ-model Mof P , and thus in particular every SEQS -model M of P such that gap(M) ⊆ gap(WF(P )) satisfies M (cid:26) WF(P ); thus if we let M in the argument above be an arbitrary SEQS -model of P , we arrive at N2 = M and thus the second claim holds. This proves the result. (cid:2)(cid:16)) ⊂ gap(N2); as N(cid:16)(cid:16)References[1] J. Alcântara, C.V. Damásio, L.M. Pereira, A declarative characterization of disjunctive paraconsistent answer sets, in: R.L. de Mántaras, L. Saitta (Eds.), Proc. 16th European Conf. Artificial Intelligence (ECAI 2004), IOS Press, 2004, pp. 951–952.[2] G. Amendola, T. Eiter, N. Leone, Modular paracoherent answer sets, in: E. Fermé, J. Leite (Eds.), Proc. 14th European Conf. Logics in Artificial Intelligence (JELIA 2014), in: LNCS/LNAI, vol. 8761, Springer, 2014, pp. 457–471.[3] K. Apt, H. Blair, A. Walker, Towards a theory of declarative knowledge, in: Minker [36], pp. 89–148.[4] M. Balduccini, M. Gelfond, Logic programs with consistency-restoring rules, in: J. McCarthy, M.A. Williams (Eds.), International Symp. Logical Formal-ization of Commonsense Reasoning, in: AAAI 2003 Spring Symposium Series, 2003, pp. 9–18.[5] C. Baral, V.S. Subrahmanian, Dualities between alternative semantics for logic programming and nonmonotonic reasoning, J. Autom. Reason. 10 (3) (1993) 399–420.[6] C. Baral, Knowledge Representation, Reasoning and Declarative Problem Solving, Cambridge Univ. Press, 2003.[7] C. Baral, G. Greco, N. Leone, G. Terracina (Eds.), Proc. 8th International Conf. Logic Programming and Nonmonotonic Reasoning (LPNMR 2005), Diamante, Italy, September 5–8, 2005, Lect. Notes Comput. Sci., vol. 3662, Springer, 2005.[8] R. Ben-Eliyahu, R. Dechter, Propositional semantics for disjunctive logic programs, Ann. Math. Artif. Intell. 12 (1994) 53–87.[9] H.A. Blair, V.S. Subrahmanian, Paraconsistent logic programming, Theor. Comput. Sci. 68 (2) (1989) 135–154.[10] G. Brewka, T. Eiter, Equilibria in heterogeneous nonmonotonic multi-context systems, in: Proc. 22nd Conf. Artificial Intelligence (AAAI ’07), Vancouver, July 22–26, 2007, AAAI Press, 2007, pp. 385–390.[11] G. Brewka, T. Eiter, M. Truszczy ´nski, Answer set programming at a glance, Commun. ACM 54 (12) (2011) 92–103.[12] J. de Bruijn, D. Pearce, A. Polleres, A. Valverde, A semantical framework for hybrid knowledge bases, Knowl. Inf. Syst. 25 (1) (2010) 81–104.[13] P. Cabalar, S.P. Odintsov, D. Pearce, Logical foundations of well-founded semantics, in: P. Doherty, J. Mylopoulos, C.A. Welty (Eds.), Proc. 10th Interna-tional Conf. Principles of Knowledge Representation and Reasoning (KR 2006), AAAI Press, 2006, pp. 25–35.[14] P. Cabalar, S.P. Odintsov, D. Pearce, A. Valverde, Partial equilibrium logic, Ann. Math. Artif. Intell. 50 (3–4) (2007) 305–331.[15] M. Dao-Tran, T. Eiter, M. Fink, T. Krennwallner, Modular nonmonotonic logic programming revisited, in: P. Hill, D. Warren (Eds.), Proc. 25th International Conf. Logic Programming (ICLP 2009), in: Lect. Notes Comput. Sci., vol. 5649, Springer, 2009, pp. 145–159.[16] T. Eiter, G. Gottlob, On the computational cost of disjunctive logic programming: propositional case, Ann. Math. Artif. Intell. 15 (3/4) (1995) 289–323.[17] T. Eiter, M. Fink, J. Moura, Paracoherent answer set programming, in: Proc. 12th International Conf. Principles on Knowledge Representation and Reasoning (KR 2010), AAAI Press, 2010, pp. 486–496.[18] T. Eiter, G. Ianni, R. Schindlauer, H. Tompits, A uniform integration of higher-order reasoning and external evaluations in answer set programming, in: L.P. Kaelbling, A. Saffiotti (Eds.), Proc. 19th International Joint Conf. Artificial Intelligence (IJCAI-05), Professional Book, Center, 2005, pp. 90–96.[19] T. Eiter, N. Leone, D. Saccà, On the partial semantics for disjunctive deductive databases, Ann. Math. Artif. Intell. 19 (1/2) (1997) 59–96.[20] W. Faber, G. Greco, N. Leone, Magic sets and their application to data integration, J. Comput. Syst. Sci. 73 (4) (2007) 584–609.[21] P. Ferraris, Answer sets for propositional theories, in: Baral et al. [7], pp. 119–131.[22] P. Ferraris, V. Lifschitz, Weight constraints as nested expressions, Theory Pract. Log. Program. 5 (1–2) (2005) 45–74.[23] M. Fink, Paraconsistent hybrid theories, in: G. Brewka, T. Eiter, S.A. McIlraith (Eds.), KR, AAAI Press, 2012, pp. 391–401.[24] M. Gebser, R. Kaminski, B. Kaufmann, T. Schaub, Answer Set Solving in Practice. Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan & Claypool Publishers, 2012.[25] M. Gebser, J. Pührer, T. Schaub, H. Tompits, A meta-programming technique for debugging answer-set programs, in: Proc. 23rd Conf. Artificial Intelli-gence (AAAI 2008), Chicago, Illinois, USA, AAAI Press, 2008, pp. 448–453.[26] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Gener. Comput. 9 (1991) 365–385.[27] A. Heyting, Die formalen Regeln der intuitionistischen Logik, Sitz.ber. Preuss. Akad. Wiss. 16 (1) (1930) 42–56.[28] S. Huang, Q. Li, P. Hitzler, Reasoning with inconsistencies in hybrid MKNF knowledge bases, Log. J. IGPL 21 (2) (2013) 263–290.[29] T. Janhunen, E. Oikarinen, H. Tompits, S. Woltran, Modularity aspects of disjunctive stable models, J. Artif. Intell. Res. 35 (2009) 813–857.[30] A.C. Kakas, P. Mancarella, Generalized stable models: a semantics for abduction, in: Proc. 9th Eureopean Conf. Artificial Intelligence (ECAI 1990), IOS Press, 1990, pp. 385–391.[31] V. Lifschitz, H. Turner, Splitting a logic program, in: Proc. International Conf. Logic Programming (ICLP-94), MIT Press, 1994, pp. 23–38.[32] V. Lifschitz, D. Pearce, A. Valverde, Strongly equivalent logic programs, ACM Trans. Comput. Log. 2 (4) (2001) 526–541.[33] V. Lifschitz, L.R. Tang, H. Turner, Nested expressions in logic programs, Ann. Math. Artif. Intell. 25 (3–4) (1999) 369–389.[34] V. Lifschitz, T.Y.C. Woo, Answer sets in general nonmonotonic reasoning (preliminary report), in: B. Nebel, C. Rich, W.R. Swartout (Eds.), Proc. 3rd International Conf. Principles of Knowledge Representation and Reasoning (KR’92), Cambridge, MA, October 25–29, 1992, Morgan Kaufmann, 1992, pp. 603–614.[35] V.W. Marek, A. Nerode, J.B. Remmel, Logic programs, well-orderings, and forward chaining, Ann. Pure Appl. Log. 96 (1–3) (1999) 231–276.[36] J. Minker (Ed.), Foundations of Deductive Databases and Logic Programming, Morgan Kaufman, Washington, DC, 1988.G. Amendola et al. / Artificial Intelligence 234 (2016) 219–271271[37] S.P. Odintsov, D. Pearce, Routley semantics for answer sets, in: Baral et al. [7], pp. 343–355.[38] J. Oetsch, J. Pührer, H. Tompits, Stepwise debugging of description-logic programs, in: Correct Reasoning – Essays on Logic-Based AI in Honour of Vladimir Lifschitz, in: Lect. Notes Comput. Sci., vol. 7265, Springer, 2012, pp. 492–508.[39] M. Osorio, J.R.A. Ramírez, J.L. Carballido, Logical weak completions of paraconsistent logics, J. Log. Comput. 18 (6) (2008) 913–940.[40] D. Pearce, Equilibrium logic, Ann. Math. Artif. Intell. 47 (1–2) (2006) 3–41.[41] D. Pearce, A. Valverde, Quantified equilibrium logic and foundations for answer set programs, in: M.G. de la Banda, E. Pontelli (Eds.), Proc. 24th International Conf. Logic Programming (ICLP 2008), in: Lect. Notes Comput. Sci., vol. 5366, Springer, 2008, pp. 546–560.[42] L.M. Pereira, J.J. Alferes, J.N. Aparício, Contradiction removal semantics with explicit negation, in: M. Masuch, L. Pólos (Eds.), International Conf. Logic at Work: Knowledge Representation and Reasoning Under Uncertainty, in: Lect. Notes Comput. Sci., vol. 808, Springer, 1992, pp. 91–105.[43] L.M. Pereira, A.M. Pinto, Revised stable models – a semantics for logic programs, in: C. Bento, A. Cardoso, G. Dias (Eds.), Proc. 12th Portuguese Conf. Artificial Intelligence (EPIA 2005), in: Lect. Notes Comput. Sci., vol. 3808, Springer, 2005, pp. 29–42.[44] L.M. Pereira, A.M. Pinto, Approved models for normal logic programs, in: N. Dershowitz, A. Voronkov (Eds.), Proc. 14th International Conf. Logic for Programming, Artificial Intelligence, and Reasoning (LPAR 2007), in: Lect. Notes Comput. Sci., vol. 4790, Springer, 2007, pp. 454–468.[45] L.M. Pereira, A.M. Pinto, Layered models top-down querying of normal logic programs, in: A. Gill, T. Swift (Eds.), Proc. 11th International Symposium on Practical Aspects of Declarative Languages (PADL 2009), in: Lect. Notes Comput. Sci., vol. 5418, Springer, 2009, pp. 254–268.[46] T.C. Przymusinski, On the declarative semantics of deductive databases and logic programs, in: Minker [36], pp. 193–216.[47] T.C. Przymusinski, Stable semantics for disjunctive programs, New Gener. Comput. 9 (1991) 401–424.[48] D. Saccà, C. Zaniolo, Partial models and three-valued stable models in logic programs with negation, in: V. Subrahmanian (Ed.), Proc. First Workshop on Logic Programming and Nonmonotonic Reasoning (LPNMR 1991), MIT Press, 1991, pp. 87–101.[49] C. Sakama, K. Inoue, Paraconsistent stable semantics for extended disjunctive programs, J. Log. Comput. 5 (3) (1995) 265–285.[50] C. Sakama, K. Inoue, An abductive framework for computing knowledge base updates, Theory Pract. Log. Program. 3 (6) (2003) 671–713.[51] D. Seipel, Partial evidential stable models for disjunctive deductive databases, in: J. Dix, L.M. Pereira, T.C. Przymusinski (Eds.), Proc. Third International Workshop on Logic Programming and Knowledge Representation (LPKR ’97), Selected Papers, in: Lect. Notes Comput. Sci., vol. 1471, Springer, 1997, pp. 66–84.[52] T. Syrjänen, Debugging inconsistent Answer-Set Programs, in: Proc. 11th International Workshop on Nonmonotonic Reasoning (NMR 2006), TU Clausthal, Dept. Informatics, 2006, pp. 77–83, Tech. Rep. IfI-06-04.[53] R.E. Tarjan, Depth-first search and linear graph algorithms, SIAM J. Comput. 1 (2) (1972) 146–160.[54] H. Turner, Strong equivalence made easy: nested expressions and weight constraints, Theory Pract. Log. Program. 3 (4–5) (2003) 609–622.[55] A. van Gelder, The alternating fixpoint of logic programs with negation, J. Comput. Syst. Sci. 47 (1) (1993) 185–221.[56] A. van Gelder, K. Ross, J. Schlipf, The well-founded semantics for general logic programs, J. ACM 38 (3) (1991) 620–650.[57] K. Wang, L. Zhou, Comparisons and computation of well-founded semantics for disjunctive logic programs, ACM Trans. Comput. Log. 6 (2) (2005) 295–327.[58] Y. Wang, M. Zhang, J.H. You, Logic programs, compatibility and forward chaining construction, J. Comput. Sci. Technol. 24 (6) (2009) 1125–1137.[59] J.H. You, L. Yuan, A three-valued semantics for deductive databases and logic programs, J. Comput. Syst. Sci. 49 (1994) 334–361.