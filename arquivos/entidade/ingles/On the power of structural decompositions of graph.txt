Artificial Intelligence 174 (2010) 382–409Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintOn the power of structural decompositions of graph-basedrepresentations of constraint problemsGianluigi Greco a, Francesco Scarcello b,∗a Dept. of Mathematics, Università della Calabria, I-87036 Rende, Italyb DEIS, Università della Calabria, I-87036 Rende, Italya r t i c l ei n f oa b s t r a c tArticle history:Received 21 January 2009Received in revised form 14 December 2009Accepted 17 December 2009Available online 4 January 2010Keywords:Constraint satisfactionDecomposition methodsHypergraphsDual graphsIncidence graphsPrimal graphsTreewidthThe Constraint Satisfaction Problem (CSP) is a centralissue of research in ArtificialIntelligence. Due to its intractability, many efforts have been made in order to identifytractable classes of CSP instances, and in fact deep and useful results have already beenachieved. In particular, this paper focuses on structural decomposition methods, which areessentially meant to look for near-acyclicity properties of the graphs or hypergraphs thatencode the structure of the constraints interactions. In general, constraint scopes comprisean arbitrary number of variables, and thus this structure may be naturally encoded viahypergraphs. However, in many practical applications, decomposition methods are appliedover suitable graph representations of the (possibly non-binary) CSP instances at hand.Despite the great interest in such binary approaches, a formal analysis of their power, interms of their ability of identifying islands of tractability, was missing in the literature.The aim of this paper is precisely to fill this gap, by studying the relationships amongbinary structural methods, and by providing a clear picture of the tractable fragmentsof CSP that can be specified with respect to each of these decomposition approaches,when they are applied to binary representations of non-binary CSP instances. In particular,various long-standing questions about primal, dual and incidence graph encodings areanswered. The picture is then completed by comparing methods on binary encodings withmethods specifically conceived for non-binary constraints.© 2009 Elsevier B.V. All rights reserved.1. Introduction and summary of resultsConstraint satisfaction is a central issue of research in Artificial Intelligence and other areas of computer science and ithas, in fact, an impressive spectrum of applications ranging from scheduling with preferences and deadlines, to temporalreasoning, machine learning, and plan design, just to cite a few. Formally, a constraint (S i, R i) consists of a constraintscope S i , i.e., a list of variables, and of an associated constraint relation ri containing the legal combinations of values forthe variables in S i . An instance of a constraint satisfaction problem (CSP), also called constraint network [6], is a triple I =(Var, U , C), where Var is a finite set of variables, U is a finite domain of values, and C = {C1, C2, . . . , Cq} is a finite set ofconstraints. A solution to a CSP instance is a substitution ϑ : Var −→ U , such that all constraints are simultaneously satisfied,i.e., for each 1 (cid:2) i (cid:2) q, S iϑ ∈ ri . By solving a CSP we mean determining whether the problem has a solution at all (i.e.,checking for constraint satisfiability) and, if so, computing one solution.* Corresponding author. Tel.: +39 0984 494752, fax: +39 0984 494713.E-mail addresses: ggreco@mat.unical.it (G. Greco), scarcello@deis.unical.it (F. Scarcello).0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2009.12.004G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409383Fig. 1. (a) A solution to the 4-queens problem, and (b) a crossword puzzle.Example 1.1 (n-queens). Consider the problem of placing n queens on (the n rows of) a chessboard so that no queen cancapture any other queen. This problem can be formalized as a constraint satisfaction problem as follows. The set Var containsa variable Q i for each queen to be placed in the i-th row, U = {1, . . . , n} represents the columns where each queen can beplaced, and for each pair of distinct queens Q i and Q j , the set C contains the constraint Ci, j = ((Q i, Q j), {(cid:5)pi, p j(cid:6) | pi (cid:7)=p j ∧ |pi − p j| (cid:7)= |i − j|}) stating, intuitively, that any two queens can be placed neither on the same column, nor on thesame diagonal of the board.As an example, for n = 3 the problem does not admit solutions. Instead, for n = 4, a possible solution is the substitutionϑ such that Q 1ϑ = 3, Q 2ϑ = 1, Q 3ϑ = 4, and Q 4ϑ = 2. This solution is depicted in Fig. 1(a).Note that in the n-queens problem each constraint is defined over two variables at most, and this is therefore an exampleof binary CSP. In other scenarios, instead, it is much more natural to define constraints over more than two variables, therebyleading to the general case of non-binary CSPs.Example 1.2 (Crossword puzzle). Fig. 1(b) shows a combinatorial crossword puzzle (taken from [10]), which is a typical non-binary CSP [6]. A set of legal words is associated to each horizontal or vertical array of white boxes delimited by blackboxes. A solution to the puzzle is an assignment of a letter to each white box such that to each white array is assigned aword from its set of legal words. This problem can be recast in a CSP as follows. There is a variable Xi for each white box,and a constraint C for each array D of white boxes. (For simplicity, we just write the index i for variable Xi .) The scope ofC is the list of variables corresponding to the white boxes of the sequence D, and the relation of C contains the legal wordsfor D.For the example, in Fig. 1, we have C1H = ((1, 2, 3, 4, 5), r1H ), C8H = ((8, 9, 10), r8H ), C11H = ((11, 12, 13), r11H ), C20H =((20, 21, 22, 23, 24, 25, 26), r20H ), C1V = ((1, 7, 11, 16, 20), r1V ), C5V = ((5, 8, 14, 18, 24), r5V ), C6V = ((6, 10, 15, 19, 26), r6V ),C13V = ((13, 17, 22), r13V ). Subscripts H and V stand for “Horizontal” and “Vertical,” respectively, resembling the usual nam-ing of definitions in crossword puzzles. A possible instance for the relation r1H is {(cid:5)h, o, u, s, e(cid:6), (cid:5)c, o, i, n, s(cid:6), (cid:5)b, l, o, c, k(cid:6)}.It is well known and easy to see that constraint satisfiability is an NP-complete problem, even when restricted overbinary instances (since it can encode, for example, graph colouring). Hence, much effort has been spent to identify tractableclasses of CSPs, and deep and useful results have already been achieved in the literature. In fact, the various successfulapproaches to single out tractable CSP classes can be divided into two main groups (see, e.g., [4,10]):(i) Techniques that look for tractable classes on the basis of the structure of the constraint scopes {S 1, . . . , Sq}, indepen-dently of the actual constraint relations r1, . . . , rq; and(ii) Techniques that exploit peculiar properties (such as combinatorial properties of the underlying algebras) of the con-straint relations r1, . . . , rq.In this paper, we shall deal with the former kind of techniques, usually called structural decomposition methods.1.1. Structural decomposition methodsMuch of the nature of constraint scope interactions can be captured using the constraint hypergraph H(I) = (V , H)associated to any CSP instance I = (Var, U , C), where V = Var and H = {var(S) | C = (S, r) ∈ C}, and var(S) denotes the setof variables in the scope S of the constraint C —in the following, we often denote the set of vertices V by N (H) and the setof hyperedges H by E(H). For instance, Fig. 2 shows the hypergraph Hcp associated to the crossword puzzle in Example 1.2.A fundamental property of hypergraphs is acyclicity (see, e.g., [2,9]). Indeed, it has been observed that constraint satis-fiability is feasible in polynomial time on the class of those CSP instances whose associated hypergraphs are acyclic (see,384G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409Fig. 2. Hypergraph Hcp of the crossword puzzle in Example 1.2.e.g., [10]). However, in practice, constraint hypergraphs are hardly acyclic (for instance, the hypergraph Hcp in Fig. 2 is notacyclic), even though not very intricate. Therefore, there is a great deal of interest in the literature in identifying tractableclasses of constraint satisfaction problem instances by looking for nearly acyclic structures, as for they can be characterizedvia structural decomposition methods (see, e.g., [5,6,10,22]). These methods aim at transforming a given cyclic hypergraphinto an acyclic one, by organizing its edges or its nodes into a polynomial number of clusters, and by suitably arrangingthese clusters as a tree, called a decomposition tree. The original problem instance can then be evaluated over the decom-position tree, with a cost that is exponential in the cardinality of the largest cluster, also called width of the decomposition.In fact, the earliest decomposition techniques were designed to solve binary CSPs only, such as the n-queens problemof Example 1.1; that is, they have been designed to deal with scenarios where the constraint hypergraph is actually agraph (call them binary or graph methods). Subsequently, methods have been proposed which are capable of working onthe constraint hypergraph without assuming any bound on the number of variables involved in each of the constraintsand, hence, without limiting their applicability to the special case of binary CSPs. In particular, much research is currentlyaimed at defining completely novel methods exploiting the whole information encoded in the constraint hypergraph (callthem non-binary or hypergraph-based methods). However, many attempts to deal with general (i.e., non-binary) constraintproblems have historically been conceived to reuse existent methods for binary CSPs, by representing any instance I bysome graph, rather than by the hypergraph H(I). With this respect, a natural idea (widely exploited in the literature) is touse, as representative graph, the primal graph of H(I) defined as follows:• Primal-graph representation. Given a hypergraph H, its primal graph (also Gaifman graph), denoted by G(H) = (N, E),is the graph whose set of nodes N is the set of variables N (H), and whose edges connect each pair of nodes (i.e., vari-ables) occurring together in some constraint of I , that is E = {{V 1, V 2} | V 1, V 2 ∈ N (H) and ∃h ∈ E(H) s.t. {V 1, V 2} ⊆h}. For example, Fig. 3(a) shows the primal graph of Hcp .Clearly, there is an evident loss of information in using the primal graph instead of the constraint hypergraph. Forinstance, each constraint scope of I induces a clique in the primal graph. If one looks at the graph only, there is no wayto understand whether such a clique comes from a single scope, or actually from some intricate interactions among manyconstraints scopes.In fact, a deep comparison among various structural decomposition methods applied to the primal graph has been carriedout in [10], where it is moreover shown that the hypertree [12] decomposition method (short: HYPERTREE)—which insteaddirectly applies to the constraint hypergraph—is more powerful than all the (known) techniques working on primal graphs.Besides the primal-graph representation, however, two other graph-based representations of non-binary CSP instanceshave been described and used in the literature, which were instead only marginally considered in [10]:• Dual-graph representation [6]. Given a hypergraph H, its dual graph, denoted by dual(H) = (N, E), is the graph whoseset of nodes N is the set of hyperedges E(H), and whose edges connect each pair of nodes (i.e., hyperedges) havingsome variable in common, that is E = {{h1, h2} | h1, h2 ∈ E(H) and h1 ∩ h2 (cid:7)= ∅}. For example, Fig. 3(b) shows the dualgraph of Hcp .• Incidence-graph representation1 [23,3]. Given a hypergraph H, we define its incidence graph as the bipartite graphinc(H) = (N, E), where N = E(H) ∪ N (H), and E = {{h, a} | h ∈ E(H) and a ∈ h}, i.e. it contains an edge from h to a ifand only if a is a node of h. For example, Fig. 3(c) shows the incidence graph of Hcp .1 Also known as hidden-variable encoding.G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409385Fig. 3. Binary representations for Hcp : (a) primal graph, (b) dual graph, and (c) incidence graph.A first comparison of dual-graph and incidence-graph encodings has been carried out in [1], in the light of assessing theperformances of forward checking and maintaining arc consistency algorithms. However, no formal comparison has beenreported in the literature, which is focused on the intrinsic “power” of structural decomposition methods based on thesebinary encodings. In fact, there are several long-standing questions about the relationships among these methods, as wellas about their relationships with hypergraph-based techniques. In particular, dual-graph encodings received much attentionin the literature, but a deep understanding of their properties is still missing.One of the major difficulties in doing a precise and formal analysis of dual-graph based methods is due to an importantfeature of this encoding: Some edges of the dual graph can safely be removed, thereby making the evaluation of CSPs easier.Indeed, even if dual(H) appears very intricate, sometimes it is possible to find suitable simplifications that make it muchmore useful (as we shall formally discuss in Section 3). Such simplified graphs are called reducts of dual(H). For instance,if H is acyclic, it is well known that there is a polynomial time algorithm that builds an acyclic reduct of its dual graph.However, when generalizations of acyclicity are concerned, dealing with reducts is not that easy, because different removalchoices may lead to different performances of evaluation algorithms. Therefore, the following challenge comes into playwhen analyzing decomposition methods based on the dual-graph encoding:(1) The efficiency of any technique based on the dual graph crucially depends on the availability of a good algo-rithm/methodology for its simplification. But, finding an “optimal reduct” (w.r.t. the technique at hand) is a difficulttask and, for some relevant decomposition techniques, is currently not known to be feasible in polynomial time. As amatter of fact, most of the results in the literature only provide rough bounds on the power of decomposition methodsapplied to dual graphs, by pragmatically not allowing any simplification in the theoretical analysis, or by exploiting justheuristic approaches. As an example, Gyssens et al. [15] contrasted the notion of hinge decompositions (short: HINGE)with the notion of biconnected components [8] of the dual graph (short: BICOMPd). It turned out that HINGE is ageneralization of BICOMPd, and thus the hinge decomposition technique is not worse than the biconnected compo-nents technique. However, the precise relationship between these methods remained an open question. Indeed, it wasobserved that the biconnected components—and thus their largest cardinalities—may differ very much among the manypossible reducts of the dual graph.Similarly, very few results were known about the power of decomposition methods applied to incidence-graph encodingsand, in particular, on how they compare with other binary encodings. Indeed,(2) It is well known that the tree decomposition method [20] applied to the incidence graph (short: TREEDECOMPin) maybe used for identifying tractable classes of non-binary CSPs [18], as well as the tree decomposition applied to theprimal and to the dual graph (short: TREEDECOMPp and TREEDECOMPd, respectively). However, a thorough analysis of386G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409the power of these three methods has never been carried out, and it was not known whether any of these encodings isdefinitively better than the other possible applications of tree decompositions.Finally, very little was known about how binary methods compare with hypergraph-based techniques. Indeed,(3) While it is known that TREEDECOMPoptd is definitively less powerful than HYPERTREE (cf. [10]), the actual reason forsuch a big difference between them is not well-understood, since at a first glance the kind of tree labelling in thesemethods seems rather similar. In addition, nothing was known about how HYPERTREE compares with TREEDECOMPin,and about how other hypergraph-based methods, such the spread cuts [5] decomposition method (short: SPREADCUT),or the component hypertree [13] decomposition method (short: CHYPERTREE) compare in general with binary meth-ods.1.2. Main resultsIn this paper, we embark on a systematic analysis of the formal properties and of the decomposition power of both dualand incidence-graph encodings, thereby complementing the results of [10], which were mainly focused on the primal graphrepresentation. In particular, we face the issue (1) above pertaining dual-graph encodings, and we fill the gaps discussed in(2) and (3) about incidence graphs and other hypergraph-based methods. Moreover, we investigate decomposition methodsearlier introduced in the literature, so that the combination of all our results leads to a complete and clear picture ofthe relationships among decomposition methods applied to binary representations of general CSP instances, and of therelationships of these methods with hypergraph-based techniques.In order to carry out our analysis, we adopt the criteria introduced in [10], and later used in other papers about structuralmethods (see, e.g., [5]), where any pair of decomposition methods are compared according to their ability of identifyingtractable classes of CSPs. Informally, a method D2 generalizes a method D1 if each CSP that is tractable according to D1 isalso tractable according to D2 (the D2-width is smaller than the D1-width on every instance); D2 beats D1 if some CSPs aretractable according to D2 but not according to D1; D2 strongly generalizes D1 if D2 both generalizes and beats D1; and D1and D2 are equivalent if D1 generalizes D2 and D2 generalizes D1.Note that results comparing the widths of structural methods also provide information on how well these methodsdecompose the given instances—preparatory to solving them—rather than just saying which tractable classes are specifiable.Indeed, the running time of every algorithm solving CSPs using any method considered in this paper must be exponentialin the corresponding notion of width, unless some unexpected event occurs in the theory of parameterized complexity [7].This can be easily seen by observing that the k-clique problem on a graph G = (V , E) may be encoded as a binary CSPinstance I(G) with k variables X1, . . . , Xk over the domain V , and the k × (k − 1)/2 constraints (( Xi, X j), E), ∀1 (cid:2) i < j (cid:2) k.By exploiting this encoding, it immediately follows that k-clique is fp-reducible to solving bounded D-width CSP instances,where D is any method considered in this paper, and thus solving CSPs by any of these techniques is W[1]-hard.2 Therefore,unless some collapse occurs in the weft hierarchy of complexity classes (see, e.g., [7]), any algorithm for solving theseinstances must run in time O (n f (w)), where w is the D-width and f (w) is a function—that is believed to be Ω(w)for dual-graph methods and Ω(w) for all the others, unless the barrier of O (nΩ(k)) is broken for deeply studied W[1]-hard problems such as k-clique, k-independent set, and k-dominating set. Therefore, the typical dynamic programmingapproach based on Yannakakis’s algorithm, whose cost is O (nw+1 log n)—see, e.g., [22], is likely almost optimal, in thatno algorithmic breakthrough is expected that may improve significantly its running time. In particular, under the abovecomplexity assumptions, it is not possible to find any algorithm where the exponential dependency from the width is afactor of some polynomial of the input size, e.g., has the better form O (c w1 nc2 ), with c1 and c2 being fixed constants—see[14] and [21], for results on these issues and some good news for classes of instances where additional parameters are fixed(besides the D-width).√Thus, for a given class of CSP instances it is meaningful to consider not only whether the D1-width of these instancesis bounded (according to some structural method D1), but also how large these widths are, especially if compared with thewidths of some other method D2. In particular, a very relevant relationship for this paper is the following. Consider a pair ofstructural methods D1 and D2 such that D1 beats D2, and the D1-width is at most exponentially larger than the D2-widthon any CSP instance. Therefore, D2 cannot beat D1, because any class of CSP instances whose D2-width is bounded by some(cid:16) (cid:2) exp(k). Hence, every class that is tractable according to D2constant k have the D1-width bounded by some constant kis also tractable according to D1. However, assume that we know that the above upper-bound on the width is also strict,in that there is some class C of CSP instances whose D2-width is bounded by some k (cid:3) 1, and such that the D1-width isexponentially larger than the D2-width. Even if C is tractable according to D1, in practice the method D2 should be preferredto D1 on this class. Indeed, from the above lower bounds we expect that, by using any algorithm based on D1, the (worstcase) solving of CSP instances from C will perform quite bad, if compared to algorithms exploiting D2.Interestingly, many occurrences of the above relationship between structural methods come out while comparing tech-niques based on different graph encodings. To properly deal with them, we formally define the notion of weak generalization2 In fact, this is the well-known fixed-parameter intractability proof used for k-bounded treewidth instances (see, e.g., [14]).G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409387and we say, for a pair D1, D2 as above, that D1 weakly generalizes D2. Note that the term “generalization” is due to the factthat a class is tractable according to D1 whenever it is tractable according to D2, while the term “weak” recalls that such D1is quite useless for some class of instances where D2 is useful, instead. Thus, while in theory D1 is slightly better than D2,in practice the two methods are somehow incomparable, with the choice between them depending on the specific kind ofproblems to be solved.Armed with the above notions and comparison criteria, we can now outline our contribution.In the first part of the paper we study the dual-graph encoding. Note that when a method of finding the reduct to beused is not specified we can only compare decomposition methods loosely. To deal with this issue, we preliminarily define,for each method D, the method Doptd as the method D applied to an optimal reduct of the dual graph with respect to D(i.e., to any reduct of the dual graph having the minimum possible D-width). We first show in Theorem 3.3 that when adecomposition method (possibly using an arbitrary reduction algorithm) beats (and/or generalizes) another, then the samerelationship will be true when considering optimal reducts. Moreover, the widths of decomposition methods applied tooptimal reducts of dual graphs are well-defined, so that these methods may be precisely compared with other methods,according to the above criteria. Then, based on this notion,(cid:2) We answer a question firstly faced in Gyssens et al. [15], by proving that BICOMPoptd is equivalent to HINGE. In fact, weshow that any hinge decomposition corresponds to the biconnected-components tree of some reduct of the dual graph.It is worthwhile noting that, as a corollary of this result, we obtain that, for the BICOMPoptd method, an optimal reductof the dual graph can be computed in polynomial time, since a hinge decomposition can be computed in polynomialtime [15].(cid:2) We consider the tree decomposition method applied to an optimal reduct of the dual graph (short: TREEDECOMPoptd),and we show that this method is definitively better than any other method D applied to an optimal reduct of the dualgraph w.r.t. D. In particular, we show that TREEDECOMPoptd strongly generalizes the biconnected-components methodBICOMPoptd (and, hence, HINGE).(cid:2) We establish the precise relationship between BICOMPoptd and various methods applied to the primal graph (andanalyzed in [10]), namely the biconnected-components method on the primal graph (short: BICOMPp ), the cutset [16]decomposition on the primal graph (short: CUTSETp ), and the tree decomposition method [20] applied to the primalgraph (TREEDECOMPp ).(cid:2) We introduce a novel decomposition method, called weak query decomposition (short: weakQUERYDECOMP), to shedsome light on the precise decomposition power of TREEDECOMPoptd, and to overcome some technical difficulties incomparing this notion with other techniques. It is defined on the constraint hypergraph and has essentially the samedecomposition power of TREEDECOMPoptd (formally, weakQUERYDECOMP is a 2-approximation of TREEDECOMPoptd).Therefore, this method does not require the computation of any reduct, and it can be used in place of TREEDECOMPoptd,because it is equivalent to it. This relationship is also interesting because weakQUERYDECOMP is a tractable notion,while finding the most appropriate way of simplifying the dual-graph w.r.t. the tree decomposition method is a well-known challenging problem (cf. [18]).In the second part of the paper, we turn to the analysis of the incidence-graph representation, and specifically of thetree decomposition method applied to it (TREEDECOMPin). In particular,(cid:2) We show that TREEDECOMPin is incomparable with HINGE, that is, HINGE beats TREEDECOMPin but TREEDECOMPinbeats in turn HINGE. This result evidences that TREEDECOMPin behaves significantly different than TREEDECOMPoptd,given that this latter method strongly generalizes HINGE.(cid:2) We compare TREEDECOMPin with TREEDECOMPoptd. It turns out that there are CSP classes that are tractable accordingto TREEDECOMPoptd but are not tractable according to TREEDECOMPin. However, we show that TREEDECOMPoptd doesnot strongly generalize TREEDECOMPin. Indeed, there are classes of CSPs whose incidence-graph treewidth is boundedby a constant k, but the width of some optimal reduct of the dual graph is exponentially larger. Thus, even if suchclasses are tractable, their evaluation can be more efficient by using TREEDECOMPin. It follows that either of thesemethods may be useful for some kind of CSP instances, and hence there is no definitely better choice between them,even though TREEDECOMPoptd seems a bit more powerful.(cid:2) We show that the above relationships between TREEDECOMPin with TREEDECOMPoptd hold on any pair of binarydecomposition methods applied to the dual and the incidence graph, respectively. Therefore, either encodings turn outto be useful for some kind of CSP instance.(cid:2) We exploit the connections between TREEDECOMPin, TREEDECOMPoptd, and weakQUERYDECOMP in order to furtheranalyze the properties of the tree decomposition method, when applied on dual and incidence graphs. We show thatany width-k decomposition of the incidence graph can be transformed into a weak query decomposition having widthat most 2k+1 and, hence, into a tree decomposition of the dual graph whose width is bounded by 2 × 2k+1. In fact,we show that TREEDECOMPoptd weakly generalizes TREEDECOMPin, thereby exactly capturing the relationship betweenthe two notions.388G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409In the third part of the paper, we consider the primal-graph representation, and we compare it with the various methodson dual and incidence graphs we have discussed earlier. Specifically,(cid:2) We consider the problem of comparing the tree decomposition method on the primal graph (TREEDECOMPp ) with thesame method on the incidence graph (TREEDECOMPin), raised in [18]. Indeed, we formalize and adapt some of thehints in [18] to formally show that TREEDECOMPin strongly generalizes TREEDECOMPp .(cid:2) We show that no method applied to the dual graph is definitively superior to any method applied to the primal graph,precisely as in the case of the comparison between dual-graph and incidence-graph encodings. In particular, we showthat TREEDECOMPoptd weakly generalizes TREEDECOMPp , CUTSETp , and BICOMPp .Finally, we consider the problem of deciding whether any of the binary methods studied in the paper is superior to someof the above mentioned hypergraph-based decomposition methods. With this respect,(cid:2) We first focus on the (hypergraph-based) query decomposition [3] method (short: QUERYDECOMP), and we show thatQUERYDECOMP strongly generalizes the TREEDECOMP method independent of whether this latter is applied to theprimal, the dual, or the incidence graph. Then, since all the tractable hypergraph-based decomposition methods that weconsider are defined as to generalize QUERYDECOMP, we conclude that each of them, in its turn, strongly generalizesTREEDECOMPp , TREEDECOMPoptd, and TREEDECOMPin.(cid:2) Finally, we shed some light on the big difference between TREEDECOMPoptd (which emerged in our analysis as themore powerful method on binary encodings) and the hypergraph-based methods. To this end, we exploit again theweakQUERYDECOMP method (that approximates TREEDECOMPoptd), which is a special case of QUERYDECOMP.1.3. The overall pictureA summary of our results is illustrated in Fig. 4, where QUERYDECOMP is depicted in gray because it is not a tractablenotion [12]. Three kinds of arrows, dotted, dashed, and solid, are used to denote the relationships of generalization, weakgeneralization, and strong generalization, respectively. Note that this picture is complete. For instance, strong generalizationis a transitive relationship, and thus a path of solid lines from D1 to D2 implicitly means that D2 strongly generalizes D1.Moreover, if D2 neither strongly nor weakly generalizes D1, then it is actually shown in the paper (or, it is known from theliterature) that D2 and D1 are incomparable, and thus no arrow connects them in the picture.Observe thatthe power of allthe binary methods is essentially bounded by weakQUERYDECOMP, whereasQUERYDECOMP is generalized by the other hypergraph-based methods. Moreover, the picture evidences that any binarymethod applied to whatever kind of encoding is strongly generalized by QUERYDECOMP. Then, it can be argued that the su-perior power of hypergraph-based methods precisely lies in the capability of jointly using sets of hyperedges to decomposethe CSP instance at hand, a capability that is in fact missing in weakQUERYDECOMP (and below). As for the relationshipsamong binary methods, it emerges that TREEDECOMPin is better than any method applied to the primal graph. However,note that TREEDECOMPoptd weakly generalizes all these graph methods, and it strongly generalizes BICOMPoptd.Organization. The rest of the paper is organized as follows. In Section 2, we introduce some preliminaries on decompositionmethods and we define the criteria according to which these methods will be formally compared. Then, in Section 3, westart our investigation with the dual-graph encoding of non-binary CSPs. Section 4 contains the comparison of the methodTREEDECOMPin with both HINGE and TREEDECOMPoptd, while in Section 5 we complete the picture by investigating thepower of decomposition methods working on primal graphs. Section 6 reports the formal comparison of binary methodswith hypergraph-based decomposition methods. Finally, in Section 7, we draw our conclusions.2. Structural decomposition methodsIn this section, we introduce the various decomposition methods and comparison criteria that will be the subject of ourresearch in this paper.2.1. Tractable classes of constraint satisfaction problemsIt is well known that CSPs with acyclic constraint hypergraphs are polynomially solvable [6]. In fact, most of the knownstructural properties that lead to tractable CSP classes are (explicitly or implicitly) based on some generalization of acyclicity.In particular, each structural decomposition method D defines some concept of width, which can be interpreted as a measureof cyclicity of the underlying constraint (hyper)graph such that, for each fixed width k, all CSPs of width bounded by k aresolvable in polynomial time. This (possibly infinite) set of CSPs is called the tractability class of D w.r.t. k, and is denoted byC(D, k). Actually, for the sake of simplicity and whenever no confusion arises, we shall often use also C(D, k) to denote theclass of hypergraphs associated with those instances.We next recall the definitions of some relevant concepts of widths and structural decomposition methods (see, e.g.,[10])—further hypergraph-based methods will be discussed in Section 6.G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409389Fig. 4. Summary of the results.390G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409CUTSET [6]. Let G = (V , E) be a graph. A cycle cutset of G is a set S ⊆ V such that the subgraph of G (vertex-)induced byV − S is acyclic. That is, after deleting the vertices in S, the graph of G becomes acyclic. The cutset width of G is1 if G is acyclic; otherwise, it is the minimum cardinality over all its possible cycle cutsets.TREEDECOMP [20]. A tree decomposition of a graph G = (V , E) is a pair (cid:5)T , χ (cid:6), where T = (N, F ) is a tree, and χ is alabelling function associating to each vertex p ∈ N a set of nodes χ (p) ⊆ V , such that the following conditions aresatisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ (p); (2) for each edge {b, d} ∈ E, there existsp ∈ N such that {b, d} ⊆ χ (p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ (p)} induces a (connected) subtreeof T —this latter condition is usually known as the connectedness condition. The width of the tree decomposition(cid:5)T , χ (cid:6) is maxp∈N |χ (p) − 1|. The treewidth of G is the minimum width over all its tree decompositions.BICOMP [8]. Let G = (V , E) be a graph. A vertex p ∈ V is a separating vertex for G if, by removing p from G, the numberof connected components of G increases. A biconnected component of G is a maximal set of vertices C ⊆ V suchthat the subgraph of G induced by C is connected and remains connected after any one-vertex removal, i.e., hasno separating vertices. The biconnected width of G is the cardinality of the largest biconnected component of G.HINGE [15,16]. Let H be a hypergraph. For each set of hyperedges H ⊆ E(H), with a slight abuse of notation, N (H) willh∈H h. Let H ⊆ E(H), and F ⊆ edges(H) − H . Then, F is called connectedfrom now on denote the set of nodeswith respect to H if, for any two edges e, f ∈ F , there exists a sequence e1, . . . , en of edges in F such that (i) e1 = e;(cid:2)h∈H h; and (iii) en = f . Let C1, . . . , Cm be the maximal(ii) for i = 1, . . . , n − 1, ei ∩ ei+1 is not contained inconnected subsets of E(H) − H with respect to H . Then, H is a hinge if, for i = 1, . . . , m, there exists an edgehi ∈ H such that N (Ci) ∩ N (H) ⊆ hi . A hinge is minimal if it does not contain any other hinge. The hinge width ofH is defined as the cardinality of the largest minimal hinge of H.(cid:2)QUERYDECOMP [3]. The notion of query decomposition was originally conceived in the database context of conjunctivequery optimization. Following [12], we actually provide here a slight variation of the original definition of querydecomposition, where the tree vertices are labelled by hyperedges only. Indeed, from the results in [12], we knowthat this simplified notion is equivalent to the original one.A query decomposition of a hypergraph H is a pair (cid:5)T , λ(cid:6), where T = (N, E) is a tree, and λ is a labelling functionwhich associates to each vertex p ∈ N a set λ(p) ⊆ E(H), such that the following conditions hold: (1) for eachhyperedge h of H, there exists v ∈ N such that h ∈ λ(v); (2) for each hyperedge h of H, the set {v ∈ N | h ∈ λ(v)}of T , for each pair of hyperedgesinduces a (connected) subtree of T ; (3) for each pair of vertices v and v(cid:16)(cid:16))). The widthh ∈ λ(v) and hin T , h ∩ hin the path connecting v and vof the query decomposition (cid:5)T , λ(cid:6) is maxv∈N |λ(p)|. The query width of H is the minimum width over all its querydecompositions.(cid:16)), and for each vertex v(cid:16) ⊆ N (λ(v(cid:16) ∈ λ(v(cid:16)(cid:16)(cid:16)(cid:16)We point out that QUERYDECOMP and HINGE are the only of the above decomposition methods defined to be directlyapplied to the constraint hypergraph. All the other methods are, instead, binary; hence, we shall consider their applicationto some binary encodings of the constraint hypergraph. In particular, we find in the literature applications of CUTSET tothe primal graph (CUTSETp ), of BICOMP to the primal and the dual graph (BICOMPp and BICOMPd), and of TREEDECOMPto the primal, the dual, and the incidence graph (TREEDECOMPp , TREEDECOMPd and TREEDECOMPin).2.2. Comparison criteriaAny pair of decomposition methods D1 and D2 can be compared according to their ability of identifying tractable classesof CSPs. This approach has firstly been formalized in [10], where the following criteria have been proposed:Generalization. D2 generalizes D1 (D1 (cid:17) D2) if there exists a constant δ such that for each k > 0, C(D1, k) ⊆ C(D2, k + δ).In practical terms, this means that whenever a class of constraints is tractable according to method D1, it is alsotractable according to D2.Beating. D2 beats D1, denoted by D2 (cid:2) D1, if there exists an integer k > 0 and a set C of instances such that C ⊆ C(D2, k),and C (cid:2) C(D1, m) for any m > 0. Hence, some classes of problems are tractable according to D2 but not accordingto D1. For such classes, using D2 is thus better than using D1.Strong generalization. D2 strongly generalizes D1, denoted by D1 ≺≺ D2, if D2 generalizes D1 and D2 beats D1. This meansthat D2 is really more powerful, given that whenever D1 guarantees polynomial runtime for constraint solving,then also D2 guarantees tractable constraint solving, but there are classes of constraints that can be solved inpolynomial time by using D2, but are not tractable according to D1.Equivalence. D1 and D2 are equivalent, denoted by D1 ≡ D2, if D1 generalizes D2 and D2 generalizes D1. Intuitively, thismeans that these two methods do not differ significantly from each other.Finally, the decomposition methods D1 and D2 are strongly incomparable if both D1 (cid:2) D2 and D2 (cid:2) D1.G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409391Next, we state a few simple properties about the notions of generalization, beating, and strong generalization, which willbe exploited in the paper.3Proposition 2.1. Let D1, D2, and D3 be three decomposition methods. Then,(1) If D2 (cid:2) D1 and D2 (cid:17) D3, then D3 (cid:2) D1;(2) If D1 (cid:17) D2 and D2 (cid:17) D3, then D1 (cid:17) D3; and(3) If D1 ≺≺ D2 and D2 (cid:17) D3, then D1 ≺≺ D3.2.3. Weak generalizationThe above comparison criteria have been used in [10] to completely classify the power of the methods CUTSETp ,BICOMPp , TREEDECOMPp , HINGE, HYPERTREE, and, partially, of the method TREEDECOMPd. Some of the results obtainedin [10] emerge from Fig. 4 (see the citations on the arc labels).In fact, in order to extend the analysis of [10] to the dual and the incidence-graph encodings, we need to introduceanother criterium that is finer than the notions of generalization and beating. Indeed, these criteria are not appropriate tocapture those scenarios where a method D2 does not generalize D1, but it is still such that any decomposition of width kw.r.t. D1 can be mapped into a decomposition of width kis a natural number that depends on k only.w.r.t. D2, where k(cid:16)(cid:16)Formally, let f be a non-decreasing function from (positive) natural numbers to (positive) natural numbers. Then, D2 f -generalizes D1 (D1 (cid:17) f D2) if, for each k > 1, C(D1, k) ⊆ C(D2, f (k)) holds. Thus, for any given hypergraph H, if there existsa decomposition for H of width k w.r.t. D1, then there exists a decomposition for H of width f (k) w.r.t. D2.4The following are simple, yet relevant properties of f -generalizations.Proposition 2.2. Let D1 and D2 be two decomposition methods. Then,(1) D1 (cid:17) D2 implies that there is a function f such that D1 (cid:17) f D2; and(2) D1 (cid:17) f D2 implies that D1 (cid:2) D2 and D2 ≺≺ D1 do not hold.Since we are mainly interested in upper bounds that are also strict, we next define the new notion of f -beating, whichintuitively means that, for some class of instances, such a function f (·) provides a lower bound for the relationship betweenthe widths according to the given methods.Let C be a countably infinite class of hypergraphs where every hypergraph Hiis identified by its associated naturalCCD (·) as the width function such that wnumber i, and let D be any decomposition method. Define wD (n) is the D-width ofhypergraph Hn in C. Let D1 and D2 be two decomposition methods. We say that D1 f -beats D2 if there exists a countablyCinfinite class C of hypergraphs such that wD1 (n))).An important case of f -generalization and f -beating occurs when using D2 instead of D1 leads to an exponential blow-, where δ > 0 is some fixed. Moreover, whenever we say that D1 exp-generalizes (resp., exp-beats) D2,up in the width. From now on, expδ(·) will denote the exponential function expδ(n) = 2√n(cid:21)rational number. For instance, exp 12we mean that there exists some fixed rational δ > 0 such that D1 expδ -generalizes (resp., expδ -beats) D2.CD2 (n) is Ω(f (w(cid:20)(n) = 2(cid:20)nδ (cid:21)Definition 2.3 (Weak generalization). Let D1 and D2 be two decomposition methods. Then, D2 weakly generalizes D1, denotedby D1 (cid:3)≺ D2, if(i) D2 beats D1;(ii) D2 exp-generalizes D1; and(iii) D1 exp-beats D2.Thus, D2 weakly generalizes D1 intuitively means that D2 is slightly more powerful than D1. Indeed, there are classesof constraints that can be solved in polynomial time by using D2 but that are not tractable according to D1—cf. condition(i) above. And, any class of constraints that is solvable in polynomial time with D1 is solvable in polynomial time byapplying the method D2 as well, possibly with an exponential blow-up w.r.t. the width—cf. (ii). Moreover, we know thatthis exponential blow-up actually occurs for some class of instances—cf. (iii), where using D1 should be thus preferable toD2. In practice this means that in this case there is no clear winner between the two methods, and the actual choice willdepend on the specific class of problems to be solved. Of course, weak and strong generalizations are mutually exclusive,because of the exp-beating condition. Some further properties of weak generalizations are stated below.3 Proofs in this preliminary section are rather simple and hence are omitted. However, they are reported in Appendix A, for the sake of completeness.4 Note that the f -relationship is required to hold for any k > 1, instead of k > 0 as in the case of plain generalization [10]. Indeed,is here a genericfunction, and it is convenient, for (clear enough) technical reasons, to avoid that the value k = 1 occurs as the base in possible exponential expressions.This is not a substantial change, since C(D1, 1) ⊆ C(D1, 2) ⊆ C(D2, f (2)) holds.f392G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409Fig. 5. (a) A hypergraph, (b) its dual graph, (c) a reduct having treewidth 2, and (d) a reduct having treewidth 3.Proposition 2.4. Let D1, D2, and D3 be three decomposition methods. Then,(1) D1 does not weakly generalize D1, i.e., (cid:3)≺ is antireflexive;(2) If D1 (cid:3)≺ D2, then D2 (cid:3)≺ D1 does not hold, i.e., (cid:3)≺ is antisymmetric; and(3) If D1 (cid:3)≺ D2 and D2 (cid:17) D3 (or, D1 (cid:17) D2 and D2 (cid:3)≺ D3), then D3 exp-generalizes D1.3. Dual-graph representationIn this section, we formalize the notion of reduct of the dual graph, i.e., we define how the dual graph dual(H) of ahypergraph H can be simplified by safely removing some edges. Based on this notion, we then investigate the power ofsome binary decomposition techniques defined on (some optimal reduct of) the dual graph.3.1. Reducts and basic propertiesDefinition 3.1 (Reduct). Let dual(H) = (N, E) be the dual graph of a hypergraph H. A reduct Gsatisfying the following three conditions:(cid:16)of dual(H) is a graph (N(cid:16), E(cid:16))(cid:16) = N;(1) N(cid:16) ⊆ E; and(2) E(3) for each edge {h, h(cid:16)} belonging to E − E(cid:16), there exists in G(cid:16)a path h = h1, . . . , hn = h(cid:16)are included in hi ∩ hi+1, for each 1 (cid:2) i < n. That is, if all the variables shared by h and hbetween h and h, then the edge connecting them can be deleted from the dual graph.(cid:16), such that all variables in h ∩ hoccur in some other path(cid:16)(cid:16)It has been observed in the literature (see, e.g., [15]) that any CSP instance can be solved by applying binary methodsoriginally conceived for the dual graph (such as BICOMPd and TREEDECOMPd) to an arbitrary reduct of the dual graphof the given instance. This may be a great advantage, because the various edge deletions might significantly simplify theintricacy of the dual graph (and, hence, its width). However, different removal choices may lead to different widths, ingeneral. Consider, for instance, the hypergraph shown in Fig. 5(a) and the associated dual graph in (b). Then, it is easy tosee that the graphs reported in (c) and (d) are both reducts of this dual graph; however, the reduct in (c) has treewidth 2,while the reduct in (d) has treewidth 3. In this case, if we use TREEDECOMPd, it is convenient to solve the CSP instance overthe reduct in (c). Note that this conclusion depends on the technique we want to use with that graph. It is possible that,for a different dual-graph technique D, another reduct has a smaller D-width than the reduct (c), and it is thus preferablew.r.t. D.Therefore, in order to get the maximum power from a binary decomposition method D applied to the dual graph dual(H),we define the Doptd-width of dual(H) as the minimum D-width w over all its possible reducts. Any reduct of dual(H) whoseD-width is w is said an optimal reduct. Moreover, the method D applied to any optimal reduct of dual(H) is denoted byDoptd.Note that applying two graph methods D1 and D2 to the respective optimal reducts does not alter their relative power,optd, whenever D1 is preferable to D2. This is formalized below, after a useful constructionoptd remains preferable to D2i.e., D1about irreducible dual graphs.Lemma 3.2. For any graph G, there exists a hypergraph H(G) such that:• G is isomorphic to dual(H(G)); and• dual(H(G)) is irreducible.G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409393Fig. 6. Example construction in Lemma 3.2: (a) graph G, and (b) the corresponding hypergraph H(G).Proof. Let G be a graph and let H(G) be the hypergraph defined as follows: for each edge q in G, H(G) contains the noden(q); for each node v of G, H(G) contains the hyperedge h(v) consisting of all those nodes n(q) such that v ∈ q; there areno further nodes or hyperedges in H(G). An example construction is illustrated in Fig. 6.Note that, in the dual graph dual(H(G)), there is an edge between h(v 1) and h(v 2) if and only if a node n(q) occurs inh(v 1) ∩ h(v 2), i.e., if and only if v 1 ∈ q and v 2 ∈ q, i.e., if and only if q = {v 1, v 2}. Moreover, an edge in dual(H(G)) betweenh(v 1) and h(v 2) cannot be removed, since n(q) is not contained in any further hyperedge of H(G), by construction. (cid:3)Theorem 3.3. Let D1 and D2 be two graph decomposition methods. Then,(1) D2 (cid:17) D1 implies D2(2) D1 (cid:2) D2 implies D1(3) D2 ≺≺ D1 implies D1optd (cid:17) D1optd (cid:2) D2optd ≺≺ D2optd;optd; andoptd.Proof.optd, k).(1) Recall that Doptd represents the method D that, given a hypergraph H, is applied to a reduct of the dual graph havingthe minimum width (w.r.t. D) over all the possible reducts of dual(H). We denote such an optimal reduct by optDd(H).Since D2 (cid:17) D1, there is by definition a constant δ such that, for each k, C(D2, k) ⊆ C(D1, k + δ). We claim that for theoptd, k + δ). To show that the claim holds, consider anoptd, k) ⊆ C(D1same constant δ it also holds that, for each k, C(D2instance H whose width w.r.t. D2optd is k(cid:16)d(H). Since D2 (cid:17) D1, the width w.r.t. D1 of the graphoptd, kBy definition of method D2is the width w.r.t. D2 of optD2(cid:16) + δ, and hence by k + δ. Thus, there is a reduct of dual(H) whose D1-width is at mostd(H) is bounded by koptD2k + δ. It follows that k + δ is an upper bound for the width of the optimal reducts of dual(H) w.r.t. D1. Then, H belongsto C(D1(cid:16) (cid:2) k, i.e., H belongs to C(D2optd, k + δ), as well.(cid:16) > 0 be a natural number, and Gm(cid:16) be a graph in C1 that does not belong to C(D2, m(2) Since D1 beats D2, there exists an integer k and a set of graphs C1 ⊆ C(D1, k) such that C1 (cid:2) C(D2, m) for any m > 0.(cid:16)). From Lemma 3.2,Then, let mthere exists a hypergraph H(Gm(cid:16) ) such that Gm(cid:16) is isomorphic to dual(H(Gm(cid:16) )), and dual(H(Gm(cid:16) )) is the best possiblereduct.Then, observe that the application of the graph method D1 (resp., D2) to the dual graph dual(H(Gm(cid:16) )) coincides with theoptd) to H(Gm(cid:16) ), because no reduction of its dual graph is possible. Since dual(H(Gm(cid:16) )) isapplication of D1isomorphic to Gm(cid:16) , applying such graph techniques to dual(H(Gm(cid:16) )) is clearly the same as working with Gm(cid:16) . It follows(cid:16)). Therefore, the class C2 = {H(G) | G ∈that H(Gm(cid:16) ) belongs to C(D1C1} is in C(D1, k), but it is not included in C(D2optd (cid:2) D2optd, moptd, m), for any m > 0. Thus, D1optd, k), but H(Gm(cid:16) ) does not belong to C(D2optd (resp., D2optd.(3) Immediately follows from the previous two points, by definition of ≺≺. (cid:3)In the light of the above characterizations, we conclude that all the results proven in [10] for the primal graph encoding(and hence implicitly for binary CSPs) hold, in fact, when these methods are applied to the optimal reduct of the dual graph,too. As an example, given that BICOMP ≺≺ TREEDECOMP is shown to hold, we get the following.Corollary 3.4. BICOMPoptd ≺≺ TREEDECOMPoptd.In particular, since TREEDECOMP strongly generalizes all the other decomposition methods tailored for binary CSPs [10],TREEDECOMPoptd is definitively the best method to be applied to non-binary CSPs among these methods that work ondual-graph encodings.However, recall that all the known algorithms for computing a k-bounded tree decomposition of a graph are exponentialin k (even if they are polynomial for any fixed constant k), while computing the biconnected components of a graph is alinear task, independently of their width [15]. This latter technique can be therefore very useful if the size of the structureor the bound k are large, and more powerful methods like TREEDECOMP are too expensive. Yet, in order to practically394G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409exploit BICOMP on the dual graph, it remains to assess whether an optimal reduct w.r.t. this method can also be efficientlycomputed, which is the question we shall face next.3.2. Biconnected components versus hingesIn [15], it has been shown that the HINGE method generalizes BICOMP applied to any reduct of the dual graph. However,in the same paper, it is observed that a fine comparison between the two methods is quite difficult, as there is no obviousway to find a suitable reduct of the dual graph to keep the biconnected width small. Here, we solve this question byshowing that it is always possible to find a reduct of the dual graph whose biconnected width is equal to the hinge widthof H.First, we recall from [5] the definition of hinge-tree decomposition, just slightly adapted to the notations used in thispaper. A hinge-tree decomposition of a hypergraph H is a pair (cid:5)T , λ(cid:6), where T = (N, E) is a tree, and λ is a labellingfunction which associates to each vertex p ∈ N a set λ(p) ⊆ E(H), such that the following conditions hold: (1) for eachhyperedge h of H, there exists v ∈ N such that h ∈ λ(v); (2) for each node b in N (H), the set {v ∈ N | ∃h ∈ λ(v), b ∈h} induces a (connected) subtree of T ; (3) for each pair of vertices v and vof T , there is an edge h ∈ λ(v) such that(cid:16))) ⊆ h. The width of the hinge-tree decomposition (cid:5)T , λ(cid:6) is maxv∈N |λ(v)|. The hinge width of H coincidesN (λ(v)) ∩ N (λ(vwith the minimum width over all its hinge-tree decompositions [5].(cid:16)In order to establish the main result of this section, we need to preliminary state a few properties of hinge-tree decom-positions of reduced hypergraphs (that is, of hypergraphs such that there is no hyperedge properly contained in any otherhyperedge) and of connected hypergraphs (thats is, of hypergraphs such that each pair of nodes is connected via a path inthe primal graph).Lemma 3.5. Let H be a hypergraph, let (cid:5)T , λ(cid:6) be a hinge-tree decomposition of H, and let v and v(cid:16)be two distinct vertices of T .(1) If H is reduced, then λ(v) ∩ λ(v(2) If H is connected and |λ(v)| (cid:3) 2, then for each hyperedge h ∈ λ(v) there is a hyperedge ¯h ∈ λ(v) − {h} such that h ∩ ¯h (cid:7)= ∅. Thatin the path connecting in T the vertices v and v(cid:16)(cid:16)) holds for each vertex v(cid:16)) ⊆ λ(v(cid:16)(cid:16);(cid:16)is, there are no isolated hyperedges in λ labels.Proof.(cid:16)(cid:16)(1) Let v = v 1, . . . , vn = v(with n > 1) be the path in T connecting the two distinct vertices v and v. Let ¯h be(cid:16)). By condition (2) in the definition of hinge-tree decompositions, for each 1 (cid:2) i < n,a hyperedge in λ(v) ∩ λ(v¯h ⊆ N (λ(v i)) ∩ N (λ(v i+1)). Moreover, by condition (3) in the same definition, for the two vertices v i and v i+1 ofT , there is a hyperedge hi ∈ λ(v i) such that N (λ(v i)) ∩ N (λ(v i+1)) ⊆ hi . Therefore, ¯h ⊆ hi holds. In fact, since H is areduced hypergraph, the latter entails that ¯h = hi and, hence, that ¯h occurs in λ(v i), for each 1 (cid:2) i (cid:2) n.(cid:16)(cid:16)). In particular, note that v(cid:16)(cid:16)) that belongs to the path in T from v to v(2) Assume, for the sake of contradiction, that the statement does not hold. Let v be a vertex such that |λ(v)| (cid:3) 2, and leth ∈ λ(v) be a hyperedge such that h ∩ ¯h = ∅, for each ¯h ∈ λ(v) − {h}. Since H is connected, there is some hyperedge(cid:16)(cid:16) ∈ E(H) such that h(cid:16)(cid:16)(cid:16)(cid:16) ∩ h (cid:7)= ∅. From condition (1) in the definition of hinge-tree decompositions, there is a vertex vh(cid:16)(cid:16) (cid:7)= v holds. Thus, let v(cid:16)(cid:16) ∈ λ(vin T such that hbe the neighbor of v (possibly coinciding. From condition (2) in the definition of hinge-tree decompositions,with v(cid:16)(cid:16) ∩h (cid:7)= ∅. Moreover, from condition (3)h ∩h(cid:16))) should be included in some hyperedge of λ(v). Because h has no intersectionin the same definition, N (λ(v))∩N (λ(v(cid:16))) ∩ h (cid:7)= ∅, h is the only hyperedge that may playwith any other hyperedge in λ(v), and given that N (λ(v)) ∩ N (λ(v(cid:16)))such a role. We conclude that N (λ(v)) ∩ N (λ(vto any node in N (λ(v) − {h}), which contradicts the fact that H is connected. (cid:3)(cid:16))) ⊆ h. It follows that there is no path in H from any node in N (λ(v(cid:16))) and, hence, N (λ(v))∩N (λ(v(cid:16)))∩h (cid:7)= ∅ holds since h(cid:16)(cid:16) ⊆ N (λ(v))∩N (λ(v(cid:16)(cid:16)(cid:16)We are now in the position of characterizing the power of BICOMPoptd. We recall the notion of decomposition based onbiconnected components given in [5]. Let G be a graph. A triple (cid:5)T , χ , λ(cid:6) where (cid:5)T , χ (cid:6) is a tree-decomposition of G and,for each vertex v of T , χ (v) = N (λ(v)), is said an edge-defined decomposition of G. Then, a biconnected decomposition of agraph G is an edge-defined decomposition (cid:5)T , χ , λ(cid:6) of G such that the following additional condition hold: (4) for each pair(cid:16))| (cid:2) 1. The width of this decomposition is given by the maximum cardinality of theof vertices v and vχ labelling over the vertices of T . A graph G has a width-k biconnected decomposition if and only if the biconnected widthof G is at most k [5].of T , |χ (v) ∩ χ (v(cid:16)Lemma 3.6. HINGE (cid:17) BICOMPoptd.be a given hypergraph, and assume without loss of generality that H(cid:16)Proof. Let H(cid:16)is connected. Let H be the reducedhypergraph obtained by removing from H(cid:16). It is easyto see that HINGE-width(H) = HINGE-width(H(cid:16)) and BICOMPoptd-width(H) = BICOMPoptd-width(H(cid:16)), that is, non-maximalhyperedges have no impact on the widths, according to these notions. For the sake of completeness, we observe that this isnot always true for other notions that are not based on edge-defined decompositions, such as HYPERTREE.any hyperedge h which is a (proper) subset of another hyperedge h(cid:16)G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409395Fig. 7. (a) A hypergraph H, (b) a hinge-tree decomposition T of H, (c) the graph G(T ), and (d) a tree decomposition of G(T ).Let (cid:5)T , λ(cid:6) be a width-k hinge-tree decomposition of H. Based on T , we build a reduct G(T ) of dual(H) having a width-kbiconnected decomposition of G(T ).(cid:16)(cid:16)= hv1,v3= hv2,v1For each (ordered) pair of adjacent vertices v and vof T , let hv,v(cid:16) ∈ λ(v) denote a hyperedge such that N (λ(v)) ∩(cid:16))) ⊆ hv,v(cid:16) ; note that hv,v(cid:16) is well-defined due to condition (3) in the definition of hinge-tree decompositions. Then,(cid:16)} such that the following conditionsof T ,(cid:16)} (cid:7)= {hv,v(cid:16) , hv(cid:16),v }. As an example construction, Fig. 7 shows a hypergraph H in (a), a hinge-tree decomposition of H= {S8}—in (c). In particular, those edges ofN (λ(vlet us build the graph G(T ) by removing from the dual graph dual(H) each edge {h, hhold: (1) there is no vertex v of T such that {h, h{h, hin (b), and the graph G(T )—built for hv1,v2the dual graph that do not occur in G(T ) are depicted with dotted lines.(cid:16)} ⊆ λ(v), and (2) for each pair of adjacent vertices v and v= {S4}, and hv3,v1We now prove that G(T ) is indeed a reduct of dual(H), i.e., that for each edge {h, hin G(T ), condition (3) in Definition 3.1 is satisfied. To this end, given such an edge {h, hinition of hinge-tree decompositions, there are two vertices v and vbecause of point (1) in the construction of G(T ), it must be the case that v (cid:7)= vof G(T ). Let v = v 1, . . . , vn = vthe definition of hinge-tree decompositions, h ∩ hholds, for each 1 (cid:2) i < n. Therefore, h ∩ hhv i+1,v i , for each 1 (cid:2) i < n. By construction of G(T ), let us now observe that {h, hv1,v2of G(T ), and that either hv i ,v i+1h, hv1,v2 , . . . , hv i ,v i+1 , hv i+1,v i , . . . , hvn,vn−1 , h(cid:16)} of dual(H) that does not occur(cid:16)}, by condition (1) in the def-(cid:16) ∈ λ(v(cid:16)). Moreover,(cid:16)} would be an edge, and note that by condition (2) in(cid:16) ⊆ N (λ(v i)) ∩ N (λ(v i+1))(cid:16) ⊆ hv i+1,v i hold as well, by definition of hv i ,v i+1 and} are two edges} and {h} is an edge of G(T ), for each 1 (cid:2) i < n. Thus, the pathwitnesses that condition (3) in Definition 3.1 is satisfied for {h, hof T such that h ∈ λ(v) and h, for otherwise {h, h(cid:16) ⊆ N (λ(v i)), for each 1 (cid:2) i (cid:2) n. Thus, h ∩ h(with n > 1) be the path in T connecting v and v= hv i+1,v i or {hv i ,v i+1 , hv i+1,v iBased on (cid:5)T , λ(cid:6), let us now build a tree decomposition (cid:5) ¯T , ¯χ (cid:6) of G(T ) having width bounded by k—this tree decompo-sition will serve as the basis to computing the biconnected decomposition. For each vertex v of T , ¯T contains a vertex qv(cid:16)} in T , ¯T contains a vertex q{v,v(cid:16)} with ¯χ (q{v,v(cid:16)}) = {hv,v(cid:16) , hv(cid:16),v }, connected to thewith ¯χ (qv ) = λ(v); for each edge {v, v(cid:16)} of T , ¯T contains two edges {qv , q{v,v(cid:16)}}two vertices qv and qv(cid:16) associated with its endpoints (that is, for any edge {v, vand {q{v,v(cid:16)}, qv(cid:16) }). No further node or edge is in ¯T . Note that, by construction, ¯T is a tree, because it is obtained from thetree T by just breaking any edge into a pair of consecutive edges. Moreover, (cid:5) ¯T , ¯χ (cid:6) is a tree decomposition of G(T ), sincethe following conditions are satisfied:(cid:16) ⊆ hv i ,v i+1 and h ∩ h(cid:16), hvn,vn−1(cid:16)}.(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(1) For each node h of G(T ), there is a vertex p of ¯T such that h ∈ ¯χ (p).(2) For each edge {h, hIndeed, by condition (1) in the definition of hinge-tree decompositions, for each hyperedge h of H, there is a vertex vof T such that h ∈ λ(v); hence, the result follows for p = qv , by definition of the ¯χ labelling.(cid:16)} of G(T ), there is a vertex p of ¯T such that {h, hIndeed, in the case where there is a vertex v such that {h, hlabelling. Otherwise, by construction of G(T ), there is a pair of adjacent vertices v and v(cid:16)} ⊆ ¯χ (q{v,v(cid:16)}) holds.{hv,v(cid:16) , hv(cid:16),v }. In this latter case, {h, h(cid:16)} ⊆ ¯χ (p).(cid:16)} ⊆ λ(v), the result is immediate by definition of the ¯χ(cid:16)} =of T such that {h, h(cid:16)(3) For each node h in G(T ), the set {p ∈ ¯T | h ∈ ¯χ (p)} induces a connected subtree of ¯T .(cid:16), w(cid:16)) ∩ λ(w(cid:16)(cid:16)} in the corresponding path from v to v¯χ , and because of Lemma 3.5(1), each vertex of the form q w in the path in ¯T between qv and qv(cid:16)We start by considering any pair of vertices of the form qv and qv(cid:16) in ¯T such that h ∈ ¯χ (qv ) ∩ ¯χ (qv(cid:16) ). By constructionofis such thath ∈ ¯χ (qw ). Moreover, consider any vertex of the form q{w(cid:16),w(cid:16)(cid:16)} in this path. By construction, it is associated with anin T . Therefore, h = h w(cid:16),w(cid:16)(cid:16) = h w(cid:16)(cid:16),w(cid:16) holds because h belongsedge {w(cid:16)(cid:16)) by Lemma 3.5(1), which implies h ⊆ h w(cid:16),w(cid:16)(cid:16) and h ⊆ h w(cid:16)(cid:16),w(cid:16) , where the containment cannot be strictto λ(wsince H is reduced. We thus get ¯χ (q{w(cid:16),w(cid:16)(cid:16)}) = {h w(cid:16),w(cid:16)(cid:16) , h w(cid:16)(cid:16),w(cid:16) } = {h}.Consider now the case where qv and q{v(cid:16),v(cid:16)(cid:16)} are two vertices of ¯T such that h ∈ ¯χ (qv ) ∩ ¯χ (q{v(cid:16),v(cid:16)(cid:16)}) and h /∈ ¯χ (qv(cid:16)(cid:16) ),where qv(cid:16)(cid:16) and qv(cid:16) are the (only) two vertices connected to q{v(cid:16),v(cid:16)(cid:16)}. Because h /∈ ¯χ (qv(cid:16)(cid:16) ), h = hv(cid:16),v(cid:16)(cid:16) and hence h ∈ ¯χ (qv(cid:16) )¯χ (q{v(cid:16),v(cid:16)(cid:16)}) and by definition of the hyperedge hv(cid:16),v(cid:16)(cid:16) . From what we have seen above in thishold by construction of(cid:16)396G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409proof for vertices of the form qv and qv(cid:16) , each vertex in the path from qv to qv(cid:16) satisfies the connectedness conditionfor h over the ¯χ labelling. This condition thus holds for the path from qv to q{v(cid:16),v(cid:16)(cid:16)}, since q{v(cid:16),v(cid:16)(cid:16)} is directly connectedto qv(cid:16) .To conclude the proof, observe that the above two scenarios cover all the possible cases, since h ∈ ¯χ (q{v,v(cid:16)}) implies, byconstruction of the ¯χ labelling, that h ∈ χ (qv ) ∪ χ (qv(cid:16) ) holds.We next show that the tree decomposition (cid:5) ¯T , ¯χ (cid:6) satisfies the following additional property:(4) For each pair of distinct vertices p, q of ¯T , | ¯χ (p) ∩ ¯χ (q)| (cid:2) 1.Consider a pair of distinct vertices p, q of ¯T , and assume by contradiction that | ¯χ (p) ∩ ¯χ (q)| > 1 holds. Because of theabove condition (3), this implies the existence of a pair of adjacent vertices q w and q{w,w(cid:16)} (in the path from p to q in¯T ) such that | ¯χ (q{w,w(cid:16)}) ∩ ¯χ (qw )| > 1. That is, {h w,w(cid:16) , h w(cid:16),w } ⊆ ¯χ (qw ) and h w,w(cid:16) (cid:7)= h w(cid:16),w must hold. Moreover, h w(cid:16),w ∈¯χ (qw(cid:16) ) holds by definition. In particular, recall that (cid:5) ¯T , ¯χ (cid:6) is built from (cid:5)T , λ(cid:6), where the above relationships entail(cid:16))) ∩N (λ(w)) ⊆ h w(cid:16),w .h w(cid:16),w ∈ λ(w) ∩ λ(w(cid:16))) ∩ N (λ(w)) = h w(cid:16),w .Since h w(cid:16),w ∈ λ(w) ∩ λ(w(cid:16))) ∩ N (λ(w)) ⊆ h w,w(cid:16) implies h w(cid:16),w ⊆ h w,w(cid:16) , which in turn entails h w,w(cid:16) = h w(cid:16),w , because H is reduced.Thus, N (λ(wContradiction.(cid:16))) ∩N (λ(w)) ⊆ h w,w(cid:16) and N (λ(w(cid:16)), the converse of the latter inclusion holds too, and hence N (λ(w(cid:16)). By definition of such hyperedges, N (λ(wAs an example, Fig. 7 shows in (d) the tree decomposition of G(T ) associated with the hinge-tree decomposition depictedin (b). The reader may check that the additional condition (4) holds on it.To conclude the proof, we now build a biconnected decomposition of G(T ), based on (cid:5) ¯T , ¯χ (cid:6). To this end, observe pre-liminary that for some vertex p of ¯T , it is possible that ¯χ (p) is a singleton {h}. In this case, since H and thus G(T ) are(cid:16)} exists in G(T ), which is moreover covered in the ¯χ labelling of some other vertex ofconnected, an edge of the form {h, h¯T due to condition (2). Therefore, by condition (3), h must occur in some vertex p(cid:16)connected to p, so that p may be safelydeleted from ¯T by contracting this edge {p, p(cid:16)(cid:16)} (that is, we get a new tree where pis connected to the other neighbors ofp in ¯T ). Let (cid:5) ¯T(cid:16), ¯χ (cid:16)(cid:6) be the new tree decomposition of G(T ) obtained by applying this simplification procedure until thereare no more vertices with singleton labels. In particular, note that ¯χ (cid:16)is the restriction of ¯χ to the vertices whose labelling, and the width of (cid:5) ¯T , ¯χ (cid:16)(cid:6) is still bounded by k.is not a singleton. Hence, condition (4) still holds for the vertices in ¯T(cid:16)labelling can be defined such that (cid:5) ¯T, let ¯λ(cid:16)(p) contain all those edges {h, hEventually, it only remains to show that a ¯λ(cid:16)(cid:16), ¯χ (cid:16), ¯λ(cid:16)(cid:6) is an edge-defined decompo-sition. For every vertex p of ¯T(cid:16)} ⊆ ¯χ (cid:16)(p). By construction,N (¯λ(cid:16)(p)) ⊆ ¯χ (cid:16)(p). We claim that N (¯λ(cid:16)(p)) ⊇ ¯χ (cid:16)(p) holds, too. Indeed, this is immediate on a vertex p = q{w,w(cid:16)}, since¯χ (cid:16)(p) = {h w,w(cid:16) , h w(cid:16),w } and since {h w,w(cid:16) , h w(cid:16),w } is in fact an edge of G(T ) (recall that the are no singleton in ¯T). Considerthen a vertex p = qv and note from Lemma 3.5(2) that the λ label of the hinge-tree decomposition (cid:5)T , λ(cid:6) cannot containhyperedges disconnected from the rest of the label. By definition of G(T ), no connection is deleted between nodes asso-ciated with hyperedges in the same λ label. This property is thus inherited by ¯χ (cid:16)where by construction, for every vertexqv of ¯T(cid:16) ∈ ¯χ (cid:16)(qv ), and, | ¯χ (cid:16)(qv )| (cid:3) 2. It follows that, for any h ∈ ¯χ (cid:16)(qv ), there is some neighbor hof h in G(T ) such that hhence these nodes will be covered by the edge {h, h(cid:16)} of G(T ) such that {h, h(cid:16)} ⊆ ¯λ(cid:16)(qv ). (cid:3)(cid:16)(cid:16)(cid:16)(cid:16)By combining the lemma above with the fact that BICOMPoptd (cid:17) HINGE [15], we conclude that these two methods singleout the same classes of tractable CSPs.Theorem 3.7. BICOMPoptd ≡ HINGE.It is worthwhile noting that, given any hinge-tree decomposition of a hypergraph H, the proof of Lemma 3.6 provides analgorithm for computing an optimal reduct of dual(H) with respect to the BICOMP method. Since biconnected componentscan be computed in linear time, it follows that a BICOMPoptd decomposition of a hypergraph H can be computed in timeO (|N (H)||E(H)|2), which is the best-known upper bound for computing a hinge-tree decomposition [15].Eventually, we leave this section by noticing that Theorem 3.7, Corollary 3.4, and the results in [10] (stating that HINGEis strongly incomparable with TREEDECOMPp and CUTSETp ) immediately lead to establish the following relationships.Corollary 3.8. HINGE ≺≺ TREEDECOMPoptd.Corollary 3.9. BICOMPoptd and TREEDECOMPp are strongly incomparable.Corollary 3.10. BICOMPoptd and CUTSETp are strongly incomparable.3.3. A closer look at tree decompositionsWe continue the analysis of the dual-graph encoding, by looking in more detail at the TREEDECOMPoptd method. Infact, while finding the most appropriate reduction w.r.t. the biconnected components methods emerged to be an easy task,G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409397finding the most appropriate way of simplifying the dual-graph w.r.t. the tree decomposition method is a well-knownchallenging problem (cf. [18]), which makes the analysis of the decomposition power of TREEDECOMPoptd rather complex.Next, we show how this problem can be circumvented by introducing a novel decomposition method that has essentiallythe same decomposition power as TREEDECOMPoptd, while getting rid of the need for finding an appropriate simplificationof the dual graph. In particular, this new notion will be a crucial technical tool in this paper, as it is exploited in the mostintricate proofs involving TREEDECOMPoptd.Note that the method below is defined directly on the constraint hypergraph, and it can be seen as a modification ofQUERYDECOMP (see Section 2).Definition 3.11 (weakQUERYDECOMP). A weak query decomposition of a hypergraph H is a pair (cid:5)T , λ(cid:6), where T = (N, E)is a tree, and λ is a labelling function which associates to each vertex p ∈ N a set λ(p) ⊆ E(H), such that the followingconditions hold:(1) for each edge h of H, there exists p ∈ N such that h ∈ λ(p);(2) for each edge h of H, the set {p ∈ N | h ∈ λ(p)} induces a (connected) subtree of T ; and(3) for each pair of vertices v, v(cid:16) ∈ λ(v(cid:16)of T , for each pair of edges h ∈ λ(v), h(cid:16)(cid:16)) such that h ∩ h(cid:16)(cid:16) ∈ λ(v(cid:16) ⊆ h(cid:16)(cid:16).connecting v and vin T , there is h(cid:16)(cid:16)), and for each vertex v(cid:16)(cid:16)in the pathThe width of the weak query decomposition (cid:5)T , λ(cid:6) is maxp∈N |λ(p)|. The weak query-width of H is the minimum widthover all its weak query decompositions.Note, in particular, that condition (3) in the definition above entails condition (3) in the definition of QUERYDECOMP.The impact of this modification on the decomposition power of QUERYDECOMP will be illustrated in Section 6. Here, wejust show that weakQUERYDECOMP has the same decomposition power of TREEDECOMPoptd.First, we observe that weakQUERYDECOMP generalizes TREEDECOMPoptd.Theorem 3.12. TREEDECOMPoptd (cid:17) weakQUERYDECOMP.Proof. Let H be a hypergraph and TD = (cid:5)T , χ (cid:6) a tree decomposition of some reduct G of dual(H). We claim that TD is alsoa weak query decomposition of H. To this end, consider the following conditions in Definition 3.11.(1) For each edge h of E(H), there exists a vertex vh of T such that h ∈ χ (vh).Indeed, for each hyperedge h of E(H), there is a node vh in T such that h ∈ χ (vh), by definition of tree decompositionand since h is a node of the dual graph.(2) For each edge h of E(H), the set of vertices of T whose χ labelling contains h is a subtree of T .(cid:16)(cid:16).(cid:16)(cid:16)(cid:16) ∈ χ (v(cid:16) ∈ χ (vin T , there is h(cid:16)(3) For each pair of vertices v, v(cid:16)(cid:16) ∈ χ (v(cid:16)), and for each vertex vin the path connecting v (resp., v(cid:16)(cid:16)in the path connecting vIndeed, the connectedness condition trivially holds on TD, since TD is a tree decomposition.of T , for each pair of edges h ∈ χ (v), h(cid:16) ⊆ h(cid:16)(cid:16)) such that h ∩ hbe two vertices of T , and let h ∈ χ (v) and h(cid:16)} is an edge(cid:16)}. Moreover, by the connectedness condition, each vertex(cid:16)(cid:16))), and the result immediatelyand vLet v and vof G, then there is a vertex vh,h(cid:16) such that χ (vh,h(cid:16) ) ⊇ {h, h(cid:16)(cid:16)vfollows.Assume then that {h, hcondition (3) in Definition 3.1. In particular, observe that for each 1 (cid:2) i (cid:2) n, h ∩ hSince TD is a tree decomposition of G, for each edge {hi, hi+1}, there is a vertex vhi ,hi+1 in T such that χ (vhi ,hi+1 ) ⊇{hi, hi+1}. The result then follows since(cid:16)(cid:16)• for each vertex v• for each vertex v• for each vertex vin the path between vhi ,hi+1 and vhi+1,hi+2 , hi+1 is in χ (v(cid:16)(cid:16)); andin the path between v and vh1,h2 , h1 = h is in χ (vin the path between vhn−1,hn and v(cid:16)} is not an edge of G. Then, there must be a path of the form h = h1, . . . , hn = h) and vh,h(cid:16) is such that h ∈ χ (v(cid:16) (cid:7)= ∅. In the case where {h, h(cid:16) ⊆ hi holds.(cid:16)) with h ∩ h(cid:16)(cid:16)) (resp., his in χ (v, hn = h(cid:16) ∈ χ (v(cid:16)(cid:16)). (cid:3)satisfying(cid:16)(cid:16));(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)On the other hand, weakQUERYDECOMP is not too much more powerful than TREEDECOMPoptd.Theorem 3.13. For each k > 0, C(weakQUERYDECOMP, k) ⊆ C(TREEDECOMPoptd, 2 × k − 1).Proof. Let (cid:5)T , λ(cid:6) be a weak query decomposition of a hypergraph H such that its width is bounded by k. Let us arbitrarilyroot T at some vertex. Then, we build a labelled tree (cid:5)T , χ (cid:6) such that for each vertex r of T and for each child s of r in T ,χ (s) = λ(s) ∪ λ(r), i.e., s contains the same labelling as in λ plus the labelling of its father in T . Note that the cardinality ofthe χ labels over the vertices of T is bounded by 2 × k, and thus the width of (cid:5)T , χ (cid:6) is bounded by 2 × k − 1 (recall the−1 in the standard definition of treewidth).398G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409Then, define a graph G((cid:5)T , χ (cid:6)), whose set of nodes is the same as the dual graph dual(H), and such that {h, h(cid:16)} is an(cid:16)} ⊆ χ (v). We claim that G((cid:5)T , χ (cid:6)) is a reduct ofedge of G((cid:5)T , χ (cid:6)) if and only if there is a vertex v of T such that {h, hdual(H).To prove the claim, consider an edge {h, h(cid:16) ∈ χ (v(cid:16)be two(cid:16)vertices of T such that h ∈ χ (v) and h. Since h (cid:7)= h,by condition (3) in the definition of weak query decompositions, for each 1 (cid:2) i < n, there is a hyperedge hi ∈ λ(v i) such(cid:16)(cid:16)) for some vertexthat h ∩ hin the path v 1, . . . , vn. Thus, {hi, hi+1} is an edge of G((cid:5)T , χ (cid:6)), for each 1 (cid:2) i < n. It follows that h1, . . . , hn witness that theedge {h, h(cid:16)} of the dual graph that does not occur in G((cid:5)T , χ (cid:6)). Let v and v(cid:16)), and let v = v 1, . . . , vn = v(cid:16) ⊆ hi . Hence, by construction of (cid:5)T , χ (cid:6), for each 1 (cid:2) i < n, it is the case that {hi, hi+1} ⊆ χ (v(cid:16)} can safely be removed according to condition (3) in Definition 3.1.be the path in T between v and vTo conclude the proof, we show that (cid:5)T , λ(cid:6) is in fact a tree decomposition of G((cid:5)T , χ (cid:6)). Note that each node of G((cid:5)T , χ (cid:6))is covered by some vertex of (cid:5)T , λ(cid:6), because each node corresponds to a hyperedge, and hence is covered in (cid:5)T , λ(cid:6), bydefinition of weak query decomposition. Moreover, each edge of G((cid:5)T , χ (cid:6)) is trivially covered by some vertex of (cid:5)T , λ(cid:6), byconstruction of the graph G((cid:5)T , χ (cid:6)). Finally, as for the connectedness condition over λ, note that this condition holds onthe λ labelling because of condition (2) in Definition 3.11. (cid:3)(cid:16)(cid:16)To summarize,Corollary 3.14. For each k > 1,(cid:4)CTREEDECOMPoptd, k − 1(cid:5)⊆ C(weakQUERYDECOMP, k) ⊆ C(cid:4)TREEDECOMPoptd, 2 × k − 1(cid:5).Remark 3.15. Note that, while QUERYDECOMP is intractable, it is not difficult to show, by exploiting the techniques discussedin [11], that for any fixed k > 0 we can check in polynomial time whether the weak query-width of a given hypergraphis bounded by k. Thus, weakQUERYDECOMP can be seen as a polynomial method for computing a 2-approximation ofTREEDECOMPoptd. This is interesting, in the light that computing a reduct of a dual graph such that its treewidth is boundedby k is not known to be feasible in polynomial-time. In fact, it is an open problem raised by Kolaitis and Vardi [18].4. Incidence-graph representationIn this section, we focus on the incidence-graph representation, by studying, in particular, the decomposition power ofTREEDECOMPin.First, we compare this notion with HINGE, and we prove that there is no definitively best method between them. Then,we carry out the comparison with TREEDECOMPoptd, by showing that TREEDECOMPoptd is slightly more powerful thanTREEDECOMPin.4.1. Tree decomposition versus hingesWe start by showing that HINGE (BICOMPoptd) beats TREEDECOMPin.Theorem 4.1. HINGE (BICOMPoptd) (cid:2) TREEDECOMPin.Proof. We have to show that there is a class of hypergraphs that is tractable w.r.t. HINGE (BICOMPoptd), but not w.r.t.TREEDECOMPin.For each m > 0, let Rose(m) be the hypergraph having m edges {S1, . . . , Sm}, and defined over the nodes { X1, . . . , Xm, Y 1,. . . , Ym} such that S i = { X1, . . . , Xm, Y i}, for each 0 < i (cid:2) m. As an example, Fig. 8 shows the hypergraph Rose(4) in (a), itsincidence graph in (b), and a reduct of its dual graph in (c).Observe, now, that:• The graph inc(Rose(m)) is a bipartite graph, such that each S i is connected to Y i and to all the nodes in { X1, . . . , Xm}.Therefore, the treewidth of this graph is m.• The graph dual(Rose(m)) is a clique of size m, such that each vertex S i is connected to all the other nodes of the formS j , with j (cid:7)= i. Moreover, S i ∩ S j = { X1, . . . , Xm}, for each j (cid:7)= i. Therefore, we can built a reduct of dual(Rose(m)) as atree rooted in S1, such that each node of the form S j with j (cid:7)= 1 is connected with an edge to h1. Fig. 8 reports in (c)this reduct, by representing the edges removed from the dual graph with dotted lines.Thus, for each m > 0, there is an instance Rose(m + 1) such that Rose(m + 1) ∈ C(BICOMPoptd, 1) (i.e., Rose(m + 1) istractable according to BICOMPoptd), whereas Rose(m + 1) (cid:2) C(TREEDECOMPin, m) (i.e., Rose(m + 1) is not tractable accordingto TREEDECOMPin). (cid:3)The picture is next completed, by showing that TREEDECOMPin may be better than HINGE.G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409399Fig. 8. (a) The hypergraph Rose(4), (b) its incidence graph, (c) a reduct of dual(Rose(4)), and (d) its primal graph.Theorem 4.2. TREEDECOMPin (cid:2) HINGE (BICOMPoptd).Fig. 9. (a) The hypergraph Circle(6), and (b) its incidence graph.Proof. We show that there is a class of hypergraphs that is tractable w.r.t. TREEDECOMPin, but not w.r.t. HINGE. For anym > 2, let Circle(m) be the hypergraph having m hyperedges {S1, . . . , Sm} over the nodes { X1, . . . , Xm} such that: S i ={ X1, Xi+1}, for each 0 < i < m; and Sm = { Xm, X1}. As an example, Fig. 9 shows the hypergraph Circle(6) in (a) and itsincidence graph in (b).Note that the graph inc(Circle(m)) is a chain, whose treewidth is 2. Thus, the class {Circle(m) | m > 0} is tractable accord-ing to TREEDECOMPin. Instead, in [15] it has been observed that this class is not tractable according to HINGE, because thewidth of Circle(m) w.r.t. HINGE is m. (cid:3)Corollary 4.3. HINGE (BICOMPoptd) and TREEDECOMPin are strongly incomparable.4.2. Comparison with dual-graph representationIt is well known that both the dual-graph and the incidence-graph representations may be used for identifying tractableclasses of non-binary CSPs according to the tree decomposition method (see, e.g., [18]). However, it was not clear whethereither of these methods generalizes the other one or beats the other one on some classes of CSPs.We start our analysis by showing that TREEDECOMPoptd beats TREEDECOMPin.Theorem 4.4. TREEDECOMPoptd (cid:2) TREEDECOMPin.Proof. The result immediately follows from Theorem 4.1 (BICOMPoptd (cid:2) TREEDECOMPin), Corollary 3.4 (BICOMPoptd ≺≺TREEDECOMPoptd, and hence BICOMPoptd (cid:17) TREEDECOMPoptd), and Proposition 2.1(1). (cid:3)Even though TREEDECOMPoptd beats TREEDECOMPin, we next show that the former method is not much more powerfulthan the latter, formally, that TREEDECOMPoptd does not generalize TREEDECOMPin. In fact, there are cases when movingto the dual-graph encoding causes an exponential blow-up of the width.Theorem 4.5. TREEDECOMPin exp-beats TREEDECOMPoptd.Proof. Consider the countably infinite class C of hypergraphs where the n-th element, ∀n (cid:3) 2,ManySubsets(n) such that:is the hypergraph400G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409Fig. 10. A tree decomposition of inc(ManySubsets(2)) having width 9.• N (ManySubsets(n)) is the following set of nodes:(cid:6)(cid:7)¯Z p,q, where ¯X j =¯X j ∪(cid:6)1(cid:2) j(cid:2)n1(cid:2)p<q(cid:2)nXj0, Xj1, Xj2(cid:8)and ¯Z p,q =(cid:7)Zp,q0 , Zp,q1 , Zp,q2(cid:8).Note that |N (ManySubsets(n))| = 3 × n + 3 × n×(n−1).2• Hyperedges in ManySubsets(n) are built as follows. For each 0 (cid:2) i < 3, let ¯X j(i) = ¯X j − { XThen, for each n-ple 0 (cid:2) a1, a2, . . . , an < 3, E(ManySubsets(n)) contains the hyperedge:¯Z p,q(cid:4)(cid:5)c(ap, aq)¯X j(a j) ∪(cid:6)(cid:6)=,ha1,...,an} and ¯Z p,q(i) = ¯Z p,q − {Zjip,qi}.1(cid:2) j(cid:2)n1(cid:2)p<q(cid:2)nwhere c(ap, aq) (cid:4) (ap + aq) mod 3. In fact, there are exactly 3n hyperedges in E(ManySubsets(n)).As an example, Fig. 10 shows a tree decomposition of the incidence graph of ManySubsets(2), where the labelling of eachleaf vertex exactly contains a node of the form ha,b with 0 (cid:2) a, b < 3, and all the nodes of ManySubsets(2) contained in thehyperedge ha,b ∈ E(ManySubsets(2)).(cid:2) (3 × n)2.Let us first focus on the incidence graph. The number of nodes in ManySubsets(n) provides an upper bound on thetreewidth of its incidence graph. Therefore, the width of ManySubsets(n) w.r.t. TREEDECOMPin is bounded by 3 × n + 3 ×n×(n−1)2Consider now the dual graph, and notice that it consists of a clique over 3n nodes. Indeed, for each pair of nodes ha1,...,an(cid:16)1) (cid:7)= ∅. In fact,∩ haand hawe claim that no edge can be simplified from the dual graph, thereby obtaining that the width of ManySubsets(n) w.r.t.TREEDECOMPoptd is 3n − 1.(cid:7)= ∅, since (for instance) ¯X 1(a1) ∩ ¯X 1(ain dual(ManySubsets(n)), it holds that ha1,...,an(cid:16)(cid:16)1,...,an(cid:16)(cid:16)1,...,anAssume, for the sake of contradiction, that an edge {ha1,...,an , hain ManySubsets(n), with ha(cid:16)(cid:16)(cid:16)(cid:16)1,...,an(cid:16)(cid:16)1,...,an(cid:16)(cid:16)(cid:16)(cid:16)1,...,an} can be simplified. By condition (3) in Definition 3.1,∩(cid:7)= ha1,...,an and ha(cid:16)(cid:16)1,...,an, such that ha1,...,an(cid:16)(cid:16)(cid:16)(cid:16)1,...,an(cid:7)= haholds. By construction of the hyperedges in ManySubsets(n), this inclusion entails that:there must exist a hyperedge haha(cid:16)(cid:16)(cid:16)(cid:16)1,...,an(cid:16)(cid:16)1,...,an⊆ ha• for each 1 (cid:2) j (cid:2) n, ¯X j − { Xja j , X• for each 1 (cid:2) p < q (cid:2) n, ¯Z p,q − {Zja(cid:16)jja} ⊆ ¯X j − { Xp,qp,qc(ap ,aq), Z(cid:16)p ,ac(a(cid:16)(cid:16)j(cid:16)q)}; and} ⊆ ¯Z p,q − {Zp,q(cid:16)(cid:16)p ,ac(a(cid:16)(cid:16)q )}.{ZThus, the following two conditions hold: (i) for each 1 (cid:2) j (cid:2) n, Xp,qc(ap ,aq), ZSince ha1,...,an is distinct from ha(cid:16)(cid:16)p entails Xp,q(cid:16)p ,ac(a(cid:16)q)}.(cid:16)(cid:16)(cid:16)(cid:16)1,...,anand, hence, a(cid:7)= a(cid:16)(cid:16)p= a(cid:16)p . Similarly, since ha(cid:16)(cid:16)1,...,an(cid:16)(cid:16)qq . By condition (i) above, this entails X(cid:16)(cid:16)aqpabove, ap (cid:7)= a= X(cid:16)ap(cid:16)an index 1 (cid:2) q (cid:2) n such that aqp(cid:16)(cid:16)apholds, for otherwise we would have a(cid:16)(cid:16)q= aq = a(cid:16)q., we have that there is an index 1 (cid:2) p (cid:2) n such that ap (cid:7)= ais distinct from ha= Xqaq and, hence, a(cid:16)(cid:16)(cid:16)(cid:16)1,...,an(cid:16)(cid:16)q(cid:16)(cid:16)p . By condition (i), we have that there is= aq. In addition, p (cid:7)= qja(cid:16)(cid:16)j∈ { Xja j , Xja(cid:16)j}; and (ii) for each 1 (cid:2) p < q (cid:2) n, Zp,q(cid:16)(cid:16)p ,ac(a(cid:16)(cid:16)q )∈Assume without loss of generality that p < q (otherwise, just swap the roles of the two indices). Then, Zp,qwith Z(cid:16)p ,aq)c(a(cid:16)or aq = aq. In the former case, a(cid:16)the latter case, aq = aq combined with a, and hence condition (ii) can be rephrased as Z= a(cid:16)(cid:16)p= aq contradicts the fact that ap,qp,qc(ap ,aq), Z(cid:16)c(ap ,aq)(cid:16)p is impossible because ap (cid:7)= a(cid:16)(cid:16)(cid:7)= aq holds, by choice of the index q.= ap combined with ap,q(cid:16)p ,ac(a∈ {Z(cid:16)q)(cid:16)p(cid:16)(cid:16)q(cid:16)qp,q(cid:16)(cid:16)p ,ac(a}, which entails that either acoincides= ap(cid:16)(cid:16)p , by choice of the index p. In(cid:16)(cid:16)q )(cid:16)pG. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409401Fig. 11. Algorithm incidenceToWeakQueryDecomposition.In summary, for the class of hypergraphs C, ∀n > 1, wCin(n) (cid:2) 9n2 and wthe width function w.r.t. TREEDECOMPin and the latter the width function w.r.t. TREEDECOMPoptd. Thus, wCoptd(n) = 3n − 1, where the former denoteCoptd(n) is), where δ is any rational number such that 0 < δ < 12 , which means that√(n)wCin3Ω(3TREEDECOMPin exp-beats TREEDECOMPoptd. (cid:3)), and thus it is also Ω(2(wCin(n))δTo complete the picture of the relationship between TREEDECOMPoptd and TREEDECOMPin, we next show thatTREEDECOMPoptd exp-generalizes TREEDECOMPin.Technically, we exploit here the relationship between these methods and the weakQUERYDECOMP method. Indeed,we first show that any tree decomposition of the incidence graph with width k can be transformed into a weak querydecomposition having width at most 2k+1.The algorithm performing such a construction is shown in Fig. 11. It takes as its input a tree decomposition TD = (cid:5)T , χ (cid:6)(cid:16) = (cid:5)T , λ(cid:6) of H. Basically, for each node p of T , it computes theof inc(H), and outputs a weak query decomposition TDfrom its label χ (p) in the given tree decomposition TDlabelling λ(p) of this node in the weak query decomposition TDas follows: Let χ (p) = V p ∪ E p , where V p ⊆ N (H) and E p ⊆ E(H). Then, λ(p) contains all the hyperedges in E p plus onearbitrarily chosen hyperedge hV (cid:16) that covers V(cid:16) ⊆ hV (cid:16) ), for each subset Vof V p .(cid:16)(cid:16)(cid:16)(i.e., such that VFig. 12 shows an example of the application of this algorithm.Lemma 4.6. Let H be a hypergraph and (cid:5)T , χ (cid:6) a tree decomposition of inc(H). Let p be a vertex of T , h ∈ E(H), ¯X ⊆ χ (p), ¯X ⊆ h,(cid:16)). Then, either h ∈ χ (q),and h /∈ χ (p). Moreover, let q be the first vertex in the path Π of T connecting p to any vertex qor ¯X ⊆ χ (q).with h ∈ χ (q(cid:16)(cid:16)Proof. By contradiction, assume the statement is false and let q be a vertex in the path Π such that h /∈ χ (q) and X /∈ χ (q),for some node X ∈ ¯X . Since T is a tree, dropping the vertex q gives two connected components, say Cq(cid:16) and C p , whereand the latter the vertex p. Now, consider the subgraph T X = (V X , E X ) of T inducedthe former contains the vertex qby those vertices v such that X ∈ χ (v). From the connectedness condition of tree decompositions for node X , its verticesshould belong to the component C p , i.e., V X ⊆ C p . Indeed, observe that p ∈ C p and X ∈ χ (p), and q /∈ V X , because X /∈ χ (q).Similarly, from the connectedness condition for node h, the subgraph T h = (V h, Eh) of T induced by those vertices v such(cid:16)), and q /∈ V X , because h /∈ χ (q). However, since X ∈ h,that h ∈ χ (v) is such that V h ⊆ Cq(cid:16) holds. Indeed, qthere is an edge { X, h} in the incidence graph inc(H), and thus there is some vertex pin the tree decomposition (cid:5)T , χ (cid:6)such that { X, h} ⊆ χ (pshould belong to both V X and V h, which is impossible, because C p ∩ Cq(cid:16) = ∅. (cid:3)(cid:16) ∈ Cq(cid:16) and h ∈ χ (q(cid:16)). Therefore, p(cid:16)(cid:16)Lemma 4.7. Let H be a hypergraph and (cid:5)T , χ (cid:6) a tree decomposition of inc(H). Let p and q be two distinct vertices of T and Π thepath connecting them in T . Moreover, let h1, h2 ∈ E(H) be two hyperedges of H with a non-empty intersection ¯X = h1 ∩ h2, and suchthat h1 ∈ χ (p) and h2 ∈ χ (q). Then, for every vertex pin the path Π such that h1 /∈ χ (p(cid:16)) and h2 /∈ χ (p(cid:16)), ¯X ⊆ χ (p(cid:16)) holds.(cid:16)Proof. By contradiction, assume the statement is not true and let p(cid:16)), for some node X ∈ ¯X .h2 /∈ χ (p(cid:16)), and X /∈ χ (p(cid:16)be a vertex in the path Π such that h1 /∈ χ (p(cid:16)),Since X ∈ h1 and X ∈ h2, there are two edges { X, h1} and { X, h2} in the incidence graph inc(H), and thus two verticesv 1 and v 2 (not necessarily distinct) in the tree decomposition (cid:5)T , χ (cid:6) such that { X, h1} ⊆ χ (v 1) and { X, h2} ⊆ χ (v 2). From402G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409Fig. 12. (a) A hypergraph H, (b) its incidence graph, (c) a reduct of the dual graph, (d) a tree decomposition of inc(H), and (e) a weak query decompositionof H built using the algorithm in Fig. 11.the connectedness condition of tree decompositions for node X , there is a (possibly empty) path from v 1 to v 2 in T suchthat all its vertices have X in their χ label. Similarly, from the connectedness condition of tree decompositions for node h1(respectively, h2), there is a (possibly empty) path from v 1 to p (respectively, from v 2 to q) such that all its vertices haveh1 (respectively, h2) in their χ label. Thus, there is a path Π (cid:16)from p to q (possibly consisting of a single edge connectingthem) such that, for all vertices v in Π (cid:16), X ∈ χ (v), or h1 ∈ χ (v), or h2 ∈ χ (v). Since none of these nodes belong to thelabel χ (pand Π from p to q in T are distinct, which is impossible, because T is a tree. (cid:3)(cid:16)), the paths Π (cid:16)Lemma 4.8. Let H be a hypergraph. Given a tree decomposition (cid:5)T , χ (cid:6) of inc(H) whose width is k, the algorithm in Fig. 11 outputs aweak query decomposition (cid:5)T , λ(cid:6) of H, whose width is 2k+1 at most.Proof. Let H be a hypergraph, let (cid:5)T , χ (cid:6) be a tree decomposition of the graph inc(H), with T = (V , E), and let (cid:5)T , λ(cid:6) bethe output of the algorithm in Fig. 11. We show that (cid:5)T , λ(cid:6) fulfills all the three conditions in Definition 3.11 and thus it isa weak query decomposition of H.(1) For each edge h of H, there exists p ∈ N such that h ∈ λ(p).This is trivial, because every h ∈ E(H) is a vertex of inc(H) connected to some (node-)vertex of inc(H). Thus, h occursin the χ label of some vertex p of the T and hence in λ(p).(2) For each edge h of H, the set {p ∈ N | h ∈ λ(p)} induces a (connected) subtree of T .(cid:16) = {p ∈ V | h ∈ χ (p)}. Note that the subgraph of T induced by CConsider such an (hyper)edge h and the set of nodes C ⊆ V where h occurs in some λ label. Since T is a tree, it suffices(cid:16) ⊆ C be the set of vertices where h already occurs into show that the subgraph of T induced by C is connected. Let Cthe χ labels, that is, Cis connected, because of theconnectedness condition of tree decompositions. Also, note that C(cid:16)(cid:16) ⊂ V be anotherAssume by contradiction that the subgraph induced by the full set C is not connected, and let C(cid:16)(cid:16) ∩ C(cid:16) = ∅). Then, there exists(non-empty maximal) connected component of this subgraph, with C(cid:16)a borderline vertex p ∈ C, where Π does not contain(cid:16)(cid:16).any vertex of C. Then, it should be the case that h = cover( ¯X), for some ¯X ⊆ h andNote that h ∈ λ(p) and h /∈ χ (p) because p ∈ C − C¯X ⊆ χ (p), by the construction in Algorithm incidenceToWeakQueryDecomposition. However, this immediately leadsto a contradiction to the existence of the vertex q in the path Π . Indeed, from Lemma 4.6 either h ∈ χ (q), and thush ∈ λ(q), or ¯X ⊆ χ (q) and again h ∈ λ(q), because h = cover( ¯X). Both cases entail q ∈ Cfrom the maximality of thecomponent C(and clearly Cconnected through a non-empty path Π to some vertex of C. In particular, if q is the first vertex of Π , that is, the vertex adjacent to p in T , we have that q /∈ C(cid:16) (cid:7)= ∅, as observed at point (1) above.(cid:16)(cid:16) (cid:7)= C(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16)(cid:16) ∈ λ(v(cid:16)), and for each vertex v(cid:16)(cid:16)in the path connecting v and(3) For each pair of vertices v, v(cid:16), which is impossible, by the choice of p and q.of T , for each pair of edges h ∈ λ(v), h(cid:16)(cid:16).(cid:16)(cid:16)) such that h ∩ h(cid:16)(cid:16) ∈ λ(v(cid:16) ⊆ h(cid:16)(cid:16)in T , there is h(cid:16) ∈ V , with h ∈ λ(v) and h. Assume that ¯X (cid:7)= ∅ and that there exists vvConsider such a pair of vertices v, v¯X = h ∩ hin Π such that both h /∈ λ(v(cid:16)dition (3) trivially holds. Since (cid:5)T , χ (cid:6) is a tree decomposition of inc(H) and h and hedges of this graph, of course there are two vertices v 1, v 2 ∈ V such that h ∈ χ (v 1) and hto the above algorithm, h ∈ λ(v 1) and hcondition holds for the λ labelling in (cid:5)T , λ(cid:6). It follows that v(cid:16)), let Π be the path connecting them in T , and let(cid:16)(cid:16)) and h(cid:16)(cid:16)), otherwise con-are two nodes occurring in some(cid:16) ∈ χ (v 2). Then, according(cid:16) ∈ λ(v 2), too. Moreover, according to condition (2) above, the connectednessbelongs also to the path connecting v 1 and v 2 in T . From(cid:16) /∈ λ(v(cid:16) ∈ λ(v(cid:16)(cid:16)(cid:16)(cid:16)G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409403Lemma 4.7, ¯X ⊆ χ (v(cid:16)(cid:16) = cover( ¯X) such that ¯X ⊆ hh(cid:16)(cid:16)and h(cid:16)(cid:16) ∈ λ(v(cid:16)(cid:16)).(cid:16)(cid:16)) and thus, according to Algorithm incidenceToWeakQueryDecomposition, there is a hyperedgeIn order to complete the proof, observe that the width of the decomposition (cid:5)T , λ(cid:6) is bounded by 2k+1, if k is the widthof (cid:5)T , χ (cid:6). Indeed, let v be a vertex of T , and let V p = χ (p) ∩ N (H) and E p = χ (p) ∩ E(H). Then, λ(v) contains (at most)|V p | + |E p| (cid:2) 2k+1, becauseone hyperedge for each subset of the variables in V p plus the hyperedges in E p . That is, |λ(v)| (cid:2) 2|χ (p)| (cid:2) k + 1. (cid:3)Note that, in some cases, the algorithm in Fig. 11 may directly output a tree decomposition. This is for instance thecase of the example in Fig. 12, where the decomposition (e) produced by the algorithm is actually a tree decomposi-tion of the reduct in (c). In any case, transforming a weak query decomposition into a tree decomposition can easily bedone (without a large increase in the width). Indeed, from Lemma 4.8 and the relationship between TREEDECOMPoptd andweakQUERYDECOMP, we easily get the following result.Theorem 4.9. TREEDECOMPoptd exp-generalizes TREEDECOMPin.Proof. Let H be a hypergraph and (cid:5)T , χ (cid:6) a tree decomposition of inc(H) whose width is k. From Lemma 4.8, there is a weakquery decomposition of H having width w = 2k+1, at most. Therefore, from Theorem 3.13, there is a tree decomposition ofsome reduct of the dual graph whose width is bounded by 2 × w − 1 = 2k+2 − 1. (cid:3)Putting Theorems 4.4, 4.9, and 4.5 together, the precise relationship between TREEDECOMPin and TREEDECOMPoptdderives.Corollary 4.10. TREEDECOMPin (cid:3)≺ TREEDECOMPoptd.4.3. General relationships between incidence-graph and dual-graph representationsWe leave this section by noticing that the properties stated in Theorems 4.4 and 4.5 between TREEDECOMPin andTREEDECOMPoptd are in fact representative of the relationship between any pair of binary decomposition methods appliedto the incidence and the dual graph, respectively.Theorem 4.11. Let D1 and D2 be two methods in {TREEDECOMP, BICOMP, CUTSET}. Then,optd (cid:2) D2in exp-beats D1in; andoptd.(1) D1(2) D2Proof.(1) Consider the class of hypergraphs {Rose(m) | m > 0}, defined in Theorem 4.4, and recall that the treewidth of theincidence graph is m, whereas there is a reduct of the dual graph that is acyclic. Therefore, for any method D1 thatgeneralizes acyclicity and in particular for D1 ∈ {TREEDECOMP, BICOMP, CUTSET}, the width of D1 applied to the dualgraph is 1. However, the width w.r.t. any method D2 applied to the incidence graph is at least m, since this is the casefor TREEDECOMP, which generalizes all the other graph methods.(2) Consider the class of hypergraphs {ManySubsets(n) | n > 0}, defined in Theorem 4.5. The width w.r.t any method D2 onthe incidence graph is bounded by (3 × n)2, which is indeed an upper bound on the total number of nodes. Moreover,recall from the proof of Theorem 4.5 that, for any n > 0, the dual graph of ManySubsets(n) cannot be simplified. Thusoptd will deal with the same (dual) graph, and hence 3n − 1 will be a lower bound for its width forevery method D1this graph, as for TREEDECOMPoptd, which generalizes all the other graph methods. Then, the exp-beating relationshipis formally proved precisely with the same reasoning as in the proof of Theorem 4.5. (cid:3)5. Primal-graph representationIn this section, we study the primal-graph representation, by first focusing on the decomposition power of TREEDECOMPp .In particular, we compare this notion with the tree decomposition method applied to the incidence-graph representation,and then with the tree decomposition method applied to the dual-graph representation. Further relationships with the otherdecomposition methods over the primal graph will also be discussed, to give a complete picture.5.1. Comparison with the incidence-graph representationWe start our analysis by showing that TREEDECOMPin beats TREEDECOMPp .404G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409Fig. 13. (a) An hypergraph H, (b) its incidence graph, (c) its primal graph, (d) a tree decomposition TD of the primal graph, and (e) the corresponding tree(cid:16)decomposition TDof the incidence graph, according to the construction in Theorem 5.2.Theorem 5.1. TREEDECOMPin (cid:2) TREEDECOMPp .Proof. We show that there is a class of hypergraphs that is tractable w.r.t. TREEDECOMPin, but not w.r.t. TREEDECOMPp .For any n > 0, let Single(n) be the hypergraph having one hyperedge only over n different nodes. Then, the primal graph ofSingle(n) is a clique of n nodes, whose treewidth is n − 1. Conversely, the incidence graph of Single(n) is trivially acyclic, andhence it has treewidth 1. (cid:3)In fact, by adapting the arguments suggested in [18], we next show that TREEDECOMPin strongly generalizesTREEDECOMPp .Theorem 5.2. TREEDECOMPp ≺≺ TREEDECOMPin.Proof. After Theorem 5.1, it remains to show that TREEDECOMPp generalizes TREEDECOMPin. To this end, we claim that,for each k > 0, C(TREEDECOMPp, k) ⊆ C(TREEDECOMPin, k + 1).Let H be a hypergraph and assume that H ∈ C(TREEDECOMPp, k). Then, consider a tree decomposition TD = (cid:5)T , χ (cid:6) of(cid:16), χ (cid:16)(cid:6) as follows—seethe primal graph of H, whose width is bounded by k. Based on TD, we build a labelled tree TDFig. 13, for an illustration.(cid:16) = (cid:5)T(cid:16)• Tcontains all the vertices in T , and indeed the subgraph of Tinduced over the nodes in T precisely coincides with T .In particular, for each vertex v in both T and T• For each hyperedge h ∈ E(H) an arbitrary vertex vh of T is selected such that χ (vh) ⊇ h—note that one such vertex vhexists, since nodes in h form a clique in the primal graph and hence, as is well known, there must be a vertex covering(cid:16)(cid:16)h) = χ (vh) ∪ {h}.all of them in any tree decomposition. Then, a new vertex vh is added to Tas a child of vh, with χ (cid:16)(v(cid:16)(cid:16), we have that χ (v) = χ (cid:16)(v).(cid:16)(cid:16)We next show that TDFirst, we note that each node of inc(H) is covered in the χ (cid:16)is a tree decomposition of the incidence graph inc(H).the nodes in N (H) that are already covered in the χ (cid:16)(cid:16)since by construction of T(cid:16)(cid:16)h).Second, consider an edge { X, h} of inc(H). Note that X ∈ h, by definition of incidence graph. Then, { X, h} is covered inh is such that h ∈ χ (cid:16)(vthe vertex v. Indeed, this is obvious forlabelling. Moreover, for each hyperedge h, the property holds as well,labelling of some vertex of T(cid:16)the vertex v(cid:16)h, since χ (vh) is actually a superset of h and hence contains X .in TDvertex vh added in TAnd, third, note that the connectedness condition of tree decomposition is satisfied in TD, and hence it is also satisfied, χ (v) = χ (cid:16)(v), and because for each otherover the nodes in H, because for each vertex v occurring in both T and T(cid:16)(cid:16)as a child of r, it holds that χ (cid:16)(vTo conclude the proof, it is then sufficient to observe that the width of TD(cid:16)h) ⊇ χ (r) and v(cid:16)(cid:16)(cid:16)h is the only vertex of T(cid:16)is bounded by k + 1. (cid:3)where h is covered.5.2. Comparison with the dual-graph representationSimilarly to the case of the relationship between dual-graph and incidence-graph encodings, we next show that there isno definitively best binary representation, if we consider graph methods applied either to dual graphs or to primal graphs.Theorem 5.3. Let D1 and D2 be two methods in {TREEDECOMP, BICOMP, CUTSET}. Then,G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409405optd (cid:2) D2p exp-beats D1p ; andoptd.(1) D1(2) D2Proof.(1) Consider again the class of hypergraphs {Single(n) | n > 0}, defined in the proof of Theorem 5.1. The result then followssince the primal graph of Single(n) is a clique of n nodes, whose treewidth is n − 1, whereas the dual graph consists ofa single node and, hence, it is trivially acyclic.(2) Consider the class of hypergraphs {ManySubsets(n) | n > 0}, defined in Theorem 4.5. Even in this case, the width w.r.t.any method on the primal graph is bounded by (3 × n)2 which is indeed an upper bound on the total number of nodes.Then the statement follows from the same reasoning as in Theorem 4.11. (cid:3)We can now state the precise relationships between TREEDECOMPoptd, TREEDECOMPp , BICOMPp , CUTSETp , andBICOMPoptd.Theorem 5.4. TREEDECOMPp (cid:3)≺ TREEDECOMPoptd.Proof. In the light of Theorem 5.3, it only remains to show that TREEDECOMPoptd exp-generalizes TREEDECOMPp . To thisend, observe that TREEDECOMPin (cid:3)≺ TREEDECOMPoptd and TREEDECOMPp ≺≺ TREEDECOMPin hold, by Theorem 4.10 andTheorem 5.2, respectively. In particular, TREEDECOMPp (cid:17) TREEDECOMPin. Hence, the result follows because of Proposi-tion 2.4(3). (cid:3)Theorem 5.5. CUTSETp (cid:3)≺ TREEDECOMPoptd.Proof. In the light of Theorem 5.3, it only remains to show that TREEDECOMPoptd exp-generalizes CUTSETp . To this end,recall that CUTSETp ≺≺ TREEDECOMPp (and, hence, CUTSETp (cid:17) TREEDECOMPp ) has been shown in [10], and thatTREEDECOMPp (cid:3)≺ TREEDECOMPoptd holds by Theorem 5.4. Thus, the result follows again by applying Proposition 2.4(3). (cid:3)We next focus on the decomposition method based on the notion of biconnected component. Recall that BICOMPoptd isequivalent to the hyperedge-based method HINGE, by Theorem 3.8. Moreover, if we consider binary CSPs, it is known from[10], that HINGE strongly generalizes BICOMPp . This result was based on the observation in [15] that every biconnectedcomponent C of a graph corresponds to a hinge consisting of those (hyper)edges containing the variables in C . What wasnot observed in [15] and [10] is that the cardinality of this hinge in the general non-binary case may be exponentially largerthan the cardinality of C . Indeed, many hyperedges may contain these variables, in the worst case the power set of C (see,e.g., the hypergraph ManySubsets(n), for such a pathological example). In fact, we next show that, in the general case, theprecise relationship between these two approaches is the weak generalization.Theorem 5.6. BICOMPp (cid:3)≺ HINGE (BICOMPoptd).Proof. In the light of Theorem 5.3, we have to show that BICOMPoptd, or equivalently HINGE, by Theorem 3.8, exp-generalizes BICOMPp . Let H be a hypergraph and G its primal graph. Let (cid:5)T , χ , λ(cid:6) be a biconnected decomposition ofH, and let k be the width of this decomposition, i.e., the maximum cardinality over the biconnected components of G [5].Recall that, on binary CSPs, it has been shown that every biconnected component C of a graph is a hinge [15] or, moreprecisely, the set H(C) = {h ∈ E(H) | h ⊆ C} is a hinge. By applying the same line of reasoning as in [15], it is easy to seethat this property holds in the general case above, where the graph G is the primal graph of the hypergraph H. Just observethat every hyperedge h such that |h| > 2 corresponds to a clique in G, and thus it is included in some biconnected com-ponent, because variables in h cannot be disconnected by dropping any single variable. It follows that even in this generalcase (cid:5)T , χ , λ(cid:6) corresponds to a hinge decomposition of H. Let C be a biconnected component of G. Then, the correspondinghinge H(C) of H may contain at most 2hyperedges. Since the cardinality of the largest biconnected component is k, 2kis clearly an upper bound for the width of the hinge-tree decomposition of H associated with (cid:5)T , χ , λ(cid:6), and thus it is anupper bound for the HINGE width of H, too. (cid:3)|C|Eventually, we conclude with the relationship between BICOMPp and TREEDECOMPoptd.Theorem 5.7. BICOMPp (cid:3)≺ TREEDECOMPoptd.Proof. In the light of Theorem 5.3, it only remains to show that TREEDECOMPoptd exp-generalizes BICOMPp . To this end,recall that BICOMPoptd ≺≺ TREEDECOMPoptd (and, hence, BICOMPoptd (cid:17) TREEDECOMPoptd) follows by Theorem 3.7 and406G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409by Theorem 3.8. Moreover, BICOMPp (cid:3)≺ BICOMPoptd holds by Theorem 5.6. Thus, the result follows by applying Proposi-tion 2.4(3). (cid:3)6. Binary versus non-binary structural methodsIn the previous sections, we have analyzed the decomposition power of several graph-based decomposition methodsapplied to binary representations of non-binary instances. In this section, we compare these methods with hypergraph-based methods.In particular, we start by showing that no binary method is better than QUERYDECOMP. Then, we motivate this behaviorby observing that the power of binary methods is basically bounded by the weakQUERYDECOMP method introduced inSection 3.3, which is indeed a relaxation of QUERYDECOMP.6.1. Binary methods versus QUERYDECOMPThe idea that is common to all hypergraph-based decomposition methods is to exploit the power of hyperedges, whichmay contain many variables, to fulfill the connectedness condition while keeping the width small. This is, for instance, thecase of the QUERYDECOMP method (see Section 2).Indeed, observe that in the definition of QUERYDECOMP the width is measured in terms of “number of hyperedges”in the tree labels, rather than in terms of “number of variables,” as it is usual in graph methods. In fact, it has beenshown that CSP instances having such widths bounded by some constant may be solved in polynomial time, though withan exponential dependency on the width. Thus, these techniques exhibit the same kind of complexity bounds as typicalgraph-methods with variable-based widths, but usually with smaller—more efficient—widths for the same instances [10].As a matter of fact, QUERYDECOMP is however hardly used in practice, because checking whether the query width ofa hypergraph is bounded by k is an NP-hard problem, even for the fixed k = 4 [12]. Our interest w.r.t. this notion derivesfrom the fact that all the (tractable) hypergraph-based decomposition methods proposed in the literature do generalizeQUERYDECOMP. In particular, we next consider the hypertree decomposition method (HYPERTREE) [12], the spread-cutsmethod (SPREADCUT) [5], and the component hypertree decomposition method (CHYPERTREE) [13].Theorem 6.1. (See [12].) QUERYDECOMP (cid:17) HYPERTREE.Theorem 6.2. (See [5].) QUERYDECOMP (cid:17) SPREADCUT.Theorem 6.3. QUERYDECOMP (cid:17) CHYPERTREE.Proof. In [13], it has been shown that HYPERTREE (cid:17) CHYPERTREE. The result then follows by Theorem 6.1 and byProposition 2.1(2). (cid:3)Note that in this paper we are mostly interested in graph-based representations, and thus the above relationships dosuffice to our purpose, because we shall exploit QUERYDECOMP as an interface between graph methods and hypergraphmethods. We thus omit a formal treatment of the notions of HYPERTREE, SPREADCUT, and CHYPERTREE, by referringthe reader interested in expanding on this subject to [5,12,13]. Rather, we next shall focus on comparing QUERYDECOMPwith the various binary method discussed in this paper, by showing that it strongly generalizes all of them. In particular,in the light of our previous results (see, also, Fig. 4), we shall just focus on the methods TREEDECOMPoptd, TREEDECOMPin,and TREEDECOMPp , which emerged as the most powerful binary methods.Note that TREEDECOMPoptd and HYPERTREE have already been compared in [10], and itthatTREEDECOMPoptd ≺≺ HYPERTREE. Actually, by inspecting the result in [10], it is immediate to check that the proof straight-forwardly applies to QUERYDECOMP as well, and thus the following result holds, too.turned outTheorem 6.4. TREEDECOMPoptd ≺≺ QUERYDECOMP.Thus, we next shall consider the comparison with TREEDECOMPin.Theorem 6.5. TREEDECOMPin ≺≺ QUERYDECOMP.Proof. Recall that TREEDECOMPin (cid:3)≺ TREEDECOMPoptd (and, hence, TREEDECOMPoptd (cid:2) TREEDECOMPin) and TREED-ECOMPoptd ≺≺ QUERYDECOMP (and, hence, TREEDECOMPoptd (cid:17) QUERYDECOMP) hold by Theorems 4.10 and 6.4, respectively.Hence, we can apply Proposition 2.1(1) for concluding that QUERYDECOMP (cid:2) TREEDECOMPin holds as well.We conclude by recalling that TREEDECOMPin (cid:17) QUERYDECOMP, that is, any class of constraints that is tractable accord-ing to TREEDECOMPin is also tractable according to QUERYDECOMP. Indeed, Chekuri and Rajaraman [3] proved that, if H isG. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409407a hypergraph and TD = (cid:5)T , χ (cid:6) is a tree decomposition of inc(H) whose width is k, then there exists a query decompositionQ D of H having width k + 1. (cid:3)Armed with the above theorems, we can now conclude that non-binary methods are definitively better than binary ones,as far as their ability to identify islands of tractability is concerned.Theorem 6.6. Let D be any decomposition method such that QUERYDECOMP (cid:17) D. Then, all the following relationships hold:(1) TREEDECOMPin ≺≺ D;(2) TREEDECOMPoptd ≺≺ D; and(3) TREEDECOMPp ≺≺ D.Proof. By Theorems 6.5 and 6.4, we known that TREEDECOMPin ≺≺ QUERYDECOMP and TREEDECOMPoptd ≺≺QUERYDECOMP hold, respectively. Thus, we can apply Proposition 2.1(3) in order to conclude that TREEDECOMPin ≺≺ Dand TREEDECOMPoptd ≺≺ QUERYDECOMP hold, as well.Eventually, the fact that TREEDECOMPp ≺≺ D derives by applying again Proposition 2.1(3) armed with the facts thatTREEDECOMPin ≺≺ D (and, hence, TREEDECOMPin (cid:17) D) and that, by Theorem 5.2, TREEDECOMPp ≺≺ TREEDECOMPin. (cid:3)In particular, we can contextualize the result to HYPERTREE, SPREADCUT, and CHYPERTREE.Corollary 6.7. Let D1 be any method in {HYPERTREE, SPREADCUT, CHYPERTREE} and D2 be any method in {TREEDECOMPin,TREEDECOMPoptd, TREEDECOMPp}. Then, D2 ≺≺ D1.Proof. It is sufficient to apply Theorem 6.6, by observing that HYPERTREE, SPREADCUT, and CHYPERTREE generalizeQUERYDECOMP, by Theorems 6.1, 6.2, and 6.3, respectively. (cid:3)6.2. A note on the power of hypergraph-based methodsAccording to Theorem 6.6, any method that generalizes QUERYDECOMP is more powerful than any arbitrary bi-nary method. At a first sight, this result may appear surprising, especially when comparing QUERYDECOMP withTREEDECOMPoptd, given that the kind of tree labelling in these methods (both hyperedge-based) seems rather similar.Next, we clarify why there is such a big difference between TREEDECOMPoptd and QUERYDECOMP, by exploiting the notionof weak query decomposition introduced in Section 3.3 as a technical tool for the comparison.In fact, we have already observed that condition (3) in the definition of the weakQUERYDECOMP method (see Defi-nition 3.11) entails condition (3) in the definition of the QUERYDECOMP method (see Section 2). Thus, any weak querydecomposition of a hypergraph is also a query decomposition of the hypergraph.However, it is worthwhile noting that weakQUERYDECOMP misses the ability of jointly using sets of arbitrary hyperedgesto maintain the connectedness among the nodes that are to be decomposed. Indeed, in the standard query decomposition,variables are covered by the union of the hyperedges in the λ labelling, while in the above weaker notion only one hyper-edge at a time may be used (see the role of hin condition (3) of Definition 3.11). As a matter of fact, this ability is crucialin the definition of hypergraph-based methods, given that QUERYDECOMP strongly generalizes all binary methods, andthat weakQUERYDECOMP instead emerged to have the same decomposition power as TREEDECOMPoptd (cf. Corollary 3.14).Therefore, these observations suggest that the more liberal condition (3) in QUERYDECOMP is at the basis of the superiorpower of hypergraph-based methods (for non-binary instances).(cid:16)(cid:16)7. ConclusionsIn this paper, we have outlined a complete picture of the power of decomposition approaches applied to binary repre-sentations of non-binary CSP instances and of decomposition methods specifically tailored for non-binary encodings. Ourresearch provides a clear and complete comparison of the structural decomposition techniques proposed in the literatureso far, and answers some long-standing questions pertaining the relationships among such methods. For completeness wemention the recently proposed notion of fractional hypertree decomposition [17], which is not reported in Fig. 4. In fact, itis known that this notion strongly generalizes HYPERTREE, and thus it strongly generalizes all other structural methodsconsidered in this paper, too. However, deciding whether a fractional hypertree decomposition of width k can be computedin polynomial time, for a fixed constant k, is an open and rather intriguing problem.5 We feel that facing this problem mightprovide novel insights into the actual nature of hypergraph-based structural decomposition methods.5 An important advance in this respect is the O (k3) polynomial-time approximation algorithm provided by Marx [19].408G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409Appendix A. Proofs in Section 2Proposition 2.1. Let D1, D2, and D3 be three decomposition methods. Then,(1) If D2 (cid:2) D1 and D2 (cid:17) D3, then D3 (cid:2) D1;(2) If D1 (cid:17) D2 and D2 (cid:17) D3, then D1 (cid:17) D3; and(3) If D1 ≺≺ D2 and D2 (cid:17) D3, then D1 ≺≺ D3.Proof.(1) D2 (cid:2) D1 means that there is number ¯k > 0 and a set of instances C ⊆ C(D2, ¯k) such that C (cid:7)⊆ C(D1, m), for each m > 0.Moreover, since D2 (cid:17) D3 holds, there is a constant δ such that C(D2, ¯k) ⊆ C(D3, ¯k + δ), and hence C ⊆ C(D3, ¯k + δ).(2) Assume that D1 (cid:17) D2 and D2 (cid:17) D3 hold. Since D1 (cid:17) D2, there exists a constant δ1 such that, for each k, C(D1, k) ⊆C(D2, k + δ1). Moreover, since D2 (cid:17) D3 holds, there is a constant δ2 such that, for each kBy combining the above two relationships, we conclude that there is a constant δ = δ1 + δ2 such that, for each k,C(D1, k) ⊆ C(D2, k + δ1) ⊆ C(D3, k + δ1 + δ2) = C(D3, k + δ). This means that D3 generalizes D1., C(D2, k(cid:16)) ⊆ C(D3, k(cid:16) + δ2).(3) It immediately follows from (1) and (2) above, and by the definition of the notion of strong generalization. (cid:3)(cid:16)Proposition 2.2. Let D1 and D2 be two decomposition methods. Then,(1) D1 (cid:17) D2 implies that there is a function f such that D1 (cid:17) f D2; and(2) D1 (cid:17) f D2 implies that D1 (cid:2) D2 and D2 ≺≺ D1 do not hold.Proof.(1) This is immediate for the identity function f (x) = x.(2) Let D1 and D2 be two decomposition methods such that D1 (cid:17) f D2. Then, by definition off -generalization, for eachk > 1, C(D1, k) must indeed be contained in C(D2, f (k)).Assume, for the sake of contradiction, that D1 (cid:2) D2 holds, that is, there exists a positive integer ¯k and a set C ⊆C(D1, ¯k) such that C (cid:7)⊆ C(D2, m) for any m > 0. Since C(D1, 1) ⊆ C(D1, 2), assume without loss of generality that ¯k > 1,¯H (cid:7)∈ C(D2, m) = C(D2, f (¯k)).and consider the value m = f (¯k). Then, there is an instance ¯H ∈ C ⊆ C(D1, ¯k) such thatContradiction, since for each k > 1, C(D1, k) ⊆ C(D2, f (k)).Eventually, from the fact that D1 (cid:2) D2 does not hold, we immediately entail that D2 ≺≺ D1 does not hold as well. (cid:3)Proposition 2.4. Let D1, D2, and D3 be three decomposition methods. Then,(1) D1 does not weakly generalize D1, i.e., (cid:3)≺ is antireflexive;(2) If D1 (cid:3)≺ D2, then D2 (cid:3)≺ D1 does not hold, i.e., (cid:3)≺ is antisymmetric; and(3) If D1 (cid:3)≺ D2 and D2 (cid:17) D3 (or, D1 (cid:17) D2 and D2 (cid:3)≺ D3), then D3 exp-generalizes D1.Proof.(1) The result follows by observing that condition (ii) in the definition of the weak generalization, i.e., D1 (cid:2) D1, cannot besatisfied since (cid:2) is trivially antireflexive.(2) Let D1 and D2 be two decomposition methods such that D1 (cid:3)≺ D2. Then, due to condition (i) in Definition 2.3, we havethat D2 (cid:2) D1, which entails that D2 (cid:3)≺ D1 does not hold, after Proposition 2.2(2).(3) Let us first consider the case where both D1 (cid:3)≺ D2 and D2 (cid:17) D3 hold. By condition (ii) in Definition 2.3, D1 (cid:3)≺ D2 impliesthat there exists a constant δ1 such that, for each k > 1, C(D1, k) ⊆ C(D2, 2kδ1 ). Moreover, since D2 (cid:17) D3 holds, there isa constant δ2 such that, for each k > 0, C(D2, k) ⊆ C(D3, k + δ2). By combining the above two relationships we get, foreach k > 1, C(D1, k) ⊆ C(D2, 2kδ1 ) ⊆ C(D3, 2kδ1 + δ2) ⊆ C(D3, 2kδ), where δ > δ1 is some fixed positive rational greaterthan 1 and large enough so that 22δ (cid:3) 22δ1 + δ2. By definition, this means that D3 exp-generalizes D1.Let us now consider the case where D1 (cid:17) D2 and D2 (cid:3)≺ D3 hold. By condition (ii) in Definition 2.3, D2 (cid:3)≺ D3 impliesthat there exists a constant δ2 such that, for each k > 1, C(D2, k) ⊆ C(D3, 2kδ2 ). Moreover, since D1 (cid:17) D2 holds, thereis a constant δ1 such that, for each k > 0, C(D1, k) ⊆ C(D2, k + δ1), and of course this relationships holds for anynumber greater than δ1, as well. We thus choose as δ1 a number large enough so that kδ1−1 > δ1, for every k > 1.Note that, in particular, this entails δ1 > 2. By combining the above two relationships we get, for each k > 1, C(D1, k) ⊆C(D2, k + δ1) ⊆ C(D3, 2(k+δ1)δ2 ) ⊆ C(D3, 2(kδ1)δ2 ) ⊆ C(D3, 2kδ1δ2 ), because of the choice of δ1. This means that D3 exp-generalizes D1. (cid:3)G. Greco, F. Scarcello / Artificial Intelligence 174 (2010) 382–409409References[1] F. Bacchus, X. Chen, P. van Beek, T. Walsh, Binary vs non-binary constraints, Artificial Intelligence 140 (1–2) (2002) 1–37.[2] A. Bernstein, N. Goodman, The power of natural semijoins, SIAM Journal on Computing 10 (4) (1981) 751–771.[3] Ch. Chekuri, A. Rajaraman, Conjunctive query containment revisited, Theoretical Computer Science 239 (2) (2000) 211–229.[4] D. Cohen, P. Jeavons, The complexity of constraint languages, in: F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Elsevier,2006.[5] D. Cohen, P. Jeavons, M. Gyssens, A unified theory of structural tractability for constraint satisfaction problems, Journal of Computer and SystemSciences 74 (5) (2008) 721–743.[6] R. Dechter, Constraint Networks, second edition, Encyclopedia of Artificial Intelligence, Wiley and Sons, 1992, pp. 276–285.[7] R.G. Downey, M.R. Fellows, Parameterized Complexity, Springer, New York, 1999.[8] E.C. Freuder, A sufficient condition for backtrack-bounded search, Journal of the ACM 32 (4) (1985) 755–761.[9] N. Goodman, O. Shmueli, Syntactic characterization of tree database schemas, Journal of the ACM 30 (4) (1983) 767–786.[10] G. Gottlob, N. Leone, F. Scarcello, A comparison of structural CSP decomposition methods, Artificial Intelligence 124 (2) (2000) 243–282.[11] G. Gottlob, N. Leone, F. Scarcello, Computing LOGCFL certificates, Theoretical Computer Science 270 (1–2) (2002) 761–777.[12] G. Gottlob, N. Leone, F. Scarcello, Hypertree decompositions and tractable queries, Journal of Computer and System Sciences 64 (3) (2002) 579–627.[13] G. Gottlob, Z. Miklos, T. Schwentick, Generalized hypertree decompositions: NP-hardness and tractable variants, in: Proc. of the 26th ACM SIGACT–SIGMOD–SIGART Symposium on Principles of Database Systems (PODS’07), 2007, pp. 13–22.[14] G. Gottlob, S. Szeider, Fixed-parameter algorithms for artificial intelligence, constraint satisfaction and database problems, The Computer Journal 51 (3)(2008) 303–325.[15] M. Gyssens, P.G. Jeavons, D.A. Cohen, Decomposing constraint satisfaction problems using database techniques, Artificial Intelligence 66 (1994) 57–89.[16] M. Gyssens, J. Paredaens, A decomposition methodology for cyclic databases, in: Advances in Database Theory, vol. 2, Plenum Press, New York, NY,1984, pp. 85–122.[17] M. Grohe, D. Marx, Constraint solving via fractional edge covers, in: Proc. of the 17th Annual ACM–SIAM Symposium on Discrete Algorithms (SODA’06),2006, pp. 289–298.[18] Ph.G. Kolaitis, M.Y. Vardi, Conjunctive-query containment and constraint satisfaction, Journal of Computer and System Sciences 61 (2) (2000) 302–332.[19] D. Marx, Approximating fractional hypertree width, in: Proc. of the 19th Annual ACM–SIAM Symposium on Discrete Algorithms (SODA’09), 2009,pp. 902–911.[20] N. Robertson, P.D. Seymour, Graph minors II. Algorithmic aspects of tree width, Journal of Algorithms 7 (1986) 309–322.[21] M. Samer, S. Szeider, Constraint satisfaction with bounded treewidth revisited, Journal of Computer and System Sciences 76 (2) (2010) 103–114.[22] F. Scarcello, G. Gottlob, G. Greco, Uniform constraint satisfaction problems and database theory, in: Complexity of Constraints, in: LNCS, vol. 5250,Springer, 2008, pp. 156–195.[23] R. Seidel, A new method for solving constraint satisfaction problems, in: Proc. of the 7th International Joint Conference on Artificial Intelligence(IJCAI’81), 1981, pp. 338–342.