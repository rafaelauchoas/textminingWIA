Artificial Intelligence 175 (2011) 2021–2060Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintAlgorithms and mechanisms for procuring services with uncertaindurations using redundancyS. Stein a,∗, E.H. Gerding a, A.C. Rogers a, K. Larson b, N.R. Jennings aa Intelligence, Agents, Multimedia Group, School of Electronics and Computer Science, University of Southampton, Southampton, United Kingdomb Cheriton School of Computer Science, University of Waterloo, Waterloo, Canadaa r t i c l ei n f oa b s t r a c tArticle history:Received 16 September 2010Received in revised form 22 April 2011Accepted 15 July 2011Available online 23 July 2011Keywords:Mechanism designMulti-agent systemsService-oriented computingUncertaintyRedundancyIn emerging service-oriented systems, such as computational clouds or grids, softwareagents are able to automatically procure distributed services to complete computationaltasks. However, service execution times are often highly uncertain and service providersmay have incentives to lie strategically about this uncertainty to win more customers. Inthis paper, we argue that techniques from the field of artificial intelligence are instrumentalto addressing these challenges.To this end, we first propose a new decision-theoretic algorithm that allows a singleservice consumer agent to procure services for a computational task with a strict deadline.Crucially, this algorithm uses redundancy in a principled manner to mitigate uncertainexecution times and maximise the consumer’s expected utility. We present both anoptimal variant that uses a novel branch-and-bound formulation, and a fast heuristic thatachieves near-optimal performance. Using simulations, we demonstrate that our algorithmsoutperform approaches that do not employ redundancy by up to 130% in some settings.Next, as the algorithms require private information about the providers’ capabilities, weshow how techniques from mechanism design can be used to incentivise truthfulness.As no existing work in this area deals with uncertain execution times and redundantinvocations, we extend the state of the art by proposing a number of payment schemesfor these settings. In a detailed analysis, we prove that our mechanisms fulfil a rangeof desirable economic properties,including incentive compatibility, and we discusssuboptimal variants that scale to realistic settings with hundreds of providers. We showexperimentally that our mechanisms extract a high surplus and that even our suboptimalvariants typically achieve a high efficiency (95% or more in a wide range of settings).© 2011 Elsevier B.V. All rights reserved.1. IntroductionIncreasingly, participants in large distributed systems are able to discover and automatically procure the services ofothers. This allows service consumers to complete complex computational tasks on demand, but without the need to investin and maintain expensive hardware. Already, such a service-oriented approach is gaining popularity in a large range ofapplication areas, including grids, peer-to-peer systems, and cloud and utility computing [12,48,21].Despite its benefits, flexible service procurement poses new challenges that have not been addressed satisfactorily bycurrent research. In particular, as they are offered by external providers that are beyond the consumer’s direct control,* Corresponding author.E-mail addresses: ss2@ecs.soton.ac.uk (S. Stein), eg@ecs.soton.ac.uk (E.H. Gerding), acr@ecs.soton.ac.uk (A.C. Rogers), klarson@cs.uwaterloo.ca (K. Larson),nrj@ecs.soton.ac.uk (N.R. Jennings).0004-3702/$ – see front matter © 2011 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2011.07.0022022S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060services may display significant uncertainty in their behaviour. Thus, the execution time of services can be highly uncertain,due to concurrent access by other consumers, hardware or network problems and the provider’s scheduling policies. Thisis particularly problematic when services take a long time to complete, as is common for many computationally intensivetasks, and when consumers need to obtain their results by a certain deadline.Furthermore, in large systems, many different providers may offer functionally equivalent services that are heterogeneousin their quality and costs. This requires consumers to make appropriate decisions about which services to procure, balancingthe probability of success with the overall cost. In particular, instead of only procuring a single provider, the consumer maybenefit by redundantly procuring multiple service providers that will attempt the same task. For example, when facedwith a high-priority task but with a long deadline, a consumer may at first invoke an unreliable service at a low cost.However, as the time approaches the deadline and the task is still not completed, it may invoke another, more costly butalso more reliable service to ensure that the task is completed in time. Alternatively, when a critical task has to be completedurgently, the consumer may be better off (both in terms of costs and probability of success) by selecting multiple cheapservices immediately instead of a single premium service. This creates a challenge for the consumer, who has to make thesedecisions and wants to maximise its profit.However, even when a consumer can make optimal decisions about which services to procure and whether to employredundancy, it is faced with a second, highly related challenge. This is the fact that service providers are inherently self-interested agents and, thus, they may choose to misrepresent their capabilities if this promises to increase their profits. Forinstance, a provider may exaggerate its speed, in order to entice potential customers to procure its service, or it may inflateits costs to elicit higher payments. In these cases, consumers may end up procuring unsuitable services that are unableto complete the task in a timely or effective manner. Put differently, the consumer’s decisions may be based on wronginformation and therefore lead to suboptimal procurement strategies.Clearly, both the problems of dealing with uncertain execution times and the providers’ possible strategic behavioursare closely interrelated. More specifically, in order to address the first challenge satisfactorily, we also have to ensure thatproviders truthfully reveal their capabilities to the consumer. However, as we will see later, ensuring truthfulness, in turn,requires us to solve the service procurement problem optimally. For this reason, we address both of these intertwinedchallenges in this paper.Now, there is an array of existing techniques that apply to our setting. In particular, decision theory and computationalsearch techniques have been used to design agents that can take optimal actions in uncertain environments, while mech-anism design has been employed successfully to incentivise truthfulness in multi-agent systems. Unfortunately, however,none of the existing approaches are readily applicable to the scenario we consider here (see Section 2 for details). For thisreason, we combine and extend the current state of the art from multiple sub-fields of artificial intelligence and demonstratehow the resulting techniques can be applied to a realistic large-scale problem.In more detail, to address the first problem of uncertain execution times, we make the following contributions in ourwork:• We are the first to characterise the optimal solution to a generic service procurement problem where a service consumercan procure multiple service providers dynamically and redundantly over time, in order to complete a task by a givendeadline. To find this efficiently, we combine analytical optimisation with computational search techniques. In moredetail, we present a novel branch-and-bound algorithm that exploits specific characteristics of the procurement scenarioand that we empirically show to reduce the search for the optimal solution, on average, by over 99.9%. As this algorithmrelies on finding optimal procurement times from a continuous domain, we derive efficient closed-form solutions forboth settings with (i) independent execution durations and with (ii) perfectly correlated durations.• While our branch-and-bound algorithm quickly finds a solution in settings with dozens of providers, it does not scaleto significantly larger systems. Hence, we also present a suboptimal heuristic algorithm to the service procurementproblem. This combines some of our analytical results from the optimal algorithm with a greedy local search in a novelmanner. As a result, it is capable of scaling to settings with hundreds or even thousands of providers.• We evaluate both algorithms extensively using simulations. In doing this, we show empirically that they achieve anup to 130% improvement over techniques that do not use redundancy, that they also consistently outperform existingad hoc techniques that are used in practice and finally that our heuristic solution achieves near-optimal performance.We also note that although our algorithms perform particularly well in environments where service durations areindependently distributed, redundancy can still be beneficial in settings with perfect correlation, resulting in an averageimprovement of over 27% in certain scenarios.As the first part of our work relies on having full information about the providers’ capabilities, we also address thesecond interrelated problem of strategic behaviour with the following contributions:• To apply our algorithms in settings with private information, we extend the state of the art in mechanism design andpropose a number of novel incentive compatible mechanisms to deal with our service procurement problem. Unlikeexisting approaches, which have so far concentrated on services with a deterministic runtime and which allocate a taskonly to a single provider agent, our mechanisms can deal specifically with uncertain execution durations and multipleproviders that execute the same task in parallel. We propose several mechanisms here, in order to effectively address aS. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602023wide range of settings with varying information and computational requirements. This is needed because a mechanismthat implements the optimal procurement schedule is infeasible in settings with hundreds of potential providers and sowe present a range of suboptimal alternatives for large-scale problems, some of which can use arbitrary heuristics toselect an outcome if some information about the providers is known.1In more detail, we first consider settings where only the cost is private information and then where both the cost andservice duration distribution are private and need to be elicited. For the former case, we present several mechanismsthat vary in their information requirements about the types of providers.– A uniform pricing mechanism that is incentive compatible in dominant strategies and individually rational. Further-more, these properties continue to hold when a suboptimal heuristic is used to find an allocation. However, to achievea high efficiency (around 94%), this requires some prior knowledge about the distributions of provider types.– Two types of discriminatory pricing mechanisms that have the same economic properties as the uniform pricing mech-anism. In contrast, however, these require no specific knowledge about the provider types and still achieve a goodefficiency (87–88% on average).For settings where both costs and service duration distributions are private information, we present two further mech-anisms:– An Execution-Contingent Vickrey–Clarke–Groves (EC-VCG) mechanism that conditions payments on the earliest comple-tion time of the task. This mechanism is ex-post incentive compatible and individually rational, but it requires anoptimal solution to the service procurement problem.– An approximate EC-VCG mechanism that retains the same economic properties as the EC-VCG, but that uses a subop-timal allocation function with a polynomial run-time (in the number of providers). We show experimentally that theloss of utility in using this approximation is typically small (less than 10% or better) and can be balanced explicitlywith the computational effort required to find a solution.We stress that our contributions are not limited to applications in service-oriented systems, but we believe this domainconstitutes a compelling and timely motivation for our work. More generally, our techniques can be applied in many settingswhere a project or task of uncertain duration is outsourced. As an example of this, a critical product may need to beprocured in a dynamic supply chain application — here, the consumer may be able to choose between different producerswith uncertain production and delivery times, and the optimal strategy may include obtaining the product from multipleproviders. In another application, a government may need to urgently find a vaccine for an epidemic and can contractdifferent laboratories to work on this in parallel. Finally, another key application of our work is the emerging fields ofcrowdsourcing and human computation [47], where our work can be used to elicit uncertain completion times of a giventask from a large pool of workers and even contract several workers in parallel when this is beneficial.The remainder of this paper is structured as follows. In Section 2, we start by discussing related work, followed, inSection 3, by a formal summary of the problem we are addressing. In Section 4, we describe a generic approach for findingan optimal procurement strategy when the consumer has full information about the performance of services, and considervarious models of uncertainty. Then, we extend this in Section 5 and present mechanisms to address settings with privateinformation. In Section 6, we evaluate our strategy and mechanisms empirically and then conclude in Section 7.2. Related workThe problem of allocating computational tasks to providers with uncertain execution is not new, and several researchershave addressed specific aspects of this problem in the past. This research has been carried out in a wide range of fields —some work has looked specifically at robustness in service-oriented systems, but other highly-relevant research has beenconducted in the more general areas of scheduling and planning under uncertainty. Finally, the literature on mechanismdesign in multi-agent systems has considered settings where service provider agents need to be incentivised to reveal theircapabilities truthfully, and has also considered settings with uncertainty. In the following, we discuss each of these strandsof research in turn.2.1. Robust service procurementThere is already a considerable body of work that suggests the use of redundancy to address uncertainty. This is basedon techniques used in reliability engineering, where critical components are duplicated in order to increase the reliabilityof a system [54,8]. Now, while there are many analytical and heuristic tools in this area, they concentrate mainly on ei-ther minimising cost or failure probability, subject to constraints. We believe that this is insufficient and will concentrateinstead on the expected utility of the service consumer, which implicitly balances the cost and failure probability of a task.Nevertheless, the work in reliability engineering has given rise to similar techniques in the context of services. In this vein,a critical task can be delegated to several unreliable service providers at once, which increases the overall success probabil-ity. Such parallel redundancy has been used successfully in a number of application examples, from deployed peer-to-peersystems [1], to highly dependable Web services [24] and multi-agent systems or software engineering in general [23,59].1 For a full overview of our novel mechanisms and their specific theoretical properties, see Table 2 in Section 5.1.2024S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Instead of invoking service providers in parallel, other work has considered the serial invocation of services. Here, a par-ticular provider may be contacted first, but if it fails or takes too long, the task is then delegated to another provider.A prolific example of this includes Google’s MapReduce system, which uses this technique to execute large collections ofdata-processing tasks robustly on computational clusters [9], but this approach has also been suggested in the context ofpeer-to-peer systems [13]. Similarly, existing service frameworks often use pre-defined timeout values to determine whento switch to alternative service providers [38,10].A major shortcoming with most work discussed so far, however, is its reliance on ad hoc techniques for choosing anappropriate number of redundant services and timeout values. A more principled approach is taken by work on restartingWeb queries, which examines when such queries should be timed out and re-issued (possibly to a different provider)to ensure timely completion [6,32]. Similar work also exists in the domain of grid services [18]. However, such researchtypically assumes that only one query is active at any time and the costs of multiple queries are not explicitly balancedwith the resulting benefit.This shortcoming is addressed by Stein et al. [52], who use decision theory in this context to combine both paralleland serial redundancy to maximise the service consumer’s expected utility. They show that this approach allows the con-sumer to successfully complete its tasks within strict deadlines even when dealing with providers that are failure-prone anddisplay high duration uncertainty. In related work, they apply similar techniques to dynamic markets where service-levelagreements can be negotiated in advance [51]. Our approach will be similar to theirs, but there are a number of key dif-ferences. First, they concentrate on large workflows of interdependent tasks, necessitating the use of suboptimal heuristics.In contrast, we will consider optimal algorithms for single tasks and present an analytical solution for a particular familyof distributions. Second, their work assumes that probabilistic performance information about the service providers is avail-able to the consumer. A key contribution of this paper is a number of mechanisms that incentivise providers to reveal thisinformation truthfully to the consumer.2.2. Stochastic scheduling and planningResearch on stochastic scheduling also bears some similarities to our work. Here, the goal is to find optimal schedulesor policies for completing tasks with stochastic durations or random failures on one or more processors [42,3]. Most ofthis research does not consider redundant execution of tasks on multiple processors, and even when it is considered, themodel and objective functions are typically very different from our problem [37,44]. In particular, such work usually aimsto maximise the total number of failures that can be tolerated by a scheduling algorithm. Often there are restrictions on thelevel of redundancy (typically it is limited to one primary and one backup processor) and it is assumed that the schedulingmechanism has complete control and free access to all processors. None of these considerations and assumptions apply toour service procurement scenario.Somewhat closer to our work is the research on algorithm portfolios [22,19,27], where multiple instances of stochasticsearch algorithms are combined to produce faster and more dependable results. This is achieved by running the instances onindependent processors or by interleaving and restarting them on a single processor. However, there are several importantdifferences to our work. First, it is typically assumed that the use of processing resources is inherently free and the mainobjective is to minimise the run-time (or variance) over these resources. This is unrealistic in our settings, where resourcesare offered by self-interested agents. One exception to this is the work by Finkelstein et al. [11], which is closer to oursand explicitly considers the cost of running resources. However, like most other work on algorithm portfolios, they alsoassume that processes can be stopped and restarted at will. Such fine-grained control is often impractical in service-orientedsystems, where providers may be unwilling to surrender control over their own scheduling policies. Furthermore, theyconsider only two parallel processors and even in this case, their problem is difficult to solve optimally in practice.Another body of work that is relevant to the problem addressed in this paper is concerned with planning under uncer-tainty, especially when this explicitly considers continuous-time domains [31,33]. This research uses variations of Markovdecision problems (MDPs), but such formalisms have a number of drawbacks. First, they are very general and require a num-ber of adaptations to handle our scenario, including concurrently running and interruptible actions (i.e., to represent paralleland serial redundancy), which quickly leads to an infeasibly large state space as the number of providers increases. This isfurther exacerbated by the need to discretise action duration functions, which again increases the state space considerablyand also results in suboptimal policies.2.3. Mechanism designSo far, the work discussed in this section has concentrated on designing agent strategies to deal with uncertainty. Whenthis uncertainty was explicitly modelled, it was typically assumed that some probabilistic information about the providers’behaviour was available from past interactions or through an appropriate trust and reputation system [45,53,20]. However,this might be unrealistic in settings where interactions are very costly, where no appropriate reputation system is in place,or where new providers routinely enter the system.For such cases, some existing research has concentrated on designing appropriate mechanisms that incentivise providersto reveal private information about their cost and probabilistic performance estimates to the consumer. In particular, Porteret al. [43] suggest a mechanism that incentivises providers to report a truthful estimate of their success probability forS. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602025a given task. This is achieved by conditioning the payment to providers on whether they successfully complete the task.Ramchurn et al. [46] extend this by considering scenarios where providers also report on their perceived reliability ofother providers. While they consider potential failures, these approaches do not use redundancy to increase the consumer’ssuccess probability and they also do not consider uncertain service durations.Witwicki and Durfee [58] do investigate uncertain durations and propose a negotiation mechanism by which providersagree to provide a service by a given time with a certain probability. But their approach assumes that providers are cooper-ative (i.e., report their success probabilities truthfully), which is unrealistic in the open distributed systems we consider, andthey also do not employ redundancy. Gerding et al. [15] present mechanisms for incentivising non-cooperative providers toinvest costly resources in order to increase the probability of success of a task, and they also use redundancy to increasethe utility of the consumer. Similarly, Babaioff et al. [2] consider a general principal-agent setting where multiple serviceproviders need to be incentivised to exert some effort to complete a common task, but their individual actions cannot beverified and can have probabilistic outcomes. As a special case, their model covers the setting where multiple providerswork on the same task redundantly. However, they assume that success probabilities and costs are publicly known. Further-more, as in Gerding et al. [15], a service invocation either fails or succeeds, and they do not consider time-critical tasks.Therefore, the issue of when to invoke a certain provider is not investigated. A slightly different problem is investigated byPapakonstantinou et al. [40], who use scoring rules to incentivise agents to provide costly estimates of some probabilisticparameter. However, their setting is different in that the time to find a solution is not considered and in that multipleestimates can be merged to improve the overall quality.Several mechanisms have been proposed specifically for the domain of computational services [5]. For example, Garg etal. [14] describe how a continuous double auction can be used to allocate resources in a computational grid, while Narahariet al. [35] discuss incentive-compatible mechanisms for a similar application. These approaches do not directly apply to theproblem we consider, because they do not deal with uncertain execution times. Now, a mechanism that is closer to ourwork is used by Stein et al. [49]. Here, the authors investigate how service providers can be incentivised to reveal costs andprocessor speeds truthfully, but their work only considers uncertainty in the computational requirements of a task and notin the execution times of each provider. Their model is also fundamentally different to ours in that they allow tasks to besuspended and migrated from one provider to the next.In our work, we address several of the above shortcomings. First, we design an optimal agent strategy that explicitlybalances the benefit and associated cost of redundancy using a decision-theoretic approach, and we allow several providersto be invoked dynamically over time. Then, we develop a number of mechanisms that incentivise providers to reveal theirprivate performance information to the consumer, so that a good procurement strategy with redundancy can be found.3. Problem specificationIn this section, we begin by introducing the problem in formal terms, and then present the utility functions that describethe preferences of the agents in the system and the social welfare that represents the utility of the system as a whole. Wethen consider various scenarios in which execution uncertainty occurs in practice, and generate a number of more specificmodels based on different assumptions about the nature of this uncertainty.3.1. General settingWe consider a single service consumer A, who would like to complete a task T . The consumer derives a value V ∈ R+if the task is successfully completed within a given deadline D ∈ R+, and 0 otherwise. The problem faced by the agent isthat it is unable to execute the task on its own, and must procure the services of a third party. We assume that there are mservice providers, given by the set M = {1, . . . , m}, which can complete the task on the consumer’s behalf. The consumer caninvoke a provider i ∈ M at any time in the interval [0, D]. In particular, the consumer may have multiple services runningconcurrently for the same task. In this case, the value V is obtained if at least one of the invoked services completeswithin the required time (and no additional value is obtained if multiple services complete the task). We assume that, onceinvoked, the provider remains committed to the task until it is completed (possibly beyond the deadline). Thus, a servicecannot be interrupted.As service completion times are generally uncertain, we let Xi be a random variable describing the execution time ofprovider i, where we assume that Prob( Xi (cid:2) 0) = 0. This is the time from invocation to completion and includes any timeneeded for pre- and post-processing, queueing and data transfers. The random variables Xi for i ∈ M are distributed accord-ing to the cumulative distribution functions F i(t), where F i(t) = Prob( Xi (cid:2) t) is the probability that the task is successfullycompleted at most t time units after invocation. Furthermore, we let f i(t) = dF i(t)/dt be the corresponding probabilitydensity function. In the following, we also refer to F i as provider i’s duration function. We assume, in general, that neitherthe consumer nor the providers can actively influence the running time. However, we do not necessarily assume that therunning times of different providers are independently distributed. In Section 3.3, we will elaborate on how this uncertaintymay arise in practice and how this affects the modelling assumptions.While executing, provider i incurs a cost ci , where this cost may represent both the running costs of its computationalresources and opportunity costs from not being able to use these resources for other tasks. In the case that the cost isuncertain, because opportunities may or may not arise and because it typically depends on the execution time, ci can2026S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060also be interpreted as the expected cost. For simplicity, however, we refer to ci as a deterministic value. To compensatea provider for this cost, each provider i ∈ M receives a payment, which is given by transfer functions τi . In the case thatthe provider costs ci are publicly known, these transfers are simply equal to the costs when a provider has been invoked,and zero otherwise, regardless of whether the task succeeded in time.2 While such a setting, where providers are onlypaid their costs, is unrealistic in many settings, we will investigate it in detail in Section 4. This allows us to compute theoptimal procurement schedule with known costs and it will form the basis for private information settings. Formally, whenci is known:(cid:2)τi =ci0if provider i is invokedotherwiseOn the other hand, if the costs are private, the transfers are determined by a procurement mechanism, as discussed in Sec-tion 5, and they are typically not equal to the provider’s costs. In this section we make no particular assumption regardingthe transfer functions, only that these are calculated ex-post and can depend on all available information, including whetheror not the task succeeded within the deadline. Note that transfers can also be negative, in which case the provider incurs apenalty. Finally, we assume that all participants are expected utility maximisers.At this point, it should be noted that the described model has a number of possible extensions. First, in many applica-tions, a consumer will often face workflows of several interdependent tasks rather than just a single task. Furthermore, wemake the assumption that service costs stay constant throughout the active period of a task (i.e., between when it first be-comes available and its deadline). However, in practice, varying demand and capacity constraints may lead to more dynamiccosts3 and there may even be uncertainty about future costs. Similarly, we assume a fixed deadline and that a successfulservice result can be easily verified by the consumer, but potential future extensions of our work could examine soft oruncertain deadlines and settings where there can be uncertainty about whether a task was completed successfully or not.3.2. Procurement strategy and agent utility functionsGiven the above setting, we are interested in finding a procurement strategy ρ, which specifies a plan that determineswhich providers should be invoked and when. We denote P to be the set of all valid procurement strategies, and compactlyrepresent an element of this set as follows:Definition 1 (Procurement strategy). A procurement strategy is a vector ρ = (cid:4)(s1, t1), . . . , (sn, tn)(cid:5) ∈ P with n (cid:2) m, where eachelement represents the invocation time ti ∈ [0, D] of a provider si ∈ M. Importantly, a provider si is only invoked at time ti(and incurs cost csi ) if no provider has so far completed the task. Without loss of generality, we assume that ti (cid:2) ti+1 (i.e.,elements of the vector are ordered by their invocation time), and si (cid:6)= s j if i (cid:6)= j. We use ρ = ∅ to denote the case whereno provider is invoked.For example, assume there are four providers, M = {1, 2, 3, 4}, and ρ = (cid:4)(2, 0), (3, 0), (1, 2.5)(cid:5). Here, providers 2 and 3are invoked immediately. Then, if the task has not been completed by t = 2.5, provider 1 is also invoked, causing the threeproviders to run concurrently. Provider 4 is never invoked.Given a strategy ρ and the random variables describing the duration distributions, we would like to derive the probabilitythat task T is completed by a certain time. This is given by:Definition 2 (Completion probability). Denote by Xρ = mini∈{1,...,n}(ti + Xsi ) the random variable describing the completion(cid:2)time of the task. Then, the probability that the task T is completed by a certain time t is given by (recalling that Prob( Xsi0) = 0):(1)(2)Prob(Xρ (cid:2) t) = Prob(cid:3)(cid:5)n(cid:4)i=1Xsi(cid:2) t − tiWe are now ready to specify the utility functions of the consumer and the providers. In what follows, we specify theutility after execution of the procurement schedule, as well as the expected utility for a given procurement strategy prior toits execution.Definition 3 (Consumer’s utility). The consumer’s utility is:u A(ρ) =(cid:6)(cid:7)V −(cid:7)−i∈M τii∈M τiif Xρ (cid:2) Dif Xρ > D(3)2 Note that we have assumed that a task is always completed by a provider, even if this is after the deadline. To prevent a service provider from notinvesting any resources and thus not incurring costs, the payment can be made after completion.3 This has partly been addressed in related work [49].2027(4)(5)S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060and the consumer’s expected utility prior to execution is:u A(ρ) = V · Prob(Xρ (cid:2) D) −¯τi(ρ)(cid:8)i∈MHere, ¯τi(ρ) is the expected transfer to providers i given schedule ρ prior to its execution. The transfers depend on thedetails of the procurement mechanism that is used, but for the setting where costs are publicly known, the expected transferto provider i is simply its cost multiplied by the probability that it is invoked (which is equal to the probability that noother provider has completed the task by the time that provider i is scheduled to be invoked). In more detail, let tρ (i)indicate the invocation time of provider i in the procurement strategy ρ, where we define tρ (i) = ∞ if provider i is notpart of the schedule. Given this, ¯τi for the full information setting is calculated by4:(cid:11)(cid:12)(cid:10)¯τi(ρ) = ci ·(cid:9)1 − ProbXρ (cid:2) tρ (i)Furthermore, a service provider’s utility is defined by:Definition 4 (Service provider’s utility). Let Iρ = {si: ti (cid:2) Xρ } be the set of providers that are invoked for the task. The utilityof service provider i is:τi − ciτiif i ∈ Iρotherwiseui(ρ) =(6)(cid:6)and provider i’s expected utility prior to execution of strategy ρ is:ui(ρ) = ¯τi(ρ) − ci ·(cid:9)1 − Prob(cid:10)Xρ (cid:2) tρ (i)(cid:11)(cid:12)(7)In general, we are interested in choosing a strategy which maximises the social welfare, which is the sum of all utilitiesthat agents derive in the system. This is a natural metric for how efficiently the agents work together in achieving thetask, as it explicitly balances the benefit of successful task completion with the overall costs that are incurred. Now, sincethe actual completion time is unknown until execution, we need to consider the expected social welfare when selecting astrategy ρ. As such, this explicitly models the uncertainty in service execution times, which is a key consideration in ourwork, as described in Section 1. In what follows, we provide the equations for both the welfare and the expected welfarein turn. Note that these equations no longer contain the transfers, because these simply re-distribute utility between theagents.Definition 5 (Social welfare). The social welfare is given by:w(ρ) = u A(ρ) +(cid:8)i∈Mui(ρ) =V −(cid:7)−i∈I(ρ) cii∈I(ρ) ciif Xρ (cid:2) Dif Xρ > D(cid:13)(cid:7)The expected social welfare prior to execution is given by:w(ρ) = ¯u A(ρ) +(cid:8)i∈M¯ui(ρ) = V · Prob(Xρ (cid:2) D) −(cid:10)(cid:11)1 − Prob(Xρ (cid:2) ti)·csin(cid:8)i=1(8)(9)So far, we have not detailed how to calculate the probabilities in the above equations, in order to avoid making anyassumptions about the duration probabilities (e.g., whether service durations of different providers are independent orwhether they are correlated). We explore this issue further in the following section, where we instantiate Eq. (2) (comple-tion probability) for particular environments. This will then allow us to analytically derive the optimal invocation times ofproviders under certain conditions in Section 4.3.3. Models of uncertaintyAs a fundamental part of our model, we assume that the execution time of a service is uncertain, but so far we havenot been explicit about the nature of this uncertainty. In the following, we explore this issue in more detail and identifythree possible levels of correlation that occur in practice: environments with no correlation between the probability distri-butions of the execution time, with perfect correlation, and with imperfect correlation. Furthermore, we describe a numberof example scenarios where these different modelling assumptions are likely to apply in practice (or at least provide agood approximation) and for the first two settings we re-write Eqs. (2) and (9). This will then help us derive the optimalprocurement strategy for these settings in Section 4.4 Note that in the special case where ρ = ∅, the transfers are always 0, i.e., ¯τi (∅) = 0.2028S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20603.3.1. Independent distributionsMost of the research on task allocation with execution uncertainty assumes that the execution durations of differentproviders are independently distributed. This is a reasonable assumption in a setting where, for example, the computationalrequirements for the task are known (in terms of the number of computational cycles), but there is uncertainty about theload on the service provider’s resources at the time of execution. This may occur when the task is submitted to a queueon a computational cluster or mainframe, and there is uncertainty about the completion time of other tasks. Alternatively,the resource may be shared and concurrently running tasks, submitted by other users, may affect the duration of theconsumer’s task. As a result of this local, provider-specific uncertainty, it is reasonable to assume that service durations areindependently distributed, i.e., that there is no correlation between the execution times of different providers.5For a setting where independence can be assumed, Eq. (2) can be re-written as follows:Prob(Xρ (cid:2) t) = Prob(cid:3)n(cid:4)i=1(cid:5)Xsi(cid:2) t − ti= 1 − Prob(cid:5)Xsi > t − ti(cid:3)n(cid:14)i=1= 1 −n(cid:15)(cid:10)i=1(cid:11)1 − F si (t − ti)As a result, and given that F i(x) = 0 for x (cid:2) 0, Eq. (9) for the expected social welfare becomes:(cid:3)w(ρ) = V1 −(cid:11)1 − F si (D − ti)n(cid:15)(cid:10)i=1(cid:5)−n(cid:8)i−1(cid:15)(cid:10)csii=1j=1(cid:11)1 − F s j (ti − t j)(10)(11)3.3.2. Perfect correlationIn contrast to the provider-specific uncertainty, in other settings, the uncertainty may be associated with the task itself.That is, the task difficulty (e.g., in terms of the number of computational cycles required to solve it) is unknown a prioriand only given by a probability distribution. For example, it is generally unknown how difficult specific instances of NP-hardoptimisation problems are to solve, and techniques to estimate the empirical hardness [30] can be used to obtain a probabilitydistribution of this difficulty. Assuming that resources are immediately available and not influenced by concurrent tasks, theduration of a service can then be modelled by a deterministic function of this difficulty. Generally, however, as providers mayuse different hardware, the processing speeds and costs between providers can vary considerably for a particular difficulty.Given this, in such a setting, the execution times of different providers are perfectly correlated.We will now use an example scenario to describe this setting more formally. Let Y denote a continuous random variabledescribing the task difficulty, which is distributed according to the cumulative function G( y) and corresponding densityfunction g( y) with support [0, ∞]. The task difficulty is defined by some commonly agreed metric (the details of whichare not important for the purpose of our model). Each provider i has a quality of service function qi : R+0 , whereqi(t) denotes the maximum difficulty that provider i can solve within t time units. We assume that qi is increasing anddifferentiable, and qi(0) = 0. Furthermore, we define F i(t) = G(qi(t)) as the probability that provider i completes the taskwithin t time units (which corresponds exactly to the duration function introduced at the beginning of Section 3).→ R+0Given this formalisation, we can re-write Eqs. (2) and (9) for this setting (as we show later, in Section 4, these equationscan be simplified further for the optimal solution). In doing so, as a result of the perfect correlation, note that the unionoperator can be replaced by a maximisation, because only the provider that solves the highest difficulty in its allocated time(as given by qi(t)) influences the overall success probability:(cid:3)n(cid:4)Prob(Xρ (cid:2) t) = Prob(cid:5)(cid:16)Xsi(cid:2) t − ti= ProbY (cid:2) max1(cid:2)i(cid:2)n(cid:17)qsi (t − ti)(cid:16)= GAnd Eq. (9) becomes:i=1max1(cid:2)i(cid:2)n(cid:17)qsi (t − ti)= max1(cid:2)i(cid:2)nF si (t − ti)w(ρ) = V · max1(cid:2)i(cid:2)nF si (D − ti) − cs1−(cid:18)1 − max1(cid:2) j(cid:2)i−1(cid:19)F s j (ti − t j)·csin(cid:8)i=2(12)(13)5 Even in such a setting, however, this assumption may not be valid. It could be the case, for example, that all the providers are highly loaded in busyperiods, and the opposite holds in quiet periods. In this case, conditional independence may still be obtained, based, for example, on the time of day.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–206020293.3.3. Imperfect correlationWhile the previous two settings considered either perfect correlation between service durations or none at all, manyscenarios will contain correlation to a limited extent. For example, the computational difficulty of a problem may stillbe uncertain, as described before, but different providers may use different algorithms to solve this problem. This couldlead to imperfectly correlated execution times, as a generally hard problem will take longer to solve for all providers,but some providers may be faster on certain problems, but slower on others. Furthermore, the algorithm itself may benondeterministic or the factors mentioned in Section 3.3.1 could contribute to the duration uncertainty of a particularprovider.Although such settings with imperfect correlation are very common, they typically require a much more domain-specificmodel that describes the nature of the correlation between service durations. As a result, we do not analyse imperfectlycorrelated settings in this paper, and instead concentrate on the former two settings. However, many of our results can beextended to settings with imperfect correlation. In particular, the mechanisms presented in Section 5, which incentivise theproviders to truthfully report their costs and duration functions, also apply to the imperfect correlation case. However, thisdoes require that the problem can be solved optimally within the range of allowable outputs (this is described in more detailin Section 5). Since imperfect correlation settings are unlikely to admit an analytical solution, the time space may need tobe discretised.This concludes our discussion of the problem that we address in the paper, the utility functions that motivate agents inthe systems we consider, and the various types of execution uncertainty that may occur in practice. In the next section, wedescribe how an optimal procurement strategy can be found by the service consumer.4. Optimal service procurementFinding an optimal procurement strategy, i.e., deciding which providers to invoke at what times, is a fundamental partof this paper. First, it is of interest in current service markets, where providers typically offer their resources at fixed pricesthat are publicly listed (i.e., where transfers are not determined by a mechanism, but where they are set by providers,depending on the balance of supply and demand). Second, it will allow us to design efficient mechanisms in Section 5.In this context, we are mostly interested in maximising the expected social welfare, because this represents how well theavailable providers are used to complete the task and explicitly balances the combined costs of the providers with the valueof successful execution.Throughout this section, we will assume that both the providers’ costs ci and duration functions F i are public informationand that the consumer simply compensates providers for their incurred costs when they are invoked (i.e., τi = ci if provider iis invoked and τi = 0 otherwise). In Section 5, we will describe settings where this assumption does not hold. For now, itmeans that the social welfare and the consumer’s utility are equal, i.e., w(ρ) = ¯u A(ρ), and we are seeking an optimalstrategy ρ∗ = argmaxρ∈P w(ρ) that maximises these.can be found, we first outline an example scenario. This highlights the potential benefit ofredundancy by showing that appropriate procurement of multiple service providers can lead to a significant improvementin utility compared to relying only on a single service provider.Before we show how ρ∗4.1. Motivating exampleIn this example, a graphic designer needs to render a high-resolution image for an advertising campaign. As she needsto present her work to senior managers at a board meeting later that day, she has a strict deadline of 60 minutes (D = 60)and values the task at $100 (V = 100).Now, to complete the rendering task, she has several computational resources at her disposal. As her first option, shecan submit the task to one of several desktop PCs within her company, which are set up to use idle processing cycles torun background tasks. These are cheap (her department is billed $0.60 each time a task is submitted, i.e., cPC = 0.6), butthe completion time is highly uncertain, as the desktop may be in use by its regular owner and other concurrent tasks.Here, we assume that this uncertainty is described by an exponential distribution with a mean duration of 2 hours, i.e.,F PC(t) = 1 − e120 .− tAs her second option, she can outsource the task to a powerful mainframe computer, which is maintained by an externalcompany. This is significantly faster, due to its powerful hardware and its generally lower congestion. Hence, we here assumethe distribution F MF(t) = 1 − erun, the cost is higher, with the provider charging $60 for an invocation (cMF = 60).3 , with a mean duration of only 1.5 minutes. However, as the mainframe is expensive to− 2tAs is common in related work, the designer may now choose the service provider that promises the highest expectedutility. Using one of the desktop PCs would result in w = V · F PC(D) − cPC = 38.75, while submitting the task to the externalmainframe would yield a slightly higher utility of w = V · F MF(D) − cMF = 40. Hence, she would be best off choosing thelatter option, which will virtually guarantee successful execution by the deadline, but also incur a large cost.However, instead of choosing one provider, we now demonstrate how she could exploit redundancy to complete thetask. Here, we assume that there are three identical desktop PCs within her company (i ∈ {1, 2, 3}), as well as the externalmainframe (i = 4). For now, let us assume that durations are independently distributed, as described in Section 3.3.1. Giventhis, she can submit the job to several PCs and then later to the mainframe, to ensure that the task is completed in time. In2030S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Fig. 1. Success probability over time for ρ∗(combined) and its constituent services (desktop PC and mainframe) when durations are uncorrelated.Fig. 2. Success probability over time for ρ∗(combined) and its constituent services (desktop PC and mainframe) when durations are perfectly correlated.fact, in this setting, the optimal strategy for her is ρ∗ = (cid:4)(1, 0), (2, 0), (3, 0), (4, 54.51)(cid:5), which results in an expected utilityof w = V · (1 − (1 − F PC(D))3 · (1 − F MF(D − 54.51))) − 3cPC − cMF · (1 − F PC(54.51))3 = 82.27. This strategy is shown in Fig. 1,, as well as for the constituent services that are invoked as part of ρ∗which plots the success probability over time for ρ∗.Overall, ρ∗results in more than a 100% improvement over the best single provider strategy.Next, we examine the setting where service durations are perfectly correlated, as described in Section 3.3.2. To this end,we use the same parameters as given above (D = 60 and V = 100), but now assume that all uncertainty lies in the difficultyof the rendering task. More specifically, the designer now knows that all potential machines are idle, but she is unsure aboutthe number of processing cycles needed to complete the task. Thus, we assume that the difficulty of the task is distributed− y . Furthermore, we assume that the same local PCs and an external mainframe are availableaccording to G( y) = 1 − eand that their service durations are given, respectively, by the functions PC( y) = 120 y (where y is the task difficulty) andqMF(t) = 23 t. This results in exactly the same distribution functions as above, but the durations are now perfectly correlated.If only one provider is invoked in this setting, the best expected utility is again gained by invoking only the expensivemainframe, resulting in w = 40. When employing redundancy, we first note that, in this setting, the designer cannot gainanything by invoking more than one of the cheap desktop PCs, as their durations are always identical. However, she can stillbenefit from first invoking a cheap PC and then later a mainframe. This is because the mainframe may never be needed,but if the task is still not completed just before the deadline, it can be invoked to increase the probability of success. Morespecifically, the optimal strategy in this case is ρ∗ = (cid:4)(1, 0), (4, 52.01)(cid:5), which results in an expected utility of w = 60.02(see Fig. 2). While this is not as large as in the uncorrelated case, it still constitutes a 50% improvement over the singleprovider approach.These examples highlight the potential benefit of using redundancy for task procurement scenarios, both in the caseswhere durations are independent and when they are perfectly correlated. In the following, we discuss how an optimalprocurement strategy can be found in both cases. More specifically, we split the problem into two distinct parts and startin Section 4.2 by looking at the problem of computing the optimal invocation times, given that we already know whichproviders should be invoked and in what order. In Section 4.3, we then describe how this ordering of providers can befound.4.2. Optimal invocation timesWe are now interested in finding an optimal procurement strategy ρ∗, but we note here that this is a computationallyhard problem, due to its combinatorial nature and the nonlinear objective function. We also make the observation that ita specific case of the restless bandit problem [57]. The restless bandit problem is an extension of the multi-armed banditS. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602031problem where there are n arms and at any time t, some number M of those arms can be chosen to be activated. When anarm in state i is activated, a cost ci is incurred and it transitions to state j with probability pi j . If an arm is not activated,then no cost is incurred and it transitions to state j with probability qi j . The goal is to find a policy or schedule foractivating the arms so as to maximise average rewards. In Appendix A, we describe how the optimal procurement problemcan be modelled as a restless bandit problem. Classic multi-armed bandit problems are a special case of the restless banditproblem where qii = 1 and qi j = 0 for all i (cid:6)= j, but while the multi-armed bandit problem has an optimal solution byusing the Gittins priority-index rule [17] for which there are polynomial time algorithms, this is not the case for the restlessbandit problem. In particular, it has been shown that even in the case where only one arm is activated at a time (M = 1) andall transitions are deterministic, the problem of computing an approximately optimal schedule is PSPACE-hard [39].6 Sincethe optimal procurement problem is an instance of a restless bandit problem, where M = 1 but allowing for probabilistictransitions, we can make the following observation:Observation 1. The optimal procurement problem can be modelled as a restless bandit problem and it is PSPACE-hard tocompute an approximately optimal schedule.To solve the problem, we initially assume that the optimal subset of providers and their ordering is given. That is, weare given an ordered set of providers ρ∗= (cid:4)s1, . . . , sn(cid:5) where si is invoked before si+1. To compute the optimal procurementsschedule, we must determine ρ∗= (cid:4)t1, . . . , tn(cid:5), where ti is the invocation time of si . To this end, we compute the gradienttof the expected welfare, ∇ w(ρ∗t ) = 0 (if it exists). This results in a system of n simultaneousequations, with one equation for each ti , with constraints, ∀i: 0 (cid:2) ti (cid:2) D, and ∀i, j : i (cid:2) j ↔ ti (cid:2) t j . Solving these equations,checking the appropriate second order conditions and identifying the global maximum depend on the family of durationdistributions and can be done either analytically or numerically using standard optimisation software (as available, e.g., inMatlab, Mathematica or Maple).t ), and find its root, i.e., ∇ w(ρ∗In what follows, we will make a number of assumptions about the duration distributions, in order to derive closed-formanalytical solutions. Specifically:• We will focus on the exponential distribution, as this is commonly used for modelling uncertain service durations [55].7• As discussed in Section 3.3.3, we will concentrate on the two scenarios of independent and perfectly correlated dura-tions. We will cover these separately, as the objective functions are fundamentally different.We stress that these two assumptions do not limit the generality of our approach and the mechanisms outlined inSection 5. They simply allow us to derive simple closed-form solutions for the optimal invocation times in this section. Tothis end, in the following we start by looking at the setting with independent durations.4.2.1. Independent durationsWe now derive analytical expressions for the invocation times ρ∗t , given ρ∗s and given that the duration distributions−λit , where λi > 0 is a rate parameter. Re-writing Eq. (11) with theseof providers i ∈ M are described by F i(t) = 1 − edistributions, and computing the gradient now yield:∂ w(ρ)∂ti= −V · λsin(cid:15)−λs j (D−t j) + csiej=1(cid:3)n(cid:8)j−1(cid:15)cs jj=i+1k=1− λsi−λske(t j −tk)i−1(cid:8)i(cid:15)λsik=1j=1(cid:5)−λsk(ti −tk)eTo find the maximum, we set this to zero and divide both sides by(cid:20)ik=1 eλsk0 = −V · λsin(cid:15)−λs jDen(cid:15)λs jet j + csij=1(cid:3)n(cid:8)cs jj=i+1j−1(cid:15)−λskt jej−1(cid:15)j=i+1k=1k=i+1− λsieλsktki−1(cid:8)i(cid:15)λs jk=1j=1(cid:5)−λsktietk :(14)(15)6 This is in terms of the number of arms.7 The exponential distribution is also a memoryless distribution, which leads to a compact solution. However, similar approaches can be applied to otherdistributions, or, when an analytical solution is intractable or impossible, time can be discretised and a solution can be found for arbitrary distributions.We will return to this in Section 5.3.3 and also perform experiments with other distributions in Section 6.1.2.2032S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Here, we note that ti is independent of any t j ,j < i, i.e., the invocation time of a provider does not depend on theinvocation time of those already running. This is a result of the exponential function being memoryless, i.e., the probabilityof completing the task within the next time interval (cid:6)t is independent of when it was invoked. Hence, we can calculateeach ti by backward induction, starting with the last provider, n. The invocation time of this can be obtained directly bytaking the derivative with respect to tn (as in Eq. (15)):ln(csn·tn = D +(cid:7)n−1j=1 λs j ) − ln(V · λsn )(cid:7)nj=1 λs j(16)Furthermore, we can obtain a simpler closed-form solution for the remaining invocation times by combining and manip-ulating the partial derivatives for ti and ti+1, resulting in:i−1(cid:8)i−1(cid:15)csiλsiλs jj=1−λsk(ti −tk) −e(cid:3)n(cid:8)j−1(cid:15)cs j−λske(t j −tk)(cid:5)k=1i(cid:8)i(cid:15)λs jj=1k=1j=i+1−λsk(ti+1−tk) −ek=1n(cid:8)(cid:3)j−1(cid:15)cs jj=i+2k=1(cid:5)−λske(t j −tk)=csi+1λsi+1Then, using algebraic manipulations, we isolate ti , and derive an expression that is based solely on ti+1:ti = ti+1 −(cid:7)(cid:21)lncsi+1 λsicsi λsi+1(cid:22)(cid:7)(cid:7)i+1j=1 λs ji−1j=1 λs j1ij=1 λs j(17)(18)Note that Eq. (18) is not well defined for t1, but the optimal here is to set t1 = 0. This is because the cost will beincurred in any case and any delays would only reduce its probability of success by the deadline. Furthermore, we notethat the equations can yield negative values for some ti , indicating that the optimal values lie outside the constraints of theproblem (i.e., before the task can be started). In this case, as ti does not influence the procurement times of later providers,the optimal choice is to set ti = 0, i.e., the provider is invoked at the earliest possible time. Furthermore, the equationscan sometimes yield inconsistent values, i.e., ti > D or ti > ti+1 for some i, but this only occurs when the ordering and/orthe set of providers was non-optimal in the first place. Finally, we also note that the partial second derivatives are alwaysnegative, and since each variable is found uniquely one at a time using backward induction, the final result is optimal.In the next section, we show how the optimal invocation times ρ∗t can be found when service durations are perfectlycorrelated.4.2.2. Perfectly correlated durationsWe now consider optimal procurement strategies for scenarios where the only uncertainty stems from the difficultyof the task itself. As a result, the duration distributions are perfectly correlated and, as discussed in Section 3.3.2, whencalculating the social welfare, this allows us to replace the union operator with a maximisation operator (see Eq. (13)). Inthis section, we will simplify the equation even further in the case of an optimal procurement strategy. For convenience, wewill restate the equation in slightly different terms:w(ρ) = V · G(cid:16)max1(cid:2)i(cid:2)n(cid:17)qsi (D − ti)− cs1−(cid:16)(cid:18)1 − G·n(cid:8)i=2csi(cid:17)(cid:19)max1(cid:2) j(cid:2)i−1qs j (ti − t j)Now, the following properties enable us to considerably simplify the above equation:(19)Lemma 1. Any optimal procurement strategy (in perfectly correlated settings), ρ∗verted into an equivalent (in terms of the expected social welfare) strategy having these properties:, either has the following properties or can be con-1. The overall success probability only depends on the provider which is invoked last. Formally:argmax1(cid:2)i(cid:2)nqsi (D − ti) = n2. The probability that provider si is invoked only depends on the provider which is invoked just before it, si−1. Formally, for anyi ∈ {2, . . . , n}:argmax1(cid:2) j(cid:2)i−1qs j (ti − t j) = i − 1Proof. We prove both properties in turn. Suppose the first property does not hold, and there exists another provider skat position k in the schedule, so that argmax1(cid:2)i(cid:2)n qsi (D − ti) = k, where k < n. In that case, we can remove all providersS. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602033Fig. 3. Example showing the probability of success for each provider over time for a procurement strategy with 3 service providers, where t1 = 0, t2 = 20,and t3 = 30. This procurement schedule satisfies the first property from Lemma 1, but not the second.s j, j > k from the procurement strategy without adversely affecting the expected social welfare. To see this, note thatremoving these providers does not affect the first term in Eq. (19) (since this value is determined by provider sk), nor doesit affect the probability of invoking any of the providers up to and including the kth provider in the schedule. As a result ofthis manipulation, property (1) holds, since provider sk will be the last provider in the schedule.Now, assuming property (1) holds, we prove the second property using an inductive argument. Suppose this time thatj > i (i.e., all providers invoked after si ), but not for provider si , i (cid:2) n. That is, there existsproperty (2) holds for all s j ,a provider sk, k < i − 1, such that argmax1(cid:2) j(cid:2)i−1 qs j (ti − t j) = k. In this case, we can remove provider si−1 from theprocurement schedule without negatively affecting Eq. (19). To see this, note that provider si−1 does not affect the overallprobability of success since this is determined by provider sn (as per property (1)). Furthermore, si−1 does not affect theinvocation probability of any provider preceding it. Crucially, however, provider si−1 also does not affect the invocationprobability of provider si (since this is determined by provider sk), nor does it affect any provider s j with j > i (since,by assumption, the invocation probability is determined by provider s j−1). Now, by starting from the last provider, sn, thiselimination process can be repeated until property (2) holds. (cid:2)A graphical example to clarify these properties is depicted in Fig. 3. In this example, s3 is invoked last and can alsoachieve the maximum overall probability of success by the deadline. Therefore, this example satisfies property (1) ofLemma 1. On the other hand, note that, at t = 30 when s3 is invoked, the highest probability of success is determinedby provider s1 instead of s2. This violates property (2) of Lemma 1. We can do better, therefore, by removing provider s2from the schedule, since it does not affect the overall probability of success, nor the invocation probability of any of theother providers. However, by removing provider s2, we reduce the expected costs (hence, the strategy in Fig. 3 cannot beoptimal).Although there may exist multiple optimal strategies, due to Lemma 1 we can restrict our attention to those whichsatisfy properties (1) and (2). This way we can simplify Eq. (19) by removing the max operators, which results in:(cid:11)(cid:10)ρ∗w= V · F sn (D − tn) − cs1−(cid:12)(cid:9)1 − F si−1 (ti − ti−1)·csin(cid:8)i=2(20)In what follows, we will use the simplified equation to find the optimal strategy. As in Section 4.2.1, we can state anumber of necessary conditions for finding the optimal invocation times, given an appropriate ordering. We do this bysetting ∂ w(ρ∗)/∂ti = 0, which results in:0 = csi0 = csn· f si−1 (ti − ti−1) − csi+1· f sn−1 (tn − tn−1) − V · f sn (D − tn)· f si (ti+1 − ti), where 1 < i < n(22)where f si (x) = dF si (x)/dx. As before, we note that it is always optimal to invoke the first provider at the earliest possibletime and so t1 = 0.This gives us a system of simultaneous equations that can be solved for all ti to yield the optimal invocation times.As in Section 4.2.1, we use the exponential distribution in the following to demonstrate how this can be done in prac-tice. In more detail, we assume that F si (t) = 1 − et . This arises, for example, if the problem− y , and each provider has a qualitydifficulty Y is distributed according to an exponential distribution G( y) = 1 − eof service function qsi (t) = λsi t (i.e., for each provider, the execution time depends linearly on the difficulty). Hence,F si (t) = G(qsi (t)) = 1 − et . Moreover, for ease of notation, we let (cid:6)ti = ti − ti−1 be the waiting time between invok-ing provider si−1 and si (with (cid:6)t1 = 0), allowing us to re-write Eqs. (21) and (22) as follows:t and f si (t) = λsi e−λsi−λsi−λsi0 = csi λsi−1 e0 = csn λsn−1 e−λsi−1 (cid:6)ti − csi+1 λie−λsn−1 (cid:6)tn − V λsn e−λsi (cid:6)ti+1 , where 1 < i < n−λsn (D−tn)(23)(24)(21)2034S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Rearranging this, we see that the following equalities hold:csi λsi−1 ecsi λsi−1 e−λsi−1 (cid:6)ti = cs j λs j−1 e−λsi−1 (cid:6)ti = V λsn e−λs j−1 (cid:6)t j , where 1 < i, j (cid:2) n−λsn (D−tn), where 1 < i (cid:2) nUsing Eq. (25), we can thus easily calculate any (cid:6)ti , given another (cid:6)t j (with 1 < j):ln(csi λi−1cs j λs j−1) + λs j−1 (cid:6)t j(cid:6)ti =Given this, we note tn =λsi−1(cid:7)ni=2 (cid:6)ti and use this to replace tn in Eq. (26). This allows us to calculate (cid:6)tn directly8:csn λsn−1 e−λsn−1 (cid:6)tn = V λsn e−λsn (D−ln((cid:7)n−1i=2Solving this for (cid:6)tn, we obtain:λsi−1csicsn λsn−1)+λsn−1 (cid:6)tnλsi−1−(cid:6)tn)(cid:6)tn =ln(csn λsn−1V λsnλsn) + λsn D − λsn+ λsn−1+ λsn λsn−1n−1i=2(cid:7)1λsi−1n−1i=2ln(csi λsi−1csn λsn−1)1λsi−1(cid:7)(25)(26)(27)(28)(29)This allows us to calculate the waiting time for the last provider (cid:6)tn, which we can then use to calculate all other waitingtimes using Eq. (27). Deriving the actual invocation time ti of each provider is then trivial, i.e., t1 = 0 and ti =(cid:7)ij=1 (cid:6)t j .We now move on to the problem of finding the optimal ordering and subset of providers.4.3. Optimal provider sequenceSo far, the equations developed in Sections 4.2.1 and 4.2.2 allow us to efficiently calculate the optimal procurementtimes for a given sequence of service providers ρ∗s . However, it is not obvious how to find this optimal set and orderingof providers. Related work on economic search that orders alternatives using reservation values or allocation indices, suchas [56] or [17], does not directly apply to this case, due to the overlap of concurrently invoked providers. Furthermore,our problem includes a fixed time constraint, by which the task has to be completed. Other greedy approaches that orderservices by increasing costs, decreasing rate parameters, the ratio of these, or approaches that first select providers whoindividually yield a higher expected utility, also do not always find optimal solutions. This is because it is often best toselect cheaper, slower providers first and only invoke the more expensive and faster ones later, to ensure that the taskis completed successfully. However, when the deadline of the task is particularly short, the consumer may be forced toimmediately invoke the faster, expensive providers.As a simple example of this, we consider a set of two providers, M = {1, 2}. The first is cheap and slow with c1 = 0.2 andλ1 = 0.1, while the second is expensive and fast with c2 = 5 and λ2 = 10. For the sake of this example, their durations arehere independent. If we now assume that a consumer has a task T with deadline D = 1.5 and utility V = 100, the optimalprocurement strategy is ρ∗ = (cid:4)(1, 0), (2, 0.75)(cid:5). However, if we decrease the deadline slightly to D = 1, the optimal strategybecomes ρ∗ = (cid:4)(2, 0), (1, 0.84)(cid:5), thereby reversing the order of invoked providers. This observation suggests that a simplegreedy search for the optimal strategy is insufficient. However, using a brute-force search over all possible subsets andorderings is clearly infeasible when the number of providers rises beyond a handful, as the number of possible orderingsfor m providers is· i! =(cid:7)(cid:7)m(cid:11)i=0 m!/(m − i)!.(cid:10)mimi=0Fortunately, it is possible to quickly obtain an optimal order of providers when we make certain realistic assumptionsabout the quality of service functions in the perfectly correlated setting. We describe these assumptions in more detail inSection 4.3.1. Then, we develop a generic optimal branch-and-bound algorithm in Section 4.3.2, describing specific adjust-ments for both scenarios with independent and perfectly correlated durations. As this algorithm significantly reduces thespace of solutions that have to be searched, it copes well with larger problems with up to ten or twenty service providers.For situations where even this becomes infeasible (when there are dozens of providers or more), we also develop a fastgreedy algorithm in Section 4.3.3.4.3.1. Optimal order in perfectly correlated settingIn the perfectly correlated setting, it is often reasonable to make certain assumptions about the quality of service func-tions qi of the providers. In particular, we note that in these settings, some providers will always be able to complete amore difficult task than others within the same time period. For example, if we consider two otherwise identical PCs withclock speeds of 2 GHz (provider 1) and 3 GHz (provider 2), then it can safely be assumed that, if both run for the same8 The same procedure can be used to calculate an arbitrary (cid:6)t j . We pick (cid:6)tn here, as it leads to a simpler expression.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602035amount of time, the maximum task difficulty that provider 2 will be able to complete will always be higher. We formalisethis in the following.Assumption 1. There exists a total (strict) ordering of providers <d, where i <d j implies that qi(x) < q j(x) for all x ∈ R+.9We note that a wide range of functions satisfy this assumption, including linear and, more generally, any polynomial orexponential function, where, for each of the constants, the providers have the same order. It also applies to the functionswe assumed in Section 4.2.2. This assumption now gives us an unambiguous ordering over the providers that must bepreserved by an optimal sequence:Lemma 2. Given Assumption 1, for any two providers i and j in the optimal sequence ρ∗∗i < tt∗j .s , if i <d j, then i is invoked before j, i.e.,Proof. The proof is fairly straightforward and can be demonstrated by contradiction. Suppose that, in the optimal schedule,∗∗j (i is invoked after j). By assumption, qi(x) < q j(x) for all x (cid:3) 0. Because q j is increasing (see Section 3.3.1), qi(x) <i > tt∗q j( y) for any 0 (cid:2) x (cid:2) y. Let x = t − ti . Thismeans that, at any point in time, any task that can be completed by provider i at time t can also be completed by providerj at time t∗j , where t is the current time, then qi(t − t∗i) < q j(t − t(cid:13) < t. Therefore, provider i is superfluous, and cannot be part of ρ∗s , which contradicts the assumption. (cid:2)∗j ) for any t (cid:3) t∗i , y = t − tThe above observation is useful since it considerably reduces the search space. We can further prune this by noting thatit is never beneficial to invoke a slower, more expensive provider before a faster, cheaper provider. Intuitively, this holdsbecause we can simply invoke the second provider immediately and completely discard the first. This leads to a higheroverall success probability and reduces the expected cost, thereby increasing the social welfare. Hence, we can remove anyproviders that are dominated in this way, resulting in a sequence of providers ordered both by increasing speed (i.e., by <d)and by increasing costs.Although this now gives us an ordering for the optimal sequence, we are still left with the problem of finding theoptimal subset of providers to invoke. Thus, in the following section, we describe a generic branch-and-bound algorithmthat applies to all settings considered so far. In particular, this works for general settings with independent or perfectlycorrelated durations. In addition, when Assumption 1 applies, it uses the results from this section to speed up the search.4.3.2. Generic branch-and-bound algorithmIn this section we introduce a branch-and-bound algorithm that can be used for settings with correlated as well asindependent durations, in order to reduce the space of subsets and orderings that have to be searched. This algorithmiteratively partitions the set of solutions into smaller subsets. Each time this happens, the algorithm computes a lower andan upper bound for all solutions in a given subset, allowing it to quickly prune those subsets that cannot contain an optimalsolution (i.e., those with an upper bound that is less than some lower bound found so far).More specifically, our branch-and-bound algorithm is based on a number of general observations:• Some providers are inherently unsuitable for a given problem and therefore many orderings containing these providerscan be discarded. For example, if the consumer immediately invokes provider 1 with c1 = 9 for a task with valueV = 10, its profit will be at most 1 (no matter what other providers are invoked later). If it knows that using a differentprovider already promises a better utility than this, it can immediately discard all orderings that begin with provider 1.• As more providers are added to the end of a given ordering, their addition often has increasingly diminishing returns,allowing us to discard some solutions with many providers. For example, if the ordering (cid:4)1, 2, 3(cid:5) already promises asuccess probability close to 1, it may not be necessary to consider all solutions that start with these three providers(such as (cid:4)1, 2, 3, 4(cid:5), (cid:4)1, 2, 3, 5(cid:5), (cid:4)1, 2, 3, 4, 5(cid:5), (cid:4)1, 2, 3, 5, 4(cid:5)). This is because adding further providers to the end onlyincreases the cost, but will not significantly improve the success probability.• Some providers clearly dominate others. For example, if provider i is cheaper and faster than j, then j will never beinvoked before i.10 Hence, we can remove all orderings where j is before i.• In the correlated case, the assumption described in Section 4.3.1 may allow us to find a unique ordering over allproviders (by increasing cost and quality) that must hold in the optimal solution and it may also enable us to furtherdiscard a number of dominated providers. However, note that this only applies in the correlated case and not whendurations are independent. Hence, in the following, we will sometimes consider the independent and correlated settingsseparately where applicable.9 For simplicity here we assume the ordering to be strict at all points in time, but this requirement can be weakened.10 Note that provider i is faster than j if ∀x: F i (x) (cid:3) F j(x).2036S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Algorithm 1 Branch-and-bound algorithm.Lower(ρs )← (cid:4)(cid:5)ρs ← argmaxρs ∈QQ ← Q \ {ρs}(cid:13)Psfor all ρs1: ρ∗s2: ulower ← 03: Q ← {ρ∗}s4: while Q (cid:6)= ∅ do5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20: end while21: return FindTimes(ρ∗s )← Expand(ρs )(cid:13) ∈ P(cid:13)s do(cid:13)ˇu ← Lower(ρs)(cid:13)ˆu ← Upper(ρs)if ˆu > ulower then(cid:13)}Q ← Q ∪ {ρsif ˇu > ulower thenρ∗(cid:13)← ρssulower ← ˇuend ifend ifend forQ ← {x ∈ Q | Upper(x) > ulower}(cid:15) Best ordering found so far(cid:15) Best current lower bound(cid:15) Unexpanded orderings(cid:15) More unexpanded?(cid:15) Pick best(cid:15) Remove ρs from Q(cid:15) Expand ρs(cid:15) Find lower bound(cid:15) Find upper bound(cid:15) Sufficient upper bound?(cid:15) Keep for future expansion(cid:15) Better lower bound?(cid:15) Keep as current best(cid:15) Filter orderings(cid:15) Return best strategyFig. 4. Search tree that is explored by branch-and-bound algorithm (for M = {1, 2, 3}).sThese intuitions are captured by the branch-and-bound technique used in Algorithm 1. In more detail, we begin with anempty ordering ρ∗= (cid:4)(cid:5) (line 1), and then repeatedly consider any new ordering that can be created by appending a singleprovider to the end of an existing ordering, thus exploring a search tree as exemplified by Fig. 4 (for M = {1, 2, 3}). We dothis by keeping a queue of unexpanded orderings ( Q in line 3). Then, at each iteration of the main loop (lines 4–20), wefirst select for expansion and remove from Q the ordering (lines 5 and 6) that promises the highest lower bound. Here, thefunction Lower(ρs) is simply the utility of the ordering ρs, i.e., Lower(ρs) = w(FindTimes(ρs)), where FindTimes returnsthe optimal procurement strategy using the equations from Sections 4.2.1 and 4.2.2. This trivially represents a strict lowerbound for any ordering that starts with the providers given by ρs (i.e., in the search tree, this corresponds to ρs and all ofits children).Now, given the ordering to be expanded, ρs, we use the function Expand(ρs) in line 7 to give us a new set of orderings,(cid:13)s, each of which is created by adding a single unused provider to the end of ρs. In the search tree, this corresponds toPgenerating the children of a particular ordering. For example, in Fig. 4, Expand((cid:4)1(cid:5)) = {(cid:4)1, 2(cid:5), (cid:4)1, 3(cid:5)}. As part of this function,we also immediately remove any orderings that are clearly infeasible. This depends on the setting as follows:• When durations are independent, we remove all orderings where the last provider is dominated by any providers thatare not part of that ordering. Here, provider j is dominated by provider i if the latter is faster and costs at most asmuch as j or if i is cheaper and as fast or faster than j.• When durations are perfectly correlated and can be ordered (i.e., Assumption 1 holds), we remove all orderings wherej >d i holds for the last provider i and another provider j that is already part of the ordering (where >d is definedas in Assumption 1). We also remove all orderings where j >d i ∧ ci > c j or i (cid:2)d j ∧ j >d i ∧ ci (cid:2) c j holds for the lastprovider i and another provider j that is not part of the ordering. In other words, we always add providers that arefaster than any previously invoked providers and never any providers where a better uninvoked alternative exists (i.e.,cheaper and as least as fast, or faster and at most as expensive).11 We can safely ignore the orderings that are removed11 As mentioned earlier, note that this filtering can be efficiently implemented by precomputing a list of all providers, ordered according to <d , and thenremoving all providers where another provider is as expensive or cheaper later in the list. When running the Expand(ρs) function, we then simply onlyadd those providers that come later in the list than the last provider in ρs .S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602037in this manner, because they, and any of their children in the search tree, are bound to be sub-optimal, as described inSection 4.3.1.• When durations are perfectly correlated and cannot be ordered (i.e., Assumption 1 does not hold), we remove thesame orderings as in the independent case.For each of the new candidate solutions ρ(cid:13)bound, ˇu, and an upper bound, ˆu, on the utility of ρ(cid:13)the expected utility of ρ(cid:13)that could be achieved by adding any additional providers to the end of ρ(cid:13)scenario, we do this in the following:s generated by the Expand(ρs) function, the algorithm then considers a lowers and any of its children. As discussed above, the lower bound is simplys when using the optimal invocation times. However, calculating an upper bound on the utilitys is not immediately obvious. Depending on the(cid:13)(cid:13)(cid:20)s. If Ms by appending sρ to ρ(cid:13)= mini∈M(cid:13) ci and F sρ (x) = 1 −• If durations are independent, we let Mbe the remaining service providers that are not in ρ(cid:13)s and then calculate the upper bound as w(FindTimes(ρ(cid:13)(cid:13)i∈M(cid:13) (1 − F i(x)).12 This is based on the rationale that if any providers from M(cid:13) = ∅, then theupper bound is equal to the lower bound discussed above. Otherwise, we create a virtual service provider sρ withcsρareinvoked in any order, their cost is bound to be at least csρ and their combined probability of success within any giventime interval after invocation will never be higher than when immediately invoking all in parallel. With this reasoning,we obtain a new ordering ρ(cid:13)(cid:13)s )). If that isless than the lower bound, this indicates that it is not possible to achieve a higher utility by invoking further providers,and we can set the upper bound equal to the lower bound.We note here that occasionally the technique described in Section 4.2.1 will return inconsistent results when usingthese virtual providers. More specifically, it may be the case that tn < ti for some i < n, which violates the orderingprescribed by ρ(cid:13)(cid:13)s . Briefly, this can occur when csρ is very small compared to the previously invoked providers, causingthe second term in Eq. (18) to be negative. Normally, this would indicate that the ordering tested is suboptimal (clearly,we would want to invoke this provider as soon as possible, rather than at the end). However, in this case, sρ does notexist and we still need an upper bound without changing the initial ordering ρ(cid:13)s. Hence, when the result is inconsistent,we use a more conservative approach for calculating an upper bound. In more detail, we relax the problem and nowassume that each provider is invoked in isolation and given the full D time units to complete the task. Furthermore, allselected providers are invoked in series until one is successful within its allocated time. Given that the order of the firstinvoked providers is already fixed by ρ(cid:13)s, we then select the order of the remaining providers optimally by framing thisrelaxed problem as a simple economic search instance [56]. The expected utility of this is then a valid upper bound.• If durations are perfectly correlated and can be ordered, we take a similar approach to calculating an upper bound byagain creating a virtual service provider sρ that is guaranteed to perform better than any combination of the remainingbe the set of remaining service providers and set the cost of sρ to be the lowest cost inproviders. To do this, we let M, i.e., we set F sρ (x) = F i(x),this set, i.e., csρ(cid:13) = ∅ or when the ordering with sρsuch that i ∈ Myields a lower utility, we set the upper bound equal to the lower bound.= mini∈M(cid:13) ci , and we set the duration function to be the best available in M(cid:13)and ∀ j ∈ Mj <d i.13 As before, in the special case where M(cid:13) \ {i}:• If durations are perfectly correlated and cannot be ordered, we again have to take a slightly more conservativeapproach. Here we create a virtual service provider sρ that has the lowest cost in the set of remaining service= mini∈M(cid:13) ci . Since there may not be a single best duration function in that set, we then selectproviders, i.e., csρF sρ (x) = mini∈M(cid:13) F i(x).(cid:13)(cid:13)Now, given the lower and upper bounds for a particular candidate solution ρ(cid:13)s and all its children, we first compare itsupper bound to the utility of the best ordering found so far (line 11). If it is not greater, then we cannot improve on thebest solution so far by continuing to expand ρ(cid:13)s. Hence, we discard it from our search, thereby pruning a subset of thesearch-space. Otherwise, we add ρ(cid:13)s to Q for further expansion (line 12) and, if its utility is higher than the best orderingfound so far, we update ρ∗s and ulower (lines 14 and 15).At the end of each iteration, only unexpanded orderings with an upper bound that is higher than the currently highestlower bound are retained (line 19). This limits the size of Q (which we implemented using a priority queue), and alsoensures that it is empty when all necessary orderings have been searched. When this happens, the best ordering andassociated optimal times are returned (line 21). This final procurement strategy is optimal, because the algorithm searchesall orderings, except for those that are known not to have a better expected utility than those already considered. Hence,the optimal ordering will never be discarded from the search.In the following, we briefly illustrate the run-time behaviour of Algorithm 1 using an example problem instance. Forthis, we assume a task T with deadline D = 2 and value V = 1. There are three providers that can complete the task, asshown in Table 1, and we assume that their durations are independent. It is not obvious here whether the optimal strategyis to invoke the cheap provider 1 first, or immediately pick a more expensive and faster provider. To answer this, Fig. 5illustrates how our algorithm explores the search space. More specifically, the figure shows all candidate solutions that are12 When exponential distributions are assumed, this is equivalent to creating a new provider with λsρ= maxi∈M(cid:13) λi .13 When providers follow the exponential distribution, this is equivalent to setting λsρ(cid:7)=i∈M(cid:13) λi .2038S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Table 1Example service providers.Provider (i)123Cost (ci )0.050.70.2Rate (λi )0.52.12Fig. 5. Contents of Q during example run of Algorithm 1.considered at each iteration of the main loop (lines 4–20). Here, the search nodes in bold signify orderings that are stillmembers of Q at the end of the loop (after executing line 19), while the crossed-out nodes were considered during thatiteration, but then subsequently removed, because their children do not offer improvements over the best solution found sofar.In more detail, the algorithm starts by considering the empty ordering ρs = (cid:4)(cid:5) (step 1), which is then expanded byappending each of the available providers to the end (step 2). This results in three new candidate solutions, for whichthe algorithm computes a lower ( ˇu) and an upper bound ( ˆu), using the approaches described earlier in this section. As theordering ρs = (cid:4)2(cid:5) has an upper bound that is less than the lower bound of another solution, it is immediately discarded fromthe search (i.e., any ordering starting with provider 2 is subsequently ignored). As the other two orderings have overlappingbounds, they are both kept in Q for future expansion.Next, the ordering ρs = (cid:4)3(cid:5) is expanded, because it promises a higher lower bound than ρs = (cid:4)1(cid:5) (step 3). One of itschildren, ρs = (cid:4)3, 1(cid:5), is now the best ordering with ˇu = 0.783, but neither of the two children can be further improved uponthrough expansion, so both are discarded. The only remaining node in Q , ρs = (cid:4)1(cid:5), is then expanded (step 4), but neitherchild offers any possible improvement over 0.783, so both are discarded. As Q is now empty, the algorithm returns the bestordering found during its search, ρ∗s= (cid:4)3, 1(cid:5), which is the optimal.However, while significantly reducing the search space in most realistic settings, this algorithm still searches for theoptimal solution and may sometimes consider a large proportion of the entire search space. This may be the case, forexample, when there are large numbers of highly similar providers and when the value of the task is very large in relationto the service costs. To address such scenarios, we introduce a fast heuristic approach in the following section.4.3.3. Fast heuristic algorithmAlthough we argued in the beginning of Section 4.3 that a greedy approach does not generally result in an optimal strat-egy, it can still achieve good results in practice and is more scalable than exhaustive approaches. Hence, we present such analgorithm that starts with an empty ordering and then greedily adds, removes or switches providers until a local optimumis reached (Algorithm 2). Intuitively, this algorithm benefits from selecting providers that offer a good trade-off betweenperformance and cost. By also allowing providers to be removed or switched, it has some backtracking capabilities — thusan expensive but reliable provider can eventually be replaced by many cheap and unreliable providers that individually donot yield a high expected utility, but in combination result in a better strategy. Also, while the invocation order is generatedgreedily, the algorithm uses the results from Section 4.2 to efficiently calculate the optimal invocation times for a givenordering, thereby combining a greedy heuristic approach with optimal solution techniques.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602039Algorithm 2 Fast heuristic algorithm.← GenerateNeighbours(ρ∗(cid:13)s )Psρ(cid:13)← argmaxρs ∈Psif w(FindTimes(ρ(cid:13)← ρ(cid:13)s1: ρ∗← (cid:4)(cid:5)s∗ ← 02: u3: done ← false4: while done = false do5:6:7:8:9:10:11:12:13: end while14: return FindTimes(ρ∗s )ρ∗s∗ ← w(FindTimes(ρ(cid:13)uelsedone ← trueend ifs))∗(cid:13)sw(FindTimes(ρs))s)) > uthen(cid:15) Best ordering found so far(cid:15) Best current utility(cid:15) Reached local optimum?(cid:15) Generate neighbours of ρ∗s(cid:15) Select best neighbours ...(cid:15) ...use as next candidate(cid:15) If neighbour is better than ρ∗(cid:15) ...otherwise stop search(cid:15) Return best strategyIn more detail, the algorithm uses a function, GenerateNeighbours(ρ∗s ) in line 5, which, given a current ordering ρ∗s ,returns all possible orderings that can be obtained by the following three actions: (1) selecting a provider x which iscurrently not in ρ∗s at position i ∈ {1, 2, . . . , n + 1} (shifting other providers as necessary), (2) selecting aprovider si in ρs and removing it, or (3) selecting two providers si and s j in ρs and swapping their positions. Out of these,the best neighbour is chosen and this continues until the algorithm cannot find another better ordering. In this case, thecurrent best is returned.s and adding it to ρ∗While we have so far assumed that the consumer has complete information about the costs and duration functions ofthe providers, this is rarely available to the consumer in practice. Clearly, this is a significant obstacle, because our approachrequires this information to make informed procurement decisions. For this reason, we show in the following section howit can be extended for settings where providers have private information about their services.5. Using mechanism design to incentivise truthfulness in providersSo far, we have assumed that the consumer is provided with all the information it requires in order to compute theoptimal procurement strategy. In practice, however, information about a provider’s duration functions and its cost of execut-ing a task may not be publicly available, and instead may be closely guarded private information. When asked, a providermay refuse to reveal this information, or may lie about it, for example, by claiming a higher cost or by misrepresenting itsduration function in order to manipulate the final procurement strategy in its own favour. Since costs may be idiosyncraticand the duration functions are probabilistic, it can be very difficult for the consumer to verify whether the informationrevealed by a service provider is reliable.To address this problem, we describe a number of procurement mechanisms, which, by introducing direct competitionbetween the providers, provide incentives for them to truthfully reveal their private information to the consumer, allowingthe consumer to be confident that it really has the best procurement strategy. We consider several mechanisms here, inorder to cover a range of realistic scenarios, including where only some of the information about providers is private, andwe also present alternative mechanisms that allow the consumer to trade-off computational and information requirementswith the solution quality (see Table 2 at the end of Section 5.1 for a full summary of our proposed mechanisms and theirspecific properties).We start this section by introducing key concepts from the field of mechanism design and by clarifying our notation.We then look at designing mechanisms which are suitable for settings where the duration probabilities of all providers ispublic knowledge, but the cost of each provider must be elicited. We end the section by investigating what is possible ifboth duration and cost information is privately held by the consumers.5.1. PreliminariesMechanism design, a sub-field of game theory, studies how to design protocols for self-interested agents, so as to ensurethat certain desirable properties are achieved. A mechanism specifies three aspects of a protocol: (1) the possible actionsthat the self-interested agents may take, (2) an outcome function which selects a particular outcome given what actionsagents have taken, and (3) a transfer function that determines a payment to each of the agents, conditional on their actions.Ideally, a desirable outcome from the perspective of the mechanism designer will arise when agents are taking actionswhich are in equilibrium. While in general there need be no restrictions on the mechanism, in this paper, we will restrictour focus to direct mechanisms. A direct mechanism is one where the possible actions of the agents are restricted so thatthey are only allowed to reveal their private information, instead of taking arbitrary actions. This restriction is often madein the literature, since the Revelation Principle states that if a mechanism results in a desired outcome, then there exists adirect mechanism which will also result in the same outcome [34].In our proposed mechanisms, the service providers are asked to reveal their private information, but we make no as-sumption that the information that they reveal is their true information. In particular, we let ci and F i be the cost andduration functions of provider i, and denote the cost and duration function revealed to the mechanism by ˆci and ˆF i . We2040S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060let ˆc = (cid:4)ˆc1, . . . , ˆcm(cid:5) be the reported costs of all service providers, and define ˆF = (cid:4) ˆF 1, . . . , ˆFm(cid:5) analogously. As is standard,we use the notation ˆc−i = (cid:4)ˆc1, . . . , ˆci−1, ˆci+1, . . . , ˆcm(cid:5) to denote all cost reports except from provider i (and ˆF −i is, again,defined in a similar manner). Thus, we sometimes write ˆc = (cid:4)ˆci, ˆc−i(cid:5) and ˆF = (cid:4) ˆF i, ˆF −i(cid:5).Given the information announced by the service providers, ˆc and ˆF , it is possible to evaluate different procurementstrategies. For example, we let w(ρ|ˆc, ˆF ) denote the expected social welfare of procurement strategy ρ given the re-ports of the providers, and w(ρ|c, F ) is the true expected social welfare. Similarly, w(ρ|ˆc−i, ˆF −i) is the expected socialwelfare of procurement strategy ρ if service provider i had never existed (and thus could not be part of the pro-curement strategy). The optimal procurement strategy, given ˆc and ˆF , is ρ∗(ˆc, ˆF ) = argmaxρ∈P w(ρ|ˆc, ˆF ), and we useρ∗(ˆc−i, ˆF −i) = argmaxρ∈P w(ρ|ˆc−i, ˆF −i) to denote the optimal procurement strategy without the presence of agent i. Whenthe expected welfare and optimal procurement strategy are computed based on the same information, we will typicallyuse the abbreviated notation w(ρ∗(ˆc, ˆF )) = w(ρ∗(ˆc, ˆF )|ˆc, ˆF ). Similarly, w(ρ∗(c, F )) = w(ρ∗(c, F )|c, F ). Once the serviceproviders report ˆc and ˆF , the mechanism selects an outcome. In particular, in the rest of this section, we assume that themechanism selects ρ∗(ˆc, ˆF ) and then specifies transfer functions, τi , for each service provider. We currently do not specifyτi , but will instantiate them later in this section, depending on what properties we wish to achieve.There are several properties we desire for our mechanisms. First, the service providers cannot be forced to participate,and instead our mechanisms must be designed so that the service providers voluntarily participate. That is, we are interestedin mechanisms that are individually rational.Definition 6 (Individual rationality). A mechanism is (ex-post) individually rational, if, for any realisation of costs and durationdistributions c and F , and for all i ∈ M, the following holds:(cid:10)(cid:11)(c, F )ρ∗ui(cid:3) 0.If the utility of the providers is furthermore non-negative for any realisation of the completion time, Xρ∗(c,F ) (i.e., even afterexecution of the procurement strategy), then the mechanism is called post-execution individually rational.Second, we wish to design mechanisms which provide incentives so that the service providers are made best off whenthey reveal their costs and duration probabilities truthfully. In particular, when possible, we are interested in designingmechanisms where providers are best off revealing their true information, no matter what information the other providersreveal.Definition 7 (Incentive compatibility in dominant strategies). A mechanism is incentive compatible in dominant strategies, if, foreach provider i with ci and F i , and for all possible declarations by others, ˆc−i and ˆF −i , and for all ˆci (cid:6)= ci and ˆF i (cid:6)= F i ,(cid:10)(cid:10)ρ∗ui(cid:4)ci, ˆc−i(cid:5), (cid:4)F i, ˆF −i(cid:5)(cid:11)(cid:11)(cid:10)(cid:10)ρ∗(cid:3) ui(cid:4)ˆci, ˆc−i(cid:5), (cid:4) ˆF i, ˆF −i(cid:5)(cid:11)(cid:11)Incentive compatibility in dominant strategies is sometimes called strategy-proofness and we will use these terms inter-changeably. If a mechanism is strategy-proof, then all service providers maximise their own expected utility by truthfullyannouncing their costs and duration functions. That is, ˆci = ci and ˆF i = F i for all i. Since the mechanism selects the pro-curement strategy which maximises the social welfare given the reports of the service providers, by using an incentivecompatible mechanism, the consumer can ensure that it is being provided with appropriate information from the providers,and is thus selecting the best procurement strategy.Now, one prominent example of a mechanism that is incentive compatible in many settings is the well-known Vickrey–Clarke–Groves (VCG) mechanism [34]. This mechanism selects the outcome that maximises the social welfare and paysevery agent its marginal contribution to the overall system. This leads to several desirable properties. Specifically, in privateinformation settings, where the utility of an outcome to a particular agent is only determined by its own type, the VCGmechanism is incentive compatible in dominant strategies and it is individually rational. Furthermore, in certain settings,VCG is in fact the only incentive compatible mechanism possible [29].14 As VCG is of key importance in the mechanismdesign literature and as it fulfills incentive compatibility, we base some of our mechanisms on it.In the rest of this section, we study different scenarios and determine what the appropriate mechanisms are for thesesettings. We first assume that the duration probability information is publicly known and study what incentives must existin order to ensure that the service providers willingly reveal their costs. We then investigate what happens if both the costand duration probabilities are privately held. Table 2 provides a comprehensive summary of our results and can be used asan aid to choose the most appropriate mechanism for a given setting. The table indicates whether the mechanism handlesonly private information about costs, or both about costs and distributions, what properties distinguish each mechanism1514 This result does not directly apply here, as it assumes agents may have arbitrary utilities for outcomes (while our work assumes a restricted domainthat arises from the service procurement scenario).15 Note that some concepts, such as ex-post incentive compatibility or the poly-time approximation algorithm are introduced and discussed later in therelevant sections.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602041Table 2Summary of procurement mechanisms. Here, IC stands for incentive compatible, in DS means that it holds in dominant strategies and IR abbreviates individ-ually rational.MechanismMarginal contributionUniform pricingDiscriminatory pricingExecution-Contingent VCGApproximateExecution-Contingent VCGPrivateCosts ci(cid:4)Dist. F i×(cid:4)(cid:4)(cid:4)(cid:4)××(cid:4)(cid:4)PropertiesIC (in DS)IR (in expectation)Optimal welfareIncentive to de-commitIC (in DS)IR (post-execution)Suboptimal welfareRequires parameter kIC (in DS)IR (post-execution)Suboptimal welfareNo parameter requiredIC (ex-post)IR (in expectation)Optimal welfareIC (ex-post)IR (in expectation)Suboptimal welfareSolutionalgorithmsOptimalOptimal or greedyOptimal or greedyOptimalPoly-timeapproximationand whether the mechanism requires an optimal solution algorithm (that scales to at most dozens of providers) or can besolved using a greedy heuristic or approximation (that scales to thousands).5.2. Known duration probabilities, unknown costsWe initially assume that the duration probability functions, F i , are publicly known, but that the cost functions of eachservice provider, ci , are private.16 While each provider is free to report any cost, ˆci , it wishes, we show that it is possible todesign mechanisms for this setting, such that each provider maximises its expected utility by truthfully reporting its costs,that is ˆci = ci .5.2.1. Marginal contribution mechanismSince we assume that F i is already known, each provider is only asked to report a cost, ˆci . Given this, it is possibleto adapt the standard VCG mechanism, discussed earlier, to this setting. More formally, using the reported costs and theknown duration functions, the consumer finds the optimal procurement strategy, ρ∗(ˆc, F ). Then, before executing ρ∗(ˆc, F ),the consumer computes and pays each service provider i ∈ M a transferτi = w−i(cid:10)(cid:11)(ˆc, F )ρ∗(cid:10)(cid:11)(ˆc−i, F −i).ρ∗− w(30)The second term of the transfer, w(ρ∗(ˆc−i, F −i)), is the expected social welfare of the optimal procurement strategy ifprovider i did not exist. The first term of the transfer, w−i(ρ∗(ˆc, F )), is the expected social welfare obtained by the optimalprocurement strategy ρ∗(ˆc, F ), excluding the reported cost of provider i. That is(cid:10)(cid:11)(ˆc, F )ρ∗w−i= V · Prob(Xρ∗(ˆc,F )(cid:2) D) −n(cid:8)(cid:10)ˆcs j·j=1, j(cid:6)=i1 − Prob(Xρ∗(ˆc,F )(cid:11)(cid:2) t j)(31)We emphasise that when computing w−i(ρ∗(ˆc, F )), only provider i’s cost is ignored, but it is not removed completely fromthe social welfare. In particular, provider i’s existence in the procurement strategy may affect the probability of success andtherefore the consumer’s utility, as well as that of other providers, since it may influence whether or not they are asked toattempt a task or not. However, if provider i was never a candidate for procurement in ρ∗(ˆc, F ), then its existence has noimpact on the social welfare, and therefore w(ρ∗(ˆc−i, F −i)) = w−i(ρ∗(ˆc, F )).By defining the transfers for each service provider i as was done in Eq. (30), it is straightforward to show that serviceprovider i maximises its expected utility by truthfully reporting ˆci = ci . Let ui(ρ∗((cid:4)ˆci, ˆc−i(cid:5), F )|ci) be service provider i’sexpected utility when all other service providers report ˆc−i , provider i reports ˆci and its actual cost is ci . Then:16 The duration functions may be obtained from past or shared experiences, for example from using a trust or reputation system, or simply given by theprovider.(cid:10)1 − Prob(Xρ∗((cid:4)ˆci ,ˆc−i(cid:5),F )(cid:11)(cid:2) ti)2042S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060(cid:10)(cid:10)ρ∗ui(cid:4)ˆci, ˆc−i(cid:5), F(cid:11)(cid:11)(cid:23)(cid:23)ci(cid:10)(cid:10)(cid:10)= τi − ci ·ρ∗= w−i(cid:10)(cid:10)ρ∗(cid:4)ˆci, ˆc−i(cid:5), F= w1 − Prob(Xρ∗((cid:4)ˆci,ˆc−i (cid:5),F )(cid:11)(cid:23)(cid:23)ˆc−i, F(cid:4)ˆci, ˆc−i(cid:5), F− w(cid:11)(cid:23)(cid:11)(cid:23)(cid:4)ci, ˆc−i(cid:5), F(cid:11)(cid:11)(cid:2) ti)(cid:10)ρ∗(cid:10)− w(cid:11)(ˆc−i, F −i)ρ∗− ci ·(cid:11)(ˆc−i, F −i)(32)Since ρ∗(ˆc, F ) is, by definition, the procurement strategy which maximises w given reports ˆc, provider i can optimisethe first term from its perspective by reporting ˆci = ci . As for the second term in the utility function, w(ρ∗(ˆc−i, F −i)),provider i has no influence on this term, no matter what the revealed cost, since this is based on a procurement strategywhere provider i is excluded. Therefore, the service provider is best off revealing its true cost if it wishes to maximise itsexpected utility. That is, the mechanism is incentive-compatible in dominant strategies (i.e., strategy-proof).This is not surprising, as the mechanism just presented is simply an application of the VCG mechanism to our procure-ment setting and therefore inherits its desirable properties. However, while this marginal contribution mechanism is bothstrategy-proof and (ex-post) individually rational, it has two weaknesses. First, the mechanism is individually rational inexpectation only, and not post-execution individually rational. Thus, for particular instances, upon executing the procurementstrategy, a provider may end up with negative utility, as illustrated in Example 1 below.Example 1. Let V = 10, and assume there are two providers with costs c1 = c2 = 5. For simplicity, assume that there aretwo time steps of interest before the deadline, t1 = 0 and t2. Furthermore, let F 1(D) = F 1(D − t2) = 0.9 and F 2(D) =F 2(D − t2) = 0.8. In other words, the providers each have a 90% and 80% probability of succeeding, respectively, no matterat which time step they are invoked. In this case, it is optimal to invoke provider 1 on the first time step, and, if this fails,to invoke provider 2 on the second time step. The expected social welfare functions for different configurations are givenby:(cid:11)1 − (1 − 0.9) · (1 − 0.8)(cid:10)(cid:10)− c1 − (1 − 0.9) · c2 = 4.3(cid:11)− (1 − 0.9) · c2 = 9.31 − (1 − 0.9) · (1 − 0.8)(cid:11)− c1 = 4.81 − (1 − 0.9) · (1 − 0.8)(cid:10)wρ∗(cid:10)w−1(cid:10)ww−2(cid:10)ρ∗ρ∗w(cid:10)(cid:10)= V ·(cid:11)(c, F )(cid:11)(c, F )(cid:11)(c, F )ρ∗= V ·ρ∗= V ·(cid:11)(c−1, F −1)(cid:11)(c−2, F −2)= V · 0.8 − c2 = 3= V · 0.9 − c1 = 4And the transfers and expected utilities of the providers are:(cid:10)(cid:10)(cid:10)ρ∗ρ∗(cid:11)τ1 = w−1(c, F )(cid:11)τ2 = w−2(c, F )u1 = τ1 − c1 = 1.3u2 = τ2 − (1 − 0.9) · c2 = 0.3− w− wρ∗ρ∗(cid:10)(cid:11)(c−1, F −1)(cid:11)(c−2, F −2)= 6.3= 0.8Note that if provider 2 is never invoked, then its post-execution utility is 0.8. If, however, provider 2 is invoked, then itspost-execution utility is −4.2.In this example, note that, once the procurement strategy is executed, if provider 2 is invoked, then it has an incentiveto de-commit, that is, to refuse to execute the task and to forego the transfers from the consumer. This holds because, eventhough the transfers are positive and exceed the expected costs, they are less than the actual costs incurred upon execu-tion. Therefore, unless the consumer can otherwise enforce the schedule, for example through the use of de-commitmentpenalties, the marginal contribution mechanism may fail in practice.17The second weakness which arises with respect to the marginal contribution mechanism is the computational burdenit places on the consumer. The consumer must compute the optimal procurement strategy when considering all providersas candidates, and then the optimal procurement strategy as each provider is removed from consideration. This problemis further exacerbated by the fact that the consumer has limited computational power to start with; that is why it isprocuring services from the providers. While a heuristic algorithm was proposed for handling settings with large numberof providers (Section 4.3.3), it has been well established that many mechanisms, including VCG mechanisms like ours, maynot be incentive compatible if the outcome selected is sub-optimal and does not maximise social welfare [36].18 Therefore,heuristics and approximation algorithms must be carefully designed in order to ensure that the mechanism maintains thedesired strategic properties. To this end, in the rest of this section, we investigate alternative mechanisms which addressboth the computational overhead and post-execution individual rationality, while maintaining incentive compatibility. These17 Another approach is to require providers to place a deposit, which should be at least as high as the highest cost, but this may not be desirable, sincethis may discourage providers from participating.18 Intuitively, this is because an agent can misreport its information in order to try and manipulate the approximation in its favour.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602043mechanisms vary in their information requirements and are therefore applicable in different settings, which we will examinein more detail in Section 6.5.2.2. Uniform pricing mechanismIn the uniform pricing mechanism, the consumer first publicly announces an integer k, where 1 (cid:2) k < m. Then, as before,each provider i ∈ M reports a cost, ˆci . Without loss of generality, we assume that ˆci (cid:2) ˆci+1. We define K = {i: i ∈ M andˆci < ˆck+1} to be the set of k providers with the k lowest reported costs. This set determines the candidate providers andany provider in M \ K will not be considered when computing the procurement strategy. Let FK = (cid:4)F 1, . . . , Fk(cid:5) be a vectorwhich specifies the duration functions of each provider in K, ˆcK = (cid:4)ˆc1, . . . , ˆck(cid:5) be a vector which specifies the reportedK = (cid:4)ˆck+1, . . . , ˆck+1(cid:5) be a vector which, for each provider in K, replaces their announcedcosts for each provider in K and ˆcucost, ˆci , with the lowest cost amongst all providers not in K, that is, ˆck+1.Given the providers in K and their reported costs and publicly known duration functions, the consumer finds the pro-curement strategy which maximises social welfare while using only providers in K and assuming that their costs areall ˆck+1. That is,(cid:10)ˆcuK, F K(cid:11)ρ∗= argmaxρ∈P: si ∈Kw(cid:10)ρ|ˆcuK, F K(cid:11).Once the procurement strategy, ρ∗(ˆcuK, FK), is found, the consumer executes the strategy and records a set IK ⊆ K whichcomprises the providers in K that are actually invoked when using procurement strategy ρ∗(ˆcuK, FK) (see also Definition 4in Section 3.2). Only after the procurement strategy has been executed are the transfers to the providers determined asfollows:(cid:6)τi =ˆck+10if i ∈ IKif i ∈ M \ IK(33)We emphasise that the transfer τi is conditional on the outcome of ρ∗(ˆcuK, FK). That is, a non-zero transfer to provider i onlyoccurs if i ∈ K and i is actually invoked by the procurement strategy. Otherwise, a provider receives no transfer (but alsoincurs no cost).There are several computational advantages of the uniform pricing mechanism, compared to the marginal contributionmechanism described in the previous section. First, depending on the k chosen by the consumer, the set of candidateproviders may be significantly smaller than the entire pool of possible service providers. Secondly, the transfers of theproviders are straightforward to compute, since they merely require that the consumer is able to sort the service providersby the reported costs. Thirdly, in some settings, such as when the duration probability distributions can be ordered (e.g.,as described in Section 4.3.1), the problem of finding the optimal procurement strategy reduces down to selecting the bestprovider with the highest probability of completing the task within the deadline.Next, we show formally that the uniform pricing mechanism is both post-execution individually rational and incentivecompatible in dominant strategies.Theorem 1. Let M be the set of service providers, |M| = m. For any k such that 1 (cid:2) k < m, the uniform pricing mechanism is:• Incentive compatible in dominant strategies, and• Post-execution individually rational.Proof. We start by proving that the mechanism is incentive compatible. Assume all other providers report ˆc−i and thatprovider i’s true cost is ci . Assume that ci (cid:3) ˆck+1. Now, if provider i truthfully revealed ci , then it would not belong to K.Thus, it would not be part of the procurement strategy and thus it would incur no cost and receive no transfer. That is, itsexpected utility would be 0. If ˆci > ˆck+1, then provider i would still have zero utility since it would still not be a memberof K. If ˆci < ˆck+1 (cid:2) ci , then i ∈ K. If i is invoked, then it would incur cost ci but only receive transfer ˆck+1, resulting inutility ˆck+1 − ci (cid:2) 0. Thus, if provider i’s true cost is greater than ˆck+1, then it cannot improve its utility by misreportingits cost. Now assume that ci < ˆck+1. If invoked, then provider i would receive transfer ˆck+1 and incur cost ci , resulting inutility ˆck+1 − ci (cid:3) 0. If provider i reports any cost ˆci which is less than ˆck+1, then it will receive the same utility as if it toldthe truth about its cost. If the provider reports ˆci > ˆck+1, then it would no longer be a candidate provider and would haveutility equal to zero. Thus, again, provider i cannot improve its utility by misreporting its cost. This holds for any providerand thus the mechanism is incentive compatible in dominant strategies, or strategy-proof.We now show that the mechanism is post-execution individually rational. Assume that provider i was not invokedduring execution of the procurement strategy. Then τi = 0, but it also incurred no cost. Therefore, ui = 0. Now assume thatprovider i, with true cost ci , was invoked. The transfer it receives is τi = ˆck+1, but since i was invoked, then it must havebeen a member of K, which means that ci (cid:2) ˆck+1 by definition of K. Thereforeui = τi − ci = ˆck+1 − ci (cid:3) 0.(cid:2)2044S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060While our uniform pricing mechanism overcomes the problems we highlighted with respect to the marginal contributionmechanism, it still has some key limitations. First, the initial stage, where K is chosen, depends only on the reported costs ofthe providers and ignores the duration probabilities, possibly leading to a situation where expensive, but very fast, providersare excluded. Second, the parameter k is a key part of the mechanism, and must be announced before any provider revealscost information. To set k optimally requires a priori information about the distribution of the costs, which might be difficultto obtain.19 To address this last problem, we introduce two variations of this mechanism.5.2.3. Discriminatory pricing mechanismsAs mentioned in the previous section, one possible problem with our uniform pricing mechanism is that its effectivenessrelies heavily on the choice of an appropriate value of k. In this section, we describe two mechanisms which no longer relyon the consumer setting the parameter appropriately, and are also discriminatory in that different providers may receivedifferent transfers when invoked. These two mechanisms vary slightly in the way candidate providers are chosen and howtransfers are determined, and, as we will note later, we have selected them here as two representative examples of a moregeneral class of mechanisms.In the Pairing mechanism, each provider i ∈ M reports a cost ˆci . Then, all providers are randomly paired with anotherprovider (and if |M| = m is odd, then a single triplet is formed). For each pair, (i, j), if ˆci < ˆc j then i is put into candidate= ˆc j . This procedure results in a set K such that |K| = (cid:19)m/2(cid:20) and weset K and its paired cost, ˆcplet ˆcK denote the vector specifying the paired cost of each provider in K. Given K, the consumer computes the optimalprocurement strategy, ρ∗(ˆcK, FK), restricting itself to providers in K and using the costs from ˆci , is set so that ˆcpK:pipp(cid:10)ˆcρ∗pK, F K(cid:11)(cid:10)ρw= argmaxρ∈P: si ∈K(cid:23)(cid:23)ˆc(cid:11).pK, F KAfter ρ∗(ˆcset of providers in K actually invoked when ρ∗(ˆcpK, FK) is executed, transfers are determined for each provider. As in the previous section, let IK ⊆ K denote thepK, F K ) was executed. Then(cid:6)pˆci0τi =if i ∈ IKif i ∈ M \ IK(34)Our Halving mechanism only differs from the Pairing mechanism in the way that it selects candidate service providersfor K. As before, all service providers are asked to report a cost, ˆci . Then (cid:19)m/2(cid:20) providers are randomly selected and putinto a set G. All providers in M \ G are paired together at random and the set K is created as described in the Pairingmechanism, with each provider i ∈ K having paired cost ˆci , determined as described in the Pairing mechanism. From G,service provider g, such that ˆc g = mini∈G [ˆci], is selected and is added to K. Its paired cost is ˆc= mini∈G\{g}[ˆci]. Then, as inthe Paired mechanism, the consumer computes the optimal procurement strategy using only providers in K and their pairedcosts, and the transfers are defined similarly. While in the Halving mechanism the size of the set of candidate providers issmaller than that of the Pairing mechanism (|K| = (cid:19)m/4(cid:20) + 1 as opposed to |K| = (cid:19)m/2(cid:20)), using the larger set G increasesthe likelihood that a provider with a low paired cost will be placed in K.pgpTheorem 2. The Pairing and Halving mechanisms are incentive compatible in dominant strategies and post-execution individuallyrational.Proof. Since the pairs and G are formed independently of the providers’ reports, the proof follows from Theorem 1. (cid:2)We note that there are many possible variations of these mechanisms since different ways to group providers could beused. All the mechanisms, however, share some key features. First, the size of K is solely determined by the number ofproviders and thus does not rely on the consumer choosing an appropriate value. Second, the mechanisms do not requirea priori information about the costs of the providers, since all transfers are determined by the costs of providers whoare not members of K. Finally, they implement discriminatory pricing (i.e., different providers receive different payments),information which is then used to form the optimal procurement strategy (given K). In order to ascertain whether thesevariations offer any real benefit, compared to the uniform pricing mechanism, in practice, we experimentally evaluate themin Section 6.2.5.3. Unknown costs and duration probabilitiesIn this section, we relax the assumption that the duration distributions are known, and consider mechanisms which needto elicit both the distributions as well as the costs. To this end, we first show that the marginal contribution mechanism,an example of a VCG mechanism, from Section 5.2.1 no longer exhibits our desired properties and, in particular, providers19 Simulations, for example, or knowledge based on past experience may be ways to help determine k.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602045have an incentive to misreport their duration distributions. We then introduce a modified mechanism, which we refer to asthe Execution-Contingent VCG mechanism, where the transfers are contingent on the actual execution of the schedule and onwhether or not the task succeeded.5.3.1. Failure of the standard VCG mechanismConsider the marginal contribution mechanism, introduced in Section 5.2.1, with the modification that each provider, i, isasked to report both its cost, ˆci , and its duration probability, ˆF i . The transfers for this mechanism are calculated as follows:τi = w−i(cid:10)(cid:11)(ˆc, ˆF )ρ∗(cid:10)(cid:11)(ˆc−i, ˆF −i)ρ∗− wAs in the previous section where providers only reported their costs, provider i has no influence on the second term of thetransfer function, w(ρ∗(ˆc−i, ˆF −i)), since this is the expected social welfare that would have been achieved if provider i hadnot participated in the mechanism in the first place. However, we now show, by example, that a provider can improve itstransfer by misreporting F i in such a way that the first term of the transfer is increased, thus resulting in higher expectedutility for the provider.(cid:13)Example 2. For the sake of simplicity, suppose that provider i only misreports its duration distribution and that allother providers report truthfully. Also suppose that ρ∗(c, F ) = (cid:4)(i, 0)(cid:5). That is, given the true F i , the optimal schedule(cid:13)is to only invoke provider i and to do so without delay. Now, suppose there exists an alternative distribution, Fi , such(cid:13)that ρ∗(c, (Fi (D) > F i(D) (i.e., the probability ofsuccess by the deadline is higher).20 Clearly, since an increasing probability of success increases the consumer’s utility,i , F −i))) > w−i(ρ∗(c, F )), resulting in an increase of transfers τiw(ρ∗(c, (F(cid:13)when reporting Fi has no impact on the probability of being invoked (i.e., the allocationremains unchanged), provider i is better off doing so.i , F −i))) > w(ρ∗(c, F )), but also w−i(ρ∗(c, (F(cid:13)i instead of F i . Since reporting Fi , F −i)) = ρ∗(c, F ) = (cid:4)(i, 0)(cid:5) (i.e., the schedule remains unchanged) and F(cid:13)(cid:13)In the above example, the providers have an incentive to misreport their distributions as this will increase the perceivedexpected utility of other agents in the system, and thereby increase the perceived expected social welfare. This, in turn,leads to an increase in the transfers. In this particular case, the provider was able to increase the perceived expected utilityof the consumer agent by increasing the probability of success. However, it is equally possible to construct examples thatincrease the expected utility of other providers.Technically, the marginal contribution mechanism fails here because the expected utility of an agent (either the consumeror one of the providers) depends not only on the schedule, but also on the private information of other agents in the system(i.e., in this case the information about the duration distributions). Such settings are known as settings with interdependenttypes [28], and it has been shown that, in general, in situations where agents have interdependent types, it is impossibleto design a mechanism which ensures that the chosen outcome maximises social welfare and is incentive compatible indominant strategies (see, for example, Jehiel and Moldovanu [26]). Therefore, we need to make a concession on one of theseproperties and so, to this end, we introduce a mechanism that still maximises social welfare, but in which the informationrevealed by the service providers may depend on the actions taken by others. We make this particular choice, because weare still interested in using redundancy optimally to complete the task despite the execution uncertainty and because itturns out that we can obtain a slightly weaker notion of incentive compatibility, where truthtelling is a Nash equilibriumfor all participants, regardless of their particular types and without the need for prior distributions over these.5.3.2. Execution-Contingent VCGIn this section, we introduce a modification of our marginal contribution mechanism, where the transfers made tothe service providers are contingent on the outcome of the execution of the procurement strategy. We show that thismodification results in a mechanism which is able to elicit both the costs and the duration distributions from the serviceproviders.As before, each service provider, i, is asked to report its cost, ˆci , and its duration distribution, ˆF i . Using the reported costsand duration functions, the consumer finds the optimal procurement strategy ρ∗(ˆc, ˆF ) = argmaxρ∈P ρ(ˆc, ˆF ). This strategy isthen executed, and upon completion of execution and once the outcome is known (i.e., whether or not the task was completedsuccessfully before the deadline), the transfers of the providers are determined. Recall, from Section 3 that Xρ denotes theactual completion time of the task, and Iρ denotes the set of invoked providers. Then\{i} c j − w(ρ∗(ˆc−i, ˆF −i))(cid:2) D⎧⎨j∈I(cid:7)if Xρ∗(ˆc, ˆF )ρ∗(ˆc, ˆF )(35)τi =V −(cid:7)⎩−j∈Iρ∗(ˆc, ˆF )\{i} c j − w(ρ∗(ˆc−i, ˆF −i))otherwiseNow, as we will show in the remainder of this section, the Execution-Contingent VCG mechanism has a number of desir-able properties, but these properties hold under slightly weaker solution concepts compared to the mechanisms described20 As a concrete example, assume that F i (D) = 0.9 and F(cid:13)i (D) = 0.99, and that F i (x) = F(cid:13)i (x) = 0, for all x < D.2046S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060in Section 5.2 for known duration distributions. In particular, it is not always desirable for a provider to reveal its own costand duration distribution truthfully if others are not truthful. To illustrate this, we describe a simple example:Example 3. As in Example 1, assume that V = 10 and there are two providers with c1 = c2 = 5. Again, there are twotime steps of interest before the deadline, t1 = 0 and t2, but we now assume that provider 1 can never complete the taskin time, i.e., F 1(D) = F 1(D − t2) = 0, while provider 2 remains unchanged, i.e., F 2(D) = F 2(D − t2) = 0.8. Assume thatprovider 1 reports its cost truthfully, but lies about its duration distribution, reporting ˆF 1(D) = ˆF 1(D − t2) = 0.9. Given this,if provider 2 truthfully reports its cost and duration distribution, the mechanism will select ρ∗(ˆc, ˆF ) = (cid:4)(1, 0), (2, t2)(cid:5). Inthis case, the expected utility of provider 2 after learning the allocation, and assuming that it knows the true distributionF 1, is as follows:(cid:10)(cid:10)(cid:11)ρ∗u2(cid:11)(cid:23)(cid:23)F 1(cid:4)ˆc1, c2(cid:5), (cid:4) ˆF 1, F 2(cid:5)= F 2(D − t2) · V − ˆc1 − c2 − w= 0.8 · 10 − 5 − 5 − 4= −6(cid:10)ρ∗(cid:11)(ˆc1, ˆF 1)Clearly, provider 2 now has a negative expected utility and therefore an incentive to change the allocation so that it is nolonger included, thus deriving a utility of zero. It could do this, for example, by reporting ˆc2 = 10 or ˆF 2(D) = ˆF 2(D − t2) = 0.Since the mechanism is not incentive compatible in dominant strategies, as we just illustrated in the example, we will,instead, try to achieve a weaker notion of incentive compatibility.Definition 8 (Ex-post incentive compatibility). A mechanism is ex-post incentive compatible, if, for each provider i with ci andF i , and for all possible cost functions and duration distributions of other providers, c−i and F −i , and for all ˆci (cid:6)= ci andˆF i (cid:6)= F i ,(cid:10)(cid:10)ρ∗ui(cid:4)ci, c−i(cid:5), (cid:4)F i, F −i(cid:5)(cid:11)(cid:11)(cid:10)(cid:10)ρ∗(cid:3) ui(cid:4)ˆci, c−i(cid:5), (cid:4) ˆF i, F −i(cid:5)(cid:11)(cid:11)In words, a mechanism is ex-post incentive compatible, if, when all service providers but i report their cost and dura-tion distributions truthfully, then no matter what this revealed information is, provider i maximises its expected utility bytruthfully reporting its own cost and duration distributions. This is a weaker notion of incentive compatibility than incen-tive compatibility in dominant strategies, since truthtelling by provider i relies on all other providers also reporting theirinformation truthfully. However, it is stronger than Bayesian incentive compatibility, because it does not depend on priorknowledge of the other providers’ private information and because truthtelling is a Nash equilibrium, even when types arerevealed after the allocation. Hence, it is often regarded as a realistic solution concept in the mechanism design literature(see, for example, Bergemann and Morris [4] for a detailed discussion).Theorem 3. The Execution-Contingent VCG mechanism is:• Ex-post incentive compatible, and• Individually rational.(cid:10)(cid:10)Proof. Assume that all service providers but i truthfully report their costs and duration distributions. That is, they reportc−i and F −i . Then, if provider i reports ˆci and ˆF i , its expected utility is(cid:11)(cid:23)(cid:11)(cid:23)c−i, F(cid:4)ˆci, c−i(cid:5), (cid:4) ˆF i, F −i(cid:5)1 − Prob(Xρ∗((cid:4)ˆci ,c−i(cid:5),(cid:4) ˆF i ,F−i (cid:5))(cid:11)(cid:23)(cid:23)c, F(cid:4)ˆci, c−i(cid:5), (cid:4) ˆF i, F −i(cid:5)− wρ∗− w(cid:11)(cid:2) ti)(cid:10)ρ∗(cid:4)ˆci, c−i(cid:5), (cid:4) ˆF i, F −i(cid:5)(cid:11)(c−i, F −i)(cid:11)(c−i, F −i)− ci ·(cid:10)ρ∗= w−iρ∗(cid:10)= w(36)ρ∗(cid:11)(cid:11)ui(cid:10)(cid:10)(cid:10)(cid:11)(cid:10)First, we note that the second term on the RHS is independent of provider i’s reported cost and duration distribution.Thus, there is nothing that provider i can do to change this value, given the reports of the other providers. Secondly, thefirst term of the RHS is computed after the execution of procurement strategy ρ∗depends on thereported cost and duration probabilities, the actual outcome upon execution depends on the true distribution durations. Asa result, note that:(cid:10)ρ∗by definition of ρ∗. Thus, if all other providers truthfully report their costs and duration distributions, provider i is also bestoff revealing its information truthfully, since this will result in the mechanism selecting the procurement strategy whichoptimises the social welfare in expectation, which leads to the expected utility maximisation of provider i.. While the selection of ρ∗(cid:4)ˆci, c−i(cid:5), (cid:4) ˆF i, F −i(cid:5)(cid:4)ci, c−i(cid:5), (cid:4)F i, F −i(cid:5)(cid:11)(cid:23)(cid:23)c, F(cid:11)(cid:23)(cid:23)c, F(cid:3) wρ∗w(cid:11)(cid:10)(cid:10)(cid:11)(cid:10)S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602047The Execution-Contingent VCG mechanism is also individually rational, since(cid:10)(cid:11)(c, F )ρ∗w(cid:10)ρ∗(cid:11)(c−i, F −i)(cid:3) wimplying that ui(ρ∗(c, F )) (cid:3) 0. (cid:2)In Section 5.2.1, we identified two main drawbacks of the marginal contribution mechanism: the computational re-quirements to calculate the optimal schedule, and the fact that service providers may have an incentive to de-commit.Interestingly, the latter is no longer a problem when using Execution-Contingent VCG, despite the possibility that the post-execution utility of the provider may become negative. This is because the utility is calculated based on what actuallyhappened, and any increase in the post-execution social welfare results in the same increase in transfers. Therefore, thereis no need to impose additional penalties or a deposit to enforce the schedule. The first issue relating to the computationaloverheard of the marginal contribution mechanism still arises with the Execution-Contingent VCG. To address this problem,in the next part, we investigate how we can approximate the solution to the optimal schedule, while maintaining the prop-erties of the mechanism. Contrary to Section 5.2, however, we do so using the same mechanism and instead restrict the setof possible outcomes.5.3.3. Approximating the optimal procurement strategyAs mentioned in Section 4.3.2, computing the optimal procurement strategy becomes intractable as the number of avail-able providers increases, and this is of particular importance in our domain, as the consumer has limited computationalresources. However, as discussed in Section 5.2.1, replacing the optimal procurement strategy with a sub-optimal oneobtained through use of a heuristic or approximation algorithm, can destroy the incentive properties of the underlyingmechanism [36]. In Section 5.2, we chose to address the computational problem by considering alternative, simpler, mecha-nisms which required less computation on the part of the consumer. However, these mechanisms are not directly applicablein the current setting, because computing the optimal procurement strategy is an intrinsic part of the mechanism. For thisreason, we now propose an alternative approach for reducing the computational burden on the consumer.Nisan and Ronen showed that it is sometimes possible to have mechanisms which knowingly used sub-optimal out-comes [36]. They proposed that instead of changing the algorithm for finding the optimal outcome (in our case, the optimalprocurement strategy), one could restrict the set of possible outcomes, and then run the optimal algorithm on this restrictedset.21In what follows, we apply this approach to our procurement problem, and show that the Execution-Contingent VCGmechanism is incentive compatible for appropriately restricted outcome spaces. Furthermore, we show that this approxi-mation admits a polynomial-time algorithm to calculate the optimal (within the space of allowable outcomes) procurementstrategy. We will also show, however, that the approximation can (in the worst case) be arbitrarily far from the optimal out-come. Nevertheless, in practice we find that the outcomes are often close to optimal, as we will show in Section 6 wherewe analyse the approximation empirically.We start by showing that the EC-VCG mechanism is still incentive compatible when certain approximation schemes areused. For this, we let η denote the maximum number of service providers that can be selected as part of a procurementstrategy, and let Pη = {ρ ∈ P: |ρ| (cid:2) η) represent the reduced set of strategies. When η = 1, then the reduced set of strategiescontains only procurement strategies with no redundancy, while if η = m then Pη is the full procurement strategy space. Wepropose applying the Execution-Contingent VCG mechanism, but selecting only procurement strategies from the set Pη. Wecan show that this restricted version of the Execution-Contingent VCG mechanism is incentive compatible and individuallyrational under the assumption that η is using no information about the service providers (i.e. before the mechanism starts).Theorem 4. For any 1 (cid:2) η (cid:2) m, if the allocation is given by argmaxρ∈Pη w(ρ|ˆc, ˆF ), the Execution-Contingent VCG mechanism withthe reduced set of procurement strategies, Pη, is incentive compatible and individually rational.Proof. Since η is independent of any of the providers’ reports, no provider can increase the social welfare, and hence itstransfers, by misreporting. Therefore, the proof follows directly from Theorem 3. (cid:2)Given this, we now show that, once the parameter η is set, then finding the optimal procurement strategy in Pη becomespolynomial in the number of possible service providers, m. We illustrate this by considering two different scenarios. First, weconsider the situation where the optimal invocation times for providers can be found analytically, given a set of providersand their ordering in the procurement strategy (such settings were discussed in Sections 4.2.1 and 4.2.2 for independent andcorrelated duration distributions, respectively). The problem of finding the optimal procurement strategy then reduces tothe problem of finding the optimal ordering of the providers, among all sets of η providers. This is equivalent to searchingthrough all possible ordered subsets of set M of size η, which has size m!/(m − η)!. Once the optimal procurement schedule21 In particular, if an algorithm is maximal-in-range, then VCG-based mechanisms, applied to the restricted problem, are incentive compatible. See [36] fordetails.2048S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060is found, then the transfers for all providers must be computed. If a provider is not in the optimal procurement strategythen their transfer is automatically set to zero, and thus we only need to explicitly compute the transfers for at most ηproviders in the optimal procurement strategy. The overall cost of this is η · (m − 1)!/(m − η)!, which results in the overallcomplexity of O (mη) for running the mechanism.In the case that finding the optimal invocation schedule does not allow for a closed-form analytical solution, anotherapproach is to discretise time. Let T denote the total number of discrete time slots before the deadline D.22 Now, given anordered set of candidate providers, each of these providers has at most T possible invocation times, except for the firstprovider who should be invoked immediately (recall from Section 4 that it is always optimal to invoke the first providerwith no delay). Since there are at most η candidate providers, finding the optimal invocation times therefore requiressearching through less than T η−1 combinations. Together with finding the optimal set of ordered candidate providers, thisresults in a time complexity of O (mη · T η−1).While these approximations have a desirable computational complexity, they may result in sub-optimal solutions. Thisis because they restrict the set of solutions and this can yield an outcome that is significantly worse than the optimal —especially when the optimal strategy, ρ∗, contains many more than η providers. In fact, in the following theorem, we showthat it can be arbitrarily far from the optimal.Theorem 5. For any η (cid:3) 1, there exists an m, F and c, such that the ratio between the expected social welfare of the optimal solutionand the approximate solution is at least b, for any b (cid:3) 1. That is:w(ρ∗(c, F ))argmaxρ∈Pη w(ρ|c, F )(cid:3) b(37)Proof. We prove this by showing how to choose m, F and c, so that the above holds. For simplicity, we assume here thatdurations of different providers are independent, as shown in Eq. (10). For all i, we let ci = 0 and F i(D) = 1 − f , with11 > f (cid:3) (1 − 1b )η . Clearly, as providers are free in this example, it is always optimal to invoke all available providers at timet = 0. Given this, we can now choose m, so that Eq. (37) holds:b (cid:2)w(ρ∗(c, F ))argmaxρ∈Pη w(ρ|ˆc, ˆF )⇔ b (cid:2) (1 − f m) · V(1 − f η) · V⇔ m (cid:3) ln(1 − b · (1 − f η))ln( f )(38)Due to our initial constraints for f , this can always be satisfied. (cid:2)To conclude, we have shown that, through limiting the number of possible outcomes, we can obtain a solution which ispolynomial in the number of service providers, while maintaining the desired properties of the mechanism. However, wehave also demonstrated that, in theory, this approximation can be arbitrarily far from the optimal. Nevertheless, we believethat, in realistic settings, where providers are generally costly, the benefit of increased redundancy diminishes with thenumber of providers. Therefore, an approximate solution may often be close to the optimal, even when η is chosen to besignificantly less than m. To this end, in the next section, we empirically evaluate all of the mechanisms discussed thus far,including the approximation.6. Empirical evaluationHaving described optimal procurement strategies for scenarios with full information, as well as a number of mechanismsthat incentivise providers to reveal their capabilities truthfully, we now evaluate these approaches in a variety of simulatedenvironments. The purpose of this evaluation is two-fold and it should be seen as a complement to the theoretical resultsof the previous sections. First, we examine the potential benefit of procuring multiple providers and compare this to currentapproaches that invoke only single providers or use simple heuristics (Section 6.1). While our example from Section 4.1showed that redundancy can be beneficial, we use experiments here to quantify these benefits over a much wider rangeof realistic environments. Second, we consider the mechanisms proposed in Section 5 and investigate to what extent theiruse entails a loss in the consumer’s utility and in overall efficiency (Section 6.2). Again, while our results proved a rangeof desirable properties, some of our mechanisms are inherently suboptimal, due to the use of heuristics or approximations,and they also generally require an additional investment by the consumer to incentivise truthfulness. In this context, our22 Note that these time slots are not required to be equally spaced. However, it is important that they are set independent of the reports of the providers.Otherwise, the incentive properties may no longer hold.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602049experiments help us quantify these losses in utility over a range of settings. Finally, in Section 6.3, we discuss how ourtheoretical and empirical results can be combined to help the consumer choose the right mechanism for a particular setting.6.1. Full informationIn this section, we start by considering the full information case, where the consumer has full knowledge of the providers’costs (ci ) and duration distributions (F i ). We also assume that providers charge their true costs, i.e., τi = ci , and thereforethe social welfare is, in this case, equal to the consumers’s expected utility (as described in Section 4). Throughout thesection, we compare the average expected social welfare (w(ρ)) obtained by the optimal procurement strategy23 describedin Section 4 (Optimal) to two benchmark strategies that are designed to represent current approaches:• Single: This strategy selects the single provider that individually maximises the consumer’s expected utility. As such, itrepresents approaches that do not use redundancy at all (in fact, it is the optimal strategy given this restriction).• Timeout(p, t): This strategy first orders all providers using a preference ordering given by parameter p ∈ {cost, time,balanced}. These choices for p, respectively, order all providers by ascending cost, ci , mean duration, 1/λi , or acombination, ci/λi . The strategy then invokes the providers in that order, leaving a waiting time of t between successiveinvocations. This continues until either the task is completed or the deadline is reached. The Timeout strategy representsapproaches that are often used in existing applications to deal with uncertainty (see Section 2.1).Comparing our Optimal strategy to these benchmarks allows us to quantify the benefit of using redundancy in an optimaland principled manner to deal with execution uncertainty. Here, our evaluation is guided by the following hypothesis:Hypothesis 1. Compared to current procurement approaches, using redundancy results in a significant increase in utilityover a wide range of environments.We divide this section into two parts, corresponding to the two models of uncertainty we have covered in detail in thispaper — first, we test our approach in environments where service durations are independently distributed (Section 6.1.1)and then we consider those environments where service durations are perfectly correlated (Section 6.1.2).6.1.1. Independent durationsTo test Hypothesis 1 in settings with independent durations, we randomly generate each provider i by drawing its cost ciand duration rate λi independently and uniformly at random from [0, 1]. To consider a range of settings, tasks have eithera low (V low = 2) or a high value (V high = 8) and their deadline is either normal (Dnormal = 2) or urgent (Durgent = 0.5). Fur-thermore, throughout our evaluation we repeat all experiments 1000 times and use ANOVA and t-tests to ensure statisticalsignificance at the p < 0.05 level. As the associated confidence intervals are generally small, we omit these in most figuresfor clarity.The results are shown in Fig. 6. Here, we vary the number of providers in the system and plot the average expectedsocial welfare as a proportion of V . Observing these trends, it is obvious that using redundancy can significantly improvethe consumer’s utility and does so in almost all settings considered. In fact, when averaging over all cases considered, theOptimal approach achieves more than a 40% improvement over the Single approach. In general, this gain becomes morepronounced when the number of providers in the system increases, as there are more candidates to invoke redundantly andthe consumer can also be more selective about which providers to procure. Similarly, the gain achieved through redundancyincreases as the deadline becomes shorter. This is because redundancy allows the consumer to achieve a high successprobability, while the Single approach is limited by the single most reliable provider available. Finally, we note that the gainin utility rises for higher task values, as this justifies the higher investment caused by using redundancy.Hence, in the results shown here, the most marked improvement over the Single strategy is obtained when the deadlineis short (Durgent), the task value is high (V high) and there are many potential providers (m = 50). Here, the Single approachachieves 35.82% of V , while the Optimal achieves 82.68% — a 130% improvement that is obtained by using procurementstrategies with an average of 10–11 providers (7–8 of which are typically invoked).For comparison, the graphs also show two representative Timeout strategies — here, we chose p = balanced witht = 0.04 and t = 0.53, because these represent the parameter choices that obtain the best average utility for the settingswith Durgent, V high and Dnormal, V low, respectively.24 It is obvious that these heuristic strategies do not consistently achievegood results. The Timeout(balanced, 0.53) strategy does perform well in both settings with long deadlines, because it balancesthe cost of providers with their speed and also benefits from some redundancy, but it performs poorly in settings withshort deadlines. In fact, it performs worse here than the Single approach, because it does not reason about the probability ofcompleting the task within the tight deadline and therefore chooses providers that do not even have a significant probability23 This is found using our branch-and-bound algorithm when there are up to twelve providers. We then use the heuristic algorithm to obtain a lowerbound for the optimal when there are more providers. However, as we show later, the heuristic obtains near-optimal results.24 We obtained these by discretising t in 0.01 steps and then testing all possible parameter combinations.2050S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Fig. 6. Performance in full information setting.of success. Similarly, while the Timeout(balanced, 0.04) performs well in the scenario with a short deadline and high value, itleads to extremely poor or erratic performance in other settings. In fact, here, the strategy often invokes far more providersthan necessary and therefore incurs a large negative utility (which is outside the range of the graphs). In summary, theTimeout strategy only performs well if its parameters are carefully tuned for its particular environment, and even then,it is outperformed by our Optimal strategy. Overall, therefore, we can conclude that Hypothesis 1 holds in settings withindependent service durations.Additionally, we note that when solving the above problems, our branch-and-bound approach significantly reduces thecomputational time required when compared to a brute-force algorithm. For example, when there are 12 providers and weconsider V high and Durgent, a brute force approach searches over 1.3 billion provider orderings, which takes an average 3.3hours (using a Java implementation on a Windows-based Intel 2.2 GHz laptop with 4 GB RAM). By contrast, the branch-and-bound algorithm searches an average of 69 200 orderings (0.005% of the total search space), finding the optimal in justover two seconds. While the latter still finds solutions for 18–23 providers in minutes (where the brute-force would takeover 2 × 1010 years — longer than the age of the universe), our heuristic approach is better suited for larger settings withhundreds or thousands of providers. To investigate how its performance compares to the optimal, we have applied bothto all settings described above with twelve or fewer providers. Here, we found no statistically significant difference to theoptimal strategy (the graphs are not shown here for reasons of space).In the following, we investigate environments with perfectly correlated durations.6.1.2. Correlated durationsTo test Hypothesis 1 in these settings, we repeat the same experiments as above, but now assume that durations areperfectly correlated. Somewhat surprisingly, the Optimal approach here performs identically to the Single approach, i.e.,it also always procures only the service provider that individually yields the highest expected utility. Using redundancy,therefore, does not result in a higher utility for the consumer here, thus contradicting Hypothesis 1 in environments withperfectly correlated durations. As we will explore in more detail in the remainder of this section, this is here due to therelatively short deadline that we considered in our previous experiments. More specifically, as a result of the completecorrelation, any additional providers need some time to catch up with previously invoked providers and this negates theadvantage of procuring multiple providers when the deadline is short. Rather, it is best to immediately procure a betterprovider, in order to achieve a high probability of success. This is in contrast to the independent case, where any additionalprovider immediately contributes positively to the overall success probability. Overall, this is an interesting result, indicatingthat the simple greedy approach represented by the Single strategy is adequate and often optimal when durations areperfectly correlated.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602051Fig. 7. Performance with perfectly correlated durations.However, we note here that there are significant exceptions to this — one of which we have already highlighted inSection 4.1. In that example, using redundancy resulted in a considerable 50% improvement over the Single approach. Toinvestigate in more detail the types of environments where such improvements may be found in practice, we note thefollowing features in our example which set it apart from the settings we have considered so far in our evaluation:• Long deadline: The task in the example had a long deadline relative to the speed of at least one provider. This made itfeasible to delay the invocation of the second provider without causing a significant impact on its success probability.This is in contrast to the experiments carried out here, where even the fastest providers (i.e., when λi = 1) have a non-negligible failure probability, which is quickly decreased by any further delays. Furthermore, any redundantly invokedproviders typically need some time to catch up with previously invoked providers, i.e., to reach the time t where thecapacity of the redundantly invoked provider i is equal to that of its predecessor. Again, this reduces the potentialbenefit of using redundancy in settings with short deadlines.• Correlated cost and quality: The providers in the example displayed a correlation between their quality and cost — onewas cheap and slow, while the other one was expensive and fast. This required making an explicit trade-off betweenthese, and the redundant approach was able to benefit from combining both providers. In the setting considered above,we assumed costs and qualities were independent, thus often leading to the situation where a particular provider clearlydominated the others.With this in mind, we now consider a variation of our experimental setup. In particular, we use deadline Dnormal = 2and a high value V high = 8, but we now draw λi uniformly at random from the interval [0, 30] and determine the cost as−λi ). This means that the deadline is now very long relative to some of the providers and we also correlateci = 4 · (1 − ethe quality with the cost, which is linearly dependent on the success probability within a unit time step. As the branch-and-bound algorithm is significantly faster in the correlated setting, we solve the problem optimally for up to 100 providershere (this improvement in speed is due to the fact that we can immediately select an optimal ordering, as described inSection 4.3.1).The results for this modified setting are shown in Fig. 7. Not surprisingly, the improvement is still not as large as inenvironments with independent durations, because the overall success probability still depends only on the single bestprovider (whereas in independent settings, every provider contributes to increasing this success probability). Nevertheless,we can now see that the Optimal strategy here still offers a significant advantage over the Single strategy. In fact, overthe environments tested here, the average improvement is 6.12%. Furthermore, this relative improvement increases withthe number of available providers, resulting in a 7.14% improvement when there are 100 providers. We note that theTimeout strategy performs poorly here. Despite choosing the best p and t parameters, as before, the strategy is inherentlyineffective for the correlated case, because it invokes similar providers in sequence, which often does not increase thesuccess probability at all and instead incurs additional costs.These results indicate that using redundancy can be beneficial even in perfectly correlated settings, although the im-provement is not as pronounced as in the independent case and there are some environments where redundancy offers noadditional benefit over the Single strategy. However, we have so far assumed that the task difficulty follows an exponentialdistribution. We believe that this may be inherently less suitable to redundant procurement when durations are correlated,as it has a constant hazard rate and a density that quickly diminishes over time. Thus, a single reasonably fast provider isoften the best choice for the consumer. In the following, we consider a different scenario, where redundancy may offer amore substantial benefit.This new scenario is based on the observation that many realistic computational problems exhibit phase transitions intheir difficulty [7]. That is, although the problem may be hard to solve in the general case, many instances can be solved2052S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Fig. 8. Bi-modal distribution to simulate distinct levels of difficulty.Fig. 9. Performance with perfectly correlated durations and bi-modal distribution.quickly in polynomial time. Yet, when the problem parameters exhibit certain properties, the run-time becomes exponential.This typically happens abruptly and can be difficult to predict a priori for individual instances.As we believe that such a setting often occurs when there is uncertainty about the task difficulty (i.e., when providerdurations are correlated), we extend our evaluation here to settings where the task difficulty is a multi-modal distribution.More specifically, we assume that the task difficulty falls either into the class of relatively easy problems or into the classof hard problems, which have a significantly higher and more variable run-time. Although the difficulty is uncertain a priori,the consumer may still have a probability distribution, based on past problems and conditional on certain features of theinput data. To model this in our evaluation, we assume that the task difficulty follows a mixture of two normal distributionsthat are truncated at 0, as shown in Fig. 8.+ 2710 , . . . , 9Dn0,0.5( y)1−N0,0.5(0)10 ), and then use a brute-force search to find the optimal schedule for a given ordering of providers.More specifically, in this setting, we again assume V high and Dnormal. The problem difficulty Y is given by the densityn4,1( y)function g( y) = 51−N4,1(0) , where nλ,σ ( y) is the density function of a normal distribution with mean λ and7standard deviation σ and Nλ,σ ( y) the corresponding cumulative distribution function. The completion time of a partic-is drawn uniformly at random from [0, 2]. As before, we correlate theular provider i is given by qi(t) = λit, where λi−λi ). It should be noted that F i here no longer follows an exponential distribu-quality and cost by setting ci = 4 · (1 − etion, as we assumed in Section 4.2.2. For this reason, we restrict our invocation times to ten uniformly spaced time steps,(0, D10 , 2DThe results are shown in Fig. 9 and indicate that the Optimal approach offers a more significant improvement over theSingle approach when the problem difficulty follows a multi-modal distribution (we omit the Timeout strategy, as it againperforms very poorly). In fact, over the cases tested here, the average improvement is 24.1% and in some cases reaches27.3% (when m = 50). Compared to the exponential distribution, these problems are more conducive to using redundancy,because different providers can be used to specifically target parts of the distribution. For example, initially, a cheap providercan be procured to cover problems with a low run-time (in this example, this occurs in over 70% of all cases); then, when acertain threshold is reached, a fast provider is procured, because the task at hand is most likely one that is difficult to solve.In conclusion, we have so far shown that redundancy offers a significant benefit over the procurement of single providers.This is particularly the case when duration distributions are independent, because each additional provider increases theprobability of success and many cheap providers can be combined to obtain a high quality of service. We showed in generalthat Hypothesis 1 holds in these environments.When durations are perfectly correlated, this improvement is generally lower, because the consumer’s success probabilitydepends only on the capacity of the best service provider and because even faster providers need some time to catch upS. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602053with previously invoked providers. In some environments, especially with short deadlines, this means that redundancy mayoffer no benefit over the Single approach. However, when deadlines are long, costs and service qualities are correlated, orwhen the uncertainty follows a multi-modal distribution, redundancy can offer a clear advantage over the Single approach.While we have so far considered settings where the consumer has full information about the providers’ capabilities andcosts, we now move on to settings where this information is private.6.2. Private informationNow we consider the mechanisms described in Section 5. As mentioned there, these mechanisms have a number ofdesirable properties (including incentive compatibility and individual rationality), but some of them do not result in awelfare-maximising outcome and generally require the centre to pay providers more than their costs. However, our theo-retical results do not quantify these losses in realistic settings. To address this shortcoming, we measure the performance ofour mechanisms empirically here, by applying them to a wide range of settings. To this end, we are interested in the lossof utility in terms of social welfare (i.e., how far the solutions obtained by the mechanisms are from the optimal solution),as well as in the inherent loss of utility to the consumer caused by its lack of information about the providers’ costs andduration distributions (this latter cost is also called the information rent in the mechanism design literature [34, Ch. 23]).We start in Section 6.2.1 by considering the uniform and discriminatory pricing mechanisms we proposed to deal withscenarios where the duration probabilities are known by the consumer and only the costs are private information. We omita specific discussion of our first mechanism, the marginal contribution mechanism, because its performance in terms ofexpected social welfare and the consumer’s expected utility is equal to the Execution-Contingent VCG, which we cover indetail in Section 6.2.2. As discussed in Sections 5.2.2 and 5.2.3, both the uniform and the discriminatory pricing mechanismsfor these scenarios are generally sub-optimal, but we expect some to perform better in certain settings. Hence, in additionto quantifying the overall utility obtained by the mechanisms, our investigation is driven by the following hypotheses:Hypothesis 2. When we have sufficient information to choose k optimally, then the uniform pricing mechanism consistentlyoutperforms the discriminatory pricing mechanisms (both in terms of social welfare and the consumer’s utility).Hypothesis 3. When insufficient information is available and an inappropriate k is chosen, the uniform pricing mechanismcan perform poorly and is consistently outperformed by the discriminatory pricing mechanisms.Then, in Section 6.2.2, we turn to the Execution-Contingent VCG mechanism, which applies to cases where both theduration probabilities and costs of providers are private information. As this mechanism is efficient, i.e., always obtainsthe optimal solution, we are mostly concerned about the loss of utility caused by over-paying the providers. Since themechanism uses more information about the providers, we test the following hypothesis:Hypothesis 4. For a sufficiently large number of available providers, the Execution-Contingent VCG mechanism consistentlymatches or exceeds the consumer’s utility achieved by the uniform and discriminatory pricing mechanisms.Finally, as part of Section 6.2.2, we also consider the approximations introduced in Section 5.3.3 and investigate howthey affect the consumer’s performance.6.2.1. Uniform and discriminatory pricing mechanismsIn order to test the performance of these mechanisms, we apply them to the same settings as described in Section 6.1.1.25Fig. 10 shows the results for two particular settings — one with many providers, a short deadline and a high value and onewith fewer providers, a longer deadline and low value. These serve to illustrate the effect of varying the parameter k (beforewe move on to more general results over the whole range of environments). In more detail, for each strategy, Fig. 10shows the utility obtained by the consumer and by the providers, as well as the efficiency loss, as compared to the optimalsolution.It is immediately obvious here that all mechanisms suffer from a loss in utility for the consumer, as described above.More specifically, if the optimal k is chosen for the uniform pricing mechanism, the consumer achieves an average 86.0%and 83.4% of the optimal (respectively in the two example settings). In terms of social welfare, this corresponds to 95.4%and 94.6% of the optimal. Compared to this, the discriminatory pricing mechanisms achieve an average consumer’s utilitythat is 72.0% of the optimal, and an average social welfare that is 85.5% of the optimal. These results highlight that despitetheir simplicity, the proposed mechanisms can achieve a good performance compared to the optimal. Furthermore, choosingk optimally here clearly offers an advantage over the discriminatory mechanisms, thus supporting Hypothesis 2.Our second observation here is that the performance of the uniform pricing mechanism depends heavily on the choice ofk and can be as low as 25% of the optimal if the wrong parameter is chosen. Furthermore, the best parameter depends on25 As before, we solve the problem optimally when there are twelve or fewer providers and use the heuristic for settings with more providers.2054S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Fig. 10. Performance of incentive compatible mechanisms.Fig. 11. Performance of incentive compatible mechanisms over all environments (average expected consumer’s utility).the scenario. For example, for the task with V low, k = 3 is the best choice for maximising the consumer’s utility, achievingover 83.4% of the optimal. However, for V high, it is one of the worst, achieving only 58%. Hence, these results indicate thata consumer can achieve a good utility by using appropriate k parameters. However, when k is set incorrectly (e.g., wheninsufficient information is available about the environment), it can obtain better results by using one of the discriminatorypricing mechanisms, which consistently perform well. This supports Hypothesis 3.Finally, to generalise these observations, Fig. 11 plots the performance of the mechanisms in terms of the average ex-pected consumer’s utility over all environments considered in this section.26 In Fig. 12, we plot the corresponding average26 Note we discuss the performance of the Execution-Contingent VCG mechanism, labelled as EC-VCG, in Section 6.2.2.S. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602055Fig. 12. Performance of incentive compatible mechanisms over all environments (average expected social welfare).expected social welfare. For brevity, we replace all choices for k by a Best-k and a Worst-k mechanism, which show theperformance when k is chosen to maximise and minimise the expected consumer’s utility, respectively.27 Here, we notethat the discriminatory pricing mechanisms consistently perform worse than Best-k (supporting Hypothesis 2), but simi-larly outperform Worst-k (supporting Hypothesis 3). Neither of the two discriminatory pricing mechanisms dominates theother, but we generally observe that the Halving mechanism performs better in the low value (V low) environments thanthe Pairing mechanism. This is due to the fact that the Halving mechanism usually results in at least one cheap providerat the expense of having fewer candidate providers to choose from. This is advantageous in the low value case, becausethe consumer prefers to invoke fewer and cheaper providers here. Furthermore, in Fig. 12, we notice that the mechanismsgenerally achieve a good overall social welfare.286.2.2. Execution-Contingent VCGIn this section, we now consider our final mechanism, the Execution-Contingent VCG, which can be applied in settingswhere both the duration distributions and costs are private information. Again, we apply this mechanism to the samesettings as in the previous section.29 The results of this are plotted in Figs. 11 (average expected consumer’s utility) and 12(average expected social welfare).First, we note that since the Execution-Contingent VCG is efficient (i.e., always selects the social welfare maximisingoutcome), its average expected social welfare is equal to the performance of the optimal strategy in the full informationsetting. In terms of the consumer’s utility, there are two prominent trends over all environments. Initially, when there arefew providers, the Execution-Contingent VCG achieves a comparably low utility for the consumer. This is because eachprocured provider is more likely to make a significant contribution and thus receives a high payment from the mechanism(more specifically, the utility that would be obtained without that provider’s presence is typically considerably lower).27 We implement this by considering the average results of all possible choices for k. We then pick the parameter k that yielded the highest or lowestaverage utility for the consumer and re-run the experiments with that parameter.28 The performance plots in that figure are not as smooth in the previous figures. This is because the mechanisms do not explicitly optimise for theexpected social welfare, but rather for the consumer’s utility. Thus, short downwards trends are sometimes observed, especially for the performance of theBest-k strategy, where a particular choice of k may be optimal for the consumer’s utility, but not necessarily for the social welfare. This phenomenon isevidenced also by the first scenario in Fig. 10, where k = 10 maximises the consumer’s utility, but k = 11 maximises the social welfare.29 Here, we again obtain results for thirteen or more providers using our heuristic approximation. In this particular setting, it must be noted that themechanism is then no longer incentive compatible. However, as we argued earlier, the heuristic is a close approximation to the optimal case and so wenevertheless show the results to provide an intuition of the mechanism’s performance.2056S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060Table 3Summary of empirical results (compared to optimal social welfare in full information setting).MechanismUniform pricing (Best-k)Discriminatory pricing (pairing)Discriminatory pricing (halving)Execution-Contingent VCGConsumer’s utility(% of optimal)85.84%76.70%77.34%85.59%Social welfare(% of optimal)94.37%86.58%88.24%100.00%Fig. 13. Performance of Execution-Contingent VCG when approximating the optimal schedule.However, as the number of providers in the system increases, the utility obtained by the Execution-Contingent VCG quicklyrises, in most cases eventually exceeding the performance of all other mechanisms tested. In the first scenario (D urgent andV low), it only slowly approaches the performance of the Best-k mechanism, but as m is increased further, it also eventuallydominates the latter (these results are not shown here). Overall, these results support Hypothesis 4. To summarise, theoverall averaged performance results of all mechanisms shown in Figs. 11 and 12 are given in Table 3.To conclude this section, we consider the effect of using approximations for the Execution-Contingent VCG mechanism.As argued in Section 5.3.3, such approximations allow the mechanism to remain incentive compatible even in settings withmany agents. To this end, we consider the same environments examined thus far, but fix the number of total providersin the system to m = 50 (to consider a setting with many providers). We then record the performance of the Execution-Contingent VCG mechanism as we vary the maximum number of providers that are included in the allocation, i.e., theparameter η from Section 5.3.3. Both the average consumer’s utility and the social welfare obtained are plotted in Fig. 13.These results are positive, indicating that the mechanism performs well even if the number of providers in the finalsolution is restricted. In most scenarios, only two or three providers are required to perform close to the optimal, while theurgent and high value scenario requires four providers to achieve over 90% of the optimal social welfare. It is somewhatsurprising here that the consumer’s utility often reaches the equivalent utility of the optimal case more quickly and insome cases even exceeds it by a small amount. Intuitively, this is because using fewer providers increases the competitionbetween those that are selected, thereby increasing the transfers they receive. This means that if the consumer is primarilyinterested in maximising its own profit rather than finding the efficient outcome, even fewer providers are required toachieve a good solution. Also, as the social welfare maximising outcome is not necessarily optimal for the consumer, it mayeven reap a small benefit by choosing η strategically. Furthermore, we note here that the time to find a solution is still fasteven when choosing a high η. For example, when η = 6, it takes an average of six seconds in the urgent and high valueS. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602057scenario; when η = 7, this rises to 45 seconds. These trends continue to hold for larger numbers of providers, and evenproblems with hundreds of providers can be solved in minutes or faster (see [16] for further results).6.3. Choosing the right mechanismTo conclude this section, we now summarise our main theoretical and empirical results for each of the mechanisms. Thisbuilds on Table 2 and briefly describes the main information requirements, the scalability, expected performance (based onthe results in this section) and other advantages and disadvantages of each mechanism. As such, it is intended to help aservice consumer select a suitable mechanism for a particular setting.• Marginal contribution:– Information requirements: Duration distributions need to be known by the consumer (e.g., through previous interac-tions or an appropriate trust and reputation system).– Scalability: Few providers (dozens or fewer), as it requires the consumer to compute an optimal procurement schedule.– Performance: Optimal social welfare, high utility to the consumer after transfers (around 85% of the optimal).– Advantages: Incentive compatible in dominant strategies.– Disadvantages: Vulnerable to de-commitments, which can be mitigated by imposing high penalties on non-compliantproviders or by collecting a deposit prior to invocation. Also only individually rational in expectation, i.e., providerscan sometimes incur a negative utility.• Uniform pricing:– Information requirements: Known duration distributions and some knowledge about the providers’ cost distributions.The latter is required to set the parameter k. More specifically, such knowledge would in practice arise from previousinteractions with providers or general domain knowledge, and would allow the consumer to simulate the mechanismfor various choices of k prior to execution.– Scalability: Many providers (hundreds or thousands).– Performance: Near-optimal social welfare (around 95% of the optimal), high consumer’s utility (around 85% of theoptimal).– Advantages: Incentive compatible in dominant strategies and post-execution individually rational (providers nevermake a loss).– Disadvantages: High information requirements.• Discriminatory pricing:– Information requirements: Known duration distributions.– Scalability: Many providers (hundreds or thousands).– Performance: High social welfare (around 86–87% of the optimal), reasonable consumer’s utility (around 77% of theoptimal).– Advantages: Incentive compatible in dominant strategies and post-execution individually rational.– Disadvantages: Lower performance than other mechanisms.• Execution-Contingent VCG:– Information requirements: None.– Scalability: Few providers (dozens).– Performance: Optimal social welfare, high consumer’s utility (around 85% of the optimal).– Advantages: Low information requirements — elicits both truthful reports about costs and duration distributions.– Disadvantages: Ex-post incentive compatible (weaker than in dominant strategies) and only individually rational inexpectation.• Approximate Execution-Contingent VCG:– Information Requirements: None.– Scalability: Many providers (hundreds, depending on parameter η).– Performance: Close to Execution-Contingent VCG if sufficiently high η is chosen.– Advantages: Low information requirements.– Disadvantages: Ex-post incentive compatible and individually rational in expectation. Requires parameter η to be setby the consumer, but the choice is less critical than the parameter k of the uniform pricing mechanism. Specifically,it should generally be set to the highest feasible value given the computational constraints of the consumer. However,even with relatively low values (around η = 6 in the settings we tested), a performance that is almost equivalent tothe optimal Execution-Contingent VCG can be achieved.7. ConclusionsIn this paper, we developed a novel approach for procuring services with uncertain execution durations in an optimalmanner. This approach uses redundancy to increase the probability that a task is completed by a given deadline and ex-plicitly balances the cost of redundancy with its benefit. In order to deal with large systems that may contain many (tens)2058S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060service providers, we proposed an optimal branch-and-bound algorithm to significantly reduce the search space and also anear-optimal greedy heuristic which can deal with hundreds or even thousands of providers.We believe that our technique can be applied to a variety of realistic service-oriented settings, including grids and cloudcomputing, where services are offered by potentially unreliable providers. To highlight the benefit of using redundancy, wesimulated these environments and showed empirically that it leads to a significant improvement in performance. In somecases, when the deadline of the task was short and the value high, using redundancy resulted in a 130% improvement overapproaches that procure only a single provider, as is commonly done in existing task allocation scenarios. In our work, weinvestigated different sources of uncertainty and we showed that redundancy is most beneficial when service durationsare independent. Surprisingly, however, redundancy can still offer a significant advantage even in settings where servicedurations are perfectly correlated (up to 27%).Now, in order to procure services optimally, the consumer requires probabilistic performance information about theavailable services. While some existing work has considered the use of reputation systems in this context, such systemsmay not be available or there may be insufficient information about particular providers. To address such settings, welooked into techniques from mechanism design to incentivise providers to reveal their private performance information tothe consumer. In particular, we developed a number of novel mechanisms that can be applied in different scenarios.The first two of these, the uniform pricing mechanism and the discriminatory pricing mechanisms, apply to settingswhere only service costs are private information. These have highly desirable properties — they are incentive compatible indominant strategies and are post-execution individually rational — and they retain these properties even when a sub-optimaloutcome is chosen by the mechanism. For settings where costs and duration functions are private information, we showedthat the standard VCG mechanism is no longer incentive compatible as providers can profit from inflating their responsetimes. To address this, we proposed a novel Execution-Contingent VCG mechanism. This is ex-post incentive compatible,individually rational and efficient. However, unlike the other mechanisms, it has to select the optimal outcome, which canbe intractable for very large environments. To address this, we developed a simple approximation, which can be found inpolynomial time and which we demonstrated to achieve a high utility in practice.We plan to extend our work in a number of ways in the future. First, we would like to consider settings with mul-tiple interdependent tasks. These often occur in practical application areas where consumers need to complete complexworkflows. To address these settings, we will extend our branch-and-bound algorithm and also consider more expressiveconsumer preferences, such as utility functions that depend on the workflow completion time.Second, we will deal with multiple consumers that compete for the services of the providers, as this setting happens of-ten in practical service-oriented application settings. For this, we plan to look into the application of two-sided markets andextend existing work in this area to our redundant procurement setting. In this context, we will be particularly interested inthe impact increased competition among consumers will have on the use of redundancy. Clearly, when services are scarce,there will be less scope for redundant procurement, but particularly urgent or valuable tasks may still be allocated multipleservices. Depending on the aims of the system designer, it will be interesting to also investigate alternative social welfarefunctions in this setting, such as the Nash product or egalitarian social welfare.Finally, we intend to investigate more dynamic settings where both tasks and services arrive over time. This again is acommon feature of realistic settings, where providers enter or leave the system and new unexpected tasks may suddenlyappear. In such scenarios, agents may strategise not only about reporting their service capabilities, but also about whento make these reports. As such, we will consider applying and extending techniques from the field of online mechanismdesign [41].AcknowledgementsWe thank the reviewers of this paper for their detailed comments. This paper is a significantly extended version ofprevious conference publications [50] and [16]. The research was undertaken as part of the ALADDIN (Autonomous Learn-ing Agents for Decentralised Data and Information Systems) project, which is jointly funded by BAE Systems and EPSRC(EP/C548051/1), and as part of the EPSRC funded project on Market-Based Control (GR/T10664/01).Appendix A. Optimal procurement as a restless bandit problemThe optimal procurement problem can be modelled as a restless bandit problem. Given ci , F i(t) for each provider i,and deadline D, define state space S = {S j,k | j, k (cid:3) 0, j + k (cid:2) D} ∪ {S V , S A}. For each provider i, define bandit B i withstarting state S0,0. Define the activation probability function as follows. If the bandit is currently in state S 0, t with t (cid:2) Dwhen activated, then with probability 1.0 it transitions to state St,1. If the current state is S j,k such that j + k < D, then ittransitions to state S j,k+1 with probability 1.0. Otherwise, if the bandit is in state S j,k such that j + k = D then it transitionsto state S A , which is an absorbing state. The cost every time B i is activated is ci . The passive dynamics (i.e., when thebandit is not activated) are defined as follows. For any state S0,k such that k (cid:2) D, the transition to state S0,k+1 occurs withprobability 1.0, and if k = D then the transition to state S A occurs with probability 1.0 (where S A is again an absorbingstate). For any state S j,k with j > 0 and j + k (cid:2) D, the probability of transitioning to state S V is F i(k) while the probabilityof transitioning to S j,k+1 is 1 − F i(k). The probability of transitioning from state S V to state S A and from any state S j,ksuch that j + k = D to state S A is also 1.0. Finally, set the passive rewards for all states except S V to be zero, and set theS. Stein et al. / Artificial Intelligence 175 (2011) 2021–20602059reward of S V to be a perishable value V (i.e., once obtained, the value for the state changes to zero) [25]. This problem isdefined such that a bandit will only be activated at most once in the optimal schedule, and the optimal activation schedule(i.e., that maximises the average reward) is exactly the optimal procurement strategy.References[1] D.P. Anderson, J. Cobb, E. Korpela, M. Lebofsky, D. Werthimer, SETI@home: An experiment in public-resource computing, Communications of theACM 45 (11) (November 2002) 56–61.[2] M. Babaioff, M. Feldman, N. Nisan, Combinatorial agency, in: Proceedings of the 7th ACM Conference on Electronic Commerce (EC-2006), 2006, pp. 18–28.[3] J.C. Beck, N. Wilson, Proactive algorithms for job shop scheduling with probabilistic durations, Journal of Artificial Intelligence Research 28 (2007)183–232.[4] D. Bergemann, S. Morris, Ex-post implementation, Games and Economic Behavior 63 (2) (2008) 527–566.[5] R. Buyya, D. Abramson, S. Venugopal, The grid economy, Proceedings of the IEEE 93 (3) (2005) 698–714.[6] P. Chalasani, S. Jha, O. Shehory, K. Sycara, Query restart strategies for web agents, in: Proceedings of the Second International Conference on Au-tonomous Agents (AGENTS ’98), Minneapolis, USA, 1998, pp. 124–131.[7] P. Cheeseman, B. Kanefsky, W.M. Taylor, Where the really hard problems are, in: Proceedings of the Twelfth International Joint Conference on (IJCAI-91),Sydney, Australia, 1991, pp. 331–337.[8] D. Coit, A. Smith, Reliability optimization of series-parallel systems using a genetic algorithm, IEEE Transactions on Reliability 45 (2) (1996) 254–260.[9] J. Dean, S. Ghemawat, MapReduce: Simplified data processing on large clusters, Communications of the ACM 51 (1) (2008) 107–113.[10] A. Erradi, P. Maheshwari, V. Tosic, Recovery policies for enhancing web services reliability, in: Proceedings of the IEEE Int. Conf. on Web Services(ICWS’06), Chicago, USA, 2006, pp. 189–196.[11] L. Finkelstein, S. Markovitch, E. Rivlin, Optimal schedules for parallelizing anytime algorithms: The case of independent processes, in: Proceedings ofthe Eighteenth Conference on Artificial Intelligence (AAAI-02), Edmonton, Canada, 2002, pp. 719–724.[12] I. Foster, C. Kesselman, S. Tuecke, The anatomy of the grid: Enabling scalable virtual organizations, International Journal of High Performance ComputingApplications 15 (3) (August 2001) 200–222.[13] T. Friese, J.P. Müller, B. Freisleben, Self-healing execution of business processes based on a peer-to-peer service architecture, in: Proceedings of theEighteenth International Conference on Architecture of Computing Systems (ARCS ’05), System Aspects in Organic and Pervasive Computing, Innsbruck,Austria, in: LNCS, vol. 3432, Springer, 2005, pp. 108–123.[14] S. Garg, S. Venugopal, R. Buyya, A meta-scheduler with auction based resource allocation for global grids, in: Proceedings of the 14th IEEE InternationalConference on Parallel and Distributed Systems (ICPADS ’08), Melbourne, Australia, 2008, pp. 187–194.[15] E.H. Gerding, K. Larson, A. Rogers, N.R. Jennings, Mechanism design for task procurement with flexible quality of service, in: Proceedings of the 2009International Workshop on Service-Oriented Computing: Agents, Semantics, and Engineering (SOCASE 2009), Budapest, Hungary, in: LNCS, vol. 5907,Springer, 2009, pp. 12–23.[16] E.H. Gerding, S. Stein, K. Larson, A. Rogers, N.R. Jennings, Scalable mechanism design for the procurement of services with uncertain durations, in:Proceedings of the 9th International Conference on Autonomous Agents and Multi-Agent Systems (AAMAS ’10), Toronto, Canada, 2010, pp. 649–656.[17] J.C. Gittins, Bandit processes and dynamic allocation indices, Journal of the Royal Statistical Society. Series B (Methodological) 41 (2) (1979) 148–177.[18] T. Glatard, J. Montagnat, X. Pennec, Optimizing jobs timeouts on clusters and production grids, in: Proceedings of the Seventh IEEE InternationalSymposium on Cluster Computing and the Grid (CCGrid’07), Rio de Janeiro, Brazil, 2007, pp. 100–107.[19] C.P. Gomes, B. Selman, Algorithm portfolios, Artificial Intelligence 126 (2001) 43–62.[20] C.-W. Hang, M. Singh, From quality to utility: Adaptive service selection framework, in: Proceedings of the 8th International Conference on ServiceOriented Computing (ICSOC), San Francisco, USA, 2010.[21] B. Hayes, Cloud computing, Communications of the ACM 51 (7) (2008) 9–11.[22] B.A. Huberman, R.M. Lukose, T. Hogg, An economics approach to hard computational problems, Science 275 (5296) (1997) 51–54.[23] M.N. Huhns, V.T. Holderfield, R.L.Z. Gutierrez, Robust software via agent-based redundancy, in: Proceedings of the Second International Joint Conferenceon Autonomous Agents and Multiagent Systems (AAMAS ’03), Melbourne, Australia, 2003, pp. 1018–1019.[24] D.B. Ingham, F. Panzieri, S.K. Shrivastava, Advances in distributed systems, in: Advanced Distributed Computing: From Algorithms to Systems, in: LNCS,vol. 1752, Springer, Germany, 1999, pp. 277–294 (Ch. Constructing dependable Web services).[25] P. Jacko, J. Niño-Mora, Time-constrained restless bandits and the knapsack problem for perishable items, Electronic Notes in Discrete Mathematics 28(2007) 145–152.[26] P. Jehiel, B. Moldovanu, Efficient design with interdependent valuations, Econometrica 69 (5) (2001) 1237–1259.[27] H. Kautz, E. Horvit, Y. Ruan, C.P. Gomes, B. Selman, Dynamic restart policies, in: Proceedings of the Eighteenth National Conference on ArtificialIntelligence (AAAI 02), Edmonton, Canada, 2002, pp. 674–681.[28] V. Krishna, Auction Theory, Academic Press, USA, 2002.[29] R. Lavi, A. Mu’alem, N. Nisan, Two simplified proofs for Roberts’ theorem, Social Choice and Welfare 32 (2009) 407–423.[30] K. Leyton-Brown, E. Nudelman, Y. Shoham, Empirical hardness models: Methodology and a case study on combinatorial auctions, Journal of theACM 56 (4) (2009) 1–52.[31] L. Li, M.L. Littman, Lazy approximation for solving continuous finite-horizon MDPs, in: Proceedings of the Twentieth National Conference on ArtificialIntelligence (AAAI-05), Pittsburgh, USA, 2005, pp. 1175–1180.[32] R.M. Lukose, B.A. Huberman, A methodology for managing risk in electronic transactions over the Internet, Netnomics 2 (1) (2000) 25–36.[33] J. Marecki, M. Tambe, Towards faster planning with continuous resources in stochastic domains, in: Proceedings of the Twenty-Third Conference onArtificial Intelligence (AAAI-08), Chicago, USA, 2008, pp. 1049–1055.[34] A. Mas-Colell, M. Whinston, J. Green, Microeconomic Theory, Oxford University Press, UK, 1995.[35] Y. Narahari, R. Narayanam, D. Garg, H. Prakash, Mechanism design for resource procurement in grid computing, in: L. Jain, X. Wu (Eds.), Game TheoreticProblems in Network Economics and Mechanism Design Solutions. Advanced Information and Knowledge Processing, Springer, Germany, 2009, pp. 1–28.[36] N. Nisan, A. Ronen, Computationally feasible VCG mechanisms, Journal of Artificial Intelligence Research 29 (2007) 19–47.[37] Y. Oh, S.H. Son, Scheduling real-time tasks for dependability, The Journal of the Operational Research Society 48 (6) (1997) 629–639.[38] T. Oinn, M. Greenwood, M. Addis, M.N. Alpdemir, J. Ferris, K. Glover, C. Goble, A. Goderis, D. Hull, D. Marvin, P. Li, P. Lord, M.R. Pocock, M. Senger,R. Stevens, A. Wipat, C. Wroe, Taverna: lessons in creating a workflow environment for the life sciences, Concurrency and Computation: Practice andExperience 18 (10) (2005) 1067–1100.[39] C.H. Papadimitriou, J.N. Tsitsiklis, The complexity of optimal queuing network control, Mathematics of Operations Research 24 (2) (1999) 293–305.[40] A. Papakonstantinou, A. Rogers, E. Gerding, N. Jennings, Mechanism design for the truthful elicitation of costly probabilistic estimates in distributedinformation systems, Artificial Intelligence 175 (2) (February 2011) 648–672, http://eprints.ecs.soton.ac.uk/21316/.2060S. Stein et al. / Artificial Intelligence 175 (2011) 2021–2060[41] D.C. Parkes, Online mechanisms, in: N. Nisan, T. Roughgarden, E. Tardos, V. Vazirani (Eds.), Algorithmic Game Theory, Cambridge University Press, UK,2007, pp. 411–439 (Ch. 16).[42] M. Pinedo, Scheduling: Theory, Algorithms, and Systems, 2nd ed., Prentice Hall, USA, 2001.[43] R. Porter, A. Ronen, Y. Shoham, M. Tennenholtz, Fault tolerant mechanism design, Artificial Intelligence 172 (15) (2008) 1783–1799.[44] X. Qin, H. Jiang, D.R. Swanson, An efficient fault-tolerant scheduling algorithm for real-time tasks with precedence constraints in heterogeneous sys-tems, in: Proceedings of the International Conference on Parallel Processing (ICPP’02), Vancouver, Canada, 2002, pp. 360–368.[45] S.D. Ramchurn, D. Huynh, N.R. Jennings, Trust in multiagent systems, Knowledge Engineering Review 19 (1) (2004) 1–25.[46] S.D. Ramchurn, C. Mezzetti, A. Giovannucci, J.A. Rodriguez-Aguilar, R.K. Dash, N.R. Jennings, Trust-based mechanisms for robust and efficient taskallocation in the presence of execution uncertainty, Journal of Artificial Intelligence Research 35 (2009) 119–159.[47] D. Shahaf, E. Horvitz, Generalized task markets for human and machine computation, in: Proceedings of the Twenty-Fourth, AAAI Conference onArtificial Intelligence (AAAI-10), 2010, pp. 986–993.[48] M.P. Singh, M.N. Huhns, Service-Oriented Computing: Semantics, Processes, Agents, John Wiley & Sons, Inc., USA, 2005.[49] S. Stein, E.H. Gerding, N.R. Jennings, Optimal task migration in service-oriented systems: Algorithms and mechanisms, in: Proceedings of the 19thEuropean Conference on Artificial Intelligence (ECAI-10), Lisbon, Portugal, 2010, pp. 73–78.[50] S. Stein, E.H. Gerding, A. Rogers, K. Larson, N.R. Jennings, Flexible procurement of services with uncertain durations using redundancy, in: Proceedingsof the Twenty-First International Joint Conference on Artificial Intelligence (IJCAI-09), Pasadena, USA, 2009, pp. 292–298.[51] S. Stein, N.R. Jennings, T.R. Payne, Flexible service provisioning with advance agreements, in: Proceedings of the Seventh International Conference onAutonomous Agents and Multi-Agent Systems (AAMAS-08), Estoril, Portugal, 2008, pp. 249–256.[52] S. Stein, T.R. Payne, N.R. Jennings, Flexible selection of heterogeneous and unreliable services in large-scale grids, Philosophical Transactions of theRoyal Society A: Mathematical, Physical & Engineering Sciences 367 (1897) (2009) 2483–2494.[53] W.T.L. Teacy, J. Patel, N.R. Jennings, M. Luck, TRAVOS: Trust and reputation in the context of inaccurate information sources, Journal of AutonomousAgents and Multi-Agent Systems 12 (2) (February 2006) 183–198.[54] F.A. Tillman, C.L. Hwang, W. Kuo, Optimization techniques for system reliability with redundancy: A review, IEEE Transactions on Reliability R-26 (1977)148–155.[55] K. Trivedi, Probability and Statistics with Reliability, Queuing, and Computer Science Applications, 2nd ed., John Wiley & Sons, Inc., USA, 2001.[56] M.L. Weitzman, Optimal search for the best alternative, Econometrica 47 (3) (1979) 641–654.[57] P. Whittle, Restless bandits, Journal of Applied Probability 25A (1988) 301–313.[58] S.J. Witwicki, E.H. Durfee, Commitment-based service coordination, International Journal of Agent-Oriented Software Engineering 3 (1) (2009) 59–87.[59] Y. Zhang, E. Manisterski, S. Kraus, V. Subrahmanian, D. Peleg, Computing the fault tolerance of multi-agent deployment, Artificial Intelligence 173 (3–4)(2009) 437–465.