Artificial Intelligence 187–188 (2012) 156–192Contents lists available at SciVerse ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintMagic Sets for disjunctive Datalog programs ✩Mario Alviano, Wolfgang Faber∗, Gianluigi Greco, Nicola LeoneDepartment of Mathematics, University of Calabria, 87036 Rende, Italya r t i c l ei n f oa b s t r a c tArticle history:Received 13 January 2011Received in revised form 20 April 2012Accepted 24 April 2012Available online 26 April 2012Keywords:Logic programmingStable modelsMagic SetsAnswer set programmingData integrationIn this paper, a new technique for the optimization of (partially) bound queries overdisjunctive Datalog programs with stratified negation is presented. The technique exploitsthe propagation of query bindings and extends the Magic Set optimization technique(originally defined for non-disjunctive programs).An important feature of disjunctive Datalog programs is non-monotonicity, which callsfor non-deterministic implementations, such as backtracking search. A distinguishingcharacteristic of the new method is that the optimization can be exploited also duringthe non-deterministic phase. In particular, after some assumptions have been made duringthe computation, parts of the program may become irrelevant to a query under theseassumptions. This allows for dynamic pruning of the search space. In contrast, the effectof the previously defined Magic Set methods for disjunctive Datalog is limited to thedeterministic portion of the process. In this way, the potential performance gain by usingthe proposed method can be exponential, as could be observed empirically.The correctness of the method is established and proved in a formal way thanks to astrong relationship between Magic Sets and unfounded sets that has not been studied inthe literature before. This knowledge allows for extending the method and the correctnessproof also to programs with stratified negation in a natural way.The proposed method has been implemented in the DLV system and various experimentson synthetic as well as on real-world data have been conducted. The experimental resultson synthetic data confirm the utility of Magic Sets for disjunctive Datalog, and theyhighlight the computational gain that may be obtained by the new method with respectto the previously proposed Magic Set method for disjunctive Datalog programs. Furtherexperiments on data taken from a real-life application show the benefits of the MagicSet method within an application scenario that has received considerable attention inrecent years, the problem of answering user queries over possibly inconsistent databasesoriginating from integration of autonomous sources of information.© 2012 Elsevier B.V. All rights reserved.1. IntroductionDisjunctive Datalog is a language that has been proposed for modeling incomplete data [48]. Together with a lightversion of negation, in this paper stratified negation, this language can in fact express any query of the complexity class2 (i.e., NPNP) [22], under the stable model semantics. It turns out that disjunctive Datalog with stratified negation isΣ Pstrictly more expressive (unless the polynomial hierarchy collapses to its first level) than normal logic programming (i.e.,non-disjunctive Datalog with unstratified negation), as the latter can express “only” queries in NP. As shown in [22], the✩Preliminary portions of this paper appeared in the proceedings of the 20th International Conference on Logic Programming (ICLP’04).* Corresponding author.E-mail addresses: alviano@mat.unical.it (M. Alviano), faber@mat.unical.it (W. Faber), ggreco@mat.unical.it (G. Greco), leone@mat.unical.it (N. Leone).0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.http://dx.doi.org/10.1016/j.artint.2012.04.008M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192157high expressive power of disjunctive Datalog has also some positive practical implications in terms of modeling knowledge,since many problems in NP can be represented more simply and naturally in stratified disjunctive Datalog than in normallogic programming. For this reason, it is not surprising that disjunctive Datalog has found several real-world applications[42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels[46], or ClaspD [21]. As a matter of fact, these systems are continuously enhanced to support novel optimization strategies,enabling them to be effective over increasingly larger application domains. In this paper, we contribute to this developmentby providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the MagicSet method [6,9,63].The goal of the original Magic Set method (defined for non-disjunctive Datalog programs) is to exploit the presenceof constants in a query for restricting the possible search space by considering only a subset of a hypothetical programinstantiation that is sufficient to answer the query in question. In order to do this, a top–down computation for answeringthe query is simulated in an abstract way. This top–down simulation is then encoded by means of rules, defining new MagicSet predicates. The extensions of these predicates (sets of ground atoms) will contain the tuples that are calculated duringa top–down computation. These predicates are inserted into the original program rules and can then be used by bottom–upcomputations to narrow the computation to what is needed for answering the query.Extending these ideas to disjunctive Datalog faces a major challenge: While non-disjunctive Datalog programs are deter-ministic, which in terms of the stable model semantics means that any non-disjunctive Datalog program has exactly onestable model, disjunctive Datalog programs are non-deterministic in the sense that they may have multiple stable models.Of course, the main goal is still isolating a subset of a hypothetical program instantiation, upon which the considered querywill be evaluated in an equivalent way. There are two basic possibilities how this non-determinism can be dealt with inthe context of Magic Sets: The first is to consider static Magic Sets, in the sense that the definition of the Magic Sets is stilldeterministic, and therefore the extension of the Magic Set predicates is equal in each stable model. This static behavior isautomatic for Magic Sets of non-disjunctive Datalog programs. The second possibility is to allow dynamic Magic Sets, whichalso introduce non-deterministic definitions of Magic Sets. This means that the extension of the Magic Set predicates maydiffer in various stable models, and thus can be viewed as being specialized for each stable model.While the nature of dynamic Magic Sets intuitively seems to be more fitting for disjunctive Datalog than static MagicSets, considering the architecture of modern reasoning systems for disjunctive Datalog substantiates this intuition: Thesesystems work in two phases, which may be considered as a deterministic (grounding) and a non-deterministic (modelsearch) part. The interface between these two is by means of a ground program, which is produced by the deterministicphase. Static Magic Sets will almost exclusively have an impact on the grounding phase, while dynamic Magic Sets alsohave the possibility to influence the model search phase. In particular, some assumptions made during the model searchmay render parts of the program irrelevant to the query, which may be captured by dynamic Magic Sets, but not (or onlyunder very specific circumstances) by static Magic Sets.In the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set methodfor disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work. The basic ideaof SMS is that bindings need to be propagated not only from rule heads to rule bodies (as in traditional Magic Sets), but alsofrom one head predicate to other head predicates. In addition to producing definitions for the predicates defining Magic Sets,the method also introduces additional auxiliary predicates called collecting predicates. These collecting predicates howeverhave a peculiar effect: Their use keeps the Magic Sets static. Indeed, both magic and collecting predicates are guaranteedto have deterministic definitions, which implies that disjunctive Datalog systems can exploit the Magic Sets only during thegrounding phase. Most systems will actually produce a ground program which does contain neither magic nor collectingpredicates.In this article, we propose a dynamic Magic Set method for disjunctive Datalog with stratified negation under the stablemodel semantics, provide an implementation of it in the system dlv, and report on an extensive experimental evaluation.In more detail, the contributions are:(cid:2)(cid:2)(cid:2)(cid:2)We present a dynamic Magic Set method for disjunctive Datalog programs with stratified negation, referred to asDynamic Magic Sets (DMS). Different from the previously proposed static method SMS, existing systems can exploitthe information provided by the Magic Sets also during their non-deterministic model search phase. This featureallows for potentially exponential performance gains with respect to the previously proposed static method.We formally establish the correctness of DMS. In particular, we prove that the program obtained by the transfor-mation DMS is query-equivalent to the original program. This result holds for both brave and cautious reasoning.We highlight a strong relationship between Magic Sets and unfounded sets, which characterize stable models. Wecan show that the atoms which are relevant for answering a query are either true or form an unfounded set,which eventually allows us to prove the query-equivalence results.Our results hold for a disjunctive Datalog language with stratified negation under the stable model semantics. Inthe literature, several works deal with non-disjunctive Datalog with stratified negation under the well-founded orthe perfect model semantics, which are special cases of our language. For the static method SMS, an extension todisjunctive Datalog with stratified negation has previously only been sketched in [33].158(cid:2)(cid:2)(cid:2)M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192We have implemented a DMS optimization module inside the DLV system [43]. In this way, we could exploitthe internal data-structures of the DLV system and embed DMS in the core of DLV. As a result, the technique iscompletely transparent to the end user. The system is available at http://www.dlvsystem.com/magic/.We have conducted extensive experiments on synthetic domains that highlight the potential of DMS. We havecompared the performance of the DLV system without Magic Set optimization with SMS and with DMS. Theresults show that in many cases the Magic Set methods yield a significant performance benefit. Moreover, we canshow that the dynamic method DMS can yield drastically better performance than the static SMS. Importantly, incases in which DMS cannot be beneficial (if all or most of the instantiated program is relevant for answering aquery), the overhead incurred is very light.We also report on experiments which evaluate the impact of DMS on an industrial application scenario on real-world data. The application involves data integration and builds on several results in the literature (for example[5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this contextstemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.By leveraging these results, DMS can be viewed as a query optimization method for inconsistent databases or fordata integration systems. The results show that DMS can yield significant performance gains for queries of thisapplication.Organization. The main body of this article is organized as follows. In Section 2, preliminaries on disjunctive Datalog andon the Magic Set method for non-disjunctive Datalog queries are introduced. Subsequently, in Section 3 the extension DMSfor the case of disjunctive Datalog programs is presented, and we show its correctness. In Section 4 we discuss the imple-mentation and integration of the Magic Set method within the DLV system. Experimental results on synthetic benchmarksare reported in Section 5, while the application to data integration and its experimental evaluation is discussed in Section 6.Finally, related work is discussed in Section 7, and in Section 8 we draw our conclusions.2. PreliminariesIn this section, (disjunctive) Datalog programs with (stratified) negation are briefly described, and the standard MagicSet method is presented together with the notion of sideways information passing strategy (SIPS) for Datalog rules.2.1. Disjunctive Datalog programs with stratified negationIn this paper, we adopt the standard Datalog name convention: Alphanumeric strings starting with a lowercase characterare predicate or constant symbols, while alphanumeric strings starting with an uppercase character are variable symbols;moreover, we allow the use of positive integer constant symbols. Each predicate symbol is associated with a non-negativeinteger, referred to as its arity. An atom p(¯t) is composed of a predicate symbol p and a list ¯t = t1, . . . , tk (k (cid:3) 0) of terms,each of which is either a constant or a variable. A literal is an atom p(¯t) or a negated atom not p(¯t); in the first case theliteral is positive, while in the second it is negative.A disjunctive Datalog rule with negation (short: Datalogrule) r is of the form∨,¬p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).∨,¬where p1(¯t1), . . . , pn(¯tn), q1(¯s1), . . . , qm(¯sm) are atoms and n (cid:3) 1, m (cid:3) j (cid:3) 0. The disjunction p1(¯t1) ∨ · · · ∨ pn(¯tn) is thehead of r, while the conjunction q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm) is the body of r. Moreover, H(r) denotes−(r) for denoting the sets ofthe set of head atoms, while B(r) denotes the set of body literals. We also use Batoms appearing in positive and negative body literals, respectively. If r is disjunction-free, that is n = 1, and negation-free,+(r) is empty in addition, then we say that r is a fact.that is BA disjunctive Datalog program P is a finite set of rules; if all the rules in it are disjunction- and negation-free, then P is a(standard) Datalog program.−(r) is empty, then we say that r is a Datalog rule; if B+(r) and BGiven a Datalogprogram P , a predicate belongs to the Intensional Database (IDB) if it is either in the head of a rulewith non-empty body, or in the head of a disjunctive rule; otherwise, it belongs to the Extensional Database (EDB). Theset of rules having IDB predicates in their heads is denoted by IDB(P), while EDB(P) denotes the remaining rules, thatis, EDB(P) = P \ IDB(P). For simplicity, we assume that predicates will always be of the same type (EDB or IDB) in anyprogram.The set of all constants appearing in a program P is the universe of P and is denoted by U P ,1 while the set of groundatoms constructable from predicates in P with constants in U P is the base of P , denoted by BP . We call an atom (rule, orprogram) ground if it does not contain any variables. A substitution ϑ is a function from variables to elements of U P . For anexpression S (atom, literal, rule), by Sϑ we denote the expression obtained from S by substituting all occurrences of eachvariable X in S with ϑ( X). A ground atom p(¯t) (resp. ground rule r g ) is an instance of an atom p(¯t(cid:4)) (resp. rule r) if there1 If P has no constants, an arbitrary constant is added to U P .M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192159(cid:4)) (resp. in r) to U P such that p(¯t) = p(¯t(cid:4))ϑ (resp. r g = rϑ ). Given a program P ,is a substitution ϑ from the variables in p(¯tGround(P) denotes the set of all possible instances of rules in P .Given an atom p(¯t) and a set of ground atoms A, by A|p(¯t) we denote the set of ground instances of p(¯t) belongingp(¯t) is the set of all ground atoms obtained by applying to p(¯t) all the possible substitutions fromto A. For example, BP |the variables in p(¯t) to U P , that is, the set of all the instances of p(¯t). Abusing notation, if B is a set of atoms, by A|B wedenote the union of all A|p(¯t), for each p(¯t) ∈ B.∨,¬∨,¬∨,¬∨,¬+(r). A Datalogprograms is safety. A DatalogA desirable property of Datalogrule r is safe if each variable appearing in r appearsin at least one atom of Bprogram is safe if all its rules are safe. Moreover, programs without recursionprograms. Without going into details, a predicate p in theover negated literals constitute an interesting class of Datalog+(r), and phead of a rule r depends on all the predicates q in the body of r; p depends on q positively if q appears in B−(r). A program has recursion over negation if a cycle of dependencies with atdepends on q negatively if q appears in Bleast one negative dependency exists. If a program has no recursion over negation, then the program is stratified (short:Datalog∨,¬s ). In this work only safe programs without recursion over negation are considered.An interpretation for a program P is a subset I of BP . A positive ground literal p(¯t) is true with respect to an interpre-tation I if p(¯t) ∈ I ; otherwise, it is false. A negative ground literal not p(¯t) is true with respect to I if and only if p(¯t) isfalse with respect to I , that is, if and only if p(¯t) /∈ I . The body of a ground rule r is true with respect to I if and only if−(r) ∩ I = ∅. An interpretation Iall the body literals of r are true with respect to I , that is, if and only if Bsatisfies a ground rule r ∈ Ground(P) if at least one atom in H(r) is true with respect to I whenever the body of r is trueprogram P if I satisfies all the rules in Ground(P). Sincewith respect to I . An interpretation I is a model of a Datalogan interpretation is a set of atoms, if I is an interpretation for a program P , and P (cid:4)is another program, then by I|BP(cid:4) wedenote the restriction of I to the base of P (cid:4)+(r) ⊆ I and B∨,¬.Given an interpretation I for a program P , the reduct of P with respect to I , denoted by Ground(P)I , is obtained by−(r g) ∩ I (cid:9)= ∅, and then by removing all the negative literals from thedeleting from Ground(P) all the rules r g with Bremaining rules.∨,¬∨,¬The semantics of a Datalogprogram P is given by the set SM(P) of stable models of P , where an interpretation Mis a stable model for P if and only if M is a subset-minimal model of Ground(P)M . It is well-known that there is exactly∨,¬s program P ,one stable model for any Datalog program, also in presence of stratified negation. However, for a Datalog|SM(P)| (cid:3) 1 holds (Datalogprograms, instead, can also have no stable model).Given a ground atom p(¯t) and a Datalogprogram P , p(¯t) is a cautious (or certain) consequence of P , denoted byP |(cid:10)c p(¯t), if p(¯t) ∈ M for each M ∈ SM(P); p(¯t) is a brave (or possible) consequence of P , denoted by P |(cid:10)b p(¯t), if p(¯t) ∈M for some M ∈ SM(P). Note that brave and cautious consequences coincide for Datalog programs, as these programs∨,¬s program P are also brave consequences ofhave a unique stable model. Moreover, cautious consequences of a DatalogP because |SM(P)| (cid:3) 1 holds in this case.Given a query Q = g(¯t)? (an atom),2 Ansc(Q, P) denotes the set of all substitutions ϑ for the variables of g(¯t) such thatP |(cid:10)c g(¯t)ϑ , while Ansb(Q, P) denotes the set of substitutions ϑ for the variables of g(¯t) such that P |(cid:10)b g(¯t)ϑ .Let P and P (cid:4)are brave-equivalent with respect to Q,, if Ansb(Q, P ∪ F ) = Ansb(Q, P (cid:4) ∪ F ) is guaranteed for each set of facts F defined over predicatesQ P (cid:4)denoted by P ≡bwhich are EDB predicates of P or P (cid:4)Q P (cid:4),if Ansc(Q, P ∪ F ) = Ansc(Q, P (cid:4) ∪ F ) is guaranteed for each set of facts F defined over predicates which are EDB predicatesof P or P (cid:4)are cautious-equivalent with respect to Q, denoted by P ≡cprograms and Q a query. Then P and P (cid:4); similarly, P and P (cid:4)be two Datalog∨,¬.∨,¬2.2. Bottom–up disjunctive Datalog computation∨,¬Many Datalogsystems implement a two-phase computation. The first phase, referred to as program instantiation orgrounding, is bottom–up. For an input program P , it produces a ground program which is equivalent to Ground(P), butsignificantly smaller. Most of the techniques used in this phase stem from bottom–up methods developed for classic anddeductive databases; see for example [1] or [28,43] for details. Essentially, predicate instances which are known to be trueor known to be false are identified and this knowledge is used for deriving further instances of this kind. Eventually, thetruth values obtained in this way are used to produce rule instances which are not satisfied already. It is important to notethat this phase behaves in a deterministic way with respect to stable models. No assumptions about truth or falsity of atomsare made, only definite knowledge is derived, which must hold in all stable models. For this reason, programs with multiplestable models cannot be solved by grounding.The second phase is often referred to as stable model search and takes care of the non-deterministic computation. Es-sentially, one undefined atom is selected and its truth or falsity is assumed. The assumption might imply truth or falsityof other undefined atoms. Hence, the process is repeated until either an inconsistency is derived or all atoms have beeninterpreted. In the latter case an additional check is performed to ensure stability of the model. Details on this process can2 Note that more complex queries can still be expressed using appropriate rules. We assume that each constant appearing in Q also appears in P ; ifthis is not the case, then we can add to P a fact p(¯t) such that p is a predicate not occurring in P and ¯t are the arguments of Q. Question marks will beusually omitted when referring to queries in the text.160M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192be found for example in [23]. Query answering is typically handled by storing all admissible answer substitutions as stablemodels are computed. For brave reasoning, each stable model can contribute substitutions to the set of answers. In thiscase the set of answers is initially empty. For cautious reasoning, instead, each stable model may eliminate some substitu-tions from the set of admissible answers. Therefore, in this case all possible substitutions for the input query are initiallycontained in the set of answers.2.3. Sideways information passing for Datalog rulesThe Magic Set method aims at simulate a top–down evaluation of a query Q, like for instance the one adopted by Prolog.According to this kind of evaluation, all the rules r such that p(¯t) ∈ H(r) and H(r)ϑ = {Qϑ (cid:4)} (for some substitution ϑ forall the variables of r and some substitution ϑ (cid:4)for all the variables of Q) are considered in a first step. Then the atoms+(r)ϑ are taken as subqueries (we recall that standard Datalog rules have empty negative body), and the procedurein Bis iterated. Note that, according to this process, if a (sub)query has some argument that is bound to a constant value, thisinformation is “passed” to the atoms in the body. Moreover, the body is considered to be processed in a certain sequence,and processing a body atom may bind some of its arguments for subsequently considered body atoms, thus “generating”and “passing” bindings within the body. Whenever a body atom is processed, each of its argument is therefore consideredto be either bound or free. We illustrate this mechanism by means of an example.Example 2.1. Let path(1, 5) be a query for a program having the following inference rules:r1: path(X, Y ) :− edge(X, Y ).r2: path(X, Y ) :− edge(X, Z ), path(Z , Y ).Since this is a Datalog program, brave and cautious consequences coincide. Moreover, let F1 = {edge(1, 3), edge(2, 4),edge(3, 5)} be the EDB of the program. A top–down evaluation scheme considers r1 and r2 with X and Y bound to 1and 5, respectively. In particular, when considering r1, the information about the binding of the two variables is passed toedge(X, Y), which is indeed the only query atom occurring in r1. Thus, the evaluation fails since edge(1, 5) does not occurin F1.When considering r2, instead, the binding information can be passed either to path(Z, Y) or to edge(X, Z). Supposethat atoms are evaluated according to their ordering in the rule (from left to right); then edge(X, Z) is considered beforepath(Z, Y). In particular, F1 contains the atom edge(1, 3), which leads us to map Z to 3. Eventually, this inferred bindinginformation might be propagated to the remaining body atom path(Z, Y), which hence becomes path(3, 5).The process has now to be repeated by looking for an answer to path(3, 5). Again, rule r1 can be considered, fromwhich we conclude that this query is true since edge(3, 5) occurs in F1. Thus, path(1, 5) holds as well due to r2.Note that in the example above we have two degrees of freedom in the specification of the top–down evaluation scheme.The first one concerns which ordering is used for processing the body atoms. While Prolog systems are usually required tofollow the ordering in which the program is written, Datalog has a purely declarative semantics which is independent ofthe body ordering, allowing for an arbitrary ordering to be adopted. The second degree of freedom is slightly more subtle,and concerns the selection of the terms to be considered bound to constants from previous evaluations. Indeed, while wehave considered the propagation of all the binding information that originates from previously processed body atoms, it isin general possible to restrict the top–down evaluation to partially propagate this information. For instance, one may desireto propagate only information generated from the evaluation of EDB predicates, or even just the information that is passedon via the head atom.The specific propagation strategy adopted in the top–down evaluation scheme is called sideways information passing strat-egy (SIPS), which is just a way of formalizing a partial ordering over the atoms of each rule together with the specificationof how the bindings originated and propagate [9,33]. To formalize this concept, in what follows, for each IDB atom p(¯t),we shall denote its associated binding information (originated in a certain step of the top–down evaluation) by means of astring α built over the letters b and f , denoting “bound” and “free”, respectively, for each argument of p(¯t).Definition 2.2 (SIPS for Datalog rules). A SIPS for a Datalog rule r with respect to a binding α for the atom p(¯t) ∈ H(r) is apair (≺αr , f αr ), where:is a strict partial order over the atoms in H(r) ∪ Bis a function assigning to each atom q(¯s) ∈ H(r) ∪ B(1) ≺αr(2) f αrwhen processing q(¯s).+(r), such that p(¯t) ≺α+(r) a subset of the variables in ¯s—intuitively, those made boundr q(¯s), for all atoms q(¯s) ∈ B+(r); and,Intuitively, for each atom q(¯s) occurring in r, the strict partial order ≺αbefore processing atom q(¯s). Eventually, an argument X of q(¯s) is bound to a constant if there exists an atom qthat q(cid:4))). Note that the head atom p(¯t) precedes all other atoms in ≺αr .r q(¯s) and X ∈ f α(cid:4)) ≺αr (q(cid:4)(¯s(cid:4)(¯sr specifies those atoms that have to be processed(cid:4)) such(cid:4)(¯sM. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192161Example 2.3. The SIPS we have adopted in Example 2.1 for r1 with respect to the binding bb (originating from the querypath(1, 5)) can be formalized as the pair (≺bb(path(X, Y)) = {X, Y}, andr1f bb(edge(X, Y)) = ∅. Instead, the SIPS we have adopted for r2 with respect to the binding bb can be formalized as ther1pair (≺bbpath(Z, Y), f bb(edge(X, Z)) = {Z}, andr2r2f bbr2, f bbr2(path(Z, Y)) = ∅.(path(X, Y)) = {X, Y}, f bbr2), where path(X, Y) ≺bbr1), where path(X, Y) ≺bbr2edge(X, Z) ≺bbr2edge(X, Y),, f bbr1f bbr1All the algorithms and techniques we shall develop in this paper are orthogonal with respect to the underlying SIPSesto be used in the top–down evaluation. Thus, in Section 2.4, we shall assume that Datalog programs are provided in inputtogether with some arbitrarily defined SIPS (≺αr ), for each rule r and for each possible adornment α for the head atomin H(r).r , f α2.4. Magic Sets for Datalog programsThe Magic Set method is a strategy for simulating the top–down evaluation of a query by modifying the original programby means of additional rules, which narrow the computation to what is relevant for answering the query. We next provide abrief and informal description of the Magic Set rewriting technique. The reader is referred to [63] for a detailed presentation.The method is structured in four main phases, which are informally illustrated below by means of Example 2.1.(1) Adornment. The key idea is to materialize the binding information for IDB predicates that would be propagated duringa top–down computation. In particular, the fact that an IDB predicate p(¯t) is associated with a binding information α (i.e.,a string over the letters b and f , one for each term in ¯t) is denoted by the atom obtained adorning the predicate symbolwith the binding at hand, that is, by pα(¯t). In what follows, the predicate pα is said to be an adorned predicate.First, adornments are created for query predicates so that an argument occurring in the query is adorned with the letterif it is a variable. For instance, the adorned version of the query atom path(1, 5)b if it is a constant, or with the letter fis pathbb(1, 5), which gives rise to the adorned predicate pathbb.Each adorned predicate is eventually used to propagate its information into the body of the rules defining it accordingto a SIPS, thereby simulating a top–down evaluation. In particular, assume that the binding α has to be propagated into arule r whose head is p(¯t). Thus, the associated SIPS (≺αr ) determines which variables will be bound in the evaluationof the various body atoms. Indeed, a variable X of an atom q(¯s) in r is bound if and only if eitherr , f α(1) X ∈ f α(2) X ∈ f αr (q(¯s)) with q(¯s) = p(¯t); or,r (b(¯z)) for an atom b(¯z) ∈ B+(r) such that b(¯z) ≺αr q(¯s) holds.Adorning a rule r with respect to an adorned predicate pα means propagating the binding information α, starting fromthe head predicate p(¯t) ∈ H(r), thereby creating a novel adorned rule where all the IDB predicates in r are substituted bythe adorned predicates originating from the binding according to (1) and (2).Example 2.4. Adorning the query path(1, 5) generates pathbb(1, 5). Then, propagating the binding information bb intothe rule r1, i.e., when adorning r1 with pathbb, produces the following adorned rule (recall here that adornments applyonly to IDB predicates, whereas edge is an EDB predicate):1: pathbb(X, Y) :− edge(X, Y).raInstead, when propagating bb into the rule r2 according to the SIPS (≺bbr2following adorned rule:, f bbr2) defined in Example 2.3 we obtain the2: pathbb(X, Y) :− edge(X, Z), pathbb(Z, Y).raWhile adorning rules, novel binding information in the form of yet unseen adorned predicates may be generated, whichshould be used for adorning other rules. In fact, the adornment step is repeated until all bindings have been processed,yielding the adorned program, which is the set of all adorned rules created during the computation. For instance, in the2 for no adorned predicate different from pathbb is gener-above example, the adorned program just consists of raated.1 and ra(2) Generation. In the second step of the Magic Set method, the adorned program is used to generate magic rules, whichare used to simulate the top–down evaluation scheme and to single out the atoms relevant for answer the input query.For an adorned atom pα(¯t), let magic(pα(¯t)) be its magic version defined as the atom magic_pα(¯tis obtainedfrom ¯t by eliminating all arguments corresponding to an flabel in α, and where magic_pα is a new predicate symbol (forsimplicity denoted by attaching the prefix “magic_” to the predicate symbol pα ). Intuitively, magic_pα(¯t(cid:4))ϑ (ϑ a substitution)is inferred by the rules of the rewritten program whenever a top–down evaluation of the original program would process asubquery of the form pα(¯tis obtained from ¯t by applying ϑ to all terms in ¯t(cid:4)(cid:4)), where ¯t(cid:4)), where ¯t(cid:4)(cid:4).(cid:4)(cid:4)162M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192Thus, if qhead, a magic rule ri (¯si) is an adorned atom (i.e., βi is not the empty string) in the body of an adorned rule ra having pα(¯t) inβi∗) is the union of {magic(pα(¯t))} andβii (¯si))} and (ii) B(ris generated such that (i) H(r∗the set of all the atoms qβ jj (¯s j) ∈ B+(r) such that q j(¯s j) ≺α∗) = {magic(qr qi(¯si).Example 2.5. In our running example, only one magic rule is generated,∗2: magic_pathbb(Z, Y) :− magic_pathbb(X, Y), edge(X, Z).rIn fact, the adorned rule ra1 does not produce any magic rule, since there is no adorned predicate in B+(ra1).(3) Modification. The adorned rules are subsequently modified by adding magic atoms to their bodies. These magic atomslimit the range of the head variables avoiding the inference of facts which cannot contribute to the derivation of the query.In particular, each adorned rule ra, whose head atom is pα(¯t), is modified by adding the atom magic(pα(¯t)) to its body. Theresulting rules are called modified rules.Example 2.6. In our running example, the following modified rules are generated:(cid:4)1: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Y).(cid:4)2: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Z), pathbb(Z, Y).rr(4) Processing the Query. Finally, given the adorned predicate gα obtained when adorning a query g(¯t), (1) a magic seedmagic(gα(¯t)) (a fact) and (2) a rule g(¯t) :− gα(¯t) are produced. In our example, magic_pathbb(1, 5) and path(X, Y) :−pathbb(X, Y) are generated.The complete rewritten program according to the Magic Set method consists of the magic, modified, and query rules, it is well-known(together with the original EDB). Given a Datalog program P , a query Q, and the rewritten program P (cid:4)that P and P (cid:4)are equivalent with respect to Q, i.e., P ≡band P ≡chold [63].Q P (cid:4)Q P (cid:4)Example 2.7. The complete rewriting of our running example is as follows:3magic_pathbb(1, 5).path(X, Y) :− pathbb(X, Y).∗2: magic_pathbb(Z, Y) :− magic_pathbb(X, Y), edge(X, Z).(cid:4)1: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Y).(cid:4)2: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Z), pathbb(Z, Y).rrrIn this rewriting, magic_pathbb(X, Y) represents a potential sub-path of the paths from 1 to 5. Therefore, when answeringthe query, only these sub-paths will be actually considered in the bottom–up computation. One can check that this rewritingis in fact equivalent to the original program with respect to the query path(1, 5).3. Magic Set method for Datalog∨,¬s programsIn this section we present the Dynamic Magic Set algorithm (DMS) for the optimization of disjunctive programs withstratified negation. Before discussing the details of the algorithm, we informally present the main ideas that have beenexploited for enabling the Magic Set method to work on disjunctive programs (without negation).3.1. Overview of binding propagation in Datalog∨programsAs first observed in [33], while in non-disjunctive programs bindings are propagated only head-to-body, a Magic Settransformation for disjunctive programs has to propagate bindings also head-to-head in order to preserve soundness.Roughly, suppose that a predicate p is relevant for the query, and a disjunctive rule r contains p( X) in the head. Then,besides propagating the binding from p( X) to the body of r (as in the non-disjunctive case), the binding must also bepropagated from p( X) to the other head atoms of r. The reason is that any atom which is true in a stable model needs asupporting rule, which is a rule with a true body and in which the atom in question is the only true head atom. Therefore,r can yield support to the truth of p( X) only if all other head atoms are false, which is due to the implicit minimalitycriterion in the semantics.3 The Magic Set rewriting of a program P affects only IDB(P), so we usually omit EDB(P) in examples.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192163∨,¬s program P , and a query Q = g(¯t)?Algorithm DMS(Q, P )Input: A DatalogOutput: The rewritten program DMS(Q, P);var: S, D: set of adorned predicates; modifiedRulesQ,P , magicRulesQ,P : set of rules;beginpα := an element of S; remove pα from S; add pα to D;for each rule r ∈ P and for each atom p(¯t) ∈ H(r) do1. S := ∅; D := ∅; modifiedRulesQ,P := ∅; magicRulesQ,P := {BuildQuerySeed(Q, S)};2. while S (cid:9)= ∅ do3.4.5.6.7.8.end for9. end while10. DMS(Q, P) := magicRulesQ,P ∪ modifiedRulesQ,P ∪ EDB(P);11. return DMS(Q, P);ra := Adorn(r, pα (¯t), S, D);magicRulesQ,P := magicRulesQ,P ∪ Generate(r, pα (¯t), ra);modifiedRulesQ,P := modifiedRulesQ,P ∪ {Modify(r, ra)};end.Fig. 1. Dynamic Magic Set algorithm (DMS) for Datalog∨,¬s programs.∨Consider, for instance, a Datalogprogram P consisting of the rule p(X) ∨ q(Y) :− a(X, Y), b(X), and the query p(1).Even though the query propagates the binding for the predicate p, in order to correctly answer the query we also needto evaluate the truth value of q(Y), which indirectly receives the binding through the body predicate a(X, Y). For instance,suppose that the program contains the facts a(1, 2) and b(1); then the atom q(2) is relevant for the query p(1) (i.e., itshould belong to the Magic Set of the query), since the truth of q(2) would invalidate the derivation of p(1) from the aboverule, due to the minimality of the semantics. It follows that, while propagating the binding, the head atoms of disjunctiverules must be all adorned as well.However, the adornment of the head of one disjunctive rule r may give rise to multiple rules, having different adorn-ments for the head predicates. This process can be somehow seen as “splitting” r into multiple rules. While this is not aproblem in the non-disjunctive case, the semantics of a disjunctive program may be affected. Consider, for instance, the pro-gram consisting of the rule p(X, Y) ∨ q(Y, X) :− a(X, Y), in which p and q are mutually exclusive (due to minimality) sincethey do not appear in any other rule head. Assuming the adornments pbf and qbf to be propagated, we might obtain ruleswhose heads have the form pbf(X, Y) ∨ qfb(Y, X) (derived while propagating pbf) and pfb(X, Y) ∨ qbf(Y, X) (derived whilepropagating qbf). These rules could support two atoms pbf(m, n) and qbf(n, m), while in the original program p(m, n) andp(n, m) could not hold simultaneously (due to semantic minimality), thus changing the original semantics.The method proposed in [33] circumvents this problem by using some auxiliary predicates that collect all facts comingfrom the different adornments. For instance, in the above example, two rules of the form collect_p(X, Y) :− pfb(X, Y)and collect_p(X, Y) :− pbf(X, Y) are added for the predicate p. The main deficiency of this approach is that collectingpredicates will store a sizable superset of all the atoms relevant to answer the given query.An important observation is that these collecting predicates are defined in a deterministic way. Since these predicatesare used for restricting the computation in [33], a consequence is that assumptions during the computation cannot beexploited for determining the relevant part of the program. In terms of bottom–up systems, this implies that the optimiza-tion affects only the grounding portion of the solver. Intuitively, it would be beneficial to also have a form of conditionalrelevance, exploiting also relevance for assumptions. In fact, in Section 5, we provide experimental evidence for this intu-ition.In the following, we propose a novel Magic Set method that guarantees query equivalence and also allows for theexploitation of conditional or dynamic relevance, overcoming a major drawback of SMS.3.2. DMS algorithmOur proposal to enhance the Magic Set method for disjunctive Datalog programs has two crucial features compared tothe one of [33]:(1) First, the semantics of the program is preserved by stripping off the adornments from non-magic predicates in modifiedrules, and not by introducing collecting predicates that can introduce overhead in the grounding process, as discussedin Section 3.1.(2) Second, the proposed Magic Set technique is not just a way to cut irrelevant rules from the ground program; in fact,it allows for dynamic determination of relevance, thus optimizing also the non-deterministic computation by disablingparts of the programs which are not relevant in any extension of the current computation state.The algorithm DMS implementing these strategies is reported in Fig. 1 as pseudo-code. We assume that all variablesare passed to functions by reference, in particular the variable S is modified inside BuildQuerySeed and Adorn. Its input164M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192Function BuildQuerySeed(Q, S)Input: Q: query; S: set of adorned predicates;Output: The query seed (a magic atom);var: α: adornment string;begin1. Let p(¯t) be the atom in Q.2. α := (cid:6);3. for each argument t in ¯t do4.5. end for6. add pα to S;7. return magic(pα (¯t));if t is a constant then α := αb; else α := α f ; end ifend.Fig. 2. BuildQuerySeed function.∨,¬s program4 P and a query Q. The algorithm uses two sets, S and D, to store adorned predicates to beis a Datalogpropagated and already processed, respectively. After all the adorned predicates have been processed, the method outputs arewritten program DMS(Q, P) consisting of a set of modified and magic rules, stored by means of the sets modifiedRulesQ,Pand magicRulesQ,P , respectively (together with the original EDB). The main steps of the algorithm are illustrated by meansof the following running example.Example 3.1 (Strategic Companies [15]). Let C = {c1, . . . , cm} be a collection of companies producing some goods in a set G,(cid:4) ⊆ C is asuch that each company ci ∈ C is controlled by a set of other companies O i ⊆ C . A subset of the companies Cproduce all the goods instrategic set if it is a minimal set of companies satisfying the following conditions: Companies in CG; and O i ⊆ C, for each i = 1, . . . , m.implies ci ∈ C(cid:4)(cid:4)(cid:4)We assume that each product is produced by at most two companies and that each company is controlled by atmost three companies. It is known that the problem retains its hardness (for the second level of the polynomial hierar-chy; see [15]) under these restrictions. We assume that production of goods is represented by an EDB containing a factproduced_by(p, c1, c2) for each product p produced by companies c1 and c2, and that the control is represented by factscontrolled_by(c, c1, c2, c3) for each company c controlled by companies c1, c2, and c3.5 This problem can be modeledvia the following disjunctive program Psc:r3: sc(C1) ∨ sc(C2) :− produced_by(P, C1, C2).r4: sc(C) :− controlled_by(C, C1, C2, C3), sc(C1), sc(C2), sc(C3).Moreover, given a company c ∈ C , we consider a query Qsc = sc(c) asking whether c belongs to some strategic set of C .The computation starts in step 1 by initializing S, D, and modifiedRulesQ,P to the empty set. Then, the function Build-QuerySeed(Q, S) is used for storing in magicRulesQ,P the magic seed, and inserting in the set S the adorned predicateof Q. Note that we do not generate any query rules because standard atoms in the transformed program will not containadornments. Details of BuildQuerySeed(Q, S) are reported in Fig. 2.Example 3.2. Given the query Qsc = sc(c) and the program Psc,magic_scb(c) and inserts scb in S.function BuildQuerySeed(Qsc, S) creates the factThe core of the algorithm (steps 3–8) is repeated until the set S is empty, i.e., until there is no further adorned predicateto be propagated. In particular, an adorned predicate pα is moved from S to D in step 3, and its binding is propagated ineach (disjunctive) rule r ∈ P of the formr:p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).(with n (cid:3) 0) having an atom p(¯t) in the head (note that the rule r is processed a number of times that equals the numberof head atoms with predicate p; steps 4–8).(1) Adornment. Step 5 in Fig. 1 implements the adornment of the rule. Different from the case of non-disjunctive positiveprograms, the binding of the predicate pα needs to be also propagated to the atoms p1(¯t1), . . . , pn(¯tn) in the head. Therefore,binding propagation has to be extended to the head atoms different from p(¯t), which are therefore adorned according to4 Note that the algorithm can be used for non-disjunctive and/or positive programs as a special case.5 If a product is produced by only one company, c2 = c1, and similarly for companies controlled by fewer than three companies.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192165Function Adorn(r, pα (¯t), S, D)Input: r: rule; pα (¯t): adorned atom; S, D: set of adorned predicates;Output: an adorned rule;var: ra : adorned rule; αi : adornment string;begin) be the SIPS associated with r and pα (¯t)., fpα (¯t)rLet (≺pα (¯t)rra := r;for each IDB atom pi (¯ti ) in H(r) ∪ Bαi := (cid:6);for each argument t in ¯t doif t is a constant then+(r) ∪ B−(r) doαi := αib;elseArgument t is a variable. Let X be this variable.if X ∈ f(p(¯t)) or there is q(¯s) in Bq(¯s) ≺pα (¯t)pα (¯t)r+(r) such thatpi (¯ti ) and X ∈ frαi := αib;elseαi := αi f ;end ifpα (¯t)r(q(¯s)) thenend ifend forsubstitute pi (¯ti ) in ra with pαiif set D does not contain piαii (¯ti );then add pαiito S; end if1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20. end for21.end.return ra ;Fig. 3. Adorn function.a SIPS specifically conceived for disjunctive programs. Notation gets slightly more involved here: Since in non-disjunctiverules there is a single head atom, it was sufficient to specify an order and a function for each of its adornments (omittingthe head atom in the notation). With disjunctive rules, an order and a function need to be specified for each adorned headatom, so it is no longer sufficient to include only the adornment in the notation, but we rather include the full adornedatom.Definition 3.3 (SIPS for Datalogis a pair (≺pα (¯t)), where:pα (¯t)r, fr∨,¬s rules). A SIPS for a Datalog∨,¬s rule r with respect to a binding α for an atom p(¯t) ∈ H(r)(1) ≺pα (¯t)ris a strict partial order over the atoms in H(r) ∪ B+(r) ∪ Bq(¯s), for all atoms q(¯s) ∈ H(r) ∪ B(a) p(¯t) ≺pα (¯t)(b) for each pair of atoms q(¯s) ∈ (H(r) \ {p(¯t)}) ∪ Br+(r) ∪ B−(r), such that:−(r) different from p(¯t);−(r) and b(¯z) ∈ H(r) ∪ B+(r) ∪ B−(r), q(¯s) ≺pα (¯t)rb(¯z) does not hold;and,(2) fpα (¯t)rmade bound when processing q(¯s).is a function assigning to each atom q(¯s) ∈ H(r) ∪ B+(r) ∪ B−(r) a subset of the variables in ¯s—intuitively, thoseAs for Datalog rules, for each atom q(¯s) occurring in r, the strict partial order ≺pα (¯t)specifies those atoms that have to(cid:4))(cid:4)(¯sbe processed before processing atom q(¯s), and an argument X of q(¯s) is bound to a constant if there exists an atom q(cid:4))). The difference with respect to SIPSes for Datalog rules is(cid:4)(¯soccurring in r such that qprecisely in the dependency from p(¯t) in addition to α, and in condition (1.b) stating that head atoms different from p(¯t)and negative body literals cannot provide bindings to variables of other atoms.q(¯s) and X ∈ f(cid:4)) ≺pα (¯t)pα (¯t)r(cid:4)(¯s(qrrThe underlying idea is that a rule which is used to “prove” the truth of an atom in a top–down method will be a rulewhich supports that atom. This implies that all other head atoms in that rule must be false and that the body must be true.Head atoms and atoms occurring in the negative body cannot “create” bindings (that is, restrict the values of variables), butthese atoms are still relevant to the query, which leads to the restrictions in Definition 3.3.Note that this definition considers each rule in isolation and is therefore independent of the inter-rule structure of aprogram. In particular, it is not important for the SIPS definition whether a program is cyclic or contains head cycles.In the following, we shall assume that each Datalog∨,¬s program is provided in input together with some arbitrarily), the adornment can be carried outdefined SIPS for Datalogprecisely as we discussed for Datalog programs; in particular, we recall here that a variable X of an atom q(¯s) in r is boundif and only if either:). In fact, armed with (≺pα (¯t)∨,¬s rules (≺pα (¯t)pα (¯t)rpα (¯t)r, f, frr166M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192(1) X ∈ f(2) X ∈ fpα (¯t)rpα (¯t)r(q(¯s)) with q(¯s) = p(¯t); or,(b(¯z)) for an atom b(¯z) ∈ B+(r) such that b(¯z) ≺pα (¯t)rq(¯s) holds.The function Adorn(r, pα(¯t), S, D) produces an adorned disjunctive rule ra from an adorned atom pα(¯t) and a suit-able unadorned rule r (according to the bindings defined in the points (1) and (2) above), by inserting all newly adornedpredicates in S. Hence, in step 5 the rule ra is of the formra:pα(¯t) ∨ pα11 (¯t1) ∨ · · · ∨ pαnn (¯tn) :− qβ11 (¯s1), . . . , qβ jj (¯s j), not qβ j+1j+1 (¯s j+1), . . . , not qβmm (¯sm).Details of Adorn(r, pα(¯t), S, D) are reported in Fig. 3.Example 3.4. Let us resume from Example 3.2. We are supposing that the adopted SIPS is passing the bindings viaproduced_by and controlled_by to the variables of sc atoms, in particularsc(C1) ≺scb(C1)sc(C1) ≺scb(C1)produced_by(P, C1, C2) ≺scb(C1)produced_by(P, C1, C2)sc(C2)sc(C2)r3r3r3sc(C2) ≺scb(C2)sc(C2) ≺scb(C2)produced_by(P, C1, C2) ≺scb(C2)r3r3r3r4r4sc(C) ≺scb(C)sc(C) ≺scb(C)sc(C) ≺scb(C)sc(C) ≺scb(C)controlled_by(C, C1, C2, C3) ≺scb(C)controlled_by(C, C1, C2, C3) ≺scb(C)controlled_by(C, C1, C2, C3) ≺scb(C)r4r4r4r4r4produced_by(P, C1, C2)sc(C1)sc(C1)controlled_by(C, C1, C2, C3)sc(C1)sc(C2)sc(C3)sc(C1)sc(C2)sc(C3)= ∅= {C1}(cid:2)(cid:3)sc(C1)(cid:2)(cid:3)produced_by(P, C1, C2)(cid:2)(cid:3)sc(C2)(cid:2)(cid:3)sc(C2)(cid:2)(cid:3)produced_by(P, C1, C2)(cid:2)(cid:3)sc(C1)(cid:3)sc(C)= {C2}= {C}= ∅= {P, C2}= {P, C1}scb(C1)r3scb(C1)r3scb(C1)r3scb(C2)r3scb(C2)r3scb(C2)r3(cid:2)scb(C)r4scb(C)r4scb(C)r4fffffffff(cid:2)(cid:3)controlled_by(C, C1, C2, C3)= {C1, C2, C3}(cid:2)sc(C1)(cid:3)= fscb(C)r4(cid:2)(cid:3)sc(C2)= fscb(C)r4(cid:2)(cid:3)sc(C3)= ∅When scb is removed from the set S, we first select rule r3 and the head predicate sc(C1). Then the adorned version is3,1: scb(C1) ∨ scb(C2) :− produced_by(P, C1, C2).raM. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192167Function Generate(r, pα (¯t), ra )Input: r: rule; pα (¯t): adorned atom; ra : adorned rule;Output: a set of magic rules;: rule;var: R: set of rules; rbegin∗Let (≺pα (¯t), fpα (¯t)r) be the SIPS associated with r and pα (¯t).1.r2. R := ∅;3.4.5.αii (¯ti ) in H(ra) ∪ Bαii (¯ti )) :− magic(pα (¯t));for each atom pif αi (cid:9)= (cid:6) then∗ := magic(prfor each atom p j (¯t j ) in Badd atom p j (¯t j ) to B+(r+(r) such that p j (¯t j ) ≺pα (¯t)∗);rpi (¯ti ) do+(ra) ∪ B−(ra) different from pα (¯t) doend forR := R ∪ {r6.7.8.9.end if10.11. end for12.end.return R;∗};Fig. 4. Generate function.Next, r3 is processed again, this time with head predicate sc(C2), producing3,2: scb(C2) ∨ scb(C1) :− produced_by(P, C1, C2).raFinally, processing r4 we obtain4: scb(C) :− controlled_by(C, C1, C2, C3), scb(C1), scb(C2), scb(C3).ra(2) Generation. The algorithm uses the adorned rule ra for generating and collecting the magic rules in step 6 (Fig. 1).αiMore specifically, Generate(r, pα(¯t), ra) produces magic rules according to the following schema: if pi (¯ti) is an adornedatom (i.e., αi is not the empty string) occurring in ra and different from pα(¯t), a magic rule ris generated such that (i)+(r) such thatH(rq j(¯s j) ≺α∗) is the union of {magic(pα(¯t))} and the set of all the atoms qr pi(¯ti). Details of Generate(r, pα(¯t), ra) are reported in Fig. 4.αii (¯ti))} and (ii) B(r∗) = {magic(pβ jj (¯s j) ∈ B∗Example 3.5. Continuing with our running example, by invoking Generate(r3, scb(C1), raproduced:3,1), the following magic rule is∗3,1: magic_scb(C2) :− magic_scb(C1), produced_by(P, C1, C2).rSimilarly, by invoking Generate(r3, scb(C2), ra3,2), the following magic rule is produced:∗3,2: magic_scb(C1) :− magic_scb(C2), produced_by(P, C1, C2).rFinally, the following magic rules are produced by Generate(r4, scb(C), ra4):∗4,1: magic_scb(C1) :− magic_scb(C), controlled_by(C, C1, C2, C3).∗4,2: magic_scb(C2) :− magic_scb(C), controlled_by(C, C1, C2, C3).∗4,3: magic_scb(C3) :− magic_scb(C), controlled_by(C, C1, C2, C3).rrr(3) Modification. In step 7 the modified rules are generated and collected. The only difference with respect to the Datalogcase is that the adornments are stripped off the original atoms. Specifically, given an adorned rule ra associated with a ruleis obtained from r by adding to its body an atom magic(pα(¯t)) for each atom pα(¯t) occurring in H(ra).r, a modified rule r(cid:4)Hence, the function Modify(r, ra), reported in Fig. 5, constructs a rule r(cid:4)(cid:4):rp(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic(cid:2)of the form(cid:3)(cid:3)α1αnn (¯tn)1 (¯t1)q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).(cid:3)pα(¯t), . . . , magic, magicpp(cid:2)(cid:2),Finally, after all the adorned predicates have been processed, the algorithm outputs the program DMS(Q, P).168M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192(cid:4): rule;Function Modify(r, ra )Input: r: rule; ra : adorned rule;Output: a modified rule;var: rbegin1.2.3.4. end forreturn r5.end.add magic(pα (¯t)) to B;(cid:4)(cid:4) := r;rfor each atom pα (¯t) in H(ra) do+(r(cid:4));Fig. 5. Modify function.Example 3.6. In our running example, we derive the following set of modified rules:rr(cid:4)3,1: sc(C1) ∨ sc(C2) :− magic_scb(C1), magic_scb(C2), produced_by(P, C1, C2).(cid:4)3,2: sc(C2) ∨ sc(C1) :− magic_scb(C2), magic_scb(C1), produced_by(P, C1, C2).(cid:4)4: sc(C) :− magic_scb(C), controlled_by(C, C1, C2, C3), sc(C1), sc(C2), sc(C3).r(cid:4)3,1 (resp. r3,2, raHere, r4).Thus, the optimized program DMS(Qsc, Psc) comprises the above modified rules as well as the magic rules in Example 3.5,and the magic seed magic_scb(c) (together with the original EDB).(cid:4)4) is derived by adding magic predicates and stripping off adornments for the rule ra3,1 (resp. ra(cid:4)3,2, rBefore establishing the correctness of the technique, we briefly present an example of the application of DMS on aprogram containing disjunction and stratified negation.Example 3.7. Let us consider a slight variant of the Strategic Companies problem described in Example 3.1 in which we haveto determine whether a given company c does not belong to any strategic set. We can thus consider the query nsc(c) forthe program Pnsc obtained by adding to Psc the following rule:rnsc: nsc(C) :− company(C), not sc(C).where company is an EDB predicate. Company c does not belong to any strategic set if the query is cautiously false.In this case, processing the query produces the query seed magic_nscb(c) (a fact) and the adorned predicate nscb(which is added to set S). After that, nscb is moved from S to D and rule rnsc is considered. Assuming the following SIP:nsc(C) ≺nscb(C)nscb(C)rnscrnsc(nsc(C)) = {C}fcompany(C)nsc(C) ≺nscb(C)rnsc(company(P)) = fsc(C)nscb(C)rnscby invoking Adorn(rnsc, nscb(C), S, D) we obtain the following adorned rule:nscb(C)rnscf(sc(C)) = ∅nsc: nscb(C) :− company(C), not scb(C).raThe new adorned predicate scb is added to S. Then, Generate(rnsc, nscb(C), raing magic and modified rules:nsc) and Modify(rnsc, ransc) produce the follow-∗nsc: magic_scb(C) :− magic_nscb(C).(cid:4)nsc: nsc(C) :− magic_nscb(C), company(C), not sc(C).rrThe algorithm then processes the adorned atom scb. Hence, if the SIPS presented in Example 3.4 is assumed, the rewritten∗nsc , rprogram comprises the following rules: r(cid:4)nsc , r∗4,2 and r(cid:4)3,1, r∗3,1, r∗4,1, r∗3,2, r(cid:4)3,2, r(cid:4)4, r∗4,3.3.3. Query equivalence resultWe conclude the presentation of the DMS algorithm by formally proving its correctness. We would like to point outthat all of these results hold for any kind of SIPS, as long as it conforms to Definition 3.3. Therefore, in the remainder ofthis section, we assume that any program comes with some associated SIPS. In the proofs, we use the well establishednotion of unfounded set for disjunctive Datalog programs (possibly with negation) defined in [44]. Before introducing un-founded sets, however, we have to define partial interpretations, that is, interpretations for which some atoms may beundefined.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192169Definition 3.8 (Partial interpretation). Let P be a Datalogprogram. A partial interpretation for P is a pair (cid:14)T , N(cid:15) such thatT ⊆ N ⊆ BP . The atoms in T are interpreted as true, while the atoms in N are not false and those in N \ T are undefined.All other atoms are false.∨,¬Note that total interpretations are a special case in which T = N. We can then formalize the notion of unfounded set.program P , and X ⊆ BP be a set ofDefinition 3.9 (Unfounded sets). Let (cid:14)T , N(cid:15) be a partial interpretation for a Datalogatoms. Then, X is an unfounded set for P with respect to (cid:14)T , N(cid:15) if and only if, for each ground rule r g ∈ Ground(P) withX ∩ H(r g) (cid:9)= ∅, at least one of the following conditions holds:∨,¬+(r g) (cid:2) N;(1.a) B−(r g) ∩ T (cid:9)= ∅;(1.b) B+(r g) ∩ X (cid:9)= ∅;(2) B(3) H(r g) ∩ (T \ X) (cid:9)= ∅.Intuitively, conditions (1.a), (1.b) and (3) check if the rule is satisfied by (cid:14)T , N(cid:15) regardless of the atoms in X , whilecondition (2) checks whether the rule can be satisfied by taking the atoms in X as false.Example 3.10. Consider again the program Psc of Example 3.1 and assume EDB(Psc) = {produced_by(p, c, c1)}. ThenGround(Psc) consists of the rulersc: sc(c) ∨ sc(c1) :− produced_by(p, c, c1).(together with facts, and rules having some ground instance of EDB predicate not occurring in EDB(Psc), omitted for sim-plicity). Consider now a partial interpretation (cid:14)Msc, BPsc(cid:15) such that Msc = {produced_by(p, c, c1), sc(c)}. Thus, {sc(c1)}is an unfounded set for P with respect to (cid:14)Msc, BPsc(cid:15) (rsc satisfies condition (3) of Definition 3.9), while {sc(c), sc(c1)} isnot (rsc violates all conditions).The following is an adaptation of Theorem 4.6 in [44] to our notation.Theorem 3.11. (See [44].) Let (cid:14)T , N(cid:15) be a partial interpretation for a Datalogthat T ⊆ M ⊆ N, and for each unfounded set X of P with respect to (cid:14)T , N(cid:15), M ∩ X = ∅ holds.∨,¬program P . Then, for any stable model M of P suchExample 3.12. In Example 3.10, we have shown that {sc(c1)} is an unfounded set for P with respect to (cid:14)Msc, BPscthat the total interpretation Msc is a stable model of Psc, and that the unfounded set {sc(c1)} is disjoint from Msc.(cid:15). Note(cid:4)Equipped with these notions and Theorem 3.11, we now proceed to prove the correctness of the DMS strategy. Inparticular, we shall first show that the method is sound in that, for each stable model M of DMS(Q, P), there is a sta-(cid:4)|Q = M|Q (i.e., the two models coincide when restricted to the query). Then, we proveble model Mof P , there is a stable model M of DMS(Q, P) such thatthat the method is also complete, i.e., for each stable model MM(cid:4)|Q = M|Q.In both parts of the proof, we shall exploit the following (syntactic) relationship between the original program and theof P such that M(cid:4)transformed one.Lemma 3.13. Let P be a Datalogtransformed program). Then the ground rule∨,¬s program, Q a query, and let magic(pα(¯t)) be a ground atom6 in BDMS(Q,P) (the base of ther g :p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).belongs to Ground(P) if and only if the ground rule(cid:4)g :rp(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic(cid:2)(cid:2)(cid:3)pα(¯t)(cid:3)(cid:3)α1αnn (¯tn)1 (¯t1)q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm)., . . . , magic, magicpp(cid:2),belongs to Ground(DMS(Q, P)).6 Note that in this way the lemma refers only to rules that contain a head atom for which a magic predicate has been generated during the transforma-tion.170M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192Proof. (⇒) Consider the following rule r ∈ P such that r g = rϑ for some substitution ϑ :(cid:3)(cid:2)¯t(cid:4)p(cid:3)(cid:2)(cid:4)¯t1∨ p1r:∨ · · · ∨ pn(cid:3)(cid:2)(cid:4)¯tn:− q1(cid:3)(cid:2)¯s(cid:4)1, . . . , q j(cid:2)¯s(cid:4)j(cid:3), not q j+1(cid:2)¯s(cid:4)j+1(cid:3), . . . , not qm(¯s(cid:4)m).Since magic(pα(¯t)) is a ground atom in BDMS(Q,P), pα has been inserted in the set S at some point of the Magic Set(cid:4) ∈ DMS(Q, P):transformation, and it has eventually been used to adorn and modify r, thereby producing the following rule r(cid:2)¯t, . . . , magic(cid:2)¯tpα∨ · · · ∨ pn∨ p1(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)ppp(cid:3)(cid:2)(cid:2)(cid:2)(cid:3)(cid:3),r:(cid:4)(cid:4)(cid:4)(cid:2)(cid:4)¯tn(cid:2)(cid:4)¯t1:− magic(cid:3)(cid:4)1q1¯s(cid:2), magic(cid:3)(cid:2)¯s(cid:4)jα11(cid:2)(cid:4)¯t1(cid:2)¯s(cid:3)(cid:4)j+1, . . . , q j, not q j+1, . . . , not qmαnn(cid:2)(cid:2)(cid:4)¯tn(cid:3)(cid:4)¯sm.Clearly enough, the substitution ϑ mapping r into r g can also be used to map r(cid:4)into r(cid:4)g , since the magic atoms added(cid:4)into the positive body of rare defined over a subset of the variables occurring in head atoms.(⇐) Let r(cid:4):rp(cid:4) ∈ DMS(Q, P) be a rule such that r(cid:2)¯t∨ · · · ∨ pn∨ p1(cid:2)(cid:4)¯tn(cid:2)(cid:4)¯t1(cid:3)(cid:3)(cid:3)(cid:4)(cid:4)g= r(cid:2)pα(cid:4)ϑ for some substitution ϑ :(cid:2)(cid:2)¯t(cid:3)(cid:3)(cid:3)(cid:3)p(cid:4), . . . , magic, magic(cid:3)(cid:2)¯s(cid:4)jα11(cid:2)(cid:4)¯t1(cid:2)¯s(cid:3)(cid:4)j+1(cid:2)pαnn(cid:2)(cid:2)(cid:4)¯tn(cid:3)(cid:4)¯sm(cid:3)(cid:3),., . . . , q j, not q j+1, . . . , not qm:− magic(cid:3)(cid:4)1q1¯s(cid:2)By the construction of DMS(Q, P), r(cid:4)is a modified rule produced by adding some magic atom to the positive body of arule r ∈ P of the form:(cid:2)(cid:2)(cid:4)¯t¯t1∨ p1r:p(cid:3)(cid:4)(cid:3)∨ · · · ∨ pn(cid:3)(cid:2)(cid:4)¯tn:− q1(cid:3)(cid:2)¯s(cid:4)1, . . . , q j(cid:2)¯s(cid:4)j(cid:3), not q j+1(cid:2)¯s(cid:4)j+1(cid:3), . . . , not qm(cid:2)(cid:3).(cid:4)¯smThus, the substitution ϑ mapping r(cid:4)to r(cid:4)g can also be used to map r to r g , since r and r(cid:4)have the same variables. (cid:2)3.3.1. Soundness of the Magic Set methodLet us now start with the first part of the proof, in particular, by stating some further definitions and notations. Given a, we next define the set of atoms which are relevantof DMS(Q, P), and a model Nof Ground(DMS(Q, P))M(cid:4) ⊆ M(cid:4)(cid:4)(cid:4)model Mfor Q but are false with respect to N(cid:4).(cid:4)(cid:4)(cid:4)) of the killed atoms with respect to MDefinition 3.14 (Killed atoms). Given a model MkilledMQ,P (N(cid:4)k(¯t) ∈ BP \ N(cid:4)(cid:5)(cid:5) either k is an EDB predicate, or there is a binding α such that magic(cid:2)(cid:3)kα(¯t)(cid:6)(cid:4).∈ Nfor DMS(Q, P), and a model N(cid:4)is defined as:and N(cid:4)(cid:4) ⊆ M(cid:4)of Ground(DMS(Q, P))M(cid:4), the setExample 3.15. We consider the program DMS(Qsc, Psc) presented in Section 3.2 (we recall that Qsc = sc(c)), theEDB {produced_by(p, c, c1)} introduced in Example 3.10, and a stable model M= {produced_by(p, c, c1), sc(c),magic_scb(c), magic_scb(c1)} for DMS(Qsc, Psc). Thus, Ground(DMS(Qsc, Psc))Msc consists of the following rules:(cid:4)scmagic_scb(c).sc(c) ∨ sc(c1) :− magic_scb(c), magic_scb(c1), produced_by(p, c, c1).magic_scb(c1) :− magic_scb(c).(cid:4)sc is also a model of the program above, we can compute killedSince Mto it because of magic_scb(c1) in Mproduced_by(p, c1, c) or controlled_by(c, c1, c1, c1) belong to killedbelongs to this set.(cid:4)sc) and check that sc(c1) belongs(cid:4)sc. Note that, by definition, also false ground instances of EDB predicates like(cid:4)sc). Moreover, note that no other atom(cid:4)MscQsc,Psc(M(M(cid:4)MscQsc,PscThe intuition underlying the definition above is that killed atoms are either false ground instances of some EDB predicate,(cid:4)); since N, we expect that these atoms are also false in any stable model for Por false atoms which are relevant with respect to Q (for there exists an associated magic atom in the model Nis a model of Ground(DMS(Q, P))Mcontaining Mrestricted on the atoms originally occurring in P ).(cid:4)|BP (which, we recall here, is the model Mcontained in M(cid:4)(cid:4)(cid:4)(cid:4)= {produced_by(p, c, c1), sc(c)}, which coin-Example 3.16. Let us resume from Example 3.15. We have that Mcides with model Msc of Example 3.10. Hence, we already know that {sc(c1)} is an unfounded set for Psc with respect(cid:4)to (cid:14)Msc, BPscsc) is such that k is an EDB predicate, we also have that(M(cid:15). Therefore, as a consequence of Theorem 3.11,(Mkilledeach stable model M of Psc such that Msc ⊆ M ⊆ BPsc (in this case only Msc itself) is disjoint from killed(cid:15). Since each other atom k(¯t) in killed(cid:4)sc) is an unfounded set for Psc with respect to (cid:14)Msc, BPsc(cid:4)MscQsc,Psc(cid:4)MscQsc,Psc|Psc(M(cid:4)sc).(cid:4)MscQsc,Psc(cid:4)scM. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192171This intuition is formalized below.Proposition 3.17. Let Munfounded set for P with respect to (cid:14)Mbe a model for DMS(Q, P), and N(cid:4)|BP , BP (cid:15).(cid:4)(cid:4) ⊆ M(cid:4)be a model of Ground(DMS(Q, P))M(cid:4). Then, killedMQ,P (N(cid:4)(cid:4)) is anProof. According to Definition 3.9 of unfounded sets (for P with respect to (cid:14)Mof the form(cid:4)|BP , BP (cid:15)), given any rule r g in Ground(P)r g :k(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).(cid:4)) ∩ H(r g), then at least one of the following conditions holds: (1.a) B+(r g) (cid:2) BP ;we have to show that if k(¯t) ∈ killedM(1.b) BQ,P (N+(r g) ∩ killedM(cid:4)(cid:4)−(r g) ∩ M(cid:4)|BP (cid:9)= ∅; (2) B(cid:4)) (cid:9)= ∅; (3) H(r g) ∩ (MNote that the properties above refer to the original program P . However, our hypothesis is formulated over the trans-formed one DMS(Q, P) (for instance, we know that Mis a model of DMS(Q, P)). The line of the proof is then to analyzeDMS(Q, P) in the light of its syntactic relationships with P established via Lemma 3.13. In particular, recall first that, by(and, hence, magic(kα(¯t)) is a ground atom in BDMS(Q,P)).Definition 3.14, there is a binding α such that magic(kα( ¯t)) ∈ NThus, we can apply Lemma 3.13 and conclude the existence of a ground rule r∈ Ground(DMS(Q, P)) such that:(cid:4)|BP \ killedM(cid:4))) (cid:9)= ∅.Q,P (NQ,P (N(cid:4)(cid:4)(cid:4)(cid:4)gk(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic(cid:2)(cid:2)(cid:3)kα(¯t)(cid:3)(cid:3)α1αnn (¯tn)1 (¯t1),q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm)., . . . , magic, magicpp(cid:2)(cid:4)g :r(cid:4)is a model of DMS(Q, P), the proof is just based on analyzing the following three scenarios that exhaustively coverSince Mall possibilities (concerning the fact that the rule r(cid:4)g is satisfied by M(cid:4)):(S1) B(S2) B(S3) B(cid:4)g) ∩ M(cid:4)g) (cid:2) M(cid:4)g) ∩ M−(r+(r+(r−(rtrue with respect to M(cid:4) (cid:9)= ∅, i.e., the negative body of r(cid:4), i.e., the positive body of r(cid:4) = ∅, B(cid:4)g) ⊆ M, and H(r(cid:4).(cid:4)(cid:4)g is false with respect to M(cid:4);(cid:4)g is false with respect to M(cid:4)g) ∩ M(cid:4);(cid:4) (cid:9)= ∅, i.e., none of the previous cases holds, and hence the head of r(cid:4)g isIn the remaining, we shall show that (S1) implies condition (1.b), (S2) implies condition (2), and (S3) implies either (2)or (3). In fact, note that condition (1.a) cannot hold.(S1) Assume that BB−(r g) ∩ M(S2) Assume that B(cid:2)¯tkr:(cid:4)−(r(cid:4)g) ∩ M(cid:4) (cid:9)= ∅. Since B(cid:4)|BP (cid:9)= ∅, i.e., (1.b) holds.(cid:4), and let r+(r(cid:3)(cid:4)g) (cid:2) M(cid:3)(cid:2)(cid:4)¯t1∨ p1(cid:4)∨ · · · ∨ pn−(r g) = B−(r(cid:4)g) and B−(r g) ⊆ BP , from B−(r(cid:4)g) ∩ M(cid:4) (cid:9)= ∅ we immediately conclude(cid:4) ∈ DMS(Q, P) be a modified rule such that r(cid:3)(cid:3)(cid:2)(cid:4)¯tn(cid:2)kα(cid:2)¯t(cid:3)(cid:3)p(cid:2)(cid:3)(cid:4)(cid:2)(cid:4)¯t1(cid:2), magic(cid:3)(cid:2)¯sα11, not q j+1(cid:4)j(cid:3)¯s(cid:4)j+1:− magic(cid:3)(cid:4)1q1¯s(cid:2), . . . , q j, . . . , magicp, . . . , not qmαnn(cid:2)(cid:2)(cid:4)¯tn(cid:4)¯sm,(cid:3).(cid:4)g= r(cid:4)ϑ for some substitution ϑ :(cid:2)(cid:3)(cid:3)(cid:4)(cid:4)(cid:4)∗∗+(r+(r+(r+(rαii (¯t, a magic rule rmust hold in this case. To prove the claim, observe that during the Generation∗(cid:4))),i ) = {magic(p(cid:4)j)} has been produced for each 1 (cid:4) i (cid:4) n (we recall that magic rules have empty negative bodies).∗(cid:4)i we obtain ai,g) ⊆ {magic(kα(¯t)), q1(¯s1), . . . , q j(¯s j)} = {magic(kα(¯t))} ∪is a model containing magic(kα(¯t)) by(cid:4)(cid:4)(cid:4)g) (cid:2) M, from the above magic rules and since N, by applying the substitution ϑ to r. However, this is impossible, since Ni ) ⊆ {magic(kα(¯t(cid:4)i))} and B(cid:4)g)|BP ⊆ N(cid:4) ⊆ M(cid:4)1), . . . , q j(¯sWe first claim that Bαii (¯ti))} and B(cid:4)g)|BP . Thus, if B∗i such that H(r(cid:4)g)|BP (cid:2) N(cid:4)step preceding the production of rq1(¯s∗Hence, since the variables of ri are a subset of the variables of r∗∗i,g) = {magic(pi,g such that H(rground rule r(cid:4)+(r+(rBassumption, then we would conclude that Bimply BNow, BIn particular, we can assume w.l.o.g. that, for any q(¯s) ∈ B(cid:4)where r is the rule in P from which the modified rule r+(rBOtherwise, qi is an IDB predicate. In this case, there is a magic rule r∗i ) = {magic(q(cid:4)+(rg) (cid:2) N.(cid:4)+(rg)|BP (cid:2) N(cid:4)g)|BP \ N(cid:4)g) ⊆ N(cid:4)g)|BP with q(¯simplies the existence of an atom qi(¯si) ∈ B). If qi is an EDB predicate, the atom qi(¯si) belongs to killedM(cid:4)g)|BP such that qi(¯si) /∈ N(cid:4)) ≺kα (¯t+(rhas been generated (just take a ≺kα (¯t, that is, qi(¯si) ∈ BP \ Ni), it is the case that q(¯s) ∈ N-minimum element in(cid:4)) by the definition of killed atoms.∗i , produced during the Generation step preceding(cid:4)+(r) | q(¯si)}.holds because magic(kα(¯t)) belongs to N(cid:4)(cid:4)βii (¯si)) belongs to N,(cid:4)) follows from the definition of killed atoms. Thus, independently of the type (EDB,i ) = {magic(kα(¯t∗(cid:4)i))} and B(r∗∗+(ri ϑ belongs to Ground(DMS(Q, P)). In particular, Bi,g) ⊆ Nis a model of Ground(DMS(Q, P))M, such that H(r(cid:4)))} ∪ {q(¯s(cid:4)) ≺kα (¯t, magic(qQ,P (N(cid:4)) ∈ Bthe production of rThus, rand by the properties of qi(¯si). Therefore, since Nfrom which qi(¯si) ∈ killedMIDB) of qi , (2) holds.Q,P (Nβii (¯sand Bqi(¯sqi(¯s+(r+(r= r∗i,g(cid:4))(cid:4))(cid:4)).,rrr(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)172M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192(S3) Assume that B+(r(cid:4)g) ⊆ M(cid:4), B−(r(cid:4)g) ∩ M(cid:4) = ∅, and H(r(cid:4)g) ∩ Mobtained from r(cid:4) (cid:9)= ∅. First, observe that from B(cid:4) = ∅ we can(cid:4)g by removing its negative body literals. Consider(cid:4)g) ∩ M−(r(cid:4)∗i,g produced during the Generation step, for each 1 (cid:4) i (cid:4) n (as in (S2)). We distinguish two cases., we can conclude that B+(r, the latter implies that magic(pis a model of Ground(DMS(Q, P))M(cid:4)g) ∩ M(cid:4)|BP ) \ killedMQ,P (N(cid:4)(cid:4)g) contains only standard atoms and H(r(cid:4), and by Definition 3.14, N(cid:4) ∩ killedM(cid:4)(cid:4)(cid:4)(cid:4)∗i,g) ⊆ Nαii (¯ti)) ∈ N, for each 1 (cid:4) i (cid:4) n. Moreover,, for each 1 (cid:4) i (cid:4) n. Then). We now observe that(cid:4)) (cid:9)= ∅. Moreover, the latter is equiv-(cid:4)g) = H(r g). In addition,(cid:4)) = ∅ holds. Hence,Q,P (N(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)B(cid:4)g) ∩ N(cid:4)|BP \ killedMholds, and so H(r, since magic(kα(¯t)) ∈ Nis a model of Ground(DMS(Q, P))Mconclude that there is a rule in Ground(DMS(Q, P))Mnow the rules rIf {q1(¯s1), . . . , q j(¯s j)} ⊆ Nsince N(cid:4)+(rg) ⊆ N(cid:4)g) ∩ (MH(ralent to (H(r g) ∩ M(cid:4) ⊆ Mfrom N(cid:4)) \ killedM(H(r g) ∩ MOtherwise, {q1(¯s1), . . . , q j(¯s j)} (cid:2) Nqi(¯spredicate, the atom qi(¯si) belongs to killedMand there is a magic rule r(cid:4) (cid:9)= ∅ (because N(cid:4))) (cid:9)= ∅ is equivalent to (H(r(cid:4)) (cid:9)= ∅ because H(rQ,P (N(cid:4) ⊆ H(r g) ∩ M(cid:4)we conclude H(r g) ∩ N(cid:4)) ⊇ H(r g) ∩ N(cid:4)i) implies q(¯s) ∈ NQ,P (N(cid:4)) \ killedMQ,P (NQ,P (N(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4), which is not empty, and so condition (3) holds.. Let i ∈ {1, . . . , j} be such that qi(¯si) /∈ N(where r is the rule in P from which the modified rule r(cid:4)and, for any q(¯s) ∈ B(cid:4)) ≺kα (¯thas been generated). If qi is an EDB(cid:4)) by the definition of killed atoms. Otherwise, qi is an IDB predicate∗(cid:4)i,g) ⊆ N.(cid:4)) follows from the definition of killed atoms.βii (¯si)) in head, and such that B(cid:4)g)|BP , q(¯s+(r+(r(cid:4))r(cid:4)(cid:4)Therefore, magic(qThus, independently of the type (EDB, IDB) of qi , (2) holds. (cid:2)βii (¯si)) belongs to N∈ Ground(DMS(Q, P)) having an atom magic(q, from which qi(¯si) ∈ killedMQ,P (N(cid:4)∗i,gWe can now complete the first part of the proof.Lemma 3.18. For each stable model M(cid:4)of DMS(Q, P), there is a stable model M of P such that M ⊇ M(cid:4)|BP .Proof. Let M be a stable model of P ∪ Mshall show that M is in fact a stable model of P such that M ⊇ MSo, the line of the proof is to show that if M is not stable, then it is possible to build a model Nsuch that N, thereby contradicting the minimality of Mover the models of Ground(DMS(Q, P))M(cid:4)|BP , the program obtained by adding to P a fact for each atom in M(cid:4)|BP . Of course, M is a model of P such that M ⊇ M(cid:4)|BP . We(cid:4)|BP .of Ground(DMS(Q, P))M(cid:4) ⊂ M.(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)Assume, for the sake of contradiction, that M is not stable and let N ⊂ M be a model of Ground(P)M . Define N(cid:4)(cid:4)|BP ) ∪ (M(cid:4)(cid:4) = M(cid:4) \ BP ). By construction, note that N, we would have that N ⊇ Minterpretation (N ∩ Mfact, in the case where Nwould not only be a model for Ground(P)M but also a model for Ground(P ∪ M(cid:4)|BP . So, Nholds. However, this is impossible, since M is a stable model of P ∪ Mproof and get a contradiction, it remains to show that Nthe rules in Ground(DMS(Q, P))M(cid:4) ⊆ M(cid:4)|BP , since (N ∩ M(cid:4)(cid:4)(cid:4), since M. To this end, we have to consider the following two kinds of rules:is actually a model of Ground(DMS(Q, P))M(cid:4)(cid:4)|BP ) and (Mcoincides with Mas the(cid:4)|BP ∪ (M(cid:4) \ BP ). In(cid:4) \ BP ) are disjoint. Hence, N(cid:4)|BP )M , while on the other hand N ⊂ M(cid:4) ⊂ Mmust hold. Hence, to complete the, i.e., it satisfies all(cid:4)(cid:4)∗∈ Ground(DMS(Q, P))M(1) Consider a ground magic rule rg+(r, B(cid:4)(cid:4) ⊂ M∗g). Since Ng)| = 1, magic(pα(¯t)) ∈ Matom in H(r|H(ratom, magic(pα(¯t)) is also contained in Mimplies that Bmust hold (we recall that B, and let magic(pα(¯t)) be the (only)such that B∗+(ris a model of DMS(Q, P) andg) ⊂ M∗−(rg) = ∅). Moreover, since BP does not contain any magic(cid:4) (cid:9)= ∅.(cid:4) \ BP . Thus, by the construction of N∈ Ground(DMS(Q, P)) where∗+(rg) ⊆ N. In fact, since M(2) Consider a rule obtained by removing the negative literals from a ground modified rule r, we can conclude that H(r∗g) ⊆ N∗g) ∩ N∗(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)g(cid:4)g :rp(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic(cid:2)(cid:2), magic(cid:3)pα(¯t)(cid:3)α11 (¯t1),q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).(cid:4)g) ∩ M(cid:3)αnn (¯tn), . . . , magicpp(cid:2)+(rand where BGround(P) associated with r(cid:4)g) ⊆ N(cid:4)(cid:4)g (according to Lemma 3.13):. Observe that B−(r(cid:4) = ∅ holds by the definition of reduct. Moreover, let r g be the rule ofr g :p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).We have to show that H(r(cid:4)g) ∩ N(cid:4) (cid:9)= ∅. The proof is based on establishing the following properties on r(cid:4)g and r g :(cid:2)(cid:3)= ∅;∩ M = ∅;(cid:4)(cid:3)(cid:2)(cid:3)M(cid:4)• M ∩ killedMQ,P(cid:3)(cid:4)(cid:4)\ M•Hg(cid:4)−∩ M = ∅;• Bg(cid:2)(cid:3)(cid:2)(cid:4) = H∩ M• Hrr• H(r g) ∩ N (cid:9)= ∅.(cid:2)r(cid:2)r(cid:4)g(cid:3)(cid:4)g∩ M(cid:4)|BP = H(cid:3)(cid:2)r(cid:4)g∩ M;(1)(2)(3)(4)(5)M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192173In particular, we shall directly prove (1), and show the following implications: (1) → (2) ∧ (3), (2) → (4), and (3) → (5).(cid:4) (cid:9)= ∅ can be easily derived as follows: Since H(r g) ⊆ BP , by the(cid:4)|BP ). Moreover, becausecoincides in turn with (H(r g) ∩ N) ∩ (H(r g ) ∩ M). Then, recall that N ⊂ M.Eventually, based on (4) and (5), the fact that H(rdefinition of Nof (4) and the fact that H(r g) = H(rThus, H(r g) ∩ Nwe can conclude that H(r g) ∩ N(cid:4)g), H(r g) ∩ N(cid:4) = H(r g) ∩ N, which is not empty by (5).(cid:4)|BP ) = (H(r g) ∩ N) ∩ (H(r g) ∩ M(cid:4) = H(r g) ∩ (N ∩ M(cid:4)(cid:4)g) ∩ N(cid:4)In order to complete the proof, we have to show that all the above equations actually hold.(cid:4)|BP , BP (cid:15). In fact, one may notice that killedMProof of (1). We recall that, by Proposition 3.17, we already know that killedMrespect to (cid:14)M(cid:14)Mby Definition 3.14. Thus, since M ⊇ M(cid:4)) = ∅.conclude that M ∩ killedM(cid:4)|BP , BP (cid:15) too, since the rules added to P are facts corresponding to the atoms in M(cid:4)|BP and M is a stable model of P ∪ MQ,P (M(cid:4)) is an unfounded set for P ∪ M(cid:4)) is an unfounded set for P with(cid:4)|BP with respect to(cid:4)) = ∅Q,P (M(cid:4)|BP , we can apply Theorem 3.11 in order to(cid:4)|BP ∩ killedM(cid:4)|BP and MQ,P (M(cid:4)(cid:4)(cid:4)Q,P (M(cid:4)Proof of (2). After (1), we can just show that H(rimplies B+(r(cid:4)g) ⊂ M(cid:4). Thus, H(r(cid:4)g) \ M(cid:4) ⊆ killedM(cid:4)Q,P (M(cid:4)g) \ M(cid:4) ⊆ killedM(cid:4)Q,P (M(cid:4)). In fact, since N(cid:4) ⊂ M(cid:4)(cid:4)) follows by Definition 3.14 and the form of rule r, we note that B(cid:4)g .+(r(cid:4)g) ⊆ N(cid:4)Proof of (3). After (1), we can just show that Bbelong to killedMQ,P (MTo this end, consider a modified rule r(cid:4)), as EDB atoms in B−(r(cid:4)(cid:4):r(cid:3)(cid:2)¯t(cid:4)p(cid:3)(cid:2)(cid:4)¯t1∨ p1∨ · · · ∨ pn(cid:2)(cid:4)¯tn−(r(cid:4)g) ⊆ killedMQ,P (M(cid:4)(cid:4)g) clearly belong to killedM(cid:4) ∈ DMS(Q, P) such that r(cid:2)(cid:3)(cid:3)(cid:3)(cid:4)g(cid:2)¯t(cid:4)pα:− magic(cid:3)(cid:4)1q1¯s(cid:2), magic(cid:3)(cid:2)¯s(cid:4)j, . . . , q j, not q j+1(cid:4)−(rQ,P (M(cid:4)g)(cid:4) = ∅ by assumption.(cid:4)) because B(cid:4)). Actually, we show that the IDB atoms in B−(r(cid:4)g) ∩ M(cid:4)ϑ for some substitution ϑ :(cid:3)(cid:3)(cid:2)(cid:4)¯t1(cid:2)¯s, . . . , magic, . . . , not qm(cid:2)(cid:4)¯tn(cid:3)(cid:4)¯smαnn(cid:2)(cid:4)j+1(cid:3)(cid:3)p(cid:3)(cid:2),.= r(cid:2)pα11(cid:4)(cid:4)) has been produced for each j + 1 (cid:4) i (cid:4) m such that qi is an IDB predicate. Hence, since the variables of r∗i ) = {magic(q∗i with H(r, a magic rule r(cid:4)i))} and where Bβii (¯sDuring the Generation step preceding the production of r+(rBof the variables of r∗+(ri,g) ⊆ B∗i,g must be true with respect to M, the substitution ϑ can be used to map r(cid:4)g) ⊆ N(cid:4)(cid:4)g). Now, since B(cid:4) ⊂ M+(r+(rB(cid:4)of rholds, for each j + 1 (cid:4) i (cid:4) m such that qi is an IDB predicate. Moreover, Bβii (¯si) ∈ Bq(cid:4)g). Thus, by Definition 3.14, qβii (¯si) ∈ killedMQ,P (M−(r(cid:4)).(cid:4)(cid:4)∗i to a ground rule r, we can conclude that B+(r(we recall that magic rules have empty negative bodies). That is, magic(q−(r(cid:4) = ∅ implies that q∗i ϑ with H(r∗i,g) is in turn contained in M∗i,g) = {magic(q= r∗i,g(cid:4)(cid:4)g) ∩ M∗+(ri ) ⊆∗i are a subsetβii (¯si))} and. Thus, the head(cid:4)βii (¯si)) ∈ M, as(cid:4)βii (¯si) ∈ BP \ MProof of (4). The property immediately follows from (2) and the fact that H(r(cid:4)g) ⊆ BP and M ⊇ M(cid:4)|BP .Proof of (5). Note that Bthe atoms in B+(r g) ⊆ N (more specifically, BBH(r g) ∩ N (cid:9)= ∅. (cid:2)−(r−(r g) = B(cid:4)g), and so (3) implies that there is a rule in Ground(P)M obtained from r g by removing+(r(cid:4)−(r g). Note also that B(cid:4)g) ⊆ N). Thus, by the definition of N,(cid:4)|BP ). Moreover, since N is a model of Ground(P)M , the latter entails that+(r g) = B+(r g) ⊆ N ∩ M(cid:4) ∩ BP (since B(cid:4)g) ∩ BP ⊆ N+(r(cid:4)Theorem 3.19. Let Q be a query for a DatalogM of P such that M(cid:4)|Q = M|Q.∨,¬s program P . Then, for each stable model M(cid:4)of DMS(Q, P), there is a stable modelProof. Because of Lemma 3.18, for each stable model MM(cid:4)|BP . Thus, we trivially have that M|Q ⊇ MIn fact, by the definition of DMS(Q, P), the magic seed is associated to any ground instance of Q. Then BP |Q \(cid:4)) by Definition 3.14 (we recall that BP |Q denotes the ground instances of Q). By Proposition 3.17,(cid:4) ⊆ killedM(cid:4)|BP , BP (cid:15). Hence, by Theorem 3.11, we have that M ∩Q,P (M(cid:4)|Q impliesQ,P (MQ,P (M(cid:4)) is an unfounded set for P with respect to (cid:14)M(cid:4)) = ∅. It follows that M ∩ (BP |Q \ M(cid:4)|Q holds. We now show that the inclusion cannot be proper.(cid:4)|Q = ∅, which combined with M|Q ⊇ M(cid:4)) = ∅. Thus, M|Q \ Mof DMS(Q, P), there is a stable model M of P such that M ⊇(cid:4)(cid:4)(cid:4)MkilledMkilledMM|Q = M(cid:4)(cid:4)|Q. (cid:2)3.3.2. Completeness of the Magic Set methodFor the second part of the proof, we construct an interpretation for DMS(Q, P) based on one for P .174M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192Definition 3.20 (Magic variant). Let I be an interpretation for P . We define an interpretation variantcalled the magic variant of I with respect to Q and P , as the limit of the following sequence:∞Q,P (I) for DMS(Q, P),variant0varianti+1(cid:4)Q,P (I) = EDB(P);Q,P (I) = variantiandQ,P (I) ∪(cid:5)(cid:5) there is a binding α such that(cid:6)(cid:3)pα(¯t)∪Q,P (I)magic(cid:3) (cid:5)(cid:3)(cid:5) ∃r∗DMS(Q, P)g(cid:2)(cid:3)pα(¯t)∗∈ Hrg∈ Ground(cid:3)∗g∈ varianti(cid:2)and B(cid:2)r+(cid:3)(cid:2)pα(¯t)(cid:2)p(¯t) ∈ I(cid:4)(cid:2)magicmagicsuch that(cid:6)Q,P (I)⊆ varianti, ∀i (cid:3) 0.Example 3.21. Consider the program DMS(Qsc, Psc) presented in Section 3.2, the EDB {produced_by(p, c, c1)} and the in-terpretation Msc = {produced_by(p, c, c1), sc(c)}. We next compute the magic variant variant(Msc) of Msc withrespect to Qsc and Psc. We start the sequence with the original EDB: variant0(Msc) = {produced_by(p, c, c1)}.For variant1(Msc), we add sc(c) (because(Msc)), and magic_scb(c1) (because magic_scb(c1) :− magic_scb(c).sc(c) ∈ Msc and magic_scb(c) ∈ variant0is a rule of Ground(DMS(Qsc, Psc)) and magic_scb(c) ∈ variant0(Msc)). Any other element of the sequence coincideswith variant2(Msc), and so also variantQsc,Psc(Msc), we add magic_scb(c) (the query seed), while for variant2∞Qsc,Psc(Msc).Qsc,PscQsc,PscQsc,PscQsc,Psc∞Qsc,PscQsc,PscBy definition, for a magic variant variant∞Q,P (I) of an interpretation I with respect to Q and P , variantholds. More interestingly, the magic variant of a stable model for P is in turn a stable model for DMS(Q, P).∞Q,P (I)|BP ⊆ IExample 3.22. The magic variant of Msc with respect to Qsc and Psc (see Example 3.21) coincides with the interpretation(cid:4)Msc is a stablemodel of DMS(Qsc, Psc).(cid:4)sc introduced in Example 3.15. From previous examples, we know that Msc is a stable model of Psc, and MThe following two lemmas formalize the intuition above, with the latter being the counterpart of Lemma 3.18.Lemma 3.23. For each stable model M of P , the magic variant MM ⊇ M(cid:4)|BP .(cid:4) = variant∞Q,P (M) of M is a model of Ground(DMS(Q, P))M(cid:4)with(cid:4)is the magic variant of the stable model M, we trivially have that M ⊇ MProof. As Mis a model of Ground(DMS(Q, P))Mrule obtained by removing the negative body literals from a rule r+(rBhold. We have to show that H(r(cid:4)(cid:4)(cid:4)g(cid:4)g) ⊆ M. To this end, consider a rule in Ground(DMS(Q, P))M∈ Ground(DMS(Q, P)) such that B(cid:4)(cid:4)|BP holds. We next show that Mhaving the body true, that is, a(cid:4) = ∅ and(cid:4)g) ∩ M−(r(cid:4)In the case where r(cid:4)g is a magic rule, then B(cid:4)g) belongs to M(cid:4)tion 3.20). The only remaining (slightly more involved) case to be analyzed is where rg is a modified rule of the form(cid:2)(cid:3)(cid:3)α1αnn (¯tn)1 (¯t1)q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magicimplies that the (only) atom in H(r(cid:3)pα(¯t), . . . , magic, magic(cid:4)g :pp(cid:2)(cid:2),r(cid:4)(cid:4)(by Defini-(cid:4) (cid:9)= ∅.(cid:4)g) ∩ M(cid:4)+(rg) ⊆ MIn this case, we first apply as usual Lemma 3.13 in order to conclude the existence of a rule r g ∈ Ground(P) of the formr g :p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).Then, we claim that the following two properties hold:−+• B• B(r g) ∩ M = ∅;(r g) ⊆ M.(6)(7)These properties are in fact what we just need to establish the result. Indeed, since M is a model of Ground(P)M , (6) and (7)(cid:4)g) ∩ M andimply H(r g) ∩ M (cid:9)= ∅. So, we can recall that H(r g) = H(r(cid:4)+(r+(rg) ⊆magic(pMas well by Definition 3.20. That is,H(rg), and hence let pi(¯ti) be an atom in H(r g) ∩ M = H(r(cid:4)g) (i ∈ {(cid:6), 1, . . . , n}, where (cid:6) is the empty string). Since B(cid:4)(by hypothesis) and since pi(¯ti) ∈ M, we can then conclude that pi(¯ti) is in M(cid:4)g) ∩ MLet now finalize the proof, by showing that the above properties actually hold.αii (¯ti)) be its corresponding magic atom in B(cid:4) (cid:9)= ∅.(cid:4)(cid:4)M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192175(cid:4) ∈ DMS(Q, P) such that rProof of (6). Consider a modified rule r(cid:3)(cid:3)(cid:3)(cid:3)(cid:2)(cid:3)(cid:4)g(cid:2)(cid:4)r:p(cid:2)¯t(cid:4)(cid:2)(cid:4)¯t1∨ p1∨ · · · ∨ pn(cid:2)(cid:4)¯tn(cid:2)¯t(cid:4)= rpα11(cid:3)(cid:3)(cid:4)ϑ for a substitution ϑ :(cid:2)(cid:2)(cid:4)(cid:4)¯t¯tn1(cid:3)(cid:2)(cid:4)¯s¯sm, . . . , not qm, . . . , magic(cid:4)j+1αnn(cid:2)p(cid:2)(cid:3)(cid:3)(cid:3),., not q j+1and the rule r ∈ P from which r(cid:3)(cid:3)(cid:4)(cid:2)¯t(cid:4)(cid:2)(cid:4)¯t1∨ p1r:p∨ · · · ∨ pn(cid:2)(cid:4)¯tn:− q1¯s(cid:4)1, . . . , q j, not q j+1¯s(cid:4)j(cid:3)(cid:2)¯s(cid:4)j+1, . . . , not qm(cid:2)(cid:3).(cid:4)¯smpα(cid:2):− magic(cid:3)(cid:4)1is produced (such that r g = rϑ ):(cid:3), magic(cid:3)(cid:2)¯s, . . . , q jq1(cid:4)j¯s(cid:3)(cid:3)(cid:2)(cid:2)(cid:4)B, a magic rule ris an IDB predicate. Hence, since the variables of r∗i,g∗i to a ground rule r(cid:4), the substitution ϑ can be used to map r+(rDuring the Generation step preceding the production of rproduced for each j + 1 (cid:4) i (cid:4) m such that qivariables of r∗+(ri,g) ⊆ B∗+(ri,g) is in turn contained in Mis, magic(qbelongs to M, by Definition 3.20 we can conclude that qi(¯si) ∈ M−(r g) = B(we recall that BEDB predicates too, since B(cid:4)g)). This proves that IDB predicates in B(cid:4)g) ∩ M−(r−(r g) ∩ Mi (¯ti)) ∈ Mβi(cid:4) = ∅ and M(cid:4)g) (we recall that magic rules have empty negative body). Now, since B. Thus, by the construction of M, the head of r∗i,g must be true with respect to Mholds for each j + 1 (cid:4) i (cid:4) m such that qi is an IDB predicate. So, if some (IDB) atom qi(¯si) ∈ B(cid:4)g) ∩ M, that−(r g)(cid:4) = ∅−(r g) do not occur in M. The same trivially holds for, which contradicts the assumption that B(cid:4)i))} has been∗i are a subset of thei (¯ti))} andβi, we can conclude that∗i,g) = {magic(q(cid:4)(cid:4) ⊇ EDB(P) (by the definition of magic variant).∗i ϑ such that H(r+(r(cid:4)g) ⊆ M∗i such that H(r∗i ) = {magic(q(cid:4) = Bβii (¯s−(r−(r= rB(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)Proof of (7). The equation straightforwardly follows from the fact that B+(rBhold by the construction of Mand by the initial hypothesis on the choice of r(cid:4)(cid:4)(cid:4)g) ⊆ M+(r g) = B+(r(cid:4)g)|BP , and since M ⊇ M(cid:4)g , respectively. (cid:2)(cid:4)|BP andLemma 3.24. For each stable model M of P , there is a stable model MM ⊇ M(cid:4)|BP .(cid:4)of DMS(Q, P) (which is the magic variant of M) such that(cid:4). Let NProof. After Lemma 3.23, we can show that MP))Mvariant that Mcontains only EDB facts. Suppose variantiis in turn contained in N(cid:4) ⊆ M(cid:4)(cid:4)be a minimal model of Ground(DMS(Q, P))M(cid:4)(cid:4) = variant∞Q,P (M) is also minimal over all the models of Ground(DMS(Q,. We prove by induction on the definition of the magicQ,P (M)Q,P (M) ⊆ N(cid:4)) is clearly true, since variant0Q,P (M) ⊆ Nholds as well.(cid:4). The base case (i.e., variant0(cid:4)in order to prove that varianti+1(cid:4)While considering an atom in varianti+1Q,P (M), we distinguish two cases:Q,P (M) ⊆ NQ,P (M) \ varianti(cid:4)∗∗gg) = {magic(pα(¯t))} and B(a) For a magic atom magic(pα(¯t)) in varianti+1Ground(DMS(Q, P)) having H(rnegative body and so rhypothesis and so magic(pα(¯t)) ∈ N(b) For a standard atom p(¯t) in varianti+1Q,P (M) \ variantiQ,P (M), by Definition 3.20 there must be a rule r∗+(rg) ⊆ variantiholds). We can then conclude that B(cid:4)is a model of Ground(DMS(Q, P))MQ,P (M) (we recall that magic rules have empty(cid:4)holds by the induction∈ Ground(DMS(Q, P))M(cid:4)(cid:4)(because NQ,P (M) \ varianti+(r).Q,P (M), by Definition 3.20 there is a binding α such thatQ,P (M) and the atom p(¯t) belongs to M. Assume for the sake of contradiction that p(¯t) /∈ N(cid:4).(cid:4)), we can compute the set killedMQ,P (N(cid:4)) holds (by definition). Moreover, by(cid:4)|BP holds(cid:4)|BP , and we can hence apply Theorem 3.11 in(cid:4)) and p(¯t) ∈ M.magic(pα(¯t)) ∈ variantiSince Mas introduced in Section 3.3.1 and note, in particular, that p(¯t) ∈ killedMProposition 3.17, killedMby Definition 3.20. Thus, M is a stable model for P such that M ⊇ Morder to conclude that M ∩ killedMHence, p(¯t) ∈ N. (cid:2)(cid:4)) = ∅. The latter is in contradiction with p(¯t) ∈ killedM(cid:4)) is an unfounded set for P with respect to (cid:14)Mis a model of Ground(DMS(Q, P))M(cid:4)|BP , BP (cid:15). In addition, M ⊇ Mis a model of DMS(Q, P) and N∗g) ⊆ NQ,P (NQ,P (NQ,P (NQ,P (N∈∗g(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)We can then prove the correspondence of stable models with respect to queries.Theorem 3.25. Let Q be a query for a DatalogDMS(Q, P) (which is the magic variant of M) such that M(cid:4)|Q = M|Q.∨,¬s program P . Then, for each stable model M of P , there is a stable model M(cid:4)ofProof. Let M be a stable model of P and Mmodel of DMS(Q, P) such that M ⊇ Minclusion.(cid:4) = variant(cid:4)|BP . Thus, we trivially have that M|Q ⊇ M∞Q,P (M) its magic variant. Because of Lemma 3.24, M(cid:4)is a stable(cid:4)|Q holds. We now show the reverseSince M(cid:4)is a stable model of DMS(Q, P), we can determine the set killedMDefinition 3.14 we can conclude that (a) BP |Q \ M(we recall that BP |Q denotes the ground instances of Q). Moreover, since M is a stable model of P with M ⊇ MQ,P (M(cid:4)) because M(cid:4) ⊆ killedM(cid:4)(cid:4)Q,P (M(cid:4)(cid:4)) as defined in Section 3.3.1. Hence, bycontains the magic seed by construction(cid:4)|BP176M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192(cid:4)and killedMM ∩ killedMequivalent to M|Q ⊆ MQ,P (MQ,P (M(cid:4)(cid:4)|Q. (cid:2)(cid:4)) is an unfounded set for P with respect to (cid:14)M(cid:4)) = ∅ by Theorem 3.11. Thus, by combining (a) and (b) we obtain that (BP |Q \ M(cid:4)|BP , BP (cid:15) by Proposition 3.17, we can conclude that (b)(cid:4)) ∩ M = ∅, which isFinally, we show the correctness of the Magic Set method with respect to query answering, that is, we prove that theoriginal and rewritten programs provide the same answers for the input query on all possible EDBs.Theorem 3.26. Let P be a Datalog∨,¬s program, and let Q be a query. Then DMS(Q, P) ≡bQ P and DMS(Q, P) ≡cQ P hold.facts F defined over the EDB predicates of P (and DMS(Q, P)),Proof. We want to show that,Ansb(Q, DMS(Q, P) ∪ F ) = Ansb(Q, P ∪ F ) and Ansc(Q, DMS(Q, P) ∪ F ) = Ansc(Q, P ∪ F ) hold. We first observe thatthe Magic Set rewriting does not depend on EDB facts; thus, DMS(Q, P) ∪ F = DMS(Q, P ∪ F ) holds. Moreover, note that∨,¬s programs always have stable models. Therefore, as a direct consequence of Theorem 3.19 and Theorem 3.25, weDatalogcan conclude Ansb(Q, DMS(Q, P ∪ F )) = Ansb(Q, P ∪ F ) and Ansc(Q, DMS(Q, P ∪ F )) = Ansc(Q, P ∪ F ). (cid:2)for any set of3.4. Magic Sets for stratified Datalog programs without disjunctionStratified Datalog programs without disjunction have exactly one stable model [29]. However, the Magic Set transfor-mation can introduce new dependencies between predicates, possibly resulting in unstratified programs (we refer to theanalysis in [38]). Clearly, original and rewritten programs agree on the query, as proved in the previous section, but thequestion whether the rewritten program admits a unique stable model is also important. In fact, for programs having theunique stable model property, brave and cautious reasoning coincide and a solver can immediately answer the query afterthe first (and unique) stable model is found. The following theorem states that the rewritten program of a stratified programindeed has a unique stable model.Theorem 3.27. Let P be a disjunction-free Datalog program with stratified negation and Q a query. Then DMS(Q, P) has a uniquestable model.Proof. Let M be the unique stable model of P , and MBy Lemma 3.24 we already know that MDMS(Q, P) contains Mvariant0well. Thus, while considering an atom in varianti+1Q,P (M) contains only EDB facts. Suppose variantiby induction on the structure of M(cid:4)(cid:4)is a stable model of DMS(Q, P). We now show that any stable model N∞Q,P (M) its magic variant as presented in Definition 3.20.of) is clearly true, sinceQ,P (M) ⊆ Nin order to prove that varianti+1Q,P (M) ⊆ N. The base case (variant0holds as(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)Q,P (M) ⊆ NQ,P (M) \ variantiQ,P (M), two cases are possible:(cid:4) = variant(1) For a magic atom magic(pα(¯t)) in varianti+1∗Ground(DMS(Q, P)) having H(rnegative bodies and so rhypothesis and so magic(pα(¯t)) ∈ N(2) For a standard atom p(¯t) in varianti+1∈ Ground(DMS(Q, P))N(cid:4)(cid:4)(because NQ,P (M) \ variantig) = {magic(pα(¯t))} and B∗gQ,P (M) \ variantiQ,P (M), by Definition 3.20 there must be a rule r∗+(rg) ⊆ variantiholds). We can then conclude that B(cid:4)is a model of Ground(DMS(Q, P))NQ,P (M) (we recall that magic rules have empty(cid:4)holds by the induction+(r).∗g) ⊆ N(cid:4)∈∗g(cid:4)is a stable model of DMS(Q, P), we can compute the set killedNQ,P (M), by Definition 3.20 there is a binding α such thatQ,P (M) and the atom p(¯t) belongs to M. Assume for the sake of contradiction that p(¯t) /∈ Nmagic(pα(¯t)) ∈ varianti(cid:4).(cid:4)) as introduced in Section 3.3.1 and note,Since Nin particular, that p(¯t) ∈ killedN(cid:4)) is an unfoundedQ,P (N(cid:4)|BP ,set for P with respect to (cid:14)Nwhich would mean that p(¯t) /∈ N holds. Hence, we can conclude that N and M are two different stable models of P ,obtaining a contradiction, as P has a unique stable model.Q,P (N(cid:4)|BP , BP (cid:15). In addition, by Lemma 3.25 there is a stable model N of P such that N ⊇ N(cid:4)) holds, by definition. Moreover, by Proposition 3.17, killedNQ,P (N(cid:4)(cid:4)(cid:4)Since stable models are incomparable with respect to containment, Mstable model of DMS(Q, P). (cid:2)(cid:4) ⊆ N(cid:4)implies M(cid:4) = N(cid:4). Hence, M(cid:4)is the unique4. ImplementationThe Dynamic Magic Set method (DMS) has been implemented and integrated into the core of the DLV [43] system. In thissection, we shall first briefly describe the architecture of the system and its usage. We then briefly present an optimizationfor eliminating redundant rules, which are sometimes introduced during the Magic Set rewriting.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192177Fig. 6. Prototype system architecture.4.1. System architecture and usageWe have created a prototype system by implementing the Magic Set technique described in Section 3 inside DLV, asshown in the architecture reported in Fig. 6. DLV supports both brave and cautious reasoning, and for a completely groundquery it can be also used for computing all stable models in which the query is true. DLV performs brave reasoning ifinvoked with the command-line option -FB, while -FC indicates cautious reasoning.In our prototype, the DMS algorithm is applied automatically by default when the user invokes DLV with -FB or -FCtogether with a (partially) bound query. Magic Sets are not applied by default if the query does not contain any constant.The user can modify this default behavior by specifying the command-line options -ODMS (for applying Magic Sets) or-ODMS- (for disabling Magic Sets).If a completely bound query is specified, DLV can print the magic variant of the stable model (not displaying magicpredicates), which witnesses the truth (for brave reasoning) or the falsity (for cautious reasoning) of the query, by specifyingthe command-line option - -print-model.Within DLV, DMS is applied immediately after parsing the program and the query by the Magic Set Rewriter module. Therewritten (and optimized as described in Section 4.2) program is then processed by the Intelligent Grounding module and theModel Generator module using the implementation of DLV. The only other modification is for the output and its filtering:For ground queries, the witnessing stable model is no longer printed by default, but only if - -print-model is specified,in which case the magic predicates are omitted from the output.The SIPS schema7 implemented in the prototype is as follows: For a rule r, head atom p(¯t) and binding α, ≺pα (¯t)satisfiesthe conditions of Definition 3.3, in particular p(¯t) ≺pα (¯t)b(¯z) holds for allhead or negative body atoms q(s) (cid:9)= p(¯t) and any atom b(¯z) in r. Moreover, all the positive body literals of r form a chainin ≺pα (¯t). This chain is constructed by iteratively inserting those atoms containing most bound arguments (considering α) into the chain. Among the atoms with most bindings an arbitrary processingand also the partially formed chain and f(q(¯s)) = X holds if and only if q(¯s)pα (¯t)rpα (¯t)order (usually the order appearing in the original rule body) is used. Furthermore,rbelongs to the positive body of r, has at least one bound argument and X occurs in ¯s.q(¯s) holds for all q(¯s) (cid:9)= p(¯t) in r, and q(¯s) ⊀pα (¯t)frrrr7 Since technically a SIPS has a definition for every single rule, implementations use a schema for creating the SIPS for a given rule.178M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192This means that apart from the head atom via which the rule is adorned, only positive body atoms can yield variablebindings and only if at least one of their arguments is bound, but both atoms with EDB and IDB predicates can do so.Moreover, atoms with more bound arguments will be processed before those with fewer bound arguments.Note that in this work we did not study the impact of trying different SIPS schemes, as we wanted to focus onshowing the impact that our technique can have, rather than fine-tuning its parameters. While we believe that the SIPSschema employed is well-motivated, there probably is quite a bit of room for improvement, which we leave for futurework.An executable of the DLV system supporting the Magic Set optimization is available at http://www.dlvsystem.com/magic/.4.2. Dealing with redundant rulesEven though our rewriting algorithm keeps the amount of generated rules low, it might happen that some redundantrules are generated when adorning disjunctive rules, thereby somewhat deteriorating the optimization effort. For instance, inExample 3.6 the first two modified rules are semantically equivalent, and this might happen even if the two head predicatesdiffer. In general not only duplicated rules might be created, but also rules which are logically subsumed by other rules inthe program. Let us first give the definition of subsumption for Datalog∨,¬s rules.(cid:4)Definition 4.1. Let P be a Datalogr (cid:25) rif there exists a rule r) if there exists a substitution ϑ for the variables of rsuch that r (cid:25) rprogram, and let r and r.(cid:4)(cid:4)(cid:4)∨,¬(cid:4)be two rules of P . Then, r is subsumed by r(cid:4)(denoted by(cid:4))ϑ ⊆ B(r). A rule r is redundant, such that H(r(cid:4))ϑ ⊆ H(r) and B(rIdeally, a Magic Set rewriting algorithm should be capable of identifying all the possible redundant rules and removingthem from the output. Unfortunately, this approach is unlikely to be feasible in polynomial time, given that subsumptionchecking on first-order expressions is NP-complete (problem [LO18] in [27]).Thus, in order to identify whether a rule r produced during the Magic Set transformation is redundant, we pragmati-cally apply a greedy subsumption algorithm in our implementation, for checking whether r (cid:25) r. Inparticular, the employed heuristics aims at building the substitution ϑ (as in Definition 4.1) by iteratively choosing an atomp(¯t) (which is not yet processed) from rand by matching it (if possible) with some atom of r. The greedy approach prefersthose atoms of rwith the maximum number of variables not yet matched.holds for some rule r(cid:4)(cid:4)(cid:4)(cid:4)To turn on subsumption checking (applied once after the Magic Set rewriting), DLV has to be invoked with the command-line option -ODMS+.5. Experiments on standard benchmarksWe performed several experiments for assessing the effectiveness of the proposed technique. In this section we presentthe results obtained on various standard benchmarks, most of which have been directly adopted from the literature. Furtherexperiments on an application scenario using real-world data will be discussed in detail in Section 6. We also refer to[45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoningtasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, isconfronted against other ontology systems. In both publications the impact of Magic Sets is stated explicitly.5.1. Compared methods, benchmark problems and dataIn order to evaluate the impact of the proposed method, we have compared DMS (using the SIPS defined outlinedin Section 4) both with the traditional DLV evaluation without Magic Sets and with the SMS method proposed in [33].Concerning SMS, we were not able to obtain an implementation, and have therefore performed the rewriting manually. Asa consequence, the runtime measures obtained for SMS do not contain the time needed for rewriting, while it is includedfor DMS.For the comparison, we consider the following benchmark problems. The first three of them had been already used toassess SMS in [33], to which we refer for details:• Simple Path: Given a directed graph G and two nodes a and b, does there exist a unique path connecting a to b in G?The instances are encoded by facts edge(v1, v2) for each arc (v 1, v 2) in G, while the problem itself is encoded by theprogram8sp(X, X) ∨ not_ sp(X, X) :− edge(X, Y).sp(X, Y) ∨ not_ sp(X, Y) :− sp(X, Z), edge(Z, Y).8 The first rule of the program models that for each node X of G, a unique path connecting X with itself can either exist or not.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192179Fig. 7. Instances structure of Simple Path and Related (left) and of Conformant Plan Checking (right).path(X, Y) :− sp(X, Y).path(X, Y) :− not_ sp(X, Y).not_ sp(X, Z) :− path(X, Y1), path(X, Y2), Y1 <> Y2, edge(Y1, Z), edge(Y2, Z).with the query sp(a, b). The structure of the graph, which is the same as the one reported in [33], consists of a squarematrix of nodes connected as shown in Fig. 7, and the instances have been generated by varying of the number ofnodes.• Related: Given a genealogy graph storing information about relationships (father/brother) among people and given twopeople p1 and p2, is p1 an ancestor of p2? The instances are encoded by facts related(p1, p2) when p1 is known tobe related to p2, that is, when p1 is the father or a brother of p2. The problem can be encoded by the programfather(X, Y) ∨ brother(X, Y) :− related(X, Y).ancestor(X, Y) :− father(X, Y).ancestor(X, Y) :− father(X, Z), ancestor(Z, Y).and the query is ancestor(p1, p2). The structure of the “genealogy” graph is the same as the one presented in [33]and coincides with the one used for testing Simple Path. Also in this case, the instances are generated by varying thenumber of nodes (thus the number of persons in the genealogy) of the graph.(cid:4)for some i = 1, . . . , m then ci ∈ C• Strategic Companies: This is a slight variant of the problem domain used in the running example. The description hereis of the problem as posed in the Third ASP Competition. We consider a collection C of companies, where each com-pany produces some goods in a set G and each company ci ∈ C is controlled by a set of owner companies O i ⊆ C .(cid:4) ⊂ C is a strategic set if it is a minimal set of companies producing all the goods in G,A subset of the companies Csuch that if O i ⊆ Cmust hold. As in the Second Answer Set Competition,9 weassume that each product is produced by at most four companies, and that each company is controlled by at mostfour companies (the complexity of the problem under these restrictions is as hard as without them). Given two dis-tinct companies ci, c j ∈ C , is there a strategic set of C which contains both ci and c j ? The instances are encoded byfacts produced_by(p, c1, c2, c3, c4) when product p is produced by companies c1, c2, c3, and c4; if p is producedby fewer than four companies (but at least one), then c1, c2, c3, c4 contains repetitions of companies. Moreover, factscontrolled_by(c, c1, c2, c3, c4) represent that company c is controlled by companies c1, c2, c3, and c4; again, if cis controlled by fewer than four companies, then c1, c2, c3, c4 contains repetitions. The problem can be encoded by theprogram(cid:4)st(C1) ∨ st(C2) ∨ st(C3) ∨ st(C4) :− produced_by(P, C1, C2, C3, C4).st(C) :− controlled_by(C, C1, C2, C3, C4), st(C1), st(C2), st(C3), st(C4).with the query st(ci), st(cj). While the language presented in the previous sections allowed only for one atom in aquery for simplicity, the implementation in DLV allows for a conjunction in a query; it is easy to see that a conjunctivequery can be emulated by a rule with the conjunction in the body and an atom with a new predicate in the head,which contains all body arguments, and finally replacing the query conjunction with this atom. In this case this wouldmean adding a rule q(ci, cj) :− st(ci), st(cj) and replacing the query by q(ci, cj). For this benchmark we usedthe instances submitted for the Second Answer Set Competition.9 http://www.cs.kuleuven.be/~dtai/events/ASP-competition/index.shtml.180M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192Fig. 8. Simple Path: Average execution time.• Conformant Plan Checking: In addition, we have included a benchmark problem, which highlights the fact that our MagicSet technique can yield improvements not only for the grounding, but also for the model generation phase, as discussedin Section 7. This problem is inspired by a setting in planning, in particular testing whether a given plan is conformantwith respect to a state transition diagram [30]. Such a diagram is essentially a directed graph formed of nodes repre-senting states, and in which arcs are labeled by actions, meaning that executing the action in the source state will leadto the target state. In the considered setting non-determinism is allowed, that is, executing an action in one state mightlead non-deterministically to one of several successor states. A plan is a sequence of actions, and it is conformant withrespect to a given initial state and a goal state if each possible execution of the action sequence leads to the goal state.In our benchmark, we assume that the action selection process has already been done, thus having reduced the statetransition diagram to those transitions that actually occur when executing the given plan. Furthermore we assumethat there are exactly two possible non-goal successor states for any given state. This can also be viewed as whetherall outgoing paths of a node in a directed graph reach a particular confluence node. We encoded instances by factsptrans(s0, s1, s2) meaning that one of states s1 and s2 will be reached in the plan execution starting from s0. Theproblem is encoded usingtrans(X, Y) ∨ trans(X, Z) :− ptrans(X, Y, Z).reach(X, Y) :− trans(X, Y).reach(X, Y) :− reach(X, Z), trans(Z, Y).and the query reach(0, 1), where 0 is the initial state and 1 the goal state. If the query is cautiously true, the plan isconformant. The transition graphs in our experiments have the shape of a binary tree rooted in state 0, and from eachleaf there is an arc to state 1, as depicted in Fig. 7.In addition, we have performed further experiments on an application scenario modeled from real-world data for an-swering user queries in a data integration setting. These latter experiments will be discussed in more detail in Section 6.5.2. Results and discussionThe experiments have been performed on a 3 GHz Intel® Xeon® processor system with 4 GB RAM under the Debian4.0 operating system with a GNU/Linux 2.6.23 kernel. The DLV prototype used has been compiled using GCC 4.3.3. For eachinstance, we have allowed a maximum running time of 600 seconds (10 minutes) and a maximum memory usage of 3 GB.On all considered problems, DMS outperformed SMS, even if SMS does not include the rewriting time, as discussed inSection 5.1. Let us analyze the results for each problem in more detail.The results for Simple Path are reported in Fig. 8. DLV without Magic Sets solves only the smallest instances, with a verysteep increase in execution time. SMS does better than DLV, but scales much worse than DMS. The difference between SMSand DMS is mostly due to the grounding of the additional predicates that SMS introduces.Fig. 9 reports the results for Related. Compared to Simple Path, DLV without Magic Sets exhibits an even steeper increasein runtime, while in contrast both SMS and DMS scale better than on Simple Path. Comparing SMS and DMS, we note thatDMS appears to have an exponential speedup over SMS. In this case, the computational gain of DMS over SMS is due to thedynamic optimization of the model search phase resulting from our Magic Sets definition. This aspect is better highlightedby the Conformant Plan Checking benchmark, and will be discussed later in this section.For Strategic Companies, we report the results in Fig. 10 as a bar diagram, because the instances do not have a uniformstructure. The instances are, however, ordered by size. Also here, DLV without Magic Sets is clearly the least efficient of theM. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192181Fig. 9. Related: Average execution time.Fig. 10. Strategic Companies: Average execution time.tested systems, resolving only the smallest two instances in the allotted time (600 seconds). Concerning the other systems,SMS and DMS essentially show equal performance. In fact, the situation here is quite different to Simple Path and Related,because grounding the program produced by the Magic Set rewriting takes only a negligible amount of time for SMS andDMS. For this benchmark the important feature is reducing the ground program to the part which is relevant for the query,and we could verify that the ground programs produced by SMS and DMS are precisely the same.Finally, the results for Conformant Plan Checking are shown in Fig. 11. While DLV shows a similar behavior as for SimplePath and Related, here also SMS does not scale well at all, and in fact DMS appears to have an exponential speedup overSMS. There is a precise reason for this: While the Magic Set rewriting of SMS always creates a deterministic program defin-ing the magic predicates, this is not true for DMS. As a consequence, all magic predicates are completely evaluated duringthe grounding phase of DLV for SMS, while for DMS this is not the case. At the first glance, this may seem like a disadvan-tage of DMS, as one might believe that the ground program becomes larger. However, it is actually a big advantage of DMS,because it offers a more precise identification of the relevant part of the program. Roughly speaking, whatever SMS identifiesas relevant for the query will also be identified as relevant in DMS, but DMS can also include non-deterministic relevance in-formation, which SMS cannot. This means that in DMS Magic Sets can be exploited also during the non-deterministic searchphase of DLV, dynamically disabling parts of the ground program. In particular, after having made some choices, parts ofthe program may no longer be relevant to the query, but only because of these choices, and the magic atoms present in theground program can render these parts satisfied, which means that they will no longer be considered in this part of thesearch. SMS cannot induce any behavior like this and its effect is limited to the grounding phase of DLV, which can make ahuge difference, as evidenced by Conformant Plan Checking.5.3. Experimenting DMS with other disjunctive Datalog systemsIn order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with thefollowing solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37]. ClaspD is based on advanced Boolean constraint solvingtechniques, featuring backjumping and conflict-driven learning. Cmodels is based on the definition of program completionand loop formula for disjunctive programs [40,47], and uses a SAT solver for generating candidate solutions and testing182M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192Fig. 11. Conformant Plan Checking: Average execution time.Fig. 12. Simple Path: Average execution time on other systems.them. GnT1 is based on Smodels [61], a system handling Datalog programs with unstratified negation (normal programs):A disjunctive program is translated into a normal program, the stable models of which are computed by Smodels andrepresent stable model candidates of the original program. Each of these candidates is then checked to be a stable model ofthe original program by invoking Smodels on a second normal program. GnT2 is a variant of GnT1 in which the number ofcandidates produced by the first normal program is reduced by means of additional rules that discard unsupported models,i.e., models containing some atom a for which there is no rule r such that B(r) is true and a is the only true atom in H(r).All of the benchmarks presented in the previous section were tested on these systems. Since DMS is not implementedin these systems, rewritten programs were produced by DLV during the preparation of the experiment. We recall that DMSdoes not depend on EDB relations and point out that DLV computes rewritten programs for the considered encodings in1–2 hundredths of a second. The results of our experiment are reported in Figs. 12–16. In general, we tried use a consistentscales in the graphs in order to ease comparability. However, for some graphs we chose a different scale in order to keepthem readable for the main purpose (comparing performances with and without DMS), and we mention this explicitly inthe accompanying text.Concerning Simple Path, the advantages of DMS over the unoptimized encoding are evident on all tested systems. In fact,as shown in Fig. 12, without DMS all tested systems did not answered in the allotted time (600 seconds) on instances withmore than 400 nodes (900 for Cmodels). On the other hand, all of the instances considered in the benchmark (up to 40thousands of nodes) were solved by all tested solvers with the DMS encoding. We also observe that with DMS the testedsystems are faster than DLV in this benchmark, which is a clear indication of the optimization potential that can be providedto these systems by our Magic Set technique.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192183Fig. 13. Related: Average execution time on other systems.For Related we obtained a similar result, reported in Fig. 13 (we used a different scale for the y-axis for Cmodels forreadability). Without DMS only the smallest instances were solved in the allotted time (up to 2025 nodes for ClaspD andCmodels, up to 625 nodes for GnT1 and GnT2). With DMS, instead, all tested systems solved the biggest instances of thebenchmark (up to 10 thousands of nodes). In particular, with DMS Cmodels is as performant as dlv in this benchmark.The effectiveness of DMS is also evident in the Strategic Companies benchmark (Figs. 14–15). In fact, we observed sensibleperformance gains of all systems on all tested instances. GnT1, which is already faster than the other tested systems in thisbenchmark, draws particular advantage from DMS, solving all instances in few seconds. We give another evidence of theoptimization potential provided by DMS to these systems by comparing the number of solved instances: Of a total of 60tests, we counted 37 timeouts on the unoptimized encoding (10 on ClaspD, 14 on Cmodels, 3 on GnT1 and 10 on GnT2),while just one on the encoding obtained by applying DMS. We point out that the timeout on the rewritten program wasobtained by the Cmodels system, which alone collected 14 timeouts on the unoptimized encoding and is thus the leastperformant on this benchmark.Finally, consider the results for Conformant Plan Checking reported in Fig. 16 (we used a different scale on the y-axis forClaspD for readability; note also that ClaspD and GnT2 only solved the smallest instances of this benchmark, and we thusused a different scale for their x-axes). The performance of ClaspD is poor in this benchmark, nonetheless we observed aslight improvement in execution time if DMS is applied on the encoding reported in Section 5.1. Cmodels performs betterthan ClaspD in this case and the optimization potential of DMS emerges with an exponential improvement in performance.A similar result was observed for GnT1, while GnT2 on this benchmark is the only outlier of the experiment: Its performancedeteriorates if the original program is processed by DMS. However, in this benchmark GnT2 performs worse that GnT1also with the original encoding. In fact, while GnT1 solved the biggest instance (more than 65 thousands of states) in209.74 seconds (12.28 seconds with the DMS encoding), the execution of GnT2 did not terminate in the allotted time(600 seconds) on instances containing more than 10 thousands of states. We finally note that with DMS GnT1 and Cmodelsare faster than DLV in this benchmark. In fact, for the biggest instance in the benchmark, GnT1 and Cmodels required 12.28and 19.13 seconds, respectively, while DLV terminated in 279.41 seconds. The significant performance gain of GnT1 andCmodels due to DMS is a further confirmation of the potential of our optimization technique.6. Application to data integrationIn this section we give a brief account of a case study that evidences the impact of the Magic Set method when usedon programs that realize data integration systems. We first give an overview of data integration systems, show how they∨,¬s , and finally assess the impact of Magic Sets on a data integration system involvingcan be implemented using Datalogreal-world data.6.1. Data integration systems in a nutshellThe main goal of data integration systems is to offer transparent access to heterogeneous sources by providing userswith a global schema, which users can query without having to know from what sources the data come from. In fact, it isthe task of the data integration system to identify and access the data sources which are relevant for finding the answer184M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192Fig. 14. Strategic Companies: Average execution time on other systems (part 1).to a query over the global schema, followed by a combination of the data thus obtained. The data integration system usesa set of mapping assertions, which specify the relationship between the data sources and the global schema. Following [41],we formalize a data integration system I as a triple (cid:14)G, S, M(cid:15), where:(1) G is the global (relational) schema, that is, a pair (cid:14)Ψ, Σ(cid:15), where Ψ is a finite set of relation symbols, each with anassociated positive arity, and Σ is a finite set of integrity constraints (ICs) expressed on the symbols in Ψ . ICs arefirst-order assertions that are intended to be satisfied by database instances.(2) S is the source schema, constituted by the schemes of the various sources that are part of the data integration system.We assume that S is a relational schema of the form S = (cid:14)Ψ (cid:4), ∅(cid:15), which means that there are no integrity constraints onthe sources. This assumption implies that data stored at the sources are locally consistent; this is a common assumptionin data integration, because sources are in general external to the integration system, which is not in charge of analyzingor restoring their consistency.(3) M is the mapping which establishes the relationship between G and S. In our framework, the mapping follows theGAV approach, that is, each global relation is associated with a view—a Datalog∨,¬s query over the sources.The main semantic issue in data integration systems is that, since integrated sources are originally autonomous, theirdata, transformed via the mapping assertions, may not satisfy the constraints of the global schema. An approach to remedyto this problem that has lately received a lot of interest in the literature (see, e.g., [3,11,12,14,16–19,25,26]) is based onthe notion of repair for an inconsistent database as introduced in [4]. Roughly speaking, a repair of a database is a newdatabase that satisfies the constraints in the schema, and minimally differs from the original one. Since an inconsistentdatabase might possess multiple repairs, the standard approach in answering user queries is to return those answers thatare true in every possible repair. These are called consistent answers in the literature.6.2. Consistent query answering via Datalog∨,¬s queriesThere is an intuitive relation between consistent answers to queries over data integration systems and queries over∨,¬s∨,¬s programs: Indeed, if one could find a translation from data sources, mapping, and the query to a DatalogDatalogM. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192185Fig. 15. Strategic Companies: Average execution time on other systems (part 2).Fig. 16. Conformant Plan Checking: Average execution time on other systems.186M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192program, which possesses a stable model for each possible repair, and a query over it, the consistent answers within thedata integration system will correspond to cautious consequences of the obtained Datalog∨,¬s setting.In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the constraints of the global schema G intovarious kinds of logic programs, such that the stable models of this program yield the repairs of the database retrieved fromthe sources. Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalogprograms together with unstratified negation have been considered in [13,51].It has already been realized earlier that Magic Sets are a crucial optimization technique in this context, and indeed theavailability of the transformational approach using stable logic programming as its core language was a main motivation forthe research presented in this article, since in this way a Magic Set method for stable logic programs immediately yieldsan optimization technique for data integration systems. Indeed, the benefits of Magic Sets in the context of optimizing logicprograms with unstratified negation (but without disjunction) have been discussed in [24]. The Magic Set technique definedin [24] is quite different from the one defined in this article, as it does not consider disjunctive rules, and works onlyfor programs, which are consistent, that is, have at least one stable model. In [51] our preliminary work reported in [20],which eventually led to the present article, has been expanded in an ad-hoc way to particular kinds of Datalog programswith disjunction and unstratified negation. It is ad-hoc in the sense that it is tailored to programs which are created bythe transformation described in [51]. The experimental results reported in [51] show huge computational advantages whenusing Magic Sets.We now report an alternative transformation which produces Datalog∨,¬s programs (therefore different to [51], thereare no unstratified occurrences of negation). This rewriting has been devised and used within the INFOMIX system on dataintegration [42].Let I = (cid:14)G, S, M(cid:15) be a data integration system where G = (cid:14)Ψ, Σ(cid:15), and let D be a database for G, which is representedas a set of facts over the relational predicates in G. We assume that constraints over the global schema are key and exclusiondependencies. In particular, we recall that a set of attributes ¯x is a key for the relation r if:(cid:2)(cid:3)r(¯x, ¯y) ∧ r(¯x, ¯z)→ ¯y = ¯z, ∀(cid:6)(cid:4)r(¯x, ¯y), r(¯x, ¯z)⊆ Dand that an exclusion dependency holds between a set of attributes ¯x of a relation r and a set of attributes ¯w of a relations if(cid:2)(cid:3)r(¯x, ¯y) ∧ s( ¯w, ¯z)→ ¯y (cid:9)= ¯z, ∀(cid:6)(cid:4)r(¯x, ¯y), s( ¯w, ¯z)⊆ DThen, the disjunctive rewriting of a query q with respect to I is the Datalog∨,¬s program Π(I) = ΠKD ∪ ΠED ∪ ΠM ∪ Πcollwhere:• For each relation r in G and for each key defined over its set of attributes ¯x, ΠKD contains the rules:rout(¯x, ¯y) ∨ rout(¯x, ¯z) :− rD(¯x, ¯y), rD(¯x, ¯z), Y 1 (cid:9)= Z1....rout(¯x, ¯y) ∨ rout(¯x, ¯z) :− rD(¯x, ¯y) , rD(¯x, ¯z), Ym (cid:9)= Zm.where ¯y = Y 1, . . . , Ym, and ¯z = Z1, . . . , Zm.• For each exclusion dependency between a set of attributes ¯x of a relation r and a set of attributes ¯w of a relation s,ΠED contains the following rule:rout(¯x, ¯y) ∨ sout( ¯w, ¯z) :− rD(¯x, ¯y), sD( ¯w, ¯z), X1 = W 1, . . . , Xm = W m.where ¯x = X1, . . . , Xm, and ¯w = W 1, . . . , W m. In the implementation the following equivalent rule is used:rout(¯x, ¯y) ∨ sout(¯x, ¯z) :− rD(¯x, ¯y), sD(¯x, ¯z).• For each relation r in G, Πcoll contains the rule:r( ¯w) :− rD( ¯w), not rout( ¯w).• For each Datalog rule r in M such that:k(¯t) :− q1(¯s1), . . . , qm(¯sm).where k is a relation in G and qi (for 1 (cid:4) i (cid:4) m) is a relation in S, ΠM contains the rule:kD(¯t) :− q1(¯s1), . . . , qm(¯sm).M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192187Fig. 17. Average execution time of query evaluation in the INFOMIX Demo Scenario.It can be shown that for each user query Q (over G) and for each source database F (over S), consistent query answersto Q precisely coincide with the set Ansc(Q, Π (I) ∪ F ). Actually, within the INFOMIX project also inclusion dependencieshave been considered according to the rewriting discussed in [16], whose details we omit for clarity. Since the rewritingfor inclusion dependencies also modifies queries, in the INFOMIX project queries have been limited to conjunctive queries.∨,¬sIt is however important to notice that the program Π(I) contains only stratified negation and is therefore a Datalogprogram, making the Magic Set method defined in this article applicable.6.3. Experimental resultsThe effectiveness of the Magic Set method in this crucial application context has then been assessed via a number ofexperiments carried out on the demonstration scenario of the INFOMIX project, which refers to the information system ofthe University “La Sapienza” in Rome. The global schema consists of 14 global relations with 29 constraints, while the datasources include 29 relations of 3 legacy databases and 12 wrappers generating relational data from web pages. This amountsto more than 24 MB of data regarding students, professors and exams in several faculties of the university. For a detaileddescription of the INFOMIX project see https://www.mat.unical.it/infomix/.On this schema, we have tested five typical queries with different characteristics, which model different use cases. Forthe sake of completeness, the full encodings of the tested queries are reported in Appendix A. In particular, we measuredthe average execution time of DLV computing Ansc(Q, Π (I) ∪ F ) and Ansc(Q, DMS(Q, Π (I)) ∪ F ) on datasets of increasingsize. The experiments were performed by running the INFOMIX prototype system on a 3 GHz Intel® Xeon® processorsystem with 4 GB RAM under the Debian 4.0 operating system with a GNU/Linux 2.6.23 kernel. The DLV prototype usedas the computational core of the INFOMIX system had been compiled using GCC 4.3.3. For each instance, we allowed amaximum running time of 10 minutes and a maximum memory usage of 3 GB.The results, reported in Fig. 17, confirm that on these typical queries the performance is considerably improved by MagicSets. On Queries 1 to 4 in Fig. 17 the response time scales much better with Magic Sets than without, appearing essentiallylinear on the tested instance sizes, while without Magic Sets the behavior has a decidedly non-linear appearance. We alsoobserve that there is basically no improvement on Query 5. We have analyzed this query and for this use case all data188M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192seems to be relevant to the query, which means that Magic Sets cannot have any positive effect. It is however important toobserve that the Magic Set rewriting does not incur any significant overhead.7. Related workIn this section we first discuss the main body of work which is related to DMS, the technique developed in this paperfor query answering optimization. In particular, we discuss Magic Set techniques for Datalog languages. The discussion isstructured in paragraphs grouping techniques which cover the same language. After that, we discuss some applications forwhich DMS have already been exploited. All these applications refer to the preliminary work published in [20].Magic Sets for Datalog. In order to optimize query evaluation in bottom–up systems, like deductive database systems,several works have proposed the simulation of top–down strategies by means of suitable transformations introducing newpredicates and rewriting clauses. Among them, Magic Sets for Datalog queries are one of the best-known logical optimizationtechniques for database systems. The method, first developed in [6], has been analyzed and refined by many authors; see,for instance, [9,55,62,63]. These works form the foundations of DMS.¬s . Many authors have addressed the issue of extending the Magic Set technique in order to dealMagic Sets for Datalog¬swith Datalog queries involving stratified negation. The main problem related to the extension of the technique to Datalog¬s programs have a natural andprograms is how to assign a semantics to the rewritten programs. Indeed, while Datalogaccepted semantics, namely the perfect model semantics [2,64], the application of Magic Sets can introduce unstratifiednegation in the rewritten programs. A solution has been presented in [10,38,39,59]. In particular, in [38,59] rewritten pro-programs whichgrams have been evaluated according to the well-founded semantics, a three-valued semantics for Datalogis two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined. All of these methods exploit a¬s which is not present in disjunctive Datalog, uniqueness of the intended model. This property in turnproperty of Datalogimplies that query answering just consists in establishing the truth value of some atoms in one intended model. Using ourterminology, brave and cautious reasoning coincide for these programs. Therefore, all these methods are quite different fromDMS, the technique developed in this paper.¬¬¬¬. Extending the Magic Set technique to Datalogprograms must face two major difficulties. First,Magic Sets for Datalogprogram uniqueness of the intended model is no more guaranteed, thus query answering in this settingfor a Dataloginvolves a set of stable models in general. The second difficulty is that parts of a Datalogprogram may act as constraints,programs has beenthus impeding a relevant interpretation to be a stable model. In [24] a Magic Set method for Datalogdefined and proved to be correct for coherent programs, i.e., programs admitting at least one stable model. This methodtakes special precautions for relevant parts of the program that act as constraints, called dangerous rules in [24]. We observe∨,¬s programs, which allows for the simpler DMS algorithm to work correctlythat dangerous rules cannot occur in Datalogfor this class of programs.¬¬∨. The first extension of the Magic Set technique to disjunctive Datalog is due to [32,33], where theMagic Sets for DatalogSMS method has been presented and proved to be correct for Datalogprograms. We point out that the main drawback ofthis method is the introduction of collecting predicates. Indeed, magic and collecting predicates of SMS have deterministicdefinitions. As a consequence, their extension can be completely computed during program instantiation, which means thatno further optimization is provided for the subsequent stable model search. Moreover, while the correctness of DMS has∨,¬s programs has onlybeen formally established for Datalogbeen outlined in [32,33].∨,¬s programs in general, the applicability of SMS to Datalog∨Applications. Magic Sets have been applied in many contexts. In particular, [13,36,51,53] have profitably exploited theoptimization provided by DMS. In particular, in [13,51] a data integration system has been presented. The system is basedon disjunctive Datalog and exploits DMS for fast query answering. In [36,53], instead, an algorithm for answering queriesover description logic knowledge bases has been presented. More specifically, the algorithm reduces a SHIQ knowledgebase to a disjunctive Datalog program, so that DMS can be exploited for query answering optimization.8. ConclusionThe Magic Set method is one of the best-known techniques for the optimization of positive recursive Datalog programsdue to its efficiency and its generality. Just a few other focused methods such as the supplementary Magic Set and otherspecial techniques for linear and chain queries have gained similar visibility (see, e.g., [34,56,63]). After seminal papers[6,9], the viability of the approach was demonstrated e.g., in [35,55]. Later on, extensions and refinements were proposed,addressing e.g., query constraints in [62], the well-founded semantics in [38], or integration into cost-based query optimiza-tion in [60]. The research on variations of the Magic Set method is still going on. For instance, in [24] an extension of theMagic Set method was discussed for the class of unstratified logic programs (without disjunction). In [10] a technique forthe class of soft-stratifiable programs was given. Finally, in [33] the first variant of the technique for disjunctive programs(SMS) was described.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192189In this paper, we have elaborated on the issues addressed in [32,33]. Our approach is similar to SMS, but differs inseveral respects:• DMS is a dynamic optimization of query answering, in the sense that in addition to the optimization of the groundingprocess (which is the only optimization performed by SMS), DMS can drive the model generation phase by dynamicallydisabling parts of the program that become irrelevant in the considered partial interpretations.• DMS has a strong relationship with unfounded sets, allowing for a clean application to disjunctive Datalog programsalso in presence of stratified negation.• DMS can be further improved by performing a subsequent subsumption check.• DMS is integrated into the DLV system [43], profitably exploiting the DLV internal data-structures and the ability ofcontrolling the grounding module.We have conducted experiments on several benchmarks, many of which taken from the literature. The results of ourexperimentation evidence that our implementation outperforms SMS in general, often by an exponential factor. This ismainly due to the optimization of the model generation phase, which is specific to our Magic Set technique. In addition, wehave conducted further experiments on a real application scenario, which show that Magic Sets can play a crucial role inoptimizing consistent query answering over inconsistent databases. Importantly, other authors have already recognized thebenefits of our optimization strategies with respect to this very important application domain [51], thereby confirming thevalidity and the robustness of the work discussed in this paper.We conclude by observing that it has been noted in the literature (e.g., in [38]) that in the non-disjunctive case memoingtechniques lead to similar computations as evaluations after Magic Set transformations. Also in the disjunctive case suchtechniques have been proposed (e.g., Hyper Tableaux [8]), for which similar relations might hold. While [38] has alreadyevidenced that an advantage of Magic Sets over such methods is that they may be more easily combined with otheroptimization techniques, we believe that achieving a deeper comprehension of the relationships among these techniquesconstitutes an interesting avenue for further research.Another issue that we leave for future work is to study the impact of changing some parameters of the DMS method, inparticular the impact of different SIPSes.Appendix A. Queries on the INFOMIX demo scenarioINFOMIX is a project that was funded by the European Commission in its Information Society Technologies track of theSixth Framework Programme for providing an advanced system for information integration. A detailed description of thecourseD(X1, X2) : − esame(_, X1, X2, _).courseD(X1, X2) : − esame_diploma(X1, X2).exam_recordD(X1, X2, Z, W, X4, X5, Y) : − affidamenti_ing_informatica(X2, X3, Y),dati_esami(X1, _, X2, X5, X4, _, Y), dati_professori(X3, Z, W).exam_recordout(X1, X2, X3, X4, Y5, Y6, Y7) ∨ exam_recordout(X1, X2, X3, X4, Z5, Z6, Z7) : −exam_recordD(X1, X2, X3, X4, Y5, Y6, Y7), exam_recordD(X1, X2, X3, X4, Z5, Z6, Z7), Y5 (cid:9)= Z5.exam_recordout(X1, X2, X3, X4, Y5, Y6, Y7) ∨ exam_recordout(X1, X2, X3, X4, Z5, Z6, Z7) : −exam_recordD(X1, X2, X3, X4, Y5, Y6, Y7), exam_recordD(X1, X2, X3, X4, Z5, Z6, Z7), Y6 (cid:9)= Z6.exam_recordout(X1, X2, X3, X4, Y5, Y6, Y7) ∨ exam_recordout(X1, X2, X3, X4, Z5, Z6, Z7) : −exam_recordD(X1, X2, X3, X4, Y5, Y6, Y7), exam_recordD(X1, X2, X3, X4, Z5, Z6, Z7), Y7 (cid:9)= Z7.course(X1, X2) : − courseD(X1, X2), not courseout(X1, X2).exam_record(X1, X2, X3, X4, X5, X6, X7) : − exam_recordD(X1, X2, X3, X4, X5, X6, X7),not exam_recordout(X1, X2, X3, X4, X5, X6, X7).query1(CD) : − course(C, CD), exam_record(“09089903", C, _, _, _, _, _).query1(CD)?studentD(X1, X2, X3, X4, X5, X6, X7) : − diploma_maturita(Y, X7),studente(X1, X3, X2, _, _, _, _, _, _, _, _, _, X6, X5, _, _, X4, _, _, _, _, Y, _).student(X1, X2, X3, X4, X5, X6, X7) : − studentD(X1, X2, X3, X4, X5, X6, X7),not studentout(X1, X2, X3, X4, X5, X6, X7).query2(SFN, SLN, COR, ADD, TEL, HSS) : − student(“09089903", SFN, SLN, COR, ADD, TEL, HSS).query2(SFN, SLN, COR, ADD, TEL, HSS)?studentD(X1, X2, X3, X4, X5, X6, X7) : − diploma_maturita(Y, X7),studente(X1, X3, X2, _, _, _, _, _, _, _, _, _, X6, X5, _, _, X4, _, _, _, _, Y, _).student_course_planD(X1, X2, X3, X4, X5) : − orientamento(Y1, X3),piano_studi(X1, X2, Y1, X4, Y2, _, _, _, _, _), stato(Y2, X5).student(X1, X2, X3, X4, X5, X6, X7) : − studentD(X1, X2, X3, X4, X5, X6, X7),not studentout(X1, X2, X3, X4, X5, X6, X7).student_course_plan(X1, X2, X3, X4, X5) : − student_course_planD(X1, X2, X3, X4, X5),not student_course_planout(X1, X2, X3, X4, X5).query3(SID, SLN, R) : − student(SID, “ZNEPB", SLN, _, _, _, _),student_course_plan(_, SID, _, R, “APPROVATO SENZA MODIFICHE").query3(SID, SLN, R)?Fig. A.1. INFOMIX Queries 1–3.190M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192studentD(X1, X2, X3, X4, X5, X6, X7) : − diploma_maturita(Y, X7),studente(X1, X3, X2, _, _, _, _, _, _, _, _, _, X6, X5, _, _, X4, _, _, _, _, Y, _).courseD(X1, X2) : − esame(_, X1, X2, _).courseD(X1, X2) : − esame_diploma(X1, X2).student_course_planD(X1, X2, X3, X4, X5) : − orientamento(Y1, X3),piano_studi(X1, X2, Y1, X4, Y2, _, _, _, _, _), stato(Y2, X5).plan_dataD(X1, X2, X3) : − dati_piano_studi(X1, X2, _),esame_ingegneria(X2, Y3, Y2, _), tipo_esame(Y2, X3).student(X1, X2, X3, X4, X5, X6, X7) : − studentD(X1, X2, X3, X4, X5, X6, X7),not studentout(X1, X2, X3, X4, X5, X6, X7).student_course_plan(X1, X2, X3, X4, X5) : − student_course_planD(X1, X2, X3, X4, X5)not student_course_planout(X1, X2, X3, X4, X5).plan_data(X1, X2, X3) : − plan_dataD(X1, X2, X3), not plan_dataout(X1, X2, X3).course(X1, X2) : − courseD(X1, X2), not courseout(X1, X2).query4(F, S) : − course(CID, “RETILOGICHE"), plan_data(SCID, CID, _),student(SID, F, S, “ROMA", _, _, _), student_course_plan(SCID, SID, _, _, _).query4(F, S)?courseD(X1, X2) : − esame(_, X1, X2, _).courseD(X1, X2) : − esame_diploma(X1, X2).student_course_planD(X1, X2, X3, X4, X5) : − orientamento(Y1, X3),piano_studi(X1, X2, Y1, X4, Y2, _, _, _, _, _), stato(Y2, X5).plan_dataD(X1, X2, X3) : − dati_piano_studi(X1, X2, _),esame_ingegneria(X2, Y3, Y2, _), tipo_esame(Y2, X3).student_course_plan(X1, X2, X3, X4, X5) : − student_course_planD(X1, X2, X3, X4, X5),not student_course_planout(X1, X2, X3, X4, X5).plan_data(X1, X2, X3) : − plan_dataD(X1, X2, X3), not plan_dataout(X1, X2, X3).course(X1, X2) : − courseD(X1, X2), not courseout(X1, X2).query5(D) : − course(E, D), plan_data(C, E, _), student_course_plan(C, “09089903", _, _, _).query5(D)?Fig. A.2. INFOMIX Queries 4–5.project, including references in the literature, can be found at https://www.mat.unical.it/infomix/. Five typical queries of theINFOMIX demo scenario have been considered for assessing Dynamic Magic Sets. The full encodings of the tested queriesare reported in Figs. A.1–A.2. Note that the encodings include the transformation described in Section 6, and that underlinedpredicates denote source relations.References[1] Serge Abiteboul, Richard Hull, Victor Vianu, Foundations of Databases, Addison–Wesley, 1995.[2] Krzysztof R. Apt, Howard A. Blair, Adrian Walker, Towards a Theory of Declarative Knowledge, in: Minker [52], pp. 89–148.[3] Marcelo Arenas, Leopoldo Bertossi, Jan Chomicki, Scalar aggregation in fd-inconsistent databases, in: International Conference on Database Theory(ICDT-2001), Springer-Verlag, 2001, pp. 39–53.[4] Marcelo Arenas, Leopoldo E. Bertossi, Jan Chomicki, Consistent query answers in inconsistent databases, in: Proc. of the 18th ACM SIGACT SIGMODSIGART Symp. on Principles of Database Systems (PODS’99), 1999, pp. 68–79.[5] Marcelo Arenas, Leopoldo E. Bertossi, Jan Chomicki, Specifying and querying database repairs using logic programs with exceptions, in: Proc. of the4th Int. Conf. on Flexible Query Answering Systems (FQAS 2000), Springer, 2000, pp. 27–41.[6] François Bancilhon, David Maier, Yehoshua Sagiv, Jeffrey D. Ullman, Magic sets and other strange ways to implement logic programs, in: Proc. Int.Symposium on Principles of Database Systems, 1986, pp. 1–16.[7] Pablo Barceló, Leopoldo Bertossi, Repairing databases with annotated predicate logic, in: Proc. the 10th Int. Workshop on Non-Monotonic Reasoning(NMR 2002), 2002, pp. 160–170.[8] Peter Baumgartner, Ulrich Furbach, Ilkka Niemelä, Hyper tableaux, in: Proceedings of the European Workshop on Logics in Artificial Intelligence(JELIA’96), in: LNCS, vol. 1126, Springer, 1996, pp. 1–17.[9] Catriel Beeri, Raghu Ramakrishnan, On the power of magic, Journal of Logic Programming 10 (1–4) (1991) 255–259.[10] Andreas Behrend, Soft stratification for magic set based query evaluation in deductive databases, in: PODS’03: Proceedings of the Twenty-Second ACMSIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, ACM, New York, NY, USA, 2003, pp. 102–110.[11] Leo Bertossi, Jan Chomicki, Query answering in inconsistent databases, in: J. Chomicki, R. van der Meyden, G. Saake (Eds.), Logics for Emerging Appli-cations of Databases, Springer-Verlag, 2003, pp. 43–83, Chapter 2.[12] Leopoldo Bertossi, Jan Chomicki, Alvaro Cortes, Claudio Gutierrez, Consistent answers from integrated data sources, in: Proc. of the 6th Int. Conf. onFlexible Query Answering Systems (FQAS 2002), 2002, pp. 71–85.[13] Leopoldo E. Bertossi, Loreto Bravo, Consistent query answers in virtual data integration systems, in: Inconsistency Tolerance, in: LNCS, vol. 3300,Springer, 2005, pp. 42–83.[14] Loreto Bravo, Leopoldo Bertossi, Logic programming for consistently querying data integration systems, in: Proc. of the 18th Int. Joint Conf. on ArtificialIntelligence (IJCAI 2003), 2003, pp. 10–15.[15] Marco Cadoli, Thomas Eiter, Georg Gottlob, Default logic as a query language, IEEE Transactions on Knowledge and Data Engineering 9 (3) (May/June1997) 448–463.[16] Andrea Calì, Domenico Lembo, Riccardo Rosati, Query rewriting and answering under constraints in data integration systems, in: Proc. of the 18th Int.Joint Conf. on Artificial Intelligence (IJCAI 2003), 2003, pp. 16–21.[17] Jan Chomicki, Jerzy Marcinkowski, Minimal-change integrity maintenance using tuple deletions, Information and Computation 197 (1–2) (2005) 90–121.[18] Jan Chomicki, Jerzy Marcinkowski, Slawomir Staworko, Computing consistent query answers using conflict hypergraphs, in: Proc. 13th ACM Conferenceon Information and Knowledge Management (CIKM-2004), ACM Press, 2004, pp. 417–426.M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192191[19] Jan Chomicki, Jerzy Marcinkowski, Slawomir Staworko, Hippo: A system for computing consistent answers to a class of SQL queries, in: Elisa Bertino,Stavros Christodoulakis, Dimitris Plexousakis, Vassilis Christophides, Manolis Koubarakis, Klemens Böhm, Elena Ferrari (Eds.), 9th International Confer-ence on Extending Database Technology (EDBT-2004), in: Lecture Notes in Computer Science, vol. 2992, Springer, 2004, pp. 841–844.[20] Chiara Cumbo, Wolfgang Faber, Gianluigi Greco, Nicola Leone, Enhancing the magic-set method for disjunctive datalog programs, in: Proceedings ofthe 20th International Conference on Logic Programming – ICLP’04, in: Lecture Notes in Computer Science, vol. 3132, 2004, pp. 371–385.[21] Christian Drescher, Martin Gebser, Torsten Grote, Benjamin Kaufmann, Arne König, Max Ostrowski, Torsten Schaub, Conflict-driven disjunctive answerset solving, in: Gerhard Brewka, Jérôme Lang (Eds.), Proceedings of the Eleventh International Conference on Principles of Knowledge Representationand Reasoning (KR 2008), AAAI Press, Sydney, Australia, 2008, pp. 422–432.[22] Thomas Eiter, Georg Gottlob, Heikki Mannila, Disjunctive Datalog, ACM Transactions on Database Systems 22 (3) (September 1997) 364–418.[23] Wolfgang Faber, Enhancing efficiency and expressiveness in answer set programming systems, PhD thesis, Institut für Informationssysteme, TechnischeUniversität Wien, 2002.[24] Wolfgang Faber, Gianluigi Greco, Nicola Leone, Magic sets and their application to data integration, Journal of Computer and System Sciences 73 (4)(2007) 584–609.[25] Ariel Fuxman, Elham Fazli, Renée J. Miller Conquer, Efficient management of inconsistent databases, in: SIGMOD Conference, 2005.[26] Ariel Fuxman, Renée J. Miller, First-order query rewriting for inconsistent databases, in: Thomas Eiter, Leonid Libkin (Eds.), Proceedings of the 10thInternational Conference on Database Theory (ICDT 2005), in: LNCS, vol. 3363, Springer, 2005, pp. 337–351.[27] Michael R. Garey, David S. Johnson, Computers and Intractability, A Guide to the Theory of NP-Completeness, W.H. Freeman and Company, 1979.[28] Martin Gebser, Torsten Schaub, Sven Thiele, Gringo: A new grounder for answer set programming, in: Chitta Baral, Gerhard Brewka, John Schlipf(Eds.), Logic Programming and Nonmonotonic Reasoning – 9th International Conference, LPNMR’07, in: Lecture Notes in Computer Science, vol. 4483,Springer-Verlag, Tempe, Arizona, May 2007, pp. 266–271.[29] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: Logic Programming: Proceedings Fifth Int. Conference and Symposium,MIT Press, Cambridge, MA, 1988, pp. 1070–1080.[30] R. Goldman, M. Boddy, Expressive planning and explicit knowledge, in: Proceedings AIPS-96, AAAI Press, 1996, pp. 110–117.[31] Gianluigi Greco, Sergio Greco, Ester Zumpano, A logic programming approach to the integration, repairing and querying of inconsistent databases, in:Proc. of the 17th Int. Conf. on Logic Programming (ICLP’01), in: Lecture Notes in Artificial Intelligence, vol. 2237, Springer, 2001, pp. 348–364.[32] Sergio Greco, Optimization of Disjunction Queries, in: Danny De Schreye (Ed.), Proceedings of the 16th International Conference on Logic Programming(ICLP’99), The MIT Press, Las Cruces, New Mexico, USA, November 1999, pp. 441–455.[33] Sergio Greco, Binding propagation techniques for the optimization of bound disjunctive queries, IEEE Transactions on Knowledge and Data Engineer-ing 15 (2) (March/April 2003) 368–385.[34] Sergio Greco, Domenico Saccà, Carlo Zaniolo, The PushDown method to optimize chain logic programs, in: Proc. Int. Colloquim on Automata, Languagesand Programming, 1995, pp. 523–534 (extended abstract).[35] Ashish Gupta, Inderpal Singh Mumick, Magic-sets transformation in nonrecursive systems, in: Proceedings of the Thirteenth ACM SIGACT SIGMOD-SIGART Symposium on Principles of Database Systems (PODS-92), 1992, pp. 354–367.[36] Ullrich Hustadt, Boris Motik, Ulrike Sattler, Reasoning in description logics by a reduction to disjunctive datalog, Journal of Automated Reasoning 39 (3)(2007) 351–384.[37] Tomi Janhunen, Ilkka Niemelä, Dietmar Seipel, Patrik Simons, Jia-Huai You, Unfolding partiality and disjunctions in stable model semantics, ACMTransactions on Computational Logic 7 (1) (January 2006) 1–37.[38] David B. Kemp, Divesh Srivastava, Peter J. Stuckey, Bottom–up evaluation and query optimization of well-founded models, Theoretical Computer Sci-ence 146 (July 1995) 145–184.[39] Jean-Marc Kerisit, Jean-Marc Pugin, Efficient query answering on stratified databases, in: FGCS, 1988, pp. 719–726.[40] Joohyung Lee, Vladimir Lifschitz, Loop formulas for disjunctive logic programs, in: Proceedings of the Nineteenth International Conference on LogicProgramming (ICLP-03), Springer-Verlag, December 2003.[41] Maurizio Lenzerini, Data integration: A theoretical perspective, in: Proc. of the 21st ACM SIGACT SIGMOD SIGART Symp. on Principles of DatabaseSystems (PODS 2002), 2002, pp. 233–246.[42] Nicola Leone, Georg Gottlob, Riccardo Rosati, Thomas Eiter, Wolfgang Faber, Michael Fink, Gianluigi Greco, Giovambattista Ianni, Edyta Kałka, DomenicoLembo, Maurizio Lenzerini, Vincenzino Lio, Bartosz Nowicki, Marco Ruzzi, Witold Staniszkis, Giorgio Terracina, The INFOMIX system for advancedintegration of incomplete and inconsistent data, in: Proceedings of the 24th ACM SIGMOD International Conference on Management of Data (SIGMOD2005), ACM Press, Baltimore, Maryland, USA, June 2005, pp. 915–917.[43] Nicola Leone, Gerald Pfeifer, Wolfgang Faber, Thomas Eiter, Georg Gottlob, Simona Perri, Francesco Scarcello, The DLV system for knowledge represen-tation and reasoning, ACM Transactions on Computational Logic 7 (3) (July 2006) 499–562.[44] Nicola Leone, Pasquale Rullo, Francesco Scarcello, Disjunctive stable models: Unfounded sets, fixpoint semantics and computation, Information andComputation 135 (2) (June 1997) 69–112.[45] Senlin Liang, Paul Fodor, Hui Wan, Michael Kifer, OpenRuleBench: An analysis of the performance of rule engines, in: Juan Quemada, Gonzalo León,Yoëlle S. Maarek, Wolfgang Nejdl (Eds.), Proceedings of the 18th International Conference on World Wide Web (WWW 2009), ACM, 2009, pp. 601–610.[46] Yuliya Lierler, Disjunctive answer set programming via satisfiability, in: Chitta Baral, Gianluigi Greco, Nicola Leone, Giorgio Terracina (Eds.), LogicProgramming and Nonmonotonic Reasoning – 8th International Conference, LPNMR’05, Diamante, Italy, September 2005, Proceedings, in: LectureNotes in Computer Science, vol. 3662, Springer-Verlag, September 2005, pp. 447–451.[47] Fangzhen Lin, Yuting Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, in: Proceedings of the Eighteenth National Conferenceon Artificial Intelligence (AAAI-2002), AAAI Press/MIT Press, Edmonton, Alberta, Canada, 2002.[48] Jorge Lobo, Jack Minker, Arcot Rajasekar, Foundations of Disjunctive Logic Programming, The MIT Press, Cambridge, MA, 1992.[49] Marco Manna, Massimo Ruffolo, Ermelinda Oro, Mario Alviano, Nicola Leone, The HiLeX system for semantic information extraction, in: Transactions onLarge-Scale Data- and Knowledge-Centered Systems, in: Lecture Notes in Computer Science, vol. 7100, Springer, Berlin/Heidelberg, 2012, pp. 91–125.[50] Marco Manna, Francesco Scarcello, Nicola Leone, On the complexity of regular-grammars with integer attributes, Journal of Computer and SystemSciences (JCSS) 77 (2) (2011) 393–421.[51] Mónica Caniupán Marileo, Leopoldo E. Bertossi, The consistency extractor system: Querying inconsistent databases using answer set programs, in: SUM2007, 2007, pp. 74–88.[52] Jack Minker (Ed.), Foundations of Deductive Databases and Logic Programming, Morgan Kaufmann Publishers, Inc., Washington DC, 1988.[53] Boris Motik, Reasoning in description logics using resolution and deductive databases, PhD thesis, Fakultät für Wirtschaftswissenschaften, UniversitätFridericiana zu Karlsruhe, 2006.[54] Boris Motik, Ulrike Sattler, A comparison of reasoning techniques for querying large description logic aboxes, in: Miki Hermann, Andrei Voronkov(Eds.), Logic for Programming, Artificial Intelligence, and Reasoning, 13th International Conference (LPAR 2006), in: Lecture Notes in Computer Science,vol. 4246, Springer, 2006, pp. 227–241.[55] Inderpal Singh Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, Raghu Ramakrishnan, Magic is relevant, in: Proceedings of the 1990 ACM SIGMODInternational Conference on Management of Data, 1990, pp. 247–258.192M. Alviano et al. / Artificial Intelligence 187–188 (2012) 156–192[56] Raghu Ramakrishnan, Yehoshua Sagiv, Jeffrey D. Ullman, Moshe Y. Vardi, Logical query optimization by proof-tree transformation, Journal of Computerand System Sciences 47 (1) (1993) 222–248.[57] Francesco Ricca, Mario Alviano, Antonella Dimasi, Giovanni Grasso, Salvatore Maria Ielpa, Salvatore Iiritano, Marco Manna, Nicola Leone, A logic-basedsystem for e-tourism, Fundamenta Informaticae 105 (1–2) (2010) 35–55.[58] Francesco Ricca, Giovanni Grasso, Mario Alviano, Marco Manna, Vincenzino Lio, Salvatore Iiritano, Nicola Leone, Team-building with answer set pro-gramming in the Gioia–Tauro seaport, Theory and Practice of Logic Programming (2012), http://dx.doi.org/10.1017/S147106841100007X, in press.[59] K.A. Ross, Modular stratification and magic sets for datalog programs with negation, Journal of the ACM 41 (6) (1994) 1216–1266.[60] Praveen Seshadri, Joseph M. Hellerstein, Hamid Pirahesh, T.Y. Cliff Leung, Raghu Ramakrishnan, Divesh Srivastava, Peter J. Stuckey, S. Sudarshan, Cost-based optimization for magic: Algebra and implementation, in: H.V. Jagadish, Inderpal Singh Mumick (Eds.), Proceedings of the 1996 ACM SIGMODInternational Conference on Management of Data, ACM Press, June 1996, pp. 435–446.[61] Patrik Simons, Ilkka Niemelä, Timo Soininen, Extending and implementing the stable model semantics, Artificial Intelligence 138 (June 2002) 181–234.[62] Peter J. Stuckey, S. Sudarshan, Compiling query constraints, in: Proceedings of the Thirteenth Symposium on Principles of Database Systems (PODS’94),ACM Press, May 1994, pp. 56–67.[63] Jeffrey D. Ullman, Principles of Database and Knowledge-Base Systems, vol. II, Computer Science Press, 1989.[64] A. van Gelder, Negation as failure using tight derivations for general logic programs, in: Minker [52], pp. 1149–1176.