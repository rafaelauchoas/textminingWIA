Artificial Intelligence 164 (2005) 81–119www.elsevier.com/locate/artintOn the logic of cooperation and propositional controlWiebe van der Hoek ∗, Michael WooldridgeDepartment of Computer Science, University of Liverpool, Liverpool L69 7ZF, United KingdomReceived 24 August 2004Available online 5 February 2005AbstractCooperation logics have recently begun to attract attention within the multi-agent systems com-munity. Using a cooperation logic, it is possible to represent and reason about the strategic powersof agents and coalitions of agents in game-like multi-agent systems. These powers are generallyassumed to be implicitly defined within the structure of the environment, and their origin is rarelydiscussed. In this paper, we study a cooperation logic in which agents are each assumed to control aset of propositional variables—the powers of agents and coalitions then derive from the allocation ofpropositions to agents. The basic modal constructs in this Coalition Logic of Propositional Control(CL-PC) allow us to express the fact that a group of agents can cooperate to bring about a certainstate of affairs. After motivating and introducing CL-PC, we provide a complete axiom system for thelogic, investigate the issue of characterising control in CL-PC with respect to the underlying powerstructures of the logic, and formally investigate the relationship between CL-PC and Pauly’s Coali-tion Logic. We then show that the model checking and satisfiability problems for CL-PC are bothPSPACE-complete, and conclude by discussing our results and how CL-PC sits in relation to otherlogics of cooperation. 2005 Elsevier B.V. All rights reserved.Keywords: Multi-agent systems; Cooperation logic; Logics for control* Corresponding author.E-mail address: wiebe@csc.liv.ac.uk (W. van der Hoek).0004-3702/$ – see front matter  2005 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2005.01.00382W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–1191. IntroductionCooperation logics are logics that are intended to enable reasoning about coalitionsin multi-agent systems, and in particular, the powers that such coalitions have. Probablythe two best known examples of cooperation logics are Pauly’s Coalition Logic [36–38],and the Alternating-time Temporal Logic (ATL) of Alur, Henzinger, and Kupferman [5].Both of these systems are based upon the notion of a cooperation modality: a unary modaloperator, indexed by a set of agents, which is used to represent the fact that this set of agentscan cooperate so as to make true the state of affairs given as an argument to the operator.In Coalition Logic, for example, a formula [1, 2](p ∧ q) is used to express the fact that thecoalition {1, 2} can cooperate in such a way as to make the formula p ∧ q true. Althoughthey differ on technical details, the semantics of both logics are essentially equivalent [19]:coalition C are able to achieve ϕ if there exists a collective strategy for C such that, byfollowing this strategy, C can enforce ϕ (that is, ϕ is true in every outcome that couldarise by following the strategy). In both logics, the strategies available to a coalition, andthe outcomes consistent with these strategies, are implicitly enumerated within the logic’smodels: in the case of Coalition Logic, by means of effectivity functions (cf. [1]), and inthe case of ATL, by means of a system transition function.In this paper, we study a variant of cooperation logic that we refer to as the CoalitionLogic of Propositional Control (CL-PC). The key idea in CL-PC is that each agent is as-sumed to control a set of propositional variables. The strategies, or choices available toan agent then correspond to the different possible assignments of truth or falsity to thesepropositions. On top of that, the ability of a coalition to bring about some state of affairsderives from the propositional variables that are under the overall control of the coalition.There are at least two reasons why CL-PC is a system worthy of study in its own right:• First, and perhaps most importantly, if we are interested in building software agents,then it is extremely natural to think of the ability of these agents in terms of settingand unsetting bits in some digital control system. Indeed, this is arguably the mostfundamental kind of control that can be imagined.• Second, in implemented systems for reasoning about cooperation in game-like multi-agent scenarios, the individual powers of agents are actually specified by allocatingagents propositions that lie under their control. For example, this is exactly the ap-proach taken in the MOCHA model checking system for ATL, where the keywordcontrols is used to indicate the fact that an agent (or “module”, in the terminol-ogy of MOCHA) is uniquely able to determine the value of a propositional variable[3,6].Against this background, the present paper makes four main contributions to the study ofcooperation logics.First, although we have taken inspiration and some methodology from ATL and Coali-tion Logic, we note that the basic cooperation modalities of these logics have a ratherunusual modal flavour, which is neither wholly universal nor wholly existential. This isbecause these logics are intended to capture ∃∀-ability, or α-ability [1, pp. 11–12], the ideabeing that a coalition C have the α-ability to achieve some state of affairs ϕ if C haveW. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11983a collective choice such that, no matter what the agents outside C do, ϕ will hold as aconsequence of this choice. This type of ability is entirely natural when we wish to studythe circumstances under which a coalition can “reliably” bring about some state of affairs.However, the ∃∀ nature of cooperation modalities in these logics, and the fact that they areneither conventionally existential nor conventionally universal, means that (i) they are hardfor “logic users” to understand, as they have some counterintuitive properties (particularlyin their dual forms); and (ii) from a technical standpoint, the fact that they are a combina-tion of existential and universal modality makes them somewhat awkward to work with,at least compared with conventional “box” and “diamond” modalities. In CL-PC, however,the basic cooperation modalities capture contingent ability—a weaker notion of abilitythan the α-ability of Coalition Logic and ATL. Contingent ability is the ability to achievesome state of affairs under the assumption that, apart from our actions, the world remainsstatic. This is the type of ability that is implemented in classic AI planning systems such asSTRIPS [17,28]. Although contingent ability is perhaps not of great interest in its own right,it turns out that the contingent ability constructs of CL-PC are sufficient to define α-ability(as well as a related type of ability known as β-ability). Thus, although we appear to startwith a weaker notion of ability than those of Coalition Logic and ATL, it turns out that thisis in fact all we need to define these stronger types of ability. Moreover, the contingentability operators of CL-PC have the advantage of being “true modal diamonds”: they thushave a much simpler semantics than α-ability operators, and are easier to work with from atechnical point of view (for example, when using such conventional modal logic constructssuch as canonical models to prove completeness [11, pp. 59–61]).Second, although our basic cooperation modalities are conventional modal diamonds,and hence we can give them a more-or-less conventional Kripke semantics [9, p. 42], weare also able to give an alternative semantics to CL-PC, which is directly based on thepower structures that underpin the logic. We show that the two semantics are, in a precisesense, equivalent, and that we can thus move between the two semantics as we see fit. Theadvantage of this is that we can work with whichever semantics seems most appropriate tothe task at hand.Third, although complete axiomatizations are known for both ATL [19] and CoalitionLogic [36–38], we are able to provide an axiomatization for CL-PC that draws upon thesimple underlying power structures of the logic. As a consequence, our axiomatization ofCL-PC has a rather different flavour to those of Coalition Logic and ATL.Fourth, and finally, we present an analysis of control in CL-PC: when a coalition controlssome state of affairs. In particular, we show how the control that a coalition is able to exertwith respect to some state of affairs is related to the power structure underlying the logic.The remainder of this paper is structured as follows. Following a formal definition ofCL-PC, in Section 3 we present a complete axiomatization for the logic. In Section 4.1,we show how α- and β-ability modalities can be defined in terms of the basic constructsof CL-PC, and in Section 4.2, we investigate the characterisation of control in CL-PC, withparticular reference to the underlying power structures. In Section 5, we investigate thecomputational complexity of the model checking and satisfiability problems for the logic,and show that both problems are PSPACE-complete. We conclude with a discussion on theimplications of our results, and how the logic stands in relation to other similar systems.84W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–1192. The coalition logic of propositional controlIn this section, we give a formal definition of CL-PC. We begin with an informal in-troduction to the main features of the logic (readers familiar with Coalition Logic or ATLmay wish to skip or skim through this section). We then formally define the syntax ofCL-PC, and give two alternative semantics. The first is a “direct” or “propositional” seman-tics, which has the advantages of being both simple and closely related to the intuitionsunderpinning the language, but has the disadvantage of being rather unconventional in themodal logic sense, and hence rather hard to work with from the point of view of prov-ing properties such as completeness. In the second semantics, we employ the conventionalKripke-style relational structures of modal logic [9,11], making it possible to representboth the current situation and those that the agents can bring about in one and the samemodel. In Section 2.5, we show that these two semantics are equivalent. The obvious ad-vantage of having two equivalent semantics for our logic is that we can choose to workwith whichever semantics is most convenient for the problem at hand.2.1. Informal introductionThe components of the systems of interest to us are as follows. First, we assume avocabulary At of propositional variables, which represent attributes of the systems that wemodel. Next, we assume a finite, non-empty set Ag of agents; a coalition is simply a subsetof Ag. The only property that we assume of agents is that they are each able to control apart of their environment. We capture this by assuming that every propositional variableis controlled by exactly one agent. Thus we associate with every agent i ∈ Ag a (possiblyempty) subset Ati of At, representing those propositional variables under its control. Thefollowing example illustrates these ideas in more detail, and also informally introduces thelanguage of CL-PC.Fig. 1. In CL-PC, each agent is assumed to have unique control over the value of a set of propositional variables.W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11985Table 1Comparing the notation of Coalition Logic, ATL, and CL-PC fordifferent types of abilityCoalition LogicATLContingent abilityα-abilityβ-ability[C]ϕ(cid:7)(cid:7)C(cid:8)(cid:8) (cid:1)ϕCL-PC(cid:6)C ϕ(cid:7)(cid:7)C(cid:8)(cid:8)αϕ(cid:7)(cid:7)C(cid:8)(cid:8)β ϕExample 2.1. Fig. 1 illustrates the kind of scenario that we have in mind for CL-PC. Here,we have four agents, (named 1 through to 4), and eight propositional variables (p to w).Agent 1 controls propositions p and q, agent 2 controls r, agent 3 controls s, t, and u, andagent 4 controls v and w.Agent 1 has assigned the value “1” to variables p and q—that is, both these variableshave the value “true” (hereafter denoted by “tt”). Similarly, the variables s and w havebeen set to tt by agents 3 and 4 respectively, while all remaining variables have been setto 0 (i.e., “ff”). Now, given this scenario, we say that agent 1 has the contingent abilityfor ¬p ∧ s. That is, assuming that all those propositions not under the control of agent 1retain their current value, then agent 1 can choose values for its propositions so as to make¬p ∧ s true. We express this in CL-PC by the following formula.(cid:6)1(¬p ∧ s)Thus the CL-PC expression (cid:6)Cϕ means “coalition C have the contingent ability to achieveϕ”. (As an aside, we note that, unfortunately, there is no standard notation in the literatureof cooperation logics: in Table 1, we compare our notation to that of Coalition Logic andATL.)As we noted above, contingent ability corresponds quite closely to “STRIPS-style” plan-ning ability [17,28], in the sense that agent 1 has a plan to achieve ¬p ∧ s from the scenarioin Fig. 1: the plan consists of one action, namely setting p to ff. However, the plan isclearly contingent, in the sense that it depends upon the value of s remaining unchangedby agent 3. If agent 3 chose to change this value, then the plan would fail.Here is another example of a contingent ability formula that is true of Fig. 1.(cid:6)1,3(¬p ∧ t ∧ ¬r)A “multi-agent plan” to achieve ¬p ∧ t ∧ ¬r would involve two actions: agent 1 setting pto ff, and agent 3 setting t to tt. The plan is contingent upon agent 2 leaving the valueof r unchanged, at ff.Contingent ability, as captured in the coalitional ability operator of CL-PC is clearlyrather limited. It makes perfect sense however in truly turn-based systems, in which agentsperform their actions in an alternating fashion (most games have this nature). Moreover, aswe noted above, it is in fact sufficient to define α-and β-ability, both of which representstronger and arguably more useful strains of ability. Although we will not formally de-fine and investigate these types of ability until Section 4.1, we nevertheless provide someillustrative examples here.In CL-PC, we write (cid:7)(cid:7)C(cid:8)(cid:8)αϕ to express the fact that coalition C are α-able to bring aboutϕ. This means that coalition C can choose to act in such a way that no matter what the86W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119agents outside C choose to do, ϕ will be true. With respect to the scenario of Fig. 1, thefollowing formula is thus not true.(cid:7)(cid:7)1(cid:8)(cid:8)α(¬p ∧ s)In contrast, the following formula is true in the Fig. 1 scenario.(cid:7)(cid:7)1, 3(cid:8)(cid:8)α(¬p ∧ s)We represent β-ability in CL-PC by the cooperation modality (cid:7)(cid:7). . .(cid:8)(cid:8)β . The distinction be-tween α-and β-ability may be understood through the following example. Suppose wehave agents 1 and 3 playing a game in which agent 1 wins if, after the game is over, thevariables p and s have the opposite values—that is, if p is tt, then s is ff, and vice versa.The game itself simply involves the agents choosing values for their variables.Now, is agent 1 able to win this game? It depends upon whether we are talking aboutα-ability or β-ability. Agent 1 clearly does not have the α-ability to win this game:¬(cid:7)(cid:7)1(cid:8)(cid:8)α(p ↔ ¬s)This is because, when considering α-ability, agent 1 must choose first: and after choosinga value for p, agent 3 can then simply copy this value in the choice for s, thereby falsifyingp ↔ ¬s.However, when considering β-ability, the assumption is that agent 1 carries a responsiverole, while agent 3 will choose first: agent 1 can then reliably win by choosing for p theopposite of whatever agent 3 chooses for s. Thus, the following CL-PC formula is true ofFig. 1.(cid:7)(cid:7)1(cid:8)(cid:8)β (p ↔ ¬s)Notice that β-ability is strictly weaker than α-ability; we discuss this at more length inSection 4.1.2.2. SyntaxFormulae of CL-PC are constructed from the set Ag of agents, the set At of propositionalatoms, the usual operators of classical propositional logic (we use negation and disjunctionas our atomic Boolean functions, together with a logical constant for truth), and the coop-eration modality (cid:6)···. More formally, the syntax of CL-PC is given by the following BNFgrammar:ϕ ::= (cid:10) | p | ¬ϕ | ϕ ∨ ϕ | (cid:6)Cϕwhere p ∈ At is a propositional variable, and C ⊆ Ag is a set of agents. Thus we use(cid:10) as a logical constant for truth, “¬” for negation, and “∨” for disjunction. As usual, wedefine the remaining connectives of classical propositional logic as abbreviations: ⊥ ˆ= ¬(cid:10),ϕ → ψ ˆ= ¬ϕ ∨ ψ and ϕ ↔ ψ ˆ= (ϕ → ψ) ∧ (ψ → ϕ).We refer to an expression (cid:6)Cϕ as a cooperation modality. Where there is no possibilityof confusion, we will omit set brackets inside cooperation modalities, for example writing(cid:6)1,2 rather than (cid:6){1,2}. A CL-PC formula containing no cooperation modalities is said tobe an objective formula.W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11987If ϕ is a CL-PC formula, then let At(ϕ) denote the set of propositional variables occurringin ϕ, and let Ag(ϕ) denote the set of all agents named in ϕ (i.e., Ag(ϕ) is the union of allthe coalitions occurring in cooperation modalities in ϕ).2.3. Direct semanticsWe now introduce the first of the two semantics for CL-PC. We say a model for CL-PCis a structure:M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8)where:• Ag = {1, . . . , n} is a finite, non-empty set of agents;• At = {p, q, . . .} is a finite, non-empty set of propositional variables;• At1, . . . , Atn is a partition of At among the members of Ag, with the intended interpre-tation that Ati is the subset of At representing those variables under the control of agenti ∈ Ag; and finally,• θ : At → {tt, ff} is a propositional valuation function, which determines the initialtruth value of every propositional variable.Notice that since At1, . . . , Atn is a partition of At, we have:1. At = At1 ∪ · · · ∪ Atn, i.e., every variable is controlled by some agent, and2. Ati ∩ Atj = ∅ for i (cid:18)= j ∈ Ag, i.e., no variable is controlled by more than one agent.(cid:1)Some additional notation is convenient in what follows. We say a coalition, C is simplya subset of Ag, i.e., C ⊆ Ag. For any such C ⊆ Ag we denote the complement of C (i.e.,i∈C Ati . For two valuations θ and θ (cid:19), and a set ofAg \ C) by C. We will write AtC forpropositions Ψ ⊆ At, we write θ = θ (cid:19) (mod Ψ ) if θ and θ (cid:19) differ at most in the atoms in Ψ ,and we then say that θ and θ (cid:19) are the same modulo Ψ . We will sometimes understand themodel M = (cid:7)F, θ (cid:8) to consist of a valuation θ on top of a frame F = (cid:7)Ag, At, At1, . . . , Atn(cid:8).Given a model M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) and a coalition C in M, a C-valuation is afunction:θC : AtC → {tt, ff}.Thus a C-valuation is a function that assigns truth values to just the primitive propositionscontrolled by the members of the coalition C. If M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) is a model,C is a coalition in M, and θC is a C-valuation, then by M ⊕ θC we mean the model(cid:7)Ag, At, At1, . . . , Atn, θ (cid:19)(cid:8), where θ (cid:19) is the function defined as follows(cid:2)(cid:19)θ(p) ˆ=θC(p)θ (p)if p ∈ AtC,otherwiseand all other element of the model are as in M. Thus M ⊕ θC denotes the model thatis identical to M except that the values assigned by its valuation function to propositionscontrolled by members of C are as determined by θC : we have θ = θ (cid:19) (mod AtC). Noticethat the ∅-valuation θ∅ is the right identity under ⊕, that is, M ⊕ θ∅ = M, for all M.88W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119We define the size of a model M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) to be |Ag| + |At|; we denotethe size of M by size(M).We interpret formulae of CL-PC with respect to models, as introduced above.Definition 1. Given a model M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) and a formula ϕ, we writeM |=d ϕ to mean that ϕ is satisfied (or, equivalently, true) in M, under the “direct” se-mantics. The rules defining the satisfaction relation |=d are as follows:– M |=d (cid:10);– M |=d p iff θ (p) = tt (where p ∈ At);– M |=d ¬ϕ iff M (cid:18)|=d ϕ;– M |=d ϕ ∨ ψ iff M |=d ϕ or M |=d ψ;– M |=d (cid:6)Cϕ iff there exists a C-valuation θC such that M ⊕ θC |=d ϕ.We assume the conventional definitions of satisfiability and validity: a CL-PC formula ϕis d-satisfiable iff there exists a CL-PC model M such that M |=d ϕ, and ϕ is d-validiff for every CL-PC model M we have M |=d ϕ. We write |=d ϕ to indicate that ϕ is d-valid. Moreover, if I is a partition {At1, At2, . . . , Atn} of the atoms At over the agents, andM |=d ϕ for every model M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) based on this partition, we write|=dI ϕ.At this point, let us introduce the natural box dual “(cid:1)···” of the (cid:6)··· cooperation modal-ity:(cid:1)Cϕ ˆ= ¬(cid:6)C¬ϕThe intuitive interpretation of a formula (cid:1)Cϕ is that C cannot avoid ϕ: that is, for everypossible way that C choose to behave, ϕ “may” still become true. However it does notmean that ϕ will inevitably be true, as the following example illustrates.Example 2.2. Suppose we have a model M = (cid:7){1, 2}, At, At1, At2, θ (cid:8) such that At = {p, q},At1 = ∅, At2 = {p, q} and θ (x) = tt for x ∈ {p, q}. Now, there is no 1-valuation θ1 suchthat M ⊕ θ1 |=d ¬p. That is, M |=d (cid:1)1p. Similarly, agent 1 cannot avoid p ∧ q, i.e.,M |=d (cid:1)1(p ∧ q). But this does not mean p ∧ q is inevitable: it depends on the choicethat 2 makes. Since 2 controls both p and q, we have M |=d (cid:6)2¬p, M |=d (cid:6)2¬q, andM |=d (cid:6)2¬(p ∨ q).Before proceeding, we pause to consider the extent to which the number of agentsin a model affects whether or not a formula is satisfied. Let us say that a model(cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) is a k-agent model if |Ag| = k. In the same way, let us say a for-mula ϕ is a k-agent formula if |Ag(ϕ)| = k. Now, consider the following example.Example 2.3 (Individual versus multi-agent models). Consider the 1-agent formulap ∧ (cid:1)1p. This formula is clearly satisfiable, as is witnessed by the 2-agent model(cid:7)Ag, At, At1, At2, θ (cid:8) such that Ag = {1, 2}, At = {p}, At1 = ∅, At2 = {p}, and θ (p) = tt.However, this formula is clearly not satisfied in any 1-agent model, because the only agentW. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11989in such a model must (by virtue of the fact that the formula is well-formed) be 1; thus agent1 must control p, and so can choose ¬p. Hence the formula is not satisfied by the model.In this example, we have a 1-agent formula that is satisfiable in a 2-agent model, but notin any 1-agent model. This begs an obvious question: To what extent is the satisfiabilityof a formula affected by the number of agents in the models we consider for this formula?We have the following result, which says that any satisfiable k-agent formula is satisfiedin a (k + 1)-agent model. In other words, if a formula is satisfiable, then it is satisfied in amodel containing at most one agent in addition to those explicitly named in the formula.Lemma 2.1. A CL-PC formula ϕ is satisfiable iff it is satisfied in a model M =(cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) such that |Ag| = |Ag(ϕ)| + 1 and At = At(ϕ).Proof. The direction from right to left is obvious, so suppose ϕ is satisfiable, let Ag(ϕ) ={1, . . . , k} be the agents named in ϕ, and let M = (cid:7)Ag, At, At1, . . . , Atk, Atk+1, . . . , Atm, θ (cid:8)= (cid:7)F, θ (cid:8) be a model based on F that satisfies ϕ, thus Ag = {1, . . . , k, k + 1, . . . , m}. Let Sdenote the agents {k + 1, . . . , m} in Ag that are not named in ϕ. First, let e denote a newagent—one that is neither named in ϕ nor is a member of S. Now, consider the frame F (cid:19)= (cid:7)Ag(cid:19), At(cid:19), At(cid:19)k, Ate(cid:8) such that:(cid:19)1, . . . , At• Ag(cid:19) = Ag(ϕ) ∪ {e};(cid:19) = At(ϕ);• At(cid:19)• At= Ati ∩ At(ϕ), for all i (cid:1) k;i• Ate = At(ϕ) \(cid:1)i(cid:1)k At(cid:19)i .Obviously, |Ag(cid:19)| = |Ag(ϕ)| + 1 and Atvaluation θ : At → {tt, ff}, let θ(cid:2)At(cid:19) : Atwe claim:(cid:19) = At(ϕ). Finally, on the level of models, given a(cid:19). Now,(cid:19) → {tt, ff} be the restriction of θ to Atfor all valuations θ and all subformulas ψ of ϕ : (cid:7)F, θ (cid:8) |=d ψ iff (cid:7)F (cid:19), θ(cid:2)At(cid:19)(cid:8) |=d ψ.The proof is by induction on the structure of ψ The inductive base is where ψ ∈ At, andis obvious since θ is unchanged on the relevant atoms when going from F to F (cid:19). For theinductive assumption, assume that the result holds for all sub-formulae ψ of ϕ. For theinductive step, the cases for propositional connectives are immediate. So consider the casewhere χ = (cid:6)Cψ. Now, (cid:7)F, θ (cid:8) |=d (cid:6)Cψ iff for some θ i , with θ i = θ (mod Ati), we have(cid:7)F, θ i(cid:8) |=d ψ. The induction hypothesis guarantees that this is equivalent to (cid:7)F (cid:19), θ i(cid:19)(cid:8) |=dψ and this in turn is equivalent to (cid:7)F (cid:19), θ(cid:2)At(cid:19)(cid:8) |=d (cid:6)iψ. (cid:1)(cid:2)AtPauly discusses somewhat related issues in the context of Coalition Logic [36, pp. 68–71]. The significance of our result will become clear later, when we use the followingimmediate corollary as a kind of polysize model property, of the kind that is frequentlyused in establishing upper bounds in the complexity theory of modal logic [9, pp. 375–381].90W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119Corollary 2.1. If a CL-PC formula ϕ is satisfiable, then it is satisfied in a model M suchthat size(M) = |At(ϕ)| + |Ag(ϕ)| + 1.2.4. Kripke semanticsThe “direct” semantics presented above has the advantage of being closely related to ourintuitive understanding of the logic CL-PC: the semantic rule for ability is based directlyupon the way that propositional variables are partitioned among the agents in the system.However, from a technical point of view, the direct semantics has the disadvantage of be-ing unusual and unfamiliar—and hence (arguably) hard to work with. In this section, wetherefore introduce a semantics for CL-PC based on the familiar and conventional Kripkerelational structures of modal logic [9,11]. Although readers may have a personal prefer-ence for one semantics over the other, we show in Section 2.5 that the two semantics are infact equivalent, and that we can thus use whichever semantics seems most appropriate tothe task at hand.Definition 2. Let W be the set of all valuations θ over At. For every Ati ⊆ At, we assumea binary relation Ri to be given, with Riww(cid:19) iff w and w(cid:19) differ at most in the values thatthey assign to the atoms in Ati . Formally: Riww(cid:19) ⇔ w = w(cid:19) (mod Ati). Note that Ri isan equivalence relation. To lift the Ri relations, (corresponding to the possible choices ofindividual agents) to arbitrary coalitions, we need the notion of relational composition.Given a set S, and binary relations R1, R2 ⊆ S × S over S, we denote the composition ofR1 and R2 by R1 ◦ R2, where this is defined as follows.(cid:3)(cid:4)R1 ◦ R2 =(s, t) | ∃u: R1su & R2utWe then define the Kripke model K = (cid:7)W, R1, . . . , Rn, Π(cid:8), where Θ : W → At →{tt, ff} is simply given by Θ(w) = w. For any coalition C = {a1, a2, . . . , ak} (k (cid:1) n),◦ · · · ◦ Rak . The following result tells us that the composition is◦ Ra2we define RC as Ra1independent of the order.Lemma 2.2. Let K = (cid:7)W, R1, . . . , Rn, Θ(cid:8) be defined as in Definition 2. Then for everyi, j ∈ Ag, we have: Ri ◦ Rj = Rj ◦ Ri .Proof. Suppose w(Ri ◦ Rj )v. Then there is a u for which Riwu and Rj uv. This means thatw = u (mod Ati) and, similarly, u = v (mod Atj ). Note that hence w = v (mod Ati ∪ Atj ).Let u(cid:19) be defined as follows. It is exactly like w, except for the atoms in Atj , for which u(cid:19)is as v. Then, by definition of u(cid:19), we have Rj wu(cid:19) (by definition, they at most differ in Atj )and Riu(cid:19)v (w and u differ at most in Ati ∪ Atj , hence u(cid:19) and v differ at most in Ati ). Weconclude that w(Rj ◦ Ri)v. (cid:1)We can now see the following.Lemma 2.3. Let K = (cid:7)W, R1, . . . , Rn, Θ(cid:8) be defined as in Definition 2. Then for all C ⊆Ag, RC is an equivalence relation.W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11991Proof. Reflexivity and symmetry for RC are immediately inherited from the same prop-erties of Ri (i ∈ C). For transitivity, suppose that uRCv and vRCw. Let us assume thatC = {1, 2, . . . , n}. Then, since the order is irrelevant (Lemma 2.2), we know that thereare paths u = u1, u2, . . . , un = v and v = v1, v2, . . . , vn = w such that Riuiui+1 andRivivi+1. By applying Lemma 2.2 repeatedly we find u(cid:19)i (i (cid:1) n) with a pathi and Riv(cid:19)u = u(cid:19)i+1. Now we can apply tran-nsitivity to the individual agent’s relations, giving us a path from u to w that is in RC . (cid:1)= w such that Riu(cid:19)i and v(cid:19)iu(cid:19)2, . . . , u(cid:19)1, u(cid:19)1, v(cid:19)2, v(cid:19)n, v(cid:19)iv(cid:19)The inductive rules defining the truth of a CL-PC formula ϕ under an interpretation K, ware defined as follows:– K, w |=k (cid:10)– K, w |=k p iff Θ(w)(p) = w(p) = tt (where p ∈ At);– K, w |=k ¬ϕ iff K (cid:18)|=k ϕ;– K, w |=k ϕ ∨ ψ iff K, w |=k ϕ or K, w |=k ψ;– K, w |=k (cid:6)Cϕ iff there exists a w(cid:19) ∈ W such that RCww(cid:19) and K, w(cid:19) |=k ϕ.Note that, given the partition I on At, there is only one model K, which we sometimes alsowill denote as KI .1 We write KI |=k ϕ, but also |=kI ϕ as a shorthand for KI , w |=k ϕ forevery world w in KI . If moreover the latter holds for every K, more precisely for everyKI , we write |=k ϕ.Since by Lemma 2.3 every accessibility relation RC in each model K is an equivalencewe immediately obtain the following properties (see, e.g., [11]).abcdef|=k ϕ → (cid:6)Cϕ|=k (cid:6)C(cid:6)Cϕ ↔ (cid:6)Cϕ|=k (cid:6)C¬(cid:6)Cϕ ↔ ¬(cid:6)Cϕ|=k (cid:1)Cϕ → ϕ|=k (cid:1)C(cid:6)Cϕ ↔ (cid:6)Cϕ|=k (cid:1)C(cid:1)Cϕ ↔ (cid:1)Cϕ(1)Property a is the dual of d which in turn is modal axiom T and is guaranteed by re-flexivity of RC (cf. Lemma 2.3). Properties b and f are also each other duals: in f , the→-direction is a special case of d, the other direction (known in modal logic as axiom4 [11]) is due to the transitivity of RC . Of property c, the ←-direction is an instanceof a, the other direction is equivalent to axiom 5, which is usually given as ¬(cid:1)Cψ →(cid:1)C¬(cid:1)Cψ. This is also what the ←-direction of e is expressing. Finally, the →-directionof e is an instance of d.1 As an aside, we might generalize the notion of I -validity to that in models K(cid:19)= (cid:7)W (cid:19), R1, . . . , Rn, Θ(cid:8), whereIW (cid:19) ⊆ W is some subset of all the possible valuations, reflecting some background theory on the allowed propo-sitional formulas.92W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119We note in passing that (cid:1)Ag is a “universal” modality, and gives us a bridge to go from“local” (i.e., truth at a world in a Kripke structure) to “global” (i.e., truth at every world inan I -Kripke structure):KI |=k ϕ ⇔ ∃w: KI , w |=k (cid:1)Agϕ(2)Example 2.4 (Bach or Stravinsky). Let us consider two agents, each having a choice togo to either a concert by Bach or by Stravinsky. Let b1 be the atom denoting that agent 1chooses for Bach, and similarly for b2 and agent 2. Obviously, I is such that each agenti has control over the atom bi . It is understood that agent i’s choice for Stravinsky isrepresented as ¬bi . Assume that initially no agent is going to Bach (i.e., w and Θ aresuch that K, w |=k (¬b1 ∧ ¬b2)), then we have in w that no agent can force them bothgoing to Bach (¬(cid:6)1(b1 ∧ b2) ∧ ¬(cid:6)2(b1 ∧ b2)), whereas in full cooperation they can sharea Bach evening ((cid:6)1,2(b1 ∧ b2)). On a global level, neither agent can establish an eveningout together (KI (cid:18)|=k (cid:6)i(b1 ∧ b2) and KI (cid:18)|=k (cid:6)i(¬b1 ∧ ¬b2), i (cid:1) 2), but fortunately, theycan cooperate to have an evening out together (KI |=k (cid:6)1,2(b1 ∧ b2) ∧ (cid:6)1,2(¬b1 ∧ ¬b2)),but this still involves a choice (KI (cid:18)|=k (cid:6)1,2((b1 ∧ b2) ∧ (¬b1 ∧ ¬b2))).2.5. Relating the different semanticsOur next task is to formally establish that the two semantics are equivalent.Remark 2.1. From now on, given a propositional model M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8)such as defined in Definition 1, and a Kripke model K = (cid:7)W, R1, . . . , Rn, Π(cid:8) as in Defini-tion 2 we assume they are based on the same partition At1, . . . Atn. Moreover, we will writewθ for that world in W for which Θ(wθ ) = θ .Lemma 2.4 (Equivalence of semantics). Let the model M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) be asin Definition 1, and let the Kripke model K = (cid:7)W, R1, . . . , Rn, Π(cid:8) be as in Definition 2.Then, for every CL-PC formula ϕ, we have:M |=d ϕ iff K, wθ |=k ϕProof. We prove the displayed equivalence for any M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8), theproof proceeding with induction on ϕ. For ϕ being an atom p this follows from the de-finition of θ and wθ . Let us look at the diamond formula (cid:6)Cϕ. Suppose M |=d ϕ. Thismeans that there is some valuation θ (cid:19) and a model M(cid:19) = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:19)(cid:8) suchthat M(cid:19) |=d ϕ. The induction hypothesis gives us K, wθ (cid:19) |=k ϕ, and, since by definition, θ (cid:19)i∈C Ati , we have K, wθ (cid:19) |=k (cid:6)Cϕ. Thediffers from θ in at most the atoms occurring inother direction is proven in a similar way. (cid:1)(cid:1)Corollary 2.2.|=dI ϕ iff KI |=k ϕand|=d ϕ iff|=k ϕHow do the local, the semi-general I -based, and the global semantics compare? Westart by giving the obvious dependencies, and then discuss the differences between the se-W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11993mantics, on the fly arguing that, in general, none of the implications below can be reversed.So, let KI be a Kripke model with I a partition over At, and let w be a world. Then it iseasy to see that we have the following chain of implications.|=k ϕ ⇒ KI |=k ϕ ⇒ KI , w |=k ϕ(3)The last implication cannot be reversed, witnessed by ϕ = p and w(p) = tt. But objec-tive formulas are not the only counterexamples: take w as before and assume that p /∈ Ati ,q ∈ Ati . Then we have that KI , w |=k (cid:6)i(p ∧ q), whereas, even under this fixed partition I ,KI (cid:18)|=k (cid:6)i(p ∧ q). The first implication is also not an equivalence: take I such that q ∈ Ati ,then KI |= (cid:6)iq, but obviously (cid:18)|=k (cid:6)iq. It seems that the notion KI |=k ϕ is the most inter-esting for our current aims: the fact that i can bring about p ∧ q in w is too local a property,he would not be able to bring it about when in a situation in which p would not have beentrue.3. The deductive system CL-PCIn this section, we present an axiom system for CL-PC, and show that this axiom sys-tem is sound and complete with respect to our semantics. More precisely, we employ acanonical model construction to show that the axiom system is complete with respect tothe Kripke semantics for CL-PC introduced in Section 2.4. We then appeal to the fact thatthe Kripke and direct semantics are equivalent (Lemma 2.4) to conclude that the axiomati-zation is complete with respect to both.Definition 3. By (cid:10), we denote a literal p or ¬p. If we want to explicitly refer to the atom onwhich the literal is based, we write (cid:10)(p). Recall that an objective formula is one containingno cooperation modalities. Then the axioms of our logic CL-PC are as shown in Fig. 2.Given a partition I , we will write (cid:25)CL-PCϕ to denote that formula ϕ is derivable fromthese axioms and the following inference rules. We will often suppress the subscript I ,though, and sometimes also the superscript CL-PC.I(MP) (cid:25)CL-PC ϕ, (cid:25)CL-PC (ϕ → ψ) ⇒ (cid:25)CL-PC ψNec(i) (cid:25)CL-PC ϕ ⇒ (cid:25)CL-PC (cid:1)iϕFirst, note that all the axioms apart from Comp-∪ are about individual agents. We willsee below how the axioms can be “lifted” to arbitrary coalitions.With respect to the soundness of our axioms, we note that Prop is obvious, and K(i)states that (cid:1)i is a normal modal operator. Axiom T (i) in contrapositive—note that theaxioms are schemes—reads (ϕ → (cid:6)iϕ): every agent has the possibility to not changehis atoms, leaving the state unchanged. B(i) follows from the symmetry of the Ri rela-tion [11, p. 80]: starting in an arbitrary state verifying ϕ, any agent i cannot avoid to goto a state in which he can return to the original state ((cid:1)i(cid:6)iϕ). For ∅, note that R∅ isthe identity: if nobody is allowed to change some atoms, we stay where we are. Axiomat-least(control) states that every literal can be changed by at least one of the agents, andaxiom at-most(control) guarantees that no more than one agent can modify it.94W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119where ϕ is any propositional tautology(Prop)(K(i))(T (i))(B(i))ϕ,(cid:1)i (ϕ → ψ) → ((cid:1)i ϕ → (cid:1)i ψ)(cid:1)i ϕ → ϕϕ → (cid:1)i(cid:6)i ϕ(cid:1)∅ϕ ↔ ϕ(cid:5)(empty)at-least(control) (cid:10)(p) →at-most(control) (cid:10)(p) → ((cid:6)i ¬(cid:10)(p) → (cid:1)j (cid:10)(p))(cid:6)i ¬(cid:10)(p)i∈Ag(ψ ∧ (cid:10)(p)) → (cid:6)i (ψ ∧ ¬(cid:10)(p)) where(effect(i))(non-effect(i)) (cid:6)i (cid:10)(p) → (cid:1)i (cid:10)(p)(cid:1)C1(Comp-∪)(cid:1)C2 ϕ ↔ (cid:1)C1∪C2 ϕwhere i (cid:18)= jp ∈ Ati ,p /∈ At(ψ), andψ is objectivewhere p /∈ AtiFig. 2. Axioms of CL-PC.Axiom effect(i) states that agents can make local changes to formulas: if ψ does notinvolve a particular atom p that is under the control of agent i, then that agent can toggle pwithout modifying ψ, for any objective formula ψ. Although the soundness of this axiomis obvious for propositional formulas ψ, it is not immediately clear for general formulasϕ. As we will see in Lemma 3.4, however, this is derivable. The non-effect(i)-axiom saysthat no agent i can change the literals based on atoms outside his control: if p /∈ At(i) and(cid:6)i(cid:10)(p) is true, then (cid:10)(p) must be true no matter how i toggles his atoms, and in particular,(cid:10)(p) must already be true now (by virtue of T (i)).Finally, observe that Axiom Comp-∪ is equivalent to (cid:6)C1(cid:6)C2 ϕ ↔ (cid:6)C1∪C2 ϕ. This axiomis sound in the Kripke interpretation: if, given the interpretation θ , agent 1 can make atransition to θ1, from which agent 2 can choose the state to be θ2, then, equivalently, fromθ , agents 1 and 2 can choose values for their atoms so that we end up in θ2. The conversealso holds: a change in valuation due to the coalition C1 ∪ C2 can always be decomposedin a change by C1 and one by C2. (Schema Comp-∪ is so named for its close relationshipto the axiom Comp from dynamic logic [18, p. 88].2)Formally, we state without proof:Lemma 3.1 (Soundness). The system CL-PC is sound with respect to both the CL-PC se-mantics of Definition 1 and the Kripke semantics of Definition 2.The following lemma shows a number of derivable formulas. It demonstrates that theindividual agent properties of the logic CL-PC can be lifted to the collective level, and,moreover, property S(cid:19) shows when agents can concurrently exercise their powers.Lemma 3.2 (Derived schemes). The schemes in Fig. 3 may be derived in the deductivesystem CL-PC (C is an arbitrary set of agents).2 The Comp axiom from dynamic logic axiom is (cid:7)p1; p2(cid:8)ϕ ↔ (cid:7)p1(cid:8)(cid:7)p2(cid:8)ϕ (where p1 and p2 are programs).W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11995(4(C))(5(C))(T (C))(K(C))(cid:1)C (ϕ → ψ) → ((cid:1)C ϕ → (cid:1)C ψ)(cid:1)C ϕ → ϕ(cid:1)C ϕ → (cid:1)C(cid:1)C ϕ¬(cid:1)C ϕ → (cid:1)C ¬(cid:1)C ϕ(ϕ ∧ (cid:10)(p)) → (cid:6)C (ϕ ∧ ¬(cid:10)(p))(effect(C))(non-effect(C)) (p → (cid:1)C p) ∧ (¬p → (cid:1)C ¬p)(cid:1){i}∪C ϕ → (cid:1)i ϕ(Sub)(ϕ ∧ (cid:10)(p)) → (cid:6)i (ϕ ∧ (cid:10)(p)) ∧ (cid:6)i (ϕ ∧ ¬(cid:10)(p)) where(cid:6)C1 ϕ ∧ (cid:6)C2 ψ → (cid:6)C1∪C2 (ϕ ∧ ψ)Alt(i)(S(cid:19))where(cid:2)p ∈ AtC , andp /∈ At(ϕ)(cid:1)where p /∈i∈C Ati(cid:2)p ∈ Ati , andp /∈ At(ϕ)where At(ϕ) ∩ At(ψ) = ∅Fig. 3. Some derived axiom schemes.Proof. Follows from the semantics, once we have proven completeness. As an illustrationof a derivation, however, in Appendix A we prove (S(cid:19)) within CL-PC. (cid:1)Schema (S(cid:19)) is the closest we have in CL-PC to Pauly’s schema (S), which intuitivelysaid that disjoint coalitions could add abilities (i.e., for disjoint C1 and C2, if C1 can achieveϕ and C2 can achieve ψ, then C1 ∪ C2 can achieve ϕ ∧ ψ). The direct CL-PC analogue ofPauly’s (S), i.e., (cid:6)C1 ϕ ∧ (cid:6)C2 ψ → (cid:6)C1∪C2 (ϕ ∧ ψ) for disjoint C1, C2, is not valid, as thefollowing example illustrates.Example 3.1. Suppose that we have a model M with Ag = {1, 2}, At1 = {p}, and θ (p) =tt. Then clearly M |=d ((cid:6)1¬p) ∧ ((cid:6)2p). But if (cid:6)C1 ϕ ∧ (cid:6)C2ψ → (cid:6)C1∪C2(ϕ ∧ ψ) werevalid, then we would have M |=d (cid:6)1,2(p ∧ ¬p), and so M |=d (cid:6)1,2⊥ and hence M |=d ⊥.Instead, we have the weaker scheme (S(cid:19)): this scheme says that, if C1 can achieve ϕ,and C2 can achieve ψ, and ϕ and ψ have no propositional variables in common, thenC1 ∪ C2 can achieve ϕ ∧ ψ. Note that, in contrast to Pauly’s schema (S), while this schemarequires that the formulae ϕ and ψ are disjoint with respect to their propositional variables,the coalitions C1 and C2 are not required to be disjoint.3.1. CompletenessWe are now ready to prove that the axiom system CL-PC is complete with respect to thetwo semantics presented earlier. We begin by fixing some notation.Definition 4 (Notation). In the following, we use c as a variable both over individual agentsi ∈ Ag and coalitions C ⊆ Ag. If such a c is fixed, we want to reason about what it canachieve, and what not. For this, we partition a set of relevant atoms (which can be At, orAtc or At(ϕ) for a specific ϕ) in a subset X under control of c, say X = {x1, . . . , xk} and aset Y = {y1, . . . , ym} out of control of c. Note that the x’s and y’s are variables over atoms:when changing focus to another coalition c(cid:19) we will use the sets X and Y again, but ofcourse then X ⊆ At(c(cid:19)). Note that in order to not obscure notation too much, we do not96W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119make c explicit in this notation, nor do we say how k and m depend on c or ϕ. We alsowill write a propositional formula ψ in a special Disjunctive Normal Form (DNF(ψ, c)),where DNF(ψ, c) = π1 ∨ π2 ∨ · · · ∨ πd , each πj being a conjunction of literals over all theatoms occurring in ψ, and ordered along the sets At(ψ) ∩ At(c) and At(ψ) \ At(c). Thenwe can write any πj asˆcπj ≡ πjˇc∧ πj≡(cid:9)(cid:9)(cid:10)j (xg) ∧(cid:10)j (yh)g(cid:1)kh(cid:1)mGiven a conjunction π , and a coalition or agent c, we will hence write π ˇı for the con-junction of literals obtained from π by leaving out the x’s, and π ˆı for the conjunction ofπ without the y’s. Observe that hence we can interpret π ˆı as that part of π that is undercontrol of c, and π ˇı as the part out of c’s control. Sometimes, we will also use dnf (ψ),which is also a disjunctive normal form, but not necessarily containing all of ψ’s atoms.For instance, if ψ is the formula (p1 ∧ q) ∧ (p2 ∨ ¬p2) (p1, p2 ∈ At(C), q /∈ At(C)), thenDNF(ψ, C) = (p1 ∧ p2 ∧ q) ∨ (p1 ∧ ¬p2 ∧ q) while dnf (ψ) = (p1 ∧ q).The first main component of our completeness proof is Theorem 3.1. This resultstates that every CL-PC formula is equivalent to a formula of propositional logic. (Asan aside, note that this result does not imply that the modal language of CL-PC is re-dundant, since the translation from CL-PC involves an exponential blow-up in the sizeof the formula.) We prove Theorem 3.1 by way of two lemmas, which essentially showus how cooperation modalities can be eliminated from formulae, while preserving theirtruth.Lemma 3.3. Using the notation as introduced in Definition 4, let c be an agent or coalition,and let π ≡ π ˆc ∧ π ˇc also as specified there. Then:(cid:25)CL-PC πˇc ↔ (cid:6)c(πˆc ∧ πˇc)At first sight, it might seem strange that the equivalence in Lemma 3.3 has atoms on theright hand side which do not occur in the left hand side. The idea is simple though, andwill be used in many proof-steps that are to follow. Let us, given agent i, loosely refer toπ ˇı and π ˆı as literals in π that are out, or in the agent’s control, respectively. Then, i canachieve any combination of literals, as long as those out his control are already set in theright way. In an example: if i controls p1 and p2 but not p or q, then i can bring about(p1 ∧ ¬p2 ∧ p ∧ ¬q) in exactly those situations in which (p ∧ ¬q) is already true. Forcoalitions C, this works similarly.Proof. We first prove the displayed formula for the case that c is an agent i. For the rightto left direction, note that for any atom y /∈ Ati , we have(cid:25)CL-PC (cid:6)i(cid:10)(y) → (cid:10)(y)y /∈ Ati(4)One uses first non-effect(i) and then T (i) to see this. Then we derive (a)–(c):(a) : (cid:6)i(πˆı ∧ πˇı) → (cid:6)iπˇıW. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11997(cid:9)h(cid:1)m(b) : (cid:6)iπˇı → (cid:6)i(c) : (cid:6)i(cid:9)h(cid:1)m(cid:10)(yh) →(cid:10)(yh)(cid:9)h(cid:1)m(cid:10)(yh)Implication (a) is a property of any modal diamond, (b) uses the definition of π ˇı and (c)h(cid:1)m (cid:10)(yh) is by definition π ˇı , this proves the derivability of (cid:6)i(π ˆı ∧applies (4). Sinceπ ˇı) → π ˇı .(cid:10)For the other direction, first note that for any y not in Ati , we have(cid:25)CL-PC (cid:10)(y) → (cid:1)i(cid:10)(y)(5)(cid:25)CL-PC πh(cid:1)m (cid:10)(yh) → (cid:1)iwhich follows immediately from (4) and the fact that we are dealing with literals. By using(cid:10)modal logical laws, we then derive (cid:25)CL-PCˇı → (cid:1)iπ(6)Now let us write π as π ˇı ∧ π ˆı = π ˇı ∧ ((cid:10)(x1) ∧ (cid:10)(x2) ∧ · · · ∧ (cid:10)(xk)). By definition of π ˆıand π ˇı , we have x1 /∈ At(π ˇı). Also, by axiom T (i),(cid:12)ˇı ∧ (cid:10)(x1)h(cid:1)m (cid:10)(yh) and hence(cid:12)ˇı ∧ (cid:10)(x1)(cid:25)CL-PC→ (cid:6)i(cid:11)π(cid:11)π(7)(cid:10)ˇıand, by effect(i),(cid:25)CL-PC(cid:11)π(cid:12)ˇı ∧ (cid:10)(x1)Since π ˇı is equivalent to (π ˇı ∧ (cid:10)(x1)) ∨ (π ˇı ∧ ¬(cid:10)(x1)), we obtain from (7) and (8):(cid:12)ˇı ∧ ¬(cid:10)(x1)→ (cid:6)iπ(cid:11)(cid:25)CL-PC πˇı → (cid:6)i(cid:11)π(cid:12)ˇı ∧ (cid:10)(x1)(8)(9)Repeating the argument (7)–(9) we also obtain(cid:11)π(cid:11)π→ (cid:6)i(cid:25)CL-PC(cid:12)ˇı ∧ (cid:10)(x1)(cid:12)ˇı ∧ (cid:10)(x1) ∧ (cid:10)(x2)(10)Now note that (9) and (10) are of the form (cid:25)m π ˇı → (cid:2)ϕ1 and (cid:25)m ϕ1 → (cid:2)ϕ2, respectively,in which in any modal logic m one concludes (cid:25)m π ˇı → (cid:2)(cid:2)ϕ2. But in CL-PC we also have(cid:6)i(cid:6)iϕ → (cid:6)iϕ, so that we conclude, from (9) and (10),(cid:25)CL-PC πˇı → (cid:6)i(cid:11)π(cid:12)ˇı ∧ (cid:10)(x1) ∧ (cid:10)(x2)(11)Repeating the argument from (7)–(11) sufficiently many times, we conclude that (cid:25)CL-PCπ ˇı → (cid:6)i((cid:10)(x1) ∧ (cid:10)(x2) ∧ · · · ∧ (cid:10)(xk)), or, equivalently, (cid:25)CL-PC π ˇı → (cid:6)iπ ˆı . We combinethis with (6) to finally obtain (cid:25)CL-PC π ˇı → (cid:6)i(π ˆı ∧ π ˇı).Given that we now have proven what we want for c being an agent i, let us nowassume that c is a coalition C. Choose an arbitrary order of the members of C, sayiv, iv−1, . . . , i2, i1. Let the initial conjunction be π . Axiom Comp-∪ tells us that(cid:6)i1π(cid:25)CL-PC (cid:6)Cπ ↔ (cid:6)iv· · · (cid:6)i2(cid:6)iv−1(12)We now iteratively do the following. We construct a sequence of conjunctionsπ1, . . . , πv such that every πj +1 is πj with the literals over atoms from Atj left out. Let π198W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119ˇı1be π . The result for the single agent case tells us that (cid:25)CL-PC π1ˇı1↔ (cid:6)i1π1. Using this equivalence in (12), we obtain(cid:25)CL-PC π1↔ (cid:6)i1(πˆı11∧ πˇı11 ), i.e.,(cid:25)CL-PC (cid:6)Cπ ↔ (cid:6)iv(cid:6)iv−1Note that in (13), the formula πfrom Ati1 left out. Let π2 be the formula πˇı2(cid:25)CL-PC π2↔ (cid:6)i2π2 givingˇı11· · · (cid:6)i2πˇı11 is the conjunction πi with all the literals over atomsˇı11 . The single agent case again tells us that(13)(cid:25)CL-PC (cid:6)Cπ ↔ (cid:6)iv(cid:6)iv−1· · · (cid:6)i3πˇı22(14)ˇı22 is the conjunction π1 with the literals for agents i1 and i2 left out. We repeat thiswhere πargument v times to eventually conclude(cid:25)CL-PC (cid:6)Cπ ↔ πˇıvv(15)ˇıvv is the formula π1 with all the literals involving any of C’s atoms, left out. Inwhere πorder words, (15) says (cid:25)CL-PC (cid:6)Cπ ↔ π ˇc. (cid:1)Lemma 3.4. Let C be a coalition of agents, and ψ a propositional formula. Then thereexist a propositional formula α such that(cid:25)cl-pc α ↔ (cid:6)Cψ and At(α) ∩ AtC = ∅(cid:13)(cid:13)Proof. We know that ψ is propositional, so let us use the notation introduced in Defi-nition 4, and assume that DNF(ψ, C) = π1 ∨ · · · ∨ πd and that X = At(ψ) ∩ AtC , andY = At(ψ) \ X. As in any modal logic, we have(cid:25)CL-PC (cid:6)Cπj ↔(cid:6)Cπj(∗)j (cid:1)dj (cid:1)dBy Lemma 3.3, we moreover haveˇC(cid:25)CL-PC (cid:6)Cπj ↔ πj(∗∗)Note that the right hand side of (∗∗) is purely propositional. Combining (∗) and (∗∗), weˇChave (cid:25)CL-PC α ↔ (cid:6)Cψ where α is the formulaj ,At(α) ∩ AtC = ∅. (cid:1)ˇCj . Clearly, by definition of πj (cid:1)d π(cid:5)Example 3.2. Let us consider the formula (cid:6)iψ being (cid:6)i(p1 ∧ (p2 → p4)). Bringing ψ indnf gives (cid:6)i((p1 ∧ ¬p2 ∧ ¬p4) ∨ (p1 ∧ ¬p2 ∧ p4) ∨ (p1 ∧ p2 ∧ p4)). We consider thefollowing cases:(1) Ati = {p1, p2, p3, p4}. There are no atoms occurring in ψ that are not under the controlof agent i, so we get for α a disjunction of three occurrences of (cid:10), which equals (cid:10), sothat our agent can always bring about ψ.(2) Ati = {p1, p2}. Agent i can only toggle the atoms p1 and p2, so the states in which hecan bring about ψ are represented by ¬p4 ∨ p4 ∨ p4 which is equivalent to true: agenti can always bring about ψ!W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–11999(3) Ati = {p2}. Then he can bring about ψ in those worlds satisfying (p1 ∧ ¬p4) ∨ (p1 ∧p4) ∨ (p1 ∧ p4), which is equivalent to p1.(4) Ati = {p3}. Then i can bring about ψ only in those situations in which ψ is alreadytrue (i.e., α = ψ), which is as expected.Note that Lemma 3.4 implies that every formula (cid:1)Cψ is also equivalent to a proposi-tional formula. Let X and Y again be the atoms in and out of control of C, respectively.This time, write ψ in Conjunctive Normal Form CNF(ψ, C) = δ1 ∧ · · · ∧ δd , each δj of theˇCˆCform δj . As anjexample, suppose that CNF(ψ, C) = (p1 ∨ ¬p2 ∨ q1 ∨ ¬q2) ∧ (p1 ∨ p2 ∨ ¬q1 ∨ q2), andthat p1, p2 ∈ At(C), but q1, q2 /∈ At(C). Then C cannot avoid that ψ is true in those caseswhere both (q1 ∨ ¬q2) and (¬q1 ∨ q2) are true.h(cid:1)m (cid:10)j (yh). We then get that (cid:1)Cψ ≡g(cid:1)k (cid:10)j (xg) ∨j (cid:1)d δ∨ δˇCj(cid:5)(cid:5)(cid:10)≡In fact, Lemma 3.4 gives us a constructive way to find the propositional formula α,given the coalition C and DNF(ψ, C) = πi ∨ · · · ∨ πk for ψ. Let us, for future reference,define this α as F (C, ψ).Theorem 3.1 (Normal forms). Every formula ϕ is equivalent in CL-PC to a propositionalformula.Proof. Consider the following translation T .T ((cid:10)) = (cid:10)T (p) = pT (¬ϕ) = ¬T (ϕ)T (ϕ ∧ ψ) = T (ϕ) ∧ T (ψ)(cid:12)(cid:11)T ((cid:6)Cϕ) = FC, T (ϕ)From the definition of T and Lemma 3.4, it is clear that ϕ is equivalent to T (ϕ). Moreover,it is easy to see that T (ϕ) is a propositional formula. (cid:1)Example 3.3. Again, we consider the formula ϕ which in dnf is ((p1 ∧ ¬p2 ∧ ¬p4) ∨ (p1 ∧¬p2 ∧ p4) ∨ (p1 ∧ p2 ∧ p4)). We are interested in finding the propositional equivalent of(cid:6)1(cid:6)2ϕ. We consider the following cases:(1) At2 = {p1, p2, p4}, At1 = {p3}. There are no atoms occurring in ϕ that are not undercontrol of agent 2, so we get as the translation of (cid:6)2ϕ the formula (cid:10), and the translationof (cid:6)1(cid:10) is (cid:10).(2) At2 = {p1, p2}. We know from Example 3.2 that T ((cid:6)2ϕ) = (cid:10), giving also (cid:10) forT ((cid:6)1(cid:6)2ϕ).(3) At2 = {p2}. Then 2 can bring about ϕ in those worlds satisfying p1 (see Example 3.2).So, in case p1 ∈ At1, we have that (cid:6)1(cid:6)2ϕ ≡ (cid:10), saying that the coalition {1, 2} canalways bring about ϕ, but if p1 /∈ At1, the formula (cid:6)1(cid:6)2ϕ is equivalent to p1, indicatingall situations in which {1, 2} can bring about ϕ.100W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119(4) At2 = {p3}. Then i can bring about ϕ only in those situations in which ϕ is alreadytrue, and we can use the analysis of Example 3.2 to reason about (cid:6)1(cid:6)2ϕ, since it isequal to (cid:6)1ϕ.Corollary 3.1. Let ϕ be an arbitrary formula, and MI a propositional model based on apartition I . Then: MI |=d (cid:1)Agϕ iff there is a propositional formula ψ for which |=dI ϕ ↔ψ and ψ being a propositional tautology.We can now move on to the main stage of our proof. We employ a canonical modelconstruction, and assume some familiarity with this approach in what follows:3 in par-ticular, we assume some understanding of the standard definition of maximal consistentsets, Lindenbaum’s lemma [18, pp. 18–20], and the use of these in the canonical modelconstruction [18, pp. 22–23].Definition 5 (Canonical model). We define the canonical model Kcan for CL-PC as Kcan =(cid:7)W can, Rcan, . . . , Rcann , Θ can(cid:8), where:1• W can is the set of CL-PC maximal consistent sets;• Rcan• Θ can(Γ )(p) = tt iff p ∈ Γ .i Γ ∆ iff for all ϕ: ϕ ∈ ∆ ⇒ (cid:6)iϕ ∈ Γ .Lemma 3.5. The canonical model Kcan defined in Definition 5 is isomorphic to the Kripkemodel K of Definition 2. More precisely, there exists a bijective function f : W can → Wsuch that:(1) for all Γ ∈ W can and p ∈ At: Θ can(Γ )(p) = tt iff Θ(f (Γ ))(p) = tt,(2) Rcani Γ ∆ iff Rif (Γ )f (∆).Proof. Theorem 3.1 tells us that any CL-PC formula is equivalent to a propositional for-mula. Since we assumed a finite number of propositional atoms, there are finitely manypropositional formulas. It follows that for world Γ ∈ W can there is a corresponding worldwΓ in the Kripke model K which exactly satisfies the literals in Γ . It is also the case thatfor every valuation wΓ in K, there is a corresponding world Γ in W can. Let us call thisisomorphism f : W can → W , where W can is the domain of the canonical model, and W isthe domain of the Kripke model K, as defined in Definition 2. Define f formally asfor the unique wΓ such that for all p (p ∈ Γ ⇔ wΓ (p) = tt)f (Γ ) = wΓ ,This is a bijection: first of all, every world w is the image of some Γ ∈ W can. More-over, suppose that Γ (cid:18)= ∆. To show that f (Γ ) (cid:18)= f (∆), suppose the latter is not the case:f (Γ ) and f (∆) coincide. This means that Γ and ∆ contain exactly the same literals, and,since they are maximal consistent sets, also the same objective formulas. But, by Theo-rem 3.1 then, they contain the same LC-PC formulas, i.e., Γ = ∆, contradicting our initialassumption, hence f (Γ ) (cid:18)= f (∆).3 See [11, pp. 59–61], [9, pp. 196–201], or [18, pp. 22–25] for introductions.W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119101It is obvious, by construction of f , that Θ can(Γ ) and Θ(f (Γ )) agree on all atoms. Thisproves item 1.Now we have to show that the definition of Rcanthat of Ri in the Kripke model K, or, more precisely, thatiin the canonical model corresponds toRicanΓ ∆ iff(cid:15)(cid:14)f (Γ ) = f (∆) (mod Ati)To prove the displayed equivalence, suppose first that Rcani Γ ∆, and, to derive a contra-diction, that f (Γ ) (cid:18)= f (∆) (mod Ati). The latter means that there is an atom p ∈ (At \ Ati),such that for some literal (cid:10)(p), we have (cid:10)(p) being false under the valuation f (Γ ),but (cid:10)(p) being true under f (∆). By the first item of this lemma, we know that thenthen yields that (cid:6)i(cid:10)(p) ∈ Γ . But this is impos-(cid:10)(p) /∈ Γ, (cid:10)(p) ∈ ∆. The definition of Rcansible, since (cid:6)i(cid:10)(p) ∈ Γ implies (use non-effect(i)) (cid:1)i(cid:10)(p) ∈ Γ , which, by T (i), implies(cid:10)(p) ∈ Γ , in contradiction with what was derived earlier.iFor the other direction, assume that [f (Γ ) = f (∆) (mod Ati)]. Let ϕ be an arbitraryformula in ∆: we have to show that (cid:6)iϕ in Γ . Let π be the conjunction of all the literalsin ∆. This is the strongest propositional formula in ∆, and, by Theorem 3.1, the strongestformula in it. Hence we have (cid:25)cl-pc π → ϕ. We can write π as a conjunction (π ˆı ∧ π ˇı), inwhich π ˆı is the conjunction over all (cid:10)(p) with p ∈ Ati , and π ˇı a conjunction of (cid:10)(pi), withpi /∈ Ati . Since f (Γ ) = f (∆) (mod Ati), we have that π ˇı ∈ Γ . By Lemma 3.3, we knowthat (cid:25)cl-pc π ˇı → (cid:6)i(π ˆı ∧ π ˇı), and hence (cid:6)i(π ˆı ∧ π ˇı) ∈ Γ . But then, by definition of π ,we have (cid:6)iπ ∈ Γ and hence (cid:6)iϕ ∈ Γ .This completes the proof that the models K and Kcan are isomorphic, and hence verifythe same formulas. (cid:1)We now come to our main completeness result. (For readability, we suppress the set ofagents Ag, the set of atoms At and the partition I of At over Ag, which should be the samein all cases.)Theorem 3.2 (Completeness). The following are equivalent, for any formula ϕ.(i) ϕ is CL-PC-consistent;(ii) ϕ is true in one of the worlds of the canonical model Kcan (see Definition 5);(iii) ϕ is true in one of the worlds of K (see Definition 2);(iv) ϕ is true in some propositional model M (see Definition 1).Proof. Let ϕ be consistent. Then it is contained in a maximal consistent set Γ . Theconstruction of the canonical model is standard, as is the proof of its coincidence prop-erty: Kcan, ∆ |= ψ iff ψ ∈ ∆ (see, e.g., [9, pp. 196–201]). From this, it follows thatKcan, Γ |= ϕ, and hence this proves (i) implies (ii). The other direction follows fromLemma 3.1. Lemma 3.5 states that items (ii) and (iii) are equivalent, and the equivalenceof (iii) and (iv) is guaranteed by Lemma 2.4. (cid:1)102W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–1194. Varieties of ability and controlIn the introduction to this paper, we claimed that contingent ability, as captured in our“(cid:6)···” cooperation modalities, was sufficient to define other, richer (and arguably morerealistic) types of ability and control. Our aim in this section is to justify this claim. Webegin by showing how contingent ability may be used to define α- and β-ability modalities.In Section 4.2, we go on to show how the notion of control may be characterised in CL-PC.4.1. Characterising alpha and beta abilityAs we noted above, the cooperation modality (cid:6)··· is not strategic. That is, a formula(cid:6)Cϕ simply means that the coalition C have some choice available to them, such thatif they make this choice and nothing else changes, then ϕ will be true. But of course,multiagent encounters are typically strategic in nature, where the decision that one agentshould make depends on the decisions that other agents may make. In this section, we showhow it is possible to define strategic cooperation modalities in terms of CL-PC constructs.In the study of coalitional ability, the most common form of strategic capability stud-ied is known as α-ability, or “ ∃∀ ”-capability (see, e.g., [37, pp. 311–312]). Intuitively, acoalition C is said to have α-ability for some proposition ϕ if there exists a choice σC forC such that, for all choices σC for C, if C make choice σC and C make choice σC , thenϕ will be true. (Note the “ ∃∀ ” pattern of quantifiers in this definition.) In other words, Chaving the α-ability to bring about ϕ means that C have a choice such that, no matter whatthe other agents do, if they make this choice, then ϕ will be true. This notion of cooperativeability typically forms the semantic basis of cooperation modalities [36].Implicit within the notion of α-ability is the fact that C have no knowledge of the choicethat the other agents make; they are not allowed to see the choice of C and then decide whatto do, but rather they must make their decision first. This motivates the notion of β-ability(i.e., “ ∀∃ ”-ability): coalition C is said to have the β-ability for ϕ if for every choice σCavailable to C, there exists a choice σC for C such that if C choose σC and C choose σC ,then ϕ will result. Thus C being β-able to ϕ means that no matter what the other agentsdo, C have a choice such that, if they make this choice, then ϕ will be true. Note the “ ∀∃ ”pattern of quantifiers: C are implicitly allowed to make their choice while being aware ofthe choice made by C.It is easy to see that both α- and β-ability represent stronger notions of ability thanthat in the basic cooperation modalities of CL-PC. But using the cooperation modalities ofCL-PC, we can in fact define coalition modalities “(cid:7)(cid:7)· · ·(cid:8)(cid:8)α” and “(cid:7)(cid:7)· · ·(cid:8)(cid:8)β ” capturing α andβ-ability respectively, and of course their duals, “(cid:1)· · ·(cid:2)α” and “(cid:1)· · ·(cid:2)β ”.(cid:7)(cid:7)C(cid:8)(cid:8)αϕ ˆ= (cid:6)C(cid:1)Cϕ(cid:7)(cid:7)C(cid:8)(cid:8)β ϕ ˆ= (cid:1)(cid:6)CϕC(cid:1)C(cid:2)αϕ ˆ= ¬(cid:7)(cid:7)C(cid:8)(cid:8)α¬ϕ(cid:1)C(cid:2)β ϕ ˆ= ¬(cid:7)(cid:7)C(cid:8)(cid:8)β ¬ϕW. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119103As an aside, the double bracket notation, “(cid:7)(cid:7)· · ·(cid:8)(cid:8)” it motivated by its use in ATL [5]:the derived modality (cid:7)(cid:7)· · ·(cid:8)(cid:8)α is very close to the ATL “next” cooperation modality, written(cid:7)(cid:7)· · ·(cid:8)(cid:8) (cid:2).One may wonder whether definitions like those given above cannot be used in arbitrarycoalition logics, such as ATL. However, the fact that we can “reduce” α- and β-ability tothe contingent ability is due to the fact that our system is basically asynchronous. Thatis, the effect of the agents’ choices are independent of each other—the effect of a group’sdecision is exactly the sum of the effects of its individuals. Expressed more precisely:for any coalition C = {c1, . . . , ck}, any ability formula (cid:6)Cϕ can always be rewritten as· · · (cid:6)ck ϕ, expressing that the actions of the agents do not interfere with each other,(cid:6)c1and group actions can always be unravelled as a sequence of individual actions.(cid:6)c2Let us consider the relationships between the various types of ability introduced in thispaper. First, note that we have the following equivalence.(cid:7)(cid:7)C(cid:8)(cid:8)β ϕ ˆ= (cid:1)C↔ (cid:1)C↔ (cid:1)Ag(cid:6)Cϕ(cid:6)Cϕ(cid:1)C(cid:6)CϕSecondly, (cf. T (C)), we have both |=d (cid:7)(cid:7)C(cid:8)(cid:8)αϕ → (cid:6)Cϕ and |=d (cid:7)(cid:7)C(cid:8)(cid:8)β ϕ → (cid:6)Cϕ.At the global level, β-ability and contingent ability collapse: saying that, for a givenpartition of atoms among agents, the coalition C have the β-ability to achieve ϕ is thesame as saying that they have the contingent ability to achieve ϕ in every situation basedon this partition. More formally, we have the following equivalence.|=dI(cid:7)(cid:7)C(cid:8)(cid:8)β ϕ ⇔ |=dI(cid:6)Cϕ(16)However, note that α- and β-ability are distinct at the global level. Formally, we have thefollowing.|=dI(cid:7)(cid:7)C(cid:8)(cid:8)αϕ(cid:18)⇔ |=dI(cid:7)(cid:7)C(cid:8)(cid:8)β ϕlet {p} = AtC . Then we have |=dI(cid:7)(cid:7)C(cid:8)(cid:8)β (p ↔ q), but obviously not(cid:7)(cid:7)C(cid:8)(cid:8)α(p ↔ q). Instead, we get the following implications between the different typesTo see this,|=dIof ability.|=dI|=dI(cid:7)(cid:7)C(cid:8)(cid:8)αϕ → (cid:7)(cid:7)C(cid:8)(cid:8)β ϕ(cid:7)(cid:7)C(cid:8)(cid:8)β ϕ → (cid:6)Cϕ(17)(18)Given that the definition of the α cooperation modalities more closely resembles thoseof Pauly’s coalition logic, the following question arises: To what extent does Pauly’saxiomatization of Coalition Logic carry over to CL-PC with α cooperation modalities?Consider the following axioms, which are just Pauly’s axioms for Coalition Logic trans-lated directly into CL-PC (see [36, pp. 54–56]).(α-N⊥) ¬(cid:7)(cid:7)Ag(cid:8)(cid:8)α⊥(α-(cid:10))(α-⊥)(cid:7)(cid:7)∅(cid:8)(cid:8)α⊥ → (cid:7)(cid:7)C(cid:8)(cid:8)α(cid:10)(cid:7)(cid:7)C(cid:8)(cid:8)α⊥ → (cid:7)(cid:7)C(cid:19)(cid:8)(cid:8)α⊥ (C(cid:19) ⊆ C)104W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119(α-N)(α-S)¬(cid:7)(cid:7)∅(cid:8)(cid:8)α¬ϕ → (cid:7)(cid:7)Ag(cid:8)(cid:8)αϕ(cid:11)(cid:12)(cid:7)(cid:7)C1(cid:8)(cid:8)αϕ ∧ (cid:7)(cid:7)C2(cid:8)(cid:8)αψ→ (cid:7)(cid:7)C1 ∪ C2(cid:8)(cid:8)α(ϕ ∧ ψ)(C1 ∩ C2 = ∅)We have the following.Theorem 4.1. Axiom schemes (α-N⊥), (α-(cid:10)), (α-⊥), (α-N), and (α-S) may all be de-rived within the axiom system CL-PC.Proof. See Appendix B. (cid:1)4.2. Characterising controlIn this section, we address ourselves to the problem of characterising the circumstancesunder which a coalition controls some state of affairs. We begin with the following obser-vation: Control is closely related to ability, but it is not the same thing. For, consider anypropositional tautology (cid:10). According to all of the definitions of ability we have consideredthus far, any coalition (even ∅) can achieve (cid:10). But we would not be inclined to take seri-ously any coalition that claimed to control (cid:10)—this would be rather like claiming to controlthe heavens just because the sun happened to rise every morning. So, being able to controlsome state of affairs ϕ means not just being able to achieve ϕ, it also means being able toachieve ¬ϕ. This motivates the following.Definition 6 (Contingent control). Where C is a coalition and ϕ is a formula of CL-PC, wewrite controls(C, ϕ) to mean that C can choose ϕ to be either true or false:controls(C, ϕ) ˆ= (cid:6)Cϕ ∧ (cid:6)C¬ϕThe following result suggests that this definition seems to be operating at least partly inthe way intended: by using the controls(. . .) connective, we can capture the distribution ofpropositions among agents in a model.Lemma 4.1. Let M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) be a model for CL-PC, i ∈ Ag be an agent,and p ∈ At be a propositional variable in M. Then:M |=d controls(i, p)iff p ∈ AtiProof. For the left-to-right implication, assume M |=d controls(i, p). Then there are twocases to consider: where θ (p) = ff and θ (p) = tt. Consider the first case. Since M |=dcontrols(i, p), there exists an i-valuation θi such that M ⊕ θi |=d p. Since M differsfrom M ⊕ θi only in the values it assigns to variables in the domain of θi , it followsthat p ∈ dom θi , and hence p ∈ Ati . The second case is essentially identical. For the right-+−to-left implication, assume p ∈ Ati , and consider any two i-valuations θi and θi such that++i (q) = θi(q) = θ −(q). Clearly,i (p) = tt and θθ|=d ¬p, so M |=d (cid:6)ip ∧ (cid:6)i¬p, and hence by definition+M ⊕ θiM |=d controls(i, p). (cid:1)−i (p) = ff, but on all atoms q (cid:18)= p, θ|=d p and M ⊕ θ−iW. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119105In other cooperation logics, there is not much we can really say about when a coalitioncontrols some state of affairs: either it controls it, or it does not control it. However, withCL-PC, we have more information to go on: we know that propositional variables are con-trolled by agents. We can use this structure to extract some general rules with respect towhen a coalition controls a formula, in terms of the logical structure of that formula, thepropositional variables that make up the formula, and the variables that are controlled bythe coalition in question. So, we will now consider the issue of how we might generaliseLemma 4.1 to arbitrary formulas ϕ.First of all, note that the fact that controls(i, ϕ) is true, does not mean that At(ϕ) ⊆ Ati .As a counterexample, suppose that p is true, and Ati = {q}. Then obviously controls(i, p ∧q), but At(p ∧ q) = {p, q} (cid:18)⊆ {q} = Ati . This example also shows that although the set Ati isdefined independently of the actual valuation θ in M, whether i controls ϕ may depend onthe specific θ , since in the above example controls(i, p ∧ q) would not have been true in amodel M(cid:19) in which p was false. Secondly, the fact that At(ϕ) ⊆ Ati does not guarantee thati controls ϕ, for which (p ∨ ¬p) for agent i with Ati = {p} is a witness. In order for anycoalition C to control ϕ, the formula ϕ must be a contingency, i.e., neither a contradictionnor a tautology. Conversely, if ϕ is a contingent formula, the grand coalition Ag controls it:Observation 4.1. Let I be a partition At1, . . . , Atn of the atoms At. Then, for every for-mula ϕ:|=dI controls(Ag, ϕ)iff((cid:18)|=dI ϕ and (cid:18)|=dI¬ϕ)Proof. From left to right is obvious, so assume ϕ is contingent and let the model MIbe (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8). Then, for some M(cid:19)= (cid:7)Ag, At, At1, . . . , Atn, θ (cid:19)(cid:8) and for someIM(cid:19)(cid:19)= (cid:7)Ag, At, At1, . . . , Atn, θ (cid:19)(cid:19)(cid:8) we have M(cid:19) |=d ϕ and M(cid:19)(cid:19) |=d ¬ϕ. Note that we haveIθ = θ (cid:19) (mod At) and θ = θ (cid:19)(cid:19) (mod At), which finishes the proof. (cid:1)To appreciate the relevance of a fixed partition I in Observation 4.1, note that in theI are based on the same partition I . Indeed, weI and M(cid:19)(cid:19)proof, the two obtained models M(cid:19)have the following non-equivalence:|=d controls(Ag, ϕ)(cid:18)⇔ ((cid:18)|=d ϕ and (cid:18)|=d ¬ϕ)(19)Although from left to right is a valid implication, here is a witness that refutes the right toleft direction: take for ϕ the formula controls(i, p). From Lemma 4.1, we know that thisformula is true in a model M iff p ∈ Ati . Obviously, there are partitions I for which this isthe case, and others, for which it is not, from which we see that the right hand side of (19)is true. However, at the same time, (cid:18)|=d controls(Ag, controls(i, p)), because, in an arbitrarymodel MI based on a partition I , we either have p ∈ Ati (in which case |=dI controls(i, p))or p /∈ Ati (giving |=d¬controls(i, p)). In both cases, by Observation 4.1, we haveI(cid:18)|=dI controls(Ag, controls(i, p)) and hence, by the counterpart in the direct semantics of(3) and Corollary 2.2, (cid:18)|=d controls(Ag, controls(i, p)).We now consider the more general question of when a coalition C controls a formula ϕ.We settle it first for the case with a fixed partition (in what follows, we use some notationand terminology that was introduced in Section 3).106W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119Let us begin with an attempt that does not work. We cannot generalise Observation 4.1to the following:Let I be a partition At1, . . . , Atn of the atoms At. Then, for every formula ϕ and everycoalition C, |=d(cid:11)(cid:18)|=dI controls(C, ϕ) iff:(cid:19) :|=d(cid:12)) ⊆ At(C)(cid:19) ↔ ϕ) and At(ϕ¬ϕ and ∃ϕ(cid:19)I ϕ and (cid:18)|=dII (ϕAlthough the only if direction holds, a counterexample for the if direction is the formulacontrols(i, (pi ↔ q)), At(i) = {pi}. We do have the following, however.Theorem 4.2. Let C be a coalition, ϕ a formula, and MI = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8) apropositional model. Then: MI |=d controls(C, ϕ) iff there exists a propositional formulaψ with the following properties:I ψ ↔ ϕ;(a) |=dˆC(b) Let DNF(ψ, C) equal (π1Then, for some j (cid:1) d:(b1) MI |=d π(b2) There is some (cid:10)(X) = (cid:10)(x1) ∧ · · · ∧ (cid:10)(xk) such that (cid:10)(X) ∧ πˆCˇC1 )∨· · ·∨(πdˇCd ) with At(πˇCj ;∧π∧πDNF(ψ, C).ˆCj ) = X = At(ψ)∩At(C).ˇCj does not occur inˇCˇCj ) → ¬ϕ. But since πjˇCj . By soundness,ˆCj ), and hence MI |=d (cid:6)Cϕ. We also haveis alreadyProof. Suppose that (a) and (b) are true, then we have that MI |=d πˇCand Lemma 3.3, we have MI |=d (cid:6)C(π∧ πjˇC(cid:25)CL-PC ((cid:10)(X) ∧ πI ((cid:10)(X) ∧ πj ) → ¬ϕ and thus |=dˇCtrue in MI , and all the atoms in (cid:10)(X) belong to C, we have MI |=d (cid:6)C((cid:10)(X) ∧ πj ),and hence MI |=d (cid:6)C¬ϕ. Conversely, suppose MI |=d controls(C, ϕ), i.e., MI |=d (cid:6)Cϕand MI |=d (cid:6)C¬ϕ. By Lemma 3.3, we find a ψ such that |=dI ψ ↔ ϕ, and X and Y asˇC . The model MI must decideusual, with DNF(ψ, C) =on one of the disjunctions, i.e., for some πj (j (cid:1) d), we have MI |=d πj , i.e., MI |=dˇCˆCπj in DNF(ψ, C).jˇCBy propositional reasoning, we then obtain that (cid:25)CL-PC π→ ϕ, and, by necessitationjˇCˇCˇCand soundness, |=d (cid:1)C(πj , and πjjˇCis already true in MI , we have MI |=d (cid:1)Cπj . All in all, we see that MI |=d (cid:1)Cϕ. Butthis is in contradiction with MI |=d (cid:6)C¬ϕ, and hence not every combination (cid:10)(X) occursas (cid:10)(X) ∧ πˇCj . Now, suppose that every combination (cid:10)(X) occurs as (cid:10)(X) ∧ π→ ϕ). Since C has no control over the atoms in πi(cid:1)d πi , each πi of type πˇCj in DNF(ψ, C). (cid:1)ˆC ∧ π∧ π(cid:5)This notion of control still has a local flavour: if an atom p ∈ Ati and q /∈ Ati , for in-stance, then controls(i, p ∧ q) would be true in a model M for which M |=d q, but not inmodels M(cid:19) for which M(cid:19) |=d ¬q. In fact, the formulas that are globally under control of acoalition C have a very natural determination, for a fixed interpretation I :W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119107Theorem 4.3. Let C be a coalition, ϕ a formula, and I a fixed partition of At. Then:|=dI controls(C, ϕ) iff there exists a propositional formula ψ with the following properties:(a) |=dI ψ ↔ ϕ;(b) Let DNF(ψ, C) be(cid:5)inˇCDNF(ψ, C), there is an conjunction (cid:10)(X) over literals in X such that (cid:10)(X) ∧ πjdoes not occur in DNF(ψ, C).j (cid:1)d πˆCj (cid:1)d (πj∧ πˇCj ). Then |=dIˇCˇCj and for every πj(cid:5)Proof. Immediately from Theorem 4.2. (cid:1)Corollary 4.1. |=d controls(C, ϕ) iff for every partition I of At, the conditions (a) and (b)of Theorem 4.3 are met.Note that two formulas (cid:6)Cϕ and (cid:6)C(cid:19) ϕ(cid:19) can be equivalent, while on the one hand Ccontrols ϕ, but C(cid:19) need not control ϕ(cid:19): we have for instance controls(Ag, p), for any p, butnot controls(C, (cid:6)Cp), even though (cid:6)Agp and (cid:6)C(cid:6)Cp are equivalent.It seems that rather than the local notion of control, the notion of Theorem 4.3 is themore interesting one. It has a local counterpart, though, inspired by (2). Let us say that acoalition C fully controls a property ϕ in M, notation M |=d Controls(C, ϕ), if M |=d(cid:1)Agcontrols(C, ϕ). We then obtain (where M is based on partition I ):M |=d Controls(C, ϕ)iff|=dI controls(C, ϕ)(20)5. Model checking and satisfiabilityWhenever one considers reasoning within some logic, there are two basic problems thatone must address: model checking and satisfiability checking. Model checking is the prob-lem of determining, for any given model and formula, whether the formula is satisfied bythe model; the satisfiability problem, in contrast, asks whether there is any way a givenformula could be satisfied. For many modal and temporal logics, the model checking prob-lem is computationally easy when compared to the satisfiability checking problem, and forthis reason there is currently much interest in reasoning via model checking, rather thansatisfiability checking (see, e.g., [12,15,20] for discussions).In this section, we characterise the complexity of these two problems with respect to CL-PC. We show that, in fact, their complexity coincides: both problems are PSPACE-complete.Note that in the remainder of this section, we are assuming the use of the direct semantics.5.1. Model checkingWe begin by considering model checking for CL-PC. Formally, the decision problem isas follows.108W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119function eval(ϕ, (cid:7)Ag, At, At1, . . . , Atn, θ(cid:8)) returns tt or ffif ϕ ∈ At thenreturn θ(ϕ)elsif ϕ = ¬ψ then1.2.3.4.5.6.7.8.9.10.11.12.13.14.endif15. end-functionend-forreturn ffreturn not eval(ψ, (cid:7)Ag, At, At1, . . . , Atn, θ(cid:8))elsif ϕ = ψ1 ∨ ψ2 thenreturn eval(ψ1, (cid:7)Ag, At, At1, . . . , Atn, θ(cid:8))or eval(ψ2, (cid:7)Ag, At, At1, . . . , Atn, θ(cid:8))elsif ϕ = (cid:6)C ψ thenfor each C-valuation θCif eval(ψ, (cid:7)Ag, At, At1, . . . , Atn, θ(cid:8) ⊕ θC ) then return ttFig. 4. A polynomial space model checking algorithm for CL-PC.CL-PC MODEL CHECKING:Instance: CL-PC model M and formula ϕ.Answer: “Yes” if M |=d ϕ, “no” otherwise.Theorem 5.1. The CL-PC MODEL CHECKING problem is PSPACE-complete.Proof. For membership of PSPACE, consider the algorithm presented in Fig. 4.4 Par-tial correctness—that is, eval(ϕ, M) = tt iff M |=d ϕ—is by an easy induction on thestructure of formulae. Termination follows from the fact that the algorithm is recursivelyanalytic (i.e., the only recursive calls are on strict sub-formulae) with atomic propositionsbeing the recursive base. The loop in lines 10–12 clearly terminates as there are finitelymany C-valuations. With respect to the space requirements of the algorithm, for an inputformula ϕ, the algorithm will require at most |ϕ| recursive calls. A recursive call requiresno more space than the original input instance, and since there are at most |ϕ| recursivesteps, the recursion stack will require space at most polynomial in the size of the originalinput instance. Note that the loop in lines 10–12 merely involves binary counting using thepropositional variables AtC . Thus, the algorithm requires only space polynomial in |ϕ|.To show PSPACE hardness, we reduce QSAT [35, p. 456] to the CL-PC model checkingproblem. An instance of QSAT is given by a quantified Boolean formula in prenex normalform:∃x1, ∀x2, ∃x3, . . . , Qmxm · ϕ(x1, x2, x3, . . . , xm)(21)where x1, x2, x3, . . . , xm are propositional variables, the quantifier Qm is “∃” if m is oddand “∀” otherwise, and ϕ(x1, x2, x3, . . . , xm) is a propositional logic formula (the ma-trix) over x1, x2, x3, . . . , xm. The goal is to determine whether this formula is true: thatis, whether there is some value for x1 such that for all values of x2, there is some value for4 Note that we are not presenting this as a practical algorithm for model checking—its purpose is merely toestablish membership in PSPACE.W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119109x3 such that, . . . , such that the matrix ϕ(x1, x2, x3, . . . , xm) is true under this valuation. Wecan create an instance of the CL-PC model checking problem from an instance (21) as fol-lows. To create the model M = (cid:7)Ag, At, At1, . . . , Atn, θ (cid:8), set At = {x1, . . . , xm}, and createan agent ai for each quantifier Qi . Then set Ati = {xi}. Finally, define θ by θ (xi) = ff forall xi ∈ At. (In fact, the valuation θ could be set to anything—it makes no difference.) Thendefine the input formula to the model checking problem to be(cid:6)a1(cid:1)a2(cid:6)a3· · · {am} ϕ(x1, x2, x3, . . . , xm)(22)where the final cooperation modality, (i.e., {am}), is (cid:6)am if m is odd and (cid:1)am if m iseven. We claim that this formula is satisfied in the model we have created iff the inputformula (21) is true: the result follows immediately from the semantics of (cid:6)··· and (cid:1)···and the allocation of variables to agents. Hence the model checking problem for CL-PC isPSPACE-hard, and we conclude that it is PSPACE-complete. (cid:1)For readers familiar with the literature on model checking for cooperation logics, thisresult may seem surprisingly negative. After all, the two closest relatives to CL-PC (i.e.,Pauly’s coalition logic [36–38] and ATL [5]) both have tractable (polynomial time) modelchecking problems. Closer examination gives an explanation. The ATL model checkingproblem may be solved in time O(|M| · |ϕ|), where |M| is the size of the model M againstwhich the formula is to be checked, and |ϕ| is the size of the formula that is to be checked.However, models for ATL (and Coalition Logic) are more like our Kripke structures forCL-PC than the direct semantic models we use. That is, they are assumed to contain anexplicitly enumerated set of states corresponding to the possible situations that agents maycooperate to bring about—and in general, this set of states will be exponentially large in thenumber of agents and the number of propositional atoms. In contrast, our (direct) modelsfor CL-PC are exponentially more succinct—the fact that the model checking problem forATL and Coalition Logic appear to be tractable is thus only part of the story.The distinction between succinct specification and explicit enumeration of states ofmodels in model checking, and the effect that this has on the apparent complexity of modelchecking, has been noted elsewhere—see [41] for a detailed discussion. Donini and col-leagues show how SMV, the well-known symbolic model checker for CTL, can be used toefficiently solve quantified boolean formulae (QBF), a well-known PSPACE-complete prob-lem [13]. This is despite the fact that CTL model checking, like ATL and Coalition Logicmodel checking, can ostensibly be done in polynomial time [12,15]. The explanation forthe fact that an apparently polynomial time algorithm for CTL model checking can be usedto efficiently solve PSPACE-complete problems is exactly the same as that of the PSPACE-completeness of CL-PC model checking: the CTL model checking algorithm works in timepolynomial in the number of states, but the model specification language used in SMVallows an extremely succinct description of this state set.It is worth noting that our result suggests that the actual complexity of ATL modelchecking (i.e., the complexity of the problem that the MOCHA model checker solves) ismuch higher than the apparent complexity of the explicit state model checking problem.Our result suggests it is at least PSPACE-hard, and may be worse.110W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–1195.2. Satisfiability checkingThe next problem we consider is that of satisfiability checking: the problem of deter-mining whether or not there is any way a given CL-PC formula could be true. Note that, forATL, the satisfiability problem is EXPTIME-complete [14], whereas for Coalition Logic, thecomplexity of the satisfiability problem varies from NP-complete up to PSPACE-complete,depending on the variation considered [36, pp. 73–75].CL-PC SATISFIABILITY CHECKING:Instance: CL-PC formula ϕ.Answer: “Yes” if ϕ is satisfiable, “no” otherwise.Theorem 5.2. The CL-PC SATISFIABILITY problem is PSPACE-complete.Proof. Given a formula ϕ of CL-PC, the following non-deterministic algorithm decideswhether it is satisfiable:(1) Guess a model M such that size(M) = |Ag(ϕ)| + |At(ϕ)| + 1.(2) Verify that M |=d ϕ.Step (1) can be done in (non-deterministic) polynomial space, and by Theorem 5.1, step (2)can be done in polynomial space. Moreover, by Corollary 2.1, if ϕ is satisfiable, then it issatisfiable in a model of the type guessed in step (1). Hence the problem is in NPSPACE,and since NPSPACE = PSPACE, the problem is in PSPACE.To establish PSPACE hardness, we will reduce QSAT to CL-PC SATISFIABILITY (recallthe definition of QSAT from Theorem 5.1). The idea of the reduction is basically the sameas that of Theorem 5.1, but as we have no model to check against, we must add a sidecondition to the formula (22) that we create to ensure the correct distribution of controlledpropositions amongst agents. Thus, given an instance (21) of QSAT, the instance of CL-PCSATISFIABILITY that we create is as follows.(22) ∧m(cid:9)i=1controls(ai, xi)(23)Now, by Lemma 4.1, in any model that satisfies (23), proposition xi will be under thecontrol of agent ai . We now claim that (23) is satisfiable iff the QSAT instance (21) istrue. The result again follows immediately from the semantics of (cid:6)··· and (cid:1)···. The CL-PC SATISFIABILITY problem is thus PSPACE-hard, and as we proved above that it is inPSPACE, we conclude it is PSPACE-complete. (cid:1)6. Related workOver the past three decades, researchers from many disciplines have attempted to de-velop a general purpose logic of ability. Within the artificial intelligence (AI) community,it was understood that such a logic could be used in order to gain a better understanding ofW. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119111STRIPS-style AI planning systems [2,17,28]. The most notable early effort in this directionwas Moore’s dynamic epistemic logic [29,30]. Moore was particularly interested in captur-ing some of the interactions between knowledge, action, and ability. For example, he wasthe first to formalise the idea of “knowledge pre-conditions”: what an agent must know inorder to achieve some goal, or carry out some action. To use an overworked example, con-sider agent A that must speak to agent B via telephone. In order to accomplish this goal, Aneeds to know B’s telephone number—this is thus a knowledge pre-condition. However, asMoore noted, not having immediate access to B’s telephone number does not preclude thegoal from being accomplished—because A has an action available (looking up B’s numberin the telephone directory) that will furnish it with this knowledge. Moore also made theimportant distinction between an agent knowing a plan that will achieve some goal, andthe knowledge that there exists a plan that will achieve a goal. Using the terminology ofquantified modal logic [27, pp. 183–188], in the former case, the agent has de re knowl-edge of the plan (in the sense that not only does the agent know that there is a plan thatwill achieve the goal, it knows what the plan is—it knows the identity of the plan), whilein the latter case, the agent has de dicto knowledge of the plan (the agent may be ignorantabout the identity of the plan). Moore’s formalism was able to capture these distinctions.Moore’s work was subsequently enhanced by many other researchers, perhaps most no-tably, Morgenstern [31,32]. These distinctions also informed later attempts to integrate alogic of ability into more general logics of rational action in autonomous agents [45,47](see [46] for a survey of such logics).In a somewhat parallel thread of research, researchers in the philosophy of actionhave developed a range of logics underpinned by rather similar ideas and motivations.A typical example is that of Brown, who developed a logic of individual ability in the mid-1980s [10]. Brown’s main claim was that modal logic was a useful tool for the analysis ofability, and that previous—unsuccessful—attempts to characterise ability in modal logicwere based on an over-simple semantics. Brown’s account of the semantics of ability wasas follows [10, p. 5]:(An agent can achieve A) at a given world iff there exists a relevant cluster of worlds, atevery world of which A is true.Notice the ∃∀ pattern of quantifiers in this account. Brown immediately noted that thisgave the resulting logic a rather unusual flavour, neither properly existential nor properlyuniversal [10, p. 5]:Cast in this form, the truth condition (for ability) involves two metalinguistic quantifiers(one existential and one universal). In fact, (the character of the ability operator) shouldbe a little like each.As we noted in the introduction, contemporary logics of ability—Coalition Logic andATL—are based on exactly the same idea. It is worth noting that many similar approacheshave been developed in the logical theory of action: examples include the “seeing to itthat” logic of Belnap and Perloff [7,8,26], Segerberg’s logic of “bringing it about” [42],112W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119and of course program logics such as dynamic logic [21]. A useful survey of such workwas published in 1992 [43].The recent surge of interest in logics of strategic ability was sparked by two largelyindependent developments: Pauly’s development of Coalition Logic [36–39], and the de-velopment of ATL by Alur, Henzinger, and Kupferman [5,14,19]. Although these logics arevery closely related (indeed, Coalition Logic can be formally understood as the “next-time”fragment of ATL [19]), the motivation and background to the two systems is strikingly dif-ferent.Pauly’s Coalition Logic was developed in an attempt to shed some light on the links be-tween logic—and in particular, modal logic—and the mathematical theory of games [33].Pauly showed how the semantic structures underpinning a family of logics of cooperativeability could be formally understood as games of various types; he gave correspondenceresults between properties of the games and axioms of the logic, gave complete axioma-tizations of the various resulting logics, determined the computational complexity of thesatisfiability and model checking problems for his logics, and in addition, demonstratedhow these logics could be applied to the formal specification and verification of socialchoice procedures.ATL, however, emerged from a rather different research community, and was developedwith an entirely different set of motivations in mind. The development of ATL is closelylinked with the development of branching-time temporal logics for the specification andverification of reactive systems [15,16,44]. Perhaps the best known branching-time tempo-ral logic is Computation Tree Logic (CTL) [15]. CTL is a temporal logic that is interpretedover tree-like structures, in which nodes represent time points and arcs represent transitionsbetween time points. In distributed systems applications, the set of all paths through a treestructure is assumed to correspond to the set of all possible computations of a system. CTLcombines path quantifiers “A” and “E” for expressing that a certain series of events willhappen on all paths and on some path respectively, with tense modalities for expressingthat something will happen eventually on some path (♦), always on some path () andso on. Thus, for example, by using CTL-like logics, one may express properties such as“on all possible computations, the system never enters a fail state”, which is representedby the CTL formula A ¬fail. Although they have proved to be enormously useful in thespecification and verification of reactive systems, logics such as CTL are of limited valuefor reasoning about multi-agent systems, in which system components (agents) cannot beassumed to be benevolent, but may have competing or conflicting goals. The kinds of prop-erties we wish to express of such systems are the powers that the system components have.For example, we might wish to express the fact that “agents 1 and 2 can cooperate to ensurethat the system never enters a fail state”. It is not possible to capture such statements usingCTL-like logics. The best one can do is either state that something will inevitably happen,or else that it may possibly happen: CTL-like logics have no notion of agency.Alur, Henzinger, and Kupferman developed ATL in an attempt to remedy this deficiency.The key insight in ATL is that path quantifiers can be replaced by cooperation modalities:the ATL expression (cid:7)(cid:7)C(cid:8)(cid:8)ϕ, where C is a group of agents, expresses the fact that the groupC can cooperate to ensure that ϕ. Thus, for example, the fact that agents 1 and 2 can ensurethat the system never enters a fail state may be captured in ATL by the following formula:(cid:7)(cid:7)1, 2(cid:8)(cid:8) ¬fail. ATL generalises CTL because the path quantifiers A (“on all paths. . . ”) andW. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119113E (“on some paths. . . ”) can be simulated in ATL by the cooperation modalities (cid:7)(cid:7)∅(cid:8)(cid:8) (“theempty set of agents can cooperate to. . . ”) and (cid:7)(cid:7)Σ(cid:8)(cid:8) (“the grand coalition of all agents cancooperate to. . . ”).One reason for the interest in ATL is that it shares with it ancestor CTL the computa-tional tractability of its model checking problem [12].5 This led to the development of anATL model checking system called MOCHA [3,6]. With MOCHA, one specifies a modelagainst which a formula is to be checked using a model specification language called RE-ACTIVE MODULES [4]. REACTIVE MODULES is a guarded command language, whichprovides a number of mechanisms for the structured specification of models, based uponthe notion of a “module”, which is basically the REACTIVE SYSTEMS terminology for anagent. Interestingly, however, it is ultimately necessary to define for every variable in aREACTIVE MODULES system which module (i.e., agent) controls it. The powers of agentsand coalitions then derive from the ability to control these variables: and as we noted inthe introduction, this observation was one of the motivations for considering CL-PC as asystem in its own right.ATL has begun to attract increasing attention as a formal system for the specification andverification of multi-agent systems. Examples of such work include formalising the notionof role using ATL [40], the development of epistemic extensions to ATL [23–25], and theuse of ATL for specifying and verifying cooperative mechanisms [39].It is worth noting that CL-PC is closely related to the formalism of quantified Booleanformulae. The logic of quantified Boolean formulae is an extension of propositional logicwhich permits quantification over propositional variables. Although perhaps not widelystudied as an independent formalism, quantified Boolean formulae play an important rolein the theory of computational complexity [35, p. 455] (indeed, we used them when prov-ing the complexity of CL-PC model checking and satisfiability); in addition, they are usedin symbolic model checking algorithms [12, pp. 66–67]. Readers may wonder whetherquantified Boolean formulae might therefore be used directly to reason about the kindsof scenarios that we represent using the modal language of CL-PC. We believe that thereis considerable value in the modal language of CL-PC. The family relationship that thecalculus of quantified Boolean formulae bears to CL-PC is roughly that which the first-order relational calculus bears to conventional modal logic. Thus, CL-PC can be reducedto quantified Boolean formulae, in much the same way that conventional modal logic canbe reduced to first-order relational calculus [11, pp. 12–14]. But, just as the modal logiccommunity believes that the language of modal logic is preferable to that of the first-orderrelational calculus for many situations [9, pp. xii–xiii], so we believe that CL-PC is prefer-able to that of quantified Boolean formulae for the scenarios we are interested in. Perhapsmost importantly, CL-PC provides us with a language in which agency and ability arefirst-class components—and these notions are not present in quantified Boolean formu-lae. Attempting to represent our cooperation scenarios using quantified Boolean formulae,while arguably possible, would thus lose or obscure these aspects, which are explicitlypresent in CL-PC.5 It also shares with CTL the intractability of its satisfiability problem [14].114W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119We finally mention related work of Harrenstein et al., which studies distribution of de-cision variables over agents in a game theoretic setting. In their so-called Boolean Games[34], two players partition the set of propositional atoms, which then represent moves inan extensive game form. Such games allow for operations that yield a Boolean algebra,and [34] defines winning strategies and determinacy on them. One of the main themes inHarrenstein’s thesis is to describe ways that relate logical concepts to game theoreticalones [22]. Boolean Games inspire him to define a notion of generalized logical conse-quence, in which one does not quantify over arbitrary valuations, but rather those that areequivalent modulo a given set of variables. This, again, is then linked to game theoreticalnotions, like the existence of a winning strategy for one of the two players.7. ConclusionIn this paper, we have introduced a logic of strategic cooperative ability in which thepowers of individual agents within the system are defined by associating a set of propo-sitional variables with each agent, the idea being that a set of propositional variablesrepresents exactly the part of the environment under the corresponding agent’s control.The choices available to an agent in this case correspond to the different assignments oftruth or falsity that the agent can give to the variables under its control, and the pow-ers of a coalition derive from the propositions under the control of its members. We thenargued that there are several good, natural reasons why CL-PC is worth studying as a sys-tem in its own right. As well as giving two alternative, but provably equivalent semanticsfor CL-PC, we gave a complete axiomatization for the logic, established the complex-ity of its model checking and satisfiability problems, and investigated how a variety ofdifferent notions of ability and control could be captured in the logic, including α- andβ-ability.There remain a number of obvious challenges for future research. For example, in thisanalysis we have assumed a static power structure: the assignment of propositional atomsto agents is assumed to be fixed throughout the evaluation of a formula. We believe it willbe interesting to investigate dynamic power structures, where agents are permitted to passthe control of their propositional atoms to other agents. Another possibility is to considerdynamic logic-style extensions, in which atomic programs in the dynamic component ofthe logic correspond to assignments of truth or falsity that agents make to their variables.Finally, yet another interesting issue is the axioms that may arise by including ATL-styletemporal operators into the logic.AcknowledgementsWe would like to extend our sincerest thanks to Marc Pauly, who introduced us to Coali-tion Logic, and inspired us to write this paper. This research was supported by the EPSRCunder grant RG/S62727/01.W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119115Appendix A. A derivation in the CL-PC deductive systemWe now give the proof of property S(cid:19) of Fig. 3. In order to circumvent too much clutterin notation, we can get rid of some subscripts by formulating S(cid:19) as under the assumptionthat (At(ψ) ∩ At(ψ (cid:19)) = ∅), we have (cid:25)CL-PC (cid:6)Cψ ∧ (cid:6)Dψ (cid:19) → (cid:6)C∪D(ψ ∧ ψ (cid:19)).Proof. By virtue of Theorem 3.1, we may assume that ψ and ψ (cid:19) are purely propositional.Let π = π1 ∨ · · · ∨ πd be the disjunctive normal form for ψ, and π (cid:19) = π (cid:19)∨ · · · ∨ π (cid:19)d(cid:19)1that of ψ (cid:19). Since the assumption states that ψ and ψ (cid:19) have no atoms in common, let X ={x1, . . . , xk} and Y = {y1 . . . ym} be all the atoms in At(ψ), all the x’s under control ofC, and none of the y’s controlled by C. Similarly, define X(cid:19) = {x(cid:19)k(cid:19)} and Y (cid:19) ={y(cid:19)m(cid:19)} for ψ (cid:19) and D. We then know that (X ∪ Y ) ∩ (X(cid:19) ∪ Y (cid:19)) = ∅, and (X ∪ Y ∪ X(cid:19) ∪Y (cid:19)) = (At(ψ) ∪ At(ψ (cid:19))). Assume that every πi (i (cid:1) d) is of the form (cid:10)i(x1) ∧ · · · ∧ (cid:10)i(xk) ∧(cid:10)i(y1) ∧ · · · ∧ (cid:10)i(ym), and similarly for every π (cid:19)k(cid:19)) ∧i(y(cid:19)(cid:10)(cid:19)m(cid:19)). First of all, we observe, by Prop:i with i (cid:1) d (cid:19): π (cid:19)1) ∧ · · · ∧ (cid:10)(cid:19)1, . . . , x(cid:19)1 . . . y(cid:19)i(x(cid:19)i(x(cid:19)= (cid:10)(cid:19)ii(y(cid:19)1) ∧ · · · ∧ (cid:10)(cid:19)(cid:25)CL-PC (ψ ∧ ψ(cid:19)) ↔(cid:13)(πi ∧ π(cid:19)j )i(cid:1)d,j (cid:1)d(cid:19)We obtain, by Prop, and the fact that (cid:6)C and (cid:6)D are diamonds:(cid:16) (cid:13)(cid:13)(cid:17)(cid:25)CL-PC ((cid:6)Cψ ∧ (cid:6)Dψ(cid:19)) ↔(cid:6)Cπi ∧(cid:6)Dπ(cid:19)ji(cid:1)dj (cid:1)d(cid:19)ˇCi , and every (cid:6)Dπ (cid:19)j is equivalent to π (cid:19) ˇDj.By Lemma 3.3, every (cid:6)Cπi is equivalent to πHence, we have(cid:25)CL-PC ((cid:6)Cψ ∧ (cid:6)Dψ(cid:19)) ↔(cid:17)(cid:16) (cid:13)i(cid:1)dˇCπi∧(cid:13)j (cid:1)d(cid:19)(cid:19) ˇDπjby Prop we have(cid:25)CL-PC(cid:16) (cid:13)(cid:13)∧(cid:17)(cid:19) ˇDπj↔(cid:13)ˇCπi(cid:11)ˇCπi(cid:12)(cid:19) ˇD∧ πj(A.1)(A.2)(A.3)(A.4)i(cid:1)dj (cid:1)d(cid:19)i(cid:1)d,j (cid:1)d(cid:19)Let Π be a conjunct in the DNF(ψ ∧ ψ (cid:19), C), say Π = (cid:10)(x1) ∧ · · · ∧ (cid:10)(xk) ∧ (cid:10)(x(cid:19)k(cid:19)) ∧ (cid:10)(y1) ∧ · · · ∧ (cid:10)(ym) ∧ · · · ∧ (cid:10)(y(cid:19)1) ∧ · · · ∧m(cid:19)). In an obvious way, we can writej ), for some i (cid:1) d, j (cid:1) d (cid:19), and, conversely, for every such (πi ∧ π (cid:19)j )(cid:10)(x(cid:19)such a Π as (πi ∧ π (cid:19)there is a corresponding Π . Let us write Πij for it. From (A.1) we know that1) ∧ · · · ∧ (cid:10)(y(cid:19)(cid:25)CL-PC (ψ ∧ ψ(cid:19)) ↔(cid:13)Πij(A.5)i(cid:1)d,j (cid:1)d(cid:19)ˇCNote that we also have (cid:25)CL-PC (πi∧ π (cid:19) ˇDj ) → Π: if any atom p is not under controlof C ∪ D, it is neither under control of C, nor of D, and hence such p ∈ (Y ∪ Y (cid:19)). Moreover,from Lemma 3.3, we know (cid:25)CL-PC Π). Combining thosetwo observations gives→ (cid:6)C∪D(ΠˇC∪DijˆC∪DijˇC∪Dij∧ ΠˇC∪Dij(cid:25)CL-PC(cid:11)ˇCπi(cid:19) ˇD∧ πj(cid:12)→ (cid:6)C∪D(cid:11)ΠˆC∪Dij∧ ΠˇC∪Dij(cid:12)(A.6)116W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119We put the disjunction in place again, and push it through the diamond operator:(cid:25)CL-PC(cid:13)(cid:11)ˇCπi(cid:12)(cid:19) ˇD∧ πj→ (cid:6)C∪D(cid:13)(cid:11)ΠˆC∪Dij∧ ΠˇC∪Dij(cid:12)(A.7)i(cid:1)d,j (cid:1)d(cid:19)i(cid:1)d,j (cid:1)d(cid:19)Now we are done: observe that by (A.5), the right hand side of (A.7) is equal to(cid:6)C∪D(ψ ∧ ψ (cid:19)), and use (A.3), (A.4) and (A.7). (cid:1)Appendix B. Deriving Pauly’s axioms in CL-PCIn this appendix, we show that analogues of Pauly’s axioms for Coalition Logic can beproved within the proof system CL-PC (see Section 4.1). Note that since we have estab-lished that the axiom system CL-PC is complete, it suffices to show that these schemes arevalid within CL-PC. Also note that in the proofs that follow, we use whichever semanticsseems appropriate to the task at hand.Lemma B.1 (α-N⊥). (cid:25)cl-pc ¬(cid:7)(cid:7)Ag(cid:8)(cid:8)α⊥.Proof. Expanding out the definition of (cid:7)(cid:7)· · ·(cid:8)(cid:8)α gives the following as our goal: ¬(cid:6)Ag(cid:1)Ag\Ag⊥, which in turn is equivalent to: ¬(cid:6)Ag¬(cid:6)∅(cid:10). By (empty), this is equivalent to¬(cid:6)Ag¬(cid:10), or (cid:1)Ag(cid:10), a derivable formula (use Necessitation). (cid:1)Lemma B.2 (α-(cid:10)). (cid:25)cl-pc ¬(cid:7)(cid:7)∅(cid:8)(cid:8)α⊥ → (cid:7)(cid:7)C(cid:8)(cid:8)α(cid:10).Proof. Expanding out the definition of (cid:7)(cid:7)· · ·(cid:8)(cid:8)α tells us that our goal is to prove the fol-lowing: ¬(cid:6)∅(cid:1)∅⊥ → (cid:6)C(cid:1)(cid:10). Rewriting the expressions and expanding the definition of(cid:1)···, we derive the following as our goal: ¬(cid:6)∅¬(cid:6)Ag(cid:10) → (cid:6)C¬(cid:6)⊥. We show that theright hand side of this is in fact derivable in CL-PC, and then we are done. This RHS isequivalent to (cid:6)C(cid:1)(cid:10) is derivable (by Necessitation) and to that,we can apply the dual of T (C). (cid:1)(cid:10); derivable since (cid:1)CCCCLemma B.3 (α-⊥). (cid:25)cl-pc (cid:7)(cid:7)C(cid:8)(cid:8)α⊥ → (cid:7)(cid:7)C(cid:19)(cid:8)(cid:8)α⊥ (where C(cid:19) ⊆ C).Proof. Expanding out, we get the following as our goal: |=k (cid:6)C(cid:1)⊥ → (cid:6)C(cid:19)(cid:1)C(cid:19) ⊥ (whereC(cid:19) ⊆ C). Further expansion yields (cid:6)C¬(cid:6)C(cid:19) (cid:10). It is easy to see (by argu-Cments similar to the preceding lemma) that LHS is equivalent to ⊥, which is sufficient. (cid:1)(cid:10) → (cid:6)C(cid:19) ¬(cid:6)CLemma B.4 (α-N ). (cid:25)cl-pc ¬(cid:7)(cid:7)∅(cid:8)(cid:8)α¬ϕ → (cid:7)(cid:7)Ag(cid:8)(cid:8)αϕ.Proof. Expanding out gives the following as our goal: |=k ¬(cid:6)∅(cid:1)∅¬ϕ → (cid:6)Ag(cid:1)Agϕ.This in turn reduces to the following: |=k ¬(cid:6)∅¬(cid:6)Agϕ → (cid:6)Ag(cid:1)∅ϕ. So, assume K, w |=k¬(cid:6)∅¬(cid:6)Agϕ for arbitrary K, w. By the definition of (cid:1)···, we thus have K, w |=k (cid:1)∅(cid:6)Agϕ.Since |=k ψ ↔ (cid:1)∅ψ, we thus have K, w |=k (cid:6)Agϕ, and by deploying this equivalenceagain, we obtain K, w |=k (cid:6)Ag(cid:1)∅ϕ, and we are done. (cid:1)W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119117Lemma B.5 (α-S). (cid:25)cl-pc ((cid:7)(cid:7)C1(cid:8)(cid:8)αϕ ∧ (cid:7)(cid:7)C2(cid:8)(cid:8)αψ) → (cid:7)(cid:7)C1 ∪ C2(cid:8)(cid:8)α(ϕ ∧ ψ) (where C1 ∩C2 = ∅).Proof. Suppose the antecedent is true in w, i.e., suppose that K, w |=k (cid:6)C1(cid:6)C2ψ, then our goal is to show(cid:1)C2K, w |=k (cid:6)C1∪C2(cid:1)C1∪C2Our assumption gives us worlds w1 and w2 such that(ϕ ∧ ψ)RC1 ww1 & ∀v(RC1vw1 ⇒ K, w1 |=k ϕ)andRC2 ww2 & ∀v(RC2vw2 ⇒ K, w2 |=k ψ)(cid:1)C1ϕ ∧(B.1)(B.2)(B.3)To prove our goal (B.1), we first construct a world w12 as follows: it is as the valuation w,but as for the atoms in At(Ci), we let w1,2(p) = wi(p) (i (cid:1) 2). This is well-defined, sinceC1 ∩ C2 = ∅. We have RC1∪C2ww12, so if we can prove(ϕ ∧ ψ)K, w12 |=k (cid:1)(B.4)C1∪C2w12v. We argue that wewe are done. To this end, choose an arbitrary v for which RC1∪C2w1v, that is, w1 = v (mod C1). Since w1 and w12 differ at most in At(C2),must have RC1and w12 and v differ at most in At(C1 ∪ C2), we know that w1 and v differ at most inAt(C2 ∪ (C1 ∪ C2), from which follows that w1 = v (mod C1) (since C2 ∪ (C1 ∪ C2) ⊆ C1;here we use again that C1 ∩ C2 = ∅). But this yields indeed RC1w1v, and hence K, v |=k ϕ.w2v, from which K, v |=k ψ follows. Since we nowIn the same way, we obtain that RC2w12v that K, v |=k (ϕ ∧ ψ), we have proven (B.4), andhave for an arbitrary v with RC1∪C2thereby (B.1). (cid:1)References[1] J. Abdou, H. Keiding, Effectivity Functions in Social Choice Theory, Kluwer Academic, Dordrecht, 1991.[2] J.F. Allen, J. Hendler, A. Tate (Eds.), Readings in Planning, Morgan Kaufmann, San Mateo, CA, 1990.[3] R. Alur, L. de Alfaro, T.A. Henzinger, S.C. Krishnan, F.Y.C. Mang, S. Qadeer, S.K. Rajamani, S. Ta¸siran,MOCHA user manual, University of Berkeley Report, 2000.[4] R. Alur, T.A. Henzinger, Reactive modules, Formal Methods in System Design 15 (11) (1999) 7–48.[5] R. Alur, T.A. Henzinger, O. Kupferman, Alternating-time temporal logic, J. ACM 49 (5) (2002) 672–713.[6] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani, S. Ta¸siran, Mocha: Modularity in modelchecking, in: CAV 1998: Tenth International Conference on Computer-Aided Verification, in: Lecture Notesin Comput. Sci., vol. 1427, Springer, Berlin, 1998, pp. 521–525.[7] N. Belnap, Backwards and forwards in the modal logic of agency, Philos. Phenomenolog. Res. LI (54)(1991) 777–807.[8] N. Belnap, M. Perloff, Seeing to it that: a canonical form for agentives, Theoria 54 (1988) 175–199.[9] P. Blackburn, M. de Rijke, Y. Venema, Modal Logic, Cambridge University Press, Cambridge, 2001.[10] M.A. Brown, On the logic of ability, J. Philos. Logic 17 (1988) 1–26.[11] B. Chellas, Modal Logic: An Introduction, Cambridge University Press, Cambridge, 1980.[12] E.M. Clarke, O. Grumberg, D.A. Peled, Model Checking, MIT Press, Cambridge, MA, 2000.118W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119[13] F.M. Donini, P. Liberatore, F. Massacci, M. Schaerf, Solving QBF with SMV, in: Proceedings of the EighthInternational Conference on Principles of Knowledge Representation and Reasoning (KR 2002), Toulouse,France, 2002, pp. 578–589.[14] G. van Drimmelen, Satisfiability in alternating-time temporal logic, in: Proceedings of the Eighteenth An-nual IEEE Symposium on Logic in Computer Science (LICS 2003), Ottawa, Canada, 2003, pp. 208–217.[15] E.A. Emerson, Temporal and modal logic, in: J. van Leeuwen (Ed.), Handbook of Theoretical ComputerScience Volume B: Formal Models and Semantics, Elsevier Science, Amsterdam, 1990, pp. 996–1072.[16] E.A. Emerson, J. Srinivasan, Branching time logic, in: J.W. de Bakker, W.-P. de Roever, G. Rozenberg(Eds.), REX School-Workshop on Linear Time, Branching Time and Parial Order Logics and Models forConcurrency, in: Lecture Notes in Comput. Sci., vol. 354, Springer, Berlin, 1988, pp. 123–172.[17] R.E. Fikes, N. Nilsson, STRIPS: a new approach to the application of theorem proving to problem solving,Artificial Intelligence 2 (1971) 189–208.[18] R. Goldblatt, Logics of Time and Computation, CSLI Lecture Notes, vol. 7, Center for the Study of Languageand Information, Ventura Hall, Stanford, CA, 1987. Distributed by Chicago University Press.[19] V. Goranko, Coalition games and alternating temporal logics, in: J. van Benthem (Ed.), Proceeding of theEighth Conference on Theoretical Aspects of Rationality and Knowledge (TARK VIII), Siena, Italy, 2001,pp. 259–272.[20] J.Y. Halpern, M.Y. Vardi, Model checking versus theorem proving: A manifesto, in: V. Lifschitz (Ed.), AIand Mathematical Theory of Computation—Papers in Honor of John McCarthy, Academic Press, London,1991, pp. 151–176.[21] D. Harel, D. Kozen, J. Tiuryn, Dynamic Logic, MIT Press, Cambridge, MA, 2000.[22] P. Harrenstein, Logic in conflict, PhD thesis, Utrecht University, 2004.[23] W. van der Hoek, M. Wooldridge, Tractable multiagent planning for epistemic goals, in: Proceedings ofthe First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS-2002),Bologna, Italy, 2002, pp. 1167–1174.[24] W. van der Hoek, M. Wooldridge, Model checking cooperation, knowledge, and time—a case study, Res.Econom. 57 (3) (2003).[25] W. van der Hoek, M. Wooldridge, Time, knowledge, and cooperation: alternating-time temporal epistemiclogic and its applications, Studia Logica (2003).[26] J.F. Horty, N. Belnap, The deliberative STIT: a study of action, omission, ability, and obligation, J. Philos.Logic 24 (6) (1995) 583–644.[27] G.E. Hughes, M.J. Cresswell, Introduction to Modal Logic, Methuen and Co., 1968.[28] V. Lifschitz, On the semantics of STRIPS, in: M.P. Georgeff, A.L. Lansky (Eds.), Reasoning About Actions& Plans—Proceedings of the 1986 Workshop, Morgan Kaufmann, San Mateo, CA, 1986, pp. 1–10.[29] R.C. Moore, Reasoning about knowledge and action, in: Proceedings of the Fifth International Joint Con-ference on Artificial Intelligence (IJCAI-77), Cambridge, MA, 1977.[30] R.C. Moore, A formal theory of knowledge and action, in: J.F. Allen, J. Hendler, A. Tate (Eds.), Readingsin Planning, Morgan Kaufmann, San Mateo, CA, 1990, pp. 480–519.[31] L. Morgenstern, A first-order theory of planning, knowledge, and action, in: J.Y. Halpern (Ed.), Proceedingsof the 1986 Conference on Theoretical Aspects of Reasoning About Knowledge, Morgan Kaufmann, SanMateo, CA, 1986, pp. 99–114.[32] L. Morgenstern, Knowledge preconditions for actions and plans, in: Proceedings of the Tenth InternationalJoint Conference on Artificial Intelligence (IJCAI-87), Milan, Italy, 1987, pp. 867–874.[33] M.J. Osborne, A. Rubinstein, A Course in Game Theory, MIT Press, Cambridge, MA, 1994.[34] J.-J.Ch. Meyer, P. Harrenstein, W. van der Hoek, C. Witteveen, Boolean games, in: J. van Benthem (Ed.),Proceeding of the Eighth Conference on Theoretical Aspects of Rationality and Knowledge (TARK VIII),Siena, Italy, 2001, pp. 287–294.[35] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.[36] M. Pauly, Logic for social software, PhD thesis, University of Amsterdam, 2001. ILLC Dissertation Series2001-10.[37] M. Pauly, A logical framework for coalitional effectivity in dynamic procedures, Bull. Econom. Res. 53 (4)(2002) 305–324.[38] M. Pauly, A modal logic for coalitional power in games, J. Logic Comput. 12 (1) (2002) 149–166.W. van der Hoek, M. Wooldridge / Artificial Intelligence 164 (2005) 81–119119[39] M. Pauly, M. Wooldridge, Logic for mechanism design—a manifesto, in: Proceedings of the 2003 Workshopon Game Theory and Decision Theory in Agent Systems (GTDT-2003), Melbourne, Australia, 2003.[40] M. Ryan, P.-Y. Schobbens, Agents and roles: refinement in alternating-time temporal logic, in: J.-J.Ch.Meyer, M. Tambe (Eds.), Intelligent Agents VIII: Proceedings of the Eighth International Workshop onAgent Theories, Architectures, and Languages, ATAL-2001, in: Lecture Notes in Artificial Intelligence,vol. 2333, 2002, pp. 100–114.[41] P. Schnoebelen, The complexity of temporal logic model checking, in: P. Balbiani, N.-Y. Suzuki, F. Wolter,M. Zakharyascev (Eds.), in: Advanced in Modal Logic, vol. 4, King’s College Publications, London, 2003,pp. 393–436.[42] K. Segerberg, Bringing it about, J. Philos. Logic 18 (1989) 327–347.[43] K. Segerberg, Getting started: beginnings in the logic of action, Studia Logica 51 (3/4) (1992) 347–378.[44] M.Y. Vardi, Branching vs. linear time: final showdown, in: T. Margaria, W. Yi (Eds.), Proceedings of the2001 Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2001, in:Lecture Notes of Comput. Sci., vol. 2031, Springer, Berlin, 2001, pp. 1–22.[45] M. Wooldridge, Reasoning about Rational Agents, MIT Press, Cambridge, MA, 2000.[46] M. Wooldridge, N.R. Jennings, Intelligent agents: theory and practice, Knowledge Engrg. Rev. 10 (2) (1995)115–152.[47] M. Wooldridge, N.R. Jennings, The cooperative problem solving process, J. Logic Comput. 9 (4) (1999)563–592.