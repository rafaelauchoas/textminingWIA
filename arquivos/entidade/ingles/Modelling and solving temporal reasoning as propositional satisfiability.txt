Artificial Intelligence 172 (2008) 1752–1782Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintModelling and solving temporal reasoning as propositional satisfiabilityDuc Nghia Pham a,b,∗, John Thornton a,b, Abdul Sattar a,ba SAFE Program, NICTA Ltd., Queensland, Australiab Institute for Integrated and Intelligent Systems, Griffith University, Queensland, Australiaa r t i c l ei n f oa b s t r a c tArticle history:Received 24 November 2006Received in revised form 2 June 2008Accepted 11 June 2008Available online 19 June 2008Keywords:Temporal reasoningInterval AlgebraSatisfiabilitySatisfiability modulo theoriesDPLLSearchRepresenting and reasoning about time dependent information is a key research issue inmany areas of computer science and artificial intelligence. One of the best known andwidely used formalisms for representing interval-based qualitative temporal information isAllen’s interval algebra (IA). The fundamental reasoning task in IA is to find a scenario thatis consistent with the given information. This problem is in general NP-complete.In this paper, we investigate how an interval-based representation, or IA network, can beencoded into a propositional formula of Boolean variables and/or predicates in decidabletheories. Our task is to discover whether satisfying such a formula can be more efficientthan finding a consistent scenario for the original problem. There are two basic approachesto modelling an IA network: one represents the relations between intervals as variablesand the other represents the end-points of each interval as variables. By combining thesetwo approaches with three different Boolean satisfiability (SAT) encoding schemes, weproduced six encoding schemes for converting IA to SAT. In addition, we also showedhow IA networks can be formulated into satisfiability modulo theories (SMT) formulae basedon the quantifier-free integer difference logic (QF-IDL). These encodings were empiricallystudied using randomly generated IA problems of sizes ranging from 20 to 100 nodes.A general conclusion we draw from these experimental results is that encoding IA into SATproduces better results than existing approaches. More specifically, we show that the newpoint-based 1-D support SAT encoding of IA produces consistently better results than theother alternatives considered. In comparison with the six different SAT encodings, the SMTencoding came fourth after the point-based and interval-based 1-D support schemes andthe point-based direct scheme. Further, we observe that the phase transition region mapsdirectly from the IA encoding to each SAT or SMT encoding, but, surprisingly, the locationof the hard region varies according to the encoding scheme. Our results also show a fixedperformance ranking order over the various encoding schemes.© 2008 Elsevier B.V. All rights reserved.1. Introduction and backgroundRepresenting and reasoning about time dependent information (i.e. temporal reasoning) is a central research issue in manyreal world AI applications such as planning, plan recognition, scheduling, natural language understanding, and medicaldiagnosis [36]. The basic research tasks include the design and development of efficient reasoning methods to check theconsistency of temporal information, to infer new information and to answer temporal queries [10].Temporal reasoning is an important subdiscipline within the field of constraint satisfaction research and has been subdi-vided into two basic areas: qualitative and quantitative temporal reasoning.* Corresponding author at: SAFE Program, NICTA Ltd., Queensland, Australia.E-mail addresses: duc-nghia.pham@nicta.com.au (D.N. Pham), john.thornton@nicta.com.au (J. Thornton), abdul.sattar@nicta.com.au (A. Sattar).0004-3702/$ – see front matter © 2008 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2008.06.003D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–178217531.1. Quantitative temporal reasoningQuantitative problems have to deal with situations where there is definite metric information about time intervals, suchas one event being at least 20 minutes long or starting at exactly 2 o’clock. Such scenarios can be treated as temporal con-straint satisfaction problems (TCSPs) where variables represent continuous domain time points and constraints representsets of intervals that restrict the domains of particular variables [11]. For example, we could represent the unary con-straint T i that time point xi occurs within the intervals ([a1, b1], [a2, b2]) as (a1 (cid:2) xi (cid:2) b1) ∨ (a2 (cid:2) xi (cid:2) b2) or the binaryconstraint T i j that the duration between time points xi and x j lies within the interval [a1, b1] as (a1 (cid:2) x j − xi (cid:2) b1).A general TCSP can be represented as a directed constraint graph with nodes representing variables and edges represent-ing binary constraints, where each edge can be labelled with a set of intervals. If we further specify that each edge must belabelled with a single interval we arrive at a simple temporal problem (STP) [10].Deciding the consistency of a general TCSP is known to be NP-complete whereas finding the consistency of an STP canbe decided in polynomial time using shortest-path algorithms [11]. This has led to the development of methods that decidethe consistency of a TCSP by selecting one disjunct label from each edge and testing whether the resulting problem is aconsistent STP.Subsequent work has looked at disjunct temporal problems (DTPs) that allow the inclusion of non-binary constraints.Techniques for solving these problems treat the task of selecting a consistent STP from the original DTP as a meta-CSP [50]that takes each constraint in the original problem as a variable in the meta-problem and performs a backtracking searchwith forward-checking over the space of possible STPs.A DTP can also be represented as a satisfiability (SAT) problem, consisting of clauses containing disjunctions of literalsthat each represent a temporal constraint (e.g. x1 − x2 (cid:2) 2). Such problems can be solved using generic SAT solvers thatadditionally test the consistency of the underlying STP problems represented by the clauses during the search [3]. Currently,some of the most promising results in the DTP area have been produced using SAT solvers that incorporate the latestadvances from the general SAT solving complete search community [5].1.2. Qualitative temporal reasoningHowever, there are notions of time used in day to day decision making that do not refer directly to quantitative metricdata about time points or durations. For example, we may have a constraint that one event must start before another oroccur during a third event. Here we are only concerned with the relative time ordering of events and not with exactlywhen each event starts and stops. For instance, consider the ordering of events in the construction of a house. Here weare typically unable to predict or control exactly when a particular task will occur but we do have hard constraints aboutnot fitting out the interior until the roof is attached. These qualitative temporal relations were formalised in Allen’s intervalalgebra (IA) [1].In IA there are 13 atomic relations that define all the possible qualitative arrangements that can exist between twotime intervals. These relations cover the basic situations that two events can be before, during, overlapping, meeting, starting,finishing or equal to each other (see Table 1). As with the formulation of a TCSP, an IA problem can be expressed as directedconstraint graph. However, here each node represents an interval of unspecified length and the edges represent constraintslabelled by sets of atomic relations. In this form, IA is an expressively rich framework and, as with the general TCSP, thereasoning problem is computationally intractable. Existing IA techniques are typically based on the backtracking approach(proposed by Ladkin and Reinefeld [29]), which uses path consistency as forward checking. Although this approach hasTable 1The 13 IA atomic relations. Note that the endpoint relations X− < X+and Y− < Y+have been omittedAtomic relationSymbolX before YY after XX meets YY met by XX overlaps YY overlapped by XX during YY includes XX starts YY started by XX finishes YY finished by XX equals YbbimmiooiddissiffieqMeaningX(cid:2)(cid:3) Y(cid:2)(cid:3)X(cid:2) (cid:3) Y(cid:2) (cid:3)X(cid:2) (cid:3)(cid:2) (cid:3)YX(cid:2) (cid:3)(cid:3)(cid:2)YX(cid:2) (cid:3)(cid:2)(cid:3)YX(cid:2) (cid:3)(cid:3)(cid:2)YX(cid:2)(cid:2)Y(cid:3)(cid:3)Endpoint relations− < Y−, X+ < Y−, X− < Y+ < YXX++− < Y+ = Y−, X−, X− < Y+ < YXX++− < Y+ > Y−, X−, X− < Y+ < YXX++− > Y+ > Y−, X−, X− < Y+ < YXX++− = Y+ > Y−, X−, X− < Y+ < YXX++− > Y+ > Y−, X−, X− < Y+ = YXX++− = Y+ > Y−, X−, X− < Y+ = YXX++1754D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782been further improved [36,53], all variants still rely on path consistency checking at each step to prune the search space.This native IA approach has the advantage of being fairly compact, but is disadvantaged by the overhead of continuallyensuring path-consistency. Additionally, the native IA representation of variables and constraints means that state-of-the-artlocal search and complete search techniques (such as unit propagation look ahead in Satz [32] or nogood recording andnon-chronological backtracking in Chaff [35]) cannot be easily transferred to the IA domain.In practice, existing native IA backtracking approaches are only able to find consistent solutions for relatively smallgeneral IA instances [48,51]. On the other hand, recent research has shown that modelling and solving hard combinato-rial problems (including DTPs and planning problems) as SAT instances can produce significant performance benefits oversolving problems in their original form [5,24,26,41]. These results have motivated us to undertake the current study.In other related work, stochastic local search techniques (SLS) were applied to the IA problem, to see if performanceimprovements over complete search observed in other SAT and CSP domains can be translated to IA. Thornton et al. [48]developed the end-point ordering model, specifically to represent IA problems in a form suitable for processing by SLS. In thisresearch the TSAT local search algorithm was shown to significantly outperform an existing complete search technique on aset of larger, more difficult IA problems. However, the end-point ordering model, like the native IA model, has a specialisedstructure that is carefully exploited by the TSAT algorithm.1.3. Alternative approaches and translationsAnother well-known approach to the qualitative temporal reasoning problem is Villain and Kautz’s point algebra (PA)[54]. This formalism uses the three basic relations that exist between two time point variables, i.e. {<, >, =}. In PA (as inIA) constraints are defined as disjunctions of basic relations between two variables resulting in 23 possible constraint types(as opposed to the 213 in IA). These variables and constraints can again be expressed as a directed constraint graph, wherethe nodes represent the time point variables and the edges represent the constraints.The greater simplicity of PA means it is both less expressive than IA and computationally tractable. In addition, PAprovides a link between qualitative reasoning about time point orderings and metric reasoning about time quantities. Thisis shown by the fact that a PA problem is a special case of a TCSP with the metric information omitted. This allows for asimple transformation of PA into TCSP and means TCSP techniques can be easily applied [10].However, translating from IA to TCSP is not so straightforward. This is because there are many disjunctions of IA relationsthat can neither be expressed in PA or as a binary TCSP. As we will discuss later in the paper, these disjunctions representnon-binary constraints that can involve all the four end-points of a pair of intervals. The inclusion of these non-binaryconstraints allows us to represent a full IA network using only the endpoints and three basic relations of PA. Such a systemof constraints can already be encoded using the DTP formalism. In fact, an IA problem can be considered as a restricted DTPwith metric information omitted, just as PA can be treated as a binary TCSP.The previously discussed work on developing SAT-based DTP solvers overlaps with the more general area of satisfiabilitymodulo theories (SMT) [4]. SMT approaches are designed to solve problems using a combination of SAT solving and theoryspecific decision procedures. In fact, a DTP SAT solver is a special case of an SMT solver, where the meta-CSP is handled bya standard SAT solver and the problem of deciding the consistency of the underlying STPs is handled by a theory specificdecision procedure (such as the Bellman–Ford procedure) [5]. As we will show, existing general purpose SMT solvers (suchas Yices [13]) can also be applied to our new IA-encoding and to metric DTPs, thereby providing a unified framework thatcan handle both the qualitative and quantitative dimensions of the temporal reasoning domain.1.4. An overview of the paperThe aim of the current research is to investigate the best approach for solving qualitative (IA) reasoning problems, bothin terms of the choice of algorithm and of problem representation. We ask the question whether the representation ofIA problems using specialised models that require specialised algorithms is necessary in the general case. Given that thedevelopment of such approaches takes considerable effort, we will investigate whether any counterbalancing performancebenefits actually result.To this end, we consider a range of existing IA reasoning techniques, including backtracking over native IA problems andusing local search on the end-point ordering model. We also develop a new SMT-encoding of IA and use an existing SMTsolver to evaluate this encoding. Against this we contrast the approach of expressing IA as a pure propositional satisfiabilityproblem and applying a state-of-the-art SAT-solver without the need to develop special decision procedures or representa-tion formalisms. Despite the extensive work on solving quantitative TCSPs and DTPs using constraint satisfaction and SATtechniques, to the best of our knowledge there is no explicit and thorough work on formulating IA problems as pure SATinstances (excluding our own recent works in [38,39]). Nebel and Bürckert [37] pointed out that qualitative temporal in-stances can be translated to SAT instances but that such a translation causes an exponential blowup in problem size. Hence,no further investigation was provided in their work.11 Other independent work [20] has proposed representing IA as SAT, but the authors do not specify the transformation in detail, and do not provide anadequate empirical evaluation.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821755In this paper, we extend our work in [39]. We provide a detailed investigation of how interval-based representationscan be encoded into the conjunctive normal form (CNF) of a propositional formula. The interval-based representation, or IAnetwork, can be modelled into two different forms: one is based on treating relations between intervals as variables; andthe other is based on representing intervals in terms of end-points. By combining these two approaches with three differentSAT encoding schemes, we produced six encoding schemes for converting IA to SAT.In our empirical study, we used MiniSAT [14], a state-of-the-art complete search SAT solver, for solving SAT encodedproblems. These SAT encoded temporal reasoning problems were translated from randomly generated IA problems rangingin size from 20 to 100 nodes. In addition to analysing the performance of MiniSAT on each encoding scheme, we also lookedat the comparative performance of a range of other algorithms working directly on native IA, end-point ordering and ournew SMT encodings.A general conclusion we draw from these experimental results is that a SAT based approach performs better than theother alternatives. We also conclude that representing intervals using end-points produces better performance than repre-senting intervals as variables. Further, we observe that the phase transition region maps directly from the IA encoding toeach SAT or SMT encoding, but, surprisingly, the location of the hard region varies according to the encoding scheme. Ourresults also show a fixed performance ranking order over the various encoding schemes.The remainder of the paper is structured as follows: firstly, we review the basic definitions of IA and then in Section 3we introduce two models for transforming IA instances into CSP instances. Using these methods, combined with three CSPto SAT encodings, we present six IA to SAT encodings in Section 4. Section 5 describes the translation of IA to SMT, Section 6describes the generation of our test set instances and Sections 7–10 present an empirical study to evaluate the performanceof these SAT encodings relative to each other, and also to evaluate the performance of an existing complete SAT solver incomparison to the native IA backtracking, SMT and TSAT solvers. In Section 11, we further evaluate the performance of ourSAT approach against the performance of the SMT approach on structured SMT problems. Finally, Section 12 presents ourconclusions and discusses future research directions.2. Interval Algebra2.1. Preliminaries−, I+) on the time line, where IInterval Algebra [1] is the most commonly used formalism to represent qualitative temporalinformation basedis defined as an ordered pair of two real-valued endpointson relations between time intervals. A time interval. There are 13 atomic interval relations between two time intervals, I =(I{eq, b, bi, m, mi, o, oi, d, di, s, si, f , fi} which are jointly exhaustive and pairwise disjoint. Table 1 shows graphical represen-tations of these atomic relations and their definitions in terms of endpoint relations. Indefinite information between twotime intervals can be expressed as a subset of I (e.g. a disjunction of atomic relations). For example, the statement “Event Acan happen either before or after event B” can be expressed as A{b, bi}B. Hence, there are a total of 213 = 8, 192 possible IArelations between pairs of time intervals.− < I+IQualitative temporal constraints or IA relations between two time intervals A and B are written as ARB or R( A, B), whereR is an IA relation. Let R1 and R2 be two IA relations. Then the four operators of IA: union (denoted by ∪), intersection(denoted by ∩), inversion (denoted by−1), and composition (denoted by ◦), can be defined as follows:∀ A, B : A(R1 ∪ R2)B ↔ (AR1 B ∨ AR2 B)∀ A, B : A(R1 ∩ R2)B ↔ (AR1 B ∧ AR2 B)−1∀ A, B : A(R1 )B ↔ BR1 A∀ A, B : A(R1 ◦ R2)B ↔ ∃C : (AR1C ∧ CR2 B)Hence, the intersection and union of any two temporal relations (R 1, R2) are simply the standard set-theoretic intersectionand union of the two sets of atomic relations describing R1 and R2, respectively. The inversion of a temporal relation R isthe union of the inversion of each atomic relation ri ∈ R. The composition of any pair of temporal relations (R1, R2) is theunion of all results of the composition operation on each pair of atomic relations (r1i , r2 j ), where r1i ∈ R1 and r2 j ∈ R2. Thefull composition results of these IA atomic relations are shown in Table 2.Definition 1. Interval Algebra is the algebra with underlying set 2inversion, and binary operators intersection, union and composition [52].I, the power set or set of all subsets of I, unary operators2.2. The ISAT problemAn IA network is defined as a constraint satisfaction problem (CSP), where each variable represents an interval eventwith a domain of ordered pairs of real numbers and each binary constraint is labelled with the possible interval relationsbetween a pair of interval events [36,52].1756D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Table 2The composition table for the 12 IA atomic relations (omitting eq). Note that dur and con represent {d, s, f } and {di, si, fi}, respectively◦bbimmiooiddissiffibbIbb o mdi fibb o mdi fibb o mdi fibb o mdi fibbbiIbibi oi midi sibibi oi midi sibibi oi midi sibibibibi oi midi sibibbibimimibio di fibo di fimmmbbi oi mid fbmib o md sbif fi eqobbi oi mid fboib o md sbio d ss si eqbioi d fbiboi di sib o mdb o md sbi oi mid fo d soi d fo d soi d fdo oi durcon eqddibbibbib o mdi fibi oi midi siIb o mdi fidibi oi midi sidisbbi oi mid fmoi d fsibbimbifb o md sbio d sfibbibmimioo di fio d sb o moi d fbi oi mibi oi mid fdibi oi miss si eqs si eqsiddooidoi di sidoifoi di sib o md sdib o mdif fi eqo oi durcon eqbi oi mibi oi mid foi di sio oi durcon eqb o md so di fib o moi d fo di fioioi d fo d sbi oi midoi di siooi di sio d sdif fi eqfio di fioi di sidio di fiFig. 1. An example of an IA network and its consistent solution.An instantiation of an IA network maps each variable to a time interval on the time line represented by an ordered pairof real values (s, e), where s < e. A binary constraint R( A, B) is satisfied by an instantiation Θ iff Θ( A) and Θ(B) satisfythe corresponding endpoint relations of at least one atomic relation r ∈ R. A solution of an IA network is an instantiationthat satisfies all the binary constraints.The problem of determining whether an IA network is satisfiable, i.e. whether there exists a solution for that network, iscalled ISAT. ISAT is the fundamental reasoning task because all other interesting reasoning problems can be reduced to it inpolynomial time [21] and it is one of the most important tasks in practical applications [53].An IA network can be represented as a constraint graph or a constraint network where the nodes represent variables andthe edges are labelled with binary constraints. Usually, such a constraint graph for n interval events is described by an n × nmatrix M, where each entry Mi j is the binary constraint between the ith and jth intervals. An IA scenario is a singleton IAnetwork where each edge (constraint) is labelled with exactly one atomic relation. A consistent scenario is a scenario suchthat there exists a corresponding CSP instantiation that satisfies all the constraints.Fig. 1(a) shows an example of an IA network expressing the situation: “Fred was reading the paper while eating his breakfast.He put the paper down and drank the last of his coffee. After breakfast he went for a walk”.2 In this example, variables I p , Ib, Ic andI w represent the intervals that Fred is reading the paper, eating breakfast, drinking coffee and walking respectively. Fig. 1(b)shows a consistent scenario of the network and Fig. 1(c) shows the graphical representation of that scenario on the timeline.2 This example was originally used in [51].D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821757A CSP is k-consistent iff any partial solution over (k − 1) variables can be extended to a partial solution over k variablesthat satisfies all the relevant constraints [15]. In addition, a CSP is strongly k-consistent iff it is i-consistent for all i (cid:2) k [16]. AnIA network with n interval variables is globally consistent iff it is strongly n-consistent. Hence, the ISAT problem is equivalentto the problem of determining whether an IA network has a globally consistent scenario.The most useful local consistency notion in temporal reasoning is path consistency or 3-consistency [15,16,33]. Allen [1]proposed a path consistency method for an IA network M that repeatedly computes the following triangle operation Mi j ←Mi j ∩ Mik ◦ Mkj for all triplets of nodes (i, j, k) until no further change occurs or until Mi j = ∅. These operations removeall the atomic relations that cause an inconsistency between any triple (i, j, k) of intervals. The resulting network is a pathconsistent IA network. If Mi j = ∅, then the original IA network is path inconsistent. More sophisticated path consistencyalgorithms have been applied to IA networks that run in O (n3) time [36,52]. Although path consistency cannot guaranteeglobal consistency for a full IA network, it was proved that enforcing path consistency is enough to ensure global consistencyfor the maximal tractable subclasses of IA [36].2.3. Current approaches to ISATIn general, ISAT is an NP-complete problem [54]. Therefore, it requires exhaustive search methods to determine the satisfia-bility of a full IA network. In his seminal work, Allen [1] proposed an algorithm to systematically search through all possiblesingleton networks resulting from instantiating binary constraints with atomic relations and then to enforce path consis-tency on these instantiated networks. However, this sort of brute force backtracking technique is inefficient and impracticalfor non-trivial problems. Moreover, as the domains of the underlying IA network variables are infinite (real numbers), thismakes the representation unsuitable for finite CSP and SAT solving techniques.Ladkin and Reinefeld [29] proposed a more efficient approach to solve the ISAT problem by enforcing path consistencyas forward checking [22] at every branching node. This allows the elimination of relations that are inconsistent with thecurrent partial solution and hence results in a significant pruning of the search tree. In addition, backtracking algorithmscan be improved by preprocessing the input network using path consistency algorithms. van Beek [51] pointed out thatthe branching factor of an algorithm can be significantly reduced by decomposing disjunctive relations into any set ofrelations for which path consistency guarantees global consistency rather than decomposing into simple atomic relations.This suggestion was later proven correct by Nebel [36]. Based on this approach, advanced algorithms have been developedthat explore various variable and value ordering techniques and different decomposing sets of relations [30,31,36,51,53].Given that the implicit constraints of the current IA formalism can only be enforced by path consistency, state-of-the-art search techniques from the CSP and SAT domains cannot be easily employed, i.e. it would require the embeddingof a path consistency heuristic in the reasoning mechanism of the solver. To address this issue, in [48] we developed anew transformation method, called end-point ordering, that reformulates IA networks into CSPs. In this model the variablesare interval end-points and the constraints are the end-point relations as defined in Table 1. The domain of each end-point variable is defined as the integer value position or rank of that variable within the total ordering of all end-points[48]. To solve these problems, a specialised TSAT local search algorithm was developed that exploits the structure of theend-point domains and constraints. The main difficulty with this approach is the generation of very large variable domains(representing all possible orderings of each interval). Without the special TSAT pruning heuristics a standard general purposesolver would not prove competitive. Therefore, neither native IA or the end-point ordering models are appropriate for usewith a general purpose SAT or CSP solver.As mentioned in the introduction and elaborated in Section 5, we have also developed a translation procedure that canencode an IA network as an SMT problem, which can then be solved using a general-purpose SMT solver [44]. However,such solvers pay a price in comparison to a pure SAT solver, in having to perform consistency checks by calling separatedecision procedures.Due to the shortcomings of the techniques we have already considered, we decided to explore the development of alter-native SAT representations to produce reasonable-sized problems that could then be solved using existing non-specialisedSAT solvers.3. Reformulation of IA into CSPRecent research has shown that modelling and solving hard combinatorial problems as SAT instances can produce signif-icant performance benefits over solving problems in their original form [24,26,41]. These results inspired us to undertake athorough study of encoding and solving IA problems as SAT instances using existing SAT solvers.A common approach to encode combinatorial problems into SAT is to divide the task into two steps: (i) modellingthe original problem as a CSP; and (ii) mapping the new CSP into SAT. In the next two subsections, we propose twotransformation methods to model IA networks as CSPs such that these CSPs can be feasibly translated into SAT. We thendiscuss three SAT encoding schemes to map the CSP formulations into SAT, producing in six different approaches to encodeIA networks into SAT.33 In practice, IA networks can be directly encoded into SAT formulae without being reformulated as CSPs. However, for the sake of clarity we firsttransform IA into two different CSP formulations and then to SAT.1758D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17823.1. The interval-based CSP formulationA straightforward method to formulate IA networks as CSPs is to represent each edge (or binary constraint) as a CSPvariable. We then limit the domain values of each CSP variable to the set of permissible IA atomic relations for that edge,rather than the set of all subsets of I used in existing IA approaches. This allows us to reduce the domain size of eachCSP variable from 213 to a maximum of 13 values. Thus an instantiation of an interval-based CSP maps each variable (edge)to exactly one atomic relation in its domain. In other words, an instantiation of this new CSP model is actually a singletonnetwork of the original IA network.Lemma 2. Let Θ be a singleton IA network with 3 intervals I1, I2, and I3. Let ri j be the label of the edge between any two Ii and I jintervals (i, j ∈ [1..3]). Then Θ is consistent iff r13 ∈ r12 ◦ r23.Proof. The proof for this lemma is trivial based on the fact that there is exactly one mapping of a singleton network ontothe time line. (cid:2)Theorem 3. Let Θ be a singleton IA network with n intervals and ri j be the label of the edge between I i and I j . Then Θ is consistent ifffor any triple (i < k < j) of nodes, ri j ∈ rik ◦ rkj .Proof. (⇒) This direction is trivial as Θ is also path consistent.(⇐) Given the fact that ri j ∈ rik ◦ rkj holds for all triplets (i < k < j) of nodes, Θ is path consistent as a result of Lemma 2.In addition, Θ is singleton. Hence, Θ is globally consistent. (cid:2)Based on the results of Theorem 3, an interval-based CSP representation of a given IA network is defined as follows:Definition 4. Given an IA network M with n intervals, I1, . . . , In; the corresponding interval-based CSP is (X , D, C), whereX = { Xi j | i, j ∈ [1..n], i < j} where each variable Xi j represents a relation between two intervals I i and I j ;D = {D i j} where each D i j is a set of domain values for Xi j , and D i j = Mi j the set of relations between interval I i and I j ;andC consists of the following constraints:(cid:2)x∈D ik, y∈DkjXik = x ∧ Xkj = y (cid:16)⇒ Xi j ∈ D(cid:17)i jwhere i < k < j and D(cid:17)i j= D i j ∩ (x ◦ y).(1)Theorem 5. Let Θ be an IA network and Φ be the corresponding interval-based CSP defined by Definition 4. Then Θ is satisfiable iffΦ is satisfiable.Proof. We first rewrite the constraint (1) into two clauses(cid:2)x∈D ik, y∈Dkj(cid:2)x∈D ik, y∈DkjXik = x ∧ Xkj = y (cid:16)⇒ Xi j ∈ D i jXik = x ∧ Xkj = y (cid:16)⇒ Xi j ∈ x ◦ y(2)(3)It is trivial to prove that clauses (2) and (3) are equivalent to constraint (1).is a singleton network, Θ (cid:17)(⇒) Let Θ (cid:17)be a consistent scenario of Θ . As Θ (cid:17)Hence clause (2) is satisfied. In addition, as Θ (cid:17)satisfies all constraints of Φ. As a result, Φ is satisfiable.is also an instantiation of Φ by Definition 4.is globally consistent, clause (3) is also satisfied by Theorem 3. Hence Θ (cid:17)(⇐) Let Φ(cid:17)be an instantiation of Φ such that it satisfies all constraints of Φ (i.e. clauses (2) and (3) are satisfied). Wewith the atomic relation Φ(cid:17)(i, j). As Φ(cid:17)satisfies clausesatisfies clause (3), we have Θ (cid:17)(i, j) ∈ Θ (cid:17)(i, k) ◦ Θ (cid:17)(k, j) for all triplesby labelling each edge (i, j) of Θ (cid:17)is a singleton network of Θ . In addition, as Φ(cid:17)construct a singleton network Θ (cid:17)(2), Θ (cid:17)(i < k < j) of nodes. Applying Theorem 3, Θ (cid:17)is globally consistent. As a result, Θ is satisfiable. (cid:2)3.1.1. ExampleFor the sake of clarity, we use the IA network in Fig. 2(a) as a running example to illustrate the transformation ofIA networks into CSPs and SAT encodings (which are discussed in later sections). The example represents the followingscenario:D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821759Fig. 2. An example of interval-based CSPs of IA networks.Table 3The composition table for PA atomic relations. Note that‘?’ represents the universal relation {<, =, >}◦<=><<<?=<=>>?>>Anne usually reads her newspaper (I1) before or during her breakfast (I3). In addition, she always drinks a cup of coffee (I2) duringher breakfast. This morning, she started reading her newspaper before her coffee was served and finished reading before drinkingthe last of her coffee.The corresponding interval-based CSP of this IA network is shown in Fig. 2(b), having 3 variables, which represent thetemporal relations between each pair of actions. These CSP variables and their corresponding domains are described usingthe same order in X and D. It is worth noting that as {o} ◦ {d} = {o, d, s}, the constraint between I1, I2 and I3 furtherrestricts the domain of X13 to {d} instead of its original D13 = {b, d}, i.e. Anne could not have read her newspaper beforebreakfast if she was still reading it while drinking her coffee during breakfast.3.2. The point-based CSP formulationVilain and Kautz [54] proposed the full Point Algebra to model qualitative information between time points. PA consistsof a set of 3 atomic relations P = {<, =, >} and four operators union, intersection, inversion and composition, which aredefined in a similar manner to IA. The full composition results of the PA atomic relations are shown in Table 3.A PA network can be represented as a constraint graph in a similar manner as an IA network, where nodes representpoints and edges are labelled with PA relations between pairs of points. Hence, all the concepts of consistency discussedabove for IA networks are also applicable to PA networks. Again, we use an n × n matrix P to represent a PA network withn points where P i j is the relation between two points i and j.As mentioned in Section 2, IA atomic relations can be uniquely expressed in terms of their endpoint relations. However,representing non-atomic IA relations is more complex, as not all IA relations can be translated into conjunctions of pointrelations. For example, the following combination of point relations− (cid:18)= B−( A) ∧ ( A−< B+) ∧ ( A+ (cid:18)= B−) ∧ ( A+< B+)represents not only A{b, d}B but also A{b, d, o}B. This means that PA can only cover 2% of IA [36].In the example above, to represent A{b, d}B we would also need to disallow that A{o}B. This is not possible in PAbecause ruling out the overlap relation requires a non-binary relation between the end-points of A and B, i.e. we wouldhave to disallow the situation that interval A starts before interval B while also ending between the start and end ofinterval B, requiring a non-binary relation involving at least 3 endpoints:(cid:3)( A¬−< B−) ∧ ( A+> B−) ∧ ( A+< B+(cid:4))However, using the CSP formalism, we can control the instantiation of such undesired IA relations by simply introducingnew constraints into the CSP model, as follows:Let μ(r) = (v ss, v se, ves, vee) be the PA representation of an IA atomic relation r between two intervals A and B, where. We then define the point-based CSPv se , for example, is the corresponding PA relation between two endpoints Amodel of an IA network as:and B+−Definition 6. Given an IA network M with n intervals and its corresponding PA network P (with 2n points, P 1, . . . , P 2n),4the corresponding point-based CSP of M is (X , D, C), where4 P may allow relations that are not allowed in M.1760D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782X = { Xi j | i, j ∈ [1..2n], i < j} where each variable Xi j represents a relation between two points P i and P j of P ;D = {D i j} where each D i j is the set of domain values for Xi j and D i j = P i j , the set of point relations between P i and P j ;andC consists of the following constraints:(cid:2)Xik = x ∧ Xkj = y (cid:16)⇒ Xi j ∈ D(cid:17)i jx∈D ik, y∈Dkj(cid:2)( Xl−m− , Xl−m+ , Xl+m− , Xl+m+ ) (cid:18)= μ(r)r /∈Mlm(4)(5)where i < k < j, Dl and one endpoint of interval m.(cid:17)i j= D i j ∩ (x ◦ y), and Xl∗m∗ is the CSP variable representing the relation between one endpoint of intervalTheorem 7. Let Ω be a singleton PA network with n points and ri j be the label of the edge between two points Ii and I j . Then Ω isconsistent iff for any triple (i < k < j) of nodes, ri j ∈ rik ◦ rkj .Theorem 8. Let Ω be a PA network and Ψ be the corresponding point-based CSP defined by Definition 6 without constraints (5). ThenΩ is satisfiable iff Ψ is satisfiable.Theorems 7 and 8 are similar to the Theorems 3 and 5 respectively. We can also construct the proofs of Theorems 7and 8 in a similar way to the proofs of Theorems 3 and 5.Theorem 9. Let Θ be an IA network and Ψ be the corresponding point-based CSP defined by Definition 6. Then Θ is satisfiable iff Ψ issatisfiable.Proof. (⇒) Let Θ (cid:17)be a consistent scenario of Θ . As Θ (cid:17)fined by Definition 6, is an instantiation of Ψ . Hence, Ψ (cid:17)Ψ (cid:17)is a singleton network, its corresponding point-based CSP Ψ (cid:17)satisfies all constraints (5). In addition, as Θ (cid:17), de-is globally consistent,satisfies all constraints (4) due to Theorem 7. As a result, Ψ is satisfiable.(⇐) Let Ψ (cid:17)be an instantiation of Ψ such that all constraints (4) and (5) are satisfied. Let μ−1( Xl−m− , Xl−m+ , Xl+m− ,Xl+m+ ) = r be the inversion of μ(r), such that it maps the combination of the PA atomic relations of four endpoints ( Xl−m− ,Xl−m+ , Xl+m− , Xl+m+ ) to the IA atomic relation r between two intervals l and m. As every variable Xl∗m∗ of Ψ (cid:17)is instantiatedwith exactly one atomic relation, μ−1( Xl−m− , Xl−m+ , Xl+m− , Xl+m+ ) maps to exactly one interval relation.We construct a singleton IA network Θ (cid:17)tion μ−1( Xl−m− , Xl−m+ , Xl+m− , Xl+m+ ). As Ψ (cid:17)consistent by the application of Theorem 7 as Ψ (cid:17)from Ψ (cid:17)satisfies all constraints (5), Θ (cid:17)by labelling each edge (l, m) with the corresponding IA atomic rela-is globallyis a scenario of Θ . In addition, Θ (cid:17)satisfies all constraints (4). As a result, Θ is satisfiable. (cid:2)3.2.1. ExampleFig. 3 shows a point-based CSP corresponding to the original IA network running example from Fig. 2(a), including apartial PA graph to assist in understanding the point-based CSP translation. In this graph (Fig. 3(a)), each interval I i has beenFig. 3. An example of a point-based CSP representation of an IA network.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821761replaced by its endpoints I i− (the start point) and I i+ (the finish point) and all temporal relations between pairs of intervalshave been replaced by corresponding relations between their endpoints. These endpoint relations are the CSP variables inthe new model, which are in turn instantiated with PA atomic relations. For example, the expression X1−1+ = ‘<’ expressesthe constraint that the edge between the endpoints I1− and I1+ must be instantiated with the value ‘<’, thereby expressingthe underlying PA constraint I1− < I1+ . The power we obtain from this CSP representation is that we can disallow additionalunwanted interpretations that cannot be eliminated from a simple PA model. For example, in Fig. 3(a) the PA graph is nota correct alternative representation of the original IA network as it allows interval I1 to overlap (o) with interval I3. In theCSP formalism we can disallow this overlapping relation using the third constraint in Fig. 3(b):¬( X1−3− = ‘<’ ∧ X1−3+ = ‘<’ ∧ X1+3− = ‘>’ ∧ X1+3+ = ‘<’)It should further be noted that the order of domains in D is exactly preserved with respect to their corresponding variablesin X and that all constraints of type (4) that do not further restrict the domain values of a variable have been omitted inthis example.4. Reformulation of IA into SATThe efficiency of modern SAT solvers has triggered considerable interest in encoding problems from different domainsas propositional satisfiability problems. For example, encoding binary CSPs into SAT was studied in [24,55]. In the currentstudy we have now introduced an interval-based and a point-based non-binary IA CSP formulation. In this section, wedescribe three different schemes to encode these formulations into SAT, producing six new encodings. First, we describe theone-dimensional (1-D) support scheme that naturally translates IA CSPs into CNF formulae. We then present extensions ofthe direct and log encoding schemes [24,55].4.1. The SAT 1-D support encodingAn IA network can be encoded as a SAT instance using either interval-based or point-based CSP formulations (as de-scribed in the previous section), in which each Boolean variable xri j represents an assignment of a domain value r to a CSPvariable Xi j such that xri j is true iff r is assigned to Xi j . In a standard SAT encoding, for each CSP variable Xi j having adomain of values D i j , two sets of at-least-one (ALO) and at-most-one (AMO) clauses are used to ensure that exactly onedomain value v ∈ D i j is assigned to Xi j at any time:ALO:AMO:(cid:5)xvi jv∈D i j(cid:2)u,v∈D i j¬xui j∨ ¬xvi j(6)(7)It is common practice to encode a general CSP into a SAT formula without AMO clauses, thereby allowing the CSPvariables to be instantiated with more than one value [55]. A CSP solution can then be extracted by taking any single SAT-assigned value for each CSP variable. However, our two CSP formulation methods strongly depend on the fact that each CSPvariable can only be instantiated with exactly one value at any time. This maintains the completeness of our reformulationmethods (see the proofs above). A counter-example (based on the example in Fig. 1) is shown in Fig. 4 where I p is beforeI w because I p is during Ib and Ib is before I w . In addition, as I p overlaps Ic and Ic starts I w , I p overlaps I w . As a result, I pis either before or overlaps I w . However, neither of the scenarios obtained from this network is consistent. Hence, the AMOclauses cannot be removed from our translation.A natural way to encode the consistency constraints, i.e. constraints (1) and (4) above, is to add the following support(SUP) clauses:SUP:(cid:2)u∈D ik,v∈Dkj¬xuik∨ ¬xvkj∨ xw1i j∨ · · · ∨ xwmi j(8)Fig. 4. A counter-example of removing AMO clauses.1762D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 5. An interval-based 1-D support encoding of the running example.Fig. 6. A point-based 1-D support encoding of the running example.= D i j ∩ (u ◦ v) = {w 1, . . . , wm}. Note that we use the IA composition table for the interval-based reduction methodwhere Dand the PA composition table for the point-based reduction method.(cid:17)i jThe constraints (5) in a point-based CSP are translated into SAT formula using the following forbidden (FOR) clauses:FOR:¬xul−m− ∨ ¬xvl−m+ ∨ ¬xyl+m− ∨ ¬xzl+m+(9)(cid:2)r /∈Mlmwhere u, v, y, z are PA atomic relations and μ(r) = (u, v, y, z). For example, given the PA representation of Xl{o} Xm isμ(o) = (<, <, >, <), the corresponding forbidden clause is ¬x<l−m− ∨ ¬x<l−m+ ∨ ¬x>l+m− ∨ ¬x<We refer to this method as the 1-D support encoding scheme because, it encodes the support values of the originalproblem. In Gent’s support encoding scheme [18], the support clauses are necessary for both implication directions of theCSP constraints. However, in our scheme, only one SUP clause is needed for each triple of intervals (i < k < j), and not forall permutation orders of this triple.l+m+ .Formally, the interval and point-based SAT 1-D support encoding schemes for IA networks are described as follows:Scheme 1 (The interval-based 1-D support encoding).Input: an IA network M with n intervals1: associate a Boolean variable xr2: generate ALO clauses as defined in (6);3: generate AMO clauses as defined in (7);4: generate SUP clauses as defined in (8);i j with each assignment of relation r ∈ Mi j to edge (i, j) between two intervals i and j;Output: the corresponding interval-based 1d support SAT instance.Scheme 2 (The point-based 1-D support encoding).Input: an IA network M with n intervals and its corresponding PA network P1: associate a Boolean variable xr2: generate ALO clauses as defined in (6);3: generate AMO clauses as defined in (7);4: generate SUP clauses as defined in (8);5: generate FOR clauses as defined in (9);i j with each assignment of relation r ∈ P i j to edge (i, j) between two endpoints i and j;Output: the corresponding point-based 1d support SAT instance.4.1.1. ExampleThe interval-based and point-based SAT 1-D support encodings of the running IA network example are respectivelyshown in Figs. 5 and 6. Literals in the following SUP clauses are bolded to highlight the differences with other directencoding examples in Figs. 7 and 8.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821763Fig. 7. An interval-based direct encoding of the running example.Fig. 8. A point-based direct encoding of the running example.4.2. The SAT direct encodingAnother way to represent CSP constraints as SAT clauses is to encode the conflict values, i.e. the nogoods, between anypair of CSP variables [24,55]. This direct encoding scheme for IA networks can be derived from our 1-D support encodingscheme by replacing the SUP clauses with conflict (CON) clauses. If we represent the SUP clauses between a triple ofintervals (i < k < j) as a 3D array of allowable values for the CSP variable Xi j , given the values of Xik and Xkj , then thecorresponding CON clauses can be defined as:(cid:2)CON:u∈D ik,v∈Dkj ,w∈D(cid:17)(cid:17)i j¬xuik∨ ¬xvkj∨ ¬xwi jwhere D(cid:17)(cid:17)i j= D i j − (u ◦ v).(10)The multivalued encoding [41] is a variation of the direct encoding, where all AMO clauses are omitted. As discussedearlier, we did not consider such an encoding because in our IA transformations the AMO clauses play a necessary role.Scheme 3 (The interval-based direct encoding).Input: an IA network M with n intervals1: associate a Boolean variable xr2: generate ALO clauses as defined in (6);3: generate AMO clauses as defined in (7);4: generate CON clauses as defined in (10);i j with each assignment of relation r ∈ Mi j to edge (i, j) between two intervals i and j;Output: the corresponding interval-based direct SAT instance.Scheme 4 (The point-based direct encoding).Input: an IA network M with n intervals and its corresponding PA network Pi j with each assignment of relation r ∈ P i j to edge (i, j) between two endpoints i and j;1: associate a Boolean variable xr2: generate ALO clauses as defined in (6);3: generate AMO clauses as defined in (7);4: generate CON clauses as defined in (10);5: generate FOR clauses as defined in (9);Output: the corresponding point-based direct SAT instance.1764D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17824.2.1. ExampleThe interval-based and point-based SAT direct encodings of the running IA network example are respectively shown inFigs. 7 and 8. Literals in the following CON clauses are bolded to highlight the differences with other 1-D support encodingexamples in Figs. 5 and 6.4.3. The SAT log encodingA more compact version of the direct encoding is the log encoding [24,55]. Here, a Boolean variable xli is true iff thecorresponding CSP variable Xi is assigned a value in which the lth bit of that value is 1. We can linearly derive log encodedIA instances from direct encoded IA instances by replacing each Boolean variable in the direct encoding with its bitwiserepresentation. As a single instantiation of the underlying CSP variable is enforced by the bitwise representation, ALO andAMO clauses are omitted. However, extra bitwise prohibited (PRO) clauses are needed (if necessary) to prevent bitwiserepresentations of undesired Boolean variables from being instantiated. For example, if the domain of variable X has threevalues then we will need a minimum of two bits to represent those values. As two bits can represent four values, we haveto add the clause ¬x03 to prevent the fourth value from assigning to X . Another way to remove redundant bitwise3representations is to map them to valid values. However, this binary encoding [17] can generate exponentially more conflictclauses than the log encoding and hence is not considered further in this study.∨ ¬x1Scheme 5 (The interval-based log encoding).Input: an IA network M with n intervals1: associate a temporary Boolean variable pri j with each assignment of relation r ∈ Mi j to edge (i, j) between two intervals iand j;2: generate CON clauses as defined in (10);3: replace each occurrence of a temporary Boolean variable pri j with its bitwise representation bwri j , note that each bwri j isactually a combination of Boolean variables lvk;4: generate PRO clauses if necessary;Output: the corresponding interval-based log SAT instance.Scheme 6 (The point-based log encoding).Input: an IA network M with n intervals and its corresponding PA network P1: associate a temporary Boolean variable pri j with each assignment of relation r ∈ P i j to edge (i, j) between two endpointsi and j;2: generate CON clauses as defined in (10);3: generate FOR clauses as defined in (9);4: replace each occurrence of a temporary Boolean variable pri j with its bitwise representation bwri j , note that each bwri j isactually a combination of Boolean variables lvk;5: generate PRO clauses if necessary;Output: the corresponding point-based log SAT instance.4.3.1. ExampleThe interval-based and point-based SAT log encodings of the running IA network example are respectively shown inFigs. 9 and 10.5. Beyond SAT: The SMT encodingOver the last few years, there has been increasing interest in the SAT community to develop an alternative to SAT thatcan deal effectively with non-Boolean problems. In this paper, we are particularly interested in SMT techniques, which aredesigned to decide the satisfiability of quantifier-free (QF) first-order logic formulae with respect to one or more backgrounddecidable theories (such as linear arithmetic, the theory of numbers, the theory of arrays or the theory of bit-vectors). ApartFig. 9. An interval-based log encoding of the running example.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821765Fig. 10. A point-based log encoding of the running example.from successful applications in formal verification and compiler optimisation, SMT solvers are also the best for solvingquantitative temporal reasoning problems such as STPs, TCSPs and DTPs.An SMT problem is defined by a combination of a Boolean formula and predicates in other theories. Deciding the sat-isfiability of an SMT problem involves finding an assignment for all Boolean and theory specific variables that satisfies theBoolean formula and all theory specific predicates or proving that there is no such assignment. Consequently, developing anefficient SMT solver has involved finding a good integration between SAT and theory-specific techniques.Currently, many SMT solvers support difference constraints, i.e. constraints in the form of x − y (cid:19)(cid:20) b where x and y arereal- or integer-valued variables, b is a numeric constant and (cid:19)(cid:20)∈ {<, (cid:2), >, (cid:3), =, (cid:18)=}. These types of constraints are calledQF-RDL or QF-IDL (i.e. the quantifier-free real difference logic or the quantifier-free integer difference logic) depending onwhether the values of x and y are real or integer numbers. In this paper, we use the QF-IDL logic to translate an IA networkM with n intervals into a point-based SMT formula with 2n integer-valued variables, where each SMT variable xi representsan endpoint P i of the corresponding PA network P (with 2n points, P 1, . . . , P 2n) of M.5We then add the following domain (DOM) constraints to ensure that the instantiation of SMT variables xi and x j satisfiesthe set of point relations P i j between two endpoints P i and P j in P . Note that u ∈ {<, =, >} is a PA atomic relation.(cid:5)DOM:xi u x ju∈P i j(11)Here, we do not need to add constraints to ensure the path consistency between any triplets (i < j < k) of endpointsof P as we did for the point-based CSP formulation in Section 3.2. As each SMT variable xi is instantiated with integervalues, an instantiation of xi represents the position of the corresponding endpoint P i in the time line. Consequently, asolution to this SMT formula (i.e. all DOM constraints are satisfied) represents a consistent mapping of all endpoints of Ponto the time line, i.e. a consistent scenario of P .Finally, we add the following forbidden (FOR) constraints to rule out all IA relations r that are not in the set of IArelations Mlm between two intervals Il and Im but may be enabled during the translation of the original IA network M intoits corresponding PA network P :(cid:2)FOR:¬(xl− u xm− ) ∨ ¬(xl− v xm+ ) ∨ ¬(xl+ y xm− ) ∨ ¬(xl+ z xm+ )(12)r /∈Mlmwhere u, v, y, z are PA atomic relations and μ(r) = (u, v, y, z).Formally, the point-based SMT QF-IDL encoding scheme (or in short, the point-based SMT encoding) for IA networks isdescribed as follows:Scheme 7 (The point-based SMT QF-IDL encoding).Input: an IA network M with n intervals and its corresponding PA network P1: associate an integer-valued variable xi with each endpoint P i in P ;2: generate DOM constraints as defined in (11);3: generate FOR constraints as defined in (12);Output: the corresponding point-based SMT QF-IDL formula.Theorem 10. Let Θ be an IA network and Π be the corresponding point-based SMT formula formulated by Scheme 7. Then Θ issatisfiable iff Π is satisfiable.Proof. The proof of this theorem is trivial and can be constructed in a similar manner as the proof of Theorem 9. (cid:2)5 P may allow relations that are not allowed in M.1766D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 11. A point-based SMT encoding (in Yices’ input language) of the running example.5.1. ExampleThe point-based SMT encoding of the running IA network example is shown in Fig. 11 using the Yices’ input language.6The ‘run’ commands are to tell Yices to check for the satisfiability of the input formula and to return a satisfiable model ifone exists.6. Test instances and algorithm selection6.1. Test instancesAs there is a lack of large sized realistic IA benchmarks, the majority of empirical studies in this field have relied onrandomly generated IA problems [29–31,36,53]. This reliance has the advantage of allowing researchers to “investigate howalgorithmic performance depends on problem characteristics” and be able to “predict how an algorithm will perform on agiven problem class” [23].Among the different current models for randomly generating IA instances [31,36,53], the models proposed by Nebel[36] provide more control of the characteristics of generated instances. We therefore based our empirical study on randomproblems generated using Nebel’s A(n, d, s) model [36]. The resulting instances are temporal constraint graphs with n nodes(i.e. intervals) and an average degree of d constrained edges (i.e. interval relations). Constrained edges are then uniformlylabelled with an average size of s IA atomic relations, where 1 (cid:2) s (cid:2) 12. Unconstrained edges are labelled with all 13 IAatomic relations.We chose the A(n, d, s) model as it allows the constraints to be uniformly chosen from the entire set of IA relations andnot limited to only a small sets of very hard constraints like the H(n, d) model, or to generating only satisfiable instanceslike the S(n, d, s) model [36]. In his study, Nebel [36] pointed out that the average degree d is a critical parameter that candefine the phase transition of IA instances independently from the number of nodes. He showed that when s is fixed to 6.5,the phase transition happens around d = 9.5.To investigate the performance effects of our six SAT encoding schemes and one SMT encoding, we use Nebel’s generator7to generate IA instances where the number of nodes was varied from 20 to 100. We then pre-processed these IA instancesusing the path consistency algorithm proposed by van Beek [53] before encoding them into SAT or SMT formulae. We foundthat this preprocessing significantly reduced the problem size of SAT-encoded and SMT-encoded IA instances both in termsof the number of variables and the number of clauses. Section 7.1 discusses in detail the effects of this pre-processingapproach on our SAT encodings.6 See http://yices.csl.sri.com/language.shtml.7 Available for download at ftp://ftp.informatik.uni-freiburg.de/documents/papers/ki/allen-csp-solving.programs.tar.gz.6.2. Algorithm selectionD.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821767SAT solving is one of the most active research areas in computer science and artificial intelligence. It has been shown thatSLS techniques (such as the WalkSAT family [46]) and recent clause weighting techniques (such as SAPS [25] and PAWS [49])are significantly better than systematic search on random SAT problems. However, although SLS solvers are the best choicefor many realistic problems [6,27,28], systematic solvers were still the leading performers in the recent SAT competitions8on the crafted and industrial categories problems, where test cases are highly structured.As local search solvers (e.g. PAWS [49] and its many-valued variant MV-PAWS [40]) performed poorly in comparison withthe systematic solver zChaff [35] (version 2004.11.25) on all six different SAT encodings of IA instances in our preliminarystudy [38], we decided to use only systematic search in this study.9 Another reason for choosing systematic solvers is thatthey work on both satisfiable and unsatisfiable instances and hence allow us to evaluate the performance of SAT solvers onthe phase transition of IA instances.In this study, we selected MiniSAT [14] version 2 (build 070721)10 as our benchmarking SAT solver as it is one of thebest systematic solvers for both random and structured problems. MiniSAT uses an efficient mechanism for learning clausesand won the championship in the 2005 SAT competition. As our SMT solver, we used Yices [13] version 1.0.911 as it wasshown to be the best overall SMT solver in the 2006 and 2007 SMT competitions.12To compare with existing IA approaches, we chose Nebel’s solver [36] as it is the best known systematic solver fornative IA representation.13 In particular, we used two variants of Nebel’s backtracking algorithm, NBTI and NBTH. NBTIinstantiates each edge with an atomic relation in I, whereas NBTH assigns a relation in the set H of ORD-Horn relationsto each edge. The other heuristics used in Nebel’s backtracking algorithm were set to default.Finally, we included TSAT [48], the specialised SLS solver that uses an end point ordering representation of IA instances,described in Section 2.3. By exploiting special heuristics suited to this representation (such as domain and constraint skip-ping) TSAT was shown to perform better than both NBTI and NBTH on hard IA instances [48].7. The effects of encoding on the problem sizeIn 1995, Nebel and Bürckert [37] pointed out that qualitative temporal instances can be translated to SAT instances butsuch a translation causes an exponential blowup in problem size. In order to study the effect of our SAT translation on thesize of the generated problems, we first generated an extensive benchmark test set of A(n, d, 6.5) IA instances by varyingthe average degree d from 1 to 20 (in steps of 0.5 from 8 to 11 and in steps of 1 otherwise) and n from 20 to 50 (in stepsof 5). We generated 500 instances for each n/d data point to obtain a set of 23 × 7 × 500 = 80, 500 test instances. We thenused our SAT and SMT encoding schemes to translate these instances to SAT and SMT formulae respectively. Fig. 12 graphsthe median number of variables, clauses and literals of the corresponding SAT and SMT encodings and the median timefor translation. We use PS, PD, and PL to denote the point-based 1-D support, direct and log SAT instances; IS, ID and ILto denote the interval-based 1-D support, direct and log SAT instances; and SMT to denote the point-based SMT instances;respectively.The results show that the point-based SMT encoding dominates the other encoding schemes in producing both thesmallest problem sizes and the fastest translation times. As graphed in Fig. 12, the SMT encoding produces instances that areat least 40 times smaller than its closest SAT rival. In addition, the translation of IA instances into SMT formulae happenedalmost instantly (hence the SMT translation times are omitted from Fig. 12). This result is not surprising as the translationof an IA network into an SMT formula is a relatively straightforward carry over from the corresponding PA network.Putting aside the results of the SMT encoding, the graphs in Fig. 12 clearly show that point-based SAT encoding producesinstances with significantly smaller problem sizes (in terms of the number of clauses) and in a shorter time than interval-based SAT encoding. Among the three SAT encoding schemes, 1-D support was the best, followed by the direct encodingscheme. Although the interval-based and point-based log schemes generated SAT instances with the smallest number ofvariables, they took the longest time to translate and produced instances with more lengthy clauses. As shown in Fig. 12,the median CPU time used for the point-based 1-D support scheme was from 2 to 20 times faster than other SAT encodingschemes. Similar results were also observed when comparing the median number of clauses and literals of the point based1-D support SAT instances with the other SAT encoded instances.8 Results for SAT competitions are available at http://www.satcompetition.org/.9 Although PAWS with its weight decay parameter fixed to 10 lost to R+AdaptNovelty+in the 2005 SAT competition, a tuned version of PAWS stronglydominates other local search solvers [2]. In our preliminary study, both variants of PAWS were run with their optimal tuned parameter settings.10 Source code is available at http://www.cs.chalmers.se/Cs/Research/FormalMethods/MiniSat/MiniSat.html.11 Binary version is available at http://yices.csl.sri.com/.12 Results for SMT competitions are available at http://www.smtcomp.org.13 Source code is available at ftp://ftp.informatik.uni-freiburg.de/documents/papers/ki/allen-csp-solving.programs.tar.gz.1768D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 12. The median number of variables, clauses and literals, and the median time taken to translate A(n, d, 6.5) IA instances into SAT- and SMT-encodedinstances without path consistency preprocessing (11,500 instances, where d = 1–20, per each data point). The CPU time of the point-based SMT encodingis omitted as the translation was almost instant.7.1. The impact of path consistency preprocessingSince the path consistency algorithm is an efficient approximation approach to solve IA problems [29,51,53], most suc-cessful IA backtracking algorithms use it before and during the search to remove as many inconsistent relations betweenintervals (or endpoints) as possible [30,31,36,53]. Hence, it would appear reasonable to try and minimise the problem sizeof the SAT and SMT encoded instances by applying path consistency algorithms to native IA instances before translation. Inaddition, as path consistency algorithms are polynomial, we would expect a combination of path consistency and SAT (orSMT) to be more efficient than trying to solve unpreprocessed SAT (or SMT) encoded instances.Here, we used the vBM path consistency algorithm [53],14 taken from Nebel’s backtracking solvers (NBTI and NBTH),to evaluate the impacts of preprocessing native IA instances before SAT or SMT translations. We ran the vBM algorithm onall benchmark instances generated in the previous experiment. Fig. 13 graphs the median number of variables, clauses andliterals, and the median time taken to translate these IA instances, with and without the path consistency preprocessing,into point-based SAT instances.The results clearly show the advantage of preprocessing native IA instances using path consistency algorithms beforeSAT translation. With path consistency preprocessing, the higher the probability of inconsistency in the IA instances (i.e. thehigher average degree d), the more improvement in minimising the problem size of SAT encoded instances was observed.Similar benefits were also observed when combining path consistency with other SAT and SMT encoding schemes.14 The source code of this path consistency algorithm was included in Nebel’s solvers.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821769Fig. 13. The median number of variables, clauses and literals, and the median time taken to translate A(50, d, 6.5) IA instances into the point-based SATinstances with and without path consistency preprocessing (500 instances, where d = 1–20, per each data point).8. The phase transition of SAT/SMT encodingsAn important advantage of using randomly generated benchmark test sets is that the average difficulty of these instancescan be controlled. Cheeseman et al. [8] pointed out that the satisfiability distribution of problem sets can be separated intotwo regions: one where most of the problems have many solutions and are relatively easy to solve; and one where mostof the problems are unsatisfiable and this is also relatively easy to prove. They conjectured that the phase transition, theborder between the two regions, depends strongly on the critical value of at least one order parameter. They also found thatinstances around the phase transition are harder to solve than other instances. Later, several empirical studies reconfirmedthis conjecture [42,47].Ladkin and Reinefeld [30] were the first to study the phase transition of IA instances. They observed this transition tobe in the range of 6 (cid:2) c × n (cid:2) 15 for c (cid:3) 0.5, where c is the completion coefficient [29] and n is the number of intervals.However, this phase transition depends on the problem size n, and hence does not allow “the generation of arbitrarily hardinstances” [36]. In his study, Nebel [36] pointed out that the average degree d is a critical parameter that can define thephase transition of IA instances independently of the number of nodes. He showed that with s fixed to 6.5, the phasetransition happens around d = 9.5 for the A(n, d, s) model. He also observed that the runtime of his backtracking algorithmpeaked at d = 9.5 for s = 6.5.As our SAT and SMT translation methods were theoretically proved sound and complete, we expected that the followingproperties would also be true for our SAT-encoded and SMT-encoded IA instances:i) The phase transition of SAT-encoded and SMT-encoded instances happens at the same critical value of the averagedegree parameter d as for the original IA instances; and1770D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 14. The probability of satisfiability for A(n, d, 6.5) (500 instances per data point).ii) The performance of SAT solvers on SAT-encoded instances is proportionally similar to the performance of temporalbacktracking algorithms on the original IA instances; andiii) The performance of SMT solvers on SMT-encoded instances is proportionally similar to the performance of temporalbacktracking algorithms on the original IA instances.In order to verify these properties, we conducted a similar experiment to that reported in Nebel’s study [36]. We ranNBTI and NBTH on IA instances generated in the previous section and MiniSAT and Yices respectively on the correspondingSAT-encoded and SMT-encoded instances. All solvers were timed out after one hour.As expected, the probability of satisfiability for our SAT-encoded and SMT-encoded instances was the same as the prob-ability of satisfiability for the original IA instances, regardless of the translation method. This is illustrated in Fig. 14 whichshows that the phase transition happens around d = 9.5 for s = 6.5 regardless of instance size or representation. Theseresults are consistent with the earlier work of Nebel [36].However, the performance of MiniSAT on our six different SAT encodings was significantly different from the performanceof NBTI and NBTH on the native IA representations. As graphed in Fig. 15, the runtime of NBTI and NBTH both peakedaround the phase transition point, i.e. d = 9.5. In contrast, the runtime peaks of MiniSAT on the SAT instances were shiftedaway from the phase transition. Fig. 16 shows that the median and mean CPU time of MiniSAT on the point-based 1-Dsupport, direct and log SAT-encoded instances peaked around a d value of 8, 8 and 3, respectively. In addition, the CPU timeof MiniSAT on instances surrounding these peaks was relatively similar, regardless of which SAT encoding scheme was used.This result is further supported when we take into account the performance of MiniSAT on the interval-based SATinstances. Fig. 17 graphs the median and mean CPU time of MiniSAT on the corresponding interval-based 1-D support,direct and log SAT-encoded instances, respectively. Here we can see that the runtime peaks of MiniSAT are shifted awayfrom the phase transition in the same as they were on the point-based SAT instances, regardless of which SAT encodingscheme is used. However, the CPU time of MiniSAT on the interval-based direct and log instances peaked at slightly differentpoints in comparison to their corresponding point-based instances, i.e. with d equal to 7 (compared to 8) and 4 (comparedto 3), respectively. Only the runtime of MiniSAT on the interval-based 1-D support instances remained the same as thepoint-based instances (both peaking at 8).A similar story develops when we look at the performance of Yices on the SMT-encoded instances. Fig. 18 graphs themedian and mean CPU time of Yices on the point-based SMT instances. Here we can see that the runtime peaks of Yices (atd = 7) are shifted further away from the phase transition than the runtime peaks achieved by MiniSAT (at d = 8) on boththe point-based 1-D support and direct SAT instances.These results are quite surprising and contrast with the results of previous studies on the phase transition of randomproblems [8,36,45,47]. Intuitively, the further left we move from the phase transition, the more solutions an instance hasand as a consequence, the easier this instance should be to solve. However, this conjecture is not true for our SAT and SMTencoding schemes. Our empirical results clearly show that the hard region, where instances take significantly more timeto solve, does not always happen around the phase transition. In contrast, the representation or encoding of the probleminstance plays an important role in determining where hard region will occur.9. An empirical comparison between SAT and SMT encodingsFrom the graphs in Figs. 16–18, we can conclude that:i) A point-based formulation method produces better results than an interval-based formulation method, regardless ofhow IA instances are generated (in terms of the number of nodes n, the average degree d or the average label size s)or the SAT encoding employed.ii) The 1-D support encoding scheme produces the best results, followed by the direct and log encoding schemes, regard-less of how IA instances being generated (in terms of the number of nodes n, the average degree d or the average labelsize s) or the formulation method employed.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821771Fig. 15. The performance of NBTI and NBTH on native IA instances.iii) SAT encoding schemes produce better results than the SMT encoding scheme. In particular, the performance of Yices onSMT instances is worse than the performance of MiniSAT on the top three SAT encodings (i.e. point-based and interval-based 1-D support and point-based direct encodings) but is better than the performance of MiniSAT on the other threeSAT encodings.iv) Among the six SAT encoding schemes considered, the point-based 1-D support encoding is the most suitable scheme totranslate IA instances into SAT formulae.Fig. 19 graphs the median CPU time of MiniSAT and Yices respectively on the SAT and SMT encodings of IA instances atdifferent problem sizes. These graphs give us a closer look at how the SAT and SMT encodings affect performance in thehardest regions (as discussed in the previous sections).From this we can see that the performance of MiniSAT on a point-based encoding scales better than its performanceon an interval-based encoding, i.e. the bigger the problem instance is, the bigger the gap between the point versus intervalperformance lines plotted in these graphs. Among the various SAT encodings, the performance of MiniSAT on the point-based 1-D support instances scaled steadiest and was nearly linear, having an average runtime of around 8.36 seconds whilethe average runtime of MiniSAT on the second best encoding (the interval-based 1-D support scheme), was around 21.16seconds at A(50, 8, 6.5). The performance of MiniSAT on these six different SAT encodings is ordered from best to worst asfollows: point-based 1-D support (PS) < interval-based 1-D support (IS) < point-based direct (ID) < interval-based direct(ID) < point-based log (PL) < interval-based log (IL). If we take into account the results of point-based SMT instances,this order is clearly divided into two exact halves with Yices’ performance on SMT instances being worse than MiniSAT’sperformance on point-based direct instances but better than MiniSAT’s performance on interval-based direct instances. Insummary, these results clearly demonstrate the benefit of using the 1-D support SAT encoding over the direct and log SATencodings and the SMT encoding.1772D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 16. The performance of MiniSAT on point-based 1-D support, direct and log SAT-encoded instances.It is worth noting that SMT solvers for QF-IDL or QF-RDL usually translate an SMT formula (either eagerly or lazily) into aSAT formula and pass it to a DPLL SAT solver [13]. Consequently, the question arises as to whether the inferior performanceof Yices on the SMT-encoded IA instances (in comparison to MiniSAT on the SAT-encoded instances) is because Yices’ un-derlying SAT engine performs significantly worse than MiniSAT. In order to test this, we re-ran Yices on the point-based 1-DD.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821773Fig. 17. The performance of MiniSAT on interval-based 1-D support, direct and log SAT-encoded instances.support SAT-encoded A(50,d,6.5) instances with Yices simply calling its SAT engine to solve the CNF input formula.15 Yices’results on the SAT-encoded instances are graphed in Fig. 20 against its performance on the corresponding SMT-encodedinstances and against MiniSAT on the same SAT-encoded instances. These graphs clearly show that the Yices internal SATsolver has almost identical performance to MiniSAT on the 1-D support SAT-encoded instances and that the large difference15 The developers of Yices confirmed via email discussion that Yices will exclusively employ its SAT engine to solve a pure CNF formula.1774D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 18. The performance of Yices on point-based SMT-encoded instances.Fig. 19. The performance of MiniSAT and Yices on SAT-encoded and SMT-encoded IA instances respectively. The ‘SMT’ key represents Yices. All other keysrepresent MiniSAT on the various encodings, where ‘P’ = point-based, ‘I’ = interval-based, ‘S’ = support, ‘D’ = direct and ‘L’ = log.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821775Fig. 20. The performance of MiniSAT and Yices on SAT-encoded or SMT-encoded IA A(50, d, 6.5) instances. The ‘SMT’ key represents Yices on SMT-encodedinstances. Other keys represent MiniSAT and Yices on the SAT-encoded instances, where ‘M’ = MiniSAT, ‘Y’ = Yices, and ‘PS’ = point-based 1-D support.Fig. 21. The median and mean number of unit propagations performed by MiniSAT on point-based SAT-encoded IA A(45, d, 6.5) instances. The keys representMiniSAT on the various encodings, where ‘P’ = point-based, ‘S’ = support, ‘D’ = direct, and ‘L’ = log.in performance between Yices on the SMT-encoded instances and MiniSAT on the SAT-encoded instances is due to the useof SMT-encoding and the subsequent translation of SMT into SAT.Although the search trees (i.e. the number of variables) for 1-D support and direct SAT-encoded instances are the samesize, the graphs in Fig. 12 show that the clause-to-variable ratios of the 1-D support SAT-encoded instances are significantlysmaller than for the direct SAT-encoded instances. This difference partly explains the superior performance gained fromusing the 1-D support encoding over the direct encoding on satisfiable IA instances. However, MiniSAT also gained a signif-icant performance boost when solving unsatisfiable 1-D support SAT-encoded instances in comparison with its performancewhen solving unsatisfiable direct SAT-encoded instances, despite previous studies [8,9,19,34] showing that the smaller theclause-to-variable ratio of a CNF formula, the harder it is to prove the unsatisfiability of that formula. This motivated us tofind an explanation for these observations.Theoretically, it has been shown that a DPLL solver with unit propagation on a support SAT-encoded instance maintainsfull arc consistency during the search [18], while on direct SAT-encoded instances it only maintains a weaker form ofarc consistency (equivalent to a forward checking CSP solver) [55]. However, these results are limited to SAT instancestranslated from binary CSPs whereas our two IA-to-CSP formulations produce ternary CSPs. According to Bessière et al. [7],unit propagation on our 1-D support and direct SAT-encoded IA instances would enforce relational 2-arc-consistency andrelational 3-arc-consistency respectively. Although their experiments confirmed that support encoding is better than directencoding for ternary CSPs, to the best of our knowledge there is no theoretical comparison between these two encodingson ternary CSPs.From an examination of MiniSAT’s use of unit propagation and its branching heuristic we found two explanations for∨its superior performance on the support-encoded instances. Firstly, the direct scheme replaces each support clause (¬xuik1776D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 22. The median number of decisions and conflict clauses produced by MiniSAT on point-based SAT-encoded IA A(45, d, 6.5) instances. The keys representMiniSAT on the various encodings, where ‘P’ = point-based, ‘S’ = support, ‘D’ = direct, and ‘L’ = log.i j∨ xw1i j∨ · · · ∨ xwm) by a series of nc conflict clauses (¬xuikw¬xvi j ) (nc varies from 1 to 12 conflict clauses),kjmeaning unit propagation on direct SAT-encoded instances will do more work than on support SAT-encoded instances.As unit propagation accounts for more than 90% of the run time of a DPLL solver [12,35], such solvers should benefitsignificantly from support encoding. This is confirmed by the plots of the median and mean number of unit propagationsmade by MiniSAT on the support and direct SAT-encoded instances shown in Fig. 21.∨ ¬xvkj∨ ¬x(cid:17)lSecondly, MiniSAT selects the variable with the highest number of occurrences in recent conflict clauses to split theik and xvkj in a series of conflict clauses (¬xuwsearch tree. Consequently, variables xui j ) have a higher chanceof selection at each branching node than other variables in the same series. In contrast, all variables in the correspond-ing support clauses are treated equally. Furthermore, MiniSAT always branches on the negative value of a variable first.Consequently, MiniSAT on direct SAT-encoded instances becomes less effective and efficient in enforcing path consistencyconstraints (e.g. constraints 1 or 4) than for support SAT-encoded instances. In other words, MiniSAT gains less informationand guidance from direct encoding than from support encoding. This is illustrated in Fig. 22 which shows MiniSAT mademore decisions and produced more conflict clauses when solving direct SAT-encoded instances than for support SAT-encodedinstances. (Note that the higher the number of conflict clauses generated, the higher the number of times MiniSAT needs tobacktrack.)∨ ¬xvkj∨ ¬xik(cid:17)lWe then altered MiniSAT so that it always branches on the positive value of the branching variable first, meaning itwill more strictly enforce path consistency constraints on direct SAT-encoded IA instances. The results in Fig. 23 showthe superiority of the branch-positive-first strategy, supporting our conjecture that the original MiniSAT with its branch-negative-first policy is not the most suitable for direct SAT-encoded IA instances.Finally, although the log SAT-encoded encoding scheme produces instances that are O (n × (|s| − log |s|)) times smallerthan the other two schemes in terms of the number of variables [24], its bitwise representation of variables also loosens therelationship between variables in their constraints. Consequently, a SAT solver has to spend more time correcting the valuesof the bitwise variables of the log encoding than it would on the direct encoding. This is confirmed by the large number ofdecisions MiniSAT had to make when solving log SAT-encoded instances shown in Fig. 22.10. An empirical evaluation of SAT/SMT versus existing approachesAs the results in previous sections provided encouraging evidence of the practical feasibility of our SAT/SMT approaches,we decided to perform a thorough evaluation of the best performing versions of each approach (MiniSAT on point-based1-D support SAT instances and Yices on point-based SMT instances) in comparison to the two most well-known existingapproaches (NBTH on native IA instances and TSAT on the endpoint ordering model).We generated another benchmark test set of A(n, d, 6.5) IA instances by varying the average degree d ∈ {1, 3, 5, 7, 8, 8.5,9, 9.5, 10, 10.5, 11, 12, 14, 16, 18, 20} across nine values of n varied from 60 to 100 (in steps of 5). We generated 100 in-stances for each n/d data point to obtain a set of 16 × 9 × 100 = 14,400 test instances. This test set allows us a closer lookat the performance of different approaches around the phase transition while still providing a general view across the entiredistribution. We then ran NBTH on these instances and MiniSAT and Yices on the corresponding point-based 1-D supportSAT instances and point-based SMT instances respectively. All solvers were timed out after one hour for n < 80 and fourhours for n (cid:3) 80.Fig. 24 plots the median and mean CPU time of MiniSAT, Yices and NBTH on these benchmark instances. Here we cansee that MiniSAT strongly dominates Yices and NBTH as the problem size grows. In particular, the CPU time of MiniSAT atD.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821777Fig. 23. The head-to-head comparison on the effects of the branch-negative-first and branch-positive-first policies on the performance of MiniSAT on point-based direct SAT-encoded IA A(50, d, 6.5) instances (500 instances per each d data point, where d = 1–20).n = 100 is about 30 times better than for Yices (both in terms of median and mean time) and about 10 times better than forNBTH (in terms of mean time). In addition, when the test instances became bigger (e.g. n (cid:3) 80), the median and mean timecurves of Yices and NBTH were exponentially increasing while the MiniSAT curves remained nearly polynomial. A closerlook at the results produced further evidence to support this conclusion: with a one hour time limit, MiniSAT was unable tosolve only 1 of the entire benchmark set of 14,400 instances (this instance took MiniSAT an extra 207.92 seconds to solve),while 323 and 1774 instances remained unsolved for NBTH and Yices respectively. When the time limit was raised to fourhours, NBTH and Yices were still unable to solve 103 and 812 instances respectively. This shows that the performance ofMiniSAT scaled significantly better than NBTH and Yices on these extremely hard instances. The detailed probabilities offailure for Yices and NBTH are graphed in Fig. 25.It should also be noted that although the average CPU time of MiniSAT was significantly better than for NBTH (asgraphed in Fig. 24), the median CPU time of MiniSAT was only slightly better. This observation led us to conjecture thatMiniSAT performs better than NBTH on hard instances. A more thorough analysis of the results revealed that all the in-stances that NBTH failed to solve (either within a one hour limit or a four hour limit) fall in the area surrounding the phasetransition (see Fig. 25). This conjecture is further supported when we look at the runtime distribution of MiniSAT and NBTHon all instances within the range of d = 8 to 11 in Fig. 26. These graphs also confirm that the performance of MiniSAT scalesmuch better than the other methods as the number of time intervals in the test instances increases.The performance of TSAT on satisfiable instances was first shown to be better than NBTH in [48] and this result was ini-tially confirmed in our preliminary study [38]. In a further investigation, we ran TSAT on all 3985 hard satisfiable instances(i.e. instances within the range of d = 8 to 11) generated in this study in order to obtain a better view of the relative perfor-mance of our approaches, NBTH and TSAT. As TSAT is a local search algorithm, we ran TSAT 100 times for each satisfiableinstance with a time-out of one hour for n < 80 and four hours for n (cid:3) 80.1778D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 24. The CPU time of MiniSAT, Yices and NBTH on the point-based 1-D support SAT instances, the point-based SMT instances and the native IA instancesrespectively.We then plotted the performance of TSAT against the performance of MiniSAT, Yices and NBTH extracted from the pre-vious experiment in Fig. 27. These results further emphasise the superior performance of our SAT approach against existingapproaches, but showed a reversal of performance between TSAT and NBTH, with NBTH now appearing convincingly betterthan TSAT. This reversal is perhaps explained by the relatively small number of instances used in our preliminary study.D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821779Fig. 25. The probability of failure of Yices and NBTH on the point-based SMT instances and the native IA instances respectively.11. An empirical evaluation of SAT versus SMT on structured SMT problemsSo far, we have shown that our SAT approach significantly outperforms other approaches for solving qualitative temporalproblems. As discussed in Section 6.1, we have followed the common trend of IA-related research [29–31,36,53] and limitedour benchmarks to randomly generated IA problems. However, although randomly generated problems have useful features(such as controllable size and hardness), they lack the structure that can be found in non-random instances. For this reason,we decided to extend our benchmark set with the more realistic diamonds instances.16 These problems were generated byOfer Strichman17 and later translated into SMT-LIB format by Albert Oliveras. Each diamonds instance is specified by (n, s),where n is the number of diamonds and s is the number of edges of each diamond divided by 2. A diamonds instance isencoded into a SMT formula as a conjunction of disjunct clauses, where each clause contains elements in the followingform: ((cid:3) (− a b) 1) or (not ((cid:3) (− a b) 1)). Given that the variables a and b are integer numbers, the translation ofthese instances into our qualitative temporal SAT encodings is a straightforward task, as each element is equal to (a > b) or(a (cid:2) b), respectively.The left graph in Fig. 28 compares the performance (in seconds) of MiniSAT and Yices on diamonds instances wheren varies from 10 to 18 and s varies from 2 to 10. MiniSAT was run on the point-based 1-D support encodings of theseinstances whilst Yices was run on the original SMT encodings. The results shows that our SAT approach dominates on allthe (n, 2) instances and the three biggest (n, 3) instances but is outperformed by Yices on all other instances (which makeup the majority of the test set). In addition, the SAT encodings of the diamonds (n, 10) instances become too big for MiniSATto handle when n > 12.16 The majority of QF-IDL benchmarks in the SMT-LIB repository (http://www.sat-lib.org/) require reasoning with metric information and hence are un-suitable for our study.17 http://iew3.technion.ac.il/Home/Users/ofers.phtml.1780D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782Fig. 26. The runtime distribution of MiniSAT, Yices and NBTH on A(n, d, 6.5) instances, where d = 8–11.Fig. 27. The results of MiniSAT, Yices, NBTH and TSAT on satisfiable A(n, d, 6.5) instances, where d = 8–11.However, a closer inspection of the diamonds problem set provided us with a solution to this size blow-up problem:we found that most instances contain several long chains of inequalities of the form: (a (cid:2) c1 (cid:2) c2 (cid:2) · · · (cid:2) ck (cid:2) b) wherec1, c2, . . . , ck do not appear in any other inequalities. Our conjecture is that the original intention of these ci variables wasto enforce a metric distance constraint between a and b. However, such constraints appear to be very ‘weak’ as the solvercan freely set the distance between a and b to any number (cid:3) 0. In addition, the constraint becomes redundant from theD.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–17821781Fig. 28. A comparison of the performance of MiniSAT and Yices on the original and processed SMT-LIB diamonds problems.qualitative point of view as once a < b we can allow an unlimited number of ci between a and b. It is the inclusion of civariables in the diamonds instances that makes the size of the corresponding SAT encoding grow exponentially (due tothe requirement of extra clauses to maintain consistency). Once these redundant ci variables are removed, the size of SAT-encoded diamonds instances is greatly reduced, leading to significant boost in the performance of MiniSAT. This is shown inthe right graph of Fig. 28, where MiniSAT now clearly dominates Yices on the majority of instances where n > 11.12. Conclusions and future workIn conclusion, we have proposed six different methods to formulate IA networks into SAT formulae and one point-based method to formulate IA networks into SMT instances. We also provided the theoretical proofs of completeness ofthese transformation techniques. Although our empirical results confirmed that the phase transition of IA networks mappeddirectly into these SAT and SMT encodings, they also showed that the hard regions of these problems were surprisinglyshifted away from the phase transition areas after transformation into SAT or SMT. Evaluating the effects of these encodings,we found that the point-based 1-D support SAT scheme is the best among the seven different encoding schemes examined.Our results also revealed that MiniSAT combined with our point-based 1-D support SAT scheme could solve IA instancessignificantly faster than existing IA solvers working on the equivalent native IA networks.In future work we anticipate that the performance of our SAT-based approach can be further improved by exploitingthe special structure of IA problems in a manner analogous to the work on TSAT [48]. In addition, we plan to extend ourSAT-based approach to cover INDU networks [43], which enable qualitative reasoning with the duration between pairs ofintervals. The possibility also opens up of integrating our approach to temporal reasoning into other well known real worldproblems such as planning. Given the success of SAT solvers in many real world domains, our work promises to expand thereach of temporal reasoning approaches for IA to encompass larger and more practical problems.AcknowledgementsWe thankfully acknowledge the financial support from NICTA and the Queensland government. NICTA is funded by theAustralian Government as represented by the Department of Broadband, Communications and the Digital Economy and theAustralian Research Council through the ICT Centre of Excellence program.References[1] J.F. Allen, Maintaining knowledge about temporal intervals, Communications of the ACM 26 (1983) 832–843.[2] Anbulagan, D. Nghia Pham, J. Slaney, A. Sattar, Old resolution meets modern SLS, in: Proceedings of the Twentieth National Conference on ArtificialIntelligence (AAAI-05), 2005, pp. 354–359.[3] A. Armando, C. Castellini, E. Giunchiglia, SAT-based procedures for temporal reasoning, in: Proceedings of the Fifth European Conference on Planning,2000, pp. 97–108.[4] A. Armando, C. Castellini, E. Giunchiglia, M. Idini, M. Maratea, TSAT++: An open platform for satisfiability modulo theories, in: Proceedings of theSecond Workshop on Pragmatics of Decision Procedures in Automated Reasoning (PDPAR-04), 2004.[5] A. Armando, C. Castellini, E. Giunchiglia, M. Maratea, A SAT-based decision procedure for the boolean combination of difference constraints, in: Pro-ceedings of the Seventh International Conference on Theory and Applications of Satisfiability Testing SAT 2004, Selected Revised Papers, Lecture Notesin Computer Science, vol. 3542, 2004, pp. 16–29.[6] R. Béjar, F. Manyà, Solving the round robin problem using propositional logic, in: Proceedings of the Seventeenth National Conference on ArtificialIntelligence (AAAI-00), 2000, pp. 262–266.[7] C. Bessière, E. Hebrard, T. Walsh, Local consistencies in SAT, in: Proceedings of the Sixth International Conference on Theory and Applications ofSatisfiability Testing SAT 2003, Selected Revised Papers, Lecture Notes in Computer Science, vol. 2919, 2003, pp. 299–314.[8] P. Cheeseman, B. Kanefsky, W.M. Taylor, Where the really hard problems are, in: Proceedings of the Twelfth International Joint Conference on ArtificialIntelligence (IJCAI-91), 1991, pp. 331–337.1782D.N. Pham et al. / Artificial Intelligence 172 (2008) 1752–1782[9] J.M. Crawford, L.D. Auton, Experimental results on the crossover point in random 3-SAT, Artificial Intelligence 81 (1–2) (1996) 31–57.[10] R. Dechter, Constraint Processing, Morgan Kaufmann, San Francisco, 2003.[11] R. Dechter, I. Meiri, J. Pearl, Temporal constraint networks, Artificial Intelligence 49 (1–3) (1991) 61–95.[12] H.E. Dixon, M.L. Ginsberg, A.J. Parkes, Generalizing Boolean satisfiability I: Background and survey of existing work, Journal of Artificial IntelligenceResearch 21 (2004) 193–243.[13] B. Dutertre, L. Mendonça de Moura, A fast linear-arithmetic solver for DPLL(T), in: Proceedings of the Eighteenth International Conference on ComputerAided Verification, 2006, pp. 81–94.[14] N. Eén, N. Sörensson, An extensible SAT solver, in: Proceedings of the Sixth International Conference on Theory and Applications of Satisfiability Testing(SAT-03), Selected Revised Papers, Lecture Notes in Computer Science, vol. 2919, 2003, pp. 502–518.[15] E.C. Freuder, Synthesizing constraint expressions, Communication of ACM 21 (11) (1978) 958–966.[16] E.C. Freuder, A sufficient condition for backtrack-free search, Journal of ACM 29 (1) (1982) 24–32.[17] A.M. Frisch, T.J. Peugniez, Solving non-Boolean satisfiability problems with stochastic local search, in: Proceedings of the Seventeenth InternationalJoint Conference on Artificial Intelligence (IJCAI-01), 2001, pp. 282–290.[18] I.P. Gent, Arc consistency in SAT, in: Proceedings of the Fifteenth European Conference on Artificial Intelligence (ECAI-02), 2002, pp. 121–125.[19] I.P. Gent, T. Walsh, The SAT phase transition, in: Proceedings of the Eleventh European Conference on Artificial Intelligence (ECAI-94), 1994, pp. 105–109.[20] K. Ghiathi, G. Ghassem-Sani, Using satisfiability in temporal planning, WSEAS Transactions on Computers 3 (4) (2004) 963–969.[21] M.C. Golumbic, R. Shamir, Complexity and algorithms for reasoning about time: A graph-theoretic approach, Journal of ACM (1993) 1108–1133.[22] R.M. Haralick, G.L. Elliott, Increasing tree search efficiency for constraint satisfaction problems, Artificial Intelligence 14 (3) (1980) 263–313.[23] J.N. Hooker, Needed: an empirical science of algorithms, Operations Research 42 (2) (1994) 201–212.[24] H.H. Hoos, SAT-encodings, search space structure, and local search performance, in: Proceedings of the Sixteenth International Joint Conference onArtificial Intelligence (IJCAI-99), 1999, pp. 296–302.[25] F. Hutter, D.A.D. Tompkins, H.H. Hoos, Scaling and probabilistic smoothing: Efficient dynamic local search for SAT, in: Proceedings of the EighthInternational Conference on Principles and Practice of Constraint Programming (CP-02), 2002, pp. 233–248.[26] H. Kautz, D. McAllester, B. Selman, Encoding plans in propositional logic, in: Proceedings of the Fifth International Conference on Principles of Knowl-edge Representation and Reasoning (KR-96), 1996, pp. 374–384.[27] H. Kautz, Y. Ruan, D. Achlioptas, C. Gomes, B. Selman, M. Stickel, Balance and filtering in structured satisfiable problems, in: Proceedings of theSeventeenth International Joint Conference on Artificial Intelligence (IJCAI-01), 2001, pp. 351–358.[28] H. Kautz, B. Selman, Pushing the envelope: Planning, propositional logic, and stochastic search, in: Proceedings of the Thirteenth National Conferenceon Artificial Intelligence (AAAI-96), 1996, pp. 1194–1201.[29] P. Ladkin, A. Reinefeld, Effective solution of qualitative interval constraint problems, Artificial Intelligence 57 (1) (1992) 105–124.[30] P. Ladkin, A. Reinefeld, A symbolic approach to interval constraint problems, in: Artificial Intelligence and Symbolic Mathematical Computation, 1993,pp. 65–84.[31] P. Ladkin, A. Reinefeld, Fast algebraic methods for interval constraint problems, Annals of Mathematics and Artificial Intelligence 19 (1997) 383–411.[32] C.M. Li, Anbulagan, Look-ahead versus look-back for satisfiability problems, in: Proceedings of the Third International Conference on Principles andPractice of Constraint Programming (CP-97), 1997, pp. 341–355.[33] A.K. Mackworth, Consistency in networks of relations, Artificial Intelligence 8 (1) (1977) 99–118.[34] D. Mitchell, B. Selman, H. Levesque, Hard and easy distributions of SAT problems, in: Proceedings of the Tenth National Conference on ArtificialIntelligence (AAAI-92), 1992, pp. 459–465.[35] M.W. Moskewicz, C.F. Madigan, Y. Zhao, L. Zhang, S. Malik, Chaff: Engineering an efficient SAT solver, in: Proceedings of the 38th Design AutomationConference (DAC-01), 2001, pp. 530–535.[36] B. Nebel, Solving hard qualitative temporal reasoning problems: Evaluating the efficiency of using the ORD-Horn class, Constraints 1 (3) (1997) 175–190.[37] B. Nebel, H.-J. Bürckert, Reasoning about temporal relations: A maximal tractable subclass of Allen’s Interval Algebra, Journal of ACM 42 (1) (1995)43–66.[38] D. Nghia Pham, J. Thornton, A. Sattar, Modelling and solving temporal reasoning as satisfiability, in: Proceedings of the 4th International Workshop onModelling and Reformulating Constraint Satisfaction Problems, 2005, pp. 117–131.[39] D. Nghia Pham, J. Thornton, A. Sattar, Towards an efficient SAT encoding for temporal reasoning, in: Proceedings of the Twelfth International Conferenceon the Principles and Practice of Constraint Programming (CP-06), 2006, pp. 421–436.[40] D. Nghia Pham, J. Thornton, A. Sattar, A. Ishtaiwi, SAT-based versus CSP-based constraint weighting for satisfiability, in: Proceedings of the TwentiethNational Conference on Artificial Intelligence (AAAI-05), 2005, pp. 455–460.[41] S. Prestwich, Local search on SAT-encoded colouring problems, in: Proceedings of the Sixth International Conference on Theory and Applications ofSatisfiability Testing (SAT-03), Selected Revised Papers, Lecture Notes in Computer Science, vol. 2919, 2003, pp. 105–119.[42] P. Prosser, An empirical study of phase transitions in binary constraint satisfaction problems, Artificial Intelligence 81 (1-2) (1996) 81–109.[43] A.K. Pujari, G. Vijaya Kumari, A. Sattar, INDU: An interval and duration network, in: Proceedings of the Twelfth Australian Joint Conference on ArtificialIntelligence, 1999, pp. 291–303.[44] S. Ranise, C. Tinelli, The Satisfiability Modulo Theories Library (SMT-LIB), www.SMT-LIB.org, 2006.[45] J. Renz, B. Nebel, Efficient methods for qualitative spatial reasoning, Journal of Artificial Intelligence Research 15 (2001) 289–318.[46] B. Selman, H. Kautz, D. McAllester, Ten challenges in propositional reasoning and search, in: Proceedings of the Fifteenth International Joint Conferenceon Artificial Intelligence (IJCAI-97), 1997, pp. 50–54.[47] B.M. Smith, M.E. Dyer, Locating the phase transition in binary constraint satisfaction problems, Artificial Intelligence 81 (1-2) (1996) 155–181.[48] J. Thornton, M. Beaumont, A. Sattar, M. Maher, A local search approach to modelling and solving Interval Algebra problems, Journal of Logic andComputation 14 (1) (2004) 93–112.[49] J. Thornton, D. Nghia Pham, S. Bain, V. Ferreira Jr., Additive versus multiplicative clause weighting for SAT, in: Proceedings of the Twentieth NationalConference on Artificial Intelligence (AAAI-04), 2004, pp. 191–196.[50] I. Tsamardinos, M. Pollack, Efficient solution techniques for disjunctive temporal reasoning problems, Artificial Intelligence 151 (1) (2003) 43–89.[51] P. van Beek, Reasoning about qualitative temporal information, Artificial Intelligence 58 (1992) 297–326.[52] P. van Beek, R. Cohen, Exact and approximate reasoning about temporal relations, Computational Intelligence 6 (1990) 132–144.[53] P. van Beek, D.W. Manchak, The design and experimental analysis of algorithms for temporal reasoning, Journal of Artificial Intelligence Research 4(1996) 1–18.[54] M. Vilain, H. Kautz, Constraint propagation algorithms for temporal reasoning, in: Proceedings of the Fifth National Conference on Artificial Intelligence(AAAI-86), 1986, pp. 377–382.[55] T. Walsh, SAT v CSP, in: Proceedings of the Sixth International Conference on Principles and Practice of Constraint Programming (CP-00), 2000, pp. 441–456.