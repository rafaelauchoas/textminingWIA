Artificial Intelligence 186 (2012) 1–37Contents lists available at SciVerse ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintTowards fixed-parameter tractable algorithms for abstractargumentation ✩Wolfgang Dvoˇrák∗, Reinhard Pichler, Stefan WoltranInstitute of Information Systems, Vienna University of Technology, A-1040 Vienna, Austriaa r t i c l ei n f oa b s t r a c tAbstract argumentation frameworks have received a lot of interest in recent years. Mostcomputational problems in this area are intractable but several tractable fragments havebeen identified. In particular, Dunne showed that many problems can be solved in lineartime for argumentation frameworks of bounded tree-width. However, these tractabilityresults, which were obtained via Courcelle’s Theorem, do not directly lead to efficientalgorithms. The goal of this paper is to turn the theoretical tractability results into efficientalgorithms and to explore the potential of directed notions of tree-width for defining largertractable fragments. As a by-product, we will sharpen some known complexity results.© 2012 Elsevier B.V. All rights reserved.Article history:Received 16 June 2011Received in revised form 1 February 2012Accepted 11 March 2012Available online 13 March 2012Keywords:Abstract argumentationFixed-parameter tractabilityTree-widthDynamic programmingComplexity1. IntroductionArgumentation has evolved as an important field in AI with abstract argumentation frameworks (AFs, for short) asintroduced by Dung [20] being its most popular formalization. Meanwhile, a wide range of semantics for AFs has beenproposed (for an overview see [4]) and their complexity has been analyzed in depth. Most computational problems in thisarea are intractable (see e.g. [17,24,26]), but the importance of efficient algorithms for tractable fragments has been clearlyrecognized (see e.g. [18]). Such tractable fragments are, for instance, symmetric argumentation frameworks [12] or bipartiteargumentation frameworks [22].An interesting approach to dealing with intractable problems comes from parameterized complexity theory and is basedon the following observation: Many hard problems become tractable if some problem parameter is bounded by a fixedconstant. This property is referred to as fixed-parameter tractability (FPT). One important parameter of graphs is the tree-width, which measures the “tree-likeness” of a graph. Indeed, Dunne [22] showed that many problems in the area ofargumentation can be solved in linear time for argumentation frameworks of bounded tree-width. This FPT result wasshown via a seminal result by Courcelle [13]. However, as stated in [22], “rather than synthesizing methods indirectly fromCourcelle’s Theorem, one could attempt to develop practical direct methods”. The primary goal of this paper is therefore topresent new, direct algorithms for certain reasoning tasks in abstract argumentation.Clearly, the quest for FPT results in argumentation should not stop at the tree-width, and further parameters have to beanalyzed. This may of course also lead to negative results. For instance, considering as parameter the degree of an argument(i.e., the number of incoming and outgoing attacks), Dunne [22] showed that reasoning remains intractable, even if decision✩This work has been funded by the Vienna Science and Technology Fund (WWTF) through project ICT08-028 and by the Austrian Science Fund (FWF)under grant P20704-N18. A short version of this article appeared in the Proceedings of the 12th International Conference on Knowledge Representationand Reasoning (KR 2010), AAAI Press, 2010.* Corresponding author.E-mail addresses: dvorak@dbai.tuwien.ac.at (W. Dvoˇrák), pichler@dbai.tuwien.ac.at (R. Pichler), woltran@dbai.tuwien.ac.at (S. Woltran).0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.http://dx.doi.org/10.1016/j.artint.2012.03.0052W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37problems are given over AFs with at most two incoming and two outgoing attacks. A number of further parameters ishowever, still unexplored. Hence, the second major goal of this paper is to explore the potential of further parametersfor identifying tractable fragments of argumentation. In particular, since AFs are directed graphs, it is natural to considerdirected notions of width to obtain larger classes of tractable AFs. To this end, we investigate the effect of bounded cycle-rank [28] on reasoning in AFs. We show that reasoning remains intractable even if we only consider AFs of cycle-rank 2.Actually, many further directed notions of width exist in the literature. However, it has been recently shown [6,33,31] thatproblems which are hard for bounded cycle-rank remain hard when several other directed variants of the tree-width arebounded. A notable exception is the related notion of clique-width [14] which (in contrast to tree-width) can be directlyextended to directed graphs. Moreover, meta-theorems for clique-width [15] show that Dunne’s result on tractability withrespect to bounded tree-width extend to AFs of bounded clique-width (for details, we refer to [27]).Still, the main focus of this paper is on novel algorithms for decision problems defined over the so-called preferredsemantics of AFs. Roughly speaking, the preferred extensions of an AF are maximal admissible sets of arguments, whereadmissible means that the selected arguments defend themselves against attacks. To be more precise, we present herealgorithms for the following three decision problems.• Credulous acceptance: deciding whether a given argument is contained in at least one preferred extension of a given AF.• Skeptical acceptance: deciding whether a given argument is contained in all preferred extensions of a given AF.• Ideal acceptance: deciding whether a given argument is contained in an admissible set which itself is a subset of eachpreferred extension of a given AF.The problem of ideal acceptance is better known as ideal semantics [21]. To the best of our knowledge, FPT results for idealsemantics have not been established yet, thus the algorithm that we present in the paper provides such a result as a by-product (one could alternatively use Courcelle’s meta-theorem to obtain that result). By its very nature, the running timesof our novel algorithms will heavily depend on the tree-width of the given AF, but are linear in the size of the AF. Thus forAFs of small tree-width, these algorithms are expected to be preferable over standard algorithms from the literature (seee.g. [19,38]).One reason why we have chosen the preferred semantics for our work here is that it is widely used. Moreover, admissi-bility and maximality are prototypical properties common in many other semantics, for instance complete and stable [20],stage [43], and semi-stable [10] semantics. Hence, we expect that the methods developed here can also be extended toother semantics.1.1. Summary of results• We first prove some negative results: we show that reasoning remains intractable in AFs of bounded cycle-rank [28].As has been mentioned above, this negative result carries over to many other directed notions of width. We also showthat the problem of skeptical acceptance is coNP-complete for AFs of cycle-rank 1.• We develop a dynamic programming approach to characterize admissible sets of AFs. The time complexity of our algo-rithm is linear in the size of the AFs (as expected by Courcelle’s Theorem) with a multiplicative constant that is singleexponential in the tree-width (which is in great contrast to algorithms derived via Courcelle’s Theorem). This algorithmcan be directly used to decide the problem of credulous acceptance.• This dynamic programming algorithm is then extended so as to cover also the preferred semantics, and thus to decideskeptical acceptance.• We finally show how to further adapt this algorithm to decide ideal acceptance.1.2. Structure of the paperIn Section 2, we recall some basic notions and results on AFs and discuss some width-measures for graphs. We thenshow in Section 3 some negative results for reasoning in AFs where some parameters of directed graphs are bounded. InSection 4.1, we first develop a dynamic programming approach for credulous acceptance in AFs of bounded tree-width. Thisalgorithm is then extended to cover also preferred semantics in Section 4.2 and adapted to ideal acceptance in Section 4.3.Section 5 provides some final conclusions as well as pointers to related and future work.2. BackgroundIn this section, we first introduce argumentation frameworks and then some graph measures we want to investigate forsuch frameworks.2.1. Argumentation frameworksWe start by introducing (abstract) argumentation frameworks [20], and then recall the preferred as well as the idealsemantics for such frameworks. Afterwards, we highlight some known complexity results for typical decision problemsassociated to such frameworks.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–373Definition 1. An argumentation framework (AF) is a pair F = ( A, R) where A is a set of arguments and R ⊆ A × A is theattack relation. We sometimes use the notation a (cid:2) b instead of (a, b) ∈ R, in case no ambiguity arises. Further, for S ⊆ Aand a ∈ A, we write S (cid:2) a (resp. a (cid:2) S) iff there exists b ∈ S, such that b (cid:2) a (resp. a (cid:2) b). An argument a ∈ A is defended⊕ = {b ∈ A | S (cid:2) b}.by a set S ⊆ A iff for each b ∈ A, such that b (cid:2) a, also S (cid:2) b holds. Finally, for a set S ⊆ A we define SAn AF can naturally be represented as a directed graph.Example 1. Let F = ( A, R) with A = {a, b, c, d, e, f , g} and R = {(a, b), (c, b), (c, d), (d, c), (d, e), (e, g), ( f , e), (g, f )}. Thegraph representation of F is given as follows.We continue with a few basic concepts and the definition of preferred extensions as introduced in Dung’s seminalpaper [20] as well as the concept of ideal sets as proposed by Dung, Mancarella and Toni [21].Definition 2. Let F = ( A, R) be an AF. A set S ⊆ A is conflict-free (in F ), iff there are no a, b ∈ S, such that (a, b) ∈ R. A setS ⊆ A is admissible for F , if S is conflict-free in F and each a ∈ S is defended by S in F . We denote the collection of alladmissible extensions of F by adm(F ).Definition 3. Let F = ( A, R) be an AF. A set S ⊆ A is a preferred extension of F , iff S is a maximal (w.r.t. subset inclusion)admissible set for F . We denote the collection of all preferred extensions of F by pref (F ).Definition 4. Let F = ( A, R) be an AF. A set S ⊆ A is called ideal for F , if S ∈ adm(F ) and S is a subset of all preferredextensions (i.e., S ⊆P ∈pref (F ) P ). We denote the collection of all ideal sets of F by ideal(F ).(cid:2)An admissible set S is called complete, if each argument defended by S is contained in S. It was shown in [21] that eachAF F possesses a unique maximal ideal set (called the ideal extension of F ) and that this set is also a complete extensionof F .Example 2. For the AF F in Example 1, we get as admissible sets {}, {a}, {c}, {d}, {d, g}, {a, c}, {a, d}, and {a, d, g}. Conse-quently, pref (F ) = {{a, c}, {a, d, g}}, and moreover, ideal(F ) = {{}, {a}}. Thus, {a} is the ideal extension of F .Next, we recall the complexity of reasoning over preferred and ideal extensions. To this end, we define the decisionproblems of credulous acceptance (CA), skeptical acceptance (SA) and ideal acceptance (ID) which have as input an AFF = ( A, R) and an argument a ∈ A:• CA: Is a contained in some S ∈ pref (F )?• SA: Is a contained in each S ∈ pref (F )?• ID: Is a contained in some S ∈ ideal(F )?Note that the problem ID is equivalent to deciding whether a is contained in the ideal extension of F .It is known that CA is NP-complete, while SA is Π P2 -complete (see [17,24]). The reason why CA is located on a lowerlevel of the polynomial hierarchy compared to SA, is the fact that it is sufficient to check whether a is contained in at leastone admissible set for the given AF F . Then a is also contained in a preferred extension of F . In other words, the maximalityrequirement of preferred extensions does not come into play for CA. For SA, the situation is different, and maximality hasto be taken into account, leading to an additional source of complexity. The exact complexity of ID is still an open problem1but for the lower bound it is known that ID is coNP-hard and as an upper bound membership in Θ P2 has been shown(see [23]). Hence, under usual complexity-theoretic assumptions SA is harder to decide than CA and ID. Moreover, theanalysis in [23] suggests that ID might be mildly harder than CA. As we will see later, these theoretical observations are tosome extent mirrored by the running times of our algorithms.2.2. Parameters for graphsWe review several notions of parameters for graphs (both directed and undirected). One of the most important conceptsfor fixed-parameter tractability on graphs is the tree-width, which was introduced by Robertson and Seymour [40].1 To be more precise, [23] gives an exact Θ P2 -hardness lower bound in terms of randomized reductions. The open aspect of the problem is thus whetherthe random element in this reduction can be eliminated in order to obtain Θ P2 -hardness under the standard polynomial-time many-one reductions.4W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Fig. 1. A tree decomposition of the graph in Example 1.To start with, we recall the concept of an induced subgraph: given a graph G = (V , E) and a set A, we write G| A =(V ∩ A, E ∩ ( A × A)) for the subgraph of G induced by A.Definition 5. Let G = (V , E) be an undirected graph. A tree decomposition of G is a pair (T , X ) where T = (V T , ET ) is atree and X = ( Xt)t∈V T is a set of so-called bags, which has to satisfy the following conditions:(cid:3)t∈V T Xt = V , i.e. X is a cover of V ,1.2. for each v ∈ V , T |{t|v∈ Xt } is connected,3. for each {v i, v j} ∈ E, {v i, v j} ⊆ Xt for some t ∈ V T .The width of such a tree decomposition is given by max{card( Xt) | t ∈ V T } − 1. The tree-width of a graph G is theminimum width over all tree decompositions of G.As already mentioned, the concept of tree-width is defined for undirected graphs but can also be applied to directedgraphs and thus to AFs.Definition 6. Let F = ( A, R) be an AF. A tree decomposition of the undirected graph ( A, Rcontains the edges ofR without orientation is called a tree decomposition of F . The tree-width of an AF F is given by the minimum width overall tree decompositions of F .(cid:7)) where R(cid:7)It was shown by Bodlaender [7] that, for fixed w (cid:3) 1, it can be decided in linear time whether a graph has tree-widthat most w. Moreover, in case of a positive answer, a tree decomposition of width w can be computed in linear time. Fig. 1shows a tree decomposition of width 2 for the AF from Example 1 (when considered as an undirected graph).Many NP-hard problems on graphs have been shown to be linear time computable on graphs of bounded tree-width. Inparticular, Courcelle’s Theorem [13] provides a powerful tool to obtain such results. It states that any property over graphswhich can be expressed in Monadic Second-Order Logic, can be decided in linear time (w.r.t. to the size of the graph) forgraphs which have bounded tree-width. Dunne [22] used this result to show fixed-parameter tractability of the problemsCA and SA for the parameter tree-width.However, there is a certain problem when using tree-width in the area of directed graphs. In fact, there are manydigraphs which we intuitively consider as simply structured but already have high tree-width. As an example consider theacyclic digraphs of the form (n (cid:3) 1)(cid:6)(cid:6) 1 (cid:4) i < j (cid:4) n(cid:4){a1, . . . , an},Gn =(ai, a j)(1)(cid:7)(cid:8)(cid:5).For n = 5, Gn looks as followsSeen as undirected graph, each Gn turns into a clique of size n. Thus, the tree-width of the graphs Gn (with increasing n)cannot be bounded by a constant.As AFs are directed graphs, it seems natural to consider parameters exclusively defined for digraphs. Indeed, manysuch measures exist like directed tree-width [35], DAG-width [6] or Kelly-width [33]. An old but particularly interestingparameter, which we shall focus on here, is cycle-rank [28]. One reason why there are many different such notions is due tothe fact that, so far, no analogue to Courcelle’s Theorem which is comparably general has been found for digraph problems.2Before giving the definition of cycle-rank, we recall some basic definitions: we call a graph acyclic, if it does not containa cycle going through distinct vertices. In other words, self-loops are not considered as cycles. A directed graph is stronglyconnected, if each vertex is reachable from any other vertex in this graph. Finally, a strongly connected component (SCC) of agraph G is an induced subgraph G|S of G such that S is maximal with the property that G|S is strongly connected.2 As mentioned in the introduction, (directed) clique-width is a notable exception; we again refer to [27] for a more detailed discussion.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–375Definition 7. Let G = (V , E) be a directed graph. The cycle-rank r(.) of G is defined as follows: an acyclic graph has r(G) = 0;if G is strongly connected then r(G) = 1 + minv∈V r(G|V \{v}). If G is not strongly connected, then r(G) is the maximumcycle-rank among all SCCs of G.Intuitively, the cycle-rank corresponds to the maximum recursion depth of a procedure which – in each call – eliminatesone node per SCC until we have an acyclic graph. Note that the graphs Gn of the form (1) are acyclic and, thus, havecycle-rank 0 for any n.The cycle-rank is of particular interest because recent results [6,31,33] showed that problems which are hard for boundedcycle-rank also remain hard when some of the other aforementioned parameters are bounded. Indeed, in Section 3 we shallprove several intractability results for AFs with bounded cycle-rank. These intractability results thus immediately carry overto the other parameters for directed graphs.For a similar intractability result, Dunne [22] has recently shown that CA and SA remain intractable for AFs withbounded in- and out-degree. The following example illustrates that the class of graphs with bounded cycle-rank is in-comparable with the class of graphs with bounded in- and out-degree.Example 3. Let (Hn = (V n, En))n(cid:2)1 be a family of directed graphs with V n = {x1, . . . , xn, y1, . . . , yn} and En = {(xi, yi),( yi, xi) | 1 (cid:4) i (cid:4) n} ∪ {(xi, xi+1), ( yi+1, yi) | 1 (cid:4) i (cid:4) n − 1}. As an example, the graph H 5 looks as followsIt is easy to see that the in- and out-degrees of these graphs are bounded by 2, but that these graphs are of arbitrarycycle-rank.As another example,let (In = (V n, En))n(cid:2)1 be the family of directed graphs with V n = {x1, . . . , xn, x} and En ={(x, xi), (xi, x) | 1 (cid:4) i (cid:4) n}. The graph I5 looks as followsEach graph In has cycle-rank 1, but the graphs of form In which have arbitrary in- and out-degree.3. Parameters for directed graphs – negative results3.1. Bounded cycle-rankWe continue to prove that NP-hardness for CA holds, even if we restrict ourselves to AFs with bounded cycle-rank.We employ the reduction from [17] which maps each instance (i.e. a CNF formula) of the NP-hard problem SAT to anargumentation framework.Definition 8. Given a CNF formula Φ =(cid:9)mj=1 C j with C j being clauses over variables Z , define F Φ = ( A, R) with(cid:5)A = {Φ, C1, . . . , Cm} ∪ Z ∪ ¯Z ,(cid:5)(z, ¯z), (¯z, z)∪(C j, Φ) | 1 (cid:4) j (cid:4) mR =(cid:6)(cid:5)(cid:6) z occurs in C j, 1 (cid:4) j (cid:4) m∪where ¯Z = {¯z | z ∈ Z } is a set of fresh arguments.(z, C j)(cid:7)(cid:7)(cid:6)(cid:6) z ∈ Z(cid:5)(cid:7)∪(¯z, C j)(cid:6)(cid:6) ¬z occurs in C j, 1 (cid:4) j (cid:4) m(cid:7)Example 4. Consider the CNF formulaΦ = (z1 ∨ z2 ∨ z3) ∧ (¬z2 ∨ ¬z3 ∨ ¬z4) ∧ (¬z1 ∨ z2 ∨ z4).Fig. 2 illustrates the corresponding AF F Φ .For any CNF formula Φ, F Φ can be constructed in polynomial time, and Φ is satisfiable iff argument Φ is credulouslyaccepted in F Φ . This gives the NP-hardness for CA, first shown by Dimopoulos and Torres [17] and later rephrased in termsof AFs by Dunne and Bench-Capon [24]. We strengthen this result as follows.6W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Fig. 2. AF F Φ for CNF formula Φ in Example 4.Theorem 1. CA is NP-hard, even if the problem is restricted to AFs of cycle-rank 1.Fig. 3. AF GΨ for QBF Ψ in Example 5.Proof. As discussed above, AFs F of the form given in Definition 8 provide us with a valid reduction from SAT to CA. Toprove the assertion it is thus sufficient to show that for each CNF formula Φ, the corresponding AF F has at most cycle-rank 1. Indeed, such an AF F has the following SCCs: F |{z,¯z} for each z ∈ Z and the singletons C1, . . . , Cm, and Φ. Obviously,components F |{z,¯z} have cycle-rank 1 and all other components have cycle-rank 0. Hence, each F constructed followingDefinition 8 has cycle-rank 1. (cid:2)We now turn our attention to the Π P2 -hard problem SA. The following reduction from QBFs to AFs is used in [24].Definition 9. Given a QBF Ψ = ∀Y ∃Zwith(cid:9)mj=1 C j with C j being clauses over variables X = Y ∪ Z . We define the AF GΨ = ( A, R)(cid:5)A = {Ψ, C1, . . . , Cm} ∪ X ∪ ¯X ∪ {b1, b2, b3},(cid:6)(cid:6)(cid:6) x ∈ X(cid:6) 1 (cid:4) j (cid:4) m(x, ¯x), (¯x, x)∪R =(cid:6)(cid:5)(cid:7)(cid:6) x occurs in C j, 1 (cid:4) j (cid:4) m∪(C j, Ψ )∪(x, C j)(cid:5)(cid:5)(cid:7)(cid:7)(cid:5)(cid:7)(Ψ, b1), (Ψ, b2), (Ψ, b3)∪∪(cid:5)(¯x, C j)(cid:7)(b1, b2), (b2, b3), (b3, b1)(cid:6)(cid:6) ¬x occurs in C j, 1 (cid:4) j (cid:4) m(cid:6)(cid:6) z ∈ Z(b1, z), (b1, ¯z)∪(cid:5)(cid:7)(cid:7)where ¯X = {¯x | x ∈ X} is a set of fresh arguments.Example 5. Consider the QBFΨ = ∀ y1 y2∃z3z4( y1 ∨ y2 ∨ z3) ∧ (¬ y2 ∨ ¬z3 ∨ ¬z4) ∧ (¬ y1 ∨ y2 ∨ z4).In Fig. 3, we depict the corresponding AF GΨ .As shown by Dunne and Bench-Capon [24], the following holds for each QBF Ψ of the above form: Ψ is valid iff argument2 -hardnessΨ is contained in each S ∈ pref (GΨ ). Since GΨ can be constructed from Ψ in polynomial time, this showed Π Pof the problem SA. We strengthen this result as follows.Theorem 2. SA is Π P2 -hard, even if the problem is restricted to AFs of cycle-rank 2.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–377Fig. 4. AF HΦ for CNF formula Φ in Example 6.(cid:9)Proof. We can proceed similarly as in the proof of Theorem 1. Moreover, we are allowed to restrict ourselves to QBFs Φ ofthe form ∀Y ∃Zmj=1 C j where each C j contains at least one occurrence of an atom from Z ; the validity problem for suchQBFs obviously remains Π P2 -hard. Each AF G according to Definition 9 has the following SCCs:• G|{ y, ¯y} for each y ∈ Y ;• G|S for S = {z, ¯z | z ∈ Z } ∪ {C1, . . . , Cm, Φ, b1, b2, b3}.Components G|{ y, ¯y} have cycle-rank 1, and H = G|S has cycle-rank 2. This can be seen as follows: Removing Φ leads toSCCs H|{z,¯z} (for each z ∈ Z ), H|{b1,b2,b3}, and singletons C1, . . . , Cm. All these have cycle-rank 1 or 0. (cid:2)We now turn our attention to the coNP-hard problem ID. The following reduction from CNF formulas to AFs is a slightlymodified version of that given by Dunne [23].Definition 10. Given a formula Φ =(cid:9)mj=1 C j in CNF over variables Z . We define the AF HΦ = ( A, R) with(cid:5)A = {Φ, C1, . . . , Cm} ∪ Z ∪ ¯Z ∪ {Ψ },(cid:6)(cid:6) 1 (cid:4) j (cid:4) m(z, ¯z), (¯z, z)∪R =(cid:6)(cid:6) z occurs in C j, 1 (cid:4) j (cid:4) m(C j, Φ)∪(z, C j)(cid:5)(cid:7)(cid:5)(cid:7)(cid:6)(cid:6) z ∈ Z(cid:5)(cid:7)∪(cid:5)(cid:7)(Ψ, Φ), (Φ, Ψ )∪(¯z, C j)(cid:6)(cid:6) ¬z occurs in C j, 1 (cid:4) j (cid:4) m(cid:7)where ¯Z = { ¯Z | z ∈ Z } is a set of fresh arguments.Example 6. Recall the CNF formula Φ from Example 4, i.e.Φ = (z1 ∨ z2 ∨ z3) ∧ (¬z2 ∨ ¬z3 ∨ ¬z4) ∧ (¬z1 ∨ z2 ∨ z4).Fig. 4 illustrates the corresponding AF HΦ .As shown by Dunne [23], the following holds for each formula Φ of the above form: Φ is unsatisfiable iff the argu-ment Ψ is contained in the ideal extension.3 Since HΦ can be constructed from Φ in polynomial time, coNP-hardness ofthe problem ID follows. We strengthen this result as follows.Theorem 3. ID is coNP-hard, even if the problem is restricted to AFs of cycle-rank 1.Proof. We can proceed similar as in the proofs of Theorems 1 and 2. Let H be an arbitrary AF which follows Definition 10.Then H has the following SCCs: H|{z,¯z} for each z ∈ Z , the singletons C1, . . . , Cm, and H|{Φ,Ψ }. Each of these componentseither has cycle-rank 1 or cycle-rank 0 and thus each H constructed following Definition 10 has cycle-rank 1. (cid:2)Theorems 1–3 show that the parameter cycle-rank is not applicable for fixed-parameter tractability of the consideredproblems. However, these theorems leave some room for potential tractable fragments. First, consider the class of AFsof cycle-rank 0. By definition this is the class of acyclic AFs and it is well known that the acceptance problems under3 We note that the proof given by Dunne also works for our slightly modified reduction.8W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37consideration are tractable for acyclic AFs (there is a single preferred extension which coincides with the so-called groundedextension – for details see [20]). It thus remains to classify the complexity of skeptical acceptance for AFs of cycle-rank 1.Using the reduction to the AF HΦ from Definition 10, we immediately get that this problem is still coNP-hard, i.e. it doesnot form a tractable fragment in the usual sense. Nevertheless, we next show that also coNP membership holds for skepticalacceptance when restricted to AFs of cycle-rank 1. Hence, this fragment turns out to be computationally easier, bearing inmind that SA is Π P2 -complete in general.Theorem 4. SA is in coNP for AFs of cycle-rank 1.Proof. To prove SA ∈ coNP we provide a polynomial-time algorithm for verifying that a given set is a preferred extension.Then one can build a coNP algorithm for SA by deciding its complement by a standard guess and check approach. Toverify whether a set E is a preferred extension of an AF F = ( A, R) we first compute the SCCs and build a linear orderS1, . . . , Sm of the SCCs which respects the partial order given by the attacks between different components, i.e. for i < j wehave that S j (cid:13)(cid:2) S i . Note that both the identification of SCCs and obtaining such a linear order can be done in polynomialtime by depth-first search. Now one can decide the verification problem by considering each SCC separately starting with{in,def ,undec} which maps verticesS1 and then following the linear ordering. Therefore, we use a multi-labeling M : V S → 2to sets of labels, as well as ordinary labelings L : V S → {in, def , undec} (see [11]). Intuitively such a labeling correspondsifto an extension in the following way: an argument is labeled in if it is in the extension. An argument is labeled defit is not in the extension and attacked by some argument in the extension. Intuitively, the label defindicates that theextension is “defended” against potential attacks from this argument. Finally, an argument is labeled undec if it is neitherin the extension nor attacked by an argument in the extension. Intuitively, the label undec indicates that the status of thisargument is in a sense “undecided” yet.The multi-labeling will be used as a certain form of initialization of the currently considered SCC S j (for j > 1 this mighttake results from SCCs S i with i < j into account); ordinary labelings are then obtained from M by taking a designatedargument as a starting point and are finally compared to the candidate E.The verification algorithm (see also Example 7 below for illustration) for a given AF F = ( A, R) with linearly orderedSCCs S1, . . . , Sm and a set of arguments E is as follows and loops over j with 1 (cid:4) j (cid:4) m.1. First, initialize a multi-labeling M j with M j(a) = {in, def , undec}, for all vertices a in S j . For each attack (a, b) in Fwith a ∈ S i , b ∈ S j and i < j, we setM j(b) := M j(b) \ {in, undec}M j(b) := M j(b) \ {in}if a ∈ E,if a /∈ E ∧ E (cid:13)(cid:2) a.2. Identify an argument x ∈ S j such that S j \ {x} is acyclic.3. Compute a labeling Llj for each label l ∈ M j(x) as follows: Llj(x) = l and for all vertices a (cid:13)= x in S j :⎧⎪⎨⎪⎩indefLlj(a) =if in ∈ M j(a) ∧ ∀b ∈ S j: b (cid:2) a ⇒ Llif M j(a) = {def } or ∃b ∈ S j: Llj(b) = def ,j(b) = in ∧ b (cid:2) a,undec otherwise.4. Verify the status of the selected argument x in labelings Llj :is valid iff ∀b ∈ S j: b (cid:2) x ⇒ Llj(b) = def ;is valid iff M j(x) = {def } or ∃b ∈ S j: Ldefj(b) = in ∧ b (cid:2) x;• Linj• Ldefj• Lundecjis valid anyway.Let L j be the set of valid labelings for S j .5. Define(cid:14)L∗j=L jL j \ {Lundec6. Verification: Reject, if there is no L ∈ Lj} otherwise.jif L j = {Lundec},∗j such that for all vertices a in S j it holds that L(a) = in iff a ∈ E; otherwisecontinue with the next SCC.If the above algorithm terminates without rejecting E, then E is a preferred extension.To show the correctness of the verification algorithm we exploit the following result form [5] (Proposition 41): For E ⊆ Ait holds that E ∈ pref (F ) iff for each SCC S of F it holds that E ∩ S is the ⊆-maximal admissible set of (S \ (E \ S)⊕, R ∩ S × S)satisfying that no argument is attacked by A \ (S ∪ E⊕).Our algorithm iterates over all SCCs S i testing the above conditions for E being preferred. In Step 1 for each argumentwe set M j(b) := {def } excluding argument b from having any effect in the subsequent computation, i.e.b ∈ S ∩ (E \ S)⊕W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–379restricting the set S to S \ (E \ S)⊕labels for b, implementing that b cannot be contained in the admissible sets.. Moreover, for each argument b attacked by A \ (S ∪ E⊕) we exclude in from the possibleThe Steps 2–5 are used to compute these ⊆-maximal admissible sets. In Step 2 we use the fact that, by definition,cr(F ) (cid:4) 1 iff for each SCC S = ( A S , R S ) of F , there is an argument x ∈ A S , such that S| A S \{x} is acyclic. We note that thiscan be easily done in polynomial time. In Steps 3–4 we compute all labelings that are (i) admissible and (ii) are candidatesfor being ⊆-maximal. By definition of a labeling we have that an argument is labeled def iff it is attacked by an argumentlabeled in (the condition M j(a) = {def } just ignores arguments in S ∩ (E \ S)⊕). By (i) we have that if an argument islabeled in it has to be defended, i.e. all of its attackers have to be labeled def [11]. Further by (ii) we have that each⊕), actually has to be in an extension. We obtain theargument defended by an extension and not attacked by A \ (S ∪ Econditions to compute Llj(a). Note that given the label of the selected argument x, we can compute the labels of all otherarguments in S j by a finite recursion (due to the fact that the SCC without x is acyclic).However, in Step 4 we have to check whether the computed labels are compatible with the label of x, i.e. we have toverify if the computed label is really an admissible labeling. For the case where we labeled x with in, we have to checkwhether x is defended with respect to labeling Linj . Similar, for l = def , we have to check whether x is attacked.In Step 5 we address the ⊆-maximality of the valid labelings. The extensions corresponding to Linare clearly notin ⊆-relation as one contains x and the other extension contains at least one attacker of x. On the other hand, we havethat in the recursion in Step 3, switching a def or in label to undec never gives rise to a new in or def label. Hence, theextension corresponding to Lundecis in ⊆-relation to the extensions corresponding to Lincontains the argument x nor an attacker of x they are also in ⊂-relation. Hence if Linthen Lundecj and resp. Ldefare admissible labelingsj and Ldefand as it neitheris not maximal.j , LdefjjjjjFinally in Step 6 we test whether E ∩ S corresponds to one of the maximal admissible sets. (cid:2)Example 7. For illustration of this algorithm consider the AF F = ({a, b, c, d, e}, {(a, b), (b, c), (c, d), (d, e), (e, b)}) and the setE = {a, c}.We have two SCCs S1 = F |{a} and S2 = F |{b,c,d,e}. First we apply our algorithm to S1. Since S1 is an initial SCC, its multi-labeling is given by M1(a) = {in, def , undec}. S1 has only one argument, we thus select x = a in Step 2 and get the followingthree labelings Lin1 (a) is not1 (a) = in, we now have that E isvalid (Step 4). In Step 5, we obtain Lvalid on S1 and we thus continue the algorithm with SCC S2.(a) = in in Step 3. As there is no argument attacking a, Ldef} \ {Lundec11 (a) = def and Lundec1 , Lundec= {Lin}. As a ∈ E and Lin1 (a) = in, LdefFor the multi-labeling M2 we have that M2(c) = M2(d) = M2(e) = {in, def , undec} and M2(b) = {def }. The latterequality holds because a ∈ E and a (cid:2) b. In the next step we have four options for argument x to make S 2 acyclic. Let usconsider x = d. We compute three labelings Lin. They are given as follows:} = {Lin1∗111and Lundec22 (b) = def ,LinLdef2 (b) = def ,Lundec2(b) = def ,2 (c) = in,LinLdef2 (c) = in,Lundec2(c) = in,22 , Ldef2 (d) = in,LinLdef2 (d) = def ,Lundec22 (e) = def ,LinLdef2 (e) = in,Lundec2(d) = undec,(e) = undec.2 is not valid, because of the fact that c (cid:2) d and LinThe labeling LinLdef2 (e) = in but e /∈ E, E is rejected by the algorithm.It is easy to see that {a, c, e} is the only set that would be accepted by the algorithm, which mirrors the fact that {a, c, e}2 (c) = in. Hence we have that L}. Now, since= {Ldef2∗2is the only preferred extension of F .Remark. The problem SA is closely related to the problem of deciding whether an AF is coherent [24], that is checkingwhether the stable and preferred extensions of the AF coincide. Stable extensions of an AF ( A, R) are defined as conflict-freesets S ⊆ A such that S attacks each argument from A \ S. In general, deciding whether an AF is coherent is Π P2 -complete,which can be shown using the reduction GΨ [24]. Hence the problem clearly remains Π P2 -hard for AFs of cycle-rank 2, butone might be interested whether this problem also becomes easier for cycle-rank 1.In the proof of Theorem 4 we have shown that for AFs of cycle-rank 1 one can decide in polynomial time whether agiven set is a preferred extension. This gives rise to a simple coNP algorithm for deciding coherence of an AF. First, non-deterministically guess a set E and then perform a polynomial-time test whether E is a preferred extension and whetherE is a stable extension. If E is preferred and not stable one has found a counter-example for coherence. Moreover, coNP-hardness can be shown by using the reduction HΦ ∪ ({b}, {(Ψ, b), (b, b)}).10W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–373.2. Further directed graph measuresFig. 5. An arboreal decomposition for the AF in Example 1.In this section we extend our hardness results to some popular parameters for directed graphs, namely for directed tree-width, DAG-width, Kelly-width, and directed path-width. We first review the definition of directed tree-width [35]. Hereby,the so-called arboreal decomposition is built similarly to a tree decomposition: an arboreal decomposition also consists of atree and “bags”, i.e., sets of vertices of the graph that we want to decompose. However, in contrast to tree decompositionsof undirected graphs, the bags in an arboreal decomposition can be used both as vertex labels and as edge labels in thetree. The bags used as vertex labels build a partition of the vertices of the original graph. The bags used as edge labelsare vertex sets that concern the subtree rooted at the target vertex of the associated edge; in particular they isolate thesubgraph induced by the union of the vertex bags in this subtree. This means that every path which starts and ends – butleaves the subgraph – comes across a vertex which is in the edge bag.The following definition makes these concepts formal. It is convenient to introduce the following notation first. Fort ∈ V T and e = (u, v) ∈ ET we write t > e iff v = t or there exists a path from v to t in T . Moreover, for e = (u, v) ∈ ET ,we use the term e ∼ t to denote that either u = t or v = t holds.Definition 11. Let G = (V , E) be a directed graph. An arboreal decomposition of G is a tuple (T , X , Y) where T = (V T , ET )is a directed tree with a unique root and X = ( Xt)t∈V T , Y = (Y e)e∈ET are families of subsets of V , such that1. X is a partition of V G into non-empty sets;2. for each e ∈ E T , there is no directed path in G|V \Y e with first and last vertex in X(cid:2)e :=vertex in V \ (Y e ∪ X(cid:2)e).(cid:3){ Xt | t > e} that contains aThe width of an arboreal decomposition is maxt∈V tis the smallest width of any arboreal decomposition.{card( Xt ∪(cid:3)e∼t Y e)} − 1. The directed tree-width of G (denoted as dtw(G))Example 8. Recall the AF F from Example 1. Below, we define an arboreal decomposition (T , X , W) of the correspondinggraph interpretation. For simplicity, we identify each node t ∈ T with the corresponding bag Xt . The arboreal decompositionis as follows:• V T = X = {{c, d}, {a}, {b}, {e}, { f }, {g}};• ET = {({c, d}, {a}), ({c, d}, {b}), ({c, d}, {e}), ({e}, { f }), ({e}, {g})};• Y = (Y y) y∈ET with Y ({e},{ f }) = {e}, Y ({e},{g}) = {e} and Y y = ∅ for the other edges in ET .For an illustration of the decomposition, see Fig. 5. We mention that this decomposition has width 1. For example, considerthe cycle e, g, f of the AF. In our decomposition the cycle is partitioned in three nodes such that the nodes { f }, {g} aresuccessors of {e}. Now given { f }, we have a path in F , namely f , e, g, f , which starts and ends in the bag { f } but leavesthe bag. Thus to fulfill condition 2 for being an arboreal decomposition, one has to add either e or g to the edge bag of({e}, { f }). For similar reasons we have to add either e or f to the edge bag of ({e}, {g}). In both cases we decided to add eas it is already contained in the predecessor’s vertex bag, i.e. in {e}, and thus does not increase the width generated by thepredecessor node, while in any case it increases the width generated by the node { f } resp. {g}.We do not require explicitly the definitions of the other three graph parameters mentioned in this paper. Instead, weonly provide a summary of results compiled together from [6,33,31]; the reader is referred to [2,6,33] for formal definitionsof the parameters of DAG-width, Kelly-width and directed path-width.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3711Fig. 6. Propagation of hardness results for directed graph measures (see Proposition 1).Proposition 1. For any directed graph G the following relations hold:(cid:4)(cid:4)dtw(G) − 1dtw(G) + 2(cid:8)/3 (cid:4) dagw(G) (cid:4) dpw(G) + 1 (cid:4) cr(G) + 1,(cid:8)/6 (cid:4) kellyw(G) (cid:4) dpw(G) + 1 (cid:4) cr(G) + 1where dagw(G), kellyw(G), and dpw(G) denote the DAG-width, Kelly-width, and directed path-width of G, respectively.Indeed, this proposition allows us to obtain hardness results for directed tree-width, DAG-width, Kelly-width and directedpath-width from the corresponding hardness result for cycle-rank, which we have obtained in the previous subsection.Fig. 6 illustrates how a hardness result for one of the above mentioned graph measures can be propagated to the othergraph measures. The following corollaries exploit this result, but use distinct proof-arguments for the parameter of directedtree-width.Corollary 1. CA is NP-hard even for• AFs of directed path-width 1;• AFs of DAG-width 2;• AFs of Kelly-width 2;• AFs of directed tree-width 1.Proof. While the results for directed path-width, DAG-width and Kelly-width follow directly from Proposition 1, we givean explicit proof for NP-hardness of CA over AFs with directed tree-width 1 (Proposition 1 only provides hardness for AFsof directed tree-width 7). To this end, we construct arboreal decompositions (T , X , W) for frameworks of the form FΦ asgiven in Definition 8.• V T = X = {{z1, ¬z1}, . . . , {zn, ¬zn}, {C1}, . . . , {Cm}, {Φ}};• ET = {({Φ}, {zi, ¬zi}) | 1 (cid:4) i (cid:4) n} ∪ {({Φ}, {Ci}) | 1 (cid:4) i (cid:4) m};• Y = (Y e)e∈ET with Y e = ∅ for all e ∈ ET .This arboreal decomposition has width 1 and by the fact that FΦ contains a clique of size 2, namely {z, ¯z}, we concludethat dtw(FΦ ) = 1. (cid:2)12W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Corollary 2. SA is Π P2 -hard even for• AFs of directed path-width 2;• AFs of DAG-width 3;• AFs of Kelly-width 3;• AFs of directed tree-width 2.Proof. As before the results for directed path-width, DAG-width and Kelly-width follow directly from Proposition 1 and wehave to construct appropriate arboreal decompositions for AFs of the form GΨ as given in Definition 9 to show the desiredhardness result for AFs of directed tree-width 2.• V T = X = {{ y1, ¬ y1}, {z1, ¬z1}, . . . , { yn, ¬ yn}, {zn, ¬zn}, {C1}, . . . , {Cm}, {Ψ }, {b1}, {b2}, {b3}};• ET = {({Ψ }, { yi, ¬ yi})} ∪ {({Ψ }, {zi, ¬zi})} ∪ {({Ψ }, {Ci})} ∪ {(Ψ, bi)};• Y = (Y e)e∈ET with{Ψ }{b1}{Ψ, b3}∅for e = ({Ψ }, {Ci}) or ({Ψ }, {zi, ¬zi}),for e = ({Ψ }, {b2}) or e = ({Ψ }, {b3}),for e = ({Ψ }, {b1}),otherwise.⎧⎪⎪⎨⎪⎪⎩Y e =One can see that this arboreal decomposition has width 2 and further one can show that dtw(GΨ ) = 2. (cid:2)Corollary 3. ID is coNP-hard even for• AFs of directed path-width 1;• AFs of DAG-width 2;• AFs of Kelly-width 2;• AFs of directed tree-width 1.Proof. Once more the results for directed path-width, DAG-width and Kelly-width follow directly from Proposition 1. Toshow hardness for AFs of directed tree-width 1, we give arboreal decompositions for AFs of the form HΦ (see Definition 10).• V T = X = {{z1, ¬z1}, . . . , {zn, ¬zn}, {C1}, . . . , {Cm}, {Φ, Ψ }};• ET = {({Φ}, {zi, ¬zi}): 1 (cid:4) i (cid:4) n} ∪ {({Φ}, {Ci}): 1 (cid:4) i (cid:4) m};• Y = (Y e)e∈ET with Y e = ∅ for all e ∈ ET .One can see that this arboreal decomposition has width 1 and by the presence of cliques of size 2, dtw(HΦ ) = 1 follows. (cid:2)To summarize, we have shown that none of the parameters cycle-rank, directed tree-width, DAG-width, Kelly-width, anddirected path-width is applicable for fixed-parameter tractability results. Hence, we observe that directed graph measuresgeneralizing tree-width are not well suited for the reasoning problems CA, SA, and ID on AFs.An explanation for this obstacle is that argumentation semantics are based on conflict-freeness of the extension whichis an undirected property, i.e. the orientation of the attacks does not play a role, and thus cannot be captured well by theW. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3713measures discussed in this subsection. As the standard reasoning tasks are computationally easy for (maximal) conflict-free sets one might expect that conflict-freeness does not harm when searching for tractable fragments. But there are alsoproblems which are hard for conflict-free sets. For instance, the problem of counting for maximal conflict-free sets is #P-hard, this was originally shown by Valiant [41] (in terms of counting maximal cliques) and was recently applied to abstractargumentation [3]. Thus the above #P-hardness result is an evidence against the existence of tractability results based ondirected graph measures.The above results leave some space for tractable fragments when bounding directed tree-width, DAG-width, Kelly-widthor directed path-width to 0, 1 or 2. Taking the minimal bounds into account (by definition, 0 for directed path-width anddirected tree-width and resp. 1 for DAG-width and Kelly-width) leads to acyclic AFs which are trivially tractable. Moreover,using Corollary 3, we can show that skeptical acceptance is still coNP-hard for AFs of directed path-width 1, DAG-width 2,Kelly-width 2 or directed tree-width 1. We leave the exact complexity classification for these particular fragments as openproblems.We now come back to the parameter of tree-width, which, in contrast to the parameters discussed in this section, allowsfor fixed-parameter tractability results. In fact, in the next section we present novel algorithms which exploit this feature.4. Dynamic programming for argumentationBefore we introduce our algorithms, we need some more notation for tree decompositions. In particular, it is useful toreduce the number of different node types and to identify a root node. The following concept serves this purpose.Definition 12. A tree decomposition (T , X ) of a graph G is called nice if T is a rooted tree and if each node4 t ∈ T is ofone of the following types:1. LEAF: t is a leaf of T ;and Xt = Xt(cid:7) \ {v} for some v ∈ Xt(cid:7) ;2. FORGET: t has only one child t(cid:7)and Xt = Xt(cid:7) ∪ {v} for some v /∈ Xt(cid:7) ;3. INSERT: t has only one child t(cid:7)(cid:7)and Xt = Xt(cid:7) = Xt(cid:7)(cid:7) .4. JOIN: t has two children t(cid:7), t(cid:7)Kloks [37] showed that a tree decomposition (T , X ) of a graph G where T has n nodes, can be transformed in timeO (n) into a nice tree decomposition (T (cid:7), X (cid:7)) of G which has the same width as (T , X ) and where T (cid:7)has O (n) nodes.Next, we have to introduce a few more technical notions which allow us direct access to some objects associated withcertain nodes in a tree decomposition.Definition 13. For a tree decomposition (T , X ) of an AF F and t ∈ T , let X(cid:2)t be the union of all bags Xs ∈ X such that soccurs in the subtree of T rooted at t. Moreover, X>t denotes X(cid:2)t \ Xt . We also use the following terminology:• Ft = F | Xt is the subframework in t;• F (cid:2)t = F | X(cid:2)t is the subframework induced by (the subtree rooted at) t.Note that the subframework induced by the root of such a decomposition of an AF F is F itself.Example 9. For the AF F from Example 1, we have already depicted a tree decomposition in Fig. 1. To obtain a nice treedecomposition, we have to introduce some further nodes. To make the node with bag {c, d} a join node we add two newnodes, one between the JOIN node and the node with bag {c, d} and one between JOIN node and the node with bag {d, e},both having bag {c, d}. Further we have to add some new nodes to make the remaining nodes of type insert or forget. Forinstance, between the nodes with bags {a, b} and {b, c}, we insert a further node with bag {b}, etc. We also have added twoforget nodes above the {c, d} node in order to have an empty root. The resulting nice tree decomposition of F is illustratedin Fig. 7, which has to be read as follows. In each node t, the bag Xt contains the arguments in (solid) cycles. In addition,we depict in each node t the AF Ft , i.e. the subframework in t; by adding the dotted parts of the graph, we obtain F (cid:2)t , thesubframework induced by t.In what follows we restrict ourselves to nice tree decompositions where the bag of the root is empty. Unless statedotherwise, we thus assume below that (T , X ) always denotes a nice tree decomposition (with empty root bag) for somegiven AF F .4.1. Characterizing admissible setsWe first introduce a relativization of admissible sets to a given set B of arguments.4 For T = (V T , ET ) we often write t ∈ T instead of t ∈ V T .14W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Fig. 7. Tree decomposition of F with subframeworks.Definition 14. Let F = ( A, R) be an AF and B a set of arguments. A set S ⊆ A is a B-restricted admissible set for F , if S isconflict-free in F and S defends itself in F against all a ∈ A ∩ B.Example 10. Let us consider the AF(cid:5)(e, g), (g, f ), ( f , e){e, f , g},(cid:4)(cid:7)(cid:8)which is a subframework of our running example. Indeed, in the tree decomposition in Fig. 7, it is the subframework in n13and also the subframework induced by n12. The {g}-restricted admissible sets of this AF are ∅, {e}, and {g}. In fact, { f } isnot {g}-restricted admissible here, since g (cid:2) f but f does not defend itself against g.Note that for A ⊆ B, B-restricted admissible sets of AFs ( A, R) are just the standard admissible sets; for A ∩ B = ∅,B-restricted admissible sets are just the conflict-free sets.We now introduce the underlying “data structure” of our dynamic programming algorithm for characterizing admissiblesets. The idea hereby is to store at each node t in the tree decomposition (T , X ) for a given AF F , a set of candidateswhich are represented solely via the elements in the bag Xt . More precisely, we assign to each node t ∈ T a certain set ofmappings C : Xt → {in, out, att, def }. We call such mappings also colorings for t. The rationale behind a coloring for t is asfollows: explicitly, a coloring characterizes the set(cid:5)a(cid:6)(cid:7)(cid:6) C(a) = in[C] =and the values out, att, def tell us about the relationship between [C] and the remaining arguments Xt \ [C]. In fact, att willdenote arguments which attack [C] but are not attacked by [C], def denotes arguments attacked by [C], and out are thosewhich are in no relation with arguments from [C]. However, we will define colorings in such a way that they characterizesets over X(cid:2)t , rather than over Xt as sketched above. Formally, this intuition is captured as follows:Definition 15. Let (T , X ) be a tree decomposition of an AF F and t ∈ T . Given a coloring C for a node t ∈ T , we defineet(C) as the collection of X>t -restricted admissible sets S for F (cid:2)t which satisfy the following conditions for each a ∈ Xt :W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3715(i) C(a) = in iff a ∈ S;(ii) C(a) = def iff S (cid:2) a;(iii) C(a) = att iff S (cid:13)(cid:2) a and a (cid:2) S;(iv) C(a) = out iff S (cid:13)(cid:2) a and a (cid:13)(cid:2) S.If et(C) (cid:13)= ∅, C is called a valid coloring for t. The set of valid colorings for t is denoted by Ct .Example 11. Consider the node t = n11 of our example tree decomposition with Xt = {d, e, f } (see the right-hand side ofthe tree in Fig. 7) and the coloring C with C(d) = in and C(e) = C( f ) = def . We have F (cid:2)t = ({d, e, f , g}, {(d, e), (e, g), (g, f ),( f , e)}) and X>t = {g}. The only set which is X>t -restricted admissible for F (cid:2)t and satisfies the conditions from Defini-tion 15 is {d, g}. S = {d} would also be X>t -restricted admissible but violates condition (ii), since C( f ) = def and S (cid:13)(cid:2) f . Insummary, this particular C is valid for t = n11 and we have et(C) = {{d, g}}.Our ultimate goal is to efficiently compute the set Cr of valid colorings for the root node r of a given tree decompositionfor an AF F = ( A, R). The reason for this is the fact thatet(C) gives exactly the set of X>t -restricted admissible setsC∈Ctfor F (cid:2)t (as we show next). Since the root r has an empty bag, and thus X>r = A, we obtain that Cr characterizes theadmissible sets of F .(cid:3)By definition, each element in et(C) is an X>t -restricted admissible set for F (cid:2)t . Next, we show that the opposite directionalso holds.Lemma 1. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and S an X>t -restricted admissible set for F (cid:2)t . Then, there is acoloring C ∈ Ct such that S ∈ et(C).Proof. Since S is an X>t -restricted admissible set for F (cid:2)t , each argument a ∈ Xt satisfies one of the following conditions:(i) a ∈ S, (ii) S (cid:2) a, (iii) S (cid:13)(cid:2) a and a (cid:2) S, or (iv) S (cid:13)(cid:2) a and a (cid:13)(cid:2) S. For these four cases, we define C as follows:in case (i): C(a) = in,in case (ii): C(a) = def ,in case (iii): C(a) = att, andin case (iv): C(a) = out.By the construction of C , the set S satisfies conditions (i)–(iv) in Definition 15 and, since S is X>t -restricted admissible forF (cid:2)t , it holds that S ∈ et(C). (cid:2)Moreover, different colorings for a node t characterize different X>t -restricted admissible sets for F (cid:2)t .Lemma 2. Let (T , X ) be a tree decomposition of an AF F and let C , C(cid:7)be different colorings for a node t ∈ T . Then, et(C) ∩ et(C(cid:7)) = ∅.Proof. Suppose to the contrary that there is a set S ∈ et(C) ∩ et(Cexists an argument a ∈ Xt such that C(a) (cid:13)= Cderive a contradiction in each case. First let us consider the case where C(a) = in and CC(a) = in implies a ∈ S and further CC(a) = def and CS (cid:13)(cid:2) a, a contradiction. Finally, in case C(a) = att and Ca (cid:2) S and Cthe above arguments. (cid:2)are different colorings for t. Then there(cid:7)(a) and to(cid:7)(a) ∈ {def , att, out}. By Definition 15,(cid:7)(a) ∈ {def , att, out} implies a /∈ S, a contradiction. We continue with the case where(cid:7)(a) ∈ {att, out} implies(cid:7)(a) = out, we get a contradiction by the fact that C(a) = att impliesin(cid:7)(a) = out implies a (cid:13)(cid:2) S. The remaining cases follow by symmetry, i.e. by interchanging the roles of C , C(cid:7)(a) ∈ {att, out}. By Definition 15, C(a) = def implies S (cid:2) a. On the other hand, C(cid:7)(a). It remains to inspect all possible pairs of values of C(a) and C(cid:7)), where C and C(cid:7)(cid:7)To guarantee fixed-parameter tractability with respect to tree-width, we want to compute the sets Ct in a bottom-upmanner along the tree decomposition without an explicit computation of et(·). Therefore, we recursively define the conceptof vcolorings which we afterwards show to be equivalent to valid colorings.Definition 16. Let t ∈ T be a node in a nice tree decomposition (T , X ) of an AF F and let tbe the possible childrenof t. The operations (C − a), (C + a), (C ˙+ a), and (C (cid:3) D) used below are defined in Fig. 8. Depending on the node typeof t, we define a vcoloring for t as follows:(cid:7)(cid:7)(cid:7), t• LEAF node: Each coloring Xt → {in, out, att, def } wherefor all y (cid:2) x,C(x) = in ⇒ C( y) ∈ {att, def }C(x) = att ⇒ ∃ y: C( y) = in and x (cid:2) y,C(x) = def ⇔ ∃ y: C( y) = in and y (cid:2) xholds for all x ∈ Xt , is a vcoloring for t.16W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37(C − a)(b) = C(b)for each b ∈ X \ {a},⎧⎪⎪⎨C(b)defattoutindefout(C + a)(b) =(C ˙+ a)(b) =⎪⎪⎩⎧⎪⎪⎨⎪⎪⎩(C (cid:2) D)(b) =inatt⎧⎪⎪⎨⎪⎪⎩outdefattif b ∈ X,if b = a and [C] (cid:3) a,if b = a, [C] (cid:13)(cid:3) a and a (cid:3) [C],otherwise,if b = a or C(b) = in,if a (cid:13)= b and ((a, b) ∈ F or C(b) = def ),if a (cid:13)= b, C(b) = out, (a, b) /∈ F , (b, a) /∈ F ,otherwise,if C(b) = D(b) = in,if C(b) = D(b) = out,if C(b) = def or D(b) = def ,otherwise.Fig. 8. Operations for colorings C, D : X → {in, out, att, def } and AF F .• FORGET node: If C is a vcoloring for t(cid:7)• INSERT node: If C is a vcoloring for thold, then C ˙+ a is also a vcoloring for t.(cid:7)• JOIN node: If C is a vcoloring for t(cid:7), Xt = Xt(cid:7) \ {a}, and C(a) (cid:13)= att, then C − a is a vcoloring for t.and Xt = Xt(cid:7) ∪ {a}, then C + a is a vcoloring for t; if a (cid:13)(cid:2) a, [C] (cid:13)(cid:2) a, and a (cid:13)(cid:2) [C], D is a vcoloring for t(cid:7)(cid:7), and [C] = [D], then C (cid:3) D is a vcoloring for t.In what follows, we show the adequacy of vcolorings (i.e., that they match the concept of valid colorings) and alsoillustrate their functioning on our running example. We will do this step-by-step distinguishing between the different nodetypes.Example 12. Recall the AF from Example 1 and its tree decomposition in Fig. 7. Fig. 9 illustrates the bottom-up computationof the vcolorings for all nodes in the tree decomposition. More precisely, for each node t we give a table representing allvcolorings of t, whereby each row gives one such vcoloring. Below we will discuss some of the transitions from children toparent nodes (as defined by vcolorings, cf. Definition 16) in detail.For the moment, let us just describe a few further aspects in Fig. 9. For a better understanding we also added the#-column in Fig. 9 to show the cardinalities of the sets et(C), i.e. the number of X>t -restricted admissible sets for F (cid:2)tcharacterized by vcoloring C in t. In particular, we see in the root that we end up with 8 such sets which refer to theadmissible sets from our example AF (see Example 1). An explanation for the (cid:5) symbol in the tables of Fig. 9 follows laterin Example 17, when we shall illustrate how to decide CA using the concept of vcolorings.Let us start with LEAF nodes. We first give the desired result and then provide for illustration the computation of thevcolorings for a leaf node in our running example.Lemma 3. For any LEAF node in a tree decomposition of an AF, valid colorings and vcolorings coincide.Proof. Let (T , X ) be a tree decomposition of F and t a leaf in T . We have X>t = ∅; therefore, the X>t -restricted admissiblesets for F (cid:2)t coincide with the conflict-free sets.First, let C be a vcoloring for t. We have to show that then C is a valid coloring for t. Suppose to the contrary that itis not, i.e., either [C] is not conflict-free in Ft = F (cid:2)t or C violates one of the conditions (ii)–(iv) in Definition 15. It is easyto check that, in both cases, one of the conditions for C being a vcoloring is violated. For instance, if there is a conflictin [C], then there exist arguments x, y ∈ Xt with x (cid:2) y and C(x) = C( y) = in. Hence, the first condition in Definition 16 forvcolorings at a LEAF node is violated, a contradiction.Now suppose that C is a valid coloring for t, i.e., C satisfies the conditions (i)–(iv) of a coloring (see Definition 15) and[C] is conflict-free in F (cid:2)t . Then C satisfies the condition of a vcoloring for a LEAF node according to Definition 16. Forinstance, let x, y ∈ Xt with C(x) = in and y (cid:2) x. Then, since C is a coloring, either case (ii) or case (iii) of Definition 15applies and, thus, C( y) ∈ {att, def } holds. (cid:2)Example 13. Consider, for instance, the LEAF node n13 in Fig. 9 with bag {e, f , g}. We have here four vcolorings for n13 whichcorrespond to the conflict-free (and thus to the ∅-restricted admissible) sets for F (cid:2)n13= ({e, f , g}, {(e, g), (g, f ), ( f , e)}),namely {e}, { f }, {g}, and ∅.We proceed with the FORGET nodes.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3717Fig. 9. Computation of vcolorings for the example AF.Lemma 4. For any FORGET node t in a tree decomposition of an AF with child node tfollowing relationships hold:(cid:7)such that Xt = Xt(cid:7) \ {a}, and every S ⊆ A, the(1) If S is an X>t -restricted admissible set for F (cid:2)t , then S is also an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) .(2) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and a ∈ S, then S is an X>t -restricted admissible set for F (cid:2)t .(3) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) , a /∈ S and S defends itself against a (including the case that a does not attack Sat all), then S is an X>t -restricted admissible set for F (cid:2)t .Proof. First, since Xt ⊆ Xt(cid:7) , we have F (cid:2)t = F (cid:2)t(cid:7) and X>t ⊇ X>t(cid:7) . Let S be an X>t -restricted admissible set for F (cid:2)t andhence for F (cid:2)t(cid:7) , i.e., S is conflict-free in F and S defends itself against all b ∈ X>t . By X>t ⊇ X>t(cid:7) , S thus also defends itselfagainst all b ∈ X>t(cid:7) . Hence S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and assertion (1) follows.18W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Now assume that S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and a ∈ S. Then S is conflict-free in F and S defendsitself against all b ∈ X>t(cid:7) . Strictly speaking, S defends itself against all b ∈ X>t(cid:7) \ S. By X>t(cid:7) \ S = X>t \ S (recall that we areassuming that a ∈ S), therefore S is an X>t -restricted admissible set for F (cid:2)t . This proves assertion (2).Finally assume that S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) , a /∈ S and S defends itself against a. Since S is X>t(cid:7) -restricted admissible it is conflict-free in F and it defends itself against all b ∈ X>t(cid:7) . Moreover, X>t = X>t(cid:7) ∪ {a} and, byassumption, S defends itself against a. Hence, S defends itself against all b ∈ X>t . Thus, S is X>t -restricted admissible andassertion (3) follows. (cid:2)Next we exploit this property to show that vcolorings and valid colorings coincide on forget nodes.Lemma 5. For any FORGET node t in a tree decomposition of an AF, valid colorings and vcolorings coincide, if they coincide in the childnode tof t.(cid:7)Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t a FORGET node in T , and tXt = Xt(cid:7) \ {a}, for some a ∈ A. Moreover, we get X(cid:2)t = X(cid:2)t(cid:7) and X>t = X>t(cid:7) ∪ {a}.(cid:7)Let C be a valid coloring for t. We show that there exists a valid coloring C(cid:7)(cid:7)define Cto Cas follows: For all b ∈ Xt = Xt(cid:7) \ {a}, we set C(cid:7)(a), we have C = C(cid:7) − a. In order to define C(cid:7) − a. Wewith C(cid:7)(b) = C(b). Hence, no matter which value of {in, def , out} we assign(cid:7)(a) (cid:13)= att and C = Cfor t(cid:7)(a), we consider an arbitrary set S ∈ et(C) and distinguish two cases:(cid:7)the child node of t. By definition,(1) If a ∈ S, then we set CF (cid:2)t(cid:7) = F (cid:2)t , by Lemma 4. Moreover, S ∈ et(cid:7) (Cchosen S in the conditions (i)–(iv) in Definition 15). Hence, by assumption, CC = C(cid:7) − a is a vcoloring for t, by definition.(cid:7)(a) = in. Since S is X>t -restricted admissible for F (cid:2)t , it is also X>t(cid:7) -restricted admissible for(this can be seen by just using theand, therefore, alsois a valid coloring for tis a vcoloring for t(2) Now let a /∈ S. If S (cid:2) a, we set C(cid:7)). Notethat the case S (cid:13)(cid:2) a and a (cid:2) S cannot occur since, by assumption, S is X>t -restricted admissible for F (cid:2)t . By the same(cid:7)reasoning as above, C(cid:7)(a) = def . If S (cid:13)(cid:2) a and a (cid:13)(cid:2) S, we set C(cid:7)(a) = out. In both cases, S ∈ et(cid:7) (C(and thus also C ) is a vcoloring for t(cid:7)), i.e., C(resp. for t).(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7) − a. By assumption, C(cid:7)Now let C be a vcoloring for t, i.e., there exists a vcoloring C(cid:7)(a) (cid:13)= att,is a valid coloring for tit cannot happen that both a (cid:2) S and S (cid:13)(cid:2) a hold. But then S is also X>t -restricted admissible for F (cid:2)t by Lemma 4 andS ∈ et(C). Thus, C ∈ Ct . (cid:2)(cid:7)), i.e., S is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t . Since C. Hence, there exists S ∈ et(cid:7) (C(cid:7)(a) (cid:13)= att and C = Csuch that Cfor t(cid:7)(cid:7)(cid:7)Example 14. Let us continue the running example which we started above by computing the vcolorings for node n13. The= {g}. The vcolorings for n12 are obtainednext node n12 above n13 is of type FORGET and removes argument g. Thus X>n12from the vcolorings for n13 with the exception of the coloring C with [C] = { f }. Here we have C(g) = att, which violates theconstruction for the FORGET node. Intuitively, [C] = { f } is not further propagated because { f } is attacked by the argumentg which is no longer present in Xn12 . Hence, by properties (2) and (3) of tree decompositions, g is not attacked by anyargument outside X(cid:2)n12 . Therefore, [C] = { f } cannot be extended to an admissible set along the bottom-up traversal, i.e.,any extension of [C] = { f } to arguments outside X(cid:2)n12 will not defend itself against this attack from g against f . The= F (cid:2)n13 (see also Example 10vcolorings for n12 are now in accordance with the X>n12 -restricted admissible sets for F (cid:2)n12where we already analyzed exactly this situation).The next nodes we want to consider are those of type INSERT.Lemma 6. For any INSERT node t in a tree decomposition of an AF with child node tfollowing relationships hold:(cid:7)such that Xt = Xt(cid:7) ∪ {a}, and every S ⊆ A, the(1) If S is an X>t -restricted admissible set for F (cid:2)t , then S \ {a} is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) .(2) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) , then S is also an X>t -restricted admissible set for F (cid:2)t .(3) If S is an X>t(cid:7) -restricted admissible set for F (cid:2)t(cid:7) and S ∪ {a} is conflict-free in F (cid:2)t then S ∪ {a} is an X>t -restricted admissible setfor F (cid:2)t .Proof. By assumption, we have Xt = Xt(cid:7) ∪ {a} and a /∈ Xt(cid:7) . Thus, also X(cid:2)t = X(cid:2)t(cid:7) ∪ {a} and X>t = X>t(cid:7) hold. By properties (2)and (3) of tree decompositions, we know that there are no attacks between the new argument a and arguments in X>t .First, let S be an X>t -restricted admissible set for F (cid:2)t . By X>t = X>t(cid:7) , the set S is also X>t(cid:7) -restricted admissible forF (cid:2)t . Moreover, since a cannot attack any argument in X>t(cid:7) , also S \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) (of course, ifa /∈ S, then S \ {a} = S and the latter admissibility property is trivial). This proves assertion (1).Now consider an X>t(cid:7) -restricted admissible set S for F (cid:2)t(cid:7) . Then S is conflict-free in F . Moreover, as explained above,there are no attacks between the new argument a and arguments in X>t . Hence, the argument a does not affect theW. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3719second condition for being an X>t -restricted admissible set. Thus S and S ∪ {a} (in case it is conflict-free) are X>t -restrictedadmissible sets of F (cid:2)t . This proves assertions (2) and (3). (cid:2)Lemma 7. For any INSERT node t in a tree decomposition of an AF, valid colorings and vcolorings coincide, if they coincide in the childnode tof t.(cid:7)Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t an INSERT node in T , and tXt = Xt(cid:7) ∪ {a} and a /∈ Xt(cid:7) .(cid:7)the child node of t. Moreover, letLet C be a valid coloring for t, i.e., there exists an X>t -restricted admissible set S ∈ et(C) for F (cid:2)t . Then, by Lemma 6,with S \ {a} ∈S \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . As in the proof of Lemma 1, we construct a coloring Cet(cid:7) (Cfor t(cid:7)(cid:7)(cid:7)) as follows. For arbitrary b ∈ Xt(cid:7) , we define:if b ∈ S \ {a},if b /∈ S and S \ {a} (cid:2) b,if b /∈ S, b (cid:2) S \ {a}, and S \ {a} (cid:13)(cid:2) b,if b /∈ S, b (cid:13)(cid:2) S \ {a}, and S \ {a} (cid:13)(cid:2) b.(cid:7)(b) = inC(cid:7)(b) = defC(cid:7)(b) = attC(cid:7)(b) = outC(cid:7) ∈ Ct(cid:7) , and by assumption, is a vcoloring for t(cid:7) ˙+ a holds (if a ∈ S). Hence, C is a vcoloring for t.(cid:7)Thus, CC = C. Moreover, it is easy to check that either C = C(cid:7) + a holds (if a /∈ S) orNow let C be a vcoloring for t, i.e., there exists a vcoloring Cis a valid coloring, i.e. there exists an X>t(cid:7) -restricted (and, hence, X>t -restricted) admissible set S ∈ et(cid:7) (C(cid:7) + a). Moreover if the set S ∪ {a} is conflict-free in F (cid:2)t , then S ∪ {a} ∈ et(Cfor t(cid:7)Ceasy to check that then S ∈ et(CThus, C (which is either C(cid:7) + a or C(cid:7) ˙+ a) is a valid coloring for t. (cid:2)(cid:7)with either C = C(cid:7) + a or C = C(cid:7) ˙+ a. By assumption,(cid:7)) of F (cid:2)t(cid:7) . It is(cid:7) ˙+ a) as well.(cid:7)(cid:7)(e) = att and C(cid:7)Example 15. We continue our running example: the next node n11 is of type INSERT and adds d. Consider the coloring C(cid:7)( f ) = def . We have two possibilities to add d. In case we want d to be in the set, we obtainfor n12 with Cthe coloring C with C(d) = in, C(e) = def , C( f ) = def (note that e changes its color since it is now a “defeated attacker”);we have seen this coloring already in Example 11. The other possibility is to have d not in the set, resulting in the coloringC(cid:7)(cid:7)(d) = out, C(cid:7)(cid:7)(e) = att, C(cid:7)(cid:7)( f ) = def .with C(cid:7)(cid:7)Lemma 8. For any JOIN node t in a tree decomposition of an AF, valid colorings and vcolorings coincide, if they coincide also for bothchild nodes of t.Proof. Let (T , X ) be a tree decomposition of F = ( A, R) and t a JOIN node in T with successors t=(cid:7)(cid:7)t and X(cid:2)t(cid:7) ∩ X(cid:2)t(cid:7)(cid:7) = Xt and X(cid:2)t = X(cid:2)t(cid:7) ∪ X(cid:2)t(cid:7)(cid:7) . So we can partition X(cid:2)t into three disjoint sets X>t(cid:7) , X>t(cid:7)(cid:7) and Xt . ThusXevery set S ⊆ X(cid:2)t can be seen as the union of two sets S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) with S1 ∩ Xt = S2 ∩ Xt . The followinglemmas identify important properties of these sets S1 and S2.. Then Xt = Xand t(cid:7)(cid:7)(cid:7)(cid:7)tLemma 9. Let S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) , such that1. S1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) ;2. S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) ;3. S1 ∩ Xt = S2 ∩ Xt .Then S = S1 ∪ S2 is an X>t -restricted admissible set for F (cid:2)t .Proof. By properties 2 and 3 of tree decompositions, there are no attacks between the argument sets X>t(cid:7) and X>t(cid:7)(cid:7) . Inorder to show that S = S1 ∪ S2 is X>t -restricted admissible, we have to prove that (a) S is conflict-free in the AF F (cid:2)t ; and(b) S defends itself against all attacks from arguments in X>t = X>t(cid:7) ∪ X>t(cid:7)(cid:7) in F (cid:2)t .(a) Suppose to the contrary that there is a conflict a (cid:2) b with a, b ∈ S. Then either a, b ∈ X(cid:2)t(cid:7) (resp. a, b ∈ X(cid:2)t(cid:7)(cid:7) ) ora ∈ X(cid:2)t(cid:7) while b ∈ X(cid:2)t(cid:7)(cid:7) (or vice versa). In the case a, b ∈ X(cid:2)t(cid:7) , we get a, b ∈ S1 and, therefore, S1 is not conflict-free in F (cid:2)t(cid:7) ,a contradiction to assumption 1 (the same argument applies to the case a, b ∈ X(cid:2)t(cid:7)(cid:7) ). Thus assume a ∈ X(cid:2)t(cid:7) while b ∈ X(cid:2)t(cid:7)(cid:7)(or vice versa). Since there are no attacks between an argument from X>t(cid:7) and an argument from X>t(cid:7)(cid:7) , it must hold thata ∈ Xt or b ∈ Xt . Hence, {a, b} ⊆ X(cid:2)t(cid:7) or {a, b} ⊆ X(cid:2)t(cid:7)(cid:7) holds. Assuming S1 ∩ Xt = S2 ∩ Xt , this means that there is a conflictin either S1 or S2, yielding a contradiction to assumption 1 or 2.(b) We show that all arguments in S1 are defended by S against arguments from X>t in F (cid:2)t . The analogous result forS2 then follows by symmetry. In total, every argument in S is then defended by S against arguments from X>t . Togetherwith the result from (a), we thus derive the desired result, i.e. that S is an X>t -restricted admissible set for F (cid:2)t .By assumption, S1 defends itself against X>t(cid:7) in F (cid:2)t(cid:7) and thus against X>t(cid:7) in F (cid:2)t . Moreover, there are no attacks fromX>t(cid:7)(cid:7) against X>t(cid:7) in F (cid:2)t by the properties of tree decompositions. So X>t(cid:7)(cid:7) can only attack arguments in S1 ∩ Xt . Thus, S220W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37defends S1 against X>t(cid:7)(cid:7) since, S1 ∩ Xt = S2 ∩ Xt and by assumption, S2 defends itself against all attacks from X>t(cid:7)(cid:7) in F (cid:2)t(cid:7)and thus also in F (cid:2)t . Putting this together, we have that S = S1 ∪ S2 defends S1 against X>t in F (cid:2)t . (cid:2)Lemma 10. Let S be an X>t -restricted admissible set for F (cid:2)t , S1 = S ∩ X(cid:2)t(cid:7) and S2 = S ∩ X(cid:2)t(cid:7)(cid:7) . Then,1. S1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) ;2. S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) ;3. S1 ∩ Xt = S2 ∩ Xt .Proof. Let S be an X>t -restricted admissible set for F (cid:2)t . Assumption 3 is immediate by the fact that X(cid:2)t(cid:7) ∩ X(cid:2)t(cid:7)(cid:7) = Xt .Moreover, since S is conflict-free in F (cid:2)t , each subset of S is conflict-free in any subframework of F (cid:2)t , in particular S1 =S ∩ X(cid:2)t(cid:7) is conflict-free in F (cid:2)t(cid:7) and S2 = S ∩ X(cid:2)t(cid:7)(cid:7) is conflict-free in F (cid:2)t(cid:7)(cid:7) . It remains to show that S1 (resp. S2) defends itselfagainst all attacks from X>t(cid:7) (resp. from X>t(cid:7)(cid:7) ) in F (cid:2)t(cid:7) (resp. in F (cid:2)t(cid:7)(cid:7) ). Suppose to the contrary that there exists a ∈ X>t(cid:7)such that a (cid:2) S1 and S1 (cid:13)(cid:2) a in F (cid:2)t(cid:7) . Since S is X>t -restricted admissible in F (cid:2)t , we know that S (cid:2) a in F (cid:2)t . Hence, therehas to exist an argument b ∈ S \ S1 = S ∩ X>t(cid:7)(cid:7) such that b (cid:2) a in F (cid:2)t . But, as already observed earlier, there are no attacksbetween X>t(cid:7) and X>t(cid:7)(cid:7) , a contradiction. By symmetry, also S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . (cid:2)Proof of Lemma 8 continued. We now show that valid colorings and vcolorings for a JOIN node t coincide. First, let C be(cid:7) (cid:3) C(cid:7)(cid:7)]. By assumption, C(cid:7)a vcoloring for t, i.e., C = C(cid:7)(cid:7)). Moreover, byare valid colorings for the respective nodes tand C(cid:7)(cid:7)], we have S1 ∩ Xt = S2 ∩ Xt . Thus, by Lemma 9, S = S1 ∪ S2 is X>t -restricted admissible. It remains to show that[CS ∈ et(C). To this end, we check that the conditions (i)–(iv) in Definition 15 are satisfied for every a ∈ Xt :(cid:7). Hence, there exist S1 ∈ et(cid:7) (C(cid:7)] = [C(cid:7)) and S2 ∈ et(cid:7)(cid:7) (C) is a vcoloring for t(cid:7)(cid:7)(cid:7)] = [C(resp. C(cid:7)) and [C, where C(resp. tand t(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(i) By the definition of the (cid:3)-operator in Fig. 8, we have C(a) = in iff C(cid:7)(a) = in and C(cid:7)(cid:7)(a) = in. This, in turn, is equivalentto a ∈ S1 and a ∈ S2. In total, we have C(a) = in iff a ∈ S.(ii) C(a) = def iff C(iii) By the “otherwise” branch in Fig. 8, we have C(a) = att iff (C(cid:7)(a) = def or C(cid:7)(cid:7)(a) = def (see Fig. 8) iff S1 (cid:2) a or S2 (cid:2) a iff S (cid:2) a.(cid:7)(cid:7)(a) (cid:13)= def ).This, in turn, is equivalent to (a (cid:2) S1 or a (cid:2) S2) and (S1 (cid:13)(cid:2) a and S2 (cid:13)(cid:2) a). In total, we have C(a) = att iff a (cid:2) S butS (cid:13)(cid:2) a.(cid:7)(cid:7)(a) = att) and (C(cid:7)(a) (cid:13)= def and C(cid:7)(a) = att or C(iv) C(a) = out iff C(cid:7)(a) = out and C(cid:7)(cid:7)(a) = out (see Fig. 8) iff a (cid:13)(cid:2) S1, a (cid:13)(cid:2) S2, S1 (cid:13)(cid:2) a and S2 (cid:13)(cid:2) a iff a (cid:13)(cid:2) S and S (cid:13)(cid:2) a.(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)and Care valid colorings for the respective nodes tNow assume that C is a valid coloring for t, i.e., there exists S ∈ et(C). We define S1 = S ∩ X(cid:2)t(cid:7) and S2 = S ∩ X(cid:2)t(cid:7)(cid:7) . Then,by Lemma 10, S1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) , S2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) , and S1 ∩ Xt = S2 ∩ Xt . As in(cid:7)(cid:7)). Thenthe proof of Lemma 1, we can define a coloring CC, and, therefore, by assumption they are also vcolorings for∗ = C holds. To prove this claim, we have totheir node. Now define the vcoloring C∗(a) = C(a) for every a ∈ Xt . This equality is shown by distinguishing the four possible values {in, def , att, out}show that Cand by exploiting the conditions (i)–(iv) in Definition 15 as well as the definition of the (cid:3) operator in Fig. 8. We onlywork out the case of “in” nodes here. The remaining cases are treated analogously. Inspecting the definition of (cid:3) in Fig. 8,(cid:7)(cid:7)(a) = in. This, in turn, is equivalent to a ∈ S1 and a ∈ S2. On the other hand, byshows that Ccondition (i) of Definition 15, we have C(a) = in iff a ∈ S. By the definition of S 1 and S2, this is equivalent to a ∈ S1 anda ∈ S2. In total, we thus have C∗(a) = in iff C(a) = in. (cid:2), such that S1 ∈ et(cid:7) (Cfor node t. We claim that Cand a coloring C(cid:7)(cid:7)(cid:7)(cid:7)) and S2 ∈ et(cid:7)(cid:7) (C(cid:7)(a) = in and C∗(a) = in iff C∗ = C(cid:7) (cid:3) Cand tat tat t(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)] = [C(cid:7)(cid:7)], i.e. the extensions coincide on the intersection X(cid:2)n3Example 16. The only node of type JOIN in our example is the node n2, which combines the subframeworks F (cid:2)n3 and F (cid:2)n8 .(cid:7)(cid:7)(d) = def . As(cid:7)(cid:7)(c) = in and CConsider the coloring C∩ X(cid:2)n8 , we can join these colorings without causing any[C(cid:7)(cid:7)conflict. Thus we obtain C with C(c) = in and C(d) = def for the node n12. Now let us consider the coloring Dfor node n8(cid:7)(cid:7)] = {c, d} has a conflict.(cid:7)] (cid:13)= [Dwith DHence the pair C(cid:7)(cid:7)] and one can see that the set [C(cid:7)(cid:7)(d) = in. We have that [Cdoes not lead to a vcoloring for the node n12.for node n3 and the coloring C(cid:7)(cid:7)(c) = def and Dfor node n8 with C(cid:7)(d) = C(cid:7)(c) = C(cid:7)] ∪ [D(cid:7), D(cid:7)(cid:7)(cid:7)(cid:7)Lemmas 3–8 show that vcolorings provide us with exactly the same information as valid colorings. The following resultthus immediately follows by structural induction over a given nice tree decomposition.Theorem 5. Let (T , X ) be a nice tree decomposition of an AF F = ( A, R). Then, for each coloring C for a node t ∈ T , it holds that C isa valid coloring for t iff C is a vcoloring for t.Let us now describe how credulous acceptance can be performed via vcolorings: We just have to mark each coloringwhich assigns the value in to the argument we are interested in and accordingly pass this mark up to the root. In otherwords, we mark a coloring if it is constructed by using at least one marked coloring. If the coloring of the root has themark, then we know that credulous acceptance for this argument holds.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3721Example 17. Recall the computation from Example 12 in Fig. 9. We now consider the problem of deciding if the argument dis credulously accepted. The argument d is introduced in the nodes n3 and n11 thus we mark all their vcolorings C satisfyingC(d) = in and illustrate this with a (cid:5) in the last column of the table. Consider, for instance, the node n8 with the colorings(cid:7)1(d) = in andC1(c) = in, C1(d) = def , C2(c) = def , C2(d) = in and C3(c) = out, C3(d) = out. The child node n9 has colorings C(cid:7)+ {c}) it is also2(d) = out, the first marked for credulous acceptance. As C2 is constructed via the marked CCmarked and as C1 and C3 are both constructed via C(cid:7)1 (C2 = C+ {c}) they are not marked.˙+ {c}, C3 = C(cid:7)1(cid:7)2 (C1 = C(cid:7)2(cid:7)2Since vcolorings can be computed efficiently (for bounded bag size) we obtain the following result for such an algorithm,assuming that AFs come together with a nice tree decomposition of suitable width. The upper bound on the time complexityis obtained by considering the maximum number of vcolorings per node and assuming a straightforward method (e.g.,nested loops) for computing a node’s vcolorings from the vcolorings at the child node(s).Theorem 6. Deciding CA for an AF F = ( A, R) of tree-width k − 1 can be done in time O (10k · k · | A|).Proof. Let (T , X ) be a tree decomposition of an AF F = ( A, R). First, we observe that the number of colorings for each nodet ∈ T is bounded by 4k, since there are at most k arguments in Xt ∈ X and there are only 4 colors {in, out, def , att} to assignto these arguments. We assume that the set of vcolorings for a node t is stored in a table with 4k rows. Each row containsa coloring plus an additional bit which indicates if this coloring is a vcoloring. We assume that, given a coloring C , we canfind the corresponding row in this table within time O (k). We have to show that computing the vcolorings at each nodet ∈ T is feasible in time O (10k · k) in a single bottom-up traversal of T . Since the number of nodes of T may be assumed tobe bounded by O (| A|), the desired upper bound of the theorem follows immediately. We prove the upper bound O (10k · k)for the time needed at each node t ∈ T by distinguishing the four types of nodes in a nice tree decomposition.At a LEAF node t, we inspect each coloring C in the table at t and check in time O (k2) if C is a vcoloring, i.e., conflict-free.To this end, we simply consider all pairs of arguments in the bag. This yields the bound O (4k · k2).For a FORGET node t, we iterate over all vcolorings C(cid:7)(a) (cid:13)= att.(cid:7) − a in time O (k). Then we access in time O (k) the coloring C in theIf this is the case, we compute the coloring C = Ctable at t and set the vcoloring-bit. In total, we can compute the vcoloring-table at t in time O (4k · k). An INSERT node t istreated similarly.and check for each such Cfor the successor node tif C(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)In a JOIN node t, the vcolorings are computed by combining two colorings of the successors t. In a naiveimplementation, up to 4k · 4k = 42k = 16k pairs exist. However, we show that only 10k pairs have to be considered. By(cid:7)(cid:7)]. Forusing appropriate data structures, we can implement the join such that we only consider pairs (Cinstance, we can sort the colorings in the tables at tin lexicographical order by treating in as 1 and the other values(cid:7)] are in contiguous rows. This sorting requires(i.e., def , att, out) as 0. In the sorted table, the colorings D, Dtime O (4k · k).with [D] = [D(cid:7)(cid:7)) with [C(cid:7)] = [Cand tand t(cid:7), C(cid:7)]. For every m, there areLet C be a coloring over k arguments with m (cid:4) k arguments mapped to in. Then, for each argument with C(a) (cid:13)= in, we(cid:7)can choose any color in {out, def , att} without effecting the set [C]. Thus there exist at most 3k−m different colorings C· 3k−m colorings Csuch that [C] = [Cin the first table mapping m arguments to in. Each of these colorings can be combined with 3k−m colorings from the second(cid:8)3k−m · 3k−m join pairs produced by colorings that map m arguments to in. The sum overtable. Hence we have at most· 9m = 10k.and the latter equality follows from the combinatorial identityall possible m yields the desired upper bound for the total number of join pairs:different choices of m arguments and thus there are(cid:15)km=0(cid:15)km=0· 3m · 3m =kmkmkmkmkm=(cid:8)(cid:8)(cid:4)(cid:4)(cid:4)(cid:8)(cid:4)(cid:4)(cid:8)(cid:8)(cid:8)(cid:4)(cid:7)(cid:4)kk−mkm(cid:7)(cid:7)) can be handled in time O (k) (for computing C = C(cid:7), CTo obtain the first sum we use the identity(cid:15)· (l)i = (l + 1)n. Each joinable pair (Cni=0(cid:4)ni(cid:8)(cid:7) (cid:3) C(cid:7)(cid:7)and setting thevcoloring-bit of C ). In total, the vcolorings for a JOIN node can thus be computed in time O (10k · k). (cid:2)(cid:7)(cid:7)(cid:7)As hinted at in Example 12, our dynamic programming approach can be easily extended so as to count the number ofadmissible sets. In fact, we just need to add the computation of the #-column to our algorithm (which is straightforward dueto Lemma 2). Finally, we also emphasize the possibility of enumerating (with linear delay) all admissible sets (using a secondtop-down pass of the tree similar as sketched in [34]).4.2. Characterizing preferred extensionsSo far, we have solved the credulous acceptance problem via a certain characterization for the admissible sets. Forskeptical reasoning, we have to characterize preferred extensions rather than the admissible sets. We thus need a morecomplicated data structure. Instead of colorings for nodes t we shall use pairs (C, Γ ) where C is a coloring for t and Γ isa set of colorings for t. The set Γ of “certificates” contains further colorings which characterize X>t -restricted admissiblesets strictly larger than the X>t -restricted admissible sets characterized by C . Intuitively, Γ represents those X>t -restrictedadmissible sets which may ultimately keep the elements in et(C) from being maximal.22W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Definition 17. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and (C, Γ ) a pair with C being a coloring for t and Γbeing a set of colorings for t. We call (C, Γ ) simply a pair for t and define et(C, Γ ) as the collection of sets S which satisfythe following conditions:(i) S ∈ et(C);(ii) For all C(iii) For all X>t -restricted admissible (for F (cid:2)t ) sets E with S ⊂ E, there exists some C(cid:7) ∈ Γ , there is an E ∈ et(C(cid:7)) such that S ⊂ E;(cid:7) ∈ Γ with E ∈ et(C(cid:7)).If et(C, Γ ) (cid:13)= ∅, (C, Γ ) is a valid pair for t.The following technical lemmas mirror Lemmas 1 and 2.Lemma 11. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and S an X>t -restricted admissible set for F (cid:2)t . Then, there is a pair(C, Γ ) for t such that S ∈ et(C, Γ ).Proof. Let S be an X>t -restricted admissible set for F (cid:2)t . By Lemma 1, there exists a coloring C with S ∈ et(C). Now let(cid:7))}. We claim thatE = {E | E is X>t -restricted admissible for F (cid:2)t and S ⊂ E}. Moreover, let Γ = {CS ∈ et(C, Γ ). To prove this, we check the conditions (i)–(iii) from Definition 17: (i) S ∈ et(C) by the selection of C . (ii) For(cid:7)) with S ⊂ E; this follows by the construction of Γ from E . (iii) For all X>t -restricted sets Eall C(cid:7)); again this follows by the construction of Γthat are admissible in F (cid:2)t with S ⊂ E, there exists Cfrom E . (cid:2)(cid:7) ∈ Γ , there exists E ∈ et(C(cid:7) | ∃E ∈ E, s.t. E ∈ et(C(cid:7) ∈ Γ with E ∈ et(CLemma 12. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and let (C, Γ ), (CC (cid:13)= C). Then, et(C, Γ ) ∩ et(C(cid:7), Γ (cid:7)) = ∅.(cid:7)(cid:7), Γ (cid:7)) be different pairs for t (but not necessarily(cid:7)Proof. If C (cid:13)= Cwith Γ (cid:13)= Γ (cid:7)et(C, Γ ) ∩ et(C, Γ (cid:7)) = ∅, we prove that none of the sets S ∈ et(C, Γ ) is contained in et(C, Γ (cid:7)).. W.l.o.g., we assume that there exists a coloring ¯C for t such that ¯C ∈ Γ but ¯C /∈ Γ (cid:7)(cid:7)) = ∅ and our claim follows. Thus, it remains to consider pairs (C, Γ ), (C, Γ (cid:7)). In order to show thatthen, by Lemma 2, et(C) ∩ et(CLet S be an arbitrary set in et(C, Γ ). Suppose to the contrary that S is also contained in et(C, Γ (cid:7)). By Definition 17(applied to et(C, Γ )), there exists an X>t -restricted admissible set E ∈ et( ¯C) for F (cid:2)t such that S ⊂ E. By Definition 17(applied to et(C, Γ (cid:7))), there exists a coloring Ccoincide.Thus, ¯C ∈ Γ (cid:7), a contradiction. (cid:2)∗). By Lemma 2, the colorings ¯C and Csuch that E ∈ et(C∗ ∈ Γ (cid:7)∗Hence, each element S ∈ et(C, Γ ) is an X>t -restricted admissible set for F (cid:2)t and each X>t -restricted admissible set forF (cid:2)t is characterized by some valid pair for t.Now that we have augmented valid colorings with sets of valid colorings, we can identify the preferred extensions of Fin the root node. Recall that the root node r of T has an empty bag, thus there are only two possible pairs for r, namely((cid:7), ∅) and ((cid:7), {(cid:7)}), where (cid:7) is the empty coloring. Only the first pair corresponds to preferred extensions (see Definition 17)and we have the following relationship.Proposition 2. Let r be the root of a nice tree decomposition (T , X ) of an AF F . Then, er((cid:7), ∅) = pref (F ).Proof. We recall that er((cid:7)) = adm(F ). To show the set inclusion er((cid:7), ∅) ⊆ pref (F ), let S be an arbitrary set such thatS ∈ er((cid:7), ∅). By Definition 17(i) we obtain that S is admissible for F (cid:2)r = F . Further by (iii) and the fact that Γ = ∅ weconclude that there is no proper superset of S being admissible for F , i.e. S is a preferred extension of F . It remains toshow that er((cid:7), ∅) ⊇ pref (F ). Thus let S ∈ pref (F ) be an arbitrary preferred extension of F . By Lemmas 11 and 12 we getthat there exists a unique pair (C, Γ ) such that S ∈ et(C, Γ ). Since the root node has an empty bag, C = (cid:7) and further, byDefinition 17(ii) and the fact that S is a ⊆-maximal admissible set for F , we conclude that Γ = ∅ has to hold as well. (cid:2)Thus, our pairs have the desired property to characterize preferred extensions. It remains to find an efficient way tocompute them. As we did for admissible sets, we shall employ vcolorings for this purpose. However, the bottom-up com-putation now has to be applied to certificates as well, which makes the definition more involved. To handle the certificates,we have to extend the definition of the operators for vcolorings (see Fig. 8) to sets of vcolorings. By slight abuse of notation,we overload the operators −, +, ˙+, and (cid:3) as follows:(cid:5)(cid:6)(cid:6) C ∈ Γ and C(a) (cid:13)= att(cid:7),C − aΓ − a =Γ + a = {C + a | C ∈ Γ },Γ ˙+ a =C ˙+ a(cid:5)Γ (cid:3) (cid:8) =C (cid:3) D(cid:5)(cid:6)(cid:7)(cid:6) C ∈ Γ, a (cid:13)(cid:2) a, [C] (cid:13)(cid:2) a and a (cid:13)(cid:2) [C](cid:6)(cid:7)(cid:6) C ∈ Γ, D ∈ (cid:8), and [C] = [D].,W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3723We observe that if Γ is a set of vcolorings for a node thaving t as its parent node, applying an operator corresponding tothe node type of t results in a set of vcolorings for t. For the join operator we additionally have to assume that (cid:8) is a setof vcolorings for a node t. As an analogue to vcolorings we formally define nowthe concept of vpairs as follows.which shares t as a parent node with t(cid:7)(cid:7)(cid:7)(cid:7)Definition 18. Let (T , X ) be a nice tree decomposition of an AF F and let t ∈ T be a node with tDepending on the node type of t we define a vpair for t as follows:(cid:7)(cid:7)(cid:7), tits possible children.• LEAF: Each (C, Γ ) where C ∈ Ct and Γ = {C• FORGET: If (C(cid:7)(cid:7) ∈ Ct | [C] ⊂ [C(cid:7)]} is a vpair for t., Xt = Xt(cid:7) \ {a}, and C(cid:7)(a) (cid:13)= att, then– (C• INSERT: If (C(cid:7), Γ (cid:7)) is a vpair for t(cid:7) − a, Γ (cid:7) − a) is a vpair for t.(cid:7), Γ (cid:7)) is a vpair for t(cid:7)(cid:7) + a, (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ ({C(cid:7) ˙+ a is a vcoloring then (C(cid:7)(cid:7), Γ (cid:7)) is a vpair for t(cid:7)(cid:7), (Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)) ∪ ({C– (C– if C• JOIN: If (C(cid:7) (cid:3) C– (Cand Xt = Xt(cid:7) ∪ {a}, then(cid:7)} ˙+ a)) is a vpair for t;(cid:7) ˙+ a, Γ (cid:7) ˙+ a) is a vpair for t as well., (C(cid:7)(cid:7), Γ (cid:7)(cid:7)) is a vpair for t(cid:7)(cid:7), and [C(cid:7)(cid:7)})) is a vpair for t.(cid:7)} (cid:3) Γ (cid:7)(cid:7)) ∪ (Γ (cid:7) (cid:3) {C(cid:7)] = [C(cid:7)(cid:7)], then(cid:7) ∈ Γ (cid:7)may give rise to two certificates of C(cid:7) + a. But we possibly also get a certificate for C(cid:7) ˙+ a – hence the union with (Γ (cid:7) ˙+ a). Finally, we may also get a new certificate of C(cid:7) + a in the above definition are in order. We consider here a new argument a(cid:7) + a. First, if we do not add a to(cid:7) + a if we do add a to [E],(cid:7) + a if we take Citself andA few words about the certificates of Cbut do not add it to [C]. Now each certificate E(cid:7) + a is still a certificate for C[Enamely Eadd a to it – hence the union with {C(cid:7)], we get that E(cid:7)} ˙+ a.(cid:7)Similar considerations underly the certificates of C, of different subframeworks(cid:7)F (cid:2)t(cid:7) , F (cid:2)t(cid:7)(cid:7) to a vcoloring for the union of these subframeworks. Now let D be a certificate of C and Da certificate of C(cid:7)then clearly D (cid:3) Dare also certificates for C (cid:3) C. But further we have that C (cid:3) D.This relies on the fact that for a ⊂-relationship in the combined AF, it suffices to have a ⊂-relationship in one of thesubframeworks and a ⊆-relationship in the other.. Here we combine vcolorings C , Cis a certificate for C (cid:3) Cand D (cid:3) C(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7) (cid:3) C(cid:7)(cid:7)(cid:7)Example 18. Recall the AF from Example 9. The computation of vpairs for nodes t is illustrated in Fig. 10. As before weuse the #-column to notate the cardinality of the sets et(C, Γ ) for better readability. Furthermore, we use the (cid:2) symbol toillustrate how to decide SA – a detailed explanation of this concept follows in Example 23. Also observe that we indeed havepairs (C, Γ ) and (C, Γ (cid:7)) with Γ (cid:13)= Γ (cid:7)for the same node. An example is node n5 with bag {b, c} on the left branch and thecoloring C1 with C1(b) = def and C1(c) = in, i.e. [C1] = {c}. We have that et(C1) = {{c}, {a, c}}. However, et(C1, {C1}) = {{c}}(since we have {a, c} as certificate), while et(C1, ∅) = {{a, c}}.In what follows, we show that vpairs match the concept of valid pairs and thus are appropriate for our purposes.Similarly as for vcolorings, we will do this step-by-step distinguishing between the different node types. We start with thenodes of type LEAF:Lemma 13. For any LEAF node in a tree decomposition of an AF, its vpairs coincide with its valid pairs.Proof. Let (T , X ) be a tree decomposition of F and t a leaf node in T . The X>t -restricted admissible sets for F (cid:2)t coincidewith the sets [C] for the valid colorings C ∈ Ct . Moreover, the valid colorings and vcolorings for t coincide by Lemma 3.Now let (C, Γ ) be a valid pair for t. Then, by Definition 17, [C] ∈ et(C, Γ ). Hence, by Definition 18, (C, Γ ) is a vpair for t.Conversely, let (C, Γ ) be a vpair for t and let S = [C]. By Definition 16, S is X>t -restricted admissible for F (cid:2)t . Hence, byDefinitions 17 and 18, S ∈ et(C, Γ ). (C, Γ ) is thus a valid pair for node t. (cid:2)Example 19. Consider, for instance, the LEAF node n13 in Fig. 10. As mentioned before we have four valid coloringsC1, C2, C3, C4 that correspond to the ∅-restricted admissible sets {e}, { f }, {g}, ∅ of F (cid:2)n13 . One can see that the first three setsare ⊆-maximal in being ∅-restricted admissible for F (cid:2)n13 and thus correspond to the vpairs (C1, ∅), (C2, ∅), (C3, ∅) of n13.On the other hand, ∅ has three such supersets, namely {e}, { f }, {g}, and thus the corresponding vpair is (C4, {C1, C2, C3}).Next we consider FORGET nodes:Lemma 14. For any FORGET node t in a tree decomposition of an AF, vpairs and valid pairs coincide, if they coincide in the child node tof t.(cid:7)Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t a FORGET node in T , and tXt = Xt(cid:7) \ {a}, for some argument a ∈ Xt(cid:7) .(cid:7)the child node of t. We have that24W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Fig. 10. Computation of vpairs for the example AF.First we show that every valid pair for t is also a vpair for t. Thus let (C, Γ ) be a valid pair for t. Then there exists a setS ∈ et(C, Γ ). In particular, S is X>t -restricted admissible for F (cid:2)t , and hence, also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t .(cid:7), Γ (cid:7)) is aThus, by Lemmas 11 and 12, there exists a unique valid pair (C(cid:7) − a, Γ (cid:7) − a) is a vpairvpair for tfor t. We claim that (C. Since S is X>t -restricted admissible for F (cid:2)t and S ∈ et(cid:7) (C(cid:7) − a, Γ (cid:7) − a) = (C, Γ ) holds.(cid:7), Γ (cid:7)). By assumption, (C(cid:7)(a) (cid:13)= att. Then (Cwith S ∈ et(cid:7) (C(cid:7)), we have C(cid:7), Γ (cid:7)) for t(cid:7)(cid:7)W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3725, such that C(cid:7) − a = C , recall the construction from the proof of Lemma 5, where we constructed a coloring, which we denoteFor C∗and thushere as C(cid:7) − a = C .C(cid:7)) holds, by Lemma 2 we have that C∗ − a = C and S ∈ et(cid:7) (C∗). As also S ∈ et(cid:7) (CTo show Γ (cid:7) − a = Γ , we first consider the inclusion Γ (cid:7) − a ⊆ Γ : Let D(cid:7)(a) (cid:13)= att. By condition (ii) of(cid:7)(a) (cid:13)= att, we knowDefinition 17, there exists an X>t(cid:7) -restricted admissible set E for F (cid:2)t(cid:7) with S ⊂ E and E ∈ et(cid:7) (Dthat E is also X>t -restricted admissible. Hence, by condition (iii) of Definition 17, there exists D ∈ Γ with E ∈ et(D). As(cid:7) − a. Hence,before one can use the construction from the proof of Lemma 5 together with Lemma 2, to obtain D = DΓ (cid:7) − a ⊆ Γ .(cid:7)). By D(cid:7) ∈ Γ (cid:7)with D(cid:7) = C∗Now consider an arbitrary coloring D in Γ . By condition (ii) of Definition 17, there exists an X>t -restricted admissibleset E for F (cid:2)t with S ⊂ E and E ∈ et(D). By condition (iii) of Definition 17 and since E is also X>t(cid:7) -restricted admissible for(cid:7)). Again by the construction from the proof of Lemma 5 and Lemma 2 we haveF (cid:2)t(cid:7) , there exists Dthat D = D(cid:7) ∈ Γ (cid:7)(cid:7) − a. Hence, Γ ⊆ Γ (cid:7) − a.with E ∈ et(cid:7) (D(cid:7), Γ (cid:7)) for node t(cid:7)a vpair (CHence, there exists S ∈ et(cid:7) (CC = CWe now show that every vpair for the FORGET node t is also valid pair for t. Let (C, Γ ) be a vpair for t, i.e., there exists(cid:7)(cid:7), Γ (cid:7)) is a valid pair for twith C.(cid:7), Γ (cid:7)). We claim that also S ∈ et(C, Γ ) holds. As in the proof of Lemma 5, S ∈ et(C) holds since(cid:7) − a, Γ (cid:7) − a). By assumption, (C(cid:7)(a) (cid:13)= att and (C, Γ ) = (C(cid:7) − a. It remains to show that also conditions (ii) and (iii) of Definition 17 are fulfilled.with DTo show condition (ii), let D ∈ Γ , i.e., D is of the form D = D(cid:7) ∈ Γ (cid:7)(cid:7)) with S ⊂ E. As in the proof of Lemma 5, then also E ∈ et(D(cid:7)(a) (cid:13)= att. Since S ∈ et(cid:7) (C(cid:7), Γ (cid:7)),(cid:7) − a). To show condition (iii), let E bethere exists E ∈ et(cid:7) (DX>t -restricted admissible for F (cid:2)t with S ⊂ E. Then E is also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) , and therefore, there exists(cid:7)(a) (cid:13)= att. But then, as in the proof of Lemma 5,(cid:7) ∈ Γ (cid:7)Dalso E ∈ et(D(cid:7)). Since E is X>t -restricted admissible, we have Dwith E ∈ et(cid:7) (D(cid:7) − a). (cid:2)(cid:7) − a for some DExample 20. As an example for a FORGET node, consider the node n12 in Fig. 10, which removes argument g from its child] = { f }. Thisnode n13. The vpairs of n12 are obtained from the vpairs of n13 with the exception of the vpair (C(cid:7)2, ∅) is not propagated by definitionis due to the fact that C})(since Cof n13 which leads to the vpair (C3, {C1, C2}) for n12.(cid:7)2 is not further propagated as a vcoloring; thus also the vpair (C(cid:7)2(g) = att). For the same reason, we also have to eliminate C(cid:7)2 from the certificates of the vpair (C(cid:7)2, ∅) with [C(cid:7)4, {C(cid:7)2, C(cid:7)1, C(cid:7)2(cid:7)3We continue with nodes of type INSERT.Lemma 15. For any INSERT node t in a tree decomposition of an AF, vpairs and valid pairs coincide, if they coincide in the child node tof t.(cid:7)Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t an INSERT node in T , and tthat Xt = Xt(cid:7) ∪ {a} for some argument a ∈ A.(cid:7)the child node of t. Hence we haveFirst we show that every valid pair for t is also a vpair for t. Thus let (C, Γ ) be a valid pair for t. Then there exists(cid:7) = S \ {a} is X>t(cid:7) -restricted admissible for(cid:7), Γ (cid:7)). By assumption,(cid:7)] ∪ a is(cid:7) ˙+ a, Γ (cid:7) ˙+ a) = (C, Γ )S ∈ et(C, Γ ), which is X>t -restricted admissible for F (cid:2)t and further the set SF (cid:2)t(cid:7) . Thus, by Lemmas 11 and 12, there exists a unique valid pair (C(Cconflict-free in Ft(cid:7) , then also (Cholds.(cid:7) ∈ et(cid:7) (C(cid:7)} ˙+ a) is a vpair for t and further if [C(cid:7) + a, Γ1) = (C, Γ ) or (C(cid:7) + a, Γ1) with Γ1 = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ ({C(cid:7) ˙+ a, Γ (cid:7) ˙+ a) is a vpair. We claim that either (C(cid:7), Γ (cid:7)) is a vpair for t(cid:7), Γ (cid:7)) for t. Then (Cwith S(cid:7)(cid:7)To show that either C = C(cid:7) + a (if a /∈ S) or C = C∗a coloring, which we denote here as C(cid:7) = Cholds, by Lemma 2 we have that C, such that C = C∗and the assertion follows.(cid:7) ˙+ a (if a ∈ S) holds, recall the proof of Lemma 7, where we constructed(cid:7))∗). As also S \ {a} ∈ et(cid:7) (C∗ ˙+ a and S \ {a} ∈ et(cid:7) (C∗ + a or C = CIn the following we show that also the respective sets of certificates coincide. To this end we distinguish the twomentioned cases a /∈ S and a ∈ S, respectively:(1) Assume a /∈ S: To derive Γ1 = Γ , we first show the relation Γ1 ⊆ Γ ; this can be split up into the following threestatements:(α) Γ(cid:7) + a ⊆ Γ,(β) Γand (γ )(cid:7)(cid:7)(cid:5)C˙+ a ⊆ Γ.(cid:7) ˙+ a ⊆ Γ,(cid:7) ∈ Γ (cid:7)(cid:7) ∈ et(cid:7) (D(cid:7)(cid:7)(cid:7) ⊂ Efor F (cid:2)t(cid:7) with STo show (α) and (β), consider D. By condition (ii) of Definition 17, there exists an X>t(cid:7) -restricted admissible(cid:7) ∪ {a}(cid:7)). As we have here S = S, we obtain S ⊂ E = Eand Eset Efor (β). In the first case we have that E is conflict-free in F (cid:2)t by definition, and further as X>t = X>t(cid:7) and a /∈ X>t(cid:7)] ∪ {a} isit is also an X>t -restricted admissible set for F (cid:2)t . In the latter case E is conflict-free in F (cid:2)t iff the set [Dconflict-free. This is due to the definition of tree decompositions which ensures that there are no attacks between theset X>t and the new argument a. Using that a is not attacked by X>t we get that if E is conflict-free in F (cid:2)t then E isalso an X>t -restricted admissible set for F (cid:2)t .Now by condition (iii) of Definition 17 there exists D ∈ Γ such that E ∈ et(D). As before, using the construction from the(cid:7) + a, and in the case (β)proof of Lemma 7 together with Lemma 2, we obtain that, in the case (α) it holds that D = Dfor (α), and S ⊂ E = E(cid:7)(cid:7)26W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37(cid:7)(cid:7)} ˙+ a). If ({C(cid:7)} ˙+ a ⊆ Γ and finally Γ1 ⊆ Γ .(cid:7) ˙+ a) and as S ⊂ S ∪ {a} that C(cid:7)} ˙+ a) = ∅(cid:7) ˙+ a ∈ Γ . Hence,(cid:7) ˙+ a. Next we prove statement (γ ). To do this let us consider the set ({Cit holds that D = Dstatement (γ ) is trivially true. Otherwise we have that S ∪ {a} ∈ et(C{CTo prove Γ ⊆ Γ1, consider an arbitrary D ∈ Γ . By condition (ii) of Definition 17, there exists an X>t -restricted admis-(cid:7) = E \ {a} eithersible set E for F (cid:2)t with S ⊂ E and E ∈ et(D). By the assumption a /∈ S, i.e. S = S(cid:7) ⊂ Eis X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and thusS(cid:7)). Now we can use the proof of Lemma 7 together with Lemma 2 to show that inthere exists D(cid:7) ⊂ Ethe case S(cid:7) = S) holds. In both cases we have that E(cid:7) ∈ et(cid:7) (D(cid:7) + a or D = Dor E = S ∪ {a} (i.e. E(cid:7) ∈ Γ (cid:7)with E(cid:7)(cid:7) ˙+ a and D = C(2) Assume a ∈ S: To show Γ (cid:7) ˙+ a = Γ , we first consider the inclusion Γ (cid:7) ˙+ a ⊆ Γ : Consider D(cid:7) ∈ Γ (cid:7). By condition (ii) of(cid:7)). As by assumption(cid:7) ∈ et(cid:7) (DDefinition 17, there exists an X>t(cid:7) -restricted admissible set E(cid:7)] ∪ {a} is conflict-free then E is X>t -restrictedS = Sadmissible for F (cid:2)t . In this case we get by Definition 17 that there exists D ∈ Γ such that E ∈ et(D). By the constructionfrom the proof of Lemma 7 and Lemma 2, it holds that D = DTo prove Γ ⊆ Γ1, consider an arbitrary D in Γ . By condition (ii) of Definition 17, there exists an X>t -restricted admis-(cid:7) ⊂ Esible set E for F (cid:2)t with S ⊂ E and E ∈ et(D). We have that Sis X>t(cid:7) -restricted(cid:7)). By the construction from the proof of Lemma 7(cid:7) ∈ et(cid:7) (Dadmissible for F (cid:2)t(cid:7) . Thus there exists D(cid:7) ˙+ a. Hence, Γ ⊆ Γ (cid:7) ˙+ a holds.and Lemma 2, we get that D = D(cid:7) ∪ {a}. Further as in case (1) if [D(cid:7) ˙+ a otherwise. Hence, Γ ⊆ Γ1.(cid:7) ∪ {a} we have that S ⊂ E = E(cid:7) = E \ {a} and further that E(cid:7) ˙+ a. Hence, Γ (cid:7) ˙+ a ⊆ Γ ., we have that for Efor F (cid:2)t(cid:7) with S, D = D(cid:7) ∈ Γ (cid:7)with E(cid:7) ⊂ Eand E(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7), Γ (cid:7)) for node tIt remains to show that every vpair for an INSERT node is also a valid pair. Thus let (C, Γ ) be a vpair for t, i.e., there exists(cid:7) ˙+ a, Γ (cid:7) ˙+ a)a vpair (C(cid:7), Γ (cid:7)). Towith [C] ∪ {a} being conflict-free in Ft . By assumption, (Cshow that (C, Γ ) is a valid pair for t we distinguish the cases (1) and (2) as follows:(cid:7) + a, Γ1) (Γ1 defined as above) or (2) (C, Γ ) = (Csuch that either (1) (C, Γ ) = (C(cid:7), Γ (cid:7)) is a valid pair for tand thus there exists S(cid:7) ∈ et(cid:7) (C(cid:7)(cid:7)(1) As in the proof of Lemma 7, S = S(cid:7) ∈ et(C) holds since C = C(cid:7) + a. It remains to show that also conditions (ii) and (iii)(cid:7)(cid:7)) with S ⊂ E(cid:7), Γ (cid:7)), there exists E(cid:7)] ∪ {a} conflict-free in Ft .(cid:7) + a,(cid:7) ˙+ a with [D] ∪ {a} conflict-free in Ft , or(cid:7) ˙+ a with [C(cid:7) ∈ et(cid:7) (D(cid:7) + a). For case (b), we get by the construction of D that E = Eof Definition 17 are fulfilled. To show condition (ii), consider an arbitrary D ∈ Γ , i.e., D is either of the form(a) D = D(b) D = D(c) D = CSince S ∈ et(cid:7) (C. In case (a), we follow the proof of Lemma 7, and obtain(cid:7) ∪ {a} is conflict-free in F (cid:2)t . Once more we(cid:7) ∈ et(DEcan use the fact Xt (cid:13)(cid:2) a to obtain that E is an X>t -restricted admissible set for F (cid:2)t . Further S ⊂ E and as in the proof(cid:7) ˙+ a yields that E = S ∪ {a} is conflict-of Lemma 7, then also E ∈ et(Dfree in F (cid:2)t and thus as before E is an X>t -restricted admissible set for F (cid:2)t . Hence, as in the proof of Lemma 7, alsoE ∈ et(CTo show condition (iii), consider an arbitrary X>t -restricted admissible set E for F (cid:2)t such that S ⊂ E. Then E(cid:7)is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . If E(cid:7)with E ∈ et(cid:7) (Dit holds that S ⊂ Ehave that there is a unique vcoloring D such that E ∈ et(D). But then, as in the proof of Lemma 7, either D = CD = D(cid:7) = E \ {a}(cid:7) (cid:13)= S(cid:7)). Since E is X>t -restricted admissible for F (cid:2)t , we(cid:7) ˙+ a,(cid:7) ˙+ a) holds. Further, as a /∈ S, we have that S ⊂ E.(cid:7) ˙+ a). Finally, for (c) the construction of D = Cis the unique vcoloring such that E ∈ et(cid:7) (C(cid:7) = S then C(cid:7) ∈ Γ (cid:7)(cid:7)). Otherwise if Eand thus, there exists D(cid:7) + a or D = D(cid:7) ˙+ a we have that S = S(cid:7)]∪{a} conflict-free in Ft . Since S(cid:7) ∪ {a} ∈ et(C). It remains to show that the vpair (C, Γ ) also satisfies(cid:7) ˙+ a with. By the construction of D we have(cid:7) ∪ {a} is conflict-free and thus that E is an X>t -restricted admissible set for F (cid:2)t . By definition of E it holds(cid:7) ˙+ a). To show condition (iii) of Definition 17,(cid:7) = E \ {a} is X>t(cid:7) -restricted admissible for(cid:7)). Since E is X>t -restricted admissible, we haveconditions (ii) and (iii) of Definition 17. To show condition (ii), consider D ∈ Γ , i.e., D is of the form D = D[Dthat E = Ethat S ⊂ E and further, as in the proof of Lemma 7, we get that E ∈ et(Dlet E be an X>t -restricted admissible set for F (cid:2)t such that S ⊂ E. Then E(cid:7) ∈ Γ (cid:7)F (cid:2)t(cid:7) and S \ {a} = S. Thus, there exists Dthat there is a unique vcoloring D such that E ∈ et(D). But then, as in the proof of Lemma 7, D = D(cid:7), Γ (cid:7)), there exists E(cid:7) ˙+ a holds. (cid:2)(cid:7) ˙+ a holds.(cid:7) ∈ et(cid:7) (D(cid:7)) with S(cid:7) ∈ et(cid:7) (D(cid:7) ∈ et(cid:7) (C(cid:7) ⊂ E(cid:7) ⊂ Ewith E(cid:7)(cid:7)(2) By the assumption C = C(cid:7)2(cid:7)1(cid:7)1, C(cid:7)3, {CExample 21. Consider the INSERT node n11 in Fig. 10, which adds the argument d. Let us illustrate how vpairs of n11 are] = ∅. There are two ways toobtained from the vpairs of n12. For instance, consider the vpair (Cincorporate the argument d for the resulting vpairs of n11. We first consider adding the argument d to the extensions, i.e.we set C(d) = in. As the certificates represent supersets we have to extend them in the same way, otherwise the ⊂-relation˙+ d = C2. In the first case we have that the setwould be violated. In our example we have to consider C[C] ∪ d is conflict-free and thuswe obtain C2 as certificate and we end up with the vpair (C4, {C2}).] ∪ d contains a conflict and thus it is neither a vcoloring nor a certificate. But the set [C}) of n12, with [C˙+ d and CNow let us consider not adding d to the vpair (Cout, C5(e) = out, C5( f ) = out. Now both adding d or not adding d to the certificates {C(cid:7)(cid:7)we have both {C1, C2seen to {C2} ⊆ Γ . Further, as C4 = C(C5, {C1, C2, C3, C4}).+ d, with C5(d) =} preserve the ⊂-relation. Thus} ˙+ d ⊆ Γ . The first leads to {C1, C3} ⊆ Γ and the latter as we already have(cid:7) + d, we also get C4 ∈ Γ . In total, we obtain the vpair}). This results in the vcoloring C5 = C(cid:7) ˙+ d represents supersets of C} + d ⊆ Γ and {C(cid:7)3, {C(cid:7)1, C(cid:7)1, C(cid:7)1, C(cid:7)2(cid:7)3(cid:7)3(cid:7)2(cid:7)2(cid:7)1(cid:7)2(cid:7)2W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3727Lemma 16. For any JOIN node t in a tree decomposition of an AF, the vpairs coincide with the valid pairs if they coincide on thesuccessors tand tof t.(cid:7)(cid:7)(cid:7)Proof. Let (T , X ) be a tree decomposition of F = ( A, R) and t a JOIN node in T with successors t(cid:7)and t(cid:7)(cid:7).First consider an arbitrary valid pair (C, Γ ) for t. We show that (C, Γ ) is also a vpair. As (C, Γ ) is valid there existsan X>t -restricted admissible set S for F (cid:2)t such that S ∈ et(C, Γ ). As in the proof of Lemma 8 we have that there exist(cid:7), C(cid:7)(cid:7)unique sets S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) , such that S1 ∩ Xt = S2 ∩ Xt and S = S1 ∪ S2. Further, there exist valid colorings C(cid:7)(cid:7), Γ (cid:7)(cid:7)), suchsuch that S1 ∈ et(cid:7) (C∗, Γ ∗) andthat S1 ∈ et(cid:7) (C∗(cid:7) (cid:13)= CCwith the above properties is unique.) By assumption these valid pairs are also vpairs.(cid:7)(cid:7), Γ (cid:7)(cid:7)). (Note that by Lemma 2 there cannot be a pair (C(cid:7), Γ (cid:7)) and (C∗, Γ ∗) with S1 ∈ et(C. Thus, by Lemma 11 there are valid pairs (C(cid:7), Γ (cid:7)) and S2 ∈ et(cid:7)(cid:7) (C(cid:7)(cid:7)(cid:7)), S2 ∈ et(cid:7)(cid:7) (C(cid:7)(cid:7)) and C = C. Analogously, CNow we turn our attention to the set Γ . We first have to show that Γ ⊆ Γ ∗(cid:7)} (cid:3) Γ (cid:7)(cid:7)) ∪ (Γ (cid:7) (cid:3)(cid:7)(cid:7)}). For every D ∈ Γ there exists an X>t -restricted admissible set E ∈ et(D) such that S ⊂ E. We define E = E1 ∪ E2with Γ ∗ = (Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)) ∪ ({C{Canalogously to S1, S2. Now we have that S ⊂ E holds iff either(cid:7) (cid:3) C(cid:7)(cid:7)(i) S1 ⊂ E1 ∧ S2 ⊂ E2,(ii) S1 = E1 ∧ S2 ⊂ E2or(iii) S1 ⊂ E1 = S2 ⊂ E2holds. We discuss these three cases separately:(i) As E1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) , there exist sets D(cid:7)) and E2 ∈ et(cid:7)(cid:7) (D(cid:7)(cid:7)). By the proof of Lemma 8 and Lemma 2 we have that D = D(cid:7) ∈ Γ (cid:7)and(cid:7)(cid:7)(cid:7) (cid:3) D(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7), such that E1 ∈ et(cid:7) (DDand thus D ∈ Γ (cid:7) (cid:3) Γ (cid:7)(cid:7).(ii) As E2 is X>t(cid:7)(cid:7) -restricted admissible there exists D(cid:7) (cid:3) D(cid:7)(cid:7)(iii) By the symmetry to case (ii) we get that D ∈ (Γ (cid:7) (cid:3) {Cwe have that D = Cand thus D ∈ ({C(cid:7)} (cid:3) Γ (cid:7)(cid:7)).(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)(cid:7)(cid:7)}).such that E2 ∈ et(cid:7)(cid:7) (D(cid:7)(cid:7)). By the proof of Lemma 8 and Lemma 2Thus we have that Γ ⊆ Γ ∗(cid:7) (cid:3) Γ(cid:7)(cid:7) ⊆ Γ,(i) Γ. It remains to show that Γ ∗ ⊆ Γ which is equivalent to showing each of the following inclusions:(cid:5)(ii)C(cid:7)(cid:7)(cid:3) Γ(cid:7)(cid:7) ⊆ Γ and (iii) Γ(cid:7) (cid:3)(cid:7)(cid:7)(cid:7)(cid:5)C⊆ Γ.This can be done as follows:(i) Consider arbitrary D(cid:7)] = [DS1 ⊂ E1 and S2 ⊂ E2. We conclude that S ⊂ E and by the proof of Lemma 8 and Lemma 2 that D = Dunique coloring such that E ∈ et(D). Therefore D(cid:7)(cid:7) ∈ Γ and thus Γ (cid:7) (cid:3) Γ (cid:7)(cid:7) ⊆ Γ .(cid:7)(cid:7)). By Definition 17 we have thatis the(cid:7)) and E2 ∈ et(cid:7)(cid:7) (D(cid:7)(cid:7)], E1 ∈ et(cid:7) (Dwith [D(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7) (cid:3) D(cid:7) (cid:3) Dand D(cid:7)(cid:7)(ii) Consider an arbitrary D(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)with [C(cid:7)] = [Dis the unique coloring such that E ∈ et(D). Thus {C(cid:7)(cid:7)] and E2 ∈ et(cid:7)(cid:7) (D(cid:7)} (cid:3) Γ (cid:7)(cid:7) ⊆ Γ .(cid:7)(cid:7)). We have that S ⊂ E = S1 ∪ E2 and that D = C(cid:7) (cid:3) D(cid:7)(cid:7)(iii) By symmetry to (ii).This shows Γ = Γ ∗and thus every valid pair (C, Γ ) is also a vpair.(cid:7)Now we show that every vpair for t is also a valid pair for t. Thus let (C, Γ ) be a vpair for t, i.e., there exists a vpair(cid:7), Γ (cid:7)) for node tdefined as(cid:7)(cid:7), Γ (cid:7)). As(cid:7)] = [C(cid:7)(cid:7), Γ (cid:7)(cid:7)) are valid pairs. Hence, there exist sets S1 ∈ et(cid:7) (C(Cabove). By assumption (Cin the proof of Lemma 8, S = S1 ∪ S2 ∈ et(C) holds since [C(cid:7)(cid:7)] = [CIt remains to show that (C, Γ ) also fulfills conditions (ii) and (iii) of Definition 17. To show condition (ii), consider D ∈ Γ ,(cid:7)(cid:7)] such that (C, Γ ) = (C(cid:7), Γ (cid:7)) and S2 ∈ et(cid:7)(cid:7) (C(cid:7)(cid:7), Γ (cid:7)(cid:7)) for node t(cid:7), Γ (cid:7)) and (Cand a vpair (C(cid:7)(cid:7), Γ ∗) (Γ ∗with [C(cid:7) (cid:3) C(cid:7)].(cid:7)(cid:7)i.e., D is of one of the following forms:(a) D = D(b) D = C(c) D = D(cid:7)(cid:7)(cid:7) (cid:3) D(cid:7)(cid:7)(cid:7) (cid:3) D(cid:7) (cid:3) C(cid:7)(cid:7)for some Dfor some Dfor some D(cid:7) ∈ Γ (cid:7)(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)(cid:7) ∈ Γ (cid:7), D(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)with [Cwith [Cwith [D(cid:7)(cid:7)];(cid:7)] = [D(cid:7)].(cid:7)(cid:7)] = [D(cid:7)] = [D(cid:7)(cid:7)];We only discuss case (a) here as the cases (b) and (c) are similar: Since S 1 ∈ et(cid:7) (CE1 ∈ et(cid:7) (DE1 ∪ E2 ∈ et(D(cid:7)(cid:7), Γ (cid:7)(cid:7)), there exist(cid:7)(cid:7)) with S ⊂ E1, S ⊂ E2 and E1 ∩ Xt = E2 ∩ Xt . As in the proof of Lemma 8, then also E =(cid:7), Γ (cid:7)) and S2 ∈ et(cid:7)(cid:7) (C(cid:7)) and E2 ∈ et(cid:7)(cid:7) (D(cid:7)(cid:7)) and S ⊂ E.To show condition (iii), let E be X>t -restricted admissible for F (cid:2)t with S ⊂ E. Then E1 is X>t(cid:7) -restricted admissible(cid:7)(cid:7)),with E1 ∈ et(cid:7) (D(cid:7)), E2 ∈ et(cid:7)(cid:7) (D(cid:7) (cid:3) Dand D(cid:7)(cid:7)(cid:7)for F (cid:2)t(cid:7) and E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . Hence there exist sets DE1 ∩ Xt = E2 ∩ Xt , and either(cid:7)(cid:7)(cid:7) ∈ Γ(c) Dholds. But then, as in the proof of Lemma 8, also E = E 1 ∪ E2 ∈ et(D(cid:7) ∈ Γ(cid:7) (cid:3) D, D(cid:7)(cid:7)). (cid:2)(cid:7)(cid:7) ∈ Γ(cid:7)(cid:7) ∈ Γ(cid:7) = C(b) D(a) D(cid:7)(cid:7) = C, D, Dor,(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)Example 22. To give an example consider the JOIN node n2 in Fig. 10. Let us have a look at the pair (C(cid:7)1(c) = in, CC(cid:7)1(d) = def , and pair (C(cid:7)(cid:7)1 , ∅) of n8 with C(cid:7)(cid:7)1 (d) = def . As [C(cid:7)(cid:7)1 (c) = in, C] = [C(cid:7)(cid:7)1(cid:7)1(cid:7)}) of n3 with1, {C] we combine these vpairs using(cid:7)128W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37the (cid:3) operations. The join C(cid:3) Chave to consider the sets Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)to the certificate C1. In this way, we have obtained the vpair (C1, {C1}) for n2.(cid:7)(cid:7)1 leads to the vcoloring C1 with C1(c) = in and C1(d) = def . To update the certificates we(cid:7)(cid:7)}. The first two sets are empty as Γ (cid:7)(cid:7) = ∅ and the third one leads, {C, and Γ (cid:7) (cid:3) {C(cid:7)} (cid:3) Γ (cid:7)(cid:7)(cid:7)1Theorem 7. Let (T , X ) be a nice tree decomposition of an AF F = ( A, R). Then, for each pair (C, Γ ) for a node t, it holds that (C, Γ )is a valid pair for t iff (C, Γ ) is a vpair for t.Proof. As in Theorem 5, the proof proceeds by structural induction. For the induction base, we have to show that vpairsand valid pairs coincide on LEAF nodes, which is the case due to Lemma 13. For the induction step, we have to show thisproperty for the remaining nodes. Indeed, this is captured by Lemmas 14, 15 and 16. (cid:2)Thus, we now have a handle to efficiently decide skeptical acceptance for bounded tree-width. We just have to mark allpairs (C, Γ ) where the considered argument a satisfies C(a) (cid:13)= in and pass this mark accordingly towards the root node. If((cid:7), ∅) carries this mark, then we know that skeptical acceptance does not hold.Example 23. Let us now consider the problem of deciding if the argument a is skeptically accepted in our example AF. InFig. 10 we illustrate the vpairs which are marked as contradictory for skeptical acceptance with a (cid:2) in the last column ofthe table. Note that for a vpair (C, Γ ) to be marked it is sufficient that for one set S ∈ et(C, Γ ) it holds that a /∈ S. Thecounter # in Fig. 10 still refers to all X>t -admissible sets (for F (cid:2)t ) in et(·,·). Thus, the number of such sets S ∈ et(·,·) witha /∈ S is, in general, smaller.Theorem 8. Deciding SA for an AF F = ( A, R) of tree-width k − 1 can be done in time O (222k+1+8k · | A|).Proof. Recall that the number of colorings for each node is bounded by 4k. In order to maintain the vpairs for each node,we consider all possible pairs (C, Γ ), where C is a coloring and Γ is a set of colorings. Hence, we have to consider at most4k · 24k = 2n pairs at each node, where n = 22k + 2k (we use abbreviation n throughout the proof). Analogously to the proofof Theorem 6, we can store the vpairs for a node t in a table with one row per possible pair (C, Γ ). In an additional bit weindicate if this row represents a vpair. Given a pair (C, Γ ), we can find the corresponding row in time O (n).We have to show that computing the vpairs at each node t ∈ T is feasible in time O (222k+1+8k) in a single bottom-uptraversal of T . Since the number of nodes of T may be assumed to be bounded by O (| A|), the desired upper bound ofthe theorem follows immediately. We prove the upper bound O (222k+1+8k) for the time needed at each node t ∈ T bydistinguishing the four types of nodes. As in the proof of Theorem 6, the computationally most expensive node type is theJOIN node, which is the one we shall focus on below. The other node types are treated similarly.and t. To compute the table of vpairs for t, we iterate in a nested loop overLet t be a JOIN node with successors t(cid:7), Γ (cid:7)) in the table at t(cid:7)(cid:7), Γ (cid:7)) is aall pairs (C(cid:7)(cid:7), (Γ (cid:7) (cid:3) Γ (cid:7)(cid:7)) ∪ (Γ (cid:7) (cid:3)(cid:7)(cid:7), Γ (cid:7)(cid:7)) is a vpair and [Cvpair and (C(cid:7)} (cid:3) Γ (cid:7)(cid:7))) and set the vpair-bit in the row corresponding to (C, Γ ) in the table at node t. As in the proof of(cid:7)(cid:7)}) ∪ ({C{CTheorem 6, the join operation can be carried out in time O (10k · k). The access to the appropriate row in the table at node t(cid:7), Γ (cid:7)). Moreover,is feasible in time O (22k · k). In total, we have to process at most (2n)2 combinations of vpairs (C, Γ ) and (Cthe action required for each such combination of vpairs fits into O (10k · k + 22k · k) = O (24k). We thus end up with the upperbound O ((222k+2k)2 · 24k) = O ((222k+1+4k) · 24k) = O (222k+1+8k). (cid:2)(cid:7)(cid:7)]. If this is the case, we compute the vpair (C, Γ ) = (Cand all pairs (C(cid:7)] = [Cand do the following: check if (C(cid:7)(cid:7), Γ (cid:7)(cid:7)) in the table at t(cid:7) (cid:3) C(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)4.3. Characterizing ideal setsSo far, we have solved the credulous and the skeptical acceptance problems. For the first problem we used coloringsto characterize admissible sets and for the latter problem we extended our data structure by certificates Γ , handling thesubset maximality, to characterize preferred extensions. Here, we will reuse the concept of certificates to characterize idealsets. But instead of storing supersets in the certificates we store certain witnesses against being an ideal set. Such witnesseshave been identified by Dunne [23] as follows.Proposition 3. (See [23].) Let F = ( A, R) be an AF and S ⊆ A a set of arguments. S is an ideal set of F iff the following conditionshold:• S is admissible in F ;• for every argument p ∈ S− = {x ∈ A | (x, s) ∈ R for some s ∈ S}, no admissible set of F contains p.Intuitively, S is an ideal set of an AF F if S is admissible and S is not attacked by any other admissible set. Therefore,a certificate Γ of a pair (C, Γ ) should represent all restricted admissible sets that attack some S ∈ et(C). This is formallydefined next.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3729Definition 19. Given a tree decomposition (T , X ) of an AF F and a pair (C, Γ ) for t ∈ T , i.e. where C is a coloring for t andΓ is a set of colorings for t, define eIDt (C, Γ ) as the collection of sets S which satisfy the following conditions:(i) S ∈ et(C);(ii) for all C(iii) for all X>t -restricted admissible (for F (cid:2)t ) sets E such that E (cid:2) S there is a C(cid:7) ∈ Γ , there exists a set E ∈ et(C(cid:7)), such that E (cid:2) S;(cid:7) ∈ Γ with E ∈ et(C(cid:7)).If eIDt (C, Γ ) (cid:13)= ∅, we call (C, Γ ) an ID-pair for t.The following lemmas are analogous to Lemmas 1 and 2 (resp. Lemmas 11 and 12).Lemma 17. Let (T , X ) be a tree decomposition of an AF F , t ∈ T , and S an X>t -restricted admissible set for F (cid:2)t . Then there is a pair(C, Γ ) with S ∈ eIDt (C, Γ ).Proof. Let S be an X>t -restricted admissible set for F (cid:2)t . By Lemma 1, there exists a coloring C with S ∈ et(C). Now let(cid:7))}. We claim thatE = {E | E is X>t -restricted admissible for F (cid:2)t and E (cid:2) S}. Moreover, let Γ = {Ct (C, Γ ). To prove this, we check the conditions (i)–(iii) from Definition 19: (i) S ∈ et(C) by the selection of C . (ii) ForS ∈ eID(cid:7)) with E (cid:2) S; this follows by the construction of Γ from E . (iii) For all E being X>t -(cid:7) ∈ Γ , there exists E ∈ et(Call C(cid:7)); again this follows by the constructionrestricted sets admissible in F (cid:2)t with E (cid:2) S, there exists Cof Γ from E . (cid:2)(cid:7) ∈ Γ such that E ∈ et(C(cid:7) | ∃E ∈ E, s.t. E ∈ et(CLemma 18. Let (T , X ) be a tree decomposition of an AF F and let (C, Γ ), (CeIDt (C(cid:7), Γ (cid:7)) = ∅.(cid:7), Γ (cid:7)) be different pairs for t ∈ T . Then, eIDt (C, Γ ) ∩Proof. If C (cid:13)= Cwith Γ (cid:13)= Γ (cid:7)t (C, Γ ) ∩ eIDeID(applied to eID(applied to eIDThus, ¯C ∈ Γ (cid:7)(cid:7)then, by Lemma 2, et(C) ∩ et(C(cid:7)) = ∅ and our claim follows. Thus, it remains to consider pairs (C, Γ ), (C, Γ (cid:7)). In order to show that. W.l.o.g., we assume that there exists a coloring ¯C for t such that ¯C ∈ Γ but ¯C /∈ Γ (cid:7)t (C, Γ (cid:7)) = ∅, we prove that none of the sets S ∈ eIDt (C, Γ (cid:7)). By Definition 19t (C, Γ )), there exists an X>t -restricted admissible set E ∈ et( ¯C) for F (cid:2)t such that E (cid:2) S. By Definition 19t (C, Γ (cid:7))), there exists a coloring Ccoincide., a contradiction. (cid:2)t (C, Γ (cid:7)).t (C, Γ ). Suppose to the contrary that S is also contained in eID∗). By Lemma 2, the colorings ¯C and Ct (C, Γ ) is contained in eIDsuch that E ∈ et(C∗ ∈ Γ (cid:7)∗Let S be an arbitrary set in eIDIn summary, we again conclude that each element S ∈ eIDt (C, Γ ) is an X>t -restricted admissible set for F (cid:2)t and eachX>t -restricted admissible set for F (cid:2)t is characterized by a unique ID-pair for t.Proposition 4. Let r be the root of a nice tree decomposition (T , X ) of an AF F . Then, eIDr ((cid:7), ∅) = ideal(F ).r ((cid:7), ∅) ⊆ ideal(F ), let S be an arbitrary set such thatProof. We recall that er((cid:7)) = adm(F ). To show the set inclusion eIDS ∈ eIDr ((cid:7), ∅). By Definition 19(i), we obtain that S is X>r -restricted admissible in F (cid:2)r , i.e. (since the root has an empty bag)S is an admissible set for F . Further by (iii) and the fact that Γ = ∅ we conclude that there is no admissible set E such thatE (cid:2) S. By Proposition 3, S is thus an ideal extension of F .It remains to show that eIDr ((cid:7), ∅) ⊇ ideal(F ). Thus let S ∈ ideal(F ) be an arbitrary ideal extension. By Lemmas 17 and 18we get that there exists a unique ID-pair (C, Γ ) such that S ∈ eIDt (C, Γ ). Since the root has an empty bag we have C = (cid:7) andfurther by Definition 19(ii) and the fact that there is no admissible set E of F such that E (cid:2) S (again using Proposition 3)we conclude that Γ = ∅. (cid:2)Thus our pairs have the desired property to characterize ideal extensions. As in the previous subsections, we give nowan alternative definition of such pairs which allows for an efficient computation (as long as the tree-width of the given AFis small).Definition 20. Let t ∈ T be a node in a nice tree decomposition (T , X ) of an AF and tDepending on the node type of t we define an ID-vpair for t as follows:(cid:7)(cid:7)(cid:7), tthe possible children of t.• LEAF: Each (C, Γ ) where C ∈ Ct and Γ = {C• FORGET: If (C(cid:7), Γ (cid:7)) is an ID-vpair for t(cid:7) − a, Γ (cid:7) − a) is an ID-vpair for t.(cid:7), Γ (cid:7)) is an ID-vpair for t• INSERT: If (C– (C(cid:7)(cid:7)(cid:7) ∈ Ct | [C, Xt = Xt(cid:7) \ {a}, and C(cid:7)] (cid:2) [C]}, is an ID-vpair for t.(cid:7)(a) (cid:13)= att, thenand Xt = Xt(cid:7) ∪ {a}, then(cid:7) + a, Γ ) with Γ = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) [C(cid:7) ˙+ a is a vcoloring then (C(cid:7) + a]} is an ID-vpair for t;(cid:7) ˙+ a, Γ ) with Γ = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) [C– (C– if C(cid:7) ˙+ a]} is an ID-vpair for t aswell.30W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37• JOIN: If (C(cid:7) (cid:3) C– (C(cid:7), Γ (cid:7)) is an ID-vpair for t(cid:7)(cid:7), (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7))) is an ID-vpair for t.(cid:7)(cid:7), Γ (cid:7)(cid:7)) is an ID-vpair for t, (C(cid:7)(cid:7)(cid:7), and [C(cid:7)] = [C(cid:7)(cid:7)], thenLet us comment on the construction of the set of certificates for pairs with colorings C. By thenature of certificates for ID-pairs, we have to consider all vcolorings that can be constructed from the certificates in thesuccessor nodes (in the case of vpairs in the previous subsection we could restrict ourselves to a certain superset relation).(cid:7) + a operation. Here we consider a new argument a but do not add it to [C].Let us first explain the construction for the C(cid:7) ˙+ a. Further weNow each certificate E(cid:7) + a] then all vcolorings E withmay also get new certificates of C(cid:7) + a]}. SimilarE(a) = in are certificates for C(cid:7) ˙+ a]} captures the colorings E withconsiderations underlie the certificates of C(cid:7)(cid:7)[E] (cid:2) a. Next let us consider the certificates of C.The certificate Eis combinedwith each vcoloring D(cid:7) + a. This is why Γ in the above definition contains the set {C ∈ Ct | [C] (cid:2) [Cmay give rise to several certificates of C(cid:7)(cid:7)]. Similarly a certificate E(cid:7) + a from the vcolorings of the current node. If a (cid:2) [Cis combined with each vcoloring Dsuch that [E(cid:7) ˙+ a, but here the set {C | C ∈ Ct, [C] (cid:2) [Cmay give rise to two certificates of C. A certificate Esuch that [E(cid:7) + a and (possibly) E(cid:7) + a, namely E(cid:7) ∈ Γ (cid:7)(cid:7)] = [D(cid:7)(cid:7)] = [D(cid:7) (cid:3) C(cid:7)(cid:7)(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7) (cid:3) Cof tof t(cid:7)].(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7) + a, C(cid:7) ˙+ a and C(cid:7) (cid:3) C(cid:7)(cid:7)Example 24. Recall the AF from Example 9. The computation of ID-vpairs for the nodes of the tree decomposition for thisAF is illustrated in Fig. 11. The symbol (cid:5) is now used to mark ID-vpairs that correspond to at least one X>t -restrictedadmissible set containing the argument a.In the following we show that the concept of ID-vpairs coincides with the concept ID-pairs and thus is appropriate forefficiently deciding the problem of ideal acceptance. As before we do this separately for each node type starting with LEAFnodes:Lemma 19. For any LEAF node t in a tree decomposition of an AF, the ID-vpairs of t coincide with the ID-pairs of t.Proof. Let (T , X ) be a tree decomposition of an AF F and t a leaf in T . The X>t -restricted admissible sets for F (cid:2)t coincidewith the sets [C] for the valid colorings C ∈ Ct . Moreover, the valid colorings and vcolorings for t coincide by Lemma 3. Nowlet (C, Γ ) be an ID-pair for t. Then, by Definition 19, [C] ∈ eIDt (C, Γ ). Hence, by Definition 20, (C, Γ ) is an ID-vpair for t.Conversely, let (C, Γ ) be an ID-vpair for t and let S = [C]. By Definition 16, S is X>t -restricted admissible for F (cid:2)t . Hence,by Definitions 19 and 20, S ∈ eIDt (C, Γ ). Thus, (C, Γ ) is an ID-pair for t. (cid:2)Example 25. As an example consider the LEAF node n13 in Fig. 11. The vcolorings C1, C2, C3, C4 correspond to the ∅-restricted admissible sets {e}, { f }, {g} and ∅. As in our example f (cid:2) e we have that C2 is a certificate for C1. For similarreasons we get that C3 is a certificate for C2 and that C1 is a certificate for C3. As ∅ has no attackers, the set of certificatesfor C4 is empty.We proceed with nodes of type FORGET:Lemma 20. For any FORGET node t in a tree decomposition of an AF, the ID-vpairs and ID-pairs coincide, if they coincide in the childnode tof t.(cid:7)(cid:7)∗, Γ ∗) is an ID-vpair for t(cid:7) − a. Since S ∈ eIDt(cid:7) (CProof. Let (T , X ) be a tree decomposition of F = ( A, R), t a FORGET node in T , and tthe child node of t. It holds thatXt = Xt(cid:7) \ {a} for some argument a ∈ Xt(cid:7) . First we show that every ID-pair for t is also an ID-vpair for t. Thus let (C, Γ )be an ID-pair for t and S ∈ eIDt (C, Γ ). In particular, S is X>t -restricted admissible for F (cid:2)t and, hence, by Lemma 4 also∗, Γ ∗).X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t . Thus, by Lemma 17, there exists an ID-pair (C(cid:7)),(cid:7)By assumption, (C(cid:7)(a) (cid:13)= att, and C = CCby Lemma 2.Hence, by C(cid:7)∗ = C(cid:7) − a = C∗ − a.∗(a) (cid:13)= att. First considerthe implication “⇒”: let D be an arbitrary coloring in Γ . By condition (ii) of Definition 19, there exists an X>t -restrictedadmissible set E for F (cid:2)t with E (cid:2) S and E ∈ et(D). By Lemma 4, E is also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) = F (cid:2)t . Hence,∗ − aby condition (iii) of Definition 19, there exists D), oneshown above (i.e., constructing Dcan now prove that D = D∗, Γ ∗) for t(cid:7). Recall from the proof of Lemma 5 the construction of C∗, Γ ∗) and, therefore, in particular, S ∈ et(cid:7) (C∗ − a, Γ ∗ − a) is an ID-vpair for t with C = C∗ − a for some Dwith DIt remains to show that Γ = Γ ∗ − a holds, i.e., D ∈ Γ ⇔ D = Dfrom D as in the proof of Lemma 5 and applying Lemma 2 to conclude D(cid:7)with S ∈ eIDfrom C , s.t. S ∈ et(cid:7) (C∗). Analogously to the equalities C = C(cid:7)(a) (cid:13)= att and by Definition 20, (C(cid:7) − a = C∗(cid:7) = D∗), we have Cwith E ∈ et(cid:7) (D∗ − a holds.∗(a) = C∗ ∈ Γ ∗∗ ∈ Γ ∗t(cid:7) (C(cid:7)Now consider the implication “⇐”: let D∗ ∈ Γ ∗with Drestricted admissible set E for F (cid:2)t(cid:7) with E (cid:2) S and E ∈ et(cid:7) (DE ∈ et(D). Hence, by condition (iii) of Definition 19 and Lemma 2, we have D ∈ Γ .∗(a) (cid:13)= att. By condition (ii) of Definition 19, there exists an X>t(cid:7) -∗ − a is defined and∗(a) (cid:13)= att, the coloring D = D∗). By DIt remains to show that every ID-vpair for t is an ID-pair for t. Therefore consider an ID-vpair (C, Γ ) for t. By definition(cid:7) − a, Γ (cid:7) − a). By assumption, (C(cid:7), Γ (cid:7)) is alsot (C, Γ ) holds. As in the proof of Lemma 5,(cid:7)(a) (cid:13)= att and (C, Γ ) = (C(cid:7), Γ (cid:7)). We claim that also S ∈ eID(cid:7), Γ (cid:7)) for node t(cid:7). Hence, there exists S ∈ eIDthere exists an ID-vpair (Can ID-pair for twith C(cid:7)t(cid:7) (CW. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3731Fig. 11. Computation of ID-vpairs for the example AF.(cid:7)(a) (cid:13)= att and C = C(cid:7) − a. It remains to show that (C, Γ ) also satisfies conditions (ii) and (iii) ofS ∈ et(C) holds since CDefinition 19.(cid:7), Γ (cid:7)), there exists E ∈ et(cid:7) (DTo show condition (ii), consider D ∈ Γ , i.e., D is of the form D = D(cid:7)(a) (cid:13)= att. Since S ∈(cid:7) ∈ Γ (cid:7)(cid:7) − a). To show condition (iii),(cid:7)) with E (cid:2) S. As in the proof of Lemma 5, then also E ∈ et(DeIDt(cid:7) (Clet E be an X>t -restricted admissible set for F (cid:2)t with E (cid:2) S. Then E is also X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and,(cid:7)(a) (cid:13)= att and, therefore,therefore, there exists DDwith E ∈ et(cid:7) (D(cid:7) − a ∈ Γ = Γ (cid:7) − a. Moreover, as in the proof of Lemma 5, also E ∈ et(D(cid:7)). Since E is X>t -restricted admissible, we have D(cid:7) − a for some D(cid:7) − a) holds. (cid:2)(cid:7) ∈ Γ (cid:7)with D32W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37Example 26. Consider the FORGET node n12 in Fig. 11 where argument g is removed. The ID-vpairs for n12 are obtained(cid:7)from the ID-vpairs of n13, but (as for vcolorings) with one exception. As discussed in Section 4.1, the vcoloring C2 of n13(cid:7)with C( f ) = in is not a vcoloring for n12. Thus we exclude the ID-vpair based on this vcoloring and further exclude C2 fromall certificate sets.Next we consider INSERT nodes:Lemma 21. For any INSERT node t in a tree decomposition of an AF, the ID-vpairs and ID-pairs coincide, if they coincide in the childnode tof t.(cid:7)Proof. Let (T , X ) be a tree decomposition of F = ( A, R), t an INSERT node in T , and tthe child node of t. Then there existsan argument a ∈ A such that Xt = Xt(cid:7) ∪ {a}. First we show that every ID-pair for t is also an ID-vpair for t. Thus consideran ID-pair (C, Γ ) for t. Then there exists an X>t -restricted admissible set S for F (cid:2)t such that S ∈ eIDt (C, Γ ). Moreover also(cid:7), Γ (cid:7)) for tthe set Swith(cid:7) ∈ eIDt(cid:7) (CSThen (C(cid:7) = S \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . Thus, by Lemma 17, there exists an ID-pair (C(cid:7), Γ (cid:7)) and by assumption, (C(cid:7)] ∪ a is(cid:7) ˙+ a} is an ID-vpair for t. This(cid:7) ˙+ a, Γ2) with Γ2 = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) Cconflict-free in Ft then also (Cfollows by the same arguments based on properties of a tree decomposition as we have used earlier, e.g. in the proof ofLemma 15. We claim that either (C(cid:7) + a, Γ1) with Γ1 = (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ∪ {C ∈ Ct | [C] (cid:2) C(cid:7) + a} is an ID-vpair for t and further if [C(cid:7), Γ (cid:7)) is also an ID-vpair for t(cid:7) ˙+ a, Γ2) = (C, Γ ) holds.(cid:7) + a, Γ1) = (C, Γ ) or (C.(cid:7)(cid:7)(cid:7)To show that either C = C(cid:7) + a (if a /∈ S) or C = C∗(cid:7)), we have that C(cid:7) ˙+ a (if a ∈ S) holds, consider the proof of Lemma 7 where we construct∗). Asby Lemma 2 and the claim follows. To show the equality for the certificates,∗ ˙+ a holds. Moreover, we have S, such that either C = C(cid:7) = C∗ + a or C = C(cid:7) ∈ et(C∗a coloring, which we denote here as C(cid:7) ∈ et(Cby definition Si.e. Γ = Γ1 or Γ = Γ2, we distinguish two cases:(1) Assume a /∈ S: To show Γ1 = Γ , we first prove the inclusion Γ1 ⊆ Γ : For the inclusion (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ⊆ Γ , considerfor F (cid:2)t(cid:7) with. By condition (ii) of Definition 19, there exists an X>t(cid:7) -restricted admissible set E(cid:7)(cid:7) ∈ Γ (cid:7)an arbitrary D(cid:7) ∈ et(cid:7) (D(cid:7)(cid:7) (cid:2) Sand EEAs by assumption a /∈ S we have that(cid:7)).(i) E(cid:7) (cid:2) Sand (ii) E = E(cid:7)(cid:7) ∪ {a} (cid:2) S,is conflict-free in F (cid:2)t ; in the latter case, E is conflict-free in F (cid:2)t if [Drespectively.(cid:7)] ∪ {a} is so.In the first case we have that EFurther if E is conflict-free in F (cid:2)t then it is also X>t -restricted admissible for F (cid:2)t (using the fact that there are noattacks between arguments from X>t and a which holds by properties of tree decompositions). Thus, by Definition 19,there exists a set D ∈ Γ such that E ∈ et(D). Using the construction from the proof of Lemma 7 and Lemma 2, in(cid:7) ˙+ a. This concludes the proof that (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ⊆ Γcase (i), we have D = Dholds.It remains to show {Cet(CNow consider an arbitrary vcoloring D ∈ Γ . By condition (ii) of Definition 19, there exists an X>t -restricted admissible(cid:7) = E \ {a} one of the followingset E ∈ et(D) for F (cid:2)t such that E (cid:2) S. Using the assumption a /∈ S we conclude that for Econditions holds:(cid:7) + a] it follows that for each S ∈ et(C), E (cid:2) S and thus C(cid:7) + a]} ⊆ Γ . Thus let us consider such a coloring C(cid:7) + a and in case (ii), we have D = D∗ ∈ Γ must hold. Hence, Γ1 ⊆ Γ .and an arbitrary set E ∈∗ ∈ Ct | [C∗). As [C∗] (cid:2) [C∗] (cid:2) [C∗(i) E(cid:7) (cid:2) S(cid:7)or(ii) E(cid:7)but a (cid:2) S.(cid:7) (cid:13)(cid:2) S(cid:7)In both cases we have that Ecase (i) we can use the proof of Lemma 7 and Lemma 2 to show that either D = D∗ ∈ Ct | [Cuse that a (cid:2) S iff [D] (cid:2) [C] iff D ∈ {Cis X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) and thus there exists D(cid:7) + a]}. Hence, Γ ⊆ Γ1.∗] (cid:2) [C(cid:7) ∈ Γ (cid:7)(cid:7) + a or D = D(cid:7)). Inwith E ∈ et(cid:7) (D(cid:7) ˙+ a. In case (ii) we(cid:7)(cid:7)] ∪ {a} is conflict-free in Ft then also E = E. By condition (ii) of Definition 19, there exists an X>t(cid:7) -restricted admissible set E(cid:7) ∈ Γ (cid:7). As X>t = X>t(cid:7) we have that E(2) Assume a ∈ S: To show Γ2 = Γ , we first consider the inclusion Γ2 ⊆ Γ : For the inclusion (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) ⊆ Γ ,(cid:7))(cid:7) ∈ et(cid:7) (Dis also an X>t -restricted admissible set for F (cid:2)t and further if(cid:7) ∪ {a} is X>t -restricted admissible for F (cid:2)t . By Definition 19 there exists(cid:7) ∈ et(D) or E ∈ et(D), respectively. By the construction in the proof of Lemma 7 and Lemma 2 we∗] (cid:2) [C]consider an arbitrary D(cid:7)(cid:7) (cid:2) Sfor F (cid:2)t(cid:7) with E[Da D ∈ Γ such that E(cid:7) + a or D = Dobtain that D = Dit follows that for each S ∈ et(C), E (cid:2) S and thus CNow let D ∈ Γ . By condition (ii) of Definition 19, there exists an X>t -restricted admissible set E ∈ et(D) for F (cid:2)twith E (cid:2) S. By assumption a ∈ S and thus we have that Eis X>t(cid:7) -restricted(cid:7) (cid:2) a. In the(cid:7) (cid:2) Swith Eadmissible for F (cid:2)t(cid:7) and thus there exists D(cid:7) ˙+ a holds (again by the proof of Lemma 7 and Lemma 2). Thusfirst case we have that either D = DD ∈ (Γ (cid:7) + a) ∪ (Γ (cid:7) ˙+ a) holds. In the latter case it holds that [D] (cid:2) [C] (as a ∈ [C]) and D ∈ Ct (as D ∈ Γ ). ThusD ∈ {C(cid:7) = E \ {a} (cid:2) S. Further we have that E(cid:7) ∈ et(cid:7) (D∗ ∈ Ct | [C∗ ∈ Γ must hold. Hence, Γ2 ⊆ Γ .(cid:7) ˙+ a, respectively. It remains to show that {C(cid:7) ˙+ a]} holds. Hence, Γ ⊆ Γ2.(cid:7) ˙+ a]} ⊆ Γ . As [C(cid:7)). Now either E(cid:7) = S \ {a} or E(cid:7) + a or D = D∗ ∈ Ct | [C∗] (cid:2) [C∗] (cid:2) [C(cid:7) ∈ Γ (cid:7)(cid:7)W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3733It remains to show that every ID-vpair for t is also an ID-pair for t. Thus let (C, Γ ) be an ID-vpair for t. By definition(cid:7)] ∪ {a} is conflict-free in Ft ,such that either (C, Γ ) = (C(cid:7) + a, Γ1) or, in case [C(cid:7), Γ (cid:7)) for node t(cid:7)there exists an ID-vpair (C(C, Γ ) = (CBy assumption, (C(cid:7) ˙+ a, Γ2) (Γ1, Γ2 defined as above).(cid:7)(cid:7), Γ (cid:7)) is an ID-pair for tif C = C(cid:7)where S is defined as follows: S = Sholds in both cases. It remains to show that also conditions (ii) and (iii) of Definition 19 are fulfilled.. Hence, there exists S(cid:7) + a and S = S(cid:7) ∈ eIDt(cid:7) (C(cid:7) ∪ {a} if C = C(cid:7), Γ (cid:7)). We claim that also S ∈ eIDt (C, Γ ) holds,(cid:7) ˙+ a. As in the proof of Lemma 7, S ∈ et(C)To show condition (ii), let D ∈ Γ , i.e., D is either of the form(a) D = D(cid:7) ∈ Γ (cid:7)(b) D = D(cid:7) + a,. We prove for each of these cases that condition (ii) holds, i.e., there exists a set E ∈ et(D), such that(c) [D] (cid:2) [C](cid:7) ˙+ a orfor some DE (cid:2) S:(cid:7)) with E(cid:7) (cid:2) S(cid:7). Thus, by S(cid:7) ⊆ S, also E(cid:7) (cid:2) S holds. Moreover, as in the proof(a) By S(cid:7) ∈ eIDt(cid:7) (C(cid:7), Γ (cid:7)), there exists Eof Lemma 7, we also have E(cid:7) ∈ eID(cid:7) ∈ et(D(cid:7), Γ (cid:7)), there exists an E(cid:7) ∈ et(cid:7) (D(cid:7) + a).t(cid:7) (C(cid:7) (cid:2) S. By the construction of(b) Again, by S(cid:7) ∪ {a} is conflict-free in F (cid:2)t . By the usual arguments exploiting the definition of treeD = Ddecompositions, we obtain that E is an X>t -restricted admissible set for F (cid:2)t . Following the proof of Lemma 7, we getE ∈ et(D(cid:7) ˙+ a). Moreover, E (cid:2) S follows from E(cid:7) ˙+ a we know that E = Eand, therefore, also E(cid:7) (cid:2) S and E(c) As D is a valid coloring there exists an X>t -restricted admissible set E ∈ et(D). From [D] (cid:2) [C] and S ∈ et(C) it follows(cid:7)) with E(cid:7) ∈ et(cid:7) (D(cid:7) (cid:2) S(cid:7) ⊆ E.(cid:7)that E (cid:2) S.To show condition (iii), let E be X>t -restricted admissible for F (cid:2)t such that E (cid:2) S. Further let D be the unique coloring(cid:7) (cid:2) S \ {a} then(cid:7) + a or(cid:7) (cid:13)(cid:2) S it must hold that either (i) a ∈ E and a (cid:2) S or (ii) a ∈ S andsuch that E ∈ et(D). We claim that D ∈ Γ . Clearly, E(cid:7) ∈ et(cid:7) (D(cid:7)DD = DE (cid:2) a. But both (i) and (ii) imply that [D] (cid:2) [C] and hence D ∈ Γ . (cid:2)(cid:7) = E \ {a} is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) . If E(cid:7)) and D(cid:7) ˙+ a holds and therefore D ∈ Γ . Otherwise if E. Then, as in the proof of Lemma 7, either D = Ddenotes the unique vcoloring such that E(cid:7) ∈ Γ (cid:7)Example 27. One example for an INSERT node is the node n11 in Fig. 11, where the argument d is added. The ID-vpairs+ d,of n11 are obtained from the ID-vpairs of n12. For instance consider the ID-vpair (Cobserve that [C2] (cid:2) [C1] and [C4] (cid:2) [C1]; hence we derive the ID-vpair (C1, {C2, C4}) for n11.(cid:7)1, ∅) of n12. For the vcoloring C1 = C(cid:7)1Now consider the ID-vpair (C(cid:7)2, {C(cid:7)1}) of n12. We get the vcoloring C2 = C(cid:7)2˙+ d and the certificate C1 = C(cid:7)1+ d. C˙+ d is(cid:7)1not a vcoloring and C1 is the only vcoloring with [C1] (cid:2) [C2]. Thus we obtain the ID-vpair (C2, {C1}).Finally we discuss JOIN nodes.Lemma 22. For a JOIN node t in a tree decomposition of an AF with successors tif they coincide for tas well as for t(cid:7)(cid:7).(cid:7)(cid:7)(cid:7)(cid:7), t, the ID-vpairs of t coincide with the ID-pairs of t(cid:7)), S2 ∈ et(cid:7)(cid:7) (CProof. Let (T , X ) be a tree decomposition of F = ( A, R) and t a JOIN node in T with successors t. Recall that wehave Xt = Xt(cid:7) = Xt(cid:7)(cid:7) . To show that every ID-pair for t is also an ID-vpair for t, consider an arbitrary ID-pair (C, Γ ) for t.Then, there exists an X>t -restricted admissible set S ∈ eIDt (C, Γ ) for F (cid:2)t . As in the proof of Lemma 8 we have that there(cid:7)exist unique sets S1 ⊆ X(cid:2)t(cid:7) and S2 ⊆ X(cid:2)t(cid:7)(cid:7) such that S1 ∩ Xt = S2 ∩ Xt and S = S1 ∪ S2. Moreover there exist vcolorings C,(cid:7), Γ (cid:7))(cid:7)(cid:7)) and C = C1 (cid:3) C2. Hence there exist ID-pairs (C(cid:7)(cid:7)C∗, Γ ∗)and S2 ∈ eIDwith S1 ∈ eID(cid:7)(cid:7), Γ (cid:7)(cid:7)) with S1 ∈ eIDt(cid:7) (C(cid:7)(cid:7), Γ (cid:7)(cid:7)), which, by assumption are also ID-vpairs. (Notice that by Lemma 2 there cannot be a pair (C∗, Γ ∗) and Csuch that S1 ∈ et(cid:7) (Ct(cid:7)(cid:7) (Ct(cid:7) (CNow we turn our attention to the certificates. We have to show Γ = (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)). We first prove the inclusionΓ ⊆ (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)). So, let D ∈ Γ . By Definition 19 there exists an X>t -restricted admissible set E for F (cid:2)t suchthat E (cid:2) D. We define E = E1 ∪ E2 analogously to S1, S2. As we mentioned in the proof of Lemma 8, there are no attacksbetween the argument sets X>t(cid:7) and X>t(cid:7)(cid:7) , because of the properties 2 and 3 of tree decompositions. Thus we have thatE (cid:2) S holds iff eitherwith the above properties is unique.). Analogously, C(cid:7), Γ (cid:7)), (C(cid:7) (cid:13)= Cand t(cid:7)(cid:7)∗(cid:7)(cid:7)(cid:7)(i) E1 (cid:2) S1 or(ii) E2 (cid:2) S2holds. As both cases are symmetric it suffices to consider case (i). As E is X>t -restricted admissible for F (cid:2)t , we have that(cid:7)(cid:7) ∈also E1 is X>t(cid:7) -restricted admissible for F (cid:2)t(cid:7) , and likewise, E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . Thus there exists D(cid:7)). By the proof of Lemma 8 andCt(cid:7)(cid:7) such that E2 ∈ et(cid:7)(cid:7) (Dand thus D ∈ Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) . Hence Γ ⊆ (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)).the uniqueness property of Lemma 2 we have that D = D(cid:7)(cid:7)). Moreover by (i) we have that there exists Dwith E1 ∈ et(cid:7) (D(cid:7) ∈ Γ (cid:7)(cid:7) (cid:3) D(cid:7)(cid:7)It remains to show that (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)) ⊆ Γ which is equivalent to(i) Γ(cid:7) (cid:3) Ct(cid:7)(cid:7) ⊆ Γ and (ii) Ct(cid:7) (cid:3) Γ(cid:7)(cid:7) ⊆ Γ.34W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37(cid:7))(cid:7)(cid:7)], E1 ∈ et(cid:7) (D(cid:7)(cid:7)). By Definition 19 we have that E1 (cid:2) S1 and therefore that E = E1 ∪ E2 (cid:2) S. Further by the proof of(cid:7) (cid:3)(cid:7)(cid:7) ∈ Γ . Hence (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)) ⊆ Γ . In summary, we have proved Γ = (Γ (cid:7) (cid:3) Ct(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7)) and thus every ID-pairAs before, by symmetry, we may restrict ourselves to case (i). Thus let Dand E2 ∈ et(cid:7)(cid:7) (DLemma 8 and Lemma 2, D = DD(C, Γ ) is also an ID-vpair.is the unique coloring such that E ∈ et(D). We thus obtain the desired result D(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) with [D(cid:7)] = [D(cid:7) ∈ Γ (cid:7)(cid:7) (cid:3) Dand D(cid:7)(cid:7)In the second part of the proof we show that every ID-vpair for t is an ID-pair for t. Thus let (C, Γ ) be an ID-vpair for t.(cid:7)(cid:7), (Γ (cid:7) (cid:3)(cid:7), Γ (cid:7)) are also ID-pairs and thus there are sets S1, S2 suchand an ID-vpair (C(cid:7), Γ (cid:7)) and (Csuch that (C, Γ ) = (C(cid:7)(cid:7), Γ (cid:7)(cid:7)) for node t(cid:7) (cid:3) CBy definition there is an ID-vpair (CCt(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) Γ (cid:7)(cid:7))) and [Cthat S1 ∈ eIDt(cid:7) (C(cid:7), Γ (cid:7)) and S2 ∈ eID(cid:7)] = [C(cid:7), Γ (cid:7)) for node t(cid:7)(cid:7)(cid:7)]. By assumption, (Ct(cid:7)(cid:7) (C(cid:7)(cid:7), Γ (cid:7)). As in the proof of Lemma 8, S = S1 ∪ S2 ∈ et(C) holds since [C(cid:7)(cid:7)] = [C(cid:7)].(cid:7)(cid:7)It remains to show that also conditions (ii) and (iii) of Definition 19 are fulfilled:(cid:7)(cid:7)(cid:7) (cid:3) D(cid:7) (cid:3) D(ii) To show condition (ii), consider D ∈ Γ . Then D is either of the form(cid:7) ∈ Γ (cid:7), D(cid:7) ∈ Ct(cid:7) , D(a) D = D(b) D = DBy symmetry, it suffices to consider case (a). As S1 ∈ eIDDholds that E = E1 ∪ E2 ∈ et(D(cid:7)(cid:7)], there exists E2 ∈ et(cid:7)(cid:7) (D(cid:7)(cid:7)) and E (cid:2) S.(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) with [D(cid:7)(cid:7) ∈ Γ (cid:7)(cid:7)with [D(cid:7)] = [D(cid:7)] = [Dt(cid:7) (Cfor some Dfor some D(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) and [D(cid:7)] = [D(cid:7) (cid:3) D(cid:7)(cid:7)(cid:7)(cid:7)], or(cid:7)(cid:7)].(cid:7), Γ (cid:7)) there exists E1 ∈ et(cid:7) (D(cid:7)) such that E1 (cid:2) S1. Further by(cid:7)(cid:7)) such that E1 ∩ Xt = E2 ∩ Xt . Now, using the proof of Lemma 8, it(iii) To show condition (iii), let E be X>t -restricted admissible for F (cid:2)t with E (cid:2) S. Then E1 is X>t(cid:7) -restricted admissiblefor F (cid:2)t(cid:7) and E2 is X>t(cid:7)(cid:7) -restricted admissible for F (cid:2)t(cid:7)(cid:7) . Moreover as E (cid:2) S either E1 (cid:2) S1 or E2 (cid:2) S2 holds. Thusthere exist D(cid:7)(cid:7)), E1 ∩ Xt = E2 ∩ Xt , and either(cid:7)), E2 ∈ et(cid:7)(cid:7) (D, D(cid:7)(cid:7)(cid:7)with E1 ∈ et(cid:7) (D(cid:7)(cid:7) ∈ Ct(cid:7)(cid:7) or, D(a) D(cid:7) ∈ Γ(cid:7)(b) D(cid:7) ∈ Ct(cid:7) , D(cid:7)(cid:7) ∈ Γ(cid:7)(cid:7)holds. But then, as in the proof of Lemma 8, also E = E 1 ∪ E2 ∈ et(D(cid:7) (cid:3) D(cid:7)(cid:7)). (cid:2)Example 28. The only JOIN node in our example is n2 in Fig. 11. For instance consider joining the ID-vpair (C(cid:7)}) of n8. As [Cwith the ID-vpair (C1(cid:7)(cid:7)2 and vice versa we only get one certificate C2 = Conly appropriate join partner in n8 is C(C1, {C2}).] these two pairs can be combined to a pair (C1, Γ ). Further as for C}) of n3(cid:7)2 the(cid:7)(cid:7)2 . This leads to the ID-vpair(cid:7)(cid:7)1 , {C] = [C(cid:3) C(cid:7)(cid:7)1(cid:7)(cid:7)2(cid:7)2(cid:7)1, {C(cid:7)2Theorem 9. Let (T , X ) be a nice tree decomposition of an AF F = ( A, R). Then, for each pair (C, Γ ), it holds that (C, Γ ) is an ID-pairfor t iff (C, Γ ) is an ID-vpair for t.Proof. The proof makes use of the above lemmas and is the same as for the corresponding theorems in the previoussections. (cid:2)To decide whether an argument a is ideally accepted we now can proceed as for credulous acceptance: We have to markID-vpairs which assign the value in to the argument a and pass this mark up to the root. If the ID-vpair ((cid:7), ∅) at the roothas the mark, then we can conclude that the argument a is ideally accepted. Otherwise if ((cid:7), ∅) is not marked then theargument a is not ideally accepted.Example 29. Recall the computation in Fig. 11. Now we consider the problem of deciding whether the argument a is ideallyaccepted. The argument a first appears in the node n7 and thus we mark the ID-vpair with C1(a) = in and as before weillustrate this with a (cid:5) in the corresponding row of the table. Now consider node n5; here we have that the ID-vpairs(cid:7)(C1, ∅) and (C2, ∅) are constructed from the marked ID-vpair (C1, ∅) of n6 and thus they are marked. We mention that(cid:7)2, ∅), but this does not affect the mark. On the other hand, the only way tothe ID-vpair (C1, ∅) can also be built from (C(cid:7)build the ID-vpair (C3, ∅) is via the ID-vpair (C2, ∅) and thus it is not marked. Inspecting the root shows that a is ideallyaccepted, which indeed holds since {a} is an ideal set of our running example (see Example 2).Theorem 10. Deciding ID for an AF F = ( A, R) of tree-width k − 1 can be done in time O (222k+1+8k · | A|).Proof. Recall the proof of Theorem 6. We have that the number of pairs (C, Γ ) in each node is bounded by 2n withn = 22k + 2k. Further we store these pairs in tables such that we can find a given pair in time O (n).We have to show that computing the ID-vpairs at each node t ∈ T is feasible in time O (222k+1+8k) in a single bottom-up traversal of T . Since the number of nodes of T may be assumed to be bounded by O (| A|), the desired upper boundof the theorem follows immediately. We prove the upper bound O (222k+1+8k) for the time needed at each node t ∈ T bydistinguishing the four types of nodes. As in the proof of Theorem 6, the computationally most expensive node type is theJOIN node, which is the one we shall focus on below. The other node types are treated similarly.and tand all pairs (C. To compute the table of ID-vpairs for t, we iterate in a nested loop(cid:7), Γ (cid:7)) isLet t be a JOIN node with successors tand do the following: check if (C(cid:7)(cid:7), Γ (cid:7)(cid:7)) in the table at t(cid:7), Γ (cid:7)) in the table at tover all pairs (C(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3735an ID-vpair and (CCt(cid:7)(cid:7) ) ∪ (Ct(cid:7) (cid:3) {CTheorem 8, this can be done in time O (222k+1+8k). (cid:2)(cid:7)(cid:7), Γ (cid:7)(cid:7)) is an ID-vpair and [C(cid:7)(cid:7), (Γ (cid:7) (cid:3)(cid:7)(cid:7)})) and set the ID-vpair-bit in the row corresponding to (C, Γ ) in the table at node t. As in the proof of(cid:7)(cid:7)]. If this is the case, we compute the vpair (C, Γ ) = (C(cid:7)] = [C(cid:7) (cid:3) C5. ConclusionIn this paper, we have turned several theoretical tractability results for argumentation frameworks of bounded tree-width into efficient algorithms. All these algorithms are based on a dynamic programming approach which uses a singlebottom-up traversal of a tree decomposition of the given argumentation framework. For the basic algorithm, we introducedvcolorings as the crucial data structure to be maintained along this bottom-up traversal. We proved that this data structureallows us to succinctly represent the admissible sets and thus to efficiently decide credulous acceptance. For succinctlyrepresenting the preferred extensions and thus deciding skeptical acceptance we had to extend our basic data structure tovpairs – consisting of a vcoloring plus a set of certificates, which are themselves vcolorings. Finally, we modified these vpairsto so-called ID-pairs, which allowed us to design an efficient algorithm for ideal acceptance in argumentation frameworksof bounded tree-width. Moreover, we have shown that some further graph parameters (which, in contrast to tree-width,apply to directed graphs), do not lead to similar tractability results. The key to this collection of intractability results wasthe intractability for argumentation frameworks of bounded cycle-rank.Crucial for our dynamic programming algorithms is the efficient computation of a tree decomposition (T , X ) of mini-mum width (i.e., the tree-width) or at least a good approximation thereof. We have already mentioned in Section 2.2 thatBodlaender [7] provided a linear-time algorithm which, for fixed w (cid:3) 1, computes a tree decomposition of width at mostw provided that it exists. However, this algorithm is of limited practical use due to the big multiplicative constant, whichis exponential in the width w. Bodlaender et al. have developed several powerful preprocessing methods that may con-siderably reduce the size of a problem instance for tree-width computation [9,42]. Moreover, intensive research has beendevoted to heuristic methods for tree-width computation and to the development of efficient algorithms for an approxima-tion of the tree-width. A good survey on heuristic methods for tree-width computation is given in [8]. Further recent workson this topic are, for instance, [32,36,39]. Various algorithms with different approximation guarantees and run-time upperbounds are given in [1]. On the one hand, a polynomial-time algorithm is presented for a factor O (log w) approximation ofthe tree-width w. On the other hand, also algorithms for constant factor approximations of the tree-width are given. Thelatter algorithms work in exponential time w.r.t. the tree-wdith but are still exponentially faster than previous algorithms.All the above works on tree-width computation deal with a tradeoff of efficiency and accuracy. Alternatively, there are alsoapproaches where there is a tradeoff between efficiency and generality. For instance, in [16] a subexponential algorithmresults from the restriction of graph classes via forbidden minors.Several algorithms for the problems discussed in this paper have been presented in the literature. We mention the workby Doutre and Mengin [19] here which relies on set-enumeration techniques exploring a binary tree. Although this treeis conceptually different from the tree decompositions we use, a number of short-cuts for accelerating the enumeration isprovided, which could be applied to our algorithms as well.A similar, yet differently motivated account to characterize argumentation semantics via a decomposition (into a cer-tain form of strongly connected components) is due to Baroni et al. [5]. Similar as in tree decompositions, their approachallows to “locally” compute smaller parts of the extensions independently by propagating certain information during thecomputation. However, their concept is not directly amenable to fixed-parameter tractability since even in case the numberof arguments in the single components is bound, standard NP/coNP-hardness reductions apply. In fact, parameterizing thesize of the SCCs is related to the parameter cycle-rank as follows. If the size is of the largest SCC of an AF is bounded by kthen clearly the cycle-rank of the AF is (cid:4) k (as one can simple delete all arguments of an SCC to make it acyclic). But thereexist AFs with bounded cycle-rank and arbitrary large SCCs, e.g. directed cycles which have cycle-rank 1 but are of arbitrarysize. However, Π P2 -hardness proofs of skeptical acceptance under preferred semantics fail for AFs with bounded SCC-size.We anticipate that the coNP algorithm we presented for AFs of cycle-rank 1 can be extended to AFs such that for fixedSCC-size the algorithm runs in coNP but its run-time heavily increases with the maximal SCC-size yielding a para-coNPalgorithm [30].Recall that our algorithms rely on the concept of colorings. They look similar to labelings (see [11,38]). However, labelingsare defined for complete frameworks, while we require here a concept which also applies to subframeworks (recall thatfor our complexity results in Theorems 6, 8 and 10, it was essential that colorings are defined over a small number ofarguments); in other words, we do not know in advance, whether an argument will eventually be defended; this alsoexplains why we need four colors, whereas the number of labels is usually three. Nonetheless, known results about relationsbetween labelings for different semantics might help us in extending our algorithms to other semantics, which is indeed amajor topic for future work.Further ongoing and future work is as follows:• We plan to adapt our algorithms to other semantics, such as complete, stable, stage, and semi-stable. As we have alreadymentioned, we expect no major obstacles in extending the methods developed here to such other semantics.36W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–37• Another important aspect of future work is to analyze if typical argumentation scenarios naturally lead to AFs of lowtree-width. Note that graphs containing big cliques have high tree-width. However, for argumentation scenarios wewould rather expect graphs with small cliques or cycles, which are harmless as far as the tree-width is concerned.• A first prototype system which implements the algorithms from this paper is available underwww.dbai.tuwien.ac.at/research/project/argumentation/dynpartix.In recent work [25], we compared this implementation with existing systems, for instance, the ASPARTIX system [29]which relies on reduction to logic programs. The experiments show that the new dynpartix system performs well forinstances of low tree-width. Moreover, compared to the ASPARTIX the size of the instance is not of high influence thusreflecting the theoretical run-time analysis given in this paper. Further advances in the dynpartix system have to bemade in order to be competitive on arbitrary instances where we cannot expect low tree-width.AcknowledgementsWe thank the anonymous referees of the preceding KR 2010 paper and of the current paper for their detailed reviewsand many helpful comments.References[1] E. Amir, Approximation algorithms for treewidth, Algorithmica 56 (4) (2010) 448–479.[2] J. Barát, Directed path-width and monotonicity in digraph searching, Graphs Combin. 22 (2) (2006) 161–172.[3] P. Baroni, P.E. Dunne, M. Giacomin, On extension counting problems in argumentation frameworks, in: P. Baroni, F. Cerutti, M. Giacomin, G.R. Simari(Eds.), Proceedings of the 3rd Conference on Computational Models of Argument (COMMA’10), in: Frontiers in Artificial Intelligence and Applications,vol. 216, IOS Press, 2010, pp. 63–74.[4] P. Baroni, M. Giacomin, Semantics of abstract argument systems, in: I. Rahwan, G. Simari (Eds.), Argumentation in Artificial Intelligence, Springer, 2009,pp. 25–44.[5] P. Baroni, M. Giacomin, G. Guida, SCC-recursiveness: A general schema for argumentation semantics, Artificial Intelligence 168 (1–2) (2005) 162–210.[6] D. Berwanger, A. Dawar, P. Hunter, S. Kreutzer, DAG-width and parity games, in: Proceedings of the 23rd Annual Symposium on Theoretical Aspects ofComputer Science (STACS 2006), 2006, pp. 524–536.[7] H.L. Bodlaender, A linear-time algorithm for finding tree-decompositions of small treewidth, SIAM J. Comput. 25 (6) (1996) 1305–1317.[8] H.L. Bodlaender, A.M.C.A. Koster, Treewidth computations. I: Upper bounds, Inform. and Comput. 208 (2010) 259–275.[9] H.L. Bodlaender, A.M.C.A. Koster, Safe separators for treewidth, Discrete Math. 306 (3) (2006) 337–350.[10] M. Caminada, Semi-stable semantics, in: P.E. Dunne, T.J.M. Bench-Capon (Eds.), Proceedings of the 1st Conference on Computational Models of Argu-ment (COMMA’06), in: Frontiers in Artificial Intelligence and Applications, vol. 144, IOS Press, 2006, pp. 121–130.[11] M. Caminada, D.M. Gabbay, A logical account of formal argumentation, Studia Logica 93 (2–3) (2009) 109–145.[12] S. Coste-Marquis, C. Devred, P. Marquis, Symmetric argumentation frameworks, in: L. Godo (Ed.), Proceedings of the 8th European Conference onSymbolic and Quantitative Approaches to Reasoning with Uncertainty (ECSQARU 2005), in: LNCS, vol. 3571, Springer, 2005, pp. 317–328.[13] B. Courcelle, The monadic second-order logic of graphs. I. Recognizable sets of finite graphs, Inform. and Comput. 85 (1) (1990) 12–75.[14] B. Courcelle, J. Engelfriet, G. Rozenberg, Handle-rewriting hypergraph grammars, J. Comput. System Sci. 46 (2) (1993) 218–270.[15] B. Courcelle, J.A. Makowsky, U. Rotics, Linear time solvable optimization problems on graphs of bounded clique-width, Theory Comput. Syst. 33 (2)(2000) 125–150.[16] E.D. Demaine, F.V. Fomin, M.T. Hajiaghayi, D.M. Thilikos, Subexponential parameterized algorithms on bounded-genus graphs and h-minor-free graphs,J. ACM 52 (6) (2005) 866–893.[17] Y. Dimopoulos, A. Torres, Graph theoretical structures in logic programs and default theories, Theoret. Comput. Sci. 170 (1–2) (1996) 209–244.[18] J. Dix, S. Parsons, H. Prakken, G.R. Simari, Research challenges for argumentation, Comput. Sci. Res. Develop. 23 (1) (2009) 27–34.[19] S. Doutre, J. Mengin, Preferred extensions of argumentation frameworks: Query answering and computation, in: R. Goré, A. Leitsch, T. Nipkow (Eds.),Proceedings of the 1st International Joint Conference on Automated Reasoning (IJCAR 2001), in: LNCS, vol. 2083, Springer, 2001, pp. 272–288.[20] P.M. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, ArtificialIntelligence 77 (2) (1995) 321–358.[21] P.M. Dung, P. Mancarella, F. Toni, Computing ideal sceptical argumentation, Artificial Intelligence 171 (10–15) (2007) 642–674.[22] P.E. Dunne, Computational properties of argument systems satisfying graph-theoretic constraints, Artificial Intelligence 171 (10–15) (2007) 701–729.[23] P.E. Dunne, The computational complexity of ideal semantics, Artificial Intelligence 173 (18) (2009) 1559–1591.[24] P.E. Dunne, T.J.M. Bench-Capon, Coherence in finite argument systems, Artificial Intelligence 141 (1–2) (2002) 187–203.[25] W. Dvorák, M. Morak, C. Nopp, S. Woltran, dynPARTIX – A dynamic programming reasoner for abstract argumentation, CoRR (2011), arXiv:1108.4804[cs.AI].[26] W. Dvoˇrák, S. Woltran, Complexity of semi-stable and stage semantics in argumentation frameworks, Inform. Process. Lett. 110 (11) (2010) 425–430.[27] W. Dvoˇrák, S. Szeider, S. Woltran, Reasoning in argumentation frameworks of bounded clique-width, in: P. Baroni, F. Cerutti, M. Giacomin, G.R. Simari(Eds.), Proceedings of the 3rd Conference on Computational Models of Argument (COMMA’10), in: Frontiers in Artificial Intelligence and Applications,vol. 216, IOS Press, 2010, pp. 219–230.[28] L.C. Eggan, Transition graphs and the star height of regular events, Michigan Math. J. 10 (1963) 385–397.[29] U. Egly, S.A. Gaggl, S. Woltran, Answer-set programming encodings for argumentation frameworks, Argum. Comput. 1 (2) (2010) 147–177.[30] J. Flum, M. Grohe, Parameterized Complexity Theory, Texts in Theoretical Computer Science, Springer, 2006.[31] H. Gruber, Digraph complexity measures and applications in formal language theory, in: Proceedings of the 4th Workshop on Mathematical andEngineering Methods in Computer Science (MEMICS 2008), 2008, pp. 60–67.[32] T. Hammerl, N. Musliu, Ant colony optimization for tree decompositions, in: EvoCOP, 2010, pp. 95–106.[33] P. Hunter, S. Kreutzer, Digraph measures: Kelly decompositions, games, and orderings, Theoret. Comput. Sci. 399 (3) (2008) 206–219.[34] M. Jakl, R. Pichler, S. Woltran, Answer-set programming with bounded treewidth, in: Proceedings of the 21st International Joint Conference on ArtificialIntelligence (IJCAI 2009), 2009, pp. 816–822.[35] T. Johnson, N. Robertson, P.D. Seymour, R. Thomas, Directed tree-width, J. Combin. Theory Ser. B 82 (1) (2001) 138–154.W. Dvoˇrák et al. / Artificial Intelligence 186 (2012) 1–3737[36] K. Kask, A. Gelfand, L. Otten, R. Dechter, Pushing the power of stochastic greedy ordering schemes for inference in graphical models, in: Proceedingsof the Twenty-Fifth Conference on Artificial Intelligence (AAAI-11), 2011.[37] T. Kloks, Treewidth, Computations and Approximations, Lecture Notes in Computer Science, vol. 842, Springer, 1994.[38] S. Modgil, M. Caminada, Proof theories and algorithms for abstract argumentation frameworks, in: I. Rahwan, G. Simari (Eds.), Argumentation inArtificial Intelligence, Springer, 2009, pp. 105–129.[39] N. Musliu, An iterative heuristic algorithm for tree decomposition, in: Recent Advances in Evolutionary Computation for Combinatorial Optimization,in: Studies in Computational Intelligence, vol. 153, Springer, 2008, pp. 133–150.[40] N. Robertson, P.D. Seymour, Graph minors. II. Algorithmic aspects of tree-width, J. Algorithms 7 (3) (1986) 309–322.[41] L.G. Valiant, The complexity of enumeration and reliability problems, SIAM J. Comput. 8 (3) (1979) 410–421.[42] F. van den Eijkhof, H.L. Bodlaender, A.M.C.A. Koster, Safe reduction rules for weighted treewidth, Algorithmica 47 (2) (2007) 139–158.[43] B. Verheij, Two approaches to dialectical argumentation: Admissible sets and argumentation stages, in: J. Meyer, L. van der Gaag (Eds.), Proceedings ofthe 8th Dutch Conference on Artificial Intelligence (NAIC’96), 1996, pp. 357–368.