Artificial Intelligence 175 (2011) 1053–1091Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintComputational techniques for a simple theory of conditional preferencesNic Wilson∗Cork Constraint Computation Centre, Department of Computer Science, University College Cork, Cork, Irelanda r t i c l ei n f oa b s t r a c tA simple logic of conditional preferences is defined, with a language that allows thecompact representation of certain kinds of conditional preference statements, a semanticsand a proof theory. CP-nets and TCP-nets can be mapped into this logic, and the semanticsand proof theory generalise those of CP-nets and TCP-nets. The system can also expresspreferences of a lexicographic kind. The paper derives various sufficient conditions for a setof conditional preferences to be consistent, along with algorithmic techniques for checkingsuch conditions and hence confirming consistency. These techniques can also be used fortotally ordering outcomes in a way that is consistent with the set of preferences, and theyare further developed to give an approach to the problem of constrained optimisation forconditional preferences.© 2010 Elsevier B.V. All rights reserved.Article history:Received 28 February 2009Received in revised form 9 August 2010Accepted 9 August 2010Available online 2 December 2010Keywords:Conditional preferencesComparative preferencesCeteris paribus preferencesCP-netsTCP-netsConstrained optimisationLexicographic preferences1. Introduction(cid:3)(cid:3), where x, xThe formalism CP-nets [3,4] is designed for compactly expressing conditional comparative preferences in multivariateproblems. A CP-net involves statements of the form: u : x > xare values of a variable X and u is an assignmentto a set of variables U (called the parents of X ). The interpretation is that, given u, x is (strictly) preferred to x, all else(cid:3)being equal (ceteris paribus); that is, for all assignments s to the other variables S, sux is preferred to sux, where e.g., suxis the outcome (complete assignment) α such that α( X) = x, α(U ) = u and α(S) = s. The statement therefore compactlyrepresents exponentially many preferences between outcomes. This is a conditional preference, since the preference betweenvalues of X is conditional on the values of other variables U . It represents comparative preferences, in that the preferencestatements relate directly to the ordering between outcomes; this is in contrast to many theories of preference whichassign some form of grade to outcomes, and outcomes are compared by comparing their grades. Comparative preferencestatements can be easier to reliably elicit: often it is easier to judge that one alternative is preferred to another than it is toallocate particular grades of preference to the alternatives.(cid:3)Another key feature of CP-nets and related languages is the ceteris paribus aspect of the interpretation. If someone tellsus they’d prefer a green car to a white car, they wouldn’t usually mean that they’d prefer any green car to any white car;a ceteris paribus interpretation, that any green car is preferred to a car which is similar except being white, seems muchmore natural. However, this will tend to lead to quite weak inferences, and a user will sometimes want to express muchstronger statements such as those of the form: x is preferred to xirrespective of the values of other variables, where the variableX is the most important variable, and, for example, xrepresents a value that should be avoided if at all possible.(cid:3)(cid:3)This paper develops a formalism along similar lines to CP-nets, but where a richer language of preference statementscan be expressed: stronger conditional preference statements as well as the usual CP-nets ceteris paribus statements. The* Tel.: +353 21 4205954, fax: +353 21 4205369.E-mail address: n.wilson@4c.ucc.ie.0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.11.0181054N. Wilson / Artificial Intelligence 175 (2011) 1053–1091(cid:3)to W and assignments t to S − W , tuxw is preferred to tux(cid:3)[W ] (where W is a subset of S), which represents that for all assign-language consists of statements of the form u : x > x(cid:3)ments w, w. So, given u and any t, x is preferred to xirrespective of the values of W . CP-nets ceteris paribus statements are represented by such statements with W = ∅, and the(cid:3)[V − { X}], where V is the setstrong conditional preference statement in the previous paragraph corresponds to (cid:5) : x > xof all variables. As in CP-nets, and their extension TCP-nets [6,8], this is a compact representation: each statement typicallycorresponds to many preferences between outcomes.w(cid:3)(cid:3)The next section introduces the new formalism, which can be viewed as a simple logic of conditional preferences. A cp-theory Γ has an associated preference relation >Γ on outcomes; Γ can be considered to be a compact representation of >Γ .A semantics is given and also a complete proof theory, based on ‘swapping sequences’, which is a natural generalisation offlipping sequences in CP-nets and TCP-nets. Section 3 examines the relative expressivity of the language as compared withCP-nets. It shows how CP-net orderings (Section 3.1) and TCP-net orderings (Section 3.2) can be represented within thelanguage; however, this stronger kind of preference statement, which can be used, for example, to construct a lexicographicorder on outcomes, is not expressible within the languages of CP-nets or TCP-nets (see Sections 3.3 and 3.4). Section 3.5illustrates that the ceteris paribus statements of CP-nets tend to be rather weak, by showing how hard it is for a CP-net togenerate a total order on outcomes.Sections 4, 5, 6 and 7, are all concerned with the inter-related topics of determining consistency of a cp-theory, totallyordering sets of outcomes, and constrained optimisation. Most of the work on CP-nets and TCP-nets has assumed a verystrong acyclicity property on the variables (though see [12,11]); here we generally make much weaker assumptions, whichis desirable since natural sets of conditional preference statements can easily fail to be acyclic in this sense. A necessarycondition for consistency is derived, “local consistency” (Section 4.1), and some sufficient conditions; determining whetherthese conditions hold is much less hard than determining consistency.A cp-theory is consistent if and only if there exists a strict total order on outcomes that satisfies it. We focus on aparticular kind of strict total order: one generated by a complete search tree (or “cs-tree”, see Section 4.2), as used inbacktracking search for solutions of a constraint satisfaction problem; the associated strict total order is the order in whichoutcomes are visited by such a search tree. We derive various sufficient conditions for a cs-tree to satisfy a cp-theory. Ifwe can show that there exists a cs-tree satisfying a cp-theory Γ , then we have proved that Γ is consistent. Furthermore,we can use such a satisfying cs-tree for totally ordering sets of outcomes, and in a constrained optimisation algorithm(Section 4.4), making use of an upper approximation of the preference relation, i.e., a relation on outcomes that extends thepreference relation.For the fully acyclic case, i.e., when the graph formed by dependencies and importance is acyclic, defining a satisfyingcs-tree is straightforward, as shown in Section 5; this implies that Γ is consistent if and only if it is locally consistent,with the latter condition often being very easy to check. For more general cases, the situation is more complicated, and inSections 6 and 7 we derive more complex methods for constructing satisfying cs-trees. Section 6 considers weaker forms ofacyclicity for cp-theories, that we call strong conditional acyclicity (Section 6.1) and cuc-acyclicity (Section 6.2), and whichare sufficient conditions for a cp-theory to be consistent. A polynomial upper approximation is derived for cuc-acyclic cp-theories.Proving consistency of a cp-theory by explicitly giving a cs-tree that satisfies the cp-theory will typically not be feasible,since the cs-tree is an exponentially large object. However, cs-trees can be defined in a compact way based on implicitrepresentations of the variable and value orderings; defining the value ordering is easy, given that the cp-theory is locallyconsistent. Section 7 defines a compact computational structure and associated techniques for defining the variable order-ings of a cs-tree satisfying the cp-theory; this can be used for confirming consistency, ordering outcomes and constrainedoptimisation.Section 8 discusses related work, Section 9 concludes, and Appendix A contains most of the proofs.2. A logic of conditional preferencesIn this section, a simple logic of conditional preferences is defined, with a language, semantics and a kind of prooftheory. As we will see in Sections 3.1 and 3.2, CP-nets and TCP-nets can be expressed within this language. The logic has asomewhat restrictive language, but the restrictions entail some nice properties, generalising properties of CP-nets.After giving some basic definitions of ordering relations in Section 2.1, we define cp-theories and their associated pref-erence relations in Section 2.2. A semantics (Section 2.3) and a proof theory (Section 2.4) are defined, with a completenessresult (Theorem 1).2.1. Ordering relationsIn this section we give some basic definitions and properties of ordering relations that will be used throughout thepaper.A binary relation (cid:6) on a set Ω is defined to be a subset of Ω × Ω ; the notations “(a, b) ∈ (cid:6)” and “a (cid:6) b” are usedinterchangeably. Since binary relations are sets, we can talk about the intersection and union of them, and containment ofone by another. So, in particular, if (cid:6) and (cid:6)(cid:3)holds if and only if a (cid:6) b impliesb. We may also say in this case that (cid:6)(cid:3)a (cid:6)(cid:3)are (binary) relations on Ω then (cid:6) ⊆ (cid:6)(cid:3)extends (cid:6).contains (cid:6), or (cid:6)(cid:3)N. Wilson / Artificial Intelligence 175 (2011) 1053–10911055Let (cid:6) be a binary relation on a set Ω . (cid:6) is said to be reflexive if a (cid:6) a for all a ∈ Ω . It is said to be irreflexive if for alla ∈ Ω it is not the case that a (cid:6) a. Relation (cid:6) is said to be transitive if for all a, b, c ∈ Ω , if a (cid:6) b and b (cid:6) c both hold thena (cid:6) c holds. For any relation (cid:6), there exists a unique (set-wise) minimal transitive relation R containing (cid:6) (which is equalto the intersection of all transitive relations on Ω containing (cid:6)). R is known as the transitive closure of (cid:6).Irreflexive relation (cid:6) is said to be acyclic if its transitive closure is irreflexive, i.e., if there exists no cycle a (cid:6) a(cid:3)(cid:3) (cid:6)· · · (cid:6) a. Relation (cid:6) is said to be a strict partial order if it is transitive and irreflexive. A strict partial order is therefore acyclic.A strict total order (cid:6) is a strict partial order such that for all different a, b ∈ Ω either a (cid:6) b holds or b (cid:6) a holds.(cid:3) (cid:6) aWe summarise some well-known properties of ordering relations (e.g., part (ii) generalised to infinite sets is Szpilrajn’sExtension Theorem [25]).Lemma 1. Let (cid:6) be a binary relation on finite set Ω . Then the following properties hold.(i) Suppose that (cid:6) is a strict partial order on Ω , and that α, β ∈ Ω are such that it is not the case that α (cid:6) β. Then (cid:6) ∪ {(β, α)} is(ii) If (cid:6) is a strict partial order then it can be extended to a strict total order, that is, there exists some strict total order (cid:6)(cid:3)on Ω withacyclic.(cid:6) ⊆ (cid:6)(cid:3)(i.e., α (cid:6) β ⇒ α (cid:6)(cid:3) β).(iii) If (cid:6) is irreflexive and acyclic then it can be extended to a strict total order on Ω .(iv) Suppose that (cid:6) is irreflexive. Then (cid:6) is acyclic if and only if its transitive closure is irreflexive if and only if there exists a strict totalordering extending it.(v) If (cid:6) is a strict partial order then (cid:6) is equal to the intersection of all strict total orders extending it.2.2. cp-theories and their associated preference relationsIn this section we define a formalism for compactly expressing comparative preferences. Before defining cp-theories, wefirst introduce our notation for outcomes and assignments.Variables, tuples and outcomes.of X . For subset of variables U ⊆ V , we use the notation U =to U . Formally, U is the set of functions on U which, for each X ∈ U , assign a value of X to variable X .1Let V be a set of variables; for each X ∈ V let Domain( X) be the set of possible valuesX∈U Domain( X) to represent the set of possible assignments(cid:2)The assignment to the empty set of variables is written (cid:5). A complete tuple/assignment or outcome is an element of V , i.e.,an assignment to all the variables. Let a ∈ A be an assignment to variables A, and let u ∈ U be an assignment to variablesU ⊆ A ⊆ V . We may write a |(cid:11) u to mean that a projected to U gives u, which can also be written as a(U ) = u. We thenalso say that a extends u.2.2.1. cp-theories(cid:3)= xFor set of variables V , the language LV (abbreviated to L) consists of all statements of the form u : x > xis an assignment to a set of variables U ⊆ V (i.e., u ∈ U ), x, x(cid:3)x and x(cid:3)may write uϕ = u, U ϕ = U , xϕ = x, xϕcorrespond to different values of X ) and W is some subset of V − U − { X}. If ϕ is the statement u : x > x, W ϕ = W and Tϕ = V − ({ X} ∪ U ∪ W ).(cid:3)[W ], where u(cid:3) ∈ X are different assignments to some variable X /∈ U (and so(cid:3)[W ], weSubsets of L are called conditional preference theories or cp-theories (on V ). For ϕ = u : x > x(cid:3)pairs of outcomes {(tuxw, tuxα over β, and ϕ is intended as a compact representation of the preference information ϕ∗(cid:3)given u and any t, x is preferred to xdefine Γ ∗ =ϕ∈Γ ϕ∗natural to define order >Γ , induced on V by Γ , to be the transitive closure of Γ ∗be represented in terms of statements u : x > xone variable.(cid:3)[W ], let ϕ∗be the set ofare intended to represent a preference for. Informally, ϕ represents that,, irrespective of the assignments to W . For conditional preference theory Γ ⊆ L,represents a set of preferences. We assume here that preferences are transitive, so it is then. In Section 3 it is shown that CP-nets can(cid:3)[W ] with W = ∅, and TCP-nets with statements with W containing at most(cid:3) ∈ W }. Such pairs (α, β) ∈ ϕ∗(cid:3)) : t ∈ Tϕ, w, w, so Γ ∗(cid:3)wConditional preference theories allow locally partially ordered preferences: we do not need to assume that we can elicita total order on the values of a variable given each assignment to its parents. This kind of representation of conditionalpreferences is very flexible as regards elicitation: we can reason with an arbitrary subset Γ of the language L, so we canaccept any conditional preference statements (of the appropriate form) that the agent is happy to give us. More statementscan be added later, and, because the logic is monotonic (i.e., Γ ⊆ (cid:7) implies >Γ ⊆ >(cid:7)), all of our previous deductions fromΓ will still hold, in particular whether one outcome is preferred to another.2.2.2. Example AI’m planning a holiday. I can either go next week (n) or later in the year (n). I’ve decided to go either to Oxford (o) orto Manchester (o), and I can either take the plane (p) or drive and take a car ferry (p). So, there are three variables, X1, X21 For variable X ∈ V , the elements of X , which can be written in the form X = a for some value a of X , are in one-to-one correspondence withDomain( X). We will usually slightly abuse notation, and refer to an element of X as a value of X , and refer to X as the domain of X .1056N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Fig. 1. The ordering of outcomes in Example A. For i = 2, . . . , 5, an edge from outcome α to outcome β is labelled with i if and only if preference statementϕi entails that α is preferred to β, i.e., iff (α, β) ∈ ϕ∗i . All four outcomes in the left-hand oval dominate, using ϕ1, all the other four outcomes. All the edgestogether form Γ ∗, and >Γ is the transitive closure of this set Γ ∗of orderings.and X3, where X1 = {n, n}, X2 = {o, o} and X3 = {p, p}. Firstly, I’d prefer to go next week irrespective of the choices of theother variables, as I could do with a break soon. This can be represented by statement ϕ1 which equals (cid:5) : n > n[{ X2, X3}].This represents a set ϕ∗1 of pairs of outcomes (nw 1, nw 2), where w 1 and w 2 are both arbitrary assignments to the set ofvariables { X2, X3}; e.g., setting w 1 = op and w 2 = op gives the pair (nop, nop) indicating the preference of nop over nop.ϕ1 is a compact way of representing the 16 pairs in ϕ∗1 . Secondly, all else being equal (ceteris paribus), I’d prefer to go toOxford rather than Manchester. We represent this by the statement ϕ2, which equals (cid:5) : o > o[∅]. This is an unconditionalceteris paribus statement. It represents set ϕ∗2 of pairs of outcomes (x1ox3, x1ox3) meaning outcome x1ox3 is preferred tox1ox3, where x1 is either value of X1 and x3 is either value of X3.My preferences on variable X3 are conditional. I’d prefer to fly rather than drive unless I go later in the year toManchester, when the weather will be warmer and a car would be useful for touring around. This can be representedby conditional preference statements ϕ3, ϕ4 and ϕ5 defined as follows. ϕ3 is n : p > p[∅], and ϕ4 is o : p > p[∅]. ϕ5 is5 which consists of the single preference of nop over nop, i.e., ϕ∗no : p > p[∅], representing ϕ∗Let Γ = {ϕ1, . . . , ϕ5}. The statement ϕ1 cannot be represented in a CP-net on V = { X1, X2, X3}. The others all canas they involve empty W . The induced partial ordering >Γ on outcomes can be shown to be the transitive closure of:nop >Γ {nop, nop} >Γ nop >Γ nop >Γ nop >Γ nop >Γ nop, so that >Γ is almost a total order, with only the pair ofoutcomes nop and nop not being ordered (see Fig. 1).= {(nop, nop)}.52.2.3. Graphs H(Γ ) and G(Γ ) on V , and fully acyclic cp-theoriesIn the paper we will define several kinds of directed graph on the set of variables, and weDirected graphs notation.introduce the following notation. For S, T ⊆ V , define S → T to be the set of edges {( X, Y ): X ∈ S, Y ∈ T }. In addition, if Sor T is a singleton set, then we may omit the set brackets, abbreviating, e.g., S → { X} to S → X .Let Γ be a cp-theory over set of variables V . We define a pair of binary relations on V , which are considered as directedgraphs.The dependency graph H(Γ ) consists of edges U ϕ → Xϕ for all ϕ in Γ . In other words, H(Γ ) consists of all pairs ofthe form (Y , Xϕ), where ϕ ∈ Γ and Y ∈ U ϕ . H(Γ ) contains edge (Y , X) if and only if there is some conditional preferencestatement ϕ ∈ Γ that makes the preferences for X conditional on Y . H(Γ ) thus encodes dependency information. Givenfixed Γ , and variable X ∈ V , we will sometimes write U X to mean the parents of variable X with respect to H(Γ ), i.e., theset of variables Y with (Y , X) ∈ H(Γ ). U X is the set of variables that the preference for X can depend on.Define G(Γ ) to contain U ϕ → Xϕ and Xϕ → W ϕ for all ϕ ∈ Γ , i.e., G(Γ ) =ϕ∈Γ ( Xϕ → W ϕ). G(Γ )is H(Γ ) with extra edges ( X, Z ) when there is some preference statement ϕ ∈ Γ representing a preference for values of Xirrespective of the value of Z , which implies that X is more important than Z in that context. G(Γ ) thus represents boththe dependency and the relative importance information.ϕ∈Γ (U ϕ → Xϕ) ∪(cid:3)(cid:3)We say that cp-theory Γ is fully acyclic if G(Γ ) is acyclic. Fully acyclic cp-theories will be studied further in Section 5.In the example it happens to be the case that both H(Γ ) and G(Γ ) are acyclic, and so Γ is fully acyclic: H(Γ ) ={( X1, X3), ( X2, X3)} and G(Γ ) equals the total order on variables, {( X1, X2), ( X1, X3), ( X2, X3)}. However, more generally,this need not be so. Suppose that some cp-theory Γ contains the following statements: “If I go later in the year to Oxford,then I’d prefer to drive than fly”, and “If I fly next week then I’d prefer to go to Manchester than Oxford”; H(Γ ) thencontains both ( X2, X3) and ( X3, X2). There is nothing unreasonable or inconsistent about this (in particular, because thepreferences are in disjoint contexts, the first regarding later in the year, the second regarding travelling next week).2.3. Semantic entailment for cp-theoriesIn this section, we define a semantics and the notion of consistency for cp-theories. We define models for L to be stricttotal orders on V , i.e., irreflexive transitive binary relations > on V such that for all α and β in V , with α (cid:13)= β, either α > βor β > α. For strict total order >, and conditional preference statement ϕ ∈ L, we say that > satisfies ϕ (> |(cid:11) ϕ) if > ⊇ ϕ∗.(cid:3)Therefore, if ϕ is the statement u : x > x.For cp-theory Γ ⊆ L we say that > satisfies Γ (> |(cid:11) Γ ) if > satisfies every element of Γ , which is if and only if > ⊇ Γ ∗(cid:3)[W ] then > satisfies ϕ if and only if for all t ∈ T and w, w(cid:3)(cid:3) ∈ W , tuxw > tuxw.We also then say that > is a model of Γ .N. Wilson / Artificial Intelligence 175 (2011) 1053–10911057Definition 1 (Semantic entailment). For Γ ⊆ L and ϕ ∈ L, we define the semantic entailment relation by Γ |(cid:11) ϕ if and onlyif > |(cid:11) ϕ for all > such that > |(cid:11) Γ . For α, β ∈ V we also say that Γ |(cid:11) (α, β) if α > β holds for all models > of Γ .Definition 2 (Consistency of a cp-theory). We say that cp-theory Γ is consistent if it has a model, i.e., if there exists a stricttotal order > with > |(cid:11) Γ .For Example A, consider the model > defined as the transitive closure of nop > nop > nop > nop > nop > nop >nop > nop. Total order > satisfies ϕ1 = (cid:5) : n > n[{ X2, X3}] because any outcome extending n is preferred to any outcomeextending n, i.e., α > β for any outcomes α and β with α( X1) = n and β( X1) = n. It can be checked that > satisfies eachstatement in Γ , and so satisfies Γ , i.e., > extends Γ ∗. This shows that Γ is consistent. Γ has one other model, whichdiffers from > only in how it orders outcomes nop and nop. Hence we have, for example, Γ |(cid:11) (nop, nop), but it is not thecase that Γ |(cid:11) (nop, nop), since there exists a model > of Γ with nop > nop, and nor do we have Γ |(cid:11) (nop, nop).The construction of semantic entailment relation |(cid:11) ensures that it is monotonic; in particular, if Γ ⊆ (cid:7) ⊆ L and Γ |(cid:11)(α, β) then (cid:7) |(cid:11) (α, β). The following lemma sums up some basic properties of semantic entailment.Lemma 2. Let Γ ⊆ L be a cp-theory over variables V .(i) Let > be a strict total order on V . Then > satisfies Γ if and only if > extends >Γ , i.e., > |(cid:11) Γ ⇐⇒ > ⊇ >Γ .(ii) The following four statements are equivalent: (a) Γ is consistent; (b) Γ ∗is acyclic; (c) >Γ is irreflexive; (d) >Γ is a strict partialorder.(iii) If Γ is consistent then >Γ is equal to the intersection of all strict total orders satisfying Γ , i.e., >Γ equals(iv) If Γ is consistent then Γ |(cid:11) (α, β) if and only if α >Γ β.(v) If Γ is consistent then Γ |(cid:11) ϕ if and only if >Γ ⊇ ϕ∗.(cid:4)>|(cid:11)Γ >.2.4. Proof theoryWe describe a proof theory for cp-theories, based on swapping sequences (which generalise flipping sequences for CP-nets[4]), and give a completeness result, relating the proof theory with the semantics.Definition 3 (Swapping sequences). Let α, β ∈ V be two outcomes. We say that there is a worsening swap from α to β for(cid:3)(cid:3)[W ]) ∈ Γ such that α |(cid:11) u, β |(cid:11) u, α( X) = x, β( X) = xcp-theory Γ if (α, β) ∈ Γ ∗,and α(Tϕ) = β(Tϕ ). We say that there is a worsening swapping sequence from α to β (for Γ ) if there exists a sequence α =α1, . . . , αl = β such that for each k = 1, . . . , l − 1, there is a worsening swap from αk to αk+1, i.e., (αk, αk+1) ∈ Γ ∗, i.e., iff there exists ϕ = (u : x > x.For instance, in Example A, there is a worsening swap (and hence a worsening swapping sequence) from nop to nop,1 . There is also a worsening swapping sequence from nop to nop, since there is a worsening swapsince (nop, nop) ∈ ϕ∗from nop to nop (using ϕ2), and a worsening swap from nop to nop (using ϕ5).Clearly, if there is a worsening swapping sequence from α to β then (α, β) is in the transitive closure >Γ of Γ ∗.with for each. We therefore have, using Lemma 2(ii) and (iv), the following result which is a soundnessthen there exists a sequence α(cid:3) = α1, . . . , αl = β(cid:3)Conversely, if (α(cid:3), β(cid:3)) is in the transitive closure of Γ ∗k = 1, . . . , l − 1, (αk, αk+1) ∈ Γ ∗and completeness result for worsening swapping sequences.Theorem 1 (Soundness and completeness for swapping sequences).2 Let Γ be a conditional preference theory on V and let α, β ∈ Vbe outcomes. Then(i) α >Γ β if and only if there exists a worsening swapping sequence for Γ from α to β;(ii) Γ is consistent if and only if the associated preference relation >Γ is irreflexive (which is if and only if Γ ∗(iii) if Γ is consistent then Γ |(cid:11) (α, β) ⇐⇒ α >Γ β, which is if and only if there exists a worsening swapping sequence for Γ fromis acyclic);α to β.3. Expressiveness, CP-nets, TCP-nets and lexicographic ordersThis section considers issues regarding the expressiveness of cp-theories, CP-nets and TCP-nets. It is shown in Section 3.1how to map a CP-net to a cp-theory with the same associated preference relation; Section 3.2 does the same for TCP-nets.2 An alternative to using strict total orders as models is to use total pre-orders (reflexive, transitive and complete binary relations), see Section 3 of [9].We can define total pre-order (cid:2) to satisfy Γ if (cid:2) ⊇ Γ ∗. Every Γ then has a model, in particular every Γ is satisfied by the total pre-order with α (cid:2) βfor all outcomes α and β. We can define relation |(cid:11)(cid:3)as follows: Γ |(cid:11)(cid:3) (α, β) if and only if α (cid:2) β holds for all total pre-orders (cid:2) satisfying Γ . This leadsto a fuller completeness result: Γ |(cid:11)(cid:3) (α, β) if and only if α >Γ β: see Theorem 1 of [33], and also Theorem 1 of [9].1058N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Lexicographic orders are considered in Section 3.3, where it is shown how they can be represented easily using a cp-theory,but not by CP-nets or TCP-nets. Lexicographic orders can be viewed as being composed of a set of a particular kind ofstrong preference statement where the choice of values of a variable dominate the assignments to a set of other (lessimportant) variables. Some results are presented in Section 3.4 which show that, these statements are not at all naturalfor CP-nets or TCP-nets. In Section 3.5 we show how hard it is to generate a total order on outcomes with purely ceterisparibus preferences; we show that for any number n there is essentially a unique acyclic CP-net on n Boolean variableswhose associated preference relation is a total order.3.1. Expressing CP-nets in the languageIn this section we show how CP-nets can be expressed as conditional preference theories, using statements u : x > xwith W = ∅. It is shown in Section 3.3 and Section 3.4 that the language is a good deal more expressive than CP-nets.A CP-net over V is defined (see [3] and especially Definitions 1, 2 and 3 of [4]) to be a pair N = (H, CT) where H isa (binary) relation on V (which is conventionally thought of as a directed graph) and CT is a function which assigns aconditional preference table to each variable X ∈ V . The conditional preference table CT( X) is defined to be a function whichassigns to each3 u ∈ PaH ( X) a strict total order4 (cid:6) XLet > be a strict total order on V . Let X be a variable and let u ∈ PaH ( X) be an assignment to the parents of X . LetT = V − PaH ( X) − { X}. > is said to satisfy (cid:6) X. Wesay that > satisfies CP-net N = (H, CT) if for all X ∈ V , and all u ∈ PaH ( X), > satisfies (cid:6) X= CT( X)(u)). CP-net Nis said to be satisfiable if there exists some > which satisfies N. There is a simple sufficient condition for satisfiability of aCP-net N: that its associated relation H is acyclic. We say that N is acyclic if its associated relation H is acyclic.holds for all t ∈ T and for all x, x(cid:3) ∈ X such that x (cid:6) X(cid:3)u if tux > tuxu (where (cid:6) Xu on X .(cid:3)u xuFor CP-net N define relation (cid:6)N on V as follows. For α, β ∈ V , α (cid:6)N β if and only if α > β for all total orders >(cid:3)[W ]satisfying N. Therefore, (cid:6)N is the intersection of all > satisfying N.Representing a CP-net N as a cp-theory(cid:3)[∅]): x, x(cid:3) ∈ X, x (cid:6) XFor variable X ∈ V and assignment u ∈ PaH ( X) to the parent variables,⊆ L be the set of statementsover all X ∈ V and{(u : x > xu ∈ PaH ( X). Note that the construction of ΓN is linear in the size of the conditional preference table. (If the domain ofvariable X is large, one might represent total order (cid:6) Xu ; the sub-relationcould then also be used in the definition of Γ X,uif and only if > satisfies(cid:6) Xu . So, > |(cid:11) ΓN if and only if > satisfies N. Therefore, ΓN is consistent if and only if N is satisfiable. We have:(cid:3)}. Let conditional preference theory ΓN be the union of sets Γ X,uu by a sub-relation whose transitive closure is (cid:6) X.) Now, for strict total order >, we have > |(cid:11) Γ X,uu xlet Γ X,uNNNNProposition 1. Let N be a CP-net, and ΓN ⊆ L (as defined above) be its associated conditional preference theory. Then N is satisfiableif and only if ΓN is consistent. If N is satisfiable, then >ΓN= (cid:6)N .Proof. The first part has already been shown. Now, suppose that N is satisfiable, and so ΓN is satisfiable. (cid:6)N is the inter-section of all > satisfying N, that is, the intersection of all > satisfying ΓN , which, by Lemma 2(iii), equals >ΓN . (cid:2)This shows that a CP-net can be represented within the language L, with the same associated preference order onoutcomes.3.2. Expressing TCP-nets within the languageIn this section we show how TCP-nets—a generalisation of CP-nets—can be represented using cp-theories. A TCP-net [8,6]on set of variables V can be considered as consisting of a directed graph H on V , a conditional preference table, a set ofi-arcs, and a set of ci-statements. For X ∈ V , let U X be PaH ( X), the set of parents of X in H , i.e., the set of variables Y suchthat (Y , X) ∈ H . A conditional preference table assigns to each X ∈ V and assignment u ∈ U X a strict partial order (cid:6) Xu onX , i.e., it partially orders the values of X . An i-arc is an ordered pair of different variables X and Y , which we write asX → Y . It is intended to represent that X is a much more important variable than Y . A ci-statement consists of an orderedpair of variables X and Y and an assignment s to some set of variables S X,Y ⊆ V − { X, Y }; such a statement is written hereas X →s Y . It is intended to represent that given s, X is much more important than Y . (It is assumed that Y /∈ U X andX /∈ U Y .)A strict partial order > on outcomes is said to satisfy the conditional preference table if for each X ∈ V and u ∈ U X it], where(cid:3)implies for all t ∈ T tux > tuxu ; strict partial order > satisfies (cid:6) Xu if [x (cid:6) X(cid:3)u xsatisfies the associated ordering (cid:6) XT = V − { X} − U X .3 PaH ( X), the parents of X with respect to H , is the set of all Y such that (Y , X) ∈ H .4 If we relax this assumption by allowing (cid:6)Xu to be a non-empty strict partial order then the results all still hold.N. Wilson / Artificial Intelligence 175 (2011) 1053–10911059x (cid:6) XGiven a TCP-net N, strict partial order > is said to satisfy an i-arc X → Y if rxy > rx(cid:3)r(U X ) x(cid:3)Given a TCP-net N, strict partial order > satisfies ci-statement X →s Y if rsxy > rsx(cid:3) ∈ Y , and for all assignments r to V − { X, Y }., and for all y, y(cid:3)y(cid:3) ∈ Y where u is rs restricted to U X .(cid:3)V − S X,Y − { X, Y }, all x, xsuch that x (cid:6) X(cid:3)u xand all y, y(cid:3)(cid:3)y(cid:3)holds for all x, xsuch thatholds for all assignments r toStrict partial order > on outcomes is said to satisfy a TCP-net if it satisfies the conditional preference table, every i-arcand every ci-statement.Define the TCP-net order on outcomes as follows: for TCP-net N, define >N on V by: for α, β ∈ V , α >N β if and only ifα > β for all strict partial orders > satisfying N.Therefore, >N is the intersection of all strict partial orders satisfying N. Lemma 1(v) then implies that >N is the inter-section of elements of J , where J is the set of strict total orders that extend some partial order satisfying N. The definitionsimmediately imply that if strict partial order > satisfies a TCP-net then any strict total order extending > also satisfies theJ equals the set of strict total orders satisfying N, and so, >N is equal to the intersection of all strict totalTCP-net. Hence,orders satisfying N. Therefore, α >N β if and only if α > β for all strict total orders > satisfying N.Representing TCP-nets orderings using cp-theories(cid:6) XLet N be a TCP-net as defined above. We will define a cp-theory ΓN that generates the same order on outcomes.(cid:3)Define Γcp ⊆ L to be the set of statements u : x > xu xu is part of the conditional preference table of N).For i-arc X → Y of N define Γ X→Y ⊆ L to be the set of statements u : x > x. Let Γi be the union of the Γ X→Y over all i-arcs X → Y of N.For ci-statement X →s Y define Γ X→s Y to be the set of statements qs : x > x(cid:3)[Y ] for all assignments q to U X − S X,Y and, where u is qs restricted to U X . Let Γci be the union of Γ X→s Y over all ci-statements X →s Y of N.(cid:3)[∅] over all X ∈ V , u ∈ U X , and x, x(cid:3)(cid:3)[Y ] such that u ∈ U X and x and x(cid:3) ∈ V such that x (cid:6) Xsuch that x (cid:6) Xare such(where(cid:3)u xFinally, define the cp-theory ΓN to be Γcp ∪ Γi ∪ Γci. These definitions easily lead to the following result.(cid:3)u xthat x (cid:6) X(cid:3)all x, xProposition 2. TCP-net N is satisfiable if and only if ΓN is consistent. If N is satisfiable, then >N = >ΓN .This means that cp-theories are more general than TCP-nets, in the sense that any TCP-net can be efficiently convertedinto a cp-theory which has the same preference relation on outcomes. The TCP-net order >N only differs from the corre-sponding cp-theory order >ΓN when N is not satisfiable; but in that case, the TCP-net order becomes trivial: >N is thecomplete relation V × V .As shown above, TCP-nets represent conditional preference statements ϕ with |W ϕ| = 0 or 1; they cannot directlyrepresent statements with larger W ϕ (and in many situations, one variable will be more important than each of a largeset of variables, so W ϕ can be large). It is not immediately obvious how much difference this makes: how much is lost by(cid:3)[{Y }] over all variables Y in W ? One can(cid:3)[W ]) by a set (cid:7) of statements u : x > xapproximating a statement ϕ = (u : x > xget a good idea of the answer to this by comparing the sizes of ϕ∗, which represent the direct consequences of theconditional preference statements. For example, with all binary (two-valued) variables, it can be shown that |(cid:7)∗|/|ϕ∗| =(cid:3)[W ] will tend to be a very poor one(k + 1)2unless W is small.−k, where k = |W |, so the TCP-style approximation to a statement u : x > xand (cid:7)∗Example B: This is a variation of the holiday example (Example A) in Section 2.2. To make the relationship between thevalues and variables clearer we use x1 instead of n for travelling next week, and x2 instead of o for Oxford, and x3 insteadof p for travelling by plane. As well as the decision regarding when, where and how I travel, I also have to decide whetherto take my expensive camera x4, or my cheaper one x4. This last choice is much less important than the others. So, thereare four variables, X1, X2, X3 and X4, where X1 = {x1, x1}, X2 = {x2, x2}, X3 = {x3, x3} and X4 = {x4, x4}.Firstly, I’d prefer to go next week irrespective of the choices of the other variables. This is represented by the followingpreference statement: (cid:5): x1 > x1[{ X2, X3, X4}]. This implies that outcome α is preferred to β whenever α( X1) = x1 andβ( X1) = x1, irrespective of what the other values of α and β are. It represents a strong kind of preference, but one that isnatural in many contexts. As we shall see, this cannot be represented in a CP-net or TCP-net.If I go next week I definitely want to fly, as I can’t face the long drive, which is represented by the preference statementx1 : x3 > x3[{ X2, X4}]. Also, I’d prefer to go to Oxford in that case: x1 : x2 > x2[{ X4}]. So, if I go next week, the choice of howI travel ( X3) is more important than the choice of where I go ( X2). Later in the year my preference for Oxford is irrespectiveof how I travel: x1 : x2 > x2[{ X3, X4}]. If I go later, I’d also prefer to drive than to fly (whether I go to Oxford or Manchester),x1 : x3 > x3[{ X4}], as it would then be useful having a car with me. If I fly I’d prefer to take my cheap camera, whereas if Idrive I’d rather take the better one: x3 : x4 > x4[∅] and x3 : x4 > x4[∅].Let Γ be this set of preference statements. Unlike in Example A, G(Γ ) is not acyclic, as it contains pairs ( X2, X3) and( X3, X2). Let α = x1x2x3x4 and β = x1x2x3x4, and let ϕ be the first preference statement, (cid:5) : x1 > x1[{ X2, X3, X4}]. Then(α, β) ∈ ϕ∗since α( X1) = x1 and β( X1) = x1. So, there is a worsening swap from α to β, and therefore α >Γ β. It can beseen that α and β are consecutive in the order >Γ , with no outcome γ such that α >Γ γ >Γ β.Since α and β differ on three variables, it can be seen that there exists no TCP-net N on V with >N equalling >Γ (seeLemma 3 below). Because >Γ happens in this case to be a total order this further implies that there exists no satisfiable1060N. Wilson / Artificial Intelligence 175 (2011) 1053–1091TCP-net N which satisfies these preferences, i.e., with >N ⊇ Γ ∗. This illustrates the fact that a statement such as ϕ isstrictly stronger than a CP-net statement (cid:5) : x1 > x1 along with three i-arcs X1 → X2, X1 → X3 and X1 → X4; with thelatter, the outcomes x1x2x3x4 and x1x2x3x4 would not be ordered by the TCP-net.3.3. Representing lexicographic ordersWe will show how to represent a lexicographic order with a cp-theory. For set of variables V , a lexicographic order onV involves an ordering X1, . . . , Xn of the variables V , and for each Xi a total order >i on the set of values Xi of Xi . Definerelation >lex as follows. For α, β ∈ V , α >lex β if and only if α (cid:13)= β and α( Xi) >i β( Xi), where Xi is the first variable (i.e.,with minimal i) such that α( Xi) (cid:13)= β( Xi). The lexicographic order >lex is easily seen to be a strict total order on V .The following proposition shows that lexicographic orders can be represented by conditional preference theories, i.e., forany lexicographic order >lex, there exists cp-theory Γ such that its associated order >Γ equals >lex.Proposition 3. For each variable Xi , let Γi be the set of all statements of the form (cid:5) : x > x(cid:3). Let Γ = Γ1 ∪ · · · ∪ Γn. Then the associated order >Γ equals >lex.that x >i x(cid:3)[{ Xi+1, . . . , Xn}], where x, x(cid:3) ∈ Xi are suchThe following lemma is useful for revealing limits to the expressivity of CP-nets and TCP-nets. We say that α covers βwith respect to a transitive relation (cid:6) on V if α (cid:6) β and there does not exist γ ∈ V with α (cid:6) γ (cid:6) β.Lemma 3.(i) Let Γ be a conditional preference theory. Suppose α covers β with respect to >Γ . Then there is a worsening swap from α to β.(ii) Let N be a CP-net. Suppose α covers β with respect to (cid:6)N . Then α and β differ on precisely one variable. In other words, thereexists X ∈ V with α( X) (cid:13)= β( X) and for all X(cid:3) ∈ V − { X}, α( X(cid:3)) = β( X(cid:3)).(iii) Let M be a TCP-net, with associated relation (cid:6)M . Suppose α covers β with respect to (cid:6)M . Then α and β differ either on onevariable or on two variables.All three parts follow easily from the appropriate completeness theorems for swapping/flipping sequences: Theorem 1,Section 2.4, for (i); Theorem 8 (the CP-nets completeness result for flipping sequences) of [4] for (ii); and for (iii), theTCP-nets completeness result: see Theorem 6 of [8].In Example A (Section 2.2.2), there are a pair of outcomes, nop and nop, which are consecutive in the preference order>Γ that differ on all three variables. Lemma 3 then implies that the preferences in this example cannot be represented bya CP-net or TCP-net, i.e., there’s no CP-net or TCP-net N on V with >N equal to >Γ .A consequence of Lemma 3 is that, except in some trivial cases, if N is a CP-net or a TCP-net, then (cid:6)N is never alexicographic order. This is because lexicographic orders on n variables include consecutive elements that differ on alln variables (assuming the domain of each variable has more than one element). To illustrate this, consider the case ofBoolean variables and the order on complete tuples being just the usual order of binary numbers. Then (1, 0, 0, . . . , 0) and(0, 1, 1, . . . , 1) are consecutive in the order, but they differ on all the variables. Therefore, by the lemma, the order cannotbe generated by a CP-net if n > 1 and the order cannot be generated by a TCP-net if n > 2. This leads to the following result(which also appears in Section 3.2 of [16]).Proposition 4. Let >lex be a lexicographic order (as defined above) on V , where the domain of each variables contains more than oneelement, i.e., for all X ∈ V , | X| > 1. Then (a) if |V | > 1, there exists no CP-net N on V with (cid:6)N = >lex; (b) if |V | > 2, there exists noTCP-net M on V with (cid:6)M = >lex.3.4. Representing stronger conditional preferencesIn this section we show how a strong kind of preference statement, of the sort that holds for a lexicographic order, canbe represented with a cp-theory.Lexicographic orders are a very special type of order, but the kind of statements they represent can be natural. Let (cid:6)be a strict partial order (i.e., a transitive irreflexive relation) on V . Let X ∈ V and W ⊆ V − { X} and let T = V − { X} − W ,so that { X}, W and T partition V . Let > X be a non-empty partial order on X , the set of assignments to variable X . Wesay that X (unconditionally) dominates W with respect to ((cid:6), > X ) if the following condition holds: for α, β ∈ V , α (cid:6) β holdswhenever α and β are such that: α( X) > X β( X) and α(T ) = β(T ). In other words, α is preferred to β if α and β agree onT and α is better than β on X .In particular, if X dominates W = V −{ X} with respect to ((cid:6), > X ), then a sufficient condition for α (cid:6) β is α( X) > X β( X).This is a stronger form of preference statement than ceteris paribus statements. It represents a situation where the value ofvariable X is much more important than the values of any other variable; we prefer any outcome that does better onvariable X .N. Wilson / Artificial Intelligence 175 (2011) 1053–10911061(cid:3)[W ]) : x > X xThis kind of condition is naturally represented within the language L. Let Θ be the set of preferences statements(cid:3)}. Then, if cp-theory Γ contains Θ , X dominates W with respect to (>Γ , > X ). Such statements{((cid:5) : x > xcan be used to represent a lexicographic order, as shown above in Proposition 3. In contrast, this type of variable domi-nance is not at all natural for CP-nets and TCP-nets, as the following results indicate. It is, however, easy to construct aconsistent cp-theory Γ that satisfies the hypotheses of the two propositions (e.g., Γ = Θ for the representation Θ above,or extensions of Θ , in particular, representing a lexicographic order).Proposition 5. Consider any consistent CP-net N on V = { X1, . . . , Xn} (n (cid:2) 2) such that X2 has no parents and | X2| > 1. Then for no(non-empty) >1 on X1 is it the case that X1 dominates { X2, . . . , Xn} with respect to ((cid:6)N , >1).In Example A, X1 dominates { X2, X3} with respect to (>Γ , >1), where n >1 n; also X2 has no parents. The propositionthen implies (without looking at the level of outcomes) that there’s no CP-net N on V with (cid:6)N = >Γ . It also implies thatthe same would hold if we were to change the preferences on X3 in any way.There is a similar result for TCP-nets:Proposition 6. Consider any consistent TCP-net M on V = { X1, . . . , Xn} (n (cid:2) 3) with total local orderings and such that X2 has noparents and X3 has no parents, | X2|, | X3| > 1. Then for no total order >1 on X1 is it the case that X1 dominates { X2, . . . , Xn} withrespect to ((cid:6)M , >1).3.5. Generating precisely a total order on outcomesWe finish Section 3 with an expressibility result illustrating how unusual it is for a CP-net to generate a total order ofoutcomes. It shows that once one removes the obvious symmetries concerned with variable and value ordering, there is aunique acyclic CP-net on a set V of Boolean variables that generates a total order of outcomes.This contrasts with the situation for conditional preference theories, where there are doubly exponential number5 oftotal orders > on V whose maximum element is (1, 1, . . . , 1) and which are equal to some >Γ , for cp-theory Γ such thatG(Γ ) is consistent with the variable ordering X1, . . . , Xn.Theorem 2. For any given value of n (cid:2) 1, there is a unique CP-net N on Boolean variables V = { X1, . . . , Xn} satisfying the followingproperties:(i) the CP-net order (cid:6)N is a strict total order of outcomes with maximum element (1, . . . , 1); and(ii) the variable ordering X1, X2, . . . , Xn is consistent with the relation H on V associated with N, i.e., ( X j, Xi) ∈ H implies j < i.We will show, furthermore, that H is maximally large: H = {( X j, Xi):is{ X1, . . . , Xi−1}. The conditional preference tables (when written out explicitly) are therefore of exponential size. They canbe expressed compactly as follows: for each i = 1, . . . , n, and assignment u to Pa( Xi), 1 (cid:6) Xiu 0 holds if and only if u (viewedas a sequence of Boolean values) contains an even number of zeros.j < i} so that the parents set Pa( Xi) of XiWe derive three auxiliary results to help prove this theorem. The first two prove that there is at most one ordering >on outcomes equalling (cid:6)N for some CP-net satisfying conditions (i) and (ii) in Theorem 2. The third result gives an explicitconstruction of such a CP-net.First we consider the case of n = 3, to illustrate the ideas behind the results.Example 1. Suppose that we’d like to construct an acyclic CP-net N on Boolean variables X1, X2 and X3 such that (cid:6)N isa total order. We can relabel the values so that (1, 1, 1) is the optimal outcome. Since N is acyclic, we can choose somevariable, which we relabel to being X3, which has no children. We can generate a CP-net Non variables X1 and X2 bydeleting from N the conditional preferences of X3. It can be seen that (cid:6)N being a total order implies that (cid:6)N(cid:3) is a totalorder (by deleting flips involving X3 from flipping sequences for N). Without loss of generality, let us assume that X1 hasno parents. Then we can see that Nmust be the CP-net with preferences 1 (cid:6) X1(cid:5) 0, and 1 (cid:6) X2X1=1 0, and 0 (cid:6) X2X1=0 1.Now, if outcomes for N, α and β, agree on X1 and X2 and differ on X3 then they must be consecutive in the totalorder. Otherwise, removing the flips changing X3 in a flipping sequence between α and β gives a flipping sequence in. Let α1, α2, . . . , α8Nbe the ordering of outcomes, so α1 = (1, 1, 1). The previous remark implies that (1, 1, 1) and (1, 1, 0) are consecutive, soα2 = (1, 1, 0). Now, α3 and α2 are consecutive, so there exists a worsening flip from α2 to α3, so they differ on preciselyfrom α({ X1, X2}) to β({ X1, X2}) = α({ X1, X2}), and hence a cycle, contradicting consistency of N(cid:3)(cid:3)(cid:3)(cid:3)5 It follows from Proposition 17 below in Section 5.2 that we can instead count the number of total orders equalling (cid:6)p(Γ ) for some cp-theory Γsatisfying these properties, since if >Γ is a total order then (cid:6)p(Γ ) equals >Γ , and if (cid:6)p(Γ ) is a total order then >Γ equals (cid:6)p(Γ ). For (cid:6)p(Γ ) to be a totalorder we just need that the transitive closure of G(Γ ) is a total order and all the local orderings (cid:6)Xα are total orderings. Xn can have parents { X1, . . . , Xn−1},and so there are a doubly exponential number (22n−1−1) of valid non-equivalent choices for the set of local orderings for Xn .1062N. Wilson / Artificial Intelligence 175 (2011) 1053–1091one variable. This means that α2( X3) = α3( X3) = 0. If we change the value of X3 in α3 to 1 then, by the earlier remark, weobtain an outcome consecutive with α3, which must be α4. Hence, α4( X3) = 1. Continuing this argument, the values of X3in α1, α2, . . . , α8 are 1, 0, 0, 1, 1, 0, 0, 1. Therefore, the ordering on outcomes is (1, 1, 1), (1, 1, 0), (1, 0, 0), (1, 0, 1), (0, 0, 1),(0, 0, 0), (0, 1, 0), (0, 1, 1).This kind of reasoning is generalised and formalised in Lemma 4 and its proof.Lemma 4. Let N be an acyclic CP-nets on Boolean variables V such that (cid:6)N is a strict total order on V . Let Z be a variable with nochildren, i.e., the conditional preferences of no variable are conditional on Z . List the elements V in decreasing order with respect to(cid:6)N as α1, α2, . . . , αK , where K = 2be the CP-net on variables V − {Z } formed by deleting the conditional preferences of Z .Then the following hold.. Let N|V |(cid:3)(a) (cid:6)N(cid:3) is a strict total order on V − {Z }.(b) If α, β ∈ V differ on V − {Z } then α (cid:6)N β if and only if α(V − {Z }) (cid:6)N(cid:3) β(V − {Z }).(c) If outcomes α and β differ on Z but agree on all other variables, then α and β are consecutive in (cid:6)N . Hence, for all j = 1, 2, . . . , K2 ,outcomes α2 j−1 and α2 j agree on V − {Z }.(d) Suppose that α1(Z ) = 1. Then the value of Z in the sequence α1, α2, . . . , αK follows the pattern: 1, 0, 0, 1, 1, 0, 0, 1, . . . , so thatfor l ∈ {1, 2, 3, 4}, and j = 0, 1, . . . , K4− 1, we have α4 j+l(Z ) = 1 if l = 1, 4, and α4 j+l(Z ) = 0 if l = 2, 3.Proposition 7 shows that there is at most one CP-net ordering satisfying the conditions of Theorem 2. Proposition 8defines such a CP-net, showing that there exists exactly one. Theorem 2 can then be proved using these two results.Proposition 7. Let n be any natural number, and let V = { X1, . . . , Xn} be a set of Boolean variables. There is at most one strict totalorder > on V with > equalling (cid:6)N for some CP-net N on V satisfying the pair of conditions:(i) the CP-net order (cid:6)N is a strict total order of outcomes with maximum element (1, . . . , 1);(ii) the variable ordering X1, X2, . . . , Xn is consistent with the relation H on V associated with N, i.e., ( X j, Xi) ∈ H implies j < i.Sketch of proof. The proof is by induction on n. Suppose that there are CP-nets, N1 and N2, on variables V = { X1, . . . , Xn}(cid:3)2 on variables { X1, . . . , Xn−1}.satisfying the conditions of the proposition. Eliminating variable Xn gives CP-nets NLemma 4(b), (c) and (d) show that (cid:6)with the following sequenceof values for variable Xn : 1, 0, 0, 1, 1, 0, 0, 1, . . . . Similarly, for (cid:6)N2 . By Lemma 4(a), (cid:6)are both strict total orders,so, by induction, are equal, and hence (cid:6)N1 and (cid:6)N2 are equal. (cid:2)(cid:3)1 and Ndetermines the total ordering (cid:6)N1 , by extending (cid:6)(cid:3)N1and (cid:6)(cid:3)2(cid:3)1(cid:3)1NNNContinuing Example 1, write assignment u to variables X1 and X2 as a pair of the Boolean values; for example, theassignment X1 = 1, X2 = 0 is abbreviated to (1, 0). It can be seen that if we use the following conditional preference tablefor X3 then we arrive at the total ordering of outcomes: 1 (cid:6) X3(0,1) 1. This argument canbe generalised to show that for any n, there exists a CP-net on n Boolean variables which totally orders the outcomes. Infact it can be seen that 1 (cid:6) Xiu 0 if and only if the tuple u contains an even number of zeros:(0,0) 0, and 0 (cid:6) X3(1,0) 1, 1 (cid:6) X3(1,1) 0, 0 (cid:6) X3Proposition 8. Let V be a set of variables, which we label as { X1, . . . , Xn}. Define a CP-net N as follows:(a) the graph H is defined to be ( X j, Xi) : 1 (cid:3) j < i (cid:3) n, so that the set U i of parents of variable Xi is equal to V i−1 = { X1, . . . , Xi−1};(b) for i = 1, . . . , n and u ∈ U i , the relation (cid:6) Xiu 0 if and only if the tuple u contains an even number of zeros, i.e.,u 1 if and only if the tuple u contains an odd number ofthere is an even number of variables X j in U i with u( X j) = 0. So, 0 (cid:6) Xizeros.u is defined by 1 (cid:6) XiThen (cid:6)N is a strict total order on V with maximum element (1, . . . , 1).Proof of Theorem 2. Let n be a natural number. Proposition 8 shows that there exists at least one CP-net N0 satisfying theconditions (i) and (ii) of the theorem. Suppose that N is any CP-net on V satisfying conditions (i) and (ii). Proposition 7implies that (cid:6)N equals (cid:6)N0 . For each variable Xi , the set of parents of Xi in N must be the same as the set of parents of Xiin N0, i.e., { X1, . . . , Xi−1}. This is because we can’t have more parents of Xi in N than in N0 without contradicting (ii), andin N0, the preference over Xi genuinely depends on each of these variables, so if we omit any X j from V i−1 we can’t getan equivalent conditional preference table. (1 (cid:6) Xiu 0 holds if and only if the tuple u contains an even number of zeros, soif we were to omit any variable from u, we can’t generate equivalent preferences.) Given the choice of parents, the relation(cid:6)N determines all the local relations (cid:6) Xiu , since we have x (cid:6) Xi, where t is any assignment to variablesu xV − (U ∪ { Xi}). This shows that N is actually equal to N0. (cid:2)(cid:3)(cid:3) ⇐⇒ tux (cid:6)N tuxN. Wilson / Artificial Intelligence 175 (2011) 1053–109110634. Determining consistency, totally ordering outcomes and constrained optimisationSection 4, as well as Sections 5, 6 and 7, are concerned with the three inter-related topics of determining consistency ofa cp-theory, totally ordering sets of outcomes, and constrained optimisation; these are described below.Determining consistency of a cp-theory Γ . Γ is consistent if and only if there exists some strict total order > extendingthe preference relation >Γ , which, by Theorem 1, is if and only if >Γ is acyclic. We focus on a particular kind of strict totalorder: one generated by a complete search tree (or “cs-tree”), as used in backtracking search for solutions of a constraintsatisfaction problem (CSP); the associated strict total order is the order in which outcomes are visited by such a search tree.For the fully acyclic case, when G(Γ ) is acyclic (see Section 2.2.3), testing consistency is relatively easy (see Section 5.1).More generally, the problem of determining consistency of a cp-theory is extremely hard, indeed PSPACE-complete: see[18], Theorem 3. We give a necessary (see Section 4.1) and some sufficient conditions (see Section 6) for consistency, thathave much lower complexity (see Proposition 11 in Section 4.1 and Proposition 24 in Section 6.5).Totally ordering sets of outcomes.It will often be the case that not all complete assignments are available. Suppose thatwe have a set Ω ⊆ V of possible outcomes which the user needs to choose between, and we have elicited their preferencesas a cp-theory Γ . We wish to display the outcomes in some order, showing them the best ones first. A basic requirementis that if α is preferred to β then α appears before β, since the user is more interested in outcome α than outcome β.Thus, we are concerned with the following task: given cp-theory Γ and subset Ω of outcomes, construct a total order onΩ which extends >Γ restricted to Ω .The set Ω of available outcomes might be very large; in particular it might be expressed implicitly as the set of solutionsof a constraint satisfaction problem. Then we won’t be able to display all of them, but just, say, some number K of them.This gives rise to the following related problem: Given a number K , generate outcomes α1, . . . , αK ∈ Ω such that for allj = 1, . . . , K , if β >Γ α j for some β ∈ Ω then β = αi for some i < j, i.e., if an element of Ω is preferred to α j then it occursbefore α j in the generated list of outcomes. cs-trees can be used for these total ordering tasks (see Sections 4.4, 5.1, and6.4).Optimisation. Given cp-theory Γ , we say that outcome α is optimal if there exists no outcome β that dominates it, i.e.,is such that β >Γ α. It can easily be seen that outcome α is optimal if and only if it is a solution of a particular constraintsatisfaction problem. This implies that checking whether an outcome is optimal or not can be performed very efficiently,and finding an optimal outcome can be solved using CSP technology. Let Ω be a set of outcomes. We say that outcomeα ∈ Ω is optimal in Ω if there exists no outcome β ∈ Ω such that β >Γ α. If Ω is represented as the set of solutions of aCSP then we refer to such a task as constrained optimisation.Given cp-theory Γ , we define an upper approximation (cid:16) to be a strict partial order containing the preference relation>Γ , and we say that it is a polynomial upper approximation if α (cid:16) β can be determined in polynomial time for anyoutcomes α and β (see Section 4.4). Specific polynomial upper approximations are defined in Sections 5.2, 6.3 and 7.6.We show how a polynomial upper approximation can be useful for finding a set of optimal outcomes of a constrainedoptimisation problem: by using a search tree to generate solutions in an order consistent with >Γ , and using an upperapproximation (cid:16) to eliminate outcomes which could be non-optimal in Ω . They can also be used to totally order a smallset Ω of outcomes: for each α, β ∈ Ω , we determine if α (cid:16) β holds, thus determining (cid:16) restricted to Ω , and choose atotal order on Ω compatible with this (see Section 4.5).This section (Section 4) describes the basic mathematical notions and approaches: we define a necessary condition forconsistency, called local consistency; we define cs-trees (complete search trees)—which can be used for showing consistencyof a cp-theory—and give some basic properties of them; we consider the problem of constrained optimisation and describeour general approach, based on cs-trees and upper approximations. Section 5 below considers the problems of determiningconsistency, and ordering outcomes for the fully acyclic case, and shows how a polynomial upper approximation can bedefined. In Sections 6 and 7 approaches for these tasks are derived for more general cp-theories.Section 4.1 defines the “local consistency” property; a cp-theory is not locally consistent if and only if there exists someoutcome α and some variable X such that there exists a worsening swapping (flipping) sequence from α to itself that justchanges variable X . Local consistency is thus a necessary condition for a cp-theory to be consistent, which can often bedetermined efficiently.Section 4.2 defines cs-trees and their associated strict total orders, and Section 4.3 gives a precise characterisation forwhen a cs-tree order satisfies a cp-theory. The cs-tree is a kind of lexicographic order where both the value and the variableorderings are conditional on the values of more important variables. Search trees have previously been used in the contextof CP-nets and TCP-nets, in particular, in [5] and [8]. Section 4.4 considers the problem of totally ordering a set of outcomesaccording to the preference ordering >Γ , which can be solved if one can construct a compact representation of a satisfyingcs-tree (see Sections 5.1, 6.4 and 7 below for such constructions) or, if the set is small, using an upper approximationof >Γ , i.e., a strict partial order containing >Γ (see Sections 5.2, 6.3 and 7.6, below for definitions of polynomial upperapproximations in different situations). Section 4.5 considers the problems of optimisation and constrained optimisation,showing that one can use a cs-tree and an upper approximation to generate some of the optimal solutions of a set ofconstraints.1064N. Wilson / Artificial Intelligence 175 (2011) 1053–10914.1. Local consistencyIn this section we consider a necessary condition for consistency, called local consistency. In certain cases, it’s clear thata cp-theory Γ is not consistent, by just looking at local conditions: if there’s a sequence of worsening swaps from someoutcome α to itself, which just changes the values of a single variable X . If this does not hold, then we say that Γ islocally consistent. As well as defining local consistency, the definition below introduces the local ordering (cid:6) Xa induced bythe cp-theory on the domain of variable X given assignment a.Definition 4 (Local consistency and local ordering (cid:6) XX ∈ V , set of variables A ⊆ V and assignment a ∈ A to A. Say that ordered pair (x, xthere exists some statement (u : x > x(cid:6) Xlocally consistent if (cid:6) Xa ). Fix conditional preference theory Γ on V , and consider some variable(cid:3)) of values of X is validated by a if(cid:3)[W ]) ∈ Γ such that a extends u (i.e., u is a projection of a). Define the local ordering(cid:3)) validated by a. We say that Γ isa ) on X to be the transitive closure of the set of all pairs (x, xa (Γ ) (abbreviated to (cid:6) Xα is irreflexive for all variables X and outcomes α.If Γ is not locally consistent then there exists outcome α, variable X and a sequence x1, . . . , xk of values of X withassociated statements in Γ , (ui : xi > xi+1[W i]), such that α |(cid:11) ui , and α( X) = x1 = xk. This gives a worsening swappingsequence from α to α (only involving changing variable X ), thus implying that Γ is not consistent, by Theorem 1. Therefore,local consistency is a necessary condition for consistency:Proposition 9. If cp-theory Γ is consistent then it is locally consistent.The set of statements Γ in Example A in Section 2.2.2 (and also Example B in Section 3.2) is easily seen to be locally5 equalling o : p > p[∅] then Γ would no longer be locally consistent as ϕ(cid:3)5α is notα p. Γ would no longer beconsistent. However, if ϕ5 were changed to ϕ(cid:3)and ϕ3 = (n : p > p[∅]) would give conflicting preferences for X3 under the conditions no. Let α = nop. Then (cid:6) X3α p (since (p, p) is validated by α using ϕ(cid:3)irreflexive since p (cid:6) X3consistent as >Γ is no longer irreflexive: we have nop >Γ nop >Γ nop so α >Γ α.α p using ϕ3, so p (cid:6) X35), and p (cid:6) X3Local ordering (cid:6) Xholds then x (cid:6) X(cid:3)b xa is monotonic with respect to a, i.e., if partial tuple b extends a then (cid:6) Xholds.b extends (cid:6) Xa , i.e., if x (cid:6) X(cid:3)a xClearly, relation (cid:6) Xa can be generated in polynomial time for a given tuple a and variable X , by selecting all ϕ in Γ with(cid:3)Xϕ = X and such that a(U ϕ) = uϕ , recording the associated pairs (xϕ, xϕ), and computing the transitive closure of this setof pairs of values of X .Unsurprisingly, the converse of Proposition 9 does not hold:Example 2. Let V = { X1, X2} with X1 = {x1, x1}, and X2 = {x2, x2}. Let Γ be the pair of statements (cid:5) : x1 > x1[{ X2}] and(cid:5) : x2 > x2[{ X1}], which is easily seen to be locally consistent (since there is no statement preferring x1 over x1, nor x2 overx2). However, we have x1x2 >Γ x1x2 because of the first statement, and x1x2 >Γ x1x2 because of the second statement, sox1x2 >Γ x1x2 and Γ is therefore inconsistent. For another example, see Example 1 of [18].The following lemma, which is important in Section 6.1, follows easily from the definitions (since (x, x(cid:3)) is validated by α). It states that the local ordering (cid:6) X(cid:3)) is validated byα is unchanged if one eliminates irrelevantα( A) if and only if (x, xvariables from α.Lemma 5. Let α be an outcome, let X ∈ V be a variable, and let A be a set of variables satisfying the following property: for all ϕ ∈ Γsuch that Xϕ = X , if α |(cid:11) uϕ then A ⊇ U ϕ . It follows that (cid:6) Xα( A).α=(cid:6) XFor X ∈ V , recall that U X = PaH(Γ )( X) is the set of parents of X with respect to H(Γ ) (see Section 2.2.3). Hence, Y ∈ U Xif and only if there exists ϕ ∈ Γ with Xϕ = X and U ϕ (cid:17) Y , so that U X =ϕ∈Γ, Xϕ = X U ϕ . Lemma 5 implies the followingresult, which shows that local consistency can be determined using just the local orderings based on the set of parents ofeach variable.(cid:3)Proposition 10. Γ is locally consistent if and only if for all X ∈ V and u ∈ U X , (cid:6) Xu is irreflexive.Proposition 10 shows that local consistency can be checked efficiently if all the parents sets U X are small: for each X(cid:3)) of values of X validated by u.and for each u ∈ U X , we compute (cid:6) Xu , by taking the transitive closure of all the pairs (x, xHence, if the sizes of the parents sets and the sizes of the domains are bounded by a constant, then determining localconsistency is polynomial.N. Wilson / Artificial Intelligence 175 (2011) 1053–10911065Fig. 2. A cs-tree σ over binary variables { X1, X2, X3}. For each body node r we include its associated variable Yr and the ordering (cid:6)r . The associatedordering >σ on outcomes is given by the ordering of leaf nodes (at the bottom), starting from the left, i.e., x1x2x3 >σ x1x2x3 >σ x1x2x3 >σ · · · >σ x1x2x3.Example 3. Consider the set Γ = {ϕ1, ϕ2, ϕ3, ϕ4, ϕ5} of preference statements on variables { X1, X2, X3}, which are those ofExample B with variable X4 deleted. ϕ1 equals (cid:5) : x1 > x1[{ X2, X3}]. ϕ2 = x1 : x3 > x3[{ X2}]; ϕ3 equals x1 : x2 > x2[∅]. ϕ4 =x1 : x2 > x2[{ X3}], and ϕ5 = x1 : x3 > x3[∅].It is clear, for any outcome α, that (cid:6) X1(cid:3)preference for x1 over x1, i.e. which is such that xϕ = x1 and xϕif and only if α( X1) = x1, and x3 (cid:6) X3which proves that for all outcomes α, (cid:6) X3α is irreflexive, since there is no preference statement ϕ in Γ that involves aα x3α x3 if and only if α( X1) = x1, and so, for no outcome α do we have both preferences,= x1. Similarly, for X2. Regarding X3, we have x3 (cid:6) X3α is irreflexive, and hence Γ is locally consistent.An alternative way of proving local consistency is to use Proposition 10. For X3 this involves considering the two possibleassignments to the set { X1} of parents of X3. We have (cid:6) X3x1= {(x3, x3)}, and (cid:6) X3x1= {(x3, x3)}.In general, determining local consistency is coNP-complete:Proposition 11. The problem of deciding whether a cp-theory Γ is locally consistent is coNP-complete.However, often checking local consistency will be easy; in particular, as discussed above, when the sets U X are small(where U X is the set of variables that variable X depends on), as in intended applications of CP-nets and TCP-nets, onecan efficiently construct each local ordering (cid:6) Xu explicitly, thus determining whether local consistency holds or not, usingProposition 10. (For CP-nets and TCP-nets, it is assumed that these local orderings (cid:6) Xu have already been computed, ordirectly elicited; they are also assumed to be strict partial orders, so local consistency is guaranteed.) To give anotherexample, when all the variables are binary (i.e., two-valued), local consistency can be determined in time proportional to|Γ |2|V | (assuming that the domain sizes of variables are bounded by a constant).4.2. cs-treesIn this section we describe complete search trees (cs-trees), and their associated total orderings over outcomes. In Sec-tions 4.3, 5, 6, and 7 we will show how under certain conditions a search tree ordering will satisfy a cp-theory, which leadsto methods for proving consistency of a cp-theory.A cs-tree (or “complete search tree”) is a rooted directed tree with its |V | leaves corresponding to outcomes (see Fig. 2).Associated with each non-leaf node r is a variable Y r , which is instantiated with a different value in each of the node’s|Y r| children, and also an ordering (cid:6)r of the values of Y r . So, a directed edge in the tree corresponds to an instantiation ofone of the variables. Paths in the tree from the root down to a leaf node correspond to sequential instantiations of all thevariables V .Definition 5 (cs-tree (“complete search tree”)). A cs-tree over variables V is defined to be a rooted directed tree, where nodesand edges have associated labels as defined below.Each directed edge e from node r to node ris associated with a variable Y e and a value ye of Y e (corresponding to the(cid:3)assignment Y e = ye ). We say that ris a child of r.Each node r has the following associated labels:(cid:3)(a) a set of variables Ar ⊆ V (the assigned variables, i.e., the variables assigned above that node in the cs-tree);(b) an assignment ar to variables Ar (corresponding to the assignments made above that node).1066N. Wilson / Artificial Intelligence 175 (2011) 1053–1091If a node has no children then we say that it is a leaf node; otherwise we say that the node is a body node. A node is a leafnode if and only if its associated set of variables Ar is equal to the whole set of variables V . If r is a body node then wealso associate the following two labels with it.(c) a variable Y r ∈ V − Ar (the next variable to be instantiated);(d) an ordering (cid:6)r on the domain Y r of Y r (the “value ordering” at that node).For leaf node r we define the associated leaf tuple to be (cid:18) Ar, ar(cid:19). For body node r we define the associated body tuple tobe (cid:18) Ar, ar, Y r, (cid:6)r(cid:19).The (unique) root node we write as r∗, and define Ar∗ to be the empty set, and hence we have ar∗ equals (cid:5), theassignment to the empty set.Body node r with associated variable Y r has |Y r| children, so has |Y r| edges coming from it. Each such edge e hasthen Ar(cid:3) = Ar ∪ {Y r}, and ar(cid:3) isassociated variable Y e = Y r and a different associated value yr . If e goes from node r to rthe tuple formed by extending ar with the assignment Y e = ye .(cid:3)Example 4. We define a search tree σ over binary-valued variables V = { X1, X2, X3}. This is illustrated in Fig. 2. The rootnode is at the top, and the eight leaf nodes are at the bottom. In the figure, we show, for each node r, the associatedvariable Y r , and, for body nodes, the local ordering (cid:6)r on the values of Y r (omitting the components Ar and ar ).The root node has associated tuple (cid:18)∅, (cid:5), X1, (x1, x1)(cid:19), so that X1 is the variable which is assigned at the root node,with ordering x1 (cid:6) x1. Below it, following the edge associated with the assignment X1 = x1, is the node with tuple(cid:18){ X1}, x1, X3, (x3, x3)(cid:19). The first component is the set of variables assigned above that node, i.e., { X1}.The bottom left node is the leaf node (cid:18){ X1, X2, X3}, x1x2x3(cid:19). The first component of this node is the set of variablesassigned in the path from the root to that node, which is always equal to V for a leaf node. The second component is theassignment to V along that path. Notice that the variable orderings vary within the cs-tree. For example, the leftmost pathin the tree has associated variable ordering X1, X3, X2, whereas the rightmost path has variable ordering X1, X2, X3. Alsothe local (value) orderings of a variable can be different in different nodes. For example, one node has ordering x3 (cid:6) x3,whilst two nodes have ordering x3 (cid:6) x3.We have the following properties of cs-trees:Lemma 6. Let σ be a cs-tree over variables V .• For each node r, ar is the set of assignments Y e = ye made in edges e on the path from the root to r.• For each outcome α there exists exactly one leaf node r with ar = α, so we can associate leaf nodes with outcomes. The set of leafnodes is therefore in one-to-one correspondence with the set V of outcomes.Definition 6 (Path to outcome). Let σ be a cs-tree over variables V , and let α be an element of V . The path (in σ ) to α isdefined to be the sequence of nodes along the directed path from the root node to the leaf node corresponding to α.∗The set of nodes in the path to α thus consists of all nodes r such that α extends ar . Write the path to α as r0, r1, . . . , rn,}, the set of variables instantiated in= α( Ari ). The path to α has an associated ordering of variables,where r0 = rnodes between ri and the root node. We also have arinamely, Y r0 , . . . , Y rn−1 . A cs-tree σ thus associates an ordering of V with any outcome α., the root node. Then for each i = 1, . . . , n, we have Ari= {Y r0 , . . . , Y ri−1Definition 7 (cs-tree node divides outcomes). Let σ be a cs-tree over variables V , and let α and β be elements of V . We saythat node r divides α and β if r is the last node in the path to α which is also in the path to β.Clearly, for any pair of different outcomes α and β, there exists a unique node in σ which divides α and β. We associatea strict total order >σ with cs-tree σ as follows:Definition 8 (cs-tree order on outcomes). Let σ be a cs-tree over variables V , and let α and β be elements of V . Defineα >σ β if and only if α (cid:13)= β and α(Y r) (cid:6)r β(Y r), where r is the node that divides α and β.In other words, we compare two outcomes by considering the lowest (deepest) node r that is above both of them, anduse the ordering (cid:6)r to compare them. If, as in Fig. 2, we draw the cs-tree σ with the directed edges pointing downwardsfrom the root, and the edges from a node r in the order (cid:6)r , with the best being leftmost, then α >σ β if and only if leafnode (cid:18)V , α(cid:19) appears to the left of (cid:18)V , β(cid:19). Similarly, suppose, in a depth-first search, we instantiate at each node r the bestvalue according to (cid:6)r first, and on backtracking, the values in the order (cid:6)r ; then α is reached before β if and only ifα >σ β. This means that it is very easy to generate the first K elements in the cs-tree order.N. Wilson / Artificial Intelligence 175 (2011) 1053–10911067Example 5. Consider the cs-tree σ in Fig. 2. To determine how σ orders outcomes x1x2x3 and x1x2x3, we start from theroot, and follow corresponding edges until we find the node that divides them. The root does not divide them because theyagree on its associated variable X1, each taking value x1. So, we then consider the node at the end of the x1 edge. This hasassociated variable X3. Since the two outcomes differ on X3, this is the node that divides them. Since the value ordering atthis node prefers x3 to x3 we have x1x2x3 >σ x1x2x3.The ordering >σ on outcomes is given by the ordering of leaf nodes. >σ is thus the transitive closure of the followingpreference comparisons: x1x2x3 >σ x1x2x3 >σ x1x2x3 >σ x1x2x3 >σ x1x2x3 >σ x1x2x3 >σ x1x2x3 >σ x1x2x3.Compact representations of cs-trees. To construct a cs-tree, for each node (starting at the root node) we have to choosean associated variable Y and a total ordering (cid:6) on its domain Y . (Similarly, when using a complete search for finding asolution of a constraint satisfaction problem, at each node of the explored search tree, we have to choose a variable toinstantiate next, and a value ordering over the domain of that variable.) This determines the components Ar and ar for eachchild r of this node, and we choose associated variable Y r ∈ V − Ar and total ordering (cid:6)r on Y r . Applying this iterativelyfrom the root to the leaf nodes generates a cs-tree.A cs-tree σ is an exponentially large object, so we will often not be able to generate it explicitly. However, to define acs-tree implicitly, all we have to do is to define a function g that takes as input appropriate tuples a ∈ A and returns a pair(Y , (cid:6)) where Y ∈ V − A and (cid:6) is a total ordering on Y . The domain D g of the function could be the set of all possibletuples a, but need not be: it is sufficient that it contain the assignment (cid:5) to the empty set, and satisfy the condition thatif D g contains a and g(a) = (Y , (cid:6)) then D g contains tuple ay for every assignment y to Y . Such a function g thereforespecifies a compact representation of a search tree σg (given that g is specified in a compact way). For any search tree,there exists g such that σ equals σg .Given that any value of the function g can be computed efficiently, we can efficiently perform important operationswith σg (without constructing σg explicitly). In particular, for any two outcomes α and β, we can determine if α >σg β: wegenerate the nodes in the path to α until we find the node that divides α and β. In addition, given any number K , we canefficiently generate the best K outcomes according to >σg , by generating the nodes in σg in a depth first search manner, asexplained below, until K outcomes have been generated.Using a cs-tree σ for backtracking search. As alluded to above, cs-trees are essentially the same as search trees used forsolving CSPs, and they can be used to control the depth-first search for solutions. Any node of the search tree correspondsto a node r of the cs-tree σ . Ar is the set of variables already assigned, and ar is their assignment. We start the searchat the root node. At each node r, we instantiate variable Y r next. Relation (cid:6)r gives the value ordering: we instantiate firstthe best value according to (cid:6)r . On backtracking to this search node, we remove the previously tried value of Y r from thedomain of Y r , and instantiate Y r with the best remaining value according to (cid:6)r . If the domain of Y r is now empty, webacktrack to the parent node of r. When we reach a leaf node r, i.e., when all the variables are instantiated, we record theassociated outcome ar , and backtrack to its parent node.Given a set C of constraints6 on variables V we can use this backtracking search method in the usual way to generatesolutions of C , i.e., outcomes satisfying all the constraints in C . Standard CSP techniques such as maintaining arc consistencycan be used to reduce the search. The solutions of C will be generated in decreasing order of >σ .4.3. cs-trees satisfying cp-theoriesIn this section, sufficient conditions are given for a cs-tree ordering to satisfy a cp-theory. These conditions will be usedin Sections 5, 6 and 7 to give sufficient conditions for a cp-theory to be consistent.A cs-tree σ is said to satisfy a cp-theory Γ if its associated total order >σ extends the preference relation >Γ (seeDefinition 9, below). A cp-theory is conditionally acyclic if there exists some cs-tree satisfying it. This immediately implies(Proposition 12) that conditional acyclicity implies consistency (although the converse does not hold: see Example 6). Propo-sition 13 gives a pair of necessary and sufficient conditions for a cs-tree to satisfy a cp-theory, the first based on the variableorderings in paths in the cs-tree (or, equivalently, on the variable Y r that can be chosen for a node r given the current as-signment a); the second condition is on the value ordering that is chosen for a node r in the cs-tree. Proposition 14 thengives a stronger pair of sufficient conditions (which corresponds to “strong satisfaction”, developed in Section 6.1); the firstcondition, on the variable orderings, is that for any preference statement ϕ ∈ Γ , set of variables U ϕ must appear before Xϕwhich must appear before variables W ϕ , on the path from the root node of the cs-tree to any outcome α which extends uϕ .This condition enables a simpler form for the second, local ordering condition, namely, that the total ordering (cid:6)r for noder in the cs-tree extends the appropriate local ordering, which is a strict partial order, given that the cp-theory is locallyconsistent (this implies that the second condition is easy to satisfy, since a partial order can always be extended to a totalorder).6 A constraint c on variables V is a relation on Sc for some Sc ⊆ V , so is interpreted as a subset of Sc . An outcome α ∈ V satisfies a constraint c ifα(Sc) ∈ c. Outcome α is said to be a solution of set of constraints C on V if it satisfies each constraint in C .1068N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Definition 9. Let Γ be a cp-theory. We say that cs-tree σ satisfies Γ if the associated total order >σ satisfies Γ , i.e., if>σ ⊇ >Γ (by Lemma 2(i)).We say that Γ is conditionally acyclic7 if there exists a cs-tree satisfying Γ .If a cp-theory Γ is conditionally acyclic then there exists a cs-tree σ with >σ satisfying Γ , implying that Γ is consistent:Proposition 12. Let Γ be a cp-theory. If Γ is conditionally acyclic then it is consistent.The following example shows that the converse does not hold: there exist consistent cp-theories that are not condition-ally acyclic.Example 6. Let cp-theory Γ on variables { X1, X2} consist of the four preference statements x1 : x2 > x2[∅]; x2 : x1 > x1[∅];x1 : x2 > x2[∅], and x2 : x1 > x1[∅]. These statements imply that x1x2 and x1x2 are both preferred to x1x2 and x1x2. Γ isconsistent, but is not conditionally acyclic. To prove a contradiction, assume that there exists a cs-tree σ which satisfies Γ .(i.e., the top, or, most important variable for σ ). Then theSuppose that X1 is the variable associated with the root node rnode value ordering (cid:6) is either x1 (cid:6) x1, or x1 (cid:6) x1. If the former, then x1x2 >σ x1x2; if the latter then x1x2 >σ x1x2. Bothof these are incompatible with Γ , so X1 cannot be the top variable. Similarly, X2 cannot be the top variable, so there existsno cs-tree satisfying Γ .∗The following result gives equivalent conditions for a search tree to satisfy a cp-theory. Condition (1) states that avariable precedes less important variables on relevant paths of the cs-tree, and condition (2) states that the node valueordering must be compatible with the preference statements in the cp-theory. More precisely, consider some statementu : x > xare values of variable X . (1) requires that on paths to outcomes thatextend u, X appears before each element of W . (2) requires that for any node r whose context ar is compatible with u and(cid:3)where X is chosen, x is preferred to x(cid:3)(cid:3)[W ] in the cp-theory Γ , where x and xin the node value ordering.Proposition 13. Let Γ be a cp-theory, and let σ be a cs-tree. The following pair of conditions is sufficient for σ to satisfy Γ . If thedomain of each variable has at least two elements then the pair of conditions is also necessary for σ to satisfy Γ .(1) For any ϕ ∈ Γ and any outcome α such that α |(cid:11) uϕ : on the path from the root to α, Xϕ appears before each element of W ϕ ;(cid:3)(2) for any body node r and any ϕ ∈ Γ such that Xϕ = Y r and for any uϕ compatible with ar , we have xϕ (cid:6)r xϕ .(The condition that the domain of each variable has at least two elements is not restrictive, since any variable with asingleton domain can be eliminated.)One interesting aspect of the above result is that it shows that it is not necessary for parents of a variable to precedethe variable in the paths in a cs-tree, i.e., we can have, for ϕ ∈ Γ , elements of U ϕ further from the root (i.e., less important)than Xϕ . However, in this paper we are mainly concerned with cs-trees where parents precede children (at least in relevantcontexts). For this case we have the following version of Proposition 13, which will be used in Section 6. It again consists) is a stronger formof a condition on the variable orderings, and a condition on the node value orderings. Condition (1(cid:3)[W ] in Γ , on paths where U is instantiated as u, it isof (1) of Proposition 13, requiring that, for any statement u : x > xinstantiated before X which is instantiated before W . Given (1), condition (2) of Proposition 13 can be expressed as (2).(cid:3)(cid:3)(cid:3)Proposition 14. Let Γ be a cp-theory, and let σ be a cs-tree. Then σ satisfies Γ if the following pair of conditions hold:(cid:3)(cid:3)(1(2) For any ϕ ∈ Γ and any outcome α such that α |(cid:11) uϕ : on the path from the root to α, each element of U ϕ appears before Xϕ ,which appears before each element of W ϕ ;) for any body node r = (cid:18) A, a, Y , (cid:6)(cid:19), relation (cid:6) extends the local ordering (cid:6)Ya (see Definition 4).Example 7. Consider again the cp-theory Γ from Example 3, and the cs-tree σ from Example 4 and Fig. 2. In particular,consider the preference statement ϕ = x1 : x3 > x3[{ X2}] in Γ , and any outcome α such that α |(cid:11) x1, i.e., α( X1) = x1. In thepath to such an outcome, the variables appear in the order X1, X3, X2, and so U ϕ = { X1} appears before Xϕ = X3 whichappears before W ϕ = { X2}. Thus, condition (1) of Proposition 14 is satisfied, for this ϕ, and it can be easily confirmed also(cid:3)), consider the node associated with assignment x1, which has value ordering (cid:6)for other ϕ ∈ Γ . To illustrate condition (2given by x3 (cid:6) x3, and so (cid:6) is equal to (cid:6) X3) can be confirmed for all other nodes also, so byProposition 14, cs-tree σ satisfies Γ .x1 (see Example 3). Condition (2(cid:3)(cid:3)7 Our terminology differs here from that used for TCP-nets (and also the terminology used in [31]); conditional acyclicity for TCP-nets [8] correspondswith our property “context-uniform conditional acyclicity” (see Section 6.2), which is a very much stronger condition, assuming, in particular, that H(Γ ) isacyclic.N. Wilson / Artificial Intelligence 175 (2011) 1053–109110694.4. Total ordering tasks and upper approximations of the preference relationSuppose that we have a set Ω of possible outcomes which the user needs to choose between, and we have elicited theirpreferences as a cp-theory Γ . We wish to display the outcomes in some order >, showing them the best ones first. A basicrequirement is that for α, β ∈ Ω , if α is preferred to β then α appears before β, i.e., if α >Γ β then α > β, since they aremore likely to be interested in outcome α than outcome β. Thus, we are concerned with the following task: given cp-theoryΓ and subset Ω of outcomes, construct a strict total order > on Ω which extends >Γ restricted to Ω .However, if Ω is very large, in particular if it is expressed implicitly as the set of solutions of a constraint satisfactionproblem, then we won’t be able to display all of them, but just, say, K of them. This gives rise to the following relatedproblem: Given K , generate outcomes α1, . . . , αK ∈ Ω such that for all j = 1, . . . , K , if β >Γ α j for some β ∈ Ω then β = αifor some i < j.These ordering tasks can be solved if we can define a cs-tree satisfying Γ , since as shown in Section 4.2, we can then ef-ficiently compare outcomes, and generate outcomes in the cs-tree order. Another approach is to use an upper approximationof the preference relation, as defined below.Definition 10 (Upper approximation). Binary relation (cid:16) on V is said to be an upper approximation of the preference relation>Γ if (cid:16) is a strict partial order extending >Γ . We say that (cid:16) is a polynomial upper approximation if for any outcomes αand β, whether or not α (cid:16) β holds can be determined in polynomial time.Note that an upper approximation of >Γ exists if and only if >Γ is irreflexive, i.e., if and only if (by Theorem 1) Γ isconsistent.The result below, which follows easily from the definitions, describes a general way of generating upper approximations,which will be used below in Sections 5.2, 6.3 and 7.6, for proving that certain relations are polynomial upper approxima-tions. It states that the intersection of a non-empty set of cs-tree orderings satisfying a cp-theory is an upper approximation.Proposition 15. Let R be some non-empty set of cs-trees satisfying cp-theory Γ . Define relation (cid:16)Rσ in R, so that, for outcomes α and β, α (cid:16)R β if and only if α >σ β holds for all σ ∈ R. Then relation (cid:16)Rof >Γ , i.e., a strict partial order containing >Γ .to be the intersection of >σ overis an upper approximationProof. Each relation >σ is transitive, and intersections of transitive relations are also transitive, so (cid:16)Ralso irreflexive since any >σ is irreflexive, and so (cid:16)Rthat their intersection, (cid:16)Ris transitive; it isis a strict partial order. For each σ ∈ R, >σ ⊇ >Γ , which implies, contains >Γ . (cid:2)For Ω consisting of just a few outcomes, a polynomial upper approximation (cid:16) can be used to order Ω in a way that iscompatible with >Γ : for each α, β ∈ Ω we test if α (cid:16) β; this generates a strict partial order over Ω , i.e., the restriction of(cid:16) to Ω × Ω . (This procedure can be speeded up if we can efficiently find a (cid:16)-undominated element in Ω , i.e., an elementα ∈ Ω such that for all β ∈ Ω it is not the case that β (cid:16) α, since we can find such an element and then remove it from Ωand iterate.)For larger Ω , or Ω defined implicitly as the set of solutions of a constraint satisfaction problem on V , our approach isto use an implicit representation of a cs-tree σ satisfying Γ : see Sections 5.1, 6.4, and 7. This can also be used to generatethe top K elements according to σ .4.5. Constrained optimisation using polynomial upper approximationThis section first considers the task of finding optimal outcomes for a cp-theory Γ , i.e., outcomes that are not dominatedby any outcome according to the preference relation >Γ . It then considers the much harder problem of finding optimalsolutions to a set of constraints, and shows how an upper approximation can be used to help find some optimal solutions.Definition 11. Given cp-theory Γ , we say that outcome α is (>Γ -)optimal if there exists no outcome β such that β >Γ α.Let Ω be a set of outcomes. We say that outcome α ∈ Ω is (>Γ -)optimal in Ω if there exists no outcome β ∈ Ω such thatβ >Γ α. If C is a set of constraints on V we say that α is an (>Γ -)optimal solution of C if α is >Γ -optimal in the set ofsolutions of C .The optimal outcomes with respect to cp-theory Γ are precisely the solutions of a particular constraint satisfactionproblem (CSP) CΓ on V (cf. [9] and Theorem 2 of [13]). The point is that if outcome α does not satisfy some cϕ then it’s(cid:3)ϕ to xϕ .not optimal since there’s an improving swap just changing the value of Xϕ from xProposition 16. Let Γ be a cp-theory. Define CΓ to be the set of constraints {cϕ : ϕ ∈ Γ }, where constraint cϕ on variables U ϕ ∪ { Xϕ}(cid:3)ϕ). Then outcome α ∈ V is >Γ -optimal if and only if α is a solution of CΓ .is (U ϕ = uϕ) ⇒ ( Xϕ (cid:13)= x1070N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Furthermore, as observed in [32], if H(Γ ) is acyclic and (e.g.,) if Γ is locally consistent, then it’s very easy to find >Γ -optimal outcomes; by instantiating the variables in an order compatible with H(Γ ), one can reach a (any) solution (withouthaving to backtrack).The situation is much trickier when we have a set of constraints C on V , and we wish to find optimal solutions of C .If one is only interested in finding some outcomes which are optimal, then one can try to solve the CSP with constraintsCΓ ∪ C . Any solution of this CSP will be an >Γ -optimal solution of C since it is >Γ -optimal in V . However, CΓ ∪ C mayvery well have no solutions, so we need some more general methods.Finding all optimal solutions. Suppose one can find a cs-tree σ satisfying Γ . This can be used to generate the solutionsof C in the order >σ , by using the natural backtracking algorithm associated with σ (see Section 4.2). The first solution, α,that it generates will be >Γ -optimal since β >Γ α implies β >σ α (and so β cannot be a solution of C ). At each pointin the search we have a set Ω ∗of >Γ -optimal solutions already found. When we find the next solution α we need todetermine if there exists any β ∈ Ω ∗(since α isnot dominated by any solution γ found later, because α >σ γ , and so γ ≯σ α and hence γ ≯Γ α).with β >Γ α. If not, then α is a >Γ -optimal solution and we add it to Ω ∗This algorithm, which is based on the approach used for CP-nets in [5], is complete, with the final Ω ∗being the set of all>Γ -optimal solutions, and at each point the set Ω ∗contains only >Γ -optimal solutions. The problem with this algorithm(and the similar algorithms in [5,8]) is that determining if β >Γ α (or not) will often be infeasible [4,12,18] unless theproblem is small, since it involves searching for swapping sequences, which generalise flipping sequences.Finding some optimal solutions. However, suppose now we apply exactly the same form of algorithm, but replacing testsof the form β >Γ α by β (cid:16) α, where (cid:16) is an upper approximation of >Γ . The generated outcomes will be precisely the(cid:16)-optimal solutions of C . However, from the definition of an upper approximation it immediately follows that if α is (cid:16)-optimal then it is >Γ -optimal. This algorithm will therefore generate some (but not usually all) the >Γ -optimal solutions;if the tests β (cid:16) α can be performed efficiently then generating >Γ -optimal solutions in this way should be quite feasible.There will often be a very large number of optimal solutions, and we may well only wish to report a small fraction ofthem; it is not necessarily important that the upper approximation is a close approximation, just that (cid:16) is sufficiently farfrom being a total order that there are still liable to be a good number of solutions which are (cid:16)-optimal.5. Consistency, and polynomial upper bound of preference relation: the fully acyclic caseIn this section we consider fully acyclic cp-theories Γ , that is, those such that G(Γ ) is acyclic. Recall from Section 2.2.3that G(Γ ) contains sets of edges U ϕ → Xϕ and Xϕ → W ϕ for all ϕ ∈ Γ ; Γ is thus fully acyclic if and only if the set ofvariables V can be labelled as {Z1, Z2, . . . , Zn} in such a way that for all ϕ ∈ Γ , if Z i ∈ U ϕ then i < j where Z j = Xϕ , andif Zk ∈ W ϕ then k > j. It is shown in Section 5.1 how to construct a satisfying cs-tree for Γ if it is locally consistent. Thisimplies (Theorem 3) that when G(Γ ) is acyclic, Γ is consistent if and only if it is locally consistent. In Section 5.2 we definean upper approximation for the preference relation >Γ , which, as shown in Section 4.4, can be used for totally orderingsets of outcomes, and for constrained optimisation.5.1. Generating a cs-tree satisfying fully acyclic ΓSuppose that Γ is a locally consistent and fully acyclic cp-theory. Therefore, there exists a total order on the set ofvariables V that extends G(Γ ). Let us enumerate V as Z 1, Z2, . . . , Zn in a way which is compatible with G(Γ ), i.e., suchthat (Z i, Z j) ∈ G(Γ ) implies i < j. We can iteratively define the nodes of a cs-tree from the root to the leaves as follows,instantiating the variables in the order Z1, Z2, . . . , Zn. For each node r, we have Ar = {Z1, . . . , Zk−1} for some k. We defineY r to be Zk, and choose (cid:6)r to be some strict total order extending (cid:6) Zkis acyclic, by localconsistency. Let us call this cs-tree σ [Γ ]. Proposition 14 of Section 4.3 immediately implies that this cs-tree satisfies Γ :ar , which is possible since (cid:6) ZkarLemma 7. Let Γ be a locally consistent and fully acyclic cp-theory. Then the cs-tree σ [Γ ] satisfies Γ .Lemma 7 implies that a locally consistent fully acyclic cp-theory Γ is consistent, since (cid:6)σ [Γ ] satisfies Γ . As observedearlier, local consistency is a necessary condition for consistency (Proposition 9, Section 4.1). We therefore have that localconsistency and consistency are equivalent for fully acyclic cp-theories:Theorem 3. Let Γ be a fully acyclic cp-theory. Then Γ is consistent if and only if Γ is locally consistent.5.2. An upper approximation for fully acyclic ΓThere is a simple way of defining a polynomial upper approximation (see Definition 10 in Section 4.4) for a fully acycliccp-theory. It is a kind of generalised lexicographic order, and is strongly related to the ‘ordering queries’ and the relation(cid:16) used in the proof of Theorem 6 in [4]. Two outcomes are compared by comparing, using the appropriate local ordering,N. Wilson / Artificial Intelligence 175 (2011) 1053–10911071their value on each of the most important variables on which they differ, where importance is defined (here) according torelation G(Γ ). The section finishes with a result, Proposition 17, which shows that this polynomial upper approximation forΓ is equal to the preference relation associated with a strengthened form of Γ .Definition 12. Let Γ be a locally consistent and fully acyclic cp-theory. Define relation (cid:6)p(Γ ) on outcomes as follows.Let α and β be outcomes in V . Define (cid:7)(α, β) to be the set of variables on which α and β differ, that is, the set{Y ∈ V : α(Y ) (cid:13)= β(Y )}. If α (cid:13)= β, define Θ(α, β) to be the set of Gis the transi-tive closure of G(Γ ), i.e., variables Y ∈ (cid:7)(α, β) such that there exists no Z ∈ (cid:7)(α, β) such that (Z , Y ) ∈ G. In other words,Θ(α, β) is the set of variables Y on which α and β differ such that every ancestor of Y agrees on α and β. For α, β ∈ V ,we define α (cid:6)p(Γ ) β if and only if α (cid:13)= β and α(Y ) (cid:6)Y-maximal elements of (cid:7)(α, β), where Gα β(Y ) for all Y ∈ Θ(α, β).◦◦◦For given outcomes α and β, determining if α (cid:6)p(Γ ) β can clearly be done in polynomial time. This ordering is similarto a lexicographic ordering. It views G(Γ ) as expressing relative importance of variables: if (Y , Z ) ∈ G(Γ ) then variable Y isconsidered as more important than Z . The idea is that Θ(α, β) is the set of most important variables where α and β differ.α is preferred to β if α is better than β on each of these variables. A standard lexicographic order compares two outcomesα and β by considering the most important variable X on which α and β differ, and preferring α to β if α( X) is preferredto β( X). This order differs in that (i) there can be more than one best variable on which α and β differ, because Gis onlya partial order; and (ii) the local preference of α( X) over β( X) can be partial, and conditional on more important variables.With Γ as in Example A (Section 2.2.2), consider outcomes nop and nop. We have (cid:7)(nop, nop) = { X2, X3}, andΘ(nop, nop) = { X2}, because variable X2 is more important than X3 according to G(Γ ). Also, o (cid:6) X2nop o holds becauseof ϕ2, and so, nop (cid:6)p(Γ ) nop. In fact, the relation (cid:6)p(Γ ) is in this case a total order, which extends >Γ with the additionalpreference nop (cid:6)p(Γ ) nop.The following lemma shows that relation (cid:6)p(Γ ) is equal to the intersection of a particular set of cs-tree orderings, where◦the ordering of variables in the cs-trees involved is always compatible with G(Γ ).Lemma 8. Let Γ be a locally consistent and fully acyclic cp-theory. Let S be the set of cs-trees σ satisfying the two conditions:(a) for any pair (Y , Z ) ∈ G(Γ ) and any outcome α, variable Y appears before Z on the path to α (i.e., for any ϕ ∈ Γ , variables U ϕappear before variable Xϕ , which appears before variables W ϕ on any path to any outcome);(b) for any body node r in σ , (cid:6)r ⊇ (cid:6)Yr⊆ Ar by (a).)that U Yru , where u = ar(U Yr ), and U Yr is the set of the parents of Y r in H(Γ ) (see Section 2.2.3). (NoteFor outcomes α and β, α (cid:6)p(Γ ) β if and only if for all cs-trees σ in S, we have α >σ β. In other words, (cid:6)p(Γ ) = (cid:16)Snotation of Proposition 15, Section 4.4., using theThis lemma and Proposition 15 (Section 4.4) immediately imply the following result, showing that (cid:6)p(Γ ) is a polynomialupper approximation of the preference relation. (This result can also be proved more directly.)Theorem 4. Let Γ be a locally consistent and fully acyclic cp-theory. Then (cid:6)p(Γ ) is a strict partial order containing >Γ , so is an upperapproximation of the preference relation >Γ .As shown by Theorem 4, (cid:6)p(Γ ) extends >Γ . In fact, it turns out that if one strengthens the preference statements in Γ ,= >Γ . Thisby expanding the sets W ϕ , to form a cp-theory Γ , we obtain equality between the relations: (cid:6)p(Γ ) = (cid:6)result is used in the footnote in Section 3.5.p(Γ )Proposition 17. Let Γ ⊆ L be a cp-theory. For ϕ = (u : x > xis the set of descendantsof X in G(Γ ) (i.e., the set of variables Y such that ( X, Y ) is in the transitive closure of G(Γ )). Define Γ = {ϕ: ϕ ∈ Γ }. If Γ is locallyconsistent and fully acyclic then (cid:6)p(Γ ) = (cid:6)(cid:3)[W ]) ∈ Γ let ϕ be (u : x > x(cid:3)]) where W⊇ >Γ .(cid:3)[W(cid:3)= >Γp(Γ )6. Consistency and polynomial upper bound of preference relation: more general caseThis section considers the problems of determining consistency, and generating a polynomial upper approximation formore general kinds of cp-theories than the fully acyclic ones considered in Section 5.We first consider two conditions on cp-theories that are sufficient conditions for the cp-theory to be consistent. Theyare weaker forms of acyclicity, though stronger than conditional acyclicity: strong conditional acyclicity in Section 6.1, andcontext-uniform conditional acyclicity (cuc-acyclicity) in Section 6.2. (The latter is very similar to the notion of “conditionalacyclicity" in [8].) An important aspect of these conditions is that the complexity of determining them is only coNP-complete(see Proposition 24), which is much less than the complexity (PSPACE-complete) of determining consistency for generalcp-theories. For cuc-acyclic cp-theories we define a way of generating an upper approximation in Section 6.3. Section 6.41072N. Wilson / Artificial Intelligence 175 (2011) 1053–1091shows how to generate a total order satisfying the cp-theory. Theorem 6 in Section 6.5 summarises the results on thestrength of different forms of consistency, specifically, that the following are progressively weaker conditions on a cp-theory:being locally consistent and fully acyclic, cuc-acyclicity, strong conditional acyclicity, conditional acyclicity, consistency, localconsistency. Section 6.5 also discusses how to use the results to confirm that a cp-theory is consistent.6.1. Strong conditional acyclicity and strong satisfactionWe consider a condition, called strong satisfaction, which is sufficient for a cs-tree to satisfy a cp-theory (see Definition 13below). This is expressed as a pair of conditions on each node r of the cs-tree. The first condition is on the choice of thenew variable Y to be branched on, given the assignment a to variables made above that node: if this condition is satisfied,we say that Y is strongly a-undominated. The second condition is that the node value ordering extends the appropriatelocal ordering. Proposition 18 gives an equivalent definition for a cs-tree to strongly satisfy a cp-theory, which leads toProposition 19, which states that strong satisfaction implies satisfaction. The definition of strong satisfaction suggests thedefinition of a stronger form of conditional acyclicity, Definition 14, that the cp-theory is locally consistent, and that givenany assignment a to any proper subset of the set of variables, there exists a strongly a-undominated variable. This easilyimplies that if a cp-theory is strongly conditionally acyclic then one can iteratively construct, starting with the root node, acs-tree strongly satisfying Γ , hence implying the consistency of Γ (see Proposition 21). In addition, a result, Proposition 20,is given that is useful for helping prove that a particular cp-theory is strongly conditionally acyclic.We are interested in cs-trees whose associated orders satisfy cp-theory Γ . For this we need to make sure that for anypath and any relevant ϕ ∈ Γ , Xϕ appears before all the variables in W ϕ , as Xϕ is a more important variable (see Proposi-tion 13, in Section 4.3). Furthermore, we require here that the conditioning variables U ϕ to all appear before Xϕ , so thatwe know the values of relevant parents of Xϕ before we can decide which values of Xϕ are preferred (cf. Proposition 14).Definition 13. Let Γ be a cp-theory over variables V . Let A be a subset of V , and let a ∈ A be an assignment to thevariables A.• We say that Y ∈ V − A is strongly a-undominated (with respect to Γ ) if for all ϕ ∈ Γ such that uϕ is compatible witha, (i) if Xϕ = Y then U ϕ ⊆ A; (ii) if W ϕ (cid:17) Y then U ϕ ∪ { Xϕ} ⊆ A.• A body tuple (cid:18) A, a, Y , (cid:6)(cid:19) is said to strongly satisfy Γ if (I) Y is strongly a-undominated and (II) the ordering (cid:6) on Yextends (cid:6)Ya (i.e., if y (cid:6)Ya y(cid:3)then y (cid:6) y(cid:3)).• A body node is said to strongly satisfy Γ if its associated body tuple strongly satisfies Γ .• A cs-tree is said to strongly satisfy Γ if each body node in the cs-tree strongly satisfies Γ .The following result is an immediately consequence of the first part of the previous definition, since any uϕ is compatiblewith (cid:5), the assignment to the empty set of variables.Lemma 9. Let Γ be a cp-theory over variables V , and let Y be a variable in V . Then variable Y is strongly (cid:5)-undominated if and onlyif for all ϕ ∈ Γ ,(a) Y /∈ W ϕ , and(b) if Xϕ = Y then U ϕ = ∅.In other words, Y is strongly (cid:5)-undominated if and only if Y is never less important than any other variable, and anypreferences regarding the values of Y are unconditional. This is also if and only if Y is undominated with respect to G(Γ )(see Section 2.2.3), i.e., there does not exist Z ∈ V with (Z , Y ) ∈ G(Γ ).If a cs-tree strongly satisfies Γ , the conditions ensure that if ϕ ∈ Γ and outcome α is such that α |(cid:11) uϕ then on the pathfrom the root to the leaf node (cid:18)V , α(cid:19), variables U ϕ appear before Xϕ which appears before variables W ϕ ; this leads to thefollowing result expressing an equivalent form for a cs-tree to strongly satisfy a cp-theory.Proposition 18. Let Γ be a cp-theory, and let σ be a cs-tree. Then σ strongly satisfies Γ if and only if the following pair of conditionshold:(1) For any ϕ ∈ Γ and any outcome α such that α |(cid:11) uϕ : on the path from the root to α, each element of U ϕ appears before Xϕ ,which appears before each element of W ϕ ;(2) for any body node r of σ with associated tuple (cid:18) A, a, Y , (cid:6)(cid:19), relation (cid:6) extends the local ordering (cid:6)Ya .Proposition 18, and Proposition 14 from Section 4.3, immediately imply the following result.Proposition 19. If a cs-tree σ strongly satisfies cp-theory Γ , then it satisfies Γ , i.e., its associated order >σ satisfies Γ .N. Wilson / Artificial Intelligence 175 (2011) 1053–10911073Here we define a stronger form of conditional acyclicity of a cp-theory (as shown by Proposition 21 below).Definition 14 (Strongly conditionally acyclic cp-theory). We say that Γ is strongly conditionally acyclic if it is locally consistentand for all proper subsets A of V , and all a ∈ A, there exists a strongly a-undominated variable (see Definition 13).Below we derive a result, Proposition 20, that can make it easier to prove strong conditional acyclicity, and henceconsistency. First we show, in Lemma 10, how being strongly a-undominated is the same as being undominated withrespect to a particular relation, Fa on V − A. Let A ⊆ V be a set of variables, and let a ∈ A be an assignment to A. Definerelation Fa on V (using the notation of Section 2.2.3) to consist of all edges U ϕ → Xϕ and U ϕ ∪ { Xϕ} → W ϕ for all ϕ ∈ Γsuch that uϕ is compatible with a, i.e., Fa is the union of (U ϕ → Xϕ) ∪ (U ϕ ∪ { Xϕ} → W ϕ) over all ϕ ∈ Γ such that uϕ iscompatible with a. (Thus, (Y , Z ) ∈ Fa if and only if there exists some ϕ ∈ Γ such that uϕ is compatible with a and eitherY ∈ U ϕ and Z = Xϕ or Y ∈ U ϕ ∪ { Xϕ} and Z ∈ W ϕ .)Lemma 10. Let A ⊆ V , and let a ∈ A, and let Y be a variable in V − A. Then Y is strongly a-undominated if and only if Y is notFa-dominated by any element of V − A, i.e., there does not exist Z ∈ V − A with (Z , Y ) ∈ Fa.Proposition 20. Let A, B ⊆ V be a sets of variables with A ⊆ B, and let a ∈ A be an assignment to A, and suppose that b ∈ B extends a.Then(i) Fb ⊆ Fa, i.e., if (Y , Z ) ∈ Fb then (Y , Z ) ∈ Fa;(ii) if Y ∈ V − B is strongly a-undominated then Y is strongly b-undominated;(iii) if Fa restricted to V − A is acyclic then there exists a strongly b-undominated variable in V − B.Example 8. Consider again the cp-theory Γ from Example 3 in Section 4.1, consisting of the following preference statements:ϕ1 = (cid:5) : x1 > x1[{ X2, X3}], ϕ2 = x1 : x3 > x3[{ X2}]; ϕ3 = x1 : x2 > x2[∅]. ϕ4 = x1 : x2 > x2[{ X3}], and ϕ5 = x1 : x3 > x3[∅].By Lemma 9, X1 is strongly (cid:5)-undominated, so, by Proposition 20(ii), X1 is strongly b-undominated for any assignmentb to set of variables B such that B /(cid:17) X1. F x1 restricted to { X2, X3} consists just of the edge X3 → X2 (because of ϕ2)and is hence acyclic. Then, by Proposition 20(iii), there exists a strongly b-undominated variable for any b extending x1.Similarly, F x1 restricted to { X2, X3} is acyclic, so by Proposition 20(iii), there exists a strongly b-undominated variable forany b extending x1. This implies that, for any assignment b to a proper subset of V , there exists a strongly b-undominatedvariable, and hence Γ is strongly conditionally acyclic. A similar argument works for Example B in Section 3.2.This example illustrates that strong conditional acyclicity, and hence consistency, of a cp-theory Γ can sometimes beeasily shown, if Γ is close to being acyclic.The following result follows easily from the definitions.Lemma 11. Let Γ be a strongly conditionally acyclic cp-theory. Given any proper subset A of V and a ∈ V , there exists Y and totalorder (cid:6) on Y such that (cid:18) A, a, Y , (cid:6)(cid:19) is a body tuple strongly satisfying Γ .Proof. Since Γ is strongly conditionally acyclic, there exists a strongly a-undominated variable, Y . Choose any outcome αextending a, and pick some strict total order (cid:6) extending (cid:6)Yα is a strictpartial order.) Then (cid:6) extends (cid:6)Yα . (This is possible since, by local consistency, (cid:6)Ya , so (cid:18) A, a, Y , (cid:6)(cid:19) strongly satisfies Γ . (cid:2)This means that it is easy to construct a cs-tree satisfying a strongly conditionally acyclic Γ : we start by picking aroot node strongly satisfying Γ , and we proceed inductively, choosing children strongly satisfying Γ for each node alreadychosen. Lemma 11 ensures that the cs-tree generated will strongly satisfy Γ , and hence satisfies Γ , by Proposition 19. Thisimplies the following result:Proposition 21. Suppose Γ is a strongly conditionally acyclic cp-theory. Then Γ is conditionally acyclic and hence consistent.The example below shows that the converse fails.Example 9. Let V = { X1, X2}. Let Γ be the pair of statements x1 : x2 > x2[∅] and x2 : x1 > x1[∅]. Γ ∗is just equal to{(x1x2, x1x2), (x1x2, x1x2)}, and so is acyclic (with >Γ equal to Γ ∗) and hence, by Theorem 1(ii), Γ is consistent. Further-more, Γ is conditionally acyclic: we can define a cs-tree σ satisfying Γ as follows. σ includes two other body nodes apartfrom the root node. The root node is equal to (cid:18)∅, (cid:5), X1, x1 > x1(cid:19). The first body node is (cid:18){ X1}, x1, X2, x2 > x2(cid:19), the second is(cid:18){ X1}, x1, X2, x2 > x2(cid:19). The associated ordering >σ on outcomes is the transitive closure of: x1x2 >σ x1x2 >σ x1x2 >σ x1x2,so, >σ contains Γ ∗.1074N. Wilson / Artificial Intelligence 175 (2011) 1053–1091However, Γ is not strongly conditionally acyclic. By Lemma 9, X1 is not strongly (cid:5)-undominated, because of the pref-erence statement x2 : x1 > x1[∅]. Similarly, X2 is not strongly (cid:5)-undominated, so there exists no strongly (cid:5)-undominatedvariable.6.2. Context-uniform conditional acyclicityWe consider here cuc-acyclicity, a yet stronger form of conditional acyclicity of cp-theories, which requires, in particular,that the dependency graph H(Γ ) is acyclic (see Section 2.2.3). It is closely connected with the notion of conditional acyclic-ity for TCP-nets [8]. A major motivation for considering cuc-acyclicity is that it allows a polynomial upper approximation ofthe preference relation >Γ to be defined (see Section 6.3 below), which, as shown above in Sections 4.4 and 4.5, can beused for ordering tasks and for constrained optimisation.Definition 15 (Cuc-acyclic cp-theory). Let Γ be a cp-theory. Let a ∈ A be an assignment to a set of variables A. Definedirected graph J a(Γ ) on the set of variables V , using the notation from Section 2.2.3, to consist of the set U ϕ → { Xϕ} ∪ W ϕof edges for all ϕ ∈ Γ , and also the set Xϕ → W ϕ of edges for all ϕ ∈ Γ such that U ϕ ⊆ A and a extends uϕ . (In otherwords, (Y , Z ) ∈ J a(Γ ) if and only if there exists some ϕ ∈ Γ such that either(i) Y ∈ U ϕ and Z ∈ { Xϕ} ∪ W ϕ or(ii) a extends uϕ ,and Y = Xϕ and Z ∈ W ϕ .) Define order (cid:3)a(Γ ) on V (abbreviated to (cid:3)a) to be the transitive closure of J a(Γ ).We say that cp-theory Γ is context-uniformly conditionally acyclic (abbreviated to cuc-acyclic) if it is locally consistent andfor each outcome α ∈ V ,J α(Γ ) is acyclic, i.e., (cid:3)α is irreflexive.The reason for the terminology “context-uniform” is that the relations U ϕ → { Xϕ} ∪ W ϕ involving the context sets U ϕare required to hold for any ϕ ∈ Γ , in contrast with the relations in Section 6.1 (see e.g., the definition of Fa) which requirea condition on ϕ. In particular, cuc-acyclicity of Γ requires that the dependency graph H(Γ ) is acyclic.This property is very similar to the notion of “conditional acyclicity” for TCP-nets: see Definitions 8 and 9 in [8]; (theproperty we call “conditional acyclicity” is a much weaker condition). The methods in Section 5 of [8] could therefore beused for checking whether certain kinds of cp-theories are cuc-acyclic.Note that if Γ is context-uniformly conditionally acyclic then for any A ⊆ V and a ∈ A,J a is acyclic, since J a ⊆ J α forany α extending a (i.e., such that α( A) = a).Cuc-acyclicity is a still stronger condition than being strongly conditionally acyclic:Proposition 22. If cp-theory Γ is context-uniformly conditionally acyclic then it is strongly conditionally acyclic, and hence condi-tionally acyclic and consistent.Example 10. Consider again the cp-theory Γ from Example 8 (Section 6.1) and Example 3 (Section 4.1). For any α extendingx1, (cid:3)α is consistent with (in fact is equal to) the ordering X1, X3, X2 (partly because of the preference statement ϕ2 whichequals x1 : x3 > x3[{ X2}]). For any α extending x1, (cid:3)α is equal to the ordering X1, X2, X3. Thus, for any α, (cid:3)α is irreflexive,so Γ is cuc-acyclic. Similarly, for Example B (Section 3.2), for α extending x1, (cid:3)α equals the ordering X1, X3, X2, X4, andfor α extending x1, (cid:3)α equals the ordering X1, X2, X3, X4, and so Γ is cuc-acyclic for Example B as well.As the following example illustrates, context-uniform conditional acyclicity is a strictly stronger condition than strongconditional acyclicity.Example 11. Let cp-theory Γ consist of the following statements: (cid:5) : x1 > x1[∅], x1x3 : x2 > x2[∅], and x1x2 : x3 > x3[∅].H(Γ ) is not acyclic, since X2 is a parent of X3, and vice versa. This implies that, for any outcome α,J α(Γ ) is not acyclic;hence, Γ is not cuc-acyclic. On the other hand, Γ is strongly conditionally acyclic. Consider any assignment a ∈ A, where Ais a proper subset of V . To show strong conditional acyclicity we need to show that there exists some Y ∈ V − A which isstrongly a-undominated. If A does not contain X1, then X1 is strongly a-undominated. If a equals x1, or x1x3 or x1x3 thenX2 is strongly a-undominated. If a equals x1, or x1x2 or x1x2 then X3 is strongly a-undominated. This covers all cases.6.3. Generating a polynomial upper approximation of the preference relationIn this section, we develop an approach for generating an upper approximation for the preference relation >Γ . Asexplained in Sections 4.4 and 4.5, this can be used for constrained optimisation and ordering queries. This particular upperapproximation, although not requiring full acyclicity, still requires a strong condition on the cp-theory, that it be cuc-acyclic(see Definition 15, Section 6.2).N. Wilson / Artificial Intelligence 175 (2011) 1053–10911075We define a relation (cid:16)Γ on outcomes associated with a cuc-acyclic Γ . This is a modified form of Definition 12 inSection 5.2, which is for the fully acyclic case. We will show (Theorem 5) that (cid:16)Γ is an upper approximation of thepreference relation >Γ .To compare two outcomes with relation (cid:16)Γ , we first consider the set (cid:7)(α, β) of variables on which they differ. Amongthis set we eliminate any of the variables which are dominated by any other with respect to relation (cid:3)α (see Definition 15),to obtain the set of variables Θ (cid:3)(α, β). Then α (cid:16)Γ β is defined to hold if and only if for all X ∈ Θ (cid:3)(α, β), α( X) is betterthan β( X) according to the local ordering (cid:6) XLet A be a subset of V , and let a ∈ A be an assignment to the variables A, and let B be a subset of V . We say that Y ∈ Bα (see Definition 4).is (cid:3)a-undominated in B if Y is undominated in B with respect to (cid:3)a, i.e., there does not exist Z ∈ B with Z (cid:3)a Y .Definition 16 (Upper approximation (cid:16)Γ ). Consider fixed cuc-acyclic Γ . For α, β ∈ V , let (cid:7)(α, β) be the set of variableswhere α and β differ, i.e., { X ∈ V : α( X) (cid:13)= β( X)}. Let Θ (cid:3)(α, β) be the (cid:3)α -undominated variables in (cid:7)(α, β) (note that thedefinition of cuc-acyclicity ensures that Θ (cid:3)(α, β) is non-empty given that α (cid:13)= β). The binary relation (cid:16)Γ on outcomes isdefined by: α (cid:16)Γ β if and only if for all X ∈ Θ (cid:3)(α, β), α( X) (cid:6) Xα β( X).We will prove the following result in the next section.Theorem 5. Let Γ be a cuc-acyclic cp-theory. Then (cid:16)Γ is a strict partial order containing >Γ and so is an upper approximation forthe preference relation >Γ .Example 12. Continuing Example 10, let α be the outcome x1x2x3, and let β be the outcome x1x2x3. The two outcomesdiffer on variables X2 and X3 so (cid:7)(α, β) = { X2, X3}. (cid:3)α is the ordering X1, X2, X3 (see Example 10) so Θ (cid:3)(α, β) = { X2}.We have α( X2) (cid:6) X2α x2, because of the preference statement ϕ4 = x1 : x2 > x2[{ X3}]. Hence, α (cid:16)Γ β.α β( X2), i.e., x2 (cid:6) X2Dominance testing with (cid:16)Γ , i.e., determining if α (cid:16)Γ β or not, can be done in polynomial time (and is often veryeasy), and so (cid:16)Γ is a polynomial upper approximation. If Γ is fully acyclic then (cid:16)Γ can be compared with relation◦(cid:6)p(Γ ) defined in Definition 12 in Section 6.3. Let α and β be outcomes. We have J α(Γ ) ⊆ G(Γ ), and so (cid:3)α ⊆ G. Hence,Θ (cid:3)(α, β) ⊇ Θ(α, β). Therefore, α (cid:16)Γ β implies α (cid:6)p(Γ ) β, so that (cid:16)Γ is a closer approximation of >Γ than (cid:6)p(Γ ).Proving Theorem 5The way we shall prove Theorem 5 is to show, using Lemma 14 and Lemma 15 below, that (cid:16)Γ is the intersection oftotal orders >σ over a particular set of cs-trees, those which cu-satisfy Γ (see Definition 17 below). This property ensuresthat the cs-tree satisfies Γ . The theorem then follows using Proposition 15 of Section 4.4. (A more direct proof is alsopossible.)Definition 17 (cu-satisfaction). Let Γ ⊆ L be cuc-acyclic. A body node with associated tuple (cid:18) A, a, Y , (cid:6)(cid:19) is said to context-uniformly satisfy Γ (abbreviated to cu-satisfy Γ ) if (i) Y is (cid:3)a-undominated in V − A (i.e., there does not exist Z ∈ V − Awith Z (cid:3)a Y ), and (ii) the total ordering (cid:6) on Y extends (cid:6)Y). A cs-tree is said to cu-satisfy Γ ifeach body node in the cs-tree cu-satisfies Γ .a (i.e., if y (cid:6)Ythen y (cid:6) ya y(cid:3)(cid:3)If Y is (cid:3)a-undominated in V − A then it can be seen that Y is strongly a-undominated in V − A (see Definition 13),which immediately implies the following result, using Proposition 19, Section 6.1.Lemma 12. If a cs-tree cu-satisfies Γ then it strongly satisfies Γ , and hence satisfies Γ .If Γ is cuc-acyclic (see Definition 15), then for any A ⊆ V and a ∈ A, we can define a body node cu-satisfying Γ bychoosing any Y which is (cid:3)a-undominated in V − A ((cid:3)a is acyclic, since (cid:3)α is acyclic for any α |(cid:11) a, ensuring we canpick such a Y ) and choosing any total order (cid:6) on Y extending (cid:6)Ya is a partial order by localconsistency). This means that we can generate a cs-tree cu-satisfying Γ by choosing a root node and iteratively generatingchildren of nodes already created. This proves the following lemma:a (which is possible since (cid:6)YLemma 13. If Γ is cuc-acyclic then there exists a cs-tree cu-satisfying Γ .The following result shows that (cid:16)Γ is contained in >σ for any cs-tree σ cu-satisfying Γ .Lemma 14. Let Γ be a cuc-acyclic cp-theory, and let σ be any cs-tree that cu-satisfies Γ . Then >σ contains (cid:16)Γ .The next lemma supplies the final piece we need to prove Theorem 5.1076N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Lemma 15. Let Γ be a cuc-acyclic cp-theory, and suppose outcomes α, β ∈ V are such that it is not the case that α (cid:16)Γ β. Then thereexists a cs-tree σ cu-satisfying Γ such that it is not the case that α >σ β.Putting the parts together, we have the following result, which immediately entails Theorem 5.Proposition 23. Let Γ be a cuc-acyclic cp-theory. Then (cid:16)Γ is the intersection of >σ over all cs-trees σ cu-satisfying Γ . Furthermore,(cid:16)Γ is a strict partial order containing >Γ and so is an upper approximation for the preference relation >Γ .Proof. By Lemma 14 and Lemma 15, α (cid:16)Γ β if and only if α >σ β for all cs-trees σ cu-satisfying Γ . This implies that(cid:16)Γ is the intersection of >σ over all cs-trees σ cu-satisfying Γ . If σ cu-satisfies Γ then it satisfies Γ , by Lemma 12.Proposition 15 (Section 4.4) then implies that (cid:16)Γ is a strict partial order containing >Γ . (cid:2)6.4. Generating a total order satisfying cp-theory ΓThe procedure described above—after Lemma 11 in Section 6.1—for generating a cs-tree from strongly conditionallyacyclic Γ , could usually, depending on the choices made, generate many different cs-trees satisfying Γ . It can be usefulto have a way of pinning down which choice is made, and thus a way of defining (implicitly) a particular total order that(where mi = | Xi|) of the valuessatisfies Γ . We assume a listing X1, . . . , Xn of V , and for each i, a total ordering x1of Xi . We use these to define a particular cs-tree σ (Γ ) which satisfies Γ . This is constructed from the root down. Wheneverwe have a set of choices of a-undominated variable at node r we choose Y r to be Xi with minimal i (among the choices).Similarly we define (cid:6)r by generating the values of Xi from the best to the worst, at each point choosing a (cid:6) Xia -maximalvalue amongst the remaining values, where ties are broken by choosing value xi , . . . , xmiiji with largest j.Suppose we want to be able to generate outcomes in an order compatible with the preferences Γ (i.e., compatible with>Γ ). If Γ is conditionally acyclic then >σ (Γ ) is such an order. This order was defined implicitly: we do not have to explicitlyconstruct cs-tree σ (Γ ) to use it. In particular, we can generate in polynomial time the best K outcomes according to >σ (Γ ),by generating just the first K leaf nodes of cs-tree σ (Γ ). Also, given any two different outcomes α and β, we can efficientlydetermine which is better according to this order >σ (Γ ), by constructing just the nodes that are above both leaf node (cid:18)V , α(cid:19)and leaf node (cid:18)V , β(cid:19).6.5. Summary and discussion on forms of consistencyThe following result sums up the relationships between the different conditions of cp-theories that we have explored.Theorem 6. Let Γ be a cp-theory. Recall that Γ is– consistent if there exists a strict total order satisfying Γ (Definition 2, Section 2.3);– locally consistent if (cid:6) X– fully acyclic if G(Γ ) is acyclic (see Section 2.2.3);– conditionally acyclic if there exists a cs-tree satisfying Γ (Definition 9, Section 4.3);– strongly conditionally acyclic if it is locally consistent and for all A ⊆ V and a ∈ A, there exists a strongly a-undominatedα is irreflexive for all variables X and outcomes α (Definition 4, Section 4.1);variable (Definition 14, Section 6.1);– context-uniformly conditionally acyclic (cuc-acyclic) if it is locally consistent and for each outcome α ∈ V , J α(Γ ) is acyclic(Definition 15, Section 6.2).Then, Γ is locally consistent and fully acyclic⇒ Γ is context-uniformly conditionally acyclic⇒ Γ is strongly conditionally acyclic⇒ Γ is conditionally acyclic⇒ Γ is consistent⇒ Γ is locally consistent.Moreover, none of the implications are equivalences.Proof. If Γ is fully acyclic, i.e., G(Γ ) is acyclic, then J α(Γ ) is acyclic for any outcome α, since J α(Γ ) ⊆ G(Γ ). This showsthat if Γ is locally consistent and G(Γ ) is acyclic then Γ is context-uniformly conditionally acyclic. The other implicationsare from Propositions 22, 21, 12 and 9, respectively.The last part follows from Example 10 (where the cp-theory Γ is context-uniformly conditionally acyclic but not fullyacyclic), Example 11, Example 9, Example 6, and Example 2, respectively. (cid:2)N. Wilson / Artificial Intelligence 175 (2011) 1053–10911077Determining if Γ is strongly conditionally acyclic is a coNP-complete problem, as is determining if Γ is context-uniformly conditionally acyclic. It is straight-forward to see that these problems are in coNP. coNP-hardness can be shownusing a reduction from 3-SAT, with a similar construction to that used in the proof of Theorem 2 of [8], and for coNP-hardness of local consistency (Proposition 11).Proposition 24. The problem of determining if cp-theory Γ is strongly conditionally acyclic is coNP-complete, as is the problem ofdetermining if Γ is cuc-acyclic.Determining consistency of a cp-theory is PSPACE-complete [17,18]. We thus have both a necessary condition for con-sistency (local consistency) and a sufficient condition (strong conditional acyclicity) of much lower complexity.One might adapt the methods of Section 5 of [8] to check the context-uniformly conditionally acyclicity—and hence toshow the consistency—of certain forms of cp-theory Γ . It may also often be easy to confirm consistency of a cp-theory Γin a somewhat ad hoc manner, assuming that Γ is locally consistent (which will often be easy to confirm). We can definea simple set of rules that determine which variable gets picked at each point, in generating a cs-tree σ satisfying Γ . Forexample, suppose V = { X1, . . . , X8}; consider the following rules for the variable ordering, where e.g., X1 < X2 means thatX1 must always be picked earlier than X2:• X1 < X2 < { X3, X4, X5} < X6 < { X7, X8};• if x1 then X3 < X4 < X5;(cid:3)• if x1x2 then X5 < X4 < X3; else X5 < X3 < X4;(cid:3)• if x4x6 then X7 < X8, else X8 < X7.(cid:3)(cid:3)Given tuple a ∈ A, these rules determine a minimal variable in V − A, say Ya; for example, if a is the assignment x1x2then Ya = X5; we can also define the value ordering (cid:6) at any node in a simple way. This defines a compact representationfunction g with associated cs-tree σg (see Section 4.2). It is straight-forward to check if σg strongly satisfies Γ (that is, ifYa is always a-undominated). If so, then this proves that Γ is conditionally acyclic and hence consistent; we can also useσg to totally order a set of outcomes.In the next section a more formal way is developed of compactly representing the variable orderings for a search tree,and hence determining consistency, and enabling one to totally order outcomes in a way that is compatible with a cp-theory.7. Variable ordering networks as compact representations of satisfying cs-treesIt was shown in Section 4 how complete search trees can be used for the important tasks of confirming consistencyof a cp-theory Γ , and totally ordering a set of outcomes. In particular, if Γ happens to be strongly conditionally acyclicthen it is easy to define a cs-tree that (strongly) satisfies Γ (see Section 6.4). However, confirming the consistency of Γby constructing a cs-tree explicitly will usually not be feasible since the number of nodes is of the order of the number ofoutcomes |V |. Here we describe an often much more compact representation of certain cs-trees satisfying Γ . The idea is toturn the cs-tree into a directed acyclic graph (a decision diagram) by merging nodes where we can take the same decisionsregarding variables orderings from that point.The key to generating a cs-tree strongly satisfying cp-theory Γ is choosing an ar -undominated variable Y r for each bodynode r, where ar is the tuple of assignments made to instantiated variables (see Definition 13, Section 6.1); if there is such avariable for each body node, then we have shown that Γ is consistent, assuming local consistency. (Given local consistency(Definition 4, Section 4.1), choosing the node value ordering (cid:6)r is never a problem, since we just choose any strict totalorder extending the local ordering (cid:6)Ya , which is a strict partial order by local consistency.) Consider two nodes q and r(cid:3)are both assignments to some set of variables A. Suppose that a and awith associated tuples a and aare equivalent in the following sense: for any assignment b to any subset B of the remaining variables V − A, variable Yb-undominated. This means that we can make the same choices of a-undominatedis ab-undominated if and only if Y is avariables in nodes below q, as for nodes below r, or, more neatly, we can merge nodes q and r. We will define a graphicalstructure that enables us to assert such equivalences., where a and a(cid:3)(cid:3)(cid:3)In Section 7.1 we define a variable ordering network, which is a compact representation of the variable orderings inthe different branches of a cs-tree. In Section 7.2, variable ordering triples are defined, which are restrictions on variableorderings in a cs-tree or variable ordering network. In Section 7.3, sufficient conditions are defined for a variable orderingnetwork to satisfy a set of variable ordering triples, and in Section 7.4, we show how to generate a set of variable orderingtriples [Γ ] from a cp-theory Γ in such a way that a compatible variable ordering network will, given local consistency,generate a cs-tree satisfying Γ . Thus, if we can construct such a variable ordering network, we have proved consistency oflocally consistent Γ , and we can use the implicitly defined cs-tree to efficiently answer total ordering queries. Section 7.5gives a method of constructing a variable ordering network from [Γ ]. Section 7.6 shows how one can easily also generatean upper approximation of the preference relation from a variable ordering network.1078N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Fig. 3. A variable ordering network τ . The root node is at the top, and the sink node is at the bottom. The set of paths from the root to the sink are inone-to-one correspondence with the set of outcomes.7.1. Variable ordering networksThis section describes variable ordering networks, which are intended as compact representations of the variable order-ings in a cs-tree which (strongly) satisfies a given cp-theory. Let σ be a cs-tree and let α be an outcome. Write Oσ (α)for the ordering of variables on the path to α. The idea is to develop a compact representation for this variable orderingfunction Oσ . A variable ordering network is very similar to a cs-tree; however, we are only interested in representing thevariable orderings, so we do not include any value ordering information; we use a directed acyclic graph as a potentiallymuch more compact representation than a tree.Variable ordering networks (VONs) are defined first (Definition 18), and a VON is defined (Definition 19) to be compatiblewith a cs-tree if they induce the same variable ordering for any outcome. Proposition 25 shows that variable orderingnetworks and cs-trees represent the same set of variable ordering functions.Definition 18 (Variable ordering network (VON)). A variable ordering network over variables V is defined to be a directed acyclicand a sink node r∗, where nodes and edges have associated labels asgraph with two distinguished nodes, a root node rdefined below.∗Each directed edge e from node r to node ris associated with a variable Y e and a value ye of Y e (corresponding to theassignment Y e = ye ). We say that r(cid:3)is a child of r, and that r is a parent of r.(cid:3)(cid:3)Every node except the root node has a parent, and every node except the sink node has a child.Each node r has the following associated labels:(a) a set of variables Ar ⊆ V ;(b) an assignment ar to variables Ar (corresponding to the assignments in one of the paths to that node);(c) with the exception of the sink node: a variable Y r ∈ V − Ar (the next variable to be instantiated).For node r which is not the sink node we define its associated tuple to be (cid:18) Ar, ar, Y r(cid:19). It has |Y r| children, so has |Y r|edges coming from it. Each such edge e has associated variable Y e = Y r and a different associated value ye .If e goes from node r to rFor any node r(cid:3)(cid:3)then Ar(cid:3) = Ar ∪ {Y r}.which is not equal to the root, there exists some parent node r of rsuch that ar(cid:3) is equal to the tupleformed by extending ar with the assignment Y e = ye , where e is the edge from node r to rFor root node rThe sink node r∗ has associated tuple (cid:18) Ar∗ , α(cid:19), where α is some outcome and Ar∗ = V ., we define Ar∗ to be the empty set, and hence we have ar∗ equals (cid:5), the assignment to the empty set.∗(cid:3)(cid:3).Example 13. Fig. 3 illustrates a variable ordering network over the variables V = { X1, X2, X3, X4} in Example B in Sec-with associated tuple (cid:18)∅, (cid:5), X1(cid:19). The bottom node is the sink node r∗ withtion 3.2. The top node is the root node rassociated pair (cid:18)V , x1x2x3x4(cid:19). Note that, in contrast with cs-trees, some nodes have more than one parent.∗Let τ be a variable ordering network. For each outcome α, we can define a path from the root node to the sink nodeby following at each node r the edge corresponding to assignment Y r = α(Y r). In particular, each outcome generates anordering of the variables V . Conversely, each (directed) path from the root node to the sink node corresponds to an outcome.The set of paths from the root node to the sink node are in one-to-one correspondence with the set of outcomes.N. Wilson / Artificial Intelligence 175 (2011) 1053–10911079Let τ be a variable ordering network over variables V . Let α be any outcome. A variable ordering network τ generatesa total ordering Oτ (α) of the variables V , by following the assignments to variables made in α. For instance, if τ is thevariable ordering network in Fig. 3, then Oτ (x1x2x3x4) equals the ordering X1, X3, X2, X4 (following the left-hand edgesfrom the root node), and Oτ (x1x2x3x4) equals X1, X2, X3, X4.A variable ordering network can be viewed as a representation for the variable orderings used in a cs-tree.Definition 19. cs-tree σ and VON τ are said to be compatible if for all outcomes α, the ordering of variables in τ associatedwith α is the same as the ordering of variables in the path to α in cs-tree σ . In other words, if and only if Oτ = Oσ .The following result implies that variable ordering networks and cs-trees represent the same set of variable orderingfunctions.Proposition 25. Let σ be a cs-tree. There exists a variable ordering network compatible with σ . Conversely, if τ is a variable orderingnetwork then there exists some cs-tree compatible with τ .7.2. Variable ordering triplesA variable ordering triple (cid:18)u, Y , Z (cid:19) is intended as a restriction on the orderings in a cs-tree: it means that variable Yshould appear before variable Z on the path from the root to any outcome α which extends assignment u. (Variable orderingtriples are similar to ci-statements in TCP-nets—see Section 3.2.) A set of variable ordering triples is used to represent theconditions on variable orderings required for a cs-tree to strongly satisfy a cp-theory—see Section 7.4 below.Definition 20. A variable ordering triple (cid:18)u, Y , Z (cid:19) is an ordered triple where Y and Z are variables and u is an assignmentto a set of variables.Given a set of variable ordering triples T and a partial tuple a ∈ A (for some A ⊆ V ), we define Ta to be the set ofvariable ordering triples which are still relevant given a: we consider only triples (cid:18)u, Y , Z (cid:19) in T with u compatible with a,and we restrict such triples to V − A.Definition 21. Let T be a set of variable ordering triples, let a ∈ A be an assignment to a subset of V . Define Ta to be the(cid:3), Y , Z (cid:19) such that there exists triple (cid:18)u, Y , Z (cid:19) in T with Y , Z ∈ V − A, tuple u ∈ U is compatible with a,set of all triples (cid:18)u(cid:3)and u(U − A) = u.The first lemma is used to prove Lemma 17, which is a modularity property that we use in Section 7.3.Lemma 16. Let A and B be disjoint subsets of V , and let a ∈ A and b ∈ B. Let t be an assignment to some set of variables T ⊆V − ( A ∪ B), and let Y and Z be variables in V − ( A ∪ B). Let T be a set of variable ordering triples. Then (cid:18)t, Z , Y (cid:19) ∈ Tab if and onlyif there exists assignment u to some set of variables U ⊆ V − A such that (i) U − B = T , u(T ) = t, and u is compatible with b, and(ii) (cid:18)u, Z , Y (cid:19) is in Ta.Lemma 17. Let T be a set of variable ordering triples. Let A and B be disjoint subsets of V , and let a, aTab = Ta(cid:3)b.(cid:3) ∈ A and b ∈ B. If Ta = Ta(cid:3) thenProof. This follows immediately from the previous lemma. (cid:2)7.3. Sufficient conditions for a variable ordering network to satisfy a set of ordering triplesIn this section, a sufficient condition (see Definition 23 and Proposition 26) is given for a VON to satisfy the variableorderings conditions stipulated by a set of triples. A result, Proposition 27, is also included which will imply a limit on thesize of the VONs required to satisfy a cp-theory.A variable ordering network respects a variable ordering triple if the associated restriction on variable orderings isrespected.Definition 22. A VON τ respects a variable ordering triple (cid:18)u, Y , Z (cid:19) if Y appears before Z in Oτ (α) for all outcomes αextending u.We define a condition which is sufficient (see Proposition 26) for a variable ordering network to respect a set of variableordering triples; this condition can be enforced more easily.1080N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Definition 23. Let us say that VON τ is strongly compatible with set of variable ordering triples T if the following pair ofproperties holds:(i) for any node r of τ , if (cid:18)u, Y , Y r(cid:19) is in T and u is compatible with ar then Y ∈ Ar .(ii) Merging: suppose that r is a child of node r(cid:3), with the edge between them labelled with the assignment Y r(cid:3) = y. Extendassignment ar(cid:3) with assignment Y r(cid:3) = y to form assignment a to variables Ar . We have Ta = Tar .The following lemma is proved using Lemma 17, and is used to prove Proposition 26, showing that a variable orderingnetwork τ being strongly compatible with a set of ordering triples T implies that τ respects T .Lemma 18. Suppose that τ is strongly compatible with set of triples T and let r be any node of τ . Consider any path from the root tor with associated assignment a. Then Ta = Tar .Proposition 26. If variable ordering network τ is strongly compatible with set of ordering triples T then τ respects T .We finish this section with a result which limits the size of the variable ordering networks that we will need to use fora cp-theory Γ (see Section 7.5).For set T of ordering triples, define Q T ( A) to consist of all variables X ∈ A such that there exists some (cid:18)u, Y , Z (cid:19) in Twith Y , Z ∈ V − A and U (cid:17) X , where u is an assignment to variables U . Q T ( A) can be considered as the set of variables inA which are relevant for determining variable orderings outside of A.Proposition 27. Let T be a set of variable ordering triples on variables V , and let A be a subset of V . Suppose that a and aQ T ( A). Then Ta = Ta(cid:3) .(cid:3)agree on7.4. cp-theories and sets of variable ordering triplesFor a cp-theory Γ , we generate a set of variable ordering triples [Γ ] corresponding to Γ . We will show (Theorem 7)that if Γ is locally consistent and we can construct a variable ordering network which respects [Γ ] then Γ is consistent.This therefore gives an approach for showing consistency of cp-theories. A method for constructing [Γ ] is given below inSection 7.5.The idea is that we want to enforce the following property on a variable ordering network: for any ϕ ∈ Γ , and forany outcome α extending uϕ , variables U ϕ appear before Xϕ , and Xϕ appears before variables W ϕ on the path to α (cf.Proposition 18(1), Section 6.1). [Γ ] encodes this ordering information.Definition 24. Define [Γ ] to be the set of all triples (cid:18)u, Y , Z (cid:19) such that there exists ϕ ∈ Γ with uϕ = u and either(i) Y ∈ U ϕ and Z ∈ { Xϕ} ∪ W ϕ or(ii) Y = Xϕ and Z ∈ W ϕ .Example 14. Consider Γ in Example B in Section 3.2 (or see Example 15 below). Because Γ contains the statement ϕ =x1 : x2 > x2[{ X4}], (and x1 ∈ X1, and x2, x2 ∈ X2), [Γ ] contains, among others, the triples (cid:18)x1, X1, X2(cid:19), and (cid:18)x1, X1, X4(cid:19) (usingcase (i) of Definition 24), and also (cid:18)x1, X2, X4(cid:19) (using case (ii) of Definition 24). This ties in with the fact that if σ is anycs-tree which strongly satisfies Γ then, because of ϕ, X1 must come before X2 which must come before X4 on the path toany outcome α which extends x1 (see Proposition 18(1)).Lemma 19 shows that [Γ ] determines which variables are strongly a-undominated. This is used in the proof ofLemma 20, which gives a sufficient condition using [Γ ] for a cs-tree to strongly satisfy cp-theory Γ , and which is usedin the proof of Theorem 7.Lemma 19. For a ∈ A and Y ∈ V − A, Y is strongly a-undominated (with respect to Γ ) if and only if there does not exist (cid:18)u, Z , Y (cid:19) in[Γ ] with Z ∈ V − A and u compatible with a. This is also if and only if there does not exist any triple of the form (cid:18)u(cid:3), Z , Y (cid:19) in [Γ ]a.Lemma 20. Let Γ be locally consistent cp-theory, suppose that τ is a variable ordering network which respects [Γ ], and let σ be anycs-tree compatible with τ . Suppose also that for all body nodes r = (cid:18) A, a, Y , (cid:6)(cid:19) in σ , the associated strict total ordering (cid:6) extendslocal ordering (cid:6)Ya (see Definition 4). Then σ strongly satisfies Γ .Theorem 7. Let Γ be a cp-theory over variables V , and suppose there exists a variable ordering network τ which respects [Γ ]. If Γ islocally consistent then it is conditionally acyclic. Therefore, Γ is consistent if and only if it is locally consistent.N. Wilson / Artificial Intelligence 175 (2011) 1053–10911081Proof. By Proposition 25 (Section 7.1) there exists some cs-tree σ compatible with τ . Let r = (cid:18) A, a, Y , (cid:6)(cid:19) be any bodynode of σ . Local consistency of Γ implies that the local ordering (cid:6)Ya is a strict partial order. Redefine (cid:6) to be any stricttotal ordering extending (cid:6)Ya . By Lemma 20, cs-tree σ now strongly satisfies Γ , showing that Γ is conditionally acyclic andhence consistent, by Proposition 12 (Section 4.3). The last part follows because local consistency is a necessary condition forconsistency (Proposition 9, Section 4.1). (cid:2)Theorem 7, which is a kind of counterpart of Theorem 3 (Section 5.1), shows that if we can construct a variable orderingnetwork which respects [Γ ] for locally consistent cp-theory Γ , then we have proved that Γ is consistent. In Section 7.5we show one way of attempting to construct a variable ordering network which is strongly compatible with [Γ ] and hencerespects [Γ ], by Proposition 26.7.5. Generating a variable ordering network which respects [Γ ]In this section, we describe a method for constructing a variable ordering network τ (Γ ) that respects [Γ ], and hence, ifit succeeds, will prove that Γ is consistent if Γ is locally consistent (see Theorem 7).Label V as { X1, . . . , Xn}. To construct τ (Γ ) we first construct the (single) root node; then we iteratively construct thechildren of a node already constructed. As for cs-trees, for each node r we generate |Y r| directed edges from r, eachassociated with some value of variable Y r . Let a be ar extended with assignment y to Y r , and let A = Ar ∪ {Y r}. We checkif there is any node q already constructed with Aq = A and [Γ ]aq= [Γ ]a (this corresponds to the merging condition ofDefinition 23(ii)). If there is such a node q then we add a directed edge from r to q with associated value y of Y r .Suppose that there is no such node. If there is no strongly a-undominated variable in V − A then we say that theconstruction of τ (Γ ) fails, and we proceed no further; else we create a new node (cid:18) A, a, Xi(cid:19) (or the leaf node (cid:18) A, a(cid:19) ifA = V ) with Xi chosen with minimal i among the a-undominated variables in V − A.If the construction for τ (Γ ) does not fail, then we say that τ (Γ ) exists.Example 15. The algorithm will be applied for Γ in Example B in Section 3.2, which consists of the following preferencestatements: (cid:5) : x1 > x1[{ X2, X3, X4}]; x1 : x3 > x3[{ X2, X4}]; x1 : x2 > x2[{ X4}]; x1 : x2 > x2[{ X3, X4}]; x1 : x3 > x3[{ X4}];x3 : x4 > x4[∅]; and x3 : x4 > x4[∅]. We first generate the root node. To do this we need to choose a strongly (cid:5)-undominatedvariable. The only choice for this is X1, since the preference statement (cid:5) : x1 > x1[{ X2, X3, X4}] means that X2, X3 and X4are not strongly (cid:5)-undominated, by Lemma 9. Thus, the root node is (cid:18)∅, (cid:5), X1(cid:19).We then create edges corresponding to choices x1 and x1 for X1. Following the x1 edge, we need to choose an x1-undominated variable among { X2, X3, X4}. The only one is X3, because the preference statement x1 : x3 > x3[{ X2, X4}]means that X2 and X4 are not x1-undominated (given x1, X3 needs to come before X2 and X4). Thus, we create a node rwith tuple (cid:18){ X1}, x1, X3(cid:19).Following the edge from r associated with the choice x3 for X3 leads to the node q with tuple (cid:18){ X1, X3}, x1x3, X2(cid:19),since X2 is the only x1x3-undominated variable among { X2, X4}, because of the preference statement x1 : x2 > x2[{ X4}].Following the edge from r associated with the choice x3 for X3, let a be ar extended with assignment x3 to Y r (= X3), andlet A = Ar ∪ {Y r}, so that a = x1x3 and A = { X1, X3}; we find that A = Aq and [Γ ]a = [Γ ]aq , which consists of the singletriple (cid:18)(cid:5), X2, X4(cid:19). This means that the x3-edge from node r leads also to node q. (This relates to the merging condition inDefinition 23.)Continuing this process (and using the value ordering z before z, for z equalling each of x1, x2, x3 and x4) we generatethe variable ordering network in Fig. 3.Proposition 27 (Section 7.3) limits the possible size of the generated variable ordering network τ (Γ ). Q [Γ ]( A) consistsof all variables X ∈ A such that there exists some ϕ ∈ Γ such that U ϕ (cid:17) X and either (i) U ϕ (cid:3) A and { Xϕ} ∪ W ϕ (cid:3) A or(ii) Xϕ /∈ A and W ϕ (cid:3) A. For any given set of variables A the number of nodes r with Ar = A is at most exponential in|Q [Γ ]( A)| (rather than exponential in | A|).The following result shows that if Γ is strongly conditionally acyclic then the construction given above is bound tosucceed.Proposition 28. If Γ is a strongly conditionally acyclic cp-theory then τ (Γ ) exists.Proof. The definition of strongly conditionally acyclic cp-theory ensures that for any a ∈ A there exists an a-undominatedvariable in V − A. This implies that the construction does not fail at any point. (cid:2)Proposition 29 below shows that if we find that τ (Γ ) exists for locally consistent Γ then we have proved the consis-tency of Γ . Furthermore, Proposition 28 shows that if Γ happens to be strongly conditionally acyclic cp-theory, then theconstruction given above is bound to succeed, and hence will correctly determine (by Theorem 7) that Γ is consistent.Proposition 29. Let Γ be a cp-theory, and suppose that τ (Γ ) exists. Then τ (Γ ) respects [Γ ]. Also, Γ is consistent if and only if it islocally consistent.1082N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Proof. The construction of τ (Γ ) ensures that it is strongly compatible with [Γ ]: Lemma 19 ensures that condition (i) ofDefinition 23 holds, and condition (ii) clearly holds. Hence, by Proposition 26, τ (Γ ) respects [Γ ]. By Theorem 7 (Section 7.4),Γ is consistent if and only if it is locally consistent. (cid:2)The variable ordering network τ (Γ ) for Example B (in Section 3.2) has only seven nodes (see Example 15 and Fig. 3)as opposed to the 31 nodes in the corresponding cs-tree σ (Γ ). More generally, one would expect when there are only afew variations in importance orderings, that the variable ordering network would be compact. Also the number of variableorderings associated with a variable ordering network can be exponential in the number of nodes, as the network ‘factorises’the variable orderings, so even if we need many different orderings in different paths in a cs-tree, the variable orderingnetwork may still be small, thus enabling consistency to be efficiently checked.7.6. Generating an upper approximation from a variable ordering networkFrom locally consistent cp-theory Γ and variable ordering network τ which respects [Γ ] we can generate in a simpleway a polynomial upper approximation for the preference relation >Γ , which can be used for ordering and optimisationtasks as shown in Section 4.Define irreflexive relation (cid:16)Γτ as follows. Consider two different outcomes α and β. Follow the assignment of α along theedges in τ from the root until a node r is reached such that α and β differ on Y r , so that α( Ar) = β( Ar) and α(Y r) (cid:13)= β(Y r).As for cs-trees, we call this node, the node that divides α and β. Define α (cid:16)Γar β(Y r) holds(see Definition 4).τ β to hold if and only if α(Y r) (cid:6)YrTheorem 8 below shows that (cid:16)Γa are alltotal orders then (cid:16)Γis a strict total order, so would then not be useful for generating more than one optimal solutionτof a constrained optimisation problem. (cid:16)Γτ will tend to be a cruder approximation of >Γ than the other two upperapproximations defined in the paper (in Sections 5.2 and 6.3). To prove Theorem 8 we use a similar technique as weused for proving Theorems 4 and 5, by showing that (cid:16)Γτ is indeed an upper approximation for >Γ . Note that if the local orderings (cid:6)Yτ is the intersection of a set of cs-tree orders.Lemma 21. Let Γ be locally consistent cp-theory, and let τ be a variable ordering network which respects [Γ ]. Let Q be the set ofcs-trees σ which are compatible with τ and such that for all body nodes r = (cid:18) A, a, Y , (cid:6)(cid:19) in σ , the associated strict total ordering (cid:6)extends local ordering (cid:6)Yτ β if and only if α >σ β for all σ ∈ Q.a . Then α (cid:16)ΓThis implies that (cid:16)Γτ is an upper approximation of the preference relation >Γ :Theorem 8. Let Γ be a locally consistent cp-theory, and let τ be a variable ordering network that respects [Γ ]. Then (cid:16)Γpartial order, and (cid:16)Γmation of the preference relation >Γ .τ β holds for any outcomes α and β such that α >Γ β. Hence, (cid:16)Γτ contains >Γ , i.e., α (cid:16)Γτ is a strictτ is an upper approxi-Proof. Lemma 21 implies that (cid:16)Γτstrongly satisfies Γ , so σ satisfies Γ , by Proposition 19, Section 6.1. Proposition 15 (Section 4.4) then implies that (cid:16)Γstrict partial order containing >Γ . (cid:2)is the intersection of relations >σ over cs-trees σ in Q. By Lemma 20, each such στ is a8. Related workThe work described here—which is based on and develops the papers [32,31]—builds very much on the fundamentalwork on CP-nets, as described especially in [3] and [4], as well as on other work by the authors (Boutilier, Brafman, Domsh-lak, Hoos and Poole) of these papers, such as [12,6,11,5,9,10,8]; indeed one of the main initial motivations of the currentwork was to show how CP-nets approaches could be generalised to a richer language.Although most work has focused on acyclic CP-nets, this is a strong restriction, limiting their potential applicability. Foranalysis and discussion of non-acyclic CP-nets see Chapter 6 of [11], Section 4 of [12], [9, Section 4], [17] and [35]. One ofthe motivations for the work in this paper on determining consistency of a cp-theory is the hardness complexity results forthis task for CP-nets: see [11,12,17,18].Logic-based formalisms for comparative preferences, that also emphasise the importance of ceteris paribus interpretations,include [29,30,19–21,28] from the Philosophy literature, as well as [15,26,27,23,24,1] in the AI literature. The preferencestatements in this paper are of the form u : x > xof a single (not-necessarily Boolean)variable X , conditional on a partial assignment u, and irrespective of variables W , where the other variables are treatedin a ceteris paribus manner. Other logic-based formalisms allow preferences between arbitrary propositional formulae, andvary on the interpretation of ceteris paribus. Formalisms defined in [24] (Definition 4) and [28,1] also allow irrespectivestatements, with the latter formalisms being especially expressive.(cid:3)(cid:3)[W ], focusing on the values x and xOne of the main tasks that this paper is concerned with is totally ordering the outcomes in a way that is compatible withthe cp-theory’s preference ordering. The work here is most closely related to that on ordering queries in [4], and the use ofsearch trees in [4,5,8] for CP-nets and TCP-nets. However, another kind of approach to this problem is to construct a valueN. Wilson / Artificial Intelligence 175 (2011) 1053–10911083function or utility function on the set of outcomes (i.e., a function that assigns a number to each outcome) whose orderingis compatible with the preference relation. Work of this kind for acyclic CP-nets includes UCP-nets [2], soft constraintsmethods [14,13], and [7]. An advantage of the search tree approaches over value function approaches is that it’s easier togenerate outcomes in decreasing preference order.The upper approximation for the case of fully acyclic cp-theories (see Section 5.2) generalises the relation (cid:16) defined forordering queries in [4] for acyclic CP-nets, and this kind of approximation has also been considered in [22]. Another upperapproximation, for cp-theories, is defined in [33], and is generalised to more expressive preference languages in [34].9. Summary and discussionThis paper has defined a formalism, cp-theories, that is a simple logic of comparative preferences, and basic formalproperties are shown (Section 2). The relationship with CP-nets and TCP-nets has been analysed, regarding what can andcannot be expressed (Section 3). It is shown that cp-theories are, in a particular precise sense, more general than CP-netsand TCP-nets, and that they can represent natural statements that cannot be expressed by CP-nets and TCP-nets, such asthose used in a lexicographic order. A result is also included showing that, for each n, there is essentially a unique acyclicCP-net on n Boolean variables that totally orders the outcomes.Much of the paper (Sections 4, 5, 6 and 7) is dedicated to the related problems of determining consistency of a cp-theory, and totally ordering a set of outcomes in a way that is compatible with the cp-theory preference relation. Thelatter is a key basic task that can be used, in particular, for choosing the outcomes that are displayed first to the user.The approaches developed cover non-acyclic as well as acyclic cases of cp-theories, which means that the methods can beapplied to non-acyclic CP-nets and TCP-nets; this is important since non-acyclic sets of preference statements can easilyarise—there’s nothing irrational about them.Inconsistency indicates incoherence within the input preference statements, which could, for example, be because of theelicited statements not reflecting the user’s preferences; hence the importance of being able to check consistency. However,determining consistency of a cp-theory (or a CP-net) is an extremely hard problem, so it is desirable to find incompletemethods that can sometimes prove consistency or prove inconsistency. A simple necessary condition for consistency isdefined, called local consistency (Section 4.1); testing local consistency will often be easy (in particular if the parents set U Xof each variable X is small); inconsistency can thus sometimes be proved by showing local inconsistency. If the cp-theoryis fully acyclic then consistency holds if and only if local consistency holds (Section 5). In Section 6, sufficient conditionsare derived for consistency which have much lower complexity, specifically, strong conditional acyclicity (Section 6.1) andcuc-acyclicity (Section 6.2).The approaches for confirming consistency and for ordering tasks are based on complete search trees (cs-trees), similarto those used for depth-first search for a solution of a constraint satisfaction problem. A sufficient condition for consistencyof a cp-theory Γ is that there is a cs-tree satisfying Γ . If one is looking to show that there exists a cs-tree satisfying locallyconsistent Γ , it is sufficient to satisfy certain constraints that Γ imposes on the variable orderings that appear in branchesof the cs-tree (see e.g., Proposition 18, Section 6.1).Explicitly constructing a cs-tree will not be possible, unless the number of variables is small, since its size is linear inthe number of outcomes. Different compact representations of a satisfying cs-tree are derived, for expressing the variableorderings of a search tree. Of particular note is the variable ordering network, defined in Section 7, which uses a decisiondiagram representation for the variable orderings. These compact representations of a cs-tree thus can allow consistency ofa cp-theory to be determined, and ordering tasks to be performed in an efficient way.Unconstrained optimisation reduces (just like for the case of CP-nets) to solving a constraint satisfaction problem. Poly-nomial upper approximations of the preference relation have been derived (in Sections 5.2, 6.3 and 7.6), and we show howthey can be useful for generating, in a relatively efficient way, a set of optimal solutions of a constraint satisfaction problem(see Section 4.5).There are many directions in which this work might usefully be extended and developed; we list some of these.• The language of conditional preferences only allows preferences of a single variable (conditional on other variables);some natural preference statements involve preferences over more than one variable, so it would be desirable to con-sider more general languages, in particular, on the lines of the languages considered in [24,27] and [34], and to see towhat extent the methods of this paper can be extended.• The idea of a cs-tree can be extended to include partially completed search trees. An upper approximation can bedefined from this that is a closer approximation of the preference relation >Γ than ones defined in this paper [33];this might be used, in conjunction with the cs-tree methods developed here, for constrained optimisation. In addition,propagation methods for improving the efficiency of constrained optimisation might be developed, in order to prunesubtrees of the search tree which only contain outcomes that are dominated—with respect to the appropriate upperapproximation—by a solution we’ve already found.• The compact representation of variable orderings developed in Section 7 could be made yet more compact if weakerconditions for merging (see Section 7.5) are used when generating the variable ordering network.• This paper hasn’t addressed the important (but very hard [4,12,18]) problem of dominance testing; approaches in Sec-tion 5 of [4] and Proposition 8 of [32] can be developed for more general cp-theories.1084N. Wilson / Artificial Intelligence 175 (2011) 1053–1091AcknowledgementsThis material is based upon works supported by the Science Foundation Ireland under Grant No. 05/IN/I886 and GrantNo. 08/PI/I1912. Thanks also for the referees for their constructive comments which helped improve the paper.Appendix A. ProofsProof of Lemma 1. (i) If there exists a cycle in (cid:6) ∪ {(β, α)} then, since (cid:6) is acyclic, β, α must appear in the cycle. We thushave a sequence α (cid:6) · · · (cid:6) β and so α (cid:6) β by transitivity, which contradicts the hypothesis.(ii) If strict partial order (cid:6) is not already a (strict) total order, there exists some pair α, β of different elements such thatneither α (cid:6) β nor β (cid:6) α. Arbitrarily choose such a pair. Let (cid:6)(cid:3)is a strictpartial order strictly containing (cid:6). Iterating this we eventually generate a strict total order containing (cid:6). (iii) follows from(ii) by first taking the transitive closure to generate a strict partial order. (iv) easily follows from (iii).be the transitive closure of (cid:6) ∪ {(β, α)}. By (i), (cid:6)(cid:3)(v) Clearly, (cid:6) is a subset of the intersection of all strict total orders containing it. To prove the converse, it is sufficientto show that if it is not the case that α (cid:6) β then (α, β) is not in the intersection of all strict total orders extending (cid:6), i.e.,there exists some strict total order > extending (cid:6) with α ≯ β. So, suppose that it is not the case that α (cid:6) β. If α = β thenthe implication follows immediately, so let us assume that α (cid:13)= β. By (i), (cid:6) ∪ {(β, α)} is irreflexive and acyclic, so by (iii),there exists strict total order > extending (cid:6) ∪ {(β, α)}, so β > α, and hence α ≯ β, as required. (cid:2)Proof of Lemma 2. (i) We have that > |(cid:11) Γ if and only if > ⊇ Γ ∗>Γ , the transitive closure of Γ ∗., which, since > is transitive, is if and only if > contains(ii) Γ is consistent if and only if there exists some strict total order > extending Γ ∗, which, by Lemma 1(iv) is if andonly if Γ ∗is acyclic. Γ ∗is acyclic if and only if its transitive closure >Γ is irreflexive, and hence is a strict partial order.(iii) If Γ is consistent then, by (ii), >Γ is a strict partial order, and so, by Lemma 1(v), is equal to the intersection of allstrict total orders extending it, i.e., by (i), the intersection of all strict total orders satisfying Γ .(iv) Suppose that Γ is consistent. Γ |(cid:11) (α, β) if and only if α > β holds for all strict total orders > satisfying Γ , whichis if and only if the intersection of all strict orders satisfying Γ contains the pair (α, β), which, by (iii), is if and only ifα >Γ β.(v) Suppose that Γ is consistent. Γ |(cid:11) ϕ holds if and only if > extends ϕ∗is if and only if the intersection of all strict total orders satisfying Γ is a superset of ϕ∗>Γ ⊇ ϕ∗. (cid:2)for all strict total orders > satisfying Γ , which, which, by (iii), is if and only ifProof of Proposition 2. Let > be an arbitrary strict total order on the set V of outcomes.• Let X ∈ V , u ∈ U X , and x, x(cid:3)for all t ∈ T tux > tuxconditional preference table if and only if > satisfies the cp-theory Γcp.(cid:3) ∈ V be such that x (cid:6) X, where T = V − { X} − U X , which is if and only if > satisfies (cid:6) X. > satisfies the cp-theory statement u : x > x(cid:3)[∅] if and only ifu . Therefore, > satisfies the(cid:3)u x(cid:3)• > satisfies Γ X→Y if and only if for all u ∈ U X and x and xsuch that x (cid:6) X(cid:3)u xi.e., for all y, yi-arc X → Y . Hence, > satisfies all the i-arcs of N if and only if > satisfies Γi.(cid:3) ∈ Y and for all assignments r to V − { X, Y } extending u, rxy > rxholds, we have > satisfies u : x > x(cid:3)[Y ],. This is if and only if > satisfiesy(cid:3)(cid:3)(cid:3)u x• > satisfies Γ X→s Y if and only if > satisfies qs : x > x(cid:3)x (cid:6) Xholds, where u is qs restricted to U X . This holds if and only if rsxy > rsx(cid:3)such that x (cid:6) Xassignments r to V − S X,Y − { X, Y }, for all x, x> satisfies the ci-statement X →s Y . Hence, > satisfies all the ci-statements in N if and only if > satisfies Γci.such that(cid:3) ∈ Y , for all, where u is rs restricted to U X . This is if and only if(cid:3)(cid:3)[Y ] for all assignments q to U X − S X,Y and all x, xholds for all y, y(cid:3)u xy(cid:3)Putting these together, > satisfies the TCP-net N if and only if > satisfies the cp-theory ΓN . Therefore, N is satisfiable ifand only if ΓN is consistent.Furthermore, if N is satisfiable (and so ΓN is consistent), >N is the intersection of all strict total orders satisfying N, i.e.,the intersection of all strict total orders satisfying ΓN , which equals >ΓN by Lemma 2(iii). (cid:2)Proof of Proposition 3. We’ll show that >Γ equals >lex by showing that Γ ∗have >Γ , the transitive closure of Γ ∗is equal to >lex.equals >lex. Because >lex is transitive we thenTo show Γ ∗ ⊆ >lex: suppose (α, β) ∈ Γ ∗. Then for some i, (α, β) ∈ (Γi)∗(cid:3)(cid:3)[{ Xi+1, . . . , Xn}] in Γi with α( Xi) = x, β( Xi) = xxas required.and for all, so there exists statement (cid:5) : x >j < i, α( X j) = β( X j). We have α( Xi) >i β( Xi) so α >lex βTo prove the converse, suppose α >lex β. Then for some i ∈ {1, . . . , m} we have α( Xi) >i β( Xi) and for all j < i, α( X j) =(cid:3) = β( Xi). Since ϕ ∈ Γ ,(cid:3)[{ Xi+1, . . . , Xn}], with x = α( Xi) and xwhere ϕ is the statement (cid:5) : x > xβ( X j). But then (α, β) ∈ ϕ∗we have (α, β) ∈ Γ ∗. (cid:2)Proof of Lemma 3. All three parts follow easily from the appropriate completeness theorems for swapping/flipping se-quences. However, to make the presentation more self-contained, we instead use Propositions 1 and 2 in Section 3.1 andSection 3.2 for (ii) and (iii), respectively.N. Wilson / Artificial Intelligence 175 (2011) 1053–10911085The first part follows immediately from Theorem 1: α >Γ β implies that there exists a worsening swapping sequencefrom α to β; but since α covers β, there can be no element in the sequence between α and β, so there is a worseningswap from α to β.(ii) If a CP-net N is unsatisfiable then (cid:6)N degenerates to V × V , which implies that no outcome covers any otheroutcome. (The same applies to TCP-nets.) Suppose α covers β with respect to (cid:6)N . CP-net N is then satisfiable, so (cid:6)N equals(cid:3)[W ] be the>ΓN by Proposition 1. Part (i) implies that there exists a worsening swap from α to β for ΓN . Let u : x > xrelevant element of ΓN used for this swap. The form of ΓN implies that W = ∅, and so α and β differ on X and agree onall other variables.The proof of (iii) is almost the same as that for (ii). Let N be a TCP-net, and suppose that α covers β with respect to(cid:6)N . N is then satisfiable, so (cid:6)N equals >ΓN , by Proposition 2. Part (i) implies that there is a worsening swap from α to β(cid:3)[W ] be the relevant element of ΓN used for this swap. The form of ΓN implies that W is empty or afor ΓN . Let u : x > xsingleton, so α and β differ on at least one variable ( X ) and at most two variables. (cid:2)Proof of Proposition 5. Suppose to the contrary that there exists order >1 on X1 such that X1 dominates { X2, . . . , Xn} withrespect to ((cid:6)N , >1). Write >2 for the total order on X2 given in the specification of the CP-net (it is unconditional, as X2has an empty set of parents).Because >1 is non-empty we can choose α, β ∈ V such that α( X1) >1 β( X1) and β( X2) >2 α( X2). Because α( X1) >1β( X1) we have α (cid:6) β, by the dominance of X1. Therefore, there exists a sequence α = α1, . . . , αk = β of outcomes suchthat, for i = 1, . . . , k − 1, there is a worsening flip from αi to αi+1. For each i we must either have αi( X2) = αi+1( X2) orαi( X2) >2 αi+1( X2). This implies that either α1( X2) = αk( X2) or α1( X2) >2 αk( X2); but neither of these are possible asαk( X2) = β( X2) >2 α( X2) = α1( X2). (cid:2)Proof of Proposition 6. Let x1 be the >1-maximal element in X1. Let α be a (cid:6)M -minimal element in A = {α : α( X1) = x1}(this exists because (cid:6)M is acyclic), and let β be a (cid:6)M -maximal element in B = V − A = {β : x1 >1 β( X1)}. Since α( X1) >1β( X1), by the dominance of X1 we have α (cid:6) β. Furthermore, if γ (cid:13)= α, β then either γ ∈ A and so it is not the case thatα (cid:6) γ , or γ ∈ B and it is not the case that γ (cid:6) β. This shows that there does not exist γ with α (cid:6) γ (cid:6) β, proving that αcovers β with respect to (cid:6)M . By Lemma 3(iii), it must then be the case that α and β differ on at most two variables; wewill obtain the required contradiction by showing that α and β differ on at least three variables.(cid:3)We have α( X1) (cid:13)= β( X1). Suppose α( X2) = β( X2); call this element x2, and let x2 be any other element of X2. Since X2(cid:3)(cid:3)2; or (b) have some CP statement (cid:5) : xhas no parents, we either (a) have some CP statement (cid:5) : x2 > x2 > x2. If (a) there isa worsening flip from α to some element α(cid:3) ∈ A, and so α (cid:6) α(cid:3), contradicting the definition of α. If (b) we can perform animproving flip on β to produce β(cid:3) ∈ B with β(cid:3) (cid:6) β, contradicting the definition of β. Therefore, α( X2) (cid:13)= β( X2).We can use exactly the same argument to show that α( X3) (cid:13)= β( X3), so α and β differ on at least three variables, whichis the contradiction required. (cid:2)(cid:3)(cid:3)Proof of Lemma 4. (a) (cid:6)N(cid:3) is transitive by its construction. We just need to show that it is irreflexive and complete (i.e., forall outcomes α and β, either α = β or α (cid:6)N(cid:3) β or β (cid:6)N(cid:3) α).Suppose that δ (cid:6)N(cid:3) δ for some δ ∈ V − {Z }. Then there exists a worsening flipping sequence from δ to δ in N. Let δ0 beδ extended with the assignment Z = 0. Applying the same flips yields a worsening flipping sequence for N from δ0 to δ0,showing that δ0 (cid:6)N δ0, contradicting the assumption that (cid:6)N is a strict total order.Consider any two different elements δ and (cid:13) of V − {Z }. Extend each of these to an element of V by assigning Z = 0,leading to outcomes δ0 and (cid:13)0, respectively. Since (cid:6)N is a strict total order, we either have δ0 (cid:6)N (cid:13)0 or (cid:13)0 (cid:6)N δ0. Withoutloss of generality, assume that δ0 (cid:6)N (cid:13)0. There exists a worsening flipping sequence for N from δ0 to (cid:13)0. Removing any flipsof Z generates a worsening flipping sequence for Nfrom δ to (cid:13), proving δ (cid:6)N(cid:3) (cid:13) and hence completeness.(b) First suppose that α (cid:6)N β, so that there exists a worsening flipping sequence for N from α to β. By ignoring flipsfrom α(V − {Z }) to β(V − {Z }), showing that α(V − {Z }) (cid:6)N(cid:3)of Z we can generate a worsening flipping sequence for Nβ(V − {Z }). The converse then follows immediately from the fact that (cid:6)N and (cid:6)N(cid:3) are strict total orders: for if α (cid:6)N β doesnot hold then β (cid:6)N α holds, implying β(V − {Z }) (cid:6)N(cid:3) α(V − {Z }) and hence α(V − {Z }) (cid:6)N(cid:3) β(V − {Z }) does not hold.(c) Suppose that α and β differ on Z and agree on all other variables, but that α and β are not consecutive with respectto (cid:6)N . Since (cid:6)N is a total order, there exists γ ∈ V , different from α and β, with either α (cid:6)N γ (cid:6)N β or β (cid:6)N γ (cid:6)N α.Without loss of generality, assume α (cid:6)N γ (cid:6)N β. Since Z has only two values, γ must differ with α and β on V − {Z }.There exists a worsening flipping sequence for N from α to β passing through γ . By ignoring flips of Z we can generate afrom α(V − {Z }) to β(V − {Z }) = α(V − {Z }), which contradicts the irreflexivity of (cid:6)N(cid:3)worsening flipping sequence for Nshown in (a).If outcomes δ and γ differ on Z but agree on all other variables, write δ = γ and γ = δ (recall that Z has only twovalues). The first part implies that α1 and α1 are consecutive, so α2 = α1. Similarly, α3 and α3 are consecutive, so α3 equalsα2 or α4. But α3 = α2 would imply α3 = α1 (since Z has only two values), so we must have α3 = α4. Continuing this showsthat for all j = 1, 2, . . . , K2 , α2 j = α2 j−1. and so α2 j−1 and α2 j agree on V − {Z }.(d) Suppose that α1(Z ) = 1. Since Z takes two values, for each element α of V , there exists exactly one other elementof V which agrees with α on V − {Z }. By part (c), α1 and α2 agree on V − {Z } and so differ on Z (otherwise they would(cid:3)(cid:3)1086N. Wilson / Artificial Intelligence 175 (2011) 1053–1091be the same outcome). Similarly, for all j = 1, 2, . . . , K /2, outcomes α2 j−1 and α2 j agree on V − {Z } and so differ on Z . α2and α3 differ on V − {Z }; they are consecutive so there exists a worsening flip from α2 to α3; thus, they differ on exactlyj = 1, 2, . . . , outcomes α2 j and α2 j+1 agree on Z . We thus have theone variable, and hence agree on Z . Similarly, for allsequence of values of Z being 1, 0, 0, 1, 1, 0, 0, 1, 1, and so on. (cid:2)Proof of Proposition 7. We show this by induction on n. This is clearly true for n = 1, since there is only one strict totalorder satisfying property (i). Suppose it is true for n = k. We will show that it holds also for n = k + 1, hence implying thatit is true for all natural numbers n. Suppose that >1 and >2 are both strict total orders on V corresponding to CP-nets N1(cid:3)(cid:3)2 be the associated CP-nets on { X1, . . . , Xk} defined inand N2, respectively, satisfying properties (i) and (ii). Let N1 and NLemma 4. By Lemma 4(a), (cid:6)(cid:3)1are both strict total orders, so, by induction, are equal.Lemma 4(b), (c) and (d) then imply that (cid:6)N1 and (cid:6)N2 are equal: by Lemma 4(b), if α, β ∈ V differ on V − {Z } thenα (cid:6)N1 β if and only if α(V − {Z }) (cid:6)β(V − {Z }) if and only if α (cid:6)N2 β. If differentoutcomes α, β ∈ V agree on V − {Z } then by Lemma 4(c) they are consecutive in the orderings (cid:6)N1 and (cid:6)N2 . Lemma 4(b)and the fact that (cid:6)are equal implies that the ordering of {α, β} relative to the other outcomes is the same in(cid:6)N1 and (cid:6)N2 . Lemma 4(d) then implies that both (cid:6)N1 and (cid:6)N2 order α and β the same way, i.e., α (cid:6)N1 β ⇐⇒ α (cid:6)N2 β.Therefore, >1 equals >2, completing the inductive step. (cid:2)β(V − {Z }) if and only if α(V − {Z }) (cid:6)and (cid:6)and (cid:6)(cid:3)2(cid:3)2(cid:3)1(cid:3)2(cid:3)1NNNNNNProof of Proposition 8. This CP-net N can be restricted to a CP-net Ni on V i for 1 (cid:3) i (cid:3) n, where Nn = N. We shall proveby induction that (cid:6)Ni is a strict total order on V i with maximum element (1, . . . , 1) for each i = 1, . . . , n, proving that (cid:6)N(i.e., (cid:6)Nn ) is a strict total order.The base case: i = 1. Then 1 (cid:6) X1(cid:5) 0 since (cid:5) contains an even number of zeros, as it contains no zeros. Hence, 1 (cid:6)Ni 0and it is not the case that 0 (cid:6)Ni 1, so (cid:6)Ni is a strict total order.(cid:3)or vSuppose, by induction, that (cid:6)Ni−1 is a strict total order with maximum element (1, . . . , 1); we need to show that (cid:6)Niis a strict total order with maximum element (1, . . . , 1). Consider any v, v. We will prove that either(cid:3) (cid:6)Ni v. This implies that there is at most one model satisfying Ni . Acyclicity implies that Ni has at least onev (cid:6)Ni vmodel (see Theorem 1 of [4]), so has exactly one model, which is then equal to (cid:6)Ni . This implies that (cid:6)Ni is a strict totalorder; Lemma 4(b), (c), (d) and the inductive hypothesis can then be used to show that the maximum element is (1, . . . , 1),completing the inductive step.Case (i) v(V i−1) = v(cid:3)(V i−1) which equals u, say. Then v and v(cid:3) ∈ V i with v (cid:13)= vdiffer on only one variable, Xi , and v( Xi) = 1 andu 1, which implies that either u1 (cid:6)Ni u0 or u0 (cid:6)Ni u1, so eitheru 0 or 0 (cid:6) Xi(cid:3)(cid:3)(cid:3)( Xi) = 0 or vice versa. We either have 1 (cid:6) Xivv (cid:6)Ni v(cid:3) (cid:6)Ni v.or v(cid:3)(cid:3)(cid:3)(cid:3)Case (ii) v(V i−1) (cid:13)= v(cid:3)(V i−1). Let u = v(V i−1) and u(cid:3) = vvice versa. Assume without loss of generality that u (cid:6)Ni−1 uand define vor v (cid:6)Ni v(cid:3)(cid:3). Putting these together will imply by transitivity that v (cid:6)Ni vto be u(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(V i−1). By the inductive hypothesis we have either u (cid:6)Ni−1 ube minimal, with respect to (cid:6)Ni−1 , such that u. Let u(cid:3)or(cid:3)(cid:3)(cid:3) (cid:6)Ni−1 u,(cid:3)(cid:3)and (b) either v = v(cid:3)(cid:3) (cid:6)Ni v(cid:3)extended with the assignment v( Xi) to Xi . We shall show that (a) v, as required.(cid:3)(cid:3)(cid:3)(cid:3)To show (a): since ucovers u(cid:3)(cid:3)apply this worsening flip to get u0 (cid:6)Ni ucontains an odd number of zeros, since they differ on precisely one variable, and so 0 (cid:6) Xiand so u(cid:3)(cid:3)(cid:3)1 (cid:6)Ni u0 (cid:6)Ni u0 (cid:6)Ni u(cid:3)(cid:3)To show (b): If v (cid:13)= v, by Lemma 3 (Section 3.3), there exists a worsening flip from u1 (cid:6)Ni u(cid:3)1, which implies that v(cid:3)(cid:3)so u (cid:6)Ni−1 uthen u (cid:13)= u, as required. A similar argument applies if 0 (cid:6) Xi. We can alsomust contain an even number of zeros,u(cid:3) 1. This implies thatu(cid:3)(cid:3) 1., using the fact that (cid:6)Ni−1 is a strictand u (cid:6)Ni−1 u. The same sequence of flips can be used from v tocovers u(cid:3)(cid:3)total order. So, there exists a worsening sequence of flips from u to uvu(cid:3)(cid:3) 0 then u0. If 1 (cid:6) Xi(cid:3)(cid:3) (cid:6)Ni v, since u1 and u, showing that v (cid:6)Ni v. (cid:2)to uu(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)Proof of Proposition 11. The problem is in coNP since if Γ is not locally consistent we can non-deterministically choose αand X such that (cid:6) Xα (which can be computed in polynomial time) is not irreflexive, i.e., there exists x ∈ X with x (cid:6) Xα x.(cid:3)To show coNP-hardness we can use a reduction from 3-SAT. Consider an instance of 3-SAT with m clauses involving3. We generate a cp-theorypropositional variables V: zk−1 > zk[∅],Γ as follows: let V be Vfor j = 1, 2, 3, and let Γ be Γ1 ∪ · · · ∪ Γm ∪ {(cid:5) : zk > z0[∅]}. Then Γ is not locally consistent if and only if there exists anj , which is ifassignment u to Vand only if u satisfies the 3-SAT instance. (cid:2). For k = 1, . . . , m, let ck be the kth clause, which we write as lk1(cid:3) ∪ {Z } where Z has domain {z0, . . . , zm}. Let Γk consist of the three statements lku not irreflexive, which is if and only if for each k there exists j with u satisfying lkwith (cid:6) Z∨ lk2∨ lk(cid:3)jfor all ϕ ∈ Γ . Consider any (α, β) ∈ ϕ∗Proof of Proposition 13. Sufficiency of (1) and (2): We need to show that >σ ⊇ ϕ∗.α and β are different outcomes, so there exists some node r of σ that divides them. α |(cid:11) uϕ so, by (1), on the path to α,Xϕ appears before all of W ϕ . This implies that Y r = Xϕ , since α and β only differ on { Xϕ} ∪ W ϕ , and certainly differ on(cid:3)Xϕ . Since α |(cid:11) uϕ, ar , tuples uϕ and ar are compatible so, by (2), xϕ (cid:6)r x), whichshows that α >σ β, i.e., (α, β) ∈ >σ . Since (α, β) is an arbitrary element of ϕ∗, and ϕ is an arbitrary element of Γ , wehave that >σ ⊇ ϕ∗ϕ , i.e., α( Xϕ) (cid:6)r β( Xϕ) (since (α, β) ∈ ϕ∗for all ϕ ∈ Γ .N. Wilson / Artificial Intelligence 175 (2011) 1053–10911087Conversely, we need to prove the necessity of (1) and (2). Necessity of (1): Suppose that ϕ ∈ Γ and α |(cid:11) uϕ , but thatthere exists some Y ∈ W ϕ which appears before Xϕ on the path to α. Let r be the node with Y r = Y . Since Y has at least(cid:3)and β as follows: α(cid:3)( Xϕ) = xϕ , β( Xϕ) = xtwo values, we can choose values y, yϕ ,and β, so α(cid:3) ≯σ β,α(cid:3)(Y ) = y, since α |(cid:11) uϕ and hence α(cid:3), β |(cid:11) uϕ (using the fact that U ϕ is disjoint fromsince α(cid:3)(Y r) (cid:4)r β(Y r). However, (α(cid:3), β) ∈ ϕ∗{ Xϕ} ∪ W ϕ , and so α(cid:3), and so it is not the case that >σ satisfies Γ ,proving the necessity of (1).(cid:3), β(Y ) = y, and for all other variables Z (cid:13)= Xϕ, Y define α(cid:3)(Z ) = β(Z ) = α(Z ). Then r divides α(cid:3)and β agree with α on U ϕ ). Therefore, >σ (cid:5) ϕ∗. Define outcomes α(cid:3)of Y with y (cid:6)r y(cid:3)(cid:3)Necessity of (2): Suppose that σ satisfies Γ , and that for node r, and ϕ ∈ Γ , we have Xϕ = Y r and uϕ is compatiblewith ar . Choose any outcome α which extends uϕ and ar , and satisfies α( Xϕ) = xϕ (this is possible since Xϕ /∈ U ϕ ∪ Ar ).(cid:3)Define outcome β to satisfy β( Xϕ) = x, so α >Γ β, and(cid:3)(cid:3)hence, α >σ β. Node r divides α and β, so we have xϕ = α(Y ) (cid:6)r β(Y ) = xϕ , by definition of >σ , and hence, xϕ (cid:6)r xϕ , asrequired. (cid:2)ϕ , and to agree with α on all other outcomes. (α, β) ∈ ϕ∗ ⊆ Γ ∗). Using Proposition 13, it is sufficient to show that σProof of Proposition 14. Let σ be any cs-tree satisfying (1). Regarding (2), let r = (cid:18) A, a, Y , (cid:6)(cid:19) be any node, andsatisfies (1) and (2) of Proposition 13. (1) follows immediately from (1ϕ be any element of Γ such that Xϕ = Y and uϕ are compatible with a. Since uϕ is compatible with a, there exists some), U ϕ appears before Xϕ , so U ϕ ⊆ A. Sinceoutcome, say, α, which extends both of them, and so r is on the path to α. By (1uϕ is compatible with a, we have that a extends uϕ . By definition (see Definition 4), xϕ (cid:6) Xϕ(cid:3)ϕ , and hence bya x(2(cid:3)ϕ , so xϕ (cid:6)Yuϕ x(cid:3)ϕ , proving (2). (cid:2)), xϕ (cid:6) x) and (2(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)Proof of Proposition 16. Suppose that α is not optimal, so that there exists some outcome β with β >Γ α. Since >Γ is thetransitive closure of Γ ∗(cid:3). We have α( Xϕ) = xϕ andα(U ϕ) = uϕ , so α is not a solution of CΓ since it does not satisfy cϕ .there exists outcome γ with (γ , α) ∈ Γ ∗, so for some ϕ ∈ Γ , (γ , α) ∈ ϕ∗Conversely, suppose that outcome α is not a solution of CΓ . Then there exists some ϕ ∈ Γ such that α does not(cid:3)satisfy cϕ , and so α( Xϕ) = xϕ and α(U ϕ) = uϕ . Define outcome γ to be equal to α on all variables except Xϕ , and defineγ ( Xϕ) = xϕ . We have (γ , α) ∈ ϕ∗so γ >Γ α, showing that α is not optimal. (cid:2)Proof of Lemma 8. First, suppose that α (cid:6)p(Γ ) β, and consider any σ ∈ S. Let r = (cid:18) A, a, Y , (cid:6)(cid:19) be the node that divides αand β, so that α( A) = β( A) = a. Condition (a) implies that U Y ⊆ A. α(Y ) (cid:13)= β(Y ), so Y ∈ (cid:7)(α, β).Suppose that Y /∈ Θ(α, β). Then there exists Z ∈ (cid:7)(α, β) which is an ancestor of Y with respect to G(Γ ). Condition (a)above implies that Z would appear before Y on the path to α, so that Z ∈ A; α and β agree on A and hence Z (since rdivides α and β) which is contradiction since Z ∈ (cid:7)(α, β).We have proved that Y ∈ Θ(α, β). Since α (cid:6)p(Γ ) β we have α(Y ) (cid:6)YU Y ⊆ A and α extends a. Thus, using Lemma 5, α(Y ) (cid:6)Yα >σ β, as required.α β(Y ). Let u = α(U Y ), which equals a(U Y ), becauseu β(Y ), which implies that α(Y ) (cid:6)r β(Y ) by condition (b), and henceConversely, suppose that it is not the case that α (cid:6)p(Γ ) β; we will show that there exists some σ ∈ S with α ≯σ β. Thisfollows immediately if α = β, so let us assume that α (cid:13)= β.Since α (cid:4)p(Γ ) β, there exists Y ∈ Θ(α, β) such that α(Y ) (cid:4)Yα β(Y ). We can create a cs-tree σ satisfying the followingproperties:(i) σ uses a fixed variable ordering compatible with G(Γ ) in all paths from the root to outcomes, where Y is only precededin this ordering by its ancestors in G(Γ );(ii) let r(cid:3)be the node that divides α and β; by (i), Y is only preceded in the variable ordering by variables not in Θ(α, β),and so not in (cid:7)(α, β), hence α and β agree on variables before Y ; this implies that Y r(cid:3) = Y ; we choose (cid:6)r(cid:3) to be somestrict total order extending (cid:6)Yα and such that α(Y ) (cid:4)r(cid:3) β(Y );(iii) for all other nodes r in σ , set (cid:6)r to be some strict total order extending (cid:6)Yru , where u = ar(U Yr ), and U Yr is the parentsof Y r in H(Γ ).Then σ satisfies conditions (a) and (b), so is in S. We also have α ≯σ β. (cid:2)Proof of Proposition 17. For any ϕ, (ϕ)∗ ⊇ ϕ∗>Γsame local orderings (cid:6) Xfor U ⊆ V , maxG◦(Γ )(U ) = maxG◦(Γ )(U ). These observations imply that (cid:6)p(Γ ) equals (cid:6)(cid:6), and hence, taking the transitive closure of both sides,⊇ >Γ . Also, H(Γ ) = H(Γ ) so Γ is locally consistent if and only if Γ is locally consistent, as they both give rise to the◦(Γ ) of G(Γ ) so,p(Γ ). By Theorem 4 (applied to Γ ),◦(Γ ) of G(Γ ) is equal to the transitive closure Gα on X . The transitive closure Gp(Γ )Suppose α (cid:6)p(Γ ) β, so α (cid:13)= β. Abbreviate G(Γ ) to G, abbreviate H(Γ ) to H , and Θ(α, β) to Θ . Write Θ as { X1, . . . , Xk}.⊇ >Γ . It just remains to show that (cid:6)p(Γ ) ⊆ >Γ ., so (Γ )∗ ⊇ Γ ∗Since (cid:7)(α, β) (cid:13)= ∅ and G is acyclic, Θ (cid:13)= ∅.Define β0 = α, and for i = 1, . . . , k define βi inductively as follows:1088N. Wilson / Artificial Intelligence 175 (2011) 1053–1091βi( Xi) = β( Xi), and βi(Z ) = β(Z ) for all Z that are descendants of Xi in G (i.e., such that ( Xi, Z ) is in the transitiveclosure of G). For all other Y ∈ V , let βi(Y ) = βi−1(Y ). We have βk = β, since every element of (cid:7)(α, β) is equal to, or is adescendant of, some Xi in Θ .α equals (cid:6) Xiβ jfor all i and j. By definition of (cid:6)p(Γ ) we have for each Xi ∈ Θ , α( Xi) (cid:6) XiFor each Xi ∈ Θ , PaH ( Xi) ∩ (cid:7)(α, β) = ∅, else Xi would be a descendant of a variable in (cid:7)(α, β), contradicting thedefinition of Θ . So, α(PaH ( Xi)) = β(PaH ( Xi)). We therefore have, for all j = 0, . . . , k, α(PaH ( Xi)) = β j(PaH ( Xi)). This implies(cid:6) Xiβ( Xi),and hence, βi−1( Xi) (cid:6) Xiβi( Xi), since βi−1( Xi) = α( Xi), because Xi is not a descendant of any of X1, . . . , Xi−1. This impliesβi−1 >Γ βi , since we can apply a sequence of worsening swaps for Γ which start with βi−1, change with the last swap thevalue of Xi to βi( Xi), and with (e.g.,) the last swap also changing the values of all descendants of Xi to their values in βi .Since >Γ is transitive, we have β0 >Γ βk, i.e., α >Γ β. Thus, (cid:6)p(Γ ) ⊆ >Γ , as required. (cid:2)α β( Xi). So, for all j, α( Xi) (cid:6) Xiβ jβi−1Proof of Proposition 18. First let us assume that conditions (1) and (2) hold. We need to show that σ strongly satisfies Γ ,i.e., for any body node r of σ , with associated tuple (cid:18) A, a, Y , (cid:6)(cid:19), that (I) Y is strongly a-undominated, and (II) the ordering(cid:6) on Y extends (cid:6)Ya . (II) follows immediately from (2).To prove (I), we need to show that for all ϕ ∈ Γ such that uϕ is compatible with a, (i) if Xϕ = Y then U ϕ ⊆ A; (ii) ifW ϕ (cid:17) Y then U ϕ ∪ { Xϕ} ⊆ A. Since uϕ is compatible with a, there exists an outcome α that extends both. r is on the pathto α, so, by (1), if Xϕ = Y then U ϕ appears before Y , i.e., U ϕ ⊆ A, proving (i). Similarly, if W ϕ (cid:17) Y , then U ϕ and Xϕ appearbefore Y on the path to α, so U ϕ ∪ { Xϕ} ⊆ A, proving (ii).Conversely, suppose that σ strongly satisfies Γ . We need to show that conditions (1) and (2) hold. For any body node rof σ with associated tuple (cid:18) A, a, Y , (cid:6)(cid:19), r strongly satisfies Γ , so (cid:6) extends (cid:6)Ya , proving (2).To prove (1), consider any ϕ ∈ Γ and any outcome α such that α |(cid:11) uϕ . Consider first the node r on the path to αwith Y r = Xϕ . Then, Y r is strongly ar -undominated, so U ϕ ⊆ Ar , and hence, U ϕ appears before Xϕ on the path to α. Nowconsider any node r on the path to α with Y r ∈ W ϕ . Since Y r is strongly ar -undominated, we have U ϕ ∪ { Xϕ} ⊆ Ar showingthat Xϕ appears before each element of W ϕ on the path to α, completing the proof of (1). (cid:2)Proof of Lemma 10. ⇒: Suppose that Y is Fa-dominated by some element Z of V − A. Then there exists ϕ ∈ Γ such thatuϕ is compatible with a and either (i) Y = Xϕ and Z ∈ U ϕ , or (ii) Y ∈ W ϕ and Z ∈ U ϕ ∪ { Xϕ}. In either case, Y is notstrongly a-undominated.⇐: Suppose that Y is not Fa-dominated by any element of V − A. Consider any ϕ ∈ Γ such that uϕ is compatible with a.(i) If Xϕ = Y then U ϕ ∩ (V − A) = ∅, and so U ϕ ⊆ A. (ii) If Y ∈ W ϕ then ({ Xϕ} ∪ U ϕ) ∩ (V − A) = ∅ and so { Xϕ} ∪ U ϕ ⊆ A.This proves that Y is strongly a-undominated. (cid:2)Proof of Proposition 20. (i) Fb ⊆ Fa follows immediately from the fact that, for any ϕ ∈ Γ , if b is compatible with uϕ thena is compatible with uϕ .(ii) Suppose Y ∈ V − B is strongly a-undominated. By Lemma 10, Y is not Fa-dominated by any element of V − A, so,using the fact that Fb ⊆ Fa, Y is not Fb-dominated by any element of V − A, so in particular is not Fb-dominated by anyelement of V − B. By Lemma 10, Y is strongly b-undominated.(iii) Suppose that Fa restricted to V − A is acyclic, and consider any b extending a. Fb is a subrelation of Fa, so Fbrestricted to V − A is acyclic, and hence Fb restricted to V − B ⊆ V − A is acyclic, so there exists some Y ∈ V − B which isFb-undominated in V − B. By Lemma 10, Y is strongly b-undominated. (cid:2)Proof of Proposition 22. By Definition 14, we have to show that for all A ⊆ V and a ∈ A, there exists a strongly a-undominated variable (see Definition 13). Let α be any outcome extending a. Then (cid:3)α is irreflexive, since Γ is cuc-acyclic.This implies that (cid:3)a is irreflexive (since Y (cid:3)a Z implies Y (cid:3)α Z ). So, (cid:3)a is acyclic. This implies that there exists someY ∈ V − A which is (cid:3)a-undominated in V − A. If ϕ ∈ Γ is such that a is compatible with uϕ , and Y ∈ { Xϕ} ∪ W ϕ then forall Z ∈ U ϕ , Z (cid:3)a Y (by definition of (cid:3)a) so U ϕ ⊆ A (else Y wouldn’t be (cid:3)a-undominated in V − A), which implies also thata extends uϕ . If W ϕ (cid:17) Y , then Xϕ (cid:3)a Y and so Xϕ ∈ A, proving that Y is a-undominated. (cid:2)We will use the following basic technical lemma to prove Lemma 14.Lemma 22. Let A be a subset of V , and let a ∈ A be an assignment to the variables A, let α ∈ V be an outcome such that α |(cid:11) a.Y is undominated in V − A with respect to (cid:3)a if and only if Y is undominated in V − A with respect to (cid:3)α . Furthermore, if Y isa and (cid:6)Yundominated in V − A with respect to (cid:3)a, then the relations (cid:6)Yα (see Definition 4) are equal.Proof. If Y is undominated in V − A with respect to (cid:3)α then clearly Y is undominated in V − A with respect to (cid:3)a,since the relation (cid:3)α extends (cid:3)a. Conversely, suppose that Y is undominated in V − A with respect to (cid:3)a and, to prove acontradiction suppose that Y is not undominated in V − A with respect to (cid:3)α , so that Z (cid:3)α Y for some Z ∈ V − A. Thenthere exists ϕ ∈ Γ with either (i) U ϕ (cid:17) Z and Y ∈ { Xϕ} ∪ W ϕ or (ii) Xϕ = Z and W ϕ (cid:17) Y and α |(cid:11) uϕ . We have U ϕ ⊆ A sinceY is undominated in V − A with respect to (cid:3)a. Since Z /∈ A, we have U ϕ /(cid:17) Z so case (i) cannot hold. Consider case (ii). WeN. Wilson / Artificial Intelligence 175 (2011) 1053–10911089have α |(cid:11) uϕ and so a |(cid:11) uϕ , since U ϕ ⊆ A and α |(cid:11) a. This implies by Definition 15 that Z (cid:3)a Y which is a contradiction ofZ being in V − A, as Y is (cid:3)a-undominated in V − A.For the last part, (cid:6)Yα clearly contains (cid:6)YU Y dominates Y with respect to (cid:3)a (or (cid:3)α ). This implies that (cid:6)Yα |(cid:11) uϕ , then a |(cid:11) uϕ . (cid:2)a . We also have that all the parents of Y are in A: U Y ⊆ A, since any element ofα are equal, since if Y = Xϕ for some ϕ ∈ Γ witha and (cid:6)YProof of Lemma 12. We first prove that if Y is (cid:3)a-undominated in V − A then Y is strongly a-undominated in V − A.Suppose that Y is (cid:3)a-undominated and consider any ϕ ∈ Γ such that uϕ is compatible with a. (i) If Xϕ = Y then U ϕ ∩ (V −A) = ∅, so U ϕ ⊆ A. Also, (ii) if W ϕ (cid:17) Y then (U ϕ ∪ { Xϕ}) ∩ (V − A) = ∅, so U ϕ ∪ { Xϕ} ⊆ A. This proves that Y is stronglya-undominated in V − A.If a cs-tree σ cu-satisfies Γ then each body node of it cu-satisfies Γ . This implies, using the result above, that each bodynode strongly satisfies Γ (see Definitions 17 and 13), implying that σ strongly satisfies Γ , and hence, by Proposition 19, σsatisfies Γ . (cid:2)Proof of Lemma 14. Suppose α (cid:16)Γ β and let σ be a cs-tree cu-satisfying Γ . Let r = (cid:18) A, a, Y , (cid:6)(cid:19) be the node that dividesα and β. In order to prove the required condition α >σ β we need to show that α(Y ) (cid:6) β(Y ). Now, α and β differ on Y soY ∈ (cid:7)(α, β). Y is (cid:3)a-undominated in V − A, so by Lemma 22 is undominated in V − A with respect to (cid:3)α , and hence wehave Y ∈ Θ (cid:3)(α, β). Since α (cid:16)Γ β we have α(Y ) (cid:6)Ya β(Y ) by Lemma 22. This implies, bythe definition of a body node cu-satisfying Γ , that α(Y ) (cid:6) β(Y ) as required. (cid:2)α β(Y ), which implies that α(Y ) (cid:6)YProof of Lemma 15. If α = β then the result follows from Lemma 13, since >σ is irreflexive for any cs-tree σ .Now, suppose that α (cid:13)= β. This implies (cid:7)(α, β) (cid:13)= ∅, and Θ (cid:3)(α, β) (cid:13)= ∅. Since it is not the case that α (cid:16)Γ β there mustexist some Y ∈ Θ (cid:3)(α, β) such that it is not the case that α(Y ) (cid:6)Yα β(Y ). Since, Y ∈ Θ (cid:3)(α, β), we also have α(Y ) (cid:13)= β(Y ).List the variables in an order compatible with (cid:3)α such that Y appears as early as possible, i.e., so that there’s no ordercompatible with (cid:3)α in which Y appears earlier. We will construct a cs-tree σ in which the variables on the path from theroot to α appear in that order. Thus, at any node r on the path to α, Y r will be (cid:3)α -undominated in V − Ar , since anydominating variables come earlier, as the ordering is compatible with (cid:3)α .For the node r(cid:3)on the path to α with Y r(cid:3) = Y , we define relation (cid:6)r(cid:3) to be any total order on Y extending (cid:6)Ythat α(Y ) (cid:4)r(cid:3) β(Y ); this is possible, by Lemma 1(i), because (cid:6)Ynodes r in the path to α we define the relation (cid:6)r to be any total order extending (cid:6)Yrar .α is a partial order such that α(Y ) (cid:4)Yα and suchα β(Y ). For the otherWe generate the rest of the cs-tree iteratively so that each body node r cu-satisfies Γ (by choosing any variable Y rar ). This generates a cs-tree σwhich is (cid:3)ar -undominated in V − Ar and choosing any total order (cid:6) on Y r extending (cid:6)Yrwhich cu-satisfies Γ .The condition that Y appears as early as possible in the variable ordering ensures that Ar(cid:3) consists only of variables Zwith Z (cid:3)α Y . (If not, let Z be the latest variable appearing in the list before Y not satisfying Z (cid:3)α Y . Then moving Z to justafter Y gives an ordering of the variables which is still compatible with (cid:3)α , but where Y comes earlier, which contradictsthe definition of the variable ordering.) Y ∈ Θ (cid:3)(α, β) then implies Ar(cid:3) ∩ (cid:7)(α, β) = ∅, i.e., α and β agree on all variablesin Ar(cid:3) . Then the node rdivides α and β. We also have α(Y ) (cid:4)r(cid:3) β(Y ) which implies it is not the case that α >σ β. (cid:2)(cid:3)Proof of Proposition 24. If Γ is not strongly conditionally acyclic then either it is not locally consistent, or there exists aproper subset A of V , and an assignment a ∈ A such that there exists no strongly a-undominated variable. Thus, to deter-mine that Γ is not strongly conditionally acyclic we can either non-deterministically choose α and X such that (cid:6) Xα (whichcan be computed in polynomial time) is not irreflexive (proving that Γ is not locally consistent), or non-deterministicallychoose A and a ∈ A such that there exists no strongly a-undominated variable (and for each variable Y ∈ V − A we cancheck in polynomial time that Y is not a-undominated). This proves membership in coNP.The proof of membership for cuc-acyclicity is similar, using the fact that for given cp-theory Γ and outcome α, comput-ing the relation J α(Γ )—and hence determining that it is not acyclic—can be done in polynomial time.(cid:3). For k = 1, . . . , m, let ck be the kth clause, which we write as lk1To show coNP-hardness we use a reduction from 3-SAT. Consider an instance of 3-SAT with m clauses involving propo-∨ lk3. We generate a cp-theory(cid:3)}. Let Γk consist of the threek[ Z0]}. Now, the 3-SAT instance(cid:3), which implies that Γ is not∨ lksitional variables V2(cid:3) ∪ {Z0, Z1, . . . , Zm} where, for k = 0, . . . , m, Zk has domain {zk, zΓ as follows: let V be V(cid:3)[{Zk}], for j = 1, 2, 3, and let Γ be Γ1 ∪ · · · ∪ Γm ∪ {(cid:5) : zm > zstatements lkmhas a satisfying assignment u if and only if there exists no u-undominated variable in V − Vstrongly conditional acyclic.j: zk−1 > z(cid:3)k−1Conversely, if Γ is not strongly conditional acyclic, then, for some proper subset A of V and tuple a ∈ A, there exists noand for eacha-undominated variable in V − A (since Γ is clearly locally consistent). This can only happen if A contains Vk there exists j with a satisfying lkj , which is if and only if a satisfies the 3-SAT instance.(cid:3)Hence the 3-SAT instance is satisfiable if and only if Γ is not strongly conditionally acyclic. The same construction appliesalso for cuc-acyclicity. (cid:2)1090N. Wilson / Artificial Intelligence 175 (2011) 1053–1091Proof of Proposition 25. Let σ be a cs-tree; we will define a VON τ compatible with σ . For each body node r of σ withassociated tuple (cid:18) A, a, Y , (cid:6)(cid:19) we define a node r of τ with associated tuple (cid:18) A, a, Y (cid:19). We create a sink node r∗ with ar∗ equalin σ we create and edge from r to node r(cid:3) in τ , where r(cid:3)to some arbitrary outcome. For each edge from node r to node ris a leaf node of σ . Clearly, τ is compatible with σ . (Naturally, there will often be muchis defined to be the sink node if rmore compact variable ordering networks compatible with σ than τ .)(cid:3)(cid:3)Conversely, suppose that τ is a variable ordering network. We construct a cs-tree σ compatible with τ inductively,starting from the root. To generate a body node r we need to define the associated tuple (cid:18) A, a, Y , (cid:6)(cid:19). Assume, inductively,that A and a have already been defined (for the root node they are, by definition, equal to ∅ and (cid:5), respectively). a generatesa path in τ from the root node to some node r. We let Y equal Y r , and we choose (cid:6) to be some arbitrary strict total orderon Y . We create |Y | child nodes of r, so r has |Y | edges coming from it. Each such edge e has associated variable Y e = Y(cid:3)then Ar(cid:3) = Ar ∪ {Y }, and ar(cid:3) is the tuple formed by extendingand a different associated value ye . If e goes from node r to ra with the assignment Y e = ye . This inductively defines the whole of σ . Clearly, σ is compatible with τ . (cid:2)Proof of Lemma 16. By definition, (cid:18)t, Z , Y (cid:19) is in Tab if and only if there exists assignment s to some set of variables S withs compatible with ab, S − ( A ∪ B) = T , s(T ) = t and (cid:18)s, Z , Y (cid:19) ∈ T .Given such an assignment s, define U = S − A and u = s(U ). Then (i) U − B = T and u(T ) = s(T ) = t and u is compatiblewith b, since s is compatible with b; also we have (ii) (cid:18)u, Z , Y (cid:19) is in Ta, since s is compatible with a.Conversely, suppose there exists assignment u to some set of variables U ⊆ V − A such that (i) U − B = T , u(T ) = t,and u compatible with b and (ii) (cid:18)u, Z , Y (cid:19) is in Ta. Hence, there exists assignment s (to some set of variables S) which iscompatible with a, is such that S − A = U and s(U ) = u, and (cid:18)s, Z , Y (cid:19) ∈ T . We have S − ( A ∪ B) = (S − A) − B = U − B = T .Also, T ⊆ U , so s(T ) = u(T ), which equals t. Since A and B are disjoint, S ∩ B = (S − A) ∩ B = U ∩ B. Tuple s is compatiblewith b since s(S ∩ B) = s(U ∩ B) = u(U ∩ B) = b(U ∩ B) = b(S ∩ B), as u is compatible with b. Therefore, s is compatiblewith ab since it is also compatible with a. This proves that (cid:18)t, Z , Y (cid:19) is in Tab. (cid:2)(cid:3)Proof of Lemma 18. This will be proved by induction on the cardinality of | Ar|. Suppose that it is true for all nodes r| Ar(cid:3) | < k. Consider node r with | Ar| = k, and consider any path from the root to r with associated assignment a. Let rthe parent of r along that path, and let ainduction we have Ta(cid:3) = Tarwhere aTa = Tar as required. (cid:2)with(cid:3)beand r. Byand ar(cid:3) by the assignment Y = y we obtain Ta = Ta(cid:3)(cid:3)is ar(cid:3) extended with the assignment Y = y. We also have by condition (ii) of Definition 23 that Ta(cid:3)(cid:3) = Tar . Hence,be a( Ar(cid:3) ), and let Y = y be the assignment along the edge between r(cid:3) . Using Lemma 17 and extending both a(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)Proof of Proposition 26. Consider some element (cid:18)u, Y , Z (cid:19) in T , where u is an assignment to some set of variables U .Consider any outcome α extending u. We need to show that Y appears before Z in Oτ (α). We proceed using Proof byContradiction.Suppose that Z appears before Y in Oτ (α). Consider node r in τ with Y r = Z in the path associated with α. SinceZ = Y r /∈ Ar we also have Y /∈ Ar , since Z appears before Y in the path associated with α, by definition of Oτ (α). Let(cid:3) = u(U − Ar).a = α( Ar). By Lemma 18 we have Ta = Tar . Now, u is compatible with a, since α extends both u and a. Let u(cid:3), Y , Z (cid:19) ∈ Tar , i.e., (cid:18)u(cid:3)(cid:3), Y , Y r(cid:19) ∈ T(cid:3), Y , Y r(cid:19) ∈ Tar , and hence there exists (cid:18)uSince Y , Z /∈ Ar , we have (cid:18)u(cid:3)). By condition (i) of Definition 23, Y ∈ Ar which contradicts Y /∈ Ar ,with ucompleting the Proof by Contradiction. (cid:2)(cid:3), Y , Z (cid:19) ∈ Ta, and so (cid:18)uextending ucompatible with ar (and u(cid:3)(cid:3)(cid:3)(cid:3)Proof of Proposition 27. Suppose that a and athere exists some triple (cid:18)u, Y , Z (cid:19) in T such that Y , Z ∈ V − A, tuple u ∈ U is compatible with a, and u(U − A) = uU ∩ A ⊆ Q T ( A), so a and aDefinition 21. We’ve shown that Ta ⊆ Ta(cid:3) . Swapping the roles of a and aTa = Ta(cid:3) , as required. (cid:2)(cid:3), Y , Z (cid:19) in Ta. Then, by Definition 21,. Now,(cid:3), Y , Z (cid:19) in Ta(cid:3) , by. Hence, (cid:18)uin the above argument shows that Ta(cid:3) ⊆ Ta, soagree on U ∩ A, which implies that u is also compatible with aagree on Q T ( A). Consider any (cid:18)u(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)Proof of Lemma 19. Y is not strongly a-undominated if and only if there exists Z ∈ V − A and ϕ ∈ Γ with uϕ compatiblewith a such that either (a) Z ∈ U ϕ and Y ∈ Xϕ ∪ W ϕ or (b) Z = Xϕ and Y ∈ W ϕ . This is if and only if there exists Z ∈ V − Aand ϕ ∈ Γ with uϕ compatible with a such that (cid:18)uϕ, Z , Y (cid:19) ∈ [Γ ]. This is if and only if there exists Z ∈ V − A and u(cid:3), Z , Y (cid:19) incompatible with a such that (cid:18)u, Z , Y (cid:19) ∈ [Γ ], which is if and only if there exists an element of the form (cid:18)u[Γ ]a. (cid:2)Proof of Lemma 20. Let r be a body node in σ with associated tuple (cid:18) A, a, Y , (cid:6)(cid:19). Suppose that there exists some triple(cid:18)u, Z , Y (cid:19) in [Γ ] with Z ∈ V − A and u compatible with a. Then, for any α extending both u and a, Z must appear beforeY on the path to α in τ (since τ respects [Γ ], see Definition 22), and hence on the path to α in σ (since σ is compatiblewith τ ), which contradicts the fact that Z ∈ V − A.Therefore, there exists no triple (cid:18)u, Z , Y (cid:19) in [Γ ] with Z ∈ V − A and u compatible with a. By Lemma 19, Y is stronglya-undominated. Therefore, by Definition 13 (Section 6.1), r strongly satisfies Γ , and hence σ strongly satisfies Γ , since r isan arbitrary body node of σ . (cid:2)N. Wilson / Artificial Intelligence 175 (2011) 1053–10911091τ β, and let rProof of Lemma 21. Note that local consistency of Γ ensures that Q is non-empty, using the proof of Theorem 7. First(cid:3) = (cid:18) A, a, Y (cid:19) be the node in τ that divides α and β. Consider any σ ∈ Q, and let r be thesuppose that α (cid:16)Γnode in σ which divides α and β. Because σ is compatible with τ , and so the variable ordering is the same on the path toa β(Y ), and so α(Y r) (cid:6)r β(Y r), and henceα in τ and σ , we must have Ar = A and Y r = Y . Since α (cid:16)Γα >σ β.τ β we have α(Y ) (cid:6)YConversely, suppose that it is not the case that α (cid:16)Γτ β, and it will be shown that there exists some σ ∈ Q with α ≯σ β.(cid:3) = (cid:18) A, a, Y (cid:19) be theIf α = β then the implication holds because of irreflexivity of all >σ , so we can assume that α (cid:13)= β. Let ra is acyclic, so there exists a total order (cid:6) onnode in τ that divides α and β. Then α(Y ) (cid:4)Ya and is such that α(Y ) (cid:4) β(Y ). Consider any cs-tree σ ∈ Q. Let r be the node in σ which divides α andY that extends (cid:6)Yβ. Because σ is compatible with τ , we must have Ar = A and Y r = Y . Change σ by changing (cid:6)r to (cid:6). σ is still in Q, andwe have α(Y ) (cid:4)r β(Y ) which implies that α ≯σ β, as required. (cid:2)a β(Y ). By local consistency, (cid:6)YReferences[1] M. Bienvenu, J. Lang, N. Wilson, From preference logics to preference languages, and back, in: Proceedings of KR 2008, 2010.[2] C. Boutilier, F. Bacchus, R. Brafman, UCP-networks: A directed graphical representation of conditional utilities, in: Proceedings of UAI 2001, 2001,pp. 56–64.[3] C. Boutilier, R. Brafman, H. Hoos, D. Poole, Reasoning with conditional ceteris paribus preference statements, in: Proceedings of UAI 1999, 1999, pp. 71–80.[4] C. Boutilier, R.I. Brafman, C. Domshlak, H. Hoos, D. Poole, CP-nets: A tool for reasoning with conditional ceteris paribus preference statements, Journalof Artificial Intelligence Research 21 (2004) 135–191.[5] C. Boutilier, R.I. Brafman, C. Domshlak, H. Hoos, D. Poole, Preference-based constrained optimization with CP-nets, Computational Intelligence 20 (2)(2004) 137–157.[6] R. Brafman, C. Domshlak, Introducing variable importance trade-offs into CP-nets, in: Proceedings of UAI 2002, 2002, pp. 69–76.[7] R. Brafman, C. Domshlak, Graphically structured value-function compilation, Artificial Intelligence 172 (2008) 325–349.[8] R. Brafman, C. Domshlak, E. Shimony, On graphical modeling of preference and importance, Journal of Artificial Intelligence Research 25 (2006) 389–424.[9] R.I. Brafman, Y. Dimopoulos, Extended semantics and optimization algorithms for CP-networks, Computational Intelligence 20 (2) (2004) 218–245.[10] R.I. Brafman, C. Domshlak, S.E. Shimony, Qualitative decision making in adaptive presentation of structured information, ACM Transactions on Informa-tion Systems 22 (4) (2004) 503–539.[11] C. Domshlak, Modeling and reasoning about preferences with CP-nets, PhD thesis, Ben-Gurion University of the Negev, 2002.[12] C. Domshlak, R.I. Brafman, CP-nets—reasoning and consistency testing, in: Proceedings of KR 2002, 2002, pp. 121–132.[13] C. Domshlak, S. Prestwich, F. Rossi, K.B. Venable, T. Walsh, Hard and soft constraints for reasoning about qualitative conditional preferences, Journal ofHeuristics 12 (4–5) (2006) 263–285.[14] C. Domshlak, F. Rossi, K. Venable, T. Walsh, Reasoning about soft constraints and conditional preferences: complexity results and approximation tech-niques, in: Proceedings of IJCAI 2003, 2003, pp. 215–220.[15] J. Doyle, M.P. Wellman, Representing preferences as ceteris paribus comparatives, in: Working Notes of the AAAI Symposium on Decision-TheoreticPlanning, 1994.[16] E. Freuder, R. Heffernan, R. Wallace, N. Wilson, Lexicographically-ordered constraint satisfaction problems, Constraints 171 (1) (2010) 3–25.[17] J. Goldsmith, J. Lang, M. Truszczy ´nski, N. Wilson, The computational complexity of dominance and consistency in CP-nets, in: Proceedings of IJCAI2005, 2005, pp. 144–149.[18] J. Goldsmith, J. Lang, M. Truszczy ´nski, N. Wilson, The computational complexity of dominance and consistency in CP-nets, Journal of Artificial Intelli-gence Research 33 (2008) 403–432.[19] S.O. Hansson, What is ceteris paribus preference? Journal of Philosophical Logic 425 (1996) 307–332.[20] S.O. Hansson, Preference logic, in: D. Gabbay, F. Guenthner (Eds.), Handbook of Philosophical Logic, Kluwer, 2001, pp. 319–393.[21] S.O. Hansson, The Structure of Values and Norms, Cambridge University Press, 2001.[22] S. Kaci, H. Prade, Relaxing ceteris paribus preferences with partially ordered priorities, in: Proceedings of ECSQARU 2007, 2007, pp. 660–671.[23] J. Lang, From preference representation to combinatorial vote, in: Proceedings of KR 2002, 2002, pp. 277–288.[24] J. Lang, Logical preference representation and combinatorial vote, Annals of Mathematics and Artificial Intelligence 42 (1) (2004) 37–71.[25] E. Marczewski, Sur l’extension de l’ordre partiel, Fundamenta Mathematicae 16 (1930) 386–389.[26] M. McGeachie, J. Doyle, Efficient utility functions for ceteris paribus preferences, in: Proceedings of AAAI 2002, 2002, pp. 279–284.[27] M. McGeachie, J. Doyle, Utility functions for ceteris paribus preferences, Computational Intelligence 20 (2) (2004) 158–217.[28] J. van Benthem, P. Girard, O. Roy, Everything else being equal: A modal logic for ceteris paribus preferences, Journal of Philosophical Logic 38 (1)(2009) 83–125.[29] G.H. von Wright, The Logic of Preference, Edinburgh University Press, 1963.[30] G.H. von Wright, The logic of preference reconsidered, Theory and Decision 3 (1972) 140–169.[31] N. Wilson, Consistency and constrained optimisation for conditional preferences, in: Proceedings of ECAI 2004, 2004, pp. 888–892.[32] N. Wilson, Extending CP-nets with stronger conditional preference statements, in: Proceedings of AAAI 2004, 2004, pp. 735–741.[33] N. Wilson, An efficient upper approximation for conditional preference, in: Proceedings of ECAI 2006, 2006, pp. 472–476.[34] N. Wilson, Efficient inference for expressive comparative preference languages, in: Proceedings of IJCAI 2009, 2009, pp. 961–966.[35] L. Xia, V. Conitzer, J. Lang, Voting on multiattribute domains with cyclic preferential dependencies, in: Proceedings of AAAI 2008, 2008, pp. 202–207.