Artificial Intelligence 173 (2009) 1310–1342Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintWeighted A∗search – unifying view and applicationRüdiger Ebendt a,∗, Rolf Drechsler ba German Aerospace Center, Institute of Transportation Systems, 12489 Berlin, Germanyb Institute of Computer Science, University of Bremen, 28359 Bremen, Germanya r t i c l ei n f oa b s t r a c tArticle history:Received 17 December 2007Received in revised form 9 June 2009Accepted 10 June 2009Available online 16 June 2009Keywords:PlanningSearchHeuristic search∗A∗Weighted ABDDSTRIPS1. Introduction∗2(cid:4)∗∗approach are known.). These methods guarantee a bounded suboptimality.where N is an upper bound on an optimal solution length.algorithm is a well-known heuristic best-first search method. Several performance-The AInteresting examples areaccelerated extensions of the exact Aapproximate algorithms where the heuristic function used is inflated by a weight (often∗referred to as weighted AAs a technical contribution, this paper presents the previous results related to weightedfrom authors like Pohl, Pearl, Kim, Likhachev and others in a more condensed andAunifying form. With this unified view, a novel general bound on suboptimality of the resultis derived. In the case of avoiding any reopening of expanded states, for (cid:2) > 0, this boundis (1 + (cid:2))(cid:3) NBinary Decision Diagrams (BDDs) are well-known to AI, e.g. from set-based explorationof sparse-memory and symbolic manipulation of state spaces. The problem of exact orapproximate BDD minimization is introduced as a possible new challenge for heuristicsearch. Like many classical AI domains, this problem is motivated by real-world applications.∗search are applied to problems of BDD minimization andSeveral variants of weighted Athe more classical domains like blocksworld and sliding-tile puzzles. For BDD minimization,the comparison of the evaluated methods also includes previous heuristic and simulation-based methods such as Rudell’s hill-climbing based sifting algorithm, Simulated Annealingand Evolutionary Algorithms.A discussion of the results obtained in the different problem domains gives our experiences∗with weighted A, which is of value for the AI practitioner.© 2009 Elsevier B.V. All rights reserved.In many real-world problems, dominating effort is put into search which often involves huge state spaces. Therefore alarge number of papers on search has been published by numerous authors. The drawbacks of fixed-order methods likebreadth-first search or depth-first search can be avoided by following a best-first order. The disadvantages of blind methodsare overcome by heuristic search methods that guide the search. A prominent guided best-first search algorithm is the∗well-known A, otherexamples for special cases of best-first search are breadth-first search and Dijkstra’s single-source shortest path algorithm[22]. Best-first search explores the search graph by a list Open containing the “open” frontier nodes that have been generatedbut not yet expanded. A second list Closed stores the “closed” inner or expanded nodes. A cost function maps every node toits cost value. A best-first search always expands a most promising open node of minimum cost. Expanding a node meansto generate all its child nodes. They are inserted into Open, preserving an order based upon the cost values of the nodes.algorithm [40]. Best-first search is a more general framework of algorithms, e.g. see [55]: besides A∗* Corresponding author.E-mail addresses: ruediger.ebendt@dlr.de (R. Ebendt), drechsle@informatik.uni-bremen.de (R. Drechsler).0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2009.06.004R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421311∗AThe expanded node is inserted into Closed. At the start, Open contains only the initial node and the search stops when agoal node is chosen for expansion.∗The different instances of best-first search differ only in their cost functions. For A, the cost of a node n is f (n) =g(n) + h(n). Hereby, two components of information are used with every node n: one is g(n), which is the informationabout the cost of the path already covered. The other is the heuristic function value h(n), which is an estimate of the leastcost of the remaining part of the path to a goal node. The vertices of the search graph represent the states of a problemstate space, e.g. for the sliding-tile puzzle, a state is represented by an ordered sequence of tiles. The edges of the searchgraph describe the possible transitions between the states (for more details, see Section 2.1).is used in many fields of application, including diverse areas such as robotics (see e.g. [62–64]), computational biology(see e.g. [51,59,78,88]), AI gameplay (see e.g. [12]), hardware verification [75] and logic synthesis [28]. If certain require-∗ments to the heuristic function guiding the search are met, Awill find a minimum cost path to a goal state (see [40] andalso Section 2.1).∗A serious drawback of Ais that, in the worst-case, the run time as well as the amount of memory required is expo-∗nential in the depth of the search. This has led to several extensions of A, some of which are memory-bounded [13,49,59,77,87,89,90], while others mainly aim at a reduction in run time by allowing for bounded suboptimality. These so-called∗methods actually do guarantee bounded suboptimality which contrasts to generalizations of best-first searchweighted Asuch as the K-Best First Method (KBFM) of Felner et al. [33]. Generally, a weighting to the heuristic function is applied andthe methods differ in the way and idea of this weighting.∗∗, many authors refer to it as WAFirst, Pohl proposed to constantly inflate the heuristic function h by a certain factor 1 + (cid:2), (cid:2) > 0 [71]. Since this is. A second proposal of the same author was Dynamicthe original idea of weighted A∗Weighting (DWA) [72]. At the beginning of the search, the method starts with a high weighting of the heuristic function(as this may help to find a promising direction more quickly) and then it dynamically weights it less heavily as the searchgoes deeper. The latter may help to prevent premature termination. More recently, the interest in Pohl’s first, conceptuallysimpler and more natural idea of a constant overweighting has been renewed [52,88]. It has also been embedded in the∗Anytime Weighting A) [38] and Anytime Repairing A∗) variants of Ain [62,63].∗(ARA(AWA∗∗In contrast to that, in [70], the Traveling Salesman Problem (TSP) has been tackled by an extension of A∗∗(cid:2) whichcalled A. This condition triggers the choice of the next node for expansion (i.e. for generatingsearch has also been transferred to the bidirectional∗∗relaxes the selection condition of Aall its child nodes). Further, the idea of relaxing a (unidirectional) Acase [53].1In this paper, previous results from the different authors are presented in a condensed and unifying form. This allows fora comparison of the respective methods on more formal grounds. Finally, a novel general bound on suboptimality is derivedremain methods of bounded suboptimality, even when(see Section 5). It is shown that all discussed variants of weighted Aexpanded states are not reopened again. A previous bound was only stated for the case of constant overweighting [63].∗A second contribution of this paper is the experimental evaluation of the several variants. In Section 7, the respective∗variants of weighted A(two of them are novel) are applied to benchmark problems of classical AI domains like blocks-world, several logistics domains, the sliding-tile puzzle, and a problem domain which has been well-studied in the hardwarecommunity. This is the problem of the exact or approximate minimization of Binary Decision Diagrams (BDDs). BDDs are well-known in the AI as well as in the hardware community, e.g. from set-based exploration of sparse-memory and symbolicmanipulation of state spaces. For this domain, the comparison of the evaluated methods also includes previous heuristicand simulation-based methods such as Rudell’s hill-climbing based sifting algorithm [76], Evolutionary Algorithms (EAs) [23],and Simulated Annealing (SA) [4].BDDs uniquely represent Boolean functions and are described in more detail in Section 6.3. It has been shown that it isNP-complete to decide whether the number of nodes of a BDD can be decreased by variable reordering [5]. Although thesolving of NP-complete problems has a long tradition in the AI community (e.g. the Traveling Salesman Problem (TSP) [70],the (n × n) − 1 sliding-tile puzzle [60,74], number partitioning [56], rectangle and bin packing [57,58], minimum vertexcover [37,61] and many of the planning problems [11,54]), and BDDs have been used in the community for sparse-memoryexploration [44,89] and to run symbolic versions of established search methods like A[30,39,43,73], to the best of theauthors’ knowledge, so far the problem of exact or approximate BDD minimization itself has not been addressed in AI.However, this problem is strongly motivated by real-world applications in VLSI CAD. Therefore the authors would alsolike to introduce this problem to AI as a possible new challenge. A discussion of the experimental results obtained in thedifferent problem domains addresses the AI practitioner.∗This paper is structured as follows: A brief description of A, basic notations and definitions are given and the different∗ideas of weighted Aare briefly reviewed. Related technical results of different authors are presented in a unifying form. The conse-in Section 3. In Section 4, an instructive example illustrates the reopening of expanded nodes for weighted Aquences of not reopening the nodes are discussed in Section 5. In Section 6, the problem of exact and approximate BDDminimization is introduced as a possible new challenge for weighted A. For this purpose, first a formal definition of BDDsis briefly reviewed. Experimental resultsand the problem is given. Then previous work on exact BDD minimization by Aare given in Section 7. Finally, in Section 8 the work is concluded.∗∗∗∗1 In addition, [48] gives an excellent discussion of the relationship of unidirectional to bidirectional search in general.1312R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13422. Background2.1. State space search by A∗algorithmA search problem and the corresponding search task can be formulated as a state space graph. Vertices represent thestates q and edges represent the allowed state transitions (see e.g. [55] and also Section 1). For the remainder of the paper,, . . . , which are traditionally used to denotevertices will be identified with the states they represent and the letters q, q(cid:5)states, are favored over the letters n, n, . . . that are usually used for the (logical) nodes of the search graph.(cid:5)An important method to guide the search on a state space is heuristic search. With every state q a quantity h(q) isassociated which estimates the cost of the cheapest path from q to a goal state t (the “target”). This allows for searching in∗the direction of the goal states. The Aalgorithm is a heuristic best-first search algorithm (see also Section 1). Given thatcertain requirements are met, a minimum cost path from the initial state s (the “start”) to a goal state t is found by A. Itstarts at s and bases the choice of the next state to expand on two criteria:∗• the sum of the edge costs on the path from the initial state up to state q (or “path cost” for short), denoted g(q), and• the estimate h(q).They are combined in cost function f = g + h. For all q the cost of q is the sum of its current path cost and its estimate,∗(q). The cost of a minimum costi.e. we have f (q) = g(q) + h(q). The cost of a minimum cost path from s to q is denoted gpath from q to a goal state is denoted h∗(q).∗For A, the estimate h(q) has to be a lower bound on the cost of an optimal path from q to a goal state:h(q) (cid:2) h∗(q)(1)∗∗∗In this case, h is called admissible. A∗always finds a minimum cost path [40]. Anodes (up to tie breaking) in a class of search algorithms that use the same heuristic [20].terminates andis also known to be optimally efficient in terms of the number of expandedis called an admissible algorithm since the theory guarantees that ALike every best-first search, Amaintains a prioritized queue Open which is ordered with respect to ascending valuesf (q) (see also Section 1). Initially, this queue contains only s. At each step, a state q with a minimalf -value is expanded,dequeued and put on a list called Closed. During expansion, the successor states of q are generated and inserted into thequeue Open according to their f -values. For this, the g- and the h-value of the successor states are computed dynamically.(cid:5)) =(cid:5)) denote the transition cost (edge cost). Then qFor a transition q −→ q(cid:5)) of allg(q) + c(q, qtransitions r −→ ris optimal, its cost is denoted(cid:5)).by k(q, q(cid:5)), i.e. g accumulates transition costs. In this, for a state q, g(q) is computed as the sum of the cost c(r, roccurring on the current tentative path to q. If a path between q and qis associated with its cost g(qlet c(q, q(cid:5)(cid:5)(cid:5)(cid:5)If there is more than one state with a minimum f -value, tie-breaking rules are used to select one of these states. Themost common rule is to select a state with a lowest h-value. Such states are less estimative and when a search fromsuch a state is continued, a faster termination can be expected. This idea is used again later in all methods described inSections 2.3.1, 2.3.2 and 2.3.3.(cid:5)(cid:5)(cid:5)(cid:5)A successor state qis found in this case, g(qmight be generated a second time if q(cid:5)) is updated. If qhas more than one predecessor state. If a cheaper path fromis reopened, i.e. it is put on Open again. Thuss to qstates get a second chance during the search for the minimum cost path when new information about them is available.These updates of the g-component of f to the costs of a newly found cheaper path continuously compensate for the fact(cid:5)) and is alsothat the character of the h-component is only estimative. The cheapest known path to qupdated, respectively.2was on the list Closed, qThe algorithm terminates if the next state to expand is a goal state t. The estimate h(t) = h∗(t) must be zero. In this case,∗(t)) is reportedthe path found up to t is of minimal cost, which is denoted Cfrom other best-first searches likeas solution. As has been stated in Section 1, it is the cost function which separates ADijkstra’s single-source shortest path algorithm ( f = g with g defined as above), greedy best-first search ( f = h with hdefined as above) or breadth-first search, if the edge costs are uniform and, again, f = g.as well as the optimal path (denoted p∗is denoted p(q, C∗∗(cid:5)(cid:5)2.2. MonotonicityDefinition 1. Consider an Ak of optimal paths between states. Heuristic function h is said to be monotone (or, equivalently, consistent), ifalgorithm with heuristic function h (satisfying h(t) = 0 for all goal states t) and with the cost∗h(q) (cid:2) k(q, q(cid:5)(cid:5))(2)for any descendant q) + h(q(cid:5)of q.2 In an implementation, usually only a back-pointer to the predecessor is stored. The complete path p can be reconstructed as the sequence of predeces-sors up to the initial state.R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421313In [40] it is shown that, in the case of a monotone heuristic function h, A∗finds optimal paths to all expanded nodes.More precisely:∗Theorem 1. Consider an Acheapest path to q has already been found, i.e. we have g(q) = g∗(q) and therefore p(q) = p∗(q).algorithm with a monotone heuristic function h and path cost function g. Then, if a state q is expanded, aCost updates are never needed after a first expansion. With that, every state is expanded exactly once and there is noperformance degradation by the reopening of states (as described later in Section 4).∗2.3. Weighted AsearchIn the literature, the term “weighted A. All approaches relax some of the. This is done to derive a faster algorithm with a provable upper bound on suboptimality. The ideas vary∗” subsumes several approximate variants of A∗∗conditions of Asignificantly and in the following three methods are distinguished.2.3.1. Constant inflationIn [71], Pohl’s first suggestion was the constant inflation of the heuristic function h by a fixed factor 1 + (cid:2) ((cid:2) > 0). Thatis, the cost function↑f(q) = g(q) + (1 + (cid:2)) · h(q)is used instead of the original cost function f of A∗.This method is denoted WA∗speaking of “weighted Amethod suggested by Pohl.∗since historically it is the first weighted variant of A” in the sequel, we refer to the collection of all three methods, whereas WAthat has been proposed. Whendenotes the particular∗∗is relaxed to quickly direct the search into a more promising direction. It is noteworthy that WAEven if h is admissible, that would not always hold for the inflated heuristic (see e.g. [55]). The admissibility condition∗breaks ties in favorof Aof the state with the lower h-value (without establishing a special tie breaking rule). Given, that h is admissible, it can beis (cid:2)-admissible, i.e. it always finds a solution whose cost does not exceed the optimal cost by more than ashown that WAfactor of 1 + (cid:2). In comparison to the “dynamic” variant DWA(see the next section), no other precautions against prematuretermination are taken here.∗∗∗2.3.2. Dynamic weightingPohl’s second idea [72] was to relax the fixed weighting of the heuristic function h. Algorithm DWAstarts with a highweighting of h at the beginning of the search. This may help to find a promising direction more quickly. Then the methoddynamically weights the heuristic less heavily as the search goes deeper, preventing premature termination. For (cid:2) > 0, thecost function used by DWAis∗∗f DW(q) = g(q) + h(q) + (cid:2) ·(cid:2)(cid:3)1 − d(q)N· h(q)where d(q) denotes the depth of the vertex representing state q in the search graph, and N denotes the optimal solutionlength, respectively. Usually, N is not known in advance, but then an upper bound or an estimate can be used instead.For some problems however, N is actually known. For example, sometimes all paths to a goal vertex in this graph are ofequal length, and thus the length N is the number of edges on such a path. The knowledge of N can be used for manyimprovements. It can be shown that the same (cid:2)-admissibility as for WA, if h isadmissible. Both methods are further analyzed in Section 3.(see previous section) holds for DWA∗∗2.3.3. Search effort estimatesThis section reviews an important approach of Pearl and Kim [70]. The first significant point is the extension of a set of∗states crucial for A. This set is theto a larger set, thereby “blurring” the focus and relaxing the selection condition of Af -value on Open. It is extended to the larger set of states with an f -value within 1 + (cid:2) timesset of states with minimalthe least f -value. The second important proposal is the use of a heuristic to estimate the remaining search effort at a givensnapshot of the search progress. This additional heuristic then selects a state from the aforementioned extended set of focusas the next state to expand. Thereby it provides an additional guide of the search process.In detail, Pearl and Kim [70] suggest an extension of A∗(cid:2) which adds a second queue Focal maintaining a subsetcalled Aof the states on Open. This subset is the set of those states whose cost does not deviate from the minimal cost of a state onOpen by a factor greater than 1 + (cid:2). More precisely,∗∗Focal =(cid:4)q | f (q) (cid:2) (1 + (cid:2)) · minr∈Open(cid:5)f (r)(3)∗∗∗(cid:2) selects a state q from Focal with minimal value h F (q). TheThe operation of A(cid:2) is identical to that of Afunction h F is a second heuristic estimating the computational effort required to complete the search. In this, the nature ofexcept that A1314R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342h F differs significantly from that of h since h estimates the solution cost of the remaining path whereas h F estimates theremaining time needed to find this solution. The choice of h F puts a high degree of freedom to the approach which will besubject to further investigation in Section 3. In [70], it has been suggested to use• h F = h or• to integrate properties of the subgraph emanating from a given state q.The motivation behind the first point is that minimizing the h-value for the states in the set Focal means preferring theless estimative states. As a concrete suggestion for the second point,h F (q) = N − d(q)will be used later in the experimental evaluation (see Section 7). Again, d(q) denotes the depth of the vertex representingstate q in the search graph and N is an upper bound on an optimal solution length. To minimize N − d(q) means to preferthe deeper states in the search graph. This is done with the motivation that the subgraphs emanating from them tend to be∗(cid:2) is (cid:2)-admissible,comparatively small and thus the same can be expected for the remaining run time. If h is admissible, Ai.e. we have the same upper bound 1 + (cid:2) on suboptimality as for WAand DWA∗∗.3. Unifying view∗(cid:2) in the last section,In this section, the approach of Pearl and Kim [70] which has been reviewed as the method Ais subjected to a closer consideration. Special attention is drawn to its nondeterministic formulation. Depending on thechoice of the additional heuristic h F , it basically allows for expansion of any state within the extended focus, i.e. within∗∗the set Focal. As will be shown, this allows for viewing of earlier methods as special cases of A(cid:2) has been(cid:2) . Historically, A∗published after the idea of constant inflation (WA). This suggests that Pearl and Kimalready developed their algorithm aiming at a generalization of the earlier approaches. In so far, the following unifying viewhas already been prepared by the work of Pearl and Kim. Nevertheless, in the following, the relationship of Aand∗DWAis made explicit for the first time. This enables the transfer of the more general results to the special cases, and inturn allows for a comparison of the respective methods on more formal grounds. As the first step, the next result states acondition that guarantees the conformity of a cost function with the strategy described in Section 2.3.3.) and Dynamic Weighting (DWA∗(cid:2) to WA∗∗Theorem 2. Let us consider a state space with a subset Open and a cost function f , let (cid:2) > 0 and let Focal be defined as before inEq. (3). For all states q of the state space, let f⇑(q) = (1 + (cid:2)) · f (q) and let f (q) (cid:2) f⇑(q). Let(cid:5)(q) (cid:2) fˆq = arg minq∈Open(cid:5)f(q)Then it must be that ˆq ∈ Focal.Proof. See Appendix A. (cid:2)In Section 2.3.3 we stated that the choice of the heuristic function h F leaves a considerable degree of freedom to themethod. Next, we will clarify that the other relaxation methods can be derived simply by respective choices for h F . In detail,Theorem 2 characterizes DWAas two instantiations of the generic method given in Section 2.3.3. In this, Pearland Kim’s proposal proves to be more than just another weighted variation of A. The next result shows that it also servesas a framework for weighted A∗and WA∗∗∗., and let (cid:2) > 0 be the parameter of the ATheorem 3. Let us consider a state space and its graph representation, let g be the path cost function and h be the heuristic function∗∗of A, respectively. For all states q of the state space, let↑(q) = g(q) + (1 + (cid:2)) · h(q), let d(q) denote the depth of the vertex representing q, let N denote an upper bound on an optimalfsolution length, and let f DW = g(q) + h(q) + (cid:2) · [1 − d(q)] · h(q). Further, assume that identical tie-breaking rules are used in theNalgorithms. Then we have:∗(cid:2) , WA-variations A, and DWA∗∗∗• the operation of Algorithm WA• the operation of Algorithm DWA∗(cid:2) with search estimate h F = fis identical to that of A, and∗∗(cid:2) with search estimate h F = f DW.is identical to that of A↑Proof. See Appendix A. (cid:2)In brief, the result states that the choice of the next state to expand as performed by DWA∗relaxation strategy of A(cid:2) as stated in Eq. (3). Notice that, despite the fact that DWAfunctions that are different from that of Aconforms to theare formulated by use of cost∗(cid:2) (i.e., different from f = g + h), they provably act as if f = g + h wouldor A∗and WAand WA∗∗∗∗R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421315be used. This holds since, in the formulation as an instantiation of Aprecisely this function h F that then must be replaced by the respective alternative cost function.∗(cid:2) , they are also guided by the second heuristic h F . It is∗(cid:2) to be transferred directly to DWAThe result of Theorem 3 also allows any provable result for A, as the two∗∗(cid:2) is (cid:2)-admissible. The same property follows for(cid:2) . For instance, it is well known that Amethods are special instances of A∗∗(cid:2) . It is alsoand WADWA∗known that f (q) (cid:2) (1 + (cid:2)) · C(cid:2) algorithm [70].This results in the following corollary.immediately. There is no need for specific proofs with respect to a particular instantiation of Aholds for every state q at the time of expansion during operation of an A∗and WA∗∗∗Corollary 1. Let g be the path cost function, let h be an admissible heuristic function, and let f = g + h be the cost function of∗, respectively. For A ∈operating on a state space. Further, let (cid:2) > 0 be the parameter of the AA∗{A(cid:2) , DWAfor the tentative f -values of all states at the time of expansion by A.∗} we have: f (q) (cid:2) (1 + (cid:2)) · C∗∗(cid:2) , WA-variations A, and DWA∗, WA∗∗∗Corollary 1 states a necessary condition for the expansion of a state. The result contrasts to the corresponding condition∗holds for all states q at the time of expansion (see e.g. [40] and alsoholding for the original Athe following Theorem 4). Using the unifying view it becomes possible to express the condition with the same cost function∗f = g + h for all considered algorithms, even though different cost functions are used in DWA(cid:2) . This in turn, and Aallows for a comparison of the respective instantiations.algorithm. In A, f (q) (cid:2) C∗, WA∗∗∗As a first consequence, a potential problem becomes visible for all three methods: it may be possible that some states. This effectwould be expanded by DWA∗ < f (q) (cid:2) (1 + (cid:2)) · Cq satisfying the condition Ccould, in some cases, even exceed the savings provided by the weighted approaches.∗∗(cid:2) , but not by A, and A∗(cid:2) are compared in terms of the significance of this problem. A, and A∗(cid:2) is the algorithm in its generalform, i.e. no property of a particular, second heuristic h F can be exploited. Next, Theorem 4 considers under what conditions∗andstates are eligible for state expansion. It thereby strengthens Corollary 1, providing a formal argument in favor of WADWA∗Now WA, DWA, WA∗∗∗∗∗∗(cid:2) .over general ATheorem 4. Let g be the path cost function, let h be an admissible heuristic function, and let f = g + h be the cost function of Aoperating on a state space. Further, let (cid:2) > 0 be the parameter of the A, respectively. For a snapshot∗, DWAof the progress of A ∈ {Ais the first state of this path that is not closed,i.e. that also appears on Open. Then}, consider an optimal path s, . . . , q∗∗-variations A(cid:2) , WA(cid:5)(cid:5), and DWA∗, WA∗, A∗(cid:2)where q∗∗∗∗∗• A = A: f (q) (cid:2) C∗(cid:2) : f (q) (cid:2) (1 + (cid:2)) · C• A = A∗• A = WA∗for all states q at the time of expansion.∗: for all states q at the time of expansion, either f (q) (cid:2) Cfor all states q at the time of expansion.holds or we have f (q) > C∗and f (q) (cid:2) UB where(cid:6)h(q(cid:5)(cid:7)) − h(q)(cid:5)UB = g(q) + (1 + (cid:2)) ·+ h(q)That is, for h(q) within the half-open interval [0, h(q(1 + (cid:2)) · C∗• A = DWA∗: for all states q at the time of expansion, either f (q) (cid:2) Cand C∗.(cid:5))), the upper bound UB ranges from (1 + (cid:2)) · C∗∗to C, not includingUB = g(q(cid:5)) + (1 + (cid:2)) ·(cid:2)(cid:8)(cid:5))1 − d(qN(cid:9)(cid:8)· h(q(cid:5)) −1 − d(q)N(cid:3)· h(q)+1 − d(q)N· h(q)∗holds or we have f (q) > C(cid:9)(cid:9)(cid:8)∗and f (q) (cid:2) UB where(cid:5))That is, for h(q) within the half-open interval [0, N−d(qN−d(q)(1 + (cid:2)) · Cand C∗∗.· h(q(cid:5))), the upper bound UB ranges from (1 + (cid:2)) · C∗∗to C, not includingProof. See Appendix A. (cid:2)∗∗This result indicates the following: Both for WAand for DWA, states q with Cto expansion if their f -value also stays below the stated upper bound UB. To approach the value (1 + (cid:2)) · Ch-value of the eligible state must be much less than h(qin the search graph.can only be eligiblefor UB, the(cid:5)) and/or the eligible state must reside at a significantly deeper levelThis contrasts to the situation in A∗(cid:2) where no such additional restriction holds for the eligibility for expansion. In BDDminimization (see Section 6) as well as in many other problem domains, states with equal or similar h-values and/or depthand its weighted variants. Thus, eligible states thatare often expanded during a series of consecutive expansions by A(in terms of the h-value and/or depth) to be chosen for expansion, are rare. Hence, for anreally are far enough “below” qeligible state q, f (q) (cid:2) Cis often much more typical.∗ < f (q) (cid:2) (1 + (cid:2)) · C∗∗∗∗(cid:5)Consequently it can be expected that the total number of states expanded during a run of WAtypically is at∗have many consecutiveleast no more than that for Aexpansions of nodes at the same or similar depth, this number is expected to still remain as low as in the situations where∗(cid:2) using h F = h or h F = N − d(q) runs into problems.A(and often much less). If in the targeted domain Aand DWA∗, or DWA∗, WA∗∗∗1316R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342(a) Suboptimal path to an expanded state.(b) Worst-case scenario with (cid:3) n2(cid:4) deviations, even and odd case.Fig. 1. Examples for the behavior with and without reopening.4. Monotonicity and reopeningIn [63], Likhachev et al. provide a thorough analysis of an Anytime Repairing variant of A). In the course of theiranalysis, they also raise the following question: provided that weighted Ais guided by a monotone heuristic h, can statesbe reopened? And: if so, can the performance be improved by not reopening previously opened states? This question is of∗, i.e. for the algorithms A = Ainterest for all weighted variants of A, a concrete suggestionof Likhachev et al. was to improve the method by not reopening previously expanded states (a weighted Aalgorithm with∗constant inflation is an integral part of their approach ARA). Further, the authors also prove a bound on suboptimality for∗weighted Awith constant inflation and without reopening. It was shown that the deviation of the computed solution fromthe optimum cannot be greater than 1 + (cid:2).. In the case of WA∗, DWA∗(cid:2) , WA∗∗∗∗∗∗(ARAFollowing this idea of Likhachev et al., this section as well as Section 5 aims to answer the corresponding questions for. Next, an instructive example is given which shows that reopened states can exist for all choices of.3∗general weighted A∗∗, DWA∗A = A(cid:2) , WAExample 1. In Fig. 1(a), the left datum annotated at a node is the g-value, the right one is the h-value. Edges depict statetransitions and the cost of the transition is annotated at each edge. The heuristic function h is monotone since Eq. (2) isrespected along every path in the state space graph.∗(cid:2) with h F = h and let (cid:2) = 1First, let A = A∗(cid:5)2 . In the beginning, A(cid:2) expands the initial state s with successor states q(cid:5)) = f (q0) = 2. Since q0 has the lowest h-value, theand q0. All states are cost minimal states on Open with f (s) = f (qcost of this state appears to be less estimative, i.e. the state can be expected to be the closest to a goal state. Thus q0(cid:5)) = 2. The successor state of q0, state q, appears on Focal sinceis expanded next while the minimum on Open stays f (q3 The inconsistency of the cost function of WA∗has already been pointed out by other authors, see e.g. [55].R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421317f (q) = 3 (cid:2) (1 + 1state in terms of run time. The successor state is qthe only state left on Focal, qvia q2 ) · 2 = 3. Moreover, it is the state with the lowest h-value 0, and hence it is chosen as the most promising2 ) · 2 = 3. Asis expanded next, reopening successor q. At the time of expansion of q, the best path to qwhich does not appear on Focal since f (qhad not been explored yet. Hence it is g(q) = 3 > 2 = g∗(q) and thus g(q) now is updated to the value 2.(cid:5)(cid:5)) = 4 > (1 + 1(cid:5)(cid:5)(cid:5)(cid:5)Next, it is easy to derive the same line of argument for the remaining choices of A, again showing that q is reopened., let the upper bound on an optimal solution length, let (cid:2) = 32 . In the case of A = DWA∗∗To see this in the case of A = WAN = 3 and let (cid:2) = 94 .During experiments conducted with A∗(cid:2) , using the monotone heuristic from [28], this phenomenon in fact has been∗(cid:2) has lost much ofobserved, causing high increases in run time (see Section 7). In other words, due to the relaxation, A∗the capability of A(cid:2) and its instantiations, thefollowing new result states an upper bound for the deviation of g from gto gain from the monotonicity of h. To further analyze the operation of Afor an expanded state.∗∗Lemma 1. Let (cid:2) > 0. The paths to expanded states found by an AHowever, this deviation is bounded, in detail:∗(cid:2) algorithm that is guided by a monotone heuristic may be suboptimal.∀q ∈ Closed: g(q) − g∗(cid:6)(cid:7)(q) + h(q)∗g(q) (cid:2) (cid:2) ·∗For the special instance of Algorithm WA, this result can be tightened to∀q ∈ Closed: g(q) − g(cid:5)∗(q) (cid:2) (cid:2) · k(q(cid:5), q)where qis the first state on Open on an optimal path s, . . . , q(cid:5), . . . , q at the time of expansion of q.Proof. See Appendix A. (cid:2)5. Preventing the reopening of states(4)(5)∗In this section, the simple modification of weighted Aas suggested by Likhachev et al. for the case of constant inflation,∗(cid:2) and its instantiations. This yields the final methods used in the experiments (denoted using a prefix “NR”is applied to A. Notice thatfor the “Non-Reopening” variant): NRA∗is not really a new method as it has been proposed and implemented by Likhachev et al. [63] (however, in aNRWAdifferent context).∗∗∗(cid:2) , called NRWA(cid:2) as well as two instantiations of NRA∗(cid:2) , if the method finds a better path for a closed state q, this better pathConsider the following change of operation for Aand NRDWA∗is ignored, i.e. g(q) is not updated. Otherwise, method NRA∗(cid:2) follows the usual operation of A∗(cid:2) .As has been said in the previous section, we are interested in a general bound for suboptimality, i.e. a bound for the∗∗(cid:2) ). Although (cid:2)-admissibility cannot be guaranteed for NRA(cid:2) in∗(cid:2) under the above modification (denoted NRAframework Ageneral, still the following result can be shown:Theorem 5. Let N be an upper bound on an optimal solution length. When driven by a monotone heuristic, Algorithm NRAfinds a solution not exceeding the optimal cost by a factor greater than (1 + (cid:2))(cid:3) N(cid:4).2∗(cid:2) alwaysProof. See Appendix A. (cid:2)∗Basically, the proof follows a similar line of argument as the proof for (cid:2)-admissibi-lity of A(cid:2) [70], except that, due to the∗modified behavior of the algorithm, one has to account for the following consequence. In NRA(cid:2) , the g-value of states on. By Lemma 1, states might be expandedan optimal path may irrecoverably be affected by deviations from the optimum, g∗(cid:2) , no reopening/improvementwhile the best known path to them is still suboptimal. Due to the modified behavior of NRAcan take place later. This effect increases the maximum deviation on an optimal path. The extent of the deviation is de-termined in the worst-case scenario. Let N be the maximal length of an optimal path. Since two nodes must always beincreasesinvolved for a deviation of a g-value to occur (see the proof of Lemma 1), the deviation of a g-value from gat most (cid:3) N(cid:4) times. In Fig. 1(b), dashed transition are “late” transitions, i.e. the state they lead to has already been opened2along a suboptimal path different from p. State qlast is the last state that has been prematurely opened along such a side-way and, thus, is affected by a deviation of the g-value. We have qlast = q(cid:3) N(cid:4), regardless of whether N is odd or even (seeFig. 1(b)). The proof then is an induction on i = 1, . . . , (cid:3) N2(cid:4).∗∗2Notice that the result for the case (cid:2) = 0 states that in this case operation of NRAdriven by a monotone heuristic. This is expected since Ato expanded states. Consequently the described modification in the behavior of A∗(cid:2)=0∗= A∗. Moreover, by Theorem 1, A∗(cid:2)=0 does not affect operation.∗(cid:2) , isThe fact of being bounded suboptimality is not only present for the case of constant inflation but also for general Aa new (theoretical) result in itself. However, this general bound is exponential in the depth of the search. In practice, it can∗∗(cid:2) coincides with that of Awhenalways finds optimal paths1318R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342still be useful for smaller values of (cid:2) and N, as it is the case for such examples as approximate BDD minimization. Noticethat the construction of the worst-case already gives a strong intuition that this would be a rare event. As far as the domain∗(cid:2) whichof approximate BDD minimization is concerned, this expectation has been strengthened by the performance of NRAis far off the worst-case (see Section 7). Reconsidering the upper bounds stated in Theorem 4, it is straightforward to derivethe following corollary:Corollary 2. Let g be the path cost function, let h be a monotone heuristic function, and let f = g + h the cost function of A∗on a state space. Further, let N be an upper bound on an optimal solution length and let (cid:2) > 0 be the parameter of the A∗∗(cid:2) , NRWANRA, respectively. Then, and NRDWA∗∗operating-variations∗• A = NRA• A ∈ {NRWA(cid:2) : f (q) (cid:2) (1 + (cid:2))(cid:3) N∗, NRDWA∗∗}: f (q) (cid:2) (1 + (cid:2)) · C(cid:4) · C2∗for all states q at the time of expansion, andfor all states q at the time of expansion.The proof is analogous to the one of Theorem 4. The only differences between the two proofs are in the places where, inthe proof of Theorem 4, the g-value of the first open state on an optimal path could be bounded by its respective g-value.∗(cid:2) , this is not a valid conclusion anymore, i.e. the costs of states onDue to the modification of Aoptimal paths can be higher than the optimal costs (however, they are still provably bounded, see Lemma 1 as well as theproof of Theorem 5). For more details, see the proof of Theorem 4.∗(cid:2) in the revised version NRAThe result states that the respective NRA∗(cid:2) -versions may expand more states than the original approaches, i.e. the ob-tained upper bounds for the f -value of states are larger. The reason is that, during derivation of the bounds, we mustaccount for a possible degradation of the g-value of nodes on the optimal path. As follows from the discussion of the∗(cid:2) , there is sufficient evidence that this will be a rare event for a number of application domains. Despiteworst-case of NRAthe result, for the appropriate domains an increase in run time as caused by a larger number of state expansions is notexpected in practice. It can be assumed that the revised algorithms will still often behave as forecasted by Theorem 4. Thisis confirmed later by experiments for the BDD domain in Section 7.∗6. Approximate BDD minimization – a problem domain for weighted A∗Reduced ordered Binary Decision Diagrams (BDDs) were introduced in [9]. There are many fields of application for BDDs inAI, including software model checking [29], sparse-memory applications [44,89], BDD-based planning [2,3,17,18,34,45] andsymbolic (BDD-based) heuristic search [39,73]. BDDs often enhance classical search methods of AI, such as the Aalgorithm∗to enhance model checking for hardware[30,43]. Moreover, Reffel and Edelkamp also used a BDD-based version of Averification [75]. This work also is an example of research at the intersections of AI and VLSI CAD. In VLSI CAD, BDDs arewell known from hardware verification and logic synthesis.∗BDD is a graph-based data structure for the representation of Boolean functions. Redundant nodes in the graph, i.e. nodesnot needed to represent a Boolean function f , can be eliminated. BDDs allow a unique (i.e. canonical) representation ofBoolean functions. At the same time they allow for a good trade-off between efficiency of manipulation and compactness ofthe representation.Exact BDD minimization requires to find the optimal variable ordering which yields the minimum BDD size (i.e. theminimum number of nodes). It is known to be an NP-complete problem [5]. Approaches for exact minimization have beenproposed in the hardware community. The algorithm of Friedman and Supowit [36] works on truth table representations andhas an exponential time complexity of O (n2 · 3n). This was later reduced to O (n · 3n) by application of a 2-phase bucket-sorttechnique by Sieling and Wegener [82]. Other approaches aimed more at improvement of performance without reducing theworst-case complexity [24,27,42,46]. The most recent suggestion is to use the Aalgorithm [28]. Besides the fact that theyshed additional light on the problem, there are strong reasons for this research: in several real-world applications in VLSICAD, BDDs are directly mapped to circuits. Henceforth, the BDD size can be directly transferred to the resulting chip areaand it is a significant drawback to start from a BDD whose size has been optimized by the use of heuristics. This particularlyholds when methods like the well-known sifting algorithm [25,26,76] which are based on a hill-climbing framework are faraway from the optimum. In the experiments described in this paper, the percentage loss in quality for sifting was up tomore than 80% (see Section 7.3). In [84], an instructive example is given where sifting yields a BDD as large as twice thesize of the optimum. Moreover, BDD sizes that result from sifting have been compared to known upper bounds on theoptimal sizes which have been obtained by the use of simulation-based approaches like SA or EAs [4,23]. This revealed thatthe difference can be as large as orders of magnitudes.∗In the past, numerous research papers have addressed BDD-based approaches for the automated design or logic opti-mization of FPGAs (e.g. [14–16,32,68]), of Pass Transistor Logic (PTL) or other multiplexor-based design styles [10,35,66,67].Of note is that the academic research has been strongly supported by the release of publicly available BDD-based designautomation tools like the logic optimization system BDS [86] and the PTL-oriented synthesizing tool PTLS [80].In this paper, the problem domain of approximate BDD minimization is added to the range of more typical AI problemdomains such as the sliding-tile puzzle or planning problems like logistics or blocksworld problems. To keep the paperself-contained, this section provides the necessary formal background of Boolean functions and BDDs.R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–134213196.1. Boolean functionsThe following is an introduction of the notations for Boolean functions used throughout the paper.Definition 2. Let B = {0, 1} and Xn = {x1, . . . , xn} where x1, . . . , xn are Boolean variables. Let m, n ∈ N. A mappingf : Bn → Bmis called a Boolean function. In the case of m = 1 we say fis called a multi-outputfunction. To put emphasis on the arity n of f , we may choose to write f (n) instead of f . A multi-output function f : Bn → Bmcan be interpreted as a family of m single-output functions ( f(n)iTo achieve a standard, the set of variables of a Boolean function f (n) will always be assumed to be Xn. If not statedotherwise, Boolean functions are assumed to be total (completely specified), i.e. there exists a defined function value forevery vector of input variables. The Boolean functions constantly mapping every variable to 1 (to 0) are denoted one (zero),i.e.is a single-output function, otherwise f)1(cid:2)i(cid:2)m.one : Bn → Bm; (x1, x2, . . . , xn) (cid:11)→ 1zero : Bn → Bm; (x1, x2, . . . , xn) (cid:11)→ 0An interesting class of Boolean functions are (partially) symmetric functions. Later, in Section 6.4, it is explained how the-based approach to exact BDD minimization exploits (partial) symmetry to reduce run time.∗ADefinition 3. Let f : Bn → Bm be a multi-output function. Two variables xi and x j are called symmetric, ifff (x1, . . . , xi, . . . , x j, . . . , xn) = f (x1, . . . , xi−1, x j, xi+1, . . . , x j−1, xi, x j+1, . . . , xn)Symmetry is an equivalence relation which partitions the set Xn into disjoint classes S1, . . . , Sk called the symmetry sets.is called partially symmetric, iff it has at least oneThey are sets of variables which are pairwise symmetric. A function fsymmetry set S with |S| > 1. If a function f has only one symmetry set S = Xn, then it is called totally symmetric.6.2. Shannon decompositionThe well-known theorem [79] allows decomposing Boolean functions into “simpler” sub-functions. In the following def-f to a valueis defined as the function derived from f by fixing a variable ofinition, a cofactor of a Boolean function fin B.Definition 4. Letf xi =c : Bn → Bm. For all variables in Xn it is defined asf : Bn → Bm be a Boolean function. The cofactor off with respect to xi = c (c ∈ B) is the functionf xi=c(x1, x2, . . . , xi−1, xi, xi+1, . . . , xn) = f (x1, x2, . . . , xi−1, c, xi+1, . . . , xn)Repeated cofactoring yields cofactors with respect to more than one variable, e.g. for 1 (cid:2) k (cid:2) n and a set of k variableindices {i1, . . . , ik} ⊆ {1, . . . , n}, for {xi1 , . . . , xik=ck is a cofactor inmultiple variables. This cofactor is equivalent to} ⊆ Xn and (c1, . . . , ck) ∈ Bk, the function f xi1=c2,...,xik=c1,xi2( f xi1=c1,xi2=c2,...,xi j−1=c j−1,xi j+1=c j+1,...,xik=ck )xi j=c jfor any 1 (cid:2) j (cid:2) k. Let f : Bn → Bm be a Boolean function and let xi ∈ Xn. Then function fiffis said to depend essentially on xif xi=0 (cid:13)= f xi=1Theorem 6. Let f : Bn → Bm be a Boolean function (over Xn). For all xi ∈ Xn we have:f = xi · f xi=1 + xi · f xi=06.3. BDDs(6)In the following, a formal definition of BDDs is given. We start with purely syntactical definitions by means of DirectedAcyclic Graphs (DAGs). First, single-rooted Ordered Binary Decision Diagrams (OBDDs) are defined. This definition is extendedto multi-rooted graphs, yielding Shared OBDDs (SBDDs). Next, the semantics of SBDDs is defined, clarifying how Booleanfunctions are represented by SBDDs. After that, reduction operations on SBDDs are introduced which preserve the semanticsof an SBDD. This leads to the final definition of reduced SBDDs that will be called BDDs for short.1320R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13426.3.1. Syntactical definition of BDDsFig. 2. A shared OBDD (SBDD).Definition 5. An Ordered Binary Decision Diagram (OBDD) is a pair (π , G) where π denotes the variable ordering of the OBDDand G is a finite DAG G = (V , E) (V denotes the set of vertices and E denotes the set of edges of the DAG) with exactly oneroot node (denoted root) and the following properties:• A node in V is either a non-terminal node or one of the two terminal nodes in {1, 0}.• Each non-terminal node v is labeled with a variable in Xn, denoted var(v), and has exactly two child nodes in V whichare denoted then(v) and else(v).• On each path from the root node to a terminal node the variables are encountered at most once and in the same order.More precisely, the variable ordering π of an OBDD is a bijectionπ : {1, 2, . . . , n} → Xnwhere π (i) denotes the ith variable in the ordering. The above condition “in the same order” states that for any non-terminal node v we have(cid:6)(cid:7)var(v)π −1< π −1(cid:6)(cid:6)(cid:7)(cid:7)varthen(v)iff then(v) is also a non-terminal node and(cid:6)(cid:7)var(v)π −1< π −1(cid:6)(cid:6)(cid:7)(cid:7)varelse(v)iff else(v) is also a non-terminal node.For convenience, variable orderings will be given as sequences of variables, e.g. we write x3, x1, x2 to express thatπ −1(x3) = 1 < π −1(x1) = 2 < π −1(x2) = 3.Definition 6. A Shared OBDD (SBDD) is a tuple (π , G, O ). G is a rooted, possibly multi-rooted DAG (V , E) which consists ofa finite number of graph components. These components are OBDDs, all of them respecting the same variable ordering π .O ⊆ V \ {1, 0} is a finite set of output nodes O = {o1, o2, . . . , om}. An SBDD has the following properties:• A node in V is either a non-terminal node or one of the two terminal nodes in {1, 0}.• Every root node of the component OBDD graphs must be contained in O (but not necessarily vice versa).Example 2. An example of an SBDD is given in Fig. 2. Solid lines are used for the edges from v to then(v) whereas dashedlines indicate an edge between v and else(v). The nodes pointed to by f 1, f 2 and f 3 are output nodes. Notice that everyroot node is an output node (pointed to by f 2 and f 3) and that not every output node is a root node (see the node pointedto by f 1).Also note that in SBDDs multiple graphs can share the same node, a property which helps to save nodes and to reducethe size of the diagram. The idea behind the set O is to declare additional non-terminal, non-root nodes as nodes represent-ing Boolean functions. This will be clarified in the next section when the semantics of BDDs is defined. Notice that SBDDsas well as OBDDs have at most two terminal nodes which are shared by the components.R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421321Fig. 3. Two different SBDDs for f : (x1, x2, x3) (cid:11)→ x1 · x2 + x1 · x3.6.3.2. Semantical definition of BDDsFig. 4. Deletion Rule for SBDD-reduction.Definition 7. An SBDD (. . . , G, O ), over Xn with O = {o1, o2, . . . , om} represents the multi-output function f := ( fdefined as follows:(n)i)1(cid:2)i(cid:2)m• If v is the terminal node 1, then f v = one, if v is the terminal node 0, then f v = zero.• If v is a non-terminal node and var(v) = xi , then f v is the functionf v (x1, . . . , xn) = xi · f then(v)(x1, . . . , xn) + xi · f else(v)(x1, . . . , xn)• For 1 (cid:2) i (cid:2) m, f i is the function represented by the node oi .The expression f then(v) ( f else(v)) denotes the function represented by the child nodes then(v) (else(v)). At each node ofthe SBDD, essentially a Shannon decomposition (see Theorem 6) is performed. In this, an SBDD recursively splits a functioninto simpler sub-functions.Two different variable orderings yield two different BDDs (see e.g. Fig. 7). Even if the considered variable ordering isfixed, still there exist several possibilities of representing a given function: in Fig. 3 we see two different SBDDs respectingthe same variable ordering x1, x2, x3, representing the same function f : B3 → B; (x1, x2, x3) (cid:11)→ x1 · x2 + x1 · x3. Figs. 4 and 5illustrate reduction operations on SBDDs which transform an SBDD into an irreducible form, while the function representedby the SBDD is preserved. With the Deletion Rule, redundant nodes are deleted. Subsequent application of the Merging Ruleidentifies isomorphic sub-graphs. This leads to an SBDD respecting a given variable ordering which is unique up to graphisomorphism.A reduced SBDD then is the final form of binary decision diagrams called BDD.Definition 8. An SBDD is called reduced iff there is no node where one of the reduction rules (i.e., the Deletion or theMerging Rule) applies.The following theorem [9] holds:Theorem 7. BDDs are a canonical representation of Boolean functions, i.e. the BDD-representation of a given Boolean function withrespect to a fixed variable ordering is unique up to isomorphism.1322R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342Fig. 5. Merging Rule for SBDD-reduction.6.4. Finding a best BDD variable ordering by path cost minimization6.4.1. Idea∗In this paper, approximate BDD minimization is achieved by weighted A. This approach is based on a previous work. To keep∗[28] which describes exact BDD minimization as a problem of finding a minimum cost path that is solved by Athe paper self-contained, the basic concept of this work is briefly reviewed in this section.The problem of exact BDD minimization is the problem of finding an optimal variable ordering, i.e. one that leads to aminimum number of BDD nodes. In [28], the problem of finding an optimal variable ordering is expressed as the problemof finding a minimum cost path from the initial state ∅ to the goal state Xn in the state space 2 Xn .Sets of variables q ⊆ Xn are successively growing from ∅ to Xn: q is extended at each transition by a variable xi ∈ Xn \ q,xi−→ q ∪ {xi}. The algorithm starts in the initial state ∅ and progresses until the goal state Xn is reached. As describedi.e. q∗( Xn) is an optimal∗before in Section 2.1, Asequence of transitions. Consequently, there must exist a permutation σ of the numbers 1, . . . , n (i.e., σ : {1, . . . , n} →{1, . . . , n} is a bijection) such that the aforementioned minimal cost is the accumulated transition cost for the transitions∗( Xn) from ∅ to Xn with minimal cost. The optimal path pfinds a path p∅ xσ (1)−→ {xσ (1)} xσ (2)−→ {xσ (1), xσ (2)} xσ (3)−→ · · · xσ (n)−→ Xn∗( Xn). The sequence of variables occurring on this path obviously defines a variable ordering.along pThe basic idea of the approach is the following: the above ordering annotated along the minimum cost path is intended∗( Xn) is intended to be the number of nodes in the BDD with the ordering xσ (1), xσ (2), . . . , xσ (n).∗( Xn) must be an optimal variable ordering, yieldingto be optimal. This means, fGiven, that this already holds, the sequence of variables along pthe minimum BDD size.To achieve this, an appropriate cost function is chosen. A sequence of variables occurring along the transitions from ∅ toa non-goal state has the semantics of a prefix of a variable ordering. That is, a path of length k defines the positions of thefirst k variables in a variable ordering. The key idea of [28] is to define the cost function such that the number of nodes inthe first k levels of a BDD is taken as the cost of the corresponding path of length k. In this, the method does not performvariable transpositions (as in local search approaches) but incrementally generates the ordering by adding one variable afterthe other.6.4.2. Example∗An example of a run of the A-based approach of [28] is given in Fig. 6. The algorithm is applied to the initial BDD inFig. 7(a), which represents the functionf : B4 → B; (x0, x1, y0, y1) (cid:11)→ x0 · x1 + y0 · y1First, this function is partially symmetric with two symmetry sets (see Definition 3). The first set is {x0, x1}, the second is{ y0, y1}. Because of the symmetry, for any two variables within one set, the structure of a representing BDD is preservedif their positions in a variable ordering are swapped (the only change is a renaming of the respective node labels). Second,the function is a four-input instance of the n-input “Achilles heel” function (n has to be even) given in [9]. The BDD of thismore general function has only linear size for any ordering that respects an (L, R)-partition of the variables where L, R arethe two symmetry sets. However, for an interleaved ordering where variables from different sets are neighbored, the BDDis of exponential size (for more details, see [9]). This demonstrates an “Achilles heel” of BDDs, i.e. their crucial dependencyon the ordering.All BDDs depicted in Fig. 7 are BDDs which actually have been built during the run. The graphical outputs have beengenerated by use of the GraphViz-interface of CUDD [31,83]. Different from the previous illustrations, a distinct identifier isannotated to each node whereas the actual node label (i.e., the respective variable) is annotated at the BDD levels (due tothe ordering restriction in Definition 5, the variable label is the same for all nodes of a BDD level). This enables referencesto particular nodes in the BDD in the textual descriptions of the figures. Notice that the BDDs of Fig. 7 also have someR. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421323∗Fig. 6. Aapplied to a BDD for a four-input “Achilles heel” function with a bad initial ordering.dotted edges besides the dashed and solid ones. These indicate the use of Complemented Edges (CEs). CEs are an importantextension of the basic BDD concept and have been described in [1,8]. A CE is an ordinary edge that is tagged with an extraattribute, the complement bit. This bit is set to indicate that the connected sub-graph must be interpreted as the complementof the formula that it represents. CEs allow to represent both a function and its complement by the same node, modifyingthe edge pointing to that node instead. As a consequence, only one constant node is needed. Usually the node 1 is kept,allowing the function zero to be represented by a CE to 1.The initial BDD respects the interleaved ordering x0, y0, x1, y1, which is a suboptimal ordering. In Fig. 6, states are setsof variables which constitute the nodes of the search graph. The g-value and the h-value are annotated at each state. Edgesdepict state transitions (which are always from the top to the bottom). The transition costs (edge costs) are annotated atthe edges. A detailed description of the heuristic function h used follows later in Section 6.4.3.The initial state is the empty set which is expanded to the four successors {x0}, { y0}, {x1}, { y1}. The edges leading tothem all have costs of 1 because for every successor one root node is established at the first BDD level. Since g- andh-values are identical for the first four open nodes, a second-order tie-breaking rule (which, in this case, is motivated byefficiency aspects) selects the state { y1}. During the next steps, ties in the value f = g + h are resolved (by the first-ordertie-breaking rule) in favor of the state with the lower h-value where possible.The expansion of state { y1} generates the successors { y1, x1}, { y1, y0}, and { y1, x0}. The order of elements in the setnotation gives the path taken from ∅ to the state (this saves space in the illustration). In a formal sense, paths are orderedsequences and states are unordered sets (and in particular, the distinct paths ( y1, y0) and ( y0, y1) would both end in state{ y1, y0}). However, in this small example, a state where a second, cheaper path is found, does not occur and hence the(only) path to a state is simply given by the order of elements in the state sets. The successor state { y1, x1} has a g-valueof three. This reflects the total of three nodes in the first two levels of a BDD for the example function given that variabley1 is situated at the root and variable x1 resides at the second level (see 7(b)). Notice that the structure of the first two (or,in general: k) levels holds regardless of the variable ordering in the part of the BDD below the second (or, in general: kth)1324R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342(a) Initial ordering.(b) Intermediate ordering.(c) Optimal ordering.Fig. 7. BDDs for initial, an intermediate, and the optimal ordering.level. This follows from a well-known theorem of Friedman and Supowit (for more details and a rigorous proof see [36]).This is important because otherwise the path cost function g which maps states to costs of the currently best known pathto them would have to map a state to more than one value (i.e., it would not be a well-defined function).Due to the partial symmetry of the example function, the BDDs with an ordering y1, x0, . . . have the same g-value ofthree as the BDD depicted in Fig. 7(b).In the next step, state { y1, y0} is expanded since it has the lowest h-value in the set of open states with minimalf -value of four. Again, for reasons of partial symmetry, the BDDs with the orderings y1, y0, x0, . . . and y1, y0, x1, . . . haveidentical g-value of three (and the same h-value of one). From the set of open states with the minimal f -value four, the twostates { y1, y0, x0} and { y1, y0, x1} have the lowest h-value and therefore are selected by the first-order tie-breaking rule.The second-order tie-breaking rule then selects the state { y1, y0, x1} for expansion. This results in the optimal orderingy1, y0, x1, x0 and a BDD with only four nodes (see 7(c)). Notice that this has been achieved with only four state expansions(i.e., the number of expansions is linear in the number of input variables n, which corresponds to the problem size).For brevity, several details and optimizations of the method described in [28] have been omitted. E.g., the algorithmis able to detect the symmetry sets of the variables. When operating with the according option switch USE_SYMMETRY,only the first variable of a symmetry set is processed (to obtain a simple, instructive example, this optimization has notbeen used in the example run depicted in Fig. 6). The other variables can be skipped since it is clear that the resulting g-and h-values must be the same as for the first variable (e.g. see the g- and h-values of the states { y1, x1} and { y1, x0}).Henceforth, if symmetry is exploited, also the number of generated states stays linear in the problem size n.Notice that, for the calculation of the g- and h-values, the BDD that is subjected to optimization is used itself. For thispurpose, the BDD often has to be reordered with respect to the state that is currently processed. The basic building-blockfor reordering is a swap of two adjacent BDD levels. This can be done with a graph operation that only needs to touch thevertices of the two affected BDD levels. Nevertheless this operation is time-consuming if the two BDD levels are large. Sincethis operation is needed with every expansion, the approach is often more time-bounded than memory-bounded. This is∗in classical AI domains where the time needed for an expansion is often constant, anddifferent from the application of Athus in practice these approaches are more memory-bounded. Several optimizations in [28] address the efficiency of thedynamical reordering needed at a state expansion.6.4.3. Heuristic functionNext, the heuristic function used in [28] is briefly reviewed. It was derived using a relaxation of the original model andproblem: consider a BDD representing f with an ordering which first |q| variables constitute q.The original problem is to determine the minimum number of nodes in the remaining lower part of the BDD such that fremains correctly represented; or, equivalently, such that all cofactors of f with respect to all variables in q remain correctlyrepresented.The relaxed problem then is to determine the number of such distinct cofactors. This is a lower bound on the minimumnumber of nodes to represent them. To see this, notice that at least one additional node is needed for every distinct cofactor:this node is the root node of the subgraph representing the cofactor. This cannot be said for the nodes different from thisroot since the subgraphs representing the cofactors may share nodes: e.g., in Fig. 7(b), the BDD node labeled “ce” is sharedby the subgraphs rooted at the nodes labeled “d1” and “d2”.R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421325More precisely, let f : Bn → Bm; f = ( f)1(cid:2)i(cid:2)m be a Boolean multi-output function that depends essentially on all itsinput variables. For 1 (cid:2) k (cid:2) n, let {i1, . . . , ik} ⊆ {1, . . . , n} be a set of k variable indices. Consider a state q ∈ 2 Xn with kelements that correspond to the aforementioned set of k indices, i.e. q = {xi1 , . . . , xik} ⊆ Xn. For q, let(n)i(cid:4)(cid:5)cof( f , q) =( f i)xi1=a1,...,xik=aknon-constant | 1 (cid:2) i (cid:2) m, (a1, . . . , ak) ∈ {0, 1}k(7)For state q, cof( f , q) counts the number of cofactors with respect to the variables in q. E.g., in Fig. 7(b), the cofactorswith respect to the variables in { y1, x1} are represented by the BDD nodes labeled “cd”, “d1”, and “ce”. More formally, theset cof( f , q) is the set of all distinct, non-constant (single-output) cofactors ofis interpreted as a family of n-arysingle-output functions) with respect to all variables in q. The heuristic function h : 2 Xn → N used in the approach isf ( fh(q) = max(cid:6)(cid:10)(cid:10)(cid:10)cof( f , q)(cid:10), n − |q|(cid:7)(8)It is straightforward to see that h(q) is a lower bound on the minimum number of BDD nodes in the levels |q| + 1, . . . , n ofany BDD• that represents f , and• where the variables in q are situated at the first |q| levels.First, all distinct cofactors in cof( f , q) must be represented by different nodes in levels |q| + 1, . . . , n, since otherwise theBDD would not represent f . Second, in every level from |q| + 1 to n there is at least one node since f is assumed to dependessentially on all input variables. This yields the second term n − |q|. Hence, the maximum of both lower bounds, i.e. h(q),must also be a lower bound.(cid:7)h(cid:6){ y1, x1}E.g. for the state in Fig. 7(b), the resulting h-value is(cid:6)(cid:10)(cid:10)(cid:6)(cid:10)cof(cid:10){ y1, x1}= max= max(3, 4 − 2)= 3(cid:7)(cid:10)(cid:10), n −f , { y1, x1}(cid:10)(cid:7)(cid:10)It can be computed effectively with a top down graph traversal on the BDD, counting the number of direct references fromthe upper nodes to the nodes in the lower part of the BDD [24]. Of note is that this heuristic function has the convenientproperty of monotonicity (see Definition 1). For more details and a rigorous proof, see [28].7. Experimental resultswith Branch and Bound (B&B). For a comparison of plain concepts, we did not use a combination of ATo evaluate the algorithms in discussion, the respective methods have been applied to several problem domains. The firstsuite of experiments tackles the problem of approximate BDD minimization as defined in Section 6.4. For this purpose, the-based approach of [28] which combinesrespective methods have been implemented by the authors, starting from the A∗and B&B here.AAll algorithms make use of Dial/Johnson queues to quickly determine the respective next minimum from Open [21,47]. Toput up a testing environment, all algorithms have been integrated into the CUDD package [83]. By this it is guaranteed thatthey run in the same system environment. The present expertise in this particular domain also allowed for the inclusion ofdomain-dependent approaches.∗∗∗In a second suite, weighted Ais applied to STRIPS benchmark problems in typical planning domains. They have beenobtained from previous planning competitions such as AIPS2000, IPC3 and IPC4, and from distributions of problem solversthat have been made available to the public, such as the domain-independent planner HSP2 by Bonet and Geffner [6,7].All experimental results have been carried out on a machine with a Xeon processor running at 3.2 GHz with 12 GB ofmemory. For the BDD domain, a run time limit of 3600 CPU seconds was imposed. Within the given time limit, a total of 28benchmark functions from LGSynth93 [19], a benchmark suite of combinational and sequential circuits could be minimized∗and its variants. For this purpose, the logic-level description given in a Berkeley Logic Interchange Format (BLIF) filewith Ahas been used to build the representing BDDs. Since the BDD domain is more time-bounded than other classical AI domains(see Section 6.4), the memory requirement of all evaluated methods never exceeded 500 MB, hence no memory limit wasapplied.For the planning domains, the performance of Afor different weights was compared by means of thedomain-independent planner HSP2 and our implementation of the non-reopening variant NRWAthat has been obtainedby appropriate modifications of the source code of HSP2. For this purpose, those STRIPS problems in the aforementioned∗on our machine within 100 CPU secondsplanning domains have been chosen that we succeeded to solve optimally by Aand two GB of memory. The number of these problems varies, starting from 38 and 23 problems in the PSR and Blocksworlddomain, respectively, down to only two problems in the Satellite domain.∗∗∗, WA∗and NRWAAdditionally, in Section 7.3, also hard instances of the BDD domain and the STRIPS domains (i.e., problems that cannot∗be solved with Awithin the given time and memory limit) have been solved by weighted A∗.1326R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342Fig. 8. Trading off run time for solution quality with a∗∗(cid:2) .(cid:2) and nraIn all experiments run time, solution length and the number of generated and expanded search graph nodes have beenacquired, respectively.7.1. Application to approximate BDD minimization7.1.1. Aim and methodology∗∗(cid:2) (see [70] and also Sec-(cid:2) which instantiates ATwo previous methods have been implemented: the first is called a∗(cid:2) , h F (q) = N − d(q) has been chosen, where d(q) denotes the depthtion 2.3.3) in the BDD context. As the focal heuristic of aof state q in the search graph and N is an upper bound on an optimal solution length (see also Section 2.3.3). The second is∗(see [72] and also Section 2.3.2). In the following, the parameter (cid:2) of the weighting will be referred to as the “degreeDWA∗of relaxation”. Besides the approaches WA(see Section 2.3.1), new, non-reopening∗(cid:2) )variants of two known methods have been implemented as the corresponding methods nra∗and NRDWA). The aim of the experiments was the analysis and comparison of the re-spective different methods’ suitability to let the user trade solution quality for run time. The user controls the degree ofrelaxation, resulting in different run times and final BDD sizes.∗(cid:2) (non-reopening variant of aand the non-reopening variant NRWA(non-reopening version of DWA∗∗Figs. 8, 10, and 13–15 depict the mean values of the two dimensions run time and quality for every group that isconstituted by a different degree of relaxation. In the graphs, the degree used is annotated at the points as the appliedvalue of (cid:2). The progress of the gain in run time and the loss in quality, with an increasing degree of relaxation (cid:2) isillustrated in Figs. 11 and 12: Here, mean values of the gain and loss in every group are depicted.∗∗7.1.2. Comparison of a(cid:2) to nra(cid:2)∗In a first series of experiments, A∗(cid:2) achieves a reduction in run time of 20.7% when compared to A∗∗∗, a(cid:2) have been applied to the benchmark circuits of the test suite. Fig. 8(cid:2) , and nradepicts points on the space spanned by the two dimensions solution quality (i.e. the number of BDD nodes) and total run∗:time for the whole test suite (in CPU seconds). Both methods show a significant gain in run time when compared to A∗at a degree of relaxation of 30%, a(cid:2) , the gain is. For nra34.6%. The results also show that the run time for both methods is not always monotonic decreasing when allowing for a∗rising degradation of solution quality. Instead a(cid:2) tends to jump across the spanned space when applying small increases in∗relaxation. This limits the usefulness of a(cid:2) for the desired run time/quality tradeoffs. In contrast, the plot resulting from the∗(cid:2) is very similar to a monotonic decreasing hyperbola within the range of 0% up to 30%.experiments with the method nra∗∗∗On the one hand, nra(cid:2) achieves significant better(cid:2) . However, a(cid:2) has better and more predictable run times than aqualities for (cid:2) in the range of 0.05 to 0.35 (but yields worse results for (cid:2) = 0.4). Lemma 1 formulates the reason for the∗reduced quality of nra(cid:2) : the path to an expanded state might be suboptimal and is never improved later since the state∗∗is not reopened again. I.e., for nra(cid:2) may be(cid:2) , cost deviations on an optimal path are always permanent, while those for acorrected later. However, the commentary to Theorem 5 formulated the expectation that the loss in quality would stay farbelow the stated bound. This is confirmed by the experimental results.∗(cid:2) , also the number of state expansions and state reopeningsTo explain the improved predictability of the new method nra∗(cid:2) operating athas been acquired in the experiments. The percentage of expansions that reopen a state during a run of adifferent degrees of relaxation has been depicted in Fig. 9. As can be seen, the mean percentages of reopenings for the nine∗groups have a monotonic growth in (cid:2). This explains the better run times of the nra(cid:2) -method which is not decelerated byany reopening.For both methods, the total run time increases again for a degree larger than 30%. Similar results have been observed∗(cid:2) : there, as with our application,in [70] where the Traveling Salesman Problem (TSP) has been used as a test vehicle for Athe number of states expanded often is not a monotonic decreasing function. The reason for this phenomenon lies withthe modified condition for the selection of the next, most promising state. This directly influences the necessary condition∗∗(cid:2) ) only(cid:2) (and with that, also nrais expanded, afor state expansion. While Aguarantees that no state q with f (q) > C∗∗R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421327Fig. 9. Degree of relaxation vs. percentage of reopenings of a∗(cid:2) .∗(cid:2) and NRWAFig. 10. Trading off run time for solution quality with nra∗.∗∗guarantees that states satisfying f (q) > (1 + (cid:2)) · Cwill be excluded from expansion. Consequently, it is possible that somestates q satisfying the condition (1 + (cid:2)) · Calgorithm(also see Theorem 4). We have also experimentally verified that the number of state expansions first decreases as the degree∗(cid:2) in Fig. 8, it has notof relaxation is raised, but later increases again. As the resulting plot was similar to the curve for nrabeen included due to space limitations.are expanded by weighted A, but not by the original A∗ (cid:3) f (q) > C∗The relaxation has a strong potential to reduce the run time. This is the positive effect of a more focused search. For a(cid:2)however, at least two negative effects oppose this positive effect. The first is the increase of reopenings, the second is thepotential for more state expansions in general. The unpredictability seems to result from the varying extent of influence of∗a particular relaxation (cid:2) on a total of three effects (one of them positive and two of them negative). In contrast, for nra(cid:2)only one negative effect (the general potential for an increased number of state expansions) counteracts a reduction in runtime caused by the relaxation. Here, the positive effect first predominates but eventually is absorbed and diminishes.∗∗∗(cid:2) . A disadvantage of nraConsequently, the behavior is much more predictable than for a∗(cid:2) , however, are potentially worseresults.7.1.3. Comparison of nra∗∗(cid:2) to NRWA∗∗∗In a second series of experiments A∗(cid:2) have been compared to NRWAand nracontrast to the behavior of nraas well as our expectations that also the revised version of WAstated in Theorem 4 (as has been explained in the remarks to Corollary 2). For NRWAfirst increases slowly (e.g., for (cid:2) ∈ [0, 0.5]) and later ascends more steeply with increasing (cid:2).∗∗(cid:2) , the run time of NRWA. The results are depicted in Fig. 10. Inis monotonic decreasing. This confirms the result of Theorem 4, would behave according to the upper bounds, the degradation of solution quality∗, i.e. NRWA∗The next experiments confirm the observed improved suitability of NRWA∗for a run time/quality trade-off by the user., Fig. 11 illustrates how the gain in run time grows monotonic withWhen comparing the run time of NRWAthe degree of relaxation (the curve in the space spanned by the percentage of gain and the degree (cid:2) is a convex hyperbola).At the higher relaxation degree of (cid:2) = 3.0 the reduction in run time is already more than 90% on average.Taking into account that NRWA∗(cid:2) (in particular, NRWAalso has much more convenient theoretical properties than NRA∗seems to be superiorguarantees a much tighter upper bound for the deviation of the solution from the optimum), NRWA∗(cid:2) both from a theoretical and a practical standpoint. It should be noted however, that we have only limited practicalto NRAevidence for this (in one domain only, BDD minimization). As Fig. 12 shows, high speed-ups can be obtained at an only∗to that of A∗∗∗1328R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342Fig. 11. Degree of relaxation vs. gain in run time of NRWA∗.Fig. 12. Degree of relaxation vs. loss in quality of NRWA∗.small degradation of solution quality. In fact the average degradation is considerably less than the worst-case degradationas guaranteed by the theory (a factor of 1 + (cid:2)). Also notice that for the first smaller weights the percentage of degradationgrows slowly with the weight.∗Similar results have been reported by Korf for the application of weighted Ato instances of the 15-puzzle [55]. Thisis also consistent with the results of Section 7.2, which describes experiments for typical planning domains. The resultsachieved by the method are much better than the quality guaranteed by the bound. On the one hand, this is a pleasantproperty for the practice. However, this also may indicate that the stated bound of 1 + (cid:2) can be tightened.Operating at 40% of relaxation, on average the results are only 0.5% larger than the optimum BDD size. When theoreti-cally allowing for solutions that are twice the minimum size, the average degradation still is only 4.3%. We also applied veryhigh relaxations: Fig. 12 shows that the average degradation stays below 20% for a wide range of high relaxation degrees, itfirst reaches 20.5% for (cid:2) = 20.0. For the higher weights, the resulting plot forms a convex hyperbola where the slope fallswith ascending degree of relaxation.7.1.4. Comparison of WA∗∗to NRWAand DWA∗to NRDWA∗In a third series of experiments, the solution quality and run time of the algorithms WA∗∗have been com-and NRWA∗∗(cid:2) ,(cid:2) when compared to a. The. Different from the observations for∗, shows no significant reductions in run time when compared to WApared (see Fig. 13). In contrast to the strong improvement that has been observed for Algorithm nra∗∗the revised version of WAreason is that, on average, reopenings are not a significant cause of run time for WA∗(cid:2) , the average number of reopenings does not grow significantly with the degree of relaxation.nraHowever, the picture can change when looking at specific benchmarks: When using WA, i.e. Algorithm NRWA∗∗for such examples as thecircuit s208.1, the percentage of reopenings reaches 33.5% at a relaxation of (cid:2) = 2.0. For cm150a, mux, even 52.7% of thestate expansions have been due to reopenings at a relaxation of (cid:2) = 1.0. Accordingly, the run times for these benchmarkoffers more stable run times thanfunctions are significantly higher when using WA∗since no reopenings can occur during a run of the algorithm. However, there may be a certain penalty in quality forWA∗and NRWAthe increased robustness: while there is no significant difference in the quality of solutions obtained by WAfor relaxation degrees up to 50%, at a relaxation of (cid:2) = 1.0 the solutions obtained by NRWAare on average 8.2% larger than. This corresponds to the respective observation in Section 7.1.2: by Lemma 1, states might bethe solutions yielded by WA∗,expanded by NRWAwhile the best known path to them is still suboptimal and, due to the modified behavior of NRWA∗. Therefore, NRWAinstead of NRWA∗∗∗∗∗∗R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421329∗Fig. 13. Trading off run time for solution quality with WAand NRWA∗.∗Fig. 14. Trading off run time for solution quality with DWAand NRDWA∗.Fig. 15. Trading off run time for solution quality with NRWA∗and NRDWA∗.no reopening/improvement can take place later. However, by a result of Likhachev et al., NRWAyields a result whose costdoes not exceed the optimum by more then a factor of 1 + (cid:2) [63]. For this reason, the penalty for improved robustnessremains comparatively small.Second, almost the same observations have been made when comparing DWAand NRDWA(see Fig. 14).∗∗7.1.5. Comparison of NRWA∗to NRDWA∗∗∗Next, in a fourth series of experiments, NRWAin terms of quality and run time. As canwhile at the same time slightly better resultsbe seen from Fig. 15, NRDWAcan be obtained. There is no clear relationship between the percentage of improvement of the solution and the degree ofrelaxation. However, at ascending degrees of relaxation, the blow-up of the average run time of NRDWAincreases. E.g., ata relaxation of (cid:2) = 0.3, the run time of NRDWAon average whereas the solutionobtained by NRDWA. Further increase of the relaxation yieldson average has 1.8% less BDD nodes than that of NRWAhas significantly higher run times than NRWAis 15.4% higher than that of NRWAhas been compared to NRDWA∗∗∗∗∗∗∗∗1330R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342Table 1Results of NRWA(cid:11)∗∗time A, evolutionary algorithm, simulated annealing and sifting.(cid:11)opt0.4(cid:11)time(cid:11)size3.0(cid:11)time(cid:11)sizegenetic(cid:11)time(cid:11)sizeannealing(cid:11)time(cid:11)sizesifting(cid:11)time(cid:11)size5508.39 s33882978.5 s3406331.3 s37158.05 s34096.77 s3411< 0.35 s3701improvements in the quality below 3% and yields ascending blow-ups of run time. At a relaxation of (cid:2) = 2.0, the run time∗∗of NRDWAon averageon average whereas the solution obtained by NRDWAis 1.6% smaller than the solution of NRWA. Summarized, there is a significant penalty for only small improvements inquality provided by NRDWAis already 35.9% higher than that of NRWA∗∗∗.7.1.6. Comparison of NRWA∗to classical simulation-based and heuristic techniques∗A fifth series of experiments compares the method NRWAwith classical simulation-based and heuristic techniques likeEvolutionary Algorithms (EAs) [23], Simulated Annealing (SA) [4], and Rudell’s sifting [76] which performs a classical hill-climbing approach. All algorithms are integrated into the CUDD package which is publicly available at [83]. The critical∗shows the total run time for computation of the minimumtime Apoints of our results are shown in Table 1. Columnopt shows the total number of BDDBDD size for 28 benchmark circuits of the LGSynth93 test suite with Anodes of all BDDs needed for the minimal representation of the 28 circuits. The following five double-columns (0.4), (3.0),(cid:11)size) of the BDDsgenetic, annealing, and sifting show the total run time (resulting fromtime) and the total number of BDD nodes (. Column(cid:11)(cid:11)(cid:11)∗running at a degree of relaxation of (cid:2) = 0.4 and (cid:2) = 3.0, respectively,∗• the method NRWA• the genetic algorithm of [23],• the simulated annealing approach of [4],• the hill-climbing approach of [76].∗at a relaxation degree of 40%, a large reduction of run time of 45.9% can be observed when comparingUsing NRWA∗. The actual average degradation in quality at this degree of relaxation is only 0.53%, which is a better averagewith Aquality than with the EA and with SA. For the more complex circuits, the solutions obtained by the EA, SA, and sifting canshow a significant degradation. E.g., for comp, the solution shows almost 10% more BDD nodes than the optimum size whenusing SA, more than 20% when using the EA, and sifting results in an almost 50% blow up of the solution.∗In contrast, the method NRWAhas the advantage of a guaranteed upper bound for the deviation from the optimum.This does not come for free: the run time is very high compared to the simulation-based or heuristic methods. However,with the theoretical nonapproximability result of [81], this of course is an expected result.If an average quality as low as for sifting is acceptable, much smaller run times can be achieved by higher degreesof relaxation. At a degree of (cid:2) = 3.0, all benchmarks of the test suite can be minimized within a few minutes. A certainadvantage over sifting is that the cost of the results is still guaranteed to be within four times the optimum, an upperbound for the deviation which sifting as well as the EA or SA do not guarantee. It can be expected that this bound may∗(albeiteven be grossly exceeded by EA/SA for hard problem instances, i.e. the benchmarks that cannot be solved by Afirst experiments showed no evidence which supports this hypothesis, see Section 7.3). Within the limited scope of ourexperiments, the simulation-based approaches performed well enough to raise the question whether the use of weighted∗is always beneficial in the domain of BDD minimization. On the other hand, EAs/SA might not always work that well forAthe hard examples of different benchmark suites.Moreover, good simulation-based approaches mostly depend on domain knowledge (this holds in particular for the fit-ness functions, cross over and mutation operators of EAs) and they might not be at hand for every application domain. Inparticular when solutions are very sparse, many local search methods run into problems. Opposed to that, there exists adomain-independent realization of A(see Section 7.2).and weighted A∗∗∗7.2. Weighted Aand STRIPS planning∗This section describes the application of weighted Ato STRIPS benchmark problems of typical planning domains suchas Blocksworld, Puzzle (the sliding-tile puzzle also known as (n × n) − 1 puzzle), Depots, Logistics, PSR, Satellite, Freecell,and the Driverlog domain. The additional experiments put the observations in Section 7.1 into a wider context of differentdomains, each of which with its own characteristics.7.2.1. BackgroundIn the past, several domain-independent heuristic problem solvers have been suggested, including the optimal plannersSTAN [65], BLACKBOX [50], and HSP (and, more recently, HSPr/HSP2) by Bonet and Geffner [6,7]. The more recent versions, and they are both able to search backward from theHSPr and HSP2 solve STRIPS planning problems by use of weighted Agoal to the initial state (known as “regression search” [69,85]). This was a significant improvement over the first version of∗∗∗and WAR. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421331HSP since that way unnecessary recomputations of the heuristic are avoided [6]. The heuristic is the domain-independentand admissible heuristic called “max-pair” (denoted h2) by Haslum and Geffner [41].HSPr showed a good performance in the biennial ICAPS planning competitions [6]. The source code has been madeavailable to the public. The latest version called HSP2 subsumes the functionalities of the previous releases HSP and HSPr.∗has been obtained by appropriate modifications of HSP2. ThroughoutFor our experiments, an implementation of NRWAthe experiments, backward search and the “max-pair” heuristic was used.∗∗∗(AWAThe application of Ato STRIPS problems has been subject to previous work by Bonet and Geffner [7] and byHansen and Zhou [38]. The present experiments extend these results in two aspects: first, the variation of the weight has notbeen studied very intensively. In [7] only three weights (1.0, 2.0, and 5.0) have been applied. Throughout the experimentsin [38], one more weight, 10.0, has been applied. The same authors also examine the idea of decreasing the weight after) algorithm. The reported total run times are given for the completion of alleach iteration of their Anytime WAiterations. While shedding light on the role of weights within an anytime framework, it is difficult to derive which weightso far has only been analyzed withinapproach in a particular domain. Second, NRWAwould be good for the original WAthe framework of Anytime algorithms: Likhachev et al. applied their ARAalgorithm with a special technique to limitandnode reexpansions to one particular domain (a robot planning domain) [62,63]. Hansen and Zhou reimplemented ARAexamined Likhachev’s idea to limit the number of reexpansions, with regard to more than one domain [38].Different from the first suite of experiments, we did not include the remaining variants of WA∗and A(cid:2)depend on the application domain. Dynamic Weighting works with an upper bound on an optimal solution length N. Forsome domains it is not hard to give this number (e.g., BDD minimization or Pohl’s original problem TSP), for others it maybe much harder. The automated derivation of a bound for arbitrary STRIPS domains seems very difficult. Even when givenone upper bound, the use of a tighter bound already suffices to change the behavior (see [72]).As has been discussed in Section 3, Pearl and Kims’ method A∗(cid:2) leaves a high degree of freedom. It is advantageous toutilize this freedom using the available domain knowledge. On the one hand, it is possible to obtain a domain-independent∗(cid:2) , e.g. by using the “max-pair” heuristic h2 and by resorting to the “focal” heuristic h F = h2. However, this wayvariant of A∗(cid:2) is hardly used and this hinders a fair comparison to truly domain-independent methods.the full potential of Aas both DWA∗∗∗∗∗Due to the space restrictions, we also did not include local search methods. Instead we would like to refer to therespective previous work, e.g. the experiments of Bonet and Geffner where a domain-independent hill-climbing approach[6,7] was applied to STRIPS problems in the same and similar planning domains.7.2.2. ResultsThe results of the conducted experiments are depicted in Figs. 16(a)–20(b). Figs. 16(a)–20(b), and Figs. B.3(a), B.3(b) inAppendix B, respectively, show the progression of the average run time and loss in quality with the degree of relaxation (cid:2)for the benchmark problems in the respective domain. Figs. B.1, B.2(a), and B.2(b) in Appendix B show how the total numberof expanded nodes for the problems in the respective domain varies with (cid:2).As the results show, weighted Agenerally works very well for the majority of the examined domains. For some domains,a large gain in run time is already observed for weights smaller than 1.20: e.g. for the Blocksworld domain, a weight assmall as 1.08 already yields a reduction in run time of 80%, quickly reaching 98.0% for a weight of 1.20 (see Fig. 16(a)).∗Other domains require slightly larger weights to achieve the best possible run time reductions: for the Logistics domain,the observed gain for a weight of 1.20 is already more than 40% percent. But the gain can be increased to more than90% when a weight of 1.50 is applied (see Fig. 17). In the Satellite domain, the maximum reduction in run time was 60%(achieved for a weight of 2.0 at an average loss in quality of 6%, see Figs. 18(a) and 18(b)).The gain curves generally show a high steepness, except for the PSR domain, where the curve is flatter. Here, a higherreduction in run time of more than 80% is first observed for a weight of 3.0 (but the reduction increases to more than 90%for weights beyond 3.0, see Fig. 19). The curves for the gain in run time are monotonically decreasing and relatively smoothfor almost the total range of (cid:2) in all domains. The presented theory gives reasons for this overall convenient behavior (seeTheorem 4 in Section 3). On the other hand there is no theoretical reason why this should always be the case, and actually,two noteworthy exceptions have been encountered (see Experiment 1 in Appendix B).The Blocksworld domain shows a relatively smooth degradation of quality with increasing weight (see Fig. 16(b)). Forother domains, the curves show several plateaux that are reached for the different ranges of weights. For two domains,there is only one such plateau at zero %, i.e. for all considered weights the quality is fully preserved. This holds even whenapplying high weights (Logistics and PSR, see Figs. 17 and 19). For all domains the loss in quality is either zero % or isvery close to zero if an appropriate weight is chosen. At the same time, such a weight yields a very high reduction in runtime, i.e., at least a 10X speedup. With one exception, the use of high weights did not yield losses more than 6% to 12% onaverage, and also the average run time did not increase (for an exception see Experiment 2 in Appendix B). As far as theperformance resulting from the use of high weights is concerned, the actual run times are determined by the interaction ofa positive effect (a more focused search) and a negative effect (more reopenings, see Experiment 3 in Appendix B).In all experiments, weighted Aseems to reach a “fixed point” where further increases of the weight neither have anysignificant impact on the behavior nor on the results of the run of the algorithm. Instead it seems that the same portion ofthe search space is visited and the same solution is found regardless of further weight increases. This is consistent with therespective observation in the BDD minimization domain (see Figs. 11 and 12). There is a simple reason: with large weights∗1332R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342(a) Gain for Blocksworld domain.(b) Loss for Blocksworld domain.Fig. 16. Gain and loss for the Blocksworld domain.Fig. 17. Gain and loss for the Logistics domain.∗1 + (cid:2), the term (1 + (cid:2)) · h dominates the g-value, which at some point has no effect on the decisions of the algorithm atall. By this, weighted Agradually fades to greedy best-first search (see Section 2.1).∗There are also two examples where WA∗to WAdid not work very well (see Experiment 4 in Appendix B). When comparing∗, only very small average gains are observed. However, when looking at specific problems, the method canNRWAyield significant gains in run time: Experiment 4 in Appendix B, conducted in the Freecell domain (with a reduction in thenumber of expanded and generated nodes of almost 15%, without any loss in quality) is one of them. Using a weight of10.0 in the Puzzle domain, NRWAfor problem “prob03”.Again, there is no penalty in terms of quality loss. For other problems, the observed reduction in the number of generatedyields a higherand expanded nodes was smaller (around 1–10%). However, there is also (only) one example where NRWA(see Experiment 5 in Appendix B). For more appropriate weights, this negative effectrun time than original weighted Aagain vanishes completely.expands 30% less nodes and generates 28% less nodes than WA∗∗∗∗R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421333(a) Gain for Satellite domain.(b) Loss for Satellite domain.Fig. 18. Gain and loss for the Satellite domain.Fig. 19. Gain and loss for the PSR domain.∗NRWAsometimes has a slightly higher loss in quality than WA. This seems to happen only when an inappropriateweight has been chosen (examples are the Blocksworld, the Depots and the Puzzle domain, see Figs. 16(b), 20(b), andB.3(b)). Otherwise, the quality is as good as with WA∗.∗7.3. Hard problem instances∗∗The experiments with weighted Adescribed in the previous sections included a comparison to the results and thealgorithm. Therefore it was necessary to restrict the test suites to those cases that could beperformance of the original A∗. Besides that, it is also interesting to see whether hard instances (i.e., problems that cannot be solved withsolved with A∗. In a last series of experiments, we applied aAweight of 1.20 to the hard instances of the considered STRIPS domains. On the one hand, applying weights larger than 1.20would possibly yield more solutions. However, the obtained solution lengths would not be guaranteed to be at most 20%away from the optimum anymore, making it more difficult to interpret the results. In two domains, Blocksworld and PSR,within a given time and memory limit) can be solved with weighted A∗1334R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342(a) Gain for Depots domain.(b) Loss for Depots domain.Fig. 20. Gain and loss for the Depots domain.Table 2∗Results of WAproblemBLOCK-14-0PSR-P50_S107((cid:2) = 0.2) applied to hard instances.solution length# generated nodes# expanded nodes3823101281312443341620451solutions for hard instances have been found. In Table 2, the results for the largest solved hard instances are given (solutionlengths and node counts were identical for WA).∗and NRWA∗For the BDD domain, the solutions for some hard instances have been compared to the results of sifting and thesimulation-based approaches. For a weight of 1.20, several hard instances could be solved, among the largest are countand term1 with 35 and 34 inputs, respectively. The results were not better than those for sifting. For a weight of 2.0, a so-lution for term1 of 90 BDD nodes has been obtained within a few minutes. The result of sifting is 163 BDD nodes, which ismore than 80% higher. However, the results of the simulated annealing approach and the genetic algorithm are better: SAresults in 85 BDD nodes and the EA yields only 75 BDD nodes, both within a few seconds.7.4. Summary of experimental resultsFor the domain of BDD minimization, the methods aand its non-reopening variant NRWAfor the STRIPS problems in several planning domains.have been included in a comparison to WA, while we focused on (domain-independent) realizations of the latter two approaches∗∗∗(cid:2) and NRDWA(cid:2) , nra∗∗In contrast to the rather erratic behavior of a∗(cid:2) shows a much more predictable∗(cid:2) to achieve the desired run time/quality trade-off at relaxation degrees up to 30%.behavior. A practitioner can use nra∗When compared to our instantiation of Pearl and Kims’ A(cid:2) , the increased predictability and the better run times come atthe cost of a reduction in quality. If solution quality is what matters most, the original method of Pearl and Kim can be abetter choice than the non-reopening variant.On the one hand, the method NRWA∗(cid:2) for our application, the new method nracan be considered superior to NRA∗∗(cid:2) both from a theoretical and practical stand-weredid not show a turning point in run time, i.e. no relaxation degree has∗. For this reason also the qualities of NRWA∗point: first, the practitioner can rely on the much tighter bound of NRWAmuch better than those of nra∗(cid:2) . Second, NRWA∗R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421335been observed where the number of state expansions (and therefore, the run time) would have increased again. Theorem 4sheds light on the reason for the better behavior.However, the degrees of freedom in the approach of Kim and Pearl allow for a better utilization of an expert’s domainknowledge. The fact that using this freedom was not beneficial in our BDD minimization domain (implemented with oneparticular “focal” heuristic) does not imply that this will also be the case for other domains. Also notice that, by the resultsof Section 3, NRWAis just an instance of the general framework provided by A∗∗(cid:2) .∗instead of WAThe advantages of NRDWAare debatable: slightly better results come at a rather high penalty in run time.Concerning average run time, our experiments in the BDD minimization domain did not show a clear advantage of using∗∗(cid:2) did. Similar results havedid not suffer as much from reopenings as aNRWA∗, the reduction in the number of node generations and expansions is asbeen obtained for the planning domains. For NRWAlow as one percent on average, but can be up to 30% for specific problems. In the BDD domain, the corresponding observedmaximum gain of NRWA∗in comparison to WAwas higher, more than 50%.because the method WA∗∗∗∗over NRWAThere was only one example where the use of NRWAcaused a high increase in the number of node generations andexpansions (the Depots domain, using a weight of 1.20 or 1.50) and therefore the run time here was worse than that of∗. In the BDD minimization as well as in the planning domains for some weights a small penalty in terms of quality canWA. Nevertheless, given, that a more appropriate weight is used, there is no example of abeen observed when using NRWAsignificant penalty in run time or quality for not reopening expanded nodes.∗∗In the BDD minimization domain, NRWAhas also been compared with local search techniques. The practitioner can∗processed the wholechoose an expected quality similar to that of hill-climbing approaches like sifting. In this case NRWAtest suite in minutes (however, the guaranteed bound for the deviation from the optimum then is already a factor of four).∗are still at least anIf a (guaranteed) higher quality is needed for the targeted application, the run times of weighted Aorder of magnitude away from that of sifting and the simulation-based methods. Hence, if and only if unpredictable outliersin the results or even frequently downgraded qualities (as, in particular, yielded by sifting) can always be tolerated by theapplication, sifting would probably be the way to go. If, in addition, higher run times can be accepted, the use of EAsreduces the expected frequency and magnitude of deviations from the optimum significantly. However, this still has thedisadvantage of an unpredictable quality of the results. Moreover, the design of a good EA depends on domain knowledgeand might not be at hand for every application domain, particularly if solutions are sparse.For the remaining applications where a bounded suboptimality is required (as the aforementioned VLSI applications, seesearch seems to offer an interesting alternative,Section 6), even very high run times can be accepted. Here, weighted Awhich, as a bonus, can be implemented as a domain-independent approach.∗∗Summarized, weighted Aworks very well for most of the considered problems, allowing for reductions in run time ofup to 98%, at a zero or a very small loss in quality. Exceptions are most of the problems in the Freecell domain and one, there is no definite winner. The sameproblem in the Driverlog domain. With regard to the different variants of weighted Awith local search approaches. Depending on the different users’ preferences,seems to hold when comparing weighted Aone method might be better suited than another. Theorem 4 formulates an advantage of constant overweighting over an∗(cid:2) algorithm that uses a standard cost function f = g + h. There also is some empirical evidence for this (obtained fromA∗(cid:2) framework, namely itsexperiments in one particular domain, BDD minimization). Nevertheless, the advantages of the Afreedom and generality, remain (see Section 3).∗∗Some domains require higher weights than others. Among the considered domains, the domain with the smallest effec-tive weights is the Blocksworld domain, the one with the highest is the PSR domain. PSR as well as the BDD minimizationdomain require higher weights than the remaining planning domains. While it seems difficult to give a general advice forthe choice of appropriate weights, our results suggest to choose a comparatively high weight as the first trial. It is worthmentioning that the choice of the default weight of 2.0 in the HSP planner of Bonet and Geffner also follows this strategy.In our experiments, this suffices to achieve a high reduction in run time in most cases. However, when applying even higherweights, a loss in quality of up to 20% (for one example, the Puzzle domain, even up to 70%) is the penalty. Therefore it canbe beneficial to repeatedly apply gradually decreased weights until the sum of the solution lengths falls below a thresholdfor quality (or, alternatively, a threshold for the relative improvement of quality).8. ConclusionWe have presented a unifying view on previous approaches to weighted A. A particular concern of the paper wasthe effect of not reopening expanded states. This also led to some novel variations. All considered approaches have beenstudied from a theoretical and an empirical perspective. As a technical contribution, a novel general bound on suboptimality∗has been derived from the unifying view. In an experimental evaluation, the BDD minimization problemsfor weighted Acorresponding to benchmark circuits and STRIPS benchmark problems of several classical AI planning domains have beensolved by the respective variants of weighted A. The experiments clearly demonstrate the efficiency of weighted A∗∗.∗On the one hand, the actual performance depends on the problem domain and the problem instance. In this, differentimpacts of weight and reopenings can be observed. On the other hand, many aspects of the behavior were found to besimilar in all considered domains.With regard to the considered variants of weighted A, there was no definite winner as they differed in performance,presenting more than one tradeoff. Besides the essential tradeoff run time vs. quality other tradeoffs were considered,∗∗1336R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342e.g. predictability of behavior vs. quality. Weighted Aturned out that which method suits best depends on the preferences of the user.was also compared with several local search approaches. Again, it∗∗, which is of value for the AI practitioner.We provided a detailed discussion of our experiences with weighted AAcknowledgementsThe authors would like to thank the anonymous reviewers for their helpful comments on an earlier draft of this paper.We would like to thank Shavila Devi, Armando Franco, Brandon Jue, and Jennifer Worley for their help with the Englishpresentation. Our thanks also go to Laura Lo and Yun-Pang Wang for the coordination of the proofreading. Finally, we thankTony Cohn who, after the coordination of the reviewing process, also found the time to make valuable suggestions to furtherimprove the English presentation of the final version.Appendix A. ProofsProof of Theorem 2. Let q0 = arg minq∈Open f (q). We have(cid:5)(cid:5)(ˆq)(q0)⇑f (ˆq) (cid:2) f(cid:2) f(cid:2) f(q0)= (1 + (cid:2)) · f (q0)= (1 + (cid:2)) · minq∈Openf (q)(A.1)(A.2)(A.3)(A.4)Eq. (A.1) holds by the definition of fwith the definition of f(cid:5). By Eq. (A.4), ˆq ∈ Focal already follows. (cid:2)(cid:5)in the assumption. Next, Eq. (A.2) holds by definition of ˆq. Then, Eq. (A.3) holds againProof of Theorem 3. First it is easily verified thatf (q) (cid:2) f DW(q) (cid:2) f↑(q) (cid:2) f⇑(q)for all states q of the considered state space. By Theorem 2, the respective next state expanded by WAbe contained in Focal. Second, Arespective cost function, and since the same respective tie-breaking rule is used, Arespectively. (cid:2)must∗(cid:2) chooses a state q F from Focal with q F = arg minq∈Focal h F (q). As h F is assigned to the∗,and WA∗(cid:2) must act exactly as DWAand DWA∗∗∗∗∗, AProof of Theorem 4. The results for the cases A = A(cid:2) are already well-known [40,70]. They are included to compare(cid:5),them to the new results. Because q is expanded before q↑f(q) = f (q) + (cid:2) · h(q) (cid:2) f↑(cid:5))(q∗in the case A = WA, andf DW(q) = f (q) + (cid:2) ·(cid:3)(cid:2)1 − d(q)N· h(q) (cid:2) f DW(q(cid:5))(A.5)(A.6)∗in the case of A = DWAthe left side of the two equations (A.5) and (A.6), respectively. The upper bounds range within the stated intervals since. To derive the stated upper bounds for A = WA, it now suffices to separate f (q) on, A = DWA∗∗(cid:5)) can be bounded by h• the term h(q• since an optimal path is considered, we have g(q∗(q(cid:5)) because of the admissibility of h, and(cid:5)) = g∗(q(cid:5)) and finally f∗(q(cid:5)) (cid:2) C∗. (cid:2)Proof of Lemma 1. Consider an optimal path p from s to q. Let qappears on Open.4 Assume that q (cid:13)= qmonotonicity of h (see Eq. (2)), it is straightforward to conclude the result of Theorem 1 g(q) = gsituation is different due to the relaxed selection condition.and that q is selected for expansion. In A∗(cid:5)this implies f (q) (cid:2) f (q(cid:5)be the first state on p = s, . . . , q(cid:5), . . . , q which also(cid:5)) and, using the∗∗(q). However, in A(cid:2) theLet f 0 be the minimal cost of a state on Open. With Eq. (3) and the selection condition it is f (q) (cid:2) (1 + (cid:2)) · f 0. On the, the cost(cid:5)). Different from the situation in A(cid:5)) by definition of f 0. Thus,f (q) (cid:2) (1 + (cid:2)) · f (q∗other hand we have f 0 (cid:2) f (qof q can exceed that of q(cid:5)(by a factor of 1 + (cid:2) in the worst-case).4 Notice that it is straightforward to prove that, during operation of the algorithm, at least one state on p must be an open state. The proof is aninduction on the length of p which is started by s, the very first state occurring both on Open and p.R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421337(A.7)(A.8)Consequently,g(q) + h(q) (cid:2) (1 + (cid:2)) ·= (1 + (cid:2)) ·(cid:2) (1 + (cid:2)) ·= (1 + (cid:2)) ·(cid:5)(cid:6)(cid:6)(cid:6)(cid:6)(cid:5)(cid:5)(q(cid:7)) + h(q)(cid:7)(cid:5)(cid:5)) + h(q)(cid:7)(cid:5), q) + h(q)) + k(q(q(cid:7)(q) + h(q)(cid:5)g(q∗g∗∗gg(cid:5)along p are closed, g(q∗(q(cid:5)) + k(q(A.9)(cid:5)) =(cid:5), q) is equal to∗(q) on the(cid:5)). Eq. (A.8) holds with the monotonicity of h, see Eq. (2). Eq. (A.9) holds since the sum gis the first open state on an optimal path p where all ancestors of qis an ancestor of q along an optimal path p. Then Eq. (4) follows after separating g(q) and gEq. (A.7) holds: since q∗(qg∗(q) because qgleft side of the equation.(cid:5)∗Next, let us consider the operation of WA. Since q is expanded before q(cid:5), we have f↑(q) (cid:2) f↑(q(cid:5)), and consequently,with a similar line of argument as before,(cid:5)g(q) + (1 + (cid:2)) · h(q) (cid:2) g(q(cid:2) g(q∗= g= g∗(q) + (cid:2) · k(q∗(cid:5)(cid:5)) + (1 + (cid:2)) · h(q) + (1 + (cid:2)) ·(cid:5)) + k(q(q(q) + (cid:2) · k(q(cid:6)k(q, q) + (cid:2) · k(q(cid:5)(cid:5))(cid:7)(cid:5), q) + h(q)(cid:5), q) + (1 + (cid:2)) · h(q)(cid:5), q) and Eq. (5) follows. (cid:2)Consequently, g(q) (cid:2) g, q) + (1 + (cid:2)) · h(q)(cid:5)1, . . . , q1 which alsoProof of Theorem 5. Consider an optimal path p from s to q1. Let q∗(cid:5)appears on Open. Assume that q1 (cid:13)= q(cid:2) , q1 is1 and that q1 is selected for expansion. Due to the modified behavior of NRAmarked as closed afterwards. To start an induction on the length of p, assume that this is the first time this situation occursduring operation. Let f 0 be the minimal cost of a state on Open. As long as q(cid:5)1 be the first state on p = s, . . . , q(cid:5)1 resides on Open, we havef (r) (cid:2) (1 + (cid:2)) · f 0 (cid:2) (1 + (cid:2)) · f (q(cid:5)1)for every open state r that is eligible to expansion. Moreover,∗f (q(cid:5)1) (cid:2) Ccan be concluded: since qfollows. Consequently, f (r) (cid:2) (1 + (cid:2)) · C∗.(cid:5)1 is the first open state on an optimal path, it is g(q(cid:5)1) = g∗(q(A.10)(cid:5)1). As h is admissible, Eq. (A.10)However, the deviation can become worse: q∗(cid:2) ignores better paths to closed states, g(q1) will not be updated with the optimal path cost along qNRAwill never reach f(cid:5)1 might eventually be expanded as one of the next steps of operation. Asf (q1)(cid:5)1 on p, i.e.∗(q1). However, by Lemma 1 this loss in exactness must be bounded,5 i.e. it is(q1) (cid:2) (cid:2) ·(cid:7)(q1) + h(q1)g(q1) − g∗(cid:6)∗(A.11)The last equation holds with a similar argument as for f (q(cid:5)1) above.In the following, refer to Fig. 1(b) for the notation and an illustration of the idea. In an induction on the length of p,(cid:4) wea similar argument is applied repeatedly on all remaining pairs of adjacent states (qiclaim(cid:5), qi) on p, that is, for 1 (cid:2) i (cid:2) (cid:3) N2g(qi) − g∗(qi) (cid:2) (cid:2) · C∗ ·i−1(cid:12)(1 + (cid:2))kk=0(A.12)In the case of i = 1, the claim is equivalent to Eq. (A.11). Now assume the claim is proven for i. For the step i −→ i + 1we deriveg(q(cid:5)i+1) = g(qi) + k(qi, q(cid:5)i+1)i−1(cid:12)∗(cid:2) g(qi) + (cid:2) · C∗ ·(1 + (cid:2))k + k(qi, qk=0(cid:2) g∗(q(cid:5)i+1) + (cid:2) · C∗ ·i−1(cid:12)(1 + (cid:2))kk=0(cid:5)i+1)(A.13)(A.14)5 The lemma can be applied here since the operation of A∗(cid:2) and NRA∗(cid:2) is identical before the first state has been reopened.g∗(cid:2) (cid:2) · C1338R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342Eq. (A.13) holds with the induction hypothesis in Eq. (A.12), Eq. (A.14) holds with the optimality of p. It is f (qi+1) (cid:2)(cid:5)(1 + (cid:2)) · f (q1. But then,similar to the argument of Lemma 1,(cid:5)i+1: this holds with the same argument as applied before to q(cid:5)i+1) since qi+1 is expanded before q(cid:6)(cid:7)g(qi+1) + h(qi+1)(cid:2) (1 + (cid:2)) ·(cid:6)g(q(cid:13)(cid:5)i+1) + h(q(cid:7)(cid:5)i+1)(cid:2) (1 + (cid:2)) ·∗g(q(cid:5)i+1) + (cid:2) · C∗ ·(cid:2) (1 + (cid:2)) ·(cid:13)(cid:13)∗g(q(cid:5)i+1) + k(qi−1(cid:12)(1 + (cid:2))k + h(q(cid:14)(cid:5)i+1)k=0(cid:5)i+1, qi+1) + h(qi+1) + (cid:2) · C(cid:14)∗ ·(cid:14)i−1(cid:12)(1 + (cid:2))kk=0(cid:2) (1 + (cid:2)) ·∗g(qi+1) + h(qi+1) + (cid:2) · C∗ ·(1 + (cid:2))ki−1(cid:12)k=0Eq. (A.15) holds with Eq. (A.14), Eq. (A.15) holds with the monotonicity of h (see Eq. (2)), and Eq. (A.15) holds with theoptimality of path p. By Eq. (A.15), it is(cid:13)g(qi+1) (cid:2) (1 + (cid:2)) ·∗g(qi+1) + (cid:2) · C∗ ·and consequently(cid:14)i−1(cid:12)(1 + (cid:2))kk=0+ (cid:2) · h(qi+1)g(qi+1) − g∗(qi+1) (cid:2) (cid:2) ·(cid:15)(cid:16)(qi+1) + h(qi+1)∗g+ (1 + (cid:2)) · (cid:2) · C∗ ·i−1(cid:12)(1 + (cid:2))kk=0= (cid:2) ·(cid:15)(cid:16)(qi+1) + h(qi+1)∗g+ (cid:2) · C∗ ·i−1(cid:12)(1 + (cid:2))k+1= (cid:2) ·(cid:15)(cid:16)(qi+1) + h(qi+1)∗g+ (cid:2) · C∗ ·k=0i(cid:12)(1 + (cid:2))kk=1(cid:2) (cid:2) · C∗ + (cid:2) · C∗ ·i(cid:12)(1 + (cid:2))kk=1= (cid:2) · C∗ ·i(cid:12)(1 + (cid:2))kk=0and the claim of the induction is shown. Eq. (A.15) holds with the admissibility of h. In particular, for qlast = q(cid:3) N2(A.15)(cid:4)g(qlast) − g∗(qlast) (cid:2) (cid:2) · C∗(cid:4)−1(cid:12)(cid:3) N2(1 + (cid:2))kk=0which is 0 if (cid:2) = 0, otherwise we haveg(qlast) − g∗(qlast) (cid:2) (cid:2) · C∗(cid:4)−1(cid:12)(cid:3) N2(1 + (cid:2))kk=0= (cid:2) · C(cid:4) − 12∗ · (1 + (cid:2))(cid:3) N(cid:2)(cid:15)(cid:4) − 1(cid:3) N2∗(cid:4) − C(1 + (cid:2))(cid:3) N∗ · (1 + (cid:2))2∗ ·(cid:16)= C= C(A.16)Eq. (A.16) holds with the well-known sum formula for geometric series (which only applies in the case (cid:2) (cid:13)= 0). That is, onany optimal path constructed during operation of NRA∗(qlast)∗(cid:2) , the deviation from the optimum is not greater than a factor∗ + g(qlast) − gC(cid:4)C ∗= (1 + (cid:2))(cid:3) N2(cid:2)R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421339Fig. B.1. Total number of expansions for the Blocksworld domain.Appendix B. Additional experimentsExperiment 1. For the Blocksworld domain there is one weight, 1.10, for which the curve progression suggests an averagegain of around 90%, but the measured value is only 60% (see Fig. 16(a)). This corresponds to high numbers of expandednodes that do not fit the general progression of the curve (see Fig. B.1). A similar observation has been made for the Satellitedomain from IPC4 (see Fig. 18(a)). Here, the weight 1.50 yields a higher average run time and a larger total number ofgenerated and expanded nodes than a weight of 1.20 (see Fig. B.2(b) for the expanded nodes).Experiment 2. The exception from the general rule that higher weights usually do not cause high degradations of solutionquality is the set of instances of the Eight-Puzzle (it is contained in the HSP2 distribution): the average loss in quality wentup to 70% when applying weights larger then 10.0 (see Fig. B.3(b)). For the random puzzle prob04, the number of generatedand expanded nodes more than doubles when the weight is increased from 3.0 to 6.0 (but both numbers fall to less thanhalf of their original value when a weight of 11.0 is applied). The harder instances prob02 and prob03 show a similar blowup for the weights 10.0 and 11.0.Experiment 3. A potential negative effect of higher weights is the increase in the number of reopenings, since the incon-sistency of the weighted heuristic increases. We observed that this effect diminishes for several domains (e.g. Blocksworld,Depots and the Logistics domain), if the weights are further increased. E.g., the problems of the Depots domain have re-openings for a weight w = 1.20, but not for w (cid:3) 2.0, and those of the Logistics domain have reopenings for 1.10 (cid:2) w (cid:2) 2.0,but not for w (cid:3) 3.0). Here the number of reopenings goes back to zero again since the positive effects of the relaxation(i.e., a more focused search that helps good solutions more quickly) take over. The benefit from the relaxation becomesdominating for the higher weights. For the sliding tile puzzle, it is vice versa (that is, the reduction in run time resultingfrom the relaxation is absorbed more and more by the increase in reopenings). Nevertheless, the total number of generatedand expanded nodes for the examined set of Eight-Puzzles is not increased significantly for higher weights. This is becausethe weights with an aforementioned negative effect are different for distinct problems (and also have positive effects on∗other problems). So for this experiment, WAworked well.∗Experiment 4. The first example for poor performance of WAis in the Driverlog domain from IPC3, where one problem ofsize 2 (named pfile1) is completely insensitive to changes in the weight. Regardless of the applied weight, the same numberof nodes were created and expanded, yielding the same solution as with A. The second example is the set of problems ofwas able to solve them all (but none of the biggersize 2 in the Freecell domain from the AIPS2000 benchmark collection: A∗problems) on our machine within 100 seconds. Unfortunately, neither WAnor the non-reopening variant can solve theseproblems more quickly: for the weights 1.01, 1.02, . . . , 1.10 there is no change in the number of expanded or generated. For the weight 1.20 the number of expanded or generated nodes, and also the run timenodes compared to that of Aalready more than doubles, and the higher weights 2.0, 5.0, and 10.0 result in a dramatic increase of generated and createdworks best whennodes. Hence the run time limit of 100 seconds is exceeded. Hansen and Zhou state that weighted Amany close-to-optimal solutions are available [38]. Freecell in fact is an example of a domain with a rather sparse solutionspace which probably is the reason for the observed behavior.∗∗∗∗∗and NRWAThe same authors also report a successful experiment applying AWAto a Freecell problem of size 3, using a weight of2.0. The algorithm then failed to find a solution before running out of memory with higher weights of 5.0 and 10.0. We∗applied WAon the problem of the IPC3 suite of size 3. Our results are consistent with the observations of∗Hansen and Zhou, as with a weight of 2.0 a solution is found in less than two seconds with both variants of weighted A.Moreover, both methods result in the same solution length. The non-reopening variant NRWAperforms significantly fasteras only 2879 nodes are expanded (and 15118 nodes are generated) instead of 3387 nodes expanded (and 17757 generated)∗by WA. Here, many reopenings are avoided by the use of the non-reopening variant. Both variants perform much worse∗∗1340R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342(a) Node expansions for Depots domain.(b) Node expansions for Satellite domain.Fig. B.2. Total number of expansions for selected domains.(a) Gain for Puzzle domain.(b) Loss for Puzzle domain.Fig. B.3. Gain and loss for the Puzzle domain.R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–13421341for a weight of 1.50 and fail completely for all weights greater than or equal to 3.0 that have been tried (5.0, 10.0, 20.0,and 50.0).Experiment 5. The (only) examples where NRWAare in the Depots domain from IPC3where the weight 1.20 (and, less dramatically, also the weight 1.50) causes a high increase in the number of generated andexpanded nodes (see Fig. B.2(a) for the expanded nodes).yields a higher run time than WA∗∗References[1] S. Akers, Functional testing with binary decision diagrams, in: Eighth Annual Conf. on Fault-Tolerant Computing, 1978, pp. 75–82.[2] P. Bertoli, A. Cimatti, M. Roveri, Heuristic search symbolic model checking = efficient conformant planning, in: Proc. of the Int’l Joint Conf. on ArtificialIntelligence, 2001, pp. 467–472.[3] P. Bertoli, A. Cimatti, M. Roveri, P. Traverso, Planning in non-deterministic domains under partial observability via symbolic model checking, in: Proc.of the Int’l Joint Conf. on Artificial Intelligence, 2001, pp. 473–478.[4] B. Bollig, M. Löbbing, I. Wegener, Simulated annealing to improve variable orderings for OBDDs, in: Int’l Workshop on Logic Synth., 1995, pp. 5b:5.1–5.10.[5] B. Bollig, I. Wegener, Improving the variable ordering of OBDDs is NP-complete, IEEE Trans. on Comp. 45 (9) (1996) 993–1002.[6] B. Bonet, H. Geffner, Heuristic search planner 2.0, AI Magazine 22 (3) (2001) 77–80.[7] B. Bonet, H. Geffner, Planning as heuristic search, Artificial Intelligence 129 (1) (2001) 5–33.[8] K. Brace, R. Rudell, R. Bryant, Efficient implementation of a BDD package, in: Design Automation Conf., 1990, pp. 40–45.[9] R.E. Bryant, Graph-based algorithms for Boolean function manipulation, IEEE Trans. on Comp. 35 (8) (1986) 677–691.[10] P. Buch, A. Narayan, A. Newton, A. Sangiovanni-Vincentelli, Logic synthesis for large pass transistor circuits, in: Int’l Conf. on CAD, 1997, pp. 663–670.[11] T. Bylander, Complexity results for planning, in: Proc. of the Int’l Joint Conference on Artificial Intelligence, 1991, pp. 274–279.[12] T. Cain, Practical optimisation for A[13] P. Chakrabarti, S. Ghose, A. Acharya, S. de Sarkar, Heuristic search in restricted memory, Artificial Intelligence 47 (1989) 197–221.[14] S. Chang, M. Marek-Sadowska, T. Hwang, Technology mapping for TLU FPGAs based on decomposition of binary decision diagrams, IEEE Trans. onpath generation, in: AI Game Programming Wisdom, Charles River Media, 2002, pp. 146–152.∗CAD 15 (10) (1996) 1226–1236.[15] M. Chrzanowska-Jeske, Z. Wang, Mapping of symmetric and partially-symmetric functions to the CA-type FPGAs, in: Proc. Midwest Symp. on Circuitsand Systems, 1995, pp. 290–293.[16] M. Chrzanowska-Jeske, Z. Wang, Y. Xu, A regular representation for mapping to fine-grain locally-connected FPGAs, in: Proc. Int’l Symp. on Circuits andSystems, 1997, pp. 2749–2752.[17] A. Cimatti, E. Giunchiglia, F. Giunchiglia, P. Traverso, Planning via model checking: A decision procedure for AR, in: Proc. of the European Conf. onPlanning, 1997, pp. 130–142.[18] A. Cimatti, M. Roveri, P. Traverso, Automatic OBDD-based generation of universal plans in non-deterministic domains, in: Proc. of the National Conf. onArtificial Intelligence, 2000, pp. 875–881.[19] Collaborative Benchmarking Laboratory, 1993 LGSynth Benchmarks, North Carolina State University, Department of Computer Science, 1993.[20] R. Dechter, J. Pearl, Generalized best-first search strategies and the optimality of A, Journal of the Association for Computing Machinery 32 (3) (1985)∗505–536.[21] R.B. Dial, Algorithm 360: Shortest path forest with topological ordering, Commun. ACM 12 (11) (1969) 632–633.[22] E.W. Dijkstra, A note on two problems in connexion with graphs, Numerische Mathematik 1 (1959) 269–271.[23] R. Drechsler, B. Becker, N. Göckel, A genetic algorithm for variable ordering of OBDDs, IEE Proc. Comp. Digital Techniques 143 (6) (1996) 364–368.[24] R. Drechsler, N. Drechsler, W. Günther, Fast exact minimization of BDDs, IEEE Trans. on CAD 19 (3) (2000) 384–389.[25] R. Drechsler, W. Günther, F. Somenzi, Using lower bounds during dynamic BDD minimization, IEEE Trans. on CAD 20 (1) (2001) 51–57.[26] R. Ebendt, R. Drechsler, The effect of lower bounds in dynamic BDD reordering, IEEE Trans. on CAD 25 (5) (2006) 902–909.[27] R. Ebendt, W. Günther, R. Drechsler, An improved branch and bound algorithm for exact BDD minimization, IEEE Trans. on CAD 22 (12) (2003) 1657–1663.[28] R. Ebendt, W. Günther, R. Drechsler, Combining ordered best-first search with branch and bound for exact BDD minimization, IEEE Trans. onCAD 24 (10) (2005) 1515–1529.[29] S. Edelkamp, T. Mehler, Byte code distance heuristics and trail direction for model checking Java programs, in: Proc. of the Workshop on ModelChecking and Artificial Intelligence, 2003, pp. 69–76.[30] S. Edelkamp, F. Reffel, OBDDs in heuristic search, in: Advances in Artificial Intelligence, in: LNAI, Springer Verlag, 1998, pp. 81–92.[31] J. Ellson, E. Gansner, G. Low, D. Dobkin, E. Koutsofios, S. North, K.-P. Vo, G. Woodhull, Graphviz – graph visualization software, Websitehttp://www.graphviz.org, 2000–2008.[32] S. Ercolani, G.D. Micheli, Technology mapping for electronically programmable gate arrays, in: Proc. of the 28th Design Automation Conf., 1991, pp.234–239.[33] A. Felner, S. Kraus, R. Korf, KBFS: K-best first search, Annals of Mathematics and Artificial Intelligence 39 (1–2) (2003) 19–39.[34] Z. Feng, E. Hansen, S. Zilberstein, Symbolic generalization for on-line planning, in: Proc. of the Annual Conf. on Uncertainty in Artificial Intelligence,2003, pp. 209–216.[35] F. Ferrandi, A. Macii, E. Macii, M. Poncino, R. Scarsi, F. Somenzi, Symbolic algorithms for layout-oriented synthesis of pass transistor logic circuits, in:Int’l Conf. on CAD, 1998, pp. 235–241.[36] S. Friedman, K. Supowit, Finding the optimal variable ordering for binary decision diagrams, IEEE Trans. on Comp. 39 (5) (1990) 710–713.[37] M. Garey, D. Johnson, Computers and Intractability. A Guide to the Theory of NP-Completeness, W.H. Freeman, New York, 1979.[38] E. Hansen, R. Zhou, Anytime heuristic search, Journal of Artificial Intelligence Research 28 (2007) 267–297.[39] E. Hansen, R. Zhou, Z. Feng, Symbolic heuristic search using decision diagrams, in: Symp. on Abstraction, Reformulation and Approximation, 2002, pp.83–98.[40] P. Hart, N. Nilsson, B. Raphael, A formal basis for the heuristic determination of minimum cost paths, IEEE Trans. Syst. Sci. Cybern. 2 (1968) 100–107.[41] P. Haslum, H. Geffner, Admissible heuristics for optimal planning, in: Proc. Int’l Conf. on AI Planning Systems, 2000, pp. 70–82.[42] N. Ishiura, H. Sawada, S. Yajima, Minimization of binary decision diagrams based on exchange of variables, in: Int’l Conf. on CAD, 1991, pp. 472–475.∗[43] R. Jensen, R. Bryant, M. Veloso, SetAalgorithm, in: Proc. of the National Conf. on Artificial Intelligence, 2002, pp. 668–673.[44] R. Jensen, E. Hansen, S. Richards, R. Zhou, Memory-efficient symbolic heuristic search, in: Proc. of Int’l Conf. on Automated Planning and Scheduling,: An efficient BDD-based A∗2006, pp. 304–313.[45] R. Jensen, M. Veloso, ASET: A multi-agent planning language with nondeterministic durative tasks for BDD-based fault tolerant planning, in: Proc. ofInt’l Conf. on Automated Planning and Scheduling: Workshop on Multiagent Planning and Scheduling, 2005, pp. 58–65.1342R. Ebendt, R. Drechsler / Artificial Intelligence 173 (2009) 1310–1342[46] S.-W. Jeong, T.-S. Kim, F. Somenzi, An efficient method for optimal BDD ordering computation, in: Int’l Conf. on VLSI and CAD, 1993.[47] D.B. Johnson, Efficient algorithms for shortest paths in sparse networks, J. ACM 24 (1) (1977) 1–13.[48] H. Kaindl, G. Kainz, Bidirectional heuristic search reconsidered, Journal of Artificial Intelligence Research 7 (1997) 283–317.[49] H. Kaindl, A. Khorsand, Memory-bounded bidirectional search, in: Proc. of the 12th National Conf. on Artificial Intelligence, 1994, pp. 1359–1364.[50] H. Kautz, B. Selman, Unifying SAT-based and graph-based planning, in: Proc. Int. Joint Conf. on Artificial Intelligence, 1999, pp. 318–327.[51] H. Kobayashi, H. Imai, Improvement of the Aalgorithm for multiple sequence alignment, in: Proc. of the 9th Workshop on Genome Informatics, 1998,∗pp. 120–130.[52] A. Köll, H. Kaindl, A new approach to dynamic weighting, in: Proc. of the European Conf. on Artificial Intelligence, 1992, pp. 16–17.[53] A. Köll, H. Kaindl, Bidirectional best-first search with bounded error: Summary of results, in: Proc. of the 13th International Joint Conf. on ArtificialIntelligence, 1993, pp. 217–223.[54] R.E. Korf, Planning as search: A quantitative approach, Artificial Intelligence 33 (1) (1987) 65–68.[55] R.E. Korf, Linear-space best-first search, Artificial Intelligence 62 (1) (1993) 41–78.[56] R.E. Korf, A complete anytime algorithm for number partitioning, Artificial Intelligence 106 (2) (1998) 181–203.[57] R.E. Korf, An improved algorithm for optimal bin packing, in: Proc. of Int’l Joint Conf. on Artificial Intelligence, 2003, pp. 1252–1258.[58] R.E. Korf, Optimal rectangle packing: New results, in: Proc. of Int’l Conf. on Automated Planning and Scheduling, 2004, pp. 142–149.[59] R.E. Korf, W. Zhang, Divide-and-conquer frontier search applied to optimal sequence alignment, in: Proc. of the 17th National Conf. on ArtificialIntelligence, 2000, pp. 910–916.[60] R.E. Korf, W. Zhang, I. Thayer, H. Hohwald, Frontier search, J. ACM 52 (5) (2005) 715–748.[61] K. Kotecha, N. Gambhava, A hybrid genetic algorithm for minimum vertex cover problem in: Proc. of the Indian Int’l Conf. on Artificial Intelligence,2003, pp. 904–913.[62] M. Likhachev, D. Ferguson, G. Gordon, A. Stentz, S. Thrun, Anytime search in dynamic graphs, Artificial Intelligence 172 (14) (2008) 1613–1643.∗[63] M. Likhachev, G. Gordon, S. Thrun, ARA: Formal analysis, Technical report of the Carnegie Mellon University, 2003.∗[64] M. Likhachev, G.J. Gordon, S. Thrun, ARAwith provable bounds on sub-optimality, in: S. Thrun, L. Saul, B. Schölkopf (Eds.), Advances in: Anytime A∗Neural Information Processing Systems, vol. 16, MIT Press, Cambridge, MA, 2004.[65] D. Long, M. Fox, The efficient implementation of the plan-graph in STAN, J. of Artificial Intelligence Research 10 (1999) 85–115.[66] L. Macchiarulo, L. Benini, E. Macii, On-the-fly layout generation for PTL macrocells, in: Design, Automation and Test in Europe, 2001, pp. 546–551.[67] A. Mukherjee, R. Sudhakar, M. Marek-Sadowska, S. Long, Wave steering in YADDs: A novel, non-iterative synthesis and layout technique, in: DesignAutomation Conf., 1999, pp. 466–471.[68] R. Murgai, Y. Nishizaki, N. Shenoy, R. Brayton, A. Sangiovanni-Vincentelli, Logic synthesis for programmable gate arrays, in: Proc. of the 27th DesignAutomation Conf., 1991, pp. 620–625.[69] N. Nilsson, Principles of Artificial Intelligence, Tioga Publishing Company, Palo Alto, CA, 1980.[70] J. Pearl, J. Kim, Studies in semi-admissible heuristics, IEEE Trans. on Pattern Analysis and Machine Intelligence PAMI-4 (4) (1982) 392–399.[71] I. Pohl, Heuristic search viewed as path finding in a graph, Artificial Intelligence 1 (3) (1970) 193–204.[72] I. Pohl, The avoidance of (relative) catastrophe, heuristic competence, genuine dynamic weighting and computational issues in heuristic problemsolving, in: Proc. of the 3rd Int. Joint Conf. on Artificial Intelligence, 1973, pp. 12–17.[73] K. Qian, A. Nymeier, Heuristic search algorithms based on symbolic data structures, in: Proc. of the Australian Conf. on Artificial Intelligence, 2003, pp.966–979.[74] D. Ratner, M. Warmuth, Finding a shortest solution for the (n × n)-extension of the 15-puzzle is intractable, J. Symbolic Computation 10 (2) (1990)111–137.[75] F. Reffel, S. Edelkamp, Error detection with directed symbolic model checking, in: World Congress on Formal Methods, 1999, pp. 195–211.[76] R. Rudell, Dynamic variable ordering for ordered binary decision diagrams, in: Int’l Conf. on CAD, 1993, pp. 42–47.[77] S. Russell, Efficient memory-bounded search methods, in: Proc. of the 10th European Conf. on Artificial Intelligence, vol. 16, 1992, pp. 701–710.[78] S. Schroedl, An improved search algorithm for optimal multiple-sequence alignment, Journal of Artificial Intelligence Research 23 (2005) 587–623.[79] C. Shannon, A symbolic analysis of relay and switching circuits, Trans. AIEE 57 (1938) 713–723.[80] R. Shelar, S. Sapatnekar, Pass Transistor Logic Synthesizer Version 1.0 (PTLS), University of Michigan, 2002.[81] D. Sieling, Nonapproximability of OBDD minimization, Information and Computation 172 (2) (2002) 103–138.[82] D. Sieling, I. Wegener, Reduction of BDDs in linear time, Information Processing Letters 48 (3) (1993) 139–144.[83] F. Somenzi, CU decision diagram package release 2.4.1, University of Colorado at Boulder, available at http://vlsi.colorado.edu/~fabio/CUDD/, 2004.[84] I. Wegener, Worst case examples for operations on OBDDs, Information Processing Letters 74 (2000) 91–96.[85] D. Weld, An introduction to least commitment planning, AI Magazine 15 (4) (1994) 27–61.[86] C. Yang, M. Ciesielski, BDS: A BDD-based logic optimization system, IEEE Trans. on CAD 21 (7) (2002) 866–876.[87] R. Zhou, E. Hansen, Memory-bounded A[88] R. Zhou, E. Hansen, Multiple sequence alignment using anytime Agraph search, in: 15th Int. Florida Artificial Intelligence Research Soc. Conf., 2002, pp. 203–209., in: Proc. of the 18th National Conf. on Artificial Intelligence, Student Abstract,∗∗2002, pp. 975–976.[89] R. Zhou, E. Hansen, Sparse-memory graph search, in: Proc. of the 18th Joint Conf. on Artificial Intelligence, 2003, pp. 1259–1266.[90] R. Zhou, E. Hansen, Sweep A: Space-efficient heuristic search in partially ordered graphs, in: Proc. of the 15th IEEE Int. Conf. on Tools with Artificial∗Intelligence, 2003, pp. 427–434.