Artificial Intelligence 87 ( 1996) 145-I 86 Artificial Intelligence Planning from second principles Jana Koehler * Depariment of Computer Science, Albert Ludwigs University, Am Flughafen 17, D-791 10 Freiburg, Germany Received June 1994; revised June 1995 Abstract Planning from second principles by reusing and modifying plans is one way of improving the efficiency of planning systems. In this paper, we study it in the general framework of deductive planning and develop a logical formalization of planning from second principles, which relies on a systematic decomposition of the planning process. Deductive inference processes with clearly defined semantics formalize each of the subtasks a second principles planner has to address. Plan modification, which comprises matching and adaptation tasks, is based on a deductive approach yielding provably correct modified plans. Description logics are introduced as query languages to plan libraries, which leads to a novel and efficient solution to the indexing problem in case-based reasoning. Apart from sequential plans, this approach enables a planner to reuse and modify complex plans containing control structures like conditionals and loops. 1. Introduction actions and tries to construct to specified preconditions. A serious Planning from first principles generates plans from “scratch”. The planner its set of available with respect is the invariable nature of the planning process over time: If a planner the same planning problem, words, it is unable processes. inspects a plan the desired goal limitation of first principles planners receives exactly In other that can be drawn from previous planning the same planning operations. to benefit from experience it will repeat exactly that achieves Approaches to planning from second principles try to overcome and modifying of generated plans. From a this limitation from scratch by reusing previously planning * E-mail: koehler@informatik.uni-freiburg.de 0004-3702/96/$15.00 Copyright @ 1996 Elsevier Science B.V. All rights reserved SSDlOOO4-3702(95)00113-1 complexity case [44], easier reasonable theory point of view, WC: cannot hope to prove efficiency gains in the worst since the reuse of’ plans comprises that are not computationally subtasks than plan generation. But to reuse existing plans in many practical applications than generating a new one. The current state of the art comprises a variety of approaches it seems to be more that tackle the problems planning, from a cognitive point of view Ccf: 1341 for a summary framework of STRIPS-based In using a deductive cl‘. ( 2 I, 28.54). framework, we present a formal approach from and frame- the retrieval of candidate plans from a librar;i as well as the problem of second principles. which makes no commitments application domains. We formalize work including plan modi$cation. the whole reuse process formalisms logical to particular planning of approaches) or in the in a unique to planning Plan modification is based on deductive modified plans. It comprises planning problem task of re$ttirzg the reused plan plan modification. we discuss plans, in order to determine inference processes that yield provably correct two subtasks: First. the task of matching an old and a new the new requirements. As a new issue in in the reuse and refitting of control structures occurring and differences. Secondly, to accommodate their similarities like case analyses and loops. which introduce qualitatively new problems. library, we propose a hybrid knowledge As for the plan the planning logic with a description languages abstraction, linking as query arc introduced use leads to well-defined oretical and practical properties of interest. to develop efficient and complete [44 1, which are guaranteed problem. logic. In this approach, description to large knowledge bases or case retrieval, and update procedures In particular, description representation formalism logics libraries. Their that possess the- logics enable us for the matching problem that solve a planning approximation algorithms to retrieve all plans from the library Finally, the formal framework allows us to prove important properties ness and completeness provides developed as an integrated part of the PHI planner for the implemented of the underlying the foundation [S]. like the correct- inference procedures. Besides this, the approach plan reuse system MRL, ’ which has been The paper is organized as follows: We begin in Section 2 with a summary of the of second principles a four-phase model as the foundation that are used by MRL. The section also contains a short introduction logical formalisms as well as a short overview of the PHI planner. Section 3 into deductive planning planning. The introduces model supports a temporal view as well as a task specific view of the second principles planning the theoretical basis process. A logical for the system MRL that is described sections. Sections 4 and 6 are in the subsequent to the inference procedures working on the plan library, while in Section 5 the devoted deductive in Section 7 we review related work and propose a systematic categorization of the various principles and design decisions underlying the main properties of MRL in the light of this categorization. second principles planners. We summarize of each phase provides is presented. Finally, to plan modification formalization approach ’ MKL stands for modification and reuse 111 logic J. Koehler/Ariijicial Intelligence 87 (1996) 145-186 147 2. Formal preliminaries Deductive planning is a longstanding variant of artificial origins go back to QA3 formal plan specifications specified condition, cf. [ 37, p. 141. Usually, the form [ 181. To generate plans deductively, are performed, i.e., “to construct one proves the existence of a state in which this requires us to constructively constructive intelligence planning, whose proofs of that will meet a is true”, of the condition prove plan specifications a plan v’s0 ‘Ja 32 Q[so,a,zl where SO denotes planvariable the initial state, a is an argument or input parameter, and z_ is a representing the plan term that has to be constructed [ 371. Two properties of deductive planners are particularly interesting when studying plan- from second principles: First, plans are provably correct. Once provided with a of a particular application domain and the actions which can be to can leads to a sound plan, that solves ning correct axiomatization performed work. Preserving we ensure the planning problem at hand? this property during plan modification a deductive planner generates plans reordering or adding actions is a real challenge-how that are guaranteed in this domain, that removing, Secondly, deductive planning has been closely like if-then-else and while loops. While from its origins. Plans are viewed as programs and consequently, structures generate such complex plans, many deductive planning trol structures in plans. The retrieval and modification and loops is therefore another challenge we are going to address. related to program right synthesis they contain control it is very rare that classical planners systems are able to generate con- of plans containing conditionals A deductive planning system-like complexity this means controlling a search space of enormous For a deductive planner, in such a way that plans can be constructed system to correctly “guess” appropriate with mechanisms The difficulty of this Many sacrifice soundness by ignoring complexity. inference task led to a temporary that decide which any other classical planning search and controlling instantiations the inferences automatically. This of planvariables to certain rules apply abandonment (but not all) classical planners, which have been developed in the underlying system-is faced with is a difficult problem. logic a it involves enabling and to provide logical of deductive formulae. techniques. in the meanwhile, in order to reduce search frame or ramification problems solution that allow for an efficient Recently, deductive planning logics devised, e.g., [ 8,471. On the other hand, new ways of controlling by using planning ative representation automatically giving up completeness also play an important has seen a renaissance. On one hand, various planning to the frame problem have been carefully a deductive planner in deductive the declar- so that plans can be this implies tactics tactics have been developed, is inspired by tactical theorem proving tractability. As we will demonstrate, plan modification. in order to purchase role in implementing [ 11,24,46]. Tactics support [8,53]. The use of tactics constructed when proving the plan specification. of control knowledge the inference In practice, and guide e.g., to use to tllustrate planning The examples we are going are to perform plan generation and plan taken from the PHI planner. PHI has been designed recognition e.g., software systems. It provides a logic-based kernel that can be used to develop intelligent help systems supporting users of PHI is the UNIX mail domain where objects of software. A prototype like messuges and mailboxes are manipulated like read, delete, and save. from second principles language environments, tasks in command application by actions logical The system uses the so-called language formalism. The logic LLP reflects the specific requirements for planning lying planning language environments. ementary like loops and conditionals complex user actions on the level of the logical formalism. For example, statements of the application [ 8 J as the under- of command the basic actions which occur in plans are the el- control structures system to describe language. Furthermore, are available 3.4 defined operators, which allows (LLP) 2.1. The logicul luttguage,ftir pluntting LLP temporal [49] with a tempo& logic with interval-based semantics, which combines LLP is a modal logic for programs tures of c/zo~~~ logic temporal formalisms logics have been proposed as appropriate of programs or plans, e.g., [ 15,401. Plans can be decomposed periods or intervals of, e.g., subplans or actions. The framework terized by properties time. [ 351. Interval-based the behavior to describe smaller into successively intervals provide a convenient can be charac- the initial and final values of variables over intervals of timing details. State transitions for introducing quantitative relating fea- The basis of LLP is a many sorted first-order locul variables, which are the usual logics where 0 (tzexr), 0 (sometimes), following, we shortly review they correspond language with equality. It distinguishes the value of which may vary from state to state and global variables from programming the modal operators In the logical variables. Local variables are borrowed to program variables. LLP provides 0 (always), and the binary modal operator the main properties of LLP as introduced ; (chop). in [ 81. 2. I. I. Syntax and semantics A state (T; is a pair CT; = (CT/, CT:) where g: is a valuation assigning domain elements to local variables, while gf in state CT,. Note that the command only the values of local variables may change from state to state. Function and predicate symbols a nonempty intervals. The length of an interval w is defined as does not vary over time. An interval w is .). W denotes the set of all are rigid, i.e., their finite or infinite interpretation sequence of states to be executed indicates (crorrl Jwl= wy i n, if w is infinite. if 12’ = (uoo-1 U,,,! Observe that 1~1 = 0 iff w = (u-0) is a sittgletotz containing only one state. Intuitively, the number of states this interval contains, the length of an interval does not represent but the number of possible state transitions. The immediate accessibility on intervals defined as the subinterval relationship R with is J. Koehler/Artijicial Intelligence 87 (1996) 145-186 149 WRW’ iff w=((+aq(+~...) and w’=((TI(+~...). The relation R is not serial, length zero has no successor. R* denotes composition is defined as a partial function over the set of intervals W: the transitive i.e., VW Z!w’ w R w’ does not hold since an interval of and reflexive closure of R. The wow’= W, (aa.. i if w is infinite, . rn_~u,,u,,+l.. .), if w = (go.. .cr,,_lc,,) and w’ = (UnVn+, . . J. Global variables are interpreted by mapping them to domain elements using a valua- in an interval w for a particular tion function. The value of a local variable is given by its value modal-free formulae propositional which i.e., w kz ex(t) takes a command constants iff I(t) in the initial state of the interval. The satisfiability is defined as in classical first-order false and true, respectively. The special-purpose term as the argument, denotes = 0;. For the modal operators we define: interpretation relation b for the ex, logic. F and T denote predicate to be executed, the action w & 04 iff w’ +I Q, for all w’ E W with w R w’, w&O+ iff w’kI-+forsomew’EWwithwR*w’, w/=~CI+ iff w’&Q,forallw’EWwithwR*w’, w/=~+;II/ iff therearew’,w”EW w’ finite and w’ & 4 and w” bI @. withw=w’ow”, For example, OF holds in an interval w iff w has length 0, i.e., it is a singleton. More length in w iff w has at most n states, that is iff w has at most generally, n - I. A formula 4 A ,OF A OOF; 0 Cl $ holds in an interval (~0~1~2~3 . . .) if 0°F holds - 4 holds - OCl$ holds in the subinterval in the subinterval (aeat) and ((~1 CT~U~ . . .), i.e., 1+9 holds in all subintervals (g, . . .) with n >, 2. 2.1.2. Plans and plan specijkations in LLP Certain types of formulae in LLP are viewed as plans and plan specifications. Definition 1. Let t be a command formulae. Plans are all formulae of the form: 2 term, E an atomic formula, 5, and I/ consistent plan - ex(t), - +;*, - if e then $ else t+b, - while&do(bod;$. * Currently, PHI uses an extended class of plan formulae comprising abstractions formulae to those plans that are used in the examples. (“sometimes execute an action”). For the purpose of this paper, we restrict nonlinear plans that contain temporal the class of plan The conditional The while operator if F then C$ else 1,4 stands for the formula is defined by the following axiom: 3 [E + 41 A [ 7.s 4 I) 1. while .s do C/J od;$ ++ ifcthenc$;[whilecdo@od;@] else@. The atomic actions available mail system. They are axiomatized Changes of state caused by executing of local variables, which represent For example, mailbox &oxJ the axiomatization reads to the planner are the elementary commands of the UNIX logics. in a change of the values an action are reflected in programming like assignment statements the mailboxes in the domain under consideration. of the delete-command which deletes a message x in a ‘Jr [ open$ag( mbox) = T A delere$ag( msg( x, mbox) ) = F A ex(delete(x, mbox) ) -3 0 deleteJlag( msg( x, mbox) ) = T ) The state of a mailbox requires is represented with the help of jugs. As a precondition, i.e.. its open_j?ag yields that the mailbox mOox is open, tr-uur (T) and that the message x has not yet been deleted, the value false the the delete-command i.e., its delete-flag value yields the action sets the delete-flag of message x in mailbox mbo.u to the value frrde in the next state. In general, PHI uses more general the proof process. The axiom that are instantiated during second-order schemata describe effects as well as frame conditions, which leads to a representational solution of the frame problem, action since only one axiom schemata axiom schemata ’ As an effect. is necessary for each [ 8 1. (F) Definition 2. Plan specitications are universally quantilied LLP formulae of the form Plan A precorzditiotzs ~----t 0 goal. is carried out in the initial state where the preconditions if the Plan i.e., state will be achieved satisfying goal. Plan plan formula i.e.. Plan meets the specification that has to be generated by constructively iff Plan ~pr~~mditiot~~ is true proving ---) Ogoal is a metalogical variable hold then a for the standing the plan specification. Plan specification formulae have to obey various syntactic are described by a modal operator free tirst-order tion, disjunction, and a limited may be described by formulae containing conjunction, and also a limited form of implication form of implication restrictions. Preconditions formula containing negation, conjunc- and universal quantification. Goals like 0 [ q5 A V$], nested sometimes operators, and universal quantification. ’ To complete the recursive defnition of while, an extra semantic condition IS necessary, which amounts to a smallest tixpoint construction as in IS2 I for example. Since in our application the formula r$ is restricted to be a valid plan formula not containing any while structure, the operational view of the while definition is sufficient. A Constants begin with capital letters, whtle variables arc written in lower case. 5 The reader may note the difference between the hooletrn constants T and F, which are assigned as values to local variables and the /~r~~~.ritiontr/ constants T and F, which are formulae as in OOF for example. J. Koehler/Artijkial Intelligence 87 (1996) 145-186 151 Let us consider three specifications and example plans this paper. The first specification the planning problem: a message m in the mailbox mybox”. As preconditions, we assume mybox has already been opened and that the message m has not yet been deleted. $1 specifies that will be used throughout “read and delete that the mailbox open_jGg( mybox) = T A delete$ag( msg( m, mybox) ) = F -+ 0 [read.$ag(msg(m,mybox)) = T A 0 [ delete_.ag(msg( m, mybox) ) = T] 1. SPI specifies temporary goals with the help of nested sometimes operators, that have to be achieved at some point and not necessarily message simple sequence containing to be read first and then deleted. The plan Pl solving type and delete. the actions in the end. It requires this specification i.e., goals the is a Pl ex(type(m,mybox)) ;ex(delete(m,mybox)). In the second specification $2, we have the same goals as specified in $1, but formulated here as a conjunctive goal. $2 Planp2 A delete_jlag( msg( x, mbox) ) = F -+ 0 [read$ag(msg(x,mbox)) = T A defete_Jag(msg(x, mbox)) = T]. that about the state of the mailbox As a precondition we only know the message has not been deleted, but no the is available, the plan P2 must contain a case analysis on the state the message x can be read and deleted. is closed, we have to open it first before the message x can be read and i.e., we do not know whether is open or closed. Thus, information mailbox of the mailbox mbox: If the mailbox If the mailbox deleted. is open, P2 if open@ag( mbox) = T then ex( empty-action) ex( type( x, mbox) ) ; ex( delete( x, mbox) ) . else ex( open( mbox) ) ; The third specification $3 specifies an iterative plan reading all messages from sender and goals contains in the mailbox mbox. The specification of its preconditions Joe universally quantified formulae: $3 Planp3 A open_jlag(mbox) = T A Vx [ sender( msg( x, mbox) ) = Joe -+ delete_.ag( msg( x, mbox) ) = F] ---f 0 Vx [ sender( msg (x, mbox) ) = Joe -+ read$ag( msg( x, mbox) ) = T A delete_$ag( msg( x, mbox) ) = T] . The plan P3, which solves this specification contains a while loop over the length of the mailbox. 2. I..?. The LLP sequent ccr1culu.s All deductive inf‘erences are performed in a sequent calculus, which has been devel- oped for LLF? ’ Sequent calculi possess several advantages making deductive planning more efficient. They support a compositional proof guidance by tactics and allow for a [ 121. The calculus contains different kinds of sequent natural problem decomposition rules: the rules for the standard S4 calculus as for example given in [55], LLP specific rules rules, which to handle instantiate planvariables the modal operators next and chop, and planning for example. specific Definition 3. A sequent I- + d. It is valid iff, in all models M. for some B E 3. is an ordered pair (,I’, 3) of finite sets of formulae, written /= B, if when M k A, for all A E r, then M In order a derivation axioms to prove a formula in a sequent calculus, the theorem prover (tree) of the formula by applying sequent rules, which ends tries to find in a set of (leaves) from which the formula follows. Definition 4. A sequent a bottom sequent, conclusion. rule consists of at least one upper sequent, the conclusion. A sequent rule is correct iff the premise the premise, and the implies LLP specific rules are for example the c*hup_composition rule 41 =+ *I 42 =+ $2 41 ;42 * $1 ;$‘2 chop_cowlpositinrl and the sometimed_to_rlext rule I-=+ &j~~oF,d r*u&d .sot~ietittl~‘.s_to~l~xt. Definition 5. An axiom is a sequent of form 1; A + A, d, i.e., antecedent and succedent contain at least one common formula. ’ A general introduction into sequent cnlculi can be found rn [ l&S5 1 J. Koehler/Artijicial Intelligence 87 (1996) 145-186 153 If a sequent derivation of a formula does not terminate in a formulae set comprising only axioms, the derivation stating the validity of a subformula. the proof of this formula has failed. But then tree which contains only axioms as leaves, is a subtree of then we have a partial proof if there 2.2. Description logics is the identification A main problem during planning from second principles reusable plan. This can be achieved by matching a given plan specification stored in a plan library. As we have logical descriptions. Therefore, we cannot by a appropriate formula against a set of plan specification seen, plan specifications hope partial or best match. The main formalism idea is therefore, LLP to a target formalism, which can be used to represent abstracted plan specifications. As we will show, a partial match exact match to find an efficient matching in the source formalism in the target formalism. two plan specifications can be easily reduced are very complex to shift from the source comparing algorithm formulae of an to an This approach uses concept description logics (also called for the representation terminological of abstract knowledge. Furthermore, logics) as target formalism the ideal we introduce description retrieval problem and efficient solution logics as query languages to plan libraries by formalizing the lead to a novel as a clussijkution task. With that, description logics to the indexing problem in case-based reasoning. 2.2. I. Syntax and semantics and inference logics comprise a whole family of logical languages with different degrees In the for the as a subset of Description of expressivity following, we define a language of restricted representation various well-known [21. It can be considered [ 501, CLASSIC services of different computational complexity.7 is sufficient logics such as ACC expressivity which plan specifications. [9], and KRZS of abstracted description blocks” The basic “building are concepts and roles, which denote subsets of the objects of the application domain 27 and binary relationships over D connecting objects, the whole domain, while J_ (bottom) denotes respectively. The concept T (top) denotes that specify the empty set. Concepts the properties are defined an object must satisfy intensionally to belong in terms of descriptions to the concept. Definition 6. Let C and D be syntactical variables R:! for role names. The following concept descriptions for concept descriptions can be formed: and R, RI, - C n D (conjunction), - C LJ D (disjunction), - -C (negation), - 3R.C (existential - RI o R2 (role composition/role role restriction), chain). 7 For a good introduction into description logics see for example 14 11. Besides the construction with the help of terminological axioms. of complex concepts, new concept descriptions can be defined Definition terminological axiom. 7. Let A be a concept name and D a concept description, then A G D is a Primitive concepts are all concepts which arc not contained on left sides of termino- and can be considered as the in the terminology logical axioms. They remain undefined basic terms on which other concept descriptions can be built. The formal model theoretic semantics of description domain D. for the interpretation objects, while each role denotes a set of object pairs. These sets are called extensions of concepts and roles. the of concept descriptions. Concepts denote a (sub)set of logics uses the set of objects, Definition 8. An interpretation Z consists of a domain V and an extension mapping binary function & each concept name A to a subset &I A ] from ID and each role name R to a relation E[ R] over 2). The terminological the necessary mine relationships relationships between concept descriptions their extensions. between can be used to deter- Definition Y. Let C be the set of concept symbols and R be the set of role symbols. ?I is an arbitrary set and & a function: &= C - 2F. R - 2’pXD E is an extension function iff the following equations hold: E[T] =V, l5L.l =li), f[Cfl D] =&[C] nE(D]. EICu DI =E[C] LJE[r)]. E[-C] =V\E[CI. El 3R.C] = {_r t 23 1 exists y 5 ‘P (.x.y! t E[R] and _Y E E[C]}, &‘I R, o R2] ={x,y E 73 ! cxlsta; t P ,s.\,z) F E[R,] and (z,y) E&[Rz]}. The interpretation of a terminological axiom is the equation E[A] = E[ D]. Definition nonempty 10. A concept extension E[ C 1 # (n. c’ is hatisfiablc (also denoted as consistent) iff it has a J. Koehler/Artijicial Intelligence 87 (1996) 145-186 155 2.2.2. Subsumption and classification The main inference procedure provided in terminological systems is subsumption, which determines whether one concept description is more general than another. Definition 11. Let 7 be a terminology (C Cl D) iff &[ C] C &[ D] holds in all models of 1. and C, D be concepts. D subsumes C in 7’ The computation of all subsumption relationships Since we intend to formalize between a set of concept descrip- retrieval as a classification runs in grounding is called classi$cation. tions task, we are interested in polynomial rithm, which operators in a concept description. Due [ 421, we can either give up completeness, of admissible expressions, ties. Giving up completeness detect existing algorithm: subsumption in order relations may is problematic it on a complete and efficient subsumption time depending to the inherent on the number of concept intractability algo- forming of subsumption to obtain an algorithm with or confine concept descriptions to a subset the desired proper- to because to incorrect behavior of the retrieval inability in this application, lead - Existing solutions may not be found in the library. This can lead to an undesirable overhead computational reuse the best available plan, which may result in needless modification abstracted in second principles planning, because growth of the plan - Uncontrolled effort. specifica- the system does not library may occur. Identical the incomplete subsumption algorithm is tions are added unable Consequently, to recognize to the library, because their equivalence. concept descriptions are restricted to so-called admissible concepts in conjunctive normal form, for which a sound, complete, and polynomial-time algorithm exists. subsumption Definition 12. Let R be a composition primitive components. concept atom. Concept of primitive roles (role chain), and C be a terms of form 3R.C and JR.4 are called primitive Definition 13. A consistent of concept descriptions components. concept description D is admissible di, where each di is restricted to be a disjunction iff D is a conjunction of primitive steps unnecessary. the language of subsumption Restricting and normalization the relevant part of a terminology the computation their definition concepts, because restricted logic. Primitive subsumption. subsumption components The following algorithm to be primitive. using terminological to admissible concept descriptions makes the usual expansion In the general case of more expressive descriptions, form before has to be transformed can start. Defined concepts have to be expanded by into a normal axioms. This step is not necessary for admissible they are already given In fact, admissible in a normal form, and all concept concepts define a subset of propositional terms are can be treated as atomic units during from rule set taken of [ 171 defines a sound and complete the computation for admissible concepts that runs in polynomial time. 3. A four-phase model of second principles planning Reasoning from second principles proceeds in a basic cycle of problem inpt- these three phases, we activation of previous consider a fourth and final phase in the cycle, which updates the memory of the second principles planner. solutions-adaptation. cf. (481. Besides 1. Phi determinatiorl The current plan specification is the input to the plan-determination specification, description, which represents the retrieval process starts by mapping the LLP formula the search key to the plan library. phase. Taking this into a concept The plan library contains a collection ofplan errfries that are extracted from previously and problem its solution, problems. A plan entry provides comprehensive solved planning planning initial and goal states, the plan which was generated as a solution that is extracted which is represented by the position of its index information of the problem describing for it, and information from the plan generation process. Each plan entry possesses an index, as a concept description. The position of a plan entry is determined in the subsumption the specification hierarchy. e.g., about a Retrieval classifies the current search key in the subsumption returns a set of reuse candidates. Ranking heuristics are applied the best candidate. hierarchy of indices, and in order to determine attempts to prove is sufficient the reused plan specification of the reused plan specification that the current plan specification formula S,,, formula Sold. If the attempt for the current one, which means the old planning problem will solve the current planning problem. This means If the is constructed. A plan skeleton provides an entry point into to the current for subplans achieving open to achieve. The plan skeleton keeps any II. Plan interpretation Plan interpretation is a logical consequence succeeds, solving that the reused plan solves Snew directly, and no modification attempt fails, a plan skeleton the search space of possible plans. planning problem, because subgoals, which actions of the reused plan and in which variables are appropriately the current plan specification. It represents it may contain “placeholders” instantiated with object parameters as reusable during plan that were determined of it is necessary. the reused plan an incomplete interpretation, taken from is unable solution J. Koehler/Artijicial Intelligence 87 (1996) 145-186 157 PLAN GENERATOR plan specification plan t current Dlan soscification )’ 1 ‘: PLAN LIBRARY I ,,“I ~LGG~ERPRETATION I“1 reused $an sb&ification I woof attemm plan skeieton Fig. 1. Architecture of the MRL system. III. Plan refitting The third phase completes the plan skeleton interleaved planner, plan refitting from control structures the plan skeleton process of plan verification and generative planning. Similar to work on and successively to a correct plan with the help of an to a generative reuses subplans this process, actions and the final plan. During selects a subgoal to construct in the plan skeleton may be deleted, added or reordered. IK Plan-library update Planning from second principles terminates with a plan-library update, during which the current plan spec- from three sources of information: a new plan entry is constructed ification, that is extracted The plan entry library. The modified plan is now available is related the plan which was generated by modifying from the proof tree which was constructed an existing plan, and information as a result of plan refitting. to the current search key, which serves as its index in the plan to subsequent planning processes. The four-phase model describes I-III are necessary guished by other authors who sometimes denote a temporal view on the reuse process. The phases to generate a plan by reusing an existing one. They are also distin- them as retrieval, matching, adaptation phases, cf. [ 221. The fourth phase comprises formalization the plan refitting tttodijicatiorr. groups library provide (phases those phases the basis the maintenance together, which perform similar for phases I and IV, while plan of the plan library. The tasks. Operations on and as plan interpretation II and III) work on plan specifications and are summarized Fig, I shows the architecture of the MRL system. The system comprises four modules, each of which implements a phase of second principles planning. 3.1. Fi,rtttmlizittg phi tttodijcfttiott The input to plan modification is the current plan specification formula S,,, of form Plan,,,, A pw,,cw - 0 <q’tul,,,u and the plan specification formula Sold from the reuse candidate of form stands for the plan (formula) we want to determine by reusing The planvariable Plan,,, the existing plan of the plan- variable Plan,ld. Plan modification has now to answer the question of whether POld meets s ne\lS, i.e.. if (formula) P&J that is available as a correct instantiation P,I,I A prenrw --t 0 ROE,,, is true. In this case. P&j can be reused meet new requirements. sufficient conditions Instead of directly proving between both plan specifications immediately, otherwise to the validity of this formula, we show it has to be refitted according to Theorem 14. This means, if the new plan specification theory Ax, solving for solving S,,. As contains one under the given domain is sufficient the domain constraints. ’ Since plan specifications show Ax /= Sold p-t S,,, by proving sufficient according to Theorem 15: formula is a logical consequence of the old the old planning problem with plan POld the set of action axiom schemata as well as contain formal descriptions of initial and goal states. we can and goals relations between preconditions Theorem 15. Ax b SOId - S,,,,v (f This means, we have to prove satisfied in the current initial state and that the preconditions required by the old plan are that the goals achieved by the old plan are ’ An example of it domain con&ant in fhc mail domain is the formula Vx 1 c~~“l_~u~(“z”~lho.r) = F - delete...ug( mg( x, ndbr~x) ) = F 1, i.c.. no closed mailbox can contain deleted messages. J. Koehler/Artifkial Intelligence 87 (1996) 145-186 159 sufficient state specifications hold, we know that for the currently required goals. If these relationships between initial and goal - Potd 1s applicable m pre,, - P&j achieves at least all of the goals required The validity of both theorems and in gOa&. can easily be demonstrated by a sequent proof of Ax + Sold --t &ew . We start with the initial sequent Ax, Pold A p%ld -+ 0 @a&Id =+ Pold A P’-enew * 0 W&w instantiated with the reused plan formula. Ap- rules for the logical connectives A and ---f to both sides of the sequent are already in which both planvariables plying sequent leads to the following (la) Ax, Pold,p%ew ( lb) Ax, Pold,P%ew =+ w%d9 0 go4,, ( lc) Ax, Pold$~~new~ three proof tasks’ * Potd, Ogd,, 0 gO&ld =$ 0 @‘&w Sequent (la) as a common required in Theorem Ax,prenew =+ goa&, where therefore, the goal is a logical axiom since antecedent ( lc) formula. Sequents ( lb) and and succedent contain lead to the two subproof ( 1 b) and ( lc) would also be valid the plan P&j tasks as if 15. Of course, sequents can be proved, is already satisfied i.e., if the current plan specification in the initial is a tautology state. But this will seldom hold and there is not much sense in trying to prove this. The reader may now wonder why it makes more sense to prove relations between the validity of P&j A prenew ---f in particular, we in many cases have and goals are possible in principle. We decided instead of directly proving are easier. For preconditions preconditions 0 goalnew. Both approaches the subproofs formulae of a rather simple involving perform a first-order proof This allows us to use complete proof tactics that run in polynomial length of the formulae. Directly proving to split the plan formula go&V4 can be shown prenew. This requires formulae frame axioms. to follow from a (sub)plan the application and goals, which often requires additional of correct sequent into subformulae complicated the instantiated plan specification in such a way, that each of the subgoals of P old and the current preconditions rules for the splitting of plan proof tasks involving for the former since to structure. to the formula means from syntactic time relative The reader may note that an analogue for syntactically different plan specifications, where plans are represented as terms as is usual in deductive planning. in the goal state specifications. and plan terms occur as additional arguments to Theorem 15 can be obtained In this case, planvariables 3.2. Formulizing library retrieval and update In principle, in the same way as plan modification. A plan solving can be determined and achieves the inference procedures working on the plan library can be formalized problem initial state between the current planning in the current all of the current goals, by finding a candidate that is applicable i.e., by proving conditions sufficient ‘The sequent proof can be found in detail in Appendix A. 160 J. Koehler/Art@icial Intelligence 87 (1996) 145-186 and goals. But apart from the complexity problems we would encounter, preconditions this is too restrictive because such a search process can only retrieve solutions. A failed proof would not tell us which of the plans is the best candidate for plan modification. Research in case-based reasoning proposes to solve this problem by computing lo Partial matches are computed between .that designate under what conditions [ 34, p. 201. A pre-indexing technique so- the indices of a case, each of the cases can be used identifies a privileged in the case library. Usually, to in order to make the retrieval and matching problem indices are restricted called partial matches. which are “labels to make useful set of features be vectors of propositional tractable. inferences” to organize cases atoms ’ ’ There are several disadvantages al. [ I] have observed, the representation and flattens indexing schemes restrict the case library as a discrimination inference relation the retrieval algorithm is impossible to prove. of pre-indexing and partial matching. As Anderson et in retrieval indexing based on a fixed vocabulary hinders flexibility this, these feature vectors. Besides to have a tree-like structure usually represented of cases into simple network [ 131. Finally, partial matches require a “relaxation” on the for which clear semantics can rarely be given and thus soundness of involve relational To overcome in description to the indexing can be interpreted can easily be investigated as the basic inference procedure algorithm. Soundness guarantees the search criterion. Completeness the matching of these graph structures when formulae, which may in [9], such concept descriptions limitations, we developed a novel solution logics. As a main advantage, description language beyond sets of atoms. Simple logics offer a feature vectors and functional de- as labeled, logics indices have to be compared. formal that the retrieved candi- that all matching candidates are algorithm decides whether an ef- is available. As a further advantage, case libraries are indexed instead of a these serious problem based on description mom expressive representation can be replaced by logical scriptions. As shown directed multigraphs. Subsumption formalizes The formal properties of the “matcher” properties of the subsumption date meets ensures in the retrieval set. The complexity of the subsumption ficient retrieval algorithm on a more general tree structure problem can be resolved, because no set of features has to Finally, from the logical be identified formulae) with the help of an encoding representation scheme w. The encoding to concept descriptions. The formal basis for w is the model theoretic semantics of both logics. In into a first-order a first step, an LLP plan specification is then formula the method described formula using first-order replaced by an abstracted formuia is equivalently in [33]. The resulting formula. lattice structure provided by the subsumption is defined as a mapping from LLP formulae the pre-indexing in advance. of cases (here plan specification the indexing vocabulary translated first-order is computed by proving hierarchy Instead, scheme [ 291. Definition 16. Given abstraction of 4 iff two first-order formulae C#J and abs( 4)) the formula abs( 4) is an ‘” See [ 34 1 for a summary of the state of the art m case-based reasoning. ” See [44 1 for a complexity theoretic analysis of the matching problem. J. Koehler/Artijicial Intelligence 87 (1996) 145-186 161 holds in all models M. For example, the proposition A is an abstraction of A A B. The result of abstraction is a formula in a sublanguage of first-order logic which can be translated into a concept description by preserving equivalence again. Here, we exploit the fact that description logics can be seen as sublanguages of first-order logic [ lo]. A very desirable property of encoding schemes is the so-called monotonicity property: Definition 17. Given two plan specification formulae Sold, S,, and their respective encoding concepts w( Sold), w( S,,,), an encoding scheme w satisfies the monotonicity property iff This means, if a plan specification S new is a logical consequence of a plan specification &Id in a domain axiomatization Ax, then o (S,,) must subsume o (&Id). In other words, the encoding scheme preserves an existing subset relationship between the set of models of the plan specification formulae as a subset relationship between the extensions of the concept descriptions. The monotonicity property ensures that existing solutions are found in the plan library, when a complete subsumption algorithm is used. The abstraction of formulae as part of the encoding guarantees that an exact match as computed by the subsumption algorithm corresponds to a partial match between the original formulae. To compute an abstraction, we define a set of abstraction rules of form C$ -+ abs( (b), which replace a formula q5 by a weaker formula ubs( 4). Examples of abstraction rules are A A B -+ A or Vx p (x) --+ 3x p (x) . An analysis of the abstraction rules allows us to draw conclusions about the degree of partial matches. Furthermore, when using different sets of abstraction rules, different degrees of partial matches can be performed by a retrieval algorithm. Finally, an encoding scheme provides a formalization of reasoning by approximation. The retrieval algorithm approximates the relationship of logical consequence between plan specifications when computing subsumption between their encoding concept de- scriptions. Fig. 2 summarizes the formal framework. It bases planning from second principles on deductive inference processes. Plan modification is formalized by proving sufficient conditions between preconditions and goals in the underlying planning logic. A formal- ization of the inference procedures working on the plan library is obtained by computing their approximation in a description logic. The idea of exploiting relationships between preconditions and goals can be found in other approaches as well. Hanks and Weld [ 2 1 ] write that “retrieval takes the problem’s initial and goal conditions and finds in the plan library a plan that has worked under circumstances similar to those posed by the current problem”. The basic approach described by Hammond [ 191 is “to find a past plan in memory that satisfies as many of the most important goals as possible”. Plan modification as formalized by Kambhampati 162 J. Koelder/Art(ficiul l~rtelli~ence 87 (1996) 145-186 ---______? I and Hendler spec$catintzs”. Fig_ 2. The logx;~l frarwwork liar planning from second principles. [2X] relies on marking “the dijfkrences between the initial and goal state I In the remaining a theoretical foundation in the second principles since theoretical properties procedures are provable. part of the paper we show how this formal of well-defined for the implementation planner MRL. We obtain a system of predictable framework inference procedures behavior, and efficiency of the inference like soundness, completeness, serves as 4. Efficient retrieval of candidate plans In order to illustrate the use of description logics as indexing and query languages us return the plan P2 solving Sp2 to the example plans, which have been introduced in Section 2. Assume let that P2 if open$ag( mbox) = 7‘ then e.u( empty-action) else ex( mail( mbux) ) ; / ex(type(x, mbox) ) : ex(delete(x. mbox)) / has to be generated stored in the plan library. from second principles. i.e.. by reusing the plans Pl or P3 that are PI /ex(type(m,mybox)) :ex(deiete(m,myboxI) 1 P3 n:=l; while II < lengthf mbox) do if sender(msg(n, mbux) ) = Joe then PA-( type( n, mbox) ) : ex( delete( n, inbox)) else ex( emptyaction) ; II :=n+ I od Plan determination candidates to guide the planning process for P2 and which of the two candidates the question of whether Pl or P3 are appropriate should has to answer J. Koehler/Arfificial Intelligence 87 (1996) 145-186 163 reveals look at the plans be preferred. A closer common, cf. the framed formula. Apart from this, the plans differ mainly structures even for human experts. Pl and add a case analysis or take plan P3 and remove the loop in order towards P2. in subplan in the control is a difficult problem It is by no means obvious whether we should either take plan to work they contain. The comparison of such complex structures that they have a sequential The identification of Pl and P3 as appropriate reusable plans requires abstraction from: - specific objects occurring subgoal states, - temporary - universally quantified goals. The basic effects of actions which cause a mailbox’s in the specifications, features the abstraction process. These requirements preserved during by defining specifications a particular to concepts encoding scheme w, which is used in MRL to map LLP plan in a description logic. to be changed have to be have to be accomplished 4.1. An example encoding scheme The definition of a particular encoding - - - the representation the choice of a particular description the application formalism domain. In order to map LLP plan specifications scheme depends on three factors: for plan specifications logic, and plans, abstraction to perform: Abstraction rules corresponding to the three different from universal goals is accomplished forms of abstraction by the rule to concept descriptions we use three types of that we want Vxp(x) + 3xp(x). Abstraction from specific objects is implemented by the rule p(A) -+ 3~ P(x). For example, applying 3ssender(msg(x,mbox)) straction impression this rule to sender(msg(x, mbox)) = Joe leads from the specific sender of a mail. Ab- from temporal information is slightly more complicated. To give the reader an to a formula = s which abstracts of the temporal abstraction process we consider the formula 0 [ read&zg( msg( m, mybox) ) = T A 0 [ delete$ag( msg( m, mybox) ) = T] 1. The goal of temporal abstraction is to abstract from the ordering of subgoal states. In the nested sometimes operators specify such an ordering. A simple the example rule, which accomplishes formula, the desired abstraction is Such a modal formula can be equivalently the relational translation method by Ohlbach translated into a first-order [45]. The translation formula following adds an additional representing the accessibility predicate Local variables, which are the only fluents that are equipped with an interval argument u’; [ 331. Another abstraction to eliminate would obtain into in LLP, are translated (WI, ~2 are interval variables) introduced by the translation. the additional predicates relation on intervals language. the object into unary functions rule is applied In the example, we read$ag( msg( m, mybos( 11’1 1 J ) = 7’ 1; clelete_&zg ( rlzsg ( 111, f?lJ?XH( W’, ) ) ) = T. The result of the abstraction process is a first-order and disjunction. Each literal is then mapped conjunction, i.e., an existential mapped to fl and U, respectively. role restriction of the form 3R.C or 3R.4’, while A and V are formula containing to a primitive negation, component, is of type The structure of a term like read_.ug(msg( m, m~box( WI ) ) ) is reflected function mybox interval x mailbox. The binary it takes a mailbox i.e., that can he found in the com- is position of roles. The unary function msg is of type abstracted by a binary relation and an integer as arguments irlteger 4 message, mailbox x indicated and returns by the integer. Thus, relations mailbox x integer0 integer x message. The unary function read-Bag is of type message + boolean, for the formula reud_$ug(nzsg(m, mybox( ~‘1) ) ) = T we obtain it by a binary relation of type messagex boolean. Consequently, the concept description at the position of binary is abstracted by the composition interval + mailbox and i.e., we abstract in the mailbox the message this function 3 mailbox o position o message o read_flag.TRUE. After the encoding process has been completed, the conjunctive is computed. Of course, is only complete concept description grows exponentially with the formula gorithm for concepts reasons pragmatic encoding process index. In many cases, tasks involve only sets of atomic subgoals. it is less costly instead of computing the computational length. But remember in conjunctive normal to compute the normal it several times during normal form of the effort for this operation al- for the of an that the subsumption form. Nevertheless, form only once during the classification the normalization will not be necessary because many planning The encoding fications Sp, to $1. scheme w used in MRL leads to the following encodings of the speci- 0~ (pwh 1 3 mailbox o open_flag.TRUE 11 7 mailbox o position o message o deiete_flag.FALSE w( goc&, ) 3 mailbox o position o message o read_flag.TRUE fl 3 mailbox 0 position o message o delete_flag.TRUE w (veh ) 3 mailbox o position o message o delete_flag.FALSE ~(goal~,~) 3 mailbox 0 position o message o read_flag.TRUEfl 3 mailbox o position o message o delete_flag.TRUE J. Koehler/Art@ial Intelligence 87 (1996) 145-1U6 165 oQv-esP2) 3 mailbox o open_flag.TRUEfl [ 3 mailbox o position o message o sender.lSENDER~ 3 mailbox o position o message o delete_flag.FALSE ] w(goals,,) [ 3 mailbox o position o message o sender.-&ENDER u 3 mailbox o position o message o delete_flag.TRUE ] n [ 3 mailbox o position o message o sender.TSENDERu 3 mailbox o position o message o read_flag.TRUE ] The expressiveness of admissible concepts is sufficient to represent for which different adequately. The reader may note that this property may not generalize schemes must be defined. encoding domains can require intractable. abstractions to use more expressive concept In this situation, we have either to give up completeness, leading languages formulae The general to simplified idea of using description logics as query languages the mail domain to other application In some cases, this becomes further or perform to be widely applicable. Given a logical description of a case, i.e., a logical it is possible to map a concept description. Nevertheless, logical interesting to concept descriptions for further research. logical the development is a creative process. it to some weaker of encoding formulae subject formula, which can be interpreted schemes mapping is an Its mechanization to case libraries seems formula, as remaining within a tractable sublanguage. for which subsumption The encoding scheme used in MRL satisfies the retrieval 17. Thus, algorithm that the inverse of the monotonicity property as formulated the monotonicity is guaranteed solu- to find existing property does not hold in general. A to the new by approximation. The retrieval algorithm their the plan specifications when comparing the library will not, with certainty, provide a solution reflects reasoning the relationship between it extends the computed set of candidates. by Definition tions. Note plan retrieved planning approximates abstractions. Thereby, from problem. This 4.2. Weakening retrieval The retrieval algorithm takes the encoding of preconditions plan specification testing in order to determine its position in the subsumption and goals of the current hierarchy. By a set of subsumed plan specifications fications are possible specification only subsumes the plan library. In this situation, a second principles planner of either: is determined. The plans which meet these speci- i.e., if the encoded current If no plan is returned, in is faced with the decision the bottom concept, no directly reusable plan is contained reuse candidates. - - to give up further reuse attempts and plan from scratch, or to weaken criterion modified. the retrieval and accept that any reuse candidate has to be 166 J. Koelder/Arrific~iu/ Inrclli~ence 87 (I 996) /45-I86 BOTTOM Fig. 3 The example library. the modification The principal problem is to anticipate principles makes sense when the effort for retrieval and modification effort for planning from scratch. Unfortunately, we start retrieval. However, practical experiments is often less costly searching for plans efficiency considerations. than generating one from scratch that have to be modified from second is lower than the this before a plan retrieval and is therefore a practical decision even under it is impossible demonstrated to decide that modifying [ 22,301. Weakening effort. Planning Retrieval based on classification offers criterion, which are to classify according two principle ways to goals or preconditions to weaken only: the search w(P”new) & W(Pr&ld) or ~JQP&I) L: ~(~4,~). the first case, retrieval searches In that its preconditions may not be satisfied retrieval searches achieve all of the currently for a plan which required goals. ” is applicable for a plan achieving in the current in the current the current goals by accepting initial state. In the latter case, initial state, but will not Fig. 3 shows the small example library obtained for the three plan specifications under consideration. Obviously, w(.Spz) subsumes only the bottom concept, rectly reusable plan can be retrieved. Therefore, a weaker retrieval algorithm searching for an w(pre,ld,) sumed by o(g~als,,~). Classification candidate as well, while classification since w( go&, i.e., no di- is activated that subsumes ~~(pre~,,~) or for an w(goa&[d, ) that is sub- a for w(goals,,, ) to w(Spl ) is of the encoded preconditions of the encoded goals is successful the plan Pl attached ) holds. Therefore, fails in retrieving ) & w( goa& system retrieval it seems I2 In a working to weak demonstrate i.e., it requires plans to be applicable control structures during plan modification to improve in order to be a good restriction to implement only one of the possible approaches retrieval efficiency. Here, we discuss both possibilities in order to how retrieval based on classification works. MRL applies weak retrieval only to preconditions, in the current initial state as a heuristic to reduce the refitting effort for J. Koehler/Artificial Intelligence 87 (1996) 145-186 167 activated as a reuse candidate. Since strong represent to the current planning of the current goals, but we know that its preconditions initial state. Thus, plan refitting has to start as will be described retrieval problem Sp2. We expect failed, we know a solution are not satisfied in Section 5. that Pl cannot it to achieve all in the current 4.3. Ranking of plans Only one candidate plan has been retrieved from the plan under consideration. candidates. Consequently, the best one. But in general, retrieval will determine a ranking is needed for the candidates library several appropriate in the example reuse in order to determine The subsumption hierarchy, which to rank candidates by computing best candidate have a shortest path, ranking heuristics modification effort, respectively. the shortest path has their distance is a directed acyclic graph, provides an easy way to the current concept description. The If several candidates and the optimization in the graph. are used to approximate to w( S,,,) from to be applicable the ranking of candidates these goals can be eliminated in the initial state and Strong retrieval returns plans that are supposed to achieve at least all of the current goals. This implies that the candidate set may contain plans which achieve superfluous goals, i.e., goals that are currently unnecessary. Actions attempts achieving of the it. Thus, at optimizing optimization effort for each candidate, that have the number of atomic to be eliminated subgoals in the current reflects the minimal number of primitive plan specification. the plan with the actions smallest number If several candidates is selected as the best reuse candidate and sent to plan modification. the same ranking value, one of them is selected arbitrarily. from the candidate plan. The heuristic estimates that are achieved by a candidate plan but that are not required from the candidate plan. Therefore, i.e., the number of superfluous the reused plan by making is based on an estimation that have to be eliminated that this number It assumes receive actions the for u( S,,,) . The heuristic compares Definition 18. Let u (&Id, ) , . . . , a( &ld,,) be strong retrieval dates o (goa&, The set of primitive cardinality of the set P[C] components that occur is as usually denoted by (P[ C] (. ) , . . . , w(goals,,,,,) with the encoding of the current goal w(goafs,,). in a concept C is denoted by P[ C] The retrieved by indices of candidates the encoding of goals of the candi- The optimization effort for each candidate is defined as OPTw(goalsold, ) = IP[~(goa&, ) 1 \ P lw(go&,,) 1 I The ranking heuristic selects a plan needing minimal optimization effort. Weak retrieval returns candidate plans that are either supposed the desired goals, the initial state or to achieve didate has to be modified. Consequently, each candidate in the retrieval set by computing ) , . . . , w(goafs,,, ), which approximates w (go&,,, goals that are achieved by each candidate, cf. [ 291. the heuristic i.e., we have to expect to be applicable in that every can- estimates to modify the effort the intersection of w(goals_) with the number of current atomic sub- 168 J. Koehler/Ar~iJicrul ltttellipxce R7 (1996) 145-186 strong retrieval search for applicable plan reaching all current goals fails activates plan modification T below lower bound V 1 fails ) Activation of Plan Generator 1 Fig. 4. Interaction between tirst and second principles planning. Furthermore, the ranking heuristic verifies whether the ranking value of the best candidate exceeds a lower bound: in w(go~ls,~~ ) must be contained heuristic subgoals. candidates In this situation, plan determination PHI planner assumes If no candidate are rejected because is activated. that the best candidate a&eves receives a ranking value which exceeds it requires in w(goa&,,, ). If this condition that at least half of the primitive components the ranking is satisfied, at least half of the current atomic the lower bound, all effort is estimated as too expensive. their modification reports a failure and planning from scratch with the The ranking heuristics guide see Fig. 4. principles, the Interaction between planning from first and second 5. Correct modification of complex plans that are provably correct. As introduced is based on deductive lead to modified in two phases. computes a plan skeleton and secondly, plan rejitting completes inference processes which in Section 3, it proceeds Plan modification plans First, plarz interpretation the plan skeleton to a correct plan that meets the current specification. In the following, we apply the formal approach to plan modification as defined in Section 3 to the example under consideration in MRL. and discuss deductive plan modification 5. I. Plari interpretation Plan interpretation (i) The current plan specification receives two sources of input: for which a plan has to be generated. J. Koehler/Artijicial Intelligence 87 (1996) 145-186 169 (ii) The best reusable plan, which the determination phase could identify in the plan library, together with its specification. It takes the two plan specifications and tries to prove the required relations between preconditions and goals: Ax b prenew --t weold and Ax k Ogoal,,ld -+ Ogoal,,. In this example, proving the applicability of the reused plan Pl in the current initial state as specified in SE requires the proof of sequent ( 1): deletesflag( msg (x, mbox) > = F =+- open_$ag(mybox) = T A delete$ag(msg(m, mybox)) = E Starting point for the goal proof is sequent (2): 0 [reud$ag(msg(m,mybox)) = T A 0 [ deZete$ug( msg( m, mybox) ) = T] I =+ 0 [read_.ag(msg(x,mbox)) =T A delete$ug( msg( x, mbox) ) = T] . (1) (2) In the following, we discuss both sequent proofs as they are performed by the proof tactics used during plan interpretation [ 311. The tactics run in polynomial time on the length of the input formula. On one hand, this enables plan interpretation to eficiently compute an entry point into the search space of plans. On the other hand, this implies that the tactic is incomplete in the sense that it cannot compute a maximal plan skeleton which has been shown to be a PSPACE-hard problem [ 441. The precondition proof for the example sequent is very simple because of the sim- ple syntactic structure of the formulae. The first rule that is successfully applied to sequent ( 1) is rule rA. I3 The rule splits sequent ( 1) into sequents (3) and (4) : deleteflag(msg(x,mbox)) = F + open._jIag(mybox) = T, delete$ag(msg(x,mbox)) = F + delete__ag(msg(m,mybox)) = E (3) (4) While sequent (3) cannot be reduced to an axiom, sequent (4) can be closed, i.e., it In order to obtain an leads to an axiom under the substitution {x/m,mbox/mybox}. appropriate instantiation of the reused plan, variables in the reused specification &td are substituted by terms which occur in the current specification &,. Furthermore, different variables must be mapped to different terms, i.e., the substitutions must be injective. Injectivity may not always be required, but it is a safe condition ensuring that a proper instantiation of the reuse candidate is computed during the proof. The reader I3 A survey of all sequent rules that are used in this paper can be found in Appendix B. I70 J. Koelder/Art@cid fturlli~rrrce X7 (1996) /45-/X6 may note that an instantiation possible when quantifier universally quantified, the universal quantifiers using the rules ” of variables rules arc applied. Plan specification i.e.. when proving Soid + S,,, in sequents during a sequent proof is only are implicitly in the sequent calculus we remove formulae to “guess” prover due implemented the appropriate instantiation. Of course, and have an instantiation will lead to a proof of the sequent. The restrictions we pose on the instantiations leaf sequents ensure those instantiations with the help of quantifier is delayed until we know which instantiation is unacceptable overhead. Therefore, in the i.e., which one of the that can be introduced to the resulting is appropriate, are computed computational that only rules. this Sequents (3) and (4) arc the lcaves of’ the derivation are applicable. Since only one of the leaves is an axiom, proof of the reused plan’s preconditions. tree, because no further rules the tactic did not find a valid When trying has sequent to cope with rules: to prove that the reused plan achieves all of the current goals the prover the following therefore additionally ,sonzetinzes operators uses and /‘* “2’ {CIB ! LIB t /‘} and _I* 2’ { OB i OB E A). recursively over the sometimes The proof proceeds in order to compare every temporary temporary followed by rule r 0 and obtains sequent subgoal states from goal,,,. (5): operators subgoal state specified First. the tactic applies in both goal specifications in go&d with each of the (2) to sequent rule IO reud_ffug ( msg i 111. nzybar ) ) = 7’ 1.5 0 [ delete_$ug ( msg ( 02, nybox ) ) = 7’ I =$ raud_fug( mg( .a.!, nlOox ) ) = T A dekre&g( msg( .x, nzboxj ) = T. (5) Now. rule /A is applied and (7): to sequent (5 ) followed by rule t-A, which leads to sequents (6) rrud_&zg ( tnsg ( m, mybox) ) = T, 0 [delete-&g (msg ( tn. mybox) ) = T ] =+ reud_$ug(msg( x, nzbox) ) = T, (6) I4 Eigenvanable condition: (I must not occur in the concluaiun of r’d. J. Koehler/Artijicial Intelligence 87 (I 996) 145-186 171 read_$ag( msg ( m, mybox) > = T, 0 [ delete_$ag( msg( m, mybox) ) = T] + delete#lag(msg( x, mbox) ) = T. (7) (6) can also be closed under i.e., the Sequent current subgoal read_Jag( msg( x, mbox) > = T has been successfully proved. The system proceeds on sequent 0 operator with the help of rule IO which (7) and removes (8): {x/m,mbox/mybox}, leads to sequent the substitution the remaining deLete$ag( msg( m, mybox) ) = T + 0. (8) (8) because subgoal. The reason for this failure the remaining requires the reused goal specification (7) disap- The formula deleteflag( msg (x, mbox) > = T from the succedent of sequent the it does not occur in the scope of a 0 operator. Thus, pears in sequent the is obvious: tactic fails in proving in the same state, current goal specification to be achieved one while after the other. Of course, deleting a message preserves the effect that the message has been read, i.e., the reused plan that first reads the message and then deletes it also leads the message has been read and deleted. But we have no way to to a final state where derive for a completion formula. This is a motivation in Section 6. this fact from the original plan specification the two subgoals only requires process of plan specification the two subgoals that is described to be achieved formulae 5.2. Plan refitting Proof tactics are always designed as decision procedures: that no for some of the leaves has been obtained. proof is possible and that a falsifying valuation Two situations are possible after the termination of a proof tactic in the sequent calculus: If a tactic does not result they are considered tree, it is assumed to terminate. In addition, in a proof (i) A proof tree has been constructed, i.e., the leaves of the tree describe a set of logical axioms formula was proved from which the original to be valid. formula follows. In this case the original This assumption is a safe condition ensuring of plan modification. (ii) No proof tree has been possible and that a counter-example found and that the tactics are incomplete, Remember might either be the case that the formula to find a proof. tactic failed that the formula Assuming during plan refitting. Thereby, with respect The proof to the current plan specification. tactics guarantee is invalid ensures it prevents atomic formulae. The falsifying valuation makes: - All old atomic goals (in the example the assumption is made tree has been constructed. the soundness that no proof is i.e., when a tactic terminates with a failure is invalid or that the formula it is valid, but the that the correctness of a plan is verified the reuse of plans that are not provably correct formulae which describe as false. These achieved by the reused plan (in the example by Pl). (in falsified goals are interpreted current goals from $1 ) true, however some of the atomic from Sm) are valued that are not the example as those current goals that the leaves of a counter-example tree contain only 17’ J. Koehler/Arr~jic~ul lnrellipwc~e 87 (I 996) 145-186 _ All atomic formulae describing true, but some of the old preconditions falsified preconditions the example of Pl) that do not hold in the current (in the example are interpreted as those preconditions currenf preconditions (in initial state. the example from $1) from &2) false. These of the reused plan (in Plan Pl must be modified by constructing neither possible the currently {x/m, mbox/mybox} to prove that its preconditions required goals. First, the reused plan computed during plan interpretation leading to a plan skeleton from it, because it was are satisfied nor that it achieves all of is instantiated with the substitutions Pl’ a( type( n, mbox) ) ; a( delere( .r. mbox) ) refitting concludes Plan open_@g(mbux) current goal delete_~ug(msg(x,mbox) achieved a subgoal from that = T required by Pl does not hold the failed proofs the (instantiated) in the initial 1 = T is not achieved by precondition state and that the it. Furthermore, Pl delete.$ag( msg ( m, mybox) ) = 7 that is not contained structed ex(delete(m, mybox)) superfluous it occurs) during in the axiom that was obtained the goal proof. Thus, plan from sequent (6), which was con- the action is (at least at the current position where concludes refitting that achieving and can be removed this subgoal from the plan skeleton. This analysis of the result of plan interpretation leads to the following modification operations that have to be performed on the instantiated plan Pl’: (i) A planvariable Plant has to be introduced in front of the reused plan. It repre- sents a subplan achieving the missing precondition open-$ug( mbox) = T (ii) The superJIuous action ex(delete( x, mbox) ) is removed (iii) A planvariable the subplan representing for the open subgoal from the plan skeleton. delete$ag( msg (x. mbox) ) = T must be introduced in the skeleton where this planvariable specification must be analyzed with the help of the PHI planner. In order has to be added, the plan skeleton. to determine into the position the current goal state The planvariable in the current plan specification Spz is instantiated with the prelimi- nary plan skeleton Pl”. It serves as a starting point for plan refitting: Pl” Plan, ; ex( type( x. mbox) 1. SP2’ Plan! ;ex(type(x,mbox)) ~delete&zg(msg(x,mbox)) = F --i OLreadJlag(nzsg(x,nlbox)) =TA delete-jag ( msg ( x , mbox) ) = T] In a first step, a subplan to replace Plan, has to be generated. Plan refitting applies the rule effect-intro [7] to $2, and introduces the missing precondition open_.ag( msg( mbox) ) = T J. Koehler/Artijicial Intelligence 87 (1996) 145-186 173 as the new subgoal goalnew: p-e, Planl =+ 0 tgoaL A OF Apre’] pre’, Plan:! * Ogd effect_inrro pre, Plan, ; Plan2 * OgoaE two subplan specifications It obtains action ex( type(x, mbox) ) taken from instantiated computed. after a plan for Plan, has been generated and frame conditions (9) and (10) where Plan:! is instantiated with the the plan skeleton. The precondition pre’ can be have been deleteflag(msg(x,mbox)) = F,Planl 3 0 [openJlag(msg(mbox) ) = T A OF A pre’] pre’,ex(type(x,mbox)) + 0 [read_.ag(msg(x,mbox)) =TA delete$ag( msg( x, mbox) ) = T] . (9) (101 specification (9) in the domain leads to a conditional axiomatization that achieves the rule if-intro [7] plan because there is no the required goal to instantiate the given precondition. Plan refitting applies The proof of subplan atomic action available under the planvariable Plan, with a case analysis: pre, if (cord, PlanA, PlanB) * 0 goal pre, Plan * Vgoal ifintro. the example, In open$ag(mbox) the conditional = T that plan interpretation cond is instantiated with failed to prove: the missing precondition Plan1 := if open-jlag(mbox) = T then Plan3 else Plan4. Applying the rule ifsplitting [ 71 pre, cond, PlanA + 0 goal pre, lcond, PlanB + 0 goal pre,if (cond, PlanA, PlanB) + Ogoal ifsplitting to sequent (9), plan refitting obtains the following subplan specifications: delete$ag(msg( n, mbox)) = F, open_.ag(mbox) = T, Plan3 + 0 [open$ag( mbox) = T A OF A pre’] , delete$ag(msg(x,mbox)) = E yopenJEag(mbox) = T, Plan4 + 0 [ open&g( mbox) = T A OF A pre’] . (11) (12) Plan3 can be instantiated with the empty action ex( empty-action), because the desired subgoal holds already in the initial state. lc~/~en_Ju~(mbn.r) = T in sequent ( 12) is equivalent The formula opetr_Jlag(mailbox) ex(opetz(ttzbox)) = F and which opens thus. Plan4 is instantiated with the action the mailbox and starts a mail session: to the formula instance Vttzuilbox [ opetz-$ag( muilbox) = F /‘. CY( opetz( mailbox) ) -+ 0 opetz_fIag( mailbox) = 7’1. With that, the following conditional plan is obtained as an instantiation of Plant: Plan, := if opetz-jiug( ttzbox-) = T then er( empty-action) else ex ( open ( ttzbox) ) . Now. the precondition pre’ in sequent ( IO) can be instantiated with the formula defete$ag(msg( x. mbox) ) = F A opetr_Jag( mbox) = 7: specifcation The proof of subplan ( IO) proceeds as an interleaved process of plan generation and plan verification. A tactic for the ordering of conjunctive goals is activated [ 71 which decides the subgoal delete-$ag( msg( x. mbox) ) = T, since deleting a message destroys of reading rule 171: the possibility is isolated with the help of the effectsplit read_jag(rtzsg(x, mbox) ) = T before it subsequently. The first subgoal the subgoal to achieve pre, PlanA * 0 [go&r I”\ OF Apre’I pre’, PlanB + 0 [goal;!] pre. PIann ; Plana =+ 0 [goall A goal21 eRectsplit. composition This rule requires a sequential that the tirst planvariable second planvariable Plan2 planvariable single atomic action ex(type(x, mbox) ) in specification must be withdrawn and plan refitting sets Plan? a subplan a subplatz achieving by the effect-intro represents introduced represents of two planvariables achieving that can be split such the the the the first subgoal, while subgoals. But instantiated with the remaining rule has been ( IO). Thus, this instantiation to Plans ; Plane. We obtain two subplan specifications ( I3 ) and ( 14) : opetz$ag(ttzsg(mbox) ) = T A rfelere&zg( nzsg( x. rtzbox) ) = F: Plans .+ 0 [ read_&zg( nzsg( A-, mbox) ) = T I’, 0 F I? pre”] , pre”. Plan6 ==+ 0 [ delete&g( msg ( x. tdmr ) ) = T ] (13) (14) The first subgoal proven during plan ex(type(.r, mbox)) variable Plans: read$ag( ttzsgi .x, mbon) ) = T (sequent Consequently. the action interpretation. from ( 13) ) has successfully achieving this subgoal is reused as an instantiation been the plan skeleton of the plan- J. Koehler/Artijicial Intelligence 87 (1996) 145-186 175 open$ag(msg(mbox)) = T A delete$ag(msg(x,mbox)) = F, ex(type(x,mbox)) +O[read__ag(msg(x,mbox)) =TAOFApre”]. (15) The instantiation sequent (14) is instantiated with can be successfully verified by plan refitting. The precondition pre” in open_jlag( msg( mbox) ) = T A delete_.ag( msg( x, mbox) ) = F because this precondition “survives” the execution of the type action. open$ag( msg( mbox) ) = T A delete$ag( msg( x, mbox) ) = F, Plan6 + 0 [ delete$ag( msg( x, mbox) ) = T] . (16) isolates (16) failed to prove. Plan refitting concludes Sequent pretation tiation and relies on planning that instantiates successfully instantiated structed by plan refitting. The result the sequential plan Pl: the open subgoal delete$ag(msg(x, mbox)) = T that plan inter- that the reused plan provides no instan- the action ex(delete( x, mbox)) have been has been con- is the desired plan P2 that is obtained by reusing and a correct proof of the plan specification the remaining planvariable Plan6. With this, all planvariables from scratch. It generates P2 if open-jlag( mbox) = T then ex( empty-action) else ex( open( mbox) ) ; ex(type(x,mbox)) ;ex(delete(x,mbox)). 5 The planning process benefits from the reuse of plan Pl in two situations: - When a conditional second principles control structure has to be introduced; from the case analysis has to be performed. the subgoal read_$ag(msg( x, mbox)) = T has to be addressed; here planning the same goal “knows” on which formula reuses an action here planning that achieved instantiation - When from second principles in the candidate plan. The search space during planning can be dynamically restricted in both cases, which to the generative according in [43]. reuse of the candidate I5 A maximal results leads to a speed up of the second principles planner when compared planner. is not possible complexity refitting where the action plan, but subsequently demonstrates a maximal see [43, p. 14401. instance as the action to determine efficiently re-introduced “that it is not possible reusable plan skeleton before plan generation to the to some overhead during plan from the original ex( delete( x, mbox) ) . This time) in polynomial (i.e., this skeleton”, starts to extend instance ex( delete( m, mybox) ) is eliminated plan this leads In the example, The example demonstrated plan. MRL is the first system the generation of a conditional plan by reusing a sequential reuse and modify plans containing that is able to correctly I5 A summary of the results of an empirical study can be found in 130,321. 176 J. Koehler/Art@id tntel1ipxc.e 87 (1996) 145-186 structures. Usually, in control the simple example. Refitting of such plans with a large number of atomic actions and nested control structures can involve several hundred deduction these plans are much more complex than those shown steps. 5.3. Reuse of corztrol structures The reuse and modification that do not occur in approaches of plans with control structures restricting problems plans comprises operations modification addition or reordering of atomic actions. The modification of complex plans raises question of whether decisions have to bc made: new to sequential plans. The deletion, the to control structures. Two main like the instantiation, leads to qualitatively can be extended these operations of sequential themselves (i) Are control structures reused? rer.cu.\ Are only structures? those sequential subplans reused that occur in the scope of control (ii) Are control structures introduced by the modification strategy if this is required by the refitting process‘? V~YSUS Are control structures only a plan containing control structures? introduced if the current planning problem requires in a second principles planner in a help system application. Here, plans are generated The treatment of control structures carefully is working and to take into consideration these decisions application domain. The MRL system provides which active help to users of software environments to meet exactly structures are only reused in a restricted way in the implemented introduced planning problem An unrestricted - Reused control into the modified plan or preserved the generation of a plan containing the user’s goals and are not guaranteed structures requires to make from the specific requirements the reuse component of the PHI planner to provide that plans are required control system MRL. They are if the current in the plan skeleton only [ 51. This means requires control structures. reuse of control structures can lead to the following problems: to be as simple as possible. Therefore, to correspond to the requirements of the current planning situation. This can result example, a case analysis makes the execution of a plan more complicated a test on the conditional analysis problem should only be introduced requires us to generate a conditional has to be performed during execution in over-complicated plans. For because time. Thus, a case into a plan skeleton when the current planning plan. _ Plans can achieve unintended a reused plan by removing optimizing to generate optimal plans because plan. Superfluous control structures ative plan which achieves a particular goal for all objects satisfying a precondition side-effects. Plan refitting makes some attempts at superfluous actions from it, but it is not able an arbitrary render the problem worse. For example, an iter- this is usually harder than generating in principle be reused to satisfy the reader may think of reusing a plan achieving could example, files in directory x”. This also achieves Without any attempts at optimizing iterative control structure a drastic and harmful side-effect the goal for only one of the objects. As an the goal: “delete all my in directory x”. the superfluous the goal: “delete file x.ps the reused plan by removing is achieved. J. Koehler/Artijicial Intelligence 87 (1996) 145-186 111 Planning Logic Description Logic Update of the Plan Library construction of a new plan entry encoding of the abstracted plan specification Plan Retrieval Plan Retrieval best ranked plan fotwarded to plan modification Fig. 5. Plan entries in the plan library. Restricting the reuse of control structures as in MRL is one way of coping with these problems. Further research is necessary in order to identify other solutions. 6. Updating the plan library The plan library is updated dynamically in MRL. Fig. 5 summarizes logic and a planning structure based on the subsumption as concept descriptions information about a successfully and information the hybrid repre- logic. The description hierarchy and serve solved the extracted from an abstract class of planning is represented in the planning into the library over the index in to the same index when their implemen- In the current problems problem: that has led to this plan. This information the plan specification, the library with an indexing sentation of the library based on a description logic provides of encoded plan specifications, which are represented as indices to plan entries. A plan entry contains planning the plan, planning process logic. A plan entry can be retrieved to which it is linked. Each the application specifications tation, only one plan entry the abstract class of planning problems entries be solved by modifying are encoded by equivalent library. Planning the plan stored in the plan index represents domain. Several plan entries can be linked problems belonging from and inserted in the plan entry. concept descriptions. represented by the index. This avoids redundant to the same abstract class can is stored on a “first come-first serve” basis as an instance of The system starts with bottom. A new plan entry the initial plan is added to the library under library containing the following conditions: only the indices top and - no reusable plan has been found and the planner has to generate a plan from first principles, the reused plan had to be modified. is not updated when: - The plan - a library plan directly solves a current planning problem, - the index of the current planning problem library is already contained in the library. 17x .I. K~~rhler/Arr~~t~,trI lrrwllipwcr X7 (1996) 145-186 Let us continue the example from Section 5. According to the above-mentioned conditions, sources of information the plan library is updated because the reused plan has been modified. Three are available for the construction of the plan entry: the current plan specification. the modified plan that meets the specilication, the proof tree that has been constructed during plan refitting. (i) (ii) (iii) The index of the plan entry has already been computed during plan determination. The the computation current plan specification we understand plan. This means, are not necessary plan can achieve as side-effects. is completed before it is added to the plan entry. By completion of the weakest preconditions those preconditions for the plan and those goals are added to the plan specification and strongest goals of a from the plan specification which that a are eliminated To determine the weakest preconditions and strongest goals of a plan, the planning is analyzed. In particular, that has led to the plan process have been applied during cnuditiorrs of an action and process ification thus, the position of the plan in the library can change caused by altered subsumption relationships. see Section 2. If the completion the encoding of the plan spec- it and the proof are investigated. They specify it achieves, leads to a changed plan specification is repeated, because a different that the necessary pre- concept description may result action axiom schemata the effects formula, from In the example under consideration, the completion of plan specification $2 leads to a disjunctive precondition into the plan with the help of the ifintro reflecting rule: the complete case analysis that has been introduced Planp:! A [ delete-.ag ( nlsg ( s, 172170x) ) = F A q?err$ag( Inbox) = T] V [delete-$ag( msg( x, mbox) ) = F A openflag( mbox) = F] -+ 0 [ read$ag(msg(x, Inbox) ) = T A delete.$ag ( msg ( x . mbox ) 1 = T ) An explicit representation of the possible preconditions for plan P2 supports the iden- tification of applicable of the encoding precondition formula subplans during is not necessary because is logically equivalent the plan-interpretation the conjunctive normal to the originally phase. A recomputation form of the completed specified precondition in &l’ A major part of a plan entry comprises information that is extracted from the proof tree leading to a plan: - relation of sequential subplans occurring in conditional plans to their weakest pre- conditions. - extraction of sequential body plans occurring _ relation of atomic actions In order to relate sequential analyzed for applications has led to the conditional to the atomic goals achieved by the plan. subplans to their weakest preconditions, the proof tree is of the rule &intro, see Section 5. In the example, plan refitting plan in iterative plans, J. Koehler/Artijicial Intelligence 87 (1996) 145-186 179 Plan] if open_j?ag( mbox) = T then ex( empty-action) else ex( open( mbox) ) for this plan are explicitly the sequential preceding preconditions cation one of the preconditions. Consequently, branch l6 formula. Now, each of them plan ex( type( x, mbox) ) ; ex(delete( n, mbox) ) . Two possible plan specifi- to from the then plan resulting in the completed to the sequential the sequential that belongs represented is related subplan ex( empty-action) ; ex( type( x, mbox) ) ; ex( delete( x, mbox) ) is related to the preconditions delete$ag( msg( x, mbox) > = F A open_jlag( mbox) = T and the sequential subplan resulting from the else branch e_x(open(mbox)) ;ex(type(x,mbox)) ;ex(delete(x,mbox)) is related to its preconditions delete$ag( msg( x, mbox) ) = F A open_jlag( mbox) = E Plan refitting relies furthermore on information the help of an old subgoal during plan subgoals. When a current atomic about the relationship between atomic been subgoal has successfully tries the from the from the application of action axiom schemata. For the in order to achieve the old subgoal plan refitting interpretation, instances which achieve atomic goals are extracted and atomic actions proved with to reuse current subgoal. The action leaves of the proof tree resulting example plan, the following relationships are stored in the plan entry: the action or subplan which achieved - ex( maiZ( mbox) ) achieves open_$ag( mbox) = T, - ex( type( x, mbox) ) achieves readJEag( x, mbox) = T, - ex(delete(x, mbox)) achieves delete$ag(msg(x, mbox) ) = T. The construction is completed by a systematic of a plan entry with internal designators Joe with existentially quantified variables. and by a sort-preserving abstraction renaming of variables like sender of constants Finally, in the plan ples. the plan entry is related It is now available library. to its index which uniquely determines to subsequent planning its position from second princi- 7. Related work The implementation of a second principles planner based on the formal as introduced in Section 3 requires design decisions that specify how planning framework from I6 The emptyaction in this subplan pleteness and understandability is normally of the example. eliminated. It is shown here only for the sakeness of com- second principles proceeds these decisions underlying MRL and relate the system in detail. In this section, we discuss to other approaches. the most important of Meta level versus object level can proceed on a metu level or on an object from second principles level, previously generated plans are directly Planning On the object planning provide “recycle” knowledge extracted from previous planning processes experience in the form of planning problem. This means the basis for planning tactics. heuristics or strategies. reused level. to solve the current process to that represents planning from second principles. Reuse on the metu level means that the plans as the objects of the planning The commitment of a particular planner to one of these levels is a fundamental design decision. A commitment systems, e.g., PRIAR 1271. CHEF leads [ 391 and GRASSHOPPER to adaptive and reactive systems based on learning I361. to the object level leads to case-based planners and reuse to the meta level e.g., PRODIGY [ 19 J and SPA (2 I]. A commitment techniques, MRL proceeds mainly on the object level because is reused, e.g., when plan refitting it relies on the reuse of stored plans. is supplied with information on which case analyses have to be performed, see the example in Meta-level knowledge about preconditions Section 5. Skeletal plun rejinement versus jlexible modijication When planning in order to construct as skeletal plan rejinement Skeletal plan refinement from second principles proceeds on the object level, plans are modified can be implemented the desired plan from them. Plan modification [ 14] or as j?exible modi@ution computes an appropriate ground-level in the abstract skeleton. The admissible modification [ 2 1,261. operator occurring restricted tracking may occur. The modified plan is obtained as an instance of the skeleton. in several hierarchical but they can proceed to instantiation, instantiation for each are steps and back- operations Flexible modification as implemented in MRL admits a variety of operations on plans, like the deletion and addition of operators and control structures. Skeletal refinement occurs fully been proved situation, an instantiation plan modification to be a logical consequence in MRL when the current plan specification has success- In this of the library plan will solve the current planning problem and of the reused plan specification. can be restricted to easy-to-compute substitutions. Trarlsformation bused versus gerferutiorl bused The modification of a plan can be done with the help of transformations [ 6,19,38] or by extending a first principles planner with the ability to modify plans [21,25,54]. Transformation-based in a failure hierarchy and resolved by activating approaches execute a plan in a simulated environment. Failures on the are classified i.e., a proof of the plan. This approach is rules, which completeness hard to achieve. I7 Further problems are related to the soundness and termination of the failures, transformation of the failure hierarchy requires a prediction and the available of all possible transformations ” As an example see the incompleteness proof of CHEF in )20 1 J. Koehler/Artificial intelligence 87 (1996) 145-186 181 Transformations transformations. makes transformed it difficult to ensure plan is sound, resolving a failure may introduce other failures, which process does not loop and that the that the transformation i.e., that it solves the current planning problem. To overcome PRIAR system the planner possibility. principles planner possesses these problems, a generation-based [ 251. The proof of the completeness approach has been introduced in the of plan modification with respect to is trivial since plan modification Soundness and termination can rely on plan generation as a “fall-back” are also easy to ensure if the underlying first these properties. The modification of a plan in MRL proceeds generation based. MRL computes a plan to be reusable. The extension of a skeleton for completion, which interacts with the generative skeleton and sends it to plan refitting PHI planner. The plan skeleton preserves assumed modification The correctness the modified plan is sound. Planning knowledge plan refitting and dynamically that are to a correct plan requires flexible operations, which add, delete or reorder operators and control structures. that represented by the plan skeleton guides of deductive plan refitting, which completes those control structures and actions the skeleton, ensures the search space. constrains MRL is “complete” with respect on plan generation. The system plan if there is one because incomplete. to the planner because plan refitting can “fall back” in the sense that it will not always find a the use of tactics makes the underlying LLP theorem prover is incomplete Conservative versus nonconservative A desirable property of plan modification is conservatism, which means [the original plan ] ” [ 281. Minimal modification to ‘produce a of a is PSPACE-hard. Therefore, . . . by minimally modifying to preserve the maximal number of applicable operators in [43] shows that the computation In order to ensure efficiency of the plan modification process, for example proof tactics for plan interpretation plan plan implies in a plan skeleton. A critical analysis of conservatism of such maximal plan skeletons including MRL are nonconservative. they rely on polynomial that run into the search space of possible in polynomial plans as made explicit by Hanks and Weld [ 21 I. This entry point cannot be guaranteed to be the best, but it is the best the approximation It is an open approximable within a the maximal problem whether to hint at a negative results constant result. approximations, time, which compute an “entry point” algorithm can compute. is efficiently applicable subplan for similar problems ratio. Recent implemented systems [4,51] seem The plan library Recently, the representation of plans based on terminological to several approaches, which extend description representational for the representation primitives knowledge represen- logics with of actions and systems has tation new application-oriented plans. led One such extension reasoning simulates and solves implements The system situations, is the system RAT about plans by inferences the execution of plans, verifies [ 231 which is based on KRZS in the underlying description [ 31. RAT logic. in particular their applicability tasks of temporal projection. An application of description logics to tasks of plan recognition is developed in T-REX [56]. Plans in the form of disjunctive actions. in T-REX may contain conditions and iterations as well as nondeterminism The plan library can be static as well as dynamic retrieves typical plans. The system to the library. A dynamic plan in MRL. A static library comprises these plans for reuse, but does not the lifetime of the adds new plan entries library grows during i.e., MRL starts with an empty library and incrementally user-predefined add new plans system, to it. in a library in polynomial The main advantage time. This contrasts in using a description to retrieve “reasonable logic as a query language lies in the novel solution similar past cases . . within (cf. [S4, p. 1031). Furthermore, schemes based on discrimination to the plan library to the indexing problem and in the theoretically properties of the retrieval algorithm. For the first time, retrieval guarantees to approaches limited bounded an indexing of plan libraries based on the as in MRL well-founded that solutions are found that are restricted resources” lattice structure provided by the suhsunzption hierarchy overcomes problems occurring in indexing networks. On one hand, discrimination fail networks cope with conjunctions on discrimination For example, given a goal state containing developed computes all subsets of subgoals of cardinality the atomic subgoals as input. This means, n except the empty set as input concept descriptions of subgoals are reflected it II - 1, then n - 2 and so on until it takes takes the power set of is 2” - 1. Retrieval based on between sets to algorithms working input set. growing the retrieval algorithm retrieval faced with an exponentially avoids such problems because existing of literals. On are often first searches a plan covering complex plan specifications in the worst case, which the retrieval algorithm II atomic subgoals, they are restricted in the subsumption the other hand, If this fails, relationships II subgoals. in indexing hierarchy. networks because these [S4] in 8. Conclusion We have presented a logic-based relies on a systematic decomposition phase model. Deductive each phase. The formal model makes no commitments plans or planning situations. inference processes with clearly defined semantics approach to planning from second principles, which of the planning process with the help of a four- formalize and the nature of of a particular planning implementational formalism details, is independent to application domains. Plan modification ples planner to reuse plans containing Reusable plans are retrieved tion logic as query a lattice structure and retrieval guaranteed language to find existing solutions. yields provably correct moditied plans and enables a second princi- and iterations. updated plan library using a descrip- to the library. The plan library can be indexed basing on is is formalized using a KL-ONE-like from a dynamically control structures classifier which like conditionals The formal Furthermore, ness, completeness framework has led to an implemented in contrast to heuristic approaches, system with predictable behavior. like the correct- theoretical properties and efficiency of the inference procedures can be proved. J. Koehler/Artijicial Intelligence 87 (1996) 145-186 183 Acknowledgements This work was supported by the German Ministry for Research under contract ITW 9000 8 as part of the PHI project. of the PHI group, Mathias Bauer, Susanne Biundo, Dietmar Dengler, (BMFT) members Gabriele Paul for their interest am indebted Hans-Ergen made very detailed comments helping me during the and I to Wolfgang Wahlster for his advice and support, and to Bernhard Nebel and reviewers Ohlbach in my work and for fruitful discussions. Furthermore, on the draft version. The anonymous the revision of the paper. for commenting I want and Technology to thank Appendix A. Proofs of theorems Theorem 14. Pold meets S,, ifAx /= &Id + S,,,. Proof. We have to prove the following sequent An, Pold Ai”-%ld -+ ~W&ld =+ Pold ~P’%ew + ~$Y’&w (A.1) in which both planvariables We start by applying the rule I -+ is applied are already the sequent rule r ---) which leads to sequent instantiated with the reused plan formula Pold. (A.2). To this sequent, leading to sequents (A.3) and (A.4). Ax, Pold A PWmv, 0 goalold + 0 &‘~Qkv. (A.21 (A.3) (A.4) Sequents and apply (A.3) and (A.4) have to be expanded further. We start with sequent (A.3) the rule IA, followed by r-A and obtain sequents (A.5) and (A.6). Ax, Pold > P%mv Ax, Pold7p=hew * * Pold 3 0 @‘dmv, preold, 0 m&w. To sequent (A.4), the rule IA is applied leading to sequent (A.7). Ax3 Pold~Pr~“ew7 0 goalold * 0 .w&ew. (A.5) (‘4.6) (A.7) The original sequent is proved succedent contain a common sequents and (A.7) (A.6) lead to the two subproofs iff the three sequents are axioms, (A.5) formula. This holds for sequent i.e., antecedent and immediately, while Ax, prenew * pold and Ax, 0 goalold * 0 goalnew. Cl 184 J. Xo~lrler/Arttjrucd In~ellqww X7 (I YY6) 145-186 Appendix B. Summary of sequent rules I’=+ A,3 I‘=+ B,A I’ =+ A A B, A rA pre, Plan, ; Plan2 =+ Ogoal pre, Plan * Ogoal .reyuence_us.sunzption pre, Plan, =+ 0 [goal, A OF npre’l pre’, Plan2 =s OgoaLl pre. Plan, ; Plan2 * 0 [goal, A goal21 pre. Plan, =+ 0 I godnew A OF Apre’j pre’. Plan2 + Ogoal pre, Plan, ; Plan? =3 Ogoal eflectsplit effect_intro pre, if (cord, PlanA, PlanB) * Qgoal pre, Plan * Ogoal lj-fntro pre, cond, PlanA =+ goal pre, Tcolzd, PlanB + Ogoal pre, if (cond, Plan A, PlanB ) + 0 goal lfsplittirig References 1 I W. Anderson, J. Hendler, M. Evetf and B. Kettler, Massively parallel matching of knowledge structures, in: I-l. Kitano and J. Hendler, eds., Mnssive!, forctllel Artijiciul Intellipznce (MIT Press, Cambridge, MA. 1994) 53-71. 2 1 E Baader and B. Hollunder, KRIS: knowledge representation and inference system, SIGART Bull. 2 (2) (1991) 8-15. 3 I F. Baader, B. Hollunder, B. Nebel. H.-J. Protitlich and E. Franconi. An empirical analysis of optimization techniques for terminological representation systems, or making KRIS get a move on, in: Proceedings 3rd Internutiwutl Conference on Principles of Knowled,~r Representation und Recmming, Cambridge, MA (1992) 270-281. J. Koehler/Ariificial Intelligence 87 (1996) 145-186 185 [ 4 ] C. Backstrom, Finding in: C. Backstrom least constrained plans and optimal parallel executions and E. Sandewall, eds., Current Trends in AI Planning (10s Press, Amsterdam, [ 5 1 M. Bauer, S. Biundo, D. Dengler, J. Koehler and G. Paul, PHI-a logic-based is harder than we thought, 1994) tool for intelligent help systems, in: Proceedings IJCAI-93, Chambety 161 M. Beetz and D. McDermott, Improving ( 1993) 460-466. robot plans during their execution, in: Proceedings 2nd fnternational Conference on Artificial Intelligence Planning Systems ( 1994) 7-12. [7] S. Biundo and D. Dengler, The logical language for planning UP , Research Rept., German Research Center for Artificial Intelligence, Saarbriicken ( 1996). [8] S. Biundo, D. Dengler and J. Koehler, Deductive planning and plan reuse in a command language environment, in: Proceedings ECAI-92, Vienna (1992) 628-632. [ 91 A. Borgida and P Patel-Schneider. A semantics and complete algorithm for subsumption in the CLASSIC description logic, J. Artif Intell. Res. 1 ( 1994) 277-308. [ IO] R. Brachmann and H. Levesque, The tractability of subsumption in frame based description languages, in: Proceedings AAAI-84, Austin, TX ( 1984) 34-37. [ 111 R. Constable, Implementing Mathematics with the Nuprl Proof Development System (Prentice Hall, Englewood Cliffs, NJ, 1986). 1 121 D. Dengler, An adaptive deductive planning system, in: Proceedings ECAI-94, Amsterdam (1994) 610-614. [ 131 E. Feigenbaum, The simulation of natural learning behavior, in: E. Feigenbaum and J. Feldman, eds., Computers and Thought (McGraw-Hill, New York, 1963). [ 141 P Friedland and Y. Iwasaki, The concept and implementation of skeletal plans, J. Automated Reasoning 1 (1985) 161-208. [ 15) D. Gabbay, Declarative in: H. Barringer Altrinchham, Lecture Notes in Computer Science 398 (Springer, New York, 1989) 402-450. systems, and A. Pnueli, eds., Proceedings Colloquium an Temporal Logic in Specification, logic for imperative past and imperative future: executable temporal [ 161 J. Gallier, Logic for Computer Science: Foundations of Automatic Theorem Proving (Wiley, New York, 1987). 1171 R. Givan and D. McAllester, New results on local inference in: Proceedings 3rd International Conference on Principles of Knowledge Representation and Reasoning, Cambridge, MA ( 1992) 403- 412. relations, of theorem proving [ 181 C. Green, Application DC (1969) 219-239. [ 191 K. Hammond, Explaining [ 201 S. Hanks and D. Weld, The systematic plan adaptor: a formal foundation of case-based planning, Tech. of Computer Science and Engineering, University of Washington, Seattle, and repairing plans that fail, Arttf Intell. 45 ( 1990) 173-228. in: Proceedings IJCAI-69, Washington, to problem solving, Rept. 92-09-04, Department WA (1992). [211 S. Hanks and D. Weld, Systematic adaptation for case-based planning, in: Proceedings 1st fnternational Conference on Artificial Intelligence Planning Systems (1992) 96-105. 122 I S. Hanks and D. Weld, A domain-independent algorithm for plan adaptation, J. Artif Intell. Res. 2 (1995) 319-360. 1231 J. Heinsohn, D. Kudenko, B. Nebel and H.-J. Profitlich, terminological logics, Logic Users Workshop, KIT-Report 95, TU Berlin ( 199 I ). in: C. Peltason, K. Luck and C. Kindermann, Integration of action in eds., Proceedings Terminological representation [ 24) M. Heisel, W. Reif and W. Stephan, Tactical theorem proving in program verification, Lecture Notes in: Proceedings in Artificial J&h International Conference on Automated Deduction, Kaiserslautem, Intelligence 449 (Springer, Berlin, 1990) 117- I3 1. 1251 S. Kambhampati, Flexible reuse and modification in hierarchical planning: a validation-structure-based approach, PhD thesis MD 207 42-34 I 1, Center for Automation Research, Computer Vision Labomtory, University of Maryland, College Park, MD ( 1989). [ 261 S. Kambhampati, A theory of plan modification, 1271 S. Kambhampati in: Proceedings AAAI-90, Boston, MA ( 1990) 176-182. and J. Hendler, Control of refitting during plan reuse, in: Proceedings NCAI-89, Detroit, MI ( 1989) 943-949. [28] S. Kambhampati and J. Hendler, A validation-structure-based theory of plan modification and reuse, Arttf Intell. 55 (1992) 193-258. 1341 1351 1361 I.371 1381 I.?01 1401 141 I 1421 1431 1441 1451 1461 186 .I Koehlrr/Art~jicrcl lrtrellr~rt~cr X7 (I 996) IJS-IX6 129 1 J. Koehler, An application of terminological logics IO case-based reasoning, in: Proceedings 4th fntenrcttionul Crmference ou Princ?ples of Knowledge Representation and Reasoning, Bonn ( 1994) 351-362. I30 1 J. Koehler, Avoiding pitfalls u, case-based planning, in: Proceedings 2nd Internutiontrl Cortference on Artt$citrl Intelligence Pknning Systent.r ( 1994) 104- 109. 13 I ) J. Koehler. Correct modification of complex plans. in: Proceedings ECAI-94. Amsterdam ( 1994) 60% 609. 132 1 J. Koehler, Flexible plan reuse in a formal framework, Trends in A/ Pkrnning (10s Press. Amsterdam, 1994) in: C. BiickstrGm and E. Sandewall, eds., Current I7 I - 184. J. Koehler and R. Treinen, Constraint deduction in an interval-based temporal logic, in: M. Fisher and trnd Ternporul Logic, Lecture Notes in Artificial Intelligence 897 R. Owen, eds.. Executuhle Mod& IO3- I 17 (Springer, Berlin, 1995) J. Kolodner, Cuw-Based Rea.wrrit~sq ( Morgan Kaufman. Los Altos, CA, 1993). E Krtiger, Temj~orcrl Logic, of Pm~ratxv C. Leckie and 1. Zuckerman. An ( Springer. Heidelberg, 1987). to learning search control I’roc.eedings IJCAI-93, Chambery inductive approach ( 199.3) I I OO- I 105. rules for planning, in: Z. Manna and R. Waldinger, A theory of plans. in: M. Georgeff and A. Lansky, eds.. Reusotting crhout .ktiwts nrrd Pktt~s: Proceedings 1986 Wink~lrop ( Morgan Kaufmann, Los Altos, CA. 1987) I I-45. D. McDermott. Planning and acting, Cognit. Sci. 2 ( 1978) 71-109. S. Minton. Quantitative results concerning the utility of explanation-based learning, in: Proceedings .AAA/-88, St. Paul, MN (1988) 564-569. B. Moszkowski and Z. Manna, Reasoning in interval temporal logic, in: E. Clarke and D. Kozen, eds., Proceedings Conj>rence on Ingicx of Pro,yrnnr.v. Lecture Notes in Computer Science 164 (Springer, New York, 198?). B. Nebel, Rea.wnrtt,q and Rer+ion t/t Hybrid Rrpresentution Sy.Vems, Lecture Notes in Artificial Intelligence 422 (Springer, Berlin. 1990). B. Nebel, Terminological reasoning is inherently intractable, Art~j ltrtrll. 43 ( 1990) 235-249. 8. Nebel and J. Koehler. Plan modification versus plan generation: a complexity-theoretic perspective. in: Proceedings IJCAI-93, Chambery ( I993 ) I436- I44 I. B. Nebel and J. Koehler, Plan reuse versus plan generation: a theoretical and empirical analysis. Art$ hztell 76 ( 1995) 427-454. H.-J. Ohlbach. Semantics-based translation methods I;,r modal logics. J. h,qrc Contput. 1 ( I99 1) 69 I - 77s. L. Paulson. Jsabelle: the next 700 theorem provers. in: l? Odifredi, ed., Logic ctnd Chputer Science (Academic Press, New York, 1990) R. Reiter. Proving properties of states in the sgtuation calculus, Artif: Intell. 64 ( 1993) 337-35 I. 1471 I48 ) C. Riesbeck and R. Schank, I49 1 R. Rosner and A. Pnueli, A choppy /nsi& Cu.ru-Bawd Rectsorrin~ (Lawrence Erlbaum, Hillsdale, NJ, 1989). logic. in: Proceedings Swttposiunr nn L,ogic in Cotnputer Scirrrw. Cambridge, MA ( I986). (SO/ M. Schmidt-SchauB and G. Smolku. Attributive concept descriptions with complements, Arti/. Intell. 48 (1991) l-26. [ 5 I [ B. Selman. Near-optimal plans, tractability. and reactivity, in: Proceedings 4th fnterrmtinnal Cotzfhrence art P rtncip1e.r of Knowledge Repre.wntation ctud Reasoning, Bonn ( 1994) 52 I-529. 152) W. Stephan and S. Biundo. Multilevel refinement planning in an interval-based temporal logic, in: Procerdin~s 7th Portuguese Cotzference WI Arti’cictl Intclligenre, Lecture Notes in Artificial Jntelligence 990 (Springer, Berlin, 1995) 483-387 I.53 1 I? Traverse. A. Cimatti and L. Spalazzi, Beyond the single planning paradigm: introspective planning, in: Proc.eedings ECAI-92. Vienna 1 54 I M. Veloso, Pkannin~ culd tktnting ( 1992) 643-647. hy Armh~icrtl Retrsonirrg, Lecture Notes in Artificial Intelligence 886 (Springer, Berlin, I994 1. 155 1 L. Wallen, Autonutted Deduction 156 I R. Weida and D. Litman. Subsumption tt~ Nottr~/rrs.~icul Dqtcx (MIT Press, Cambridge, 1989 ). and recognition of heterogeneous constraint networks, in: Proceedings Tenth IEEE Conference on Art$cial Itttelligence ,/i,r Applications ( 1994). 