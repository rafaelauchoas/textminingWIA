Artificial Intelligence 171 (2007) 1011–1038www.elsevier.com/locate/artintBounded model checking for knowledge and real timeAlessio Lomuscio a,1, Wojciech Penczek b,c,2, Bo˙zena Wo´zna d,∗,3a Department of Computing, Imperial College London, 180 Queen’s Gate, London SW7 2BZ, United Kingdomb Institute of Computer Science, PAS, Ordona 21, 01-237 Warsaw, Polandc Institute of Informatics, Podlasie Academy, Sienkiewicza 51, Siedlce, Polandd Institute of Mathematics and Computer Science, Jan Dlugosz University, Armii Krajowej 13/15, 42-200 Cz¸estochowa, PolandReceived 23 August 2006; received in revised form 2 April 2007; accepted 11 May 2007Available online 24 May 2007AbstractWe present TECTLK, a logic to specify knowledge and real time in multi-agent systems. We show that the TECTLK modelchecking problem is decidable, and we present an algorithm for bounded model checking based on a discretisation method. Weexemplify the use of the technique by means of the “Railroad Crossing System”, a popular example in the multi-agent systemsliterature.© 2007 Elsevier B.V. All rights reserved.Keywords: Temporal epistemic logics; Model checking; Interpreted systems; Real time systems1. IntroductionReasoning about knowledge [9] has always been a core concern in artificial intelligence. This is hardly surprisinggiven that knowledge is a key concept to model intelligent, rational activities, human or artificial. A plethora offormalisms have been proposed and refined over the years, many of them based on formal logic. One of the mostwidely studied is based on variants of modal logics and is commonly referred to as temporal epistemic logic [9].Rather than providing a computational engine for artificial agents’ reasoning, epistemic logic, at least in this line, isseen as a specification language for modelling and reasoning about systems, much in common with formal methodsin computer science. Formal properties of the logics such as completeness, decidability and complexity have beenexplored [10,12,13,20].Specification languages are most useful when they can be verified automatically. In this effort both theorem provingand model checking techniques as well as tools for epistemic logic have been developed. In the model checkingapproach the question of whether or not a system of agents S satisfies a property P is tackled by trying to establish* Corresponding author.E-mail addresses: A.Lomuscio@imperial.ac.uk (A. Lomuscio), penczek@ipipan.waw.pl (W. Penczek), b.wozna@ajd.czest.pl (B. Wo´zna).1 The author acknowledges partial support from the EPSRC (grant GR/S49353).2 The author acknowledges partial support from the Royal Society (grant ESEP 2004/R3-EU).3 The research presented here was conducted while B. Wo´zna was supported by EPSRC (grant GR/S49353). The author also acknowledgespartial support from the Ministry of Science and Information Society Technologies under grant number 3 T11C 011 28.0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2007.05.0051012A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038whether or not MS |= φP , where MS is a suitable model for S and φP is an appropriate logical formula representingP ; we refer to [8] for more details.In particular, for what concerns temporal epistemic logic, model checking techniques based on BDD [26,29],bounded model checking [23], unbounded model checking [16] have been developed and their implementation eitherpublicly released [11,26] or made available via a web-interface [22].While, one could now argue that verification via model checking of temporal epistemic logic has now become ofage, in many respects the area is still lacking support for many essential functionalities. One of these is real-time.While the formalisms above deal with discrete sequence of events, it is often of both theoretical and practical interestto refer to a temporal model that assumes a dense sequence of events and uses operators able to represent densetemporal intervals. The aim of this work is to make a first step in this direction. In particular, recent contributionshave focused on extending model checking techniques and tools [14,23,25,26,28,32], to adapt them to the needs ofmulti-agent systems (MAS) formalisms [6,9,14,15].Specifically, we make two contributions: first we present a logic, that we call TECTLK, to reason about realtime and knowledge in MAS; second, we present a bounded model checking technique for verifying automaticallyproperties of multi-agent systems expressed in this logic.The rest of the paper is organised as follows. The next section defines Real Time Interpreted Systems, the semanticson which we work with throughout the paper. In Section 3 the logic TECTLK is introduced. Section 4 deals withthe discretisation process necessary for the bounded model checking algorithm, discussed in Section 5. Section 6shows how this method can be applied to the “railroad crossing system”, a typical multi-agent system example of timedependent systems. We conclude in Section 7 by discussing some related work.2. Real Time Interpreted SystemsIn this section we briefly recall the concept of timed automata, which were introduced in [2], and define Real TimeInterpreted Systems.2.1. Timed automataLet R = [0, ∞) be a set of non-negative real numbers, R+ = (0, ∞) a set of positive real numbers, N = {0, 1, . . .}a set of natural numbers, X a finite set of real variables, called clocks, x ∈ X , c ∈ N, and ∼ ∈ {(cid:2), <, =, >, (cid:3)}. Theclock constraints over X are defined by the following grammar:cc := true | x ∼ c | cc ∧ cc.The set of all the clock constraints over X is denoted by C(X ). Note that inequalities involving differences of clocksare not in C(X ).A clock valuation on X is a tuple v ∈ R|X |. The value of the clock x in v is denoted by v(x). For a valuation v andδ ∈ R, v + δ denotes the valuation v(cid:7) such that for all x ∈ X , v(cid:7)(x) = v(x) + δ. For a subset of clocks X ⊆ X , v[X := 0]denotes the valuation v(cid:7) such that v(cid:7)(x) = 0 for all x ∈ X, and v(cid:7)(x) = v(x) for all x ∈ X \ X. The satisfaction relation|= for a clock constraint cc ∈ C(X ) and v ∈ R|X | is defined inductively as follows:v |= true,v |= (x ∼ c) iff v(x) ∼ c,(cid:7)v |= (cc ∧ cc(cid:7)) iff v |= cc iff v |= cc.For a clock constraint cc ∈ C(X ), by (cid:2)cc(cid:3) we denote the set of all the clock valuations satisfying cc, i.e., (cid:2)cc(cid:3) ={v ∈ R|X | | v |= cc}.Definition 1 (Timed automaton). A timed automaton is a tuple T A = (Z, L, l0, E, X , I), where Z is a finite set ofactions, L is a finite set of locations, l0 ∈ L is an initial location, X is a finite set of clocks, E ⊆ L×Z×C(X )×2X ×Lis a transition relation, and I : L → C(X ) is a location invariant function, assigning to each location l ∈ L a clockconstraint defining the conditions under which T A may stay in l.Each element e of E is denoted by l a,cc,X−−−−→ l(cid:7), where l is the source location, l(cid:7) is the target location, a is an action,cc is the enabling condition for e, and X ⊆ X is the set of clocks reset when performing e.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381013Fig. 1. A timed automaton.The clocks of a timed automaton are used to express its timing conditions. We differentiate between enablingconditions and invariant conditions. An enabling condition is a temporal constraint which must be satisfied for thetransition to occur. An invariant condition I(l) specifies the temporal constraint that must be satisfied for the automatonto remain in l.in,x(cid:2)300,∅−−−−−−−→ t2, t2out,true,∅−−−−−→ t3, and t3Example 1. Fig. 1 shows a timed automaton consisting of four locations: t0, t1, t2, and t3, where t0 is the initial loca-approach,true,{x}−−−−−−−−−−→ t1,tion, one clock x, the set of actions Z = {approach, in, out, exit}, and the following transitions: t0exit,x(cid:3)500,∅−−−−−−−−→ t0. The invariant of the location t0 is true, whereas all the otherst1locations are labelled with the invariant x (cid:2) 500. Intuitively, the example models a system starting from t0 and movingto t1 by the action “approach” thereby causing the clock to be reset. The automaton must then execute the action “in”between the clock values of 300 and 500, thereby reaching location t2. From t2 the action “out” must be performedbefore the clock reaches the value of 500 resulting in t3. From t3 the action “exit” must be performed before the clockreaches the value of 500 resulting in t0. Note that the enabling condition in t3 is in this case redundant.We take a timed-automaton as a fine-grained model of a real-time agent. A (real-time) multi-agent system will bedefined as a set of communicating timed automata combined via parallel composition into a global timed automaton.In the composition the transitions not corresponding to a shared action are interleaved, whereas the transitions labelledwith a shared action are synchronised. Several definitions of parallel composition exist. Here we use multi-way syn-chronisation [27], i.e., we require that each component with a communication transition (labelled by a shared action)has to perform this action when the global transition occurs.Formally, let T Ai = (Zi, Li, l0i , Ei, Xi, Ii) be a timed automaton for i = 1, . . . , m, Li ∩ Lj = ∅ for all i, j ∈{1, . . . , m} and i (cid:12)= j , and let Z(a) = {1 (cid:2) i (cid:2) m | a ∈ Zi} denote the set of indices of the timed automata whose setsof actions contain the action a. The parallel composition is defined as follows.Definition 2 (Parallel composition). A parallel composition of m timed automata T Ai is a timed automaton T A =m(Z, L, l0, E, X, I), where Z =i=1 Ii(li).Each global transition is such thatXi , I(l1, . . . , lm) =mi=1 Li , l0 = (l0mi=1 Zi , L =m), X =1 , . . . , l0mi=1(cid:2)(cid:4)(cid:3)(cid:2)((l1, . . . , lm), a, cc, X, (l(cid:5)cci, X =cc =(cid:7)1, . . . , l(cid:6)(cid:7)m)) ∈ E iff (∀i ∈ Z(a))(li, a, cci, Xi, lXi, and (∀j ∈ {1, . . . , m} \ Z(a)) l(cid:7)i) ∈ Ei,= lj .(cid:7)ji∈Z(a)i∈Z(a)Note that the agents for which no communication action is available remain in the same location when this syn-chronisation action is performed.Example 2. As an example of parallel composition let us consider the well-known railroad crossing system (RCS)[17]. The system consists of three timed automata: Train, Gate and Controller, as shown in Fig. 2. The automatonTrain is modelled via the timed automaton considered in Example 1. The automaton Gate consists of four locations: g0,g1, g2, and g3, one initial location g0, one clock y, the set of actions Z = {lower, down, raise, up}, and the following1014A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038Fig. 2. Timed automata for Train, Gate, and Controller.Fig. 3. The parallel composition of Train, Gate, and Controller.lower,true,{y}−−−−−−−−→ g1, g1down,y(cid:3)100,∅−−−−−−−−−→ g2, g2up,100(cid:3)y(cid:3)200,∅−−−−−−−−−−→ g0. The invariant of thetransitions: g0locations g0 and g2 is true, whereas the locations g1 and g3 are labelled with the invariant y (cid:2) 100 and y (cid:2) 200,respectively. The automaton Controller consists of four locations: c0, c1, c2, and c3, one initial location c0, oneapproach,true,{z}clock z, the set of actions Z = {approach, lower, exit, raise}, and the following transitions: c0−−−−−−−−−−→ c1,raise,z(cid:3)100,∅−−−−−−−−→ c0. The invariant of the locations c0 and c2 is true, whereas thec1locations c1 and c3 are labelled with the invariant z (cid:2) 100.lower,z=100,∅−−−−−−−−→ c2, c2raise,true,{y}−−−−−−−→ g3, g3exit,true,{z}−−−−−−−→ c3, c3The automata Train, Gate, and Controller synchronise through the actions: approach, exit, lower and raise, andtheir parallel composition (known as the RCS system) is shown in Fig. 3. The locations of RCS are given by triples(i, j, k) whose elements represent that Train, Gate, and Controller are at locations ti , gj and ck, for i, j, k ∈ {0, 1, 2, 3},respectively. The initial location of RCS is represented by the triple (0, 0, 0), whereas the invariants of all the locationsof RCS are the conjunction of the invariants of the three components.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–103810152.2. Timed automataWe use timed automata to interpret a logical language for real time and knowledge.Let T A = (Z, L, l0, E, X, I) be a timed automaton. An instantaneous state of T A is a pair (l, v), where l ∈ L andv ∈ R|X |.Definition 3. The dense state space of T A is a tuple (L×R|X |, q0, →), where L×R|X | is a set of all the instantaneousstates, q0 = (l0, v0) is the initial state such that v0(x) = 0 for all x ∈ X and v0 ∈ (cid:2)I(l0)(cid:3), and → ⊆ (L × R|X |) × (Z ∪R) × (L × R|X |) is the transition relation, defined by:• Action transition: for a ∈ Z, (l, v) a−→ (l(cid:7), v(cid:7)) iff (∃cc ∈ C(X ))(∃X ⊆ X ) such that l a,cc,X−−−−→ l(cid:7) ∈ E, v ∈ (cid:2)cc(cid:3),v(cid:7) = v[X := 0], and v(cid:7) ∈ (cid:2)I(l(cid:7))(cid:3),• Time transition: for δ ∈ R, (l, v) δ−→ (l, v + δ) iff v, v + δ ∈ (cid:2)I(l)(cid:3).Intuitively, an action transition corresponds to an action performed by the automaton under consideration. Follow-ing this, its location changes accordingly, and all the clocks that are associated with the action are set to zero (i.e., theones which belong to the set X ⊆ X ). Obviously, the action can be performed only if the underling enabling conditionis satisfied. A time transition does not involve a location change, but an equal increase in the value of all the clocks,provided that the new clock valuations still satisfy all the location invariants.For (l, v) ∈ L × R|X |, let (l, v) + δ denote (l, v + δ). A q0-run ρ of T A is a finite or infinite sequence of instanta-neous states:δ0−→ q0 + δ0a0−→ q1δ1−→ q1 + δ1a1−→ q2q0δ2−→ · · ·such that qi ∈ L × R|X |, ai ∈ Z, δ0 (cid:3) 0, and δi ∈ R+ for each i ∈ N \ {0}. For the q0-runs we require that δ0 ∈ R+.In other words, a run is a finite or infinite path of T A, where action transitions are taken (in)finitely often andtime transitions are aggregated. Notice that the semantics does not permit two consecutive action transitions to beperformed one after the other, i.e., between each two action transitions some time must pass. This is a convenient wayof representing a series of events to be taken in a continuous time.Example 3. Given the automaton shown in Fig. 3, let (l, v) be an instantaneous state of the automaton suchthat l = (i, j, k) for i ∈ {0, 1, 2, 3} and v = (v(x), v(y), v(z)). One of the possible q0-runs is the following:approach−−−−−→ ((1, 0, 1), (0, 50, 0)) 100−−→ ((1, 0, 1), (100, 150, 100)) lower−−−→((0, 0, 0)(0, 0, 0)) 50−→ ((0, 0, 0), (50, 50, 50))((1, 1, 2), (100, 0, 100)) 30.5−−→ · · · .In line with much of the literature of the area we make the assumption that agents run continuously without termi-nation. In a real-time context this requirement is normally expressed by distinguishing between discrete progress andtime progress. Under discrete progress we allow for action transitions to happen infinitely often, that is, no instanta-neous state occurs without action successors. Under time progress one assumes that time may pass without an upperbound; this is usually formalised by the notion of non-zeno runs.(cid:7)Formally, an infinite run ρ is said to be non-zeno iffi∈N δi is unbounded. An infinite run ρ is said to be zeno iffi∈N δi is bounded by some real value. As an example, consider the automaton shown in Fig. 4. Its q0-run (q0, 0) 1−→(q0, 1) a−→ (q0, 1) 0.5−−→ (q0, 1.5) a−→ (q0, 1.5) 0.25−−→ (q0, 1.75) a−→ (q0, 1.75) 0.125−−−→ (q0, 1.875) a−→ (q0, 1.875) 0.0625−−−−→(cid:7)Fig. 4. An example of non-zeno and zeno runs.1016A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038· · · is zeno. On the other hand, the following q0-run (q0, 0) 1−→ (q0, 1) b−→ (q1, 1) 1−→ (q1, 2) c−→ (q1, 0) 2−→ (q1, 2) c−→(q1, 0) 2−→ (q1, 2) c−→ · · · is non-zeno.We say that T A is time-progressive iff all its q0-runs are non-zeno. For ease of presentation, we consider onlytime-progressive timed automata.2.3. Real time interpreted systemsWe used timed-automata as a fine-grained semantics to reason about real time multi-agent systems. Technicallywe construct real-time traces generated by communicating automata upon which we interpret a temporal epistemiclanguage. The standard (discrete time) semantics for temporal epistemic languages is the one of interpreted systems[9]. Here we introduce a real time version of them. First, in line with [1], we partition the set of clock valuations.Let T A be a timed automaton, C(T A) ⊆ C(X ) be a non-empty set containing all the clock constraints occurring inall enabling conditions used in the transition relation E and all state invariants of T A. Moreover, let cmax be the largestconstant appearing in C(T A) and let fr(σ ) (respectively (cid:16)σ (cid:17)), σ ∈ R, denote the fractional (respectively integral part)of σ . We define an equivalence relation (cid:18) in the set of all the clock valuations as follows.Definition 4. (See [1].) For two clock valuations v, v(cid:7) ∈ R|X |, v (cid:18) v(cid:7) if and only if the following conditions are met:1. For all x ∈ X , v(x) > cmax iff v(cid:7)(x) > cmax,2. For all x, y ∈ X , if v(x) (cid:2) cmax and v(y) (cid:2) cmax then(a) (cid:16)v(x)(cid:17) = (cid:16)v(cid:7)(x)(cid:17),(b) fr(v(x)) = 0 iff fr(v(cid:7)(x)) = 0, and(c) fr(v(x)) (cid:2) fr(v(y)) iff fr(v(cid:7)(x)) (cid:2) fr(v(cid:7)(y)).In other words the valuations are equivalent if they return values greater than cmax for the same x and when theirintegral part is the same for any x, and the fractional parts are either both nil or preserve the order of any two clockvalues (see Fig. 5 for an example).The relation (cid:18) partitions R|X | into zones, denoted by Z, Z(cid:7), and so on. We will denote the set of all the zones byZ(|X |).Let AG be a set of m agents such that each agent is modelled by a timed automaton T Ai = (Zi, Li, l0i , Ei, Xi, Ii),for i = 1, . . . , m, T A = (Z, L, l0, E, X, I) the parallel composition of all the agents, and li : L → Li be a func-tion returning the location of agent i in a global location. Moreover, we take PV i to be a set of propositionalvariables containing the constant true (denoted by (cid:19)) such that PV i ∩ PV j = ∅ for all i, j ∈ {1, . . . , m}, andPV =PV i . In order to reason about multi-agent systems, where each agent is represented by a timed automa-ton, we assume the existence of a (local) valuation function VT Ai : Li → 2PV i for each agent i. We further requirethat (cid:19) ∈ VT Ai (l) for each l ∈ Li . The (global) valuation function VT A : L → 2PV for the parallel composition, isdefined by VT A((l1, . . . , lm)) =VT Ai (li). Given this, a real time interpreted system is defined as follows.mi=1(cid:2)(cid:2)mi=1Fig. 5. Equivalence of clock valuations for two clocks with cmax = 1.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381017Definition 5 (Real time interpreted system). A real time interpreted system is a tuple M = (Q, q0, →, ∼1, . . . , ∼m, V),where:• Q is a subset of L × R|X | such that all the instantaneous states in Q are reachable.4• q0 and → are defined as in Definition 3.• ∼i ⊆ Q × Q is an (equivalence) relation defined by (l, v) ∼i (l(cid:7), v(cid:7)) iff li(l) = li(l(cid:7)) and v (cid:18) v(cid:7), for each agent i.• V : Q → 2PV is a valuation function such that V((l, v)) = VT A(l).In line with [9] and related literature ∼i is an epistemic accessibility relation. Two states are related for agent iif, according to all the information the agent has available these two states cannot be distinguished; in other wordsthe two states are locally identical for agent i. In (discrete time) interpreted systems the definition of ∼i is based onthe equality of the local states for agent i in the two global states. The definition we propose here extends that byassuming that not only the local locations of the agents are the same, but also the two clock valuations are in the samezone. In other words we assume the zones of the clock valuations to be visible to agent i: if two states have the samelocation but differ in the clock zone the agent is able to distinguish them, and, consequently, the states will not be inthe same equivalence class induced by ∼i .3. The logic TECTLKTo reason about MAS, we introduce TECTLK, a logic for knowledge and real time that is the fusion [5] of thetwo underlying languages: an existential fragment of TCTL for branching real time [1] and S5n for the knowledgeoperators. Obviously, defining the fusion with the full TCTL would not be problematic [31], but we use here thefragment only because it is more suited for the model checking method that is defined later on in the paper.3.1. SyntaxLet PV be a set of propositional variables containing the symbol (cid:19) that represents the constant true, AG a set of magents, and I an interval in R with integer bounds of the form [n, n(cid:7)], [n, n(cid:7)), (n, n(cid:7)], (n, n(cid:7)), (n, ∞), and [n, ∞), forn, n(cid:7) ∈ N. Let p ∈ PV, i ∈ AG, and Γ ⊆ AG. The set of TECTLK formulae is defined by the following grammar:ϕ := p | ¬p | ϕ ∧ ϕ | ϕ ∨ ϕ | E(ϕUI ϕ) | E(ϕRI ϕ) | Kiϕ | DΓ ϕ | EΓ ϕ | CΓ ϕ.As customary the formula E(ϕUI ψ) is read as “there exists a computation in which ϕ holds until, in the interval I ,ψ holds”. R is the operator for “Release”; E(ϕRI ψ) represents “there exists a computation in which either ψ holdsuntil, in the interval I , both ψ and ϕ hold, or ψ always holds in the interval I ”. Ki is the dual for the standardepistemic modality, so Kiϕ is read as “agent i considers ϕ as possible”. Similarly, the modalities DΓ , EΓ , CΓ are thediamonds for DΓ , EΓ , CΓ representing distributed knowledge in the group Γ , “everyone in Γ knows”, and commonknowledge among agents in Γ .The other basic temporal modalities can be introduced as usual: EGI ϕdef= (α → β) ∧ (β → α).def= ¬α ∨ β, and α ↔ βMoreover, ⊥ def= ¬(cid:19), α → βdef= E(⊥RI ϕ), and EFI ϕdef= E((cid:19)UI ϕ).3.2. SemanticsLet AG be a set of m agents such that each agent is modelled by a timed automaton T Ai = (Zi, Li, l0i , Ei, Xi, Ii).Further, let T A = (Z, L, l0, E, X, I) be the parallel composition of the agents and fT A(q) denote the set of all q-runs for T A, that is, the set of all the runs in T A that start at the state q. In order to give a semantics to TECTLK,a0−→ q1a1−→δ1−→ q1 + δ1we introduce the notion of a dense path πρ corresponding to a q0-run ρ = q0(cid:7)i−1i−1j =0 δj = 0. So,j =0 δj (cid:2) r. Notice that for i = 0 we letq2for r (cid:2) δ0, idx(ρ, r) = 0. A dense path πρ corresponding to ρ is a mapping from R to the set of states Q such thatδ2−→ · · ·. Let idx(ρ, r) be the greatest i ∈ N such thatδ0−→ q0 + δ0(cid:7)4 An instantaneous state q ∈ L × R|X |is reachable iff there is a q0-run ρ in T A such that there exists an instantaneous state in ρ equal to q.1018A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038Fig. 6. Examples of TECTLK formulae which hold at state q of a real time interpreted system.(cid:7)πρ(r) = qi + r −T A do not contain two consecutive action transitions.i−1j =0 δj where i = idx(ρ, r). This can be done in a unique way because we assume that runs of aMoreover, for the group modalities we also, as customary, define the following. If Γ ⊆ AG, then ∼EΓdef= (∼EΓ )+ (the transitive closure of ∼EΓ ), and ∼DΓ∼i .def=i∈Γ(cid:8)∼CΓ(cid:2)def=∼i ,i∈ΓDefinition 6 (Satisfaction). Let M = (Q, q0, →, ∼1, . . . , ∼m, V) be a real time interpreted system. M, q |= α denotesthat α is true at state q in M. M is omitted, if it is implicitly understood. The satisfaction relation |= is definedinductively as follows:q |= pq |= ¬pq |= ϕ ∨ ψq |= ϕ ∧ ψq |= E(ϕUI ψ)q |= E(ϕRI ψ)q |= Kiαq |= DΓ αq |= EΓ αq |= CΓ αiff p ∈ V(q),iff p /∈ V(q),iffiffiffiffiffiffiffiffq |= ϕ or q |= ψ,q |= ϕ and q |= ψ,(∃ρ ∈ fT A(q))(∃r ∈ I )(πρ(r) |= ψ and (∀r (cid:7) < r) πρ(r (cid:7)) |= ϕ),(∃ρ ∈ fT A(q))(∀r ∈ I )(πρ(r) |= ψ or (∃r (cid:7) < r) πρ(r (cid:7)) |= ϕ),(∃q(cid:7) ∈ Q)(q ∼i q(cid:7) and q(cid:7) |= α),Γ q(cid:7) and q(cid:7) |= α),(∃q(cid:7) ∈ Q)(q ∼DΓ q(cid:7)and q(cid:7) |= α),(∃q(cid:7) ∈ Q)(q ∼EΓ q(cid:7) and q(cid:7) |= α).(∃q(cid:7) ∈ Q)(q ∼CSome examples of TECTLK formulae holding at state q of a real time interpreted system are shown in Fig. 6.A TECTLK formula ϕ is satisfiable iff there exists a real time interpreted system M = (Q, q0, →, ∼1, . . . , ∼m, V)and an instantaneous state q of M such that M, q |= ϕ. A TECTLK formula ϕ is valid on M (denoted M |= ϕ) iffM, q0 |= ϕ, i.e., ϕ is true at the initial state of M; we use the term model checking problem to denote the problem ofchecking validity of ϕ when M is given explicitly.5Note that the “full” logic of branching real time, i.e., TCTL, is undecidable [1] (in the sense that its theoremhoodproblem is undecidable). Since real time interpreted systems can be shown to be as expressive as the TCTL structureof a time graph in [1], and the fusion [5] between TCTL and S5 for knowledge is a proper extension of TCTL, itfollows that problem of satisfiability for the full fusion is also undecidable. Still, the decidability of TECTL is notknown; if TECTL were decidable, it would be straightforward to show that TECTLK is also decidable on real timeinterpreted systems. In fact, we do not have decidability results for the satisfiability problem for TECTLK, but for5 Note that some authors have recently used the term “model checking problem” only to refer to situations when M is given implicitly by meansof a dedicated (programming) language.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381019our application purposes, we are interested in the model checking problem for TECTLK, and this can be shown to bedecidable (see Lemma 1).Lemma 1. Given a real time interpreted system M and a TECTLK formula ϕ, there is a decision procedure forchecking whether or not M satisfies ϕ.Proof. The correctness of the lemma follows from lemma [correctness of the labelling algorithm] in [1] and Proposi-tion 3.2.1 in [9]. (cid:2)4. Epistemic region graph and its discretisationAny real time interpreted system is dense and hence infinite. To perform model checking efficiently, we consideran appropriately generated finite version of it. In particular we use an epistemic region graph (ERG), defined as anextension of the region graph [1] augmented to include the relation ∼i , for each agent i ∈ AG.Let AG be a set of m agents, where each agent is modelled via a timed automaton and T A = (Z, L, l0, E, X , I)the parallel composition of them. The epistemic region graph for the timed automaton T A is a tupleMrg = (S, ι, →rg, ∼rg1 , . . . , ∼rgm , Vrg)where• S ⊆ L × Z(|X |) is a set of reachable states, called regions; note that each element of S is a pair (l, Z) where l isa location and Z is a zone.• ι = (l0, Z0) is the initial region, where Z0 = {v0}; recall that v0(x) = 0, for all x ∈ X ,• →rg ⊆ S × (Z ∪ {τ }) × S is defined by:– Time transition: (l, Z) τ−→rg (l, Z(cid:7)) iff there exist v ∈ Z and v(cid:7) ∈ Z(cid:7) such that−→ (l, v(cid:7)) and (l, Z(cid:7)(cid:7)) ∈ S for some Z(cid:7)(cid:7) such that v(cid:7)(cid:7) ∈ Z(cid:7)(cid:7), then either v (cid:18) v(cid:7)(cid:7) or v(cid:7)(cid:7) (cid:18) v(cid:7),(a) (l, v) δ−→ (l, v(cid:7)) for some δ ∈ R+,−→ (l, v(cid:7)(cid:7)) δ(cid:7)(cid:7)(b) if (l, v) δ(cid:7)and(c) if v (cid:18) v(cid:7), then v (cid:18) v(cid:7) + δ(cid:7)(cid:7) for each δ(cid:7)(cid:7) ∈ R.– Action transition: For any a ∈ Z, (l, Z) a−→rg (l(cid:7), Z(cid:7)) iff the following conditions hold:(a) (l, Z) is not boundary6 and(b) either there exist v ∈ Z and v(cid:7) ∈ Z(cid:7) such that (l, v) a−→ (l(cid:7), v(cid:7)) or there exist Z(cid:7)(cid:7) and v(cid:7)(cid:7) ∈ Z(cid:7)(cid:7) such that(l, Z) τ−→rg (l, Z(cid:7)(cid:7)) and (l, v(cid:7)(cid:7)) a−→ (l(cid:7), v(cid:7)).• ∼rgi⊆ S × S is a relation defined by (l, Z) ∼i (l(cid:7), Z(cid:7)) iff li(l) = li(l(cid:7)) and Z = Z(cid:7), for each agent i. Obviously ∼iis an equivalence relation.• Vrg : S → 2PV is a valuation function that extends VT A as follows Vrg((l, Z)) = VT A(l).An illustration of the above definition of the action and time transition relation is shown in Fig. 7.The following lemma guarantees that the epistemic region graph preserves validity of TECTLK formulae.Lemma 2. Let AG be a finite set of agents modelled by timed automata, T A = (Z, L, l0, E, X , I) their parallelcomposition, VT A a valuation function for T A, and M the real time interpreted system for T A. Further, let l ∈ L,and v, v(cid:7) ∈ R|X |+ with v (cid:18) v(cid:7). Then, for every TECTLK formula ϕ, M, (l, v) |= ϕ iff M, (l, v(cid:7)) |= ϕ.Proof. The proof of the lemma follows directly from lemma of equivalence of clock valuations [1] and the definitionof the accessibility relation ∼i for each agent. (cid:2)In Section 5 we define a bounded model checking (BMC) technique to verify TECTLK properties of real timeinterpreted systems. The BMC method relies on a symbolic encoding of the transition relations of the real time6 A region (l, Z) is boundary if for each δ ∈ R, v ∈ Z, ¬(v (cid:18) v + δ).1020A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038Fig. 7. Time and action transitions in an epistemic region graph.interpreted system under consideration as Boolean formulae. But, given Lemma 2, it is sufficient to define Booleanformulae that encode the transition relations of the epistemic region graph only. To perform this task we will discretisethe state space by using a discretisation method described in [33] and shortly reported below.4.1. DiscretisationLet T A = (Z, L, l0, E, X , I) be a timed automaton, ϕ a TECTLK formula, and cmax(ϕ) the largest constantappearing in C(T A) and in any interval of the temporal operators in ϕ. We choose Δ = 1/2(cid:23)log2(2|X |)(cid:24) as the discreti-sation step,7 and we define a discretised clock space D|X | with(cid:9)kΔ | 0 (cid:2) kΔ (cid:2) 2cmax(ϕ) + 2, k ∈ ND =(cid:10).Note that the clocks do not go beyond 2cmax(ϕ) + 2. This is because while evaluating TECTLK formula ϕ over timedautomata we do not need to distinguish between clock valuations above cmax(ϕ) + 1. Therefore, the maximal valuesof time delays can be restricted to cmax(ϕ) + 1, and the set of values that can change a valuation in a zone can bedefined asE =(cid:9)kΔ | 0 (cid:2) kΔ < cmax(ϕ) + 1(cid:10).Next, we take a subset U|X | of D|X | that allows us to preserve the time transitions of the epistemic region graph byinsisting that either the values of all the clocks in v ∈ U|X | are only even or only odd multiplications of Δ:U|X | =(cid:10)(cid:9)v ∈ D|X | | (∀x ∈ X )(∃k ∈ N) either v(x) = 2kΔ or v(x) = (2k + 1)Δ.To preserve action transitions of the epistemic region graph we use so called adjust transitions (cid:15)−→ ⊆ (L × D|X |) ×(L × U|X |). The aim of these transitions is to replace points no longer in U|X | (after executing an action or time tran-sition) by zone-equivalent points in U|X |. Formally such adjust transitions are defined as follows. Let (l, v), (l, v(cid:7)) ∈(L × D|X |). Then, (l, v) (cid:15)−→ (l, v(cid:7)) iff v(cid:7) ∈ U|X |, (∀x ∈ X )(v(cid:7)(x) (cid:2) cmax(ϕ) + 1), and v (cid:18) v(cid:7).Example 4. Consider a timed automaton T A with two clocks x and y, and a TECTLK formula ϕ. Moreover, assume2(cid:23)log2(2·2)(cid:24) =that cmax(ϕ) = 1. Fig. 8 shows the discretised clock space D2 of T A. The chosen discretisation step is Δ =14 . Therefore,14 , 24 , 3• D = {0, 1• D2 = {(0, 0), (0, 1• U2 = {(0, 0), (0, 24 ), ( 24 , 1, . . . , 4},4 ), (0, 24 ), (0, 1), (0, 1 24 , 4), ( 34 , 1), . . . , ( 24 , 2( 24 , 14 ), . . . , (0, 4), ( 14 ), . . . , ( 14 , 24 ), ( 14 , 14 , 0), ( 14 ), ( 14 , 34 , 14 ), . . . , (0, 4), ( 14 , 1 14 ), ( 14 ), . . . , (4, 4)}.4 , 3 34 ), . . . , ( 34 ), ( 34 , 4), . . . , (4, 4)},4 ), . . . , ( 14 ),4 , 3 34 , 1 14 , 34 ), ( 37 A different discretisation step is also possible, but the one reported here is convenient for the model checking method described later on.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381021Fig. 8. (A) Discretisation of R2 with cmax(ϕ) = 1; the elements of D2. Notice that both the black dots and the transparent rectangles are elementsof D2, but only the transparent rectangles are elements of U2. (B) Zones of R2 with cmax(ϕ) = 1 and the elements of U2. The latter one arerepresented by black rectangles.4.2. Discretised interpreted systemIn this section, we define a discretised interpreted system and show that it enjoys the same property as the epistemicregion graph Mrg, i.e., it preserves validity of TECTLK formulae.Definition 7 (Discretised interpreted system). Let E+ denote the set E \ {0}, and denote composition of two relations.A discretised interpreted system for the timed automaton T A = (Z, L, l0, E, X , I) is a structure Md = (Sd , s0, → d ,m, Vd ), where Sd ⊆ L × U|X | is a set of reachable states, s0 = (l0, v0) is the initial state, and the relation∼d→d ⊆ Sd × (Z ∪ {τ }) × Sd is defined by:1 , . . . , ∼d• (Discrete) time transition: (l, v) τ−→d (l, v(cid:7)) iff (l, v) δ−→; (cid:15)−→ (l, v(cid:7)) for some δ ∈ E+, and (∀δ(cid:7) (cid:2) δ)(v(cid:7) + δ(cid:7) (cid:18) v orv(cid:7) + δ(cid:7) (cid:18) v(cid:7)), and if v (cid:18) v(cid:7), then v (cid:18) v(cid:7) + δ(cid:7)(cid:7) for each δ(cid:7)(cid:7) ∈ E+.• (Discrete) action transition: (l, v) a−→d (l(cid:7), v(cid:7)) iff (l, v) is not boundary 8 and [(l, v) a−→; (cid:15)−→ (l(cid:7), v(cid:7)) or (l, v) τ−→d ;a−→; (cid:15)−→ (l(cid:7), v(cid:7))], for a ∈ Z.The accessibility relation ∼dition function Vd : Sd → 2PV is given by Vd ((l, v)) = VT A(l).= ∼i ∩(Sd × Sd ), for i ∈ AG, where ∼i is the accessibility relation in M. The valua-For an intuition of the above, consider a region as a pair (l, Z) for a location l ∈ L and a zone Z. A time transitionrelation represents a move to a region because of passage of time, but sharing the same location. In order to makesure that valuations of the clocks do not go beyond 2cmax(ϕ) + 2, and that before taking any transition the value ofevery clock does not exceed cmax(ϕ) + 1, we adjust each time transition by an (cid:15)-move. An action transition representsa move by an action (adjusted by an (cid:15)-move in order to stay in U) taken from a non-boundary region and possiblypreceded by the time transition step. Note that an action transition cannot be taken from a boundary region to makesure that there are no two consecutive action transition steps in a run.Lemma 3 (Discretisation preserves time successor). Let (cid:11)Z = Z ∩ U|X |, for any zone Z ∈ Z(|X |). For every region(l, Z) and (l, Z(cid:7)), if (l, Z) τ−→rg (l, Z(cid:7)), then there exist v ∈ (cid:11)Z, v(cid:7) ∈ (cid:11)Z(cid:7) such that (l, v) τ−→d (l, v(cid:7)).Proof. The proof of the lemma follows directly from Lemmas 4.1–4.4 in [33]. (cid:2)8 A state (l, v) is boundary if for any δ ∈ {kΔ | 0 < kΔ < 1}, it is not the case that (v (cid:18) v + δ).1022A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038Lemma 4 (Discretisation for action successor). Let (cid:11)Z = Z ∩ U|X |, for any zone Z ∈ Z(|X |). For any a ∈ Z andfor every region (l, Z) and (l, Z(cid:7)), if (l, Z) a−→rg (l, Z(cid:7)), then there exists v ∈ (cid:11)Z and there exists v(cid:7) ∈ (cid:11)Z(cid:7) such that(l, v) a−→d (l, v(cid:7)).Proof. The proof of the lemma follows directly from Lemma 4.2 in [33]. (cid:2)The reverse of Lemmas 4 and 3 also holds.The following lemma guarantees that the discretised interpreted system preserves validity of the TECTLK formu-lae.Lemma 5. Let AG be a finite set of agents modelled by timed automata, T A = (Z, L, l0, E, X , I) their parallelcomposition, VT A a valuation function for T A, and M the real time interpreted system for T A, l ∈ L, and v ∈ R|X |+ .Then, for every TECTLK formula ϕ, M, (l, v) |= ϕ iff there exists v(cid:7) ∈ U|X | such that v (cid:18) v(cid:7) and M, (l, v(cid:7)) |= ϕ.Proof. The proof of the lemma follows directly from Lemmas 2, 3, and 4. (cid:2)5. TECTLK bounded model checkingBounded model checking (BMC) is a SAT-based technique for symbolic model checking. Compared to BDD-based model checking it offers the advantage of handling the verification of large state spaces, albeit for a smallerfragment of the language.The main idea of BMC is to avoid the full state space generation and, instead, to look for witnesses of an existentialspecification on suitable subsets of the full model. Once a submodel is selected, the formula to be checked as well asthe considered submodel are translated into propositional formulae and a propositional satisfiability problem is solvedvia specialised SAT solvers. If the test is positive, the specification holds on the submodel as well as on the wholemodel, given the particular existential syntax checked. If not, a larger submodel is selected and the whole procedureis run again.Note that at times this procedure is used to find bugs on systems by attempting to find counterexamples to universalformulas by checking their negations.While this approach is not intrinsically more efficient than BDD-based approaches, in applications that it is oftenthe case that faults can be identified on small fragments of a full model. In these cases BMC represents an extremelyappealing alternative to more standard techniques. The efficiency of this approach has been experimentally demon-strated in, among others [4,18,24,25].For the case of this paper, knowledge and real time, we extend the technique employed for TECTL [25] andECTLK [23]. We first translate the model checking problem for TECTLK into the model checking problem of an-other logic, called ECTLKy , and then we define BMC for ECTLKy . Thanks to these translations the model checkingproblem on an infinite state space is translated into bounded model checking on a finite state space. Soundness andcompleteness of the translations is guaranteed by Theorems 1, 2, and 3 presented below.5.1. Translation from TECTLK to ECTLKyIn general, the model checking problem for TECTL can be translated into the model checking problem for a fairversion of ECTL [1]. Since here we have assumed that we deal with time-progressive timed automata only, to extendthe procedure of [1] to TECTLK, we introduce a slightly different logic ECTLKy , as presented below.Let AG be a finite set of agents modelled by timed automata, T A = (Z, L, l0, E, X , I) be their parallel composi-tion, VT A a valuation function, and ϕ a TECTLK formula. First, we construct a new timed automaton T Aϕ = (Z(cid:7), L,l0, E(cid:7), X (cid:7), I) by extending T A with: (1) a new clock y that corresponds to all the intervals appearing in ϕ, i.e.,X (cid:7) = X ∪ {y};9 (2) an action ay , i.e., Z(cid:7) = Z ∪ {ay}; (3) a set Ey = {(l, ay, true, {y}, l) | l ∈ L} of special transitions9 One clock is sufficient to perform the bounded model checking algorithm that is presented in the next section. Note other model checkingmethods may require one clock per interval appearing in the TECTLK formula under consideration.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381023that are used to reset the new clock y, i.e., E(cid:7) = E ∪ Ey . These transitions are used to start the runs over whichsub-formulae of ϕ are checked. We then extend the set of propositional variables PV to the set PV (cid:7) = PV ∪ {py∈I |I is an interval in ϕ} ∪ {pb}, where py∈I is a propositional variable true at the states where y ∈ I , and pb is a proposi-tional variable representing the fact that a state (region) is boundary. Further, we construct the discretised interpretedsystem for T Aϕ, and augment its valuation function with the set PV (cid:7) of propositional variables. Finally, we translatethe TECTLK formula ϕ into an ECTLKy formula ψ = cr(ϕ) such that model checking of ϕ over the discretisedinterpreted system for T A can be reduced to the model checking of ψ over the discretised interpreted system forT Aϕ.In order to translate a TECTLK formula ϕ into the corresponding ECTLKy formula ψ we map the ECTLKlanguage into ECTLKy by reinterpreting the temporal operators, denoted by EyU and EyR. This language is inter-preted over the discretised interpreted system for T Aϕ. Formally, for p ∈ PV, i ∈ AG and Γ ⊆ AG, the set WF ofECTLKy formulae is defined by the following grammar:α := p | ¬p | α ∧ α | α ∨ α | Ey(αUα) | Ey(αRα) | Kiα | DΓ α | CΓ α | EΓ α.1 , . . . , ∼dLet Md = (Sd , s0, →d , ∼dm, Vd ) be a discretised interpreted system for T Aϕ such that the set Sd containsreachable states only, s ∈ Sd , α, β formulae of ECTLKy , →T A denote the part of →d , where transitions are labelledwith elements of Z ∪ {τ }, and →y denotes the transitions that reset the clock y. A path π in Md is a sequence(s0, s1, . . .) of states such that si →T A si+1 for each i ∈ N. The set of all the paths starting at s in Md is denoted bydef= (∼Ei . The satisfaction relation |=Π(s). Recall that, for Γ ⊆ AG, ∼EΓfor ECTLKy is defined inductively as follows:Γ )+, and ∼Di , ∼CΓ∼d∼ddef=def=i∈Γi∈Γ(cid:8)(cid:2)ΓMd , s |= pMd , s |= ¬pMd , s |= α ∨ βMd , s |= α ∧ βMd , s |= Ey(αUβ)iff p ∈ Vd (s),iff p /∈ Vd (s),iff Md , s |= α or Md , s |= β,iff Md , s |= α and Md , s |= β,iffMd , s |= Ey(αRβ)iff(∃s(cid:7) ∈ S)(s →y s(cid:7) and (∃π ∈ Π(s(cid:7)))(∃m (cid:3) 0)[Md , π(m) |= β and (∀j < m)Md , π(j ) |= α]),(∃s(cid:7) ∈ S)(s →y s(cid:7) and (∃π ∈ Π(s(cid:7)))(∀m (cid:3) 0)[Md , π(m) |= β or (∃j < m)Md , π(j ) |= α]),i s(cid:7) and s(cid:7) |= α),(∃s(cid:7) ∈ S)(s ∼dΓ s(cid:7) and s(cid:7) |= α),(∃s(cid:7) ∈ S)(s ∼DΓ s(cid:7) and s(cid:7) |= α),(∃s(cid:7) ∈ S)(s ∼EΓ s(cid:7) and s(cid:7) |= α).(∃s(cid:7) ∈ S)(s ∼CMd , s |= KiαMd , s |= DΓ αMd , s |= EΓ αMd , s |= CΓ αAn ECTLKy formula ϕ is valid on Md (denoted Md |= ϕ) iff Md , s0 |= ϕ, i.e., ϕ is true at the initial state of theiffiffiffiffmodel Md .Having defined syntax and semantics of the ECTLKy logic, we can now introduce the translation mentioned above.A TECTLK formula ϕ is translated inductively into the ECTLKy formula cr(ϕ) as follows:• cr(p) = p if p ∈ PV (cid:7),• cr(¬p) = ¬p if p ∈ PV (cid:7),• cr(α ∨ β) = cr(α) ∨ cr(β),• cr(α ∧ β) = cr(α) ∧ cr(β),• cr(Kiα) = Ki cr(α),• cr(DΓ α) = DΓ cr(α),• cr(EΓ α) = EΓ cr(α),• cr(CΓ α) = CΓ cr(α),• cr(E(αUIi β)) = Ey(cr(α)U(cr(β) ∧ py∈Ii• cr(E(αRIi β)) = Ey(cr(α)R(cr(β) ∨ ¬py∈Ii∧ (pb ∨ cr(α)))),∨ (¬pb ∧ cr(α)))).The translation of the propositional variables and their negations as well as conjunctions and disjunctions is intuitive.Notice that the formula Ey(cr(α)U(cr(β) ∧ py∈Ii∧ (pb ∨ cr(α)))) expresses the following conditions:1024A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038(a) there exists a path π = (s0, s1, . . .) in the discretised interpreted system for T Aϕ that starts at a state with thevalue of the clock y equal to zero; this statement is expressed by using the quantifier Ey in cr(E(αUI β));(b) there exists a state si = (l, v) on π such that v(y) ∈ I and the translation of β holds in the state; this is expressedby the requirement cr(β) ∧ py∈I ;(c) the translation of α holds in all the states sj on the path π , for j < i; this is expressed by employing the standarduntil operator, i.e., cr(α)U(cr(β) ∧ py∈I ∧ (pb ∨ cr(α))),Regarding the conjunct pb ∨ cr(α) notice that we have to take into consideration the shape of a region in whichcr(β) holds. Namely, if this region is not boundary, then its borders are open, and therefore each state belongingto the region has some time predecessors that also belong to the same region. Thus, if we require that E(αUI β)holds, then cr(α) must hold continuously until cr(β) and cr(α) must hold at all the states of the region wherecr(β) holds; this is expressed by the condition pb ∨ cr(α) put in conjunction with cr(β) ∧ py∈I .Note that the translation for cr(E(αRI β)) is the dual of the one for cr(E(αUI β)).The following lemma shows that validity of a TECTLK formula ϕ over the real time interpreted system for T Ais equivalent to the validity of the corresponding ECTLKy formula cr(ϕ) over the discretised interpreted system forT Aϕ.Lemma 6. M |= ϕ iff Md |= cr(ϕ), for each TECTLK formula ϕ.Proof. The proof follows directly from lemma on correctness of the labelling algorithm of [1] and Theorem 4.1 of[33] for TECTL fragment of TECTLK, and from the definition of the relation ∼i for the epistemic fragment ofTECTLK. (cid:2)In the following we present a BMC method for ECTLKy over discretised interpreted systems. This, paired withthe translation just shown, gives a BMC method for TECTLK.5.2. ECTLKy bounded model checkingAll the known BMC techniques are based on a notion of satisfaction on finite structures. In particular, BMC forECTLKy is based on the k-bounded satisfaction for ECTLKy , the definition of which we present below.5.2.1. Bounded satisfactionWe start with some auxiliary definitions. Let Md = (Sd , s0, →d , ∼dm, Vd ) be a discretised interpreted sys-tem, and k ∈ N+ a bound. As before, we denote by →T A the subset of →d , where transitions are labelled withelements of Z ∪ {τ }, and by →y the set of transitions resetting the clock y. A k-path π in Md is a finite sequence ofstates (s0, . . . , sk) such that si →T A si+1 for each 0 (cid:2) i < k. We will denote the set of all the k-paths starting at sin Md by Πk(s). Note that this set is a convenient way of representing the k-bounded subtree rooted at s of the treeresulting from unwinding the discretised interpreted system from s (see Fig. 9). A k-path π = (s0, . . . , sk) is a loop ifthere exists 0 (cid:2) l (cid:2) k such that π(k) →T A π(l) (see Fig. 10).1 , . . . , ∼dDefinition 8 (k-model). Let Md = (Sd , s0, →d , ∼da bound. A k-model for Md is a structure Mk = (Sd , s0, Pk, Py, ∼dPy = {(s, s(cid:7)) | s →y s(cid:7) and s, s(cid:7) ∈ Sd }.1 , . . . , ∼dm, Vd ) be a discretised interpreted system, and k ∈ N+m, Vd ), where Pk =Πk(s) and1 , . . . , ∼d(cid:2)s∈SdSatisfaction of the temporal operator EyR on a k-path π in the bounded case depends on whether or not π is aloop. Therefore, we introduce a function loop : Pk → 2N which allows for the identification of the k-paths that areactually loops. This function is defined by loop(π) = {i | 0 (cid:2) i (cid:2) k and π(k) →T A π(i)}, and it returns the set of allthe indices of the states for which there is a transition from the last state of a k-path π . Note that if a k-path is a loop,then it represents an infinite path (see Fig. 10).Now we can define a notion of (bounded) satisfaction for ECTLKy formulae on bounded structures. Let k ∈ N+,Md be a discretised interpreted system, Mk its k-model, and α, β ECTLKy formulae. Mk, s |= α denotes that α istrue at the state s of Mk. The satisfaction relation |= is defined inductively as follows:A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381025Fig. 9. (a) Unwinding of a discretised interpreted system Md from a state s of Md ; (b) Π2(s) for Md .Fig. 10. Two kinds of k-paths.Mk, s |= pMk, s |= ¬pMk, s |= α ∨ βMk, s |= α ∧ βMk, s |= KiαMk, s |= DΓ αMk, s |= EΓ αMk, s |= CΓ αMk, s |= Ey(αUβ)Mk, s |= Ey(αRβ)iffiff p ∈ Vd (s),iff p /∈ Vd (s),iff Mk, s |= α or Mk, s |= β,iff Mk, s |= α and Mk, s |= β,iffiffiffiffiff(∃π ∈ Πk(s0))(∃0 (cid:2) j (cid:2) k)(Mk, π(j ) |= α and s ∼d(∃π ∈ Πk(s0))(∃0 (cid:2) j (cid:2) k)(Mk, π(j ) |= α and s ∼D(∃π ∈ Πk(s0))(∃0 (cid:2) j (cid:2) k)(Mk, π(j ) |= α and s ∼E(∃π ∈ Πk(s0))(∃0 (cid:2) j (cid:2) k)(Mk, π(j ) |= α and s ∼C(∃s(cid:7) ∈ Sd )((s, s(cid:7)) ∈ Py and (∃π ∈ Πk(s(cid:7)))(∃0 (cid:2) j (cid:2) k)(Mk, π(j ) |= β and (∀0 (cid:2) i < j )Mk, π(i) |= α)),(∃s(cid:7) ∈ Sd )((s, s(cid:7)) ∈ Py and (∃π ∈ Πk(s(cid:7)))[(∃0 (cid:2) j (cid:2) k)(Mk, π(j ) |= α and (∀0 (cid:2) i (cid:2) j )Mk, π(i) |= β) or(∀0 (cid:2) j (cid:2) k)(Mk, π(j ) |= β and loop(π) (cid:12)= ∅)]).i π(j )),Γ π(j )),Γ π(j )),Γ π(j )),We use the definition above to interpret ECTLKy on finite structures. Pictorial descriptions for bounded satisfac-tion of ECTLKy formulae are shown in Fig. 11.An ECTLKy formula ϕ is valid on k-model Mk(denoted Md |=k ϕ) iff Mk, s0 |= ϕ, i.e., ϕ is true at the initialstate of the k-model Mk. |Md | denotes the size of Md , i.e., the sum of the elements of the set Sd and the elementsof →d .We can now describe how the model checking problem (Md |= ϕ) can be reduced to the bounded model checkingproblem (Md |=k ϕ).Lemma 7. Let k ∈ N+, Md be a discretised interpreted system, Mk its k-model, and ϕ an ECTLKy formula. Then,for any s in Md , Mk, s |= ϕ implies Md , s |= ϕ.Proof. By straightforward induction on the length of ϕ. (cid:2)Lemma 8. Let Md be a discretised interpreted system, Mk its k-model, k = |Md |, ϕ an ECTLKy formula and s astate of Md . If Md , s |= ϕ, then Mk, s |= ϕ.1026A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038Fig. 11. Examples of satisfaction for ECTLKy formulae on bounded models.Proof. (By induction on the length of ϕ.) The lemma follows directly for the propositional variables and their nega-tions. Next, assume that the hypothesis holds for all the proper sub-formulae of ϕ. If ϕ is equal to either α ∧ β orα ∨ β, then it is easy to check that the lemma holds. Consider ϕ to be of the following forms:(1) ϕ = Ey(αUβ). By the definition of unbounded satisfaction we have that there is a state s(cid:7) in Md such that s →y s(cid:7)and there is a path π ∈ Π(s(cid:7)) such that there exists m > 0 with (Md , π(m) |= β and (∀0 (cid:2) i < m) Md , π(i) |= α).Since the set of states of Md is finite, we have that m (cid:2) k (i.e., m (cid:2) |Md |). Thus, by the inductive assumptionwe have that Mk, π(m) |= β, and Mk, π(i) |= α for all 0 (cid:2) i < m. Now, consider the prefix πk of length k of thepath π . We have that πk ∈ Πk(s(cid:7)). By the definition of the k-model, (s, s(cid:7)) ∈ Py . Therefore, by the definition ofbounded satisfaction we have that Mk, s |= Ey(αUβ).(2) ϕ = Ey(αRβ). By the definition of unbounded satisfaction we have that there is a state s(cid:7) in Md such that s →y s(cid:7)and there is a path π ∈ Π(s(cid:7)) such that (∀m (cid:3) 0)(Md , π(m) |= β or (∃0 (cid:2) i < m)Md , π(i) |= α). This impliesthat either (1) (∀m (cid:3) 0)(Md , π(m) |= β), or (2) (∃i (cid:2) k)(Md , π(i) |= α and (∀j (cid:2) i)(Md , π(j ) |= β)). Let usconsider the following two cases:• Assume that (1) holds. Since the set of state of Md is finite, we have that the path π must be of the followingform (π(0), . . . , π(i − 1))(π(i), . . . , π(k))ω for some i (cid:2) k. Thus, we have that loop(π) (cid:12)= ∅, and that the prefixof π of the length k belongs to Πk(s(cid:7)). Further, by the definition of the k-model we have that (s, s(cid:7)) ∈ Py , andby the inductive assumption we have that Mk, π(m) |= β for all 0 (cid:2) m (cid:2) k. Therefore, by the definition ofbounded satisfaction we have that Mk, s |= Ey(αRβ).• Assume that (2) holds. Since the set of states of Md is finite, we have that i (cid:2) k (i.e., i (cid:2) |Md |). Thus, bythe inductive assumption we have that Mk, π(i) |= α, and Mk, π(j ) |= β for all 0 (cid:2) j (cid:2) i. Now, consider theprefix πk of length k of the path π . It is obvious that πk ∈ Πk(s(cid:7)). Further, by the definition of the k-model,(s, s(cid:7)) ∈ Py . So, by the definition of bounded satisfaction we have that Mk, s |= Ey(αRβ).(3) ϕ = Kiα. By the definition of unbounded satisfaction, there is a state s(cid:7) in Md such that s ∼di s(cid:7) and Md , s(cid:7) |= α.By the inductive assumption, we have that Mk, s(cid:7) |= α. Since s(cid:7) is reachable, it is reachable from s0 in k = |Md |steps at most. Thus, there is a k-path π ∈ Pk(s0) such that π(i) = s(cid:7) for some i (cid:2) k. So, we have Mk, s |= Kiα.(4) ϕ = EΓ α. ϕ = EΓ α =i∈Γ Kiα. Therefore the result follows from the case above for a specific i ∈ Γ , and the(cid:12)basic case for the Boolean connectives.(5) ϕ = DΓ α. Straightforward by definition from the case ϕ = Kiα.(6) ϕ = CΓ α. Note that Md , s |= CΓ α iff Md , s |=(cid:12)i(cid:3)|Md |(EΓ )iα. So, by induction and the former case, we haveMk, s |= CΓ α. (cid:2)The main theorem of this section states that |Md |-bounded satisfaction is equivalent to the unbounded one.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381027Theorem 1. Let Md be a discretised interpreted system Mk its k-model where k = |Md | and ψ an ECTLKy formula.Then, Md |= ψ iff Md |=k ψ.Proof. The proof follows from Lemmas 7 and 8. (cid:2)5.2.2. Submodels of k-modelsThe previous subsection ends with the following conclusion: to check that an ECTLKy formula ψ holds on adiscretised interpreted system Md , it is enough to show that ψ holds on its k-model Mk, for some k (cid:2) |Md |. In thissubsection we show a stronger property. Namely, we prove that ψ holds on Md if and only if ψ holds on a submodelof Mk.Definition 9 (Submodel). A submodel of a k-model Mk = (Sd , s0, Pk, Py, ∼d(S(cid:7), s, P (cid:7)∪ {s}, P (cid:7)ym, V (cid:7)) rooted at state s ∈ Sd , such that P (cid:7)k, P (cid:7)1, . . . , ∼(cid:7)⊆ Py ∩ (S(cid:7) × S(cid:7)), ∼(cid:7)i= ∼i ∩(S(cid:7) × S(cid:7)) for each i ∈ {1, . . . , m}, and V (cid:7) = Vd (cid:4) S(cid:7).⊆ Pk, S(cid:7) = {r ∈ Sd | (∃π ∈ P (cid:7)1 , . . . , ∼dy, ∼(cid:7)km, Vd ) is a tuple M (cid:7)(s) =k)(∃i (cid:2) k)π(i) = r}Satisfaction for ECTLKy over a submodel M (cid:7)(s) is defined as for Mk.We now introduce a definition of a function fk that gives a bound on the number of k-paths in the submodel M (cid:7)(s),y in the submodel M (cid:7)(s). We will showand a function fy that gives a bound on the number of elements of the set P (cid:7)later that the validity of ψ in Mk is equivalent to the validity of ψ in M (cid:7)(s) provided that the bound k is chosenappropriately considering fk and fy , where these are given below.The function fk : WF → N is defined by:• fk(p) = fk(¬p) = 0, where p ∈ PV (cid:7),• fk(α ∨ β) = max{fk(α), fk(β)},• fk(α ∧ β) = fk(α) + fk(β),• fk(Ey(αUβ)) = k · fk(α) + fk(β) + 1,• fk(Ey(αRβ)) = (k + 1) · fk(β) + fk(α) + 1,• fk(Y α) = fk(α) + 1, for Y ∈ {Ki, DΓ , EΓ },• fk(CΓ α) = fk(α) + k.The function fy : WF → N is defined by:• fy(p) = fy(¬p) = 0, where p ∈ PV (cid:7),• fy(α ∨ β) = max{fy(α), fy(β)},• fy(α ∧ β) = fy(α) + fy(β),• fy(Ey(αUβ)) = k · fy(α) + fy(β) + 1,• fy(Ey(αRβ)) = (k + 1) · fy(β) + fy(α) + 1,• fy(Y α) = fk(α), for Y ∈ {Ki, DΓ , EΓ , CΓ }.Lemma 9. Let M (cid:7)(s) and M (cid:7)(cid:7)(s) be two submodels of Mk with P (cid:7)kM (cid:7)(s) |=k ψ, then M (cid:7)(cid:7)(s) |=k ψ.Proof. By straightforward induction on the length of ψ. (cid:2)⊆ P (cid:7)(cid:7)k , P (cid:7)y⊆ P (cid:7)(cid:7)y , and ψ an ECTLKy formula. IfThe lemma below shows that the validity of ψ in Mk is equivalent to the validity of ψ in M (cid:7)(s) provided that thebound k is chosen by means of fk and fy functions.Lemma 10. Mk, s |= ψ iff there is a submodel M (cid:7)(s) of Mk with |P (cid:7)ks |= ψ.| (cid:2) fk(ψ) and |P (cid:7)y| (cid:2) fy(ψ) such that M (cid:7)(s),Proof. The implication from right to left is straightforward. To prove the implication left to right, we will use inductionon the length of ψ.1028A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038The “left-to-right” implication follows directly for the propositional variables and their negations. Consider thefollowing cases:yy| (cid:2) fy(α), or there is a submodel M (cid:7)(cid:7)(s) of Mk such that M (cid:7)(cid:7)(s), s |= β and |P (cid:7)(cid:7)k• Let ψ = α ∨ β and Mk, s |= α ∨ β. By the definition of bounded satisfaction we have that Mk, s |= α or Mk, s |= β.Hence, by induction we have that either there is a submodel M (cid:7)(s) of Mk such that M (cid:7)(s), s |= α and |P (cid:7)| (cid:2) fk(α),k| (cid:2) fk(β) and |P (cid:7)(cid:7)|P (cid:7)| (cid:2) fy(β).yyNow, consider a submodel M (cid:7)(cid:7)(cid:7)(s) of Mk such that:= P (cid:7)◦ P (cid:7)(cid:7)(cid:7)k◦ P (cid:7)(cid:7)(cid:7)= P (cid:7)(cid:7)kThus, |P (cid:7)(cid:7)(cid:7)ks |= β. Therefore, by the definition of bounded satisfaction we have that M (cid:7)(cid:7)(cid:7)(s), s |= α ∨ β.k and P (cid:7)(cid:7)(cid:7)k and P (cid:7)(cid:7)(cid:7)| (cid:2) max{fk(α), fk(β)} and |P (cid:7)(cid:7)(cid:7)y| (cid:2) max{fy(α), fy(β)}. It is obvious that M (cid:7)(cid:7)(cid:7)(s), s |= α or M (cid:7)(cid:7)(cid:7)(s),y if M (cid:7)(s), s |= α,y otherwise.= P (cid:7)= P (cid:7)(cid:7)• Let ψ = α ∧ β and Mk, s |= α ∧ β. By the definition of bounded satisfaction we have that Mk, s |= α and Mk,s |= β. Hence, by induction we have that there is a submodel M (cid:7)(s) of Mk such that M (cid:7)(s), s |= α and |P (cid:7)| (cid:2)k| (cid:2) fy(α), and there is a submodel M (cid:7)(cid:7)(s) of Mk such that M (cid:7)(cid:7)(s), s |= β and |P (cid:7)(cid:7)fk(α) and |P (cid:7)| (cid:2) fk(β) andyk∪ P (cid:7)(cid:7)|P (cid:7)(cid:7)∪ P (cid:7)(cid:7)= P (cid:7)y . It is easyyyto observe that |P (cid:7)(cid:7)(cid:7)| (cid:2) fy(α) + fy(β). So, by Lemma 9, we have that M (cid:7)(cid:7)(cid:7)(s), s |= αkand M (cid:7)(cid:7)(cid:7)(s), s |= β. Therefore, by the definition of bounded satisfaction we have that M (cid:7)(cid:7)(cid:7)(s), s |= α ∧ β.| (cid:2) fy(β). Now, consider the submodel M (cid:7)(cid:7)(cid:7)(s) of Mk such that P (cid:7)(cid:7)(cid:7)k| (cid:2) fk(α) + fk(β) and |P (cid:7)(cid:7)(cid:7)y• Let ψ = Ey(αUβ) and Mk, s |= Ey(αUβ). By the definition, there is a state s(cid:7) ∈ Sd such that (s, s(cid:7)) ∈ Py andk and P (cid:7)(cid:7)(cid:7)= P (cid:7)kythere is a k-path π ∈ Πk(s(cid:7)) such that(∃0 (cid:2) m (cid:2) k)(Mk, π(m) |= β and (∀0 (cid:2) i < m)Mk, π(i) |= α).(1)Hence, by the inductive assumption, for all i such that 0 (cid:2) i < m there are submodels M i(π(i)) of Mk with|P ik| (cid:2) fk(α) and |P iy| (cid:2) fy(α) and, π(i) |= α,(2)and there is a submodel M m(π(m)) of Mk with |P mk| (cid:2) fk(β) and |P my| (cid:2) fy(β) andM m, π(m) |= β.Consider a submodel M (cid:7)(s) of Mk such that P (cid:7)kconstruction of M (cid:7)(s), we have that (s, s(cid:7)) ∈ P (cid:7)by the definition of bounded satisfaction, we have that M (cid:7), s |= Ey(αUβ) and |P (cid:7)k|P (cid:7)y(3)∪ {(s, s(cid:7))}. Thus, by themmi=0 P ii=0 P iyky and π ∈ P (cid:7)k. Therefore, since conditions (1), (2), and (3) hold,| (cid:2) k · fk(α) + fk(β) + 1 and| (cid:2) k · fy(α) + fy(β) + 1.• Let ψ = Ey(αRβ) and Mk, s |= Ey(αRβ). By the definition, there is a state s(cid:7) ∈ Sd such that (s, s(cid:7)) ∈ Py and there∪ {π} and P (cid:7)y(cid:2)(cid:2)==is a k-path π ∈ Πk(s(cid:7)) such that(∃0 (cid:2) j (cid:2) k)(Mk, π(j ) |= α and (∀0 (cid:2) i (cid:2) j )Mk, π(i) |= β)(∀0 (cid:2) j (cid:2) k)(Mk, π(j ) |= β and loop(π) (cid:12)= ∅).or(4)(5)Let us consider the two cases. First, assume that condition (4) holds. Then, by the inductive assumption, for all isuch that 0 (cid:2) i (cid:2) j there are submodels M i(π(i)) of Mk with |P ik| (cid:2) fk(β) and |P iy| (cid:2) fy(β) and(cid:14)(cid:13)π(i)M i(cid:14)(cid:13)π(m)(cid:14)(cid:13)π(i)M i, π(i) |= β,and there is a submodel M(cid:7)(cid:7)(cid:14)(cid:13)π(m)M, π(m) |= α.(cid:7)(cid:7)(cid:7)(cid:7)(π(m)) of Mk with |Pk(cid:7)(cid:7)| (cid:2) fk(α) and |Py| (cid:2) fy(α) and(cid:2)Consider the submodel M (cid:7)(s) of Mk such that P (cid:7)ji=0 P ikkThus, by the construction of M (cid:7)(s), we have that (s, s(cid:7)) ∈ P (cid:7)(6) and (7) hold, by the definition of bounded satisfaction we have that M (cid:7)(s), s |= Ey(αRβ) and |P (cid:7)kfk(β) + fk(α) + 1 and |P (cid:7)yAssume now that condition (5) holds. Then, by the inductive assumption, for all j such that 0 (cid:2) j (cid:2) k there aresubmodels M j (π(j )) of Mk with |P jk(cid:2)j∪ {(s, s(cid:7))}.i=0 P iyk. Therefore, since the conditions (4),| (cid:2) (k + 1) ·| (cid:2) (k + 1) · fy(β) + fy(α) + 1.| (cid:2) fk(β) and |P j∪ {π} and P (cid:7)yy and π ∈ P (cid:7)y | (cid:2) fy(β) and∪ P (cid:7)(cid:7)k∪ P (cid:7)(cid:7)y==(6)(7)A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038(cid:13)M j(cid:14)(cid:13), π(j ) |= βπ(j )(cid:14).1029(8)(cid:2)(cid:2)Consider the submodel M (cid:7)(s) of Mk such that P (cid:7)kconstruction of M (cid:7)(s), we have that (s, s(cid:7)) ∈ P (cid:7)definition of bounded satisfaction we have that M (cid:7)(s), s |= Ey(αRβ) and |P (cid:7)k|P (cid:7)y| (cid:2) (k + 1) · fy(β) + fy(α) + 1.=y and π ∈ P (cid:7)∪ {(s, s(cid:7))}. Thus, by theki=0 P iyk. Therefore, since conditions (4) and (8) hold, by the| (cid:2) (k + 1) · fk(β) + fk(α) + 1 and∪ {π} and P (cid:7)yj =0 P j=kk• Let ψ = Kiα and Mk, s |= Kiα. By the definition, we have that there exists π ∈ Πk(s0) such that(cid:13)s ∼i π(j ) and π(j ) |= α(∃0 (cid:2) j (cid:2) k)(cid:14).(9)By the inductive assumption there is a submodel M (cid:7)(π(j )) of Mk with |P (cid:7)| (cid:2) fk(α) and |P (cid:7)| (cid:2) fy(α) such thatykM (cid:7)(π(j )), π(j ) |= α. Consider a submodel M (cid:7)(cid:7)(s) of Mk such that P (cid:7)(cid:7)y . Since π ∈ P (cid:7)(cid:7)= P (cid:7)= P (cid:7)∪ {π} and P (cid:7)(cid:7)k ,ykks ∈ S(cid:7)(cid:7), and condition (9) holds, by the construction of M (cid:7)(cid:7)(s) and the definition of bounded satisfaction, we havethat M (cid:7)(cid:7), s |= Kiα and |P (cid:7)(cid:7)k| (cid:2) fk(α) + 1 and |P (cid:7)(cid:7)y• Let ψ = EΓ α and Mk, s |= EΓ α. By the definition, we have that there exists π ∈ Πk(s0) such that| (cid:2) fy(α).(cid:13)Mk, π(j ) |= α and s ∼E(∃0 (cid:2) j (cid:2) k)(cid:14).Γ π(j )(10)By the inductive assumption there is a submodel M (cid:7)(π(j )) of Mk with |P (cid:7)| (cid:2) fk(α) and |P (cid:7)| (cid:2) fy(α) such thatyky . Since π ∈ P (cid:7)(cid:7)= P (cid:7)M (cid:7)(π(j )), π(j ) |= α. Consider a submodel M (cid:7)(cid:7)(s) of Mk such that P (cid:7)(cid:7)= P (cid:7)∪ {π} and P (cid:7)(cid:7)k ,ykks ∈ S(cid:7)(cid:7), and condition (10) holds, by the construction of M (cid:7)(cid:7)(s) and the definition of bounded satisfaction, we havethat M (cid:7)(cid:7)(s), s |= EΓ α and |P (cid:7)(cid:7)| (cid:2) fy(α).k| (cid:2) fk(α) + 1 and |P (cid:7)(cid:7)y• Let ψ = DΓ α. This case can be proven similarly to the two above.• Let ψ = CΓ α and Mk, s |= CΓ α. Below, we only prove that fk(CΓ α) = fk(α) + k is a sufficient number of pathsin a submodel M (cid:7)(s) validating ϕ and that fy(CΓ α) = fy(α). The actual construction of M (cid:7)(s) can be givensimilarly to the case ψ = Kiα and ψ = α ∨ β.Note that CΓ α =1(cid:3)i(cid:3)k(EΓ )iα, fk((EΓ )1α) = fk(EΓ α) = fk(α) + 1, and fy((EΓ )1α) = fy(EΓ α) = fy(α).It is easy to show, by induction on i, that fk((EΓ )iα) = fk(α) + i and fy((EΓ )iα) = fy(α), for i ∈ {1, . . . , k}.Therefore, fk(ψ) = fk(1(cid:3)i(cid:3)k(EΓ )iα) = max{fk((EΓ )1α), . . . , fk((EΓ )kα)} = fk((EΓ )kα) = fk(α) + k, andfy(ψ) = fy(1(cid:3)i(cid:3)k(EΓ )iα) = max{fy((EΓ )1α), . . . , fy((EΓ )kα)} = fy((EΓ )kα) = fy(α). (cid:2)(cid:12)(cid:12)(cid:12)From Lemma 10 we can now derive the following.Corollary 1. Mk, s0 |= ψ iff there is a submodel M (cid:7)(s0) of Mk with |P (cid:7)kM (cid:7)(s0), s0 |= ψ.| (cid:2) fk(ψ) and |P (cid:7)y| (cid:2) fy(ψ) such thatProof. It follows from the definition of bounded satisfaction and Lemma 10, by using s = s0. (cid:2)Theorem 2. Let Md be a discretised interpreted system, Mk its k-model, ψ an ECTLKy formula, and k = |Md |.Then, Md |= ψ iff there exists submodel M (cid:7)(s0) of Mk with P (cid:7)k| (cid:2) fy(ψ) such that M (cid:7)(s0) |=k ψ.(cid:2) fk(ψ) and |P (cid:7)yProof. Follows from Theorem 1 and Corollary 1. (cid:2)5.2.3. Translation to Boolean formulaeAs it was mentioned before, the main idea of BMC for ECTLKy consists in translating the model checkingproblem for ECTLKy into the problem of satisfiability of a propositional formula. Given an ECTLKy formula ψ anda discretised interpreted system Md , this propositional formula is of the following form:(cid:16)(cid:15)M ψ,s0d∧ [ψ]Mk .[Md , ψ]k =k(11)The first conjunct of [Md , ψ]k represents all the possible submodels of Md which consist of fk(ψ) k-paths of Md ,whereas the second conjunct encodes a number of constraints that must be satisfied on the ‘fk(ψ)-submodels’ of Mdfor ψ to be satisfied. Once this translation is defined, checking satisfiability of an ECTLKy formula can be done bymeans of a SAT-checker. In order to define the formula [Md , ψ]k, we proceed as follows.1030A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038Let us assume that each state s of the discretised interpreted system Md is encoded by a bit-vector whose length,say b, depends on the number of locations, the number of clocks, the discretisation step, and cmax(ϕ). So, each states of Md can be represented by a vector w = (w[1], . . . , w[b]) (called global state variable), where each w[i], fori = 1, . . . , b, is a propositional variable (called state variable). Notice that we distinguish between states s encodedas sequences of 0’s and 1’s and their representations in terms of propositional variables w[i]. A finite sequence(w0, . . . , wk) of global state variables is called a symbolic k-path. In general, we need to consider not just one buta number of symbolic k-paths. This number depends on the formula ψ under investigation, and it is returned as thevalue fk(ψ) of the function fk. The j th symbolic k-path is denoted by w0,j , . . . , wk,j , where wi,j are global statevariables for 1 (cid:2) j (cid:2) fk(ψ), 0 (cid:2) i (cid:2) k. For two global state variables w, w(cid:7), we define the following propositionalformulae:• Is(w) is a formula over w, which is true for a valuation sw of w iff sw = s.• p(w) is a formula over w, which is true for a valuation sw of w iff p ∈ Vd (sw), where p ∈ PV (cid:7),• Hi(w, w(cid:7)) is a formula over two global state variables w = (l, v), w(cid:7) = (l(cid:7), v(cid:7)), which is true for valuations sl of l,sl(cid:7) of l(cid:7), sv of v, and sv(cid:7) of v(cid:7) iff li(sl) = li(sl(cid:7)) and sv (cid:18) sv(cid:7) (encodes equivalence of local states of agent i).• R(w, w(cid:7)) is a formula over w, w(cid:7), which is true for two valuations sw of w and sw(cid:7) of w(cid:7) iff sw →T A sw(cid:7) (encodesthe non-resetting transition relation of Md ),• Ry(w, w(cid:7)) is a formula over w, w(cid:7), which is true for two valuations sw of w and sw(cid:7) of w(cid:7) iff sw →y sw(cid:7) (encodesthe transitions resetting the clock y).The propositional formula [Md , ψ]k is defined over state variables w0,0, wn,m, for 0 (cid:2) m (cid:2) k and 1 (cid:2) n (cid:2) fk(ψ).]k, which constrains the fk(ψ) sym-We start off with the definition of its first conjunct, i.e., the definition of [M ψ,s0bolic k-paths to be valid k-path of Mk. Namely,d(cid:15)M ψ,s0d(cid:16)k:= Is0(w0,0) ∧fk(ψ)(cid:5)k−1(cid:5)n=1m=0R(wm,n, wm+1,n).The second conjunct, i.e., the formula [ψ]Mk= [ψ][0,0]k, is inductively defined as follows::= p(wm,n),[p][m,n]k[¬p][m,n]k[α ∧ β][m,n][α ∨ β][m,n]kkEy(αUβ):= ¬p(wm,n),:= [α][m,n]k:= [α][m,n]kfk(ψ)(cid:17)(cid:16)[m,n]k:=∧ [β][m,n]k∨ [β][m,n]k(cid:18),,(cid:15)(cid:15)Ey(αRβ)(cid:16)[m,n]ki=1fk(ψ)(cid:17)(cid:18):=j =0(cid:18)k(cid:17)Ry(wm,n, w0,i)∧(cid:18)(cid:18)k(cid:17)Ry(wm,n, w0,i) ∧[β][j,i]k∧(cid:19)(cid:19)[α][l,i]k,j −1(cid:5)l=0(cid:19)j(cid:5)l=0[β][l,i]k[α][j,i]k∧(cid:19)(cid:19)j =0R(wk,i, wl,i),i=1k(cid:5)j =0∨(cid:18)[β][j,i]k∧k(cid:17)l=0fk(ψ)(cid:17)[Klα][m,n]k:=[DΓ α][m,n]k:=i=1fk(ψ)(cid:17)(cid:18)i=1Is0(w0,i) ∧(cid:13)[α][j,i]k(cid:14)∧ Hl(wm,n, wj,i)k(cid:17)j =0Is0(w0,i) ∧(cid:20)k(cid:17)j =0[α][j,i]k∧(cid:5)l∈Γ(cid:21)(cid:19),Hl(wm,n, wj,i)(cid:19),A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381031[EΓ α][m,n]k:=fk(ψ)(cid:17)(cid:18)Is0(w0,i) ∧(cid:20)k(cid:17)[CΓ α][m,n]k:=i=1(cid:22)k(cid:17)j =0(cid:23)[m,n](EΓ )iα.i=1k(cid:21)(cid:19),Hl(wm,n, wj,i)[α][j,i]k∧(cid:17)l∈ΓThis fully defines the encoding of formula (11).Now we show that the validity of an ECTLKy formula ψ on a submodel M (cid:7)(s), defined by using the functionsfk and fy , is equivalent to the satisfiability of formula (11). Once we have shown this fact, we can conclude that thevalidity of ψ on the discretised interpreted system Md is equivalent to the satisfiability of formula (11) (see Theorem 3below). Further, by taking into account Lemma 6 we can claim that the validity of a TECTLK formula ϕ over the realtime interpreted system for T A is equivalent to the satisfiability of formula (11); note that this propositional formulaencodes the translation of the ECTLKy formula cr(ϕ) over the discretised interpreted system for T Aϕ.Lemma 11. Let Md be discretised interpreted system, Mk its k-model, and ψ an ECTLKy formula. For each state sof Md , the following holds: [M ψ,s| (cid:2) fk(ψ) and|P (cid:7)y]k ∧ [ψ]Mk is satisfiable iff there is a submodel M (cid:7)(s) of Mk with |P (cid:7)| (cid:2) fy(ψ) such that M (cid:7)(s), s |= ψ.dkdProof. (⇒) Let [M ψ,s]k ∧ [ψ]Mk be satisfiable. By the definition of the translation, the propositional formula [ψ]Mkencodes all the sets of k-paths of size fk(ψ) which satisfy the formula ψ and all the sets of transitions resetting theclock y of size fy(ψ) . By the definition of the unfolding of the transition relation, the propositional formula [M ψ,s]kencodes fk(ψ) symbolic k-paths to be valid k-paths of Mk. Hence, there is a set of k-paths in Mk, which satisfies theformula ψ of size smaller or equal to fk(ψ), and there is a set of transitions resetting the clock y of size fy(ψ). Thus,we conclude that there is a submodel M (cid:7)(s) of Mk with |P (cid:7)k(⇐) The proof is by induction on the length of ψ. The lemma follows directly for the propositional variables and| (cid:2) fy(ψ) such that M (cid:7)(s), s |= ψ.| (cid:2) fk(ψ) and |P (cid:7)ytheir negations. Consider the following cases:(A) For ψ = α ∨ β, α ∧ β, or the temporal operators the proof is like in [24].(B) Let ψ = Klα. Let M (cid:7)(s), s |= Klα with |P (cid:7)k| (cid:2) fy(Klα). By definition of bounded satisfactionl π(j )) and M (cid:7)(s), π(j ) |= α. Hence, bywe have that there is a k-path π such that π(0) = s0 and (∃j (cid:2) k)s ∼dinduction we obtain that for some j (cid:2) k the propositional formula [α][0,0]∧ [M α,π(j )]k is satisfiable. Let ii =fk(α) + 1 be the index of a new symbolic k-path which satisfies the formulae Is0(w0,ii) and Hl(w0,0, wj,ii) forsome j ∈ {1, . . . , k}. Therefore, by the construction above, it follows that the propositional formula Is0(w0,ii) ∧(cid:12)k∧ Hl(w0,0, wj,ii)) ∧ [M Kl α,s]k is satisfiable. Therefore, the following propositional formula is| (cid:2) fk(Klα) and |P (cid:7)yj =0([α][j,ii]kksatisfiable:(cid:17)1(cid:3)i(cid:3)fk(Kl α)(cid:18)Is0(w0,i) ∧k(cid:17)j =0(cid:13)[α][j,i]k(cid:14)∧ Hl(w0,0, wj,i)(cid:19)∧ [M Kl α,s]k.kHence, by the definition of the translation of an ECTLKy formula, the above formula is equal to the propositionalformula [Klα][0,0]∧ [M Kl α,s]k.| (cid:2) fk(EΓ α) and |P (cid:7)y(C) Let ψ = EΓ α. Let M (cid:7)(s), s |= EΓ α with |P (cid:7)k| (cid:2) fy(EΓ α). By definition of bounded satisfac-Γ π(j )) and M (cid:7)(s), π(j ) |= α. Hence,tion we have that there is a k-path π such that π(0) = s0 and (∃j (cid:2) k)s ∼Eby induction we obtain that for some j (cid:2) k the propositional formula [α][0,0]∧ [M α,π(j )]k is satisfiable. Letii = fk(α) + 1 be the index of a new symbolic k-path which satisfies the formulae Is0(w0,ii) and Hl(w0,0, wj,ii)for some j ∈ {1, . . . , k} and l ∈ Γ . Therefore, by the construction above, it follows that the propositional formulaj =0([α][j,ii]Is0(w0,ii) ∧l∈Γ Hl(w0,0, wj,ii)) ∧ [M EΓ α,s]k is satisfiable. Therefore, the following proposi-∧tional formula is satisfiable:(cid:18)(cid:12)(cid:12)(cid:19)kkk(cid:21)(cid:17)Is0(w0,i) ∧1(cid:3)i(cid:3)fk(EΓ α)j =0k(cid:17)(cid:20)[α][j,i]k∧(cid:17)l∈ΓHl(w0,0, wj,i)∧ [M EΓ α,s]k.1032A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038kHence, by the definition of the translation of an ECTLKy formula, the above formula is equal to the propositionalformula [EΓ α][0,0]∧ [M EΓ α,s]k.| (cid:2) fk(DΓ α) and |P (cid:7)y(D) Let ψ = DΓ α. Let M (cid:7)(s), s |= DΓ α with |P (cid:7)k| (cid:2) fy(DΓ α). By definition of bounded sat-Γ π(j )) and M (cid:7)(s), π(j ) |= α.isfaction we have that there is a k-path π such that π(0) = s0 and (∃j (cid:2) k)s ∼DHence, by induction we obtain that for some j (cid:2) k the propositional formula [α][0,0]∧ [M α,π(j )]k is satisfi-able. Let ii = fk(α) + 1 be the index of a new symbolic k-path which satisfies the formulae Is0(w0,ii) andHl(w0,0, wj,ii) for some j ∈ {1, . . . , k} and for all l ∈ Γ . Therefore, by the construction above, it follows that thej =0([α][j,ii]propositional formula Is0(w0,ii) ∧l∈Γ Hl(w0,0, wj,ii)) ∧ [M DΓ α,s]k is satisfiable. Therefore,the following propositional formula is satisfiable:(cid:12)k(cid:4)∧kk(cid:18)(cid:17)1(cid:3)i(cid:3)fk(DΓ α)Is0(w0,i) ∧(cid:20)k(cid:17)j =0[α][j,i]k∧(cid:5)l∈Γ(cid:21)(cid:19)Hl(w0,0, wj,i)∧ [M DΓ α,s]k.Hence, by the definition of the translation of an ECTLKy formula, the above formula is equal to the propositionalformula [DΓ α][0,0]∧ [M DΓ α,s]k.k(cid:12)ki=1(E)iα and by a simple induction on i and(E) Let ψ = CΓ α. This can be shown by noting that CΓ α =case C. (cid:2)Theorem 3. Let Md be a discretised interpreted system, and ψ an ECTLKy formula. Then, Md |= ψ iff there existsk ∈ N+ such that [ψ]Mk∧ [M ψ,s0 ]k is satisfiable.Proof. It follows from Theorem 2 and Lemma 11. (cid:2)6. Railroad crossing systemTo exemplify the use of the techniques of this paper we verify an extension of the railroad crossing system (RCS)[17], a well-known example in the literature of real time verification. In the following we not only verify temporalproperties, as it is customary in reactive systems, but a specification that includes epistemic concepts too. The sys-tem consists of three agents: Train, Gate, and Controller running in parallel and synchronising through the events:approach, exit, lower and raise (see Fig. 2). When a train approaches the crossing, Train sends an approach signalto Controller and enters the crossing between 300 and 500 milliseconds (ms) from this event. When Train leaves thecrossing, it sends an exit signal to Controller. Controller sends a signal lower to Gate exactly 100 ms after the approachsignal is received, and sends a raise signal within 100 ms after exit. Gate performs the transition down within 100 msof receiving the request lower, and responds to raise by moving up between 100 ms and 200 ms.To model the scenario we assume the following set of propositions: PV = {p, q} with PV Train = {p}, and PV Gate ={q}, and denote by L1, L2, L3 sets of locations for Train, Gate, and Controller, respectively. The valuation functions forTrain (VTrain), Gate (VGate), and Controller (VCont) are shown in Fig. 2. The valuation function VRCS : L1 × L2 × L3 →2PV for the parallel composition, i.e., RCS system, is defined by VRCS(l) = VTrain(l1) ∪ VGate(l2) ∪ VCont(l3), for alll = (l1, l2, l3) ∈ L1 × L2 × L3.In addition to verifying standard specifications based on temporal properties of the system, we can now check avariety of temporal epistemic properties. For instance we could check specifications formalising that:• There exists a behaviour of RCS such that agent Train considers possible a situation in which it sends an approachsignal but agent Gate does not send the signal down within 50 milliseconds.• There exists a behaviour of RCS such that agent Controller considers possible a situation in which it sends a lowersignal but agent Gate does not send the signal down within 50 milliseconds.• There exists a behaviour of RCS such that agent Train considers possible a situation in which it sends an approachsignal and agent Controller sends a lower signal within 10 milliseconds but still agent Gate does not send the signaldown within 50 milliseconds.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381033In the following, as an example, we verify the first property above. This can be formalised by the following TECTLKformula:ϕ := EF[0,∞]KTrain(cid:13)(cid:14)p ∧ EF[0,50](¬q).According to the BMC algorithm for TECTLK, presented in the previous section, to perform BMC for the RCSsystem against property ϕ, all the states of the discretised interpreted system Md for RCS with the additional clock yhave to be represented as bit vectors first. To do this we have to encode all the possible configurations in terms of boththe locations, and the clock valuations of the RCS system.Assume that we have the following bit representation for local locations. For Train we take t0 = (0, 0), t1 = (0, 1),t2 = (1, 0), and t3 = (1, 1); for Gate g0 = (0, 0), g1 = (0, 1), g2 = (1, 0), and g3 = (1, 1); for Controller c0 = (0, 0),c1 = (0, 1), c2 = (1, 0), and c3 = (1, 1). So, the (global) locations of the RCS system have the following encoding:t1 × g0 × c1 = (0, 1; 0, 0; 0, 1), t1 × g0 × c1 = (0, 1; 0, 0; 0, 1), t1 × g1 × c2 = (0, 1; 0, 1; 1, 0), etc. In other words weneed 6 state variables (l[0], . . . , l[5]) to encode all the possible configuration of locations of the RCS system.8 , 78 , 58 , 38 , 48 , 68 , 2In order to encode the clock valuations of significance for RCS, we have to encode the valuations in D = {k · Δ |8 , 1, . . . , 1002} for the clocks: x1, x2, x3, y by means of the discretisation0 (cid:2) k · Δ (cid:2) 1002} = {0, 18 , and cmax(ϕ) = 500. Note that to do this, it is sufficient to encode the integral parts of the valuations andstep Δ = 1the numerators of the fractional parts. Since the largest integral value is 1002 and the largest value of the numeratorsis 8, it is enough to take 10 + 3 state variables to encode these values for one clock; this is because 210 = 1024 and23 = 8. Therefore, we need 13 state variables to encode all the clock valuations for one clock, and respectively 4 · 13state variables (v[0], . . . , v[51]) to encode all the clock valuations for all 4 clocks. So, a global state variable for theRCS system is w = ((l[0], . . . , l[5]), (v[0], . . . , v[51])) = (w[0], . . . , w[57]).To proceed with the verification of the formula in question, the transition relation of Md has to be translatedinto a Boolean formula and cr(ϕ) = EyF(KTrain(p ∧ EyF(¬q ∧ py∈[0,50] ∧ (pb ∨ (cid:19))) ∧ (pb ∨ (cid:19)))) = EyF(KTrain(p ∧EyF(¬q ∧ py∈[0,50]))) has to be translated considering all the possible fk(cr(ϕ)) = 3 submodels of Md as describedin the previous section.To proceed with the translation of the transition relation of Md , we first consider the initial state s0 =((t0, g0, c0), v0) of RCS, where s0 is represented as a bit vector of 58 consecutive 0’s. With the representation abovethis is encoded by the following propositional formula:Is0(w0,0) =57(cid:5)i=0¬w0,0[i].The next step is to encode the transitions of Md by the formula R(wi,j , wi+1,j ) with j = 1, 2, 3 and i (cid:2) k.As an example we encode here the witness for depth k = 2:(cid:21)(cid:25)(cid:20)(cid:24)(cid:15)(cid:16)(t0, g0, c0), (0, 0, 0, 0)τ−→(t0, g0, c0),14,14,14,14(cid:24)(cid:20)approach−−−−−→(t1, g0, c1),0,(cid:21)(cid:25).14, 0,14The formula encoding the first transition for our witness has the following form:Rrcs(w0,1, w1,1) :=5(cid:5)(cid:13)(cid:14)¬w0,1[i] ∧ ¬w1,1[i]∧i=057(cid:5)i=6¬w0,1[i]∧∧17(cid:5)¬w1,1[i] ∧ w1,1[18] ∧30(cid:5)¬w1,1[i] ∧ w1,1[31]i=643(cid:5)i=32i=1956(cid:5)¬w1,1[i] ∧ w1,1[44] ∧i=45¬w1,1[i] ∧ w1,1[57].(12)The formula encoding the second transition for our witness has the form:Rrcs(w1,1, w2,1) :=5(cid:5)i=0¬w1,1[i] ∧ ¬w2,1[0] ∧ ¬w2,1[2] ∧ ¬w2,1[3]1034A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038∧ ¬w2,1[4] ∧ w2,1[1] ∧ w2,1[5] ∧17(cid:5)i=6¬w1,1[i] ∧ w1,1[18] ∧30(cid:5)i=19¬w1,1[i]∧ w1,1[31] ∧43(cid:5)i=32¬w1,1[i] ∧ w1,1[44] ∧56(cid:5)i=45¬w1,1[i] ∧ w1,1[57]∧30(cid:5)i=6¬w2,1[i] ∧ w2,1[31] ∧56(cid:5)i=32¬w2,1[i] ∧ w2,1[57].(13)Note that in fact formulae (12) and (13) are fragments of the formulae R(w0,1, w1,1) and R(w1,1, w2,1), respec-tively. In order to encode the whole example we should model, in a similar way to the above, all the possible transitionsof Md , and encode them as formulae R(wi,j , wi+1,j ) with j = 1, 2, 3 and i (cid:2) k. This is a process that can be auto-mated.To encode the translation of cr(ϕ), first we need to encode the propositions used in cr(ϕ). For p we have p(w) :=(¬w[0] ∧ w[1]), representing the fact that p holds at all the global states with the first local locations equal to (0, 1).For q we have q(w) := (w[4] ∧ ¬w[5]), representing the fact that q holds at all the global states with the third locallocations equal to (1, 0). To give the translation of the proposition py∈[0,50](w), assume the following definition ofpropositional formulae. For the vectors of state variables a = (a[1], . . . , a[t]) and b = (b[1], . . . , b[t]) we define:• eq(a, b)• ge(a, b)• geq(a, b)• le(a, b)(cid:4)def=ti=1 a[i] ⇔ b[i],(cid:12)def=ti=1(a[i] ∧ ¬b[i] ∧def= eq(a, b) ∨ ge(a, b),def= ¬geq(a, b).(cid:4)tj =i+1 a[j ] ⇔ b[j ]),Then, for 0 := (0, 0, 0, 0, 0, 0, 0, 0, 0, 0), and 50 := (0, 0, 0, 0, 1, 1, 0, 0, 1, 0), we define py∈[0,50](w) as follows:py∈[0,50](w)def= geq(cid:22)(cid:13)(cid:13)(cid:14)w[45], . . . , w[54], 0(cid:14)(cid:13)(cid:13)(cid:14)w[45], . . . , w[54], 50(cid:14)∨∧le(cid:18)eq(cid:13)(cid:13)(cid:14)w[45], . . . , w[54], 50(cid:14)∧(cid:19)(cid:23)¬w[i].57(cid:5)i=55Further, we have to define the formulae Ry(w, v) and Hl(w, v). The formula Ry(w, v) is defined as follows:Ry(w, v) =44(cid:5)j =0(cid:14)(cid:13)w[j ] ↔ v[j ]∧57(cid:5)(cid:13)v[j ] ↔ ⊥(cid:14).j =45(14)Let Idxl be a set of the indexes of the bits of the local states of agent l. Then, the formula Hl(w, v) is defined asfollows:Hl(w, v) =w[i] ⇔ v[i].(15)(cid:5)i∈IdxlIn so doing, it is sufficient to unfold the formula [cr(ϕ)]0,0, for k = 1, 2, . . . , according to the definition onk(cid:15)=(cid:16)0,0cr(ϕ)kpage 1030. Namely,(cid:15)(cid:13)EyFKTrain(cid:15)(cid:13)EyFKTrain(cid:13)(cid:13)(cid:15)(cid:19)UEyKTrain3(cid:17)==(cid:18)(cid:14)(cid:13)¬q ∧ py∈[0,50] ∧ (pb ∨ (cid:19))(cid:13)p ∧ EyF(cid:13)p ∧ EyF(¬q ∧ py∈[0,50])0,0k(cid:13)(cid:14)(cid:14)(cid:14)(cid:16)p ∧ EyF(¬q ∧ py∈[0,50])(cid:14)(cid:14)(cid:16)0,0k=Ry(w0,0, w0,i) ∧i=1k(cid:17)(cid:15)KTrainj =0(cid:13)p ∧ EyF(¬q ∧ py∈[0,50])(cid:14)(cid:16)[j,i]k(cid:19)∧ (pb ∨ (cid:19))(cid:14)(cid:14)(cid:16)0,0kA. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–10381035(cid:18)=Ry(w0,0, w0,1) ∧(cid:18)∨Ry(w0,0, w0,2) ∧(cid:18)∨Ry(w0,0, w0,3) ∧j =0k(cid:17)j =0(cid:18)KTrain(cid:13)p ∧ EyF(¬q ∧ py∈[0,50])(cid:14)(cid:16)[j,1]kk(cid:17)(cid:15)j =0(cid:19)k(cid:17)(cid:15)KTrain(cid:13)p ∧ EyF(¬q ∧ py∈[0,50])(cid:14)(cid:16)[j,2]k(cid:19)(cid:19)(cid:15)KTrain(cid:13)p ∧ EyF(¬q ∧ py∈[0,50])(cid:14)(cid:16)[j,3]k(cid:18)=Ry(w0,0, w0,1) ∧k(cid:17)3(cid:17)(cid:18)Is0(w0,t ) ∧k(cid:17)(cid:13)(cid:15)j =0(cid:19)(cid:19)(cid:19)(cid:14)∧ Hl(wj,1, wl,t )t=1l=0p ∧ EyF(¬q ∧ py∈[0,50])(cid:16)[l,t]kp ∧ EyF(¬q ∧ py∈[0,50])(cid:16)[l,t]k(cid:16)[l,t]k(cid:18)∨Ry(w0,0, w0,2) ∧(cid:18)(cid:18)3(cid:17)k(cid:17)Is0(w0,t ) ∧k(cid:17)(cid:13)(cid:15)j =0(cid:19)(cid:19)(cid:19)(cid:14)∧ Hl(wj,2, wl,t )t=1l=0(cid:18)∨Ry(w0,0, w0,3) ∧(cid:18)(cid:18)3(cid:17)k(cid:17)Is0(w0,t ) ∧k(cid:17)(cid:13)(cid:15)j =0t=1l=0p ∧ EyF(¬q ∧ py∈[0,50])(cid:19)(cid:19)(cid:19)(cid:14)∧ Hl(wj,3, wl,t )(cid:22)=Ry(w0,0, w0,1) ∧(cid:18)k(cid:17)3(cid:17)(cid:18)Is0(w0,t ) ∧k(cid:17)(cid:13)p(wl,t ) ∧(cid:15)EyF(¬q ∧ py∈[0,50])(cid:16)[l,t]kj =0(cid:19)(cid:19)(cid:23)(cid:14)∧ Hl(wj,1, wl,t )t=1(cid:22)l=0∨Ry(w0,0, w0,2) ∧(cid:18)k(cid:17)3(cid:17)(cid:18)Is0(w0,t ) ∧(cid:22)l=0j =0t=1(cid:19)(cid:19)(cid:23)k(cid:17)(cid:13)p(wl,t )∧(cid:15)EyF(¬q ∧ py∈[0,50])(cid:16)[l,t]k(cid:14)∧ Hl(wj,2, wl,t )∨Ry(w0,0, w0,3) ∧k(cid:17)(cid:13)p(wl,t ) ∧∧l=0(cid:22)=Ry(w0,0, w0,1) ∧(cid:15)EyF(¬q ∧ py∈[0,50])(cid:16)[l,t]k(cid:19)(cid:19)(cid:23)(cid:14)∧ Hl(wj,3, wl,t )(cid:18)k(cid:17)3(cid:17)(cid:18)Is0(w0,t ) ∧(cid:18)k(cid:17)j =0t=1l=0p(wl,t ) ∧ Hl(wj,1, wl,t )(cid:19)(cid:19)(cid:19)(cid:19)(cid:19)(cid:23)(cid:18)(cid:18)3(cid:17)∧n=1(cid:22)(cid:18)∧3(cid:17)n=1Ry(wl,t , w0,n) ∧k(cid:17)[¬q ∧ py∈[0,50]][m,n]m=0(cid:18)3(cid:17)k(cid:18)k(cid:17)(cid:18)k(cid:17)∨Ry(w0,0, w0,2) ∧Is0(w0,t ) ∧p(wl,t ) ∧ Hl(wj,2, wl,t )Ry(wl,t , w0,n) ∧[¬q ∧ py∈[0,50]][m,n]kj =0t=1k(cid:17)m=0l=0(cid:19)(cid:19)(cid:19)(cid:19)(cid:23)(cid:18)(cid:18)3(cid:17)k(cid:17)j =0t=1Is0(w0,t )1036A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038(cid:22)∨Ry(w0,0, w0,3) ∧(cid:18)(cid:18)3(cid:17)k(cid:17)j =0t=1Is0(w0,t ) ∧(cid:18)k(cid:17)l=0Ry(wl,t , w0,n) ∧[¬q ∧ py∈[0,50]][m,n]k(cid:17)p(wl,t ) ∧ Hl(wj,3, wl,t )(cid:19)(cid:19)(cid:19)(cid:19)(cid:23)k(cid:18)k(cid:17)(cid:18)k(cid:17)m=0(cid:18)3(cid:17)Is0(w0,t ) ∧j =0t=1l=0=Ry(w0,0, w0,1) ∧p(wl,t ) ∧ Hl(wj,1, wl,t )Ry(wl,t , w0,n) ∧k(cid:17)(cid:13)(cid:14)¬q(wm,n) ∧ py∈[0,50](wm,n)(cid:19)(cid:19)(cid:19)(cid:19)(cid:23)m=0(cid:18)k(cid:17)3(cid:17)(cid:18)Is0(w0,t ) ∧j =0t=1(cid:18)k(cid:17)l=0m=0(cid:18)k(cid:17)3(cid:17)(cid:18)Is0(w0,t ) ∧j =0t=1(cid:18)k(cid:17)l=0∨Ry(w0,0, w0,2) ∧p(wl,t ) ∧ Hl(wj,2, wl,t )Ry(wl,t , w0,n) ∧k(cid:17)(cid:14)(cid:13)¬q(wm,n) ∧ py∈[0,50](wm,n)(cid:19)(cid:19)(cid:19)(cid:19)(cid:23)∨Ry(w0,0, w0,3) ∧p(wl,t ) ∧ Hl(wj,3, wl,t )Ry(wl,t , w0,n) ∧k(cid:17)(cid:13)(cid:14)¬q(wm,n) ∧ py∈[0,50](wm,n)m=0(cid:19)(cid:19)(cid:19)(cid:19)(cid:23).(cid:18)3(cid:17)n=1∧(cid:22)(cid:18)∧3(cid:17)n=1(cid:22)(cid:18)∧3(cid:17)n=1(cid:22)(cid:18)∧3(cid:17)n=1Checking that the RCS system satisfies the TECTLK formula above can now be done by checking the propositionalformula generated by this method with an efficient SAT checker. This would produce a solution, thereby proving thatthe propositional formula is satisfiable.It is worth noting that the logic under analysis in this paper provides for a richer specification language for veri-fication when compared to existing approaches. For instance, in the RCS above we can specify and verify via BMCthe TECTLK specification “there exists a behaviour of RCS such that within 100 milliseconds agent Train consid-ers possible a situation in which it sends an approach signal but agent Gate does not send the signal down within50 milliseconds”, represented by the formula:EF[0,100]KTrain(cid:13)(cid:14)p ∧ EF[0,50](¬q).Other bounded model checking formalisms have been defined for TCTL [25] and CTLK [23]. With TCTL we canverify dense time but not knowledge. So we could check a less expressive property, e.g., “there exists a behaviour ofRCS such that within 100 milliseconds agent Train sends an approach signal but agent Gate does not send the signaldown within 50 milliseconds”, expressible by the TECTL formula:(cid:13)(cid:14)p ∧ EF[0,50](¬q)EF[0,100].Conversely in a bounded model checking framework for CTLK we can express combinations of knowledge andtime but only limited to a discrete model of time. In this weaker language we could for instance verify the specification“there exists a behaviour of RCS such that agent Train considers possible a situation in which it sends an approachsignal but agent Gate does not send the signal down”, expressible by the CTLK formula:EFKTrain(cid:14)(cid:13)p ∧ EF(¬q).Clearly these two options are not as expressive as our original specification. In the first we have no way of referringto agent Train’s knowledge, whereas in the second we cannot make explicit the temporal interval the events should bereferring to.A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–103810377. Related work and conclusionsBMC was initially developed for the verification of reactive systems, and then extended for Multi-Agent Systems[18,23,32]. In particular, BMC has been extended to ACTL(cid:18) [30], TACTL [25], and ACTLKD [32]. These arelogics able to represent not only branching time but also modalities of concern in Artificial Intelligence (individualand group knowledge, and correctness of behaviour with respect to specifications). In separate developments BMChas been explored for real time temporal logic [3,25,33].In this paper we have tried to combine these directions and have developed BMC to a new logic that combinesreal time and knowledge. There is no obstacle to extend the method presented here to handle operators representingcorrect functioning behaviour [19].Combinations of real time and knowledge have been defined previously [7,21] but to our knowledge no verificationmechanism has ever been defined for them. To solve the difficulty of dense time, we have made use of discretisationon equal intervals, already employed in [25,33]. It is worth noting that intervals with explicit length could be alsoused in principle. To do so one would have to encode more information (the maximum value of each clock, differentlengths of bit-vectors that encode the integral parts of values of the clock, etc.), and as a result any implementation ofthe method would suffer in terms of speed.Like every SAT-based approach the size of formulae produced in the translation can be large, as the example of thepaper demonstrates. To evaluate its effectiveness in practical applications, we are currently implementing the methodin view of comparing experimental results. We are encouraged that implementations of other BMC-based tools [18,24,25] showed largely positive results. We are therefore hopeful that the technique of this paper, once implemented,will produce comparably fast results.References[1] R. Alur, C. Courcoubetis, D. Dill, Model checking in dense real-time, Information and Computation 104 (1) (1993) 2–34.[2] R. Alur, D. Dill, Automata for modelling real-time systems, in: Proceedings of the International Colloquium on Automata, Languages andProgramming (ICALP’90), in: LNCS, vol. 443, Springer-Verlag, 1990, pp. 322–335.[3] G. Audemard, A. Cimatti, A. Kornilowicz, R. Sebastiani, Bounded model checking for timed systems, in: Proceedings of the 22nd InternationalConference on Formal Techniques for Networked and Distributed Systems (FORTE’02), in: LNCS, vol. 2529, Springer-Verlag, 2002, pp. 243–259.[4] A. Biere, A. Cimatti, E. Clarke, M. Fujita, Y. Zhu, Symbolic model checking using SAT procedures instead of BDDs, in: Proceedings of theACM/IEEE Design Automation Conference (DAC’99), 1999, pp. 317–320.[5] P. Blackburn, M. de Rijke, Y. Venema, Modal Logic, Cambridge Tracts in Theoretical Computer Science, vol. 53, Cambridge University Press,2001.[6] R.H. Bordini, M. Fisher, C. Pardavila, M. Wooldridge, Model checking AgentSpeak, in: J.S. Rosenschein, T. Sandholm, W. Michael, M.Yokoo (Eds.), Proceedings of the Second International Joint Conference on Autonomous Agents and Multi-agent systems (AAMAS-03),ACM Press, 2003, pp. 409–416.[7] R.I. Brafman, J.C. Latombe, Y. Moses, Y. Shoham, Application of a logic of knowledge to motion planning under uncertainty, Journal of theACM 44 (5) (1997) 633–668.[8] E.M. Clarke, O. Grumberg, D.A. Peled, Model Checking, MIT Press, Cambridge, MA, 1999.[9] R. Fagin, J.Y. Halpern, Y. Moses, M.Y. Vardi, Reasoning about Knowledge, MIT Press, Cambridge, MA, 1995.[10] R. Fagin, J.Y. Halpern, M.Y. Vardi, What can machines know? On the properties of knowledge in distributed systems, Journal of theACM 32 (2) (1992) 328–376.[11] P. Gammie, R. van der Meyden, MCK: Model checking the logic of knowledge, in: Proceedings of 16th International Conference on ComputerAided Verification (CAV’04), in: LNCS, vol. 3114, Springer-Verlag, 2004, pp. 479–483.[12] J. Halpern, R. van der Meyden, M.Y. Vardi, Complete axiomatisations for reasoning about knowledge and time, SIAM Journal on Comput-ing 33 (3) (2003) 674–703.[13] J. Halpern, Y. Moses, A guide to completeness complexity for modal logics of knowledge and belief, Artificial Intelligence 54 (1992) 319–379.[14] W. van der Hoek, M. Wooldridge, Model checking knowledge and time, in: SPIN 2002—Proceedings of the Ninth International SPIN Work-shop on Model Checking of Software, Grenoble, France, April 2002.[15] W. van der Hoek, M. Wooldridge, Cooperation, knowledge, and time: Alternating-time temporal epistemic logic and its applications, StudiaLogica 75 (1) (2003) 125–157.[16] M. Kacprzak, A. Lomuscio, W. Penczek, Verification of multiagent systems via unbounded model checking, in: N.R. Jennings, C. Sierra,L. Sonenberg, M. Tambe (Eds.), Proceedings of the Third International Conference on Autonomous Agents and Multiagent Systems (AA-MAS’04), vol. II, ACM, July 2004, pp. 638–645.[17] I. Kang, I. Lee, An efficient state space generation for analysis of real-time systems, in: Proceedings of the International Symposium onSoftware testing and Analysis (ISSTA’96), ACM Press, 1996, pp. 4–13.1038A. Lomuscio et al. / Artificial Intelligence 171 (2007) 1011–1038[18] A. Lomuscio, T. Łasica, W. Penczek, Bounded model checking for interpreted systems: preliminary experimental results, in: M. Hinchey(Ed.), Proceedings of FAABS II, in: LNCS, vol. 2699, Springer-Verlag, 2003.[19] A. Lomuscio, M. Sergot, Deontic interpreted systems, Studia Logica 75 (1) (2003) 63–92.[20] R. van der Meyden, K. Wong, Complete axiomatizations for reasoning about knowledge and branching time, Studia Logica 75 (1) (2003)93–123.[21] Y. Moses, B. Bloom, Knowledge, timed precedence and clocks, in: Proceedings of the 13th ACM Symposium on Principles of DistributedComputing (PODC’94), ACM Press, 1994, pp. 274–303.[22] W. Nabialek, A. Niewiadomski, W. Penczek, A. Pólrola, M. Szreter, VerICS 2004: A model checker for real time and multi-agent systems, in:Proceedings of the International Workshop on Concurrency, Specification and Programming (CS&P’04), in: Informatik-Berichte, vol. 170,Humboldt University, 2004, pp. 88–99.[23] W. Penczek, A. Lomuscio, Verifying epistemic properties of multi-agent systems via bounded model checking, Fundamenta Informati-cae 55 (2) (2003) 167–185.[24] W. Penczek, B. Wo´zna, A. Zbrzezny, Bounded model checking for the universal fragment of CTL, Fundamenta Informaticae 51 (1–2) (2002)135–156.[25] W. Penczek, B. Wo´zna, A. Zbrzezny, Towards bounded model checking for the universal fragment of TCTL, in: Proceedings of the 7thInternational Symposium on Formal Techniques in Real-Time and Fault Tolerant Systems (FTRTFT’02), in: LNCS, vol. 2469, Springer-Verlag, 2002, pp. 265–288.[26] F. Raimondi, A. Lomuscio, Automatic verification of multi-agent systems by model checking via OBDDs, Journal of Applied Logic (2007)(Special issue on Logic-based agent verification), submitted for publication.[27] S. Tripakis, S. Yovine, Analysis of timed systems using time-abstracting bisimulations, Formal Methods in System Design 18 (1) (2001)25–68.[28] R. van der Meyden, H. Shilov, Model checking knowledge and time in systems with perfect recall, in: Proceedings of the 19th Conferenceon Foundations of Software Technology and Theoretical Computer Science (FST&TCS’99), in: LNCS, vol. 1738, Springer-Verlag, 1999,pp. 432–445.[29] R. van der Meyden, K. Su, Symbolic model checking the knowledge of the dining cryptographers, in: Proceedings of the 17th IEEE ComputerSecurity Foundations Workshop (CSFW’04), Washington, DC, USA, IEEE Computer Society, 2004, pp. 280–291.∗[30] B. Wo´zna, Bounded model checking for the universal fragment of CTL[31] B. Wo´zna, A. Lomuscio, A logic for knowledge, correctness, and real time, in: Proceedings of the 5th International Workshop on Computa-, Fundamenta Informaticae 63 (1) (2004) 65–87.tional Logic in Multi-Agent Systems (CLIMA’04), in: LNAI, vol. 3487, Springer-Verlag, 2005, pp. 1–15.[32] B. Wo´zna, A. Lomuscio, W. Penczek, Bounded model checking for deontic interpreted systems, in: Proc. of the 2nd Workshop on Logic andCommunication in Multi-Agent Systems (LCMAS’04), in: ENTCS, vol. 126, Elsevier, 2004, pp. 93–114.[33] A. Zbrzezny, Improvements in SAT-based reachability analysis for timed automata, Fundamenta Informaticae 60 (1–4) (2004) 417–434.