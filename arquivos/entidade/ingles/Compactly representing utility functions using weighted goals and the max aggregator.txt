Artificial Intelligence 174 (2010) 1222–1246Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintCompactly representing utility functions using weighted goals andthe max aggregator ✩Joel Uckelman∗,1, Ulle EndrissInstitute for Logic, Language and Computation, University of Amsterdam, Netherlandsa r t i c l ei n f oa b s t r a c tWeighted propositional formulas can be used to model preferences over combinatorialdomains: each formula represents a goal we would like to see satisfied, the weight of aformula represents the importance of the goal in question, and to assess the desirability ofa given alternative we aggregate the weights of the goals satisfied by that alternative. Oneof several options is to aggregate by using the maximum of the weights of the satisfiedgoals. This approach gives rise to a family of preference representation languages, one foreach of a range of possible restrictions we can impose on either formulas or weights. Weanalyze the properties of these languages and establish results regarding their expressivity,and absolute and relative succinctness. We also study the computational complexity of theproblem of finding the best and the worst alternative for a given set of weighted goals,and of finding an alternative that is optimal for a group of agents, for a range of differentnotions of collective optimality proposed in social choice theory and welfare economics.© 2010 Elsevier B.V. All rights reserved.Article history:Received 11 January 2010Received in revised form 8 July 2010Accepted 12 July 2010Available online 17 July 2010Keywords:Preference representationPreference aggregation1. Introduction1.1. Motivation and backgroundPreference handling is a problem of central importance in Artificial Intelligence [3]. For example, recommender systemsneed to elicit and maintain a representation of the user’s preferences and multiagent systems are often modeled as col-lections of decision-theoretic agents, each of which are guided by their own preferences. Possibly the most fundamentalquestion in this context is how to best represent the preferences of an artificial agent or a human user. Designing suitablelanguages for representing preferences is particularly challenging when the alternatives over which an agent expresses pref-erences have a combinatorial structure. For example, in the context of combinatorial auctions [4] or other resource allocationproblems [5], the number of bundles of goods an agent may obtain is exponential in the number of goods under discussion,so being able to express preferences over this exponentially large space of alternatives in a compact manner is crucial.In this paper we study a particular family of languages for representing cardinal preferences over combinatorial domainsthat are Cartesian products of several binary domains. Expressing a cardinal preference means specifying a (utility or valua-tion) function mapping each alternative to a number reflecting the degree of preference for that alternative. For comparison,ordinal preferences are relations over pairs of alternatives specifying whether one is preferable to the other. The use of utility✩This paper is based on and extends work presented at the 11th International Conference on Principles of Knowledge Representation and Reasoning(KR-2008) (Uckelman and Endriss (2008) [1]), and additionally presents material from Uckelman (2009) [2].* Corresponding author.E-mail addresses: j.d.uckelman@uva.nl (J. Uckelman), ulle.endriss@uva.nl (U. Endriss).1 The work of Joel Uckelman was supported by a GLoRiClass fellowship funded by the European Commission (Early Stage Research Training Mono-HostFellowship MEST-CT-2005-020841).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.07.003J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461223functions to model preferences is appropriate in some circumstances, and inappropriate in others. In the context of com-binatorial auctions, for instance, modeling preferences as utility functions is appropriate: in such an auction each bidderneeds to express how much they would be prepared to pay for a given bundle of goods [4]. From the representational pointof view, this amounts to specifying a function from the space of bundles to numbers, i.e., to specifying a cardinal preferencestructure.The family of preference representation languages we study is based on weighted propositional formulas, or weightedgoals. For a given set of propositional variables, alternatives correspond to models for propositional formulas. A utilityfunction mapping such alternatives to the reals can then be represented as a set of weighted goals, as follows: To computethe utility of a given alternative X , we first collect all the weights of the goals satisfied by X and then we aggregate thoseweights to obtain a single number, the utility of X . One natural aggregation function is (cid:2); in this case, the utility of X isthe sum of the weights of the goals satisfied by X . An other option is to use the max operator; in this case the utility of Xis the maximum of the weights of the goals satisfied by X .Using weighted formulas for preference representation is an idea which originated in penalty logic [6]. Penalty logicaddresses the problem of how to make inferences from an inconsistent knowledge base by augmenting the formulas ina knowledge base with weights, which indicate the cost of falsifying the associated formula; then the inference problemreduces to considering what is valid over only the minimal-cost consistent subsets of a given knowledge base. Here, costs aresummed: That is, the cost of rejecting ϕ and ψ is the sum of their weights. Lafage and Lang [7] generalize penalty logic topermit aggregators other than sum, and also introduce a distance-based aggregator. Coste-Marquis et al. [8] take a differentapproach: Rather than using goalbases directly for representing cardinal preferences, they use goalbases to underpin variousordinal preference relations.Chevaleyre et al. [9] shifted from considering the weights of unsatisfied formulas as penalties to considering the weightsof satisfied formulas as utilities, and their work contains initial results on goalbases aggregated with sum; later work extendsthis to systematically cover most naturally-defined sum-aggregated goalbase languages [10]. Recently, this framework hasbeen further extended from propositional logic to description logic [11,12].1.2. Our contributionAs mentioned, most previous work has concentrated on the weights of unsatisfied goals or on sum languages, whereweights are aggregated via (cid:2). In this paper we explore in depth the properties of the next most important family oflanguages that can be constructed in this framework, namely the max languages, in which the aggregation function used ismax. The properties we study concern the expressivity, the succinctness, and the complexity of max languages.Expressivity. We establish correspondence results which show what classes of utility functions can be represented by themost natural representatives of the family of the max languages. For instance, if the only logical connective allowed isconjunction, then we can represent the monotone utility functions, and only those.Succinctness. We rank the most important max languages in terms of how compactly they can represent those utilityfunctions that they are able to represent. Informally, language L is at least as succinct as L(cid:3)if the increase in size whentranslating representations from L(cid:3)to L is polynomially bounded. For instance, conjunctions of literals induce a strictlymore succinct language than conjunctions of atoms if only positive weights are permitted, but an equally succinct languageif both positive and negative weights can be used. We also provide results concerning bounds on the absolute succinct-ness of some languages, and we study whether languages have unique or multiple representations for the same utilityfunction.Complexity. We first address two natural problems that arise in the context of reasoning about the preferences of a singleagent when these are represented using a max language. Here we study the computational complexity of (the decisionvariants of) the problem of finding the highest and the lowest utility that such an agent may experience. It turns outthat the complexity strongly depends on the language chosen; some problems can be solved in linear time while othersare coNP-complete. We also study the complexity of collective utility maximization, the problem of finding the “best”partitioning of the set of propositional variables amongst a group of agents (inducing a model for each of them). There area number of different ways of aggregating the utilities of the members of a group to define what is best for that group. Weanalyze the complexity of the problem for several of the standard notions of collective utility, familiar from the social choiceand welfare economics literature, such as utilitarian social welfare, egalitarian social welfare, and the Nash product [13].1.3. Related workSimilar questions have previously been addressed for other preference representation languages.CP-nets [14] are a tool for representing conditional ordinal preferences over combinatorial domains (rather than utilityfunctions, on which we focus in this paper). As with any individual preference representation formalism, we may wish toaggregate individual preferences into group preferences. Various methods for aggregating the CP-nets of multiple agentshave been tried by, e.g., Rossi et al. [15] and Lang and Xia [16]; the analogous problem for us, aggregating the goalbases of1224J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246multiple agents, we take up in Section 8. The complexity of answering ordering and dominance queries is also studied inthe CP-nets literature [17]; we do not study these questions for goalbases because finding the utility of a given model foran agent is always computationally trivial.Generalized additive (GA) decomposition is a way of representing utility functions as sums of “smaller” utility functions,each of which has as its domain some proper subset of the domain of the larger utility function. Originally proposed byFishburn [18], GA-decomposition has more recently been used by Gonzales and Perny [19] for constructing GAI-nets, and byBrafman et al. [20] for eliciting preferences using GA-decomposable CP- and TCP-nets. Goalbase languages may be seen asparticular way of GA-decomposing utility functions.MC-nets [21] are a method of representing the utilities which accrue to coalitions of players in coalitional games. Ieongand Shoham [21] consider the expressive power and succinctness of MC-nets, as well as the complexity of answeringquestions about the core of the coalitional game being represented. MC-nets and the goalbase language L(cubes, R, (cid:2))(the language of arbitrarily-weighted conjunctions of literals, aggregated by summing weights of satisfied formulas) areessentially notational variants of each other, applied to different problems. Elkind et al. [22] extend MC-nets to permitarbitrary formulas and prove some succinctness and complexity results for these languages.Bidding languages—cardinal preference representation languages designed for expressing the values of bundles of goods—are a popular topic in the combinatorial auctions literature. The expressivity, succinctness, and complexity of the XOR and ORbidding languages have been studied extensively [23]. The XOR language is equivalent to our language L(pcubes, R+, max)(the language of positively-weighted conjunctions of atoms, aggregated by taking the maximum weight of all satisfiedformulas). Boutilier and Hoos [24] have proposed two logic-based bidding languages (which are in some respects similar toour sum languages), and Boutilier [25] experimentally compared these two languages to see how their use affected runtimewhen solving the Winner Determination Problem for auctions.Coste-Marquis et al. [8] use goalbases to induce various kinds of preference orderings, prove expressivity results aboutwhich preorders are expressible under which methods of constructing preorders from goalbases, and show whether it ispossible to translate the underlying goalbases from one language to another without exponential blowup. These results aresimilar in concept to our succinctness results, though we view goalbases cardinally rather than ordinally.1.4. Overview of this paperThe remainder of this paper is structured as follows. Basic definitions concerning the framework of representing utilityfunctions via weighted goals are provided in Section 2. Section 3 contains our expressivity results. Following some generalremarks on succinctness in Section 4, Section 5 presents results on absolute succinctness and the uniqueness property andSection 6 is devoted to the issue of relative succinctness. Then, complexity results for reasoning about the preferences ofindividual agents are provided in Section 7, while our results on the complexity of collective utility maximization can befound in Section 8. Finally, Section 9 concludes with a brief discussion of some of the remaining open problems in the area.2. PreliminariesIn this section we present definitions and notation used throughout this paper, as well as our basic framework forrepresenting utility functions. First, we define the structures we need from propositional logic:Definition 1 (Propositional formulas). The set PS is a fixed, finite set of propositional variables. We write PSn to indicatethat |PS| = n. Let LPS be the language of propositional logic over PS and the logical constants (cid:4) and ⊥, closed underthe Boolean connectives ¬, ∧, and ∨.The technical results found here apply to formulas that contain only the connectives ¬, ∧, and ∨. We omit → (implica-tion) as a Boolean connective because is it succinctly definable in terms of ¬ and ∨. Equivalence and XOR we also do notconsider here, though their inclusion might result in more succinct languages.2Definition 2 (Propositional models). A model is a set M ⊆ PS. The satisfaction relation |(cid:10) for models and formulas is definedin the usual way for propositional logic:M |(cid:10) (cid:4).M (cid:11)|(cid:10) ⊥.M |(cid:10) p iff p ∈ M.M |(cid:10) ¬ϕM |(cid:10) ϕ ∧ ψM |(cid:10) ϕ ∨ ψiff M (cid:11)|(cid:10) ϕ.iff M |(cid:10) ϕ and M |(cid:10) ψ.iff M |(cid:10) ϕ or M |(cid:10) ψ.We give names to some types of propositional formulas:2 The XOR we refer to here is logical XOR, which is distinct from the so-called XOR in XOR bidding languages [23] and valuative XOR [24], both of whichbehave like max and operate on weights, rather than formulas.J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461225Definition 3 (Types of formulas).• An atom is a member of PS.• A literal is an atom or its negation.• A clause is a disjunction of literals.• A cube is a conjunction of literals.• A positive X is a satisfiable formula of type X that contains nonegations.• A strictly positive X is a non-tautologous positive X.• A k- X is an X with at most k occurrences of atoms.We abbreviate the class of general, unrestricted formulas to forms. When discussing positive clauses, positive cubes, andpositive formulas, we frequently abbreviate these to pclauses, pcubes, and pforms, respectively. Additionally, we call strictlypositive cubes and strictly positive formulas spcubes and spforms, respectively. (The term spclauses is redundant becauseevery positive clause is falsifiable.) Atoms are 1-spclauses, 1-spcubes, and 1-spformulas (and also 1-pclauses, 1-pcubes, and1-pformulas), while literals are 1-clauses, 1-cubes, and 1-formulas. Clauses, cubes, and formulas are ω-clauses, ω-cubes, and∅ = (cid:4)ω-formulas, respectively, which is to say that the formulas may be of any finite length.3 Note that by convention∅ = ⊥, from which follows that (cid:4) is the unique 0-pcube and ⊥ the unique 0-clause. The notation X + (cid:4) indicatesandthe set of formulas X ∪ {(cid:4)} (e.g., pclauses + (cid:4) is the set containing all pclauses along with (cid:4)).(cid:3)(cid:2)Definition 4 (State formulas). If X ⊆ PS, then define ¯X = PS \ X , and ¬ X = {¬p | p ∈ X}. Thenformula corresponding to the model M.(cid:2)(M ∪ ¬ ¯M) is the stateFor example, if PS = {a, b, c, d}, then the state formula for the model ∅ is ¬a ∧ ¬b ∧ ¬c ∧ ¬d and for {a, b} is a ∧ b ∧(cid:2)¬c ∧ ¬d. Notice that M(cid:3) |(cid:10)(M ∪ ¬ ¯M) iff M = M(cid:3).We are interested in utility functions over combinatorial domains that are the Cartesian product of several binary do-mains. A generic representation of this kind of domain is the set of all possible models for propositional formulas over afixed language with a finite number of propositional variables (the dimensionality of the combinatorial domain).Utility functions are a typical method for specifying cardinal preferences:Definition 5 (Utility functions). A utility function is a mapping u : 2PS → R.Because the utility functions we consider have sets as their domain, and propositional models are sets, utility functionscan be thought of as mapping models to their values.We note here some properties of utility functions to which we make frequent reference:Definition 6 (Properties of utility functions). Suppose that u is a utility function. Then:• u is normalized iff u(∅) = 0.• u is nonnegative iff u( X) (cid:2) 0 for all X .• u is monotone iff u( X) (cid:2) u(Y ) for all X ⊇ Y .• u is modular iff u( X ∪ Y ) = u( X) + u(Y ) − u( X ∩ Y ) for all X, Y .• u is a unit-demand valuation iff u( X) = maxa∈ X u({a}) and u is normalized.• u is a simple unit-demand valuation iff u( X) = 1 for all X (cid:11)= ∅ and u is normalized.Definition 7 (Weighted goals and goalbases). A weighted goal is a pair (ϕ, w), where ϕ is a formula in the language LPS andw ∈ R. A goalbase is a finite multiset G = {(ϕi, w i)}i of weighted goals.Goals are typically required to be satisfiable formulas. We will see in Section 3 that for the languages studied here thisrestriction does not affect expressive power, though the presence of unsatisfiable formulas can affect the computationalcomplexity of some decision problems, as discussed in Section 7. When a particular goalbase is under consideration, wewrite wϕ to mean the weight of formula ϕ in that goalbase. For(G) is the set of formulas in G. Var(ϕ) is the set ofpropositional variables in the formula ϕ and Var(G) =ϕ∈For(G) Var(ϕ). A formula (ϕ, wϕ) ∈ G is active in a model Mwhen M |(cid:10) ϕ and for all other (ψ, wψ ) ∈ G such that M |(cid:10) ψ , wψ (cid:3) wϕ .(cid:4)Given a goalbase and a model, we may easily determine which weighted formulas the model makes true. Now, we wouldlike to combine the weights of the satisfied formulas to find the value of the model. A function which combines weightsmust map a multiset of reals (the collected weights of the satisfied formulas) to a real (the value of the model). We call suchfunctions aggregation functions, as they aggregate the many weights of satisfied formulas into the single value of the model.43 Strictly speaking, we should write, e.g., <ω-cubes instead of ω-cubes, but we abuse notation for the sake of brevity and because all formulas areassumed to have finite length.4 The definition of aggregation function given here differs subtly from that given elsewhere [7,10,26], in that all of these write the aggregation functionR → R when in practice the reader is meant to understand the aggregation function as operating on multisets. In particular, these authors oftenstuff w. We have striven to avoid this ambiguity in the present work; in the event thatas F : 2write sums of weights aswe have failed, please in all cases read sums of weights as sums of multisets (rather than sets) of weights. That is,{w | stuff }, when what is intended is{1, 1} = 2 (cid:11)= 1.(cid:5)(cid:5)(cid:5)1226J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246Definition 8 (Generated utility functions). A goalbase G and an aggregation function F : NR → R generate a utility function uG,Fmapping each model M ⊆ PS to uG,F (M) = F (w | (ϕ, w) ∈ G and M |(cid:10) ϕ).Because multisets are unordered structures, any aggregation function will necessarily be associative and commutativeover weights.5 Natural aggregation functions to consider include (cid:2) and max. In this paper, we restrict ourselves to theaggregation function max, the maximum function. When F = max, the utility function generated from a goalbase G isuG,max(M) = max(ϕ,w)∈GM|(cid:10)ϕw.In other words, the value of a model is the same as the largest weight had by any formula which is true in that model. Forexample, if PS = {p, q, r}, then the goalbase G = {((cid:4), 0), (p ∨ q ∨ r, 1)} generates the utility function u : X (cid:17)→ min(1, | X|).(This is easy to see by observing that (cid:4) is the only true formula in the model ∅, so it sets the value of uG there; both(cid:4) and p ∨ q ∨ r are true in every other model, but p ∨ q ∨ r has a higher weight, so it sets the value of uG in all modelsexcept ∅.)Different aggregation functions may produce dramatically different utility functions from the same goalbase. E.g., if G ={(a, 1) | a ∈ PS}, then uG,max is the simple unit-demand utility function (u( X) = 1 if X (cid:11)= ∅, 0 otherwise) while uG,(cid:2) is thesimple additive utility function (u( X) = | X|). We assume that max(∅) = −∞; it is often useful to include, say, ((cid:4), 0) in anygoalbase intended for use with max so as to obtain utility functions with finite values for all models.Definition 9 (Goalbase equivalence). Two goalbases G and Gten G ≡F G) iff they define the same utility function. That is, G ≡F G(cid:3)(cid:3)iff uG,F = uG(cid:3),F .are equivalent with respect to an aggregation function F (writ-(cid:3)Goalbases provide a framework for defining languages for representing utility functions. Any restriction we might imposeon goals (e.g., we may only want to allow clauses as formulas) or weights (e.g., we may not want to allow negative weights)and any choice we make regarding the aggregator F give rise to a different language. An interesting question, then, iswhether there are natural goalbase languages (defined in terms of natural restrictions) such that the utility functions theygenerate enjoy simple structural properties. (This is indeed the case, as seen in Section 3.)Definition 10 (Languages and classes of utility functions). Let Φ ⊆ LPS be a set of formulas, W ⊆ R a set of weights, and Fan aggregation function. Then L(Φ, W , F ) is the set of all goalbases formed by formulas in Φ with weights from W to beaggregated by F , and U (Φ, W , F ) is the class of utility functions generated by goalbases belonging to L(Φ, W , F ).Regarding weights, we study the restriction to the positive reals (R+) as well as the general case (R). For complexityquestions we will restrict our attention to the rationals (Q). We restrict formulas by their structure, according to the typesof formula defined in Definition 3. For example, the language L(cubes, R+, max) consists of all goalbases which containonly positively-weighted cubes, and are aggregated using max. Many more examples of languages will be seen in Section 3,where we investigate language expressivity.Finally, a note on non-binary domains: Due to the applications we have in mind for goalbase languages, resource alloca-tion, auctions, voting—all binary in the sense that an agent has an item or does not, or a candidate is a winner or not—wehave restricted our variables to have binary domains. Moreover, restriction to binary domains is a natural one when workingwith propositional logic. Nonetheless, it is possible to simulate in our framework variables which take on a larger (but stillfinite) set of values, by coding single many-valued variables into multiple binary-valued ones.3. ExpressivityAn important feature of any preference representation language is the range of preferences which can be represented init. This available range is known as the expressivity of the language; this section is devoted to determining the expressivityof various max goalbase languages.From the point of view of the theorist, we want to know how expressive goalbase languages are, both for their ownsake and because these expressivity results are necessary for proving succinctness results in Section 6. As a user of goalbaselanguages, knowing the expressivity of goalbase languages can help us choose the language which is best suited for ourapplication. Can our language of choice represent all functions belonging to a given class of utility functions which interestsus? Not all languages are equally expressive and not all applications require full expressivity. Excess expressivity is oftenundesirable, because highly expressive languages tend to be computationally more demanding to reason about.We are interested in correspondence results between languages and classes of utility functions. A correspondence resultshows that the utility functions representable in a particular language are exactly those comprising a particular class of5 If the domain were arbitrary-length tuples of reals instead of multisets of reals (R∗), then there could be aggregators which are sensitiveto the order in which formula weights are aggregated. Since goalbases are unordered structures, there is no compelling reason to be concerned with theorder in which weights are aggregated, so we limit the domains of aggregators to multisets.instead of NRJ. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461227utility functions. We provide correspondence results for eight max languages, and partial correspondence results for anotherfour.We begin by establishing some simple results regarding equivalences between languages, which allow us to narrow therange of languages to be considered in the remainder of the section. We then characterize the expressivity of the mostimportant (distinct) languages.3.1. Goalbase equivalencesWe are interested in comparing languages generated by different types of goalbases, in particular those generated fromthe following restrictions on formulas: literals, cubes, clauses, and general formulas using both conjunction and disjunction; aswell as positive formulas and those including negation. Regarding weights, we want to consider positive and general weights.This gives rise to 4 · 2 · 2 = 16 different languages. Here we establish several equivalences amongst languages and therebyshow that we actually only need to consider a subset of all the languages that can be defined in this manner. Furthermore,if we are interested only in monotone utility functions, then we can further reduce the range of languages to consider.We first show that disjunction is not an expressively helpful connective for max languages:Theorem 11. G ∪ {(ϕ1 ∨ · · · ∨ ϕn, w)} ≡max G ∪ {(ϕi, w) | 1 (cid:3) i (cid:3) n}.Proof. Fix a model X . If wϕ1∨···∨ϕn is not the maximum wψ such that X |(cid:10) ψ , then some other (ψ, wψ ) ∈ G is. Since= wϕ1∨···∨ϕn , then wψ > wϕi for all i. In this case, G alone determines the value of the left and right goalbases.wϕiIf wϕ1∨···∨ϕn is the maximum wψ such that X |(cid:10) ψ , then some ϕi are such that X |(cid:10) ϕi . For each such ϕi , we have= wϕ1∨···∨ϕn in the goalbase on the right, and so both the left and right have the same maximum. (cid:2)wϕiThis tells us that with max as our aggregator, disjunctions as main connectives do not contribute to a language’s expres-sivity. In fact, as any formula has an equivalent representation in disjunctive normal form, this tells us that disjunction cannever increase the expressive power of a max language. In particular, from Theorem 11 we get the following equivalencesbetween languages:Corollary 12. Fix W ⊆ R. Then:1. U (pclauses, W , max) = U (atoms, W , max),2. U (clauses, W , max) = U (literals, W , max),3. U (pforms, W , max) = U (pcubes, W , max),4. U (forms, W , max) = U (cubes, W , max).Proof. For U (forms, W , max) = U (cubes, W , max): Suppose that (ϕ, w) ∈ G. Without loss of generality, assume that ϕ =ψ1 ∨ · · · ∨ ψn is in DNF. By Theorem 11, we may replace (ψ1 ∨ · · · ∨ ψn, w) by (ψ1, w), . . . , (ψn, w) and preserve goalbaseequivalence. Repeating this for each original formula in G converts G to the language L(cubes, W , max), since each ψi is acube and the weights were left unchanged.We use the same argument for each of the other cases, noting that the same transformation reduces a positive formula(in DNF) to a set of positive cubes, a clause to a set of literals, and a positive clause to a set of atoms. (cid:2)The same is not true for sum languages. E.g., under summation clauses are more expressive than literals: For W = R,clauses can express all utility functions, while literals can express only modular functions [10, Corollary 3.8]. For each of theequivalences in Corollary 12, there is a set of weights W which violates it under summation.Recall that a utility function u is called monotone if M ⊆ M(cid:3)). Monotonicity is a reasonable assump-tion for many applications, in particular if propositional variables are interpreted as goods. Next we show that negation isnot a helpful operation in case we are only interested in modeling monotone functions.implies u(M) (cid:3) u(M(cid:3)+be a set of positive literals, and X−a set of negative literals, such that no atom appears in both. IfTheorem 13. Fix G. Let XuG∪{(X +∪X −,w)},max is monotone, then(cid:2)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)G ∪+ ∪ XX−, w≡max G ∪(cid:6)(cid:7)(cid:8)(cid:9)(cid:10).+X, wProof. There are two cases to consider: models which are supersets of X+, and models which are not.• Write u for uG∪{(X +∪X −,w)},max. In models M ⊇ X(cid:2)because u( Xof model M, since the value in M is already at least w.+) (cid:2) w and u is monotone. Therefore, substituting (+, we have that M |(cid:10)(cid:2)+X(cid:2)+, w) for (X. It must be the case that u(M) (cid:2) w−, w) cannot change the valueX+ ∪ X(cid:2)1228J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246• In models M (cid:2) X(cid:2)++, w) for ((cid:2)(Xfunction., we have that both+ ∪ XXare false, and so cannot be active. Thus substituting−, w) cannot change the value at M, as inactive formulas do not affect the value of a utilityandXX(cid:2)+ ∪ X−(cid:2)+Therefore, in all models M we have that uG∪{((cid:2)X +∪X −,w)},max(M) = uG∪{((cid:2)X +,w)},max(M). (cid:2)The following result shows that we can further reduce the range of languages to consider if we limit ourselves to(cid:2)∅ = (cid:4).)monotone utility functions. It follows immediately from Theorem 13 and Corollary 12. (Recall thatCorollary 14. Let Mono be the class of monotone utility functions. Fix W ⊆ R. Then:1. U (clauses, W , max) ∩ Mono = U (atoms + (cid:4), W , max) ∩ Mono.2. U (forms, W , max) ∩ Mono = U (pcubes, W , max) ∩ Mono.3.2. CorrespondencesCorollary 12 tells us that the interesting languages, expressivity-wise, are those based on cubes, positive cubes, literals,and atoms. We prove that cubes are expressively complete for the full range of utility functions and that positive cubescorrespond to the class of monotone functions:Theorem 15. U (cubes, R, max) is the class of all utility functions.Proof. Given a utility function u, define(cid:6)(cid:7)(cid:8)(cid:9) (cid:11)G =X ∪ ¬ ¯X, u(X)(cid:11) X ⊆ PS(cid:10).Since the formulas are state formulas, and as such are mutually exclusive, exactly one weight will be active in each model,and so u( X) = uG ( X). (cid:2)Theorem 16. U (pcubes, R, max) is the class of monotone utility functions.Proof. (⇒) Suppose that G ∈ U (pcubes, R, max) but uG is not monotone. So there are models M ⊂ MuG (M). Then there is a (ϕ, uG (M)) ∈ G which is active in M such that M |(cid:10) ϕ but Ma ∈ M(cid:2)(cid:3) \ M for which ϕ |(cid:10) ¬a. Therefore, ϕ is not a positive formula, which contradicts the hypothesis that ϕ is a pcube.(cid:3)) <such that uG (M(cid:3) ⊃ M, then there is some(cid:3) (cid:11)|(cid:10) ϕ. Since M(cid:3)(⇐) If u is monotone, then let G = {(X, u( X)) | X ⊆ PS}. Note that for Y ⊆ X , u(Y ) = w= u( X) followsdirectly from the monotonicity of u. In model X , uG ( X) = max{w(cid:2)Y| Y ⊆ X} = w(cid:2)(cid:2)YX . Hence uG ( X) = u( X). (cid:2)(cid:3) w(cid:2)XTheorem 17. U (atoms, R, max) is the class of unit-demand utility functions.Proof. Suppose that u is a unit-demand valuation, which by definition means that u( X) = maxa∈ X u({a}). Construct a G ∈U (atoms, R, max) such that G = {(a, w) | a ∈ PS, u({a}) = w}. Thenu(X) = maxa∈ Xu= max(a,w)∈Gw = uG,max(X).(cid:12)(cid:13){a}Conversely, suppose that G ∈ U (atoms, R, max), and note that the same series of equivalences holds. (cid:2)We are not aware of a property of utility functions referred to in the literature which would characterize U (literals,R, max). The desired property is a generalization of the unit-demand valuation that also allows us to specify a value for notreceiving a particular item.By restricting the set of weights W we can capture classes of utility functions with a particular range. For in-stance, the class U (pcubes, R+, max), is the class of nonnegative monotone functions. This class is known to be equal toU (pforms, R+, (cid:2)) [10, Corollary 3.12].6 This is a case where a syntactically simple language is more expressive with maxthan with sum.On the other hand, some very simple classes of utility functions are hard to capture in structurally simple languages using(cid:3)) for. Modular functions are nicely captured by U (literals, R, (cid:2)) [10, Corollary 3.8]. However, there is no naturalmax aggregation. For instance, recall that a utility function u is called modular iff u(M ∪ Mall M, M(cid:3)) = u(M) + u(M(cid:3)) − u(M ∩ M(cid:3) ∈ 2PS6 To be precise, U (pcubes, R+, max) = U (pforms, R+, (cid:2)) over total functions only. Because the max languages can also express partially definedfunctions returning −∞ for some models while sum languages cannot,if we expand our consideration to partially-defined utility functions, thenU (pcubes, R+, max) ⊃ U (pforms, R+, (cid:2)).J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461229Fig. 1. Summary of expressivity results.restriction to formulas that would allow us to characterize the modular functions under max aggregation. On the contrary,among the max languages considered here, only L(cubes, R, max) can express all modular functions, and this language isso powerful that it can actually express all utility functions.We use the fact that L(k-pcubes, R, max) misses some modular utility functions when k < |PS| to show that the ex-pressivity of L(k-pcubes, W , max) and L(k-cubes, W , max) strictly increases with k:Theorem 18. For all k > j,1. U (k-pcubes, W , max) ⊃ U (j-pcubes, W , max), and2. U (k-cubes, W , max) ⊃ U (j-cubes, W , max).follows by inclusion. For the strict part, we show that L((k + 1)-pcubes, W , max)\Proof. (1) The nonstrict partU (k-pcubes, W , max) is nonempty because it includes a family of modular utility functions: Suppose that u is mod-ular and nonnegative, and at least k + 1 singleton models {p1}, . . . , {pk+1} have nonzero value. Then there is noG ∈ L(k-pcubes, W , max) such that u({p1, . . . , pk+1}) = uG ({p1, . . . , pk+1}). This is the case because with max as our ag-gregator uG ({p1, . . . , pk+1}) would necessarily be the weight of some k-pcube and by assumption if X ⊂ {p1, . . . , pk+1}then u( X) < u({p1, . . . , pk+1}). However, if u gives exactly k + 1 singleton models nonzero value, then u is representable inL((k + 1)-pcubes, W , max) by the goalbase(cid:9) (cid:11)(cid:6)(cid:7)(cid:8)X, u(X)(cid:11) X ⊆ PS and | X| (cid:3) k + 1(cid:10).(2) The same modular utility functions missing from L(k-pcubes, W , max) are missing from L(k-cubes, W , max), dueto the fact that the addition of negation to the language is not helpful for representing monotone utility functions (seeTheorem 13). (cid:2)Our correspondence results are summarized in Fig. 1. In the figure, each node represents one language we examined,and an arrow from one node to another indicates that the tail language is included in the head language. Within each node,the expressivity of the language is given, according to the key below:ω ω-additive (general)+ nonnegative‡general unit-demandm monotoneuunit-demand⊂ proper subset ofWhere ⊂ is indicated, the language represents a proper subset of the class of utility functions with the given properties. Inall other cases, the language represents exactly the class of utility functions with the given properties. The x-axis (increasing1230J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246for all (ϕ, wϕ ) ∈ G dofor all (ψ, wψ ) ∈ G doif wϕ (cid:2) wψ thenif |(cid:10) ϕ → ψ thenG := G \ {(ϕ, wϕ )}end ifend ifend forend forFig. 2. An algorithm for removing superfluous formulas from a goalbase G.to the right) is the cubes axis, along which allowable cubes grow from length 1 up to ω; the y-axis (decreasing into thepage) is the positivity axis and has two steps: positive and general. Each language in the lower graph is a sublanguage of thecorresponding language with general weights in the upper graph, but we have omitted these arrows for clarity. Note thatseveral languages do not appear in the figure due to being expressively equivalent to some language which does appearthere. For max languages, this is due to the fact expressed in Corollary 12, namely that disjunction does not contributeexpressivity to max languages.4. Succinctness: Terminological interludeAn important criterion for selecting one language over another for some application is, as mentioned previously, the sizeof the representations of utility functions in that language. (Recall that this is why we seek to avoid explicit representationsof utility functions.) In the two sections following this one, we present both absolute and comparative notions of succinct-ness, so that we can make precise claims about the efficiency of various goalbase languages. Before we can do that, however,we require some terminology and definitions common to both types of succinctness.For max languages, some weighted goals in a goalbase may never contribute to the utility of an alternative. Recall that aformula (ϕ, wϕ) ∈ G is active in a model M when M |(cid:10) ϕ and for all other (ψ, wψ ) ∈ G such that M |(cid:10) ψ , wψ (cid:3) wϕ . Goal-bases may sometimes contain formulas which fail to contribute value to the goalbase in any model. We call these formulassuperfluous. Equivalence is preserved if superfluous formulas are removed from a goalbase one at a time: If (ϕ, w) ∈ G is asuperfluous formula, then G ≡ G \ {(ϕ, w)}. However, removal of all superfluous formulas simultaneously is not necessarilyequivalence-preserving, and which formulas are superfluous must be reevaluated after any single formula is removed froma goalbase. For example, all formulas in {(a, 1), (¬¬a, 1)} are superfluous under max; however, removing both produces theempty goalbase, which is not equivalent to the original. For max languages, contradictions are always superfluous, but forany other weighted formula (even formulas with zero weight) there is some max goalbase where it is not superfluous.Fact 19. Fix (ϕ, wϕ) ∈ G, and the aggregator as max. Then, if (ϕ, wϕ) is superfluous, for every model M where (ϕ, wϕ) is active, theset {(ψ, wψ ) ∈ G | M |(cid:10) ψ and wψ is maximal} is not a singleton.Since superfluous formulas are useless, they may be removed without harm. We can remove superfluous formulas fromany G ∈ L(forms, R, max) as in Fig. 2. Two aspects of this algorithm are significant: First, we remove superfluous formulasone at a time. Second, this algorithm is not efficient, as it requires a quadratic number of calls to an unsat oracle; wewould like to do better than a coNP algorithm. In the previous section, we saw that the only max languages which are(expressively) interesting are based on cubes. This fact greatly reduces the complexity of deciding whether a formula issuperfluous, since deciding whether one cube implies another is polynomial (see the proof of Theorem 60 for the algorithm).Next, we note a useful fact relating superfluity to activity:Fact 20. Under the max aggregator, if G contains no superfluous formulas then every (ϕ, w) ∈ G has a model in which it is uniquelyactive.Some goalbase languages have a unique way of expressing a given utility function, while others allow for several alter-native representations. Here we make this notion of uniqueness precise:Definition 21 (Unique representations). A utility function u is represented in a language L if there exists a goalbase G ∈ Lsuch that u = uG . A utility function u is uniquely represented (modulo formula equivalence) in a language L if, given a setof formulas Φ containing one representative formula for each formula equivalence class in L (except ⊥), there is a uniquegoalbase G such that For(G) ⊆ Φ, uG = u, and G contains no superfluous formulas. A language L is said to have uniquerepresentations if every u represented in L is uniquely represented.Any language which has unique representations can be thought of as minimal in the sense that any further restriction onpermissible weighted formulas will lead to a reduction in expressivity. Effectively this means that the set of representativesof formula equivalence classes forms a minimal basis for the vector space in which the goalbases live.J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461231Definition 22 (Formula length and goalbase size). The length of a formula ϕ is the number of occurrences of atoms it contains.The size of a weighted goal (ϕ, w) is the length of ϕ plus the number of bits needed to store w (that is, (cid:24)log w(cid:25) bits). Thesize of a goalbase G, written as size(G), is the sum of the sizes of the weighted goals in G.Observe that the size of a goalbase may differ from its cardinality: If G = {(a ∧ b, 1)}, then size(G) = 2 (or 3, if we arenot neglecting the bit used for storing the weight) while |G| = 1.Definition 23. A goalbase G ∈ L(Φ, W , F ) is minimal if for all G(cid:3) ∈ L(Φ, W , F ) such that G(cid:3) ≡F G, size(G) (cid:3) size(G(cid:3)).The difficulty of recognizing whether G is minimal, or of finding a G which is a minimal representative of some utilityfunction u, is strongly dependent on what L and u are. In the general case, formulas in a minimal goalbase will be pairwisenon-equivalent, but this is not a sufficient condition for minimality. For some languages (such as L(atoms, R, max)) andsome classes of utility functions (e.g., modular) we can detect minimality and generate minimal representations easily,while for many richer languages how to do this is not obvious or unknown.For max languages, in a minimal goalbase no formula is implied by any formula with a smaller or equal weight; for sumlanguages, formulas in a minimal goalbase will be pairwise non-equivalent.5. Absolute succinctness and uniquenessIn this section we find (absolute) bounds on the sizes of goalbases for the two most expressive and useful max languages,L(pcubes, R, max) and L(cubes, R, max). The bounds we derive here imply bounds for sublanguages of these as well, in-cluding all max languages we consider in this paper. For L(pcubes, R, max) and its sublanguages, we calculate exact sizesof goalbases; for L(cubes, R, max), we give upper and lower bounds which are sometimes tight—though for sublanguagesthere is the possibility of tighter bounds. Along the way, we prove that L(pcubes, R, max) has unique representations.The range of a utility function u (ran u)—that is, the set of values it may take on—strongly influences the size of repre-sentations that utility function may have in any max language:Theorem 24. For any goalbase G, |G| (cid:2) | ran uG,max|.Proof. By definition, uG,max( X) = max{wϕ | X |(cid:10) ϕ}, so for every model X there must be some wϕ = u( X). (cid:2)While the size of the range of a utility function serves as a lower bound on the size of its representation in any maxlanguage, there is no such relationship for sum languages: E.g., if G = {(ai, 2i) | ai ∈ PS}, then uG,(cid:2) has a large range (everyvalue in 0, . . . , 2|PS| − 1) despite that G is itself small (using only |PS| atoms).| is polynomial. However, the converse does not hold:By Theorem 24 we have that if |Gn| is polynomial then | ran uGn(cid:15)Let(cid:14)(cid:7)(cid:8)Gn =X, 1(cid:9) (cid:11)(cid:11) | X| = n2(cid:12)Here, | ran uGn| = 2 but |Gn| =nn/2(cid:16)(cid:17)((cid:4), 0).∪(cid:13)+ 1 is superpolynomial and Gn is minimal in L(pcubes, R+, max).There is a clear connection between superfluity and goalbase minimality, namely that if G is a minimal goalbase fora utility function u ∈ U (Φ, W , max), then G contains no superfluous formulas. However, the converse does not hold forL(forms, R, max): {(p, 1), (¬p, 1)} and {((cid:4), 1)} represent the same utility function u( X) = 1, yet neither formula in thelarger goalbase is superfluous.Recall from Definition 21 that a language can have unique representations, meaning that it is sufficiently restrictiveas to have exactly one minimal representation of each representable utility function. Several sum languages have uniquerepresentations, as discussed in [2, Section 3.4.2] and [10, Section 3.2]. This also occurs for at least one max language:Theorem 25. L(pcubes, R, max) has unique representations.Proof. Fix u ∈ U (pcubes, R, max). Let G 0 = ∅. While uG i ,max (cid:11)= u: Choose a least model X for which uG i ,max( X) (cid:11)= u( X). (Byleast, we mean that | X| is minimal.) Let G i+1 = G i ∪ {(X, u( X))}. Call G the G i at which this algorithm terminates. (Anexample of a run of this algorithm appears after this proof.)(cid:2)Correctness: uG,max = u because each iteration ends with one more model correct than in the previous iteration, andX cannot disturb the value of any model Y ⊂ X , as X is the leastthere are finitely many models. Setting a weight forX is true, and cannot prevent us from correctly setting the value of any model Z ⊃ X during subsequentmodel whereiterations, because by Theorem 16 u is monotone. Note also that the order of choice of cubes of the same size makes nodifference in the outcome.(cid:2)(cid:2)(cid:2)Minimality: For any model X , either(cid:2)Y ⊂ X for which (Y , u(Y )) dominates (X receives a weight or not. IfX receives a weight, then there is no modelX, u( X)). (A formula (ψ, wψ ) ∈ G dominates another (ϕ, wϕ) ∈ G if ϕ |(cid:10) ψ and(cid:2)(cid:2)1232J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246(cid:2)wϕ < wψ . If such a (ψ, wψ ) exists, we call (ϕ, wϕ) dominated. Dominated formulas are superfluous.) Furthermore, there isno model Z ⊃ X for which X |(cid:10)X , then this is the sole way in whichwe can make uG,max( X) = u( X). If, on the other hand, the algorithm produces a G whereX receives no weight, then atsome step i in the construction uG i ,max( X) became correct before we reached model X . If we were to set a weight forX ,it would be superfluous and so G would not be minimal. In summary: Any smaller G will give an incorrect value for somemodel, and any different, yet still correct, G will necessarily contain a superfluous formula. (cid:2)Z . Hence, if the algorithm assigns a weight to(cid:2)(cid:2)(cid:2)We give an example of run of the algorithm used in the proof above: Given the utility functionu(∅) = 0,(cid:12)(cid:13){a}u= 1,(cid:12)u(cid:12)(cid:13){b}(cid:13){c}= 0,= 2,(cid:12)u(cid:12)(cid:13){a, b}(cid:13){a, c}= 2,= 2,(cid:12)u(cid:12)(cid:13)= 3,(cid:13){b, c}{a, b, c}= 10,uuthe algorithm constructs the corresponding goalbase G as follows: G 0 = ∅ by definition. uG 0,max(∅) = −∞ (cid:11)= u(∅) = 0, and∅ is the unique smallest incorrect model, so we let G 1 = G 0 ∪ {((cid:4), 0)}. Now {a} and {c} are the least models made incorrectby uG 1,max; we choose to correct {a} first. (Recall that the order in which models of the same size are corrected does notaffect the result.) Let G 2 = G 1 ∪ {(a, 1)}. Continuing in this fashion, we will correct the models {c}, {a, b}, {b, c}, and {a, b, c}:uG 0 = ∅,G 1 = G 0 ∪(cid:16)(cid:17)((cid:4), 0),G 2 = G 1 ∪G 3 = G 2 ∪(cid:16)(cid:16)(cid:17)(a, 1)(cid:17)(c, 2),,G 4 = G 3 ∪G 5 = G 4 ∪(cid:16)(cid:16)(cid:17)(a ∧ b, 2),(cid:17)(b ∧ c, 3),G 6 = G 5 ∪(cid:16)(cid:17)(a ∧ b ∧ c, 10).After constructing G 6, we see that there are no further incorrect models, i.e., uG 6,max( X) = u( X) for all X ⊆ PS, so G = G 6is the unique representation of u in L(pcubes, R, max).Note that while this algorithm does show how to construct the minimal representation for any representable utility func-tion in L(pcubes, W , max), it is not an efficient algorithm for finding representations, as it requires us to check exponentiallymany models in order to set weights for them.Next, we derive upper and lower bounds for the size of representations in L(cubes, W , max), but first we prove severaltechnical lemmas which we will need. For the remainder of this section, we assume that all uG,max are total. First, recallthat active formulas in max-aggregated goalbases are those which have a weight equal to the value of some model wherethey are true.Lemma 26. Fix a goalbase G ∈ L(cubes, W , max) and a (ϕ, w) ∈ G. If a model X has an extension Y ⊃ X such that uG,max(Y ) <uG,max( X) and (ϕ, w) is active in X , then ϕ is not a positive cube.Proof. Suppose otherwise. Let (ϕ, w) be such that X |(cid:10) ϕ, uG,max( X) = w, ϕ a pcube, and uG,max(Y ) < uG,max( X). Then forall Y ⊃ X it follows that Y |(cid:10) ϕ because ϕ is a monotone formula. So uG,max(Y ) (cid:2) w = uG,max( X), contrary to hypothesis. (cid:2)In words: If a cube is active in a model which can decline in value when extended, then there must be a negative literalin that cube.Here we define the X↑ notation for denoting the set of extensions of X , which is used throughout the remainder of thissection:Definition 27 (Upsets). If X is a model, then X↑ = {Y | X ⊆ Y ⊆ PS}.The set of models 2PSmay be thought of as a Boolean lattice; then X↑ is the sublattice rooted at X . Alternatively, X↑may be thought of as all of the ways of extending X .Lemma 28. Suppose that w is the minimum value of any model in X↑. Let (ϕ1, w), . . . , (ϕk, w) ∈ G ∈ L(cubes, W , max) be theformulas which are true in at least one model in X↑, false outside of X↑, and have weight w. Let GX, w)}.Then:(cid:3) = G \ {(ϕi, w)}1(cid:2)i(cid:2)k ∪ {((cid:2)(cid:3) ≡max G.1. G2. size(G(cid:3)) (cid:3) size(G).(cid:2)Proof. For 1, we must show that the changes made to G to get Gvalues. The formuladisturbs no models in X↑, since (remaining models in X↑ since w is minimal there. Every ϕi |(cid:10)models where a ϕi was active.X is not longer than ϕ1, . . . , ϕk:(cid:2)X is true exactly in X↑ and nowhere else, so it disturbs no models outside of X↑. Adding (result in no models being disturbed from their originalX, w)X, w) is inactive in any Y where u(Y ) > w, and provides the correct value in theX , so if M |(cid:10) ϕi then M |(cid:10)X also, which covers allX is the shortest formula which is true only in X↑. Each ϕi is true only in(cid:5)X) (strictly larger if k > 1). (cid:2)kX↑ also, so size(ϕi) (cid:2) size(X), and thereforei=1 size(ϕi) (cid:2) size(For 2:(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461233This lemma permits us to reduce iteratively any goalbase in L(cubes, W , max): Let G = G 0. Apply the reduction to thesmallest sublattice X↑ of G i to which it has not yet been applied, and let the result be G i+1. (Starting from the smallestsublattice means starting with PS as the root and working our way downwards to ∅.) At some stage i, we will reach a fixedpoint—that is, G i = G∞—where no further applications of the reduction will have any effect. (The upper bound for reachinga fixed point happens to be i = 2, though all we require here is that it happens after finitely many applications of thereduction.) Let G(cid:3) = G∞, and call such a Gpcubes-minimal.|PS|(cid:3)Since this reduction is never size-increasing, we may make use of it to observe a useful fact about the formulas inminimal goalbases in L(cubes, W , max):Lemma 29. For every G ∈ L(cubes, W , max), there is a minimal Gu(Y ) < w for every Y ⊂ X .(cid:3) ≡max G such that ((cid:2)X, w) ∈ G(cid:3)iff w = min Z ∈ X↑ u(Z ) and(cid:3)(cid:3) ≡max G and G(cid:3)(cid:3)is minimal. Let G(cid:3)(cid:3)(cid:3)Proof. Suppose that Gto Galready minimal, G(cid:3). Since the reduction is equivalence-preserving and size-reducing, Gcannot be smaller, so size(G(cid:3)(cid:2)(cid:2)(cid:3)) = size(G(cid:3)(cid:3)) and G(cid:3)(cid:3) ≡max Gis also minimal.be the result of exhaustively applying the reduction in Lemma 28and size(Gwas(cid:3)(cid:3)). Since G(cid:3)) (cid:3) size(G(cid:3)(cid:3)(cid:3)(cid:3)X, w) ∈ G(⇒) Suppose that ((cid:2)(cid:2)X is a positive cube, itis true exactly in X↑ and nowhere else. If there were some model Y ⊂ X for which u(Y ) (cid:2) w, then the reduction wouldY , w) instead, so it must be the case that u(Y ) < w for all Y ⊂ X . Forhave eliminated (the other condition, suppose that there is a model Z ∈ X↑ such that u(Z ) < w. Since Z |(cid:10)X and max is our aggregator,it follows that u(Z ) (cid:2) w, which is a contradiction.X, w) was not eliminated by the reduction. SinceX, w) and replaced it with (. Then ((⇐) Suppose that w = min Z ∈ X↑ u(Z ) and u(Y ) < w for every Y ⊂ X . Since w is the minimal model value in X↑, itfollows that there is a model Z ⊇ X for which u(Z ) = w. In order for u(Z ) = w, we need a formula (ϕ, w) ∈ Gsuch thatZ |(cid:10) ϕ. Because u(Y ) < w for all Y ⊂ X , it must also be the case that Y (cid:11)|(cid:10) ϕ for all Y ⊂ X . The only formula which meetsboth of these requirements which could have survived the reduction is (X, w), since any longer formula would have beenreplaced by (X, w) and any shorter formula would either be true in some model Y ⊂ X or fail to be true in Z . (cid:2)(cid:2)(cid:2)(cid:2)(cid:3)(cid:2)Note that w is not necessarily equal to u( X) here—in fact, if uG is nonmonotone, then w will frequently not be u( X).For example, if(cid:14)u(X) =2 if X = ∅,1 otherwise,then over PS = {p, q} the goalbase {((cid:4), 1), (¬p ∧ ¬q, 2)} represents u in the language L(cubes, R, max) and is pcubes-minimal, yet the minimal weight in ∅↑, which is 1, does not equal u(∅) = 2.Lemma 29 is crucial for the bounds we will derive below, as it tells us exactly which positive cubes we will find in aminimal goalbase which is also pcubes-minimal.Furthermore, from Lemma 29, we have the following special case:Lemma 30. For every G ∈ L(cubes, W , max), there is a minimal G(cid:3) ≡max G such that ((cid:4), min X∈2PS u( X)) ∈ G(cid:3).Proof. min X∈2PS u( X) = min Z ∈∅↑ u(Z ), and ∅ has no proper subsets. (cid:2)It is not always that case that a G(cid:3)which results from the reduction under discussion is uniquely minimal. E.g.,(cid:14)u(X) =1 if a ∈ X,0 otherwisecan be represented as either {((cid:4), 0), (a, 1)} or {(¬a, 0), (a, 1)}, which are the same size.Now we attempt to calculate bounds on size(G) when G ∈ L(cubes, W , max).Lemma 31. Let G ∈ L(cubes, W , max) be minimal. Let G+ ⊆ G be the set of pcubes in G. Then(cid:12)sizeG(cid:13)+=(cid:18)(cid:6)max(cid:12)1, | X|(cid:13) (cid:11)(cid:11) ¬∃Y ⊂ X s.t. uG,max(Y ) (cid:2) minZ ∈ X↑(cid:10)uG,max(Z ).Proof. By Lemma 29 we may, without loss of generality, assume that(cid:6)(cid:7)(cid:8)(cid:9) (cid:11)+ =G(cid:11) ¬∃Y ⊂ X s.t. u(Y ) (cid:2) minZ ∈ X↑(cid:10)u(Z ).X, w(cid:18)(cid:6)Therefore(cid:12)sizeG(cid:13)+=(cid:12)1, | X|(cid:13) (cid:11)(cid:11) ¬∃Y ⊂ X s.t. uG,max(Y ) (cid:2) minZ ∈ X↑(cid:10)uG,max(Z ).max1234J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246Note that we must have max(1, | X|) instead of simply | X|, due to the fact that |∅| = 0 but size((cid:2)∅) = size((cid:4)) = 1. (cid:2)Using this and a result from Section 3, we can derive the exact size for every minimal G in the monotone portion ofL(cubes, W , max):Theorem 32. If G ∈ L(cubes, W , max), G is minimal, and uG,max is monotone, thensize(G) =(cid:18)(cid:16)(cid:12)1, | X|max(cid:13) (cid:11)(cid:17)(cid:11) ¬∃Y ⊂ X s.t. uG,max(Y ) (cid:2) uG,max(X).Proof. Since uG,max is monotone, we know by Theorem 13 that removal of negative literals is equivalence-preserving. Since+G is minimal, it follows that the negative literals are already gone, so every formula in G is a positive cube. Hence G = G,so we have from Lemma 31 that(cid:18)(cid:6)size(G) =max(cid:12)1, | X|(cid:13) (cid:11)(cid:11) ¬∃Y ⊂ X s.t. uG,max(Y ) (cid:2) minZ ∈ X↑(cid:10)uG,max(Z ).Finally, notice that because uG,max is monotone, min Z ∈ X↑ uG,max(Z ) = uG,max( X), which permits us to simplify the condi-tion. (cid:2)Now we turn to the case where uG,max is nonmonotone. For any such minimal G, we know by Lemma 31 the precise, the subset of G containing negative, the positive subset of G, so all that remains is to derive bounds for G−+size of Gliterals. First, we derive bounds for the size of G−.Lemma 33. Let G ∈ L(cubes, W , max) be minimal. Let G(cid:11)(cid:11) uG,max(X) > uG,maxX ∪ {p}p ∈ PS(cid:11)(cid:16)(cid:11)(cid:13)(cid:17)(cid:11)(cid:12)(cid:11) (cid:3) size−(cid:12)be the set of cubes in G containing negative literals. Then(cid:10)(cid:11)(cid:11)(cid:11).X|∃Y ⊂ X s.t. u(Y ) (cid:2) minZ ∈ X↑(cid:3) |PS| ·u(Z )(cid:11)(cid:11)(cid:11)(cid:6)G−(cid:13)Proof. By Lemma 26, if there are models X and X ∪ {p} where uG,max( X ∪ {p}) < uG,max( X), then there must be a formula(ϕ, w) active in model X that contains ¬p. These are the formulas which comprise G−.The best case is that every such ¬p appears in G−(cid:2)exactly once, which gives us the lower bound. The worst case is toX ∪ ¬ ¯X to cover each pair of model X, X ∪ {p} over which there is a decline in value; every suchwrite a state formulastate formula has length |PS|. (cid:2)Now we have all of the pieces necessary for exhibiting upper and lower bounds on the size of goalbases inL(cubes, W , max) which represent nonmonotone utility functions.Theorem 34. If G ∈ L(cubes, W , max), G is minimal, and uG,max is nonmonotone, thensize(G) (cid:2)(cid:18)(cid:6)(cid:12)(cid:13) (cid:11)(cid:11) ¬∃Y ⊂ X s.t. uG,max(Y ) (cid:2) minZ ∈ X↑(cid:13)(cid:17)(cid:11)(cid:12)(cid:11).1, | X|(cid:11)(cid:11) uG,max(X) > uG,maxX ∪ {a}max(cid:11)(cid:16)(cid:11)a ∈ PS+(cid:10)uG,max(Z )Proof. Recall that G = G. (cid:2)size of G−+ ∪ G−. Lemma 31 gives us the exact size of G+, while Lemma 33 gives us a lower bound for theTheorem 35. If G ∈ L(cubes, W , max), G is minimal, and uG,max is nonmonotone, thensize(G) (cid:3)(cid:18)(cid:6)max+ |PS| ·(cid:11)(cid:11)(cid:11)(cid:12)(cid:13) (cid:11)(cid:11) ¬∃Y ⊂ X s.t. uG,max(Y ) (cid:2) minZ ∈ X↑1, | X|(cid:6)(cid:11)(cid:11) ∃Y ⊂ X s.t. uG,max(Y ) (cid:2) minZ ∈ X↑X(cid:10)uG,max(Z )(cid:10)(cid:11)(cid:11)(cid:11).uG,max(Z )Proof. Recall that G = G. (cid:2)size of G−+ ∪ G−. Lemma 31 gives us the exact size of G+, while Lemma 33 gives us an upper bound for theNote that neither the upper nor lower bounds given here are tight in general, though for each bound we do have anexample of a goalbase for which one of the bounds is tight. For the upper bound, consider the utility functionu(X) = | X| mod 2,J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461235the parity function on PS. When PS = {a, b, c}, the goalbase(cid:16)(cid:17)((cid:4), 0), (a ∧ b ∧ c, 1), (a ∧ ¬b ∧ ¬c, 1), (¬a ∧ b ∧ ¬c, 1), (¬a ∧ ¬b ∧ c, 1)is minimal for u( X). The lower bound here is 7, the upper bound is 13, and the actual size is also 13. For the lower bound,consider the utility function(cid:14)1 if a /∈ X,0 otherwise,u(X) =for which the goalbase {((cid:4), 0), (¬a, 1)} is minimal over PS = {a, b, c}. In this case, both the actual size and lower boundare 2, while the upper bound is again 13. Finally, the utility function u( X) = 3 − | X| is represented minimally over PS ={a, b, c} by the goalbase⎧⎪⎪⎪⎨⎪⎪⎪⎩((cid:4), 0),(¬a, 1), (¬b, 1), (¬c, 1),(¬a ∧ ¬b ∧ c, 2), (¬a ∧ b ∧ ¬c, 2), (a ∧ ¬b ∧ ¬c, 2),(¬a ∧ ¬b ∧ ¬c, 3)⎫⎪⎪⎪⎬⎪⎪⎪⎭which has size 16, but hits neither the lower nor the upper bound, which are 4 and 22, respectively.Clearly these bounds could be refined by further analyzing the composition of Gfor various nonmonotone utilityfunctions, but at present what exactly the differences are among the three examples—what causes one to hit the lowerbound, one to hit the upper bound, and one to hit neither—is not apparent to us. Furthermore, the bounds themselves arenot easy to compute; here again, some additional insight into the structure of such functions might be of use. We leavethese issues for future work.−6. Relative succinctnessFrequently one language contains shorter representations of some utility functions than another language does. Here wegive a definition of relative succinctness (used also in [10] and similar to those given in [8,27]) to make this notion precise.Because we wish to compare languages which differ in expressive power, we define succinctness over only the expressiveoverlap of the languages being compared. This leads to some counterintuitive results for languages with little expressiveoverlap and makes the comparative succinctness relation intransitive, but it also permits us to make comparisons where theexpressive overlap is substantial, though not total.Definition 36 (Relative succinctness). Let L(Φ, W , F ) and L(Ψ, Wtions for which every member is expressible in both languages. Then L(Φ, W , F ) (cid:28)U L(Ψ, Wf : L(Φ, W , F ) → L(Ψ, Wsize( f (G)) (cid:3) p(size(G)).(cid:3)) be goalbase languages and U a class of utility func-(cid:3)) iff there exists a function(cid:3), F(cid:3)) and a polynomial p such that for all G ∈ L(Φ, W , F ), if uG,F ∈ U then uG,F = u f (G),F (cid:3) and(cid:3), F(cid:3), Fas: L(cid:3)Read L (cid:28)U L(cid:3)—we write L ≺U L(cid:3)is at least as succinct as L over the class U . When L(cid:3)is strictly more succinct than L—thatis, in no case are representations more than polynomially worse, and in at least one case, they are super-polynomiallybetter in L(cid:3); when we havenonstrict succinctness in neither direction, i.e., incomparability, we write L ⊥U L(cid:3). Whenever a succinctness relation appears(cid:3) ∈ L(cid:3)}, which isunsubscripted (i.e., without an explicit class of comparison), then implicitly U = {uG,F | G ∈ L} ∩ {uG(cid:3),F (cid:3) | Gthe expressive intersection of L and L(cid:3). Later, in Section 6.2, we illustrate some circumstances in which being explicit aboutthe class of comparison is important.. When we have nonstrict succinctness in both directions, we write L ∼U L(cid:3)Finding the succinctness relation between some pairs of goalbase languages is trivial, as when one language in a pair isa sublanguage of the other, or when the two languages have no expressive overlap. These cases can be dismissed withoutargument. Recall from Definition 21 that a goalbase language may have unique representations: If a utility function isrepresentable in the language, then there is exactly one representation of it in the language. If L has unique representationsand L (cid:3) L(cid:3)is true, then we can show that L (cid:3) L(cid:3)as follows:Proof strategy. We present a family of utility functions U , and construct a (smallish, but not necessarily optimal) repre-for each u ∈ U . Then, we construct a representation G u ∈ L for each u ∈ U where at least one G u issentation G(cid:3)u . Because we know that L has unique representations, we know that weexponentially larger than its corresponding Gcannot find a smaller (or any other!) representation of u in L, so we have shown that L (cid:3) L(cid:3). (cid:2)∈ L(cid:3)(cid:3)uThis is a handy proof strategy, one which we shall make use of in the proofs of Theorems 42, 50, and 51.Often we consider families of utility functions {un}n∈N, where for each n we have that |PS| = n. Suppose that we have acorresponding family of goalbases {Gn}n∈N for which un = uGn . Unless the number of bits required to represent the weightsin Gn grows superexponentially in n, the size contributed by the weights can be safely ignored when considering how1236J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246size(Gn) grows with n. Every family of utility functions considered here has weights which are independent of n, so wedisregard the size of the weights in our succinctness results. (Superexponential growth in weights affects all languagesequally.)Here we state some basic properties of the succinctness relation, which we use frequently in our proofs, often withoutreference.Fact 37. For all languages L1, L2, L3:1. If L1 ⊆ L2, then L1 (cid:28) L2.2. If L1 (cid:28) L2 and L3 ⊆ L1, then L3 (cid:28) L2.3. If L1 ⊆ L2 ⊆ L3 and L1 ≺ L2 (cid:28) L3, then L1 ≺ L3.Note that Fact 37.2 is useful contrapositively also, for deriving (cid:4) results for superlanguages. For Fact 37.3, it would beinadequate to require that L1 (cid:28) L2 ≺ L3 instead, since it could happen that L1 is too small to represent the utility functionswhich cause L2 ≺ L3.For certain languages, due to the limited length of formulas which may appear in minimal goalbases, it will be the casethat we need not distinguish between growth of size(G) and growth of |G|.Lemma 38. Let L be a goalbase language. For each n ∈ N, let ϕn be the longest formula in L in n variables with no shorter equivalent.Then if there is a polynomial p such that size(ϕn) ∈ O (p(n)), it follows that for all families of minimal goalbases {Gn}n∈N ⊆ L, size(Gn)is polynomial in n iff |Gn| is polynomial in n.Proof. (⇒) This direction is immediate, since it is impossible to form exponentially many formulas from polynomially-manyatom instances.(⇐) Suppose that |Gn| = p(n) is a polynomial. The longest formula ϕn in L in n variables has size(ϕn) = q(n), for somepolynomial q. The worst case is that each of the p(n) formulas in Gn has size q(n), for a total size of p(n) · q(n), which isstill polynomial in n. (cid:2)In particular, this means that size(G) and |G| are interchangeable in terms of growth in |PS| for languages such asL(cubes, W , F ) and L(clauses, W , F ), but not necessarily for languages such as L(forms, W , F ). We use this lemma implicitlyin several of our relative succinctness results.Now we derive a simple succinctness result which applies to all languages which permit formulas of no more than afixed, finite length.Theorem 39. For any fixed k ∈ N, arbitrary set of formulas Ψ , and arbitrary sets of weights W , Wthen L(Φ, W , F ) (cid:31) L(Ψ, W(cid:3), F ).(cid:3)and aggregator F : If Φ ⊆ k-forms,Proof. There are only O (nk) formulas of length k or less, and so any utility function u representable in L(Φ, W , F )cannot have a representation more than polynomially larger than the best one in L(forms, R, F ). Hence, L(Φ, W , F ) (cid:31)L(forms, R, F ). Furthermore, L(forms, R, F ) ⊇ L(Ψ, W(cid:3), F ), so by Fact 37.2 we have that L(Φ, W , F ) (cid:31) L(Ψ, W(cid:3), F ). (cid:2)As a consequence, any two languages with bounded-length formulas and the same aggregator are equally succinct overtheir expressive intersection. Put another way, there are no interesting questions involving relative succinctness betweenpairs of languages in which both impose a fixed bound on formula length.When comparing the succinctness of any two max languages, notice that the available weights play no role in the out-(cid:3), max) are the languages under comparison, then for any utility function u representablecome. If L(Φ, W , max) and L(Ψ, W(cid:3)in both languages, ran u ⊆ W ∩ W. Due to this, any weighted formula (ϕ, w) where w /∈ W ∩ Wwill be superfluous whenit occurs in a representation of u in either language. Since only minimal representations are relevant for succinctness, wecan disregard all representations of u which use weights outside of W ∩ W:(cid:3)(cid:3)Fact 40. For succinctness relations  ∈ {(cid:28), ≺, ∼, ⊥}:L(Φ, W , max)  L(Ψ, W(cid:3), max) ⇐⇒ L(Φ, W ∩ W(cid:3), max)  L(Ψ, W ∩ W(cid:3), max).6.1. Succinctness between max languagesNext, we show that all pcubes and cubes languages are equally succinct when using max for our aggregator.J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461237Theorem 41. For all j, k ∈ N ∪ {ω} and W , W(cid:3) ⊆ R:1. L(j-pcubes, W , max) ∼ L(k-pcubes, W2. L(j-pcubes, W , max) ∼ L(k-cubes, W3. L(j-cubes, W , max) ∼ L(k-cubes, W(cid:3), max).(cid:3), max).(cid:3), max).(cid:3), max). By Fact 40, we may assume without loss of generality that W = Wj, k ∈ N, all three cases follow immediately from Theorem 39. We must give a proofProof. When at least one ofwhen j = k = ω, but here the first and third cases trivialize, so all that remains is to show that L(pcubes, W , max) ∼L(cubes, W. L(pcubes, W , max) expresses onlymonotone utility functions, and Theorem 13 ensures that any representation containing negative literals may be reducedto a shorter, equivalent one by simply deleting the negative literals; the result of such a deletion is in L(pcubes, W , max).(cid:3), max) will be theHence the minimal representations for any u representable in both L(pcubes, W , max) and L(cubes, Wsame, which proves that L(pcubes, W , max) ∼ L(cubes, W(cid:3), max). (cid:2)(cid:3)Recall that Theorem 11 shows that disjunctions as main connectives do not affect succinctness, because the translationrequired to eliminate disjunction does not affect the size of a goalbase. However, the same is not necessarily true fordisjunctions which occur within the scope of other connectives. Therefore, for our analysis of expressivity of max languagesin Section 3 we could safely ignore disjunction, but for succinctness we cannot, as the next result demonstrates.Theorem 42. L(pcubes, R+, max) ≺ L(pforms, R+, max).Proof. We have that L(pcubes, R+, max) (cid:28) L(pforms, R+, max) because every pcube is a positive formula. For strict suc-cinctness: The family of utility functions represented by(cid:13)(cid:17)(cid:16)(cid:12)(p1 ∨ p2) ∧ (p3 ∨ p4) ∧ · · · ∧ (pn−1 ∨ pn), 1in L(pforms, R+, max) grows linearly with n. The same family may be represented in L(pcubes, R+, max) by(cid:26)(cid:27)n/2(cid:8)k=1pik , 1(cid:28) (cid:11)(cid:11)(cid:11)(cid:11) i1, . . . , in/2 ∈ {1, 2} × {3, 4} × · · · × {n − 1, n}(cid:29)which has size 2n−1 for any (even) n. By Theorem 25, L(pcubes, R+, max) has unique representations, which establishes theminimality of this representation. (cid:2)More generally, the same argument shows that for any intersecting sets of weights W , W, L(pcubes, W , max) ≺L(pforms, W, we may use that for the formula weights instead of using 1 aswe do in the proof—and also that L(pcubes, W , max) ≺ L(forms, W , max) and L(cubes, W , max) ≺ L(pforms, W , max), byvirtue of Theorem 13.(cid:3), max)—so long as there is some w ∈ W ∩ W(cid:3)(cid:3)When dealing with negation-containing goalbases for monotone utility functions, we might wish to put all nonpositiveformulas in a standard form in order to simplify working with them. Negation normal form is a way of doing this. A formulaϕ is in negation normal form (NNF) if all occurrences of negation apply to atoms only. Any formula may be rewritten to anequivalent formula in NNF without an increase in size, by recursive application of De Morgan’s Laws and elimination ofdouble negation.Before proceeding, we define a notion of uniform substitution for formulas and goalbases:Definition 43 (Uniform substitution). If ϕ, ψ1, . . . , ψk are formulas and p1, . . . , pk ∈ PS, then ϕ[ψ1/p1, . . . , ψk/pk] is theresult of (simultaneously) substituting ψi for every occurrence of pi in ϕ. If G is a goalbase, then G[ψ1/p1, . . . , ψk/pk] isthe result of applying the substitution to each (ϕ, w) ∈ G.In the following, we will abuse notation by writing ϕ[(cid:4)/¬p] for the less perspicuous ϕ[⊥/p]. Once we have all formulasin a monotone max goalbase translated to NNF, we may apply the following equivalence in order to remove the negativeliterals altogether:Lemma 44. If uG,max is monotone and every formula in G is in NNF, then G[(cid:4)/¬p1, . . . , (cid:4)/¬pn] ≡max G.Proof. To show that G[(cid:4)/¬p1, . . . , (cid:4)/¬pn] ≡max G,{(ϕ[(cid:4)/¬p], w)} ≡max G, as we can then repeat the process for every other formula and every other p ∈ PS.it suffices to show for a single (ϕ, w) ∈ G that (G \ {(ϕ, w)}) ∪Fix a (ϕ, wϕ) ∈ G which has ¬p as a subformula. Suppose that no model M where p /∈ M is such that M |(cid:10) ϕ butM ∪ {p} (cid:11)|(cid:10) ϕ. In this case, switching p from false to true will never make ϕ false if had been true, so we may safely replaceall occurrences of ¬p by (cid:4). That is, |(cid:10) ϕ[(cid:4)/¬p] ↔ ϕ and we are done.1238J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246Table 1Summary of relative succinctness results. Entries to beread row first.Otherwise, let M be such a model. Since ϕ is in NNF, ϕ[(cid:4)/¬p] will remain true in every model where ϕ was true;but there is additionally the possibility that M ∪ {p} |(cid:10) ϕ[(cid:4)/¬p] when M (cid:11)|(cid:10) ϕ. However, since uG,max is monotone andM |(cid:10) ϕ, we know that uG,max(M ∪ {p}) (cid:2) wϕ , and so there must already be some (ψ, wψ ) ∈ G such that M ∪ {p} |(cid:10) ψ andwψ = uG,max(M ∪ {p}). Therefore, making it so that M ∪ {p} |(cid:10) ϕ[(cid:4)/¬p] will not disturb the value of the utility functionthere (or in any other model). Hence, (G \ {(ϕ, w)}) ∪ {(ϕ[(cid:4)/¬p], w)} ≡max G. (cid:2)With this lemma in hand, we now improve on Theorem 13 and show that there is no succinctness gain from usingnegation in arbitrary formulas, not just cubes, when representing monotone utility functions in max languages.Theorem 45. If Φ is closed under transformation to NNF and for every G ∈ L(Φ, W , max) which is in NNF, there exists a G[(cid:4)/¬p |p ∈ PS] ∈ L(Ψ, W(cid:3), max), then L(Φ, W , max) (cid:28) L(Ψ, W(cid:3), max).Proof. By Lemma 44, if G is in NNF, then G ≡max G[(cid:4)/¬p1, . . . , (cid:4)/¬pn]. Since transformation to NNF and substitution of (cid:4)for all negative literals are both size-preserving, size(G) = size(G[(cid:4)/¬p1, . . . , (cid:4)/¬pn]), so there is always a space-efficienttranslation from L(Φ, W , max) to L(Ψ, W(cid:3), max). (cid:2)Note that Wcannot be completely arbitrary here: The condition requiring that G[(cid:4)/¬p | p ∈ PS] ∈ L(Ψ, W(cid:3), max)implies that W(cid:3)(cid:3) ⊇ W , though it is not stated in the theorem.Corollary 46. L(forms, W , max) ∼ L(pforms, W(cid:3), max), for all W , W(cid:3) ⊆ R.Proof. By Fact 40, we may assume withoutL(forms, W , max) (cid:31) L(pforms, W(cid:3), max), and L(forms, W , max) (cid:28) L(pforms, W(cid:3), max) follows from Theorem 45. (cid:2)loss of generality that W = W(cid:3). Then itfollows by inclusion thatOur relative succinctness results are summarized in Table 1. The table contains many more results than are proved in thetext, but in all cases these are straightforward consequences of results which do appear here. The most common result by anoverwhelming margin is for two max languages to be equally succinct, a consequence of Theorem 41, which gives us equalsuccinctness between any pair of cubes and pcubes languages. (For example, L(cubes, R+, max) ∼ L(pcubes, R, max).) Alldifferences in succinctness shown in the table are due to the combination of Theorem 42 with Fact 40 or Theorem 13. (Seethe text immediately following Theorem 42 for the required argument.) Furthermore, we list no clauses languages here,because Corollary 12 reduces all clauses languages to simpler cubes languages. Because our succinctness results for maxlanguages are much more powerful than comparable results for sum languages [10, Table 2], the table for max languages iscomplete.6.2. Cross-aggregator succinctnessHere we examine the succinctness of selected max languages with respect to selected sum languages. For any pair ofthe 10 max languages and 18 sum languages considered in [10, Section 4], there is a succinctness result to be shown.J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461239We do not present all 180 potential results here, however, both for brevity and because for some sum languages withoutunique representations we lack the tools to easily prove succinctness results involving them. The results we do present arerepresentative of results of this kind.The first two results, Theorems 48 and 49, indicate that each aggregator favors short representations for certain kinds ofutility functions; whether max or sum is better for a particular application will depend on what utility functions agents arelikely to have. Additionally, the final three results in this section highlight why it was necessary to index our succinctnessrelation to a particular class of comparison; a discussion of this appears at the end of the section.∀n and u∃n, which are useful for showing succinctness differences betweenWe define two families of utility functions, ulanguages.Definition 47. Let u∀n(X) =u(cid:14)10∀n and uif X = PS,otherwise,∃n be the utility functions over PSn whereand u∃n(X) =(cid:14)10if X (cid:11)= ∅,otherwise.First, we use u∃n and a utility function with maximal range to compare L(pcubes, R+, max) with L(pcubes, R, (cid:2)). Thisresult highlights the difference between max and sum as aggregators.Theorem 48. L(pcubes, R+, max) ⊥ L(pcubes, R, (cid:2)).Proof. ((cid:4)) The family uL(pcubes, R, (cid:2)).L(pcubes, R, (cid:2)).(cid:5)In L(pcubes, R+, max), u∃n was shown in the proof of [10, Theorem 4.11] to have exponential representations inn is represented by G = {(p, 1) | p ∈ PS}. Therefore L(pcubes, R+, max) (cid:4)∃((cid:5)) Let un( X) =ai ∈ X 2i . Then | ran un| = 2n, and so if G max represents un, then by Theorem 24, |G max| (cid:2) 2n. InL(atoms, R+, (cid:2)), we have G(cid:2) = {(ai, 2i) | 0 (cid:3) i < n} which represents un. Hence L(pcubes, R+, max) (cid:5) L(pcubes, R, (cid:2)). (cid:2)We use u∀n to arrive at a similar result for L(pcubes, R+, max) and L(pclauses, R, (cid:2)):Theorem 49. L(pcubes, R+, max) ⊥ L(pclauses, R, (cid:2)).Proof. ((cid:4)) The family uL(pclauses, R, (cid:2)). In L(pcubes, R+, max), u(cid:5)∀n is represented by {(PS, 1)}.∀n was shown in the proof of [10, Theorem 4.10] to have exponential representations in the language(cid:2)((cid:5)) Let un( X) =ai ∈ X 2i . Then | ran un| = 2n, and so if G max represents un, then by Theorem 24, |G max| (cid:2) 2n. InL(atoms, R+, (cid:2)), we have G(cid:2) = {(ai, 2i) | 0 (cid:3) i < n} which represents un. Hence L(pcubes, R+, max) (cid:4) L(pclauses, R, (cid:2)). (cid:2)The next two results are examples of how cross-aggregator succinctness may be surprising. The languages in questionhave very little expressive overlap, which is the underlying reason for these results. First, we show that the austere languageL(atoms, R, max) is strictly more succinct than the seemingly-richer L(pcubes, R, (cid:2)):Theorem 50. L(pcubes, R, (cid:2)) ≺ L(atoms, R, max).Proof. U (atoms, R, max) corresponds to the class of unit-demand utility functions. Every unit-demand utility function u isexpressible linearly in the language L(atoms, R, max) as {(a, u(a))}a∈PS . In L(pcubes, R, (cid:2)) (which is fully expressive andhas uniqueness, cf. [10, Theorem 3.2 and Corollary 3.7]), u is represented by {(X ) | X ⊆ PS} whereX, w(cid:2)(cid:2)(cid:2)wX= (−1)| X|+1 mina∈ Xu(a).For any unit-demand u which is also single-minded (i.e., exactly one a ∈ PS is such that u(a) (cid:11)= 0), it is the case thatG = {(a, u(a))}, the same as in L(atoms, R, max). For non-single-minded u, let X ⊆ PS be the items which u assigns(cid:2)∃n, which is the familynonzero value. Then G will contain a nonzero weight for wof simple unit-demand utility functions, we have that representations in L(pcubes, R, (cid:2)) are exponential in |PS|. (cid:2)Y whenever Y ⊆ X . So, for the family uNext, we present a result similar to Theorem 50, but with the aggregators reversed. It may at first seem surprising to findthat there is a language with a natural definition which is strictly less succinct than the extremely limited L(atoms, R+, (cid:2)),but we get this result because max languages are poor at representing modular utility functions.Theorem 51. L(cubes, R+, max) ≺ L(atoms, R+, (cid:2)).1240J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246Proof. ((cid:28)) From [10, Corollary 3.8] we have that U (atoms, R+, (cid:2)) is the class of normalized nonnegative modular utilityfunctions. From Theorem 16, U (cubes, R+, max) is the class of nonnegative monotone utility functions, so L(atoms, R+, (cid:2))is the expressive intersection of the two languages. Every representation in L(atoms, R+, (cid:2)) is linear in |PS|. If u({a}) (cid:2) 0,then the atom a will appear somewhere in any representation of u in L(cubes, R+, max), so no representations which growlogarithmically in |PS| are possible there.((cid:5)) Consider the family of utility functions u( X) = | X|. In L(atoms, R+, (cid:2)), u is represented by {(a, 1) | X ∈ PS}, whichX, | X|) | X ⊆ PS}, which is exponentialis linear in |PS|, while the unique representation in L(cubes, R+, max) is {(in |PS|. (cid:2)(cid:2)Finally, we compare L(pclauses, R, (cid:2)) and L(atoms, R, max). A feature of interest here is that we establish a succinctnessgap which falls below the discriminating power of our succinctness relation, since complex unit-demand valuations arelinearly representable in L(atoms, R, max), but the best representations of the same are quadratic in L(pclauses, R, (cid:2)).Theorem 52. L(pclauses, R, (cid:2)) ∼ L(atoms, R, max).Proof. Recall that U (atoms, R, max) is the class of unit-demand utility functions. Simple unit-demand utility functions areexpressible linearly in L(pclauses, R, (cid:2)) as {(PS, 1)}. Consider complex unit-demand utility functions u (where itemsmay differ in value but the value of a bundle is the value of the best item contained in it) expressed in L(pclauses, R, (cid:2)).Without loss of generality, suppose that the items are ordered a1 (cid:3) · · · (cid:3) an in value. Then(cid:3)(cid:6)(cid:7)(cid:30)(cid:9)(cid:10)PS \ {a1, . . . , ai−1}, u(ai) − u(ai−1)1(cid:2)i(cid:2)nis the unique minimal representative of u in L(pclauses, R, (cid:2)), containing n(n−1)2atoms. (cid:2)We are now in position to demonstrate why the more general definition of succinctness (subscripted by the comparisonclass) is needed: In Theorem 50 we showed that L(pcubes, R, (cid:2)) ≺ L(atoms, R, max), while in Theorem 51, we showed thatL(cubes, R+, max) ≺ L(atoms, R+, (cid:2)). Furthermore, L(pcubes, R, (cid:2)) ∼ L(atoms, R+, (cid:2)), since the expressive intersection ofthe two languages is the whole of the latter, and in the latter every representation is small. Finally, L(atoms, R, max) ∼L(cubes, R+, max) because their expressive intersection is the class of nonnegative unit-demand utility functions, whichhave small representations in both languages. We now have the following situation:L(pcubes, R, (cid:2)) ≺ L(atoms, R, max)∼L(atoms, R+∼, (cid:2)) # L(cubes, R+, max)From this it can be seen that the unsubscripted succinctness relation is not transitive. This comes about because no twopairs of these four languages have the same expressive intersection. Because the expressive intersection of the languagescan shift from comparison to comparison, we must make explicit the class of utility functions over which the comparisonis being made if we wish to do more than pairwise comparison.7. The complexity of individual utility maximization and minimizationIn this section, we analyze the effect that restrictions on goalbases have on the complexity of answering questions aboutthe utility functions they represent, focusing specifically on the decision problems max-util and min-util. The problemmax-util asks whether there is any model producing at least a specified amount of utility. The problem min-util is thepessimal version of max-util, which asks whether an agent will always obtain at least some specified amount of utility, nomatter what model he finds himself in.7.1. The complexity of max-utilThe decision problem max-util is the problem of determining whether an agent, given his preferences, can attain atleast some specified amount of utility.Definition 53 (The decision problem max-util). The decision problem max-util(Φ, W , F ) is defined as: Given a goalbaseG ∈ L(Φ, W , F ) and an integer K , is there a model M ∈ 2where uG,F (M) (cid:2) K ?PSNote that we consider only cases where the set of weights W is a subset of Q, in order to avoid issues of how torepresent irrational weights.Who (if anyone) needs to solve max-util depends on the context in which our preference representation languages arebeing applied. Take auctions, for example: The Winner Determination Problem in combinatorial auctions [4] is the problemof allocating goods to bidders while maximizing revenue. Whether max-util needs to be solved by the auctioneer in orderJ. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461241to determine which bidders win which goods depends on the concrete algorithm the auctioneer uses. Even in cases where itis not necessary to solve max-util in order to solve the Winner Determination Problem, the complexity of max-util providesa lower bound on how complex the Winner Determination Problem can be: Observe that in the (degenerate) single-biddercase, the two problems coincide. If only one bidder shows up to the auction, then determining which items he wins isprecisely the same as finding his optimal model. Therefore, the Winner Determination Problem can never be easier thanmax-util, as it contains max-util as a subproblem. Finally, for an agent himself it is useful to solve max-util if he buildshis bids not directly from an explicitly represented utility function, but instead from constraints or through elicitation. Inthat case, the agent may only be able to find his optimal model by first solving max-util.In contrast to the hardness results we have for max-util for most sum languages ([2, Section 5.5.1]; [10]), solvingmax-util for any max language is trivial:Theorem 54. max-util(forms, Q, max) ∈ TIME(n), when restricted to goalbases containing only satisfiable formulas.Proof. An algorithm solving max-util for any max language simply has to iterate over the formulas in the goalbase, answeraffirmatively as soon as it encounters a (ϕ, w) for which w (cid:2) K , and answer negatively otherwise. (cid:2)Thisresultrequirescomplexitysome discussion.formulas,max-util(forms, Q, max) is NP-complete, as lifting this restriction imposes the additional requirement of checking whetherϕ is satisfiable whenever w (cid:2) K .7 Second (assuming that we retain the satisfiability condition), we must be careful abouthow we interpret the low complexity of max-util. Note that our algorithm does not compute the actual model M yieldingthe desired level of utility; it only checks whether such an M exists. If we also require M itself, then we still need to extracta satisfying model M from some goal (ϕ, w) where w (cid:2) K .First, withoutrestriction tosatisfiabletheThe problem of finding a satisfying assignment for an arbitrary formula that is already known to be satisfiable is probablystill intractable: fsat, which is the function problem version of sat, is complete for FNP, the extension of NP to functionproblems. Given a formula ϕ, fsat will return either a satisfying model M, or “no” if there is no satisfying model. If wesomehow know already that ϕ is satisfiable, then we know that fsat will always give us a model instead of answering “no”.Call this subproblem of fsat where the input formulas are guaranteed to be satisfiable tfsat (for “total” fsat). tfsat is amember of the class TFNP, which is the subset of FNP where all problems are total—that is to say, these problems neverreturn “no” as an answer. Clearly, FP ⊆ TFNP ⊆ FNP, but no more beyond that is known. If FP = TFNP, this would implythat P = NP ∩ coNP, which is considered unlikely [29]. Hence, it is likely that there is no polynomial algorithm for findinga satisfying assignment for an arbitrary known-satisfiable formula, so in general, the low complexity of max-util for maxlanguages does not imply low complexity of the corresponding function problem which finds a witness.In contrast to this observation, for sum languages, we are not aware of any case where the complexity of checkingexistence of an alternative giving at least K utility and computing that alternative differ, so long as we restrict ourselves tolanguages closed under substitution of logical constants.8 For languages with an NP-complete max-util this is a non-issue;for all sum languages with polynomial max-util the proofs are constructive and directly show the computation of the topalternative to be polynomial.Finally, we stress that both limitations of Theorem 54—the assumption that all goals are satisfiable, and the difference forL(forms, W , max) between solving max-util and actually computing the best alternative—vanish for certain, more restrictedmax languages. For both cubes and clauses (and any of their sublanguages) determining the satisfiability of single formulasis trivial; as a result, max-util(cubes, W , max) and max-util(clauses, W , max) are unconditionally in P. Finding a model fora single satisfiable cube or clause is also trivial, which makes computing the best alternative simple for these languages aswell.7.2. The complexity of min-utilSo far in this section, we have considered optimal models, but what of pessimal models? Just as an agent may wish toknow how well he can do, he may wish to know how poorly, as well. min-util can be seen as the pessimistic dual of theoptimistic max-util, in the sense that it checks lower bounds instead of upper bounds.Definition 55 (The decision problem min-util). The decision problem min-util(Φ, W , F ) is defined as: Given a goalbase G ∈L(Φ, W , F ) and an integer K , are all models M ∈ 2such that uG,F (M) (cid:2) K ?PS(Note that min-util is not the complement of max-util: This can easily be seen from the problem instance ${((cid:4), 1)}, 1%,which is a member of both decision problems, for many different languages and choices of aggregators.)We have seen in [2, Section 5.5] that for sum languages, min-util behaves similarly to max-util. However, this is not thecase for max languages:7 By taking satisfiability as a precondition, we make max-util(forms, Q, max) into a promise problem, as discussed by Even et al. [28].8 For languages which are not closed under substitution of logical constants, it is not always the case that the decision problem can be used to solve thefunction problem. For a discussion of this, see [30] and [2, Section 5.7.1].1242J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246ˆp1, . . . , ˆpn := 1, ˆw 1, . . . , ˆwn := −∞for all ((cid:8), w) ∈ G doif (cid:8) = pi and w (cid:3) ˆw i thenelse if (cid:8) = ¬pi and w > ˆw i thenˆpi := 1, ˆw i := wˆpi := 0, ˆw i := wend ifend forM := {pi ∈ PS | ˆpi = 1}Fig. 3. An algorithm for finding maximal optimal models for G ∈ L(literals, Q, max).Theorem 56. min-util(forms, Q, max) is coNP-complete.Proof. For coNP membership: Any purported counterexample model M is polynomially checkable, simply evaluatinguG,max(M) to see if it is less than K .For coNP-hardness: Let ϕ be an instance of the well-known coNP-hard problem unsat, and ${(¬ϕ, 1)}, 1% an instance ofmin-util(forms, Q, max). It is easy to see that if ϕ is not satisfiable, then u{(¬ϕ,1)}(M) = 1 for all models M, and vice versa.Hence unsat reduces to min-util(forms, Q, max). (cid:2)If we restrict the goalbases in our inputs to those containing no superfluous formulas, however, we get a more favorableresult for min-util(forms, Q, max):Theorem 57. min-util(forms, Q, max) ∈ TIME(n), when restricted to goalbases containing no superfluous formulas.Proof. Since no (ϕ, w) ∈ G is superfluous, any such ϕ will determine the value of uG (M) for some model M. Hence, thevalue of the worst model may be found simply by identifying the (ϕ, w) with the least w, which can be done by iteratinga single time over G. If that w (cid:2) K , the min-util instance is positive, and negative otherwise. (cid:2)As with the sum languages over the same sets of formulas, there are some max languages for which min-util remainspolynomial in the absence of any further restrictions. This may be seen in the following three theorems.Theorem 58. min-util(pforms, Q, max) ∈ TIME(n).Proof. For any instance $G, K %, we know that uG is monotone. Hence, ∅ is a minimally-valued model. Therefore, $G, K % ∈min-util(pforms, Q, max) iff uG (∅) (cid:2) K , so all that is required to decide the instance is reading G once and comparing tworationals. (cid:2)Theorem 59. min-util(literals, Q, max) ∈ TIME(n).Proof. Let $G, K % be an instance. We present in Fig. 3 a linear-time algorithm for building the maximal optimal model M(maximal in the sense that, among all optimal models, it has the most true atoms). For each pi ∈ PS, ˆw i tracks the value ofthe best weighted literal containing pi seen so far, while ˆpi tracks whether that literal was positive or negative. Because Mis the maximal optimal model, it follows that PS \ M is the minimal pessimal model, since the values of items are mutuallyindependent in uG . Finally, we check whether uG (PS \ M) (cid:2) K . (cid:2)Theorem 60. min-util(cubes, Q, max) ∈ TIME(n2).Proof. We argue that it is quadratic to identify and remove superfluous formulas from goalbases in L(cubes, Q, max); onceG contains no superfluous formulas, we may invoke Theorem 57 to finish deciding the reduced instance.First, observe that when X, Y , X(cid:7)(cid:8)(cid:8)(cid:7)(cid:8)(cid:9)|(cid:10)X ∧¬Y→(cid:3), Y(cid:3) ⊆ PS,(cid:8)(cid:3) ∧X(cid:9)(cid:3)⇐⇒ X(cid:3) ⊆ X and Y(cid:3) ⊆ Y , or X ∩ Y (cid:11)= ∅.¬YThat is to say, testing whether one cube implies another involves only checking whether some sets intersect or are supersetsof some other sets, all of which are O (n log n) operations. This means we can find and remove superfluous cubes from anyG ∈ L(cubes, Q, max) as follows:X ∧For each pair of cubes ((cid:2)(cid:3) ⊆ Y or X ∩ Y (cid:11)= ∅,(cid:3) > w and either X(cid:3) ⊆ X and Y(cid:3)) ∈ G, if w¬Y , w), ((cid:3), w¬Y(cid:3) ∧(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)Xthen (X ∧¬Y , w) is superfluous; remove it from G.J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461243Table 2Summary of complexity results for max-util and min-util.Decision problemforms Q maxmax-utilmin-util pforms Q maxliterals Q maxmin-utilcubes Q maxmin-utilforms Q maxmin-utilComplexityTIME(n)TIME(n)TIME(n)TIME(n2)coNP-completeThis algorithm is quadratic in |G|. Once G contains no superfluous formulas, the least remaining weight w may be foundand checked for whether w (cid:2) K . (cid:2)It is worth noting the dramatic difference the choice of aggregator makes for min-util over cubes languages: From [2,Theorem 5.5.21], we have that min-util is already coNP-complete for positively-weighted 2-cubes using summation, whilehere we have shown that min-util for arbitrarily-weighted cubes of any length remains polynomial when aggregating withmax.Theorem 54 shows that max-util is linear for all max languages (when only satisfiable formulas are given as input).The general case of min-util is surprisingly hard, being coNP-complete. The full language L(forms, Q, max) is perhaps moresuitable for optimists interested in how much utility they may hope to achieve, rather than pessimists interested in howmuch utility they are guaranteed. On the other hand, as there is no difference in expressivity between L(cubes, Q, max) andL(forms, Q, max) (see Corollary 12), nothing compels us to use the additional formulas we gain by permitting disjunction;and in fact it seems that we are punished with additional complexity for using disjunction in this case. See Table 2 for asummary of results for max-util and min-util.8. The complexity of collective utility maximizationCollective utility maximization is the central problem we face when attempting to allocate indivisible goods amonga group of agents. The goal may range from maximizing revenue, as with auctions (or minimizing cost, as with reverseauctions), to maximizing overall satisfaction, as with task allocation. Determining how to use the limited capabilities of asatellite to satisfy each space agency which contributed to its cost [31,32]; selling flowers or bonds to bidders at auction;assigning radio spectra to communications operators, routes to bus operators [33], and take-off and landing slots to airlines[34]—all of these are resource allocation problems where we want to maximize collective utility according to some measure.When there are several agents, each with a utility function encoded using the same language, then the collective utilitymaximization problem (max-cuf), the problem of finding a solution maximizing collective utility, is of interest. By “solution”we mean a partition of the set of propositional variables among the agents, thereby fixing a model for each of them. Thisdefinition is natural, for instance, if we think of variables as goods.9 (For example, if there are three goods a, b, c and twoagents 1, 2, then one possible allocation is to assign goods a and b to agent 1 and good c to agent 2.) In this section, wefocus on the complexity of max-cuf for several max languages and notions of collective utility.Now, we introduce the definitions we need for discussing collective utility maximization. A collective utility function(CUF) [13] fulfills the same role for groups of agents as the aggregation function does for individuals, viz., mapping multipleutilities to a single, aggregated value:Definition 61 (Collective utility functions). A collective utility function (CUF) is a mapping σ : R∗ → R.Since any function from tuples of reals to reals is a CUF, there are a great diversity of CUFs from which to choose [13].In practice, however the four CUFs most frequently encountered are the egalitarian, utilitarian, elitist, and Nash productcollective utility functions:Definition 62 (Common collective utility functions).• σ = max is the elitist collective utility function.• σ = min is the egalitarian collective utility function.• σ = (cid:2) is the utilitarian collective utility function.• σ = (cid:10) is the Nash product collective utility function.The utilitarian collective utility of an alternative is the sum of the individual utilities. Optimizing with respect to utilitar-ian collective utility is equivalent to the Winner Determination Problem in combinatorial auctions, where it is interpreted as9 Other types of solutions, such as finding a single model which maximizes collective utility, are also of interest, but shall not be considered here. Thecombinatorial vote problem of Lang [26] is exactly this problem, in the context of voting.1244J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246finding an allocation of goods to bidders that would maximize the sum of the prices offered [35]. The elitist and egalitarianCUFs are similar, but focus on different individuals as salient for collective utility: The egalitarian collective utility is theutility of the agent worst off, while the elitist collective utility is the utility of the agent best off. (A finer-grained version ofegalitarian collective utility, the leximin ordering was advocated by Rawls [36]; another possibility is to focus on the utility ofsome agent other than the best or worst off, for example, the median agent, as the median-rank dictator CUF does.) Finally,the Nash product, the product of individual utilities, attempts to strike a balance between fairness and total utility.10Now we give a formal definition of max-cuf, which is similar to the definition of max-util, but lifted from an individualagent to a group of agents:Definition 63 (The decision problem max-cuf). The decision problem max-cuf(Φ, W , F , σ ) for n agents is defined as: Givengoalbases G 1, . . . , Gn ∈ L(Φ, W , F ), a collective utility function σ , and an integer K , is there a partition $M1, . . . , Mn% of PSsuch that σ (uG 1,F (M1), . . . , uGn,F (Mn)) (cid:2) K ?First, we state two lemmas bounding the complexity of max-cuf:Lemma 64. max-cuf(Φ, W , F , σ ) ∈ NP whenever F and σ are polynomially-computable functions.This holds because whenever F and σ are polynomially-computable functions, we can in all cases easily check whethera given allocation does in fact produce at least K utility.Before proceeding to our next lemma, we need to define a reasonableness notion for individual and collective utilityfunctions.Definition 65 (Singleton consistency). A function f : R∗ → R without fixed arity is singleton consistent ifα ∈ R.f (α) = α for allAny reasonable individual aggregator or collective utility function will be singleton consistent. For individual aggregators,singleton consistency means that an agent having exactly one satisfied weighted formula (ϕ, w) has utility w. For collectiveutility functions, singleton consistency means that a single-agent society has the same utility as its sole member. Singletonconsistent functions give the intuitively right answers for the utility of single agents stranded on desert islands. All of thefunctions we consider here—min, max, sum, and product—are singleton consistent.Lemma 66. max-cuf(Φ, W , F , σ ) is at least as hard as max-util(Φ, W , F ) for any singleton-consistent σ .Here, singleton consistency ensures that σ behaves as the identity function when only a single agent is involved, andhence for such σ max-cuf and max-util coincide.max-cuf is easy for max languages when using the elitist collective utility function, for the same reasons as those statedin support of Theorem 54.Fact 67. max-cuf(forms, Q, max, max) ∈ TIME(n) so long as goalbases contain only satisfiable formulas.However, when we switch to other common CUFs, max-cuf becomes hard even for severely restricted languages:Theorem 68. max-cuf(2-pcubes, {0, 1}, max, σ ) is NP-complete for σ ∈ {(cid:2), (cid:10), min}.Proof. For the first case, σ = (cid:2), we follow van Hoesel and Müller [37, Theorem 2] by reducing the known NP-completeproblem tripartite matching [38] to max-cuf(2-pcubes, {0, 1}, max, (cid:2)). Instances of tripartite matching are $ X, Y , Z , T %,where the sets X, Y , Z are such that | X| = |Y | = | Z | and T ⊆ X × Y × Z . An instance $ X, Y , Z , T % is a member iff there is anM ⊆ T which is a perfect matching (i.e., each x ∈ X , y ∈ Y , and z ∈ Z appears in exactly one triple in M).For the reduction, we interpret the set X as agents and the sets Y and Z as items appearing in 2-pcubes. For each(x, y, z) ∈ T , put ( y ∧ z, 1) ∈ G x. Also put ((cid:4), 0) ∈ G x. Let K = | X|. The only way to achieve K utility by allocating Y ∪ Zto the agents in X is to ensure that at least one (non-(cid:4)) goal is satisfied from each G x; conversely, satisfying more thanone (non-(cid:4)) goal in any G x does not increase collective utility, since the individual aggregator is max. Hence $ X, Y , Z , T % ∈tripartite matching iff ${G x}x∈ X , | X|% ∈ max-cuf(2-spcubes, {0, 1}, max, (cid:2)).For the other cases, use the same reduction from tripartite matching but let K = 1. (cid:2)10 Note that all of the collective utility functions we consider are associative and commutative, so aggregating a tuple of individual utilities is the same asaggregating a multiset of individual utilities. Functions which are nonassociative or noncommutative tend to be less interesting as CUFs, because they failto treat all agents equally.J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–12461245Table 3Summary of complexity results for max-cuf.Decision problemmax-cufmax-cuf 2-spcubesmax-cuf 2-spcubesmax-cuf 2-pcubessatisfiable ϕ Q{1}{1}{0, 1} max (cid:10)max maxmax (cid:2)max minComplexityTIME(n)NP-completeNP-completeNP-completeThis result subsumes parts of the NP-completeness results of Bouveret et al. [39, Fig. 1] and Bouveret [40, Propo-sition 4.22] for σ = min. As they do not consider negation, their results (by a reduction from set packing) apply tomax-cuf(pforms, Q, max, min), which contains the problem max-cuf(2-spcubes, {0, 1}, max, min) that we have just provedto be NP-complete. Notice also that the presence of ((cid:4), 0) in each goalbase is necessary only in the σ = (cid:10) case.11 For theother two cases including ((cid:4), 0) is safe but unnecessary; for (cid:2) and min we could state a slightly stronger result using only2-spcubes and W = {1}, leaving the proof otherwise unchanged.max-cuf is significantly harder than max-util. There are numerous languages for which max-util is polynomial, butwhere max-cuf is NP-complete for some collective utility function. For example, Theorem 68 shows that a tiny fragment ofa language with positive formulas and positive weights already has an NP-complete max-cuf problem, despite that max-utilis trivial over the same languages. See Table 3 for a summary of results for max-cuf.9. Conclusions and future workWe have analyzed the expressivity, succinctness and complexity of languages for representing utility functions that arebased on weighted propositional formulas aggregated by the max operator. Our results show that there are substantialdifferences in all three categories in comparison with languages using sum for aggregating weights [10].For expressivity, we were able to give a complete picture for the most important languages, in part because the inclusionof disjunction in max languages has no effect on expressivity, which cuts down the number of languages to consider.More fine-grained results could probably still be obtained by considering languages generated by specific weight sets or bylooking into formulas of limited length (although in some cases such results will be direct consequences of what is knownalready). Concerning relative succinctness, we have established all relationships between the max languages we consider,and have also given several results that show how they relate to selected sum languages. Additionally, we have exhibitedbounds on the absolute succinctness of max-aggregated goalbases formed using cubes and positive cubes. Lastly, concerningcomplexity: We have observed that finding an alternative maximizing individual utility (max-util) is computationally easyfor max languages for all practical purposes, while finding an alternative minimizing individual utility (min-util) rangesfrom linear to coNP-complete, depending on which formulas the language allows. We have then discussed to what extentknown results apply to our framework when analyzing the complexity of the problem of maximizing collective utility fora group of agents (max-cuf), and proved NP-completeness results for collective utility maximization in several restrictivelanguages.Some problems remain open. As mentioned before, we do not know the exact expressivity of the max languages withbounded formula length (L(k-cubes, R, max) and its positive sublanguages, for 1 < k < ω), and many cross-aggregator suc-cinctness results are still unresolved. The bounds on goalbase size for L(cubes, R, max) are not tight in all cases, and couldbe improved. Also of interest is sharpening the boundary between the languages for which max-cuf is NP-complete andthose for which it is only polynomial—for example, when using the Nash product as the collective utility function, how littleexpressive power may we remove from L(2-spcubes, {0, 1}, max) before its max-cuf problem becomes easier, or how muchmay we add to L(atoms, {0, 1}, max) before its max-cuf becomes harder?Finally, there looms the larger question of whether the properties goalbase languages have by virtue of their aggregatorsmay be tackled in a more general way, rather than by doing once for each aggregator the painstaking classification workdone here for max and in [10] for (cid:2). Unfortunately, max and (cid:2) differ enough that we do not yet see how to generalizeover them; perhaps it would be easier to generalize over max and min, or (cid:2) and (cid:10), as these pairs of aggregators havemore in common than max and (cid:2) do.References[1] J. Uckelman, U. Endriss, Preference modeling by weighted goals with max aggregation, in: G. Brewka, J. Lang (Eds.), Proceedings of the 11th Interna-tional Conference on Principles of Knowledge Representation and Reasoning (KR-2008), 2008, pp. 579–587.[2] J. Uckelman, More than the sum of its parts: Compact preference representation over combinatorial domains, PhD thesis, University of Amsterdam,ILLC Publication DS-2009-12, 2009.[3] J. Goldsmith, U. Junker, Preference handling for artificial intelligence (editorial), AI Magazine 29 (4) (2008) 9–12.[4] P. Cramton, Y. Shoham, R. Steinberg (Eds.), Combinatorial Auctions, MIT Press, 2006.11 Suppose that (cid:4) is left unweighted. Because max ∅ = −∞, an agent who has no satisfied formulas in his goalbase will have a utility of −∞. If there arean even number of such agents and σ = (cid:10), then the collective utility will be −∞ × · · · × −∞ = ∞, which isn’t the desired result.1246J. Uckelman, U. Endriss / Artificial Intelligence 174 (2010) 1222–1246[5] Y. Chevaleyre, P.E. Dunne, U. Endriss, J. Lang, M. Lemaître, N. Maudet, J. Padget, S. Phelps, J.A. Rodríguez-Aguilar, P. Sousa, Issues in multiagent resourceallocation, Informatica 30 (2006) 3–31.[6] G. Pinkas, Propositional nonmonotonic reasoning and inconsistency in symmetric neural networks, in: J. Mylopoulos, R. Reiter (Eds.), Proceedings ofthe 12th International Joint Conference on Artificial Intelligence (IJCAI-1991), Morgan Kaufmann, 1991, pp. 525–531.[7] C. Lafage, J. Lang, Logical representation of preferences for group decision making, in: A.G. Cohn, F. Giunchiglia, B. Selman (Eds.), Proceedings of the7th International Conference on Principles of Knowledge Representation and Reasoning (KR-2000), Morgan Kaufmann, 2000, pp. 457–468.[8] S. Coste-Marquis, J. Lang, P. Liberatore, P. Marquis, Expressive power and succinctness of propositional languages for preference representation, in:D. Dubois, C.A. Welty, M.-A. Williams (Eds.), Principles of Knowledge Representation and Reasoning: Proceedings of the Ninth International Conference(KR-2004), Whistler, Canada, June 2–5, 2004, AAAI Press, 2004, pp. 203–212.[9] Y. Chevaleyre, U. Endriss, J. Lang, Expressive power of weighted propositional formulas for cardinal preference modelling, in: P. Doherty, J. Mylopoulos,C.A. Welty (Eds.), Proceedings, Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR-2006), AAAI Press, 2006,pp. 145–152.[10] J. Uckelman, Y. Chevaleyre, U. Endriss, J. Lang, Representing utility functions via weighted goals, Mathematical Logic Quarterly 55 (4) (2009) 341–361.[11] A. Ragone, T.D. Noia, F.M. Donini, E.D. Sciascio, M.P. Wellman, Computing utility from weighted description logic preference formulas, in: DeclarativeAgent Languages and Technologies VII (DALT-2009), in: Lecture Notes in Computer Science, vol. 5948, Springer, 2009, pp. 158–173.[12] A. Ragone, T.D. Noia, F.M. Donini, E.D. Sciascio, M.P. Wellman, Weighted description logics preference formulas for multiattribute negotiation, in:Scalable Uncertainty Management. Third International Conference, SUM 2009, Proceedings, Washington, DC, USA, September 28–30, 2009, in: LectureNotes in Computer Science, vol. 5785, Springer, 2009, pp. 193–205.[13] H. Moulin, Axioms of Cooperative Decision Making, Econometric Society Monographs, vol. 15, Cambridge University Press, 1988.[14] C. Boutilier, R.I. Brafman, C. Domshlak, H.H. Hoos, D. Poole, CP-nets: A tool for representing and reasoning with conditional ceteris paribus preferencestatements, Journal of Artificial Intelligence Research (JAIR) 21 (2004) 135–191.[15] F. Rossi, K.B. Venable, T. Walsh, mCP nets: Representing and reasoning with preferences of multiple agents, in: D.L. McGuinness, G. Ferguson (Eds.),Proceedings of the Nineteenth National Conference on Artificial Intelligence, Sixteenth Conference on Innovative Applications of Artificial Intelligence,San Jose, California, USA, July 25–29, 2004, AAAI Press/The MIT Press, 2004, pp. 729–734.[16] J. Lang, L. Xia, Sequential composition of voting rules in multi-issue domains, Mathematical Social Sciences 57 (3) (2009) 304–324.[17] J. Goldsmith, J. Lang, M. Truszczy ´nski, N. Wilson, The computational complexity of dominance and consistency in CP-nets, Journal of Artificial Intelli-gence Research (JAIR) 33 (2008) 403–432.[18] P.C. Fishburn, Utility Theory for Decision Making, John Wiley & Sons, 1970.[19] C. Gonzales, P. Perny, GAI networks for utility elicitation, in: D. Dubois, C.A. Welty, M.-A. Williams (Eds.), Principles of Knowledge Representation andReasoning: Proceedings of the Ninth International Conference (KR-2004), Whistler, Canada, June 2–5, 2004, AAAI Press, 2004, pp. 224–234.[20] R.I. Brafman, C. Domshlak, T. Kogan, Compact value-function representations for qualitative preferences, in: D.M. Chickering, J.Y. Halpern (Eds.), UAI ’04,Proceedings of the 20th Conference Uncertainty in Artificial Intelligence, Banff, Canada, July 7–11, 2004, AUAI Press, 2004, pp. 51–59.[21] S. Ieong, Y. Shoham, Marginal contribution nets: A compact representation scheme for coalitional games, in: J. Riedl, M.J. Kearns, M.K. Reiter (Eds.),Proceedings, 6th ACM Conference on Electronic Commerce (EC-2005), ACM Press, 2005, pp. 193–202.[22] E. Elkind, L.A. Goldberg, P.W. Goldberg, M. Wooldridge, A tractable and expressive class of marginal contribution nets and its applications, MathematicalLogic Quarterly 55 (4) (2009) 362–376.[23] N. Nisan, Bidding languages for combinatorial auctions, in: P. Cramton, Y. Shoham, R. Steinberg (Eds.), Combinatorial Auctions, MIT Press, 2006, pp. 215–232.[24] C. Boutilier, H.H. Hoos, Bidding languages for combinatorial auctions, in: B. Nebel (Ed.), Proceedings of the Seventeenth International Joint Conferenceon Artificial Intelligence, IJCAI 2001, Seattle, Washington, USA, August 4–10, 2001, Morgan Kaufmann, 2001, pp. 1211–1217.[25] C. Boutilier, Solving concisely expressed combinatorial auction problems, in: Proceedings of the Eighteenth National Conference on Artificial Intelligenceand Fourteenth Conference on Innovative Applications of Artificial Intelligence (AAAI/IAAI 2002), AAAI Press, 2002.[26] J. Lang, Logical preference representation and combinatorial vote, Annals of Mathematics and Artificial Intelligence 42 (1–3) (2004) 37–71.[27] M. Cadoli, F.M. Donini, P. Liberatore, M. Schaerf, Space efficiency of propositional knowledge representation formalisms, Journal of Artificial IntelligenceResearch (JAIR) 13 (2000) 1–31.[28] S. Even, A.L. Selman, Y. Yacobi, The complexity of promise problems with applications to public-key cryptography, Information and Control 61 (1984)159–173.[29] C.H. Papadimitriou, On the complexity of the parity argument and other inefficient proofs of existence, Journal of Computer and System Sciences 48 (3)(1994) 498–532.[30] J. Uckelman, A. Witzel, Logic-based preference languages with intermediate complexity, in: J. Chomicki, V. Conitzer, U. Junker, P. Perny (Eds.), Proceed-ings of the 4th Multidisciplinary Workshop on Advances in Preference Handling (MPREF-2008), AAAI Press, Chicago, 2008, pp. 123–127.[31] M. Lemaître, G. Verfaillie, N. Bataille, Exploiting a common property resource under a fairness constraint: a case study, in: T. Dean (Ed.), Proceedingsof the Sixteenth International Joint Conference on Artificial Intelligence (IJCAI 99), Morgan Kaufmann, 1999, pp. 206–211.[32] S. Bouveret, J. Lang, Efficiency and envy-freeness in fair division of indivisible goods: logical representation and complexity, Journal of Artificial Intelli-gence Research (JAIR) 32 (2008) 525–564.[33] E. Cantillon, M. Pesendorfer, Auctioning bus routes: The London experience, in: P. Cramton, Y. Shoham, R. Steinberg (Eds.), Combinatorial Auctions, MITPress, 2006, pp. 573–591.[34] M.O. Ball, G.L. Donohue, K. Hoffman, Auctions for the safe, efficient, and equitable allocation of airspace system resources, in: P. Cramton, Y. Shoham,R. Steinberg (Eds.), Combinatorial Auctions, MIT Press, 2006, pp. 507–538.[35] D. Lehmann, R. Müller, T. Sandholm, The winner determination problem, in: P. Cramton, Y. Shoham, R. Steinberg (Eds.), Combinatorial Auctions, MITPress, 2006, pp. 288–317.[36] J. Rawls, A Theory of Justice, Harvard University Press, 1971.[37] S. van Hoesel, R. Müller, Optimization in electronic markets: examples in combinatorial auctions, Netnomics 3 (1) (2001) 23–33.[38] R.M. Karp, Reducibility among combinatorial problems, in: R.E. Miller, J.W. Thatcher (Eds.), Complexity of Computer Computations, Plenum Press, 1972.[39] S. Bouveret, H. Fargier, J. Lang, M. Lemaître, Allocation of indivisible goods: a general model and some complexity results, in: F. Dignum, V. Dignum, S.Koenig, S. Kraus, M.P. Singh, M. Wooldridge (Eds.), 4th International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS 2005),Utrecht, The Netherlands, July 25–29, 2005, ACM, 2005, pp. 1309–1310.[40] S. Bouveret, Allocation et partage équitables de ressources indivisibles: modélisation, complexité et algorithmique, PhD thesis, Supaéro/University ofToulouse, 2007.