Artificial Intelligence 95 ( 1997) l-65 Artificial Intelligence Engineering and compiling planning domain models to promote validity and efficiency T.L. McCluskey *, J.M. Porteous The School of Computing and Mathematics, The University of Huddersjield, Queensgate. Huddersjield HDI 3DH, United Kingdom ’ Received July 1996; revised May 1997 Abstract This paper postulates a rigorous method for the construction of classical planning domain models. We describe, with the help of a non-trivial example, a tool-supported method for encoding such models. The method results in an “object-centred” specification of the domain that lifts the representation from the level of the literal to the level of the object. Thus, for example, operators are defined in terms of how they change the state of objects, and planning states are defined as amalgams of the objects’ states. The method features two classes of tools: for initial capture and validation of the domain model; and for operationalising the domain model (a process we call compilation) for later planning. Here we focus on compilation tools used to generate macros and goal orders to be utilised at plan generation time. We describe them in depth, and evaluate empirically their combined benefits in plan generation speed-up. The method’s main benefit is in helping the modeller to produce a tight, valid and operational domain model. It also has the potential benefits of (i) forcing a change of emphasis in classical planning research to encompass knowledge-based aspects of target planning domains in a system- atic manner, (ii) helping to bridge the gap between the research area of theoretical but unrealistic planning on the one hand, and “scruffy” but real-world planning on the other, (iii) a commitment to a knowledge representation form which allows powerful techniques for planning domain model validation and planning algorithm speed-up can be bound up into a tool-supported environment. @ 1997 Elsevier Science B.V. Keywords: Planning; Knowledge compilation; Domain modelling * Corresponding author. Email: ’ Email: julie@zeus.hud.ac.uk. lee@zeus.hud.ac.uk. 0004.3702/97/$17,00 PII SOOO4-3702(97)00034-9 @ 1997 Elsevier Science B.V. All rights reserved 2 ZL. McCluskey, J.M. Porteous/ArtiJicial Intelligence 95 (I 997) 1-65 1. Introduction 1.1. The problems of “knowledge sparse” planning Intelligence frameworks in Artificial structure, containing the relative performance has for decades concentrated into classical planning issues of planning algorithms. Recent work has concentrated planners of total-order versus partial-order [ 7,231, extending complexity of plan generation [25], and general, research has been dominated level of representation, on, for ex- [ 3,44,57], the expres- for planning theoretical by the use of the literal or propo- actions, as the formulae made up of these literals. Although en- action little commitment Research on theoretical ample, the inherent computational siveness of the classical model [ 311. This engines sition as the basic basic knowledge vironmental assumptions and the closed world characterise to a more elaborate knowledge structure has been made. In this paper we argue research issues edge acquisition from the syntactic “object”. Several issues have ners. that in isolation of knowl- this, there should be a move away level of the in classical planning and representation representational lines of argument and, to facilitate primitive of the literal, lead us to believe into account when making claims about Planning such as default persistence, should not be considered the classical approach, to the semantic that knowledge representational and operators instantaneous to be taken deterministic representing in general and Plan- causal planners planners. linear planners, Firstly, consider link partial-order the recent trend in AI Planning over a number of different planning research to analyse of the classical generative planner linear and partial-order suggested the computational to compare and results with Initial that they were more efficient redundancy these strategies can give wildly vary- In a similar rather total- or partial-order, we should concentrate on than match different planners for hybrid planners in different problem do- properties of different variations the efficiency tradeoffs between systematic than in part as a result of reducing results have been called into question, as fixed planning ing relative performance vein, some researchers have concluded than ponder over which is preferable, where off against each other, research [32] or different domain-independent mains the choice of optimal frameworks encodings. that even in the range of domains open to classical planning, and so we need to take advantage of domain strategy appears domain-dependent, focus on control strategies the wrong question: that we are asking strategy. So rather [ 551. We conclude to use a particular and mechanisms [3,39]. But classification for planning for domain it is best heuristics domains. research should Secondly, there is a need to fill the gap between clean [ 26,421. Researchers who are exploring of planning practical applications features of planning necessarily use simple domains intensive acquisition to the research scenario, (HCI, user and reliability issues. On the other hand real-world planning as well as planning and software experts-a in that many non-functional to be considered. issues have training. In making etc.), hardware and software constraints, to facilitate theoretically research and the abstract reasoning about search requires teams of both knowledge completely different “ball game” such as user factors time, response this system towards bridging requirements steps TL. McCluske)s J.M. Porteous/ArGjicial lnrelligence 95 (1997) l-65 3 gap we must be careful we keep within modelling planning step forward. that while moving away from the “knowledge the spectrum of “clean AI”. Hence we see a systematic domains, within a standard, broad representational sparse” stance to approach framework, as a Thirdly, work has shown how performance strategy of the same domain model. Some researchers have testified insignificant in performance can vary by using a fixed planning from seemingly that can result to a domain encoding. An example of this is given for the performance of the system in [ 24, p. 9161. Even results favouring one planner over another that or into some the same domain encoding may be flawed in that it is the particular encoding in the domain. Guidelines a planner, for encoding domains would at least put this encoding problem than something intrinsic rather with different encodings to the large differences changes PRODIGY/EBL using is favouring frameworks context. 1.2. Implications of introducing knowledge representation issues In introducing representational issues we have three phenomena to consider: is the and (ii), to (i), reality), software the model. to conform is supposed is supposed and validating language used to encode itself (a reality, or an imagined relational testing. Using then debugging the planning to capture a piece of reality (block to a theoretical model, or an outline algorithm, etc.), and so, unlike software, for the purposes of acceptance it with respect to be used with it. Whereas planning stacking, machine- criteria such as correctness (iii) as a framework, levels of cohesion and self-consistency in relational a real client one would need to have guidelines and in applications for this kind of construction. This is apparently not the case in AI planning their specification the domain (i) the symbolic domain model, and (ii) the representation (iii) creating Initially often as hard as debugging software domain model shop scheduling, are inappropriate one can devise guidelines for domain models databases) and metrics models and appear sparse and underdeveloped. 2 For example, [ 591, Weld equates a domain specification with a set of pre- and post condition operators, yet this form of definition alone leaves questions unanswered domain?“. More generally, one might those conditions on any valid state. Also, the way that domain models are constructed purposes of research evaluation ever given. (particularly and sufficient for the appears ad hoc as the reasons for an encoding are rarely and tests to capture like the concept and process of normalisation reasonably the closed world assumption) expect domain models to include necessary a valid initial state in the such as “what constitutes that have dominated in the literature-they incorporating languages involving (rather in In Fig. 1, we show the typical concerns of the modeller as model validation, expressive issues are also language used for interaction with the language, and ease of maintenance. Validation of the representation power of the specification to understandability linked * There has been some work in developing “realistic” planner representation languages (e.g. 1 lo] ) but not within the realms of Al planning, despite the move to more expressive languages such as ADL [ 461. 4 T.L. McCluskey, J.M. Porteous/Art@iul Intelligence 95 (1997) I-65 s MODELLER concerns include validat expressive power and maintenance of the model of the planning algorithm SHARED concerns include plan quality Fig. I Views of the domain model. Modeller INITIAL DOMAIN MODEL Tools: e.g. syntax, type and consistency checking COMPILABLE DOMAIN MODEL Tools: e.g. goal order, macro and abstraction hierarchy generators RUNNABLE DOMAIN MODEL Tools: e.g. random task generator and planner I “PROVEN” DOMAIN MODEL maintenance Fig. 2. The development of a domain model using tool support. of the input model are that it should planner, a concern cited in [ 291. From the planning algorithm’s point of view the typical lead to efficient and effective plan requirements generation. This generally entails that it is in some that can be separated out from the planning standard, simple format, and any processing input task has been done off line. Issues such as the understandability are not as important. On the other hand, although in isolation to separate out (plan quality, from the planner, some types of requirements for example, relies on both an accurate model and an effective planner). issues can be considered that it is as pre-compiled of the planner’s are difficult as possible, these TL. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) l-65 5 Tool support associated with these activities in the development tools feature have to be revised and tools re-applied provide a measure of insulation the final planning as a form of model compilation. of a model. At each stage, to the changed model. In particular, is essential, and in Fig. 2 we show where the domain model may tools should the domain model valid and making the use of tool support between making system efJicient. In this paper we emphasise tables systems language which Within planning, instances of planning the idea of using domain engineering that use knowledge of knowledge. The O-Plan system features operators with causal to tackle search problems to solve Rubic’s Cube problems producing macros, a form of domain engineering which “unwinds” [ 371. Also, there have been to prune search, but these have [ 171 has a rich domain is not new. For example, Korf’s use of macro features compilation macros from the structure of the original domain encoding many relied mainly on hand-coding specification typing, but [ 17, p. 581. This problem . . . “is a difficult cal planners where, “the designer of the problem appropriate initial domain model features domain specific heuristics encapsulated within descriptions. This coding up and maintenance by the lack of a standard operators. that the “actual coding up” (of operators) in some hierarchi- the engineer is “largely a black art” [ 36, p. 11. In other words, the the operator search during plan generation but the is also apparent space must manually that is exacerbated these form, and tool support for developing it is admitted by the authors information/precondition is difficult, a problem abstractions” which is certainly useful of these operators representational in reducing job” 1.3. A way forward This paper contains language It shows that a rigorous method for capturing the first steps towards a standard for classical planning domains, backed up by a set of standards requirements tool-supported method, and a the functional the model with respect domains within a domain model to to its fit with the domain and its efficiency when used to many opportunities leads representation for encodings. of classical planning improve at plan time. [ 7,8] and theoretical [ 361, complexity rely on them has been concerned with have relied on them formulations the level of the literal or classes rely [ 12,381. The restrictions In the past, classical planning proposition. Abstraction mechanisms to some extent on them attraction of this is the apparent generality of the approach, yet syntactic (such as having the domains manipulated Further, domains and behaviours: scheduling domains contain drills, shelves and cranes, etc. are often made. To us, involve objects which are the process of plan execution. to contain groups of objects which share common properties rooms, doors, boxes; job-shop trucks, that classical planners or otherwise lathes, components; warehouse worlds contain for example, STRIPS domains contain free terms or propositional are aimed at invariably their state function through change terms) tend To date there have been some attempts these have been example, an object-oriented largely aimed at the architectural but level. For approach has been used in robot planning, by Chang et al. to take an “object view” of planning rather than the conceptual 6 TL. McCluskey, J.M. Porteous/Artificial Intelligence 95 (1997) l-65 system information knowledge bases rather objects with ones in the knowledge base. These approaches on utilising object-oriented by exploiting object structure. [ 331 objects are to be represented [ 11 I, Green and Todd [ 281 and others. In these systems abstract about objects match unfamiliar concentrate generation planning quence of objects objects. This object-oriented junction with the reactive planner. Again, object-centred stractions and hierarchies our work is to exploit to domain modelling the 00 paradigm was used to from a knowledge base into families and to pattern seem to than carrying out plan reactive se- specialised are associated with are used in con- the into plan generation, but to restrict its use to the creation of ab- in the knowledge base. In contrast, one of the central aims of level approach knowledge base and the plan fragments this work does not seem to incorporate that results from adopting an object In Kazi’s proposed object-oriented the problem of plan generation hierarchy and plan fragments in classical planning. in an increasingly in an inheritance the regularity in tackling approach Overall, our approach could be summed up as providing a tool-supported method for domain modellers tools to operationalise subsequent planning). to engineer the capture of domain models and then use compilation the model In summary, is, translate (that form for the potential benefits of using the method are that: it into a more efficient l it allows domain models l tools can naturally be provided l it ensures the production to be created in a systematic fashion; to support each step of the method; of a tight domain model, e.g. the modeller must define the property of a valid state for a given domain and this can then be used to check, for example, of action representations; the operational consistency l it forces the domain modeller to focus attention on the semantic level of the object rather than the literal; l the tools help in maintenance is updated; model of the model since they can be re-run whenever the the first steps towards a standard object-centred represen- for classical planning domains, and this promises to provide a for analysis of the impact of variations of domain model representation language represents l the method tational framework on different plan generation In addition we have empirical strategies. evidence with the method are capable of producing more general benefit of the method may stem from the cross-fertilisation other areas of computing-our capture that the model compilation large speed-ups [41] and formal methods in software engineering approach [ 561. tools associated in plan generation. Finally, a of research from is influenced by our own work in requirements domain the model This paper is communicated in Section 2. Section 3 formalises as follows. The use of the method the method and for the method and for operationalising using a concepts and a domain models captured the method. This latter category of tools produces macros and goal orders and is In Section 5 we evaluate the method speed-up using a number of planning in Section 2. We present a review of related work our is organised non-trivial classical planning underlying properties range of tool support using the subject of Sections 4.1 and 4.2 respectively. evidence of plan generation showing empirical domains the one introduced including in Section 6, some extensions work in Section 8. it produces. Section 4 discusses in Section 7 before summarising to our approach TL. McChskey J.M. Porteous/Arttjicial Intelligence 95 (I 997) I-65 7 2. A tool-supported method for encoding classical planning domains In overview, the method we propose for encoding domain models is given below. Steps ners, produces a “runnable” model l-6 produce a “compilable” (see Fig. 2). for classical plan- domain model, whilst step 7 I. Initial requirements for the domain are described, in natural language and diagram- matic form. 2. The domain modeller identifies an object hierarchy in the domain, and that appear appropriate that reflects the natural group- for knowledge elicitation ings of objects and validation. The hierarchy is based on object classes which we call sorts. 3. A set of predicate descriptions denoting properties and relationships in the domain are defined. 4. For each sort in the domain whose state can be changed by the effect of an action that actual objects of that sort are (these are called dynamic sort can occupy are specified. Transition diagrams constructed. for each such dynamic the range of states sorts), 5. A set of state invariants in model based are constructed. These state invariants of software specifications formal of an invariant the validation, for the domain promotes and compilation development are analogous to (e.g. as in VDM the effectiveness of the domain those used [ 56]), The availability of tools model. 6. Operators that model to support affect states of an object class. The consistency of the operators the effect of actions are specified in terms of the way they is checked. 7. Compilation tools are used to provide a further degree of validation and to produce an efficient planning application. between requirements the different that the divisions loose and at any step, be the process would loop back to an earlier step. At each step, tools to help in can be used. It is only after the last step that Note should new uncovered, construction the planning domain would be ready to attach to a planner plan generation. for dynamic testing involving in the initial domain steps are fairly be discovered cross-checking or consistency encoding or bugs Each of these steps below with is explained is an elaborate form of the much-quoted the help of a non-trivial multi-robot [51], to the reader. We will call the actual STRIPS-worlds terminology should be familiar example. The domain and so the basic (imagined) reality DR”, and the symbolic model we create R”. 2.1. Initial domain description (step I) For the domain being captured, the initial requirements the kind of problems (central abstractions), brought about. A first attempt at a natural A diagram purposes, representing in Fig. 3. is shown a particular configuration should outline its main features to be solved and the ways that this can be language description of DR” is given below. of the domain, chosen for illustrative 8 l?L. McCluskey, J.M. Porteous/Art@cial Intelligence 95 (I 997) I-65 Legend: H P e e robot (harry) blue key red key Light (on) q Light (oft3 m bluedoor m B reddoor door closed and locked - - door closed and unlocked q boxS Fig. 3. DR3: an example configuration of a multi-robot domain model. to doors, domain, consists of a configuration of rooms, connected by “DR”, a multi-robot ‘n’ robots exist. Each robot has an arm which can be used various doors, wherein for pushing or carrying. Robots are therefore capable of opening doors, pushing through doors and next to other objects. Doors can be locked objects or unlocked with a key, and keys must be carried around locked doors or to lock unlocked doors. Each room has a light which must be turned on by a robot before objects can be found which doors they open. Changes actions of the robots. The planner so that all robots contribute initial running in it, and keys are colour coded to determine to the domain are brought about only by the is used to generate sequential controlling plans a desired state of the world from an to keep overall state. Robots should contribute costs down.” to producing to unlock in order to plans fairly An important issue is to focus on the use of the model and to analyse level of detail with respect that is being modelled at an appropriate reality the model. For example, in the robots’ world we will be interested involve moving boxes and robots to various locations, and moving between strategy at this stage (which for the PRODIGY planning descriptions to perform in plans that typically the colour coded keys rooms so that doors can be locked, unlocked or opened and closed. A useful for modelling domains [49] ) is to try and formulate example problems and teach someone solutions and to consider how you would is supplied amongst of their possible the guidelines the task. system the portion of to the use of ZL. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) l-65 9 Translating many questions encoded as part of the domain model such an outline regarding requirements into a precise model will reveal the model, and these will need to be answered and explicitly specification (in the operators and invariants). 2.2. Sort and object identification (step 2) Nouns used in the natural language description may indicate the sorts in the domain that model identifying methods collecting objects is being captured. We regard sorts is similar in software engineering. to identifying Sorts sorts together in primitive them as the model’s central abstractions- classes of objects in object-oriented themselves can be grouped hierarchically design by into a “supersort”. From DR” we identified the following sorts: sorts = (Room, Door, Box, Robot, Arm, Key, Light, Colour, Movableobj, Physical_obj). The first eight sorts are primitive, whereas the last two of the sorts are supersorts: Movable_obj = Box U Robot U Key, Physical_obj = Door U Arm U Movabledbj. identified, identifiers belonging the object (for example boxl, key2, door23). By convention, sort sort names and sort letter, and object identifiers will start with a lower case to each primitive After sorts have been are recorded variables will start with a capital letter. The set of object sorts. Primitive their objects are deemed Room and Colour to be static. All objects of a dynamic (static) objects. identifiers belonging is the union of its contained to a supersort sorts are described as being dynamic or static, depending on whether In R”, we chose sort are called dynamic state by the effects of actions. to change (static) sort has its own local state, which can be changed by actions The main characteristic of sorts, on which our methodology object of a dynamic domain. To distinguish these local states as substates. A complete, valid “planning identifiers object set of invariants and appropriate (described in step 5). (described substates a local state for some sort from a planning is based, is that each in the state, we will refer to state” is a mapping between to a in step 4) which conforms 2.3. Ident$cation of relationships and properties (step 3) in the natural and properties The verbs and verb phrases of the relationships also suggest effected). At this stage the domain modeller specifies predicate descriptors and verb phrases relevant problem language description give some indication (they the states of the different sorts and the way that changes of state can be for the verbs that appear is that every in terms of these to the planning problem; that the planner might be asked to solve should be describable a necessary condition on the language that is being captured in the domain model in the domain and properties that describe relationships IO TL. McCluskey, J.M. Porteous/Art@ciul Intelligence 95 (1997) l-65 relationships following properties are suggested: and properties. Considering our example domain R”, for the sort Door, the open, closed, locked, unlocked and these may be used as predicate form the following predicate descriptors of predicates) : symbols with the single argument of sort Door to (we use the sort name to give a “type” to slots open (Door), closed( Door), locked( Door), unlocked( Door). Likewise, the following predicates give positional information on movable objects: on_jloor( Movable-obj, Room), next( Movable-obj, Movable-obj) , near_door( Movable_obj, Door, Room > . typed so that slots must take values (object truth value may change during Predicates are thus strongly the specified sort. We make a binary distinction between whose the remaining sentences” and “non-essential and Backstrom’s opposed sentences” distinction irreversible are called static. This predicates reversible to sorts). static, and the course of planning idea is similar distinction identifiers) two types of predicates, from those are called dynamic, while to Lifschitz’s “essential to Jonsson (as [ 301 for “atoms” in [ 381. It is also similar Which slots are included in a predicate and the kinds of goals is to some degree determined by the objects to be solved by the that are required the goal of getting box1 next to box2 may be specified by related by the predicate, planner. For example, next( box1 , box2) without being specific about the room they are in or whether the boxes are next to some other objects. On the other hand, a goal predicate such as near-door( box1 , door23, room2) in that it includes on which side of the door (that is which room) is specific to be placed. The choice of granularity of the target planning the requirements of predicate appears system. the box is to us to be dependent on 2.4. Substates and substate transitions (step 4) The state space of a planning domain is the set of all valid combinations in the model can occupy. In any non-trivial model of situations the size of the state and choosing the most natural and effective state decomposition that the complexity brought about by this size is managed effectively is at the that the objects space is astronomical, to ensure heart of our method. Whereas in a classical planner each state might be modelled as a predicate formula written as a set of asserted predicates under a closed world assumption, for example: TL. McCluskey, J.M. Porteous/Art@ciul Intelligence 95 (1997) l-65 II {onJEoor( boxl, room2), neardoor( boxl, door23, room2), closed(door23), locked( door23), onfloor( harry, room3), next( harry, key3), . . .}, in our object-centred object identifiers and substates. A substate describes formulation a planning state is modelled as a mapping between is a set of ground, dynamic predicates 3 that to it. the situation of the dynamic object which is mapped For example, the partial state above would be represented thus: (box1 H {onJloor( boxl, room2), neardoor( box1 , door23, room2)}, door23 +-+ { closed( door23), locked( door23) }, harry H {onJloor(harry, room3), next(harry, key3)) . . I Hence, the state space can be described as a space of mappings between dynamic object identifiers and all valid substates. Determination of substate classes An object identifier cannot be mapped for an object must be a member of one of the substate classes identified substate that object’s sort. A substate class is defined by a collection of predicate expressions: substate belongs The method to a class if and only if it satisfies one of the expressions. to an arbitrary set of ground predicates; a valid for a substate classes for a primitive sort is as follows: for designing represent 2. Each node susbstate classes, that is the abstract states 1. A substate class transition diagram, made up of nodes and arcs, is drawn for that that a typical sort. Nodes object could be in, and arcs between nodes represent the ways that the abstract states of the sort change. The choice of nodes and arcs is determined by examining the verbs and verb phrases used in the natural sample diagrams of domain configurations in the diagram substate class. To do this the modeller write down the conjunction true if the object occupies or exclusively Consider if necessary, state of an object that substate. No dynamic predicates which primarily (ii) of the resulting predicate expression. Add static predicates, to a valid a should consider a typical object, and (i) the object and which are such as Fig. 3. is annotated with a predicate describe objects of another dynamic of the expression corresponds language domain description, to ensure every instantiation sort should be included. in the domain. of predicates that describe instantiations expression defining and The principal role of substate classes that behave the same way under a state transition brought about by an action. They also provide a means of checking the validity of a state, and later we will see how they can provide the basis for generation of useful macro-operators is to group those substates to help in planning speed-up. together 3 In Section 7 we explain how this representation about an object’s substate. information can be naturally extended so that it can handle incomplete 12 T.L. McCluskey, 04. Porteous/ArtijiciaI Intelligence 95 (1997) I-65 Fig. 4. Substate class transition diagram for sort Door. Examples The substate class transition diagram annotating the nodes expressions in Fig. 4 define for the sort Door in R” is shown in Fig. 4. The the three substate classes the fact that a door can be closed and locked that a door may represents a predicate that any door object can be in, reflecting or closed and unlocked or open and unlocked, and implicitly not be open and locked at the same time. Each node’s annotation, necessary condition state; and in any well-formed in a substate satisfying transitions, from open and unlocked state of closed and unlocked. state of the model, each object of the sort Door must be exactly one of the predicate expressions. The arcs record state and show that there is no direct way to change the substate of a Door directly is via the intermediate that must be satisfied for objects of sort Door to be in a well-formed to closed and locked, the only “route” therefore, recording For the sort Box, objects are deemed to be either on the floor of a Room, and not next to a Box, a Key, or near a Door; or on the floor of a Room, at a Door, and not next to a Box or Key; or on the floor of a Room, next to another Box, and not near a Door or next to a Key; or on the floor of a Room, next to a Key, and not next to a Box or near a Door. This gives us the nodes for the Box sort, in Fig. 5. The cyclic arcs are used to indicate a change of substate where only bindings of the predicate expressions that a box may be moved from one door to another within a room). the diagram we can write down for an object Bx of sort Box (here Rm, Rml are variables of sort Room, Bxl is of sort Box and Dr is of sort Door. The is-~~_.sort predicate sort to a subsort of that sort): is used to restrict a variable of a non-primitive the substate class definitions in the transition diagram for example, (to indicate, change From {onJEoor(Bx, Rm)} {on$oor( Bx, Rm > , near_door( Bx, Dr, Rnz) , connect( Rm, Rml , Dr)} {on$oor( Bx, Rm) , next( Bx, KY), Ky is_ofsort Key} {onJloor(Bx, Rm), next( Bx, BAT,), Bxl is-of-sort Box, Bx -it Bxl} ZL. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (I 997) 1-65 13 We assume a local closed world assumption for dynamic predicates chosen to describe a box in the substate class definitions. For example, since in the first set it is not asserted that Bx is next to an object, this substate. Here the modeller has used the following to restrict values of the dynamic false for any box object occupying then this is assumed static predicates sorts: connect( Room, Room, Door), Obj # Obj, Obj ixofsort Sort. An object’s substate satisfies a substate class definition dynamic predicates in the definition, to true unders caused by the match. the bindings and any static predicates if the substate matches with the in the definition evaluate 2.5. State invariant construction (step 5) The next stage in engineering of the domain invariants are axioms that rigorously define state. Invariants have been used before Informally, true of a planning WARPLAN engineering ticular, assumptions and automatically. They fall into the following classes: [58]), such as compilation, them tool construction, of the modeller. Using our method can be used for consistency checking, invariants but we have exploited invariants is to specify the conditions in planning logical state invariants. that must be (in for example in various aspects of domain model In par- the validation and maintenance. and to explicitly are acquired both manually record expressions invariants: a set of atomic l Positive includes that are always definitions to be well-formed of that object’s sort’s substate classes. are in fact positive invariants, that must be true is, those in every planning instances that true. In the context of planning with substates, invariants: a necessary condition state. This of static predicates the substate class state to one for a planning is that each object identifier maps to a substate belonging that must be false expressions includes true. Explicitly-declared negative all instances of static predicates in every planning state. This that have not been invariants are termed “incon- l Negative invariants: implicitly category declared as always sistency constraints”. Examples of invariants Positive atomic invariants are given primarily by a list of all predicate instances that never change during planning, for example: connect( room6, room5, door.56) position( light4, room4, door45) colour( door47, blue) are instances of static predicates guished static predicates, that are always true. We have already met two distin- “ f ” and “is_ofsort”, each with the obvious meaning. For an example of a negative invariant, consider in R” part of a valid state describing the situation of robot harry: 14 TL. McCluskey, J.M. Porteous/Art@cial Intelligence 95 (I 997) 1-65 harry H {on&or( h arty, room3), next(harry, box1 )} Hence the substate of box1 must be an instantiation sets, such that the bindings of object the following static predicates: Ky, or Bx satisfies the associated of the dynamic predicates identifiers in one of to sort variables Dr, Rml, {onJEoor( buxl, room3)) {onJEoor( boxl, room3), neardoor(box1, Dr, room3), connects( room3, Rml , Dr)} { onJEoor( box1 , room3), next( box1 , KY), Ky is_ofsort Key} {on_.uor( boxl, ruom3), next( box1 , Bx) , box1 # Bx, Bx is-ofsort Box} or in other words box1 must be in some substate the robot hurry. This can be summed up using a generalised, negative it is in the same Room as invariant: in which 3A, B E Movable_obj, 3Rt, R2 E Room: onJloor(A,R~)&next(A,B)&on_fZoor(B,R2)&R~ # R2 and/or it could be expressed as a positive invariant as follows: VA, B E Movableiobj,VR E Room: next( A, B) & onJEoor( A, R) -+ on._Joor( B, R) Maintaining two separate sets of invariants (positive and negative) in this way is required so that the tools that use them can work more efficiently. As another example of an invariant, consider the substate class for sort Arm given by the expression: {arm_used(Arm, Robot, Key) ,part_of(Robot, Arm)}. that in DR” it is only possible If it is assumed planning is not allowed. For example, a state containing invalid: for a key to be held by one robot arm, a state in which two different arms were both being used to hold the same key two substates would be the following { . . . harrysarm H {arm_used( harryatm, hurry, key3)}, dicksarm ++ {arm-used(dicksarm, dick, key3)}, . . . 1 A negative key: invariant for sort Arm is the constraint that no two arms can hold the same 3A1, A2 E Arm, 3R1, R2 E Robot, 3K E Key: arm_used( Al, RI, K) &arm_used( AZ, R2, K) &Al # AZ. In concrete syntax (used later) this constraint would be written: inconsistentxonstraint(arm_used( Al, _, K) &arm_used( AZ, _, K) &Al Z AT). TL. McCluskey, J.M. Porteous/Artifcial Intelligence 95 (1997) 1-65 15 [on_floor(Bx,Rm)) Node B (on_floor(Bx,Rm),near_door(Bx,Dr,Rm), connect(Rm,Rml,Dr)] (on_floor(Bx,Rm),next(Bx,Bxl) (on_floor(Bx.Rm),next(Bx,Ky)] Fig. 5. Substate class transition diagram for sort BOX. question “enough” important information? is when does the domain modeller know specifying that the invariant An substate classes contains this is straightforward the invariant must specify all of the abstracted states that objects of that sort can occupy. However, we know of no such criteria is reached invariants, when the tools described below check and compile although a level of security the model without errors. sort that has been identified since for each dynamic For the positive for negative invariants 2.6. Operator specification (step 6) In the natural and properties of the domain, and possible language description of DR” verbs and verb phrases not only suggest states of sorts, but also ways includes text, “Robots . . . capable of . . . pushing . . . objects to doors, through the state of they affect relationships in which states can be changed. For example, the following doors and next to other objects”, suggesting a movable objects of dynamic the possible ways of changing sort. We call these the actions in the planning domain because sorts in the model. the description of the domain transitions of sorts. The need for operators from the step above. The node description Within our framework, actions are represented by schema called operators that have to classical planning operators, are specified is identified using the the pre- and of the operator and for each arc that leads to a node a suitable operator in Fig. 5, pushtodoor the pre- and post-conditions, which, in contrast in terms of the substate transition diagrams postconditions name is selected could be used to label arc from Node A to Node B ) . Clearly operators change diagram that the operator may affect, along with any other objects affected transition they appear, but the domain modeller needs to also consider any other objects that are involved but not that prevail). We will show how an operator the arc from Node B to Node A, and pushthrudoor to label that could be used to label the arc (for example, from the sort on whose the substates of objects on an object is conditions can initiate (that 16 TL. McCluskey. J.M. Porteous/Ar@cial Intelligence 95 (1997) 1-65 the the action of pushing a box through a door can be constructed representing sort Box’s transition diagram shown in Fig. 5. Each node represents a substate class (as recorded in Section 2.4), and each arc an abstracted state transition. Each operator will be designed by recording: using (1) Prevail conditions: conditions on substates can execute, and are unchanged by it. that need to be true before an action (2) Necessary effects: conditions on substates that need to be true before an action can execute and are necessarily changed by it. (3) Conditional efects: conditions on substates that, if they were true before an action executes, term “condition” then they will be changed by it. The in each of these operator components to a predicate expression which matches with one or more substate classes. In an operator’s definition expression by the sort name to which it is applicable. Hence we precede each conditional the condition: refers Box: {onJZoor(Box~ , Room21 )} the other hand, could be satisfied by a box object at any of the nodes shown On and Conditional equivalently well-formed in the transition diagram. in the Necessary the new substate of the affected object given a unique (or substate class that the operator produces a as identifying to ensure a node output state. Effects slots is interpreted in the transition diagram), Construction of prevail conditions The operator Door, called Doorl, empty conditions (in that transforms node A to node B (Fig. 5), requires an object of sort to be to be open, and the arm object of the robot, called Arm,, but neither of these its pushing), this domain a robot cannot carry while are changed by the operator. These two conditions are: Door: {open( Door, ) , unlocked( Door] > } Arm: {arm_empty(Arml , Robot, ) ,part_of(Robotl ,Arml )} They must be specified effects. in the preconditions of the operator, but will not appear in the Construction of necessary effects The operator that pushes a Box through a Door changes the substate of Box from one satisfying: {near_door( Box,, Dooq, Room! ) , on$oor( Box, , Room) ) , connect ( Room] , Room2, Door1 ) } , to the substate: {onJloor(Boxl , Roomz)} TL. McCluskey, J.M. Porteous/Art@cial Intelligence 95 (1997) 1-65 17 Now actions may affect other objects the door and hence through satisfying: the operator also changes {onJloor( Robot,, Room1 ) , next(Robotl , Box, )} to the substate: in certain ways. Robot, must “push” the Box, the substate of Robot, from one {on_jloor( Robot,, Roomz) , next( Robot,, Box, ), Box, is_ofsort Box} Although the scope of sort variables is global expressions may be examined restriction in the expression above. individually, to the whole of the operator, substate the “is_ofsort” to place hence we needed 2.7. Construction of conditional eflects There may be other objects on context, e.g. it may be that that change depending other movable objects were next to the box about to be pushed. For any object, Obj, if its current substate satisfies: {next< Obj, Box1 > , onJloor( Obj, Room1 ) }, then it changes to the substate: {on$oor( Obj, Room1 )> To systematically check for conditional effects, that may be affected by the change objects objects. This may be done by searching which may refer to the necessarily the modeller must decide whether substates already constraints may be consulted as a side effect, then the modeller decides in the necessary recorded through affected objects the substate can co-exist in the substate of the necessarily transition graphs and considering the modeller considers any dynamic affected nodes (that is Boq, Robot1 ). At each one, state with the inconsistency in a planning (the and prevail conditions to help this). If this is possible, and an object may change to which substate. Operator integrity The operator design can now be encoded lists, etc., for the purpose of input design to reason about its properties, into a concrete syntax using add and delete engine. We can also use the to the target planning in particular we can ask if the operator is: state, is the ( 1) consistent-if resulting an operator state well-formed? is applied in a well-formed planning an operator is applied in a well-formed planning state, then is (2) deterministic-if the resulting these properties state unique? Both operator. consistency the consistency follow the In the next section, after formally defining an operator’s semantics, operator of states, we will show how the modeller can prove the way we have constructed and well-formedness trivially fairly from of the “pushthrudoor” operator. 18 ZL. McCluskey, J.M. Porteous/Artifcicrl Intelligence 95 (I 997) l-65 3. A formalisation of the object-centred framework The result of using the method of the last section of the model M of a domain of interest V, which is composed of sets of: is the production of a specification Sorts, identifiers: Objs, l object l sort definitions: l predicate definitions: Prds, l substate class expressions: Exps, l positive and negative domain 0 operators: Ops. In this section we formalise invariants: Znvs+ and Invs-, previous will be described, from the section will be made more precise, some useful properties of domain models and some notation used in later sections will be introduced. framework. Some definitions the object-centred 3.1. Loosely Sort-Abstracted (LSA) models Our starting point is to declare what we mean by a sort: Definition 1. A sort is a set of object identifiers and behaviours. a common set of characteristics in M denoting objects in 2, that share Objs is thus the union of all the sorts in M. The characteristics and behaviours of and operators associated with that sort. Unless to mean “object the word “object” will be used a sort are modelled by the invariants otherwise identifier”. in what follows stated, Definition 2. Sorts are either primitive or non-primitive. Non-primitive as the union of objects defined two or more other sorts. A sort is primitive in terms of other sorts. from sorts are defined if it is not Each object is a member of exactly one primitive is a member of two sorts st and s:! then si must be a supersort of s2 or vice-versa. Each argument of an element of Prds (predicates have at least one argument) referring to objects of one sort, which may be primitive or non-primitive. sort, and if an object is pre-defined in M as of predicates. A binding of an object Let Bindings denote all sequences of legal bindings of object to variables if the within arguments to the predicate’s definition. A object belongs grounding of a predicate to formulae) objects. We can thus define the set of all possible ground predicates Prdso as the set of all legal groundings to the same sort as the variable according is a binding of all its sort variables of every predicate definition. to a variable (or predicate identifiers is legal Definition 3. The Positive Atomic taken from Prdsc and are interpreted as being always true in M. Invariant is the subset of Invs+ whose members are T.L. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) 1-65 19 All other instances of those predicates appearing in the Positive Atomic interpreted example, as being always false (and in R”, as the static ground predicate: in M form a negative atomic connect( rooml, room6, doorl6) Invariant are For invariant). does not appear predicates Invariant. in the positive such as “kofsort”, invariants are assumed it is therefore a member of Invs-. Static in the Atomic to be defined explicitly The following two definitions are to do with the split in a model between objects and predicates that are affected by operators, and those that are unaffected. Definition 4. A predicate the Atomic Invariant. Otherwise is static if one or more instances of it are declared is considered dynamic. the predicate true in Definition 5. A primitive in M. Otherwise (static). dynamic a sort is called static. Objects of a dynamic if its objects are deemed (static) to change state sort are called sort is dynamic Below we let SortsD and Objs, denote the dynamic respectively. We use the phrase “are deemed” objects as to which sorts are considered could, for example, have declared Room as dynamic depending atomic are good candidates for static sorts. invariants dynamic on which objects were in it. Sorts whose objects in some cases sort names and the dynamic in Definition 5, as the decision is not straightforward. We in R”, the state of a room changing feature frequently in the the basic terminology for objects, for each s E Sortso, we assume reviewed Having formalise the substate chooses an exclusive to describe terminology that the object whose state they refer to is given in their$first argument. For example three members of Prds chosen sorts and predicates, we will idea. First, that the modeller set of dynamic predicate definitions Prds’ c Prds with which the the syntax of elements of Prds” so the the local state of objects of s (in our earlier publications we used “s owns Prds”“). Further, we restrict sort Box are: for primitive on._jloor( Movubleobj, Room), neur_door( Movableobj, Door, Room). next( Movuble-obj, Movubfe-obj) with the first argument of each predicate restricted to members of sort Box. Definition 6. Let Prdsg be the set of all groundings o E Objs, of sort s, is a set W c Prds;, describing o, such that of Prds”. A valid substute of in 2, of the referent of a situation (a) every predicate (b) every predicate in W is deemed - W) in (Prds; given by -0. false in the interpretation true in the interpretation that has its first argument equal to o is deemed given by D, 20 ZL. McCluskey J.M. Porteous/ArtijiciuI Intelligence 95 (I 997) l-6.5 Let Cjn denote all conjunctions Prds. They have the property as follows: of predicates that can be made up from members of that they may or may not be satisfied by a subset of Prdsc Definition 7. If W c Prdsc and C E Cjn, then W satisfies C if and only grounding of C given by LY E Bindings, call it C,, such that W&Invs+ /- C,. if there is a An important property of a member of Cjn is whether or not it can satisfy a negative invariant: Definition 8. For any C E Cjn, inconsistent(C) which are groundings of C, there is an A E Invs- such that C, satisfies A. is true if and only if for all cy E Bindings In practice one defines the set of possible class expressions Exps. Elements the substate composed of dynamic predicate(s) subclass of Cjn called Cjrz’. This using are members of an important conjunctions or more static predicates are interpreted under a local closed world assumption when describing some object o. This means not included from Prds. As well as this constraint, that all instances of any predicate in the expression, in that substate. of Exps are false substates of a dynamic object implicitly to a sort s is defined as those taken from Prds” only, and zero, one that apply substate class expressions the substate of in Prds”, describing o but The model’s substate class expressions Exps are segregated into groups associated with each sort, and defined as follows: Definition 9. Exps’ is a valid set of substate class expressions for sort s if (a) every valid substate of objects of sort s satisfies exactly one member of Exps”, (b) for each expression C in Exps”, if C, is a grounding of C under bindings all static predicates predicates form a valid substate of an object of sort s. (Y, and formulae’s dynamic in C, are true in M, then the remaining Adequacy of substate descriptions, for a sort, cannot be formally requirements. and validity of sets of substate class expressions the domain to be validated using checked but have We call the process of designing the planning model’s state following since abstraction” We now turn to the operators in the model: the sort and its substate classes are the main abstractions this method “sort employed. Definition 10. An operator 0 0.E’ where 0.P x.C E Cjn’.‘; and 0.E” and 0.E’ x.s E Sortso,x.CJ’ E Cjr? is a schema having is a set of pairs, and each pair x has components three components O.P, 0. El’, and x.s E SortsD and three components are sets with each member x having and x.C’ E Cjn’.‘. In later sections we may simply by a take the liberty of referring name and a collection of objects or object variables as the name’s parameters. These parameters the preconditions set such that their instantiation to be the smallest of the operator. to an operator are chosen grounds 7X. McCluske); J.M. Porteous/Artificial Intelligence 95 (1997) l-65 21 Drawing on these definitions we can describe an important, necessary condition of model well-formedness: Definition 11 (LSA property). A model M of a domain 2, is loosely sort abstracted if the following restrictions on the components of M are true: (a) For Objs: For every object in V that needs to be represented there exists a unique object identifier (b) For Sorts: Every object sort. All sorts (and static. in Objs that refers to it. identifier therefore all objects) in Objs is a member of exactly one primitive to be either dynamic or are deemed (c) For Prds: Prds is defined such that each predicate’s argument may refer to any from exactly one (primitive or non-primitive) identifier object sort. (d) For Exps: A set of valid substate class expressions Exps’ has been constructed to Definition 9. All the dynamic predicates for each dynamic sort s, according in Prds appear in at least one substate class description. (at least) to define (e) For Invs: The invariant the truth values of the static predicates “=“, “ # ” and “is_ofsort” for all domain objects. is assumed distinguished (f) For Ops: A set of operators have been defined according to Definition 10. The LSA model would normally contain many invariants, although this part of the specification Given is somewhat open ended in a realistic application. the LSA property, we can make the following central definition of planning states that represent the changeable part of a domain model. Definition 12. Let Cjn& represent the set of well-formed states in an LSA model M those members of C~H’ which are grounded. Then is the set of all the (total) maps such that, for any state I, if o is of sort s then I(o) E Cjn& satisfies exactly one member of (a) Vo E Objs,, Exp” ; (the conjunction range(I) of I) satisfies none of the negative (b) of the range elements of every object in the domain invariants in M. 3.2. Operator complete models The operational semantics of an operator 0 is given by the next two definitions: Definition 13. 0 is applicable to a well-formed all the variables in 0.P and 0.E” such that: state I if there exists a binding cx for (a) Vx E O.P, 30 E Objs, of sort x.s such that Z(o) satisfies xX,; (b) Vx E O.E”, 30 E Objs, of sort x.s such that I(o) satisfies x.Ci. that while the operator may be applicable to different objects depending chosen, given a binding and a state I the objects necessarily on affected are Note the binding determined. 22 T.L. McCluskey, J.M. Porteous/Artificial Intelligetw 95 (1997) l-65 Definition 14. If 0 is applicable new state O(I) and (b): (a) is equal to a well-formed to I with the following state 1 in M under a binding a, then given by (a) substate replacements for each member of O.E”, we know from Definition such that I(u) (0 I-+ x.C”~~) where x.P’~ satisfies XX:. Replace the maplet 13 that there is an object o (0 H I( o> ) with the maplet is the set x.Cz with static predicates removed. (b> Let Objs’ be those dynamic objects unaffected by (a), Then Vx E O.EC,Vo E the maplet is the set x.C$ with satisfies x.Ci under some binding ) with the maplet /3, then replace where XJ’?~ (o I-+ x.P~) if I(o) Objs’, (CI I-+ I(u) all its static predicates removed. These definitions of operators. Although we have defined operator applicability without the use of an explicit set of preconditions, we will find it useful to have a function which returns to the sequential extend naturally of a sequence appiicarion them: Definition 15. precons where P XC”, such that x E 0.E”. is the conjunction : Ops + Cjn is a function such of all x.C such that x E O-P, Q is the conjunction that precons( 0) = P& Q, of all precans returns the preconditions of an operator 0, and it follows that 0 is applicable to any state I if mnge(Z) satisfies precons(0). The applicative semantics of operators and the well-formedness property of states allows us to define a notion of consistency for operators: Definition 16. An operator 0 in an LSA model is consistent is false, and O’S application state) transforms its members are. it into another well-formed to a well-formed state (assuming if inc~~lsl’stent(precons(0) it is applicable ) to that if all state. An operator set is consistent Example. The “pushthrudoar” operator defined in Section 3 is consistent. The first part of the consistency definition which the operator can be applied, and for this case it is straightforward is to check that there is at least one state in to verify that inconsistent( {open(Doorl ), unlocked(Doorl ) , arm_empty(Annl, Robot,), part&Robot1 , Arm] ) , neardoor( Box,, Door,, Room1 ) , on-$oor( Boxl, Ruoml ) , connect (Room], Room:!, Door2 ) , on&x-( Robatl, Room1 ) , next( Roboti, Box, ) )) is fulx. The second part was generally struction, but we can check it in more detail by a two step process: established by the systematic form of its con- (a) we check that each expression the same collection stated after “CHANGES TO” in the specification as one of the substate class defini- of predicates the possible output states resulting from the operation against the set of negative invariants to make sure that they all remain unsatisfied. contains tions; (b) we check T.L. McCluskey, J.M. Porteous/Art$cial Intelligence 95 (1997) 1-65 23 Name: pushthrudoor Prevail conditions Door: {open(Doorl), Arm: {arm_emp~(Arm~, Necessary state changes unlocked(Doorl)} Robot, ) ,part_of(Robotj ,Arml)} Box: (near_door( Box,, Door, , Room, ) , on$oor( Box,, Room) ) , connect ( Room 1, Room;!, Door;! ) } , CHANGES TO {onJloor( Box,, Roomz) } Robot: {on$oor( Robot,, Room, ) , next( Robot,, Box, )} CHANGES TO {onJloor( Robot,, Roomz) , next( Robot,, Box1 ) , Box1 is_ofsort Box} Conditional state changes Movableobj: {next( Obj, Box, ) , onJloor( Obj, Room1 )} CHANGES TO {on-jloor( Obj, Rooml)} Fig. 6. The operator pushthrudoor. (a) The expressions after “CHANGES TO” are: {onJIoor(Boxl, Roomz)} {o@oor( Robot,, Roomg) , next( Robot!, Box] ) , Box, is-ofsort Box} {on_Joor( Obj, Room1 )} The full definition of M can be used in a straightforward verify that these are equivalent to exactly one of the substate class definitions. (and automated) manner to invariants. From that the introduction of the new substates does not potentially the definition of operator application we from the necessary and zero, one or more other changed substates depending on the conditional (b) We must check satisfy one of the negative can see that the output state has two changed condition, effect. Since self-consistent. “Box1 # Obj”, hence of the changed contain one or more of the predicates appearing remain unsatisfied by the output state. Assume we left out the substate change the input state is well-formed, we know that the unaffected shows that “Robot, inconsistency states. Finally, we have to check through invariants which to verify that they The definition of operator application substates are f Obf’ and arising the negative in the new substates, from the conjunction there is no possible substates resulting to {on$oor( Obj, Room] ) }. A search of the invariants would reveal: inconsistent_constraint( onJZoor( Obj, Rm) & next( Obj, Objl ) & onJIoor( Objl , Rml ) & Rm # Rml ) 24 TL. McCluskey, J.M. Porteous/Artificicl Intelligence 95 (1997) 1-65 in this constraint since predicates being satisfied after the operation of pushthrudoor, in Fig. 6. be added as shown are affected by the operation. To prevent the relevant conditional this from effect would Putting Definitions 11 and 16 together gives us a standard for planning models which we call “operator complete”: Definition 17. A domain model M is operator complete if the LSA property, (a) M satisfies (b) (c) the operator set in M the operator set in M transitions every dynamic predicate appears in the transition is consistent, is complete relative to dynamic sorts, that is all required by operators, and diagrams have been represented in the effects of some operator. The concept of the “weakest precondition” of a plan is important in knowledge compilation for planning, and we will need the following definition in later sections: Definition 18. Let ( Opsc)* define predicates the weakest precondition to be the function: represent the sequences of ground operators of a sequence with respect to a conjunction in M. We of goal WP : (OpsG)* x Cjn, + CinG If OS is sequentially smallest conjunction OS is applicable wp( OS, G) = false. to at least one well-formed applicable such that given any state I where range(I) state, then wp( OS, G) is the satisfies wp(OS, G), to I and will produce a new state whose range satisfies G. Otherwise 3.3. Goal conditions Engineering domain models to be operator complete only of a set of literal-based from a model consisting pleteness gives a level of well-formedness however, allow conditions be underspecific mentioned to be decomposed, is as follows: in that when instantiated at the end of Section 2.3). A tighter property for object-centred in an operator’s preconditions, is itself a significant step away operators. While operator com- it does, domain models, to (as that does not allow substates or predicates in a goal, they might not give a unique substate Definition 19 (TSA property). A domain model is tightly sort abstracted if it is operator complete (a) (b) every substate class expression consists of exactly one predicate. The apparent advantage of creating a TSA model is one of efficiency-here conjunction the domain of ground predicates is equivalent is not TSA, then goal predicates may specify a disjunctiue to a conjunction of objects’ substates. any If goal in terms of TL, McCluskey, J.M. Porteous/Artijicial Intelligence 95 (I 997) 1-65 25 object states. On the other hand, refining a loose formulation the flexibility into a TSA model loses of the original. goal conjunctions as a map between objects and sets ofsubstates, are often expressed as sets of literals. explicitly and disjunctive the following nature of goals. literal set representing a planning goal in the In the classical and expressiveness formulation, We interpret a goal conjunction showing the conjunctive For example, LSA model of R”: consider { neardoor( tom, door45, room4) , next( box1 , box2), -open( door1 2), onfloor( tom, room4)) This would be tom, boxl, door12 so it would be translated substate expressions: interpreted (as as describing these are the objects into a goal consisting of the conjunction the substates of three dynamic in the first slots of the predicates), objects and of the three objects’ {tom H { {on$oor( tom, room4), neardoor( tom, door45, room4))) door12 H {{closed(doorl2), unlocked(doorl2)}, {closed(doorl2),locked(doorl2)}} box1 H { {on_$oor( b ox 1 ,rooml),next(boxl,box2)}, {on.#oor< boxl, room2), next( box1 , box2)}, . . .}} The negated goal above evaluates after the negation. This explicit, as a single the predicate disjunction in box1 ‘s goal state). In what follows we will assume as literal sets, but we will also use the following within LSA models. to a set of goal substates formulation literal goal may correspond has the effect of making that do not contain implicit to a set of object states (as that planning goals are still input logical definition of goal conditions Definition 20. The set of well-formed goal conditions of all maps: in an LSA model M is the set G : Objs, -+ Cjn,-set where each member of Cjn,-set one well-formed state I E M such that t/c E dom( G) : I(c) E G(c) . is a set of substates of one sort, and there exists at least Note that for any goal G, dam(G) G dam(Z), as goals can only be posed for known objects. We end the section by defining the useful function achieve which returns true if and only if a goal condition is met in a state: Definition 21. For any well-formed ‘dc E dam(G): achieve(l,G) w state I and goal condition G in an LSA model M, Z(c) E G(c). 26 i?L. McCluske~~, J.M. Porteous/Artificial Intelligence 95 (1997) l-65 4. Tool support for a particular class of architectures In this section we will examine ability throughout to support a major benefit of formalising domain the whole process with tools. Their use can be inter- the whole cycle. Tools all help to some degree in the crucial aspect two main of a model, and here we classify planning them into and verijcation 1: Tools for use in model construction and maintenance, which might in- models-the spersed of validation categories: Cutego~ clude: and that dy- system (a) Syntax and sort cross-checking (b) Static analysis of operators: checking of a model’s components. that operators are consistent namic goal predicates are achievable. MVP is an example of a planning tools that test whether certain goals are unachievable featuring (c) Graphical diagrams development consistency editing, for example and operators. The SOCAP transition features a range of knowledge type and a graphical operator editor which performs [ 141. of substate class checking of operators in the construction tools including system [ 191. (d) Partial construction of operators tools used in software engineering from diagrams, similar [53]. For example, editor diagrams) and then the tool could automatically to the kind of “methods the modeller to enter operator store these in the (featuring node-link integration” could use a graphical pre and post-conditions input format. planner negative (e) Generating invariants from operator definitions. An early version of this features (predicates) both the positive and negative effects of an operator. in the work of Dawson and Siklossy to be “incompatible” are deemed [ 181 where sets of “assertions” (inconsistent) if they appear in planning random planning random well-formed (f) Generating hence defined as amalgams of substates satisfying domly generating problems Category 2: Tools used primarily include: form. These problems or operational in a systematic manner for compiling (as planning states, the invariants, is obvious). states and sets of goal in our formulation, the potential literals, and are for ran- a domain model into a more efficient (see Section 4.1) , (a) macro generation (b) generation of various (c) abstraction hierarchy generation At present our environment types of goal orderings (see Section 4.2)) (for example ALPINE in [ 35,361) contains a number of tools of Category 1 (a, b, e and f) as follows: l A tool that uses the substate class definitions the syntax of the domain that should be achievable are indeed achievable to: check operator set; check that all substates by operator action; help check that the operator set is consistent. l A tool that identifies goals that are unachievable is described as a type (iii) blocking below). given the current operator set (this l A tool that generates information of the domain to ensure from state invariants, random planning problems substates and descriptions that generated problems are valid. for a particular domain using states of well-formed TL. McCluskey, J.M. Porteous/Artijicid Intelligence 95 (1997) l-65 21 l A tool fects. that generates negative invariants through static analysis of operator ef- to automation. I tools are performed by hand although The function of the remaining Category they In the remainder of this section we will concentrate on the are amenable category. In Section 4.1 tools that fall into Category 2 above, the more planning-specific for planning through model we introduce for generating macro operators analysis and then in Section 4.2 we introduce a method for generating goal orderings. The effectiveness of these tools is dependent on the input of an operator complete model constructed using a systematic in Section 2. a method The premise of using form, but written in an operational and naturalness with readability (a) we see it, is twofold: when used with a planning solutions and (b) approach as described tools to compile domain models in a language designed of presentation. The function is not to do as of the model, to improve engine, without any marked adverse effect on the quality of is that the input model to satisfy criteria then, of compilation, the efficiency of the representation to further validate and verify the model. 4.1. Macros in planning only compilation for complete The overall effect of “macro creation” is to produce, during a once stage, a set S of partial solutions which can be used as building blocks in this context solutions of planning problems. There are two obvious extremes: l S is empty. In this case the planner has no macros, and uses the basic operators as its building blocks. l S is the set of macros representing In the kind of problems we have in mind both the generation every solution to every planning problem. set of macros would be intractable. A good set of macros and maintenance of an is one that satisfies these extremes. Given a domain model, of a macro set can be the performance exhaustive (a) above, and that falls somewhere between a planner technique, and a macro generation predicted by consideration ( 1) the likelihood of the following factors: planning problem, the amount of processing the cost of searching the cost (in terms of solution non-optimality) the cost of generating and maintaining (search) like a set of macros and a selection (2) (3) (4) (5) We would set means the cost related is I, and the amount of processing first two points and minimised the extreme where S is an exhaustive applicable total. Unfortunately, prohibitive. As another example, assume a planner to previously Then give a high (4) and (5). Unless the problem generation, factors ( l)-(5) in all but trivial domain models, the strategy of storing solutions (2) and a low (3), ( 1) is likely is not easy. of using a macro, the macro set. technique (in terms of search space) cut down to the other three. For example, that the probability that scored highly on the taking of a macro being is the cost of (3) and (5) would be to solve. random problems solved problems would (initially) receives there was some strong bias in to be very low. Finding a good trade-off between a macro cuts down, for an applicable macro during planning, of some macro being usable at any step in solving any given 28 TL. McCluskey, J.M. Porteous/ArtijiciaI Intelligence 95 (I 997) 1-65 Work on macro creation was pioneered by Korf in (in encodings the number of macros the work cited he assumed propositional feature vectors of propositions). Korf gave some explicit properties display: amount of time required problem of subgoals (l)-(5) instance; and the worst case solution length of a problem in the problem their optimal the macros to generate above. times [ 371, at least for domains with as states could be modelled that his macro sets the is of the same order as that of solving a solution. These criteria are implicit is equal to the number in is a small fraction of the number of possible states; The regularity used in Korf’s domains was that of “operator decomposability”-his had of the state” If we replace that operators to be expressed is not dissimilar. the phrase “component [ 37, p. 591. The regularity into its effects on each individual in an operator complete encoding component of the state, independent to mean a slot of a feature vector) by our “substate” so that “the effect of an operator on a state can be domains of decomposed relied upon by our macro the other components of the state” (which technique then we in Korf’s work seems in the sense claim in terms of the effect it has on substate classes. Further, that each operator in that could be posed in the planning domain (expressed LSA implies of one or more terms of an initial state and goal condition) will require the manipulation instances of dynamic objects to the change in the substates of the objects. Now, if a planning domain model has been engineered to be at least LSA then pre-defined. This means problem, substate’s class. the classes of substates that for any object of a dynamic sort that features its substate both in the initial state and the goal must be a grounding is defined that any problem that objects of a sort can occupy are in the domain, where manipulation are decomposable in a planning refers of a For each such pair of substate classes object of a sort) we can produce a macro problem the (generalised) can be performed for every dynamic space of all possible pairs of generalised given that the description (the generalised for an that represents an abstract plan for solving represented by this generalised pair. This macro production start and end situation sort in a domain model in a way that spans the In summary: of any object’s substate must be a ground instance of a sort’s substate classes, we can aim to generate a macro set that will be of exhaustive with respect the “transition” to providing to subtasks involving solutions start and end situations. one object. 4.1.1. Macro generation techniques Let us consider two substate classes within sort Box, and explore possible macros and generation techniques: {on$oor(Bx, Rml )} {on$oor( Bx, Rmz) , next (Bx, Bxl ) , Bxl is_ofsort Box} Such a pair of substate classes (a macro) abstract plan the first one is an initial substate and the second transporting these two generalised is a goal) room and putting a box from one room that “spans” to another an substates that is an abstract problem of it next to another box (assuming is called a task conjiguration below. Generating TL. McCluskey, J.M. Porieous/Artijicial Intelligence 95 (1997) 1-65 29 for this sort abstracted task in the R” model will consist of in that room. A solution a series of operators where a Robot (Rbl ) successively through a series of Rooms (Rml , Rm2, . .), connected by doors (Drl , Dr2, . . .) using operators and then pushes the Box to be next to the other Box (Bx) pushtodoor and pushthrudoor, as follows: using an operator pushnext. This can be represented the Box (Bx) pushes [ [pushtodoor( Rbl , Bx, Drl , Rml ) ,pushthrudoor( Rbl , Bx, Drl , Rmz) ] *, pushnext( Rbl , Bx, BXI ) 1 where the abstract solution consists of a sequence and pushthrudoor (denoted by the * notation), pushtodoor pushnext. There are a number of conditions on these abstract macros, chiefly join preconditions some object), in the sequence that they are effective of one operator and satisfy (they change (the post-conditions (0, 1 or more) of applications of followed by application of that they the sort abstracted the state of of its successor) as specified [48] in [ 401. concentrated initial work is they would be applicable Our macros-that in the task configuration. The diagrams. Being very general, relatively small. On the other hand, adding a processing overhead which endangered iterative property arose out of cycles the total number generated at compile these macros had to be “unwound” their utility. on generating such fully generalised for any instantiations iterative of the sort parameters in the transition time would be at plan-time, The opposite end of the scale would be to generate macros is for every pair of substates configuration-that still would be much more abstract only be interested of such a ground task configuration in abstract 4 plans between for every “ground” task (rather than classes) within a sort. This all possible plans since we would substates of the same sort. An example if generated from R”, might be: than generating and macro, i = { on_$oor( box1 , room 1) } g = (next(box1, box3) , on_jioor( box1 , room4)) [pushtodoor( harry, box1 , door1 2, room1 ) , pushthrudoor( harry, box1 , door1 2, room2), pushtodoor( harry, box1 , door24, room2), pushthrudoorf harry, box1 , door24, room4), pushnext(harry, box1 , box3) ] Both of these approaches have disadvantages, macros at plan-time consumes on-line may prove prohibitive were interested generation predicates of fully generalised resources; and compilation of fully ground macros storage and maintenance. Hence, we in the macro and our basis for this came from the difference between static and dynamic that are used to define a planning domain model. in terms of computation, some useful mid point to use for abstraction however: unwinding in finding We observed that for many domains in the planning be made up of repeated sequences of operators literature solution plans that are iterated over static relationships tend to ’ By abstract we mean one which suppresses details of all other dynamic sorts. 30 TL. McCluskey, J.M. Porteous/Arii$iciaI Intelligence 95 (I 997) l-65 the relationship require moving In R” many planning problems is that adjacent doors and rooms are “connected” then was to explore binding variables is determined in the domain. Box, Key through series of Room and Door, where Rooms and Doors unchangingly. Our strategy and substates) whose value all other variables generalised. Then run-time intuitive example of this processing consider the set of “paths” abstraction we would compile be pushed by any instance of sort Robot through These paths are unchanging with the appropriate instances of sort Robot, between different to each other slots and to leave at input planning problem. For an in R” where at this level of instance of sort Box could doors and rooms. and at run-time need only be looked up and instantiated that any the interconnected their values are dependent on the actual uniquely by static relationships variables could be instantiated instances of Box and Robot. the generalised (in operator the situation since The idea is embodied in our second and more successful macro generation algorithm described in Section 5). of an operator complete and index substates is shown the macro I initialises set Ops with operators in Fig. 7 (and was used in our experiments accepts as input components which The algorithm Generatemacros model and builds up a macro iterates through every dynamic all the pairs of generalised to produce set of “sort abstracted” operators-the affect objects of sort s. The resulting operators are further components which are not prefixed by sort s. Step 5 iterates for each task configuration, producing generalised their task configuration. In step 6 a planner table. Step table, while Step 2 sort in the model. Step 3 calls a procedure which returns that are going to be used the reduced that gathers removed which do not any (the task configurations) the macros. Step 4 calls a procedure is used to produce in the abstract only static predicates and dynamic predicates owned by the sort if necessary. (such as the one described abstract plans for each task configuration where in step 6.1 it (a) searches plan space containing s; (b) grounds Step 6.2 generalises technique instances of sorts that are unified with variables to variables execution are carefully generalised the task configuration with “typical” the abstract plan along similar and all of operators during in the preconditions in the final plan. them in a table (step 7), indexed by lines to a standard explanation-based [45] : the weakest precondition reduced by removing of the abstract plan (step 6) and storing instances of sorts, in Section 5.4) is assembled, plans Returning to our example above, we have the generalised task configuration: ({on$oor(Bx~, rooml)}, {next(Bx, , Bxz) , onJloor(Bxl , room4), Bxl # Bxz}) and an explanation-based generalisation of the solution would be: [pushtodoor(Rb~,Bx~,doorl2,rooml), pushthrudoor( Rbl , Bxl , door12, room2), pushtodoor( Rbl , Bx*, door24, room2), pushthrudoor( Rbl , Bxl , door24, room4), pushnext( Rbl , Bxl , Bx2) ] T.L. McCluskey, JM. Porteous/Artijicial Intelligence 95 (1997) I-65 31 algorithm Generate-macros In Operator complete model M (Sorts, Objs, Prds, Exps, Invs, Ops) Out MT: a macro table }; for each s in Sortso do generate_task_configs( Exps" , TC’) ; abstract( s, Ops, 0~s’) for each pair (i,g) in Tc‘ do ; 1. MT:={ 2. 3. 4. 5. 6. produce_generalisedplans(i, g, 0~9, GP) ; MT:=MTu ((i,g),GP) end for; end for 7. 8. 9. end. procedure generate_task_cor$gs( 3.1. in.9 := {j, 1 j E Exps’ & inconsistent( j,) in Exps” , outTC”) is false, where (Y is a binding of all static variables in j}; 3.2. TC” := {(i, g) 1 i E in?, end procedure. g E in?, i f g}; procedure abstract( in s, Ops, out 0~s”) 4.1. Ops_reduced := (0’ 4.2. 0~s’ := (0 E Ops / 3x E 0.E”: / 0 E Ops_reduced & 0’ = 0 with all its components not referring x.s = s} to sort s removed}; end procedure. procedure produce_generalisedplans( 6.1. P := {p 1 p E (Opsk)*, and for some fixed grounding p is an optimal solution of g, from initial state i,}; in i, g, Ops’, out GP) cy of (i, g), 6.2. GP := {G(p, wp(p,g,)) end procedure. 1 p E P, G is an EBG operator}; - Fig. 7. Outline algorithm for macro generation. 4.2. Generation of goal orders The main function of the “goal ordering” stage is to produce the range of goal5 choices a planner may have at each step of a planning although such goal ordering the domain encoding, thesis are also useful as we shall see later. The work here originates [48] and is influenced by the work of [ 13,18,36]. techniques in spotting possible problems rules which cut down algorithm, in from Porteous’s 5 Although a goal could potentially mean a literal or a substate, in this section we keep the discussion at the general level of literals. 32 TL. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) l-65 -p&-q_--- p&q --_:----__* _--_--) p&-q ---\ t 0 P2 [I / / I I / \ \ \ \ P5 0 I I p6 0 I I I v \ \ 0 PI \ \ \ ti t’ I I I t P3 0 ‘\ ---* -p&q ____I 0 P4 Fig. 8. The goal establishment diagram for two ground literals. goals individual to establish that make up conjunctive Static analysis of the inherent goai structure of models can reveal heuristic or definite goal planning the goal structure of the model by analysing pairs of literals: to map out the set of possible ways that a goal pair could be is used to formulate that lead to blocks between nodes, and hence order goals for planning. in a tool called and this section ends with an outline of its algorithm and some illustrative orders in which problems. We examine our approach has been established general conditions Some of the conditions PRECEDE examples. that we have identified have been implemented (using a “goal establishment” diagram). This diagram 4.2.1. Goal establishment In addition to the notation introduced in Section 3, we assume the existence of the following functions: Definition 22. establishes( A,, p) under the unique most general binding a (A, makes pa true). is true if and only if operator A establishes literal p For example in R”: establishes(pushnext( Rbl , &xl, Bx~)~, next( 60x1, box3) ) = True where cy = {boxf /Bx,, box3/Bx~) Definition 23. For operator A and literal 4, clobbers( A, q) clobbers qa (makes for any LY E Bindings. it false) is true if and only if A, Note that we assume it is not possible to true for any assignment to both evaluate for some ground operator A and ground predicate p, then from Definitions 15, 18 and 22, we can derive: for establishes(A,,p) of A and p. If establishes( A,p), and clobbers(A,p) T.L. McCluskey, J.M. Porreous/Artijicial Intelligence 95 (1997) l-65 33 precons(A) = wp( [A],p). As a framework for our static analysis literals x and y (we assume be used. A node marked x&y identifies two ground through P6, between nodes represent two states identified by two separate nodes. We define a valid link between as follows: the goal establishment the set of all well-formed this set is non-empty); the valid links (sequences diagram of Fig. 8 will states which satisfy the labelled Pl and links, of operators) between two nodes Definition 24. A valid link X between lishment diagram, is a sequence of grounded operators such that: two distinct nodes Nt and N2 in a goal estab- l only the last operator in X changes the truth value of either or both of the two literals in Nt, l inconsistent( wp( X, Nz)&Nf ) is false. The effect of the first condition in the goal establishment nodes viable plan. follows sequentially If a sequence X forms a valid link between that there is a well-formed to produce a state that asserts N2. diagram. The second ensures is to make sure a valid link does not go through other that a link could form a two goal sets Nt and N2 it state that contains NI from which X can be applied There are five possible acyclic paths from any state asserting asserting p & q. The first two are defined by the node sequences: -p & ~4 to any state (1) (2) I-p&--% P&V> P&41 “P&43 P&41 [-P&Y, where in the first sequence p is established involving an operator which affects the truth values of both p and q. first, then q. The other three are “odd” paths, (3) (4) (5) [-p&v. L-P & -4, [“P&W, P&41 “P&4, P&V? “P & 4, p & -4, p & 41 P&41 For an example of a problem with a solution path such as (3), consider of filling a fixed container and q = ““container identified and a movable then the sequence of actions below corresponds the problem jug of equal volume. Letting p = jug full”, to the path in (3). full”, lfill jug from tapJill container from jugJill jug from tap] 4.2.2. Identifying blocked links For some goal sets certain paths may be unavailable is blocked nodes that satisfy establishment We define a path between diagram two (the operator set does not provide a way of changing between states to use the goal blocked paths between goal sets. thrust of our analysis has been to reason about “necessarily” because a link between the two nodes). The main two nodes NI and N2 to be necessarily blocked as follows: 34 TL. McCluskey, J.M. Pr,rteous/Artifcial Intelligence 95 (1997) 1-65 Definition 25. A path between is necessarily blocked two nodes Nt and N2 in a goal establishment iff there exists no valid sequence of operators diagram linking Nt and Nz. From Fig. 8, we can identify various distinct types of blocking between up & wq and p & q, including: l type (i) : only one link is blocked at PI (or equivalently P4), l type (ii) : only one link is blocked at P2 (or equivalently P3), there are no sequences of valid links l type (iii): joining up &-q to p&q (for example, when P 1, P4 and P5 are blocked), as well as various others (where P2, P3 and P5 are blocked, both PI and P2 are blocked, etc.). We can formulate type (i) and (ii), whereas rules for ordering goals for planning using type (iii) can be used for debugging and consolidating domain models. Type (i). A computable condition operator A E Ops that establishes of p, or the precondition formalised using Definitions for a blocked path at Pl q E Prds, either A also changes is as follows: given any the truth value is to p. This condition of A is inconsistent when conjoined 8, 15, 22 and 23 as follows. Let cz E Bindings, then: VA E Ops: establishes( A,, q) + clobbers( A,, p) V inconsistent(precons( A), &p) [il Theorem. [i] is a necessav and sz@cient condition for Pl to be blocked. is self-evident-if two nodes Nt (p & wq) and N2 (p&q) Proof (Sketch). That this is a sufficient condition it will never be possible p is true and q is false. To prove link between false, and obtain a contradiction. is false, we have it is the case, then to execute an establisher A and establish q from a state where that the it is a necessary condition we will assume [i] is is blocked yet condition (Y for which precons(A),&p Given substitution clobber p. Let us choose A to form this sequence, /I. We will show it forms a valid link between Nt and N2 as follows: last operator of X changes this case: there exists an establisher A for q under some and A, does not necessarily for some grounding firstly, only the in Nt. Secondly, we have in the value of any of the literals that is X = [A+] is consistent that [i] J+P(XN~)&NI =vW,,ln’W~~~v Now from our observation after Definition 23, and the fact that establishes(A,p,q), we have precons(A.,) = wp([Anpllq) and hence wp([A,pl,p&q)&p&“q=precons(A)np&p&Nq Now we are given that precons(A),&p is consistent, and so it follows that precons(A),p&p&Nq IYL. McCluskey, J.M. Porteous/Art@cial Intelligence 95 (I 997) l-65 3.5 as A is an establisher for 9. Hence wp(X, N2) & Ni is a valid grounded sequence connecting Nt and N2. This gives is consistent, and the required is consistent, [A,61 contradiction. Type (ii). This arises when the only block condition using is at P3 only). the functions defined above, for some (Y, /3 E Bindings, as follows: In this case we can form the necessary the path is blocked at position P2 only (and similarly if and sufficient VA E Ops: establishes(A,,p) =+ establishes( A,p, q) V inconsistent(precons( A), & ~q) Condition corresponds corresponds [ii] can be seen as the dual of [il. The first disjunctive to taking to the block at P2. the path through P5 straight to the main goal, while [ii] clause here the second it is not possible Type (iii). This arises when goal problem from any initial state (for example when Pl, P4 and P5 are all blocked). We describe this a major help in the pair {p, q} as being operationally domain debugging this way may in the specification. The pair may be added to form part lead to bugs being discovered software re-run with this addition. of the inconsistency inconsistent. We have found specifications, to solve the conjunctive and the compilation as pairs discovered and consolidating constraints, 4.2.3. “Lifting ” the analysis So far we have analysed the domain model assuming nodes are identified by ground and hence dynamic predicate instances, the regularity brought by the object-centred approach-that literals. In R3 there are over 1000 contingent, lo6 pairs. Using around objects of the same sort behave the level of the ground dynamic predicate structures, literal in the same way-we shall “lift” to the level of the sort variable. resulting in less than 400 comparisons. the analysis from In R3 there are only 20 Definition 24 can be extended by defining a node x&y, where x and y are lifted pred- sense) that join the identified (in the original satisfies (x&y),, all the well-formed states I such that range(I) states. Blocked paths are defined (Y E Bindings. Valid links between remain unchanged. When p and q do have one or more sorts in common, lifted nodes are therefore any valid in [i] and then a icates, as identifying for any grounding links the same way, and when p and q do not have any sorts in common, 6 conditions [ii] useful distinction or are prevented STATIC system possible co-designation SO for example, and Bxj are variables of sort Box, and Rmi and Rm.i of sort Room, and Dr of sort Door) then they should be considered under each and these sorts have more than one instance, of the following can be made as to whether their sort variables are made to codesignate from co-designating. As observed [47] comparing in a series of experiments with the that all the if p = on-jloor( Bxi, Rmi) and q = near_door(Bxj, Dr, Rmj) pairs of predicates means the different predicates should be considered. relations between co-designation uninstantiated (where BXi constraints: h Two liter& have a sort in common when both liter& have an argument of the same sort. 36 ZL. McCluskey. J.M. Porteous/Artificial Intelligence 95 (I 997) 1-65 Bxi = Bxj A Rmi = Rmj Bxi = Bx,~ A Rmi # Rm, Bxi # Bxj A Rmi = Rm,, Bxi f B+i A Rmi f Rmj The number of constraints may get large if many slots are shared, but the theoretical is always limit pairs of ground predicates. less than (and in our experiments much less than) the total number of 4.2.4. Use of goal orders The results of goal analysis can be used in different ways depending on the type of to be used. Here we will give two examples of their use with a planning total-order, goal directed planner. architecture Use of type (i) orders establish a goal set containing both false, a type (i) block in planning. When a total-order, goal directed planner has to goal p &q from a state where they are the conjunctive (at PI as shown on Fig. 8) gives us the rule: Rule (i): “Establish q, then establish p from the advanced state containing q.” (conditions effort looking This saves planning on line use of goal analysis the compilation solutions (i) and use of this rule forms has already been empirically [ 40,481. domains into the possibility of achieving q first, and avoids the such as inconsistent are only executed during phase). We have also found that the rule helps towards the optimality of of type the backbone of our earlier work on PRECEDE which speed up across different (Section 5 supplies some empirical evidence validated as producing planning for this). Determination Use of type (ii) orders block at P2 on Fig. 8)) a rule for guiding planning they are both false is as follows: in planning. When wff [ii] is true (i.e. there is a type (ii) to establish p &q from a state where Rule (ii): “Establish p in a goal directed fashion (as any plan achieving p will also establish q) .” Consider goals p = next( Bxl , Bxz) and q = next( Rb, Bx~) from R’, the example domain with only one robot, and with the binding that Bxl = Bx3. These predicates would display a type (ii) relationship some point making q true also under the binding constraint. To establish both predicates in RI therefore, to form a plan aimed at next(Bxl, Bx2) only. as it would be impossible to establish p without at it is sufficient constraint 4.2.5. Outline algorithm Fig. 9 shows an outline algorithm the components as input for their definitions). binding constraints It outputs if appropriate) for generating goal orders for generating of an operator complete domain model goal orders. The algorithm (refer takes to Section 3 (with (i) orders, and the other two sets of orders between pairs of predicates one resulting from type ZL. h4cCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) l-65 37 algorithm Order-Goals In Operator complete model M (Sorts, Objs, Prds, Exps, Invs, Ops) Out ODS: Goal Orders, CYC: Cyclic Goal Orders; }; CYC:={ }; for each 1 E PrdsD do for each 1’ E Prdso do codesignation( 1, I’, B); for each C in B do 1. ODS:={ 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. end for; end. end if; end for; end for; Ops, := (0, if VA E Ops,: (clobbers( A, 1’) under constraints C or / 0 E Ops& establishes( O,, 1)); inconsistent(precons( A) & 1’ &C) ) then if order( I’, 1, C) +! ODS then ODS:=ODSu{(Z,l’,C)} else CYC:=CYCU{(l,l’,C)}; end if; ODS:=ODS\{(l’,l,C)} Fig. 9. Outline algorithm for generating goal orders. (step 4). is empty. For each different it against every other dynamic predicate type (iii) blocks. The algorithm steps through each dynamic (steps 2-3). This pair constraints between If there are no variables then the set of codesignation cyclical orders representing predicate and compares is “lifted” and hence the next step is to find the set of codesignation variables of the same sort in the two predicates of the same sort that are common constraints C, steps 6-10 constraints the literal of interest operationalise then a check is made to see if all of these operators clobber 1’ or have 1 is constructed, inconsistent with I’, in the context of the constraints C. If it is the case that preconditions then an order (1, I’, C) all establishers In step 9 any orders are added to the output ODS where appropriate. has been identified. Type (iii) orders are generated after discovering (1, l’, C) and (I’, 1, C). This cycle is then added to CYC and the order (I’, 1, C) is removed from ODS. for 1 clobber 1’ or have inconsistent [il. Firstly, a set of operators there are orders between to the two predicates set of codesignation that establish preconditions condition 4.2.6. Possible goal orderings The analysis using the goal establishment diagram can be extended in a natural way to techniques based on possible orderings model are based on possible orderings between pairs of literals p and q as follows: establishment goal directed if the affect the truth value of q (given a the risk of a cannot possibly then q can be established of p by a planner search, say) [ 481. These techniques before p without such as ABGEN 38 i?L. McCluskey, J.M. Porteous/Art@cial Intelligence 9.5 (1997) l-65 would goal violation. This kind of heuristic was used originally by Knoblock planning-q therefore be a “detail” whose establishment [ 361. abstraction Consider space the space of all valid paths that can be generated for hierarchical than p. p would could be safely left to a lower level of the in a higher level of abstraction in this case appear through from any state containing states satisfying to establish p &q paths traverse then we can assert the heuristic it being violated when p is established. We return Section 5.3.3. “p&q either of the other that q can be established before p without (P4 in a goal directed search in Fig. 8). If nolze of these in the diagram the risk of in two nodes to the use of possible orderings 5. Evaluation of the method (similar test domain to the PRODIGY specifications include R”, introduced The method has been used to construct object-centred some familiar and some novel. These [ 501, STRIPS-worlds planning domains, in this paper, Russell’s Tyre World world have used tools presented models and have explored is to present some models using various planning of the results of these activities and demonstrate in a number of planning domains. Not surprisingly we devote most space to the results of the dynamic tests of the compiled domain models, as an account of the benefits of the use of a development method using a small set of test domains for a range of earlier scheduling in Section 4 to help acquire, validate and compile engines. The purpose of this section the benefits of the use of the method the effect upon planner performance [ 341. We these domain [ 491) and a warehouse world tends to be anecdotal. of the operationalised [ 5 11, a job-shop As a guide, the organisation In Section 5.4 we evaluate the four domains that were used method’s use in initially encoding and goal orders. results of random planning finally software used was implemented and all CPU measures are taken from this configuration. in Section 5.5 we summarise tests using compiled of this section in testing. the models, and compiling is as follows: In Sections 5.2 and 5.3 we evaluate in Section 5.1 we introduce the them to produce macros the and that all the configurations, by analysing the method empirically and uncompiled the benefits of the method. Note in Quintus Prolog running on a Sun IPX workstation, 5.1. The four test domains The most complex test domain is illustrated in Fig. 3). The most complex domain was the DR3 World, that is the domain described of this domain interactions was the Tyre World [50], which concerns on an automobile. The central problem in the domain, typically few orders which permit each goal remaining goals are established. These two domains contrast well: with respect interactions: in terms of structure, and number of distinct actions, in Section 2, with n = 3 (a state in terms of goal the ordering of repair actions a wheel, as that of changing [ 31, since there are very the to goal in the R3 the Tyre World abounds with potential goal interactions, whereas could be termed “laboriously serialisable” and then preserved whilst to be established formulated T.L. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) I-65 39 is relatively to structure, of two goals interacting the familiar STRIPS-world low (though still significant); the Tyre World has few static predicates to R3 which has many. In between World the probability with respect contrast we used: a variant of Sacerdoti’s STRIPS-world 10 doors in which a robot boxes. The latter an example domain used to test the PRODIGY complications moved around by the robot to unlock is [ 5 11, which consists of 7 rooms connected by is capable of opening doors and moving any of 3 different is an elaboration of a 6 room STRIPS-world which we adapted from a number of system to the domain: doors that can be locked and unlocked; and keys must be in lie the two other domains and the Extended STRIPS-world. [9]. It introduces these extremes and invariants, locked doors. The former 5.2. Initial construction qf domain models Construction steps, described partial description engineering” simple conditional state when dynamic syntactic testing alone. of operator in Section 2, several complete models involved looping times. Old literal-based of the domains, and to an extent the encoding through specifications resembled the method’s gave us a a “reverse from to the omission of task. The tool support revealed many errors in our initial encoding: errors, shown up using predicate cross-checking, effects, shown up by checking input with a consistent that the operators always produce a consistent state. Often these errors would be hard to spot using For example with R3, carrying out step 5 with the help of tool (e) in category 1 (cf. constraints. Use of the goal order generation led to the discovery of several new constraints, Section 4), resulted in 55 inconsistency tool in step 7 of the method subsequently as the production of cyclic orders encoding of the operator set. Inclusion of the new constraints appropriate) so on until our model settled on a final figure of 80 by the end of step 7. led to more cyclic orders output from the goal order generation in the (or debugged operators as indicated a lack of a constraint or an omission tool-and inconsistent tests described or impossible goal sets. Nevertheless, that the invariants built up in step 5 eliminated Analysis of random domain models showed potentially dynamic tasks randomly amount of invariants, however, 54 were found to be impossible problems. initially tasks generated by tool (f) in category 1 (cf. Section 4) for the a great many the invariants used in the of the 100 hardest to 12 were found In a batch of 100 that were generated without the use later in this section were still incomplete: for R’ (this set is called RDM7 below), the Tyre World with 15 inconsistency to “impossible” example, we As another problems. generated supplied constraints. The following are two of the constraints that were immediately apparent: inconsistentzonstraint( loose( Nuts, Hub) & tight( Nuts, Hub) ) inconsistentLonstraint( wheel_in( Wheel, Hub) & wheel_on( Wheel, Hub) ) but other constraints, such as the pair given below: inconsistent_constraint( have-nuts( Nuts) & tight (Nuts, Hub) ) inconsistent_constraintCfree( Hub) & loose (Nuts, Hub) ) 40 ZL. McCluskey, J.M. Porteous/Art$ciai Intelligence 95 (1997) I-65 Table 1 Size of the domain models’ sort abstracted components Model Objs Sorts Prds fiPS hVS OPS RY Tyre Extended STRIPS STRIPS 41 8 19 21 8 7 6 4 27 22 22 II 20 20 18 8 204 36 150 106 25 17 19 8 were not as obvious, but were revealed with the help of type (iii) blocks identified during goal order generation constraints. (cf. Section 4.2). In the final model there were 27 inconsistency To give a feel for the size of each domain model we indicate the number of elements in the model in Table 1. As the tool support was not available for each of the components the use of sort hierarchy. Thus at the time, our models were all built and tested without all the sorts used were primitive and all the predicates’ slots were restricted to a primitive sort. Use of the sort hierarchy mechanism would on the whole have made the components the number of ground elements of these components. more compact, without affecting the number of ground elements in the table: here the approximate instances For R3 especially, larger than the figures were in the region of 1,000 operator on conditional variations dependent around 1,700. The total size of the state space was thus very large difficult there were 87 distinct number of possible in a component was very much size of PrdsG was 4,500, there (in fact many more if one were to consider substates was indeed, although the sort Box: the for a given box, and with 6 boxes states made up of box objects alone was of the order of 876. in the presence of state invariants. Consider effects) and the number of distinct to calculate accurately in this domain substates 5.3. Compilation of domain models in the sense for each one. The size of the sets and that a set of macros, necessary the times are shown in Table 3. As predicted, All the domain models were compiled and possible goal orders were generated approximate generation tools was beneficial indicating by the results of the choice of a model’s components what are dynamic). One might make design choices based on, for example, and utility of the macro set so generated. in detecting bugs in the domain encodings, (e.g. what sorts and predicates in Section 5.4). Additionally, this stage is useful in plan generation new invariants, and delivering speed-up in evaluating (as demonstrated the utility are static and the number the use of compilation tightening encodings by 5.3.1. Construction of macro tables Using the notation introduced in the algorithm of Fig. 7, the number of entries in a macro table is bounded by the following formulae: T (ins”j* - in?, T.L. McCluskey, J.M. Porreous/Arrifcial Intelligence 95 (1997) l-65 41 Table 2 An indication of the space complexity of a macro table (K is some constant) Model feature that increases Number of dynamic objects Number of dynamic Number of substate classes Number of static objects sorts Table 3 Compilation results Generation of: Macros Necessary orders Possible orders Effect on the size of the macro table stays constant increases, bounded by K x lSortsol increases, bounded by K x I.!~JJs~~ increases polynomially Model R? Tyre Extended STRIPS STRIPS R3 Tyre Extended STRIPS STRIPS Rj Tyre Extended STRIPS STRIPS Number 2385 32 1926 824 98 30 105 18 56 23 65 19 CPU time several hours several minutes several seconds from partially instantiating this is what circumvents that is, the number of entries that result point (and critique of Universal Plans being built for each sort, as macros are indexed according rather than the whole planning derived from the algorithmic description, is of the order of the square of the number of elements substate classes with static objects. The crucial in Ginsberg’s bottleneck noticed table to the substates of an object state. The theoretical growth of macros with model size, the exponential is that our approach leads to a separate macro is summarised in Table 2. [ 271) in our sample worlds are summarised is the total number of macros generated in the first for that is, facts such as wheell The results of macro compilation part of Table 3. The number given model. The Tyre World has no static predicates apart from standard (that their potential macro generation the choice of substate classes. Where a solution validate problem fails as part of the macro generation process, goal or throws doubt on the choice of substate class expressions. for use in planning in domains is_of_sort wheel, etc.) and so the macro set is small, and that such as the Tyre World helps clarify goal structure and is low. It should be stressed, however, speed-up to a sort-abstracted planning it often uncovers an unreachable typing information time taken The maximum for the macro generation phase was for R3 which took several hours. This figure is acceptable since it should be seen in the context of the overall need only be performed time is changed). when involves On the other hand there are potential complexity problems as macro generation the domain model, because compilation taken the domain (and occasionally when the domain model is captured to create 42 ZL. McCluskey, J.M. Porteous/Artificial Intelligence 95 (1997) l-65 exponential. The central point is that this search the details of all but one of space which suppresses search and consequently occurs the dynamic in a sort-abstracted sorts. Another potential problem is inherently planning to store every generalised distinct macros intractable task configuration, we allowed shortest solutions. Recognising to allow a planner (it may be possible of a plan). recourse should be indexed by a task configuration. Given that our solution (including tests revealed was the question of how many that it would be to every the algorithm that this offers only heuristic coverage, we would have fail to fit in with the rest the macro generation non-optimal macros) the macro retrieved to produce only is required to the original operator set should that a locally non-optimal macro 5.3.2. Generation of necessav goal orderings Of interest during compilation in is the computational Fig. 9, the number of goal orders that will be compiled by it, and an assessment of the potential utility of the goal orders on planning performance. complexity of the algorithm Let N be the number of dynamic predicates of grounded dynamic predicates. Then c, the number of comparisons in Fig. 9 has to make is bounded as follows: in the domain model, and M the number that the algorithm N(N- 1) <c< M(M- 1). In practice c turns out to be much nearer N2 than M2. This is illustrated in Section 4.2.3: while gives 4 comparisons, the number of constraints grounded comparisons would be over 600. in the example the number of The dominating component during each comparison for inconsistency in our implementation tent function. Checking in general, although the form used for the examples tool) in the PRECEDE bedded check operator consistency. The tractability or otherwise of executing in this paper. In practice, is used after the state invariants have been specified constraints the inconsistent are limited function the inconsistency in a first-order to (em- to is the evaluation of the inconsis- theory is of course undecidable inconsistent(precons (A) ) for each operator “A” in the model would operator consistency then domain model. On the other hand, would suggest that the execution that this evaluate to the modeller this would time of indicate then be established as it is a condition of to false. If this were computationally prohibitive at an early stage the need to re-design if the execution time for this is acceptable the then this inconsistent(precons( A) &p) which is at the heart of PRECEDE, would also be acceptable. test results of using The summarised generated during to be of the order of minutes. in Table 3. The number this phase and tool to generate necessary goal orders is the total number of goal orders taken to note the difference is that were for generation was found in the number of time the maximum It is interesting the PRECEDE 7IL. McCluskey, J.M. Porteous/Art$cial Intelligence 95 (1997) l-65 Fig. 10. Graph of type (i) goal orders for the Tyre World. necessary goal orders across models. For the extended STRIPS-world the higher degree of interaction number of goal orders domain. increases of the 3 robots greatly possible ground establishers per goal and this explains goal orderings In R3 the introduction for this model. identified reflects the relatively large in this between goals the average number of the lower number of necessary As for predicted utility of the PRECEDE goal orders, we would expect the impact of to the size for our extended than the orders generated using goal orderings of the domain model. Hence we would expect STRIPS-world for domain R3. to have more effect on planning performance to the number of orders identified the orders generated to be related relative Example. using The declarative specification of the main problem a conjunction set, representing of predicate goals: the following in the Tyre World is posed {closed( boot, > , jack_in(jack,, boot1 ) , pumpin(pump, , boot, ) , wheel_in( wheel,, boot, ) , wrench4 wrench 1, boot1 ) , wheel_on( wheelz, hub, ) , tighf( nutsI, hub, ), inJated( wheel2)) which can be paraphrased the initial state asserts the boot” when appropriate tools are in boot,. The operators a wheel to be changed by jacking up the wheel, unbolting as: “replace a j?at tyre on a car and put all the tools away in that wheel1 has a flat tyre on hubl, and all the that make up the application’s mode1 allow the wheel nuts and so on. The PRECEDE pairs of predicates, bindings) and these are shown abstractly in Fig. 10. Each arrow corresponds in Section 4.2) between is without details of variable to a type (i) order. Type (i) orders are (that tool generated 30 type (i) orders (as defined 44 7: L. McCluskey, J.M. Porteous/Artijiciul Inteliigence 9.5 (I 997) l-65 If the goal is {a, 6, c}, however, that to solve goal {u, c}, subgoal a has to be solved not strictly associative, be the case sequence. to a set of predicates subset can be established subset from the resulting predicates. Using the orders reduce in the sense that if a < b and b < c then it may not necessarily first in a solution is total. When applied in the solution of the complement of the clobber any of the solved the eight goals to three: in any order, and subsequent advanced the set to a subset such that predicates state will not necessarily then their ordering the diagram we can see that the orders reduce {wheel_in( wheel,, boot1 ), wheel_on( wheel;!, hub1 ) , injkzted( whee/z)) The necessary orders are used at every planning node to order goal establishment in the same fashion. The diagram also provides an opportunity to check goal structure, and the validity of the operators tion to do with inflating a tyre before putting be a valid constraint. from which the orders were generated. For example, there is no precondi- it on a hub in the operators, yet this might 5.3.3. Generation of possible goal orderings ABGEN is an implementation in Section 4.2). We included based on the ALPINE algorithm presented in [ 35,361, interactions between goals (ABGEN which generates goal orders on the basis of possible was described necessary orders when choosing which goal to establish next during planning: given a set of goal predicates, necessary orders reduce goal choice by removing goals whose establishment would be undone by another goal’s establishment, as shown in the Tyre World example above. Possible orders are then used on the reduced goal set to further limit choice. Any predicates whose establishment may possibly clobber some other goal in the reduced conjunction from the goal set. The number of possible orders produced by the ABGEN are removed tool for the tests domain models are shown in Table 3. it in the tests as it complements 5.4. Using the domain models in planning 5.4.1. The FMD planner The planner constructed planner the use of goal orderings, macros and sort information called FMD. Assuming goal conjunctions to dynamically test the domain models was a goal directed, FMD to solve a planning the FMD reason and test the models. Our rationale was that its relative plan for speed of solution construction performance this was the main are serialisable, it to dynamically trading optimality very good planning total-order synthesises problem. By effectively planner demonstrates we selected generation on planner performance. (viz. planner overlong solution model. We could equally have selected other planning and some examples of these are discussed interacting Further, we predicted efficiency would provide a good test for the effect of domain compilation of a total-order to produce sequences) would be ameliorated by the use of a processed domain for our test platform that the disadvantages the difficulty the tendency goals and in solving algorithms in Section 7.5. FMD works on goals independently, advancing the plan state after partial solutions are found. For simplicity, we start by describing an outline version of FMD shown in T.L. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) 1-65 45 the workings of the planner, Fig. 11. To illustrate and the benefits of the combined use of goal ordering at a typical planning node when input with a compiled operator complete domain model, an initial well-formed represented as a partial mapping between object identifiers rules and macros, we will consider FMD’s behaviour state, and a goal condition and sets of substates. searches The algorithm through a space of open nodes, where each node has the form: node(N,A,I,G,OS,P) and has fields N = identifier, A = parent’s condition, OS = partial solution, P = the node’s purpose preconditions The partial solution slot contains initial state to produce the node’s the operator sequence the node’s current state I. the node was established to solve is invariably identifier, I = current state, G = current goal (the macro or operator whose the purpose of the node). that already has been applied to in the planner’s Step 1 initialises the matching process the set of open and closed nodes to sorting using a pre-defined partial order. The predicates the orderings of goal predicates generated during that should be solved process, a substate gs is picked Using ODS (step 5 in Fig. 1 I), compilation a member of one of the set of substates mapped range of goal condition G. This process of gs’s selection corresponds ground, hence table whose operation with linear lead to any increase instantiated member of M is applicable to establish (steps 8 et al.). If a node time complexity in complexity to one or more ground macros is picked whose current state solves index matches with (I,, gs) to by some object c say, from search space. the first. gs will be the cheap as it are In step 6 the entry in the macro look-up is one way and therefore does not this way will be (set M) according to the goal node. If a to I, otherwise new nodes will be created fashion of each member of M in a backchaining is retrieved. This process the weakest preconditions order. A macro operator it will be applied is straightforward. is computationally as matching in range(G) is a simple retrieved the goal G, then (steps 19 and 20) to N’s parent’s current state, followed by the purpose of the as an open a macro). Then the parent node is re-asserted its solution OS is applied node’s existence (typically node (step 21) and any of its ancestors are closed. to the outline design, In addition the algorithm was elaborated with some important extensions. l Firstly, it contained for loops the admissible heuristic of loop detection: the planner was able to check the in both developing plan OS in a node, and by checking the ancestry of a new node) and take appropriate the head and the tail plan is by checking action. (that l In step 6 FMD uses Ops rather than MT, and resorts to normal operator backchain- is uncompiled; (ii) of two or more substates. ing, in two cases (i) if G(c) Z {gs}, that is if the range of c is a disjunction if MT is empty as is the case where M l In step 20 the combined application of P and OS may fail due to goal violations-a problem that is without deal with solution to be developed that is much more acute when FMD is input with an uncompiled model, to detect and solutions the benefit of goal orders. The planner was equipped that clobbered protected goals by allowing sequences to different orderings of conjunctive goals. 46 T.L. McCluskey, J.M. Porteous/Artificial Intelligence 95 (1997) l-65 algorithm FMD state in M; In Operator complete model M (Sorts, Objs, Prds, Exps, Invs, Ops) ; hit: a well-formed Goal: a well-formed MT: a macro ODS: a set of goal orders for M Out SOLN: Operator sequence goal condition table for M; in M; 1. O-Nodes := {node( root, null, Init, Goal, [ 1, null)}; C-Nodes := { } 2. Remove node( N, A, I, G, OS, P) from O-Nodes; 3. while 4. 5. a substate gs using ODS, where gs E G(c) root or yachieve( I, G) ) do if lachieve( I, G) then Determine (N f 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. for c E Objs and I(c) +! G(c); Pick m from MT such that (f(c) for some CY E Bindings ,gs) satisfies the index of m, M := {m,p 1 j3 E Bindings is a grounding of m,} if there exists an m, E M applicable l-advanced := Apply mR to I; ONodes to I then := ONodes U {node( N, A,ladvanced, G, OS + +m,, P)} else CNodes for each mK E M do := C-Nodes U {node( N, A, I, G, OS, P)}; Wp := the weakest precondition Oflodes := O_Nodes U {node(New, N, I, Wp, [ 1, m,)} component of m,; end for; end if; else Retrieve node( A, Ap, Ip, Gp, OSp, Pp) from C-Nodes; IpAdvanced:= Apply P to (Apply OS to Zp) ; O-Nodes := O-Nodes u {node( A, Ap, IpAdvanced, Gp, OSp + +OS + +P, Pp)}; Move all nodes which have ancestor A from OiVodes to C-Nodes end if, Choose and remove a node( N, A, I, G, OS, P) from OYVodes; 22. 23. 24. 25. end while; 26. SOLN := OS end. Fig. I I. Outline algorithm of FMD. TL. McCluskey, J.M. Porteous/Artijicial Intelligence 9.5 (I 997) l-65 47 Finally, three variations of FMD were created by adjusting the choice strategy of step 24. The variations were called HS, DS and BS, and are defined as follows: l HS: a heuristic that used the following heuristic planning candidate to expand: either a single goal or a partial solution before any other nodes breadth-first the expansion search). favour search strategy nodes to evaluate which of open nodes with to (and default l DS: a depth-first l BS: a breadth-first search strategy. search strategy. Example. Assume we use FMD with a compiled condition G, which and their sets of possible substates. Assuming G is input in literal-based a goal form of R3, and consider four objects box2, tom, harry, door45 and form as follows: is a mapping between {on$oor( harry, rooml) , on_j?oor( box2, room5), next( tom, key2), near-door( box2, door56, room5), locked(door-45)) then the goal orders ODS will identify onfloor as the first predicate c = box2 as the domain element of G. That is, to be solved, with G(box2) = {{ on oor _ji (b 2 ox , room5), near_door( box2, door56, room5))) and hence gs = {on$oor( box2, room5), neardoor( box2, door56, room5)) As G(c) is a singleton, the next step is to retrieve the entry from the macro table whose index matches (I (box2), 8s). Assuming I(box2) = {on_JEoor(box2,rooml)} then the entry retrieved from the macro table, and instantiated with the instance box2 is [pushtodoor( Robot, box2, door12, room1 ) , pushthrudoor( Robot, box2, door12, rooml, room2), pushtodoor( Robot, box2, door25, room2), pushthrudoor( Robot, box2, door25, room2, room5), pushtodoor( Robot, box2, door56, room5) ] If this macro’s preconditions it will be applied, otherwise new nodes will be created are satisfied by I for some value of parameter Robot then to recursively establish them. search space Overall, FMD’s and the use of goal ordering is reduced by the use of macros cutting out search sets of goal during operator backchaining, that make up the main goal or a macro’s preconditions. Use of macros and predicates cheap, and the size of macro tables and goal orderings at each node is computationally goal ordering sets does not grow unmanageable with the rise in numbers of sorts or dynamic objects. Hence speed-up does not seem to suffer from the “utility” problem as described rules linearising in [ 431. 48 TL. McCluskey, J.M. Porteous/Art@cial Intelligence 95 (1997) 1-65 compiled HS compiled DS compiled BS ________~-------- uncompiled HS _______-N-----_-- uncompiled DS ___-----+-------- uncompiled BS Fig. 12. Legend for results graphs. 5.4.2. Planning conjiguration Twenty-four planning configurations were constructed by “bolting” the four domain in both compiled and uncompiled ( R3, Tyre, STRIPS, and extended STRIPS), models form, onto each of the three different variations of the FMD planner BS). The compiled necessary and possible goal orders. (HS, DS and forms would therefore have use of the previously generated macros, random problems which were split To test these configurations we generated one thousand problems as follows: l For each of R3, the extended STRIPS-world and the STRIPS-world we generated into divisions of one hundred three hundred problems called RDM3, RDMS and RDM7. RDM7, for each model, contained generated 7 randomly consisting positive, ground likewise, with their goal literal sets being of size 5 and 3 respectively. For example, problem goal set no. 36 for RDM7 of R3 was: ’ state, and a goal set containing literals. RDM5 and RDM3 were formed of an initial {key_on-Joor(keyl, room7),status(light3, room3,on), unlocked(door35), robotin( tom, room3), key_being_held( key3, harry, room4), keynext_key( key1 , key5), boxnear_door( box1 , door23, room3)) which corresponds to achieving goal states for six objects {keyl, light3,door35, tom, key3, boxl}. ’ As previously mentioned names used arc more elaborate than those in our previous examples in R”. the tests were encoded without use of a sort hierarchy and hence the predicate T.L. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) 1-65 49 Table 4 Solution STRIPS Extended STRIPS RT Tyre length (Len) averaged over the number of successes (WC) within the set resource limit DS BS HS camp uncmp camp uncmp camp uncmp len 19 32 42 22 34 49 32 49 61 21 sue len sue len sue len WC len WC len sue 100 100 100 100 91 96 9s 74 51 100 36 64 76 36 55 76 41 64 85 33 99 100 94 99 92 86 38 13 s 100 19 29 36 20 31 42 22 33 46 21 100 100 100 100 98 98 91 61 46 100 21 28 3s 22 32 44 II 21 29 31 100 88 82 9s 81 72 35 9 3 100 19 29 35 20 35 42 23 36 46 21 100 100 100 100 99 98 92 66 49 100 20 31 38 23 34 46 18 29 34 31 100 100 97 98 88 81 57 17 8 100 RDM3 RDMS RDMI RDM3 RDMS RDMI RDM3 RDMS RDM7 l referred (door35, to be locked to be well-formed using literal set was to unlock the problem of impossible light3, key3, boxl) while others in particular doors were not allowed to in a goal set have a unique goal substate (here tom) can be satisfied by a range the model’s initial states were randomly generated, but from a reduced (unless one the door). This was to tasks where, for example, a key is Some of the objects keyl, of substates. Initial states and goal sets were all generated state invariants. Further, state space where of the goals of the corresponding attempt to overcome locked away in a room. required but is inaccessibly For the Tyre World a test file was generated consisting of 100 random permutations of the 8 goal predicates described in Section 5.3. The initial state (the flat tyre!) in this case was kept fixed. The results of the experimental there is a separate figure representing of seconds plans created using steps 13-l 6 of the FMD algorithm world, extended STRIPS-world represent the results the three different the Tyre World each graph contains one tigure for the problem consisting of 100 random permutations lines have been used to plot continuous versions of the domain model, as shown in the legend in Figs. 13-20. For each domain in terms of CPU (the number and nodes (the number of new partial in Fig. 11) . For the STRIPS- and R3 worlds each figure contains 3 graphs which for each of labelled RDM3, RDMS and RDM7. For sample, called RDM8, of the problem given above. Within each graph for the six different terms of CPU or nodes as shown on the legend) taken to generate a correct solution) the results (Fig. 12). tests are summarised the results measured random problem and dashed samples, (in Table 4 summarises the average solution limit of 60 CPU seconds the ( 120 CPU seconds for R3). Note that the number of the average (as the problems actually solved tend to be those with a shorter solution). Thus in R” is less than 100, has the effect of reducing length of the problems from the uncompiled length of solutions if it is significantly solved within configurations solution resource problems solved, length the average small because only the simpler problems were solved. TL. McCluskey, JM. Porreous/Art$cial Intelligence 95 (1997) l-65 RDM3 RDM5 1 3 CPU limit R seconds7 9 1 3 CPU limit b seconds7 9 RDM7 1 < CPU limit in seconds = Fig. 13. CPU: STRIPS-world 5.4.3. Discussion of results in more of goals is virtually the solution of conjunctions the poorest compiled configuration for this domain model, measured in terms of CPU and in Figs. 13 and 14, These results show that for trivial. Out of the solved than 85% of the batch in 3 seconds or under. Even the hardest the best, solving STRIPS-world. The results number of nodes expanded are shown the compiled models 300 problems generated, each problem 15% were all solved within 16 CPU seconds. Compiled HS performed each of the 300 problems seconds per solution. The uncompiled with seconds of CPU time. The results of the uncompiled with choice of search strategy, and predictably poorer in plan generation poorest solutions. varied appreciably search the in 7 seconds or less, with an average CPU expenditure of 1.7 time and space usage, and the depth-first search producing to solve 3 of the 300 problems within 60 configurations were in contrast the graphs show breadth-first the best configuration less successful, configurations (depth-first search) failing (HS) An interesting observation ation, by all of the compiled planning for more than three quarters of the problems is that the number of nodes expanded during plan gener- low. For example, the average number of in sample RDM7, is consistently configurations TL. McCluskey, J.M. Porteous/ArtiJicial Intelligence 95 (1997) 1-65 51 RDM3 RDM5 Node limit Node limit RDM7 _+_-.+..a-- 20 100 Node limit 140 180 Fig. 14. NODES: STRIPS-world. (this can be seen by comparing nodes expanded during planning problem with the graphs the compiled breadth-first 90 nodes, of the same 100 problems within the same uncompiled is less than the length of the resulting the average solution solution for the lengths given in Table 4 in the use of space is that while search solved all 100 RDM7 problems within a space limit of to solve one problem out only managed configuration in Fig. 14). The most striking contrast this space limit. One might expect solutions made up of macros does not produce provably-optimal (i) we attempted to laboriously compared these with eral in this model can potentially our hand-validated line with the average solution ble. the generated to be overly solutions we believe solutions find optimal (ii) solutions, long. Although PMD they are close to optimal since tasks by hand and lit- solution of one take an operator sequence up to 20 in length, and is in in the ta- set solutions the optimal as shown to some sizes of the problem tests show an average of between 7 and 8 operators. This Extended STRIPS-world. As with the results for the STRIPS-world, that the overall effect of domain model compilation solution of the problem the results show in the for the hardest problem sample. Consider is a dramatic improvement the results again 52 TL. McCluskey, J.M. Porteous/Art$icial Intelligence 95 (1997) I-65 ADM5 1 3 CPU limit R seconds7 9 ADM7 CPU limit in seconds Fig. 15. CPU: Extended STRIPS-world. sample, RDM7, where Fig. 1.5 show that around seconds, of the problems. For the other problem improvements Comparison in which time are as impressive. of the results number of nodes expanded, ble 4) reveals piled planning 3 problem less than plans. samples, the average length the problems are all goal sets of size seven. The results in two thirds of the RDh47 sample problems are solved within 5 less than 20% the best uncompiled configurations have solved samples RDMS and RDM3, the performance the average in Fig. 16, which plots planning performance and the in Ta- that the number of nodes expanded during plan generation by the com- the domain configurations is of solution in terms of number of operators) the number of nodes expanded for at least 80% of problems length of solution plans in this planning is consistently low-across (measured (shown against for this domain are represented graphically @ World. The results The additional complexity harder than the those in the STRIPS-worlds. Also, in this model some problems set were impossible the tests of the static invariants. As mentioned above, RDM7 was found in this multi-robot world means that problems are considerably to contain at least 12 impossible problems. to solve despite passing in Figs. 17 and 18. TL. McCluske)~, J.M. Porteous/Artijicial Intelligence 95 (1997) l-65 RDM3 RDMS Node limit Node limit RDM7 60 Node limit Fig. 16. NODES: Extended STRIPS-world there is a marked difference Again configurations from the uncompiled levels off-much many further successes. and the uncompiled configuration more resource given rate between in the solution the compiled planning to the harder problems configurations, are particularly poor in that the gradient of the graph is clearly not going to lead to to these problems and solutions Although the compiled planning configurations fair much better, the fact that in R3 that with the CPU limit suggests poorer the compilation the performance techniques were not as useful. Also, two thirds of the problems were solved within than HS and DS across the three problem samples since for all the other domain models configurations only some problems of BS is consistently domain. This is interesting the three compiled planning the impact of model compilation method. The reason to lie with and extended STRIPS-worlds macro usage was around 80% (i.e. reverted generated MD the R3 world macro usage had dropped is starting worst. for this of that search the amount of macro usage. In the STRIPS- in 20% of nodes to its original operator set to establish a goal), whereas with the compiled configuration R3 configuration with BS faring the performance result which suggests of the particular to 40%. Thus of an uncompiled is to some extent is very similar-a the behaviour independent to exhibit seems 54 TL. McCluskey, J.M. Porteous/ArtiJiciul Intelligence 95 (1997) I-65 RDM3 I RDM5 RDM7 Fig. 17. CPU: R-’ world length is summarised in Figs. 19 and is remarkably Tyre World. The results of the tests in this domain are shown graphically in Table 4. Performance 20 and the average solution similar for the three compiled planning configurations different configurations are superimposed on each other) and the average solution are identical at 21 operators per problem. Somewhat surprisingly, given Russells in his encoding of this domain [ 501, the uncompiled problems the uncompiled planning generated optimal contain 19 operators: planning uncompiled planning 33 operators). can be explained by the fact that the total-order algorithm FMD can produce sub-optimal plans whereas Russell’s planner only length plans for the problem sample RDM8 length of solution plans generated by the compiled the length of plans generated by the (between 31 and (so much so that the plots for the lengths results configuration BS solves 100% of the for in an average of 2 seconds per problem. The relatively good performance configurations was on average 50 per cent longer configurations was 21 operators, whereas solution plans. Optimal configurations the average planning Barrett and Weld describe of 6 hours for solution combination Our results time for early experiments this domain as being “fairly difficult”, and quote a figure [ 3, p. 991. The best in the domain solution. and to reach an optimal takes 123 seconds for the compiled configurations, of their own algorithms show that the problems were trivial TL. McCluskey, J.M. Purteous/Artijicial Intelligence 95 (1997) 1-65 55 RDMS 250 Node limit 250 Node limit RDM7 Node limit Fig. 18. NODES: R” world time for each problem (at 1 second in solution rules produced very useful that the goal ordering supporting our contention during planning. On the other hand, one should point out that to achieve substate class the guarantee of optimality that the the introduction that there was virtually no variation of CPU), orderings these results we have to (a) create a full domain model with invariants, expressions, when using a planner further Section 5.5.2). the model, and (c) sacrifice (although we found types of ordering devices produced an optimal solution for this problem-see etc., (b) compile such as PMD of 5.5. Evaluation summary 5.5.1. Evidence from dynamic testing The results indicate that the compiled configurations are relatively superior, producing shorter solutions using much less CPU time and much less space compared to generally the uncompiled ment, as many problems the uncompiled compared configurations. It was impossible to distill an overall factor of improve- solved by the compiled configuration were never solved using configurations. Also, the results for the Tyre World are very impressive to other results given in the literature. 56 TL. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) I-65 RDM8 . c? I 1 3 CPU limit Fn seconds7 9 Fig. 19. CPU: Tyre World. 100 go- n Q) 80. z ,’ ,’ 0 ,,.--4 RDM8 ,.___*__*__-*’ .’ ,I ,’ -3 /’ I J I 20 60 100 Node limit 140 180 Fig. 20. NODES: Tyre World. configurations The compiled also rate well sense. Firstly, the average number of nodes expanded during successful plan generation by the com- the resulting piled planning average results which point to the required length of a solution plan). Also, the distinctive effect of different search strategies over in the majority of tests (in contrast rising exponentially with respect configurations was consistently to the number of nodes low, and was less length of solutions to theoretical fundamental in a more than TL. McCluskey, J.M. Porteous/Artijicial Intelligence 95 (1997) l-65 51 all the domain models was dampened tent feel to the results. This suggests is to some extent rithm. independent giving a consis- by the effect of compilation, that the impact of the compiled domain model algo- in the planning search method of the particular 5.5.2. Effectiveness of FMD + goal orders lead FMD In general goal orders (i) goal orders allowed PMD the total-order planner produces on average a sub-optimal times. This conclusion in this world had a negligible to produce shorter solutions is supported by the Tyre World and to shorten plan tests as their use of effect. Although PRECEDE’s generation to obtain a sensible ordering of the Tyre World solution of 21 rather to be that while working on top level goal two sub- Investigation of p and q to establish p only, by a generation of macros type goals, than 19 operators. The cause was found wheel_in( wheel,, boot, ), there was a lack of an ordering constraint between goals p = unfasteaed( Hub) and q = jacked-up{ Hub, Jack). here shows it is impossible from a state which contains {up, wq} since all establishers valid sequence of operators to consider for p have q amongst unfastened( Hub) only, and in their combination with type (i) would lead to an optimal order for this problem. their preconditions. Type (ii) rules force the planner that we have a type (ii) block: 5.5.3. Effectiveness of FMD + macros We will use the factors introduced testing. set, in the light of dynamic in Section 4.1 to judge the effectiveness of a macro ( 1) The likelihood of some macro being usable at any step in solving any given that the macro table spans the whole set of task configurations, problem: Given for TSA domains. As the test models were this likelihood would be a certainty not TSA PMD reverted to operator backchaining when a unique substate could not be found for the object described by a chosen goal predicate. Across all our ranged between results from R3 with a 40% and 85%. As predicted, macro usage averaging 40%. the use of macros, as a percentage of all nodes processed, result were obtained the poorest into sorts provides a means of decomposing (2) The amount of processing (search) a macro cuts down: The method of engineer- into is sup- to obtain are trivial because in (here goal ordering ing domain models useful sub-problems where ported by observations solutions of the lack of static structure, such as in the Tyre World, the form we have described makes no significant difference is the dominant above on the small amounts of nodes required In models where substate this “factors” out some of the search. This the use of macros factor in planning in the results. speed-up). transitions problems (3) Cost of searching for an applicable macro during planning: As the index used the cost of searching a macro to search for a macro is a ground pair of substates, table is not subject to exponential matching problems. (4) Cost, in terms of solution non-optima&y, of using a macro: Our experiments suggest the combined that this cost is low as argued above. We believe use of goal ordering techniques to that order goal sets so that the that this is linked 58 T.L. McCluskey, 04. Porteous/Artificial Intelligence 95 (1997) I-65 establishment self paraphrasing Banerji satisfied subgoals of one goal cannot undo another. As Korf states [ 37, p. 451 (him- . . . leave all previously [ 21) “macros intact while satisfying that are useful an additional subgoal”. (5) The cost of generating and maintaining the macro set: The average cost of a a fraction of the average cost of solving a macro is generally generating problem sorts except the one in question. The parameters size were detailed above and in Table 2. in the full domain model as macro generation abstracts out all dynamic a macro table’s that determined 5.5.4. Summary of the bene$ts of the object-centred approach that we postulate here appears The object-centred approach to help solve of the planning the problems associated with process, and (b) of the planning approach which focuses on enriching domain models. Both these problems tools of the complexity integrates our method and management verification engineering tematic way that leads to a (compiled) is much easier ties for checking our understanding model. to find. Yet at the same time the model with knowledge in which the solutions representation to problems creates more opportuni- of the domain and the accuracy of the resultant this enrichment to form the glue (a) that the and are attacked by our in a sys- the validation 6. Related work at the object to plan generation into utilising an object-centred Up to now there has been little research the process of plan generation. A recent exception is similar representation is the PLANRIK algorithm to manage [ 201. This level in our framework as object states are used as the basis for plan generation. Linear plans are formed for each object in the domain by ignoring all other objects, and then merging them with a current global alternative (this is an interesting to the use of plan to produce a partially-ordered the merging operation may well introduce a total-order planner a processing to move objects, overhead). from our framework and the precedence between object states, are all decided on-line during planning, rather is at the object rather than than during a compilation the object class (sort) although PLANRIK differs stage; and the level of planning in that the plans plan An interesting can be made with types of planning should be able to take advantage of this to improve the inherent [30], who point out that many planners structure exploits transition graph induced by the operators. Although to make planning their representation in problems by studying is proposition-centred tractable, rather than object-centred. problem are highly structured the work of Jonsson and Backstrom and their efficiency. Their work in a state- the authors exploit domain structure issues, and restrictions structural their work is not aimed at domain engineering There is an increasing in [ l] was used to produce a model the modelling of planning domains. For example, of planning awareness of the need for structured approaches and associated the KADS method- control knowledge. and its use for knowledge base system development, independent tools to support ology KADS is a proven methodology level. comparison IL. McCluskey, J.M. Porteous/Artijicial Intelligence 9.5 (1997) l-65 59 from our own, however, for use in hierarchical the impact of modelling inference structure” is quite different and Pryor that can result from includingfilter sharply with our planning-oriented, contrasts work cited a “KADS portance of understanding by Collins demonstrated incompleteness In deductive planning, Biundo and Stephan domains well as taking a formal view of proving they further engage other software engineering model reuse. An integral [5]. They use temporal feature of our method systematically recognise in custom-built method. The output of the in that the model produced was skeletal plan refinement. The im- in particular ways was domains the potential problems of in operator preconditions. the need for modelling planning [ 161. They showed conditions logic as a formal framework, and as the consistency of models using concepts such as abstract data types and invariants, is the emphasis on the use of tool support at all stages of domain model capture and validation which is is in part inspired by our work [41,56]. The need for tool support and requirements in formal specification capture being reflected for domain engineering for example Des is increasingly in the literature, the need for tools to help capture domain models Jardins work with SOCAP emphasised [ 191 and Chien showed the planning domain model that for the Multimission VICAR planner such tools reveal might appear straightforward can be “painful [ 151 he takes the to manually or otherwise work further, of planning [ 14, p. 261. In a more recent publication static analysis [ 141. As Chien states, some of the errors the importance of tools to validate track down” introducing to catch but nevertheless tools to analyse the achievability goals. reasoning Intelligence is captured to automated in a declarative tools to transform the search needed in simple domains is the use of compilation in general. For example, a common Another key aspect of our approach a domain model into a more “efficient” operationalise) areas of Artificial and rule bases is that an initial model to the domain and the modeller( s) and then this is compiled is more amenable into a procedural (see for example work on COLAB Work on macro generation was pioneered by Korf [37] who used macro (or form. This reflects trends in other feature of knowledge form that is best suited form that in [6]). tables such as the Rubic’s Cube, and this was discussed tool improve planning (i.e. macros) to a perceived advantage of hierarchical (non primitive operators) to in solve problems efficiency Section 4. The macros generated by our compilation is not required since task reduction at planning sup- planners: (this HTN framework, plied by the domain modeller, in the tradition of NOAH to partial- [52], has recently been formalised order planners by Erol et al. [ 221 and Barrett and Weld [ 41 for example). We argue that flavour as task our macros serve the same function: and unlike other examples of macro reduction since use they do not heavily because macro selection and instantiation factor during planning to the current state as well as the goal conditions, is STATIC is linked to our macro generation they are sort abstracted; increase time. This is similar schemas that remove search during planning they have the same “hierarchical” contain plan fragments, the “plan fragments” A related work [24], a method and compared task reduction the branching to construct technique schemas acquiring compilation object-centred control rules for operator and binding tool, although an important difference domain theories whereas STATIC analyses for selection. STATIC can be viewed as a reasons about for each is that our technique static interactions 60 LL. McCluskey. J.M. Porteous/Art$cial Intelligence 95 (I 997) I-65 literal. In addition, the output of our method domain generated stack cycles” the work of Poet and Smith to the transition partial-order is sets of sort abstracted macros through a process of sort abstracted planning whereas STATIC analyses “goal- is also carried out in [ 541. They show how operator graphs, which are similar in to generate control rules. Static analyses of operators graphs we used in Section 2, can be generated to analyse planning. threats There are a number of systems that appear the that forms part of technique PRECEDE has been used elsewhere. For instance, Dawson [ 181 compiled pairs of predicates concerned with literature in the system that cannot be simultaneously generation of goal orders for planning. The identification of interactions our goal ordering and Siklbssy’s REFLECT assertions”), domain and Drummond work on “temporal to our negative partial plans with similar work is that invariants are used to identify goal interactions stage in a problem-independent a compilation coherent outstanding true in a consistent state invariant preconditions. temporally invariants) manner. and Currie [21] used state invariants coherence”. Both sets of researchers used these invariants that were similar uses a to compile goal orders but a key difference with this and other and form goal orders during PRECEDE (“incompatible state of the planning “on the fly” to speed up planner performance, in their (similar by selecting 7. Future work 7.1. Extensions to sorts More research and development is needed expressive, and less dependent on STRIPS-type integrate more might usefully sort as an aggregation of other sorts, for example: ideas from the object-oriented introduce aggregation to our model-that framework more to make our current assumptions. Also, it would be useful to software design areas. For example, one is defining an object of one Box = box( Box-id, Shape, Colour) . Further, we could introduce recursive sort definitions, for example: Stack = above( Box, Stack) U BOX. Two object instances of sort Stack might be: box( box1 , small, green) above( box( boxl, small, green), above( box( box2, medium, green), box( box3, large, red) ) ) For such recursive theforms of the structure data type might define each type operation constructor forms of the type [ 561). sorts, substate class expressions would (in the same way that an equational of include an enumeration specification of an abstract the different in terms of how it re-writes T.L. McCluskey, J.M. Portenus/Artijicial Intelligence 95 (1997) I-65 61 p & -q & -I‘ . p&q&-r x \ -p&q&r ___) - p&q&r / -p&-q&-r - -p&q&-r \ x / -p & -q & r p&-q&r Fig. 2 I. Goal establishment diagram for 3 literals 7.2. Improvements to goal order generation and use resulting techniques The goal ordering from our analysis need to be implemented that were presented interactions progressing in the paper generated goal order- between pairs of lifted predicates in three ways. Firstly, further or- (the results were based solely on type (i) necessary orders, and possible or- so it tests for interactions between pairs the analysis consider that this diagram and the (for exam- in the ings based on an analysis of necessary in a domain model. We see development dering procedures experimental ders). Secondly, we could extend the technique of substates to consider the goal establishment assert the 3 ground diagram ple between p k-q 3-diagram: for some sort in a domain model. Thirdly, we could extend larger groups of predicates shown for goal ordering. As an illustration, in Fig. 21. This shows all the valid states literals p, q and r. The relationship between (Fig. 8) and p &q> is that a single “block” the following blocks in the 2-diagram for 2 literals is equivalent and tested to finding diagram [p&wq&w,p&q&-r] [P&Nq&r,p&q&rl So finding a block rules being in the 3-diagram will lead to an increased number of “finer grained” identified, but where these rdes will be less widely applicable. 7.3. Improvements to macro generation and use The regularity of the object-centred approach is crucial for creation and use of a Macro Table. We have not exploited procedure however. Currently our planner makes use of macros where goal. We have yet to experiment with full use of Macro Tables in the disjunctive the chosen goal predicate defines a unique substate in a limited manner, to the effectiveness of the the idea fully, in the case in the context of the current substate 62 TL. McCluskey, J.M. Porreous/Artificial Intelligence 95 (I 997) I-6S situation, or in applications on the form of a macro producing macros tables with partially-ordered 7.4. Incomplete information involving TSA models. More development is also required table. The size and flexibility of tables would be optimised by and by filling than for primitive sorts only), (rather for supersorts rather than linear macros. operators, A promising non-deterministic unknown. To do this we remove of substates; information the range of possible constraints set of possible of the substate When an operator The attraction range of states specified for each object. situations area for exploration is the use of sorts and substates and domains in which the exact substate of an object the constraint that a well-formed to be a vector of sets of substates. to cleanly capture is state is a kind of vector Incomplete instead a state is generalised about an object means that it is represented in the domain model on operators can be loosened so that their effect causes an object states. This can be done, for example, by allowing change to match on more in operators rules is executed in using object-centred it will therefore leave representation (and hence uncertainty) is bounded by the range of possible as a set of substates-that that it could be in. Likewise, is the to be in a the right-hand sides than one substate class. in a set of substates. for this extension would be that the substates the object 7.5. More powe@l sort abstracted planners To date the main platform tools has been conventional planner of a fully sort engineered “literal-based” for our empirical evaluation of sort engineering and compi- planners. Our future work will involve that reasons solely at the level of than at the level of the literal which can be used as a platform to our current platform which, at the some reasoning planner will be more the rep- the merits of our theory, performs this sort engineered a sort engineered It is anticipated the system will help further evaluate afforded by extending domain that This will be in contrast throughout rather lation the construction the object for future experimentation. accepting although level of the literal. efficient resentation approach. level than our current system and that the continuity Part of the development of this new planner will involve experimentation using sort compiled domain models with other plan generation algorithms such as HTN, [ 521, which has recently been formalised in the tradition of NOAH tools can be seen as storing abstract planning planners by Erol et al. [ 221 and Barrett and Weld 141. since the macros that are generated by our and as such they solutions, engineered a hierarchical planner and compared to partial-order This appears a promising area of investigation compilation could provide solutions Alternatively, provide an advanced constraints that required with temporal constraints on the initial goals. Any other the use of goal orderings the establishment if appropriate. for a hierarchical planner at levels organised by sort abstraction. tools could initial partial plan for use with a partial-order planner with temporal in an advanced partial plan of goals could likewise be augmented that are output by our compilation of a conjunction temporal point T.L. McCluskey, J.M. PorreousIArtificial Intelligence 95 (1997) l-65 63 8. Conclusions In this paper we have argued for a change in the emphasis in classical planning aspects of domains. This can be done by creating independence, an object-centred a measure of domain and properties which formalised to take into account knowledge-based retaining example, which helps in validation and refinement of such a model. The method was supported by the model, and a description of the two In particular we detailed form of the model, and showed research cleanly, model. We have detailed a rigorous method, using a non-trivial the acquisition, a set of definitions tool support required compilation how their use in compiling when used in conjunction with a total-order planner. Using compiled knowledge down search recent effective to cut as to our knowledge, more improvement, techniques Finally, we see our work as the first step towards in this way is evidently for planning tools that capitalised on the knowledge-based improves plan generation performance, for each step of the model’s lifecycle. as powerful and yet as generally than using other machine the domain model techniques applicable algorithm speed-up. learning and for planning (a) providing theoretical planning a bridge between research and (b) so that models can be research groups, and properties of these models can be uni- planning for planning domain encodings and clean, realistic, application-oriented providing exchanged versally understood. a set of standards easily between Acknowledgements Our thanks go to Diane Kitchin, Blaga Iordanova, Steve Scott and Malcolm Roome and to Colin Pink and Iain Anderson for reading over earlier drafts of this document, for help with production of the results graphs. References [ I 1 J.S. Aitken and N. Shadbolt, Knowledge Trends in AI Planning (10s Press, Amsterdam, level planning, 1994). in: C. Bkkstriim and E. Sandewall, eds., Current 12 1 R. Banerji, GPS and the psychology of the Rubik cubist, in: A. Elithom and R. Banerji, eds., Artificial and Human Inrelligence (North-Holland, Amsterdam, planning: and D.S. Weld, Partial-order 131 A. Barrett 1983). evaluating possible efficiency gains, Artijicial Inrelligence 61 ( 1994). I4 I A. Barrett and D.S. Weld, Task-decomposition via plan parsing, in: Proceedings AAAI-94, Seattle, WA (1994). IS I S. Biundo and W. Stephan, Modeling planning domains systematically, in: Proceedings f.Zth European Conference on Artificial Intelligence (ECAI-96) ( 1996). [ 61 H. Boley, P. Hanschke, K. Hinkelmann and M. Meyer, COLAB: a hybrid knowledge compilation (1993). laboratory, Tech. Rept. RR-93-08, The German Research Centre for Artificial representation and Intelligence I7 1 T. Bylander, Complexity I81 T. Bylander, Complexity results for planning, in: Proceedings IJCAI-91, Sydney, Australia ( I99 1) results for extended planning, in: Artificial InreUigence Planning Systems: Proceedings 1st International Conference ( 1992) 19 I J.G. CarbonelI, C.A. Knoblock for planning and in: K. Van Lehn, ed., Architectures for Intelligence (Morgan Kaufman, Los Altos, CA, 1991). and S. Minton, PRODIGY: an integrated architecture learning, in: Planning nnd ( AAAl 64 TL. McCluskey, J.M. Porteous/Arti$cial Intelligence 95 (1997) 1-65 I IO1 A. Cesta and A. Oddi, DDL. I : a formal description of a constraint for physical in: M. Ghallab and A. Milani, eds., New Directions in Al Planning (10s press, Amsterdam, representation domains, language 1996) 341-352. I I l I A. Chang, I? Kannan and B. Wong, Design of an object-oriented system for manufacturing planning and control, Manufacturing, Troy, NY ( I99 I ) in: Proceedings Rensselaer’.r 2nd Internutional Conference on Computer Integrated [ 121 D. Chapman, Planning [ 131 J. Cheng and K.B. Irani, Ordering problem subgoals, 1141 S.A. Chien, Towards an intelligent planning knowledge base development environment, for conjunctive goals, Artificial Intelligence 32 (1987) 333-377. in: Proceedings IJCAI-89, Detroit, MI ( 1989). Learning: On to Real Applications. Paper,~fntm the 1994 AAAI Fail Symposium, No. FS-94-01 Press, 199.5). I IS] S.A. Chien, Static and completion analysis in: Proceedings Artijicial Intelligence Planning Systems ( AAAI Press, 1996). [ 16 ] G. Collins and L. Pryor, On the misuse of filter conditions: a critical analysis, Sandewall, eds., Current Trends in AI Planning (10s Press, Amsterdam, in: C. Backstrom and E. 1993) 105-I 16. for planning knowledge base development and verification, [ I71 K. Currie and A. Tate, O-Plan: I 181 C. Dawson and L. Siklossy, The role of preprocessing the open planning architecture, Artijicial fntelligence S2 ( 1991) 49-86. in: Proceedings in problem systems, solving IJCAI-77, Cambridge, MA ( 1977). [ I9 1 M. Des Jardins, Knowledge development methods for planning systems, in: Planning and Learning: On to Real Applications. Papers from the 1994 AAAI Fall Symposium, No. FS-94-01 (AAAI Press, 1995). nonlinear planner based on object PLANRIK: a hierarchical and C. Zozaya-Gorostiza, 1201 E. Diaz-Infante states, in: Proceedings FLAIRS The Florida Al Research Symposium ( 1996) 1211 M. Drummond and K. Currie, Goal ordering in partially ordered plans, in: Proceedings NCAI-89, Detroit, MI (1989). [ 221 K. Erol, J. Hendler and D.S. Nau, UMCP: a sound and complete procedure task network in: Proceedings Artificial Intelligence Planning Systems (Morgan Kaufman, Los Altos, CA, for hierarchical planning, 1994). 1231 K. Erol, D.S. Nau and V.S. Subrahmanian, On the complexity of domain-independent planning, in: Proceedings AAAI-92, San Jose, CA ( 1992). 1241 0. Etzioni, Why PRODIGY/EBL works, [25] 0. Etzioni, K. Golden and D.S. Weld, Tractable closed world reasoning with updates, in: Proceedings Fourth International Conference OR Principles of Knowledge Representation and Reasoning, Bonn (1994). in: Proceedings AAAI-90, Boston, MA (1990). [26] Y. Gil, M. Veloso, S.A. Chien, D. McDermott in: Planning and Learning: On to Real Applications. Papers from the 1994 AAAI Fall Symposium, No. FS-94-01 (AAAI Press, 1995). and D. Nau, Symposium Preface, 1271 M. Ginsberg, Universal planning: an (almost) universally bad idea, Al Mag. 10 (4) (1989) 40-44. [28] D.G. Green and M. Todd, Object-oriented to robotic motion, in: IEEE SOUTHEASTCON approach (1993). [29] J. Hertzberg, On building a planning Al Planning (10s Press, Amsterdam, [ 301 P Jonsson and C. Backstrom, tool box, in: M. Ghallab and A. Milani, eds., New Directions in 1996) 3-18. Incremental planning, in: M. Ghallab and A. Milani, eds., New Directions in Al Planning (10s Press, Amsterdam, 1996) 79-90. [ 3 I ] S. Kambhampati, C.A. Knoblock and Q. Yang, Planning as refinement search: a unified framework for evaluating design [ 32 ] S. Kambhampati plan-space, 1996) 61-75. tradeoffs and B. Srivastava, Universal classical planner: an algorithm in partial order planning, Artijicial Intelligence 76 ( 1995) 167-238. for unifying state-space and in: M. Ghallab and A. Milani, eds., New Directions in AI Planning (10s Press, Amsterdam, [ 331 Z. Kazi, Integrating human-computer of Computer Proposal, Department (1994). [ 341 D.E. Kitchin, Use of an object-centred interaction with reactive planning system, Ph.D. Information Sciences, University of Delaware, Newark, DE for a telerobotic and approach for the creation and validation of a warehouse planning domain model, Tech. Rept. (in preparation), Huddersfield ( 1997) School of Computing and Mathematics, The University of 7YL. McCluskey, J.M. Porteous/Artificial Intelligence 95 (1997) l-6.5 65 135 1 C.A. Knoblock, Learning abstraction hierarchies for problem solving, in: Proceedings AAAI-90, Boston, MA (1990). I36 1 C.A. Knoblock, Automatically generating abstractions for problem solving, Ph.D. Thesis, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA ( 1991). [ 37 1 R.E. Korf, Macro-operators: I38 1 V. Lifschitz, On the semantics of STRIPS, a weak method for learning, Artt$cial Intelligence 26 ( 1985) 35-77. in: Proceedings 1986 Workshop: Reasoning about Actions and Plans ( 1986) I39 1 D. McAllester and D. Rosenblitt, Systematic nonlinear planning, in: Proceedings AAAI-91, Anaheim, CA (1991). 1401 T.L. McCluskey planning, and J.M. Porteous, Two complementary for in: Proceedings 3rd International Workshop on Knowledge Compilation and Speedup Learning in knowledge compilation techniques (1993). [ 41 I T.L. McCluskey, J.M. Porteous, Y. Naik, C.N. Taylor and S. Jones, A requirements capture method and its use in an air traffic control application, Software-Practice and Experience 25 ( 1995). 142) D. McDermott and J. Hendler, Planning: What it is, What it could be, An introduction to the Special lssue on Planning and Scheduling, Artificial Intelligence 76 ( 1995) 1-16. the utility of explanation-based results concerning [43] S. Minton, Quantitative learning, in: Proceedings AAAI-88, St. Paul, MN (1988) 564-569. I44 I S. Minton, J. Bresina and M. Drummond, Commitment strategies in planning: a comparative analysis, in: Proceedings IJCAI-91, Sydney, Australia ( 1991). 145 1 T.M. Mitchell and R. Keller and ST. Kedar-Cabelli. Explanation-based learning: a unifying view, Machine Learning 1 ( 1986). 1461 E.P.D. Pednault, Generalising dependent effects, nonlinear planning in: Proceedings IJCAI-91, Sydney, Australia ( 199 1). to handle complex goals and actions with context- 147 I M.A. Perez and 0. Ezioni, DYNAMIC: a new role for training problems in EBL, Tech. Rept. CMU- CS-92- 124, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA ( 1992). [48 I J.M. Porteous, Compilation-based performance improvement for generative planners, Ph.D. Thesis. Department of Computer Science, The City University ( 1993). 149 I The PRODIGY Research Group, PRODIGY 4.0: The Manual and Tutorial, Tech. Rept. CMU-CS-92-150, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA ( 1992). [SO] S. Russell, Efficient memory-bounded search algorithms, in: Proceedings ECAI-92, Vienna, Austria (1992). [5 I I E.D. Sacerdoti, Planning [521 E.D. Sacerdoti, The nonlinear nature of plans, [53 I L.T. Semmens, R.B.France and T.W.G. Docker, in a hierarchy of abstraction spaces, Artificial lnrelligence 5 ( 1974) 115-I 35. in: Proceedings IJCAI-75, Tblisi, Georgia ( 1975). Integrating structured analysis and formal specification techniques. Cornput. J. 36 ( 1992). 1541 D.E. Smith and M.A. Poet, Postponing Washington, DC ( 1993). threats in partial order planning, in: Proceedings AAAI-93, I55 I P. Stone, M. Veloso and J. Blythe, The need for different domain in: Proceedings 2nd International Conference on Artificial Intelligence Planning Systems (Morgan Kaufman, Los Altos, CA, 1994). J.G. Turner and T.L. McCluskey, The Construction of Formal Specijications: An Introduction to the Model-Based and Algebraic Approaches, McGraw-Hill New York, 1994) independent heuristics, Software Engineering (McGraw-Hill, Series [56l ISI I M. Veloso and J. Blythe, Linkability: examining causal link commitments in partial order planning, in: I581 D.H.D. Warren, WARPLAN: Proceedings Art$cial Intelligence Planning Systems (Morgan Kaufman, Los Altos, CA, 1994). for generating ( 1977). to least commitment planning, AI Mug. ( 1994). Logic, University of Edinburgh plans, Tech. Rept., Memo 76, Department Computational a system 159 I D.S. Weld, An introduction of 