Artificial Intelligence 92 ( 1997) 13 l- 167 Artificial Intelligence How to progress a database * Fangzhen Lin ‘, Ray Reiter * Department of Computer Science, University of Toronto, Toronto, Ont., Canada M5S 3H5 Received March 1996; revised October 1996 Abstract One way to think about a STRIPS operator is as a mapping from databases to databases, in the following sense: suppose we want to know what the world would be like if an action, represented by the STRIPS operator (Y, were done in some world, represented by the STRIPS database Do. To find out, simply perform the operator (Y on DO (by applying (Y’S elementary add and delete to DO). We describe this process as progressing the database 230 in response revision operators to the action (Y. In this paper, we consider the general problem of progressing an initial database in response to a given sequence of actions. We appeal to the situation calculus and an axiomatization of actions which addresses the frame problem (Reiter ( 1991) ). This setting is considerably more general than STRIPS. Our results concerning progression are mixed. The (surprising) bad news is that, in general, to characterize a progressed database we must appeal to second-order logic. The good news is that there are many useful special cases for which we can compute the progressed database in first-order logic; not only that, we can do so efficiently. Finally, we relate these results about progression to STRIPS-like systems by providing a se- mantics for such systems in terms of a purely declarative situation calculus axiomatization for actions and their effects. On our view, STRIPS operators provide a mechanism for computing the progression of an initial situation calculus database under the effects of an action. We illustrate this idea by describing two different STRIPS mechanisms, and proving their correctness with respect to their situation calculus specifications. @ 1997 Elsevier Science B.V. Keywords: Situation calculus; Theories of actions; Regression; Progression; STRIPS; Strongest postconditions *This paper revises, and combines, (and why) 1. Logical database foundations” results that first appeared [ 121 and “How to progress a database in E Lin and R. Reiter’s “How to progress a II. The STRIPS connection” 1151. * Corresponding author. E-mail: reiter@ai.toronto.edu. Fellow of the Canadian Institute for Advanced Research. ’ E-mail: fl@ai.toronto.edu. 0004-3702/97/$17.00 PII SOOO4-3702( @ 1997 Elsevier Science B.V. All rights reserved 96)00044-6 132 F Lin, R. Reiter/Art@cial Intelligence 92 (1997) 131-167 1. Introduction represented from databases is as a mapping by the STRIPS operator One way to think about STRIPS operators to databases, in the following sense: suppose we want to know what the world would be like if an (Y, were done action, by the STRIPS database 2%~. To find out, simply perform add and delete revision operators applying LY’S elementary process as progressing the database Do in response [ 251 and Pednault the world represented by the initial database. 2 However, or even possible initial world description. As we shall see in this paper, once we go beyond STRIPS-like systems, progression in some world, represented the operator cx on Do (by this to Do). We describe the effects of actions as a simple process of progressing [ 161). The resulting database describes to the action CY (cf. Rosenschein it may not always be convenient the effects of the action on becomes surprisingly to describe an In this paper, we consider of actions which addresses to a given sequence of actions. We appeal in response an axiomatization and Reiter concerning characterize is that there are many useful special cases for which we can compute database [ 131). This setting progression bad news a progressed database we must appeal to second-order is considerably more general (surprising) the frame problem are mixed. The logic; not only in first-order to the situation (Reiter an initial database and calculus [ 211, Lin than STRIPS. Our results is that, to logic. The good news the progressed in general, Finally, we relate these results about progression for such systems in terms of a purely declarative that, we can do so efficiently. to STRIPS-like complicated. the general problem of progressing ing a semantics axiomatization anism for computing the effects of an action. We illustrate mechanisms, and proving ifications. for actions and their effects. On our view, a STRIPS operator of an initial this idea by describing the progression situation their correctness with respect to their situation calculus situation systems by provid- calculus is a mech- calculus database under two different STRIPS spec- The need to progress a database arises for us in a robotics setting. In our approach a robot [ 8, lo], we must address the so-called projection problem: answer controlling query Q( do( A, SO) ) , where do( A, So) denotes from performing the sequence of actions A beginning with the initial situation SO. This can be done using [ 211) to reduce the projection [ 281, Pednault regression about from problem the initial situation SO. Unfortunately, in this application: 1. After the initial database, consisting regression suffers from a number of drawbacks to one of entailment the robot has been for a long period, [ 171, and Reiter (cf. Waldinger of sentences the situation functioning resulting to the it has performed since the sequence A, con- the initial situation, has become long, and regressing over such a sequence becomes computationally sisting of all the actions extremely expensive. 2 This is also the way that database practitioners think about database updates the STRIPS action and the database update paradigms as much about database updates as it is about STRIPS actions and their generalizations. database perspective, are essentially see Reiter [ 231. (Abiteboul the same. Accordingly, [ 11). In fact, this paper is For more on the E Lin, R. Reiter/Art$icial Intelligence 92 (1997) 131-167 133 2. Similarly, after a long while, the initial world state often becomes that significantly many final steps of the regression become SXY. so rearranged unneces- entirely 3. Most significantly, for robotics, perceptual actions [ 261) lead to new facts being added to the database. But such facts are true in the current situation-the the other about databases containing mixed (old) database facts-facts and we very complicated, know of no satisfactory way to do this. the current and initial situations-is facts are true in SO. Reasoning the perceptual action-whereas (Scherl and Levesque one immediately following about Our way of addressing robot’s database. sion of the database, database. We envisage line, during about. these problems with regression action every perceptual In particular, is to periodically is accompanied coupled with the addition of the perceived that these database progression computations progress the by a progres- fact to the resulting can be done off- like moving the time when the robot is busy performing physical actions, 2. Logical preliminaries The language L: of the situation calculus action function do( a, s) denoting is first order, many sorted, with sorts situation for everything else. It has the following a constant SO of sort situation denoting from that for actions, and object predicates and functions: independent situation; a binary the action a in the situation for situations, domain the initial performing the action a is possible situation. s < s’ means We assume a finite number of situation a finite number of situation and a finite number ofpuents which are predicate n 2 0. We denote by .C2 the second-order the situation calculus will be in ,C2 (Lin and Reiter [ 221) . on situations s; a binary predicate Poss( a, s) meaning in situation s; and a binary predicate <: situationx (executable) that s’ can be reached from s by a sequence of executable actions. independent predicates with arity object”, n > 0, functions with arity object” --+ object, n 3 0, symbols of arity object” x situation, for extension of ,C. Our foundational [ 13]), because we need induction the situation independent resulting axioms (Reiter the situation calculus Often, we must restrict is a finite set of sentences situation. For example, any situation the initial database for any situation terms except SO, and do not mention Poss and <. For this purpose, term st, we define ,C,, to be the subset of L that does not mention any other situation terms except st, does not quantify over situation variables, and does not mention Poss or <. Formally, in C that do not mention to a particular it is the smallest set satisfying: I. cp E L,Y, provided cp E C does not mention any situation 2. F(t1,... term. , t,, st) E Lc,, provided F is a fluent of the right arity, and tl , . . , t, are terms of the right sort. 3. If (o and C$ are in 13,,, so are 7Q9 40 v 40’9 9 A $0’7 cp 2 40’9 ‘p = q’, (V-x)$? (3x) P, (Va) q, and (3a) 9, where x and a are variables of sort object and action, respectively. 134 F: Lin, R. ReiterIArtificial Intelligence 92 (1997) 131-167 We remark here that according This may seem odd when we want sentences Fortunately, we shall use C,, only when sf is either a ground of sort situation. to this definition, (Vu) F( do( a, Se) ) will be in C~oCn,soj. about situation st. in ,C,, to be propositions term or a simple variable (3~) (V’x) (3s).p(x, We shall use ,C$ to denote the second-order of arity object”, n > 0. So the second-order is in CzO, but over a predicate variable of arity object x situation. Formally, satisfying: 1. 2. in C,, is also in Cz,. s) z F(x, SO) is not, since extension of ,C,, by predicate variables z F(x, So) sentence the latter quantifies (3~) (tlx).p(x) ,Cz, is the smallest set , t,,) E C$ provided p is a predicate variable of arity objecf, n 3 0, and Every formula p(t1,... t1,. . . , t, are terms of sort object. If (p and 9’ are in l:,, (V’a)p, (Vp)p, (31) 9, action, respectively, 3. so are X+T, (o V p’, p A tp’, q 3 p’, p E q’, and (Zlp)cp, where x and a are variables of sort object and (VX)~, (3x)p, and p is a predicate variable of arity object”, n 3 0. 3. Basic action theories We assume given a basic action theory D, having the following form (cf. Reiter 1231 and Lin and Reiter [ 131) : 3 where: l ,X, given below, l Dss is a set of successor state axioms of the form: 4 is the set of the foundational axioms for situations. Poss(a,s) > [F(x,do(u,s)) ~@F(X,U,S)l, (1) where F is a fluent, and @F(x, a, s) is in L,T. Informally, about F specifies of properties of the current situation a successor state axiom the truth values of F in the successor situation do( a, s) in terms s. ’ D‘,, is a set of action precondition axioms of the form: Poss(A(x),s) z PA(x,s), 7 We emphasize that a basic action theory is monotonic; we are not presenting here any nonmonotonic approaches to solving the frame, ramification or qualification problems. An approach to such problems, logic, is described in [ 131. This sometimes allows one to derive a (monotonic) using a nonmonotonic basic action theory from state constraints, but it is important to note that the resulting theory does not contain the original state constraints; it does, however, include the same “information content” as was present in the original state constraints. Accordingly, the basic action theories of this paper do nor include state constraints. 4 In the following, unless othenvise stated, all free variables in a formula are assumed to be prenex universally quantified. Variables will always begin with a lower case Roman character; constants will always begin with upper case. E Lin, R. Reiter/Artijicial Intelligence 92 (1997) 131-167 135 where A is an action, and PA (x, s) is in L,. An action precondition necessary performed. and sufficient conditions under which an action can be (physically) axiom specifies l %,‘, A(x) is the set of unique names axioms and A’(y), we have for actions: for any two different actions A(x) =+ A’(Y), and for any action A(xl, . . . , x,~), we have A(x ,,..., x,) =A(y ,,..., yn) >xl =yl A...Ax,=yn. l Ds,,, the initial database, The following is a finite set of first-order sentences in Ls,. is an example of a basic action theory. Notice that 2, the foundational for the situation calculus given below, will be independent of any domain, and generated once the language has been specified, so to define and the successor state, action precondition, theory, one need only specify axioms ID~,,,~ can be automatically a basic action initial situation axioms. Example 3.1. An educational database (Reiter [ 231) . There are two i&tents: l enrolled( stu, course, s) : student stu is enrolled l grade(stu, course, grade, s): the grade of stu in course in course course is grade in situation in situation s. s. There are two situation l prereq(pre, l better(grade1, course) grade2): predicates: independent : pre is a prerequisite grade grade1 course for course course. is better than grade grade2. There are three database l register(stu, transactions: register that the student has satisfied all of the prerequisites better course): than 50 in each prerequisite. : change course, grade) l change(stu, the student stu in course course, with precondition for course by obtaining a grade the grade of the student stu in course course to grade. This action can always be performed. l drop(stu, course): drop the student stu from course course, with precondition that the student is currently enrolled in course. This setting can be axiomatized DD,,Y consists of the following as follows. successor state axioms: Poss( a, s) 3 [ enrolled( stu, c, do( a, s) ) E a = register( stu, c) V enrolled( stu, c, s) A a # drop( stu, c) ] , Poss(a,s) > [grade(stu,c,g,do(a,s)) f a = change(stu, c, g) V grade(stu,c,g,s) r\~(3g’)(g # g’Aa=change(stu,c,g’)]. VDop consists of the following action precondition axioms: Poss( register( stu, c) , s) - (Vpr) .prereq(pr, c) > (3g) (grade(stu,pr, g, s) A better(g, 50))) 136 E Lin, R. Reiter/Arti’cial Intelligence 92 (1997) 131-167 Poss( change(stu, c, g) , s) E True, Poss( drop( stu, c) , s) = enrolled( stu, c, s) . DsO, the initial database, can be any finite set of axioms about the following:5 axioms which mention no situation, for example, the initial situation, or John f Sue # Cl00 # C200, prereq( C 100, C200), enrolled( Sue, C 100, SO), enroZfed( John, C 100, SO) V enrolled( John, C200, SO). We shall now present our domain Informally, the structure of situations. with SO at the root and with actions Formally, z‘ consists of the following axioms: independent foundational 2 stipulates that the space of situations axioms z’ which specify is a tree the only way of generating new nodes (situations). SO Sdo(a,s), do(al,sl) =do(a;?,sz) > (al =az~sl =sz.), (\dP).P(So) A (Va,s>[P(s) > P(do(a,s))l 3 (Vs)P(s), 1s < So, s < do( a, s’) = (Poss( a, s’) A s 6 s’). (2) (3) (4) (5) (6) Notice between the similarity 2 and Peano arithmetic. The first two axioms are finite cycles, and merging. The third axiom unique names assumptions; is second-order to a domain closure axiom which says that every situation must be obtained by repeatedly applying do to SO. 6 The last two axioms define < inductively. they eliminate it amounts induction; 2 are the only axioms theory about if we want to show, usually by induction, in a basic action the structure of situations. It that a state constraint of the is often needed form (Vs) C ( s) is entailed by an action in particular progression any formula p(s) theory. For the purpose of temporal projection, as we shall see, D has exactly in ~5,~, and any sequence A of ground action terms, the same effect as D - 2: for D /== p(do(A So)) iff VS., u DL7p u %I” UR,, l= +$do(A,So)). 51ngeneral,rl + 12 + h For a discussion of the use of induction # f,,standsforthen(n-I) in the situation calculus, see Reiter [ 221. inequalities:tl # t2A...Afl + tnA...Atn_l + tn. E Lin, R. Reiter/Arti&ial Intelligence 92 (1997) 131-167 137 This follows directly paper. from the following proposition which will be used throughout this Proposition 3.2. Given any model M- of D - .Y, there is a model M of D such that: 1. M- and M have the same domains for sorts action and object, and interpret all situation independent predicates and functions the same; 2. for any sequence A of ground action terms, anyJluent F, and any variable assign- ment v:’ M,v k F(x,do(A,So)) if M-,v j= F(x,do(A,So)). an equality atom whose arguments Proof. We begin with the observation mentions unique names axioms about situations. this that if M- 2, - _Z, then there is a model M of V,Y, U DOp U D,,, U Ds,, U { (2)) (3)) conditions that M- that no sentence of 2) - 2 = VD,, UVap U ID,,, U IDS, are of sort situation, and (2) and (3) are is a model of such that the loss of generality, we can assume ofD,~,U~~,,U~~,,U~s,U{(2),(3)}. are satisfied. So without of the proposition It follows isamodel from In the following, we use [‘!” for the denotation of the symbol 5 in an interpretation M. Given M-, construct a structure M as follows. First, let M’s domains be the same as that of M- for sorts action and object. Next, let the domain dom$ for the sort situation be the smallest subset of the situation domain of M- such that: 1. SF- E dam:,. 2. If u E dornz! and if LY is an element of the action domain of M-, then doM- (a, V) E dom$ So, M has exactly situation domain To complete icate symbols. the same domain of sorts action and object as does M-, and its is a subset of that of M-. the specification of M, we describe how it interprets function and pred- 1. M interprets all situation independent function and predicate symbols (including the equality predicate) exactly as does M-. 2. M interprets the equality predicate over situation terms of dom$ exactly as does M-. 3. M interprets do, Poss, and fluents over M’s domain exactly as does M- over this domain. 4. Finally, we specify how M interprets the < relation on situations. <M is the set with the properties: smallest (a) (b) We prove If (T E domz and (cu, @) E Poss”, then (cr,do(cY,a)) If u,(+‘d’ E domy! and (a,g’) E<~ and (u’,(+“) E<~, E<~. then (u,~“) that M is a model of D = Z U DD,, U D,, U Dun, U Ds,,, from which EC”“. the proposition follows. 1. To begin, consider (p does not mention <, where C$ does not mention an equality atom with situation arguments, and where 4 does not quantify over situations. Then whenever M- is a model any sentence of C of the form (V’s)+, where ’ M, v b rp means that M satisfies p under the variable assignment v 138 E Lin, R. Reiter/Art$icial Intelligence 92 (1997) 131-167 independent of (Y/s)+, so is M. This is so because M and M- situation of M’s domain, and M’s domain every sentence of V,,Y U DLlp U Duna U Ds, is of the form independent, function and predicate symbols for sort sittlation interpret do, POD, fluents and identically over the elements is a subset of that for M-. Since (‘v’~s)c,& or is situation that M is a model for V,, U Dop U I&,,,, U l&,, since M- it follows is. 2. It remains to prove that M is a model of X. (2) and (3) for situations because M- the unique names axioms (a) M satisfies does. (b) M satisfies domain do”, and this is true of M’s situation domain. (4), because set containing Sf which is the smallest induction axiom the this says is closed under that M’s situation the function (c) Finally, axioms The conditions it is not hard (5) and (6) of 2. of the proposition follow from the properties of M. Cl to see that <M, as defined in 4 above, satisfies the 4. Formal foundations Let (Y be a ground situation following properties: term do( CY, SO). A progression VS,, of V so in response simple action, e.g. enrolled(Sue, CIOO), and let S, denote the to (Y should have the is a set of sentences 1. Vs, 2. For all queries about the future of S,, V is equivalent about situation S, only, i.e., in Cs, or in Ci,. (in a suitable formal sense) to In other words, Vs, acts like the new initial database with respect evolutions of the theory following the “performance” of the action cy. to all possible future at S,” Semantically, the models of Vs, should about S, only, any structure about progressing Vs, to Vs, include that is “isomorphic those of 2). But since Vs,, is a set of sentences to a model of V should also be a model of Vs,, and these should be all the models of VsCr. Another way is that we want 2) to “forget about” what is of thinking true of the initial from SO but not in those models of VsO and of 2) which “don’t from S,. This means we are interested care” about what is true in Vs,,. To make these intuitions precise, we first need to define what we mean by “isomorphic relation over structures. Let M and M’ be structures (for our language) with the same domains for sorts action and object. Define M’ -s,, M, (“M and M’ are isomorphic the following at S,“. To that end, we introduce an equivalence and all those situations that are reachable two conditions situation at S,“) iff 1. M’ and M interpret and function symbols which do not take any arguments of sort situation identically. . 2. M and M’ agree on all fluents at S,. variable assignment (T, for every predicate fluent F, and every M’,(T k F(x,do(a,So)) iff M,a k F(x,do(a,So)). hold: all predicate E Lin, R. Reiter/ArtQicial Intelligence 92 (1997) 131-167 139 -s, is an equivalence Clearly, on fluents and situation interpretation Poss and do differently. We have the following else on all other situations. simple of everything independent predicates relation. If M’ ws, M, then M’ agrees with M on S, its they can interpret but is free to vary and functions, In particular, lemma. Lemma 4.1. If M ws, M’, then for any formula cp in Ls”, and any variable assignment (+, M,o+piifSM’,o+p. We can now make the following definition: Definition 4.2. A set of sentences V’S, in Lza is a progression of the initial database 2)~~ to S, (with respect iff there is a model M’ of 2, such that M -s, M’. iff for any structure M, M is a model of V, to V) that we define Notice new database logic is not expressive to contain second-order the new database only up to logical equivalence. We allow the sentences because, as we shall see later, first-order enough for our purposes. Proposition 4.3. Let Vs, be a progression model of V is a model of 2 U V,,, U VL,p U VD,,,, U V,. of the initial database to S,. Then every Proposition 4.4. Let Vs, be a progression of the initial database model M of to S,. Then for every 2 u V$S u V,, u VD,ll, lJ V’s, 3 there exists a model M’ of V such that: interpret all situation 1. M’ and M identically. independent predicate and function symbols 2. For every variable assignment (+, and every predicate fluent E M’,abS,<sAF(x,s) iff M,o/=&<sAF(x,s). Proof. Let M be a model of 2 u v.w u VD,,, u %,a u n”, . Since M is a model of Vs,, there is a model M’ of 2 u ~s.7 u VU,> u %,, u Q” such that M’ -s,, M. It can be easily seen that M’ has the desired properties. 0 these From two propositions, we conclude agree on all situations > S,. So Vs,” really does characterize the initial database that the new database, when it exists, entails to the action (Y. Furthermore, in response that V and 2 U V,,? U VL,rp U V,,,, U Vs, the result of progressing the following theorem says the same set of sentences in L”s as V: 140 I? Lin, R. Reiter/Artijiciul Intelligence 92 (1997) 131-167 Theorem 4.5. Let Vsm be a progression of the initial database to S,. For any sentence YEJ$~,V~, kviffVt=p. If 2, b 9, then by Lemma 4.1, we have VS,, + rp. If VD, + 4p, then 2) + 9 by Proof. Proposition 4.3. Cl theorem informs us that Vs, is a strongest postcondition (cf. Pednault [3], and others) of the precondition VsO with respect [ 161, to the and Scholten [ 161, by defining progression are entailed by 27, shows that his definition of progression set of first-order as well. In the next section, we shall extend even be a set of first-order sentences sentences in Cs,. in )CS_. By Theorem 4.5, this result applies as the set of first-order cannot sentences in Cs, that in general be a finite to our definition this result, and show that VS, need not This Dijkstra action (Y. Pednault 4.1. Progression is not always Jirst-order definable the fact that progression At first glance, may seem obvious induction axiom. However, as we mentioned V is equivalent to V - 2, which cannot always be expressed in first-order logic in light of Theorem 4.5, and the fact that V includes a second-order in Section 3, for the purpose of progression, is a finite set of first-order sentences. We shall construct following properties: a basic action theory V and two structures Mt and M2 with the 1. MI +V. 2. Mr and I& satisfy exactly 3. There the same set of sentences in &. is no model M’ of V such that M’ ws, M2. for V, from our definition to S, cannot be in Cs,. Suppose otherwise, follow that the progression initial then by property 1, Ml k V,; the of the assumption that Vs* is a set of sentences ‘Vs,, as well, but this contradicts property 3 and our definition in Cs,, we have of progres- then It will database by property 2 and M2 k sion. the two associated We now proceed fluent structures. Consider F2, one action constant symbol A, one constant symbol 0, and one unary function symbol succ: such a basic action theory V with a unary fluent Fl, and a binary to construct the following theory, and 2) uno =0. vs, = {(Vx>.x # 0 3 (3y)x = succ(y)}. V,, = {(Ys).Poss(A,s) E True}. V,, consists of the following pair of axioms: Poss(a,s) > [F,(do(a,s)) s (3x)--F2(x,s)l, E Lin, R. Reiter/Ari@cial Intelligence 92 (1997) 131-167 141 Poss(a,s) 3 {F*(x,do(a,s)) x=OAF2(O,s) - v x # OAF2(x,s) - (3y)[x=succ(y) AF2(y,s)]}. For an intuitive 0 as the number 0, and any x, Fz(~,do(a,s)) F2 (predecessor( the truth values of F2 in the previous reading of the successor the unary holds symbol for and x) , s) have the same truth value. The purpose of F, is to keep track of iff either x = 0 and Fz(O,s) succ as the successor think of the constant holds, or F~(x,s) function. Then state axioms, situation. function We now proceed to construct the two models Ml and M:! that satisfy the above- mentioned three properties. We first construct M2 which is a structure such that: 8 1. M2 is a standard model of arithmetic with respect for object in M2 is the set of nonnegative and succ is mapped to the successor function. to sort object. Thus the domain to the number 0, numbers, 0 is mapped 2. M2 + F~(do(A,So)l A Wx)F2(x,MA,So)). there cannot be a model M’ of 2, such that We claim otherwise. Then M’ also satisfies properties M’ /= F, (&(A, SO)), we have that M2 -s,, M’. Suppose 1 and 2 above. Since M’ k ID,,, and M’ t= (3x)+2(x,So). since M’ /= (Vx) F~(x, do( A, SO)), by the successor Similarly, have M’ k F~(O,SO)AF~(SUCC(O),S~)A~~~. Thus M’ b (Vlx) F~(x, SO), a contradiction. Therefore there is no model M’ of D such that M2 -s,, M’. state axiom for F2, we a model MI of 2, such that for any sentence q in CS,, Ml + p of MI is in two steps. First, by using Skolem’s theorem the same set of in Cs, as M2. We then revise M” into a model of D in such a way that the theory, we construct a structure M* which satisfies exactly to hold, thus obtaining (cf. Kleene [ 7, p. 3261)) the desired model Ml. there is a first-order that for any sentence qo in Csa, M2 /= rp iff M* + p, and (M2,0,succ) i.e., M2 and M* are not isomorphic on sort object. structure M* and In We now construct iff M:! + q. The construction for number sentences above property continues theorem By Skolem’s such (M*, 0, succ) are not isomorphic, particular, since M t= Fi(do(A>So)) A (vx)Fz(x,do(ASo)), and Fl(do(A,So)) A (Vx)F2(x,do(A,So)) is a sentence in Csn, we have for suggesting the following picture s We thank one of the referees the successor (like floor if the first state axioms and the construction indicators light the reader better un- derstand labelled row of lights 0, 1.2,. to the follow- ing rules: on if it (stays) off otherwise. Then the only way and its predecessor were both on or both off together, and goes that all the lights are on in the next step ((Vn) F2( X, do( A, SO)) holds) yet there was a light off initially ((3x)~F2(~, nonstandard So), i.e., Fi (&(A, So)) holds) would be that the initially off light be “somewhere lights come on or go off according light comes that may help of Ma. Imagine an infinite in an elevator). The forever; any other it stays on (off) is on (off), number! else”-a (stays) 142 F Lin, R. Reiter/Artijicial Intelligence 92 (1997) 131-167 Now revise M* into a structure Mr such that: 1. MI and M* have the same domains for sorts action and object, and interpret situation independent predicates and functions the same. 2. M] + (VJa,s)Poss(a,s). 3. Ml 4. For the truth values of the fluents on So: Ml k Fl (So), and for the truth values t= 2 u u no. ‘o,,,, of Fz(x, SO), we have that for any variable assignment (a) is a standard number, u: i.e., there is an n 2 0 such that Mr, cr + x = (b) is a nonstandard then Ml,cr k Fz(x,So). number, If a(x) succ”(O), If a(x) x = succ”(O), then Ml,a not isomorphic on sort object with respect a nonstandard b 7F2(x,Su). i.e., there is no n 2 0 such that Ml, a(x) + that since M* and M2 are there must be Notice to Peano arithmetic, in the domain of M*, and thus in the domain of MI. 5. For the truth values of the fluents on do( A, SO): for any fluent F, and any variable number assignment 6. Inductively, (+, M],a k F(x,do(A,So)) for any variable assignment V, if iff M*,(T b F(x,do(A,So)). MI ,U /= do(A, So) < s, then the successor truth values of the fluents on s will be determined according state axioms and the truth values of the fluents on do( A, SO); if to the M1,a + So < s A -do(A,So) < s, the truth values of the fluents on s will be determined to the then successor state axioms and the truth values of the fluents on SO. This will define the truth values of the fluents on every situation because MI k (‘ds) .SO < s, which follows according from the fact that Ml k (Vu, s)Poss( a, s). that Ml and M2 satisfy the successor the same set of sentences state axioms. By the construction Clearly, MI -s,, M*. It follows Cs,. We now show that Ml satisfies MI, we only need to prove that it satisfies and action A, i.e., the successor state axioms instantiated in of to SO MI +=oss(A,So) 3 [FI(MA,SO)) = (3~)+2(~,~0)1, and Ml + Poss(A, So) > (V’X){F~(X,~O(A,SO)) = x = 0 A F2(0, So) V x # OA F2(x,So) = (3y)[x=succ(y) A F2(y,So)l}. To show the first, we need to prove that MI + (3x)~F2( construction show the second, we need to prove that of MI and the existence of nonstandard s, SO). This follows from our in the domain of MI. To numbers Ml + (‘dx){x = 0 A F2(0,So) V x # Or\F2(x,So) -(3y)[x=succ(y)AF2(y,Sg)]}. F: Lin, R. Reifer/Artijicial Inrelligence 92 (1997) 131-167 143 There are three cases: 1. If x = 0, then F2 (0, Se) follows from our construction. 2. If n = SUCC’~ (0) for some n > 0, then both F2 ( SUCC” (0)) SO) and F2 ( SUCC”-’ (0)) SO) hold. 3. If x is a nonstandard number, y such that x = succ( y), y is also a nonstandard hold either. Moreover, by the axiom in DsO, such a y exists. then Fz(x, SO) does not hold. Furthermore, for any number, so Fz(y, SO) does not that Mi k D, and MI and M2 satisfy Therefore, A41 satisfies the successor state axioms instantiated This means Therefore we have constructed in the beginning by a set of first-order of this subsection, sentences, two models Mi and M:! that satisfy the three conditions to S, for D cannot be captured so the progression to SO and A. So Ml k Z&. in Cs,,. the same set of sentences 4.2. Progression is always second-order dejinable We now show that, by appealing to second-order logic, progression always exists. We first introduce some notation. Given a finite set VD,, of successor state axioms, define the instantiation of D,, on an action term at and a situation term st, written D,ss [ at, st] , to be the sentence: Poss(at,st) > (Vx).F(x,do(at,st)) E @F(x,at,st), A F is a fluent where (Va,s).Poss(a,s) > (Vx)[F(x,do(a,s)) =@~(x,a,s)] is the successor state axiom for F in D$,. Given a formula q in C2, the lifting of qo on the situation st, written qo t st, is the every fluent atom of the form F( t] , . . . , t,,, st) by a new predicate result of replacing variable p( tl , . . , tn) of arity object”. For example, enrolled(John, C200, SO) A enrolled(John, ClOO, SO) t SO is P(John,C200) Ap(John,C100).9 Lemma 4.6. The following are some simple properties of lifting: that does not mention st, then 9 T st is p. in LCg,, then 40 t st is a situation over situations, where pl , . . ,pk are the new predicate variables 1. If p is a sentence 2. If p is a sentence 3. If p does not mention quant$ers independent sentence. then cp k (3~1,. introduced during the lifting. . . ,pk)p T st, With progression the above notation in hand, we can describe a procedure for computing the of the initial database VsO in response to the action LY: ‘) Lifting as we have defined it does not generally preserve logical equivalence. For example, [ (Vs).F( s) 1 7 .So is (Vs).F(s), only be lifting but the logically equivalent those sentences that do preserve logical equivalence. IF(&) A (V’s).F(s)j T.5’0 is p A (V.s).F(s). Fortunately, we shall 144 E Lin, R. Reiter/Artifcial Intelligence 92 (1997) 131-167 1. Instantiate the successor state axioms with LY and SO to get VD,, [ a, SO]. This will be the only use made of the successor state axioms. 2. Replace Poss( cr, SO) in the above instantiation the right hand side of the action precondition axioms. use made of the action precondition by the corresponding conditions on axiom for (Y. This will be the only 3. The resulting formula and those in the initial database will generally mention SO, but the progression SO without This procedure needs to be about S, only, so we need to somehow “forget” losing any information. This is done by lifting SO from the formulas. and described more precisely, by the following, which is justified, is the main theorem of this section: Theorem 4.7. Let Vs,, be the union of VU,,, together with the sentence: (3PI*...,Pk) // cp ~Pw[~~~ol(P4~a) tso, N co~VD$ ) 1 where 1. Pl,..., 2. W, is a sentence pk are the new predicate variables in ,Cs,, such that introduced during the lifting. Poss(a, So) E !P, is an instance of the axiom in Vap corresponding to the action a. 2. VD,, [ CY, SO] ( Poss/?P~) is the result of replacing Poss( a, SO) by ?PU in V.YS [ a, SO]. Then Vs, is a progression of ‘Ds, to S, with respect to V. Proof. First, it is clear that the sentences in Vsn are in lge. Let M be a structure. We need to show that A4 k Vs, iff there is a model M’ of V such that M -s, M’. Suppose that there is a model M’ of V such that A4 us, M’. By Lemma 4.6, V k Vs,, thus M’ k Vs,. Therefore by Lemma 4.1, M k Vs, that M k V,. Then Now suppose there is a variable assignment CY such that M,ab A P Avo,,[a,Sol(Poss/~~)t~o. PEDS” ) ( Now construct a structure M’ such that: 1. M and M’ have the same universe, and interpret all situation identically. 2. For every fluent F, if F(x, SO) is lifted in ‘VS, as p, then and predicate symbols independent function M’,(T b F(x,So) iff M,a bp(x). 3. M’ + VD,, uVO,. 4. If M’ + -pa, then for any fluent F, and any variable assignment u’, M’,cr’ k F(x,&) iff M,a’ k F(x,S,). F Lin, R. Reiter/Artijicial Intelligence 92 (1997) 131-167 145 It is clear that such an M’ exists. We claim that it4 -s, M'. There are two cases: 1. If M' /= l!Pa, then it follows from our construction that for any fluent F, and any variable assignment u’, M',a' +F(r,S,) iff M,u' k F(x,S,). 2. If M' k Pa, then since M' k Vop, and VO,) b Poss( (Y, SO) E pa, therefore M' k Poss(a, SO). But M' f= V,y,. Thus for any fluent F, and any variable assignment I fl, M',d k F(x,S,) iff M',u' /=@~(x,a,So), (7) where @F is as in the successor state axiom (1) for F in VSS. Now since M' k P,, by our construction of M', we have that M, (T k Pa 1 SO. But M,(T + ~o,s[~,~ol(~~~~/~a) Tso. Therefore for any predicate variable p, for any fluent F, and any variable assignment g’ such that c’(p) = a(p) M,u'kF(x,S,) iff M',cr'~@~(x,a,So)fSo. (8) But for any variable variable p, since @F(x, (Y, SO) is in CsO, by our construction that (T’(P) = a(p) assignment (+’ such of M', for any predicate M,d ~@F(x,(Y,SO)~SO iff M',~'~@F(x,(Y,SO). Therefore assignment from cr’, (7) and (8), we see that for any fluent F, and any variable M',a'~F(x,S,) iff M,a'/=F(x,S,). It follows then that M us, M'. By the construction of M' and the fact that M k VU,,, we have that M' k V,, U VQ,) U V,,,,. Thus from Proposition 3.2, there is a model M" of ws,, we have that M -s,, M". of V such that M' "so M". Then by the transitivity This concludes the proof that V s, as defined is a progressed database. 0 It is clear of second-order repeatedly that the theorem sentences still holds when in L&. Therefore, applied to progress the initial database at least in principle, in response the initial database VsO is a finite set the theorem can be to a sequence of actions. it can in VU,,, as we shall see in the The new database 2)s” as defined in the theorem can be unwieldy. However, often be simplified by using example. following the unique names axioms Example 4.8. Consider our educational database. The instantiation axioms on drop( Sue, C 100) and SO, VD,,Y [ drop( Sue, C 100)) SO] is the conjunction following two sentences, where a = drop( Sue, ClOO) and S, = do( cy, SO): of the successor state of the Poss( cy, SO) > [ enrolled(stu, c, S,) E cr = register( stu, c) V enrolZed( stu, c, SO) A cy # drop( stu, c) 1, 146 E Lin, R. Reiter/Artijicial Intelligence 92 (1997) 131-167 Poss(a,So) 3 [grude(stu,c,g,S,) a = chnnge(stu, c, g) v z grude(stu,c,g,S0) A-(3g’)(g f g’Aa=change(stu,c,g’))]. By unique names axioms, these two sentences can be simplified to Poss(cf, SO) 3 [enroZZed(stu, c, S,) z enroffed(stu,c,S0) A (Sue # stuVClO0 # c)], Poss(a,S~) 3 [grude(stu,c,g,S,) 5 grude(stu,c,g,So)]. Poss( a, SO) sz enrofled(Sue, ClOO, SO). Thus D,s,v [ a, SO J (Poss/?P,) is the conjunction of the following two sentences: enrolled(Sue, C 100, SO) > [ enrolled( stu, c, S,) z enrolZed(stu,c,So) A (Sue # stuVClO0 + c)], enroiled(Sue,ClOO, So) 3 [grude(stu,c,g, S,) = grade(stu,c,g, So)]. Thus ( ~PI 3 ~2 > 1 (A,,,, 40) ~~,,~~,~~l~~~~~/~~~l TS0 is (3p1,p2). John # Sue # Cl00 # C200 A [p1 (John, c 100) v pi (John,C200) ] A pl(Sue,ClOO) Aprereq(ClOO,C200) A pl(Sue,ClOO) > enrolled(stu,c,S,) s [PI (stu, c) A (Sue Z stu V Cl00 # c) ] A pl(Sue,ClOO) > grude(stu,c,g,S,) s pz(stu,c,g). This is equivalent to John # Sue # Cl00 # C200Aprereq(C100,C200) A (3pl,p2). [pl(John,ClOO) Vpl(John,C200)1 enroZZed(stu,c,S,) E [p~(stu,c) A (Sue # stu VClOO # c)] A Apl(Sue,ClOO) A grude(stu,c,g,S,) -p~(stu,c,g), which is equivalent to John Z Sue # Cl00 f C2OOAprereq(ClOO,C200) A (3~~). [p~(John,ClOO) Vpl(John,C200)] A p1 (Sue, Cl001 A enrolled(stu,c,S,) E [pl(stu,c) A (Sue # stuVClO0 + c)]. F Lin, R. Reiter/Artijicial Intelligence 92 (1997) 131-167 147 Now, enrolled(stu, two cases: c, S,) E [pl (stu, c) A (Sue Z stu V Cl00 f c)] can be broken into Sue = stu A Cl00 = c 3 enrolled( stu, c, S,) E [PI (stu, c) A (Sue # stu V C 100 # c)] A Sue f stu V Cl00 # c 3 enrolled(stu, c, S,) E [pl (stu, c) A (Sue # stu V Cl00 # c) 1, that is, Sue = stu A Cl00 = c > Tenrolled(stu, c, S,) A Sue f stu V Cl00 # c > [ enrolled(stu, c, S,) E p1 (au, c) 1, so we can continue simplifying (3pi ,p2) [ ( l\coED,To qop) A DD,,y [ a, SO] (Pass/Pa) ] T SO into: John # Sue # Cl00 # C200Aprereq(ClOO,C200) A [ enrolled(John, C 100, S,) V enroEled(John, C200, S,) ] A Tenrolled( Sue, C 100, S, ) A ($1). PI (Sue, ClOO) A Sue # stu V Cl00 # c > [ enrolled(stu, c, S,) E p1 (stu, c)]. Therefore we have a first-order sentences: following representation for Ds,, which is DD,,,, together with the John # Sue # Cl00 Z C200. prereq(ClOO,C200), enrolled(John, ClOO, S,) V enrolZed(John, C200, S,), Tenrolled(Sue, ClOO, S,). 4.3. More on first-order progression Theorem 4.5 informs us that, in particular, sentences set of @St-order we did not define progression by 2). Indeed, step our negative result logic. There are several purely syntactic, sumption many other notions, as we did, with a purely progression, that progression and see where the progression the same about S, as does V. In view of this, one may wonder why in Ls, entailed side in first-order this is basically what Pednault did that, in general, progression reasons why we did not do this. First, such a definition [ 161, and will, by definition, to be the set of jirst-order cannot be captured of VD, entails sentences and hence has an arbitrary quality is first order definable, transitive for example especially to it. What justifies is the prior as- in view of the fact that closure, are not? Ideally, one should begin, about database intuitions that, for [ 191 show of one’s semantic that characterization leads. Secondly, Peppas et al. 148 F: Lin, R. Reiter/Art@cial Intelligence 92 (1997) 13I-167 in terms of first-order defined that a first-order sentence of V but not of (V - V,S,, ) U V,. While about a future entailments, in lose action information, theories, progression the sense quite general may tion of S, may be a consequence result by Peppas et al. is for more general that it is not a priori obvious Unfortunately, comparable ing: we have not been able than ours, that a first-order definition of progression theories action to find a result for basic to that of Peppas et al. Nevertheless, we are convinced situa- this it does show is warranted. theories of actions of the follow- Conjecture 4.9. For an arbitrary basic action theory V, and an arbitrary ground action in Ls, entailed by V. Then there is a basic sentences a, let Fs, be the set offirst-order action sentence c such that cr is term LY and a jirst-order entailed by (V - Vs”) U VS, but not by (2) - VsO) U Fs,. theory V, a ground action If true, this conjecture would establish first-order entailments would be too weak. for an important is entirely However, progression first-order progression is sufficient. adequate. Specifically, class of first-order that a definition of progression in terms of sentences, for addressing this “weaker” definition of the projection problem, Proposition 4.10. Suppose terms. Then that 4(s) E L,7, and that A is a sequence of ground action (V--s,) UVs,, t==s, <do(A,&) A&do(A,&)) iff (V--s”) UPS,, I=& 6 do(A,&) A&do(A,&)). (9) (10) Proof. We make use of the soundness [ 241. Specifically, Reiter Reiter shows how, using such that CT E &, and completeness of regression, as described in for sentences of the form S, < do( A, S,) A +(do( A, S,)), sentence the regression to determine a first-order operator, V - Vs,, + u= [So < do(A,&) A+(do(A,Sa))l. (11) Moreover, Reiter shows that ( 10) iff V,,,U.Fs, (by the definition of .Fs~) 2, b CT iff (by the remarks following k CT iff (since Vu,, C .Fs, ) Fs,, k c iff the proof of Proposition 4.4) (V - Vs,) u V’s, F aiff (by (11)) (9). (cid:144)1 5. Progression with relatively complete initial databases In the previous section we showed that, in general, progression logic. However, there are some interesting is first-order definable. and important In this section and the next, we consider is definable only in special cases for two second-order which progression such cases. E Lin, R. Reiter/ArtQicial Intelligence 92 (1997) 131-167 149 We say 23~~ is relatively complete if it is a set of situation independent sentences combined with a set of sentences, one for each fluent F, of the form: Wx).Ftx,So) = OF, where UF(x) is a situation When VD, is relatively independent complete, formula whose free variables are among x. the truth value of each is completely determined by the truth value of the situation It does not follow situation L~F(x). be only when independent the blocks world, one may want to specify on the table, without saying which blocks are green: predicates. Hence the terminology the initial situation uniquely determines that initially “relative completeness”. fluent F independent in the initial formula It will the truth values of the situation in all and only green blocks are For example, that the initial database must be logically complete. ontable( x, SO) = green(x) . Theorem 5.1. Let V be an action Vs”, and let a be a ground action set: theory with a relatively complete initial database term such that V k Poss( a, SO). Then the following V,,,, u {cp 1 p E Vs,, is situation independent} U ((Yx).F(x,do(o,SO)) = @r(x,a,So)[So] 1 F is ajuent} is a progression of VsO to S,, where 1. @F is as in the successor state axiom ( 1) for F in V,Y,; 2. @r(x, a, SO) [SO] is the result of replacing, F’( t, SO) by I7rf (t) , where nrf and this replacement is pelformed in @F( x, a, So), every occurrence of is as in the corresponding axiom for F’ in VD,, in @F( x, a, SO). for every fluent F’ mentioned Proof. Denote first-order V b S. Thus by Theorem 4.5, VsO k S. sentences the set of the sentences of the theorem by S. Clearly, S is a set of it is clear that in Cs,. It is easy to see that S b 23,. Conversely, 0 Clearly, the progressed database at S, as given by the theorem complete. Thus the theorem can be repeatedly applied initial database database will can use these axioms to a sequence of executable independent include VU,,, and the situation to simplify @F (x, LY, SO) [SO]. in response is also relatively to progress a relatively complete that the new in Vs,,; therefore we actions. Notice axioms Example 5.2. Consider again our educational initial database 27s” consists of the following database example. Suppose now that the axioms: John f Sue # C 100 # C200, better( 70,50), prereq (C 100, C200), 150 I? Lin, R. Reiter/Art$cial Intelligence 92 (1997) 131-167 enrolled(stu,c,&) = (stu=JohnAc=C100) V(stu=SueAc=C200), grade(stu, c, g, So) z stu = Sue A c = Cl00 A g = 70. is relatively Ds, the axiom for enrolled complete, and D k Poss( (Y, So), where LY = drop(John, ClOO). From in Vs,,, we see that IZenrollrd(~&, c) is the formula: (stu=JohnAc=C100)V(stu=SueAc=C200). from the successor Now Qrnrolled( stu, c, a, s) , the condition is the formula: state axiom for enrolled that in Example under which enrolled( stu, c, do( a, s) ) will be true, 3.1, we see a = register( stu, c) V (enrolled( stu, c, s) A a # drop( stu, c) ). Therefore Genrollpd( stu, c, cy, SO) [SO] is the formula: drop(John, C 100) = register( stu, c) V {[(stu=.fohnAc=ClOO)V(stu=SueAc=C200)] A drop(John, ClOO) # drop(stu, c)}. By the unique names axioms in V,,,, this can be simplified to [ (stu = John A c = C 100) V (stu = Sue A c = C200) ] A l(stu =.fohn AC = ClOO). By the unique names axioms in DsO, this can be further simplified to stu = Sue A c = C2OO. Therefore we obtain the following axiom about do( a, SO): enrolled( stu, c, do( a, SO) ) 3 stu = Sue A c = C200. Similarly, we have: grade(stu,c,g,do(cu,So)) = stu = Sue A c = ClOOAg = 70. Therefore a progression sentences: to do (drop( John, C 100)) SO) is V U,,u together with the following John # Sue # Cl00 # C200, better( 70,50), prereq(ClOO,C200), enrolled( stu, c, do( a, So) ) E stu = Sue A c = C200, grude( stu, c, g, do( a, SO) ) - stu = Sue A c = C 100 A g = 70. FI Lin, R. Reiier/Artijicial Intelligence 92 (1997) 131-167 1.51 6. Progression in the context free case In this section we consider progression with respect to context free action theories. A successor state axiom for F is context free iff it has the form: Poss(a,s) 1 [F(x,do(~s)) =$(x,4 V (F(x,s) A ~F(x>a))l, (12) where yf (x, a) and y; (x, a) are situation are among context free. So is the following successor those in x, a. The successor state axioms state axiom: independent formulas whose free variables in our educational database are all Poss( a, s) 3 [ broken( x, do( a, s) ) = a = drop(x) Afrugile( x) V broken( x, s) A a # repair(x) ] . The following successor state axiom is not context free: Puss(u,s) > [deud(x,do(u,s)) = (3~) (a = explode_bombat( y) A close( x, y, S) ) V deud( x, s) 1. a successor Intuitively, the next situation &(a, S) depends on F’s truth value independent of the truth values of any other fluents state axiom for fluent F is context in S. in free iff F’s truth value in the current situation S, but is Now assume I. Ds,, is a set of situation that: E 1 ItF(x~,...,x,,So), independent sentences, and sentences of the form (13) where F is a fluent and E is a situation independent formula. For example, ontuble( x, SO), x # A > wntuble(x, SO), frugile( x) 3 broken( x, SO) are all of this form. The following are not of this form: ontuble(x, SO) V orzJEoor( x, SO), (3x)ontuf7le(x, SO). 2. ‘DD, is coherent in the sense that for every fluent F, whenever (Vx) .E1 > F(x, SO) and (b’x).Eg > ~F(x,&) are in D,, then {q~ / qo E DD, is situation independent} b (Vx) .-( El A E2) that D>sO cannot use axioms of the form sentences: for any situation independent to encode (13) sentence qb, Ds,, b 4 situation iff This means independent {q 1 40 E Vs,, is situation 3. D,, is a set of context independent} free successor + 4. state axioms. 1.52 I? Lin, R. Reiter/Art@cial Intelligence 92 (1997) 131-167 4. a is a ground action 5. For each fluent F, the following consistency term, and is possible initially: V b POSS( (Y, SO). condition (Reiter [ 211) is satisfied: vl7p U %Kl != l(3 x,a,s).Poss(a,s) Q&a) AY;(X,a), (14) where F’s successor state axiom has the form (12). The consistency condition ( 14) deserves a brief explanation. Following Pednault [ 271, Reiter and Schubert of state constraints which syntactically fluent F into a successor syntactic forms: ‘O [ 211 provides a solution transforms to the frame problem a pair of effect axioms state axiom for F. The effect axioms are assumed [ 181 in the absence for a given to have the Poss(u,s) ~y$(x,u,s) > F(x,do(u,s)), and Poss(a,s) Ay;(x,u,s) > ~F(x,do(u,s)). Reiter applies frame axioms the explanation closure idea of Schubert for F: [27] to obtain the following Poss(u,s) A ~F(x,s) A F(x,do(u,s)) > y;(x,u,s), Poss(u,s) A F(x,s) A ~F(x,do(u,s)) > y,(x,u,s). The successor state axiom Poss(u,s) > F(x,do(u,s)) = $(~,a) V (F(x,s) A ~y,(x,a)) is logically consistency if it were violated, y; (X, A, S), effect axioms. equivalent condition to the conjunction holds. Notice of the above that the consistency four sentences, whenever the condition makes good sense: so that for some X, A, S we have Poss(A, S), yi(X, A, S), and two inconsistency the above from then we could derive an immediate It is easy to verify that each fluent in our educational database satisfies the consistency condition. Under initially these assumptions, empty, of sentences 1. If 9 E Ds, is situation 2. For any fluent F, add to S the sentences to compute Ds,, use Theorem 4.5 to construct as follows: independent, then 40 E S. $(~,a) 1 F(x,do(a,So)), y;(x,a> 3 +‘(x,do(a,So)). a set S, (15) (16) 3. For any fluent F, if (Vx).E > F(x,So) is in Ds,,, then add to S the sentence EA-yF(x,c~) > F(x,do(a,Sg)). (17) “’ In general, y: and y, may be situation dependent. F: Lin, R. Reiter/Art@cial Intelligence 92 (1997) 131-167 153 4. For any fluent F, if (Vx).E > lF(x,So) is in Vs,,, then add to S the sentence E A &(~,a) > ~F(x,do(cu,So)). (18) Theorem 6.1. Under the afore-mentioned assumptions, S U D,,, V, to s,. is a progression of Proof. We use Theorem 4.5. First we show that V b S U Vu,,. V f= V,,, Suppose (o E S, we show by cases that 2) b (D: trivially. 1. c,o E Vs,, is situation 2. (o is (15). By the successor independent. Trivial. state axiom ( 12) of F in V, we have Poss(a,So) A$(X,CY) > F(x,do(a,So)). From this and our assumption that V k Poss( LY, SO), we have y;(x+) 1 F(x,do(o,So)), that is, 4p. 3. q~ is ( 16). Again by the successor state axiom ( 12) of F in V, we have Poss(a,So) 1 [Y;(x,(Y) A-$(X,“) 2 -F(x,do(a,So))l. Now by the consistency condition ( 14), we have Poss(a, So) > [r; (x, (Y) > TF(x,do(a, So)) I. So we have y;(x,a> 3 -Ftx,do(a,So)), that is, q. 4. +Y is (17). By the successor state axiom (12) of F in V, we have Poss(cu,So) 1 [F(x,So) A~Y;(x,Q) 3 F(x,do(a,So))l. so F(x,So) A ly,(x,cu) 3 F(x,do(a,So)). But (Yx)(E > F(x,So)) is in VsO, so we have E A yy,(x,a) 1 F(x,do(cu,So)), that is, 9. 5. 40 is (18). By the successor state axiom (12) of F in V, we have Poss(~~,So) > [lF(x,So) A~y~(x,cu) > -F(x,do(cr,So))l. so +(x, So) A 1$(x, a) 3 F(x,do(a, So) ). 154 I? Lin, R. Reiter/Art@ial Intelligence 92 (1997) 131-167 But (V’x)(E > -JF(x,&,)) is in z)sO, so we have that is, 9. By our construction Ls,. Therefore by Theorem 4.5, 27, k S U DunL,. of S, this proves that D b S. But DD,,, U S is a set of sentences in To prove the converse, we show that for any model M of S U ‘Du,,, there is a model M’ of 2) such that A4 ws, M’. Suppose now that M is a model of SUD,,,. We construct M’ as follows: 1. M’ and A4 have the same domains for sorts action and object, and interpret all situation independent predicates and functions the same. 2. For each fluent F, M’ interprets F on SO as follows: (a) For every variable assignment g, if (V’x) .E > F (x, SO) is in Ds,,, and M, g k E (thus M’,m b E as well), then M’,u k F(x,So). (b) Similarly, for every variable assignment, and M,g b E (thus M’,u k E as well), (c) For every variable assignment value by one of the above F(x,Ma,So)). if (V’x).E > ~F(x, SO) is in DsO, then M’,a k ~F(x,$). (T, if F(x, SO) has not been assigned a truth then M’, c k F(x, SO) iff M, u k two steps, Notice that by our coherence assumption for Ds,,, our construction 3. M’ interprets Poss according to VOp, and interprets is well defined. the truth values of the fluents on reachable situations 4. M’ + _Z. This can be done according according to D)ss. to Proposition 3.2. Clearly M’ /= D. We show now that M ws,, M’. For any fluent F, suppose state axiom for F is the successor Poss(a,s) > F(x,do(a,s)) = y;(x,a) V (F(x,s) A’yF(x,a)). a variable Given Poss( a, SO), by the above successor assignment (T, suppose M’, CT k F(x, do(a, SO)). Since 27 k there are two cases: state axiom, 1. M’,(T b yFf(x,a). This implies M,a k ys(x,a). Now since rFf(x,n) > F(x,do(a,So)) as well. E S, and M is a model of S, thus M,cr b F(x,do(a,Sg)) 2. M’,cr k F(x,So) A ly;(x,a). either M,a k F(x,do(a,S~)), that M, CT k E. Suppose EA-y;(x,cr) 3 F(x,do(a,So)). Similarly, fore M wS,, M’. 0 if M’,a + -F(x,do(a,Sg)), Since M’,(T k F(x,&), by our construction, or there is a sentence E > F(x,So) the latter. Then by our construction Thus M,cr k F(x,do(a,&)) then M,a k ~F(x,do(a,&)) in V,s, such it contains of S, as well. as well. There- Note the following: 1. The new database S has the same syntactic form as Vs,,, so this process can be iterated. 2. The computation of S is very efficient, and the size of S is bounded by the sum of the size of VsO and twice the number of fluents. I? Lin, R. Reiter/Art@cial Intelligence 92 (1997) 131-167 IS.5 We emphasize that the results of this section depend on the fact that the initial database [ 161 shows that for context free to yield finite first-order is not always guaranteed has a certain specific form. In fact, a result by Pednault actions and arbitrary D,, progression theories. 7. STRIPS [6] ), its logical in the literature se- (e.g. [ 21). These all [ 41, Bacchus and Yang to cap- theories on logical it has never been clear ex- they are ap- especially when for a reliance on meta-theoretic [ 111, Erol, Nau and Subrahmanian Ever since STRIPS was first introduced in common the add and delete operations lists of STRIPS operators, but (Fikes and Nilsson mantics has been problematic. There have been many proposals Lifschitz have ture actly what plied STRIPS-like tion for computing the progression fects of an action. We shall mechanisms, ifications. these operations incomplete their correctness with respect in terms of a purely declarative their effects. On our view, a STRIPS operator axiomatiza- is a mechanism the ef- two different STRIPS spec- In the sequel, we shall provide a semantics situation to their situation calculus calculus database under correspond theories. this idea by describing systems and to declaratively, of an initial and proving to logically for actions illustrate situation calculus Following Lifschitz [ 111, define an operator description (8 D, A), to be a triple where P is a sentence of a first-order .Cp~lps and D (the delete list) and A language (the add list) are sets of sentences of L: n~lps. A world description W is any set of sentences of Cn~fps. A STRIPS system consists of: I. a world description WO, called 2. a binary 3. a set Op of symbols called operators, and 4. a family of operator descriptions relation DC 2LsrR/ps x Ln~~ps,” {(Pa, D,, Aa)}ruEop. the initial world description, With each operator LY is associated a world description W,, the successor world descrip- tion of Wo, defined by W, = ( WO - 0,) U A,. A successor world description W, is admissible iff WO D P,. Sometimes, language C.rr~~p.r. In this case, admissibility but not always, D will be the standard entailment for the first- to the fact that Pa is entailed by the initial world description WO, in which case, on simply corresponds relation the operator and we prefer (Y is applicable. However, our intuitions to leave open the interpretation of the order the precondition the standard view of STRIPS, about STRIPS are not standard, “entailment” relation D. Our semantics for STRIPS systems is indirect; we define certain classes of theories in the situation calculus and show how to associate suitable STRIPS systems with those theories will, on theories. Only STRIPS systems associated with such situation calculus systems our account of STRIPS, be assigned a semantics. This leaves many STRIPS ‘I In his treatment of STRIPS, Lifschitz does not provide for the relation D 156 l? Lin, R. Reiter/Ariijicial Intelligence 92 (1997) 131-167 those without an associated (namely are not very distressed by this, given semantics not currently have coherent situation calculus that STRIPS systems, anyway. theory) without a semantics; we in their full generality, do 8. Two versions of STRIPS The STFUPS systems we derive apply only theories for which action which we now define. A successor form: the successor state axioms have a particular to a restricted class of situation calculus form, is strongly context free iff it has the syntactic state axiom Poss(a,s) 3 [F(x,do(a,s)) (3d’))a = A1(&')) V ... V (%‘““‘)a = A,,&“‘)) V = (19) the A and B are function symbols of sort action, not necessarily distinct from Here one another. The 6 and q are sequences of distinct variables which include all of the variables of x; the remaining quantified strongly context state axioms defined world example given below are strongly axiom that state axioms are special cases of context free successor state axioms of our running blocks state free. The following in Section 6. The successor context variables of the 6 and q are those being existentially x could be the empty sequence. Notice by the v and W, respectively. free but not strongly context free successor is context successor free: Poss(u, s) > [ontuble(x,do(u, s)) E a =putontuble(x) V ontuble( x, s) A a f tiptuble A a # pickup(x) 1. This is because the action tiptuble does not have x as a parameter. The STRIPS systems which we shall characterize will be for languages L2 whose only symbols of sort object are constants. Therefore, consider a ground action term function (Y, and the strongly context free successor state axiom (19) for fluent F, relativized to the initial situation So. How does LY affect the truth value of fluent F in the successor situation do( a, So)? By the unique names axioms that the successor axiom will be are strongly state axioms logically equivalent together with the assumption to a sentence of the form: for actions, context this relativized free, Poss(a,So) > [F(x,do(a,So)) x = x(I) v E . . . v -& = _p’) i”/ F(x,So) Ax # Y”)A...Ax # Y(“)]. Here the X and Y are tuples of constants of C2 obtained ground action situation, i.e., that D b Poss( CY, SO), this is equivalent term cy. If we assume further to: that the action LY is possible from those mentioned by the in the initial E Lin, R. Reiter/Artificial Intelligence 92 (1997) 131-167 F(x,do(a,So)) x = x”’ v . . . v x = x(n’) v F(x, So) A x # Y(l) A ‘. = . Ax # YCfl). 157 (20) Example 8.1. The following blocks world will provide a running example of this paper: for the rest Actions l move( x, y, z ) : move the block x from block y onto block z, provided both x and z are clear and block x is on top of block y. l movefromtable(x, y): move the block x from the table onto block y, provided x is clear and on the table, and block y is clear. l movetotuble( x, y) : move block x from block y onto the table, provided x is clear and x is on y. Flue&s l clear(x, s) : block x has no other blocks on top of it, in state S. l on(x, y, s): block x is on (touching) l ontable(x, s): block x is on the table, block y, in state S. in state s. This setting can be axiomatized as follows: Action precondition axioms Poss(move(x,y,z),s) = clear-(x, s) A clear( z, s) A on(x, y, s) A x # y A x # z A y # z, Poss(movefromtabZe( x, y) , s) E clear(x, s) A clear(y, s) A ontable(x, s) A x Z y, Poss( movetotable( x, y) , s) 5 clear-(x, s) A on( x, y, s) A x + y. Successor state axioms Poss(a,s) > [clear(x,do(a,s)) I (3y, z )a = move( y, x, z ) V (3y)a = movetotable( y, x) V clear(x,s) A7(3y,z)a=move(y,z,x) A 7 (3~) a = movefromtable( y, x) ] , Poss(a,s) > [on(x,y,do(a,s)) = (32 ) a = move( x, z, y) V a = movefromtable( x, y) V on(x,y,s) Au $1 movetotable(x,y) A~(3z)a=move(x,y,z)], Poss( a, s) > [ ontable( x, do(a, s) ) E ( 3y) a = movetotable( x, y) V ontable( x, s) A -( 3y)a = movefromtable( x, y) 1. 1% E Lin, R. Reiter/Arti$cial Intelligence 92 (1997) 131-167 NOW consider the “generic” ground action move( X, I: 2). The corresponding instances of (20) for the fluents clear, on and ontable are logically equivalent to: clear(x,do(move(X,I:Z),So)) rx=YVclear(x,&)Ax # Z, on(x,y,do(move(X,I:Z),So)) = x=XAy=ZVon(x,y,S())A~[x=XAy=Y], ontable(x,do(move(X,Y,Z),So)) E ontable(x,So). the generic ground actions movefromtable(X, Y) and movetotable(X, Y) we ob- For tain: clear( x, do(movefromtable( X, Y) , So) > E clear( x, So) A x f E: on(x,y,do(movefromtable(X,Y),So)) -x=XAy=YVon(x,y,So), ontable( x, do( movefromtable( X, Y) , So) ) E ontable( x, SO) A x # X, clear( x, do( movetotable( X, Y) , SO) ) s x = Y V clear(x, SO), on(x,y,do(movetotable(X,Y),So)) =on(x,y,So) Al[x=XAy=Y], ontable( x, do(movetotable( X, Y) , SO) ) E x = X V ontable( x, SO). 8.1. OCF-STRIPS: open world, context free STRIPS world in (not atoms with a closed world this database need not be is theory D = 2 U V,,y U V,,, U I&,,, U ‘Ds,,, incompleteness an open world version of STRIPS-open In this section we characterize that its database complete. is an action symbols of sort object literals and moreover, In other words, a certain degree of information is a set of ground as in most versions of STRIPS), the sense assumption, logically permitted. Our point of departure the following properties: with The only function 1. sesses are constants. i2 Each situation dependent F( C, SO) or -F( C, So) for fluent F and constants C of sort object. Ds,, contains unique names axioms distinct constant names C and C’ of sort object, DsO contains no pair of complementary Each successor We are progressing with respect initially: (and hence state axiom of V,,v is strongly context free. to a, a ground action that the second-order 4. 5. 6. literals 2. 3. for constants of sort object: for each pair of the axiom C + C’. sentence of DsO is a ground fluent literal, i.e., of the form term, and (Y is possible language L2 pos- is consistent). D t= Poss(a,So). I2 Recall that L? is the language in which V is expressed. E Lin. R. Reiter/Artijicial Intelligence 92 (1997) 131-167 159 7. For each tedious) fluent F, the consistency condition (14) is satisfied. It is easy (but to verify that each fluent of Example 8.1 satisfies this condition. intuition In keeping with our situation calculus databases, we want now to characterize under the effects of the ground action a in the case of action theories of the above kind. Our basis for this will be Theorem 6.1. the result of progressing DsO systems are mechanisms for progressing that STRIPS Let S be the following 1. Initialize S to {‘p E Ds,, 1 p is situation 2. For each fluent F do (with reference set of sentences: independent}. to the instance (20) of F’s successor state axiom) : (a) Add to S the sentence F(X”‘,do(a,&~)), (b) For each ground instance F( C, SO) E Vs,, add &(a, SO)), whenever C is a tuple of constants i= l,... object.) the sentence F( C, from each Y(j), the unique names axioms for constants of sort , n. (Here, we invoke i = 1,. . . ,m. to S different (c) Add to S the sentence (d) For each ground lF( Yci), &I( a, SO)), i = 1,. . , n. instance -F(C, SO) E VS,, add to S i = 1,. . . ) m. (We again -F( C, du(cu, SO)), whenever C is a tuple of constants different x(i), of sort object.) 6.1, the unique names axioms set S enjoys the resulting invoke By Theorem gression of DD, under action LY. Moreover, all ground can serve as a new initial database mechanism. literals, and S contains no pair of complementary for the purposes of iterating the property the situation dependent that S U DD,,?, is a pro- sentences of S are that S It follows the above progression literals. the sentence from each for constants Now we interpret the above construction of the set S as a STRIPS operator. the situation of deletions argument SO of all the ground and additions of ground Imag- literals of 2)~~. Now ask on literals must be performed version of Vs,, in order to obtain the situation-suppressed (i.e. S with the situation argument &(LY, SO) suppressed in its sen- and additions necessary to achieve this situation-suppressed of D)s,, to S will define the delete and add lists for the STRIPS op- ine suppressing what sequence the situation-suppressed version of S tences) . The deletions transformation erator cy. It is easy to see that the following deletions and additions, when applied to DO, the situation-suppressed version of Ds,,, yields For each fluent F do (with reference the situation-suppressed to the instance version of S: (20) of F’s successor state axiom) : from Da the sentences 1 F( Xci) ) , i = 1, . , m. from Da the sentences F(Y(“)), 1. Delete 2. Delete 3. Add to Da the sentences F(X(‘)), 4. Add to Z& the sentences i = 1,. . . , n. . , m. -F( Y(‘) ) , i = 1, . . . , II. i = 1,. It is now clear how to define a STRIPS system and its associated operator for LY: ” I3 See Section 7 for the relevant definitions 160 E Lin, R. Reiter/Art@cial Intelligence 92 (1997) 131-167 1. 2. 3. 4. 5. The language Ln~~ps is the situation-suppressed The initial world description is Do. version of L2. I4 logical entailment; for a world description W and sentence c E is ordinary D Lflip~ps, W D g iff W b g. a’s precondition equivalence For each fluent F, include for obtaining is the situation-suppressed version of the right hand side of the in (Y’S situation calculus action precondition axiom. in LY’S add and delete lists those literals specified above the situation-suppressed version of S. To our knowledge, OCF-STRIPS for an incomplete database of ground is the only variant of STRIPS which specifically is provably correct literals, and which provides with respect to a logical specification. Example 8.2. Continuing with our blocks world example, we can “read off” the OCF- STRIPS operator state axioms given the instances of the successor in Example 8.1: for move from schema moue(X,I:Z) I5 P: clear(X) A clear(Z) A on(X, Y) A X # Z A X # Y A Y # Z. D: ~clear(Y),cfear(Z),~on(X,Z),on(X,Y). A: clear(Y), -dear(Z), on( X, Z), ~on(X, Y). The operator description the same way: schemas for movefromtable and movetotable are obtained in movefromtable(X, Y) P: clear(X) A cfear( Y) A ontable( X) A X f I: D: ~on( X, Y) , ontable( X) , clear( Y) . A: on( X, Y) , lontable( X) , dear(Y). movetotable( X, Y) P: dear(X) Aon(X,Y) AX f P D: 4ear( A: clear(Y) , ~on( X, Y) , ontable( X). Y) , on( X, Y) , lontuble( X) . 8.2. RCF-STRIPS: relational, context free STRIPS In this section, we characterize in the sense relational database. This version of STRIPS derives theories D of the form 2) = E U V,, U Vop U V,,, U I&, , with the following a relational version of STRIPS-relational is a conventional that its database from action properties: l4 We take it as self evident what situation from the language L2. I5 Notice X, Y and 2 of the schema by constants of our situation calculus that these are schemas, standing language. is meant formally by the language obtained by suppressing for the family of operators obtained by instantiating objects of sort the “variables” E Lin, R. Reiter/Arti&ial Intelligence 92 (1997) 131-167 161 1. The only function symbols of sort object that the second-order language L2 pos- sesses are constants. 2. Vs,, contains one sentence of the following form, for each fluent F: F(x,&,) s x =C(l) V...Vx =@, (21) the Cci) are tuples of constant where situation dependent special cases of the relatively 12 = 0 is permitted, an agent’s hand is initially empty: sentences of D so. Notice in which case this axiom symbols of sort object. These are the only that initial databases of this form are in Section 5. The case if is F(x, SO) 3 false. For example, complete databases defined holding( X, So) 3 false. If initially, block A is on B, D is on A, C is on E, and no other block block: is on a on(x,y,So) =x=AA~=BVX=DA~=AVX=CA~=E. 3. 27s” contains unique names axioms for constants of sort object. 4. Each successor 5. We are progressing with respect is strongly context free. to LY, a ground action state axiom of D,, term, and LY is possible initially: 27 k Poss(GJ,So). Notice that the single sentence (21) is logically equivalent to: F(C”‘,So),. . . , F(C(“),So), x # C(‘)A...AX # 6’) > lF(x,So). (22) (23) by the set of all positive (22) of F, we can trivially determine instances to represent a database of this form Notice also that, given all the positive (23). So it is sufficient the sentence purposes) computational what some versions of STRIPS do (but suppressing also what relational databases do; in fact, the unique names assumption the condition [ 201). The relational in mind that logically, (23) and unique names axioms.) for is is together with (Reiter instances of the fluents F. (But bear tables are just the database consists of the table for F, together with the axiom instances of F. This, we claim, argument). This (2 1) on Ds, are the defining properties for a relational database the situation the ground (say As we did in the previous section, we want now to characterize the effects of the ground action to the results ing 27~~ under above kind. To do so, we appeal successor state axiom By our assumption (20) (21) on the syntactic for fluent F which we relativized form of Vs,, (20) (Y in the case of action in Section 5. Consider the result of progress- theories of the free to the initial situation SO. to: is equivalent the context F(x,do(a,So)) x = XC’) v E . . . v -# = x(nr) v [x = C(I) v.. . v X = C(n)] Ax # Y(l) A.. . A 3 # y(n). 162 E Lin, R. Reiter/Artifciul Intelligence 92 (1997) 131-167 C”’ be all the C”’ that are different symbols of sort object, tuples than all of the Y(j). Then, by the above sentence will be Let C(t),..., unique names axioms to logically equivalent F(x,du(a,So)) = $1) v . x for constant f v x = X’“” v x = c(I) v . . . v x = C”‘. (24) Let S be the following set of sentences: 1. Initialize S to (9 E DsO 1 p is situation 2. For each fluent F do: add the sentence independent}. (24) that SUl&,,, to S. set S enjoys The resulting (Y (Theorem 5.1) . Moreover, S has the same syntactic a new initial database Now we interpret for the purposes of iterating the above construction the property is a progression of D,s,, under action form as DsO, and so can serve as the above progression mechanism. of the set S as a STRIPS operator. Imagine representing the situation dependent sentences F(x, So) E x = C(l) V . . . V x = C@) (25) instances database a shorthand this representation (25). Now ask what sequence of deletions and additions of ground of ground is merely relational F( C”‘), . . . , for the sen- literals must relational database version of Vs,, in order and additions of S representation relational version of S. The deletions of DO to the corresponding that the situation-suppressed by F(C(“)). We emphasize tence be performed on 270, the situation-suppressed the situation-suppressed to obtain necessary to achieve will define this transformation the delete and add lists for the STRIPS operator a. It is easy to see that the following deletions and additions, when applied to ‘Da, yield the situation-suppressed, relational database representation of S: For each fluent F do (with reference 1. Delete 2. Add to De the sentences F( Xc’)), from De the sentences F(Y(‘)), to (20) ) : i = 1,. . . , n. i = 1,. . . , m. It is now clear how to define a STRIPS system and its associated operator for (Y: l6 1. The language L,~-RIPS is the situation-suppressed 2. The initial world description 3. For a sentence u E Lr~,ps, W D CT iff R( W) b u. Here, W is a world description version of L2. is Z&. database form for all its fluents, a fluent are ground atoms of that fluent. R(W) in relational mention relational database part of W to its full logical form as follows: R(W) the sentences of W that do not mention a fluent, the form in W that of the consists of together with those sentences of i.e., the only sentences is the translation F(x) E x = C(l) V . . . V x = Ccn) where F(C(‘)) 4. LY’S precondition equivalence . , F( C”“) are alE the ground . is the situation-suppressed instances of a fluent F in W. version of the right hand side of the in a’s situation calculus action precondition axiom. I6 See Section 7 for the relevant definitions E Lin, R. Reiter/Artijicial Intelligence 92 (1997) 131-167 163 5. For each fluent F, include in (Y’S add and delete lists those literals specified above for obtaining the situation-suppressed relational database representation of S. the same actions, Example 8.3. Consider treat this setting now as an instance of an RCF-STRIPS In this case, as before, we can “read off” the RCF-STRIPS from the instances of the successor state axioms of Example 8.1: fluents and axioms as in Example 8.1, except situation calculus specification. operator schema for move move( X, x Z) P:clear(X)Aclear(Z)Aon(X,Y)AX#ZAx#YYY#Z. D: clear(Z),on(X,Y). A: clear(Y),on(X,Z). The operator description the same way: schemas for movefromtable and movetotable are obtained in movefromtable( X, Y) P: clear(X) A clear(Y) A ontubZe( X) A X # I! D: clear(Y) , ontable( X). A: on(X,Y). movetotable( X, Y) P: clear(X) Aon(X,Y) AX # K D: on( X, Y) . A: cfear( Y) , ontuble( X). 8.3. Pednault’s ADL The only prior literature similar to our progression semantics relates a STRIPS database theory, distinguishes for STRIPS-like systems to the initial of such a database, our approach structures. So for Pednault, structures, to the is defined by just [ 111, a STRIPS operator this theories, where to the theory. The to first-order of STRIPS, from structures in which first-order as a situation-suppressed [ 16,181. Like us, Pednault calculus are first-order situation these databases is a mapping is defined by the addition is by Pednault situation of a situation calculus axiomatization. But our interpretation namely from Pednault’s, a STRIPS operator where this mapping relations of the structure. ADL, Pednault’s generalization such a mapping between is a mapping mapping is effected by add and delete problem with the ADL view on STRIPS for applying theory theory must be mapped by an ADL operator set of all such transformed When there are infinitely many such models, or even when structures. For us, as for Lifschitz in the case that the database a STRIPS operator into its transformed (e.g. OCF-STRIPS from first-order second-order) to (possibly theories of Section 8.1). For in such a case, every model of this structure, and it is the the effect of the ADL operator. in number structures which represents they are finite lists of sentences applied is that it does not provide a feasible mechanism incomplete is a logically and deletion of tuples applied 164 E Lin, R. Reiter/Art@cial Intelligence 92 (1997) 131-167 but plentiful, ADL becomes an unattractive STRIPS mechanism. is on STRIPS operators representations sentential that apply of these many models. In contrast, our focus theories, and hence operate on the single to logical 9. Summary and future problems Although progression is a widespread notion its full generality the properties of progression, and related what we take to be the main contributions it is a surprisingly in the database and AI literatures, complex idea. This paper has explored in some of them to STRIPS systems. Here we summarize of the paper. 1. We have argued the need for progressing a database, both from the perspective of STRIPS, and for the purposes of cognitive robotics. 2. We have semantically defined a notion of progression, that in general, is required. Moreover, we have shown how to finite first- for the progression of an arbitrary and shown logic it, second-order to capture determine sentence a second-order (or second-) order initial database. 3. We have explored two special cases for which progression free successor state axioms. In both cases, we gave efficient procedures the progression. On the other hand, as Pednault has shown free successor state axioms, when is first order definable, initial databases with arbitrary successor form of open world initial database, with for [ 161, even is an arbitrary the initial database namely, complete the case of relatively state axioms, and the case of a limited context computing for context finite first-order theory, progression need not be finitely first-order axiomatizable. is a mechanism for progressing can best be understood with reference of actions and their effects. Under a situation calcu- to a suitable this intuition, to formulate various STRIPS-like calculus axiomatization 4. On our view a STRIPS operator lus theory, and its semantics situation it becomes possible rectness with respect to our progression that for two different STRIPS systems tion OCF-STRIPS of logical only variant of STRIPS which specifically provides ground is of particular incompleteness semantics. (OCF- and RCF-STRIPS) systems, and prove their cor- In this paper we have done just . In this connec- form is the for an incomplete database of interest because for a (limited) of the database. To our knowledge, OCF-STRIPS it provides situation calculus specifications process and successor 5. It is a completely mechanical literals, and which is provably correct with respect to a logical specification. to obtain operators of some domain. Similarly the action precondition iomatization purely declarative STRIPS systems. Moreover, Reiter’s an algorithm specifying iomatizer laws, and have those axioms automatically ators for that domain have the right syntactic the causal can describe (assuming forms). for computing calculus [ 211 solution In other words, the OCF-STRIPS for RCF-STRIPS. state axioms of a situation from ax- these can be compiled into appropriate to the frame problem provides the effect axioms from the ax- In other words, causal the domain’s into suitable STRIPS oper- the successor state axioms and the initial situation axioms, and transformed the successor state axioms laws of the domain being modeled. the action precondition E Lin, R. Reiter/Artijicial Intelligence 92 (1997) 131-167 165 The results of this paper suggests a variety of topics for future research: 1. There are other cases for which progression such case concerns actions with finitary effects, namely, when for every fluent, action changes and other special cases of progression need to be explored. logic. One the truth value at only a finite number of instances. This can be done in first-order the fluent’s In this connection, Etzioni et al. [5] have recently proposed an extension of to accommodate about sensing actions, the world. As Levesque i.e., actions that obtain (at plan execution the resulting stemming primarily and drawbacks, of their system. As it happens, [9] has observed, suffers from a number of limitations specification lack of a declarative calculus account of sensing actions already exists (Scherl and Levesque sensing actions into our to include such actions. to prove the correctness of this version of STRIPS with semantics, much as we did in this paper for RCF- and to incorporate and use this to generalize STRIPS then be possible to its progression it should be possible a the information STRIPS time) planner from situation [ 261). Accordingly, notion of progression, It should respect OCF-STRIPS. 2. We have considered only systems that compute purposes, for example for computational that part of the progression Sometimes, only example, is no need to progress still an open problem how such partial progressions in a principled way. that is relevant if our blocks world includes a fluent for the colors of blocks, this fluent if our goals have nothing the full result of progression. it may be better to compute to the goals of interest. For then there to do with colors. It is can be specified and computed 3. The connection of RCF-STRIPS to relational databases of STRIPS operators (not just adds and deletes) natural generalization operators indeed be done, and an appropriate calculus that relaxes axioms of Section 8.2. In this connection, Pednault’s ADL such a generalized semantics the context axiomatization in defining to allow for arbitrary (Section 8.2) suggests a relational algebra the operator’s effects. This can is defined in terms of a situation free restriction on successor state for just [ 181 provides 4. In a sense, progressing and all those situations situation view of progression base Reiter [ 141). to forget about some of its contents a database relational STRIPS, but without to 5, amounts that are reachable the relational to forgetting the initial from SO but not from S,. This leads to an interesting notion of what it means for a knowledge in (Lin and that is investigated algebra. about further Acknowledgements advice and feedback, we wish to thank the other members of the of Toronto Cognitive Robotics Group: Yves Lesptrance, Hector Levesque, and Richard Scherl. One of the referees made a number of valuable the Government improving research was funded by the paper. This For their generous University Daniel Marcu, suggestions for of Canada National Sciences Robotics and Intelligent Systems. and Engineering Research Council, and the Institute for 166 I? Lin, R. Reiter/Arttficial Intelligence 92 (1997) 131-167 References in: Proceedings Second International Conference on Database I 1 J S. Abiteboul, Updates, a new frontier, Theory (Springer, New York, 1988) 121 E Bacchus and Q. Yang, Downward l-1 8. refinement and the efficiency of hierarchical problem solving, Artif Intell. 71 (1994) 41-100. 131 E.W. Dijkstra and C.S. Scholten, Predicate Calculus and Program Semantics (Springer, New York, 1990). 141 K. Erol, D. Nau and V. Subrahmanian, On the complexity of domain independent planning, in: Proceedings AAAI-92, San Jose, CA (1992) 381-386. IS] 0. Etzioni, S. Hanks, D. Weld, D. Draper, N. Lesh and M. Williamson, An approach to planning with in: Proceedings Third Infernational Conference on Principles of Knowledge incomplete Representation and Reasoning, Cambridge, MA ( 1992) 115-125. information, 161 R.E. Fikes and N.J. Nilsson, STRIPS: a new approach to theorem proving in problem solving, Artif: Intell. 2 (1971) 189-208. 171 S.C. Kleene, Mathematical Logic (Wiley, New York, 1967). [ 81 Y. Lesperance, H.J. Levesque, E Lin, D. Marcu, R. Reiter and R. Scherl, Foundations in: M. Wooldridge, of a logical J. Muller and M. Tambe, eds., Intelligent Agents of the 1995 Workshop on Agent Theories, Architectures, and Languages (ATAL - to agent programming, approach Wmune II-Proceedings 95) (Springer, New York, 1996) 331-346. 191 H.J. Levesque, What is planning Science, University of Toronto, Toronto, Ont. ( 1995). in the presence of sensing?, Tech. Rept., Department of Computer [ 10 1 H.J. Levesque, R. Reiter, Y. Lesptrance, E Lin and R. Scherl, GOLOG: a logic programming language for dynamic domains, J. Logic Program. (to appear). [ 1 I I V. Lifschitz, On the semantics of STRIPS, in: Proceedings Workshop on Planning and Reasoning about Action, Timberline, OR (1986) l-9. [ 121 E Lin and R. Reiter, How in: Proceedings Fourth International Conference on Principles of Knowledge Representation and Reasoning, Bonn ( 1994) 425-436. to progress a database foundations, (and why) I. Logical I 131 F. Lin and R. Reiter, State constraints [ 141 E Lin and R. Reiter, Forget it!, in: R. Greiner and D. Subramanian, revisited, J. Logic Comput. 4 (1994) 655-678. eds., Working Notes of AAAI Fall Intelligence, Menlo Park, CA, 1994) Symposium on Relevance 154-159. (American Association for Artificial [ 15 J E Lin and R. Reiter, How to progress a database II. The STRIPS connection, in: Proceedings IJCAI-95, Montreal, Que. (1995) 2001-2007. [ 161 E.P. Pednault, Toward a mathematical theory of plan synthesis, PhD thesis, Department of Electrical Engineering, Stanford University, Stanford, CA ( 1986). [ 17 ] E.P Pednault, Synthesizing plans that contain actions with context dependent effects, Comput. Intell. 4 ( 1988) 356-372. 1 E.P. Pednault, ADL: exploring the middle ground between STRIPS and the situation calculus, in: Proceedings First International Conference on Principles of Knowledge Representation and Reasoning, Toronto, Ont. ( 1989) 324-332. 1 P. Peppas, N. Foo and M.-A. Williams, On the expressibility of propositions, Logiyue Anal. 139-140 (1992) 251-272. I R. Reiter, Towards a logical reconstruction of relational database theory, in: M. Brodie, J. Mylopoulos and J. Schmidt, eds., On Conceptual Modelling: Perspectives,from ArtiJicial Intelligence, Databases and Programming Languages (Springer, New York, 1984) 191-233. [ 2 I] R. Reiter, The frame problem for goal regression, in the situation calculus: a simple solution (sometimes) and a completeness result Computation: Papers in Honor of John McCarthy (Academic Press, San Diego, CA, 1991) 418-420. ed., Artificial Intelligence and Mathemafical Theory of in: V. Lifschitz, 1221 R. Reiter, Proving properties of states in the situation calculus, Arttf Intell. 64 (1993) 337-3.51. [23] R. Reiter, On specifying database updates, J. Logic Program. 25 ( 1995) 53-91. [ 241 R. Reiter, Some soundness and completeness in the situation calculus results for regression (to appear). E: Lin, R. Reiter/Art$icial Intelligence 92 (1997) 131-167 161 [ 25 1 S.J. Rosenschein, Plan synthesis: A logical perspective, in: Proceedings IJCAI-81, Milan ( 1981) 33 I- 331. 1261 R. Scherl and H.J. Levesque, The frame problem and knowledge-producing actions, in: Proceedings AAAI-93, Washington, DC (1993). solution I27 ] L.K. Schubert, Monotonic for worlds with fully specified actions, Representation and Defeasible Reasoning (Kluwer Academic Publishers, Boston, MA, 1990) 23-67. to the frame problem in the situation calculus: an efficient method in: H.E. Kyberg, R.P. Loui and G. Carlson, eds., Knowledge [ 28 1 R. Waldinger, Achieving several goals simultaneously, in: E.W. Elcock and D. Michie, eds., Machine /ntelligence 8 (Ellis Horwood, Chichester, 1977) 94-136. 