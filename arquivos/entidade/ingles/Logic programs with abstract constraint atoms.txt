Artificial Intelligence 174 (2010) 295–315Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintLogic programs with abstract constraint atoms: The roleof computations ✩Lengning Liu a, Enrico Pontelli b,∗, Tran Cao Son b, Miroslaw Truszczy ´nski aa Department of Computer Science, University of Kentucky, Lexington, KY 40506, USAb Department of Computer Science, New Mexico State University, Las Cruces, NM 88003, USAa r t i c l ei n f oa b s t r a c tArticle history:Received 3 September 2008Received in revised form 16 November 2009Accepted 23 November 2009Available online 27 November 2009Keywords:Logic programs with abstract constraintatomsAnswer setsComputationsWe provide a new perspective on the semantics of logic programs with arbitrary abstractconstraints. To this end, we introduce several notions of computation. We use the results ofcomputations to specify answer sets of programs with constraints. We present the rationalebehind the classes of computations we consider, and discuss the relationships among them.We also discuss the relationships among the corresponding concepts of answer sets. Oneof those concepts has several compelling characterizations and properties, and we proposeit as the correct generalization of the answer-set semantics to the case of programs witharbitrary constraints. We show that several other notions of an answer set proposed inthe literature for programs with constraints can be obtained within our framework as theresults of appropriately selected classes of computations.© 2009 Elsevier B.V. All rights reserved.1. Introduction and motivationWe study logic programs with arbitrary abstract constraints, or simply, constraints. Programs with constraints providea general framework to study semantics of extensions of logic programs with aggregates. It is due to the fact that nor-mal logic programs, programs with monotone and convex constraints (proposed by Marek and Truszczy ´nski [31], Liu andTruszczy ´nski [25]), and several classes of programs with aggregates (e.g., [6,14,35,40]) can be viewed as special programswith arbitrary constraints.The original definition of the syntax of programs with constraints, along with a possible semantics, has been proposedby Marek and Remmel [29]. An alternative semantics was later proposed by Son, Pontelli, and Tu [42], and revisited by Shenand You [38] and by You, Yuan, Liu, and Shen [45].In this paper, we introduce a general framework for defining and investigating semantics for programs with constraints.We base our development on the notion of computation. The proposed framework builds on general principles that can beelicited from the semantics of traditional normal logic programs (i.e., logic programs with negation as failure).The answer-set semantics of logic programs was introduced by Gelfond and Lifschitz [20]. The semantics generalizes thestable-model semantics of Gelfond and Lifschitz [19], which was proposed for the class of normal logic programs only, tologic programs with two negations (negation as failure and classical negation). In the paper, we consistently use the termanswer-set semantics, as it is currently more widely used, and as the bulk of our paper is concerned with programs thatare not normal.✩An extended abstract of this paper appeared in the Proceedings of the 2007 International Conference on Logic Programming.* Corresponding author.E-mail addresses: lliu1@cs.uky.edu (L. Liu), epontell@cs.nmsu.edu (E. Pontelli), tson@cs.nmsu.edu (T.C. Son), mirek@cs.uky.edu (M. Truszczy ´nski).0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2009.11.016296L. Liu et al. / Artificial Intelligence 174 (2010) 295–315The answer-set semantics forms the foundation of Answer-Set Programming (ASP) [30,33,18]. Intuitively, an answer setof a program represents the set of “justified” beliefs of an agent, whose knowledge is encoded by the program. Over theyears, researchers have developed several characterizations of answer sets, that identify and emphasize their key featuresand suggest ways to compute them.The original definition of answer sets [19] introduces a “guess-and-check” approach to computing answer sets of aprogram. The process starts by guessing an interpretation, to be used as a candidate answer set, and then proceeds invalidating it. The validation consists of recomputing the guessed interpretation, starting from the empty set and iterativelyapplying the immediate consequence operator [43] for the Gelfond–Lifschitz reduct of the program [19]. The interpretation isaccepted only if it is the limit of this iterative process. In this approach, once the guess is made, the validation is entirelydeterministic.Other characterizations of answer sets suggest an alternative scheme for constructing answer sets. The process starts,also in this case, from the empty set. At each step, we add to the set under construction the heads of some of the rulesapplicable at that step. Typically, we use all the rules selected during the previous steps (if they are no longer applicable,the construction terminates with failure) plus some additional ones. When the process stabilizes—i.e., no new elements canbe introduced in the set—the result is an answer set [27,32]. In this approach, we replace the initial non-deterministic stepof guessing an entire interpretation with local non-deterministic choices of rules to fire at each step of the construction.Similarly, the task of validation is distributed across the computation. Observe that this approach for characterizing answersets represents the underlying model that is employed by several ASP solvers, where 3-valued partial models [44] areextended to stable models.Example 1. Let us consider the program P 1 consisting of the following rules:a ← not bb ← not ac ← ad ← bThis program has two answer sets: {a, c} and {b, d}.1In the “guess-and-check” approach, we might guess {a, c} as a candidate answer set. To verify the guess, we computethe Gelfond–Lifschitz reduct, consisting of the rules:a ←c ← ad ← bThe validation requires determining the least fixpoint of the immediate consequence operator of the reduct program—i.e.,the least Herbrand model of the reduct program—which corresponds to {a, c}. Since it coincides with the initial guess, theguess is validated as an answer set. In the same way, we can also validate the guess {b, d}. However, the validation of {a}fails—since the reduct program contains the rulesa ←c ← ad ← band the iteration of its immediate consequence operator converges to {a, c}, which is different from the initial guess {a}.The alternative approach we mentioned starts with the empty interpretation, ∅, which makes two rules applicable:a ← not b and b ← not a. The algorithm needs to select some of them for application, say, it selects a ← not b. The choiceresults in the new interpretation {a}. Two rules are applicable now: a ← not b and c ← a. Let us select both rules forapplication. The resulting interpretation is {a, c}. The same two rules that were applicable in the previous step are stillapplicable and no other rules are applicable. Thus, there is no possibility to add new elements to the current set. Thecomputation stabilizes at {a, c}, thus making {a, c} an answer set.We note that the first approach starts with a tentative answer set of the program, while the second starts with the emptyinterpretation. In the first approach, we guess the entire answer set at once and, from that point on, proceed in a determin-istic fashion. In the second approach we construct an answer set incrementally making non-deterministic choices along the1 Since neither in this example, nor anywhere else in the paper, do we consider classical negation, following the tradition of logic programming, wedescribe an answer set using a set of atoms—that contains all the atoms that are true; the remaining atoms are considered false by default.L. Liu et al. / Artificial Intelligence 174 (2010) 295–315297way. Thus, each approach involves non-determinism. However, in the second approach, the role of non-determinism couldbe potentially more limited.In this paper, we cast these two approaches in terms of abstract principles related to a notion of computation. We then liftthese principles to the case of programs with abstract constraints and derive from the approach a well-motivated semanticsfor such programs.The recent interest in ASP has been fueled by the development of inference engines to compute answer sets of logicprograms, most notably systems like Smodels [34], Cmodels [23], clasp [16] and DLV [22], which allow programmers totackle complex real-world problems (e.g., [2,21,13]). To facilitate declarative solutions of problems in knowledge represen-tation and reasoning, researchers proposed extensions of the logic programming language, which support aggregates [33,6,8,14,17,35,39].These development efforts stimulated interest in logic programming formalisms based on abstract constraint atoms, orig-inally proposed by Marek and Remmel [29] and Marek and Truszczy ´nski [31]. The objective was not to introduce aknowledge representation language but rather an abstract framework, in which one could study semantics of knowledgerepresentation systems obtained by extending the syntax of logic programs aggregates. The need arose as the introductionof constraints and aggregates into logic programming created a challenge to extend the semantics. Researchers proposedseveral possible approaches [14,8,40,42,11,41]. These approaches all agree on large classes of programs, including• normal logic programs (every extension contains that class),• programs with monotone aggregates such as weight atoms with all weights non-negative and without the upperbound given (they can be regarded as special programs with monotone constraints, as presented by Marek andTruszczy ´nski [31]), and• programs with convex aggregates such as weight atoms with all weights non-negative and with both lower and up-per bounds given (they can be regarded as special programs with monotone constraints, as presented by Liu andTruszczy ´nski [25]).However, the proposed approaches tend to differ on programs with arbitrary aggregates.What makes the task of defining answer sets for programs with aggregates difficult and interesting is the non-monotonicbehavior of such constraints. For instance, let us consider the constraint ({p(1), p(−1)}, {∅, {p(1), p(−1)}}),2 which can beseen as an encoding of the aggregate(cid:4)(cid:4) X ∈ {−1, 1} ∧ p(X)= 0.Sum(cid:5)(cid:6)(cid:2)(cid:3)XThis aggregate atom is true in the interpretations ∅ and {p(1), p(−1)}, but false in {p(1)} and {p(−1)}. Therefore it is notmonotone; observe that it is also not convex.In this paper, we propose and study a general framework for defining semantics (different types of answer sets) of logicprograms with constraints. Our proposal relies on the notion of (incremental) computation. We introduce several classes ofcomputations and use their results to define different types of answer sets. The approach can be traced back to the twobasic methods to characterize answer sets of normal logic programs that we mentioned above.The notion of a computation we introduce and use here generalizes those developed by Marek and Truszczy ´nski [31] andLiu and Truszczy ´nski [25] for programs with monotone and convex constraints. We study properties of the various classesof computations introduced and of the corresponding notions of answer sets. We relate these computation-based conceptsof answer sets to earlier proposals. An interesting observation of our investigation is that several characterizations convergeto the same semantics—which correspond to the one proposed by Son, Pontelli, and Tu [42].A preliminary approach to the notion of computation investigated in this paper has been presented by Liu, Pontelli,Son, and Truszczy ´nski [24]—the present manuscript deeply revises and reorganizes the ideas from that work, leading todefinitions and results that are significantly different and more advanced those presented earlier.The contributions presented in this work are of importance not only to the field of logic programming, but the overalldomain of knowledge representation. Answer-Set Programming has gained a momentum as an instrument for the design ofintelligent agents and for investigating properties of reasoning in complex domains (e.g., domains with multiple interactingagents, domains with incomplete knowledge, domains with non-deterministic actions). Several of the recently exploredextensions of languages used in Answer-Set Programming have been motivated by the needs of applications in these areasof research (e.g., [9,10]). In the invited talk at the AAAI’05 conference, given by Baral [4], logic programming under theanswer-set semantics has been presented as an attractive and suitable knowledge representation language for AI research,as it features several desirable properties. In particular, the formalism:• is declarative and has a simple syntax;• is non-monotonic and is expressive enough for representing several classes of problems in the complexity hierarchy [5];• has solid theoretical foundations with a large body of building block results [3]—e.g., equivalence between programs,systematic program development, relationships to other non-monotonic formalisms; and• is supported by several efficient computational tools, as those mentioned earlier.2 We introduce this notation in Section 4.298L. Liu et al. / Artificial Intelligence 174 (2010) 295–315The general framework of abstract constraints provides a foundation for the investigation of generalizations of currentASP formalisms to meet the needs of knowledge representation and reasoning applications.2. Normal logic programs and answer-set semanticsA normal logic program P is a set of rules of the forma ← a1, . . . , am, not am+1, . . . , not an(1)where 0 (cid:2) m (cid:2) n, each ai is an atom in a first-order language L and not is the negation-as-failure (default negation) con-nective. An expression of the form not a, where a is an atom, is a default literal. A literal is an atom or a default literal.A program is positive (or Horn) if it does not contain default literals.The Herbrand universe and the Herbrand base of a program are defined in the standard way [26]. All major semantics ofprograms are restricted to Herbrand interpretations and, under each of them, a program and its ground instantiation areequivalent. That includes the answer-set semantics, which is of interest to us here. Ground programs under the semanticsof Herbrand models are, essentially, propositional programs. Thus, from now on, we consider only propositional programsover a fixed countable set At of propositional atoms.For a propositional rule r of the form (1), a is the head of r. We denote it by hd(r). We set pos(r) = {a1, . . . , am}, andneg(r) = {am+1, . . . , an}. Finally, we denote with body(r) the body of the rule r, that is, the set of the literals in the right-handside of the rule r.We represent Herbrand interpretations as subsets of At. An atom a is satisfied by an Herbrand interpretation M ⊆ At ifa ∈ M. A default literal not a is satisfied by M if a /∈ M. We write M |(cid:8) (cid:2) to denote that a literal (cid:2) is satisfied by M. Similarly,if S is a set (conjunction) of literals, we write M |(cid:8) S to denote that M |(cid:8) (cid:2), for every (cid:2) ∈ S.A rule r is M-applicable if M |(cid:8) body(r). We denote by P (M) the set of all M-applicable rules in P . An atom a is supportedby M in P if a is the head of at least one M-applicable rule r ∈ P . An interpretation M satisfies P , or is a model of P , ifit contains all atoms supported by M in P . An interpretation M is a supported model of P if M is a model of P and everyatom in M is supported by M in P . Observe that not every model of a program is a supported model. For example, theset {a, b} is a model of a program P = {a ← not b}; however, it is not a supported model of P , since neither a nor b issupported by {a, b}.The immediate consequence operator, also referred to as the one-step provability operator, maps interpretations to interpre-tations. Specifically, it assigns to an interpretation M the set of the heads of all rules in P (M), that is, the set of all atomsthat are supported by M in P . We denote this operator by T P . Formally,(cid:3)hd(r): M |(cid:8) body(r), for some r ∈ PT P (M) =(cid:5).One can check that the fixpoints of T P are supported models of P [1].For later use, let us introduce the following notion of iterated applications of T P . Let (cid:9)T P ↑i(cid:11)∞i=0 be the sequence:T P ↑0 = ∅T P ↑(i + 1) = T P (T P ↑i).We note that if P is a positive program then T P is a monotone (and continuous) operator whose least fixpoint, denoted byi=0 T P ↑i. Many other properties of T Plfp(T P ), is the (unique) least Herbrand model of P . It is well known that lfp(T P ) =have been discussed, for example, by Lloyd [26].(cid:7)∞The Gelfond–Lifschitz reduct of P w.r.t. M, denoted by P M , is the program obtained from P by deleting(1) each rule whose body contains a default literal not a such that a ∈ M, and(2) all default literals in the bodies of the remaining rules.Note that P M is a positive program whose least model is lfp(T P M ). An interpretation M is a stable model or, as we willsay here, an answer set of P , if and only if M is the least model of P M . Thus, M is an answer set of P if and only ifM = lfp(T P M ). It also follows directly from the definitions that the least model of a positive program is the only answer setof that program.3. Computations in normal logic programs: PrinciplesWe start by motivating the notion of a computation, which is central to our paper, as a tool to determine answer setsof a normal logic programs. Our starting point is the collection of considerations introduced in Example 1. In particular, weshow how to use computations to characterize answer sets.We define computations for a normal program P as sequences (cid:9) Xi(cid:11)∞i=0 of sets of atoms (propositional interpretations),where Xi represents the state of the computation at step i. In particular, we require that X0 = ∅. A key intuition is thatat each step i (cid:3) 1, we use P to revise the state Xi−1 of the computation into its new state Xi . We base the revision onL. Liu et al. / Artificial Intelligence 174 (2010) 295–315299a non-deterministic operator, ConclP . Given an interpretation X , ConclP ( X) consists of all possible revisions of X that are“grounded” in P .Formally, a set of atoms Y is grounded in a set of atoms X and a program P if Y ⊆ T P ( X), that is, if every atom in Y issupported by X in P . Thus, ConclP ( X) = {Y | Y ⊆ T P ( X)}.The first principle we will impose on computations formalizes the way in which states of computations are revised. Wecall it the principle of revision.(R) Revision: each successive element in a computation must be grounded in the preceding one and the program, thatis, Xi ∈ ConclP ( Xi−1), for every i (cid:3) 1.Computations of answer sets of a program, using the methods described in Example 1, produce sequences of sets that aremonotonically growing (w.r.t. set inclusion), each set being a part of the answer set under construction. Thus, at each stepnot only new atoms are computed, but also all atoms established earlier are recomputed. This suggests another principlefor computations, the principle of persistence of beliefs:(P) Persistence of beliefs: each next element in the computation must contain the previous one (once we “revise an atomin”, we keep it), that is, Xi−1 ⊆ Xi , for every i, 1 (cid:2) i.For a sequence (cid:9) Xi(cid:11)∞i=0 Xi and we refer to X∞ as the result of (cid:9) Xi(cid:11)∞i=0.The result of a computation should be an interpretation that cannot be revised any further. This suggests one additionalbasic principle for computations, the principle of convergence:i=0 satisfying the principle (P), we define X∞ =(cid:7)∞(C) Convergence: a computation continues until it stabilizes (no additional revisions can be made). Formally speaking,convergence requires X∞ = T P ( X∞), where T P is the one-step provability operator for P . (In particular, convergenceimplies that X∞ is a supported model of P .)These observations can be summarized in the following definition.Definition 1. Let P be a normal logic program. A sequence of interpretations (cid:9) Xi(cid:11)∞(cid:9) Xi(cid:11)∞i=0 satisfies the principles (R), (P) and (C).i=0 is a computation for P if X0 = ∅ andComputations are relevant to the task of describing answer sets of normal logic programs. We have the following result.Proposition 1. Let P be a normal logic program. If a set of atoms X is an answer set of P then there exists a computation (cid:9) Xi(cid:11)∞P such that X = X∞.i=0 forProof. If X is an answer set of P then X is the least fixpoint of T P X . Let us define Xi = T P X ↑i. It follows from the propertyof the operator T P X that X = lfp(T P X ) =i=0 is acomputation for P .i=0 Xi . To complete the proof, it suffices to show that (cid:9) Xi(cid:11)∞i=0 T P X ↑i =(cid:7)∞(cid:7)∞First, we note that T P X is a monotone operator and X0 = ∅. It follows that for every i (cid:3) 1, Xi−1 ⊆ T P X ( Xi−1) = Xi . Thus,the principle of persistence of beliefs holds. We also have that for every i (cid:3) 0, Xi ⊆ X and X = X∞. Consequently, for everyi (cid:3) 1, Xi = T P X ( Xi−1) ⊆ T P ( Xi−1), that is, the principle of revision holds. Finally, since X is an answer set of P , X is asupported model of P . Consequently, T P ( X) = X and the principle of convergence holds. (cid:2)Proposition 1 implies that the principles (R), (P) and (C) give a notion of computation broad enough to encompass allanswer sets. Is this concept of computation what is needed to characterize answer sets? In other words, does every sequenceof sets of atoms starting with the ∅ and satisfying the principles (R), (P) and (C) result in an answer set? It is indeed thecase for positive programs.Proposition 2. Let P be a positive logic program. The result of every computation is equal to the least model of P , that is, the uniqueanswer set of P .Proof. Let (cid:9) Xi(cid:11)∞i=0 be a computation for P and M be the least model of P . Since P is positive, we have that T P is amonotone operator. By definition of a computation and the monotonicity of T P , Xi ⊆ T P ↑i. This implies that X∞ ⊆ M since(cid:7)∞i=0 T P ↑i. On the other hand, since M is the least model of P and X∞ is also a model of P , we have that M ⊆ X∞.M =This proves the proposition. (cid:2)However, in the case of arbitrary normal programs, there are computations that do not result in answer sets, as shownin the following example.300L. Liu et al. / Artificial Intelligence 174 (2010) 295–315Example 2. Let us consider the program P 2 containing the two rulesa ← not aa ← aThis program has no answer sets. The sequence X0 = ∅, X1 = {a}, X2 = {a}, . . . satisfies (R), (P) and (C), thus it is a compu-tation for P . However, X =i=0 Xi = {a} is not an answer set of P 2.(cid:7)∞It follows that the notion of computation defined by the principles (R), (P) and (C) is too broad to capture precisely thenotion of answer set. Let us reconsider Example 2. In that example, a ∈ X1 because the body of the first rule is satisfied bythe interpretation ∅. However, the body of the first rule is not satisfied in any set Xi for i (cid:3) 1. On the other hand, a ∈ Xi ,for i (cid:3) 2, since the body of the second rule is satisfied by Xi−1. Thus, the reason for the presence of a in the next revisionchanges between the first and the second step. This is the reason why the computation does not result in an answer set,even though it satisfies the principle (P).These considerations suggest that useful classes of computations can be obtained by requiring that not only atoms, butalso the reasons for including atoms persist. Intuitively, we would like to associate with each atom included in Xi a rule thatsupports the inclusion, and this rule should remain applicable from that point on. More formally, we state this principle asfollows:(Pr) Persistence of reasons: for every a ∈ X∞ there is a rule ra ∈ P (called the reason for a) whose head is a and whosebody holds in every Xi , i (cid:3) ia − 1, where ia is the least integer such that a ∈ Xia .It turns out that persistence of reasons is exactly what is needed to characterize answer sets of normal logic programs.Definition 2. Let P be a normal logic program. A computation (cid:9) Xi(cid:11)∞i=0 for P is persistent if it satisfies the principle (Pr).The next proposition shows that the principle of persistence of reasons is exactly what we need to capture the answer-setsemantics by computations.Proposition 3. Let P be a normal logic program. A set X is an answer set of P if and only if there is a persistent computation for Pwhose result is X .Let (cid:9) Xi(cid:11)∞Proof. Let X be an answer set of P . It is easy to see that the computation constructed in the proof of Proposition 1, whoseresult is X , is a persistent computation for P . That proves the “only-if” part of the proposition.i=0 be a persistent computation for P and X = X∞. First, we observe that for every i (cid:3) 0, Xi ⊆ T P X ↑i. We provethat by induction. The base case being evident, we proceed to the induction step and consider a ∈ Xi+1. By the persistenceof reasons, there is a rule ra and an integer ia (cid:2) i such that hd(ra) = a and X j |(cid:8) body(ra), for every j (cid:3) ia. It follows that for∈ P X , where with r Xevery default literal not b ∈ body(ra), b /∈ X . Thus, r Xa we denote the rule obtained from ra by removinga⊆ Xi , we have that a ∈ T P X ( Xi). By the inductiona ), ia (cid:2) i, and Xiaall default literals from the body of ra. Since Xiahypothesis and the monotonicity of T P X , a ∈ T P X (T P X ↑i). It follows that a ∈ T P X ↑(i + 1) and so, Xi+1 ⊆ T P X ↑(i + 1). That↑i = lfp(T P X ).completes the induction and shows that X ⊆On the other hand, since X is a supported model of P , we have that X is also a model of P X . Hence, lfp(T P X ) ⊆ X . Thus,X = lfp(T P X ), that is, X is an answer set of P , which proves the “if” part of the proposition and completes the proof. (cid:2)|(cid:8) body(r Xi=0 T P X(cid:7)∞In general, the operator ConclP offers several choices for revising the current interpretation Xi−1 to Xi during a compu-tation. A natural question is whether this freedom is needed, or whether we can restrict the principle (R) without loosingthe ability to characterize the answer sets of normal logic programs.Example 3. Let P 3 be the normal logic program:a ← not bc ← not be ← a, cf ← a, not cThis program has only one answer set M = {a, c, e}, that can be generated by the computation:∅,{a, c},{a, c, e}.L. Liu et al. / Artificial Intelligence 174 (2010) 295–315301In this computation, at each step i = 1, 2, we select Xi to be the greatest element of ConclP 3 ( Xi−1), which exists and isgiven by T P 3 ( Xi−1). Thus, the next element of the computation is the result of firing all applicable rules.On the other hand, selecting an element in ConclP 3 ( X) other than T P 3 ( X) can result in sequences that cannot be ex-tended to a computation. For example, the sequence ∅, {a}, {a, f } represents a potential computation since it satisfies the(R) and (P) principles. Yet, no possible extension of this sequence satisfies the (C) principle.This example indicates that interesting classes of computations can be obtained by restricting the operator ConclP . Sincefor every X we have that T P ( X) ∈ ConclP ( X), we could restrict the choice for possible revisions of X based on P to T P ( X)only. The class of computations obtained under this restriction is a proper subset of the class of computations. For instance,the program P 1 from Example 1 does not admit computations that revise X0 into X1 = T P ( X0). Thus, the class of suchcomputations is not adequate for the task of characterizing answer sets of normal logic program. We note, however, thatthey do characterize answer sets for certain special classes of logic programs, for instance, for stratified logic programs [1].To obtain a general characterization of answer sets by restricting the choices offered by ConclP ( X), we need to modifythe operator T P ( X). The first approach to computing answer sets, discussed in the introduction provides a clue: we need tomodify the notion of satisfiability used in the definition of T P ( X). Let M be an interpretation. We define the satisfiabilityrelation |(cid:8)M , between sets of atoms and conjunctions of literals, as follows: given a set of atoms S and a conjunction ofliterals F , the relation S |(cid:8)M F holds if S |(cid:8) F and M |(cid:8) F . That is, the satisfaction is based not only on S (i.e., the currentstate of the computation), but also on M (the “context” of the computation). We can define the context-based one-stepprovability operator T MP as follows:(cid:4)(cid:4) X |(cid:8)M body(r), for some r ∈ Phd(r)(cid:3)(cid:5).P ( X) ⊆ T P ( X) and, consequently, T MP ( X) ∈ ConclP ( X). Thus, we obtain the following result.P (X) =T MWe note that T MProposition 4. Let P be a normal logic program and M be an interpretation. A sequence (cid:9) Xi(cid:11)∞1, 2, . . . , is a computation for P if and only if it satisfies the principles (P) and (C).i=0, where Xi = T MP ( Xi−1) for i =Given an interpretation M, the sequence (cid:9) Xi(cid:11)∞P ( Xi−1), for i = 1, 2, . . . , is uniquely determined by M.Whenever the sequence satisfies the principles (P) and (C), we will refer to it as the M-computation. We observe that notall M-computations define answer sets, as illustrated in the following example.i=0 such that Xi = T MExample 4. Let P 4 be the normal logic program:a ← aa ← not bb ← aLet M = {a}. One can check that for each rule r ∈ P 4, M |(cid:8) body(r). Thus, for every set X of atoms, T MConsequently, ∅, {a}, {a, b}, . . . is an M-computation. However, {a, b} is not an answer set of P 4.P ( X) = T P ( X).The problem is that M-computations may fail to be persistent. In fact, the M-computation described in Example 4 doesnot satisfy the persistence of reasons principle. However, persistent M-computations, being special persistent computations,do result in answer sets. Moreover, every answer set is the result of a persistent M-computation.Proposition 5. Let P be a normal logic program. A set M ⊆ At is an answer set of P if and only if the M-computation is persistent andits result is M.Proof. If M is the result of a persistent X -computation, then M is, in particular, the result of a persistent computation.Thus, by Proposition 3, M is an answer set.On the other hand, let us assume that M is an answer set of P . We observe that for every set of atoms Y , T P (M)(Y ) ⊆T P M (Y ). Moreover, if Y ⊆ M, the converse inclusion holds, too. Indeed, if Y ⊆ M and a ∈ T P M (Y ) then there is a rule r ∈ Psuch that hd(r) = a, M |(cid:8) body(r), and Y |(cid:8) body(r M ) (where r M denotes the rule obtained from r by removing from body(r)all default literals). In particular, it follows that r ∈ P (M) and a ∈ T P (M)(Y ). The two inclusions together imply that if Y ⊆ M,then T P (M)(Y ) = T P M (Y ).We now observe that T MP (Y ) = T P M (Y ). It follows that the computationconstructed in the proof of Proposition 1 is an M-computation and it is persistent (Proposition 3). Since its result is M, theassertion follows. (cid:2)P (Y ) = T P (M)(Y ). Thus, for every Y ⊆ M, T MAn even stronger result can be proved, in which answer sets are characterized by a proper subclass of persistent M-computations. We call an M-computation self-justified if its result is M. In general, the class of self-justified M-computationsis a proper subclass of M-computations. Indeed, as shown in Example 4, there are M-computations that are not persistent302L. Liu et al. / Artificial Intelligence 174 (2010) 295–315while, as we prove below, self-justified M-computations satisfy the persistence of reasons property. We use that fact toshow that self-justified computations do indeed characterize answer sets.Proposition 6. Let P be a normal logic program. A set of atoms M is an answer set of P if and only if the M-computation is self-justified.Proof. In the proof of Proposition 5, we showed that if M is an answer set of P , then it generates an M-computation withthe result M, which proves one direction of the proposition.Conversely, let M be a set of atoms that determines a self-justified M-computation and let (cid:9) Xi(cid:11)∞i=0 is a computation, to conclude the desired result it suffices to show that (cid:9) Xi(cid:11)∞i=0 be that computation.i=0 is persistent—then the resultSince (cid:9) Xi(cid:11)∞will be immediate from Proposition 3.Thus, let a ∈ M, and let i be the least integer such that a ∈ Xi . It follows that i (cid:3) 1 and a ∈ T MP ( Xi−1). Thus, there is arule r ∈ P (M) such that M |(cid:8) body(r) and Xi−1 |(cid:8) body(r). For every j (cid:3) i, Xi−1 ⊆ X j ⊆ M. Thus, X j |(cid:8) body(r) and so thepersistence of the computation follows. (cid:2)We can summarize our discussion in this section as follows. Our goal was to characterize answer sets of normal logicprograms in terms of computations. More specifically, taking two ways of computing answer sets as the starting point,we introduced three characterizations of answer sets in terms of computations: persistent computations, persistent M-computations, and self-justified M-computations, with each subsequent class being a proper subclass of the preceding one.In Sections 5 and 6, we will show how to generalize the classes of computations discussed here to the case of programswith constraints. We will use these generalized computations to define and characterize answer sets of such programs.4. Programs with abstract constraints: Basic definitionsWe will recall here some basic definitions concerning programs with constraints [29,31,25]. As before, we fix a countableinfinite set At of propositional atoms. An arbitrary abstract constraint (or, simply, a constraint) is an expression A = ( X, C),where X ⊆ At is a finite set, and C ⊆ P( X)—where P( X) denotes the powerset of X . The set X is called the domain of A,while the elements of C are called satisfiers of A. Given a constraint A = ( X, C), we denote X with Adom and C with Asat.Intuitively, the sets in Asat are precisely those subsets of Adom that satisfy the constraint.It is common to recognize special types of constraints:• A constraint is inconsistent if it has no satisfiers. We will distinguish a special inconsistent constraint, (∅, ∅), and wewill denote it by ⊥.• A constraint A is monotone if, for every X ∈ Asat and for every Y such that X ⊆ Y ⊆ Adom, we have that Y ∈ Asat.• A constraint A is convex if for every X, Y ∈ Asat and for every Z such that X ⊆ Z ⊆ Y , we have that Z ∈ Asat.Constraints are building blocks of rules and programs. A rule is an expressionA ← A1, . . . , Ak(2)where A, A1, . . . , Ak are constraints. A constraint program (or a program) is a collection of rules. A program is monotone(convex) if every constraint occurring in it is monotone (convex).Given a rule r of the form (2), the constraint A is the head of r and the set of constraints { A1, . . . , Ak} is the bodyof r; sometimes we view the body of a rule as the conjunction of its constraints. Following the notation introduced earlier,we denote the head and the body of r with hd(r) and body(r), respectively. We define the headset of r (hset(r)) to be thedomain of the head of r, that is, hset(r) = hd(r)dom. For a set of rules P , we define hset(P ) =We view subsets of At as interpretations. We say that M ⊆ At satisfies a constraint A, denoted by M |(cid:8) A, if M ∩ Adom ∈Asat. For a rule r, M satisfies r, denoted by M |(cid:8) r, if M satisfies hd(r) or M does not satisfy some constraint in body(r). Aninterpretation M is a model of a program P if it satisfies all rules in P .r∈P hset(r).(cid:7)Let M be an interpretation. A rule is M-applicable if M satisfies every constraint in body(r), i.e., M |(cid:8) body(r). As inSection 2, we denote with P (M) the set of all M-applicable rules in P . Let P be a program. A model M of P is supportedif M ⊆ hset(P (M)). Observe that, from this definition, one can conclude that if a model M is supported then M will satisfyhd(r) for every rule r applicable in M.Let P be a program and M a set of atoms. A set X is non-deterministically one-step provable from M by means of P , ifX ⊆ hset(P (M)) and X |(cid:8) hd(r) for every rule r ∈ P (M). The non-deterministic one-step provability operatorP : P(At) → PT nd(cid:2)(cid:6)P(At)for a program P is an operator where T ndby means of P , for every M ⊆ At. In other words,(cid:3)P (M) =T ndX: X ⊆ hset(cid:2)(cid:6)P (M)(cid:2), ∀r ∈ P (M).(cid:6)(cid:5)X |(cid:8) hd(r).P (M) consists of all sets that are non-deterministically one-step provable from MObserve that, for every X ∈ T ndP (M), X is a model of P (M).L. Liu et al. / Artificial Intelligence 174 (2010) 295–315303For an arbitrary atom a ∈ At, the constraints ({a}, {{a}}) and ({a}, {∅}) are said to be elementary. Since ({a}, {{a}}) has thesame models as a, we identify and denote the constraint ({a}, {{a}}) simply with a. For analogous reasons, we identify theconstraint ({a}, {∅}) with the literal not a.Given a normal logic program P and a rule r ∈ P , we denote with C(r) the rule obtained by replacing every positive atoma in r with the constraint ({a}, {{a}}), and replacing every literal not a in r with the constraint ({a}, {∅}). Let C(P ) = {C(r) |r ∈ P }. We call C(r) and C(P ) the constraint representation of r and P , respectively. It is easy to see that C(P ) is a convexprogram. It is possible to show that supported models of P coincide with supported models of C(P ), and answer sets ofP coincide with answer sets of C(P )—according to the definition of answer sets presented by Liu and Truszczy ´nski [25]. Inother words, programs with constraints are sufficient to express normal logic programs. We conclude this section with anexample illustrating the different concepts related to constraints.Example 5. Consider the program P{a, b}, {a, b, c}, {c}←{b}, {c}, {b, c}(cid:5)(cid:6)(cid:2)(cid:5)(cid:6)(cid:2)←(cid:3)(cid:5)(cid:6){a, b},(cid:3)∅, {a, b}(cid:5)(cid:6){a, b},∅, {a, b}(cid:3)(cid:3)(cid:2)(cid:2){a, b, c},{a, b, c},a ← bb ← ac ←r1:r1:r2:r3:r4:We have that:• all constraints occurring in P are consistent;• ({a}, {{a}}) (written as a in rules r2 and r3) is a monotone constraint;• ({a, b, c}, {{b}, {c}, {b, c}}) is not a monotone constraint; however, it is a convex constraint;• ({a, b}, {∅, {a, b}}) is neither monotone nor convex;• hset(r1) = hset(P ) = {a, b, c} and hset(r2) = {a};• the set M = {a} satisfies the head of r1 but does not satisfy the body of r1;• for M = {a}, the set of M-applicable rules is {r3, r4}, i.e., P ({a}) = {r3, r4};• the set {a} is not a model of the program since it does not satisfy r3;• the set {c} is a model of the program and so is {a, b, c}, both are supported;• for M = ∅, P (M) = {r1, r4}, which implies that T ndP (M) = {{c}, {b, c}}.5. Computations for programs with constraintsIn this section we extend the notion of a computation to programs with constraints, and use computations to define ageneralization of the answer-set semantics for such programs. Our approach is based on exploiting the intuitions that wehave developed in Section 3 for the case of normal logic programs.In order to define computations for programs with constraints, we consider the principles identified in Section 3. Thekey step is to generalize the revision principle. For normal programs, this principle was based on sets of atoms grounded ina set of atoms X (i.e., the current interpretation) and P . We will now extend this concept to programs with constraints.Definition 3. Let P be a program with constraints and let X ⊆ At be a set of atoms. A set Y is grounded in X and P if thereexists a set of rules Q ⊆ P ( X) such that Y ∈ T ndQ ( X). We denote by ConclP ( X) the collection of all sets Y grounded in Xand P .The intuition is analogous to the one used in the case of normal logic programs. There, a set Y is grounded in X and anormal logic program P if Y can be justified by means of some X -applicable rules in P . That is, Y ∈ ConclP ( X) if and only ifY = T Q ( X) for some Q ⊆ P ( X). Thus, the definition of ConclP ( X) for a constraint program P indeed generalizes the earlierdefinition.With this definition of ConclP ( X), the principle (R) lifts without any changes to program with constraints—we will refer(cid:17)). The same is true for the principle (P), now(cid:17)). An appropriate generalization of the principle (C) can be expressed in terms of supported models asto the version of principle (R) in the case of program with constraints as (Rreferred to as (Pfollows:(cid:17)) Convergence: X∞ is a supported model of P , that is, X∞ ∈ T nd(CP ( X∞).Finally, the principle (Pr) can be generalized, as well. At a step i of a computation that satisfies (Relement of ConclP ( Xi−1). From the definition of ConclP ( Xi−1), there is a program P i−1 ⊆ P ( Xi−1) such that Xi ∈ T ndP i−1(cid:17)) as follows:Each such program can be viewed as a reason for Xi . We can now state the generalized principle (Pr(cid:17)), we select as Xi an( Xi−1).304L. Liu et al. / Artificial Intelligence 174 (2010) 295–315(cid:17)) Persistence of reasons: There is a sequence of programs (cid:9)P i(cid:11)∞i=0 such that for every i (cid:3) 0, P i ⊆ P i+1, P i ⊆ P ( Xi), and(PrXi+1 ∈ T ndP i( Xi).The definition implies that for every j (cid:3) i, P i ⊆ P j and P i ⊆ P ( X j). That is, the principle requires that rules used atstep i “persist” ( P i ⊆ P j , for j (cid:3) i) and are applicable at all successive steps ( P i ⊆ P ( X j), for j (cid:3) i).Having generalized the principles (R), (P), (C) and (Pr) to define (R(cid:17)) for the class of programs withconstraints, we can now extend the concept of a computation by literally lifting the definitions developed for the case ofnormal logic programs. However, the resulting notion has some undesired properties, as shown in the next example.(cid:17)) and (Pr(cid:17)), (P(cid:17)), (CExample 6. Let P 5 be the program:(cid:3)∅, {a, b}{a, b}, {{a, b}}{a, b},←(cid:2)(cid:2)(cid:6)(cid:5)(cid:6)The constraint in the body is satisfied by interpretations where a and b are either both true or both false. The head of therule is satisfied only in the case both a and b are true.It is easy to see that the sequence ∅, {a, b}, {a, b}, . . . satisfies the properties (R(cid:17)). On the other hand,this outcome is not satisfactory: a and b are in the result of this computation only because they “self-support” themselves.Given that {a, b} is the result of the sequence, the only set ensuring that the rule ({a, b}, {{a, b}}) ← ({a, b}, {∅, {a, b}})remains applicable independently of what may happen later in the computation is {a, b} itself. Indeed, ∅ (the only othersatisfier of the body of the rule) is too weak due to the non-monotonicity of the constraint. The empty set might potentiallybe revised into {a} or {b} (not possible here, but a priori possible if other rules were present in the program). For each ofthese sets the rule would not be applicable and persistence of reasons would be violated.(cid:17)) and (Pr(cid:17)), (P(cid:17)), (CTo better present this point let us contrast this situation with the case of a logic program P 6 consisting of the followingrules (in a syntax resembling that of Smodels):a ←b ← 1{a, b, c}2The body of the second rule is satisfied by any interpretation that contains at least one and at most two of a, b, and c. The(cid:17)). Also in this case, it may look as if b is self-sequence ∅, {a}, {a, b}, {a, b}, . . . satisfies the properties (Rsupported. But, in fact it is not. Given that the result of the computation is {a, b}, once we establish a in the computation,the second rule will remain applicable no matter how the current state is revised (as long as the revision does not gobeyond {a, b}). In other words, in view of the second rule, for b to hold it suffices to know a, and b really depends on a andnot on itself.(cid:17)) and (Pr(cid:17)), (P(cid:17)), (CThe key behind this is the convexity of the constraint 1{a, b, c}2, which ensures that there are no “gaps” between thederivation of the atom a, which is a trigger for the rule, and the result of the computation ({a, b}). Every set in betweenis guaranteed to “activate” the rule by satisfying its body. This is exactly the property that was missing in the case ofprogram P 5.Our example suggests that, in the case of programs with arbitrary constraints, the four properties we introduced do notcapture all that is needed for a computation to give rise to a reasonable notion of an answer set. We also need to requirethat the result of the computation is “well-founded”, that is, that every element derived in the process remains founded inelements derived earlier throughout the rest of the computation.In order to formalize this concept, we need to introduce some additional definitions. Let A be a constraint and X andY a set of atoms. The set Y is an X -trigger for A if, for every set Z such that Y ⊆ Z ⊆ X , we have that Z |(cid:8) A. If r is arule, Y is an X -trigger for r if it is an X -trigger for every constraint A in the body of R; i.e., for every set Z , such thatY ⊆ Z ⊆ X , we have that Z |(cid:8) body(r). Thus, if Y is an X -trigger for r, then as long as a computation does not go beyond X ,Y is a sufficient justification for applying r, and atoms derived based on r can be regarded as founded only in Y . This ideais captured by the following property:(FPr) Founded persistence of reasons: There is a sequence of programs (cid:9)P i(cid:11)∞P ( Xi), Xi+1 ∈ T ndP i( Xi), and each rule in P i has an X∞-trigger contained in Xi .i=0 such that for every i (cid:3) 0, P i ⊆ P i+1, P i ⊆Thus, the principle of founded persistence of reasons simply strengthens that of persistence of reasons by the founded-ness requirement.We now use the principles introduced above to define several types of computations for programs with arbitrary con-straints.Definition 4. Let P be a program with constraints. A sequence of interpretations (cid:9) Xi(cid:11)∞(cid:17)) and (Cand the sequence satisfies the principles (RA computation is founded if it satisfies the principle (FPr).(cid:17)). A computation is persistent if it satisfies the principle (Pri=0 is a computation for P if X0 = ∅(cid:17)).(cid:17)), (PL. Liu et al. / Artificial Intelligence 174 (2010) 295–315305Persistent computations are computations. As in the case of normal programs, the converse is not true in general. Letus consider the program C(P 2), where P 2 is the normal logic program from Example 2. The sequence ∅, {a}, {a}, . . . is acomputation but not a persistent one. It is not a coincidence that we could derive a counterexample from a normal logicprogram. We have the following general result.Proposition 7. Let P be a normal logic program. The class of computations for P , as defined in Section 3, coincides with the class ofcomputations of C(P ), as defined in this section. Similarly, the class of persistent computations for P , as defined in Section 3, coincideswith the class of persistent computations for C(P ) as defined in this section.Proof. It is straightforward to verify that the sequence (cid:9) Xi(cid:11)∞defined in Section 3) if and only if (cid:9) Xi(cid:11)∞computation in P and in C(P ) coincide.i=0 satisfies properties (Ri=0 satisfies properties (R(cid:17)), (P(cid:17)) and (C(cid:17)), (P(cid:17)) with respect to P (as(cid:17)) with respect to C(P ). Thus, the notions of(cid:17)) and (CLet us show that the same result holds for the case of persistent computations. Let us assume that (cid:9) Xi(cid:11)∞i=0 satisfies the(cid:17)) for P (as defined in Section 3). For each atom a ∈ X∞, let ra denote the rule satisfying the condition of(cid:17)). Let P i = {C(ra) | a ∈ Xi+1}. From the persistence of reasons for P , P i ⊆ P i+1, P i ⊆ P ( Xi), and { Xi+1} =(cid:17)) for C(P ), as defined in thisi=0 is a sequence of subprograms of C(P ) satisfying the conditions of (Pr( Xi). Hence, (cid:9)P i(cid:11)∞property (Prpersistence in (PrT ndP isection.Conversely, let us assume that (cid:9) Xi(cid:11)∞i=0 satisfies the property (Pr(cid:17)) for C(P ) (as defined in this section) and let (cid:9)P i(cid:11)∞i=0 bethe sequence of subprograms of C(P ) that demonstrates that.For each a ∈ X∞, let i be the index such that a ∈ Xi+1 \ Xi . Because Xi+1 ∈ T ndP i( Xi), we can conclude that there existssome rule ra ∈ P such that C(ra) ∈ P i and hset(ra) = {a}. Since P i ⊆ C(P )( Xi), we have Xi |(cid:8) body(ra) and hd(ra) = a. Themonotonicity of (cid:9)P i(cid:11)∞i=0 implies that C(ra) ∈ P j for j (cid:3) i. The condition P j ⊆ C(P )( X j) implies that C(ra) is applicable inevery X j for j (cid:3) i. Thus, ra is applicable in every X j for j (cid:3) i. Hence, (cid:9) Xi(cid:11)∞i=0 is a persistent computation for P , accordingto the definition in Section 3. (cid:2)For normal logic programs, we do not need to impose the principle of founded persistence explicitly. It is possibleto show that, in the case of normal logic programs, persistent computations are always founded.3 Thus, for normal logicprograms, the two classes of computations coincide. In fact, this property holds for a larger classes of programs—the classof programs with convex constraints, which includes normal logic programs or, more precisely, programs of the form C(P ),where P is a normal program.Proposition 8. Let P be a program with convex constraints. A computation for P is founded if and only if it is persistent.Proof. From the previous observations, we know that each founded computation is persistent. Thus, we need to show thatevery persistent computation for P is founded. Let (cid:9) Xi(cid:11)∞i=0 be a sequenceof programs demonstrating that (cid:9) Xi(cid:11)∞i=0 be a persistent computation for P and let (cid:9)P i(cid:11)∞Let r ∈ P i (for some i (cid:3) 0). It follows that r ∈ P ( Xi), that is Xi |(cid:8) body(r). From the persistence of reasons, r ∈ P ( X j),for every j (cid:3) i, and, because of the finiteness of the domains of constraints, r ∈ P ( X∞). Thus, X∞ |(cid:8) body(r). Since allconstraints in the body of r are convex, for every Z such that Xi ⊆ Z ⊆ X∞, Z |(cid:8) body(r). It follows that Xi is an X∞-triggerfor r. Consequently, the computation (cid:9) Xi(cid:11)∞i=0 satisfies the property (Pri=0 is founded. (cid:2)(cid:17)).However, in the general case of programs with arbitrary constraints, the class of persistent computations is a propersubclass of the class of founded computations. The inclusion follows directly from the definition. The program P 5 fromExample 6 shows that it is proper. For programs with arbitrary constraints, we use founded computations as the basis forthe generalization of the answer-set semantics.Definition 5. Let P be a program with constraints. A set X is an answer set of P if there is a founded computation for Pwhose result is X .Propositions 7 and 8 imply that our concept of an answer set, as specified by Definition 5, generalizes that for normallogic programs.Corollary 1. Let P be a normal logic program. A set X ⊆ At is an answer set of P if and only if X is an answer set of C(P ).Proof. We have that X is an answer set of P if and only if there is a persistent computation for P whose result is X . FromProposition 7, it is the case if and only if there is a founded computation for C(P ) whose result is X , that is, if and only ifX is an answer set of C(P ). (cid:2)3 We assume a natural definition of founded persistence for normal logic programs based on the correspondence between P and C(P ).306L. Liu et al. / Artificial Intelligence 174 (2010) 295–315We can also show that this definition of answer set generalizes the notion of answer set for programs with convexconstraints (proposed by Liu and Truszczy ´nski [25]), a property that we formally state and prove later in the paper.We conclude this section by observing that we have determined so far four distinct classes of models of programs withconstraints: answer sets, models obtained via persistent computations, models obtained as results of computations, andsupported models. Each class of models is a subclass (in general, proper) of the successive one. The role of the last threeclasses of models, and their properties require further studies, that are beyond the scope of this paper.We also note that, thanks to the principle (C(cid:17)), supported models form indeed a superclass of the class of the results ofcomputations. However, not all supported models of programs can be obtained as the results of computations. For instance,{a} is a supported model of the program C(P ), where P = {a ← a}, but there is no computation for C(P ) with the result {a}.To capture supported models as the results of some bottom-up process, the notion of a computation has to be broadenedby relaxing some of the key principles. In the following section, we show one way in which that goal can be accomplished.6. Computations and quasi-satisfiability relationsThe notion of a computation discussed so far makes use of the non-deterministic operator ConclP to revise the interpre-tations occurring in a computation. As we mentioned earlier, the use of ConclP provides a wide range of choices for revisinga state of a computation, considering all the subsets of applicable rules.In this section, we will study sequences of interpretations that can be generated by narrowing down the set of choicesallowed in ConclP ( X) as possible revisions of X . In the case of normal logic programs, we accomplished this goal by meansP , based on the satisfiability relation |(cid:8)M . In that case, the whole computation is determined just by theof an operator T Mchoice of M. Thus, the only non-deterministic decision is the selection of M. Once that is done, there is no non-determinismleft. We proved that M is an answer set of a logic program P if and only if M is the result of the computation it generates.In other words, the computation is context-dependent. This idea has been studied in the context of default logic by Marekand Truszczy ´nski [32]. We will now generalize that approach to the case of programs with constraints.Definition 6. A sequence (cid:9) Xi(cid:11)∞and (C(cid:17)) and X0 = ∅.i=0 is a weak computation for a program with constraints P if it satisfies the properties (P(cid:17))Thus, weak computations are sequences that do not rely on a program P when moving from step i to step i + 1. Next, wewill define a broad class of weak computations that, at least to some degree, restores the role of P as a revision mechanism.Let (cid:18) be a relation between sets of atoms (interpretations) and abstract constraints. We extend the relation (cid:18) to the caseof conjunctions (or sets) of constraints as follows: X (cid:18) { A1, . . . , Ak} if X (cid:18) Ai , for every i, 1 (cid:2) i (cid:2) k. This relation is intended torepresent some concept of satisfiability of constraints and their conjunctions. We will call such relations quasi-satisfiabilityrelations. They will later allow us to generalize the relation |(cid:8)M .For a quasi-satisfiability relation (cid:18), we define(cid:18)P(X) =(cid:4)(cid:5)(cid:4) X (cid:18) body(r)(cid:3)r ∈ P(cid:18)( X) is the set of all rules in P that are applicable with respect to X under the satisfiability relation (cid:18)..(cid:3)In other words, PNext, we defineT nd;(cid:18)In other words, T nd;(cid:18)similarly to T nd(X) =PPY : Y ⊆ hset(cid:2)(cid:18)(cid:6)(X)P, ∀r ∈ P(cid:18)(cid:2)(X).(cid:6)(cid:5)Y |(cid:8) hd(r).( X) consist of all sets Y ⊆ hset(P(cid:18)( X)) such that Y |(cid:8) hd(r), for every r ∈ P(cid:18)( X). Thus, T nd;(cid:18)PworksP , except that rules in P(cid:18)( X) are “fired” rather than those in P ( X).Definition 7. Let (cid:18) be a quasi-satisfiability relation. A weak computation (cid:9) Xi(cid:11)∞T nd;(cid:18)( Xi), for i (cid:3) 1.Pi=0 is a weak (cid:18)-computation for P if Xi+1 ∈Since we do not impose any particular properties on the quasi-satisfiability relation (cid:18),it is not guaranteed that( X) ⊆ ConclP ( X). Thus, weak (cid:18)-computations are not guaranteed to be computations. There is, however, a simpleT nd;(cid:18)sufficient conditions guaranteeing that weak (cid:18)-computations are computations.PWe say that a quasi-satisfiability relation (cid:18) is a sub-satisfiability relation if, for every X ⊆ At and every abstract con-(cid:18)( X) ⊆ P ( X). This property and thestraint A, X (cid:18) A implies X |(cid:8) A. Observe that if (cid:18) is a sub-satisfiability relation then Pappropriate definitions imply that(X) = T nd;(cid:18)P (cid:18)( X)(X) = T ndP (cid:18)( X)(X).T nd;(cid:18)P(3)We can observe that the relation |(cid:8)M considered in Section 3 is a sub-satisfiability relation.Proposition 9. Let P be a program with constraints. If (cid:18) is a sub-satisfiability relation then for every X ⊆ At, we have that T nd;(cid:18)ConclP ( X).P( X) ⊆L. Liu et al. / Artificial Intelligence 174 (2010) 295–315307Proof. Consider Y ∈ T nd;(cid:18)P (cid:18)( X)( X). Thus, it follows that Y ∈ ConclP ( X). (cid:2)T ndP( X). Since (cid:18) is a sub-satisfiability relation, P(cid:18)( X) ⊆ P ( X). Moreover, from Eq. (3), T nd;(cid:18)P( X) =The following corollary is an obvious consequence of Proposition 9.Corollary 2. If (cid:18) is a sub-satisfiability relation, then every weak (cid:18)-computation is a computation.Thus, from now on, if (cid:18) is a sub-satisfiability relation, we will write (cid:18)-computation interchangeably with weak (cid:18)-com-putation.We recall that if P is a normal logic program, then M is an answer set of P if and only if M is the result of anM-computation for P . We will now use weak (cid:18)-computations and (cid:18)-computations to generalize the notion of an M-com-putation to programs with constraints. To this end, we extend the approach proposed and studied by Son et al. [42]. Ourmethod requires a mapping fX . Thus, we explore thepossibility that the quasi-satisfiability relation can change as a function of the target model X we are trying to achieve.Later in this section, we will explore one particular mapping f ; alternative mappings of interest are explored in a latersection.that assigns to a set X of atoms a quasi-satisfiability relation (cid:18) fDefinition 8. Let P be a program with constraints and f a mapping assigning to every set X of atoms a quasi-satisfiabilityrelation (cid:18) fX -computationfor P . A set of atoms X is an f -model of P if X is the result of a self-justified weak (cid:18) fX -computation for P and X is the result of C , then C is a self-justified weak (cid:18) fX . If C is a weak (cid:18) fX -computation for P .The definition of an f -model is sound. Since weak computations satisfy the property (C(cid:17)), their results are indeed modelsof P . In fact, they are supported models. Several interesting classes of models of programs with constraints can be describedin terms of f -models by specializing the mapping f . We will demonstrate the flexibility of the approach presented abovelater in the paper.In order to specialize the general approach of self-justified weak computations so that it might generalize the notion ofan answer set, we need to identify mappings f that ensure that self-justified weak computations are computations—i.e.,they satisfy the revision principle—and are founded. We have already seen that if (cid:18) fX is a sub-satisfiability relation thenweak (cid:18) fX -computations). We will now seek conditions guaranteeing thefoundedness of (cid:18) fX -computations are computations (referred to as (cid:18) fX -computations.We first address the weaker property of persistence of reason (Pr(cid:17)). The next proposition follows from Eq. (3).Proposition 10. Let (cid:18) be a sub-satisfiability relation and let C = (cid:9) Xi(cid:11)∞i = 0, 1, . . . , Xi (cid:18) A implies that Xi+1 (cid:18) A, then C is persistent.i=0 be a (cid:18)-computation. If for every constraint A and everyProof. Since (cid:18) is a sub-satisfiability relation, PP i = P(cid:18)( Xi) satisfies the persistence condition. (cid:2)(cid:18)( X) ⊆ P ( X). It follows from Eq. (3) and Definition 7 that the sequenceWe will now show that the sub-satisfiability relation proposed by Son et al. [42] gives rise to founded computations.X A if for each set Z such that Y ⊆ Z ⊆ X , Z |(cid:8) A (or equivalently,is a sub-satisfiability relation. Thus, it defines computations. Secondly, if C is aX satisfies the assumptions of Proposition 10. Using the terminologyX A if Y is an X -trigger for A. The connection to theGiven a set X of atoms we define (cid:18)sptZ ∩ Adom ∈ Asat). It is easy to see that (cid:18)sptX -computation, then it is persistent as the relation (cid:18)spt(cid:18)sptintroduced earlier, we can restate the definition of (cid:18)sptdefinition of founded persistence is evident and, not surprisingly, self-justified (cid:18)sptX as follows: Y (cid:18)sptX as follows: Y (cid:18)sptXX -computations are founded.Proposition 11. Let P be a program with constraints. If C is a self-justified (cid:18)sptX -computation then it is a founded computation.Proof. To simplify notation, we write (cid:18) for (cid:18)spti=0 be the self-justified (cid:18)-computation. We already(cid:17))(cid:18)( Xi), i = 0, 1, . . . , to show that the property (Prargued that C is a persistent computation by using the sequence P i = Pholds. We will now show that every rule in P i has an X -trigger contained in Xi . To this end, let r ∈ P i . It follows thatXi (cid:18) body(r). By the definition of (cid:18) (= (cid:18)sptX ), if Xi ⊆ Z ⊆ X , then Z (cid:18) body(r). Thus, Xi is an X -trigger for r. Consequently, C isfounded. (cid:2)X in the proof. Let C = (cid:9) Xi(cid:11)∞Not every founded computation C is a self-justified (cid:18)sptX -computation. This can be seen in the following example.308L. Liu et al. / Artificial Intelligence 174 (2010) 295–315Example 7. Consider the program P (remember that a is shorthand for ({a}, {{a}})):a ←b ←c ←(cid:2)(cid:3){a, b},∅, {a, b}(cid:5)(cid:6)We have that ∅, {a}, {a, b}, {a, b, c}, {a, b, c} . . . is a founded computation for P which is not a self-justified (cid:18)sptbecause it does not end in the set {a, b}.{a,b}-computationAlthough not every founded computation is a self-justified (cid:18)sptX -computation. Thus, the results of self-justified (cid:18)sptfied (cid:18)sptwe have the following result:X -computation, for every answer set X there is a self-justi-X -computations for P are precisely the answer sets of P . Formally,Proposition 12. Let P be a program with constraints and let X be an answer set for P . Then there is a self-justified (cid:18)sptfor P .X -computationProof. Also in this proof, to simplify the notation we write (cid:18) for (cid:18)sptX and let (cid:9)P i(cid:11)∞i=0 be a sequence of programs demonstrating that (FPr) holds.X . Let (cid:9) Xi(cid:11)∞i=0 be a founded computation with the resultLet us define Y 0 = ∅ and Y i+1 = hset(Pmore, X |(cid:8) P and so, X |(cid:8) PSince hset(r) ⊆ hset(PThus, (cid:9)Y i(cid:11)∞i=0 is a (cid:18)-computation for P .(cid:18)(Y i). By the definition of (cid:18) (= (cid:18)spt(cid:18)(Y i)), Y i+1 |(cid:8) hd(r). It follows that Y i+1 ∈ T nd(cid:18)(Y i)) ∩ X , for i = 0, 1, . . . . It follows that for every i = 0, 1, . . . , Y i ⊆ X . Further-(cid:18)(Y i), X |(cid:8) body(r). Thus, X |(cid:8) hd(r).(Y i) = T nd(Y i).X ), for every rule r ∈ PP (cid:18)(Y i )(Y i). Since T nd;(cid:18)P (cid:18)(Y i )(Y i), Y i+1 ∈ T nd;(cid:18)PPMoreover, for every i, Xi ⊆ Y i . We prove this claim by induction. For the base case, we note that X0 = ∅ = Y 0. Let us(cid:18)(Y i). Indeed,now assume that Xi ⊆ Y i . We have Xi+1 ∈ T ndP iif r ∈ P i , then r has an X -trigger U r such that U r ⊆ Xi . It follows that for every Z such that U r ⊆ Z ⊆ X , Z |(cid:8) body(r). Thus,(cid:18)(Y i).for every Z such that Y i ⊆ Z ⊆ X , Z |(cid:8) body(r) and so, r ∈ P( Xi). Since Xi ⊆ Y i , foundedness of (cid:9) Xi(cid:11)∞i=0 implies that P i ⊆ PClearly, P i ⊆ Pturn, implies that(cid:18)(Y i) implies that Xi+1 ⊆ hset(P(cid:7)∞i=0 Y i = X . It follows that (cid:9)Y i(cid:11)∞(cid:18)(Y i) ∩ X) = Y i+1. This completes the proof of the claim. The claim, ini=0 is a self-justified (cid:18)sptX -computation. (cid:2)7. DiscussionIn this section, we discuss several additional properties of the semantics of answer sets we introduced in the paper. Inparticular, we present two alternative characterizations of the semantics—one based on the concept of strong groundedness,which is based on the existence of a ranking of atoms, and the second based on program transformation. Finally, we willdiscuss some alternative proposals for semantics of programs with constraints (or aggregates).7.1. Strong groundedness of answer setsOne of the key properties of answer sets of normal logic programs is that they are not self-supported. Namely, we havethe following property that can be derived from more general results (Theorem 1) proposed by Erdem and Lifschitz [12].Theorem 1. Let P be a normal logic program and M a model of P . Then M is an answer set of P if and only if there is a ranking kassigning non-negative integers to atoms in M, so that for every atom a ∈ M, there is a rule r ∈ P (M) such that hd(r) = a and for everyb ∈ pos(r), we have that k(a) > k(b).We will now extend this property to the case of programs with arbitrary constraints and the concept of an answer setwe introduced here. The notion of an M-trigger and the property of founded persistence of reasons are critical. We recallthat a set X is an M-trigger for a rule r precisely when for every Y , X ⊆ Y ⊆ M, Y |(cid:8) body(r). In other words, if X is anM-trigger for r, having computed X guarantees that the rule will remain applicable later in the computation as long as thecomputation “stays” within M. In such a case, we say that X is an M-justification for every atom a ∈ hset(r) ∩ M. We notethat a rule can have several M-triggers and each of them can be used as an M-justification for the elements in the headsetof the rule.We say that a model M of a program with arbitrary constraints is strongly grounded if there is a ranking of atoms in Msuch that each atom has an M-justification consisting entirely of atoms with strictly lower ranks. We will show that answersets are precisely those models that are strongly grounded. We start with an example.Example 8. Let us consider the following program P 6:L. Liu et al. / Artificial Intelligence 174 (2010) 295–315309(cid:3)∅, {a, b}(cid:5)(cid:6){a, b},(cid:2)a ←a ← bb ← aClearly, M = {a, b} is a model of P 6. It is easy to see that M is not strongly grounded. Indeed, the only M-justificationfor the atom a provided by the first rule is {a, b}—the other satisfier, ∅, is not an M-trigger for that rule as some of itssupersets (e.g., {a}) do not satisfy the body of the rule. The only M-justification for a provided by the second rule is {b} andthe only M-justification for b (it is provided by the third rule) is a. Thus, it is clear that no ranking necessary for stronggroundedness exists. One can also verify that P 6 has no answer sets.The next theorem relates the notions of answer sets and strongly groundedness.Theorem 2. A model M of a program with arbitrary constraints is an answer set of P if and only if it is strongly grounded.Proof. First, let us assume that M is an answer set of P . It follows that there is a founded computation (cid:9) Xi(cid:11)∞X∞ = M. Let a ∈ M. We define k(a) as the minimum i such that a ∈ Xi . Since M =for every atom a ∈ M.i=0 such thati=0 Xi , the value k(a) is well defined(cid:7)∞We will show that the ranking k is a witness of M being strongly grounded. To this end, we need to show that everyatom in M has an M-justification. Let a ∈ M. Since (cid:9) Xi(cid:11)∞i=0 is founded, there is a rule r and a set of atoms Y such thathd(r) = a, Y ⊆ Xi−1 and Y is an M-trigger for r. We observe that for every b ∈ Y , k(b) (cid:2) i − 1. Thus, Y is an M-justificationfor a.Conversely, let us assume that M is a strongly grounded model of P . We will show that M is an answer set by con-structing a founded computation (cid:9) Xi(cid:11)∞i=0 such that M = X∞. Let k be a ranking that witnesses strong groundedness of M.We define X0 = ∅. We then proceed inductively as follows. We define P i , i (cid:3) 0, to consist of all rules for which Xi is anM-trigger. We define Xi+1, i (cid:3) 0, by setting Xi+1 = hset(P i) ∩ M.Directly from the definition, it follows that for every i (cid:3) 0, Xi ⊆ M and P i = P i( Xi) = P i(M). Since M is a model of P ,i=0 satisfies( Xi) (and Xi+1 ∈ ConclP ( Xi)) and so, (cid:9) Xi(cid:11)∞we have that for every r ∈ P i , hset(P i) ∩ M |(cid:8) hd(r). Thus, Xi+1 ∈ T ndP ithe principle (RNext, we will prove that (cid:9) Xi(cid:11)∞(cid:17)), that is, that for every i (cid:3) 0, Xi ⊆ Xi+1. We proceed byinduction. The inclusion X0 ⊆ X1 is evident. By the induction hypothesis, Xi−1 ⊆ Xi . Since Xi ⊆ M, Xi is an M-trigger forevery rule in P i−1. Thus, P i−1 ⊆ P i . It follows thati=0 satisfies the principle (P(cid:17)).Xi = hset(P i−1) ∩ M ⊆ hset(P i) ∩ M = Xi+1.That completes the proof of the inductive step and of the claim (for property (P(cid:17))).The principle (P(cid:17)) implies that for every i (cid:3) 0, P i ⊆ P i+1. Together with earlier observations, that implies that (cid:9) Xi(cid:11)∞i=0By definition, X∞ ⊆ M. We will now prove the converse inclusion. To this end, let us consider a ∈ M. We will prove bysatisfies the principle (FPr).induction on the rank k of a that a ∈ Xk+1.If a ∈ M has rank 0, then a has an empty M-justification, that is, there is a rule r such that a ∈ hset(r) and ∅ is anM-trigger for r. It follows that r ∈ P 0 and so, a ∈ hset(P 0) ∩ M = X1. The reasoning for the inductive step is essentially thesame. Let us consider a ∈ M such that k(a) = k (cid:3) 1. By definition, there is a rule r such that Y is an M-trigger for r and Yconsists of atoms of ranks strictly lower than a. By the induction hypothesis, Y ⊆ Xk. Thus, r ∈ P k and so, a ∈ Xk+1.It follows that M ⊆ X∞. Consequently, M = X∞. To complete the proof all that remains is to show is that X∞ is asupported model of P , that is, that (cid:9) Xi(cid:11)∞(cid:17)). To this end, we recall that for every i (cid:3) 0, P i = P i(M).Thus, P i ⊆ P (M) and, since Xi ⊆ hset(P i), M = X∞ ⊆ hset(P (M)). Since M is a model of P , it follows that X∞ is a supportedmodel of P . (cid:2)i=0 satisfies the principle (C7.2. Answer-set semantics and program transformationsProgram transformations are mappings assigning programs to programs. They form a useful tool in the studies of seman-tics of programs. Invariance of a semantics to a particular program transformation yields methods for program rewritingand simplification, as well as normal form representations of programs. Alternatively, program transformations can be usedto generalize a semantics defined for programs of some simple syntactic form to those without syntactic restrictions.We will consider here a simple transformation of programs with arbitrary constraints to programs with convex con-straints. We will show that the transformation preserves the semantics of answer sets. Given that all major proposals forthe semantics of programs with convex constraints coincide, that result provides additional support for the notion of ananswer set as we defined it here.310L. Liu et al. / Artificial Intelligence 174 (2010) 295–315First, we show that every program with arbitrary constraints can be transformed into a head-convex program. A rule ris head-convex if hd(r) is a convex constraint. A program is head-convex if all its rules are head-convex.Let r = A ← A1, . . . , Ak be a rule with arbitrary constraints. We represent it by two head-convex rules cstr(r) and sppt(r).The first rule iscstr(r) = ⊥ ← A, A1, . . . , Akwhere A denotes the complement of A, that is, the constraint B such that B dom = Adom and Bsat = { X ⊆ Adom | X /∈ Asat}.The second rule is(cid:2)(cid:6)sppt(r) =Adom, { X | X ⊆ Adom}← A1, . . . , Ak.Clearly, both ⊥ and ( Adom, { X | X ⊆ Adom}) are convex. Thus, rules cstr(r) and sppt(r) are head-convex. The role of cstr(r) isto capture precisely the same constraint as the one expressed by r. The role of sppt(r) is to “support” precisely the sameatoms as r and in exactly the same circumstances. For a program with arbitrary constraints, P , we define(cid:3)hc(P ) =cstr(r)(cid:5)(cid:4)(cid:4) r ∈ P∪(cid:3)sppt(r)(cid:5)(cid:4)(cid:4) r ∈ P.Theorem 3. Let P be a program with arbitrary constraints and M ⊆ At. Then M is an answer set of P if and only if M is an answer setof hc(P ).Proof. It is evident that M is a model of P if and only if M is a model of hc(P ). Moreover, directly from the definition itfollows that M is strongly grounded with respect to P if and only if M is strongly grounded with respect to hc(P ). Thus,the result follows from Theorem 2. (cid:2)Next, we will show that every head-convex program can be transformed into a program with convex constraints sothat the answer sets are preserved. Let A, B be a constraints. We say that A is a subconstraint of B if Adom = Bdom andAsat ⊆ Bsat. For a constraint A, we denote by mc( A) the set of maximal convex subconstraints of A. We note that everysatisfier X of A is a satisfier of at least one of the constraints in mc( A).Given a head-convex rule A ← A1, . . . , Ak, we define Cvx(r) to be the set of all rules of the form A ← A∈ mc( Ai). For a head-convex program P , we setA(cid:17)i(cid:17)1, . . . , A(cid:17)k, whereCvx(P ) =(cid:8)r∈PCvx(r).It is clear that Cvx(P ) is a program with convex constraints.Theorem 4. Let P be a head-convex program with arbitrary constraints and M ⊆ At. Then M is an answer set of P if and only if M isan answer set of Cvx(P ).Proof. (Sketch) As before, we first note that M is a model of P if and only if M is a model of Cvx(P ). Next, we note thatX is an M-trigger of a rule r ∈ P if and only if there is a rule r. It followsthat M is strongly grounded in P if and only if M is strongly grounded in Cvx(P ). Thus, as before, the result follows fromTheorem 2. (cid:2)(cid:17) ∈ Cvx(r) such that X is an M-trigger for r(cid:17)It follows that the transformation of P to Cvx(hc(P )) preserves answer sets. We note that the role of the transforma-tion is conceptual rather than practical. The program Cvx(hc(P )) may grow exponentially relative to P (the size explosionpotentially occurs in the second step of the transformation).7.3. More about self-justified weak (cid:18) fc -computationsSeveral interesting classes of models can be defined by specifying the mapping from sets to quasi-satisfiability relations,which determines a class of self-justified weak computations and so, a class of models. Each class of models that canbe defined in this way consists of supported models—since we require that weak computations satisfy the convergenceprinciple. We will now show that, in particular, the class of supported models can be defined in these terms.Definition 9. Let X be a set of atoms. For a set Y of atoms and a constraint A we define the relation (cid:18)suppXas follows:Y (cid:18)suppXA if X |(cid:8) A.We denote the mapping X (cid:20)→ (cid:18)suppXby supp.L. Liu et al. / Artificial Intelligence 174 (2010) 295–315311Let M be a supported model of P . We have that the sequence C = (cid:9)∅, M, M, . . .(cid:11) satisfies (P(cid:17)), and hence, is a weakcomputation. Furthermore, since M is a supported model of P , P supp(M) = P (M). This implies that M ∈ T nd;supp(M). Thus,C is a weak (cid:18)suppM -computation. Thus, supported modelsof P are supp-models of P . As we observed earlier, all f -models are supported models. It follows that supported models ofP are precisely supp-models of P .M -computation. As M is the result of C , C is a self-justified weak (cid:18)supp(cid:17)), (CPNext, we will discuss the semantics of programs with abstract constraints proposed by Marek and Remmel [29]. Thatproposal is based on a specialized notion of program reduct. Let A be a constraint. By (cid:9)A we denote the closure of A, that is,the constraint ( Adom, {Y | Y ⊆ Adom, (∃Z ∈ Asat)(Z ⊆ Y )}). Now, given a program P and an interpretation M, the NSS-reductof P with respect to M is obtained by (i) removing all rules whose body is not satisfied by M, and (ii) replacing eachremaining rule A ← A1, . . . , Ak with the set of rules {a ← (cid:10)A1, . . . , (cid:10)Ak | a ∈ M ∩ Adom}. A set M of atoms is an mr-answer setif M is the unique least model of the NSS-reduct of P with respect to M; one can show that NSS-reducts do have uniqueleast models [29].Definition 10. Let X be a set of atoms. For a set Y of atoms and a constraint A we define the relation (cid:18)mrX as follows:Y (cid:18)mrX A if there exists Y(cid:17) ⊆ Y such that Y(cid:17) |(cid:8) A, and X |(cid:8) A.(cid:18)mrM ( X) ⊆ PWe will now show that mr-models of P are precisely the mr-answer sets of P . Let M be an mr-answer set of P and Q bethe NSS-reduct of P with respect to M. By definition, M is the fixpoint of the operator4 T Q ( X) = {hd(r): r ∈ Q , X |(cid:8) body(r)}.Consider the sequence C = (cid:9) Xi(cid:11)∞Q (∅). Because every constraint in Q is monotone, we have that T Q is aM we have that for every X ⊆ Y ⊆ M,monotonic operator. Thus, C is a weak computation. Furthermore, by definition of (cid:18)mrPM -computation whose resultis M, i.e., M is an mr-model of P .M ( Xi). This implies that C is a self-justified weak (cid:18)mrM (Y ), and hence, Xi+1 ∈ T nd;(cid:18)mr(cid:18)mri=0 where Xi = T iConversely, if M is an mr-model of P , then M is the result of a self-justified weak (cid:18)mri=0. Again,let Q be the NSS-reduct of P with respect to M. Since M |(cid:8) A implies M |(cid:8) (cid:11)A for every constraint A, we have that M is alsoa model of Q . Let Y i = T iM , the construction of Q , and the operator T Q , we canconclude that X1 ⊆ Y 1. Using induction and similar arguments, we conclude that Xi ⊆ Y i . Thus, the least fixpoint of Q , say(cid:17) = M, i.e., M is anMmr-answer set of P .Q (∅). By definition of the operator T nd;(cid:18)mris the least model of Q , implies that M. This, together with the fact that M, satisfying that M ⊆ MM -computation C = (cid:9) Xi(cid:11)∞The approach of self-justified weak (cid:18) fX -computations can be extended further. Namely, instead of regarding f as assign-ing quasi-satisfiability relations to sets of atoms, we could assume that f assigns quasi-satisfiability relations to computations.To illustrate this point, let us assume that C = (cid:9) Xi(cid:11)∞i=0 is a computation and define (cid:18)C as follows: Y (cid:18)C A if Y = Xi , forsome i, 0 (cid:2) i, and X j |(cid:8) A for every j, i (cid:2) j. This particular approach has interesting connections to the basic idea of areduct. We recall that in the normal case we take a set of atoms as a context, and re-justify it in the “check” phase. Here,we take the whole computation as a context and have to re-justify all its elements in the “check” phase. The correspondingnotion of an (cid:18)C -model has several desirable properties, yet it seems to be too weak. One can show that (cid:18)C -models areanswer sets but, in general, not conversely.(cid:17)(cid:17)(cid:17)Even in this more general version, the approach to define classes of models through self-justified weak computationshas its limitations. Let us recall the semantics for programs with aggregates proposed by Faber et al. [14] (we restate it forprograms with constraints). A set of atoms M is an FLP-answer set of a program with constraints P if M is a minimal modelof P (M). So far, we have been unable to cast that semantics in terms of self-justified weak computations.7.4. Answer sets and programs with aggregatesAs discussed in other papers considering abstract constraints [29,31,28], abstract constraints can be used to representseveral extensions of logic programs, including aggregates (e.g., [8,14,15,35,41]). Intuitively, an aggregate atom A can berepresented by a constraint C A = ( Adom, Asat), where Adom is the set of atoms occurring in the set expression of A and Asatcontains the subsets of Adom that satisfy the aggregate. In the remainder of this section, by A(P ) we mean the programwith constraints obtained from a program with aggregates by replacing aggregates with the corresponding constraints.Proposition 12, and the results developed by Son, Pontelli, and Elkabani [41], Son, Pontelli, and Tu [42], allow us to relateanswer sets as we introduced them with semantics for programs with aggregates proposed by others. First, we note thatwhen only monotone aggregates (constraints) are allowed, all approaches coincide.Proposition 13. (See [42].) For a program with monotone aggregates, say P , M is an answer set of A(P ) if and only if it is an answerset of P with respect to the definitions proposed by Faber et al. [14] and Ferraris [15].Another important approach to the semantics of aggregates in logic programming has been investigated by Pelov, De-necker and Bruynooghe [36] and Pelov [35], based on the approximation theory developed in [7]. The proposal of Pelov4 Abusing the notation, we use the immediate consequence operator T P as defined for normal logic programs.312L. Liu et al. / Artificial Intelligence 174 (2010) 295–315et al. [36], Pelov [35] defines and exploits the so-called ultimate approximation operator Φ aggr. A complete (two-valued)interpretation M is an answer set according to Pelov et al. [36] if it is a fixpoint of Φ aggr. If P is a positive program withaggregates (the notion defined by Pelov et al. [36], Pelov [35]), the program A(P ) has only monotone constraints in bodiesof the rules, and we have the following result.PPProposition 14. Let P be a positive program with aggregates. Then, every answer set of A(P ) is an answer set according to thedefinition of Pelov et al. [36] and vice versa.The proof of this proposition relies on Proposition 12 and Theorem 3 by Son and Pontelli [40].The relationship between the semantics discussed above brakes when we allow programs with aggregates that are notmonotone. This is illustrated by the following examples.Example 9. Consider the program P :(cid:3)(cid:2)(cid:3)(cid:3)(cid:5)p(1), p(−1),∅,p(1) ←p(1) ← p(−1)p(−1) ← p(1)(cid:5)(cid:5)(cid:6)p(1), p(−1)Intuitively, the abstract atom A = ({p(1), p(−1)}, {∅, {p(1), p(−1)}}) represents the aggregate atom Sum({ X | p( X)}) = 0 orCount({ X | p( X)}) (cid:22)= 1 (where the domain of the variable X is {1, −1}). This program has a model M1 = {p(1), p(−1)}.The approaches by Marek and Remmel [29], Faber et al. [14], and Ferraris [15] accept M1 as an answer set, while ourapproach and that by Pelov [35] and Denecker et al. [8] do not admit any answer sets. It is easy to see that there is nofounded computation for P whose result is M1. In fact, this program does not have a computation: the only applicable rulegiven X0 = ∅ is the first rule and so X1 = {p(1)}; the only applicable rule with respect to X1 is the last rule, and thus,X2 = {p(−1)}; and the sequence violates the property (PAlternatively, we could argue against semantics allowing {p(1), p(−1)} as an answer set by noting that the model{p(1), p(−1)} is self-supported. Indeed, it is not strongly grounded, that is, no “proper” ranking of its elements can befound (we note that the program P is isomorphic to the program P 6 considered in Example 8).(cid:17)).Let us now consider the program consisting of two rulesp ← p(cid:2)p ←{p}, ∅(cid:6)The approach by Pelov et al. [36] accepts M = {p} as an answer set, while our approach does not.Finally, we note that the proposals developed by Faber et al. [14] and Pelov [35] do not allow aggregates in the head ofthe rules, but they consider disjunctive logic programs with aggregates.7.5. Other semantics of programs with abstract constraintsWe have already mentioned the relationship between the computation characterization of answer sets and the charac-terization proposed by Son et al. [42]—the latter can be described by the sub-satisfiability relation (cid:18)sptX .For the semantics proposed by Marek and Remmel [29] we have the following observations as corollaries from ourresults and the results by Son et al. [42]:(1) Each answer set of P according to the definition given in this paper is also an answer set according to Marek andRemmel—this result can be derived from the observation that the analogous property holds for answer sets as discussedby Son et al. [42].(2) There are answer sets according to Marek and Remmel that are not answer sets according to the definitions in thispaper. This can be seen in the program:a ←b ←c ←(cid:2)(cid:3){a, b, c},{a}, {a, b, c}(cid:5)(cid:6)The characterization by Marek and Remmel accepts {a, b, c} as an answer set. On the other hand, a computation, inorder to produce {a, b, c} will need to be organized as follows: ∅, {a}, {a, b, c}, . . . . But this computation is clearly notfounded.L. Liu et al. / Artificial Intelligence 174 (2010) 295–315313Marek and Truszczy ´nski [31] and Marek et al. [28] propose a characterization of answer sets for program with monotoneconstraints, later extended to the case of convex constraints by Liu and Truszczy ´nski [25]. These two semantics are provedto coincide with the answer sets obtained using (cid:18)sptX by Son et al. [42], that is, with answer sets as defined in this paper.Another interesting line of research has been recently proposed by Shen and You [38]. The authors propose a model-theoretic semantic characterization for programs with constraints which is based on a generalized Gelfond–Lifschitz trans-formation. The resulting semantics is proved to coincide with the notion of answer sets we discuss in this work (and withthe answer sets as defined by Son et al. [42]). This provides further reinforcement of the validity of the semantics wediscuss in this paper. The work by Shen and You [38] nicely complements our computation-based approach, by offering amodel-theoretic characterization of answer sets.8. ConclusionsIn this paper, we conducted an in-depth investigation of semantics of logic programs with general abstract constraints.Programs with such constraints are important. Arbitrary abstract constraints subsume many types of constraints and aggre-gates that arise in practice. Moreover, the use of arbitrary constraints allows us to eliminate the explicit use of the negationas failure without compromising the expressive power. Our effort extends and complements earlier proposals, generalizingthe well-established notions of answer sets of normal logic programs, and of programs with monotone and convex abstractconstraints.The backbone of our proposal is the notion of a computation, viewed as a regulated sequence of interpretations. Compu-tations are specified in terms of some basic principles: revision, convergence, persistence of beliefs, persistence of reasons,and founded persistence of reasons. These principles have been derived through an analysis of properties of answer sets ofnormal logic programs. Building on that connection, we proposed as answer sets of programs with arbitrary constraints theresults of computations that are founded, that is, satisfy all the properties listed above.The problem of assigning an “answer-set” semantics to programs with arbitrary constraints has received much attentionlately. In the paper, we compared our proposal with several alternative ones. Clearly, the question which of the proposedgeneralizations of the answer-set semantics from the case of normal programs to the case of programs with arbitraryconstraints is the “correct” one cannot be given a definitive answer. Indeed, the concept of “correctness” does not havea formal definition. However, one can identify some desirable properties that answer sets should satisfy, and evaluateproposed semantics based on how they behave relative to those properties.In this respect, we note that our concept of an answer set has a strong constructive flavor. It is rooted in the notion of acomputation which, in turn, is based on some fundamental principles computations should obey. Next, it coincides with anearlier proposal by Son et al. [42] and, as should be expected of any semantics of answer sets for programs with arbitraryconstraints, it generalizes answer sets of normal logic programs and of programs with convex constraints. Furthermore,answer sets as defined here have several equivalent characterizations. They are: the definition provided in Section 5, thedefinition given by Son et al. [42], a closely related characterization in terms of sub-satisfiability relations from Section 6,and the characterization in terms of a transformation of programs with arbitrary constraints to programs with convex ones.All these characterizations point to the multitude of intuitions that underlie the semantics we proposed here. Lastly, ouranswer sets are free of self-supportedness, a feature lacking in other proposals for the semantics of programs with arbitraryconstraints, most notably the proposal developed by Faber et al. [14].We conclude by noting a challenging open problem. Namely, so far we have been unable to extend our computation-based approach so that to capture as a special case the semantics of answer sets of disjunctive logic programs. Answer setsof disjunctive programs are minimal models. Therefore, we are after a class of computations that are guaranteed to produceminimal models only. However, finding such a concept of a computation is not easy. In particular, an obvious attempt torequire that computations increase minimally in each step of a computation does not address the problem [37]. For instance,let us consider a program consisting of two rules: a ∨ b and b ← a. Every reasonable class of computations (that do notlook ahead to the result but decides how to expand based on what has been computed so far) seems to have to contain thecomputation ∅, {a}, {a, b}, {a, b}, . . .. But the result of that computation is not a minimal model. In the same time, there isno way to determine that computing {a} in the first step is incorrect based only on the current (in this case, initial) state ofthe computation. It seems possible that in order to capture minimality it is necessary to impose some “global” minimalityrequirement (as opposed to “local” definition of how to increment from step to step). This difficulty seems also to be at theheart of the problem of expressing the semantics of Faber et al. [14] in terms of computations, which we noted earlier.AcknowledgementsThe authors wish to thank the anonymous reviewers for their insightful comments. This research has been partiallysupported by NSF grants 0812267 and 0420407.References[1] K. Apt, Logic programming, in: J. van Leeuven (Ed.), Handbook of Theoretical Computer Science, Elsevier, Amsterdam, 1990, pp. 493–574.[2] M. Balduccini, M. Gelfond, M. Nogueira, Answer set based design of knowledge systems, Annals of Mathematics and Artificial Intelligence 47 (1–2)(2006) 183–219.314L. Liu et al. / Artificial Intelligence 174 (2010) 295–315[3] C. Baral, Knowledge Representation, Reasoning, and Declarative Problem Solving, Cambridge University Press, 2003.[4] C. Baral, From knowledge to intelligence—building blocks and applications. Invited talk, AAAI, 2005, www.public.asu.edu/~cbaral/aaai05-invited-talk.ppt.[5] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Computing Surveys 33 (3) (2001) 374–425.[6] T. Dell’Armi, W. Faber, G. Ielpa, N. Leone, G. Pfeifer, Aggregate functions in disjunctive logic programming: Semantics, complexity, and implementationin DLV, in: Proceedings of the 18th International Joint Conference on Artificial Intelligence, IJCAI 2003, 2003, pp. 847–852.[7] M. Denecker, V. Marek, M. Truszczy ´nski, Ultimate semantic treatment of default and autoepistemic logics, in: Proceedings of KR, Principles of Knowl-edge Representation and Reasoning, 2000, pp. 74–84.[8] M. Denecker, N. Pelov, M. Bruynooghe, Ultimate well-founded and stable semantics for logic programs with aggregates, in: P. Codognet (Ed.), LogicProgramming, Proceedings of the 17th International Conference, ICLP 2001, Paphos, Cyprus, November 26–December 1, 2001, in: Lecture Notes inComputer Science, vol. 2237, Springer, 2001, pp. 212–226.[9] T. Eiter, W. Faber, N. Leone, G. Pfeifer, A. Polleres, A logic programming approach to knowledge state planning, II: The DLVsystem, Artificial Intelli-Kgence 144 (1–2) (2003) 157–211.[10] T. Eiter, W. Faber, N. Leone, G. Pfeifer, A. Polleres, Answer set planning under action costs, Journal of Artificial Intelligence Research 19 (2003) 25–71.[11] I. Elkabani, E. Pontelli, T.C. Son, Smodels with CLP and its applications: A simple and effective approach to aggregates in ASP, in: B. Demoen, V. Lifschitz(Eds.), Logic Programming, Proceedings of the 20th International Conference, ICLP 2004, Saint-Malo, France, September 6–10, 2004, in: Lecture Notesin Computer Science, vol. 3132, Springer, 2004, pp. 73–89.[12] E. Erdem, V. Lifschitz, Tight logic programs, Theory and Practice of Logic Programming 3 (4–5) (2003) 499–518.[13] E. Erdem, V. Lifschitz, D. Ringe, Temporal phylogenetic networks and logic programming, Theory and Practice of Logic Programming 6 (5) (2006)539–558.[14] W. Faber, N. Leone, G. Pfeifer, Recursive aggregates in disjunctive logic programs: Semantics and complexity, in: J.J. Alferes, J.A. Leite (Eds.), Logics inArtificial Intelligence, Proceedings of the 9th European Conference, JELIA 2004, Lisbon, Portugal, September 27–30, 2004, in: Lecture Notes in ComputerScience, vol. 3229, Springer, 2004, pp. 200–212.[15] P. Ferraris, Answer sets for propositional theories, in: C. Baral, G. Greco, N. Leone, G. Terracina (Eds.), Logic Programming and Non-monotonic Reasoning,Proceedings of the 8th International Conference, LPNMR 2005, Diamante, Italy, September 5–8, 2005, in: Lecture Notes in Computer Science, vol. 3662,Springer, 2005, pp. 119–131.[16] M. Gebser, B. Kaufmann, T. Schaub, clasp: A conflict driven answer set solver, in: C. Baral, G. Brewka, J. Schlipf (Eds.), Logic Programming and Non-monotonic Reasoning, Proceedings of the 9th International Conference, LPNMR 2007, Tempe, USA, May 15–17, 2007, in: Lecture Notes in ComputerScience, vol. 4483, Springer, 2007, pp. 260–265.[17] M. Gelfond, Representing knowledge in A-Prolog, in: A. Kakas, F. Sadri (Eds.), Computational Logic: Logic Programming and Beyond, Springer-Verlag,2002, pp. 413–451.[18] M. Gelfond, N. Leone, Logic programming and knowledge representation—the A-Prolog perspective, Artificial Intelligence 138 (1–2) (2002) 3–38.[19] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: R. Kowalski, K. Bowen (Eds.), Logic Programming: Proceedings of theFifth International Conference and Symposium, The MIT Press, 1988, pp. 1070–1080.[20] M. Gelfond, V. Lifschitz, Logic programs with classical negation, in: D. Warren, P. Szeredi (Eds.), Logic Programming: Proceedings of the SeventhInternational Conference, The MIT Press, 1990, pp. 579–597.[21] K. Heljanko, I. Niemelä, Bounded LTL model checking with stable models, Theory and Practice of Logic Programming 3 (4–5) (2003) 519–550.[22] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Transactionson Computational Logic 7 (3) (2006) 499–562.[23] Y. Lierler, M. Maratea, Cmodels-2: SAT-based answer set solver enhanced to non-tight programs, in: V. Lifschitz, I. Niemelä (Eds.), Proceedings of the7th International Conference on Logic Programming and Non-monotonic Reasoning Conference, LPNMR’04, in: LNCS, vol. 2923, Springer-Verlag, 2004,pp. 346–350.[24] L. Liu, E. Pontelli, T.C. Son, M. Truszczy ´nski, Logic programs with abstract constraint atoms: The role of computations, in: V. Dahl, I. Niemelä (Eds.),Proceedings of the 23rd International Conference on Logic Programming, ICLP 2007, Porto, Portugal, September 8–13, in: Lecture Notes in ComputerScience, vol. 4670, Springer, 2007, pp. 286–301.[25] L. Liu, M. Truszczy ´nski, Properties of programs with monotone and convex constraints, in: M.M. Veloso, S. Kambhampati (Eds.), Proceedings, TheTwentieth National Conference on Artificial Intelligence and the Seventeenth Innovative Applications of Artificial Intelligence Conference, July 9–13,2005, AAAI Press/The MIT Press, Pittsburgh, Pennsylvania, USA, 2005, pp. 701–706.[26] J. Lloyd, Foundations of Logic Programming, 2nd edition, Springer-Verlag, 1987.[27] V.W. Marek, A. Nerode, J.B. Remmel, Logic programs, well-orderings, and forward chaining, Ann. Pure Appl. Logic 96 (1–3) (1999) 231–276.[28] V.W. Marek, I. Niemelä, M. Truszczy ´nski, Logic programs with monotone abstract constraint atoms, Theory and Practice of Logic Programming 8 (2)(2008) 167–199.[29] V.W. Marek, J.B. Remmel, Set constraints in logic programming, in: Logic Programming and Non-monotonic Reasoning, Proceedings of the 7th Interna-tional Conference, LPNMR 2004, Fort Lauderdale, FL, USA, January 6–8, 2004, in: Lecture Notes in Computer Science, vol. 2923, Springer-Verlag, 2004,pp. 167–179.[30] V.W. Marek, M. Truszczy ´nski, Stable models and an alternative logic programming paradigm, in: The Logic Programming Paradigm: A 25-year Perspec-tive, Springer-Verlag, 1999, pp. 375–398.[31] V.W. Marek, M. Truszczy ´nski, Logic programs with abstract constraint atoms, in: Proceedings of the Nineteenth National Conference on ArtificialIntelligence, Sixteenth Conference on Innovative Applications of Artificial Intelligence, July 25–29, 2004, San Jose, California, USA, AAAI Press/The MITPress, 2004, pp. 86–91.[32] W. Marek, M. Truszczy ´nski, Non-Monotonic Logic: Context Dependent Reasoning, Springer-Verlag, 1993.[33] I. Niemelä, Logic programming with stable model semantics as a constraint programming paradigm, Annals of Mathematics and Artificial Intelli-gence 25 (3–4) (1999) 241–273.[34] I. Niemelä, P. Simons, Smodels—an implementation of the stable model and well-founded semantics for normal logic programs, in: Logic Programmingand Non-monotonic Reasoning, 7th International Conference, LPNMR 1997, Springer-Verlag, 1997, pp. 420–429.[35] N. Pelov, Semantic of logic programs with aggregates, PhD thesis, Katholieke Universiteit Leuven, 2004, www.cs.kuleuven.ac.be/publicaties/doctoraten/cw/CW2004_02.abs.html.[36] N. Pelov, M. Denecker, M. Bruynooghe, Partial stable models for logic programs with aggregates, in: Logic Programming and Non-monotonic Reasoning,7th International Conference, LPNMR 2004, Springer-Verlag, 2004, pp. 207–219.[37] N. Pelov, M. Truszczy ´nski, Semantics of disjunctive programs with monotone aggregates—an operator-based approach, in: J.P. Delgrande, T. Schaub(Eds.), Proceedings of the 10th International Workshop on Non-Monotonic Reasoning, NMR-04, 2004, pp. 327–334.[38] Y.-D. Shen, J.-H. You, A generalized Gelfond–Lifschitz transformation for logic programs with abstract constraints, in: AAAI, AAAI Press, 2007, pp. 483–488.[39] P. Simons, N. Niemelä, T. Soininen, Extending and implementing the stable model semantics, Artificial Intelligence 138 (1–2) (2002) 181–234.[40] T.C. Son, E. Pontelli, A constructive semantic characterization of aggregates in answer-set programming, Theory and Practice of Logic Programming 7 (3)(2007) 355–375.L. Liu et al. / Artificial Intelligence 174 (2010) 295–315315[41] T.C. Son, E. Pontelli, I. Elkabani, An unfolding-based semantics for logic programming with aggregates. Computing research repository, cs.SE/0605038,2006.[42] T.C. Son, E. Pontelli, P.H. Tu, Answer sets for logic programs with arbitrary abstract constraint atoms, Journal of Artificial Intelligence Research 29 (2007)353–389.[43] M. van Emden, R. Kowalski, The semantics of predicate logic as a programming language, Journal of the ACM 23 (4) (1976) 733–742.[44] A. Van Gelder, K. Ross, J. Schlipf, The well-founded semantics for general logic programs, Journal of the ACM 38 (3) (1991) 620–650.[45] J.-H. You, L.-Y. Yuan, G. Liu, Y.-D. Shen, Logic programs with abstract constraints: Representation, disjunction and complexities, in: C. Baral, G. Brewka,J.S. Schlipf (Eds.), Logic Programming and Non-monotonic Reasoning, Proceedings of the 9th International Conference, LPNMR 2007, Tempe, AZ, USA,May 15–17, 2007, in: Lecture Notes in Computer Science, vol. 4483, Springer, 2007, pp. 228–240.