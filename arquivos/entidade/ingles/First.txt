Artificial Intelligence 175 (2011) 193–219Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintFirst-order logical filteringAfsaneh Shirazi∗, Eyal AmirUniversity of Illinois at Urbana-Champaign, Department of Computer Science, Urbana, IL 61801, USAa r t i c l ei n f oa b s t r a c tArticle history:Available online 3 April 2010Keywords:FilteringFirst-order logicBelief updateSituation calculus1. IntroductionLogical filtering is the process of updating a belief state (set of possible world states) aftera sequence of executed actions and perceived observations. In general, it is intractable indynamic domains that include many objects and relationships. Still, potential applicationsfor such domains (e.g., semantic web, autonomous agents, and partial-knowledge games)encourage research beyond intractability results.In this paper we present polynomial-time algorithms for filtering belief states that areencoded as First-Order Logic (FOL) formulas. Our algorithms are exact in many cases ofinterest. They accept belief states in FOL without functions, permitting arbitrary arity forpredicates, infinite universes of elements, and equality. They enable natural representationwith explicit references to unidentified objects and partially known relationships, stillmaintaining tractable computation. Previous results focus on more general cases that areintractable or permit only imprecise filtering. Our algorithms guarantee that belief-staterepresentation remains compact for STRIPS actions (among others) with unbounded-sizedomains. This guarantees tractable exact filtering indefinitely for those domains. The restof our results apply to expressive modeling languages, such as partial databases and beliefrevision in FOL.© 2010 Elsevier B.V. All rights reserved.Many everyday scenarios are dynamic and partially observable: a robot in one room cannot see the state of anotherroom, a camera overlooking a bookshelf cannot detect the title of a book that is obscured, and one cannot readily observethe amount of money an agent has. Many applications in such domains compute information about the current world state(belief state, i.e. set of possible states or a distribution over such a set) after performing actions and perceiving observations.This computation is called filtering (also, state estimation, belief update, and database progression). They use this informationto make decisions (e.g., “increase the asking price for my car”), answer questions (e.g., “where is my calculus book?”), andexplore (e.g., “go to room 2 and sense the state of the circuit break”).Filtering is intractable in general for discrete domains [17], and much research is dedicated to its approximation instochastic domains (e.g., [6,15,20]). Still, these approximations introduce unbounded errors many times, take unboundedcomputation time in others, and are not usable in most deterministic domains.Recent progress on logical methods for filtering of propositional belief states (sets of states) [3] with actions and obser-vations has shown that exact filtering is tractable when belief states are represented as propositional formulas, and certainnatural assumptions are met. Still, many domains have propositional encodings that are too large. In some domains, propo-sitional representation is not possible at all. This includes domains with large numbers of objects, unknown numbers of* Corresponding author.E-mail addresses: hajiamin@cs.uiuc.edu (A. Shirazi), eyal@cs.uiuc.edu (E. Amir).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.04.015194A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219AlgorithmAssumptionsTime (1 step)SpaceDeduction filter (Section 3.2)Factored filter (Section 4)Unit-case filter (Section 5.1)STRIPS filter (Section 5.2)STRIPS filter (Section 5.2)none1:1 actions; Finite FOL filtering of atoms;precompilation stage1:1 Unit-Cases actions; UNAaSTRIPS actions; known success; UNA; ϕ inclausal formb; cases fully instantiatedSTRIPS actions; known success; UNA; ϕ in2-clausalc formunbounded (lazy computation)precompilation unbounded; O (|ϕ| · C)O (Rl(l + |ϕ| + p))O ((l|ψ|)2e)O (m2(R + n)2R )unboundedO (|ϕ| · C), C depends on pre-compilationO (Rl(l + |ϕ| + p))O ((l|ψ|)2e);O (m2(R + n)2R ) for any t > 0time stepsLegend: ϕ: input (initial) belief state; m: number of predicate symbols; R: maximum arity of predicates; n: number of constant symbols (not objects, whichmay be infinitely many); l: total number of cases for action a’s successor-state axioms; p: number of distinct atoms in the precondition of a; e: number ofdistinct affected literals of a.a UNA: Unique-Names Assumption.b Clausal form: Conjunction of disjunctions in ∃∗∀∗c 2-clausal: Every clause has (cid:2) 2 literals.fragment of FOL.Fig. 1. The algorithms presented in this paper, their properties, and their assumptions for correct filtering. All algorithms assume no function symbols. Noalgorithm assumes a finite domain or requires a closed-world assumption (CWA). (The CWA is made in many planning domains. It assumes that the onlyobjects in the domain are those mentioned explicitly.)objects, and observations with partial knowledge about identity of objects. Propositional methods are very inefficient insuch domains, and representations are typically large and cumbersome.In this paper we present tractable algorithms and theoretical results for filtering belief states that are represented in First-Order Logic (FOL). These representations permit belief states of infinite sizes, uncertainty about the number of objects andtheir identity, and observations that do not distinguish between some objects. It also enables more compact representationsthan those of propositional logic.More specifically (detailed results table is presented in Fig. 1), we present the following algorithms and complexitybounds on their performance: First, we show that when actions are partial functions that map states 1:1, we can filterarbitrary FOL belief-state formulas in time O (|ψ| · C), for ψ the input belief state representation, after a precompilationstage of the domain (not including ψ ). The output size is O (|ψ| · C), for C a constant (possibly large) that depends on ouractions’ definitions (not on the input sequence of actions or the initial belief state).Second, we examine in more detail two action representations that permit faster and more compact filtering withoutprecompilation of the domain. Both of those classes of domains represent the effects of actions by cases.For the first class of actions we show that filtering takes time O (Rl · (|ψ| + l + p)) for R the arity of predicate fluents, lthe total number of cases into which filtered actions break, and p the number of distinct atoms appearing in preconditionsof the action and in cases. The belief state returned has representation size O (Rl · (|ψ| + l + p)). To obtain these results weassume that actions are 1:1 and can be broken into cases conditioned on unit clauses (this is defined formally in Section 5.1),and that different constant symbols refer to different elements in our domain (this is the Unique Names Assumption (UNA)).We present a different result for the second class of action representations, namely, STRIPS actions [18] in two differentscenarios. In the first scenario we assume that every action case for a but one instantiates all variables in every affectedpredicate (thus making it a proposition). Also, we assume the UNA and that actions are executable when they are filtered.Given those, we show that filtering takes time O ((l|ψ|)2e) per action, for e the number of affected literals for action a. Also,we show that the resulting belief state formula is represented in space bounded by O ((l|ψ|)2e) (here, |ψ| is the size of theinput belief state).Focusing on filtering sequences of length T > 0, and assuming input belief states that have only clauses of (cid:2) 2 literals, weget a final, better result. Assuming UNA and STRIPS actions, not assuming full-instantiation of cases (cases may instantiatesubsets of variables), we show that the same algorithm for STRIPS actions takes time O (m2(R + n)2R ) per action, for mpredicates of arity at most R and n constant symbols. The output belief-state space representation is bounded by O (m2(R +n)2R ) regardless of the number of filtering steps. Thus, filtering a sequence of t > 0 actions and observations takes time(tm2(R + n)2R ).Notice that the domain may still be large (or infinite) when R, m, n are small, so this result enables tractable filteringfor some very large domains. This result guarantees tractable filtering for arbitrary sequence lengths with such domains. Itapplies to standard STRIPS actions, among others.These results support a growing belief that FOL can be used efficiently for representing and updating partial knowledge[40,66,53,41,65].En route to these contributions we relate deterministic Situation Calculus [53] with a FOL transition model [4]. In thetransition model, every belief state is a set of FOL structures over the FOL language of a state. We encode this set ofstructures with FOL formulas. We re-state results of [40,64] showing that filtering such belief states can be captured exactlyby deduction in FOL and that deduction can be carried out one time step at a time, if all we wish is to answer queries abouta particular future or past state.This forms the foundations for the rest of our results, which give an efficient (polynomial-time) exact algorithm forcomputing this deduction, under some common conditions as mentioned above.The rest of the paper is organized as follows. Section 2 describes the semantics that we use for FOL filtering. In Section 3we provide a naive algorithm for filtering and prove its correctness. Section 4 offers a polynomial time algorithm for FOLA. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219195filtering that requires domain precompilation and is exact for 1:1 actions. Correctness of this algorithm relies on distributionproperties of filtering FOL KBs over logical connectives that we prove in the same section. Section 5 presents efficientalgorithms for our two kinds of case-based actions.Some of the results of this paper appeared previously in [56]. In particular, some of the basic algorithms of Sections 4and 5 appear there. The complexity results, correctness, and examples are new to this manuscript, and so is the perspectiverelating this work to early and recent research on progression of FOL databases.2. Semantics of first-order filteringIn this section, we study logical filtering with FOL structures. Logical filtering is the process of updating a set of possibleworld states after a sequence of executed actions and perceived observations. In this paper, a world state is represented bya FOL structure. Before explaining the details of logical filtering semantics, we present the languages that we consider.2.1. First-order languagesA first-order language is specified by two sets of symbols:(1) Logical symbols:(a) Logical connectives: ∧, ∨, ¬, . . . .(b) Quantifiers: ∀, ∃.(c) Equality: =.(2) Nonlogical symbols:(a) Variables (infinitely many): x, y, z, . . . .(b) Function symbols: For each n, a set of symbols called n-ary function symbols. A 0-ary function symbol is calledconstant. We use strings of English characters starting with capital letters for constants.(c) Predicate symbols: For each n, a set of symbols called n-ary predicate symbols.Note that the equality symbol can be treated as a binary predicate symbol. We define the terms and formulas by thefollowing generalized inductive definition. Variables and functions are terms. Predicates are atomic formulas. We defineliterals to be atomic formulas or the negation of atomic formulas. Concepts of free and bound occurrences of a variable in aformula are defined as usual. A closed formula is a formula with no free variable.A FOL language is a language in which the symbols and formulas are as described above. It is completely determined byits nonlogical symbols. We now turn to a description of the semantics of FOL languages. A structure S for a FOL languageconsists of:(1) |S|, the nonempty universe or domain of the structure S. The elements of |S| are called the individuals of S.(2) For each n-ary predicate symbol p, p S ⊆ |S|n. These tuples of the universe are those tuples on which p is true in thestructure.(3) For each n-ary function symbol f , f S : |S|n → |S|. (In particular, for each constant e, e S is an individual of S.)When a sentence ψ is true in a structure S, we denote it by |(cid:9)S ψ . To define it, we need a more general notion of truth fora formula. Suppose that:(1) φ is a formula of a given FOL language.(2) S is a structure for the language.(3) σ : V → |S| is a function, called a variable assignment, from the set V of variables of the language into the universeof S.We can now define |(cid:9)S φ[σ ], meaning that the formula φ is true in the structure S when its free variables are given thevalues specified by σ in the universe of S as follows.of the function σ from the set of all terms of the language into the universe.(1) Terms: Define an extension σ (cid:10)(a) For each variable v, σ (cid:10)(v) = σ (v).(b) If t1, . . . , tn are terms and f(cid:2)(cid:3)f (t1, . . . , tn)σ (cid:10)(2) Atomic formulas:(a) For term t1 and t2,is an n-ary function symbol, then(cid:2)= f Sσ (cid:10)(t1), . . . , σ (cid:10)(cid:3)(tn)|(cid:9)S t1 = t2[σ ]iff σ (cid:10)(t1) = σ (cid:10)(t2)196A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219(b) For an n-ary predicate symbol p,|(cid:9)S p(t1, . . . , tn)[σ ]iff(cid:4)σ (cid:10)(t1), . . . , σ (cid:10)(cid:5)(tn)∈ p S(3) Well-formed formulas:(a) |(cid:9)S ¬φ[σ ] iff not |(cid:9)S φ[σ ].(b) |(cid:9)S (φ ⇒ ϕ)[σ ] iff |(cid:9)S ¬φ[σ ] or |(cid:9)S ϕ[σ ].(c) |(cid:9)S (∀x)φ[σ ] iff for every d ∈ |S|, |(cid:9)S φ[σ (x/d)]. σ (x/d) is the function that is exactly like σ except that for thevariable x it assigns the value d.Definition 1. The language of a set of formulas D, L(D), is a set of first-order formulas whose predicate and function symbolsappear in of D.As an example, suppose that in structure S:• |S| = {B, R},• for binary predicate in: inS = {(cid:13)B, R(cid:14)},• for constant Office: OfficeS = {R},• for constant C++: C++S = {B}.This world has the predicate in that indicates whether a book is in a room or not, the book C++ and the room Office. Bythis definition, sentence in(C++, Office) is true in S.We define logical filtering using situation calculus [44] in a way compatible with basic action theories of [53]. In thefollowing section we discuss the basics of situation calculus needed for our work.2.2. Situation calculusIn this section, we specify the language and axiomatization of situation calculus that we will use throughout the paper.The situation calculus is a language for specifying properties of actions. The formal language adopted here is a second-orderlanguage with equality. It has three disjoint sorts: action for actions, situation for situations, and object for everything elsedepending on the domain of the application. This language has the following alphabet (this definition is similar to thesituation calculus of Reiter [53]):• A constant symbol S0, denoting the initial situation.• A binary function symbol do : action × situation → situation. The intended interpretation is that situations are finitesequences of actions, and do(a, s) denotes that sequence formed by adding action a to the sequence s.• A binary predicate symbol Poss : action × situation. The intended interpretation of Poss(a, s) is to show the possibility ofperforming the action a in situation s.• A binary predicate symbol (cid:2) : situation × situation defining an ordering relation on situations. The intended interpreta-(cid:10)tion of situations is as action histories, in which case s (cid:2) smeans that s is a proper subhistory of s.(cid:10)We want to be able to say that a certain sequence of actions is a subsequence of another. To formalize this, we adoptthe following four foundational axioms presented in [33]:(1) do(a1, s1) = do(a2, s2) ⇒ a1 = a2 ∧ s1 = s2,(2) (∀P ).P (S0) ∧ (∀a, s)[P (s) ⇒ P (do(a, s))] ⇒ (∀s)P (s),(3) ¬s (cid:2) S0,(4) s (cid:2) do(a, s(cid:10)) ≡ s (cid:16) s.(cid:10)Axiom 1 is a unique-names axiom for situations, stating that two situations are the same iff they are the same sequenceof actions. Axiom 2 is the second-order induction on situations. The importance of induction for the situation calculus isdescribed by Reiter in [52]. This axiom is the only second-order axiom in our action theory. However, Reiter in [33] showedthat the second-order axiom is not needed for projection purposes. In the rest of this paper, we use the first-order situationcalculus without this axiom. This subset of the situation calculus is sufficient for filtering, as shown by Reiter.The above axioms are domain independent. We refer to them as Σ . Combination of these axioms with a specification ofaxioms holding for the initial situation, successor state axioms, action precondition axioms, and unique-names axioms foractions is called a basic theory of actions.Generally speaking, the truth value of a predicate and the value of a function in a dynamic world may vary from timeto time. In FOL there is no intrinsic notion of time. Hence, situation calculus includes relational and functional fluentsthat capture the dynamic behavior of our world. Predicates whose truth values vary from situation to situation are calledrelational fluents. They are denoted by predicate symbols taking a situation term as their last argument. Functional fluentsare defined similarly.A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219197The situation calculus that we use here is not typed. For simplicity, we also assume that all predicates and functions arefluents. Thus, predicates whose truth values do not change from situation to situation are handled with axioms that enforcethese constraints.Definition 2 (Uniform formulas). Let s be a term of sort situation. Inductive definition of a term uniform in s is as follows:(1) Any term that does not mention a term of sort situation is uniform in s.(2) If fis an n-ary functional fluent other than do, and t1, . . . , tn are terms that are uniform in s, then f (t1, . . . , tn, s) isuniform in s.The formulas that are uniform in s are inductively defined by:(1) Any formula that does not mention a term of sort situation is uniform in s.(2) If p is an n-ary relational fluent other than Poss, and t1, . . . , tn are terms that are uniform in s, then p(t1, . . . , tn, s) is aformula uniform in s.(3) If ϕ1 and ϕ2 are formulas uniform in s, so are ¬ϕ1, ϕ1 ∧ ϕ2 and ∃v ϕ1 provided that v is a variable not of sort situation.Thus, a formula is uniform in s iff it does not mention Poss, it does not quantify over variables of sort situation, it doesnot mention equality of situations, and whenever it mentions a term of sort situation in the situation argument position ofa fluent, then that term is s.We define precondition axioms and successor state axioms as a part of our basic action theory as follows.From this point on, in our formulas the letter a refers to a ground action, and the letter A refers to the correspondingaction symbol, i.e. A is a function symbol that has arguments of sort object and value of sort action.Definition 3 (Action precondition axioms). An action precondition axiom is a sentence of the form:(cid:2)(cid:3)PossA(x1, . . . , xn), s⇔ precond A(x1, . . . , xn, s)where A is an n-ary action symbol, and precond A(x1, . . . , xn, s) is a formula that is uniform in s and whose free variablesare among x1, . . . , xn, s.Definition 4 (Successor state axioms). A Successor state axiom is defined for either a relational fluent or a functional fluent.A successor state axiom for an n-ary relational fluent p is a sentence of the form:(cid:2)(cid:3)Poss(cid:2)A(x1, . . . , xn), s(cid:2)(cid:2)⇒ ∀ y1, . . . , ∀ ympy1, . . . , ym, doA(x1, . . . , xn), s(cid:3)(cid:3)(cid:3)⇔ succp, A(x1, . . . , xn, y1, . . . , ym, s)where A is an action symbol, and succp, A(x1, . . . , xn, y1, . . . , ym, s) is a formula that is uniform in s, and whose free variablesare among x1, . . . , xn, y1, . . . , ym, s. We define a successor state axiom for a functional fluent similarly as follows.(cid:2)(cid:3)Poss(cid:2)A(x1, . . . , xn), s(cid:2)(cid:2)⇒ ∀ y1, . . . , ∀ ym, ∀zfy1, . . . , ym, doA(x1, . . . , xn), s(cid:3)(cid:3)(cid:3)= z ⇔ succ f , A(x1, . . . , xn, y1, . . . , ym, z, s)The basic action theory has the form D = Σ ∪ Dss ∪ Dap ∪ Duna ∪ DS0 where:• Σ are the foundational axioms for situations.• Dss is a set of successor state axioms.• Dap is a set of action precondition axioms.• Duna is a set of unique-names axioms for actions. A((cid:19)x) (cid:20)= A(cid:10)((cid:19)y), A((cid:19)x) = A((cid:19)y) ⇒ (cid:19)x = (cid:19)y where A and A(cid:10)are actionsymbols.• DS0 (the initial database) is a finite set of FOL sentences that are uniform in S 0. DS0 will function as the initial theoryof the world (i.e., the one we start off with, before any action is executed).All changes to the world are the result of named actions. An action may be parameterized. For example, move(B, R 1, R2)stands for the action of moving object B from room R1 to room R2. We use the situation calculus as foundations andsemantics. Later (Section 3 onwards) we focus more closely on belief states, and situation calculus is used in the proofs oftheorems.198A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–2192.2.1. Example: Book-keeper robotConsider a book-keeper robot which lives in a world consisting of rooms. When the robot is in a room, it can makeobservations about the books in that room. It can move a book from one room to the other, it can return a book to thelibrary from an arbitrary room or it can put a borrowed book in a room. So possible actions are move(b, r1, r2), return(b, r)and borrow(b, r). The actions which are executable in a world state can change the value of different relational or functionalfluents. Relational fluents are room(r, s), book(b, s), and in(b, r, s). There are no functional fluents except constants.We define the precondition axiom and the successor state axiom for action move and omit the others.• Precondition Axiom:• Successor State Axiom:Poss(move(b, r1, r2), s) ⇔ book(b, s) ∧ room(r1, s) ∧ room(r2, s) ∧ in(b, r1, s) ∧ r1 (cid:20)= r2.(cid:2)Poss(cid:3)(cid:3)move(b, r1, r2), s(cid:2)(cid:2)(cid:2)(cid:10) = bb(cid:2)(cid:2)(cid:10) = bb(cid:2)(cid:10) = r1r(cid:2)(cid:10) = r1r¬∧∧(cid:3)⇔(cid:2)∧⇒ ∀b(cid:3)(cid:3)(cid:10)(cid:10)∀rin⇒ FALSE ∧(cid:2)(cid:2)(cid:10) = b∧ ¬b(cid:3)(cid:3)(cid:2)(cid:10)(cid:10)(cid:2)b(cid:2)(cid:2)b(cid:3)(cid:2)(cid:3)(cid:3), do, r(cid:3)(cid:10) = b(cid:2)∧rmove(b, r1, r2), s∧(cid:10) = r2(cid:10) = r2⇒ in(cid:2)r(cid:3)(cid:3)(cid:3)(cid:2)b, r(cid:3)(cid:3)⇒ TRUE(cid:3)(cid:3)(cid:3)(cid:10)(cid:10), sWe write this successor-state axiom in this way to help usage in Section 5. Indeed, the successor-state axiom can besimplified logically.2.3. Filtering semanticsFor filtering we are interested in answering queries over values of fluents after actions and observations occur fromtime 0. Stated in the language of situation calculus, we are concerned with queries uniform in s, for some ground situationterm s.Thus, in our filtering language there is a predicate corresponding to each relational fluent of our situation calculuslanguage. Those predicates do not take any arguments of sort situation. Roughly speaking, the truth value of a predicatechanges from one situation to another. We represent predicates re-using the same symbols of relational fluents but withdifferent arity (one less than the corresponding relational fluent).Thus, in the following definition we drop all situation terms. The values of all predicates and functions are consideredin the same situation. Transition from situation s to do(a, s) (performing action a) changes the values of predicates andfunctions.The following is a formal definition of transition relations and filtering over FOL structures. The generality of the systemdemands attention to specific details regarding cardinality of sets and the relationship between FOL formulas and the classesof structures characterized by these formulas. We bring those details first.Let κ be a fixed infinite cardinality κ (cid:3) ℵ0 (we keep this cardinality unspecified to emphasize the generality of thefollowing development). The vocabulary for describing a state of our system is (cid:13)P, F , C(cid:14), with P a set of predicate symbols,F a set of function symbols, and C a set of constant symbols. Let S be the set of all FOL structures S over (cid:13)P, F , C(cid:14) thathave cardinality (cid:22)S(cid:22) at most κ . Progression and filtering semantics are as follows.Definition 5 (Transition relation for FOL structures). For an action theory D, a structure S, and a ground action a, we define atransition relation RD as follows.RD =(cid:6)(cid:4)(cid:10)(cid:5) (cid:7)(cid:7) |(cid:9)S preconda, S, S(cid:10) ∈ S and |S| = |S(cid:7)(cid:8)(cid:7) |(cid:9)S succp,a(v 1, . . . , vm)(cid:10)|(cid:13)v 1, . . . , vm(cid:14) ∈ |S|m(cid:6)(cid:13)v 1, . . . , vm, vm+1(cid:14) ∈ |S|m+1,(cid:7)(cid:7) |(cid:9)S succ f ,a(v 1, . . . , vm, vm+1)S, a, S(cid:6)(cid:10) =(cid:10) =p Sf S(cid:8)(cid:8)In this definition v i is an individual of |S|.Note that action a is a parameterized action. The parameters are constants (e.g., move(C++, Office, Lounge)). For a =A(u1, . . . , un), preconda is equal to precond A(u1, . . . , un) which is defined by the precondition axiom of the action symbol A.Now, we define filtering semantics using transition relation for FOL structures.Definition 6 (First-order logical filtering semantics). Let (cid:8) be a set of FOL structures. The filtering of a sequence of actions andobservations (cid:13)a1, o1, . . . , at, ot(cid:14) is defined as follows ((cid:9) refers to the empty sequence).(1) Filter[(cid:9)]((cid:8)) = (cid:8);(2) Filter[a]((cid:8)) = {S(3) Filter[o]((cid:8)) = {S ∈ (cid:8) | |(cid:9)S o};(4) Filter[(cid:13)ai, oi, . . . , at, ot(cid:14)]((cid:8)) = Filter[(cid:13)ai+1, oi+1, . . . , at, ot(cid:14)](Filter[oi](Filter[ai]((cid:8)))).(cid:10) | S ∈ (cid:8), (cid:13)S, a, S(cid:10)(cid:14) ∈ RD};We call Step (2) progression with a and Step (3) filtering with o.A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219199In the definition above, filtering is applied to a set of FOL structures. A belief state formula is a FOL formula in the vocab-ulary (cid:13)P, F , C(cid:14), with P, F , C the predicate, function, and constant symbols that correspond to relational fluents, functionalfluents, and constants (essentially, they are the same only without a situation argument). For example, the predicate in(b, r)corresponds to relational fluent in(b, r, s) in the situation calculus.Every belief state formula ψ has a corresponding belief state, σψ = {S ∈ S | |(cid:9)S ψ}. In the opposite direction, everybelief state σ has many belief state formulas to which it corresponds, and we distinguish one such formula, the theory ofσ . The theory of σ , Th(σ ), is the set of all first-order sentences with vocabulary (cid:13)P, F , C(cid:14) that all structures in σ satisfy.Th(σ ) = {φ | φ in vocabulary (cid:13)P, F , C(cid:14), ∀S ∈ σ |(cid:9)S φ}.Several delicate points are worth mentioning. First, our choice of κ affects S and the rest of the sets discussedabove. Nonetheless, taking σψ with κ (cid:10) > κ does not change Th(σψ ). Specifically, Th(σ κψ ). This results from theLowenheim–Skolem theorem. Thus, our choice of κ is not important as long as it is at least countable (ℵ0) and is at leastas large as the number of symbols in the vocabulary (when the vocabulary is infinitely large).ψ ) = Th(σ κ (cid:10)3. Filtering of FOL formulasApproaches to filtering actions and observations that at any stage enumerate all the structures in a belief state areimpractical because almost all belief states are of infinite sizes. Even when those are finite, an enumeration approach doesnot scale to large domains. An alternative approach is to perform logical progression in a form similar to the one describedby [40,46]. In our work now we wish to do so efficiently in the context of nondeterministic actions and observations.In this section we present a naive algorithm that filters belief state formulas directly. This algorithm serves as a startingpoint for Sections 4 and 5, where we propose efficient algorithms. We also present distribution properties of filtering overthe logical connectives ∧, ∨, ¬, and examine the theoretical limitations of formula filtering. These will guide us in Section 5,and allow us to present classes of systems that are not subject to those limitations and can be tracked in polynomial time(with a compact representation) indefinitely.From here forth we assume that our first-order language has no functional symbols except constants. This assumptionhelp present our results more concisely, and is does not restrict the applicability of our results.3.1. Filtering as consequence findingIn this section we show how to progress an initial database represented by a logical formula after applying a singleaction or observation. The result of progression is a new database that the progression algorithm can use afterwards.(cid:10)r(cid:10)1, . . . , gr/gSuppose that P = {g1, . . . , gr} is the set of all constants and predicates of our first-order language. We define a newas the set ofi( y1, . . . , yn) = gi( y1, . . . , yn)[P/P (cid:10)] where [P/P (cid:10)] is a shorthand for}. We view P as the set of constants and predicates in situation s, and P (cid:10)(cid:10)set of symbols P (cid:10) = {g1, . . . , gconstants and predicates in situation do(a, s). Thus, g[g1/gWe filter a belief-state formula as follows. (We reuse the notation Filter[·](·) for filtering a belief-state formula and also aset of formulas.) Let ψ be a belief state formula (a formula that represent all the possible structures of the current state ofthe world), a be a ground action, Cn(Ψ ) be the set of FOL consequences of Ψ (i.e., formulas φ in FOL such that Ψ |(cid:9) φ), andL(Ψ ) be the set of logical consequences of Ψ in the language L. We write CnL(Ψ ), when L is a set of symbols to meanCnL(L)(Ψ ).Cn].(cid:10)r(cid:10)1.Filter[a](ψ) =(cid:9)(cid:9)ψ ∧ preconda∧P (cid:10)Cn(cid:10)i(cid:10)i∀ y1, . . . , ym, p(cid:10)i( y1, . . . , ym) ⇔ succpi ,a( y1, . . . , ym) ∧(cid:11)(cid:11)∀z, f(cid:10)i= z ⇔ succ f i ,a(z)[P (cid:10)/P]2.Filter[o](ψ) = ψ ∧ o(1)When we filter with action a we assert that its precondition held in the last world state. If the action is not executableon the belief state, the new belief state formula would be FALSE which indicates an empty set of structures (meaning thatthere is no structure of the current belief state in which the action was executable). We also define filtering of a set offormulas enabling a recursive use of the previous equations. For a set of formulas Γ ,(cid:9)(cid:9)P (cid:10)CnΓ ∪ {preconda} ∪∀ y1, . . . , ym, p(cid:8)(cid:10)i( y1, . . . , ym) ⇔ succpi ,a( y1, . . . , ym)∪1.Filter[a](Γ ) =(cid:12)(cid:6)i200A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219∀z, f(cid:10)i(cid:8)= z ⇔ succ f i ,a(z)(cid:11)(cid:11)(cid:12)(cid:6)i[P (cid:10)/P]2.Filter[o](Γ ) = Γ ∪ {o}(2)We prove in the following theorem that this definition of filtering approximates the semantics of Definition 6.Theorem 7. Let ψ be a belief state formula, and let a be a ground action, then(cid:2)Filter[a]{S | |(cid:9)S ψ}(cid:3)⊆(cid:6)(cid:10)S(cid:7)(cid:8)(cid:7) |(cid:9)S(cid:10) Filter[a](ψ)Proof. See Appendix A.1. (cid:3)[40] showed that progression is not always first-order definable. They showed that progression always exists as a set ofsecond-order sentences for finite initial databases. Therefore, the two sides of Theorem 7 are not equivalent since formula (1)is in FOL. In other words, FOL is not strong enough to model the progression of the initial database. However, the followingcorollary shows that the two sides of Theorem 7 would be equal if the progression of a database is FOL definable.Corollary 8. Let ψ be a first-order belief state formula. If progression of ψ is first-order definable then(cid:2)Filter[a]{S | |(cid:9)S ψ}(cid:3)=(cid:6)(cid:10)S(cid:7)(cid:8)(cid:7) |(cid:9)S(cid:10) Filter[a](ψ)Proof. See Appendix A.2. (cid:3)3.2. Deduction-based algorithm for filteringOur baseline algorithm computes Filter[(cid:13)a1, o1, . . . , at, ot(cid:14)](ψ) by iteratively applying filtering of a belief-state formulawith an action and an observation. It is not too practical, and is presented here for reference and contrast with later meth-ods. Since every step may generate an infinite set of sentences, we reformulate this intuition into the following algorithm.(1) Set ψ0 = ψ , and ψi = oi for all 0 < i (cid:2) t.(2) Concurrently for all 0 < i (cid:2) t do(a) Apply a first-order consequence finder (e.g., resolution [32]) to generate sentences in Filter[ai](ψi−1) using for-mula (1).(b) When a sentence is generated, add it to ψi .This algorithm is correct for filtering, as shown below. We discuss methods for consequence finding that can be usedhere further in Section 4.2.2. In Sections 4, 5 we provide algorithms for generating the formula that is the result of filtering.3.3. Sequences of actions and observationsThis section shows that iterative application of formula-filtering steps loses no information with respect to answeringqueries about the outcome of a sequence of actions and observations. It shows that we can discard the previous databaseafter filtering every action and start using the database that we obtain after performing the progression step for that action.To show so we use the first-order situation calculus that we described above. It follows the treatment of situation calculusby Reiter [53].The development in this section can be seen to follow immediately from the following more general results by [40,64].Theorem 9. (See [40, Prop. 4.10].) Let φ(s) be a formula uniform in s, and let (cid:19)a = (cid:13)a1, . . . , at(cid:14) be a sequence of ground action terms(do((cid:19)a, s) is a shorthand for do(at, do(at−1, do(. . . , do(a1, s), . . .)))). Then, for DSα the second-order filtering to Sα and FSα the first-order filtering to Sα ,(D − DS0 ) ∪ DSα|(cid:9) Sα (cid:2) do((cid:19)a, Sα) ∧ φ(cid:3)(cid:2)do((cid:19)a, Sα)iff(D − DS0 ) ∪ FSα|(cid:9) Sα (cid:2) do((cid:19)a, Sα) ∧ φ(cid:2)(cid:3)do((cid:19)a, Sα)We bring a more complete development below to help explain the foundations of our algorithm in Section 3.2 and ourresults that follow in Sections 4 and 5.We divide our action theory D into two parts, the initial database DS0 and the rest Dg . Therefore, D = Dg ∪ DS0 . Wedefine the language of an action theory as follows.A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219201We use Cnst (Ψ ) as the set of logical consequences of Ψ uniform in st = do(at, do(at−1, . . . , do(a1, S0))).Suppose that we want to progress our initial database DS0 with action a1. Recall that D = Σ ∪ Dss ∪ Dap ∪ Duna ∪ DS0 .To progress D with action a1, not all the axioms are required [33]. Instead of including all successor state and preconditionaxioms in the action theory, we just need precondition and successor state axioms related to action a1 (with the sameaction symbol). To retrieve these axioms, in all the successor state and precondition axioms with the same action symbolas a1 we replace their parameters with the constants appearing in ground action a1. We refer to this subset of successorstate axioms as Dss0,1 . The subset of precondition axioms corresponding to action a1 is Dap0,1 . For example, if our firstaction is move(C++, Lounge, Office), then axiom(cid:2)move(x1, x2, x3), s(cid:2)(cid:2)(cid:3)Poss(cid:2)⇒ ∀ y1, . . . , ∀ ympy1, . . . , ym, domove(x1, x2, x3), swould be replaced by(cid:3)(cid:3)(cid:3)⇔ succp,move(x1, x2, x3, y1, . . . , ym, s)Poss(cid:2)(cid:2)move(C++, Lounge, Office), S0(cid:2)(cid:3)y1, . . . , ym, do(a1, S0)p(cid:3)⇒ ∀ y1, . . . , ∀ ym(cid:3)⇔ succp,move(C++, Lounge, Office, y1, . . . , ym, S0)All other axioms are not needed for progression with a1. For a ground action term a1 we are looking for a set of sen-tences D1 uniform in do(a1, S0) that can serve as a new initial database.Define Ds1 as the first-order progression of DS0 with a, the set of sentences uniform in do(a1, S0) that are entailed by D.(cid:10)|(cid:9) ψ iff D |(cid:9) ψ for every first-order sentence ψ uniform in a situation sIf we show that Dg ∪ Ds1such that do(a1, S0) (cid:16) s,then Ds1 can be used as a new initial database for further filtering. The following theorem states this result for two-stepprogression.(cid:10)Theorem 10. (Similar to [40, Prop. 4.10].) Let DS0 be an initial database for an action theory D (D = Dg ∪ DS0 ). Define Dst for t (cid:3) 1as follows:Dst= Cnst (Dsst−1,t∪ Dapt−1,t∪ Dst−1 )Then, for all ψ uniform in do(at, do(at−1, . . . , do(a1, S0))),Dg ∪ Dst|(cid:9) ψ iff Dg ∪ DS0|(cid:9) ψProof. See Appendix A.4. (cid:3)Theorem 10 is a different derivation of Lin and Reiters’ result that applies to filtering. [40] Proposition 4.10 showed thatfirst-order progression is enough for consequences about any specific future ground situation term. Filtering is interested inanswering queries about given ground situation terms, so this theorem implies that first-order progression answers filteringqueries correctly.For example, in our book-keeper example ifDS0=(cid:6)(cid:8)book(B, S0), room(R, S0), in(B, R, S0)and the first action is return(B, R), then Ds1 is logically equivalent to(cid:2)(cid:6)(cid:2)(cid:2)(cid:3)B, do(a1, S0), room(cid:3)R, do(a1, S0), ¬inB, R, do(a1, S0)book(cid:3)(cid:8)4. Factored filteringIn this section we present one of two main contributions of this paper, namely, a polynomial-time algorithm that com-putes logical filtering exactly for a significant class of transition systems. For the systems that do not fall within this classour algorithm gives an approximation to the filtering.Our algorithm in the next section decompose filtering of FOL formulas to the filtering atomic subformulas. Recall thata FOL formula is atomic (an atom), if it is a predicate (or =) applied to well-founded terms, i.e. it includes no quantifiersor connectives. In what follows we prove several decomposition properties of filtering of FOL formulas. Our algorithm usesthose properties and filters subformulas of a formula later combining the results.202A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–2194.1. Distribution propertiesSeveral distribution properties hold for logical filtering. We can decompose the filtering of a formula ϕ along logicalconnectives ∧, ∨, ¬, ∀, ∃.Theorem 11. Let a be an action, and ϕ and ψ be FOL formulas. Assume that filtering of a is definable in FOL. Then,(1) Filter[a](ϕ ∨ ψ) ≡ Filter[a](ϕ) ∨ Filter[a](ψ),(2) |(cid:9) Filter[a](ϕ ∧ ψ) ⇒ Filter[a](ϕ) ∧ Filter[a](ψ),(3) |(cid:9) Filter[a](¬ϕ) ⇐ ¬Filter[a](ϕ) ∧ Filter[a](TRUE),(4) Filter[a](∃xϕ(x)) ≡ ∃xFilter[a](ϕ( X))[X/x].( X is a new constant symbol.)Proof. See Appendix A.6. (cid:3)Thus, filtering ϕ ∨ ψ with a can be done by filtering ϕ and ψ separately and then combining the results. Also, filteringϕ ∧ ψ can be approximated by filtering ϕ and ψ separately and then combining the results. The formula that is theconjunction of the filtering of ϕ and ψ separately is a logically weaker formula than the filtering of ϕ ∧ ψ . Thus, everythingthat is entailed by that combination is also true in every structure of the original filtering.Filtering of ¬ϕ can be approximated in the other direction. The formula that is the negation of the filtering of ϕ is astronger formula than the filtering of ¬ϕ. Thus, everything that follows from the filtering of ¬ϕ necessarily holds in thenegation of the filtering of ϕ and that of TRUE. Also filtering ∃xϕ(x) can be done by filtering ϕ( X) with X being a newconstant symbol and then replacing every X in the resulted formula with variable x and having an existential quantifierover x.While 2 and 3 are only approximations (according to Theorem 11), they can be used as an exact answer in somedomains. Our following Theorem 13 gives a stronger statement for actions that act as 1:1 partial functions on the structuresin which they are executable.Definition 12 (1:1 actions). Action a is 1:1 if for every structure S(cid:10)there is at most one S such that RD(S, a, S(cid:10)).Recall the example from Section 2.2.1. There, action a = move(C++, Office, Lounge) is a one-to-one mapping between FOLstructures. Assume that we define another action moveto(C++, Lounge) which moves book C++ to room Lounge regardlessof where the book is before moving. This new action is not 1:1 because it maps different FOL structures to the same one:e.g. it maps structures whose book C++ locations are different and otherwise are identical to the same structure.In many domains an action which is not one-to-one such as moveto can be replaced easily with a 1:1 action such asmove with no loss in the expressivity of the domain (e.g. turning on the light can be replaced by flipping the light switch).Domains that only include 1:1 actions are called 1:1 domains. The next theorem presents distribution-over-connectivesproperties for 1:1 domains.Theorem 13 (Distribution properties for 1:1 domains). Let a be a 1:1 action, and ϕ and ψ be formulas. Assume that filtering of a isdefinable in FOL. Then,(1) Filter[a](ϕ ∨ ψ) ≡ Filter[a](ϕ) ∨ Filter[a](ψ),(2) Filter[a](ϕ ∧ ψ) ≡ Filter[a](ϕ) ∧ Filter[a](ψ),(3) Filter[a](¬ϕ) ≡ ¬Filter[a](ϕ) ∧ Filter[a](TRUE),(4) Filter[a](∃xϕ(x)) ≡ ∃xFilter[a](ϕ(L))[L/x].Proof. See Appendix A.8. (cid:3)The decomposition strategy offered by this theorem is not only an approximation but an exact computation for 1:1domains. These distribution properties are enough for decomposing the filtering of any FOL formula into the filtering ofits atomic subformulas. We can decompose the filtering of any FOL formula into the filtering of atomic formulas by usingdistribution properties proved above. As an example, universally quantified formulas are decomposed as follows:• Universal quantifier over a formula: (by rule 3 and rule 4)(cid:2)Filter[a](cid:3)∀xϕ(x)(cid:2)(cid:3)¬∃x¬ϕ(x)≡ Filter[a](cid:3)(cid:2)3≡ ¬Filter[a]∃x¬ϕ(x)(cid:2)4≡ ¬∃xFilter[a](cid:3)¬ϕ(L)∧ Filter[a](TRUE)∧ Filter[a](TRUE)[L/x]A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219203PROCEDURE FF((cid:13)ai , oi (cid:14)0<i(cid:2)t , ψ )∀i, ai an action, oi an observation, ψ a belief-state formula.(1) if t = 0, return ψ .(2) return ot ∧ FF-Step(at , precondat∧ FF((cid:13)ai , oi (cid:14)0<i(cid:2)(t−1), ψ )).PROCEDURE FF-Step(a, ψ )a an action, ψ a belief-state formula.(1) if ψ is an atomic formula, then return Single-Literal-Filtering(a, ψ ).(2) else, use distribution properties as follows:(3)(4)(5)(6)if ψ = φ ∨ ϕ, return FF-Step(a, φ) ∨ FF-Step(a, ϕ).elseif ψ = φ ∧ ϕ, return FF-Step(a, φ) ∧ FF-Step(a, ϕ).elseif ψ = ¬φ, return ¬ FF-Step(a, φ) ∧ FF-Step(a, TRUE).elseif ψ = ∃x φ(x), return ∃x FF-Step(a, φ(L))[L/x].Fig. 2. Factored filtering of a FOL formula in a 1:1 domain.• Universal quantifier over conjunction: (by rule 2)(cid:2)Filter[a]∀xϕ(x) ∧ ψ(x)(cid:2)(cid:3) 2≡ Filter[a](cid:3)∀x ϕ(x)(cid:2)∧ Filter[a](cid:3)∀xψ(x)• Universal quantifier over negation: (by rule 3 and rule 4)(cid:2)Filter[a](cid:3)∀x¬ϕ(x)(cid:2)(cid:3)¬∃x ϕ(x)≡ Filter[a](cid:3)(cid:2)3,4≡ ¬∃xFilter[a]ϕ(L)[L/x]∧ Filter[a](TRUE)• Universal quantifier over disjunction: (by rule 2, rule 3, and rule 4)(cid:2)Filter[a](cid:3)∀xϕ(x) ∨ ψ(x)4.2. Factored filtering(cid:2)≡ Filter[a](cid:2)3,4≡ ¬∃xFilter[a](cid:3)¬∃x ¬ϕ(x) ∧ ¬ψ(x)(cid:3)¬ϕ(L) ∧ ¬ψ(L)[L/x]∧ Filter[a](TRUE)Our Factored Filtering (FF) algorithm for 1:1 domains is presented in Fig. 2. It relies on Theorems 8, 11, and 13. Thenumber of closed atomic subformulas of a domain is finite, if the number of constants is finite. Therefore, in finite domainswe can calculate filtering of all atomic formulas as a preprocessing step and retrieve them later. (Note that the argumentsof these atomic formulas are either the constants associated with existential quantifiers or the constants mentioned in theinitial belief state, the set of axioms, or the observations.) We discuss this preprocessing step below.Theorem 14. Let D be a basic action theory, and ψ an initial belief state. Algorithm FF (Fig. 2) returns a formula that is logicallyequivalent to Filter[a](ψ), if a is 1:1 in D and precompilation of D with respect to a has a finite representation. It runs in time∧ ψ| × F ) when the filtering of all the atomic formulas are given and have finite representation, and F is the time neededO (|precondato retrieve the filtering of an atomic formula.Proof. See Appendix A.9. (cid:3)4.2.1. Example computation with FFFirst, consider a push-button action that permutes the states of two locks, d, e as follows:d, ¬e ⇒ d, e ⇒ ¬d, e ⇒ ¬d, ¬e ⇒ d, ¬eSuccessor-state axioms for this domain are(cid:2)d(cid:2)e(cid:3)do(a, s)(cid:3)do(a, s)≡ a = push ∧ ¬e(s) ∨ a (cid:20)= push ∧ d(s)≡ a = push ∧ d(s) ∨ a (cid:20)= push ∧ e(s)Precompilation of progression of the four literals with A = push yieldsFilter[ A](d) ≡ eFilter[ A](¬d) ≡ ¬eFilter[ A](e) ≡ ¬dFilter[ A](¬e) ≡ d(3)(4)204A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219A second example is when we assume that our action has a precondition ∀w up(w), i.e., the action changes the world(cid:10) = push2. Successor-state axioms forwhen ∀w up(w) and the world stays the same otherwise. We call the new action Athis domain are(cid:2)(cid:2)(cid:2)(cid:3)do(a, s)(cid:3)do(a, s)d(cid:2)e≡ a = push2 ∧d(s) ∧(cid:2)a (cid:20)= push2 ∨(cid:2)(cid:2)≡ a = push2 ∧(cid:3)(cid:3)∨∧ ¬e(s)∀w up(w)(cid:2)(cid:2)a = push2 ∧ ¬(cid:3)(cid:3)∨∧ d(s)∀w up(w)(cid:2)(cid:2)a = push2 ∧ ¬(cid:2)a (cid:20)= push2 ∨(Successor-state axioms are of the form F ((cid:19)x, do(a, s)) ≡ γ +e(s) ∧∀w up(w)∀w up(w)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)F ((cid:19)x, a) ∨ (F ((cid:19)x, s) ∧ ¬γ −F ((cid:19)x, a) are dis-junctions of formulas of the form ∃(cid:19)z[a = A((cid:19)y) ∧ φ((cid:19)y)] with φ quantifier free uniform in s and (cid:19)y the exclusive union of (cid:19)x, (cid:19)z.)(cid:10) = push2 yieldsPrecompilation of progression of the three atomic formulas with A(cid:3)F ((cid:19)x, a)), and γ +F ((cid:19)x, a), γ −(cid:3)(cid:13)(5)FilterFilterFilterAAA(cid:13)(cid:13)(cid:13)(cid:10)(cid:10)(cid:10)(cid:10)(cid:2)(cid:2)(cid:2)(cid:2)(cid:14)(e) ≡(cid:14)(d) ≡(cid:14)(cid:2)(cid:3)∀w up(w)(cid:3)∀w up(w)(cid:3)≡ up(w)up(w)(cid:14)(TRUE) ≡ TRUE⇒ ¬d(cid:3)∧⇒ e∧(cid:2)(cid:2)(cid:2)¬(cid:2)¬(cid:3)∀w up(w)(cid:3)∀w up(w)⇒ e(cid:3)⇒ d(Filter[ AFilterA(cid:10)](¬e), Filter[ A(cid:10)](TRUE) ∧ ¬F itler[ A(cid:10)](¬d), Filter[ A(6)(cid:10)](¬ϕ) ≡(cid:10)](ϕ).) This precompilation is then used as the results returned by subroutine Single-Literal-(cid:10)](¬up(w)) are computed by noticing that Aso Filter[ Ais 1:1,(cid:10)Filter[ AFiltering.4.2.2. PrecompilationAlgorithm FF uses a subroutine for filtering atoms (recall, atoms are predicate symbols applied to well-founded terms,i.e. including no quantifiers or logical connectives). Such filtering of atomic formulas can be done at a compilation (prepro-cessing) stage for a domain, if Filter[a](P (x1, . . . , xl)) is finitely axiomatizable (in FOL), for every action a and predicate P .Corollary 15. Let a be an action term, P (t1, . . . , tl) an atom, and t1, . . . , tl constant symbols. Let X1, . . . , Xl be new constant sym-bols. If Filter[a](P ( X1, . . . , Xl)) has a finite axiomatization in FOL and ϕ is such an axiomatization, then Filter[a](P (t1, . . . , tl)) ≡ϕ[X1/t1,..., Xl/tl].Proof. Follows the same proof as equivalence (4) in Theorem 11. (cid:3)Thus, if the domain description language includes no function symbols and the language is finite (we assume both), thenthe compilation needs to occur only once per predicate-and-action pair.Notice that these assumptions are not related to the size of the domain, which may be infinite. Our assumptions permitFOL theories for time step 0 that have only infinite models. For example, consider the example in Section 4.2.1 above. Anexample belief state for time step 0 is(cid:2)(cid:3)up(w) ⇒ up(x)∀w∃x after(w, x) ∧∀w, x after(w, x) ⇒ x (cid:20)= w∀x, y, z after(x, y) ∧ after( y, z) ⇒ after(x, z)Here, the predicate after(.,.) is a strict order relation and every element has at least one subsequent other element. Thisforces the universe of every model to be of infinite size. The filtering of action push2 holds without change.Thus, filtering of atoms can be done at a compilation (preprocessing) stage. Such a compilation would be done once forthe domain, and would then be used for all filtering needs within that domain.For n actions and m predicates, the precompilation would be done for n · m pairs. Every such compilation of an atom,P ( (cid:19)X), and action, a( (cid:19)Y ), can be done by applying FOL consequence finding (e.g. [32,57,58,42,2]) of sentences uniform indo((cid:19)y, s) from P ((cid:19)x, s) ∧ Σ ∪ Dss ∪ Dap ∪ Duna.If our action theory D also conforms to other restrictions (e.g. strictly local actions in [65]), the precompilation can be), even when polynomial-sizedone directly (in [65,64] the size of the resulting formula per compilation step is Ω(2p·ckrepresentation is possible, so the result of precompilation may undermine the efficiency and output-compactness of FF).Thus, any of the above methods can be used to implement Single-Literal-Filtering of Fig. 2 and precompute it in acompilation stage into a table SLF that has size O (n · m), storing every compilation of literal and ground action term. Then,the computation with FF of progression of ψ with action a((cid:19)y) uses Single-Literal-Filtering as a table lookup, and takes bothtime and output size in O (|SLF| · |ψ|).A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–2192055. Filtering by casesOur naive filtering algorithm from Section 3 uses consequence finding tools which do not scale to large domains. Theo-rem 17 below suggests a different reasoning procedure by which updates are broken into smaller local updates. Before that,we need to define the set of derived-formulas of a set of predicates.Definition 16 (Derived-formulas). Let p1, . . . , pn be n closed predicates. DF(p1, . . . , pn) is the set of derived-formulas ofp1, . . . , pn which is defined inductively as follows:(1) {p1, . . . , pn} ⊂ DF(p1, . . . , pn),(2) ¬φ ∈ DF(p1, . . . , pn) if φ ∈ DF(p1, . . . , pn),(3) φ ∧ ψ ∈ DF(p1, . . . , pn) if {φ, ψ} ⊂ DF(p1, . . . , pn),(4) ∀x φ( y1, . . . , ym)[ y1/x1,..., ym/xm] if φ( y1, . . . , ym) ∈ DF(p1, . . . , pn).For example,∀x∀ y book(x) ∧ room( y) ∧ in(x, y) ∈ DF(cid:3)book(x1), room(x2), in(x3, x4)because book(x1) ∧ room(x2) ∧ in(x3, x4) is a derived-formula and we can perform rule 4 on this formula and substitute x1and x3 by x, and x2 and x4 by y.(cid:2)Theorem 17. Let a be a ground action, ψ be a belief state formula, and p1, . . . , pn be n closed predicates in our action theory. Then,(cid:7)(cid:7) ψ ∧ precondaΦ(p1, . . . , pn) ∈ DF(p1, . . . , pn)|(cid:9) Φ(p1, . . . , pn)[p1/succp1,a,...,pn/succpn,a]Filter[a](ψ) ≡(cid:6)(cid:8)(7)Proof. See Appendix A.10. (cid:3)In this formula, every Φ in DF(p1, . . . , pn) that is entailed by our belief state and action precondition is in the filtering.Generally, generating all Φs is impossible in practice because there are infinitely many such Φs. In the following sections, weprovide simpler closed-form solutions for two special cases of dynamic domains.1 These give rise to practical (polynomial)algorithms.5.1. Unit-case successor state axiomsBy definition of successor state axioms, for every pair of actions and predicates exactly one successor state axiom isprovided. The successor state axiom for action a = A(x1, . . . , xn) and predicate p can be rewritten in the following form:⇒ ∀ y1, . . . , ∀ ymp(cid:3)p(x1, . . . , xn, y1, . . . , ym, s)(cid:2)Poss⇔(cid:3)A(x1, . . . , xn), s(cid:2)case1p(cid:2)⇒ φ1casel pp⇒ φ∧ · · · ∧(cid:2)∧¬case1pl p∧ · · · ∧ ¬casep(cid:3)l pp (x1, . . . , xn, y1, . . . , ym, s)l p+1p⇒ φ(cid:3)(cid:3)(x1, . . . , xn, y1, . . . , ym, s)(cid:2)(cid:2)(cid:3)y1, . . . , ym, do(a, s)jp is of the form ( yjkp ) (variable xwhere caseis anargument of predicate p) and each variable assignment satisfies at most one of the cases. Note that the set of variables in eachcase can be a subset of variables in p and a.is an argument of action a and variable yj1p ) ∧ · · · ∧ ( y= x= xj1pj1pj1pjkpNotice that the algorithms presented in this section and the following require Unique Names Axioms for objects. This isbecause we would like to determine which case a ground predicate corresponds to without checking if the constants areequal, e.g., p(B) is not from the case p( y, do(a, s)) ⇔ ( y = A) ⇒ TRUE ( A and B are constants). Also we would like to beable to say if two instantiated predicates are unifiable without adding equality preconditions, e.g., p( A, y) is not unifiablewith p(B, C) with unique name assumption. However, without this assumption any two predicates with the same predicatesymbols are unifiable (if (B = A) then p(B, C) and p( A, y) are unifiable).A successor state axiom is called unit-case successor state axiom ifit can be rewritten in a form where everyφ jp(x1, . . . , xn, y1, . . . , ym, s) (1 (cid:2) j (cid:2) l p + 1) is a unit clause. Our book-carrying robot example from Section 2.2.1 is writtenin this form. The last term in the precondition assures that the cases are mutually exclusive.We divide a unit-case successor state axiom into multiple instantiated axioms.1 Those domains were shown independently to have finite strong progression in FOL [65].206A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219PROCEDURE UCF ((cid:13)ai , oi (cid:14)0<i(cid:2)t , ψ )∀i, ai an action, oi an observation, ψ a belief-state formula.(1) if t = 0, return ψ .(2) ψt−1 = UCF((cid:13)ai , oi (cid:14)0<i(cid:2)(t−1), ψ ).(3) return ot ∧ Filter-True(at ) ∧ UCStep(at , precondat∧ ψt−1)., for every case of each,if unifiable(φp(z1, . . . , zm+n), φp(cid:10) (z1, . . . , zm+n)),[Poss( A(x1, . . . , xn), s) ⇒ (condp ⇒ (p(z1, . . . , zm, do(a, s)) ⇔φp(z1, . . . , zm+n, s))) is a successor state axiom of a casea]if φp(z1, . . . , zm+n) = true, S = S ∪ {condp ⇒ p(z1, . . . , zm)}elseif φp (z1, . . . , zm+n) = false, S = S ∪ {condp ⇒ ¬p(z1, . . . , zm)}(cid:10)PROCEDURE Filter-True( A(x1, . . . , xn)) [Done once and cashed]A(x1, . . . , xn) an action.(1) S = ∅(2) for every predicate symbol p, for every case of p,(3)(4)(5)(6)(7) for every predicate symbol pair p, p(8)(9)(10)(11)(12)(13)(14)(15)(16)(17)(18)(19)(20)(21)(22) returnS = S ∪ {((condp ∧ condp(cid:10) ) ⇒ (p(z1, . . . , zm) ⇔(cid:10)(z1, . . . , zm)))mgu(φp ,φp(cid:10) )}pelseif unifiable(φp(z1, . . . , zm+n), ¬φp(cid:10) (z1, . . . , zm+n)),S = S ∪ {((condp ∧ condp(cid:10) ) ⇒ (p(z1, . . . , zm) ⇔(cid:10)(z1, . . . , zm)))mgu(φp ,φp¬pelseif φp (z1, . . . , zm+n) = ∀x q(x), φp(cid:10) (z1, . . . , zm+n) = q(T ),S = S ∪ {(condp ∧ condp(cid:10) ) ⇒ (¬p(z1, . . . , zm) ∨ pelseif φp (z1, . . . , zm+n) = ∀x q(x), φp(cid:10) (z1, . . . , zm+n) = ¬q(T ),S = S ∪ {(condp ∧ condp(cid:10) ) ⇒ (¬p(z1, . . . , zm) ∨ ¬pelseif φp (z1, . . . , zm+n) = ∃x q(x), φp(cid:10) (z1, . . . , zm+n) = q(T ),S = S ∪ {(condp ∧ condp(cid:10) ) ⇒ (p(z1, . . . , zm) ∨ ¬pelseif φp (z1, . . . , zm+n) = ∃x q(x), φp(cid:10) (z1, . . . , zm+n) = ¬q(T ),S = S ∪ {(condp ∧ condp(cid:10) ) ⇒ (p(z1, . . . , zm) ∨ p(cid:10) )}(cid:15)ϕ∈S ϕ.(cid:10)(z1, . . . , zm))}(cid:10)(z1, . . . , zm))}(cid:10)(z1, . . . , zm))}(cid:10)(z1, . . . , zm))}a condp is either TRUE or (¬case1p∧ · · · ∧ ¬casel pp ) using Definition 18.Fig. 3. Unit-case filtering.Definition 18. Instantiated successor state axioms for predicate p are:• Poss( A(x1, . . . , xn), s) ⇒ (p( y1, . . . , ym, do(a, s)) ⇔ φ j• Poss( A(x1, . . . , xn), s) ⇒ ∀ y1, . . . , ym(¬case1pp(x1, . . . , xn, y1, . . . , ym, s))[ yjp /xjp] for all 1 (cid:2) j (cid:2) l p ,lpp ) ⇒ (p( y1, . . . , ym, do(a, s)) ⇔ φ∧· · ·∧¬caselp +1p(x1, . . . , xn, y1, . . . , ym, s)).jpjp/x] is the substitution corresponding to case[ yinto cases. Note that all instantiated successor state axioms are in the form(cid:2)jp and xjp ( y(cid:2)(cid:3)(cid:2)(cid:2)PossA(x1, . . . , xn), s⇒condp ⇒p(cid:3)z1, . . . , zm, do(a, s)⇔ φp(z1, . . . , zm+n, s)(cid:3)(cid:3)jp are sequences of variables). This process is called breakingwhere in some of them condp is TRUE (i is an enumeration of all instantiated successor state axioms of action a). Inthis formula zp is either a variable which is universally quantified or one of the parameters of action A(x1, . . . , xn). Theparameters of action A(x1, . . . , xn) are free variables.Figs. 3 and 4 show the Unit-Case Filtering (UCF) algorithm. This algorithm is applicable to 1:1 domains whose successorstate axioms are unit-case. Algorithm UCF is actually a way to compute every Φ(p1, . . . , pn) in formula (7). Here, p1, . . . , pnare the predicates of the instantiated successor state axioms after breaking into cases. Therefore, some of the arguments ofthese predicates are constant symbols that appear in our ground action.In 1:1 domains the head of the entailment of formula (7) is an atomic formula since we use distribution propertiesof Theorem 13 on ψ ∧ preconda. The distribution properties (discussed above) break the conjunction of belief state andprecondition into atomic subformulas. Consequently, Φ(p1, . . . , pn)[p1/succp1,a,...,pn/succpn ,a] is either equivalent to that atomicformula or a tautology. The size of a tautology is at most two when unit-case successor state axioms are used. Therefore,we can compute all desired Φs in a finite number of steps.Theorem 19. Let progression be first-order definable, l be the number of successor state axioms after breaking into cases, and ψ bethe belief state formula. Algorithm UCF returns the filtering of ψ with a and o in time O (Rl(l + |ψ| + |preconda|)) where R is themaximum arity of all predicates. The length of the returned formula is O (Rl(l + |ψ| + |preconda|)).Proof. See Appendix A.11. (cid:3)A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219207S = ∅for every predicate symbol p and every case of p,[Poss( A(x1, . . . , xn), s) ⇒ (condp ⇒ (p(z1, . . . , zm, do(a, s)) ⇔φp(z1, . . . , zm+n, s))) is a successor state axiom of a casea]if unifiable(φp (z1, . . . , zm+n), ψ)S = S ∪ {(condp ⇒ p(z1, . . . , zm))mgu(φp ,ψ)}elseif unifiable(φp(z1, . . . , zm+n), ¬ψ)(cid:15)S = S ∪ {(condp ⇒ ¬p(z1, . . . , zm))mgu(φp ,ψ)}PROCEDURE UCStep( A(x1, . . . , xn), ψ )A(x1, . . . , xn) an action, ψ a belief-state formula.(1) if ψ is an atomic formula then(2)(3)(4)(5)(6)(7)(8)(9)(10)(11) else, use distribution properties as follows:(12)(13)(14)(15)(16)(17)(18)(19)elseif ψ = φ ∧ ϕelseif ψ = ¬φif ψ = φ ∨ ϕϕ∈S ϕ.returnreturn ¬ UCStep( A(x1, . . . , xn), φ) ∧return UCStep( A(x1, . . . , xn), φ) ∨ UCStep( A(x1, . . . , xn), ϕ).return UCStep( A(x1, . . . , xn), φ) ∧ UCStep( A(x1, . . . , xn), ϕ).UCStep( A(x1, . . . , xn), TRUE).elseif ψ = ∃x φ(x), return ∃x UCStep( A(x1, . . . , xn)s, φ(L))[L/x].a condp is either TRUE or (¬case1p∧ · · · ∧ ¬casel pp ) using Definition 18.Fig. 4. One step unit-case filtering.5.1.1. ExampleConsider our book-keeping robot example from Section 2.2.1. Suppose that we have two rooms, office and lounge, andtwo books, C++ and Java, and our belief state formula is in(C++, Office) ∧ in(Java, Lounge). Assume students studying in thelounge need the C++ tutorial for a while, so the book keeper robot decides to move the book to the lounge. The action ismove(C++, Office, Lounge). It has unit-case successor state axioms.Our algorithm UCF works as follows. First, we add the precondition to the belief state formula. The new belief state is(since (Office (cid:20)= Lounge), the last term of precondition is true):in(C++, Office) ∧ in(Java, Lounge) ∧ book(C++) ∧ room(Office) ∧ room(Lounge)We calculate the filtering of all the atomic formulas of the belief state formula separately and compute the result byusing our distribution properties. What follows is the formula for one of these atomic formulas based on the algorithmpresented above.(cid:13)move(C++, Office, Lounge)(cid:14)(cid:2)(cid:3)in(Java, Lounge)Filter≡ in(C++, Lounge) ∧ ¬in(C++, Office) ∧ in(Java, Lounge)Now suppose that we filter the belief state after receiving the following observation. The robot enters the office and itobserves that there is only one book in the room. A perfect filtering algorithm guarantees that in such cases the book is thesame book that the robot has put in the room before.Assume that the belief state formula is in(C++, Office)∧in(Java, Lounge). The observation is ∀x in(x, Office) ⇒ x = TheBook.Filter[o](ψ) |(cid:9) TheBook = C++, and we can replace every instance of TheBook in the new belief state formula by C++.5.2. STRIPS domainsIn STRIPS domains [18,37] actions have no conditional effects. It means that the value of each predicate either changesto true, changes to FALSE, or remains the same. STRIPS actions are not necessarily 1:1. Consequently STRIPS successor stateaxioms cannot be treated by algorithm UCF even though they are unit-case. Successor state axioms in STRIPS domains areof the form:Poss(a, s) ⇒ ∀ y1, . . . , ∀ yml pp(cid:3)l pp ( y1, . . . , ym, s)∧ · · · ∧⇒ φcase(cid:2)(cid:2)∧(cid:2)(cid:2)p(cid:3)y1, . . . , ym, do(a, s)(cid:2)⇔case1p¬case1pl p∧ · · · ∧ ¬casep⇒ φ1(cid:3)p( y1, . . . , ym, s)(cid:3)⇒ p( y1, . . . , ym, s)(cid:3)(8)where φ jof p as in the previous section. casep( y1, . . . , ym, s) ( j (cid:2) l p ) is either TRUE or FALSE. Notice that casej1p ) ∧ · · · ∧ ( y= xjp can assign equality to a subset of parametersjkis an argument ofpjkp ) where variable x= xj1pj1paction a and variable yjp is of the form ( yj1p is an argument of predicate p.We can instantiate an action by constants c1, . . . , cn. An instantiated action a is equal to A(c1, . . . , cn). A case afterinstantiation of action a is case[x1,...,xn/c1,...,cn] (we omit p and j from caseDenote case(a) = case( A(c1, . . . , cn)) = case[x1,...,xn/c1,...,cn].jp for simplicity).208A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219PROCEDURE FOSF((cid:13)ai , oi (cid:14)0<i(cid:2)t , ψ )∀i, ai an action, oi an observation and ψ a belief state formula. oi and ψin EAFOL (the form ∃∗∀∗φ).(1) if t = 0, return ψ .(2) return Move-Quana(ot ∧ FO-STRIPS-Step(at ,(3)∧ FOSF((cid:13)ai , oi (cid:14)0<i(cid:2)(t−1), ψ ))))Move-Quan(precondata Moves all the quantifiers to the front with fresh variable names.(cid:15)i ci a belief-state formula.ψsplit ← split every clause in ψ into casesaE ← {ϕ | ϕ ∈ ψsplit and there is l ∈ atom(ϕ) and lPROCEDURE FO-STRIPS-Step(a, ψ )a an action, ψ = ∃∗∀∗(1) if ψ = ∃x φ(x), return ∃x FO-STRIPS-Step(a, φ(L))[L/x](2) // L is a fresh constant that does not appear in the language(3) elseif ψ = ∀x φ(x), return ∀x FO-STRIPS-Step(a, φ(x))(4) else(5)(6)(7)(8)(9)(10)(11)(12)(13)(14)+(a) ← literals affected to TRUE−(a) ← literals affected to FALSEE ← resolve-out(l, E)bc∈E∪S cφ =EffEffreturn φ ∧S ← ψsplit \ EFor all l ∈ Eff(a)such that l is an instance of l¬p(v).(cid:15)(cid:15)(cid:15)(cid:10)}−+(a) p(v) ∧p(v)∈Eff(a)p(v)∈Eff(cid:10) ∈ Eff(a)a The definition of such splitting appears in Eq. (9).b Resolve-out: uses resolution on all instances of l in E. After all resolu-tions are done, we select only those clauses that mention no instance of lor its negation.Fig. 5. First-order STRIPS filtering.A STRIPS action affects the truth value of some of the instantiated predicates and keeps the value of the others. Aninstantiated predicate is a predicate symbol with some arguments constants and others variables. We refer to the set ofaffected instantiated predicates as Eff(a). Eff(a, p) is defined as follows:(cid:6)Eff(a, p) =p( y1, . . . , ym)[ yi1/v i1,...](cid:7)(cid:7) casejp(a) =(cid:2)( yi1= ci1 ) ∧ · · ·(cid:3)for case j of a, p(cid:8)Eff(a) is:Eff(a) =(cid:12)p∈PredEff(a, p)number of elements in the set Eff(a), isTherefore, |Eff(a, p)|, the number of elements in the set Eff(a, p), is exactly the number of cases, l of p, a. |Eff(a)|, the|Eff(a, p)|, the total number of cases stated for a and any predicate fluent.An affected literal (an atomic formula or its negation) is any atom in Eff(a), a negation of such an atom, or a literal whosep∈Pred(cid:16)further instantiation (after replacing some variables with terms) without negation is in Eff(a).Our First-Order STRIPS Filtering (FOSF) algorithm is presented in Fig. 5. A FOL formula is in EAFOL if no existentialquantifier appears within the scope of a universal quantifier. The input to FOSF is assumed to be a belief state formula∃∗∀∗φ in EAFOL (∃∗ refers to any number (cid:3) 0 of existential quantifications of variables; ∀∗ refers to any number (cid:3) 0 ofuniversal quantifications of variables) with no equality, and with observation formulas φ provided in clausal form.Step (5) of our algorithm splits every clause in the clausal form of φ into cases. It does so to allow treating instances ofpredicates which are affected by a differently from those which are not affected by a. We call this step splitting into cases.We split every clause ϕ as in the algorithm described below.Let p((cid:19)v) be an atom in ϕ ((cid:19)v is a vector of variables and constants). Then, let (cid:19)v j be the instantiation of (cid:19)v for casedefined as follows ((cid:19)v = (cid:13)w 1, . . . , wm(cid:14) and each w i is a constant or variable):jp(a)if w i is constant, and yi = c j is in case(a) then(1) (cid:19)v = (cid:13)w 1, . . . , wm(cid:14)(2) For i = 1 to n(3)(4)(5)(6)(7)(8)(9) return p(u1, . . . , um)If w i (cid:20)= c j , return TRUEElse set ui = c jElse w i is variable,If yi = c j in case(a) set ui = c jElse set ui = w iA. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219209Fig. 6. STRIPS example: boxed literals are affected, filled ones are not.We split every clause ϕ into:ϕ[(cid:19)v/ (cid:19)v1], . . . , ϕ[(cid:19)v/ (cid:19)vlp],(cid:2)¬case1pl p∧ · · · ∧ ¬casep⇒ ϕ(cid:3)(9)Note that we treat (¬case1pabove, we require Unique-Names Axioms for objects here.lp∧ · · · ∧ ¬casep⇒ ϕ) as a single literal which is not affected by our action. Also, as mentionedExample. Let casecases. The result would bep1= (x1 = A) and casep2= (x1 (cid:20)= A). Let ϕ = p(x1, B) ∨ q(x1). We split this with respect to predicate p intop( A, B) ∨ q( A),(cid:2)(cid:3)(x1 (cid:20)= A) ⇒ p(x1, B) ∨ q(x1)(10)The new clausal form of φ is divided into two parts: clauses with no affected literals and clauses that have at least oneaffected literal. The algorithm directly copies the first part to the new belief state formula. It also adds all the consequencesof the second part in which no affected literal exists, to the new belief state formula. The literals that are not affected arethe only ones who stay the same in the new belief state. Then all predicates in Eff(a) are added to the new belief stateformula as positive or negative literals (depending on whether they change to TRUE or FALSE).An example of how the FOSF algorithm works is shown in Fig. 6. The action is move(Java, Lounge, Office). You can findthe successor state axioms of this action in Section 2.2.1. Based on this axiom:(cid:2)Eff(cid:3)move(Java, Lounge, Office)=(cid:6)(cid:8)in(Java, Lounge), in(Java, Office)The top line in the figure is the current belief state. Some instances of the first literal in the belief state are affected andsome are not (in(Java, Lounge) is affected, and for every other book in(b, Lounge) is not affected). We split this clause intotwo clauses. There is no literal in these clauses that has both affected and unaffected instances. The middle line of the figureshows the belief state after splitting into cases. In the first clause one of the literals is affected, so we try to resolve it withother clauses in our knowledge base (since we have no other clauses, it is discarded). The second clause has no affectedliteral. We copy it directly to the new belief state. At the end, all the predicates in Eff(move(Java, Lounge, Office)) are addedas positive or negative literals.Theorem 20. Let action a, observation o, and belief state formula ψ in EAFOL be given to FOSF as input. Assume progression is first-order definable, let l be the maximum number of cases in all successor state axioms. Assume that every case of a instantiates allvariables. Then, algorithm FOSF returns the filtering of ψ with a and o in time O ((l · |ψ|)2|Eff(a)|).Proof. See Appendix A.12. (cid:3)Theorem 21. Let progression be first-order definable and let C be the number of constant symbols appearing in the domain description.Let R be the maximum arity of predicates and m be the number of predicates. If ψ is in 2-FO-CNF,2 the length of formula after filteringwith t actions a1, . . . , at is bounded by O (m2 · (R + C)2R ), a term independent of t. The time taken for filtering each action a isO (m2 · (R + C)2R ).2 An EAFOL is in k-FO-CNF if it is in clausal CNF, and the size of each clause is at most k.210A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219Proof. See Appendix A.13. (cid:3)Thus, these theorems give a polynomial time and space guarantees for filtering (polynomial in the number of predicatesand the length of action sequence). Importantly, Theorem 21 gives a bound on the size of our belief state representation, |ψ|,that is maintained after T > 0 steps. This bound is important for ensuring tractable (polynomial time) filtering indefinitely,since the inference time per step is polynomial in |ψ|. (Notice that without this result it is possible that one step of filteringresults in a belief states of size O (|ψ|2), then compounding over T steps to belief state of size O (|ψ|2T ).)6. Related worksSeveral research streams in AI concern problems that are relevant to our work here. We divide the work relevant toours into four parts: works within logical AI and Databases that focus on reasoning about actions; works within stochasticfiltering and state estimation in Markov Chains; and works between Philosophy, Linguistics, and AI that focus on BeliefRevision and Update. We choose not to cover learning in dynamic systems in this scope, but the two are related; see [1] fordetails.6.1. Reasoning about actionsOur work is closest to works on reasoning about actions. In its general form, Logical Filtering is a generalization ofDatabase Progression [66,39,40], formal verification with Symbolic Model Checking [7,10], and Belief Update [27,55,28].Those works that are closest to ours examine progression in FOL theories. In that context, work on filtering is betweendatabase progression and stochastic filtering. While applying similar fundamental techniques to progression, filtering’s goalsare different and so are the types of sought results. It aims at procedures that process a sequence of actions tractablyindefinitely.In a series of papers [51,38,40] Lin and Reiter defined progression of FOL theories and showed that sometimes the filteredbelief state has no representation within FOL. They also showed that FOL progression (the set of (possibly infinite) FOLconsequences uniform in a situation) is enough to characterize progression for correct answers to queries in FOL pertainingto any specified future ground situation term. [63,64] extended this work and showed that FOL progression is further enoughto answer correctly entailment of the form “after α, property φ will always be true.”Those works are compatible with ours in that they establish correctness of FOL progression for classes of queries thatcontain ours. They do not concern tractability, which is our focus here.Somewhat closer to ours are works that find classes of action theories for which progression is tractable or more efficientthan in general. [21] studied cases of progression in which one can exploit correspondence between the situation calculusand relational databases to build systems for reasoning about actions. It focuses on tractability results, but is based onstandard relational database technology, and assumes the initial knowledge base is complete (the initial belief state includesexactly one state).Following that line of research, [41,65] developed algorithms for incomplete initial knowledge bases. [41] developedalgorithms that can be applied to any proper initial knowledge (roughly, one that is consistent) and local actions (successor-state axioms are of the form F ((cid:19)x, do(a, s)) ≡ γ +F ((cid:19)x, a) ∨ (F ((cid:19)x, s) ∧ ¬γ −F ((cid:19)x, a) are disjunctions offormulas of the form ∃(cid:19)z[a = A((cid:19)y) ∧ φ((cid:19)y)] with φ quantifier free uniform in s and (cid:19)y the exclusive union of (cid:19)x, (cid:19)z). However,their progression algorithm is only complete when applied to context-complete knowledge, i.e., when knowledge is completeabout φ(.) when successor-state actions need to be applied. This differs from our results here in that we effectively restrictthe form of successor-state axioms, but do not make assumptions of completeness for the initial or intermediate knowledge.[65] extended this work on actions of local effects, and showed that progression is always first-order definable for those.They also show that progression is finite when φ(.) has no quantifiers and includes only variables that appear in (cid:19)y (strictlylocal effects). Their finiteness result is important, but their formulas grow exponentially with even one progression step;Theorem 2 in [65] computes projection and results in a disjunction of l disjuncts, where l is the number of “ J -models”(we omit the definition here) of the progression, a number that is worst-case at least exponential in the number of groundatoms.F ((cid:19)x, a)), and γ +F ((cid:19)x, a), γ −In contrast, our results focus on progression that grows at most linearly with every step: Our results in Sections 4 and 5focus on progression whose output is of size O ( f · |ψ|), where ψ is the input databases and where fis a constant thatdepends only on the form of the action theory, D. Our final result, Theorem 21, gives an even stronger result, boundingthe size of progression after T time steps (T actions and observations) by a polynomial O (T |ψ|2) of the input that growslinearly with T . Such results are critical to practical filtering over long sequences actions and observations.A final contrast with these previous results is the scope of action domains to which they apply. Specifically, our results(cid:10) = push2 shown in Eq. (6) inin Section 5 do not assume that the domain is strictly local. For example, the example action aour Section 4.2.1 is not a strictly local effect action, so it cannot be processed by the procedure of [65], whereas our FF canprocess it in linear time and with only linear growth in the belief-state representation per progression step.Finally, a related line of work to the ones above investigates Fluent Calculus [60,61] as a computationally efficient meansfor updating belief states. [60] introduces a dual representation for basic action theories based on state update axioms thatexplicitly define the direct effects of each action. It starts from the Situation Calculus where successor state axioms are usedA. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219211to solve the frame problem and it shows how the Fluent Calculus can be viewed as the result of gradually improving thislogic to improve inferential aspects. [61] presents an implementation technique for progression based on the state updateaxioms and the use of a constraint solver. Another work [24] extends the fluent calculus by a method for belief change,which allows agents to revise their internal model upon making observations that contradict this model.The main difference that we draw between this work and ours is in that update in this framework trades off accuracyfor efficiency. While updates are generally efficient, the results are not guaranteed to be a precise representation of the FOLprogression of ones’ belief state. These results are useful for our purposes as subroutines that may compute progression (e.g.,in compilation of Section 4). However, no computational analysis of time or space is given by the author, so comparison ishard.6.2. Propositional progression and filteringPrevious works that address tractable algorithms for exact filtering focus on propositional cases and intractability resultsfor the general case of those.[3] present efficient logical filtering algorithms that maintain a compact belief state representation indefinitely, for abroad range of environment classes including nondeterministic, partially observable successful-STRIPS environments (whensuccess/failure of the action is known) and environments in which actions act as 1:1 mapping on states. That work isrestricted to the propositional case.Earlier research about the hardness of belief revision and update [17,35] focused on the properties of different updatesemantics, showing that finding out if a query follows from the updated belief state is coNP-hard. [8] further showed thatmany3 semantics discussed in the literature lead to an exponential growth in the representation size of any belief-staterepresentation scheme, if the polynomial hierarchy does not collapse.Our contribution and focus are different from earlier work by our emphasis on FOL and on tractable, scalable filteringtechniques for indefinite online processing of updates. These would take computation time that depends only linearly on thenumber of time steps. We focus on tractable cases, and apply belief update semantics that is easier for analysis and com-putation. Our approach focuses on AI applications in partially observable domains, and is closer in spirit to data-intensivecontrol-theory approaches to tracking of dynamic systems.6.3. Stochastic filteringEarly work, beginning with Gauss, assumed stochastic models. For example, the Kalman filter [26] is a ubiquitous devicethat maintains a multivariate Gaussian belief state over n variables, assuming linear-Gaussian transition and sensor model.Crucially, the O (n3) update cost and the O (n2) space requirement do not depend on the length of the observation sequence. Thistype of tractability permits the Kalman filter to run indefinitely and enables well-known applications [59,43]. This type ofrecursive estimation motivates our term logical filtering.Stochastic filtering and reasoning in probabilistic dynamic models is an area of vast literature and common everydayapplications [45]. Progress and research on it is divided between Statistics [30], Artificial Intelligence [47,16], and ControlTheory [43,12]. Research on stochastic filtering focuses on Hidden Markov Models [50,19] and Dynamic Bayesian Networks[13,23,48]. Reasoning and estimation with these models is hard when the systems dynamics or sensor model are notGaussian-linear and the number of state features is of modest size (e.g., a hundred features, thus (cid:3) 2100 states).The difficulty of stochastic filtering led early to modern research to focus on reasoning techniques that approximatethe model [59,47,30,6,62,31] or approximate inference in the model via sampling [15,16]. Unfortunately, these still requireexponential-time computations or produce poor approximations in most cases (approximations work in practice for someapplications), especially when the transition model includes states defined from discrete variables [48,5]. This difficulty is asecond motivation for our work here (the first are immediate applications [9]).Logical Filtering is close to stochastic filtering, only without probabilities in belief state, transition model, or sensor model.The filter’s first input is a representation for belief state σ0 ⊆ S, where S ⊆ Pow(P) is the system’s set of states definedwith propositional fluents P (fluents are state features that change over time). The filter’s second input is a representationfor transition relation R ⊆ S × S, with (cid:13)s, sat time t + 1 for any t (cid:3) 0.The filter’s final input is a sequence of representations of observations o0:T , for ot ⊆ S, given in an online fashion, one pertime step t (cid:2) T . The filter’s task is to update the belief state representation recursively to σt (returning σt when requestedto) so that it accounts exactly for all the states that are consistent with σ0, R, o0:t .(cid:10)(cid:14) ∈ R iff state s at time t may transition to state s(cid:10)An inquiry in logical filtering is typical of inference from logical knowledge bases, e.g., satisfiability checking (e.g., isit possible that A is on B?), entailment (e.g., must it be that A is on B?), and checking the feasibility of a state (e.g., is state{inHand(B), onTable( A)} possible?).3 They also show that the WIDTIO (When In Doubt Throw It Out) semantics has a compact representation. This is so because one can always discardinformation to achieve a compact representation.212A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–2196.4. Belief revision and update in FOLImportant research that is related to ours is on the usage of FOL for belief update, either as holder of a belief formula oras supplying some of the semantics involved with different revision tasks. Examples of the first are [11,14] (first-order AGMbelief revision) and [66] (belief update and revision in simple subclasses of FOL).An important difference that we draw with these works is that ours provides efficient inference procedures, while thoselines of work focus on the use of general-purpose theorem provers and provide only intractability results.[34] presents an approach for incorporating a new piece of knowledge into knowledge bases about actions and change.Their approach is different from all other belief revision operations since they consider another criterion: A possible causeexplaining the new fact and all the effects of the possible cause should be added and all cause-effect relations should bemaintained. This is called possible cause approach (PCA).Interestingly, a set of works examined the question of how belief update and progression are related with each other.[36] shows that several different semantics for belief update can be expressed in a single framework for reasoning aboutactions. That framework can be considered as a common core of all these update formalisms. In the other direction, [29]shows that belief update is a specific case of feedback-free action progression. It also presented reverse update, which is toregression as update is to progression.Similarly, works on iterated belief revision [54,25] examine the belief change associated with performing actions. Theyassume a theory of action represented in the situation calculus and extended to deal with belief. Their belief revisioncorresponds to our observations, where belief update corresponds to update with actions.7. ConclusionsWe presented semantics and methodology for efficient filtering in domains that include many objects. Some of ouralgorithms allow objects whose identity is not certain. We generalized this problem to filtering FOL formulas with groundactions and FOL observations.Previous results guarantee that FOL representations are sufficient for filtering. We showed that such filtering is solvablein polynomial time when actions map states 1:1 (after precompilation of the domain), or the actions have a case-basedrepresentation (this includes STRIPS actions whose success or failure are observed). We showed that 1:1 actions allow us tofilter FOL belief state formulas in linear time per time step in the size of belief-state representation, given an algorithm forcomputing the progression of atomic formulas, and assuming this algorithm compiles our domain (and terminates) beforefiltering commences.When actions are successful-STRIPS or Unit-Case, we can filter arbitrary belief state formulas efficiently without pre-compilation. We showed that for a class of actions and belief states (roughly, corresponding to conjunctions of first-orderclauses of size 2) belief state formulas are guaranteed to remain represented compactly (polynomial size in the initial beliefstate representation and the number of time steps T ) for arbitrary action-observation sequence lengths, T . Those cases per-mit filtering of actions and observations indefinitely in polynomial time (in the number of predicates and constants of ourdomain).Tractable filtering is important for many practical, everyday life applications. Technologies such as the ones presented inthis paper are important for practical natural-language processing (NLP), autonomous agents in robotics and WWW domains[9], game playing [49], and state estimation more generally [22]. In those applications it is crucial that processing be efficientfor large numbers of states and large domains. The efficient processing algorithms reported in this paper and those that wehope will be derived in the future are key to new applications in these domains. We expect uses of our algorithms in thesedomains, and hope to help introducing FOL-based tractable applications into mainstream AI, including NLP, autonomousagents, robot motion planning and world-state estimation, and partial knowledge games.AcknowledgementsWe wish to thank Megan Nance and Adam Vogel for useful discussions on related topics. We also thank the diligentreviewers and editors of Artificial Intelligence Journal for helping improve this manuscript significantly. Finally, we wish toacknowledge support from DAF Air Force Research Laboratory Award FA8750-04-2-0222 (DARPA REAL program) and NationalScience Foundation CAREER grant 05-46663.Appendix A. ProofsA.1. Proof of Theorem 7: Filtering algorithmWe show that the left-hand side is contained in the right-hand side.(cid:3)(cid:2)Filter[a](cid:10) ∈ Filter[a]({S | |(cid:9)S ψ}). From Definition 6, there is an S such that S ∈ {S | |(cid:9)S ψ} and (cid:13)S, a, S(cid:7)(cid:8)(cid:7) |(cid:9)S(cid:10) Filter[a](ψ){S | |(cid:9)S ψ}⊆(cid:6)S(cid:10)Take Sthere is an S such that |(cid:9)S ψ and (cid:13)S, a, S(cid:10)(cid:14) ∈ RD .(cid:10)(cid:14) ∈ RD . In other words,A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219213To prove the theorem, we need to show that |(cid:9)S(cid:10) Filter[a](ψ) (Sarerestricted to our first-order language L. Let P be the set of all constants and predicates in L. For each element of P (g ∈ P )we define a new symbol gsuchthat |S. The set of all these new symbols is called P (cid:10). We define structure Swhere gis in the right-hand side). Note that S and S(cid:10)(cid:10) = g S and for each gon language L ∪ P (cid:10)is the new symbol for g.(cid:10)(cid:10) = g S(cid:10) ∈ P (cid:10), g(cid:10)S(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)| = |S|, for each g ∈ P , g SWe claim that |(cid:9)S(cid:10)(cid:10) ξ where ξ isψ ∧ preconda∧∀ y1 . . . ∀ ym p(cid:10)i( y1, . . . , ym) ⇔ succpi ,a( y1, . . . , ym) ∧(cid:10)i(cid:10)i∀z f(cid:10)i= z ⇔ succ f i ,a(z)(cid:10)(cid:10)does not model ξ only if one of the conjuncts is falsified. This in not the case for ψ or preconda by our choice of S.S(cid:10)i( y1, . . . , ym) ⇔ succpi ,a( y1, . . . , ym) does not hold). FromAssume by contradiction that this is the case for some i (i.e., p(cid:10)the way we defined RD this is never the case. The way we define p Si based on structure S always guarantees that(cid:10)i( y1, . . . , ym) and succpi ,a( y1, . . . , ym) are equivalent. This contradicts our assumption. Thus, we get |(cid:9)S(cid:10)(cid:10) ξ . Therefore |(cid:9)S(cid:10)(cid:10)pP (cid:10)(ξ ).) also models CnCnIf we replace symbols in P (cid:10). Therefore, |(cid:9)S(cid:10) Filter[a](ψ).(ξ ) is L(P (cid:10)), the restriction of Sby their corresponding symbols in P , Sto L(P (cid:10)) (we refer to it as S(cid:10)(cid:10)(cid:10)would be equal to S(ξ ). Since the language of CnP (cid:10)P (cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)A.2. Proof of Corollary 8We show that the two sets of structures have the same elements. By Theorem 7 we know that the left-hand side of theequality is contained in the right-hand side.(cid:2)Filter[a]{S | |(cid:9)S ψ}(cid:3)⊆(cid:6)(cid:10)S(cid:7)(cid:8)(cid:7) |(cid:9)S(cid:10) Filter[a](ψ)For the opposite direction (showing the right-hand side is contained in the left-hand side), suppose that we can encode theleft-hand side with a first-order formula ϕ. Formula ϕ holds in all the members of the left-hand side. To prove the oppositedirection we need to show that,Filter[a](ψ) |(cid:9) ϕEvery model of Filter[a](ψ) (right-hand side of equation) is also a model of ϕ (left-hand side of the equation). In otherwords, right-hand side is a subset of left-hand side.To prove this statement we use the following lemma:Lemma 22. Let ϕ(cid:10)that:be the formula computed by replacing every predicate p( y1, . . . , ym) in ϕ with succp,a( y1, . . . , ym). We proveψ ∧ preconda|(cid:9) ϕ(cid:10)Proof. See Section A.3. (cid:3)We know that ϕ(cid:10) = ϕ[pi ( y1,..., ym)/succpi ,a( y1,..., ym)] and we use this lemma ψ ∧ preconda(cid:10)(cid:10)ψ ∧ preconda∧∀ y1 . . . ∀ ym p(cid:10)i( y1, . . . , ym) ⇔ succpi ,a( y1, . . . , ym) ∧|(cid:9) ϕ(cid:10). Therefore,∀ y1 . . . ∀ ym∀z f(cid:10)i= z ⇔isucc f i ,a(z) |(cid:9) ϕ[P/P (cid:10)]and the proof is done (Filter[a](ψ) |(cid:9) ϕ).A.3. Proof of Lemma 22iBy contradiction assume that this is not the case. There is a structure S which |(cid:9)S ψ ∧ preconda but S is not a model(cid:10)(cid:14) ∈ RD and. Since |(cid:9)S ψ and |(cid:9)S preconda, observing the way RD is defined, there should be an Sof ϕ(cid:10)(cid:10) ∈ Filter[a]({S | |(cid:9)S ψ}). We encode Filter[a]({S | |(cid:9)S ψ}) with formula ϕ. So |(cid:9)S(cid:10) ϕ.Ssuch that (cid:13)S, a, S(cid:10)Since we have replaced every predicate p in ϕ with succp,a for getting ϕ(cid:10), with |(cid:9)S(cid:10) ϕ and (cid:13)S, a, S(cid:10)(cid:14) ∈ RD we concludethat |(cid:9)S ϕ(cid:10). This contradicts our assumption.A.4. Proof of Theorem 10: Progression possibilityWe want to prove:Dg ∪ Ds2|(cid:9) ψ iff Dg ∪ Ds0|(cid:9) ψProving the forward direction is easy. We assume that Dg ∪ Ds2|(cid:9) ψ and we prove that Dg ∪ Ds0|(cid:9) ψ . By definition:214A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219Ds2Ds1= Cns2 (Dss1,2= Cns1 (Dss0,1∪ Dap1,2∪ Dap0,1∪ Ds1 )∪ Ds0 )Therefore, Dg ∪ Dss1,2We conclude that∪ Dap1,2∪ Ds1|(cid:9) ψ (consequence finding procedure is sound). Now, we replace Ds1 by its definition.Dg ∪ Dss1,2∪ Dap0,1and since Dsst−1,t and Dapt−1,t are part of Dg , we can conclude that Dg ∪ Ds0∪ Dap1,2∪ Dss0,1∪ Ds0|(cid:9) ψ|(cid:9) ψ .For the opposite direction, we should show that for a formula ψ uniform in do(a2, do(a1, s0)) if Dg ∪ Ds0|(cid:9) ψ , thenDg ∪ Ds2|(cid:9) ψ . We can rewrite Dg as in the next formula.|(cid:9) ψDg ∪ Ds0Dg ∪ Dss0,1∪ Dap0,1∪ Dss1,2∪ Dap1,2∪ Ds0|(cid:9) ψFrom deduction theoremDss0,1∪ Dap0,1∪ Ds0|(cid:9) (Dg ∧ Dss1,2∧ Dap1,2 ) ⇒ ψWe use the following lemma:Lemma 23. Let ϕ and ψ be two first-order formulas, and f (T ) be a ground function in L(ϕ) ∪ L(ψ). Let ϕ[ f (T ):R] be the formula thatis obtained after replacing every ∀x φ where f (x) is in φ with (∀x (x (cid:20)= T ) ⇒ φ) ∧ φ[x/T ] and also replacing every instance of f (T )with R. Then ϕ |(cid:9) ψ if and only if ϕ[ f (T ):R] |(cid:9) ψ[ f (T ):R] where R is a new constant symbol.Using the lemma, we replace do(a1, s0) with s1 and do(a2, s1) with s2 in the above equation (note that a1, a2, s0, s1, ands2 are constants). After this replacement, the intersection of the language of the two sides of |(cid:9) does not include s0, s2, andfunction do.Now, by applying Craig’s interpolation theorem for FOL, we get that there should be a ϕ in L(Dss0,1∪ Dap0,1∪ Ds0 ) ∩L((Dg ∧ Dss1,2∧ Dap1,2 ) ⇒ ψ) such that∪ Dap0,1Dss0,1ϕ |(cid:9) (Dg ∧ Dss1,2∪ Ds0|(cid:9) ϕ∧ Dap1,2 ) ⇒ ψNext, we replace back s1 and s2 with do(a1, s0) and do(a2, do(a1, s0)), respectively (using the result of the previous lemma,we know that this replacement does not affect the entailment). Since ϕ does not include any term of sort situation exceptdo(a1, s0), it is uniform in do(a1, s0). From our definition of Ds1 we infer that ϕ ∈ Ds1 . ThereforeDs1Dss1,2|(cid:9) (Dg ∧ Dss1,2∪ Ds1∪ Dap1,2∧ Dap1,2 ) ⇒ ψ|(cid:9) Dg ⇒ ψWith the same argument as before we can prove thatDs2|(cid:9) Dg ⇒ ψand the opposite direction is done.A.5. Proof of Lemma 23By contradiction assume that ϕ |(cid:9) ψ but ϕ[ f (T ):R] (cid:20)|(cid:9) ψ[ f (T ):R]. There is a structure M which |(cid:9)M ϕ[ f (T )|R] but M is not adoes not have constant symbol R. With theequal to M except that f (T )M(cid:10) = R M and also M(cid:10)(cid:10)model of ψ[ f (T )|R]. Define M(cid:10)definition of MWe define Mequal to M, it is clear that |(cid:9)M(cid:10) ϕ. Given our assumption |(cid:9)M(cid:10) ψ .(cid:10)(cid:10)(cid:10)except that it has a new constant symbol R for which R M. We can conclude thatand M differ only in the interpretation of f (T ), and ψ[ f (T ):R] does not have any(cid:10)(cid:10)(cid:10)(cid:10) = f (T )M(cid:10)(cid:10)(cid:10)is a model of ψ[ f (T ):R]. Mthis new Mevaluation of f (T ). Therefore, |(cid:9)M ψ[ f (T )|R].The other direction is proved similarly.A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219215A.6. Proof of Theorem 11: Distribution over connectivesThe proof for the first three parts is similar to the proof given by [3] for propositional filtering. We use the result statedby Corollary 8 in our proof.(1) Take a structure S(cid:10)that satisfies Filter[a](ϕ ∨ ψ). Then, there is a structure S that satisfies ϕ ∨ ψ such that RD(S, a, S(2) Take a structure S(cid:10)Thus, S satisfies one of ϕ or ψ because S is a complete setting of the fluents. Therefore, SFilter[a](ψ). It follows that Filter[a](ϕ ∨ ψ) ⇒ Filter[a](ϕ) ∨ Filter[a](ψ).For the other direction take SThus, there is a structure S such that RD(S, a, SFilter[a](ϕ ∨ ψ). It follows that Filter[a](ϕ ∨ ψ) ⇐ Filter[a](ϕ) ∨ Filter[a](ψ).that satisfies Filter[a](ϕ) ∨ Filter[a](ψ). Then, it satisfies one of Filter[a](ϕ) or Filter[a](ψ).satisfies(cid:10)) and S satisfies one of ϕ or ψ . Thus, S satisfies ϕ ∨ ψ and Sthat satisfies Filter[a](ϕ ∧ ψ). Then, there is a structure S that satisfies ϕ ∧ ψ such that RD(S, a, S(cid:10)).Thus, S satisfies both of ϕ and ψ . Thus, Sthatsatisfies Filter[a](ϕ ∧ ψ) also satisfies Filter[a](ϕ) ∧ Filter[a](ψ). It follows |(cid:9) Filter[a](ϕ ∧ ψ) ⇒ Filter[a](ϕ) ∧ Filter[a](ψ).(cid:10)) and S satisfies ϕ.satisfies Filter[a](TRUE) there is a structure Ssatisfies Filter[a](¬ϕ). It follows that |(cid:9) Filter[a](¬ϕ) ⇐ ¬Filter[a](ϕ) ∧that satisfies ¬Filter[a](ϕ) ∧ Filter[a](TRUE). Then, there is no structure S that RD(S, a, Sis in both of Filter[a](ϕ) and Filter[a](ψ). We conclude that every S(cid:10)). This S satisfies ¬ϕ so S(cid:10)), S satisfies ¬ϕ. Since SThus, for every structure S that RD(S, a, Ssuch that R D (S, a, SFilter[a](TRUE).(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(3) Take S(cid:10)).is in one of Filter[a](ϕ) or(cid:10)(4) We used Skolemization for this part. We show that the two sets of world structures are equal. We first show that theleft-hand side of the equation is contained in the right-hand side.(cid:2)Filter[a](cid:3)∃x ϕ(x)(cid:2)≡ ∃x Filter[a](cid:3)ϕ(L)[L/x]Take structure M such that |(cid:9)M F ilter[a](∃x ϕ(x)). We show that |(cid:9)M ∃x Filter[a](ϕ(L))[L/x].Based on Theorem 7:|(cid:9)M Filter[a](∃x ϕ(x))iff M ∈ Filter[a](cid:2)(cid:6)(cid:7)(cid:7) |(cid:9)S ∃x ϕ(x)(cid:3)(cid:8)SBased on Definition 6:(cid:6)(cid:7)(cid:7) |(cid:9)S ∃x ϕ(x),Based on Definition 5, there exists an S that:∈ RDS, a, SM ∈S(cid:8)(cid:5)(cid:4)(cid:10)(cid:10)|(cid:9)S ∃x ϕ(x)|(cid:9)S preconda|S| = |M|p M =f M =(cid:6)(cid:7)(cid:8)(cid:7) |(cid:9)S succp,a(v 1, . . . , vm)(cid:13)v 1, . . . , vm(cid:14)(cid:7)(cid:8)(cid:6)(cid:7) |(cid:9)S succ f ,a(v 1, . . . , vr)(cid:13)v 1, . . . , vr(cid:14)We define S L,ϕ equal to S with additional mapping of new constant symbol L to v ∈ |S| such that |(cid:9)S ϕ(v). In thiscase:|(cid:9)S L,ϕ ϕ(L)We can progress S L,ϕ with action a.(cid:3){S L,ϕ}iffM(cid:7)(cid:7)Mp M(cid:2)(cid:10) ∈ Filter[a](cid:7)(cid:7) = |S L,ϕ|(cid:10)(cid:6)(cid:10) =(cid:10) =f M(cid:7)(cid:8)(cid:7) |(cid:9)S L,ϕ succp,a(v 1, . . . , vm)(cid:13)v 1, . . . , vm(cid:14)(cid:7)(cid:8)(cid:6)(cid:7) |(cid:9)S L,ϕ succ f ,a(v 1, . . . , vr)(cid:13)v 1, . . . , vr(cid:14)We conclude that |(cid:9)M(cid:10) F ilter[a](ϕ(L)).Define DL equal to D with an extra constant symbol L. We can say that M is the restriction of Mbecause it behaves like Mon every element in the domain except that it does not have the symbol L.(cid:10)(cid:10)to symbols in DWe can use the following lemma to complete the proof.Lemma 24. Take ψ ∈ L(DL), we can prove that:|(cid:9)M ∃x ψ[L/x]iff ∃M(cid:10) |(cid:9)M(cid:10) ψ such that M is a restriction of M(cid:10)to L(ψ)\{L}216A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219Proof. See Section A.7. (cid:3)With this lemma the proof is complete. The other side is the same. All conclusions are if and only if so the other side isalso proved.A.7. Proof of Lemma 24Suppose that the left-hand side is true but the right-hand side is not.(cid:10) |(cid:9)M(cid:10) ψ such that M is a restriction of M|(cid:9)M ∃x ψ[ X/x]iff ∃M(cid:10)to L(ψ)\{L}(cid:10)It means there is no structure Mthe existential quantifier true. Add a constant X to M such that X = v and call this new structure Mrestriction of Mto L(ψ)\{ X}. We can conclude that the left-hand side implies the right-hand side.that models ψ and M is a restriction of M. Assume that v ∈ |M| is the x that makes(cid:10)(cid:10). |(cid:9)M(cid:10)(cid:10) ψ and M is a(cid:10)(cid:10)(cid:10)Now for the other side, suppose that the right-hand side is true but the left-hand side is not. The element in the domainassociated with X would satisfy the existential quantifier and the proof is done.A.8. Proof of Theorem 13(cid:10)Theorem 11 supplies the proof of 1, the “⇒” direction of 2, the “⇐” direction of 3, and the proof of 4.We are left to prove the “⇐” direction of 2 and the “⇒” direction of 3 (similar to propositional case in [3]).For “⇐” of 2, let SFilter[a](ψ). For Filter[a](ϕ) there is a structure S such that RD(S, a, Sis a structure S1 such that RD(S1, a, Sstructures, there is only one structure that maps to SFilter[a](ϕ ∧ ψ). It follows that |(cid:9) Filter[a](ϕ ∧ ψ) ⇐ Filter[a](ϕ) ∧ Filter[a](ψ).be a structure that satisfies Filter[a](ϕ) ∧ Filter[a](ψ). Then, it satisfies both of Filter[a](ϕ) and(cid:10)) and S satisfies ϕ. Similarly, for Filter[a](ψ) there(cid:10)) and S1 satisfies ψ . However, since a acts as a one-to-one mapping betweensatisfies. Thus, S = S1, and S satisfies ψ . S satisfies ϕ ∧ ψ and SFor “⇒” of 3, let Sbe a structure that satisfies Filter[a](¬ϕ). Then, there is a structure S that satisfies ¬ϕ such that(cid:10)). Thus, S does not satisfies ϕ. Since a acts as a one-to-one mapping, there is only one structure that maps to(cid:10)). So, Safter a. There is no structure S1 that satisfies ϕ and for which RD(S1, a, Sdoes not satisfy Filter[a](ϕ) and(cid:10)satisfies ¬Filter[a](ϕ) ∧ Filter[a](TRUE). Italso satisfies Filter[a](TRUE). So SRD(S, a, S(cid:10)Stherefore it satisfies ¬Filter[a](ϕ). Clearly, Sfollows that |(cid:9) Filter[a](¬ϕ) ⇒ ¬Filter[a](ϕ) ∧ Filter[a](TRUE).(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)A.9. Proof of Theorem 14By Theorem 13, we know that algorithm FF is correct. It decomposes ψ ∧ preconda into atomic sub-formulas by usingdistribution properties. Since we assume that we have the filtering of atomic formulas (as a precomputed table) we justretrieve it in time F and combine the results. Therefore, the time complexity of this algorithm is O (|ψ ∧ preconda| × F ).A.10. Proof of Theorem 17Using formula 1 we should show that every clause in formula 1 is also in the set of 7 and every Φ in 7 is a consequenceof formula 1. We repeat formula 1 here.1.Filter[a](ψ) =P (cid:10)Cn(cid:9)(cid:9)ψ ∧ preconda(cid:10)i(cid:10)i∀ y1, . . . , ym, p(cid:10)i( y1, . . . , ym) ⇔ succpi ,a( y1, . . . , ym)(cid:11)(cid:11)∀z, f(cid:10)i= z ⇔ succ f i ,a(z)[P (cid:10)/P]2.Filter[o](ψ) = ψ ∧ o(cid:10)n) is a consequence of formula 1 before applying [P (cid:10)/P]. We want to show that ψ ∧ preconda|(cid:9)Suppose that Φ(pΦ(succp1,a, . . . , succpn,a). By the above definition(cid:10)(cid:10)1, . . . , pψ ∧ preconda∧∀ y1 . . . ∀ ym p(cid:10)i( y1, . . . , ym) ⇔ succpi ,a( y1, . . . , ym)i∀z, f(cid:10)i= z ⇔ succ f i ,a(z) |(cid:9) Φ(cid:2)(cid:3)(cid:10)1, . . . , p(cid:10)np(cid:10)iWe refer to left-hand side as ξ . Therefore, for every structure M, if |(cid:9)M ξ then |(cid:9)M Φ(pevery p(cid:10)1, . . . , p(cid:10)i is equivalent to succpi ,a in M, we conclude that |(cid:9)M Φ(succp1,a, . . . , succpn,a). As a result,ξ |(cid:9) Φ(succp1,a, . . . , succpn,a)(cid:10)n) and since the value ofA. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219217Since pconsists of some equivalence formulas about p(cid:10)i does not appear in Φ(succp1,a, . . . , succpn,a) we conclude that ψ ∧ preconda(cid:10)i ). One direction of the proof is done.|(cid:9) Φ(succp1,a, . . . , succpn,a) (the rest of ξNow for the other direction, we show that for every Φ(p1, . . . , pn) in the set of 7, ξ |(cid:9) Φ(p(cid:10)1, . . . , p(cid:10)n). Sinceψ ∧ preconda|(cid:9) Φ(succp1,a, . . . , succpn,a), this part is also trivial.A.11. Proof of Theorem 19Correctness. To prove that the algorithm UCF returns the filtering of ψ correctly we use the result of Theorem 17. Wewant to find all Φ(p1, . . . , pn)s such that ψ ∧ preconda|(cid:9) Φ(succp1,a, . . . , succpn,a).The algorithm Filter-True finds all Φs that true |(cid:9) Φ(succp1,a, . . . , succpn,a). In other words, Φ(succp1,a, . . . , succpn,a)should be a tautology. Since all φp s are unit clauses, the size of tautologies is at most 2. The algorithm checks the unifiabilityof every pair of φp and φp(cid:10) and finds all the tautologies of size 2.Next, we need to find all Φs that ψ ∧ preconda|(cid:9) Φ(succp1,a, . . . , succpn,a). With Theorem 13 we divide ψ ∧ preconda intoatomic formulas. Let q be an atomic formula, we want to find all Φs that q |(cid:9) Φ(succp1,a, . . . , succpn,a). We rewrite it astrue |(cid:9) ¬q ∨ Φ(succp1,a, . . . , succpn,a)Therefore, ¬q ∨ Φ(succp1,a, . . . , succpn,a) should be a tautology. (6) of UCStep finds all such Φs.Complexity. Suppose that we have t successor state axioms and we divide them into k instantiated successor state axiomsof the form(cid:2)PossA(x1, . . . , xn), s(cid:3)(cid:2)⇒condp ⇒(cid:2)(cid:2)(cid:3)z1, . . . , zm, do(a, s)p p⇔ φp(z1, . . . , zm+n, s)(cid:3)(cid:3)where l = l1 + 1 + · · · + lt + 1. The first successor state axiom after breaking into instantiated successor state axioms resultsin l1 + 1 new axioms. We can easily verify that the size of the first l1 axioms is 2 and the size of l1 + 1th axiom is O (Rl1).Therefore, the total size of all instantiated successor state axioms is 2l1 + Rl1 + · · · + 2lt + Rlt which is O (Rl).Since we have |ψ ∧ preconda| atomic formulas and for every atomic formula the size of the resulted formula after filtering|). In additionis less than the size of all successor state axioms, the size of the returned formula would be O (Rl|ψ ∧ precondathere is a constant formula (filtering of TRUE) that we add to the resulted formula. Suppose that the size of the instantiatedsuccessor state axioms are x1, . . . , xl. The size of filtering of TRUE would be less than ΣiΣ j(xi + x j) = Σi(lxi + Σ j x j) =O (Rl2). The size of the formula is O (Rl2 + Rl|ψ ∧ precondaFor computing the time complexity, we run Filter-True once which takes O (l2) and we run UCStep once for each singleliteral and it takes O (l) each time. Therefore, the time complexity is the same as the space complexity O (Rl2 + Rl|ψ ∧preconda|).|).A.12. Proof of Theorem 20Correctness. To prove that the algorithm FOSF returns the filtering of ψ correctly we use the result of Theorem 17. Wewant to find all Φ(p1, . . . , pn)s such that ψ ∧ precondaFO-STRIPS-Step finds some Φs that ψ ∧ preconda|(cid:9) Φ(succp1,a, . . . , succpn,a).|(cid:9) Φ(succp1,a, . . . , succpn,a) by using resolution (since all φp s are eitherTRUE, FALSE, or the same literal). We refer to the set of Φs that this part returns as ξ .We need to show that if ψ ∧ preconda|(cid:9) c(cid:10)(succp1,a, . . . , succpn,a) where c(cid:10)is a clause, then a clause in ξ subsumes(cid:10)(p1, . . . , pn).c(cid:10)c(succp1,a, . . . , succpn,a) = t1 ∨ · · · ∨ tmti cannot be TRUE or FALSE otherwise it would be subsumed by the last two terms of (14) in FO-STRIPS-Step. ti cannot bein Eff(a) and since the resolution is complete cshould be computed by (11).Complexity. Suppose that the length of the belief state formula is |ψ|. The first two lines (recursive calls) of the algorithmtake O (|ψ|) time. Splitting into pure literal clauses takes O (|E| + |ψ|) time because the size of the resulted formula is|E| + |S| and |S| (cid:2) |ψ| (a clause in the original belief state is either broken into multiple clauses, in which case the numberof ones added to E is more than the number of ones added to S, or is not broken and is added directly to E or S and thenumber of such clauses is less than |ψ|).(cid:10)After splitting into cases, every literal that is an instance of a member of Eff(a) is resolved out from E. This process maynot terminate in general, but we assume in the theorem that cases leave no variable uninstantiated. This reduces resolutionover those variables to propositional resolution, which is guaranteed to terminate. More specifically, there are at most ldifferent literals that are instantiated this way, for every affected literal in Eff(a).Thus, the size of E before resolution is (cid:2) l · |ψ|. After resolution E’s size increases to at most (l · |ψ|)2|Eff(a)|. The timecomplexity of the resolution depends on the size of the resulting set, so the algorithm takes O ((l · |ψ|)2|Eff(a)|), and theresulting belief state is of the same size.218A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219A.13. Proof of Theorem 21The number of different literals possible with m predicates of maximum arity R and C constants is bounded by 2m · (R +C)R , for m predicates. Thus, the total number of 2-clauses possible with m predicates of arity at most R and C constants(and unbounded number of variables) is bounded by (2m · (R + C)R )2. Since all clauses in the algorithm are 2-clauses, thenumber of clauses maintained in the belief state at time t is of size O (m2 · (R + C)2R ).The time complexity follows from this bound on the size of the resulting formula and noticing that the majority of timespent in the procedure is on resolution and deriving the resolvents in that bound.References[1] Eyal Amir, Allen Chang, Learning partially observable deterministic action models, Journal of Artificial Intelligence Research 33 (2008) 349–402.[2] Eyal Amir, Sheila McIlraith, Partition-based logical reasoning for first-order and propositional theories, Artificial Intelligence 162 (1–2) (2005) 49–88.[3] Eyal Amir, Stuart Russell, Logical filtering, in: Proc. Eighteenth International Joint Conference on Artificial Intelligence (IJCAI ’03), Morgan Kaufmann,2003, pp. 75–82.[4] A. Blass, Y. Gurevich, Background, reserve, and Gandy machines, in: P. Clote, H. Schwichtenberg (Eds.), Computer Science Logic (Proceedings of CSL2000), in: LNCS, vol. 1862, Springer, 2000, pp. 1–17.[5] Georg Böker, Jan Lunze, Stability and performance of switching Kalman filters, International Journal of Control 75 (16–17) (2002) 1269–1281.[6] Xavier Boyen, Daphne Koller, Tractable inference for complex stochastic processes, in: Proc. Fourteenth Conference on Uncertainty in Artificial Intelli-gence (UAI ’98), Morgan Kaufmann, 1998, pp. 33–42.[7] Jerry R. Burch, Ed.M. Clarke, Ken L. McMillan, David L. Dill, L.J. Hwang, Symbolic model checking: 1020 states and beyond, in: Proceedings of the FifthAnnual IEEE Symposium on Logic in Computer Science, IEEE Computer Society Press, Washington, DC, 1990, pp. 1–33.[8] Marco Cadoli, Francesco M. Donini, Paolo Liberatore, Marco Schaerf, The size of a revised knowledge base, Artificial Intelligence 115 (1) (1999) 25–64.[9] Allen Chang, Eyal Amir, Goal achievement in partially known, partially observable domains, in: Proceedings of the 16th Int’l Conf. on AutomatedPlanning and Scheduling (ICAPS ’06), AAAI Press, 2006.[10] Edmund M. Clarke, Armin Biere, Richard Raimi, Yunshan Zhu, Bounded model checking using satisfiability solving, Formal Methods in System De-sign 19 (1) (2001) 7–34.[11] Maria R. Cravo, João P. Cachopo, Ana C. Cachopo, João P. Martins, Permissive belief revision, in: EPIA, 2001, pp. 335–348.[12] Jon H. Davis, Foundations of Deterministic and Stochastic Control, Birkhäuser, Boston, 2002.[13] Tom Dean, Keiji Kanazawa, A model for reasoning about persistence and causation, Computational Intelligence 5 (3) (1989) 142–150.[14] Simon Dixon, Wayne Wobcke, The implementation of a first-order logic AGM belief revision system, in: ICTAI, 1993, pp. 40–47.[15] Arnaud Doucet, Nando de Freitas, Kevin Murphy, Stuart Russell, Rao-Blackwellised particle filtering for dynamic Bayesian networks, in: Proc. SixteenthConference on Uncertainty in Artificial Intelligence (UAI ’00), Morgan Kaufmann, 2000, pp. 176–183.[16] Arnaud Doucet, Nando De Freitas, Neil Gordon (Eds.), Sequential Monte Carlo Methods in Practice, Statistics for Engineering and Information Science,Springer-Verlag, 2001.[17] Thomas Eiter, Georg Gottlob, On the complexity of propositional knowledge base revision, updates, and counterfactuals, Artificial Intelligence 57 (2–3)(October 1992) 227–270.[18] Richard Fikes, Peter Hart, Nils Nilsson, Learning and executing generalized robot plans, in: Bonnie Webber, Nils Nilsson (Eds.), Readings in ArtificialIntelligence, Morgan Kaufmann, 1981, pp. 231–249.[19] Zoubin Ghahramani, Michael I. Jordan, Factorial hidden Markov models, Machine Learning 29 (1997) 245–275.[20] Zoubin Ghahramani, An introduction to Hidden Markov Models and Bayesian networks, International Journal of Pattern Recognition and ArtificialIntelligence 15 (1) (2001) 9–42.[21] G. De Giacomo, T. Mancini, Scaling up reasoning about actions using relational database technology, in: Proc. National Conference on Artificial Intelli-gence (AAAI ’04), 2004, pp. 245–250.[22] Hannaneh Hajishirzi, Eyal Amir, Sampling first-order logical particles, in: Proc. Twenty Fourth Conference on Uncertainty in Artificial Intelligence(UAI ’08), 2008.[23] Finn V. Jensen, Steffen L. Lauritzen, Kristian G. Olesen, Bayesian updating in recursive graphical models by local computation, Computational StatisticsQuarterly 4 (1990) 269–282.[24] Yi Jin, Michael Thielscher, Representing beliefs in the fluent calculus, in: ECAI, 2004, pp. 823–827.[25] Yi Jin, Michael Thielscher, Actions and belief revision: A computational approach, in: Belief Change in Rational Agents, 2005.[26] Emil Kalman Rudolph, A new approach to linear filtering and prediction problems, Transactions of the ASME – Journal of Basic Engineering Series D 5(1960) 35–45.[27] Hirofumi Katsuno, Ken Satoh, A unified view of consequence relation, belief revision and conditional logic, in: John Mylopoulos, Ray Reiter (Eds.),Principles of Knowledge Representation and Reasoning: Proc. Second International Conference (KR ’91), Morgan Kaufmann, Sydney, Australia, August1991, pp. 406–412.[28] Jérôme Lang, Belief update revisited, in: Proc. Twentieth International Joint Conference on Artificial Intelligence (IJCAI ’07), 2007.[29] Jérôme Lang, Belief update revisited, in: IJCAI, 2007, pp. 2517–2522.[30] Steffen L. Lauritzen, Propagation of probabilities, means and variances in mixed graphical association models, Journal of the American StatisticalAssociation 87 (1992) 1098–1108.[31] Joseph LaViola, A comparison of unscented and extended Kalman filtering for estimating quaternion motion, in: Proceedings of the American ControlConference, vol. 3, IEEE, 2003, pp. 2435–2440.[32] Richard Char-Tung Lee, A completeness theorem and a computer program for finding theorems derivable from given axioms, PhD thesis, University ofCalifornia, Berkeley, 1967.[33] Hector J. Levesque, Fiora Pirri, Ray Reiter, Foundations for the situation calculus, Electronic Transactions on Artificial Intelligence 3 (18) (December1998), http://www.etaij.org.[34] Renwei Li, Lu’is Moniz Pereira, What is believed is what is explained sometimes, in: Proc. of AAAI ’96, 1996, pp. 550–555.[35] Paolo Liberatore, The complexity of belief update, in: Proc. Fifteenth International Joint Conference on Artificial Intelligence (IJCAI ’97), 1997, pp. 68–73.[36] Paolo Liberatore, A framework for belief update, in: JELIA ’00: Proceedings of the European Workshop on Logics in Artificial Intelligence, Springer-Verlag, London, UK, 2000, pp. 361–375.[37] Vladimir Lifschitz, On the semantics of strips, in: Michael P. Georgeff, Amy Lansky (Eds.), Reasoning About Actions and Plans, Morgan Kaufmann, LosAltos, California, 1986, pp. 1–9.[38] Fangzhen Lin, Raymond Reiter, State constraints revisited, Journal of Logic and Computation 4 (5) (1994) 655–678.A. Shirazi, E. Amir / Artificial Intelligence 175 (2011) 193–219219[39] Fangzhen Lin, Raymond Reiter, How to progress a database II: The STRIPS connection, in: Proc. Fourteenth International Joint Conference on ArtificialIntelligence (IJCAI ’95), Montreal, Canada, 1995, pp. 2001–2007.[40] Fangzhen Lin, Ray Reiter, How to progress a database, Artificial Intelligence 92 (1–2) (1997) 131–167.[41] Yongmei Liu, Hector J. Levesque, Tractable reasoning with incomplete first-order knowledge in dynamic systems with context-dependent actions, in:Proc. Nineteenth International Joint Conference on Artificial Intelligence (IJCAI ’05), 2005, pp. 522–527.[42] Bill MacCartney, Sheila McIlraith, Eyal Amir, Tomas Uribe, Practical partition-based theorem proving for large knowledge bases, in: Proc. EighteenthInternational Joint Conference on Artificial Intelligence (IJCAI ’03), Morgan Kaufmann, 2003, pp. 89–96.[43] Peter S. Maybeck, Stochastic Models, Estimation, and Control, Mathematics in Science and Engineering, vol. 141, Academic Press, 1979.[44] John McCarthy, Patrick J. Hayes, Some philosophical problems from the standpoint of artificial intelligence, in: B. Meltzer, D. Michie (Eds.), MachineIntelligence, vol. 4, Edinburgh University Press, 1969, pp. 463–502.[45] Leonard A. McGee, Stanley F. Schmidt, Discovery of the Kalman filter as a practical tool for the aerospace industry, Technical Memorandum 86847,NASA, 1985.[46] Sheila McIlraith, Explanatory diagnosis: Conjecturing actions to explain observations, in: Anthony G. Cohn, Lenhart Schubert, Stuart C. Shapiro (Eds.),Principles of Knowledge Representation and Reasoning: Proc. Sixth Int’l Conference (KR ’98), Morgan Kaufmann, San Francisco, California, 1998,pp. 167–177.[47] Thomas Minka, A family of algorithms for approximate Bayesian inference, PhD thesis, MIT, 2001.[48] Kevin Murphy, Dynamic Bayesian networks: Representation, inference and learning, PhD thesis, University of California at Berkeley, 2002.[49] Megan Nance, Adam Vogel, Eyal Amir, Reasoning about partially observed actions, in: Proc. National Conference on Artificial Intelligence (AAAI ’06),AAAI Press, 2006.[50] Lawrence R. Rabiner, A tutorial on hidden Markov models and selected applications in speech recognition, Proceedings of the IEEE 77 (2) (February1989) 257–285.[51] Raymond Reiter, The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression, in: V. Lifs-chitz (Ed.), Artificial Intelligence and Mathematical Theory of Computation (Papers in Honor of John McCarthy), Academic Press, 1991, pp. 359–380.[52] Raymond Reiter, Proving properties of states in the situation calculus, Artificial Intelligence 64 (2) (1993) 337–351.[53] Raymod Reiter, Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems, MIT Press, 2001.[54] Steven Shapiro, Maurice Pagnucco, Iterated belief change and exogeneous actions in the situation calculus, in: ECAI, 2004, pp. 878–882.[55] Steven Shapiro, Maurice Pagnucco, Yves Lespérance, Hector J. Levesque, Iterated belief change in the situation calculus, in: Principles of KnowledgeRepresentation and Reasoning: Proc. Seventh Int’l Conference (KR ’2000), Morgan Kaufmann, 2000.[56] Afsaneh Shirazi, Eyal Amir, First order logical filtering, in: Proc. Nineteenth International Joint Conference on Artificial Intelligence (IJCAI ’05), Interna-tional Joint Conferences on Artificial Intelligence, 2005, pp. 589–595.[57] James R. Slagle, Chin-Liang Chang, Richard C.T. Lee, Completeness theorems for semantic resolution in consequence-finding, in: Proc. First InternationalJoint Conference on Artificial Intelligence (IJCAI ’69), 1969, pp. 281–285.[58] James R. Slagle, Interpolation theorems for resolution in lower predicate calculus, Journal of the ACM 17 (3) (July 1970) 535–542.[59] Gerald L. Smith, Stanley F. Schmidt, The application of statistical filter theory to optimal trajectory determination on-board a circular vehicle, in:American Astronautical Society Meeting, 1961, pp. 61–92.[60] Michael Thielscher, From situation calculus to fluent calculus: State update axioms as a solution to the inferential frame problem, Artificial Intelli-gence 111 (1999) 277–299.[61] Michael Thielscher, Flux: A logic programming method for reasoning agents, Theory Pract. Log. Program. 5 (4–5) (2005) 533–565.[62] Rudolph van der Merwe, Eric A. Wan, The square-root unscented Kalman filter for state and parameter-estimation, in: Proceedings IEEE InternationalConference on Acoustics, Speech, and Signal Processing (ICASSP 2001), vol. 6, 2001, pp. 3461–3464.[63] Stavros Vassos, Hector Levesque, Progression of situation calculus action theories with incomplete information, in: Proc. Twentieth International JointConference on Artificial Intelligence (IJCAI ’07), 2007.[64] Stavros Vassos, Hector Levesque, On the progression of situation calculus basic action theories: Resolving a 10-year-old conjecture, in: Proc. NationalConference on Artificial Intelligence (AAAI ’08), 2008.[65] Stavros Vassos, Gerhard Lakemeyer, Hector. J. Levesque, First-order strong progression for local-effect basic action theories, in: 11th InternationalConference on the Principles of Knowledge Representation and Reasoning, AAAI Press, 2008.[66] Mary-Anne Winslett, Updating Logical Databases, Cambridge University Press, 1990.