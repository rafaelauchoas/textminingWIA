Artificial Intelligence 257 (2018) 1–23Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintConstants and finite unary relations in qualitative constraint reasoningPeter JonssonDepartment of Computer and Information Science, Linköping University, SE-581 83 Linköping, Swedena r t i c l e i n f oa b s t r a c tArticle history:Received 30 May 2017Received in revised form 1 December 2017Accepted 13 December 2017Available online 20 December 2017Keywords:Constraint satisfactionQualitative reasoningComputational complexityExtending qualitative CSPs with the ability of restricting selected variables to finite sets of possible values has been proposed as an interesting research direction with important applications, cf. “Qualitative constraint satisfaction problems: an extended framework with landmarks” by Li, Liu, and Wang (2013) [48]. Previously presented complexity results for this kind of extended formalisms have typically focused on concrete examples and not on general principles. We propose three general methods. The first two methods are based on analysing the given CSP from a model-theoretical perspective, while the third method is based on directly analysing the growth of the representation of solutions. We exemplify the methods on temporal and spatial formalisms including Allen’s algebra and RCC-5.© 2017 Elsevier B.V. All rights reserved.1. IntroductionThis introductory section is divided into two parts where we first discuss the background of this article and thereafter describe our results.1.1. BackgroundQualitative reasoning has a long history in artificial intelligence and the combination of qualitative reasoning and con-straint reasoning has been a very productive field. A large number of constraint-based formalisms for qualitative reasoning have been invented, most notably within temporal and spatial reasoning, and they have been investigated from many dif-ferent angles. It has been noted that a particular extension to qualitative CSPs is highly relevant: Cohn and Renz [25, p. 578]observe the followingOne problem with this [constraint-based] approach is that spatial entities are treated as variables which have to be instantiated using values of an infinite domain. How to integrate this with settings where some spatial entities are known or can only be from a small domain is still unknown and is one of the main future challenges of constraint-based spatial reasoning.and Li, Liu, and Wang [48, p. 33] writeE-mail address: peter.jonsson@liu.se.https://doi.org/10.1016/j.artint.2017.12.0030004-3702/© 2017 Elsevier B.V. All rights reserved.2P. Jonsson / Artificial Intelligence 257 (2018) 1–23There is a growing consensus, however, that breakthroughs are necessary to bring spatial/temporal reasoning theory closer to practical applications. One reason might be that the current qualitative reasoning scheme uses a rather re-stricted constraint language: constraints in a qualitative CSP are always taken from the same calculus and only relate variables from the same infinite domain. This is highly undesirable, as constraints involving restricted variables and/or multiple aspects of information frequently appear in practical tasks such as urban planning and spatial query processing.That is, they regard the question of how to extend constraint formalisms with constants and other unary relations1as being very important; the same observation has been made in a wider context by Kreutzmann and Wolter [44]. An interesting recent example where such extensions of qualitative formalisms are necessary is the article on spatial query processing by Nikolaou and Koubarakis [56].(cid:3) ⊆ D | DGiven a (finite or infinite) set of values D, we let Dc = {{d} | d ∈ D} (i.e. the set of constant relations over D) and is finite} (i.e. the set of finite unary relations over D). Let us consider finite-domain CSPs for a moment. D f = {DFor every finite constraint language (cid:2) over D, the computational complexity of CSP((cid:2) ∪ D f ) is known due to results by Bulatov [17]. This is an important complexity result in finite-domain constraint satisfaction and it has been reproven several times using different methods [2,18]. Very recently, the complexity of CSP((cid:2) ∪ Dc) and CSP((cid:2)) has also been determined [19,63].(cid:3)The situation is radically different when considering infinite-domain CSPs where similar powerful results are not known. This can, at least partly, be attributed to the fact that infinite-domain CSPs constitute a much richer class of problems than finite-domain CSPs: for every computational problem X , there is an infinite-domain constraint language (cid:2) X such that Xand CSP((cid:2) X ) are polynomial-time Turing equivalent [9]. Finite domain CSPs are, on the other hand, always members of NP. Hence, the majority of computational problems cannot be captured by finite-domain CSPs.Nevertheless, there exist concrete examples where interesting qualitative and/or infinite-domain CSPs have been ex-tended with finite unary relations and/or constant relations. A very early example is the article by Jonsson and Bäck-ström [38] (see also Koubarakis [43]) where several temporal formalisms (including the point algebra and Allen’s algebra) are extended by unary relations (and also other relations). A more recent example is the article by Li et al. [48] where the point algebra and Allen’s algebra are once again considered. Li et al. also study several other formalisms including the cardinal relation algebra and RCC-5 and RCC-8 over two-dimensional regions and where constants are assumed to be polyg-onal regions. The results for the temporal formalisms by Jonsson and Bäckström are not completely comparable with the results by Li et al.: Jonsson and Bäckström’s approach is based on linear programming while Li et al. use methods based on enforcing consistency and computational geometry. Consistency-enforcing methods have certain advantages such as lower time complexity and easier integration with existing constraint solving methods. At the same time, the linear programming method allows for more expressive extensions with retained tractability. Both consistency-based and LP-based methods have attracted attention lately, cf. Giannakopoulou et al. [30] and Kreutzmann and Wolter [44], respectively, and generalisations of the basic concepts have been proposed and analysed by de Leng and Heintz [26].We see that this line of research has to a large extent been based on analysing concrete examples. The approach in this article will be different: instead of studying concrete examples, we study basic principles and aim at providing methods that are applicable to many different constraint formalisms.1.2. Our resultsWe present three different methods. The first two methods are based on analysing the given CSP from a model-theoretical perspective. The third method is more of a toolbox for proving that the size of solutions (i.e., the number of bits needed for representing a solution) grows in a controlled way, and that problems consequently are in NP. We will now describe these methods in slightly more detail.Method I. The first method is based on exploiting ω-categoricity. This is a model-theoretical property of constraint languages and other mathematical structures that have gained a lot of attention in the literature. Briefly speaking, a constraint language (cid:2) is ω-categorical if (cid:2) is the unique countable model (up to isomorphism) of the set of all first-order sentences that are true in (cid:2). One of the interesting aspects of ω-categorical constraint languages is that they in some respects resemble constraint languages over finite domains: this is expressed by a famous result proved by Engeler, Ryll-Nardzewski, and Svenonius (see Theorem 11). From a model-theoretical point of view, ω-categoricity is a very strong assumption. Nevertheless, many interesting CSP problems can be formulated using ω-categorical constraint languages: examples include the point algebra, RCC-5, RCC-8, and Allen’s algebra. Among the ω-categorical constraint languages, the model-complete cores are particularly interesting. Such constraint languages allow us to define gadgets that can be used for simulating constants. This method is applicable to a wide selection of CSP((cid:2)) problems when (cid:2) is ω-categorical. The drawback with the method is that it may be difficult to compute the gadgets used for simulating constants. Given that (cid:2) is an ω-categorical model-complete core and that the gadgets can be computed efficiently, we verify (based on results by Bodirsky [5]) that CSP((cid:2)) is polynomial-time equivalent to CSP((cid:2) ∪ Dc). To demonstrate the strength of this method, we apply it to an extended version of Allen’s algebra. 1 Finite unary relations are sometimes referred to as landmarks in the AI literature. We will use the standard mathematical term throughout the article.P. Jonsson / Artificial Intelligence 257 (2018) 1–233This exercise shows, for example, that relations with higher arity than two does not pose any particular problem. This is an important observation since previous work (such as Li et al. [48]) has mostly focused on binary relations.Method II. The second method is based on homogeneity. This is a property of relational structures that has been studied for a long time in mathematics and logic. Some machinery is needed for the formal definition so we refrain from giving it here. However, we note that homogeneous relational structures have many interesting properties: for instance, they allow quantifier elimination and they are ω-categorical whenever the structure contains a finite number of relation symbols and the domain is countably infinite. Even though homogeneity is a very strong property of relational structures, there are many well-known examples within AI and computer science. An early example was provided by Hirsch [33] who proved that Allen’s algebra (with the standard interval-based representation) is homogeneous. Given that (cid:2) is homogeneous and satisfies certain additional restrictions, we show that CSP((cid:2)) is polynomial-time equivalent to CSP((cid:2) ∪ Dc). The additional restrictions are a bit technical; in brief, (cid:2) needs to be based on a partition scheme in the sense of Ligozat and Renz [51]. This method has both advantages and disadvantages when compared to method I. The main advantage is that we do not have to compute the gadgets that are needed for applying method I while the main disadvantage is that we are restricted to a particular kind of constraint languages. Nevertheless, many interesting examples can be found within this restricted class of problems.Method III. Even though many qualitative CSPs are ω-categorical and method I and/or II may be applicable, this is not always the case. One alternative approach is to analyse the growth of CSP((cid:2) ∪ Dc) solutions, measured as a function of instance size. If the growth is polynomially bounded, then it follows immediately that CSP((cid:2) ∪ Dc) is a member of NP. One disadvantage with this method is that we cannot obtain polynomial-time equivalences between CSP((cid:2)) and CSP((cid:2) ∪ Dc). Another disadvantage is that it may be quite difficult to obtain such bounds. In certain cases, one can inductively compute bounds by a fairly straightforward analysis of problem instances. We demonstrate this by analysing a variant of RCC-5 that is based on finite sets of integers instead of closed sets in topological spaces.We illustrate the methods on both temporal and spatial formalisms (including point-based temporal constraints, Allen’s algebra, and RCC-5). We want to stress that the representation of domains and relations is very important. In fact, we will see that RCC-5 can be represented in two different ways (which we denote RCC-5set and RCC-5ω−cat) that give rise to exactly the same computational problem (by Proposition 13). However, we will also see (in Sections 5 and 6.2) that there exists an RCC-5 constraint language R such that RCC-5set(R ∪ {{c}}) is NP-complete while RCC-5ω−cat(R ∪ X) is polynomial-time solvable, where {c} is a particular constant relation and X is an arbitrary finite set of constants. Thus, adding constant relations to constraint languages that are computationally equivalent (but represented differently) may lead to problems with different computational complexity.The reader may find it strange that we mostly consider extensions with constant relations. The explanation is the close connection between problems extended with constants and with finite unary relations: if one of them is in NP, then both are in NP (see Lemma 3). Most problems under consideration become NP-hard when adding unary relations containing at least three elements: for example, if the constraint language contains the disequality relation (cid:6)=, then NP-hardness follows from a straightforward reduction from 3-Colourability. However, NP-completeness is not inevitable if we only add constants to the language—a concrete example of this phenomenon was given earlier in the context of RCC-5. Thus, we can extract more information by considering constants instead of finite unary relations. The same viewpoint is taken by, for instance, Li et al. [48].This article has the following structure. We introduce the basic concepts from CSPs and logic together with some infor-mation about homomorphisms in Section 2. Temporal constraints, Allen’s algebra, and RCC-5 will be introduced in Section 3. The three different methods outlined above are presented in Sections 4, 5, and 6, respectively. We conclude the article with a brief discussion in Section 7. This article is a revised and extended version of a conference paper [37].2. PreliminariesThis section is divided into three parts where we provide basic information concerning constraint satisfaction, logic, and automorphisms of relational structures, respectively.2.1. Constraint satisfaction problemsWe begin by presenting CSPs in terms of homomorphisms. This view is widely used in the literature on finite-domain CSP and it will provide us with certain advantages: some of the properties that we consider later on are inherently based on homomorphisms. One should note, however, that there is no fundamental difference with the more common AI viewpoint that constraint satisfaction is about assigning values to variables in a way that satisfy certain constraints. In fact, it will be convenient to use both viewpoints in the sequel.A relational signature τ consists of relation symbols R i with associated arities ki ∈ N. A (relational) structure (cid:2) over relational ⊆ Dki(cid:2) for each relation symbol R i of arity ki . i . We sometimes use the shortened notation xsignature τ (also called τ -structure) is a set D(cid:2) (the domain) and relation R(cid:2)iIf the reference to the structure (cid:2) is clear, we may omit the superscript in R(cid:2)for a vector (x1, . . . , xn) of any length.4P. Jonsson / Artificial Intelligence 257 (2018) 1–23Let (cid:2) and (cid:5) be τ -structures. A homomorphism from (cid:2) to (cid:5) is a function ffrom D(cid:2) to D(cid:5) such that for each n-ary relation symbol R in τ and each n-tuple a = (a1, . . . , an), if a ∈ R(cid:2), then ( f (a1), . . . , f (an)) ∈ R(cid:5).Let (cid:2) be a structure with a relational signature τ . Then, the constraint satisfaction problem (CSP) for (cid:2) is the following computational problem.CSP((cid:2)).Instance: A τ -structure (cid:5).Question: Is there a homomorphism from (cid:5) to (cid:2)?Example 1. For k ≥ 1, the k-Colourability problem is the computational problem of deciding for a given finite graph Gwhether the vertices can be coloured by k colours such that adjacent vertices get different colours. It is well-known that the k-colouring problem is NP-hard for k ≥ 3 and tractable when k ≤ 2. For k ≥ 1, let Kk denote the complete loop-free graph on k vertices. We view undirected graphs as τ -structures where τ contains a single binary relation symbol E which denotes a symmetric and anti-reflexive relation. Then, the k-Colourability problem can be viewed as CSP({Kk}).Example 2. Consider the problem CSP((Q; <)) where < is the binary order relation of the set Q of rational numbers. Let G = (V , A) be a directed graph. It is easy to see that there is a homomorphism from G to (Q; <) if and only if G contains no directed cycle. Thus, CSP((Q; <)) is solvable in polynomial time since cycle detection in directed graphs can be carried out in polynomial time.A homomorphism from a given τ -structure (cid:5) to (cid:2) is often called a solution of (cid:5) for CSP((cid:2)). In the homomorphism perspective on CSPs, the structure (cid:2) is typically called the template of the constraint satisfaction problem CSP((cid:2)). The reader should be aware that several different names are used in the literature; constraint language is probably the most common within AI. Clearly, we can equivalently define the instances of the CSP((cid:2)) problem as a tuple (V , C) where V is a set of variables and C is a set of constraints of the form R(xi1 , . . . , xik ) where R is a relation in (cid:2), k is the arity of R, and {xi1 , . . . , xik} ⊆ V . In this case, a solution is a function from V to the domain of (cid:2) satisfying ( f (xi1 ), . . . , f (xik )) ∈ R for every R(xi1 , . . . , xik ) ∈ C .To represent an input structure (cid:5) of CSP((cid:2)), we need to fix a suitable representation of the relation symbols in the signature τ . We will see in the forthcoming sections that the choice of representation is very important. Given a particular representation of relation symbols, we let ||(cid:5)|| denote the size of an input structure (cid:5). It is in general not clear how to represent solutions for CSP((cid:2)) in a compact way, i.e., by an object whose size is polynomially bounded in the input size. When domains are of fixed finite size, then this is indeed possible by simply writing down the variable assignment. When domains are of infinite size, this is not always possible. Note, however, that for the definition of the problem CSP((cid:2)) we do not need to explicitly represent solutions since we only have to decide the existence of solutions.(cid:3) ⊆ D | DLet D be a domain with a particular representation and let ||d|| denote the size of the representation of d ∈ D. We let is finite}. Given a representation of the elements in D, we always represent the Dc = {{d} | d ∈ D} and D f = {Dmembers of D f as sets of elements in D and we may assume that the size of D f is linear in the sizes of its elements. Other ways of representing D f are possible (such as solution sets of equations) but they are outside the scope of this article. If (cid:2)is a constraint language with domain D, then CSP((cid:2) ∪ Dc) is the problem CSP((cid:2)) extended with constants and CSP((cid:2) ∪ D f )is the problem CSP((cid:2)) extended with finite unary relations. The next lemma strengthens Proposition 1(iii) in Li et al. [48]by extending it to arbitrary constraint languages.(cid:3)Lemma 3. Let (cid:2) denote a constraint language. CSP((cid:2) ∪ Dc) is in NP if and only if CSP((cid:2) ∪ D f ) is in NP.Proof. Assume that CSP((cid:2) ∪ D f ) is in NP. Then, CSP((cid:2) ∪ Dc) is in NP, too, since Dc ⊆ D f . Assume instead that CSP((cid:2) ∪ Dc)is in NP. Let us consider an arbitrary instance I = (V , C) of CSP((cid:2) ∪ D f ). Assume I has a solution s : V → D. We replace is an instance of CSP((cid:2) ∪ Dc), it each constraint U (x) ∈ C with U ∈ D f by the constraint {s(v)}(v). The resulting instance Iis satisfiable, and ||Ican be verified in polynomial time by a certificate X . A polynomial-time verifiable certificate for I is thus the tuple (I(cid:3)|| ≤ ||I||. The problem CSP((cid:2) ∪ Dc) is in NP so the satisfiability of I(cid:3)(cid:3), X). (cid:2)(cid:3)Lemma 3 allows us to, for example, concentrate on CSP((cid:2) ∪ Dc) instead of CSP((cid:2) ∪ D f ) when proving membership in NP.2.2. LogicFirst-order formulas ϕ over the signature τ (or, in short, τ -formulas) are as usual inductively defined using the logical symbols of universal and existential quantification, disjunction, conjunction, negation, equality, bracketing, variable symbols and the symbols from τ . The semantics of a first-order formula over some τ -structure is defined in the ordinary Tarskian style. A τ -formula without free variables is called a τ -sentence. We write (cid:2) |= ϕ if and only if the τ -structure (cid:2) is a model for the τ -sentence ϕ, that is, satisfies ϕ. This notation is lifted to sets of sentences (viewed as conjunctions) in the usual way.P. Jonsson / Artificial Intelligence 257 (2018) 1–2352.2.1. Logical definitionsOne can use first-order formulas over the signature τ to define relations over a given τ -structure (cid:2): for a formula ϕ(x1, . . . , xk) where x1, . . . , xk are the free variables of ϕ, the corresponding relation R is the set of all k-tuples (t1, . . . , tk) ∈Dk(cid:2) such that ϕ(t1, . . . , tk) is true in (cid:2). In this case, we say that R is first-order definable in (cid:2). We extend definability to structures in the natural way: a structure (cid:7) is first-order definable in (cid:2) if every relation in (cid:7) is first-order definable in (cid:2). Note that our definitions are always parameter-free, i.e., we do not allow the use of domain elements in them. Quantifier-free formulas will be of a certain interest in the following. We say that the τ -structure (cid:2) admits quantifier elimination if every relation with a first-order definition in (cid:2) has a quantifier-free definition in (cid:2). We also say that a set of formulas T admits quantifier elimination if each φ ∈ T has a logically equivalent quantifier-free formula.We will often consider quantifier-free formulas in conjunctive normal form (CNF). Such a formula is a conjunction of clausesand a clause is a disjunction of literals, i.e., negated or unnegated atomic formulas. A first-order τ -formula φ(x1, . . . , xn) is called positive if it does not contain the negation symbol ¬. We note that every quantifier-free positive formula can be rewritten into a logically equivalent positive formula in conjunctive normal form.A first-order τ -formula φ(x1, . . . , xn) is called existential if it is of the form∃xn+1, . . . , xm.ψwhere ψ is a quantifier-free first-order formula. A subset of positive and existential formulas is of particular interest to us: a first-order τ -formula φ(x1, . . . , xn) is called primitive positive if it is of the form∃xn+1, . . . , xm.ψ1 ∧ · · · ∧ ψlwhere ψ1, . . . , ψl are atomic τ -formulas, i.e., formulas of the form1. R( y1, . . . , yk) with R ∈ τ and yi ∈ {x1, . . . , xm} or(cid:3) ∈ {x1, . . . , xm}.2. y = yfor y, y(cid:3)Primitive positive formulas will be called pp-formulas for short. In a pp-formula, equality relations can always be re-moved by identifying variables. This is not true for general formulas since we may, for instance, have formulas such as ¬(x = y). If the relation R has a primitive positive definition in (cid:2), then we say that R is pp-definable in (cid:2), and we define (cid:12)(cid:2)(cid:13) to be the set of relations that are pp-definable in (cid:2). Jeavons [36] has proved the following result.Theorem 4. If (cid:2) is a structure and the relation R is pp-definable in (cid:2), then there is a polynomial-time reduction from CSP((cid:2) ∪ {R}) to CSP((cid:2)).This explains why pp-definability is important when studying the complexity of CSP problems. To exemplify pp-definitions and Theorem 4, consider the structure (cid:2) = {N; {1, 2, 3, 4}, (cid:6)=}. We see that the binary relation K 4 = {(x, y) ∈{1, 2, 3, 4}2 | x (cid:6)= y} (from Example 1) is pp-definable in (cid:2) sinceK4(x, y) ⇔ {1, 2, 3, 4}(x) ∧ {1, 2, 3, 4}( y) ∧ x (cid:6)= y,and it follows that CSP((cid:2)) is NP-hard. It is worth mentioning that many of the operations that are encountered in relation algebra can be viewed as pp-definitions. Let R and S denote binary relations. Then, the converse R(cid:10) has the pp-definition R(cid:10)(x, y) ⇔ R( y, x), the intersection R ∩ S has the pp-definition (R ∩ S)(x, y) ⇔ R(x, y) ∧ S(x, y), and the composition R ◦ Shas the pp-definition (R ◦ S)(x, y) ⇔ ∃z.R(x, z) ∧ S(z, y).We finally discuss certain families of binary relations. Partition schemes were introduced by Ligozat and Renz [51] and they have been highly influential in CSP research. Let D be a non-empty domain. Given a finite family B = {B 1, . . . , Bk} of B = D2 and that B is pairwise disjoint (PD) if B i ∩ B j = ∅binary relations over D, we say that B is jointly exhaustive (JE) if whenever 1 ≤ i (cid:6)= j ≤ k. If B is simultaneously JE and PD (which we denote JEPD), then B forms a partition of the set D2.(cid:2)Definition 5. Let D be a non-empty domain and let B = {B 1, . . . , Bk} be a finite set of binary relations over D. We say that B is a partition scheme if the following holds:1. B is JEPD,2. the equality relation EQD = {(x, x) ∈ D2} is in B, and3. for every B i ∈ B, the converse relation B(cid:10)iis in B.It is important to note that if B is a partition scheme over a domain D, then for arbitrary d, d(cid:3) ∈ D there exists exactly (cid:3)) ∈ B. Given a finite set of binary relations B = {R1, . . . , Rk}, we follow notational conventions one B ∈ B such that (d, dfrom [24,40] and define B∨=can be viewed as a disjunction B1(x, y) ∨ B2(x, y) ∨ · · · ∨ Bk(x, y) for some {B1, . . . , Bk} ⊆ B. We sometimes abuse notation and write (B1, . . . , Bk) to denote the relation B1 ∪ · · · ∪ Bk. The set B∨=are the natural as the set of all unions of relations from B. Equivalently, each relation in B∨=and the problem CSP((cid:2)) where (cid:2) ⊆ B∨=6P. Jonsson / Artificial Intelligence 257 (2018) 1–23objects that are studied in connection with partition schemes. If B is a partition scheme, then every relation in B∨=is quantifier-free positive definable in B but not necessarily pp-definable in B (since disjunctions are not allowed in pp-definitions).2.2.2. Membership in NPWhen a constraint language (cid:2) is logically defined in some constraint language (cid:7), then (cid:2) sometimes inherits useful properties of (cid:7). We have already encountered Theorem 4 which is one example of this. We will next present two results that connect logical definability with membership in NP. These results will be helpful in the forthcoming Sections 5 and 6.Lemma 6. Let B denote a partition scheme over domain D, and let (cid:2) denote a finite constraint language that is quantifier-free definable in B. If CSP(B ∪ Dc) is in NP, then CSP((cid:2) ∪ Dc) is in NP.Proof. We assume that B = {B1, . . . , Bk}, (cid:2) = {R1, . . . , Rm}, and that every relation R i , 1 ≤ i ≤ m, is defined by a quantifier-free formula φi . Without loss of generality, we assume that φi is written in conjunctive normal form. We first demonstrate that every clause in φi can be rewritten as a disjunction of relations in B. If φi does not contain any negative literals, then φi itself has this property. Otherwise, consider a negation such as ¬(B i (x, y)). Since B is a partition scheme, we have the following equivalence:¬(B i(x, y)) ⇔(cid:3)B∈B\{B i }B(x, y).We can thus assume, without loss of generality, that φi does not contain any negated literals.Let I = (V , C) denote an arbitrary instance of CSP((cid:2) ∪ Dc) with the solution s : V → D. Pick an arbitrary constraint R i(x1, . . . , xn) ∈ C with R i ∈ (cid:2). We consider the defining formula φi = σ1 ∧ · · · ∧ σp . From each clause σi , 1 ≤ i ≤ p, choose one literal that is satisfied by solution s. Add these literals to the set C. Repeat this process for all constraints in C . Finally, add all constraints U (x) ∈ C with U ∈ Dc to C. Note the following.(cid:3)(cid:3)(cid:3)) is an instance of CSP(B ∪ Dc),1. (V , C2. the size of (V , C3. (V , C4. there exists a polynomial-time verifiable certificate for the satisfiability of (V , C(cid:3)) is satisfiable (as is witnessed by the function s), and(cid:3)) is polynomially bounded in the size of (V , C),(cid:3)) (since CSP(B ∪ Dc) is in NP).Hence, there is a polynomial-time verifiable certificate for the satisfiability of (V , C): concatenate the instance (V , Cwith a polynomial-time verifiable certificate for the satisfiability of (V , C(cid:3)). This implies that CSP((cid:2) ∪ Dc) is in NP. (cid:2)(cid:3))Lemma 7. Let (cid:7) denote a constraint language over domain D, and let (cid:2) denote a finite constraint language that is quantifier-free positive definable in (cid:7). If CSP((cid:7) ∪ Dc) is in NP, then CSP((cid:2) ∪ Dc) is in NP.Proof. The proof is virtually the same as the proof of Lemma 6. We merely observe the following: when a quantifier-free positive formula is converted into conjunctive normal form, the resulting formula is still positive, i.e., it contains no negation symbols. Thus, we will not need to rewrite negated literals as disjunctions and it is not required that (cid:7) is a partition scheme. (cid:2)Results like Lemma 6 and 7 may give the impression that there is a strong connection between the complexity of CSP((cid:2))and CSP((cid:2) ∪ Dc). Unfortunately, this is not true in general. To see this, we begin by arbitrarily choosing a complexity class Cthat admits complete problems under polynomial-time reductions (such as PSPACE or EXPTIME). Let (cid:2) = {R 1, R2, . . . } be a constraint language over domain N such that CSP((cid:2)) is C-complete under polynomial-time reductions. Results by Bodirsky and Grohe [9, Theorem 1] provide a systematic way of obtaining such (cid:2). However, one should note that it is often possible (and sometimes even simpler) to obtain such a (cid:2) via ad hoc constructions.Let 0k denote the all-zero vector with k elements. Given a relation R ∈ (cid:2) with arity k, we defineR(cid:3) = {(a1 + 1, . . . , ak + 1) | (a1, . . . , ak) ∈ R} ∪ {0k},(cid:3)} where(cid:3) | R ∈ (cid:2)} ∪ {Sand let (cid:2)(cid:3) = {R(cid:3) = {(1, n) ∈ N2 | n ≥ 1} ∪ {02}.SThe problem CSP((cid:2)(cid:3)) is trivially in P since every instance (V , C) is satisfied by assigning the value 0 to each variable. such that We will next show that the problem CSP((cid:2)(cid:3) ∪ Nc) is, on the other hand, C-hard. We can thus find examples of (cid:2)(cid:3)CSP((cid:2)(cid:3)) and CSP((cid:2)(cid:3) ∪ Nc) are arbitrarily far separated.P. Jonsson / Artificial Intelligence 257 (2018) 1–237To verify that CSP((cid:2)(cid:3) ∪ Nc) is C-hard, we present a polynomial-time reduction from CSP((cid:2)) to CSP((cid:2)(cid:3) ∪ {{1}}). Let (V , C)(cid:3), C(cid:3)) such that V(cid:3) = V ∪ { y} anddenote an arbitrary instance of CSP((cid:2)). Introduce one fresh variable y and define (V(cid:3) = {RC(cid:3)i(¯x) | R i(¯x) ∈ C} ∪ {S(cid:3)( y, x) | x ∈ V } ∪ {{1}( y)}.If (V , C) has a solution f : V → N, then it is obvious that the function f(cid:3) : V(cid:3) → N defined by f(cid:3)( y) = 1 and f(cid:3)(x) =f (x) + 1, x ∈ V , is a solution to (V(cid:3) : V(cid:3)) has a solution fIf (V(cid:3), C(cid:3)).(cid:3), C(cid:3) → N, then we note that no variable can be assigned the value 0. Thus, it is easy to verify that the function f : V → N defined by f (x) = f(cid:3)(x) − 1 is a solution to (V , C).2.3. AutomorphismsKeeping the homomorphism definition of CSPs in mind may be helpful in the rest of this section. Let (cid:2) and (cid:5) denote two relational τ -structures over domain D. We say that a function f : D → D preserves R ∈ (cid:2) if for every (a1, . . . , ak) ∈R, the tuple ( f (a1), . . . , f (ak)) is in R, too. A bijective homomorphism ffrom (cid:2) to (cid:5) is called an isomorphism if the inverse of fis a homomorphism from (cid:5) to (cid:2). If (cid:2) and (cid:5) are isomorphic, then it is clear that CSP((cid:2)) and CSP((cid:5)) are the same computational problem. An injective homomorphism that additionally preserves the complement of each relation is called an embedding; the complement of a k-ary relation R in (cid:2) is the relation Dk \ R. Homomorphisms from (cid:2) to (cid:2) are called endomorphisms of (cid:2). An automorphism of (cid:2) is a bijective endomorphism whose inverse is also an endomorphism. In other words, automorphisms are bijective embeddings of (cid:2) into (cid:2) or isomorphisms from (cid:2) to (cid:2). The set containing all endomorphisms of (cid:2) is denoted End((cid:2)) while the set of all automorphisms is denoted Aut((cid:2)).Example 8. Let R+ = {(x, y, z) ∈ Z3 | x + y = z}. For arbitrary a ∈ Z, let ea : Z → Z be defined as ea(n) = a · n. Let e : Z → Zbe an arbitrary endomorphism of (Z; R+); e is a homomorphism so (e(x), e( y), e(z)) ∈ R+ whenever (x, y, z) ∈ R+ and, more generally, e(i=1 e(xi) when x1, . . . , xk ∈ Z. Arbitrarily choose n ∈ Z and note thati=1 xi) =(cid:4)k(cid:4)ke(n) = e(1 + · · · + 1(cid:8)(cid:5)(cid:6)(cid:7)) = n · e(1).n timesIt follows that End((Z; R+)) = {ea | a ∈ Z}. Note that ea has an inverse if and only if a ∈ {−1, 1}. Thus, Aut((Z; R+)) ={ea | a ∈ {−1, 1}}.A useful observation is that if (V , C) is an instance of CSP((cid:2)) with a solution s : V → D, then s(cid:3) : V → D defined by (cid:3)(x) = α(s(x)) is a solution to (V , C) for every α in Aut((cid:2)) or End((cid:2)). If a function s : V → D is not a solution to (V , C), s(cid:3)then s(cid:3)(x) = α(s(x)) is not a solution for any α ∈ Aut((cid:2)) while smay or may not be a solution if α ∈ End((cid:2)) \ Aut((cid:2)).In the following, let G be a set of permutations of a set X . We say that G is a permutation group if the identity permuta-−1(x) are also in G. In other words, G is closed tion is in G and for arbitrary g, f ∈ G, the functions x (cid:18)→ g( f (x)) and x (cid:18)→ gunder function composition and inversion. If (cid:2) is a τ -structure, then Aut((cid:2)) is a permutation group on the set D(cid:2). For n ≥ 1, the orbit of an n-tuple (t1, . . . , tn) ∈ Xn under G is the set {(α(t1), . . . , α(tn)) | α ∈ G}. Clearly, the orbits of n-tuples under G partition the set Xn, that is, every (t1, . . . , tn) ∈ Xn lies in precisely one orbit under G.Example 9. Consider once again the structure (Z; R+) from Example 8. It is obvious that {e1, e−1} forms a group under function composition. If a ∈ Z, then the orbit of (a) equals {a, −a} so (Z; R+) admits an infinite number of different orbits under its automorphism group.We will now introduce the central concept of ω-categoricity. It has been observed that ω-categoricity plays an important role in the context of qualitative reasoning. We will not go into the details here but the interested reader may refer to, for instance, Huang [35], Westphal et al. [62], Bodirsky and Dalmau [8], and Bodirsky and Jonsson [11].A first-order theory is a set of first-order sentences. When the first-order sentences are over the signature τ , we say that T is a τ -theory. The (full) theory of a τ -structure (cid:5) (denoted Th((cid:5))) is the set of τ -sentences φ such that (cid:5) |= φ. A modelof a τ -theory T is a τ -structure (cid:5) such that (cid:5) satisfies all sentences in T . Theories that have a model are called satisfiable. Since models are structures, the notion of isomorphism for structures immediately carries over to models. A satisfiable first-order theory T is ω-categorical if all countable models of T are isomorphic, and a structure is ω-categorical if its first-order theory is ω-categorical. All ω-categorical structures that appear in this article will be countably infinite so we make the convention that ω-categorical structures are countably infinite. Note that the first-order theory of a finite structure does not have infinite models so finite structures are ω-categorical. One of the first infinite structures that was found to be ω-categorical (by Cantor [22]) is the linear order of the rational numbers (Q; <). There are many characterisations of ω-categoricity and the most important one is in terms of the automorphism group.Definition 10. A permutation group G over a countably infinite set X is oligomorphic if G has only finitely many orbits of n-tuples for each n ≥ 1.8P. Jonsson / Artificial Intelligence 257 (2018) 1–23Basic relationI precedes JJ preceded by II meets JJ met by II overlaps JJ overlapped by II during JJ includes II starts JJ started by II finishes JJ finished by II equals J(cid:2)(cid:2)(cid:2)ppmmoodds(cid:2)sf(cid:2)f≡(cid:2)IllustrationIIIEndpoints+ < JI−JJJJJJJIIIIIIIIJJJJIIJJJJJJIIIJJJJJJIIIJJJJJJIIIIJJJJ+ = JI−− < J+ < J− > J+ < J− = J+ < J+ = J− > J− = J+ = JIIIIIIIIII− < I++,,,,,−+−++−−+An accessible proof of the following theorem can be found in Hodges’ book [34].Fig. 1. The definitions of the basic relations of Allen’s algebra.Theorem 11 (Engeler, Ryll-Nardzewski, Svenonius). Let (cid:2) be a countably infinite structure with countable signature. Then, (cid:2) is ω-categorical if and only if Aut((cid:2)) is oligomorphic.Example 9 immediately implies that (Z; R+) is not an ω-categorical structure. Consider the structure (Z; <). One can verify that Aut((Z; <)) = {x (cid:18)→ x + a | a ∈ Z}. Hence, (Z; <) is not ω-categorical (despite the fact that (Q; <) is indeed ω-categorical): the orbits of (0, 0), (0, 1), (0, 2), . . . are distinct.We conclude this section by presenting a result that connects first-order definability with ω-categoricity.Theorem 12 (Thm. 7.3.8 in Hodges [34]). If (cid:2) is an ω-categorical structure and (cid:5) is first-order definable in (cid:2), then (cid:5) is ω-categorical, too.3. CSP examplesWe will now give a brief introduction to three qualitative formalisms: temporal constraints (including the point algebra), Allen’s algebra and RCC-5. These formalisms will be used as illustrating examples during the course of the article.We begin with the structure (Q; <), that is, the rational numbers with the usual linear ordering relation. Constraint languages that are first-order definable in (Q; <) are well-studied in the literature and they are sometimes called temporal constraint languages. We have already noticed that (Q; <) is ω-categorical which implies that all temporal constraint lan-guages are ω-categorical by Theorem 12. Furthermore, the computational complexity of CSP((cid:2)) is known for every finite temporal constraint language (cid:2) [13]. In particular, CSP((cid:2)) is either in P or it is an NP-complete problem. The point algebra(PA) is the constraint language {<, =, >}∨=and CSP(PA) is probably the most well-known example of a polynomial-time solvable temporal constraint language.We continue by introducing Allen’s algebra [1]. It was introduced to reason about intervals and the qualitative relation-ships between intervals. The variable domain isI = {{x ∈ Q | a ≤ x ≤ b} | a, b ∈ Q and a < b},−+that is, it consists of all closed intervals [a, b] of rational numbers. If I = [a, b] ∈ I, then we write Ifor b. The basic relations are the 13 relations defined in Fig. 1. We let A denote the set of Allen basic relations. Clearly, A is a partition scheme and the 8192 relations of Allen’s algebra are the contents of the set A∨=is known to be ω-categorical [32]. Observe that A∨=is not a temporal constraint language since the domain is not Q.. The structure A∨=for a and IFor every subset (cid:2) ⊆ A∨=later on. A relation R ∈ A∨=+, J, the complexity of CSP((cid:2)) is known [45]. Unlike temporal constraint languages, the complexity for all finite first-order definable constraint languages are not known. We will encounter the ORD-Horn subclass [55] H ⊆A∨=+]) ∈ R if and only if is a member of H if and only if the following hold: ([I+) over (Q; ≤, =, (cid:6)=) such that each φ(Iclause contains at most one relation of the form x = y or x ≤ y. The constraint language H is very well-studied within the literature on temporal constraints. We merely note that CSP(H) is polynomial-time solvable, CSP(H ∪ {R}) is NP-hard whenever R ∈ A∨= \ H, and that A ⊆ H.+) evaluates to true, where φ is a positive CNF formula φ(x+], [ J+, y−, y−, J−, J−, x−, I−, IWe finally turn our attention to RCC-5. The RCC formalisms [58] are designed for reasoning about spatial regions and they are the basis for a large part of the work in qualitative spatial reasoning (QSR). There are several variants such as RCC-23, RCC-8, and RCC-5. We will henceforth concentrate on the simplest formalism RCC-5. RCC-5 is based on five basic relations PP, PP(cid:2)(which is the inverse of PP), PO, DR, and EQ, which together form a partition scheme. Here, PP stands for proper part, PO stands for partial overlap, DR stands for disconnected regions, and EQ stands for equality. We will consider several different variants of RCC-5 based on different choices of variable domains.P. Jonsson / Artificial Intelligence 257 (2018) 1–239PP(x, y)PP(cid:2)(x, y)DR(x, y)PO(x, y)EQ(x, y)iffiffiffiffiffx ⊂ int( y)int(x) ⊃ yint(x) ∩ int( y) = ∅int(x) ∩ int( y) (cid:6)= ∅, x (cid:3) y, y (cid:3) xx = yFig. 2. Basic relations of RCC-5reg where int(·) denotes the interior operator.PP(x, y)PP(cid:2)(x, y)DR(x, y)PO(x, y)EQ(x, y)iffiffiffiffiffx ⊂ yx ⊃ yx ∩ y = ∅∃a, b, c : a ∈ x, a /∈ y, b ∈ x, b ∈ y, c /∈ x, c ∈ yx = yFig. 3. Basic relations of RCC-5set.The first variant is based on the standard representation of the spatial calculus RCC-8 (the reader is referred to Renz and Nebel [60, Sec. 3.1] for details concerning RCC-8) but where one is not able to distinguish regions from their topological closure: the disconnectedness relations DC and EC are replaced by DR and the tangential and non-tangential proper part relations TPP and NTPP are replaced by PP (and the relation PP(cid:2)is introduced analogously). Here, the domain consists of the nonempty regular closed subsets of some regular and connected topological space. A subset of a topological space is called regular closed if it is equal to the closure of its interior. Note that the sets are not required to be connected. The basic relations of RCC-5 under this choice of variable domain is given in Fig. 2. We henceforth call this algebra RCC-5reg.We continue by providing another variant of RCC-5. Here, we consider arbitrary non-empty subsets of an infinite set such as N. We define the relations PP, PP(cid:2), DR, PO, EQ as in Fig. 3 and denote the resulting structure by RCC-5set. RCC-5setis not ω-categorical while it is unknown whether there is a topological space (with the properties described above) where one can define RCC-5reg such that the resulting structure is ω-categorical. However, there are ways of defining RCC-5 such that the resulting structure is ω-categorical described in the literature. For instance, Bodirsky and Chen [7] presents such a structure based on Fraïssé amalgamation. We let RCC-5ω−cat denote this constructions.The following result is a consequence of Proposition 15 in Bodirsky and Jonsson [11] combined with Section 6 in Bodirsky and Chen [7].Proposition 13. Let (V , C) be an instance of RCC-5. The following three statements are equivalent.1. (V , C) is satisfiable if the relations are interpreted over RCC-5reg.2. (V , C) is satisfiable if the relations are interpreted over RCC-5set.3. (V , C) is satisfiable if the relations are interpreted over RCC-5ω−cat.In other words, the RCC-5 representations RCC-5reg, RCC-5set, and RCC-5ω−cat are indistinguishable from a computational perspective. The RCC-5 representation used by Li et al. [48] is restricted to regions in the plane. The exact computational properties of this representation are not known, but it is worth noting that Proposition 13 cannot be extended to RCC-5 based on non-empty open disks in the plane [11, Sec. 2.5.2]. Further discussions concerning different interpretations of RCC-5 and other spatial formalisms can be found in [7,27,49].4. Method I: ω-categoricity and model-complete coresOur first method is based on analysing a given constraint language (cid:2) with respect to its automorphisms and the central notions here are ω-categoricity and model-complete cores. We present the method in Section 4.1 and, as an example, apply it to an extended version of Allen’s algebra in Section 4.2.4.1. Constants and model-complete cores(cid:3); R(cid:3)1, R(cid:3)2, . . . ). Given an instance (V , C) of CSP((cid:2)), let (V , CWe first introduce the concept of homomorphically equivalent CSPs. Let (cid:2) and (cid:5) denote two relational τ -structures. If (cid:2)and (cid:5) are isomorphic, then it is clear that CSP((cid:2)) and CSP((cid:5)) correspond to the same computational problem. However, (cid:2)and (cid:5) may be non-isomorphic and still correspond to the same computational problem. Assume that (cid:2) = (D; R 1, R2, . . . )(cid:3)) denote the instance of CSP((cid:5)) where each relation and (cid:5) = (D(cid:3)i . We say that (cid:2) and (cid:5) have the same CSP if the following holds for all instances R i appearing in C has been replaced by R(cid:3)) is satisfiable. This is, for example, the case when there simulta-(V , C) of CSP((cid:2)): (V , C) is satisfiable if and only if (V , Cneously exists a homomorphism from (cid:2) to (cid:5) and a homomorphism from (cid:5) to (cid:2). In this case, we say that (cid:2) and (cid:5) are homomorphically equivalent and this defines an equivalence relation on structures. We note that there are structures that have the same CSP even when they are not homomorphically equivalent. Consider for example the structures (Z; <) and (Q; <). They have the same CSP and there is a homomorphism from (Z; <) to (Q; <) but there is no homomorphism from (Q; <) to (Z; <).10P. Jonsson / Artificial Intelligence 257 (2018) 1–23For ω-categorical structures (cid:2), the equivalence classes have interesting properties: the homomorphic equivalence class of (cid:2) contains a distinguished member (cid:5) which is up to isomorphism uniquely given by two properties: (cid:5) is a core and (cid:5)is model-complete. A relational structure (cid:2) is a core if all endomorphisms of (cid:2) are embeddings. Cores are important when studying the complexity of finite-domain CSPs: we refer to the textbook by Hell and Nešetˇril [31] that extensively covers cores in the context of graph homomorphisms and to Bulatov et al. [20] that covers cores in general finite-domain CSPs. It is known that when the domain of a relational structure is infinite, then there are several reasonable ways of defining cores; see, for instance, Bauslaugh [4] or Bodirsky [6, Sec. 3.6.3]. The reason for choosing the definition above is simple: it is the definition used by Bodirsky [5] in his proof of the forthcoming Theorem 14.Model completeness is a central concept in model theory. Let T be a first-order theory. We say that the formulas φ and ψ are equivalent modulo T if T |= (φ ⇔ ψ). A structure (cid:2) is model-complete if every formula in Th((cid:2)) is equivalent to an existential formula modulo T . This may be viewed as a limited notion of quantifier elimination.Consider the relation < over the rationals Q. The structure (Q; <) admits quantifier elimination [46] so every formula in Th((Q; <)) is equivalent to a quantifier-free formula (and, naturally, an existential formula). It follows that (Q; <) is model-complete, and that every (cid:2) that is first-order definable in (Q; <) is model-complete, too. The structure (Q; <) is also a core. Let e : Q → Q be an endomorphism of (Q; <), i.e., if a < b, then e(a) < e(b). Clearly, e is injective and it preserves the relation ≥ (that is, the negation of <) since if a > b, then e(a) > e(b) and if a = b, then e(a) = e(b). However, there are relations R that are first-order definable in (Q; <) and (Q; R) is not a core. One trivial example is the equality relation =. The function x (cid:18)→ 1 is obviously an endomorphism of = but it is not injective and thus not an embedding. We have the following important result.Theorem 14 (Theorem 16 in Bodirsky [5]). Every ω-categorical structure (cid:5) is homomorphically equivalent to a model-complete core structure (cid:2) which is unique up to isomorphism. Moreover, (cid:2) is ω-categorical and the orbits of n-tuples over D(cid:2) are pp-definable in (cid:2)for all n ≥ 1.Since homomorphically equivalent structures have the same CSP, one can focus on ω-categorical structures that have these properties. The fact that we can pp-define the orbits of n-tuples will now become highly important.Theorem 15. Let (cid:2) be a constraint language over the domain D. Assume the following:1. (cid:2) is a model-complete ω-categorical core and2. the domain elements are represented in a way such that given a vector ¯d = (d1, . . . , dn) ∈ Dn, a pp-definition in (cid:2) of the orbit of ¯d can be generated in polynomial time (in the size of the representation of d1, . . . , dn).Then, CSP((cid:2)) and CSP((cid:2) ∪ Dc) are polynomial-time equivalent.(cid:3)(cid:3), C(cid:3)) be an instance of CSP((cid:2)(cid:3)). Assume without loss of generality that if {di}(x) is in CProof. Let (cid:2)(cid:3) = (cid:2) ∪ Dc . The reduction from CSP((cid:2)) to CSP((cid:2)(cid:3)) is trivial so we concentrate on the other direction. Let (cid:3) = (V, then there is no variable I; if so, the constraint {di}( y) can be removed and the variable y be replaced by x. Normalising an y (cid:6)= x such that {di}( y) ∈ Cinstance in this way can easily be done in polynomial-time. We assume (without loss of generality) that the only constraints in C(cid:3)with relations from Dc are {d1}(x1), . . . , {dm}(xm). This can be achieved in polynomial time by renaming of variables.Compute (in polynomial time) the formula F (x1, . . . , xm) for the orbit of (d1, . . . , dm). Define I = (V , C) such that the constraint set C equals Cexpanded with the existentially quantified variables in F (x1, . . . , xm). Note that I can be constructed in polynomial time and it is an instance of CSP((cid:2)).extended with F (x1, . . . , xm) and with the constant relations removed. Let V denote VIf the instance I has no solution, then it follows immediately that I(cid:3)does not have a solution—one can view I as being a since the formula F (x1, . . . , xm) is, in particular, satisfiable when x1 = d1, . . . , xm = dm. If the instance I has a (cid:3) → D to I, too. Since F describes the orbit of (d1, . . . , dm), (cid:3)(x)) restricted to the set V is a (cid:3)(xi)) = di , 1 ≤ i ≤ m. This implies that α(srelaxation of Isolution s : V → D, then we claim that there is a solution sthere is an automorphism α of (cid:2) such that α(ssolution to I . (cid:2)(cid:3) : V(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)For those that are familiar with the algebraic approach to finite-domain CSPs, it may be illuminating to compare the proof of Theorem 15 with the proof of Theorem 4.7 in Bulatov et al. [20].We concretise the method by presenting an example based on temporal constraint languages, i.e. constraint languages that are first-order definable in the structure (Q; <). We have already observed (in Section 3) that temporal constraint languages are ω-categorical. It is additionally known (by Junker and Ziegler [41], also see Cameron [21]) that there are five possible choices of Aut((cid:2)). We concentrate on the (for our purposes) most interesting case when < ∈ (cid:12)(cid:2)(cid:13) and Aut((cid:2)) =Aut(Q; <). Arbitrarily choose such a language (cid:2) and assume (without loss of generality due to Theorem 4) that < ∈ (cid:2). We know that (cid:2) is model-complete (by the discussion preceding Theorem 14) so we assume that (cid:2) is a core. For instance, (cid:2) may be the point algebra {<, >, =}∨=. We represent all members of Q in the natural way, i.e., as (a/b) where a, b are integers written in binary and b (cid:6)= 0.P. Jonsson / Artificial Intelligence 257 (2018) 1–2311The automorphisms of (Q; <) are the bijective functions f : Q → Q that are monotonically increasing. The orbit of 1-tuples equals Q while the orbit of a 2-tuple (a, b) with a < b equals {(x, y) ∈ Q2 | x < y}. More generally, the orbit of a k-tuple (a1, . . . , ak) with a1 < a2 < · · · < ak equals{(x1, . . . , xk) ∈ Qk | x1 < x2 < · · · < xk}so the orbit-defining formulas can be generated in polynomial time. Theorem 15 is thus applicable and CSP((cid:2) ∪ Qc) is polynomial-time equivalent to CSP((cid:2)). In particular, CSP((cid:2) ∪ Qc) is in P if CSP((cid:2)) is in P, and CSP((cid:2) ∪ Qc) is in NP if CSP((cid:2))is in NP.This example shows that ω-categoricity is indispensable. Theorem 15 combined with the tractability of CSP((Q; <, (cid:6)=))implies that CSP((cid:2)Q) is in P when (cid:2)Q denotes (Q; <, (cid:6)=) extended with the constant relations in Qc . Recall that (Z; <) and (Z; <, (cid:6)=) are not ω-categorical and define (cid:2)Z by expanding (Z; <, (cid:6)=) with Zc . The problem CSP((cid:2)Z) is NP-hard since the relation {0, 1, 2} can be pp-defined via{0, 1, 2}(x) ⇔ ∃ y, z.{−1}( y) ∧ {3}(z) ∧ y < x ∧ x < z,and the problem CSP((Z; {0, 1, 2}, (cid:6)=)) is NP-hard since there is an obvious polynomial-time reduction from 3-Colourability. A similar example of this phenomenon (but based on RCC-5 instead of (Q; <)) will be presented in Section 6.2.By Theorem 14, we know that orbit-defining formulas always can be pp-defined in (cid:2) under the given assumptions. Whether these can be generated or not in polynomial time is a completely different question, though. Bodirsky [5, Sec. 7]notes that if the set of possible constants is finite, then an orbit-defining formula for these constants can be computed off-line and subsequently be used without additional cost. This gives us the following result.Corollary 16. Let (cid:2) be a constraint language over the domain D and let Dω-categorical core, then CSP((cid:2)) and CSP((cid:2) ∪ D(cid:3)c) are polynomial-time equivalent problems.(cid:3)c be a finite subset of Dc. If (cid:2) is a model-complete Assuming that the set of constant relations is finite is sensible in applications such as geographical information systems: geographical maps contain a comparatively small number of features and they tend to evolve quite slowly.4.2. An example based on Allen’s algebraWe will now illustrate the results presented in Section 4.1 with the aid of a slightly more involved example. There are several reasons for doing this. First of all, we want to show how the results can be used for studying non-binary constraint languages. One may argue that most constraint formalisms studied in AI are binary and studying higher-arity formalisms is of minor importance. However, there are many interesting formalisms based on relations with higher arity. We refer the reader to the survey by Dylla et al. [28] that contains both examples of higher-arity formalisms and a thorough discussion concerning their properties. Another reason is to give the reader some familiarity with the use of results such as Theorem 15. Even though it may seem quite abstract at first sight, it is both powerful and fairly easy to use in concrete applications.Our departure is the following dichotomy result.Theorem 17 (Theorem 5.5.23 in Bodirsky [6]). Let (cid:2) be a finite set of relations that are first-order definable in A and m ∈ (cid:2) (where mis the Allen relation satisfying (I, J ) ∈ m if and only if I). Then, CSP((cid:2)) is either polynomial-time solvable or NP-complete.+ = J−The reader may be puzzled about the restriction to constraint languages containing the relation m. Intuitively, m allows us to define certain relations that make endpoints identical and such relations are the very basis of the dichotomy result (see the construction in the beginning of Lemma 22).Before continuing, we want to point out that switching from A∨=to relations that are first-order definable in A gives new possibilities but also poses new problems. Consider, for example, the following ternary Allen relation:(cid:9)∗ =R(I, J , K ) ∈ I3(cid:10)(cid:10)(cid:10)(cid:10)(s, s(s, s(cid:2), ≡)(I, J ) ∧ (s, s(cid:2), ≡)( J , K ) ∧ (s(K , I) ∨ s(K , J ))(cid:2), ≡)(I, K )∧(cid:11).This relation expresses that I , J , and K have the same starting point and the ending point of K is before at least one of the ending points of I and J . Note that the disjunction s(K , I) ∨ s(K , J ) is not expressible with relations in A∨=. Relations that are first-order definable in A are inherently different from the relations in A∨=. We exemplify by the ORD-Horn class H that was described in Section 3. Nebel and Bürckert [55] have proved that the ORD-Horn class H has the following uniqueness property: if A ⊆ X ⊆ A∨=and CSP( X) in P, then X ⊆ H. Such a unique class of relations does not exist if we consider relations that are first-order definable in A: there exist two incomparable classes of relations X1, X2 that are first-order definable in A, the ORD-Horn class is a strict subset of both, and CSP( Xi), 1 ≤ i ≤ 2, is in P. This is a straightfor-ward consequence of results proved by Bodirsky and Kára [14]; more details can be found in Bodirsky [6, Chapter 10]. One 12P. Jonsson / Artificial Intelligence 257 (2018) 1–23∗extension of H can be used for studying the relation Rbe rewritten as a relation that is definable in (Q; <) by splitting the intervals into variables that range over Q:∗}) is indeed polynomial-time solvable. First, R: CSP(H ∪ {R∗can ⎧⎪⎪⎨⎪⎪⎩∗∗ =R−+, I(I, J−, J+, K−, K+) ∈ Q6−∧+ < JEvery relation in H can be rewritten in a similar way; we let H(cid:3)+)− < J+∧(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)(cid:10)− < II− < KK− = JI+ < I(K+ ∧ J+∧− = K+ ∨ K⎫⎪⎪⎬⎪⎪⎭.denote the resulting constraint language. Now, the constraint language H(cid:3) ∪ {R∗}) is tractable, too. This kind of transformations of constraint languages will be an important ingredient in the proofs of the forthcoming results.∗∗} is a subset of the tractable dual-ll class [14], and we conclude that CSP(H ∪ {RBodirsky’s proof of Theorem 17 is based on the following fundamental result.Theorem 18 (Bodirsky and Kára [13]). Let (cid:2) be a finite set of relations that are first-order definable in (Q; <). Then, CSP((cid:2)) is either polynomial-time solvable or NP-complete.The problem of applying Theorem 18 directly to Allen relations stems from the different domains: the theorem is concerned with the domain Q while Allen relations are defined over the interval domain I. We will now generalise the dichotomy result for the first-order extension of Allen’s algebra (Theorem 17) as follows: we show that adding constants to the constraint language do not change the complexity of the corresponding constraint satisfaction problem.Theorem 19. Let (cid:2) be a finite set of relations that are first-order definable in A and m ∈ (cid:2). Then, the problems CSP((cid:2)) and CSP((cid:2) ∪ Ic)are polynomial-time equivalent. Additionally, these problems exhibit a dichotomy: they are either polynomial-time solvable or NP-complete depending on the choice of (cid:2).Theorem 19 can be proved in several different ways. Our proof does not use any complex formal machinery and it emphasises the connections with the results in Section 4.1. The proof can be found in Section 4.2.1 and we discuss some aspects of this result in Section 4.2.2. Special cases of Theorem 19 and related results have been studied in the literature. We have already mentioned that Li et al. [48] have showed that CSP(A∨= ∪ Ic) is in NP. Their approach seems difficult to generalise for handling relations with arbitrarily high arity. Another example is Jonsson and Bäckström [38] who have proved that CSP(H ∪ Ic) is in P. Their approach does not easily generalise to larger classes of relations, either. In fact, it cannot be used for proving that CSP(H ∪ {R∗} ∪ Ic) is in P—a result that can easily be inferred from Theorem 19.4.2.1. Dichotomy resultWe begin by proving that Allen relations admit quantifier elimination. The exact definition of homogeneity (which is used in the proof below) is not important at this point but we will come back to it in Section 5.Lemma 20. Structure A admits quantifier elimination.Proof. By Statement 2.22 in Cameron [21], we know that an ω-categorical structure admits quantifier elimination if and only if it is homogeneous. Corollary 5.9 in Hirsch [33] shows that A∨=is homogeneous. Every homogeneous structure that contains a finite number of relations and has an infinite countable domain is ω-categorical, cf. Lemma 3.2.10 in Bodirsky [6]. We conclude that A∨=admits quantifier elimination. This immediately implies that A admits quantifier elimination, too, since every relation in A∨=can be rewritten as a disjunction of relations in A without introducing any quantifiers. (cid:2)Let R ⊆ Ik denote a k-ary relation that is first-order definable in A. Assume without loss of generality (due to Lemma 20) that (I1, . . . , Ik) ∈ R if and only if φR (I1, . . . , Ik) holds where φR is a quantifier-free formula. Define the formula X(φR ) to +−+−be a formula φ(cid:3) ∧ φ(cid:3)(cid:3)k , x1 , . . . , x1 , xk wherewith 2k free variables x+−1. φ(cid:3) = x1 < x12. φ(cid:3)(cid:3)+−∧ · · · ∧ xk < xk andvariables x+−+−n , xm, xm, xn .is φ where each atomic formula a(Im, In) with a ∈ A is replaced by the corresponding definition in Fig. 1 over Note that the formula X(φ) is always quantifier-free first-order definable in (Q; <). We adapt X(·) for handling relations in the natural way: for a relation R with arity a, letˆX(R) = {(x+−+−+−+−a )}.a ) ∈ Qa | X(φR )(xa , x1 , . . . , x1 , xa , x1 , . . . , x1 , x∗and R∗). Finally, we extend ˆXIf we go back to the relations Rto constraint languages: ˆX((cid:2)) = { ˆX(R) | R ∈ (cid:2)}. By the very definition of ˆX(·), it is straightforward to verify that CSP((cid:2)) is that were introduced earlier, then we see that R∗∗ = ˆX(R∗∗13+−, xP. Jonsson / Artificial Intelligence 257 (2018) 1–23polynomial-time reducible to CSP( ˆX((cid:2))). The basic step is to replace each interval variable I with two point variables xwhere xis interpreted as the starting point of I and xreduction in the other direction needs some more work.. Showing that there is a polynomial-time the ending point of x+−+Lemma 21. The relations (s, s(cid:2), ≡) and (f, f(cid:2), ≡) are pp-definable in {m}.Proof. Note that(cid:2)(s, s, ≡)(I, J ) ⇔ ∃K .m(K , I) ∧ m(K , J )(cid:2), ≡) can be pp-defined analogously. (cid:2)and that (f, fLemma 22. Let (cid:2) be a finite set of relations that are first-order definable in A and m ∈ (cid:2). Then, CSP( ˆX((cid:2))) is polynomial-time reducible to CSP((cid:2)).Proof. Assume without loss of generality (due to Lemma 21 and Theorem 4) that {(s, s(cid:2), ≡), (f, f(cid:2), ≡)} ⊆ (cid:2).Arbitrarily choose an instance (V , C) of CSP( ˆX((cid:2))). We say that variables x, y ∈ V are a pair if x appears at position k(where k is odd) in some constraint in C and y appears in the same constraint at position k + 1. Note that if x, y are a pair, then every solution must assign a strictly higher value to y than to x.Based on (V , C), we define an instance (V(cid:3), C(cid:3)) of CSP((cid:2)) as follows.1. For each pair of variables x, y ∈ V , introduce an interval variable I x, y and put it into V2. For variables I x, y and I x,z in V3. For variables I y,x and I z,x in V4. For variables I y,x and I x,z in V5. For variables I x, y and I z,x in V6. For each constraint S(x1, x2, . . . , x2m−1, x2m) ∈ C , add the constraint R(I x1,x2 , . . . , I x2m−1,x2m ) to C, add the constraint (s, s, add the constraint (f, f, add the constraint m(I y,x, I x,z) to C, add the constraint m(I z,x, I x, y) to C(cid:2), ≡)(I x, y, I x,z) to C(cid:3)(cid:2), ≡)(I x, y, I x,z) to C.....(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)S = ˆX(R).(cid:3)where R ∈ (cid:2) satisfies (cid:3)(cid:3), C(cid:3)) is satisfiable if and only if (V , C) is satisfiable.We claim that (VAssume (V , C) is satisfiable and that it has the solution f : V → Q. Define the function f[ f (x), f ( y)]. The variables x, y are a pair so they appear in some constraint that requires f (x) < f ( y). Thus, fto I. If there are interval variables I x, y and I x,z in Vfrom Vsatisfies this constraint since fCverified that the constraints introduced in steps 3–5 are satisfied by fsatisfied by fAssume (Vdue to the definition of ˆX(·).(cid:3), C(cid:3)) is satisfiable and that it has the solution f, then we know that the constraint (s, s(cid:3)(I x, y) =is a function (cid:2), ≡)(I x, y, I x,z) is in (cid:3)(I x,z) = [ f (x), f (z)]. It can analogously be . Finally, the constraints introduced in steps 6 are (cid:3)(I x, y) = [ f (x), f ( y)] and f. The function fsuch that f(cid:3) : V(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3) → I. For each variable x ∈ V , there is at least one such that for every x ∈ V , g(x) = I x, y or variable I x, y or I y,x in Vg(x) = I y,x (for some y ∈ V ) and g(x) ∈ Vfor some y ∈ V . Arbitrarily choose a function g : V → V(cid:3). Define a function f : V → Q as follows:(cid:3)(cid:3)1.2.f (x) = a if g(x) = I x, y and ff (x) = b if g(x) = I y,x and f(cid:3)(I x, y) = [a, b] or(cid:3)(I y,x) = [a, b].Note that the exact choice of function g for defining f (x) is irrelevant: whenever we have interval variables, say, I x, y(cid:3)(I x,z) = [a, c], due to the constraints introduced in steps 2–5 in the reduction. Thus, (cid:3)(I x, y) = [a, b] and fand I x,z, then fthere exists exactly one function f corresponding to a given solution f.(cid:3)(cid:3)(I x1,x2 ), . . . , fWe conclude the proof by proving that fis a solution to (V , C). Arbitrarily choose a constraint S(x1, x2, . . . , x2m−1, x2m)in C . Assume first that all variables are distinct. We need to verify that ( f (x1), f (x2), . . . , f (x2m−1), f (x2m)) ∈ S. We know (cid:3)(I x2m−1,x2m )) ∈ R so the very construction of f combined with the definition of ˆX(·) implies that that ( fthis holds. Assume now instead that the variables are not distinct. We exemplify with a 4-ary constraint S(x, y, x, z). This due to corresponds to a constraint R(I x, y, I x,z) in C(cid:3))(cid:3), Cstep 2 in the reduction. It is thus guaranteed that the intervals f(cid:3)(I x,z)) ∈ R. This implies that ( f (x), f ( y), f (x), f (z)) ∈ S due to the definition of has a solution, we know that ( fˆX(·). It is not hard to generalise this reasoning to constraints of higher arity. (cid:2)where we additionally have the constraint (s, s(cid:3)(I x, y) and f(cid:3)(I x,z) start at the same point. Since (V(cid:2), ≡)(I x, y, I x,z) ∈ C(cid:3)(I x, y), f(cid:3)(cid:3)We are now ready to prove Theorem 19.Proof. We prove the result by giving four polynomial-time reductions.1. CSP((cid:2) ∪ Ic) to CSP( ˆX((cid:2)) ∪ Qc). We have earlier discussed the fact that there is a straightforward reduction from CSP((cid:2))to CSP( ˆX((cid:2))). Assume that we have a unary relation that constrains the interval variable I to have the value [a, b]. In +ranging over Q. It is easy to see that we can replace a the reduction, I is associated with two variables xand x−) and {b}(xconstraint [a, b](I) with [a, b] ∈ Ic with the constraints {a}(x+) where {a}, {b} ∈ Qc .−14P. Jonsson / Artificial Intelligence 257 (2018) 1–232. CSP( ˆX((cid:2)) ∪ Qc) to CSP( ˆX((cid:2))). We merely note that the relation < is pp-definable in ˆX((cid:2)) since x < y ⇔∃z, w. ˆX(m)(x, z, w, y) so the reduction exists due to the discussion after Theorem 15.3. CSP( ˆX((cid:2))) to CSP((cid:2)). This reduction exists due to Lemma 22.4. CSP((cid:2)) to CSP((cid:2) ∪ Ic). Trivial.For an arbitrary constraint language (cid:7) that is first-order definable in (Q; <), we know that CSP((cid:7)) is either in P or is an NP-complete problem by Theorem 18. Since ˆX((cid:2)) is first-order definable in (Q; <), the reduction above shows that CSP((cid:2)), CSP((cid:2) ∪ Ic), CSP( ˆX((cid:2))), and CSP( ˆX((cid:2)) ∪ Qc) are either in P or they are NP-complete problems. (cid:2)Theorem 19 only gives the complexity for CSP((cid:2) ∪ Ic) and not for CSP((cid:2) ∪ I f ). However, we can conclude (by Lemma 3) that CSP((cid:2) ∪ I f ) is in NP. Recall that the complexity of CSP((cid:2)) and CSP((cid:2) ∪ Ic) is always the same (up to polynomial-time reductions) when m ∈ (cid:2). This does not hold for CSP((cid:2) ∪ I f ). Let (cid:7) = {m, (cid:6)≡} where (cid:6)≡ =B∈A\{≡} B. CSP((cid:7)) is in P since (cid:7)is a subset of the ORD-Horn class H. The problem CSP((cid:7) ∪ I f ) is NP-complete, though. This can be proved by a reduction (cid:3)from 3-Colourability. Let G = (V , E) be an undirected graph. For each v ∈ V , introduce a variable vand the constraint (cid:3)). It is easy to see that the resulting (cid:3)). For each edge (v, w) ∈ E, introduce the constraint (cid:6)≡ (v{[0, 1], [1, 2], [2, 3]}(vinstance is satisfiable if and only if G is 3-colourable, and this implies that CSP((cid:2) ∪ I f ) is NP-complete.(cid:3), w(cid:2)4.2.2. DiscussionIt is now suitable to discuss some aspects of the dichotomy result presented in the previous section. One obvious question is what happens if we consider languages that do not contain the relation m. Unfortunately, the proof breaks down. Let (cid:2) = {R1, . . . , Rn} be first-order definable in A such that m ∈ (cid:2) and R i , 1 ≤ i ≤ n, is defined by the quantifier-free formula φi . The reductions in the proof of Theorem 19 shows that the problems CSP((cid:2)) and CSP((cid:7)) have the same complexity up to polynomial-time reductions where the relations in (cid:7) are defined via X(φ1), . . . , X(φn). We demonstrate that this is not true in the general case where we do not have access to the relation m.(cid:2)B∈A\{≡} B. Let Just as in the previous section, we let (cid:6)≡ denote the ‘not equal’ relation, i.e., the relation (cid:6)≡ =φR (I, J , X, Y ) denote the formulam(I, J ) → (cid:6)≡(X, Y )and φS ( X, A, B, C) the formula≡(X, A) ∨ ≡(X, B) ∨ ≡(X, C).Define the relations R, S ⊆ I4 as follows:R = {(I, J , X, Y ) ∈ I4 | φR (I, J , X, Y )} andS = {(X, A, B, C) ∈ I4 | φS (X, A, B, C)}.Let (cid:2)(cid:3) = {R, S}. Clearly, m /∈ (cid:2)(cid:3)are first-order definable in A by definition. Observe that the problem CSP((cid:2)(cid:3)) is in P: if (V , C) is an instance of CSP((cid:2)(cid:3)), then the constant function f (v) = [0, 1] is a solution to (V , C). Now take (cid:7)(cid:3) = {Rand the relations in (cid:2)(cid:3)(cid:3)} where(cid:3), S(cid:3) = {(x1, . . . , x8) ∈ Q8 | X(φR )(x1, . . . , x8)} andR(cid:3) = {(x1, . . . , x8) ∈ Q8 | X(φS )(x1, . . . , x8)}.SWe show that the problem CSP({Rundirected graph. Introduce “colour variables” c(cid:3)}) is NP-hard by a reduction from 3-Colourability. Let (V , E) denote an arbitrary +3 , auxiliary variables a1, a2, a3, and impose the constraints+2 , c−3 , c−2 , c−1 , c+1 , c(cid:3), S(1) R(2) R(3) R(cid:3)(a1, a2, a2, a3, c(cid:3)(a1, a2, a2, a3, c(cid:3)(a1, a2, a2, a3, c−1 , c−1 , c−2 , c+1 , c+1 , c+2 , c−2 , c−3 , c−3 , c+2 ),+3 ), and+3 ).We first note that these three constraints are simultaneously satisfiable: for instance, every function f : {a1, a2, a3} ∪−i , c| 1 ≤ i ≤ 3} → Q such that+i{cf (c−1 ) < f (cf (a1) < f (a2) < f (a3) <+1 ) < f (cis a solution. By inspecting the definition of RGiven this, it follows that for arbitrary 1 ≤ i (cid:6)= j ≤ 3, either f (c+2 )], and [ f (c[ f (c−i ) (cid:6)= f (c+3 )] are distinct intervals.−2 ) < f (c−3 ) < f (c+2 ) < f (c+1 )], [ f (c−2 ), f (c−3 ), f (c−1 ), f (c+3 )(cid:3), it is evident that every solution f must satisfy f (a1) < f (a2) < f (a3). ++i ) (cid:6)= f (cj ) (or both). We conclude that −j ) or f (cFor each vertex v ∈ V , introduce variables v+−, vand the constraintP. Jonsson / Artificial Intelligence 257 (2018) 1–2315(cid:3)S−+, c(v, v−1 , c+2 , c−), f (v+)] ∈ {[ f (cThis constraint implies that [ f (vsible values due to constraints (1)–(3). This value correspond to the colour given to vertex v.+i )] | 1 ≤ i ≤ 3}. Thus, [ f (v+−3 ).3 , c−), f (v−i ), f (c−2 , c+1 , c+)] may have one of three pos-Finally, for each edge (v, w) ∈ E, introduce the constraint(cid:3)−+−+R, v(a1, a2, a2, a3, v, w+)], i.e., adjacent vertices are assigned different colours. It is not This constraint ensures that [ f (vhard to verify that the resulting instance is satisfiable if and only if (V , E) is 3-colourable. This shows that the complexities for CSP((cid:2)) and CSP((cid:7)) do not always match when m /∈ (cid:2).).+)] (cid:6)= [ f (w, w−), f (v−), f (wAnother interesting question concerns the complexity of the metaproblem: given a constraint language (cid:2) such that m ∈ (cid:2)and (cid:2) is first-order definable in A, what is the complexity of CSP((cid:2))? Preferably, we want problems of this kind to be decidable. Let us first consider the structure (Q; <). Let (cid:7) be a finite set of relations that are first-order definable in (Q; <). Bodirsky and Kára [13] have showed that there are nine different cases where CSP((cid:7)) is polynomial-time solvable, and they have algebraically characterised these classes. A similar algebraic classification is possible for CSP((cid:2)) and, consequently, CSP((cid:2) ∪ Ic) by Theorem 19—the complexity of such a CSP is determined by a corresponding set of relations that are first-order definable in (Q; <). In practice, the following result may be more useful.Theorem 23 (Bodirsky and Kára [13], see also Bodirsky et al. [15]). Let (cid:2) = {R1, . . . , Rn} be a finite set of relations that are first-order definable in (Q; <), and let φ1, . . . , φn denote their quantifier-free first-order definitions. There is an algorithm that given φ1, . . . , φndecides whether CSP((cid:2)) is polynomial-time solvable or NP-complete.As far as we know, there are no specialised algorithms for performing quantifier elimination in Allen’s algebra described in the literature. There are, however, general algorithms that can be used for this purpose.Proposition 24 (Proposition 3.1.22 in Marker [54]). Suppose that T is a decidable theory with quantifier elimination. Then, there is an algorithm which when given a formula φ as input will output a quantifier-free formula ψ such that T |= ∀x1, . . . , xn.φ(¯x) ↔ ψ(¯x).The theory of Allen relations is first-order axiomatisable: this follows from the fact that the theory of dense linear order has this property, (cf. Section 1.2 in Marker [54]) combined with the definitions of the basic relations in A. By choosing T to be the theory of Allen relations, it follows from Proposition 24 that there exists a suitable quantifier elimination algorithm.Theorem 25. Let (cid:2) = {R1, . . . , Rn} be a finite set of relations that are first-order definable in A and contains the relation m, and let φ1, . . . , φn denote their first-order definitions. There is an algorithm that given φ1, . . . , φn decides whether CSP((cid:2)) is polynomial-time solvable or NP-complete.Proof. The first-order formulas φ1, . . . , φn can be algorithmically converted into logically equivalent quantifier-free formulas φ(cid:3)1, . . . , φ(cid:3)n) by exploiting the definitions in Fig. 1. We note the following.n, we can easily compute the quantifier-free formulas X(φ(cid:3)n, as described above. Given φ(cid:3)1), . . . , X(φ(cid:3)1, . . . , φ(cid:3)• CSP((cid:2)) is polynomial-time equivalent with CSP( ˆX((cid:2))) by Lemma 22, and• the computational complexity of CSP( ˆX((cid:2))) is decidable by Theorem 23 since we have access to the formulas X(φ(cid:3)1), . . . , X(φ(cid:3)n) that define the relations in ˆX((cid:2)).Combining these two facts concludes the proof. (cid:2)The same result holds for CSP((cid:2) ∪ Ic) by Theorem 19. Even though the metaproblem is indeed decidable, it is quite evident that the method outlined above is time-consuming. We want to stress that there may exist more efficient methods: one encouraging example is conservative constraints over finite domains. They admit a polynomial-time algorithm for the meta-problem whereas the straightforward algorithm is super-exponential [23].5. Method II: homogeneous structuresOur second method is based on analysing a given constraint language (cid:2) with respect to its automorphisms, just as method I. However, the central notion in method II is homogeneity instead of ω-categoricity. In our context, homogeneous structures are typically ω-categorical so method I is, in principle, applicable. The main advantage of working with homoge-neous structures is that we do not need a method for computing orbit-defining formulas. This advantage comes at a price: the method is restricted to constraint languages based on partition schemes.16P. Jonsson / Artificial Intelligence 257 (2018) 1–23Homogeneous2 structures have been intensively studied in mathematics and logics (for instance, in connection with combinatorics, model theory, and group theory) and they are also highly relevant in the study of CSPs. Homogeneous structures have useful properties such as admitting quantifier elimination and they are ω-categorical whenever the struc-ture contains a finite number of relations and the domain is countably infinite. Theoretically interesting examples include (Q; <), (N; =), and the random (or Rado) graph. There are also many examples that are (more obviously) relevant in AI and computer science. One of the earliest studies of homogeneous structures in AI was performed by Hirsch [33]. He proved, among other things, that Allen’s algebra under the interval representation is homogeneous. Another early example is the homogeneous representation of RCC-5 proposed by Bodirsky and Chen [7]; this is the ω-categorical representation that was briefly discussed in Section 3. Other examples include RCC-8 [16], phylogeny constraints [12], and temporal constraints for partially-ordered time [42].We need some machinery before providing the formal definition of homogeneity. Let D be the domain of a relational τ -structure (cid:2) and arbitrarily choose S ⊆ D. Then the substructure induced by S in (cid:2) is the τ -structure (cid:5) with domain Ssuch that R(cid:5) = R(cid:2) ∩ Sn for each n-ary R ∈ τ ; we also write (cid:2)[S] for (cid:5). The structure (cid:2) is called homogeneous if every isomorphism f : D1 → D2 between finite induced substructures of (cid:2) can be extended to an automorphism of (cid:2), that is, there exists an automorphism α such that f (x) = α(x) when x ∈ D1. The survey by Macpherson [53] is a good introduction to homogeneous structures. We give a very simple example to illustrate the idea behind homogeneity.Example 26. We revisit Example 1. Assume k ≥ 1 to be fixed, let D = {1, . . . , k}, and let Kk denote the binary relation {(x, y) ∈ D2 | x (cid:6)= y}. One may easily verify that Aut({Kk}) equals the full symmetric group on the set D, i.e., the group of all permutations of D.Arbitrarily choose D1, D2 ⊆ D and an isomorphism f : D1 → D2 between Kk[D1] and Kk[D2]. Note that |D \ D1| =|D \ D2| and let g : D \ D1 → D \ D2 be an arbitrary bijection. If we define α : D → D such that α(d) = f (d) when d ∈ D1and α(d) = g(d) otherwise, then α is an extension of f and α is a permutation on D which implies that α ∈ Aut({Kk}). Since D1, D2, and f were arbitrarily chosen, we conclude that the structure (D; Kk) is homogeneous.Many additional examples can be found in, for instance, the article by Hirsch [33]. Homogeneity is a more “fragile” concept than ω-categoricity. For instance, (cid:2) being homogeneous and (cid:5) being first-order definable in (cid:2) does not necessarily imply that (cid:5) is homogeneous.In the following, we will concentrate on partition schemes as defined in Section 2.2.Theorem 27. Let B = {B1, . . . , Bk} be a partition scheme over the domain D and let B ⊆ (cid:2) ⊆ B∨=. Assume the following:1. (cid:2) is homogeneous, and2. the domain elements are represented in a way such that given two elements a, b ∈ D, it is possible to find (by using an algorithm A) the unique B i , 1 ≤ i ≤ k, such that (a, b) ∈ B i in polynomial time (measured in the size of the representations of a and b).Then, CSP((cid:2)) and CSP((cid:2) ∪ Dc) are polynomial-time equivalent.Proof. Let (cid:2)(cid:3) = (cid:2) ∪ Dc . The reduction from CSP((cid:2)) to CSP((cid:2)(cid:3)) is trivial so we concentrate on the other direction. Let (cid:3)) be an instance of CSP((cid:2)(cid:3)). We assume without loss of generality (just as in the proof of Theorem 15) that the (cid:3) = (VIonly constraints in Cwith relations from Dc are {d1}(x1), . . . , {dm}(xm).(cid:3), C(cid:3)Construct an instance I = (V , C) of CSP((cid:2)) as follows: let(cid:3),• V = V• (cid:19)C = {B(xi, x j) | 1 ≤ i (cid:6)= j ≤ m and B = A(di, d j)}, and• C = (C(cid:3) ∪ (cid:19)C) \ {{d1}(x1), . . . , {dm}(xm)}.The instance I = (V , C) can obviously be generated in polynomial time.If the instance Ihas a solution, then it follows immediately that I has a solution—the constraints in (cid:19)C are satisfiable by (cid:3)the assignment x1 = d1, . . . , xm = dm.If the instance I has a solution s : V → D, then we claim that there is a solution s, too. Let S = {s(x1), . . . , s(xm)} and T = {d1, . . . , dm}. The set T contains m elements by our initial assumptions and the set S contains m elements due to the constraints in (cid:19)C ; all variables in {x1, . . . , xm} are assigned distinct values since none of the constraints in (cid:19)C allows equality (due to the fact that B is a partition scheme and d1, . . . , dm are distinct values). Thus, f : S → T is a well-defined bijective function if we let f (s(xi)) = di , 1 ≤ i ≤ m. We continue by proving the following claim.(cid:3) : V → D to I(cid:3)2 The term ultra-homogeneous is sometimes used in the literature.P. Jonsson / Artificial Intelligence 257 (2018) 1–2317is an homomorphism from B[S] to B[T ] when B ∈ B. Arbitrarily choose a tuple (a, b) ∈ B[S]. By the choice of S, Claim: fwe know that a = s(xi) and b = s(x j) for some distinct 1 ≤ i, j ≤ m. We see that( f (a), f (b)) = ( f (s(xi)), f (s(x j))) = (di, d j).We know that di, d j ∈ T so it remains to show that (di, d j) ∈ B. If A(di, d j) = B, then we are done. If A(di, d j) = Bthen B. This contradicts that a = s(xi), b = s(x j), and (a, b) ∈ B since B ∩ B(cid:3)(xi, x j) ∈ (cid:19)C ⊆ C so (s(xi), s(x j)) ∈ B(cid:3) = ∅.(cid:3)(cid:3) (cid:6)= B, We show that f is an isomorphism between (cid:2)[S] and (cid:2)[T ]. We have already verified that f is a bijective function. Hence, −1 is a homomorphism is a homomorphism from (cid:2)[S] to (cid:2)[T ], and that the inverse function fwe need to show that ffrom (cid:2)[T ] to (cid:2)[S].We begin by showing that fis a homomorphism from (cid:2)[S] to (cid:2)[T ]. Arbitrarily choose a relation R ∈ (cid:2) where R =B1 ∪ · · · ∪ B p and B i ∈ B, 1 ≤ i ≤ p. Arbitrarily choose (a, b) ∈ R[S]. The tuple (a, b) is a member of some relation B i in {B1, . . . , B p}. By the Claim, ( f (a), f (b)) ∈ B i[T ] so ( f (a), f (b)) ∈ R[T ] since B i ⊆ R. It follows that fis a homomorphism from R[S] to R[T ] since (a, b) was arbitrarily chosen in R[S]. This, in turn, implies that f is a homomorphism from (cid:2)[S] to (cid:2)[T ] since R was arbitrarily chosen in B∨=Next, we show that f−1 is a homomorphism from (cid:2)[T ] to (cid:2)[S]. Arbitrarily choose a relation R ∈ (cid:2) where R =B1 ∪ · · · ∪ B p and B i ∈ B, 1 ≤ i ≤ p. Arbitrarily choose (di, d j) ∈ R[T ]. The tuple (di, d j) is a member of some relation −1(d j)) =Bm in {B1, . . . , B p}. Now, consider the tuple ( f(s(xi), s(x j)). If (s(xi), s(x j)) ∈ Bm, then we are done. Assume to the contrary that (s(xi), s(x j)) ∈ Bn where n (cid:6)= m. By the Claim, ( f (s(xi)), f (s(x j))) ∈ Bn and ( f (s(xi)), f (s(x j))) = (di, d j). This leads to a contradiction since (di, d j) cannot simulta-neously be a member of Bn and Bm due to the fact that B is a partition scheme.−1(d j)). By the definition of f , we see that ( f−1(di), f−1(di), f.Since (cid:2) is a homogeneous structure, the function f can be extended to an automorphism α of (cid:2). It follows that the function s(cid:3) : V → D defined such that s(cid:3)(x) = α(s(x)) is a solution to I(cid:3); merely note that s(cid:3)(xi) = di , 1 ≤ i ≤ m. (cid:2)The major advantage of working with homogeneous structures instead of using method I is that we do not need any efficient algorithm for computing orbit formulas. Presumably, the computations required by condition (2) in Theorem 27are easier to carry out than computing orbit formulas given that domain elements are represented in some suitable way. In fact, if the constants represent objects in the real world, we may very well know their relations a priori and we do not need an algorithm for computing them.We exemplify the result by taking a look at Allen’s algebra with domain I. Hirsch [33] has shown that A∨=is a ho-mogeneous structure and the second precondition of Theorem 27 is clearly satisfied with the given representation. We conclude that CSP(A∨= ∪ Ic) is an NP-complete problem since CSP(A∨=) is NP-complete. By Lemma 3, it follows directly that CSP(A∨= ∪ I f ) is an NP-complete problem, too. One may also note that CSP(H ∪ Ic) is in P when H is the ORD-Horn subclass [55] since H contains all 13 basic relations.RCC-8 may serve as another example. We first recall the result for RCC-8 presented by Li et al. [48]. They use a repre-sentation of RCC-8 where the objects are regions in the plane, and they show that RCC-8 extended with polygonal constants give rise to an NP-complete problem. Unfortunately, their representation of RCC-8 is not known to be homogeneous so method II is not applicable in this case. There are other representations that are homogeneous, though: one example is presented by Bodirsky and Wölfl [16]. In this case, we do not have an explicit method for analysing the relationships be-tween domain elements. Thus, either one has to construct such a method or one may restrict oneself to objects with known (cid:3)relationships. In particular, one may restrict oneself to finite sets of constant relations. If Dc is a finite set of constant re-(cid:3)c is finite, lations, then the relations between the corresponding domain elements can be computed in advance. Since Dthis information can be stored in a finite table which can be efficiently accessed. This gives us a result that is analogous to Corollary 16.Corollary 28. Let B = {B1, . . . , Bk} be a partition scheme over the domain D and let B ⊆ (cid:2) ⊆ B∨=Dc . If (cid:2) is homogeneous, then CSP((cid:2)) and CSP((cid:2) ∪ D(cid:3)c) are polynomial-time equivalent.. Let D(cid:3)c denote a finite subset of One may additionally note that Corollary 28 is applicable to RCC-5ω−cat since this representation is known to be homo-geneous [7].Theorem 27 can be utilised in many other ways. One example is the following result which “lifts” Theorem 27 to first-order definable relations. Note, however, that this result is only useful for proving membership in NP.Corollary 29. Let B = {B1, . . . , Bk} be a partition scheme and let B ⊆ (cid:2) ⊆ B∨=. Assume the following:1. (cid:2) is homogeneous,2. B satisfies precondition (2) of Theorem 27, and3. CSP(B) is in NP.For every finite set (cid:7) = {R1, . . . , Rk} of relations that are first-order definable in (cid:2), CSP((cid:7) ∪ Dc) and CSP((cid:7) ∪ D f ) are in NP.18P. Jonsson / Artificial Intelligence 257 (2018) 1–23Proof. Arbitrarily choose a (cid:7) = {R1, . . . , Rk} that satisfies the preconditions. Note that CSP((cid:2)) is in NP since CSP(B) is in NP and (cid:2) ⊆ B∨=; this can easily be proved along the same lines as Lemma 6. By Theorem 27, CSP((cid:2) ∪ Dc) is in NP since CSP((cid:2)) is in NP. This implies that CSP(B ∪ Dc) is in NP since B ⊆ (cid:2). By arguing as in the proof of Lemma 20, we may assume that each R i , 1 ≤ i ≤ k, has a quantifier-free definition in B. It follows from Lemma 6 that CSP((cid:7) ∪ Dc) is in NP, too. By Lemma 3, it additionally holds that CSP((cid:7) ∪ D f ) is in NP. (cid:2)6. Method III: small solutionsThe methods in Sections 4 and 5 provide polynomial-time equivalences between CSP((cid:2)) and CSP((cid:2) ∪ Dc) under certain conditions. In this section, we will instead analyse the constraint language (cid:2) ∪ Dc directly. The main result will be weaker than in the previous two sections since we will only be able to prove membership in NP. On the other hand, the approach is applicable also without ω-categoricity.6.1. The small solution propertyLet (cid:2) be an arbitrary constraint language with domain D, and assume that the relations in (cid:2) and the elements in Dare represented is some fixed way. We say that (cid:2) has the small solution property if there exists a polynomial p (that only depends on the choice of (cid:2)) such that for every satisfiable instance I = (V , C) of CSP((cid:2)), there exists a solution s : V → Dsuch that ||s(v)|| ≤ p(||I||) for every v ∈ V .Lemma 30. Let (cid:2) denote a constraint language over the domain D. Assume that1. (cid:2) has the small solution property and2. there exists an algorithm A and a polynomial q such that for arbitrary k-ary R ∈ (cid:2) and d1, . . . , dk ∈ D, algorithm A can verify whether (d1, . . . , dk) ∈ R in time O (q(||R|| +(cid:4)ki=1||di||)).Then CSP((cid:2)) is in NP.Proof. Let (V , C) denote an arbitrary instance of CSP((cid:2)). To show that I = (V , C) is satisfiable, non-deterministically guess a solution s : V → D such that ||s(v)|| ≤ p(||I||) for every v ∈ V (where p denotes a fixed polynomial). Such a solution exists since (cid:2) has the small solution property, and the size of s is consequently polynomially bounded in ||I||. The solution s can thus be verified in polynomial time with the aid of algorithm A. (cid:2)Many well-known structures possess the small solution property. One example is the temporal constraint problem that we introduced in Sec. 3: if (V , C) is an instance of this problem with a solution s : V → Q, then there exists a solution t : V → {1, . . . , |V |}, too, and this solution can be represented by approximately |V | · log2|V | bits. The existence of t can be shown along the following lines: let S = {s(v) | v ∈ V } = {a1, . . . , ap} with a1 < a2 < · · · < ap , and define t(v) = i if and only if s(v) = ai . It is easy to verify that t is indeed a solution to (V , C). This idea can, for instance, be used for verifying that Allen’s algebra has the small solution property.Another example is relations R defined by linear expressions, that is, R is defined by(x1, . . . , xk) ∈ R ⇔or(x1, . . . , xk) ∈ R ⇔k(cid:20)i=1k(cid:20)i=1ci · xi ≤ c0ci · xi = c0where the coefficients are in Z and the variables range over, for instance, Q or Z. Given a constraint language (cid:2) containing such relations, the small solution property for Q follows from the fact that linear programming can be solved (and a concrete solution written down) in polynomial time while the property for Z has been proven by Papadimitriou [57]. This example is interesting in several respects. First of all, the constants in Qc are, of course, linear. Furthermore, we know (from Example 8) that not even the language (cid:2) = {{(x, y, z) ∈ Z3 | x + y = z}} is ω-categorical; the same can be proved for the domain Q. Thus, the methods in Section 4 and 5 are not applicable in this case.An important observation is that it is not sufficient to verify that (cid:2) itself has the small solution property—one needs to verify that (cid:2) ∪ Dc has the small solution property if one wants to use Lemma 30 in connection with constants. We exemplify by using the relation R = {(x, y) ∈ N2 | x = 2 y−1}. The constraint language {R} has the small solution property P. Jonsson / Artificial Intelligence 257 (2018) 1–2319since every instance has the solution that assigns 1 to every variable. However, CSP({R, {2}}) does not have small solutions if we assume integers to be written in binary. Consider the instance (V , C) where V = {x0, . . . , xn} andC = {{2}(x0), R(x1, x0), R(x2, x1), . . . , R(xn, xn−1)}.It is easy to verify that (V , C) is solvable and every solution s : V → N must satisfy s(xn) = Tower(n) where Tower is the rapidly increasing functionTower(n) = 22..2(cid:5)(cid:6)(cid:7)(cid:8)n times.The small solution property is particularly useful in connection with relations that are constructed via logical definitions.Corollary 31. Let (cid:2) be a set of relations with domain D such that precondition (2) of Lemma 30 is satisfied and (cid:2) ∪ Dc has the small solution property.1. If (cid:2) is a partition scheme and (cid:7) is a finite set of relations that are quantifier-free definable in (cid:2), then CSP((cid:7) ∪ Dc) and CSP((cid:7) ∪ D f )are in NP.2. If (cid:7) is a finite set of relations that are quantifier-free positive definable in (cid:2), then CSP((cid:7) ∪ Dc) and CSP((cid:7) ∪ D f ) are in NP.Proof. We begin by proving case 1. Hence, assume that (cid:2) is a partition scheme. We know that (cid:2) ∪ Dc has the small solution property so CSP((cid:2) ∪ Dc) is in NP by Lemma 30. Lemma 6 implies that CSP((cid:7) ∪ Dc) is in NP and, consequently, CSP((cid:7) ∪ D f )is in NP by Lemma 3.We continue by proving case 2. We know that (cid:7) has a quantifier-free positive definition in (cid:2). This and the fact that CSP((cid:2) ∪ Dc) is in NP allow us to apply Lemma 7 and conclude that CSP((cid:7) ∪ Dc) is in NP and that CSP((cid:7) ∪ D f ) is in NP by Lemma 3. (cid:2)We exemplify Corollary 31 with the point algebra PA over Z; recall from Sec. 2.3 that (Z; <) is not ω-categorical so methods I and II are not applicable. Let (cid:2) denote the basic relations {<, >, =} over the domain Z. By using the same idea as we used for proving that temporal constraints have the small solution property, it follows that if an instance (V , C) of CSP((cid:2)) has a solution, then it has a solution s : V → {1, . . . , |V |} and (cid:2) has the small solution property. Let us now consider the constraint language (cid:2) ∪ Zc . We assume as usual that the constants in Zc are represented by c written in binary. Let (V , C) denote an arbitrary instance of CSP((cid:2) ∪ Zc) and define S = {d | {d}(x) ∈ C}. Building on the same proof idea once again, one can easily verify that if (V , C) has a solution, then it has a solution s : V → {(min S) − |V |, . . . , (max S) + |V |}. (cid:3) = (cid:25)log2(| max S|) + 1(cid:27) bits are needed to represent the numbers min S and Now, at most r = (cid:25)log2(| min S|) + 1(cid:27) and rare smaller than ||(V , C)||. We max S, respectively. This implies that (cid:2) ∪ Zc has the small solution property since r and rsee that (cid:2) is a partition scheme and (cid:2) ∪ Zc satisfies precondition (2) of Lemma 30. We conclude that both CSP((cid:7) ∪ Zc) and CSP((cid:7) ∪ Z f ) are members of NP whenever (cid:7) is quantifier-free first-order definable in (cid:2).(cid:3)6.2. An example based on RCC-5setWe will now illustrate the small solution property with RCC-5set. Henceforth, let R denote the RCC-5 basic relations interpreted as RCC-5set relations (see Fig. 3 in Section 3). It is known that RCC-5set is not ω-categorical so the methods in Sections 4 and 5 are not applicable. As a warm-up, we give a simple way of proving this under the assumption that P (cid:6)=NP. Let (cid:2) = R ∪ {(cid:6)=} where (cid:6)= equals B∈R\{EQ} B. It is known that CSP((cid:2)) is in P [39,59]. We extend (cid:2) with one constant: (cid:2)(cid:3) = (cid:2) ∪ {{0, 1, 2}}. Consider the constraints {PP( y, z), {0, 1, 2}(z)}. It is clear that if s is a solution, then(cid:2)s( y) ∈ {{0}, {1}, {2}, {0, 1}, {0, 2}, {1, 2}}so there are 6 distinct possible choices for the variable y. This implies that there is a straightforward polynomial-time reduction from 6-Colourability to CSP((cid:2)(cid:3)) (since the relation (cid:6)= is in (cid:2)(cid:3)) and, consequently, that CSP((cid:2)(cid:3)) is NP-complete. If Theorem 15 or Theorem 27 were applicable, then CSP((cid:2)(cid:3)) would be polynomial-time solvable.Proving that a particular constraint language has the small solution property may be a non-trivial task; one may, for instance, think of the previously mentioned results concerning linear and integer programming. When studying qualitative constraint languages, one often encounters relations that only relates “smaller” objects with “larger” objects: obvious exam-ples include the less-than relation < or the subset relation ⊂. Such relations are occasionally useful for inductively proving the small solution property. This idea is illustrated in the next lemma.Lemma 32. Let D = 2N \ {∅}. The constraint language R ∪ Dc has the small solution property.20P. Jonsson / Artificial Intelligence 257 (2018) 1–23Proof. Let I = (V , C) be a satisfiable instance of CSP(R ∪ Dc) with solution s : V → 2(cid:3) = (VI(cid:3)) as follows.(cid:3), CN \ {∅}. Construct a new instance Step 1. Remove every EQ(x, y) constraint: this can be done by collapsing the variables x and y (we leave the obvious details of this step to the reader).Step 2. Replace every PP(cid:2)(x, y) constraint with PP( y, x).Step 3. Remove every PO(x, y) constraint by replacing it withDR(z1, z2) DR(z2, z3) DR(z3, z1)DR(z1, y)PP(z1, x)PP(z2, y)PP(z2, x)PP(z3, y) DR(z3, x)where z1, z2, z3 are fresh variables.Note the following.(cid:3)is a satisfiable instance of CSP(R ∪ Dc),1. I2. the only non-unary relations that appear in I are DR and PP, and3. the size of V(cid:3)is upper bounded by some polynomial q (that does not depend on (V , C)).Fact 3 can be established as follows: fresh variables are only introduced in Step 3 where PO constraints are removed, and there are at most O (|V |2) such constraints since PO is a binary relation.(cid:3)We say that two variables u, v in Iare PP-connected if there exists a sequence of variables w 1, . . . , w p such that1. w 1 = u,2. w p = v, and3. PP(w i, w i+1) ∈ C(cid:3)for all 1 ≤ i < p.Note that if u and v are PP-connected, then in any solution s(cid:3)(cid:3)of Iwe have that (s(cid:3)(u), s(cid:3)(v)) ∈ PP.Given a constant relation U = {{a1, . . . , ak}} ∈ Dc , we let sz(U ) = k. Now, letT = max{sz(U ) | U (x) ∈ C(cid:3)and U ∈ Dc}.If u is PP-connected with some variable v and U (v) ∈ C, then we know that |s(cid:3)(cid:3)(u)| < T for any solution s(cid:3)to I(cid:3).We prove that at most |V(cid:3)(cid:3)| · T different elements are needed for representing a solution by induction over the number . This implies the result by reasoning as follows: we can without loss of generality assume that the set of of variables in V(cid:3)| · T bits if we view each value possible values is 2as a bit vector where the ith component equals 1 if and only if i is a member of the set. Hence, CSP(R ∪ Dc) has the small solution property since |V(cid:3)|·T } \ {∅}. To represent such a value, i.e., a set, we need at most |V(cid:3)| ≤ q(|V |) ≤ q(||I||) and T ≤ ||I|| ≤ q(||I||).{1,...,|VBasis step. If |Vunary relation) or a set with cardinality T is sufficient (otherwise).(cid:3)| = 1 and V(cid:3) = {v}, then either a singleton set is sufficient as a value for v (if v is not constrained by a Induction hypothesis. Assume the claim holds when |V(cid:3)| = p.(cid:3)(cid:3)(cid:3), C(cid:3)| = p + 1. If there are variables v, v(cid:3)Induction step. We show the claim when |Vsuch that v is PP-connected to v(cid:3)) has no solution and this leads to a contradiction. Thus, we can choose a variable is PP-connected to v, then (Vand v(cid:3)v ∈ Vsuch that v is maximal with respect to PP-connectedness, i.e. v is not PP-connected to any other variable. Let Ibe restricted to variable set V \ {v}. By the induction hypothesis, we need at most pT values for the instance the instance I(cid:3)(cid:3). If there exists U (v) ∈ C , then we need at most T values for v which gives us at most pT + T = (p + 1)T values in Itotal. If there is no U (v) ∈ C , then we need at most one additional value for v so we need at most pT + 1 ≤ (p + 1)Tvalues in total. To see this, v may (in the worst case) be PP-connected to every other variable and v must (by the induction hypothesis) contain at least pT different values. However, it must also be a strict superset of the other variables and this is accomplished by adding one fresh element. (cid:2)(cid:3) ∈ V(cid:3)(cid:3)(cid:3)Theorem 33. Let (cid:2) be a finite set of relations that are quantifier-free definable in R. Then, CSP((cid:2) ∪ Dc) and CSP((cid:2) ∪ D f ) are in NP.Proof. Combine Lemma 32 with Corollary 31. (cid:2)P. Jonsson / Artificial Intelligence 257 (2018) 1–23216.3. DiscussionThe idea behind Lemma 32 can readily be extended to other classes of relations that are related to RCC-5 such as (certain variants of) set relations (cf. Bodirsky and Hils [10] and the references in their article), and it can also be generalised in other directions. An interesting observation is that the NP membership results for RCC-5 and RCC-8 in the plane by Li et al. [48] is implicitly based on the small solution property. There, the representational size of the regions are analysed and bounded by exploiting a particular parameter that is related to embeddings of planar graphs in the plane. Another interesting observation is that Li [47] uses concepts that are similar to PP-connectedness when constructing different realisations of the RCC-8 formalism. This may indicate that the approach taken in the proof of Lemma 32 could quite easily be adapted to other spatial formalisms.We conclude this section by a few observations concerning the small solution property. First of all, it is important to realise that the converse of Lemma 30 does not necessarily hold. Clearly, the function log(Tower(n)) grows faster than any polynomial in n. Now consider the constraint language (cid:2) = {U 1, U 2, . . . } where U i = {x ∈ N | x = Tower(i)}. Checking if an instance of CSP((cid:2)) is satisfiable or not can trivially be solved in polynomial time if U 1, U 2, . . . are represented in a reasonable way—for instance, if U i is represented by the number i written in binary. Thus, CSP((cid:2)) is in NP, too. It is obvious, though, that (cid:2) does not have the small solution property if we represent the natural numbers in binary.Finally, we want to emphasise once again that the choice of exact interpretation and representation of relations and do-main elements is extremely important. Recall the ω-categorical and homogeneous representation of RCC-5 that we denoted RCC-5ω−cat. In this case, adding constants preserves computational complexity (up to polynomial-time reductions) by The-orem 27 (given that relations and domain elements are represented in a suitable way). Recall that adding a finite number of constant relations always preserve the complexity by Corollary 28. We know from an earlier example that adding even a single constant may not preserve the complexity of RCC-5set. At the same time, we know from Proposition 13 that the CSPs for RCC-5set and RCC-5ω−cat are the very same computational problem.7. ConclusionsWe have presented three different methods for analysing the complexity of qualitative CSPs extended with finite unary relations. Assume we have a constraint language (cid:2) over domain D and we want to analyse the complexity of CSP((cid:2) ∪Dc) or CSP((cid:2) ∪ D f ). Which method should we use? If (cid:2) is ω-categorical, then methods I (model-complete cores) and II (homogeneity) should be considered first. If there is a way of efficiently computing orbit-defining formulas, then method I is typically the easiest method to use and it gives polynomial-time equivalence of CSP((cid:2)) and CSP((cid:2) ∪ Dc). However, if B ⊆ (cid:2) and (cid:2) is quantifier-free definable in B for some partition scheme B, then one should always check whether (cid:2) is homogeneous or not. If so, one can apply method II and circumvent the need for computing orbit-defining formulas. Note, though, that one does not always get polynomial-time equivalence of CSP((cid:2)) and CSP((cid:2) ∪ Dc) in this case. If (cid:2) is not ω-categorical (or there are other problems in applying method I and/or II), then one has to resort to method III (small solutions).We exemplify this approach by taking a closer look at the cardinal relation algebra (CRA) [29,50]. Here, the domain elements are points in the plane and we have nine basic relations (N, NE, E, SE, S, SW, W, NW and the equality relation EQ) (cid:3)) holds if and only if x < x(cid:3)) SW ( y, y(cid:3). Let B denote this set of that describe cardinal directions. For instance, (x, xand y < yrelations over the set Q2. Li et al. [48] have shown that B∨=extended with constants and/or finite unary relations give rise to an NP-complete constraint satisfaction problem. We will now give a more fine-grained analysis in the case when we add constants to constraint languages. Hirsch [32, Corollary 8] has shown that CRA is ω-categorical so method I is in principle applicable. However, given a constraint language (cid:2) ⊆ B∨=, we do not know right away whether it is a model-complete core or not, and we do not know how to compute orbit-defining formulas. This can probably be worked out quite easily since CRA is closely related to the point algebra PA. A simpler way, though, is to note that Hirsch [32, Theorem 1] has proved that CRA is homogeneous. If we combine this with the fact that CRA is a partition scheme, we can easily apply method II and conclude the following: if B ⊆ (cid:2) ⊆ B∨=, then CSP((cid:2)) and CSP((cid:2) ∪ (Q2)c) are polynomial-time equivalent problems.Methods I and II are based on exploiting model-theoretical properties of the underlying constraint languages. While methods based on model theory and universal algebra have been very common when studying CSPs from the viewpoint of theoretical computer science [3,13,20], such methods have been less popular within the AI community (with some notable exceptions such as Hirsch [32] and Huang [35]). Thus, we take the opportunity to discuss these methods in slightly more detail.(cid:3)Method I. The main obstacle for applying method I is the need for computing orbit-defining formulas efficiently. In fact, it is not even known if this problem is decidable or not in the general case. Studying this problem is a very important future research direction. In cases where we do not know how to efficiently generate orbit-defining formulas, there are (at least) two possible workarounds. We have already encountered the first workaround in Corollary 16: the restriction to finite sets of constant relations. Another workaround is to sacrifice polynomial-time equivalence and allow more time for computing the orbit-defining formula. If the problem at hand is NP-hard, then a (preferably mildly) exponential algorithm can be acceptable. In both cases, algorithmic methods for generating orbit-defining formulas would be helpful. We note, on the positive side, that related definability problems have recently been successfully addressed, cf. Bodirsky et al. [15]. 22P. Jonsson / Artificial Intelligence 257 (2018) 1–23Their methods are interesting since they combine methods taken from universal algebra, Ramsey theory, and topological dynamics.Method II. Given a structure (cid:2), it may be difficult to verify that it is indeed homogeneous. Here, one should note that if (cid:2)contains a finite number of relations, the domain of (cid:2) is countably infinite, and (cid:2) is homogeneous, then (cid:2) is ω-categorical, cf. Macpherson [53]. This explains why one should always check ω-categoricity first, and this can quite often be accom-plished by using Theorem 11. If (cid:2) is ω-categorical, then (cid:2) is homogeneous if and only if every formula in Th((cid:2)) is equivalent to a quantifier-free formula (see, for instance, Macpherson [53]). This gives an alternative way of proving homogeneity than using the automorphism-based definition directly. This also clarifies the connections between method I and method II: recall that (cid:2) is model-complete if and only if every formula in Th((cid:2)) is equivalent to an existential formula.Another approach for using homogeneity is to construct suitable homogeneous structures “from scratch”. The main tool for this is Fraïssé amalgamation. The details are outside the scope of this article: Macpherson [53] outlines the approach and concrete constructions for RCC-5 and RCC-8 can be found in Bodirsky and Chen [7] and Bodirsky and Wölfl [16], respectively. One should note that amalgamation is quite common in the literature on CSPs and related problems; however, it is often referred to as the patchwork property [35,52,61].AcknowledgementsWe thank Meysam Aghighi, Manuel Bodirsky, Fredrik Heintz, Johan Thapper, and the anonymous reviewers for providing valuable input to this article. This research did not receive any specific grant from funding agencies in the public, commer-cial, or not-for-profit sectors.References[1] James F. Allen, Maintaining knowledge about temporal intervals, Commun. ACM 26 (11) (1983) 832–843.[2] Libor Barto, The dichotomy for conservative constraint satisfaction problems revisited, in: Proc. 26th Annual IEEE Symposium on Logic in Computer Science (LICS-2011), 2011, pp. 301–310.[3] Libor Barto, Marcin Kozik, Constraint satisfaction problems solvable by local consistency methods, J. ACM 61 (1) (2014) 3.[4] Bruce L. Bauslaugh, Core-like properties of infinite graphs and structures, Discrete Math. 138 (1–3) (1995) 101–111.[5] Manuel Bodirsky, Cores of countably categorical structures, Log. Methods Comput. Sci. 3 (1) (2007) 1–16.[6] Manuel Bodirsky, Complexity classification in infinite-domain constraint satisfaction, Mémoire d’habilitation à diriger des recherches, Université Diderot – Paris 7. Available at arXiv:1201.0856, 2012.[7] Manuel Bodirsky, Hubie Chen, Qualitative temporal and spatial reasoning revisited, J. Log. Comput. 19 (6) (2009) 1359–1383.[8] Manuel Bodirsky, Víctor Dalmau, Datalog and constraint satisfaction with infinite templates, J. Comput. Syst. Sci. 79 (1) (2013) 79–100.[9] Manuel Bodirsky, Martin Grohe, Non-dichotomies in constraint satisfaction complexity, in: Proc. 35th International Colloquium on Automata, Languages and Programming (ICALP-2008), 2008, pp. 184–196.[10] Manuel Bodirsky, Martin Hils, Tractable set constraints, J. Artif. Intell. Res. 45 (2012) 731–759.[11] Manuel Bodirsky, Peter Jonsson, A model-theoretic view on qualitative constraint reasoning, J. Artif. Intell. Res. 58 (2017) 339–385.[12] Manuel Bodirsky, Peter Jonsson, Trung Van Pham, The reducts of the homogeneous binary branching C-relation, J. Symb. Log. 81 (4) (2016) 1255–1297.[13] Manuel Bodirsky, Jan Kára, The complexity of temporal constraint satisfaction problems, J. ACM 57 (2) (2010).[14] Manuel Bodirsky, Jan Kára, A fast algorithm and datalog inexpressibility for temporal reasoning, ACM Trans. Comput. Log. 11 (3) (2010) 15.[15] Manuel Bodirsky, Michael Pinsker, Todor Tsankov, Decidability of definability, J. Symb. Log. 78 (4) (2013) 1036–1054.[16] Manuel Bodirsky, Stefan Wölfl, RCC8 is polynomial on networks of bounded treewidth, in: Proc. 22nd International Joint Conference on Artificial Intelligence (IJCAI-2011), 2011, pp. 756–761.2003), 2003, pp. 321–330.[17] Andrei Bulatov, Tractable conservative constraint satisfaction problems, in: Proc. 18th Annual IEEE Symposium on Logic in Computer Science (LICS-[18] Andrei Bulatov, Conservative constraint satisfaction re-revisited, J. Comput. Syst. Sci. 82 (2) (2016) 347–356.[19] Andrei Bulatov, A dichotomy theorem for nonuniform CSPs, in: Proc. 58th IEEE Annual Symposium on Foundations of Computer Science (FOCS-2017), [20] Andrei Bulatov, Peter Jeavons, Andrei Krokhin, Classifying the computational complexity of constraints using finite algebras, SIAM J. Comput. 34 (3) 2017, pp. 319–330.(2005) 720–742.[21] Peter J. Cameron, Oligomorphic Permutation Groups, Cambridge University Press, Cambridge, 1990.[22] Georg Cantor, Über unendliche, lineare Punktmannigfaltigkeiten, Math. Ann. 23 (1884) 453–488.[23] Clément Carbonnel, The dichotomy for conservative constraint satisfaction is polynomially decidable, in: Proc. 22nd International Conference on Prin-ciples and Practice of Constraint Programming (CP-2016), 2016, pp. 130–146.[24] David Cohen, Peter Jeavons, Peter Jonsson, Manolis Koubarakis, Building tractable disjunctive constraints, J. ACM 47 (5) (2000) 826–853.[25] Anthony G. Cohn, Jochen Renz, Qualitative spatial representation and reasoning, in: Handbook of Knowledge Representation, Elsevier, 2008, pp. 551–596.[26] Daniel de Leng, Fredrik Heintz, Qualitative spatio-temporal stream reasoning with unobservable intertemporal spatial relations using landmarks, in: Proc. 30th AAAI Conference on Artificial Intelligence (AAAI-2016), 2016, pp. 957–963.[27] Ivo Düntsch, Hui Wang, Stephen McCloskey, A relation-algebraic approach to the region connection calculus, Theor. Comput. Sci. 255 (1–2) (2001) 63–83.[28] Frank Dylla, Jae Hee Lee, Till Mossakowski, Thomas Schneider, André van Delden, Jasper van de Ven, Diedrich Wolter, A survey of qualitative spatial and temporal calculi: algebraic and computational properties, ACM Comput. Surv. 50 (1) (2017) 7.[29] Andrew U. Frank, Qualitative spatial reasoning with cardinal directions, in: Proc. 7th Austrian Conference on Artificial Intelligence (ÖGAI-91), 1991, pp. 157–167.[30] Stella Giannakopoulou, Charalampos Nikolaou, Manolis Koubarakis, A reasoner for the RCC-5 and RCC-8 calculi extended with constants, in: Proc. 28th AAAI Conference on Artificial Intelligence (AAAI-2014), 2014, pp. 2659–2665.[31] Pavol Hell, Jaroslav Nešetˇril, Graphs and Homomorphisms, Oxford University Press, Oxford, 2004.[32] Robin Hirsch, Relation algebras of intervals, Artif. Intell. 83 (2) (1996) 267–295.P. Jonsson / Artificial Intelligence 257 (2018) 1–23232016, pp. 37–45.[33] Robin Hirsch, Expressive power and complexity in algebraic logic, J. Log. Comput. 7 (3) (1997) 309–351.[34] Wilfrid Hodges, Model Theory, Cambridge University Press, 1993.[35] Jinbo Huang, Compactness and its implications for qualitative spatial and temporal reasoning, in: Proc. 13th International Conference on Knowledge Representation and Reasoning (KR-2012), 2012.[36] Peter Jeavons, On the algebraic structure of combinatorial problems, Theor. Comput. Sci. 200 (1–2) (1998) 185–204.[37] Peter Jonsson, Finite unary relations and qualitative constraint satisfaction, in: Proc. 22nd European Conference on Artificial Intelligence (ECAI-2016), [38] Peter Jonsson, Christer Bäckström, A unifying approach to temporal constraint reasoning, Artif. Intell. 102 (1) (1998) 143–155.[39] Peter Jonsson, Thomas Drakengren, A complete classification of tractability in RCC-5, J. Artif. Intell. Res. 6 (1997) 211–221.[40] Peter Jonsson, Victor Lagerkvist, Upper and lower bounds on the time complexity of infinite-domain CSPs, in: Proc. 21st International Conference on Principles and Practice of Constraint Programming (CP-2015), 2015, pp. 183–199.[41] Markus Junker, Martin Ziegler, The 116 reducts of (Q, <, a), J. Symb. Log. 73 (3) (2008) 861–884.[42] Michael Kompatscher, Trung Van Pham, A complexity dichotomy for poset constraint satisfaction, in: Proc. 34th Symposium on Theoretical Aspects of Computer Science (STACS-2017), 2017, 47.[43] Manolis Koubarakis, Tractable disjunctions of linear constraints: basic results and applications to temporal reasoning, Theor. Comput. Sci. 266 (1–2) (2001) 311–339.(2003) 591–640.(2013) 32–58.227–259.(1995) 43–66.[44] Arne Kreutzmann, Diedrich Wolter, Qualitative spatial and temporal reasoning with AND/OR linear programming, in: Proc. 21st European Conference on Artificial Intelligence (ECAI-2014), 2014, pp. 495–500.[45] Andrei Krokhin, Peter Jeavons, Peter Jonsson, Reasoning about temporal relations: the tractable subclasses of Allen’s interval algebra, J. ACM 50 (5) [46] C. Langford, Some theorems on deducibility, Ann. Math. 28 (1927) 16–40.[47] Sanjiang Li, On topological consistency and realization, Constraints 11 (1) (2006) 31–51.[48] Sanjiang Li, Weiming Liu, Sheng-sheng Wang, Qualitative constraint satisfaction problems: an extended framework with landmarks, Artif. Intell. 201 [49] Sanjiang Li, Mingsheng Ying, Extensionality of the RCC8 composition table, Fundam. Inform. 55 (3–4) (2003) 363–385.[50] Gérard Ligozat, Reasoning about cardinal directions, J. Vis. Lang. Comput. 9 (1) (1998) 23–44.[51] Gérard Ligozat, Jochen Renz, What is a qualitative calculus? A general framework, in: Proc. 8th Pacific Rim International Conference on Artificial Intelligence (PRICAI-2004), 2004, pp. 53–64.[52] Carsten Lutz, Maja Milicic, A tableau algorithm for description logics with concrete domains and general Tboxes, J. Autom. Reason. 38 (1–3) (2007) [53] Dugald Macpherson, A survey of homogeneous structures, Discrete Math. 311 (15) (2011) 1599–1634.[54] David Marker, Model Theory: An Introduction, Springer, 2002.[55] Bernhard Nebel, Hans-Jürgen Bürckert, Reasoning about temporal relations: a maximal tractable subclass of Allen’s interval algebra, J. ACM 42 (1) [56] Charalampos Nikolaou, Manolis Koubarakis, Querying incomplete information in RDF with SPARQL, Artif. Intell. 237 (2016) 138–171.[57] Christos Papadimitriou, On the complexity of integer programming, J. ACM 28 (4) (1981) 765–768.[58] David A. Randell, Zhan Cui, Anthony G. Cohn, A spatial logic based on regions and connection, in: Proc. 3rd International Conference on Principles of Knowledge Representation and Reasoning (KR-1992), 1992, pp. 165–176.[59] Jochen Renz, Bernhard Nebel, On the complexity of qualitative spatial reasoning: a maximal tractable fragment of the region connection calculus, Artif. Intell. 108 (1–2) (1999) 69–123.Handbook of Spatial Logics, Springer, 2007, pp. 161–215.[60] Jochen Renz, Bernhard Nebel, Qualitative spatial reasoning using constraint calculi, in: Marco Aiello, Ian Pratt-Hartmann, Johan van Benthem (Eds.), [61] Michael Sioutis, Manolis Koubarakis, Consistency of chordal RCC-8 networks, in: Proc. 24th International Conference on Tools with Artificial Intelligence [62] Matthias Westphal, Julien Hué, Stefan Wölfl, On the scope of qualitative constraint calculi, in: Proc. 37th Annual German Conference on AI (KI-2014), [63] Dmitriy Zhuk, A proof of CSP dichotomy conjecture, in: Proc. 58th IEEE Annual Symposium on Foundations of Computer Science (FOCS-2017), 2017, (ICTAI-2012), 2012, pp. 436–443.2014, pp. 207–218.pp. 331–342.