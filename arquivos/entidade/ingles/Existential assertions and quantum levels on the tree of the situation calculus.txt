Artificial Intelligence 170 (2006) 643–652www.elsevier.com/locate/artintExistential assertions and quantum levels onthe tree of the situation calculusFrancesco SavelliDipartimento di Informatica e Sistemistica, Università di Roma “La Sapienza”, Via Salaria 113, I-00198 Roma, ItalyReceived 14 February 2005; received in revised form 7 December 2005; accepted 5 January 2006Available online 8 February 2006AbstractIn a seminal paper, Reiter introduced a variant of the situation calculus along with a set of its properties. To the best of ourknowledge, one of these properties has remained unproved and ignored despite its relevance to the planning problem and theexpressivity of the theories of actions. We state this property in a more general form and provide its proof. Intuitively, whenevera theory of actions entails that there exists a situation satisfying a first order formula (e.g., a goal), at least one such situation mustbe found within a predetermined distance from the initial situation. This distance is finite and the same in all the models of thetheory, since it depends only on the theory and the formula at hand. 2006 Elsevier B.V. All rights reserved.Keywords: Knowledge representation; Reasoning about actions and change; Situation calculus1. IntroductionIn reasoning about actions and change with partial knowledge, computing a plan of actions that achieves a specifiedgoal can be impossible even if the existence of the plan is formally guaranteed. Indeed, if a logical theory of actionsdoes not include a complete axiomatic representation of the system’s state, no one plan (or finite disjunction of plans)might exist that simultaneously meets the goal in all the models of the theory, though each model might still containits own valid plan. When this is the case, no finite plan guaranteed to succeed can be built and executed in the realworld, even though its existence is actually entailed by the theory.This problem has a theoretical solution in the variant of the situation calculus [1] introduced by Reiter [2], whichhas represented one of the most influential approaches to laying formal foundations for planning, diagnosis, and agentspecification in artificial intelligence, besides having contributed new insights into database theory. For nearly fifteenyears, a diverse body of research has stemmed from Reiter’s seminal paper [2], and the original ideas and notionscontained therein are currently at the core of much work in cognitive robotics. All but one of the properties of theformalism were formally proved in a later paper [3] after cleaner and more systematic axiomatization, and have beenextensively employed in later research.E-mail address: Francesco.Savelli@dis.uniroma1.it (F. Savelli).0004-3702/$ – see front matter  2006 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2006.01.002644F. Savelli / Artificial Intelligence 170 (2006) 643–652To the best of our knowledge, the theorem in [2] that provides the solution to the problem introduced abovehas never been mentioned again, and its formal justification has not appeared in literature. The theorem formallyguarantees that if a theory of actions entails the existence of a plan that achieves a given goal, a finite disjunctiveinstance can be built.This result is still theoretically very relevant as the research community begins to investigate more complexsystems, and consequently the problem of plan computability is being recasted in more sophisticated terms. One note-worthy example is the problem of “knowing how” to execute a program augmented with non-deterministic choicesand sensing actions [4,5] in cognitive robotics.In this paper we provide the missing proof of Reiter’s theorem. We state the result in more general terms and showits implications for the expressivity of the formalism. Intuitively, whenever an action theory entails that there existsa situation satisfying a first order formula (e.g., a goal), at least one such situation must be found inside a specialregion of the tree of situations that characterizes the models of the theory. This region takes the form of a finite subsetof all the levels of the tree, and it is the same in all the models of the theory, since it depends only on the theory andthe formula at hand. We dub the situation-tree levels belonging to this subset “quantum levels”.The rest of this paper is organized as follows. In Section 2 we recall the basic formal notions needed to make thispaper self-contained, and introduce some preliminary definitions and results that are straightforward consequencesof previous work. In Section 3 we state and prove some properties of the situation calculus, including the theoremmentioned above (Theorem 2 of [2]). In Section 4 we discuss the implications of these results for the expressivity ofthe situation calculus and for current research in reasoning about actions and change.2. The situation calculusWe assume the reader is familiar with the basic concepts of classical logic [6]. We recall some notations.In a formula, by τ1/τ2 we denote that the occurrences of τ1 are replaced by τ2. By (∀) or (∃) at the beginning ofa formula we intend that all the free variables occurring in the formula are universally or existentially closed. Givena function or constant symbol ω of a language L, ωM denotes the interpretation of ω in the structure M of L. Weextend the classical notation of entailment to set of sentences: M |= {φi}i∈N means that the structure M entails everysentence φ1, φ2, . . . of the set simultaneously. The meaning of T |= {φi}i∈N, where T is a theory, is likewise defined.We use the notations, definitions, and results given in [3], which provides systematic and formally completefoundations for the situation calculus as formulated in [2]. These notions are recalled in Sections 2.1, 2.2, and 2.3.Sections 2.4, 2.5, and 2.6 introduce notions that simply follow from previous results.2.1. The language LsitcalcThe language Lsitcalc is a three-sorted second order language with equality. The three sorts are action for actions,situation for situations, and a catch-all sort object for everything else depending on the domain of application.We adopt the following notations, with subscripts and superscripts: α and a for terms and variables of sort action,σ and s for terms and variables of sort situation; t and x for terms and variables of any sort.S0 is the constant denoting the initial situation, anddo : action × situation → situationis a special function that enables the inductive construction of successive situations. The term do(α, σ ) interprets thesituation resulting from performing the action α in the situation σ . Thus the termdo(αn, do(. . . , do(α2, do(α1, S0))))—abbreviated as do([α1, . . . , αn], S0)—interprets the situation obtained after the sequence of actions α1, . . . , αn hastaken place. (If n = 0, do([α1, . . . , αn], σ ) is σ .)Hence, situations represent sequences of actions, which should be viewed as histories of the dynamical domain,rather than as its states. This is a fundamental distinguishing feature of Reiter’s variant of the situation calculus.The actions are usually completely represented by a finite set of action function symbols with signature (action ∪object)n → action. As an example, consider the action function symbol moveOn(x, y) denoting the action of movingF. Savelli / Artificial Intelligence 170 (2006) 643–652645the object x on the object y. The term do(moveOn(book, table), S0) will interpret the situation in which this actionhas been applied to the two objects interpreted by the constant symbols book and table.Two special predicates are (cid:1) : situation × situation, which defines an ordering relation on situations, andPoss : action × situation, which defines which actions can be performed in a given situation.The dynamical properties of the domain are represented by function and predicate symbols with signatures(action ∪ object)n × situation → (action ∪ object) and (action ∪ object)n × situation. These functions and predi-cates are respectively called functional and relational fluents. Following the example above, the relational fluentsOn(x, y, s) and Holding(z, s) may mean that in the situation s the object x is on the object y, and that the object z isbeing held by the agent. Non-fluent functions or predicates can be used to represent properties and facts independentof any specific situation, like Flat(table) or Larger(table, book).The use of terms of sort situation in Lsitcalc is limited. The only constant and function symbols of this sort are S0and do. The only predicates allowed to take an argument of sort situation are Poss, (cid:1), the equality, and the relationalfluents. The only functions allowed to take an argument of sort situation are do and the functional fluents.In a structure M of Lsitcalc the domain is partitioned into the subsets Obj, Act, and Sit, reflecting the three sorts ofthe language. Terms of sorts object, action, and situation range respectively over these different domains. We use νfor an assignment to free variables of any sort.2.2. Basic action theoriesA formula of Lsitcalc is uniform in σ iff it is first order, it does not mention the predicates Poss or (cid:1), it does notmention equality on situations, it does not quantify over variables of sort situation, and σ is the only term of sortsituation that is mentioned in the fluents occurring in the formula. The set of these formulas can be syntacticallydefined by induction [3]. Intuitively, the key property of a formula uniform in σ is that it “concerns only σ ”.A basic action theory D is composed of the foundational axioms Σ, the set of action precondition axioms Dap, theset of successor state axioms Dss, the set of unique names axioms for the action function symbols Duna, and the initialdatabase DS0 . The structure of these sets and of their axioms are as follows.1• Σ contains four foundational, domain-independent axioms.(∀) do(a1, s1) = do(a2, s2) ⊃ a1 = a2 ∧ s1 = s2is a unique name axiom for situations.(∀P ) {P (S0) ∧ (∀a, s)[P (s) ⊃ P (do(a, s))]} ⊃ (∀s)P (s)(1)(2)is a second order induction axiom on situations, whose purpose is very similar to that of the analogous axiomin Peano’s arithmetic [6]. Axiom (2) has the important effect of limiting the domain Sit to the smallest set that(i) contains the interpretation of S0, and (ii) is closed under the application of the function do to the elements ofAct and recursively of Sit itself. This inductive definition constructs an infinite tree of situations that is rooted inS0 and contains all the elements of Sit as its nodes. Every node branches on all the elements of Act [7].The last two axioms define the ordering relation on situations:(∀s) ¬s (cid:1) S0(cid:8)(∀s, s, a) s (cid:1) do(a, s(cid:8)) ≡ s (cid:1) s(cid:8) ∨ s = s(cid:8)(3)(4)Intuitively, s (cid:1) s(cid:8) means that s(cid:8) can be obtained from s by performing an appropriate sequence of actions.• Dap contains one action precondition axiom in the form(∀x1, . . . , xn, s) Poss(A(x1, . . . , xn), s) ≡ ΠA(x1, . . . , xn, s)(5)for each action function symbol A of Lsitcalc, where ΠA(x1, . . . , xn, s) is a formula uniform in s that does notmention any free variable other than x1, . . . , xn, s.1 For ease of exposition, in this section we will not treat the functional fluents. The complete introduction requires a straightforward technicalextension. The interested reader is referred to [3,7]. The theorems provided in this paper and their proofs are formally complete with respect to thefull framework including functional fluents.646F. Savelli / Artificial Intelligence 170 (2006) 643–652An action precondition axiom defines the preconditions to the executability of an action in a given situation, interms of properties holding in that situation alone. Following the simple example above, we may define:(∀x, s) Poss(pickUp(x), s) ≡ ¬(∃y)Holding(y, s)(∀x, s) Poss(putDown(x), s) ≡ Holding(x, s)(∀x, y, s) Poss(moveOn(x, y), s) ≡ Holding(x, s) ∧ Flat(y) ∧ Larger(y, x)• Dss contains one successor state axiom in the form(∀x1, . . . , xn, a, s) F (x1, . . . , xn, do(a, s)) ≡ ΦF (x1, . . . , xn, a, s)(6)for each relational fluent F of Lsitcalc, where ΦF (x1, . . . , xn, a, s) is a formula uniform in s that does not mentionany free variable other than x1, . . . , xn, a, s.A successor state axiom defines how a fluent’s truth value changes from situation to situation, based only on theaction taken and on the properties holding in the current situation. For example:(∀x, y, a, s) On(x, y, do(a, s)) ≡ a = moveOn(x, y) ∨ [On(x, y, s) ∧ a (cid:11)= pickUp(x)](∀x, a, s) Holding(x, do(a, s)) ≡ a = pickUp(x) ∨ [Holding(x, s) ∧ a (cid:11)= putDown(x)]• Duna contains unique name axioms for the action function symbols. For every two distinct action function sym-bols A and B of Lsitcalc:(∀) A(x1, . . . , xn) (cid:11)= B(y1, . . . , ym)Besides, for each action function symbol A:(∀) A(x1, . . . , xn) = A(y1, . . . , yn) ⊃ x1 = y1 ∧ · · · ∧ xn = yn• DS0 , often called the initial database, is a set of first order sentences that are uniform in S0. Their function is todescribe the world as it is before any action has been executed. Some of these sentences may mention no situation,to the purpose of representing situation-independent properties. Unique name axioms for individuals are a typicalcase of such sentences.An initial database for our simple example might be:¬(∃x) Holding(x, S0)table (cid:11)= bookFlat(table)Larger(table, book)Note that a basic action theory thus defined is first order except for the induction axiom (2).2.3. Relative satisfiability and regressionRelative satisfiability is a key property of basic action theories that will play an essential role in this paper.Theorem 1 (Relative satisfiability). A basic action theory D is satisfiable iff DS0∪ Duna is.Regression is a form of automated reasoning widely employed in computational procedures for planning and diag-nosis. There is a precise and natural way to characterize regression formally in the situation calculus. We first need todefine the class of the regressable formulas of Lsitcalc.Definition 2 (The regressable formulas). A formula W of Lsitcalc is regressable iff(1) W is first order.F. Savelli / Artificial Intelligence 170 (2006) 643–652647(2) Every term of sort situation mentioned by W has the form do([α1, . . . , αn], S0) for some2 n (cid:1) 0 and termsα1, . . . , αn of sort action.(3) For every term of the form Poss(α, σ ) mentioned by W , α has the form A(t1, . . . , tn) for some action functionsymbol A of Lsitcalc, n (cid:1) 0, and terms t1, . . . , tn of appropriate sorts.Observe that any formula uniform in σ is trivially regressable if σ is not a variable of sort situation.Given a basic action theory D and a regressable formula W , the regression operator R applied to W generatesa formula R[W ] uniform in S0 that is logically equivalent to W in the models of D. This operator is defined byinduction both on the syntactic structure of W and on the number of actions in the terms of sort situation occurringin W . This definition as well as a complete and detailed account of all the syntactic transformations involved by R canbe found elsewhere [3,7]. We emphasize here that such transformations are chiefly based on employing the logicaldefinitions (equivalences) embodied by the successor state axioms as rewriting rules. In this way, the number ofactions in the terms of sort situation can be reduced. Since the rewriting rules are axioms of D, logical equivalence ispreserved. After a finite number of iterations, this process ends with the formula R[W ] uniform in S0.A formal account of the properties of R is given by two theorems.Theorem 3. Let W be a regressable formula of Lsitcalc and D a basic action theory. Then R[W ] is uniform in S0, andD |= (∀) (W ≡ R[W ])By combining Theorems 1 and 3 the following important result is obtained [3] as well:Theorem 4 (Soundness and completeness of regression). Let W be a regressable formula of Lsitcalc and D a basicaction theory. ThenD |= W iff DS0∪ Duna |= R[W ]2.4. Executable situationsA logical definition of the executable situations is provided [7] by the recursive macro:ex(s)def≡ s = S0 ∨ (∃a, s(cid:8)) s = do(a, s(cid:8)) ∧ Poss(a, s(cid:8)) ∧ ex(s(cid:8))For a term do([α1, . . . , αn], S0) of sort situation, in the models of Σ it follows thatex(do([α1, . . . , αn], S0)) ≡ Poss(α1, S0) ∧ Poss(α2, do(α1, S0)) ∧ · · · ∧ Poss(αn, do([α1, . . . , αn−1], S0))(7)2.5. Closure on actionsIn Theorem 10 we shall consider a basic action theory that includes the following action closure property as anaxiom:(∀a)(cid:1)i=1...q(∃x1, . . . , xni ) a = Ai(x1, . . . , xni )(8)where A1, . . . , Aq are all the action function symbols for which action precondition axioms are provided in Dap.Note that for such a basic action theory, given a formula θ (a) in which the variable a of sort action occurs free, thefollowing holdsD |= [(∀a) θ (a)] ≡(cid:2)i=1...q(∀x1, . . . , xni ) θ (a/Ai(x1, . . . , xni ))(9)2 Different situation terms are typically mentioned by W , that is, n and α1, . . . , αn vary across the terms do([α1, . . . , αn], S0) occurring in W . Ifthis is not the case, W can be shown equivalent to a formula uniform in do([α1, . . . , αn], S0).648F. Savelli / Artificial Intelligence 170 (2006) 643–6522.6. Compactness of basic action theoriesCompactness is a property of first order logic theories that in general does not extend to higher order languages.Basic action theories are a fortunate case in which compactness does hold, although they include the second orderinduction axiom (2) in Σ. This can be stated as a corollary of the relative satisfiability (Theorem 1):Corollary 5 (Compactness of basic action theories). Let D be an infinite basic action theory. D is unsatisfiable iffthere exists a first order finite unsatisfiable subset of D.Proof. The if part is straightforward. Let us address the only if.D is unsatisfiable. Let D_ be the subtheory obtained when the second order induction axiom is removed from D.∪ Duna would be satisfiable too, and so would D be by relative satisfiability,If D_ were satisfiable, its subtheory DS0which contradicts the hypothesis. Then D_ must be unsatisfiable and, since it is a first order theory, it is also compact.Therefore there must exist an unsatisfiable finite subset of D_. (cid:2)3. Quantum levels and Reiter’s theoremAs recalled in Section 2.2, the domain Sit in the models of Σ has the form of a tree rooted in S0 whose nodes andarcs are respectively the elements of the domains Sit and Act [7]. There are countably infinitely many levels for thistree. This does not imply that Sit is countable, as the branching factor at every node is equal to the cardinality of Act;since no constraint for this is commonly given, in the general case Sit will take any infinite cardinality across all themodels, due to the Lowenheim–Skolem–Tarski theorem [6]. However, if we split a quantification over situations intoa double quantification, the first over the levels and the second over the situations belonging to the current level, theformer can be syntactically expanded thanks to the countability of the tree’s levels. This is formally stated and justifiedin Lemma 6 below.First, note that for a formula ϕ(s), in which s is a variable of sort situation occurring free, the universal andexistential quantifications over the situations belonging to the level l of the situation tree have the form(∀a1, . . . , al) ϕ(s/do([a1, . . . , al], S0))and(∃a1, . . . , al) ϕ(s/do([a1, . . . , al], S0))where a1, . . . , al are fresh variable symbols of sort action.Lemma 6. Let ϕ(s) be a formula of Lsitcalc, where s is a variable of sort situation occurring free. Let M be a modelof Σ and ν an assignment to the free variables occurring in ϕ(s) except s, thenM, ν |= (∀s) ϕ(s)iff M, ν |= {(∀a1, . . . , al) ϕ(s/do([a1, . . . , al], S0))}l∈Nwhere a1, . . . , al are fresh variable symbols of sort action.Proof. The only if part is straightforward. Let us address the if.M, ν |= Σ ∪ {(∀a1, . . . , al) ϕ(s/do([a1, . . . , al], S0))}l∈N.AssumeM, ν (cid:11)|= (∀s) ϕ(s)that is(10)M, ν |= (∃s) ¬ϕ(s)(11)Now pick a witness in M for (11), i.e., an element of the domain Sit of M, say ˙s, such that ϕM,ν(˙s) is false. SinceM |= Σ we know that every situation corresponds to a unique path on the situation tree, which is the sequence ofF. Savelli / Artificial Intelligence 170 (2006) 643–652649elements of Act connecting the situation to the root of the tree S0. Formally, it is ˙s = doM([ ˙a1, . . . , ˙ap], SMp ∈ N and some ˙a1, . . . , ˙ap elements of the domain Act of M. Therefore0 ) for someM, ν (cid:11)|= (∀a1, . . . , ap) ϕ(s/do([a1, . . . , ap], S0))which contradicts the initial assumption (10). (cid:2)We can now provide the main result of this paper.Theorem 7. Let D be a satisfiable basic action theory and ϕ(s) a first order formula of Lsitcalc such that, for anyn ∈ N and α1, . . . , αn terms of sort action, the formula ϕ(s/do([α1, . . . , αn], S0)) is regressable.3 ThenD |= (∀) (∃s) ϕ(s)iff there exists a finite subset Λ of N such that(cid:1)D |=(∀) (∃a1, . . . , al) ϕ(s/do([a1, . . . , al], S0))l∈Λwhere a1, . . . , al are fresh variable symbols of sort action.Proof. The if part is straightforward. Let us address the only if.D |= (∀) (∃s) ϕ(s). This can also be stated asD ∪ {(∃) (∀s) ¬ϕ(s)} is unsatisfiable.By Lemma 6 the theoryD ∪ {(∃) (∀a1, . . . , al) ¬ϕ(s/do([a1, . . . , al], S0))}l∈Nmust be unsatisfiable too. Every sentence(∃) (∀a1, . . . , ak) ¬ϕ(s/do([a1, . . . , ak], S0))can be regressed (Theorem 3) into a sentence uniform in S0, say ψk, such thatD |= [(∃) (∀a1, . . . , ak) ¬ϕ(s/do([a1, . . . , ak], S0))] ≡ ψk(12)Therefore, the setD(cid:8) = D ∪ {ψl}l∈Nis an unsatisfiable theory. In particular, by lettingD(cid:8)S0= DS0∪ {ψl}l∈Nit is easy to observe that D(cid:8) formally amounts to a new infinite basic action theoryΣ ∪ Dap ∪ Dss ∪ Duna ∪ D(cid:8)S0Then, by compactness (Corollary 5), there must exist an unsatisfiable finite subset D(cid:8)by hypothesis, D(cid:8)their l indexes. The finite superset of D(cid:8)ff of D(cid:8). Since D is satisfiablef must contain some (finitely many) elements of {ψl}l∈N: let Λ be the finite subset of N containingD ∪ {ψl}l∈Λmust be unsatisfiable too.Now, reasoning backward, by (12)D ∪ {(∃) (∀a1, . . . , al) ¬ϕ(s/do([a1, . . . , al], S0))}l∈Λ3 Hence, s is the only variable of sort situation in ϕ(s) and occurs free, and no variable of sort situation is mentioned by any term αi .650F. Savelli / Artificial Intelligence 170 (2006) 643–652is unsatisfiable, that is(cid:1)D |=(∀) (∃a1, . . . , al) ϕ(s/do([a1, . . . , al], S0)).(cid:2)l∈ΛThis result points out how the expressive power of the situation calculus is affected by the compactness of the basicaction theories, which in turn is due to the compactness of the first order theory DS0 (see Corollary 5). For example,a particular property cannot come true in only one situation whose corresponding sequence of actions has a differentlength in every model of the theory. More generally, if a basic action theory entails the existence of a situation witha given property, this situation cannot range over the levels of the situation tree in full freedom. Indeed the basic actiontheory coupled with the property determines what we call the “quantum levels” of the situation tree: given D and ϕ(s)such that D |= (∃s) ϕ(s), there must exist a finite subset of levels of the situation tree, depending only on D and ϕ, onwhich at least one witness for (∃s) ϕ(s) is found. Note that this set is the same in every model of D.A proof of Reiter’s Theorem 2 in [2]—rephrased below according to the notations and axiomatization in [3] fol-lowed here—can be easily obtained as a variant of the proof of Theorem 7 above. We first introduce some convenientdefinitions:Definition 8. Let D be a basic action theory that additionally includes the action closure axiom (8). Let k ∈ N, andG(do([a1, . . . , ak], S0)) be a first order formula of Lsitcalc uniform in do([a1, . . . , ak], S0). Ψk is the formula obtainedafter all the occurrences of the variables a1, . . . , ak and their quantifications in(∀a1, . . . , ak) ¬(cid:3)G(do([a1, . . . , ak], S0)) ∧(cid:2)(cid:4)Poss(ai, do([a1, . . . , ai−1], S0))(13)have been replaced by applying the equivalence (9) k times.i=1...kAfter this transformation the predicate Poss(. . .) occurs consistently with Definition 2 of regressable formulas. Theremaining subformula expanded from G(. . .) inherits regressability from G(. . .), which is regressable because it isuniform in do([a1, . . . , ak], S0). Ψk is hence regressable, thus letΓk = ¬R[Ψk]The purpose of the previous definition is to provide a regressable formula equivalent to (13). Indeed Poss(ai, do([a1,. . . , ai−1], S0)) is not in a regressable form (Definition 2). We can then rely on a chain of equivalences:Proposition 9. For Definition 8 we have:D |= (∀a1, . . . , ak) ¬[G(do([a1, . . . , ak], S0)) ∧ ex(do([a1, . . . , ak], S0))] ≡(by (7))(cid:3)(∀a1, . . . , ak) ¬G(do([a1, . . . , ak], S0)) ∧(cid:2)(cid:4)Poss(ai, do([a1, . . . , ai−1], S0))≡i=1...k(by Definition 8)Ψk ≡(by Definition 8 and Theorem 3)¬ΓkTheorem 10. Let D be a satisfiable basic action theory that additionally includes the action closure axiom (8). LetG(s) be a first order formula of Lsitcalc uniform in the variable of sort situations, which is also the only variableoccurring free. Let Γi , i ∈ N, be the sentences produced from G(s/do([a1, . . . , ai], S0)) as in Definition 8. ThenD |= (∃s) [G(s) ∧ ex(s)]iff for some n ∈ NDS0∪ Duna |=(cid:1)Γii=1...nF. Savelli / Artificial Intelligence 170 (2006) 643–652651Proof. We address the if part, which is rather straightforward by Definition 8 and Proposition 9.DS0∪ Duna |=(cid:1)Γii=1...nBy Proposition 9,(cid:1)D |=¬Ψii=1...nand, again by Proposition 9,(cid:1)D |=(∃a1, . . . , ai) [G(do([a1, . . . , ai], S0)) ∧ ex(do([a1, . . . , ai], S0))]i=1...nfrom which it followsD |= (∃s) [G(s) ∧ ex(s)]For the only if part the proof proceeds as for Theorem 7, provided some additional care for “ex(s)” as follows.Let ϕ(s) = G(s) ∧ ex(s); after the first step of the proof of Theorem 7 we had that the theoryD ∪ {(∀a1, . . . , al) ¬ϕ(s/do([a1, . . . , al], S0))}l∈Nis unsatisfiable.For the next step the formula in curly brackets should be in regressable form; to this purpose we can rely onProposition 9D ∪ {Ψl}l∈N is unsatisfiableProceeding as for Theorem 7, it can be shown that there exists a finite subset Λ of N such thatD |=¬Ψl(cid:1)l∈ΛBy Theorem 4 and Proposition 9, we have(cid:1)DS0∪ Duna |=Γll∈ΛBy choosing n = max Λ, we can conclude(cid:1)i=1...nΓi(cid:2)DS0∪ Duna |=4. ConclusionThis paper contributes the proof of a key property of Reiter’s variant of the situation calculus. The property wasfirst stated as a theorem in a seminal paper [2], but its proof was not provided. We have rephrased and proved thetheorem in a more general form. To this end, we have pointed out that this result is a consequence of the compactnessof the situation calculus’ basic action theories, which significantly affects the expressivity of the formalism.The theorem constrains how the situations satisfying an existential assertion can take place over the levels of thesituation tree. If one or more situations exist in which a given property (e.g., a goal) is satisfied, at least one of thesesituations must be found on certain levels of the tree, within a finite distance from the initial situation. The set ofsuch levels and the distance is the same in every model. This is a key formal guarantee for generating a plan asa finite syntactic term of the language when distinct models contain different plan solutions, as may be the case whenknowledge is incomplete.This important property of the situation calculus may not hold if a basic action theory does not comply with someof the constraints assumed in [2], and later required by definition in [3].For instance, if the initial database (DS0 ) is not first order (Section 2.2), Theorems 7 and 10 may not hold, sincetheir proofs rest on the compactness of the basic action theories, which in turn is guaranteed by the fact that the initial652F. Savelli / Artificial Intelligence 170 (2006) 643–652database is first order (Corollary 5). This case arises in the formalization of the chop problem [4,5], which is a simpleaction domain showing that an agent might not know how to execute a program with non-deterministic choices andsensing actions, even though its executability is formally guaranteed by the underlying basic action theory known tothe agent. This basic action theory is purposely designed so that the first situation in which the goal is reached is atan arbitrary distance from the initial situation in every model. It follows that there can be no such quantum levels aspredicted by Theorem 7, nor can there be such a finite number n as predicted by Theorem 10. This is only possiblebecause the hypotheses of the two theorems do not hold: the initial database is second order. Indeed, since quantifyingover the natural numbers is essential to the correctness of the chop-problem formalization, the exact standard modelof N must be selected. The second order induction axiom of Peano’s axiomatization of arithmetic is therefore requiredin the initial database, in order to rule out the non-standard models containing Z-chains [6].The chop problem generalizes the problem of building a plan that is known to exist according to a given basic actiontheory—which was originally addressed by Reiter’s theorem. The insight gained here is that this generalization, too,falls within the scope of the theorem; the chop problem, or one with a similar structure, cannot arise in basic actiontheories with a first order initial database.AcknowledgementsI am grateful to Fiora Pirri for her stimulating discussion and for her comments on an earlier draft. I would liketo thank Giuseppe De Giacomo for acquainting me with the chop problem. Two anonymous referees have providedvaluable suggestions for improving this paper.References[1] J. McCarthy, Situations, actions and causal laws, in: M. Minsky (Ed.), Semantic Information Processing, MIT Press, Cambridge, MA, 1968,pp. 410–417.[2] R. Reiter, The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression, in:V. Lifschitz (Ed.), Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, Academic Press, SanDiego, CA, 1991, pp. 359–380.[3] F. Pirri, R. Reiter, Some contributions to the metatheory of the situation calculus, J. ACM 46 (3) (1999) 261–325.[4] Y. Lespérance, H. Levesque, F. Lin, R. Scherl, Ability and knowing how in the situation calculus, Studia Logica 66 (1) (2000) 165–186.[5] S. Sardina, G. De Giacomo, Y. Lespérance, H. Levesque, On ability to autonomously execute agent programs with sensing, in: Proceedings ofthe 4th International Workshop on Cognitive Robotics (CoRobo-04), Valencia, Spain, 2004, pp. 88–93.[6] H.B. Enderton, A Mathematical Introduction to Logic, Academic Press, San Diego, CA, 1972.[7] R. Reiter, Knowledge in Action. Logical Foundations for Specifying and Implementing Dynamical Systems, MIT Press, Cambridge, MA, 2001.