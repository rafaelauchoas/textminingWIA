Artificial Intelligence 256 (2018) 160–180Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintBelief revision, minimal change and relaxation: A general framework based on satisfaction systems, and applications to description logicsMarc Aiguier a, Jamal Atif b,∗a MICS, Centrale Supelec, Université Paris-Saclay, Franceb Université Paris-Dauphine, PSL Research University, CNRS, UMR 7243, LAMSADE, 75016 Paris, Francec LTCI, Télécom ParisTech, Université Paris-Saclay, Paris, France, Isabelle Bloch c, Céline Hudelot aa r t i c l e i n f oa b s t r a c tArticle history:Received 13 November 2015Received in revised form 7 July 2017Accepted 11 December 2017Available online 17 December 2017Keywords:Abstract belief revisionRelaxationAGM theorySatisfaction systemsDescription logicsBelief revision of knowledge bases represented by a set of sentences in a given logic has been extensively studied but for specific logics, mainly propositional, and also recently Horn and description logics. Here, we propose to generalize this operation from a model-theoretic point of view, by defining revision in the abstract model theory of satisfaction systems. In this framework, we generalize to any satisfaction system the characterization of the AGM postulates given by Katsuno and Mendelzon for propositional logic in terms of minimal change among interpretations. In this generalization, the constraint on syntax independence is partially relaxed. Moreover, we study how to define revision, satisfying these weakened AGM postulates, from relaxation notions that have been first introduced in description logics to define dissimilarity measures between concepts, and the consequence of which is to relax the set of models of the old belief until it becomes consistent with the new pieces of knowledge. We show how the proposed general framework can be instantiated in different logics such as propositional, first-order, description and Horn logics. In particular for description logics, we introduce several concrete relaxation operators tailored for the description logic ALC and its fragments EL and ELU , discuss their properties and provide some illustrative examples.© 2018 Elsevier B.V. All rights reserved.1. IntroductionBelief change, the process that makes an agent’s beliefs evolve with newly acquired knowledge, is one of the classical but still challenging problems in artificial intelligence. It is gaining more and more interest these days, due to the emergence of new logical-based knowledge representation frameworks enjoying good complexity properties, allowing them to tackle large scale knowledge bases, and to reason on massive datasets. Among these logical frameworks, one can mention Description Logics (DLs) and Horn Clause theories. Description logics, for instance, are now pervasive in many knowledge-based repre-sentation systems such as ontological reasoning, semantic web, scene understanding, cognitive robotics, to mention a few. In all these domains, the expert knowledge is not fixed, but rather a flux evolving over time, hence requiring the definition of rational change operators.* Corresponding author.E-mail addresses: marc.aiguier@centralesupelec.fr (M. Aiguier), jamal.atif@dauphine.fr (J. Atif), isabelle.bloch@telecom-paristech.fr (I. Bloch), celine.hudelot@centralesupelec.fr (C. Hudelot).https://doi.org/10.1016/j.artint.2017.12.0020004-3702/© 2018 Elsevier B.V. All rights reserved.M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180161Studying the rationality of belief change operators, when knowledge bases are logical theories, i.e. sets of sentences in a given logic, goes back to the seminal work of Alchourròn, Gardenfors and Makinson [1], that gave birth to what is now known as AGM theory. Three change operations are studied within this framework, expansion, contraction and revision. Belief expansion consists in adding new knowledge without checking consistency, while both contraction and revision consist in consistently removing and adding new knowledge, respectively. We focus in this paper on belief revision.Although defined in the abstract framework of logics given by Tarski [40] (so called Tarskian logics), postulates of the AGM theory make strong assumptions on the considered logics. Indeed, in [1] the considered logics have to be closed under the standard propositional connectives in {∧, ∨, ¬, ⇒}, to be compact (i.e. inference depends on a finite set of axioms), and to satisfy the deduction theorem (i.e. entailment and implication are equivalent). While compactness is a standard property of logics, to be closed under the standard propositional connectives is more questionable. Indeed, many logics (called hereafter non-classical logics) such as description logics, equational logic or Horn clause logic, widely used for various modern applications in computing science, do not satisfy such a constraint. Recently, in many works, belief change has been studied in such non-classical logics [12,17,34,35]. For instance, Ribeiro et al. in [35] studied contraction at the abstract level of Tarskian logics, and recently Zhuang et al. in [42] proposed an extension of AGM contraction to arbitrary logics. The adaptation of the AGM postulates for revision for non-classical logics has been studied but only for specific logics, mainly description logics [16,17,28,29,31,33,41] and Horn logics [11,43]. The reason is that revision can be abstractly defined in terms of expansion and retraction following the Levi identity [23], but this requires the use of negation, which rules out some non-classical logics that do not consider this connective [34].The AGM postulates were interpreted in terms of minimal change in [22], in the sense that the models of the revision should be as close as possible, according to some metric, to the models of the initial knowledge set. However, to the best of our knowledge, the generalization of the AGM theory with minimality criteria on the set of models of knowledge bases has never been proposed. The reason is that semantics is not explicit in the abstract framework of logics defined by Tarski.We propose here to generalize AGM revision but in the abstract model theory of satisfaction systems, which formalizes the intuitive notion of logical systems, including syntax, semantics and the satisfaction relation. This notion was introduced in [18] under the name of “rooms”, and then of “satisfaction systems” in [38]. See also [26]. Then, we propose to generalize to any satisfaction system the approach developed in [22] for propositional logic and in [30] for description logics. In this abstract framework, we will also show how to define revision operators from the relaxation notion that has been introduced in description logics to define dissimilarity measures between concepts [14,15]. The main idea is to relax the set of models of the old belief until it becomes consistent with the new pieces of knowledge. This notion of relaxation, defined in an abstract way through a set of properties, turns out to generalize several revision operators introduced in different contexts e.g. [9,20,25,29]. This is another key contribution of our work.To concretize our abstract framework, we provide examples of relaxations in propositional logics, first order logics, and Horn logic. The case of description logics (DLs) is more detailed. This is motivated, as mentioned above, by their broad scope of applications, including reasoning on large web data.The paper is organized as follows. Section 2 reviews some concepts, notations and terminology about satisfaction systems which are used in this work. In Section 3, we adapt the AGM theory in the framework of satisfaction systems, and then give an abstract model-theoretic rewriting of the AGM postulates. We then show in Section 3.2 that any revision operator satis-fying such postulates accomplishes an update with minimal change to the set of models of knowledge bases. In Section 3.3, we introduce a general framework of relaxation-based revision operators and show that our revision operators lead to faith-ful assignments and then also satisfy the AGM postulates. In Section 4, we illustrate our abstract approach by providing revision operators in different logics, including classical logics (propositional and first order logics) and non-classical ones (Horn and description logics). The case of DL is further developed in Section 4.4, with several examples. Finally, Section 5 is dedicated to related works.2. Satisfaction systemsSatisfaction systems [26] generalize Tarski’s classical “semantic definition of truth” [39] and Barwise’s “Translation Ax-iom” [4]. For the sake of generalization, sentences are simply required to form a set. All other contingencies such as inductive definition of sentences are not considered. Similarly, models are simply seen as elements of a class, i.e. no particular struc-ture is imposed on them.2.1. Definition and examplesDefinition 1 (Satisfaction system). A satisfaction system R = (Sen, Mod, |=) consists of• a set Sen of sentences,• a class Mod of models, and• a satisfaction relation |=⊆ Mod × Sen.162M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180Let us note that the non-logical vocabulary, so-called signature, over which sentences and models are built, is not speci-fied in Definition 1.1 Actually, it is left implicit. Hence, as we will see in the examples developed in the paper, a satisfaction system always depends on a signature.Example 1. The following examples of satisfaction systems are of particular importance in computer science and in the remainder of this paper.Propositional Logic (PL) Given a set of propositional variables (cid:2), we can define the satisfaction system R(cid:2) = (Sen, Mod,|=) where Sen is the least set of sentences finitely built over propositional variables in (cid:2) and Boolean connectives in {¬, ∨}, Mod contains all the mappings ν : (cid:2) → {0, 1} (0 and 1 are the usual truth values), and the satisfaction relation |= is the usual propositional satisfaction.Horn Logic (HCL) A Horn clause is a sentence of the form (cid:4) ⇒ α where (cid:4) is a finite (possibly empty) conjunction of propositional variables and α is a propositional variable. The satisfaction system of Horn clause logic is then defined as for PL except that sentences are restricted to be conjunctions of Horn clauses.First Order Logic (FOL) and Many-sorted First Order Logic We detail here only the many-sorted variant of FOL, FOL being a particular case. Signatures are triplets (S, F , P ) where S is a set of sorts, and F and P are a set of functionsand a set of predicate names, respectively, both with arities in Sis the set of all + ∪ {(cid:6)} where (cid:6) denotes the empty sequence). In the following, non-empty sequences of elements in S and Sto indicate that a function name f ∈ F (respectively a predicate name p ∈ P ) has for arity (s1 . . . sn, s) (respectively s1 . . . sn), we will note f : s1 × . . . × sn → s (resp. p : s1 × . . . × sn).∗ × S and Srespectively (S∗ = S++Given a signature (cid:2) = (S, F , P ), we can define the satisfaction system R(cid:2) = (Sen, Mod, |=) where:• Sen is the least set of sentences built over atoms of the form p(t1, . . . , tn) where p : s1 × . . . × sn ∈ P and ti ∈ T F ( X)si for every i, 1 ≤ i ≤ n (T F ( X)s is the term algebra of sort s built over F with sorted variables in a given set X ) by finitely applying Boolean connectives in {¬, ∨} and the quantifier ∀.• Mod is the class of models M defined by a family (Ms)s∈S of sets (one for every s ∈ S), each one equipped → Ms for every f : s1 × . . . × sn → s ∈ F and with an n-ary relation with a function fM ⊆ Ms1p× . . . × Msn× . . . × Msn for every p : s1 × . . . × sn ∈ P .M : Ms1• Finally, the satisfaction relation |= is the usual first-order satisfaction.As for PL, we can consider the logic FHCL of first-order Horn Logic whose models are those of FOL and sentences are restricted to be conjunctions of universally quantified Horn sentences (i.e. sentences of the form (cid:4) ⇒ α where (cid:4) is a finite conjunction of atoms and α is an atom).Description logic (DL) Signatures are triplets (NC , N R , I) where NC , N R and I are nonempty pairwise disjoint sets where elements in NC , N R and I are called concept names, role names and individuals, respectively.Given a signature (cid:2) = (NC , N R , I), we can define the satisfaction system R(cid:2) = (Sen, Mod, |=) where:• Sen contains2 all the sentences of the form C (cid:12) D, x : C and (x, y) : r where x, y ∈ I , r ∈ N R and C is a con-cept inductively defined from NC ∪ {(cid:13)} and binary and unary operators in {_ (cid:14) _, _ (cid:15) _} and in {_c, ∀r._, ∃r._}, respectively.• Mod is the class of models I defined by a set (cid:7)Ifor every relation name r ∈ N R with a binary relation rI ∈ (cid:7)Ix.equipped for every concept name A ∈ NC with a set AI ⊆ (cid:7)I, , and for every individual x ∈ I with a value I ⊆ (cid:7)I × (cid:7)Iis the evaluation of C in I inductively defined on the structure of C as follows:• The satisfaction relation |= is then defined as:I ⊆ DI,I , yI ) ∈ rI,,I· I |= C (cid:12) D iff CI ∈ C· I |= x : C iff x· I |= (x, y) : r iff (xIwhere C· if C = A with A ∈ NC , then C· if C = (cid:13) then C· if C = C· if C = C· if C = ∀r.C· if C = ∃r.CI = (cid:7)I(resp. C = C(cid:17) (cid:15) D(cid:17)(cid:17) c , then C, then C, then CI = (cid:7)I \ C;(cid:17)(cid:17)I = AI;(cid:17)(cid:17) (cid:14) D(cid:17) I), then C;I = C(cid:17) I ∪ D(cid:17) I(resp. CI = C(cid:17) I ∩ D(cid:17) I);I = {x ∈ (cid:7)I | ∀ y ∈ (cid:7)I , (x, y) ∈ rII = {x ∈ (cid:7)I | ∃ y ∈ (cid:7)I , (x, y) ∈ rIimplies y ∈ C(cid:17) I }.and y ∈ C(cid:17) I };2.2. Knowledge bases and theoriesLet us now consider a fixed but arbitrary satisfaction system R = (Sen, Mod, |=) (since the signature (cid:2) is supposed fixed, the subscript (cid:2) will be omitted from now on).1 The set of logical symbols is defined in each particular logic, and does not depend on a theory.2 The description logic defined here is better known under the acronym ALC.Notation 1. Let T ⊆ Sen be a set of sentences.M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180163• Mod(T ) is the sub-class of Mod whose elements are models of T , i.e. for every M ∈ Mod(T ) and every ϕ ∈ T , M |= ϕ. When T is restricted to a formula ϕ (i.e. T = {ϕ}), we will denote Mod(ϕ), the class of model of {ϕ}, rather than Mod({ϕ}).• Cn(T ) = {ϕ ∈ Sen | ∀M ∈ Mod(T ), M |= ϕ} is the set of semantic consequences of T .• Let M ⊆ Mod. Let us note M∗ = {ϕ ∈ Sen | ∀M ∈ M, M |= ϕ}. Therefore, we have for every T ⊆ Sen, Cn(T ) = Mod(T )∗When M is restricted to one model M, M∗will be equivalently noted M∗• Let us note T ri v = {M ∈ Mod | M∗ = Sen}, i.e. the set of models in which all formulas are satisfied. In PL and FOL, T ri v is empty because the negation is considered. Similarly, the complementation is involved in the DL ALC, hence T ri v is empty. In HCL, T ri v only contains the unique model where all propositional variables have a truth value equal to 1. In FHCL, T ri v contains all models M where for every predicate name p : s1 × . . . × sn ∈ P , p× . . . × Msn .M = Ms1. .Let us note that for every T ⊆ Sen, T ri v ⊆ Mod(T ).From the above notations, we obviously have:(cid:17)Cn(T ) = Cn(T) ⇔ Mod(T ) = Mod(TThe two functions Mod(_) from P(Sen) into P(Mod) and _connection in that they satisfy the following properties: for all T , Tproof of Proposition 1 below)).∗(cid:17)(1)from P(Mod) into P(Sen) form what is known as a Galois (cid:17) ⊆ Sen and M, M(cid:17) ⊆ Mod, we have (see [13] and the (cid:17)) ⊆ Mod(T )(cid:17) =⇒ Mod(T(1) T ⊆ T(2) M ⊆ M(cid:17) =⇒ M(cid:17)∗ ⊆ M∗(3) T ⊆ Mod(T )∗(4) M ⊆ Mod(M∗)Definition 2 (Knowledge base and theory). A knowledge base T is a set of sentences (i.e. T ⊆ Sen). A knowledge base T is said to be a theory if and only if T = Cn(T ).(cid:17) ⊆ Sen such that T = Cn(T(cid:17)).A theory T is finitely representable if there exists a finite set TProposition 1. For every satisfaction system R, we have:Inclusion ∀T ⊆ Sen, T ⊆ Cn(T );Iteration ∀T ⊆ Sen, Cn(T ) = Cn(Cn(T ));Monotonicity ∀T , T(cid:17) ⊆ Sen, T ⊆ T(cid:17) =⇒ Cn(T ) ⊆ Cn(T(cid:17)).Proof. For the sake of completeness, let us first show that Mod is decreasing (Property 1): let us assume T ⊆ T, and thus M |= ϕ. Hence M ∈ Mod(T ).∀M ∈ Mod(T(cid:17)) we have ∀ϕ ∈ T , ϕ ∈ T(cid:17)(cid:17), then Let us now show that Cn is increasing (monotonicity property): let us assume T ⊆ T(cid:17)), M ∈ Mod(T ) since Mod is decreasing, and M |= ϕ. Hence ϕ ∈ Cn(T(cid:17)).Mod(T(cid:17), then ∀ϕ ∈ Cn(T ) we have ∀M ∈(Property 3): indeed, ∀ϕ ∈ T we have ∀M ∈ Mod(T ), M |= ϕ by definition of Mod(T ). Hence We have T ⊆ Mod(T )∗.ϕ ∈ Mod(T )∗It is then easy to see that Cn is extensive (inclusion property) from the previous property and Cn(T ) = Mod(T )∗Let us finally show that Cn is idempotent (iteration property): extensivity implies ∀T , Cn(T ) ⊆ Cn(Cn(T )). Since T ⊆.Mod(T )∗and Cn is increasing, we have Cn(T ) ⊆ Cn(Mod(T )∗) = Cn(Cn(T )). (cid:2)Hence, satisfaction systems are Tarskian according to the definition of logics given by Tarski: a logic is a pair (L, Cn)where L is a set of expressions (formulas) and Cn : P(L) → P(L) is a mapping that satisfies the inclusion, iteration and monotonicity properties [40]. Indeed, from any satisfaction system R we can define the following Tarskian logic (L, Cn)where L = Sen and Cn is the mapping that associates to every T ⊆ Sen, the set Cn(T ) of semantic consequences of T .Classically, the consistency of a theory T is defined as Mod(T ) (cid:20)= ∅. The problem of such a definition of consistency is that its significance depends on the considered logic. Hence, this consistency is significant for FOL, while in FHCL it is a trivial property since each set of sentences is consistent because Mod(T ) always contains T ri v which is non-empty. Here, for the notion of consistency to be more appropriate for our purpose of defining revision for the largest family of logics, we propose a more general definition of consistency, the meaning of which is that there is at least a sentence which is not a semantic consequence.Definition 3 (Consistency). T ⊆ Sen is consistent if Cn(T ) (cid:20)= Sen.Proposition 2. For every T ⊆ Sen, T is consistent if and only if Mod(T ) \ T ri v (cid:20)= ∅.164M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180Proof. Let us prove that Cn(T ) = Sen iff Mod(T ) \ T ri v = ∅. Let us first assume that Mod(T ) \ T ri v = ∅. Therefore, this means that the only models that satisfy T are M such that M∗ = Sen (if they exist). Hence, we have Cn(T ) = Mod(T )∗ = Sen.Conversely, let us assume that Cn(T ) = Sen. This means that every model M such that M∗ (cid:20)= Sen does not belong to Mod(T ), and Mod(T ) \ T ri v = ∅. (cid:2)Corollary 1. For every T ⊆ Sen, T is inconsistent is equivalent to Mod(T ) = T ri v.3. AGM postulates for revision in satisfaction systems3.1. AGM postulates and weakened AGM postulatesThe AGM postulates for knowledge base revision in satisfaction systems are easily adaptable. We build upon the model-theoretic characterization introduced by Katsuno and Mendelzon (KM) [22] for propositional logic. Note, however, that in propositional logic, a belief base can be represented by a formula, and then the KM postulates exploit this property. This is no longer the case in our context, but we argue that the postulates are still appropriate, except the one on syntax inde-(cid:17), that is, T ◦ Tpendence, as discussed next. Given two knowledge bases T , Tis obtained by adding consistently new knowledge TT ∪ Tis consistent. This is what the AGM postulates ensure.is consistent. The revision operator has then to minimally change T so that T ◦ Tto the old knowledge base T . Note that T ◦ Tbecause nothing ensures that T ∪ Tcannot be defined as (cid:17)denotes the revision of T by T(cid:17) ⊆ Sen, T ◦ T(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)Here we use the following weakened AGM postulates3:(cid:17)(G1) If T(G2) Mod(T ◦ T(G3) if T ∪ T(G5) Mod((T ◦ T(G6) if (T ◦ T(cid:17)is consistent, then so is T ◦ T(cid:17).(cid:17)).(cid:17)) ⊆ Mod(Tis consistent, then T ◦ T(cid:17)(cid:17)) ⊆ Mod(T ◦ (Tis consistent, then Mod(T ◦ (T(cid:17) = T ∪ T(cid:17)(cid:17))).(cid:17) ∪ T(cid:17)) ∪ T(cid:17)(cid:17)(cid:17)) ∪ T.(cid:17)(cid:17) ∪ T(cid:17)(cid:17))) ⊆ Mod((T ◦ T(cid:17)) ∪ T(cid:17)(cid:17)).In the literature such as in [22,30], an additional postulate concerns the independence of the syntax:(G4) If Cn(T 1) = Cn(T(cid:17)1) and Cn(T 2) = Cn(T(cid:17)2), then Mod(T 1 ◦ T 2) = Mod(T(cid:17)1◦ T(cid:17)2).This postulate states a complete independence of the syntactical forms of both the original knowledge base and the newly acquired knowledge. The problem with Postulate (G4) is that it is almost never satisfied when we want to preserve the structure of knowledge bases and then apply revision operators over the formulas that compose knowledge bases. Indeed, let us consider in the logic PL the following knowledge bases T 1 = {p, q} and T 2 = {q ⇒ p, q} over the signature (cid:17) = {¬q}. {p, q}. Obviously, we have that Mod(T 1) = Mod(T 2) = {ν : p (cid:23)→ 1, q (cid:23)→ 1}. Let us consider the knowledge base T(cid:17)We have now that T 1 ∪ T(and then T 2 ∪ T) is inconsistent. A way to retrieve the consistency is to replace in T 1 and T 2(cid:17)) = {ν : p (cid:23)→ 1, q (cid:23)→ 0}, (cid:17) = {q ⇒ p, ¬q}. Then Mod(T 1 ◦ T(cid:17) = {p, ¬q} and T 2 ◦ Tthe atomic formula q by ¬q. Hence, T 1 ◦ T(cid:17)). This example shows that syntax Mod(T 2 ◦ Tindependence may be too strong a requirement.(cid:17)) = {ν : p (cid:23)→ 1, q (cid:23)→ 0; ν(cid:17) : p (cid:23)→ 0, q (cid:23)→ 0}, and Mod(T 1 ◦ T(cid:17)) (cid:20)= Mod(T 2 ◦ T(cid:17)In [22], the authors bypass the problem by representing any knowledge base K (which is a theory in [22]) by a proposi-tional formula ψ such that K = Cn(ψ). Hence, they apply their revision operator on ψ and not on K , and so they lose the structure of the knowledge base K .A weaker form of this postulate could be written as:(G’4) If Cn(T(cid:17)1) = Cn(T(cid:17)2), then Mod(T ◦ T(cid:17)1) = Mod(T ◦ T(cid:17)2),which ensures a partial independence of the syntax, only on the new knowledge. Remarkably, this weaker form can be derived from the other postulates (as expressed in Proposition 3), and is hence not used in the subsequent proofs (see e.g. Theorem 1 below).Proposition 3. Postulates (G1)–(G3), (G5) and (G6) imply Postulate (G’4).Proof. See Appendix. (cid:2)Based on this result, the only weakened AGM postulates (G1)–(G3), (G5) and (G6) are considered next.3 The numbering is kept consistent with the ones in previous works.3.2. Faithful assignment and weakened AGM postulatesM. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180165Intuitively, any revision operator ◦ satisfying the weakened AGM postulates above induces minimal change, that is the models of T ◦ T, according to some distance for measuring how close are models. This is what is now shown in this section by establishing a correspondence between the weakened AGM postulates and binary relations over models with minimality conditions.are the models of T that are the closest to models of T(cid:17)(cid:17)Let M ⊆ Mod and (cid:24) be a binary relation over M. We define ≺ as M ≺ M(cid:17)if and only if M (cid:24) M(cid:17)and M(cid:17)(cid:2)M. We also define Min(M, (cid:24)) = {M ∈ M | ∀M(cid:17) ∈ M, M(cid:17)⊀M}.Definition 4 (Faithful assignment). An assignment is a mapping that assigns to each knowledge base T a binary relation (cid:24)Tover Mod. We say that this assignment is faithful (FA) if the following two conditions are satisfied:(1) if M, M(cid:17) ∈ Mod(T ), M⊀.(2) for every M ∈ Mod(T ) and every M(cid:17) ∈ Mod \ Mod(T ), M ≺T M(cid:17)M(cid:17)T.A binary relation (cid:24)T assigned to a knowledge base T by a faithful assignment will be also said faithful.This definition of FA differs from the one originally given in [22] on two points:(1) In [22], a third condition is stated:∀T , T(cid:17) ⊆ Sen, Mod(T ) = Mod(T(cid:17)) ⇒(cid:24)T =(cid:24)T (cid:17) .As for (G4), this condition expresses a syntactical independence.(2) It is not required for (cid:24)T to be a pre-order. As shown below, the only important feature to have to make a correspon-dence between a FA and the fact that ◦ satisfies the weakened AGM Postulates is that there is a minimal model for (cid:24)Tin Mod(T(cid:17)) as expressed by Theorem 1.Theorem 1. Let ◦ be a revision operator. The operator ◦ satisfies the weakened AGM Postulates (as defined in Section 3.1) if and only if there exists a FA that maps each knowledge base T ⊆ Sen to a binary relation (cid:24)T such that for every knowledge base T(cid:17) ⊆ Sen:• Mod(T ◦ T(cid:17)• if T• for every T(cid:17)) \ T ri v = Min(Mod(Tis consistent, then Min(Mod(T(cid:17)(cid:17)(cid:17)(cid:17) ⊆ Sen, if (T ◦ T(cid:17)) ∪ T(cid:17)) \ T ri v, (cid:24)T );(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅;is consistent, then Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T(cid:17)(cid:17)) = Min(Mod(T(cid:17) ∪ T(cid:17)(cid:17)) \ T ri v, (cid:24)T ).Proof. See Appendix. (cid:2)(cid:17)(cid:17)Note that if Tis inconsistent, then so is T ◦ T, which corresponds to a cautious revision. The case where T is inconsistent is not considered in this paper (and is usually excluded from the scope of revision procedures), since in that case other operators could be more relevant than revision, in particular debugging methods (see e.g. [36] for debugging of terminologies, or [32] for base revision for ontology debugging, both in description logics)., and we can set arbitrarily T ◦ TGiven a revision operator ◦ satisfying the weakened AGM postulates, any FA satisfying the supplementary conditions of Theorem 1 will be called FA+. To a revision operator ◦ satisfying the weakened AGM postulates, we can associate many FA+. An example of such a FA+ was given in the proof of Theorem 1. Another example is the mapping f that associates to every T ⊆ Sen the binary relation (cid:24)T defined as follows:(cid:17) = T(cid:17)Given T(cid:17) ⊆ Sen, let us start by defining (cid:24)TT(cid:17)⊆ Mod(T(cid:17)) × Mod(T(cid:17)) as:(cid:17)M (cid:24)TTM(cid:17) ⇐⇒ M ∈ Mod(T ◦ T(cid:17)) and M(cid:17)/∈Mod(T ◦ T(cid:17)).Let us then set f (T ) = (cid:24)T =(cid:2)(cid:17)T (cid:17) (cid:24)TT(i.e. M (cid:24)T M(cid:17) ⇔ ∃T(cid:17)(cid:17), M (cid:24)TTM(cid:17)).Theorem 2. If ◦ satisfies the weakened AGM postulates, then the mapping f defined above is a FA+.Proof. See Appendix. (cid:2)Actually, the set of FA+ associated with a revision operator satisfying the weakened AGM postulates has a lattice struc-ture, as shown by the following definition and propositions.Definition 5. Let f 1, f 2 be two FA. Let us denote f 1 (cid:15) f 2 (resp. f 1 (cid:14) f 2) the mapping that assigns to each knowledge base T ⊆ Sen the binary relation (cid:24)T =(cid:24)1TT ) where f i(T ) =(cid:24)iT (resp. (cid:24)T =(cid:24)1T for i = 1, 2.∪ (cid:24)2∩ (cid:24)2T166M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180Proposition 4. If f 1 and f 2 are FA+ for a same revision operator ◦, then so are f 1 (cid:15) f 2 and f 1 (cid:14) f 2.Proof. See Appendix. (cid:2)Proposition 5. The relation ≤ defined on FA+ by:f ≤ g ⇐⇒ ∀T ⊆ Sen, f (T ) ⊆ g(T )is a partial ordering.Given a revision operator ◦ which satisfies the weakened AGM postulates, the poset (FA+(◦), ≤) of FA+ associated with ◦ is a lattice. For any f , g ∈ FA+(◦), f (cid:15) g (respectively f (cid:14) g) is the least upper bound (respectively the greatest lower bound) of { f , g}. The lattice (FA+(◦), ≤) is further complete.Proof. The fact that the relation ≤ actually defines a partial order is straightforward. The fact that f (cid:15) g and f (cid:14) g are the least upper bound and greatest lower bound of { f , g} is also easy to show.Given a subset S ⊆ FA+(◦), its least upper bound is the mapping (cid:15)S : T (cid:23)→(cid:3)f ∈S f (T ), and its greatest lower bound is the mapping (cid:14)S : T (cid:23)→f ∈S f (T ). By extending the proof of Proposition 4, it is easy to show that (cid:15)S and (cid:14)S are FA+. (cid:2)(cid:2)3.3. Relaxation and AGM postulatesRelaxations have been introduced in [14,15] in the framework of description logics with the aim of defining dissimilarity between concepts. Here, we propose to generalize this notion in the framework of satisfaction systems.Definition 6 (Relaxation). A relaxation is a mapping ρ : Sen → Sen satisfying the following properties:Extensivity ∀ϕ ∈ Sen, Mod(ϕ) ⊆ Mod(ρ(ϕ)).Exhaustivity ∃k ∈ N, Mod(ρk(ϕ)) = Mod, where ρ0 is the identity mapping, and for all k > 0, ρk(ϕ) = ρ(ρk−1(ϕ)).Let us observe that relaxations exist if and only if the underlying satisfaction system (Sen, Mod, |=) has tautologies (i.e. formulas ϕ ∈ Sen such that Mod(ϕ) = Mod). Indeed, when the satisfaction system has tautologies, we can define the trivial relaxation ρ : ϕ (cid:23)→ ψ where ψ is any tautology.4 Conversely, all relaxations imply that the underlying satisfaction system has tautologies to satisfy the exhaustivity condition.The interest of relaxations is that they give rise to revision operators which have demonstrated their usefulness in practice (see Section 4).Notation 2. Let T ⊆ Sen be a knowledge base. Let K = {kϕ ∈ N | ϕ ∈ T }, and K(cid:17) = {k(cid:17)ϕ∈ N | ϕ ∈ T }. Let us note:(cid:4)(cid:4)• ρK(T ) = {ρkϕ (ϕ) | kϕ ∈ K, ϕ ∈ T },K =•• K ≤ K(cid:17)• K < K(cid:17)(cid:17)when for every ϕ ∈ T , kϕ ≤ kϕ ,(cid:17)if K ≤ K(cid:17)and ∃ϕ ∈ T , kϕ < kϕ .kϕ ∈K kϕ ,In this notation, kϕ is a number associated with each formula ϕ of the knowledge base (equivalently it can be considered as a function of ϕ taking values in N), which intuitively represents the degree to which ϕ is relaxed.Definition 7 (Revision based on relaxation). Let ρ be a relaxation. A revision operator over ρ is a mapping ◦ : P(Sen) ×P(Sen) → P(Sen) satisfying for every T , T(cid:17) ⊆ Sen:(cid:5)T ◦ T(cid:17) =(cid:17)ρK(T ) ∪ T(cid:17)T(cid:17)if Tis consistentotherwisefor some K = {kϕ ∈ N | ϕ ∈ T } such that:is consistent, then T ◦ Tis consistent;such that ρK(cid:17)(cid:17)(T ) ∪ T(cid:17)is consistent, (cid:4)(cid:4)K(cid:17)K ≤(minimality on the number of applications of the relax-such that Mod(T(cid:17)) ⊆ Mod(T(cid:17)(cid:17)), if T ◦ T(cid:17)(cid:17) = ρK(cid:17)(T ) ∪ T(cid:17)(cid:17), then K(cid:17) ≤ K.(cid:17)(1) if T(2) for every K(cid:17)ation);(3) for every T(cid:17)(cid:17)4 Note that most systems have tautologies. An example without tautology would be a non-complete logic where the only connective is ∨.M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180167Fig. 1. Successive relaxations of T until it becomes consistent with T(cid:17).Revision based on relaxation is illustrated in Fig. 1 where theories are represented as sets of their models. Intermediate steps to define the revision operators are then the definitions of formula and theory relaxations.It is important to note that given a relaxation ρ, several revision operators can be defined. Without Condition 3 of Definition 7, we could accept revision operators ◦ that do not satisfy Postulates (G5) and (G6). Hence, Condition 3 allows us to exclude such operators. To illustrate this, let us consider in FOL the satisfaction system R = (Sen, Mod, |=) over the signature (S, F , P ) where S = {s}, F = ∅ and P = {=: s × s}. Let us consider T , T(cid:17) ⊆ Sen such that:⎧⎪⎨⎪⎩⎧⎪⎨⎪⎩T =(cid:17) =T∃x.∃ y.(¬x = y) ∧ ∀z(z = x ∨ z = y)∃x.∃ y.∃z.(¬x = y ∧ ¬ y = z ∧ ¬x = z)∧∀w(w = x ∨ w = y ∨ w = z)∀x.x = x∀x.∀ y.x = y ⇒ y = x∀x.∀ y.∀z.x = y ∧ y = z ⇒ x = z⎫⎪⎬⎪⎭⎫⎪⎬⎪⎭(cid:17)(cid:17)Obviously, Tis consistent. As T does not contain the axioms for equality, it is also consistent. Indeed, the model M with its associated set Ms = {0, 1, 2} and the binary relation =M⊆ Ms × Ms, defined by the following set {(0, 0), (1, 1), (2, 0)}, satisfies T .But T ∪ Tis not consistent. The reason is that when the meaning of = is the equality, the first axiom of T can only be satisfied by models with two values while the second axiom is satisfied by models with three values. A way to retrieve the consistency is to remove one of the two axioms. This can be modeled by the relaxation ρ that maps each formula to a tautology.5 But in this case, we have then two options depending on whether we remove and change the first or the second axiom by a tautology, which give rise to two revision operators ◦1 and ◦2. The first two conditions of Definition 7are satisfied by both ◦1 and ◦2.(cid:17)(cid:17) = {∃x.∃ y.¬x = y} which is satisfied, when added to the axioms in T, by any model with at least (cid:17)) ∪ Ttwo elements. Hence, (T ◦1 Tare consistent. Without the third condition, nothing would prevent (cid:17)(cid:17))) by removing and change in T the second (respectively the first) axiom to define T ◦1 (Tby a tautology which would be a counter-example to Postulates (G5) and (G6). Actually, as shown by the result below, this third condition of Definition 7 entails Postulates (G5) and (G6), and then, by Proposition 3, entails Postulate (G’4).(cid:17)) ∪ T(cid:17)(cid:17)) (respectively T ◦2 (Tand (T ◦2 T(cid:17) ∪ TNow, let us take T(cid:17) ∪ T(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)However in some situations Condition 3 may be considered as too strong, forcing to relax more than what would be needed to satisfy only Condition 2. This could typically be the case when Condition 2 could be obtained in two different ways, for instance for K(cid:17) = {0, 1, 0, 0...} or for K(cid:17)(cid:17) = {1, 0, 0, 0...}. Then taking Cn(Tusing K(cid:17)would not meet Condition 3. To satisfy it, relaxation should be done for instance with K = {1, 1, 0, 0...}. and T ◦ TTherefore in concrete applications, we will have to find a compromise between Condition 3 and (G5)–(G6) at the price of potential larger relaxations on the one hand, and less relaxation but potentially the loss of (G5)–(G6) on the other hand.(cid:17)(cid:17)), and revising T ◦ T(cid:17)) = Cn(Tusing K(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)Notation 3. In the context of Definition 7, let T , TN | ϕ ∈ T }, then we note KTT= K.(cid:17)(cid:17) ⊆ Sen be two knowledge bases. If T ◦ T(cid:17) = ρK(T ) ∪ T(cid:17)with K = {kϕ ∈Theorem 3. Any revision operator ◦ based on a relaxation (Definition 7) satisfies the weakened AGM postulates.Proof. See Appendix. (cid:2)So far we showed that several FA+ can be associated with a given revision operator ◦ satisfying the weakened AGM postulates. Here, we define a particular one, which is more specific to revision operators based on relaxation. Let ρ be a relaxation and fρ be the mapping that associates to every T ⊆ Sen the binary relation (cid:24)T defined as follows:5 We will see in Section 4.3 a less trivial but more interesting relaxation in FOL that consists in changing universal quantifiers into existential ones.168M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180Given T(cid:17) ⊆ Sen, let us start by defining (cid:24)TT(cid:17)⊆ Mod(T(cid:17)) × Mod(T(cid:17)) as:(cid:5)(cid:17)M (cid:24)TTM(cid:17) ⇐⇒ ∀K(cid:17)(cid:17)≥ KT(cid:17)T , M(cid:17) ∈ Mod(ρK(cid:17)(cid:17)(T )) ⇒ ∃K(cid:17)≥ KT(cid:17)T ,andK(cid:17) < K(cid:17)(cid:17)M ∈ Mod(ρK(cid:17)(T ))Let us then set (cid:24)T =(i.e. M (cid:24)T M(cid:17) ⇔ ∃TIntuitively, it means that T has to be relaxed more to be satisfied by M(cid:17)). We have (cid:24)T ⊆ Mod × Mod because (cid:24)∅Tthan to be satisfied by M.(cid:17), M (cid:24)TTT (cid:17) (cid:24)TM(cid:17)T⊆(cid:24)T .(cid:17)(cid:2)(cid:17)Theorem 4. For any revision operator ◦ based on a relaxation ρ as defined in Definition 7, the mapping fρ is a FA+.Proof. See Appendix. (cid:2)4. ApplicationsIn this section, we illustrate our general approach by defining revision operators based on relaxations for the logicsPL, HCL, and FOL. We further develop the case of DLs in Section 4.4, by defining several concrete relaxation operators for different fragments of the DL ALC.4.1. Revision in PLHere, inspired by the work in [7,8] on Morpho-Logics, we define relaxations based on dilations from mathematical mor-phology [6]. In PL, knowing a formula is equivalent to knowing the set of its models, and we can identify any propositional formula ϕ with the set of its interpretations Mod(ϕ). To define relaxations in PL, we will apply set-theoretic morphological operations. First, let us recall a basic definition of dilation in mathematical morphology [6]. Let X and B be two subsets of Rn. The dilation of X by the structuring element B, denoted by D B ( X), is defined as follows:D B (X) = {x ∈ Rn | B x ∩ X (cid:20)= ∅}where B x denotes the translation of B at x. More generally, dilations in any space can be defined in a similar way by considering the structuring element as a binary relationship between elements of this space.6In PL, this leads to the following dilation of a formula ϕ ∈ Sen:Mod(D B (ϕ)) = {ν ∈ Mod | Bν ∩ Mod(ϕ) (cid:20)= ∅}where Bν contains all the models that satisfy some relationship with ν. The relationship standardly used is based on a discrete distance δ between models, and the most commonly used is the Hamming distance dH where dH (ν, ν(cid:17)) for two propositional models over a same signature is the number of propositional symbols that are instantiated differently in ν and ν(cid:17). From any distance δ between models, a distance from models to a formula is derived as follows: d(ν, ϕ) =minν(cid:17)|=ϕδ(ν, ν(cid:17)). In this case, we can rewrite the dilation of a formula as follows:Mod(D B (ϕ)) = {ν ∈ Mod((cid:2)) | d(ν, ϕ) ≤ 1}This consists in using the distance ball of radius 1 as structuring element B. To ensure the exhaustivity condition to our relaxation, we need to add a condition on distances, the betweenness property [14].Definition 8 (Betweenness property). Let δ be a discrete distance over a set S. δ has the betweenness property if for all x, yin S and all k in {0, 1, . . . , δ(x, y)}, there exists z in S such that δ(x, z) = k and δ(z, y) = δ(x, y) − k.The Hamming distance trivially satisfies the betweenness property. The interest for our purpose of this property is that it allows from any model to reach any other one, and then ensuring the exhaustivity property of relaxation.7Proposition 6. Let D B be a dilation applied to formulas ϕ ∈ Sen for a finite signature, and based on a distance between models that satisfies the betweenness property. Such a dilation D B is a relaxation.6 Definitions based on the notion of structuring elements are all particular cases of more general algebraic dilations, defined as operators between lattices, which commute with the supremum.7 Hence, a dilation of formulas could also be defined by using a distance ball of radius n as structuring element [7].M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180169Fig. 2. A simple example of revision based on dilation in PL (see text). (For interpretation of the references to color in this figure, the reader is referred to the web version of this article.)Proof. It is extensive. Indeed, for every ϕ and for every model ν ∈ Mod(ϕ), we have that d(ν, ϕ) = 0, and then ϕ |= D B (ϕ). Exhaustivity results from the fact that the considered signature is a finite set and from the betweenness property. (cid:2)Using Definition 7, this relaxation allows defining revision operators that include the classical Dalal’s revision as a par-ticular case (see [7,8]).A simple example is illustrated in Fig. 2. Three propositional symbols a, b and c are considered. The set of models is represented by the vertices of a cube, and we assimilate a formula formed by a simple conjunction of symbols with its corresponding model. For instance a ∧ b ∧ c is assimilated to the corresponding world, represented by the point (1, 1, 1)in the cube. The edges link two worlds differing by one instantiation of a propositional symbol, i.e. at a distance 1 for the Hamming distance. For instance vertices representing a ∧ b ∧ c and ¬a ∧ b ∧ c are linked by an edge (we have dH (a ∧ b ∧c, ¬a ∧ b ∧ c) = 1). Colored dots define ϕ and ψ : ϕ = a ∧ b ∧ c and ψ = ¬c. The red circle represents the result of the revision ϕ ◦ ψ= a ∧ b ∧ ¬c. Indeed, ϕ and ψ are inconsistent, hence we relax ϕ by a dilation of size 1 according to the Hamming distance, leading to D B (ϕ) = (a ∧ b ∧ c) ∨ (¬a ∧ b ∧ c) ∨ (a ∧ ¬b ∧ c) ∨ (a ∧ b ∧ ¬c), which is now consistent with ϕ and the conjunction provides the revision. The result here simply amounts to change the old belief which included c, by negating this atom according to the new knowledge expressed by ψ .4.2. Revision in HCLMany works have focused on belief revision involving propositional Horn formulas (cf. [12] to have an overview on these works). Here, we propose to extend relaxations that we have defined in the framework of PL to deal with the Horn fragment of propositional theories.Definition 9 (Model intersection). Given a propositional signature (cid:2) and two (cid:2)-models ν, ν(cid:17) : (cid:2) → {0, 1}, we note ν ∩ ν(cid:17) :(cid:2) → {0, 1} the (cid:2)-model defined by:1 if ν(p) = ν(cid:17)(p) = 10 otherwisep (cid:23)→(cid:13)Given a set of (cid:2)-models S, we notecl∩(S) = S ∪ {ν ∩ ν(cid:17) | ν, ν(cid:17) ∈ S}cl∩(S) is then the closure of S under intersection of positive atoms.For any set S closed under intersection of positive atoms, there exists a Horn sentence ϕ that defines S (i.e. Mod(ϕ) =S). Given a distance δ between models, we then define a relaxation ρ as follows: for every Horn formula ϕ, ρ(ϕ) is any Horn formula ϕ(cid:17)such that Mod(ϕ(cid:17)) = cl∩(Mod(D B (ϕ)) (by the previous property, we know that such a formula ϕ(cid:17)exists).Proposition 7. With the same conditions as in Proposition 6, the mapping ρ is a relaxation.Then a revision operator can be defined from ρ according to Definition 7.4.3. Revision in FOLA trivial way to define a relaxation in FOL is to map any formula to a tautology. A less trivial and more interesting relaxation is to change universal quantifiers to existential ones. Indeed, given a formula ϕ of the form ∀x.ψ , if ϕ is not consistent with a given theory T , ∃x.ψ may be consistent with T (it is quite intuitive that if it cannot be consistent for all values, it can be for some of them). A similar approach has been adopted for defining merging operators using dilations 170M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180Fig. 3. From concept relaxation and retraction to revision operators in DL.in FOL in [20]. In the following we suppose that given a signature, every formula ϕ in Sen is a disjunction of formulas is in {∀, ∃}). Let us define the relaxation ρ as in prenex form (i.e. ϕ is of the form follows, for a tautology τ :jn j .ψ j where each Qj1 . . . Qjn j xj1 xj Q(cid:14)ji• ρ(τ ) = τ ;• ρ(∃1x1 . . . ∃nxn.ϕ) = τ ;• Let ϕ = Q 1x1 . . . Q nxn.ψ be a formula such that the set Eϕ = {i, 1 ≤ i ≤ n | Q i = ∀} (cid:20)= ∅. Then, ρ(Q 1x1 . . . Q nxn.ϕ) =(cid:14)i∈Eϕ ϕi where ϕi = Q(cid:14)j1 . . . Qjn j xj1 xj Qjn j .ψ) =(cid:17)1x1 . . . Q(cid:14)• ρ(j ρ(Qj1 xj1 . . . Qjn j xjn j .ψ).(cid:17)nxn.ψ such that for every j (cid:20)= i, 1 ≤ j ≤ n, Q(cid:17)j= Q j and Q= ∃;(cid:17)iProposition 8. ρ is a relaxation.Proof. It is obviously extensive, and exhaustivity results from the fact that in a finite number of steps, we always reach the tautology τ . (cid:2)Again a revision operator can then be defined from ρ using Definition 7.4.4. Revision in DL4.4.1. General construction schemeThe instantiation of our abstract framework to DLs follows the scheme depicted in Fig. 3.The necessary ingredient is the specialization of formulas relaxations as abstractly defined in Definition 6. To this end, we propose to define a formula relaxation in two ways (other definitions may also exist). For sentences of the form C (cid:12) D, the first proposed approach consists in relaxing the set of interpretations of D, while the second one amounts to “retracting” the set of interpretations of C . We give hereafter formal definitions of these notions of concept relaxation and retraction.Definition 10 (Concept relaxation). Given a signature (NC , N R , I), we note C the set of concepts over this signature. A concept relaxation is an operator ρ : C → C that satisfies, in every model, the following properties for all C in C:(1) ρ is extensive, i.e. C (cid:12) ρ(C)(2) ρ is exhaustive, i.e. ∃k ∈ N, (cid:13) (cid:12) ρk(C)A similar notion of concept relaxation has first been introduced in [14,15] but with an additional constraint of non-decreasingness property that we do not need in this work.A trivial concept relaxation is the operation ρ(cid:13) that maps every concept C to (cid:13). Other non-trivial concrete concept relaxations will be discussed in the sequel.Definition 11 (Concept retraction). A (concept) retraction is an operator κ : C → C that satisfies, in every model, the following properties for all C in C:(1) κ is anti-extensive, i.e. κ(C) (cid:12) C , and(2) κ is exhaustive, i.e. ∀D ∈ C, ∃k ∈ N such that κ k(C) (cid:12) D.Note that in this definition, D could be replaced equivalently by ⊥.With these definitions at hand, formulas relaxation can be defined as follows, using either concept relaxation (Defini-tion 10) or concept retraction (Definition 11). We suppose that any signature (NC , N R , I) always contains in N R a relation O(cid:13) = (cid:7)O × (cid:7)Oname r(cid:13) the meaning of which is, in any model O, r.Definition 12 (Formula relaxation based on concept relaxation). Let ρ a concept relaxation as in Definition 10. A formula ρ is defined as follows, for any two complex concepts C and D, any individuals a, b, and relaxation based on ρ, denoted ρFany role r:M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180171ρρF (C (cid:12) D) ≡ C (cid:12) ρ(D),ρρF (a : C) ≡ a : ρ(C),ρρF ((cid:30)a, b(cid:31) : r)) ≡ (cid:30)a, b(cid:31) : r(cid:13).Note that the relaxation of the role assertion axiom amounts to delete it from the knowledge base, since a tautology is satisfied by any model.Proposition 9. ρρF is a formula relaxation in the sense of Definition 6.Proof. It directly follows from the extensivity and exhaustivity of ρ. (cid:2)Definition 13 (Formula relaxation based on concept retraction). A formula relaxation based on a concept retraction κ , denoted ρκF , is defined as follows, for any two complex concepts C and D, any individuals a, b, and any role r:ρκF (C (cid:12) D) ≡ κ(C) (cid:12) D,ρκF (a : C) ≡ a : (cid:13),ρκF ((cid:30)a, b(cid:31) : r)) ≡ (cid:30)a, b(cid:31) : r(cid:13).Similarly, the relaxation of the concept assertion amounts to delete it from the knowledge base.A similar construction can be found in [29] for sentences of the form (a : C).Proposition 10. ρκF is a formula relaxation in the sense of Definition 6.Proof. Extensivity and exhaustivity follow directly from the properties of κ . (cid:2)To complete the picture, it remains to define concrete concept relaxation and retraction operators for particular Descrip-tion Logics families. We consider the logic ALC, as defined in Section 2.1, and its fragments EL and ELU . EL-concept description constructors are existential restriction (∃), conjunction ((cid:14)), (cid:13) and ⊥, while ELU -concept constructors are those of EL enriched with disjunction ((cid:15)).4.4.2. Relaxation and retraction in ELEL-concept retractions. A trivial concept retraction is the operator κ⊥ that maps every concept to ⊥. Note that this operator is also particularly interesting for debugging ontologies expressed in EL [37]. Let us illustrate this operator for revision through the following example adapted from [29] to restrict the language to EL.(cid:17)(cid:17) = {Tweety (cid:14) flies (cid:12) ⊥}. Clearly T ∪ TExample 2. Let T = {Tweety (cid:12) bird, bird (cid:12) flies} and Tis inconsistent. The formula relaxation based on the retraction κ⊥ amounts to apply κ⊥ to the concept Tweety resulting in the following new knowledge base {⊥ (cid:12) bird, bird (cid:12) flies} which is now consistent with T. An alternative solution is to retract the concept bird in (cid:17)bird (cid:12) flies which results in the following knowledge base {Tweety (cid:12) bird, ⊥ (cid:12) flies} which is also consistent with T. The sets of minimal sum K1 and K2 in Condition 2 of Definition 7 are K1 = {1, 0}, (i.e. kϕ1= 0, where ϕ1 =Tweety (cid:12) bird, ϕ2 = bird (cid:12) flies) and K2 = {0, 1}. However, Condition 3 of the same definition is not satisfied: let us take (cid:17)(cid:17) =(cid:17)(cid:17) = TTρK2 (T ) ∪ T. But we do not have any ordering relation between K1 and K2. To ensure Condition 3, we must relax one more time the axioms in T leading to the following knowledge base {⊥ (cid:12) bird, ⊥ (cid:12) flies} (for K = {1, 1}). The final revision (cid:17) = {⊥ (cid:12) bird, ⊥ (cid:12) flies, Tweety (cid:14) flies (cid:12) ⊥}. This revision satisfies the weakened AGM postulates but may then writes T ◦ T(cid:17) = {⊥ (cid:12) bird, bird (cid:12) flies, Tweety (cid:14) flies (cid:12) ⊥}appear too strong, and one may prefer one of the following solutions: T ◦1 Tor T ◦2 T(cid:17) = {Tweety (cid:12) bird, ⊥ (cid:12) flies, Tweety (cid:14) flies (cid:12) ⊥} at the price of loosing (G5)–(G6).(cid:17)(cid:17)). We can then write T ◦ T. Then a fortiori we have Mod(T(cid:17)(cid:17) = ρK2 (T ) ∪ T(cid:17) = ρK1 (T ) ∪ T(cid:17)) ⊆ Mod(Tand T ◦ T= 1, kϕ2(cid:17)(cid:17)(cid:17)(cid:17)Although the results are rather intuitive, one should note that it is pretty hard to figure out what each DL researcher would like to have as a result in such an example, and this enforces the interest of relying on an established theory such as AGM or its extension. In our work we propose operators enjoying a set of properties stemming from our adaptation of the AGM theory. Some of them can meet the requirement of a knowledge engineer, and some other may not completely, depending on the context, the ontology, etc.EL-concept relaxations. Dually, a trivial relaxation is the operator ρ(cid:13) that maps every concept to (cid:13). Other non-trivial EL-concept description relaxations have been introduced in [14]. We summarize here some of these operators.172M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180EL concept descriptions can appropriately be represented as labeled trees, often called EL description trees [3]. An ELdescription tree is a tree whose nodes are labeled with sets of concept names and whose edges are labeled with role names. An EL concept descriptionC ≡ P 1 (cid:14) · · · (cid:14) P n (cid:14) ∃r1.C1 (cid:14) · · · (cid:14) ∃rm.Cm,(2)with P i ∈ NC ∪ {(cid:13)}, can be translated into a description tree by labeling the root node v 0 with {P 1, . . . , P n}, creating an r jsuccessor, and then proceeding inductively by expanding C j for the r j -successor node for all j ∈ {1, . . . , m}.An EL-concept description relaxation then amounts to apply simple tree operations. Two relaxations can hence be defined [14]: (i) ρdepth that reduces the role depth of each concept by 1, simply by pruning the description tree, and (ii) ρleaves that removes all leaves from a description tree.4.4.3. Relaxations in ELUThe relaxation defined above exploits the strong property that an EL concept description is isomorphic to a description tree. This is arguably not true for more expressive DLs. Let us try to go one step further in expressivity and consider the logic ELU . Here we only propose some definitions of relaxations. Retractions could be designed similarly. A relaxation operator, as introduced in [14], requires a concept description to be in a special normal form, called normal form with grouping of existentials, defined recursively as follows.Definition 14 (Normal form with grouping of existential restrictions). We say that an EL-concept D is written in normal form with grouping of existential restrictions if it is of the formD = (cid:14)A (cid:14) (cid:14)A∈N Dr∈N RDr,where N D ⊆ NC is a set of concept names and the concepts Dr are of the formDr = (cid:14)E∈CDr∃r.E,(3)(4)where no subsumption relation holds between two distinct conjuncts and CDrthemselves in normal form with grouping of existential restrictions.is a set of complex EL-concepts that are The purpose of Dr terms is simply to group existential restrictions that share the same role name. For an ELU -concept C we say that C is in normal form if it is of the form (C ≡ C1 (cid:15) C2 (cid:15) · · · (cid:15) Ck) and each of the Ci is an EL-concept in normal form with grouping of existential restrictions.Definition 15 (Relaxation from normal form [14]). Given an ELU -concept description C we define an operator ρe recursively as follows.• For C = (cid:13) we define ρe(C) = (cid:13).• For C = Dr , where Dr is a group of existential restrictions as in Equation (4), we need to distinguish two cases:· if Dr ≡ ∃r.(cid:13) we define ρe(Dr) = (cid:13), and· if Dr (cid:20)≡ ∃r.(cid:13) then we define ρe(Dr) = (cid:15)S⊆CDrNote that in the latter case (cid:13) /∈ CDr since Dr is in normal form.• For C = D as in Equation (3) we define ρe(D) = (cid:15)G∈CDρe(G) (cid:14) (cid:14)H∈CD \{G} H• Finally for C = C1 (cid:15) C2 (cid:15) · · · (cid:15) Ck we set ρe(C) = ρe(C1) (cid:15) ρe(C2) (cid:15) · · · (cid:15) ρe(Ck).(cid:15)(cid:14)E /∈S ∃r.E (cid:14) ∃r.ρe(cid:14)F ∈S F(cid:15)(cid:15)(cid:16)(cid:16).(cid:16), where CD = N D ∪ {Dr | r ∈ N R }.Proposition 11. [14] ρe is a relaxation.Let us illustrate this operator with an example.Example 3. Suppose an agent believes that a person Bob is married to a female judge: T = {Bob (cid:12) male (cid:14) ∃.MarriedTo.(female (cid:14) judge)}. Suppose now that due to some obscurantist law, it happens that females are not allowed to be judges. (cid:17) = {judge (cid:14) female (cid:12) ⊥}. By applying ρe one can resolve the conflict between the two belief This new belief is captured as Tsets. To ease the reading, let us rewrite the concepts as follows: A ≡ male, B ≡ female, C ≡ judge, m ≡ MarriedTo, D ≡∃MarriedTo. (female (cid:14) judge). Hence, from Definition 15 we have ρe( A (cid:14) D) ≡ (ρe( A) (cid:14) D) (cid:15) ( A (cid:14) ρe(D)), with ρe( A) ≡ (cid:13)andM. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180173ρe(D) ≡ ∃m.ρe(B (cid:14) C) (cid:15) (∃m.B (cid:14) ∃m.ρe(C)) (cid:15) (∃m.ρe(B) (cid:14) ∃m.C)≡ ∃m.(B (cid:15) C) (cid:15) (∃m.B (cid:14) ∃m.(cid:13)) (cid:15) (∃m.(cid:13) (cid:14) ∃m.C)≡ ∃m.B (cid:15) ∃m.C (cid:15) ∃m.(B (cid:15) C) ≡ ∃m.B (cid:15) ∃m.CThenρe( A (cid:14) D) ≡ (ρe( A) (cid:14) D) (cid:15) ( A (cid:14) ρe(D))≡ ((cid:13) (cid:14) D) (cid:15) ( A (cid:14) (∃m.B (cid:15) ∃m.C))≡ D (cid:15) ( A (cid:14) (∃m.B (cid:15) ∃m.C))The new agent’s belief, up to a rewriting, becomes{Bob (cid:12) ∃.MarriedTo. (female (cid:14) judge) (cid:15) (male (cid:14) (∃Married.female (cid:15) ∃Married.judge)) , judge (cid:14) female (cid:12) ⊥}.One can notice from this example that the relaxation ρe leads to a refined revision operator. Indeed, the resulting relaxed axiom in T emphasizes all the minimal possible changes (through the disjunction operator) on Bob’s condition. This is due to the fact that the relaxation operator ρe corresponds to dilating the set of models of a ball defined from an edit distance on the concept description tree of size one. For more details on the correspondence between this relaxation operator, the set of models and tree edit distances, one can refer to [14].Another possibility for defining a relaxation in ELU is obtained by exploiting the disjunction constructor by augmenting a concept description with a set of exceptions.Definition 16 (Relaxation from exceptions in ELU ). Given a set of exceptions E = {E 1, · · · , En}, we define a relaxation of degree k of an ELU -concept description C as follows: for a finite set E k ⊆ E with |E k| = k, C is relaxed by adding the sets E i j∈ E k such that E i j(cid:14) C (cid:12) ⊥E (C) = C (cid:15) E i1ρk(cid:15) · · · (cid:15) E ik .Proposition 12. ρkE is extensive.Proof. Extensivity of this operator follows directly from the definition. (cid:2)However, exhaustivity is not necessarily satisfied unless the exception set includes the (cid:13) concept, or the disjunction of some or all of its elements entails the (cid:13) concept.If we consider again Example 2, a relaxation of the formula bird (cid:12) flies using the operator ρkE over the concept flies with the ex-ception set E = {Tweety} results in the formula bird (cid:12) flies (cid:15) Tweety. The new revised knowledge base, if Condition 3 in Definition 7is not considered, is then {Tweety (cid:12) bird, bird (cid:12) flies (cid:15) Tweety, Tweety (cid:14) flies (cid:12) ⊥} which is consistent. This is obviously a more refined revision than the one obtained from the operator ρ⊥, but requires the logic to be equipped with the disjunction connective and the definition of a set of exceptions.Another example involving this relaxation will be discussed in the ALC case (cf. Example 4).4.4.4. Relaxation and retraction in ALCWe consider here operators suited to ALC language. Of course, all the operators defined for EL and ELU remain valid.ALC-concept retractions. A first possibility for defining retraction is to remove iteratively from an ALC-concept description one or a set of its subconcepts. A similar construction has been introduced in [29]. Interestingly enough, almost all the operators defined in [20,29] are relaxations.Definition 17 (Retraction from exceptions in ALC). Given a set of exceptions E = {E 1, · · · , En}, we retract any ALC-concept description C by constraining it to the elements E ci such that E i (cid:12) C :E (C) = C (cid:14) E cκ n1(cid:14) · · · (cid:14) E cn.Proposition 13. κ nE is anti-extensive.Proof. The proof follows directly from the definition. (cid:2)As for its counterpart relaxation (ρkE ), exhaustivity of κ nE is not necessarily satisfied unless the exception set includes the ⊥ concept, or the conjunction of some or all of its elements entails the ⊥ concept.174M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180Consider again Example 2. We have κ 1E (bird) = bird (cid:14) Tweetyc . The resulting revised knowledge base, if Condition 3 in Definition 7is not considered, is then {Tweety (cid:12) bird, bird (cid:14) Tweetyc (cid:12) flies, Tweety (cid:14) flies (cid:12) ⊥} which is consistent.Another possibility, suggested in [20] and related to operators defined in propositional logic as introduced in [7], consists in applying the retraction at the atomic level. This captures somehow Dalal’s idea of revision operators in propositional logic [10].Definition 18. Let C be an ALC-concept description of the form Q 1r1 · · · Q mrm.D, where Q iis a quantifier and D is quantifier-free and in CNF form,8 i.e. D = E 1 (cid:14) E 2 (cid:14) · · · En with E i being disjunctions of possibly negated atomic concepts, i.e. E i = (cid:15)k∈(cid:14)(i) Ak, where (cid:14)(i) is the index set of the atomic (possibly negated) concepts Ak forming E i . We define, as in the p (D) = (cid:14)i∈{1...n}κ(E i). Then we set κDalal(C) = Q 1r1 · · · Q mrm.κp(D).propositional case [7], κ(E i) = (cid:14)k∈(cid:14)(i) (cid:15) j∈(cid:14)(i)\{k} A j and κ nProposition 14. κ nDalal is a retraction.Proof. Exhaustivity and anti-extensivity follow from those of κp . Indeed the operator κp is exhaustive and anti-extensive, and if applied n times it reaches the ⊥ concept (see [7] for properties of this operator). (cid:2)This idea can be generalized to consider any retraction defined in ELU .Definition 19. Let C be an ALC-concept description of the form Q 1r1 · · · Q mrm.D, where Q iquantifier-free.Then we define κ∩(C) = Q 1r1 · · · Q mrm.κ nE (D).is a quantifier and D is Proposition 15. κ n∩ is anti-extensive.Proof. The properties of this operator follows from the ones of κ nexhaustivity. (cid:2)E (D). Hence, anti-extensivity is verified but not necessarily Another possible ALC-concept description retraction is obtained by substituting the existential restriction by an univer-sal one. This idea has been sketched in [20] for defining dilation operators by transforming ∀ into ∃, i.e. special relaxation operators enjoying additional properties [14], and also used for defining revision in FOL (see Section 4.3). We adapt it here, by transforming ∃ into ∀, to define retraction in DL syntax.Definition 20. Let C be an ALC-concept description of the form Q 1r1 · · · Q nrn.D, where Q i is a quantifier, D is quantifier-free, then we defineκq(C) =(cid:14){Q(cid:17)1r1 · · · Q(cid:17)nrn.D | ∃ j ≤ n s.t. Q j = ∃ and Q(cid:17)j= ∀, and for all i ≤ n s.t. i (cid:20)= j, Q(cid:17)i= Q i}Proposition 16. κq is anti-extensive.Proof. See Appendix. (cid:2)Note that for κq exhaustivity can be obtained by further removing recursively the remaining universal quantifiers and apply at the final step any retraction defined above on the concept D.ALC-concept relaxations. Let us now introduce some relaxation operators suited to ALC language.Definition 21. Let C be an ALC-concept description of the form Q 1r1 · · · Q mrm.D, where Q iis a quantifier and D is quantifier-free and in DNF form, i.e. D = E 1 (cid:15) E 2 (cid:15) · · · En with E i being a conjunction of possibly negated atomic concepts, i.e. E i = (cid:14)k∈(cid:14)(i) Ak, where (cid:14)(i) is the index set of the atomic (possibly negated) concepts Ak forming E i . We define ρ(E i) =(cid:15)k∈(cid:14)(i) (cid:14) j∈(cid:14)(i)\{k} A j and ρnp(D).p(D) = (cid:15)i∈{1...n}ρ(E i), as in the propositional case [7], and then ρnDalal(C) = Q 1r1 · · · Q mrm.ρnAs for retraction, this idea can be generalized to consider any relaxation defined in ELU .Definition 22. Let C be an ALC-concept description of the form Q 1r1 · · · Q nrn.D, where Q iquantifier-free, then we define ρn∪(C) = Q 1r1 · · · Q nrn.ρnE (D).is a quantifier and D is 8 Any concept can indeed be written in this prenex form.M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180175Let us consider another example adapted from the literature to illustrate these operators [29].Example 4. Let us consider the following knowledge bases: T = {Bob (cid:12) ∀hasChild.rich, Bob (cid:12) ∃hasChild.Mary, Mary (cid:12)(cid:17) = {Bob (cid:12) hasChild.John, John (cid:12) richc} (we consider here individuals as concepts). Relaxing the formula rich} and TBob (cid:12) ∀hasChild.rich by applying ρn∪ to the concept on the right hand side results in the following formula Bob (cid:12)∀hasChild.(rich (cid:15) John) which resolves the conflict between the two knowledge bases.A last possibility, dual to the retraction operator given in Definition 20, consists in transforming universal quantifiers into existential ones (as done for relaxation in FOL in Section 4.3).Definition 23. Let C be an ALC-concept description of the form Q 1r1 · · · Q nrn.D, where Q iquantifier-free, then we define a relaxation as:is a quantifier and D is ρq(C) =(cid:15){Q(cid:17)1r1 · · · Q(cid:17)nrn.D | ∃ j ≤ n s.t. Q j = ∀ and Q(cid:17)j= ∃, and for all i ≤ n s.t. i (cid:20)= j, Q(cid:17)i= Q i}If we consider again Example 4, relaxing the formula Bob (cid:12) ∀hasChild.rich by applying ρq to the concept on the right hand side results in the following formula Bob (cid:12) ∃hasChild.rich, which resolves the conflict between the two knowledge bases.Proposition 17. The operators ρDalal and ρq are extensive and exhaustive. The operator ρ∪ is extensive but not exhaustive.Proof. The properties of ρDalal and ρ∪ are directly derived from the definitions and from properties of ρp detailed in [7]and ρE . The proof of ρq being extensive and exhaustive can be found in [20]. (cid:2)5. Related workRecently a first generalization of AGM revision has been proposed in the framework of Tarskian logics considering mini-mality criteria on removed formulas [34] following previous works of the same authors for contraction [35]. Representation results that make a correspondence between a large family of logics containing non-classical logics such as DL and HCLand AGM postulates for revision with such minimality criteria have then been obtained. Here, the proposed generalization also gives similar representation theorems (cf. Theorem 1) but for a different minimality criterion. Indeed, we showed in Section 3.2 that revision operators satisfying the weakened AGM postulates are precisely the ones that accomplish an up-date with minimal change to the set of models of knowledge bases, generalizing the approach developed in [22] for the logic PL and [30] for DL. However, our revision operator based on relaxation also has a minimality criterion on transformed formulas. Indeed, a simple consequence of Definition 7 is the property(Relevance) Let T , T(cid:17) ⊆ Sen be two knowledge bases such that T ◦ T(cid:17)(cid:17) = ρK(T ) ∪ T(cid:17)is inconsistent for K(cid:17) = K \ {kϕ} ∪ {k(T ) ∪ TρK(cid:17). Then, for every ϕ ∈ T such that kϕ (cid:20)= 0, (cid:17)ϕ= 0}.This property states that only formulas that contribute to inconsistencies with Tare allowed to be transformed. Our property (Relevance) is similar to the property with the same name in [34,35], but for contraction operators, and that states that only the formulas that somehow “contribute” to derive the formulas to abandon can be removed.(cid:17)Since the primary aim of this paper is to show that a more general framework, encompassing different logics, can be useful, it is out of the scope of this paper to provide an overview of all existing relaxation methods. However, some works deserve to be mentioned, since they are based on ideas that show some similarity with the relaxation notion proposed in our framework.The relaxation idea originates from the work on Morpho-Logics, initially introduced in [7,8]. In this seminal work, revi-sion operators (and explanatory relations) were defined through dilation and erosion operators. These operators share some similarities with relaxation and retraction as defined in this paper. Dilation is a sup-preserving operator and erosion is inf-preserving, hence both are increasing. Some particular dilations and erosions are exhaustive and extensive while relaxation and retraction operators are defined to be exhaustive and extensive but not necessarily sup- and inf-preserving. Dilation has been further exploited for merging first-order theories in [20].In [1], the notion of partial meet contraction is defined as the intersection of a non-empty family of maximal subsets of the theory that do not imply the proposition to be eliminated. Revision is then defined from the Levi identity. The maximal subsets can also be selected according to some choice function. The authors also define a notion of partial meet revision, which can be seen as a special case of the relaxation operator introduced in this paper. In [21], the author also discusses choice functions and compares the postulates for partial meet revision to the AGM postulates. He also highlights the distinction between belief sets (which can be very large) and belief bases (which are not necessarily closed by Cn). More precisely, A is a belief base of a belief set K iff K = Cn( A). A permissive belief revision is defined in [9], based on the 176M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180notion of weakening. The beliefs which are suppressed by classical revision methods are replaced by weaker forms, which keep the resulting belief set consistent. This notion of weakening is closed to the one of relaxation developed in this paper. In the last decade, several works have studied revision operators in description logics. While most of them concentrated on the adaptation of the AGM theory, few works have addressed the definition of concrete operators [25,27–29]. For instance, in [25], based on the seminal work in [5], revision in DL is studied by defining strategies to manage inconsistencies and using the notion of knowledge integration (see also the work by Hansson). The authors propose a conjunctive maxi-adjustment, for stratified knowledge bases and lexicographic entailment. In [28], weakening operators, that are in fact relaxation operators, are defined. Our work brings a principled formal flavor to these operators. In [27], revision of ontologies in DL is based on the notion of forgetting, which is also a way to manage inconsistencies. The authors propose a model based approach, inspired by Dalal’s revision in PL, and based on a distance between terminologies and on the difference set between two are then the interpretations I for which there exists an interpretation interpretations. The models of the revision T ◦ TI(cid:17). In [24], updating Aboxes in DL is discussed, and some operators are introduced. The rationality of these operators is not discussed, hence the interest of a formal theory such as the AGM postulates. In [2] an original use of DL revision is introduced for the orchestration of processes. A closely related field is inconsistency handling in ontologies (e.g. [36,37]), with the main difference that the rationality of inconsistency repairing operators is not investigated, as suggested by the AGM theory.such that the cardinality of the difference set between I and I(cid:17)is equal to the distance between T and T(cid:17)(cid:17)As previously highlighted, some of our DL-based relaxation operators are closely related to the ones introduced in [29]for knowledge bases revision. Our relaxation-based revision framework, being abstract enough (i.e. defined through easily satisfied properties), encompasses these operators. Moreover, the revision operator defined in [29] considers only inconsis-tencies due to Abox assertions. Our operators are general in the sense that Abox assertions are handled as any formula of the language.6. ConclusionThe contribution of this paper is threefold. First, we provided a generalization of AGM postulates, in a slightly weaker form from a model-theoretic point of view, in the abstract model theory of satisfaction systems, so as they become ap-plicable to a wide class of non-classical logics. In this framework, we then generalized to any satisfaction systems the characterization of the AGM postulates given by Katsuno and Mendelzon for propositional logic in terms of minimal change with respect to an ordering among interpretations. This work generalizes the previous ones in the area. It also suggests the theory behind satisfaction systems to be a principled framework for dealing with knowledge dynamics with the growing interest on non-classical logics such as DL. We do hope that bridges can thus be built, by working at the cross-road of different areas of theoretical computer science.Secondly, we proposed a general framework for defining revision operators based on the notion of relaxation. We demon-strated that such a relaxation-based framework for belief revision satisfies the weakened AGM postulates. As a byproduct, we give a principled formal flavor to several operators defined in the literature (e.g. weakening operators defined in DL).Thirdly, we introduced a number of concrete relaxations within the scope of description logics, discussed their properties and illustrated them through simple examples. It was out of the scope of this paper to discuss languages such as OWL. However, the proposed approach could be applied to SROIQ and implemented in OWL, by augmenting a relaxation with operations on complex constructors.Future works will concern the study of the complexity of the introduced operators, the comparison of their induced ordering, and their generalization to more expressive DL as well as other non-classical logics such as first-order Horn logics or equational logics.Finally, there is an extension of satisfaction systems that takes into account explicitly the notion of signatures, the theory of institutions [19], a categorical model theory which has emerged in computing science studies of software specifications and semantics. In this paper, as we have considered logical theories over a same signature, signature morphisms and their interpretation for model classes and sentence sets were not relevant. However, these results carry over to institutions, which are indexed satisfaction systems.Appendix. Proofs of the main resultsProof of Proposition 3. Let us suppose that Cn(T(cid:17)1) = Cn(T(cid:17)2). Here, three cases have to be considered:(1) One of T(2) Both T ∪ T(cid:17)1 and T(cid:17)2 is inconsistent (say T(cid:17)(cid:17)1) = Cn(T1 without loss of generality). Since Cn(T(cid:17)(cid:17)i ) ⊆ Mod(Ti ), and Mod(T(cid:17)2) by hypothesis, T(cid:17)2 is also (cid:17)i ) = T ri v (Corollary 1). inconsistent. By Postulate (G2), we then have that, for i = 1, 2, Mod(T ◦ THence Mod(T ◦ T(cid:17)i ) ⊆ T ri v, and Mod(T ◦ T(cid:17)(cid:17)1 and T ∪ T1 are consistent. Since Cn(T(cid:17)1) = Mod(T ∪ Tthen Mod(T ∪ T(cid:17)(cid:17)(cid:17)(cid:17)2 is not (say T ∪ T1 or T ∪ T2 are consistent but T ∪ T1 and T(cid:17)also inconsistent. By Postulate (G1), both T ◦ T1 and T ◦ Tobviously M ∈ Mod(T ◦ T(cid:17)M ∈ Mod(T(cid:17)1) = Mod(T ◦ T2). Let M(cid:17) ∈ Mod(T ◦ T(cid:17)2) \ T ri v. Such a model exists as T ◦ T(cid:17)1) = Mod(T(cid:17)2). Therefore, by Postulate (G3), we have that Mod(T ◦ T(cid:17)1) = Cn(T(cid:17)2) = T ri v.(cid:17)2), we know that Mod(T(cid:17)2 are consistent. Let M ∈ Mod(T ◦ T(cid:17)1) = Cn(T(cid:17)1) = Mod(T ◦ T(cid:17)2).(cid:17)2), we derive that T ∪ T(cid:17)2 is (cid:17)1). If M ∈ T ri v, then (cid:17)1), and then (cid:17)2 is consistent. By Postulate (G2) and the (cid:17)2). Therefore, let us suppose that M /∈ T ri v. By Postulate (G2), M ∈ Mod(T(cid:17)2) (Equation (1)), and (cid:17)1). From Cn(T(3) TM. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180177(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)1) = Cn(T2. Obviously, we have that (T ◦ T1 and Tare consistent. Therefore, by Postulates (G5) and (G6), we have that Mod((T ◦ T2), {M, M(cid:17)}∗∪ {M, M(cid:17)}∗) = Mod(T ◦ {M, M(cid:17)}∗) and Mod((T ◦ Thypothesis that Cn(T(cid:17)2) ∪ {M, M(cid:17)}∗(T ◦ TMod((T ◦ (T{M, M(cid:17)}∗). We can then derive that Mod((T ◦ T(cid:17)Mod(T ◦ T2). Similarly, by reversing the roles of Tcontains both T(cid:17)1(cid:17)1) ∪ {M, M(cid:17)}∗) = Mod((T ◦ T(cid:17)1 and T(cid:17)2, if M ∈ Mod(T ◦ T1) ∪ {M, M(cid:17)}∗and 1) ∪ {M, M(cid:17)}∗) =∪ {M, M(cid:17)}∗) = Mod(T ◦2) ∪ {M, M(cid:17)}∗), and conclude that M ∈(cid:17)1).(cid:17)2), we can conclude that M ∈ Mod(T ◦ T(cid:17)2(cid:17)(cid:17)(cid:17)2) ∪ {M, M(cid:17)}∗) = Mod((T ◦ (TProof of Theorem 1.(1) Let us suppose that ◦ satisfies AGM Postulates. For every knowledge base T , let us define the binary relation (cid:24)T ⊆Mod × Mod by: for all M, M(cid:17) ∈ Mod,(cid:5)M (cid:24)T M(cid:17)iffeither M ∈ Mod(T )or M ∈ Mod(T ◦ {M, M(cid:17)}∗) and M(cid:17) /∈T ri vLet us first show that (cid:24)T satisfies the two conditions of FA.• The first condition easily follows from the definition of (cid:24)T .• To prove the second one, let us assume that M ∈ Mod(T ) and M(cid:17) /∈ Mod(T ). Since M ∈ Mod(T ), we have M (cid:24)T M(cid:17). is consistent since M ∈ Mod(T ) \ T ri v and M ∈ Mod(M∗) ⊆ Mod({M, M(cid:17)}∗). . Therefore, we have that M(cid:17) /∈Mod(T ◦Here two cases have to be considered:(a) M ∈ T ri v. In this case, we directly have by definition that M(cid:17) (cid:2)T M.(b) M /∈ T ri v. Then T ∪ {M, M(cid:17)}∗Hence M ≺T M(cid:17)Then by Postulate (G3), we have that T ◦ {M, M(cid:17)}∗ = T ∪ {M, M(cid:17)}∗{M, M(cid:17)}∗), and M(cid:17) (cid:2)T M.in both cases.Let us now prove the three supplementary conditions.• First, let us show that Mod(T ◦ TT ri v = ∅, and by (G2) Mod(T ◦ TLet us assume now that T· Let us first show that Mod(T ◦ T(cid:17)) \ T ri v, (cid:24)T ). If T(cid:17)) ⊆ T ri v, hence Mod(T ◦ T(cid:17)) = Min(Mod(T(cid:17)) ⊆ Mod(Tis consistent.(cid:17)) \ T ri v ⊆ Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ). By (G2), M ∈ Mod(Tthat M /∈ Min(Mod(Tsuch that M(cid:17) ≺T M. Here, two cases have to be considered:(a) M(cid:17) ∈ Mod(T ). As M(cid:17) ∈ Mod(T(cid:17)) \ T ri v, then T ∪ T(cid:17)(cid:17)(cid:17)M ∈ Mod(T ), and then M (cid:24)T M(cid:17), which is a contradiction.is inconsistent, then by Proposition 2 Mod(T(cid:17)) \ T ri v = ∅ = Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ).(cid:17)) \(cid:17)) \ T ri v, (cid:24)T ). Let M ∈ Mod(T ◦ T(cid:17)) \ T ri v. By hypothesis, there exists M(cid:17) ∈ Mod(T(cid:17)) \ T ri v. Let us assume (cid:17)) \ T ri vis consistent, and then by (G3), T ◦ T(cid:17) = T ∪ T(cid:17). Thus, (b) M(cid:17) /∈ Mod(T ). By definition of (cid:24)T , this means that M(cid:17) ∈ Mod(T ◦ {M, M(cid:17)}∗). As M, M(cid:17) ∈ Mod(TPostulate (G2), (T ◦ TMod(T ◦ {M, M(cid:17)}∗) = Mod((T ◦ TM /∈ Mod(T ◦ {M, M(cid:17)}∗), whence by Postulate (G6) we have that M /∈ Mod(T ◦ Ttradiction.(cid:17)), by is consistent, and then by Postulates (G5) and (G6), we have that (cid:17)) ∪ {M, M(cid:17)}∗). By the hypothesis that M(cid:17) ≺T M, we can deduce that (cid:17)) \ T ri v, which is a con-(cid:17)) ∪ {M, M(cid:17)}∗· Let us now show that Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ), and then Mod(T ◦ TFinally we can conclude that M ∈ Min(Mod(T(cid:17)) \ T ri v. As T(cid:17)assume that M /∈ Mod(T ◦ Tsuch that M(cid:17)∗ (cid:20)= Sen, and M(cid:17) ∈ Mod(TMod({M, M(cid:17)}∗). By Postulates (G5) and (G6), we can write Mod(T ◦ Tsince (T ◦ Tdiction. We can conclude that M ∈ Mod(T ◦ T(cid:17)) \ T ri v, (cid:24)T ).(cid:17)) \ T ri v, (cid:24)T ). Let us (cid:17))(cid:17) ∪ {M, M(cid:17)}∗) =(cid:17)) ∩ Mod({M, M(cid:17)}∗) = Mod(T ◦ {M, M(cid:17)}∗), is consistent. Hence, M /∈ Mod(T ◦ {M, M(cid:17)}∗), and then M(cid:17) ≺T M, which is a contra-(cid:17)) \ T ri v. Let M ∈ Min(Mod(Tis consistent, by Postulates (G1) and (G2), there exists M(cid:17) ∈ Mod(T ◦ T(cid:17)). Since T(cid:17)) \ T ri v, (cid:24)T ) ⊆ Mod(T ◦ T, we also have that Mod(T(cid:17)) \ T ri v ⊆ Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ) ⊆ Mod(T ◦ T(cid:17)) ∪ {M, M(cid:17)}∗(cid:17) ⊆ {M, M(cid:17)}∗(cid:17)) \ T ri v.(cid:17)) \ T ri v, and then Min(Mod(T(cid:17)(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅ if T(cid:17)) \ T ri v (cid:20)= ∅. We can directly conclude by the previous point that Min(Mod(T(cid:17)is consistent. By Postulate (G1), we have that T ◦ T(cid:17)) \• Secondly, let us show that Min(Mod(Tis consistent, and then Mod(T ◦ TT ri v, (cid:24)T ) (cid:20)= ∅.• Finally, let us show that for every T(cid:17)) ∪ Tif (T ◦ Tthe first point, we can directly conclude that Min(Mod(Tis consistent. By (G5) and (G6), we have that Mod(T ◦ (T(cid:17) ∪ T(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T(cid:17)(cid:17))) = Mod((T ◦ T(cid:17)(cid:17)) = Min(Mod(T(cid:17)) ∪ T(cid:17) ∪ T(cid:17)(cid:17)(cid:17), T(cid:17)(cid:17) ⊆ Sen, Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T(cid:17)(cid:17)) = Min(Mod(T(cid:17) ∪ T(cid:17)(cid:17)) \ T ri v, (cid:24)T )(cid:17)(cid:17)). Therefore, by (cid:17)(cid:17)) \ T ri v, (cid:24)T ).(2) Let us now suppose that for a revision operation ◦ there exists a FA which maps any knowledge base T ⊆ Sen to a binary relation (cid:24)T ⊆ Mod × Mod satisfying the three conditions of Theorem 1. Let us prove that ◦ verifies the AGM Postulates.(G1) This postulate directly results from the fact that Min(Mod(Tis consistent, hence Mod(T ◦(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅ when T(cid:17)(cid:17)). If M ∈ T ri v, then obviously M ∈ Mod(T(cid:17)). Now, if M /∈ T ri v, then by definition, M ∈T(cid:17)) \ T ri v (cid:20)= ∅.(G2) Let M ∈ Mod(T ◦ TMin(Mod(T(G3) Suppose that T ∪ T(cid:17)(cid:17)) \ T ri v, (cid:24)T ). This means that M ∈ Mod(T(cid:17)).is consistent (hence Mod(T ∪ T(cid:17)) \ T ri v (cid:20)= ∅).• Let us first prove that Mod(T ◦ T(cid:17)) ⊆ Mod(T ∪ T(a) M ∈ T ri v. In this case, we obviously have that M ∈ Mod(T ∪ T(cid:17)). Let M ∈ Mod(T ◦ T(cid:17)).(cid:17)). Here two cases have to be considered:178M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180(b) M /∈ T ri v. By definition, M ∈ Min(Mod(T(cid:17)). Let us sup-pose now that M /∈Mod(T ). As T is consistent, Mod(T ) \ T ri v (cid:20)= ∅ by Proposition 2. Therefore, there exists M(cid:17) ∈ Mod(T ) \ T ri v such that M(cid:17) ≺T M (from M /∈ Mod(T ) and the second property of FA), which is a contradiction. Hence M ∈ Mod(T ) and M ∈ Mod(T ∪ T(cid:17)) \ T ri v, (cid:24)T ). Hence, we have that M ∈ Mod(T• Let us now prove that Mod(T ∪ T(cid:17)). Therefore, M ∈ Mod(T ). By hypothesis, there exists M(cid:17) ∈ Mod(T(cid:17)) \T ri v, (cid:24)T )), and then M(cid:17) /∈Mod(T ) by the first condition of FA. However, by the second condition of FA, we have that M ≺T M(cid:17)(cid:17)) \ T ri v such that M(cid:17) ≺T M (since M /∈ Min(Mod(T(cid:17)) such that M /∈Mod(T ◦ T, which is a contradiction.(cid:17)) ⊆ Mod(T ◦ T(cid:17)).(cid:17)). Let M ∈ Mod(T ∪ TFinally, we can conclude that Mod(T ◦ T(G5) Let M ∈ Mod(T ◦ T(cid:17)) ∩ Mod(Tor there exists M(cid:17) ∈ Mod(Tthat M ∈ Mod(T ◦ (TM ∈ Min(Mod(T(cid:17) ∪ T(G6) Let us suppose that (T ◦ T(cid:17)) = Mod(T ∪ T(cid:17)(cid:17)). Let us assume that M /∈Min(Mod(T(cid:17) ∪ T(cid:17)(cid:17)) \ T ri v, (cid:24)T ). This means that M ∈ T ri v(cid:17)(cid:17)) such that M(cid:17)∗ (cid:20)= Sen and M(cid:17) ≺T M. In the first case, we obviously have (cid:17)), and then M(cid:17)⊀T M since (cid:17)(cid:17))). In the second case, we then have that M(cid:17) ∈ Mod(T(cid:17) ∪ T(cid:17)).(cid:17)) \ T ri v, (cid:24)T ), which is a contradiction.(cid:17)) ∪ T(cid:17)(cid:17)is consistent. Let M ∈ Mod(T ◦ (Tthis case, obviously we have that M ∈ Mod((T ◦ T(cid:17)(cid:17)))\T ri v = Min(Mod(TT(cid:24)T ) = Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ) ∩ Mod(T(cid:17)(cid:17)) \ T ri v, (cid:24)T ). As (T ◦ T(cid:17)) ∪ T(cid:17)(cid:17)) and then M ∈ Mod((T ◦ T(cid:17) ∪ T(cid:17)) ∪ T(cid:17)) ∪ T(cid:17)(cid:17)).(cid:17) ∪ T(cid:17)(cid:17)), or M ∈ Min(Mod(T(cid:17) ∪ Tis consistent, we have that Min(Mod(T(cid:17)(cid:17))). By hypothesis, either M ∈ T ri v and in (cid:17) ∪(cid:17)(cid:17)) \ T ri v,(cid:17)(cid:17)) \ T ri v, (cid:24)T ) as Mod(T ◦ (T(cid:17) ∪ T(cid:17)(cid:17)Proof of Theorem 2. First, let us show that fis a FA.Mod(TT ◦ T• Let M, M(cid:17) ∈ Mod(T ). Let us suppose that M ≺T M(cid:17)(cid:17)), M ∈ Mod(T ◦ T(cid:17)) and M(cid:17) /∈ Mod(T ◦ T(cid:17)(cid:17) = T ∪ T. We then have that M(cid:17) ∈ Mod(T ◦ T• Let M ∈ Mod(T ) and let M(cid:17) ∈ Mod \ Mod(T ). We have that M (cid:24)∅let us suppose that M(cid:17) (cid:24)T M. This means that there exists T(cid:17)). But, as M ∈ Mod(T ), we have that T ∪ T(cid:17)and M /∈ Mod(T ◦ T(cid:17)) which is a contradiction.Hence, we have that M ∈ Mod(T ◦ T(cid:17)). Hence we have that T ∪ T(cid:17)(cid:17)) which is a contradiction.. This means that there exists T(cid:17) ⊆ Sen such that M, M(cid:17) ∈is consistent, and then by Postulate (G3), TM(cid:17), and then M (cid:24)T M(cid:17)(cid:17) ⊆ Sen such that M, M(cid:17) ∈ Mod(Tis consistent, and then by Postulate (G3), T ◦ Tby definition of (cid:24)T . Now, (cid:17))(cid:17)), M(cid:17) ∈ Mod(T ◦ T(cid:17)(cid:17) = T ∪ T. Let us show now the supplementary conditions of Theorem 1.• First, let us show that Mod(T ◦ T(cid:17)) \ T ri v = Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ). The case where T(cid:17)is inconsistent follows the same (cid:17)(cid:17)), M(cid:17) ∈ Mod(T ◦ Tis consistent. Let M ∈ Mod(T ◦ Tproof as in Theorem 1.(cid:17)Let us suppose that TThis means that there exists M(cid:17) ∈ Mod(TM, M(cid:17) ∈ Mod(Tand then by Postulates (G5) and (G6), Mod((T ◦ T(cid:17)(cid:17)) which is a contradiction.that M ∈ Mod(T ◦ T(cid:17)) \ T ri v, (cid:24)T ). Let us suppose that M /∈ Mod(T ◦ TLet M ∈ Min(Mod(Tand (G2), there exists M(cid:17) ∈ Mod(T ◦ Twhich is a contradiction.(cid:17)) \ T ri v. By definition of (cid:24)T(cid:17)(cid:17)) and M /∈ Mod(T ◦ T(cid:17)(cid:17)) = Mod((T ◦ T(cid:17)) ∪ T• The proof of the two other conditions corresponds to the one given in Theorem 1.(cid:17)) \ T ri v. Let us suppose that M /∈ Min(Mod(T(cid:17)) \ T ri v such that M(cid:17) ≺T M. Therefore, there exists T(cid:17)(cid:17)). Hence, both (T ◦ T(cid:17)(cid:17)(cid:17)) ∪ T(cid:17)) = Mod(T ◦ (Tand (T ◦ T(cid:17) ∪ T(cid:17)(cid:17)) ∪ T(cid:17)) \ T ri v, (cid:24)T ). (cid:17)(cid:17) ⊆ Sen such that are consistent, (cid:17)(cid:17))). We can then derive (cid:17)(cid:17)) ∪ T(cid:17)(cid:17)) \ T ri v. As TT , we have that M(cid:17) (cid:24)Tis consistent, by Postulates (G1) M, and then M(cid:17) (cid:24)T MT(cid:17)(cid:17)(cid:17)Proof of Proposition 4. It is sufficient to show that (cid:24)1Tall the conditions of Theorem 1.∪ (cid:24)2T and (cid:24)1T∩ (cid:24)2T satisfy Conditions (1) and (2) of Definition 4 plus Let us first show that they are FA. Let T ⊆ Sen. Let M, M(cid:17) ∈ Mod(T ). By definition of FA, then we have either M(cid:2)iTM(cid:17)M for i = 1, 2. We then have four cases to consider, but for f 1 (cid:14) f 2(T ) =(cid:24)T (resp. and M(cid:17) (cid:24)T M. Likewise, for every for i = 1, 2. Therefore, it is obvious to conclude that and M(cid:17)(cid:2)T M or M (cid:24)T M(cid:17)M(cid:17)M(cid:17)M or M (cid:24)iTand M(cid:17)(cid:2)iTf 1 (cid:15) f 2(T ) =(cid:24)T ), we always end up at either M(cid:2)T M(cid:17)M ∈ Mod(T ) and every M(cid:17) ∈ Mod \ Mod(T ), we have that M ≺iTM ≺T M(cid:17)and M(cid:17) (cid:24)iT.Now, by the first supplementary condition for (cid:24)1T ) = Mod(T ◦ TT ri v, (cid:24)1Min(Mod(Tforward, and this allows us to directly conclude that f 1 (cid:15) f 2 and f 1 (cid:14) f 2 are FA+.T ) = Min(Mod(T(cid:17)) \ T ri v, (cid:24)1TT and (cid:24)2T in Theorem 1, we have for every T(cid:17)) \ T ri v. Hence, we can write that Min(Mod(T(cid:17)) \T ) =T ) for i = 1, 2. The three supplementary conditions are then straight-(cid:17) ⊆ Sen that Min(Mod(T(cid:17)) \ T ri v, (cid:24)1∪ (cid:24)2T(cid:17)) \ T ri v, (cid:24)2∩ (cid:24)2T ) = Min(Mod(T(cid:17)) \ T ri v, (cid:24)iProof of Theorem 3. ◦ obviously satisfies Postulates (G1), (G2) and (G3). To prove (G5)–(G6), let us suppose T , Tsuch that (T ◦ Tis consistent. Now, obviously we have that Mod(TDefinition 7, we necessarily have that T ◦ (T(cid:17)(cid:17) ⊆ Sen(cid:17)(cid:17)(cid:17) ∪ T(cid:17)). Hence, by the second and the third conditions of (cid:17)(cid:17))).(cid:17)) ∪ T(cid:17)(cid:17)is consistent (the case where (T ◦ T(cid:17) ∪ T(cid:17)(cid:17)) = ρKTis inconsistent is obvious). This means that ρKT(cid:17)) ∪ T(cid:17)(cid:17)(cid:17)(cid:17)) ⊆ Mod(T(cid:17) ∪ TT (T ) ∪ T, and then Mod((T ◦ T(cid:17), TT (T ) ∪ T(cid:17)(cid:17)) = Mod(T ◦ (T(cid:17)) ∪ T(cid:17) ∪ T(cid:17) ∪ T(cid:17)(cid:17)(cid:17)(cid:17)Proof of Theorem 4. Let T ⊆ Sen. Let us first show that fρ (T ) = (cid:24)T is faithful.M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180179• Obviously, we have for every M, M(cid:17) ∈ Mod(T ) and every T(cid:17) ⊆ Sen that both M(cid:2)TT(cid:17)M(cid:17)and M(cid:17)(cid:2)TT(cid:17)M. Hence the same relations hold for (cid:24)T .• Let M ∈ Mod(T ) and let M(cid:17) ∈ Mod \ Mod(T ). Obviously, we have that M (cid:24)∅M(cid:17). Let TT(cid:17)) (the case where for all T(cid:17) ⊆ Sen M or M(cid:17)Mod(T(cid:17)T , and then we directly have that M(cid:17)(cid:2)T M). Here two cases have to be considered:(cid:24)T(1) M ∈ T ri v. As M(cid:17) /∈Mod(T ), then M(cid:17) /∈T ri v. Hence, there does not exist K(cid:17) < K such that M(cid:17) ∈ Mod(ρK(cid:17)(cid:17).would be consistent, which would contradict the hypothesis that T ◦ T(cid:17)) implies that M and M(cid:17)Otherwise, ρK(cid:17)(cid:17) = ρK(T ) ∪ Tis not in Mod(T(cid:17)(cid:17) ⊆ Sen such that M, M(cid:17) ∈are incomparable by (T )). (cid:17)) but M(cid:17) /∈Mod(T ∪ T(cid:17)), and then M(cid:17)(cid:2)TT(cid:17)M By definition of ◦.(T ) ∪ T(2) M /∈T ri v. We have that M ∈ Mod(T ∪ THence, in both cases we can conclude that M(cid:17)(cid:2)T M.Let us prove that Mod(T ◦ Twhen TT ri v, (cid:24)T ) (cid:20)= ∅ if Mod(T ◦ T(cid:17)(cid:17)is consistent. Indeed, by definition, we have that T ◦ T(cid:17)) \ T ri v, (cid:24)T ).by definition. Hence, Mod(T ◦ T(cid:17)) \ T ri v = Min(Mod(T(cid:17)is inconsistent, then so is T ◦ T(cid:17)If TLet us now suppose that T(cid:17)is consistent.(cid:17)) \ T ri v = Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ). This will directly prove that Min(Mod(Tis consistent when Tis consistent, and then Min(Mod(T(cid:17)(cid:17)) \ T ri v, (cid:24)T ) (cid:20)= ∅(cid:17)) \(cid:17)) \ T ri v = Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ) = ∅.• Let us show that Mod(T ◦ T(cid:17)) \ T ri v ⊆ Min(Mod(T(cid:17)) \ T ri v, (cid:24)T ). Let M ∈ Mod(T ◦ T(cid:17)) \ T ri v. Let M(cid:17) ∈ Mod(T(cid:17)) \ T ri v. Two cases have to be considered:(1) M(cid:17) ∈ Mod(T ◦ T(cid:17)(cid:17) = T ◦ (T(cid:17)(cid:17) ⊆ Sen such that M, M(cid:17) ∈ Mod(TTpothesis, we then have that (T ◦ T(cid:17)) ∪ Tthat (T ◦ T(cid:17)(cid:17)) ⊆ Mod(T(cid:17) ∪ TMod(Tdeduce that there exists K(cid:17)(cid:17) < KTthen by Condition 2 of Definition 7, (cid:17)). By definition of (cid:24)T(cid:17) ∪ T(cid:17)(2) M(cid:17) /∈Mod(T ◦ TFinally, we can conclude that M ∈ Min(Mod(T(cid:17)(cid:17)(cid:17)). Obviously, we have both M(cid:2)TTM(cid:17)and M(cid:17)(cid:2)TT(cid:17)) ∪ T(cid:17)(cid:17)). Let us suppose that there exists TM. Let us show that this is also true for every M. By hy-is consistent. Therefore, by Conditions 2 and 3 of Definition 7, we have (cid:17)(cid:17)) = ρKT. Consequently, as M, we can ≤ KTis consistent, and (T )). We then have that ρK(cid:17)(cid:17)(cid:17)(cid:17) ⊆ Sen such that M(cid:17) (cid:24)TTT . Therefore, as M(cid:17) (cid:24)T(cid:17)(cid:17)). Hence, we also have that T ◦ (T(cid:17) ∪ T(cid:17)(cid:17)), we have by Condition 3 of Definition 7 that KTTT such that M(cid:17) ∈ Mod(ρK(cid:17)(cid:17)(cid:4)T (T ) ∪ T(T ) ∪ T(cid:17) ∪ T(cid:4)(cid:17)(cid:17)(cid:17)(cid:17)T(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)KTT≤K(cid:17)(cid:17), which is a contradiction.(cid:17)M(cid:17), and therefore M (cid:24)T M(cid:17).T , we have that M (cid:24)TT(cid:17)) \ T ri v, (cid:24)T ).(cid:17)) \ T ri v, (cid:24)T ) ⊆ Mod(T ◦ T(cid:17)is consistent, then so is T ◦ T• Let us now show that Min(Mod(T(cid:17)) \ T ri v. As T(cid:17)) \ T ri v. Let M ∈ Min(Mod(T(cid:17). Hence, there exists M(cid:17) ∈ Mod(T ◦ T(cid:17)) \ Mod(T ◦ T(cid:17)), we have that M(cid:17) (cid:24)TT(cid:17)M, and then as M ∈ Min(Mod(T. This means that there exists T(cid:17)(cid:17)(cid:17)) ∪ T(cid:17)(cid:17) ⊆ Sen such that M, M(cid:17) ∈ Mod(T(cid:17)(cid:17)) and M (cid:24)TTis consistent. Therefore, by Conditions 2 and 3 of Definition 7, we have that (T ◦ T(cid:17)(cid:17)). Hence, we also have that T ◦ (T(cid:17) ∪ T(cid:17)(cid:17)) = ρKT≤ KT(cid:17)T . Hence, there exists K(cid:17)(cid:17) ≥ KTTis consistent, and then by Condition 2 of Definition 7 we have that (cid:17). Consequently, we have by Condition 3 of T and M ∈ Mod(ρK(cid:17)(cid:17)(T )). We can then (cid:4)≤, which is a K(cid:17)(cid:17)(cid:4)(cid:17)(cid:17) ∪ TT (T ) ∪ Tsuch that K(cid:17)(cid:17) < KT(cid:17)(cid:17)(cid:17)(cid:17)(cid:17)KTT(cid:17)(cid:17)) \ T ri v, (cid:24)T ). Let us suppose (cid:17)) \ T ri v. As (cid:17)) \ T ri v, (cid:24)T ) we also have that . By hypothesis, we (cid:17)(cid:17) =M(cid:17)(cid:17)(cid:17)(cid:17)) ∪ Tthat M /∈Mod(T ◦ TM ∈ Mod(TM (cid:24)T M(cid:17)then have that (T ◦ TT ◦ (TDefinition 7 that KTTdeduce that ρK(cid:17)(cid:17)(T ) ∪ Tcontradiction.(cid:17) ∪ T(cid:17)(cid:17)Finally, to prove the last point, we follow the same steps as in the proof of Theorem 1.Proof of Proposition 15. The proof relies on the following general result:∀C, ∀r, ∀r.C (cid:12) ∃r.CIndeed, for each interpretation I, if rIi(cid:20)= ∅, we havex ∈ (∀r.C)I ⇒ (∀ y, (x, y) ∈ rI ) ⇒ (∃ y, (x, y) ∈ rIand y ∈ CI ) ⇒ x ∈ (∃r.C)I .Hence (∀r.C)I ⊆ (∃r.C)Ifor each I (if r= ∅ it is obvious), and ∀r.C (cid:12) ∃r.C .In a similar way, we can show, that for any C1, C2, r, and Q ∈ {∃, ∀}:I ⇒ y ∈ CIiC1 (cid:12) C2 ⇒ Q r.C1 (cid:12) Q r.C2.Now, let us consider any j such that Q j = ∃, and set C(cid:17) = Q j+1r j+1...Q nrn.D. We have from the first result QQ jr j.C. Applying the second result recursively on each Q i for i < j, we then have(cid:17)(cid:17)jr j.C(cid:17) (cid:12)Q 1r1...Q j−1r j−1 Q(cid:17)jr j.C(cid:17) (cid:12) Q 1r1...Q j−1r j−1 Q jr j.C(cid:17).The same relation holds for the conjunction over any j such that Q j = ∃, from which we conclude that ∀C, κq(C) (cid:12) C , i.e. κq is anti-extensive.180M. Aiguier et al. / Artificial Intelligence 256 (2018) 160–180ReferencesLogics, 2013, pp. 501–512.(2004) 339–371.Verlag, 2007, pp. 857–947.[1] C. Alchourron, P. Gardenfors, D. Makinson, On the logic of theory change, J. Symb. Log. 50 (2) (1985) 510–530.[2] S. Autexier, D. Hutter, Constructive DL update and reasoning for modeling and executing the orchestration of heterogeneous processes, in: Description [3] F. Baader, R. Küsters, R. Molitor, Computing least common subsumers in description logics with existential restrictions, in: International Joint Conference on Artificial Intelligence, IJCAI’99, Morgan-Kaufmann, 1999, pp. 96–101.[4] J. Barwise, Axioms for abstract model theory, Ann. Math. Log. 7 (1974) 221–265.[5] S. Benferhat, S. Kaci, D. Le Berre, M.-A. Williams, Weakening conflicting information for iterated revision and knowledge integration, Artif. Intell. 153 (1) [6] I. Bloch, H. Heijmans, C. Ronse, Mathematical morphology, in: M. Aiello, I. Pratt-Hartman, J. van Benthem (Eds.), Handbook of Spatial Logics, Springer-[7] I. Bloch, J. Lang, Towards mathematical morpho-logics, in: B. Bouchon-Meunier, J. Gutierrez-Rios, L. Magdalena, R. Yager (Eds.), Technologies for Con-[8] I. Bloch, R. Pino-Pérez, C. Uzcategui, A unified treatment of knowledge dynamics, in: International Conference on Principles of Knowledge Representa-structing Intelligent Systems, Springer-Verlag, 2002, pp. 367–380.tion and Reasoning, KR, AAAI Press, 2004, pp. 329–337.[9] M.R. Cravo, J.P. Cachopo, A.C. Cachopo, J.P. Martins, Permissive belief revision, in: Portuguese Conference on Artificial Intelligence, in: Lect. Notes Artif. [10] M. Dalal, Investigations into a theory of knowledge base revision: preliminary report, in: Association for the Advancement of Artificial Intelligence, [11] J.-P. Delgrande, P. Peppas, Revising Horn theories, in: T. Walsh (Ed.), 22nd International Joint Conference on Artificial Intelligence, IJCAI, IJCAI/AAAI, [12] J.-P. Delgrande, P. Peppas, Belief revision in Horn theories, Artif. Intell. 218 (2015) 1–22.[13] R. Diaconescu, Institution-Independent Model Theory, Universal Logic, Birkhäuser, 2008.[14] F. Distel, J. Atif, I. Bloch, Concept dissimilarity on tree edit distance and morphological dilatations, in: European Conference on Artificial Intelligence, Intell., vol. 2258, 2001, pp. 335–348.AAAI’88, 1988, pp. 475–479.2011, pp. 839–844.ECAI, 2014, pp. 249–254.[15] F. Distel, J. Atif, I. Bloch, Concept dissimilarity with triangle inequality, in: C. Baral, G.D. Giacomo, T. Eiter (Eds.), Fourteenth International Conference on Principles of Knowledge Representation and Reasoning, KR, AAAI Press, 2014, pp. 614–617.[16] G. Flouris, Z. Huang, J. Pan, D. Plexousakis, H. Wache, Inconsistencies, negations and changes in ontologies, in: 21st AAAI National Conference on [17] G. Flouris, D. Plexousakis, G. Antoniou, On applying the AGM theory to DLs and OWL, in: The Semantic Web—ISWC 2005, in: Lect. Notes Comput. Sci., Artificial Intelligence, 2006, pp. 1295–1300.vol. 5341, Springer, 2005, pp. 216–231.[18] J.-A. Goguen, R.-M. Burstall, A study in the foundations of programming methodology: specifications, institutions, charters and parchments, in: D. Pitt, et al. (Eds.), Category Theory and Computer Programming, in: Lect. Notes Comput. Sci., vol. 240, Springer-Verlag, 1985, pp. 313–333.[19] J.-A. Goguen, R.-M. Burstall, Institutions: abstract model theory for specification and programming, J. ACM 39 (1) (1992) 95–146.[20] N. Gorogiannis, A. Hunter, Merging first-order knowledge using dilation operators, in: Fifth International Symposium on Foundations of Information and Knowledge Systems, FoIKS’08, in: Lect. Notes Comput. Sci., vol. 4932, 2008, pp. 132–150.[21] S.O. Hansson, Knowledge-level analysis of belief base operations, Artif. Intell. 82 (1) (1996) 215–235.[22] H. Katsuno, A.-O. Mendelzon, Propositional knowledge base revision and minimal change, Artif. Intell. 52 (1991) 263–294.[23] I. Levi, Subjunctives, dispositions and chances, in: Dispositions, in: Synthese, vol. 113, Springer, 1977, pp. 303–335.[24] H. Liu, C. Lutz, M. Milicic, F. Wolter, Updating description logic ABoxes, in: KR, 2006, pp. 46–56.[25] T. Meyer, K. Lee, R. Booth, Knowledge integration for description logics, in: Association for the Advancement of Artificial Intelligence, AAAI’05, vol. 5, 2005, pp. 645–650.2009, pp. 891–897.[26] T. Mossakowski, R. Diaconescu, A. Tarlecki, What is a logic translation, Log. Univers. 3 (1) (2009) 95–124.[27] G. Qi, J. Du, Model-based revision operators for terminologies in description logics, in: International Joint Conference on Artificial Intelligence, IJCAI, [28] G. Qi, W. Liu, D. Bell, A revision-based approach to handling inconsistency in description logics, Artif. Intell. Rev. 26 (1–2) (2006) 115–128.[29] G. Qi, W. Liu, D.-A. Bell, Knowledge base revision in description logics, in: M. Fisher, W.V. der Hoek, B. Konev, A. Lisitsa (Eds.), European Conference on Logics in Artificial Intelligence, JELIA, in: Lect. Notes Artif. Intell., vol. 4160, Springer-Verlag, 2006, pp. 386–398.[30] G. Qi, F. Yang, A survey of revision approaches in description logics, in: D. Calvanese, G. Lausen (Eds.), Web Reasoning and Rule Systems (RR), Second International Conference, in: Lect. Notes Comput. Sci., vol. 5341, Springer-Verlag, 2008, pp. 74–88.[31] M.-M. Ribeiro, R. Wassermann, AGM revision in description logics, in: First Workshop on Automated Reasoning about Context and Ontology Evolution, ARCOE, 2009, pp. 13–15.Ontology Evolution, ARCOE, 2010, pp. 7–8.[32] M.M. Ribeiro, R. Wassermann, Base revision for ontology debugging, J. Log. Comput. 19 (5) (2009) 721–743.[33] M.-M. Ribeiro, R. Wassermann, More about AGM revision in description logics, in: Second Workshop on Automated Reasoning about Context and [34] M.-M. Ribeiro, R. Wassermann, Minimal change in AGM for non-classical logics, in: C. Baral, G.D. Giacomo, T. Eiter (Eds.), Fourteenth International Conference on Principles of Knowledge Representation and Reasoning, KR, AAAI Press, 2014, pp. 657–660.[35] M.-M. Ribeiro, R. Wassermann, G. Flouris, G. Antoniou, Minimal change: relevance and recovery revisited, Artif. Intell. 201 (2013) 59–80.[36] S. Schlobach, R. Cornet, Non-standard reasoning services for the debugging of description logic terminologies, in: International Joint Conference on Artificial Intelligence, IJCAI’03, vol. 3, 2003, pp. 355–362.[37] S. Schlobach, Z. Huang, R. Cornet, F.V. Harmelen, Debugging incoherent terminologies, J. Autom. Reason. 39 (3) (2007) 317–349.[38] A. Sernadas, C. Sernadas, C. Caleiro, Synchronization of logics, Stud. Log. 59 (2) (1997) 217–247.[39] A. Tarski, The semantic conception of truth, Philos. Phenomenol. Res. 4 (1944) 13–47.[40] A. Tarski, On the concept of logical consequence, Log. Semant. Metamath. (1956) 409–420.[41] Z. Wang, K. Wang, R.-W. Topor, Revising general knowledge bases in description logics, in: F. Lin, U. Sattler, M. Truszczynski (Eds.), Twelfth International Conference on Principles of Knowledge Representation and Reasoning, KR, AAAI Press, 2010, pp. 599–601.[42] Z. Zhuang, Z. Wang, K. Wang, J. Delgrande, Extending AGM contraction to arbitrary logics, in: 24th International Joint Conference on Artificial Intelli-[43] Z.-Q. Zhuang, M. Pagnucco, Y. Zhang, Definability of Horn revision from Horn contraction, in: 23rd International Joint Conference on Artificial Intelli-gence, IJCAI-15, 2015, pp. 3299–3305.gence, IJCAI, IJCAI/AAAI, 2013, pp. 1205–1211.