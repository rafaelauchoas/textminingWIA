Artificial Intelligence 76 ( 1995) 377-426 Artificial Intelligence CABINS: a frarnework of knowledge acquisition and iterative revision for schedule improvement and reactive repair Kazuo Miyashita a**vl, Katia Sycara b,2 a Electrotechnical Laboratory, l-l-4 Umezono, Tsukuba, Ibaraki 305, Japan h The Robotics Institute, Carnegie Mellon University, Pittsburgh, PA 15213, USA Received 14 June 1993; revised 27 April 1994 Abstract Practical scheduling problems generally require allocation of resources in the presence of a large, diverse and typically conflicting set of constraints and optimization criteria. The ill-structuredness of both the solution space and the desired objectives make scheduling problems difficult to for- malize. This paper describes a case-based learning method for acquiring context-dependent user optimization preferences and tradeoffs and using them to incrementally improve schedule quality in predictive scheduling and reactive schedule management in response to unexpected execution events. The approach, implemented in the CABINS system, uses acquired user preferences to dynamically modify search control to guide schedule improvement. During iterative repair, cases are exploited for: ( 1) repair action selection, (2) evaluation of intermediate repair results and (3) recovery from revision failures. The method allows the system to dynamically switch between re- pair heuristic actions, each of which operates with respect to a particular local view of the problem and offers selective repair advantages. Application of a repair action tunes the search procedure to the characteristics of the local repair problem. This is achieved by dynamic modification of the search control bias. There is no a priori characterization of the amount of modification that may be required by repair actions. However, initial experimental results show that the approach is able to (a) capture and effectively utilize user scheduling preferences that were not present in the scheduling model, (b) produce schedules with high quality, without unduly sacrificing efficiency in predictive schedule generation and reactive response to unpredictable execution events along a variety of criteria that have been recognized as important in real operating environments. * Corresponding author. ’ E-mail: miyasita@etLgo.jp. 2 E-mail: katia@cs.cmu.edu. 0004-3702/95/$09.50 @ 1995 Elsevier Science B.V. All rights reserved SSDIOOO4-3702(94)00089-l 378 K. Miyashita, K. Sycara/Arti$cial Intelligence 76 (1995) 377-426 1. Introduction in a consistent manner, a limited number of resources to task can be described as assigning The scheduling activities over time associated with the problem, and release dates. The goal of a scheduling constraints that respect these problem constraints mize tardiness of jobs, minimize work-in-process cycle utilization, minimize preferences. Scheduling i.e. so as to avoid violation of constraints activity precedence is to produce schedules such as mini- resource should also respect user and optimize a set of objectives, inventory such as resource capacity constraints, time etc. The produced (WIP), maximize schedule reasons: system for the following is a problem in the “hardest” subset of (i) Computational is difficult to automate complexity: Scheduling [ 131. interactions: Due (iii) problems scheduling to the tight objectives/preferences: that multiple optimization the effect of a local optimization problems, (e.g. minimize weighted For practical objectives inventory, maximize scheduling among there is no general decision on global optimality, interactions and the nonlinear nature of scheduling objectives, NP-complete (ii) Tight constraint constraints way to predict even for the simplest objective. it is Ill-structured tardi- desirable resource utilization) must ness, minimize work-in-process be satisfied. Moreover, optimization objectives often interact and conflict with one another. To optimize along one objective alone could jeopardize optimality along other objectives. The relationships between global objectives are extremely itself of what is a “high quality” difficult to balance conflict- schedule the typically ing objectives user preferences and domain constraints not cap- presence of context-dependent such user preferences tured in the scheduling model. The value of incorporating and constraints increasingly recognized to model. The definition/evaluation is fraught with difficulties and tradeoffs among because of the need tradeoffs them. Such [ 281) but good techniques are currently is becoming lacking. scheduling environments in operational reflect (e.g. environments environment: Operational are dynamic. Unpredictable (e.g. (iv) Dynamic factories) events, such as machine breakdown or operator absence, often happen during schedule execution. Therefore, a schedule is static and that is only predictive (i.e. it is created assuming system will be brittle. predictable) should be reactive, i.e. perform to unforeseen events during schedule execution. that any effective that the world for scheduling in response It is clear scheduling schedule systems revision The scheduling problem has been addressed by two general In revision-based scheduling structive [ 12,401) , a schedule schedules. initial schedule heuristic from scratch, response implications incremental to unanticipated is incrementally [ 291 or simulated annealing. approaches and revision-based scheduling. is constructed by incremental construction [ 29,54,6,24] In constructive types of methods, con- (e.g., approaches and merging of partial ) a complete but suboptimal such as a mm-conflict In [ 361, while predictive schedules are generated in the techniques, schedule revision has been used to repair a pre-computed events during schedule execution. The approach analyzes (e.g., repaired by several of specific schedule features and matches them to behavioral characteristics to react. reasoning (CBR) based on [42]. K. Miyashita, K. Sycara/Artifcial Intelligence 76 (1995) 377-426 319 reactive actions of appropriate control model. These approaches assume tion. This assumption context-dependent objective is in general user preferences function. that are selected according to a static, pre-determined the existence of an explicit optimization limiting since, in practice, optimization and cannot be expressed func- criteria reflect in terms of a single global repair approach, in response to find a feasible In this paper, we describe a revision-based of schedule quality based on these preferences, system, that provides a unified framework and tradeoffs, improvement schedule management iterative schedule was not guaranteed executable schedule after each repair that has guaranteed monotonic the more time it is allowed for repair, thus exhibiting anytime executable behavior This is a very desirable quality especially a certain in the CABINS implemented for acquisition of user optimization preferences and reactive that utilize of the iteration, CABINS produces an in quality increase [ 111. in reactive contexts since there could only be to unforeseen events. Unlike other systems solution limited amount of time for the system [ 54,29]>, where executability at the end of each repair (e.g. Our approach uses integration of case-based [ 221 and fine granu- Integrating CBR with scheduling that could be scheduling knowledge regularities repair action to dynamically domain, we assume that it exhibits domain scheduling mechanisms thus expressing dependencies adapt the search procedure and differentially stems from a variety of motivations. Although in the schedule, the repair context and a suitable in a case. In CABINS, a case represents application among (see Section CBR allows capture and re-use of larity constraint-directed constraint-based is an ill-structured captured, albeit only approximately, to one activity of a revision action features of the schedule, 4.1 for a detailed description of case representation). this dependency in future similar situations. On the other hand, because of the bias scheduling decisions in one part of the schedule tightly coupled nature of scheduling decisions, tech- may cause constraint to other parts niques are necessary revisions of the schedule as case-based the acceptability of the outcome of a repair are made. The evaluation criteria for judging of action are often multiple, criteria and the associated tradeoffs. Therefore, that tradeoffs and trade- collectively these offs under diverse problem tradeoffs in the case base in two ways: as preferences for selecting a repair action depending on the features of the from repair context, and as evaluation preferences selection and application of a specific repair action. approach capture a user’s schedule evaluation preferences solving circumstances the ripple e#ects that spread conflicts repair actions are applied and specific schedule and enable CABINS are reflected in other parts. Therefore, constraint propagation in a simple manner. The case base incorporates from the case base. Hence, user preferences violations to determine a distribution of examples and reflect user judgment for the repair outcome for solving practical context dependent A revision-based and implicitly the evaluation it is difficult that resulted is attractive to describe conflicting, a revision to induce There are no known efficient search algorithms very limited set of simple objectives computation the construction to meet optimization for finding a solution of a cheap but suboptimal is preferable objectives required for schedule optimization scheduling problems. except for a [ l] ) and the amount of such as makespan (e.g. is generally unpredictable schedule that is then incrementally in practice, because one can interrupt [ 131. Therefore, repaired the 380 K. Miyashita, K. Sycara/Arttjicial Intelligence 76 (I 995) 377-426 repair process and use the interim result for execution when no more time is allowed for further repair. For example, dispatch heuristics have very low computational cost, but due to their myopic nature, they must be tailored to particular optimization objectives. Hence, in general they cannot address issues of balancing tradeoffs with respect to a variety of optimization objectives. As a consequence, they result in suboptimal schedules. However, because of their efficiency, they are widely used by practitioners. Therefore, [ 51,30]), combining a as has already been pointed out by other researchers (e.g., repair methodology, such as a simple gradient search [ 171, or the one advocated in our work, with a dispatch driven scheduler for creation of the initial schedule is promising for real-world scheduling environments. Experimental results reported in Section 5.2.1 indicate that CABINS can produce substantial schedule improvements starting with schedules generated by several methods, i.e. a number of dispatch heuristic and a constraint-based scheduler. [ 211, neural networks Our approach was evaluated through extensive controlled experimentation on job shop scheduling problems. Experimental results, reported in Section 5 show that ( 1) the approach is potentially effective in capturing user preferences and optimization tradeoffs it improves schedule quality irrespective of method that are difficult to model, (2) of initial schedule generation, (3) it produces high quality schedules at much lower computational cost as compared to simulated annealing, a well-known iterative repair method, and (4) it is suitable as a reactive scheduling method because it maintains high schedule quality and minimizes disruptions in the face of execution time failures. The rest of the paper is organized as follows: Section 2 gives some background in job shop scheduling and presents the constraint-based techniques used in CABINS. Section 3 introduces case-based schedule optimization. Section 4 presents case representation, indexing, retrieval and application to the schedule of a retrieved revision. It also presents an extensive example. Section 5 presents experimental results to validate the approach. Section 6 discusses related work and Section 7 conclusions and future work. 2. Job shop scheduling Job shop scheduling deals with allocation of a limited set of resources to a number of activities associated with a set of jobs/orders. The dominant constraints in job shop scheduling are temporal activity precedence and resource capacity constraints. The ac- tivity precedence constraints along with a job’s release date and due date restrict the set of acceptable start times for each activity. The capacity constraints restrict the number of activities that can use a resource at any particular point in time and create conflicts among activities that are competing for the use of the same resource at overlapping time intervals. The goal of a scheduling system is to produce schedules that respect temporal relations and resource capacity constraints, and optimize a set of objectives. In our model we allow substitutable resources for each activity of a job, thus being able to deal with parallel machine job shop scheduling, a more complicated version of the job shop scheduling problem [ 311. CABINS’s revision-based approach has two phases: ( 1) create an initial schedule by utilizing any method (e.g. dispatching rules), and (2) improve the (possibly) suboptimal schedule that was generated in the first step so as to K. Miyaslzita, K. Sycara/Art@cial Intelligence 76 (1995) 377-426 381 incorporate user preferences and tradeoffs. In the rest of this section, we present the job shop scheduling problem within the framework of constraint satisfaction, and present the search strategy that is used to propagate the effects of repair actions in CABINS. 2.1. Constraints The job shop scheduling problem requires scheduling a set of jobs J = (51,. . . , Jn} on a set of physical resources RES = {RI, . . . , R,}. Each job JI consists of a set of operations/activities A’ = {A’, , . . . , AL,} to be scheduled according to a process routing that specifies a partial ordering among these activities (e.g., Af BEFORE Af) . Each job Jl has a release date rdr that signifies the earliest time the job can be started and a job due date ddl, by which the job should be finished. Each activity Af has a fixed duration duf and a variable start time stf. The domain of possible start times of each activity is initially constrained by the release and due dates of the job to which the activity belongs. In order to be successfully executed, each activity Af requires of different resources (e.g., a milling machine, a jig and a machinist) Rt ( 1 < j < pf), for each of which there may be a pool of physical resources from which to choose, r!. I }, with rijk E RES (1 < k 6 qij) (e.g., several possible milling Gj = Irijl 1 . . . t I,14ii machines). More formally, the problem can be defined as follows: Variables: k vector of variables is associated with each activity, Ai (1 < I < n, 1 6 i < nl), which includes: (i) (ii) each resource requirement, Rt (1 < j < of) for which the activity has several the activity start time, stf, and alternatives. (ii) Constraints: The non-unary constraints of the problem are of two types: (i) constraints defined by the process routings translate into linear precedence inequalities of the type: stf + duf < st: (i.e. Af BEFORE A:); capacity constraints that restrict the use of each resource to only one activity at a time translate into disjunctive constraints of the form: (VpVq Rk # Riq) V stj + duf < st: V st$ + duf < stf. Constraints simply express that, unless they use different resources, two activities A! and Af cannot overlap. 3 Time is assumed discrete, i.e., activity start times and end times can only take integer values. Each resource requirement RI has to be selected from a set of resource alter- natives, Gj C RES. These constraints include non-relaxable release dates, and initially, non-relaxable due dates between which all activities in a job need to be performed. 2.2. Objectives and preferences In practice, scheduling objectives are numerous, complex, often conflicting and the mathematics of the problem can be extremely difficult with even the simplest of ob- 3 These constraints have to be generalized when dealing with resources of capacity larger than one. 382 K. Miyashita, K. SycurdArtifcial Intelligence 76 (199.5) 377-426 (e.g. the objectives, [ 131. Below, we define [ 13]>, that we used to develop jectives the literature INS. These objectives that are difficult WEIGHTED.TARDINESS2 evaluation of schedules, but cannot be easily represented by traditional to model precisely. For example, schedule approaches. are mathematical simplifications x WIP3 could be induced by CABINS that are among the performance the most common in evaluation of CAB- objectives of state-dependent an optimization criterion such as if user gave consistent in ways that can be explored l Waiting time ( W;> : is the time that elapses between the completion of the preceding activity Ai_, l TotuE waiting (or rdr, if i = 1) and the start of processing Af. time (WI): is the sum of waiting time of all activities that belong to J’. Clearly Wl = CF!, W:. b Completion time (Cl): equality: Cl = rdl + Cz!, ( Wi + duf). is the time at which processing of 51 finishes. We have the l Lateness is simply (LI): date of JI: LI = Cl - ddl. the difference between the completion time and the due l Tardiness 8 always l Flowtime (TI): is delay in the completion of JI against takes non-zero value. Thus Tr = max(O, ~51). ( FI): is the amount of time that Jl spends its due date ddl. Note that in the system. Fl = Cl - rdl or Fl = Cyl, ( Wj + duf). l Mukespun l Work-in-process (C,,,,,) : is the latest completion ( WIP): is the summation of total waiting time of the entire orders. Cm, = max Ci. time. WZP = inventory c;=, Wi. l Weighted tardiness (T,,) : is the weighted average of tardiness. Weight is considered as a penalty cost of being The quality of a schedule tardy. T,, = Cz, wiz;:. is a function of the extent to which the necessity of having user’s preferences preferences. We illustrate system by using a very simple example. We assume machine factory machine. Let us further assume that the two jobs are released at the same time. and two jobs. Each job consists of a single activity the simplest it achieves user’s in the scheduling factory with a single to be processed on the to the factory floor job B finishes before Fig. 1 shows two schedule results for this problem. Suppose schedule-l to reduce is to switch is schedule-2. in Fig. 1 (the WIP of job B is zero). Suppose one wishes the tardiness of job A. In this simple schedule, the positions of job A and job B. The schedule is generated. its due date but job A is tardy. The WIP of job the to revise the only possible from this (the it is In this schedule, A is indicated schedule repair switch In schedule-2, neither job is tardy but the WIP in schedule-2 WIP of job B) is larger than in schedule-l. Even in this extremely simple example, is of higher quality without difficult the preferences of the user. Simply adding WIP plus weighted the sum may not be realistic in the overall sum reflects may depend upon many past shipping those factors produces an enormous number of contexts thus making user’s preferences considered, into consideration taking tardiness and minimizing importance of each of these objectives tradeoffs of the client of each job, of are a priori and so on. The combination in which user preferences load of a factory/warehouse to decide which schedule to capture and represent such as the importance the user is willing to make. These the tradeoffs the relative resulting records, difficult factors, since K. Miyashita, K. Sycara/Artijcial Intelligence 76 (1995) 377-426 383 nf?rease “aa (.4 and B) Due Date (A) Due Da!e (B) Schedule-l Schedule-2 WIP of Job A Tardiness of Job A WIP of Job B Time Horizon Fig. I. Example of conflicting objectives. D in the problem model. That is the reason that the authors think acquiring preferences adaptively is important. 2.3. Constraint-based search procedure The constraint-based search procedure used in CABINS for applying a selected repair action (see Section 4.4) is based on [ 42,401. Search is interleaved with the application of consistency enforcing mechanisms and variable/value ordering heuristics that attempt to avoid dead-end states. A search state is associated with each partial solution. Each search state defines a new constraint satisfaction problem whose variables are the vari- ables that have not yet been instantiated and whose constraints are the initial problem constraints along with constraints reflecting current assignments. A schedule is built by opportunistically selecting an activity to be scheduled and assigning to it a reservation, i.e. a resource and a start time. Each time a new activity is scheduled, new constraints are added to the initial scheduling constraints that reflect the new activity reservation. These new constraints are then propagated (consistency checking). If an inconsistency (i.e., constraint violation) is detected during propagation, the system backtracks. Other- wise the scheduler selects a new activity to schedule and a reservation for that activity. The process terminates when all activities have been scheduled successfully. More specifically, search proceeds according to the following steps: (i) (ii) (iii) (iv) (v) (vi) If all operations have been scheduled then stop, else go onto step 2; Apply the consistency enforcing procedure; If a dead-end is detected then backtrack (i.e. select an alternative reservation if one is left and go back to step 1, otherwise stop) ; Select the next operation to be scheduled (variable ordering heuristic); Select a promising reservation for that operation (value ordering heuristic) ; Create a new search state by adding the new reservation assignment to the current partial schedule and go back to step 1; 384 K. Miyashita, K. Sycara/Art@cial Intelligence 76 (1995) 377-426 The details of each step are as follows: l Consistency enforcement: The consistency enforcing procedure is a hybrid proce- dure that differentiates between precedence constraints and capacity constraints. It guarantees that dead-end states only occur as the result of capacity constraint vio- lations. Essentially, consistency with respect to precedence constraints is enforced by updating in each search state a pair of earliest/latest possible start times for each unscheduled operation. Consistency enforcement with respect to capacity constraints tends to be signifi- cantly more expensive due to the disjunctive nature of these constraints. For capacity constraints, a forward checking type of consistency checking is generally carried out by the system. Whenever a resource is allocated to an operation over some time interval, the forward checking procedure checks the set of remaining possible start times of other operations requiring that resource, and removes those start times that would conflict with the new assignment. l Variable ordering: Because scheduling is NE-hard, it is important to focus search in ways that avoid dead-end states. This is accomplished by utilizing good vari- able (i.e., activity) and value (i.e., reservation) ordering heuristics. A variable ordering determines which activity is going to be scheduled next and value or- dering determines which reservation should be assigned to the selected activity. The variable ordering heuristic utilized in the system is called Activity Resource [42] and selects the most critical activity first, i.e., the activity Reliance (ARR) with the highest probability of being involved in a capacity constraint violation over particular time intervals. For more details on the approach, see [42]. l Value ordering: Once the activity to be scheduled next has been selected, the value ordering heuristic determines which reservation to assign to the activity. The two value ordering heuristics relevant to this paper are: l Least constraining value ordering (LCV) : This heuristic selects the reservation that is the least likely to prevent other activities from being scheduled. LCV uses an unbiased utility function (see Fig. 2) for each activity, i.e. there is no preference for a particular start time out of the activity’s available start times. l Greedy value ordering (GV) : This heuristic selects a reservation based on local preferences that are expressed via static piece-wise linear biased utility function associated with each activity (see Fig. 2). This biases value ordering to prefer activity start times with high utility values. For scheduling problems with substi- tutable resources, static utilities that express differential resource preferences are used in the selection of an activity’s reservation. Experiments in [42] 4 on some rather small job shop problems (each with 20 ac- indicate that the ARR variable ordering with LCV value ordering produces tivities) suboptimal schedules with minimal backtracking; ARR variable ordering with GV value ordering with statically pre-determined utility functions, henceforth referred to as constraint-based scheduling (CBS), was shown to produce high quality schedules as compared to the SMU heuristic [ 231. 4 The experiments were run on 20 randomly generated scheduling problems. K. Miyaslzita. K. Sycara/Artifcial Intelligence 76 (1995) 377-426 385 A biased-utility-value \ I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ...*..... - . . . . . . . . . ~ . . . . unbiased-utility-value [ \ release-date allowable latest start date Fig. 2. Utility functions. In CABINS, schedule revision proceeds iteratively, one activity at a time. The set of activities that get involved in constraint violations as a result of repairing one activity is the conjlict set of the repair. The repair process unschedules the activities in the conflict set and modifies the bias of the utility functions associated with them. This bias reflects the effects of learning context-dependent user preferences and evaluations of repair outcomes that have been stored in the case base. The search procedure with the modi$ed utility functions, ARR variable ordering and GV value ordering is used to schedule the conflict set activities that got unscheduled during repair. In other words, each time an activity is repaired, CBS is used to re-schedule a subset of the activities (i.e. the members of the conflict set) of the overall schedule with utility functions that have been adaptively modi$ed based on information in the case base. Section 4.4 describes the repair process in detail. 3. Case-based schedule optimization In order to optimize schedules to user’s satisfaction, we need to know context- dependent user preferences and represent them in the scheduling system to be exploited in the reasoning process. Rule-based approaches, while having the potential to capture tradeoffs in rules, require considerable knowledge acquisition effort context-dependent [ 371. Our approach uses case-based reasoning (CBR) which has the potential for deal- ing with noisy data [ 39,2], acquiring user knowledge in complex domains [ 7,281, and expending less effort in knowledge acquisition compared with knowledge acquisition for rule-based systems [ 45,261. Because of the characteristics of the scheduling domain described in the previous section and our interest in capturing context-dependent user preferences, CBR seems a natural method for knowledge acquisition. However, applying CBR to schedule im- provement, a numerical optimization problem, is very challenging. In general, CBR has been used for ill-structured symbolic problems, such as planning [ 14,18,50], legal reasoning [ 3,381, argumentation [ 491, conceptual design [ 431, medical diagnosis [ 201 where the primary concern has been plausibility or correctness of the resulting artifact (plan, argument, design) and computational efficiency of the process rather than artifact 386 K. Miyashita, K. Sycara/Artijicial Intelligence 76 (1995) 377-426 quality. The challenges we faced were to decide what constitutes a case in the domain of schedule optimization and what the case indices should be. The intuitive answer would be to consider a whole schedule as a case. This solution is attractive since, if the right information could be transferred from one scheduling scenario to another, or with little adaptation, the new problem would be solved with relative ease. However, because of the high degree of nonlinearity of scheduling constraints and objectives, a very small difference between an input problem specification and the problems in the case base can in general result in large variations in the results both in terms of amount of modification needed and the quality of resulting schedule. A second difficulty with respect to having a whole schedule as a case came in the form of what indices to choose. Indexing a case in terms of the goals that must be achieved and problems that must be avoided [ 141 is a good guideline and has served many CBR systems well. However, in our domain, the goals to be achieved (the optimization criteria) cannot be explicitly stated since they reflect context-dependent user preferences and tradeoffs. Even if the optimization objectives were explicit, because of the nonlinearities of the problem, retrieving a schedule in which the achieved objectives were the same as the desired ones in the current problem would give little or no help in adapting the retrieved schedule to the current problem specifications. Moreover, because of unpredictable ripple effects of constraint propagation and tight constraint interactions, the problems to be avoided are not at all obvious, neither can they be discovered since a causal model for scheduling cannot be assumed. Since it is impossible to judge a priori the effects of a scheduling decision on the optimization objectives, a scheduling decision must be applied to a schedule and its outcome must be evaluated in terms of the resulting effects on scheduling objectives. Therefore, having a single scheduling decision as a case seemed to provide advantages in terms of focus and traceability of the problem solving process. Focus and traceability mean that we could capture a user’s evaluation of the results of a single scheduling decision in a case, and, if the result was unacceptable, we could apply another scheduling decision to the same scheduling entity until either all available scheduling decisions had been exhausted or an acceptable result had been obtained. Therefore, it became clear that it was better to have a single activity/operation of a scheduling job as the “scheduling entity” on which a scheduling decision was applied. Since the result of a scheduling decision needed to be evaluated with regard to the optimization preferences for a schedule as a whole, it is clear that constructive methods which incrementally augment a partial schedule at every scheduling decision point would be unsuitable for information, which can only be provided by having a our purposes. Moreover, contextual scheduling complete schedule, was chosen as the underlying is very useful in applying CBR. Therefore, scheduling methodology. revision-based Hence in CABINS, a case describes the application of a schedule revision decision on a single activity of a job. Operationalization is done by means of a schedule repair action. We have identified two classes of schedule repair in detail in Section 4. We use constraint actions propagation to the rest of the to propagate in a new schedule. The search space of schedule. Each application the effects of a schedule of a repair results (i.e. strategy and tactic), described revision decision of a schedule repair action K. Miyashita, K. SycaralArtificial Intelligence 76 (1995) 377-426 381 that are suitable for case indexing indices are divided the predictive case features is the space of complete schedules that there are regularities of the domain CABINS that incorporate acceptable user optimization tradeoffs. Hence should be ones that capture good tradeoffs. Although schedule optimization is ill-structured, we make the hypothesis that can be captured, albeit into three in an approximate manner, in these features. In CABINS, categories. The first category consists of the globalfeatures. Since the results of schedule revision associated with a single activity pertain to the whole schedule, global features that express characteristics of a whole schedule are relevant and operate as contextual information second category. Since necessitated since reasoning lookahead amount the range of lookahead analysis Associated with this time horizon, the effects of each repair action. the the bounds of repair and about the effects of a repair action on the whole schedule a priori would intractable, we confine repair time horizon (see Section 4.1). to estimate analysis which to a limited there are local features that allow CABINS repair action. The local features comprise in general to constraint for selection of a particular to predict (due of a repair action it is not possible ripple effects), by application is in general to unlimited The schedule from application of a repair action must be evaluated resulting tradeoffs. The user cannot predict of user-defined schedule correctness or quality since a modification quality or introducing evaluation of the results of schedule revisions. This evaluation part of the case’s repair history. The repair history constitutes features. Therefore, capture constraint violations. Nevertheless, the case base incorporates a distribution of examples tradeoffs under diverse scheduling repair performance the effects of modification in terms actions on schedule the user can perform consistent could result in worsening in the case as is recorded the third category of case that collectively circumstances. is provided CABINS searches to be applied and second the space of complete schedules. Control for this search is provided selection of by CBR in two ways: First, search control evaluation of the the next repair action from application of a selected repair action. The outcome that are used to retrieve a case that suggests global and local features are the indices the next repair action to be applied. The features associated with the repair history are used to retrieve cases that suggest evaluations of a repair outcome. For a more detailed description of case representation through case-based through case-based see Section 4.1. for the schedule and indexing, that resulted 4. CABINS overview In CABINS, there are two general tactics are appropriate is associated with a particular high level description types of repairs: repair strategies and repair tuc- of classes tics. A repair strategy of schedule defects. Each repair strategy has a variety of repair tactics associated with of the defect classes. it. The repair for particular local patching and model We have identified the that result in changing modijcution. Local patching resource assign- sequence of activities to factory operations. For ments. Local patching strategies example, less costly and disruptive tardiness, if the repair goal is to reduce job is the selection of repair actions allocated is in general types of repair strategies: resources, or rearranging local patching specializations two general to different specific 388 K. Miyashita. K. Sycara/Artijicial Intelligence 76 (1995) 377-426 I Scheduling Problem ,................. 1 . . . . . . . . . . . . . . . . . . . Scheduler -- incomplete Domain Knowledge Test Data Suboptimal Schedule l . . . . . . . . . . . . . . . . . ..a............... * . . . . . . . . . i Repair by CABINS i.............................................< Retrieve similar case Evaluate result I Contextual Domain Knowledge I L m......... *...; f Repair by : Human-expert i i...............................! sd~ct a r*pair actions Case-Base case acquisition * m....... -j Feature Values Evaluation Criteria I :‘....... Repair Tactic Explain i : i Evaluat. romu1t fd1Ur.S I I,............... . . . . . . ..a....... Improved Schedule Fig. 3. CABINS architecture. include “reduce the slack between activities in the tardy job”, and “reduce the idle time of resources needed by activities in the tardy job”. Model modification reformulates the problem by changing model parameters, such as the number of jobs to be scheduled, or global constraints such as changing release or due dates, increasing resource capacity or increasing number of shifts. Model modification strategies facilitate the solution of the problem, since they amount to global constraint relaxations. However, in practice, model modification strategies are costly to implement (e.g., buy new equipment, pay for extra shifts in a factory, subcontract jobs to outside contractors). The default CAB- INS strategy is local patching, a computationally more challenging task since the system must improve the schedule without relaxing the already imposed constraints (except due date constraints). If local patching is unsuccessful in fulfilling the repair goal, the repair episode is considered a failure. Our experiments were run within these more stringent assumptions. Fig. 3 depicts the overall architecture of CABINS. CABINS is composed of three modules: ( 1) an initial schedule builder, (2) an interactive schedule repair (case acqui- sition) module and (3) an automated schedule repair (case re-use) module. CABINS can operate in the following modes that exhibit different levels of autonomy: - Knowledge acquisition interactive mode to acquire user preferences and generate K. Miyashita, K. Sycara/Art$cial Intelligence 76 (1995) 377-426 389 the case base. - Decision-support interactive mode where the previously acquired case base that incorporates user preferences suggests revision actions and evaluation outcomes to the user who can accept a suggestion or override it with a new suggestion. - Automatic mode where previously acquired user preferences are re-used to guide scheduling decisions without any interaction with the user. In the experiments reported in Section 5, CABINS operated autonomously. The repair process in autonomous operating mode has the following basic steps: (i) (ii) (iii) (iv) (v) A job in the initial suboptimal schedule is randomly identified to be repaired. The random job selection is necessary since CABINS does not have explicit optimization criteria that it could use to select jobs to be repaired in a more informed fashion. and the activity The job under current repair consideration is called thefocaljob under current repair consideration is called thefocalactivity. Repair is performed one activity at a time. Activities in a focal-job are repaired in a forward fashion starting with the earliest activity of that job that has “enough” upstream slack. This mechanism focuses attention on activities that have enough slack so they can be moved, thus (a) avoiding unnecessary computations, and (b) limiting the amount of ripple effects (schedule disruption) that could be caused by moving activities that are too tightly scheduled and whose move would cause many constraint violations. s A repair strategy/tactic is selected for the current problem using CBR and is applied. Application of a repair tactic (described in Section 4.4) consists of three parts: (a) identifying the activities, resources and time intervals that will be involved in the repair, i.e. the current conflict set, (b) change the utility functions associated with activities in the conflict set, and (c) using the constraint-directed scheduler with utilities assigned in step (b) to make the resource reservations for the activities identified in step (a). After a repair has been executed, CBR is used to predict and evaluate the repair outcome in the context of the current case base. If repair is deemed a success, find next activity to repair, else (if repair outcome is a failure), CBR is invoked to select the next repair tactic to repair the current focal-activity. 4.1, Case representation The repair process should exploit knowledge relating both to the continuing validity of various scheduling decisions, the flexibility of current time and capacity constraints, the tradeoffs that are implied by a particular repair, and whether the repair was successful or unsuccessful according to the user’s judgment. Fig. 4 shows the information content of a case. Appendix A shows an example of a case instance that is in CABINS’ case base. 5 In the current implementation, “enough” upstream slack is heuristically determined as twice the tardiness of the focal-job. 390 K. Miyushita, K. Sycara/Artifcial Intelligence 76 (1995) 377-426 CASE Global Feature Resource Utilization Deviation Local Feature Waiting Time Value Salience Predictive Shift Gain Value Salience Predictive Alt Shift Gain Salience Value Predictive Swap Gain Value Salience Predictive Alt Swap Gain Salience Value Repair History Tactic Value Outcome Va,ue Salience Salience Effect Type Value Salience Xl Fig. 4. Case representation. the application of a particular repair action to an activity. Because that of the domain, case features are heuristic approximations of revision-based scheduling. For example, one of the regularities regularities A case describes of the ill-structuredness reflect that would be useful much freedom Global case features whole. High resource utilization, much presence of highly contended-for reflect flexibility Local features the temporal bound In particular, horizon. The repair end of the activity preceding focal-activity repair to represent would be repair flexibility, for moving an activity i.e. the notion of how to a new position. there is in the current schedule (Fig. 4) reflect potential repair flexibility for example, often flexibility. High standard deviation of resource utilization for the schedule as a indicates a tight schedule without the low repair flexibility. temporal bounds. indicates revision within resources which in turn indicates for schedule that CABINS uses is a time interval called repair time the is the time in the same focal-job and the end of the that we have identified are in the same interval between limited time horizon of a focal-activity the focal-activity (see Fig. 5). The local features K. Miyashita, K. Sycara/Artificial Intelligence 76 (199.5) 377-426 391 1 Fig. 5. Repair time horizon of focaLactivity( ACT,!). spirit as those utilized overall gain will be achieved by moving horizon. when moved to the left within In particular, it predicts in [ 361. For example, predictive-shift-gain the current focal-activity the repair time horizon. the likely reduction of the focal-activity’s waiting predicts how much in its time time earlier The repair history records the sequence of applications of successive repair actions, the assigned objectives the outcome This judgment is “acceptable” (e.g., weighted in the case base. An outcome these effects reflect tradeoffs among different objectives. A repair outcome repair effects and the repair outcome. Repair effects describe the impact of the application tardiness, WIP). of a repair action on schedule optimization Typically the evaluation [“acceptable”, “unacceptable”]. recorded of effects for the current application of a repair action case acquisition, tactic is considered balancing during CBR repair the repair outcome from success cases features, retrieves similar past failures of the tactic that were successfully that was eventually similar outcome past and current case. Therefore, potentially is to the set of effects of a repair action and takes values in the set is made in the training phase and gets in the set If, during the application of the repair to tradeoffs with respect If is provided. another tactic is selected the same activity, using as indices global and local case the failed tactic, and the indication of the failed outcome. This CBR invocation repaired and the tactic here is that a the tactic of a similar failure can favorable and unfavorable outcomes on optimization objectives if the tradeoffs involved is judged acceptable. implies similarity of causal structure between the past failure. The assumption a failure and an explanation is judged as “unacceptable”, is deemed unacceptable, in the current problem. for the same tactic that expresses the eventually be successful successful successful to repair in fixing 4.2. Case acquisition In CABINS, the session starts with an empty case base. A set of training problems to the user who interacts with CABINS tactic that is deemed presented the user selects the repair tactic application procedure schedule. (see Section 4.4) is to repair schedules by hand. At first, and uses CABINS’ tactic to the current to be appropriate to apply the chosen The effects of the repair are calculated. An effect describes to one or more repair objectives. Effects pertain with respect a whole or to a job. Possible effects pertaining tardiness, resource utilization, average deviation of resource utilization, the result of the repair the schedule as to either to a schedule as a whole are: weighted total schedule 392 K. Miyaslzita, K. Sycara/Artificial Intelligence 76 (1995) 377426 to a job are changes a less preferred machine inventory, or changes WIP. Effects that pertain in-process between utilizing in these effects. Due to tight constraint shop scheduling a repair schedule effects is shown An outcome tactic produces result, is acceptable or not based upon in Appendix A. is judged as unacceptable, a feasible and make schedule optimization in resource assignment. So, for example, to reduce a job’s in the tardiness of the job, changes in work- the tradeoff tardiness can be reflected in job extremely hard. When application of these effects are ubiquitous interactions, the user must decide whether the resulting those calculated effects. An example of these if the schedule resulting from the application to the user’s although improvement. For example, of low-quality machine, improvement with respect if reduction of job tardiness enforces in the user’s judgment, increased favorable and unfavorable the explanations such a repair might be judged as unacceptable. The user’s judgment of the revision heuristic does not make any criteria. This could happen because harmful effects outweighed, the effected utilization may be unacceptable low. Therefore balancing constitute terms of rating end of each repair judgment/explanation features. current problem recorded as “acceptable” that are incorporated not like the tradeoffs the current (“unacceptable”), tactic salience assigned by the user are recorded the user tries to utilize another repair tactic to repair the same activity. the total cost of this repair may be low, it to a user who worries that the quality of resulting products might be as to objective in in Fig. 4). At the the effects of the repair and user in a case along with the is If the user does in the repair effects, then the outcome of the effects calculated by CABINS and the the importance of each effect (denoted by “salience” the applied repair tactic, as to the repair outcome are recorded effects related to a particular optimization of the repair outcome. The user supplies an explanation If the effects are acceptable and the user tries to repair another activity. in the repair history of the case. Subsequently, to the user, the repair outcome iteration, repair is reached, or failure The process continues the effects, user’s judgment until an acceptable outcome is declared when all available is under repair. When an activity is declared. Failure tactics have been used to repair an activity, but the user finds each repair outcome unacceptable. The sequence of application of successive repair actions, in case of failed application are recorded activity tactic application is augmented this way, a number of cases are accumulated how the cases used report current experimental operates with different and explanation in the repair history of the case. A new case is acquired only when a new repair results, no new case is acquired, but the repair history of the same case In in the case base. In Section 5, we describe in Section 5.3 we incurred when CABINS in our experiments were acquired. Moreover, results size case bases. repaired due to unacceptable its effects and outcome. by each successive tactic application, to investigate the tradeoffs is repeatedly repair 4.3. Case retrieval Once CABINS has constructed repair without any selection of a repair application of the selected tactic interaction with a case base from training data, it can perform schedule cases are for three purposes: after repair tactic, and, in case of failure, retrieval of a tactic that to be applied, evaluation its user. Retrieved of the resulting schedule K. Miyashita. K. Sycara/Arttj5cial Intelligence 76 (1995) 377-426 393 similar had fixed a previous a different tactic, global and local features of the current case (the current focal-activity) The process of applying a repair tactic is described In each of these three situations, CABINS utilizes In order to retrieve cases to select a repair are used. for case retrieval. in Section 4.4. set of indices failure. After a repair has been applied and, if the result is a feasible schedule, repair evaluation as new the effect features (type, value, and salience) is performed through CBR. Using indices, CBR is invoked and returns an outcome in the set (acceptable, unacceptable). to repair another activity. situations described the conjunction If the outcome of current revision using as indices the failed heuristic and the case global and local features Invoking CBR with these indices is decided as unacceptable, CABINS performs (un- another CBR invocation to find another acceptable), possibly retrieves cases that have failed in the past in a similar manner as the current revision. This use of CBR [48,44], in the space of failures the problem and allows then CABINS proceeds acceptable, is a domain-independent solver to access past solutions of the current outcome method of failure revision heuristic. to the failure. If the result applicable recovery is For each of the three case retrieval Nearest Neighbor method k-Nearest Neighbor calculation the three retrieval k-NN k-NN calculation problem simplest is used over (k-NN) [ IO] for case retrieval. The space over which above, CABINS uses a k- the to each of tactic, features. A finds the k-nearest neighbors, where k is some constant of the current similarity measures and, in its is done is the set of features corresponding for case retrieval the space defined by the values of global and to select a repair local situations. For example, result. from the training data based on pre-determined form, a single nearest neighbor We selected k-NN instead of I-NN is found and chosen as a classification for the following result leftshift to be applied), swap as the tactic a higher confidence reasons. 6 In domains, that do not have clear predictive than if the near neighbors and some suggesting such features due to lack of causal structure, to If a large number of near neighbor cases are of the same category can be given are of many different categories in deciding swap). For example, that we have five nearest is to the current problem is 0.8 and 0.75. If the nearest retrieved case the tactic. In this method, as scheduling there can be many matches other than the nearest match that can potentially contribute accurate classification. (e.g. suggesting to the classification (e.g. some suggesting the repair tactic to be applied to the current problem, suppose neighbors. Three of them are left-shift cases, whose similarity 0.9, 0.2 and 0.1 and the other two are swap cases, whose similarity we use l-NN, (with similarity 0.9) uses left-shift as a successful occurrence high similarity could potentially be ignored. We use the sum of the similarity neighbors as a selection criterion, among k-nearest neighbors, have an undue result with relatively in k-nearest instead of using the frequency of appearance of a class cases may swap in order to avoid the situation where dissimilar influence on the classification In the previous example, a different classification is selected as a repair cases suggesting tactic because of multiple revision leftshift result.7 ’ In the current 7 This method has been successfully implementation pronunciation and text classification of CABINS, k is set to 5. applied in [47,9]. in domains without clear causal structure, such as English word 394 K. Miyashita, K. Sycara/Artijicial Intelligence 76 (1995) 377-426 is selected as a repair leftshift). tactic by CABINS (since its total similarity is 1.55 vs. 1.2 of The similarity between a case and the current problem is computed in CABINS as follows: Distancei = Salience$ x CaseFeature; - ProblemFeaturej EDevj Similarityi = exp( -Distancei) where Salience; is the salience of the jth feature of the ith case in the case base, CaseFeature; of the jth feature feature value of all cases in the case base, and Distancei is the dissimilarity ith case and the current problem. Similarityi is the similarity between the current problem. is the value of the jth feature of the ith case, ProbEemFeaturej is the value is the standard deviation of the jth the between the ith case and in the current problem, EDevj We utilize the normalized Euclidean distance to measure the dissimilarity between a case and a problem. This prevents certain features from dominating distance calculation merely because they have large numerical values. 4.4. Repair by CABINS Repair of a schedule is performed by applying the repair repair iteration by CBR. The repair tactics currently available tactics selected in CABINS are: in each on the same resource as much to the left on the the sequence on the same resource as much to the left on the the disruptions. on a substitutable resource as much to the repair time horizon while minimizing as possible within try to move focal-activity the repair time horizon, while preserving try to move focal-activity leftslide: timeline of all the activities. leftshift: try to move focal-activity timeline as possible within the repair time horizon while minimizing leftshiftintoalt: the left on the timeline as possible within the disruptions. swap: swap within swapintoalt: horizon which causes the least disruptions by changing the focal-activity give-up: give up a further repair of the current focal-activity. the repair time horizon which causes the least disruptions. to a substitutable resource. swap the focal-activity with activity on its left within the focal-activity with the repair time the resource assignment of the activity on its left on the same resource In recent work we have expanded experiments with them. The process of applying the set of tactics to 11 and are currently perform- tactic has the a repair ing additional following steps: repaired. The (i) Determine predictive is a temporary start time that is calculated by each repair tactic as a desirable start time for a focal-activity. The ripple effects the predictive start start time of an activity time of the focal-activity being K. Miyashita, K. Sycara/Ar@cial intelligence 76 (1995) 377-426 395 of a repair, the conflict set, consists of all the activities scheduled due to constraint violations arising the predictive the same as the start time that will result from execution of the repair below). - For leftshift that may need to be re- to the focal-activity start time may not be exactly (step 5 start time. Note that this predictive start time is the start time or leftshiftintoalt, the “predictive” from moving that minimizes on the same (or substitutable) horizon. capacity over-allocation as a result of moving the focal-activity resource within the focal-activity’s repair time - For swap or swap_intoalt, the “predictive” causes substitutable) the least amount of precedence resource within the focal-activity’s start time is the start time that constraint violations on the same (or repair time horizon. (ii) Project the effects of moving the focal-activity designated tify capacity constraint violations. resource. This is done by performing to the predictive constraint propagation start time and to iden- (iii) Adjust the reservations shifting or left-shifting of all the activities so that all conflicts are resolved. in the conflict set by simple right- (iv) Change the bias of the start time utility function (see Fig. 2) of the activities in step 3. If the tactic the resource utility resource has utility higher than the resource on involves a substitutable so that the substitutable set in favor of start times calculated in the conflict being applied function which is currently biases selection of start times by the value ordering heuristic favor of those with higher utility values, thus reflecting in the case base. resource, also change scheduled. Changing the focal-activity the utility functions (Section 2.3) in encoded the preferences the focal-activity the opportunistic (v) Unschedule them using ordering, GV value ordering and the utility functions defined the start time utility function of the affected activities and all members of its conflict set and re-schedule scheduler with ARR variable constraint-directed in step 4. to reflect no bias (vi) Restore for the next repair iteration. The above process revision are calculated, evaluate schedule. The effects of the to the repair outcome. Note that an activity A! can be moved under two different results free revised and CBR is invoked with the effects as the relevant in a conflict indices situations. First, A{ can be moved when it is the current be moved when it is in the conflict set of another focal-activity. focal-activity. Second, it can In this simplified Fig. 6 gives a detailed example leftshift can be applied. them has three activities. Suppose chosen as the repair for activity A:. Left-shift dictates within that used to reflect the preference figure by “Utility the new utility the given repair function that graphically the current focal-activity shows how the local repair action example, we have three jobs and each of is AZ and leftshifr has been start time that activity Ai should be starting as soon as possible function associated with A: in the is adjusted accordingly. In the figure, function of Ai after adjustment”. The for starting Ai as late as possible is to find an appropriate the utility (indicated function of Ai before repair”) as “Utility is indicated tactic. The first step of revision time horizon. Therefore, 396 K. Miyashita, K. Sycara/Artificial Intelligence 76 (I 995) 377-426 next step is to find the conflict set which consists of all affected activities by moving Ai to the left. The members of the conflict set are shown in the figure. The utility function of each activity in the conflict set is also adjusted to reflect these changes. In the figure, we show as an example the adjustment of the utility for activity A:. After these utility functions have been adjusted, the focal-activity and the activities in the conflict set are unscheduled and the constraint-based scheduler is called to re-schedule them. The resulting repaired schedule is shown at the bottom of the Fig. 6. 4.5. An example We briefly illustrate the repair process with a very simple example schedule to be repaired shown in Fig. 7. In the gantt chart, each row shows assignments of activities on each resource, along the timeline, and each white box corresponds to an assignment of an activity. The number inside a white box identifies the job which the activity belongs to. For example, the first activity on resource2 is the first activity of Job2, identified in our text as A:. We write Ri to indicate the ith resource, Jj to identify the jth job and Ai to identify the kth activity of job 12. The example has ten jobs (JI, . . . , J~o) and each job has five activities with the linear precedence constraint (e.g., A’f BEFORE A;, . . ., Ai BEFORE A;). Resources RI and Rz, R3 and R5 are substitutable; resource R4 is a bottleneck. Suppose that the current focal-job is Js and the current focal-activity is A:. The indices used to retrieve the similar cases from the case base are calculated as follows: (i) Global features: l Weighted tardiness: In this particular case, the weighted tardiness of the whole schedule is 460. l Resource utilization average: This feature can be calculated as the ratio of overall utilization of resources to overall availability of resources. The value of this feature is 0.544. a Resource utilization deviation: The deviation of resource utilizations across the different resources is equal to 0.032. (ii) Local features: l Waiting time: This feature is defined as the time elapsing between the comple- tion of the preceding activity (A!) and the start of the present focal activity (A:). In our case, it is equal to 1180 - 620 = 560. l Predictive-shift-gain: This feature is computed in CABINS as follows: predictive_start_time - current-startfime waitingdime x repairability where predictive-start&me is defined in Section 4.4, currentstart-time and waiting-time are the parameters associated with focal activity. We heuristically estimate the repairability within the given repair time horizon by a hyperbolic tangent function. For our example, the value of predictive-shift-gain for Ai is 0.705. K. Miyashita, K. Sycara/Ar@cial Intelligence 76 (1995) 377-426 397 job1 job2 Machine 1 Machine 2 Machine 3 Focal activity: u Conflict set: (TLJ(YJ(xJam Utility function for I Utility function for I After left-shlft I\ After adjustment h After adjustment Machine 3 I!!!!!L Time Horizon ; 5; 2 r3 A Fig. 6. Example of repair tactic application: leftshift. l Predictive alt shift gain: The calculation of this feature to that In this case, since the required resource of activity Ai resources, resource, R4, that does not have any substitutable is very similar of predictive-shift-gain. is a bottleneck the value of predictive_aZtshift-ggain is 0. K. Miyashita. K. Sycara/Art@cial Intelligence 76 (1995) 377-426 Fig. 7. Original schedule results. l Predictive swap gain: To calculate predictiveswap_gain, CABINS uses the is cal- (see Section 4.4). For this example, predictiveswup-gain but the predictivestart-time same formulas as for predictiveshifkgain, culated differently is 0.96. l Predictive alt swap gain: The value of this feature bottleneck resource R4 which does not have substitutable is 0 since Ai requires resources. the Case-based retrieval is performed with the global and local indices. It turns out that in Appendix A as the most similar and thus case-based selected swap as the repair tactic for the focal-activity At. the case shown retrieval found to the primary it may appear that it would be better To apply swap, CABINS calculates constraint violations. From Fig. 7 we can see that actually the activity with which Ai will be swapped. To do the activity which, if swapped with A:, will result in least amount there are five the repair horizon. These activities are: Ai’, AZ, A:, if Ai was swapped it is this, CABINS selects of precedence activities swappable with Ai within Ai and A:. At first glance, with Ai0 because by doing so A! will be finished as early as possible. However, not the best choice since if Ai is swapped with Ai”, it will cause a lot of downstream repair effects as localized as ripple effects contrary to swap possible. After calculation Ai with Ai. Job J4 has weight 3 and weighted tardiness 3 x (1370 - 1320) = 150. on R4 and Ai The effect of applying to start at time 1090 (the start time of activity Ai prior to the swap). is re-scheduled Due to the larger duration of activity At, now there is the ripple effect of a precedence constraint violation between activity Ai and its successor activity A: on resource R2. (In general, many activities could be affected and must be re-scheduled in Section 4.4) _ Constraint propagation discovers this constraint conflict and shifts activity At further to the right on resource R:! resulting in the repaired schedule shown in Fig. 8. Then, the effects of repairing Ai are calculated. CABINS estimates the local effects on the swap tactic is that Ai and Ai are unscheduled of the estimated possible effects, CABINS decides intention of keeping as described the focal-job did not change but .& had an estimated decrease and an estimated decrease of 150 units and an increase .& and calculates global effects on the whole schedule. Machine utilization tardiness of 180 time units tardiness is in WIP of 200 units; 8 J4 had an increase in WIP of 750 units. Global weighted in weighted tardiness decrease in weighted 8 These decreases cannot be precisely determined until the last activity of Js, A!& is repaired. K. Miyashita, K. SycaraIArttjkial Intelligence 76 (1995) 377-426 0 399 00 Fig. 8. Schedule results after repair on A:. 180 - 150 = 30 and global WIP increase is 750. CBR is invoked using these effects and applied repair tactic as indices to determine whether this repair outcome is acceptable. If there are more success cases than failure cases in the retrieved k-nearest neighbors, it is considered that the effects reflect tradeoffs in the user’s preferences (in this example, little weight on WIP) and the outcome is considered acceptable. If, on the other hand, a failure case is retrieved, then the outcome is considered unacceptable, reflecting the user preferences for minimization of weighted tardiness without the expense of increasing WIP. In this example, CBR invocation with effects as indices retrieves as the closest match- ing case, the case shown in Appendix B, where the effects match the effects associated with the swap repair tactic. Therefore, the outcome is deemed “acceptable”. 5. Evaluation of the approach We conducted a set of experiments to test the following hypotheses: (i) Our approach is potentially effective in capturing user preferences and optimiza- tion tradeoffs that are difficult to model. (ii) Our approach improves schedule quality irrespective of method of initial sched- ule generation. (iii) Our approach produces high quality schedules at much lower computational cost as compared to simulated annealing, a well-known iterative repair method. (iv) Our approach is suitable as a reactive scheduling method because it maintains high schedule quality and minimizes disruptions in the face of execution time failures. These hypotheses are difficult to test since, due to the subjective and ill-defined nature of user preferences, it is not obvious how to correlate scheduling results with the captured preferences or how to define quality of a schedule whose evaluation is subjective. To address these issues, we had to devise a method to test the hypotheses in a consistent manner. To do that, it is necessary to know the optimization criterion that would be implicit in the case base, so that the experimental results can be evaluated. In the experiments reported here, we used two different explicit criteria (weighted tardiness; 400 K. Miyashita, K. Sycara/Artificial Intelligence 76 (1995) 377-426 (RBR) reasoner tardiness) to reflect repair process the user’s optimization the RBR was constructed that goes through a trial-and-error not to select criteria and built a rule- WIP + weighted to optimize based the same repair action after a schedule. Since it could go through application of a selected repair tactic was evaluated as unacceptable, of a all the repair actions before giving up further repair. Each of these applications repair action would be gathered in the repair history of the case for the particular activity under repair. For each repair, the repair effects were calculated and, on this basis, since the RBR had a predefined the repair outcome objective, rules each time to generate different consistently. Thus, we used the RBR with different case bases, each for a different explicit optimization objective. Naturally, an objective, though known to the RBR, is not known to CABINS and is only implicitly and indirectly reflected RBR so it could be reflected baseline against which to evaluate in an extensional way in each case base. By designing the schedules generated by CABINS. case base, we got an experimental in the corresponding it could evaluate an objective evaluation into the instances. In particular, the distribution the approach on a benchmark such as number of bottlenecks, to cover a broad range of parallel machine the benchmark problems have the following a sequence where each job must visit bottleneck suite of job shop scheduling problems We evaluated range of due dates and activity where parameters, job shop scheduling durations were varied problem structure: each problem has ten jobs of five activities each. Each job has a linear process routing after a fixed specifying tighter. so as to increase resource contention number of activities, Two parameters were used to cover different scheduling a range parameter, RG, controlled of job due dates and release dates, and a bottleneck parameter, BK, controlled not unintentionally the overall problem structure described used a problem generator instances where the problem parameters above to generate parallel each were six groups of ten problems were varied (static, randomly generated by considering moderate, dynamic), ( 1 and 2 bottleneck and two values of the bottleneck configuration problems). The slack was adjusted as a function of the range and bottleneck parameters to keep demand to 100% over the major part of each problem. Durations function job shop scheduling in controlled ways. In particular, resources and make the problem conditions: that we had into the solution strategies, we three different values of the range parameter resources close in each job were also randomly generated. “in hardwired knowledge of the problem the number of bottleneck resources. To ensure for bottleneck that embodied problem scheduling Generating for activities instances variation of problem parameters knowledge-based methods (e.g., features of problem 2 machines machines problems carries over even if the number of jobs etc), and CBR can exploit for transfer [40,41] ) . The problem are bottlenecks, structure communities the neighborhood” is a well-accepted method of a problem by controlled in Operations Research and the performance of scheduling shared (e.g., each problem has five machines, of which 1 and and substitutable machines exist for the non-bottleneck randomly generated, for evaluating instances, although to later problem solving. the captured regularities It is interesting in the structure of the to note that this transfer is varied (see Table 5). The benchmark problems and used as a benchmark sets are, however, different are variations of the problems originally by a number of researchers in two respects: in 1401 (e.g. 135,271). Our problem for (a) we allow substitutable resources reported K. Miyushita, K. Sycara/Art$cial Intelligence 76 (1995) 377-426 401 non-bottleneck resources, thus solving the parallel machine rather than the simple job shop scheduling problem, and (b) the due dates of jobs in our problems are tighter by 20 percent than in the original problems. A cross-validation method was used to evaluate the capabilities of CABINS. Each problem set in each class was divided in half. The overall training sample, consisting of 30 problems, each of which has 50 activities, was repaired by RBR to gather cases. As has been explained in the section on case acquisition (Section 4.2), a case is acquired for each activity that is the current focal-activity (irrespective of the number of tactics available or number of tactics used in the activity’s repair). Of course, an activity (and consequently a job) may be repaired more than once during an overall repair cycle, since it is repaired as a focal-activity but also as an activity in the conflict set of another focal-activity, and thus must be moved. Allowing each activity to be a focal-activity once for each problem would give a maximum of 30 x 50 = 1,500 cases for each training sample (for each different experimental optimization objective). In practice, some of the activities did not become focal-activities to be repaired because they did not have enough upstream slack (see Section 4), so that for each training sample, CABINS was trained with approximately 1,100 cases. These cases were then used for case-based repair of the validation problems (the other 30 problems). We repeated the above process by interchanging the training and the test sets. Reported results are for the validation problem sets. Since it is not possible to theoretically predict the bounds of repair or the global optimum, in the experiments, CABINS was allowed to run for three overall repair cycles. 5.1. Preference acquisition To test the hypothesis that CABINS could acquire user preferences, we constructed through RBR two case bases, the first to reflect the user’s preference for repairs that minimize weighted tardiness and the second to reflect the more complex criterion of minimizing the combination of weighted tardiness and WIP. The cases constituted the only source of knowledge for CABINS. In other words, there was no objective given to CABINS explicitly. The case bases were used both as a source of suitable repairs, and also as a source of advice regarding repair evaluation. Graphs in Fig. 9 show the comparison of the performance by CABINS using “weighted tardiness” case base (labeled in the graphs as CABINS( WT) ) and the performance by CABINS using the “weighted tardiness and WIP” case base (labeled in the graphs as CABINS( WT + WIP) ) . From the results, we observe that CABINS gen- erated higher quality schedules with respect to minimizing weighted tardiness than CABINS( WT + WIP) in all six problem classes. Conversely, CABINS(WT + WIP) generated higher quality schedules with respect to WIP, and weighted tardiness plus WIP than CABINS tries to optimize a schedule only in terms of weighted tardiness and neglects WIP, but CABINS ( WT + WIP) takes into account the tradeoffs between weighted tardiness and WIP in schedule repair. These results indicate that CABINS can acquire different and subjective user preferences on the tradeoffs of diverse objectives in scheduling from the cases. Thus in our approach, unlike traditional heuristic scheduling approaches [ 13,311, in the all problem classes. In a nutshell, CABINS 402 K. Miyashita, K. Sycara/Art@cial Intelligence 76 (1995) 377-426 2500 500 0 1000 800 600 400 z t ‘2 z P E .F s 200 0 2000 1600 400 0 CABINS(WT+WIP) m CABINS(W) 1 2 3 4 5 6 Problem Set . . . . . . . . ..___._.______..~............._......__...~~~~~............-~~.~~~~...........-.- CABINS(WT+WIP) m CABINS 1 2 3 4 5 6 Problem Set m CABINS 1 2 3 4 5 6 Problem Set Fig. 9. Scheduling results with different case bases. K. Miyashita, K. Sycara/Art@cial Intelligence 76 (1995) 377-426 403 Table 1 Repair by RBR and CABINS Repair by RBR Repair by CABINS WT 375.2 405.3 WIP 1446.6 1195.0 WT+wIP 1821.8 1600.3 CPU Sec. 498.6 296.5 scheduling objectives. represented to suit the optimization criterion. Only In addition, unlike dynamic pro- and so on, our approach doesn’t require an for inducing more for different optimization form of user’s objectives to devise a particular heuristic function. CABINS has the potential approaches such as branch-and-bound, search-based tabu search, simulated annealing objective it is not necessary the case base must be changed traditional gramming, explicitly complicated from the cases. It is true that user’s objectives could be elicited by intensely domain experts and represented to gather cases RBR modules quisition laborious that even a domain expert cannot have a sufficient knowledge ule efficiently efficient control model rules. in the form of rules as we have done [ 371 and (2) a scheduling problem in the experiments. But, (1) from the cases obtained [ 191. Nevertheless, is so ill-structured for making a good sched- the CBR-based methodology of CABINS can induce of insufficient situations) interviewing in constructing (e.g. allowing handling of exceptional rule-based knowledge the applications is extremely through ac- In another set of experiments with objective WIP + WT, we used RBR itself to repair is about 40% more the quality of schedules by about 12% that repair by CABINS the set of test problems. Table 1 shows efficient than repair by RBR and more than repair by RBR. A potential explanation in Section 4.3, CABINS can effectively utilize (Refer failure to [ 341 for more details and some experimental it improves for these results information results.) is that, as described stored in the cases. 5.2. Predictive and reactive scheduling We evaluated CABINS against other scheduling methods using standard criteria (e.g. revision quality. These criteria are also appropriate schedule for evaluating how many changes [36,54]) for planning. These criteria were: (a) Attendance quality of the revision with respect of disruption: of revision: how quick be responsive rapidly as possible? Although we subscribe and schedule we have described our experiments Schedule quality and efficiency is the revision process? to schedule execution to the original and reactive schedule management. Responsiveness crucial during handling of schedule execution the schedule quickly and allow execution is most executing, reactive management to preserve continuity during it is important important to the desired optimization to scheduling objectives: what it the (b) Amount criteria? (c) Efficiency In particular, can the revision process to proceed as schedule are made? in the sense of allowing execution in two separate subsections 5.2.1 and 5.2.2. in both predictive is important of the schedule failures (and opportunities) schedule generation revision process is to patch up to proceed. Minimizing of a schedule. Once a schedule of domain activity, since schedule disruption starts there could to the view that both schedule generation repair can be viewed as an iterative repair process, for ease of readability, 404 K. Miyashita, K. Sycara/Art@cial Intelligence 76 (1995) 377-426 be substantial cost in having to attend to discontinuities introduced by reactive schedule revision (e.g. set-up costs when resource assignments have been changed). These criteria must be balanced and traded off against each other. The results show that in predictive schedule generation, the methodology improves the quality of schedules generated by a variety of scheduling methods and also gener- ates schedules of higher quality along a variety of optimization objectives with lower processing cost as compared to simulated annealing, a well-known iterative optimization method [ 1554,241. In recovering from execution time failures, the approach ( 1) attends to schedule quality both in terms of optimization objectives, and disruption, and (2) is responsive in that it allows continuation of execution without delays in response to execution failures. 5.2.1. Predictive schedule repair In predictive schedule repair, the primary objective in our experiments was to optimize schedule quality at a low computational cost. To investigate our experimental hypotheses, we compared CABINS with simulated annealing. Simulated annealing (SA) is a well- known iterative improvement approach to combinatorial optimization problems, which is reported to be able to yield solutions of better quality at the cost of larger computational efforts in a number of combinatorial optimization domains, such as computer-aided design of integrated circuit, image processing and neural network theory [ 16,151. SA has also been applied to job shop scheduling domain for the makespan objective and is reported [24] to have a potential of finding shorter makespans than the state-of-the-art tailored heuristic, e.g. shifting bottleneck procedure [ 11. The details of our SA implementation are given as follows: (i) Generate an initial schedule. (ii) Select an activity randomly. (iii) Unless all the available repair actions have been tried, do the following: (a) Select a repair tactic among the remaining untried repair tactics; (b) Apply the chosen repair tactic to the activity under repair; (c) Evaluate the resulting repaired schedule with respect to the explicit objective (WIP+WT); (d) If the resulting schedule is better than the schedule before repair in terms of the objective, then the revision procedure goes on to repair next randomly- chosen activity; otherwise the revision procedure goes on to repair next randomly-chosen activity with probability exp( -A/Temp), in which A is defined as the difference of schedule evaluations after repair and before repair. The temperature Temp is updated (decreased by a fixed percentage every time) when a fixed number (currently 250) of repair actions have been applied and the revision procedure will be terminated if a pre-set maximum computational effort has been reached. We ran each experiments 5 times and reported the best results among these 5 separate runs (since SA incorporates a probabilistic factor, the results are not necessarily the same across the different experimental runs). In order to test the generality of the approach, we repeated the same set of experiments K. Miyashita, K. Sycara/Art$cial Intelligence 76 (1995) 377-426 405 Table 2 Repair by CABINS and SA based on different methods of initial schedule generation Schedule by EDD Repair by CABINS Repair by SA Schedule by WSPT Repair by CABINS Repair by SA Schedule by R&M Repair by CABINS Repair by SA Schedule by CBS Repair by CABINS Repair by SA WT 956.0 349.5 340.5 584.0 321.0 328.5 556.0 305.3 330.1 1173.0 405.3 395.5 WIP 1284.6 1311.2 1333.4 1241.0 1254.9 1320.4 1242.0 1264.9 1290.8 1481.0 1195.0 1220.0 WT$WIP CPU Sec. 2240.6 1660.7 1673.9 1825.0 1575.9 1648.9 1798.0 1570.2 1620.9 2654.0 1600.3 1615.5 0.1 73.5 388.2 0.1 72.1 398.3 0.1 84.9 450.5 17.4 296.5 1380.0 the each time initial where (seed) schedule was generated using a set of 4 times, well-regarded dispatch heuristics and a constraint-based scheduler (CBS). The dispatch rules selected to generate the initial schedule are widely used in practical job shop scheduling problems, namely the Earliest Due Date (EDD) rule, the Weighted Shortest Processing Time (WSPT) rule and the WSPT with order time urgency factor (R&M) rule. These heuristics have been reported to be particularly good at reducing tardiness under different scheduling conditions [ 3 I]. We also used the constrained-based scheduler (CBS), which uses ARR variable ordering heuristic and GV value ordering heuristic with pre-determined biased start time utility functions (see Section 2.3). In our experiments, the user’s objective function was assumed to be minimizing a weighted linear combination of work-in-process inventory (WIP) plus weighted tardi- ness. This is a multi-objective function that is difficult to optimize heuristically. WIP and weighted tardiness are not always compatible with each other. There are situations where WIP is reduced, but weighted tardiness increases. Table 2 presents the average results of all 60 problems in the benchmark. Based on the results, we make a variety of observations. First, CABINS improved the initial schedule across all scheduling methods according to the objectives. It should be noted that these dispatch heuristics have been extensively used in Operations Research experimentation with very good results [ 4,331. The initial schedules generated by the dispatch heuristics can be considered as local minima, in the sense that they cannot be easily improved. For example, these initial schedules are very tight, in that there is no on-purpose machine idleness. We conjecture that it would be more difficult to improve an initial schedule with higher quality. For example, it would be more difficult to improve an “R&M”- generated schedule than an “EDD”-generated one. The experimental results support this conjecture (EDD-generated schedule has been improved by 25.9 percent and R&M- generated schedule has been improved by a 12.6 percent). Second, we observe that the better the quality of the initial schedule, the better the quality of the repaired result. Third, CABINS generated schedules of comparable quality but was on the average 4-5 times more efficient than simulated annealing. It seems that the contextual information 406 K. Miyaslzita, K. Sycara/Artijkial Intelligence 76 (1995) 377-426 Table 3 Repair by CABINS on randomly generated initial schedules Initial schedule Repair by CABINS Repair by SA WT 3875.0 1740.0 1723.8 WIP 1470.5 1432.5 1418.6 WT + WIP CPU Sec. 5345.5 3172.5 3142.4 0.1 81.2 323.3 in the CABINS case base and the system’s use of failure information captured repair history making CABINS much more efficient is effectively used to guide the search and prune unpromising than the random search of simulated annealing. in the paths thus and resource constraints is randomly generated constraints To further investigate CABINS’ behavior vis a vis initial schedule generation method, training and test sets of 5 resources and 10 jobs problems. The initial we again used from scratch. To do this, we took for each problem schedule due date the precedence into account the constraints) so generation of an executable qualities of these initial schedules are very low (compared to the ones generated by the dispatch heuristics and CBS). From the Table 3 we can see that CABINS also performs schedules. The behavior of CABINS with well on generated regard to the method of initial schedule generation confirms in the Operations Research community better based methods, and also the min-conflict the is also consistent with the behavior of other repair- in our experiments, annealing schedule was guaranteed. As expected, the quality of the initial solution, the behavior of simulated [ 3 1 ] ) that the higher satisfaction problems heuristic’s behavior these randomly solution. This for example (disregarding the repaired intuitions [ 301. initial (e.g. for constraint results we got so far are: to ascertain experimental Other interesting - Evaluation of revision control model learning. We conducted another set of exper- learning of the control model learning were obtained by and application for that repair did not improve schedule quality of selection repair. The results showed the repair actions. The results without iments for selecting random, not case-based, activity approximately 90% of the example problems. of the same repair the effectiveness of case-based tactics is likely to remain environments, in real operating the same for reasonably the factory configuration relatively - Evaluation of scalability. To test the scalability of our approach we generated an set of 60 problems each with 20 jobs, each of which uses 5 resources. additional (e.g. number Usually, long and type of machines) to fluctuate due to varied periods. The number of jobs, however, customer demands in and other economic our experimentation, we focused on varying number of jobs rather than number of from the same problem generator resources. The 20-job problems were generated function by varying in controlled ways, The knowledge acquisition method was the same as for the lo-job i.e. RBR was used to acquire a training case base with 30 problems each problems, approach. The of which has 20 jobs and 5 resources. We also used cross-validation pattern of results was the same as for the first set of 60 problems. The results are shown is very factors. Based on these assumptions, (as for the set of IO-job problems) the same parameters in Table 4. likely - Evaluation of knowledge transferability. In order to test generalization issues in K. Myuslzita, K. Sycara/Art@cial Intelligence 76 (1995) 377-426 407 Table 4 Repair by CABINS on 5 resources and 20 jobs problems Schedule by EDD Repair by CABINS Schedule by WSPT Repair by CABINS Schedule by R&M Repair by CABINS Schedule by CBS Repair by CABINS WT 2106.8 648.5 718.4 561.2 709.5 548.6 2396.5 692.2 WIP 5440.3 5538.4 5310.2 5332.1 5218.3 5237.8 6260.7 6246.0 WT+w1p CPU Sec. 7547.1 6186.9 6028.7 5893.3 5927.8 5786.4 8657.2 6938.2 0.3 171.0 0.5 190.0 0.6 164.5 203.0 880.0 Table 5 Repair on 5 x 20 problems using case base collected from 5 x 10 problems Schedule by EDD Repair by CABINS Schedule by WSPT Repair by CABINS Schedule by R&M Repair by CABINS Schedule by CBS Repair by CABINS WT 2106.8 824.5 718.4 633.7 709.5 598.2 2396.5 924.2 WIP 5440.3 5429.4 5310.2 5342.1 5218.3 5229.9 6260.7 6252.1 WT + WIP CPU Sec. 7547.1 6253.9 6028.7 5975.8 5927.8 5828.1 8657.2 7176.3 0.3 234.2 0.5 222.0 0.6 194.5 203.0 973.8 learning of acquired knowledge, still performs very well on the bigger problems using transferability the 5 resources and 10 jobs benchmark problems (1) we collected and case-based (using the cases through solving in Step 1 to solve the 5 resources RBR) and (2) we used the case base collected and 20 jobs problems. The results are shown in Table 5. We see that although the results we got based on 5 resource and 20 jobs case base are better (reported the in Table 4), CABINS original 5 resource and 10 jobs case base. We also see that the pattern of CABINS behavior, of initial schedule generation still holds. acquisition From encouraging. They show that CABINS has potential factory environments, acquisition of scheduling and practical point of view, the results are quite in operational the knowledge and quality for application transferability will alleviate burden without much affecting overall system performance since knowledge schedule quality the knowledge i.e. improving independent results. 5.2.2. Repair in response to unpredictable execution events Reactive schedule repair involves (1) recognition of the conflicts in the schedule as a result of an unexpected and uncontrollable environment, repair action. Before we present and discuss criteria and results, we present (2) propagation the experimental the reactive repair steps taken by CABINS. of the conflicts, and (3) selection and application of a hypotheses, evaluation that are introduced in the execution change 408 K. Miyashita, K. Sycara/Artifcial lntelligerzce 76 (1995) 377-426 The first step in reactive repair is the recognition of conflicts introduced in the schedule as a result of unexpected events in the execution environment. In general, there are two types of conflicts that can be recognized: l Temporal conj?icts: These are conflicts reflecting inconsistencies between the sched- uled and actual start and end times of activities. l Resource conjlicts: These are conflicts reflecting inconsistencies in the resource capacity currently available and the capacity required for processing activities. In the second step, the effects of the introduced conflicts are propagated downstream (forward in time) from the point in time where the unexpected event happened (right- shifting). This involves undoing the reservations that become inconsistent as a result of the unexpected event and propagating their effects to determine the consequences (ripple effects) of the unexpected event for the rest of the schedule. The result of this step is a feasible schedule but typically of much worse quality than the predictive schedule before the occurrence of the deleterious unexpected event. In the third step, CABINS is used to repair the suboptimal schedule that resulted in the second step. The mechanisms that CABINS uses in reactive repair are exactly the same used for predictive optimization (except, of course, that no attempt is made to repair activities that have being already executed before the unexpected event happened). If the unexpected event is loss of capacity (e.g. a machine breakdown), the activity that was being processed on the resource at the time of breakdown must also be re-scheduled. We illustrate the repair process by an example. Fig. 10 shows a predictive schedule for one of the problems that were used for experimentation with predictive schedule optimization (see Section 5.2.1). In particular, it is one of the two-bottleneck problems with static start time for all jobs. In this schedule, the weighted tardiness is 240 units. After computing the predictive schedule, a machine breakdown is created in the middle of the schedule. The broken machine, M, is the busiest non-bottleneck machine. The breakdown was timed to occur at the first 20% of total execution time so as to increase its deleterious effects on the rest of the schedule. The estimated duration of the breakdown was 10 times the average duration of the activities in the problem. M is assumed available for processing at the end time of the breakdown. The effects of the breakdown are propagated downstream (forward in time). In par- ticular, the activities that were scheduled on the broken machine M and whose scheduled reservations overlapped with the time interval of the breakdown, are unscheduled and in the same sequence on M after the end time of the breakdown (this re-scheduled has been called right-shifting in [ 361) . Right-shifting of these activities on M typically results in constraint conflicts of related activities that are fixed by the constraint prop- agation mechanisms in CABINS so that a feasible but worse schedule results. Fig. 11 shows the schedule resulting from the machine breakdown and its propagated effects. The weighted tardiness of this schedule is 4500, a more than lo-fold worsening of qual- ity. Delaying schedule execution till M is fixed, which is equivalent to right-shifting, is clearly not an option in practice. It is of the utmost importance that the schedule be repaired to enable execution continuity. CABINS is applied to repair the schedule of Fig. 11. Because of the big delays that arise as a consequence of capacity loss, we assume optimization of weighted tardiness as the repair objective. Fig. 12 shows the schedule resulting after repair by CABINS. o---____8  410 K. Miyashitu, K. Sycara/Artijiciul Intelligence 76 (1995) 377-426 (though no measure of disruption was given in previous revision of the existing schedule. It repair process that achieves efficient of execution while of high quality schedule disruption would be the most desirable. To date no experimental and also allows continuation schedule disruption increase work). A third repair strategy could be incremental has been argued in the literature that an incremental generation minimizing evidence has been provided re-scheduling, all the above repair objective We demonstrate CABINS’ (a) or (b) exhibiting schedules simultaneously. reactive capability with respect in favor of incremental an incremental repair approach schedule repair as opposed to that performs well on time failures, to execution since they are the ones that typically happen and against which a scheduling system must guard. In the set of experiments we performed, CABINS was used to repair a predictive loss. CBS was used for re-scheduling. Our schedule is experimental superior failures along all the desirable evaluation criteria. reactive schedule repairs in response repair methodology of CABINS to unexpected capacity that the incremental results demonstrate to re-scheduling in performing to execution in response We measured disruption with respect to three criteria: (i) Difference of start times between the repaired schedule and the original predic- tive schedule (before occurrence of the unexpected capacity loss). in the repaired versus the original (ii) Difference in resource assignment of activities schedule. (iii) Difference in sequencing of activities on a resource in the repaired versus the original schedule. These changes between since routing, changes job finish in start times may cause changes the repaired and the original they could cause changes and expected of schedule disruption source set-up activities, process in a manufacturing environment, for product warehousing, material preparation resource assignments may change product routings to change programs of material handling need vehicles); set-ups and worker assignments. continuation of such changes depends on the nature of the manufacturing layout. Therefore, a unified measure of disruption of a schedule schedule qualify as measures in re- (with attendant costs) times. For example, in plans and product shipment plans; change of in the (such as automated guided in machine in the smooth the degree of severity process and the factory floor in activity sequencing on a machine may cause changes of schedule execution on a factory floor. Obviously, Such changes cause serious difficulties in the factory floor resulting is hard to formulate. equipment changes We compare the performance two different machine breakdown In the first experiment, activity duration, experiment, problems. a machine breakdown, whose duration of reactive scenarios, repair against CBS re-scheduling each of which has 10 sets of problems. the average is 10 times resource problems, and in the second in the is simulated on the two-bottleneck a similar machine breakdown is simulated on the set of one-bottleneck Table 6 shows the average results across all experiments. The results show that in terms of disruption scheduling by CBS. However, CABINS’ efficiency problems, time as CBS. such as Problem 1 for example, CABINS and quality CABINS outperformed re- is much worse than CBS. In some spends as much as 40 times more K. Miyushita, K. Sycara/Art@cial Intelligence 76 (1995) 377-426 411 Table 6 Reactive repair vs re-scheduling Start time disruption Routing disruption Sequencing disruption Repaired wei. tar. (%) CPU time (seconds) CABINS reactive repair 6380 9 21 98.8 112.9 CBS(GV) re-schedule 8980 11 27 91.6 6.7 result quality However, upon further examination, this result is misleading. The reason repair behavior of CABINS. As shown than CBS at the time point when CBS is the rapid in Fig. 13, for example, CAB- finished From Fig. 13 we see that after 9.3 seconds, CABINS has achieved a in to the re-scheduling method reactive incremental if the repair the schedule produced by CABINS can be executed the same and monotonic INS achieved better re-scheduling. weighted the same which does not provide repair results process is stopped after 9.3 seconds, and is of higher quality time period. This behavior was consistency tardiness of 1430 units compared time period (9.3 seconds). Since, schedule incremental in contrast feasibility, CABINS than the one produced by CBS re-scheduling to 1560 units achieved by re-scheduling schedule after every repair iteration, exhibited in all experiments. in a feasible (executable) during System responsiveness in reactive contexts is of great concern. To see whether the the ex- In each the breakdown duration was 4, 6, 8, and 10 times the average activity dura- is very efficient is possible. This characteristic of results of Fig.13 are robust across different breakdown periments with four different variations of duration of machine breakdown. experiment, tion. Fig. 14 shows those results. The graph shows that reactive repair at first and then saturates until no further improvement CABINS’ repair process of execution with minimal delay rapidly). for reactive repair since it allows continuation (most of the schedule quality scenarios, we repeated loss is repaired very is very suitable 5.3. How many cases are “enough”? The graphs in Fig. 15 compare the performance of CABINS with different sized case bases. The results were obtained based on CABINS with WT + WIP type of case bases. A case of approximately 4,500 cases was generated by RBR. This was done by allowing 3 overall repair cycles for a training set of 30 problems each of which has 50 activities. To get the case bases of different sizes, an appropriate number of cases for each situation was randomly 4,500 size case base. This a new case base by random deletion of cases from a bigger case method of generating in [ 51. The initial schedule generation base is similar to the ablation study performed an interesting question method was CBS. From the viewpoint of knowledge acquisition, can be terminated because sufficient knowledge has been is when knowledge acquisition acquired system. For case- this question becomes how many cases would be enough based knowledge to enable high quality performance from the approximately of a knowledge-based selected and deleted acquisition, 412 K. Miyashita, K. Sycara/Art$cial Intelligence 76 (1995) 377426 1000 1 owo 1ooQoa CPU time [msec] 1OWWG Fig. 13. Repair responsiveness of CABINS in Problem 1. for knowledge capture and re-use and for guaranteeing overall satisfactory performance. Unfortunately, it is very difficult to answer this question in general due to the ill- structuredness of the scheduling problem and the approximate nature of CBR (since no causal model is available). We believe, however, that there exists some appropriate size of the case base which will give us relatively satisfactory results in terms of schedule quality without excessive overhead for case acquisition or case retrieval from the case K. Miyashita, K. Sycara/Ar@cial Intelligence 76 (1995) 377-426 413 c _ -m Machine Breakdown (4 average durations) Machine Breakdown (6 average durations) o- -e Machine Breakdown (8 average durations) - Machine Breakdown (10 average durations) 0’ 100 1000 10000 1WJOoO - lLnxn3JO CPU time [msec] Fig. 14. Repair ratio. results (Fig. 15) support the number of cases, this hypothesis as follows: Our experimental (i) The larger the increase marginal explained partially by the fact that some number of cases capture well characteristics may give much redundant the in case base size decreases. This can be loo0 cases) of the problem space, and additional 1000 new cases the size of case base is relatively information. When the schedule quality. However, the better payoff from (say, 414 K. Miyashita, K. SycurdArtificial Intelligence 76 (1995) 377-426 &2600- 3 +2400. I E e2200’ tij :2000- 0 %600- g 1600. 1400. 1200’ 1000. 600. I-- CABINS(WT+WIP): - - CABINS(WT+WIP): - CABINSIWT+WIPk ..... CABINS(WT+WIPj: 500 cases 1 1000 cases 1500 cases I 2000 cases sooo 1 2 3 4 6 5 Problem Set I 100 I I 0 500 1000 1500 2000 Number of Cases in Case-Base Fig. 15. Effect of case base sizes in quality and efficiency. (ii) time new cases are acquired, we may get information small, every different part of the problem space which results in higher quality In terms of efficiency of the system, we observe from the graphs that the case base with 1000 cases might be the optimal choice. Actually, both in terms of CPU outperforms improvement, payoff proportional the case base with 1000 cases obviously in terms of schedule quality to provide the case base with 500 cases. Moreover, than 1000 cases do not seem to the case base size increase. case bases with more time and quality improvement. improvement, about a 5.4. Discussion The experimental results show that the CBR-based repair method not only has the po- to capture different user optimization preferences but also performs well in terms scheduling repair-based method, CBR- schedules of high quality as compared with other constructive annealing, another schedules of comparable quality with substantial computational repair exhibits desirable anytime characteristics and in terms of mini- by a constructive constraint-based method tential of producing methods. As compared with simulated based repair produces savings. outperforms mizing disruption In addition, CBR-based and maintaining re-scheduling high schedule quality. to answer In this section, we will attempt the question “what makes the power of the approach stems from the following powerful”? We believe First, as has been pointed out by others making available a complete assignment more only a partial assignment the approach four reasons. approaches by for our domain) provide that can guide search as compared with constructive methods where revision method captures such is available. Our CBR-based (a complete schedule revision-based information [ 30]), (e.g. K. Miyashita, K. Sycara/Artijicial Intelligence 76 (1995) 377-426 415 belongs problems, information information it as contextual domain information job shop schedule optimization in global case features and exploits such as repair failed applications regularities, about failed cases relevant to the during case retrieval. Second, although the case features were able to capture some category of “hard” NP-complete flexibility. This was complemented by important in the repair case history of revisions keeping failures were exploited by in the case memory. These and also keeping paths in the search space in future similar situations. Third, CBR to prune unpromising that in Section 5.3 support experimental the acquired and used in the reported experiments the cases CABINS solution space in a fairly evenly distributed repair to take advantage of this coverage. Since, however, we cannot conjecture whether good in the search space as a whole, backtrack search, quality solutions are evenly distributed if good solutions are “bunched up” in for example, could be potentially particular parts of the search space [ 30,251, whereas dispatch heuristics are too myopic to take advantage of promising the hypothesis seem to cover results and discussion presented thus allowing CBR-based search paths. disadvantaged fashion, transfer in solving satisfiability, this information in cases during is very difficult to job shop optimization “easy” or “hard” problem that some of the regularities analysis has been performed in a theoretical way. In contrast in the structure of the experimental to solve the test problems. Moreover, to answer (e.g. graph-coloring, then arises to what extent the information can size as the results training with a set of lo-job problems were effective the training phase and this information was seems to transfer also in Table 5 indicate. The table shows that the cases test captured problems structure. This question, albeit of great theoretical and practical to other NP- for which (e.g. [ 32,8] ) as to their structure and properties of job shop (e.g.[ 8,4] ). Due it is not known what i.e. what features of a problem make it difficult or easy similar or different from another. It is for this flowtime finds the for It is only after some proposed problem has defied solution by to be Finally, we believe problems were captured transferable across problem acquired during problems with 20 jobs. The question in cases from one set of problems with different problem importance, complete problems insightful that characterize schedule optimization to the tight constraint constitutes “problem to solve, or make one problem substantially reason for one-machine optimal solution, a particular extensive difficult problem structure not help with our analysis but instead aims at capturing problems where it has been proven it is currently to characterize criteria, this would function, problems inter-dependencies structure”, such as minimize that the WSPT heuristic since CABINS does not have an explicit objective in job shop optimization, with explicit optimization that, except for some simple optimization to theoretically prove schedule optimality is currently an open research problem technique. experimentation instances, similar characterization if there were good approaches in job shop optimization, that it is understood context-dependent user preferences. [ 1,4]. Most importantly, researchers objectives, impossible salesman) by many implicitly traveling ipso facto even 416 K. Miyashifa, K. Sycara/ArtQicial Intelligence 76 (I995) 377-426 6. Related work Our work shares the same motivations and goals with the work in [28] where for interactive user manipulation the user’s manipulation that is made. This information motivations the system monitors each revision knowledge. The approach seems promising but has not been experimentally is rooted on concepts and mechanisms [ 12,46,40]. of schedules of a schedule, is presented. requesting is then used to augment/refine scheduling of a long that work, schedules and merging partial schedules. That work has extensively in are generated by line of research In tested. the In that work, for the system’s the reasons and aspects of this scheduling methodology and has procedures tradition has come to view scheduling techniques and for constraint-directed as an opportunistic it has operated under static design assumptions (e.g. deterministic constructing various properties sophisticated this research Our approach constraint-directed incrementally investigated proposed Although process, of variable and value ordering heuristics model art by learning and by adapting and user preferences of repair actions for application to dynamically and tradeoffs. adapt the focusing mechanism the repair model according to current problem of the search procedure solving circumstances scheduling. repair application level the state of the control in 1401, or statically determined [36]). Our approach advances [53]. speed [29,30] heuristic, constraint lookahead scheduling for solving to improve perturbations to a conflict that chooses from a one-step [52] has studied and its performance the N-queens problem, it is similar iterative it has been shown inadequate the heuristic has been shown that result analyzed. Though to [ 54,53,29,6]. repair. Knowledge resource constraints. the repair Our approach, generates schedules by repair-based criteria has been added to the basic simulated annealing the min-conflict the number of conflicts convergence vs. speed of convergence in terms of number of violated a repair heuristic in the space of complete In [ 54,531 simulated annealing types in the form of constraint framework and the tradeoff free schedule and In this respect schedules. has been used to perform and evaluation has been shown of minimizing vs. schedule quality measured In minimizes investigated powerful of job shop scheduling is random. This is because min-conflicts CBR-based improve the percent schedule modifications process, called chronologies, incrementally In [ 511 plausible control payload and ground processing. PEBL enables a system concept function above systems, CABINS doesn’t have any explicit objectives case-based [ 301. The to irrespective of initial schedule generation method, although and the quality of the final repaired schedule varies. In [6] encoded. Small snapshots of the scheduling gained to locate, classify and resolve bottlenecks. to learn search (PEBL) has been applied tasks for NASA Space Shuttle target a given of examples. The cost in the schedule. Unlike all the to optimize, but applies from the records that has been to be for some types repair of CABINS, on the other hand, has been shown experimentally resource contention) the number of remaining the scheduling process learning over a distribution conflicts to acquire user optimization preferences schedule quality improvement are used to focus the search by using relies on a good initial assignment rules to increase search efficiency (e.g. chronic is to minimize [35] when the initial assignment satisfaction problems explanation-based are procedurally in scheduling to generalize information techniques learning during K. Miyashita, K. Sycara/Ariifcial Intelligence 76 (1995) 377-426 417 of user’s repair decisions and optimizes schedules based on the acquired objectives. in been solution simulator previously case-based for incremental The repair-based to get information used systems that [ 50,18,14] as to plan correctness. For example, CHEF scheduling methods considered here are related rather than improving plan quality, and have assumed to the repair-based systems planning revision have efficiency, preserving plan cor- the existence of a strong [ 141 as- to evaluate a derived plan and detect repairs. Research by is causally and have methods ) . Previous case-based (e.g. been motivated primarily by concerns of computational rectness domain model sumes the existence of a model-based failure and uses well-studied a plan [ 18,501 are based on the hypothesis teleologically CABINS knowledge causal explanations schedule to possess causal domain knowledge. The user cannot give a solid explanation her/his action on the plan caused by tight interactions. The user’s expertise to perform consistent program cases of problem solving experiences to previous case-based require In CBR-based the user nor the program are assumed as to selection of repair action, because s/he cannot predict the effects of the selected lies in the ability to the domain that the plan built by their planner correct, and use CBR to find the satisfying plan efficiently. from an expert teacher to acquire domain knowledge. as a knowledge acquisition [5] ). These approaches usually of the results of problem and histories of evaluation in CABINS, neither solving and impart repair embodied is also related (e.g. Protos for selecting acquisition evaluation tradeoffs. systems system rules 7. Conclusions and future work repair repair scheduling for improving and constraint-based for knowledge acquisition In this paper, we advocate a framework if they were available, new optimization tactics, each of which operates with respect and re-using user scheduling preferences user optimization preferences is important expressed objectives and iterative repair for recording for is predicated on (a) the existence to a particular schedule quality, and judgments. The in domains without are unavailable. heuristics would need to be developed, of the system. results to capture and effectively utilize user scheduling that bias for schedule optimization. The approach utilizes CBR-based mechanisms user preferences, tactics and explanations, application of the selected repair tactics. The approach of a set of schedule local view of the problem and offers selective advantages and on (b) capturing capability of acquiring strong domain models because usually explicitly Even evaluated CABINS provides a framework show preferences different the schedule objectives as compared with other repair-based In addition, CABINS schedule seems results show that for well-defined in the case base, CABINS produces schedules with higher quality scheduling methods, such as simulated annealing. reflected repair procedure. Further experimental indicate in the case base differentially to capture a large number of cases can be amortized of which method was used for generating in the scheduling model. The results the quality of a It these problems. Our experimental the potential of the approach the design and maintenance that the effort expended that were not present the seed schedule. that it always for alleviating in the sense complicating implemented scheduling regardless objectives improved is robust implicitly reflected and 418 K. Miyashifa, K. Sycara/Artijcial Intelligence 76 (1995) 377-426 improvement without the cases through user interaction during by future repeated use of the case base to get high quality schedules efficiently. More the process importantly, CABINS can acquire that of solution CABINS has the potential that change this issue and issues of automating hierarchical over time. Future work will investigate abstraction of the repair process, and dealing with more complex objectives and larger problems. imposing undue overhead on the user. We believe acquisition of user preferences for accommodating Acknowledgments This research was partially supported by the Defense Advance Research Projects the first This work was originated when Agency under contract #F30602-91-C-0016. author was a visiting under Dajun Zeng for help with the experimentation the support of Matsushita Electric scientist at the Robotics Institute of Carnegie Mellon University Industrial Co. We would like to thank Mr. and insightful discussions. Appendix A: Case instance T-case 1 name = “exp_0_0_8:order5-l:l:activity5_2”; slots = ( ( Slot feature value salience 1; Slot { feature value salience 1; Slot { feature value salience 1; = weighted-tardiness; = 470.000000; = 1.000000; = resource_utilization_average; = 0.789000; = 1.000000; = resource_utilization_deviation; = 0.0403749; = 1.000000; >; SI_slots Slot = ( { feature value salience = waiting-time; = 580.000000; = 0.333; K. Miyashita, K. Sycara/Artijicial Intelligence 76 (1995) 377-426 419 ); Slot c feature = predictive-shift-gain; value = 0.806000; salience = 0.667; 3; Slot c feature = predictive_alt_shift_wip_gain; value = 0.106000; salience = 0.333; 3; Slot ( feature = predictive-swap-gain; value = 0.903000; salience = 0.667; 3; Slot c feature = predictive_alt_swap_gain; value = 0; salience = 0.333; 3; >; solutions = ( Solution { tactics-type = SWAP; effects = ( Effect { effect-type = WEIGHTED-TARDINESS; salience = 0.667; domain = "whole_schedule"; previous_value = 470.000000; current-value = 380.000000; gain = 90.000000; 3; Effect C effect-type = RESODRCE_UTILIZATION_AVEXLAGE; salience = 0.667; domain = "whole_schedule"; previous_value = 0.789000; current-value = 0.789000; gain = 0; 3; 420 K. Miyashita, K. SycaraIArtificial Intelligence 76 (1995) 377-426 Effect C effect-type = RESClURCE_UTILIZATION_DEVIATION; salience = 0.667; domain = "whole_schedule"; previous_value = 0.0403749; current-value = 0.0403749; gain = 0; 3; Effect C effect-type = INPROCESS_INVENTORY; salience = 0.667; domain = "whole_schedule"; previous_value = 2240.000000 current-value = 2250.000000; gain = -10.000000; 3; Effect ( effect-type = INPROCESS_INVENTORY; salience = 0.333; domain = "job7"; previous_value = 290.000000; current-value = 310.000000; gain = -20.000000; 3; ); result = ACCEPTABLE 3 ); 3 Appendix B: Case used for evaluation T-case ( name = "exp_2_0_4:order7-l:l:activity7_2"; slots = ( Slot { feature = weighted-tardiness; value = 670.000000; salience = 1.000000; 3; K. Miyashita, K. Sycara/Art$cial Intelligence 76 (199s) 377-426 421 Slot I feature = resource_utilization_average; value = 0.682000; salience = 1.000000; 3; Slot c feature = resource_utilization_deviation; value = 0.074000; salience = 1.000000; 1; 1; SI_slots = ( Slot ( feature = waiting-time; value = 280.000000; salience = 0.333; 1; Slot ( feature = predictive-shift-gain; value = 0.406000; salience = 0.667; 3; Slot c feature = predictive_alt_shift_wip_gain; value = 0.306000; salience = 0.333; 3; Slot c feature = predictive-swap-gain; value = 0.103000; salience = 0.667; 3; Slot c feature = predictive_alt_swap_gain; value = 0.304000; salience = 0.333; 3; >; solutions = ( Solution C tactics-type = LEFT-SHIFT; effects = ( Effect ( effect-type = WEIGHTED_TARDINESS; 422 K. Miyashita, K. Sycara/Art&ial Intelligence 76 (1995) 377-426 salience = 0.667; domain = "whole_schedule"; previous_value = 670.000000; current-value = 930.000000; gain = -260.000000; 3; Effect ( effect-type = RESOURCE_UTILIZATION_AVERAGE; salience = 0.667; domain = "whole_schedule"; previous_value = 0.682000; current-value = 0.682000; gain = 0; 1; Effect C effect-type = RESOURCE_UTILIZATION_DEVIATION; salience = 0.667; domain = "whole_schedule"; previous_value = 0.074000; current-value = 0.074000; gain = 0; 3; Effect < effect-type = INPROCESS_INVENTORY; salience = 0.667; domain = "whole_schedule"; previous_value = 1940.000000 current-value = 1990.000000; gain = - 50.000000; 3; . . . . . . . . . . /, result = UNACCEPTABLE; 3; Solution I tactics-type = SWAP; effects = ( Effect { effect-type = WEIGHTED-TARDINESS; salience = 0.667; domain = "whole_schedule"; K. Miyashita, K. Sycara/Artifcial Intelligence 76 (1995) 377-426 423 previous-value = 670.000000; current_value = 600.000000; gain = 70.000000; 3; Effect { effect-type = RESOURCE_UTILIZATION_AVERAGE; salience = 0.667; domain = "whole_schedule"; previous-value = 0.682000; current-value = 0.682000; gain = 0; 3; Effect C effect-type = RESOURCE_UTILIZATION_DEVIATION; salience = 0.667; domain = "whole_schedule"; previous-value = 0.074000; current-value = 0.074000; gain = 0; 3; Effect C effect-type = INPROCESS_INVENTORY; salience = 0.667; domain = "whole_schedule"; previous-value = 2480.000000; current-value = 3180.000000; gain = -700.000000; 3; Effect ( effect-type = WEIGHTED-TARDINESS; salience = 0.333; domain = "job7"; previous-value = 790; current-value = 210; gain = 580; 3; Effect { effect-type = INPROCESS_INVENTORY; salience = 0.333; domain = "job9"; 424 K. Miyashita, K. SycaraIArttficial Intelligence 76 (1995) 377426 previous_value = 290; current-value = 410; gain = -120; 3; );-’ result = ACCEPTABLE; 3; /, 3 References I 1 J J. Adams. E. Balas and D. Zawack, The shifting bottleneck procedure for job shop scheduling, Manage. Sci. 34 (1988) 391-401. I21 D.W. Aha, D. Kibler and M.K. Albert, Instance-based learning algorithms, Mach. Learn. 6 ( 1991) 31-66. 13 I K.D. Ashley, Modeling legal argument: reasoning with cases and hypotheticals, Ph.D. thesis, University of Massachusetts, Amherst, MA ( 1987). 14 I K.R. Baker, Introduction to Sequencing and Scheduling (Wiley, New York, 1974). 151 R. Bareiss, Exemplar-Based Knowledge Acquisition: A Unified Approach to Concept Representation, Classification, and Learning (Academic Press, New York, 1989). 161 E. Biefeld and L. Cooper, Bottleneck identification using process chronologies, in: Proceedings IJCAI-9I, Sydney, NSW ( 1991) 218-224. I71 A.R. Chaturvedi, Acquiring implicit knowledge in a complex domain, Expert Syst. Appl. 6 (1993) 23-35. [ 8 I I? Cheeseman, B. Kanefsky and W. Taylor, Where the really hard problems are, in: Proceedings IJCAI- 91, Sydney, NSW (1991). 19 I R.H. Creecy, B.M. Masand, S.J. Smith and D.L. Waltz, A traiding MIPS and memory for knowledge engineering, Commun. ACM 35 (8) ( 1992) 48-64. ] IO] B.V. Dasarathy, ed., Nearest Neighbor (NN) Norms: NN Pattern Classtfication Techniques (IEEE5 Computer Society Press, Los Alamos, CA, 1990). [ 111 T. Dean and M. Boddy, An analysis of time dependent planning, in: Proceedings AAAI-88, St. Paul, MN (1988) 49-54. [ 121 M. Fox, Constraint-directed search: a case study in jop shop scheduling, Ph.D. thesis, Department of Computer Science, Carnegie-Mellon University, Pittsburgh, PA ( 1983). [ 131 S. French, Sequencing and Scheduling: An Introduction to the Mathematics of the Job-Shop (Ellis Horwood, London, 1982). [14] K.J. Hammond, Case-Bused Planning: Viewing Planning as a Memory Tusk (Academic Press, New York, 1989). [ 151 D.S. Johnson, C.R. Aragon, L.A. McGeoch and C. Schevon, Optimization by simulated annealing: An experimental evaluation, I: graph partioning, Oper. Res. 37 (1989) 865-892. [ 161 D.S. Johnson, C.R. Aragon, L.A. McGeoch and C. Schevon, Optimization by simulated annealing: An experimental evaluation, II: graph coloring and number partitioning, Oper. Res. 39 (1991) 378-406. [ 171 M.D. Johnston, SPIKE Al sheduling for NASA’s Hubble Space Telescope, in: Proceedings Sixth IEEE Conference on Artificial Intelligence for Applications, Santa Barbara, CA ( 1990) 184-190. [ 18 J S. Kambhampati and J.A. Hendler, A validation-structure-based theory of plan modification and reuse, Arti$ Intell. 55 (1992) 193-258. [ 191 K. Kempf, C. LePape, SF Smith and B.R. Fox, Issues in the design of AI-based schedulers: workshop report, Artif Intell. Magazine 11 (5) (1991) 37-46. K. Miyashita, K. Sycara/Artificiul Intelligence 76 (1995) 377-426 425 [ 201 P. Koton, Reasoning about evidence in causal explanations, in: Proceedings DARPA Workshop on Case- Based Reasoning, Clearwater Beach, FL ( 1988) 260-270. [21] J.J. Kanet and V. Sridharan, The electronic leitstand: a new tool for shop scheduling, Manufacturing Rev. 3 (1990) 161-169. [22] J. Kolodner, R. Simpson and K. Sycara, A process of case-based reasoning in problem solving, in: Proceedings IJCAI-85, Los Angeles, CA ( 1985) 284-290. 1231 Naiping Keng and D.Y.Y. Yun, A planning/scheduling methodology for the constrained resource problem, in: Proceedings IJCAI-89, Detroit, Ml ( 1989) 998-1003. [ 241 P.J.M. Van Laarhoven, E.H.L. Aarts and J.K. Lenstn, Job shop scheduling by simulated annealing, Oper. Rex 40 (1992) 113-125. 125 1 P. Langley, Systematic and non-systematic search strategies, in: Proceedings AAAI-92, San Jose, CA (1992). [ 26 1 L.M. Lewis, D.V. Minior and S.J. Brown, A case-based reasoning solution to the problem of redundant engineering in large scale manufacturing, Int. J. Expert Syst. 4 (1991) 189-201. [ 271 J. Liu and K. Sycara, Distributed constraint satisfaction through constraint partition and coordinated reaction, in: Proceedings 12th International Workshop on Distributed Artificial Intelligence, Hidden Valley, PA ( 1993). 1281 K. Mckay, J. Buzacott and E Safayeni, The scheduler’s knowledge of uncertainty: the missing link, in: Proceedings IFIP Working Conference on Knowledge Based Production Management Systems, Galway (1988). 1291 S. Minton, M.D. Johnston, A.B. Philips and P Laird, Solving large-scale constraint satisfaction and scheduling problems using a heuristic repair method, in: Proceedings AAAI-90, Boston, MA ( 1990) 17-24. [ 301 S. Minton, M Johnston, A. Philips and P Laird, Minimizing conflicts: a heuristic repair method for constraint satisfaction and scheduling problems, Artif: Intell. 58 ( 1992) 161-205. (3 I] T.E. Morton and D.W. Pentico, Heuristic Scheduling Systems: With Application to Production Systems and Product Management (Wiley, New York, 1993). [32] R. Musick and S. Russell, How long will it take?, in: Proceedings AAAI-92, San Jose, CA (1992) 466-47 1. [33 1 T.E. Morton, R.M. Rachamadugu and A. Vepsaleinen, Accurate myopic heurisrics for tardiness scheduling, Technical Report 36083-84, Graduate School of Industrial Administration, Carnegie-Mellon University, Pittsburgh, PA ( 1984). [ 341 K. Miyashita and K. Sycara, Learning control knowledge through cases in schedule optimization problems, in: Proceedings Tenth IEEE Conference on Aritijicial Intelligence for Applications, San Antonio, TX (1994) 33-39. 1351 N. Muscettola, Scheduling by iterative partition of bottleneck conflicts, in: Proceedings of the Ninth IEEE Conference on Artificial Intelligence for Applications, Orlando, FL ( 1993) 49-55. 1361 P.S. Ow, SF Smith and A. Thiriez, Reactive plan revision, in: Proceedings AAAI-88, St. Paul, MN (1988) 77-82. [37] D.S. Prerau, Developing and Managing Expert Systems: Proven Techniques for Business and Industry (Addison-Wesley, Reading, MA, 1990). ]38] E.L. Rissland and K.D. Ashley, Credit assignment and the problem of competing factors in case-based reasoning, in: Proceedings DARPA Workshop on Case-Based Reasoning, Clearwater Beach, FL ( 1988) 327-344. [ 391 D. Ruby and D. Kibler, Learning episodes for optimization, in: Proceedings Ninth International Conference on Machine Learning, Aberdeen ( 1992) 379-384. [40] N. Sadeh, Look-ahead techniques for micro-opportunistic job shop scheduling, Ph.D. thesis, School of Computer Science, Carnegie-Mellon University, Pittsburgh, PA ( 1991). [ 411 SF Smith and CC. Cheng, Slack-based heuristics for constraint satisfaction scheduling, in: Proceedings AAAI-93/IAAI-93, Washington, DC ( 1993). [42] N. Sadeh and M.S. Fox, Variable and value ordering heuristics for activity-based job-shop scheduling, in: Proceedings Fourth International Conference on Expert Systems in Production and Operations Management, Hilton Head Island, SC ( 1990) 134- 144. 426 K. Miyaslzita, K. Sycara/Artifcial Intelligence 76 (1995) 377-426 [43] K. Sycara, R. Guttal, J. Koning, S. Narasimhan and D. Navinchandra, CADET A case-based synthesis tool for engineering design, In!. J. Experf Syst. 4 ( 1991). 1441 R.L. Simpson, A computer model of case-based reasoning the domain of dispute mediation, Ph.D. thesis, School of Information Institute of Technology, Atlanta, GA ( 1985). in problem solving: an investigation in and Computer Science, Georgia [45] E. Simoudis and J.S. Miller, The application of CBR to help desk applications, in: Proceedings Case- Based Reasoning Workshop (1991) 25-36. [46] S.F. Smith, P.S. Ow, C. LePape, B. McLaren to generate perspectives Manufacturing, Long Beach, CA ( 1986). 1471 C. Stanfill and D. Waltz, Toward memory-based 1481 K. Sycara, Patching up old plans, production detailed and N. Muscettola, Integrating multiple scheduling plans, in: Proceedings SME Conference on AI in reasoning, Conunun. ACM 29 (1986) 1213-1228. in: Proceedings Tenth Annual Conference of the Cognitive Science Society, Montreal, Que. ( 1988). 149 1 K. Sycara, Argumentation: [50] M.M. Veloso, Learning by analogical planning other agents’ plans, in: Proceedings IJCAI-89, Detroit, MI ( 1989). thesis, School of in general problem solving, Ph.D. reasoning Computer Science, Carnegie-Mellon University, Pittsburgh, PA ( 1992). [ 5 I] M. Zweben, E. Davis, D. Brian, E. Drascher, M. Deale and M. Eskey, Learning to improve constraint- based scheduling, Art$ Intell. 58 ( 1992) 271-296. [52] M. Zweben, E. Davis, B. Daun and M. Deale, Rescheduling with iterative repair, in: Proceedings AAAI-92 Workshop on Production Planning, Scheduling and Control, San Jose, CA ( 1992). [53] M. Zweben, E. Davis, B. Daun and M. Deale, Iterative repair for scheduling and rescheduling, IEEE Trans. Syst. Man Cybern. 23 (1993) 1588-1596. [ 541 M. Zweben, M. Deale and M. Gargan, Anytime rescheduling, in: Proceedings DARPA Workshop on Innovative Approaches to Planning, Scheduling and Control, San Diego, CA (1990) 251-259. 