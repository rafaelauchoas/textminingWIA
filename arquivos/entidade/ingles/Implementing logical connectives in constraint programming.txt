Artificial Intelligence 174 (2010) 1407–1429Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintImplementing logical connectives in constraint programmingChristopher Jefferson b, Neil C.A. Moore b, Peter Nightingale b,∗, Karen E. Petrie aa School of Computing, University of Dundee, Dundee DD1 4HN, UKb School of Computer Science, University of St Andrews, St Andrews, Fife KY16 9SX, UKa r t i c l ei n f oa b s t r a c tArticle history:Received 31 July 2009Received in revised form 30 June 2010Accepted 2 July 2010Keywords:Constraint programmingConstraint satisfaction problemsPropagation algorithmsLogical connectivesCombining constraints using logical connectives such as disjunction is ubiquitous inconstraint programming, because it adds considerable expressive power to a constraintlanguage. We explore the solver architecture needed to propagate such combinations ofconstraints efficiently. In particular we describe two new features named satisfying sets andconstraint trees. We also make use of movable triggers (Gent et al., 2006) [1], and with thesethree complementary features we are able to make considerable efficiency gains.A key reason for the success of Boolean Satisfiability (SAT) solvers is their ability topropagate Or constraints efficiently, making use of movable triggers. We successfullygeneralise this approach to an Or of an arbitrary set of constraints, maintaining the crucialproperty that at most two constraints are active at any time, and no computation at allis done on the others. We also give an And propagator within our framework, whichmay be embedded within the Or. Using this approach, we demonstrate speedups of over10,000 times in some cases, compared to traditional constraint programming approaches.We also prove that the Or algorithm enforces generalised arc consistency (GAC) when allits child constraints have a GAC propagator, and no variables are shared between children.By extending the Or propagator, we present a propagator for AtLeastK, which expressesthat at least k of its child constraints are satisfied in any solution.Some logical expressions (e.g. exclusive-or) cannot be compactly expressed using And, Orand AtLeastK. Therefore we investigate reification of constraints. We present a fast genericalgorithm for reification using satisfying sets and movable triggers.© 2010 Published by Elsevier B.V.1. IntroductionProblems often consist of choices. Making an optimal choice which is compatible with all other choices made is difficult.Constraint programming (CP) is a branch of Artificial Intelligence, where computers help users to make these choices. Con-straint programming is a multidisciplinary technology combining computer science, operations research and mathematics.Constraints are a powerful and natural means of knowledge representation and inference in many areas of industry andacademia, arising in design and configuration; planning and scheduling; diagnosis and testing; and in many other contexts.A constraint satisfaction problem (CSP [2]) is a set of decision variables, each with an associated domain of potential values,and a set of constraints. For example, the problem might be to fit components (values) to circuit boards (decision variables),subject to the constraint that no two components can be overlapping. An assignment maps a variable to a value from itsdomain. Each constraint specifies allowed combinations of assignments of values to a subset of the variables. A solution to a* Corresponding author.E-mail addresses: caj@cs.st-andrews.ac.uk (C. Jefferson), ncam@cs.st-andrews.ac.uk (N.C.A. Moore), pn@cs.st-andrews.ac.uk (P. Nightingale),kpetrie@computing.dundee.ac.uk (K.E. Petrie).0004-3702/$ – see front matter © 2010 Published by Elsevier B.V.doi:10.1016/j.artint.2010.07.0011408C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429CSP is an assignment to all the variables which satisfies all the constraints. In this paper we consider solving CSPs throughbacktrack search with an inference step at each node [2].Modelling is the process of representing a problem as a CSP. To allow natural modelling of some problems, the logicalconnectives of And and Or are required between constraints. For example, in a school timetabling problem you may haveeither Teacher1 Or (Teacher2 And Teacher3) taking a particular class. It is also sometimes useful to be able to apply Not toa constraint, this is often done in CSP by means of reification. The reification of a constraint C produces another constraintCr , such that Cr has an extra Boolean variable r in its variable set, and (in any solution) r is set to true if and only if theoriginal constraint C is satisfied. In this paper we discuss the neglected area of how to efficiently implement these logicalconnectives across constraints, which are the fundamental building blocks of CSP models [3] (Chapter 11).During the search for a solution of a CSP, constraint propagation algorithms are used. These propagators make inferences,recorded as domain reductions, based on the domains of the variables constrained. If at any point these inferences result inany variable having an empty domain then search backtracks and a new branch is considered. Propagators and generalisedarc consistency (GAC) are important concepts in this paper. When considering a single constraint C , GAC is the strongestpossible consistency that a propagation algorithm can enforce. Enforcing GAC removes all domain values which are notcompatible with any solution of C . In [3] (Chapter 3), Bessiere defines GAC and discusses the complexity of enforcing it.In this paper we consider propagating logical combinations of constraints. For example, for constraints C1, C2, C3, C4 wemay wish to post the following expression and propagate it efficiently.(C1 ∧ C2) ⇒ (C3 ∨ C4)It is desirable to make use of existing propagators for C1, C2, C3 and C4 since these may be highly efficient specialisedpropagators.1.1. A traditional approachA traditional approach (probably the most common) is to individually create reified propagators for the four constraints.These introduce an additional Boolean variable representing the truth of the constraint (e.g. the reified form of C1 is theconstraint r1 ⇔ C1, so in any solution r1 is True if and only if C1 is satisfied). A logical expression can be enforced on theadditional Boolean variables to obtain the desired combination. The example above translates into the following collectionof constraints1:r1 ⇔ C1,(r1 ∧ r2) ⇒ (r3 ∨ r4)r3 ⇔ C3,r2 ⇔ C2,r4 ⇔ C4,This scheme has three major disadvantages. First, it can be very inefficient because every reified constraint is propagatedall the time. For example consider an Or of a set of n constraints. As we will demonstrate in Section 4, at most twoconstraints need to be actively checked at any time. However, a reification approach will propagate all n reified constraintsat all times. Second, developing reified propagators individually for each constraint is a major effort. Third, when a variableoccurs multiple times in an expression, the reified decomposition may propagate poorly. In this paper we address the firsttwo issues but not the third: we achieve the same level of consistency as the reified decomposition.1.2. Two vital features of a solver for a new approachThe key finding of this work is that two vital features of the solver must be combined to achieve efficient propagationof logical connectives. If either feature is not available, then the other is of limited benefit. The two features are constrainttrees, which allow a parent constraint to control the propagation of its children, and movable triggers which allow a constraintto change the events [3] (Chapter 14) it is interested in during search.Consider an Or of n constraints over disjoint variable sets. We will show that at most two of the constraints need to beconsidered at any time, because if two of the constraints are satisfiable then no propagation can occur. Once two satisfiableconstraints have been identified, all other constraints are presently irrelevant and no computation time should be wastedon them. This is essential to efficiency when n is large.Constraint trees allow us to stop checking irrelevant constraints. However, this is not enough to achieve zero cost forirrelevant constraints: there is a cost to generate trigger events for the constraints. It is necessary to remove triggers notcurrently of interest, hence movable triggers are also required.The following table summarises the costs caused by irrelevant constraints.ReificationConstraint treesStatic triggersAll reified constraintspropagated at all timesTrigger events received forall constraints at all timesMovable triggersAll reified constraintspropagated at all timesIrrelevant constraintscause no cost1 In some solvers it would be necessary to further decompose (r1 ∧ r2) ⇒ (r3 ∨ r4).C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291409Our implementations are in the Minion solver [4], though the presentation is not specific to Minion.1.3. OverviewThere are a number of solver architecture decisions which impinge on propagating logical combinations of constraints.In Section 3 we describe three architecture features which are key to the new algorithms presented in this paper. Satisfyingsets (Section 3.3) are novel to the best of our knowledge. We also provide the first implementation of constraint trees(Section 3.2). Movable triggers [1] are also described in Section 3.1 to aid understanding of the rest of the paper.In Section 4, we present a propagator for the constraint AtLeastK, which ensures that at least k of a set of constraintsare satisfied in any solution. Both And and Or are special cases of AtLeastK. Via the constraint trees framework, AtLeastKconstraints may be nested to any depth, and also may be reified using the algorithms given in Section 5. The AtLeastKpropagator maintains the crucial property that only k + 1 constraints are checked (or k propagated) at any time — nocomputation at all is done on the others. Section 4 also contains experiments on the efficiency of Watched Or, And andAtLeastK, which demonstrate huge speedups in some cases.In Section 5 we consider reification. Some logical expressions (e.g. exclusive-or) cannot be compactly expressed usingonly And, Or and AtLeastK, so a more general approach is needed. Therefore we investigate the use of satisfying sets,movable triggers and constraint trees for reification of constraints. To avoid implementing reified propagators for individualconstraints, we developed four generic algorithms which can be used with any constraint C , provided that there is a propa-gator for ¬C available. We compare algorithms which use satisfying sets and movable triggers with alternatives using statictriggers, and again we demonstrate huge speedups in some cases.Finally, the paper is concluded in Section 6.2. Background2.1. PreliminariesA CSP P = (cid:7)X , D, C(cid:8) is defined as a sequence of n variables X = (cid:7)x1, . . . , xn(cid:8), a sequence of domains D = (cid:7)D1, . . . , Dn(cid:8)where D i is the finite set of all potential values of xi , and a set C = {C1, C2, . . . , Ce} of constraints. A literal is a pair (cid:7)xi, di(cid:8),with xi ∈ X and di ∈ D i . An assignment A is a partial function A : X → Dall such that A(xi) ∈ D i , where Dall =i D i . In acomplete assignment A is a total function, i.e., every xi ∈ X is mapped by A.Within CSP P = (cid:7)X , D, C(cid:8), a constraint Ck ∈ C consists of a sequence of r > 0 variables Xk = (cid:7)xk1 , . . . , xkr(cid:8) (where Xk(cid:8) s.t. Xk is a subsequence2 of X and Dk is theis the scope of the constraint) with respective domains Dk = (cid:7)Dk1 , . . . , Dkrcorresponding subsequence of D. Ck has an associated set C S× · · · × Dkr of tuples which specify allowed combinationskof values for the variables in Xk. A constraint is satisfied under a complete assignment to the variables iff the assigned valuesof Xk in sequence form a tuple in C Sk . A solution to a CSP is a complete assignment which satisfies all the constraints.The reified form (rk ⇔ Ck) of a constraint Ck is satisfied iff rk is assigned 1 and Ck is satisfied, or rk is assigned 0 and Ckis not satisfied. The reifyimplied form (rk ⇒ Ck) of Ck is satisfied iff rk is assigned 0, or rk is assigned 1 and Ck is satisfied.The And of a set of constraints is satisfied iff all constraints in the set are satisfied. The Or of a set of constraints issatisfied iff at least one of the constraints in the set is satisfied. The AtLeastK of a set of constraints (with parameter k) issatisfied iff at least k of the constraints in the set are satisfied.⊆ Dk1(cid:2)A subdomain for a variable x is a subset of its initial domain. A subdomain list is a sequence of subdomains for distinctvariables. A subdomain list (cid:7)D1, . . . , Dk(cid:8) allows the set of assignments corresponding to D1 × · · · × Dk.A propagator for a constraint C is a function which takes a subdomain list for XC and returns a new subdomain list,which does not allow any extra assignments, and does not remove any assignments which satisfy C . Further, if everysubdomain in a subdomain list S D on XC is singleton, then a propagator must empty all the domains iff C s does notcontain the single allowed assignment from S D.A propagator is GAC if it removes every domain value possible without violating the definition of propagator. A completediscussion of propagators can be found in [3] (Chapter 3).Given a constraint c and a subdomain list S D for the variables in Xc , then c is disentailed if every assignment allowedby S D does not satisfy c. c is entailed if every assignment allowed by S D satisfies c.2.2. Related work on propagation controlBrand and Yap [5] present a framework for reducing redundant propagation in logical combinations of constraints. This isnamed the controlled propagation framework (CPF). In CPF the standard reification approach is used, and improved by addingcontrol flags to each constraint. For an individual reified constraint C ⇔ b, the value of b controls whether it is propagated(positively or negatively) and the control flags indicate whether it prunes b: the flags chk-true and chk-false indicatewhether C is checked for entailment and disentailment. b is only pruned if at least one of chk-true or chk-false is2 We use subsequence in the sense that (cid:7)1, 3(cid:8) is a subsequence of (cid:7)1, 2, 3, 4(cid:8).1410C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429present. The flag irrelevant indicates that C ⇔ b need not be propagated at the current search node or its descendents.This would usually mean C ⇔ b is revoked and its triggers removed. The control flags are manipulated using implicationrules.CPF is implemented in a Constraint Logic Programming context that allows constraints to be posted (and triggers added)as search moves forward. The posted constraints (and their triggers) are removed on backtracking. This allows parts of adecomposition to be generated as needed during search. Constraints may also be revoked (and restored on backtracking).CPF has the same goals as our work. A detailed comparison is given in Section 3.4.2.3. Related work on OrMany authors have considered constructive disjunction for propagating Or. For example, Müller and Würtz [6,7] present aconstructive disjunction algorithm implemented in Oz. Assuming that all child constraints have GAC propagators, construc-tive disjunction is able to enforce GAC over the Or, regardless of whether child constraints share variables. However, thisis achieved by making a copy of the variable domains for each child constraint and propagating each child independently.A value which is pruned by every child constraint (i.e. pruned in each copy of the domains) is then pruned globally by theOr. It is not clear that this algorithm can be implemented efficiently. Lagerkvist and Schulte [8] observed a performancepenalty of over 45% when executing propagators on copies of the domains and mirroring the result back to the primarydomains, compared with executing directly on the original variables.Constructive disjunction may be valuable for problems where strong propagation of Or is required. However, in thispaper we consider more lightweight methods that do not require duplication of variable domains. Therefore we considerconstructive disjunction to be outside the scope of this paper.Bacchus and Walsh [9] give some theoretical results about logical combinations of constraints, including And, Or andnegation. Concerning Or, the paper only states that the set of inconsistent values of the Or is the intersection of theinconsistent values of each child constraint. This would perform the same domain reductions as constructive disjunction.The authors give a basic algorithm but do not consider incremental propagation (which is vital for efficiency). Adapting thisalgorithm for incrementality would require tracking the state of variable domains independently for each child — essentiallyduplicating the variable domains. This would be equivalent to the algorithm of Müller and Würtz [6,7].Lhomme [10,11] presents an alternative to constructive disjunction which performs the same domain reductions. Lhom-me’s algorithm is claimed to be more efficient than constructive disjunction. It is based on finding satisfying assignments(represented as tuples of values) for the constraints. Each relevant variable-value pair is supported by a satisfying tuple forone of the constraints in the disjunction, or it is pruned.While Lhomme’s algorithm may be faster than constructive disjunction, it maintains a large set of supporting tuples (onefor each variable-value pair where the variable is shared between two child constraints). Our proposed algorithm maintainsonly two partial tuples (and enforces a weaker consistency), therefore it is much more lightweight.In SAT, the constraints (Or of Boolean literals) are often propagated by 2-literal watching [12]. This scheme has theadvantage that only two literals are active at any time, and the others incur no cost. One of the major contributions of thispaper is our proposed algorithm Watched Or in Section 4, which shows how the basic techniques behind 2-literal watchingcan be efficiently extended to support arbitrary constraints and propagators, keeping the efficiency which comes from onlyhaving two active disjuncts at any time.2.4. Related work on reificationReification of a constraint C produces the constraint r ⇔ C , where r is a Boolean variable. We focus on generic ap-proaches to reification that can be applied to any constraint that has the appropriate algorithms defined for it. For example,we prove that a generic reification algorithm that enforces GAC efficiently requires GAC propagators for both the constraintand its negation.Indexicals (proposed by Van Hentenryck et al. [13]) allow simple propagators to be specified in a high-level language.They can be extended slightly to allow reification [3] (Section 14.2.6). However, it is not possible to express polynomial-timeGAC propagators for constraints such as AllDifferent [14] in the indexicals language.Propia [15] allows constraints to be expressed as Prolog predicates. The predicate specifies the constraint semanticallyas opposed to giving a propagator for the constraint. To implement reification, a predicate would be required for both theconstraint and its negation. Similarly to indexicals, it is not possible to specify sophisticated propagators in propia, thereforeit does not offer an efficient generic solution.Schulte proposed a generic reification algorithm [16] based on the concept of computation spaces. A computation space isan isolated environment which allows a propagator to be executed without affecting the primary variables. The computationspace includes independent variable domains. For ri ⇔ Ci , Ci is posted in the space, and propagated. If it fails, then ri (cid:12)= 1(i.e. 1 is pruned from ri ). If it is entailed (i.e. equivalent to the constraint True), then ri (cid:12)= 0. If ri = 1 then the effectsof propagating Ci are copied to the primary variables. In the case where ri = 0, there is no propagation of ¬Ci , and thealgorithm does nothing until Ci is entailed. The approach later proposed by Lagerkvist and Schulte [8] is virtually the samealgorithm implemented with propagator groups.C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291411Fig. 1. Constraint tree for (x = 1) ∨ (( y = 2) ∧ (x = 3)).Both these approaches have the disadvantages that they duplicate variables and do not propagate the negative constraint¬C when r = 0. Lagerkvist and Schulte compared a hand-implemented reified constraint to the generic algorithm. Thegeneric algorithm was substantially slower, with the solver taking between 29% and 106% extra time [8].The commercial product ILOG Solver implements reification, but we found no literature describing the algorithm.In Section 5 we propose new reification algorithms which avoid the overhead of duplicating variables, while also beingable to encapsulate any propagator, unlike indexicals or propia.2.4.1. TriggeringGiven a propagator P for a constraint c, there may be many subdomain lists S D where P (S D) = S D. In these situations,it is not necessary to run the propagator. Rather than invoke propagators on any domain change, solvers provide a list ofevents, which propagators can subscribe to. A propagator subscribes to an event by attaching a trigger to it. Executing atrigger calls the propagator which generated it, with a reference to the event which occurred (we refer to this as triggeringthe propagator). When events occur they are placed in a queue. Items in the queue are processed by executing every triggeron that event in turn.The exact set of events which can be subscribed to varies between solvers. For any variable x with domain D(x) anddomain value i, Minion supports the following events: i is removed from D(x); any value is removed from D(x); x isassigned; the maximum value of D(x) removed; and the minimum value of D(x) removed.The propagator must always be triggered when P (S D) (cid:12)= S D; otherwise the propagator would fail to enforce the correctlevel of consistency.2.4.2. Constraint treesThere are highly efficient propagators already written for many constraints. We would like to be able to combine thesepropagators to build new propagators. Constraint trees provide a highly efficient framework for achieving this goal.To define constraint trees, we define the concept of meta-variables. These are not CSP variables, and have none of theassociated overhead, but are merely for pedagogical purposes. Meta-variables are Boolean, and therefore have three states(0, 1, and unset). The current subdomain of a meta-variable xm for a constraint c denotes if, in the current subdomain list,c is entailed (xm = 1), disentailed (xm = 0) or neither (xm ∈ {0, 1}). The state of xm is a property of c, it is never stored.A constraint tree is a rooted tree T = (cid:7)V , E, r(cid:8) with root r ∈ V . Each node b ∈ V has associated with it a constraint and ameta-variable. The scope of the constraint on node b may contain both CSP variables and the meta-variables of the childrenof b. A constraint tree as a whole is satisfied iff the constraint associated with r is satisfied. A constraint tree is a type ofconstraint, and may be contained in a CSP (defined in Section 2.1). Constraint trees are not a novel concept (for example,Bacchus and Walsh make use of them [9]), however they allow us to define a novel propagation framework.Now we discuss propagation of constraint trees. The constraint for every vertex a ∈ V has a propagator P a associatedwith it. Propagators at leaves of the tree are conventional propagators as described in Section 2.1. The propagator P b for aninternal vertex b ∈ V of the tree is able to prune its CSP variables, query any child constraint for disentailment, and invokethe propagator for any child constraint.By an abuse of notation, we refer to the vertices in T as constraints. The parent of the constraint attached to node a isthe parent of a in T . The children of the constraint attached to a node a ∈ V are the children of a in T .Constraint trees are used to implement constraints that are expressed as logical combinations of other constraints. Forexample, (x = 1) ∨ (( y = 2) ∧ (x = 3)) could be represented by the constraint tree in Fig. 1. We will present propagators forthe interior nodes ∧ and ∨ in Section 4.One issue which is often ignored when discussing propagation algorithms is when variables are repeated within the con-straint. Most propagation algorithms that enforce GAC will not enforce GAC when variables are repeated. Many constraintswith polynomial-time GAC propagators become NP-hard to enforce GAC once repeated variables are taken into account,for example the Global Cardinality Constraint [17]. We address the issue of repeated variables separately for each of theproposed algorithms in this paper.3. Solver architectureIn order to implement logical connectives efficiently, we made a number of solver architecture decisions which aredescribed in this section.1412C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14293.1. Movable triggersOne important part of how propagators are implemented is how they are triggered, as described in Section 2.4.1. InMinion there are three classes of triggers, discussed in depth in [1]. In this paper we exploit both static and movabletriggers. In [1], movable triggers are referred to as watched literals.Static:These triggers are placed on variables at the beginning of search. They can never be moved or removed.Movable: These triggers can be placed, moved and removed during search. When search backtracks, they are not restoredto their previous place.Using movable triggers can produce great improvements in the performance of the solver, as observed in SAT [12] andCSP [1]. Some solvers support movable triggers which backtrack during search. The algorithms described in this paper canbe trivially modified to work with such solvers, at the cost of the extra overhead of backtracking the triggers and datastructures.3.2. Constraint treesAll the following algorithms use the concept of a Constraint Tree, as defined in Section 2.4.2. In this paper we assumethat a parent constraint controls when a child is propagated, and also every constraint has a method which can detectif a constraint is disentailed. We will show in Section 4 how we can detect disentailment of interior nodes by using thedisentailment detectors of their children.Any constraint which has a propagator and disentailment checker can function as a child constraint, allowing us toleverage the large number of already implemented highly efficient propagators in the CP literature. All the parent constraintswe describe in this paper can also function as a child of another constraint.Static triggers are handled as follows in a tree of constraints. At setup time, all propagators in the tree place the statictriggers that they need. During search, all trigger events are passed to the topmost propagator. Each parent propagator passesthe appropriate trigger events through to the children which are currently propagating, and discards others. An example ofthis is shown in Fig. 2. Three assignments occur in sequence (x2 = 0, x6 = 0 and x1 = 0) and the corresponding events arepassed to the propagator of c1 by the solver core. In Fig. 2(b), c1 is propagating neither of its children so it discards thetwo events. In (c), c1 is propagating its left child, but the trigger event belongs to the right child so it is discarded. In (d),c1 passes the trigger event on to c2 because c2 is currently propagating.Movable triggers are somewhat more complicated, but they allow triggers for non-propagating children to be removed,reducing the number of unnecessary trigger events. Operations on movable triggers are described in detail with the algo-rithms in Sections 4 and 5.For both classes of trigger, the trigger events are passed in at the top of the tree, and filter down, which adds a smalloverhead to propagating the constraints at the leaves of the tree. However, once the propagators are invoked they executeas if they were not within a constraint tree, directly reading and changing the subdomain of variables.3.3. Satisfying setsIn many of the algorithms in this paper, we want a fast method of checking if a constraint is satisfiable. One way of doingthis is to execute its propagator and check to see if it removes all the values from the domain of any variable. However thisis clearly inefficient because it computes domain deletions as well as deducing whether the constraint is satisfiable. In thissection, we introduce satisfying sets, a simple and efficient framework for checking disentailment.Definition 1. Given a constraint C , a satisfying set is a set of literals F from XC such that every assignment to XC whichcontains all the literals in F also satisfies C . A satisfying set F is complete if, additionally, every subdomain list for XC thatcontains all the literals in F allows at least one assignment that satisfies C .Example 2. Consider the constraint X + Y + Z (cid:2) 2, for variables X , Y and Z with domains {0, 1}. The set of liter-als {(cid:7) X, 1(cid:8), (cid:7)Y , 1(cid:8)} is a complete satisfying set. It is a satisfying set as the two assignments that contain these literals,(cid:7) X, Y , Z (cid:8) = (cid:7)1, 1, 0(cid:8) and (cid:7)1, 1, 1(cid:8), both satisfy the constraint. It is complete because any subdomain list for XC which con-tain this satisfying set must contain an assignment where X = 1 and Y = 1. Therefore regardless of the assignment to Z thesum of the variables must be greater than or equal to two.The set of literals {(cid:7) X, 0(cid:8), (cid:7) X, 1(cid:8)} is trivially a satisfying set, as there can be no assignment which contains both of theseliterals, as they are from the same variable. It is not complete, because the subdomain list X ∈ {0, 1}, Y , Z ∈ {0} does notcontain an assignment which satisfies the constraint.Given a satisfying set for a constraint, we know that if none of the literals in the satisfying set are removed, we cannotend up in a state where every variable is assigned and the constraint is not satisfied. This basic guarantee will be usedC. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291413Fig. 2. Example of static trigger events and satisfying sets in a constraint tree representing (x1 ↔ x2 = x3) ∨ (x4 < 1 ∧ x5 < x6). Satisfying sets are writtenbeside constraints as a list of values. For example, the satisfying set for c5 is (cid:7)x4, 0(cid:8), (cid:7)x5, 0(cid:8), (cid:7)x6, 1(cid:8). Movable trigger events are omitted from this diagram.In the table at the bottom, the static triggers placed by each constraint are listed.to ensure algorithms using satisfying sets are correct. A complete satisfying set produces a much stronger guarantee, thatthe constraint is never disentailed as long as no literal from the satisfying set is removed. This will be necessary for anypropagator which makes use of satisfying sets to enforce GAC.Definition 3 introduces the concept of a satisfying set generator.Definition 3. A satisfying set generator for a constraint C is a function that takes a subdomain list S D and either returns asatisfying set within S D, or Fail. A satisfying set generator may only return Fail when there is no assignment within S Dthat satisfies C .A satisfying set generator is complete if it only returns complete satisfying sets. This implies it must return Fail exactlywhen there is no assignment within S D that satisfies C .One question is for which constraints satisfying set generators can be implemented in polynomial time, and when theycan be made complete. Definition 4 presents the trivial satisfying set generator, which provides a polynomial-time satisfyingset generator for any constraint. Lemma 5 shows that the trivial satisfying set generator is valid. Notice that an incompletesatisfying set must contain two literals of the same variable, by Definition 1. The following trivial satisfying set generatormakes use of this fact.Definition 4. The trivial satisfying set generator for a constraint C and subdomain list S D is defined as follows:1. There exists an X ∈ XC such that |S D( X)| > 1: Return a satisfying set containing two literals from S D( X).2. S D allows exactly one assignment: If this assignment satisfies C , return the satisfying set containing all the literals inS D, else return Fail.1414C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429Lemma 5. For every constraint C , the trivial satisfying set generator is valid and runs in polynomial time.Proof. Any set of literals that contains two assignments to one variable is a satisfying set, as no assignment can containtwo values for one variable. Once all variables are assigned, the trivial satisfying set generator either returns Fail, or returnsa complete assignment which must satisfy C . The complexity result is trivial. (cid:2)Theorem 6 categorises the complexity of complete satisfying set generators.Theorem 6. A constraint C has a polynomial time complete satisfying set generator if and only if it has a polynomial time GACpropagator.Proof. Given a complete satisfying set generator, it is possible to check if a subdomain list for XC contains a satisfyingassignment, by seeing if the satisfying set generator returns Fail. Lemma 1 of [17] proves this is polynomially equivalent tohaving a GAC propagator. Alternatively, given a GAC propagator for C , we can construct a complete satisfying set generatoras follows.The GAC propagator will empty the domains of the variables if the subdomain list contains no assignment which sat-isfies C , which is exactly the situation in which a complete satisfying set generator must return Fail. Assuming the GACpropagator does not empty the domains, then they must contain at least one satisfying assignment. A complete assignmentwhich satisfies C is a complete satisfying set, as any subdomain list which contains it contains a satisfying assignment. Thefollowing algorithm produces an assignment which satisfies C within |XC | invocations of the propagator: (1) Run the GACpropagator. (2) If any unassigned variable exists, choose one and assign it to any value in its current subdomain. (3) If anyvariable is unassigned, return to step 1. (cid:2)While Theorem 6 shows how to build a complete satisfying set generator from a GAC propagator, for many constraintsthere is a faster complete satisfying set generator which produces smaller satisfying sets. Theorem 6 always returns acomplete satisfying set with as many literals as variables in XC . The complexity of finding smaller complete satisfying setsis an open problem which we leave for future work. For all the constraints in Minion which have GAC propagators, we haveconstructed complete satisfying set generators (often by taking a small part of the propagator). We present two cases hereas examples.Example 7. Consider the constraint M[x] = y for an array of variables M and variables x and y. Given a subdomain list, thisconstraint is satisfiable if and only if there exist i and j such that i is in the subdomain of x and j is in the subdomain ofboth M[i] and y. If such i and j exist, then the literals (cid:7)x, i(cid:8), (cid:7)M[i], j(cid:8) and (cid:7) y, j(cid:8) form a complete satisfying set.Example 8. The complete satisfying set generator given in Theorem 6 requires finding a complete assignment which satisfiesthe constraint. The first part of the AllDifferent propagator [14] finds a satisfying assignment, so a complete satisfying setgenerator can be formed by truncating the algorithm at this point.3.4. Comparison to previous workThe most closely related previous work is by Brand and Yap [5] (CPF, described in Section 2.2). There are several impor-tant differences between our work and CPF. Firstly, their approach has reification variables whereas with constraint trees weare able to avoid them (to reduce overheads). Secondly, constraint trees are static whereas their framework posts new con-straints and revokes constraints during search, potentially saving space but with a time overhead. Thirdly, our approach isrestricted to propagation and checking of child constraints. It is not possible to propagate the negation of a child, except byintroducing the negation as another child constraint. CPF allows propagation and checking of the negation of any constraint,at the cost of requiring a propagator for the reified form of each constraint.Fourthly, and perhaps most importantly, CPF does not make use of movable triggers. Constraints are posted and revokedduring search, but between these two events the triggers are fixed. The framework proposed here makes extensive useof movable triggers (with satisfying sets) to check disentailment of both primitive and parent constraints. For example,checking disentailment of the AllDifferent constraint requires a movable trigger on one literal per variable. By contrast, inCPF it would be necessary to check the constraint for every domain change.3It is possible to implement 2-literal watching for a SAT clause on Boolean variables in CPF. This is done by dynamicallyposting literals such that only two are checked for disentailment at any time. The same technique can be applied to adisjunction of constraints, however CPF is not able to combine the technique with movable triggers and satisfying sets forefficient disentailment checking of the child constraints.3 Assuming that complete satisfiability checking is required.C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–142914154. Efficient propagators for ATLEASTK, AND and ORIn this section we present a new algorithm for AtLeastK of a set of constraints (defined in Section 2.1). Then we showhow that algorithm can be specialised to And and Or.4.1. Theoretical overviewThe AtLeastK algorithm is defined as: AtLeastK(k, Con) is true if at least k constraints in Con are true. In Theorem 9,we show the fundamental result which the algorithm for AtLeastK uses to enforce GAC, assuming all the constraints in Conhave a GAC propagator and no two constraints in Con share a variable.Theorem 9. Let constraint C = AtLeastK(k, {Con1, Con2, . . . , Conn}) for a constant k and constraints Coni , where the scopes of theConi are disjoint.Given a subdomain list S D for XC , where the subdomain of every variable in S D is non-empty, then S D is GAC with respect to C ifand only if, either:1. At least k + 1 of the Coni have satisfying assignments in S D; or2. exactly k of the Coni has a satisfying assignment in S D, and S D is GAC with respect to each of these k constraints.Proof. 1. Assume that there exists some set S such that |S| = k + 1 and Coni has a satisfying assignment for every i ∈ S.Then given any assignment to any variable there are at least k members of S which do not contain this variable in theirscope. A satisfying assignment to C can be generated by assigning these k constraints a satisfying assignment, and thenassigning all other variables any value. Therefore, every assignment to every variable is supported.2. Assume there exists a set S such that |S| = k and Coni is satisfiable if and only if i ∈ S. This implies in any satisfyingassignment to C , then every Coni for i ∈ S must be satisfied. Therefore for each i ∈ S, any assignment to any variable inthe scope of Coni which cannot be extended to a satisfying assignment to Coni must be removed. This is the definition ofGAC(Coni).Any variable not in the scope of any Coni for i ∈ S can be assigned any value.If there are less than k members of the Con which are satisfiable, clearly no assignment can satisfy C . (cid:2)4.2. The watched AtLeastK propagatorOur algorithm is split into three distinct phases, namely a setup phase, a watching phase and a propagation phase. In thissection we will present each phase separately. Before presenting the steps in our algorithm, we first describe the state thatthe algorithm stores between calls.PropagateMode: a Boolean which represents if we are in the propagation phase of the algorithm. It is reverted whensearch backtracks.Watches: The indices of the k + 1 child constraints that are currently being watched. These are not reverted when searchbacktracks.The algorithm operates on child constraints c1 to cn, which are each required to have a propagator and a satisfying setgenerator. By using the constraint trees framework (Section 3.2), the child propagators are able to use any kind of triggeravailable in Minion, and executing them is almost as efficient as propagating an ordinary constraint (the only overheadbeing passing trigger events through the AtLeastK).The algorithm begins in the setup phase. This searches for k + 1 satisfiable children. If k + 1 can be found then they areall watched. If exactly k are found then the propagation phase is entered, and if fewer than k are found then the constraintfails, signalling that search should backtrack. The code for the setup phase is shown in Algorithm 1.While PropagateMode is False, whenever a literal of a satisfying set is pruned, the watching phase of the algorithm iscalled. This either finds a new satisfying set, or (if only k children are satisfiable) starts to propagate all k satisfiable children.The code for the watching phase is shown in Algorithm 2.Finally, the propagation phase is active when PropagateMode is True. All trigger events belonging to any c j wherej ∈ Prop are passed through to c j . We do not give code for the propagation phase.It is possible to receive stale trigger events from movable triggers which were placed in a different phase becausemovable triggers are not backtracked. Therefore in the watching and propagation phases, some trigger events must beignored or otherwise handled specially. These are listed below, but in Algorithms 1 and 2 we assume such events havealready been dealt with appropriately.Watching Phase: Trigger events from the propagation phase may be received in this phase. Movable triggers are removedand ignored; static triggers cannot be removed and are just ignored.1416C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429PropagateMode = Falseif ∃S ⊆ {1 . . . n}. (|S| = k + 1 ∧ ∀ci ∈ S. ci has satisfying set) thenPlace movable triggers on satisfying sets of all ci ∈ S;Watches = Selseif ∃S ⊆ {1 . . . n}. (|S| = k ∧ ∀ci ∈ S. ci has satisfying set) thenInitialise propagation of ci for all i ∈ S;PropagateMode = True;elseFail;endendAlgorithm 1: Code for setup phase.Input: i: The satisfying set of constraint ci has been lostGlobal Data: PropagateModeif PropagateMode thenReturnendif ci is satisfiable thenMove movable triggers to new satisfying set of ci ;elseif ∃k. ck is satisfiable and k /∈ Watches thenMove movable triggers to satisfying set of ck from ci ;Watches = (Watches \ {i}) ∪ {k};Prop = Watches \ {i};Initialise propagation of c j for all j ∈ Prop;PropagateMode = True;elseendendAlgorithm 2: Code for watching phase.Propagation Phase: Static trigger events for children not being propagated are ignored. All trigger events from setup andwatching phases are ignored, and movable trigger events from a non-propagating child cause the correspondingmovable trigger to be removed.To prove our algorithm correct, we present two invariants. These two invariants are exactly the conditions which arerequired to enforce GAC on AtLeastK from Theorem 9, so our algorithm achieves GAC under the assumptions that allchildren have GAC propagators, all satisfying set generators are complete and no pair of children share variables.Lemma 10. After the setup phase for the algorithm has completed, at any point during search where failure has not occurred and allitems on the constraint queue have been executed, the following two invariants are true.1. PropagateMode = False implies that k + 1 satisfying sets of k + 1 child constraints are being watched.2. PropagateMode = True implies that n − k child constraints are known to be unsatisfiable, and the other k are being propagated.Proof. Invariant 1 is true after setup, and whenever search progresses forward. However, we must consider what happenswhen search backtracks. If PropagateMode was True and remains so, then the condition is trivially true. There are two othercases to consider.• Backtrack from node A where PropagateMode is False to node B, where PropagateMode is still False. The k + 1 satisfyingsets from A are retained, and they are valid at B since the domain sets at B are (non-strict) supersets of those at A.• Backtrack from node A where PropagateMode is True to node B where it is False. The k + 1 satisfying sets were foundat node B or at an intermediate state between A and B. They remain valid at B since the domain sets at B are supersetsof those at any intermediate state.For invariant 2, in both places where PropagateMode is set to True, the invariant holds. Suppose PropagateMode is set toTrue at node A. For all nodes B below A in the search tree, domain sets are a subset of those at A and therefore the invariantstill holds (i.e. the n − k unsatisfiable children remain unsatisfiable at B). When backtracking from A, PropagateMode isreverted to False therefore the invariant holds. (cid:2)C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291417As stated above, the proof assumes that each child constraint has a GAC propagator and satisfying set generators are allcomplete. If this is not the case, in invariant 2 when k children are propagated the guarantee of GAC is lost, however it isclear that the algorithm remains correct as long as the children have propagators meeting the definition in Section 2.1.The proof also assumes that no variables are shared between children. However, this assumption will often not be met,so it requires some discussion. In terms of constraint trees, consider an AtLeastK vertex with two child vertices a and b,with associated meta-variables xa and xb, and associated constraints y = 1 and y = 3 on variable y ∈ {1, 2, 3}. Both meta-variables will be unassigned, and the AtLeastK algorithm will not deduce that they cannot both be equal to 1 at the sametime. The level of consistency enforced on the AtLeastK is the same as achieved by doing the following: replace y = 3 with(cid:17) = 3 for a new variable y, and apply the Watched AtLeastKy(cid:17) = 3 no longer share variables so Watched AtLeastK enforcesalgorithm. In this translation, the two children y = 1 and yGAC.of identical domain, add the new (GAC) constraint y = y(cid:17)(cid:17)In general the level of consistency enforced on an AtLeastK with shared variables is the same as achieved by doingthe following: reformulating the AtLeastK to remove shared variables by duplicating variables and adding GAC equalityconstraints, then enforcing GAC on the reformulated AtLeastK. It is assumed here that each child constraint has a GACpropagator, and that if a child constraint itself has repeated variables in its scope, that its propagator still enforces GAC.As discussed in Section 2.3, previous work has shown that given a disjunction of constraints, each of which has apolynomial-time GAC propagator, it is possible to achieve GAC propagation over the whole disjunction in polynomial-time,even if disjuncts share variables (constructive disjunction). We leave efficiently combining constructive disjunction, constrainttrees and satisfying sets to future work.4.2.1. A satisfying set generator for AtLeastKOur Watched AtLeastK algorithm uses satisfying sets extensively. To be able to use AtLeastK as a non-root node in aconstraint tree, it is necessary to also have a satisfying set generator for AtLeastK.Definition 11. Given satisfying set generators for a set {c1, . . . , cn} of constraints, the satisfying set generator forAtLeastK(c1, . . . , cn) is defined as follows:If the satisfying set generators of more than n − k children return Fail, then return Fail. Otherwise choose any set of kchildren whose satisfying set generators do not return Fail, and return the union of the satisfying sets they generate.Lemma 12. The satisfying set generator for C = AtLeastK(c1, . . . , cn) given in Definition 11 is correct. Further, it is complete if thesatisfying set generators for the ci are complete and for all i (cid:12)= j, Xci and Xc j are disjoint.Proof. (Correct) The satisfying set generator for C returns Fail when fewer than k children are satisfiable, matching thedefinition of AtLeastK. A satisfying set F generated for C must contain satisfying sets for at least k of its children, thereforeany assignment that contains F must satisfy those k children.(Completeness) If C is unsatisfiable, there cannot exist k children of C which have a complete satisfying set, and so thesatisfying set generator for C will return Fail. If C is satisfiable, it must have at least k satisfiable children, so completesatisfying sets can be generated for these k children. Given any subdomain list S D for XC which contains these k completesatisfying sets, the same k children must have a satisfying assignment in S D. Joining these k disjoint assignments, togetherwith any assignment to every other variable in XC , produces a satisfying assignment to C . Therefore the satisfying setgenerator for C is complete as long as the satisfying set generators for its children are complete, and the scopes of thechildren are disjoint. (cid:2)4.3. The watched Or and And propagatorsIt is easy to take our algorithm for AtLeastK, and generate algorithms for both And and Or. Or is logically identical toAtLeastK when k = 1, although of course this algorithm will not achieve constructive disjunction, as discussed in Section 2.3.Furthermore And is equivalent to AtLeastK when k is set equal to the number of children. (Watched And is useless inisolation, as it will achieve identical propagation as posting the child constraints individually. However, it is useful as a childof an Or or AtLeastK constraint.)Given this observation, the propagators and satisfying set generators for Watched Or and Watched And are straightfor-ward specialisations of Watched AtLeastK. For both algorithms, there are some simplifications and performance gains whichcan be achieved by fixing k.The algorithm for Or is a generalisation of unit propagation (with 2-literal watching) in SAT [12]. A SAT clause is an Orof literals of Boolean variables ((cid:7)xi, 0(cid:8) or (cid:7)xi, 1(cid:8)).4.4. ComplexityLemma 10 showed that the polynomial-time algorithm given for AtLeastK achieves GAC if there are no repeated vari-ables, so the specialisations of it we describe in Section 4.3 for Watched Or and Watched And will also run in polynomial1418C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429time and achieve GAC. As discussed previously in Section 2.3, it is possible to achieve GAC in polynomial time on WatchedOr, even with variables repeated in different disjuncts. Lemma 14 shows that this is not the case for AtLeastK for k (cid:2) 2.Definition 13. The True constraint is the constraint on no variables which contains a single empty tuple. Therefore it isalways satisfied. The False constraint is the constraint on no variables which contains no tuples, and is therefore alwaysfalse.Lemma 14. GAC propagation of And (C) is NP hard if |C| (cid:2) 2, and AtLeastK (k, C) is NP-hard if k (cid:2) 2 and |C| (cid:2) 2.Proof. Bacchus and Walsh [9] show that the And of two constraints with polynomial-time GAC propagators is NP-hard,when the constraints are allowed to share variables. We can extend this result to And (C) for |C| (cid:2) 3 by adding |C| − 2copies of the True constraint (Definition 13). We can further extend this result to AtLeastK (k, C) by adding k − 2 copies ofthe True and |C| − k copies of False (Definition 13). (cid:2)4.5. Experimental resultsWe claimed in Section 1.2 that both constraint trees and movable triggers are essential for propagation of logical con-nectives. Here we test that claim on four different problems.All of our experiments use Minion version 0.10 which can be downloaded from http://minion.sourceforge.net. We ranour experiments on 4 servers using Intel Xeon 2.4 GHz CPUs. Each server has 2 cores and 2 GB of memory, and is runningLinux kernel 2.6.18. We repeated each experiment 5 times and took the instance with minimum runtime as representative,since this is the run suffering from the least interference and hence most closely approximating the ideal. The maximumcoefficient of variation of any set of 5 runs is under 1.3%. All our problem instances are available online.4 All times are givenin seconds.4.5.1. The generalised pigeon-hole problemThe first experiment is a generalisation of the pigeon-hole problem. We consider the problem of finding assignments toa two-dimensional array of variables, where every pair of rows in the array must be unequal.The parameters for this problem are the number of rows n, the number of columns p, and the domain size d. Weintroduce a matrix of variables M[1 . . . n, 1 . . . p] ∈ {1 . . . d}. All five models must introduce n(n − 1)/2 not-equal constraintsbetween pairs of rows in M. We compare five representations of the constraint that two rows r1 and r2 are not equal.Watched OR:Implement M[r1, 1] (cid:12)= M[r2, 1] ∨ · · · ∨ M[r1, p] (cid:12)= M[r2, p] as a Watched Or (described in Section 4.3) thatenforces GAC.Element: We ensure that r1 and r2 differ at some position by adding, for each pair of rows:Sum:• New variables X ∈ {1, . . . , p} and Y , Z ∈ {1, . . . , d}.• The constraints M[r1, X] = Y , M[r2, X] = Z and Y (cid:12)= Z .Decompose the model for Watched OR into:• New variables N[1 . . . p] ∈ {0, 1}.• The constraints ∀i. (N[i] ⇔( M[r1, i] (cid:12)= M[r2, i])) and ((cid:3)(cid:3)N) (cid:2) 1.Watched Sum: The same model as Sum, except the constraint (N) (cid:2) 1 is replaced by a SAT clause implemented usingmovable triggers.Custom: A custom-written propagation algorithm using static triggers on all variables, enforcing the same level of consis-tency as Watched OR (GAC).These models explore all four possibilities of using static or movable triggers, with reification or constraint trees, asshown in the table below.ReificationConstraint treesStatic triggersSumCustomMovable triggersWatched SumWatched ORNote that using Theorem 6.6 from [18], as long as we get GAC on each of the constraints in the Sum and WatchedSum models, we get GAC over the whole Or, and further as long as we place the new variables at the end of the searchordering, the resulting searches will be identical to the Watched OR model. Therefore, the only model which could result ina different sized search is Element.Since we achieve GAC, there is no scope for Lhomme’s algorithm [10,11] (or other constructive disjunction algorithms) toenforce a stronger consistency. Lhomme’s algorithm is statically triggered, and would be similar to Custom in this context.4 http://www.cs.st-andrews.ac.uk/~pn/or-reify-journal-instances.tar.bz2.C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291419Table 1Search size for small instances of the array pigeon-hole problem.(cid:7)n, p, d(cid:8)(cid:7)8, 3, 2(cid:8)(cid:7)8, 3, 3(cid:8)(cid:7)8, 4, 2(cid:8)(cid:7)8, 4, 3(cid:8)ElementTime25.818028.622137.13>109,067.70Nodes12,335,5933,112,501,7601,092,789,218>45,000,000,000Table 2Nodes per second averaged over 100 seconds of pigeon-hole instances where n = 100.(cid:7)n, p, d(cid:8)(cid:7)100, 5, 2(cid:8)(cid:7)100, 10, 2(cid:8)(cid:7)100, 20, 2(cid:8)(cid:7)100, 30, 2(cid:8)(cid:7)100, 40, 2(cid:8)(cid:7)100, 50, 2(cid:8)(cid:7)100, 5, 10(cid:8)(cid:7)100, 10, 10(cid:8)(cid:7)100, 20, 10(cid:8)(cid:7)100, 30, 10(cid:8)(cid:7)100, 40, 10(cid:8)(cid:7)100, 50, 10(cid:8)Watched OR191,536.22499,007.211,576,413.851,579,347.991,461,316.061,439,796.97690,482.51379,255.81239,937.97203,991.09155,887.24124,141.39Sum19,304.051268.15755.48548.23424.32370.621404.05817.18378.53266.58234.83203.79Watched ORTime0.270.270.270.27Nodes25283336Watched SumCustom29,404.221377.21782.40564.70428.23373.951439.98838.69385.92307.82253.54225.5454,180.0479,704.1487,443.9984,170.6078,234.2076,766.77105,234.71103,457.5079,418.7671,914.2365,572.3456,685.84Table 1 shows just how badly the Element model performs in practice on some very small instances, quickly leading toinsolvable problems which the other models we consider are all able to solve in less than a second. Due to the very poorperformance of this model, it will not be considered further.As the remaining four models produce identical search trees, in Table 2 we compare them on various instances in termsof the number of nodes of search they perform per second. The Custom model improves significantly on Sum and WatchedSum by eliminating the additional variables, but Watched OR is always faster than Custom, sometimes by several ordersof magnitude. When in the watching phase, the Watched Or algorithm will use only four movable triggers: two for eachwatched child constraint. By comparison, the custom algorithm has assignment triggers on all variables. This illustrates theimportance of using an appropriate triggering mechanism, in this case movable triggers.With domain size 2, the Watched Or algorithm sometimes increases in speed as instance size increases. This surprisingresult is caused by a decrease in the proportion of variables with a movable trigger on them.The small differences between Sum and Watched Sum show that the gain from using movable triggers for the sumconstraint is often insignificant compared to the cost of propagating the reified not-equal constraints.In summary, these results support the hypothesis that both constraint trees and movable triggers can be used to effi-ciently propagate Or.4.5.2. The anti-chain problemIn our second experiment we consider the anti-chain problem, defined below.Definition 15. An anti-chain is a set S of multisets where ∀{x, y} ⊆ S. x (cid:12)⊆ y ∧ y (cid:12)⊆ x.The (cid:7)n, l, d(cid:8) instance of anti-chain finds a set of n multisets with cardinality l drawn from d elements in total, satisfyingthe constraint of Definition 15. We model this as a CSP using n arrays of variables, denoted M1, . . . , Mn, each containing lvariables with domain {0, . . . , d − 1} and the constraints ∀i (cid:12)= j ∈ {1, . . . , n}. ∃k ∈ {1, . . . , n}. Mi[k] < M j[k].Each variable Mi[v] represents the number of occurrences of value v in multiset i, up to a maximum of d − 1. Each pairof rows Mi and M j differ in at least two places: in one position k, Mi[k] < M j[k] and in another position p, Mi[p] > M j[p].This ensures that neither multiset contains the other.Similarly to the generalised pigeon-hole problem, we consider 4 implementations of the constraint ∃i. M[i] < N[i] forarrays M and N.Watched OR:Element:Sum:Implemented as a Watched Or.Introduce variables i with domain {0, . . . , l − 1} and m and n each with domain {0, . . . , d − 1}. Impose the threeconstraints M[i] = m, N[i] = n and m < n.Introduce a new array of Boolean variables b of length l and impose the set of constraints ∀i. (M[i] < N[i]) ↔ b[i]and also(cid:3)(bi j) (cid:2) 1.1420C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429Table 3Search size for finding the first solution to the anti-chain problem.(cid:7)n, l, d(cid:8)(cid:7)11, 4, 3(cid:8)(cid:7)12, 4, 3(cid:8)(cid:7)13, 4, 3(cid:8)(cid:7)14, 4, 3(cid:8)(cid:7)9, 4, 10(cid:8)(cid:7)10, 4, 10(cid:8)(cid:7)11, 4, 10(cid:8)(cid:7)12, 4, 10(cid:8)(cid:7)11, 5, 2(cid:8)ElementTime3.8377.404488.454931.103.7628.31171.82775.36735.76Nodes142,6743,030,555166,888,355166,888,37290,678636,6353,340,22512,311,35447,602,427Table 4Finding all solutions for instances of the anti-chain problem.(cid:7)n, l, d(cid:8)(cid:7)2, 4, 3(cid:8)(cid:7)3, 4, 3(cid:8)(cid:7)4, 4, 3(cid:8)(cid:7)3, 6, 2(cid:8)(cid:7)3, 7, 2(cid:8)ElementTime0.023.62814.422.7961.05NodesSolutions18,6282,855,281561,666,8633,102,71970,533,11987481,269,108240,375,3121,551,36035,266,560Table 5Nodes per second achieved on anti-chain instances.(cid:7)n, l, d(cid:8)(cid:7)100, 5, 2(cid:8)(cid:7)100, 10, 2(cid:8)(cid:7)100, 20, 2(cid:8)(cid:7)100, 30, 2(cid:8)(cid:7)100, 40, 2(cid:8)(cid:7)100, 50, 2(cid:8)(cid:7)100, 5, 10(cid:8)(cid:7)100, 10, 10(cid:8)(cid:7)100, 20, 10(cid:8)(cid:7)100, 30, 10(cid:8)(cid:7)100, 40, 10(cid:8)(cid:7)100, 50, 10(cid:8)Watched OR22,351.3813,503.048812.306564.406426.524870.18344.69382.78385.45413.34506.79672.59Watched ORTime0.649.68416.89444.870.340.733.1615.68188.30Nodes8099288,3777,657,223167,9991,845,143Watched ORTime0.000.164.940.101.04Sum727.77598.67466.01492.44434.64451.6842.2334.0839.5942.9256.5067.06Nodes77,1172,189,03495,301,65995,301,66112,34975,807399,9971,815,75547,602,427Solutions4050144,1503,823,20084,000922,572Watched Sum984.32552.10640.04386.65374.49343.5232.8934.9537.2541.8554.9669.39Watched Sum: The same model as Sum, except the constraint (implemented with movable triggers.(cid:3)b) (cid:2) 1 is replaced by a SAT clause b[1] ∨ · · · ∨ b[l]We did not construct a custom propagator for this experiment because it takes considerable effort and we are concernedwith generic algorithms.Similarly to the previous experiment, the Watched OR, Sum and Watched Sum models all enforce the equivalent of GACon the original expression, and Element does not.Once again, we will consider the Element model separately, as we must compare time, rather than just nodes per second.In each of these experiments, we search for only the first solution and results are given in Table 3.These results are much closer than those in the pigeon-hole problem. On some instances, such as (cid:7)11, 5, 2(cid:8), the Elementmodel even achieves the same sized search as Watched OR. However, Element was slower in terms of nodes per secondon all the instances we considered. Furthermore, Element sometimes exhibits a much larger number of solutions. Table 4shows the results of finding all solutions to a small set of problems. The number of solutions found by the Watched ORmodel is the correct number of solutions, the Element duplicates some of these solutions multiple times, due to the factits auxiliary variables can take multiple values for each solution to the problem. This shows once again the limitation of theElement model in practice.To compare the other three models we consider how many nodes per second the particular model can solve, averagedover the first 100 seconds of search. In both cases we consider solving the anti-chain problem on 100 arrays (n = 100) ofvarying length and domain size.C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291421Table 6Nodes per second achieved on Hamming instances.Distance (s)Watched AtLeastK49454030201053212,660.0155,012.0653,005.73159,528.97184,247.4976,531.801,502,509.711,733,255.031,726,415.28Sum10,932.1950,508.9852,200.7254,943.0854,770.7520,405.951613.261226.181166.95Watched Sum1746.424446.969491.1319,336.1530,900.5813,281.601639.261239.551166.50A number of conclusions can be drawn from the results of this experiment, given in Table 5. First of all, our algorithmperforms well compared to Sum on short vectors, but performance decreases as the length increases. For example withBoolean domains for length 5 arrays our algorithm is around 31 times faster, decreasing to 11 times at length 50. Wenote that for larger domains the nodes per second increases as the problem size increases. This is in common with thepigeon-hole problem, and is caused by a decrease in the proportion of variables with a movable trigger on them.This experiment partially supports the hypothesis that both constraint trees and movable triggers are required to effi-ciently propagate Or. However we do not have an algorithm using static triggers with constraint trees, so we have not fullyexplored the space.4.5.3. The Hamming codes problemIn this section we consider Hamming codes (see [19]), defined below.Definition 16. The (cid:7)n, l, d, s(cid:8) instance of the Hamming problem is to find a set of n codewords of length l with alphabet{1 . . . d}, where each pair of codewords differ in at least s positions.This is modelled as follows. We have n arrays of integers, named M1, . . . , Mn, each of length l and domain {1, . . . , d}k∈{1,...,l} Mi[k] (cid:12)= M j[k]) (cid:2) s. We compare 3 repre-with the following Hamming distance constraints: ∀{i, j} ⊆ {1, . . . , n}. (sentations of the constraint (i∈{1,...,l} M[i] (cid:12)= N[i]) (cid:2) s.(cid:3)(cid:3)Watched ATLEASTK: Directly represented as a Watched AtLeastK, the algorithm described in Section 4.2.Sum:Introduce an array of auxiliary Boolean variables b[l] and add the set of constraints ∀i ∈ {1, . . . , l}. (M[i] (cid:12)= N[i]) ↔b[i]. Then impose(cid:3)b (cid:2) s.(cid:3)Watched Sum: The same model as Sum, except the constraintb (cid:2) s is replaced by a watched sum constraint.For this problem we do not attempt to give an Element model, because preliminary experiments showed that theperformance was so poor it was impossible to usefully compare it to any of the other models. All three models enforce GAC,because the child constraints of the AtLeastK do not share variables.We experimented with the Hamming codes problem where n = l = 50 and d = 2, and the Hamming distance s is varied.The results are presented in Table 6. As stated in Section 4.2, we expect the Watched AtLeastK algorithm to be most efficientwhen k is small (where k = s here). This is supported by Table 6, which shows Watched AtLeastK performing much betterat low values of s than high values. However Watched AtLeastK dominates Sum and Watched Sum at all values of s. Ats = 49, Watched AtLeastK will watch all child constraints, so there is little scope for it to improve on Sum.In summary, this experiment provides some evidence that the gains from using constraint trees and movable triggersapply to AtLeastK as well as Or.4.5.4. The supertree problemThe supertree problem [20] is that of transforming an input set of rooted bifurcating trees (species trees), describing theevolutionary history of a set of species, into an output tree respecting all the relationships in the input. Various CP modelshave been created to solve this problem, here we will use the model of [21] as well as the optimisation model of [22]. Bothconsist almost entirely of constraints of the form (a (cid:3) b = c) ∨ (b (cid:3) a = c) ∨ (c (cid:3) a = b) ∨ (a = b = c). The standard modelrequires all such constraints to be satisfied, while the optimisation model maximises the number that are satisfied.This can be modelled directly as Or(And(a (cid:3) b, b = c), And(b (cid:3) a, a = c), And(c (cid:3) a, a = b), And(a = b, a = c, b = c))using Watched And and Watched Or. Note that this modelling does not require any auxiliary variables. The conjuncts anddisjuncts share variables, so GAC may not be enforced by the Watched And and Or propagators.We compare this to the Sum model. We have already described how Or is handled using sums (Section 4.5.1). Torepresent And, we reify each conjunct, and then use a sum constraint to represent the conjunction. This encoding usesauxiliary variables and enforces the same level of consistency as the above Watched Or and And encoding.We use all instances from Moore and Prosser [22] that have two input trees and are small enough to load. (The modeltakes cubic space and the larger instances exceeded 2 GB RAM.) These are partitioned into ten solvable instances and four1422C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429Table 7Experimental data for solvable supertree instances.InstanceNodesWatched timeSum timeABADAFAGBDBFBGCDCFDF5897661527227785330810.320.450.320.410.540.330.470.580.380.940.420.790.400.730.720.430.731.140.531.07Table 8Experimental data for unsolvable supertree instances.InstanceACBCCGDGBest sol found48 cons satisfied271343Watched time3063.093591.101264.823766.26Sum time11,146.4422,235.872360.068404.40Saving22.12%42.24%20.60%43.87%24.65%24.36%35.12%48.50%29.14%12.76%Saving72.52%83.85%46.41%55.19%instances where input trees contain conflicting information (e.g. tree 1 says that a and b are closer relatives to each otherthan to c, whereas tree 2 says that a and c are closest). The standard model is used for the solvable instances, and theoptimisation model for the unsolvable ones.Table 7 shows that the watched model is significantly faster than Sum for the ten solvable instances. These times do notinclude time to load instances, however load times are larger for Sum because it is less concise. Table 8 presents resultsfor the unsolvable instances. We ran these instances to 2,000,000 nodes and again the results are in favour of the watchedmodel. Using a profiler we discovered that the speedups are due to an increase in propagation speed; the reduced cost ofcreating, setting and backtracking the additional auxiliary variables has an insignificant effect in this case.In summary, this final experiment shows that the Watched Or algorithm can be valuable when combined with anotherparent constraint.5. ReificationThe reification of a constraint C produces another constraint Cr , such that Cr has an extra Boolean variable r in its scope,and (in any solution) r is set to true iff the original constraint C is satisfied.def≡ r ⇔ CCrConstraints can be combined in arbitrary ways using reification. For example, consider the exclusive-or of a set of con-straints, as follows.C1 ⊕ C2 ⊕ · · · ⊕ CnAn odd number of these constraints must be satisfied in any solution. It is straightforward to represent this structure withreification. The constraints C1 . . . Cn are each reified, creating extra variables r1 . . . rn. These are added using a sum constraint,and the total variable is constrained to be odd.Previous work on generic reification (Section 2.4) has been limited in one of two ways: the method cannot make use ofefficient global propagators such as Régin’s AllDifferent [14] (e.g. indexicals and propia [13,15]); or GAC propagation is notachieved [16,8]. Our methods overcome both these limitations, at the cost of requiring propagators for both C and ¬C .In this section we describe two ways to propagate reified constraints, and compare them empirically. The first methoduses only static triggers. The second method uses movable triggers, and is more complex, but it overcomes some of theapparent disadvantages of the first method.We also investigate another form of reification, which we call reifyimply, where the reification variable implies the con-straint, as follows.def≡ r ⇒ CCriAgain we describe an algorithm based on checking and a movable trigger algorithm to propagate reifyimplied constraints.5.1. Theoretical analysisTheorem 17 provides a simple algorithm which achieves GAC propagation for r ⇔ C , given a GAC propagator for bothC and ¬C . We shall consider two different ways of making this algorithm more efficient, using incrementality. In generalC. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291423the propagators for C and ¬C will be very different and can have very different complexities. Lemma 18 shows that thepropagator for r ⇔ C is tractable if and only if the propagators for both C and ¬C are tractable.Theorem 17. The following Algorithm 3 is a GAC propagation algorithm for r ⇔ C for Boolean variable r and any constraint C ,assuming r is not in the scope of C and that the propagators for C and ¬C achieve GAC propagation.Input: r, Cif Domain(r) = {True, False} thenif There is no satisfying assignment to C thenr (cid:12)= Trueendif There is no satisfying assignment to ¬C thenr (cid:12)= Falseendendif Domain(r) = {True} thenPropagate(C)elseif Domain(r) = {False} thenPropagate(¬C)endendAlgorithm 3: GAC propagation algorithm for reify.Proof. Consider the following cases upon entering the algorithm:1. Domain(r) = {TRUE, FALSE}: In this case, we check if the values in r are supported. This requires finding both anassignment to XC which satisfies C , and an assignment which does not satisfy C . If either value is unsupported it isremoved, and the algorithm continues with case 2 below.If neither value of r is removed then every value in the domain of every variable in the scope of C is supported, byeither C or ¬C . Any assignment to the variables in C can be extended to a satisfying assignment to r ⇔ C by adding eitherr = True or r = False, depending on whether the assignment satisfies C or ¬C .2. Domain(r) contains a single value: In this case, if the domain of r is {True}, r ⇔ C is exactly equivalent to C , and ifthe domain of r is {False}, the constraint is equivalent to ¬C . (cid:2)Lemma 18. GAC(r ⇔ C) is NP-hard if and only if at least one of GAC(C) and GAC(¬C) is.Proof. Running GAC(C ) on a subdomain list removes all domain values if and only if there is no satisfying assignment for C .Therefore, Theorem 17 demonstrates how to implement GAC(r ⇔ C) using at most one invocation of GAC(C ) and at mostone invocation of GAC(¬C ). Therefore GAC(r ⇔ C) is polynomial time if both GAC(C ) and GAC(¬C ) are. By assigning r toTrue or False, we can see that GAC(r ⇔ C) must be at least as hard as both GAC(C ) and GAC(¬C ). (cid:2)In this paper reification is implemented as a constraint tree with two child constraints, C and ¬C . This raises the issue ofshared variables among child constraints, as discussed in Section 2.4.2. However, the constraint tree propagator implementsAlgorithm 3, and therefore enforces GAC despite the shared variables.Theorem 19 presents a basic algorithm for implementing the constraint r ⇒ C . We will improve this basic algorithmusing incrementality.Theorem 19. The following Algorithm 4 is a GAC propagation algorithm for r ⇒ C for Boolean variable r and any constraint C ,assuming r is not in the scope of C and the propagator for C achieves GAC.Input: r, Cif Domain(r) = {True, False} thenif There is no satisfying assignment to C thenr (cid:12)= True;endelseif Domain(r) = {True} thenPropagate(C)endendAlgorithm 4: GAC propagation algorithm for reifyimply.1424C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429Proof. This proof follows the cases in the algorithm:1. Domain(r) = {TRUE, FALSE}: In this case, every value in the domain of every variable in the scope of C is supported, asan assignment which contains r = False satisfies the constraint. Therefore the only value which could possibly be eliminatedis r = True. This value is allowed if and only if there exists an assignment to XC which satisfies C .2. Domain(r) contains a single value: In this case, if the domain of r is {True}, the constraint is exactly equivalent to justC , and if the domain of r is {False}, any assignment satisfies the constraint so no pruning can occur. (cid:2)5.2. Algorithms for reification and reifyimplyThe following algorithms for r ⇔ C and r ⇒ C have some features in common. They all have a phase for checkingentailment/disentailment of C , so that r can be set when necessary (the watching or checking phase). They all have a phasefor propagating C (or ¬C ) when that is necessary (the propagation phase). The movable trigger algorithms also have a setupphase where movable triggers are placed for the first time.When describing the algorithms, C is described as a child constraint object, with methods for propagation, checkingdisentailment (checkUnsat) and a satisfying set generator. Checking for disentailment is equivalent to checking if a satisfyingset generator would return Fail. This means it can often be implemented more efficiently. Full reification also has ¬C as achild. Child constraints do not receive trigger events unless they are passed through by the parent.5.3. Watched reificationFirst we describe implementing reification using movable triggers. Following this, we will show three simple modifica-tions of this algorithm. In this scheme, both the positive and negative child constraints must implement a satisfying setgenerator. Watched reification has three phases, described below. There are three sets of triggers: triggers required by thechild constraints; the static trigger on r; movable triggers placed in phases 1 and 2 to watch satisfying sets.Setup Phase:If r is assigned, move to the propagation phase. Otherwise, call the satisfying set generator for both childconstraints. If either child returns Fail, then it is disentailed. Set r appropriately and move to the propagationphase. Otherwise, place static triggers on r and movable triggers on both satisfying sets and move to the watchingphase.Watching Phase:If r is assigned, move to the propagation phase. If a domain value being watched is removed, then de-termine which child it belongs to, and call the satisfying set generator again for the child. If it returns Fail, set rappropriately and move to the propagation phase. If it returns a satisfying set, place movable triggers on it andremain in this phase.Propagation Phase:If r = 1 then propagate the positive constraint, otherwise propagate the negative constraint. Triggerevents for the appropriate child constraint are passed through.Since movable triggers are not backtracked, it is possible to receive stale trigger events from movable triggers whichwere placed in a different phase. Therefore in the watching and propagation phases, some trigger events must be ignoredor otherwise handled specially. These are listed below.Watching Phase: Trigger events from the propagation phase may be received in this phase; in this case the movable triggeris removed and the event is ignored. Any trigger events belonging to child constraints are ignored.Propagation Phase: When propagating one child constraint, trigger events for the other child are ignored. Movable triggerevents from setup and watching phases are ignored.Notice that movable triggers from the setup and watching phases are not removed in the propagation phase. Whenbacktracking into the watching phase, there is no opportunity to place movable triggers, but the previous set are still bepresent so there is no need to replace them.The setup phase only occurs when the propagator is first invoked. The other two phases occur during search, and weuse one backtracking Boolean to indicate which phase the algorithm is in. This algorithm does not make use of the factthat disentailment of C implies entailment of ¬C , and therefore can perform unnecessary propagation of entailed childconstraints. We leave this for future work.5.3.1. ReifyimplyWe implemented watched reifyimply, using the abstract Algorithm 4. As Algorithm 4 is a subset of Algorithm 3, we didthis by taking a subset of the concrete algorithm described in Section 5.3 above. This required removing the child constraint¬C , as it is not necessary to check disentailment of, or propagate, ¬C . Also, it is only necessary to trigger when r is assigned1, as no propagation occurs when r is assigned 0.C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291425Table 9Times and call counts for steelmill instances.Instance405060708090WatchedTime2120.022329.732839.903542.024488.405390.12Calls to SSG151131156246282320StaticTime2180.972362.712884.103619.984622.785248.09Calls to CU1,350,922,599758,088,0751,193,581,8571,589,486,5392,525,193,9862,596,608,279OverallWinnerW by 2.87%W by 1.42%W by 1.56%W by 2.20%W by 2.99%S by 2.63%5.4. Static reificationWe implement a static variant of both reify and reifyimply. These use a disentailment checker instead of a combinationof a satisfying set generator and movable triggers to detect when a constraint is disentailed. Static reification requires boththe positive and negative child constraints have a checkUnsat method which checks if the constraint is disentailed. Beforesearch begins, the (static) triggers of both the positive and negative constraints are placed on the variables, along with atrigger on the reification variable.55.5. Empirical comparison of reification algorithmsIn this section we give an empirical comparison of reify and reifyimply, in their watched and static forms, using a rangeof realistic benchmark problems.Notice that checkUnsat (CU) in static reification, and satisfying set generators (SSG) in watched reification perform similartasks. Both determine whether a constraint is disentailed. Satisfying set generators additionally return a satisfying set ofliterals when the constraint is not disentailed. For all reified or reifyimplied constraints in the benchmarks, the two functionsare equivalent for determining disentailment. Hence, static and watched algorithms provide the same level of consistency,and the solver explores the same number of search nodes for all benchmarks.One metric we use to compare static and watched algorithms is the number of calls made to CU and SSG. Consider ahypothetical solver which only offers triggers (static or watched) on individual domain values. CU must have static triggerson any value which may be important at any time during search. SSG is able to place watches during search. In this solverSSG cannot be called more times than CU. In most cases, this carries through to Minion, however Minion has assignmenttriggers which are not available to SSG. For movable triggers to have any potential, the number of calls to SSG must besubstantially fewer, since the cost of calling it is somewhat higher and there is the additional overhead of placing movabletriggers.The methodology and hardware used for the following experiments was the same as for those described in Section 4.5.5.5.1. Steel mill slab designOur first benchmark consists of instances of the steel mill slab design problem [23]. This is a well-known optimisationproblem involving assigning orders to a steel mill to slabs, minimising the total waste. Our instances include reifyimpliedlex ordering constraints on rows of a 0/1 matrix, these constraints break symmetry on the rows and are reifyimplied sothat they can be switched off when a row (corresponding to a slab) is not needed to fulfil the set of orders.Our evaluation on these instances exhibits solid results in favour of watched reifyimply. Table 9 shows an exceptionaldecrease in calls to SSG compared to CU, for watched versus static reifyimply, running the instances up to 100,000,000nodes. Here billions of calls are being made to CU compared to hundreds for SSG. In fact, after the first 100 nodes of searchin all these examples, the movable triggers are hardly ever moved. Instance 90 is typical: during the first 100 nodes, SSG iscalled 260 times; at 10,000 nodes it has been called 301 times; and at 1,000,000 nodes it has been called 315 times. Forthe same instance CU is being called over 60 times per node on average up to 1,000,000 nodes. This dramatic improvementis due to the movable triggers being very rarely triggered in the watched variant, whereas for the static variant the boundtriggers are being woken up frequently even when the constraint remains satisfiable. SSG needs to place movable triggerson just two values in the scope of the lexleq needed to ensure it remains satisfiable, whereas CU has bound triggers on allthe variables in the scope of the constraint.Table 9 shows that this improvement in calls translates to an improvement in solution time. This improvement is rela-tively small in absolute terms, but this is because most of the time is spent propagating other constraints besides reifyimply.With the aid of a profiler, we have discovered that, on benchmark 90, the average call to SSG for the lexicographic orderingconstraint consumes 2695 CPU instructions whereas the average call to CU consumes just 54. These statistics give an im-pression that the SSG movable triggers must be triggered substantially less often than the static triggers to justify the cost,in this case more than 50 times less often (since there is an additional overhead of placing dynamic triggers on the literals).5 Our implementation of static reification does not allow children to use movable triggers.1426C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429Fig. 3. Comparison of calls to SSG and CU for blackhole problems.Fig. 4. Comparison of time spent on blackhole problems.5.5.2. Blackhole solitaireBlackhole solitaire [24] is a single-player card game. The initial layout is 17 stacks of 3 cards, with all cards visible. Thereis one special stack, containing only the ace of spades initially, named the black hole. Cards are moved from the top of astack onto the black hole, and the game is completed when all 51 cards have been moved onto the black hole. The cardmoved must be adjacent to (but not the same as) the previous card on the black hole, regardless of suit, where adjacencywraps around (i.e. king is adjacent to ace). A solution is a sequence of 51 valid moves.Our model of blackhole solitaire contains reifyimplied less-than constraints (r ⇒ x1 < x2). The less-than constraint placestwo static triggers, one on the lower bound of x1 and the other on the upper bound of x2. SSG always returns two movabletriggers, the lower bound of x1 and the upper bound of x2. When bounds are restored on backtracking, the movable triggersare no longer on the bounds. This effect allows SSG to be called many fewer times than CU on these benchmarks. Themodel also contains reified less-than and sum-greater constraints, which were propagated statically in both cases, so as notto influence the results.As shown in Fig. 3 the total number of calls to SSG for all constraints is much smaller than the number of calls to CUfor each instance of blackhole we tried. The black line on the plot is the line y = x/10, or the “10 times better line”, sinceall points beneath the line use at least 10 times more calls to CU than SSG, for static and watched reifyimply respectively.Using a profiler, we have discovered that the mean number of CPU instructions in a call to SSG was 54 versus 9 instructionsper call to CU, meaning that the ratio of CU to SSG would have to be more than 6 for dynamic reifyimply to have a chanceof winning. This does not take into account the time to additionally place the watches, and so Fig. 4 shows that even a ratioof 10 is not sufficient, as the static algorithm is slightly faster on this benchmark.5.5.3. Contrived benchmarkWe use a reified allDifferent constraint in a contrived problem intended to demonstrate the potential of watched reifica-tion. We expect that watched reification will perform well if the movable triggers can settle on values which are never (oronly rarely) removed. This effect was observed for watched reifyimply, on the steel mill slab design problem.Problem instances can be generated for any positive integer k, and consist of two k-vectors X and Y with do-mains {1, . . . , k}. The constraints are as follows: ∀i ∈ {1 . . . k}: (2 X[i]) (cid:12)= Y [i]; X[k − 1] (cid:12)= X[k]; X[k − 1] = X[k] andr ⇔ allDifferent(Y ).C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291427Fig. 5. Comparison of time spent on English peg solitaire instances.The allDifferent constraint uses a GAC algorithm [25], and maintains a matching from variables to distinct values. SSGfor the positive constraint returns a k-matching if one exists, hence there is one movable trigger for each variable in X . Forthe static reify, CU is called for any domain change. CU is very similar to SSG, it maintains a maximal matching using thesame algorithm as SSG.The negative constraint waits until all variables are assigned, then checks the assignment.6 SSG for the negative constraintplaces two movable triggers on different values of an unassigned variable, if possible. If all variables are assigned, SSG checksif the constraint is disentailed. CU requires an assignment trigger on each variable.The variable ordering is X in index order, values are branched in ascending order. X[k] cannot be consistently assigned,and there is no restriction on the rest of X , so the solver explores kk−1 assignments of X[1 . . . k − 1]. Whenever a variableX[i] is set to j, 2 j is removed from Y [i] by the not-equal constraint. Therefore odd values in Y are never removed, andmovable triggers may settle on them.We ran instance k = 20 with a node limit of 10,000,000. Watched reify made 2509 calls to SSG, compared to 10,526,315calls to CU. With static reify, Minion took 50.82 s, and with watched reify it took 50.16 s. Using the callgrind profiler (anda node limit of 500,000), we found that Minion uses 6.60 bn CPU instructions with static reify and 6.42 bn with watchedreify. The static reify propagator alone uses 193 m instructions, compared to 7.90 m for the watched reify propagator. Thisclearly shows that most of the cost is outside the reification, and that watched reify is performing much better than thestatic variant, as we would expect from the call counts.5.5.4. English peg solitaireFinally we consider the game of English peg solitaire [26], which is played with 32 pegs placed in a board with 33 holes.Pegs are removed by hopping moves (similar to checkers/draughts) until a goal state is reached or no moves are possible.We use model C of Jefferson et al. [26], slightly adapted to suit Minion rather than ILOG Solver. These benchmarks containa large number of reified sum constraints. The constraints state that a sum of Boolean variables is 1 or more. The length ofthe sum ranges from 1 to 8 variables.We used 33 instances with different goals. All instances are run to a node limit of 10,000,000. Fig. 6 shows that, on theseinstances, the number of calls to SSG by watched reification is usually between a half and third of the calls to CU for staticreification. However, Fig. 5 shows that static reification is faster for all instances.We used the profiler callgrind with instance solitaire_benchmark_6 (which takes 40 s with static reification).Minion uses 71.2 billion CPU instructions with static reification, and 78.1 with watched. Static reify alone uses 21.8 bn, andwatched reify uses 26.5, an increase of 22%.75.5.5. Conclusion to empirical comparisonThe results of our experiments are not conclusive, demonstrating that different implementations perform better on dif-ferent constraints and problems. In all cases, we have shown the potential of a movable triggers approach, by demonstratingthat the SSG function is called much less often than CU. On the other hand, static reification (and reifyimply) is simple andfast, and in many cases it is faster than the watched variant.6 The standard implementation in Minion 0.10 is a Watched Or of equal constraints on all pairs of variables. Unfortunately, Watched Or is incompatiblewith the static reification algorithm, so for this experiment the Watched Or was replaced with an assignment checker.7 Changing the reification algorithm changes the propagation order and affects other constraints. In this case, the difference for reify alone is 4.8 bn andfor the whole solver it is 6.9 bn.1428C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–1429Fig. 6. Comparison of calls to SSG and CU for English peg solitaire instances.6. ConclusionIn this paper we have explored possibilities for implementing logical connectives in a constraint solver, with the overallhypothesis that movable triggers and constraint trees together are invaluable. These two solver features are combined withsatisfying set generators, which provide an efficient way of checking the satisfiability of a constraint.First we focused on AtLeastK, Or and And of arbitrary constraints. The ubiquitous way of modelling these in CP is byreifying the constraints, and applying a sum-(cid:2) k constraint (or equivalent) to the reification variables. With this approach,the solver is required to propagate all reified constraints at all times. By contrast, the Watched AtLeastK algorithm wepresent has at most k + 1 active constraints at any time — all others have zero cost. Using this approach on Hamming codeswe were able to demonstrate a 2000 times speedup on some instances compared to reification.We also presented Watched Or, a specialisation of Watched AtLeastK. In our evaluation we observed that Watched Orcan be over 10,000 times faster than reification, and is consistently much faster on all problems we tested.By implementing satisfying set generators for Watched AtLeastK, Or and And, these parent constraints can be arbitrarilynested, giving a rich language for logical expressions. We hope to extend this work to other logical connectives, and also toachieve GAC in the case where child constraints share variables, while maintaining high performance.Secondly, we investigated two ways of implementing both reification and reifyimply for any constraint. We describedsimple algorithms which use static triggers, and more sophisticated algorithms which make use of movable triggers toreduce the number of constraint checks. In our experiments, the results were mixed. In some cases, the simple staticalgorithms were faster, and in others the watched algorithms paid their additional overhead and were more efficient.The common thread through this paper is that movable triggers, satisfying sets and constraint trees together allowsimple, efficient implementation of logical connectives of constraints. Once a constraint has a satisfying set generator (whichis usually much simpler than its propagation function), it can be used in Watched Or and other parent constraints, and it canbe reified and reifyimplied. This makes a simple, general and compelling framework for implementing logical connectives.AcknowledgementsWe would like to thank the anonymous reviewers for their helpful comments about an earlier version of this paper. Thiswork was funded by EPSRC research grant numbers EP/C523229/1 (Jefferson), EP/H004092/1 (Jefferson, Nightingale, Petrie),EP/E030394/1 (Moore, Nightingale), and a Royal Society Dorothy Hodgkin Fellowship (Petrie).References[1] I.P. Gent, C. Jefferson, I. Miguel, Watched literals for constraint propagation in minion, in: F. Benhamou (Ed.), CP, in: Lecture Notes in Computer Science,vol. 4204, Springer, 2006, pp. 182–197.[2] K.R. Apt, Principles of Constraint Programming, Cambridge University Press, 2003.[3] F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Elsevier, 2006.[4] I.P. Gent, C. Jefferson, I. Miguel, Minion: A fast scalable constraint solver, in: G. Brewka, S. Coradeschi, A. Perini, P. Traverso (Eds.), ECAI, in: Frontiers inArtificial Intelligence and Applications, vol. 141, IOS Press, 2006, pp. 98–102.[5] S. Brand, R.H.C. Yap, Towards “propagation = logic + control”, in: S. Etalle, M. Truszczynski (Eds.), ICLP, in: Lecture Notes in Computer Science,vol. 4079, Springer, 2006, pp. 102–116.[6] T. Müller, J. Würtz, Constructive disjunction in Oz, in: Workshop Logische Programmierung (WLP), in: GMD-Studien, vol. 270, Gesellschaft für Mathe-matik und Datenverarbeitung MBH, 1995, pp. 113–122.[7] J. Würtz, T. Müller, Constructive disjunction revisited, in: G. Görz, S. Hölldobler (Eds.), German Conference on Artificial Intelligence (KI), in: LNCS,vol. 1137, Springer, 1996, pp. 377–386.[8] M.Z. Lagerkvist, C. Schulte, Propagator groups, in: I.P. Gent (Ed.), CP, in: Lecture Notes in Computer Science, vol. 5732, Springer, 2009, pp. 524–538.C. Jefferson et al. / Artificial Intelligence 174 (2010) 1407–14291429[9] F. Bacchus, T. Walsh, Propagating logical combinations of constraints, in: L.P. Kaelbling, A. Saffiotti (Eds.), IJCAI, Professional Book Center, 2005, pp. 35–40.[10] O. Lhomme, An efficient filtering algorithm for disjunction of constraints, in: F. Rossi (Ed.), CP, in: Lecture Notes in Computer Science, vol. 2833,Springer, 2003, pp. 904–908.[11] O. Lhomme, Arc-consistency filtering algorithms for logical combinations of constraints, in: J.C. Régin, M. Rueher (Eds.), CPAIOR, in: Lecture Notes inComputer Science, vol. 3011, Springer, 2004, pp. 209–224.[12] M.W. Moskewicz, C.F. Madigan, Y. Zhao, L. Zhang, S. Malik, Chaff: engineering an efficient sat solver, in: DAC ’01: Proceedings of the 38th AnnualDesign Automation Conference, ACM, New York, NY, USA, 2001, pp. 530–535.[13] P.V. Hentenryck, V. Saraswat, Y. Deville, Constraint processing in cc(fd), Technical report, Brown University, 1991.[14] J.C. Régin, A filtering algorithm for constraints of difference in CSPs, in: Proceedings 12th National Conference on Artificial Intelligence (AAAI 94), 1994,pp. 362–367.[15] A. Aggoun, D. Chan, P. Dufresne, E. Falvey, H. Grant, W. Harvey, A. Herold, G. Macartney, M. Meier, D. Miller, S. Mudambi, S. Novello, B. Perez, E. vanRossum, J. Schimpf, K. Shen, P.A. Tsahageas, D.H. de Villeneuve, Eclipse user manual release 5.10, http://eclipse-clp.org/, 2006.[16] C. Schulte, Programming deep concurrent constraint combinators, in: Proceedings of Practical Aspects of Declarative Languages (PADL 2000), in: LNCS,vol. 1753, Springer, 2000, pp. 215–229.[17] C. Bessiere, E. Hebrard, B. Hnich, T. Walsh, The complexity of reasoning with global constraints, Constraints 12 (2) (2007) 239–259.[18] C. Jefferson, Representations in constraint programming, PhD thesis, University of York, 2007.[19] C.J. Colbourn, J.H. Dinitz, Handbook of Combinatorial Designs, second edition, Discrete Mathematics and Its Applications, Chapman & Hall/CRC, 2006.[20] P. Daniel, C. Semple, Supertree algorithms for nested taxa, in: O. Bininda-Emonds (Ed.), Phylogenetic Supertrees: Combining Information to Reveal theTree of Life, in: Computational Biology Series, Kluwer, 2004, pp. 151–171.[21] I.P. Gent, P. Prosser, B.M. Smith, W. Wei, Supertree construction with constraint programming, in: F. Rossi (Ed.), CP, in: Lecture Notes in ComputerScience, vol. 2833, Springer, 2003, pp. 837–841.[22] N.C. Moore, P. Prosser, The ultrametric constraint and its application to phylogenetics, Journal of Artificial Intelligence Research 32 (2008) 901–938.[23] A.M. Frisch, I. Miguel, T. Walsh, Modelling a steel mill slab design problem, in: IJCAI-01 Workshop on Modelling and Solving Problems with Constraints,2001, pp. 39–45.[24] I.P. Gent, C. Jefferson, T. Kelsey, I. Lynce, I. Miguel, P. Nightingale, B.M. Smith, Search in the patience game ‘black hole’, AI Communications 20 (3)(2007) 211–226.[25] I.P. Gent, I. Miguel, P. Nightingale, Generalised arc consistency for the alldifferent constraint: An empirical survey, Artificial Intelligence 172 (18) (2008)1973–2000.[26] C. Jefferson, A. Miguel, I. Miguel, A. Tarim, Modelling and solving English peg solitaire, Computers and Operations Research 33 (10) (2006) 2935–2959.