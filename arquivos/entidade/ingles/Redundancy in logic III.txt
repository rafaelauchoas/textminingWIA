Artificial Intelligence 172 (2008) 1317–1359www.elsevier.com/locate/artintRedundancy in logic III: Non-monotonic reasoningPaolo LiberatoreUniversità di Roma “La Sapienza”, Dipartimento di Informatica e Sistemistica, Via Ariosto 25, I-00185 Roma, ItalyReceived 14 October 2005; received in revised form 15 February 2008; accepted 18 February 2008Available online 4 March 2008AbstractResults about the redundancy of certain versions of circumscription and default logic are presented. In particular, propositionalcircumscription where all variables are minimized and skeptical default logics are considered. This restricted version of circum-scription is shown to have the unitary redundancy property: a CNF formula is redundant (it is equivalent to one of its proper subsets)if and only if it contains a redundant clause (it is equivalent to itself minus one clause); default logic does not have this property ingeneral. We also give the complexity of checking redundancy in the considered formalisms.© 2008 Elsevier B.V. All rights reserved.Keywords: Logical redundancy; Non-monotonic reasoning; Computational complexity; Circumscription; Default logic1. IntroductionIn this paper, we study the problem whether a circumscriptive [36] or default [44] theory is redundant, that is, itcontains unnecessary parts. Formally, a theory is redundant if it is equivalent to one of its proper subsets; a part isredundant in a theory if the theory is not semantically changed by the removal of the part. The problem of redundancyin other settings has been extensively analyzed in the literature. The complexity of establishing whether a CNF, 2CNF,and Horn formula is redundant has been studied by the author of the present article [26,30], who also analyzed someproblems related to irredundant equivalent subsets of formulae. These problems are all considered in the settings ofclassical propositional logic.The related problem of minimizing a propositional theory, in particular when in Horn form, has been analyzedby several authors [1,22,23,34,37,52]. Minimization is significantly different from redundancy: a formula is minimalif there is no shorter formula that is equivalent to it. Minimal formulae are also irredundant, but not the other wayaround: a formula may be irredundant because no part can be removed from it, but still a completely different formulais both shorter than it and equivalent to it. For example, {a ∨ b, a ∨ ¬b} is irredundant (because none of the twoclauses can be removed from it while maintaining equivalence with the original set) but is not minimal (because it isequivalent to the shorter set {a}). There are motivations for studying both minimization and redundancy. Minimizationproduces the shortest possible formula equivalent to a given one, and this has obvious advantages; making a formulairredundant may not produce a formula as short as the minimal ones, but has the additional advantage of not changingthe structure of the original formula, but only to remove parts from it.E-mail address: paolo@liberatore.org.0004-3702/$ – see front matter © 2008 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2008.02.0031318P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359A related problem is that of studying the properties of formulae that are already known to be irredundant. Büningand Zhao [7] studied the problems of equivalence and extension-equivalence of irredundant formulae. Also related isthe problem of minimal unsatisfiability, that is, checking whether an unsatisfiable formula would become satisfiableas soon as a clause is removed from it [5,14,43].Other authors have studied redundancy in settings different from that in this article. Ginsberg [18] and Schmolzeand Snyder [48] studied the redundancy of production rules. Gottlob and Fermüller [17] studied the redundancy of aliteral within a clause in first-order logic.The settings considered in this article are those of circumscription and default logic, which are two of the most stud-ied [2,4,6,10,13,29,31,36,38,44] forms of non-monotonic reasoning, as opposite to classical logic, which is monotonic.A logic is monotonic if the consequences of a set of formulae monotonically non-decrease with the set. In other words,all formulae that are entailed by a set are also entailed by every superset of it. Circumscription and default logic do nothave this property, and are therefore non-monotonic. For circumscription, we assume that all variables are minimized;the rationale for this restriction is that fixed and varying variables can be efficiently eliminated [8,9], which showsthat the minimized variables are the “core” of the circumscription formalism. Other authors have indeed consideredcircumscription only under this restriction [6,25,40]. This shows that this restriction of circumscription is of inter-est; however, results about redundancy in this case do not necessarily extend to the general case, as discussed in theconclusions.For default logic, there are several semantics; for most of them, one can choose between the “credulous” and“skeptical” approach. In this article, we consider the skeptical approach under the original semantics [44] and threesimilar ones: justified [33], constrained [11,46], and rational [39]. We however also consider the case in which weassume that the semantics of a theory is the set of its extensions, without combining these extensions in a skepticalmanner. The results obtained in this case hold for the credulous approach under the original semantics (where nototherwise stated, the skeptical approach is assumed). The properties of redundancy in the credulous approach underthe other semantics is left open. Since redundancy is defined in terms of equivalence (namely, equivalence of a formulato a proper subset of it), it is affected by the kind of equivalence used. In particular, equivalence can be defined in twoways for default logic: equality of extensions and equality of consequences. This leads to two different definitions ofredundancy in default logic.Both circumscription and default logic differ from classical propositional logic. This difference affects redundancy.If a CNF formula contains a redundant clause, it is redundant (equivalent to one of its proper subsets); the converse istrue in propositional logic, but not in all logics. In particular, it may be the case that a formula is equivalent to one ofits proper subsets, but none of its clauses is redundant. We will indeed show a situation in default logic where {a, b}is equivalent to ∅ but neither to {a} nor to {b}, which means that {a, b} is redundant but does not contain any singleredundant element.The property that a formula is redundant if and only if it contains a redundant clause is called unitary redundancy.Classical logic has this property; other logics, like default logic, do not. We show three different sufficient conditionsfor this property to hold in a logic; one of them involves monotonicity, another involves cumulativity [35]. A propertythat entails unitary redundancy is that of monotonic redundancy: if (cid:2)(cid:4) ⊆ (cid:2)(cid:4)(cid:4) ⊆ (cid:2) and (cid:2)(cid:4) and (cid:2) are equivalent then(cid:2)(cid:4)(cid:4) and (cid:2) are equivalent as well. This is the property for which the sufficient conditions are actually proved; unitaryredundancy follows.Regarding the specific non-monotonic formalisms considered here, we show that monotonic redundancy, and there-fore unitary redundancy, holds for circumscription and for the redundancy of the background theory in default logicwhen all defaults are categorical (prerequisite-free) and normal. In the general case, default logic does not have theunitary redundancy property (and therefore does not have the monotonic redundancy property either). We also consid-ered the redundancy of defaults in a default theory. In this case, monotonic and unitary redundancy hold for justifieddefault logic but not for the other three considered semantics.Regarding the complexity results, we show that checking whether a clause is redundant in a formula and whether aformula is redundant according to circumscriptive inference are (cid:2)p2 -complete problems. For default logic, the resultsare as follows. Checking redundancy, based on extensions, of a clause in the background theory is (cid:2)p2 -complete forReiter and justified default logics, and (cid:2)p3 -complete for constrained and rational default logic; checking redundancybased on skeptical consequences is (cid:2)p3 -complete for all four semantics. Checking redundancy of a background theoryis (cid:3)p4 -complete, respectively, for equivalence based on extensions and skeptical consequences. Theproofs of the latter two results are of some interest by themselves, as they are done by first showing that the problems3 -complete and (cid:3)pP. Liberatore / Artificial Intelligence 172 (2008) 1317–135913192 -complete and (cid:2)pare (cid:2)p3 -complete, respectively, and then showing that such complexity results can be raised onelevel in the polynomial hierarchy. This technique allows for a proof of hardness for a class such as (cid:3)p4 withoutinvolving complicated QBFs such as ∃W ∀X∃Y ∀Z.F . Regarding the credulous approach, we prove that equality ofextensions and equality of credulous consequences coincide for the Reiter default logic, but not for the other threeconsidered semantics. Regarding the redundancy of defaults, we only considered Reiter default logic with equivalencebased on equality of extensions; we proved that the redundancy of a default is (cid:2)p2 -complete and the redundancy of aset of defaults is (cid:3)p3 -complete in this case.For the sake of clarity, long proofs and very technical parts are in the appendix.2. PreliminariesIf (cid:2) and (cid:4) are sets, (cid:2)\(cid:4) denotes the set of elements that are in (cid:2) but not in (cid:4). This operator is often calledset subtraction because the elements of (cid:4) are “subtracted” from (cid:2). An alternative definition of this operator is:(cid:2)\(cid:4) = (cid:2) ∩ (cid:4), where (cid:4) is the complement of (cid:4).All formulae considered in this paper are propositional and finite Boolean formulae over a finite alphabet. Wetypically use formulae in CNF, that is, sets of clauses; we refer to sets of clauses simply as formulae. Var((cid:2)) is theset of variables mentioned in the formula (cid:2), Cn((cid:2)) is the set of its consequences (formulae entailed by it). If S a(possibly infinite) set of formulae (all built of variables from the same finite alphabet), ∨S denotes a formula whosemodels are exactly the models that satisfy all formulae of S.We use the notation l ∈ γ , where l is a literal and γ a clause, to indicate that l is a literal of the clause γ . Insome places, we use the notation ¬γ , where γ is a clause, to denote the formula {¬l | l ∈ γ }. Note that γ is a clause,while both {γ } and ¬γ are formulae (sets of clauses). A clause is positive if and only if it contains only positiveliterals.A propositional interpretation is an assignment from a set of propositional variables to the set {true, false}. Wedenote a model by the set of variables it assigns to true. We use the notation Mod((cid:2)) to denote the set of models of aformula (cid:2). We sometimes use models as formulae, e.g., (cid:2) ∧ ω where (cid:2) is a formula and ω is a model. In the contextwhere a formula is expected, a model ω represents the formula {x | x ∈ ω} ∪ {¬x | x /∈ ω}. If (cid:2) is a formula and ωXis an interpretation over the set of variables X, we denote by (cid:2)|ωX the formula obtained by replacing each variable ofX with its value as assigned by ωX in (cid:2). Since a model is a set of positive literals, M ⊆ M (cid:4) holds if and only if Massigns to false all variables that M (cid:4) assigns to false.All formulae considered in this article are assumed to be built over a finite alphabet of variables. Sometimes,formulae are built from other formulae with the addition of new variables. These additions implicitly assume theexistence of a countable set of new variables to take from; these new variables are symbols not appearing in theoriginal formulae.3. Arbitrary logicsIn this section, we show some results about redundancy in an arbitrary logic. To this aim, we consider a logic tobe characterized by an entailment relation |=L and an equivalence relation ≡L. In the basic case, these relations willbe over the set of all sets of clauses over a given alphabet, so that one can write (cid:2) ≡L (cid:2)(cid:4) if (cid:2) and (cid:2)(cid:4) are sets ofclauses. However, we also analyze the question of redundancy of defaults, which depends on whether two sets ofdefaults D and D(cid:4) are equivalent, that is, D ≡L D(cid:4). In order to obtain truly general results, in this section we do notmake assumptions over the basic elements in these sets, and only assume |=L and ≡L to be relations over the setsof elements from a given set; in this article, this set is either the set of all clauses or of all default rules over a givenalphabet, but the results in this section hold for an arbitrary set.We do not implicitly assume any property over these two relations or over their relationship; as it will be shown,some entailment and equivalence relations we consider do not have the properties one would generally expect fromthem; for example, a definition of equivalence that is instrumental to the study of default logic is not transitive.Formally, that would mean that this form of logical equivalence is not in fact an equivalence relation. While the term“equivalence” could be considered misleading, it is still the most expressive name for this relation.Some properties entailment and equivalence relations may have are defined as follows.1320P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Definition 1. The following properties are defined over relations |=L, ≡L, where (cid:2), (cid:2)(cid:4), and (cid:2)(cid:4)(cid:4) are sets:if (cid:2) ≡L (cid:2)(cid:4) then (cid:2)(cid:4) ≡L (cid:2);if (cid:2) ≡L (cid:2)(cid:4) and (cid:2)(cid:4) ≡L (cid:2)(cid:4)(cid:4) then (cid:2) ≡L (cid:2)(cid:4)(cid:4);Reflexivity: (cid:2) |=L (cid:2), (cid:2) ≡L (cid:2);Symmetry:Transitivity:Right weakening:Right conjunction:if (cid:2) |=L (cid:2)(cid:4) and (cid:2) ⊆ (cid:2)(cid:4)(cid:4) then (cid:2)(cid:4)(cid:4) |=L (cid:2)(cid:4)Monotonicity:if (cid:2) |=L (cid:2)(cid:4) then (cid:2) ≡L (cid:2) ∪ (cid:2)(cid:4);Cumulativity:if (cid:2) ≡L (cid:2)(cid:4) then (cid:2) |=L (cid:2)(cid:4);Half-entailment:Full-entailment: (cid:2) ≡L (cid:2)(cid:4) if and only if (cid:2) |=L (cid:2)(cid:4) and (cid:2)(cid:4) |=L (cid:2).if (cid:2) |=L (cid:2)(cid:4) and (cid:2)(cid:4)(cid:4) ⊆ (cid:2)(cid:4) then (cid:2) |=L (cid:2)(cid:4)(cid:4);if (cid:2) |=L (cid:2)(cid:4) and (cid:2) |=L (cid:2)(cid:4)(cid:4) then (cid:2) |=L (cid:2)(cid:4) ∪ (cid:2)(cid:4)(cid:4);Reflexivity, symmetry, and transitivity are defined as they usually are on binary relations. Some other of these con-ditions are defined differently from the standard way because we cannot use propositional connectives and entailment.This is due to the intentional lack of assumptions over the elements in the sets (cid:2), (cid:2)(cid:4), etc: since these are not necessar-ily sets of clauses or of propositional formulae, one cannot write (cid:2)(cid:4) |= (cid:2)(cid:4)(cid:4) where |= is propositional entailment. As aresult, one cannot write for example right weakening in the usual form: if (cid:2) |=L (cid:2)(cid:4) and (cid:2)(cid:4) |= (cid:2)(cid:4)(cid:4) then (cid:2) |=L (cid:2)(cid:4)(cid:4). Theabove definitions, being based on set operations only, can be used in scenarios where propositional connectives andentailment are not defined, such as the redundancy of defaults (if D and D(cid:4) are sets of defaults, D |= D(cid:4) is undefinedif |= is propositional entailment).The above definitions are equivalent to the classical ones for sets of clauses or propositional formulae with theadditional assumption that |=L and ≡L behave the same on propositionally equivalent formulae: if (cid:2) and (cid:2)(cid:4) arepropositionally equivalent then for every (cid:2)(cid:4)(cid:4) it holds (cid:2) |=L (cid:2)(cid:4)(cid:4) if and only if (cid:2)(cid:4) |=L (cid:2)(cid:4)(cid:4) holds, etc. In this case, thedefinitions above coincide with the classical ones by taking sets that are deductively closed.All entailment and equivalence relations considered in this article are reflexive and all equivalence relations arealso symmetric. However, a definition of equivalence used for the study of default logic will be shown not transitive,and some forms of entailment will be shown not to enjoy the right weakening property. Equivalence will often bedefined according to the full entailment property from an entailment relation; in such cases, full entailment holds bydefinition.An element is redundant in a set if its removal leads to an equivalent set.Definition 2 (Redundancy of an element). An element γ of a set (cid:2) is redundant in it according to ≡L if (cid:2) ≡L (cid:2)\{γ }.A set is redundant if it is equivalent to one of its proper subsets.Definition 3 (Redundancy of a set). A set (cid:2) is redundant according to ≡L if there exists (cid:2)(cid:4) ⊂ (cid:2) such that (cid:2) ≡L (cid:2)(cid:4).In propositional logic, these two forms of redundancy are related: a set of clauses is redundant if and only if itcontains a redundant clause. The same holds for circumscription but not for all logics. For example, it does not holdfor the redundancy of clauses in the background theory of default logic.Definition 4 (Unitary redundancy). Equivalence ≡L has the unitary redundancy property if the redundancy of a set isthe same as the presence of a redundant element in it.More formally, if ≡L has this property then (cid:2) ≡L (cid:2)(cid:4) and (cid:2)(cid:4) ⊂ (cid:2) imply that there exists γ ∈ (cid:2) such that (cid:2) ≡L(cid:2)\{γ }. One may also assume that such γ is in (cid:2)\(cid:2)(cid:4); modifying the definition in this way would not change theresults in this article.A property of ≡L that implies unitary redundancy is the following limited form of monotonicity.Definition 5 (Monotonic redundancy). Equivalence ≡L has the monotonic redundancy property if, for every three sets(cid:2), (cid:2)(cid:4), and (cid:2)(cid:4)(cid:4) such that (cid:2) ≡L (cid:2)(cid:4) and (cid:2)(cid:4) ⊆ (cid:2)(cid:4)(cid:4) ⊆ (cid:2), it holds that (cid:2)(cid:4)(cid:4) ≡L (cid:2).P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591321Monotonic redundancy implies that every set that is contained in another and contains yet another is equivalent tothe former if the former and the latter are equivalent to each other. In this definition, (cid:2)(cid:4)(cid:4) ≡L (cid:2) cannot in general bereplaced with (cid:2)(cid:4)(cid:4) ≡l (cid:2)(cid:4) unless ≡L is transitive.Monotonic redundancy implies unitary redundancy: if (cid:2) is equivalent to (cid:2)(cid:4) with (cid:2)(cid:4) ⊂ (cid:2), then for an arbitraryγ ∈ (cid:2)\(cid:2)(cid:4) it holds that (cid:2)\{γ } is equivalent to (cid:2). Whenever possible, monotonic redundancy will be proved. Sincecounterexamples of the unitary redundancy property are stronger than monotonic redundancy ones, unitary redun-dancy is used in this article when giving counterexamples.While monotonic redundancy entails unitary redundancy, the converse does not hold.Counterexample 1. There exists a logic where |=L is reflexive, ≡L is symmetric and transitive, they are related byfull-entailment, and unitary redundance holds, but monotonic redundancy does not.The following three theorems provide some sufficient conditions to monotonic redundancy, and therefore to unitaryredundancy as well.Theorem 1. If |=L is reflexive and enjoys right weakening, ≡L is transitive, and they are related by full-entailment,then ≡L has the monotonic redundancy property.Proof. Let us assume (cid:2) ≡L (cid:2)(cid:4) and (cid:2)(cid:4) ⊆ (cid:2)(cid:4)(cid:4) ⊆ (cid:2), and prove (cid:2) ≡L (cid:2)(cid:4)(cid:4). Since (cid:2) ≡L (cid:2)(cid:4), by full-entailment we have(cid:2)(cid:4) |=L (cid:2). Since (cid:2)(cid:4)(cid:4) ⊆ (cid:2), by right weakening it holds (cid:2)(cid:4) |=L (cid:2)(cid:4)(cid:4). Since |=L is reflexive, it also holds (cid:2)(cid:4)(cid:4) |=L (cid:2)(cid:4)(cid:4).By right weakening, (cid:2)(cid:4)(cid:4) |=L (cid:2)(cid:4). Since we previously proved that (cid:2)(cid:4) |=L (cid:2)(cid:4)(cid:4), by full-entailment it follows (cid:2)(cid:4) ≡L (cid:2)(cid:4)(cid:4).Since (cid:2) ≡L (cid:2)(cid:4), by symmetry (which is a consequence of full-entailment) and transitivity of ≡L it follows that(cid:2) ≡L (cid:2)(cid:4)(cid:4). (cid:2)Theorem 2. If |=L is reflexive and monotonic and is related to ≡L by full entailment, then ≡L has the monotonicredundancy property.Proof. Let us assume that (cid:2) ≡L (cid:2)(cid:4) and that (cid:2)(cid:4) ⊆ (cid:2)(cid:4)(cid:4) ⊆ (cid:2). By full entailment, the first condition implies (cid:2)(cid:4) |=L (cid:2).Since (cid:2)(cid:4) ⊆ (cid:2)(cid:4)(cid:4), by monotonicity we have (cid:2)(cid:4)(cid:4) |=L (cid:2). By reflexivity of |=L, we have (cid:2)(cid:4)(cid:4) |=L (cid:2)(cid:4)(cid:4); since (cid:2)(cid:4)(cid:4) ⊆ (cid:2), bymonotonicity we have that (cid:2) |=L (cid:2)(cid:4)(cid:4). Since we have already proved that (cid:2)(cid:4)(cid:4) |=L (cid:2) holds, we can use full entailmentand conclude that (cid:2)(cid:4)(cid:4) ≡L (cid:2). (cid:2)Theorem 3. If |=L enjoys right weakening, ≡L is symmetric and transitive, and they are related by cumulativity andhalf-entailment, then ≡L has the monotonic redundancy property.Proof. Assume that (cid:2) ≡L (cid:2)(cid:4) and (cid:2)(cid:4) ⊆ (cid:2)(cid:4)(cid:4) ⊆ (cid:2). By symmetry and half-entailment, (cid:2)(cid:4) |=L (cid:2). By right weakening,we have (cid:2)(cid:4) |=L (cid:2)(cid:4)(cid:4)\(cid:2)(cid:4). By cumulativity, (cid:2)(cid:4) ≡L ((cid:2)(cid:4)(cid:4)\(cid:2)(cid:4)) ∪ (cid:2)(cid:4)(cid:4), which is the same as (cid:2)(cid:4) ≡L (cid:2)(cid:4)(cid:4). By transitivity andsymmetry of ≡L, we have (cid:2) ≡L (cid:2)(cid:4)(cid:4). (cid:2)Another general result is that redundancy of an element is the same as the rest of the set entailing that elementprovided that the logic has some properties. The existence of this correspondence has been suggested by one of thereferees.Theorem 4. If |=L and ≡L have the half-entailment and cumulativity properties and |=L has the right weakeningproperty then an element γ is redundant in a set (cid:2) if and only if (cid:2)\{γ } |=L γ .Proof. Let us assume that (cid:2)\{γ } ≡L (cid:2) and γ ∈ (cid:2). By half-entailment, we have (cid:2)\{γ } |=L (cid:2). By right weakening,(cid:2)\{γ } |=L γ .To prove the opposite direction, assume (cid:2)\{γ } |=L γ . By cumulativity, it holds (cid:2)\{γ } ≡L (cid:2)\{γ } ∪ {γ }, which isthe same as (cid:2)\{γ } ≡L (cid:2). (cid:2)The same equivalence can also be proved using different conditions.1322P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Theorem 5. If |=L satisfies reflexivity, right weakening, right conjunction, and is related to ≡L by full entailment,then an element γ is redundant in a set (cid:2) if and only if (cid:2)\{γ } |=L γ .Proof. If (cid:2)\{γ } ≡L (cid:2), then (cid:2)\{γ } |=L (cid:2) by full entailment, and therefore (cid:2)\{γ } |=L γ by right weakening.If (cid:2)\{γ } |=L γ , we can apply right conjunction together with (cid:2)\{γ } |=L (cid:2)\{γ }, which holds by reflexivity, toobtain (cid:2)\{γ } |=L (cid:2). Since (cid:2) |=L (cid:2)\{γ } holds by reflexivity and right weakening, by full entailment we have(cid:2)\{γ } ≡L (cid:2). (cid:2)While (cid:2)\{γ } |=L γ could be used as an alternative definition of redundancy of γ , its equivalence to (cid:2)\{γ } ≡L (cid:2)does not hold for every logic, as shown by the following counterexample.Counterexample 2. There exists two relations |=L and ≡L such that |=L is reflexive, ≡L is reflexive and symmetric,|=L and ≡L are related by full entailment, but there exists (cid:2) and γ ∈ (cid:2) such that (cid:2)\{γ } |=L γ but (cid:2) (cid:14)≡L (cid:2)\{γ }.A natural question is which definition of redundancy would be the most natural for logics where they differ. If“redundancy” is taken as its literal meaning of “something is unnecessary”, then a clause would be redundant if it canbe taken out of a set without this removal changing the meaning of the set. Formally, (cid:2)\{γ } ≡L (cid:2).4. CircumscriptionCircumscriptive inference is based on the minimal models of a theory, i.e., the models whose set of variablesassigned to true is minimal w.r.t. set inclusion. Formally, we define the set of minimal models as follows.Definition 6. The set of minimal models of a propositional formula (cid:2), denoted by CIRC((cid:2)), is defined as follows.CIRC((cid:2)) = min⊆(cid:3)(cid:2)Mod((cid:2))We define CIRC((cid:2)) to be a set of models instead of a formula, although the latter is more common in the literature.Circumscriptive entailment is defined like classical entailment but only minimal models are taken into account.Definition 7. The circumscriptive inference |=M is defined by: for any two formulae (cid:2) and (cid:4), it holds (cid:2) |=M (cid:4) if (cid:4)is satisfied by all minimal models of (cid:2):(cid:2) |=M (cid:4) if CIRC((cid:2)) ⊆ Mod((cid:4))We assume that the alphabet is finite. This definition is actually the restriction of the original circumscription [36]without “fixed” and “varying” variables. We use this version because it captures the core of circumscription, that ofusing minimal models, as shown by the translations that efficiently remove fixed [9] and varying [8] variables. Theimportance of this subcase is also shown by the attemption it has been given in the literature [6,25,40]. We howeverremark that, while an interesting subcase, the results about redundancy given in this article do not necessarily extendto the general case, as the elimination of fixed and varying predicates modify the formula.Equivalence in propositional logic can be defined in two equivalent ways: either by equality of the models or byequality of the sets of entailed formulae. These two definitions of equivalence coincide for circumscriptive inferenceas well. We define ≡M as follows: (cid:2) ≡M (cid:4) if and only if CIRC((cid:2)) = CIRC((cid:4)). The next theorem gives someproperties of circumscriptive inference and equivalence.Theorem 6. Relation |=M has the properties of reflexivity and right weakening; relation ≡M is reflexive, symmetric,and transitive; these two relations are related by cumulativity and full-entailment.Proof. Reflexivity, symmetry, transitivity, and right weakening are obvious from definition. Cumulativity of circum-scription is well-known [35,47] when equivalence is defined as equality of consequences, which is the same as ≡Mby definition of |=M and ≡M .P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591323We now prove that |=M and ≡M are related by full-entailment. If (cid:2) ≡M (cid:2)(cid:4), then the minimal models of (cid:2) and (cid:2)(cid:4)are the same. Therefore, the minimal models of (cid:2) are also all models of (cid:2)(cid:4), which means that (cid:2) |=M (cid:2)(cid:4).For the other direction, let us assume that (cid:2) |=M (cid:2)(cid:4) and (cid:2)(cid:4) |=M (cid:2), and prove (cid:2) ≡M (cid:2)(cid:4). To the contrary, assumethat (cid:2) has a minimal model M which is not a minimal model of (cid:2)(cid:4). Since M is a minimal model of (cid:2) and (cid:2) |=M (cid:2)(cid:4),it follows that M is a model of (cid:2)(cid:4). Since it is a model but not a minimal model, there exists M (cid:4) ⊂ M that is a minimalmodel of (cid:2)(cid:4). However, since (cid:2)(cid:4) |=M (cid:2), this model M (cid:4) is also a model of (cid:2). This contradicts the assumption that Mis a minimal model of (cid:2). In a similar way, assuming that (cid:2)(cid:4) has a minimal model which is not a minimal model of (cid:2)leads to a contradiction. (cid:2)Redundancy of a clause is defined as follows.Definition 8. A clause γ ∈ (cid:2) is CIRC-redundant in formula (cid:2) if and only if (cid:2)\{γ } ≡M (cid:2).By Theorem 4 and Theorem 6, redundancy of a clause γ in a set (cid:2) could also be defined as (cid:2)\{γ } |=M γ .A formula is redundant if some of its clauses can be removed without changing its semantics.Definition 9. A formula is CIRC-redundant if it is ≡M -equivalent to one of its proper subsets.A formula is therefore redundant if some clauses can be removed from it while preserving equivalence. Monotonicredundancy can be easily proved to hold given the properties of |=M and ≡M .Theorem 7. Circumscription has the monotonic redundancy property.Proof. Theorem 6 proves that |=M and ≡M have all properties that are necessary to apply Theorem 1. (cid:2)As a result, circumscription also has the unitary redundancy property.Corollary 1. Circumscription has the unitary redundancy property.4.1. Redundant clausesThe following lemma characterizes the clauses that are redundant in a formula.Lemma 1. The following three conditions are equivalent for every formula (cid:2) and clause γ ∈ (cid:2).1. γ is CIRC-redundant in (cid:2);2. for each M ∈ Mod((cid:2)\{γ } ∪ ¬γ ) there exists M (cid:4) ∈ Mod((cid:2)) such that M (cid:4) ⊂ M;3. for each M ∈ Mod((cid:2)\{γ } ∪ ¬γ ) there exists M (cid:4) ∈ Mod((cid:2)\{γ }) such that M (cid:4) ⊂ M.Proof. The models of (cid:2)\{γ } that are not models of (cid:2) are exactly the models of (cid:2)\{γ } ∪ ¬γ . The two formulae (cid:2)and (cid:2)\{γ } are |=M -equivalent if none of these models (if any) is minimal, that is, all these models contain othermodels of (cid:2). In other words, γ is redundant if and only if every model of (cid:2)\{γ } ∪ ¬γ properly contains a modelof (cid:2).The fact that we can check M (cid:4) ∈ Mod((cid:2)\{γ }) instead of M (cid:4) ∈ Mod((cid:2)) follows from the fact that Mod((cid:2)\{γ })is composed of all models of (cid:2) and all models of (cid:2)\{γ } ∪ ¬γ . Consider a model M that is a minimal model of(cid:2)\{γ } ∪ ¬γ . The condition M (cid:4) ⊂ M implies that M (cid:4) is not a model of (cid:2)\{γ } ∪ ¬γ , and is therefore a model of (cid:2). Bytransitivity, the condition that there exists M (cid:4) ∈ Mod((cid:2)) such that M (cid:4) ⊂ M holds for all models of (cid:2)\{γ } ∪ ¬γ . (cid:2)Computationally, checking the second or third condition of this lemma can be done by checking whether for all2 . For positiveM ∈ . . . there exists M (cid:4) ∈ . . . such that a simple condition is met. As a result, the problem is in (cid:2)pclauses, checking CIRC-redundancy is easier, as it amounts to checking classical redundancy.1324P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Lemma 2. A positive clause is CIRC-redundant in a formula if and only if it is classically redundant in the formula.Proof. Theorem 4 and Theorem 6 prove that γ is CIRC-redundant in (cid:2) if and only if (cid:2)\{γ } |=M γ . Bossu and Siegel[6, Property 1.6.6] proved that a positive clause is sub-implied by a formula if and only if it is (classically) impliedby it. This implies the statement of the lemma because sub-implication coincides with our version of circumscriptionin the propositional case; this is also essentially proved by Bossu and Siegel [6, Property 1.6.3], considering that allmodels are discriminant in the propositional case. (cid:2)Intuitively, a positive clause only excludes models that assign false to all variables in the clause. Therefore, when-ever a positive clause is classically irredundant, it is because such models were not otherwise excluded; therefore, itis also CIRC-irredundant.According to this argument, it may look like all negative clauses are CIRC-redundant, since they exclude modelswith positive literals and these models are not minimal. This is however not the case: a model with some positiveliterals might be minimal because no other model of the formula has a smaller (w.r.t. set inclusion) set of variablesassigned to true. Consider, for example, the following formula:(cid:2) = {¬x1 ∨ ¬x2, x1 ∨ x3, x2 ∨ x3}The clause ¬x1 ∨ ¬x2, although negative, is CIRC-irredundant. Indeed, (cid:2)\{¬x1 ∨ ¬x2} = {x1 ∨ x3, x2 ∨ x3}, andthis formula has {x1, x2} and {x3} as its minimal models. The first one is not a model of (cid:2) because of the clause¬x1 ∨ ¬x2. Therefore, ¬x1 ∨ ¬x2 is CIRC-irredundant in (cid:2).Intuitively, a negative clause excludes the possibility of setting all variables to true, while minimal inference onlytries to set variables to false. Therefore, removing the clause may generate a model that have its variables set to true({x1, x2} in the example), but is minimal because of the values of the other variables (x3 in the example).Lemma 2 can be extended to clauses containing negative literals via the addition of new clauses and new variables.Lemma 3. A clause γ is classically redundant in a formula (cid:2) if and only if it is CIRC-redundant in (cid:2) ∪ {x ∨ x(cid:4) |¬x ∈ γ }, where each variable x(cid:4) is a new variable associated to each variable x such that ¬x ∈ γ .Proof. In propositional logic, γ is redundant in (cid:2) if and only if (cid:2)\{γ } entails γ . If γ is redundant in (cid:2) then(cid:2)\{γ } |= γ and therefore (cid:2) ∪ {x ∨ x(cid:4) | ¬x ∈ γ }\{γ } |= γ . Since γ is redundant in (cid:2) ∪ {x ∨ x(cid:4) | ¬x ∈ γ }, it is alsoCIRC-redundant.Let us now assume that γ is irredundant in (cid:2), that is, (cid:2)\{γ } ∪ ¬γ has some models. Let M be one such model.Since this model satisfies ¬γ , it assigns false to any variable x such that x ∈ γ and true to any variable x such that¬x ∈ γ . Extending M to assign false to all variables x(cid:4), this model also satisfies (cid:2) ∪ {x ∨ x(cid:4) | ¬x ∈ γ }\{γ } ∪ ¬γ .We show that M does not contain a model of (cid:2)∪{x ∨x(cid:4) | ¬x ∈ γ }; by Lemma 1, this implies that γ is not redundantin (cid:2) ∪ {x ∨ x(cid:4) | ¬x ∈ γ }. This extended model M assigns false to all x ∈ γ and also false to all x(cid:4) such that ¬x ∈ γ .On the other hand, {γ } ∪ {x ∨ x(cid:4) | ¬x ∈ γ } entails the clause{x(cid:4) | ¬x ∈ γ }; this can be proved forexample by iteratively resolving upon all literals x such that ¬x ∈ γ . As a result, no model of (cid:2) ∪ {x ∨ x(cid:4) | ¬x ∈ γ }has a model that assign false to all x ∈ γ and all x(cid:4) such that ¬x ∈ γ . Since this is instead done by M, it follows thatno model of (cid:2) ∪ {x ∨ x(cid:4) | ¬x ∈ γ } is contained in M. (cid:2){x | x ∈ γ } ∨(cid:4)(cid:4)Note that the clauses x ∨ x(cid:4) are not necessarily CIRC-irredundant in the considered formula. On the other hand,Lemma 2 can be applied to them: they are CIRC-redundant if and only if they are classically redundant.4.2. Complexity of CIRC-redundancyWe first show the complexity of checking the redundancy of a single clause.Theorem 8. Checking the CIRC-redundancy of a clause in a formula is (cid:2)pis assumed to be satisfiable.2 -complete, and remains hard if the formulaIn order to characterize the complexity of the problem of checking the CIRC-redundancy of a formula, we use thefact that a formula is CIRC-redundant if and only if it contains a CIRC-redundant clause by Corollary 1. In particular,P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591325Theorem 8 shows that the problem of checking the CIRC-redundancy of a clause γ in (cid:2) is (cid:2)p2 -hard. In order forthis result to be used as a proof of hardness for the problem of CIRC-redundancy of formulae, we need to modify theformula (cid:2) in such a way all its clauses but γ are made CIRC-irredundant. This is the corresponding of Lemma 4 of thearticle about redundancy of propositional CNF formulae [26], which has been useful because it allows to “localize”problems about redundancy. In particular, for every consistent formula and arbitrary subset of it, we can change theformula in such a way the clauses not in the subset are made irredundant.Definition 10. For every formula (cid:2) = {γ1, . . . , γm} over variables X = {x1, . . . , xn} and every (cid:2)(cid:4) ⊆ (cid:2), the formulaI ((cid:2), (cid:2)(cid:4)) is defined as follows, where a, b, s, and t are new variables and C = {ci | 1 (cid:2) i (cid:2) m}, D = {di | 1 (cid:2) i (cid:2) m},and X(cid:4) = {x(cid:4)i| 1 (cid:2) i (cid:2) n} are sets of new variables.(cid:4)I ((cid:2), (cid:2)) = {s ∨ t} ∪ {s ∨ a, t ∨ b} ∪{¬s ∨ t ∨ ci ∨ di | 1 (cid:2) i (cid:2) m} ∪ {¬s ∨ ¬ci | 1 (cid:2) i (cid:2) m} ∪{¬t ∨ ci ∨ γi | 1 (cid:2) i (cid:2) m, γi ∈ (cid:2)\(cid:2)(cid:4){s ∨ ¬t ∨ xi ∨ xi(cid:4)}{¬s ∨ ¬t ∨ γi | 1 (cid:2) i (cid:2) m, γi ∈ (cid:2)| 1 (cid:2) i (cid:2) n} ∪(cid:4)} ∪The following lemma shows that the clauses of I ((cid:2), (cid:2)(cid:4)) that do not originate from clauses of (cid:2)(cid:4) are irredundant,and that the clauses that originate from clauses of (cid:2)(cid:4) maintain their redundancy status.Lemma 4. For every consistent formula (cid:2) = {γ1, . . . , γm} and every (cid:2)(cid:4) ⊆ (cid:2), the only CIRC-redundant clauses ofI ((cid:2), (cid:2)(cid:4)) are the clauses ¬s ∨ ¬t ∨ γi such that γi ∈ (cid:2)(cid:4) is CIRC-redundant in (cid:2).This lemma shows a way to make the clauses of (cid:2)\(cid:2)(cid:4) necessary, that is, contained in every equivalent subsetof (cid:2). This theorem allows to characterize the complexity of formula CIRC-redundancy.Theorem 9. The problem of verifying CIRC-redundancy is (cid:2)p2 -complete.Proof. By Corollary 1, (cid:2) is redundant if and only if it contains a redundant clause. Therefore, we have to solve alinear number of problems in (cid:2)p2 . Since these problems can be solved in parallel, the whole problem is in (cid:2)p2 .Hardness is proved by reduction from the problem of CIRC-redundancy of a single clause. By Lemma 4, a clauseγ is CIRC-redundant in a consistent formula (cid:2) if and only if ¬s ∨ ¬t ∨ γ is CIRC-redundant in I ((cid:2), {γ }) and allother clauses of I ((cid:2), {γ }) are irredundant. Since the problem of checking redundancy of a clause in a formula is(cid:2)p2 -hard as well. (cid:2)2 -hard even if the formula is satisfiable by Theorem 8, the problem of formula redundancy is (cid:2)p5. Default logicA default theory is a pair (cid:15)D, W (cid:16), where W is formula and D is a set of default rules, each rule being in the form:α : βγThe formulae α, β, and γ are called the precondition, the justification, and the consequence of the default, respectively.In this paper, we assume that W is a finite CNF formula (a finite set of clauses) and that the set of variables and defaultsare finite. A variant we do not consider is that in which a set of formulae β1, . . . , βm is in place of the single formula β.Given a default d = α:βγ , its parts are denoted by prec(d) = α, just(d) = β, and cons(d) = γ .A default d is normal if just(d) = cons(d); it is categorical if prec(d) = true. Defaults that are normal and possiblycategorical have been often considered because of their semantical properties and their ability to encode naturaldomains [4,41]. In particular, circumscription with all variables minimized can be easily simulated by defaults in theformWe use the operational semantics of default logics [2,3,15,16], which is based on sequences of defaults with noduplicates. If (cid:2) is such a sequence, we denote by (cid:2)[d] the sequence of defaults preceding d in (cid:2), and by (cid:2) · [d] the:¬x¬x .1326P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359sequence obtained by adding d at the end of (cid:2). We extend the notation from defaults to sequences, so that prec((cid:2)) isthe conjunction of all preconditions of the defaults in (cid:2), just((cid:2)) is the conjunction of all justifications, and cons((cid:2))is the conjunction of all consequences.Propositional entailment is denoted by |=, (cid:17) indicates (combined) consistency, and ⊥ indicates inconsistency. Forexample, A(cid:17)B means that A ∧ B is consistent, while A⊥B means that A ∧ B is inconsistent.Default logic can be defined in terms of the selected processes, that are the sequences of defaults that are consideredapplicable by the considered semantics [2]. These are defined as a combinations of conditions.Definition 11 (Process). A sequence of defaults (cid:2) containing no duplicate is a process if W ∪ cons((cid:2)[d]) |= prec(d)holds for every d ∈ (cid:2).Definition 12 (Local and global applicability). A default d is locally applicable to a sequence of defaults (cid:2) ifcons((cid:2)) ∪ W |= prec(d) and cons((cid:2)) ∪ W (cid:17)just(d). Global applicability also requires cons((cid:2)) ∪ W (cid:17)just((cid:2) · [d]).The default logic semantics considered in this article can be defined from the concept of process. In particular, eachsemantics defines some processes to be maximal sequences of defaults that can be applied. These processes are called“selected”, and are defined as follows.Definition 13 (Selected process). Processes are selected if:Reiter [44]: a process (cid:2) is selected if cons((cid:2)) ∪ W (cid:17)just(d) for each d ∈ (cid:2) and no default d (cid:4) /∈ (cid:2) is locally applica-ble to (cid:2);Justified [33]: a process (cid:2) is selected if it is a maximal process such that cons((cid:2)) ∪ W (cid:17)just(d) for each d ∈ (cid:2);Constrained [11,46]: a process (cid:2) is selected if it is a maximal process such that cons((cid:2)) ∪ W (cid:17)just((cid:2));Rational [39]: a process (cid:2) is selected if cons((cid:2)) ∪ W (cid:17)just((cid:2)) and no default d (cid:4) /∈ (cid:2) is globally applicable to (cid:2).The conditions for a process to be selected can all be broken in two parts: success (a consistency condition)and closure (non-extendibility of the process). For example, for constrained default logic the condition of success iscons((cid:2)) ∪ W (cid:17)just((cid:2)) and the condition of closure is that (cid:2) · [d] is not a successful process for any d /∈ (cid:2).For a full rationale of these definitions we refer to the original articles where they have been introduced [11,33,39,44,46], compared [10,29], or surveyed [2,42]. Essentially, Reiter and justified default logics require the justificationof each default to be consistent with the background theory and the consequences of the defaults in the process. Con-strained and rational default logics instead require the union of all justifications to be consistent with the backgroundtheory and the consequences of the defaults in the process. This difference gives one “axis” on which these semanticsdiffer. The other axis is whether a partially built process is allowed to “fail” [29], which is the condition where theaddition of a default to a process contradicts the justification of a previously applied default. Reiter and rational defaultlogic allow a process to fail, so that no extension would be generated by the process. Justified and constrained defaultlogic disallow failing: a default cannot be added to a process if that would result in a failure.a , d2 = a:c. In allconsidered semantics, d2 and d3 can only be applied after a has been derived, that is, after d1 has been applied. Sincethe conclusion of each default negates the justification of the other, d2 cannot follow d3 in a selected process and viceversa. Of the remaining processes [d1], [d1, d2] and [d1, d3], the four semantics behave as follows: for Reiter, the firstis unclosed, the second fails, and the third is selected; for justified, the first is unclosed, the second is unsuccessful,and the third is selected; for constrained, the first process is selected, the other two are not successful; for rational, thefirst is unclosed, the second fails, and the third is unsuccessful.As an example, consider the default theory (cid:15){d1, d2, d3}, ∅(cid:16) where d1 = :a∧b¬b∧c , and d3 = a:¬b∧¬c¬cRemarkably, all definitions of selected processes only mention the background theory W in conjunction withcons((cid:2)), that is, W only occurs in subformulae of the form W ∪ cons((cid:2)). The only conditions for which this is nottrue is that of (cid:2) being a process. The selected processes of a default theory determine the extensions of the theory,from which entailment is in turn defined.P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591327Definition 14 (Extension). An extension of a default theory (cid:15)D, W (cid:16) is a set Cn(W ∪ cons((cid:2))) where (cid:2) is a selectedprocess of the theory. We denote by ExtD(W ) the set of all (finite) formulae that are equivalent to an extension of(cid:15)D, W (cid:16).We remind the assumption that the considered alphabet is finite. Including formulae that are equivalent to theextensions in this set allows to write E ∈ ExtD(W ) to denote the equivalence of E with an extension of (cid:15)D, W (cid:16). Inthe skeptical semantics (also called cautious) a default theory entails a formula if all its extensions do.Definition 15 (Skeptical entailment). A default theory (cid:15)D, W (cid:16) entails a formula W (cid:4) if E |= W (cid:4) for every E ∈ExtD(W ).This condition is equivalent to ∨ExtD(W ) |= W (cid:4) (see the Preliminaries section for the definition of the notation∨S when S is an infinite set of formulae); as a result, the set of all consequences of a default theory is equivalent to∨ExtD(W ). Entailment of W (cid:4) from a theory (cid:15)D, W (cid:16) is denoted by W |=D W (cid:4). This notation emphasizes that eachset of defaults D defines a non-monotonic inference relation |=D [35]. Equivalence of two default theories is definedas either pairwise propositional equivalence of extensions, or equality of consequences. In the following section weprovide formal definitions of entailment and equivalence in default logic.Some semantics of default logic do not assign any extension to some theories. In this paper, we try to deriveexistence results (counterexamples and proofs of hardness) using theories having extensions.5.1. Equivalence in default logicsThe definition of redundancy is based on that of equivalence, and in particular on the equivalence of a formula withone of its proper subsets. As explained in the previous section, two forms of equivalence are natural in default logic:one based on extensions, the other on consequences. Remarkably, none of these two definitions of equivalence isrelated to |=D by full entailment. We therefore define a new form of equivalence, derived from |=D by full entailment,and two new forms of entailment, derived from the two aforementioned definitions of equivalence by full entailment.This leads to three definitions of entailment and three of equivalence. Of these, one definition of entailment andtwo of equivalence are of actual interest, the other definitions being technical tools. The first form of equivalence isderived from skeptical entailment.Definition 16 (Entailment and mutual equivalence). For a given set of defaults D, formula W entails formula W (cid:4),denoted by W |=D W (cid:4), if ∨ExtD(W ) |= W (cid:4). These two formulae are mutually equivalent, denoted by W ≡mD W (cid:4), ifW |=D W (cid:4) and W (cid:4) |=D W .In classical logic, this definition of equivalence is the same as W and W (cid:4) having the same set of consequences andthe same set of models. In default logic, this is not the case. We define the equivalence based on the set of consequencesas follows; an associated definition of entailment is defined for convenience.Definition 17 (Consequence-entailment and consequence-equivalence). For a given set of defaults D, formulaW consequence-entails formula W (cid:4), denoted W |=cD W (cid:4), if ∨ExtD(W ) |= ∨ExtD(W (cid:4)). These two formulae areconsequence-equivalent, denoted W ≡cD W (cid:4), if ∨ExtD(W ) ≡ ∨ExtD(W (cid:4)).A more stringent condition of equivalence of two defaults theories is that of having the same extensions. Again,an associated entailment relation is defined for technical convenience. The rationale of this definition is that theextensions of a default theory are the possible alternative scenarios that are expressed by the default theory, so in wayit is the most faithful representation of what a theory expresses. Other authors have considered default theories to beequivalent when they have the same extensions [10,21,24].Definition 18 (Faithful entailment and faithful equivalence). For a given set of defaults D, formula W faithfullyentails formula W (cid:4), denoted W |=eD W (cid:4), if ExtD(W ) ⊆ ExtD(W (cid:4)). These two formulae are faithfully equivalent,denoted W ≡eD W (cid:4), if ExtD(W ) = ExtD(W (cid:4)).1328P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359In a later section this form of equivalence will be shown the same as consequence-equivalence when the credulousconsequences are considered and Reiter semantics is used.It is easy to see that W |=eD W (cid:4) implies W |=camples regarding these forms of entailment will be show in the next section.D W (cid:4), which in turn implies W |=D W (cid:4). Other results and counterex-Each of the above three equivalence relations is related to the corresponding entailment relation by full entailment:two formulae are equivalent if and only if each formula entails the other. Since redundancy is defined in terms of equiv-alence, we are especially interested in the natural equivalence relations ≡cD, that is, equality of consequencesand equality of extensions. Mutual equivalence has been defined for technical reasons.D and ≡eRedundancy in default logic is defined as follows.Definition 19 (Redundancy of a clause). For a given set of defaults D, a clause γ is redundant in a formula Waccording to equivalence ≡xD if W ≡xD W \{γ }.Definition 20 (Redundancy of a formula). For a given set of defaults D, a formula W is redundant according toD W (cid:4).equivalence ≡xD if there exists W (cid:4) ⊂ W such that W ≡xIn both cases, we are comparing for equivalence a formula and one of its subsets. In Appendix C we study theequivalence of W (cid:4) and W when W (cid:4) ⊆ W . Equivalence depends on the semantics (Reiter, justified, constrained, andrational); we try to derive results that hold for all these four semantics. The results can be summarized as follows:Counterexample 9. There exists a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊂ W , W (cid:4) ≡mW (cid:4) (cid:14)≡cD W in Reiter, justified, constrained and rational default logic.D W , andCounterexample 10. There exists a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊂ W , W (cid:4) ≡cW (cid:4) (cid:14)≡eD W in Reiter and justified default logic.D W , andCounterexample 11. There exists a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊂ W , W (cid:4) ≡cW (cid:4) (cid:14)≡eD W in constrained and rational default logic.D W , andTrivial W (cid:4) |=eD W ⇒ W (cid:4) |=cD W .Lemma 7. For any set of defaults D and two formulae W and W (cid:4), if W (cid:4) |=cconstrained and rational default logic.D W then W (cid:4) |=D W , in Reiter, justified,Lemma 8. For any set of defaults D and two formulae W and W (cid:4), if W (cid:4) ⊆ W and W (cid:4) |=D W then W (cid:4) |=eReiter, justified, constrained and rational default logic.D W forCorollary 4. For any set of defaults D and two formulae W and W (cid:4), if W (cid:4) ⊆ W , then in Reiter, justified, constrained,and rational default logic the following holds:W(cid:4) |=D W ⇔ W(cid:4) |=cD W ⇔ W(cid:4) |=eD WTheorem 16. For any set of normal defaults D and two formulae W and W (cid:4), if W (cid:4) ⊆ W then W (cid:4) ≡cW (cid:4) ≡eD W in constrained default logic.D W impliesTheorem 17. If D is a set of normal defaults and W and W (cid:4) are two formulae such that W (cid:4) ⊆ W , then W (cid:4) ≡cholds if and only if W (cid:4) ≡eD W holds for Reiter, justified, constrained, and rational default logic.D WLemma 9. If D is a set of categorical defaults and W and W (cid:4) are two formulae such that W (cid:4) ⊆ W and W (cid:4) |=D W ,then W |=eD W (cid:4) in constrained default logic.P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591329Corollary 5. If D is a set of normal and categorical defaults and W and W (cid:4) are two formulae such that W (cid:4) ⊆ W , theconditions W (cid:4) ≡mD W are equivalent in Reiter, justified, constrained, and rational defaultlogic.D W , and W (cid:4) ≡eD W , W (cid:4) ≡c5.2. Redundancy of clauses vs. theoriesIn this section, we show that default logic does not have the unitary redundancy property in general, but it has it ifall defaults are categorical and normal.Counterexample 3. There exists a set of normal defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊂ W , W isequivalent to W (cid:4), and W \{γ } is not equivalent to W for any γ ∈ W , for mutual, faithful, and consequence equivalencein Reiter, justified, constrained, and rational default logic.Proof. The defaults D and background theory W are as follows.W = {a, b}(cid:4) = ∅WD = {d1, d2, d3}whered1 = a : ¬b¬bd2 = b : ¬a¬a: a ∧ ba ∧ bd3 =We show that (cid:15)D, W (cid:16) and (cid:15)D, ∅(cid:16) have the same extensions, thus proving equivalence of W and W (cid:4) according to allthree definitions. We also show that neither ∨ExtD({a}) nor ∨ExtD({b}) entail W , thus proving their non-equivalenceto W for all three definitions.The theory (cid:15)D, W (cid:16) has the single extension Cn({a, b}). Indeed, d1 and d2 are not applicable because their justifi-cations are inconsistent with W . The third default is applicable, but its consequence is a ∧ b, which is already in thetheory.The theory (cid:15)D, ∅(cid:16) has the same single extension: d3 is the only applicable default, leading to the addition of a ∧ b,which makes both d1 and d2 inapplicable. Therefore, Cn({a, b}) is the only extension of this theory. Since (cid:15)D, W (cid:16)and (cid:15)D, ∅(cid:16) have the same extensions, they are equivalent according to all three definitions of equivalence.The theory (cid:15)D, {a}(cid:16) still has the extension {a, b}, which results from the application of d3, which then blocks theapplication of d1 and d2. However, it also has a new extension: since d1 is applicable, it generates ¬b, which blocks theapplication of d3. This produces the extension Cn({a, ¬b}). Therefore, ∨ExtD({a}) is equivalent to a, and thereforedoes not entail W . As a result, {a} is not equivalent to W for any of the three definitions of equivalence.In the same way, (cid:15)D, {b}(cid:16) has the two extensions Cn({a, b}) and Cn({¬a, b}), and ∨ExtD({b}) is equivalent to b,which does not entail W . (cid:2)Since unitary redundancy does not hold, monotonic redundancy does not hold either. This means that the precon-ditions of Theorems 1, 2 and 3, are not satisfied. The precondition of the second and third theorem are not satisfiedbecause the considered semantics of default logic are neither monotonic nor cumulative. The following theorems showwhich preconditions of the other theorem are not satisfied.Counterexample 4. Mutual equivalence is not transitive for Reiter, justified, constrained, and rational default logic,even for normal defaults.1330P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Proof. We show a set of defaults D such that {a} ≡mDfollows.(cid:5)D =(cid:6)a : ¬b¬b,: a ∧ ba ∧ b∅, ∅ ≡mD{a, b} but {a} (cid:14)≡mD{a, b}. This set of defaults is asThe extensions are as follows: ∅ and {a, b} have the single extension Cn({a, b}), since the second default is the onlyapplicable one, and its consequence prevents the application of the first one; {a} has two extensions Cn({a, ¬b}) andCn({a, b}), since both defaults are applicable but the consequence of each one prevent the application of the other.Since Cn({a, b}) entails {a} and {a, b}, while ∅ is entailed by all considered extensions, we have that {a} ≡mD{a, b}. (cid:2){a, b}. On the other hand, ∨ExtD({a}) ≡ {a}, which does not entail {a, b}. As a result, {a} (cid:14)≡mD∅ ≡mD∅ andRemarkably, consequence-equivalence and faithful equivalence are instead transitive by definition. The propertythat does not hold is right weakening of their corresponding entailment relations.Counterexample 5. Consequence-entailment and faithful entailment do not have the right weakening property inReiter, justified, constrained, and rational default logic, and even for normal defaults.Proof. This is shown by D = { :¬aD W and W |=cD W .¬aOn the other hand, the only extension of W (cid:4) is Cn({¬a}). Since the set of the extensions of W is not contained in theset of extensions of W (cid:4), the first formula does not faithfully entail the second, that is, W (cid:14)|=eD W (cid:4). For the same reason,consequence-entailment does not hold either. (cid:2)} and the two formulae W = {a} and W (cid:4) = ∅. Clearly, W |=eInterestingly, this counterexample involves a theory that is both categorical and normal. Theorem 1 cannot be usedbecause consequence-entailment and faithful entailment do not meet its precondition. However, monotonic redun-dancy can still be proved for categorical and normal defaults.Theorem 10. Mutual equivalence, faithful equivalence, and consequence equivalence have the monotonic redundancyproperty if all defaults are categorical and normal in Reiter, justified, constrained, and rational default logic.Proof. If all defaults are categorical and normal, the three forms of equivalence coincide. Since faithful equivalenceis transitive, mutual equivalence is transitive as well in this case. Since |=D is reflexive, has right weakening, and isrelated to mutual equivalence by full-entailment, Theorem 1 applies: mutual equivalence has the monotonic redun-dancy property in this case. As a result, all three forms of equivalence have this property if all defaults are categoricaland normal. (cid:2)Incidentally, Corollary 5 only states that the three forms of equivalence coincide for categorical and normal de-faults, not that the same applies to the corresponding forms of entailment. This explains why faithful entailment andconsequence-entailment do not have the right weakening property, which entailment has, even in the case of normaland categorical defaults.5.3. Making clauses irredundantModifying a formula in order to make some of its parts irredundant proved useful for classical and circumscriptivelogics. We show a similar result for default logic. Such results are generally useful to build a theory having someproperties regarding redundancy. For example, one can reduce the problem of redundancy of a clause to the problemof redundancy of a theory, as checking whether γ is redundant in (cid:2) is the same as checking the redundancy of γ inthe modified version of (cid:2) in which all clauses but γ are made irredundant.Definition 21. The M-irredundant version of a default theory (cid:15)D, W (cid:16), where M ⊆ W = {γ1, . . . , γm}, is the followingdefault theory, where {d, c1, . . . , cm} are new variables.(cid:4)(cid:3)(cid:2)(cid:15)D, W (cid:16), MI= (cid:15)D, W(cid:4)(cid:16)P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591331where:WD(cid:5)(cid:4) = {ci ∨ γi | 1 (cid:2) i (cid:2) m}(cid:4) = D1 ∪ D2 ∪ D3: ¬d¬d : ¬c1 ∧ · · · ∧ ¬cm¬c1 ∧ · · · ∧ ¬cm¬d(cid:7)(cid:7)¬c1 ∧ · · · ∧ ¬cm ∧ α : β(cid:7)(cid:7)γ(cid:5),D1 =D2 =α : βγ(cid:6)(cid:6)∈ D(cid:5)D3 =ci ∨ γi : ¬ci ∧ d ∧ {cj | 1 (cid:2) j (cid:2) m, j (cid:14)= i}¬ci ∧ d ∧ {cj | 1 (cid:2) j (cid:2) m, j (cid:14)= i}(cid:7)(cid:7)(cid:7)(cid:7)1 (cid:2) i (cid:2) m, γj ∈ M(cid:6)The clauses of M are made irredundant by this transformation, while the redundancy of the other clauses does notchange.Theorem 11. For any default theory (cid:15)D, W (cid:16) and formulae M and W (cid:4)(cid:4), if M ⊆ W , (cid:15)D(cid:4), W (cid:4)(cid:16) = I ((cid:15)D, W (cid:16), M), andW (cid:4)(cid:4) ⊂ W , then W (cid:4) ≡eD W and W (cid:4)(cid:4) contains all clauses ci ∨ γi such thatγi ∈ M. This holds for Reiter, justified, constrained and rational default logic, and also for consequence-equivalence.D(cid:4) W (cid:4)(cid:4) holds if and only if {γi | ci ∨ γi ∈ W (cid:4)(cid:4)} ≡eProof. The first default of D1 can always be applied to W (cid:4), leading to ¬d, which makes all defaults of D3 inapplica-ble. If W is inconsistent, no other default can be then applied. Otherwise, the only applicable default is the second oneof D1, which generates ¬c1 ∧ · · · ∧ ¬cm. This formula makes W (cid:4) equivalent to W and the defaults of D2 equivalent tothose of D. As a result, I ((cid:15)D, W (cid:16), M) has an extension Cn(E ∪ {¬d, ¬c1, . . . , ¬cm}) for any extension E of (cid:15)D, W (cid:16),if W is consistent, and the extension Cn({d}) otherwise. A subset of W (cid:4) has such an extension if and only if the cor-responding subset of W has the same extension modulo the new variables. This means that if a clause is irredundantin (cid:15)D, W (cid:16), the corresponding clause of (cid:15)D(cid:4), W (cid:4)(cid:16) is irredundant as well.We now prove that all clauses ci ∨ γi such that γi ∈ M are irredundant as well. This is proved by showing that foreach clause of M the corresponding default of D3 can only be applied if that clause is in the background theory, andthat its effect is to produce an extension that cannot generated otherwise.Every default of D3 is applicable to W : the ith default is applicable because its precondition ci ∨ γi is in thebackground theory, and its justification is consistent with the background theory, since W (cid:4) ∪ {d, ¬ci} ∪ {cj | . . .} isequivalent to {γi, d, ¬ci} ∪ {cj | . . .}. The application of such a default makes all other defaults of D(cid:4) inapplicable.This means that the ith default of D3 is not applicable in a subset of W (cid:4) that does not contain ci ∨ γi : the otherclauses of W do entail this one because each clause contains a different ci , and the application of any other defaultblocks this one.Since the extension generated by applying this default is inconsistent with all other extensions of the theory, anysubset of W (cid:4) not containing ci ∨ γi necessarily has a different set of extensions and consequences than W (cid:4).Finally, if a clause γi is redundant in (cid:15)D, W (cid:16) but does not occur in M, the corresponding clause ci ∨ γi does notaffect the extensions obtained by applying the defaults in D3. Its removal could therefore only affect the extensionsobtained by applying the defaults of D1 ∪ D2; the application of these defaults has however essentially the same effectas the application of the defaults of D in the original theory, which proves that ci ∨ γi is redundant. (cid:2)5.4. Complexity of redundancy in default logicsIn this section, we summarize the results about the complexity of checking the redundancy of a clause in thebackground theory of a default theory and that of checking the redundancy of the background theory.The following results are about the redundancy for faithful equivalence.Theorem 18. Checking whether W (cid:4) ≡ein (cid:2)p2 for Reiter and justified default logic and in (cid:2)pD W for a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊆ W is3 for constrained and rational default logic.1332P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Theorem 19. Checking whether W (cid:4) ≡e2 -hardeven if W = W (cid:4) ∪ {a} where a is a variable, W is consistent, and all defaults are categorical and normal, in Reiter,justified, constrained, and rational default logic.D W , where D is a set of defaults and W and W (cid:4) are two formulae, is (cid:2)pTheorem 20. Checking whether W ≡econstrained and rational default logic even if W = W (cid:4) ∪ {a}, where a is a variable.D W (cid:4), where D is a set of defaults and W and W (cid:4) two formulae, is (cid:2)p3 -hard forAs a corollary, we can conclude that the problems of redundancy of a clause and that of redundancy of the back-3 -complete for2 -complete for Reiter and justified default logic and (cid:2)pground theory under faithful equivalence are (cid:2)pconstrained and rational default logic.We now consider the problem of redundancy of clauses when consequence-equivalence is used. The differencebetween the two kinds of equivalence is that two sets of extensions may be different but yet their disjunctions are thesame. The necessity of calculating the disjunction of all extensions intuitively explains why checking redundancy forconsequence-equivalence can be harder than for faithful equivalence.Theorem 21. Checking whether W (cid:4) ≡cW (cid:4) ⊆ W for Reiter, justified, constrained, and rational default logic.D W , where D is a set of defaults and W and W (cid:4) are two formulae, is in (cid:2)p3 ifTheorem 22. The problem of checking whether W (cid:4) ≡cis (cid:2)p3 -hard even if W = W (cid:4) ∪ {a} where a is a variable for Reiter, justified, rational, and constrained default logic.D W , where D is a set of default and W and W (cid:4) two formulae,D W , where D is a set of default and W and W (cid:4) two formulae, is3 -complete if W (cid:4) ⊆ W ; hardness holds even if W = W (cid:4) ∪ {a} where a is a variable. This holds for Reiter, justified,Corollary 6. The problem of checking whether W (cid:4) ≡c(cid:2)pconstrained, and rational default logic.The next problem to analyze is whether a formula is redundant, still for a fixed set of defaults. The results provedin the appendix are as follows.Theorem 23. The problem of formula redundancy for faithful and consequence-equivalence is in (cid:3)ptively, for Reiter, justified, constrained, and rational default logic.3 and (cid:3)p4 , respec-Theorem 24. The problem of formula redundancy based on faithful equivalence is (cid:3)pconsistent theories, for Reiter, justified, constrained, and rational default logic.3 -hard, and remains hard forIn order to prove the (cid:3)p4 -hardness of the problem of formula redundancy under consequence-equivalence, weshould provide a reduction from ∃∀∃∀QBF validity into this problem. A simpler proof can however be given, basedon the following consideration: checking clause redundancy has been proved (cid:2)p3 -hard using reductionsfrom QBFs that results in default theories having W = {a} as the background theory. As a result, these reductions alsoprove that formula redundancy is (cid:2)p3 -hard. In other words, we can reduce the validity of a ∀∃QBF or a∀∃∀QBF into the problems of formula redundancy. What we show is that, if such reductions satisfy some assumptions,we can obtain new reductions from QBFs having an additional existential quantifier in the front. The assumptions arethat the default theory resulting from the reduction is such that:2 -hard or (cid:2)p2 -hard or (cid:2)p1. the background theory that results from the reduction is classically irredundant;2. the matrix of the QBF occurs only in the justification of a single default and does not affect the rest of the defaulttheory.The reductions used for proving the hardness of clause redundancy satisfy both assumptions. In particular,∀X∃Y ∀Z.F is valid if and only if the background theory of the following theory is consequence-redundant, whereW , D, α, β, γ , do not depend on F but only on the quantifiers of the QBF and W is classically irredundant.(cid:5)(cid:8)D ∪α : β ∧ Fγ(cid:6)(cid:9), WP. Liberatore / Artificial Intelligence 172 (2008) 1317–13591333The fact that the matrix of the QBF is copied “verbatim” in the default theory is exploited as follows: if ωw is atruth evaluation over the variable w, then ∀X∃Y ∀Z.F |ωw is valid if and only if the background theory of (cid:15)D ∪{ α:β∧F ∧ωw}, W (cid:16) is redundant. This default theory can be modified in such a way that the subsets of the backgroundγtheory are in correspondence with the truth evaluations over ωw. This way, the resulting theory is redundant if and onlyif ∃w∀X∃Y ∀Z . F is valid. The resulting default theory still satisfies the two assumptions above on the backgroundtheory and on the use of the matrix of the QBF; therefore, this procedure can be iterated to obtain a reduction from∃∀∃∀QBF validity into the problem of formula redundancy under consequence-equivalence. A similar technique canbe used for faithful equivalence.The details of this technique are reported in the appendix. The results obtained this way are as follows.Theorem 25. Formula redundancy is (cid:3)pReiter, justified, constrained, and rational default logic.3 -hard for faithful equivalence and (cid:3)p4 -hard for consequence-equivalence in5.5. Credulous default reasoningIn the credulous approach to default logic, if a formula is in at least one extension of the theory, it is entailed by thetheory. Contrarily to skeptical reasoning, presence in all extensions is not required; presence in one suffices. Credulousequivalence can be defined in the obvious way: two theories (or two background theories, in the assumption that afixed set of defaults is considered) are equivalent if they have the same credulous consequences.If two theories are faithfully equivalent, they also have the same consequences, regardless of whether the skepticalor credulous approach is used. The converse has already been proved untrue for the skeptical semantics. For thecredulous semantics, things are slightly more complicated: credulous equivalence implies faithful equivalence forReiter default logic but not for the other three considered semantics.Theorem 12. If two default theories have the same credulous consequences under Reiter default logic, they also havethe same extensions.Proof. Let us assume to the contrary that E is an extension of T but not of T (cid:4), where T and T (cid:4) have the samecredulous consequences. Let F be a finite formula equivalent to E. By definition, F is entailed by T under thecredulous semantics. Therefore, F is also entailed by T (cid:4). This means that T (cid:4) has an extension E(cid:4) such that E(cid:4) |= F ,which implies E ⊆ E(cid:4).Let F (cid:4) be a finite formula that is equivalent to E(cid:4). We have that F (cid:4) is entailed by T (cid:4), and is therefore also entailedby T . As a result, T has an extension E(cid:4)(cid:4) such that E(cid:4)(cid:4) |= F (cid:4). This implies E(cid:4)(cid:4) |= F , and therefore E(cid:4)(cid:4) |= E, whichmeans E ⊆ E(cid:4)(cid:4).Under Reiter semantics, two extensions of the same theory cannot be one strictly contained into the other [44].This implies E = E(cid:4)(cid:4), and therefore E = E(cid:4). Since E(cid:4) is an extension of T (cid:4), this contradicts the assumption that E isnot an extension of T (cid:4). (cid:2)This theorem shows that, in Reiter default logic, the results about the redundancy of default theories under faithfulequivalence also hold for credulous equivalence.The proof of this theorem is based on the impossibility for a theory to have an extension strictly contained inanother. This is also true for QDL when the background theory has empty support [19] and for ZDL [27], where theabove theorem therefore holds.This condition is however not true for all semantics. We can indeed show a counterexample where two theorieshave different extensions but the same credulous consequences. This counterexample involves a theory having anextension contained into another.Counterexample 6. There exists D, W , W (cid:4) ⊆ W such that (cid:15)D, W (cid:16) and (cid:15)D, W (cid:4)(cid:16) have the same credulous conse-quences but different sets of extensions under justified, constrained and rational default logic.1334P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Proof. The statement holds for W = {a}, W (cid:4) = ∅ and D defined as follows.(cid:5)D =(cid:6): a ∧ ba ∧ b,: ¬a ∧ bbIn all three considered semantics, the first default can be applied to both W and W (cid:4), leading to a ∧ b which blocks theapplication of the second default. Both theories therefore have the extension Cn({a ∧ b}).The second default cannot be applied to W because W contradicts its justification. On the other hand, it can beapplied to W (cid:4), generating b. The first default cannot be now applied, for different reasons: in constrained and rationaldefault logic, the justifications of the two defaults contradict each other; in justified default logic, the first default couldbe applied, but that would lead to a failure because its consequence a ∧ b contradicts the justification ¬a ∧ b of thepreviously applied second default. As a result, W (cid:4) has the additional extension Cn({b}).Since (cid:15)D, W (cid:16) and (cid:15)D, W (cid:4)(cid:16) have different sets of extensions, they are not faithfully equivalent. On the other hand,they have exactly the same credulous consequences. Indeed, the only additional extensions of the second theory isCn({b}), whose consequences are all contained in the consequences of the common extension Cn({a ∧ b}). (cid:2)5.6. Redundancy of defaultsFor the sake of simplicity, we analyze the redundancy of defaults only for the case of faithful equivalence. For a setof clauses W and defaults D, we define ExtW (D) to be the set of extensions of (cid:15)D, W (cid:16), that is, ExtW (D) = ExtD(W ).The definitions of faithful entailment and equivalence are defined as follows.Definition 22 (Faithful equivalence of sets of defaults). Given a fixed background theory W , a set of defaults DW D(cid:4), if ExtW (D) ⊆ ExtW (D(cid:4)). These two sets are faithfullyfaithfully entails a set of defaults D(cid:4), written D |=eequivalent, denoted by D ≡eW D(cid:4), if D |=eW D(cid:4) and D(cid:4) |=eW D.For a fixed background theory, we can define redundancy of a default in a set of defaults as the equivalence of theset with the set where the default has been removed.Definition 23 (Redundancy of a default). A default d is redundant in D with respect to a background theory W if andonly if D\{d} is faithfully equivalent to D.Redundancy of sets of defaults is defined as follows.Definition 24 (Redundancy of a theory). A set of defaults D is redundant with respect to a background theory W ifthere exists D(cid:4) ⊂ D such that D(cid:4) is faithfully equivalent to D.5.6.1. Making defaults irredundantThe following lemma is the version of Theorem 11 in the case of default redundancy rather than clause redundancy.It proves that some defaults can be made irredundant while not changing the redundancy status of the others. Suchresults are generally useful to build default theories having some specific properties w.r.t. redundancy. In particular,the following lemma will be later used in Theorem 14 to prove that the problems of redundancy of clauses can bereduced to the corresponding problems of redundancy of defaults.Lemma 5. For every default theory (cid:15)D, W (cid:16) and every set of defaults DI ⊆ D, let p and q two new variables and{vi} be a set of new variables in bijective correspondence with the defaults of DI , and let D1, D2, D3 be defined asfollows:D1 = {d+, d−}where:d+ =: p ∧ qp ∧ qP. Liberatore / Artificial Intelligence 172 (2008) 1317–13591335d− =D2 =D3 =: ¬p ∧ q¬p ∧ q(cid:5)q ∧ (¬p ∨ α) : ¬p ∨ β(p ∨ vi) ∧ (¬p ∨ γ )q ∧ p ∧ α : βγα : βγ(cid:7)(cid:7)(cid:7)(cid:7)(cid:5)∈ D\DI(cid:7)(cid:7)(cid:7)(cid:7)α : βγ∈ DI , vi is the variable corresponding to(cid:6)(cid:6)α : βγif (cid:15)D, W (cid:16) has extensions and W is consistent, in Reiter, justified, constrained, and rational default logics it holds that:1. the processes of (cid:15)D1 ∪ D2 ∪ D3, W (cid:16) are (modulo the transformation of the defaults) the same as of (cid:15)D, W (cid:16) withd+ added to the front and a number of processes composed of d− and a sequence containing all defaults of D2;2. the extensions of (cid:15)D1 ∪ D2 ∪ D3, W (cid:16) are the same as of (cid:15)D, W (cid:16) with {p, q} added plus the single extension{¬p, q} ∪ {vi};3. a subset of D1 ∪ D2 ∪ D3 is faithfully equivalent to it if and only if it contains D1 ∪ D2 and the set of originaldefaults corresponding to those of D2 ∪ D3 is faithfully equivalent to D.5.6.2. Redundancy of defaults vs. sets of defaultsWhile a formula is classically redundant if and only if it contains a redundant clause, the same does not happen fordefault redundancy. The following counterexamples indeed show that Reiter, constrained, and rational default logicdo not have the unitary redundancy property w.r.t. redundancy of defaults.Counterexample 7. There exists a set of defaults D such that, according to Reiter and rational default logic:1. for every d ∈ D, the theory (cid:15)D\{d}, ∅(cid:16) has extensions and D\{d} (cid:14)≡e2. there exists D(cid:4) ⊂ D such that D(cid:4) ≡e∅ D;∅ D.Counterexample 8. There exists a set of defaults D such that, according to constrained default logic:1. for every d ∈ D, it holds D\{d} (cid:14)≡e2. there exists D(cid:4) ⊂ D such that D(cid:4) ≡e∅ D;∅ D.Justified default logic has the unitary redundancy property w.r.t. default redundancy. This is a combination of twofactors: first, justified default logic is failsafe [29] (every successful process can be made selected by adding somedefaults); second, every extension is generated by an unique set of defaults.Theorem 13. Faithful equivalence of sets of defaults for justified default logic has the monotonic redundancy property.We therefore have as a corollary that justified default logic has the unitary redundancy property when redundancyof defaults is considered.Corollary 2. Faithful equivalence of sets of defaults under justified default logic has the unitary redundancy property.Remarkably, monotonic redundancy could not be proved by using Theorems 1, 2, or 3. Indeed, faithful entailmentand equivalence for justified default logic do not satisfy the preconditions of any of these theorems. Right weakeningdoes not hold as shown by W = ∅, D = { :a}, D(cid:4) = D, and D(cid:4)(cid:4) = ∅: while Ext(D) ⊆ Ext(D(cid:4)) obviously holds(i.e., D entails D(cid:4)) and D(cid:4)(cid:4) ⊆ D(cid:4), the set D has the extension Cn({a}) which D(cid:4)(cid:4) does not have; therefore, Ext(D) (cid:14)⊆Ext(D(cid:4)(cid:4)), that is, D does not entail D(cid:4)(cid:4). Monotonicity does not hold either: it can be the case that Ext(D) ⊆ Ext(D(cid:4))and D ⊆ D(cid:4)(cid:4), but Ext(D(cid:4)(cid:4)) (cid:14)⊆ Ext(D(cid:4)), as for example for W = ∅, D = D(cid:4) = { :aa} and D(cid:4)(cid:4) = D ∪ { :bba , :¬a¬a}.5.6.3. Complexity of redundancy of defaultsFor Reiter default logic, an upper bound on complexity can be given by showing a reduction from the complexityof clause or formula redundancy to the corresponding problems for defaults. This is possible thanks to the followinglemma.1336P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Lemma 6. If W ∪ {γ } is a consistent formula and D a set of defaults, (cid:15)D, W ∪ {γ }(cid:16) and (cid:15)D ∪ { :(cid:17)γReiter extensions.}, W (cid:16) have the sameProof. We prove that every selected process of the first theory can be turned into a selected process of the second:(cid:17)theory by the addition of the defaultγ hasno precondition, it is always applicable. As a result, [ :(cid:17)}, W (cid:16). In order to prove that thisγis a selected process, we observe that the background theory and the consequences of the default of a process alwaysoccur together in the definition of a selected process. As a result, it does not matter if γ is in the background theoryor in consequence of a default in a process.:(cid:17)γ , and vice versa. Let (cid:2) be a selected process of (cid:15)D, W ∪ {γ }(cid:16). Since] · (cid:2) is a process of (cid:15)D ∪ { :(cid:17)γLet us now assume that (cid:2) is a selected process of the second theory. Since:(cid:17)γ has no precondition, it is in (cid:2), asotherwise this process would not be closed. Let (cid:2)(cid:4) be the process obtained by removing :(cid:17)γ from (cid:2). This is a selectedprocess of (cid:15)D, W ∪ {γ }(cid:16), because the lack of the clause γ from cons((cid:2)(cid:4)) is compensated by the presence of γin W . (cid:2)If a background theory is consistent, this lemma can be applied to all its clauses, leading to the following charac-terization of the complexity of redundancy for defaults.Theorem 14. The problem of redundancy of a default and of a default theory for faithful equivalence in Reiter defaultlogic are (cid:2)p2 -hard and (cid:3)p3 -hard, respectively.Proof. Hardness of clause and formula redundancy remains the same even if the formula is consistent by Theorem 19and Theorem 24. As a result, Lemma 6 can be applied: a clause γ is redundant in (cid:15)D, W (cid:16) if and only if dγ is redundantin (cid:15)D ∪ {dγ }, W \{γ }(cid:16). Indeed, (cid:15)D, W (cid:16) has the same extensions of (cid:15)D ∪ {dγ }, W \{γ }(cid:16), and removing γ from the firsttheory or removing dγ from the second theory lead both to (cid:15)D, W \{γ }(cid:16).The problem of formula redundancy can be reduced to default redundancy by first applying Lemma 6 to all clausesof W , and then making all original defaults irredundant using the transformation of Lemma 5. (cid:2)In order to show membership of the problems of redundancy, we prove that faithful equivalence of sets of defaultsis in (cid:2)p2 .Theorem 15. Checking faithful equivalence of two sets of defaults is in (cid:2)p2 for Reiter default logic.Proof. The contrary of the statement amounts to checking whether any of the two theories have an extension thatthe other one does not have. The number of possible extensions, however, is limited by the fact that any extension isgenerated by the set of consequences of some defaults.Checking whether (cid:15)D, W (cid:16) has an extension that (cid:15)D(cid:4), W (cid:4)(cid:16) has not can be done as follows: guess a subset D(cid:4)(cid:4) ⊆ D,and let E = cons(D(cid:4)(cid:4)); check whether E is an extension of (cid:15)D, W (cid:16) but is not an extension of (cid:15)D(cid:4), W (cid:4)(cid:16).Checking whether a formula E is an extension of a default theory can be done with a logarithmic number ofsatisfiability tests [28,45]. As a result, the problem can also be expressed as a QBF formula ∃∀QBF. In order to checkwhether there exists D(cid:4)(cid:4) such that E = cons(D(cid:4)(cid:4)) is in this condition, we only have to add an existential quantifier tothe front of this formula. The problem is therefore in (cid:2)p2 . (cid:2)The problem of checking the redundancy of a set of defaults is obviously in (cid:3)p3 , as it can be solved by guessing asubsets of defaults and then checking equivalence. As a result, we have a precise complexity characterization of theproblems of redundancy of Reiter default logics according to faithful equivalence.Corollary 3. The problem of checking the redundancy of a default and the redundancy of a set of defaults are (cid:2)p2 -complete and (cid:3)p3 -complete, respectively, for Reiter default logic and faithful equivalence.P. Liberatore / Artificial Intelligence 172 (2008) 1317–135913376. ConclusionsIn this article, some properties of redundancy in some non-monotonic logics has been proved. These properties fallin three categories: some logics have the monotonic or unitary redundancy property while others do not; some parts ofa theory can be made irredundant; and results characterizing the complexity of checking the redundancy of an elementin a set and the redundancy of a set.The results can be summarized as follows.Monotonic/unitary redundancy: hold for circumscription (with all variables minimized), for the redundancy of thebackground theory for categorical normal default logic, and for the redundancy of defaults in justified de-fault logic; do not hold for the redundancy of the background theory in default logic in general and for theredundancy of defaults for Reiter, constrained, and rational default logic;Making parts irredundant: for every of the considered formalisms, we were able to provide a transformation thatmakes an arbitrary part of a set irredundant, while not changing the redundancy status of the other elementsof the set;Complexity results: complexity results regarding the second and third level of the polynomial hierarchy have beenprovided; the following list gives the results for problem of checking the redundancy of an element.• CIRC-redundancy (all variables minimized) of a clause is (cid:2)p• redundancy of a clause of the background theory under faithful equivalence is (cid:2)p3 -complete for constrained and rational default logic;justified default logic and (cid:2)p2 -complete for Reiter and• redundancy of a clause of the background theory under (skeptical) consequence-equivalence is (cid:2)p3 -2 -complete;complete for Reiter, justified, constrained and rational default logic;• redundancy of a default under faithful equivalence for Reiter default logic is (cid:2)pThe complexity of checking the redundancy of a set is in the following list.• CIRC-redundancy (all variables minimized) of a formula is (cid:2)p• redundancy of a background theory is (cid:3)p2 -complete;2 -complete.3 -complete for faithful equivalence for Reiter, justified, con-strained, and rational default logic;• redundancy of a background theory is (cid:3)pjustified, constrained, and rational default logic;4 -complete for (skeptical) consequence-equivalence for Reiter,• redundancy of a set of defaults under faithful equivalence for Reiter default logic is (cid:3)p3 -complete.In a way, circumscription with all variables minimized can be seen as a very basic form of non-monotonic reason-ing. However, it somehow expresses the core principle of circumscription, as general circumscription can be translatedinto it [8,9]. Nevertheless, the results about redundancy in this restriction do not necessarily extend to the general case,as the elimination of varying and fixed variable modify the formula to be minimized. The extension of the results pre-sented in this article to the general case is therefore left as an open problem.Two results are proved regarding credulous default reasoning: equality of credulous consequences coincide withfaithful equivalence for Reiter default logic but not for the three other considered semantics. This means that all resultsregarding faithful equivalence in Reiter default logic extend to credulous equivalence. The problem of whether theyhold for the other three semantics is left as an open problem.While most of the results are about the redundancy of a set of clauses, some results have also been given aboutthe redundancy of a set of defaults. This scenario is interesting because redundancy is defined on something whichis not a propositional formula, so the usual propositional entailment relation and connectives cannot be used. For thisreason, in the section about general results we have considered the redundancy of an arbitrary set of elements, withoutrestricting these elements to be clauses or propositional formulae.The complexity results show that the problems of redundancy of a clause in a formula is the same as for the corre-sponding problem of entailment for all considered cases. While membership to the same class is obvious, hardness isnot and required a separate proof. Regarding the relative complexity of clause redundancy and formula redundancy,one may observe that the difference is affected by the unitary redundancy property. If the unitary redundancy propertyholds, redundancy of a formula is equivalent to the existence of a redundant clause in it; this means that the check forredundancy of the formula can be done by performing a linear number of clause redundancy checks, and these can beparallelized, thus leading the same complexity. On the other hand, if unitary redundancy does not hold, redundancy1338P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359of a formula requires checking the existence of an equivalent subset of the formula. This corresponds to an additionalexistential quantification when these tests are expressed as QBFs, which may imply a jump of one level up in thepolynomial hierarchy.An open question is about the extension of the results presented in this article to strong and uniform equivalence.As it has been noted in the study of default logic, redundancy is defined in terms of equivalence, and its propertydepends on the definition of equivalence used. Two forms of equivalence that have been recently defined are thoseof strong and uniform equivalence, which can be defined as “update-resistant equivalence” [12,32,50,51]. A clausewould therefore be strongly CIRC-redundant not only if they can be removed from a formula without changing theminimal models of the formula, but also if the same happens in the formulae obtained by adding other clauses.AcknowledgementsThe author thanks Jiang Zhengjun for his comments about a previous version of this paper. Thanks also goes to theanonymous reviewers, and in particular for their suggestions of relating unitary redundancy with cumulativity, whichlead the author to the study of redundancy in arbitrary logics.Appendix A. Two counterexamplesThe following two counterexamples are about redundancy in arbitrary logics. In this section we use (cid:2), (cid:2)(cid:4), etc. todenote sets of formulae (rather than default processes) to the sake of coherence with the section on arbitrary logics.The first counterexample shows that unitary redundancy does not imply monotonic redundancy (the converse has beenproved to hold).Counterexample 1 (proof). There exists a logic where |=L is reflexive, ≡L is symmetric and transitive, they are relatedby full-entailment, and unitary redundance holds, but monotonic redundancy does not.Proof. We show that the statement holds for |=eD and ≡eD defined by the following set of defaults:(cid:5)D =(cid:6): x ∧ yx ∧ y,y : ¬x ∧ y¬x ∧ yMonotonic redundancy does not hold: let (cid:2) = {x, y}, (cid:2)(cid:4) = ∅, and (cid:2)(cid:4)(cid:4) = {y}. Both (cid:2) and (cid:2)(cid:4) have Cn({x, y}) astheir only extension, as the first default is the only one that can be applied, and the second default cannot then beapplied. In the theory (cid:2)(cid:4)(cid:4), either the first or the second default can be applied, leading to two extensions: Cn({x, y})and Cn({¬x, y}).Reflexivity, symmetry, transitivity and full-entailment are obvious from definition. Proving that this logic has theunitary redundancy property is more involved. Most of the theories have Cn({x, y}) as their only extension. The onlyexceptions are the theories where the second default can be applied and the theories where the first default cannot beapplied. The theories in the first category entail y but not x; the theories in the second category entail ¬x ∨ ¬y.1. {¬x, y} has extension Cn({¬x, y});{y} has extensions Cn({x, y}) and Cn({¬x, y});2. {⊥}, {¬x ∨ ¬y}, {¬x}, {¬y}, {¬x, ¬y}, {x, ¬y}, {x ∨ y, ¬x ∨ ¬y}, all have their deductive closure as their onlyextension.Each of these theories has a set of extensions that is different from that of the another, and is different from the setcontaining only Cn({x, y}). As a result, if two sets (cid:2) and (cid:2)(cid:4) are not faithfully equivalent, then at least one of themis one of the above theories. Moreover, if (cid:2) and (cid:2)(cid:4) are not classically equivalent but faithfully equivalent, they bothhave Cn({x, y}) as their only extension.Let us assume that a counterexample to unitary redundancy exists. There exists (cid:2) and (cid:2)(cid:4) such that (cid:2)(cid:4) ⊂ (cid:2) and(cid:2)(cid:4) is equivalent to (cid:2) but for every γ ∈ (cid:2) it holds that (cid:2)\{γ } is not equivalent to (cid:2). Since (cid:2)(cid:4) is equivalent to (cid:2), itcannot be the case that (cid:2)(cid:4) and (cid:2) differ for a single clause γ , as otherwise (cid:2)(cid:4) would be equal to (cid:2)\{γ } and thereforenot equivalent to (cid:2).P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591339As a result, (cid:2)(cid:4) and (cid:2) differ on two or more clauses, that is, (cid:2)\(cid:2)(cid:4) contains at least two clauses. We show that,among the sets (cid:2)\{γ } such that γ ∈ (cid:2)\(cid:2)(cid:4), there are at least two which are not classically equivalent. Let assume tothe contrary that all these theories (cid:2)\{γ } are classically equivalent. Then, their union would be classically equivalentto them, and therefore also faithfully equivalent to them; since their union is (cid:2), that would contradict the assumptionthat they are not equivalent to it.We are therefore in the following condition: there are at least two clauses γ1, γ2 ∈ (cid:2) such that no two theoriesamong (cid:2), (cid:2)\{γ1}, and (cid:2)\{γ2} are equivalent to each other. Let (cid:2)1 = (cid:2)\{γ1} and (cid:2)2 = (cid:2)\{γ2}. We have that (cid:2)(cid:4)and (cid:2) are equivalent, but are not classically equivalent to (cid:2)1 and (cid:2)2, which are also not classically equivalent to eachother.Since (cid:2)(cid:4) and (cid:2) are faithfully but not classically equivalent, they both have Cn({x, y}) as their only extension,since every other possible set of extensions is only generated by classically equivalent theories. Since (cid:2)1 and (cid:2)2 arenot faithfully equivalent to them, they are equivalent to two of the theories above: each one either entails y but not x,or entails ¬x ∨ ¬y.If either (cid:2)1 or (cid:2)2 entail ¬x ∨ ¬y, their union does the same. Therefore, (cid:2) would not have Cn({x, y}) as its onlyextension. If both theories entail y but not x, they are equivalent to y and ¬x ∧ y, respectively; their union is therefore¬x ∧ y, which does not have Cn({x, y}) as its only extension.In all possible cases where unitary redundancy would be violated we have that reached a contradiction; therefore,no counterexample to unitary redundancy exists for this logic. (cid:2)The second counterexample shows that there exists a logic where the alternative definition of redundancy in termsof entailment ((cid:2)\{γ } |=L γ ) is not the same as the definition in terms of equivalence ((cid:2) ≡L (cid:2)\{γ }).Counterexample 2 (proof). There exists two relations |=L and ≡L such that |=L is reflexive, ≡L is reflexive andsymmetric, |=L and ≡L are related by full entailment, but there exists (cid:2) and γ ∈ (cid:2) such that (cid:2)\{γ } |=L γ but(cid:2) (cid:14)≡L (cid:2)\{γ }.Proof. We use faithful entailment |=eD and equivalence ≡eD for the following set of defaults.D = {d1, d2}where: a ∧ ¬ba ∧ ¬bd1 =d2 = a : bbIn (cid:15)D, ∅(cid:16), the only applicable default is d1, which blocks the application of d2. The only extension of this theoryis therefore Cn({a, ¬b}). In (cid:15)D, {a}(cid:16) we can still apply d1, with the same result, but we can also apply d2. Theconsequence of this default blocks the application of the first; therefore, we have a second extension Cn({a, b}).We therefore have that ExtD(∅) ⊆ ExtD({a}) and therefore ∅ |=eDExtD(∅). As a result, by taking (cid:2) = {a} and γ = a, we have that (cid:2)\{γ } |=e{a}. Yet, ∅ (cid:14)≡eDD γ but (cid:2)\{γ } (cid:14)≡eD (cid:2). (cid:2){a} because ExtD({a}) (cid:14)⊆Appendix B. Complexity of CIRC-redundancyThe following theorem shows the complexity of the problem of redundancy of a single clause.Theorem 8 (proof). Checking the CIRC-redundancy of a clause in a formula is (cid:2)pformula is assumed to be satisfiable.2 -complete, and remains hard if theProof. Lemma 1 proves that the redundancy of a clause in a formula can be checked by solving a ∀∃QBF (for allM . . . there exists M (cid:4) . . .), and is therefore in (cid:2)p2 . Alternatively, Theorem 4 and Theorem 6 prove that a clause γ isredundant in (cid:2) if and only if (cid:2)\{γ } |=M γ ; Eiter and Gottlob [13] proved that this problem is in (cid:2)p2 .We show hardness by reduction from a QBF formula ∀X∃Y.(cid:4) to the problem of redundancy. We assume that (cid:4)is satisfiable; this assumption does not change the hardness of the problem. Let X = {x1, . . . , xn}, Y = {y1, . . . , yn},1340P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359and (cid:4) = {δ1, . . . , δm}. Let a and {p1, . . . , pn} be new variables. We show that ∀X∃Y.(cid:4) is valid if and only if γ isCIRC-redundant in (cid:2), where:(cid:2) = {xi ∨ pi | 1 (cid:2) i (cid:2) n} ∪ {¬a ∨ yj | 1 (cid:2) j (cid:2) n} ∪ {a ∨ δk | 1 (cid:2) k (cid:2) m} ∪ {γ }γ = ¬a ∨ ¬y1 ∨ · · · ∨ ¬ynThis formula (cid:2) is satisfiable: it is satisfied by every model where all pi ’s are true, a is false, and all variables xi ’sand yi ’s have the values that make (cid:4) true (such an assignment exists because (cid:4) has been assumed satisfiable).By Lemma 1, γ is CIRC-redundant in (cid:2) if and only if each minimal model of (cid:2)\{γ } ∪ ¬γ contains a model of (cid:2).The following equivalences holds:(cid:2) ≡ {xi ∨ pi | 1 (cid:2) i (cid:2) n} ∪ {¬a} ∪ (cid:4)(cid:2)\{γ } ∪ ¬γ ≡ {xi ∨ pi | 1 (cid:2) i (cid:2) n} ∪ {a, y1, . . . , yn}The first equivalence holds because {¬a ∨ yj | 1 (cid:2) j (cid:2) n} ∪ {¬a ∨ ¬y1 ∨ · · · ∨ ¬yn} is equivalent to ¬a, as can bechecked by resolving upon each yj in turn. The second equivalence holds because ¬γ = {a, y1, . . . , yn} and this setimplies all clauses ¬a ∨ yj and a ∨ δk.Formula (cid:2)\{γ } ∪ ¬γ has a minimal model for each truth evaluation ωX over the variables xi :IωX= ωX ∪ {pi | 1 (cid:2) i (cid:2) n, xi /∈ ωX} ∪ {a} ∪ {yj | 1 (cid:2) j (cid:2) n}We show that the model IωX contains a model of (cid:2) if and only if (cid:4)|ωX is satisfiable. By Lemma 1, the redundancyof γ corresponds to this condition being true for all possible models of (cid:2)\{γ } ∪ ¬γ . This would therefore prove thatthe QBF is valid if and only if γ is redundant in (cid:2).Since (cid:2) ≡ {xi ∨ pi | 1 (cid:2) i (cid:2) n} ∪ {¬a} ∪ (cid:4), if (cid:4) has a model with a given value of ωX then (cid:2) has a model that isstrictly contained in IωX : add to the satisfying assignment of (cid:4) the setting of every pi to the opposite of xi and a tofalse.On the converse, if (cid:2) has a model that is strictly contained in IωX , this model must have exactly the same value ofX ∪ P because (cid:2) contains xi ∨ pi and either xi or pi is false in IωX . On the other hand, this model of (cid:2) must alsoset a to false and satisfy (cid:4), thus showing that there exists an assignment extending ωX and satisfying (cid:4). (cid:2)The following lemma is about making clauses irredundant while not changing the redundancy status of the otherones. In other words, it shows a way to make the clauses of (cid:2)\(cid:2)(cid:4) necessary, that is, contained in all equivalent subsetsof (cid:2).Lemma 4 (proof). For every consistent formula (cid:2) = {γ1, . . . , γm} and every (cid:2)(cid:4) ⊆ (cid:2), the only CIRC-redundantclauses of I ((cid:2), (cid:2)(cid:4)) are the clauses ¬s ∨ ¬t ∨ γi such that γi ∈ (cid:2)(cid:4) is CIRC-redundant in (cid:2).Proof. There are four possible assignment to the variables s and t. Since the models of I ((cid:2), (cid:2)(cid:4)) can be partitionedinto the models of I ((cid:2), (cid:2)(cid:4)) ∪ {¬s, ¬t}, I ((cid:2), (cid:2)(cid:4)) ∪ {s, ¬t}, I ((cid:2), (cid:2)(cid:4)) ∪ {¬s, t}, and I ((cid:2), (cid:2)(cid:4)) ∪ {s, t}, the minimalmodels of I ((cid:2), (cid:2)(cid:4)) are necessarily some of the minimal models of these formulae.In the table below we show what remains of I ((cid:2), (cid:2)(cid:4))\{s ∨ t} in each of the four possible assignment to s and tafter removing entailed clauses and false literals. We also show the minimal models of the resulting formulae.assignment{¬s, ¬t}{s, ¬t}{¬s, t}{s, t}subformula{a, b}{b} ∪ {ci ∨ di | 1 (cid:2) i (cid:2) m}∪{¬ci | 1 (cid:2) i (cid:2) m}{a} ∪ {ci ∨ γi | 1 (cid:2) i (cid:2) m, γi ∈ (cid:2)\(cid:2)(cid:4)}∪{x ∨ x(cid:4) | x ∈ Var((cid:2))}{¬ci | 1 (cid:2) i (cid:2) m}∪{ci ∨ γi | 1 (cid:2) i (cid:2) m, γi ∈ (cid:2)\(cid:2)(cid:4)} ∪ (cid:2)(cid:4)minimal models{a, b}{s, b} ∪ {di }{t, a} ∪ H where H ⊆ C ∪ X ∪ X(cid:4){s, t} ∪ H where H ∈ CIRC((cid:2))The four subformulae are all satisfiable. Moreover, no minimal model of one is contained in the minimal models ofanother because of either the values of {s, t} and {a, b}. As a result, the minimal models of I ((cid:2), (cid:2)(cid:4))\{s ∨ t} are exactlyP. Liberatore / Artificial Intelligence 172 (2008) 1317–13591341the minimal models of the four subformulae. The clause s ∨ t is irredundant because its addition to I ((cid:2), (cid:2)(cid:4))\{s ∨ t}deletes the minimal model {a, b}. The minimal models of I ((cid:2), (cid:2)(cid:4)) are therefore exactly the minimal models of theremaining three subformulae.We show that the remaining clauses but the ones derived from (cid:2)(cid:4) are irredundant. This is shown by removing aclause from the set and showing that some of the minimal models of a subformula can be removed some elements.Since the minimal models of these three subformulae are exactly the minimal models of (cid:2), this is a proof that theclause is irredundant.1. The clauses s ∨ a and t ∨ b are irredundant because their removal would allow a and b to be set to false in theminimal models of the third and second subformula, respectively.2. The clauses ¬s ∨ t ∨ ci ∨ di and ¬s ∨ ¬ci are irredundant because their removal would allow di to be set to falsein the minimal model of the second subformula.3. The clauses ¬t ∨ ci ∨ γi and s ∨ ¬t ∨ x ∨ x(cid:4) require a longer analysis. In the third assignment, I ((cid:2), (cid:2)(cid:4)) becomes:(cid:11)(cid:4) | x ∈ Var((cid:2))F = {a} ∪ {ci ∨ γi | 1 (cid:2) i (cid:2) m} ∪x ∨ x(cid:10)The clauses x ∨ x(cid:4) are positive. By Lemma 2, they are CIRC-redundant if and only if they are redundant. In turn,they are not redundant because {a} ∪ {ci | 1 (cid:2) i (cid:2) m} ∪ {y | y ∈ X, y (cid:14)= x} is a model of all clauses but x ∨ x(cid:4).Since ci occurs positive in ci ∨ γi , Lemma 3 ensures that this clause is CIRC-redundant in F if and only if it isredundant in F \{x ∨ x(cid:4) | ¬x ∈ γi}. This is false because the removal of ci ∨ γi creates the following new model:M = {cj | 1 (cid:2) j (cid:2) m, j (cid:14)= i} ∪ {x(cid:4)} ∪ {x | ¬x ∈ γi}This model M satisfies F \{x ∨ x(cid:4) | ¬x ∈ γi}\{ci ∨ γi}: all clauses cj ∨ γj are satisfied because cj ∈ M and allclauses x ∨ x(cid:4) are satisfied because x(cid:4) ∈ M. On the other hand, M does not satisfy ci ∨ γi because it assigns allits literals to false.The only clauses that can therefore be redundant are those corresponding to the clauses of (cid:2)(cid:4). In particular, theseclauses only occur in the fourth subformula, which is equivalent to {s, t}∪{¬ci | 1 (cid:2) i (cid:2) m}∪(cid:2). A clause ¬s ∨¬t ∨γiwith γi ∈ (cid:2)(cid:4) is therefore CIRC-redundant in I ((cid:2), (cid:2)(cid:4)) if and only if γi is CIRC-redundant in (cid:2). (cid:2)Appendix C. Equivalence in default logicsIn this section we show the relationship among the different definitions of equivalence in default logic.C.1. Non-equality of equivalence relationsIn this section we show that the three considered forms of equivalence do not in general coincide even if one theoryis contained in the other.Counterexample 9. There exists a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊂ W , W (cid:4) ≡mW (cid:4) (cid:14)≡cD W in Reiter, justified, constrained and rational default logic.D W , andProof. Let D, W , and W (cid:4) be as follows.D = {d1, d2}where:: a ∧ ¬ba ∧ ¬bd1 =d2 = a : bbW = {a}(cid:4) = ∅W1342P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359The only selected process of (cid:15)D, W (cid:4)(cid:16) is [d1], which generates the extension Cn({a, ¬b}). This extension entails W ,but it also entails ¬b. The theory (cid:15)D, W (cid:16) has also the process [d2], generating the extension Cn({a, b}). Thesetwo processes cannot however be concatenated, as the consequence ¬b of d1 is inconsistent with the justificationof d2.Since W (cid:4) ⊂ W , we have that W |=D W (cid:4). In this example, we also have W (cid:4) |=D W because the single extensionof W (cid:4) entails W = {a}. However, W (cid:4) and W have different set of extensions; in particular, ∨ExtD(W (cid:4)) ≡ a ∧ ¬b and∨ExtD(W ) ≡ a. (cid:2)Since W (cid:4) (cid:14)≡cD W , it also holds W (cid:4) (cid:14)≡eA similar result can be proved about ≡cD and ≡eD.D W , which proves that mutual and faithful equivalence do not coincide.Counterexample 10. There exists a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊂ W , W (cid:4) ≡cW (cid:4) (cid:14)≡eD W in Reiter and justified default logic.D W , andProof. Let D = {d1, d2, d3, d4}, W = {a}, W (cid:4) = ∅, and the defaults be as follows.d1 =: ¬b ∧ ca ∧ c: ¬b ∧ ¬cd2 =a ∧ ¬cd3 = a : b ∧ cb ∨ cd4 = a ∧ (b ∨ c) : b ∧ ¬cbIn W (cid:4), only d1 and d2 are applicable. The consequence of the first default is a ∧ c, which is consistent with thejustification of d3. Default d4 is not applicable because of its justification. The first selected process of W (cid:4) is therefore[d1, d3], leading to the extension Cn({a, c}).The second process from W (cid:4) starts with d2, whose consequence is a ∧ ¬c, which is not consistent with d1 andd3, and does not imply the precondition of d4. As a result, [d2] is the second selected process of W (cid:4), leading to theextension Cn({a, ¬c}). We therefore have ∨ExtD(W (cid:4)) ≡ (a ∧ c) ∨ (a ∧ ¬c) ≡ a.Let us now consider the extensions of W . All selected processes of W (cid:4) are also selected processes of W . However,we can now apply d3, as a is true in the background theory. We therefore obtain b ∨ c. This conclusion is inconsistentwith the justification of d2, but d1 and d4 can be applied. The first one leads to the extension Cn({a, c}), which isalso an extension of (cid:15)D, W (cid:4)(cid:16). On the other hand, [d3, d4] leads to Cn({a, b}), which is a new extension. Nevertheless,∨ExtD(W ) ≡ (a ∧ c) ∨ (a ∧ ¬c) ∨ (a ∧ b) ≡ a: the theory (cid:15)D, W (cid:16) has the extensions Cn({a, b}) which (cid:15)D, W (cid:4)(cid:16) doesnot have, but their skeptical consequences are the same. (cid:2)In the proof, we used two defaults that are applicable in W but not in the processes of (cid:15)D, W (cid:4)(cid:16). Such two defaultscannot have mutually consistent justifications; otherwise, they would be both applicable in some process of (cid:15)D, W (cid:4)(cid:16)thanks to the fact that any extension of (cid:15)D, W (cid:16) contains only models of some extensions of (cid:15)D, W (cid:4)(cid:16). This condi-tion is not possible in constrained and rational default logic; however, the same claim can be proved in a differentway.Counterexample 11. There exists a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊂ W , W (cid:4) ≡cW (cid:4) (cid:14)≡eD W in constrained and rational default logic.D W , andProof. D, W , and W (cid:4) are defined as follows.D = {d1, d2, d3, d4}W = {x}(cid:4) = ∅WP. Liberatore / Artificial Intelligence 172 (2008) 1317–13591343: x ∧ axd1 =d2 = x : a ∧ bd3 = x : a ∧ ¬b¬bd4 = x : ¬a ∧ ¬bbxThe justifications of d2, d3, and d4 are mutually inconsistent. The selected processes of (cid:15)D, W (cid:16) are [d1, d2], [d2, d1],[d1, d3], [d3, d1], and [d4], generating the three extensions E1 = Cn({x, b}), E2 = Cn({x, ¬b}), and E3 = Cn({x}).Their disjunction is ∨ExtD(W ) ≡ x.Let us now consider (cid:15)D, W (cid:4)(cid:16). The only default that is applicable in W (cid:4) = ∅ is d1, which generates x but also has aas a justification. As a result, the defaults d2 and d3 are still applicable, but d4 is not. As a result, the only extensionsof (cid:15)D, W (cid:4)(cid:16) are Cn({x, b}) and Cn({x, ¬b}). We therefore have W (cid:4) (cid:14)≡eD W . On the other hand, ∨ExtD(W (cid:4)) ≡ x, whichis equivalent to ∨ExtD(W ). As a result, W (cid:4) ≡cD W . (cid:2)C.2. Equality of entailment relationsThe following chain of implications is easy to prove:W(cid:4) |=eD W ⇒ W(cid:4) |=cD W ⇒ W(cid:4) |=D WThe latter implication is proved by the following lemma.Lemma 7. For any set of defaults D and two formulae W and W (cid:4), if W (cid:4) |=cconstrained and rational default logic.D W then W (cid:4) |=D W , in Reiter, justified,Proof. By assumption, ∨ExtD(W (cid:4)) |= ∨ExtD(W ). Since every extension of (cid:15)D, W (cid:16) entails W , we have ∨ExtD(W ) |=W . As a result, ∨ExtD(W (cid:4)) |= W , which is by definition W (cid:4) |=D W . (cid:2)Redundancy is defined in terms of equivalence of two formulae, one contained in the other. As a result, it makessense to study the conditions of equivalence in the particular case in which W (cid:4) ⊆ W . The above chain of implicationscan be wrapped around in this case, thus proving that the three forms of entailment coincide. The following lemma hasbeen proved by Makinson [35, Observation 9] for Reiter default logic; Makinson stated that if W (cid:4) ⊆ W and W (cid:4) |=D Wthen W (cid:4) |=cD W holdsin this case. This fact can be generalized to justified, constrained, and rational default logic.D W , but the proof of this statement actually shows that W (cid:4) |=cD W holds by proving that W (cid:4) |=eLemma 8. For any set of defaults D and two formulae W and W (cid:4), if W (cid:4) ⊆ W and W (cid:4) |=D W then W (cid:4) |=eReiter, justified, constrained and rational default logic.D W forProof. Let (cid:2) be a selected process of (cid:15)D, W (cid:4)(cid:16). We prove that it is also a selected process of (cid:15)D, W (cid:16). Since W (cid:4) |=D W ,the formula W is entailed by every extension in ExtD(W (cid:4)). In particular, W (cid:4) ∪ cons((cid:2)) |= W . Therefore, W (cid:4) ∪cons((cid:2)) ≡ W ∪ cons((cid:2)). As a result, all conditions (such as success and closure) where W (cid:4) only occurs in thesubformula W (cid:4) ∪ cons((cid:2)) are not changed by replacing W (cid:4) with W . This is in particular true for all consideredconditions of success and closure.The only condition that mentions the background theory not in conjunction with cons((cid:2)) is the condition of asequence being a process: (cid:2) is a process of (cid:15)D, W (cid:4)(cid:16) if and only if W (cid:4) ∪ cons((cid:2)[d]) |= prec(d) for any d ∈ (cid:2). Thesame condition is however true for W because W (cid:4) ⊆ W implies W |= W (cid:4). (cid:2)The following is a consequence of these two lemmas.Corollary 4. For any set of defaults D and two formulae W and W (cid:4), if W (cid:4) ⊆ W , then in Reiter, justified, constrained,and rational default logic the following holds:D W(cid:4) |=D W ⇔ WD W ⇔ W(cid:4) |=c(cid:4) |=eW1344P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359C.3. Equality of equivalence relations in particular casesWhile ≡cD and ≡econtained in the other one.D are not the same in general, they coincide when all defaults are normal and one formula isTheorem 16. For any set of normal defaults D and two formulae W and W (cid:4), if W (cid:4) ⊆ W then W (cid:4) ≡cW (cid:4) ≡eD W in constrained default logic.D W impliesProof. Given the previous result, we only have to prove that W ≡c(cid:15)D, W (cid:16) does not have any extension that is not an extension of (cid:15)D, W (cid:4)(cid:16).D W (cid:4) implies that ExtD(W ) ⊆ ExtD(W (cid:4)), that is,To the contrary, assume that such extension exists. Let (cid:2) be the process that generates the extension of (cid:15)D, W (cid:16)that is not an extension of (cid:15)D, W (cid:4)(cid:16). By definition of process, cons((cid:2)) ∪ W ∪ just((cid:2)) is consistent. Therefore, it has amodel M. Since this model satisfies both W and cons((cid:2)), it is a model of the extension generated by (cid:2).Since the conclusions of the two theories are the same, every model of the extension generated by (cid:2) is a model ofsome extensions of (cid:15)D, W (cid:4)(cid:16). Let (cid:2)(cid:4) be the process of (cid:15)D, W (cid:4)(cid:16) that generates an extension that has the model M. Weprove that all defaults of (cid:2) are in (cid:2)(cid:4).Since M is a model of the extension generated by (cid:2)(cid:4), it is a model of cons((cid:2)(cid:4)) ∪ W (cid:4). Therefore, it is a model ofcons((cid:2)(cid:4)), and a model of just((cid:2)(cid:4)) because defaults are normal. We have already proved that M is a model of cons((cid:2))and just((cid:2)) and of W . As a result, the set cons((cid:2)) ∪ cons((cid:2)(cid:4)) ∪ W ∪ just((cid:2)) ∪ just((cid:2)(cid:4)) is consistent. Therefore, wecan add all defaults of (cid:2) to (cid:2)(cid:4) without contradicting the justifications.As a result, the defaults of (cid:2) are not in (cid:2)(cid:4) only if their preconditions are not entailed from the consequences of (cid:2).This is impossible: since (cid:2) is a process of (cid:15)D, W (cid:16), we have W |= prec(d), where d is the first default of (cid:2). As aresult, d must be part of (cid:2)(cid:4), otherwise (cid:2)(cid:4) would not be a maximal process. The consequences of d are therefore partof cons((cid:2)(cid:4)) ∪ W (cid:4). Repeating the argument with the second default of (cid:2) we get the same result. We can thereforeconclude that all defaults of (cid:2) are in (cid:2)(cid:4). (cid:2)Since Reiter, justified, constrained, and rational default logics coincide on normal default theories, the equality ofthe definitions of equivalence holds when defaults are normal.Theorem 17. If D is a set of normal defaults and W and W (cid:4) are two formulae such that W (cid:4) ⊆ W , then W (cid:4) ≡cholds if and only if W (cid:4) ≡eD W holds for Reiter, justified, constrained, and rational default logic.D WThe following lemma is what is missing for proving that the three considered forms of equivalence coincide whenall defaults are categorical and normal.Lemma 9. If D is a set of categorical defaults and W and W (cid:4) are two formulae such that W (cid:4) ⊆ W and W (cid:4) |=D W ,then W |=eD W (cid:4) in constrained default logic.Proof. Let (cid:2) be a selected process of (cid:15)D, W (cid:16). We prove that (cid:2) is a selected process of (cid:15)D, W (cid:4)(cid:16) generating the sameextension.Since (cid:2) is a selected process of (cid:15)D, W (cid:16), it holds that W ∪ cons((cid:2)) ∪ just((cid:2)) is consistent. Since W (cid:4) ⊆ W , italso holds that W (cid:4) ∪ cons((cid:2)) ∪ just((cid:2)) is consistent. Since no default has preconditions, (cid:2) is a successful processof (cid:15)D, W (cid:4)(cid:16). Since constrained default logic is a failsafe semantics [29], there exists (cid:2)(cid:4) such that (cid:2) · (cid:2)(cid:4) is a selectedprocess of (cid:15)D, W (cid:16).Since every extension of W (cid:4) entails W , this is in particular true for the extension generated by (cid:2) · (cid:2)(cid:4). In otherwords, W (cid:4) ∪ cons((cid:2) · (cid:2)(cid:4)) |= W . As a result, W (cid:4) ∪ cons((cid:2) · (cid:2)(cid:4)) ≡ W ∪ cons((cid:2) · (cid:2)(cid:4)). Since (cid:2) · (cid:2)(cid:4) is a process of(cid:15)D, W (cid:4)(cid:16), we have that W (cid:4) ∪ cons((cid:2) · (cid:2)(cid:4)) ∪ just((cid:2) · (cid:2)(cid:4)) is consistent, which is therefore equivalent to the consistencyof W ∪ cons((cid:2) · (cid:2)(cid:4)) ∪ just((cid:2) · (cid:2)(cid:4)). Therefore, (cid:2) · (cid:2)(cid:4) is a successful process of (cid:15)D, W (cid:16). Since (cid:2) is by assumption amaximal successful process of (cid:15)D, W (cid:16), it must be the case that (cid:2)(cid:4) = [ ], that is, (cid:2) · (cid:2)(cid:4) = (cid:2). We have already provedthat W (cid:4) ∪ cons((cid:2) · (cid:2)(cid:4)) ≡ W ∪ cons((cid:2) · (cid:2)(cid:4)), that is, (cid:2) generates the same extension in W and in W (cid:4). (cid:2)Since constrained and Reiter default logics coincide on normal default theories, we have the following consequence.P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591345Corollary 5. If D is a set of normal and categorical defaults and W and W (cid:4) are two formulae such that W (cid:4) ⊆ W , theconditions W (cid:4) ≡mD W are equivalent in Reiter, justified, constrained, and rational defaultlogic.D W , and W (cid:4) ≡eD W , W (cid:4) ≡cAppendix D. Complexity of redundancy in default logicD.1. Complexity of clause redundancyIn this section, we analyze the complexity of checking the redundancy of a clause in a formula. Formally, thisis the problem of whether W \{γ } is equivalent to W according to ≡cD. By Corollary 4, these two forms ofequivalence are related, as W (cid:4) |=cD W (and also to W (cid:4) |=D W ), if W (cid:4) ⊆ W . As a result,checking whether W (cid:4) |=D W allows for telling whether the “first part of equivalence” between W (cid:4) and W holds, forboth kinds of equivalence. In other words, in order to check whether W (cid:4) and W are equivalent, if W (cid:4) ⊆ W we canD W (cid:4)first check whether W (cid:4) |=D W ; if this condition is true, we then proceed checking whether W |=cdepending on which equivalence is considered.D W is equivalent to W (cid:4) |=eD W (cid:4) or W |=eLemma 8 tells that W (cid:4) |=D W implies that all extensions of (cid:15)D, W (cid:4)(cid:16) are also extensions of (cid:15)D, W (cid:16). This conditiondoes not imply equivalence because (cid:15)D, W (cid:16) may contain some other extension, as in the default theory (cid:15)D, W (cid:16) below.D or ≡eW = {a}D = {d1, d2}where:d1 = a : bbd2 =: a ∧ ¬ba ∧ ¬bThe theory (cid:15)D, W (cid:16) has two extensions: applying either d1 or d2, the other is not applicable. The resulting extensionsare Cn({a, b}) and Cn({a, ¬b}). Let W (cid:4) = ∅. The only default that is applicable in W (cid:4) is d2, leading to the onlyextension Cn({a, ¬b}). This extension implies W . As a result, we have that W (cid:4) |=D W but W (cid:4) and W do not havethe same extensions and the same consequences. In particular, W has some extensions that W (cid:4) does not have. This isalways the case if W (cid:4) |=D W but W and W (cid:4) are not equivalent.In order to check equivalence of W (cid:4) and W with W (cid:4) ⊆ W , two conditions have to be checked:1. W (cid:4) |=D W ; and2. W |=cD W (cid:4) or W |=eD W (cid:4).An upper bound on the complexity of checking the redundancy of a clause is given by the following theorem.Theorem 18. Checking whether W (cid:4) ≡ein (cid:2)p2 for Reiter and justified default logic and in (cid:2)pD W for a set of defaults D and two formulae W and W (cid:4) such that W (cid:4) ⊆ W is3 for constrained and rational default logic.2 . The other condition to be checked is W |=eProof. Checking whether W (cid:4) |=D W is in (cid:2)pD W (cid:4). The converse of thiscondition is that there exists a formula E ⊆ W ∪ cons(D) such that Cn(E) is an extension of (cid:15)D, W (cid:16) but is not anextension of (cid:15)D, W (cid:4)(cid:16). Since checking whether a formula is a Reiter or justified default logic is in (cid:10)p[log n] [28,45],2the whole problem is in (cid:3)p2 . The problem of redundancy of a clause can be solved bysolving two problems in (cid:2)p2 . Its converse is therefore in (cid:2)p2 in parallel.The same line of proof does not work for constrained and rational default logic, where extension checking is2 -complete [28]; this makes clause redundancy to be in (cid:2)p(cid:3)p3 for these two semantics. (cid:2)Clause redundancy is (cid:2)p2 -hard for all considered semantics, as shown by the following theorem.1346P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Theorem 19. Checking whether W (cid:4) ≡e2 -hardeven if W = W (cid:4) ∪ {a} where a is a variable, W is consistent, and all defaults are categorical and normal, in Reiter,justified, constrained, and rational default logic.D W , where D is a set of defaults and W and W (cid:4) are two formulae, is (cid:2)pProof. The claim could be proved from the fact that entailment in default logic is (cid:2)p2 -hard even if the formula toentail is a single positive literal, and all defaults are categorical and normal [20,49]. If all defaults are categorical andnormal, Corollary 5 proves that W (cid:4) ≡mD W is equivalent to the two other forms of equivalence.We show a new reduction from ∀∃QBF. The formula ∀X∃Y . F is valid if and only if the new variable a is(cid:8)(cid:5)redundant in the theory below:: ¬xi¬xi: F ∧ aa: xixi∪(cid:5)(cid:6),(cid:6)(cid:9), {a}The background theory W = {a} is consistent. This theory has an extension for every possible truth assignmentover the variables X. For each such extension, the last default can be applied only if F is consistent with the givenassignment over X. As a result, if F is consistent with every truth assignment over the variables X, then a can beremoved from the background theory without changing the consequences of these extensions. Otherwise, the removalof a would cause some of these extensions not to entail a any more. (cid:2)The following theorem shows that the same problem is (cid:2)p3 -complete for the other two considered semantics (con-strained and rational).Theorem 20. Checking whether W ≡econstrained and rational default logic even if W = W (cid:4) ∪ {a}, where a is a variable.D W (cid:4), where D is a set of defaults and W and W (cid:4) two formulae, is (cid:2)p3 -hard forProof. We show a reduction from ∀∃∀QBF to the problem under consideration. Given a formula ∀X∃Y ∀Z.F , whereX = {x1, . . . , xn} and Y = {y1, . . . , yn}, the corresponding redundancy problem is defined by W = {a}, W (cid:4) = ∅, andD = D1 ∪ D2 ∪ D3 ∪ D4; these sets of defaults are defined as follows, where a, b, and f are new variables, andC = {c1, . . . , cn} and E = {e1, . . . , en} are sets of new variables.a : ¬b ∧ ¬xi¬xi(cid:6)(cid:7)(cid:7)(cid:7)(cid:7)1 (cid:2) i (cid:2) nD1 =(cid:6)(cid:5)(cid:5),a : ¬b ∧ xixia : ¬bC ∧ ¬d ∧ E ∧ fD2 =D3 =D4 =D5 =(cid:5)(cid:5)(cid:5)(cid:6)(cid:7)(cid:7)(cid:7)(cid:7)1 (cid:2) i (cid:2) n(cid:7)(cid:7)(cid:7)(cid:7)1 (cid:2) i (cid:2) n(cid:6),: b ∧ ¬xici ∧ (d ∨ ¬xi)C : b ∧ ¬yiei ∧ (f ∨ ¬yi): b ∧ xici ∧ (d ∨ xi)C : b ∧ yiei ∧ (f ∨ yi)C ∧ E ∧ (d ∨ f ∨ F ) : ba ∧ ¬d ∧ f(cid:6),The defaults in D1 ∪ D2 all have ¬b as a justification, while the defaults in D3 ∪ D4 ∪ D5 all have b. As a result,any successful process either contains only defaults from the first set or only defaults from the second set.Since the defaults of the first set all have a as a precondition, they are applicable from W , but they are not applicablefrom W (cid:4). The default in D5 is the only default having a as a consequence, and this default has b as a justification; as aresult, even if a could be derived from W (cid:4), this requires the application of the default in D5, which blocks the defaultsin D1 ∪ D2.We can therefore conclude that every selected process of (cid:15)D, W (cid:16) is made either of defaults of D1 ∪ D2 or ofdefaults of D3 ∪ D4 ∪ D5, while the selected processes of (cid:15)D, W (cid:4)(cid:16) are all made of defaults of the second set.We can also show that every selected process of W (cid:4) is also a selected process of W . Let (cid:2) be a selected processof W (cid:4). Since a never occurs negated, the consistency of W (cid:4) ∪ cons((cid:2)) ∪ just((cid:2)) entails that of W ∪ cons((cid:2)) ∪ just((cid:2)).:b∧x1c1∧(d∨x1) is applicable from W (cid:4))As for the condition of maximality, (cid:2) contains at least a default of D3 ∪D4 ∪D5 (e.g.,P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591347and therefore has b as a justification. As a result, the defaults in D1 ∪ D2 cannot be applied because they all have ¬bin their justifications. Therefore, (cid:2) is also maximal in W .The only way W and W (cid:4) may not have the same extensions is when W has an extension made of defaults ofD1 ∪ D2 such that W (cid:4) does not generate the same extension using the defaults of D3 ∪ D4 ∪ D5. The extensions of Wgenerated from the extensions of D1 ∪ D2 are in bijective correspondence with the interpretations over the variablesX: for every such interpretation ωX there is an extension that is equivalent to a ∧ C ∧ ¬d ∧ E ∧ f ∧ ωX, and viceversa. We now show how W (cid:4) could possibly generate such an extension using the defaults in D3 ∪ D4 ∪ D5.The only defaults that are applicable in W (cid:4) are those in D3. Since the set of all justifications has to be consistent,two defaults containing opposite values of xi cannot be applied. A maximal such process has consequences equivalentto C ∧ (d ∨ ωX) where ωX is an interpretation over the variables X. More precisely, for every interpretation there aresome such processes, and vice versa.Since the consequences of this process entail C, the defaults of D4 can now be applied. Again, what results is aprocess whose consequences also include E ∧ (f ∨ ωY ). In other words, for every pair of interpretations ωX and ωYover X and Y , respectively, there are some processes all having consequences equivalent to C ∧ (d ∨ ωX) ∧ E ∧ (f ∨ωY ), and vice versa.The default in D5 now could be applied from this process; more precisely, C ∧E is now entailed by the consequenceof this process; the default is applicable if and only if d ∨ f ∨ F is also entailed. Since d and f are new variables, thisis equivalent to ωX ∧ ωY |= F , that is, F is valid for any value of Z in the interpretation ωX ∪ ωY .The effect of the application of this default is that d is made false while a and f are made true. The resultingextension a ∧ ¬d ∧ f ∧ C ∧ (d ∨ ωX) ∧ E ∧ (f ∨ ωY ) is equivalent to a ∧ C ∧ ¬d ∧ E ∧ f ∧ ωX. This extension isalways generated by W from defaults in D1 ∪ D2, while W (cid:4) generates it only if the default in D5 can be applied.Now, assume that ∀X∃Y ∀Z.F is valid. This means that for every extension equivalent to a ∧ C ∧ ¬d ∧ E ∧ f ∧ ωXof W , there exists an interpretation ωY such that the process that has C ∧ (d ∨ ωX) ∧ E ∧ (f ∨ ωY ) as a consequencecan be extended by the application of the default of D5, thus generating the same extension.If instead ∀X∃Y ∀Z.F is not valid, there exists ωX such that, for every ωY , it holds ωX ∧ ωY (cid:14)|= F . In termsof extensions of the two considered theories, W still has the extension equivalent to a ∧ C ∧ ¬d ∧ E ∧ f ∧ ωX.However, the only processes of W (cid:4) that can generate the same extension are the ones that extend the process havingC ∧ (d ∨ ωX) ∧ E ∧ (f ∨ ωY ) for some ωY has consequence. By assumption, F is not entailed by ωX ∪ ωY ; therefore,the default of D5 cannot be applied in any such process. This means that the sets of extensions of W and W (cid:4) differ. (cid:2)We now consider the problem of redundancy of clauses when consequence-equivalence is used. The differencebetween the two kinds of equivalence is that two sets of extensions may be different but yet the disjunctions of theirelements are the same. The necessity of calculating the disjunction of all extensions intuitively explains why checkingredundancy for consequence-equivalence is harder than for faithful equivalence.Theorem 21. Checking whether W (cid:4) ≡cW (cid:4) ⊆ W for Reiter, justified, constrained, and rational default logic.D W , where D is a set of defaults and W and W (cid:4) are two formulae, is in (cid:2)p3 ifProof. W (cid:4) and W are consequence-equivalent if W (cid:4) |=D W and W |=c2 . We prove thatD W (cid:4) holds if and only if ∨ExtD(W ) (cid:14)|= ∨ExtD(W (cid:4)).the converse of the second condition is in (cid:3)pIn terms of models, we have ∪{Mod(E) | E ∈ ExtD(W )} (cid:14)⊆ ∪{Mod(E) | E ∈ ExtD(W (cid:4))}, that is, there exists M andE such that M ∈ Mod(E), E ∈ ExtD(W ), but M is not a model of any extension of W (cid:4). The whole condition cantherefore be expressed by the following formula.D W (cid:4). The first problem is in (cid:2)p3 . By definition, W (cid:14)|=c∃M∃E . M ∈ Mod(E) ∧ E ∈ ExtD(W ) ∧ (∀E(cid:4)(cid:4). E/∈ ExtD(W(cid:4)) ∨ M /∈ Mod(E(cid:4)))Since E(cid:4) /∈ ExtD(W (cid:4)) is in (cid:10)p2nal [28], the problem of checking W |=cas well for all four considered semantics. (cid:2)[log n] for Reiter [45] and justified default logic and in (cid:2)p2 for constrained and ratio-3 . Therefore, the problem of consequence-equivalence is in (cid:2)p3D W (cid:4) is in (cid:2)pWe show that the problem is hard for the same class.1348P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359D W , where D is a set of default and W and W (cid:4) two formulae,3 -hard even if W = W (cid:4) ∪ {a} where a is a variable for Reiter justified default, constrained and rational defaultTheorem 22. The problem of checking whether W (cid:4) ≡cis (cid:2)plogics.Proof. We prove the claim by reduction from QBF. We reduce a formula ∃X∀Y ∃Z.F into the problem of checkingD W (cid:4), where W (cid:4) = ∅, W = {a}, and D = D1 ∪ D2 ∪ D3 ∪ D4 ∪ D5 ∪ D6. Let X = {x1, . . . , xn} andwhether W (cid:14)≡cY = {y1, . . . , yn}. We show each Di at time. First, we generate a complete assignment over the variables X using thefollowing defaults, where H = {h1, . . . , hn} are new variables.(cid:6)(cid:5)D1 =: xixi ∧ hi,: ¬xi¬xi ∧ hiSince these defaults have no preconditions, they can be applied regardless of whether W or W (cid:4) is the backgroundtheory. They generate a process for any truth assignment ωX over the variables in X. The variables hi are all true onlywhen all variables xi have been set to a value.The processes of W and W (cid:4) are so far the same. Once all hi are true, we can apply the defaults of D2 ={d1, d2, d3, d4}, which are the ones used in Counterexample 10 to show two theories that have the same consequencesbut different extensions (a, b, and c are new variables):D2 = {d1, d2, d3, d4}d1 = h1 ∧ · · · ∧ hn : ¬b ∧ ca ∧ cd2 = h1 ∧ · · · ∧ hn : ¬b ∧ ¬cd3 = h1 ∧ · · · ∧ hn ∧ a : b ∧ cd4 = h1 ∧ · · · ∧ hn ∧ a ∧ (b ∨ c) : b ∧ ¬ca ∧ ¬cb ∨ cbSince these defaults all have ∧H as a precondition, they can only be applied once a truth assignment over X hasbeen generated by the previous defaults. They act as in the proof of Counterexample 10. Only [d1, d3] and [d2] areprocesses of W (cid:4); their consequences are a ∧ c and a ∧ ¬c. The theory W has the same processes, but also [d3, d1] and[d3, d4], which generate the extensions a ∧ c and a ∧ b, respectively. While the first is also an extension of W (cid:4), thesecond is not. The disjunction of all extensions is equivalent to a ∧ H for both W and W (cid:4).The idea is as follows: from H ∧ a ∧ b ∧ ωX, which is obtained from W but not from W (cid:4), we always generate anextension equivalent to H ∧ a ∧ b ∧ ωX ∧ d ∧ (cid:11)Y , where (cid:11)Y is the assignment of false to all variables of Y ; from thetwo other partial extensions H ∧ a ∧ ¬c ∧ ωX and H ∧ a ∧ c ∧ ωX we instead generate an arbitrary assignment ωY ,which then has H ∧ a ∧ b ∧ ωX ∧ d ∧ (cid:11)Y as a model only if ωX ∧ ωY ∧ F is satisfiable.This way, if there exists an assignment ωX such that for all ωY the formula ωX ∧ ωY ∧ F is satisfiable, then thereis no extension of W (cid:4) having the model H ∪ {a, b, d} ∪ ωX ∪ (cid:11)Y . Vice versa, if there exists even a single ωY suchthat ωX ∧ ωY ∧ F is unsatisfiable, an extension equivalent to H ∧ a ∧ c ∧ ωX ∧ . . . for W (cid:4) will be generated, and thisextension has the model H ∪ {a, b} ∪ ωX ∪ {d} ∪ (cid:11)Y .The required defaults are the following ones. First, we generate the considered model from the process that gener-ated H ∪ {a, b} ∪ ωX by the following default, where d is a new variable:(cid:6)(cid:5)D3 =b : (cid:17)d ∧ ¬y1 ∧ · · · ∧ ¬ynFrom H ∧ a ∧ ¬c ∧ ωX and H ∧ a ∧ c ∧ ωX we generate an arbitrary truth assignment over Y . Since the modelH ∪ {a, b, d} ∪ ωX ∪ (cid:11)Y assigns false to all variables yi , we cannot simply add yi as a conclusion. A similar effect canbe achieved by the following defaults, where L = {l1, . . . , ln} are new variables.(cid:5)D4 =D5 =(cid:5)¬c : ¬d ∧ yid ∨ (yi ∧ li)c : ¬d ∧ yid ∨ (yi ∧ li),,¬c : ¬d ∧ ¬yid ∨ (¬yi ∧ li)c : ¬d ∧ ¬yid ∨ (¬yi ∧ li)(cid:6)(cid:7)(cid:7)(cid:7)(cid:7) 1 (cid:2) i (cid:2) n(cid:7)(cid:6)(cid:7)(cid:7)(cid:7) 1 (cid:2) i (cid:2) nP. Liberatore / Artificial Intelligence 172 (2008) 1317–13591349The two defaults associated with yi and ¬yi cannot be applied both at the same time, as the consequence of onecontains the negation of the justification of the other one. Since the following defaults can only be applied whend ∨ (l1 ∧ · · · ∧ ln) has been derived, the current extensions before their application are equivalent to H ∧ a ∧ ¬c ∧ωX ∧ (d ∨ (ωY ∧ L)) and H ∧ a ∧ c ∧ ωX ∧ (d ∨ (ωY ∧ L)), where ωY is an arbitrary truth assignment over Y .These extensions have all models of a ∧ b ∧ ωX ∧ d ∧ (cid:11)Y . The following default removes these models from theextensions if and only if ωX ∧ ωY ∧ F is satisfiable.d ∨ (l1 ∧ · · · ∧ ln) : ¬d ∧ F¬dD6 =(cid:6)(cid:5)This default is not applicable from H ∧ a ∧ b ∧ ωX ∧ d ∧ (cid:11)Y because its justification contains ¬d. It is applicable fromthe other processes but only after the ith default of D4 or D5 has been applied for each i and only if the consequencesof the applied defaults of D4 or D5 are consistent with ¬d ∧ F . In other words, (d ∨ (ωY ∧ L)) ∧ ¬d ∧ F must beconsistent, which is equivalent to the consistency of ωY ∧ F because d and L are not mentioned in ωY and F .We can therefore conclude that:1. for each truth assignment ωX, three “partial extensions” are generated from W : H ∧ a ∧ ¬c ∧ ωX, H ∧ a ∧ c ∧ ωX,and H ∧ a ∧ b ∧ ωX; the first two are also generated by W (cid:4);2. from H ∧ a ∧ b ∧ ωX, an extension equivalent to H ∧ a ∧ b ∧ ωX ∧ d ∧ (cid:11)Y is generated; if the models of thisextension are not models of an extension of W (cid:4), equivalence between W and W (cid:4) does not hold;3. from H ∧ a ∧ [¬]c ∧ ωX we generate H ∧ a ∧ [¬]c ∧ ωX ∧ (d ∨ (ωY ∧ L)) for each truth assignment ωY on thevariables Y ; to this formula, ¬d is added if and only if F is consistent with ωX and ωY .As a result, the models of H ∧ a ∧ b ∧ ωX ∧ d ∧ (cid:11)Y are not models of an extension of W (cid:4) if and only if F ∧ ωXis satisfiable for every truth assignment over Y . Since non-equivalence has to be checked for every ωX, we have thatnon-equivalence holds if and only if ∃X∀Y ∃Z . F .A similar proof holds for constrained or rational default logics by replacing the default theory of Counterexample 10with that of Counterexample 11. The proof can also slightly simplified in this case, as the defaults of D4 and D5 canbe modified with justifications yi or ¬yi and consequence d ∨ li . (cid:2)Since we have proved that the problem of clause redundancy w.r.t. consequence-equivalence is both in (cid:2)p3 andhard for the same class, we have the following result.D W , where D is a set of default and W and W (cid:4) two formulae, is3 -complete if W (cid:4) ⊆ W ; hardness holds even if W = W (cid:4) ∪ {a} where a is a variable. This holds for Reiter, justified,Corollary 6. The problem of checking whether W (cid:4) ≡c(cid:2)pconstrained, and rational default logic.D.2. Complexity of formula redundancyThe next problem to analyze is whether a formula is redundant, for a fixed set of defaults. The complexity offormula redundancy w.r.t. faithful and consequence-equivalence is in (cid:3)p3 and (cid:3)p4 , respectively.Theorem 23. The problem of formula redundancy for faithful and consequence-equivalence is in (cid:3)ptively, for Reiter, justified, constrained, and rational default logic.3 and (cid:3)p4 , respec-Proof. Both problems can be expressed as the existence of a subset W (cid:4) ⊂ W such that W (cid:4) is equivalent to W . Sinceverifying equivalence is in (cid:2)p3 , respectively, for faithful and consequence-equivalence, the claim follows. (cid:2)2 and (cid:2)pRegarding hardness, we first show a theorem characterizing the complexity of the problem for the case of faithfulequivalence. We then show a more general technique allowing a hardness result to be raised one level in the polynomialhierarchy.Theorem 24. The problem of formula redundancy based on faithful equivalence is (cid:3)pconsistent theories, for Reiter, justified, constrained, and rational default logic.3 -hard, and remains hard for1350P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Proof. We reduce the problem of validity of ∃X∀Y ∃Z.F , where X = {x1, . . . , xn}, Y = {y1, . . . , yn}, and Z ={z1, . . . , zn} to the problem of redundancy of a formula. The default theory corresponding to the formula ∃X∀Y ∃Z.Fis the theory (cid:15)D, W (cid:16) defined as follows, where a, {s1, . . . , sn}, {r1, . . . , rn}, {h1, . . . , hn}, and {p1, . . . , pn} are newvariables.W = {si | 1 (cid:2) i (cid:2) n} ∪ {ri | 1 (cid:2) i (cid:2) n}D = D1 ∪ D2 ∪ D3 ∪ D4 ∪ D5 ∪ D6(cid:7)(cid:7)(cid:7)(cid:7)si ∧ ri : ¬rjaD1 =(cid:5)(cid:6)1 (cid:2) i (cid:2) n1 (cid:2) j (cid:2) n,(cid:6)(cid:6)si ∧ ri : ¬sja: ¬si ∧ ¬ria: yiyi ∧ hi: xipi ∧ xixi ∧ ri : (cid:17)∧W,(cid:7)(cid:7)(cid:7)(cid:7) 1 (cid:2) i (cid:2) n(cid:7)(cid:7)(cid:7)(cid:7) 1 (cid:2) i (cid:2) n(cid:7)(cid:7)(cid:7)(cid:7) 1 (cid:2) i (cid:2) n(cid:7)(cid:7)(cid:7)(cid:7) 1 (cid:2) i (cid:2) n(cid:6): ¬yi¬yi ∧ hi: ¬xipi ∧ ¬xi¬xi ∧ si : (cid:17)∧Wp1 ∧ · · · ∧ pn ∧ h1 ∧ · · · ∧ hn : F∧W(cid:6),,(cid:6)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)D2 =D3 =D4 =D5 =D6 =The background theory W is consistent. The defaults of D1 and D2 cannot be applied from it. The defaultsof D3 and D4 generate an extension for every possible truth evaluation over X ∪ Y ; this extension also containsall variables hi and pi . Whether or not the last default is applicable, its consequence is equivalent to the backgroundtheory.Let W (cid:4) ⊂ W . If there is an index i such that both si and ri are in W (cid:4), one of the defaults of D1 is applicable,generating a. Therefore, W (cid:4) is not equivalent to W . If there exists an index i such that neither si nor ri is in W (cid:4), theith default of D2 is applicable, still generating a.In order to check for redundancy, we therefore only have to consider subsets W (cid:4) ⊂ W such that, for every 1 (cid:2) i (cid:2) n,either si ∈ W (cid:4) or ri ∈ W (cid:4) but not both. Let ωX be the assignment on the variables X such that xi is assigned to trueif si ∈ W (cid:4) and to false if ri ∈ W (cid:4). The defaults of D3 and D4 generate an arbitrary truth evaluation of the vari-ables X ∪ Y . If the assignment on X is not equal to ωX, the formula ∧W is generated, thus leading to an extensionthat is also an extension of W . As a result, all extensions of W (cid:4) that do not match the value ωX are also exten-sions of W . If the same holds also for the extensions for which the values of X match ωX, then W (cid:4) is equivalentto W .For a given W (cid:4) we consider the extensions consistent with ωX. There is exactly one such extension for each possibletruth evaluation over Y . If the default of D6 can be applied, it generates ∧W , thus making W (cid:4) equivalent to W . Inturn, the default of D6 can be applied for all truth evaluation over Y if and only if for all such truth evaluation, Fis satisfiable. As a result, W (cid:4) is equivalent to W if and only if, for all possible truth evaluations over Y , the formulaF is satisfiable. Since there exists a relevant W (cid:4) for each truth evaluation over X, the formula W is redundant if andonly if there exists a truth evaluation over X such that, for all possible truth evaluations over Y , the formula F issatisfiable. (cid:2)In order to prove the (cid:3)p4 -hardness of the problem of formula redundancy under consequence-equivalence, weshould provide a reduction from ∃∀∃∀QBF validity into this problem. A simpler proof can however be given, basedon the following consideration: checking clause redundancy has been proved (cid:2)p3 -hard using reductionsfrom QBFs that results in default theories having W = {a} as the background theory. As a result, these reductions alsoprove that formula redundancy is (cid:2)p3 -hard. In other words, we can reduce the validity of a ∀∃QBF or a∀∃∀QBF into the problems of formula redundancy. What we show is that, if such reductions satisfy some assumptions,we can obtain new reductions from QBFs having an additional existential quantifier in the front. The assumptions arethat the default theory resulting from the reduction is such that:2 -hard or (cid:2)p2 -hard or (cid:2)pP. Liberatore / Artificial Intelligence 172 (2008) 1317–135913511. the background theory that results from the reduction is classically irredundant;2. the matrix of the QBF occurs only in the justification of a single default and does not affect the rest of the defaulttheory.The reductions used for proving the hardness of clause redundancy satisfy both assumptions. In particular,∀X∃Y ∀Z.F is valid if and only if the background theory of the following theory is consequence-redundant, where D,α, β, γ , do not depend on F but only on the quantifiers of the QBF and W is classically irredundant.(cid:5)(cid:8)D ∪α : β ∧ Fγ(cid:6)(cid:9), WThe fact that the matrix of the QBF is copied “verbatim” in the default theory is exploited as follows: if ωw is atruth evaluation over the variable w, then ∀X∃Y ∀Z.F |ωw is valid if and only if the background theory of (cid:15)D ∪{ α:β∧F ∧ωw}, W (cid:16) is redundant. This default theory can be modified in such a way that the subsets of the backgroundγtheory are in correspondence with the truth evaluations over ωw. This way, the resulting theory is redundant if and onlyif ∃w∀X∃Y ∀Z . F is valid. The resulting default theory still satisfies the two assumptions above on the backgroundtheory and on the use of the matrix of the QBF; therefore, this procedure can be iterated to obtain a reduction from∃∀∃∀QBF validity into the problem of formula redundancy under consequence-equivalence. A similar technique canbe used for faithful equivalence.The details of this technique are in the following three lemmas. The first one shows that a literal can be movedfrom the justification of a default to the background theory and vice versa, under certain conditions.Lemma 10. Let W be a propositional formula and D ∪ {d} a set of defaults. Assume that l is a literal whose variabledo not occur in W , D, prec(d), and cons(d) (in other words, it may only occur in just(d)). Then, the selected processesof the first of following theory can be converted into a selected process of the second by replacing d with d (cid:4), and viceversa. This holds for Reiter, justified, constrained, and rational default logic.(cid:13)(cid:12)D ∪ {d}, W ∪ {l}(cid:12)(cid:4)}, WD ∪ {d(cid:13)whered(cid:4) = prec(d) : just(d) ∧ lcons(d)Proof. The variable in l only occurs in the background theory W ∪ {l} and in the justification of d and d (cid:4). Theconditions for a process of the first theory being selected either involve (W ∪ {l}) ∪ just(d) or W ∪ {l} with otherformulae not containing l, where W does not contain the variable of l. As a result, moving l from the backgroundtheory to the justification of d or vice versa does not affect these conditions.Note that the processes are the same, but the extensions are different in that l is in all extensions of the first theorybut in none of the second. (cid:2)The second lemma is an obvious consequence of the above: under the same conditions, moving a literal from thejustification of a default to the background theory or vice versa does not change the redundancy of a theory.Lemma 11. Let W and W (cid:4) be two propositional formulae such that W (cid:4) ⊆ W , D ∪ {d} a set of defaults, and l a literalwhose variable do not occur in W , D, prec(d), and cons(d) (that is, it may only occur in just(d)). It holds W (cid:4) ≡eD(cid:4) Wif and only if W (cid:4) ∪ {l} ≡eD(cid:4)(cid:4) W ∪ {l}, where D(cid:4) and D(cid:4)(cid:4) are as follows. This holds for Reiter, justified, constrained, andrational default logic.(cid:5)(cid:4) = D ∪D(cid:6)prec(d) : just(d) ∧ lcons(d)(cid:4)(cid:4) = D ∪ {d}D1352P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Proof. Obvious consequence of the lemma above: (cid:15)D(cid:4), W (cid:4)(cid:16) and (cid:15)D(cid:4), W (cid:16) have the same processes of (cid:15)D(cid:4)(cid:4), W (cid:4) ∪ {l}(cid:16)and (cid:15)D(cid:4)(cid:4), W ∪ {l}(cid:16), respectively. (cid:2)A consequence of this lemma is that W is redundant according to D(cid:4) if and only if W ∪ {l} is redundant accordingto D(cid:4)(cid:4). Indeed, l is not mentioned in the consequences of the defaults; therefore, a subset of W ∪ {l} can only beequivalent to W ∪ {l} if it contains l. The lemma is formulated in the more general way because it is necessary forproving the following lemma. The same property can be proved using consequence-equivalence because moving lfrom the justification of the default to the background theory has the only effect of adding l to all extensions.Lemma 12. If D is a set of defaults, w a variable, and W a classically irredundant formula, then there exists W (cid:4) ⊂ Wsuch that W (cid:4) ∪ {w} ≡ep ∧ α : βγD W ∪ {¬w} if and only if the following theory is redundant:D W ∪ {w} or W (cid:4) ∪ {¬w} ≡e(cid:6)(cid:8)Dw ∪α : βγ, W ∪ {w∈ D, w−}(cid:7)(cid:7)(cid:7)(cid:7)(cid:5)+(cid:9)where:(cid:5)Dw =w+ : w ∧ pw ∧ pand w+, w−, and p are new variables. This holds for Reiter, justified, constrained, and rational default logic.w+ ∧ w− : ¬W¬p: ¬w+ ∧ ¬w−¬pw− : ¬w ∧ p¬w ∧ p,,,(cid:6)Proof. Since w+ and w− are new variables not contained in W and W is classically irredundant, W ∪ {w+, w−} isclassically irredundant as well.We now consider the processes that can be generated from W ∪{w+, w−} and from its subsets. From W ∪{w+, w−}we can apply only one of the last two defaults of Dw, generating either w ∧ p or ¬w ∧ p. From this point on, we haveexactly the same processes of (cid:15)D, W ∪ {w}(cid:16) and (cid:15)D, W ∪ {¬w}(cid:16), the generated extensions only differing because ofthe addition of p, w+, and w−.The proper subsets of W ∪ {w+, w−} are W (cid:4) ∪ {w+, w−} where W (cid:4) ⊂ W , W (cid:4) ∪ {w+}, W (cid:4) ∪ {w−}, and W (cid:4), whereW (cid:4) ⊆ W . The fourth subset W (cid:4) is not equivalent to W because the second default of Dw allows the derivation of¬p, which is not derivable from W . If W (cid:4) ⊂ W , since W is (classically) irredundant, W (cid:4) ∪ {w+, w−} allows for theapplication of the first default of Dw, deriving ¬p; therefore, this subset is not equivalent to the background theory.The only two other subsets to consider are W (cid:4) ∪ {w+} and W (cid:4) ∪ {w−}. In the first subset, only w ∧ p can begenerated. In the second subset, only ¬w ∧ p can be generated. From this point on, we have exactly the same processesof W (cid:4) ∪ {w} and W (cid:4) ∪ {¬w} according to D. The generated extensions are the same but for the addition of p. (cid:2)These three lemmas together prove that a reduction from QBF to formula redundancy can be “raised” by theaddition of an existential quantifier in the front of the QBF. Formally, this is proved by assuming the existence of areduction from a QBF to the problem of irredundancy of a default theory in a given form, and shown the existence ofa reduction from a QBF with an additional existential quantifier in the front to the problem of redundancy of a defaulttheory in the same form. We formally define this form as follows.Definition 25 (Verbatim reduction). A reduction from the validity of a class of QBFs to the problem of formularedundancy of a default theory is a verbatim reduction if each formula Q.E, where Q is a sequence of quantifiers, isreduced to a default theory (cid:15)D, W (cid:16) whereD = D(cid:4) ∪(cid:5)(cid:6)α : β ∧ EγW is classically irredundant and W , D(cid:4), α, β, and γ do not depend on E but only on Q.This definition is instrumental to proving that a reduction from QBF to formula redundancy can be added anexistential quantifier.Lemma 13. If there exists a verbatim polynomial reduction from QBF formulae whose sequence of quantifiers is in agiven set S to the problem of formula redundancy of a default theory, then there exists a verbatim polynomial reductionP. Liberatore / Artificial Intelligence 172 (2008) 1317–13591353from QBF formulae whose sequence of quantifiers is in the class {∃T | T ∈ S} to the problem of formula redundancyof a default theory. This holds for Reiter, justified, constrained, and rational default logic.Proof. In order to show the existence of the reduction, let ∃wQ.F be an arbitrary QBF formula whose sequence ofquantifiers is in {∃T | T ∈ S}.By assumption, both Q.F |w=true and Q.F |w=false can be reduced to the problem of formula redundancy by a ver-batim reduction. These two QBF formulae only differ on their matrices, which are F |w=true and F |w=false. Therefore,the resulting default theories are:(cid:6)(cid:5)(cid:9)(cid:8)D ∪(cid:8)D ∪(cid:5)α : β ∧ F |w=trueγα : β ∧ F |w=falseγ, W(cid:6)(cid:9), WSince w does not occur anywhere in these defaults theories, we can replace F |w=true and F |w=false with F ∧ w andF ∧ ¬w, respectively. Indeed, justifications are only checked for consistency, and for any formula R not containing w,the consistency of R ∪ F |w=true is the same as the consistency of R ∪ (F ∧ w), and the consistency of R ∪ F |w=falseis the same as the consistency of R ∪ (F ∧ ¬w).(cid:5)(cid:5)(cid:8)D ∪(cid:8)D ∪(cid:6)(cid:9)α : β ∧ F ∧ wγα : β ∧ F ∧ ¬wγ, W(cid:6)(cid:9), WBy Lemma 11, formula redundancy of these two theories corresponds to formula redundancy of the same theorieswith w or ¬w moved to the background theory. More precisely, the redundancy of the first theory correspond to theexistence of a subset W (cid:4) ⊂ W such that W (cid:4) ∪ {w} is equivalent to W ∪ {w} according to the defaults D ∪ { α:β∧F}.The same holds for the second theory.α : β ∧ Fγα : β ∧ Fγ(cid:8)D ∪(cid:8)D ∪, W ∪ {¬w}, W ∪ {w}(cid:6)(cid:6)(cid:5)(cid:5)(cid:9)(cid:9)γBy Lemma 12, since W is classically irredundant, we have that either the first or the second of the two theories areredundant if and only if the following theory is redundant:(cid:5)(cid:8)Dw ∪p ∧ α(cid:4) : β(cid:4)γ (cid:4)α(cid:4) : β(cid:4)γ (cid:4)∈ D ∪α : β ∧ Fγ(cid:7)(cid:7)(cid:7)(cid:7)(cid:5)(cid:6)(cid:6)(cid:9), W ∪ {w+−}, wwhere Dw is defined in the statement of Lemma 12. As a result, this formula is redundant if and only if eitherQ.F |w=true is valid or Q.F |w=false is valid, that is, ∃wQ.F is valid.In order to complete the lemma, we have to show that this reduction from an arbitrary QBF ∃wQ.F to the abovedefault theory is a verbatim reduction. Since W is classically irredundant by assumption and w+ and w− are newvariables, W ∪ {w+, w−} is classically irredundant as well. In the above theory, the matrix F of the QBF only affectsthe justification of the default p∧α:β∧F. Therefore, the reduction is a verbatim reduction. (cid:2)γThe above lemmas are also valid for consequence-equivalence. In both cases, we have that the hardness of formularedundancy is one level higher in the polynomial hierarchy than clause redundancy.Theorem 25. Formula redundancy is (cid:3)pReiter, justified, constrained, and rational default logic.3 -hard for faithful equivalence and (cid:3)p4 -hard for consequence-equivalence inProof. The reduction shown after Theorem 19 and the reduction used in Theorem 22 are reductions from ∀∃QBFand ∀∃∀QBF, respectively, into the problem of formula redundancy. These reductions produce a default theory inwhich the background theory contains a single non-tautological clause, and is therefore classically irredundant, and1354P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359the matrix of the QBF only occurs in the justification of a single default. These are the conditions of Lemma 13. Asa result, one can reduce an ∃∀∃QBF or an ∃∀∃∀QBF to the problem of formula redundancy by iteratively applyingthe modification of Lemma 13 for all variables of the first existential quantifier. These reductions are polynomialbecause the repeated application of Lemma 13 does not increase the size of the involved default theories more thanpolynomially: every application adds two literals to background theory, four new defaults (each of size linear in thesize of the background theory), and a new symbol in each default. (cid:2)D.3. Redundancy of defaultsThe following lemma is the version of Theorem 11 in the case of default redundancy rather than clause redundancy.It proves that some defaults can be made irredundant while not changing the redundancy status of the others. Suchresults are generally useful to build default theories having some specific properties w.r.t. redundancy. In particular,the following lemma will be later used in Theorem 14 to prove that the problems of redundancy of clauses can bereduced to the corresponding problems of redundancy of defaults.Lemma 5 (proof). For every default theory (cid:15)D, W (cid:16) and every set of defaults DI ⊆ D, let p and q two new variablesand {vi} be a set of new variables in bijective correspondence with the defaults of DI , and let D1, D2, D3 be definedas follows:D1 = {d+, d−}where:d+ =d− =D2 =D3 =: p ∧ qp ∧ q: ¬p ∧ q¬p ∧ q(cid:5)q ∧ (¬p ∨ α) : ¬p ∨ β(p ∨ vi) ∧ (¬p ∨ γ )α : βq ∧ p ∧ α : βγγ(cid:7)(cid:7)(cid:7)(cid:7)(cid:5)∈ D\DI(cid:7)(cid:7)(cid:7)(cid:7)α : βγ∈ DI , vi is the variable corresponding to(cid:6)(cid:6)α : βγif (cid:15)D, W (cid:16) has extensions and W is consistent, in Reiter, justified, constrained, and rational default logics it holds that:1. the processes of (cid:15)D1 ∪ D2 ∪ D3, W (cid:16) are (modulo the transformation of the defaults) the same as of (cid:15)D, W (cid:16) withd+ added to the front and a number of processes composed of d− and a sequence containing all defaults of D2;2. the extensions of (cid:15)D1 ∪ D2 ∪ D3, W (cid:16) are the same as of (cid:15)D, W (cid:16) with {p, q} added plus the single extension{¬p, q} ∪ {vi};3. a subset of D1 ∪ D2 ∪ D3 is faithfully equivalent to it if and only if it contains D1 ∪ D2 and the set of originaldefaults corresponding to those of D2 ∪ D3 is faithfully equivalent to D.Proof. Since all defaults of D2 ∪ D3 have q as a precondition, they are not applicable from W . The only defaults thatare applicable to W are therefore d+ and d−, which are mutually exclusive.Let us consider the processes with d− in first position. Since d− generates ¬p, the defaults of D3 are not applica-ble. We prove that [d−] · (cid:2)2 is a successful process, where (cid:2)2 is an arbitrary sequence containing all defaults of D2.The preconditions of all defaults of D2 are entailed by q ∧ ¬p. The union of the justifications and consequences ofall defaults of this process is {¬p, q} ∪ {¬p ∨ β, p ∨ vi, ¬p ∨ γ }, which is equivalent to {¬p, q} ∪ {vi}. This set isconsistent with the background theory, which does not contain the variables p, q, and vi .If a subset of D1 ∪ D2 ∪ D3 does not contain d−, the literal ¬q cannot derived because no other default has ¬qas a conclusion. If a subset of D1 ∪ D2 ∪ D3 does not contain a default of D2, the corresponding variable vi is not inthis extension. As a result, every subset of D1 ∪ D2 ∪ D3 that is equivalent to it contains {d−} ∪ D2.Let us now consider the processes with d+ in first position. Such a process cannot contain d−. Since p and q aregenerated, the defaults of D2 ∪ D3 can be simplified to α:βγ by removing all clauses containing p or q and all literals¬p and ¬q from the clauses containing them. As a result, the processes having d+ in first position correspond to theprocesses of the original theory.P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591355Provided that the original theory has extensions, every subset of D1 ∪ D2 ∪ D3 not containing d+ lacks theseextensions. The defaults of D3 are redundant if and only if they are redundant in the original theory. More precisely, asubset D(cid:4) ⊂ D1 ∪ D2 ∪ D3 is equivalent to D1 ∪ D2 ∪ D3 if and only if D(cid:4) contains D1 ∪ D2, and the set of originaldefaults D(cid:4)(cid:4) corresponding to the defaults of D(cid:4) ∩ (D2 ∪ D3) is equivalent to D. (cid:2)The following counterexample shows that Reiter and rational default logic do not have the unitary redundancyproperty w.r.t. redundancy of defaults.Counterexample 7 (proof). There exists a set of defaults D such that, according to Reiter and rational default logic:1. for every d ∈ D, the theory (cid:15)D\{d}, ∅(cid:16) has extensions and D\{d} (cid:14)≡e2. there exists D(cid:4) ⊂ D such that D(cid:4) ≡e∅ D;∅ D.Proof. We use a pair of defaults that lead to failure is they are together in the same process. Removing one of themfrom the default theory leads to a new extension, while removing both of them lead to the original set of extensions.The following defaults are a realization of this idea.D = {d1, d2, d3, d4}where:d1 =d2 =d3 =d4 =: bb ∧ c: bb ∧ ¬c: ¬b ∧ c¬b ∧ c: ¬b ∧ ¬c¬b ∧ ¬cThe extensions of some (cid:15)D(cid:4), ∅(cid:16), with D(cid:4) ⊆ D, are as follows:D(cid:4) = D we can either apply both d1 and d2 (leading to a failure) or either d3 or d4, but not both; the extensions ofthis theory therefore are Cn({¬b, c}) and Cn({¬b, ¬c});D(cid:4) = {d1, d3, d4} one among d1, d3, and d4 can be applied, but not any two of them at the same time; that results inthree processes, generating the extensions Cn({b, c}), Cn({¬b, c}), and Cn({¬b, ¬c});D(cid:4) = {d2, d3, d4} similar to the previous case:the generated extensions are Cn({b, ¬c}), Cn({¬b, c}), andD(cid:4) = {d1, d2, d3} either d1, d2 or d3 can be applied; the first two lead to failure; the only extension of this theory isCn({¬b, ¬c});therefore Cn({¬b, c});D(cid:4) = {d1, d2, d4} similar to the case above: the only extension is Cn({¬b, ¬c});D(cid:4) = {d3, d4} both d3 and d4 can be applied, but not at the same time; as a result, the generated extensions areCn({¬b, c}) and Cn({¬b, ¬c}).As a result, (cid:15)D\{d}, ∅(cid:16) has extensions for every d ∈ D, but its set of extensions is different from that of (cid:15)D, ∅(cid:16). Onthe other hand, (cid:15)D, ∅(cid:16) and (cid:15){d3, d4}, ∅(cid:16) have the same extensions. (cid:2)The same result holds for constrained default logic.Counterexample 8 (proof). There exists a set of defaults D such that, according to constrained default logic:1. for every d ∈ D, it holds D\{d} (cid:14)≡e2. there exists D(cid:4) ⊂ D such that D(cid:4) ≡e∅ D;∅ D.1356P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359Proof. The defaults are the following ones:D = {d1, d2, d3}where:d1 =d2 =d3 =: xa: xb: ¬x ∧ ¬ya ∧ bThe theory (cid:15)D, ∅(cid:16) has two selected processes (modulo permutation of defaults): [d1, d2] and [d3], both generatingthe extension Cn({a, b}). Removing either d1 or d2 causes the first process to become [d1] or [d2], thus creating a newextension Cn({a}) or Cn({b}), respectively. On the other hand, removing both d1 and d2 makes the only remainingprocess to be [d3], which generates the same single extension Cn({a, b}) of the original theory. The default d3 is notredundant, but can be made so by applying the transformation of Lemma 5. (cid:2)Justified default logic has the unitary redundancy property w.r.t. default redundancy. The proof requires two lem-mas. The first one is about extendibility of processes when new defaults are added to a theory.Lemma 14. In justified default logic, if (cid:2) is a selected process of a default theory (cid:15)D(cid:4), W (cid:16) and D(cid:4) ⊆ D, then thereexists a sequence (cid:2)(cid:4) of defaults of D\D(cid:4) such that (cid:2) · (cid:2)(cid:4) is a selected process of (cid:15)D, W (cid:16).Proof. Let (cid:2) be a selected process of (cid:15)D(cid:4), W (cid:16). By definition, it holds W ∪ cons((cid:2)[d]) |= prec(d) and W ∪cons((cid:2))(cid:17)just(d) for every d ∈ (cid:2). As a result, (cid:2) is a also a successful process of (cid:15)D, W (cid:16). Therefore, there exists(cid:2)(cid:4) such that (cid:2) · (cid:2)(cid:4) is a selected process of (cid:15)D, W (cid:16) because justified default logic is failsafe [29]. If (cid:2)(cid:4) containsdefaults of D(cid:4), then (cid:2) would not be a closed process of (cid:15)D(cid:4), W (cid:16). (cid:2)In order for proving the second lemma, we need an intermediate result.Lemma 15. In justified default logic, the selected processes of a default theory (cid:15)D, W (cid:16) generating the extension Eare composed of exactly the defaults of the following set:GEN(E, D) =(cid:10)(cid:11)d ∈ D | E |= prec(d) and E(cid:17)just(d) ∪ cons(d)Proof. Assume that (cid:2) is a selected process generating E that does not contain a default d ∈ GEN(E, D).Since E |= prec(d), E(cid:17)just(d) ∪ cons(d), and E = W ∪ cons((cid:2)), we have that W ∪ cons((cid:2)) |= prec(d) andW ∪ cons((cid:2))(cid:17)just(d) ∪ cons(d). As a result, (cid:2) · [d] is a successful process, contradicting the assumption.Let (cid:2) be a selected process containing a default d not in GEN(E, D). By definition, either E (cid:14)|= prec(d) orE⊥just(d) ∪ cons(d). The first condition implies that W ∪ cons((cid:2)[d]) (cid:14)|= d whichever the position of d in (cid:2) is.The second condition implies W ∪ cons((cid:2))⊥just(d) ∪ cons(d): the process (cid:2) is not successful contrary to the as-sumption. (cid:2)The next lemma relates the processes of two theories when they are assumed to have the same extension. In thislemma and in the following theorem, when a process is used in a place where a set of defaults is expected, it meansthe set of defaults of the process. For example, if (cid:2) is a sequence of defaults and D(cid:4) a set of defaults, (cid:2) ∩ D(cid:4) is theset of defaults that are both in (cid:2) and in D.Lemma 16. In justified default logic, if W is a formula and D and D(cid:4) are two sets of default such that D(cid:4) ⊆ D,D(cid:4) ≡eW D, and (cid:2) is a selected process of (cid:15)D, W (cid:16), then there exists a selected process of (cid:15)D(cid:4), W (cid:16) made exactly of thedefaults of (cid:2) ∩ D(cid:4) and generating the same extension as generated by (cid:2).P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591357Proof. Let E = W ∪ cons((cid:2)) be the extension that is generated by (cid:2). By the lemma above, it is generated by thedefaults in GEN(E, D). Since E is also an extension of (cid:15)D(cid:4), W (cid:16), it is generated by a process (cid:2)(cid:4) made exactly of thedefaults of GEN(E, D(cid:4)) = GEN(E, D) ∩ D(cid:4) = (cid:2) ∩ D(cid:4). (cid:2)The above lemmas allows to prove that justified default logic has the monotonic redundancy property w.r.t. sets ofdefaults and faithful equivalence.Theorem 13 (proof). Faithful equivalence of sets of defaults for justified default logic has the monotonic redundancyproperty.Proof. We prove that, if D(cid:4) ⊆ D(cid:4)(cid:4) ⊆ D and D(cid:4) ≡eevery extension of (cid:15)D(cid:4)(cid:4), W (cid:16) is also an extension of (cid:15)D, W (cid:16), and then show the converse.W D then D(cid:4)(cid:4) ≡eLet E be an extension of (cid:15)D(cid:4)(cid:4), W (cid:16). Let (cid:2) be one its generating processes. By Lemma 14, there exists a se-quence (cid:2)(cid:4) of defaults of D\D(cid:4)(cid:4) such that (cid:2) · (cid:2)(cid:4) is a selected process of (cid:15)D, W (cid:16). Let E(cid:4) be its generated extension.Since E is generated by (cid:2) and E(cid:4) is generated by (cid:2) · (cid:2)(cid:4), we have E(cid:4) |= E. We prove that E |= E(cid:4), which impliesE ≡ E(cid:4).W D for justified default logic. We first show thatBy Lemma 16, since (cid:2) is a selected process of (cid:15)D, W (cid:16) and this theory is faithfully equivalent to (cid:15)D(cid:4), W (cid:16), thereexists a selected process (cid:2)(cid:4)(cid:4) of (cid:15)D(cid:4), W (cid:16) made of the defaults of ((cid:2) · (cid:2)(cid:4)) ∩ D(cid:4) and generating the extension E(cid:4). Since(cid:2)(cid:4) is made of defaults of D\D(cid:4)(cid:4) and D(cid:4) ⊆ D(cid:4)(cid:4), we have that ((cid:2) · (cid:2)(cid:4)) ∩ D(cid:4) = (cid:2) ∩ D(cid:4). As a result, (cid:2)(cid:4)(cid:4) is only madeof defaults in (cid:2) ∩ D(cid:4). Since (cid:2)(cid:4)(cid:4) generates E(cid:4) and (cid:2) generates E, we have E |= E(cid:4). We can therefore conclude thatE ≡ E(cid:4).Let us now prove the converse: we assume that E is an extension of (cid:15)D, W (cid:16) and prove that it is also an extensionof (cid:15)D(cid:4)(cid:4), W (cid:16). Let (cid:2) be the process of (cid:15)D, W (cid:16) that generates E. By definition, the following two properties are true:1. W ∪ cons((cid:2)) |= prec(d) for every d ∈ (cid:2);2. W ∪ cons((cid:2))⊥just(d) ∪ cons(d) for every d /∈ (cid:2).By Lemma 16, the theory (cid:15)D(cid:4), W (cid:16) has a selected process (cid:2)(cid:4) that is composed exactly of the defaults of (cid:2) ∩ D(cid:4)and that generates the same extension E. Since W ∪ cons((cid:2)(cid:4)) ≡ W ∪ cons((cid:2)), the two properties are equivalent tothe following two ones:1. W ∪ cons((cid:2)(cid:4)) |= prec(d) for every d ∈ (cid:2);2. W ∪ cons((cid:2)(cid:4))⊥just(d) ∪ cons(d) for every d /∈ (cid:2).The first property implies that every default d ∈ (cid:2) ∩ (D(cid:4)(cid:4)\D(cid:4)) is applicable to (cid:2)(cid:4): this is because the preconditionof d is entailed by W ∪ cons((cid:2)(cid:4)) and the process (cid:2)(cid:4) · [d] is successful because so is (cid:2), which contains all defaultof (cid:2)(cid:4) · [d]. The second property implies that no default of D(cid:4)(cid:4)\(cid:2) is applicable to (cid:2)(cid:4). As a result, (cid:2)(cid:4) and the sequencecomposed of all defaults of (cid:2) ∩ (D(cid:4)(cid:4)\D(cid:4)) in any order form a selected process of D(cid:4)(cid:4). The extension generated bythis process is equivalent to E because this process is composed of a superset of the defaults of (cid:2)(cid:4) and a subset of thedefaults of (cid:2), and these two processes both generate E. (cid:2)References[1] G. Ausiello, A. D’Atri, D. Saccà, Minimal representation of directed hypergraphs, SIAM Journal on Computing 15 (2) (1986) 418–431.[2] G. Antoniou, A tutorial on default logics, ACM Computing Surveys 31 (4) (1999) 337–359.[3] G. Antoniou, V. Sperschneider, Operational concepts of non-monotonic logics, part 1: Default logic, Artificial Intelligence Review 8 (1) (1994)3–16.[4] P. Besnard, An Introduction to Default Logic, Springer, Berlin, 1989.[5] R. Bruni, Approximating minimal unsatisfiable subformulae by means of adaptive core search, Discrete Applied Mathematics 130 (2) (2003)85–100.[6] P. Bossu, P. Siegel, Saturation, non-monotonic reasoning and the closed world assumption, Artificial Intelligence 25 (1985) 16–63.[7] H. Büning, X. Zhao, Extension and equivalence problems for clause minimal formulae, Annals of Mathematics and Artificial Intelli-gence 43 (1) (2005) 295–306.1358P. Liberatore / Artificial Intelligence 172 (2008) 1317–1359[8] M. Cadoli, T. Eiter, G. Gottlob, Default logic as a query language, IEEE Transactions on Knowledge and Data Engineering 9 (3) (1997)448–463.[9] J. de Kleer, K. Konolige, Eliminating the fixed predicates from a circumscription, Artificial Intelligence 39 (1989) 391–398.[10] J. Delgrande, T. Schaub, Expressing default logic variants in default logic, Journal of Logic and Computation 15 (5) (2005) 593–621.[11] J.P. Delgrande, T. Schaub, W.K. Jackson, Alternative approaches to default logic, Artificial Intelligence 70 (1994) 167–237.[12] T. Eiter, M. Fink, H. Tompits, S. Woltran, Strong and uniform equivalence in answer-set programming: Characterizations and complexityresults for the non-ground case, in: Proceedings of the Twentieth National Conference on Artificial Intelligence (AAAI 2005), 2005, pp. 695–700.[13] T. Eiter, G. Gottlob, Propositional circumscription and extended closed world reasoning are (cid:2)p2 -complete, Theoretical Computer Science 114(1993) 231–245.[14] H. Fleischner, O. Kullmann, S. Szeider, Polynomial-time recognition of minimal unsatisfiable formulas with fixed clause-variable difference,Theoretical Computer Science 289 (2002) 503–516.[15] C. Froidevaux, J. Mengin, A framework for default logics, in: European Workshop on Logics in AI (JELIA’92), 1992, pp. 154–173.[16] C. Froidevaux, J. Mengin, Default logics: A unified view, Computational Intelligence 10 (1994) 331–369.[17] G. Gottlob, C.G. Fermüller, Removing redundancy from a clause, Artificial Intelligence 61 (1993) 263–289.[18] A. Ginsberg, Knowledge base reduction: A new approach to checking knowledge bases for inconsistency & redundancy, in: Proceedings ofthe Seventh National Conference on Artificial Intelligence (AAAI’88), 1988, pp. 585–589.[19] L. Giordano, A. Martelli, On cumulative default logics, Artificial Intelligence 66 (1994) 161–179.[20] G. Gottlob, Complexity results for non-monotonic logics, Journal of Logic and Computation 2 (1992) 397–425.[21] G. Gottlob, Translating default logic into standard autoepistemic logic, Journal of the ACM 42 (1995) 711–740.[22] P. Hammer, A. Kogan, Optimal compression of propositional Horn knowledge bases: Complexity and approximation, Artificial Intelli-gence 64 (1) (1993) 131–145.[23] E. Hemaspaandra, G. Wechsung, The minimization problem for Boolean formulas, in: Proceedings of the Thirty Eighth Annual Symposiumon the Foundations of Computer Science (FOCS’97), 1997, pp. 575–584.[24] T. Janhunen, Evaluating the effect of semi-normality on the expressiveness of defaults, Artificial Intelligence 144 (2003) 233–250.[25] L. Kirousis, P. Kolaitis, A dichotomy in the complexity of propositional circumscription, in: Proceedings of the Nineteenth IEEE Symposiumon Logic in Computer Science (LICS 2004), 2001, pp. 71–80.[26] P. Liberatore, Redundancy in logic I: CNF propositional formulae, Artificial Intelligence 163 (2) (2005) 203–232.[27] P. Liberatore, Representability in default logic, Logic Journal of the IGPL 13 (3) (2005) 335–351.[28] P. Liberatore, On the complexity of extension checking in default logic, Information Processing Letters 98 (2) (2006) 61–65.[29] P. Liberatore, Where fail-safe default logics fail, ACM Transactions on Computational Logic 8 (2) (2007).[30] P. Liberatore, Redundancy in logic II: 2-CNF and Horn propositional formulae, Artificial Intelligence 172 (2–3) (2008) 265–299.[31] J. Lang, P. Marquis, In search of the right extension, in: Proceedings of the Seventh International Conference on Principles of KnowledgeRepresentation and Reasoning (KR 2000), 2000, pp. 625–636.[32] V. Lifschitz, D. Pearce, A. Valverde, Strongly equivalent logic programs, ACM Transactions on Computational Logic 2 (4) (2001) 526–541.[33] W. Lukaszewicz, Considerations on default logic: An alternative approach, Computational Intelligence 4 (1) (1988) 1–16.[34] D. Maier, Minimum covers in relational database model, Journal of the ACM 27 (4) (1980) 664–674.[35] D. Makinson, General theory of cumulative inference, in: Proceedings of the Second International Workshop on Non-Monotonic Reasoning,Springer, 1988, pp. 1–18.[36] J. McCarthy, Circumscription—A form of non-monotonic reasoning, Artificial Intelligence 13 (1980) 27–39.[37] A. Meyer, L. Stockmeyer, The equivalence problem for regular expressions with squaring requires exponential space, in: Proceedings of theThirteenth Annual Symposium on Switching and Automata Theory (FOCS’72), 1972, pp. 125–129.[38] W. Marek, M. Truszczy´nski, Non-Monotonic Logics: Context-Dependent Reasoning, Springer, Berlin, 1993.[39] A. Mikitiuk, M. Truszczynski, Constrained and rational default logics, in: Proceedings of the Fourteenth International Joint Conference onArtificial Intelligence (IJCAI’95), 1995, pp. 1509–1517.[40] G. Nordh, P. Jonsson, An algebraic approach to the complexity of propositional circumscription, in: Proceedings of the Nineteenth IEEESymposium on Logic in Computer Science (LICS 2004), 2004, pp. 367–376.[41] D.L. Poole, A logical framework for default reasoning, Artificial Intelligence 36 (1988) 27–47.[42] D. Poole, Default logic, in: Handbook of Logic in Artificial Intelligence and Logic Programming, Volume 3: Non-Monotonic and UncertaintyReasoning, Oxford University Press, Oxford, 1994, pp. 189–215.[43] C. Papadimitriou, D. Wolfe, The complexity of facets resolved, Journal of Computer and System Sciences 37 (1988) 2–13.[44] R. Reiter, A logic for default reasoning, Artificial Intelligence 13 (1980) 81–132.[45] R. Rosati, Model checking for non-monotonic logics, in: Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence(IJCAI’99), 1999, pp. 76–83.[46] T. Schaub, On constrained default theories, in: Proceedings of the Tenth European Conference on Artificial Intelligence (ECAI’92), 1992,pp. 304–308.[47] P. Siegel, L. Forget, A representation theorem for preferential logics, in: Proceedings of the Fifth International Conference on the Principlesof Knowledge Representation and Reasoning (KR’96), 1996, pp. 453–460.[48] J. Schmolze, W. Snyder, Detecting redundant production rules, in: Proceedings of the Fourteenth National Conference on Artificial Intelligence(AAAI’97), 1997, pp. 417–423.[49] J. Stillman, The complexity of propositional default logics, in: Proceedings of the Tenth National Conference on Artificial Intelligence(AAAI’92), 1992, pp. 794–799.P. Liberatore / Artificial Intelligence 172 (2008) 1317–13591359[50] M. Truszczynski, Strong and uniform equivalence of non-monotonic theories—an algebraic approach, Annals of Mathematics and ArtificialIntelligence 48 (3–4) (2006) 245–265.[51] H. Turner, Strong equivalence for logic programs and default theories (made easy), in: Proceedings of the Sixth International Conference onLogic Programming and Non-Monotonic Reasoning (LPNMR’01), 2001, pp. 81–92.[52] C. Umans, The minimum equivalent DNF problem and shortest implicants, in: Proceedings of the Thirty Ninth Annual Symposium on theFoundations of Computer Science (FOCS’98), 1998, pp. 556–563.