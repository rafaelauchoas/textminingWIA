Artificial Intelligence 173 (2009) 1275–1309Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintRepresenting ontologies using description logics, description graphs,and rules ✩Boris Motik a,∗, Bernardo Cuenca Grau a, Ian Horrocks a, Ulrike Sattler ba University of Oxford, UKb University of Manchester, UKa r t i c l ei n f oa b s t r a c tArticle history:Received 20 February 2009Received in revised form 3 June 2009Accepted 9 June 2009Available online 13 June 2009Keywords:Knowledge representationDescription logicsStructured objectsOntologiesDescription logics (DLs) are a family of state-of-the-art knowledge representation languages,and their expressive power has been carefully crafted to provide useful knowledgemodeling primitives while allowing for practically effective decision procedures for thebasic reasoning problems. Recent experience with DLs, however, has shown that theirexpressivity is often insufficient to accurately describe structured objects—objects whoseparts are interconnected in arbitrary, rather than tree-like ways. DL knowledge basesdescribing structured objects are therefore usually underconstrained, which precludes theentailment of certain consequences and causes performance problems during reasoning.To address this problem, we propose an extension of DL languages with description graphs—a knowledge modeling construct that can accurately describe objects with parts connectedin arbitrary ways. Furthermore, to enable modeling the conditional aspects of structuredobjects, we also extend DLs with rules. We present an in-depth study of the computationalproperties of such a formalism. In particular, we first identify the sources of undecidabilityof the general, unrestricted formalism. Based on that analysis, we then investigate severalrestrictions of the general formalism that make reasoning decidable. We present practicalevidence that such a logic can be used to model nontrivial structured objects. Finally,we present a practical decision procedure for our formalism, as well as tight complexitybounds.© 2009 Elsevier B.V. All rights reserved.1. IntroductionThe Web Ontology Language (OWL) is a well-known language for ontology modeling in the Semantic Web [34]. TheWorld Wide Web Consortium (W3C) is currently working on a revision of OWL—called OWL 2 [10]—whose main goal is toaddress some of the limitations of OWL. The formal underpinnings of OWL and OWL 2 are provided by description logics(DLs) [3]—knowledge representation formalisms with well-understood formal properties.DLs are often used to describe structured objects—objects whose parts are interconnected in complex ways. Such objectsabound in molecular biology and the clinical sciences, and clinical ontologies such as GALEN, the Foundational Model of✩This is an extended version of two papers published at WWW 2008 [B. Motik, B. Cuenca Grau, U. Sattler, Structured objects in OWL: Representationand reasoning, in: Proc. of the 17th Int. World Wide Web Conference (WWW 2008), Beijing, China, April 21–25, 2008, ACM Press, 2008, pp. 555–564] andKR 2008 [B. Motik, B. Cuenca Grau, I. Horrocks, U. Sattler, Representing structured objects using description graphs, in: Gerhard Brewka, Jérôme Lang (Eds.),Proc. of the 11th Int. Joint Conf. on Principles of Knowledge Representation and Reasoning (KR 2008), Sydney, NSW, Australia, August 16–19, 2008, AAAIPress, 2008, pp. 296–306], respectively.* Corresponding author at: Oxford University Computing Laboratory, Wolfson Building, Parks Road, Oxford, OX1 3QD, United Kingdom.E-mail addresses: boris.motik@comlab.ox.ac.uk (B. Motik), berg@comlab.ox.ac.uk (B. Cuenca Grau), ian.horrocks@comlab.ox.ac.uk (I. Horrocks),sattler@cs.man.ac.uk (U. Sattler).0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2009.06.0031276B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Anatomy (FMA), and the National Cancer Institute (NCI) Thesaurus describe numerous structured objects. For example, FMAmodels the human hand as consisting of the fingers, the palm, various bones, blood vessels, and so on, all of which arehighly interconnected.Modeling structured objects poses numerous problems to DLs and the OWL family of languages. The design of DLs hasbeen driven by the desire to provide practically useful knowledge modeling primitives while ensuring decidability of thecore reasoning problems. To achieve the latter goal, the modeling constructs available in DLs are usually carefully crafted sothat the resulting language exhibits a variant of the tree-model property [39]: each satisfiable DL ontology always has at leastone model whose elements are connected in a tree-like manner. This property can be used to derive a decision procedure;however, it also prevents one from accurately describing (usually non-tree-like) structured objects since, whenever a modelexists, at least one model does not reflect the intended structure. This technical problem has severe consequences in practice[28]. In search of the “correct” way of describing structured objects, modelers often create overly complex descriptions;however, since the required expressive power is actually missing, such descriptions do not entail the consequences thatwould follow if the descriptions accurately captured the intended structure. We discuss the expressivity limitations of DLsin more detail in Section 3 and present a practically-motivated example.In order to address this lack of expressivity, in this paper we extend DLs with description graphs, which can be under-stood as schema-level descriptions of structured objects. To allow for the representation of conditional statements aboutstructured objects, we also extend DLs with first-order rules [20]. In this way, we obtain a powerful and versatile knowl-edge representation formalism. It allows us, for example, to describe the structure of the hand using description graphs,statements such as “if a bone in the hand is fractured, then the hand is fractured as well” using rules, and nonstructuralaspects of the domain such as “a medical doctor is a person with an MD degree” using DLs.Unsurprisingly, this formalism is undecidable in its unrestricted form. It is widely recognized that reasoning algorithmsare more likely to be effective in practice if the underlying logics are decidable. Therefore, we discuss the main causes ofundecidability and investigate restrictions under which the formalism becomes decidable.We have observed that structured objects can often be described by a possibly large, yet bounded number of parts. Forexample, a human body consists of organs all of which can be decomposed into smaller parts; however, further decomposi-tion will eventually lead to parts that one does not want or know how to describe any further. In this vein, FMA describesthe skeleton of the hand, but it does not describe the internal structure of the distal phalanges of the fingers. The number ofparts needed to describe the hand is therefore determined by the granularity of the hierarchical decomposition of the hand.This decomposition naturally defines an acyclic hierarchy of description graphs. For example, the fingers can be describedby description graphs that are subordinate to that of the hand; however, the description graph for the hand is not naturallysubordinate to the description graphs for the fingers. We use this observation to define a particular acyclicity restriction ondescription graphs. Acyclicity bounds the number of parts that one needs to reason with, which, provided that there are noDL axioms, can be used to obtain a decision procedure for the basic reasoning problems.If description graphs are used in combination with DL axioms, the acyclicity condition alone does not ensure decidabilitydue to possible interactions between DL axioms, graphs, and rules [26]. To ensure decidability, we limit this interaction byimposing an additional role separation condition. In particular, we separate the roles (i.e., the binary predicates) that can beused in DL axioms from the roles that can be used in rules; furthermore, depending on the expressivity of the DL beingused, we may additionally require DL axioms not to refer to the roles used in the description graphs.We present a hypertableau-based [31] reasoning algorithm that decides the satisfiability problem in the decidable cases,and that acts as a semidecision procedure for some undecidable ones. Furthermore, we present tight complexity bounds forthe decidable variants of our formalism and identify the main sources of complexity. We have implemented the reasoningalgorithm in the HermiT1 reasoner [30], and our initial experiments have shown the algorithm to be amenable to practice.Evaluation of our approach is currently difficult due to the lack of test data. We have therefore devised an algorithm thatextracts description graphs from existing OWL ontologies, and have applied it to GALEN and FMA. The resulting ontologiesshould be treated with caution; however, domain experts have confirmed that substantial parts of thus derived ontologiesagree with their intuition. Our transformation can thus be used as a starting point for a more comprehensive remodeling ofontologies using description graphs. Our experiments already allowed us to discover a modeling error in GALEN, which wetake as indication of the practical usefulness of our formalism. Furthermore, classification times for the transformed ontolo-gies are of similar orders of magnitude as for the original ontologies despite the fact that our formalism adds considerableexpressive power to DLs.We believe that description graphs can be used for modeling structured objects in a number of domains, of which welist a few next.• Anatomy. In Sections 3 and 4 we present a comprehensive example of how description graphs can be applied to modelhuman anatomy.• Chemistry. The precise description of molecules is an important problem in bioinformatics [23]. A formal representationof molecules and chemical compounds is often used to integrate information from different chemical databases [23]. Thestructure of molecules is often not tree-like. For example, hydrocarbons are chemical compounds containing carbon–1 http://www.hermit-reasoner.com/.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091277hydrogen chains, and benzene is a hydrocarbon whose molecules contain exactly one benzene ring. The structure ofbenzene can be described using our formalism: description graphs can be used to represent the benzene ring (which isbounded in size), while standard OWL axioms can be used to represent tree-like carbon–hydrogen chains.• Scientific workflows. Scientific workflows are descriptions of the steps of scientific experiments, and they are often rep-resented as directed graphs in which each node depicts a single experiment step and each edge represents informationflow between two steps. The precise description of workflows is increasingly important, for example, in bioinformatics.Attempts were made to provide semantics to workflows using OWL [16], but the success has been rather limited so fardue to their non-tree-like structure. Since workflows are typically bounded, however, they can naturally be representedusing description graphs.• Engineering. OWL has recently been used in engineering domains, such as the aerospace industry, which involve therepresentation of very complex structured objects such as aeroplanes [19]. The number of parts needed to describe anaircraft is naturally bounded (in the same way as it is in the case of the human body), so such domains can easily berepresented using description graphs [17].2. PreliminariesThe formal underpinnings of OWL 2 are provided by the DL SROIQ [25]. To make our results easier to follow, however,in this paper we consider the DL SHOIQ+, which covers all of SROIQ except for the so-called complex role inclusions.Using a well-known encoding [13,21], complex role inclusions can be encoded using SHOIQ+axioms, so the decidabilityresults and reasoning algorithms from this paper can be easily extended to SROIQ and OWL 2. We present the definitionof SHOIQ+in Section 2.1. In Section 2.2, we recapitulate the well-known principles for extending DLs with first-orderrules. Finally, in Section 2.3 we present an overview of the hypertableau algorithm for SHOIQ+[31].2.1. The description logic SHOIQ+A SHOIQ+signature is a triple (NC , N R , N I ) consisting of mutually disjoint sets of atomic concepts NC , atomic roles N R ,(cid:5)(cid:5)−A role is either R or Rand named individuals N I . In the rest of this paper, we assume that the signature is implicit in all relevant definitions.(inverse role), for R ∈ N R . The function inv(·) is defined on the set of roles as inv(R) = R−−) = R. An RBox axiom is an expression of the form R1 (cid:4) R2 (role inclusion), Dis(S1, S2) (role disjointness), Ref(R)and inv(R(reflexivity), Irr(S) (irreflexivity), Sym(R) (symmetry), Asy(S) (asymmetry), and Tra(R) (transitivity), where R, R 1, and R2 areroles, and S, S1, and S2 are simple roles, as defined next. For X a set of RBox axioms, let (cid:4)∗X be the reflexive-transitiveclosure of the relation {R1 (cid:4) R2, inv(R1) (cid:4) inv(R2) | R1 (cid:4) R2 ∈ X}. A role R is transitive in X if a role Rexists such that(cid:5) (cid:4)∗(cid:5))) ∈ X . A role S is simple in X if no transitive role R exists such thatRR (cid:4)∗X R, R (cid:4)∗X S.Given a set of RBox axioms X , the set of concepts w.r.t. X is the smallest set containing (cid:6) (the top concept), ⊥ (thebottom concept), A (atomic concept), {a} (nominal), ¬C (negation), C (cid:8) D (conjunction), C (cid:9) D (disjunction), ∃R.C (existentialrestriction), ∀R.C (universal restriction), ∃S.Self (local reflexivity), (cid:2) n S.C (at-least restriction), and (cid:3) n S.C (at-most restriction),where A is an atomic concept, a is an individual, C and D are concepts, R is a role, S is a simple role w.r.t. X , and n is anonnegative integer. The set of literal concepts is defined as N L = NC ∪ {¬ A | A ∈ NC }. A TBox T is a finite set of RBox axiomsand general concept inclusion (GCI) axioms C (cid:4) D, where C and D are concepts w.r.t. the subset of the RBox axioms of T .2(cid:5)) ∈ X or Tra(inv(R, and either Tra(RX RAn assertion is an expression of the form C(a) (concept assertion), R(a, b) (role assertion), a ≈ b (equality assertion), anda (cid:14)≈ b (inequality assertion), where C is a concept, R is a role, and a and b are named individuals. An ABox A is a finite setof assertions. Finally, a SHOIQ+knowledge base is a pair (T , A) where T is a TBox and A is an ABox.An interpretation for a signature (NC , N R , N I ) is a tuple I = ((cid:15)I , ·I ), where (cid:15)I is a nonempty set called the interpretationdomain and ·I is a function assigning an element aI ∈ (cid:15)I to each named individual a ∈ N I , a set A I ⊆ (cid:15)I to each atomicconcept A ∈ NC , and a relation R I ⊆ (cid:15)I × (cid:15)I to each atomic role R ∈ N R . The extension of ·I to concepts and roles, andsatisfaction of axioms and assertions in I is defined as shown in Table 1. An interpretation I is a model of (T , A), writtenI |(cid:17) (T , A), if and only if all axioms of T and all assertions of A are satisfied in I .The basic inference problem for SHOIQ+is checking whether (T , A) is satisfiable—that is, whether a model of (T , A)exists. A concept C subsumes a concept D w.r.t. (T , A), written (T , A) |(cid:17) C (cid:4) D, if C I ⊆ D I for each model I of (T , A). Itis well known that (T , A) |(cid:17) C (cid:4) D if and only if (T , A ∪ {C(a), ¬D(a)}) is unsatisfiable, where a is an individual occurringin neither T nor A [3].The negation-normal form nnf(C) of a concept C is the concept equivalent to C in which negations occur only in front ofatomic concepts and concepts of the form {a} and ∃S.Self. The concept nnf(C) can be computed in time linear in the sizeof C [3]. With |K| we denote the size of a knowledge base K—that is, the number of symbols required to encode K on theinput tape of a Turing machine (numbers can be coded in binary).SHIQ+ALCHOIQ+and SHOQ+are obtained from SHOIQ+is obtained from SHOIQ+by disallowing nominals and inverse roles, respectively.by disallowing transitivity axioms. ALCIF allows for negation, conjunction,2 The TBox T is sometimes assumed to contain only GCIs, and all RBox axioms are represented as a separate set R; however, to simplify the presentationin the following sections, in this paper we assume that T contains GCIs as well as RBox axioms.1278B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Table 1Model-theoretic semantics of SHOIQ+.(R−)I(cid:6)I⊥I{s}I(¬C)I(C (cid:8) D)I(C (cid:9) D)I(∃R.C)I(∀R.C)I(∃S.Self)I((cid:2) n S.C )I((cid:3) n S.C )IInterpretation of roles and concepts============{(cid:18) y, x(cid:19) | (cid:18)x, y(cid:19) ∈ R I }(cid:15)I∅{sI }(cid:15)I \ C IC I ∩ D IC I ∪ D I{x | ∃ y : (cid:18)x, y(cid:19) ∈ R I ∧ y ∈ C I }{x | ∀ y : (cid:18)x, y(cid:19) ∈ R I → y ∈ C I }{x | (cid:18)x, x(cid:19) ∈ S I }{x | (cid:2){ y | (cid:18)x, y(cid:19) ∈ S I ∧ y ∈ C I } (cid:2) n}{x | (cid:2){ y | (cid:18)x, y(cid:19) ∈ S I ∧ y ∈ C I } (cid:3) n}I |(cid:17) C (cid:4) DI |(cid:17) R1 (cid:4) R2I |(cid:17) Dis(S 1, S 2)I |(cid:17) Ref(R)I |(cid:17) Irr(S)I |(cid:17) Sym(R)I |(cid:17) Asy(S)I |(cid:17) Tra(R)I |(cid:17) C(a)I |(cid:17) R(a, b)I |(cid:17) a ≈ bI |(cid:17) a (cid:14)≈ bInterpretation of axioms and assertionsiffiffiffiffiffiffiffiffiffiffiffiffC I ⊆ D I⊆ R IR I21= ∅∩ S IS I21∀x ∈ (cid:15)I : (cid:18)x, x(cid:19) ∈ R I∀x ∈ (cid:15)I : (cid:18)x, x(cid:19) /∈ S IR I ⊆ (inv(R))IS I ∩ (inv(S))I = ∅∀x, y, z ∈ (cid:15)I : (cid:18)x, y(cid:19) ∈ R I ∧ (cid:18) y, z(cid:19) ∈ R I → (cid:18)x, z(cid:19) ∈ R IaI ∈ C I(cid:18)aI , bI (cid:19) ∈ R IaI = bIaI (cid:14)= bINote. (cid:2)N is the number of elements in N.Table 2Satisfaction of rules in an interpretation.I, μ |(cid:17) C(s)I, μ |(cid:17) R(s, t)I, μ |(cid:17) s ≈ tI, μ |(cid:17)mI |(cid:17)I |(cid:17) R(cid:2)(cid:2)mi=1 U i →i=1 U i →iffiffiffiffiffiff(cid:3)nj=1 V j(cid:3)nj=1 V jsI,μ ∈ C I(cid:18)sI,μ, t I,μ(cid:19) ∈ R IsI,μ = t I,μI, μ |(cid:17) U i for each 1 (cid:3) i (cid:3) m implies I, μ |(cid:17) V j for some 1 (cid:3) j (cid:3) n(cid:3)I, μ |(cid:17)i=1 U i →nj=1 V j for all mappings μI |(cid:17) r for each rule r ∈ R(cid:2)mdisjunction, existential and universal restrictions, inverse roles, and axioms of the form (cid:6) (cid:4) (cid:3) 1 R.(cid:6). Finally, ALCF isobtained from ALCIF by disallowing inverse roles.2.2. Extending DLs with rulesDescription logics can be extended with rules—clauses interpreted under standard first-order semantics—in a straightfor-ward way [14,20,26]. Let N V be a set of variables disjoint with the set of individuals N I . An atom is an expression of theform C(s), R(s, t), or s ≈ t, for s and t individuals or variables, C a concept, and R a role. A rule is an expression of the formU 1 ∧ · · · ∧ Um → V 1 ∨ · · · ∨ V n(1)where U i and V j are atoms, m (cid:2) 0, and n (cid:2) 0. The conjunction U 1 ∧ · · · ∧ Um is called the body, and the disjunctionV 1 ∨ · · · ∨ V n is called the head. Without loss of generality, we assume that no rule r contains ≈ in the body. The emptybody and the empty head of a rule are written as (cid:6) and ⊥, respectively. A rule is Horn if the head of the rule containsat most one atom. Variables x and y are directly connected in a rule r if they occur together in some body atom of r;furthermore, connected is the transitive closure of directly connected. A rule r is connected if each pair of variables x and yoccurring in r is connected in r.Let I = ((cid:15)I , ·I ) be an interpretation and μ : N V → (cid:15)I a mapping of variables to elements of the interpretation domain.Let aI,μ = aI for an individual a and xI,μ = μ(x) for a variable x. Satisfaction of an atom, rule, and a set of rules R in I andμ is defined in Table 2.2.3. Hypertableau calculus for SHOIQ+We now present an overview of the hypertableau calculus [31], which can be used to decide the satisfiability of aSHOIQ+knowledge base (T , A).B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091279The algorithm first preprocesses (T , A) into a set of rules ΞT (T ) and an ABox A ∪ ΞA(T ). This transformation consistsof three steps. First, transitivity axioms are eliminated from T by encoding them using general concept inclusions; similarencodings are well known in the context of various description and modal logics [27,37,38]. Second, axioms are normalizedand complex concepts are replaced with atomic ones in a way similar to the structural transformation [35]. Third, thenormalized axioms are translated into rules by using the correspondences between description and first-order logic [8]. Weomit the details of the preprocessing for the sake of brevity; they can be found in [31, Section 4.1]. All steps are satisfiabilitypreserving; thus, ΞT (T ) and A ∪ ΞA(T ) are equisatisfiable with (T , A).Preprocessing produces HT-rules—syntactically restricted rules on which the hypertableau calculus is guaranteed to ter-minate. In the definition of HT-rules and in the rest of this paper, we often use the following function ar. Given a role R andvariables or constants s and t, this function returns an atom with an atomic role that is semantically equivalent to R(s, t).(cid:4)ar(R, s, t) =R(s, t)S(t, s)if R is an atomic roleif R is an inverse role and R = S−Definition 1 (HT-rule). We assume that the set of atomic concepts NC contains a nominal guard concept O a for each individuala, and that these concepts do not occur in any input knowledge base.An at-most equality is an atom of the form s ≈ t @uinteger, S is a role, and B is a literal concept; the part @uequivalent to s ≈ t.(cid:3)n S.B , where s, t, and u are constants or variables, n is a nonnegative(cid:3)n S.B of the atom is called the annotation. This atom is semanticallyAn HT-rule r is a rule of the form (1) with m (cid:2) 0 and n (cid:2) 0, in which it must be possible to separate the variables intoa center variable x, a set of branch variables yi , and a set of nominal variables z j such that the following properties hold, forA an atomic concept, B a literal but not a nominal guard concept, O a a nominal guard concept, R an atomic role, and S arole.• Each atom in the body of r is of the form A(x), R(x, x), R(x, yi), R( yi, x), A( yi), or A(z j).• Each atom in the head of r is of the form B(x), (cid:2) h S.B(x), B( yi), R(x, x), R(x, yi), R( yi, x), R(x, z j), R(z j, x), x ≈ z j , oryi ≈ y j @x(cid:3)h S.B .• Each yi occurs in the body of r in an atom of the form R(x, yi) or R( yi, x).• Each z j occurs in the body of r in an atom of the form O a(z j).• Each equality yi ≈ y j @xoccurs elsewhere in r.(cid:3)h S. A in the head of r occurs in a subclause of r of the form (2) and no yk with 1 (cid:3) k (cid:3) h + 1h+1(cid:5)(cid:6)(cid:7)ar(S, x, yk) ∧ A( yk)· · ·· · · → · · ·(cid:8)k=11(cid:3)k<(cid:4)(cid:3)h+1yk ≈ y(cid:4) @x(cid:3)h S. A . . .(2)• Each equality yi ≈ y j @xoccurs elsewhere in r.(cid:3)n S.¬ A in the head of r occurs in a subclause of r of the form (3) and no yk with 1 (cid:3) k (cid:3) h + 1· · ·h+1(cid:5)k=1ar(S, x, yk) · · · → · · ·h+1(cid:8)k=1A( yk) ∨(cid:8)1(cid:3)k<(cid:4)(cid:3)h+1yk ≈ y(cid:4) @x(cid:3)h S.¬ A . . .(3)Intuitively, the body and the head of HT-rules can be seen as being “star-shaped”: the variable x represents the centerof the star, and the branch variables yi can be connected to the center only through role atoms. Such a shape ensures thatHT-rules can enforce only tree-like models—a property that can be used to explain the good computational properties ofmany DLs [39].Atoms of the form x ≈ z jin HT-rules stem from nominals. For example, axiom C (cid:4) {a} naturally corresponds to therule C(x) → x ≈ a. To avoid making the calculus unnecessarily complex, however, the rules should not contain constants[31]. Therefore, nominal guard concepts are used to “push” all constants from the rules into the ABox. For example, thementioned rule is transformed into an HT-rule C(x) ∧ O a(z) → x ≈ z and an assertion O a(a). Nominal guard concepts areunique for the nominal and they are used only internally by the algorithm—that is, they are not allowed to occur in theinput knowledge base.At-most equalities yi ≈ y j @x(cid:3)n R.C stem from the translation of at-most concepts; for example, (cid:6) (cid:4) (cid:3) 1 R.(cid:6) is translatedinto R(x, y1) ∧ R(x, y2) → y1 ≈ y2 @x(cid:3)1 R.(cid:6) does not affect the meaning of the equality; it merelyrecords its provenance, and we shall discuss its usage shortly. The concept ∃R.C is used in the rest of this paper as anabbreviation for (cid:2) 1 R.C .(cid:3)1 R.(cid:6). The annotation @xThe hypertableau calculus takes a set of HT-rules R and an input ABox A, and it decides the satisfiability of (R, A).1280B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Definition 2 (Hypertableau algorithm).Individuals. Given a set of named individuals N I , the set of root individuals N O is the smallest set such that N I ⊆ N Oand, if x ∈ N O , then x.(cid:18)R, B, i(cid:19) ∈ N O for each role R, literal concept B, and integer i. The set of generalized individuals N Ais the smallest set such that N O ⊆ N A and, if x ∈ N A , then x.i ∈ N A for each integer i. The individuals in N A \ N O are treeindividuals.A tree individual x.i is a successor of x, and x is a predecessor of x.i. Descendant and ancestor are the transitive closuresof successor and predecessor, respectively.ABoxes. The hypertableau algorithm operates on ABoxes that are obtained by extending the standard definition as fol-lows.• In addition to standard assertions, an ABox can contain at-most equalities and a special assertion ⊥ that is false in allinterpretations. Furthermore, assertions can refer to the individuals from N A and not only from N I .• Each (in)equality s ≈ t (s (cid:14)≈ t) also stands for the symmetric (in)equality t ≈ s (t (cid:14)≈ s). The same is true for annotatedat-most equalities.• An ABox A can contain renamings of the form a (cid:25)→ b where a and b are root individuals. The relation (cid:25)→ in A mustbe acyclic, A can contain at most one renaming a (cid:25)→ b for an individual a, and, if A contains a (cid:25)→ b, then a should notoccur in any assertion or (in)equality in A. An individual b is the canonical name of a root individual a in A, writtenb = (cid:26)a(cid:26)A, iff a (cid:25)→∗is the reflexive-transitive closureof (cid:25)→ in A.b and there exists no individual c (cid:14)= b such that b (cid:25)→∗c, where (cid:25)→∗An input ABox contains only named individuals, no at-most equalities, no renamings, and in which all concepts are literaland all roles are atomic.Satisfaction of such ABoxes in an interpretation is obtained by a straightforward generalization of the definitions inSection 2.1: all individuals are interpreted as elements of the interpretation domain (cid:15)I , and I |(cid:17) a (cid:25)→ b iff aI = bI .Merge target. An individual t is a merge target for an individual s if t is a named individual, or t is a root individual ands is not a named individual, or s is a descendant of t.Pruning. The ABox pruneA(s) is obtained from A by removing all assertions containing a descendant of s.Merging. The ABox mergeA(s → t) is obtained from pruneA(s) by replacing the individual s with the individual t in allassertions and their annotations (but not in renamings) and, if both s and t are root individuals, adding the renaming s (cid:25)→ t.Pairwise anywhere blocking. The labels of an individual s and of an individual pair (cid:18)s, t(cid:19) in an ABox A are defined asfollows:LA(s) =LA(s, t) =(cid:9)(cid:9)(cid:10)A | A(s) ∈ A and A is an atomic concept(cid:10)R | R(s, t) ∈ ALet < be a strict ordering (i.e., a transitive and irreflexive relation) on N A containing the ancestor relation—that is, if sis an ancestor of s, then s(cid:5) < s. By induction on <, we assign to each individual s in A a status as follows:(cid:5)• a tree individual s is directly blocked by a tree individual t iff, for s(cid:5)(cid:5)and tthe predecessors of s and t, respectively,◦ t is not blocked,◦ t < s,◦ LA(s) = LA(t) and LA(s(cid:5)) = LA(t, t◦ LA(s, s(cid:5)) = LA(t(cid:5)), and(cid:5), s) = LA(t(cid:5)) and LA(s(cid:5), t);• s is indirectly blocked iff it has a predecessor that is blocked; and• s is blocked iff it is either directly or indirectly blocked.Derivation rules. Table 3 specifies derivation rules that, given an ABox A and a set of HT-rules R, derive the ABoxesA1, . . . , An. In the Hyp-rule, σ is a mapping from the set of variables in the HT-rule to the individuals occurring in theassertions of A, and σ (U ) is the result of replacing each variable x in the atom U with σ (x). In the NI-rule, for u a rootindividual, R a role, B a literal concept, and i an integer, we define rootfor(u, R, B, i) = u.(cid:18)R, B, i(cid:19).3Rule precedence. The ≈-rule can be applied to a (possibly annotated) equality s ≈ t in an ABox A only if A does notcontain an equality s ≈ t @u(cid:3)n R.B to which the NI-rule is applicable.Clash. An ABox A contains a clash iff ⊥ ∈ A; otherwise, A is clash-free.Derivation. For a set of HT-rules R and an ABox A, a derivation is a pair (T , ρ) where T is a finitely branching tree andρ is a function that labels the nodes of T with ABoxes such that the following properties hold for each node t ∈ T :• ρ(t) = A if t the root of T ;3 The function rootfor is not used in the formalization of the algorithm in [31], and it has been introduced here to make the presentation of the algorithmin Section 6 easier.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091281Table 3Derivation rules of the hypertableau calculus.Hyp-ruleIf 1.2.2.12.22.3r ∈ R with r = U 1 ∧ · · · ∧ Um → V 1 ∨ · · · ∨ V n, anda mapping σ from variables of r to the individuals of A exists such thatσ (x) is not indirectly blocked for each variable x ∈ N V ,σ (U i ) ∈ A for each 1 (cid:3) i (cid:3) m, andσ (V j ) /∈ A for each 1 (cid:3) j (cid:3) n,then A1 := A ∪ {⊥} if n = 0;A j := A ∪ {σ (V j )} for 1 (cid:3) j (cid:3) n otherwise.(cid:2)-rule≈-rule⊥-ruleNI-ruleIf 1. (cid:2) n R.B(s) ∈ A,s is not blocked in A, and2.3. A does not contain individuals u1, . . . , un such that3.13.2{ar(R, s, ui ), B(ui ) | 1 (cid:3) i (cid:3) n} ∪ {ui (cid:14)≈ u j | 1 (cid:3) i < j (cid:3) n} ⊆ A, andui is not indirectly blocked in A for each 1 (cid:3) i (cid:3) nthen A1 := A ∪ {ar(R, s, ti ), B(ti ) | 1 (cid:3) i (cid:3) n} ∪ {ti (cid:14)≈ t j | 1 (cid:3) i < j (cid:3) n}where t1, . . . , tn are fresh distinct tree successors of s.s ≈ t ∈ A (the equality can possibly be annotated),s (cid:14)= t, andneither s not t is indirectly blockedIf 1.2.3.then A1 := mergeA(s → t) if t is merge target for s, andA1 := mergeA(t → s) otherwise.s (cid:14)≈ s ∈ A or { A(s), ¬ A(s)} ⊆ A where s is not indirectly blockedIf 1.Ifthen A1 := A ∪ {⊥}.s ≈ t @uu is a root individual,s is neither a root individual nor a tree successor of u,t is not a root individual, andneither s nor t is indirectly blocked∈ A (the symmetry of ≈ applies as usual),2.3.4.5.(cid:2)n R.Bthen Ai := mergeA(s → (cid:26)rootfor(u, R, B, i)(cid:26)A) for each 1 (cid:3) i (cid:3) n.Fig. 1. A forest-shaped ABox.• t is a leaf of T if ⊥ ∈ ρ(t) or no derivation rule is applicable to ρ(t) and R;• t has children t1, . . . , tn such that ρ(t1), . . . , ρ(tn) are exactly the results of applying one (arbitrarily chosen, but re-specting the rule precedence) applicable rule to ρ(t) and R in all other cases.A derivation is successful if T contains a branch t1, t2, . . . such that each ABox ρ(ti) is clash-free.The Hyp-rule is similar to the one of the hypertableau calculus for first order logic [6]: given an HT-rule of the form (1)and an ABox A, the Hyp-rule tries to unify the atoms U 1, . . . , Um with a subset of the assertions in A; if a unifier σ isfound, the rule nondeterministically derives σ (V j) for some 1 (cid:3) j (cid:3) n. For example, given R(x, y) → ∃R.C(x) ∨ D( y) and anassertion R(a, b), the Hyp-rule derives either ∃R.C(a) or D(b). The (cid:2)-rule deals with existential quantifiers; for example,given ∃R.C(a), the rule introduces a fresh individual t and derives R(a, t) and C(t). The ≈-rule deals with equality; forexample, given a ≈ b, the rule replaces the individual a in all assertions with the individual b, and it introduces a renaminga (cid:25)→ b in order to keep track of the merge. As discussed in [31], renamings are necessary to ensure soundness of the NI-rule.Finally, the ⊥-rule detects contradictions such as A(a) and ¬ A(a), or a (cid:14)≈ a.Termination of the calculus is ensured through blocking, the correctness of which relies on the notion of forest-shapedABoxes. Such an ABox is shown in Fig. 1, where nodes and edges correspond to individuals and role assertions, respectively.Named individuals (shown as black nodes) originate from the input ABox, and they can be connected in arbitrary ways. Treeindividuals (shown as white nodes and called blockable individuals in [31]) are introduced by the (cid:2)-rule, and they canbe connected either to arbitrary named individuals, or to other tree individuals in a tree-like way. For convenience, treeindividuals are represented in the algorithm as strings; for example, s = a.1 denotes that s is the first successor of a. Nowit is possible to show that the (cid:2)-rule can be applied only to nonblocked individuals without jeopardizing completeness.Intuitively, if s is blocked by t in an ABox A and no derivation rule is applicable to A, then a model of the knowledge1282B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309base can be constructed by “unraveling” A—that is, by replicating the fragment between s and t infinitely often. Effectively,blocking means that we do not need to introduce tree successors in order to satisfy assertions of the form (cid:2) n R.C(s)because we can “reuse” the successors of t.Applications of most derivation rules preserve the forest shape of an ABox; however, inverse roles, nominals, and number−.(cid:6).restrictions cause subtle problems. Consider again Fig. 1 and assume that d must satisfy an at-most restriction (cid:3) 1 RThis implies v ≈ s, so one individual should be merged into the other; however, this can compromise the tree shape ofthe ABox. The NI-rule deals with this problem by promoting one of v or s into a root individual: such individuals can beconnected in arbitrary ways even if they do not occur in the input ABox. Thus, an application of the Hyp-rule to the ABox inFig. 1 and the HT-rule R( y1, x) ∧ R( y2, x) → y1 ≈ y2 @x(cid:3)1 R−.(cid:6). By examining theannotation on the equality, the NI-rule can detect that the equality stems from an at-most concept, in response to which itturns either v or s into a root individual. It is possible to establish a bound on the number of the introduced root individualsand thus prove termination.(cid:3)1 R−.(cid:6) derives the at-most equality v ≈ s @dThe complexity of the hypertableau calculus is due to a possible interaction between number restrictions, inverse roles,and nominals. If a description logic does not support at least one of these constructors, then the HT-rules in ΞT (T ) havea simpler form, which prevents the derivation of assertions that satisfy the preconditions of the NI-rule. In such cases, eachatom of the form yi ≈ y j @x(cid:3)n R.B can be simplified to yi ≈ y j , and the set of root individuals becomes the same as the setof named individuals. Furthermore, Condition 3.2 of the (cid:2)-rule is always satisfied, so it need not be explicitly checked.On SHOQ+, the HT-rules in ΞT (T ) have the following simpler form.Definition 3 (Simple HT-rule). A simple HT-rule is a rule r of the form (1) in which it must be possible to separate the variablesinto a center variable x, a set of branch variables yi , and a set of nominal variables z j such that the following properties hold,for A an atomic concept, B a literal but not a nominal guard concept, O a a nominal guard concept, and R an atomic role.• Each atom in the body of r is of the form A(x), R(x, x), R(x, yi), A( yi), or A(z j).• Each atom in the head of r is of the form B(x), (cid:2) n R.B(x), B( yi), R(x, x), R(x, yi), R(x, z j), x ≈ z j , or yi ≈ y j .• Each yi occurs in the body of r in an atom of the form R(x, yi).• Each z j occurs in the body of r in an atom of the form O a(z j).Simple HT-rules allow for a simpler version of blocking: instead of pairs of individuals, one needs to consider only singleindividuals.Definition 4 (Single anywhere blocking). By induction on <, each individual s in A is assigned a status as follows:• a tree individual s is directly blocked by a tree individual t if t is not blocked, t < s, and LA(s) = LA(t);• s is indirectly blocked if it has a predecessor that is blocked; and• s is blocked if it is either directly or indirectly blocked.3. Problems with modeling complex structuresTo understand the limitations of modeling structured objects in DLs (and hence in OWL as well), consider the problem ofmodeling the skeleton of the human hand, whose structure is shown in Fig. 2a. The carpal bones form the base of the hand.The central part of the hand contains the metacarpal bones, one leading to each finger. The fingers consist of phalanges: theproximal phalanges are connected to the metacarpal bones, and all fingers apart from the thumb contain a middle phalanxbetween the proximal and the distal phalanx. This structure can be intuitively conceptualized as shown in Figs. 2b–2e.4This structure can be straightforwardly encoded in a DL ABox A. ABox assertions, however, represent concrete data; thus,A would represent the structure of one particular hand. In this paper, we are concerned with modeling structured objectsat the schema level—that is, we want to describe the general structure of all hands. We should be able to instantiate sucha description many times. For example, if we say that each patient has a hand, then for each concrete patient we shouldinstantiate a different hand, each with the structure as shown in Figs. 2b–2e; depending on the properties of the patientand the axioms in the ontology, each such structure can then exhibit distinct features. This clearly cannot be achieved usingABox assertions.We can give a logical, schema-level interpretation to Figs. 2b–2e by treating vertices as concepts and arrows as partici-pation constraints between the concepts. For example, vertices 1 and 6 would correspond to concepts Hand and Index_finger,whose instances would be all hands and all index fingers, respectively. Furthermore, the arrow from 1 to 6 would be inter-preted as a statement that each hand has an index finger as its part. In DLs, such a participation constraint would commonlybe represented by axioms (4)–(5).4 The relationship attached_to is assumed to be bidirectional, so the edges labeled with it are not oriented.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091283Fig. 2. The anatomy of the hand and its conceptual models.Hand (cid:4) ∃part.Index_fingerHand (cid:4) (cid:3) 1 part.Index_finger(4)(5)Thus, the knowledge base K containing axioms (6)–(19) would provide a formalization of the structure shown in Fig. 2e.5Index_finger (cid:4) ∃part.Distal_phalanx_oifIndex_finger (cid:4) ∃part.Middle_phalanx_oifIndex_finger (cid:4) ∃part.Proximal_phalanx_oifDistal_phalanx_oif (cid:4) ∃attached_to.Middle_phalanx_oifMiddle_phalanx_oif (cid:4) ∃attached_to.Distal_phalanx_oifMiddle_phalanx_oif (cid:4) ∃attached_to.Proximal_phalanx_oifProximal_phalanx_oif (cid:4) ∃attached_to.Middle_phalanx_oifIndex_finger (cid:4) (cid:3) 1 part.Distal_phalanx_oifIndex_finger (cid:4) (cid:3) 1 part.Middle_phalanx_oifIndex_finger (cid:4) (cid:3) 1 part.Proximal_phalanx_oifDistal_phalanx_oif (cid:4) (cid:3) 1 attached_to.Middle_phalanx_oifMiddle_phalanx_oif (cid:4) (cid:3) 1 attached_to.Distal_phalanx_oifMiddle_phalanx_oif (cid:4) (cid:3) 1 attached_to.Proximal_phalanx_oif5 The suffix _of_index_finger has been abbreviated to _oif.(6)(7)(8)(9)(10)(11)(12)(13)(14)(15)(16)(17)(18)1284B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Proximal_phalanx_oif (cid:4) (cid:3) 1 attached_to.Middle_phalanx_oif(19)Fig. 3. Unintended model I(cid:5).Let I be an interpretation corresponding to Fig. 2e in the obvious way. Clearly, I satisfies K, which justifies the formalizationof Fig. 2e using K.Let us extend K with knowledge about bone fractures. For example, let K(cid:5)be an extension of K with axiom (20) statingthat, if the middle phalanx of the index finger is broken, then the index finger is broken as well:Index_finger (cid:8) ∃part.(Middle_phalanx_oif (cid:8) Broken) (cid:4) Broken(20)Given the structure of the index finger shown in Fig. 2e, we might expect K(cid:5)phalanx that is attached to a broken middle phalanx, then the index finger is broken as well:to imply that if the index finger has a distal(cid:11)Index_finger (cid:8) ∃part.(cid:12)Distal_phalanx_oif (cid:8) ∃attached_to.(Middle_phalanx_oif (cid:8) Broken)(cid:4) Broken(21)That K(cid:5)Unfortunately, K(cid:5)is underconstrained, and some models of K(cid:5)do not correspond to the structure of the index fingershown in Fig. 2e. Axioms (7) and (9) both imply the existence of middle phalanges of the index finger, but K(cid:5)does notcapture the fact that, for any given index finger, these two middle phalanges must be the same object. Thus, the infiniteinterpretation I, even if the middle phalanx of the index finger is broken, themiddle phalanges at the second level of the model need not be broken; hence, axiom (20) does not necessarily derive thatthe index finger is broken and, consequently, axiom (21) is not a consequence of K(cid:5)shown in Fig. 3 is also a model of K(cid:5). In I.(cid:5)(cid:5)is underconstrained can also lead to problems with the performance of reasoning. In order to disprove anentailment, a DL reasoner will try to construct a “canonical” model of K(cid:5)—that is, a model that contains as little informationderivable from K(cid:5)as possible. Such models, however, are often highly repetitive and much larger than the intended ones, soconstructing them can be costly. The interpretation Iis an example of such a “canonical” model, and it contains an infinitetree of phalanges instead of a finite structure shown in Fig. 2e. In our experience, this is the main reason why DL reasonerscannot process complex ontologies such as FMA and certain versions of GALEN.These problems could be addressed by ensuring that all models of K(cid:5)resemble as much as possible the intended con-ceptualization shown in Figs. 2b–2e. DL axioms, however, are usually syntactically restricted such that the resulting logicexhibits (a variant of) the tree model property [39]: whenever a DL knowledge base has a model, it has a model of a certaintree shape (such as I). The tree model property is generally considered desirable because its absence often leads to theundecidability of reasoning. At the same time, however, it also means that we must leave the confines of DLs if we want tofaithfully represent structured objects.(cid:5)(cid:5)Rule formalisms such as datalog [1] can routinely express conditions over nontree structures; however, they typicallydo not provide for existential quantification. Such rules can thus be applied only to the individuals explicitly mentionedin a knowledge base and cannot express schema constraints such as “each patient has some (unknown) hand.” Ontologylanguages such as OWL-Flight [12], Telos [33], and the logic programming variant of F-Logic [22] are based on datalog andtherefore share its restrictions.Combining rules with description logics overcomes the limitations of datalog and yields a very expressive knowledgerepresentation formalism capable of axiomatizing nontree structures [20,26]. Similarly, the first-order version of F-Logic [22]B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091285provides a combination of existential quantification with rules. Such solutions, however, are quite complex and susceptibleto modeling errors. Furthermore, the extension of DLs with rules is undecidable even for very simple DLs [26], and the sameis the case for the first-order version of F-Logic.A number of decidable combinations of DLs and rules have been proposed in practice, and decidability is typicallyachieved by syntactically restricting the applicability of the rules. For example, DL-safe rules [32] are restricted such thatthey apply only to the explicitly named objects. Role-safe [26] and weakly safe [36] rules also impose restrictions that pre-vent the application of the rules to arbitrary elements of the domain, and similar restrictions are also employed by variousnonmonotonic rule extensions of DLs [15,29,36]. Consequently, such extensions are useful mainly for query answering, butnot for schema modeling.To address the problems outlined in this section, SROIQ [25] provides complex role inclusions—axioms of the formR1 ◦ · · · ◦ Rn (cid:4) S, where ◦ stands for role composition. Such axioms are restricted in a way that ensures decidability of thebasic reasoning problems. The use of complex role inclusions solves some of the identified problems; however, they stillcannot axiomatize arbitrary structures such as the one in Fig. 2b.In the rest of this paper, we propose a formalism for modeling arbitrarily connected structured objects by extending DLswith description graphs. For example, Fig. 2d can be seen as a description graph showing that each thumb has a proximal anda distal phalanx that are attached to each other. Different structured objects can be represented using separate descriptiongraphs, which can be appropriately connected. For example, the hand and the thumb can be represented using two differentdescription graphs, which are connected to each other. Furthermore, structured objects often need to be modeled at differentlevels of abstraction. For example, we would like to describe the abstract structure common to all fingers as shown inFig. 2c, and then specialize it for, say, the index finger by introducing the middle phalanx as shown in Fig. 2e. To this end,our formalism provides for graph specialization statements, which can represent the fact that one structure is more generalthan another. Finally, in order to represent conditional aspects of the domain, we also allow for arbitrary rules over thedescription graphs; for example, we can state that, if a bone in the hand is fractured, then the hand is fractured as well. Weintroduce the formalism in the following section, and show how it can be used to exclude unintended infinite models suchas the one in Fig. 3.Our formalism is related to weakly guarded tuple generating dependencies [9] and the guarded fragment of first-order logic [2], which allow for axiomatizing nontree structures of bounded treewidth. Unlike these formalisms, however,graph-extended knowledge bases allow for functional roles and arbitrary rules; furthermore, we present different syntacticrestrictions to achieve decidability of reasoning.4. A formalism for modeling complex structuresIn this section, we present our knowledge representation formalism. We start by defining the notion of a descriptiongraph.Definition 5 (Description graph). An (cid:4)-ary description graph G = (V , E, λ, M) is a directed labeled graph where• V = {1, . . . , (cid:4)} is a set of (cid:4) vertices,• E ⊆ V × V is a set of edges,• λ is a labeling function that assigns a set of literal concepts λ(cid:18)i(cid:19) ⊆ N L to each vertex i ∈ V and a set of atomic rolesλ(cid:18)i, j(cid:19) ⊆ N R to each edge (cid:18)i, j(cid:19) ∈ E, and• M ⊆ NC is a set of main concepts for G.For A an atomic concept, V A is the set of vertices that contain A in their label; that is, V A = {k ∈ V | A ∈ λ(cid:18)k(cid:19)}.We define the vertices of G to be integers in order to be able to use them as indices. The main concepts of G identifythe objects whose structure is defined by G. In Fig. 2, main concepts are framed with rounded rectangles. Thus, the mainconcepts for the description graph shown in Fig. 2b are Hand and Palm, meaning that this graph defines the structure of allhands and palms. Intuitively, an instance of a main concept implies the existence of the corresponding graph instance of G.R→ j to denote that a description graph contains an R-labeled edgeAs a notational convenience, we sometimes use ifrom a vertex i to a vertex j.In order to represent conditions over the structure of a graph, our formalism allows for graph rules. The followingdefinition refines the general notion of a rule introduced in Section 2.2.Definition 6 (Graph rule). A graph atom is an atom of the form G(t1, . . . , t(cid:4)), where G is an (cid:4)-ary description graph andti ∈ N I ∪ N V for 1 (cid:3) i (cid:3) (cid:4). A graph rule is a rule in which all concepts and roles in atoms are atomic, and whose head andbody can contain graph atoms.Next, we introduce graph specializations, which allow us to represent structured objects at different levels of abstraction.For example, we can capture the abstract structure common to all fingers by a description graph G finger shown in Fig. 2c, and1286B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Table 4Satisfaction of GBox elements in an interpretation.I |(cid:17) G for G = (V , E, λ, M) iffKey property:∀x1, . . . , x(cid:4), y1, . . . , y(cid:4) ∈ (cid:15)I : (cid:18)x1, . . . , x(cid:4)(cid:19) ∈ G I ∧ (cid:18) y1, . . . , y(cid:4)(cid:19) ∈ G I ∧(cid:3)1(cid:2)i(cid:2)(cid:4)xi = yi →(cid:2)1(cid:2) j(cid:2)(cid:4)x j = y jDisjointness property:∀x1, . . . , x(cid:4), y1, . . . , y(cid:4) ∈ (cid:15)I : (cid:18)x1, . . . , x(cid:4)(cid:19) ∈ G I ∧ (cid:18) y1, . . . , y(cid:4)(cid:19) ∈ G I →Start property: for each atomic concept A ∈ M,∀x ∈ (cid:15)I : x ∈ A I → ∃x1, . . . , x(cid:4) ∈ (cid:15)I : (cid:18)x1, . . . , x(cid:4)(cid:19) ∈ G I ∧(cid:3)k∈V Ax = xk(cid:2)1(cid:2)i< j(cid:2)(cid:4)xi (cid:14)= y jLayout property:∀x1, . . . , x(cid:4) ∈ (cid:15)I : (cid:18)x1, . . . , x(cid:4)(cid:19) ∈ G I →(cid:2)i∈V ,B∈λ(cid:18)i(cid:19)xi ∈ B I ∧(cid:2)(cid:18)xi , x j (cid:19) ∈ R I(cid:18)i, j(cid:19)∈E,R∈λ(cid:18)i, j(cid:19)I |(cid:17) G 1 (cid:4) G 2 iff∀x1, . . . , x(cid:4)2∈ (cid:15)I : (cid:18)x1, . . . , x(cid:4)1 , . . . , x(cid:4)2(cid:19) ∈ G I2→ (cid:18)x1, . . . , x(cid:4)1(cid:19) ∈ G I1I |(cid:17) G 1[v 1, . . . , vn] ↔ G 2[w 1, . . . , wn] iff, for each 1 (cid:3) i (cid:3) n,∧ (cid:18) y1, . . . , y(cid:4)2∀x1, . . . , x(cid:4)1 , y1, . . . , y(cid:4)2∈ (cid:15)I : (cid:18)x1, . . . , x(cid:4)1(cid:19) ∈ G I1(cid:19) ∈ G I2∧ xv i= y w i→(cid:2)1(cid:2) j(cid:2)nxv j= y w jNote. (cid:4)(i) is the arity of the description graph G(i).we can specialize this structure for the thumb by introducing a description graph G thumb shown in Fig. 2d. The followinggraph specialization axiom captures the relationship between these two description graphs:G finger (cid:4) G thumb(22)Definition 7 (Graph specialization). A graph specialization is an axiom of the form G 1 (cid:4) G 2, where G 1 = (V 1, E1, λ1, M1) andG 2 = (V 2, E2, λ2, M2) are description graphs with V 1 ⊆ V 2.Next, we introduce axioms that allow us to appropriately connect graph instances. For example, the description graphG hand shown in Fig. 2b contains the vertices 3 and 4 that represent the thumb and its proximal phalanx, which correspondto the vertices 1 and 3 of the description graph G thumb shown in Fig. 2d. We can specify this correspondence using thefollowing graph alignment:G hand[3, 4] ↔ G thumb[1, 3](23)This axiom ensures that, whenever two instances of G hand and G thumb share the thumb vertex, they share a proximal phalanxvertex as well, and vice versa.Definition 8 (Graph alignment). A graph alignment is an axiom of the form G 1[v 1, . . . , vn] ↔ G 2[w 1, . . . wn], where G 1 andG 2 are description graphs with sets of vertices V 1 and V 2, respectively, and v i ∈ V 1 and w i ∈ V 2 for 1 (cid:3) i (cid:3) n.Finally, we define GBoxes and graph-extended knowledge bases.Definition 9 (Formalism). A graph box (GBox) is a tuple G = (GG , GS , G A) where GG , GS , and G A are finite sets of descriptiongraphs, graph specializations over GG , and graph alignments over GG , respectively. The definition of ABoxes from Section 2.1is extended to allow for graph assertions of the form G(a1, . . . , a(cid:4)) where G is an (cid:4)-ary graph and each ai , 1 (cid:3) i (cid:3) (cid:4), is anindividual. A graph-extended knowledge base is a 4-tuple K = (T , P, G, A) where T is a TBox, P is a finite set of connectedgraph rules, G is a GBox, and A is an ABox.Next, we define the semantics of the formalism.Definition 10 (Semantics). An interpretation I = ((cid:15)I , ·I ) is defined as usual, with the addition that it interprets each (cid:4)-arydescription graph G as an (cid:4)-ary relation over (cid:15)I —that is, G I ⊆ ((cid:15)I )(cid:4). Each tuple in G I is called a graph instance of G. A graphassertion is satisfied in I , written I |(cid:17) G(a1, . . . , a(cid:4)), if and only if (cid:18)aI(cid:19) ∈ G I . Satisfaction of a description graph, graphspecialization, and graph alignment in I is defined in Table 4. A knowledge base K = (T , P, G, A) is satisfied in I , writtenI |(cid:17) K, if all its components are satisfied in I .1, . . . , aI(cid:4)The key and disjointness properties in Table 4 ensure that no two distinct instances of G can share a vertex; for example,different instances of G hand cannot share the vertex that represents the thumb. These properties are required to ensure thatB. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091287the representation of the structured objects is bounded, which is a core assumption of our formalism. In particular, theyprevent the existence of infinite “chains” of instances of G hand, which is crucial for the decidability of our formalism.The start property in Table 4 ensures that each instance of a main concept A of G occurs in an instance of G. Forexample, since Hand is a main concept for G hand, each instance of Hand must occur as vertex 1 in an instance of G hand.Similarly, vertex 3 of G hand is labeled with Thumb, which is the main concept of G thumb; hence, each vertex 3 in an instanceof G hand is also a vertex 1 in an instance of G thumb (but not the other way around). The disjunction in the start propertyhandles the case when a main concept labels multiple vertices. For example, if we were to describe the hand and the fivefingers in a single graph without a distinction between the five fingers, then, given an instance of a Finger, we would haveto guess which of the five fingers we are dealing with. Finally, the layout property ensures that each instance of G is labeledand connected as specified in the definition of G.Graph specializations are interpreted as inclusions over the graph relations; for example, axiom (22) states that eachinstance of a thumb is also an instance of a finger. The two graphs share all the vertices of the more general graph, and themore specific graph can introduce additional vertices.Finally, graph alignments state that, whenever two graphs share some vertex from the specified list, then they share allother vertices from the list as well. For example, alignment (23) states that, if instances of G hand and G thumb share vertices3 and 1, respectively, then they must also share vertices 4 and 3, respectively.The main reasoning problem for graph-extended knowledge bases is satisfiability checking, since concept subsumptionand instance checking can be reduced to satisfiability as usual.Description graphs allow us to faithfully represent the nontree connections between the parts of a structured object. Forcontains axioms (13)–(20), and G(cid:5)(cid:5)correctly axiomatizes the structure of the index fingerexample, consider the graph-extended knowledge base K(cid:5)(cid:5) = (T (cid:5)(cid:5), ∅, G(cid:5)(cid:5), ∅) where T (cid:5)(cid:5)contains description graph G index_finger shown in Fig. 2e. The GBox G(cid:5)(cid:5)and, unlike the DL knowledge base K(cid:5)from Section 3, the graph-extended knowledge base K(cid:5)(cid:5)entails axiom (21).Note that Definition 10 does not ensure that objects in an instance of a description graph G are connected only bythe edges as specified in G—that is, the maximum cardinality of the edges in an instance of G is not fixed. Because ofthat, axioms (13)–(19) are strictly necessary for the inference from the previous paragraph. Although Definition 10 couldbe straightforwardly extended with conditions that impose appropriate cardinality restrictions, we refrain from doing so forseveral reasons. First, cardinalities can always be axiomatized explicitly as shown in the previous example, so the presentedformalism is more general. Second, the adopted approach allows us to study at a finer-grained level the impact of variousconstructs on the decidability of reasoning.5. Undecidability of reasoningChecking the satisfiability of a graph-extended knowledge base K = (T , P, G, A) is clearly undecidable since the com-bination of DLs such as ALC with unrestricted Horn rules is already undecidable [26]. We next show that, even if T = ∅,checking the satisfiability of K is undecidable due to an interaction between description graphs and unrestricted Horn rules.In our proof, we use the well-known undecidable problem of checking emptiness of the intersection of context-free gram-mars [18]. A context-free grammar is a tuple G = (T, N, P, S), where T is a finite set of terminal symbols, N a finite set ofnonterminal symbols, S ∈ N is a start symbol, and P ⊆ N × (T ∪ N)∗is a finite set of productions. The language generated by(cid:5)) over the same set of terminalG is denoted as L(G). Given two context-free grammars G = (T, N, P, S) and Gsymbols T and with N ∩ N(cid:5) = (T, N(cid:5)) = ∅ is undecidable [18].(cid:5) = ∅, checking whether L(G) ∩ L(G(cid:5), P(cid:5), SProposition 1. Checking the satisfiability of a graph-extended knowledge base K = (∅, P, G, A) where all rules in P are Horn andG = (GG , ∅, ∅) is undecidable.(cid:5) = (T, NProof. Let G = (T, N, P, S) and Gextended knowledge base KG,G(cid:5) that simulates the derivations of G and Gwith each symbol P ∈ T ∪ N ∪ NP ∪ P(cid:5) = ∅. We first construct a graph-. Let R P be an atomic role uniquely associated. The knowledge base KG,G(cid:5) contains a Horn rule of the form (24) for each production in(cid:5)) be two context-free grammars with N ∩ Nof the form P → Q 1.Q 2. . . . .Q n.(cid:5), P(cid:5), S(cid:5)(cid:5)(cid:5)R Q 1 (x0, x1) ∧ R Q 2 (x1, x2) ∧ · · · ∧ R Q n (xn−1, xn) → R P (x0, xn)(24)symbolP ∈ T,the GBox of KG,G(cid:5)contains description graphs G 1P= (V 1P , E 1P , λ1P , M1P ) andFor each terminalP , M2P , E 2G 2P= (V 2P , λ2P ) defined as follows:= { A}= {1, 2}M1P(cid:18)2(cid:19) = {B}V 1P(cid:18)1(cid:19) = { A}::G 1PG 2Pλ1Pλ2P= {1, 2}V 2P(cid:18)1(cid:19) = {B}λ1P= {B}M2P(cid:18)2(cid:19) = { A}λ2PR P→ 21R P→ 21Finally, the ABox of KG,G(cid:5) contains the assertion A(a).1288B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Fig. 4. Grid construction for ALCF .It is straightforward to see that KG,G(cid:5)is satisfiable. Let I be any interpretation obtained by intersecting all models of∗KG,G(cid:5) that have the same interpretation domain (cid:15)I , and let w = P 1. . . . .Pn ∈ Tbe a finite word over the set of nonterminalsymbols T. Due to the GBox of KG,G(cid:5) , domain objects {α0, . . . , αn} ⊆ (cid:15)I exists such that (cid:18)αi−1, αi(cid:19) ∈ R Ifor each 1 (cid:3) i (cid:3) n.P i—that is, for each nonterminal symbolIt is straightforward to see that the rules (24) encode the derivations of G and G). Now let KintQ ∈ N (resp. Q ∈ NG,G(cid:5)be the graph-extended knowledge obtained by extending KG,G(cid:5) with the Horn rule (25).Q if and only if a derivation of Q from w exists in G (resp. G), we have (cid:18)α0, αn(cid:19) ∈ R I(cid:5)(cid:5)(cid:5)R S (x, y) ∧ R S(cid:5) (x, y) → ⊥(25)Clearly, KintG,G(cid:5) is unsatisfiable if and only if L(G) ∩ L(G(cid:5)) (cid:14)= ∅, which proves the claim of this proposition. (cid:2)One might try to ensure decidability by requiring that P = ∅. As we show next, this is not sufficient: an interactionbetween description graphs in G and number restrictions in T is another source of undecidability. In our proof, we presentreductions from the well-known domino tiling problem. A domino system is a triple S = (D, H, V) where D = {D 1, . . . , Dm}is a set of tiles, and H ⊆ D × D and V ⊆ D × D are horizontal and vertical compatibility conditions, respectively. An S-tilingis a function τ : N × N → D such that (cid:18)τ (i, j), τ (i + 1, j)(cid:19) ∈ H and (cid:18)τ (i, j), τ (i, j + 1)(cid:19) ∈ V.6 It is well known that, given adomino system S, checking whether an S-tiling exists is undecidable [7].Proposition 2. Checking the satisfiability of a graph-extended knowledge base K = (T , ∅, G, A) with T a TBox in ALCF andG = (GG , ∅, ∅) is undecidable.Proof. We first present a graph-extended KB Kgrid that implies the existence of an infinite grid. The TBox of Kgrid containsthe following ALCF axioms:(cid:6) (cid:4) (cid:3) 1 H(cid:6) (cid:4) (cid:3) 1 V(27)The ABox of Kgrid consists of a single assertion A1(a). The GBox of Kgrid contains four graphs G i = (V i, E i, λi, Mi), 1 (cid:3) i (cid:3) 4.The sets of vertices V i , edges E i , and the labels of the edges are the same for all G i and are shown in Fig. 4a. Furthermore,Mi = { Ai}, and the labels λi of vertices in each G i are as given next:(26)(cid:9)(cid:9)(cid:9)(cid:9)λ1 =λ2 =λ3 =λ4 =1 (cid:25)→ { A1}, 2 (cid:25)→ { A2}, 3 (cid:25)→ { A3}, 4 (cid:25)→ { A4}1 (cid:25)→ { A2}, 2 (cid:25)→ { A1}, 3 (cid:25)→ { A4}, 4 (cid:25)→ { A3}1 (cid:25)→ { A3}, 2 (cid:25)→ { A4}, 3 (cid:25)→ { A1}, 4 (cid:25)→ { A2}1 (cid:25)→ { A4}, 2 (cid:25)→ { A3}, 3 (cid:25)→ { A2}, 4 (cid:25)→ { A1}(cid:10)(cid:10)(cid:10)(cid:10)6 N is the set of all natural numbers.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091289We next show that Kgrid is satisfiable and that each model I of Kgrid contains an infinite two-dimensional grid, as shownin Fig. 4b. Individual a corresponds to the top left corner of the grid, and instances of description graphs are labeled usinglowercase letters. Since A1 is a main concept for G 1, I contains the instance g1 of G 1. Vertex 2 of g1 is labeled with A2, soI contains the instance g2 of G 2; since V is functional by (27), the two graphs are “glued together” into a grid. By a similarargument, one can see that I contains the instance g3 of G 3 and the instance g4 of G 4, which are “glued” with g1 and g2into a grid. By repeating the same argument, it is clear that the grid extends indefinitely to the right and downwards.For a domino system S = (D, H, V), let KS be the graph-extended knowledge base obtained by extending the TBox ofKgrid with the following axioms, where each tile D i ∈ D, 1 (cid:3) i (cid:3) m, corresponds to an atomic concept D i :(cid:6) (cid:4) D1 (cid:9) · · · (cid:9) DmD i (cid:8) D j (cid:4) ⊥ for each 1 (cid:3) i < j (cid:3) mD i (cid:8) ∃H.D j (cid:4) ⊥ for each (D i, D j) /∈ HD i (cid:8) ∃V .D j (cid:4) ⊥ for each (D i, D j) /∈ V(28)(29)(30)(31)These axioms ensure that each point in a grid is labeled with some D i according to the compatibility conditions of S. Thus,if KS is satisfiable, an S-tiling can be extracted from a model of KS; conversely, if an S-tiling exists, a model of KS can beobtained by labeling vertices in the grid shown in Fig. 4b according to the S-tiling. These two facts then imply the claim ofthis proposition. (cid:2)The proofs of Propositions 1 and 2 suggest that undecidability arises partly because graph-extended knowledge bases canaxiomatize models containing unbounded sequences of description graph instances. In practice, however, structured objectsare usually modeled up to a certain level of granularity, which naturally determines a bound on the sequence of graphs oneneeds to represent. In such cases, we can describe the structure of an object by an acyclic hierarchy of parts; for example,carpal bones are parts of the hand, but the hand is not a part of the carpal bones. To reflect the acyclic nature of such arepresentation, it therefore seems reasonable to impose an acyclicity condition in our formalism. Intuitively, this conditionensures that the description graphs are arranged in a hierarchical manner and that their instantiation always provides abounded representation.Definition 11 (Acyclic GBox). Let G = (GG , GS , G A) be a GBox, and let (cid:4)∗ be the reflexive–transitive closure of the graphspecialization relation (cid:4) in GS . The GBox G is acyclic if a strict (i.e., an irreflexive and transitive, but not necessarily total)order ≺ on GG exists such that, for each G = (V , E, λ, M) and G, and for eachA ∈ M(cid:5)) in GG such that G (cid:14)(cid:30) G, the following two conditions hold:(cid:5), λ(cid:5), M(cid:5) = (V(cid:5), E(cid:5)(cid:5)• G• G(cid:5) (cid:4)∗ G implies ¬ A ∈ λ(cid:18)i(cid:19) for each i ∈ V \ V(cid:5) (cid:14)(cid:4)∗ G implies ¬ A ∈ λ(cid:18)i(cid:19) for each i ∈ V .(cid:5); andA graph-extended knowledge base is acyclic if its GBox is acyclic.Intuitively, G 1 ≺ G 2 means that an instance of G 1 is allowed to imply the existence of an instance of G 2. In our example,we would have G hand ≺ G finger and G hand ≺ G thumb, which allows an instance of a hand to imply the existence of a fingerand/or a thumb. We would also have G finger ≺ G thumb, since finger is more general than thumb. The conditions in Defini-tion 11 state that, if G 1 (cid:14)≺ G 2, then an instance of G 2 cannot imply the existence of an instance of G 1 because each node ofG 2 must be labeled with a negation of each start concept of G 1. For example, since G thumb (cid:14)≺ G hand, no vertex in an instanceof G thumb should ever become labeled with a main concept of G hand. Effectively, this prevents cyclic implications betweeninstances of description graphs.Requiring the GBox to be acyclic invalidates Proposition 1. In fact, checking the satisfiability of K = (∅, P, G, A) where Gis acyclic is decidable: G can then axiomatize only structures that can be obtained by unfolding G in a straightforward way,so it does not matter if the rules in P are not tree-like. Furthermore, in Section 6.2 we show that checking satisfiabilityof K = (T , ∅, G, A) is decidable if T is in SHOQ+. We next show, however, that an interaction between inverse roles,number restrictions, and description graphs leads to undecidability even if G is acyclic.Proposition 3. Checking the satisfiability of a graph-extended knowledge base K = (T , ∅, G, A) with T a TBox in ALCIF andG = (GG , ∅, ∅) an acyclic GBox is undecidable.Proof. Let Kgrid be the graph-extended KB in which the GBox contains four description graphs G i = (V i, E i, λi, Mi), 1 (cid:3) i (cid:3) 4with the structure as shown in Fig. 5a and Mi = { Ai}. To make the GBox acyclic, we assume that all vertices in each G i are1290B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Fig. 5. Grid construction for ALCIF .labeled with ¬ A j for i (cid:14)= j; these negative labels are not shown in Fig. 5a for the sake of clarity. The ABox of Kgrid containsthe assertion A1(a). Finally, the TBox of Kgrid contains the following ALCIF axioms:(cid:6) (cid:4) (cid:3) 1 R−(cid:6) (cid:4) (cid:3) 1 HB1 (cid:4) ∃R. A2B2 (cid:4) ∃R. A1B3 (cid:4) ∃R. A4B4 (cid:4) ∃R. A3(cid:6) (cid:4) (cid:3) 1 VC1 (cid:4) ∃R. A4C2 (cid:4) ∃R. A3C3 (cid:4) ∃R. A2C4 (cid:4) ∃R. A1We next show that Kgrid is satisfiable and that each model I of Kgrid contains an infinite two-dimensional grid, as shownin Fig. 5b. Instances of description graphs are denoted with lowercase letters. Due to the ABox assertion A1(a), I containsthe instance g1 of G 1. Due to B1 (cid:4) ∃R. A2, vertex 2 of g1 is connected with an instance of A2, so I contains the instanceg2 of G 2. Since R is inverse-functional, however, vertex 1 of g2 must be the same as vertex 2 of g1, as shown by the arrowm1. Furthermore, since V is functional, vertex 4 of g2 must be the same as vertex 3 of g1, as shown by the arrow m2.Hence, g1 and g2 form the top two squares of the grid. By a similar argument, one can see that I contains the instance g4of G 4, and that g1 and g4 share the vertices as shown by the arrows m3 and m4. Finally, I contains the instances g13 and3 of G 3, which share vertices with g2 and g4 as shown my the arrows m5–m8. Thus, g1g13 share vertex 1, so by the= g3, and g4 are connected in I= g2key property they must be the one and the same instance. Consequently, g1, g2, g133in a grid-like manner. Note that no two instances gi share vertex 5, so I satisfies the concept ¬ Ai occurring in the label ofeach vertex of G j for i (cid:14)= j. By repeating the same argument, it is clear that the grid extends indefinitely to the right anddownwards.3 and g2Now given a domino system S = (D, H, V), we can extend Kgrid with axioms (28)–(31) to a knowledge base KS that issatisfiable if and only if an S-tiling exists, which proves our claim. (cid:2)This result can be intuitively understood as follows. Let G 1 and G 2 be description graphs with start concepts A1 and A2,respectively; furthermore, let g1 and g2 be instances of G 1 and G 2, respectively. Then, inverse roles and number restrictionscan merge g1 and g2 such that the vertex of g1 labeled with A1 is not contained in g2 and, conversely, the vertex ofg2 labeled with A2 is not contained in g1. Therefore, even if all vertices of G 1 and G 2 are labeled with ¬ A2 and ¬ A1,respectively, it is still possible to enforce the existence of infinite non-tree-like structures.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–130912916. Reasoning with graph-extended knowledge basesIn this section, we present an algorithm for reasoning with a graph-extended knowledge base K = (T , P, G, A). In orderto overcome the undecidability results from the previous section, in Section 6.1 we introduce role separation as a way ofattaining decidability. Intuitively, role separation places restrictions on the usage of atomic roles in T , P , and G in orderto limit the possible interaction between different types of axioms. In Section 6.2 we then present a hypertableau-basedalgorithm for checking the satisfiability of K. When K is weakly separated (i.e., when the roles occurring in P do not occurin T and vice versa), our algorithm provides a decision procedure if T is in SHOQ+and G is acyclic G and a semidecisionprocedure if T is in SHOIQ+. Finally, in Section 6.3 we show that the decidability of the latter case can be regained byrequiring K to be strongly separated (i.e., that the roles occurring in P and G do not occur in T and vice versa).6.1. Role separationLet K = (T , P, G, A) be a graph-extended KB. In Section 5, we proposed acyclicity of G as a way to limit the size ofthe structures whose existence is implied by G. As expected, acyclicity invalidates the proof of Proposition 2. The proof ofProposition 3, however, reveals that an interaction between graphs, inverse roles, and functionality axioms can circumventthe desired effects of acyclicity. Thus, one way of ensuring decidability is to restrict the interaction between T , P , and G byplacing restrictions on the usage of roles. The general approach is captured by the following definition, which is specializedin the following sections.Definition 12 (Role separation). A role separation scheme Λ = (N RT , N RP , N RG ) is a triple where all N RT , N RP , and N RG are(not necessarily disjoint) subsets of the set of atomic roles N R . The roles in N RT , N RP , and N RG are called T -, P -, andG-roles, respectively. A graph-extended knowledge base K = (T , P, G, A) is Λ-separated if all roles occurring in T , P , andG are T -, P -, and G-roles, respectively.A similar idea has been used to ensure decidability of the fusions of Abstract Description Systems (ADSs) [5]: the compo-nent ADSs can share concepts, but the interaction through roles is restricted to ensure decidability. The separation into T -,P - and G-roles is similar in spirit. ADSs, however, lack standard first-order variables, so they cannot directly represent arbi-trarily connected structures and rules. The latter could potentially be axiomatized using an ADS; however, such an encodingis likely to be complex and therefore not practicable. Furthermore, fusions of ADSs require a strict separation of roles, whichrules out weakly separated knowledge bases (see Section 6.2).Similarly to the standard hypertableau algorithm presented in Section 2.3, our algorithm first preprocesses K into a setof rules R, a GBox G, and an ABox A. We next define a notion of Λ-admissibility for (R, G, A) that identifies the typesof inputs our core algorithm can handle. This notion closely parallels Definition 12 and, as we discuss shortly, there is astraightforward relationship between Λ-separation for knowledge bases and Λ-admissibility for the algorithm inputs.Definition 13 (Admissibility). Let R be a set of rules, G a GBox, A an ABox, and Λ = (N RT , N RP , N RG ) a role separationscheme. The triple (R, G, A) is Λ-admissible if all roles in G are G-roles, A is an input ABox, and R can be separated intodisjoint subsets RT and RP of T - and P -rules, respectively, such that• each rule r ∈ RT is an HT-rule and all roles in r are T -roles, and• each rule r ∈ RP is a connected graph rule and all roles in r are P -roles.A Λ-admissible triple (R, G, A) is simple if all rules in RT are simple HT-rules, and (R, G, A) is acyclic if G is acyclic.Let K = (T , P, G, A) be a graph-extended KB, ΞT (T ) and A(cid:5) = A ∪ ΞA(T ) the result of preprocessing T using thepreprocessing transformation from [31, Section 4.1] (see Section 2.3 for a summary), and R = P ∪ ΞT (T ). By inspectingthe transformation it is straightforward to see that, for each role separation scheme Λ, if K is Λ-separated, then (R, G, A(cid:5))is Λ-admissible; if T is in SHOQ+, then (R, G, A(cid:5)) is simple; and if G is acyclic, then (R, G, A(cid:5)) is acyclic as well.Furthermore, if K does not contain transitivity axioms, it is trivial to see that K is equisatisfiable with (R, G, A(cid:5)). Finally, ifΛ is such that N RT ∩ N RP = ∅, then there is no interaction between T and P , so transitivity axioms in T can be encodedinto GCIs in the same way as in [31, Section 4.1] without affecting satisfiability. Therefore, we omit the details of thepreprocessing phase for the sake of brevity and present an algorithm that decides the satisfiability of an admissible triple(R, G, A).6.2. Weakly separated knowledge basesWe now define a notion of weak role separation.Definition 14 (Weak separation). A role separation scheme (N RT , N RP , N RG ) is weak if N RT ∩ N RP = ∅. A graph-extendedknowledge base K is weakly separated if a weak role separation scheme Λ exists such that K is Λ-separated. Similarly, for1292B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Fig. 6. Example derivation of the hypertableau algorithm.R a set of rules, G a GBox, and A an ABox, (R, G, A) is weakly admissible if a weak role separation scheme Λ exists suchthat (R, G, A) is Λ-admissible.Intuitively, weak separation prevents any interaction between T and P and thus avoids well-known sources of undecid-ability, such as the ones identified in [26]. From a modeling point of view, weak separation is interesting because it allowsone to describe general knowledge using TBox axioms and then to specialize such knowledge using description graphs. Forexample, even if the general structure of a finger were described using DL axioms (e.g., this description might be a partof a general, coarse-grained knowledge base that does not use description graphs), one could describe more specializedknowledge, such as the structure of an index finger, using graphs. One can thus choose the appropriate style of modelingfor knowledge at different levels of granularity. The main limitation of weak separation is that one cannot use rules toexpress knowledge about roles used in DL axioms. Thus, weak separation does not impose any additional restrictions ongraph-extended KBs beyond those that are already present in standard DL knowledge bases without description graphs.Note that DL-safe [32] need not satisfy the weak admissibility requirement; however, we do not consider such rules in thispaper because of their limited applicability to schema reasoning.We next present an algorithm that can be used to check the satisfiability of a weakly separated knowledge base K. Theformal definitions of the algorithm are rather intricate, so we first outline the main ideas by means of an example. Considerthe following graph-extended knowledge base K1 = (T1, P1, G1, A1):T1 = {C (cid:4) ∃R. A, B (cid:4) {b} }P1 = ∅A1 = {C(a)}G1 contains the following description graph:G:V = {1, 2, 3} λ(cid:18)1(cid:19) ={ A}λ(cid:18)2(cid:19) = {B}M = { A}λ(cid:18)3(cid:19) = {C}S→ 2T→ 3U→ 3121The preprocessing of T1 produces the ABox ΞA(T1) = {O b(b)} and the following set of rules ΞT (T1):C(x) → (∃R. A)(x)B(x) ∧ O b( yb) → x ≈ yb(34)1) is weakly admissible: all rules in R1 are HT-rules and, sinceLet R1 = ΞT (T1) and A11P = ∅, we can consider all roles to be T -roles.= ΞA(T1) ∪ A1. Clearly, (R1, G1, A1By successively applying the derivation rules shown in Tables 3 and 5 to R1, G1, and A11, our algorithm tries to construct1). The evolution of A1an ABox that represents a model of (R1, G1, A11 is shown in Fig. 6, where assertions derived by asingle application of a derivation rule are separated by dotted lines. Note that the derivation rules from Table 5 closelyfollow the semantic conditions on description graphs given in Definition 10.The Hyp-rule derives new assertions based on the contents of R: if the body of some rule r ∈ R can be matched toassertions in an ABox, an assertion from the head of r is derived nondeterministically. Thus, from C(a) and (33), the Hyp-rule derives the assertion ∃R. A(a).To satisfy this assertion, the (cid:2)-rule introduces a fresh tree successor s1 of a and it derives the assertions R(a, s1) andA(s1). To keep track of the successor relation, our algorithm represents individuals as finite strings of the form (cid:31).α1. . . . .αn,where αi are symbols, and (cid:31) is a special symbol that is used to make certain definitions simpler. Thus, the individual aactually corresponds to the string (cid:31).νa where νa is a name symbol; furthermore, s1 corresponds to the individual (cid:31).νa.τ ,where τ is a tree symbol. That s1 is a successor of a is evident from the fact that a = (cid:31).νa is a prefix of s1 = (cid:31).νa.τ .The concept A is a main concept in G so, due to the assertion A(s1), individual s1 must occur in an instance of Gat vertex 1; to ensure this, the hypertableau calculus contains the G∃-rule. An application of the G∃-rule to A(s1) derivesthe assertion G(s1, t1,1, t1,2). Individuals t1,1 and t1,2 are fresh graph successors of s1, which is reflected in their stringrepresentation: we have t1,1 = s1.γ1 = (cid:31).νa.τ .γ1 and t1,2 = s1.γ2 = (cid:31).νa.τ .γ2 where γ1 and γ2 are graph symbols. A tree or(32)(33)B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091293Fig. 7. A generalized forest-shaped ABox.named individual and all of its graph successors are said to form a cluster; individuals s1, t1,1, and t1,2 are an example ofsuch a cluster.In order to connect and label all the vertices in the instance of G, the hypertableau calculus contains the G L -rule. Itsapplication to the current set of assertions adds, among others, the assertion C(t1,2). But then, the same inferences canbe repeated: the Hyp-rule derives ∃R. A(t1,2), the (cid:2)-rule derives R(t1,2, s2) and A(s2) where s2 = t1,2.τ = (cid:31).νa.τ .γ2.τ , theG∃-rule derives the graph assertion G(s2, t2,1, t2,2), and the G L -rule connects and labels all the vertices. Let A21 be the ABoxcontaining all assertions derived thus far; these are shown in Fig. 6.Clearly, unrestricted application of the (cid:2)- and G∃-rule would lead to nontermination. Therefore, just like the standard(hyper)tableau algorithms, our algorithm applies blocking. Roughly speaking, tree individuals s1 and s2 occur in A21 in thesame concepts, so the former individual blocks the latter—that is, the (cid:2)- and G∃-rule are not applied to (the successorsof) the blocked individual. Blocking is applicable because the ABox A21 is of structure that generalizes the notion of forest-shaped ABoxes from Section 2.3. In particular, A21 can thus be seen as consisting of three clusters, shown in Fig. 6 as theleft-most, middle, and right-most columns, connected by assertions R(a, s1) and R(t1,2, s2).In general, forest-shaped ABoxes are of the form shown in Fig. 7. They contain several kinds of individuals, which wesummarize next.• Root individuals are shown in Fig. 7 as black circles, and can be of two types:– Named individuals are the ones that occur in the input ABox.– Root individuals that are not named are introduced by the NI-rule (see Table 3) due to an interaction between in-verse roles, number restrictions, and nominals. An in-depth discussion of the rationale behind the NI-rule is availablein [31].• Tree individuals are introduced by the (cid:2)-rule in order to satisfy the existential quantifiers in the TBox of the knowledgebase, and they are shown in Fig. 7 as white circles with a single edge.• Graph individuals are introduced by the G∃-rule in order to satisfy the start property for the graphs in the GBox of theknowledge base, and they are shown in Fig. 7 as white circles with a double edge.The central concept in forest-shaped ABoxes is the notion of a cluster, whose formal definition ensures that all root individ-uals and all graph individuals of the form (cid:31).γi form a single cluster, and that each tree individual t and all graph individualsof the form t.γi form a cluster. Fig. 7 shows two clusters of two distinct tree individuals, where the member individualsare enclosed in a dashed line. The key idea behind clusters is that (i) individuals in the same cluster can be arbitrarilyconnected, but (ii) individuals from different clusters are connected in a tree-like manner. Thus, each forest-shaped ABoxcan be seen as a tree of clusters; we often call this structure a tree backbone. We exploit the tree backbone to generalize thenotions of blocking and pruning from the standard (hyper)tableau algorithms.In Lemma 1, we formalize the notion of forest-shaped ABoxes and show that, if (R, G, A) is weakly separated, then theapplication of the hypertableau derivation rules to a forest-shaped ABox always produces a forest-shaped ABox. Intuitively,the arbitrarily shaped P -rules in R can be applied only to assertions involving individuals in the same cluster, wherethey can introduce arbitrary connections; however, due to weak separation, they cannot affect the tree backbone. The treebackbone is constructed solely using the T -rules in R.Nominals, however, introduce a slight complication. Consider again the ABox A21. From B(t1,1), O b(b), and (34), the Hyp-rule derives t1,1 ≈ b. The ≈-rule then prunes t1,1 (i.e., it removes all graph and tree descendants or t1,1) and replaces itwith b; pruning is necessary in order to avoid nontermination due to repeated individual creation and merging, as in theso-called “yo-yo” problem [4]. After t1,1 is replaced with b, the ABox contains the graph assertion G(s1, b, t1,2) in which bis not from the same cluster as s1 and t1,2; thus, the ABox is not forest shaped. This is remedied through graph cleanup:the mentioned assertion is replaced with G(v 1, b, v 2), where v 1 = (cid:31).γ1 and v 2 = (cid:31).γ2 are fresh graph individuals from thecluster of b. The cluster of s1 and t1,2 is thus merged into the cluster of b in order to make the resulting ABox forest shaped.Furthermore, if graph cleanup is subsequently applied to an assertion of the form G(w 1, b, w 2), individuals w 1 and w 2 are1294B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309replaced with v 1 and v 2, respectively. Reusing individuals in graph cleanup is sound because of the key property in Table 4,and it allows us to establish a bound on the number of individuals introduced by the cleanup.We next define our algorithm formally. At this point, we assume the rules in R to be HT-rules, but do not assumethem to be simple. Thus, the algorithm can be applied to a triple (R, G, A) obtained by preprocessing a graph-extendedknowledge base whose TBox is in SHOIQ+.Definition 15. The hypertableau algorithm for checking the satisfiability of an admissible triple (R, G, A) is obtained bymodifying parts of Definition 2 as follows.Individuals. Let Στ , Σγ , and Σν be countably infinite and mutually disjoint sets of tree, graph, and name symbols, respec-tively, none of which contains the special symbol (cid:31). The set Σι of NI-symbols is the smallest set such that (cid:18)α, R, B, i(cid:19) ∈ Σιfor each α ∈ Σγ ∪ Σν ∪ Σι, role R, literal concept B, and integer i.An individual is a finite string of the form (cid:31).α1. . . . .αn with n (cid:2) 1 such that• α1 ∈ Σν ∪ Σγ ∪ Σι,• αi ∈ Σγ ∪ Στ for 2 (cid:3) i (cid:3) n, and• αi ∈ Σν ∪ Σγ ∪ Σι implies αi+1 /∈ Σγ for 1 (cid:3) i (cid:3) n.An individual with αn ∈ Στ (resp. αn ∈ Σγ ) is a tree (resp. graph) individual. Furthermore, an individual of the form (cid:31).αis a root individual, and if α ∈ Σν , the individual is named. Let N A , N I , and N O be the sets of all individuals, all namedindividuals, and all root individuals, respectively.For each individual x.α ∈ N A (with x possibly being equal to (cid:31)), we say that x.α is a successor of x, x is predecessor ofx.α, and descendant and ancestor are the transitive closures of successor and predecessor, respectively.Cluster. For each individual s ∈ N A , the function s! is defined as follows: s! = s if s is a tree individual; otherwise, s! = t for s = t.α. Individuals s and t are from the same cluster if s! = t!.Graph cleanup. Let A be an ABox containing an assertion G(u1, . . . , u(cid:4)) where some ui and u j are not from the samecluster, and ui! is an ancestor of u j . A cleanup of u j is an ABox obtained from A by pruning u j and then replacing in allthe remaining assertions u j with an individual t defined as follows:• if A contains another graph assertion G(v 1, . . . , v(cid:4)) such that ui = v i and v j is from the same cluster as ui , then t = v j ;• otherwise, t is a fresh graph successor of ui!.A graph cleanup of A is obtained from A by iteratively applying a cleanup to candidate individuals as long as possible and inany sequence that satisfies the following restriction: whenever cleanup is applicable to ui and u j such that ui is an ancestorof u j , cleanup is applied first to ui .7Merge target. An individual t is a merge target for an individual s if t is a named individual, or t is a root individual ands is not a named individual, or t is not a root individual and s is a descendant of t!.Merging. The ABox mergeA(s → t) is obtained from pruneA(s) by replacing s with t in all assertions, and then applyinga graph cleanup.Derivation rules. The derivation rules from Table 3 are extended with the ones from Table 5. In the NI-rule (see Table 3),for u = (cid:31).α a root individual, R a role, B a literal concept, and i an integer, rootfor(u, R, B, i) = (cid:31).(cid:18)α, R, B, i(cid:19).Rule precedence. The ≈-rule can be applied to a (possibly annotated) equality s ≈ t in an ABox A only if A does not(cid:3)n R.B to which the NI-rule is applicable. Furthermore, the G∃-rule is applicable to an ABox onlycontain an equality s ≈ t @uif the ⊥-, ≈-, G⊥-, G≈-, G(cid:4)-, and G L -rule are not applicable to the ABox.If (R, G, A) is weakly admissible and simple, the T -rules in R are simple HT-rules so, as explained in Section 2.3,the NI-rule then never gets applied, no root individual occurring in a derivation involves an NI-symbol, and pairwiseblocking can be simplified to single blocking. Therefore, we implicitly make these assumptions whenever (R, G, A) is sim-ple.We next show that, if (R, G, A) is weakly admissible, simple, and acyclic, the hypertableau algorithm becomes a decisionprocedure. Intuitively, if R is simple (i.e., if T is in SHOQ+), then different clusters cannot interact in an adverse waydue to number restrictions. Consider, for example, the ABox shown in Fig. 7. Individual u can be merged into t; however,t then “inherits” all main concepts asserted on u. Thus, if t and u occur in assertions with description graphs G 1 and G 2,respectively, such that G 1 (cid:14)≺ G 2, an inconsistency will be derived due to the acyclicity of G, which will prevent furtherapplication of the derivation rules. Hence, despite the fact that different clusters can be merged, we can establish a boundon the size of each cluster and thus prove termination.We next prove soundness, completeness, and termination of our algorithm. To this end, we first formalize the intuitivenotion of forest-shaped ABoxes and show that an application of a derivation rule always preserves this property.7 Note that, due to the freedom in choice of t and the order in which cleanup is applied to candidate individuals, graph cleanup of A is not uniquelydefined; however, for the purposes of our algorithm, any cleanup of A will suffice.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091295Table 5Derivation rules related to description graphs.G≈-ruleG⊥-rule{G(s1, . . . , s(cid:4)), G(t1, . . . , t(cid:4))} ⊆ A,si = ti for some 1 (cid:3) i (cid:3) (cid:4),{s j ≈ t j | 1 (cid:3) j (cid:3) (cid:4)} (cid:14)⊆ A, andIf 1.2.3.4. neither si nor ti is indirectly blocked for each 1 (cid:3) i (cid:3) (cid:4)then A1 := A ∪ {s j ≈ t j | 1 (cid:3) j (cid:3) (cid:4)}.If 1.2.3. neither si nor ti is indirectly blocked for each 1 (cid:3) i (cid:3) (cid:4){G(s1, . . . , s(cid:4)), G(t1, . . . , t(cid:4))} ⊆ A,si = t j for some i (cid:14)= j, andthen A1 := A ∪ {⊥}.If 1. A(s) ∈ A such that A ∈ M for some G = (V , E, λ, M) ∈ GG ,2.3.G∃-rules is not blocked in A, andfor each v i ∈ V A = {v 1, . . . , vn}, no individuals u1, . . . , u(cid:4) existsuch that G(u1, . . . , u(cid:4)) ∈ A and u v i= sthen Ai := A ∪ {G(t1, . . . , t(cid:4))} for each 1 (cid:3) i (cid:3) n wheret v i= s and all other tk are fresh graph successors of s!.G L -ruleG(cid:3)-ruleG↔-ruleIf 1. G(s1, . . . , s(cid:4)) ∈ A with G = (V , E, λ, M),2.3.{ A(si ) | A ∈ λ(cid:18)i(cid:19)} ∪ {R(si , s j ) | R ∈ λ(cid:18)i, j(cid:19)} (cid:14)⊆ A, andsi is not indirectly blocked for each 1 (cid:3) i (cid:3) (cid:4)then A1 := A ∪ { A(si ) | A ∈ λ(cid:18)i(cid:19)} ∪ {R(si , s j ) | R ∈ λ(cid:18)i, j(cid:19)}.If 1. G 1 (cid:4) G 2 ∈ GS ,2. G 2(s1, . . . , s(cid:4)2 ) ∈ A,3. G 1(s1, . . . , s(cid:4)1 ) /∈ A, and4.si is not indirectly blocked for each 1 (cid:3) i (cid:3) (cid:4)then A1 := A ∪ {G 1(s1, . . . , s(cid:4)1 )}.If 1. G 1[v 1, . . . , vn] ↔ G 2[w 1, . . . , wn] ∈ G A ,{G 1(s1, . . . , s(cid:4)1 ), G 2(t1, . . . , t(cid:4)2 )} ⊆ A,sv i{sv j2.3.4.5. neither si nor ti is indirectly blocked for each 1 (cid:3) i (cid:3) (cid:4)= t w i for some 1 (cid:3) i (cid:3) n,≈ t w j| 1 (cid:3) j (cid:3) n} (cid:14)⊆ A, andthen A1 := A ∪ {sv j≈ t w j| 1 (cid:3) j (cid:3) n}.Lemma 1. Let R be a set of rules, G a GBox, and A an ABox such that (R, G, A) is simple and weakly admissible. Then, each ABox A(cid:5)labeling a node of a derivation for (R, G, A) satisfies the following properties, for a and b root individuals, u(i) individuals, γi, γ j ∈ Σγ ,and τi, τ j ∈ Στ .where R is a T -role has the form R(u, u.τi), R(u, a), or R(u1, u2), where u1 and u2 are individuals from theis of the form a ≈ u, u1 ≈ u2, u1 ≈ u2.τi , or u.τi ≈ u.τ j , where u1 and u2 are individuals from the same cluster.with U a P -role, ui are all from the same cluster. Furthermore, for each graph—that is,, a tree or a root individual un from the same cluster as u0 exists such that u0 has a path to un in A(cid:5)individual u0 in A(cid:5)individuals u1, . . . , un−1 exist such that ui−1 and ui occur together in a graph assertion in A(cid:5)and U (u1, u2) ∈ A(cid:5)for each 1 (cid:3) i (cid:3) n.(4) In each O a(u) ∈ A(cid:5)with O a a nominal guard concept, the individual u is named. Furthermore, in each (cid:2) n R.B(u) ∈ A(cid:5), theconcept B is not a nominal guard concept.(5) For each tree individual tn in A(cid:5), individuals s0, . . . , sn and t0, . . . , tn−1 exist such that (i) s0 is a root individual, (ii) for each1 (cid:3) i (cid:3) n, individuals si and ti−1 are from the same cluster, and (iii) for each 0 (cid:3) i (cid:3) n, individual ti is a tree successor of si , andR i(si, ti) ∈ A(cid:5)for some T -role R i .Proof. Let Λ = (N RT , N RP , N RG ) be a weak role separation scheme and RT and RP the subsets of R satisfying theconditions of Definition 13. We prove this lemma by induction on the rule application. Since A is an input ABox, theinduction base is trivial. Assume that the claim holds for an ABox A0 and consider the inferences deriving some ABox Ai .(⊥- and G⊥-rule) The ABox A1 trivially satisfies Conditions 1–5.(G(cid:4)-, G↔-, G≈-, and G L -rule) These rules are always applied to individuals in the same cluster, so A1 satisfiesConditions 1–5.(G∃-rule) Assume that Ai is obtained by an application of the G∃-rule to an assertion A(s) ∈ A0. All individuals t1, . . . , t(cid:4)introduced by the rule application are from the same cluster as s, so Ai satisfies Conditions 1–5.((cid:2)-rule) Assume that A1 is obtained by an application of the (cid:2)-rule to an assertion (cid:2) n R.B(s) ∈ A0. All individualst1, . . . , tn introduced by the rule application are tree successors of s such that R(s, ti) ∈ A1, and B is not a nominal guardconcept, so A1 satisfies Conditions 1–5.(Hyp-rule) Assume that Ai is obtained from A0 by an application of the Hyp-rule to a rule r ∈ R. The rule r does notcontain a nominal guard concept in the head, so Ai satisfies Condition 4. Furthermore, the Hyp-rule does not introducefresh individuals, so Condition 5 trivially holds for Ai .(1) Each R(s, t) ∈ A(cid:5)same cluster.(2) Each s ≈ t ∈ A(cid:5)(3) In each G(u1, . . . , u(cid:4)) ∈ A(cid:5)1296B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309If r ∈ RP , then r is connected, so all variables in r are matched to individuals in the same cluster. All role atoms in thehead of r are P -roles due to weak separation, so Ai satisfies Conditions 1–3. Thus, let r ∈ RT be a simple HT-rule andconsider the types of assertions derived by instantiating an atom from the head of r.If s ≈ t is derived by instantiating an atom of the form x ≈ z j , then the body of r contains an atom O a(z j). This atom ismatched to an assertion O a(t) ∈ A0 in which, by Condition 4, t is a named individual. Hence, s ≈ t satisfies Condition 2.If s ≈ t is derived by instantiating yi ≈ y j in a simple HT-rule r, the body of r contains atoms R(x, yi) and S(x, y j) thatare matched to assertions R(u, s) ∈ A0 and S(u, t) ∈ A0 where R and S are T -roles, and each individual in {s, t} is fromthe same cluster as u, or a tree successor of u, or a root individual. Clearly, s ≈ t satisfies Condition 2.If R(s, t) is derived by instantiating R(x, x), then s = t; since s is from the same cluster as s, the assertion satisfiesCondition 1.If R(s, t) is derived by instantiating R(x, yi) in a simple HT-rule r, the body of r contains an atom S(x, yi) that is matchedto assertion S(s, t) ∈ A0, which satisfies Condition 1. Clearly, R(s, t) then satisfies Condition 1 as well.If R(s, t) is derived by instantiating R(x, z j) in a simple HT-rule r, the body of r contains an atom O a(z j) that is matchedto an assertion O a(t) ∈ A0. By Condition 4, t is a root individual, so R(s, t) satisfies Condition 1.(≈-rule) Consider the types of equality assertions in A0 to which the ≈-rule can be applied.For u1 ≈ u2 where u1 and u2 are from the same cluster, the ≈-rule prunes one individual—call it s—and replaces it withanother individual from the same cluster. Clearly, the resulting assertions satisfy Conditions 1 and 2. Furthermore, individuals occurs in the ABox after pruning only in assertions involving predecessors of s or individuals from the same cluster as s,so A1 satisfies Conditions 3–5 as well.For u1 ≈ u2.τi with u1 and u2 from the same cluster, the ≈-rule prunes u2.τi and replaces it with u1. Thus, assertions ofthe form R(u2, u2.τi), R(u2.τi, a), a ≈ u2.τi , u3 ≈ u2.τi with u2 and u3 from the same cluster, and u2.τi ≈ u2.τ j are changedinto assertions R(u2, u1), R(u1, a), a ≈ u1, u3 ≈ u1, and u1 ≈ u2.τ j , respectively, all of which satisfy Conditions 1 and 2.Furthermore, pruning removes all individuals from the cluster of u2.τi , so A1 satisfies Conditions 3–5 as well.For a ≈ u, the ≈-rule prunes u and merges it into a. Thus, assertions of the form R(v, u) and v ≈ u are changed intoassertions R(v, a) and v ≈ a, respectively, all of which satisfy Conditions 1 and 2. Replacing u with a in G(u1, . . . , un) whereui = u produces at first an assertion that does not satisfy Condition 3; however, graph cleanup then replaces each u j witha graph individual from the same cluster as a. Since A0 satisfies the second part of Condition 3, graph cleanup replacesall individuals from the cluster of u with graph individuals from the same cluster as a, so the resulting ABox satisfiesConditions 1–5. (cid:2)Theorem 1 summarizes the properties of our algorithm.Theorem 1. The following properties hold for each set of rules R, GBox G, and ABox A such that (R, G, A) is weakly admissible,simple, and acyclic:(1) if (R, G, A) is satisfiable, then each derivation for (R, G, A) is successful;(2) (R, G, A) is satisfiable if a successful derivation for (R, G, A) exists; and(3) each derivation for (R, G, A) is finite.Proof of Claim 1. The claim follows from the following property: if (R, G, A) is satisfiable and (cid:18)A1, . . . , An(cid:19) is the resultof applying a derivation rule to R, G, and A, then (R, G, Ai) is satisfiable for some 1 (cid:3) i (cid:3) n (and, consequently, Ai isclash-free). The proof is the same as in [31, Lemma 13] for all but the ≈-rule, in which the application of graph cleanup isnonstandard. Let I be a model of (R, G, A) and consider an application of the ≈-rule to s ≈ t ∈ A, producing an ABox A1.Let A(cid:5)be the ABox obtained from A by pruning s and then replacing it with t. Since I |(cid:17) s ≈ t, we have sI = t I , so clearly. The ABox A1 is obtained from A(cid:5)I |(cid:17) A(cid:5)by graph cleanup, which can additionally replace some individuals ui with v i .If v i is fresh, we can extend I to obtain a model of A1; otherwise, by the definition of graph cleanup, A(cid:5)contains graphassertions G(. . . , ui, . . .) and G(. . . , v i, . . .) so, by the key property from Definition 10, we have u Ij for each j. Clearly,j(R, G, A1) is satisfied in I . (cid:2)= v IProof of Claim 2. Let A(cid:5)next show how to construct a model of (R, G, A). To do this, we first introduce several definitions.be a clash-free ABox labeling a leaf of a successful derivation for (R, G, A). To prove the claim, weA path is a finite nonempty sequence of pairs of individuals p = [ x0(cid:5)x0(cid:5)(cid:5)(p) = xn. Further-]; we say that q is a successor of p, and p is a predecessor of q. The]. Let tail(p) = xn and tail, . . . , xn(cid:5)xnmore, let q = [p | xn+1, xn+1(cid:5)(cid:5)xxn+1n+1set of all paths P(A(cid:5)) is defined inductively as follows:] denote the path [ x0(cid:5)x0, . . . , xn(cid:5)xn] ∈ P(A(cid:5)) if a is a root individual and it occurs in A(cid:5);(cid:5)• [ aa• [p | sand• [p | sA(cid:5)s(cid:5) ] ∈ P(A(cid:5)) if p ∈ P(A(cid:5)) and ss(cid:5) ] ∈ P(A(cid:5)) if p ∈ P(A(cid:5)) and sby s.(cid:5)(cid:5)is a successor of tail(p), sis a successor of tail(p), s(cid:5)(cid:5)occurs in an assertion of A(cid:5), and soccurs in an assertion of A(cid:5), and s(cid:5)(cid:5)is not blocked in A(cid:5);is directly blocked inPaths p, q ∈ P(A(cid:5)) are from the same cluster, written p ∼ q, ifB. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091297• p = q, or• p = [ aa• individuals tail(p) and tail(q) are from the same cluster and either p and q are successors of the same path or one path] for a and b root individuals, or] and q = [ bbis a successor of the other path.We now define an interpretation I as follows, for each atomic concept A, each T -role R, each P -role U , and eachdescription graph G 8:(cid:15)I = P(A(cid:5)(cid:6)(cid:7)aI =aaaI = bI(cid:9)A I =R I =p | A(cid:6)(cid:9)(cid:13)aa)for each root individual a that occurs in A(cid:5)if a (cid:14)= b and (cid:26)a(cid:26)A(cid:5) = b(cid:11)(cid:12)tail(p)(cid:7)(cid:14) (cid:15)(cid:10)∈ A(cid:5)(cid:6)(cid:6)(cid:11)(cid:9)aa(cid:15) a is a root individual, p (cid:14)∼p,(cid:18)p1, p2(cid:19) | p1 ∼ p2 and R(cid:7)(cid:14) (cid:15)(cid:15)(cid:9)(cid:13)(cid:7)(cid:15) sp,s(cid:5)(cid:18)p1, p2(cid:19) | p1 ∼ p2 and U(cid:18)p1, . . . , p(cid:4)(cid:19) | pi ∼ p j for 1 (cid:3) i < j (cid:3) (cid:4) and G(cid:7), and R(cid:12)∈ A(cid:5)tail(p1), tail(p2)(cid:10)(cid:12)∈ A(cid:5)(cid:5)∈ A(cid:5)(cid:11)(cid:12)tail(p1), tail(p2)and R(cid:11)tail(p), s(cid:15) p (cid:14)∼(cid:15)(cid:15) ss(cid:5)(cid:9)(cid:9)pp(cid:11)(cid:6)(cid:10)U I =G I =(cid:12)(cid:10)∪∈ A(cid:5)(cid:11)tail(p), a(cid:10)∪(cid:12)tail(p1), . . . , tail(p(cid:4))(cid:10)∈ A(cid:5)A(cid:5)is an HT-ABox, so (cid:15)Iis not empty. To prove I |(cid:17) (R, G, A), we first show that, for each ps = [qs | ss(cid:5) ] and eachindividual w, the following claims hold (*):• R(s, s) ∈ A(cid:5)• If B(w) ∈ A(cid:5)(resp. A(s) ∈ A(cid:5)and LA(cid:5) (w) = LA(cid:5) (ssince the ⊥-rule is not applicable to A(cid:5)case implies ps /∈ A I .) iff (cid:18)ps, ps(cid:19) ∈ R I (resp. ps ∈ A I ): Immediate by the definition of I .(cid:5)) for B a literal concept, then ps ∈ B I : The proof is immediate if B is atomic. If B = ¬ A,, which by the previous, we have A(w) /∈ A(cid:5)and A(s) /∈ A(cid:5); but then, A(s(cid:5)) /∈ A(cid:5)• If (cid:2) n R.B(s) ∈ A(cid:5), then ps ∈ ((cid:2) n R.B)I : By the definition of paths, s is not blocked. Since the (cid:2)-rule is not applicableto (cid:2) n R.B(s), individuals u1, . . . , un exist such that R(s, ui) ∈ A(cid:5)foreach 1 (cid:3) i < j (cid:3) n. Each assertion R(s, ui) satisfies Property (1) of HT-ABoxes, so each ui can be of one of the followingforms.for each 1 (cid:3) i (cid:3) n, and ui (cid:14)≈ u j ∈ A(cid:5)and B(ui) ∈ A(cid:5)otherwise,(cid:18)ps, puilet pui= [ps | uiui(cid:19) ∈ R I . Furthermore, B(ui) ∈ A(cid:5)◦ uiis from the same cluster as s. If s is a tree individual, let puidefinition of I and the facts that R(s, ui) ∈ A(cid:5)and B(ui) ∈ A(cid:5)= [ps | uiui, we conclude (cid:18)ps, pui]; otherwise, let pui(cid:19) ∈ R I and pui= [qs | uiui∈ B I .◦ ui is a successor of s, but ui and s are not from the same cluster. If ui is directly blocked by v i , let pui]. In either case, we have R(tail(ps), ui) ∈ A(cid:5), which, by the definition of= [ps | v i];uiimpliesI ,]. By the◦ ui is a root individual. Let puiConsider now each 1 (cid:3) i < j (cid:3) n. In all cases, we have tailapplicable, we also have tail]. We have R(s, ui) ∈ A(cid:5)(cid:5)(pu j ), which implies pui(cid:5)(pui ) (cid:14)= tail= [ uiuiand B(ui) ∈ A(cid:5), which imply (cid:18)ps, pui. Since ⊥ /∈ A(cid:5)(cid:14)= pu j . Thus, we conclude that ps ∈ ((cid:2) n R.B)I .(cid:5)(pu j ) ∈ A(cid:5)(cid:19) ∈ R I and pui(cid:5)(pui ) (cid:14)≈ tailand the ⊥-rule is not∈ B I .and LA(cid:5) (ui) = LA(cid:5) (tail(pui )) imply pui∈ B I .For an assertion α(cid:5) ∈ A(cid:5). Furthermore, if α(cid:5)I |(cid:17) α(cid:5)Consider now each α ∈ A. If α /∈ A(cid:5)but then, I |(cid:17) α by the definition of I .of the form a ≈ b and a (cid:14)≈ b with a and b named individuals, it is straightforward to see thatis of the form R(a, b) or B(a), or (cid:2) n R.B(a) with a a named individual, (*) implies I |(cid:17) α(cid:5).contains renamings that, when applied to α, produce an assertion α(cid:5) ∈ A(cid:5);, then A(cid:5)We next show that I |(cid:17) R. Consider a simple HT-rule r ∈ RT with variables x, yi , and z j as in Definition 3, and amapping μ of the variables to (cid:15)I such that I, μ |(cid:17) Bm for each body atom Bm of r. Let σ be a mapping of the variables inr to individuals in A(cid:5)defined as follows:• σ (x) = tail(μ(x));• σ ( yi) = tail• σ ( yi) = tail(μ( yi)) in all cases not covered by the previous one; and• σ (z j) = tail(μ(z j)).(cid:5)(μ( yi)) if μ( yi) is a successor of μ(x) such that μ( yi) (cid:14)∼ μ(x);8 The function (cid:26) · (cid:26)A(cid:5) has been introduced in Definition 2.1298B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309Atom Bm can be of the form A(x), A( yi), A(z j), R(x, x), or R(x, yi), for R a T -role. By the definition of paths, σ (x) is notblocked. Furthermore, if μ( yi) is a successor of μ(x), then σ ( yi) is a successor of σ (x); otherwise, σ ( yi) is either from thesame cluster as σ (x) or it is a named individual. Finally, by the definition of I , we have σ (Bm) ∈ A(cid:5). Each variable z j occurs]a are of the form [ bin r in an atom of the form O a(z j); by Condition 4 of Lemma 1 and the definition of I , all paths in O Ibfor b a named individual, so μ(z j) is of that form as well. The Hyp-rule is not applicable to r, A(cid:5)forsome head atom Hn of r. We have the following possibilities for the structure of Hn., and σ , so σ (Hn) ∈ A(cid:5)• Assume that Hn is of the form C(x) for C a literal concept or a concept of the form (cid:2) n S.B; thus, we have C(σ (x)) ∈ A(cid:5).By (*), we then have μ(x) ∈ C I . Thus, I, μ |(cid:17) r.• Assume that Hn is of the form R(x, x); thus, we have R(σ (x), σ (x)) ∈ A(cid:5). By (*), we then have (cid:18)μ(x), μ(x)(cid:19) ∈ R I . Thus,I, μ |(cid:17) r.I, μ |(cid:17) r.• Assume that Hn is of the form B( yi); thus, we have B(σ ( yi)) ∈ A(cid:5)i . Thus, I, μ |(cid:17) r.LA(cid:5) (σ ( yi)) = LA(cid:5) (tail(μ( yi))); by (*), we then have p yi• Assume that Hn is of the form S(x, yi), so S(σ (x), σ ( yi)) ∈ A(cid:5)∈ E I. By the definition of blocking, we have. By the definition of I , we have (cid:18)px, p yi(cid:19) ∈ S Ii . Thus,• The case when Hn is of the form S(x, z j) is analogous to the previous one.• Assume that Hn is of the form x ≈ z j ; thus, we have σ (x) ≈ σ (z j) ∈ A. Since the ≈-rule is not applicable to A(cid:5)σ (x) = σ (z j). Since σ (x) is a named individual, it cannot block other individuals, so tailμ(x) = μ(z j). Thus, I, μ |(cid:17) r., we have(cid:5)(μ(x)) = σ (x), which implies• Assume that Hn is of the form yi ≈ y j ; thus, we have σ ( yi) ≈ σ ( y j) ∈ A(cid:5). Since the ≈-rule is not applicable toA(cid:5), we have σ ( yi) = σ ( y j). By Definition 3, the antecedent of r contains atoms R(x, yi) and R(x, y j); therefore,(cid:18)μ(x), μ( yi)(cid:19) ∈ R I and (cid:18)μ(x), μ( y j)(cid:19) ∈ R I . By Condition 1 of Lemma 1 and the definition of I , path μ( yi) can be eitherof the form [ a] for a a root individual, a successor of μ(x), or from the same cluster as μ(x); similar restrictions holdafor μ( y j). But then, σ ( yi) = σ ( y j) implies μ( yi) = μ( y j). Thus, I, μ |(cid:17) r.Consider a rule r ∈ RP containing variables x1, . . . , xn and μ a mapping of these variables to (cid:15)I such that I, μ |(cid:17) Bm foreach body atom Bm of r. Since r is connected and each nonunary atom Bm involves either a P -role or a description graph,Condition 3 of Lemma 1 and the definition of I imply that all paths μ(xi) are from the same cluster. Let σ be a mapping ofdefined as σ (xi) = tail(μ(xi)) for 1 (cid:3) i (cid:3) n. By the definition of I , we have σ (Bm) ∈ A(cid:5)the variables in r to individuals in A(cid:5)for each body atom Bm. Since the Hyp-rule is not applicable to r, A(cid:5), and σ , then σ (Hn) ∈ A(cid:5)for some head atom Hn. Butthen, by the definition of I , we have I, μ |(cid:17) Hn.The proof that I |(cid:17) G is completely analogous to the one in the previous paragraph and we omit it for the sake ofbrevity. (cid:2)(cid:5)) for some descendant node gProof of Claim 3. We show that each derivation (T , ρ) for R, G, and A satisfies the following properties: (1) if a derivationrule is applied to a subset of ρ(g) for some derivation node g ∈ T , then the same derivation rule cannot become applicable(cid:5)of g; (2) an integer ℘ depending only on R, G, and A existsto the same assertions in ρ(gsuch that, for each ρ(g) and each tree individual s in ρ(g), the number of tree ancestors of s is at most ℘; (3) for eachρ(g) and each tree individual s in it, the number of graph successors of s is bounded; (4) on each derivation path, thenumber of graph individuals introduced by graph cleanup is bounded; and (5) the number of root graph individuals in eachρ(g) is bounded. Together, all these items imply that (6) the number of individuals introduced on each derivation path isbounded. Items (1) and (6) imply that the number of applications of all derivation rules on each derivation path is boundedas well, which implies the claim of this lemma.(1) This item holds in exactly the same way as in the case of the standard hypertableau algorithm [31, Lemma 15]: ifa derivation rule is applied to a subset of assertions of ρ(g) for some derivation node g ∈ T , then assertions are added to(cid:5)(cid:5)) for some descendant node gρ(g) that prevent a reapplication of the same derivation rule to the same assertions in ρ(gof g. We omit the details for the sake of brevity.(2) Let c be the number of atomic concepts occurring in (R, G, A), and let depth of a tree individual s, written dep(s),be the number of its tree ancestors. For each g ∈ T , the ancestors of each tree individual in ρ(g) are present in ρ(g) byCondition 5 of Lemma 1. Thus, if a tree individual s has depth ℘ = 2c + 1, two ancestors with the same individual labelexist in ρ(g), so s is blocked in ρ(g). The (cid:2)-rule is not applicable to blocked individuals, so the (cid:2)-rule is never applied tosuch s. Thus, for each tree individual s in ρ(g), we have dep(s) (cid:3) ℘.(3) To prove this item, we first show a useful property. Let ≺ be an order on the description graphs in G that satisfiesthe conditions of Definition 11. Furthermore, let us assume that the hypertableau algorithm is modified such that eachindividual s in A(cid:5)is assigned a label ω(s), which is a (possibly empty) string of the formG 1|v1→ v(cid:5)1 . . . . .Gn|vn→ v(cid:5)n(35)where n (cid:2) 0, G i is a description graph, and v i and vrules:(cid:5)i are vertices in G i . Individuals are labeled according to the followingB. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091299• For s a tree or named individual, or a fresh graph individual introduced by graph cleanup, ω(s) is the empty string.• If an application of the G∃-rule to an assertion A(s) introduces a graph assertion G(t1, . . . , t(cid:4)) with s = ti for some1 (cid:3) i (cid:3) (cid:4), then ω(t j) = ω(s).G|i→ j for each 1 (cid:3) j (cid:3) (cid:4) and j (cid:14)= i.By induction on the applications of the derivation rules, we show that the following properties (†) hold for each clash-free ABox A(cid:5)labeling a node of (T , ρ):(i) For each graph individual s in A(cid:5)with ω(s) of the form (35),contains an assertion Gn(u1, . . . , u(cid:4)n ) such that s = u v(cid:5)n;(a) A(cid:5)(b) G 1 ≺ · · · ≺ Gn−1; and(c) if Gn−1 (cid:14)≺ Gn, then A(cid:5)that w i = w(cid:5)j for some i (cid:14)= j.as s such that s (cid:14)= t and ω(s) = ω(t).contains (not necessarily distinct) graph assertions Gn(w 1, . . . , w(cid:4)n ) and Gn(w(cid:5)1, . . . , w(cid:5)(cid:4)n) such(ii) For each individual s in A(cid:5)such that s! is a tree individual, A(cid:5)does not contain an individual t from the same clusterProperty (†) clearly holds for the input ABox A, so let A(cid:5)be an ABox satisfying (†) and consider all possible derivation rules.The Hyp-, ⊥-, G≈-, G⊥-, G L -, G(cid:4)-, and G↔-rule do not introduce fresh individuals and do not remove assertions from anABox, so they cannot invalidate (†). Furthermore, the (cid:2)-rule introduces tree individuals ti where ω(ti) is the empty string,so the resulting ABox clearly satisfies (†).Assume that the ≈-rule is applied to an assertion s ≈ t ∈ A(cid:5)and that the individual s is merged into t. By Lemma 1,pruning always removes either all or no graph individuals from some cluster; therefore, the ABox after merging, but beforepossible graph cleanup, clearly satisfies Condition (i-c) and (ii). Furthermore, if merging requires graph cleanup, then freshlyintroduced graph individuals clearly satisfy Conditions (i) and (ii).Consider an application of the G∃-rule to an assertion A(s) ∈ A(cid:5)-ary description graph Gand an (cid:4)(cid:5)(cid:5)) with(cid:5), λ(cid:5), M(cid:5) = (V(cid:5), EA ∈ M(cid:5). Assume that s is labeled as follows, for Gn = (V n, En, λn, Mn):ω(s) = G 1|v1→ v1 . . . . .Gn|vn→ v(cid:5)n(cid:5)By the induction assumption, ω(s) satisfies Conditions (i) and (ii). Moreover, by the rule precedence, the G⊥-, G L -, and G(cid:4)-,and ⊥-rule are not applicable to A(cid:5)The G⊥-rule is not applicable, so A(cid:5)) such that(cid:5)j for some i (cid:14)= j. Since ω(s) satisfies Condition (i-a), we conclude that Gn−1 ≺ Gn. Furthermore, since ω(s) satis-does not contain assertions Gn(w 1, . . . , w(cid:4)n ) and Gn(ww i = wfies Condition (i-b), we have that G i ≺ G i+1 for each 1 (cid:3) i (cid:3) n − 1.(cid:5)1, . . . , w(cid:5)(cid:4)n.By Condition (i-a), A(cid:5)B(s) ∈ A(cid:5)(cid:5)(cid:5)graph Gfor each B ∈ λn(cid:18)vin G such that Gn (cid:14)(cid:30) G(cid:5)(cid:5)contains an assertion Gn(u1, . . . , u(cid:4)n ) such that s = u v(cid:5)n. Since the G L -rule is not applicable,(cid:19). Since G is acyclic, by Definition 11 the following properties (‡) hold for each description(cid:5)nand each main concept C of G(cid:5)(cid:5):• If G• If G(cid:5)(cid:5) (cid:4)∗ Gn and v(cid:5)(cid:5) (cid:14)(cid:4)∗ Gn, or if G(cid:5)(cid:5) (cid:4)∗ Gn and v(cid:5)n is a vertex of G= s.that qv(cid:5)n(cid:5)n is not a vertex of G(cid:5)(cid:5), then ¬C(s) ∈ A(cid:5).(cid:5)(cid:5), since the G(cid:4)-rule is not applicable, A(cid:5)contains an assertion G(cid:5)(cid:5)(q1, . . . , q(cid:4)(cid:5)(cid:5) ) suchLet G(cid:5)(t1, . . . , t(cid:4)(cid:5) ) be a graph assertion introduced by the G∃-rule such that t v = s, and consider each fresh graph indi-vidual ti , labeled as follows:ω(ti) = G 1|v1→ v(cid:5)1 . . . . .Gn|vn→ v(cid:5)n .G(cid:5)|v→ iWe next show that ω(ti) satisfies Conditions (i) and (ii). Condition (i-a) is obviously satisfied, and we have already estab-lished that Condition (i-b) is satisfied by the induction assumption on ω(s). To show that ω(t) satisfies Condition (i-c), weconsider all possible relationships between Gn and G.(cid:5)• Gn ≺ G• Gn = G(cid:5)(cid:5): Condition (i-c) is vacuously satisfied.: Precondition 3 of the G∃-rule ensures that v (cid:14)= v(cid:5)n, so graph assertions G(cid:5)(t1, . . . , t(cid:4)(cid:5) ) and Gn(u1, . . . , u(cid:4)n ) satisfyCondition (i-c).(cid:5)• Gn (cid:14)(cid:30) G◦ G: Consider the relationship between Gn and G(cid:5)(cid:5) (cid:4)∗ Gn and v is not a vertex of Gn: By case 1 of (‡), we have that ¬ A(s) ∈ A(cid:5)in (cid:4)∗ .(cid:5) (cid:14)(cid:4)∗ Gn, or Gapplicable to A(cid:5)(cid:5) (cid:4)∗ Gn and v is not a vertex of Gn: By case 2 of (‡), then A(cid:5)but then the G∃-rule is not applicable to A(cid:5), which is a contradiction., we have ⊥ ∈ A(cid:5)◦ Gby precondition 3, which is a contradiction.; since the ⊥-rule is notcontains an assertion G(cid:5)(q1, . . . , q(cid:4)(cid:5)(cid:5) ) such that qv = s;Finally, to have ω(ti) = ω(q) for some individual q from the cluster of ti , the G∃-rule must be applied to the same assertionfor the same graph twice. By (1), this is not possible; hence, ω(ti) satisfies (ii). This completes the proof of (†).1300B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309(cid:5)We next use (†) to show (3). Let g be the number of graphs and a the maximum arity of a graph in G. The ordering ≺(cid:5))is acyclic, so n (cid:3) g + 1 in each label of the form (35). Each label can thus be understood as a tuple of g + 1 triples (G, v, vare integers between 1 and a. There are most ((g + 1) · a · a)g+1where G is a description graph or is empty, and v and vdifferent such labels, and this number is bounded by ϑ = 2(2a+1)·(g+1)2. But then, by (ii), the number of graph individualsin a cluster of a tree individual in A(cid:5)is bounded by ϑ as well, which implies Item (3).(4) Consider any graph or tree individual s in an ABox A(cid:5)labeling a derivation node. Let t1, . . . , tn be a sequence oftree individuals such that t1 is a successor of a root individual, tn = s!, and each tk is the closest tree predecessor oftk+1. Furthermore, let χs = S1, . . . , Sn be a sequence where each Sk is the maximal subset of A(cid:5)in which all individualsare from the cluster of tk. In the worst case, s can be merged into a named individual a, and an individual from each Skcan be merged into Sk+1. By the first condition of the definition of graph cleanup, however, fresh graph individuals can beintroduced at most once for each χs unique up to the renaming of individuals. By Item (2), n (cid:3) ℘, and, by Item (3), the sizeof each S i is bounded; therefore, the number of sequences χs unique up to the renaming of individuals is also bounded.Consequently, the number of fresh graph individuals introduced in graph cleanup is bounded as well.(5) Item (4), property (†), and the fact that ≺ is acyclic imply that the number of fresh root graph individuals introducedby the G∃-rule is bounded. The proof is analogous to the proof of Item (3) and is omitted for the sake of brevity.(6) By (4) and (5), the total number of root individuals in an ABox is bounded. Furthermore, by (1), (2), and (3), thenumber of their descendants is bounded as well. Therefore, by (1), the total number of applications of derivation rules oneach derivation path is bounded as well. (cid:2)Since preprocessing of the TBox does not affect satisfiability of a graph-extended knowledge base, we immediately havethe following theorem.Theorem 2. Checking the satisfiability of a weakly separated acyclic graph-extended knowledge base K = (T , P, G, A) where T is inSHOQ+is decidable.We now consider the case when K = (T , P, G, A) is a weakly separated acyclic graph-extended knowledge base withT in SHOIQ+. The TBox T is preprocessed as usual, so let R = ΞT (T ) ∪ P and A(cid:5) = A ∪ ΞA(A); then, (R, G, A(cid:5)) isweakly admissible and acyclic, but not simple. By Proposition 3, checking the satisfiability of (R, G, A(cid:5)) is undecidable;consequently, the hypertableau algorithm does not necessarily terminate. Consider again Fig. 7. If R is not simple (i.e., if Tcontains inverse roles), then v can be merged into s. Individual v, however, does not need to occur in an assertion involvinga main concept of some graph from the cluster of u. Thus, the algorithm does not necessarily derive a contradiction if agraph from the cluster of u is not subordinate to all graphs in the cluster of s. Hence, even though G is acyclic, clusters canbe of arbitrary size which leads to nontermination.Our algorithm, however, can be used as a semidecision procedure. This is a nontrivial and practically interesting conse-quence since the algorithm uses blocking. Assume that the T -rules in R have been obtained from a cyclic TBox, and that(R, G, A(cid:5)) is satisfiable. Blocking “increases the chances” for termination; in fact, provided that G is acyclic, our algorithmwill necessarily terminate unless it performs one particular type of inference. Our algorithm is a semidecision procedureeven if G is not acyclic, but then it is unlikely to terminate on satisfiable (R, G, A(cid:5)).Since the rules in RT are not simple, pairwise blocking must be used, and the NI-rule can become applicable. Further-more, as usual in the case of semidecision procedures, derivations must be fair; intuitively, this means that no applicationof an inference rule should be “postponed” infinitely often.Definition 16 (Fair derivation). A derivation (T , ρ) for R, G, and A is unfair if a branch t1, t2, . . . of T exists such that, forinfinitely many nodes ti1 , ti2 , . . . on that branch, the same derivation rule is applicable to the same assertions in each ρ(ti j ).Fair is the opposite of unfair.The correctness proofs for the standard hypertableau algorithm for SHOIQ+[31] are quite involved and lengthy, andso is their generalization to graph-extended knowledge bases. To keep this paper within reasonable length, we only sketchthe proofs of our claims. The full proofs can be obtained by a rather straightforward combination of the proofs of Lemma 1and Theorem 1 and the proofs from [31].We first generalize Lemma 1 to take into account the assertions that can be derived when R is not simple.Lemma 2. Let R be a set of rules, G a GBox, and A an ABox such that (R, G, A) is weakly admissible. Then, each ABox A(cid:5)labelinga node of a derivation for (R, G, A) satisfies Conditions (3)–(5) of Lemma 1, as well as the following conditions, for a and b rootindividuals, u(i) individuals, γi, γ j ∈ Σγ , and τi, τ j ∈ Στ .(1) Each R(s, t) ∈ A(cid:5)same cluster.where R is a T -role has the form R(u, u.τi), R(u.τi, u), R(u, a), R(a, u), or R(u1, u2) with u1 and u2 from theB. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091301(2) Each equality in A(cid:5)either is of the form s ≈ t @a(cid:3)n R.B with s a tree individual that is not a successor of a and t a tree individual, orit is a possibly annotated equality of the form a ≈ u, u1 ≈ u2, u1 ≈ u2.τi , u ≈ u.τi.γ j , u.τi ≈ u.τ j , or u ≈ u.τi.τ j , where u1 andu2 are individuals from the same cluster.Proof (sketch). The proof is a straightforward combination of the proofs of Lemma 1 and [31, Lemma 12]. The main differ-ence is in the application of the ≈-rule to and equality of the form u ≈ u.τi.γ j , which prunes u.τi.γ j and merges it into u.The cluster of u.τi.γ j is not necessarily pruned as well; however, graph cleanup ensures that all individuals from the clusterof u.τi.γ j are replaced with individuals from the cluster of u. (cid:2)Theorem 3. The following properties hold for each set of rules R, a GBox G, and an ABox A such that (R, G, A) is weakly admissible:(1) if (R, G, A) is satisfiable, then each derivation for (R, G, A) is successful; and(2) (R, G, A) is satisfiable if a successful and fair derivation for (R, G, A) exists.i(cid:7)(cid:16)(cid:17)(cid:9)(cid:13)(cid:6)j(cid:2)i ρ(t j). Since (T , ρ) is fair, no derivation rule is applicable to A(cid:5)Proof (sketch). The proof of Claim 1 is the same as in Theorem 1, apart from the case for the NI-rule which is the same asin [31, Lemma 13]. For Claim 2, let (T , ρ) be a successful fair derivation for (R, G, A). The main difference to the proof ofClaim 2 of Theorem 1 is that (T , ρ) is not necessarily finite. Let t1, t2, . . . be the branch of T such that each ρ(ti) is clash-free, and let A(cid:5) =. We can construct the model of(R, G, A) in the same way as in Theorem 1, with the following difference in the treatment of T -roles:(cid:7), and R(cid:7), and R(cid:12)∈ A(cid:5)tail(p1), tail(p2)(cid:10)(cid:12)∈ A(cid:5)(cid:5)∈ A(cid:5)(cid:14) (cid:15)(cid:15) a is a root individual, p (cid:14)∼(cid:15) a is a root individual, p (cid:14)∼(cid:15)(cid:15) p1 ∼ p2 and R(cid:7)(cid:14) (cid:15)(cid:15)(cid:6)(cid:7)(cid:15) ss(cid:5)(cid:15)(cid:15) ss(cid:5)aaap,a(cid:18)p1, p2(cid:19)(cid:15)(cid:6)(cid:9)(cid:13)(cid:15) sp,s(cid:5)(cid:7), p(cid:11)tail(p), s(cid:11)(cid:5)(cid:12)(cid:11)a, tail(p)(cid:12)(cid:11)(cid:15) p (cid:14)∼(cid:14) (cid:15)(cid:15) p (cid:14)∼(cid:12), tail(p)tail(p), a(cid:10)∈ A(cid:5)∈ A(cid:5)p(cid:15)(cid:15) ss(cid:5)R I =, p(cid:6)and Rand R(cid:7)(cid:14) (cid:15)aaaa(cid:9)(cid:13)(cid:6)(cid:9)(cid:13)∪∪∪∪(cid:9)(cid:10)(cid:10)(cid:10)ppp(cid:11)(cid:6)(cid:6)(cid:6)(cid:7)sThe proof that I is a model of (R, G, A) is a straightforward combination of the proof of Claim 2 of Theorem 1 and [31,Lemma 14]. (cid:2)Termination is lost because the application of the ≈-rule to assertions of the form u ≈ u.τi.γ j invalidates Condition (ii)of (†) in the proof of Claim 3 of Theorem 1. The results in Section 6.3, however, show that the algorithm terminates if suchan inference is not performed. A practical implementation can detect such inferences and warn the user about the loss oftermination guarantees.6.3. Strongly separated knowledge basesFor K = (T , P, G, A) where T is in SHOIQ+, termination can be regained if K is strongly separated and acyclic. Then,for R = ΞT (T ) ∪ P and A(cid:5) = A ∪ ΞA(A), triple (R, G, A(cid:5)) is strongly admissible and acyclic, as defined next.Definition 17 (Strong separation). A role separation scheme (N RT , N RP , N RG ) is strong if N RT ∩ N RP = ∅ and N RG = N RP .A graph-extended knowledge base K = (T , P, G, A) is strongly separated if a strong role separation scheme Λ exists suchthat K is Λ-separated. Similarly, a triple (R, G, A) is strongly admissible if a strong role separation scheme Λ exists suchthat (R, G, A) is Λ-admissible.Strong separation restricts the modeling style in a more significant way than weak separation: essentially, it requires themodeler to determine in advance which knowledge will be modeled using DLs and which using graphs. Thus, knowledgemodeled using DLs cannot be specialized using graphs and vice versa.To understand why strong separation ensures decidability of reasoning, consider again Fig. 7. The tree backbone thencontains only T -roles, and the clusters contain only P -roles (i.e., G-roles). Thus, the T -rules from R can be applied onlyto the tree backbone, while the P -rules can be applied only to the graphs in a single cluster. Therefore, even if R is notsimple, no rule in T can derive an equality that equates s with v and thus merges two distinct clusters.Theorem 4. Let R be a set of rules, G a GBox, and A an ABox such that (R, G, A) is strongly admissible and acyclic. Then, eachderivation for (R, G, A) is finite.Proof (sketch). Since (R, G, A) is strongly admissible, the rules in R can be separated into sets RT and RP of T -rulesand P -rules, respectively, that do not share roles. By a straightforward modification to the proof of Lemma 2 one can seethat, due to strong role separation, role assertions of the form R(u1, u2), where R is a T -role and u1 and u2 are from the1302B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309same cluster are always of form R(u, u) for u a tree individual. This can be used to strengthen Lemma 2 and show that eachABox A(cid:5)labeling a node in a derivation for (R, G, A) contains equalities of the form a ≈ u, u1 ≈ u2, u ≈ u.τi , u.τi ≈ u.τ j , oru ≈ u.τi.τ j —that is, equalities of the form u ≈ u.τi.γ j are never derived.9 As we show next, this can be used to show thatthe number of individuals introduced on a derivation path is bounded.Assume that the ≈-rule is applied to u ≈ u.τi , u.τi ≈ u.τ j , or u ≈ u.τi.τ j . Just like in the proof of Claim 3 of Theorem 1,the merged individual is a tree individual, so its entire cluster is pruned and the resulting ABox satisfies (†); consequently,the number of individuals in the cluster of a tree individual is bounded by ϑ .If the ≈-rule is applied to a ≈ u, then the resulting ABox is subjected to graph cleanup; however, the number of newlyintroduced individuals is bounded in exactly the same way as in Item (4) of the proof of Claim 3 of Theorem 1.It remains to be shown that the number of new root individuals introduced by the NI-rule is bounded as well. Let ℘be the maximal number of tree ancestors of an individual occurring in A(cid:5); in [31, Lemma 15], it was shown that ℘ isexponential in the number of atomic concepts and roles. Furthermore, in [31, Lemma 15] it was also shown that the rootindividuals introduced by the NI-rule can be seen as forming a tree with a polynomial branching factor and depth at most℘. Since the number of graph individuals in each cluster is bounded, the addition of description graphs does not change theessence of this argument: the root individuals introduced by the NI-rule can be seen as forming a tree of clusters, where thesize of each cluster is at most ϑ and the depth of the tree is at most ℘. Thus, the number of root individuals is bounded,which implies the claim of this theorem. (cid:2)Theorem 5. Checking the satisfiability of a strongly separated acyclic graph-extended knowledge base K = (T , P, G, A) where T isin SHOIQ+is decidable.7. Complexity of reasoningWe now determine the exact complexity bounds of checking the satisfiability of a graph-extended knowledge baseK = (T , P, G, A). In Section 7.1, we show that the problem is NExpTime-hard even if T = ∅. Then, in Section 7.2, we showthat the problem is in NExpTime if K is acyclic and weakly separated with T in SHOQ+, or if K is acyclic and stronglyseparated with T in SHIQ+is left for ourfuture work.. The case when K is strongly separated and acyclic and T is in SHOIQ+7.1. Lower boundA graph-extended knowledge base K contains a set P or disjunctive datalog rules, and checking the satisfiability of Pis NExpTime-complete [11] (under standard first-order semantics), so one might intuitively expect this result to providea lower bound for the complexity of checking the satisfiability of K. To understand why this is not the case, considerthe following intuitive explanation of the result from [11]. The satisfiability of P alone can be decided by the followingthree-step process:(1) Compute the grounding Pg of P —that is, replace in P all variables in the rules with all individuals in all possible ways.(2) Nondeterministically guess an interpretation I for Pg .(3) Check whether I is a model of Pg .Without restricting P in any way, the first and the third step can be implemented in exponential time, but the secondstep requires nondeterministic exponential time; thus, the overall complexity of this procedure is NExpTime. If, however,the arity of the predicates occurring in P is bounded, then the number of ground atoms in Pg is polynomial in |P|, soall interpretations I can be enumerated by an exponential algorithm. Similarly, if the number of variables in P is bounded,then Pg is polynomial in |P|; furthermore, in the second step we can clearly restrict our attention to interpretations thatcontain only the ground atoms from Pg , so we can again enumerate all relevant interpretations in exponential time. Thus,for the problem to be NExpTime-hard, P must be allowed to contain predicates of arbitrary arity as well as rules with anarbitrary number of variables.The set of rules P of a graph-extended knowledge base K can contain rules with an unbounded number of variables, andit can contain graph atoms with arbitrary arity. Graph atoms, however, must satisfy the disjointness and key properties fromDefinition 10; this imposes restrictions on the interpretation of graph atoms in addition to P , so the hardness result from[11] does not apply. In fact, we show that checking the satisfiability of K is NExpTime-hard even if the rules are allowedto contain only unary and binary predicates and at least four variables. We thus identify a new source of complexity ofreasoning with graph-extended knowledge bases: description graphs can succinctly encode exponential structures.We prove hardness by a reduction from the bounded domino tiling problem [7]. Given a domino system S = (D, H, V), aninitial condition for S is an n-tuple I = Dα0 , . . . , Dαn−1 of tiles from D. A bounded S-tiling for I is a function τ : N2n × N2n → Dwhere N2n = {0, . . . , 2n − 1}, τ (i, 0) = Dαi for 0 (cid:3) i < n, and (cid:18)τ (i, j), τ (i ⊕2n 1, j)(cid:19) ∈ H and (cid:18)τ (i, j), τ (i, j ⊕2n 1)(cid:19) ∈ V where9 Due to strong admissibility, equalities of the form u1 ≈ u2.τi from Lemma 2 become u ≈ u.τi ; however, this is not relevant to this termination proof.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091303Fig. 8. Construction of an exponential grid.⊕2n denotes addition modulo 2n. Given a domino system S and an initial condition I, checking whether a bounded S-tilingfor I exists is NExpTime-complete [7].Lemma 3. Let K = (∅, P, G, A) be a graph-extended KB where G = (GG , ∅, ∅) is an acyclic GBox and each rule in P contains onlyatomic concepts and roles and at most four variables. Then, checking the satisfiability of K is NExpTime-hard.Proof. For an arbitrary integer n, we first construct a graph-extended knowledge base Kna “cyclic” grid with 2n × 2n elements. The ABox of Knn graphs G i = (V i, E i, λi, Mi), 1 (cid:3) i (cid:3) n, as shown in Fig. 8a, where Mi = { Ai−1}. The knowledge base Knfollowing rules:grid contains a single assertion A0(a). The GBox of Kngrid that implies the existence ofgrid containsgrid contains theA0(x) ∧ R4(x, y) ∧ R1(x, z) → H( y, z)A0(x) ∧ R3(x, y) ∧ R2(x, z) → H( y, z)A0(x) ∧ R2(x, y) ∧ R1(x, z) → V ( y, z)A0(x) ∧ R3(x, y) ∧ R4(x, z) → V ( y, z)H(x, y) ∧ R4(x, z) ∧ R1( y, w) → H(z, w)H(x, y) ∧ R3(x, z) ∧ R2( y, w) → H(z, w)V (x, y) ∧ R2(x, z) ∧ R1( y, w) → V (z, w)V (x, y) ∧ R3(x, z) ∧ R4( y, w) → V (z, w)(36)(37)(38)(39)(40)(41)(42)(43)We next show that Kngrid is satisfiable and that each model I of Kngrid contains a structure shown in Fig. 8b. The individuala corresponds to the apex of the pyramid. Due to the assertion A0(a), the model I contains an instance of G 1 such thatits vertex 5 corresponds to a. Vertices 1–4 of G 1 are labeled with A1, so I contains four instances of G 2 as shown in thefigure. By repeating this argument, I can be seen as containing a pyramid consisting of n levels, where level i contains 2i · 2ivertices. Furthermore, in the first level, rules (36)–(39) ensure that vertex 4 is connected through H to vertex 1, vertex 3is connected through H to vertex 2, vertex 2 is connected through V to vertex 1, and vertex 3 is connected through V tovertex 4; that is, the grid in the first level is “cyclic.” Rules (40)–(43) then inductively use the H - and V -edges at level i − 1to construct the missing H - and V -edges at level i; since the grid at level i − 1 is “cyclic,” these rules construct at level i a“cyclic” grid as well. Thus, I contains at level n a “cyclic” grid of size 2n · 2n in which all elements are labeled with An.Consider now any domino system S = (D, H, V) with m tiles in D and any initial condition I = Dα0 , . . . , Dαn−1 . Let KS,Igrid with the following rules, where each domino tile D i ∈ Dbe a graph-extended knowledge base obtained by extending Kncorresponds to the atomic concept D i .(44)(45)(46)(47)(48)(49)(50)1304B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309A0(x) → O 0(x)O 0(x) ∧ R1(x, y) → O 0( y)An(x) ∧ O i−1(x) ∧ H(x, y) → O i( y)An(x) ∧ O i(x) → Dαi (x)An(x) → D1(x) ∨ · · · ∨ Dm(x)D i(x) ∧ D j(x) → ⊥ for each 1 (cid:3) i < j (cid:3) mD i(x) ∧ H(x, y) ∧ D j( y) → ⊥ for each (D i, D j) /∈ HD i(x) ∧ V (x, y) ∧ D j( y) → ⊥ for each (D i, D j) /∈ Vfor each 1 (cid:3) i < nfor each 1 (cid:3) i < n(51)Let I be a model of KS,I. By rules (44)–(45), the apex of the pyramid and each vertex that is reachable from the apex byan R1-chain is labeled with O 0. Rule (46) ensure that the “first” n vertices in the n-th level of the pyramid are labeledwith O 0, . . . , O n−1. Rules (47) label these vertices with the appropriate tiles from the initial condition. Finally, rules (48)–(51) ensure that each element at the n-th level of the grid is labeled with exactly one tile according to the compatibilityconditions of S. Therefore, KS,I is satisfiable if and only if a bounded S-tiling for I exists, which proves our claim. (cid:2)Note that rule (48) contains a disjunction. Without disjunctions in the rules and description graphs (i.e., if for each graphG in the GBox of K we have that | V A |(cid:3) 1 for each main concept A of G), reasoning with G and P becomes deterministicand the complexity drops to ExpTime: the description graphs in G then encode a structure that can be computed determin-istically in exponential time by unfolding G, and the rules in P can be applied to this structure in exponential time as well.Axioms of the form (48), however, are available even in the basic description logic ALC, so the proof of Lemma 7.1 showsthat reasoning with graph-extended KBs is NExpTime-hard even for basic DLs.7.2. Upper boundsThe hypertableau procedure from Section 6 is not worst-case optimal even without description graphs and rules, andwith T in ALC [31, Section 5.3]. This is because an ABox A(cid:5)labeling a derivation node for a set of HT-rules R = ΞT (T )and an ABox ΞA(T ) ∪A can at any given point in time contain at most exponentially many nonblocked and directly blockedtree individuals; however, A(cid:5)can contain a doubly exponential number of indirectly blocked individuals. The complexity ofthe hypertableau procedure can be reduced to NExpTime if we ensure that the label of each individual s is fully determinedin A(cid:5)before applying the (cid:2)-rule to an assertion containing s: the rule application strategy then ensures that s cannotsubsequently become blocked, so A(cid:5)never contains indirectly blocked individuals. A similar approach was used in [14] toobtain a tableau algorithm for ALC running in NExpTime. For SHOQ+and SHIQ+, such an algorithm is not worst-caseoptimal, since these DLs are ExpTime-complete [3]. Description graphs increase the complexity at least to NExpTime, so the“excess” complexity of the modified hypertableau algorithm is not relevant: we next present two modified hypertableaualgorithms that decide the satisfiability of a graph-extended acyclic knowledge base K = (T , P, G, A) in NExpTime if K isacyclic and weakly separated with T in SHOQ+. Since theyuse extensive guessing to realize the idea outlined above, these algorithms are unlikely to be practicable., or if K is acyclic and strongly separated with T in SHIQ+Our modified algorithms can be applied to any (R, G, A) where R is normalized according to the following definition.This assumption is without loss of generality, since each set of HT-rules can be normalized by replacing concepts of theform (cid:2) n R.B in the rules with fresh atomic concepts.Definition 18 (Normalized rules). A set of HT-rules R is normalized if all at-least restriction concepts occur in R only in rulesof the form (52).A(x) → (cid:2) n R.B(x)(52)We are now ready to present the algorithm for the case when T is in SHOQ+.Theorem 6. Checking the satisfiability of a weakly separated acyclic graph-extended knowledge base K whose TBox is in SHOQ+NExpTime-complete, provided that the numbers in K are coded in unary.isProof. Hardness is shown in Lemma 3. By the properties of preprocessing [31], K can be transformed to an equisatisfiabletriple (R, G, A) where R is normalized and A is an input ABox. We next show that the satisfiability of (R, G, A) can bedecided by the following variant of the calculus from Section 6.(1) The (cid:2)-rule is modified such that, after it is applied to an assertion (cid:2) n R.B(s) in an ABox A(cid:5)and it introduces freshtree successors t1, . . . , tn of s, it also nondeterministically derives the following assertions for each 1 (cid:3) i (cid:3) n:B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091305(a) ti ≈ a or ti (cid:14)≈ a for each root individual a in A(cid:5)(b) ti ≈ u or ti (cid:14)≈ u for each individual u in A(cid:5)(c) ti ≈ u or ti (cid:14)≈ u for each tree successor u of s in A(cid:5)(d) ti ≈ t j or ti (cid:14)≈ t j for each i < j (cid:3) n, and(e) A(ti) or ¬ A(ti) for each atomic concept A occurring in (R, G, A).from the cluster of s,,,(2) The G∃-rule is modified such that, after it is applied to an assertion A(s) in an ABox A(cid:5)and it introduces fresh graphsuccessors t1, . . . , tn of s, it also nondeterministically derives the following assertions for each 1 (cid:3) i (cid:3) n:(a) ti ≈ a or ti (cid:14)≈ a for each root individual a in A(cid:5),(b) ti ≈ u or ti (cid:14)≈ u for each individual u in A(cid:5)(c) A(ti) or ¬ A(ti) for each atomic concept A occurring in (R, G, A).from the cluster of ti , and(3) When the ≈-rule is applied to an assertion ti ≈ u derived in the previous two cases, it merges ti into u.(4) The rule precedence satisfies the following restrictions in addition to the ones given in Definition 15:(a) the ⊥-rule is applied with the highest priority,(b) the ≈-rule is applied with the second-highest priority,(c) the Hyp-rule is applied to an HT-rule of the form (52) with the third-highest priority, and(d) the (cid:2)-rule is applied only if the G∃-rule is not applicable.(5) The strict ordering < used in the definition of anywhere blocking follows the creation order—that is, if an individual sis added to an ABox before an individual t, then s < t.The modified (cid:2)- and G∃-rules are obviously sound, so the proof of Claim 1 of Theorem 1 applies with minor changes.Furthermore, all assertions introduced by the (cid:2)- and G∃-rules are of the form as specified in Lemma 1, and the new ruleprecedence is stronger than the one in Definition 15; hence, the proofs of Claims 2 and 3 of Theorem 1 apply without anychange.Let A0 be an ABox labeling a node in a derivation for (R, G, A); let A1 be an ABox obtained from A0 by an applicationof the (cid:2)- or G∃-rule that introduces fresh individuals t1, . . . tn; and let A2 be a clash-free ABox obtained from A1 byexhaustive applications of the rules mentioned in Items (4a)–(4c).We now show the following property ((cid:5)): if A2 contains ti , A3 is a clash-free ABox obtained from A2 by applying oneor more derivation rules, and the ⊥-rule is not applicable to A3, then A3 contains ti as well and LA2 (ti) = LA3 (ti). Thisfollows from the following facts:• By Items (1a)–(1d), (2a)–(2b), and (4a)–(4b), ABox A2 contains an inequality ti (cid:14)≈ u for each individual u from A2 thatinto some individual from A2, then A3ti could potentially be merged into. Hence, if A3 is derived by merging ticontains ⊥.• By Item (3), if A3 is derived by an application of the ≈-rule to ti ≈ u, then u is merged into ti , so A3 contains ti .• By Items (1e) and (2c), ABox A2 contains either A(ti) or ¬ A(ti) for each atomic concept A. Hence, A3 is derived byadding an assertion of the form B(ti), then A3 contains ⊥.• By Item (4c) and the fact that R is normalized, A2 contains all assertions of the form (cid:2) n R.B(ti) implied by the HT-rules of the form (52). Since no derivation rule can introduce a concept A(ti) without introducing a clash, no HT-ruleof the form (52) can be used to derive a new assertion of the form (cid:2) n R.B(ti).• By Items (1e), (2c), and (4d), the G∃-rule is applied exhaustively to individuals in the cluster of ti before the (cid:2)-rulecan introduce a tree descendant of ti!. Therefore, if a subsequent application of the (cid:2)-rule introduces an individual v,either ti ≈ v or ti (cid:14)≈ v will be introduced by Item (1b), which allows for an inductive application of this argument.We also show the following property ((cid:6)): no individual in A3 is indirectly blocked. This is because ((cid:5)) implies that theblocking status of ti is the same in A2 and A3, which means that no descendant of ti can become indirectly blocked by ti .We also show the following property (♦): pruning never removes individuals from an ABox. This is a simple consequenceof the fact that, by ((cid:5)), Items (3) and (4a)–(4d), individual ti is either merged into an individual from A1 in the derivationof A2, or it cannot participate in merging inference used to derive A3.Let c be the number of atomic concepts in (R, G, A); by Item (5) and the definition of single blocking, A0 can containat most 2c nonblocked tree individuals. As shown in the proof of Claim 2 of Theorem 1, A0 can contain the tree clusterof each tree individual can contain at most ϑ graph individuals. Furthermore, ((cid:6)) implies that A0 can contain at mostexponentially many blocked individuals.Consider now a named individual a in A0. Since individuals are reused in graph cleanup, merging a graph individual uinto a can introduce at most ϑ individuals for each label ω(u) of the form (35). There are at most ϑ such labels, so graphcleanup can introduce at most ϑ 2 individuals for a. In the same way as in the proof of Item (3) of Claim 2 of Theorem 1,the G∃-rule can introduce at most ϑ individuals for each of the ϑ 2 individuals. Thus, A0 contains at most ϑr = i · ϑ 3 rootgraph individuals, where i is the number of named individuals in (R, G, A).Thus, the total number of individuals itot in each clash-free ABox is at most exponential in (R, G, A). Furthermore, eachderivation rule is applied to a polynomial number of individuals. Finally, by (♦), individuals are never removed from anABox by pruning. Thus, a derivation path for (R, G, A) can be constructed in nondeterministic exponential time, whichimplies our claim. (cid:2)1306B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309We now prove an analogous claim for the case when T is in SHIQ+.Theorem 7. Checking the satisfiability of a strongly separated acyclic graph-extended knowledge base K whose TBox is in SHIQ+NExpTime-complete, provided that the numbers in K are coded in unary.isProof. Hardness is shown in Lemma 3, and the membership proof is analogous to Theorem 6. The hypertableau algorithmfrom Section 6 is modified as follows:(1) The (cid:2)-rule is modified such that, after it is applied to an assertion (cid:2) n R.B(s) in an ABox A(cid:5)and it introduces freshcontains a tree predecessor u of s,tree successors t1, . . . , tn of s, it also nondeterministically derives the following assertions for each 1 (cid:3) i (cid:3) n:(a) ti ≈ u or ti (cid:14)≈ u if A(cid:5)(b) ti ≈ s or ti (cid:14)≈ s,(c) ti ≈ u or ti (cid:14)≈ u for each tree successor u of s in A(cid:5)(d) ti ≈ t j or ti (cid:14)≈ t j for each i < j (cid:3) n,(e) A(ti) or ¬ A(ti) for each atomic concept A occurring in (R, G, A), and(f) R(s, ti) or ¬R(s, ti), as well as R(ti, s) or ¬R(ti, s), for each atomic T -role R occurring in (R, G, A).,(2) The G∃-rule is modified such that, after it is applied to an assertion A(s) in an ABox A(cid:5)and it introduces fresh graphsuccessors t1, . . . , tn of s, it also nondeterministically derives the following assertions for each 1 (cid:3) i (cid:3) n:(a) ti ≈ u or ti (cid:14)≈ u for each individual u in A(cid:5)(b) A(ti) or ¬ A(ti) for each atomic concept A occurring in (R, G, A).from the cluster of ti , and(3) The ⊥-rule is amended to derive ⊥ if A(cid:5)(4) Items (2)–(5) from the proof of Theorem 7 are used without change.contains both R(s, t) and ¬R(s, t).Although negative role assertions of the form ¬R(u, v) do not satisfy Lemma 2, they do not participate in the modelconstruction from the proof of Theorem 3; therefore, Theorem 4 holds without any change. Furthermore, Item (1e) of themodified calculus ensures that, for each individual s and each tree successor t of s, labels LA(s, t) and LA(t, s) are fullydetermined after the application of the (cid:2)-rule; thus, an individual t j becomes pairwise-blocked immediately after it hasbeen introduced, or it never becomes blocked. The rest of the argument is analogous to the proof of Theorem 6. (cid:2)8. ImplementationWe have implemented our reasoning algorithm in the hypertableau-based reasoner HermiT [31]. Evaluating the adequacyof our approach is rather difficult due to lack of test data. Furthermore, remodeling existing ontologies using a new modelingparadigm may require considerable effort. In order to both obtain test data for our reasoner and make the adoption of ourapproach in practice easier, we have developed an algorithm that automatically transforms a TBox T1 into a graph-extendedknowledge base K. The knowledge base K, even if only a rough approximation, can be used as a starting point for a morecomprehensive remodeling of T1 into a proper graph-extended KB. Our experience with GALEN and the discussions we hadwith the authors of GALEN led us to conclude that the transformed KB K represents the anatomical structures in the humanbody in a way that is closer to the modelers’ intention than the original DL axioms.108.1. The transformation algorithmOur algorithm transforms a TBox T1 into a graph-extended K = (T , G, P, A) such that K is strongly-separated and Gcontains only one description graph. It would clearly be more useful if we could automatically transform T1 into severalsmaller description graphs; however, it was unclear what kinds of heuristics to use in order to determine the boundariesbetween different description graphs.Our transformation is based on two assumptions. The first assumption is that only some concepts and roles from T1are relevant to G. For example, Hand is relevant to the graph of the human body, but Fracture is not; similarly, the hasPartrole belongs to the graph, while the hasAge role does not. The second assumption is that each relevant concept shouldbe represented by one vertex in G, and edges in G can be decoded from axioms of the form A (cid:4) ∃R.B. In other words,we conjecture that, by writing axioms such as (53)–(55), modelers actually wanted to say “the index finger has a middlephalanx and a proximal phalanx as parts, and these two phalanges are attached to each other.”Index_finger (cid:4) ∃part.Middle_phalanx_oifDistal_phalanx_oif (cid:4) ∃attached_to.Middle_phalanx_oifProximal_phalanx_oif (cid:4) ∃part.Index_finger−10 Thanks to Alan Rector and Sebastian Brandt.(53)(54)(55)B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091307Table 6Information about test ontologies.Total number of concepts:Total number of roles:Total number of GCIs:GCIs discarded in the transformation:Translated GCIs:Into the description graph:Into rules over the graph:Into the DL TBoxVertices in the description graph:Edges in the description graph:GALEN2748413696232066426801555807325667FMA4303834793283151296611843421076Our algorithm is given a DL TBox T1, a set of relevant concepts NC g , and a set of relevant roles N R g . The latter setactually defines the set of G-roles, and all other roles are T -roles. Our algorithm first normalizes T1 in a certain way. Then,it creates a vertex i in V for each concept A ∈ NC g and sets λ(cid:18)i(cid:19) = { A}. Then, it processes each axiom α ∈ T1 as follows:• If α is of the form A (cid:4) ∃R.B where { A, B} ⊆ NC g and R ∈ N R g , then, for i and j vertices such that λ(cid:18)i(cid:19) = { A} andλ(cid:18) j(cid:19) = {B}, the algorithm adds the edge (cid:18)i, j(cid:19) to E and extends λ such that R ∈ λ(cid:18)i, j(cid:19).• If α does not contain a role in N R g , then α is copied to T .• If α contains only roles from N R g and no existential quantifier, the algorithm translates α into a graph-regular rule andadds it to P .• If α is not of the above form, then either it involves a G-role and a T -role simultaneously, or it is of the form A (cid:4) ∃R.Bbut some of A, B, or R are not relevant for the graph. Such an axiom either invalidates the syntactic restrictions of ourformalism or it does not have a natural interpretation. Human intervention would be needed to interpret such axiomsin a “reasonable” way; therefore, such axioms are discarded by our algorithm.strategy is to manually identify a set of roles NDetermining the sets NC g and N R g manually is not easy. According to our experience with GALEN and FMA, a goodthat naturally belong to the graph, and then to take N R g as the closure of(cid:5)w.r.t. the explicit role inclusions from T1. Then, we take NC g as the set of all concepts A and B occurring in an axiomNR gA (cid:4) ∃R.B ∈ T1 such that R ∈ N R g . Intuitively, if A and B are connected by a role that should be included into the graph,then it is likely that A and B should be included into the graph as well.(cid:5)R g8.2. Classification resultsTo evaluate our approach, we have classified the original version of GALEN and a fragment of FMA. Next, we havetransformed them into graph-extended KBs, and classified the resulting KBs using the reasoning algorithm presented inSection 6. We now discuss the obtained results. Table 6 summarizes information about the original and the transformedontologies.We performed the experiments using a standard laptop with 1 GB of RAM. Classification of the original version of GALENand the fragment of FMA took 129 s and 57 s, respectively; furthermore, classification of the transformed ontologies took781 s and 6 s, respectively. The increase in classification time for GALEN is partly due to the prototypical nature of ourimplementation. In the case of FMA, classification times are substantially lower because most of the original ontology istranslated into the graph, so the generated models are much smaller. Our results show that, even with a very prototypicalimplementation, complex ontologies can be processed, which we take as indication that our approach is practically feasible.Our transformation leads to a change in the semantics of the ontology: some axioms are lost in the process, and thesemantics of many axioms is modified. Many parts of the resulting description graph, however, correspond with an intuitivedescription of the human body. For example, the (union of) the graphs shown in Figs. 2b–2e has been extracted from thetransformed ontology.Although some information is lost in the translation, the resulting description graphs can be seen as being “more precise”than the original axioms, so one can expect to obtain new entailments. For example, we discovered in GALEN a conceptthat is satisfiable in the original ontology, but is unsatisfiable in the transformed ontology; this revealed a modeling errorin the original ontology. The problem occurs in the representation of the patella—a bone in a knee that is connected to cer-tain tendons through two retinacula, represented using the concepts LateralPatellaRetinaculum and MedialPatellaRetinaculum.GALEN describes the relationship between the patella and the two retinacula as follows:LateralPatellaRetinaculum ≡ ∃hasOtherEndAt.Patella (cid:8) (. . .)MedialPatellaRetinaculum ≡ ∃hasOtherEndAt.Patella (cid:8) (. . .)(56)(57)1308B. Motik et al. / Artificial Intelligence 173 (2009) 1275–1309hasOtherEndAt ≡ isAtOtherEndOf(cid:6) (cid:4) (cid:3) 1 isAtOtherEndOf−(58)(59)In a human body, each patella is connected to a lateral and a medial retinaculum. In GALEN, however, isAtOtherEndOfis functional, so the two retinacula connected to a patella must always be one and the same object. This leads us tobelieve that isAtOtherEndOf probably should not have been declared functional. GALEN, however, is underconstrained: itdoes not require the lateral retinaculum and the medium retinaculum of a knee to be connected to the same patella, andit does not state that the lateral retinaculum and the medial retinaculum are different from each other. Consequently, theconcept Patella is consistent in GALEN, and this modeling error was not detected. The description graph produced by ourtransformation, however, contains one node for the patella and one for each retinaculum; furthermore, both retinacula areconnected through isAtOtherEndOf to the same patella. Since isAtOtherEndOf is functional, the retinacula should be the same,which invalidates the disjointness property of description graphs (see Definition 10) and makes Patella unsatisfiable.9. ConclusionWe have presented an expressive formalism that extends DLs with description graphs and rules, allowing for moreprecise modeling of arbitrarily connected structures. Our formalism is applicable not only to anatomy, but to all domains inwhich the number of arbitrarily interconnected objects has a natural bound.The main open theoretical challenges are to determine the decidability and/or complexity of reasoning with graph-extended knowledge bases under different assumptions on the expressivity of the DL TBox T and the set of rules P . Allour undecidability results from Section 5 require T to contain number restrictions. We conjecture that if T is not allowedto contain number restrictions, P = ∅, and G does not contain graph alignments, then reasoning becomes decidable even ifG is not acyclic. This is because such T and the properties from Table 4 apart from the key and the disjointness propertiescan be transformed into an equivalent formula of the guarded fragment of first-order logic which is known to be decidable[2]; furthermore, the key and the disjointness properties seem “innocuous” because they merely prevent an axiomatizationof infinite chains of instances of one description graph. Another important research direction is to see whether decidabilitycan be achieved by placing different restrictions on the set of rules P . For example, we conjecture that, even without anyrole separation requirement, our formalism can be extended with ELP rules [24] without losing decidability. Finally, thecomplexity of reasoning with a strongly separated and acyclic graph extended knowledge base whose TBox is in SHOIQ+is open.The main practical challenge is to validate the applicability of our formalism in these and other applications. To thisend, we will extend the ontology editor Protégé 4 to support description graphs and apply our formalism in the identifiedpractical scenarios.References[1] S. Abiteboul, R. Hull, V. Vianu, Foundations of Databases, Addison Wesley, 1995.[2] H. Andréka, J. van Benthem, I. Németi, Modal languages and bounded fragments of predicate logic, Journal of Philosophical Logic 27 (3) (1998) 217–274.[3] F. Baader, D. Calvanese, D. McGuinness, D. Nardi, P.F. Patel-Schneider (Eds.), The Description Logic Handbook: Theory, Implementation and Applications,2nd edition, Cambridge University Press, August 2007.[4] F. Baader, U. Sattler, An overview of tableau algorithms for description logics, Studia Logica 69 (2001) 5–40.[5] Franz Baader, Carsten Lutz, Holger Sturm, Frank Wolter, Fusions of description logics and abstract description systems, Journal of Artificial IntelligenceResearch 16 (2002) 1–58.[6] P. Baumgartner, U. Furbach, I. Niemelä, Hyper tableaux, in: Proc. of the European Workshop on Logics in Artificial Intelligence (JELIA ’96), Évora,Portugal, September 30–October 3, 1996, in: LNAI, vol. 1126, Springer, 1996, pp. 1–17.[7] E. Börger, E. Grädel, Y. Gurevich, The Classical Decision Problem, Springer, 1996.[8] A. Borgida, On the relative expressiveness of description logics and predicate logics, Artificial Intelligence 82 (1–2) (1996) 353–367.[9] A. Calì, G. Gottlob, M. Kifer, Taming the infinite chase: Query answering under expressive relational constraints, in: Gerhard Brewka, Jérôme Lang(Eds.), Proc. of the 11th Int. Joint Conf. on Principles of Knowledge Representation and Reasoning (KR 2008), Sydney, NSW, Australia, August 16–19,2008, AAAI Press, 2008, pp. 70–80.[10] Bernardo Cuenca Grau, Ian Horrocks, Boris Motik, Bijan Parsia, Peter Patel-Schneider, Ulrike Sattler, OWL 2: The next step for OWL, Journal of WebSemantics: Science, Services and Agents on the World Wide Web 6 (4) (2008) 309–322.[11] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Computing Surveys 33 (3) (2001) 374–425.[12] J. de Bruijn, A. Polleres, R. Lara, D. Fensel, OWL DL vs. OWL flight: Conceptual modeling and reasoning on the semantic web, in: Proc. of the 14th Int.World Wide Web Conference (WWW2005), Chiba, Japan, May 10–14, 2005, ACM, 2005, pp. 623–632.[13] S. Demri, H. de Nivelle, Deciding regular grammar logics with converse through first-order logic, Journal of Logic, Language and Information 14 (3)(2005) 289–329.[14] F.M. Donini, M. Lenzerini, D. Nardi, A. Schaerf, AL-log: Integrating datalog and description logics, Journal of Intelligent Information Systems 10 (3)(1998) 227–252.[15] T. Eiter, T. Lukasiewicz, R. Schindlauer, H. Tompits, Combining answer set programming with description logics for the semantic web, in: D. Dubois,C.A. Welty, M.-A. Williams (Eds.), Proc. of the 9th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR 2004), Whistler, Canada,June 2–5, 2004, AAAI Press, 2004, pp. 141–151.[16] A. Goderis, U. Sattler, C.A. Goble, Applying description logics for workflow reuse and repurposing, in: Ian Horrocks, Ulrike Sattler, Frank Wolter (Eds.),Proc. of the 2005 Int. Workshop on Description Logics (DL 2005), Edinburgh, UK, July 26–28, 2005, in: CEUR Workshop Proceedings, vol. 147.[17] H. Graves, Representing product designs using a description graph extension to OWL 2, in: Alan Ruttenberg, Ulrile Sattler, Cathy Dolbear (Eds.), Proc.of the 5th Int. Workshop on OWL: Experiences and Directions (OWLED 2008 EU), Karlsruhe, Germany, October 26–27, 2008.B. Motik et al. / Artificial Intelligence 173 (2009) 1275–13091309[18] J.E. Hopcroft, R. Motwani, J.D. Ullman, Introduction to Automata Theory, Languages, and Computation, 2nd edition, Addison Wesley, 2000.[19] I. Horrocks, H. Graves, Application of OWL 1.1 to systems engineering, in: K. Clark, P.F. Patel-Schneider (Eds.), Proc. of the OWL: Experiences andDirections Workshop (OWLED 2008 DC), Washington, DC, USA, April 1–2, 2008.[20] I. Horrocks, P.F. Patel-Schneider, A proposal for an OWL rules language, in: Proc. of the 13th Int. World Wide Web Conference (WWW 2004), New York,NY, USA, May 17–22, 2004, ACM Press, 2004, pp. 723–731.[21] I. Horrocks, U. Sattler, Decidability of SHIQ with complex role inclusion axioms, Artificial Intelligence 160 (1–2) (December 2004) 79–104.[22] M. Kifer, G. Lausen, J. Wu, Logical foundations of object-oriented and frame-based languages, Journal of the ACM 42 (4) (1995) 741–843.[23] M. Konyk, A. De Leon Battista, M. Dumontier, Chemical knowledge for the semantic web, in: Proc. of the 5th Int. Workshop on Data Integration in theLife Sciences (DILS 2008), in: LNCS, vol. 5109, Springer, 2008, pp. 169–176.[24] M. Krötzsch, S. Rudolph, P. Hitzler, ELP: Tractable rules for OWL 2, in: Amit P. Sheth, Steffen Staab, Mike Dean, Massimo Paolucci, Diana Maynard,Timothy Finin, Krishnaprasad Thirunarayan (Eds.), Proc. of the 7th Int. Semantic Web Conference (ISWC 2008), Karlsruhe, Germany, October 26–30,2008, in: LNCS, vol. 5318, Springer, 2008, pp. 649–664.[25] O. Kutz, I. Horrocks, U. Sattler, The even more irresistible SROIQ, in: P. Doherty, J. Mylopoulos, C.A. Welty (Eds.), Proc. of the 10th Int. Conf. on thePrinciples of Knowledge Representation and Reasoning (KR 2006), Lake District, UK, June 2–5, 2006, AAAI Press, 2006, pp. 68–78.[26] A.Y. Levy, M.-C. Rousset, Combining Horn rules and description logics in CARIN, Artificial Intelligence 104 (1–2) (1998) 165–209.[27] B. Motik, Reasoning in description logics using resolution and deductive databases, PhD thesis, Univesität Karlsruhe, Germany, 2006.[28] B. Motik, B. Cuenca Grau, U. Sattler, Structured objects in OWL: Representation and reasoning, in: Proc. of the 17th Int. World Wide Web Conference(WWW 2008), Beijing, China, April 21–25, 2008, ACM Press, 2008, pp. 555–564.[29] B. Motik, R. Rosati, A faithful integration of description logics with logic programming, in: Proc. of the 20th Int. Joint Conf. on Artificial Intelligence(IJCAI 2007), Hyderabad, India, January 6–12, 2007, Morgan Kaufmann Publishers, 2008, pp. 477–482.[30] B. Motik, R. Shearer, I. Horrocks, Optimized reasoning in description logics using hypertableaux, in: F. Pfenning (Ed.), Proc. of the 21st Conference onAutomated Deduction (CADE-21), Bremen, Germany, July 17–20, 2007, in: LNAI, vol. 4603, Springer, 2007, pp. 67–83.[31] B. Motik, R. Shearer, I. Horrocks, Hypertableau reasoning for description logics, Technical report, University of Oxford, 2008. JAIR, submitted for publi-cation.[32] Boris Motik, Ulrike Sattler, Rudi Studer, Query answering for OWL-DL with rules, Journal of Web Semantics 3 (1) (2005) 41–60.[33] J. Mylopoulos, A. Borgida, M. Jarke, M. Koubarakis, Telos: Representing knowledge about information systems, ACM Transactions of Information Sys-tems 8 (4) (1990) 325–362.[34] P.F. Patel-Schneider, P. Hayes, I. Horrocks, OWL web ontology language: Semantics and abstract syntax, W3C Recommendation, http://www.w3.org/TR/owl-semantics/, February 10, 2004.[35] D.A. Plaisted, S. Greenbaum, A structure-preserving clause form translation, Journal of Symbolic Logic and Computation 2 (3) (1986) 293–304.[36] R. Rosati, DL+log: A tight integration of description logics and disjunctive datalog, in: P. Doherty, J. Mylopoulos, C.A. Welty (Eds.), Proc. of the 10thInt. Conf. on the Principles of Knowledge Representation and Reasoning (KR 2006), Lake District, UK, June 2–5, 2006, AAAI Press, 2006, pp. 68–78.[37] R.A. Schmidt, U. Hustadt, A principle for incorporating axioms into the first-order translation of modal formulae, in: F. Baader (Ed.), Proc. of the 19thInt. Conf. on Automated Deduction (CADE-19), Miami Beach, FL, USA, July 28–August 2, 2003, in: LNAI, vol. 2741, Springer, 2003, pp. 412–426.[38] S. Tobies, Complexity results and practical algorithms for logics in knowledge representation, PhD thesis, RWTH Aachen, Germany, 2001.[39] M.Y. Vardi, Why is modal logic so robustly decidable?, in: N. Immerman, P. Kolaitis (Eds.), Proc. of a DIMACS Workshop on Descriptive Complexity andFinite Models, Princeton University, USA, January 14–17, 1996, in: DIMACS Series in Discrete Mathematics and Theoretical Computer Science, vol. 31,American Mathematical Society, 1996, pp. 149–184.