Artificial Intelligence 86 (1996) 43-73 Artificial Intelligence Graph search methods for non-order-preserving evaluation functions: applications problems * to job sequencing Anup K. Sen*, Amitava Bagchi’ Indian Institute of Management Calcutta, Joka, D. H. Road, P.O. Box No. 16757, Calcutta 700 027, India Received March 1994; revised April 1995 Abstract Graph search with A* is frequently faster than tree search. But A* graph search In the non-order- function is order-preserving. operates correctly only when the evaluation preserving case, no paths can be discarded and the entire explicit graph must be stored in memory. Such situations arise in one-machine minimum penalty job sequencing problems when setup times are sequence dependent. GREC, memory-constrained over A* in that it is able to find optimal solutions as efficient as A* in solving graph search problems with order-preserving functions. Experimental indicate faster than both best-first and depth-first larger size than best-first that in the non-order-preserving tree search, and can solve problem search algorithm of the authors called MREC, has a clear advantage to such problems. At the same time, it is the unlimited memory version of a is instances of case, GREC tree search. evaluation results 1. Introduction Many attempts have been made in recent years to widen the range of problem areas to which algorithm A* [8] can be usefully applied. As part of this effort, A* in areas such as project has been employed stock cutting [29]. In both these cases the search scheduling running A* and running a graph job standard is little distinction between best-first branch-and-bound to solve optimization [3] and rectangular is a tree, so there job sequencing procedure. problems and In * A major part of the work Institute reported of Technology, at the School of Industrial Management, here was completed Newark, NJ 07102, USA, where both authors were visitors. New Jersey * Corresponding ’ E-mail: bagchi@iimcal.ernet.in. author. E-mail: sen@iimcal.ernet.in. 0004-3702/96/$15.00 0 1996 Elsevier Science B.V. All rights reserved SSDI 0004-3702(95)00094-l far higher execution speeds have sometimes as a graph instead of as a tree of jobs on one machine. branch-and-bound the penalty functions algorithm It has been [28] are quadratic been achieved [15,22,24,25]. found for minimum that runs 25 to 40 implemented that graph search methods as an A”-based are likely graph search to find greater use in scheme. search procedure however. stock cutting and related optimization in existence. problems. Some other in recent years which either view the search space as [21] graph search tree deepening and does not use an stack. But it can be fed of nodes It is a constrained of the is recursive [17,27]. MREC in tree search for its implicit tells it how much additional memory memory iterative is available it stores as much as possible of the explicit graph. When as a generalization [lo]. Unlike A*, MREC is sufficient memory faster classic suggest howcvcr. sequencing scheduling, represented the optimal the search graph for 16 jobs when the only graph have been proposed [Y] or try to avoid duplication such methods. in sequencing, is not sequencing best-first of jobs when scheduling, with Consider Townsend’s penalty times Such examples future A” methods a graph is one of the earliest algorithm search OPEN at run time a parameter M which In this memory, for use. M is small increases, MREC makes when node expansion graph explicit comparable scheme list. All it needs that can be viewed it approximates IDA* time and does not expand to A”. is called GREC to IDA”: and expands each node many times. As M fewer and fewer node expansions, which is significant. When M is large MREC than once; any node more is of advantage stores the entire it then becomes in But from case. function solutions functions no path functions. evaluation MREC(M is efficient to problems it is possible in this paper, It is also able that is currently is order-preserving, the non-order-preserving lOO-1031) . so in this respect in solving graph to find involving norm-order-preserving evaluation it has a clear advantage a path [14, pp. that when an evaluation in performance = x), which search problems with order-preserving optimal over A*. We (Pearl recall the root to a node can be discarded when a path of lower cost is found. A” is based on this principle. because for a path at later stages of the search process. Such situations jobs are allowed get the machine been completed time processed setup search methods dent, however, unsuitable advantages size. be used it is sequence dependent. When graph depen- and A* is the retain can be discarded, to become promising in job sequencing when taken to job has job can begin. The setup tree search the entire explicit graph has to be stored, yield optimal the evaluation search search over to have setup ready and before .I is sequence solutions. When function becomes graph time for a job is the time of the previous of small and medium like GREC must the processing of the current if it does not matter which times are ignored or assumed in place of A* [23]. unless of graph to job J; otherwise, times are sequence non-order-preserving, times. The setup and an algorithm as a tree. To to be sequence is implemented the processing for processing for problems independent independent, immediately unpromising for a job A*-based setup prior arise after job the is Job sequencing and job scheduling solutions since most problems are areas are NP-complete in which it is difficult to find exact [ 191; as a result, approximation A.K. Sen, A. Bagchi / Artificial Intelligence 86 (1996) 43-73 4.5 used in recent years. Promising that in flow shop scheduling, than the best of the classical heuristics to sequencing and scheduling methods have been extensively approaches employ artificial neural networks and tabu search [16]. It has been demonstrated, tabu search obtains solutions uniformly for example, [26]. A list of applications of tabu better is given in [16, Table 3.1, p. 1281. Similar search if only approaches might prove useful approximate in practice, problem Our interest exact methods any detail. sizes tend to be large and exact methods become is primarily infeasible. the scope of use of in in job sequencing, so we do not discuss approximation methods in this paper, however, solutions are desired. in minimum penalty job sequencing in situations that arise It is true to extend that This paper is organized as follows: (a) In Section 2 we review algorithm GREC its principle of operation with the help of an example. We then formally state and prove some of its important properties. and explain that in cases life problems interest being solves one-machine to show how GREC that have non-order-preserving times. As a first step in this direction, try our particular setup times. Section 4 explains how graph search with GREC (b) We then problems, dependent problems are described class of real functions to duplication of nodes the execution multiple provide answers one-machine minimum penalty dependent bound methods have been employed [4,13]. We show that when problem GREC best-first and depth-first than best-first last section summarizes compares GREC with some other similar search schemes. job sequencing involve sequence- job sequencing in Section 3, and the existence of an interesting evaluation is demonstrated. Tree search can solve such problems, but owing is slow and some nodes get expanded can to such problems. The quadratic penalty version of the job sequencing problem with sequence- interest. Depth-first branch-and- in the past to solve similar problems instances are of small and medium size, is to be preferred over other methods since it runs faster than both tree search, and also solves problems of larger size the paper and setup times has great practical tree search. The 2. Algorithm GREC GREC GREC solutions when heuristic is identical to MREC [21] with the memory parameter M set to infinity. It outputs optimal are admissible, never expanding a node more than once. We explain its principle of operation below. recursive procedure EXPLORE, which, at each the explicit iteration explores graph contains only the root node. EXPLORE moves down a path in the explicit a tip node, i.e., a node which as no successors in the graph until it encounters the tip node and adds the new nodes and edges to the explicit graph. It expands the explicit graph below the root node s. Initially is based on estimates the 46 A. K. Sm. A. Bagchi I Artificial Intelligence 86 (1996) 43-73 explicit graph. As in IDA”‘, a cutoff value movement. terminates GREC when it encounters is used Each node n in the explicit graph has a b-value for monitoring goal node. b(n) which stores the downward the current estimate node, b(n) equals the heuristic estimate h(n). of the cost of a path of least cost from II to a goal node. When n is a tip program GREC; var terminate; begin (* initially the explicit graph contains the root node s “) terminate initialize repeat : = false; s (:I: b(s) = h(s) :‘); EXPLORE(s) terminate; until output output b(s) as solution outpath as solution cost; path; end. procedure EXPLORE(n:node); begin if n is a goal node begin then terminate : = true; return; end; if n is a tip node UPDATE(n); (* updation then EXPAND(n); takes place whether n is a tip node or a non-tip node *) end; procedure EXPANJl(n:node); begin (* if y1 has no successors then b(n) = h(n) = x, so EXPLORE and therefore EXPAND will never get called at II ‘“) for each successor n, of n do if II, is not present begin in the explicit graph then initialize add n, and n,; (:” b(n)) = h(n,) (n, n,) the edge :‘:) to the explicit graph; end else add end; the edge (n, n,) to the explicit graph; procedure UPDATE var cutoff: begin integer: (n:node); A.K. St-n, A. Bagchi I Artijcial Intelligence 86 (1996) 43-73 47 cutoff := 00 (* a very large value *); for each successor IZ, of 12 do begin if b(n) 3 b(n,) + c(n, n,) then begin : = b(n) - c(n, n,); b(q) EXPLORE(q); (* exploration continues to greater depths until the bound is exceeded *) if terminate begin then add ni to outpath; return; end; end; (* at this point b(n,) + c(n, ni) > b(n) *) if b(ni) + c(n, ni) < cutoff then cutoff : = b(n,) + c(n, n,); end; b(n) : = cutoff; end. The downward movement along a path is determined by the b-values of the the cost of the arc nodes on the path and the costs of the arcs. Let C(IZ, ni) denote IZ~ of IZ such that (n, ni). When GREC on reaching a node II finds a successor then b(ni) gets b(n) 2 b(ni) + c(lt, n,), reset below ni. If b(n) < b(n,) + ~(12, n,) for every successor IZ~ of IZ, then none of the successors get in this case, b(n) gets reset to the minimum of the b(n,) values. If IZ is explored; explored at a subsequent IZ will have a successor n, in the explicit graph for which b(n) 3 b(n,) + c( IZ, IZ~), and n, will also be explored. it explores ni. If b(n) > b(ni) + c(n, n,), to a larger value, and this allows a deeper exploration iteration, explores EXPLORE calls two procedures, EXPAND and UPDATE. EXPAND expands to the explicit graph. a tip node and adds newly generated nodes and edges the b-values of nodes; it UPDATE carries out this makes GREC and recursive. The output solution path is stored in outpath. The explicit search graph and its associated parameters the graph below a node and updates by calling EXPLORE, the exploration are assumed to be accessible to all the procedures. superficial in spite of certain the above description it is clear From that resemblances, GREC differs radically from IDA* in two major respects: (i) GREC stores the entire explicit graph in memory. This amounts to storing the nodes and the successor lists. IDA*, in contrast, does not store any part is of the explicit graph available to GREC, no node needs to be expanded more than once. Note that unlike GREC, A* does not store the entire explicit graph in memory; the currently it stores a spanning known minimum cost path to each node. tree of the explicit graph that contains the entire explicit graph in memory. Because (ii) IDA* is a tree search algorithm. When it searches a graph that is not a tree, the graph to a tree in the course of the search. GREC it implicitly converts 4x A. K. Sen. A. Bagchl I Artificial Intelligence 86 (1996) 43-73 I-ig. I. Search graph tor Example I. is a genuine convert graph search method to a tree. the graph and views a graph as a graph; it does not from the search graph instant correspond 1. Consider cost path Example minimum expansions made by GREC A*. Let each instant, at and estimates b(s) gets updated is the minimum c(s, n) + b(n). At instant 2, n gets expanded. EXPLORE(s) termination is called of GREC and b-values to 6, which shown in Fig. 1. We want the start node s to a goal node. The sequence is snpm, which differs to a fresh call the sequence from to EXPLORE(s); to find the of node snpmp of ith the at 3 at instant for the ith shown are of nodes are encircled. At instant in Fig. 2. time. The explicit graphs In the figures, 1, s gets expanded heuristic and of the two values c(s, m) + b(m) and is Since b(n) is 3 and c(n, p) + b(p) Fig. 2. Explicit graphs during the execution of GREC. A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 49 also 3, p also gets expanded, and the b-values of p, n and s are revised to 10, 13 and 11 respectively. At instant 3, m gets expanded and b(s) is revised to 12. At instant 4, GREC terminates with smpr as the minimum cost solution path. An experimental is given comparison of GREC with A* and IDA* on a variety of fast in in [21]. The data that GREC runs quite indicates problems general; a few examples are given below. (9 (ii) ‘(‘i: 1v it is as fast as 15puzzle problem problem with the Manhattan heuristic, it runs short of memory is able to solve this problem On the 8-p&e IDA*. On the corresponding just like A*. But MREC with limited memory as fast as IDA*. On the travelling salesman problem using the evaluation function of Little et al. [12], as well as on a graph formulation of the problem suggested by Pearl [14], it is as fast as A*. On the rectangular cutting stock problem On a general uniform d-ary single goal node, and randomly generated admissible heuristic estimates, is faster than both A* and IDA*. arcs of unit cost, a it [29], it is as fast as A*. tree with bi-directional The power of GREC comes from the use of the b-value, which estimates the cost of the best path from the node to a goal; the b-value helps to determine whether further exploration below the node is worth pursuing, and is an extremely useful feature. Comparing (9 the characteristics of GREC, A* and IDA*, we find that: function is able to solve the problem. is admissible and order-preserving, all three When the evaluation like IDA* always algorithms find optimal solutions. A tree search method finds optimal solutions, even when the evaluation is non-order- preserving, but A*-based graph search methods can fail to do so. GREC, however, and GREC solution paths can also differ. But GREC and IDA* always output same solution path. Unlike A* and IDA*, GREC never expands a node more than once. The worst-case running time of GREC, exponential in the number of nodes in the search graph. like that of A* and IDA*, can be and A* sometimes expand nodes in different function the the order, (ii) i’i: IV Some of these issues, as for example (iv), are discussed in greater detail in Section 2.1.1. 2.1. Properties of GREC: theoretical formulation 2.1.1. Constant arc costs We now state and derive some important initially assume that arc costs are constant, and later extend arc costs. The notation and terminology dependent results are given in Appendix A. of important theoretical properties of GREC. We the results to path are adapted from [l]. Proofs A search graph G is a directed graph with a special node s called the root node, 50 A. K. Sm. A. Hugchi : Artificiul lntellqpcc~ X6 (19%) J3- 7.1 of directed the root node path of minimum in G, and strictly be the goal nodes arc (m, n) has a finite, arcs; a .solution to a goal node. The cost c(P) of a path P is the is to find a this path by non-negative set of goul nodes. Let r, r, . r,. in G. Each directed . the other nodes arc cost c(m, n). A path is a finite sequence and a non-empty m. n, positive path is a path from sum of the costs of the arcs which make up the path. Our objective solution to find systematically heuristic estimate h(m), and values. The search graph G is called to the algorithm. What which When instants, nodes get expanded. searching G. Each node m in G has an associated the explicit graph, the explicit graph consists of the root node S. are added to the explicit graph. At subsequent in the explicit graph as more and more is given of G. Initially its successors estimate is not really supplied fresh nodes and arcs get included is a subgraph s is expanded the implicit graph and is a set of rules these heuristic in G. GREC. for generating is guided like A*, search tries cost the by The ensure following that the search conditions (i) G has exactly one are is well defined root node, frequently and at imposed on the search graph G to that it terminates successfully: least one goal node, solution G has finitely many directed loops or cycles. path. G can have infinitely many nodes and arcs, but each node immediate successors. It is permissible and at least one in for G to have (ii) There and is a real number 7 > 0 such T. Since c(rn. n) > 0, this condition nodes, true always is therefore ical studies, when G has infinitely many nodes and arcs, that imposed that for each arc (m, n) in G, c(m, n) 3 if G has finitely many in theoret- to ensure algorithm on the arc costs. always holds in practical lower bound must be But in order the search a non-zero terminates situations. (iii) For each non-goal node m in G, the heuristic estimate is a path there or infinite; with no successors. in G from m to a goal node. Otherwise, in particular, we take h(m) to be infinite if m is a non-goal If r is a goal node then we take h(r) = 0. h(m) is finite if h(m) can be finite node Definition 2. (i) Let an instant correspond is thus to a fresh invocation of EXPLORE(s); the moment instant time. explicit graph, we say that n is explored at instant at which EXPLORE(s) If EXPLORE(n) is invoked at instant is called for j for some node graph with j. root s at instant the the II in ith ith the the explicit (ii) Let G,’ be subgraph ately prior graph at that moment.) to the jth of G,’ with m as root. (Consider the moment invocation of EXPLORE(s), and j, and G;(m) the of time immedi- look at the explicit (iii) By bj(m) we mean the b-value of the node m at instant mean hi(s). Let b* denote in G. the cost of the solution j, and by bj we cost path of minimum (iv) The explicit graph G,’ at instant j is consistent to a tip node n in G: such that for every non-tip if there is a path P from s node m lying on P, bj(m) A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 51 solution path below S. At the initial instant, is finite and equals c(P, m, n) + h(n), where c(P, m, n) is the cost of path P from m to n. The path from m to y1 along P is called the potential solution path (psp) below m at instant j; psp (without qualification) to the refers the explicit graph potential G; contains since b(s) = h(s), the psp consisting of just the node S. When G,! is consistent, the tip node n of the psp (where II could be a goal node) gets explored at instant j; if G,! is not consistent then no tip node is expanded at instant j. Let Pi, Pi, . . . , PL be the paths in GI from a node m to tip nodes. Define is viewed as being consistent the node S. Gi just (4 indicates the cost of path Pi! from m to m’; c(P,!, m) is Here c(P:, m’) taken to be zero, so that Q;(m) equals h(m) if m is a tip node. By Q,! we mean Q;(S). Note that Qi = h(s). LetP,, PkS be the paths in G from m to goal nodes. Define P2,..., (vi) Q(m) =,z$, [?z$ {c(Pi, m’) + h(m’)I] 7 (vii) indicates where c(P,, m’) the cost of the path Pi from m to m’. If m is a goal node then Q(m) = 0. If there are no solution paths passing through m then Q(m) = M. By Q we mean Q(s). Note that Q is always finite. The heuristic estimate function in G, h(m) never exceeds goal node; otherwise admissible, Q = b*. is admissible if for each non-goal node m the cost of a minimum cost path from m to a is is inadmissible. When the heuristic the heuristic that at termination, GREC has the property the cost of the output solution path is bounded above by Q. When the heuristic estimate function this path is the minimum cost solution path in the search graph. The results are stated in Theorems 10 and 12. In order to establish the theorems, we first show that at any node m in the explicit graph, Q’(m) is bounded above by Q(m). As the execution of GREC proceeds, Q,! approximates Q more closely and finally equals Q. is admissible, Lemma 3. Let m be a node with immediate successors m, , m,, Then . . . , mk in Gi . Q;(m) =,pIa2k [h(m), min{c(m, mi> + Qj(mi)>l . Lemma 4. Let j and j’ be two instants during the execution of GREC, where j <j’. Then for any node m in G,!, Q,!(m) s Q;,(m) =S Q(m) . Lemmas 3 and 4 follow immediately from the definitions of Q\(m) and Q(m). 52 A. K. Sen. A. Bugchi i Artificial Intelligence 86 (lYY6) 43-7.1 Corollary j<j’. Then 5. Let j and j’ be two instants during the execution of GREC, where Q,’ s Q;, c Q How is the b-value by Q at every instant, at the root node as the next lemma shows. related to its Q-value? It is bounded above Lemma 6. Let j be any instant during the execution of GREC. Then for any node m in G,‘: (i) bj(m) c Q;(m) (ii) b, -I Q,’ c Q. Corollary 7. If the explicit graph is consistent at instant j, then for every node m on P where P is the psp at instant j, b,(m) = Q,‘(m). Remark 8. (i) for which than Q(m). See proof of Lemma 6. Appendix A. then at termination the root, there might be a node is the b-value (ii) then at every instant j, b,(m) = Q,‘(m) for is inadmissible, If the heuristic m on the output path, where m is not greater If the search graph every node m in G,‘. the search graph is not consistent. is not a tree, For example, is a tree, (iii) When graph Fig. 1. we make c(m, p) = 6 and h(p) = 6, keeping same. Then 13, 16, and at instant taken by b(s) at successive 5 the explicit graph there are instants the values suppose that at which the explicit in the search graph of the are 0, 6, 11, 12, all other values instants is not consistent. Lemma 9. Let j be any positive integer. If GREC has not terminated by instant j then at some instant j’ 2 j prior to termination, G,‘. is consistent. Theorem and outputs a solution path. 10. Algorithm GREC terminates successfully, i.e., it finds a goal node Definition 11. Let b,;,,,- be the b-value at the root s when GREC terminates. Theorem 12. (i> b ciKE<‘ = Q. (ii) b (iREC = b* if the heuristic estimate function is admissible. Which nodes of the search graph are expanded in the set V defined below. contained by GREC? These are the nodes Definition 13. We construct a finite set of nodes V as follows: (i) s is in V. A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 53 (ii) A node m of G is in V is a path P from s to if there c(P) + h(m) s Q, and the immediate predecessor of m on P m such that is in V. Theorem 14. All nodes expanded by GREC belong to the set V. the immediate the running is found over time of GREC, the procedure EXPLORE it seems appropriate is called before To form an idea about the number of times terminates. When EXPLORE(m) to the count is called for the first time, node m algorithm if it is not a goal node, and the minimum of the values b(m,) + gets expanded successors of m. When m is explored c(m, m,) subsequently it is not expanded again but the minimum is recomputed. Thus, the number of such computations can serve as a good measure of the running time of GREC. the number of revolutions made around a loop depends on the costs of the arcs the arc costs.) Do there exist forming search graphs which force GREC number of calls to the existence of such a search EXPLORE? The following example demonstrates graph. (This makes sense only when G is loop free; when there are loops, the loop and can be increased by reducing to make an exponential Example 15. Consider features: the search graph G shown in Fig. 3. G has the following (i) Total number of nodes U, = 2k + 1. (ii) All heuristic estimates are zero. (iii) The arc costs are as follows: ml m2 s=no n 4 G .n “k-1 Fig. 3. Search graph for Example 1.5. 53 A. K. Sen. A. Hugchi )/ Artijicial Intelligencr~ 86 ( 1996) W- 7.3 expands nodes When k = 4, GREC m, gets expanded, there II, or m, gets expanded, m,, m,, m,. ml. m, in the given order. The which be exponential below by the total number of this is an inconsistency inconsistencies in U, for networks is bounded type. in the order n,,m,n,m,n2m,n,m,. When n1 or at m, which must be resolved. When at the nodes m,, m,, must be resolved total number of inconsistencies of calls to EXPLORE, to be resolved, will 2.1.2. Path dependent arc costs We now extend our results to path dependent arc costs. Here the heuristic at a node m and estimate path by which m is reached Section 2.1.1; any notation meaning. the costs of the arcs emanating from the root. We redefine from m depend some the notation on the of not specifically redefined continues to have its earlier Definition 16. (i) Let P be a path from estimate estimate of node m calculated with reference the root s to a node m in the search graph G. Let c(P, m, n) be the cost along path P from node m to node n. Let h(m, P) be to path P. The the heuristic for heuristic the cost every path P from from m to a (computed with goal node. In the definitions with c(P. m. m,). function the reference if for each node m in G and to P) of the minimum to rn. h(m, P) never of consistent explicit is admissible root node and psp, cost path c(m, m,) exceeds replace graph (ii) (iii) Let PI. PJ, , P; be the paths in G,‘(m) from m to tip nodes, and let P’ be a path from s to m in G:(m). Define (4 Q:(m, P’) = min I*,-/, I ,mz;, (c(P’. C’:, m’) + h(m’, P’)} 1 . Here c(P’, P,‘. m’) by path P’; c(P’. P:, m) h(n, P’) when node and m itself mean Q,‘(s,_). is taken is the cost of the path P,’ from m to m’ as defined let Q,‘(n, P’) = to be zero. Also from m to a tip If there are no paths then Ql(m, P’) = x. By Q,’ we is not a tip node r7 is a tip node. (b) Q:(m) = max(Q,‘(m, P’)) the maximum where explicit graph GI. is taken over all paths P’ from s to m in the (iv) Let P, . P2, nodes, and . P,. be the paths in the search graph G from m to goal let P be a path from s to m in G. Define (4 Q(m. P) =,~~in, [ IJEI; {c(P. P,, m’) + W’. PI) 1 , where c(P, P,. m ‘) indicates the cost of the path P, from m to m’ A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 55 let Q(n, P) = 0. If there are no defined by P. If n is a goal node solution paths passing through m let Q(m, P) = 00. Thus Q(m, P) is finite for every node m in G which lies on a solution path. By Q we mean Qb_>. @I Q(m) = max(Q(m, PIIT where the maximum is taken over all paths P from s to m in G. With the above redefinitions, Lemma 3 remains true with appropriate changes in notation. It can be restated as follows: Lemma 3. Let m be a node with immediate successors m, , m2, . . . , mk in GIf , and let P’ be a path in G,! from s to m. Then Ql<m, P’) =,?F>~ Mm, P’), min{c(P’, m, mi) + Q,!(m,, f”))l __ . lower bound on the arc costs. GREC Lemmas 4 and 6 remain the same as before. We impose, as in Section 2.1.1, a then terminates successfully, since non-zero the arc costs and the heuristic Lemma 9 and Theorem 10 remain valid. When the b-value of a node can decrease with time; this estimates are path dependent, cannot occur when the arc costs and heuristic estimates are constant. But b(s) can never decrease with time even in the path dependent case and must finally achieve the value Q. Thus GREC, even with path dependent arc costs, outputs optimal if heuristic estimates are admissible for every path P in the search graph. solutions 3. One-machine job sequencing problems 3.1. Problem description A one-machine minimum penalty form. Jobs Ji with processing job sequencing problem has the following to a times a, > 0, 1 s i s N, are submitted general job shop at time t = 0. The jobs are to be processed on the given one-machine machine one at a time. Let the processing of job Ji be completed ti. Penalty functions Gi(. ), 1.1 -= ’ s N, are supplied, such that the penalty associated with completing Gi(ti) = pit:, where the pi are given constants, being proportional be sequenced on the machine is the penalty associated with a job time of the job. The jobs must job Ji at time ti is Gi(ti). An example of a penalty in such a way that the total penalty to the square of the completion function at time is minimized. The penalty functions are non-decreasing Problems of this type have obvious relevance to be hard to solve. In a more general setting, jobs can also have setup times. The setup to industry, but are known and in general nonlinear. 56 A. K. Sm. A. Bugchi / Artificiul Intelligence 86 (1996) 4.3-73 terms, time processing the current is s,,,,. The processing machine sequence two otherwise, make methods the functions that setup preserving solutions. applicable, situation for a job is the time of the previous job can begin. setup sequence time job for is s,,. After need not be brought back independent taken ready and before to get the machine job has been completed If J, is the first job it job .I, when last the in the sequence, immediately in the sequence to any specific state. Setup then follows for processing after the processing its setup job is completed, the of time the the times are said to be as a sum of the other only on job J,; to approaches J, in tend (or separable or additive) if s,, can be expressed only on job 1, and times are sequence dependent. Existing one of which depends the setup the assumption that work when that setup in the absence times order preserving. setup remain times are sequence and an A*-based of setup are But dependent, graph Tree search procedures but tend to be inefficient times are sequence independent times can frequently [13]. Solution be extended to sequence if we make evaluation independent, the more functions search method fail such as the branch-and-bound because many duplicate can since evaluation assumption realistic become non-order- optimal to output method remain nodes get generated. 3.2. Classification of minimum penalty job sequencing problems One-machine the following (a) Setup minimum seven different times are non-existent penalty job sequencing problems can be classified into types: or sequence independent; evaluation functions in consequence are order-preserving: (i) Type A: Penalty functions are linear in job finish times. Problems of this type are simple. Ordering the jobs in non-decreasing order of a,/~,-values ing is necessary. gives a minimum penalty sequence [6]; no search- (ii) Type B: Penalty functions are quadratic in job finish times. Townsend [28] in his branch-and-bound function for the quadratic formulation proposed the use turned of a novel evaluation out to be quite subsequently schemes implemented uses Townsend’s modifications. achieved. employ selective. Bagga and Kalra improvements made some tree a far more search. Sen and Bagchi efficient A*-based penalty [2] and Gupta case that and Sen [7] in Townsend’s method. All these recently [22,24] have that suggested has also been using GREC scheme search graph evaluation function with Bagga and Kalra’s A similar implementation See Section 3.3. (iii) Type C: Penalty functions are general polynomials or more complex (such as exponentials) in job finish times. functions Both these be penalty tree and graph types. Unfortunately, Schild found. functions. search methods are applicable to problems good heuristic and Fredman [20] give estimate some functions examples are yet of general of to A.K. Sen, A. Bagchi I Artijicial Intelligence 86 (1996) 43-73 57 (b) Setup times are sequence dependent, evaluation functions in consequence are non-order-preserving: (i) Type D: P enalty functions are linear in job finish times. function, when formulated In this case the evaluation in the usual is non-order preserving. The problem can be solved in a natural the evaluation so that A* graph search remains [23]. An alternative way is to redefine to make it order preserving manner, way using GREC function applicable [15,24]. See Sections 3.4 and 4.1. (ii) Type E: Penalty functions are quadratic in job finish times. In this case, the penalty function being nonlinear, to modify possible make it order-preserving. GREC again solves the problem way [23]. See Sections 3.4 and 4.2. the non-order-preserving evaluation it does not appear and function in a natural (iii) Type F: P enalty functions are general polynomials in job finish times. The approach of Section 4.2 can be extended are polynomials be found, however. in job finish times. Good evaluation to penalty functions that functions are yet to (iv) Type G: Penalty functions are more complex functions (such as exponen- tials or non-integer powers) of the job finish times. to apply the method of Section 4.2, it may be necessary In order approximate for type F problems, no good heuristic estimate reported yet. to the penalty function with a finite polynomial. However, as functions have been 3.3. Tree search and graph search Suppose jobs have no setup the branch-and-bound times. Consider for the quadratic penalty (tree search) procedure of Townsend job sequencing prob- lem. A node in the tree corresponds to an ordered partial sequence of jobs. The node ni represents the ordered two-job sequence to the null sequence. All nodes are therefore to a partial sequence of k jobs gets expanded, N - k sons are generated, each son to the partial being obtained by appending one of the remaining N - k jobs sequence of k jobs. An edge signifies that one more job has been processed, and the cost of the edge is the penalty associated with that job. A problem is solved when a complete ordered the single job J,, while the node nij represents root node corresponds (JJj), distinct. When a node corresponding sequence of N jobs gets selected from OPEN. and so on. The In the corresponding graph formulation, nodes correspond of jobs; the root node is the empty set. When a node corresponding k jobs gets selected from OPEN and expanded, being a subset of k + 1 jobs. As before, associated with the corresponding set of N jobs gets selected corresponding k, and each node has k! incoming paths from the root. to unordered subsets to a subset of it generated N - k sons, each son is the penalty job. A problem gets solved when the complete is at level 0, and a node to a subset of k jobs is at level k. There are C(N, k) nodes at level In contrast, a tree has from OPEN. The root the cost of an edge at level k, and each node has only one at since incoming is one other point level k by a factor there to keep the expanded nodes. The I + N + C(N, 2) +. path. Thus k!. This to be all the nodes in tree of nodes . . + C(N, k) < of nodes at level k of the tree nodes, while total number in memory the number as a truer estimate of computing implementation of the reduction function the evaluation of A* or GREC. or depth-first to best-first [22]. Graph tree search could be ran only upto 16 jobs; beyond this For 16 jobs, graph search was more in search. Depth-first slower search could of nodes in is actually the number up to a given an overestimate. - k)! nodes is a reduction factor into account. N!/(N there reduction taken generated search we need not keep in kC(N, k) for k s N/2. which by a factor of (k - I)!. This may be viewed factor. The use of Townsend’s yields a fast and memory In graph search WC need including time track of the expanded k equals levels 0 through is less than the graph instant, at method efficient graph search How much better is graph compared out experimentally tree search than setup times faster search; best-first for example. are sequence the available memory was exhausted. tree 40 times be run for a large number search‘? This has been checked run upto 30 jobs, but best-first point than principle than graph When essentially the same, but the representation modified. Nodes can no longer correspond job pair, where ordered component is that the search graph has the form job processed the search graph the number 0 <k < N. Again, since graph evaluation the in the subset of nodes over a tree is non-order-preserving first component search must from among the jobs function job the that has been processed must be remembered. of jobs but was found it ran about for 20 jobs to be markedly 175 times slower. dependent. tree search method remains the of nodes just to subsets of jobs, because is the that has been processed job (S. J,), where .S is a subset of jobs and in S. Thus the number and subset, in graph search needs to be the last to an A node now corresponds second the last. So a node n in .I, is the last of nodes at a level k in in for (k - 2)!, the this case In is 1 for k = 1 or N, and kC(N. k) for 0 < k < N. The reduction is by a factor of (k - l)! and only about true representation factor store all generated reduction is smaller nodes in memory. below. as explained 3.4. Non-order-preserving wuluation functions to the set S. Let t, be the time at which are sequence times .Y to node n. The in the sequence processing by path P,. When setup t, always equals Let us suppose setup from .I, completes the root node in S are processed at which paths belong jobs time sequence be sequence dependent, paths are not the cost associated with P,. but on its time of completion, depends independent. t, may not equal determined identical. .I, completes dependent. jobs processed Let P, and P, be along two the two paths all the let r,’ be the the in to times are ignored or are assumed by path P,, and jobs processing when are processed the determined when It can happen t$‘, because times are sequence t:. But when setup two times of jobs along the setup the cost associated with P, is less than to a job from node the penalty the arc costs of the arcs emanating corresponding that the t, > t,‘. Since A. K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 59 Table 1 Job setuu and orocessine times Job Setup times 1 2 3 4 1 - 1 CC 00 2 1 _ m CC 3 1 3 - P 4 m 00 10 _ Processing times 1 4 3 10 it as well as the heuristic estimate at node n depend in general on the path by which yt is reached from the root, i.e., the arc costs and the heuristic estimate are [l]. It is possible for a complete sequence of N jobs that is an path dependent extension of the subsequence determined by P2 to have a lower total cost than a sequence of N jobs that is an extension of P,. But a graph implementation of A* would discard path P2 at node IZ because its cost is higher than that of P,, and job by P2 would not sequences In the linear penalty case it is subsequently possible to skirt this difficulty by reformulating in A*, but function the strategy does not work when the penalties are nonlinear, in which case an algorithm that are extensions of the sequence determined get considered by the algorithm. like GREC must be used. the evaluation Example 17. Consider a linear penalty problem with 4 job where the penalty coefficients are unity for all the jobs. Then the penalty for a job J, equals fi, where ti is the finish time of the job, and the total penalties the sum of the individual job penalties. Table 1 gives the setup times and the processing times. Setup time si,j is the entry in the ith row and jth column of the table. The initial setup times soj are to be zero. The cost of the arc (m, r) between node m = ({1,2,3}, 3) assumed 4) depends on the path by which we reach m and the goal node r = ({ 1,2,3,4}, from the root. If we process J, before J2 then the cost of the path P, from the root to m is 19, and c(m, r) = 32. If we process J2 before J, then the cost of the path P2 from the root to m is 20, and c(m, r) = 30. If at m we favor P, and discard P2, then we end up giving preference to the inferior of the two solution paths. The minimum penalty in this case happens to be (J2J1J3J4). job sequence 4. Running GREC with non-order-preserving evaluation functions 4.1. Linear penalties When penalties are linear but setup times are sequence dependent, function when defined in the normal way is non-order-preserving. evaluation possible Appendix B). GREC can solve the problem following more natural formulation which does not require any modification it order preserving by adjusting in the same way, but there the evaluation to make function the It is (see is the in 60 A. K. Sen, A. Bagchi i Artificial Intelligence X6 (19%) 4?- 73 function. When a node n = (S, J,) first enters the evaluation result of the expansion is saved in a parameter to n, and at a subsequent along another different which n is reached linear, path; t,. T is then from from b(n) can be expressed this time of its parent node, T associated with n. There are many paths can the EXPLORE the completion instant time procedure time of job J, is t,’ which the completion reset to t,‘. The value of b(n) depends it depends thus on T. When penalties the root, and as the explicit graph as a t, of n’s last job J, from the root reach n again is in general on the path by are b(n) = aT t /5 . where LY and /3 are parameters to node n. In fact, that depend on node H but not on the path taken if Q is the set of jobs remaining to be processed at IZ, (Y = c {pk 1 J, is in Q) . and p = b-value of node n taking node IZ as the root (or equivalently, taking T = 0) yielding together the search, the parameter yielding as more of T can be grouped time c, can be expressed as T + (tk - T); the (Y, and that for any job Jk in Q, the finish terms can be combined but p changes Note the coefficients remaining during When T changes in value by (t,! - t,)a which d oes not depend on p. Thus when a node II is reached time along based on path P; GREC At a later b(n) accordingly. (Y, and stores b(n), again along a different sets b(n) = h(n. P), which p. The value of (Y remains jobs and more constant in Q get sequenced. the amount for the first estimate (Y and T at the node. in instant, when n is reached path, and b(n) a path P, GREC t:. b(n) changes is the heuristic also computes the difference using LY and in T-values, is computed the change is modified in value from t, to penalty problem the job sequencing of Example estimates. that all nodes sequence have zero heuristic (Jz J, J3J4) with cost equal 17. Let us assume Example 18. Consider the outputs for simplicity any expanding minimum 1. When node more the root at the node m = ({ 1,2.3}, some is J, J2J3), the values T = 12. b(m) = 32 and (Y = 1 are stored at node m. When m is reached being again as (10 - 12). (Y = -2. JzJ, J3) with T = 10. the change GREC than once. The algorithm 3) has been the path P, (i.e.. when along path P2 (the job sequence at m is computed next explores m with b(m) = 30 and outputs as explained for the first the root at a subsequent from sequence operates reached the job processing to 30 without the optimal in Example in b-value solution GREC instant instant along path. from time 4.1.1. Experiments In the experiments, the heuristic estimate follows 1151. Let n = (S, J,) be a tip node jobs yet to be processed at n. For a job Jk in Q. take h(n) at a tip node n was computed as in the explicit graph. Let Q be the set of time sk to the effective setup A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 61 the effective job processing be min{sj,}, where the minimum is taken over all jobs Ji in Q’ = Q U {Ji}. Let us times. Order the jobs Jk in Q call the (sk + a,)-values the finish times t, of the in non-decreasing jobs, and let the heuristic estimate be C pktk, where is over all (see Appendix B for proof). Our jobs in Q. This yields a consistent heuristic experimental is quite selective. results in Table 2 and Fig. 4 show that the heuristic estimate order of (sk + a,)/p,-values, the summation compute time, and were generated integers and were chosen randomly the total number of nodes generated A* tree search, GREC and depth-first branch and bound (DFBB) were coded times of jobs in C and run on a UNIX-based DEC 5900 system. The processing were in the range 1 to 99 from a uniform distribution. Penalty coefficients and setup times were integers in the ranges 1 to 9 in the same way. The initial setup and 0 to 9 respectively, the times soj were assumed zero for simplicity. For a given number of jobs, execution and the total number of nodes expanded were averaged over 100 runs. Every effort was made to ensure that the implementations were as efficient as possible. The OPEN set of A* was maintained as a priority queue. In GREC, nodes were stored in a node table, and for every expanded node. A hashing scheme was successor in the used for checking whether a newly generated successor was already present explicit graph. As in DFBB, in non- time. Since job sequencing problems decreasing order of effective have well-defined depth bounds, like IDA* or its variants [ll] run even slower than depth-first search, so we do not report running times for IDA*. the successors of a node were generated lists were maintained iterative deepening job processing schemes The results of our experiments speedup ratios and node reduction of jobs. The ratios were computed with respect A) and DFBB (plots labelled B). We summarize our experimental below: are shown in Table 2. In Fig. 4, we plot the ratios of algorithm GREC against the number to A* tree search (plots labelled observations (i) The number of nodes generated and expanded both increased rapidly with the number of jobs for all the three algorithms. With 22 jobs, A* tree search Table 2 Linear penalty functions Number of jobs 12 14 16 18 20 22 24 26 GREC Time (sets) 0.02 0.06 0.14 0.35 0.87 2.55 6.65 18.46 A* (tree) Depth-first Nodes generated Nodes expanded Time (sets) Nodes generated Nodes expanded Time (sets) Nodes generated Nodes expanded 363 699 1471 2912 6082 12 172 21823 40 633 70 126 252 473 954 1901 3214 6027 0.04 0.12 0.44 1.44 4.59 793 2OOil 5617 1s 133 41 154 103 220 541 1272 3134 0.06 0.21 0.78 2.66 9.66 1297 3770 11427 31567 96911 223 537 1388 3237 8990 62 A. K. Sen. A. Bagchi I Artificial Intelligence 86 (1996) 43-73 Speedup and Node Reduction 17 16 15 14 13 12 II 10 9 8 7 6 5 4 3 2 1 12 14 16 18 20 0 Speedup + Nodqen(A) 0 v Nodeexp(A) A Speedup X Nodegen(B) Nodeexp(B) Number of Jobs Fig. 1. Linear penalty functions (ii) (iii) (iv) (v) (vi) instances. instances of larger size than A* tree ran short of memory, generating more than a million nodes in sometimes certain problem GREC was able to solve problem search. We include results on GREC upto 26 jobs. A variant of GREC was also implemented in which nodes of the explicit graph were stored but successor lists were not maintained. This variant ran slower than GREC because the time to generate successors and order them is high for job sequencing problems. A* graph search using plemented. in A* graph search were close to the corresponding to that of GREC. the running time was comparable DFBB low memory needs [30]. Thus DFBB can be used to solve problem of much larger size than GREC. We ran it upto 20 jobs to compare performance with GREC and A* tree search. For 20 jobs, GREC than A* tree search, and about 11 times faster than DFBB. The speedup ratios and node reduction ratios im- It was found that the numbers of nodes generated and expanded figures for GREC and instances of larger size because of its instances its rapidly with the number of jobs. The speedup is capable of solving problem ran around 5 times faster the modified evaluation function was also ratio was increased A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 63 smaller than the node generation expansion reduction the following factors: its level in the graph, overhead of the algorithm. reduction ratio but higher than the node ratio. This could be the result of the combined effect of the dependence of the branching factor of a node on and the the consistency of the heuristic estimate, (vii) DFBB needs very little memory and its overhead is low. But, even with in non-decreasing order of effective processing times, it it generated too many nodes. successors generated ran slowly because 4.2. Quadratic penalties function the evaluation With quadratic penalty functions and no setup times, the evaluation order-preserving. efficient A* graph implementation computing and its performance possible to generalize times. The GREC handle 4.1; some additional computations because is Existing graph search algorithms are directly applicable. An can be realized using Townsend’s method for function. The problem can also be solved using GREC, it does not appear setup to in Section are needed at each step as explained below on the other hand, can be readily extended is similar to that described is similar to that of A*. Unfortunately, the A* graph implementation this case. The method of solution to sequence dependent the penalty function implementation, is nonlinear. The b-value at a node IZ in the UPDATE procedure cannot be computed same way as in the linear case. The b-value at a node II now has the form in the where (Y, /3 and y are parameters the set of jobs remaining to be processed at it. We have that depend on node II but not on T. Let Q be o = c {pk 1 Jk is in Q) , P = 2 c {pktk 1 Jk is in Q> , and y = the b-value at node n with IZ viewed as the origin (i.e., with T taken as zero). the coefficients of T2 can be grouped a, the coefficients of T yield the parameter p, and the remaining As in the linear case, for any job Jk in Q, the finish time t, can be expressed as the T + (tk - T); terms parameter combine /I and y (Y, p and T must be stored at change as more and more jobs in Q get sequenced; and each node and reset in UPDATE. This increases explains why GREC linear penalties. to give y. The value of CY remains constant during the search, runs slower with quadratic the amount of computation than with penalties yielding together 64 A. K. Sen, A, Bagchi i Artificial Irttelligence 86 (1996) 43- 73 This method can be extended job finish times. For example, to penalty functions in the cubic case b(n) can be written as that are higher powers of the b(n) = CYT’ + /3T2 + yT + 6 , the parameters can be defined where Extension functions to penalty immediate. Since good heuristic were performed with such penalty functions. in a manner similar to that shown above. is that are polynomials functions are not yet known, no experiments in job finish times 4.2.1. Experiments At a tip node n, the effective processing as before and a heuristic estimate h(n) Townsend’s method. Townsend derived sufficient conditions jobs to be minimum cost. He showed that a sequence pair of adjacent both satisfied: time sL + uk for a job Jk in Q is found of is computed using a modification for a sequence of N is minimum cost if for every jobs (J,, J,) where J, precedes J,, the following two conditions are (i) p,la, apiia,; (ii) p, “P,. The two conditions might not be satisfied simultaneously by an adjacent pair of jobs. Hence a search method is needed. To determine a lower bound at a node IZ in the branch-and-bound the m jobs in Q as follows: search, order P,,&(i, ap,(Z)lar(Z, 2. . ~Picrnj~ait,,, The penalty F’ of the above subsequence of jobs is where and T=x {aA ) Jk is in S} the penalty F’ by (p, - pk)a,a,. The lower bound can be obtained by considering all pairs of jobs (Jk, J,) in the above ordered sequence where Jk precedes J, and pk < p, , and for every such pair, In the presence of setup times, effective reducing times. The resulting processing (see Appendix B for proof). The function heuristic experimental in this data indicated case than in the absence of setup times. times must be used in place of actual processing is consistent that the heuristic estimate was less selective estimate In the experiments, DEC 5900 system as before. Processing chosen randomly coefficients were integers the programs were written in C and run on a UNIX-based times of jobs were integers and were Penalty in the same in the ranges 1 to 9 and were generated in the range 1 to 99 from a uniform distribution. A.K. Sen, A. Bagchi / Artificial Intelligence 86 (1996) 43-73 65 Table 3 Quadratic oenaltv functions-Set I Number of jobs 12 14 16 18 20 GREC Time (sets) 0.09 0.28 0.83 3.25 13.25 A* (tree) Depth-first Nodes generated Nodes expanded Time (sets) Nodes generated Nodes expanded Time (sets) Nodes generated Nodes expanded 920 2287 5544 14 526 36646 232 539 1277 3322 8193 0.15 0.69 3.39 3685 12 961 50 776 488 1446 5003 0.20 0.90 4.15 5216 18 853 80 575 789 2342 8662 way. For both sets the initial setup times soj were assumed zero for simplicity. Two sets of setup times were considered: Set I consisted of setup times in the times in the range 1 to 5. The range 0 to 9, while Set II consisted of setup heuristic estimate for Set I was less selective and this increased the running time. GREC could be run for a larger number of jobs in a given time when Set II was time, the total number of nodes used. For a given number of jobs, the execution generated and the total number of nodes expanded were averaged over 100 runs. in In implementing depth-first search, the successors of a node were generated Speedup and Node reduction 16 15 - 14 - 13 - 12 - 11 - 10 - 9- S- 7- 6- 5- 4- 3- 2- 0 Speedup + Nodegen(A) 0 Nodeexp(A) A Speedup X Nodeeen(B) Number of jobs V Nodeexp(B) Fig. 5. Quadratic penalty functions: Set I. 66 A.K. Sen. A. Bagchi I Artificial Intelligence 86 (1996) 43-73 Table 4 Quadratic Number of jobs penalty functions--Set II GREC A” (tree) Depth-first Time Nodes Nodcs Time Nodea Nodes Time Nodes Nodes (sets) generated expanded (sets) generated expanded (sets) generated cxpandcd 12 14 16 IX 20 22 24 0.05 0.16 0.55 I .hO 4.Y2 30.64 Y I .09 649 1482 3420 7517 IX 158 40 5.55 x1 714 I63 34s XI)4 16X7 4052 Y7 I9 I7 65’) 0 I2 0 56 3.23 2YOh IO 344 47 120 388 116’) 4750 0.15 0.69 3.91 3937 1449’) 66 756 16 Y2 233 250 x5.03 979 937 s94 IX05 7214 ?I 6X9 82 548 non-decreasing job J,. order of u,/p: where p: refers to the effective processing time of Experimental results for Set I are shown could be run for a larger number Table 4 and Fig. 6. The results were similar GREC than A* tree search nodes million for 16 jobs. For 18 jobs, instances. in some Since in trend to those of jobs, and was about in Table 3 and Fig. 5, and for Set II in for the linear case. faster than one is not as sharp as in tree search generated more five times estimate the heuristic Speedup and Node reduction 12 14 I / 16 / 1 18 I I 20 ‘3 Speedup + Nodegen(A) 0 Nodeexp(A) A Speedup X Nodegen(B) Number of Jobs v Nodeexp(B) Fig. 6. Quadratic penalty functions: Set 11. A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 67 the linear case, running graphs in Figs. 5 and 6 showed an increase of speedup and node reduction with the number of jobs. DFBB ran about six times slower than GREC jobs; as before, DFBB GREC. times in Tables 3 and 4 are larger than in Table 2. The ratios for 16 is capable of solving problems of much larger size than 5. Conclusion in practice Although A* is capable of graph search and not just tree search, it has been generally used as a tree search procedure. It has been found recently that in some application areas such as one-machine job sequencing, graph search tree search for problems with A* can be much faster than best-first or depth-first of small and medium size. However, A* is not suitable for searching graphs when In such cases the graph search the evaluation that algorithm GREC can be used in place of A*. Experimental is in times are sequence dependent, when setup consequence GREC non-order-preserving, job sequencing problems penalty solves linear penalty and quadratic faster than tree search schemes. is non-order-preserving. and the evaluation results indicate function function The detection and elimination of duplicate nodes is a most pressing issue in tree for pruning duplicate search algorithms. Taylor and Korf 1271 suggest a technique in depth-first search. Their method requires a preprocessing of the search nodes the breadth-first graph by means of an exploratory sequence of operators to that are needed shortest and thus helps in detecting and eliminating duplicate nodes during the another, actual search phase. Preprocessing is needed only once for each type of problem, and the knowledge acquired can be used later during the depth-first search on the instances. The implicit assumption here is that the cost of an arc various problem of the problem between a pair of nodes is always the same and is independent like the 15puzzle, 24-puzzle and Rubik’s cube. instance. This is true for problems But for to apply such techniques effectively since arc costs are not the same for different problem search. This determines to move job sequencing problems, it is not possible from one node instances. Very recently, Reinefeld and Marsland [17] have reported some enhancements than IDA* on both search. They have shown that search efficiency can be of iterative deepening greatly improved by storing, in a table in memory, nodes which have already been in the course of the search. Their search algorithm TRANS appears encountered to perform much better and the solution method suggested by Pearl [14] for the travelling salesman graph-based is conceptually very close to GREC, as the pseudo-code given problem. TRANS in [17, Fig. 7, p. 7091 shows. The hash table used in TRANS to store generated nodes is similar to the table used in GREC. However in TRANS, when the hash full, existing entries can be overwritten by more promising new table becomes is that TRANS only entries. Another difference the two algorithms lists. This can be an stores the nodes of the explicit graph but not the successor is in- advantage like the Wpuzzle where node generation the 15puzzle in problems problem between time But significant. generate nodes: can be achieved problems the node numbers generation useful purpose. it is enough and at the the number time in job sequencing, where it is a disadvantage since if successor like the rectangular lists are maintained the same node can be explored many in memory. [21.29], since nodes can be repeatedly stock problem cutting of successors time it takes times, higher Even it is helpful explored and hashing to speeds in tree search to know and node serves no is high; In fact, in such cases every node in this case a separate is distinct to store with each expanded node of sons. since the sons can be assigned array for successors the node number successive is not needed; of the first son node numbers time of generation. In ending, we point out that GREC has one serious explicit graph in memory it cannot this difficulty? At this time we do not know scheme solve Since limitation. large problems. it stores Is there any In job the so the same if the available memory M is the answer. is inadvisable; depth schemes. bound, For deepening is a well-defined deepening the use of an iterative there known. than iterative formulated is unsuitable jobs being runs faster as currently SMA* run memory will [18] and MA” the into constraint [S] arc based on A” and as A” graph that maintains same difficulties algorithm their graph search. An the entire appears in memory graph the memory management problems can successor technique modified sequencing to be the need of the hour. features efficiently of MREC without so that storing it becomes the entire lists be incorporated in TRANS so that it runs efficiently on sequencing capable explicit the and Is it possible to number problems. of search the entire way to get around sequencing total depth-first reason, MREC small. Algorithms implementations efficient explicit improve of solving graph? Alternatively, memory management problems graph-based of larger size? Appendix A. Properties of GREC: proofs of claims in Section 2.1 Lemma 6. Let j he any irzstunt during the execution of GREC. Then (i) b,(m) G Q,‘(m) (ii) h,G&:<Q. fur uny node m in G,‘: For a non-tip at which node, we prove the lemma the fails. The j. This is so takes place at instant does not take place at instant instant if m is a non-tip then m is a non-tip (i) is true by definition. Let ,j be the earliest Proof. For a tip node, result by contradiction. lemma must fail at a node at which recalculation because j, Q;_,(m); we know by Lemma Q;(m). at which the moment immediate In the course of recalculation fails. Let n,. n,, the lemma the recalculation node at which recalculation node successors. Some of at instant at instant these j - 1 and by assumption 4 that Q;_,(m) 9 Q,‘(m), . . rzk be the immediate j, let n be the first node successors and h, ,(m) S so b,(m) = b,_,(m) S (in time) of n. At for each of its their b-values takes place at H, the lemma holds successors will have had A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 69 updated already this instant, some others will not change their b-values at all, and in case n lies in a loop, there may be an immediate successor of IZ whose b-value is done at II, for will be updated l<ick IZ. However, when the recalculation after > b(ni) = h(n,) = Qi(nl) if II, is a tip node and b(n;) c Ql(ni) if n, is a non-tip node so that bj(n) “,y%“, {b,-,(n), mink@, n,) + b(q)]) . . < Q,! (n) by Lemmas 3 and 4 . This is a contradiction. function is admissible the b-value at m can never When the heuristic estimate since it can never be set to a value exceeding exceed Q(m) even at termination, Q(m) from above. If the heuristic is inadmissible, there might then at termination be a node m on the output path, where m is not the root, whose b-value is greater than Q(m) because it has been set to a large value from above. If GREC does not terminate, the b-value as well as the Q’-value at m would get revised upwards from below and at the next instant j we would again have bj(m) s Q,! (m). The is b-value the heuristic admissible or inadmissible, b, s Q,! at every the execution of GREC; a similar inequality would also hold at termination. at the root cannot be set from above, so whether instant j during 0 Lemma 9. Let j be any positive integer, Zf GREC has not terminated by instant j then at some instant j’ 2 j prior to termination, G,!. is consistent. the lemma Proof. Suppose is still is false. Then at every running and the explicit graph G,!, is not consistent. Since no tip node gets explored, no nodes get expanded and G,!. remains unchanged, but b-values of non-tip nodes which do get explored increase by at least 7. Thus at every instant j’ > j, bj8 increases by at least T. Since G,!, remains the same, Q,!, = Q,! for every instant j’ > j. So, as Q,! is finite, a time must come when b,, > Ql,, which contradicts Lemma 6. instant j’ > j, GREC (cid:144)i Theorem 10. Algorithm GREC and outputs a solution path. terminates successfully, i.e., it finds a goal node Proof. By Lemma 9, GREC cannot go on running indefinitely without expanding a tip node. If j and j’ are two instants at which tip nodes get expanded, then the psps at these two instants must be distinct. If the search graph is finite and loop 70 A.K. Sen, A. Bagchi i Arrificial Intelligence 86 (19Y6) 43-73 free then GREC obviously terminates. If not, we recall that the cost of an arc is at least T > 0, a node has finitely many immediate successors, and b(s) cannot exceed Q; it follows that GREC must terminate in this case too. 0 Definition 11. Let b,;,,c be the h-value at the root s when GREC terminates. Theorem 12. (i) b,,,c (ii) b GRE(. = b* if the heuristic estimate function = Q. is admissible. (i) By Lemma 6(ii). b,;,,,. s Q. But since a solution path is found at Proof. termination, b,,,,. 2 Q. (ii) If the heuristic is admissible, (2 = b”‘. 0 Theorem 14. All nodes expanded by GREC belong to the set V. Proof. Immediate by Lemma 6(ii). n Appendix B B. 1. Linear penalties: making the evaluation function order-preserving Let node m = (S, Ji) be an immediate predecessor of node n = (S U {Jk}, Jk) in the explicit graph. Then, in the standard A* formulation, known best path from the root to it is the cost of the currently g(n) = min{g(m) +PI,(T +Ly,a +ak)) where T is the completion time of m’s last job 1, as determined by the currently known best path to m, and the minimum is taken over all immediate predecessors m of n in the explicit graph. This cost function since the arc cost c(m, n) = pk(T + s,~ + ak) depends on the path by which m is reached in the following way. Let P be a solution from the root. We get over the problem , JN along P. Then the cost path, and let jobs be sequenced of P is is non-order-preserving, in the order J, , Jz, . p,a, +p2(a, +s,? +~,)+...+p,~(a, +s,? -t . ..+a.) = a,(p, +pz + . . . +P,v) + (s,z +a,)(P2 + “. +PN) + . . + (s,* , .N + a,v)ph. Taking a cue from this expression, we define new g-values which we call deferral g-values as follows: g,(n)=min{g,(m)+(s,,+~~)C~,). where the minimum is again taken over all predecessors m of n, and the A.K. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 71 and the evaluation is over all jobs remaining summation longer path dependent based graph search can still be employed now estimates processed; into account the contribution the total contribution in the expression function to be processed at II. The g,-values are no so A*- [15,24]. The heuristic estimate at a node to be taken to the total penalty of the jobs remaining of the jobs already processed has been is order-preserving, for the g,-value. B.2. Linear penalties: consistency of the heuristic estimate h(. ) is consistent; We show that the heuristic estimate h(n, P) in the linear penalty case (Section the heuristic the path P is shown as a parameter 4.1.1) estimate depends on the finish time of the last job at node n. Let node m be a parent of node n. We have to show that since h(m, P) s c(P, m, n) + h(n, P) where c(P, m, n) is the cost of the arc between m and n along path P; c(P, m, n) depends on the actual time taken to process the last job Ji at node it and also on to be processed at node m all belong to the path from s to IZ. The jobs remaining time of J at m Q U {Ji}. Let J be such a job, J # Ji. Then the effective processing is no larger time c(P, m, n) is not smaller than its effective taken processing time at node m. Thus the left-hand side of the above expression can be than the right-hand side. no larger to process Ji, which determines than its effective processing time at II. Moreover, the actual B.3. Quadratic penalties: consistency of the heuristic estimate h( * ) The method of computation in Section 4.2.1. The method ensures is admissible. We argue that it is also consistent. Let node n be a son of node m, and let P be a path from s to m. We want to show that of the heuristic estimate that the heuristic estimate function is described h(m, P) s c(P, m, n) + h(n, P) . to be processed are sequenced Let the edge (m, n) correspond jobs remaining values. Job J occurs somewhere the penalty this sequence for sponding right-hand to job J. When the heuristic is computed at m, the order of ailpi in non-decreasing in this sequence. To derive the heuristic h(m, P), terms corre- and then correction is computed, to certain pairs of jobs are deducted. Thus we can say that the left- and sides in the above inequality differ in the following respects: (i) In the right-hand side, J occurs as the first job, while in the left-hand side it is not necessarily the first job. (ii) In the right-hand side, correction from the penalty for any job pair of which J is a member, but such corrections have been made in the left-hand side. terms have not been deducted Consider an optimal path P from m to a goal. If J is the first job along P, then for the heuristic the above inequality must hold, since the computation procedure 72 A.K. Sen, A. Bagchi i Artificial Intelligence 86 (1996) 43-73 ensures that the contribution of J to h(m, P) is only a lower bound on the final contribution of J to the total penalty. If J is not the first job along P, then forcing J to the front and not making any corrections for J can only increase the value of the right-hand side. References [l] A. Bagchi study. and A. Mahanti, J. ACM 30 (1983) Search algorithms under different kinds of heuristics: a comparative l-21. [2] P.C. Bagga and K.R. Kalra. A node elimination function single machine quadratic penalty the 633-636. procedure scheduling for Townsend’s for solving problem, Manage. Sci. 26 (1980) algorithm [3] C.E. Bell and K. Park. Solving resource-constrained project scheduling problems by A* search, Nav. Res. Logist. 37, (1990) 61-84. [4] L. Bianco, S. Ricciardelli, G. Rinaldi and A. Sassano, Scheduling tasks with sequence dependent processing times, Nav. Res. Logist. 35 (1988) 177-184. [S] P.P. Chakrabarti, memory, Artif S. Chose, A. Acharya and S.C. De Sarkar, Heuristic search in restricted Intel/. 41 (1989) 197-221. [6] S. French, Sequencing and Scheduling: An Introduction to the Mathematics of the Job-Shop (Ellis Chichester, 1982). Horwood, [7] S.K. Gupta function 644-647. and T. Sen, On times: of completion the single machine improved an branching scheduling problem with quadratic penalty procedure, Manage. Sci. 30 (1984) 18) P.E. Hart. N.J. Nilsson minimum-cost paths. and B. Raphael, A formal IEEE Trans. Syst. Sci. Cybern. 4 (2) (1968) 100-107. the heuristic basis for determination of [9] H. Kaindl and A. Khorsand, Memory-bounded bidirectional search, in: Proceedings AAAI-94, Seattle, WA (1994) 1359-1364. iterative [lo] R.E. Korf. Depth-first 97-109. deepening: an optimal admissible search, Artif. Intell. 27 (1985) [ll] R.E. Korf, Linear-space best-first search: summary of results, in: Proceedings AAAI-92, San Jose, CA (1992). [12] J.D.C. Little, K.G. Murty, D.W. Sweeny and G. Karel. An algorithm for the travelling salesman problem, Oper. Res. 11 (1963) 972-989. [13] A.J. Mason and E.J. Anderson, Minimizing How time on a single machine with job classes and setup times, Nav. Res. Logist. 38 (1991) 333-350. [ 141 J. Pearl, Heuristics: Intelligent Search Strategies for Computer Problem Solving (Addison-Wesley, Reading, MA, 1984). [15] R. Ramaswamy and A.K. path-dependent [16] C.R. Reeves, Publications, [ 171 A. Reinefeld arc costs, Sen. Single machine scheduling in: Proceedings ECAI-92, Vienna as a graph (1992) 11-15. search problem with ed.. Modern Heuristic Techniques for Combinatorial Problems (Blackwell Oxford. and T. Marsland, iterative-deepening Enhanced search, 1993). IEEE Trans. Pattern Anal. Scientific Mach. Intell. 16 (1994) 701-709. [ 181 S. Russell, Efficient memory-bounded 1-5. search methods, in: Proceedings ECAI-92, Vienna (1992) [19] S. Sahni and T. Gonzalez, [20] A. Schild I.J. Fredman. Manage. Sci. 9 (1963) 73-81. and p-complete approximation problems, tasks with deadlines J. ACM 23 (1976) 555-565. and non-linear functions, loss Scheduling [21] A.K. Sen and A. Bagchi, Fast in: Proceedings use of memory, recursive IJCAI-89, Detroit. MI (1989) 297-302. for best-first formulations search that allow controlled AK. Sen, A. Bagchi I Artificial Intelligence 86 (1996) 43-73 13 [22] A.K. Sen and A. Bagchi, Job sequencing with quadratic penalties: an A*-based graph search IEEE Conference on Artificial Intelligence for Applications, Orlando, in: Proceedings approach, FL (1993) 190-196. [23] A.K. Sen and A. Bagchi, Non-order-preserving evaluation methods for job sequencing problems, in: Proceedings functions: recursive graph-search IJCAI-93, Chambery (1993) 1423-1429. to job [24] A.K. Sen, A. Bagchi and R. Ramaswamy, Searching graphs with A’: applications IEEE Trans. Syst., Man Cybern. Part A Syst. Humans 26 (1996) 168-173. sequencing, [25] A.K. Sen, A. Bagchi and B.K. Sinha, Admissible for minimum penalty sequencing of jobs with setup times on one and two machines, in: Proceedings ZJCAZ-91, Sydney, NSW (1991) 178-183. search methods [26] E. Taillard, Some efficient heuristic methods for the flow shop sequencing problem, Eur. J. Oper. Res. 47 (1990) 65-74. (271 A. Taylor and R.E. Korf, Pruning duplicate nodes in depth-first search, in: Proceedings AAAI-93, Washington DC (1993). [28] W. Townsend, The single machine problem with quadratic penalty function of completion times: a branch and bound solution, Manage. Sci. 24 (1978) 530-534. and A. Bagchi, Best-first search methods [29] K.V. Viswanathan cutting stock problems, Oper. Res. 41 (1993) 768-776. for constrained two-dimensional [30] W. Zhang and R.E. Korf, Depth-first vs. best-first search: new results, in: Proceedings AAAI-93, Washington DC (1993). 