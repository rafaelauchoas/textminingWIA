Artificial Intelligence 250 (2017) 58–79Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintA progression semantics for first-order logic programsYi Zhou a,b,∗a School of Computing, Engineering and Mathematics, Western Sydney University, Sydney, Australiab School of Computer Science and Technology, TianJin University, TianJin, Chinac School of Computer Science and Technology, Huazhong University of Science and Technology, Wuhan, China, Yan Zhang a,ca r t i c l e i n f oa b s t r a c tArticle history:Received 21 August 2015Received in revised form 19 May 2017Accepted 6 June 2017Available online 9 June 2017Keywords:Logic programmingStable modelProgressionFirst-order1. IntroductionIn this paper, we propose a progression semantics for first-order normal logic programs, and show that it is equivalent to the well-known stable model (answer set) semantics. The progressional definition sheds new insights into Answer Set Programming (ASP), for instance, its relationships to Datalog, First-Order Logic (FOL) and Satisfiability Modulo Theories (SMT). As an example, we extend the notion of boundedness in Datalog for ASP, and show that it coincides with the notions of recursion-freeness and loop-freeness under program equivalence. In addition, we prove that boundedness precisely captures first-order definability for normal logic programs on arbitrary structures. Finally, we show that the progressional definition suggests an alternative translation from ASP to SMT, which yields a new way of implementing first-order ASP.© 2017 Elsevier B.V. All rights reserved.Answer Set Programming (ASP) has emerged as a predominant approach for nonmonotonic reasoning in the area of knowledge representation and reasoning due to its simplicity, expressive power and computational advantage [6,20,33,34]. At its beginning, the stable model (answer set) semantics for first-order logic programs is defined only on Herbrand Struc-tures by grounding into propositional programs [21,22]. In recent years, a number of approaches have been developed to release this restriction by directly defining the stable model semantics on arbitrary structures [4,5,7,10,15,18,24,26,28,31,36,38,40,42].A typical approach on this research line is to use a translation to another host language, e.g. second-order language [18] or circumscription [31]. For this purpose, second-order is inevitable as the class of the stable models of some logic programs, e.g. transitive closure, cannot be captured in first-order logic [16]. Under this backdrop, a first-order logic pro-gram (cid:2) is transformed to a corresponding second-order sentence S M((cid:2)), and the stable models of (cid:2) are defined as the models of S M((cid:2)) [18]. While this definition provides a precise mathematical representation and also generalizes the tradi-tional propositional ASP, it, however, does not reveal much information about the expressiveness of first-order answer set programming. For instance, it is unclear whether we can provide a complete characterization of first-order definability for first-order ASP.In this paper, we propose a progressional definition for first-order normal logic programs. Intuitively, this definition may be viewed as a generalization of the Gelfond–Lifschitz transformation [6] to the first-order case as well as a generalization of the progression semantics for Datalog [1,32]. Also, it shares some fundamental ideas with Reiter’s semantics for default * Corresponding author.E-mail address: yzhou@scm.uws.edu.au (Y. Zhou).http://dx.doi.org/10.1016/j.artint.2017.06.0010004-3702/© 2017 Elsevier B.V. All rights reserved.Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7959logic [37]. Simply enough, in the progressional definition, a first-order structure M is a stable model of a first-order normal logic program (cid:2) if and only if it is the fixed point of the progression of (cid:2) with respect to M. More precisely, M coincides with the structure obtained by recursively applying the rules in (cid:2), where the negative parts are fixed by M itself. We show that, for normal logic programs, this progressional definition is equivalent to the general stable model semantics defined by S M((cid:2)).The progressional definition sheds new insights into Answer Set Programming (ASP), for instance, its relationships to Datalog, First-Order Logic (FOL) and Satisfiability Modulo Theories (SMT). It can be further evident from the progressional definition that Datalog is exactly the monotonic counterpart of ASP, and many important Datalog techniques can be ap-plied to ASP as well. Based on the proposed progressional definition, we are able to define the notion of boundedness for first-order answer set programs, which is critical for understanding the relationship between first-order ASP and classical first-order logic.With the features of iterative and nonmonotonic reasoning, ASP is a representative rule-based formalism that is signifi-cantly different from classical logics. Nevertheless, ASP and classical logics are very closely related. Hence, the relationships between them have attracted a lot of attention in the literature [4,5,12–14,17,25,26,39]. Among them, a central topic is first-order definability, that is, what kind of answer set programs can be captured in classical first-order logic in the sense that their answer sets/stable models are exactly the classical models of a first-order sentence. Our notion of boundedness provides a complete answer for this. We prove that an answer set program is first-order definable if and only if it is bounded. Moreover, the notion of boundedness/first-order definability is also equivalent to two important syntactic notions of recursion-freeness and loop-freeness (tightness) under program equivalence. We believe that results in this aspect will establish a foundation for the further study of the expressiveness and related properties of first-order ASP.The progressional definition is not only of theoretical interest but also of practical relevance as it directly yields a new translation from first-order ASP to Satisfiability Modulo Theories (SMT). Comparing this translation to the one obtained from ordered completion [4,5], it is logically stronger as it has less models.This paper is organized as follows. Section 2 introduces necessary backgrounds. Section 3 proposes the progressional definition and shows that it is equivalent to the translational definition. Then, Section 4 extends the notion of boundedness in Datalog for ASP and shows that it is equivalent to the notions of recursion-freeness and loop-freeness under program equivalence. Section 5 further shows that boundedness exactly captures first-order definability of ASP. Section 6 reports a natural translation from first-order ASP to SMT based on the progressional definition. Finally, Section 7 discusses some related and ongoing works and Section 8 concludes the paper respectively.2. PreliminariesAiWe start with necessary logical notions and notations. We consider a second-order language without function symbols but with equality. A vocabulary τ is a set that consists of relation symbols (or predicates) including the equality symbol = and constant symbols (or constants). Each predicate is associated with a natural number, called its arity. Given a vocabulary, term, atom, substitution, (first-order and second-order) formula and (first-order and second-order) sentence are defined as usual. In particular, an atom is called an equality atom if it has the form t1 = t2, where t1 and t2 are terms. Otherwise, it is called a proper atom.A structure A of vocabulary τ (or a τ -structure) is a tuple A = ( A, ccalled the domain of A, cover A for every k-ary predicate P j in τ . Pa finite set. In this paper, we consider both finite and infinite structures.AA1 , · · · , Pn ), where A is a nonempty set A(1 ≤ j ≤ n) is a k-ary relation(1 ≤ i ≤ m) is an element in A for every constant ci in τ , and Pjis also called the interpretation of P j in A. A structure is finite if its domain is A1 , · · · , cAm , P−→x ) be an atom, η an assignment in structure A. For convenience, we also write P (Let A be a structure of τ . An assignment in A is a function η from the set of variables to A. An assignment can be , where c is an arbitrary constant. −→x )η ∈ A for the fact that . The satisfaction relation |= between a structure A and a formula φ associated with an assignment η, denoted −→x be the set of free variables occurring in a formula φ. Then, the satisfaction relation −→a ) for convenience, −→a is a tuple of elements in A. In particular, if φ is a sentence, then the satisfaction relation is independent of the −→a ), where P is a predicate −→a ), to denote extended to a corresponding function from the set of terms to A by mapping η(c) to cLet P (−→x ) ∈ Pη(by A |= φ[η], is defined as usual. Let is independent from the assignment of variables not in where assignment. In this case, we simply write A |= φ for short. A ground atom in A is of the form P (−→and a a tuple of elements that matches the arity of P . For convenience, we also use P (−→a ∈ P−→x . In this case, we also write A |= φ(−→a ) ∈ A, or A |= P (−→x /AjAAA.Given a structure A of τ , Q a predicate in τ and some ground atoms Q (−→an }.−→a1 , . . . , to denote a new structure of τ which is obtained from A by expanding the interpretation of predicate Q in A (i.e. QQA ∪ {Let A1 and A2 be two structures of τ sharing the same domain, and for each constant c in τ , cA2 . By A1 ⊆ A2, A2 . By A1 ⊂ A2, we mean that A1 ⊆ A2 but not A2 ⊆ A1. We we simply mean that for each predicate P ∈ τ , Pwrite A1 ∪ A2 to denote the structure of τ where the domain of A1 ∪ A2 is the same as A1 and A2’s domain, each constant c is interpreted in the same way as in A1 and A2, and for each predicate P in τ , PA1∪A2 = PA1 ⊆ PA1 ∪ PA1 = cA2 .−→a1 ) ,. . . , Q (−→a n), we use A ∪{Q (−→−→an )}a1 ), . . . , Q (A) to 60Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–792.1. First-order normal logic programA rule r is of the following form:α ← β1, . . . , βm, not γ1, . . . , not γl,(1)where α is a proper atom, βi (0 ≤ i ≤ m), and γ j (0 ≤ j ≤ l) are atoms. We say that α is the head of r, denoted by Head(r); {β1, . . . , βm} the positive body of r, denoted by P os(r); and {not γ1, . . . , not γl} the negative body of r, denoted by Neg(r). In addition, we use Body(r) to denote P os(r) ∪ Neg(r).A normal logic program (program for short) is a finite set of rules. Given a program (cid:2), predicates that occur in the heads of some rules in (cid:2) are said to be intensional; all other predicates are said to be extensional.1 For a given program (cid:2), we use τ ((cid:2)) to denote the vocabulary of (cid:2); τext((cid:2)) to denote all the extensional predicates in (cid:2) together with all the constants in (cid:2); τint((cid:2)) to denote all the intensional predicates of (cid:2). Clearly, τ ((cid:2)) = τext((cid:2)) ∪ τint((cid:2)). In addition, τint ((cid:2)) contains no constant. We also use (cid:9)(cid:2) to denote the set of all intensional predicates of (cid:2). Although (cid:9)(cid:2) is the same as τint((cid:2)), we use two notations to make a difference because the former denotes a set of predicates whilst the latter presents a vocabulary.Let M be a structure, r a rule of the form (1) and η an assignment. We say that M satisfies the positive body of r−→t )η; M satisfies the negative under η, namely P os(r), written M |= P os(r)η, if for all atoms P (−→t )η; M satisfies body of r under η, namely Neg(r), written M |= Neg(r)η, if for all atoms not P (the body of r under η, namely Body(r), written M |= Body(r)η if M |= P os(r)η and M |= Neg(r)η; and finally, M satisfies the rule r under η, written M |= rη if M |= Head(r)η whenever M |= Body(r)η.−→t ) ∈ Neg(r), M (cid:10)|= P (−→t ) ∈ P os(r), M |= P (2.2. The translational stable model definitionLet (cid:2) be a program and (cid:9)(cid:2) the set of intensional predicates in (cid:2). We introduce (cid:9)∗(cid:2)} to be a new set of (cid:2) has the same arity as predicate Q i in (cid:9)(cid:2). Let r be a rule in (cid:2) of = {Q∗1 , . . . , Q∗n∗iin (cid:9)∗predicates corresponding to (cid:9)(cid:2), where each Qthe formα ← β1, . . . , βm, not γ1, . . . , not γl,by (cid:2)r, we denote the universal closure of the following formula(cid:2)Body(r) → α,where (cid:2)Body(r) is the conjunction of all elements in Body(r) by replacing each occurrence of not with ¬, i.e.∗By r(cid:2)Body(r) = β1 ∧ · · · ∧ βm ∧ ¬γ1 ∧ · · · ∧ ¬γl., we denote the universal closure of the following formula∧ ¬γ1 ∧ · · · ∧ ¬γl → α∗−→x ) and∗∧ · · · ∧ βm−→x ) if α = Q (∗1where α∗ = Q∗(β,β∗i , (1 ≤ i ≤ m) =(cid:3)Qβi∗j (−→t j ) if βi = Q j(otherwise.−→t j ) and Q j ∈ (cid:9)(cid:2)By (cid:2)(cid:2), we denote the first-order sentence logic program. By S M((cid:2)), we denote the following second-order sentence:ˆr; by (cid:2)∗r∈(cid:2), we denote the first-order sentence (cid:4)(cid:4)r∈(cid:2) r∗. Let (cid:2) be a normal (cid:2)(cid:2) ∧ ¬∃(cid:9)∗∗∗(cid:2) < (cid:9)(cid:2)) ∧ (cid:2)(cid:2)(((cid:9)where (cid:9)∗(cid:2) < (cid:9)(cid:2) is the abbreviation of the formula(cid:5)−→x (Q i(−→x ) → Q i(−→x )) ∧ ¬−→x (Q(cid:5)),∀∀∗i (−→x ) → Q−→x )).∗i (1≤i≤n1≤i≤nDefinition 1 (Translational stable model). Let (cid:2) be a program and A a τ ((cid:2))-structure. We say that A is a stable model (an answer set) of (cid:2) if A is a model of S M((cid:2)).1 Here, we follow the notions used in Datalog to distinguish between intensional and extensional predicates. According to the definition, predicates defined by sets of facts in the program are also considered to be intensional.Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7961We refer this definition to the translational definition. For convenience, we use A S((cid:2)) to denote the collection of all stable models of (cid:2). Two programs are said to be equivalent if they have the same set of stable models.This definition is originated from Lin and Shoham’s work to translate normal logic programs under the answer set/stable model semantics into circumscription – a second order sentence [29]. Later on, a number of approaches have been proposed to generalize this work for translating richer forms of logic programs into fragments of second-order logic [8,18,28,31,36,42]. Restricted to normal logic programs, these translations are essentially equivalent.2.3. Clark’s completion and ordered completionAnswer Set Programming is a rule-based formalism for dealing with iterative reasoning (recursion) and nonmonotonic reasoning, which is significantly different from the classical first-order logic. However, these two types of formalisms are closely related. The relationships between answer set programming and classical logics have been one of the central topics in this area since its origin, and have attracted much attention in the literature [4,5,12–14,17,25,26,39].Among them, one influential work is the completion approaches [14], which intend to use first-order sentences directly to capture the stable model (answer set) semantics of logic programs.Definition 2 (Clark’s completion). Let (cid:2) be a program. Clark’s Completion (completion for short if clear from the context) of (cid:2), denoted by Comp((cid:2)), is the following first-order sentence:(cid:5)−→x (P (−→x ) ↔∀P ∈τint ((cid:2))where(cid:6)1≤i≤k−→yi∃(cid:2)Bodyi),(2)−→x ) ← Body1, . . . , P (is the tuple of body variables in P (• P (−→•yi• (cid:2)Bodyi is the conjunction of elements in Bodyi by simultaneously replacing the occurrences of not by ¬.−→x ) ← Bodyk are all the rules whose heads mention the predicate P ;−→x ) ← Bodyi ;It was shown that any stable model of a program (cid:2) must be a classical model of its completion, i.e. Comp((cid:2)). However, the converse does not hold in general. In this sense, Clark’s completion fails to capture the stable model semantics.The gap has been bridged recently. The loop formula approach [12,26,30] showed that, together with so-called loop formulas, Clark’s completion can exactly capture the stable model semantics. That is, a finite structure is a stable model of a program if and only if it is a classical model of the program’s Clark’s completion and all its loop formulas. Nevertheless, in the first-order case, there could be infinite number of loop formulas. In contrast, the ordered completion approach [4,5]introduces some extra comparison predicates to keep track of the derivation order so that the stable models can exactly be captured by ordered completion – a modified version of Clark’s completion.Definition 3 (Ordered completion). Let (cid:2) be a program. Ordered completion of (cid:2), denoted by O C((cid:2)), is the set of following sentences:• For each intensional predicate P , the following sentences:(cid:6)−→x (∀−→yi∃(cid:2)Bodyi → P (−→x )),1≤i≤k−→x ) →−→x (P (∀(cid:6)−→yi ((cid:2)Bodyi ∧∃(cid:5)1≤i≤k≤Q P (−→z )∈P osi ,Q ∈(cid:9)(cid:2)Q (−→z ,−→x ) ∧ ¬ ≤P Q (−→x ,−→z ))),(3)(4)where– some basic notations are borrowed from Definition 2;– P o si is the positive part of Bodyi so that Q (– ≤Q P (≤P Q ) is a new predicate, and ≤Q P (equal than the one of P (−→x );−→z ) ranges over all the intensional atoms in the positive part of Bodyi ;−→z , −→x ) intuitively means that the evaluation time of Q (−→z ) is less or • for each triple of intensional predicates P , Q , and R (two or all of them might be the same) the following sentence:(cid:5)−→∀xP ,Q ,R∈(cid:9)(cid:2)−→y−→z (≤P Q (−→x ,−→y )∧ ≤Q R (−→y ,−→z ) →≤P R (−→x ,−→z )).(5)62Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79The following theorem states that the stable models of a normal program correspond to the classical models of its ordered completion on finite structures.Proposition 1 (Theorem 1, [4]). Let (cid:2) be a program. Then, a finite τ ((cid:2))-structure is a stable model of (cid:2) if and only if it can be expanded to a model of O C((cid:2)).One can further eliminate the transitive formulas (i.e., formula (5)) by using Satisfiability Modulo Theories (SMT), more precisely, first-order logic augmented with a background theory about the comparison operator < of integers. For every predicate P , we introduce an integer predicate n P with the same arity. Then, the SMT version of ordered completion, (cid:15)((cid:2)), is the conjunction of formula (3) and formula (4), where the second the line of formula (4), i.e.,written O C(cid:5)≤Q P (−→z )∈P osi,Q ∈(cid:9)(cid:2)Q (−→z ,−→x ) ∧ ¬ ≤P Q (−→x ,−→z )is replaced by(cid:5)−→z ) < n P (−→x ).n Q (−→z )∈P osi,Q ∈(cid:9)((cid:2))Q (In the SMT version of ordered completion, there is no need for formula (5) as it is implied by the nature of the built-in comparison operator <.2.4. The progression semantics for DatalogA program is called a Datalog program if every predicate occurred in the negative part of some rule in the program is extensional. That is, the negative parts of rules in the program mention no intensional predicate, thus their values are fixed.The semantics for Datalog programs is usually defined in a progressional style as follows.Definition 4 (Datalog evaluation stage). Let (cid:2) be a Datalog program and D a structure of τext((cid:2)) (called the extensional database). Let (cid:9)(cid:2) = {Q 1, . . . , Q n} be the set of all intensional predicates of (cid:2). The t-th simultaneous evaluation stage of (cid:2), denoted as {Q t}, is defined inductively as follows:1, . . . , Q tn• for any i, 1 ≤ i ≤ n, Q 0i• for any i, 1 ≤ i ≤ n, Q k+1= ∅;i= Q ki|= (cid:3)Body[η]}.D ∪ Q k1∪ · · · ∪ Q kn∪ {Head(r)η | there exists a rule r = Q i(−→x ) ← Body ∈ (cid:2) and an assignment η such thatThe underlying intuition behind Definition 4 is quite clear. The evaluation stage for a Datalog program is defined step-by-step. At the beginning, all interpretations of intensional predicates are set to be empty. At each stage k, the value of an intensional predicate Q i (i.e. Q k+1i ) with all values computed at this stage by the Datalog program (cid:2). More precisely, Q k+1i by the heads of all applicable rules associated with Q i at stage k, where a rule in (cid:2) is associated with Q i if its head mentions Q i , and is applicable at stage k if its body is satisfied by the current evaluation, i.e., D ∪ Q k1Clearly, for any Q i , the sequence Q 0i , Q 1) is expanded from the previous one (i.e. Q kis expanded from Q kis monotonic in the sense that Q ki∪ · · · ∪ Q kn .i , . . .for any k. Hence, i , . . . , Q k⊆ Q k+1iiia convergence always exists on finite structures.Definition 5 (Intended value). Let (cid:2) be a Datalog program and D a structure of τext ((cid:2)). Let Q ∈ (cid:9)(cid:2) be an intensional predicate. The intended value of Q on D for (cid:2), denoted by Q∞((cid:2), D), is(cid:7)Q j.0≤ jNotice that Definition 5 can be extended for structures D with arbitrary cardinality by using transfinite iteration. For an arbitrary cardinal number (cid:10), we define(cid:8)=• Q (cid:10)i· · · ∪ Qξnξξ <(cid:10) Qi|= (cid:3)Body[η]}.∪ {Head(r)η | there exists a rule r = Q i(−→x ) ← Body ∈ (cid:2) and an assignment η such that D ∪ Q∪ξ1Again, a least fixed point always exists, which is called the intended value. Nevertheless, for simplicity and clarity, we mainly use the notion of evaluation stage proposed in Definition 5 unless stated otherwise. This should not affect the major conclusions drawn in this paper.Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79633. A progression definition for normal logic programsIn this section, we propose a progressional definition for first-order normal logic programs and show that it is equivalent to the translational stable model definition.3.1. The progressional definitionFirst of all, we define the evaluation stage for normal logic programs with respect to a structure.Definition 6 (Evaluation stage). Let (cid:2) be a (normal) program and (cid:9)(cid:2) = {Q 1, . . . , Q n} the set of all the intensional predicates of (cid:2). Consider a structure M of τ ((cid:2)). The t-th simultaneous evaluation stage of (cid:2) with respect to M, denoted by Mt((cid:2)), is a structure of τ ((cid:2)) defined inductively as follows:• M0((cid:2)) = M|τext((cid:2)) ∪Eτint ((cid:2)), where M|τext((cid:2)) is the restriction2 of M on τext((cid:2)), and Eτint ((cid:2)) is the structure defined −→x ) ← β1, . . . , βm, not γ1, . . . , not γl ∈ (cid:2) and an assignment η• Mk+1((cid:2)) = Mk((cid:2)) ∪ {Head(r)η | there exists r = Q (on τint((cid:2)) such that all interpretations of predicates are empty;such that for all i (1 ≤ i ≤ m), βiη ∈ Mk((cid:2)), and for all j (1 ≤ j ≤ l), γ jη /∈ M}.Although Definition 6 looks a little complicated, the underlying idea is quite simple. At each step, we expand the struc-ture by adding those heads of rules that are applicable. Here, a rule r is applicable at step k if P os(r) is satisfied by Mk((cid:2))and Neg(r) is satisfied by M.Let us take a closer look at Definition 6. Clearly, M0((cid:2)) just takes all extensional relations as the initial input, while all relations corresponding to intensional predicates in τint ((cid:2)) are set to be empty. Then, Mt+1((cid:2)) is obtained from Mt ((cid:2))by adding all derivable intensional values from Mt ((cid:2)) by fixing M. Here, an intensional value is derivable from Mt ((cid:2))by fixing M if there exists a rule applying on an assignment whose head is exactly the intensional value, whose positive body can be derived from Mt ((cid:2)) and whose negative body is consistent with M. It is important to emphasize that, in Definition 6, the negative part is fixed by M (i.e. the original structure) but not Mt ((cid:2)) (i.e. the t-th evaluation stage).For each intensional predicate Q ∈ (cid:9)(cid:2), we use Q i((cid:2), M) to denote QMi ((cid:2)) for simplicity. Then, it is easy to see that the sequence Q 0((cid:2), M), Q 1((cid:2), M), Q 2((cid:2), M), · · · , always increases, that is, Q j((cid:2), M) ⊆ Q i((cid:2), M) for j < i. ∞((cid:2), M) =So a convergence for the sequence of Q 0((cid:2), M), Q 1((cid:2), M), Q 2((cid:2), M), · · · , always exists. We call Q(cid:8)1≤ j≤∞ Q j((cid:2), M) the intended value of Q on M for (cid:2). Consequently, the convergence of the sequence M0((cid:2)), M1((cid:2)), M2((cid:2)), · · · , also exists:(cid:7)M∞((cid:2)) =M j((cid:2)).0≤ jIf Q (a1, . . . , an) ∈ M∞((cid:2)), then we say that Q (a1, . . . , an) is a link of M with respect to (cid:2). In addition, the evaluation time of Q (a1, . . . , an) on M with respect to (cid:2) is the least number t such that Q (a1, . . . , an) ∈ Mt((cid:2)). In particular, if Q (a1, . . . , an) is not a link of M, we treat the evaluation time of Q (a1, . . . , an) as ∞.Similarly to Datalog, Definition 6 can be extended for structures with arbitrary cardinality by using transfinite iteration. For simplicity and clarity, we mainly use the notion and notations in Definition 6. Again, this should not affect the major conclusions drawn in this paper.Based on the definition of evaluation stage, we are able to characterize the stable model semantics for first-order normal logic programs by using a progressional definition, similar to the one for Datalog.Definition 7 (Progressional stable model). Let (cid:2) be a normal program and M a structure of τ ((cid:2)). M is called a progressional stable model of (cid:2) iff M∞((cid:2)) = M.We call this definition the progressional definition. Intuitively, a structure M is a progressional stable model of a program (cid:2) iff it is the fixed point of the progression of (cid:2) with respect to M. More precisely, M coincides with the structure obtained by recursively applying the rules in (cid:2), where the negative parts are fixed by M itself.Example 1. Consider the following program (cid:2)G :Go Shopping(x, y) ← F riends(x, y),Go Shopping(x, y) ← Go Shopping(x, z), Likes(z, y), not Hate(x, y).2 Let σ and σ1 be two signatures such that σ ⊆ σ1, and M a structure of σ1. The restriction of M on σ , denoted by M|σ , is a σ -structure such that for every constant c ∈ σ (every predicate P ∈ σ ), c).M|σ = PM|σ = c( PMM64Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79Note that Go Shopping is the only intensional predicate in program (cid:2)G . We consider a finite structure M, whereDom(M) = {alice, carol, jane, sue},F riendsM = {(alice, carol), ( jane, sue)},LikesHateM = {(carol, sue)},M = {(alice, jane), ( jane, alice)},Go ShoppingM = {(alice, carol), ( jane, sue), (alice, sue)}.Then, from Definition 6, we obtain the following sequence:Go Shopping0((cid:2)G , M) = ∅,Go Shopping1((cid:2)G , M) = {(alice, carol), ( jane, sue)},Go Shopping2((cid:2)G , M) = {(alice, carol), ( jane, sue), (alice, sue)},Go Shopping3((cid:2)G , M) = Go Shopping2((cid:2)G , M).So Go Shoppingstable model of (cid:2)G . (cid:2)∞((cid:2)G , M) = {(alice, carol), ( jane, sue), (alice, sue)}. From Definition 7, we can see that M is a progressional The progressional definition for answer set programs may be viewed as a generalization of the Gelfond–Lifschitz trans-formation [21,22] to the first-order case. First, we guess a first-order structure M. Then, we evaluate the intended values of all intensional predicates with respect to the candidate structure. Finally, if all the intended values are the same as the ones specified in the candidate structure M, then M is a progressional stable model (answer set) of the underlying program.On the other hand, the progressional definition for normal programs can be viewed as an extension of the progressional definition for Datalog [1]. From a syntactic point of view, a Datalog program is a special case of normal program, where the negative bodies mention no intensional predicate. To address this difference semantically, one needs to handle the oc-currences of intensional predicates in the negative bodies. For this purpose, we use several techniques. First, we guess a candidate structure on the signature of the program instead of just using a structure on the extensional signature (i.e., the extensional database) to start with the progression. Second, we fix the negative parts of the program by the guessed struc-ture. In this sense, the evaluation process (i.e., the progression) follows similarly to Datalog. Finally, the guessed structure is considered to be a progressional stable model if it coincides with the structure obtained from the progression.Our progressional definition also shares some fundamental ideas with Reiter’s semantics for default logic [37]. Recall Reiter’s definition of extensions. First, a candidate theory T is guessed; then an iterative process is applied to compute the result (cid:13)(T ) of applying default rules with respect to this guessed theory T , in which the negative parts of default rules are fixed by T ; finally, T is an extension if it coincides with (cid:13)(T ). Nevertheless, there are two differences. First of all, in Reiter’s default logic, what we guess is a theory, but in our progress definition, what we guess is a first-order structure. Also, Reiter’s semantics is essentially propositional (or can only be applied to closed first-order logic) as it requires the closure property.3.2. Progressional stable models = translational stable modelsWe show that the progressional definition (i.e. Definition 7) is indeed equivalent to the translational definition (i.e. Definition 1).Theorem 1. Let (cid:2) be a program and M a structure of τ ((cid:2)). Then, M is a model of S M((cid:2)) iff M∞((cid:2)) = M.Proof. In order to prove this theorem, we introduce an alternative equivalent definition, and show that it is equivalent to both the progressional definition and the translational definition described above.Let (cid:2) be a program and M a structure of τ ((cid:2)). We say that M is a justified stable model of (cid:2) iff1. for every assignment η and every rule r of form (1) in (cid:2), if for all i (1 ≤ i ≤ m), βiη ∈ M and for all j (1 ≤ j ≤ l), γ jη /∈ M, then αη ∈ M.2. there does not exist a structure M(cid:15)of τ ((cid:2)) such that(a) Dom(M(cid:15)) = Dom(M),(b) for each constant c in τ ((cid:2)), cM(cid:15) = P(c) for each P ∈ τext((cid:2)), PM(cid:15) ⊆ Q(d) for all Q ∈ τint((cid:2)), Q(e) for every assignment η and every rule r of form (1) in (cid:2), if for all i (1 ≤ i ≤ m), βiη ∈ M(cid:15)M(cid:15) = cM,, and for some Q ∈ τint((cid:2)), QM(cid:15) ⊂ QMMM,,γ jη /∈ M, then αη ∈ M(cid:15).and for all j (1 ≤ j ≤ l), Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7965∗∗nM∗M∗ ∈ (cid:9)∗∗ ∈ (cid:9)∗(cid:2)(((cid:9)∗M(cid:15) = c∗M = QM(cid:15) = Q; (3) for each P ∈ τext((cid:2)), P. Then it is not difficult to observe that M(cid:15)’s corresponding predicate in (cid:9)(cid:2). Hence, M |= ∃(cid:9)∗(cid:2) < (cid:9)(cid:2)) ∧ (cid:2)∗). We can always construct M(cid:15)We first show that this definition is equivalent to the translational definition. It is not difficult to verify that Condition 1 (cid:2) < (cid:9)(cid:2)) ∧ (cid:2)∗). Suppose that there exists = {Q} corresponding to (cid:9)(cid:2) = {Q 1, . . . , Q n}. Therefore, M |= (cid:9)∗ < (cid:9) according to Condition 2(d). as specified (cid:2), Qwhere for each Q(cid:2) < (cid:9)(cid:2)) ∧ (cid:2)∗). On the other hand, suppose in such a way: (1) Dom(M(cid:15)) = Dom(M); (2) for each ; and (4) for each Q ∈ (cid:9)(cid:2) and its corresponding holds iff M |= (cid:2)(cid:2). Now we prove that Condition 2 does not hold iff M |= ∃(cid:9)∗(cid:2)(((cid:9)∗∗, we construct n new relations in M on predicates (cid:9)∗such an M(cid:15)1 , . . . , Q(cid:2)M(cid:15)(cid:2) and its corresponding Q ∈ (cid:9)(cid:2), Qsuch that each QIn addition, from Condition 2(e), it is easy to see that M satisfies (cid:2)∗above, here Q is Qthat M |= ∃(cid:9)∗(cid:2)(((cid:9)∗constant c in τ ((cid:2)), c(cid:2), QQ∗ ∈ (cid:9)∗Now we show that this definition is also equivalent to the progressional definition. Suppose that M∞((cid:2)) = M. Then, Condition 1 holds. Otherwise, there exists an assignment η and a rule r such that, for all i (1 ≤ i ≤ m), βiη ∈ M and for all j (1 ≤ j ≤ l), γ jη /∈ M but αη /∈ M. Since βiη ∈ M∞((cid:2)), there exists a bound k such that for all i (1 ≤ i ≤ m), βiη ∈ Mk((cid:2)). Then, αη ∈ Mk+1((cid:2)) by the definition. This means that αη ∈ M∞((cid:2)). Therefore, αη ∈ M, a contradiction. In addition, Condition 2 must hold as well. Otherwise, let us assume that there exists such an M(cid:15). By induction on the evaluation stage t, it can be shown that for all t, Mt ((cid:2)) ⊆ M(cid:15). Hence, M∞((cid:2)) ⊆ M(cid:15) ⊂ M, a contradiction. On the other hand, suppose that a structure M satisfies both Conditions 1 and 2. Then, it can be shown that Mt ((cid:2)) ⊆ M by induction on the evaluation stage t by Condition 1. Hence, M∞((cid:2)) ⊆ M. Now we show that M ⊆of τ ((cid:2)) in the following way: Dom(M(cid:15)) = Dom(M), M∞((cid:2)). Otherwise, M∞((cid:2)) ⊂ M. We construct a structure M(cid:15)M(cid:15) = cMMfor each constant c ∈ τ ((cid:2)), c, and for each intensional M∞((cid:2)). So M(cid:15)M(cid:15) = Qsatisfies Conditions 2(a)–(e) as well, a contradiction. Hence, M∞((cid:2)) = M. (cid:2)predicate Q ∈ (cid:9)(cid:2), Q, for each extensional predicate P ∈ τext((cid:2)), P. Therefore, M∞((cid:2)) ⊆ M(cid:15)satisfies Conditions 2(c)–(e).M(cid:15) = P∗M = QM(cid:15) = PM(cid:15)M4. Boundedness, recursion-freeness and loop-freenessThe progressional definition for normal logic programs is a natural extension of that for Datalog programs. As discussed in the previous section, it is important for understanding the deep and long neglected connections between ASP and Datalog. More interestingly, with this definition, we are able to consider some important notions and techniques originated from Datalog for first-order answer set programming.Among them, one fundamental notion is boundedness. Roughly speaking, a Datalog program is bounded if there exists a natural number k such that every evaluation stage of this program must be ended within k steps. Boundedness is one of the key notions in Datalog, e.g., to study the expressive power of Datalog and classical first-order logic [2].With our progressional definition, we are able to define the boundedness notion for first-order ASP. Certainly, the basic idea is similar, i.e., we may require that every evaluation of a normal program is bounded by some fixed number as well. However, as we shall see in this section, the definition is not that straightforward as the progression of a normal program is relative to a candidate structure.Boundedness also plays an important role in first-order ASP. In this section, we shall show that it is actually equivalent to the syntactic notions of recursion-freeness and loop-freeness under program equivalence. Roughly speaking, recursion-free programs are those programs without recursions, that is, the positive bodies of any rules in the program contain no intensional predicate, while loop-free programs, also called tight program in the literature [17], are those programs without loops [12,30]. In the next section, we will use boundedness as a key tool to study the expressive power of first-order ASP, in particular, its relationships to classical first-order logic.4.1. Boundedness for normal logic programsWe first review the notion of boundedness in Datalog, which had attracted much attention in the area of deductive databases [1,32].Definition 8 (Datalog boundedness). A Datalog program (cid:2) is bounded if there exists a natural number k, such that for every ∞ = Q k for all intensional extensional database D, the evaluation stage of (cid:2) on D is bounded within k steps, i.e., Qpredicates Q in (cid:2).The boundedness notion can be extended for first-order answer set programming based on our progressional definition for normal logic programs (i.e. Definition 7).Definition 9 (Boundedness). A program (cid:2) is bounded if there exists a natural number k, such that for all intensional pred-∞((cid:2), M) = Q k((cid:2), M); or equivalently, M∞((cid:2)) = Mk((cid:2)). In this case, icates Q of (cid:2) and all stable models M of (cid:2), Qk is called a bound of (cid:2), and (cid:2) is called a k-bounded program.Definition 9 is not the same as saying that for all stable models M, there exists a natural number k such that M∞((cid:2)) = Mk((cid:2)). It is important to note that, similar to the boundedness notion for Datalog (see Definition 8), the 66Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79fixed constant k applies on all stable models, i.e., such k is independent from specific structures (stable models). How-ever, the difference between boundedness for ASP and that for Datalog is that the former only takes the stable models but not all τ ((cid:2))-structures into account. Hence, for a k-bounded program (cid:2), there may exist a τ ((cid:2))-structure M such that M∞((cid:2)) (cid:10)= Mk((cid:2)), where M is not a stable model of (cid:2).Boundedness is a semantic notion in the sense that its definition is only depending on the progressional definition. It intends to capture a certain subclass of all programs, for which their progressions are very restricted.Example 2. Consider the following program (cid:2)V :V isits(x, y) ← Interested(x, y), not Busy(x),V isits(x, y) ← V isits(z, y), Attraction( y), not Busy(x).(6)In program (cid:2)V , V isits is the only intensional predicate. According to Definition 6, it is easy to verify that for any stable model M of (cid:2)V , the evaluation time for all intended values of V isits is not more than 2. In other words, program (cid:2)V is a 2-bounded program. (cid:2)Nevertheless, let (cid:2)V (cid:15) be the program obtained from (cid:2)V by replacing the rule (6) with the following one:V isits(x, y) ← V isits(z, y), Interested(x, z), not Busy(x).Then, (cid:2)V (cid:15)Interestedbut there does not exist a number k such that M∞((cid:2)V (cid:15) ) = Mk((cid:2)V (cid:15) ).M = {(ai, ai+1) | i ≥ 0} and V isitsis unbounded. One can construct a structure M with an infinite domain a0, a1, . . . , an, . . . , BusyM = ∅, M = {(ai, a j) | i < j}. It can be verified that M is a stable model of (cid:2)V (cid:15)Clearly, the boundedness notion for normal programs is an extension of that for Datalog programs.Proposition 2. Let (cid:2) be a Datalog program. Then, (cid:2) is bounded under Definition 9 iff it is bounded under Definition 8.As a consequence, some results in the Datalog literature can be directly applied under the context of ASP.Corollary 3. Checking boundedness for normal logic programs is undecidable.Proof. This assertion follows directly from Proposition 2 and the result that checking boundedness for Datalog programs is undecidable (see Theorem 2.5 in [19]). (cid:2)4.2. Recursion-freeness and loop-freenessNow we introduce two syntactic notions for first-order normal programs, namely recursion-freeness and loop-freeness, which are used to characterize the expressiveness of first-order answer set programs from a syntactic point of view.Recursion-freeness is an important notion in Datalog and it is well-studied in the Datalog community [1,2,32]. It can be lifted for first-order normal programs as follows.Definition 10 (Recursion-freeness). A program is said to be recursion-free if no intensional predicate occurs in the positive body of any rule in the program.Note that it is possible that the intensional predicates may occur negatively in a recursion-free program.Example 3. Consider the following program (cid:2)V P :V isits(x, y) ← Interested(x, y),PossVisit(x, y) ← Attraction( y), not V isits(x, y).There are two intensional predicates V isits and PossVisit in program (cid:2)V P . Since none of them positively occurs in the bodies of the two rules, (cid:2)V P is a recursion-free program. (cid:2)It is generally considered that recursion is one of the most important features for Datalog and normal logic programs. Hence, recursion-free programs can be considered as “trivial” programs to some extent.According to the definitions, it is easy to see that the following result holds.Proposition 4. If (cid:2) is a recursion-free program, then M∞((cid:2)) = M1((cid:2)) for any structure M of τ ((cid:2)).Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7967Proposition 4 states that for recursion-free programs, the stable models of the program can be verified within one step. It immediately follows that all recursion-free programs are bounded.Corollary 5. Recursion-free programs are bounded.A closely related notion is loop-freeness.3 For this purpose, we first review the concepts of loops for first-order normal programs [12]. Let (cid:2) be a program. The positive dependency graph of (cid:2), denoted by G(cid:2), is a graph (maybe infinite) (V , E), where V is the set of atoms of τint ((cid:2)), and (α, β) is an edge in E if (a) there exists a rule r ∈ (cid:2), and α(cid:15)in r such that α(cid:15)is one of the positive atoms of intensional predicate in the body of r, and (b) there exists a substitution θ such that α(cid:15)θ = α and β(cid:15)θ = β. A finite non-empty subset L of V is said to be a loop of (cid:2) if there exists a cycle in G(cid:2) that goes through only and all the nodes in L.is the head of r and β(cid:15)and β(cid:15)Loops and their corresponding loop formulas are critical concepts in answer set programming. As shown in [12], under the stable model semantics, a logic program can be captured by its completion together with all its loop formulas on finite structures. Also, it initiates an alternative way to compute the stable models of a program by transforming it to propositional formulas [30].Definition 11 (Loop-freeness). A program is said to be loop-free if it has no loop.The stable models of a loop-free program can be exactly captured by its Clark’s completion [12,17].Proposition 6 ([12]). Let (cid:2) be a loop-free program. Then, a τ ((cid:2))-structure M is a stable model of (cid:2) iff it is a model of Comp((cid:2)).Example 4. Consider programs (cid:2)V and (cid:2)V P once again in Examples 2 and 3 respectively. It is easy to see that (cid:2)V has a loop L = {V isits(x, y), V isits(z, y)}. So (cid:2)V is not loop-free. On the other hand, program (cid:2)V P in Example 3 is loop-free obviously. (cid:2)Clearly, recursion-free programs are loop-free as their positive dependency graphs have no edge at all.Proposition 7. A recursion-free program must be loop-free.However, the converse of Proposition 7 does not hold in general. For example, the following programV isits(x, y) ← F riends(x, y),F riends(x, y) ← Likes(x, y), not Hate(x, y).is loop-free but not recursion-free.4.3. On the relationships among boundedness, recursion-freeness and loop-freenessIn this subsection, we shall show that the syntactic notions of recursion-freeness and loop-freeness are closely related with the semantic notion of boundedness. More precisely, these three notions coincide under program equivalence, that is, a program is bounded if and only if it is equivalent to a recursion-free program if and only if it is equivalent to a loop-free program.Some straightforward observations are presented earlier, e.g., Corollary 5 and Proposition 7. Corollary 5 states that all recursion-free programs must be bounded. We can extend this into the following result.Proposition 8. A loop-free program must be bounded.We leave the proof to the Appendix. Proposition 8 is an extension of Corollary 5 since all recursion-free programs are loop-free by Proposition 7.Now we consider the other way around, that is, whether or not a bounded program can be converted to a recursion-free/loop-free program. First of all, the following example shows that there exists a bounded program that is neither recursion-free nor loop-free.3 Loop-free is also called tight in the literature [17], particularly in the propositional case. We call it loop-free here in order to compare it with the notion of recursion-free.68Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79Example 5. Let (cid:2) f lag be the following program:Reach(a)Reach(x) ← Reach( y), Edge(x, y), f lagReach(x) ← not Reach(x)f lag ← f lag(7)Clearly, (cid:2) f lag is not a recursion-free program as the positive body of rule (7) mentions the intensional predicate Reach. It is not a loop-free program either since rule (7) forms some loops. However, (cid:2) f lag is a bounded program. The reason is that the only recursion rule, i.e., rule (7), is guarded by the 0-ary intensional predicate f lag. As f lag will never be generated in the progression, this rule will never be triggered. Thus, the syntactic recursion in rule (7) is actually blocked semantically.It is easy to see that the above program (cid:2) f lag can be equivalently transformed to a recursion-free one by simply deleting rule (7) and the rule f lag ← f lag. In this sense, (cid:2) f lag is “semantically” recursion-free to some extent. The following proposition confirms that this kind of semantical recursion-freeness indeed can be implied by boundedness.Proposition 9. If a program is bounded, then it is equivalent to a recursion-free program.As the proof of Proposition 9 is a little tedious, although a similar result for Datalog programs holds straightforwardly. We leave it to the appendix.It immediately follows from Proposition 9 and Proposition 7 that any bounded program can be equivalently transformed to a loop-free program.Corollary 10. If a program is bounded, then it is equivalent to a loop-free program.From Corollary 5, Proposition 7, Proposition 8, Proposition 9 and Corollary 10, we can see that the notions of bounded-ness, recursion-freeness and loop-freeness are highly connected. However, these results are not enough to justify the claim made in the beginning of this subsection that boundedness, recursion-freeness and loop-freeness coincide under program equivalence. The missing assertion is: if a program is equivalent to a recursion-free or loop-free program (but not necessar-ily is recursion-free or loop-free itself), must it be bounded? The answer is again yes, and we shall prove it in Section 5. Nevertheless, for this purpose, more tools and techniques are needed.Notice that the proofs provided in this section are independent of the cardinality of a particular structure. Hence, the main results proved in this section hold both on arbitrary structures and on finite structures.5. First-order definability of answer set programs and boundednessThe relationship between first-order ASP and FOL is one of the most important topics in this area, and it has been well-studied in the literature [4,5,12–14,17,25,26,39]. Researches in this direction are mainly focused on translating (some subclasses of) first-order ASP into classical FOL. This is because FOL is a well-established formalism so that translations from ASP to FOL would be helpful to understand some essential properties of the former. Also, normal logic programming is only a fragment of first-order logic programming. For instance, it lacks the support of disjunctive heads and existential quantifiers. Hence, it makes little sense to translate the full version of classical logic into a fragment of logic programming. Interestingly, some recent works are proposed to translate fragments of FOL (e.g., various description logics) into fragments of ASP (e.g., normal logic programs enhanced with existential quantifiers in the heads), largely driven by the need of rule-based reasoning and defeasible reasoning in ontology engineering [23].For the problem of translating first-order normal logic programs under the stable model semantics into classical first-order logic, a rather complete answer has been provided by Asuncion et al. [4] based on previous results in the literature (see Table 2 in [4]). Interestingly and surprisingly, the answer is depending on three factors, considering arbitrary structures or only finite structures, introducing auxiliary predicates or not, and allowing the results to be infinite or not. To conclude, there is no translation from normal ASP to FOL when considering arbitrary structures. For finite structures, if no new pred-icates are introduced and the results are restricted to be finite, again, such translation does not exist. However, there exist translations from normal ASP to FOL when relaxing any of the above two conditions. Loop formulas provide a translation from normal ASP to FOL on finite structures without introducing any new predicates but the translated results could be in-finite [12]. Ordered completion is an alternative translation that guarantees the result to be finite but a polynomial number of extra predicates are needed [4].Although normal ASP cannot be translated into FOL on arbitrary structures in general, this can be done for some sub-classes. A well known subclass is the class of loop-free programs (also called tight programs) [17]. It was shown that the stable models of a loop-free program can be captured by its Clark’s completion, which is a first-order sentence. This result is extended to the so-called loop-separable programs [13]. In fact, work in this direction is not only theoretically important Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7969but also practically relevant. For instance, some modern ASP solvers are built based on the loop-formula approaches, e.g. ASSAT [30] and CMODELS [27].However, it still remains an open problem whether there is an exact characterization of the first-order definability of first-order normal answer set programs, that is, whether we can exactly capture what kind of normal programs are first-order definable. In this paper, we bridge this gap and show that the concept of boundedness exactly captures first-order definability for first-order normal programs on arbitrary structures. That is, a program is first-order definable if and only if it is bounded. Moreover, we show that these two notions coincide with the syntactic notions of recursion-freeness and loop-freeness under program equivalence.5.1. First-order definability of answer set programsWe start our discussions with a formal definition of first-order definability of normal logic programs.Definition 12 (First-order definability). Let (cid:2) be a program and φ a first-order sentence of the signature τ ((cid:2)). Let C be a class of first-order structures. We say that φ defines (cid:2) on C if the models of φ in C are exactly the stable models of (cid:2) in C.A program (cid:2) is said to be first-order definable on C if there exists such a first-order sentence that defines (cid:2).In this paper, we normally consider C to be the class of all structures or the class of finite structures.Example 6. Let us consider (cid:2)V again in Example 2. It can be verified that (cid:2)V is defined by the following sentence:∀xy(V isits(x, y) ↔ (Interested(x, y) ∧ ¬Busy(x) ∨ ∃z(z (cid:10)= x ∧ V isits(z, y) ∧ Attraction( y) ∧ ¬Busy(x)))). (cid:2)It was shown in the literature that the stable models of a loop-free program can be exactly captured by its Clark’s completion.Proposition 11. [13] If (cid:2) is a loop-free program, then Comp((cid:2)) defines (cid:2) on both arbitrary structures and finite structures.Consequently, by Proposition 7, a recursion-free program is defined by its Clark’s completion as well.5.2. Boundedness = first-order definabilityNow we prove that the semantic notion of first-order definability can be exactly captured by the semantic notion of boundedness presented in Section 4 on arbitrary structures, which further corresponds to the syntactic notions of recursion-freeness and loop-freeness under program equivalence.Theorem 2. Let (cid:2) be a program. The following four statements are equivalent on arbitrary structures.1. (cid:2) is bounded.2. (cid:2) is equivalent to a recursion-free program.3. (cid:2) is equivalent to a loop-free program.4. (cid:2) is first-order definable.Notice that 1 ⇒ 2 is Proposition 9; 2 ⇒ 3 follows straightforwardly from Proposition 7 and 3 ⇒ 4 follows straightfor-wardly from Proposition 11. We only need to prove 4 ⇒ 1 for Theorem 2. Nevertheless, the proof of this is rather technical and tedious. Hence, we leave it to the appendix.Corollary 12. Boundedness is closed under program equivalence. That is, if two programs (cid:2)1 and (cid:2)2 are equivalent, then (cid:2)1 is bounded iff (cid:2)2 is bounded.Proof. Since (cid:2)1 is bounded, then it is first-order definable. Therefore, (cid:2)2 is first-order definable by the same sentence as (cid:2)2 is equivalent to (cid:2)1. It follows that (cid:2)2 is bounded as well. (cid:2)6. Yet another translation from ASP to SMTThe progressional definition sheds new insights on first-order ASP from a theoretical point of view. For instance, Theo-rem 2 states that first-order definability of normal programs can be exactly captured by the notion of boundedness, which is defined based on the progressional definition. In this section, we show that the progressional definition sheds new insights into first-order ASP from a practical point of view. More precisely, the progressional definition suggests a natural way to en-code first-order normal ASP into Satisfiability Modulo Theories (SMT) [35], which are classical first-order theories enhanced 70Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79with some modular theories to represent some components that cannot be easily handled in a logical setting, for instance, arithmetical formulas such as 2x − y ≤ 10.This work follows the ordered completion approach, which translates a normal program to a first-order (SMT) sentence. The ordered completion approach initiates a new way of computing stable models by grounding on ordered completion (a first-order sentence) of programs instead of the first-order program itself, as most of the modern ASP solvers do.Inspired from the progressional definition (see Definition 7), we can define an alternative translation from normal ASP to first-order logic/first-order SMT. In fact, the progressional definition directly specifies a derivation order. Let us take a closer look at Definition 7 again. At the k-th stage of the progression, the accumulating structure Mk((cid:2)) will be extended by some ground atoms, which are heads of some rules applicable at the k-th stage. Notice that the intensional part of the initial structure M0((cid:2)) is empty and the final structure M∞((cid:2)) coincides with M itself if M is a stable model of the program. This means that for any ground atom α to be true in the stable model M, it must be generated at a particular stage t in the progression, that is, there exists a rule r in the program that generates the atom α at the stage t in the progression. This is equivalent to• the negative body of r is satisfied by the intended structure M;• the positive body of r is satisfied by the t-th evaluation stage Mt ((cid:2));• and the positive body of r is not satisfied by the t − 1-th evaluation stage Mt−1((cid:2)) (otherwise the rule r must be applied before),which is further equivalent to (since Mk((cid:2)) is monotonic)• the negative body of r is satisfied by the intended structure M;• the positive body of r is satisfied by the intended structure M;• there exists at least one ground atom in the positive body of r, which is generated at the t − 1-th stage, and all other ground atoms in the positive body of r must be generated even earlier.Having explained our intuitions, we are now able to define the new translation from normal ASP to SMT. Again, for every intensional predicate P , we introduce an integer function n P with the same arity.Definition 13 (Progression based completion). Let (cid:2) be a program. The progression based completion of (cid:2), written P C((cid:2)), is the following sentence−→x [P (−→x ) = succ(max({n Q ((cid:2)Bodyi ∧ n P (−→z )}))],−→x ) →(cid:2)(cid:2) ∧−→yi(cid:6)(cid:5)(8)∀∃P ∈τint ((cid:2))1≤i≤kwhere• some notations, including yi , Bodyi and (cid:2)Bodyi , are borrowed from Definitions 2 and 3. Once again, Q (−→z ) ranges over all intensional atoms in the positive part of Bodyi ;• succ and max stand for the successor function and the maximum function in arithmetic respectively.Similar to Clark’s completion and ordered completion, progression based completion has to satisfy the program itself, namely (cid:2)(cid:2). The main difference is the justification part, which states that if a ground atom is in the stable model, then it has to be justified. There are different understandings of justification. In Clark’s completion, it simply states that there is a rule in the program to support this ground atom, i.e., whose head is the ground atom and whose body is also satisfied by the structure. It turns out that this kind of justification is not powerful enough to capture the stable model semantics. In ordered completion, justification is a bit stronger in the sense that not only that there exists a rule to support the ground atom but also that all ground atoms of that rule have to be justified earlier. As shown by Asunction et al. [4], this is enough to capture the stable model semantics. In progression based completion, justification is even stronger as it enforces a particular derivation order, which actually coincides with the derivation order obtained in the progression. Intuitively, for −→−→a ) exactly represents its evaluation time in the progression of (cid:2) with respect to M. Here, the a ), n P (a ground atom P (−→−→x ) = succ(max({n Q (x ) is exactly the maximal arithmetical formula n P (−→stage of the positive body atoms plus 1. That is, the rule is exactly triggered at this stage in the max({n Q (z )})-th evaluation stage.−→z )})) means that the stage of the head atom P (Example 7. Let (cid:2)R be the following program to check the reachability of a graph, whose edges are represented by the extensional predicate Edge.Reach(a)Reach(x) ← Reach( y), Edge(x, y),Reach(x) ← not Reach(x).Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7971Then, O C(cid:15)((cid:2)) is(cid:9)(cid:2)R ∧ ∀xR(x) → x = a ∨ ∃ y[R( y) ∧ E( y, x) ∧ nR (x) < nR ( y)],while P C((cid:2)) is(cid:9)(cid:2)R ∧ ∀x(R(x) → x = a ∨ ∃ y[R( y) ∧ E( y, x) ∧ nR (x) = succ(nR ( y))].Progression based completion and ordered completion share something in common. Both of them modify the justification part of Clark’s completion into a logically stronger formula by adding some extra statements about the derivation order of ground atoms. Nevertheless, ordered completion only requires that the ground atoms are justified in some order, i.e., bodies should be justified earlier than heads, while progression based completion strictly enforces one particular derivation order on ground atoms, which coincides with the one obtained in the progressional definition. Thus, progression based completion yields a stronger version.Proposition 13. Let (cid:2) be a program. Then, P C((cid:2)) |= O C(cid:15)((cid:2)).Proof. This follows from the definitions since if n P (−→x ) = succ(max({n Q (−→z )})), then for all n Q (−→z ), n Q (−→z ) < n P (−→x ). (cid:2)Another difference between these two translations is the host SMT language. Ordered completion needs to use the built-in comparison operators <, while progression based completion needs to use two built-in functions, namely the maximum function and the successor function. Note that, for linear programs (in which all bodies of rules contain at most one inten-sional predicate) such as reachability, the maximum function is not needed in progression based completion.We end up this section by showing that, on finite structures, progression based completion, namely P C((cid:2)), exactly captures the stable model semantics as well.Theorem 3. Let (cid:2) be an extended program. Then, a finite τ ((cid:2))-structure is a stable model of (cid:2) if and only if it can be expanded to a model of P C((cid:2)).−→a ), we define n P (is a model of (cid:2)(cid:2) since M is a model of (cid:2)(cid:2). For any ground atom P (−→a ) as its evaluation time in the progression. Now we show that M+Proof. The “if” part follows from Proposition 1 and Proposition 13. We show the “only if” part. Let M be a stable model of (cid:2). For a ground atom P (, the structure obtained from M by expanding the interpretations on the integer predicates n P as mentioned above, is a model −→of P C((cid:2)). First, M+a ) ∈ M, it must be justified by −→a rule r together with an assignment η at step n P (b ) in −→a )((cid:2)). In addition, there the positive body of rη, Q (−→a ) should be exists some Q (−→b ) ∈ P os(rη), Q ∈ (cid:9)(cid:2)})). This shows that M+justified earlier in the progression. Hence, n P (is a model of P C((cid:2)). (cid:2)−→b ) has to be justified before in the progression since Q (−→b ) in the positive body of rη whose evaluation time is exactly n P (−→a ) in the progression. Then, for any intensional ground atom Q (−→b ) ∈ Mn P (−→a ) − 1. Otherwise, P (−→a ) = succ(max({Q (−→b ) | Q (7. Ongoing and related workIn this paper, we have restricted our discussions to first-order normal logic programs with rules only of the form (1) — the most important and fundamental fragment of first-order answer set programming. Driven by needs, normal logic pro-grams are extended with some useful building blocks, including disjunctive heads, constraints and choice rules, existentially quantified heads, functions, nested expressions and so on. A problem arises when extending the progressional definition for programs with those building blocks. Unfortunately, this seems to be a challenging task as the underlying principles of some building blocks are essentially different from the nature of the progressional definition. In the progressional definition, all intensional ground atoms in a stable model of a program must be justified at some step in the evaluation stage. Starting from the empty intensional database, each step justifies a set of ground atoms, which are the heads of all rules applicable at the current stage. Here, a ground rule is applicable if its positive body is satisfied by the current progression stage and its negative body is satisfied by the candidate structure itself.Disjunctive logic programming is a natural extension of normal logic programming [22]. The head of a disjunctive rule is a disjunction of atoms, which represents a non-deterministic choice if the body is satisfied. The key point for extending the progressional definition for disjunctive programs is how to add the ground atoms when a ground rule is satisfied at a progression stage. There are two existing solutions. The first is to select a minimal hitting set of all heads of applicable rules (a collection of sets of ground atoms) as the justified ground atoms at this stage [42]. In this sense, there could be many different progression sequences with respect to a given disjunctive program and a candidate structure. The second approach is to collect the disjunctions of atoms (i.e., clauses) derivable at the current stage, and finally compute the minimal model of all collected clauses [39]. Both extensions are equivalent to the translational stable models definition. Again, some 72Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79interesting consequences follow from the progressional definition for disjunctive programs, e.g., a translation to SMT [42]and a characterization of first-order definability via boundedness [39].Constraints, choice rules and aggregates are essential building blocks for answer set programming, which are extensively used in most benchmark programs. Again, extending the progressional definition for them seems not easy as the underlying principles of the progressional definition and these building blocks are incompatible. For instance, while the progressional definition justifies the stable models step-by-step, the aggregate atoms are interpreted globally.It remains an open problem to further extend the progressional definition for incorporating other building blocks, for instance, functions, existentially quantified heads and nested expressions. We expect that such a progression definition, if defined, should be equivalent to the stale model semantics on these richer formalisms [5,18,24,38]. Nevertheless, this seems to be a challenging task as the progression definition needs to be defined step-by-step. Work in this direction is worth pursuing as the progressional definition has some important theoretical and practical consequences. Incorporating extensional functions in the progressional definition is straightforward as their interpretations are fixed in the extensional database. However, this task seems not easy for intensional functions [8,9,28]. Existentially quantified heads are of special interests as Datalog (ASP) enhanced with existentially quantified heads is able to capture some interesting fragments in description logics [23]. For incorporating existentially quantified heads in the progressional definition, again, the key point is how to add the ground atoms when a ground rule is satisfied at a progression stage. We leave these to our future investigations.Naive extensions to richer syntactic classes do not work. New notions and techniques have to be developed. For instance, only boundedness itself cannot make a difference between first-order disjunctive logic programs and classical first-order logic. Recently, we coined a new term called “choice-boundedness” for this purpose [41]. Also, we found that the progression definition may work for certain aggregates such as convex aggregates [3]. We consider this to be one of the most important future directions as the progression definition can help us understanding first-order answer set programming much more deeply, from not only a theoretical but also a practical point of view.The notion of boundedness (see Definition 9) presents an exact characterization of the first-order definability for normal logic programs on arbitrary structures (see Theorem 2). Hence, it covers the notion of loop separability [13], a sufficient condition for first-order definability based on loop formulas. Roughly speaking, a first-order program is loop-separable iff all its loop patterns can be separated in some sense so that all its loop formulas can be finitely characterized. As a consequence, the stable models of a loop separable program can be defined by the classical models of its Clark’s completion together with a finite set of loop formulas. Since boundedness is equivalent to the condition of first-order definability, all loop-separable programs are bounded. In fact, this can also be observed from the proof (see Section 5 in [13]), which essentially shows that if a program is loop-separable, then we only need to take some loops with a bounded size into account. However, the converse does not hold. That is, there exists a bounded program that is not loop separable, e.g., the program (cid:2) f lagin Example 5. Nevertheless, loop separability is a syntactic condition, while boundedness is semantic. In addition, it is decidable to check whether a program is loop separable (see Theorem 3 in [13]), but checking boundedness is undecidable. Nevertheless, given a fixed number k, checking k-boundedness should be decidable. This might help us to rewrite some logic programs into loop-free ones so that they can be solved more easily.Another important future direction is to apply our theoretical results into practices, for instance, to develop a new ASP solver based on the translation into SMT proposed in Section 6. Alternatively, we may utilize some notions and techniques developed in this paper, e.g., boundedness and k-boundedness, for solving certain subclasses of answer set programs more easily.8. ConclusionsThe main contributions of this paper are summarized as follows:• We extended the progression semantics for Datalog into a progression definition for first-order normal logic program-ming and showed that it is equivalent to the well-known stable model semantics. As a consequence, many important and useful notions and techniques in Datalog can be lifted for first-order ASP.• We introduced a notion of boundedness for first-order ASP and showed that it coincides with the notions of recursion-freeness and loop-freeness under program equivalence. More interestingly, we showed that these notions exactly capture first-order definability of ASP for normal logic programs. This clearly clarifies the expressive power of the intersection between first-order ASP and classical First-Order Logic (FOL), both from a syntactic and a semantic point of view. Syntac-tically, it is well known that recursion-free and loop-free logic programs are first-order definable [12,17,30]. Our result proved a long standing conjecture that this assertion holds the other way around. That is, a first-order definable logic program is essentially equivalent to a recursion-free (loop-free) one. Semantically, our result showed that boundedness draws a clear boundary between first-order definable and indefinable normal logic programs.• The progression semantics naturally suggests a new translation from first-order ASP to Satisfiability Modulo Theories (SMT) by introducing new predicates. This translation is of practical relevance since it is has less models than so-called ordered completion [4].Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7973To conclude, the progression definition sheds new insights into first-order Answer Set Programming (ASP), including its deep connections and relationships to Datalog, FOL and SMT.AcknowledgementsWe specially thank Fangzhen Lin for his initial inspiration on this work. Our results presented in this paper provides a complete answer to his conjecture on the equivalence between loop-freeness and first-order definability under stable model semantics. We thank Heng Zhang for pointing out that the original proof of Proposition 9 in our conference paper is incomplete. We are also grateful to the anonymous reviewers for their valuable comments.Appendix. Proofs of Proposition 9 and Theorem 2Without loss of generality, we may assume that all rules are presented in a normalized form. That is, each intensional −→predicate Q is associated with a tuple of distinguishable variables xQ ). For instance, if for some rule with an intensional predicate Q of its head, there is a constant c occurring in Q , i.e. Q (x1, · · · , xi−1, c, xi+1, · · · , xn), we simply introduce a new variable xi to replace c: Q (x1, · · · , xi−1, xi, xi+1, · · · , xn), and add atom xi = c in the body of this rule. We say that a variable x is a local variable of a rule r if it does not occur in the head of r. For convenience in our proofs, we assume that the sets of local variables in rules are pairwise disjoint.−→xQ so that the head of each rule is of the form Q (Proposition 8. A loop-free program must be bounded.Proof. We prove this assertion by contradiction. Assume that (cid:2) is not bounded. Then for an arbitrary k, there exists some −→stable model M of (cid:2), such that for some intensional predicate Q in (cid:9)(cid:2), Q (a ) /∈ Mk((cid:2)). Then from Definition 6, there must exist a rule r in (cid:2):−→a ) ∈ Mk+1((cid:2)) but Q (−→x ) ← β1, . . . , βm, not γ1, . . . , not γl,Q ((9)−→a ) = Q (−→x )η, and (2) for all i (1 ≤ i ≤ m), βiη ∈ Mk((cid:2)), and for all j (1 ≤ j ≤ l), and an assignment η such that (1) Q (γ jη /∈ M.Based on this observation, for the given stable model M of (cid:2), we define the intensional dependency tree T (Q (for Q (−→a ) as follows:−→a ), M)−→a ), M) is Q (−→a ),(a) the root of T (Q ((b) in (9), for each βi (1 ≤ i ≤ m), if βi is an intensional atom, then βiη is a child of Q ((c) for each child βiη of Q (subtree can be built.−→a ), we build the subtree T (βiη, M) as in (a) and (b), and repeat the process until no more −→a ),It is clear that T (Q (tree T (Q (−→x )) for atom Q (−→x ) as follows:−→a ), M) has depth k + 1. Now from T (Q (−→a ), M), we construct an atom based intensional dependency (i) let θ0 =(ii) let θ1 =−→a /−→b /−→x be a substitution, replace Q (−→y , where −→b is the tuple of elements occurring in β1η, · · · , βlη but not occurring in Q (−→a ) in T (Q (−→a ), M) by Q (−→a )θ = Q (−→x ) as the root of T (Q (−→x ));−→y be the −→a ), M), replace βiη by ((βiη)θ0)θ1 accordingly;−→a ), and tuple of variables not occurring in θ0, then for each child βiη in T (Q ((iii) this process continues until all ground atoms in T (Q (−→a ), M) have been replaced by the corresponding atoms.Then T (Q (−→x )) is a tree with depth k + 1 where only variables occur in each atom node.−→x ), Q j(−→x )), we observe that for each parent-child pair (Q i(From the construction of T (Q (is a corresponding edge (Q i(−→x ), Q j(−→y )) in (cid:2)’s positive dependency graph G(cid:2).On the other hand, since (cid:2) is not bounded, for any arbitrary k, there exists some stable model M and Q (−→a ) ∈ M, we −→can construct the tree T (Q (x )) with depth k + 1. Let N be the number of intensional predicates in (cid:2), and we choose −→some M > N. Then it is clear that for some intensional predicate Q , we can construct a tree T (Q (x )) which has a depth (M + 1) > N. Consequently, there must exist a path from the root to some leaf such that an intensional predicate Qoccurs −→(cid:15)(two or more than two times, i.e. atoms Qy ) are in the path. Therefore, a loop must exist in the corresponding positive dependency graph G(cid:2). This concludes that (cid:2) is not loop-free. (cid:2)−→(cid:15)(x ) and Q(cid:15)−→y )) in tree T (Q (−→x )), there Proposition 9. If a program is bounded, then it is equivalent to a recursion-free program.We prove it by constructions and we decompose the constructions into several steps. First, we show that every k-bounded program is equivalent to a 1-bounded program. Then, we show that a 1-bounded program can be equivalently transformed to a recursion-free program.74Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79Let (cid:2) be a normalized program and t a number. We define a program (cid:2)t inductively as follows. Firstly, set (cid:2)1 = (cid:2). We now specify (cid:2)t+1 by giving (cid:2)t , which is expanded from (cid:2)t by adding some new rules. Suppose that there exists a rule rin (cid:2) of the formα ← β1, . . . , βm, not γ1, . . . , not γl,−→t ) is an intensional atomic formula, then there exists a rule ri−→xQ i /−→t . We add a new rule r∗into (cid:2)t+1 such that:in (cid:2)t such that and for all i (1 ≤ i ≤ m), if βi = Q i(Head(ri)θi = βi , where θi is the substitution ∗) = Head(r),∗) = P os(r)\{βi1 , . . . , βin∪ P os(rn)θn,Head(rP os(r} ∪ P os(r1)θ1 ∪ . . .∗) = Neg(r) ∪ Neg(r1)θ1 ∪ · · · ∪ Neg(rn)θn,Neg(rwhere {βi1 , . . . , βin} is the set of all intensional atomic formulas in {β1, . . . , βm}, r1, . . . , rn are the corresponding rules in (cid:2)tas discussed above, and θi are defined accordingly. In addition, we apply necessary substitutions such that the sets of local variables in rules in (cid:2)t+1 are pairwise disjoint. It is easy to see that (cid:2)t+1 is a normalized program as well. Such process is similar to the unfolding in propositional logic programs. Clearly, (cid:2)t is normalized if (cid:2) is normalized.Lemma 1. Let (cid:2) be a program and k an integer. Then, Mk((cid:2)) = M1((cid:2)k) for any structure M of τ ((cid:2)).Proof. We prove this assertion by induction on k. Clearly, this assertion holds when k = 1. Suppose that for all k < t, this assertion holds. Now we prove that it holds when k = t as well.We first prove that Mt ((cid:2)) ⊆ M1((cid:2)t). Let (a1, . . . , an) ∈ Q t(M), where Q is an intensional predicate of (cid:2). If the evaluation time of Q (a1, . . . , an) is less than t, then Q (a1, . . . , an) ∈ M1((cid:2)t) by induction assumption. If the evaluation time of Q (a1, . . . , an) is exactly t, then according to the definition, there exists a rule r ∈ (cid:2) of form (1) and an assignment η−→xQ η = (a1, . . . , an), (b) for all i (1 ≤ i ≤ m), βiη ∈ Mt−1((cid:2)), and (c) for all j (1 ≤ j ≤ l), γ jη /∈ M. By induction such that (a) −→assumption, for all i (1 ≤ i ≤ m), βiη ∈ M1((cid:2)t−1). If βi is of the form Q (t ), where Q is an intensional predicate, then according to Definition 6, there exists a rule ri ∈ (cid:2)t−1 such that βiη can be computed by ri within one step by assuming M. Therefore, αη can be computed by the following rule rwithin one step (note that (cid:2)k is normalized for all k).∗Head(rP os(r∗) = Head(r),∗) = P os(r)\{βi1 , . . . , βin∪ P os(rn)θn,} ∪ P os(r1)θ1 ∪ . . .Neg(r∗) = Neg(r) ∪ Neg(r1)θ1 ∪ · · · ∪ Neg(rn)θn,where βi1 , . . . , βin are the atoms discussed above, and ri and θi are defined accordingly. This shows that Q (a1, . . . , an) ∈M1t ((cid:2)t).We now prove M1((cid:2)t) ⊆ Mt((cid:2)). Suppose that Q (a1, . . . , an) can be computed from (cid:2)t within one step by assum-∗ ∈ (cid:2)t , and an assignment η such that ing M, where Q is an intensional predicate of (cid:2). Then there exists a rule rHead(r∗)η = Q (a1, . . . , an). Suppose that rhas the form∗Head(rP os(r∗) = Head(r),∗) = P os(r)\{βi1 , . . . , βin∪ P os(rn)θn,} ∪ P os(r1)θ1 ∪ . . .Neg(r∗) = Neg(r) ∪ Neg(r1)θ1 ∪ · · · ∪ Neg(rn)θn,where r ∈ (cid:2), ri ∈ (cid:2)t−1, and the others are defined accordingly. Then, βi j η can be computed from ri within one step by assuming M. So βi j η ∈ Mt−1((cid:2)) by induction assumption. Consequently, αη ∈ Mt((cid:2)) since it can be computed through rule r. (cid:2)Now we show that every k-bounded program (cid:2) is equivalent to a 1-bounded program, more precisely, (cid:2)k.Lemma 2. If (cid:2) is a k-bounded program, then (cid:2) is equivalent to (cid:2)k, which is a 1-bounded program.Proof. We first show that (cid:2) is equivalent to (cid:2)k by proving that for any structure M, M∞((cid:2)) = M∞((cid:2)k). Clearly, M∞((cid:2)) ⊆ M∞((cid:2)k) since (cid:2) ⊆ (cid:2)k. It suffices to show that M∞((cid:2)k) ⊆ M∞((cid:2)). We prove this by induction that for any natural number t, Mt ((cid:2)k) ⊆ M∞((cid:2)). The induction basis follows from Lemma 1. Suppose that it holds for all natural numbers less than t, now we prove the case for t. Let Q (a1, . . . , an) be a ground atom in Mt ((cid:2)k) but not in Mt−1((cid:2)k). If it is obtained from a rule in (cid:2) itself together with an assignment, then the inductive step holds obviously. Otherwise, there ∗)η = Q (a1, . . . , an) and its body can be applied at the current exists a rule revaluation stage. Suppose that r∗ ∈ (cid:2)k, and an assignment η such that Head(rhas the form∗Head(rP os(r∗) = Head(r),∗) = P os(r)\{βi1 , . . . , βin∪ P os(rn)θn,Neg(r∗) = Neg(r) ∪ Neg(r1)θ1 ∪ · · · ∪ Neg(rn)θn,Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7975} ∪ P os(r1)θ1 ∪ . . .where r ∈ (cid:2), ri ∈ (cid:2)t−1, and the others are defined accordingly. Notice that the negative parts are irrelevant here as they are fixed by M. Considering the positive parts, for all i, 1 ≤ i ≤ n, P os(ri)θi ⊆ Mt−1((cid:2)k). By the induction hypothesis, P os(ri)θi ⊆ M∞((cid:2)). This shows that, for all i, 1 ≤ i ≤ n, βiη ∈ M∞((cid:2)). It follows that for the rule rη, P os(r)η ⊆ M∞((cid:2)). Therefore, Head(r)η ∈ M∞((cid:2)). Hence, Q (a1, . . . , an) ∈ M∞((cid:2)).We now show that (cid:2)k is a 1-bounded program. If M is a stable model of (cid:2)k, then M is a stable model of (cid:2) as well. In addition, M∞((cid:2)k) = M = M∞((cid:2)) = Mk((cid:2)) = M1((cid:2)k) (by Lemma 1). This shows that (cid:2)k is 1-bounded. (cid:2)We now show that every 1-bounded program is equivalent to a recursion-free program. For this purpose, we decompose this task into two steps. We first show that a 1-bounded program is equivalent to a program with only non-recursive rules and constraints, and then show that constraints can be eliminated into non-recursive rules as well.Constraints are of the same as normal rules of the form (1) except that the head is empty instead of an atom. More precisely, a constraint is of the form← β1, . . . , βm, not γ1, . . . , not γl.Let r be a constraint of the form (10). By (cid:2)r, we denote the first-order formula¬(β1 ∧ · · · ∧ βm ∧ ¬γ1 ∧ · · · ∧ ¬γl).(10)Let (cid:2) be a program and C a set of constraints. A first-order structure M is a stable model of (cid:2) ∪ C if it is a stable model of (cid:2) and for all c ∈ C , M |=(cid:2)c.Here, we use constraints to help us to prove that any 1-bounded program can be equivalently transformed into a recursion-free program. First, we show that any 1-bounded program can be equivalently transformed into a recursion-free program with constraints. Let r be a rule of the form (1), by rC , we denote the constraint← β1, . . . , βm, not γ1, . . . , not γl, not α.Let (cid:2) be a program. By (cid:2)C , we denote the program obtained from (cid:2) by replacing every recursive rule r with rC .Lemma 3. If (cid:2) is a 1-bounded program, then (cid:2) is equivalent to (cid:2)C .Proof. First of all, we split the program (cid:2)C into two parts, namely (cid:2)N R that contains all non-recursive rules in (cid:2) and (cid:2)RC that contains all constraints obtained from recursive rules in (cid:2). Then, a stable model of (cid:2)C is a stable model of (cid:2)N Rthat satisfies all constraints in (cid:2)RC , which is a stable model of (cid:2)N R that satisfies (cid:2)(cid:2). In addition, a structure M is a stable model of (cid:2)N R iffQ (• for all ground atoms Q (−→a ) ∈ M, there exist a non-recursive rule r ∈ (cid:2) and an assignment η such that Head(r)η =−→a ) and M |= Body(r)η;−→a ) /∈ M, there do not exist a non-recursive rule r ∈ (cid:2) and an assignment η such that −→a ) and M |= Body(r)η.• for all ground atoms Q (Head(r)η = Q (On one side, suppose that M is a stable model of (cid:2). Since (cid:2) is 1-bounded, we have M = M1((cid:2)). Hence, M is a stable model of (cid:2)N R as M1((cid:2)) satisfies the two conditions mentioned above (according to the definition of the evaluation stage). In addition, M |= (cid:2)(cid:2) since M is a stable model of (cid:2). Hence, M is a stable model of (cid:2)C .On the other side, suppose that M is a stable model of (cid:2)C . Since M is a stable model of (cid:2)C thus (cid:2)N R , M1((cid:2)) = M. −→a ) in M∞((cid:2))Now assume that M is not a stable model of (cid:2). Then, M ⊂ M∞((cid:2)). There exists a ground atom Q (−→a ) in M2((cid:2)) but not in M1((cid:2)) (which is the same as M). Otherwise, if but not in M. In fact, there exists such a Q (−→M2((cid:2)) = M1((cid:2)), then M = M1((cid:2)) = M2((cid:2)) = M3((cid:2)) = · · · = M∞((cid:2)), a contradiction. Now suppose that Q (a ) is −→a ) = Head(r)η. Then, derived by a rule r together with an assignment η in the second step of the evaluation stage and Q (M |= Neg(r)η, and M1((cid:2)) |= P os(r)η. Therefore, M |= Body(r)η since M = M1((cid:2)). It follows that M |= Head(r)η. This shows that Q (−→a ) ∈ M, a contradiction. (cid:2)Next, we show that recursion-free programs with constraints can always be equivalently transformed into recursion-free programs. Let (cid:2) be a recursion-free program and c a constraint of the form (10). Suppose that all the rules in (cid:2) whose head is βi, 1 ≤ i ≤ m areβi ← Bodyi1,. . . ,βi ← Bodyibi ,76Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79and all the rules in (cid:2) whose head is γ j, 1 ≤ j ≤ l areγ j ← Body j1,. . . ,γ j ← Body jc j .Here, Bodyik, 1 ≤ k ≤ bi (Body jl, 1 ≤ l ≤ c j ) is a body without positive intensional atoms since (cid:2) is a recursion-free program.By (cid:2) ⊕ c, we denote the program obtained from (cid:2) by replacing each βi ← Bodyk, i1 ≤ k ≤ ibi with the following set (*) of rulesβi ← not β1, Bodyk,. . . ,βi ← not βm, Bodyk,βi ← Body11, Bodyk,. . . ,βi ← Body1c1 , Bodyk,βi ← Body21, Bodyk,. . . ,βi ← Body2c2 , Bodyk,. . . ,βi ← Bodyl1, Bodyk,. . . ,βi ← Bodylcl , Bodyk.Lemma 4. If (cid:2) is a recursion-free program and c a constraint with at least one positive atom, then (cid:2) ∪ {c} is equivalent to (cid:2) ⊕ c.Proof. Suppose that M is a stable model of (cid:2) ∪ {c}. Then, M is stable model of (cid:2) and M |=(cid:2)c. Then, for any assignment η, there are two cases.Case 1:Case 2:There exists βi, 1 ≤ i ≤ m such that M (cid:10)|= βiη. In this case, consider any β jη, 1 ≤ j (cid:10)= i ≤ m. Clearly, if β jη /∈ M, then β jη /∈ M1((cid:2) ⊕ c) according to the construction of the rule set (*). On the other side, if β jη ∈ M, then there exists a rule in (cid:2) of the form β j ← Body jk, 1 ≤ jk ≤ jb j such that M |= Body jkη. Then, M |= [Body jk ∪ {¬βi}]η. Then, β jη is in M1((cid:2) ⊕ c) since it is justified by the rule β j ← not βi, Body jk in the rule set (*).There exists γ j, 1 ≤ j ≤ l such that M |= γ jη. In this case, there exists a rule of the form γ j ← Body jk, 1 ≤ k ≤ c jsuch that M |= Body jkη. Similarly, consider any βiη, 1 ≤ i ≤ m. Again, if βiη /∈ M, then βiη /∈ M1((cid:2) ⊕ c). If βiη ∈ M, then there exists a rule in (cid:2) of the form βi ← Bodyis, 1 ≤ is ≤ ibi such that M |= Bodyisη. Then, βiη is in M1((cid:2) ⊕ c) since it is justified by the rule βi ← Body jk, Bodyis in the rule set (*).In addition, for all other atoms α not in the positive body of c, (cid:2) and (cid:2) ⊕ c have the same set of rules whose head is α. This shows that for all ground atoms, it is in M iff it is in M1((cid:2) ⊕ c). It follows that M is a stable model of (cid:2) ⊕ c as (cid:2) ⊕ c is a recursion-free program.Suppose that M is a stable model of (cid:2) but does not satisfy c. Then, there exists an assignment η such that for all βi , 1 ≤ i ≤ m, βiη ∈ M and for all γ j , 1 ≤ j ≤ l, γ jη /∈ M. We use contradiction to prove that M is not a stable model of (cid:2) ⊕ c. Otherwise, β1η ∈ M1((cid:2) ⊕ c), there exists a rule in (*) that justifies β1η when i = 1. It cannot be of the form β1 ← not β j, Bodyk since β jη ∈ M. Suppose that it is of the form β1 ← Bodyi j, Bodyk. Then, M |= Bodyi jη. It follows that M |= γiη because of the rule γi ← Bodyi j is in (cid:2), a contradiction. This shows that M is not a stable model of (cid:2) ⊕ c.Finally suppose that M is not a stable model of (cid:2). Then there are two cases:Case 1:Case 2:There exists a ground atom that is in M but not in M1((cid:2)). In this case, this ground atom is not in M1((cid:2) ⊕ c)either according to the construction of the rule set (*).There exists a ground atom that is in M1((cid:2)) but not in M. If this atom is not in the positive body of c, then it is in M1((cid:2) ⊕ c) as well. Hence, M is not a stable model of (cid:2) ⊕ c. Suppose that it is of the form βiη, 1 ≤ i ≤ m. Since it is in M1((cid:2)), there exists a rule of the form βi ← Bodyk such that M |= Bodykη. Hence, M |= [Bodyk ∪ {¬βi}]ηY. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7977as βiη /∈ M. Therefore, βiη ∈ M1((cid:2) ⊕ c) as it is justified by the rule βi ← not βi, Bodyk. It follows that M is not a stable model of (cid:2) ⊕ c.No matter which case is, M is not a stable model of (cid:2) ⊕ c.This shows that (cid:2) ∪ {c} is equivalent to (cid:2) ⊕ c. (cid:2)Corollary 10. If (cid:2) is a recursion-free program and C a set of constraints, then (cid:2) ∪ C is equivalent to a recursion-free program.Proof. Note that for eliminating constraints ← not γ1, . . . , not γl without positive body, one only needs to convert it to a non-recursive rule γ1 ← not γ1, . . . , not γl. The assertion follows from Lemma 4 and this fact since constraints can be eliminated one-by-one. That is, for a constraint c and a set of constraints C , M is a stable model of (cid:2) ∪ C ∪ {c} iff M is a stable model of (cid:2) ∪ {c} and M satisfies C iff M is a stable model of (cid:2) ⊕ c and M satisfies C . (cid:2)Finally, we are able to prove Proposition 9.Proof of Proposition 9. Proposition 9 follows from Lemmas 2 and 3 and Corollary 10. (cid:2)Theorem 2. Let (cid:2) be a program. The following four statements are equivalent on arbitrary structures.1. (cid:2) is bounded.2. (cid:2) is equivalent to a recursion-free program.3. (cid:2) is equivalent to a loop-free program.4. (cid:2) is first-order definable.Here, we prove 4 ⇒ 1 for Theorem 2.For this purpose, we need to introduce some background knowledge and results on least fixed-point logic. Let τ be a −→vocabulary and P a new predicate not in τ with the arity n. Let φ(x is the tuple of all free variables in φ with length n, and P only occurs positively in φ (i.e. every occurrence of P in φ is in the scope −→of even numbers of negations4). Given a structure A of τ , the formula φ(x , P ) defines an operator (cid:15)(T ) from an n-ary relation to an n-ary relation on Dom(A):−→x , P ) be a first-order formula, where (cid:15)(T ) = {−→a ∈ Dom(A)n : A |= φ(−→x /−→a , T )}.Starting from the empty set, (cid:15) gives rise to a sequence of n-ary relations as follows:−→x , P ) = ∅;−→x , P ) = (cid:15)((cid:15)0((cid:15)t((cid:7)−→x , P )).(cid:15)r(r<t−→x , P ) = (cid:15)t(Since P only occurs positively in φ, the sequence (cid:15)1(ordinal k such that (cid:15)k(least fixed-point T 0 in the sense that (cid:15)(T 0) = T 0 and for every T such that (cid:15)(T ) = T , T 0 ⊆ T . We use (cid:15)∞(the least fixed point of (cid:15).−→x , P ) in the sense that for any −→x , P ) (φ∞−→x , P ), . . . always increases. Thus, there exists a least −→x , P ), where t > k. Since P occurs positively in φ, the operator (cid:15) has a −→x , P ) to denote −→a , P ) iff for short) to denote the the least fixed-point −→a ∈ Dom(A)n, A |= φt(This defines a corresponding iterative formula φt (−→x /−→x , P ).−→−→x , P ); A |= φ∞(a ∈ (cid:15)t(formula obtained from φ(−→x , P ). We write φ∞(−→x , P ), . . . , (cid:15)t(−→x , P ) = (cid:15)∞(−→a , P ) iff −→a ∈ φ∞(−→x /A fixed-point query is a formula in fixed-point logic that defines a global relation. More precisely, let φ(x1, . . . , xn) be a formula in fixed-point logic of vocabulary τ , where x1, . . . , xn are all the free variables in φ. We say that φ(x1, . . . , xn)expresses an n-ary global relation of τ if for every structure A of τ , φ(x1, . . . , xn) yields the following n-ary relation on Dom(A):{(a1, . . . , an) | A |= φ(a1, . . . , an)}.The notion of definability and boundedness can be defined for least fixed-point logic as well. Let K be a class of −→y is the tuple of all free variables in ψ with length n, of τ defines−→y ), where τ -structures. We say that a formula ψ(−→the fixed-point φ∞(x , P ) on K iff for every A ∈ K and every −→−→−→a , P ) iff A |= ψ(a ).x /(A |= φ−→y /∞−→a ∈ Dom(A)n,4 Here we assume that φ is constructed only from connectives of ¬, ∧ and ∨, while → and ↔ are defined in terms of ¬, ∧ and ∨.78Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–79We say that the least-fixed point formula φ∞(−→a ∈ Dom(A)n, A |= φ∞(all A ∈ K and every −→x , P ) is bounded on K if there exists a fixed natural number k such that for −→x /−→a , P ) iff A |= φk(−→a , P ).−→x /Barwise and Moschovakis [11] revealed the important correspondence between definability and boundedness on arbitrary structures in least fixed-point logic.Lemma 5. [11] Let K be a class of τ -structures which is first-order finitely axiomatizable.5 A least fixed-point formula is bounded on K iff it is defined by a first-order formula on K.We shall prove 4 ⇒ 1 based on Lemma 5. The basic ideas are divided into two steps. First, we show that for each program, we can construct a program with a single intensional predicate to simulate the original program. Then we show that each program with a single intensional predicate can be translated to an equivalent fixed-point formula.Let (cid:2) be a program. Let {P 1, . . . , P n} be the set of intensional predicates of (cid:2). Suppose that k is the maximal arity among all P i, (1 ≤ i ≤ n). Let 0, 1, . . . , n be n + 1 distinguishable new constants. Construct a new predicate P whose arity is −→k + 1. Let (cid:2)S be the program obtained from (cid:2) by simultaneously replacing each atom P i(ti , 0, . . . , 0, i), −→ti |. We show that (cid:2)S simulates (cid:2).where the number of occurrences of 0 is equal to k − |−→ti ) in (cid:2) with P (Lemma 6. Let (cid:2) be a program and (cid:2)S be the program constructed above. Let M be a structure of τ ((cid:2)). We construct a structure MS on τext((cid:2)) ∪ {P } such that• the domain of MS is M ∪ {0, 1, . . . , n};• for all extensional predicates Q of (cid:2), QM• for all constants c in (cid:2), c• for all intensional predicates P i , P i(MS = cMS = QM;;−→a ) ∈ M iff P (−→a , 0, . . . , 0, i) ∈ MS .Then, for any integer k, P i, and −→a that matches the arity of P i, P i(−→a ) ∈ Mk((cid:2)) iff P (−→a , 0, . . . , 0, i) ∈ (MS )k((cid:2)S ).Proof. This assertion follows from the constructions and definitions by induction on k. (cid:2)Lemma 6 shows that (cid:2)S can simulate (cid:2) in the sense that every intensional atom P i(intensional atom P (−→ti , 0, . . . , 0, i) in (cid:2)S .Now we show that each program with a single intensional predicate can be equivalently transferred into a fixed-point formula on a class of axiomatizable structures. Let (cid:2) be a program that only contains a single intensional predicate, say P . be a new predicate that has the Then, all the heads of rules in (cid:2) are of the form P (by two steps: (1) construct a program same arity as P . Let ψ((cid:2), P−→∗) be the (cid:2)∗t ), (2) let ψ((cid:2), P∗) is a first-order formula of the formula vocabulary τ ((cid:2)) ∪ {P−→x ) since (cid:2) is normalized. Let P∗) be the first-order formula obtained from (cid:2) and P−→y is the set of local variables in rule r. Clearly, ψ((cid:2), P−→x are all the free variables.−→t ) in the negative bodies of any rules in (cid:2) with P∗}, where P only occurs positively and by replacing every occurrence of P (−→y (cid:2)Body(r), where r∈(cid:2)∗ ∃∗((cid:10)∗∗Let M be a τ ((cid:2))-structure. By M∗, we denote the structure of the vocabulary τ ((cid:2)) ∪ {P∗} such that−→ti ) in (cid:2) is associated with the • Dom(M∗) = Dom(M);−→−→a ) ∈ M∗• for all a , P• the interpretations of all constants and other predicates are the same as those in M.−→a ) ∈ M;iff P (∗(Proof. If (cid:2) is defined by the first-order sentence φ, then K is axiomatized by the first-order sentence φ ∧ ∀P−→x )). (cid:2)∗(−→x (P (−→x ) ↔The fixed-point formula ψ((cid:2), Pfollowing lemma holds.∗)∞(−→x , P ) simulates the program (cid:2) on all stable models of (cid:2). By induction on k, the Lemma 7. Let (cid:2) be a program that has a single intensional predicate P , and M a stable model of τ ((cid:2)). Suppose that ψ((cid:2), P−→M∗a , P (are constructed as above. Then, for any integer k and any −→a ) ∈ Mk((cid:2)) iff −→a ∈ ψ((cid:2), P−→x , P ).∗)k(∗) and Lemma 7 shows that (cid:2)∗can simulate (cid:2) on the class of structures K. Consequently, the answer set program (cid:2) can be simulated by the fixed-point formula (cid:9)(cid:2)∗ on K. Together with Lemma 5, we can finally prove Theorem 2 in this paper.We finish the proof of Theorem 2 as follows.5 That is, there exists a first-order sentence φ on τ whose models are exactly captured by K.Y. Zhou, Y. Zhang / Artificial Intelligence 250 (2017) 58–7979Proof of Theorem 2. We only need to prove 4 ⇒ 1. From Lemma 6, it suffices to prove the case in which the program only contains a single intensional predicate. Let (cid:2) be such a program, which has a single intensional predicate P and is defined −→−→−→by a first-order sentence φ. Let K = {M∗ | M ∈ A S((cid:2))}. Then, K is first-order axiomatized by φ ∧ ∀∗(x ) ↔ Px )). By x (P (∗(x), where φ∗is obtained from Lemma 7, the fixed-point formula ψ((cid:2), P−→∗)∞(φ by simultaneously replacing each occurrence of P (x , P ) is bounded on K. Again, by Lemma 7, (cid:2) is bounded. (cid:2)−→x , P ) on K is defined by the formula φ∗ ∧ P−→t ). Then, by Lemma 5, ψ((cid:2), P−→t ) with P∗)∞(∗(References[1] Serge Abiteboul, Richard Hull, Victor Vianu, Foundations of Databases, Addison-Wesley, 1995.[2] Miklós Ajtai, Yuri Gurevich, Datalog vs first-order logic, J. Comput. Syst. Sci. 49 (3) (1994) 562–588.[3] Vernon Asuncion, Yin Chen, Yan Zhang, Yi Zhou, Ordered completion for logic programs with aggregates, Artif. Intell. 224 (2015) 72–102.[4] Vernon Asuncion, Fangzhen Lin, Yan Zhang, Yi Zhou, Ordered completion for first-order logic programs on finite structures, Artif. Intell. 177–179 (2012) 1–24.[5] Vernon Asuncion, Yan Zhang, Yi Zhou, Ordered completion for logic programs with aggregates, in: AAAI-2012, 2012, pp. 691–697.[6] Chitta Baral, Knowledge Representation, Reasoning and Declarative Problem Solving, Cambridge University Press, 2003.[7] Michael Bartholomew, Joohyung Lee, Functional stable model semantics and answer set programming modulo theories, in: IJCAI 2013, 2013.[8] Michael Bartholomew, Joohyung Lee, On the stable model semantics for intensional functions, Theory Pract. Log. Program. 13 (4–5) (2013) 863–876.[9] Michael Bartholomew, Joohyung Lee, Stable models of multi-valued formulas: partial versus total functions, in: Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR 2014, Vienna, Austria, July 20–24, 2014, 2014.[10] Michael Bartholomew, Joohyung Lee, Yunsong Meng, First-order extension of the FLP stable model semantics via modified circumscription, in: IJCAI-2011, 2011, pp. 724–730.[11] J. Barwise, Y. Moschovakis, Global inductive definability, J. Symb. Log. 43 (1978) 521–534.[12] Yin Chen, Fangzhen Lin, Yisong Wang, Mingyi Zhang, First-order loop formulas for normal logic programs, in: Proceedings, Tenth International Confer-ence on Principles of Knowledge Representation and Reasoning, Lake District of the United Kingdom, June 2–5, 2006, 2006, pp. 298–307.[13] Yin Chen, Fangzhen Lin, Yan Zhang, Yi Zhou, Loop-separable programs and their first-order definability, Artif. Intell. 175 (3–4) (2011) 890–913.[14] Keith L. Clark, Negation as failure, in: Logics and Databases, 1978, pp. 293–322.[15] Marc Denecker, Yuliya Lierler, Miroslaw Truszczynski, Joost Vennekens, A Tarskian informal semantics for answer set programming, in: ICLP 2012, 2012, pp. 277–289.(1993) 683–713.[16] Heinz-Dieter Ebbinghaus, Jörg Flum, Finite Model Theory, Perspectives in Mathematical Logic, Springer, 1995.[17] François Fages, Consistency of Clark’s completion and existence of stable models, Meth. of Logic in CS 1 (1) (1994) 51–60.[18] Paolo Ferraris, Joohyung Lee, Vladimir Lifschitz, Stable models and circumscription, Artif. Intell. 175 (1) (2011) 236–263.[19] Haim Gaifman, Harry G. Mairson, Yehoshua Sagiv, Moshe Y. Vardi, Undecidable optimization problems for database logic programs, J. ACM 40 (3) [20] Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Torsten Schaub, Answer Set Solving in Practice, Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan & Claypool Publishers, 2012.and Symposium, MIT Press, 1988, pp. 1070–1080.[21] Michael Gelfond, Vladimir Lifschitz, The stable model semantics for logic programming, in: Proceedings of International Logic Programming Conference [22] Michael Gelfond, Vladimir Lifschitz, Classical negation in logic programs and disjunctive databases, New Gener. Comput. 9 (3/4) (1991) 365–386.[23] Georg Gottlob, André Hernich, Clemens Kupke, Thomas Lukasiewicz, Stable model semantics for guarded existential rules and description logics, in: Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR 2014, Vienna, Austria, July 20–24, 2014, 2014.[24] Amelia Harrison, Vladimir Lifschitz, David Pearce, Agustín Valverde, Infinitary equilibrium logic and strongly equivalent logic programs, Artif. Intell. [25] Tomi Janhunen, Ilkka Niemela, Compact translations of non-disjunctive answer set programs to propositional clauses, in: Logic Programming, Knowl-edge Representation, and Nonmonotonic Reasoning – Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday, 2011, pp. 111–130.[26] Joohyung Lee, Yunsong Meng, First-order stable model semantics and first-order loop formulas, J. Artif. Intell. Res. 42 (2011) 125–180.[27] Yuliya Lierler, cmodels – SAT-based disjunctive answer set solver, in: Logic Programming and Nonmonotonic Reasoning, 8th International Conference, LPNMR 2005, Diamante, Italy, September 5–8, 2005, Proceedings, 2005, pp. 447–451.[28] Vladimir Lifschitz, Logic programs with intensional functions, in: Principles of Knowledge Representation and Reasoning: Proceedings of the Thirteenth International Conference, KR 2012, Rome, Italy, June 10–14, 2012, Springer, 2012.[29] Fangzhen Lin, Yoav Shoham, A logic of knowledge and justified assumptions, Artif. Intell. 57 (2–3) (1992) 271–289.[30] Fangzhen Lin, Yuting Zhao, ASSAT: computing answer sets of a logic program by SAT solvers, Artif. Intell. 157 (1–2) (2004) 115–137.[31] Fangzhen Lin, Yi Zhou, From answer set logic programming to circumscription via logic of GK, Artif. Intell. 175 (1) (2011) 264–277.[32] David Maier, Jeffrey D. Ullman, Moshe Y. Vardi, On the foundations of the universal relation model, ACM Trans. Database Syst. 9 (2) (1984) 283–308.[33] Victor W. Marek, Miroslaw Truszczynski, Stable models and an alternative logic programming paradigm, in: The Logic Programming Paradigm: A 25-Year Perspective, Springer-Verlag, 1999, pp. 375–398.[34] Ilkka Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Ann. Math. Artif. Intell. 25 (3–4) (1999) 241–273.[35] Robert Nieuwenhuis, Albert Oliveras, Cesare Tinelli, Solving SAT and SAT modulo theories: from an abstract Davis–Putnam–Logemann–Loveland proce-dure to DPLL(t), J. ACM 53 (6) (1999) 937–977.[36] David Pearce, Agustín Valverde, Towards a first order equilibrium logic for nonmonotonic reasoning, in: JELIA’2004, 2004, pp. 147–160.[37] Raymond Reiter, A logic for default reasoning, Artif. Intell. 13 (1–2) (1980) 81–132.[38] Yi-Dong Shen, Kewen Wang, Thomas Eiter, Michael Fink, Christoph Redl, Thomas Krennwallner, Jun Deng, FLP answer set semantics without circular justifications for general logic programs, Artif. Intell. 213 (2014) 1–41.[39] Heng Zhang, Yan Zhang, First-order expressibility and boundedness of disjunctive logic programs, in: IJCAI 2013, 2013.[40] Yan Zhang, Yi Zhou, On the progression semantics and boundedness of answer set programs, in: KR 2010, 2010.[41] Yi Zhou, First-order disjunctive logic programming vs normal logic programming, in: Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence, IJCAI 2015, Buenos Aires, Argentina, July 25–31, 2015, 2015, pp. 3292–3298.[42] Yi Zhou, Yan Zhang, Progression semantics for disjunctive logic programs, in: AAAI 2011, 2011.246 (2017) 22–33.