ELSEVIER Artificial Intelligence 92 (1997) 25-89 Artificial Intelligence Clause trees: a tool for understanding and implementing resolution in automated reasoning J.D. Horton *, Bruce Spencer ’ University of New Brunswick, Fredericron, New Brunswick, Cunada E3B 5A3 Received July 1995; revised November 1996 Abstract structure, is developed in first order for automated A new methodology/data the clause logic. A clause tree, tree T on a set S of clauses reasoning is a 4-tuple based on resolution (N, E, L, M), where N is a set of nodes, divided into clause nodes and atom nodes, E is a set of edges, each of which joins a clause node to an atom node, L is a labeling of N U E which assigns to each clause node a clause of S, to each atom node an instance of an atom of some clause of S, and to each edge either + or - . The edge joining a clause node to an atom node is labeled by the sign of the corresponding two atom literals. The merge of two identical nodes of different clause trees which represent complementary atom nodes into the set M literals is represented by placing leaf, while the head remains of chosen merge paths. The tail of the merge path becomes a closed an open leaf which can be resolved on. The clause cl(T) is the set of literals to the labels of the open leaves modified by the signs of the incident edges. The corresponding fundamental from S using resolution. literal in the clause. A resolution that cl(T) can be derived is represented by unifying the two corresponding purpose of a clause tree T is to show that T represents the path joining Loveland’s model elimination ME, the selected literal procedure SL, and Shostak’s graph trees. The condition procedure GC are explained construction required for choosing a merge path whose head is not a leaf is given. This allows a clause tree to be built in one way (the build ordering) but justified as a proof in a unified manner using clause The ordered clause set restriction trees of merge path on clause ideas from ME, GC and Spencer’s ordered clause set restriction tighter than any of the top down procedures above, and the foothold score restriction reversal. A new procedure in another (the proof ordering). the are explained using called ALPOC, which (OC), to form a new is developed and shown to be sound operation combines procedure and complete. * Corresponding author. E-mail: jdh@unb.ca. ’ E-mail: bspence@unb.ca. 0004-3702/97/$17.00 PII SOOO4-3702(96)00046-X 0 1997 Elsevier Science B.V. All rights reserved 26 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 clause tree. Any non-minimal Another operation on clause trees called surgery that non-minima1 clause trees are redundant. A sound procedure MinALPOC clause thereby showing produces only minima1 clause trees is given. Mergeless clause trees are shown to be equivalent each of input resolution, unit resolution some known results. Many other new proof procedures using clause leaving many open questions. 0 1997 Elsevier Science B.V. to define a minima1 to a minima1 clause tree using surgery, that to thereby giving short proofs of trees are discussed briefly, and relative Horn sets, tree can be reduced is defined, and used Keywords: Automated theorem proving; Redundancy; Minimality; Proof procedures 1. Introduction reasoning is the disjunction that one wants using binary resolution. Starting over a set of literals, one applies the that one the result is usually is found. This clause the most common method starts by negating for a contradiction. In this paper a clause is represented This paper is concerned with automated the clause with a set of clauses, each of which to them until resolution empty clause, because wants to prove, and then looking in graph by a tree to atom nodes each of which connected labeling clause, a or -a, which atom node an atom node can correspond the clause node. Fig. terms. An theory input clause is represented is labeled by an atom. However to either a positive or negative by a clause node the atom a in the the the clause literal the edge joining is indicated by a + or - to shows -d}. Such a tree is called a clause tree. l(a) sign labeling tree the representing {a, 6, -c, literals the clause (a, b, -c, resolution. For example Clauses can be combined using trees also can be resolved, the from two different clauses, as shown -d} -d, e, -g] upon b to form the new clause {a, -c, that identifying leaf nodes in Fig. l(b). The tree are the literals of the resulting clause. But two of the leaves the union of -d the two atom nodes to the same literal can be joined with a merge path as in Fig. l(c). The to be a literal of the can resolve with the clause {-b, e, -g}. Clause -4 represent complementary leaves of the resulting are labeled by -d. The merging of the two literals two sets occurs, is not handled automatically that correspond literal at the corresponding tail of a merge path clause. by clause trees. Instead that occurs when considered longer is no by (a) (b) Fig. 1. Example clause trees. J.D. Horton, B. Spencer/Artificial intelligence 92 (1997) 25-89 27 la, b, cl \ la, 4, dl / \ / \ / la, c, 4 \ \ l-a, dJ / / /c. dl (4 la, 4, 4 \ \ \ I I-a, 4 / / I-b, di \ /a, b. cl / ;. c, d; @I Fig. 2. Two different results from resolutions on the same clauses. In ordinary resolution with clauses represented by sets, the order in which a sequence of resolutions is done can have a significant impact on the result. For example suppose we have the clauses {a, b, c), {a, -6, d}, and {-a, d}. Resolving between the first two clauses on b produces {a, c, d}, and then resolving the result with the third clause on a produces {c, d}. See Fig. 2(a). However, if we begin by resolving between the second and third clause on a producing {-b, dj and then resolve with the first clause on b, we obtain the inferior result {a, c, d). See Fig. 2(b). Fig. 3 shows the same sequences of resolutions as Fig. 2, but using clause trees instead of sets to represent the clauses. Leaves with the same label are merged as soon as they are connected by a path. However the tree on the bottom of Fig. 3(b) can be improved by choosing a merge path from the open leaf labeled u to the internal node with the same label. Thus the inferior result is improved to yield a clause tree whose clause is {c, d}. If clause trees are used it does not matter in which order the resolutions b \ / b +d A \ a+- a \ ‘h, / a+ +c -T t / b \ \ / / +c a+ -?-- t b Fig. 3. Clause trees from Fig. 2. 28 J.D. Horton, B. Spencer/Artijicinl Intelligence 92 (1997) 25-89 are done, as the resulting corresponds to two different clause tree can be made the same. Hence the clause tree searches. between in which the clause is presented how clause trees distinguish Fig. 3 illustrates in an ordinary tree is constructed the order the resolution proof ( proof ordering), and the resolutions must be performed tree (build ordering). The final clause in which order the build ordering of Fig. 3(b) but is justified by the proof ordering could be built using in Section 3.1 where we present a way of Fig. 3(a). A more general example procedure, ME, in which the proof ordering of looking at the (weak) model elimination are required is different of the procedure. with ancestor clauses, as would be required In a manner similar These ancestor resolutions in build to MESON literal SL ordering. These procedure [29] respectively. Using clause trees, it is easily seen that GC is a restriction of a variant of SL, and that SL is a restriction of ME. In the proof ordering no resolutions in the usual justification [16] and Shostak’s graph construction GC procedure in Sections 3.3 and 3.4 to the selected [21], ancestor merges correspond to the insertion of merge paths are replaced by merges ideas are extended the build ordering. in proof ordering. from Section 4 develops the new concepts of visibility and support, which are relations between nodes of clause trees. The results of this paper rest on these relations. Section 5 shows that merge paths between nodes can be reversed, and that this does not essentially change relation. the visibility the foothold score restriction It also adapts the ordered clause set restriction [32] to clause [30,31] and trees. proof procedures its result more general. As shown A theorem prover can take advantage of the internal nodes of a clause basic ways. It can improve a proof, making an internal merge path can be chosen, resolution-based that tautologies be avoided. Since a clause tree represents detect if any one of those proofs contains a tautology or misses an opportunity literals. The operation clause tautologies hence tree that subsumes surgery cannot be applied are said to be minimal. tree in two in Fig. 3, to remove a literal. But more can be done. Most that merges be done wherever possible and several distinct proofs, we can to merge these internal tree, and to which and unused merges by cutting out some branches of the clause trees finds a smaller clause in Section 6, removes tree surgery, defined the original. Clause require Section 7 introduces ALP and AllPaths, trees. Using clause arises by reordering instance, each of these procedures clause set restriction. Moreover, avoided. As a stronger ALPOC produces only minimal trees, a theorem prover can avoid building steps, and so can avoid the resolution for building top down procedures clause tree that searching. For in Section 7 can be further restricted by the ordered can also be the procedure Min- tree that contains redundant the same clause redundant a tautology search, any clause example of avoiding clause trees. clause clause trees without merge paths, and shows Section 8 investigates clauses admits a mergeless refutation, that is a relative Horn set that is unsatisfiable. Although three concepts are equivalent, concept provide examples of using clause reasoning with resolution. that a set of if it admits an input if and only if it admits a unit refutation, and if and only if it contains a subset that the latter to the first automated is equivalent and understand the complete proofs trees to investigate it is well known tree refutation, if and only that each J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 29 trees differ from the structures defined by Eisinger [S] with the same Our clause name, although the concepts are closely related. to connection Clause trees are closely trees, whereas clause related tableaux [17]. Tableaux however are to adding a clause trees are unrooted. The operation of tableau expansion tree. tree with only one clause node trees can resolve with other clause trees that have more than one clause node, but rooted corresponds Clause this is not the case in tableaux. Choosing merge paths in a rooted clause tree corresponds folding up and folding to several different operations left hooks for down. In particular, we identify ancestor paths for reduction operations, factoring tableaux calculi defined up in addition (folding up). Also all connection trees can be built bottom (folding down) and left paths for c-reductions in [17] are top down, whereas clause to top down [13,14]. to another clause in tableaux: reduction, tableau 2. Definitions some substitution to be universally from first order clausal We use the standard definitions 0 such that C, 8 C C,. A substitution quantified. A substitution maps variables is the result of applying logic, as in [6] or [21]. An atom is an atomic formula. A literal is an atom a or the negation wu of an atom. The complement -b of a literal b is the negation of b if b is an atom, and the atom of b in a clause are otherwise. A clause is a set of literal& possibly empty. All variables to terms. An assumed instance of a literal or clause to its variables. A ground instance is one with no variables. A clause C, subsumes a clause C, if there 0 unifies two literals b, and b, if is a substitution b, 8 = b, 8. A most general unifier 8 of two literals b, and b, is one such that for each that b, U= (b, 8)p. An unifier u of b, and b, interpretation of a set of clauses consists of a non-empty to to each each n-place a set S = n-place instance {C , , . . . , C,} of clauses and an interpretation to true by I. A model of S is S’={C{,..., is satisfiable if there exists a model of an interpretation it. S entails C, written SF C, if every model of S is a model of C. In this paper, a proof procedure that takes an input set S of clauses and an input clause if C is deriued from S, written S I- C. A proof procedure C, and attempts is sound if S F C implies S F C. A proof procedure there exists a clause D such that SF D and D subsumes C. symbol a mapping a mapping Cb} of S, some literal of each Ci is mapped from D” to D, and an assignment I, I satisfies S if for every ground is a procedure to determine that satisfies S. A set of clauses is complete if S g C implies domain D, an assignment there exists a substitution to {true, false}. Given from D” predicate function p such symbol We also use standard terms from graph theory. A graph G consists of a set of nodes N, and a set E of unordered pairs of nodes called edges, written G = (N, E). An edge e = (v. u} is incident with, or joins its endpoints u and u, and u and u are adjacent to incident with e. A node is of degree k if it is incident with each other as well as being exactly k edges. A path in a graph is an alternating sequence of nodes and edges such that adjacent elements are incident with each other, no node appears twice, and the first and last elements are nodes. Thus P = ( uO, e,, u,, . . . , uk_ , , e,, v~> in the sequence 30 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 i=l,...,k,ui isin N, ei={ui_,,ui}isin the tail edge, ek is called isapathifforall uO isin N.The first node uO is called the tail of the path, the last node uk is called the head of the path, e, is called the head edge, and the path is said to join or connect the tail to the head. The length is the number of edges. Note that a path is that it determined uniquely by its set of edges and its orientation, which is the direction runs. A tree is a graph in which there is a unique path joining any given ordered pair of nodes. We write path(t, h) for the path that joins node t to node h in a tree. The nodes of degree one in a tree are called the leaves of the tree. E,and A rooted tree is a tree with a specified node called the root. The nodes on the path itself, are called the ancestors of that node. The from a given node to the root, excluding second node on that path is called the parent of the first node, while the node itself is called a child of its parent. The children of a parent node are totally ordered; a child that in the order than a second child is said to be to the left (right) of comes earlier (later) the second child. A node n is left (right) of a node m if any ancestor of n is left (right) it to the root. As of any ancestor of m. The level of a node is the length of a path joining we shall some additional trees with structures, but while they are being constructed, trees by definition are unrooted see, clause the trees can be rooted. trees in two steps. First we define mergeless clause We define clause trees and then clause trees with merge paths. Definition 1 (Mergeless clause tree). Given a set S of clauses a mergeless clause tree T (N, E, L, 4) where N is a set of atom nodes and clause nodes, E is a on S is a 4-tuple set of edges that each join an atom node to a clause node, and L is a labeling that maps each atom node to an atom, each clause node to a clause in S, and each edge to either + to either (a) or (b). or -. The graph (N, E) must be a tree. In addition, T conforms 8 (a) (Elementary mergeless clause tree). Given a clause C in S and a substitution for variables CB={a,,..., (1) N consists of a clause node and n atom nodes, where L labels in C, the mergeless clause tree T = (N, E, L, 4) a,) satisfies the following: representing the atom nodes with the atoms of a,, . . . , a, and labels the clause node with C. the clause node to one to according (2) E consists of n undirected edges, each of which joins of the atom nodes and is labeled by L positively or negatively whether (b) (Resolving the atom is positive or negative two mergeless clause trees). Let T, = (N,, E,, L,, 4) in the clause. in common trees with no nodes and T2 = ( N2, E,, L,, 4) be two mergeless clause such that n, is an atom node leaf of T, and n2 is an atom node leaf of T2. No variable may occur in both the label of an atom node in T, and the label of an atom node in T2. Let L, label n, with some atom a, and label the edge {n,, m,} negatively, and L, label n2 with the atom a2 but label the edge {n,, m2) positively. Further let a, and a2 be unifiable with a substitution 8. Let N = N, U NT - {n,}. Let m,l)U{{n2, m,}) where {n,, m,) is a new edge. Let L be a E=E, UE,-{In,, new the new relation labeling edge {n,, m,} is labeled negatively, to the label of each atom node. Then T = (N, E, L, 4) is a mergeless clause two modifications and 8 is applied to L, U L,; that results from tree. variables clause tree. (b) (Resoluing J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 31 tree that contains 2 (Unifiable merge and tautology paths). Let T = (N, E, L, 4) clause be a Definition mergeless two distinct atom nodes n, and n2 such that the atoms that label these nodes are unifiable. A unijiable parh P in T is the unique directed path from n, to n2. If the tail and head edges of P both have the same sign, then P is a then P unifiable merge path. If the signs on the tail and head edges of P are different, is a uni$able tautology path. If the labels on n, and n2 are identical and the signs on the tail and head edges are identical then the unifiable path P is called a merge path (respectively, (respectively, a tautology path). opposite) A clause tree may have many merge paths, but not all of them need to be added to the set of chosen merge paths (the fourth parameter of the clause tree tuple). Those that do, remove a leaf from the set of open leaves. Note that a merge path is fully determined by its atom nodes and orientation, indeed simply by its head and tail. Definition (N,E, L, M), the set of nodes, edges, by (a), (b) or cc). 3 (Clause tree>. Given a set S of clauses, a clause free T on S is a tuple as defined labels and chosen paths respectively, (a) (Elementary clause tree). Given a clause C in S, and a substitution 0 for representing Cf3 is a in C, the mergeless clause tree T = (N, E, L, 4) tw o clause leaf of T, and n2 is an open trees). Let T, = (N,, E,, L,, M,) and T2 = ( N2, E2, L,, M, ) be two clause trees with no common nodes such that n, is an leaf of T,. Let T’ = (N, E, L, 4) be the open mergeless trees from resolving (N,, E,, L,, 4) and (N2, E,, L,, 4) at the nodes n, and n2 as in Definition l(b). Let M be the set of merge paths that results from M, U M, by replacing each occurrence of n, in each path of M, with n2. Then T = (N, E, L, M) clause the two mergeless tree resulting clause clause tree. is a (c) (Choosing a merge path). Let T = (N, E, L, M) and let n, and n2 be two open leaves in T such that P = puth(n,, n2) is a unifiable merge path of (N, E, L, 4) 0, with n, not being using the tail of any chosen merge path in the substitution the head or tail of any chosen merge path. Let LB be the M and n, not being that results from applying 8 to the label of each atom node, and labeling is a clause tree. otherwise P is called a chosen merge path in T,. leaving L the same. Then T, = (N, E, LO, M U (P}) relation A path is a (unijiable) merge or tautology path in a clause tree (N, E, L, M ) if it is tree (N, E, L, 4). Note is that a merge path the to the tree a (unifiable) merge or tautology path in the mergeless clause that a clause directed. Referring back to Fig. 1, we see that the three parts of the figure three parts of Definition (N, E) underlying 3, respectively. We occasionally tree T = (N, E, L, M). is based on an undirected graph (tree), but use T to refer the clause illustrate tree Definition instance of a clause 4 (Instance of a clause tree). A clause tree T = (N, E, L, M) tree T’ = ( N, E, L!, M) is an if L’ and L are identical on the clause 32 J.D. Horron, B. Spencer/Artificial Intelligence 92 (1997) 25-89 nodes and edges, and there is a substitution 0 such that for each atom node IZ, L!(n) = (L(n))O. Where confusion does not arise we will use TB for T’ and LB for L!. Definition 5 (Open leai associated literal, clause of a clause tree and subsumption of clause trees). An open leaf is an atom node leaf that is not the tail of a chosen merge path. Each edge has an associated literal which is formed by the atom label of the incident atom node, modified by negation if the edge is labeled negatively. The clause of a clause tree T, written cl(T), is the disjunction of literals associated with the open leaves. A clause tree T, subsumes a clause tree T2 if cl(T,) subsumes cl(T,). One restriction on chosen merge paths is that the head of one cannot be the tail of another. The purpose of a merge path is to indicate where a proof of the complement of the literal at the tail of a merge path can be found. If this restriction were lifted, there could be two paths based on the same edge set but oriented differently, in which the tail of one was the head of the other. Both ends would be closed, but neither would have a proof. Nor do we want two different proofs indicated for a single tail. One can imagine other definitions for chosen merge paths (such as removing the condition that n, in Definition 3(c) is not the tail of a path) which would sometimes allow the head of a path to be the tail of another but which would avoid this type of circular situation. However other definitions such as merge connected (see below) and path reversal (in Section 5) would become more complicated. We believe that the gain in generality is minimal, and is not needed for the development of better procedures or for the understanding of the present procedures. Definition 6 (Merge connected nodes). In a clause tree T, two atom nodes are said to be merge connected if they are connected by a chosen merge path in either direction or if they are the tails of two chosen merge paths that have a common head. In addition every node is merge connected to itself. Clearly atom nodes that are merge connected must be labeled by the same atom. The relation merge connected is an equivalence relation on the set of atom nodes in a clause tree. In each equivalence class there is a single node that is the head of the chosen merge paths. The remainder of the nodes in the equivalence class are closed leaves that are the tails of chosen merge paths with the same head. These tails break up naturally into two possibly empty sets: those that are incident with a negative edge and those incident with a positive edge. Definition 7 (Merge sets). The merge sets of a clause tree are the equivalence classes defined by the merge connected relation. The head node of a merge set is the head of every path in the merge set, or the singleton node in the set if there are no merge paths. See Fig. 4 for an example clause tree where the atom nodes 1, 2, 3, 4, 5 and 6 are labeled with a and are all merge connected. Node 4 is the head node of this merge set. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 33 Fig. 4.{1,2,3,4,5,6) is a merge set. the name of an atom node We enclose circle; a label is written either beside the node or replaces from the figure. Technically in a box and the name of a clause node in a the node if the node is omitted times. However to occur multiple the clauses of the clause trees in Fig. l(b) and (c) are the same since sets is there is only one open leaf for each literal in the clause. In Fig. l(b) to only one open to multiple open leaves as soon as it is this rule in the to two open leaves, whereas l(c). Generally one does not want a literal chooses a merge path between open it corresponds to correspond that deliberately disobey there are procedures tree of Fig. -d corresponds do not allow elements more useful because the literal leaf in Fig. so one usually leaves, possible to do so. However later sections of this paper. the clause l(c) Fig. 3 shows that merge paths do not have to go between it is not apparent the heads of the merge paths are not open leaves. However that Fig. 3(a) corresponds two leaves, but can go from to a it is easy a leaf to an interior node. At first glance clause tree, because to use the definition of clause tree recursively to construct it. More formally: Definition 8 (Derivation from P is a sequence T,, . . . , T, of clause result of one of the following: of a clause free>. Given a set P of clauses, a derivation of T, trees such that each q for i = 1, _ _ . , n is the . an application of Definition 3(a) on a member of P, . an application of Definition 3(b) on 7; and Tk where j < i and k < i, or l an application of Definition 3(c) on Tj where j < i. Theorem 9. Suppose that (N, E, L, 4) is a mergeless clause tree. Then (N, E, L, M) is a clause tree if and only if it has a derivation. Proof. By induction. The definition q of derivation mirrors the definition of clause tree. 34 J.D. Horton, B. Spencer/Artijiciul Intelligence 92 (1997) 25-89 Theorem 10 Let S be a set of clauses and C a clause. S F C if and only if there exists a subsumes C. clause tree Tfrom S such that cl(T) Proof. S F C if and only if there is a sequence of clauses C,, C,, . . . , C, such that C, subsumes C and each Ci is either in S or Ci is the result of resolving C, and C,, where j < i and k < i. This is a slightly generalized in [26]. Each member of the sequence Ci corresponds 3(a), or an application of Definition 3(b) followed by as many applications 3(c) as required are left that are labeled by the same atom. Conversely, mirrors cl(T) subsumes C. to either an application of Definition of Definition (choosing merge paths between open leaves) so that no two open leaves of a clause tree cl(T) F C since the definition so clearly S t= cl(T). Further of the derivation, (cid:144)1 of Robinson’s main result the definition restatement Definition 11 (Closed clause leaves. tree>. A clause tree is said to be closed if it has no open Corollary 12. S is an unsatisfiable tree T from S. Corollary 13. Any proof procedure clause tree is sound. set of clauses if and only if there is a closed clause that refutes a set of clauses by building a closed Definition 14 (Isomorphic trees T, = (N,, E,, L,, M, > and trees>. Two clause T2 = ( N2, E2, L, , M, >, defined on the same set of clauses S, are said to be isomorphic if there is a bijection ?P : N, + N2 such that: clause (a) (u, u) is in E, iff ?P({v, u})=def {!P(v), 9(u)] (b) L,(x) = L2(F(x)) (c) path P = (u, e,. . . , u) for all x in N, U E,, and is in M, iff P(P) is in E2, =d”f(!P((~), !P(e>, . . . , q(u)) is in 4. 3. Existing top down procedures restated in terms of clause trees Well-known top down proof methodologies such as the weak model elimination procedure translated (ME), the selected into manipulating literal procedure trees. clause (SL) and graph construction (GO can be 3.1. Weak model elimination Consider the following example that proves the literal q from the clauses: Cl = (4, a, b}, C2 = {-a, b}, C3 = {-a, -b}, C4= I-b, a). J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 35 Chain ME operation Clause tree in Fig. 5 -b -4 I-qlah (-qlaf bl-a I-qla[ blkul- I-qla[bl(-d I-sla t-sllalb I-qllallbl-u {-qllallbl q query extension with (q, a, b) -b) extension with (-a, extension with f-b, u) reduction contraction extension with (-a, b) extension with (-a, reduction contraction (2 X) (3 X) -b} Tl T2 T3 T4 T.5 T6 Tl T8 Table I Step # 1. 2. 3. 4. 5. 6. I. 8. 9. 10. [21] as implemented to this proof is shown to the query (top clause). The children of a node are ordered to be proved, and apply by PTTP [35]: Table 1. The construction We start with the negation m q of the theorem the weak ME of the clause procedure in Fig. 5. The tree is rooted at the clause tree that corresponds node corresponding left to right in the order that they occur in the input clause, which an algorithm could reorder. it works on the right hand end of In fact the ME procedure works right to left because to the the chain. Each extension clause tree to the rightmost open leaf, which is called as the current node. The trees Tl, T2, T3, T4, T6 and T7 result from these additions. Each reduction to the insertion of a merge path from the current node to an ancestor node in the tree. Trees the 10 ME steps above have a steps. Not all of T5 and T8 corresponding steps correspond that is the current node, to a node at a higher result step in the construction of the clause tree in Fig. 5. The contraction to the addition of an input clause the focus of the algorithm, step corresponds step corresponds level or to a node that is further to the left in the clause (Definition the above construction is not a derivation in T5 nor the one in T8 is between the leaves. To show that clause steps, a proof in Fig. 6. Fig. 6 is read from top to bottom. Each dashed circle surrounds one the clauses merge path introduced tree T8 has a derivation, we show a sequence of binary ordering, clause tree and is labeled by the clause of that tree. The dashed lines connect resolved to their resolvents. The bottommost 8) because neither clause tree is T8. to changing resolution However together these from tree. Any ME proof is equivalent to a rooted clause as the proof progresses. Any input clause tree that grows downward in build ordering query appropriate cannot be extended, clause could be chosen equivalence literal can be resolved with the rightmost open then the procedure backtracks to extend the clause to the previous tree at the appropriate of ME and this procedure is easily seen and we do not formally prove The justification of the steps in a derivation or in terms of binary resolution be from the bottom of the tree to the top. We do not need to use resolution ancestor clauses as is usually done in order to keep the proof ordering build ordering. Ancestor ancestor node. is replaced by resolution insertion that contains from the the leaf. As in ME, if a node step where another leaf. The it. steps can steps with in line with the to an of a merge path open 36 J.D. Horton, B. Spencer/Artificiul Intelligence 92 (1997) 25-89 4 4 + ,b u + $ TI T2 T3 : T4 : T5 P _ 4 a h T6 T7 T8 Fig. 5. The build ordering of a clause tree. 3.2. Build ordering concepts: choosing merge paths Although the definition of a clause tree allows choosing a merge path between nodes only when both are open leaves, after it is used in a resolution step the head of the merge path is no longer a leaf. Under some conditions choosing a merge path to an internal node can be allowed. To choose such a merge path, one must show that some derivation can be constructed. The sequence of operations in the derivation does not have to be the sequence that an algorithm uses to build T. Thus two orderings of operations are considered: the proof ordering that satisfies Definition 3, and the build ordering that may include the insertion of a merge path to an internal node. An example of this is given in the previous section. J.D. Horton, B. Spencer/Artijkial Intelligence 92 (1997) 25-89 Fig. 6. The proof ordering of a clause tree. m conditions (derivation) on these more general merge path insertions What are the necessary that a proof ordering ensure end on each other, for if they do then in proof ordering leaves of some clause different time created. Since shown the endpoints this is clearly in the upper part of Fig. 7. to exists? First, no two merge paths A and B can the endpoints of A must both be of B not yet created. And yet at a of B must both exist with one endpoint of A not yet is impossible, tree, with one endpoint can exist. An example no such derivation 38 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 Fig. 7. Two impossible clause trees. Moreover, if there are two merge paths A and B such that A ends on B then a third that B ends on C and C ends on A. Again the merge path A before B, B in the lower part of involving more competing merge paths are also to if it happens exists that can produce is illustrated impossible situations situation merge path C cannot be chosen is that no derivation the reason before C and C before A. This Fig. 7. Other conceivable be avoided. The following definitions capture in any derivation. The subsequent the notion that one merge path must be chosen shows what paths must be result before another avoided and what paths can be chosen. Definition 15 (Precedes relation on paths). For two paths A and B in a tree T, A < B, read A precedes B, if and only if the head of A is an internal node, other than the head or tail, of the path B. Definition 16 (Legal paths). A set M of paths in a tree T is legal if the < relation on tree M can be extended T= (N, E,L, M) to a partial order < *. A path P is legal in T. in a clause if MU{P} legal is Theorem 17. Let T = ( N, E, L, M, ) be a clause tree and let M, be a set of n unifiable merge paths such that the tail of each path in M, is a different open leaf of T, and none of the tails is the head or tail of a path in M = M, U M,. Let 8 be a into merge paths. Then substitution that makes all the uni$able merge paths in M, T’ = ( N, E, LO, M > is a clause tree if and only if M is legal. In particular, a unijable merge path P, whose tail is an open leaf and is not the head of a chosen merge path, can be chosen if and only if P is legal in T. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 39 trees corresponding the heads of the paths in the same order, placing before these nodes. Create clause Proof. Assume M is legal, so there is a partial order < * on M. Extend this partial this total order on M to a total order on the atom order to a total order on M. Extend the tail of each nodes in N by ordering the head of the path, and placing all the other atom nodes immediately path to each of the clause nodes by before l(a). Perform a resolution by Definition 3(b) for each internal atom node and Definition to this total choose a merge path by Definition 3(c) for each closed leaf node, according order of the atom nodes. The resolutions can always be done. The merge paths can be chosen because all the resolutions on the path have been done first, but the head is not resolved until Conversely later and is still an open leaf. Then T is a clause if T’ is a clause according the path must be a leaf, so that it cannot be on another path that comes before ordering. Hence -X is a subrelation partial order. tree, it has a derivation. Order the merge paths of M the head of into M. When a path is inserted, it in this of this total order, and so < * is a to the order that they are inserted the relation tree. 0 The two paths in the tree T8 in Fig. 5 do not precede each other, so they form a trivial partial order. Thus it is easy to see that the set of merge paths is legal, and so by Theorem 17 the tree is a clause tree. More generally, ME chooses a merge path from an open leaf to an ancestor of that leaf. Definition 18 ( Ancestor path). An ancestor path in a rooted tree is a path from a leaf to one of its ancestors. Theorem 19. In any rooted tree, a set of ancestor paths is always legal. Proof. Order the paths by the depth of the head in the tree, from deepest to shallowest. Two paths with heads at equal depth are not comparable. This is clearly a partial order. if the head of path A falls on an internal node of path B, the head of A must be Then deeper than the head of B, in which case A precedes B in the order. Thus this partial order extends relation, as required. the precedes 0 The result of this theorem is that the ME tree building procedure in Section 3.1 builds clause trees by Theorem 17, and so is sound by Corollary 13. 3.3. SL resolution The selected [20] and Reiter [25]. It is similar (SL) procedure was independently developed by Kowalski and literal to the ME procedure, but in [16], Loveland Kuehner the current node to its ancestor, SL addition to the ME reduction operation the current node to some that merges has an additional operation called basic factoring in Section 3.1 is Table 2. left sibling of some ancestor. An SL derivation of the example The corresponding tree is built from top to bottom, and from right to left. Since neither of the two merge paths tree for this proof is built as shown in Fig. 8. The clause that merges clause 40 Table 2 Step # 1. 2. 3. 4. 5. 6. I. 8. 9. J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 Chain SL operation Clause tree in Fig. 8 &b hid bb I-qldbl wa (-sl[alb (-ql[ al[bl-a 6ql[al[bl 0 query extension with {q, a, b) extension with t-b, (I) basic factoring truncation extension with (-a. h} extension with (-u, -b) ancestor resolution truncation (3 X ) RI R2 R3 R4 R4 R5 R6 R7 R7 precedes the other, they form a trivial partial order, so by Theorem 17, the tree R7 is a closed clause tree. As in the ME procedure, the extension operation corresponds to an input clause being added to the clause tree, and the reduction operation corresponds to the insertion of a P - q : P _ 9 + A a+/ Yb P - 4 RI R2 R4 N 4 Y R7 P _ 4 b L( b a Fig. 8. An SL build ordering of clause trees. J.D. Horton, B. Spencer/Artijcial Intelligence 92 (1997) 25-89 41 resolution merge path. Ancestor open leaf to an ancestor, path to a sibling of an ancestor, where sibling must be to the left of the ancestor. We call such a path a left hook. to the insertion of a merge path from an to inserting a merge the just as in ME. Basic factoring corresponds leaf. In this case, that sibling corresponds is an open Theorem 20. In any rooted clause tree, any set of ancestor paths and left hooks, whose heads are atom nodes, forms a legal set of paths. Proof. Order the paths by the locations of their heads, first inversely by depth as done in the proof of Theorem 19, and secondarily within each level from right to left. This order is clearly a partial order. Let A be a path that ends on an interior atom node of a path B. There are two cases. (i) B is an ancestor path. As in the proof of Theorem 19, the head of A is deeper than the head of B and so A precedes B in this partial order as needed. (ii) B is a left hook. Either the head of A is deeper than the head of B, or they are on the same level. If they are on the same level, the head of B must be to the left of the head of A. In either subcase A precedes B in the partial order. 0 Thus the clause tree building procedure based on SL is sound by Corollary 13, Theorems 17 and 20. Comparing ME and SL, one sees then trees would be identical. Since SL finds all the merge paths there were no that if clause corresponding ME uses, but also can use more merge paths, the smallest clause least as small as the smallest clause tree found by ME. Indeed required by SL cannot exceed one can do better than SL in this sense. the number left hooks, the that tree found by SL is at the number of resolutions required by ME in the propositional case. But The truncation steps of the ME and SL procedures that truncate part of the data structure, so that what remains may be safely used later in reduction and information may be lost. Procedures using clause basic factoring to define which trees do not depend on truncation; later resolutions in the next section. they use the partial order on nodes are legal. Some of this information can be used by the procedure steps. Hence useful contain operations 3.4. Left paths and the GC procedure Shostak 1291 developed the graph construction to the A-literals addition and SL. An example The clauses are: (ancestors) and B-literals from his paper [29, p. 601 is used to illustrate (GC) procedure. It uses C-literals in (open siblings of ancestors) of ME the GC procedure. I-N, {-R, -T}, {K Q, Nj, {L, -Ml, {L, -Q}, {-L -P}, {R f’, N), -L}, {T}. A GC derivation of the empty clause, starting with the clause {- N, - T} is provided by tree construc- Shostak and is reproduced in Fig. 9 along with the corresponding clause 42 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 0)-N-T I)-Tl-NIMQ 2)-~l-NlQbWL 3) -T L-N] Q IM3 14 2’ extension extension extension extension 4) -T [-N] Q [Mj [t] [-PI R N extension 5) -I” r-q!$y4 [ 1 l--PI B & reduction using A- literal 6) -T [-Nw$?Jfl&, [RI -.L extension 7) -Wl~~ u l;F 8) -T i-N] @JW lL1 (-4 (0 truncation Y..-/ X2 -T L-4 C-L) (-MI Q 9) -T t-N] (4 C-M) [Ql L extension 10) -T r-4 (-UmQl 11) -T L-4 c--L) C-8) C-M) (N) I_T reduction using C- literal truncation x3 extension truncation x2 Fig. 9. The clause tree construction corresponding to the GC procedure. to denote negation, tion. Note that we use - a C-literal. Except extension has, and we have selected extensions, which is also consistent with Shostak. Selected steps we have placed the new literals the leftmost of these new [] to denote a framed A-literal, 0 to denote the in the tree in the same order that Shostak as the site of further literals are underlined. for these changes, to Shostak’s. the example is identical literals In GC allows a merge path to go from an open leaf to an ancestor, or to a node that is to to creating a merge path to the left in the tree. Reduction with an A-literal corresponds J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 43 an ancestor node, which we have already called an ancestor path. Reduction with a C-literal corresponds to creating a merge path to some other node that is to the left of the leaf in the tree. We call such paths left paths. in GC to SL merges (basic factoring) are merges the left hooks allowed by SL all correspond Although Shostak says that GC has no merging operation [29, p. 601, he does allow to open ancestor paths and left paths. What apparently corresponds to the right siblings of ancestors, what we call left siblings to left paths, and are right hooks. However time. A left hook is found by GC after the subtree all found by GC, albeit at a different the below that finds subtree the same merges as SL’s basic factoring operation. But GC finds left paths other than left hooks, so the smallest GC proof will always be at least as small as any SL proof, just as SL was compared the head of the path has already been constructed; is constructed. Thus GC’s left path operation it is found by SL before is a merging operation to ME in the previous section. Both ME and SL prune the search when a legal tautology path is found. ME only looks at ancestor paths; SL considers both ancestor paths and left hooks. GC could also prune when a tautology path is found, either an ancestor path or a left path, but this is not mentioned by Shostak [29]. We call the clause tree version of GC with this extension the ALP procedure, superior it in Section 7. Again ALP is superior that can be done using to ME in the amount of pruning to SL which and discuss tautologies. is These three procedures above leave open the question of whether using right hooks as the procedure. We call this the AllPaths well as left paths and ancestor paths improves procedure (Section 71, and it is the subject of ongoing investigation [27]. 4. Visibility and support Merge paths cannot be chosen from an open leaf to every internal node of a clause if the root of the tree in Fig. 9 had had a rightmost child labeled M, tree. For example to the set the path from that node to the M in the tree could not have been added legally of merge paths. The new path would be in contention with the ancestor path to N. In fact, none of the literals legally by a merge path in the subtree under N can be reached in an altered example, other children from a new rightmost child of the root. However can be reached. For example Fig. 10 shows a clause tree constructed by GC on a set of to Shostak’s example, but allows a child, 3, of the root to be clauses merged that is similar to a new internal node, 9. Thus sometimes we can insert a merge path and sometimes we cannot, which leads to the next definition. 21 (Visibility). A node U, which is not the tail of a merge path in M, Definition visible from a node u in a clause path in T. If u is an atom node and the head edge in P is labeled positively then the positive chosen merge path path(t, h) then we say that the positive from u if the positive positive side of u is said to be uisible from U. If t is the tail of a side of I is visible side of h is visible from U. We also say that u sees the side of u. Otherwise u is invisible from u. If a is the label of u and is if P = parh( u, u) is a legal tree T = (N, E, L, M) (negatively) (negative) (negative) (negative) (negative) 44 J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 I-N. -T, S/ /M Q, Nl lL. -Ml lL, -Ql I-L, -P, Sl lR. P, NI I-R -Ll IT) I-S1 I, 2,9 and 10 are the only atom nodes visible from 3. I, 2 and 9 are the only atom nodes visible from every other atom 10 is not visible from I 3 is not visible from 9 Fig. IO. Alteration of Shostak’s example. (negative) the positive N, is visible from another merge set N2 if the head node of N, is visible node of N2. By convention a node cannot see itself. side of u is visible then a (-a) is a visible literal. A merge set from the head Note that although we originally intended same label, we also wish it to apply to any pair of nodes, including almost cases. This definition makes merge visibility relation. The only exception is not visible from the head. For the example nodes except node 1. is that the head is visible connected that visibility apply to atom nodes with the clause nodes in some the equivalent from the tail, but the tail in Fig. 10 node 10 is visible from all other nodes under The following theorem shows that visibility is the property which merge paths can legally be added to a clause tree. This is important that build clause trees, as in Section 7. that can be used to decide for algorithms Theorem 22. A merge path P = path( t, h) in a clause tree T can be chosen if and only if t is an open leaf, (1) t is not the head of a chosen merge path, (2) (3) h is not the tail of a chosen merge path, and (4) h is visible from t. t must be a leaf and it Proof. Assume P can be chosen. By Definition cannot be the head or tail of any chosen merge path. Also the head h cannot be the tail 3(b), the tail J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 4.5 of a chosen merge path. By Theorem 13, P is legal which Conversely, legal path in T. By Theorem 17, P can be chosen. since h is not the tail of a merge path and h is visible 0 implies h is visible from t. t, then P is a from Lemma 23. A path P is illegal in a clause tree ( N, E, L, M > only if there is a path R in M such that the head of R is an interior point of P, and the directions of R and P disagree on their common edges, of which at least one must exist. that M U {P] is not a legal set of paths. Then there is a sequence of Proof. Assume paths in M u (P), P,, P,, . . . , P,, such that P, < P, -C . . . -C P,, < P,. We may assume that n is as small as possible, and that one of these paths must be P, since M is legal. loss of generality we can let P = P,. Thus P, -C P so that the head of P,,, call it Without in direction with P at u, then R = P,, and we u, is an interior node of P. If P,, disagrees are done. Otherwise P,, agrees in direction with P. Consider the tree separated at u by to one of its incident edges. The tree falls into splitting u into two nodes, each attached one of which, call it A, contains two components, the tail of P, and the other of which, the head of P. P,, is entirely within A, so the head of P,_ , is in A. call it B, contains But the head of P = P, is in B. Let Pi be the smallest i such that the head of Pi is in A. Then since the head of Pi_, -c P, 4 Pi, which contradicts is in B, Pi must contain u. But then Pi -C Pi+, < the legality of M. 0 . legal. Thus Lemma 23 implies that if a path does not run over the head of any other path in the then that path can be added to the set of paths so that the set of paths opposite direction, remains it is easy to see that any set of ancestor paths is legal as all paths point up, as was already shown by Theorem 19. Also if one has a set of ancestor paths then any ancestor path or left hook from an open leaf is legal. It follows and left hooks, easily legal sets of merge paths. However a left path can run over the head of an ancestor path, and then it may or may not be legal. that ME and SL always construct relation The visibility of (the proof is useful because tree T. Suppose is also useful, since step of Definition 3(b). Without for) one atom node on other nodes. Consider tree (Theorem 22). The related concept of support it reveals what new merge paths can be added it an that no chosen merge path if n is split into two nodes n, and n2, each of is the reverse of the that n, is there may be there were a single chosen in Fig. 11 with head and tail labeled by literal b, which has n as that P is oriented so that the the edge labeled “ - ” at n. Then if we split T at n as to a clause reveals dependency interior atom node n in a closed clause includes n as an interior node. Then degree one, T splits into two clause trees T, and T2. This operation resolution in T, and that cl(T,) = (a). Then n2 is in T, and cl(T,) = {-a). However merge paths that include n as an interior node. Suppose merge path P, shown an interior atom node. For the sake of argument edge at n labeled “ + ” precedes before, the tail of P is in T, and its head is in T,. The part of P in T, can be discarded, then and T2 still is discarded, in T, cl(T,) = {a, b}, because leaf. Thus the proof of {a) that the subtree from T, requires that is at the head of P be copied at the tail of P. This the proof of {a}, and this is the intuition behind our use of the term subtree supports if the part of P the tail of P has become an open loss of generality we may assume is a proof of (-a). But suppose 46 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 Fig. 11. n3 is a support of n. support. This subtree in turn gives indirect support to the proof. itself may require support from another chosen merge path, which In the development instead of literals. Rather of algorithms, we have found to work with to the literals, we apply instead. Thus in some sense the node n is given support by the head of that it is more useful this terminology than applying nodes it to the nodes P. This discussion leads to the following definition. Definition 24 (Support). In a clause tree, an atom node u suPport.s an atom node u (also u is supporred by u and u is a SUPPOT? of U> if there is a sequence of chosen merge paths P ,, . . . , P,, such that P, -x . . . -C P,, u is the head of Pk and u is an interior node of P,. We also say that u is a near support of u if the path from u to u contains no other support of u. Also, u is a fur support of u if there is no support w of u for which the path from u to w contains U. In a rooted tree, supports can be ancestors (ancestor suppurrs), to the left (left supports), to the right, or descendants. The following theorem relates support and visibility, by showing that a node’s near supports also serve to hide it from the view of nodes beyond the support. Theorem 25. In a clause tree T, an acorn node h thur is nor the tail of any merge path is visible from an atom node t if and only if there is no near support node of h on the path P = purh( t, h). that there is a near support node of h on P. Then Proof. Suppose (P ,,...,P,)ofchosenmergepathssuchthat of Pk is on P. Then P 4 P, -x . . . < Pk -C P. Hence P is illegal and h is not visible from there is a sequence P, andthehead ... <P,, hison P,-c t. Conversely, assume path or P is illegal there is a sequence that h is not visible in T. But h is not the tail of a merge path so P is illegal (Q,,..., from r. Then either h is the tail of a merge in T. Thus Qj> of chosen merge paths such that P < Q, -C . . . < Qj J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 47 Fig. 12. Merge paths that form an illegal set. < P. Thus h occurs on Q,, so the head of Qj is a support node of h that occurs on P. Hence there must be a near support node of h that occurs on P. q Lemma 26. If v is a support of u, then v is visible from u. . . . -C Pk be chosen merge paths such that u is an interior node of P, Proof. Let P, < and v is the head of Pk. Let P = path(u, u>. Suppose P is not legal. Then there is a sequence Q,,..., Q, of chosen merge paths such that P < Q, -X . . . -C Q, + P. Thus u is an interior node of Q,, so P, -C Q,. (See Fig. 12.) Let h be the head of Q,. Since the union of paths P,, . . . , Pm must be Q, < P, h is an and includes both u and v, P is a subset of this union. Hence h is on some connected, Pi, and so Pi< these are all chosen merge paths. Thus P must be legal, and v is visible interior node of P. Since -C Q, < Pi, a contradiction since 0 from u. <PkdQe, -C ... ... Lemma 27. If w is an ancestor support of a left support of an atom node u, then w is an ancestor of u. Proof. Let u have left support v and let v have ancestor support w. If w were not an ancestor of u, then the unique path P from u to u must go up to the nearest common ancestor of u and v, then down through w to v. (See Fig. 13.) Consider the sequence of chosen paths P,, _ . . , P, such that v is on P,, P, -X . . . * P, and w is the head of P,. Fig. 13. An impossible ancestor support of a left support. 48 J.D. Horton, B. Spencer/Artijcial Intelligence 92 (1997) 25-89 Then P-c P, < Hence w must be an ancestor of u. 0 ... -C Pk, which is impossible, as u is visible from u by Lemma 26. 5. Path reversal, ordered clause sets and foothold scores When a merge path is created, it does not matter in a fundamental sense in which direction the path is oriented. We define the operation of reversing a path A in a clause tree whereby the whole subtree that is attached to the head of A is removed and reattached at the tail of A. Selected merge paths that use parts of the path A have to be redefined, but the details are not hard. This operation allows us to consider entire families of clause trees as equivalent. It also allows us to define restrictions on clause trees, including the foothold score restriction and the ordered clause set restriction. reversal). Let T = (N, E, L, M) be a clause tree, and let Operation 28 (Path A = path(t, h) be a chosen merge path in M. Let u be the node adjacent to h in A. The operation of reversing the path A in T, illustrated in Fig. 14, modifies T to obtain T’ = (N, E’, L’, M’) in the following way: (1) (2) (3) (4) If there is an edge (v, h} in E such that u does not occur on A, then the new set of edges is E’ = (E - (u, h}) U (u, t}. L! is identical to L except that the new edge (v, t} is labeled by L’ with the same sign as (v, h) is labeled by L. In case there is no such edge, E’ = E and L! = L. Define the reversal of A, AR = path( h, t). B,,) be the set of chosen paths in M that contain the edge (u, h}. For L&(B,,..., each Bj = path(ti, hi) define the path Bi as path(ti, hi) if hi # h and path(ti, t> otherwise. Note that the edge set of Bj is the symmetric difference of the edge sets of B, and A, with the edge (v, t) replacing the edge (v, h}. We denote B: by Bi fI3 A, abusing notation slightly. Let(c,,..., each Ci = path(ti, h) define Cj = path(ti, (n, r). C,) be the set of chosen paths in M whose head edge is (v, h). For t), with just the head edge replaced by Fig. 14. Before and after path reversal. J.D. Horton, B. Spencer/Arrijicial Intelligence 92 (1997) 25-89 49 (5) I^cr M’=M-{A)U(AR}-{B cg1. ,,“” ,,..., B,}u{B’, ,..., B;}-{C ,,..., C,}u Lemma 29. Let T’ = (N, E’, L’, M’) be obtained by the path reversal of the chosen path A in T = ( N, E, L, M ). Then the following (a) T’ is a clause tree, and cl(T) = cl(T’). (b) T can be obtained by reversing AR in T’. (c) Two atom nodes are merge connected in T if and only if they are merge connected in T’. Thus a set of nodes is a merge set of T if and only if it is a merge set of T’. statements are true: (d) If a and b are atom nodes in N and {a, b} # {t, h}, a is visible from b in T if and only if a is visible from b in T’. Moreover, the same side of a is visible from b. The only difference in the visibility relations of T and T’ is that h is visible from t in T and not in T’, but t is visibleffom h in T’ and not in T. (e) The visibility relation between merge sets is unaffected by path reversal. Proof. (a) Let h, t, u, v, A, Br and Cj be defined as in Operation 28 (path reversal). Consider any order of the internal atom nodes of T which correspond to a derivation of T, as in the proof of Theorem 17. Order the internal atom nodes of T’ in the same way, except that the position of h and t in the ordering of T are interchanged in the ordering to a chosen path of T’. Consider P = path( x, y) in M. We must show that every internal node of P’ must occur before x and y in the ordering. any chosen path P’ that corresponds in M’ that the internal for T, so all internal then P’ = P. Then all internal for T’. This same argument works atom node set of P’ is the symmetric atom nodes of P If P does not have h as a node, atom nodes of P’ occur occur before x and y in the ordering if P = C;. If P = Bj before x and y in the ordering of the then note t replacing h. internal atom node set of P and the internal atom node set of A, with Since every internal node of A occurs before h in the ordering of T, every internal node t in the ordering of T’. As h either is y or occurs before y in the of A occurs before ordering of T, t is either y or occurs before y in the ordering of T’. Hence all internal atom nodes of P’ occur before y. Thus the ordering of T’ corresponds to a derivation of T’, and T’ is a clause difference tree. Note that cl(T) = cl(T’), since the open leaves of T are the open leaves of T’, except is for h if h is a leaf. But in this case it would be replaced by t which possibly associated with the same literal. (b) Let T” = (N, E”, L’, M”) be obtained by reversing AR in T’. It can easily be seen that E” = E, L’ = L and M” = M. (c) Assume that c and d are merge connected atom nodes of T. in T’. that path(c, d) is a chosen merge path of T. There are three subcases (i) If c = d, then they (it) are still merge connected to (ii) Assume c> is a cho- consider. in T’. If d = h and c # t, then path(c, t> and path(d, r> = sen merge path path(h, t> are chosen merge paths of T’. Otherwise path(c, d) is a chosen merge path of T’. In any case, c and d are merge connected If path(c, d) = A =path(t, h), then path(h, t) =path(d, in T’. J.D. Horton, B. Spencrr/Artijiciul Intelligence 92 (1997) 25-89 (iii> Assume that parh(c, w) and p&d, w) are chosen merge paths of T. If one of these paths is A, then without loss of generality let c = I and w = h. Then path(d, r> = pafh(d, c> is a chosen merge path of T’. If w = h and neither c nor d is t, then path(c, t) are both chosen merge paths of T’. Otherwise puth(c, w> and puth(d, w) are chosen merge paths of T’. t) and p&d, Conversely, assume that c and d are merge connected in T’. Then T is the result of reversing AR in Z” by (b). By the above argument, c and d are merge connected in T. (d) The proof that the visibility relation on the atom nodes is essentially unchanged between T and T’ is similar to the above argument in (a) for the merge paths remaining legal, and is omitted. (e) We must show that the head node h, of a merge set N, can see the head node h, of a merge set N, in T if and only if the head node h’, of N, can see head node hi of N2 in T’. By (d) the only difference in the visibility relation is between the head and tail of a path. Since neither h, nor h, is the tail of any path, the visibility relation between head nodes is unchanged. q The fundamental purpose of a clause tree T is to show that cl(T) can be derived from the clauses corresponding to the clause nodes of the tree. Lemma 29 shows that the same derivations can be found regardless of the direction chosen to create a merge path. Thus a procedure can specify which way a merge path is oriented, without affecting completeness of the procedure. Definition can be obtained from the other by a series of path reversal operations. equivalent). Two clause trees are reversal equivalent 30 (Reversal if one Reversal equivalence is an equivalence relation. Fig. 15 shows four reversal equiva- -c}, {a, b), and {-b, c}. In general, if lent clause trees from the clauses (-a), {a, -b, there are n merge paths with distinct heads in a clause tree then there are 2” different reversal equivalent clause trees. If multiple path reversals are to be done, the order in which the path reversals are done is not important unless there are two chosen paths that have the same head. Theorem 31. Given a clause tree T = (N, E, L, M) and a subset S of M such that no the same head. Then for any ordering of the elements of S, two paths of S have reversing all paths of S in that order results in the sume clause tree. Proof. Select two orderings of the elements of S, and consider the two edge sets that result from reversing the paths in these orders. Since each reversal changes exactly one edge, and since no two reversals affect the same edge, the two edge sets must be identical. Each merge path still connects the same tail to the same head. Since the underlying edge sets are trees, the path connecting a pair of nodes is unique, so the merge paths in the resulting trees must be identical. 0 The situation when the set of paths being reversed includes paths with the same head is not quite as simple. The important thing is where the subtree attached to the head of J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 51 Reverse path between b’s w Reverse path between a’s Reverse path between a’s Fig. 15. Four reversal equivalent clause trees. It ends up at the tail of the paths ends up being attached at the end of the path reversals. to the original head. the last path reversed, at one of the nodes that are merge connected But this is dependent on the order in which the paths with the same head are reversed. If two paths share a head then reversal of the first path followed by the reversal of (the image of) the second amounts to a reversal of the second. See Fig. 16. In fact, looking at the roles of the two paths this diagram one sees that under have been exchanged. That is the image of P, after reversing P, and then reversing Pi, is the same path as the image of P, after reversing P,. the two different operations, 5.1. The ordered clause set restriction clause The ordered set (OC) the search space needed to restriction top down procedure. These papers for any ME-type decrease to specifically develop OC for ME and SLI [191 proof procedures, but it can be applied SL and GC as well. In all of these procedures some merge paths are ancestor paths. If such a path is reversed, a different proof arises. But one needs to allow only one of these [30,311 depends upon path reversal 52 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 / s\ _ _\ L Reverse P , Reverse P 2 \ Reverse P’ 2 y// h Fig. 16. Reversing two paths with the same head. two proofs. Initially, the input clauses are assigned an arbitrary total order. The OC restriction chooses one of the two ancestor merge paths by comparing the clauses at the head and tail. The clause node adjacent to the head of any ancestor path is required to precede the clause node adjacent to the tail (or they could be the same clause in the case of first order clauses [36]). For example in Fig. 17, an ordered unsatisfiable set of clauses is presented and two closed clause trees are shown. In the first, the ordered clause set restriction is obeyed since the clause by the head of the path is earlier than the clause by the tail. However the second clause tree is not accepted. Not only does the OC condition reduce the search space, it can be detected early enough in the procedure to prevent much redundant work. It also prevents multiple redundant proofs from being found when more than one proof is required. This gives a significant improvement to the ME procedure in terms of both the number of inferences and amount of time required. Although merge paths other than ancestor paths are built by the SL and ALP procedures, the ordered clause set restriction is applied only to ancestor paths. The right hooks of SL are oriented left to right, and the left paths of ALP are oriented from right to left, so their reversal would disrupt the structure of the clause tree constructed by the procedures. The top down procedures discussed in this paper (Section 7.2) when applied to problems in propositional logic can use the ordered clause set restriction with a strict inequality because the clauses at the head and tail of a merge path cannot be the same in these algorithms without causing tautology or unchosen merge ancestor paths (Lemma 47). But the first order logic case in general is more complicated. One wants to be able J.D. Horton. B. Spencer/Artijicial Intelligence 92 (1997) 25-89 53 2 b a 1. (p, -a, cl 2. Ip, -b/ 3. (a. bl 4. ( -cl 5. I -Pl IP I’ obeys OC restriction disobeys OC resrrictron Fig. 17. An illustration of the ordered clause set restriction. in all paths simultaneously. is to choose one direction over the other in all ancestor merge paths, so that the direction Paths may arise such that the first and last clause acceptable instances of the same clause. Thus not all ancestor paths are ordered node are different by the ordered clause set restriction. See Section 7.5 for more discussion about this. The next section offers another way to orient paths that does not suffer from this problem. 5.2. Foothold scores Spencer [32] has a different method of orienting merge paths, re$ne- ment. The idea is to give each ordered pair of edges at a clause node, a score of + 1, 0 or - 1. The score of a path is the total of the scores of each such pair of edges along the path. If the path is reversed, the score gets multiplied by - 1. If the number of clause nodes on the path with non-zero score is odd, then the total must be positive or negative. total score, the proper paths, one always By accepting only paths that have a positive class of reversal equivalent gets only one representative trees (Theorem 34). clause chosen from each equivalence the foothold scores). Let T = (N, E, L, M) be a clause tree and let P be a Definition 32 (Foothold chosen merge path in T. For each clause node n in N, assume that the literals of the clause with same sign are totally ordered. Literals with different signs are not compared. Let us call such an ordering a sign ordering of n, and say T is a sign ordered clause tree. Define the score of n in P to be in the sign ordered clause tree T: . 0 if the incoming l + 1 if the incoming edge at n in P precedes l - 1 if the outgoing edge at n in P precedes and outgoing edge at n of P differ; the outgoing edge; and the incoming edge. 54 J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 P is said to be pi-oper if the sum of the scores of all the clause nodes is positive; otherwise P is said to be improper. T is said to be a representative clause tree if all of its chosen merge paths are proper. Any merge path starts and ends with edges of the same sign, and hence must have an even number of internal nodes at which the sign changes. The number of internal nodes of the path in all is odd, so there must be an odd number of internal nodes at which the sign does not change. But the sign changes at all the atom nodes, so all the nodes at which the sign does not change are clause nodes, and there must be an odd number of them. Since the score is + 1 or - 1 at these nodes and 0 elsewhere, the total score of the path must be odd, and hence either positive or negative. Note also the sign of the score changes at a node if the path runs the other way. Thus the total score of a path gets multiplied by - 1 if the path is reversed. Hence either the path or its reversal is proper, but not both. Lemma 33. Consider ordered clause score of n in each of the paths be i, j and k respectively. Then I i + j + k 1 = 1. c), and path(c, a) in a sign to the three paths. Let the tree such that a clause node n is common three paths, path(a, b), path(b, Proof. If the signs on the three edges on the paths are all the same, then the literals of the three edges are all comparable in the sign ordering. Without loss of generality, we can assume that the literal on the edge towards a is the first literal in the sign ordering. Then i= +l and k= three edges are not all the same, one sign differs from the other two. Then two of i, j andkareO,andthethirdvalueis+lor-l.HenceIi+j+kl=l. 18.Ifthesignsonthe = ljl =l.SeeFig. -l.Thus li+j+kl q Theorem representative clause tree with the same sign ordering. 34. Every sign ordered clause tree is reversal equivalent to a unique Proof. Let T = (N, E, L, M > be a sign ordered clause tree. First we show that T is reversal equivalent to a representative clause tree. Order all the chosen merge paths by some total order consistent with the < relation. Consider each of these paths in turn according to this ordering and reverse the path if it is not proper. Since the path reversal b / Fig. 18. Scores around a sign ordered clause node. J.D. Horton, B. Spenccr/Artijiciul Intelligence 92 (1997) 25-89 55 Fig. 19. If P’ and Px are proper then P’ is proper. of a chosen merge path P = path(t, h) affects only the total score of a path which includes h, any path that must precede P, which is already proper, will remain proper. Paths that include h as an internal node are processed later and it does not matter at the time P is processed whether they are proper or not. The one case that is left is if another path P’ = path(t’, h) has the same head, from the same side, and has already been processed. We show that if P is improper and is reversed, and if P’ is proper, then the path corresponding to P’ in the resulting clause tree, P* = pafh(r’, r), is proper. (See Fig. 16 for an illustration of how P* arises from P’.) This fact is proved in [32], in the proof of Theorem 3, but we include a proof here for completeness. Let II be the node common to P, P’ and P*. Let x be the total of the scores of the nodes common to P and P’, excluding n; let y be the total of the score of the nodes on PR and P* , excluding n. Let - z be the total of the score on the nodes common to P’ and P *. Let i, j and k be the scores of n on P, on the reversal of P’ and on P* respectively. Note that X, y and z are computed by traversing away from n. See Fig. 19. Then -y+i+x< Y-i-X&l -z-j+x> 1 y-z-i-j>2 y-z+ka2+i+j+k 21 -1 ( P improper), ( P R proper), ( P’ proper), (add), (add i+j+k), (by Lemma 33). Hence P* is proper. Thus each reversal does not change any path already processed from being proper. Hence the resulting clause tree is representative. The remainder of the theorem requires that two reversal equivalent representative clause trees, that have the same sign ordering, be identical. Suppose T and T’ are two such clause trees that are not identical but that have the minimal number of chosen merge paths. T and T’ cannot be mergeless if they are reversal equivalent but not identical. There is an ordering (a,, u2,. . . , uk> of the atom nodes of T that is an extension of the < ordering of the nodes of T, as defined in the proof of Theorem 17. There is an extension of the < ordering of the atom nodes (a{, a;, . . . , a;) of T’ such 56 J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 that for i = I,. . . , k, ai and u: are merge connected, since the two clause trees are reversal equivalent. Now consider the first head ai of a chosen merge path that occurs in this ordering in T. Suppose that ai and ai are different nodes. Then u; is the head of the corresponding path in T’. Also @~(a~, a,> is a chosen merge path in T while parh(u,, a:) is a chosen merge path of T’. Since the nodes on these paths must occur before ai in the ordering, they cannot be the heads of any chosen merge paths, nor can they be the tails of chosen merge paths. Hence these two paths are the reversal of each other. But then one of these paths is not proper, a contradiction of our assumptions. Thus we can assume that ai = u:. The set of chosen merge paths with ui as head now must be the same in T and T’. Removing these paths from the set of merge paths leaves two clause trees that are identical, by our assumption above. Hence T and T’ are identical. 0 The foothold score restriction can be applied to any clause tree. In particular, one can reject any non-representative clause tree, i.e., one that contains an improper path. In a bottom up procedure, this detects redundant clauses which otherwise would be detected only by a subsumption check. 6. Tautology paths, surgery and minimal clause trees Most proof procedures based on resolution do not allow two-literal tautologies like {a, -a} to be produced as a subclause. Such tautologies cannot help in the production of a proof by resolution. This does not prevent the procedure from being complete because whenever there is a proof using a tautology, some other proof that does not have such a tautology is produced by the procedure instead. Clause trees can be used to demonstrate this. If a clause tree has either a legal tautology path or an unchosen legal merge path, then parts of the clause tree can be removed without adding any more open leaves. In fact, open leaves may be removed. We call this operation clause tree surgery, and note that clause trees to which surgery cannot be applied form an important class of clause trees. Definition 35 (Minimal has no legal tautology paths and no legal merge paths not in M. clause tree). A clause tree T = (N, E, L, M) is minimal if it Conceptually, minimality means that one cannot reorder the resolutions in the clause tree and create a smaller clause tree that subsumes the original clause. That is, there is no smaller proof of the same result using a subset of the original resolution steps. We start with an informal discussion of the various types of surgery on clause trees, and give a more formal unified presentation Operation 36. Let T = (N, E, L, M) be a clause tree which has a tautology or merge path P = puth(t, h) which is legal in T but which is not in M. We consider the case of P a unifiable path later. For the sake of the following discussion, we assume that the path goes from left to right. Thus h and t divide T up into three subtrees, the tail subtree A which is to the left of t, the head J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 51 Fig. 20. Identifying the areas for tree surgery. subtree C which is to the right of h, and the middle subtree B which interior nodes of P, to the left of h and to the right of t. See Fig. 20. includes all the If P is a merge path, then we can perform the following steps, called tail surgery at P. (1) (2) (3) (4) (5) Reverse any chosen merge path which has t is an interior node and whose head is in the near support of t and is in subtree A. Repeat until no chosen merge path which has t as an interior node has its head in A. Remove from M all the chosen merge paths that have their tails in A. Replace any chosen merge path Q that has t as its head by P CB Q, where @ is defined subtree A from the clause Remove Add P to the set of chosen paths in M, making in Operation 28. the resulting tree, leaving t a closed leaf. t as an open leaf. is given in Fig. 21. An example If P is a tautology path, then we can do what we call tautology surgery at P. There that t is not visible from h. In this case there sequence of . . . -C P,, and u is the head of P,. (By a are two cases to consider. First we assume must be a support u of t on the path P. Let P,, . . . , P, be a minimal chosen paths such that minimal sequence, we mean that no subsequence t is on P,, P, < has this property.) (1) Reverse (2) Perform the merge paths P,, . . . , P,. tail surgery at P’, the path joining t to h in the new clause tree. The order in which the paths are reversed does not matter by Theorem 3 1, for none of the reversals the next path, so that is so these paths can have the same head by minimality. Thus we can consider being done immediately replaced by P f3 P,. Thus that P becomes a merge path instead of a tautology path. t is on P,. When Pk is reversed, P the sign of the edge incident with the tail of P changes, in order P,, . . . , P,. Each path reversal puts the last path reversal, t onto before The last case to be considered is that in which T is a tautology path and the tail t is visible from the head h. We call the following operation internal surgery at P. (1) For every node IZ in B which is a near support node of h or t and which can see both h and t, select a path Q = path(u, n) such that u sees the same side of n that t sees (Lemma 261, and reverse Q. (2) Remove all chosen merge paths that have tails in the middle subtree B. (3) Not needed. J.D. Horton, B. Spencer / Artijkial Intelligence 92 (1997) 25-89 u Sk-p 2 Fig. 21. Tail surgery on patldr, h). a t 9--u + / bnl + I Fig. 22. Tautology surgery where I is not visible from 11. t - c IF J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 59 c d & (4) Remove (5) Identify the middle subtree B from T. the two nodes t and h. If some chosen path is affected by the removal operation in step (4), then it must in the head have contained subtree and the tail subtree are put back together when all of P as a subgraph. The parts of this path that were t and h are identified. result than surgery at PR, the reversal of P. For example result of surgery at P is {c), whereas It is worth pointing out that surgery at a merge path P may generate a very different in Fig. 24, the clause of the is {a). in a single definition. The to the numbers on the steps in Figs. the clause of the result of surgery at PR The three different surgery operations can all be given numbers on the steps in Operation 36 correspond 21-23. Operation 36 (Clause tree surgery). Let P = parh(t, h) be a legal path in a clause tree t nor h can be the tail of a T = (N, E, L M >, unifiable by the substitution t, that can see the side of t chosen merge path. Let V be the set of nodes, excluding complimentary to the sign of the head edge of P, but cannot see that side of h. The operation of surgery at P on T produces Tp = ( Np, Ep, L,, Mp > by the following sequence of steps: 0. Neither P _ -- -- - _ +&- ._ z 3 K+ a +\- =: surgery at P R + s c 6 a +.-> I, c 3 a Fig. 24. Surgery at P and P’. J.D. Horron, B. Spencer/Arrijicial Intelligence 92 (1997) 25-89 (1) Let n be an atom node a chosen merge path whose Consider from the t side of n. Reverse step produces a clause tree T’ = (N, E’, L’, M’ >. in V that supports t or that supports h if h is in V. tail is not in V with head n that comes this path. Repeat for all such atom nodes in V. This (2) For each chosen merge path in M’ that has its tail in V, remove it from M’ to leave a set of chosen merge paths M”=M’-{QIQin M’andtailofQisinV}. These include all the paths that were reversed in step (1). (3) For each chosen merge path Q = path(s, t) in M”, replace it with Q’ = path(s, h) to form M”’ = {Q I Q is in M” and t is not the head of Q} U { path( s, h) I path( s, t) is in M”}. (4) Remove from E’ all edges incident to a node in V - {h} to obtain Ep, and let N,=N-(V-{h)). (5) (a) Tail surgery. If h is not in V, then add P to the set of chosen paths M, = M”’ U { P}. (b) Internal surgery. If h is in V, then identify the node h with ( NP, E, ), and delete all other nodes of V from any path of M”’ in which and h occur. Let Mp be the resulting set of merge paths. t in the graph t (6) Define L, to be L8, restricted to NP U E,. It is worth pointing out that while the tail of a chosen merge path cannot be seen by for the tail of an unchosen path to be seen from the the head of that path, it is possible head. Thus in Operation 36 it is possible that h is in V, since P is unchosen. We must show that the above step (1) can be performed; is a support node of t (or of h if h is in V which can be handled that is, for each node IZ in V which in the same way), there is a chosen merge path Q = puth( w, n) with w not in V. Note that support nodes of t in V are precisely the near support nodes on the same side of t as the nodes in V. Since 12 is a support node of t, there are paths Pi = path(ti, hi) for i = 1,. . . , k, such that t is an interior node of P, , P, -C . . . -X P,_ , -C P, and it = h,. If k = 1, then since h,_ , is on P, and is a support node of t, P, is a possible choice for Q. Otherwise, h,_ , must make from from either t, is not in V. Therefore P, is a possible h,. Hence choice for Q. t, or h,. But h, is in V and so t is visible t, which implies t is invisible t invisible from The above operation of surgery may produce different outcomes depending on the in step (l), if a different the result is a clause selection of paths However surgery, application ends up with clause below). Thus the operation of surgery relation between clause tree that is reversal equivalent (Theorem 38 below). to T,. trees that are reversal equivalent is well defined trees TA and T, characterized so strictly speaking set of paths were selected it is not a well-defined in an alternate operation. tree that is reversal equivalent In fact if one starts with reversal equivalent application of the to the result of the original trees, one (Theorem 39 classes of the to a clause up to isomorphism for the equivalence as: T, is isomorphic J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 61 Theorem 37. The application of surgery on a clause clause tree. tree T at a path P results in a is clear We show is a tree. This t is visible negatively loss that the head edge of P is positive. Then V is the set of nodes from which t is not the head or tail of any path reversed in step (11, we at Proof. We use the symbols given in the definition of Operation 36. Assume without of generality t is visible negatively. Since are assured by Lemma 29(d) that the set of nodes from which the end of step (1) is still V. if V is empty since N = NP and that ( NP, EP) in V, but E = E,. Assume V is not empty. Consider not in V. Of course to a node in V. If h is in V, and h is not a leaf, then the clause node beyond h, call it u, is a second such node. See Fig. 23 for an example. Let to a node u # t and u is not in V. Then the path II # h be in V such that n is adjacent from u to t must be illegal while the path from n to t is legal, for otherwise u is in V. By Theorem 25, there must be a support node of t on path(u, t). The only possible t than n. Thus n is a is n itself, with u further support node for t, and there must be a chosen merge path with head n and tail outside in step (1). See Fig. 25. But this reversal makes n a closed leaf, so V that gets reversed t and possibly u can be nodes of T’ outside of V and u does not exist in T’. Hence only adjacent the nodes of 7” adjacent t> but not on path(n, t is adjacent such node to nodes to nodes from in V. Consider any node m of T’ which is not deleted in step (4). Thus m is in NP. The path joining m to t in T’ cannot the path goes through U, and includes h, and so includes all of P. In this latter case, h is in V so h and t get to t by a path, so ( NP, EP) identified the other nodes on P is connected. are deleted. Thus the underlying If t and h are identified, no cycle is created because include any nodes of V unless in step (5b). Thus all nodes in NP are connected graph ( NP, Ep) is a tree. It is not difficult that the set of associated to see that ( NP, Ep, L,, $) is a mergeless clause tree. Consider the literals of the edges clause node c in NP. We must show in V, incident with c is an instance of the clause L,(c) = L(c). For every atom node clause nodes are also in V and hence are deleted as except possibly h, its neighbouring well. In the exceptional clause node u is not in V. When h is identified with t, the edge {t, v) is created. The labels given by L, to h and t the same. All of these are identical elementary l(b), using the substitution LB which ensures identically. The whole of ( NP, Ep, LO, 4) can be built up because clause tree are combined by Definition case, h is in V but its neighbouring that the atom nodes are labeled incident with u remain so the associated ( NP, Ep) is a tree. literals Fig. 25. In T’, showing u cannot be adjacent to a node in V. 62 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 We must still show that MP the remaining chosen merge paths, is a legal set of merge paths. Let Q be in MP. Then the tail of Q was not in V. Nor can the head of Q have been in V, because that would imply that the head of Q was a support of t or h. But then a merge path of T with the same head as Q and the same sign would have been reversed, making this node a tail of a chosen merge path at the same time as it is the head of a merge path. This contradicts the definition of a legal set of merge paths. Q could still have had some nodes in V, by starting outside of V, entering V, and then leaving V. Because the only possible entry points to V are h and the node in V adjacent to t, Q must have included both f and h. Thus Q must have included P as a subpath. Then all the internal nodes of P are deleted in step (41, breaking Q into two pieces, but then in step (51, t and h are identified, and Q is made into a single path again. Hence each object in M, is a path, and the head and tail of each are the head and tail of a merge path in M’. Thus each path is a merge path. That MP is a legal set of paths follows because the precedes relation on M, is a subrelation of the precedes relation of 0 M’, and hence extends to a partial order. The following theorem points out that the choice of a path on which to perform surgery determines the resulting clause tree, up to path reversal. Theorem 38. In any two applications of clause tree surgery at a path P in a clause tree T, the resulting clause trees are reversal equivalent. Proof. We use the terminology used in Operation 36. Let n be a near support node of t in V. The only non-deterministic step in clause tree surgery is the selection of paths to reverse in step (1). Suppose the two applications of surgery differ only by the selection n). The only difference at the end of step (1) is of Q, =path(r,, n> and Q, =parh(t,, the path reversal of Q, @ Q, = path(t,, t,>. See Fig. 26. Both 2, and t, are outside V, Reverse Q, during surgery 4 12 II ---- L , ,’ 121 \ Q, \ l--- /l t - , \ \ / / \ Reverse Q, during Fig. 26. Different results of different applications of surgery. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 63 p&t,, t,) is not deleted in step (2). Also, t,) does not change t, and t, are not deleted the tails of chosen merge paths are in V. Hence in step (4). the tail of any other chosen merge path and the in step (2) of surgery are the same regardless of whether Q, or Q2 t,> is the only the in step for the head of Q to be t, or t,. Thus the head and tail of Q are and so parh(t,, Reversing hence has no impact on whether paths that are deleted is reversed. Thus the one edge change caused by the reversal of path(t,, difference between effect of the two surgery operations on a member Q of M that is not removed (2). It is not possible unchanged from Q must differ though it is possible middle. Therefore (if at all) by precisely that the paths Q and path(t,, the edge sets at the end of the surgery operations. Now consider trees differ only by the path reversal of path(t,, the effect of reversing by the path reversals in step (1). Hence the corresponding the final clause path(t,, paths resulting t,), even t,> may have pieces deleted out of its t2). in step (l), we can on the 0 by using that the resulting prove induction number of near support nodes of t nodes at which different paths are selected. trees are reversal equivalent clause If the two surgery operations differ by more than one selection Theorem 39. Let T and T” be reversal equivalent clause trees, and let P = path( t, h) be a unifiable path in T upon which surgery can be performed. Let the node t* be the let the node h * be the head node of the head node of the merge set oft merge set of h in T' . Then the result of surgery at P on T, and the result of surgery at up to isomorphism. P* on T* are reversal equivalent, in T* . Similarly surgery between surgery at P loss of generality that the head edge of P is positive. Let Q = path(x, Proof. First we consider applying to two clause trees that differ by a single path reversal. Let T = (N, E, L, M), P = path(t, h) and V be as in Operation 36. Assume without chosen merge path of M. Let T* be the result of reversing Q in T. Consider differences generality we assume as far as possible paths to reverse have several cases to consider, depending on where x and y are relative We start with {x, y) disjoint V, we use the same argument is chosen path reversal equivalent. y> be a the loss of that the two different surgeries choose the same is the same. We to I, h and V. h). If x and y are both not in as used in Theorem 38 in the situation where a different are in step (1). By Lemma 29(d), the set V for each surgery the results of the two surgeries from {t, h}, so P* =path(t, in T, and surgery at P* in step (1). Then in T*. Without to be reversed in step (2) of surgery at P* If x and y are in V, then Q is removed the head of P and the edge in T* beyond reversal QR of Q is removed nodes are removed T beyond T* and T respectively, are identical. P in T. But in T* , Q is reversed V. Then Q can be chosen (1). Thus QR is reversed tree is formed in V. are removed as well. Thus in this case the resulting clause in step (2) of surgery at P in T, and the in T*. In step (4) the same in both surgeries, and so are the same edges, except that the edge in the head of P*, which are not in trees in step (2) of surgery at to obtain QR, with head x in V and tail y outside of to be reversed for x, which is now a support node for t in step the same clause to form Q again. Hence at the end of step (1) if y is in V, x is not If x is in V and y is not in V, then Q is removed from both T and T*. A similar argument works 64 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 We are left with the case that {t, h) is not disjoint from {x, y}. We know that neither t nor h can be x, since x is the tail of a chosen merge path. Let t = y. The case h = y is handled similarly except working from T* to T. There are two subcases, depending on whether x is in V or not. Let x be not in V, so the head edge of Q is positive. Reversing Q then interchanges the role of x and y, so path(T* , h * > = pafh( x, h). In both surgeries, the same paths are removed from M, since the location of the tails of other chosen merge paths are not affected by the path reversal of Q. Any chosen merge path pafh(s, t> that remains after h) in step (3). In T” , pufh(s, step (2) of surgery on T is replaced by p&s, t> = puth(s, y) gets replaced by p&s, X> = p&s, T* >, which in turn gets replaced by puth(s, h) in step (3) of surgery on T* . Thus all chosen merge paths at the end of step (3) have the same heads and tails in each of the two surgery operations. The set of nodes from which x is visible negatively remains V, so the same nodes are removed in both surgeries is step (4). The edge beyond the head of Q, if it exists, joins t = y to a node u in V. This u is removed in the surgery on P in T. Similarly the edge {x, u) in T* , which replaces the edge {t, u} in T, is removed in the surgery on T' . Since the node and edge sets are the same, and each corresponding merge path has the same head and tail, the merge paths are the same. Thus the resulting clause trees are identical. Let x be in V, then Q is removed in step (2) of surgery in T. But in T*, T* = x. is visible negatively is V * = (V U { y}) - (x). In step (4) Now the nodes from which T* in the two different surgeries, except that x and y the same nodes are removed interchange roles: y is kept and x discarded in surgery on T; x is kept and y discarded in surgery on T* . The same edges get removed in step (2) as well, except that if u exists then the edge {y, U} in T is replaced by the edge (x, U} in T*. Exactly the same paths are removed in step (2) in both cases. The resulting clause trees are isomorphic, with the node x replacing the node y and otherwise the mapping being the identity. This is the only case in which an isomorphism is required. In all other cases only path reversals are needed. If two clause trees T and T* differ by several path reversals, it follows by induction that the result of surgery on corresponding paths results in clause trees that are 0 isomorphic to reversal equivalent trees. The importance of surgery, and the importance of minimal clause trees, come from the following theorem. Theorem 40. Let T be a clause tree on a set S of clauses. If T is not minimal, then there is a minimal clause tree T’ on S such that cl(T’) c cl(T). Proof. Since T is not minimal, there is a legal tautology or unchosen merge path P in T. Then either tail surgery or internal surgery can be performed on P without a substitution on the variables. Since surgery does not affect clause nodes unless they are completely removed, the resulting clause tree is still from S. The surgery can only remove open leaves, never insert them so that the corresponding clause can only get smaller, not larger. If the resulting tree is still not minimal, then surgery can be repeated 0 until the resulting clause tree is minimal. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 65 Fig. 27. Supplanting a path P by its head subtree T,. Thus non-minimal trees are redundant, if one has all the minimal clause clause that a procedure it is desirable Hence search whenever the clause The surgery operations are not reversible to construct clause trees be able to prune tree being constructed becomes non-minimal. like path reversal is. One cannot know what inverse operation which can was removed. However be reversed by surgery. tail surgery does allow a one-sided trees. the Operation 41 (Supplanting a path). Let P be a chosen merge path with head h and tail t in a clause tree T. The path P is supplanted by its head subtree when the following are done: t in place of h. (1) Make a copy C of the head subtree of P. (2) Attach C to T using (3) Remove P from the set of chosen merge paths. (4) For any chosen merge path with a tail in the subtree at h, add a chosen merge path from the copy of the tail in C to either the copy of the head if the head is in the subtree, or to the head itself if it is not in the subtree. For example, the subtree in Fig. 27, a copy C of the subtree T, supplants the path P. tree, and that tail surgery by P inverts That the result of supplanting the operation, is omitted. a path is a clause 7. Top down procedures for building clause trees AllPaths by describing by pseudocode, In this section we develop for building the top down procedures ME, SL, ALP, MinALP and rooted clause trees and explore some of their properties. We begin followed the general setting, give intuitive descriptions of the procedures, and then proofs of completeness of some of the procedures. Each procedure starts with a satisfiable clause C, the negation of the theorem set S of input clauses (axioms), and another to be proved. C is also added to the set of input 66 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 clauses if the clauses are not propositional. Each procedure assumes that elementary clause trees from the clauses of S and from C are available. The clause tree from C is used as the top clause. One open atom node in the clause tree is deterministically selected as the current node by a computation rule R. Thus R determines whether the search is depth first, left to right, and so on. We usually select R as depth first, and either left to right or right to left. Some of the procedures require that R be depth first, because this guarantees that certain atom nodes are visible without having to explicitly check. All of these procedures contain one or more non-deterministic steps, such as selecting which input clause to resolve against the current atom node. This causes the search to branch. This non-determinism may be implemented by (chronological) back- tracking search, or with a parallel computation. If failure results at any point then the current branch of the search is terminated. The procedure ultimately fails if all nondeterministic steps end in failure. 7.1. Visible lists in the ALP procedures Procedures in the ALP family all use Ancestors paths and Left Paths. This family (so far) consists of ALP, MinALP for minimal ALP, ALPOC and MinALPOC. The last two use the ordered clause set restriction on ancestor paths. All of these procedures build trees top down, left to right. At any given step of the It has a sequence of ancestors procedure, an open aI, a 2,. . . , a,_ ,. None of the nodes to the left of a, are open whereas all nodes to the right are open leaves and are the children of ancestors. See Fig. 28. is being considered. leaf Some overhead work is required for the ALP procedures to guarantee that the set of chosen ancestor and left merge paths is legal. In contrast, the set of merge paths chosen by the ME and SL procedures is necessarily legal, so this overhead is not required. To is maintained, determine whether a left path is legal, a list called the visible list Left Closed Subtrees Right Open Leaves : Fig. 28. Portions of the clause tree as it is built. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 61 Fig. 29. Illustration of support level. from tree is visible of the literals that are visible support nodes. Of course to know the level of the near ancestor support node of n; this is called the current node. A node n in the left consisting portion of a clause from the current node if and only if the path from the current node does not pass over a near support node of n. The support nodes of n that if any support node could appear on this path are ancestor it occurs on this path then a near support node must occur on it. Since the tree is rooted, is sufficient the level support level of n. See Fig. 29. When of n is calculated of II excluding supports of these grandchildren. A subtle point: support of n. For grandchild level of n. of the levels of the ancestor to consider only the level of one is the level of n then its next nearest ancestor support could be the support the support lists of the atom node grandchildren it is not sufficient instance, the level of n itself, by taking the subtree beneath n is closed, levels of the grandchildren from the ancestor support if the support the maximum is inserted list is maintained into the previously and a pair consisting of this level and the literal corresponding by two operations. Recall the subtree below an atom node 12 is closed, the support The visible depth first. When calculated edge (above) with the levels greater than the newly selected atom node are removed. This method of to Shostak’s method of keeping a pointer keeping into folding up procedure of [17] in connection that atom nodes are selected level of n is to n’s upper than less list associated the list. When selected atom node, all of the entries track of visible nodes for the C-literals [29]. It is also analogous to the enforced selected atom is at a level in the visible is analogous the newly the chain tableaux. To implement the ordered clause set restriction, whenever an ancestor merge path is clauses must be compared, and rejected detected, if the deeper clause has a smaller number the clause numbers of the neighboring than that of the ancestor node. [33] by adding it to Stickel’s PTTP list are relatively The ALPOC algorithm has been implemented [34]. These procedure two operations inexpensive. However, using a visible selected, overhead of ALP over P’ITP slows it down by a factor of 2 to 4 per inference agrees with the factor of 3 mentioned The ALPOC system frequently for maintaining list adds some expense list must be searched the visible the visible paths and tautology in [ 171. for rise to a shorter proof so that the number of levels of search is decreased. Because improves upon PTTP, especially when left paths give the is left paths. The [33]. This since, as each node 68 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 iterative deepening search strategy is not forced to look as far, the number of inferences is decreased dramatically in these examples. For instance on the TPTP 1381 problem GRPOO8-1, PTIP required 9,061 ,115 inferences to find a proof within 12 levels of search (12 extension steps) [34], but our implementation of ALPOC required only 1,260,198 inferences to find a proof after 10 levels of search [33]. When we compared on the same computer the version of PITP that compiles to Prolog [35] to our modified version of the same program to build ALPOC proofs on the TPTP problem RNGOOl-3, we found that P’ITP required 13 1,224 inferences and 14.284 seconds to find a proof at level 18, but ALPOC required 6,230 inferences and 1.90 seconds to find a proof at level 14. For SYNOOl-1.005, the PTIP that compiles to Prolog found a proof after 26,790,196 inferences, and ALPOC found a proof after 465 inferences. 7.2. Finding minimal clause trees ALPOC is the tightest top down procedure yet mentioned, but still it can generate proofs that are non-minimal, hence redundant. In fact the example in Fig. 30 shows a problem for which it generates a non-minimal clause tree. All ancestor paths and left paths are handled by ALP and ALPOC. But as this figure shows, not all right paths are. All three procedures ME, SL and GC can construct the clause tree on the left of Fig. 30. However there is a legal, unchosen merge path between the nodes that are labeled with c. If the merge path between the nodes labeled a were reversed, then a legal tautology path would be created between the nodes labeled c. Thus adding the ordered clause set restriction to these algorithms does not eliminate this non-minimal proof. We construct a procedure MinALP which avoids these non-minimal proofs, by detecting such missed paths as in Fig. 30. Let t be the tail and h be the head of an unchosen merge or tautology path P in a clause tree produced by ALP on a set of propositional clauses. If h is an ancestor of t, then when t was the current node in the ALP procedure, the path P would have been discovered. Hence this is not possible. T’ is minimal the corresponding MinALP tree Fig. 30. A non-minimal ALP tree, the minimal tree found by surgery and the MinALP tree. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 69 Similarly if h is a descendant of t, the ALP procedure would have discovered the reverse of P when h was the current node. Also if h is to the left of r, then when t was the current node P would have been handled. Thus we can assume that h is to the right of t. Therefore MinALP is ALP with this additional step: reject the tree if after the subtree below h is closed, h can be seen by a node t to its left that is labeled by the same atom as h. To check this additional condition, MinALP needs to keep track of more information than ALP. Besides the three data structures required by ALP (the list of ancestors of the current node, the list of nodes visible from the current node and the list of ancestor supports of the current node) MinALP also needs to maintain two more data structures: the invisible list of nodes that the current node cannot see, and the near left supports of the current node. The operations on these data structures are not difficult to implement. A node is added to the invisible list when it is removed from the ALP visible list. Once on the invisible list, it stays on the invisible list. When calculating the near left supports of the current node, one must consider not only the heads of left paths on which the current node occurs, but also the heads of left paths on which those heads occur, and so the ancestor supports of these left supports are not needed, since by on. However Lemma 12, an ancestor support of a left support is an ancestor, and therefore is already maintained in the ALP ancestor support list. The search for this path P = parh(t, h) can begin as soon as the subtree below h is closed because then all of the supports of h are known. Consider as candidates for t all the nodes on the invisible list with the same label as h. Eliminate from this set any t whose ancestor list does not include the near ancestor support of h, because if this support of h is on the path from I to h then it makes P illegal. Next for each left support d of h, eliminate any t that has d in its ancestor list, since these supports are on the path from f to h and so make P illegal. If any candidate remains, then the clause _ A- + p, /+ d / ::; a Fig. 3 1. Candidate bad path P made illegal by P,. 70 J.D. Horton, B. Spencer/Artijiciul Intelligence 92 (1997) 25-89 tree so far is non-minimal. Conversely, and the procedure proceeds. Thus MinALP builds only minimal clause then the tree is minimal trees. if no candidate remains although it may become later in the construction. the subtree below h is complete, In Fig. 31 the bad path P is legal before P, In [12] we asked whether MinALP was complete, but we know now it is not. Even if illegal by a left path P is legal when is chosen chosen the set {P, P, , P2} is illegal, and so MinALP would have stopped. After choosing P,, it would not be found by MinALP. One and the tree in Fig. 31 is minimal, candidate bad path P is could amend MinALP that P legal now and can never become if no left path yet to be chosen can go over the nearest ancestor can never become support of h and stop on P. This, if the nearest ancestor support of h is h itself, or if there are no open leaves to the right of is typically when the proof is all ancestors of the nearest ancestor nearly complete. Unfortunately, generate only minimal clause trees, because a left path that could have made a candidate bad path illegal, may never actually be chosen. so that it rejects a tree if any remaining illegal; otherwise this amended MinALP does not necessarily in any of at least two ways: in turn, is guaranteed support of h, which It is guaranteed it proceeds. illegal 7.3. Pseudocode for the clause tree procedures Procedure 42 corresponds [21]. This in Section 3.1. In that section R selects procedure the rightmost open atom node. Such an R is always depth first. However, R does not need to be depth first for this procedure in Fig. 5 and described the weak model (Theorem 19). is illustrated elimination procedure to Procedure 42 (Weak model elimination with clause trees). Initially T is the clause tree from the top clause C. 1. [Start] Let the current atom node g = R(T) be the rightmost open node. 2. [Tautology] 3. [Merge] If a tautology path to an ancestor of g exists, fail. If a merge path to an ancestor of g exists then choose this path and go to then non-determin- If a unifiable merge path to an ancestor of g exists, Continue. istically either go to Extension or do the following: of the label of g and the label of the head of the path, apply 0 to the label of all atom nodes this path and go to Continue. 4. [Extension] in common select such a with T can be resolved with T at g, then non-deterministically clause tree T,. If none exist, fail. Let 19 be the most general unifier of the label of g and the label of the selected atom in T,. Resolve T with T,, and then apply 19 to the label of all the atom nodes. Go to Continue. in T, choose If any elementary clause tree from S that has no variables find the most general unifier 13 5. [Continue] Now g is a closed node. If there are no more open nodes, exit with success. Otherwise go to Start. Procedure 43 corresponds to SL [16] and is described in Section 3.3. An illustration is given in Fig. 8. R of this procedure where R selects the rightmost open atom node does not need to be depth first here, but that is one way to ensure that the head of each left path and right path is a sibling of an ancestor of its tail. This condition guarantees J.D. Horton, B. Spencer/Artificial Inrelligence 92 (1997) 25-89 71 literal for each open that the paths are legal, by Theorem 20. There are other ways maintains ancestors. Stickel [37] notes then factoring by selecting them is a waste of time. This inefficiency the head of a hook as soon as the hook is chosen [28]. 42 are shown 43 and Procedure Changes between Procedure in the set y, its potential factors that if two goals do not have a common provable instance can be avoided in Procedure 43 to guarantee this. SLI the siblings of its in boldface. This to highlight in this section convention will be continued between the development of the procedures. successive procedures Procedure 43 (SL with clause trees). Initially T is the clause tree from the top clause C. 1. [Start] Let the current atom node g = R(T) be the rightmost open node. 2. [Tautology] 3. [Merge] If a tautology path to an ancestor of g or any open leaf exists, fail. If a merge path to an ancestor of g or any open leaf exists then choose this path and go to Continue. If a unifiable merge path to an ancestor of g or any open or do the find the most general unifier 8 of the label of g and the label of the following: head of the path, apply 8 to the label of all atom nodes in T, choose this path and go to Continue. then non-deterministically either go to Extension leaf exists, 4. [Extension] If any elementary clause tree from S that has no variables in common select such a with T can be resolved with T at g, then non-deterministically clause tree T,. If none exist, fail. Let 8 be the most general unifier of the label of g and the label of the selected atom in T,. Resolve T with T, , and then apply 0 to the label of all the atom nodes. Go to Continue. 5. [Continue] Now g as a closed node. If there are no more open nodes, exit with success. Otherwise go to Start. paths tautology Procedure to visible 44, without using to GC and is described in step 2, the in Section 3.4. An illustration where R selects in Fig. 9. For Procedure 44, R should be depth first the Ancestor Merge step does not check whether the ancestor path is legal. If R the algorithm would not 48. Furthermore, Letz et al. [17, Proposi- for arbitrary selection corresponds leftmost open atom node is given because were not depth first, always generate ALP proofs as in Definition tion 7.11 have shown this check would be needed, but then that this is not complete functions. internal nodes Procedure 44 (ALP with clause trees). tree from the top clause C. Initially T is the clause 1. [Start] Let the current atom node g = R(T) be the leftmost open node. 2. [Tautology] exists, fail. If a tautology path to an ancestor of g or any visible internal node 3. [Merge] If a merge path to an ancestor of g or any visible then choose of g or any visible Extension or do the following: this path and go to Continue. internal node exists, internal node exists If a unifiable merge path to an ancestor either go to then non-deterministically find the most general unifier 6 of the label of g 72 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 and the label of the head of this path, apply 8 to the label of all atom nodes in T, choose this path and go to Continue. 4. [ ~xtensionl If any elementary clause tree from S that has no variables in common with T can be resolved with T at g, then non-detetministically select such a clause tree T,. If none exist, fail. Let 8 be the most general unifier of the label of g and the label of the selected atom in T,. Resolve T with T, , and then apply 8 to the label of all the atom nodes. Go to Continue. 5. [Continue] Now g as a closed node. If there are no more open nodes, exit with success. Otherwise go to Start. Like Procedure 44, MinALP should use a depth first selection function R. In MinALP this is important also because the check for minimality in step 5 assumes that the subtree below h has no open nodes. We use a leftmost selection function R, although this can be relaxed to allow any of the deepest open nodes to be selected first. Procedure 45 (MinALP with clause trees). Initially T is the clause tree from the top clause C. 1. [ ~rurt] Let the current atom node g = R(T) be the leftmost open node. 2. [Tuurology] If a tautology path to an ancestor of g or any visible internal node exists, fail. 3. [Merge] If a merge path to an ancestor of g or any visible internal node exists then choose this path and go to Continue. If a unifiable merge path to an ancestor of g or any visible internal node exists, then non-deterministically either go to Extension or do the following: find the most general unifier 0 of the label of g and the label of the head of this path, apply 8 to the label of all atom nodes in T, choose this path and go to Continue. 4. [Extension] If any elementary clause tree from S that has no variables in common with T can be resolved with T at g, then non-deterministically select such a clause tree T,. If none exist, fail. Let 13 be the most general unifier of the label of g and the label of the selected atom in T,. Resolve T with T,, and then apply 19 to the label of all the atom nodes. Go to Continue. 5. [Continue] Now g is a closed node. For each ancestor h of g that has no open descendants do if some internal atom node f with the same label as h can see h then fail endif end for If there are no more open nodes, exit with success. Otherwise go to Start. The ordered clause set restriction can be implemented with any of Procedure 42, Procedure 43, Procedure 44 and Procedure 45. In Procedure 42, replace the Merge step with the following. Here < refers to the total order on the set of clauses. In the other procedures, the ancestor merge step is the following, but other merge steps are unaffected. J.D. Horton, B. Spencer/Artificial Intelligence 9.2 (1997) 25-89 73 [Merge] If a merge path to an ancestor of g exists then if the head clause of the merge path G the tail clause then choose this path and go to Continue. else fail endif elseif a unifiable merge path to an ancestor of g exists then if the head clause of the merge path Q the tail clause then either go to Extension non-deterministically the most general unifier 0 of the label of g and the label of the head of the path, apply 8 to the label of all atom nodes this path and go to Continue. or do the following: in T, choose find else go to Extension endif endif The above procedures can be seen as special cases of a generic procedure, Procedure internal nodes for merges and tautologies, 46. This procedure makes use of all visible and it puts no restriction on its selection function. Procedure 46 (Generic procedure for clause trees). Initially T is the clause 1. [Start] Let the current atom node g = R(T). Let V be some nodes visible tree from the top clause C. from g. to any member either go to Extension If a unifiable merge path 2. [Tautology] If a tautology path to any member of V exists, fail. 3. [Merge] If a merge path to any member of V exists then choose this path and go then to Continue. the most non-deterministically general unifier 8 of the label of g and the head of the path, apply 13 to the label of all atom nodes in T, choose If any elementary in common select such a with T can be resolved with T at g, then non-deterministically clause tree T,. If none exist, fail. Let 0 be the most general unifier of the label of g and the label of the selected atom in T,. Resolve T with T, , and then apply 19 to the label of all the atom nodes. Go to Continue. clause tree from S that has no variables of V exists, find this path and go to Continue. or do the following: 4. [Extension] 5. [Continue] Now g is a closed node. If there are no more open nodes, exit with success. Otherwise go to Start. The AllPaths procedure is Procedure 46 when R is a depth first, left to right selection trees is one where all paths are function and V is all visible nodes. An AllPaths clause it has the usual restrictions on either left paths, right hooks or ancestor paths. In addition unchosen merge and tautology paths: no ancestor paths, right hooks or legal left paths are tautology paths or unchosen merge paths. A path between a node and a sibling of one of its ancestors may be either a right hook or, reversed, a left path. This introduces 74 J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 in the definition so we add the restriction some redundancy that the left paths in AllPaths trees are not reversed right hooks. It has recently been shown [l 11 that a closed AllPaths clause tree on an unsatisfiable set of clauses must exist. Hence the AllPaths procedure is complete. These clause trees are closely related to the folding up and folding down operations on connection tableaux [17]. We are investigating procedures for effectively building AllPaths clause trees. All of these procedures can be improved somewhat by checking for tautology paths in the extension step from the new open leaves. This may expose tautology paths earlier, and so prevent some work. For readability, we have decided to present the searches for tautology paths from the selected literal, and show them as separate steps. In the propositional case, a tautology check in the extension step can take the place of one from the selected node. However, in the first order case, both tautology checks may be needed. The check from the selected node may find tautology paths that were only unifiable tautology paths when the check was done in the extension step. By the same reasoning, tautology paths and unchosen merge paths can arise at any point in build ordering. Detecting this and dealing with it is the subject of ongoing research [15] on the disequality strategy. See Section 9.1. 7.4. Completeness results It is well known that ME and SL are complete. GC and a procedure equivalent to ALP have been shown to be complete 117, Theorem 8.21. We provide an alternative proof which can easily be extended to the ALPOC procedure. First, a structural definition for an ALP clause tree is given which characterizes the type of clause tree that the ALP procedure constructs. Such a tree must exist if S is satisfiable and S U (C) is unsatisfiable. We treat the propositional case, add the ordered clause set restriction, and then lift to first order logic. All procedures in this section are sound because they construct closed clause trees. is an extension with an This is guaranteed because every step in the construction elementary clause tree from an input clause, or a merge path to a visible literal. We start with the following lemma. Lemma 47. For propositional logic, (Procedure 42), SL (Procedure 43), ALP (Procedure 45), or the ordered clause set restriction of these, the top clause can only occur once, at the root. in any closed clause tree produced by ME 44), or MinALP (Procedure Proof. Suppose not, that the top clause C also occurs elsewhere in the proof at a node n. Consider the first edge on the path from the root to n. Let a be the literal associated with that edge. Then a is in C. Hence a must also be associated with an edge incident with n. If a occurs below n, then a tautology path exists from there to the atom node of a adjacent to the root. But all these algorithms reject such a path and could not construct this clause tree. Thus a must be associated with the edge above n. But then a path joining the two atom nodes labeled a, one adjacent to n and one adjacent to the root, is J.D. Horron, B. Spencer/Artificial Intelligence 92 (1997) 25-89 a merge path. This path would have been chosen by any of these algorithms, could never have been extended onto the clause tree, a contradiction. 0 75 and n Definition 48 (ALP clause tree). Given a set S of clauses, an ALP clause tree on S is a closed rooted clause tree on S that meets the following conditions: (1) All chosen merge paths are either left paths or ancestor paths. (2) No ancestor paths are tautology paths or unchosen merge paths. (3) No legal left paths are tautology paths or unchosen merge paths. Theorem 49. Any ALP clause clause for propositional tree that can be constructed by the ALP procedure (Procedure 44). Conversely logic, the ALP procedure constructs only ALP clause trees on S U (C}. tree on S U {C} with top clause C is an instance of a by first selection of the nodes that the depth the procedure would non-detemrinistically Proof. Assume we have an ALP clause the tree. Assume without loss of generality selects nodes from left to right. As an induction hypothesis we assume to the left and above n are constructed tree consisting procedure. When n is selected, there are no left tautology or ancestor is the tail of a merge path, the procedure would find and choose 3. Otherwise unifiable clause tree on S U {C). Consider each atom node n in function R that the clause the ALP the tree is not rejected by step 2 of Procedure 44 since tautology paths in the clause tree. If the atom node the merge path in step a the to extend literal the clause node immediately the procedure only looks for left paths and ancestor paths. Any left path or ancestor path is considered when the tail is the current node. If a legal tautology path trees can have no such is detected, tautology paths. Similarly so the left or ancestor path when the tail resulting clause is the current node. Since all of no unifiable merge (tautology) path can become a merge (tautology) path later in the construction. clause is detected and chosen, the tree. In particular below so the resulting legal merge path tree cannot have an unchosen merge tree is rejected, any such the atoms are propositional, labeling Conversely, choose a clause containing the current atom node. it could choose complementary the clause 0 The converse of Theorem 49 does not necessarily hold in the case of first order logic. (3) of Definition The tree generated by ALP may not satisfy condition 48. Suppose an ancestor merge path P in the tree is not chosen part of the ancestor merge step, because when the tail t of P was the selected node, the head of P was not identical to the labels may make t and h identical, but the algorithm does not check for this. in the non-deterministic to t. Subsequent (2) or condition substitutions applied 50 (Completeness Theorem propositional there exists an ALP clause tree with the clause node labeled C as its root. clauses, and C, a propositional of propositional ALP). Given S, a satisfiable clause such that S U {C} is unsatisfiable, set of Proof. We use induction on the number of atoms in the set of atoms in S U {C}. Let this set be the singleton and C = {a). In either case, there is an ALP clause tree with one atom node labeled a and two clause nodes of degree one. set {a}. Then either S = {{a)} and C = {-a} or S= ({-a}) 76 J.D. Horton, B. Spencer/Artificiul Intelligence 92 (1997) 25-89 Fig. 32. The construction of an ALP tree from T, and T,. Let there be it distinct atoms in S U {C}, and let the leftmost a. Let S, = {X - (-a) 1 X E S and a GE X}. Suppose extending a contradiction. Therefore S, is unsatisfiable. this model so that it maps a to true, we have constructed literal of C be the atom there exists a model of S,. By a model of S U {C), Define S, = S n S,. S, G S so it is satisfiable. Let S, - S, = {C,, . . . , C,}. Then find i such that S, U {C,, . . . , Ci) is unsatisfiable. Let S, = S, U {C,, . . . , Ci_ ,I. tree on S, U {Cj} with top clause Ci. For each there exists an ALP clause a the new atom node added to the top clause node and in S. the smallest By induction clause node corresponding with an edge labeled make Choose merge paths from these new open tree T,. See Fig. 32. to some Cj in this tree attach a new atom node leaves to the new root. Name the resulting it the new root. Now all clause nodes in this tree correspond - . Consider to clauses labeled Consider the clause clause tree for the singleton atom clause (a}. Let V be the set of literals visible from the root of this tree. Note that a is in V. Let tree that results when T, is resolved with an elementary J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 17 Then there is a closed clause Suppose S, is unsatisfiable. in S, labeled by a clause not in S, attach atom nodes clause node from V as appropriate tree is C’ c V. Thus S b C’ and so S I= V. Construct resolve open leaves remain. This tree ensures that S is unsatisfiable, follows tree T’ on S,. For each labeled with atoms to restore it to being a clause from S. Then the clause of this new tree for V, from V into T, so that no and since S + V, it that S U {V} is unsatisfiable, a contradiction. Therefore S, is satisfiable. it with T, at a and choose merge paths as necessary an elementary clause Let C” = C - V. If C” is empty then T, can be resolved with C on a and all literals in T,. The result is a there is a model of S, U {C”}. in V to false. Thus this model satisfies in S - S,. It also satisfies C since C” C C. Therefore S U (C) is satisfied by in C other than a can be merged with left paths to visible closed clause Extend any clause it, a contradiction. Therefore S, U {C”} is unsatisfiable. tree. Otherwise C” is not empty. Suppose that maps a and all literals it to a model literals By induction there exists an ALP clause tree on S, with top clause C”. For each clause node in the tree labeled by a clause not in S, attach new atom nodes labeled with atoms left (hook) merge paths from each atom node labeled Q to the atom node labeled a in the top clause. Let T2 be the name of this new clause from V as appropriate it to being a clause in S U {C). Choose tree. See Fig. 32. to restore tree. It is also satisfies condition Now resolve T, and T2 at the atom node labeled a and choose left merge paths as from T2 to the visible nodes in T, to close all open leaves in T2. The result is (1) of Definition 48 because all paths (2) is the atom a in T,, which only to T, because (3) is all literals complementary to those in all merge paths from T2 to T, are necessary a closed clause are either provided by induction satisfied because all new ancestor merge paths merge occurs as leaves of T,. Also no tautology ancestor paths are introduced the literal a does not occur in T, (because all occurrences satisfied because of T2 eliminates the construction V, so no tautology paths can occur. Furthermore chosen. or are ancestor paths or left paths. Condition are negative). Condition 0 ( ALPOC Definition 51 (C ,, . . . , C,). An ALPOC clause ancestor chosen merge path satisfies clause is Ci, and the head clause clause S = free). Consider tree on S is an ALP clause in which each the ordered clause set restriction. That is, if the tail set of clauses an ordered tree is C,, then j> i. Theorem 52. ALPOC is complete for propositional logic. just a slight addition to the proof of Theorem 50. The same Proof. The proof requires tree. The only extra induction works, with ALP clause set requirement the ancestor is that for top restriction. This can be accomplished for the ordered clause of T, (clauses added to S,> in the reverse order to that required clause set restriction. Then the literal u in the rest of T,, and so the chosen ancestor clauses with the top clause as head clause that the ordered clause set restriction. As this automatically tree replaced by ALPOC clause chosen merge paths satisfy the clauses the top clause precedes any clause which contains the ordered clause that are vying is the only way by ordering satisfy 78 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 ancestor paths are chosen other than recursively, satisfied. (cid:144)I the ordered clause set restriction is In the propositional case, a stronger version of the ordered clause set restriction can be used: for each ancestor path if the tail clause Ci and the head clause is Cj then j > i. To justify this, it suffices to apply Theorem 50 to each clause tree T, built by induction. The top clause cannot appear elsewhere in the clause tree, so j + i. This stronger restriction can also be applied in the first order logic case, when the head and tail clauses of a path are identical instances of the same clause. The proof of Theorem 50 suffices here. Theorem 53. ALP and ALPOC are complete for first order logic. Proof. Let S be a satisfiable set of clauses and let C be a clause such that S U {C} is unsatisfiable. We shall show there is a closed ALPOC tree on S U {C} with top clause C. There is a closed clause tree T on S U {C}. Construct the one-to-one mapping I,!J from distinct instances of atoms in T to new and distinct propositional atoms. Apply I,!I to the atom labels of T and the resulting clause tree T’ is based on the set of propositional clauses S’ U C’, where each clause of S is derived from a clause of S and C,} are the clauses derived from C in the same manner. 5’ U C’ is C’={C,,..., unsatisfiable, because cf(T’) = 4. Suppose S’ is unsatisfiable. Then a closed clause tree on S’ exists. By applying the inverse of Ic, to it, one finds a closed clause tree on S. Thus S is unsatisfiable, which contradicts the hypothesis. Therefore S’ is satisfiable. Select the minimum i such that 5” = S’ U {C, , . . . , Ci_ ,} is satisfiable, but S’ U {Ci} is unsatisfiable. By completeness of the ALPOC procedure there is a tree T* on S’ U {C,) with Ci as the top clause. By applying the inverse of (J to T* , a closed ALPOC clause tree on S U {C} is constructed with C as its top clause. Since any ALPOC tree is also an ALP tree, ALP is complete. 0 Note that the proof of the Theorem 53 allows some unifiable merge paths to remain unchosen. There can be a legal left or ancestor unifiable merge path, which is not a merge path in T*. However no other instance of C can exist in T* that is identical to the top clause (Lemma 47). 7.5. Three counterexamples For any proof format, it is important to ask whether all smallest proofs are eliminated, since many proof procedures use the size of the proof as an important criterion to guide their search. For example, PTTP [34] and SETHEO [18] use iterative deepening. The following two theorems show that ALP may increase the size of proofs and that ALPOC may increase them more. Theorem 54. A smallest ALP clause clause tree. tree on a set of clauses may not be a smallest J.D. Horron, B. Spencer/Arrijcial Inielligence 92 (1997) 25-89 79 Fig. 33. A smallest proof and a smallest ALP proof. Proof. An example the literals within a clause are ordered from left to right: is given by the following, where the first clause is the top clause and I% 4 9 {-a,, a,}, I-q, b), I-b, -4 7 f-b, q,). See Fig. 33. q that both It is known the foothold the size of ME proofs; set that is, the smallest MEOC proof may be the size of it may seem that a smallest ALP proof is the same size as a smallest ALPOC restriction can increase larger than the smallest ME proof. Because proofs, proof. However, left paths can be used to shrink this is not the case. the ordered restriction clause score and Theorem 55. A smallest ALPOC clause tree may be larger than a smallest ALP clause tree. 80 J.D. Horton. B. Spencer/Artificial Intelligence 92 (1997) 25-89 Proof. An example is given by these clauses, where the first clause is the top clause. (-a,, 1. I-41, 2. (4, a,, a,}, 3. 4. C-a,, b, 41, 5. 6. -%J, a,,}, i-b, i-b, a,), See Fig. 34. 0 Section 5.1 points out that for first order logic, the ordered clause set restriction fails is the same as its tail to orient all ancestor paths. An ancestor path whose head clause of the ordered clause can be used in either direction. Here we discuss a generalization and include all the clauses, and clause set restriction: all also all the literals, on the path. Since a merge path cannot be perfectly to orient all merge paths are oriented by such a scheme. Unfortunately paths at the same time by this scheme. in Fig. 35, there are three merge paths, all oriented by this more general ordered clause set restriction. We may to be the head of these paths so that two of the paths choose any one of the three leaves orient all paths lexicographically In the example, given it is not possible symmetric, I P Fig. 34. A smallest ALP proof and a smallest ALPOC proof. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 81 Fig. 35. This clause tree cannot obey the more general ordered clause set restriction. become ancestor paths. But no matter which incorrectly. paths is oriented leaf we choose, one of the two chosen 8. Mergeless clause trees The concepts of unit resolution, input resolution, to be equivalent in a broad sense [.5,21]. This section and resolution on relative Horn set is dedicated by proving each of them is equivalent to the concept of of clauses are known to proving mergeless clause First recall these equivalences trees. the following definitions (see [21]). Let S be a set of clauses. A unit refutation of S is a resolution proof of $ from S in which one parent of each resolution is a unit clause, consisting input refutation of S is a resolution proof of the empty clause from S in which one parent of each resolution the previous relative Horn set of clauses substitution, contains at most one literal not from H. is the result of is a factor of an input clause. S is a (a setting) H, closed under literals occur, and every clause of S in which no pair of complementary is a set of literals and the other of a single literal. An resolution (linearity) if there Theorem 56. Let S be a set of clauses. The following statements about S are equivalent. (a) S has an input refutation. (b) S has a unit refutation. (c) The set of factors of S contains a relative Horn subset which is unsatisfiable. (d) There exists a mergeless closed clause tree on S. Proof. The first three statements prove each is equivalent clause trees. to be equivalent. However we will to the last statement, as examples of how easy it is to work with are well known (a) implies (d). A ssume that S has an input refutation. Build a clause same steps as the refutation, but with the following modification. Whenever in the proof, are merged literals as open leaves identically two merged a literal, attach a clause node corresponding labeled with corresponds the two literals instead of choosing a merge path to put in the tree, leave the labeled. When an input clause resolves on that are to all open to that clause tree the proof, literal being unified. At each step of in the proof, but with possibly many copies of each leaves the clause to the current clause tree using the 82 J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 literal. The final clause tree is closed as the final clause is empty, and the clause tree is mergeless since no merge paths are ever chosen. (d) implies (a>. Assume that S admits a mergeless clause tree. Order the atom nodes using any tree search sequence as long as the next node is adjacent to a node that has already been searched. Depth first and breadth first search are both acceptable. Perform the resolutions in this order. Each step resolves an input clause with the previous clause, so the proof is immediately an input refutation. (b) implies cd). Assume that S has a unit refutation. Mirror the refutation by building clause trees using the same resolutions. Since unit clauses correspond to clause trees with a single open leaf, no clause tree generated by these resolutions can ever have two open leaves that are adjacent to different clause nodes. Thus if a merge is performed in the unit refutation, the literals merged must have come from the same input clause, in which case they could have been merged before being used in a resolution. Thus the instance of the input clause can be used in the construction of the clause tree, and no merge paths are needed. Thus the resulting closed clause tree is mergeless. (d) implies (b). Let T be a closed mergeless clause tree based on factors of S. Number the atom nodes of T from 1 to n, the number of atom nodes, starting at any atom node and follow any tree search algorithm, as in the proof of(d) implies (a) above. Consider the resolution proof based on doing the corresponding resolutions in reverse order. When any atom node is processed, all resolutions on one side of the atom node will all have been processed already, as they must all be numbered higher in the tree search sequence. Thus that one side always corresponds to a clause tree with a single open leaf. Hence the subtree on that side corresponds to a unit clause. The proof is a unit refutation since each resolution uses a unit clause, and the last clause that corresponds to T is empty. (c) implies cd). A ssume that S is an unsatisfiable Horn set relative to a set H of literals. We may assume that for any ground literal, either it or its complement is in H. Since S is unsatisfiable, there must be a closed clause tree T based on S. Without loss of generality we can assume that T is based on ground clauses, by substituting a constant for each variable. At least one of the clause nodes of T must correspond to a clause without a literal in H, because otherwise all the nodes of T could be satisfied by setting all the literals in H to be true. Root T at this node. All the edges adjacent to the root correspond to literals that are not in H, hence the edges beyond the adjacent atom nodes correspond to literals in H. But these must be the only literals in their clauses that are in H, so the literals corresponding to edges adjacent to them are not in H. Continuing in this way, one sees that a literal corresponding to the edge towards the root at any atom node is not in H, whereas the literal corresponding to the edge away from the root at any atom node is in H. Now consider the chosen merge paths in T. None of these merge paths can be ancestor paths since the edge on the path closest to the root must correspond to a literal in H, whereas the edge furthest from the root must not be in H. Then these two literals cannot be unified. Thus all merge paths are either left paths or right paths. Order the paths totally, in reverse order to the precedes relation, with the added constraint that if two paths are not comparable by the transitive closure of the precedes relation, then the path with its head further from the root must come earlier in the order. Thus the first J.D. Horton, B. Spencer/Artificiul Intelligence 92 (1997) 25-89 83 (d) implies to be processed tautology paths, since tree is mergeless, and still closed. that T is a closed mergeless clause tree on S. Without that T has no unifiable path in this order cannot have its head on any other chosen merge path, and there can be the head of the first path in the tree. Supplant each of the paths in this no path below there is no part of a path in the subtree at the head of order. When a path is supplanted, the path since such a path would have first. After all the paths are the resulting clause processed, loss of (c). Assume if it did, the generality we can assume surgery. Root T at any clause node. For tautology path could be removed by internal from n to the root. If P(n) passes over an each atom node n consider atom node m that is unifiable with II, then perform n). It does not matter that T is no longer mergeless. For all other atom nodes other than the tail of the atom node into a set merge paths, place the literal corresponding the H. H cannot contain corresponding into a merge path, whereas if it were a left or right path, it would then have been a unifiable tautology path in the original clause tree. Note that every clause node in T now contains precisely one literal not from H, except for the root which does not contain any. Thus the set of clauses corresponding to the clause nodes of T, which are a set of factors of S, form a Horn set relative atom nodes were an ancestor path, it would have been already If the path P joining turned to H, and are unsatisfiable. tail surgery at p&cm, two complementary to the edge above the path P(n) unifiable literals. q Corollary 57. If T is a closed mergeless clause tree from S then there is unit refutation which, is reversed, becomes an input refutation of S. if the order of refutations 9. Future work and conclusions This paper contains several references research. These are collected and expanded contributions. to ongoing work and raises questions for future in this section, along with a summary of the 9.1. Open problems and future work Open question 1 (Completeness Let S be a satisfiable that S U {C) is unsatisfiable. There is a sign ordered ALP clause tree on S with top clause C such that all ancestor paths are proper. (ALP with the foothold let C be a clause score restriction)). set of clauses of ALPF such and If Open question 1 is true then ALPF orients all ancestor paths, which ALPOC does not orient. including those with is an improvement it the same clause at the head and tail, on ALPOC because Open question 2. Is there a complete, minimal clause the reduced search space? top down procedure trees, no two of which are reversal equivalent, that will generate only and takes advantage of 84 J.D. Horton, B. Spencer/Arti$cial Intelligence 92 (1997) 25-89 We want to exclude from consideration those procedures that use a generate and test approach to building only minimal clause trees. For instance, one could propose the ALP procedure followed by a test for minimality of the constructed tree. Such a procedure would require a large amount of additional searching of the constructed tree, without any associated benefit of reducing the search to construct it. Ideally only a small amount of checking the constructed tree would be required to ensure it is minimal. Open question 3. Is there a polynomial p and a complete, top down procedure that will generate only (minimal) clause trees (no two of which are reversal equivalent) whose size is p(n) where II is the size of a smallest clause tree on the set of input clauses? Many implementations of theorem provers using clause tree and empirical investiga- to build tions are needed. We have already developed a compiler based on PITP ALPOC clause trees. We describe planned extensions to it, to use disequalities, and to build AllPaths trees. The experiments will use the TPTP problem library and a system we have written to automatically run a large number of jobs in batch mode and to collect and summarize the results [33]. It was reported in Section 7.4 that the ALP procedure on a set of first order clauses may generate non-ALP clause trees that contain unchosen merge paths or tautology paths. The check for these paths is done when the tail of the path is the current node, and at that time the path may have been a unifiable merge or tautology path. Since later substitutions can convert unifiable paths into merge or tautology paths, we are required to check again later if we want to avoid unchosen merge and tautology paths. Hynes [15] has implemented an ALP meta-interpreter in Prolog that creates a list of disequalities. A is a pair of nodes, not labeled identically, at the head and tail of a unifiable disequality tautology path or an unchosen unifiable merge path. The procedure maintains the list of disequalities encountered so far in the tree, and adds to this list any new disequalities from the current node. Whenever a substitution is applied, the list of disequalities is checked and if any pair now has identical labels, the tree is rejected. The current implementation applies only to ALP, and uses an iterative deepening search strategy and chronological backtracking. Preliminary experiments show that for some examples, up to 95% of the inferences are avoided, and that the number of disequalities is commensu- rate with the size of the tree. Work is ongoing to compare the benefits with the overhead of building and checking the disequality list. These disequalities are similar but not identical to the syntactic inequality constraints used in SETHEO [18]. The AllPaths procedure, which builds clause trees with ancestor and left paths as well as right hooks, has recently been shown to be complete. Any implementation of it must include some method preventing a left path from running over the head of an existing right hook. An existing AllPaths prototype for propositional logic [27] will be extended to a compiler to Prolog, in the PTTP style, and its effectiveness will be measured against ITTP and ALPOC. We are using the flexible choice of selection functions offered by clause trees to improve the performance of an SL clause tree procedure. Sharpe [28] has implemented a system that replaces the usual depth first selection function with one that selects the selection head of a left hook as soon as the path is chosen. We call this the headfirst J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 85 it chooses factoring that since function points out compensating not usable the system determines common provable decrease in SL often in proof size, because the head of a right hook before other open used leaves. Stickel a the search the unified goals are over-instantiated and the head of a left hook as the next provable goal, two factored goals have a immediately whether or not space without increases the in a proof [34]. By selecting instance. Other future work on the compiler may incorporate failure caches [2,3]. Our intention code depending on what options are selected, restriction, selection the foothold score restriction, for right hooks and lemmas. including disequalities, is to produce one system the use of lemmas, caches and that can generate different left paths, the ordered clause set right hooks, AllPaths, head first towards defining a canonical Minimal clause trees, with all chosen merge paths restricted in only to being oriented form for binary resolution proofs. one way, make progress In the ALP family of procedures, non-ancestor chosen merge paths are forced to be left paths rather than right, and ancestor chosen merge paths can be restricted by the ordered score clause an effective, clause complete procedure trees is an important question. for building minimal set restriction the foothold restriction. finding Thus or clause clause However to check for the same trees are redundant, representative minimal in bottom up procedures, the problem clause trees, we address and non-representative trees are a canoni- only representative cal form as all chosen merge paths are oriented. By retaining posed by Wos [4O]. minimal (#6) of redundancy and we can detect this Non-minimal the tree. Other bottom up systems, such as OTTER use type of redundancy by analysing subsumption check redundancy. increases with the number of retained clauses. Thus the cost of producing a set of clause such a trees that is not redundant should grow more slowly resolution. Any bottom up resolution based procedure can be set of clauses with binary trees. Once a non- turned that produces only minimal surgery, or the clause tree. The first strategy can be used procedure may choose with a complete bottom up procedure, and will preserve completeness. The second will preserve tree. Other procedures it can be made minimal by performing completeness are being The cost of a subsumption than the cost of producing if the procedure into a procedure some minimal tree is found, representative that clause to simply produces [ 13,141. clause clause reject The equality investigated relation plays a special it. Paramodulation technique using paths to justify equality substitutions justify for handling factoring. Another open question than is how to extend as done other just clauses, admit only exponentially formulas problems can be solved only with an exponential these problems problems can sometimes be solved the pigeonhole problem a clause [9]. The negation of a clause with. HOW such substitutions substitutions in polynomial to be solved polynomially role in first order logic. Paramodulation inference can be implemented analogously is one trees to the way in which merge paths in clause clause trees to handle proofs that use in [24]. Many propositional number of resolution large closed clause trees. However, satisfiability steps [4,6]. Hence such that allows to replace can be dealt such time [4,7,39]. One method is to allow a single variable so that conjunctions is a conjunction, as clause should be performed are two more open questions. can be represented trees, and when 86 J.D. Horton, B. Spencer/Artijcial Intelligence 92 (1997) 25-89 9.2. Summary and conclusions Clause trees offer new insights for implementing and understanding binary resolution. The distinction between binary resolution with clauses and binary resolution with clause trees is rather small, from one point of view. With clauses, two operations are always performed literals resolved upon are removed, and any duplicate literals are merged together. In this paper we have uncoupled these two, so that a merge may be delayed until later, or some new literal may be merged with a literal previously resolved upon. together: the complementary Despite this being a subtle difference, there are several interesting advantages. Often with binary resolution on clauses, the result from one sequence of resolution steps gives a result superior to that of the same steps done in a different order, because merge opportunities are missed in the second sequence. With clause trees, both sequences can give the superior result because merges can be done as necessary to remove literals. Thus one clause tree really represents multiple different sequences of binary resolution steps and we can dynamically choose among them to find the one with the best outcome. The interaction of merge paths in the clause tree provides the information from which we can decide, quite easily, if a merge is legal. While merge paths unify the concepts of reduction inference steps and (different forms of) factorization this does not prevent inference steps in other frameworks, different kinds of merge paths from being distinguished in implementations. In particu- lar, ancestor merge paths are used for ancestor resolution, merge paths that are hooks correspond to SL factoring, and left paths perform Shostak’s c-reductions. Thus different types of merge paths are treated differently in the procedures of Section 7. From the viewpoint of proof theory, this uniformity is an advantage because the arguments, such as those in Section 8, are simplified. One important result here is that the precedes relation on the chosen merge paths must be extendible to a partial order. From this result it follows quickly that ME and SL are sound. It also leads to the new concepts of visibility and support. With this deeper understanding of the internal structure of binary resolution we developed the ALP procedure which we soon realized was closely related to GC. This paper introduces the minimal property of clause trees. This is a strong property which means, intuitively, that there does not exist a tautology clause, nor a missing merge in any of the binary resolution derivations that this clause tree represents. In other words, the clause tree contains no unnecessary steps which would make the tree redundant. For every non-minimal clause tree, there is a minimal clause tree that subsumes it. The operation of surgery on clause trees removes the unnecessary steps, leaving a result that is at least as general as the original tree. Clause tree surgery can be applied on partial as well as closed trees, and it can be applied successively until a minimal tree remains. We know of no other inference technique that, without rebuilding at least part of the proof, can improve the result of a proof as much as surgery can. The top down procedures of ME, SL, and GC are explained in a unified manner. For these procedures, it is always permissible to reverse ancestor paths, so that the head is replaced by the tail. The ordered clause set restriction and foothold score restriction take advantage of this fact. They force the path to be oriented in one of the two ways and so J.D. Horton, B. Spencer/Artijicial Intelligence 92 (1997) 25-89 87 cut down on the space that must be searched by these procedures. This leads to inter alia the ALPOC procedure. Two new ideas in proof procedures are presented. The ability to detect non-minimal clause trees has lead to the development of a new restriction, and new top down is procedures, MinALP and MinALPOC, introduced as Procedure 46, that can use any selection function, yet are tighter in that they take full advantage of goals in the tree already proved. This generalizes both SLI, which has an unrestricted selection function but cannot use C-literal% and GC which must use a depth first selection function. A variant of Procedure 46 that uses depth first selection is called AllPaths, and is known to be complete, although the proof is not included in this paper. that use it. A family of proof procedures Unit resolution, input resolution and resolution on relative Horn sets are each shown to be identical to mergeless clause trees. The arguments are compact, yet include a number of known results. We take this as evidence that clause trees improve our understanding of resolution. Two equivalent theorems [29] and [l, Theorem 21 were proved in the 1970’s that are related to Theorem 13. Instead of using merge paths, their graphs use simple cycles to indicate a merge. Both theorems state that a graph represents a sound proof if and only if a certain type of cycle does not exist. Such a cycle exists if and only if, in the corresponding clause tree, the set of merge paths contains a circular set under the precedes relation. That is, the precedes relation is not extendible to a partial order. The advantage of working with trees, rather than graphs is that trees are simpler structures. For example, two nodes in the tree must be connected by a unique path. Using clause graphs Shostak developed the GC procedure, a significant improvement upon SL, in the implementation of it 1970’s. But it was not until 1994 that the first professional appeared [17]. Letz et al. use the connection tableaux, which is a rooted tree structure, and the folding up procedure. Using rooted clause trees, we have extended many top down procedures and made them tighter. But they require all ancestor paths to be free of duplicate atoms, except for the head and tail of chosen merge paths, while other paths are not so restricted. Thus paths in the tree are not treated identically. This has the effect of making some clause trees larger than necessary. Unrooted clause trees may have more potential than rooted trees because all paths can be treated in the same way. We believe strongly that the study of clause trees will provide many opportunities for the development of faster automated reasoning procedures. Acknowledgments The authors gratefully acknowledge the efforts of the two anonymous reviewers and members of the Automated Reasoning group at UNB, including Mike Boothroyd, Kelsey Francis, Rod Hynes, Mike Lamoureux, Charlie Obimbo, David Sharpe and Qinxin Yu, as well as NSERC for funding. 88 J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 References [l] P.B. Andrews, Refutations by matings, [2] O.L. Astrachan elimination, Academic Publishers, Dordmcht, and D.W. Loveland, METEORS: provers using model in: R.S. Boyer, ed., Automuted Reasoning: Essays in Honor of Woody Bledsoe (Kluwer IEEE Trans. C~mpur. 25 (1976) 801-807. theorem high performance [3] O.L. Astrachan 1991). and M. Stickel, Caching and lemmaizing in model elimination theorem provers, in: D. Kapur, ed., Automared Deduction- CADE-II, Saratoga Springs, Lecture Notes in Artificial 607 (Springer, Berlin, 1992) 224-238. [4] W. Bibel, Short proof of the pigeonhole formulas based on the connection method, Intelligence. J. Aurom. Reasoning 6 (1990) 287-297. [5] C.-L. Chang and R.C.-T. Lee, Symbolic Logic and Mechanical Theorem Prooing (Academic Press, New York, 1973). [6] V. Chvatal and E. Szememdi, Many hard examples [7] S.A. Cook and R.A. Reckhow, The relative efficiency of propositional for resolution, J. ACM 35 (1988) 759-768. proof systems, J. Symbolic Logic 44 (1979) 36-50. [8] N. Eisinger, Completeness, Confluence and Reluted Properties of Clause Graph Resolution, Research Notes in Artificial Intelligence (Pittman, London/Morgan Kaufmann, San Mateo, CA, 1991). [9] A. Haken, The intractability of resolution, Theoret. Comput. Sci. 39 (1985) 297-308. [lo] F. Harary, Graph Theory (Addison-Wesley, [ 111 J.D. Horton and D. Sharpe, private communication. [l2] J.D. Horton and B. Spencer, A top down Dreschler-Fischer (Gesellschaft and S. Pribbenow, tiir Informatik, Bonn, 1995) 79-80. Reading, MA, 1969). algorithm in: L. eds., KI-95 Activities: Workshops, Posters, Demos, Bielefeld to find only minimal clause trees, [13] J.D. Horton and B. Spencer, Reducing search with minimal clause trees, Tech. Rept. TR95-099, Faculty of Computer Science, University of New Brunswick, Fredericton, NB, Canada (1995). [14] J.D. Horton and B. Spencer, Bottom-up procedures for minimal clause trees, Tech. Rept. TR96-101, Faculty of Computer Science, University of New Brunswick, Fredericton, NB, Canada (1996). [15] R. Hynes, The disequality strategy Science, University of New Brunswick, Fredericton, NB, Canada in theorem proving, undergraduate (1995). thesis, Faculty of Computer [16] R. Kowalski and D. Kuehner, Linear resolution with selection [ 171 R. Letz, K. Mayr and C. Goller, Controlled Autom. Reasoning 13 (1994) 297-337. integration of the cut rule into connection tableau calculi, J. function, Arrif Intell. 2 (1971) 227-260. [18] R. Letz, J. Shumann, S. Bayer1 and W. Bibel, SETHEO: a high-performance theorem prover, J. Autom. Reasoning 8 (1992) 183-212. [19] J. Lobo, J. Miner and A. Rajasekar, Fundumenruls of Disjuncture Logic Progrumming (MIT Press, Boston, 1992). [20] D.W. Loveland, Mechanical [21] D.W. Loveland, Automated Theorem Proving: A Logicul Basis (North-Holland, Amsterdam, [22] W.W. McCune, O’lTER 2.0 users guide, Tech. Rept. ANL-90/9, Mathematics theorem proving by model elimination, J. ACM 15 (1968) 236-251. and Computer Science 1978). Division, ArgOMe National Laboratories, Argonne, IL (1990). [23] J. Minker and G. Zanon, An extension to linear resolution with selection function, Inform. Process. Serf. 14 (1982) 191-194. [24] N.V. Murray and E. Rosenthal, Dissolution: making paths vanish, 1251 R. Reiter, Two results on ordering for resolution with merging /. ACM 40 (1993) 504-535. and linear format, J. ACM 18 (1971) 630-646. [26] J.A. Robinson, A machine-oriented [27] D. Sharpe, AllPaths New Brunswick, Fredericton, NB, Canada theorem prover, Undergraduate (1995). a pessimistic factoring: basic logic based on the resolution principle, J. ACM 12 (1965) 23-41. thesis, Faculty of Computer Science, University of [28] D. Sharpe, Backwards ed., Proceedings of the Ninth Florida Artificial intelligence Research Symposium, Key West, FL (1996) 459-462. analog of basic in: J. Stewman, factoring, [29] R.E. Shostak, Refutation graphs, Artif Intell. 7 (1976) 51-64. J.D. Horton, B. Spencer/Artificial Intelligence 92 (1997) 25-89 89 [30] B. Spencer, Linear resolution with ordered clauses, in: J. Lobo, D. Loveland and A. Rajasekar, eds., Proceedings ILPS Workshop- [31] B. Spencer, The ordered clause Disjunctive Logic Programming, restriction of model elimination San Diego, CA (1991). and SLI resolution, in: D. Miller, ed., Proceedings International Symposium of Logic Programming, Vancouver, BC (1993) 678. [32] B. Spencer, Avoiding duplicate proofs with the foothold refinement, Ann. Math. Artif. Intell. 12 (1994) 117-140. [33] B. Spencer, TR95094, J.D. Horton and K. Francis, Experiments with theorem prover, Tech. Rept. Faculty of Computer Science, University of New Brunswick, Fredericton, NB, Canada (1995). J. implementation by an extended Prolog compiler. theorem prover: the ALPOC technology [34] M. Stickel, A Prolog Autom. Reasoning 1 (1988) 353-380. [35] M. Stickel, A Prolog technology theorem prover: a new exposition and implementation in Prolog, Theor. Comput. Sci. 104 (1992) 109- 128. [36] M. Stickel, personal communication. [37] M. Stickel, Upside-down meta-interpretation of the model elimination theorem-proving procedure for deduction and abduction, J. Autom. Reasoning 13 (1994) 189-210. [38] G. Sutcliffe, C. Suttner and T. Yemenis, The TPTP problem Deduction-CADE-12, 252-266. Nancy, Lecture Notes in Artificial library, Intelligence in: D. Kapur, ed., Automated 814 (Springer, Berlin, 1994) [39] G.S. Tseitin, On the complexity of derivations in propositional calculus, in: A.O. Stisenko, ed., Studies in Muthemutics and Mathemutical Logic Part II (Consultants Bureau, New York, 1970) 115-125. [40] L. Wos, Automuted Reasoning: 33 Busic Research Problems (Prentice-Hall, Englewood Cliffs, NJ, 1988). 