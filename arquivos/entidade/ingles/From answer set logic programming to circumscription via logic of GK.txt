Artificial Intelligence 175 (2011) 264–277Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintFrom answer set logic programming to circumscription via logic of GKFangzhen Lin a,∗, Yi Zhou ba Department of Computer Science, Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kongb School of Computing and Mathematics, University of Western Sydney, Penrith South DC, NSW 1797, Australiaa r t i c l ei n f oa b s t r a c tArticle history:Available online 3 April 2010Keywords:Logic programmingAnswer set programmingLogic of GKCircumscriptionNonmonotonic reasoningKnowledge representation and reasoningWe first embed Pearce’s equilibrium logic and Ferraris’s propositional generallogicprograms in Lin and Shoham’s logic of GK, a nonmonotonic modal logic that has beenshown to include as special cases both Reiter’s default logic in the propositional case andMoore’s autoepistemic logic. From this embedding, we obtain a mapping from Ferraris’spropositional general logic programs to circumscription, and show that this mapping canbe used to check the strong equivalence between two propositional logic programs inclassical logic. We also show that Ferraris’s propositional general logic programs can beextended to the first-order case, and our mapping from Ferraris’s propositional generallogic programs to circumscription can be extended to the first-order case as well to providea semantics for these first-order general logic programs.© 2010 Elsevier B.V. All rights reserved.PrologueIt gives us great pleasure to be able to contribute this work to this special issue of Artificial Intelligence in honor of JohnMcCarthy. Like so many others, we have been influenced greatly by McCarthy and his work for as long as we have known AI.This particular work relates McCarthy’s circumscription to several other nonmonotonic logics, and obviously could not havebeen done without McCarthy’s pioneering work on nonmonotonic reasoning in general and circumscription in particular.1. IntroductionAnswer Set Programming (ASP) is a new paradigm of constraint-based programming based on logic programming withanswer set semantics [9,13,17]. It started out with normal logic programs, which are programs that can have negation butnot disjunction. Driven by the need of applications, various extensions have been proposed. These include disjunctive logicprograms [5,6], nested expressions [7], cardinality and weight constraints [16], and others. Recently, Ferraris [2] proposedto view formulas in propositional logic as logic programs and showed that they include as special cases all the abovementioned classes of logic programs. In particular, Ferraris [2] provided a stable model semantics for these formulas usinga transformation similar to the original Gelfond–Lifschitz transformation, and showed that this semantics coincides withPearce’s equilibrium logic [19].In this paper, we show that this general stable model semantics can be embedded in Lin and Shoham’s logic of GK(Grounded Knowledge) [11]. Besides showing the generality of Lin and Shoham’s logic, which was proposed as a generallogic for nonmonotonic reasoning, this embedding allows us to obtain a way to check in classical propositional logic whetherany given two logic programs are strongly equivalent in almost the same way as in [12]. It also allows us to obtain a* Corresponding author.E-mail address: flin@cs.ust.hk (F. Lin).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.04.001F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277265mapping from general logic programs to propositional circumscription in the same way as Lin and Shoham [11] did formapping normal logic programs to circumscription. As it turned out, this mapping, when extended to first-order case, yieldsa semantics to first-order general logic programs that is similar to the one proposed recently by Ferraris et al. [4].We first briefly review Lin and Shoham’s logic of GK, Ferraris’s general logic programs, and Pearce’s equilibrium logic.2. Logic of GKThe language of the logic of GK is a modal propositional language with two modal operators, K , for knowledge, and A,for assumption. Given a set Atom of atoms (also called variables or primitive propositions), formulas in the logic of GK aredefined inductively below in BNF notation:F ::= ⊥ | p | K (F ) | A(F ) | ¬F | F ∧ F | F ∨ F | F → F ,where p ∈ Atom, and ⊥ is a constant standing for falsity. Formulas without modal operators are called base formulas.The semantics of the logic of GK is defined through Kripke interpretations. A Kripke interpretation M is a tuple(cid:8)W , π , R K , R A, s(cid:9), where W is a nonempty set whose elements are called possible worlds, π is a function that maps apossible world to a truth assignment on Atom, R K and R A are binary relations over W representing the accessibility re-lations for K and A, respectively, and s ∈ W , called the actual world of M. The satisfaction relation |(cid:10) between a Kripkeinterpretation M = (cid:8)W , π , R K , R A, s(cid:9) and a formula F is defined inductively as follows:• M (cid:11)|(cid:10) ⊥;• M |(cid:10) p if π (s)(p) = 1, where p ∈ Atom;• M |(cid:10) ¬F iff M (cid:11)|(cid:10) F ;• M |(cid:10) F ∧ G iff M |(cid:10) F and M |(cid:10) G;• M |(cid:10) F ∨ G iff M |(cid:10) F or M |(cid:10) G;• M |(cid:10) F → G iff M (cid:11)|(cid:10) F or M |(cid:10) G;• M |(cid:10) K (F ) iff (cid:8)W , π , R K , R A, w(cid:9) |(cid:10) F for any w ∈ W , such that (s, w) ∈ R K ;• M |(cid:10) A(F ) iff (cid:8)W , π , R K , R A, w(cid:9) |(cid:10) F for any w ∈ W , such that (s, w) ∈ R A .We say that a Kripke interpretation M is a model of a formula F if M satisfies F . In the following, given a Kripke interpre-tation M, we let(cid:2)K (M) =A(M) =(cid:2)FF(cid:3)(cid:4)(cid:3) F is a base formula and M |(cid:10) K (F )(cid:3)(cid:4)(cid:3) F is a base formula and M |(cid:10) A(F ).,Notice that K (M) and A(M) are always closed under classical logical entailment. In the following, for any set X of formulas,we let Th( X) be the logical closure of X under classical logic.Informally in GK, one assumes A(M) and minimizes K (M). When the assumed A(M) turns out to be the same as theminimal K (M), an equilibrium is reached, and the assumption is said to be “justified” or the knowledge is said to be“grounded”. Formally, GK models are defined as follows.Definition 2.1 (GK models). Given a formula F , a Kripke interpretation M is a minimal model of F if M is a model of F andthere does not exist another model M1 of F such that A(M1) = A(M) and K (M1) ⊂ K (M). We say that M is a GK model1 ifM is a minimal model of F and K (M) = A(M).Lin and Shoham showed that the logic of GK can be used to capture Reiter’s default logic [20] and Moore’s auto-epistemiclogic [15]. As a consequence, normal logic programs under stable model semantics can be captured in the logic of GK aswell. Specifically, they showed that a normal ruler ← p1, . . . , pn, not q1, . . . , not qmcan be translated into the following sentence in the logic of GK:Kp1∧ · · · ∧ Kpn∧ ¬Aq1∧ · · · ∧ ¬Aqm→ Kr.(1)They also showed that this translation extends to disjunctive logic programs.In this paper, we shall show that general logic programs proposed by Ferraris [2] can be captured in the logic of GK aswell.1 In [11], GK models are called preferred models.266F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–2773. General logic programsGiven a set Atom of atoms, general logic programs [3] are formulas defined inductively below in BNF notation:F ::= ⊥ | p | F ∧ F | F ∨ F | F → F ,where p ∈ Atom. Notice that there is no negation in the language. Instead, for any formula F , ¬F is considered to be ashorthand for F → ⊥.A set X ⊆ Atom of atoms can be considered as a truth assignment in the straightforward way:X (cid:11)|(cid:10) ⊥,X |(cid:10) p iff p ∈ X,and the usual definition for the logical connectives.The stable models of a formula (general logic program) are defined by a modified extended Gelfond–Lifschitz transforma-tion. Given a general logic program F , and a set X of atoms, the reduct of F under X [2], written F X , is the formula obtainedfrom F by replacing each maximal subformula that is not classically satisfied by X with ⊥. Thus for example,(¬F ) X =(cid:5)(cid:15), X |(cid:10) ¬F ,⊥, otherwise.Now a set X of atoms is a stable model of a general logic program F if:(i) X |(cid:10) F X ;(ii) there is no proper subset X1 of X , such that X1 |(cid:10) F X .Example 3.1. Consider the following three general logic programs.P = ¬p → q,Q = ¬p ∨ p,R = p → ¬¬p,is ¬⊥ → q, which is satisfiedwhere p, q are atoms. The maximal subformula in P that is false under {q} is p, thus Pby {q}, but not by ∅. Therefore, {q} is a stable model of P . On the other hand, Pis ⊥ → ⊥, which is satisfied by {p} aswell as its subset ∅. Therefore, {p} is not a stable model of P . It can be seen that {q} is the only stable model of P . Similarly,it can be shown that Q has two stable models, {p} and ∅, and R has exactly one stable model ∅.{p}{q}4. Pearce’s equilibrium logicPearce’s equilibrium logic [19] is based on the logic of here-and-there, a non-classical logic. Given a set Atom of atoms,formulas of Atom are exactly the same as in the case of general logic programs. Thus, negation in equilibrium logic isconsidered a shorthand as well.The semantics of the logic of here-and-there is defined in terms of HT-interpretations, which are pairs (cid:8) X, Y (cid:9) of setsof atoms such that X ⊆ Y . The HT satisfaction relation2 |(cid:10) between an HT-interpretation (cid:8) X, Y (cid:9) and a formula F is definedrecursively as follows:• For p ∈ Atom, (cid:8) X, Y (cid:9) |(cid:10) p if p ∈ X ;• (cid:8) X, Y (cid:9) (cid:11)|(cid:10) ⊥;• (cid:8) X, Y (cid:9) |(cid:10) F ∧ G if (cid:8) X, Y (cid:9) |(cid:10) F and (cid:8) X, Y (cid:9) |(cid:10) G;• (cid:8) X, Y (cid:9) |(cid:10) F ∨ G if (cid:8) X, Y (cid:9) |(cid:10) F or (cid:8) X, Y (cid:9) |(cid:10) G;• (cid:8) X, Y (cid:9) |(cid:10) F → G if(i) (cid:8) X, Y (cid:9) (cid:11)|(cid:10) F or (cid:8) X, Y (cid:9) |(cid:10) G, and(ii) Y |(cid:10) F → G.An HT interpretation (cid:8) X, Y (cid:9) is an equilibrium model of a formula F if X = Y , (cid:8) X, Y (cid:9) |(cid:10) F , and there is no proper subset X1 ofX , such that (cid:8) X1, Y (cid:9) |(cid:10) F . Ferraris [2] showed that the stable models of a formula are essentially the same as its equilibriummodels.Theorem 1 (Ferraris). Let X be a set of atoms and F a general logic program, X is a stable model of F iff (cid:8) X, X(cid:9) is an equilibrium modelof F .2 We overload |(cid:10), and use it to stand for satisfaction relations for modal logic, classical logic, and logic of here-and-there. Which one it stands for shouldbe clear from the context.F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–2772675. From general logic programs and equilibrium logic to the logic of GKIn this section, we present a translation from a general logic program (also a formula in equilibrium logic) to a formulain the logic of GK, and show that under the translation, stable models (thus equilibrium models) coincide with GK modelsin the logic of GK.Given a general logic program F , we define two formulas F A and F GK in the logic of GK as follows:(1) F A is obtained from F by simultaneously replacing each atom p by Ap.(2) F GK is defined inductively as follows:• ⊥GK = ⊥;• For p ∈ Atom, pGK = Kp;• (F (cid:17) G)GK = F GK (cid:17) G GK ((cid:17) is ∧ or ∨);• (F → G)GK = (F GK → G GK ) ∧ (F → G) A .It can be shown that for a normal logic program F , F GK is equivalent to the translation by Lin and Shoham [11] given inSection 2 under(cid:6)p∈AtomKp → Ap,(2)and that for any formula W in the logic of GK, M is a GK model of W iff M is a GK model of W ∧ (2).This translation is also similar to the mapping from formulas in equilibrium logic to quantified boolean formulas givenin [18]. We shall discuss this in more detail in a later section.To illustrate, consider the three programs in Example 3.1. P GK is(cid:7)(¬p)GK → qGK(cid:8)∧ (¬p → q) A,which is(cid:7)(cid:8)(¬pGK ∧ ¬p A) → Kq∧ (¬p A → q A),which is(cid:7)(¬Kp ∧ ¬Ap) → Kq(cid:8)∧ (¬Ap → Aq).(3)Now let M be a model of the above sentence. If p ∈ A(M), then (3) holds no matter what K (M) is, thus its minimal modelis K (M) = Th(∅), so cannot be a GK model. Now if p /∈ A(M), then (3) is equivalent to (¬Kp → Kq) ∧ Aq. Thus q ∈ A(M).Thus if M is a minimal model, then K (M) = Th({q}). And if A(M) = K (M), then M is a GK model. What we have shownhere is that in any GK model M of (3), K (M) = A(M) = Th({q}). The existence of such a model is apparent.It can be similarly shown that Q GK is equivalent to Ap → Kp, and that M is a GK model of Q GK iff K (M) = A(M) =Th({p}) or K (M) = A(M) = Th({(cid:15)}). And RGK is equivalent to Kp → Ap, and that M is a GK model of RGK iff K (M) = A(M) =Th({(cid:15)}). Thus for these three programs, their GK models correspond one-to-one with their stable models. In general, wehave the following result. Proofs of the theorems are in Appendix A.Theorem 2. Let X be a set of atoms and F a general logic program. The following two statements are equivalent.(1) X is a stable model of F .(2) There is a GK model M of F GK such that K (M) = A(M) = Th( X).6. From general logic programs and equilibrium logic to circumscriptionGiven their mapping (1) from normal logic program to the logic of GK, Lin and Shoham [11] showed that stable modelsemantics for normal logic programs can be captured in circumscription [14] as follows. Given a set Atom = {p, q, . . .} of(cid:18), . . .} be a new set of atoms. Given a normal logic program F , let C(F ) be the conjunction of theatoms, let Atomsentences:(cid:18) = {p(cid:18), qp1 ∧ · · · ∧ pn ∧ ¬q(cid:18)1(cid:18)∧ · · · ∧ ¬qm→ r,for each ruler ← p1, . . . , pn, not q1, . . . , not qmin F . Lin and Shoham [11] showed that X is a stable model of F iff X ∪ X(cid:18)is a model of268F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277(cid:6)(cid:7)(cid:8)(cid:18)p ↔ p(cid:7)∧ CircumC(F ); Atom(cid:8),p∈Atomwhere Circum(W ; Q ) is the circumscription of the atoms in Q in W (with all other atoms fixed). Lin and Shoham alsoshowed that this result can be extended to disjunctive logic programs. Using the same idea, we can capture the stablemodel semantics of general logic program and equilibrium logic in circumscription as well.Let Atom be a set of atoms. Again let Atom(cid:18) | p ∈X}. Given any general logic program F in the language Atom, let C(F ) be the result obtained from F GK by replacing everyKp in it by p and every Ap in it by p(cid:18) | p ∈ Atom} be a set of new atoms. For any X ⊆ Atom, let X, for every p ∈ Atom.(cid:18) = {p(cid:18) = {p(cid:18)Theorem 3. For any general logic program F in the language Atom, any set X ⊆ Atom, the following two statements are equivalent(1) There is a GK model M of F GK such that K (M) = A(M) = Th( X).(2) X ∪ X(cid:18)is a model of(cid:6)(cid:7)p ↔ p(cid:8)(cid:18)(cid:7)∧ CircumC(F ); Atom(cid:8).(4)p∈AtomInterestingly, our translation C(F ) that embeds general logic programs and equilibrium logic in circumscription is exactlythe same as the one by Pearce et al. [18] for embedding equilibrium logic in quantified boolean formulas. They showed that(cid:8) X, X(cid:9) is an equilibrium model of a formula F in equilibrium logic iff Xis a model of the following quantified booleanformula:(cid:18)where Fis the formula obtained from F by replacing every atom p by p(cid:8)(cid:6)(cid:7)(cid:7)(cid:8)(cid:6)(cid:7)(cid:7)Atom < Atom(cid:8)(cid:18)(cid:8)∧ C(F ),F(cid:18) ∧ ¬∃Atom(cid:18)p → p(cid:18)∧ ¬(cid:18) → p.pp∈Atomp∈Atom(cid:18), and Atom < Atom(cid:18)stands forWhile propositional circumscription is also a quantified boolean formula, it is a well studied formalism. There are manyknown results about circumscription that we can use. Mapping logic programs to circumscription can help us better under-stand both formalisms.(cid:9)Notice that the formula(cid:10) (cid:6)(cid:7)(cid:11)(cid:8)(cid:18)∧p → pp∈Atomp∈Atom(p ↔ p(cid:7)(cid:10) (cid:6)(cid:11)(cid:8).(cid:18) → ppp∈Atom(cid:18)) is equivalent toThus (4) is equivalent to(cid:11)(cid:10) (cid:6)(cid:7)(cid:8)p → p(cid:18)p∈Atom(cid:10) (cid:6)(cid:7)∧p∈Atom(cid:11)(cid:8)(cid:18) → pp(cid:7)∧ CircumC(F ); Atom(cid:8),which is equivalent to(cid:10) (cid:6)(cid:7)(cid:18) → ppp∈Atom(cid:11)(cid:8)(cid:12)∧ CircumC(F ) ∧(cid:6)(cid:7)(cid:8)(cid:18)p → p(cid:13); Atom,p∈Atom(cid:9)as the atoms (predicates) to be minimized occur only negatively ininto the theory in the circumscription is good as it can be used to simplify C(F ).p∈Atom(p → p(cid:18)). Putting the formula(cid:9)p∈Atom(p → p(cid:18))(cid:9)Proposition 6.1. If(cid:6)(cid:7)p∈Atom(p → p(cid:8)p ↔ p(cid:18)∧ Circum(W ; Atom).(cid:18)) |(cid:10) C(F ) ↔ W , then (4) is equivalent top∈AtomConsider again the three programs in Example 3.1. For P , C(P ) is equivalent to ¬p ∧ ¬p(cid:18) → q under (p → p(cid:18)). Thus for this program, (4) is equivalent to(cid:18)) ∧ (q → q¬p(cid:18) → q, which is equivalent to(cid:7)p ↔ p(cid:8)(cid:18)(cid:7)q ↔ q(cid:18)(cid:8)∧∧ Circum(cid:7)¬p(cid:18) → q; {p, q}(cid:8),which is equivalent to(cid:7)p ↔ p(cid:8)(cid:18)(cid:7)q ↔ q(cid:18)(cid:8)∧which has a unique model {q, q∧ ¬p ∧(cid:18)}.F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277269(cid:7)¬p(cid:18) ↔ q(cid:8),For Q = ¬p ∨ p, C(Q ) is equivalent to p(cid:18) → p. Thus for this program, (4) is equivalent to(cid:7)(cid:8)(cid:18)p ↔ p∧ Circum(cid:7)p(cid:8),(cid:18) → p; {p}(cid:18)which is equivalent to p ↔ p, which has two models p and ¬p.7. First-order general logic programs and circumscriptionAs in [11], we can extend the above mapping to the first-order case. First of all, we extend logic programs to the first-order case. Let L be a relational first-order language with equality, i.e. it has no proper functions. By an atom, we mean anatomic formula including equality atoms.In the following, let Σuna be the set of unique names assumptions on constants: c1 (cid:11)= c2 for any two distinct constantsc1 and c2.A first-order general logic program is a first-order sentence in the following set:F ::= ⊥ | A | F ∧ F | F ∨ F | F → F | ∀xF | ∃xF ,where A is an atom, and x a variable. Again, for any general logic program F , ¬F is considered to be a shorthand forF → ⊥.Now let M be a finite model of Σuna with domain D. Let σ be the mapping from constants to D under M. Clearly, forany distinct constants c1 and c2, σ (c1) (cid:11)= σ (c2). We say that M is a stable model of a first-order general logic program F ifT (M), the set of ground facts true in M:T (M) =(cid:2)P ((cid:23)u)(cid:3)(cid:3) P a predicate, (cid:23)u ∈ P M(cid:4)is a stable model of the general logic program F M , the grounding of F on M obtained from F and M in two steps:(1) First, replace every constant c in F by σ (c), every subformula of the form ∀xW in it by(cid:14)u∈D W (x/u), and everyu∈D W (x/u), where W (x/u) is the result of replacing every free occurrence of xsubformula of the form ∃xW in it byin W by u. The order by which these subformulas are replaced does not matter.(2) In the expression obtained by the first step, replace every equality atom u = u by (cid:15), and every u = u(cid:18)for distinct u(cid:9)and u(cid:18)by ⊥.Example 7.1. Consider the following four programs:(cid:8)(cid:7)¬p(x) → qF 1 = ∃xp(x) ∧ ∃x(cid:15)(cid:7)(cid:8)F 2 = ∃xp(x) ∧∃x¬p(x)(cid:8)(cid:7)(cid:15)∃xp(x)¬F 3 = ∃xp(x) ∧(cid:7)¬p(x) → qF 4 = ∃xp(x) ∧ ∀x,→ q(cid:16)→ q(cid:8).(cid:16),,Now consider a structure with two elements {a, b}. The grounding of the four programs on this domain are(cid:8)(cid:8)(cid:7)(cid:7)(cid:7)(cid:7)(cid:8)(cid:8)p(a) ∨ p(b)(cid:8)p(a) ∨ p(b)(cid:8)p(a) ∨ p(b)(cid:8)p(a) ∨ p(b)(cid:7)(cid:7)(cid:7)∧∧∧∧(cid:7)(cid:7)∨¬p(b) → q¬p(a) → q(cid:8)(cid:8)→ q¬p(a) ∨ ¬p(b)(cid:8)(cid:8)(cid:7)p(a) ∨ p(b)¬∧→ q,¬p(b) → q¬p(a) → q(cid:8)(cid:7),(cid:8),,(cid:7)(cid:7)respectively. So for this domain, F 1 and F 3 have the same stable models, {p(a)} and {p(b)}, and F 2 and F 4 have the samestable models, {p(a), q} and {p(b), q}. It is easy to see that this is the case for any given domain: F 1 and F 3 have the samestable models, and F 2 and F 4 have the same stable models.We now show that the stable models of first-order general logic programs can be captured in circumscription as well.Let (cid:5) be the set of predicates in the language. Let (cid:5)(cid:18)be a set of new predicates, one for each P in (cid:5) with the same arity. Now given a first-order general logic program F , let C(F ) be the first-order formula defined inductively(cid:18)and denoted by Pas follows.• C(⊥) is ⊥.• If W is an atomic formula, then C(W ) is W .270F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277• C(W 1 (cid:17) W 2) is C(W 1) (cid:17) C(W 2), where (cid:17) ∈ {∧, ∨}.• C(∀xW ) is ∀xC(W ), and C(∃xW ) is ∃xC(W ).• C(W 1 → W 2) is (C(W 1) → C(W 2)) ∧ (W→ W(cid:18)1(cid:18)2), where W(cid:18)is the result of replacing every predicate P in W by P(cid:18).The stable models of F are then the models of the circumscription of all the predicates in (cid:5) in C(F ), together with thefollowing axiom(cid:6)(cid:7)∀(cid:23)xP ((cid:23)x) ↔ P(cid:18)(cid:8)((cid:23)x).P ∈(cid:5)Theorem 4. Let M be a finite model of Σuna. M is a stable model of F iff M(cid:7)(cid:8)CircumC(F ); (cid:5)∧ (5),(cid:18)is a model of(5)(6)where M(cid:18)is the conservative extension of M under (5).Similar to Proposition 6.1, we haveProposition 7.1. If(cid:9)P ∈(cid:5)∀(cid:23)x(P ((cid:23)x) → P(cid:18)((cid:23)x)) |(cid:10) C(F ) ↔ W , then (6) is equivalent toCircum(W ; (cid:5)) ∧ (5).Example 7.2. Consider the programs in Example 7.1.(cid:8)(cid:7)(cid:18)∧¬p(x) → q(cid:18)(x) → q) under ∀x.p(x) → p(cid:18)(cid:8)(cid:16),• C(F 1) is(cid:15)(cid:7)∃xp(x) ∧ ∃x¬p(x) ∧ ¬p(cid:18)(x) → qwhich is equivalent to ∃xp(x) ∧ (¬∃xpequivalent to∃!xp(x) ∧(cid:7)(cid:7)(cid:18)(cid:8)(x)(cid:8),↔ q¬∃xpthus equivalent to∃!xp(x) ∧ ¬q,(cid:18)(x). Therefore, under (5), Circum(C(F 1), {p, q}) iswhich can be considered to be the first-order semantics of F 1. If D = {a, b}, then there are exactly two models of thissentence, {p(a)} and {p(b)}.• C(F 2) is∃xp(x) ∧(cid:7)(cid:7)∃x¬p(x) ∧ ¬p(cid:18)(cid:8)(x)(cid:7)(cid:8)∧→ q(cid:18)∃x¬p(x) → q(cid:8)(cid:18),which is equivalent to∃xp(x) ∧under ∀x.p(x) → p(cid:7)(cid:7)(cid:8)(cid:18)(x) → q∃x¬p∃!xp(x) ∧∃x¬p(cid:18)(x) ↔ q,(cid:8)(cid:18)(x). Therefore, Circum(C(F 2), {p, q}) is equivalent tounder (5), thus equivalent to(cid:8)∃x¬p(x)∃!xp(x) ∧(cid:7)(cid:7)(cid:8),↔ qwhich can be considered to be the first-order semantics of F 2. If D = {a, b}, then there are exactly two models of thissentence, {p(a), q} and {p(b), q}.• C(F 3) is• C(F 4) is∃xp(x) ∧(cid:7)¬∃xp(x) ∧ ¬∃xp(cid:18)(x) → q(cid:8)(cid:7)∧(cid:18)¬∃xp(x) → q(cid:8)(cid:18),which is equivalent to C(F 1) under (5). Thus F 1 and F 3 are equivalent under our semantics.∃xp(x) ∧ ∀x(cid:15)(cid:7)¬p(x) ∧ ¬p(cid:18)(x) → q(cid:7)(cid:8)∧(cid:18)¬p(x) → q(cid:18)(cid:8)(cid:16),which is equivalent to C(F 2). Thus F 2 and F 4 are equivalent under our semantics.F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277271We have defined the stable model semantics for first-order logic programs by reducing them to propositional logicprograms through grounding. For this to work, we need to assume a finite domain for otherwise a first-order sentence suchas ∃xp(x) cannot be replaced by a propositional sentence. We also need the unique names assumption in order to eliminateequality literals such as a = b or a (cid:11)= b.Theorem 4 shows that this stable model semantics for first-order logic programs can be captured by a simple formula (6)using circumscription. However, while the stable model semantics makes the unique names and finite models assumptions,the formula (6) is completely general and makes sense without these assumptions. Thus one could use this formula todefine the stable model semantics of first-order logic programs in the general case. As it turned out, this will yield asemantics that is essentially the same as the one proposed recently by Ferraris et al. [4]. More precisely, given a first-ordersentence F , Ferraris et al. proposed a second-order sentence as its stable model semantics, and showed that this second-order sentence is equivalent to (6) with all new predicates existentially quantified: ∃(cid:23)pϕ( (cid:23)P(cid:18)/(cid:23)p), where ϕ is formula (6), (cid:23)p a(cid:18)/(cid:23)p) is the result of replacingtuple of predicate variables, one for each predicate Pin ϕ by its corresponding variable in (cid:23)p.each Pin ϕ and with the same arity, and ϕ( (cid:23)P(cid:18)(cid:18)8. Strong equivalenceThe notion of strong equivalence [8] is important in logic programming. For disjunctive logic programs, research by Linand Chen [10] and Eiter et al. [1] show that interesting programs transformation rules can be designed based on the notion.According to Ferraris and Lifschitz [3], two general logic programs F and G are said to be strongly equivalent if for anyformula F 1 that contains an occurrence of F , F 1 has the same stable models as the formula obtained from it by replacingan occurrence of F by G. They showed that for any F and G, they are strongly equivalent iff F and G are equivalent in thelogic here-and-there.As it turns out, our mapping from equilibrium logic to logic of GK also embeds logic of here-and-there to modal logic.Thus the problem of deciding whether two programs are strongly equivalent can be reduced to checking whether certainmodal logic formulas are valid, and that, because of the special format of these modal formulas, can in turn be reduced tochecking whether certain propositional formulas are tautologies.Theorem 5. Let F be a formula in equilibrium logic, X and Y two sets of atoms such that X ⊆ Y , and M a Kripke interpretation suchthat K (M) = Th( X) and A(M) = Th(Y ). We have that (cid:8) X, Y (cid:9) |(cid:10) F iff M |(cid:10) F GK .Theorem 6. Let F and G be two general logic programs. The following conditions are equivalent.(cid:9)(cid:9)(cid:9)(cid:9)1. F and G are strongly equivalent.2.3.4.5.p∈Atom(Kp → Ap) |(cid:10) (F ↔ G)GK .p∈Atom(Kp → Ap) |(cid:10) F GK ↔ G GK .p∈Atom(p → pp∈Atom(p → p(cid:18)) |(cid:10) C(F ↔ G).(cid:18)) |(cid:10) C(F ) ↔ C(G).Corollary 7. The problem of deciding whether two general logic programs are strongly equivalent is co-NP complete.9. ConclusionWe showed that the logic of GK proposed by Lin and Shoham is flexible enough to handle stable model semantics ofgeneral logic programs. Because of this, the stable model semantics of general logic programs can also be formulated incircumscription, in both propositional and first-order cases. For future work, we plan to make use of the expressive powerof GK in other applications.AcknowledgementsWe thank Vladimir Lifschitz for stimulating discussions on topics related to this paper, and for his helpful comments onearlier versions of this paper. This work was supported in part by HK RGC under grant HKUST6170/04E, and by China NSFCunder grants 60703095 and 90718009.Appendix A. Proofs of theoremsA.1. Proof of Theorem 2Lemma 1. Let F be a general logic program; X and Y two sets of atoms such that X ⊆ Y and M a Kripke interpretation such thatK (M) = Th( X), A(M) = Th(Y ). We have that X |(cid:10) F Y iff M |(cid:10) F GK .272F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277Proof. Let F and G be two general logic programs, X ⊆ Y two sets of atoms. As shown in [3], (F ∧ G) X is equivalent toF X ∧ G X , and (F ∨ G) X equivalent to F X ∨ G X . Thus by induction on the structure of F , it’s easy to see that Y |(cid:10) F iffM |(cid:10) F A , where M is as in the proposition.We now prove that X |(cid:10) F Y iff M |(cid:10) F GK by induction on the structure of F .• If F is ⊥, then this assertion holds obviously.• If F is an atom p, then pGK is Kp. X |(cid:10) pY iff p ∈ X . On the other hand, M |(cid:10) Kp iff p ∈ X too. Therefore, X |(cid:10) pY iff• If F is G ∧ H , X |(cid:10) (G ∧ H)Y iff X |(cid:10) G Y and X |(cid:10) H Y . By induction hypothesis, this holds iff M |(cid:10) G GK and M |(cid:10) HGK ,• If F is G ∨ H , X |(cid:10) (G ∨ H)Y iff X |(cid:10) G Y or X |(cid:10) H Y . By induction hypothesis, this holds iff M |(cid:10) G GK or M |(cid:10) HGK , which• Finally, if F is G → H . X |(cid:10) (G → H)Y iff Y |(cid:10) G → H and X |(cid:10) G Y → H Y iff (i) Y |(cid:10) G → H and (ii) X (cid:11)|(cid:10) G Y or X |(cid:10) H Y .By induction hypothesis, this holds iff (i) M |(cid:10) (G → H) A and (ii) M (cid:11)|(cid:10) G GK or M |(cid:10) HGK iff M |(cid:10) (G → H)GK .M |(cid:10) pGK .which is equivalent to M |(cid:10) (G ∧ H)GK .is equivalent to M |(cid:10) (G ∨ H)GK .This completes the induction proof. (cid:2)Theorem 2. Let X be a set of atoms and F a general logic program. The following two statements are equivalent.(1) X is a stable model of F .(2) There is a GK model M of F GK such that K (M) = A(M) = Th( X).Proof. (1) ⇒ (2): Suppose that X is a stable model of F . We can construct a Kripke interpretation M such that K (M) =A(M) = Th( X). We now prove that M is a GK model of F GK . Firstly, we have X |(cid:10) F X since X is a stable model of F . ByLemma 1, M |(cid:10) F GK . We only need to prove M is a minimal model. We prove it by contradiction. Assume that M is not aminimal model of F GK , then there exists another model M1 of F GK such that A(M1) = A(M) = Th( X) and K (M1) ⊂ K (M).We construct another Kripke interpretation M2 such that A(M2) = Th( X) and K (M2) = Th( X1), where X1 = {p | M1 |(cid:10) Kp,p ∈ Atom}. For any general logic program G, by induction on the structure of G, it’s easy to see that M2 is a model of G GKiff M1 is a model of G GK . Therefore, M2 is a model of F GK . By Lemma 1, X1 |(cid:10) F X . Moreover, X1 ⊂ X . This shows that X isnot a stable model of F , a contradiction. Hence, M is a GK model of F GK .(1) ⇐ (2): Suppose that there is a GK model M of F GK such that K (M) = A(M) = Th( X). By Lemma 1, X |(cid:10) F X . There isno proper subset X1 of X such that X1 |(cid:10) F X . Otherwise, we can construct a Kripke interpretation M1 such that K (M1) =Th( X1) and A(M1) = Th( X). By Lemma 1, M1 is also a model of F GK . Moreover K (M1) ⊂ K (M); A(M1) = A(M). This showsthat M is not a GK model of F GK , a contradiction. Hence, X is a stable model of F . (cid:2)A.2. Proof of Theorem 3Notice that C(F ) can also be defined recursively as follows.• C(⊥) is ⊥.• If F is an atom, then C(F ) is F .• C(F 1 (cid:17) F 2) is C(F 1) (cid:17) C(F 2), where (cid:17) is ∧ or ∨.• C(F 1 → F 2) is (C(F 1) → C(F 2)) ∧ (F→ F(cid:18)1(cid:18)2), where F(cid:18)by p.(cid:18)is the expression obtained from F by replacing every atom pLemma 2. Let F be a general logic program, X and Y two sets of atoms, and M a Kripke interpretation such that K (M) = Th( X),A(M) = Th(Y ). We have that X ∪ Yis a model of C(F ) iff M |(cid:10) F GK .(cid:18)Proof. We prove this by induction on the structure of F .• If F is ⊥, then this assertion holds obviously.• If F is an atom p, then pGK is Kp, C(F ) is p. X ∪ YX ∪ Y(cid:18) |(cid:10) C(p) iff M |(cid:10) pGK .• If F is G ∧ H , X ∪ Y(cid:18) |(cid:10) C(G ∧ H) iff X ∪ Y(cid:18) |(cid:10) C(G) and X ∪ Yand M |(cid:10) HGK , which is equivalent to M |(cid:10) (G ∧ H)GK .• If F is G ∨ H , X ∪ Y(cid:18) |(cid:10) C(G ∨ H) iff X ∪ Y(cid:18) |(cid:10) C(G) or X ∪ Yor M |(cid:10) HGK , which is equivalent to M |(cid:10) (G ∨ H)GK .(cid:18) |(cid:10) C(G → H) iff X ∪ Y• Finally, if F is G → H . X ∪ YC(G) → C(H) iff (i) X ∪ Y(cid:18) |(cid:10) (G → H)(cid:18)and (ii) X ∪ Y(cid:18) |(cid:10) p iff p ∈ X . On the other hand, M |(cid:10) Kp iff p ∈ X too. Therefore,(cid:18) |(cid:10) C(H). By induction hypothesis, this holds iff M |(cid:10) G GK(cid:18) |(cid:10) C(H). By induction hypothesis, this holds iff M |(cid:10) G GK(cid:18) |(cid:10) (C(G) → C(H)) ∧ (G → H)(cid:18)(cid:18) (cid:11)|(cid:10) C(G) or X ∪ Yiff X ∪ Y(cid:18) |(cid:10) C(H). Notice that X ∪ Y(cid:18) |(cid:10) (G → H)(cid:18)and X ∪ Y(cid:18) |(cid:10) (G → H)(cid:18)(cid:18) |(cid:10)iffF. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277273(cid:18) |(cid:10) (G → H)(cid:18)YM (cid:11)|(cid:10) G GK or M |(cid:10) HGK iff M |(cid:10) (G → H)GK .iff Y |(cid:10) G → H iff M |(cid:10) (G → H) A . By induction hypothesis, X ∪ Y(cid:18) |(cid:10) C(F ) iff (i) M |(cid:10) (G → H) A and (ii)This completes the induction proof. (cid:2)Theorem 3. For any general logic program F in the language Atom, any set X ⊆ Atom, the following two statements are equivalent(1) There is a GK model M of F GK such that K (M) = A(M) = Th( X).(2) X ∪ X(cid:18)is a model of(cid:6)(cid:7)p ↔ p(cid:8)(cid:18)(cid:7)∧ CircumC(F ); Atom(cid:8).(4)p∈Atom(cid:18)(cid:18)(cid:18)Proof. (1) ⇒ (2): Suppose that M is a GK model of F GK and K (M) = A(M) = Th( X). Then M |(cid:10) F GK , by Lemma 2, X ∪ Xis a model of C(F ). We now show that for any set of atoms such that X1 ⊂ X , X1 ∪ Xis not a model of C(F ). Supposeotherwise, X1 ∪ Xis a model of C(F ). Construct a GK interpretation M1 such that K (M1) = Th( X1) and A(M1) = Th( X).By Lemma 2, M1 |(cid:10) F GK . It’s clear that K (M1) ⊂ K (M), A(M1) = A(M). This shows that M is not a GK model of F GK ,(cid:18)). Thisa contradiction. Therefore, X ∪ Xshows that statement (1) implies statement (2).is a model of Circum(C(F ); Atom). Of course, X ∪ Xp∈Atom(p ↔ pis a model of(cid:9)(1) ⇐ (2): Suppose that X ∪ Xis a model of Circum(C(F ); Atom). Thus X ∪ Xis a model of C(F ) and for every propersubset X1 of X , X1 ∪ Xis not a model of C(F ). Let M be a Kripke interpretation such that K (M) = A(M) = Th( X). We nowprove that M is a GK model of F GK . According to Lemma 2, M |(cid:10) F GK . We only need to prove that M is a minimal model.We prove it by contradiction. Assume that M is not a minimal model of F GK . Then there exists another model M1 of F GKsuch that A(M1) = A(M) = Th( X) and K (M1) ⊂ K (M). Construct another Kripke interpretation M2 such that A(M2) = Th( X)and K (M2) = Th( X1), where X1 = {p | M1 |(cid:10) Kp, p ∈ Atom}. For any general logic program G, by induction on the structure(cid:18) |(cid:10) C(F ).of G, M2 is a model of G GK iff M1 is a model of G GK . Therefore, M2 is a model of F GK . By Lemma 2, X1 ∪ Xis not a model of Circum(C(F ); Atom), a contradiction. Hence, M is a GK model of F GK . This showsMoreover, X1 ⊂ X . X ∪ Xthat statement (2) implies statement (1). (cid:2)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)A.3. Proof of Theorem 4Let L be a first order language with equality but without proper functions. Let C be the set of constants in L, and (cid:5) thethe extension of L by the new predicates(cid:18) | P ∈ (cid:5)} be a set of new predicates, and L(cid:18)set of predicates in L. Let (cid:5)(cid:18) = {Pin (cid:5)(cid:18).(cid:18)(cid:18)(cid:18)A first-order structure Mthe same domain, and they interpret all symbols in L the same. Suppose that Mto see that if M is a model of Σuna, then Msame.is said to be a conservative extension of a first-order structure M of L if Mand M haveis a conservative extension of M. It is easyis also a model of Σuna, and that for every sentence F , F M and F M(cid:18) are theof L(cid:18)(cid:18)Let F be a first order general logic program in L, and M a finite model of Σuna. We remark that F M can also be definedrecursively as follows (recall that σ is the mapping from constants in L to the domain of M under M).• ⊥M is ⊥.• If F is a = b, where a and b are two constants, then F M is (cid:15) when σ (a) is the same as σ (b), otherwise F M is ⊥.• If F is an atomic formula P ((cid:23)t), where (cid:23)t is a vector of constants, then F M is P (σ ((cid:23)t)), where σ ((cid:23)t) is (cid:8)σ (t1), . . . , σ (tn)(cid:9)when (cid:23)t is (cid:8)t1, . . . , tn(cid:9).(cid:14)(cid:9)• (G (cid:17) H)M is G M (cid:17) H M , where (cid:17) is ∧, ∨ or →.• (∃xF )M is• (∀xF )M isu∈D F (x/u)M .u∈D F (x/u)M .Thus given a first order general logic program F in L, F M is a propositional formula in A(M), the set of ground atomsin M:A(M) =(cid:2)(cid:3)(cid:3) P an n-ary predicate, (cid:23)u ∈ Dn, D the domain of M(cid:4),P ((cid:23)u)and C(F M ) is a propositional formula in A(M) ∪ A(M)(cid:18).Let M be a first-order structure. Recall that T (M) is the set of ground atoms true in M:(cid:4)(cid:2)T (M) =P ((cid:23)u)(cid:3)(cid:3) P a predicate, (cid:23)u ∈ P M.Lemma 3. Let M be a finite model of Σuna, and F a first order general logic program. We have that M is a model of F iff T (M) is amodel of F M .274F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277Proof. We prove it by induction on the structure of F .• If F is ⊥, then this assertion holds obviously.• If F is a = b, where a, b are constants, then F M is (cid:15) when a and b are the same; F M is ⊥ when a and b are twodistinct constants. On the other hand, since M is a model of Σuna, M is a model of F iff a is the same with b. Thereforethis assertion holds.• If F is an atomic formula p((cid:23)t), where (cid:23)t is a vector of constants, then F M is p(σ ((cid:23)t)). M is a model of F iff σ ((cid:23)t) ∈ p M iffp(σ ((cid:23)t)) ∈ T (M) iff T (M) is a model of F M .• If F is G ∧ H , then F M is G M ∧ H M . M is a model of F iff M is a model of G ∧ H iff M is a model of G and F is amodel of H iff T (M) is a model of G M and T (M) is a model of H M iff T (M) is a model of G M ∧ H M iff T (M) is amodel of F M .• If F is G ∨ H , then F M is G M ∨ H M . M is a model of F iff M is a model of G ∨ H iff M is a model of G or F is a modelof H iff T (M) is a model of G M or T (M) is a model of H M iff T (M) is a model of G M ∨ H M iff T (M) is a model of F M .• If F is G → H , then F M is G M → H M . M is a model of F iff M is a model of G → H iff M is not a model of G or F isa model of H iff T (M) is not a model of G M or T (M) is a model of H M iff T (M) is a model of G M → H M iff T (M) is amodel of F M .• If F is ∃xG, then F M isthere exists u ∈ D such that T (M) is a model of (G(x/u))M iff T (M) is a model ofof F M .u∈D (G(x/u))M . M is a model of F iff there exists u ∈ D such that M is a model of G(x/u) iffu∈D (G(x/u))M iff T (M) is a model(cid:14)(cid:14)• If F is ∀xG, then F M isu∈D (G(x/u))M . M is a model of F iff for all u ∈ D, M is a model of G(x/u) iff for all u ∈ D,(cid:9)(cid:9)T (M) is a model of (G(x/u))M iff T (M) is a model ofu∈D (G(x/u))M iff T (M) is a model of F . (cid:2)Lemma 4. Let M be a finite model of Σuna, and F a first order general logic program. We have that C(F M ) is equivalent to C(F )M .Proof. We prove it by induction on the structure of F .• If F is ⊥, this assertion holds obviously.• F is a = b, where a, b are constants. If a is the same with b, then both C(F M ) and (C(F ))M are (cid:15), otherwise both of• F is an atomic formula p((cid:23)t). Then F M is p(σ ((cid:23)t)), C(F M ) is also p(σ ((cid:23)t)). On the other hand, C(F ) is p((cid:23)t), (C(F ))M isthem are ⊥.p(σ ((cid:23)t)) too.• F is G ∧ H . Then C(F M ) is equivalent to C(G M ) ∧ C(H M ), which is equivalent to (C(G))M ∧ (C(H))M , which is equivalentto (C(G) ∧ C(H))M , which is equivalent to (C(G ∧ H))M , which is (C(F ))M .• F is G ∨ H . Then C(F M ) is equivalent to C(G M ) ∨ C(H M ), which is equivalent to (C(G))M ∨ (C(H))M , which is equivalentto (C(G) ∨ C(H))M , which is equivalent to (C(G ∨ H))M , which is (C(F ))M .• F is G → H . Then C(F M ) is C(G M → H M ), which is equivalent to (C(G M ) → C(H M )) ∧ (Gto (C(G)M → C(H)M ) ∧ (Gis equivalent to (C(G)M → C(H)M ) ∧ (GM is the same as (H M )(cid:18)structure M, H(cid:14)→ H(cid:18)(cid:18)M(cid:18)M ). On the other hand, C(F )M is equivalent to ((C(G) → C(H)) ∧ (G(cid:18)M ), which is equivalent(cid:18)))M , which(cid:18)M ). Moreover, it’s easy to see that for any first order sentence H and any(cid:18) → H→ H→ H(cid:18)M(cid:18)M. Hence, this assertion holds.(cid:14)(cid:14)• If F is ∃xG, then F M isthe other hand, C(F ) is ∃xC(G), (C(F ))M issee that for any first order formula H , C(H(x/u)) is equivalent to C(H)(x/u). Hence, this assertion holds.(cid:9)u∈D C((G(x/u))M ), which is equivalent tou∈D (C(G(x/u))M ). Onu∈D (C(G)(x/u))M . Moreover, by induction on the structure, it’s easy tou∈D (G(x/u))M . C(F M ) is(cid:9)(cid:14)(cid:9)• If F is ∀xG, then F M isu∈D (G(x/u))M . C(F M ) is(cid:9)the other hand, C(F ) is ∀xC(G), (C(F ))M isu∈D C((G(x/u))M ), which is equivalent tou∈D (C(G)(x/u))M . Similarly, this assertion holds. (cid:2)u∈D (C(G(x/u))M ). OnLemma 5. Let M be a finite model of Σuna, Mis a model of C(F ).is a model of C(F M ) iff M(cid:18)(cid:18)a conservative extension of M under (5), and F a first order sentence. Then T (M)∪ T (M)(cid:18)Proof. Since M(cid:18)is a conservative extension of M under (5), T (M(cid:18)) = T (M) ∪ T (M)(cid:18).(cid:18)) is a model of C(F )M(cid:18) (Lemma 3)is a model of C(F )(cid:18)MiffT (MiffT (M) ∪ T (M)(cid:18)iffT (M) ∪ T (M)(cid:18)is a model of C(F )Mis a model of C(F M ) (Lemma 4). (cid:2)Let M and Mbe two first order structures on Lwritten by M∗ ⊂(cid:5) M, if and only if:∗(cid:18)and (cid:5) the set of predicates in L. We say that M∗is less than M on (cid:5),F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277275∗∗have the same domain D.map every constant c in C into the same element in D.(cid:18) ∈ (cid:5)(cid:18)(1) M and M(2) M and M, (cid:23)u ∈ p(3) For each p(4) For all p ∈ (cid:5), if (cid:23)u ∈ p M(5) There is a p ∈ (cid:5) and some (cid:23)u such that (cid:23)u ∈ p M and (cid:23)u /∈ p Mi(cid:18)M(cid:18)M .iff (cid:23)u ∈ p∗, then (cid:23)u ∈ p M .∗.∗Thus M is a model of Circum(F ; (cid:5)) if and only if M is a model of F and there is no Mof F .∗ ⊂(cid:5) M such that M∗is also a modelLemma 6. Let M be a finite model of Σuna, Mhave that(cid:18)a conservative extension of M under (5), F a first order sentence, and S ⊆ A(M). We(1) S ⊂ T (M) iff there is M∗(2) For any Msuch that M∗such that M(cid:18)∗ ⊂(cid:5) M∗ ⊂(cid:5) M(cid:18)and T (M∗) = S ∪ T (M)(cid:18)∗) = S ∪ T (M)(cid:18), S ∪ T (M)(cid:18)and T (M.is a model of C(F M ) iff M∗is a model of C(F ).Proof. (1) is obvious. Proof of (2):is a model of C(F )∗) is a model of C(F )M∗ (Lemma 3)∗MiffT (MiffS ∪ T (M)(cid:18)iffS ∪ T (M)(cid:18)iffS ∪ T (M)(cid:18)is a model of C(F )M∗is a model of C(F )M (M and M∗have the same domain and interpret all constants the same)is a model of C(F M ) (Lemma 4). (cid:2)Theorem 4. Let M be a finite model of Σuna. M is a stable model of F iff M(cid:18)is a model of(cid:7)(cid:8)CircumC(F ); (cid:5)∧ (5),(6)where M(cid:18)is the conservative extension of M under (5).Proof. M is a stable model of FiffT (M) is a stable model of F M (by the definition)iffT (M) ∪ T (M)(cid:18)iffp∈ A(M)(p ↔ pis a model of(cid:9)(cid:18)) ∧ Circum(C(F M ); A(M)) (by Theorem 3)• T (M) ∪ T (M)(cid:18)• T (M) ∪ T (M)(cid:18)• for any S ⊆ A(M), if S ⊂ T (M), then S ∪ T (M)(cid:18)is a model ofis a model of C(F M );p∈ A(M)(p ↔ p(cid:18));(cid:9)is not a model of C(F M )iff(cid:18)(cid:18)• M• M• for any first order structure Mis a model of (5);is a model of C(F ) (by Lemma 5);, if M∗∗ ⊂(cid:5) M(cid:18), then M∗is not a model of C(F ) (by Lemma 6)(cid:18)iff Mis a model of (6). (cid:2)A.4. Proof of Theorems 5 and 6Theorem 5. Let F be a general logic program; X and Y two sets of atoms such that X ⊆ Y and M a Kripke interpretation such thatK (M) = Th( X), A(M) = Th(Y ). We have that (cid:8) X, Y (cid:9) |(cid:10) F iff M |(cid:10) F GK .Proof. As stated in [2], (cid:8) X, Y (cid:9) |(cid:10) F iff X |(cid:10) F Y . According to Lemma 1, X |(cid:10) F Y iff M |(cid:10) F GK , therefore, this assertionholds. (cid:2)Theorem 6. Let F and G be two general logic programs. The following statements are equivalent.1. F and G are strongly equivalent.F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277276(cid:9)(cid:9)(cid:9)(cid:9)2.3.4.5.p∈Atom(Kp → Ap) |(cid:10) (F ↔ G)GK .p∈Atom(Kp → Ap) |(cid:10) F GK ↔ G GK .p∈Atom(p → pp∈Atom(p → p(cid:18)) |(cid:10) C(F ↔ G).(cid:18)) |(cid:10) C(F ) ↔ C(G).(cid:9)p∈Atom(Kp → Ap). Construct a Kripke interpretation M1 such that K (M1) = Th( X)Proof. 1 ⇒ 2: Let M be a model ofand A(M1) = Th(Y ), where X = {p | M |(cid:10) Kp, p ∈ Atom}; Y = {p | M |(cid:10) Ap, p ∈ Atom}. It’s clear that M1 |(cid:10) (F ↔ G)GK iff(cid:9)p∈Atom(Kp → Ap), X ⊆ Y . Therefore (cid:8) X, Y (cid:9) is an HT-interpretation. Since F and GM |(cid:10) (F ↔ G)GK . Since M is a model ofare assumed to be strongly equivalent, they are equivalent in the logic of here-and-there. Thus (cid:8) X, Y (cid:9) |(cid:10) F ↔ G. Then byTheorem 5, M1 |(cid:10) (F ↔ G)GK . Therefore, M |(cid:10) (F ↔ G)GK . This shows thatp∈Atom(Kp → Ap) |(cid:10) (F ↔ G)GK .2 ⇒ 3: (F ↔ G)GK is ((F → G) ∧ (G → F ))GK , which is equivalent to (F → G)GK ∧ (G → F )GK , which is equivalent to(cid:9)(F GK → G GK) ∧ (F A → G A) ∧ (G GK → F GK) ∧ (G A → F A),(cid:9)which is equivalent to (F GK ↔ G GK ) ∧ (F A ↔ G A). This shows that (F ↔ G)GK |(cid:10) F GK ↔ G GK . Hence, this assertion holds.3 ⇒ 1: We first show that ifp∈Atom(Kp → Ap) |(cid:10) F GK ↔ G GK , then F is classically equivalent to G. Suppose otherwise,without loss of generality, X is a model of F but not a model of G. By the definition of reduction, it’s clear that X is amodel of F X . Construct a Kripke interpretation M such that K (M) = A(M) = Th( X). By Lemma 1, M is a model of F GK .Thus, M is also a model of G GK . Again by Lemma 1, X is a model of G X . Thus, X is a model of G, a contradiction. Hence, if(cid:9)p∈Atom(Kp → Ap) |(cid:10) F GK ↔ G GK . Therefore, by induction on the structure of H , it’s easy to see thatp∈Atom(Kp → Ap) |(cid:10) F GK ↔ G GK , then F is classically equivalent to G. Therefore, F A is equivalent to G A .Suppose that H is a general logic program and it contains an occurrence of F , H 1 is the general logic program obtainedfrom H by replacing an occurrence of F in H by G. We now show that H has the same set of stable models as H 1. By 3,(cid:9)p∈Atom(Kp → Ap) |(cid:10)HGK ↔ (H1)GK . Thus, HGK and (H1)GK has the same set of GK models. By Theorem 2, H has the same set of stable modelsas H1.2 ⇒ 4: Suppose(cid:9)p∈Atom(p → pis a model(cid:18)). Therefore, X ⊆ Y . Construct a Kripke interpretation M such that K (M) = Th( X) and A(M) = Th(Y ). Wep∈Atom(Kp → Ap). By 2, it’s also a model of (F ↔ G)GK . By Lemma 2, X ∪ Yis a model ofp∈Atom(p → pp∈Atom(Kp → Ap) |(cid:10) (F ↔ G)GK . Now, suppose that X and Y are two sets of atoms and X ∪ Yofhave that M is a model ofC(F ↔ G). This shows that(cid:18)) |(cid:10) C(F ↔ G).4 ⇒ 5: Similar to the proof of 2 ⇒ 3, C(F ↔ G) |(cid:10) C(F ) ↔ C(G). Hence, this assertion holds.5 ⇒ 1: Similar to the proof of 3 ⇒ 1. (cid:2)(cid:9)(cid:9)(cid:9)(cid:9)(cid:18)(cid:18)Let F be a propositional formula constructed with atoms and basic connectives (⊥, ∧, ∨ and →). Let Length(F ) be thetotal number of atoms and ⊥ occurring in F .Lemma 7.(cid:7)(cid:8)C(F )(cid:2)(cid:7)LengthLength(F ) + 1(cid:8)(cid:7)Length(F ) + 2(cid:8)/2 − 2.Proof. We prove this assertion by induction on the structure of F .• If F is ⊥, then Length(F ) = Length(C(F )) = 1. This assertion holds.• If F is an atom p, then Length(F ) = Length(C(F )) = 1. This assertion holds as well.• If F is G ∧ H or G ∨ H , then Length(C(F )) = Length(C(G)) + Length(C(H)) (cid:2) (Length(G) + 1)(Length(G) + 2)/2 −2 + (Length(H) + 1)(Length(H) + 2)/2 − 2 (cid:2) (Length(G) + Length(H) + 1)(Length(G) + Length(H) + 2)/2 − 2 (which isequivalent to 0 (cid:2) Length(G)Length(H) + 1) (cid:2) (Length(F ) + 1)(Length(F ) + 2)/2 − 2.• Finally, if F is G → H , then Length(C(F )) = Length(C(G)) + Length(C(H)) + Length(F ) (cid:2) (Length(G) + 1)(Length(G) +2)/2 − 2 + (Length(H) + 1)(Length(H) + 2)/2 − 2 + Length(G) + Length(H) (cid:2) (Length(G) + Length(H) + 1)(Length(G) +Length(H) + 2)/2 − 2 (which is equivalent to 0 (cid:2) (Length(G) − 1)(Length(H) − 1)) (cid:2) (Length(F ) + 1)(Length(F ) + 2)/2 − 2.This completes the proof. (cid:2)Corollary 7. The problem of deciding whether two general logic programs are strongly equivalent is co-NP complete.Proof. This assertion follows straightforwardly from Theorem 6 and Lemma 7. (cid:2)References[1] T. Eiter, M. Fink, H. Tompits, P. Traxler, S. Woltran, Replacements in non-ground answer-set programming, in: KR’2006, 2006, pp. 340–351.[2] P. Ferraris, Answer sets for propositional theories, in: LPNMR, 2005, pp. 119–131.F. Lin, Y. Zhou / Artificial Intelligence 175 (2011) 264–277277[3] P. Ferraris, V. Lifschitz, Mathematical foundations of answer set programming, in: We Will Show Them! (1), 2005, pp. 615–664.[4] P. Ferraris, J. Lee, V. Lifschitz, A new perspective on stable models, in: Proceedings of IJCAI’07, 2007, pp. 372–379.[5] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (1991) 365–385.[6] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Transactionson Computational Logic 7 (3) (2006) 499–562.[7] V. Lifschitz, L.R. Tang, H. Turner, Nested expressions in logic programs, Annals of Mathematics and Artificial Intelligence 25 (3–4) (1999) 369–389.[8] V. Lifschitz, D. Pearce, A. Valverde, Strongly equivalent logic programs, ACM Transactions on Computational Logic 2 (4) (2001) 526–541.[9] V. Lifschitz, Action languages, answer sets and planning, in: K.R. Apt, V.W. Marek, M. Truszczynski, D.S. Warren (Eds.), The Logic Programming Paradigm:A 25-Year Perspective, Springer-Verlag, 1999.[10] F. Lin, Y. Chen, Discovering classes of strongly equivalent logic programs, in: Proc. of IJCAI’95, 2005, pp. 516–521.[11] F. Lin, Y. Shoham, A logic of knowledge and justified assumptions, Artificial Intelligence 57 (1992) 271–289.[12] F. Lin, Reducing strong equivalence of logic programs to entailment in classical propositional logic, in: Proc. of KR’02, 2002, pp. 170–176.[13] V.W. Marek, M. Truszczynski, Stable logic programming – an alternative logic programming paradigm, in: K.R. Apt, V.W. Marek, M. Truszczynski, D.S.Warren (Eds.), The Logic Programming Paradigm: A 25-Year Perspective, Springer-Verlag, 1999.[14] J. McCarthy, Applications of circumscription to formalizing commonsense knowledge, Artificial Intelligence 28 (1986) 89–118.[15] R. Moore, Semantical considerations on nonmonotonic logic, Artificial Intelligence 25 (1) (1985) 75–94.[16] I. Niemelä, P. Simons, Extending the smodels system with cardinality and weight constraints, in: Jack Minker (Ed.), Logic-Based Artificial Intelligence,Kluwer Academic Publishers, 2000, pp. 491–521.[17] I. Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Annals of Mathematics and Artificial Intelligence 25 (3–4) (1999) 241–273.[18] D. Pearce, H. Tompits, S. Woltran, Encodings for equilibrium logic and logic programs with nested expressions, in: Proc. EPIA-01, 2001, pp. 306–320.[19] D. Pearce, A new logical characterisation of stable models and answer sets, in: Non-Monotonic Extensions of Logic Programming, 1997, pp. 57–70.[20] R. Reiter, A logic for default reasoning, Artificial Intelligence 13 (1980) 81–132.