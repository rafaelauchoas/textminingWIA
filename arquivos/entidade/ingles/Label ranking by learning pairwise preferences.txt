Artificial Intelligence 172 (2008) 1897–1916Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintLabel ranking by learning pairwise preferencesEyke Hüllermeier a,∗, Johannes Fürnkranz b, Weiwei Cheng a, Klaus Brinker aa Department of Mathematics and Computer Science, Philipps-Universität Marburg, Germanyb Department of Computer Science, TU Darmstadt, Germanya r t i c l ei n f oa b s t r a c tArticle history:Received 21 January 2008Received in revised form 14 July 2008Accepted 8 August 2008Available online 15 August 2008Keywords:Preference learningRankingPairwise classificationConstraint classification1. IntroductionPreference learning is an emerging topic that appears in different guises in the recentliterature. This work focuses on a particular learning scenario called label ranking, wherethe problem is to learn a mapping from instances to rankings over a finite number oflabels. Our approach for learning such a mapping, called ranking by pairwise comparison(RPC), first induces a binary preference relation from suitable training data using a naturalextension of pairwise classification. A ranking is then derived from the preference relationthus obtained by means of a ranking procedure, whereby different ranking methods canbe used for minimizing different loss functions. In particular, we show that a simple(weighted) voting strategy minimizes risk with respect to the well-known Spearman rankcorrelation. We compare RPC to existing label ranking methods, which are based on scoringindividual labels instead of comparing pairs of labels. Both empirically and theoretically, itis shown that RPC is superior in terms of computational efficiency, and at least competitivein terms of accuracy.© 2008 Elsevier B.V. All rights reserved.The topic of preferences has recently attracted considerable attention in Artificial Intelligence (AI) research, notably infields such as agents, non-monotonic reasoning, constraint satisfaction, planning, and qualitative decision theory [19].1 Pref-erences provide a means for specifying desires in a declarative way, which is a point of critical importance for AI. In fact,consider AI’s paradigm of a rationally acting (decision-theoretic) agent: The behavior of such an agent has to be driven byan underlying preference model, and an agent recommending decisions or acting on behalf of a user should clearly reflectthat user’s preferences.It is hence hardly surprising that methods for learning and predicting preferences in an automatic way are amongthe very recent research topics in disciplines such as machine learning, knowledge discovery, and recommender systems.Many approaches have been subsumed under the terms of ranking and preference learning, even though some of themare quite different and are not sufficiently well discriminated by existing terminology. We will thus start our paper with aclarification of its contribution (Section 2). The learning scenario that we will consider in this paper assumes a collectionof training examples which are associated with a finite set of decision alternatives. Following the common notation ofsupervised learning, we shall refer to the latter as labels. However, contrary to standard classification, a training example isnot assigned a single label, but a set of pairwise preferences between labels (which neither has to be complete nor entirely* Corresponding author.E-mail addresses: eyke@informatik.uni-marburg.de (E. Hüllermeier), juffi@ke.informatik.tu-darmstadt.de (J. Fürnkranz), cheng@informatik.uni-marburg.de(W. Cheng), brinker@informatik.uni-marburg.de (K. Brinker).1 The increasing activity in this area is also witnessed by several workshops that have been devoted to preference learning and related topics, such asthose at the NIPS-02, KI-03, SIGIR-03, NIPS-04, GfKl-05, IJCAI-05 and ECAI-2006 conferences (the second and fifth organized by two of the authors).0004-3702/$ – see front matter © 2008 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2008.08.0021898E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916Table 1Four different approaches to learning from preference information together withrepresentative referencesmodeling utility functionsmodeling pairwise preferencesobject rankinglabel rankingcomparison training [58]constraint classification [28]learning to order things [13]this work [24]consistent), each one expressing that one label is preferred over another. The goal is to learn to predict a total order, aranking, of all possible labels for a new training example.The ranking by pairwise comparison (RPC) algorithm, which we introduce in Section 3 of this paper, has a modular struc-ture and works in two phases. First, pairwise preferences are learned from suitable training data, using a natural extensionof so-called pairwise classification. Then, a ranking is derived from a set of such preferences by means of a ranking procedure.In Section 4, we analyze the computational complexity of the RPC algorithm. Then, in Section 5, it will be shown that, byusing suitable ranking procedures, RPC can minimize the risk for certain loss functions on rankings. Section 6 is devoted toan experimental evaluation of RPC and a comparison with alternative approaches applicable to the same learning problem.The paper closes with a discussion of related work in Section 7 and concluding remarks in Section 8. Parts of this paper arebased on [24,25,33].2. Learning from preferencesIn this section, we will motivate preference learning2 as a theoretically interesting and practically relevant subfield ofmachine learning. One can distinguish two types of preference learning problems, namely learning from object preferencesand learning from label preferences, as well as two different approaches for modeling the preferences, namely by evaluatingindividual alternatives (by means of a utility function), or by comparing (pairs of) competing alternatives (by means of apreference relation). Table 1 shows the four possible combinations thus obtained. In this section, we shall discuss theseoptions and show that our approach, label ranking by pairwise comparison, is still missing in the literature and hence anovel contribution.2.1. Learning from object preferencesThe most frequently studied problem in learning from preferences is to induce a ranking function r(·) that is able to orderany subset O of an underlying class X of objects. That is, r(·) assumes as input a subset O = {x1 . . . xn} ⊆ X of objects andreturns as output a permutation τ of {1 . . . n}. The interpretation of this permutation is that object xi is preferred to x jwhenever τ (i) < τ ( j). The objects themselves (e.g. websites) are typically characterized by a finite set of features as inconventional attribute-value learning. The training data consists of a set of exemplary pairwise preferences. This scenario,summarized in Fig. 1, is also known as “learning to order things” [13].As an example consider the problem of learning to rank query results of a search engine [35,52]. The training informationis provided implicitly by the user who clicks on some of the links in the query result and not on others. This informationcan be turned into binary preferences by assuming that the selected pages are preferred over nearby pages that are notclicked on [36].2.2. Learning from label preferencesIn this learning scenario, the problem is to predict, for any instance x (e.g., a person) from an instance space X , apreference relation (cid:4)x ⊆ L × L among a finite set L = {λ1 . . . λm} of labels or alternatives, where λi (cid:4)x λ j means thatinstance x prefers the label λi to the label λ j . More specifically, we are especially interested in the case where (cid:4)x is a totalstrict order, that is, a ranking of L. Note that a ranking (cid:4)x can be identified with a permutation τx of {1 . . . m}, e.g., thepermutation τx such that τx(i) < τx( j) whenever λi (cid:4)x λ j (τ (i) is the position of λi in the ranking). We shall denote theclass of all permutations of {1 . . . m} by Sm. Moreover, by abuse of notation, we shall sometimes employ the terms “ranking”and “permutation” synonymously.The training information consists of a set of instances for which (partial) knowledge about the associated preferencerelation is available (cf. Fig. 2). More precisely, each training instance x is associated with a subset of all pairwise preferences.Thus, even though we assume the existence of an underlying (“true”) ranking, we do not expect the training data to providefull information about that ranking. Besides, in order to increase the practical usefulness of the approach, we even allow forinconsistencies, such as pairwise preferences which are conflicting due to observation errors.2 We interpret the term “preference” not literally but in a wide sense as a kind of order relation. Thus, a (cid:4) b can indeed mean that alternative a is moreliked by a person than b, but also that a is an algorithm that outperforms b on a certain problem, that a is an event that is more probable than b, that ais a student finishing her studies before b, etc.E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19161899Given:• a (potentially infinite) reference set of objects X(each object typically represented by a feature vector)• a finite set of pairwise preferences xi (cid:4) x j , (xi , x j ) ∈ X × XFind:• a ranking function r(·) that assumes as input a set of objects O ⊆ X andreturns a permutation (ranking) of this setFig. 1. Learning from object preferences.Given:• a set of training instances {xk | k = 1 . . . n} ⊆ X(each instance typically represented by a feature vector)• a set of labels L = {λi | i = 1 . . . m}• for each training instance xk : a set of pairwise preferences of the formλi (cid:4)xk λ jFind:• a ranking function that maps any x ∈ X to a ranking (cid:4)x of L (permutationτx ∈ Sm)Fig. 2. Learning from label preferences.As in the case of object ranking, this learning scenario has a large number of practical applications. In the empirical part,we investigate the task of predicting a “qualitative” representation of a gene expression profile as measured by microarrayanalysis from phylogenetic profile features [4]. Another application scenario is meta-learning, where the task is to ranklearning algorithms according to their suitability for a new dataset, based on the characteristics of this dataset [10]. Finally,every preference statement in the well-known CP-nets approach [7], a qualitative graphical representation that reflectsconditional dependence and independence of preferences under a ceteris paribus interpretation, formally corresponds to alabel ranking.In addition, it has been observed by several authors [17,24,28] that many conventional learning problems, such as classi-fication and multi-label classification, may be formulated in terms of label preferences:• Classification: A single class label λi is assigned to each example xk. This implicitly defines the set of preferences {λi (cid:4)xkλ j | 1 (cid:2) j (cid:6)= i (cid:2) m}.• Multi-label classification: Each training example xk is associated with a subset Lk ⊆ L of possible labels. This implicitlydefines the set of preferences {λi (cid:4)xk λ j | λi ∈ Lk, λ j ∈ L \ Lk}.f : X → Sm is learned from a subset of all possible pairwise preferences.In each of the former scenarios, a ranking modelA suitable projection may be applied to the ranking model (which outputs permutations) as a post-processing step, forexample a projection to the top-rank in classification learning where only this label is relevant.2.3. Learning utility functionsAs mentioned above, one natural way to represent preferences is to evaluate individual alternatives by means of a (real-valued) utility function. In the object preferences scenario, such a function is a mapping f : X → R that assigns a utilitydegree f (x) to each object x and, hence, induces a complete order on X . In the label preferences scenario, a utility functionf i : X → R is needed for each of the labels λi , i = 1 . . . m. Here,f i(x) is the utility assigned to alternative λi by instance x.To obtain a ranking for x, the alternatives are ordered according to these utility scores, i.e., λi (cid:8)x λ j ⇔ f i(x) (cid:3) f j(x).If the training data would offer the utility scores directly, preference learning would reduce to a standard regressionproblem (up to a monotonic transformation of the utility values). This information can rarely be assumed, however. Instead,usually only constraints derived from comparative preference information of the form “This object (or label) should have ahigher utility score than that object (or label)” are given. Thus, the challenge for the learner is to find a function that is asmuch as possible in agreement with all constraints.For object ranking approaches, this idea has first been formalized by Tesauro [58] under the name comparison training.He proposed a symmetric neural-network architecture that can be trained with representations of two states and a trainingsignal that indicates which of the two states is preferable. The elegance of this approach comes from the property thatone can replace the two symmetric components of the network with a single network, which can subsequently provide areal-valued evaluation of single states. Later works on learning utility function from object preference data include [27,31,35,60]Subsequently, we outline two approaches, constraint classification (CC) and log-linear models for label ranking (LL), thatare direct alternatives to our method of ranking by pairwise comparison, and that we shall later on compare with.1900E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19162.3.1. Constraint classificationFor the case of label ranking, a corresponding method for learning the functions f i(·), i = 1 . . . m, from training data hasbeen proposed in the framework of constraint classification [28,29]. Proceeding from linear utility functionsf i(x) =n(cid:2)k=1αikxk(2.1)with label-specific coefficients αik, k = 1 . . . n, a preference λi (cid:4)x λ j translates into the constraint f i(x) − f j(x) > 0 or, equiva-lently, f j(x) − f i(x) < 0. Both constraints, the positive and the negative one, can be expressed in terms of the sign of an innerproduct (cid:10)z, α(cid:11), where α = (α11 . . . α1n, α21 . . . αmn) is a concatenation of all label-specific coefficients. Correspondingly, thevector z is constructed by mapping the original (cid:5)-dimensional training example x = (x1 . . . x(cid:5)) into an (m × (cid:5))-dimensionalspace: For the positive constraint, x is copied into the components ((i − 1) × (cid:5) + 1) . . . (i × (cid:5)) and its negation −x intothe components (( j − 1) × (cid:5) + 1) . . . ( j × (cid:5)); the remaining entries are filled with 0. For the negative constraint, a vectoris constructed with the same elements but reversed signs. Both constraints can be considered as training examples for aconventional binary classifier in an (m × (cid:5))-dimensional space: The first vector is a positive and the second one a negativeexample. The corresponding learner tries to find a separating hyperplane in this space, that is, a suitable vector α satisfyingall constraints. For classifying a new example e, the labels are ordered according to the response resulting from multiply-ing e with the i-th (cid:5)-element section of the hyperplane vector. To work with more general types of utility functions, themethod can obviously be kernelized.Alternatively, Har-Peled et al. [28,29] propose an online version of constraint classification, namely an iterative algorithmthat maintains weight vectors α1 . . . αm ∈ R(cid:5) for each label individually. In every iteration, the algorithm checks each con-straint λi (cid:4)x λ j and, in case the associated inequality αi × x = f i(x) > f j(x) = α j × x is violated, adapts the weight vectorsαi, α j appropriately. In particular, using perceptron training, the algorithm can be implemented in terms of a multi-outputperceptron in a way quite similar to the approach of Grammer and Singer [15].2.3.2. Log-linear models for label rankingSo-called log-linear models for label ranking have been proposed in Dekel et al. [17]. Here, utility functions are expressedin terms of linear combinations of a set of base ranking functions:(cid:2)f i(x) =α jh j(x, λi),jwhere a base function h j(·) maps instance/label pairs to real numbers. Interestingly, for the special case in which instancesare represented as feature vectors x = (x1 . . . x(cid:5)) and the base functions are of the formhkj(x, λ) =xk λ = λ jλ (cid:6)= λ j0(1 (cid:2) k (cid:2) (cid:5), 1 (cid:2) j (cid:2) m),(2.2)(cid:3)the approach is essentially equivalent to CC, as it amounts to learning class-specific utility functions (2.1). Algorithmically,however, the underlying optimization problem is approached in a different way, namely by means of a boosting-basedalgorithm that seeks to minimize a (generalized) ranking error in an iterative way.2.4. Learning preference relationsThe key idea of this approach is to model the individual preferences directly instead of translating them into a utilityfunction. This seems a natural approach, since it has already been noted that utility scores are difficult to elicit and observedpreferences are usually of the relational type. For example, it is very hard to ensure a consistent scale even if all utilityevaluations are performed by the same user. The situation becomes even more problematic if utility scores are elicited fromdifferent users, which may not have a uniform scale of their scores [13]. For the learning of preferences, one may bring upa similar argument. It will typically be easier to learn a separate theory for each individual preference that compares twoobjects or two labels and determines which one is better. Of course, every learned utility function that assigns a score to aset of labels L induces such a binary preference relation on these labels.For object ranking problems, the pairwise approach has been pursued in [13]. The authors propose to solve object rankingor vice versa. A finalproblems by learning a binary preference predicate Q (x, xordering is found in a second phase by deriving a ranking that is maximally consistent with these predictions.(cid:12)(cid:12)), which predicts whether x is preferred to xFor label ranking problems, the pairwise approach has been introduced by Fürnkranz and Hüllermeier [24]. The keyidea, to be described in more detail in Section 3, is to learn, for each pair of labels (λi, λ j), a binary predicate Mi j(x) thatpredicts whether λi (cid:4)x λ j or λ j (cid:4)x λi for an input x. In order to rank the labels for a new object, predictions for all pairwiselabel preferences are obtained and a ranking that is maximally consistent with these preferences is derived.3. Label ranking by learning pairwise preferencesThe key idea of ranking by pairwise comparison (RPC) is to reduce the problem of label ranking to several binary classi-fication problems (Sections 3.1 and 3.2). The predictions of this ensemble of binary classifiers can then be combined intoE. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19161901a ranking using a separate ranking algorithm (Section 3.3). We consider this modularity of RPC as an important advantageof the approach. Firstly, the binary classification problems are comparably simple and efficiently learnable. Secondly, as willbecome clear in the remainder of the paper, different ranking algorithms allow the ensemble of pairwise classifiers to adaptto different loss functions on label rankings without the need for re-training the pairwise classifiers.3.1. Pairwise classificationThe key idea of pairwise learning is well-known in the context of classification [22], where it allows one to transform amulti-class classification problem, i.e., a problem involving m > 2 classes L = {λ1 . . . λm}, into a number of binary problems.To this end, a separate model (base learner) Mi j is trained for each pair of labels (λi, λ j) ∈ L, 1 (cid:2) i < j (cid:2) m; thus, a totalnumber of m(m − 1)/2 models is needed. Mi j is intended to separate the objects with label λi from those having label λ j .At classification time, a query instance is submitted to all models Mi j , and their predictions are combined into an overallprediction. In the simplest case, each prediction of a model Mi j is interpreted as a vote for either λi or λ j , and the labelwith the highest number of votes is proposed as a final prediction.3Pairwise classification has been tried in the areas of statistics [8,21], neural networks [40,41,44,51], support vector ma-chines [30,32,42,54], and others. Typically, the technique learns more accurate theories than the more commonly usedone-against-all classification method, which learns one theory for each class, using the examples of this class as positiveexamples and all others as negative examples.4 Surprisingly, it can be shown that pairwise classification is also computa-tionally more efficient than one-against-all class binarization (cf. Section 4).3.2. Learning pairwise preferenceThe above procedure can be extended to the case of preference learning in a natural way [24]. Again, a preference(order) information of the form λa (cid:4)x λb is turned into a training example (x, y) for the learner Mi j , where i = min(a, b)and j = max(a, b). Moreover, y = 1 if a < b and y = 0 otherwise. Thus, Mi j is intended to learn the mapping that outputs1 if λi (cid:4)x λ j and 0 if λ j (cid:4)x λi :(cid:3)x (cid:13)→1 if λi (cid:4)x λ j,0 if λ j (cid:4)x λi.(3.1)The model is trained with all examples xk for which either λi (cid:4)xk λ j or λ j (cid:4)xk λi is known. Examples for which nothing isknown about the preference between λi and λ j are ignored.The mapping (3.1) can be realized by any binary classifier. Alternatively, one may also employ base classifiers that mapinto the unit interval [0, 1] instead of {0, 1}, and thereby assign a valued preference relation Rx to every (query) instancex ∈ X :(cid:3)Rx(λi, λ j) =Mi j(x)1 − M ji(x)if i < j,if i > j(3.2)for all λi (cid:6)= λ j ∈ L. The output of a [0, 1]-valued classifier can usually be interpreted as a probability or, more generally, akind of confidence in the classification: the closer the output of Mi j to 1, the stronger the preference λi (cid:4)x λ j is supported.Fig. 3 illustrates the entire process for a hypothetical dataset with eight examples that are described with three binaryattributes (A1, A2, A3) and preferences among three labels (a, b, c). First, the original training set is transformed into threetwo-class training sets, one for each possible pair of labels, containing only those training examples for which the relationbetween these two labels is known. Then three binary models, Mab, Mbc , and Mac are trained. In our example, the resultcould be simple rules like the following:Mab: a > b if A2 = 1.Mbc: b > cif A3 = 1.Mac: a > cif A1 = 1 ∨ A3 = 1.Given a new example with an unknown preference structure (shown in the bottom left of Fig. 3), the predictions ofthese models are then used to predict a ranking for this example. As we will see in the next section, this is not always astrivial as in this example.3 Ties can be broken in favor or prevalent classes, i.e., according to the class distribution in the classification setting.4 Rifkin and Klautau [53] have argued that, at least in the case of support vector machines, one-against-all can be as effective provided that the binarybase classifiers are carefully tuned.1902E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916Fig. 3. Schematic illustration of learning by pairwise comparison.3.3. Combining predicted preferences into a rankingGiven a predicted preference relation Rx for an instance x, the next question is how to derive an associated ranking τx.This question is non-trivial, since a relation Rx does not always suggest a unique ranking in an unequivocal way. For exam-ple, the learned preference relation need not be transitive (cf. Section 3.4). In fact, the problem of inducing a ranking from a(valued) preference relation has received a lot of attention in several research fields, e.g., in fuzzy preference modeling and(multi-attribute) decision making [20]. In the context of pairwise classification and preference learning, several studies haveempirically compared different ways of combining the predictions of individual classifiers [2,23,34,62].A simple though effective strategy is a generalization of the aforementioned voting strategy: each alternative λi is eval-uated by the sum of (weighted) votesS(λi) =Rx(λi, λ j),(cid:2)λ j (cid:6)=λiand all labels are then ordered according to these evaluations, i.e., such that(λi (cid:4)x λ j) ⇒(cid:4)(cid:5)S(λi) (cid:3) S(λ j).(3.3)(3.4)Even though this ranking procedure may appear rather ad-hoc at first sight, we shall give a theoretical justification inSection 5, where it will be shown that ordering the labels according to (3.3) minimizes a reasonable loss function onrankings.3.4. TransitivityOur pairwise learning scheme as outlined above produces a relation Rx by learning the preference degrees Rx(λi, λ j)independently of each other. In this regard, one may wonder whether there are no interdependencies between these de-grees that should be taken into account. In particular, as transitivity of pairwise preferences is one of the most importantproperties in preference modeling, an interesting question is whether any sort of transitivity can be guaranteed for Rx.Obviously, the learned binary preference relation does not necessarily have the typical properties of order relations. Forexample, transitivity will in general not hold, because if λi (cid:4)x λ j and λ j (cid:4)x λk, the independently trained classifier Mik maystill predict λk (cid:4)x λi .5 This is not a problem, because the subsequent ranking phase will convert the intransitive predictivepreference relation into a total preference order.However, it can be shown that, given the formal assumptions of our setting, the following weak form of transitivity mustbe satisfied:∀ i, j, k ∈ {1 . . . m}: Rx(λi, λ j) (cid:3) Rx(λi, λk) + Rx(λk, λ j) − 1.(3.5)5 In fact, not even symmetry needs to hold if Mi j and M ji are different models, which is, e.g., the case for rule learning algorithms [22]. This situationmay be compared with round robin sports tournament, where individual results do not necessarily conform to the final ranking that is computed fromthem.E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19161903As a consequence of this property, which is proved in Appendix A, the predictions obtained by an ensemble of pairwiselearners Mi j should actually satisfy (3.5). In other words, training the learners independently of each other is indeed notfully legitimate. Fortunately, our experience so far has shown that the probability to violate (3.5) is not very high. Still,forcing (3.5) to hold is a potential point of improvement and part of ongoing work.4. Complexity analysisIn this section, we will generalize previous results on the efficiency of pairwise classification to preference learning. Inparticular, we will show that this approach can be expected to be computationally more efficient than alternative approacheslike constraint classification that try to model the preference learning problem as a single binary classification problem in ahigher-dimensional space (cf. Section 2.3).4.1. Ranking by pairwise comparisonFirst, we will bound the number of training examples used by the pairwise approach. Let |P k| be the number of prefer-|P k| the average number ofences that are associated with example xk. Throughout this section, we denote by d = 1/n ·preferences over all examples.(cid:6)kLemma 1. The total number of training examples constructed by RPC is n · d, which is bounded by n · m(m − 1)/2, i.e.,n(cid:2)k=1|P k| = n · d (cid:2) n · m(m − 1)2.Proof. Each of the n training examples will be added to all |P k| binary training sets that correspond to one of its preferences.|P k| = n · d. This is bounded from above by the size of a complete setThus, the total number of training examples isof preferences n · m(m − 1)/2. (cid:2)(cid:6)nk=1The special case for classification, where the number of training examples grow only linearly with the number of classes[22], can be obtained as a corollary of this theorem, because for classification, each class label expands to d = m − 1preferences.As a consequence, it follows immediately that RPC using a base algorithm with a linear run-time complexity O(n) has atotal run-time of O(d · n). More interesting is the general case.Theorem 1. For a base learner with complexity O(na), the complexity of RPC is O(d · na).Proof. Let ni j be the number of training examples for model Mi j . Each example corresponds to a single preference, i.e.,(cid:2)1(cid:2)i< j(cid:2)mni j =n(cid:2)k=1|P k| = d · n(cid:6)and the total learning complexity isO(nai j). We now obtain(cid:8)(cid:7)(cid:7)(cid:8)a(cid:6)O(nai j)O(d · na)= 1d(cid:2) 1d(cid:2) O(nai j)O(na)(cid:7)ni jn(cid:2)O= 1d(cid:8)=(cid:2)O(cid:6)O(ni j)d · O(n)ni jn=(cid:6)O(ni j)O(d · n)=O(d · n)O(d · n)= O(1).The inequality holds because each example can have at most one preference involving the pair of labels (λi, λ j). Thus,ni j (cid:2) n. (cid:2)Again, we obtain as a corollary that the complexity of pairwise classification is only linear in the number of classesO(m · na), for which an incomplete proof was previously given in [22].4.2. Constraint classification and log-linear modelsFor comparison, CC converts each example into a set of examples, one positive and one negative for each preference.This construction leads to the following complexity.Theorem 2. For a base learner with complexity O(na), the total complexity of constraint classification is O(da · na).1904E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916|P k| = 2dn examples, which means that CC constructsProof. CC transforms the original training data into a set of 2twice as many training examples as RPC. If this problem is solved with a base learner with complexity O(na), the totalcomplexity is O((2dn)a) = O(da · na). (cid:2)(cid:6)nk=1Moreover, the newly constructed examples are projected into a space that has m times as many attributes as the originalspace.A direct comparison is less obvious for the online version of CC whose complexity strongly depends on the number ofiterations needed to achieve convergence. In a single iteration, the algorithm checks all constraints for every instance and,in case a constraint is violated, adapts the weight vector correspondingly. The complexity is hence O(n · d · (cid:5) · T ), where (cid:5) isthe number of attributes of an instance (dimension of the instance space) and T the number of iterations.For the same reason, it is difficult to compare RPC with the boosting-based algorithm proposed for log-linear modelsby Dekel et al. [17]. In each iteration, the algorithm essentially updates the weights that are associated with each instanceand preference constraint. In the label ranking setting considered here, the complexity of this step is O(d · n). Moreover,the algorithm maintains weight coefficients for each base ranking function. If specified as in (2.2), the number of thesefunctions is m · (cid:5). Therefore, the total complexity of LL is O((d · n + m · (cid:5)) · T ), with T the number of iterations.4.3. DiscussionIn summary, the overall complexity of pairwise label ranking depends on the average number of preferences that aregiven for each training example. While being quadratic in the number of labels if a complete ranking is given, it is onlylinear for the classification setting. In any case, it is no more expensive than constraint classification and can be considerablycheaper if the complexity of the base learner is super-linear (i.e., a > 1). The comparison between RPC and LL is less obviousand essentially depends on how na relates to n · T (note that, implicitly, T also depends on n, as larger data sets typicallyneed more iterations).A possible disadvantage of RPC concerns the large number of classifiers that have to be stored. Assuming an input spaceX of dimensionality (cid:5) and simple linear classifiers as base learners, the pairwise approach has to store O((cid:5) · m2) parameters,whereas both CC and LL only need to store O((cid:5) · m) parameters to represent their ranking model. (During training, however,the boosting-based optimization algorithm in LL must also store a typically much higher number of n · d parameters, onefor each preference constraint.)As all the model parameters have to be used for deriving a label ranking, this may also affect the prediction time.However, for the classification setting, it was shown in [48] that a more efficient algorithm yields the same predictions asvoting in almost linear time (≈ O((cid:5) · m)). To what extent this algorithm can be generalized to label ranking is currentlyunder investigation. As ranking is basically a sorting of all possible labels, we expect that this can be done in log-linear time(O((cid:5) · m log m)).5. Risk minimizationEven though the approach to pairwise ranking as outlined in Section 3 appears intuitively appealing, one might arguethat it lacks a solid foundation and remains ad-hoc to some extent. For example, one might easily think of ranking proce-dures other than (3.3), leading to different predictions. In any case, one might wonder whether the rankings predicted onthe basis of (3.2) and (3.3) do have any kind of optimality property. An affirmative answer to this question will be given inthis section.5.1. PreliminariesRecall that, in the setting of label ranking, we associate every instance x from an instance space X with a ranking ofa finite set of class labels L = {λ1 . . . λm} or, equivalently, with a permutation τx ∈ Sm (where Sm denotes the class of allpermutations of {1 . . . m}). More specifically, and in analogy with the setting of conventional classification, every instance isassociated with a probability distribution over the class of rankings (permutations) Sm. That is, for every instance x, thereexists a probability distribution P(· | x) such that, for every τ ∈ Sm, P(τ | x) is the probability to observe the ranking τ asan output, given the instance x as an input.The quality of a model M (induced by a learning algorithm) is commonly measured in terms of its expected loss or risk(cid:4)(cid:4)DEy, M(x)(cid:5)(cid:5),(5.1)where D(·) is a loss or distance function, M(x) denotes the prediction made by the model for the instance x, and y is thetrue outcome. The expectation E is taken over X × Y , where Y is the output space;6 in our case, Y is given by Sm.6 The existence of a probability measure over X × Y must of course be assumed.E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–191619055.2. Spearman’s rank correlationAn important and frequently applied similarity measure for rankings is the Spearman rank correlation, originally proposedby Spearman [57] as a nonparametric rank statistic to measure the strength of the associations between two variables [43].It is defined as follows1 − 6D(τ , τ (cid:12))m(m2 − 1)as a linear transformation (normalization) of the sum of squared rank distancesD(τ (cid:12), τ ) df=m(cid:2)(cid:4)τ (cid:12)(cid:5)(i) − τ (i)2i=1(5.2)(5.3)to the interval [−1, 1]. As will now be shown, RPC is a risk minimizer with respect to (5.3) (and hence Spearman rankcorrelation) as a distance measure under the condition that the binary models Mi j provide correct probability estimates,i.e.,Rx(λi, λ j) = Mi j(x) = P(λi (cid:4)x λ j).That is, if (5.4) holds, then RPC yields a risk minimizing predictionˆτx = arg minτ ∈Sm(cid:2)τ (cid:12)∈SmD(τ , τ (cid:12)) · P(τ (cid:12) | x)(5.4)(5.5)if D(·) is given by (5.3). Admittedly, (5.4) is a relatively strong assumption, as it requires the pairwise preference probabil-ities to be perfectly learnable. Yet, the result (5.5) sheds light on the aggregation properties of our technique under idealconditions and provides a valuable basis for further analysis. In fact, recalling that RPC consists of two steps, namely pair-wise learning and ranking, it is clear that in order to study properties of the latter, some assumptions about the result of theformer step have to be made. And even though (5.4) might at best hold approximately in practice, it seems to be at leastas natural as any other assumption about the output of the ensemble of pairwise learners.Lemma 2. Let si , i = 1 . . . m, be real numbers such that 0 (cid:2) s1 (cid:2) s2 (cid:2) · · · (cid:2) sm. Then, for all permutations τ ∈ Sm,m(cid:2)(i − si)2 (cid:2)m(cid:2)(i − sτ (i))2.i=1i=1(5.6)Proof. We havem(cid:2)(i − sτ (i))2 =i=1=m(cid:2)(i − si + si − sτ (i))2i=1m(cid:2)(i − si)2 + 2i=1m(cid:2)i=1Expanding the last equation and exploiting that(i − si)(si − sτ (i)) +m(cid:2)(si − sτ (i))2.(cid:6)mi=1 s2i=(cid:6)i=1mi=1 s2τ (i) yieldsm(cid:2)(i − sτ (i))2 =m(cid:2)(i − si)2 + 2i=1i=1m(cid:2)i=1i si − 2m(cid:2)i=1i sτ (i).(cid:6)i=1 isτ (i) depends on τ . This term is maximal for τ (i) = i,On the right-hand side of the last equation, only the last termbecause si (cid:2) s j for i < j, and therefore maxi=1...m msi = msm, maxi=1...m−1(m − 1)si = (m − 1)sm−1, etc. Thus, the differencei=1(i − si)2, which proves theof the two sums is always positive, and the right-hand side is larger than or equal tolemma. (cid:2)(cid:6)mmLemma 3. Let P(· | x) be a probability distribution over Sm. Moreover, let(cid:2)df= m −siP(λi (cid:4)x λ j)j(cid:6)=iwithP(λi (cid:4)x λ j) =(cid:2)P(τ | x).Then, si =(cid:6)ττ : τ (i)<τ ( j)P(τ | x)τ (i).(5.7)(5.8)1906E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916Proof. We have(cid:2)si = m −P(λi (cid:4)x λ j)j(cid:6)=i(cid:2)(cid:5)(cid:4)1 − P(λi (cid:4)x λ j)= 1 += 1 += 1 += 1 += 1 +j(cid:6)=i(cid:2)j(cid:6)=i(cid:2)j(cid:6)=i(cid:2)τ(cid:2)P(λ j (cid:4)x λi)(cid:2)P(τ | x)τ : τ ( j)<τ (i)(cid:2)P(τ | x)(cid:3)j(cid:6)=i(cid:4)P(τ | x)(cid:5)τ (i) − 11 if τ (i) > τ ( j)0 if τ (i) < τ ( j)(cid:2)τP(τ | x)τ (i).=(cid:2)τNote that si (cid:2) s jis equivalent to S(λi) (cid:3) S(λ j) (as defined in (3.3)) under the assumption (5.4). Thus, ranking thealternatives according to S(λi) (in decreasing order) is equivalent to ranking them according to si (in increasing order).Theorem 3. The expected distance(cid:4)ED(τ (cid:12)(cid:5), τ ) | x=(cid:2)τbecomes minimal by choosing τ (cid:12)Proof. We haveP(τ | x) · D(τ (cid:12), τ ) =(cid:2)P(τ | x)m(cid:2)(cid:4)τ (cid:12)(cid:5)2(i) − τ (i)i=1such that τ (cid:12)(i) (cid:2) τ (cid:12)( j) whenever si (cid:2) s j , with si given by (5.7).τ(cid:4)ED(τ (cid:12)(cid:5), τ ) | x=(cid:2)P(τ | x)m(cid:2)(cid:4)τ (cid:12)(cid:5)2(i) − τ (i)τm(cid:2)(cid:2)i=1m(cid:2)τ(cid:2)i=1m(cid:2)τ(cid:2)i=1(cid:4)τ (cid:12)P(τ | x)(cid:5)2(i) − τ (i)(cid:4)τ (cid:12)P(τ | x)(cid:5)(i) − si + si − τ (i)2(cid:9)(cid:4)P(τ | x)τ (i) − si(cid:4)(cid:5)2 − 2τ (i) − si(cid:5)(cid:4)si − τ (cid:12)(cid:4)(cid:5)(i)+si − τ (cid:12)(cid:10)2(cid:5)(i)i=1m(cid:2)τ(cid:11)(cid:2)i=1τ(cid:4)P(τ | x)τ (i) − si(cid:5)(cid:4)2 − 2si − τ (cid:12)(cid:5)(cid:2)(i)(cid:4)τ (i) − siP(τ | x)(cid:5)+τ(cid:4)P(τ | x)si − τ (cid:12)(cid:5)(i)2(cid:12).(cid:2)τ====In the last equation, the mid-term on the right-hand side becomes 0 according to Lemma 3. Moreover, the last termobviously simplifies to (si − τ (cid:12)(i))2, and the first term is a constant c =P(τ | x)(τ (i) − si)2 that does not depend on τ (cid:12).Thus, we obtain E(D(τ (cid:12), τ ) | x) = c +i=1(si − τ (cid:12)(i))2 and the theorem follows from Lemma 2. (cid:2)(cid:6)(cid:6)mτ5.3. Kendall’s tauThe above result shows that our approach to label ranking in the form presented in Section 3 is particularly tailoredto (5.3) as a loss function. We like to point out, however, that RPC is not restricted to this measure but can also minimizeother loss functions. As mentioned previously, this can be accomplished by replacing the ranking procedure in the secondstep of RPC in a suitable way. To illustrate, consider the well-known Kendall tau measure [38] as an alternative loss function.This measure essentially calculates the number of pairwise rank inversions on labels to measure the ordinal correlation oftwo rankings; more formally, withD(τ (cid:12)(cid:13), τ ) df= #(i, j)(cid:14)(cid:14) i < j, τ (i) > τ ( j) ∧ τ (cid:12)(i) < τ (cid:12)(cid:15)( j)(5.9)E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19161907denoting the number of discordant pairs of items (labels), the Kendall tau coefficient is given by 1 − 4D(τ (cid:12), τ )/(m(m − 1)),that is, by a linear scaling of D(τ (cid:12), τ ) to the interval [−1, +1].Now, for every ranking τ (cid:12)(cid:2),(cid:4)ED(τ (cid:12)(cid:5), τ ) | x=P(τ ) × D(τ (cid:12)τ ∈Sm(cid:2)τ ∈SmP(τ | x) ×, τ )(cid:2)i< j|τ (cid:12)(i)<τ (cid:12)( j)(cid:2)(cid:2)P(τ | x) ×i< j|τ (cid:12)(i)<τ (cid:12)( j)(cid:2)τ ∈SmP(λi (cid:4)x λ j).i< j|τ (cid:12)(i)<τ (cid:12)( j)===(cid:3)(cid:3)1 if τ (i) > τ ( j)0 if τ (i) < τ ( j)1 if τ (i) > τ ( j)0 if τ (i) < τ ( j)(5.10)(5.11)Thus, knowing the pairwise probabilities P(λi (cid:4)x λ j) is again enough to derive the expected loss for every ranking τ (cid:12). Inother words, RPC can also make predictions which are optimal for (5.9) as an underlying loss function. To this end, onlythe ranking procedure has to be adapted while the same pairwise probabilities (predictions of the pairwise learners) can beused.Finding the ranking that minimizes (5.10) is formally equivalent to solving the graph-theoretical feedback arc set problem(for weighted tournaments) which is known to be NP complete [3]. Of course, in the context of label ranking, this resultshould be put into perspective, because the set of class labels is typically of small to moderate size. Nevertheless, froma computational point of view, the ranking procedure that minimizes Kendall’s tau is definitely more complex than theprocedure for minimizing Spearman’s rank correlation.5.4. Connections with voting theoryIt is worth mentioning that the voting strategy in RPC, as discussed in Section 5.2, is closely related to the so-calledBorda-count, a voting rule that is well-known in social choice theory [9]: Suppose that the preferences of n voters areexpressed in terms of rankings τ1, τ2 . . . τn of m alternatives. From a ranking τi , the following scores are derived for thealternatives: The best alternative receives m − 1 points, the second best m − 2 points, and so on. The overall score of analternative is the sum of points that it has received from all voters, and a representative ranking ˆτ (aggregation of the singlevoters’ rankings) is obtained by ordering the alternatives according to these scores.Now, it is readily verified that the result obtained by this procedure corresponds exactly to the result of RPC if theprobability distribution over the class Sm of rankings is defined by the corresponding relative frequencies. In other words,the ranking ˆτ obtained by RPC minimizes the sum of all distances:ˆτ = arg minτ ∈Smn(cid:2)i=1D(τ , τi).(5.12)A ranking of that kind is sometimes called central ranking.7In connection with social choice theory it is also interesting to note that RPC does not satisfy the so-called Condorcetcriterion: As the pairwise preferences in our above example show, it is thoroughly possible that an alternative (in thiscase λ1) is preferred in all pairwise comparisons (R(λ1, λ2) > .5 and R(λ1, λ3) > .5) without being the overall winner ofthe election (top-label in the ranking). Of course, this apparently paradoxical property is not only relevant for ranking butalso for classification. In this context, it has already been recognized by Hastie and Tibshirani [30].Another distance (similarity) measure for rankings, which plays an important role in voting theory, is the aforemen-tioned Kendall tau. When using the number of discordant pairs (5.9) as a distance measure D(·) in (5.12), ˆτ is also calledthe Kemeny-optimal ranking. Kendall’s tau is intuitively quite appealing and Kemeny-optimal rankings have several niceproperties. However, as noted earlier, one drawback of using Kendall’s tau instead of rank correlation as a distance mea-sure in (5.12) is a loss of computational efficiency. In fact, the computation of Kemeny-optimal rankings is known to beNP-hard [5].6. Empirical evaluationThe experimental evaluation presented in this section compares, in terms of accuracy and computational efficiency,ranking by pairwise comparison (RPC) with weighted voting to the constraint classification (CC) approach and log-linearmodels for label ranking (LL) as outlined, respectively, in Sections 2.3.1 and 2.3.2. CC in particular is a natural counterpart7 See, e.g., Marden’s book [45], which also contains results closely related to our results from Section 5.2.1908E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916Table 2Statistics for the semi-synthetic and real datasetsdatasetiriswineglassvowelvehiclespoheatdttcolddiau#examples#classes#features15017821452884624652465246524652465336114116447413910182424242424to compare with, as its approach is orthogonal to ours: instead of breaking up the label ranking problem into a set of smallpairwise learning problems, as we do, CC embeds the original problem into a single learning problem in a high-dimensionalfeature space. We implemented CC with support vector machines using a linear kernel as a binary classifier (CC-SVM).8Apart from CC in its original version, we also included an online-variant (CC-P) as proposed in [28], using a noise-tolerantperceptron algorithm as a base learner [37].9To guarantee a fair comparison, we use LL with (2.2) as base ranking functions, which means that it is based on thesame underlying model class as CC. Moreover, we implement RPC with simple logistic regression as a base learner,10 whichcomes down to fitting a linear model and using the logistic link function (logit(π ) = log(π /(1 − π ))) to derive [0, 1]-valuedscores, the type of model output requested in RPC. Essentially, all three approaches are therefore based on linear modelsand, in fact, they all produce linear decision boundaries between classes.11 Nevertheless, to guarantee full comparabilitybetween RPC and CC, we also implemented the latter with logistic regression as a base learner (CC-LR).6.1. DatasetsTo provide a comprehensive analysis under varying conditions, we considered different scenarios that can be roughlycategorized as real-world and semi-synthetic.The real-world scenario originates from the bioinformatics fields where ranking and multilabeled data, respectively, canfrequently be found. More precisely, our experiments considered two types of genetic data, namely phylogenetic profiles andDNA microarray expression data for the Yeast genome.12 The genome consists of 2465 genes, and each gene is representedby an associated phylogenetic profile of length 24. Using these profiles as input features, we investigated the task of predict-ing a “qualitative” representation of an expression profile: Actually, the expression profile of a gene is an ordered sequenceof real-valued measurements, such as (2.1, 3.5, 0.7, −2.5), where each value represents the expression level of that genemeasured at a particular point of time. A qualitative representation can be obtained by converting the expression levelsinto ranks, i.e., ordering the time points (= labels) according to the associated expression values. In the above example, thequalitative profile would be given by (2, 1, 3, 4), which means that the highest expression was observed at time point 2, thesecond-highest at time point 1, and so on. The use of qualitative profiles of that kind, and the Spearman correlation as asimilarity measure between them, was motivated in [4], both biologically and from a data analysis point of view.We used data from five microarray experiments (spo, heat, dtt, cold, diau), giving rise to five prediction problems allusing the same input features but different target rankings. It is worth mentioning that these experiments involve differentnumbers of measurements, ranging from 4 to 11; see Table 2.13 Since in our context, each measurement corresponds toa label, we obtain ranking problems of quite different complexity. Besides, even though the original measurements arereal-valued, there are expression profiles containing ties which were broken randomly.In order to complement the former real-world scenario with problems originating from several different domains, thefollowing multiclass datasets from the UCI Repository of machine learning databases [6] and the Statlog collection [46]were included in the experimental evaluation: iris, wine, glass, vowel, vehicle (a summary of dataset properties is given inTable 2). These datasets were also used in a recent experimental study on multiclass support vector machines [32].8 We employed the implementation offered by the Weka machine learning package [61] in its default setting. To obtain a ranking of labels, classificationscores were transformed into (pseudo-)probabilities using a logistic regression technique [50].9 This algorithm is based on the “alpha-bound trick”. We set the corresponding parameter α to 500.10 Again, we used the implementation offered by the Weka package.11 All linear models also incorporate a bias term.12 This data is publicly available at http://www1.cs.columbia.edu/compbio/exp-phylo.13 We excluded three additional subproblems with more measurements due to the prohibitive computational demands of the constraint classificationapproach.E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19161909Table 3Experimental results (mean and standard deviation) in terms of Kendall’s taudatairiswineglassvowelvehiclespoheatdttcolddiauRPC.885 ± .068.921 ± .053.882 ± .042.647 ± .019.854 ± .025.140 ± .023.125 ± .024.174 ± .034.221 ± .028.332 ± .019CC-P.836 ± .089.933 ± .043.846 ± .045.623 ± .019.855 ± .022.138 ± .022.126 ± .023.180 ± .037.220 ± .029.330 ± .019CC-LR.836 ± .063.755 ± .111.834 ± .052.583 ± .019.830 ± .025.122 ± .022.124 ± .024.158 ± .033.196 ± .029.299 ± .022Table 4Experimental results (mean and standard deviation) in terms of Spearman’s rank correlationdatairiswineglassvowelvehiclespoheatdttcolddiauRPC.910 ± .058.938 ± .045.918 ± .036.760 ± .020.888 ± .020.176 ± .030.156 ± .030.199 ± .040.265 ± .033.422 ± .023CC-P.863 ± .086.949 ± .033.889 ± .043.746 ± .021.891 ± .019.178 ± .030.156 ± .029.205 ± .041.265 ± .034.418 ± .023CC-LR.874 ± .052.800 ± .102.879 ± .048.712 ± .020.873 ± .022.156 ± .029.154 ± .029.183 ± .038.234 ± .035.377 ± .026CC-SVM.812 ± .071.932 ± .057.820 ± .064.594 ± .020.817 ± .025.121 ± .020.117 ± .023.154 ± .045.193 ± .040.297 ± .019CC-SVM.856 ± .057.942 ± .052.860 ± .062.724 ± .021.864 ± .023.156 ± .026.148 ± .027.178 ± .054.235 ± .050.377 ± .022LL.818 ± .088.942 ± .043.817 ± .060.601 ± .021.770 ± .037.132 ± .024.125 ± .025.167 ± .034.209 ± .028.321 ± .020LL.843 ± .089.956 ± .034.859 ± .060.732 ± .022.820 ± .036.167 ± .030.155 ± .031.193 ± .038.251 ± .033.406 ± .025For each of these four multiclass datasets, a corresponding ranking dataset was generated in the following manner: Wetrained a naive Bayes classifier14 on the respective dataset. Then, for each example, all the labels present in the dataset wereordered with respect to decreasing predicted class probabilities (in the case of ties, labels with lower indices are rankedfirst). Thus, by substituting the single labels contained in the original multiclass datasets with the complete rankings, weobtain the label ranking datasets required for our experiments. The fundamental underlying learning problem may also beviewed as learning a qualitative replication of the probability estimates of a naive Bayes classifier.6.2. Experimental results6.2.1. Complete preference informationIn the experiments, the actual true rankings on the test sets were compared to the corresponding predicted rankings.For each of the approaches, we report the average accuracy in terms of both Spearman’s rank correlation and Kendall’stau. This is necessary because, as we showed in Section 5, RPC with weighted voting as a ranking procedure is especiallytailored toward maximizing the Spearman rank correlation, while CC and LL are more focused on the Kendall tau measure:Minimization of the 0/1-loss on the expanded set of (binary) classification examples yields an implicit maximization ofthe empirical Kendall tau statistic of the label ranking function on the training set. It is true, however, that all distance(similarity) measures on rankings are of course more or less closely related.15The results of a cross validation study (10-fold, 5 repeats), shown in Tables 3 and 4, are clearly in favor of RPC and CCin its online version. These two methods are on a par and outperform the other methods on all datasets except wine, forwhich LL yields the highest accuracy. These results are further corroborated by the standard classification accuracy on themulticlass data (probability to place the true class on the topmost rank), which is reported in Table 5.In terms of training time, RPC is the clear winner, as can be seen in Table 6.16 In compliance with our theoretical results,the original version of CC, here implemented as CC-SVM and CC-LR, was found to be quite problematic from this point ofview, as it becomes extremely expensive for data sets with many attributes or many labels. For example, the trainings timefor CC-SVM was almost 5 hours for vowel, and more than 7 days for the spo data; we therefore abstained from a detailedanalysis and exposition of results for these variants. As expected, RPC is slightly less efficient than LL and CC-P in terms of14 We employed the implementation for naive Bayes classification on numerical datasets (NaiveBayesSimple) contained in the Weka machine learningpackage [61].15 For example, it has recently been shown in [14] that optimizing rank correlation yields a 5-approximation to the ranking which is optimal for theKendall measure.16 Experiments were conducted on a PC Intel Core2 6600 2,4 Ghz with 2 GB RAM. We stopped the iteration in LL as soon as the sum of absolute changesof the weights was smaller than 10−7; empirically, this was found to be the largest value that guaranteed stability of the model performance.1910E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916Table 5Experimental results (mean and standard deviation) in terms of standard classification ratedatairiswineglassvowelvehicleRPC.952 ± .050.945 ± .051.767 ± .091.507 ± .056.895 ± .028CC-P.933 ± .069.970 ± .042.715 ± .089.425 ± .062.895 ± .034CC-LR.907 ± .075.927 ± .043.706 ± .092.445 ± .063.868 ± .035CC-SVM.911 ± .076.948 ± .057.696 ± .099.433 ± .064.865 ± .033Table 6Time (in ms) needed for training (left) and testing (mean and standard deviation)datairiswineglassvowelvehiclespoheatdttcolddiauRPC18 ± 1159 ± 16132 ± 15927 ± 24439 ± 2410 953 ± 953069 ± 391226 ± 311209 ± 324325 ± 38CC-P48 ± 1022 ± 14605 ± 5212 467 ± 5951810 ± 177343 506 ± 2719061 206 ± 364819 592 ± 113320 936 ± 135883 967 ± 9849LL833 ± 587575 ± 3761529 ± 85036 063 ± 22 8972177 ± 133961 826 ± 33 94616 552 ± 94152510 ± 13403045 ± 200127 441 ± 12 686RPC0.6 ± 3.20.6 ± 3.11.6 ± 4.813.7 ± 5.11.6 ± 4.890.5 ± 5.826.5 ± 7.310.2 ± 7.410.6 ± 7.434.7 ± 6.6CC-P0.0 ± 0.00.3 ± 2.30.0 ± 0.00.3 ± 2.10.0 ± 0.00.9 ± 3.80.6 ± 3.20.3 ± 2.10.0 ± 0.01.2 ± 4.3LL.916 ± .076.962 ± .044.706 ± .093.407 ± .067.851 ± .037LL0.0 ± 0.00.3 ± 2.30.3 ± 2.30.6 ± 3.10.0 ± 0.010.3 ± 8.13.7 ± 6.72.8 ± 6.03.4 ± 6.54.1 ± 7.0testing time (see also Table 6), even though these times are extremely small throughout and clearly negligible in comparisonwith the training times.6.2.2. Incomplete preference informationIn Section 6.2.1, we provided an empirical study on learning label ranking functions assuming that the complete rankingis available for each example in the training set. However, in practical settings, we will often not have access to a total orderof all possible labels for an object. Instead, in many cases, only a few pairs of preferences are known for each object.To model incomplete preferences, we modified the training data as follows: A biased coin was flipped for every label ina ranking in order to decide whether to keep or delete that label; the probability for a deletion is p. Thus, a ranking suchas λ1 (cid:4) λ2 (cid:4) λ3 (cid:4) λ4 (cid:4) λ5 may be reduced to λ1 (cid:4) λ3 (cid:4) λ4, and hence, pairwise preferences are generated only from thelatter (note that, as a pairwise preference “survives” only with probability (1 − p)2, the average percentage of preferencesin the training data decreases much faster with p than the average number of labels). Of course, the rankings produced inthis way are of varying size.Fig. 4 shows the experimental results for RPC, LL, and CC-P, the online variant of CC. More precisely, the figures showthe accuracy in terms of Kendall’s tau (which are qualitatively very similar to those for Spearman’s rank correlation) asa function of the probability p. As expected, the accuracy decreases with an increasing amount of missing preferenceinformation, even though all three methods can deal with missing preference information remarkably well. Still, there seemsto be a clear rank order: LL is the least sensitive method, and CC appears to be a bit less sensitive than RPC. Our explanationfor this finding is that, due to training a quadratic instead of a linear number of models, RPC is in a sense more flexible thanLL and CC. This flexibility is an advantage if enough training data is available but may turn out as a disadvantages if thisis not the case. This may also explain the superior performance of LL on the wine data, which has relatively few instances.Finally, we mention that almost identical curves are obtained when sampling complete training examples with a suitablesampling rate. Roughly speaking, training on a few instances with complete preference information is comparable to trainingon more instances with partial preference information, provided the (expected) total number of pairwise preferences is thesame.7. Related workAs noted in Section 6, the work on constraint classification [28,29] appears to be a natural counterpart to our algorithm.In the same section, we have also discussed the log-linear models for label ranking proposed by Dekel et al. [17]. As both CCand LL are directly applicable to the label ranking problem studied in this paper, we compared RPC empirically with theseapproaches. The subsequent review will focus on other key works related to label ranking and pairwise decompositiontechniques that have recently appeared in the literature; a somewhat more exhaustive literature survey can be found in[12].We are not aware of any other work that, as our method, approaches the label ranking problem by learning pairwisepreference predicates Rx(λi, λ j), 1 (cid:2) i < j (cid:2) m, and, thereby, reduces the problem to one of ranking on the basis of apreference relation. Instead, all existing methods, including CC and LL, essentially follow the idea of learning utility orscoring functions f 1(·) . . . fm(·) that can be used for inducing a label ranking: Given an input x, each label λi is evaluated interms of a score f i(x), and the labels are then ordered according to these scores.E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19161911Fig. 4. Results for the datasets in Table 2 in the missing label scenario: Accuracy in terms of Kendall’s tau as a function of the (expected) percentage ofmissing labels (note that different figures have different scales).1912E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916In passing, we note that, for the (important) special case in which we combine pairwise preferences in RPC by means ofa simple voting strategy, it is true that we eventually compute a kind of score for each label as well, namelyf i(x) =Rx(λi, λ j),(cid:2)1(cid:2) j(cid:6)=i(cid:2)mthat may, at least at first sight, appear comparable to the utility functions(cid:2)f i(x) =α jh j(x, λi)j(7.1)(7.2)used in LL. However, despite a formal resemblance, one should note that (7.1) is not directly comparable to (7.2). In par-ticular, our “base functions” are preference predicates (L × L → [0, 1] mappings) instead of scoring functions (X × L → Rmappings). Moreover, as opposed to (7.2), the number of these functions is predetermined by the number of labels (m), andeach of them has the same relevance (i.e., weighing coefficients αi are not needed).Shalev-Shwartz and Singer [56] learn utility functions f i(·) on the basis of a different type of training information,namely real values g(λi) that reflect the relevance of the labels λi for an input x. Binary preferences between labels λi andλ j are then weighted by the difference g(λi) − g(λ j), and this value is considered as a degree of importance of ordering λiahead of λ j . This framework hence deviates from a purely qualitative setting in which preference information is modeled inthe form of order relations.Another interesting generalization of the utility-based approach to label ranking is the framework of Aiolli [1], that allowsone to specify both qualitative and quantitative preference constraints on utility functions. In addition to the pairwise pref-erence constraints that we also use (and which he interprets as constraints on a utility function), Aiolli [1] also allows con-straints of the type λi (cid:8)x τ , which means that the value of the utility function f i(x) > ti , where ti is a numerical threshold.There has also been some previous work on the theoretical foundations of label ranking. We already mentioned abovethat Dekel et al. [17] introduced a generalized ranking error, which assumes a procedure for decomposing a preferencegraph into subgraphs, and defines the generalized error as the fraction of subgraphs that are not exactly in agreement withthe learned utility function. Ha and Haddawy [26] discuss a variety of different ranking loss functions and introduce adifferent extension of Kendall’s tau. With respect to predictive performance, Usunier et al. [59] analyze the generalizationproperties of binary classifiers trained on interdependent data for certain types of structured learning problems such asbipartite ranking.As mentioned in Section 2, label ranking via pairwise preference models may be viewed as a generalization of variousother learning tasks. There has been a considerable amount of recent work on many of such tasks. In particular, pairwiseclassification has been studied in-depth in the area of support vector machines [32, and references therein]. We refer to[22, Section 8] for a brief survey of work on pairwise classification, and its relation to other learning class binarizationtechniques.Another special scenario is the application of label ranking algorithms to multi-label problems. For example, Crammerand Singer [16] consider a variety of on-line learning algorithms for the problem of ranking possible labels in a multi-labeltext categorization task. They investigate a set of algorithms that maintain a prototype for each possible label, and orderthe labels of an example according to the response signal returned by each of the prototypes. [11] demonstrates a generaltechnique that not only allows one to rank all possible labels in multi-label problem, but also to select an appropriatethreshold between relevant and irrelevant labels.It is well-known that pairwise classification is a special case of Error Correcting Output Codes (ECOC) [18] or, more pre-cisely, their generalization that has been introduced in [2]. Even though ECOC allows for a more flexible decompositionof the original problem into simpler ones, the pairwise approach has the advantage that it provides a fixed, domain-independent and non-stochastic decomposition with a good overall performance. In several experimental studies, including[2], it performed en par or better with competing decoding matrices. While finding a good encoding matrix still is an openproblem [49], it can be said that pairwise classification is among the most efficient decoding schemes. Even though we haveto train a quadratic number of classifiers, both training (and to some extent also testing) can be performed in linear time asdiscussed in Section 4. ECOC matrices that produce the necessary redundancy by defining more binary prediction problemsthan labels are more expensive to train.What is more important here, however, is that the pairwise case seems to have special advantages in connection withranking and preference learning problems. In particular, it has a clearly defined semantics in terms of pairwise comparison be-tween alternatives and, as we discussed in Section 3, produces as output a binary preference relation, which is an establishedconcept in preference modeling and decision theory. As opposed to this, the semantics of a model that compares morethan two classes, namely a subset of positive with a subset of negative ones, as it is possible in ECOC, is quite unclear. Forexample, while a prediction λ3 (cid:4) λ2 obviously indicates that λ3 is ranked before λ2, several interpretations are conceivablefor a prediction such as, say, {λ3, λ5} (cid:4) {λ1, λ2}. Without going into further detail, we mention that all these interpretationsseem to produce serious complications, either with regard to the training of models or the decoding step, or both. In anycase, generalizing the pairwise approach in the label ranking setting appears to be much more difficult than in the clas-sification setting, where an information about class membership can easily be generalized from single labels (the instancebelongs to λ3) to a set of labels (the instance belongs to λ3 or λ5). The main reason is that, in label ranking, a single piece ofinformation does not concern a class membership but preference (order) information that naturally relates to pairs of labels.E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–191619138. ConclusionsIn this paper, we have introduced a learning algorithm for the label ranking problem and investigated its properties boththeoretically and empirically. The merits of our method, called ranking by pairwise comparison (RPC), can be summarizedas follows:• Firstly, we find that RPC is a simple yet intuitively appealing and elegant approach, especially as it is a natural general-ization of pairwise classification. Besides, RPC is completely in line with preference modeling based on binary preferencerelations, an established approach in decision theory.• Secondly, the modular conception of RPC allows for combining different (pairwise) learning and ranking methods in aconvenient way. For example, different loss functions can be minimized by simply changing the ranking procedure butwithout the need to retrain the binary models (see Section 5).• Thirdly, RPC is superior to alternative approaches with regard to efficiency and computational complexity, as we haveshown both theoretically and experimentally (cf. Sections 4 and 6), while being at least competitive in terms of predic-tion quality.• Fourthly, while existing label ranking methods are inherently restricted to linear models, RPC is quite general regardingthe choice of a base learner, as in principle every binary classifier can be used.Finally, we note that RPC also appears attractive with regard to an extension of the label ranking problem to the learningof more general preference relations on the label set L. In fact, in many practical applications it might be reasonable torelax the assumption of strictness, i.e., to allow for indifference between labels, or even to represent preferences in termsof partial instead of total orders. The learning of pairwise preference predicates is then definitely more suitable than utility-based methods, since a utility function necessarily induces a total order and, therefore, cannot represent partial orders.Extensions of this kind constitute important aspects of ongoing work.AcknowledgementsWe would like to thank the anonymous reviewers for their insightful comments that helped to considerably improve thispaper. This research was supported by the German Research Foundation (DFG).Appendix A. Transitivity properties of pairwise preferencesOur pairwise learning scheme introduced in Section 3 produces a preference relation Rx in a first step, which is thenused for inducing a ranking τx. As transitivity of pairwise preferences is one of the most important properties in preferencemodeling, an interesting question is whether any sort of transitivity can be guaranteed for Rx. Indeed, even though thepairwise preferences induced by a single ranking are obviously transitive, it is less clear whether this property is preservedwhen “merging” different rankings in a probabilistic way.In fact, recall that every instance x ∈ X is associated with a probability distribution over Sm (cf. Section 5.1). Such adistribution induces a unique probability distribution for pairwise preferences viapi j = P(λi (cid:4) λ j) =(cid:2)P(τ ).τ ∈Sm: τ (i)<τ ( j)(A.1)An interesting finding is that the pairwise preferences (A.1) do indeed satisfy a form of transitivity, albeit a relatively weakone:∀i, j, k ∈ {1 . . . m}: pik (cid:3) pi j + p jk − 1.More formally, we can prove the following theorem.(A.2)Theorem 4. Consider any probability distribution on the set of rankings Sm. The pairwise preferences induced by this distributionvia (A.1) satisfy (A.2).Proof. Consider any three labels λi, λ j, λk. Obviously, there is no need to distinguish the rankings which put these labels inthe same order. Thus, we can partition Sm into six equivalence classes S i jk, S ikj . . . Ski j , where S i jk = {τ ∈ Sm | τ (i) < τ ( j) <τ (k)} and the other classes are defined analogously. Letqi jkdf= P(S i jk) =(cid:2)P(τ )τ ∈Sm: τ (i)<τ ( j)<τ (k)and q = (qi jk, qikj, q jik, q jki, qki j, qkji)(cid:19) ∈ [0, 1]6.1914E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916Now, consider probabilities p = (pi j, p jk, pik)(cid:19)for the pairwise probabilities (A.1). Finding a distribution on rankingswhich induces these probabilities obviously comes down to solving a system of linear equations of the form A × q = p,where A is a matrix of dimension 3 × 6 with 0/1 entries, andqi jk + qikj + q jik + q jki + qki j + qkji = 1.⎞⎛⎛⎞The set of solutions to this problem can be expressed aspi j + p jk − 1 + v1 − p jk − u − vpik − pi j + u1 − pik − u − vuvqi jkqikjq jikq jkiqki jqkji⎟⎟⎟⎟⎟⎠⎜⎜⎜⎜⎜⎝⎟⎟⎟⎟⎟⎠⎜⎜⎜⎜⎜⎝=where u, v ∈ [0, 1]. Additionally, the components of q must be non-negative. If this is satisfied for u = v = 0, then pik (cid:3) pi j(fourth entry) and (A.2) holds. In the case where non-negativity is violated, either pi j + p jk < 1 or pik < pi j . In the secondcase, u must be increased to (at least) pi j − pik, and one obtains the solution vector(cid:4)pi j + p jk − 1, 1 + pik − (pi j + p jk), 0, 1 − pi j, pi j − pik, 0(cid:5)(cid:19)which is non-negative if and only if pik (cid:3) pi j + p jk − 1. In the first case, v must be increased to (at least) 1 − (pi j + p jk),and one obtains the solution vector(cid:4)0, pi j, pik − pi j, pi j + p jk − pik, 0, 1 − (pi j + p jk)(cid:5)(cid:19)which is non-negative if and only if pik (cid:2) pi j + p jk. This latter inequality is equivalent to pkj (cid:3) pkj + p ji − 1, where pkj =1 − p jk, so the transitivity property (A.2) now holds for the reciprocal probabilities. In a similar way one verifies that (A.2)must hold in the case where both pi j + p jk < 1 and pik < pi j . In summary, a probability distribution on Sm which inducesthe probabilities pi j, p jk, pik exists if and only if these probabilities satisfy (A.2). (cid:2)It is interesting to note that (A.2) is a special type of (cid:19)-transitivity. A so-called t-norm is a generalized logical conjunc-tion, namely a binary operator (cid:19) : [0, 1]2 → [0, 1] which is associative, commutative, monotone, and satisfies (cid:19)(0, x) = 0,(cid:19)(1, x) = x for all x. Operators of that kind have been introduced in the context of probabilistic metric spaces [55] and havebeen studied intensively in fuzzy set theory in recent years [39]. A binary relation R ⊂ A × A is called (cid:19)-transitive if itsatisfies R(a, c) (cid:3) (cid:19)(R(a, b), R(b, c)) for all a, b, c ∈ A. Therefore, what the condition (A.2) expresses is just (cid:19)-transitivitywith respect to the Lukasiewicz t-norm which is defined by (cid:19)(x, y) = max(x + y − 1, 0). An interesting idea to guaranteethis condition to hold is hence to replace the original ensemble of pairwise predictions by its (cid:19)-transitive closure [47],where (cid:19) is the aforementioned Lukasiewicz t-norm.References[1] Fabio Aiolli, A preference model for structured supervised learning tasks, in: Proceedings of the Fifth IEEE International Conference on Data Mining(ICDM-05), IEEE Computer Society, 2005, pp. 557–560.[2] Erin L. Allwein, Robert E. Schapire, Yoram Singer, Reducing multiclass to binary: A unifying approach for margin classifiers, Journal of Machine LearningResearch 1 (2000) 113–141.[3] Noga Alon, Ranking tournaments, SIAM Journal on Discrete Mathematics 20 (1), pp. 137–142.[4] Rajarajeswari Balasubramaniyan, Eyke Hüllermeier, Nils Weskamp, Jörg Kämper, Clustering of gene expression data using a local shape-based similaritymeasure, Bioinformatics 21 (7) (2005) 1069–1077.[5] John J. Bartholdi III, Craig A. Tovey, Michael A. Trick, Voting schemes for which it can be difficult to tell who won the election, Social Choice andWelfare 6 (2) (1989) 157–165.[6] Catherine L. Blake, Christopher J. Merz, UCI repository of machine learning databases, 1998; Data available at http://www.ics.uci.edu/~mlearn/MLRepository.html.[7] Craig Boutilier, Ronen Brafman, Carmel Domshlak, Holger Hoos, David Poole, CP-nets: A tool for representing and reasoning with conditional ceterisparibus preference statements, Journal of Artificial Intelligence Research 21 (2004) 135–191.[8] Ralph A. Bradley, Milton E. Terry, The rank analysis of incomplete block designs—I. The method of paired comparisons, Biometrika 39 (1952) 324–345.[9] Steven J. Brams, Peter C. Fishburn, Voting procedures, in: K.J. Arrow, A.K. Sen, K. Suzumura (Eds.), Handbook of Social Choice and Welfare (vol. 1),Elsevier, 2002, Chapter 4.[10] Pavel B. Brazdil, Carlos Soares, J.P. da Costa, Ranking learning algorithms: Using IBL and meta-learning on accuracy and time results, Machine Learn-ing 50 (3) (March 2003) 251–277.[11] Klaus Brinker, Johannes Fürnkranz, Eyke Hüllermeier, A unified model for multilabel classification and ranking, in: Proceedings of the 17th EuropeanConference on Artificial Intelligence (ECAI-06), 2006, pp. 489–493.[12] Klaus Brinker, Johannes Fürnkranz, Eyke Hüllermeier, Label ranking by learning pairwise preferences, Technical Report TUD-KE-2007-01, KnowledgeEngineering Group, TU Darmstadt, 2007.[13] William W. Cohen, Robert E. Schapire, Yoram Singer, Learning to order things, Journal of Artificial Intelligence Research 10 (1999) 243–270.[14] Don Coppersmith, Lisa Fleischer, and Atri Rudra, Ordering by weighted number of wins gives a good ranking for weighted tournaments, in: Proceedingsof the ACM–SIAM Symposium on Discrete Algorithms (SODA), 2006, pp. 776–782.[15] Koby Crammer, Yoram Singer, Ultraconservative online algorithms for multiclass problems, Journal of Machine Learning Research 3 (2003) 951–991.E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–19161915[16] Koby Crammer, Yoram Singer, A family of additive online algorithms for category ranking, Journal of Machine Learning Research 3 (2003) 1025–1058.[17] Ofer Dekel, Christopher D. Manning, Yoram Singer, Log-linear models for label ranking, in: S. Thrun, L.K. Saul, B. Schölkopfand (Eds.), Advances inNeural Information Processing Systems 16 (NIPS-2003), MIT Press, 2004.[18] Thomas G. Dietterich, Ghulum Bakiri, Solving multiclass learning problems via error-correcting output codes, Journal of Artificial Intelligence Research 2(1995) 263–286.[19] Jon Doyle, Prospects for preferences, Computational Intelligence 20 (2) (2004) 111–136.[20] János Fodor, Marc Roubens, Fuzzy Preference Modelling and Multicriteria Decision Support, Kluwer Academic Publishers, 1994.[21] Jerome H. Friedman, Another approach to polychotomous classification. Technical report, Department of Statistics, Stanford University, Stanford, CA,1996.[22] Johannes Fürnkranz, Round robin classification, Journal of Machine Learning Research 2 (2002) 721–747.[23] Johannes Fürnkranz, Round robin ensembles, Intelligent Data Analysis 7 (5) (2003) 385–404.[24] Johannes Fürnkranz, Eyke Hüllermeier, Pairwise preference learning and ranking, in: N. Lavraˇc, D. Gamberger, H. Blockeel, L. Todorovski (Eds.), Pro-ceedings of the 14th European Conference on Machine Learning (ECML-03), Cavtat, Croatia, in: Lecture Notes in Artificial Intelligence, vol. 2837,Springer-Verlag, 2003.[25] Johannes Fürnkranz, Eyke Hüllermeier, Preference learning, Künstliche Intelligenz 19 (1) (2005) 60–61.[26] Vu Ha, Peter Haddawy, Similarity of personal preferences: Theoretical foundations and empirical analysis, Artificial Intelligence 146 (2003) 149–173.[27] Peter Haddawy, Vu Ha, Angelo Restificar, Benjamin Geisler, John Miyamoto, Preference elicitation via theory refinement, Journal of Machine LearningResearch 4 (2003) 317–337.[28] Sariel Har-Peled, Dan Roth, Dav Zimak, Constraint classification: A new approach to multiclass classification, in: N. Cesa-Bianchi, M. Numao, R. Reischuk(Eds.), Proceedings of the 13th International Conference on Algorithmic Learning Theory (ALT-02), Lübeck, Germany, Springer, 2002, pp. 365–379.[29] Sariel Har-Peled, Dan Roth, Dav Zimak, Constraint classification for multiclass classification and ranking, in: Suzanna Becker, Sebastian Thrun, KlausObermayer (Eds.), Advances in Neural Information Processing Systems 15 (NIPS-02), 2003, pp. 785–792.[30] Trevor Hastie, Robert Tibshirani, Classification by pairwise coupling, in: M.I. Jordan, M.J. Kearns, S.A. Solla (Eds.), Advances in Neural InformationProcessing Systems 10 (NIPS-97), MIT Press, 1998, pp. 507–513.[31] Ralf Herbrich, Thore Graepel, Peter Bollmann-Sdorra, Klaus Obermayer, Supervised learning of preference relations, in: Proceedings des Fachgruppentr-effens Maschinelles Lernen (FGML-98), 1998, pp. 43–47.[32] Chih-Wei Hsu, Chih-Jen Lin, A comparison of methods for multi-class support vector machines, IEEE Transactions on Neural Networks 13 (2) (March2002) 415–425.[33] Eyke Hüllermeier, Johannes Fürnkranz, Ranking by pairwise comparison: A note on risk minimization, in: Proceedings of the IEEE International Con-ference on Fuzzy Systems (FUZZ-IEEE-04), Budapest, Hungary, 2004.[34] Eyke Hüllermeier, Johannes Fürnkranz, Comparison of ranking procedures in pairwise preference learning, in: Proceedings of the 10th InternationalConference on Information Processing and Management of Uncertainty in Knowledge-Based Systems (IPMU-04), Perugia, Italy, 2004.[35] Thorsten Joachims, Optimizing search engines using clickthrough data, in: Proceedings of the 8th ACM SIGKDD International Conference on KnowledgeDiscovery and Data Mining (KDD-02), ACM Press, 2002, pp. 133–142.[36] Thorsten Joachims, Laura Granka, Bing Pan, Helene Hembrooke, Geri Gay, Accurately interpreting clickthrough data as implicit feedback, in: Proceedingsof the 28th Annual International ACM Conference on Research and Development in Information Retrieval (SIGIR-05), 2005.[37] Roni Khardon, Gabriel Wachman, Noise tolerant variants of the perceptron algorithm, The Journal of Machine Learning Research 8 (2007) 227–248.[38] Maurice G. Kendall, Rank Correlation Methods, Charles Griffin, London, 1955.[39] Erich-Peter Klement, Radko Mesiar, Endre Pap, Triangular Norms, Kluwer Academic Publishers, 2002.[40] Stefan Knerr, Léon Personnaz, Gérard Dreyfus, Single-layer learning revisited: A stepwise procedure for building and training a neural network, in:F. Fogelman Soulié, J. Hérault (Eds.), Neurocomputing: Algorithms, Architectures and Applications, in: NATO ASI Series, vol. F68, Springer-Verlag, 1990,pp. 41–50.[41] Stefan Knerr, Léon Personnaz, Gérard Dreyfus, Handwritten digit recognition by neural networks with single-layer training, IEEE Transactions on NeuralNetworks 3 (6) (1992) 962–968.[42] Ulrich H.-G. Kreßel, Pairwise classification and support vector machines, in: B. Schölkopf, C.J.C. Burges, A.J. Smola (Eds.), Advances in Kernel Methods:Support Vector Learning, MIT Press, Cambridge, MA, 1999, pp. 255–268, Chapter 15.[43] Erich L. Lehmann, H.J.M. D’Abrera, Nonparametrics: Statistical Methods Based on Ranks, rev. ed., Prentice-Hall, Englewood Cliffs, NJ, 1998.[44] Bao-Liang Lu, Masami Ito, Task decomposition and module combination based on class relations: A modular neural network for pattern classification,IEEE Transactions on Neural Networks 10 (5) (September 1999) 1244–1256.[45] John I. Marden, Analyzing and Modeling Rank data, Chapman & Hall, London, 1995.[46] Donald Michie, David J. Spiegelhalter, C.C. Taylor, Machine Learning, Neural and Statistical Classification, Ellis Horwood, 1994, Data available at ftp://ftp.ncc.up.pt/pub/statlog/.[47] Helga Naessens, Hans De Meyer, Bernard De Baets, Algorithms for the computation of T-transitive closures, IEEE Trans. Fuzzy Syst. 10 (2002) 541–551.[48] Sang-Hyeun Park, Johannes Fürnkranz, Efficient Pairwise Classification, in: Proceedings of the 17th European Conference on Machine Learning (ECML-07), Warsaw, Poland, Springer-Verlag, September 2007, pp. 658–665.[49] Edgar Pimenta, João Gama, André Carvalho, Pursuing the best ECOC dimension for multiclass problems, in: Proceedings of the 20th InternationalFlorida Artificial Intelligence Research Society Conference (FLAIRS-07), 2007, pp. 622–627.[50] John Platt, Probabilistic outputs for support vector machines and comparison to regularized likelihood methods, in: A.J. Smola, P. Bartlett, B. Schoelkopf,D. Schuurmans (Eds.), Advances in Large Margin Classifiers, Cambridge, MA, MIT Press, 1999, pp. 61–74.[51] David Price, Stefan Knerr, Léon Personnaz, Gérard Dreyfus, Pairwise neural network classifiers with probabilistic outputs, in: G. Tesauro, D. Touretzky,T. Leen (Eds.), Advances in Neural Information Processing Systems 7 (NIPS-94), MIT Press, 1995, pp. 1109–1116.[52] Filip Radlinski, Thorsten Joachims, Learning to rank from implicit feedback, in: Proceedings of the ACM Conference on Knowledge Discovery and DataMining (KDD-05), 2005.[53] Ryan Rifkin, Aldebaro Klautau, In defense of one-vs-all classification, Journal of Machine Learning Research 5 (2004) 101–141.[54] Michael S. Schmidt, Herbert Gish, Speaker identification via support vector classifiers, in: Proceedings of the 21st IEEE International Conference onAcoustics, Speech, and Signal Processing (ICASSP-96), Atlanta, GA, 1996, pp. 105–108.[55] B. Schweizer, A. Sklar, Probabilistic Metric Spaces, North-Holland, New York, 1983.[56] Shai Shalev-Shwartz, Yoram Singer, Efficient learning of label ranking by soft projections onto polyhedra, Journal of Machine Learning Research 7(2006) 1567–1599.[57] Charles Spearman, The proof and measurement of association between two things, American Journal of Psychology 15 (1904) 72–101.[58] Gerald Tesauro, Connectionist learning of expert preferences by comparison training, in: D. Touretzky (Ed.), Advances in Neural Information ProcessingSystems 1 (NIPS-88), Morgan Kaufmann, 1989, pp. 99–106.[59] Nicolas Usunier, Massih-Reza Amini, Patrick Gallinari, Generalization error bounds for classifiers trained with interdependent data, in: Y. Weiss,B. Schölkopf, J. Platt (Eds.), Advances in Neural Information Processing Systems 18 (NIPS 2005), MIT Press, 2006, pp. 1369–1376.1916E. Hüllermeier et al. / Artificial Intelligence 172 (2008) 1897–1916[60] Jun Wang, Artificial neural networks versus natural neural networks: A connectionist paradigm for preference assessment, Decision Support Systems 11(1994) 415–429.[61] Ian H. Witten, Eibe Frank, Data Mining: Practical Machine Learning Tools with Java Implementations, Morgan Kaufmann, San Francisco, 2000.[62] Ting-Fan Wu, Chih-Jen Lin, Ruby C. Weng, Probability estimates for multi-class classification by pairwise coupling, Journal of Machine Learning Re-search 5 (Aug) (2004) 975–1005.