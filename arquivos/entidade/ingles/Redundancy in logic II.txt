Artificial Intelligence 172 (2008) 265–299www.elsevier.com/locate/artintRedundancy in logic II: 2CNF and Horn propositional formulaePaolo LiberatoreDipartimento di Informatica e Sistemistica, Università di Roma “La Sapienza”, Via Ariosto 25, 00185 Roma, ItalyReceived 9 August 2006; received in revised form 4 June 2007; accepted 15 June 2007Available online 27 June 2007AbstractWe report results about the redundancy of formulae in 2CNF form. In particular, we give a slight improvement over the trivialredundancy algorithm and give some complexity results about some problems related to finding Irredundant Equivalent Subsets(I.E.S.) of 2CNF formulae. The problems of checking whether a 2CNF formula has a unique I.E.S. and checking whether a clausein is all its I.E.S.’s are polynomial. Checking whether a 2CNF formula has an I.E.S. of a given size and checking whether a clauseis in some I.E.S.’s of a 2CNF formula are polynomial or NP-complete depending on whether the formula is cyclic. Some resultsabout Horn formulae are also reported.© 2007 Elsevier B.V. All rights reserved.Keywords: Propositional logic; Computational complexity; Redundancy1. IntroductionProblems related to redundancy in logic and similar fields has been investigated by a number of authors. Ginsberg[9] and Schmolze and Snyder [25] studied the problem of redundancy of production rules. Several authors investi-gated the problem of minimizing a formula, with particular emphasis on Horn formulae [1,11,12,19,20,28]. Gottloband Fermüller [10] gave results about the redundancy of a literal in a first-order clause. Liberatore [17,18] providedcomplexity results for the CNF case and for some non-classical logics. Büning and Zhao [3] studied the problems ofequivalence and extension-equivalence of irredundant formulae. Various authors have studied the problem of minimalunsatisfiability [2,7,21].In this article, we report about the complexity of some problems related to the redundancy of formulae in 2CNF andHorn form. In particular, the considered problems are that of checking whether a formula is redundant, establishingthe minimal size of an Irredundant Equivalent Subset (I.E.S.) of a formula, and checking whether a clause is in someI.E.S.’s of a formula. The first problem is polynomial due to the polynomiality of consistency checking for 2CNF andHorn formulae, but a slight improvement over the trivial algorithm exists. For the two other problems, complexity isshown to be polynomial or NP-complete depending on the structure of the formula.There are several reasons for checking redundancy of a formula and for finding an irredundant and equivalentsubset of it. Most of these reasons apply to all kind of formulae, regardless of whether they are general propositionalE-mail address: paolo@liberatore.org.0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2007.06.003266P. Liberatore / Artificial Intelligence 172 (2008) 265–299formulae, 2CNF, Horn, or formulae of non-classical logics. Some are peculiar to tractable restrictions such as 2CNFand Horn.Generally, a logic formula may come either from a user directly encoding a domain of interest or from an automatedtranslation from some formal language. In the first case, the presence of a redundant part of a formula may indicate thatsome aspects of the domain are either of particular importance or not sufficiently understood. Intentional redundancyof information about a particular part of a domain may indicate a will or need to be sure that part of the domainis correctly encoded. On the other hand, an unintentional redundancy may indicate undetected problems with theencoding, such as multiple people using the same names for expressing different concepts. Simplifying a formulaby removing redundancy shows which parts are really needed; this may result in error detection if redundancy wasunintentional, and in a confirmation of correctness if it was intentional.If a formula results from a translation, its redundancy may give the same indications on the information in thelanguage it was originally expressed. However, it may also highlight problems that are introduced by the translationitself. As an example, while each of a set of formulae may be correct by itself, their merging may result in an incon-sistent formula because of the different meaning of the variables in different formulae [16]. The same problem mayhowever also generate redundancy. Depending on the particular scenario, redundancy may also results from severalsources providing the same information. Either way, detecting redundancy tells something significant.On the technical side, redundancy has been sometimes intentionally added to formulae to speed-up consistencyand entailment solving. Removing redundancy is a way to make such formulae easier to understand to humans.On the other hand, increasing the size of formulae generally makes solving harder. This is particular important forthose cases where consistency and entailment are polynomial problems, such as 2CNF and Horn. If a set of clausesoriginally contains a large number of redundant clauses, removing some redundant ones may provide a speedup dueto the reduction in size of the original formula. This gain is useful when the same formula is for example checkedfor consistency with or entailment to several different formulae, because the cost of redundancy removal is amortizedamong several consistency or entailment tests.The results presented in this paper differ from previous work in either the settings or in the specific analyzedproblems, or both. Related work regarding different settings are those by Ginsberg [9] and Schmolze and Snyder [25],as they are about production rules and not propositional formulae. Gottlob and Fermüller [10] also worked in adifferent logic, the first-order one, but also studied a different problem, that or redundancy within a single clauserather than the redundancy of a clause within a set of clauses. Liberatore [18] investigated redundancy for somenon-classical logics.Related work regarding propositional logic can be roughly divided into three classes. First, we have the investiga-tions into making a propositional formula as small as possible while preserving equivalence. This problem originatesfrom the article where the polynomial hierarchy has been introduced [20], and has been then subject of a number ofother studies [1,11,12,19,28]; emphasis is often of Horn formulae. These results differ from the ones in the presentarticle because they are about a different problem. Minimizing a formula means producing an equivalent formula ofminimal size; such formula can be syntactically very different from the original one, to the point of not sharing anyrecognizable part with it. Minimization and redundancy elimination are therefore different tasks, and they serve dif-ferent purposes: minimization produces a formulae of strictly minimal size; redundancy elimination is not required toreduce size as much as possible, but preserves the structure of the original formula by not adding any new part to it.The other two classes of related work are about the problems where irredundancy is a restriction over the alloweddata and about subproblems of irredundancy. In the first class falls the work of Büning and Zhao [3], who studiedproblems under the restriction that the involved formulae are irredundant. In the second class we have the problem ofminimal unsatisfiability [2,7,21]; this problem can be considered as the subcase of irredundancy when the consideredformula is assumed to be unsatisfiable. In this article, we also work in this settings by showing results for 2CNFunsatisfiable formulae.Liberatore [17] provided complexity results for the CNF case. The present article contains a similar study, butfor the 2CNF and Horn case. These special cases are generally considered of importance because consistency andentailment is polynomial, rather than NP-complete, in them. While the Horn case is generally considered the mostimportant of these two subcases, attention to the 2CNF case has also been given, as shown by a number of recentarticles on the subject [4,5,13,26,27,29].The rest of the paper is organized as follows. In the next section, we give a technical overview of the presentedresults. We then give some general theorems that will be used for proving those results. In the following four sections,P. Liberatore / Artificial Intelligence 172 (2008) 265–299267results will be shown for the problems of redundancy checking and Irredundant Equivalent Subsets (I.E.S.). In partic-ular, Section 4 contains result about redundancy checking; Section 5 contains the easiest results about I.E.S.’s; Section6 is about the size of I.E.S.’s; and Section 7 is about the problem of checking whether a clause is in some I.E.S.’s of agiven formula. Section 8 contains some results about Horn formulae. Technical lemmas and proofs are moved to theappendix for ease of reading.2. Overview of resultsThe first problem we consider is that of checking the redundancy of a 2CNF formula. Since a formula is redundantif and only if it is equivalent to one of its subsets and checking equivalence for 2CNF formulae is polynomial, theproblem is polynomial. We slightly improve over the trivial algorithm by showing that redundancy can be checked intime O(nm), where n is the number of variables and m is the number of clauses of the formula.The other problems we consider are about the irredundant equivalent subsets (I.E.S.) of a formula. In particular, thefollowing problems are easily shown to be polynomial for formulae in 2CNF: check whether a formula is an I.E.S. ofanother one; check whether a clause is in all I.E.S.’s of a formula; and check whether a formula has an unique I.E.S..The last two problems are polynomial thanks to the following results [17]: a clause γ is in all I.E.S.’s of a formula Πif and only if Π\{γ } |= γ ; a formula Π has an unique I.E.S. if and only if {γ ∈ Π | Π\{γ } (cid:3)|= γ } |= Π . Combinedwith the fact that inference is polynomial for 2CNF formulae, these two results imply that checking the presence of aclause in an I.E.S. and checking the uniqueness of I.E.S.’s are polynomial problems.Two problems about I.E.S.’s require a more complicated complexity analysis: checking whether a clause is inat least an I.E.S. of a formula and checking whether a formula has an I.E.S. of size bounded by an integer k. Thecomplexity of these two problems largely depend on the presence of cycles of clauses in the formula. Namely, if theformula contains a cycle of clauses, defined as a sequence of clauses [¬l1 ∨ l2, ¬l2 ∨ l3, . . . , ¬ln ∨ l1], these twoproblems are typically NP-complete, while they are polynomial if the formula does not contain cycles.The complexity analysis for the 2CNF form has been carried on separately on three different cases. As explainedin Section 3.4, equivalence of 2CNF formulae has different features depending on whether the formula is:(1) inconsistent;(2) consistent and implying some literals;(3) consistent and not implying any literal.We prove that the clauses not containing implied literals and the clauses containing implied literals can be consid-ered separately. More precisely, the problem of redundancy can be solved in two steps:(1) check the redundancy in Π of clauses l ∨ l(cid:5) such that Π |= l;(2) remove from Π all clauses l ∨ l(cid:5) such that Π |= l, and check redundancy.A similar procedure can be used for problems about I.E.S.’s: we indeed prove that every I.E.S. of a consistentformula is composed of two parts, the second being an I.E.S. of the formula composed of the clauses not containingany implied literal. An I.E.S. of a formula can be found by first finding an I.E.S. of this reduced formula and thenchecking which clauses have to be added to allow the derivation of literals that are implied by the original formula.While the three conditions of inconsistent formulae, formulae implying literals, and formulae not implying literalsrequire each a different analysis, the complexity is usually the same in all three cases. Namely, the complexity ofchecking redundancy is always O(nm) regardless of these conditions, while the complexity of the problems of pres-ence in an I.E.S. and of the uniqueness of I.E.S.’s depend more on the presence of cycles in the formula than on theconsistency or presence of implied literals.3. PreliminariesIn this paper, we study CNF formulae that are either in 2CNF or in Horn form. Given a set of propositionalvariables, a literal is a variable or a negated variable. A clause is a disjunction of literals; in particular, a unary/binaryclause is a clause composed of one or two literals. A Horn clause is a clause containing at most one positive literal.268P. Liberatore / Artificial Intelligence 172 (2008) 265–299A set of clauses containing only unary and binary clauses is a 2CNF formula. A set of clauses composed only of Hornclauses is a Horn formula.Redundancy of clauses and formulae are defined as follows.Definition 1. A clause γ is redundant in a CNF formula Π if Π\{γ } |= γ .This definition allows a clause γ not in Π to be classified as redundant in Π . However, we are typically interestedinto the redundancy of clauses γ ∈ Π . Obviously, if γ ∈ Π is irredundant in Π , it is also irredundant in every Π (cid:5) ⊆ Π .Definition 2. A CNF formula is redundant if it contains a redundant clause.In this paper we study the problem of checking the redundancy of 2CNF and Horn formulae, and some problemsrelated to making a formula irredundant by eliminating some redundant clauses. What results from this process isformalized by the following definition.Definition 3. (See [17].) An Irredundant Equivalent Subset (I.E.S.) of a CNF formula Π is a formula Π (cid:5) such thatΠ (cid:5) ⊆ Π , Π (cid:5) ≡ Π , and Π (cid:5) is irredundant.Every formula has at least one I.E.S. An irredundant formula has a single I.E.S., which is the formula itself.A redundant formula can have a number of I.E.S.’s ranging from one to exponentially many [17]. The followingproperties have been proved in a previous article.Property 1. (See [17].) A clause γ is in all I.E.S.’s of a formula Π if and only if γ is irredundant in Π .Property 2. (See [17].) A formula Π has a single I.E.S. if and only if {γ ∈ Π | Π\{γ } (cid:3)|= γ }} |= Π .For reasons that will be explained shortly, the set of literals that are entailed by a formula is technically importantwhile studying redundancy. The following notation is used for the literals that are entailed by a formula.Notation. Π|= = {l | Π |= l}.The following notation for the clauses containing a literal in a set will be used.Notation. Π|{l1, . . . , lm} = {γ | li ∈ γ , γ ∈ Π}.We also use Π|l = Π|{l}, where l is a literal.3.1. Unit propagationThe proofs of complexity of redundancy of 2CNF formulae are mostly done using unit propagation. The followinglemmas, whose proofs can be found in the appendix, show how entailment is related to unit propagation. We denoteby |=R the derivation by resolution and by |=UP the derivation by unit propagation.In what follows, Π denotes a 2CNF formula, i.e., a set of clauses, each composed at most of two literals. Weassume that Π does not contain the empty clause. By resolution trees we mean regular resolution trees; their root islabeled with a clause which is not necessarily ⊥. The following property immediately follows from resolution beinga complete inference method for prime implicates [22].Property 3. For any set of clauses Π and clause γ , it holds Π |= γ if and only if there exists γ (cid:5) ⊆ γ such thatΠ |=R γ (cid:5).When applied to binary clauses, this property can be reformulated as:P. Liberatore / Artificial Intelligence 172 (2008) 265–299269Π |= l1 ∨ l2 if and only if one of the following conditions hold: Π |=R ⊥Π |=R l1Π |=R l2Π |=R l1 ∨ l2Each of these three cases (inconsistency, entailment of at least one literal, entailment of the clause only), corre-sponds to a property of unit resolution, as the following lemmas (proved in the appendix) show.Lemma 1. For any 2CNF formula Π and two literals l1 and l2, if Π |=R l1 ∨ l2, then Π ∪ {¬l1} |=UP l2.Lemma 2. For any 2CNF formula Π and literal l, if Π |=R l then Π ∪ {¬l} |=UP ⊥.Lemma 3. A 2CNF formula Π is inconsistent if and only if there exists a variable x such that Π ∪ {x} |=UP ⊥ andΠ ∪ {¬x} |=UP ⊥.These lemmas have the following easy consequence.Lemma 4. For every 2CNF formula Π and literals l1 and l2, Π |= l1 ∨ l2 if and only if Π is inconsistent or Π ∪{¬l1} |=UP ⊥ or Π ∪ {¬l2} |=UP ⊥ or Π ∪ {¬l1} |=UP l2.3.2. Unit clausesIf Π only contains binary clauses (no unary clause), then Π ∪ {l} |=UP l(cid:5) means that l(cid:5) is obtained by propagatingl in Π , as l is the only unit clause of Π ∪ {l}. If this is the case, Π ∪ {l} |=UP l(cid:5) is equivalent to the reachability of l(cid:5)from l in the graph of Π induced by l.We generally do not assume that Π is composed of binary clauses only. In particular, even if we start from aformula made of binary clauses only, applying Corollary 1 or Lemma 3 leads to formulae containing unit clauses.On the other hand, every unit clause l can be replaced with the logically equivalent pair {l ∨ x, l ∨ ¬x}, where x isa new variable not occurring in the rest of the formula. Since {l} ≡ {l ∨ x, l ∨ ¬x}, the redundancy of l is equivalentto the redundancy of the pair {l ∨ x, l ∨ ¬x}, and most of the properties related to I.E.S.’s are also unaffected by thisreplacement.The only property that is changed by replacing l with {l ∨ x, l ∨ ¬x} is about the size of I.E.S.’s of a formula, aswe are replacing a single clause with a pair of clauses. This problem will be taken care by counting such a pair as if itwere a single clause in the algorithms for checking the size of a minimal I.E.S. of a formula.In the rest of this paper, whenever we have to check whether Π ∪ {l1} |=UP l2 or Π ∪ {l1} |=UP ⊥, we assume thatthis transformation has been preliminary done on Π , so that Π only contains binary clauses. This way, checking unitpropagation can be done by looking at the graph of Π induced by l1. In particular, Π ∪ {l1} |=UP l2 means that, in thegraph of Π induced by l1, there is a path from l1 to l2.By definition, Π ∪ {l1} |=UP ⊥ means that unit propagation from l allows reaching a pair of opposite literals l2 and¬l2. Graphically, there exists a path from l1 to l2 and a path from l1 to ¬l2 in the graph of Π induced by l1. Let l3 bethe last common literal of these two paths.Graphically, this condition can be represented as in Fig. 1. Since ¬l2 can be reached from l3, we have that ¬l3 canbe reached from l2. As a result, there exists a path from l1 to l3, from l3 to l2, and from l2 to ¬l3. In other words,Fig. 1. Two ways of viewing a contradiction entailed by a literal.270P. Liberatore / Artificial Intelligence 172 (2008) 265–299Π ∪ {l1} |=UP ⊥ implies that there exists a single path starting from l1 that includes a pair of opposite literals. In thesequel, whenever we say “all clauses in a path from l1 to ⊥”, we mean a single path starting from l1 and ending withthe first literal that is the opposite of another literal in the path.3.3. Cyclicity and induced graphsThe presence of cycles of clauses in a formula determines the complexity of some problems related to I.E.S.’s.Formally, cycles are defined as follows.Definition 4 (Simple cycle of binary clauses). A cycle of binary clauses is a sequence of clauses [¬l1 ∨ l2, ¬l2 ∨l3, . . . , ¬ln ∨ l1] such that no literal li occurs in more than one clauses (no variable occurs in more than two).This definition only covers simple cycles of clauses, that is, we are not allowed to “cross” the same literal twice.Defining a non-simple cycle of clauses is possible but not necessary in this paper because we only classify formulaedepending on whether they have cycles or not.The graph of a 2CNF formula induced by a literal is, roughly speaking, the graph of literals that can be derivedfrom the given one by unit propagation.Definition 5. The graph induced by a literal l on a 2CNF formula Π is the minimal (as of containment of the sets ofnodes and edges) graph (N, E) such that:(1) l ∈ N ;(2) if l(cid:5) ∈ N and ¬l(cid:5) ∨ l(cid:5)(cid:5) ∈ Π , then l(cid:5)(cid:5) ∈ N and (l(cid:5), l(cid:5)(cid:5)) ∈ E.A property of acyclic formulae is that all their induced subgraphs are acyclic and vice versa.Property 4. A 2CNF formula Π contains simple cycles if and only if some of its induced graphs contain cycles.Formulae not containing cycles have some interesting properties. First, consistent acyclic 2CNF formulae notentailing any literal have a single I.E.S., which makes some problems related to I.E.S.’s computationally simpler. Thesecond result about acyclic formulae is that, for every two literals l1 and l2 that are entailed by the formula, the choiceof a minimal subset of clauses entailing l1 is independent on the choice for l2. These two results are proved in twolater sections.The following lemma shows that a chain of clauses that prove that Π ∪ {l} |=UP ⊥ cannot share clauses if theformula is acyclic.Lemma 5. In an acyclic 2CNF formula, the two chains of clauses from l to l(cid:5) and from l(cid:5) to ¬l(cid:5) do not share clauses.Proof. If both chains contain the same clause l(cid:5)(cid:5) ∨ l(cid:5)(cid:5)(cid:5), then the formula is cyclic, as these two chains cross the sameliteral l(cid:5)(cid:5) twice. If the first chain contains l(cid:5)(cid:5) ∨ l(cid:5)(cid:5)(cid:5) and the second l(cid:5)(cid:5)(cid:5) ∨ l(cid:5)(cid:5), then a cycle of clauses is l(cid:5)(cid:5)(cid:5) ∨ l(cid:5)(cid:5), the chainfrom l(cid:5)(cid:5) to ¬l(cid:5), and the reverse of the chain from l(cid:5)(cid:5)(cid:5) to l(cid:5)(cid:5). (cid:2)3.4. Analysis is done on three cases separatelyAs already mentioned, the analysis of the problem of redundancy checking and of the problems about I.E.S.’s isdone separately for three cases:(1) the formula is inconsistent;(2) the formula is consistent and implies some literals;(3) the formula is consistent and does not imply literals.P. Liberatore / Artificial Intelligence 172 (2008) 265–299271Fig. 2. An I.E.S. of a consistent formula.Fig. 3. An I.E.S. of a consistent formula entailing a literal.Fig. 4. An I.E.S. of an inconsistent formula.We can now explain why these three cases require a different analysis. Let us consider first the last case: a formulanot implying any literal. By Lemma 4, a clause is entailed by a formula if and only if one of its literals can be derivedby unit propagation from the negation of the other one. If γ ∈ Π and Π (cid:5) is an I.E.S. of Π , then Π (cid:5) |= γ . As a result,the problem of redundancy and the problems about I.E.S.’s can be reformulated in terms of formulae whose inducedgraphs have the same reachability relation of the graphs of the original formula. Fig. 2 exemplifies this idea.This requirement, however, is too restrictive when considering literals that are implied by the formula. For example,if l2 is reachable from l1 in the original formula but ¬l1 is entailed by the formula, this reachability condition is notnecessarily true in all I.E.S.’s of the formula. Indeed, all that is needed is that unit propagation from l1 allows reachingcontradiction; the condition that l2 is reachable from l1 is not necessarily true in all I.E.S.’s of the formula. Such acondition is shown in Fig. 3.Finally, if a formula is inconsistent then its I.E.S.’s are only required to be inconsistent. Not only these I.E.S.’s canhave a reachability relation different from that of the original formula; they can even omit to mention some literalsat all. Indeed, a subset of an inconsistent formula can be inconsistent even if it does not mention some literals of theoriginal formula. Fig. 4 shows an example where an I.E.S. does not mention two variables l1 and l2 of the originalformula, and consistency is guaranteed via variable x.Summarizing, the three cases are studied separately because of the different requirements on equivalent subsets:in the first case, reachability using unit propagation is the same in the I.E.S.’s and in the formula; in the second case,only reachability of ⊥ from the negation of implied literals is the same; in the third case, only the reachability of ⊥from an arbitrary pair of opposite literals is the same.3.5. Inconsistent 2CNF formulaeIn this section we present some results about irredundant inconsistent 2CNF formulae. The first result is that sucha formula cannot be acyclic, if it contains no unary clauses but only binary ones.Theorem 1. Every inconsistent set of binary clauses is cyclic.In general, a 2CNF may contain unary clauses, and can therefore be cyclic and inconsistent at the same time. Asan example, {x, ¬x ∨ y, ¬x ∨ ¬y} is inconsistent but acyclic. If a 2CNF formula includes unary clauses, we generallyturn these clauses into equivalent binary clauses: x is for example replaced by ¬x ∨ z and ¬x ∨ ¬z, where z is a new272P. Liberatore / Artificial Intelligence 172 (2008) 265–299variable. This transformation can create cycles but, as proved by the next lemma, this only happens if the formula isinconsistent.Lemma 6. Every 2CNF formula Π containing a unit clauses l is equivalent to Π\{l} ∪ {l ∨ y, l ∨ ¬y}, where y is anew variable; this second formula is cyclic only if Π is either cyclic or inconsistent.An acyclic 2CNF can be inconsistent only if it contains unary clauses. Since its I.E.S.’s are inconsistent as well,they contain at least one unary clause each. On the other hand, an irredundant acyclic 2CNF formula contains at mosttwo unary clauses. This is proved using the following lemma.Lemma 7. Every resolution tree rooted with ⊥ of a 2CNF formula has at most two unary clauses in the leaves.This lemma proves that inconsistency of a 2CNF formula can always be proved using a resolution tree having atmost two unary clauses in the leaves. Since the set of leaves of such tree are sufficient to prove inconsistency, twounary clauses are always sufficient to prove inconsistency.Lemma 8. Every irredundant inconsistent 2CNF formula contains at most two unary clauses.The following theorem shows that, if the binary clauses of a 2CNF formula are consistent while the whole formulais inconsistent, this inconsistency can be proved using unit propagation.Lemma 9. If Π is an irredundant inconsistent 2CNF, Π (cid:5) and Π (cid:5)(cid:5) are the set of its unary and binary clauses, respec-tively, and Π (cid:5)(cid:5) is consistent, then Π (cid:5) ∪ Π (cid:5)(cid:5) |=UP ⊥.These lemmas, together with Lemma 5, will be used to prove that the considered problems about I.E.S.’s arepolynomial on 2CNF formulae that are both inconsistent and irredundant. This is because one can test propagationfrom one unit clause at time, checking the minimal number of clauses needed to reach, by unit propagation, either apair of opposite literals or the negation of another unit clause.3.6. Formulae implying literalsA consistent 2CNF formula Π may imply some literals or not. We show that, as long as redundancy and I.E.S.’sare concerned, we can treat the clauses containing an implied literal and those not containing them separately. A firstobvious property is that we can replace all clauses containing an entailed literal with the literal itself: if Π |= l, thenwe can add l to Π and remove all clauses of the form l ∨ l(cid:5).Lemma 10. If Π is a CNF formula such that Π |= l, then Π and Π\(Π|l) ∪ {l} are equivalent.Replacing all clauses containing an entailed literal with the literal itself does not only preserve equivalence but alsothe redundancy of clauses not containing the entailed literal.Lemma 11. Let Π be a formula implying the literal l. If the clause γ ∈ Π does not contain l, then γ is redundant inΠ if and only if it is redundant in Π\(Π|l) ∪ {l}.This lemma shows that clauses not containing literals entailed by the formula can be checked for redundancyafter the clauses containing entailed literals have been replaced by the entailed literals. The following corollary is anobvious consequence of this lemma.Corollary 1. If Π is a consistent 2CNF such that Π |= l, then Π contains a redundant clause not containing l if andonly if Π\(Π|l) ∪ {l} is redundant.P. Liberatore / Artificial Intelligence 172 (2008) 265–299273This corollary shows that, once we have determined that all clauses containing a literal l such that Π |= l areirredundant, we can replace all such clauses with l. Repeating this procedure for all literals implied by the formula,we obtain a formula with disjoint unit and binary clauses. This is because, if Π |= l, every clause l ∨ l(cid:5) is replaced byl, while every clause ¬l ∨ l(cid:5) is replaced by l(cid:5) as Π |= l(cid:5). As a result, no binary clause contains a variable that is in aunit clause in the resulting formula.A similar result holds about I.E.S.’s: replacing clauses containing entailed literals with these literals both in theformula and in one of its I.E.S.’s generates a formula and one of its I.E.S.’s.Lemma 12. Let Π be a consistent 2CNF such that Π |= l. If Π (cid:5) is an I.E.S. of Π then Π2 = Π (cid:5)\(Π|l) ∪ {l} is anI.E.S. of Π\(Π|l) ∪ {l}.The converse of this lemma does not hold. Even if Π2 is an I.E.S. of Π\(Π|l) ∪ {l}, it is not necessarily true thatan I.E.S. of Π can be obtained by simply adding some clauses of Π|l to it. Actually, even adding all clauses of Π|ldoes not necessarily lead to a formula that is equivalent to Π , as the following example shows.Π = {x ∨ x1, x ∨ x2, ¬x1 ∨ y, ¬x2 ∨ ¬y, ¬x ∨ y}l = xΠ\(Π|l) ∪ {l} = {¬x1 ∨ y, ¬x2 ∨ ¬y, ¬x ∨ y, x}Π2 = {¬x2 ∨ ¬y, ¬x ∨ y, x}Π2\{l} ∪ (Π|l) = {¬x2 ∨ ¬y, ¬x ∨ y, x ∨ x1, x ∨ x2}It holds Π |= x: this can be proved by adding ¬x to Π and using unit propagation: x1 and x2 are derived, leadingto y and ¬y, respectively. It is also easy to prove that Π2 is equivalent to Π\(Π|l) ∪ {l}: since ¬x ∨ y and x entail y,the clause ¬x1 ∨ y is entailed by Π2. The irredundancy of Π2 is also easy to prove: removing a single clause from it,either x, y, or ¬x2 cannot be derived any longer. Adding all clauses of Π|l to Π2, however, does not allow to derivex any longer. Indeed, Π2\{l} ∪ (Π|l) has the model in which ¬x, x1, x2, and ¬y are true, which assigns false to x.An analysis of this counterexample shows why the converse of Lemma 12 is false. The problem is with the clause¬x ∨ y, which makes y true in the original formula. This clause allows to remove ¬x1 ∨ y, which was necessary inΠ to entail x. Without the clause ¬x ∨ y, indeed, the converse of Lemma 12 would hold for Π and l = x. In theappendix we detail how this counterexample invalidates a candidate proof of the converse of Lemma 12.The following easy lemma and corollary show a separation in the variables of some clauses.Lemma 13. Every clause of a 2CNF formula Π either is in Π|Π|= or does not contain literals in Π|= nor theirnegation.Corollary 2. For every 2CNF formula Π , it holds that Π\(Π|Π|=) and Π|= do not share variables.This corollary is the base of the next result. Indeed, it shows that Π\(Π|Π|=) ∪ Π|= is composed of two partsΠ\(Π|Π|=) and Π|= not sharing variables. The same result therefore holds when referred to an arbitrary subset of Π ,and in particular it holds for all of its I.E.S.’s. The following lemma proves that replacing at once all clauses of Π|Π|=with Π|=, the converse of Lemma 12 holds.Lemma 14. Let Π be a consistent 2CNF formula. If Π2 is an I.E.S. of Π\(Π|Π|=) ∪ Π|=, then Π2\Π|= ∪ (Π|Π|=) isequivalent to Π .Proof sketch. Since Π and Π\(Π|Π|=) ∪ Π|= are equivalent and Π2 is an I.E.S. of Π\(Π|Π|=) ∪ Π|=, we have thatΠ2 and Π are equivalent. The claim is proved by showing that Π2\Π|= ∪ (Π|Π|=) entails Π|=. This would prove thatΠ2\Π|= ∪ (Π|Π|=) is equivalent to Π2\Π|= ∪ (Π|Π|=) ∪ Π|=, which is a superset of Π2 and is therefore equivalentto Π .Intuitively, the proof is as follows: if l ∈ Π|=, then there is a proof of l in Π . This proof involves some clauses ofΠ|Π|= and some clauses in Π\(Π|Π|=). On the other hand, everything that is entailed in Π is also entailed in its274P. Liberatore / Artificial Intelligence 172 (2008) 265–299equivalent formula Π2\(Π|Π|=) ∪ Π|=. Since Π2\(Π|Π|=) and Π|= are built over disjoint literals, every clause of Πnot containing literals that are entailed by Π is derivable in Π2\(Π|Π|=). (cid:2)This lemma only proves that Π2\Π|= ∪ (Π|Π|=) is equivalent to Π , but does not prove it is an I.E.S. of Π . Ingeneral, this is not true. However, we can show that an I.E.S. can be obtained from this set by removing only someclauses of Π|Π|=.Lemma 15. Let Π be a consistent 2CNF formula. If Π2 is an I.E.S. of Π\(Π|Π|=) ∪ Π|=, then there exists Π1 ⊆Π|Π|= such that Π1 ∪ (Π2\Π|=) is an I.E.S. of Π .Proof sketch. Lemma 14 shows that adding Π|Π|= to Π2\Π|= results in a set that is equivalent to Π . The statementof the present lemma could be false only if an I.E.S. could be obtained by removing a clause of Π2\Π|=. This isequivalent to the redundancy of such a clause in Π2\Π|= ∪ (Π|Π|=). This is in turn proved to be false by showing,via some simple manipulation of formulae, that it is equivalent to the redundancy of Π2. (cid:2)The converse of this lemma is an immediate consequence of a repeated application of Lemma 12. We can thereforeconclude the following corollary.Corollary 3. Π2 is an I.E.S. of Π\(Π|Π|=) ∪ Π|= if and only if there exists Π1 ⊆ Π|Π|= such that Π1 ∪ (Π2\Π|=) isan I.E.S. of Π .We show a lemma about clauses containing a literal that is entailed by the formula.Lemma 16. Every consistent 2CNF formula Π implying a literal l and containing three or more clauses containing lcontains at least a redundant clause containing l.Proof sketch. If l ∈ Π , any other clause containing l is redundant. If l /∈ Π , the proof is based on the fact that Π ∪{¬l} |=UP ⊥ since Π is consistent. In turn, this is equivalent to ¬l implying two opposite literals by unit propagation,which requires two (possibly disjoint) chains of clauses. The first two clauses of these chains are therefore the onlytwo clauses containing l that are necessary to entail l; all other clauses containing l are then entailed by l and thereforeredundant. (cid:2)An obvious consequence of this lemma is that every consistent and irredundant 2CNF formula implying a literalcontains at most two clauses containing that literal.3.7. Acyclic consistent 2CNF formulae not implying literals have a single I.E.S.We show that every acyclic consistent 2CNF formula not implying any literal has a single I.E.S. If Π is consistentand Π (cid:3)|= l for every literal l, we have that Π |= ¬l ∨ l(cid:5) holds if and only if Π ∪ {l} |=UP l(cid:5). The same holds for allsubsets of Π and, in particular, for all its I.E.S.’s.Lemma 17. If Π is a consistent acyclic 2CNF and Π ∪ {l} |=UP l(cid:5), then Π (cid:5) ∪ {l} |=UP l(cid:5) holds for every I.E.S. Π (cid:5)of Π .Proof sketch. Both antecedent and consequent of the statement are equivalent to entailment of l ∨ l(cid:5), and a formulaand its I.E.S.’s are equivalent and therefore imply the same clauses. (cid:2)Every literal l partitions Π into the set of clauses that are involved in the first step of unit propagation from l andthe other ones:DΠ (l) = {γ ∈ Π | γ = ¬l ∨ lRΠ (l) = Π\DΠ (l)(cid:5)}P. Liberatore / Artificial Intelligence 172 (2008) 265–299275Fig. 5. The graph induced by a literal l on a 2CNF formula.Fig. 6. RΠ (l) and MΠ (l).The clauses in DΠ (l) are those used in the first step of unit propagation from l. The following set CΠ (l) is the setof literals that would result from this propagation.CΠ (l) = {l(cid:5) | ¬l ∨ l(cid:5) ∈ Π} =(cid:5) | ¬l ∨ l(cid:2)l(cid:3)(cid:5) ∈ DΠ (l)Since all clauses ¬l ∨ l(cid:5) in DΠ (l) are also in Π , they are entailed by every I.E.S. Π (cid:5) of Π . Since Π is a consistentCNF, so are all its subsets, and Π (cid:5) in particular. Since Π (cid:5) entails ¬l ∨ l(cid:5) and Π (cid:5) is consistent and not entailing literals,l(cid:5) is reachable from l in the graph induced by l on Π (cid:5).In turn, a given l(cid:5) ∈ CΠ (l) is reachable from l if and only if either ¬l ∨ l(cid:5) ∈ Π (cid:5), or there is another literal l(cid:5)(cid:5) suchthat ¬l ∨ l(cid:5)(cid:5) ∈ Π (cid:5) and l(cid:5) is reachable from l(cid:5)(cid:5) using the edges corresponding to the clauses of RΠ (l).Fig. 5 shows an example of a graph induced by a literal l on a 2CNF formula. In this example, ¬l ∨ l4 cannot beremoved from Π because it is the only clause allowing l4 to be reached from l. The same holds for ¬l ∨ l1. The clauses¬l ∨ l2 and ¬l ∨ l3 are instead redundant because l2 and l3 can be reached from l by following the edge correspondingto the clause ¬l ∨ l1 and then following some edges corresponding to clauses in RΠ (l).This example shows that the irredundant clauses are those containing the literals of CΠ (l) that cannot be reachedfrom other literals of CΠ (l). Such literals necessarily exist because the formula (and therefore all its induced graphs)is acyclic (and finite).MΠ (l) = {l(cid:5)(cid:5) ∈ CΠ (l) such that RΠ (l) ∪ {l(cid:5) ∈ CΠ (l) |(cid:3) ∃l(cid:5)(cid:5)} |=UP l(cid:5)}Formally, MΠ (l) is the set of literals that cannot be reached from other literals of CΠ (l) using unit propagation onthe clauses RΠ (l). In the example above, RΠ (l) and MΠ (l) are as shown in Fig. 6.The nodes that cannot be reached from other nodes are l1 and l4. Therefore, MΠ (l) = {l1, l4}. The followingcorollary states that MΠ (l) characterizes the irredundant clauses containing l. Its ancillary lemmas and their proofsare in the appendix.Corollary 4. A clause ¬l ∨ l1 is in an I.E.S. of the consistent acyclic 2CNF formula Π if and only if l1 ∈ MΠ (l).Since the statement of this corollary is in an “if and only if” form, once l1 ∨ l2 is proved to be in an I.E.S. becausel2 ∈ MΠ (¬l1), we do not need to also check l1 ∈ MΠ (¬l2). The same holds if l1 ∨ l2 is proved not to be in an I.E.S.in the same way. This result tells that every 2CNF consistent acyclic formula that does not imply literals has a singleI.E.S.276P. Liberatore / Artificial Intelligence 172 (2008) 265–299Theorem 2. Every consistent acyclic 2CNF formula Π not implying literals has a single I.E.S.Proof. For each clause l1 ∨ l2, check whether l2 ∈ MΠ (¬l1). If this is true, then l1 ∨ l2 is in all I.E.S.’s, otherwise itis in no I.E.S. Therefore, the set composed of all clauses l1 ∨ l2 such that l2 ∈ MΠ (¬l1) is the single I.E.S. of Π . (cid:2)3.8. Implied literals not in a cycle of a consistent 2CNF formulaIn this section, we consider the redundancy of clauses containing a literal that is entailed by a consistent formulabut is not in a cycle of clauses. We show that, if l(cid:5) and l(cid:5)(cid:5) are two such literals, then we can independently chooseamong clauses containing l(cid:5) and from clauses containing l(cid:5)(cid:5) to form an I.E.S. In other words, an I.E.S. can be obtainedby choosing a subset of clauses containing l(cid:5) and a subset of clauses containing l(cid:5)(cid:5), and these choices are independentfrom each other.By Lemma 2, since Π is consistent, Π |= ¬l holds if and only if Π ∪ {l} |=UP ⊥. Using the transformation ofSection 3.2, we can assume that Π does not contain unary clauses. Therefore, Π ∪ {l} |=UP ⊥ means that we canreach a pair of opposite literals by propagating l in Π . The following notations have been introduced in the previoussection:DΠ (l) = {γ ∈ Π | γ = ¬l ∨ lRΠ (l) = Π\DΠ (l)(cid:5) | ¬l ∨ lCΠ (l) = {l(cid:5) ∈ Π}(cid:5)}Since Π |= ¬l, every equivalent subset of Π allows reaching a pair of opposite literals from l. This is possible ifand only if either one of the two following conditions is true:(1) ¬l ∨ l1 ∈ Π and Π ∪ {l1} |=UP ⊥;(2) ¬l ∨ l2 ∈ Π and Π ∪ {l2} |=UP ¬l, which is equivalent to:¬l ∨ l2 ∈ Π , Π ∪ {l2} |=UP ¬l3, and l3 ∨ ¬l ∈ Π .If Π (cid:5) is an I.E.S. of Π , these conditions hold for Π if and only if they hold for Π (cid:5). In addition, if Π does notcontain a cycle including l, the same holds for Π (cid:5). As a result, unit propagation from l1 to ⊥ or from l2 to ¬l3 cannotinclude l, as otherwise l would be part of a cycle.Consider the formula graphically represented in Fig. 7. All paths from l1 to ⊥ and from l2 to ¬l3 are entirelycontained in RΠ (l): otherwise, l would be part of a cycle. As a result, the same derivations are possible in an I.E.S.Π (cid:5) of Π if and only if they are possible using only clauses of RΠ (l), that is, they are possible in Π (cid:5) ∩ RΠ (l). In otherwords, Π (cid:5) ∪ {l1} |=UP ⊥ if and only if (Π (cid:5) ∩ RΠ (l)) ∪ {l1} |=UP ⊥, and the same for the derivation of ¬l3 from l2. Asa result, Π (cid:5) ∩ RΠ (l) always entails l with the addition of either ¬l ∨ l1 or the pair ¬l ∨ l2 and ¬l ∨ l3.Let us formally denote the sets of literals like l1 and of pairs of literals like l2 and l3.Fig. 7. An example formula.P. Liberatore / Artificial Intelligence 172 (2008) 265–299277SΠ (l) =PΠ (l) =(cid:2)l1 ∈ CΠ (l) | RΠ (l) ∪ {l1} |=UP ⊥(cid:2)(l2, l3) ∈ CΠ (l) | RΠ (l) ∪ {l2} |=UP ¬l3(cid:3)(cid:3)\SΠ (l)In words, SΠ (l) is the set of literals we can reach contradiction from using unit propagation in RΠ (l) while PΠ (l)is composed of pairs of literals such that the negation of one is reachable from the other in RΠ (l). The above reasoningis formalized by the next lemma, which is formally proved in the appendix.Lemma 18. If Π (cid:5) is an I.E.S. of a consistent acyclic 2CNF formula Π such that Π |= ¬l and l is not in any cycle ofclauses of Π , then the following are all I.E.S.’s of Π :(1) (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l1} with l1 ∈ SΠ (l);(2) (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l2, ¬l ∨ l3} with (l2, l3) ∈ PΠ (l).This lemma shows a simple way for determining an I.E.S. of an acyclic consistent formula: for each literal l suchthat Π |= ¬l, we choose either a clause l ∨ l1 with l1 ∈ SΠ (l) or a pair of clauses l ∨ l2 and l ∨ l3 with (l2, l3) ∈ PΠ (l).By the above lemma, we can do this choice for all clauses containing a literal that is entailed by the formula.4. Redundancy checkingIn this section, we consider the problem of checking whether a 2CNF formula is redundant. If m is the number ofclauses of a 2CNF formula, the size such a formula is between m and 2m. Checking consistency of a set of binaryclauses can be done in linear time, and therefore in time O(m). The trivial algorithm of checking whether Π\{γ } |= γfor each γ ∈ Π requires O(m) for each clause, and therefore O(m2) total time. We improve over this result byshowing algorithms that solve the problem in time O(nm), where n is the number of variables of the formula, in allthree possible cases (inconsistent formulae, formulae implying literals or not.) Cyclicity does not affect the problemof checking redundancy. Here is a summary of the results in the various cases.The formula is inconsistent. If a set is both inconsistent and irredundant, the number of its clauses is at most fourtimes the number of variables. Therefore, if the number of clauses is greater, the set is redundant. If it islower, we still have to check redundancy, but the running time O(mm) of the trivial algorithm is now thesame as O(nm).The formula is consistent. For each literal l, we proceed differently depending on whether Π |= l holds or not.The formula implies the literal. If Π |= l then either Π is inconsistent or Π |=R l. Since Π is by assumptionconsistent, we have Π |=R l. By Lemma 2, we have Π ∪ {¬l} |=UP ⊥. We consider two casesseparately.l is in three or more clauses. Formula Π is redundant by Lemma 16.l is in one or two clauses. By assumption Π ∪ {¬l} |=UP ⊥. In order to check redundancy, justremove any of the two clauses containing l and check whether UP still leads to ⊥ from l.Two UP derivations, which are linear in the number of clauses, are needed for the literal l.The formula does not imply the literal. Since Π (cid:3)|= l we have Π\{¬l ∨ l(cid:5)} |= ¬l ∨ l(cid:5) if and only if Π\{¬l ∨l(cid:5)} ∪ {l} |=UP l(cid:5). Therefore, we can consider the graph induced by the unit propagation of l in Π ,and check whether l(cid:5) is reachable from l without using the edge corresponding to ¬l ∨ l(cid:5). This testcan be done in linear time by a modified algorithm of graph reachability.The description of the algorithms and their proofs of correctness are given in the following three sections.4.1. Redundancy checking: inconsistent 2CNF formulaeLemma 3 shows that every inconsistent 2CNF formula contains some clauses allowing both x and ¬x to derive ⊥by unit propagation. In turn, this implies the existence of two acyclic chains of clauses that allow the derivation of twoopposite literals from x and ¬x, respectively.278P. Liberatore / Artificial Intelligence 172 (2008) 265–299Lemma 19. A 2CNF formula Π is inconsistent and irredundant if and only if it is composed of two simple chains ofclauses like the following ones:x ∨ l1, ¬l1 ∨ l2,¬x ∨ p1, ¬p1 ∨ p2,. . . , ¬lm ∨ y, ¬y ∨ s1,. . . , ¬sm ∨ ¬y. . . , ¬pm ∨ z, ¬z ∨ q1,. . . , ¬qm ∨ ¬zThis lemma shows that every inconsistent and irredundant set of clauses is composed exactly of two chains ofclauses, each one not containing the same literal twice. The length of each such chain is at most the number ofliterals; therefore, the number of clauses of such formula is at most two times the number of literals. Therefore, if aninconsistent 2CNF formula contains a number of clauses that is greater than four times the number of its variables, itis redundant. If it contains less clauses, O(nm) and O(mm) are the same. Therefore, checking the consistency of Π\γfor each γ ∈ Π has complexity O(nm).4.2. Redundancy checking: Consistent 2CNF formulae implying literalsWhen a formula is consistent but implies some literals, the redundancy of clauses l ∨ l(cid:5) such that Π |= l can bechecked in linear time: time O(m) is required for every literal l that is implied by Π . The redundancy of the otherclauses can be then checked by verifying the redundancy of Π\(Π|l) ∪ {l} by Lemma 1. Performing this step forevery literal that is entailed by Π produces the formula Π\(Π|Π|=) ∪ Π|=. The two parts Π\(Π|Π|=) and Π|= of thisformula do not share variables by Lemma 2; the first part does not entail any literal. The redundancy of the first partcan therefore be checked using the algorithm of the next section.Let l be a literal such that Π |= l. By Lemma 2, we have Π ∪ {¬l} |=UP ⊥, which means that unit propagationfrom ¬l derives both a literal and its negation. In other words, there exists a variable x such that Π ∪ {¬l} |=UP x andΠ ∪ {¬l} |=UP ¬x. By definition, there are then two acyclic paths in the graph of Π induced by ¬l, one from ¬l to xand one from ¬l to ¬x. The first clause of each of these two paths are the only clauses that are necessary to derive xand ¬x from ¬l. Regardless of whether these two clauses are the same or not, they are the only clauses containing lthat are necessary to prove Π ∪ {¬l} |=UP ⊥. As a result, if l is contained in more than two clauses of Π , this formulais redundant.In order to check the redundancy of clauses l ∨ l(cid:5) such that Π |= l, we first check whether the number of suchclauses is greater than two. If this is the case, the set is redundant. Otherwise, we check the redundancy of the clausesl ∨ l(cid:5) by simply performing the linear-time entailment check Π\{l ∨ l(cid:5)} |= l ∨ l(cid:5) for all such clauses l ∨ l(cid:5). Since thereare most two such clauses, this test only requires linear time. This test is repeated for all literals l such that Π |= l;therefore, the total running time is O(nm).4.3. Redundancy checking: Consistent 2CNF formulae not implying literalsWe show that the redundancy of 2CNF consistent formulae not implying literals can be checked in time O(nm),where n is the number of variables and m is the number of clauses of the formula.Let Π be a consistent 2CNF formula not implying any literal, and let ¬l ∨ l(cid:5) be one of its clauses. Lemma 4can be simplified thanks to the assumption that no literal is implied: Π\{¬l ∨ l(cid:5)} |= ¬l ∨ l(cid:5) holds if and only ifΠ\{¬l ∨ l(cid:5)} ∪ {l} |=UP l(cid:5). Indeed, neither ¬l nor l(cid:5) are implied by Π , so they cannot be implied by Π\{¬l ∨ l(cid:5)} either.We therefore only have to check whether Π\{¬l ∨ l(cid:5)} ∪ {l} |=UP l(cid:5), which can be done by checking whether thegraph induced by l on Π contains a path from l to l(cid:5) that does not contain the edge corresponding to the clause¬l ∨ l(cid:5). We now show that this check can be done for all clauses containing ¬l at the same time in O(m). We recallthe definition of CΠ (l).CΠ (l) = {l(cid:5) | ¬l ∨ l(cid:5) ∈ Π}Redundancy of a clause ¬l ∨ l(cid:5) is equivalent to the existence of a path in the graph of Π induced by l from anotherliteral in CΠ (l) to l(cid:5). In general, if there is a path not containing l from a node in CΠ (l) to another node in CΠ (l), theformula is redundant. Consider for example the following graph induced by l on a formula. This formula is redundant,as we can delete the edge l → l(cid:5)(cid:5), and still l(cid:5)(cid:5) is reachable from l, as shown in Fig. 8.P. Liberatore / Artificial Intelligence 172 (2008) 265–299279Fig. 8. Clause ¬l ∨ l(cid:5)(cid:5)is redundant.Fig. 9. Reachability from the same node ofCΠ (l) does not prove redundancy.The first step of the algorithm is to remove l and all its incident edges from the graph. The second step is that ofchecking the existence of a path from CΠ (l) to CΠ (l) in the resulting graph. Note that no pair of opposite literals canbe reached from l because Π does not entail ¬l.A variant of the algorithm for node reachability can be used for doing this check while visiting the graph only once.The original algorithm for reachability is as follows:(1) the starting node is marked 0 while all other nodes are marked ∞;(2) at each step, take the set NH of nodes that are marked with the highest integer; let i be this integer:(a) for each n ∈ NH , consider all its successors m;(b) mark each m with the minimum among i + 1 and its previous marker;(3) if no label has been changed during Step 2, stop.The idea is that the label of the node is the distance from the starting node to it. By visiting the graph width-first,we are considering an edge at most once in the whole process. This is why the algorithm is linear.This algorithm can be applied to the problem of redundancy if the graph is acyclic: start with the nodes in CΠ (l)(instead of a single node), and visit the graph until a node in CΠ (l) is reached. In other words, if we reach a situationin which the successor m of a node n ∈ NH is in CΠ (l), then the set of clauses is redundant.The algorithm does not work for cyclic graphs: the formula is redundant if a node in CΠ (l) can be reached fromanother node in CΠ (l). On the contrary, if a node in CΠ (l) can be reached from itself, the formula is not necessarilyredundant: a cycle of this kind does not prove redundancy. Fig. 9 shows a node in CΠ (l) reachable from itself; whilea node in CΠ (l) is reachable from a node in CΠ (l), the set is not redundant.The algorithm must be modified in such a way it checks whether a node of CΠ (l) can be reached from anothernode of CΠ (l). This can be done by marking each node we visit not only with its distance from CΠ (l), but also withthe nodes of CΠ (l) it is reachable from.This variant of the node reachability algorithm is however not linear because the set of nodes of CΠ (l) a node isreachable from may grow to contain all nodes. However, when a node is reachable from two or more different nodesof CΠ (l), we do not have to care about the node we started from any longer. Indeed, if a node l(cid:5) is reachable from two(or more) different nodes l1, l2 ∈ CΠ (l), and a node of l3 ∈ CΠ (l) is reachable from l(cid:5), then either l1 or l2 is differentfrom l3. As a result, the graph contains a path from l1 to l3 or one from l2 to l3, and at least one between l1 and l2 isdifferent from l3. As a result, once a node l is known to be reachable from two different nodes of CΠ (l), we only needto check whether a node of CΠ (l) can be reached from l.The algorithm is as follows. In a first phase, labels of nodes can be either (i, n), where n ∈ CΠ (l) and i is an integer,or the special mark two.(1) each node of n ∈ CΠ (l) is marked with (0, n); take N0 = CΠ (l); set i = 0;(2) set Ni+1 = ∅;(3) let m ∈ Ni , and let (i, n) be its marker; for any of its successors t:280P. Liberatore / Artificial Intelligence 172 (2008) 265–299(a) if t is not marked, mark it with (i + 1, n), and put t in Ni+1;(b) if t is marked with (j, n), it must be j (cid:2) i; do not change its marker;(c) if t is marked with (j, s), with n (cid:3)= s, mark it with two;(d) if t is marked with two, do not change its mark.(4) if Ni+1 is empty, stop; otherwise, set i = i + 1 and go to step 2.This is almost the usual visit of the graph width-first. The point is that we mark the nodes not only with theirdistance from CΠ (l), but also with the node they can be reached from. Whenever a node is found out to be reachablefrom two nodes of CΠ (l), we mark it with two and do not continue the search from it. If a node m ∈ CΠ (l) is thesuccessor of a node marked with (n, i), and n (cid:3)= m, then the graph is redundant. Note that the whole algorithm islinear, as each edge is at most traversed once.We now have to visit the successors of the nodes we have marked with two, and check whether any node of CΠ (l)can be reached from them. This can be done with the very same original reachability algorithm, which is still linearin time.This algorithm determines the redundancy of all clauses containing one literal in time O(m). Therefore, all clausescan be checked in time O(nm).5. Irredundant equivalent subsets (I.E.S.’s)The following problems about I.E.S.’s are polynomial for 2CNF formulae because of the polynomiality of entail-ment for this restriction.check whether a formula is an I.E.S. of another formula. Check containment and irredundancy;check whether a clause is in all I.E.S.’s. A clause γ is in allI.E.S.’s of a CNF formula Π if and only ifΠ\{γ } (cid:3)|= γ [17];uniqueness. A CNF formula Π has an unique I.E.S. if and only if {γ ∈ Π | Π\{γ } (cid:3)|= γ } |= Π [17].Two other problems require a more detailed analysis: the size of I.E.S. (checking whether a formula has an I.E.S.of size bounded by a number k) and the presence of a clause in an I.E.S. (checking whether a given clause is presentin an I.E.S. of a given formula).As it is clear from the two tables below, complexity, in the cases that have been successfully classified, does notdepend on whether the formula is consistent or implies literals. However, the proofs are different in the various cases.In the two tables below, “single” indicates formulae implying a single literal and “non-single” indicates formulae notimplying any literal.Size of I.E.S.inconsistentacycliccyclicP??singlePNP-hardnon-singlePNP-hardPresence in a I.E.S.inconsistentPNP-hardsinglePNP-hardnon-singlePNP-hardacycliccyclicWe use the following order of the cases: first, all acyclic cases, then all the cyclic cases; in each case, we firstconsider inconsistent formulae, then consistent formulae implying literals, and then consistent formulae not implyingliterals. In the rest of this section, we prove the results that easily follow from previous ones.The problems about inconsistent and acyclic 2CNF formulae can be easily proved polynomial. Acyclicity impliesthat the set of binary clauses is consistent by Theorem 1. Therefore, Lemma 8 and Lemma 9 apply: every I.E.S.P. Liberatore / Artificial Intelligence 172 (2008) 265–299281contains at most two unary clauses, and every I.E.S. can be proved inconsistent by applying unit propagation from itsunary clauses.This leads to the following algorithm for building an I.E.S. of minimal size: for every pair of literals, calculatethe minimal number of binary clauses (if any) that are necessary to derive the second literal from the first using unitpropagation. This can be done using an algorithm similar to the algorithm for the minimal distance in a graph. Giventhese distances, one can compute, for every unit clause l and literals l(cid:5), ¬l(cid:5), the minimal number of clauses needed toderive l(cid:5) from l and ¬l(cid:5) from l(cid:5). These two chains cannot contain the same clause by Lemma 5, so this is the minimalnumber of clauses needed to derive inconsistency by unit propagation from l. In a similar way, one can compute theminimal number of clauses to reach the negation of a unit clause from another unit clause.As for the presence of a clause in an I.E.S., one can proceed as follows: for every unit clause and pair of oppositeliterals, check whether there exists a path that comprises the clause and goes from the unit clause to the pair of oppositeliterals. In the same way, one checks whether there exists a path from a unit clause to the negation of another unitclause.The following two results about consistent acyclic 2CNF formulae have already been proved.• Acyclic consistent formulae not implying single literals have a unique I.E.S.• Building an I.E.S. for an acyclic consistent formula implying the literals l1, l2, . . . , ln can be done by choosingindependently some of the clauses containing l1, some of the clauses containing l2, etc.These two facts allow proving that, for acyclic consistent 2CNF formulae, one can determine presence and size ofI.E.S.’s in polynomial time.Theorem 3. The unique I.E.S. of a consistent acyclic 2CNF formula not implying literals can be found in quadratictime.Proof. Let Π be a consistent acyclic 2CNF formula. Since it has a single I.E.S., a clause is in its I.E.S. if and only ifit is in all its I.E.S.’s. Since checking presence in all I.E.S.’s can be done by checking Π\{γ } |= γ , and this inferenceis linear-time for 2CNF formulae, we can conclude that checking the presence of each clause in the unique I.E.S. ofthe formula can be done in linear time. (cid:2)The proof of the theorem shows a quadratic algorithm for generating the single I.E.S. of Π based only one theuniqueness of such an I.E.S. However, Lemma 4 allows for a slightly better algorithm: for each l, we can check allclauses ¬l ∨ l1 at once by visiting the graph RΠ (l). Since the construction and visit of RΠ (l) takes linear time, theoverall running time is O(nm), where n is the number of variables and m is the number of clauses of the formula.Theorem 4. The problems of presence of a clause in an I.E.S. and of existence of an I.E.S. of given size are polynomial-time for acyclic consistent 2CNF formulae.Proof. By Lemma 18, the presence of a clause l ∨ l(cid:5) with Π |= ¬l in an I.E.S. only depends on whether l(cid:5) ∈ SΠ (l)or there exists l(cid:5)(cid:5) such that (l(cid:5), l(cid:5)(cid:5)) ∈ PΠ (l). Since SΠ (l) and PΠ (l) can be checked in polynomial time by definition,checking the presence of a clause l ∨ l(cid:5) in an I.E.S. is a polynomial-time problem if Π |= ¬l. All other clauses can bechecked in polynomial time thanks to Corollary 3 and Theorem 3.One of the smallest I.E.S.’s of an acyclic formula can be built in a similar way but choosing ¬l or a clause ¬l ∨ l(cid:5)such that l(cid:5) ∈ SΠ (l) if possible, and a pair of clauses ¬l ∨ l(cid:5) and ¬l ∨ l(cid:5)(cid:5) with (l(cid:5), l(cid:5)(cid:5)) ∈ PΠ (l) otherwise. To accountfor the pair of clauses ¬l ∨ l(cid:5) and ¬l ∨ ¬l(cid:5) that replace the unit clause l by the transformation of Section 3.2, we countsuch a pair as it were a single clause. (cid:2)6. Size of I.E.S.In this section, we consider the problem of checking whether a formula has an I.E.S. of size bounded by a giveninteger k. This problem has already been proved polynomial for inconsistent and consistent acyclic 2CNF formulae.In this section, we prove the results for consistent cyclic formulae; the case for inconsistent cyclic formula is open.282P. Liberatore / Artificial Intelligence 172 (2008) 265–2996.1. Size of I.E.S.: Cyclic consistent 2CNF formulae implying literalsWe show that Lemma 18 does not hold if the literal l under consideration is in a cycle of clauses. Consider thefollowing formula:Π = {¬l(cid:5) ∨ l, ¬l ∨ l(cid:5), ¬l ∨ l(cid:5)(cid:5), ¬l(cid:5) ∨ x, ¬l(cid:5) ∨ ¬x, ¬l(cid:5)(cid:5) ∨ y, ¬l(cid:5)(cid:5) ∨ ¬y}The graph of Π induced by l is shown in Fig. 10, which clearly shows a simple cycle between the literals l and l(cid:5).For this formula, SΠ (l) = {l(cid:5), l(cid:5)(cid:5)}, while PΠ (l) = ∅. According to Lemma 18, if Π (cid:5) is an I.E.S. of Π , then we canreplace Π (cid:5) ∩ DΠ (l) with a single clause containing a literal of SΠ (l), and what results is still an I.E.S. of Π . We showa counterexample. The formula Π is equivalent to {¬l, ¬l(cid:5), ¬l(cid:5)(cid:5)}. The following is an I.E.S. of Π .(cid:5) = {¬l(cid:5) ∨ l, ¬l ∨ l(cid:5)(cid:5), ¬l(cid:5)(cid:5) ∨ y, ¬l(cid:5)(cid:5) ∨ ¬y}ΠΠ (cid:5) is represented by the graph in Fig. 11. This subset is equivalent to Π because it entails all three literals ¬l, ¬l(cid:5),and ¬l(cid:5)(cid:5). Indeed, ¬l(cid:5)(cid:5) is entailed by the clauses ¬l(cid:5)(cid:5) ∨ y and ¬l(cid:5)(cid:5) ∨ ¬y, while ¬l and ¬l(cid:5) are entailed by ¬l(cid:5) ∨ l and¬l ∨ l(cid:5)(cid:5), which make l(cid:5)(cid:5) reachable by unit propagation from l and l(cid:5).According to Lemma 18, we should be able to obtain another I.E.S. from Π (cid:5) by replacing all clauses of DΠ (l)with ¬l ∨ l(cid:5) in it, as l(cid:5) ∈ SΠ (l). Let Π (cid:5)(cid:5) = Π (cid:5)\DΠ (l) = {¬l(cid:5) ∨ l, ¬l(cid:5)(cid:5) ∨ y, ¬l(cid:5)(cid:5) ∨ ¬y}. If Lemma 18 were true for cyclicformulae, it would hold that Π (cid:5)(cid:5) ∪ {¬l ∨ l(cid:5)} is another I.E.S. of Π . This is however false, as this set does not implyneither ¬l nor ¬l(cid:5). Graphically, Π (cid:5)(cid:5) ∪ {¬l ∨ l(cid:5)} is represented in Fig. 12.This formula still entails ¬l(cid:5)(cid:5), but no longer entails either ¬l or ¬l(cid:5). These are indeed the two literals involved in theonly cycle of this formula. Intuitively, Lemma 18 does not hold for cyclic formulae because, while Π (cid:5) ∪ {l(cid:5)} |=UP ⊥still holds in any I.E.S. Π (cid:5) of Π for every l(cid:5) ∈ SΠ (l), the unit derivation of ⊥ from l(cid:5) might involve the literal l.Therefore, the choice of clauses containing l cannot be done independently on the choices of the other clauses.We show that the problem of checking the existence of an I.E.S. of a formula is NP-complete and remains NP-hardeven if the formula entails a literal for all variables but one. The following lemma is a needed preliminary result thatis obtained by applying a result by Fortune et al. [8].Lemma 20. Deciding whether a graph contains a simple cycle including two given nodes is NP-complete.Fig. 10. The graph of Π induced by l.Fig. 11. An I.E.S. of the formula of Fig. 10.Fig. 12. The graph of Π (cid:5)(cid:5)induced by l shows that Π (cid:5)(cid:5)is not an I.E.S. of Π .P. Liberatore / Artificial Intelligence 172 (2008) 265–299283Proof. Membership is obvious: guess a set of edges and check whether it is a simple cycle including the two nodes.Hardness holds because the presence of such cycle is equivalent to the homomorphism of the graph G = (cid:15){a, b},{a → b, b → a}(cid:16) with a subset of the graph. This problem is NP-hard because G does not contain a node that is thehead of all edges or a node that is the tail of all edges [8]. (cid:2)This theorem shows that the problem of checking whether a set of clauses implying a single literal, and containingcycles in the graph induced by the negation of this literal, is NP-complete.Theorem 5. Deciding whether a consistent 2CNF formula has an I.E.S. of size k is NP-complete and remains NP-hardeven if the formula implies a literal for every variable but one.Proof. Hardness is proved by reduction from the problem of checking the existence of a simple cycle in a graphcontaining two given nodes x and y. We assume that y is reachable from x and vice versa, and that all nodes can bereached and reach both x and y. If these conditions are not met, either the problem becomes trivial or the graph canbe purged of some nodes.The reduction is as follows: for each node of the graph there is a variable. Another variable z is also used. For eachedge a → b of the graph we have a clause ¬a ∨ b. We also add the two clauses ¬x ∨ z and ¬y ∨ ¬z, where x andy are the nodes that are checked for being in the same simple cycle. This set of clauses satisfy the condition of thetheorem, as both z and ¬z are reachable from any other positive literal.Let k be the number of nodes of the graph plus two. Let us assume that the graph contains a simple cycle includingboth x and y. In this case, an I.E.S. of size k is composed of the following clauses: ¬x ∨ z and ¬y ∨ ¬z; all clausescorresponding to the edges of the cycle; and a clause for every other node obtained by recursively adding a clauseconnecting a node to the cycle if not already. This I.E.S. is of size k because it contains a clause associated to anoutgoing edge of a node for each node of the original graph, with the only exception of x and y, for which the I.E.S.also contains the clauses ¬x ∨ z and ¬y ∨ ¬z.Let us assume that the graph does not contain simple cycles including both x and y. Since removing either ¬x ∨ zor ¬y ∨ ¬z makes the formula not to imply literals any longer, any I.E.S. of this formula contains these two clauses;more precisely, both z and ¬z must be reachable from any other positive literal in every I.E.S. of the formula. As aresult, x must be reachable from y and vice versa. However, since the graph does not contain any simple cycle, atleast one node w has two outgoing edges in these two paths. Since every positive literal but z must be associated anoutgoing edge in every I.E.S. of the formula, the total number of edges needed to form an I.E.S. is at least k + 1. (cid:2)6.2. Size of I.E.S.: Cyclic consistent formulae not implying literalsThe problem of determining whether a formula has an I.E.S. of size at most k is NP-complete if the formula isconsistent and cyclic. This is in particular true even if the formula does not entail any literal.Theorem 6. Deciding whether a 2CNF formula has an I.E.S. of size bounded by k is NP-complete, and remainsNP-hard even if the formula implies that all variables are equivalent and does not imply any single literal.Proof. The problem of finding a minimum equivalent subgraph is NP-complete. In particular, it remains completeeven if the graph is strongly connected [14,24]. This is the problem of finding the minimum number of edges of thegraph that makes the resulting graph strongly connected.We show a reduction from this problem to that of checking whether there exists an I.E.S. of a 2CNF formula Πof size bounded by k. Let G = (N, E) be a graph. The set of variables of Π is the set of nodes N . For each edge(i, j ) the set Π contains the clause ¬i ∨ j . For any two nodes i and j , the node j is reachable from i if and onlyif Π ∪ {i} |=UP j . In order to complete the proof, we only have to show that Π (cid:3)|= l for any literal l: if this is true,then reachability is in one-to-one correspondence with entailment, thus showing that equivalence of graphs impliesequivalence of the corresponding formulae and vice versa.Since each clause contains a positive and a negative literal, it is satisfied both by the model setting all variables totrue and by the model setting all variables to false. These are therefore both models of Π . However, if one of themsatisfies a literal l, the other one does not. Therefore, no literal l is implied by Π . (cid:2)284P. Liberatore / Artificial Intelligence 172 (2008) 265–2997. Presence in an I.E.S.In this section, we study the problem of checking whether a clause is contained in some I.E.S.’s of a given 2CNFformula. For acyclic sets, the problem has already been proved polynomial. This result holds even if some cycles arepresent but none include the clause to check, in the case of consistent formulae; a formal proof of this statement isgiven in Appendix A.8. We now prove that the problem is NP-complete for cyclic formulae, regardless of whether theformula is consistent or implies some literals.7.1. Presence in an I.E.S.: Cyclic inconsistent 2CNF formulaeThe problem of deciding the presence of a clause in an I.E.S. of an inconsistent 2CNF formula is NP-hard if theformula contains cycles. We use this simple preliminary lemma.Lemma 21. The problem of checking in a graph the existence of a simple path from node x to node y including agiven edge is NP-complete.We can now prove that the problem of presence of a clause in an I.E.S. is NP-complete if the formula is inconsistentand cyclic.Theorem 7. Deciding whether a cyclic inconsistent 2CNF formula has an I.E.S. that contains a given clause is NP-complete.Proof. Membership is obvious, as the problem can be solved by guessing a subset of the formula and then checkingwhether it is an I.E.S. and contains the given clause. Hardness is proved by reduction from the problem of checkingwhether a graph contains a simple path from a node to another one that includes a given edge.Given the instance of the original problem (G, x, y, a, b), in which we want to determine whether there exists asimple path from x to y including the edge a → b, we build a formula Π as follows: for each node of the graph, wehave a variable; for each edge n → m of the graph, we have the clause ¬n ∨ m; finally, we add the following clauses,where z and w are new variables:{¬y ∨ z, ¬y ∨ ¬z, x ∨ w, x ∨ ¬w}Graphically, Π can be represented as in Fig. 13.Removing even a single clause containing z or w makes the formula satisfiable. Therefore, these clauses are in allI.E.S.’s of the formula. Since a 2CNF formula is unsatisfiable if and only if Π ∪ {w} |=UP ⊥ and Π ∪ {¬w} |=UP ⊥ forsome variable w, these four clauses must necessarily be all included in the paths from w and ¬w to ⊥, as otherwiseone of these clauses would be redundant. As a result, Π (cid:5) is an I.E.S. of Π if and only there exists a literal l such thaty is reachable from l and ¬x is reachable from ¬l. The second condition is equivalent to l being reachable from x;therefore, the two conditions are equivalent to the existence of a path from x to y. As a result, Π (cid:5) is an I.E.S. of Π ifand only if it contains the four clauses containing z and w, and a path from x to y.If this path from x to y in a subset of the formula is cyclic, the formula is not irredundant because all clauses inthe cycle can be removed while preserving the reachability of y from x and therefore preserving unsatisfiability. As aresult, the I.E.S.’s of the formula are in a bijection with the simple paths from x to y. Such a formula contains ¬a ∨ bif and only if there exists a simple path from x to y including the edge a → b. (cid:2)Fig. 13. Graphical representation of Π .P. Liberatore / Artificial Intelligence 172 (2008) 265–2992857.2. Presence in an I.E.S.: Cyclic consistent 2CNF formulae implying literalsIn this section we consider the problem of presence of a clause in an I.E.S. of a cyclic consistent 2CNF formulaimplying some literals. The case in which no cycle includes the clause to check is proved polynomial in Appendix A.8.We now show that the general problem is NP-complete.Theorem 8. The problem of checking the presence of a clause in some I.E.S.’s of a consistent 2CNF formula Π isNP-complete and remains hard even if Π |= l for every positive literal l but one.Proof. The proof is by reduction from the problem of deciding the existence of two vertex-disjoint paths in a directedgraph, which is NP-complete [6,8] (the corresponding problem for undirected graphs is polynomial [23].) This is theproblem of establishing whether a graph G contains a path from node s1 to node t1 and a path from node s2 to node t2and these two paths do not share nodes. We can assume that, from each node of the graph, either t1 or t2 is reachable;otherwise, the nodes not satisfying this condition can be removed from the graph in polynomial time. The formula weconsider is the one corresponding to the graph in Fig. 14.This formula implies the negation of all positive literals beside x because the pair of nodes x and ¬x can be reachedfrom any other node of the graph. The same property must therefore be true for all I.E.S.’s of this formula. Since xand ¬x form the only pair of opposite literals in the graph, the property holds only if both l3 and l4 are reachable fromany other node besides x and ¬x in the graph corresponding to the I.E.S.If G has a pair of vertex-disjoint paths from s1 to t1 and from s2 to t2, respectively, there exists an I.E.S. containingthe clause ¬l1 ∨ l2. Let us consider the subformula Π (cid:5) built as follows. First, Π (cid:5) contains all clauses correspondingto the edges of the subgraph in Fig. 15.Second, Π (cid:5) contains a number of clauses corresponding to edges making either t1 or t2 reachable from every nodeof G not having already this property: this can be done by adding a clause ¬s ∨ t if either t1 or t2 is reachable from tFig. 14. The graph of the formula used in the proof.Fig. 15. The first part of Π (cid:5).286P. Liberatore / Artificial Intelligence 172 (2008) 265–299Fig. 16. The edges that are necessarily contained in any I.E.S. of Π .Fig. 17. s2 is connected to t2 but not to t1.but not from s. The addition of these clauses does not make t2 reachable from s1 or t1 from s2 because a clause ¬s ∨ tis only added if no other edge outgoing from s is already in the I.E.S.The subformula Π (cid:5) makes both l3 and l4 reachable from l1 and l1 reachable from any other node of the graph. Asa result, Π (cid:5) ≡ Π . Since l4 is only reachable from l1 via the edge from l1 to l2, the corresponding clause is irredundantin Π (cid:5). Since ¬l1 ∨ l2 is irredundant in Π (cid:5), every I.E.S. of Π (cid:5) contains this clause by Property 1. Since Π (cid:5) ≡ Π , everyI.E.S. of Π (cid:5) is also an I.E.S. of Π . Therefore, ¬l1 ∨ l2 is contained in some I.E.S.’s of the original formula.Let us now assume that G contains no vertex-disjoint paths from s1 to t1 and from s2 to t2, respectively. We provethat ¬l1 ∨ l2 is redundant in every I.E.S. of the formula. Since x is the only variable that occurs both direct and negatedin the graph, in every I.E.S. of Π both l3 and l4 are reachable from any other variable besides x and ¬x. Fig. 16 showsthe edges that are necessarily contained in any I.E.S. of Π because either they are the only outgoing edges of a nodeor they are the only edges that are incoming to l3 or l4.Since s2 must be connected to nodes outside G (i.e., l3 and l4), it is either connected to t1 or to t2. If t1 is reachablefrom s2, then both l3 and l4 are reachable from l1 without using the clause ¬l1 ∨ l2, which is therefore redundant. Wecan therefore assume that s2 is connected to t2 but not to t1, as shown in Fig. 17.By assumption, t1 is not reachable from s2 using only edges inside G. The node s1 can therefore be connected to l4only via a path starting from t2. However, such a path can only go to l1, then l2, and finally s1. By assumption, however,every path from s1 to t1 shares a node with the path from s2 to t2, which makes t1 reachable from s2, contradicting theassumption. (cid:2)7.3. Presence in an I.E.S.: Cyclic consistent 2CNF formulae not implying literalsThe problem of checking the presence of a clause in an I.E.S. of a 2CNF formula is polynomial if the formula isacyclic and consistent, and does not entail any single literal. We now show that the same problem is NP-complete ifthe formula is still consistent but cyclic. First of all, if a formula is consistent and does not entail literals, then everyclause l1 ∨ l2 can be made irredundant by the following lemma.P. Liberatore / Artificial Intelligence 172 (2008) 265–299287Lemma 22. If Π does not entail ¬l1 nor ¬l2 and contains the clauses l1 ∨ w and ¬w ∨ l2, where w is a variableappearing only in these two clauses, then Π is equivalent to Π ∪ {l1 ∨ l2}, and the two clauses l1 ∨ w and ¬w ∨ l2are irredundant in Π .Proof. Equivalence is due to the fact that l1 ∨ l2 is obtained from l1 ∨ w and ¬w ∨ l2 by resolution. Irredundancy isdue to the fact that Π ∪ {¬l1} |=UP w in Π because Π is consistent and does not entail literals. Since l1 ∨ w is theonly clause containing w positively, this clause is necessary. For the same reason, ¬w ∨ l2 is irredundant. (cid:2)If a clause is necessary in a formula, it is contained in all its I.E.S.’s. Whenever we have a formula Π that isconsistent and does not entail literals, and we want a clause l1 ∨ l2 to be contained in all its I.E.S.’s, we can replace itwith l1 ∨ w and ¬w ∨ l2. The original clause is still implied by these two new ones by resolution, but the new clausesare both irredundant. In order to keep proofs simple, we use the following notation.Notation. l1◦∨ l2 means {l1 ∨ w, ¬w ∨ l2} where w is a new variable.We use this notation because the clauses {l1 ∨ w, ¬w ∨ l2} actually represent the single clause l1 ∨ l2 since w isnot used anywhere else. The circle over the symbol ∨ reminds us that these two clauses cannot be removed from aformula without changing its semantics. We can now prove that deciding the presence of a clause in an I.E.S. of aformula is NP-complete.Theorem 9. Deciding whether a clause is in an I.E.S. of a cyclic and consistent 2CNF formula Π is NP-hard even ifno single literal is implied by Π and Π makes all literals equivalent.Proof. We show a proof of hardness from 3sat. The set of clauses generated by this particular reduction is such thatall clauses are of the form ¬l ∨ l(cid:5). Such formulae can be represented by their induced graphs. In this proof, we usel ⇒ l(cid:5) to denote the reachability of l(cid:5) from l and l ⇔ l(cid:5) to denote mutual reachability (l and l(cid:5) can be reached fromeach other).Given a set of clauses Γ = {γ1, . . . , γm}, we generate a formula Π and one of its clauses ¬l1 ∨ l2 in such a way¬l1 ∨ l2 is in some I.E.S.’s of Π if and only if Γ is satisfiable. The graph corresponding to Π is strongly connected.In particular, truth assignments on Γ correspond to subsets of Π in which l2 ⇒ n ⇒ l1 for every node n. Therefore,the graph is strongly connected if and only if l1 ⇒ l2. The truth assignment satisfies Γ if and only if l1 ⇒ l2 does nothold in the corresponding subformula, thus making the clause ¬l1 ∨ l2 necessary.From now on, we consider Π as a graph. The graph corresponding to Γ is as follows: for each variable xi , we have+i , and x−i . For each clause γj we have a node cj . The clauses of Π are the following ones:three nodes xi , x(1) The clause to be checked for presence in an I.E.S.: ¬l1 ∨ l2;(2) Nodes forming a strongly connected component containing l1:(3) Nodes forming a strongly connected component containing l2:◦∨ xi ;(a) ¬l1+i and ¬xi ∨ x(b) ¬xi ∨ x◦◦−(c) ¬x∨ l1;∨ l1 and xi+i−i ;−i ;◦◦+(a) ¬l2∨ x∨ xi and ¬l2+∨ cj if xi ∈ γj ;(b) ¬xi−∨ cj if ¬xi ∈ γj .(c) ¬xi◦(d) ¬γj∨ l2.This graph is strongly connected. This must also be true for every graph representing an I.E.S. of Π . As an example,the clause γ1 = x1 ∨ ¬x2 is represented as in Fig. 18 (this example uses a binary clause; clauses of three literals areconverted in a similar way). The nodes l1 and l2 have been omitted to keep the figure simple: if a node is missing atthe left of an arrow, it is l1; if it is at the right, it is l2. Arrows marked with a circle cannot be removed because theycorrespond to irredundant clauses.288P. Liberatore / Artificial Intelligence 172 (2008) 265–299Fig. 18. The subgraph corresponding to γ1 = x1 ∨ ¬x2. A binary clause has been used to make the figure simpler, but clauses of three literals canbe converted in a similar way.Fig. 19. Dotted lines are clauses removed if M assigns true to both x1 and x2.Every truth assignment on Γ can be associated to a set of clauses to remove from Π to the aim of obtaining anI.E.S. In particular, if Π is satisfiable we can remove some of the clauses in such a way that l2 ⇒ n ⇒ l1 still holdsfor every node n, but l1 ⇒ l2 does not. This way, ¬l1 ∨ l2 is necessary to make this graph strongly connected andtherefore equivalent to the original one.Let us assume that Γ is satisfiable, and let M be one of its models. We build a subset of Π by removing thefollowing clauses:(1) if xi is positive in M, remove the clause ¬xi ∨ x(2) if xi is negative in M, do the other way around.+i and all clauses from x−ito a node cj ;Fig. 19 shows the clauses that are removed from the formula above if M assigns true to both x1 and x2. In this+subgraph, l2 ⇒ n ⇒ l1 holds for all nodes. For nodes xthere are edges from l2 to them and from them toi and x+−+l1. The cycle l1 ⇒ xi ⇒ xi causes all nodes xi to be in the same stronglyreplacing xiiconnected component as l1 if xi is negative in M. A node cj is in the same strongly connected component as l2 thanksto a cycle ¬l2 ∨ x∨ cj , ¬cj ∨ l2 if xi is positive in M and in cj , or a similar cycle if the literal of cj that istrue in M is a negative one.⇒ l1 or the cycle with x+i , ¬x+i−iSince l2 ⇒ n ⇒ l1 holds for all nodes, the addition of the clause ¬l1 ∨ l2 makes all nodes reachable from eachother, making this formula equivalent to the original one. On the other hand, l1 ⇒ l2 is not true in this graph: indeed,+all paths l1 ∨ xi, ¬xi ∨ xi or the clause¬x∨ cj has been removed, and the same holds for the similar paths containing x∨ cj , ¬cj ∨ l2 have been broken because either the clause ¬xi ∨ xin place of x+i , ¬x+i+i .+i−iP. Liberatore / Artificial Intelligence 172 (2008) 265–299289Let us now assume that Π has an I.E.S. Π (cid:5) containing the clause ¬l1 ∨ l2, and show a truth assignment satisfyingall clauses of Γ . Since the graph of Π is strongly connected, the same holds for Π (cid:5). Since removing ¬l1 ∨ l2 makesthe graph of Π (cid:5) not strongly connected, we have that:(1) l2 is not reachable from l1 in the graph corresponding to Π (cid:5)\{¬l1 ∨ l2};(2) every node is reachable from either l1 or l2 and reaches either l1 or l2 in the graph corresponding to Π (cid:5)\{¬l1 ∨ l2}:otherwise, the addition of ¬l1 ∨ l2 would not make the graph strongly connected.Since xi is reachable from l1, it must reach either l1 or l2; however, it cannot reach l2 as otherwise we would haveis in Π (cid:5). In other words, it cannot be that both clausesl1 ⇒ l2. As a result, for every xi , either ¬xi ∨ xare not in Π (cid:5) for the same xi . As a result, the following is a partial model (a consistent set of literals).+i /∈ Π(cid:5)} ∪ {¬xi | ¬xi ∨ xM = {xi | ¬xi ∨ x+i or ¬xi ∨ x−i /∈ Π−i(cid:5)}We show that all clauses of Γ are satisfied by M. Let γj be a clause. Since the clause ¬cj ∨ l2 is not removable,l1 ⇒ cj cannot hold, as otherwise l2 would be reachable from l1. As a result, l2 ⇒ cj must hold. This implies that∨ cj ∈ Π (cid:5). In the first case,there exists an index i such that either xi ∈ γj and ¬xi /∈ Π (cid:5) as this clause would create a path from l1 to l2. This however implies that xi is set to true by M. Since¬xi ∨ xxi ∈ γj , the clause γj is satisfied by M. The case ¬xi ∈ γj and ¬x∨ cj ∈ Π (cid:5) or ¬xi ∈ γj and ¬x∨ cj ∈ Π (cid:5) is similar. (cid:2)−i+i+−i8. Horn formulaeWhen considering the complexity of redundancy for Horn formulae, the following problems are clearly polynomial:(1) checking redundancy;(2) a set is an I.E.S.;(3) a clause is in all I.E.S.’s;(4) uniqueness.The problem of size is easily proved to be NP-complete: indeed, the corresponding proof for the case of consistentacyclic 2CNF formulae not implying single literals uses clauses corresponding to the edges of a graph whose nodesare all positive literals. These clauses are therefore all in the form ¬x ∨ y, that is, they are binary Horn clauses.We show that the problem of size is NP-complete for inconsistent Horn formulae.Theorem 10. Deciding whether a Horn formula Π has an equivalent subset of size k is NP-complete.Proof. Membership is obvious. Hardness is proved by reduction from vertex cover. Let G be a graph. We build thefollowing set of Horn clauses: for each node i we have a unit clause xi ; for each edge z = (i, j ) we have two clauses¬xi ∨ az and ¬xj ∨ az; finally, we have the clause ¬a1 ∨ · · · ∨ ¬am.Inconsistent subsets of this formula are composed of ¬a1 ∨ · · · ∨ ¬am, plus a pair xi and ¬xi ∨ az for each edgez. This means that we have exactly one clause ¬xi ∨ az for each edge of the graph. Moreover, for each edge we haveto include a unit clause corresponding to one of its incident nodes. Therefore, minimal inconsistent subsets are inone-to-one correspondence with vertex covers of the original graph. Namely, G has a vertex cover of k nodes if andonly if the formula has an inconsistent subset of m + 1 + k clauses, where m is the number of edges of G. (cid:2)9. ConclusionsThe analysis of the problems of redundancy presented in this paper shows an interesting pattern: the complexity ofsome problems is related to their cyclicity: some problems are polynomial on acyclic problems and NP-complete oncyclic ones. Interestingly, complexity does not instead depends on whether the considered formula is consistent.Quantitatively, we have shown that checking redundancy can be done with an algorithm that is slightly moreefficient than the trivial one. In particular, while checking redundancy for every possible clause requires time O(m2),where m is the total size of the set of clauses, an algorithm running in time O(mn) exists, where n is the number of290P. Liberatore / Artificial Intelligence 172 (2008) 265–299variables. This running time is asymptotically different as the total size of the set of clauses m can be quadraticallylarger than the number of variables n.A number of problems that are NP-hard for the general case turned out to be polynomial for the 2CNF case. Inparticular, this is the case for the problem of checking redundancy, checking whether a set is an I.E.S. of anotherone, checking whether a clause is in all I.E.S.’s of a given formula, and checking whether a formula has an uniqueI.E.S. In particular, the two latter problems are polynomial thanks to previous results about I.E.S.’s: a clause is in allI.E.S.’s if and only if its is not redundant and a formula has an unique I.E.S. if and only if the set of its irredundantclauses is equivalent to it [17]. The problems of I.E.S. size and presence of a clause in an I.E.S. required a technicalanalysis. This required a separate study for the restrictions to formulae that are either inconsistent, consistent andimplying some literals, or consistent and not implying literals. Surprisingly, these restrictions have not influenced thefinal results: these problems are polynomial or NP-complete depending on whether the formula is acyclic or cyclicbut not on the aforementioned restriction.One problem is still left open: that of checking the size of a I.E.S. for cyclic inconsistent formulae. Based onthe other results, it seems logical to assume that this problem is NP-complete. However, considering that each caserequired a separate analysis, it is still possible that this case is different from the other one, and turns out to bepolynomial instead.Appendix A. ProofsA.1. Unit propagationLemma 1. For any 2CNF formula Π and two literals l1 and l2, if Π |=R l1 ∨ l2, then Π ∪ {¬l1} |=UP l2.Proof. Since Π |=R l1 ∨ l2, there exists a resolution tree rooted with l1 ∨ l2. We prove the claim by induction on theheight of the tree. The base case of recursion is when the tree is a leaf. In this case, l1 ∨ l2 ∈ Π , which implies thatΠ ∪ {¬l1} |=UP l2.Let us therefore assume that the claim holds for any binary clause that can be proved with a tree of height k, andprove it for clauses requiring trees of height k + 1. Let us therefore consider a tree of height k + 1 with l1 ∨ l2 in theroot. Its subtrees have height less than or equal to k, and their roots are labeled with l1 ∨ l3 and ¬l3 ∨ l2 for someliteral l3; note that resolution does not allow to derive l1 ∨ l2 from l1 or from l2. Fig. A.1 shows such a tree.Since the resolution trees of l1 ∨ l3 and ¬l3 ∨ l2 have both height less than or equal to k, by the induction hypothesisboth Π ∪ {¬l1} |=UP l3 and Π ∪ {l3} |=UP l2 hold. As a result, Π ∪ {¬l1} |=UP l2. (cid:2)Lemma 2. For any 2CNF formula Π and literal l, if Π |=R l then Π ∪ {¬l} |=UP ⊥.Proof. The claim is proved by induction on the height of the resolution tree rooted with l. In the base case, this treeis a leaf; therefore, l ∈ Π holds. The claim Π ∪ {¬l} |=UP ⊥ therefore holds.We now assume that the claim is true for any literal that is derivable from Π using a resolution tree of height lessthan or equal to k and prove that the same holds for height k + 1. Let l be the root of a resolution tree of height k + 1.The root of this tree is l, and its children can be either both binary, or a unary clause resolved with a binary clause.Let us consider this latter case, depicted in Fig. A.2, first.By induction, Π ∪ {¬l1} |=UP ⊥, as the subtree rooted with l1 have height less than or equal to k. By Lemma 1, ¬limplies ¬l1 by unit propagation. As a result, Π ∪ {¬l} |=UP ⊥.Let us now consider the situation in which the children of l are both binary clauses. Let us call l1 the literal theyare resolved upon, that is, the two clauses are l ∨ l1 and l ∨ ¬l1. Such a tree is depicted in Fig. A.3.Fig. A.1. A resolution tree rooted by l1 ∨ l2.P. Liberatore / Artificial Intelligence 172 (2008) 265–299291Fig. A.2. A resolution tree where a child of the root is unary.Fig. A.3. A resolution tree where the children of the root are both binary.Since l ∨ l1 is the root of a resolution tree whose leaves are clauses of Π , it follows that Π |=R l ∨ l1. By Lemma 1,Π ∪ {¬l} |=UP l1 and Π ∪ {¬l} |=UP ¬l1. Since ¬l allows deriving a pair of contradictory literals by unit propagation,we have Π ∪ {¬l} |=UP ⊥. (cid:2)Lemma 3. A 2CNF formula Π is inconsistent if and only if there exists a variable x such that Π ∪ {x} |=UP ⊥ andΠ ∪ {¬x} |=UP ⊥.Proof. The “if” direction is obvious, thanks to the soundness of unit propagation.Let us consider a minimal regular resolution tree for Π . Its root is marked with ⊥, so its children have to be markedx and ¬x for some variable x. Therefore, we have that Π |=R x and Π |=R ¬x. By Lemma 2, the claim is proved. (cid:2)Lemma 4. For every 2CNF formula Π and literals l1 and l2, Π |= l1 ∨ l2 if and only if Π is inconsistent or Π ∪{¬l1} |=UP ⊥ or Π ∪ {¬l2} |=UP ⊥ or Π ∪ {¬l1} |=UP l2.Proof. The “if” direction is due to the fact the unit propagation is a sound (but not complete) entailment method, thatis, if Π |=UP γ then Π |= γ .The other direction is proved by applying Property 3. Indeed, Π |= γ implies that Π either is inconsistent orimplies either l1, l2, or l1 ∨ l2 by resolution. In turns, Π |=R l1 implies Π ∪ {¬l1} |=UP ⊥, and similarly for Π |=R l2thanks to Lemma 2. Moreover, Π |=R l1 ∨ l2 implies Π ∪ {¬l1} |=UP l2 thanks to Lemma 1. (cid:2)A.2. Inconsistent 2CNF formulaeTheorem 1. Every inconsistent set of binary clauses is cyclic.Proof. Let Π be a set of binary clauses. By Lemma 3, if Π is inconsistent then there exists a variable x such thatΠ ∪ {x} |=UP ⊥ and Π ∪ {¬x} |=UP ⊥. Since Π contains only binary clauses by assumption, these two conditions areequivalent to the existence of four paths of clauses: one from x to a variable y, one from x to ¬y, one from ¬x to avariable z, and one from ¬x to ¬z. The second and fourth of these two paths can be reversed, thus leading to a pathfrom y to ¬x and one from z to x, respectively. These two paths, together with the first and third original ones, forma cycle from x to y to ¬x to z to x. (cid:2)Lemma 6. Every 2CNF formula Π containing a unit clauses l is equivalent to Π\{l} ∪ {l ∨ y, l ∨ ¬y}, where y is anew variable; this second formula is cyclic only if Π is either cyclic or inconsistent.Proof. Equivalence is obvious. Let us assume that Π is acyclic while Π (cid:5) = Π\{l} ∪ {l ∨ y, l ∨ ¬y} is not, and provethat Π is inconsistent. Since Π is acyclic while Π (cid:5) is not, every cycle of Π (cid:5) contains either l ∨ y or l ∨ ¬y. Letus assume that one such cycle contains l ∨ y. Since y is a new variable, the only possible next clause of the cycle is¬y ∨ l. This means that the rest of the cycle is composed of clauses ¬l ∨ z, . . . , w ∨ ¬l. This means that ¬l is obtainedby applying unit propagation from l on the clauses of Π\{l}. Since Π contains l, it is inconsistent. (cid:2)Lemma 7. Every resolution tree rooted with ⊥ of a 2CNF formula has at most two unary clauses in the leaves.292P. Liberatore / Artificial Intelligence 172 (2008) 265–299Proof. We prove that each subtree of the root contains at most a unary clause in the leaves. Since the root is labeledwith ⊥, its subtrees are rooted by x and ¬x. We prove the claim for the first subtree; the proof for the second is similar.If this subtree is only composed of x, the claim is proved. Otherwise, x has two children, of which at most one canbe unary. Since a binary clause can only be obtained by resolving two binary clauses, all its descendants are binaryclauses. As a result, all binary clauses that are children of x have all binary clauses as descendants.If x has a unary child, the same argument can be used on the subtree rooted by that child: at most one of itschildren is unary, and all descendants of the binary clauses in its children are labeled with binary clauses. As a result,this subtree has at most one unary leaf. The same argument applies to the other subtree, so the tree has to most twounary clauses in the leaves. (cid:2)Lemma 8. Every irredundant inconsistent 2CNF formula contains at most two unary clauses.Proof. Let Π be an irredundant inconsistent 2CNF formula. Consider one of its resolution proofs of inconsistency.By Lemma 7, this tree contains at most two unary clauses in the leaves. As a result, if Π contained more than twounary clauses, the ones that are not leaves of that tree would be redundant. (cid:2)Lemma 9. If Π is an irredundant inconsistent 2CNF, Π (cid:5) and Π (cid:5)(cid:5) are the set of its unary and binary clauses, respec-tively, and Π (cid:5)(cid:5) is consistent, then Π (cid:5) ∪ Π (cid:5)(cid:5) |=UP ⊥.Proof. Since Π (cid:5)(cid:5) is consistent, Π (cid:5) cannot be empty. By Lemma 8, Π (cid:5) contains either one or two unary clauses.Let us first assume that Π (cid:5) = {l}. Since Π (cid:5) ∪ {l} |= ⊥, we have Π (cid:5) |= ¬l. Since Π (cid:5) (cid:3)|=R ⊥, by Property 3 we haveΠ (cid:5) |=R ¬l. By Lemma 2, Π (cid:5) ∪ {l} |=UP ⊥.Let us now assume that Π (cid:5) = {l, l(cid:5)}. Since Π (cid:5) ∪ {l, l(cid:5)} |= ⊥, we have that Π (cid:5) |= ¬l ∨ ¬l(cid:5). Since Π is irredundant,it holds neither Π (cid:5) |=R ¬l nor Π (cid:5) |=R ¬l(cid:5). As a result, Π (cid:5) ∪ {l} |=UP ¬l(cid:5) by Lemma 4, which is equivalent to Π (cid:5) ∪{l, l(cid:5)} |=UP ⊥. (cid:2)A.3. Formulae implying literalsLemma 10. If Π is a CNF formula such that Π |= l, then Π and Π\(Π|l) ∪ {l} are equivalent.Proof. Let M be a model of Π . By definition, M satisfies all clauses of Π . Since Π |= l, this model assigns true to l.Since Π\(Π|l) ∪ {l} only contains clauses of Π and l, it is satisfied by M.Vice versa, let M be a model of Π\(Π|l) ∪ {l}. This model assigns true to l. Moreover, it satisfies all clauses of Πnot containing l. It also satisfies all clauses of Π containing l because it sets l = true; therefore, it satisfies all clausesof Π . (cid:2)Lemma 11. Let Π be a formula implying the literal l. If the clause γ ∈ Π does not contain l, then γ is redundant inΠ if and only if it is redundant in Π\(Π|l) ∪ {l}.Proof. Since γ does not contain l, it is both in Π and in Π\(Π|l) ∪ {l}. We therefore only have to prove that is entailedby Π\{γ } if and only if it is entailed by (Π\(Π|l) ∪ {l})\{γ }. We prove that these two formulae are equivalent. Sinceγ is not a clause of Π|l, we have that (Π\(Π|l) ∪ {l})\{γ } is the same as (Π\{γ })\(Π|l) ∪ {l}. By Lemma 10, thisformula is equivalent to Π\{γ }. (cid:2)Lemma 12. Let Π be a consistent 2CNF such that Π |= l. If Π (cid:5) is an I.E.S. of Π then Π2 = Π (cid:5)\(Π|l) ∪ {l} is anI.E.S. of Π\(Π|l) ∪ {l}.Proof. Since Π (cid:5) is an I.E.S. of Π , we have that Π (cid:5) ⊆ Π . As a result, Π (cid:5)\(Π|l) ∪ {l} ⊆ Π\(Π|l) ∪ {l}. Containmentis the first condition for a formula being an I.E.S. of another formula. We now show equivalence and irredundancy.Since Π (cid:5) is equivalent to Π , we have Π (cid:5) |= l. By Lemma 10, Π (cid:5) is equivalent to Π (cid:5)\(Π|l) ∪ {l}, which is indeedΠ2. As a result, Π2 is equivalent to Π (cid:5), which is equivalent to Π , which is equivalent to Π\(Π|l) ∪ {l} by Lemma 10.P. Liberatore / Artificial Intelligence 172 (2008) 265–299293Let us now assume that Π (cid:5)\(Π|l) ∪ {l} is redundant. The clause l cannot be redundant because it is the only clausementioning the literal l. Therefore, there exists a clause γ not containing l such that γ is redundant in Π (cid:5)\(Π|l) ∪ {l}.By Lemma 11, γ is also redundant in Π (cid:5), thus contradicting the assumption that Π (cid:5) is an I.E.S. (cid:2)The converse of this lemma does not hold, as already shown by the following example.Π = {x ∨ x1, x ∨ x2, ¬x1 ∨ y, ¬x2 ∨ ¬y, ¬x ∨ y}l = xΠ\(Π|l) ∪ {l} = {¬x1 ∨ y, ¬x2 ∨ ¬y, ¬x ∨ y, x}Π2 = {¬x2 ∨ ¬y, ¬x ∨ y, x}Π2\{l} ∪ (Π|l) = {¬x2 ∨ ¬y, ¬x ∨ y, x ∨ x1, x ∨ x2}A possible (but incorrect) proof of the converse of Lemma 12 would go by considering that x1 and x2 should alwaysentail y and ¬y, respectively, in every I.E.S. of Π , and therefore in any I.E.S. of Π\(Π|l) ∪ {l}, because this formulais equivalent to Π . What makes this proof fail on the counterexample above is that ¬x1 ∨ y holds also because of xand ¬x ∨ y, and this proof relies on x, which is removed while “coming back” from Π2 to Π\{l} ∪ (Π|l).The problem with this proof is that the clause ¬x1 ∨ y, which is part of the proof of x, is not necessary because itcan be derived from l = x in Π\(Π|l) ∪ {l}. On the other hand, l can only derive clauses of the form l ∨ something, ory ∨ something where y is a consequence of l. In other words, what makes the proof fail is the possible entailment ofclauses containing literals that are derivable from l. On the other hand, Π |= l; therefore, Π |= y. The counterexampletherefore relies on the presence in Π\(Π|l) ∪ {l} of clauses containing literals that are entailed by Π . Replacing allsuch clauses with that literal would therefore invalidate the counterexample. Since Π|= is the set of literals entailed byΠ , the set Π|Π|= contains all clauses of Π containing a literal that is entailed by Π .Lemma 13. Every clause of a 2CNF formula Π either is in Π|Π|= or does not contain literals in Π|= nor theirnegation.Proof. Let l ∈ Π|=. All clauses containing l are in Π|Π|= by definition. On the other hand, all clauses containing thenegation of l are in the form ¬l ∨ l(cid:5). Since Π |= l, we have Π |= l(cid:5). Therefore l ∨ l(cid:5) ∈ Π|Π|=. (cid:2)Lemma 14. Let Π be a consistent 2CNF formula. If Π2 is an I.E.S. of Π\(Π|Π|=) ∪ Π|=, then Π2\Π|= ∪ (Π|Π|=) isequivalent to Π .Proof. Since Π and Π\(Π|Π|=) ∪ Π|= are equivalent and Π2 is an I.E.S. of Π\(Π|Π|=) ∪ Π|=, we have that Π2and Π are equivalent. The claim is proved by showing that Π2\Π|= ∪ (Π|Π|=) entails Π|=. This would prove thatΠ2\Π|= ∪ (Π|Π|=) is equivalent to Π2\Π|= ∪ (Π|Π|=) ∪ Π|=, which is a superset of Π2 and is therefore equivalentto Π .Intuitively, the proof is as follows: if l ∈ Π|=, then there is a proof of l in Π . This proof involves some clauses ofΠ|Π|= and some clauses in Π\(Π|Π|=). On the other hand, everything that is entailed in Π is also entailed in itsequivalent formula Π2\(Π|Π|=) ∪ Π|=. Since Π2\(Π|Π|=) and Π|= are built over disjoint literals, every clause of Πnot containing literals that are entailed by Π is derivable in Π2\(Π|Π|=).Let us formally prove the claim. Let l ∈ Π|=, that is, Π |= l. We show that Π2\Π|= ∪ (Π|Π|=) |= l. Since Π |= l,two situations are possible: either l ∈ Π , or l /∈ Π . In the first case, l ∈ Π|Π|=, and the claim is true because l is inΠ2\Π|= ∪ (Π|Π|=).Let us now consider the case l /∈ Π . Since Π |= l and Π is consistent, Π ∪ {¬l} allows deriving a pair of oppositeliterals by unit propagation. Let the following be the chains of clauses used in the unit propagation from ¬l to thesepairs of opposite literals:¬p1 ∨ p2, ¬p2 ∨ p3,¬n1 ∨ n2, ¬n2 ∨ n3,where ¬l = p1 = n1. . . , ¬pn−1 ∨ pn. . . , ¬nm−1 ∨ ¬nmand pn = ¬nm294P. Liberatore / Artificial Intelligence 172 (2008) 265–299Consider an clause ¬li ∨ li+1 of any of these two chains. By Lemma 13, either this clause is in Π|Π|= or it does notshare variables with Π|=. In the first case, li ∨li+1 ∈ Π2\Π|= ∪(Π|Π|=). We show that Π2\Π|= ∪(Π|Π|=) |= ¬li ∨li+1holds in the second case.Since ¬li ∨ li+1 is in Π , it holds Π2 |= ¬li ∨ li+1. On the other hand, Π2 = (Π2\Π|=) ∪ (Π2 ∩ Π|=). These twoparts of Π2 contain disjoint literals because of Corollary 2. Since Π2 |= ¬li ∨ li+1 and neither li , li+1, nor theirnegations are in Π|=, then Π2\Π|= |= ¬li ∨ li+1 because the other part of Π2 contains literals that are mentionedneither in Π2\Π|= nor in ¬li ∨ li+1.Of the clauses of the two chains above, therefore, we have that a clause ¬li ∨ li+1 is either in Π|Π|= or is entailedby Π2\Π|=. As a result, Π2\Π|= ∪ (Π|Π|=) entails all these clauses; therefore, unit propagation of ¬l in this formulaleads to a pair of opposite literals. (cid:2)Lemma 15. Let Π be a consistent 2CNF formula. If Π2 is an I.E.S. of Π\(Π|Π|=) ∪ Π|=, then there exists Π1 ⊆Π|Π|= such that Π1 ∪ (Π2\Π|=) is an I.E.S. of Π .Proof. Lemma 14 shows that adding Π|Π|= to Π2\Π|= results in a set that is equivalent to Π . We are now trying toprove that an I.E.S. of Π can be obtained from Π2\Π|= ∪ (Π|Π|=) without removing any clause of Π2\Π|=. Whatwe actually prove is that no clause of Π2\Π|= is redundant in Π2\Π|= ∪ (Π|Π|=), thus proving that all I.E.S.’s ofΠ2\Π|= ∪ (Π|Π|=) contain all clauses of Π2\Π|= by Property 1.Let γ ∈ Π2\Π|=. Assume that γ is redundant in Π2\Π|= ∪ (Π|Π|=), that is:(cid:4)(cid:5)Π2\Π|= ∪ (Π|Π|=)\{γ } |= γSince all clauses in Π|Π|= contain a literal in Π|= by definition, we have that Π|= |= Π|Π|=. As a result, Π|= islogically stronger than Π|Π|=, and the above formula therefore implies:(Π2\Π|= ∪ Π|=)\{γ } |= γThis is the same as Π2\{γ } |= γ , contradicting the assumption that Π2 is irredundant. (cid:2)Lemma 16. Every consistent 2CNF formula Π implying a literal l and containing three or more clauses containing lcontains at least a redundant clause containing l.Proof. If l ∈ Π , any other clause containing l is redundant. Let us assume l /∈ Π . Since Π is consistent, Π |= lis equivalent to Π ∪ {¬l} |=UP ⊥. By definition, this formula is true if and only if ¬l allows deriving a pair ofcomplementary literals x and ¬x by unit propagation.Let us first assume that neither l is neither x nor ¬x. Consider the sequences of clauses used in the derivation ofx and ¬x from l. Without loss of generality, we can assume that l is only contained in the first clauses of these twosequences.Removing all clauses containing l but the first clause in each of these two sequences, we obtain a formula that stillentails l, and therefore allows deriving all clauses that have been removed, contradicting the assumption that Π isirredundant.A similar proof can be used for the case in which l = x or l = ¬x. In this case, the first clause of the sequence ofclauses used in the derivation of ¬l from l allows deriving all other clauses containing l. (cid:2)A.4. Acyclic consistent 2CNF formulae not implying literals have a single I.E.S.Lemma 17. If Π is a consistent acyclic 2CNF and Π ∪ {l} |=UP l(cid:5), then Π (cid:5) ∪ {l} |=UP l(cid:5) holds for every I.E.S. Π (cid:5)of Π .Proof. Since Π ∪ {l} |=UP l(cid:5), it holds that Π |= ¬l ∨ l(cid:5), and the same therefore holds for Π (cid:5) because this formula isequivalent to Π . On the other hand, Π (cid:5) is consistent and does not entail literals because it is equivalent to Π . As aresult, Π (cid:5) |= ¬l ∨ l(cid:5) is equivalent to Π (cid:5) ∪ {l} |=UP l(cid:5). (cid:2)The next two lemmas prove Corollary 4.P. Liberatore / Artificial Intelligence 172 (2008) 265–299295Lemma 23. If Π is a consistent acyclic 2CNF formula not implying literals and l1 ∈ MΠ (l) then every I.E.S. of Πcontains ¬l ∨ l1.Proof. Let us assume that Π (cid:5) is an I.E.S. of Π . Since Π ∪ {l} |=UP l1, we have that Π (cid:5) ∪ {l} |=UP l1 holds byLemma 17. Let us assume that ¬l ∨ l1 is not in Π (cid:5). Then, the path of clauses from l to l1 is made of a clause¬l ∨ l2 with l2 (cid:3)= l1 followed by a path from l2 to l1. This path cannot include l because otherwise Π would becyclic. Therefore, this path from l2 to l1 is all contained in RΠ (l). This is however in contradiction with l1 being inMΠ (l). (cid:2)The second lemma is the converse of the previous one, stating that no I.E.S. contains a clause made of a literal notin CΠ (l) and l.Lemma 24. If l1 ∈ CΠ (l)\MΠ (l) then no I.E.S. of the consistent acyclic 2CNF formula Π contains ¬l ∨ l1.Proof. By definition of MΠ (l), if a literal l1 is in CΠ (l) but not in MΠ (l), then there is a literal l(cid:5) in MΠ (l) such thatRΠ (l) contains a path from l(cid:5) to l1. Let Π (cid:5) be a I.E.S. of Π . Since l1 is reachable from l(cid:5), it holds that Π ∪ {¬l(cid:5)} |=UP l1and, therefore, Π (cid:5) ∪ {¬l(cid:5)} |=UP l1.By the previous lemma, Π (cid:5) contains ¬l ∨ l(cid:5). As a result, Π (cid:5) ∪ {l} |=UP l(cid:5). Since Π (cid:5) ∪ {¬l(cid:5)} |=UP l1, we have that l1can be reached from l by first using the clause ¬l ∨ l(cid:5). Since the formula is acyclic, the clauses used in the derivationΠ (cid:5) ∪ {¬l(cid:5)} |=UP l1 do not contain l. As a result, unit propagation allows to reach l1 from l without using the clause¬l ∨ l1. In other words, Π (cid:5)\{¬l ∨ l1} ∪ {l} |=UP l1, thus proving that ¬l ∨ l1 is redundant in Π (cid:5), contradicting theassumption that Π (cid:5) is an I.E.S. (cid:2)We can then conclude that MΠ (l) exactly identifies all clauses of DΠ (l) that are in an I.E.S. of Π , as stated byCorollary 4.A.5. Implied literals not in a cycle of a consistent 2CNF formulaLemma 18. If Π (cid:5) is an I.E.S. of a consistent acyclic 2CNF formula Π such that Π |= ¬l and l is not in any cycle ofclauses of Π , then the following are all I.E.S.’s of Π :(1) (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l1} with l1 ∈ SΠ (l);(2) (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l2, ¬l ∨ l3} with (l2, l3) ∈ PΠ (l).Proof. Π (cid:5) ∩ RΠ (l) contains all clauses of Π (cid:5) but those containing ¬l. As a result, if we can prove that the formulaeabove entail ¬l, that would prove that they are equivalent to Π (cid:5).Let us consider (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l1} first. Since l1 ∈ SΠ (l), we have that Π ∪ {l1} |=UP ⊥. Since l is not part of acycle, all derivations of ⊥ from l1 are entirely contained in RΠ (l). Since Π (cid:5) is equivalent to Π , it holds Π (cid:5) ∪ {l1} |= ⊥;since Π (cid:5) is a subset of Π , all derivations of ⊥ from l1 only use clauses of RΠ (l). As a result, (Π (cid:5) ∩ RΠ (l)) ∪ {l1} |= ⊥,which implies that (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l1} ∪ {l} |= ⊥.Since Π (cid:5) is irredundant, Π (cid:5) ∩ RΠ (l) is irredundant as well. In order to prove that (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l1} isirredundant, observe that ¬l ∨ l1 is not redundant, as Π (cid:5) ∩ RΠ (l) does not contain clauses containing ¬l and doesnot therefore entail ¬l. Regarding the clauses of Π (cid:5) ∩ RΠ (l), since they do not contain ¬l by definition, Lemma 11applies: they are redundant in (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l1} if and only if they are redundant in Π (cid:5) ∩ RΠ (l), which isimpossible because Π (cid:5) is irredundant.The proof for (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l2, ¬l ∨ l3} with (l2, l3) ∈ PΠ (l) is similar. This formula implies ¬l because¬l3 is reachable from l2, and all paths from l2 to ¬l3 are in RΠ (l). Since Π (cid:5) is equivalent to Π , it contains one suchpath, which is therefore entirely contained in Π (cid:5) ∩ RΠ (l). As a result, the addition of the clauses ¬l ∨ l2 and ¬l ∨ l3allows the entailment of ¬l.The proof of irredundancy of (Π (cid:5) ∩ RΠ (l)) ∪ {¬l ∨ l2, ¬l ∨ l3} is also similar to the previous one. However, forthis proof to work we also need the fact that neither l2 nor l3 are in SΠ (l), and therefore one of them is not sufficientfor entailing ¬l. (cid:2)296P. Liberatore / Artificial Intelligence 172 (2008) 265–299A.6. Redundancy checking: Inconsistent 2CNF formulaeLemma 19. A 2CNF formula Π is inconsistent and irredundant if and only if it is composed of two simple chains ofclauses like the following ones:x ∨ l1, ¬l1 ∨ l2,¬x ∨ p1, ¬p1 ∨ p2,. . . , ¬lm ∨ y, ¬y ∨ s1,. . . , ¬sm ∨ ¬y. . . , ¬pm ∨ z, ¬z ∨ q1,. . . , ¬qm ∨ ¬zProof. If Π is inconsistent, by Lemma 3 there exists a variable x such that Π ∪ {x} |=UP ⊥ and Π ∪ {¬x} |=UP ⊥. Inturn, Π ∪ {x} |=UP ⊥ implies the existence of a chain allowing the derivation of y and ¬y from x by unit propagation,as explained in Section 3.2. The same holds for Π ∪{¬x} |=UP ⊥. The clauses of these two chains imply inconsistency.Therefore, if Π contains other clauses, they are redundant. (cid:2)A.7. Presence in an I.E.S.: Cyclic inconsistent 2CNF formulaeLemma 21. The problem of checking in a graph the existence of a simple path from node x to node y including agiven edge is NP-complete.Proof. Membership is obvious. Hardness is proved by reduction from the problem path via a node: given a graph Gand three nodes x, y, and m, decide whether there exists a simple path from x to y including the node m. This problemis NP-complete [15].The reduction is as follows: replace the node m with two nodes a and b joined by an edge. Replace every edgen → m with n → a and every edge m → n, with b → n, as shown in Fig. A.4.By construction, every simple path containing the node m in the original graph contains an edge that is incomingto m and is outgoing from m. This is possible if and only if the new graph has a simple path including the edgem1 → m2. (cid:2)A.8. Presence in an I.E.S.: Clause not in a cycleIt has already been proved that the problem of presence of a clause in an I.E.S. of acyclic consistent 2CNF formulaeis polynomial. In this section, we extend this result to the case in which cycles are allowed, but none include the clauseto check.Acyclic consistent 2CNF formulae not implying single literals have a unique I.E.S., which can be determined inpolynomial time; this result implies that checking the presence of a clause in an I.E.S. is easy. We extend this result tothe case in which the formula contains some cycles, but none include the clause under consideration.Fig. A.5 explains the idea of the proof: if we box all literals that are equivalent to l1 and all literals that are equivalentto l2, then ¬l1 ∨ l2 is in some I.E.S. if and only if all paths from the l1 box to the l2 box only contain nodes in theboxes. In this case, removing all edges from the l1 box to the l2 box, the clause ¬l1 ∨ l2 is the only one that makes l2reachable from l1. This clause is therefore necessary. On the other hand, if there is a path from l1 to l2 that includesa node l not in the boxes, then every I.E.S. includes a path from the l1 box to l and from l to the l2 box because suchpaths exist in the original formula. As a result, ¬l1 ∨ l2 is always redundant.Fig. A.4. Replacement of a node by two nodes and an edge.P. Liberatore / Artificial Intelligence 172 (2008) 265–299297Fig. A.5. The presence of the edges joining l makes the clause from ¬l1 ∨ l2 redundant.Theorem 11. If Π (cid:3)|= l1 ≡ l2, then ¬l1 ∨ l2 is in a I.E.S. of Π if and only if all paths from l1 to l2 contain only literalsthat Π makes equivalent either to l1 or to l2.Proof. Let us assume that all paths from l1 to l2 only contains literals that are equivalent to either l1 or to l2. Since l1and l2 are not equivalent, every such path can be written as (l1, . . . , l3, l4, . . . , l2), where Π makes literals l1, . . . , l3equivalent and literals l4, . . . , l2 equivalent.Let us now remove the clause ¬l3 ∨ l4. By assumption, l4 can still be reached from l3 by first going to l1, then to l2,and then to l4. Iterating this process over all paths from l1 to l2, we end up with a set of clauses whose only path froml1 to l2 is the single clause ¬l1 ∨ l2. This clause is now irredundant: removing other redundant clauses, we obtain aI.E.S. containing ¬l1 ∨ l2.Let us now assume the converse: there is a path from l1 to l2 that contains some literals that are not equivalent to l1nor to l2. Such a path can be written as: (l1, . . . , l3, l4, . . . , l5, l6, . . . , l2), where l1, . . . , l3 are equivalent to each other,as are l6, . . . , l2, but none of these literals are equivalent to any literal in l4, . . . , l5. We prove that no I.E.S. containsthe clause ¬l1 ∨ l2.Let Π (cid:5) be an equivalent subset of Π . Being equivalent to Π , it must contain a number of cycles that make allliterals l1, . . . , l3 equivalent to each other and all literals l6, . . . , l2 equivalent to each other. Note that ¬l1 ∨ l2 cannotbe in one of such cycles; otherwise, Π |= l1 ≡ l2.Since Π |= ¬l1 ∨ l4 and Π |= ¬l4 ∨ l2, the set Π (cid:5) must contain a path from l1 to l4 and a path from l4 to l2. If thefirst path includes ¬l1 ∨ l2, then we would have a path from l2 to l4. Since Π contains a path from l4 to l2, then l4 andl2 would be equivalent. For the same reason, the path from l4 to l2 does not contain the clause ¬l1 ∨ l2.We have therefore proved that Π (cid:5) includes some sets of clauses not containing ¬l1 ∨ l2 but allow to conclude thatl1, . . . , l3 are equivalent to each other, that l6, . . . , l2 are equivalent to each other, that l1 implies l4, and that l4 impliesl2. The clause ¬l1 ∨ l2 is therefore redundant. (cid:2)This theorem implies that checking whether ¬l1 ∨ l2 is in some I.E.S. is easy if l1 is not equivalent to l2. Indeed,the set of nodes in the paths from l1 to l2 can be found by intersecting the sets of nodes that are reached from l1 andthe ones l2 is reachable from. The clause ¬l1 ∨ l2 is redundant if and only if this intersection contains a literal that isnot equivalent neither to l1 nor to l2.We now consider the case where a literal of the clause to be checked for presence in an I.E.S. is entailed by theformula.The I.E.S.’s of a consistent acyclic 2CNF formula can be compactly expressed as a number of independent choices.This makes the problem of checking the presence of a clause in an I.E.S. polynomial. We extend this result to the casein which a literal of the clause to check is implied by the formula but the clause is not contained in any cycle ofclauses. The problem has already been proved to be NP-complete if the clause is contained in a cycle.Theorem 12. The problem of deciding whether ¬l1 ∨ l2 is in an I.E.S. of a consistent 2CNF formula Π is polynomialif Π |= ¬l1 and ¬l1 ∨ l2 is not in any cycle of clauses.298P. Liberatore / Artificial Intelligence 172 (2008) 265–299Proof. The proof is similar to that of Lemma 18 with CCΠ (l1) in place of l1 alone. The set CCΠ (l1) of literals thatare in a cycle with l1 can be determined in polynomial time. The clause ¬l1 ∨ l2 is in an I.E.S. of Π if and only ifeither Π ∪ {l2} |=UP ⊥ or Π ∪ {l2} |=UP ¬l3, where l3 ∈ CCΠ (l).This algorithm is correct because there is no path from l2 to l1. Therefore, there is no path from l2 to any node ofCCΠ (l). As a result, unit propagation from l2 to ⊥ or to ¬l3 do not generate any literal in CCΠ (l1).Let Π (cid:5) be an I.E.S. of Π . The derivations from l2 to ⊥ or to ¬l3 still hold in Π (cid:5) and do not involve literals inCCΠ (l1). If ⊥ is derivable from l2, we can obtain an I.E.S. by removing all clauses ¬l ∨ l(cid:5) with l ∈ CCΠ (l1) andadding ¬l1 ∨ l2 and a minimal number of clauses to make l2 reachable from any literal in CCΠ (l1). This additionmakes the negation of all literals of CCΠ (l1) entailed. This is therefore an I.E.S. of Π because all clauses that havebeen removed contain the negation of a literal in CCΠ (l1).A similar proof can be given for the case Π ∪ {l2} |=UP ¬l3. (cid:2)Appendix B. Notation(cid:5)}(cid:5) ∈ Π}(cid:5) | ¬l ∨ lCΠ (l) = {lDΠ (l) = {γ ∈ Π | γ = ¬l ∨ lRΠ (l) = Π\DΠ (l)MΠ (l) = {lSΠ (l) = {lPΠ (l) = {(l1, l2) | l1, l2 ∈ CΠ (l) and RΠ (l) ∪ {l1} |=UP ¬l2}\SΠ (l)CCΠ (l) = {l(cid:5) ∈ CΠ (l) |(cid:3) ∃l(cid:5) ∈ CΠ (l) | RΠ (l) ∪ {l(cid:5)(cid:5) ∈ CΠ (l) such that RΠ (l) ∪ {l(cid:5) | l and l(cid:5) are in a cycle}(cid:5)} |=UP ⊥}(cid:5)(cid:5)} |=UP l(cid:5)}References[1] G. Ausiello, A. D’Atri, D. Saccà, Minimal representation of directed hypergraphs, SIAM Journal on Computing 15 (2) (1986) 418–431.[2] R. Bruni, Approximating minimal unsatisfiable subformulae by means of adaptive core search, Discrete Applied Mathematics 130 (2) (2003)85–100.[3] H. Büning, X. Zhao, Extension and equivalence problems for clause minimal formulae, Annals of Mathematics and Artificial Intelli-gence 43 (1) (2005) 295–306.[4] J. Buresh-Oppenheim, D. Mitchell, Minimum witnesses for unsatisfiable 2CNFs, in: Proceedings of the Ninth International Conference onTheory and Applications of Satisfiability Testing (SAT 2006), 2006, pp. 42–47.[5] A. del Val, On 2-SAT and renamable Horn, in: Proceedings of the Seventeenth National Conference on Artificial Intelligence (AAAI 2000),2000, pp. 279–284.[6] S. Even, A. Itai, A. Shamir, On the complexity of timetable and multicommodity flow problems, SIAM Journal on Computing 5 (4) (1976)691–703.[7] H. Fleischner, O. Kullmann, S. Szeider, Polynomial-time recognition of minimal unsatisfiable formulas with fixed clause-variable difference,Theoretical Computer Science 289 (2002) 503–516.[8] S. Fortune, J. Hopcroft, J. Wyllie, The directed subgraph homeomorphism problem, Theoretical Computer Science 10 (2) (1980) 111–121.[9] A. Ginsberg, Knowledge base reduction: A new approach to checking knowledge bases for inconsistency & redundancy, in: Proceedings ofthe Seventh National Conference on Artificial Intelligence (AAAI’88), 1988, pp. 585–589.[10] G. Gottlob, C.G. Fermüller, Removing redundancy from a clause, Artificial Intelligence 61 (1993) 263–289.[11] P. Hammer, A. Kogan, Optimal compression of propositional Horn knowledge bases: Complexity and approximation, Artificial Intelli-gence 64 (1) (1993) 131–145.[12] E. Hemaspaandra, G. Wechsung, The minimization problem for Boolean formulas, in: Proceedings of the Thirty-eighth Annual Symposiumon the Foundations of Computer Science (FOCS’97), 1997, pp. 575–584.[13] D. Kavvadias, M. Sideri, E. Stavropoulos, Generating all maximal models of a Boolean expression, Information Processing Letters 74 (2000)157–162.[14] S. Khuller, B. Raghavachari, M. Fellows, Approximating the minimum equivalent digraph, SIAM Journal on Computing 24 (4) (1995) 859–872.[15] A. LaPaugh, C. Papadimitriou, The even-path problem for graphs and digraphs, Networks 14 (1984) 507–513.[16] P. Liberatore, Merging locally correct knowledge bases: A preliminary report, Tech. Rep. cs.AI/0212053, Computing Research Repository(CoRR), 2002.[17] P. Liberatore, Redundancy in logic I: CNF propositional formulae, Artificial Intelligence 163 (2) (2005) 203–232.[18] P. Liberatore, Redundancy in logic III: Non-monotonic reasoning. Tech. Rep. cs.LO/0507048, Computing Research Repository (CoRR), 2005.[19] D. Maier, Minimum covers in relational database model, Journal of the ACM 27 (4) (1980) 664–674.P. Liberatore / Artificial Intelligence 172 (2008) 265–299299[20] A. Meyer, L. Stockmeyer, The equivalence problem for regular expressions with squaring requires exponential space, in: Proceedings of theThirteenth Annual Symposium on Switching and Automata Theory (FOCS’72), 1972, pp. 125–129.[21] C. Papadimitriou, D. Wolfe, The complexity of facets resolved, Journal of Computer and System Sciences 37 (1988) 2–13.[22] W.V. Quine, On cores and prime implicants of truth functions, American Mathematical Monthly 66 (1959) 755–760.[23] N. Robertson, P. Seymour, Graph minors. XX. Wagner’s conjecture, Journal of Combinatorial Theory, Series B 92 (2004) 325–357.[24] S. Sahni, Computationally related problems, SIAM Journal on Computing 3 (4) (1974) 262–279.[25] J. Schmolze, W. Snyder, Detecting redundant production rules, in: Proceedings of the Fourteenth National Conference on Artificial Intelligence(AAAI’97), 1997, pp. 417–423.[26] H. Shen, H. Zhang, Improving exact algorithms for MAX-2-SAT, Annals of Mathematics and Artificial Intelligence 44 (4) (2005) 419–436.[27] P. Stuckey, L. Zheng, Improving GSAT using 2SAT, in: Proceedings of the Eighth International Conference on Principles and Practice ofConstraint Programming (CP 2002), 2002, pp. 691–695.[28] C. Umans, The minimum equivalent DNF problem and shortest implicants, in: Proceedings of the Thirty-Ninth Annual Symposium on theFoundations of Computer Science (FOCS’98), 1998, pp. 556–563.[29] X. Zhao, D. Ding, Complexity results for 2cnf default theories, Fundamenta Informaticae 45 (4) (2001) 393–404.