Artificial Intelligence 266 (2019) 1–26Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintOn coarser interval temporal logicsEmilio Muñoz-Velasco a, Mercedes Pelegrín b, Pietro Sala c, Guido Sciavicco d,∗Ionel Eduard Stan ea Department of Applied Mathematics, University of Malaga, Spainb Department of Statistics and Operational Research, University of Murcia, Spainc Department of Computer Science, University of Verona, Italyd Department of Mathematics and Computer Science, University of Ferrara, Italye Department of Mathematics, Computer Science, and Physics, University of Udine, Italy, a r t i c l e i n f oa b s t r a c tArticle history:Received 16 April 2017Received in revised form 7 September 2018Accepted 20 September 2018Available online 17 October 2018Keywords:Modal and temporal logic(Un)DecidabilityComplexityThe primary characteristic of interval temporal logic is that intervals, rather than points, are taken as the primitive ontological entities. Given their generally bad computational behavior of interval temporal logics, several techniques exist to produce decidable and computationally affordable temporal logics based on intervals. In this paper we take inspiration from Golumbic and Shamir’s coarser interval algebras, which generalize the classical Allen’s Interval Algebra, in order to define two previously unknown variants of Halpern and Shoham’s logic (HS) based on coarser relations. We prove that, perhaps surprisingly, the satisfiability problem for the coarsest of the two variants, namely HS3, not only is decidable, but PSpace-complete in the finite/discrete case, and PSpace-hard in any other case; besides proving its complexity bounds, we implement a tableau-based satisfiability checker for it and test it against a systematically generated benchmark. Our results are strengthened by showing that not all coarser-than-Allen’s relations are a guarantee of decidability, as we prove that the second variant, namely HS7, remains undecidable in all interesting cases.© 2018 Elsevier B.V. All rights reserved.1. IntroductionInterval Temporal Logics (ITLs) consider time intervals as the primitive ontological entities. This represents an advantage when dealing with some relevant application domains such as planning and synthesis of controllers, which are characterized by advanced features that are neglected or dealt with in an unsatisfactory way by point-based formalisms. ITLs have been applied in several fields such as hardware and real-time system verification, language processing, constraint satisfaction and planning [38,2,21,40]. Moreover, due to the fact that temporal logics are considered as the natural basis for temporal exten-sions of Description Logics [6], several attempts have been made to design interval-based extensions of such formalisms [41,10,5,4]. ITLs can be also considered as the temporal counterpart of TSQL, that is, the temporal extension to the language SQL for databases, included in the standard SQL:2011 [45]. Halpern and Shoham’s Modal Logic of Allen’s Relations (HS) may very well be the most prominent ITL [28]. Its elegance and expressive power have attracted the attention of the temporal and modal logic communities; however, promising applications have been hampered by the fact, already discovered when * Corresponding author.guido.sciavicco@unife.it (G. Sciavicco), stan.ioneleduard@spes.uniud.it (I.E. Stan).E-mail addresses: ejmunoz@uma.es (E. Muñoz-Velasco), mariamercedes.pelegrin@um.es (M. Pelegrín), pietro.sala@univr.it (P. Sala), https://doi.org/10.1016/j.artint.2018.09.0010004-3702/© 2018 Elsevier B.V. All rights reserved.2E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26the logic was first introduced, that HS is highly undecidable. Various strategies have been considered in the literature to define fragments or variants of HS with a better computational behavior. These include constraining the underlying tempo-ral structure [37], restricting the set of modal operators [14,1], softening the semantics to a reflexive one [30,33], restricting the nesting of modal operators [17], and restricting the propositional power of the languages [19].Allen’s Interval Algebra (IA) [2] is the backbone of HS: modal operators in the HS repertoire correspond to Allen’s interval relations. Our proposal is based on Golumbic and Shamir’s [26] idea to consider interval relations that describe a less precise relationship between intervals. They reduce the set of binary relations of Allen’s Interval Algebra (IA) [2] by defining coarser relations, each corresponding to the logical disjunction of some Allen’s relations; this approach generates two natural coarser algebras, namely IA7 and IA3. The former involves seven relations, by preserving the original relations before, after, and equal to, by joining meets and overlaps into a single relation (and similarly for their inverses), and by joining during, starts, and finishes into a single relation (and, again, similarly for their inverse ones). On the other hand, the latter takes into consideration only three relations: the original before and after, plus a relation (intersects) that can be viewed as the disjunction of all the remaining ones (and therefore is the inverse of itself and includes equality). The coarser algebras IA7 and IA3 inspire the logics HS7 and HS3 proposed in this paper. These languages follow similar ideas to the standard SQL:2011 [29], where interval relations are not necessarily Allen’s ones (for example, later is interpreted as the disjunction of Allen’s meets and later); therefore, they can be applied not only to classical areas of artificial intelligence, but also to temporal databases. We prove that the satisfiability problem for HS3 is PSpace-complete in the finite/discrete case, and it is PSpace-hard when interpreted in any interesting class of linearly ordered sets, but that coarser relations do not guarantee the decidability of an interval temporal logic, because HS7 remains undecidable over every interesting class of linearly ordered sets.A partial picture of the computational behavior of the satisfiability problem for HS3 in some cases could already be drawn from recent results concerning fragments of HS [34,15]. As a matter of fact, we can prove that HS3 can be (polynomially) embedded into the ABBA fragment of HS (the relations before and after can be immediately expressed in terms of meetsand met by, while the relation intersect can be obtained by means of a combination of the modalities in ABBA); since ABBAis decidable, but not primitive recursive, in the finite case [34] as well as in the case of the rational numbers [15], so is HS3. Here we prove that its satisfiability problem is, in fact, PSpace-complete (a much stronger result) in the finite/discrete case and PSpace-hard in all other classes. Similarly, we know that just one modality in the HS7 machinery, namely the one that corresponds to the disjunction of starts, finishes and during, alone implies the undecidability of the satisfiability problem of any temporal logic that contains it in the finite/discrete case [30]; here, we strengthen this results for HS7, as our proof also applies to all cases already covered from [30]. It is worth mentioning that HS3 is a unique case in the universe of the (few) decidable interval temporal logics; the only other example of interval temporal logics with a PSpace satisfiability problem is the fragment DDBBEE of HS, but only in the case of rational numbers [35], and the fragment D in its reflexive variant [33]. On the other hand, the maximal decidable fragments of HS in the finite/discrete case are the fragments ABBLand AEEL (the fragment ABBA, that contains both, is decidable only on finite or rational frames), and they are not left/right symmetric, limiting their applicability (already hampered by the fact that their satisfiability problem is ExpSpace-complete).The paper is organized as follows. We first give the necessary preliminaries, and in Section 3 we give working examples that highlight the expressive power of HS3. Section 4 is devoted to the complexity of the satisfiability problem for HS3. In Section 5 we discuss the satisfiability problem for HS7 and prove that it is generally undecidable, and, finally, in Section 6we describe an implementation of a satisfiability checker for HS3 along with the results of a series of systematic tests, before concluding in Section 7.2. PreliminariesIn this section we give some necessary preliminaries for the rest of the work.2.1. SyntaxLet D = (cid:3)D, <(cid:4) be a strict linear order. A strict interval (respectively, non-strict interval) over D is an ordered pair [x, y], where x, y ∈ D and x < y (respectively, x ≤ y). In the recent literature, the strict semantics, where only strict intervals are considered, is usually adopted. This conforms to the definition of interval adopted by Allen [2], but differs from the one given by Halpern and Shoham [28]. If we exclude the identity relation, there are 12 different relations between two intervals in a linear order, often called Allen’s relations [2]: the six relations R A (adjacent to), R L (later than), R B (begins), R E (ends), = (R X )−1, for each X ∈ { A, L, B, E, D, O }. R D (during), and R O (overlaps), depicted in Fig. 1, and their inverses, that is, R XWe interpret interval structures as Kripke structures, with Allen’s relations playing the role of the accessibility relations. Thus, we associate a universal modality [ X] and an existential modality (cid:3) X(cid:4) with each Allen’s relation R X . For each X ∈{ A, L, B, E, D, O }, the inverse of the modalities [ X] and (cid:3) X(cid:4) are the modalities [ X] and (cid:3) X(cid:4), corresponding to the inverse relation R X of R X . Halpern and Shoham’s logic HS [28] is a multi-modal logic with formulæ built from a finite, non-empty set AP of atomic propositions (also referred to as proposition letters), the classical propositional connectives, and a modal operator for each Allen’s relation, as follows:ϕ ::= ⊥ | p | ¬ψ | ψ ∨ ξ | ψ ∧ ξ | (cid:3)X(cid:4)ψ | (cid:3) X(cid:4)ψ.E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–263Fig. 1. Allen’s interval relations, HS modalities, and HS3/HS7 modalities.In the above grammar, p ∈ AP and X ∈ { A, L, B, E, D, O }, and the other propositional connectives and constants (e.g., →, and (cid:11)), as well as the dual modalities (e.g., [ A]ϕ ≡ ¬(cid:3) A(cid:4)¬ϕ), can be derived in the standard way. In general, given any subset S ⊆ { X, X : X ∈ { A, L, B, E, D, O }}, one can define the relationR S =(cid:2)X∈SR X ∪(cid:2)X∈SR X .The corresponding modal operator can be denoted by simply juxtaposing the original symbols to obtain a string: for ex-ample, the modal operator that is the disjunction of Allen’s relations overlaps and during would be denoted by (cid:3)O D(cid:4). In some cases, such as the relation intersect, we introduce a shorthand for the sake of readability, so that I = A A B B E E O O D D. Well-formed HS3 formulæ can be obtained by the above grammar with X ∈ {L, I}, while HS7 formulæ are defined under the restriction that X ∈ {L, A O , D B E}.12.2. SemanticsThe semantics of HS and both HS3 and HS7 is given in terms of interval models M = (cid:3)I(D), V (cid:4), where D is a linear order, I(D), which assigns to each atomic I(D) is the set of all (strict) intervals over D, and V is a valuation function V : AP (cid:15)→ 2proposition p ∈ AP the set of intervals V (p) on which p holds. The truth of a formula ϕ on a given interval [x, y] in an interval model M is defined by structural induction on formulæ as follows:• M, [x, y] (cid:2) p if [x, y] ∈ V (p), for p ∈ AP ;• M, [x, y] (cid:2) ¬ψ if M, [x, y] (cid:16)(cid:2) ψ ;• M, [x, y] (cid:2) ψ ∨ ξ if M, [x, y] (cid:2) ψ or M, [x, y] (cid:2) ξ ;• M, [x, y] (cid:2) ψ ∧ ξ if M, [x, y] (cid:2) ψ and M, [x, y] (cid:2) ξ ;• M, [x, y] (cid:2) (cid:3) X(cid:4)ψ if there is [z, t] with [x, y]R X [z, t] and M, [z, t] (cid:2) ψ ;[z, t] and M, [z, t] (cid:2) ψ .• M, [x, y] (cid:2) (cid:3) X(cid:4)ψ if there is [z, t] with [x, y]R XFig. 1 describes the semantics of HS7 and HS3 operators in terms of that of HS operators. Notice that a distinguishing characteristic ofs HS, inherited by the fragments considered in this paper, is the fact that the truth of a propositional letter over a given interval has no influence on the truth of the same propositional letter on the intervals contained in it, nor its points. Alternative choices include the locality principle, that implies assigning the same truth value to a propositional letter over an interval as over its starting points (see [38] for the introduction of locality in ITLs, and more recent work, such as [32], for an example of a renewed interest in constraining principles). This and other, similar, model-theoretic constraints have been shown useful in several applications and help reduce the complexity of problems such as satisfiability or model-checking, but here we follow the most general approach, in which undecidability is the rule and decidability the 1 This notation should not be confused with the standard notation for fragments of HS, indicated by the set of its modal operators, e.g., ABBA, which includes four modal relations, namely, (cid:3) A(cid:4), (cid:3) A(cid:4), (cid:3)B(cid:4), and (cid:3)B(cid:4).4E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26Table 1Bike sharing system database.Tripstrip_idstarttimestoptimebikeidfrom_st_idto_st_id4118427542914316434244802013-06-27 12:112013-06-27 14:442013-06-27 14:582013-06-27 15:062013-06-27 15:132013-06-27 19:402013-06-27 12:162013-06-27 14:452013-06-27 15:052013-06-27 15:092013-06-27 15:272013-06-27 22:28Maintenance31664433123852278532321919340283219195546repair_idstarttimestoptimebikeidfrom_st_idto_st_id53275335534653532013-06-28 09:052013-06-28 09:142013-06-28 09:262013-06-28 09:352013-06-28 10:152013-06-28 10:412013-06-28 14:252013-06-28 09:50594227118226272674241111exception. It is worth observing that both HS3 and HS7 are expressive enough to simulate the universal operator, and this depends essentially on their modalities being jointly exhaustive; for HS3 we have:[G]ϕ = ϕ ∧while for HS7:[G]ϕ = ϕ ∧(cid:3)([X]ϕ ∧ [ X]ϕ),X∈{L,I}(cid:3)X∈{L, A O ,D B E}([X]ϕ ∧ [ X]ϕ).Formulæ of HS, and therefore of HS3 and HS7, can be interpreted over several different classes of interval models. Their frame properties sometimes influence the computational complexity of the satisfiability problem, as witnessed by the recent series of results [14,1]. Notable classes of linear orders include Lin, that is, the class of all linear orders, the class Fin of all finite linear orders, and the classes that are built over N, Z, Q, R. As far as the class of all dense linear orders is concerned, a simple application of both the downward Löwenheim–Skolem’s Theorem and Cantor’s Theorem proves that the decidability of a fragment of HS over Q implies the decidability of the same fragment on a generic dense linear order. We generically use the expression the finite/discrete case for the cases that include Fin, N, and Z, but also the class Dis of all discrete linear orders. Beside notable exceptions such as the fragment ABBA of HS, fragments of HS tend to behave in a similar way in all finite/discrete cases.3. Coarser interval relations at workIn this section we discuss two working examples of temporal reasoning in coarser interval temporal logics.3.1. An example as a specification languageThis example is inspired by Divvy, the City of Chicago’s bike sharing system. The system consists of a fleet of bikes that are locked into a network of docking stations located throughout the city. Bikes can be rented from and returned to any station in the city, creating a network of trips with many possible combinations of starting and ending points. Anonymous trip data are stored in a temporal database and openly available through the Divvy Data Challenge program. The database consists of two tables (see Table 1): Trips, that stores the data on the user rentals, and Maintenance, that stores the data on the repairs and other maintenance activities of the bikes. We assume that repairs and maintenance always take place at a special station with identifier 1. Since this is naturally temporal information, tables are equipped, among other attributes, with a starttime and a stoptime for each tuple; the interval identified by the two endpoints can be interpreted as the valid time of the tuple (see, e.g. [22]). Interval temporal logics can be used to reason on the database in at least two different ways: as query languages to extract information from a current instance of the data and as specification languages to express functional dependencies, integrity constraints and other requirements that must be met by every instance of the data; in this example, we follow the latter approach and use HS3 as a specification language. Once the requirements are defined and formalized by the domain experts, one of the first problems that one must solve is the consistency problem, namely, the problem of checking whether they can be met by an actual instance of the database or not. In its most general formalization, the consistency problem can be solved by checking whether the set of formulæ representing the requirements is satisfiable.Formulæ expressing the requirements will be built from the following propositional letters: trip (i, j, k) to represent that the bike i performed a trip from station j to station k, and repair (i, j, k) to represent that bike i was collected at station jand brought to station k to be repaired. Although HS3 is not nearly as expressive as full HS, some very natural requirements (cid:3)(cid:3)i(cid:3)(cid:3)(cid:3)i(cid:3)E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–265can be written in this language. To start with, we can enforce on the Trip table that at any time instant a given bike can belong to at most one trip. More formally, for every bike identifier i, no pairs of intervals satisfying trip (i, j, k) and trip (i, l, m) can share any point (in particular, a trip cannot start at the same time when the previous trip ended):(cid:4)j,k trip (i, j, k), and repair (i) as syntactic sugar (cid:3)(cid:3)[G](trip (i, j, k) →¬trip (i, l, m)).i, j,k( j,k)(cid:16)=(l,m)Similarly, we can ensure that two repairs for the same bike do not overlap:[G](repair (i, j, k) →¬repair (i, l, m)).i, j,k( j,k)(cid:16)=(l,m)(cid:4)Here and below, whenever necessary, we use trip (i) as syntactic sugar for for j,k repair (i, j, k):(cid:3)[G](repair (i) → (¬(cid:3)I(cid:4)repair (i))).During maintenance a bike cannot do any trip (and vice-versa):[G](repair (i) → (¬trip (i) ∧ ¬(cid:3)I(cid:4)trip (i))),i(cid:3)[G](trip (i) → (¬repair (i) ∧ ¬(cid:3)I(cid:4)repair (i))).i[G](¬repair (i, 1, j) ∧¬repair (i, j, k)).i, jk(cid:16)=1(cid:3)Finally, we guarantee that maintenance is performed regularly:[G](cid:3)L(cid:4)repair (i).Then, we guarantee that a repair finishes in station 1 and starts from a station different from 1:The above formalization is arguably simple and intuitive. While it may seem that a similar, maybe less immediate, formalization could be carried out in some point-based temporal logic such as LTL, it is easy to extend our model to include pure interval-based properties. Indeed, it is not uncommon that systems such as the above one are paired up with meteorological information, for statistical or knowledge extraction purposes. Moreover, such meteorological information can be enriched with data concerning the pollution levels, and, in particular, with anti-pollution measures taken by the city councils. Now, suppose that in order to promote the use of bike sharing systems over private cars it is decided that rates for those trips that occur during intervals of time in which anti-pollution measures are active must be discounted. In order to make the service more appealing, it is decided that such discounts apply to all trips that overlap in any way an interval of time in which anti-pollution measures are active. Assuming that anti_pollution labels all intervals in which some measure is active, and that discount (i), as a shortcut for j,k discount (i, j, k), labels all and only those trips that will be eligible for a discount, we can state:(cid:4)[G]((trip (i) ∧ (cid:3)I(cid:4)anti_pollution ) → discount (i)).i3.2. An example in natural language processingNatural language processing is a well-established branch of Artificial Intelligence, and it is well-known that the structure of natural language can be, at least partly, described with interval temporal logic constructs [40,3]. Recently, the rise of automatic personal assistants (e.g., chatbots) has given a new meaning to natural language processing, and tools for this task are being studied and developed. One of the major challenges in the automatic processing of a text is context retrieval [8], and, as a consequence, context description. A context can be seen as an interval during a conversation in which a particular topic is being discussed. Because of its nature, a context cannot be forced to be an uninterrupted sequence of instants in which that particular topic is being discussed; therefore, intervals are labeled with propositional letters that represent contexts without using any projection principles such as locality or homogeneity (see Section 2). Moreover, in a conversation the contexts may overlap each other, and more generally, they may be in any Allen’s relation with each other.In this example, a certain company is designing a natural language processing tool to analyze conversations between agents and clients. The agents contact the clients with the aim of selling a certain product, and the company has specific 6E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26requirements concerning the ordering and structure of the conversation, which can be described as requirements on the various contexts that arise during a conversation. They impose that some essential contexts, such as the price of the product (denoted by price ), its known advantages (advantages ) over other products, and its possible minor defects (defects ) must arise during the conversation:(cid:3)L(cid:4)price ∧ (cid:3)L(cid:4)advantages ∧ (cid:3)L(cid:4)defects .The company also wants that the disadvantages of the product are never discussed together with the price, in order to keep these two concepts separated during the conversation:[G](price → ¬(cid:3)I(cid:4)defects ).In order to stress the positive message, the company also requires that the advantages are mentioned, separately, before and after mentioning the defects of the product:[G](defects → ((cid:3)L(cid:4)advantages ∧ (cid:3)L(cid:4)advantages )).Finally, the company wants that the price is never mentioned without recalling the advantages of the product:[G](price → (cid:3)I(cid:4)advantages ).4. HS3 is PSPACE-completeIn this section, we first prove that the satisfiability problem for HS3 is PSpace-hard, regardless of the class of linearly ordered sets on which interpreted, and, then, that it is also in PSpace when it is interpreted in the class of all finite linear orders or in N/Z. As usual, the constructions and the underlying ideas in the finite case are emblematic for the entire range of classes of discrete structures; therefore, for the finite case we give a small model theorem in detail, a PSpace, non-deterministic, algorithm, and a possible deterministic implementation in the form of a tableau, while for the case of N we simply outline a small periodic model theorem. The cases of Z and the class of all discrete linear orders Dis can be considered simple (albeit technically not trivial) generalizations of the case of N.4.1. Compass structure interpretationGiven a linear order D one can alternatively think of an HS model as a compass structure G = (D, L), where strict intervals [x, y] are seen as points (x, y) in the half-plane D × D identified by the constraint x < y, L is an extended labeling L : D × D → 2Cl(ϕ), Cl(ϕ) is the set of all sub-formulæ of a given formula ϕ, and L(x, y) denotes the subset of Cl(ϕ)of precisely those formulæ that are true at the interval [x, y] (including propositional letters). Modal operators are then immediately interpreted in a geometric way (e.g., the modality (cid:3)B(cid:4), (cid:3)B(cid:4) correspond to moving on a vertical line in the plane, while (cid:3)E(cid:4), (cid:3)E(cid:4) correspond to moving on a horizontal line). Such an interpretation, that works nicely also for its fragments of HS3 and HS7, was introduced in [44], and it has been used, among others, in [36,31], as an advanced tool for undecidability proofs.4.2. HardnessA Quantified Boolean (QB) formula is an expression of the formθ = Q 1 p1 . . . Q n pn f ,is a formula of propositional logic and, for all 1 ≤ i ≤ n, Q i is either ∀ or ∃. When every variable in a formula fwhere fis quantified, f is said to be a closed formula, and the truth problem for a closed QB formula is known to be PSpace-hard [42]. In the following, we provide a (LogSpace) reduction from the truth problem for closed QB formulæ to the satisfiability problem for HS3. Let P ∀ (respectively, P ∃) be the set of the indexes of the universally (respectively, existentially) quantified variables in θ . The strategy of our reduction is as follows. We want to encode a tree-like structure onto the linear ordering that underlies the model, without committing to any particular property of the ordering itself. Such a tree represents the QB formula θ in a very natural way: at each level i > 1, pi−1 occurs at least once if the i-th quantifier is existential (and it occurs either positive or negative), and at least twice if the i-th quantifier is universal (and it occurs both positively and negatively). So, for example, if fis encoded in a binary tree with empty root and two children: one with p1 and the other one with ¬p1. For a tree of height n (which corresponds to the encoding of a quantified formula with n propositions), we use n + 1 propositional letters h1, . . . , hn+1 to encode the levels of the (at most binary) tree. The idea of the construction is exemplified in Fig. 2, in which the colors are consistent with the intervals in which each letter hi is true.is a propositional formula where p1 occurs, then the quantified formula ∀p1 fE. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–267Fig. 2. A tree-model for θ = ∀p1∃p2∀p3∃p4((p1 ∨ p2) ∧ (¬p1 ∨ ¬p2) ∧ (p3 ∨ p4) ∧ (¬p3 ∨ ¬p4)) (right-hand side) and its embedding into a compass structure (left-hand side).Let ϕstart be the following formula:(cid:3)ϕstart = h1 ∧[G](hi → ¬(cid:5)h j))1≤i≤n+1(cid:3)[G](hi →(cid:5)i< j≤n+1¬(cid:3)I(cid:4)h j).∧(1)(2)1≤i≤n+1i< j≤n+1It is easy to see that, if M, [x, y] (cid:2) ϕstart , then: (i) M, [x, y] (cid:2) h1; (ii) if an interval [z, t] satisfies hi , then it does not satisfy (cid:19)] that intersects [z, t] and satisfies any other h j with j (cid:16)= i, and (iii) for every interval [z, t], then there is no interval [zany other h j with j (cid:16)= i.(cid:19), tBy interpreting the h intervals as nodes of the tree, we know, thanks to ϕstart , that the root of the tree (h1) exists. The idea is to encode f quantifier-by-quantifier, so that at each level we need to take care of the specific quantifier. The interval labeled by h1 does not carry any propositional letter of f , and the truth values of p1, . . . , pn are encoded in hi -intervals (cid:19)] is a descendant of a given hi -interval [z, t] if one of two conditions with 2 < i ≤ n + 1. In the following, we say that [z(cid:19) < z for each apply: (i) either t < zh j -interval [s(cid:19), s] and each j ≤ i (left descendant). Now, let ϕquant be the following formula:(cid:19)] and each j ≤ i (right descendant), or (ii) s < z(cid:19) < s for each h j -interval [s, s(cid:19) < t(cid:19) < t(cid:19), t(cid:3)(cid:3)ϕquant = [G](hi → (cid:3)I(cid:4)(∧ [G]∧ [G]i∈P ∀(cid:3)i∈P ∀(cid:3)i∈P ∃1≤ j<i(cid:3)(hi → (cid:3)I(cid:4)(1≤ j<i(cid:3)(hi → (cid:3)I(cid:4)(1≤ j<iLemma 1. Let M, [x, y] (cid:2) ϕstart ∧ ϕquant .[I]¬h j ∧ (cid:3)I(cid:4)(hi+1 ∧ pi)))[I]¬h j ∧ (cid:3)I(cid:4)(hi+1 ∧ ¬pi)))[I]¬h j ∧ (cid:3)I(cid:4)hi+1)).(3)(4)(5)(cid:19), t(cid:19)] and [z(cid:19)(cid:19), t(cid:19)(cid:19)], such that (i) If M, [z, t] (cid:2) hi and the i-th quantifier of f(cid:19)] (cid:2) hi+1 ∧ pi and M, [zM, [z(cid:19)(cid:19)] (cid:2) hi+1 ∧ ¬pi ;(cid:19)(cid:19), t(cid:19), tis universal, then there exist distinct descendants [z(ii) If M, [z, t] (cid:2) hi and the i-th quantifier of f is existential, then there exists a descendant [z(cid:19), t(cid:19)] such that M, [z(cid:19), t(cid:19)] (cid:2) hi+1 ∧ pi or M, [z(cid:19), t(cid:19)] (cid:2) hi+1 ∧ ¬pi .(cid:19)(cid:19), t(cid:19), t(cid:19)(cid:19), t(cid:19)] with respect to any other h j -interval. First, notice that [zProof. Suppose that M, [x, y] (cid:2) ϕstart ∧ ϕquant , that M, [z, t] (cid:2) hi , and that the i-th quantifier of fis universal. Then, (3)(cid:19)] (cid:2) hi+1 ∧ pi . At the same time, (4) applies, so applies to [z, t], and, therefore, there must be an [z(cid:19)(cid:19)]. Consider now the relative (cid:19), t(cid:19)] such that M, [zthat there must also be an [z(cid:19)] can neither coincide nor intersect [z, t], (cid:19), tposition of [z(cid:19), s](cid:19) > t or tthanks to ϕstart . Therefore, either z(cid:19)] is trivially correct) such that s < z, the h j -interval, with j = i − 1 (if there is no such interval, then the position of [z(cid:19), s] can be regarded to as the for each s < simmediate h j -predecessor of [z, t]; such an intuitive notion, however, is imprecise over dense models). By ϕstart , we know (cid:19)](cid:19), tthat [z(cid:19) < z is an hi+1-interval. Then, (3) and (4) are both not satisfied; indeed, in this situation, every interval that with s < u < u(cid:19), s], which is a contradiction. intersects both [z, t] and [z(cid:19) < z; let us assume the latter, without loss of generality. Let now be [s(cid:19)] such that M, [z(cid:19)(cid:19)] (cid:2) hi+1 ∧ ¬pi ; clearly, [z(cid:19), t(cid:19)] (and, so, every candidate to satisfy (3) or (4)) intersects also [s(cid:19), s]. Towards a contradiction, suppose that t < s(cid:19)(cid:19)] is an h j -interval (in other words, [s(cid:19)] can neither coincide nor intersect [s(cid:19)(cid:19) < z, no interval of the type [s, and that no interval [u, u(cid:19)] (cid:16)= [z(cid:19)(cid:19)(cid:19), s(cid:19)(cid:19), t(cid:19), t(cid:19), t(cid:19), t(cid:19)8E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26Therefore, it must be the case that s < zargument can be applied to [zonly once. (cid:2)(cid:19)(cid:19), t(cid:19)] is a descendant of [z, t]. Since the same (cid:19), t(cid:19)(cid:19)], (i) follows. As for (ii), one simply replicates the same argument as above, using (5), but (cid:19) < z, which is to say that [z(cid:19) < tFinally, we need to make sure that once a decision over the truth value of a given pi is taken, it is always respected. This means that the truth value of pi on a given node in the tree must be copied over every node in its own subtree. Since the tree is encoded in a linear ordering, there must be a way to distinguish the right subtree of a node from the left one; this is not guaranteed from the encoding so far (i.e., point (i) of the above lemma may be satisfied by two intervals on the same side with respect to the current node); it is, however, a consequence of the remaining part of the construction, where ϕcasc is the following formula:(cid:3)(cid:3)ϕcasc = [G]((hi ∧ pi−1) → [I]([I]¬h j → [I]pi−1))∧ [G]2≤i≤n(cid:3)2≤i≤n1≤ j≤i−1(cid:3)((hi ∧ ¬pi−1) → [I]([I]¬h j → [I]¬pi−1)).1≤ j≤i−1Lemma 2. Let M, [x, y] (cid:2) ϕstart ∧ ϕquant ∧ ϕcasc , and let M, [z, t] (cid:2) hi for some 2 ≤ i ≤ n + 1.(i) If M, [z, t] (cid:2) pi−1, then each descendant of [z, t] is labeled by pi−1;(ii) If M, [z, t] (cid:2) ¬pi−1, then each descendant of [z, t] is labeled by ¬pi−1.(6)(7)Proof. If M, [x, y] (cid:2) ϕstart ∧ ϕquant ∧ ϕcasc , M, [z, t] (cid:2) hi , and M, [z, t] (cid:2) pi , then (6) applies. It is immediate to see that its consequent captures precisely the two maximal intervals2 (one to the left and one to the right) such that each h-type interval that intersect either of them is a descendant of [z, t] (or it is [z, t] itself). Since these intervals are precisely where pi is forced to hold, (i) is proved. The argument for (ii) is identical. (cid:2)Observe now that Lemma 1 and Lemma 2, combined, force any hi -interval that correspond to a universal quantifier to have both a left and a right descendants, one with pi and the other with ¬pi , as we wanted. Let us now setϕθ = [G](hn+1 → f ) ∧ ϕstart ∧ ϕquant ∧ ϕcasc.Lemma 3. Let θ = Q 1 p1 . . . Q n pn f be a closed quantified Boolean formula. Then θ is true if and only if ϕθ is satisfiable.Proof. Suppose first that θ is true; we want to prove that ϕθ is satisfiable on a finite model. Let us proceed by in-duction on the number of variables of θ making sure that, at each step, the construction remains finite. As base case, suppose that θ has only one proposition, that is, θ = Q 1 p1 f , and fis a propositional formula in which only p1 oc-curs. If Q 1 is universal, then fis satisfied no matter the value of p1; we can easily build a model M over the domain D = {0 < 1 < 2 < 3 < 4 < 5}, where V (p1) = V (h2) = {[0, 1], [4, 5]} and V (h1) = {[2, 3]}, and it is immediate to see that M, [2, 3] (cid:2) ϕQ 1 p1 f . The case in which Q 1 is existential can be treated in a similar way. As far as the inductive step is con-is satisfiable. By the inductive hypothesis, we know for every quantified formula cerned, assume that Q 1 p1 Q 2 p2 . . . Q n pn fwith n − 1 propositional variables, the corresponding HS3 formula is satisfiable. Let us assume that Q 1 is universal. This means that the two formulæ Q 2 p2 . . . Q n pn f [p1/0] and Q 2 p2 . . . Q n pn f [p1/1] are satisfiable as well, and, since they have both n − 1 propositional variables, the inductive hypothesis applies. Let M1 and M2 be their respective models with finite domains D1 and D2. (Notice that we are assuming that M1, M2 are models over the letters h2, . . . , hn+1, p2, . . . , pn). Now, (cid:19)2) be the model obtained from M1 (respectively, M2) by simply making p1 true (respectively, false) let Meverywhere in the model. We now build a model M based on the domain D1 ∪ {0 < 1} ∪ D2, where we assume that 0, 1are new two fresh points and that 0 is greater than every point of D1 and, respectively, 1 is smaller than every point of D2. (cid:19)The valuation of M can be built as follows: (i) V (h1) = {[0, 1]}; (ii) V (p) = V1 and (cid:19)(cid:19)each propositional variable; (iii) V (p) = V2 and each propositional variable; (iv) for 2(p) for each interval that belongs to Meach [x, y] (cid:16)= [0, 1] such that x ∈ D1 ∪ {0, 1} and that y ∈ D2 ∪ {0, 1}, [x, y] /∈ V (hi) for any 1 ≤ i ≤ n. It can be checked now that M, [0, 1] (cid:2) ϕQ 1 p1 Q 2 p2...Q n pn f as we wanted. The case in which Q 1 is existential can be treated in a similar way.(cid:19)1(p) for each interval that belongs to M(cid:19)1 (respectively, MLet us focus on the converse direction, and let us assume that ϕθ is satisfiable; we want to prove that θ is true. Let us proceed, as before, by induction on the number of propositional variables of θ . As base case, let θ = Q 1 p1 f , and let M be a linear model such that M, [x, y] (cid:2) ϕQ 1 p1 f ; assume that Q 1 is universal. By, ϕstart , Lemma 1, and Lemma 2, we know that (cid:19)(cid:19) < x, (cid:19)(cid:19), y(cid:19)(cid:19)] such that either yM, [x, y] (cid:2) h1, that there exist two descendants [x(cid:19)] (cid:2)(cid:19), y(cid:19)] (cid:2) h2 ∧ p1 ∧ f and M, [xand that one of the following two cases hold: either M, [x(cid:19) > y and y(cid:19)(cid:19)] (cid:2) h2 ∧ ¬p1 ∧ f , or M, [x(cid:19) < x and x(cid:19)(cid:19), y(cid:19)] and [x(cid:19), y(cid:19)(cid:19) > y, or x(cid:19), y2 Over dense linear orders such intervals may not belong to the model, but the argument still holds.E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–269(cid:19)(cid:19), y(cid:19)(cid:19)] (cid:2) h2 ∧ p1 ∧ f . Either way, fis satisfied no matter the value of p1, so that Q 1 p1 fh2 ∧ ¬p1 ∧ f and M, [xis true. The case in which Q 1 is existential can be treated in a similar way. As far as the inductive case is concerned, assume that θ = Q 1 p1 Q 2 p2 . . . Q n pn f and that Q 1 is universal. Since ϕθ is satisfiable by the hypothesis, for some linear model M and some interval [x, y], we have that M, [x, y] (cid:2) ϕθ . Let D be the linear ordering on which M is based. By ϕstart , M, [x, y] (cid:2) h1. (cid:19)] is a left descendant of [x, y], and Let D1 ⊂ D be set of points such that for each interval [x(cid:19)(cid:19)] is a right descendant of [x, y]. (cid:19)(cid:19), ylet D2 ⊂ D be set of points such that for each interval [x(cid:19), y(cid:19)(cid:19)] (cid:2) ¬p1(cid:19)(cid:19), yBy combining Lemmas 1 and 2 we know that D1, D2 are not empty, and that either M, [x(cid:19)] ∈ I(D1) and each (cid:19)(cid:19)] (cid:2) p1 for each [xfor each [x(cid:19)(cid:19)] ∈ I(D2). Notice that D1 (respectively, D2) can be seen as the underlying linear order of a model M1 (respectively, [x(cid:19)] (cid:2) ϕQ 2 p2...Q n pn f [p1/0] for some M2) for the propositional letters h2, . . . , hn+1, p2, . . . , pn. We also know that either M1, [x(cid:19)] (cid:2) ϕQ 2 p2...Q n pn f [p1/1] for (cid:19), y[x(cid:19)(cid:19)] ∈ I(D2). Thus, by inductive hypothesis, (cid:19), ysome [xQ 1 p1 Q 2 p2 . . . Q n pn fis true. The case in which Q 1 is existential can be treated in a similar way. (cid:2)(cid:19)(cid:19)] (cid:2) ϕQ 2 p2...Q n pn f [p1/0] for some [x(cid:19)(cid:19)] (cid:2) ϕQ 2 p2...Q n pn f [p1/1] for some [x(cid:19)] (cid:2) p1 and M, [x(cid:19), y(cid:19)] ∈ I(D1) and that M1, [x(cid:19)] ∈ I(D1) and that M1, [x(cid:19)] such that x(cid:19)(cid:19)] such that x(cid:19) ∈ D1, [x(cid:19), y(cid:19)(cid:19) ∈ D1, [x(cid:19)] ∈ I(D1) and each [x(cid:19)(cid:19)] ∈ I(D2), or M1, [x(cid:19)(cid:19)] ∈ I(D2), or M, [x(cid:19)] (cid:2) ¬p1 and M, [x(cid:19), y(cid:19)(cid:19), y(cid:19), y(cid:19)(cid:19), y(cid:19)(cid:19), y(cid:19)(cid:19), y(cid:19)(cid:19), y(cid:19)(cid:19), y(cid:19)(cid:19), y(cid:19)(cid:19), y(cid:19)(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19), yTheorem 1. The satisfiability problem for HS3 interpreted over any class of linear orders is PSpace-hard.Proof. Since Lemma 3 proves that the satisfiability problem for QB formulæ can be reduced in LogSpace to the satisfiability problem for HS3, the result is immediate. (cid:2)4.3. PSpace membership: the finite caseNow, we prove that the satisfiability problem for HS3 is decidable in PSpace in the particular case of finite linear orders.We start by proving the small model property for HS3 interpreted over finite models, which is key to showing decidability (and complexity) of the satisfiability problem. This is taken care by Lemma 4 below; given its importance, it is convenient to understand the driving concepts before getting into the technical details. In the finite case, every satisfiable formula has a finite model; we compute a bound for the size of such model, and we prove that every model exceeding the bound can be reduced to a smaller model that satisfies the same formula. To this end, we provide a description of each row of the compass structure that represents a model; such a (finite) description is carefully designed to achieve two goals: first, there must be a finite number of different descriptions, and, second, when two rows with the same description occur, the portion of the model above each of them must be (essentially) the same. So, the number of different descriptions will be our computed bound, and we shall refer to a model G (bigger than such a bound) and its contracted version G(cid:19), where the portion of the model that exists between two rows with the same description is eliminated. The initial part of the proof is devoted to defining the description of a row; the second part to the definition of contracted model; and the last two parts of the proof to showing that in the resulting structure every universal formula is respected and every existential formula is eventually satisfied. Observe that each formula ϕ is equi-satisfiable withϕ(cid:19) = ϕ ∨ (cid:3)I(cid:4)ϕ ∨ (cid:3)L(cid:4)ϕ.Indeed, it is easy to see there exists a compass structure G = (D, L) for ϕ if and only if there exists a compass structure G(cid:19) = (D, L(cid:19)) for ϕ(cid:19)with ϕ(cid:19) ∈ L(0, 1); this notion is also called initial satisfiability. Then, without loss of generality, we focus on initial satisfiability only, that is, we search only for models whose domain is of the type {0, 1, 2, . . .}, where [0, 1] is the initial interval.Lemma 4. Let ϕ be a finitely satisfiable HS3 formula. Then it is satisfied on a model M with D of cardinality 2O (|ϕ|3).Proof. Let G = (D, L) be a compass structure that (initially) satisfies the formula ϕ. We prove that if the size of D exceeds the bound, then there exists a compass structure G(cid:19) = (D(cid:19), L(cid:19)) for ϕ with |D(cid:19)| < |D|. The contraction method obtained in this way can be iterated in order to obtain a model whose cardinality does not exceed the given bound.Definitions. Given G = (D, L) that satisfies ϕ, for a point (x, y) we can define the set of its requests as the subset of Cl(ϕ)that holds on the interval [x, y]. Intuitively, a request is a temporal formula to be satisfied somewhere; it may be existential, and therefore must be witnessed by some interval, or universal, and therefore it influences only the labels of the already existing intervals. A set of requests behaves differently depending on the modal operators that are involved in it. We choose to consider the requests of the type (cid:3)I(cid:4), (cid:3)L(cid:4) together, and separate them from the requests of the type (cid:3)L(cid:4), as follows: we define the set RI L(x, y) as the subset of L(x, y) that contains only formulas of the type (cid:3)I(cid:4)ψ, [I]ψ, (cid:3)L(cid:4)ψ , or [L]ψ , and the set RL(x, y) as the subset of L(x, y) that contains only formulas of the type (cid:3)L(cid:4)ψ, [L]ψ . By exploiting the properties of our modal operators we can represent the requests in a more convenient way. Indeed, observe that given two intervals [x, y](cid:19), y] is and [x(cid:19), y]also on [x, y]; moreover, every existential request (cid:3)L(cid:4)ξ on [x, y] is also on [xis also on [x, y]. These two properties together allow us to define the set of requests of a row y in G, as follows:(cid:19), y] is also on [x, y], and every universal request [I]ξ on [x(cid:19), y] and every universal request [L]ξ on [x, every existential request (cid:3)I(cid:4)ξ on [x(cid:19)(cid:19), y] with x > x10E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26RI L( y) = {RI L(x, y) : 0 ≤ x < y}.Then, we can represent it as a sequence (which we call a chain) R 1, R2, . . ., R|Rcontainment) ordering among its elements. In a similar way, for every 0 ≤ x, xon a row y, we can define:I L ( y)|, because there is an implicit (set-(cid:19), y) and, thus, (cid:19) ≤ y, we have RL(x, y) = RL(xRL( y) = RL(x, y), for any 0 ≤ x < y.I L(x, y)|, |RL(x, y)| ≤ |ϕ| for every interval [x, y]. This immediately implies that |RL( y)| ≤ |ϕ|, but also that |R(The asymmetry between types of requests is due to the inherent asymmetry of compass structures.) Now, observe that |RI L( y)| ≤|ϕ|. To see this, recall that every element R of a chain RI L( y) can be ideally separated into four components, namely the existential and the universal requests of type (cid:3)I(cid:4) and (cid:3)L(cid:4): the regularity property that we have observed above effectively limits the maximal cardinality of each component, and therefore also the cardinality of different Rs that may occur on a |ϕ| log(|ϕ|). Now, single row. As a consequence, the number of possible different chains Rif 0 is the first point of the model, then a chain RI L ( y) contains sets of requests for the intervals [0, y], [1, y], . . ., and so on; since, as we have already observed, the requests in (the components of the) successive Rs grow monotonically bigger or smaller, there will be a subset of points 0, . . . , m ≤ y in which all sets of requests are identical, and they change at the interval [m + 1, y]: this structure repeats itself along the chain, so that we can count, for each set of request that occurs in it, the number of consecutive points in which it appears. Now let S : I(D) → 2Cl(ϕ) be a function such thatI L ( y) is bounded by |ϕ|! ≤ |ϕ||ϕ| = 2S(x, y) = {ψ ∈ Cl(ϕ) : there are x(cid:19), yand ψ ∈ L(x(cid:19)(cid:19), ysuch that 0 ≤ x(cid:19))}.(cid:19) ≤ x < y ≤ y(cid:19)Intuitively, S associates to each point (x, y) all the formulæ (in the closure of ϕ) that occur in the maximum rectangle that has (x, y) as it lower right corner (this notion is well defined as G is a finite compass structure and it is geometrically interpreted); we call S(x, y) the rectangle of (x, y). If we fix a row y, then it is easy to prove that the sets S(x, y) enjoy similar regularity properties as the sets of requests, so that S(0, y) ⊆ S(1, y) ⊆ . . . ⊆ S( y − 1, y). As before, this allows us to effectively bound the cardinality of any such set; in fact, we have |S(x, y)| ≤ 2 · |ϕ|. Therefore, we can represent these components on a row y as we did for the requests; if (cid:6)( y) = {S(x, y) : 0 ≤ x < y} is the chain of sets S(x, y) on the row y, then |(cid:6)( y)| ≤ 2 · |ϕ| (observe that the sets S(x, y) do not need to be consistent, so that it can contain both a formula and its negation). Each element of a chain (cid:6)( y) can be chosen among 22·|ϕ|, so that the number of possible different chains (cid:6)( y) is bounded by 22·|ϕ| · 22·|ϕ|−1 · . . . · 1, which, in turn, can be bounded by 2. Let us associate to a single row y a function|ϕ|2count( y) : RI L( y) × (cid:6)( y) → {1, . . . , 4 · |ϕ| + 1},such that, for each R ∈ RI L( y) and every L ∈ (cid:6)( y), we have thatcount( y)(R, L) = min{4 · |ϕ| + 1, |{x : RI L(x, y) = R and S(x, y) = L}|}.|ϕ|2 log(4·|ϕ|+1) possible Observe that, for a row y, a chain Rcount( y) functions; this can be justified by observing that a given chain can be associated to a different function depending on how many times a given set of requests and how many times a given rectangle occur at a given position. At this point, for each y we defineI L( y), and a chain (cid:6)( y), there can be at most (4 · |ϕ| + 1)|ϕ|2 = 2row( y) = (RL( y), RI L( y), count( y), (cid:6)( y)).This can be regarded as a complete description of the row y of the compass structure (limited to the information that we need to perform the contraction). Taking into account the number of different component of each row( y), the number of the possible values for row( y) is bounded by|ϕ| · 2|ϕ|·log(|ϕ|) · 2|ϕ|2·log(4·|ϕ|+1) · 2|ϕ|2 = |ϕ| · 2|ϕ|·(|ϕ|·log(4·|ϕ|+1)+log(|ϕ|)+|ϕ|) = 2O (|ϕ|3),as we wanted.Contraction. If |D| exceeds the above bound, then, by a simple combinatorial argument, there must exist two rows y1 < y2 with row( y1) = row( y2) (Fig. 3). Indeed, let us analyze the component of the above bound: |ϕ| takes into account |ϕ| log(|ϕ|) counts the number of the number of different RL( y) (in order for the contraction to work on the diagonal), 2|ϕ|2 log(4·|ϕ|+1) counts possible different chains of requests (so that we make sure to have two rows with the same chain), 2the number of possible different functions count( y) for the given row (so that we make sure that we have two row with the same chain and the same count), and 2is the number of possible chains (cid:6)( y) (to make sure that the rectangles identified by y1 and y2 is the same). In order to prove that we can safely contract the model between y1 and y2, let us focus our attention on the set Rec( y2) in G that contains all and only such points (z, t) where z ≤ y and t > y. For |ϕ|2E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2611Fig. 3. A picture of the contraction method. In gray, the contracted area; in red, the down-left triangle (preserved); in yellow, the up-right triangle (moved without changes); and, in green, the vertical segments that have been copied from G to G(cid:19). (For interpretation of the colors in the figure(s), the reader is referred to the web version of this article.)each ψ ∈ Cl(ϕ), if ψ ∈ L(z, t) and (z, t) ∈ Rec( y), then we can identify four points (z∗, t∗) with ∗ ∈ {right, le f t, up, down}(cid:19) ≤ tup . In other words, and ψ ∈ L(z∗, t∗) as follows: for every (zthe points (z∗, t∗) with ∗ ∈ {right, le f t, up, down} are, respectively, the rightmost, leftmost, highest, and lowest occurrences of ψ in the rectangle of y. We define the set W( y) ⊆ {0, . . . , y}, for a given y, as a minimal subset of {0, . . . , y} such that contains all rightmost, leftmost, highest, and lowest witnesses of ψ in y for each ψ ∈ Cl(ϕ). Thus, we can define the following non-decreasing monotone function:(cid:19) ≤ zright and tdown ≤ t(cid:19)) then zle f t ≤ z(cid:19)), if ψ ∈ L(z(cid:19), t(cid:19), tg : {0, . . . , y1} → {0, . . . , y2}.In the above definition we have that (i) for every x ∈ {0, . . . , y1}, we have RI L(g(x), y2), (ii) for every x ∈{0, . . . , y1}, we have S(x, y1) = S(g(x), y2), (iii) W y2⊆ Img(g), and y2 − 1 ∈ Img(g), where Img(g) is the image of g. Let (cid:7) = y2 − y1; we can finally build the compass structure G(cid:19) = (D(cid:19), L(cid:19)) with |D(cid:19)| = |D| − (cid:7), where L(cid:19)is defined as follows:(i) L(cid:19)(x, y) = L(x, y) for every 0 ≤ x ≤ y ≤ y1, (ii) L(cid:19)(x, y) = L(x + (cid:7), y + (cid:7)) for every y1 < x ≤ y ≤ |D(cid:19)|, and (iii)L(cid:19)(x, y) = L(g(x), y + (cid:7)) for every y1 < x ≤ y1 < y ≤ |D(cid:19)|. In the following, we shall denote the coordinates in G with x, y, . . ., and those of G(cid:19), which depends on the particular area of G from which a certain point is copied; such a correspondence is key to the rest of the proof.(cid:19), . . .. There exists a natural correspondence between points in G and points in G(cid:19)I L(x, y1) = Rwith x(cid:19), yConsistency. Let us now prove that our new, smaller, compass structure is consistent, that is, that every universal request is respected. Given two points (x, y) and (z, t) in a compass structure, and given X ∈ {L, L, I}, we say that (x, y) → X (z, t) if and only if the following holds: if (x, y)R X (z, t) and [ X]ξ ∈ L(x, y), then ξ ∈ L(z, t). In other words, (x, y) → X (z, t) if and only if (z, t) is consistent with the universal requests of (x, y) along the relation X . The following cases may arise for two points (x(cid:19)) in G(cid:19)(cid:19)), (z(cid:19), y(cid:19), t.contraction; therefore, (x• If y(cid:19), t(cid:19) ≤ y• If x(cid:19), z(cid:19) ≥ y(cid:19)1, then both points are located in an area of G(cid:19)(cid:19)) → X (z1, then both points are located in an area of G(cid:19)(cid:19)) in G(cid:19)(cid:19), y(cid:19), t(cid:19)(cid:19) = x + (cid:7) and y(cid:19) = y + (cid:7); therefore, (xits structure, that is, xfact that (x, y) → X (z, t) in G.(the down-left triangle) that has been preserved after the for each X ∈ {L, L, I} thanks to the fact that (x, y) → X (z, t) in G.(the up-right triangle) that has been moved without changing for each X ∈ {L, L, I} thanks to the (cid:19)) in G(cid:19)(cid:19)) → X (z(cid:19), y(cid:19), t(cid:19)(cid:19)(cid:19), y(cid:19) < z(cid:19) ≥ y, or y(cid:19)1 and z(cid:19) ≤ y(cid:19)= z(cid:19)) = L(g( y1), t. In the first case, (x. In the second case, (x• The case z• If y(cid:19), y(cid:19)) in G(cid:19)(cid:19)) →L (z(cid:19)) belongs to the down-left triangle and two sub-cases arise: y(cid:19)1, then clearly (x(cid:19), t(cid:19), y(cid:19), y(cid:19), t(cid:19)) in G(cid:19)(cid:19)1) = L(g(x), y2) and L(cid:19)( y1, t(cid:19) =; this means that (x, y)R L(z + (cid:7), t + (cid:7)), and, since (x, y) →L (z + (cid:7), t + (cid:7))(cid:19)). (cid:19), y(cid:19) + (cid:7)). Observe that (g(x), y2)R I (¯x, ¯y) in G for every (cid:19) + (cid:7) > y2, and this implies .• If y(cid:19)(cid:19))R L(zy1in G, we immediately obtain that (xBy construction, L(cid:19)(x(¯x, ¯y) (cid:16)= (g(x), y2) with ¯y ≥ y2 and ¯x ≤ y2; therefore, in G, we have that g( y1) ≤ y2 and t(cid:19)) in G(cid:19)that (g(x), y2) →I (g( y1), t(cid:19)(cid:19) ≥ y(cid:19) ≤ y1 and y(cid:19)(cid:19)(cid:19)(cid:19)) belongs to the down-left triangle; moreover, there exists ¯x ≤ y(cid:19)(cid:19) < y(cid:19) ≤ y(cid:19), y1 such 1 and z1 < t(cid:19), t(cid:19)) in (cid:19))R L(z(cid:19) ≥ zthat L(cid:19)(z(cid:19) + (cid:7)). Again, two sub-cases arise, namely: y(cid:19)) = L(g(¯x), t(cid:19), t(cid:19) + (cid:7))(cid:19) + (cid:7)) in G; this means that (x, y) →L (g(¯x), tG(cid:19)(cid:19), y(cid:19)) in G(cid:19)(cid:19), t(cid:19)in G, which, in turn, implies that (x(cid:19) + (cid:7)) in G implies and there are two further sub-cases. If (x, y)R I (g(¯x), t(cid:19) + (cid:7)) in G, then, by construction, (x, y)R I (¯x, y1) and (xL(¯x, y1) = L(g(¯x), y2). Then, since S(¯x, y1) = S(g(¯x), y2), we have that (x, y) →I (g(¯x), ¯y) in G for every ¯y ≥ y2; in particular (x, y) →I (g(¯x), t(cid:19) + (cid:7)) in G, which, in turn, implies that (x(cid:19)1 is symmetric to the above one.then, as before, (x, then (x(cid:19) + (cid:7)) in G, then, as before, (x, y) →I (g(¯x), tand, then, since g is monotonic non-decreasing, (x, y)R L(g(¯x), t. If, on the other hand, (x, y)R L(g(¯x), t. If, on the other hand, y(cid:19) + (cid:7)), and thus, (x. In the first case, (x(cid:19)), that is, (x(cid:19)1) →I ( y(cid:19)) →L (z(cid:19)) →I (z(cid:19)) →I (z(cid:19)) in G(cid:19)(cid:19)) in G(cid:19)(cid:19)) in G(cid:19)(cid:19))R A(z(cid:19))R I (z(cid:19))R I (z(cid:19) ≥ z(cid:19) < zor y(cid:19)1, t(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19), t(cid:19), t(cid:19), t(cid:19), tt.(cid:19)(cid:19)(cid:19)12E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26(cid:19)(cid:19) < y(cid:19) ≤ y• The case t1 and x(cid:19)(cid:19)(cid:19)(cid:19) < y• If x1 and z1 < t(cid:19) > ytwo sub-cases may arise. If tL (g(¯x), t(x, y) →since (x, y) →I (t(cid:19)1 and xand x(cid:19) < y(cid:19)is symmetric to the one above.(cid:19)1 < ythen, by construction, there exists ¯x ≤ y1 such that L(cid:19)(z(cid:19), t(cid:19)) in G(cid:19)(cid:19), y(cid:19)(cid:19) < x(cid:19), t(cid:19)) →(cid:19) + (cid:7)) in G, we have that (xL (z(cid:19) + (cid:7)) in G, we have that L(cid:19)(x(cid:19)) →I L(z(cid:19)is symmetric., which implies that (x, y)R L(g(¯x), t(cid:19)). If, on the other hand, t(cid:19), t(cid:19))R L(z(cid:19), y(cid:19), y, then (x(cid:19)(cid:19) > x(cid:19), t(cid:19)).(cid:19)) = L(g(¯x), t, then t, then in this situation we have (x(cid:19) > y• The case z(cid:19)(cid:19)• If z1 < t(cid:19)(cid:19) < y1 < y(cid:19)(cid:19)(cid:19) < y1 < yThen, by construction, there exist ¯x, ¯¯x ≤ y1 such that L(cid:19)(x(cid:19) + (cid:7))R I (g(¯¯x), t(g(¯x), y(cid:7)) in G, which implies that (x(cid:19)) in G(cid:19)(cid:19)) →I (z(cid:19), y(cid:19), t.(cid:19), y(cid:19) + (cid:7)) in G (where y2 is the shared point in such case), we have that (g(¯x), y(cid:19)) = L(g(¯x), y(cid:19), y(cid:19))R I (z(cid:19), t(cid:19)), since y(cid:19) + (cid:7)) and L(cid:19)(z(cid:19) + (cid:7)). Once again, (cid:19) + (cid:7)) in G, and, since (cid:19) + (cid:7); so, (cid:19) + (cid:7) > x(cid:19)1 belongs to both intervals. (cid:19) + (cid:7)). Since (cid:19), t(cid:19) +(cid:19)) = L(g(¯¯x), t(cid:19) + (cid:7)) →I (g(¯¯x), tFulfillingness. Finally, it remains to prove that G(cid:19)is fulfilling, that is, that every existential request is eventually satisfied. Given (x(cid:19), y(cid:19)) ∈ I(D(cid:19)), three cases may arise, depending on where the existential request has originated:• If y• If x(cid:19)(cid:19), t(cid:19), t(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19) ≤ y(cid:19) > y(cid:19) = x − (cid:7) and y1, then as far as the requests of the type (cid:3)L(cid:4) in L(cid:19)(x(cid:19)) are concerned, since these originate and are satisfied in (cid:19), ythe down-left triangle of the structure which has not been modified by the contraction, fulfilling is guaranteed. Consider now a request of the type (cid:3)L(cid:4)ψ ∈ L(cid:19)(x(cid:19)) = L(x, y), for which, in G, there exists (z, t) with z > y such that ψ ∈ L(z, t); (cid:19)) = L(z, t)three sub-cases arise, depending on the position of (z, t) in the structure G. If t ≤ y1, then ψ ∈ L(cid:19)(z(again, everything is confined to the down-left triangle). If t > y2, then, by construction, ψ ∈ L(z − (cid:7), t − (cid:7)) (in this case, fulfilling is guaranteed by the fact that the up-right triangle has been moved without changing its structure). If, finally, z ≤ y1 < t then, since g is monotone non-decreasing, there exists ¯x such that x ≤ ¯x ≤ y1 and ψ ∈ L(g(¯), ¯y)(cid:19), ¯y − (cid:7)), for some ¯y > y2 and g(¯x) is the rightmost vertical segment starting at y2 and exhibiting ψ ; thus ψ ∈ L(cid:19)(¯x(cid:19)). It is important to notice that if z > y1, then we are back to the second sub-case, which is in relation R L with (xas (in G) (cid:3)L(cid:4)ψ belongs to both RL( y1) and RL( y2), which must be equal. Now, let (cid:3)I(cid:4)ψ ∈ L(cid:19)(x(cid:19)); then, in G, there exists (z, t) such that (x, y)R I (z, yt) and ψ ∈ L(z, t). Two cases may arise, depending on the position of (z, t). If t ≤ y1, then ψ ∈ L(cid:19)(z(cid:19)) = L(z, t) (again, everything is confined to the down-left triangle). If, on the other hand, t > y1, then z ≤ x < y1 < t, given that (z, t) must intersect (x, y). Let ¯x ≤ y be the leftmost index for which a vertical segment (starting at y1) starts that exhibits ψ : by construction, g(¯x) is the index which starts the leftmost vertical segment (starting at y2) that exhibits ψ . This means that there exists ψ ∈ L(g(¯x), ¯y) for some ¯y > y2, and, thus, ψ ∈ L(cid:19)(¯x, ¯y − (cid:7)).(cid:19)1, then x(cid:19)) are concerned, since these (cid:19) = y − (cid:7). As far as the requests of the type (cid:3)L(cid:4) in L(cid:19)(xare originated and satisfied in the up-right triangle of the structure which has been move without modifications to its structure, fulfilling is guaranteed. Consider now a request of the type (cid:3)L(cid:4)ψ ∈ L(cid:19)(x(cid:19)) for which, in G, there exists (z, y)with t < x such that ψ ∈ L(z, t); three sub-cases arise, depending on the position of (z, t) in the structure G. If z ≥ y2, then ψ ∈ L(cid:19)(z − (cid:7), t − (cid:7)) (again, everything is confined to the up-right triangle). If t ≤ y2, then either (cid:3)L(cid:4)ψ belongs to some label L(¯¯x, y2) or ψ belongs to some label L(¯¯x, y2); either way, ψ ∈ L(cid:19)(¯z(cid:19)1 (notice that, (cid:19)) independently from its since ψ occurs somewhere in the down-left triangle, it fulfills the request originated in (xprecise position). If, finally z < y2 < t then there exists ¯x ≤ y2 and ¯y < x such that ψ ∈ L(¯x, ¯y) and ¯x is the vertical segment (starting at y2) that exhibits ψ at the lowest coordinate; since g is monotone non-decreasing, and since we may assume ¯x ∈ Img(g), there exists ¯¯x ≤ y1 such that g(¯¯x) = ¯x, and, thus, ψ ∈ L(cid:19)(¯¯x). Now, let (cid:3)I(cid:4)ψ ∈(cid:19)), for which, in G, there exists (z, t) with (x, y)R I (z, t) such that ψ ∈ L(z, t); two sub-cases arise, depending L(cid:19)(xon the position of (z, t) in the structure G. If z ≥ y2, then ψ ∈ L(cid:19)(z − (cid:7), t − (cid:7)) = L(z(cid:19)) (one more time, everything is confined to the up-right triangle). If, on the other hand, z < y2, then t > x (since the intervals [x, y] and [z, t] must intersect each other). We have that there exists ¯x ≤ y2 such that the vertical segment that starts at y2 exhibits ψ at the highest coordinate; since g is monotone non-decreasing, and since we may assume ¯x ∈ Img(g), there exists ¯¯x ≤ y1such that g(¯¯x) = ¯x. Now, we know that, for some ¯y ≥ t, ψ ∈ L(¯x, ¯y) (in G); by construction, ψ ∈ L(cid:19)(¯¯x(cid:19), ¯y − (cid:7)) (in G(cid:19)) and (¯¯x(cid:19) ≤ y(cid:19)) = L(g(¯x), y + (cid:7)). Clearly, ¯x ≤ x, as g is monotonic non-decreasing. Let (cid:3)L(cid:4)ψ in L(cid:19)(xL(¯x, y1), there exists (z, t) with t < y1 such that ψ ∈ L(z, t). By construction, L(z, t) = L(cid:19)(z(cid:19)) (since (z, t) belongs to the down-left (cid:19)) = L(g(¯x), y + (cid:7)). Then, triangle), and, in G(cid:19)since G is fulfilling, there exists (z, t) with z > y + (cid:7) such that ψ ∈ L(z, t). By construction, L(z, t) = L(cid:19)(z − (cid:7), t − (cid:7))(cid:19)) = L(g(¯x), y + (cid:7)). Then, and (xsince G is fulfilling, there exists (z, t) such that, in G, (g(¯x), y + (cid:7))R I (z, t) for which ψ ∈ L(z, t). Three cases may arise, (cid:19)) (that is, (z, t) is in the down-left triangle, preserved depending on the position of (z, t). If t ≤ y1, then L(z, t) = L(cid:19)(z(cid:19)), and (cid:19), yby the contraction), and, since g is monotonic non-decreasing, we have that ¯x ≤ g(¯x); therefore, (x(cid:19)) = L(cid:19)(z − (cid:7), t − (cid:7)), and, since the request is satisfied. If z > y2 (that is, (z, t) is in the up-right triangle) then L(z(cid:19))R I (z − (cid:7), t − (cid:7)), the request is satisfied. If, on the other hand, z ≤ y2 < y and none of the previous case applies, (xthen, by construction, there exist ¯x ≤ y1 such that ψ ∈ L(g(¯x), ¯y) for some ¯y > y2 and, since L(g(¯x), ¯y) = L(cid:19)(¯x(cid:19), ¯y − (cid:7))and (x(cid:19))R L(z − (cid:7), t − (cid:7)), and, thus, the request is satisfied. Finally, let (cid:3)I(cid:4)ψ be in L(cid:19)(x(cid:19), ¯y − (cid:7))R I (x − (cid:7), y − (cid:7)), proving that the request is fulfilled.(cid:19)); therefore, the request is satisfied. Let (cid:3)L(cid:4)ψ be in L(cid:19)(x(cid:19))) = L(g(¯x), y + (cid:7)). Then, since G is fulfilling and R1, then there exists ¯x ≤ y1 such that L(cid:19)(x(cid:19), ¯y − (cid:7)), the request is satisfied.(cid:19)) for some ¯z(cid:19), yL(g(¯x), y2) = R(cid:19), ¯y − (cid:7)) (in G(cid:19)(cid:19)1 and y(cid:19))R L(z(cid:19))R I (z(cid:19) > y(cid:19) ≤ y(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19), ¯y(cid:19), ¯y(cid:19), y(cid:19), y(cid:19), y(cid:19), y(cid:19), y, (x(cid:19), t(cid:19), t(cid:19), t(cid:19), t(cid:19), t(cid:19), t(cid:19))R I (¯x(cid:19)• If xE. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2613Now, G(cid:19)bound, we are done; otherwise, we repeat the entire process. (cid:2)is a compass structure for ϕ, and it is consistent and fulfilling. Clearly, |D(cid:19)| < |D|. If |D(cid:19)| is less than the claimed A small model for HS3 is any model for a HS3 formula ϕ whose domain contains at most 2O (|ϕ|3) points. Small models are, evidently, exponential in length; this means that Lemma 4 proves that HS3 is decidable in non-deterministic exponential time. A little more work is needed to prove that, in fact, it is decidable in polynomial space. To this end, we now describe a non-deterministic algorithm that uses only polynomial space, and, then, we obtain the result thanks to Savitch’s Theorem (PSpace = NPSpace – see, e.g., [39]).The idea underlying our polynomial-space algorithm is that we can check the satisfiability of a HS3 formula by non-deterministically generating a model within the limits of Lemma 4 in such a way that, at any given moment, at most two (compass) rows are kept in memory, so that a single row must contain enough information to allow us to generate the next one. To this end, we need to introduce some more notation and definitions. An atom is any non-empty set F ⊆ Cl(ϕ)such that, for every ψ ∈ Cl(ϕ), ψ ∈ F if and only if ¬ψ /∈ F , and, for every ψ ∨ ξ ∈ Cl(ϕ), either ψ ∈ F or ξ ∈ F ; in other words, an atom is a maximally consistent subset of Cl(ϕ) (labels on a compass structure are, in fact, atoms). We denote by A(ϕ) the set of all possible atoms for ϕ. For X ∈ {L, L, I}, we denote by RϕX the set that contains all and only existential requests (that is, formulæ of the type (cid:3) X(cid:4)ξ ) in Cl(ϕ), and, given the set RϕI and any subset (cid:6) of Cl(ϕ), we call observable, denoted by O((cid:6)), the set (cid:6) ∩ RϕI . Intuitively, we are restricting our attention to the existential part of the requests, and, in ∗, n)particular, those along the relation R I . In order to efficiently describe a row, we define a counting tuple as a triple (R, Rsuch that R ⊆ RϕI L( y) along with its count (the number of times that it occurs in a row). Intuitively, R contains requests yet to be satisfied or satisfied at the row y, and Rcontains requests already satisfied (somewhere below y in the compass structure). For us, a row abstraction is a word; a counting tuple can be seen as the realization of an element of R∗ ⊆ R and n ∈ N+I , R∗C R = (R0, R∗0, n0) . . . (Rm, R∗m, nm)∗i ) (cid:16)= (R i+1, Rof counting tuples such that: (i) (R i, RThe size of a given row abstraction C R is the number |C R| =C R[i] (respectively, C Rthe algorithm shown in Figs. 4 and 5, C R and C R(cid:19)∗[i]), for 0 ≤ i ≤ |C R|, to indicate the set R j (respectively, R(cid:6)∗∗i+1); (ii) R i ⊇ R i+1 for every i < m, and (iii) Ri+1 for every i < m. 0≤i≤m ni , and we access its elements as follows: we write (cid:6)0<l≤ j nl. In 0<l< j nl < i ≤∗j ) such that ⊇ R(cid:6)∗iare row abstractions.Consider now the algorithm in Fig. 4. Clearly, to guarantee the completeness of the approach L I M must take the value is set to the theoretical bound for the dimension of any possible finite model for a given formula ϕ, as explained in Lemma 4. Each let step must be considered as a non-deterministic step, in which the requested object is guessed; then, the algorithm verifies its properties, and if any given property is not respected, the algorithm rejects (so, our algorithm may be seen as a PSpace verifier). The requests of the type (cid:3)L(cid:4) that ϕ may have are handled in the following way: f L((cid:3)L(cid:4)ψ) represents (cid:19) > z; an interval [z, t] on the model being built such that [z, t] satisfies ψ and that no other interval [zrequests of the type (cid:3)L(cid:4) are handled in a symmetric way. So, our algorithm correctly guesses all requests of the type (cid:3)L(cid:4)/(cid:3)L(cid:4), and considers them satisfied within the limits given by f L and f L ; in the function Initialize, we write I(L I M) to denote all intervals that can be built in the set {0, . . . , L I M}. Then, a correct initial atom (F ) is guessed, and its properties must be checked (within the function CheckFirstAtom). Obviously, the checked formula ϕ must belong to F , which, in turn, cannot contain any request of the type (cid:3)L(cid:4), because F holds on [0, 1] (first line of the conditions for F ). Moreover, the requests of type (cid:3)L(cid:4) that are in F are precisely those satisfied anywhere to the right of [0, 1], as collected in the function f L (second line), and F contains, among others, those formulæ ever requested that are satisfied nowhere after (or before) [0, 1] (third line). Finally, to be coherent with f L , F contains no formulæ whose leftmost satisfying interval is not [0, 1] (fourth line). Right before the while loop, we describe the initial part of the compass structure that represent the model being guessed: it has only one level corresponding to y = 1, the row abstraction C R of such line contains precisely one counting tuple formed by non-starred requests only (nothing can be satisfied below 1). We take into account any formula ever mentioned on a line in the component (cid:6)C R , of the requests of the type (cid:3)L(cid:4) in the component LC R , and of the current step (at this point, 0).(cid:19)] does, for z(cid:19), t∗The compass structure is guessed row-by-row, starting with line 1 (that corresponds to the set of all intervals ending at the point 1). Therefore, it is easy to check if, at a given point y, we have already finished: it is enough to verify that the current row abstraction has no request of type (cid:3)L(cid:4) and that every request in every set R of a counting tuple is matched into , and therefore already satisfied. This explains the first part in the while loop. At any given step, the its corresponding set Rrow step + 2 is being guessed, and its abstraction is called C R(with set of formulæ (cid:6)C R(cid:19) ). The remaining part of the code is a correct guess. To this end, we first set the set of its requests of type (cid:3)L(cid:4) as precisely those deals with checking that C Rinsisting on the last point of the line (the point row), and we use a temporary variable (cid:6)∗C R(cid:19) initially set at ∅. Then, we check C Ris correct (that is, it is precisely one more than C R); then, tuple-by-tuple. Consider, then, the problem of checking the correctness of the i-th tuple, that corresponds we check C R∗to the interval [i, row]. The temporary variable C Rpre takes the value of the set of requests already satisfied below (and it is empty when i = row − 1). The guess C Ris rejected if: either the set of requests of type (cid:3)I(cid:4) already satisfied is not equal to the set of those that were already satisfied at the same point in C R plus those that are being satisfied in the line . First, we check that the number of components of C R(cid:19)(cid:19)(cid:19)(cid:19)(cid:19)(cid:19)14E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26procedure HS3-Sat(ϕ, L I M)beginI , ∅, 1)(cid:4)Initialize( f L , f L , L I M)let F ∈ A(ϕ) such that CheckF irst Atom(F , f L , f L )C R ← (cid:3)(RF(cid:6)C R ← FLC R ← RFLstep ← 0while step < L I M doif LC R = ∅ and ∀i(0 ≤ i ≤ |C R| → C R[i] = C R∗[i]) thenbe a row abstractionreturn Y esrow ← step + 2(cid:19)let C Rlet (cid:6)C R(cid:19) ⊆ Cl(ϕ)LC R(cid:19) ← {ψ : [0, row] R L f L (ψ)}(cid:6)∗C R(cid:19) ← ∅,if |C R(cid:19)| (cid:16)= |C R| + 1 thenreturn Nofor i = 0 . . . |C Rif i = |C R∗C Rpre(cid:19)| do(cid:19)| then← ∅elseif C R∗pre← C R[i]∗∗preC R(cid:19)[i]∗ (cid:16)= C Rreturn No∪ O((cid:6)C R(cid:19) ∪ (cid:6)C R ) thenif i < |C R(cid:19)| and C R(cid:19)[i] (cid:2) C R[i] thenreturn Nolet F ∈ A(ϕ) such that Check Atom(C RC R(cid:19) ← (cid:6)∗(cid:6)∗(cid:16)= (cid:6)C R(cid:19) thenC R(cid:19)return NoC R(cid:19) ∪ Fif (cid:6)∗(cid:19), f L , f L )(cid:19)C R ← C R(cid:6)C R ← (cid:6)C R(cid:19)step ← step + 1return NoFig. 4. A PSpace-algorithm for HS3 formulæ satisfiability checking.procedure Initialize( f L , f L , L I M)beginLlet L ⊆ Rϕlet f L : L → I(L I M − 1)let L ⊆ Rϕlet f L: L → I(L I M − 1)Lprocedure CheckF irst Atom(ϕ, f L , f L )beginif ϕ ∈ F ∧ RF= ∅Land RL (F ) = {ψ : [0, 1] R L f L (ψ)}and F ⊇ {ψ : f L (ψ) = [0, 1] ∨ f L (ψ) = [0, 1]}and F ∩ {ψ : ¬([0, 1] = f L (ψ))} = ∅ thenreturn T ruereturn F alseprocedure Check Atom(C R, f L , f L )begin= {ψ : [i, row] R L f L (ψ)}= {ψ : [i, row] R L f L (ψ)}if F ⊆ (cid:6)C Rand ReqI (F ) = C R[i]and RFLand RFLand F ⊇ {ψ : f L (ψ) = [i, row] ∨ f L (ψ) = [i, row]}and F ∩ {ψ : ¬([i, row] R← f L (ψ))} = ∅and F ∩ {ψ : ¬([i, row] R→ f L (ψ))} = ∅ thenreturn T ruereturn F alseFig. 5. Auxiliary procedures for the algorithm in Fig. 4.E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2615(cid:19)(cid:19), at the component i in C Ris not a correct chain. If C R(that is, anywhere in a interval of the type [x, row] – they all intersect the interval [i, row]), or the chain of requests in (cid:19), at the i-th component, has passed all above tests, then it C Ronly remains to be seen (guessed) which atom may occupy the label for the interval [i, row]; this is one key point to keep the complexity of the algorithm in PSpace: atoms are only checked to exist, but never stored. The conditions for such an atom F to exist are: (i) its formulæ are in (cid:6)C R(cid:19) ; (ii) its requests of type (cid:3)I(cid:4) are those in the i-th component of C R; (iii)its requests of type (cid:3)L(cid:4) (respectively, (cid:3)L(cid:4)) are precisely those formulæ whose leftmost (respectively, rightmost) satisfying interval is yet to be seen (respectively, has already been seen); (iv) its formulæ include those satisfied precisely at [i, row]and never again to the left or to the right; (v) finally, its formulæ cannot contradict the functions f (e.g., F cannot witness a formula whose leftmost satisfying interval starts somewhere before i): for a better readability, we denote, in Fig. 4, by R←the union of the identity relation between intervals plus the relation R X for X ∈ {E, E, D, O , A, L}, and by R→ the union of the identity relation between intervals plus the relation R X for X ∈ {B, B, D, O , A, L}. Now, (cid:6)∗C R(cid:19) certainly includes F , and having guessed an atom for each i, the algorithm compares (cid:6)∗(cid:19)) with (cid:6)C R(cid:19) , and rejects if they are different.C R(cid:19) (the set of all formulæ that should be on C R(cid:19)Theorem 2. The finite satisfiability problem for HS3 is PSpace-complete.Proof. Our procedure requires to store only two counters (row and step) and at most two row abstractions at the same time; therefore, it suffices to prove that they can be represented in polynomial space with respect to |ϕ|. Since none of the counters may exceed 2O (|ϕ|3), clearly K = O (|ϕ|3) bits are enough to store each one of them. Now, consider a row abstractionC R = (R1, R∗1, n1), (R2, R∗2, n2), . . .and analyze its components. By definition, R1 ⊇ R2 ⊇ . . ., and since each R i is a subset of RϕI , in the worst case each R idiffers from R i−1 because it has precisely one formula less. Therefore, if we focus on the R component only, there can be at most 2 · |ϕ| different elements in C R. The component Rfollows the same pattern (reversed), so that, in total, there can be at most 4 · |ϕ| different counting triples in a row abstraction. Each one of them requires (2 · log(|ϕ| + 1) + K ) bits to be represented, and the entire row abstraction requires (2 · log(|ϕ| + 1) + K ) · K bits. To such quantity, one has to add the (cid:19)space to store three instances of (cid:6)C R (one for C R, one for C R, and one temporary instance), each one of which requiring log(2 · |ϕ| + 1) bits, and the space for a single atom F , requiring, again, log(2 · |ϕ| + 1) bits. Summing up, the algorithm in Fig. 4 works in polynomial space. Since Theorem 1 gives us a matching lower bound, we have the claim. (cid:2)∗Our PSpace algorithm is impractical. Each non-deterministic choice must guess very complex objects, and atoms must be generated in full at the beginning of the computation, which, alone, is a very time-demanding step. In Section 6 we describe a possible deterministic implementation of a finite satisfiability checker for HS3, along with the result of a systematic series of tests.4.4. PSpace membership: the case of natural numbersThe satisfiability problem for HS3 in the (general) discrete case, i.e., without assuming the finiteness of the models, can be decided using essentially the same principles as in the finite case; we give here the details for the case of N.The most relevant difference between the finite case and the case of N lies in the problem of model representation; in order to define a suitable (finite) representation for infinite models based on the natural numbers, we make use of the technical machinery defined in Lemma 4. First, given any compass structure G = (D, L) and any index 0 < y, we denote G| y = ({ y ∈ D : y < y}, L| y), where L| y is the labeling function defined as L| y(x, y) = L(x, y) for every 0 ≤ x < y ≤ y, the yprefix of G. It is essential to understand that stepping from G to G| y may have the effect of changing the content of row( y)for some y ≤ y: indeed, requests that were satisfied in G might not be satisfied anymore in G| y . Therefore, we denote by row| y( y) the value of the function row at y in the reduced compass structure G| y . A finite compass structure G based on a domain D = {0, . . . , ymax} is said to be pseudo-fulfilling if there exist two points y < y < ymax such that (i) row( y) = row( y), (cid:19) ≤ y and 0 ≤ y(cid:19)), (iii) for (cid:19) ≤ y such that ψ ∈ L(x(ii) for every 0 ≤ x ≤ y and for every ψ ∈ RI (x, y), there exists 0 ≤ x(cid:19)), and (iv) row| y( y) = row( y). The key point is that (cid:19), yevery ψ ∈ RL(x, y) there exists y < xa pseudo-fulfilling structure is self-contained, so that every existential request originated on intervals that end before or at y, are satisfied on intervals that end before or at y; notice, however, that the position of ymax plays an essential role in satisfying the last condition: even if conditions from (i) to (iii) are satisfied, a structure is pseudo-fulfilling only if, ideally, the portion of the model between y and y can be replicated infinitely often. Proving that HS3 is decidable in PSpace when interpreted over N requires three steps: first, proving that a model exists if and only if a pseudo-fulfilling structure (with ϕin the label of the interval [0, 1]) does, second, that we can effectively bound the maximum cardinality of a pseudo-fulfilling structure, and, third, that checking the existence of a pseudo-model can be done in PSpace. The first two steps are dealt with in Lemma 5 below, which is focused on the precise bound given that proving that pseudo-fulfilling structures can be converted into models is not essentially different from the proof of Lemma 4 (although a notion of periodicity is involved); as far as the third step is concerned, a simple modification of the algorithm in Fig. 4 is sufficient.(cid:19) < y such that ψ ∈ L(x(cid:19) < y(cid:19), y16E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26Lemma 5. Let ϕ be a HS3 formula satisfiable over N. Then there exists a pseudo-fulfilling structure for ϕ with domain D of cardinality 2O (|ϕ|3).Proof. Since ϕ is satisfiable over N there exists a compass structure G = (N, L) for it. We want to prove that there exists a bounded pseudo-fulfilling structure that describes it.(cid:19)(cid:19)(cid:19) > y(cid:19) ≤ y with ψ ∈ L(xwith row( y) = row( yDefinitions. Since the set of possible different row descriptions is finite, we take the smallest y ∈ N such that for every (cid:19)(cid:19)) (that is, the smallest y such that its own description repeats infinitely (cid:19) ≤ x and (cid:19)). In an identical way, (cid:19) ≤ x and (cid:19)). Observe that (cid:19) < y= row( y); so, G ymax is a pseudo-fulfilling structure (and ϕ ∈ L(0, 1)), and we have to (cid:19) ∈ N there exists yyoften). Then, we choose y > y in such a way that for every 0 ≤ x ≤ y and for every ψ ∈ S(x, y) there exists xy < ywe can also choose ymax > y as the smallest index such that 0 ≤ x ≤ y and for every ψ ∈ S(x, y) there exists xy < yrow( y)| ymaxprove that we can contract it within the given bound.(cid:19)), and for every ψ ∈ RL( y) there exists y < x(cid:19)), and for every ψ ∈ RL( y) there exists y < x= row( y) and row( y)| ymax(cid:19) ≤ ymax with ψ ∈ L(x(cid:19) ≤ ymax with ψ ∈ L(x(cid:19) ≤ y with ψ ∈ L(x(cid:19) < y(cid:19), y(cid:19), y(cid:19), y(cid:19), yContraction. Given two points ˆy, ˆy(cid:19), we defineO cc( ˆy, ˆy(cid:19)) = {ψ : there are x, y(cid:19)and ψ ∈ L(x, ysuch that 0 ≤ x ≤ ˆy < y(cid:19))}.(cid:19) < ˆy(cid:19)(cid:19), t(cid:19), t(cid:19)), if ψ ∈ L(z(cid:19) < y, then zle f t ≤ z(cid:19) ≤ zright and tdown ≤ tBy construction, O cc( y, y) = O cc( y, ymax). As in Lemma 4, we can identify, for each ψ ∈ O cc( y, y) four points (z∗, t∗) with (cid:19) < y, and ∗ ∈ {right, le f t, up, down} and ψ ∈ L(z∗, t∗), z∗ ≤ y, and t∗ ≤ y, as follows: for every (z(cid:19) ≤ tup . In other words, the points (z∗, t∗) with ∗ ∈ {right, le f t, up, down}y ≤ tare, respectively, the rightmost, leftmost, highest, and lowest witnesses of each formula in O cc( y, y). We collect all co-ordinates of the type z∗ so defined in a set V er(ψ, y, y), and all coordinates of the type t∗ in a set Hor(ψ, y, y). In a similar way, we define the sets V er(ψ, y, ymax) and Hor(ψ, y) for each ψ ∈ O cc( y, ymax). Clearly, for each ˆy, and each (cid:19))| ≤ 4. We can now identify a set V b ⊆ {x : 0 ≤ x ≤ ymax} of pair ψ, ˆy, it is the case that both |V er(ψ, ˆy, ˆyblocked verticals, which is a minimal set that satisfies the following conditions: (i) V er(ψ, y, y) ∪ V er(ψ, y, ymax) ⊆ V b for every ψ ∈ O cc( y, y); and, for every (R, L) ∈ dom(count( y)), (ii) if count( y)(R, L) < 4 · |ϕ| + 1 then |{x ∈ V b : RI L(x, y) =I L(x, y) = R and S(x, y) = L}| = count( y)(R, L), and (iii) if count( y)(R, L) ≥ 4 · |ϕ| + 1R and S(x, y) = L}| = |{x ∈ V b : RI L(x, y) = R and S(x, y) = L}| = 4 · |ϕ| + 1. Observe that then |{x ∈ V b : R(cid:19) : 0 ≤ y ≤ ymax} of blocked horizontals, which as a min-|V b| < 2 · |ϕ|(4 · |ϕ| + 1). Moreover, we can identify a set Hb ⊆ { yimal set that satisfies the following conditions: (i) Hor(ψ, y, y) ∪ rows(ψ, y, ymax) ⊆ Hb for every ψ ∈ O cc( y, y), and (ii){0, y, y, ymax} ⊆ Hb. Observe that |Hb| ≤ 2 · |ϕ| + 4. For every row 0 ≤ y ≤ ymax we can now define an additional counting function count V ( y) : RI L( y) × (cid:6) y → {1, . . . , 2 · |ϕ| · (4 · |ϕ| + 1)} such that, for every (R, L) ∈ RI L(x, y) = R and S(x, y) = L}| = |{x ∈ V b : R(cid:19))|, |Hor(ψ, ˆy, ˆyI L( y) × (cid:6) y ,(cid:19)), z(cid:19)count V ( y)(R, L) = |{x : RI L(x, y) = R and S(x, y) = L}|.(cid:19)(cid:19)(cid:19) < ˆy < ˆySimilarly to Lemma 4, we conclude that the number of possible count V ( y) functions is (2 · |ϕ|(4 · |ϕ| + 1))|ϕ|2 =|ϕ|2·log(2·|ϕ|·(4·|ϕ|+1)). Now, consider two rows 0 ≤ ˆy < ˆy(cid:19)(cid:19) < ˆy or (cid:19) < y2(cid:19) < yˆystrictly contained between two consecutive elements in Hb. or y(cid:19)), then we can directly apply Lemma 4 and obtain a smaller structure G(cid:19)If row( ˆy) = row( ˆy, (cid:19) − ˆy). which is, still, pseudo-fulling. If G ymax is based on a domain D, then G is based on a domain D(cid:19)But two rows ˆy < ˆywith the required properties are guaranteed to exist whenever the number of rows strictly contained between any two consecutive elements y(cid:19) ≤ ymax such that for every pair y, that is, consider two rows ˆy and ˆy(cid:19)) and count V ( ˆy) = count V ( ˆyin Hb is greater than or equal tosuch that |D(cid:19)| = |D| −( ˆy(cid:19)(cid:19) ∈ Hb we have y(cid:19) < y(cid:19) < y(cid:19)(cid:19)(cid:19)(cid:19)(cid:19)(cid:19)N(cid:7) = |ϕ| · 2|ϕ|·(|ϕ|·log(2·|ϕ|·(4·|ϕ|+1))+log(4·|ϕ|+1)+log(|ϕ|)+|ϕ|).We can then iterate the contraction until ystructure obtained at the end of this process has cardinality less than or equal to(cid:19) < N(cid:7) for every two consecutive elements y(cid:19)(cid:19) − y(cid:19) < y(cid:19)(cid:19). The pseudo-fulfilling |Hb| · N(cid:7) = (2 · |ϕ| + 4) · |ϕ| · 2|ϕ|·(|ϕ|·log(2·|ϕ|·(4·|ϕ|+1))+log(4·|ϕ|+1)+log(|ϕ|)+|ϕ|) = 2O (|ϕ|3),as we wanted.The pseudo-fulfilling structure obtained in this way can be now transformed into a compass structure based on the natural numbers, and therefore a model based on the natural numbers, by applying essentially the same technique already seen in Lemma 4. (cid:2)Dealing with the satisfiability of formulæ of HS3 interpreted over the set of the integers does not require any mathe-matical tool different from those used above; the notion of pseudo-fulfilling structures can be generalized to be symmetric on the interval [0, 1], and its limits suitably re-computed. Then, Lemma 5 works in the same way to prove its existence. A similar argument can be used to show that deciding the satisfiability of a formula of HS3 interpreted in the class Dis of all discrete linear orders has the same computational properties.E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2617Theorem 3. The satisfiability problem for HS3 in the case of natural numbers, in the case of the integers, and in the case of Dis isPSpace-complete.5. HS7 is undecidableIn this section we show that the satisfiability problem for HS7, interpreted in any class of linearly ordered set that contains at least one infinite order, is undecidable; all finite/discrete cases were already covered by the results in [30]. Undecidability is proven via a reduction from the so-called Octant Tiling Problem (OTP) (as, for example, in [13]). This is the problem of establishing whether a given finite set of tile types T = {τ1, . . . , τN } can tile the second octant of the integer plane O = {(n, m) ∈ Z2 : 0 ≤ n ≤ m}. For every tile type τ ∈ T , let right(τ ), le f t(τ ), up(τ ), and down(τ ) be the colors of the corresponding sides of τ . To solve the problem, one must find a function f : O → T such that right( f (n, m)) =le f t( f (n + 1, m)) and up( f (n, m)) = down( f (n, m + 1)). A simple application of König Lemma and of the Compactness Theorem for first-order logic allows one to prove that the OTP is undecidable; a similar argument is used in [11] to prove the undecidability of the Quadrant Tiling Problem.In the following we reduce the OTP to the satisfiability problem for HS7. Our construction is similar to other unde-cidability reductions for interval temporal and spatial logics [31,13], which, however, must be adapted due to the loss of expressive power of coarser operators. The reduction exploits (i) a correspondence between the points (x, y) of the octant and a suitable set of unit intervals (u-intervals from now on) labeled by the propositional letter u; (ii) propositional vari-ables to represent tiles in T ; (iii) the modal operators of HS7 to enforce the constraints of the problem. The starting point of our construction consists of building an infinite sequence of u-intervals. Let ϕuchain be the following formula:ϕuchain= u0 ∧[G](ul → (cid:3) A O (cid:4)u(l+1) mod 2)(cid:3)l=0,1∧ [G](u ↔ (u0 ∨ u1))∧ [G](u → [D B E]¬u)∧(cid:3)[G](ul → [D B E]u(cid:19)l)l=0,1∧ [G]((u(cid:19)0∧ u(cid:19)1) → ⊥).Lemma 6. Let M, [x, y] (cid:2) ϕuchain . Then, there exists an infinite increasing sequence of points y0, y1, y2, . . . such that(i) y0 = y;(ii) for each i ≥ 0, M, [ yi, yi+1] (cid:2) u;(iii) if [z, t] (cid:16)= [ yi, yi+1], for each i ≥ 0, then M, [z, t] (cid:2) ¬u, unless t ≤ x or z > yi for each i ∈ N.(8)(9)(10)(11)(12)(cid:19)0 and also M, [ y0, y] (cid:2) uProof. By hypothesis, M, [x, y] (cid:2) ϕuchain ; therefore, M, [x, y] (cid:2) u0. Because of (8) there must be an interval [ y0, y1] such that M, [ y0, y1] (cid:2) u1, and that x < y0 ≤ y. To prove (i) we suppose, for the sake of contradiction, that y0 < y. By (11) we (cid:19)obtain M, [ y0, y] (cid:2) u1, contrary to (12). Consequently, y = y0. Following the same argument and taking (9) into account, one immediately sees that ϕuchain forces the existence of a chain y = y0 < y1 < y2 . . . of u-intervals verifying (ii). Suppose now, for the sake of contradiction, that M, [z, t] (cid:2) u for some [z, t] (cid:16)= [ yi, yi+1] for all i ∈ N, where t > x and z < yi for some i ∈ N. Let us analyze all possible cases that may occur. If yi ≤ z < t ≤ yi+1 for some i ∈ N, or x ≤ z < t ≤ y0, then we have a contradiction with (10), because [z, t] is a u-interval contained (via R D B E ) in another u-interval, [ yi, yi+1] or [x, y0]. If yi ≤ z < yi+1 and t ≥ yi+k for some i, k ∈ N and k > 1, or x ≤ z < y0 and t ≥ y1, then we have, again, a violation of (10). If yi ≤ z < yi+1 and yi+1 < t < yi+2, or x ≤ z < y0 and y0 < y < y1, then, thanks to (9), either M, [z, t] (cid:2) u0 or M, [z, t] (cid:2) u1. Assume that [ yi, yi+1] is a u0-interval: in the first case, we have a contradiction with (cid:19)(12) because [ yi+1, t] is both a u1-interval, while in the second case we have a contradiction because (cid:19)[z, yi+1], in turn, is both a u1-interval. If [ yi, yi+1] is a u1-interval, then the symmetric argument applies. If t > yi for each i ∈ N, then, since by the hypothesis z < yi for some i ∈ N, we have a contradiction with (10). Finally, if z < x, then t < y0 because of (10). Thanks to (9), M, [z, t] (cid:2) u0 or M, [z, t] (cid:2) u1. In the first case, (8) ensures the existence (cid:19)of a u1-interval that will cause a conflict with the u0-interval [x, y0]. Otherwise, since x < t, the interval [x, t] satisfies u0and u(cid:19)1, which, again, is a contradiction. (cid:2)(cid:19)0-interval and a u(cid:19)0-interval and a uBy the following formula, which we call ϕube , we can easily identify those intervals that start and those that endu-intervals:ϕube= [G](u → ((cid:3)D B E(cid:4)(cid:11) ∧ [D B E]u(cid:19))∧ [G]((u(cid:19) ∧ [ A O ]¬u) → ub)(13)(14)18E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26(cid:19) ∧ [ A O ]¬u) → ue)∧ [G]((u∧ [G](ub → [ A O ]¬u)∧ [G](ue → [ A O ]¬u).(15)(16)(17)Lemma 7. Let M, [x, y] (cid:2) ϕuchainLemma 6.∧ ϕube , and let y0, y1, y2, . . . be the infinite sequence of points whose existence is guaranteed by (i) For each i ≥ 0, every interval of the form [ yi, z], where z < yi+1, satisfies ub but not ue (and there exists at least one interval of (ii) For each i ≥ 0, every interval of the form [z, yi+1], where z > yi , satisfies ue but not ub (and there exists at least one interval of this form);this form).Proof. Consider, first, a u-interval [ yi, yi+1] of the sequence, and a point z such that yi < z < yi+1. Such z exists thanks to (13). Also by (13), the interval [ yi, z] is certainly a u-interval; since, by Lemma 6, that neither [z, t] for any z < t < yi+1, (cid:19) < z, can be a u-interval, (14) applies, and [ yi, z] must be a ub-interval. Since [ yi−1, yi] is nor any [tu-interval, (17) applies, and [ yi, z] cannot be a ue -interval, proving (i). Point (ii) is proven likewise.(cid:19), t] for any yi < t(cid:19)Consider now the following formula, in which L = {∗} ∪ T (we abuse of notation and identify tile symbols with the propositional letters that represent them):ϕconf = C0 ∧(cid:3)[G](Cl → (cid:3) A O (cid:4)C(l+1) mod 2)l=0,1∧ [G](C ↔ (C0 ∨ C1))∧[G](Cl → [D B E]C(cid:3)(cid:19)l )(cid:19)0∧ Cl=0,1(cid:19)∧ [G]((C1) → ⊥)∧ [G](C → ([ A O ]¬ue ∧ [ A O ]¬ub))∧ [G](C → ([D B E]¬C ∧ (cid:3)D B E(cid:4)(cid:11)))∧ [G](u ↔(cid:5)s))∧ [G]s∈L(cid:3)s,s(cid:19)∈L,s(cid:16)=s(cid:19)(s ∧ s(cid:19) → ⊥)∧ (cid:3) A O (cid:4)(∗ ∧ (cid:3) A O (cid:4)((cid:5)τ ∧ (cid:3) A O (cid:4)∗))τ ∈T∧ [G]((u ∧ (cid:3) A O (cid:4)C) → (cid:3) A O (cid:4)∗)∧ [G]((u ∧ (cid:3) A O (cid:4)C) → (cid:3) A O (cid:4)∗)∧ [G](∗ → ((cid:3) A O (cid:4)C ∨ (cid:3) A O (cid:4)C).(18)(19)(20)(21)(22)(23)(24)(25)(26)(27)(28)(29)Lemma 8. Let M, [x, y] (cid:2) ϕuchainby Lemma 6. Then there exists an infinite sequence of indexes k0, k1, k2, . . . such that∧ ϕube∧ ϕconf , and let y0, y1, y2, . . . be the infinite sequence of points whose existence is guaranteed (i) each u-interval of the type [ yi, yi+1] satisfies precisely one letter in L;] (cid:2) C ;(ii) for each j ≥ 0, M, [ yk j , yk j+1(iii) the C -interval [ yk0 , yk1(iv) if [z, t] (cid:16)= [ yk j , yk j+1(v) each C -interval of the type [ yk j , yk j+1(vi) if [z, t] (cid:16)= [ yk j , yk j +1] and [z, t] (cid:16)= [ yk j+1−1, yk j+1] is composed of exactly three units, the middle one of which is τ ∈ T ;] for each j ≥ 0, then M, [z, t] (cid:2) ¬C , unless t ≤ x or z > yi for each i ∈ N;] is such that both its first unit [ yk j , yk j +1] and its last unit [ yk j+1−1, yk j+1] satisfy ∗;] for each j ≥ 0, then M, [z, t] (cid:2) ¬∗, unless t ≤ x or z > yi for each i ∈ N.Proof. Point (i) is an immediate consequence of (24) and (25). Since M, [x, y] (cid:2) C0 by (18), there must be an interval [z, t]such that x < z ≤ y and t > y such that M, [z, t] (cid:2) C1. Suppose, for the sake of contradiction, that z < y. By (20), we obtain (cid:19)1, contrary to (21). Therefore z = y = y0, and we set k0 = 0. Now we prove (iii), i.e., M, [z, y] (cid:2) Ct = y3 = yk1 . First, note that (22), in combination with Lemma 7, avoids that yi < t < yi+1 for any i ∈ N. Formulæ (24) and (26) imply that [ y0, y1], [ y1, y2], and [ y2, y3] are, respectively, ∗-, τ -, and ∗-intervals, for some tile τ . Therefore, t = y1(cid:19)0 and also M, [z, y] (cid:2) CE. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2619Fig. 6. A model of ϕT and its interpretation as a tiling of the second octant.contradicts (27) and t = y2 contradicts (28), because of (i); applying (29), (19), (20), and (21) to [ y2, y3], it is easy to see = y3 = t. By a similar argument, one can prove the existence of an infinite chain of that t > y3 is not possible. Then, yk1indexes k0, k1, . . . as stated in (ii) and (iv). Formulæ (27) and (28) immediately imply (v). Finally, in order to prove (vi), it suffices to observe that, first, ∗-intervals can only be units, and, second, that, thanks to (29), a ∗-interval on some interval [ yi−1, yi] for some i implies that yi−1 ends a C -interval or yi starts a C -interval. Thus, if, for the sake of contradiction, [z, t]is a ∗-interval different from the first or the last unit of a C -interval, we have a contradiction with point (iv).Given the structure built in Lemma 8, we can refer to the m-th ¬∗-interval of a level C as the m-th tile of that level, and we are therefore interested in connecting the m-th tile of a given level with the m-th tile of the next one. In particular, (cid:19)] is a Corr-interval, where Corr is a we say that the tile [z, t] is connected to the tile [zpropositional letter introduced in the following formula:(cid:19)] if and only if the interval [t, z(cid:19), tϕcorr = [G](u ∧ ¬∗ → (cid:3) A O (cid:4)Corr)∧ [G]((u ∧ ¬ ∗ ∧[ A O ]¬∗) → (cid:3) A O (cid:4)Corr)∧ [G](Corr → [ A O ]¬ue)∧ [G](Corr → [ A O ]¬ub)∧ [G](∗ → [ A O ]¬Corr)∧ [G]((u ∧ (cid:3) A O (cid:4)∗) → [ A O ]¬Corr)∧ [G](Corr → ([D B E]¬Corr ∧ [D B E]¬C∧[D B E]¬C ∧ ¬C)).(30)(31)(32)(33)(34)(35)(36)Lemma 9. Let M, [x, y] (cid:2) ϕuchainanteed by Lemma 6, and let k0, k1, k2 . . . be the infinite sequence of indexes whose existence is guaranteed by Lemma 8.∧ ϕconf ∧ ϕcorr , let y0, y1, y2, . . . be the infinite sequence of points whose existence is guar-∧ ϕube(i) For each i, j ≥ 0, if the interval [ yk j+i, yk j +i+1] is a ¬∗-interval, then the point yk j+i+1 starts a Corr-interval;(ii) For each i, j > 0, if the interval [ yk j+i+1, yk j +i+2] is a ¬∗-interval, then the point yk j+i ends a Corr-interval;(iii) If [z, t] (cid:16)= [ yi, ym] for each i, m ≥ 0, then M, [z, t] (cid:2) ¬Corr, unless t ≤ x or z > yi for each i ∈ N;(iv) For each j > 0, none of the points yk j , yk j −1, and yk j −2 finish any Corr-interval;(v) The m-th tile of every level is connected to the m-th tile of the next level, and, if the level is not the first one and m is not the index of the last tile of a level, the m-th tile is also connected to the m-th tile of the preceding level;(vi) Every level has precisely as many tiles as the preceding level plus one.Proof. Reasoning as in Lemma 7, point (i) is an immediate consequence of (30) and (33), and point (ii) is an immedi-ate consequence of (31) applied to the interval [ yk j +i, yk j +i+1]. To prove (iii), observe that (32) and (33) mandate that Corr-intervals begin and end on points of the type yi . As far as (iv) is concerned, it turns out that neither yk j or yk j −1may end a Corr-interval because of (34), and yk j−2 may not, either, because of (35). A combinatorial argument, whose cor-nerstone is (36), proves now (v) and (vi). As a matter of fact, Corr-intervals that start at a given tile cannot end within the same C -interval or after the next C -interval (thanks to (36)). But then, it is easy to observe that if the m-th tile of a certain C -interval is connected with the l-th tile (l (cid:16)= m) of the next C -interval one has a contradiction, again, with (36). Finally, thanks to (iv), the last tile of every C -interval cannot be connected to any tile of the previous C -interval, completing the argument.We complete our construction (pictured in Fig. 6) by forcing that the tiling constraints are respected. Let ϕcolor be the following formula:20E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26ϕcolor =(cid:3)τ ∈T(cid:3)τ ∈T∧[G](τ → [ A O ](Corr → (cid:3) A O (cid:4)((cid:5)τ (cid:19))))[G]((τ ∧ [ A O ]¬∗) → [ A O ](τ (cid:19)∈T ,up(τ )=down(τ (cid:19))τ (cid:19)(cid:5))).τ (cid:19)∈T ,right(τ )=le f t(τ (cid:19))(37)(38)Lemma 10. The satisfiability problem for HS7 interpreted over any class of linear frames that contains at least one infinitely ascending order can be reduced to the OTP.Proof. Let T be an instance of the OTP, and letϕT = ϕuchain∧ ϕube∧ ϕconf ∧ ϕcorr ∧ ϕcolor.Suppose, first, that M, [x, y] (cid:2) ϕT , where M is a model whose frame belongs to the class of linear frames. By Lemma 8, the point y = y0 starts a first level of three units, containing precisely one tile. By Lemma 9, each successive level contains precisely one more tile than the preceding one, and, by (37) and (38), each m-th tile respects the horizontal constraint with the m + 1-th tile (if exists), and the vertical constraint with the m-th tile of the successive level. Therefore, M represents a correct tiling of the second octant, and, in summary, the fact that ϕT is satisfiable (for a given set of tiles T ) implies that the OTP has a solution (for that specific set T ). On the contrary, given a solution to the OTP, it is immediate to build a model for ϕT by simply placing every tile in its correct position on each level, and suitably filling up the model with the evaluation of ∗, C , and Corr. In other words, for a given set T , T tiles the second octant if and only if ϕT is satisfiable. (cid:2)Theorem 4. The satisfiability problem for HS7 interpreted in the class Fin, Dis, N, Z, Q, R, and Lin, is undecidable.Proof. The class of all finite linear orders is covered by [30]. By Lemma 10, the satisfiability problem for HS7 in every other case can be reduced to the OTP, and therefore it is undecidable as well. (cid:2)6. Experimental resultsThe results of Section 4 imply that we can implement a relatively efficient finite satisfiability checker for HS3. In this section, we describe the data structures, the implementation strategies, and the policies we have used; most of the ideas can be also used to implement a satisfiability checker for the case of natural numbers, and, in general, for the discrete case.Implemented decision procedures for interval temporal logics are not common in the literature. Among the few ex-ceptions, a procedure for the fragment A of HS has been implemented in [16,23]; the former is an experimental imple-mentation not aimed to computational efficiency, and the latter is an attempt to use an automatic tableaux generator, namely MetTeL2 [43]. The only previous attempt to apply a generic theorem prover to an interval temporal logic can be found in [18], where a tableau-based decision procedure for the fragment D, interpreted over dense linear orders, was de-veloped in LoTREC [24]. Unfortunately, there are no benchmark problems for satisfiability of interval logic formulæ, which makes it difficult to compare different implementations.6.1. ImplementationWe have chosen to develop a semantic tableau satisfiability checker for HS3. Both the tableau and the formula to be checked are represented as rooted decorated trees. A rooted tree is a tree G = (V , E, r), where V is a nonempty set, E ⊆V × V , |E| = |V | − 1, and r ∈ V is its root; every element of V is called a node. A rooted decorated tree [27] is a rooted tree enriched with a function that associates every node with its decoration, which can be thought of as the information carried by that node: when we represent formulæ, a decoration is a propositional letter or an operator, while when we represent semantic tableaux, a decoration consists of the information needed to expand the tableau or to close it. In any (rooted decorated) tree, nodes without successors are called leaves, and every finite path from the root to a leaf is called a branch.Formulæ are represented as binary rooted decorated trees. Each node of the tree is decorated with a code that represents a Boolean or a modal operator or a propositional letter. Formulæ are read and contextually represented as trees; a simple recursive procedure eliminates all implications and pushes all negations in front of propositional letters, obtaining equivalent formulæ in negated normal form. Moreover, before checking its satisfiability, our procedure transforms a formula ϕ into the formula ϕ ∨ (cid:3)L(cid:4)ϕ ∨ (cid:3)I(cid:4)ϕ, whose initial satisfiability is checked (see Section 4).A tableau is represented as a k-ary tree in the form of left-child right-sibling. Each node of this tree contains a pointer to the node in the formula tree that represents the sub-formula under analysis, the interval over which it holds, an active/in-active flag, a leaf/internal flag, and the pointers to the left child, the right sibling, and the parent. Domains are represented as totally ordered sets of floating point numbers, so that an interval is a pair of floats. This has a very specific purpose: whenever a new point must be added in between a pair of already existing ones, it can be created by simply computing their average; yet, the model remains always finite by construction. Some tableau nodes are leaves during the construction E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2621Table 2Expansion rules of the semantic tableau-based procedure.ψ ∨ τ , [x, y], Dψ, [x, y], D | τ , [x, y], D(cid:3) X(cid:4)ψ, [x, y], Dψ, [x1, y1], D1 | . . . | ψ, [xn, yn], Dn[ X]ψ, [x, y], Dψ, [x1, y1], Dψ, [x2, y2], D. . .ψ, [xm, ym], Dψ ∧ τ , [x, y], Dψ, [x, y], Dτ , [x, y], D⎧⎨⎩(cid:10)wherewheren = ν♦( X, [x, y], D)Di = μ♦(i, X, [x, y], D)[x j , y j ] = λ♦( j, X, [x, y], D)m = ν(cid:2)( X, [x, y], D)[x j , y j ] = λ(cid:2)( j, X, [x, y], D)of the tableau; they (temporally) represent their branch, so that they also store domain information, plus other data that help us choosing the next branch depending on the expansion policy.In addition to the two trees (a formula tree and a tableau tree – the former is fixed during the satisfiability checking process of a given formula, the latter evolves), there are additional data structures that help us to apply the tableau ex-pansion rules. In particular, the collection of all current leaves is stored in a linked list. Each element of the list points to the tableau node that represents that leaf (and therefore its branch) which may be chosen in the next expansion step. A non-trivial adaptation of a generic tree visit algorithm must be implemented in order to correctly identify, given a tableau node, the set of all and only those leaves that belong to the sub-tree rooted at it. Finally, a dynamic data structure is built (and destroyed) before each expansion step that allows us to examine the branch on which the next to-be-expanded tableau node lies, in order to establish if the branch is closed (because it is contradictory), or it represents a model (in which case the procedure stops and returns that the given formula is satisfiable). Such a structure may be thought of as a hash table that contains the intervals and the formulæ that are (currently) true on them, with an efficient (constant time) lookup method.The initial tableau for a formula ϕ whose initial satisfiability must be checked is a tableau tree composed of a single tableau node with the following decoration: its formula node pointer has the address of the root of the formula tree that represents ϕ, its interval is [0, 1], its active flag and its leaf flag are both 1, its domain is {0, 1}, and all the other pointers are null. Given a leaf of the current tableau (that is, the branch represented by it), the following two operations are performed: (i) branch closing checking and branch model checking, and (ii) choosing the next to-be-expanded tableau node. Assuming that the current branch B is not closed and is not a model, the next to-be-expanded tableau node is chosen according to the following policy: it is the active node on B that is closest to the root. Expansion rules are described in Table 2. Boolean rules are standard, while the rules for modal operators are designed as follows. Let I be the set of all intervals in any finite domain. As for the existential cases, we define a functionν♦ : {I, L, L} × I × Fin → N,with the following meaning. Given an interval [x, y] and a domain D, ν♦( X, [x, y], D) returns the number of already existing different intervals in the relation R X with [x, y] plus the number of new intervals that should be created in the relation R X in order to explore all qualitatively distinct possibilities. For example, ν♦(L, [0, 1], {0, 1, 2}) = 5: indeed, if (cid:3)L(cid:4)ψ holds on [0, 1] and the current domain is {0, 1, 2}, then ψ may hold on some interval [1.25, 1.75], [1.5, 2], [2, 2.5], [3, 4], or [1.5, 2.5]. Notice that, for example, adding [1.25, 1.75] is necessary as it represents a new interval completely between existing points; something similar happens for [3, 4], because (cid:3)L(cid:4)ψ holding on [0, 1] may be satisfied by a new interval starting after the point 2. Similarly, as for the universal case, we define a function ν(cid:2), with the same parameters, that returns only the number of already existing different intervals in the relation R X with [x, y] (indeed, in order to expand a universal modality, no new intervals are created). Moreover, expanding an existential modality may require that some branch have a new (bigger) domain (because, as we have seen above, existential modalities may require new points); the i-th domain (in no particular order) is returned by the functionμ♦ : N × {I, L, L} × I × Fin → Fin.Finally, while expanding any existential modality, every new node in a branch is decorated with an interval that belongs to the (possibly new) domain. The j-th interval (in no particular order) of the expansion is returned by the functionλ♦ : N × {I, L, L} × I × Fin → I.Following up with the previous example, μ♦(1, L, [0, 1], {0, 1, 2}) = {0, 1, 1.25, 1.75, 2} and λ♦(1, L, [0, 1], {0, 1, 2}) =[1.25, 1.75]. Because we are restricting ourselves to initial satisfiability, these functions never return domains or intervals with new points between 0 and 1, nor smaller than 0. In this way for each existential operator (cid:3) X(cid:4)ψ we have an existential disjunctive rule that creates enough branches to search for every possible location of ψ . Universal operators are easier to 22E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26treat: given the current interval and the current domain, we use the function λ(cid:2), analogous to the previous one, to obtain all intervals on which a formula must be applied, and since universal operators do not add points to the domain, the latter, as we have already observed, does not change.Given the node to be expanded, the correct rule is chosen for its expansion (clearly, precisely one rule can be applied on it); the result of such a step is applied to all leaves in the sub-tree rooted at the chosen node. For efficiency reasons, dec-orations are never duplicated. A given branch B, identified by its leaf, is closed if one of the following two conditions hold: a propositional contradiction is found on it, that is, there exist two nodes on B such that their decorations show p, [x, y]and ¬p, [x, y], respectively, or the cardinality of the domain in the decoration of its leaf exceeds the bound (see Lemma 4). When a given leaf is selected for the next expansion step, the branch that contains it is checked for contradictions. If a contradiction is found, the leaf is simply eliminated from the list of leaves; if all leaves are eliminated, then the formula is found unsatisfiable. Otherwise, the node is expanded and the protocol for managing active/inactive flags, after every expan-sion, is as follows: nodes are inactivated after being expanded, but in case of universal nodes, they are copied at the end of the branch with the active flag at 1. Therefore, the current branch B is a model if and only if, for every active node on B, that node is universal, and, if D is in the decoration of its leaf, then, for every [ X]ψ, [x, y] in the decoration of some node of B there exists a node with ψ, [x j, y j] in B, for every 1 ≤ j ≤ ν(cid:2)( X, [x, y], D).The soundness and the completeness of our procedure are shown in the following result.Theorem 5. A formula ϕ of HS3 is finitely satisfiable if and only if the tableau-based method, with the rules in Table 2, returns ‘Satisfiable’.Proof. Let us introduce first the following notion. Consider a node n on a tableau for a formula ϕ, and let S(n) be the set of all decorations on nodes between n and the root. We denote with D(n) the domain in the decoration of n. We say that S(n) is satisfied on an extension of D(n) if there exists a model M based on some extension of D(n) such that, for each (ψ, [x, y]) ∈ S(n) it is the case that M, [x, y] (cid:2) ψ .We now show that for every finitely satisfiable formula of HS3 the presented method terminates and returns ‘Satisfiable’, that is, contra-positively, whenever the procedure closes all branches, the formula is not finitely satisfiable. To do so, we prove a stronger claim: for any node n at height h on a tableau for ϕ, if every branch that contains n is closed, then of D(n) such that |D(cid:19)| ≤ L I M (where L I M is the maximum number of points S(n) is not satisfied on any extension D(cid:19)on a domain as shown in Lemma 4). Notice that, when n is the root, this is to say that ϕ is not finitely satisfiable. We proceed now to prove the claim by induction. If h = 0, either the only branch that contains n also contains two nodes with decorations (p, [x, y]) and (¬p, [x, y]), and therefore S(n) is simply not satisfiable, or the number of points ever named in the decorations of its nodes is more than L I M, for which S(n) can never be satisfied on any extension of D(n). If h > 0, then n has been expanded by some rule, some nodes n1, n2, . . . exist that are descendants of n, and the inductive hypothesis applies to all of them. If the rule that has been applied is Boolean, then the claim follows immediately. If it is the universal rule, then suppose that ([ X]ψ, [x, y]) is in the decoration of n. Every branch that contains n also contains all nodes that (cid:19)with decoration (ψ, [z, t]) for some interval [z, t] such that are the result of its expansion, and, in particular, some node n(cid:19)) would be too, [x, y]R X [z, t]. If S(n) were satisfiable on some extension of D(n), then, in particular, S(n) ∪ {(ψ, [z, t])} = S(nbut this is in contradiction with the inductive hypothesis. Finally, if it is the existential rule, then suppose that ((cid:3) X(cid:4)ψ, [x, y])is in the decoration of n. If S(n) were satisfiable on some extension of D(n), then there would be a model whose domain extends D(n) such that it satisfies (cid:3) X(cid:4)ψ on [x, y] and ψ on some [z, t] such that [x, y]R X [z, t]. By construction, there must of n that contains the decoration (ψ, [z, t]), independently of z, t being already in D(n). This means be some successor nthat S(n(cid:19)), which is in contradiction with the inductive hypothesis.(cid:19)) would be satisfiable on some extension of D(n(cid:19)Now, we must argue that our method is also sound, that is, for every formula ϕ of HS3 for which it returns ‘Satisfiable’, there exists a model M such that M, [0, 1] (cid:2) ϕ. Consider a branch B such that it is not contradictory, all its active nodes are universal, and every node with universal decoration has been already expanded on every possible interval of the domain D of the branch. Now, let M be a model based on D, and whose valuation function is defined as follows: for each interval [x, y] and each propositional letter p, [x, y] ∈ V (p) if and only if (p, [x, y]) decorates some node on B. We want to prove, by structural induction, that, for each node n in B with decoration (ψ, [x, y]), M, [x, y] (cid:2) ψ . If ψ is a propositional letter or its negation, we have the result immediately. If ψ is a composite formula, two cases arise: either it is a universal formula, or it is not. In the latter case, the fact that B is not closed implies that n has been expanded, and such expansion has been applied to all branches that contain n: if ψ is a conjunction, then both conjuncts have been included as decorations in nodes of B, if it is a disjunction then at least one disjunct has been included as decoration in some node of B, and, if it is ψ = (cid:3) X(cid:4)ξ , then at least one node in B must be decorated with (ξ, [z, t]), for some [z, t] such that [x, y]R X [z, t]. In all cases, the inductive hypothesis applies, and therefore M must satisfy ψ on [x, y]. In the former case, if ψ is a universal formula, i.e. ψ = [ X]ξ , since B cannot be further extended, it must be the case that a node nwith decoration (ξ, [z, t]) occurs in Bfor each [z, t] such that z, t ∈ D and that [x, y]R X [z, t], and again, the inductive hypothesis applies. (cid:2)(cid:19)6.2. Benchmark and experimental resultsOur procedure is programmed object-oriented in C++ standard language with threads capabilities. Threads are run vir-tually in parallel, and carry a specific policy for choosing the next leaf to be examined. Each policy is fair, that is, every E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2623Table 3A benchmark for (finitely) satisfiable formulæ of HS3.Finitely satisfiablenameϕ1ϕ3ϕ5. . .formulap0 ∧ [I]¬p2 ∧ [L]¬p2 ∧ (cid:3)L(cid:4)p1 ∧ [L](p1 → ([I]¬p3 ∧ [L]¬p3 ∧ (cid:3)L(cid:4)p2))p0 ∧ [I]¬p2 ∧ [L]¬p2 ∧ (cid:3)L(cid:4)p1 ∧ [L](p1 → ([I]¬p3 ∧ [L]¬p3 ∧ (cid:3)L(cid:4)ϕ+2p0 ∧ [I]¬p2 ∧ [L]¬p2 ∧ (cid:3)L(cid:4)p1 ∧ [L](p1 → ([I]¬p3 ∧ [L]¬p3 ∧ (cid:3)L(cid:4)ϕ+2. . .1 ))3 ))Fig. 7. Example of a possible model for ϕ1 from Table 3.branch is eventually examined; the advantage of using different policies is the improved execution time, especially for sat-isfiable formulæ. We took into account two key aspects: domain cardinality and branch sparseness. The sparseness degree of a branch allows us to estimate how many distinct intervals in the domain are actually used; to compute such an esti-mation, we calculate the average of positive propositional letters assigned to each interval, and define the sparseness of the branch as the variance of the distribution associated to assigning positive propositional letters to intervals. We implemented the following policies: (i) branches with smaller domain and less sparse first (SBF); (ii) branches with longer domain and more sparse first (LBF); (iii) branches in Last-In-First-Out order (LIFO) – that is, the tableau tree is explored depth-first. All experiments have been carried out on an Intel(R) Core(TM) i7-6700HQ, with a clock of 2.60 GHz, four cores, and 16 GBRAM.Robustness and scalability. In order to test the robustness and the scalability of our implementation, we designed the sequence of finitely satisfiable formulæ shown in Table 3, which are systematically generated for k = 1, 3, 5, . . ., so that their length can be put in relation with the time that our program takes to establish its satisfiability. Formulæ are generated inductively: given ϕk, we obtain ϕ+2, we generate ϕk+2; each ϕk is finitely satisfiable and it has only few different models. More importantly, the formulæ ϕk grow in length and in modal depth; following [9], length, modal depth, and number of different models are three of the most important indicators to measure the experimental difficulty of proving the satisfiability of a formula. The results of our scalability experiment are shown in Fig. 8.by replacing each propositional letter pi with pi+2, and, from ϕ+2kkFor the sake of clarity, Fig. 7 shows a four points model of ϕ1 (from Table 3), as returned by our algorithm. In Fig. 7, on the left-hand side, we consider a sub-formula of ϕ1 and, correspondingly, on the right-hand side, we show how the considered sub-formula is, in fact, satisfied in the model. Observe that, in line with classical tableau-based algorithms, only necessary requests are shown: for example, there is no obligatory truth value for p1 on [0, 1] because ϕ1 does not require it. Moreover, trivially satisfied sub-formulas are not shown: for instance, on [0, 1], the sub-formula [L]¬p2 is satisfied by the fact that 0 is the first point of the model.Semi-randomized test. In order to test our implementation in a more realistic scenario, we need formulæ whose satisfi-ability status is not fixed. Purely random formulæ are not necessarily challenging for a satisfiability tester: as a matter of fact, random formulæ tend to be satisfiable, often admitting several different models. Moreover, testing the scalability of the system using only unsatisfiable formulæ of increasing length is not appropriate, as the effort needed to prove that a 24E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26Fig. 8. Elapsed time for satisfiable formulæ (by length and modal depth).Fig. 9. Timeouts versus number of finalized formulæ.formula is unsatisfiable depends on many aspects besides its length, such as, for example, the depth (in the tableau) at which a contradiction is found. Therefore, we proceeded as follows.First, we designed a simple technique to systematically generate scalable unsatisfiable formulæ. To this end, we listed a certain number of propositional tautologies, such as(p ∧ (p → q)) → q,(p ∧ q) → p,(p → (p ∨ q)),as well as a certain number of modal tautologies of HS3, such as(cid:3)L(cid:4)(cid:3)L(cid:4)p → (cid:3)L(cid:4)p, (cid:3)L(cid:4)p → [L](cid:3)L(cid:4)p.Then, we systematically applied several cycles of uniform substitution to our initial group of tautologies, obtaining longer ones. Once we were satisfied of the average length of the resulting formulæ (around 150 symbols each), we negated them, obtaining unsatisfiable formulæ.Second, we designed a simple method to generate randomized formulæ of controllable length, over an alphabet AP of propositional letters, by employing a very intuitive schema that recursively produces a formula tree: given the current height h, we randomly choose a Boolean or a modal operator (with probability directly proportional to h), or a propositional letter in the alphabet (with probability inversely proportional to h), and perform one (or two, depending on the case) recursive call(s) with height h − 1. It may be argued that such procedure does not guarantee that the obtained formula has a specificlength; it does, however, guarantee that all formulæ generated with it are, on average, of the same length, and we can suitably modulate the initial value of h to obtain formulæ that tend to be of the desired length. Modulating the proportion between h and |AP | gives us some control on the probability that the generated formula is indeed satisfiable (following the same principles as in [25]).Finally, we created a database of 5000 formulæ, of comparable length, that contains formulæ from both groups, on a proportion 40% (the former, certainly unsatisfiable) and 60% (the latter, probably satisfiable).We tested our procedure against this problem in order to establish which fraction of the entire group could be solved under different timeout settings, from 5 to 30 seconds. The results of these experiments are depicted in Fig. 9. As it can be seen, a timeout of 15 seconds was enough to establish the satisfiability of over the 97% of our tested formulæ.7. ConclusionsIn this paper we studied two previously unknown variants of Halpern and Shoham’s logic (HS), inspired by Golumbic and Shamir’s interval algebras, which generalize the classical Allen’s Interval Algebra with coarser interval relations. While the finer HS7 is still generally undecidable, the coarser HS3 becomes PSpace-complete in the finite case, the case of the natural numbers, and the integers, and PSpace-hard in the other cases. A summary of the known results on coarser interval temporal logics can be found in Table 4. Undecidability of HS in the finite case can be proven as in [28], although the E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–2625Table 4A summary of the results of this paper.ClassFin, N, Z, DisLin, QHSHS7Undec. [28]Undec. [28]Undec. [30]Undec.HS3PSpace-completePSpace-hardauthors do not mention this particular case; many of the stricter undecidability results for fragments of HS such as, for example, those in [12], actually imply that HS is undecidable in this case as well. Fragments of HS have been extensively studied in the recent literature; unfortunately, there is no natural comparison between coarser fragments (such as HS3and HS7) and syntactical fragments of HS. The latter have been systematically analyzed both from the relative expressive power [1] and from the computational complexity point of view [14,15].There are a number of open problems and interesting research directions in this topic. Besides the natural interest in completing the picture of the decidability and the complexity of the satisfiability problem for coarser interval temporal logics, there are obvious questions that arise from our results. For example, it has been proved that in the finite/discrete case the fragment LL is NP-complete [14], which means that there may exist natural and useful logics expressively in between LL and HS3. Moreover, there exists a recently emerged interest in interval temporal logic under sub-propositional restrictions [20,7,19], and it makes sense to explore a logic such as HS3 under similar restrictions.AcknowledgementsThis work was partially supported by the project TIN15-70266-C2-P-1 (E. Muñoz-Velasco), founded by the Spanish Min-istry of Science, the PhD grant FPU15/05883 (M. Pelegrín), founded by Spanish Ministry of Education, and by the project Formal Methods for Verification and Synthesis of Discrete and Hybrid Systems (P. Sala and G. Sciavicco), founded by the Italian INDAM GNCS.Appendix A. Supplementary materialSupplementary material related to this article can be found online at https://doi .org /10 .1016 /j .artint .2018 .09 .001.References[1] L. Aceto, D. Della Monica, V. Goranko, A. Ingólfsdóttir, A. Montanari, G. Sciavicco, A complete classification of the expressiveness of interval logics of Allen’s relations: the general and the dense cases, Acta Inform. 53 (3) (2016) 207–246.[2] J.F. Allen, Maintaining knowledge about temporal intervals, Commun. ACM 26 (11) (1983) 832–843.[3] R. Alluhaibi, Simple interval temporal logic for natural language assertion descriptions, in: Proc. of the 11th International Conference on Computational [4] A. Artale, D. Bresolin, A. Montanari, V. Ryzhikov, G. Sciavicco, DL-Lite and interval temporal logics: a marriage proposal, in: Proc. of the 21st European Semantics, IWCS, 2015, pp. 283–293.Conference of Artificial Intelligence, ECAI, 2014, pp. 957–958.[5] A. Artale, E. Franconi, A temporal description logic for reasoning about actions and plans, J. Artif. Intell. Reason. 9 (1998) 463–506.[6] A. Artale, R. Kontchakov, V. Ryzhikov, M. Zakharyaschev, A cookbook for temporal conceptual data modelling with description logics, ACM Trans. Comput. Log. 15 (3) (2014) 25:1–25:50.[7] A. Artale, R. Kontchakov, V. Ryzhikov, M. Zakharyaschev, Tractable interval temporal propositional and description logics, in: Proc. of the 29th AAAI Conference on Artificial Intelligence, AAAI, 2015, pp. 1417–1423.[8] R.A. Baeza-Yates, Challenges in the interaction of information retrieval and natural language processing, in: Proc. of the 5th International on Computa-tional Linguistics and Intelligent Text Processing, CICLing, 2004, pp. 445–456.[9] P. Balsiger, A. Heuerding, S. Schwendimann, A benchmark method for the propositional modal logics K, KT, S4, J. Autom. Reason. 24 (3) (2000) 297–317.[10] C. Bettini, Time-dependent concepts: representation and reasoning using temporal description logics, Data Knowl. Eng. 22 (1) (1997) 1–38.[11] E. Börger, E. Grädel, Y. Gurevich, The Classical Decision Problem, Perspectives of Mathematical Logic, Springer, 1997.[12] D. Bresolin, D. Della Monica, V. Goranko, A. Montanari, G. Sciavicco, Decidable and undecidable fragments of Halpern and Shoham’s interval temporal logic: towards a complete classification, in: Proc. of the 15th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning, LPAR, in: Lect. Notes Comput. Sci., vol. 5330, Springer, 2008, pp. 590–604.[13] D. Bresolin, D. Della Monica, V. Goranko, A. Montanari, G. Sciavicco, The dark side of interval temporal logic: marking the undecidability border, Ann. [14] D. Bresolin, D. Della Monica, A. Montanari, P. Sala, G. Sciavicco, Interval temporal logics over strongly discrete linear orders: expressiveness and Math. Artif. Intell. 71 (1–3) (2014) 41–83.complexity, Theor. Comput. Sci. 560 (2014) 269–291.[15] D. Bresolin, D. Della Monica, A. Montanari, P. Sala, G. Sciavicco, On the complexity of fragments of the modal logic of Allen’s relations over dense structures, in: Proc. of the 9th International Conference on Language and Automata Theory and Applications, LATA, in: Lect. Notes Comput. Sci., vol. 8977, Springer, 2015, pp. 511–523.[16] D. Bresolin, D. Della Monica, A. Montanari, G. Sciavicco, A tableau system for right propositional neighborhood logic over finite linear orders: an implementation, in: Proc. of the 22nd International Conference on Automated Reasoning with Analytic Tableaux and Related Methods, TABLEAUX, in: Lect. Notes Comput. Sci., vol. 8123, 2013, pp. 74–80.[17] D. Bresolin, D. Della Monica, A. Montanari, G. Sciavicco, The light side of interval temporal logic: the Bernays–Schönfinkel fragment of CDT, Ann. Math. Artif. Intell. 71 (1–3) (2014) 11–39.[18] D. Bresolin, V. Goranko, A. Montanari, P. Sala, Tableaux for logics of subinterval structures over dense orderings, J. Log. Comput. 20 (1) (2010) 133–166.[19] D. Bresolin, A. Kurucz, E. Muñoz-Velasco, V. Ryzhikov, G. Sciavicco, M. Zakharyaschev, Horn fragments of the Halpern–Shoham interval temporal logic, ACM Trans. Comput. Log. 18 (3) (2017) 22:1–22:39.26E. Muñoz-Velasco et al. / Artificial Intelligence 266 (2019) 1–26[20] D. Bresolin, E. Muñoz-Velasco, G. Sciavicco, Sub-propositional fragments of the interval temporal logic of Allen’s relations, in: Proc. of the 14th European Conference on Logics in Artificial Intelligence, JELIA, in: Lect. Notes Comput. Sci., vol. 8761, Springer, 2014, pp. 122–136.[21] Z. Chaochen, M.R. Hansen, Duration Calculus: A Formal Approach to Real-Time Systems, EATCS: Monographs in Theoretical Computer Science, Springer, 2004.[22] J. Chomicki, D. Toman, Temporal logic in information systems, in: Logics for Databases and Information Systems, 1998, pp. 31–70.[23] D. Della Monica, A. Montanari, G. Sciavicco, D. Tishkovsky, First steps towards automated synthesis of tableau systems for interval temporal logics, in: Proc. of the 5th International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking, COMPUTATION TOOLS, 2014, pp. 32–37.[24] L. Fariñas del Cerro, D. Fauthoux, O. Gasquet, A. Herzig, D. Longin, F. Massacci, Lotrec: the generic tableau prover for modal and description logics, in: Proc. of the 1st International Joint Conference on Automated Reasoning, IJCAR, 2001, pp. 453–458.[25] I.P. Gent, T. Walsh, The SAT phase transition, in: Proc. of the 11th European Conference on Artificial Intelligence, ECAI, 1994, pp. 105–109.[26] M.C. Golumbic, R. Shamir, Complexity and algorithms for reasoning about time: a graph-theoretic approach, J. ACM 40 (5) (1993) 1108–1133.[27] V. Goranko, A. Montanari, G. Sciavicco, Propositional interval neighborhood temporal logics, J. Univers. Comput. Sci. 9 (9) (2003) 1137–1167.[28] J. Halpern, Y. Shoham, A propositional modal logic of time intervals, J. ACM 38 (4) (1991) 935–962.[29] S. Klarman, Practical querying of temporal data via OWL 2 QL and SQL:2011, in: Proc. of the 19th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning, LPAR, in: EPiC Series, vol. 26, Center for Artificial Intelligence Research, 2014, pp. 52–61.[30] J. Marcinkowski, J. Michaliszyn, The undecidability of the logic of subintervals, Fundam. Inform. 131 (2) (2014) 217–240.[31] M. Marx, M. Reynolds, Undecidability of compass logic, J. Log. Comput. 9 (6) (1999) 897–914.[32] A. Molinari, A. Montanari, A. Murano, G. Perelli, A. Peron, Checking interval properties of computations, Acta Inform. 53 (6–8) (2016) 587–619.[33] A. Montanari, I. Pratt-Hartmann, P. Sala, Decidability of the logics of the reflexive sub-interval and super-interval relations over finite linear orders, in: Proc. of the 17th International Symposium on Temporal Representation and Reasoning, TIME, IEEE Computer Society, 2010, pp. 27–34.[34] A. Montanari, G. Puppis, P. Sala, Maximal decidable fragments of Halpern and Shoham’s modal logic of intervals, in: Proc. of the 37th International Colloquium on Automata, Languages and Programming – Part II, ICALP, in: Lect. Notes Comput. Sci., vol. 6199, Springer, 2010, pp. 345–356.[35] A. Montanari, G. Puppis, P. Sala, A decidable weakening of compass logic based on cone-shaped cardinal directions, Log. Methods Comput. Sci. 11 (4) (2015).[36] A. Montanari, G. Puppis, P. Sala, G. Sciavicco, Decidability of the interval temporal logic A B ¯B on natural numbers, in: Proc. of the 27th Symposium on Theoretical Aspects of Computer Science, STACS, Inria Nancy Grand Est & Loria, 2010, pp. 597–608.[37] A. Montanari, G. Sciavicco, N. Vitacolonna, Decidability of interval temporal logics over split-frames via granularity, in: Proc. of the 8th European Conference on Logics in Artificial Intelligence, JELIA, in: Lect. Notes Artif. Intell., vol. 2424, Springer, 2002, pp. 259–270.[38] B. Moszkowski, Reasoning About Digital Circuits, PhD thesis, Dept. of Computer Science, Stanford University, Stanford, CA, 1983.[39] C.M. Papadimitriou, Computational Complexity, Addison-Wesley Longman Publishing Co., Inc., 1994.[40] I. Pratt-Hartmann, Temporal prepositions and their logic, Artif. Intell. 166 (1–2) (2005) 1–36.[41] A. Schmiedel, Temporal terminological logic, in: Proc. of the 8th National Conference on Artificial Intelligence, AAAI, AAAI Press, 1990, pp. 640–645.[42] L.J. Stockmeyer, A.R. Meyer, Word problems requiring exponential time (Preliminary Report), in: Proc. of the 5th Annual ACM Symposium on Theory of [43] D. Tishkovsky, R.A. Schmidt, M. Khodadadi, The tableau prover generator MetTeL2, in: Proc. of the 13th European Conference on Logics in Artificial Computing, STOC, ACM, 1973, pp. 1–9.Intelligence, JELIA, 2012, pp. 492–495.[44] Y. Venema, Expressiveness and completeness of an interval tense logic, Notre Dame J. Form. Log. 31 (4) (1990) 529–547.[45] F. Zemke, What’s new in SQL:2011, SIGMOD Rec. 41 (1) (2012) 67–73.