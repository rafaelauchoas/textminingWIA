Artificial Intelligence 220 (2015) 64–103Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintBackdoors to tractable answer set programming ✩Johannes Klaus Fichte a,b, Stefan Szeider a,∗a Vienna University of Technology, Favoritenstrasse 9-11, 1040 Vienna, Austriab University of Potsdam, August-Bebel-Strasse 89, 14482 Potsdam, Germanya r t i c l e i n f oa b s t r a c tArticle history:Received 7 March 2014Received in revised form 1 December 2014Accepted 6 December 2014Available online 15 December 2014Keywords:Answer set programmingBackdoorsComputational complexityParameterized complexityKernelizationAnswer Set Programming (ASP) is an increasingly popular framework for declarative programming that admits the description of problems by means of rules and constraints that form a disjunctive logic program. In particular, many AI problems such as reasoning in a nonmonotonic setting can be directly formulated in ASP. Although the main problems of ASP are of high computational complexity, complete for the second level of the Polynomial Hierarchy, several restrictions of ASP have been identified in the literature, under which ASP problems become tractable.In this paper we use the concept of backdoors to identify new restrictions that make ASP problems tractable. Small backdoors are sets of atoms that represent “clever reasoning shortcuts” through the search space and represent a hidden structure in the problem input. The concept of backdoors is widely used in theoretical investigations in the areas of propositional satisfiability and constraint satisfaction. We show that it can be fruitfully adapted to ASP. We demonstrate how backdoors can serve as a unifying framework that accommodates several tractable restrictions of ASP known from the literature. Furthermore, we show how backdoors allow us to deploy recent algorithmic results from parameterized complexity theory to the domain of answer set programming.© 2015 Elsevier B.V. All rights reserved.1. IntroductionAnswer Set Programming (ASP) is an increasingly popular framework for declarative programming [115,122]. ASP admits the description of problems by means of rules and constraints that form a disjunctive logic program. Solutions to the program are so-called stable models or answer sets. Many important problems of AI and reasoning can be succinctly repre-sented and successfully solved within the ASP framework. It has been applied to several large industrial applications, e.g., social networks [97], match making [74], planning in a seaport [129], optimization of packaging of Linux distributions [69], and general game playing [145].The main computational problems for ASP (such as deciding whether a program has a solution, or whether a certain atom is contained in at least one or in all solutions) are complete for the second level of the Polynomial Hierarchy [41]; thus, ASP problems are “harder than NP” and have a higher worst-case complexity than CSP and SAT. In the literature, several restrictions have been identified that make ASP tractable, most prominently the Horn fragment and the stratified fragment [78,2], for a detailed trichotomy (tractable, first level, second level of PH) see [148].Fichte and Szeider’s research was supported by the European Research Council, grant reference 239962 (COMPLEX REASON). Fichte’s research was ✩partially supported by the Austrian Science Fund (FWF) project Y698.* Corresponding author.E-mail addresses: fichte@kr.tuwien.ac.at (J.K. Fichte), stefan@szeider.net (S. Szeider).http://dx.doi.org/10.1016/j.artint.2014.12.0010004-3702/© 2015 Elsevier B.V. All rights reserved.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103651.1. ContributionIn this paper we use the concept of backdoors to identify new restrictions that make propositional ASP problems tractable. Small backdoors are sets of atoms that represent “clever reasoning shortcuts” through the search space and represent a hidden structure in the problem input. Backdoors were originally introduced by Williams, Gomes, and Selman [152,153] as a tool to analyze the behavior of DPLL-based SAT solvers. Backdoors have been widely used in theoretical investigations in the area of propositional satisfiability [152,135,138,103] and constraint satisfaction [84], and also for abductive reasoning [125], argumentation [40], and quantified Boolean formulas [137]. A backdoor is defined with respect to some fixed target class for which the computational problem under consideration is polynomial-time tractable. The size of the backdoor can be seen as a distance measure that indicates how far the instance is from the target class.In this paper we develop a rigorous theory of backdoors for answer set programming. We show that the concept of backdoors can be fruitfully adapted for this setting, and that backdoors can serve as a unifying framework that accommodates several tractable restrictions of propositional ASP known from the literature.For a worst-case complexity analysis of various problems involving backdoors such as finding a small backdoor or using it to solve the problem, it is crucial to investigate how the running time depends on the size of the backdoor, and how well running time scales with backdoor size. Parameterized Complexity [35,55,85] provides a most suitable theoretical framework for such an analysis. It provides the key notion of fixed-parameter tractability which, in our context, means polynomial-time tractability for fixed backdoor size, where the order of the polynomial does not depend on the backdoor size. We show how backdoors allow us to deploy recent algorithmic results from parameterized complexity theory to the domain of answer set programming.Parameterized complexity provides tools for a rigorous analysis of polynomial-time preprocessing in terms of kerneliza-tion [7,58]. A kernelization is a polynomial-time self-reduction of a parameterized decision problem that outputs a decision equivalent problem instance whose size is bounded by a function f of the parameter (the kernel size). It is known that every decidable fixed-parameter tractable problem admits a kernelization, but some problems admit small kernels (of size polynomial in the parameter) and others do not. We provide upper and lower bounds for the kernel size of the prob-lems backdoor evaluation and backdoor detection for disjunctive answer set programs. These bounds provide worst case guarantees and limits for polynomial-time preprocessing for the considered problems.Several algorithms in the literature are defined for disjunction-free (i.e., normal) programs only. We introduce a general method for lifting these parameters to disjunctive programs, preserving fixed-parameter tractability under certain conditions.Although our main focus is on a theoretical evaluation, we present some experimental results where we consider the backdoor size of structured programs and random programs of varied density.1.2. Background and related workComplexity of ASP problems Answer set programming is based on the stable-model semantics for logic programs [78,79]. The computational complexity of various problems arising in answer set programming has been subject of extensive studies. Eiter and Gottlob [41] have established that the main decision problems of (disjunctive) ASP are complete for the second level of the Polynomial Hierarchy (Σ P2 -complete, respectively). Moreover, Bidoít and Froidevaux [5] and Marek and Truszczy ´nski [114] have shown that the problems are NP-complete (co-NP-complete respectively) for disjunction-free (so-called normal) programs. Several fragments of programs where the main reasoning problems are polynomial-time tractable have been identified, e.g., Horn programs [78], stratified programs [2] and programs without even cycles [156]. Dantsin et al. [27] survey the classical complexity of the main reasoning problems for various semantics of logic programming, including fragments of answer set programming.2 - or Π PASP solvers Various ASP solvers have been developed in recent years. Many of them utilize SAT solvers as black boxes or search techniques from SAT. There are solvers that deal with one or more fragments of disjunctive programs (normal, tight, or head-cycle-free), e.g., Smodels [141], Assat [111], Cmodels2 [82], and Clasp2 [71]. There are also solvers that deal with the full set of disjunctive programs, e.g., Clasp3 [37], Cmodels3 [108], DLV [107], and GnT [92]. Compilations to other problem domains and respective solvers have been considered for normal programs, e.g., propositional satisfiability [91], mixed integer programming [112], satisfiability modulo theories [93,76]. We would like to point out that these solvers use heuristics without non-trivial worst-case performance guarantees. In contrast we provide for the main reasoning problems of answer set programming theoretical worst-case time bounds that take certain hidden structures in disjunctive programs into account.Preprocessing techniques and unit propagation used in solvers might be considered in a wider sense as implicitly exploit-ing Horn fragments. Grounders like Gringo [64] already solve Horn programs simply by propagating atoms which trivially (do not) belong to the minimal model, e.g., atoms that occur in the head of rules with an empty body, atoms that occur in the head of rules where all atoms in the positive body already belong to the minimal model, atoms that cannot belong to the minimal model according to some constraint, and atoms that cannot belong to the minimal model as they occur in no head. Moreover, SAT-based solvers like Clasp [62] transform the program into a propositional formula using Clark’s completion (see e.g., [73]) where the resulting formula characterizes the classical models and necessary conditions for atoms to belong to a model. If the program contains no cycles in its positive dependency graph, unit propagation (as part of a 66J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103DPLL-based algorithm) already solves Horn fragments. Otherwise, loop formulas are added which prevent the solver from assigning true to atoms that occur on a cycle unless some atom from outside is set to true. If there is an atom from outside that has been assigned to true, atoms on the cycle are set again to true by unit propagation and so forth.Parameterizations of ASP So far there has been no rigorous study of disjunctive ASP within the framework of parameterized complexity. However, several results known from the literature can be stated in terms of parameterized complexity and provide fixed-parameter tractability. The considered parameters include the number of atoms of a normal program that appear in negative rule bodies [4], the number of non-Horn rules of a normal program [4], the size of a smallest feedback vertex set in the dependency digraph of a normal program [85], the number of cycles of even length in the dependency digraph of a normal program [110], the treewidth of the incidence graph of a normal program [90,119], and a combination of two parameters: the length of the longest cycle in the dependency digraph and the treewidth of the interaction graph of a head-cycle-free programs [3]. Very recently we established [48] an fpt-reduction that reduces disjunctive ASP to normal ASP; in other words, a reduction from the second level of the Polynomial Hierarchy to the first level. However, these results do not provide fixed-parameter tractability of the ASP reasoning problems, and hence are not directly comparable to the results presented in this paper. A general theoretical framework to classify parameterized problems on whether they admit an fpt-reduction to SAT or not has lately been introduced in [28]. Similar to our result in [48] this does not provide fixed-parameter tractability of the ASP reasoning problems, but in certain cases fixed-parameter tractability of the reduction to SAT.Backdoors The concept of a backdoor originates in SAT/CSP and was introduced by Williams et al. [152,153]. Since then, backdoors have been used frequently in the literature for theoretical investigations. The study of the parameterized com-plexity of backdoor detection was initiated by Nishimura et al. [123] who considered satisfiability backdoors for the base classes Horn and 2CNF. Since then, the study has been extended to various other base classes, including clustering formu-las [124], renamable Horn formulas [128], QHorn formulas [59], Nested formulas [56], acyclic formulas [54], and formulas of bounded incidence treewidth [57]; for a survey, see [55]. Several results extend the concept of backdoors to other problems, e.g., backdoor sets for constraint satisfaction problems [152], quantified Boolean formulas [137], abstract argumentation [40], and abductive reasoning [125]. Samer and Szeider [136] have introduced backdoor trees for propositional satisfiability which provide a more refined concept of backdoor evaluation and take the interaction of variables that form a backdoor into ac-count. Dilkina et al. [31,32] have considered strong backdoors with “empty clause detection” (empty clauses trivially yield satisfiability). Empty clause detection is present in many modern SAT solvers and often leads to much smaller backdoors in practice. However, they have also established that backdoor detection for the base classes Horn and 2CNF is already harder than NP when empty clause detection is added. Moreover, Szeider [144] has shown that (strong) backdoor detection is W[1]-hard for almost all base classes when empty clause detection is added and thus unlikely to be fixed-parameter tractable.1.3. Prior work and paper organizationThis paper is an extended and updated version of the papers that appeared in the proceedings of the 22nd International Joint Conference on Artificial Intelligence [47] and in the selected papers proceedings of the Student Session of the 23rd European Summer School in Logic, Language, and Information [49]. The present paper provides a higher level of detail, in particular full proofs and more examples. Furthermore, the paper extends its previous versions in the following way: additional attention is payed to the minimality check (Lemma 3.7). Theorem 5.13 is extended to entail some very recent results in parameterized complexity theory. A completely new section (Section 6) is devoted to a rigorous analysis of pre-processing methods for the problems of backdoor detection and backdoor evaluation. We present a general method to lift parameters from rules of normal programs to disjunctive programs (Section 7). We extend the section on the theoretical comparison of parameters (Section 8) by additional comparisons to other parameters, e.g., weak feedback width and inter-action graph treewidth, and to other classes of programs, e.g., head-cycle-free and tight programs. Additionally, we provide some empirical data on backdoor detection and discuss the evaluation of backdoors in a practical setting in Section 4.1.2. Preliminaries2.1. Answer set programmingWe consider a universe U of propositional atoms. A literal is an atom a ∈ U or its negation ¬a. A disjunctive logic program(or simply a program) P is a set of rules of the following formx1 ∨ . . . ∨ xl ← y1, . . . , ym, ¬z1, . . . , ¬znwhere x1, . . . , xl, y1, . . . , ym, z1, . . . , zn are atoms and l, m, n are non-negative integers. Let r be a rule. We write {x1, . . . , xl} =−(r) (the negative body of r). We H(r) (the head of r), { y1, . . . , ym} = Bdenote the sets of atoms occurring in a rule r or in a program P by at(r) = H(r) ∪ Br∈P at(r), +(r) (the positive body of r) and {z1, . . . , zn} = B−(r) and at(P ) =+(r) ∪ B(cid:2)J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10367−(r) = ∅, normal if |H(r)| ≤ 1, a constraint if |H(r)| = 0, constraint-free if |H(r) > 0|, respectively. A rule r is negation-free if B+(r) ∩ (H(r) ∪Horn if it is normal and negation-free or a constraint, positive if it is Horn and constraint-free, tautological if B−(r)) (cid:10)= ∅, and non-tautological if it is not tautological. We say that a program has a certain property if all its rules have Bthe property. Horn refers to the class of all Horn programs. We denote the class of all normal programs by Normal. Let (cid:11) ⊆ P ) if for each rule r(cid:11)P and Pthere is some −(r). We call a class C of programs hereditary if for each P ∈ C all rule r ∈ P with H(rsubprograms of P are in C as well. Note that many natural classes of programs (and all classes considered in this paper) are hereditary.is a subprogram of P (in symbols P+(r), B(cid:11)be programs. We say that P(cid:11)) ⊆ B(cid:11)) ⊆ H(r), BA set M of atoms satisfies a rule r if (H(r) ∪ B+(r) \ M (cid:10)= ∅. M is a model of P if it satisfies all rules of P . The Gelfond–Lifschitz (GL) reduct of a program P under a set M of atoms is the program P M obtained from P by first −(r) from the remaining rules r [79]. M is removing all rules r with Ban answer set (or stable model) of a program P if M is a minimal model of P M . We denote by AS(P ) the set of all answer sets of P .−(r) ∩ M (cid:10)= ∅ and second removing all ¬z where z ∈ B−(r)) ∩ M (cid:10)= ∅ or B(cid:11)) ⊆ B(cid:11) ∈ P−(r+(r(cid:11)Example 2.1. Consider the program P consisting of the following rules:d ← a, e;f ← d, c;b ← c;a ← d, ¬b, ¬c;c ← f , e, ¬b;f .e ∨ c ← f ;c ← d;The set M = {b, c, f } is an answer set of P , since P M = {d ← a, e; f ← d, c; b ← c; e ∨ c ← f ; c ← d; f } and the minimal models of P M are {b, c, f } and {e, f }.In this paper we generally assume that programs contain no tautological rules since one can simply remove tautological (cid:11)rules from a program without effecting the answer sets, i.e., AS(P ) = AS(Pby removing all tautological rules [13, The. 5.5] or [42]. In one case we allow tautological rules and state that explicitly −(r) (cid:10)= ∅ since one can (Proposition 5.10). Moreover, we generally assume that programs contain no rules r where H(r) ∩ B(cid:11))simply remove from those rules the head atoms in H(r) ∩ Bwhere P−(r) without effecting the answer sets, i.e., AS(P ) = AS(P−(r) for every rule r where H(r) ∩ Bis a program obtained from Pis a program obtained from Pby setting H(r) := H(r) \ B−(r) (cid:10)= ∅ [42].(cid:11)) where P(cid:11)(cid:11)(cid:11)It is well known that normal Horn programs have a unique answer set or no answer set and that this set can be found in linear time. Van Emden and Kowalski [149] have shown that every constraint-free Horn program has a unique minimal model. Dowling and Gallier [33] have established a linear-time algorithm for testing the satisfiability of propositional Horn formulas which easily extends to Horn programs. In the following we state the well-known linear-time result.Lemma 2.1. Every Horn program has at most one minimal model which can be found in linear time.2.2. ASP problemsWe consider the following fundamental ASP problems.CheckingGiven: A program P and a set M ⊆ at(P ).Task:Decide whether M is an answer set of P .ConsistencyGiven: A program P .Task:Decide whether P has an answer set.Brave ReasoningGiven: A program P and an atom a ∈ at(P ).Task:Decide whether a belongs to some answer set of P .Skeptical ReasoningGiven: A program P and an atom a ∈ at(P ).Task:Decide whether a belongs to all answer sets of P .CountingGiven: A program P .Task:Compute the number of answer sets of P .J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10368EnumGiven: A program P .Task:List all answer sets of P .We denote by AspReason the family of the reasoning problems Checking, Consistency, Brave Reasoning, and Skeptical Reasoning. We denote by AspFull the family of all the problems defined above. The family AspReason consists of decision problems, and AspFull adds to it a counting and an enumeration problem. In the sequel we will occasionally write LNormalto denote a problem L ∈ AspFull restricted to input programs from Normal.2 -complete, Skeptical Reasoning is Π PChecking is co-NP-complete in general [41], but CheckingNormal is polynomial [14]. Consistency and Brave Reasoningare Σ P2 -complete [41]. Both reasoning problems are NP-complete (or co-NP-complete) for normal programs [113], but are polynomial-time solvable for Horn programs [78]. Counting is easily seen to be #P -hard1 as it entails the problem #SAT.2.3. Parameterized complexityProblem instances that originate from practical applications are often structured in a certain way that facilitates to obtain a solution relatively fast. Such instances seem to be harder in theory, where worst-case running times are given in terms of the input size in bits, than they are in practice. The framework of parameterized complexity, introduced by Downey and Fellows [34], takes structural properties of problem instances in form of a parameter into account. In consequence, it offers a framework for a more detailed theoretical analysis that is closer to the practical hardness of problems. In recent years parameterized complexity theory has become a very active research area. Since there are many ways of defining and cap-turing structure in a problem instance, there are various ways to parameterize a problem. A main concept of parameterized complexity theory is fixed-parameter tractability which relaxes classical polynomial-time tractability in such a way that all non-polynomial parts depend only on the size of the parameter and not on the size of the input.We briefly give some background on parameterized complexity. For more detailed information we refer to other sources [34,35,50,84,120]. An instance of a parameterized problem L is a pair (I, k) ∈ Σ ∗ × N for some finite alphabet Σ . For an instance (I, k) ∈ Σ ∗ × N we call I the main part and k the parameter. (cid:13)I(cid:13) denotes the size of I . L is fixed-parameter tractable if there exist a computable function f and a constant c such that we can decide whether (I, k) ∈ L in time O( f (k)(cid:13)I(cid:13)c). Such an algorithm is called an fpt-algorithm. If L is a decision problem, then we identify L with the set of all yes-instances (I, k). FPT is the class of all fixed-parameter tractable decision problems.Let L ⊆ Σ ∗ × N and L. An we have (I, k) ∈ Lfpt-reduction r from L to L(cid:11) ≤ g(k) for a fixed computable function g : N → N and there is a computable if and only if r(I, k) = (Ifunction f and a constant c such that r is computable in time O( f (k)(cid:13)I(cid:13)c). Thus, an fpt-reduction is, in particular, an fpt-algorithm. It is easy to see that the class FPT is closed under fpt-reductions. It is clear for parameterized problems L1, and L2 that if L1 ∈ FPT and there is an fpt-reduction from L2 to L1, then L2 ∈ FPT.(cid:11) ⊆ Σ ∗ × N be two parameterized decision problems for some finite alphabets Σ and Σ (cid:11)(cid:11)is a many-to-one reduction from Σ ∗ × N to Σ (cid:11) ∗ × N such that for all I ∈ Σ ∗(cid:11)) ∈ L(cid:11), kThe Weft Hierarchy consists of parameterized complexity classes W[1] ⊆ W[2] ⊆ · · · which are defined as the closure of certain parameterized problems under parameterized reductions. There is strong theoretical evidence that parameter-ized problems that are hard for classes W[i] are not fixed-parameter tractable. A prominent W[2]-complete problem is Hitting Set [34,35] defined as follows:and k(cid:11)Hitting SetA family of sets (S, k) where S = {S1, . . . , Sm} and an integer k.Given:Parameter: The integer k.Task:Decide whether there exists set H of size at most k which intersects with all the S i (H is a hitting set of S).The class XP of non-uniform tractable problems consists of all parameterized decision problems that can be solved in polynomial time if the parameter is considered constant. That is, (I, k) ∈ L can be decided in time O((cid:13)I(cid:13) f (k)) for some computable function f . The parameterized complexity class paraNP contains all parameterized decision problems L such that (I, k) ∈ L can be decided non-deterministically in time O( f (k)(cid:13)I(cid:13)c) for some computable function f and constant c. A parameterized decision problem is paraNP-complete if it is in NP and NP-complete when restricted to finitely many pa-rameter values [50]. By co-paraNP we denote the class of all parameterized decision problems whose complement (yes and no instances swapped) is in paraNP. Using the concepts and terminology of Flum and Grohe [50], co-paraNP = para-coNP.2.4. GraphsWe recall some notations of graph theory. We consider undirected and directed graphs. An undirected graph or simply a graph is a pair G = (V , E) where V (cid:10)= ∅ is a set of vertices and E ⊆ {{u, v} ⊆ V : u (cid:10)= v} is a set of edges. We denote an 1 #P is the complexity class consisting of all the counting problems associated with the decision problems in NP.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10369(cid:11)(cid:11) = (V(cid:11), E(cid:11)and uv ∈ E also uv ∈ E(cid:11)) is a subgraph of G if V(cid:11) ⊆ E and an induced subgraph if addition-edge {v, w} by uv or vu. A graph Gally for any u, v ∈ V. A path of length k is a graph with k + 1 pairwise distinct vertices v 1, . . . , vk+1, and k distinct edges v i v i+1 where 1 ≤ i ≤ k (possibly k = 0). A cycle of length k is a graph that consists of k distinct ver-tices v 1, v 2, . . . , vk and k distinct edges v 1 v 2, . . . , vk−1 vk, vk v 1. Let G = (V , E) be a graph. G is bipartite if the set V of vertices can be divided into two disjoint sets U and W such that there is no edge uv ∈ E with u, v ∈ U or u, v ∈ W . (cid:11) ⊆ V if the induced sub-G is complete if for any two vertices u, v ∈ V there is an edge uv ∈ E. G contains a clique on V(cid:11)) of G is a complete graph. A connected component C of G is an inclusion-maximal subgraph C = (V C , E C ) of Ggraph (Vsuch that for any two vertices u, v ∈ V C there is a path in C from u to v.(cid:11) ⊆ V and EA directed graph or simply a digraph is a pair G = (V , E) where V (cid:10)= ∅ is a set of vertices and E ⊆ {(u, v) ∈ V × V : u (cid:10)= v}(cid:11) ⊆ E and an induced subdigraph if (cid:11)) is a subdigraph of G if Vis a set of directed edges. A digraph G(cid:11)additionally for any u, v ∈ V. A directed path of length k is a digraph with k + 1 pairwise distinct vertices v 1, . . . , vk+1, and k distinct edges (v i, v i+1) where 1 ≤ i ≤ k (possibly k = 0). A directed cycle of length k is a digraph that consists of k distinct vertices v 1, v 2, . . . , vk and k distinct edges (v 1, v 2), . . . , (vk−1, vk), (vk, v 1).(cid:11), Eand (u, v) ∈ E also (u, v) ∈ E(cid:11) ⊆ V and E(cid:11) = (V(cid:11), E(cid:11)We sometimes denote a (directed) path or (directed) cycle as a sequence of vertices. Please observe that according to the above definitions, the length of an undirected cycle is at least 3, whereas the length of a directed cycle is at least 2.A strongly connected component C of a digraph G = (V , E) is an inclusion-maximal directed subgraph C = (V C , E C ) of G such that for any two vertices u, v ∈ V C there are paths in C from u to v and from v to u. The strongly connected components of G form a partition of the set V of vertices, we denote this partition by SCC(G).For further basic terminology on graphs and digraphs we refer to a standard text [30,11].2.5. Satisfiability backdoorsWe also need some notions from propositional satisfiability. A literal is an atom or its negation and a clause is a finite set of literals A CNF formula is a finite set of clauses. A truth assignment is a mapping τ : X → {0, 1} defined for a set X ⊆ Uof atoms. For x ∈ X we put τ (¬x) = 1 − τ (x). By 2 X we denote the set of all truth assignments τ : X → {0, 1}. The truth assignment reduct of a CNF formula F with respect to τ ∈ 2 X is the CNF formula Fτ obtained from F by first removing all clauses c that contain a literal set to 1 by τ , and second removing from the remaining clauses all literals set to 0 by τ . τ satisfies F if Fτ = ∅, and F is satisfiable if it is satisfied by some τ .The following is obvious from the definitions:Observation 2.2. Let F be a CNF formula and X a set of atoms. F is satisfiable if and only if Fτ is satisfiable for at least one truth assignment τ ∈ 2 X .This leads to the definition of a strong backdoor relative to a class C of polynomially solvable CNF formulas: a set X of atoms is a strong C-backdoor of a CNF formula F if Fτ ∈ C for all truth assignments τ ∈ 2 X . Assume that the satisfiability of formulas F ∈ C of size (cid:13)F (cid:13) = n can be decided in time O(nc). Then we can decide the satisfiability of an arbitrary formula Ffor which we know a strong C-backdoor of size k in time O(2knc) which is efficient as long as k remains small.A further variant of backdoors are deletion backdoors defined by removing literals from a CNF formula. F − X denotes the formula obtained from F by removing all literals x, ¬x for x ∈ X from the clauses of F . Then a set X of atoms is a deletion C-backdoor of F if F − X ∈ C. In general, deletion C-backdoors are not necessarily strong C-backdoors. If all subsets of a formula in C also belong to C (C is clause-induced), then deletion C-backdoors are strong C-backdoors.Before we can use a backdoor we need to find it first. What we call the backdoor approach is a process consisting of the following two phases:• finding a backdoor (backdoor detection) and• using the backdoor to solve the problem (backdoor evaluation).For most reasonable target classes C the detection of a strong C-backdoor of size at most k is NP-hard if k is part of the input. However, as we are interested in finding small backdoors, it makes sense to parameterize the backdoor search by k and consider the parameterized complexity of backdoor detection. Indeed, with respect to the classes of Horn CNF formulas and 2-CNF formulas, the detection of strong backdoors of size at most k is fixed-parameter tractable [123]. The parameterized complexity of backdoor detection for many further target classes has been investigated [55].The purpose of this paper is to develop a backdoor approach for answer set programming. It turns out that the evaluation problem is more complicated than for propositional satisfiability (see Section 3.3) and various target classes for answer set programming require new algorithms for backdoor detection (see Section 5).70J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–1033. Answer set backdoors3.1. Strong backdoorsIn order to translate the notion of backdoors to the domain of ASP, we first need to come up with a suitable concept of a reduction with respect to a truth assignment. The following is a natural definition which generalizes a concept of Gottlob et al. [85].Definition 3.1. Let P be a program, X a set of atoms, and τ ∈ 2 X . The truth assignment reduct of P under τ is the logic program P τ obtained from P by1. removing all rules r with H(r) ∩ τ −1(1) (cid:10)= ∅ or H(r) ⊆ X ;2. removing all rules r with B3. removing all rules r with B4. removing from the heads and bodies of the remaining rules all literals a, ¬a with a ∈ X .+(r) ∩ τ −1(0) (cid:10)= ∅;−(r) ∩ τ −1(1) (cid:10)= ∅;Definition 3.2. Let C be a class of programs. A set X of atoms is a strong C-backdoor of a program P if P τ ∈ C for all truth assignments τ ∈ 2 X .By a minimal strong C-backdoor of a program P we mean a strong C-backdoor of P that does not properly contain a smaller strong C-backdoor of P ; a smallest strong C-backdoor of P is one of smallest cardinality.Example 3.1. We consider the program of Example 2.1. The set {b, c} is a strong Horn-backdoor since all four truth assign-= {d ← a, e; f ← d; f }, P b¯c = {d ← a, e; e ← f ; f }, and ment reducts P ¯b¯cP bc = {d ← a, e; f ← d; f } are in the class Horn.= P b=0,c=0 = {d ← a, e; a ← d; e ← f ; f }, P ¯bc3.2. Deletion backdoorsNext we define a variant of answer set backdoors similar to satisfiability deletion backdoors. For a program P and a set X of atoms we define P − X as the program obtained from P by deleting a, ¬a for a ∈ X from the rules of P . The definition gives rise to deletion backdoors. We will see that finding deletion backdoors is in some cases easier than finding strong backdoors.Definition 3.3. Let C be a class of programs. A set X of atoms is a deletion C-backdoor of a program P if P − X ∈ C.In general, not every strong C-backdoor is a deletion C-backdoor, and not every deletion C-backdoor is a strong C-backdoor. But we can strengthen one direction requiring the base class to satisfy the very mild condition of being hered-itary (see Section 2) which holds for all base classes considered in this paper.Lemma 3.4. If C is hereditary, then every deletion C-backdoor is a strong C-backdoor.Proof. Let P be a program, X ⊆ at(P ), and τ ∈ 2 X . Let rsome r ∈ P by deleting a, ¬a for all a ∈ X from the head and body of r. Consequently restablishes the proposition. (cid:2)(cid:11) ∈ P τ . It follows from Definition 3.1 that r(cid:11)is obtained from (cid:11) ∈ P − X . Hence P τ ⊆ P − X which 3.3. Backdoor evaluationAn analogue to Observation 2.2 does not hold for ASP, even if we consider the most basic problem Consistency. Take for example the program P = {x ← y; y ← x; ← ¬x; z ← ¬x} and the set X = {x}. Both reducts P x=0 = {z} and P x=1 = { y} have answer sets, but P has no answer set. However, we can show a somewhat weaker asymmetric variant of Observation 2.2, where we can map each answer set of P to an answer set of P τ for some τ ∈ 2 X . This is made precise by the following definition and lemma (which are key for a backdoor approach to answer set programming).Definition 3.5. Let P be a program and X a set of atoms. We defineAS(P , X) =(cid:3)(cid:4)M ∪ τ −1(1) : τ ∈ 2 X∩at(P ), M ∈ AS(P τ ).In other words, the sets in AS(P , X) are answer sets of P τ for truth assignments τ to X ∩ at(P ) extended by those atoms which are set to true by τ . In the following lemma we will see that the elements in AS(P , X) are “answer set candidates” of the original program P .Lemma 3.6. AS(P ) ⊆ AS(P , X) holds for every program P and every set X of atoms.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10371(cid:11)(cid:11)(cid:11)is a model of P Mτ .arbitrarily. By construction of P Mτ(cid:11) ∈ P Mτ(cid:11)Proof. Let M ∈ AS(P ) be chosen arbitrarily. We put X0 = ( X \ M) ∩ at(P ) and X1 = X ∩ M and define a truth assignment τ ∈(cid:11) ∈ AS(P τ ) implies M ∈ AS(P , X) since M =2X∩at(P ) by setting τ −1(i) = Xi for i ∈ {0, 1}. Let M(cid:11) ∈ AS(P τ ). We have to show that Mis Ma model of P M(cid:11) ∪ τ −1(1) by definition. Hence, to establish the lemma, it suffices to show that M(cid:11) = M \ X1. Observe that Mτ , and that no proper subset of M(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)∗+(r(cid:11)) \ M; thus, Mis a model of P MIn order to show that Mτ ), it follows that B(cid:11)) = H(r) \ X0 and Bτ , choose r(cid:11)) = B(cid:11)(cid:11) ∈ P τ , and in turn, r−(r) ∩ M−(r) ∩ M = ∅. Thus, r gives rise to a rule r∗). Since M ∈ AS(P ), M satisfies r+(rrule r ∈ P with H(r(cid:11) ∈ PMτ . Since Brhave been deleted forming P M+(r) = B+(rB+(r) \ M = BB+(r) \ X1 which gives rise to a rule r−(r) ∩ X1 = ∅ (otherwise r would have been deleted forming P τ ) and Bthere is a corresponding gives rise to (cid:11) = ∅ (otherwise r(cid:11)(cid:11)would ∗ ∈ P M with H(r) = H(r∗) and (cid:11)) ∩ M(cid:11)and (cid:11)is a model of P Mτ .(cid:11). Let N =In order to show that no proper subset of M(cid:11) = M \ X1 and X1 ⊆ M it follows that N (cid:2) M. Since M is a minimal model of P M , N cannot be a model of (cid:11) ∪ X1. Since MN−(r) ∩ M = ∅ (i.e., r is not deleted by forming P M ), B+(r) ⊆ N and P M . Consequently, there must be a rule r ∈ P such that B+(r) ⊆ N ⊆ M, H(r) ∩ M (cid:10)= ∅. Thus, r is not a constraint. Moreover, H(r) ∩ N = ∅. However, since M satisfies P M and since Bsince H(r) ∩ M (cid:10)= ∅ and M ∩ X0 = ∅, it follows that H(r) \ X0 (cid:10)= ∅. Thus, since H(r) ∩ X1 = ∅, H(r) \ X (cid:10)= ∅. We conclude that τ , giving r is not deleted when forming P τ and giving rise to a rule r, with H(rrise to a rule ris (cid:11)not a model of P Mτ .(cid:11) ∈ P τ , which in turn is not deleted when forming P M+(rτ was chosen arbitrarily, we conclude that M+(r) \ M (cid:10)= ∅. However, H(r) ∩ M = H(rchoose arbitrarily a proper subset N, i.e., H(r) ∩ M (cid:10)= ∅ or B(cid:11)(cid:11)) = H(r) \ X0, Bis a model of P Mτ+(r) \ X1, and B(cid:11)(cid:11)) = ∅. Since B(cid:11)(cid:11)) ∩ N = ∅, N. Since r(cid:11)satisfies rand H(r(cid:11)(cid:11)) ⊆ N(cid:11)(cid:11)) = B(cid:11) ∈ P M(cid:11) (cid:2) M−(r+(r(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)Thus, we have established that M(cid:11)is a stable model of P τ , and so the lemma follows. (cid:2)In view of Lemma 3.6 we shall refer to the elements in AS(P , X) as “answer set candidates.”Example 3.2. We consider program P of Example 2.1 and the strong Horn-backdoor X = {b, c} of Example 3.1. The answer sets of P τ are AS(P ¯b¯c) = {{e, f }}, AS(P ¯bc) = {{ f }}, AS(P b¯c) = {{e, f }}, and AS(P bc) = {{ f }} for τ ∈ 2. We obtain the set AS(P , X) = {{e, f }, {c, f }, {b, e, f }, {b, c, f }}.{b,c}In view of Lemma 3.6, we can compute AS(P ) by (i) computing AS(P τ ) for all τ ∈ 2 X (this produces the set AS(P , X)of candidates for AS(P )), and (ii) checking for each M ∈ AS(P , X) whether it is an answer set of P . The check (ii) entails (ii.a) checking whether M ∈ AS(P , X) is a model of P and (ii.b) whether M ∈ AS(P , X) is a minimal model of P M . We would like to note that in particular any constraint contained in P is removed in the truth assignment reduct P τ but considered in check (ii.a). Clearly check (ii.a) can be carried out in polynomial time for each M. Check (ii.b), however, is co-NP-complete in general [113], but polynomial for normal programs [14].Fortunately, for our considerations it suffices to perform check (ii.b) for programs that are “close to Normal,” and so the check is fixed-parameter tractable in the size of the given backdoor. More precisely, we consider the following parameterized problem and establish its fixed-parameter tractability in the next lemma.Strong C-Backdoor Asp CheckA program P , a strong C-backdoor X of P and a set M ⊆ at(P ).Given:Parameter: The size | X| of the backdoor.Task:Decide whether M is an answer set of P .Lemma 3.7. Let C be a class of normal programs. The problem Strong C-Backdoor Asp Check is fixed-parameter tractable.Proof. Let C be a class of normal programs, P a program, and X a strong C-backdoor X of P with | X| = k. We can check in polynomial time whether M is a model of P and whether M is a model of P M . If it is not, we can reject M, and we are done. Hence assume that M is a model of P M . In order to check whether M ∈ AS(P ) we still need to decide whether M is a minimal model of P M . Recall that P contains no tautological rules.Let X1 ⊆ M ∩ X . We construct from P M a program P MX1⊆ X by (i) removing all rules r for which H(r) ∩ X1 (cid:10)= ∅, and (ii) replacing for all remaining rules r the head H(r) with H(r) \ X , and the positive body B+(r) with B+(r) \ X1.Claim. P MX1⊆ X is Horn.(cid:11) ∈ P MX1⊆ X . By construction, there must be a rule r ∈ P that gives raise to To show the claim, consider some rule r(cid:11). Let τ ∈ 2 X be the assignment that sets all atoms in X ∩ H(r) to 0, and a rule in P M , which in turn gives raise to rall atoms in X \ H(r) to 1. Since r is not tautological, it follows that r is not deleted when we obtain P τ , and it gives rise to a rule ris normal. Hence 1 ≥ |H(r∗) = H(r) \ X . However, since C is a class of normal programs, r(cid:11))|, and the claim follows.∗)| = |H(r) \ X| = |H(r∗ ∈ P τ , where H(r∗To test whether M is a minimal model of P M , we run the following procedure for every set X1 ⊆ M ∩ X .72J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Fig. 1. Exploit pattern of ASP backdoors if the target class C is normal and enumerable where n denotes the input size of P .X1⊆ X has no model, then stop and return True.If P MOtherwise, compute the unique minimal model L of the Horn program P Mmodel of P M , then return False. Otherwise return True.X1⊆ X . If L ⊆ M \ X , L ∪ X1 (cid:2) M, and L ∪ X1 is a For each set X1 ⊆ M ∩ X the above procedure runs in linear time by Lemma 2.1. As there are O(2k) sets X1 to consider, we have a total running time of O(2kn) where n denotes the input size of P and k = | X|. It remains to establish the correctness of the above procedure in terms of the following claim.Claim. M is a minimal model of P M if and only if the algorithm returns True for each X1 ⊆ M ∩ X .(⇒) Assume that M is a minimal model of P M , and suppose to the contrary that there is some X1 ⊆ M ∩ X for which X1⊆ X has a unique minimal model L with L ⊆ M \ X , L ∪ X1 (cid:2) M, and where the algorithm returns False. Consequently, P ML ∪ X1 is a model of P M . This contradicts the assumption that M is a minimal model of P M . Hence the only–if direction of the claim is shown.(⇐) Assume that the algorithm returns True for each X1 ⊆ M ∩ X . We show that M is a minimal model of P M . Suppose to the contrary that P M has a model MWe run the algorithm for X1 := M(cid:11) (cid:2) M.has no model, or (ii) P MM \ X , or (ii.b) L ∪ X1 is not a proper subset of M, or (ii.c) L ∪ X1 is not a model of P M .(cid:11) ∩ X . By assumption, the algorithm returns True. There are two possibilities: (i) P MX1⊆ XX1⊆ X has a model, and for its unique minimal model L the following holds: (ii.a) L is not a subset of We show that case (i) is not possible by showing that MTo see this, consider a rule r(cid:11) ∈ P M(cid:11)+(r). Since MX1⊆ X , and let r ∈ P M such that ris a model of P M , we have (a) B(cid:11)) = Bby removing X1 from B+(r) \ X1 and X1 = M+(rBsince H(r) ∩ X1 = ∅, (b) implies ∅ (cid:10)= H(r) ∩ M(cid:11)Hence M(cid:11) ∩ X , (a) implies ∅ (cid:10)= B(cid:11) = H(r) ∩ (M(cid:11) = B+(r) \ M(cid:11) \ X1) = H(r) ∩ (M(cid:11) \ X is a model of P M(cid:11)X1⊆ X .(cid:11) (cid:10)= ∅ or (b) H(r) ∩ M(cid:11) ⊆ B+(ris obtained from r by removing X from H(r) and (cid:11) (cid:10)= ∅. Moreover, since +(r) \ M(cid:11) \ X), and +(r+(r) \ X1 \ M(cid:11) \ X) = H(r(cid:11) \ X). X1⊆ X .(cid:11) \ X) = (H(r) \ X) ∩ (M(cid:11)) ∩ (M(cid:11)) \ (M(cid:11)) \ M(cid:11) = B(cid:11) ∈ P M. Since r(cid:11) \ X satisfies r(cid:11) \ X is a model of P MX1⊆ X was chosen arbitrarily, we conclude that M(cid:11) \ X ⊆ M \ X . Case (ii.b): Further we have L ∪ X1 (cid:2) M since L ∪ X1 ⊆ (MCase (ii) is not possible either, as we can see as follows. Assume P MX1⊆ X , as shown above, we have L ⊆ M(cid:11) \ X is a model of P MX1⊆ X has a model, and let L be its unique minimal (cid:11) \ X(cid:11) \ X . Case (ii.a): We have L ⊆ M \ X since L ⊆ Mmodel. Since M(cid:11) (cid:2) M. and MCase (ii.c): And finally L ∪ X1 is a model of P M , as can be seen as follows. Consider a rule r ∈ P M . If X1 ∩ H(r) (cid:10)= ∅, then L ∪ X1(cid:11)) = H(r) \ Xsatisfies r; thus, it remains to consider the case X1 ∩ H(r) = ∅. In this case there is a rule r(cid:11)) ∩ L (cid:10)= ∅. Since (cid:11)) \ L (cid:10)= ∅ or (b) H(rand B(cid:11)) ⊆ H(r), (b) implies that H(r) ∩ (L ∪ X1) (cid:10)= ∅. Thus, +(rBL ∪ X1 satisfies r. Since r ∈ P M was chosen arbitrarily, we conclude that L ∪ X1 is a model of P M .(cid:11)) = B+(r) \ X1, (a) implies that B+(r) \ X1. Since L is a model of P M+(r) \ (L ∪ X1) (cid:10)= ∅; and since H(rX1⊆ X , L satisfies r(cid:11) \ X) ∪ X1 = (MX1⊆ X with H(r+(r(cid:11)) = B. Hence (a) B(cid:11) \ X) ∪ (M(cid:11) ∩ X) = M(cid:11) ∈ P M+(r(cid:11)Since neither case (i) nor case (ii) is possible, we have a contradiction, and we conclude that M is a minimal model of P M .Hence the second direction of the claim is established, and so the lemma follows. (cid:2)Fig. 1 illustrates how we can exploit a strong C-backdoor to find answer sets. For a given program P and a strong C-backdoor X of P we have to consider |2 X | truth assignments to the atoms in the backdoor X . For each truth assign-ment τ ∈ 2 X we reduce the program P to a program P τ and compute the set AS(P τ ). Finally, we obtain the set AS(P ) by checking for each M ∈ AS(P τ ) whether it gives rise to an answer set of P .J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10373Example 3.3. We consider the set AS(P , X) = {{e, f }, {c, f }, {b, e, f }, {b, c, f }} of answer set candidates of Example 3.2 and check for each candidate L = {e, f }, M = {c, f }, N = {b, e, f }, and O = {b, c, f } whether it is an answer set of P . Therefore we solve the problem Strong Horn-Backdoor Asp Check by means of Lemma 3.7.First we test whether the sets L, M, N and O are models of P . We easily observe that N and O are models of P . But Land M are not models of P since they do not satisfy the rule c ← e, f , ¬b and b ← c respectively, and we can drop them as candidates. Then we positively answer the question whether N and O are models of its GL-reducts P N and P O respectively.Next we consider the minimality and apply the algorithm of Lemma 3.7 for each subset of the backdoor X = {b, c}. We = {d ← a, e; e ←have the GL-reduct P N = {d ← a, e; e ∨ c ← f ; f ← d, c; c ← d; b ← c; f }. For X1 = ∅ we obtain P NX1⊆ Xf ; f ← d, c; ← d; ← c; f }. The set L = {e, f } is the unique minimal model of P NX1⊆ X . Since L ⊆ N \ X , L ∪ X1 (cid:2) N, and L ∪ X1 is a model of P N , the algorithm returns False. We conclude that N is not a minimal model of P N and thus N is not an answer set of P .We obtain the GL-reduct P O = {d ← a, e; e ∨ c ← f ; f ← d, c; c ← d; b ← c; f }. For X1 = ∅ we have P O= {d ←X1⊆ X . Since L ∪ X1 (cid:2) O , the a, e; e ← f ; f ← d, e; ← d; ← c; f }. The set L = {e, f } is the unique minimal model of P O= {d ← a, e; e ← f ; f ← d, e; ← d; f } and the unique minimal model algorithm returns True. For X2 = {b} we get P O= {d ← a, e; f ← d; ←; f } and no L = {e, f }. Since L ⊆ O \ X , the algorithm returns True. For X3 = {c} we obtain P OX3⊆ Xminimal model. Thus, the algorithm returns True. For X4 = {b, c} we have P O= {d ← a, e; f ← d; f } and the unique minimal model L = { f }. Since L ∪ X1 (cid:2) O , the algorithm returns True. Since only {b, c, f } ∈ AS(P , X) is an answer set of P , we obtain AS(P ) = {{b, c, f }}.X2⊆ XX4⊆ XX1⊆ XIn view of Lemmas 3.6 and 3.7, the computation of AS(P ) is fixed-parameter tractable for parameter k if we know a strong C-backdoor X of size at most k for P , and each program in C is normal and its stable sets can be computed in polynomial time. This consideration leads to the following definition and result.Definition 3.8. A class C of programs is enumerable if for each P ∈ C we can compute AS(P ) in polynomial time. If AS(P )can be computed in linear time, then the class C is linear-time enumerable.Please note, that this is a stronger property than being enumerable with polynomial-time delay; the latter is usually used in the context of enumeration problems and also mentioned in Section 8.4 for a certain parameter.Theorem 3.9. Let C be an enumerable class of normal programs. The problems in AspFull are all fixed-parameter tractable when parameterized by the size of a strong C-backdoor, assuming that the backdoor is given as input.Proof. Let X be the given backdoor, k = | X| and n the input size of P . Since P τ ∈ C and C is enumerable, we can compute AS(P τ ) in polynomial time for each τ ∈ 2 X , say in time O(nc) for some constant c. Observe that therefore |AS(P τ )| ≤ O(nc)for each τ ∈ 2 X . Thus, we obtain AS(P , X) in time O(2knc), and |AS(P , X)| ≤ O(2knc). By Lemma 3.6, AS(P ) ⊆ AS(P , X). By means of Lemma 3.7 we can decide whether M ∈ AS(P ) in time O(2kn) for each M ∈ AS(P , X). Thus, we determine from AS(P , X) the set of all answer sets of P in time O(2k · nc · 2k · n + 2k · nc) = O(22knc+1). Once we know AS(P ), then we can also solve all problems in AspFull within polynomial time. (cid:2)Theorem 3.9 identifies conditions under which a small backdoor indeed reduces the search space for the main ASPreasoning problems, that is, to be exponential only in the backdoor size and not in the size of the entire instance. Hence under these conditions a small backdoor can be considered as a “clever reasoning shortcut” through the search space.Remark. If we know that each program in C has at most one answer set, and P has a strong C-backdoor of size k, then we can conclude that P has at most 2k answer sets. Thus, we obtain an upper bound on the number of answer sets of P by computing a small strong C-backdoor of P .3.4. Backdoor detectionTheorem 3.9 draws our attention to enumerable classes of normal programs. Given such a class C, is the detection of C-backdoors fixed-parameter tractable? If the answer is affirmative, we can drop in Theorem 3.9 the assumption that the backdoor is given as an input for this class.Each class C of programs gives rise to the following two parameterized decision problems:Strong C-Backdoor DetectionA program P and an integer k.Given:Parameter: The integer k.Task:Decide whether P has a strong C-backdoor X of size at most k.74J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Fig. 2. Negation dependency graph N P of the program P of Example 2.1.Deletion C-Backdoor DetectionA program P and an integer k.Given:Parameter: The integer k.Task:Decide whether P has a deletion C-backdoor X of size at most k.By a standard construction, known as self-reduction or self-transformation [139,34,35], one can use a decision algorithm for Deletion C-Backdoor Detection to actually find the backdoor. We only require the base class to be hereditary.Lemma 3.10. Let C be a hereditary class of programs. If Deletion C-Backdoor Detection is fixed-parameter tractable, then also finding a deletion C-backdoor of a given program P of size at most k is fixed-parameter tractable (for parameter k).Proof. We proceed by induction on k. If k = 0 the statement is clearly true. Let k > 0. Given (P , k) we check for all x ∈ at(P )whether P − {x} has a deletion C-backdoor of size at most k − 1. If the answer is NO for all x, then P has no deletion C-backdoor of size k. If the answer is YES for x, then by induction hypothesis we can compute a deletion C-backdoor X of size at most k − 1 of P − x, and X ∪ {x} is a deletion C-backdoor of P . (cid:2)Remark. One could consider also target classes where empty rules are detected (an analogy to “empty clause detection” [31,32] in the SAT setting) which would yield smaller backdoors. However, backdoor detection is already W[1]-hard for almost all base classes, including Horn, in the SAT setting when empty clause detection is added [144]. These W[1]-hardness results carry over to the ASP setting if empty rule detection is added.4. Target class HornIn this section we consider the important case Horn as the target class for backdoors. As a consequence of Lemma 2.1, Horn is linear-time enumerable. The following lemma shows that strong and deletion Horn-backdoors coincide.Lemma 4.1. A set X is a strong Horn-backdoor of a program P if and only it is a deletion Horn-backdoor of P .Proof. Since Horn is hereditary, Lemma 3.4 establishes the if-direction. For the only–if direction, we assume for the sake (cid:11) ∈of a contradiction that X is a strong Horn-backdoor of P but not a deletion Horn-backdoor of P . Hence there is a rule rwas obtained in forming P − X . We define P − X that is neither tautological nor Horn. Let r ∈ P be a rule from which r+(r) to 1, and all remaining atoms in X \ at(r)τ ∈ 2X by setting all atoms in X ∩ (H(r) ∪ B(cid:11) ∈ P τ , contradicting the arbitrarily to 0 or 1. Since r is not tautological, this definition of τ is sound. It follows that rassumption that X is a strong Horn-backdoor of P . (cid:2)−(r)) to 0, all atoms in X ∩ B(cid:11)Definition 4.2. Let P be a program. The negation dependency graph N P is the graph defined on the set of atoms of the given program P , where two distinct atoms x, y are joined by an edge xy if there is a rule r ∈ P with x ∈ H(r) and y ∈ H(r) ∪ B−(r).Example 4.1. Fig. 2 visualizes the negation dependency graph N P of the program P of Example 2.1.The following lemma states how we can use recent results on the vertex cover problem to find deletion backdoors for the target class Horn. A vertex cover of a graph G = (V , E) is a set S ⊆ V such that for every edge uv ∈ E we have {u, v} ∩ S (cid:10)= ∅.Lemma 4.3. Let P be a program. A set X ⊆ at(P ) is a deletion Horn-backdoor of P if and only if X is a vertex cover of the negation dependency graph N P .Proof. Let X ⊆ at(P ) be a deletion Horn-backdoor of P . Consider an edge uv of N P . By construction of N P there is a −(r). Since X is a deletion Horn-backdoor, corresponding rule r ∈ P with (i) u, v ∈ H(r) and u (cid:10)= v or (ii) u ∈ H(r) and v ∈ BJ.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10375|H(r) − X| ≤ 1 and Bconclude that X is a vertex cover of N P .−(r) − X = ∅. Thus, if case (i) applies, {u, v} ∩ X (cid:10)= ∅. If case (ii) applies, again {u, v} ∩ X (cid:10)= ∅. We Conversely, assume that X is a vertex cover of N P . Consider a rule r ∈ P − X for proof by contradiction assume that ris not Horn (in particular r is not a constraint). If |H(r)| ≥ 2 then there are two variables u, v ∈ H(r) and an edge uv of −(r) (cid:10)= ∅ then we take a N P such that {u, v} ∩ X = ∅, contradicting the assumption that X is a vertex cover. Similarly, if B−(r) and a variable v ∈ H(r); such v exists since r is not a constraint. Thus, N P contains the edge uv with variable u ∈ B{u, v} ∩ X = ∅, contradicting the assumption that X is a vertex cover. Hence the claim holds. (cid:2)Example 4.2. For instance, the negation dependency graph N P of the program P of Example 2.1 consists of the trian-gle {a, b, c} and a path (c, e). Then {b, c} is a vertex cover of N P . We observe easily that there exists no vertex cover of size 1. Thus, {b, c} is a smallest strong Horn-backdoor of P .Remark. Note that the unparameterized version2 of Strong Horn-Backdoor Detection is NP-hard. Since the reduction pre-sented in the proof of Lemma 4.3 can be used straightforward as a reduction of the unparameterized version of the vertex cover problem to Strong Horn-Backdoor Detection.Theorem 4.4. Strong Horn-Backdoor Detection is fixed-parameter tractable. In fact, given a program with n atoms we can find a strong Horn-backdoor of size at most k in time O(1.2738k + kn) or decide that no such backdoor exists.Proof. Let P be a given program. Let N P be the negation dependency graph of P . According to Lemma 4.3, a set X ⊆ at(P )is a vertex cover of N P if and only if X is a deletion Horn-backdoor of P . Then a vertex cover of size at most k, if it exists, can be found in time O(1.2738k + kn) by Chen et al. [22]. By Lemma 4.1 this vertex cover is also a strong Horn-backdoor of P . (cid:2)Now we can use Theorem 4.4 to strengthen the fixed-parameter tractability result of Theorem 3.9 by dropping the assumption that the backdoor is given.Corollary 4.5. All the problems in AspFull are fixed-parameter tractable when parameterized by the size of a smallest strong Horn-backdoor of the given program.4.1. Horn-backdoors of benchmark instancesThe underlying idea for fixed-parameter tractability is that problem instances for which the parameter is small can be solved efficiently. It is therefore natural to ask how the values of a parameter are distributed in various problem instances. Hence, we investigate the size of backdoors for various benchmark programs, focusing on the target class Horn. As expected, structured programs, originating from application domains, have smaller backdoors than random instances. Since the direct implementation of our backdoor-based algorithms seems impracticable.We have determined strong Horn-backdoors for various benchmark programs by means of encodings into answer set programming, integer linear programming (ILP), local search (LS), and propositional satisfiability (SAT). We use the con-nection stated in Lemma 4.3 and compile the problem of finding a minimum vertex cover (k-vertex cover) into the respective domain. The encodings are straightforward: Let P be a program (without constraints or tautological rules) and let N p = (V , E) be its negation dependency graph. For the ASP encoding we proceed as follows: Among the atoms of our ASP program will be atoms {eu w : u w ∈ E} and atoms C = {c v : v ∈ V }. The truth values of the atoms in C represent a subset S ⊆ at(P ) such that c v is true if and only if v ∈ S (a vertex cover). We introduce for every edge v w ∈ E a con-straint ← e v w , ¬c v , ¬c w and a choice rule 1{cu, c v } ← eu,v Moreover, we add a statement to minimize the number of atoms in C that belong to an answer set (see [141,73] for choice rules and minimize statements). For the ILP encoding we proceed as follows: We introduce for every vertex v ∈ V a binary variable bv , we add for every edge v w ∈ E a con-straint bv + bw ≥ 1, and minimize the sumv∈V bv . For LS we ran designated local search based vertex cover solvers [15,17,16] on the graph N p . For the SAT encoding we used an encoding similar to the encoding presented in [53]. We introduce for every edge uv ∈ E a binary clause and add a sequential unary counter [142] to express that at most k vertices belong to a vertex cover.(cid:5)The answer set program that solves backdoor detection was generated by means of ASP meta programming [70] and solved using Clasp [71,72] version 3.0.5 with an unsatisfiable-core based optimization strategy (the command line parame-ter “–opt-strategy=5” yields the behavior) [1]. The integer linear program was generated using the open source mathematics framework Sage [44] with Python [150], solved using ILOG CPLEX 12 [89] and Gurobi [87].2 Given a parameterized problem L on some finite alphabet Σ . The unparameterized version of L is the classical problem {I#uk : (I, k) ∈ L} where udenotes an arbitrary symbol from Σ and # is a new symbol not in Σ .76J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Table 1Size of smallest strong Horn-backdoors (bd) for various benchmark sets, given as % of the total number of atoms (# atoms) by the mean over the instances.DomainAIGraphPlanningCryptographyPuzzleRandomInstance setDisj.#instancesHanoiTowerStrategicCompaniesMinimalDiagnosisGraphColoringMSS/MUSConformantPlanningFactoringLabyrinthKnightTourSolitaireRandomQBFRLPRandomNonTight−++−++−−−−+−−601555160382410261102515282220#atoms32 956.72002.0111 856.53544.449 402.31378.23336.855 604.923 156.911 486.8160.1200.0200.0Horn bd(%)stdev4.286.0310.7419.473.808.4325.763.4233.0838.8849.6967.2689.850.080.041.710.790.702.121.300.820.200.200.005.420.24ConformantPlanning: secure planning under incomplete initial states [147]; instances provided by Gebser and Kaminski [60]. Factoring: factoriza-tion of a number where an efficient algorithm would yield a cryptographic attack by Gebser [38]; for instances see [61]. HanoiTower: classic Towers of Hanoi puzzle by Truszczynski, Smith and Westlund; for instances see [18]. GraphColoring: classic graph coloring problem by Lierler and Balduccini; for instances see [18]. KnightTour: finding a tour for the knight piece traveling any square following the rules of chess by Zhou, Calimeri, and Santoro; for instances see [18]. Labyrinth: classical Ravensburger’s Labyrinth puzzle by Gebser; for instances see [18]. MinimalDiagnosis: an application in systems biology [67]; for instances see [18]. MSS/MUS: problem whether a clause belongs to some minimal unsatisfiable subset [94]; instances provided by Gebser and Kaminski [60]. Solitaire: classical Peg Solitaire puzzle by Lierler and Balduccini; for instances see [18]. StrategicCompanies: encoding the Σ P2 -complete problem of producing and owning companies and strategic sets between the companies [63]. RandomQBF: translations of randomly generated 2-QBF instances using the method by Chen and Interian [20]; for instances see [63]. RLP: Randomly generated normal programs, of various density (number of rules divided by the number of atoms) [155]; for instances see [63]. RandomNonTight: Randomly generated normal programs in [61]with n = 40, 50, and 60 variables, respectively with 40 instances per step instances.The results obtained with ILP methods using modern solvers like CPLEX and Gurobi come along with a certain inaccuracy (see e.g., [25,24,140]). Therefore, we ran Clasp on the structured instances using the encoding of k-vertex cover problem described above to obtain optimality.Table 1 illustrates our results on the size of small strong Horn-backdoors of the considered benchmark instances. We mainly used benchmark sets from the first three Answer Set Programming Competitions [18,29,63], because most of the instances contain only normal and/or disjunctive rules and no extended rules (cardinality/weight-constraints).3 We reference in the caption of Table 1 from where the instances have been taken and indicate in the table the number of instances of each benchmark set.The structured instances have, as expected, significantly smaller strong Horn-backdoors than the random instances. We would like to mention that the random programs from the ASP competitions contain a rather small number of atoms. So far we have no good evidence why in particular the sets KnightTour and Solitaire have rather large strong Horn-backdoors compared to other structured instances.5. Target classes based on acyclicityThere are two causes for a program to have a large number of answer sets: (i) disjunctions in the heads of rules, and (ii) certain cyclic dependencies between rules. Disallowing both yields enumerable classes.In order to define acyclicity we associate with each disjunctive program P its dependency digraph D P and its (undirected) dependency graph U P . The dependency digraph was defined by Apt et al. [2] which slight differs from our notion as no additional edges on head atoms are introduced. The following definition is closely related to the notion suggested by Gottlob et al. [85].Definition 5.1. Let P be a program. The dependency digraph is the digraph D P which has as vertices the atoms of P and a −(r)directed edge (x, y) between any two distinct atoms x, y for which there is a rule r ∈ P with x ∈ H(r) and y ∈ Bor x, y ∈ H(r). We call the edge (x, y) negative if there is a rule r ∈ P with x ∈ H(r) and y ∈ B−(r) or x, y ∈ H(r).+(r) ∪ BDefinition 5.2. Let P be a program. The (undirected) dependency graph is the graph U P obtained from the dependency digraph D p1. by replacing each negative edge e = (x, y) with two edges xve , ve y where ve is a new negative vertex, and2. by replacing each remaining directed edge (u, v) with an edge uv.3 We are aware that one can preprocess extended rules and compile them into normal rules. Even though recent versions of the solver Clasp provide such an option [66], those compilations blow up the instances significantly. Hence we omitted it for pragmatic reasons.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10377Fig. 3. Dependency digraph D P (left) and dependency graph U P (right) of the program P of Example 2.1.Example 5.1. Fig. 3 visualizes the dependency digraph D P and the dependency graph U p of the program P of Example 2.1.Definition 5.3. Let P be a program.1. A directed cycle of P is a directed cycle in the dependency digraph D P .2. A directed cycle is bad if it contains a negative edge, otherwise it is good.3. A directed cycle is even if it contains an even number of negative edges, otherwise it is odd.4. A cycle of P is a cycle in the dependency graph U P .5. A cycle is bad if it contains a negative vertex, otherwise it is good.6. A cycle is even if it contains an even number of negative vertices, otherwise it is odd.Definition 5.4. The following classes of programs are defined in terms of the absence of certain kinds of cycles:• no-C contains all programs that have no cycles,• no-BC contains all programs that have no bad cycles,• no-DC contains all programs that have no directed cycles,• no-DC2 contains all programs that have no directed cycles of length at least 3 and no directed bad cycles,• no-DBC contains all programs that have no directed bad cycles,• no-EC contains all programs that have no even cycles,• no-BEC contains all programs that have no bad even cycles,• no-DEC contains all programs that have no directed even cycles, and• no-DBEC contains all programs that have no directed bad even cycles.We let Acyc denote the family of all the nine classes defined above. We also write D-Acyc to denote the subfamily {no-DC,no-DC2, no-DBC, no-DEC, no-DBEC} ⊆ Acyc.Example 5.2. Consider the dependency graphs of the program P of Example 2.1 as depicted in Fig. 3. For instance the sequence (d, e, f ) is a cycle, (d, a) is a directed cycle (of length 2), (d, e, f ) and (c, e, f ) are directed cycles (of length 3), (a, v(a,c), c, d) is a bad cycle, (b, c) is a directed bad cycle. The sequence (d, e, f ) is an even cycle and a directed even cycle, (c, e) is a directed bad even cycle.The set X = {c} is a strong no-DBEC-backdoor since the truth assignment reducts P c=0 = P 0 = {d ← a, e; a ← d, ¬b; e ←f ; f } and P 1 = {d ← a, e; f ← d; b; f } are in the target class no-DBEC. X is also a strong no-BEC-backdoor, since P 0 ∈ no-BEC and P 1 ∈ no-BEC. The answer sets of P τ are AS(P ¯c) = {{e, f }} and AS(P c) = {{b, f }}. Thus, AS(P , X) ={{e, f }, {b, c, f }}, and since only {b, c, f } is an answer set of P , we obtain AS(P ) = {{b, c, f }}.The dependency and dependency digraphs contain bad even cycles through head atoms for non-singleton heads. This has the following consequence.Observation 5.5. C ⊆ Normal holds for all C ∈ Acyc.If we have two programs P ⊆ P(cid:11), then clearly the dependency (di)graph of P is a sub(di)graph of the dependency (di)graph of P. This has the following consequence.(cid:11)Observation 5.6. All C ∈ Acyc are hereditary.78J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Fig. 4. Relationship between classes of programs with respect to their generality. A directed path from a class C to a class C(cid:11)is no path between two classes C and C(cid:11)nor C(cid:11) ⊆ C and we say C and C(cid:11), then neither C ⊆ C(cid:11)are incomparable.indicates that C ⊆ C(cid:11). If there The following is a direct consequence of the definitions of the various classes in Acyc .Observation 5.7. If C, C(cid:11) ∈ Acyc ∪ {Horn} such that the digraph in Fig. 4 contains a directed path from the class C to the class C(cid:11)C ⊆ C(cid:11). If no inclusion between two classes is indicated, then the classes are in fact incomparable., then Proof. We first consider the acyclicity-based target classes. By definition we have no-DC (cid:2) no-DBC and no-C (cid:2) no-BC (cid:2)no-DBC; it is easy to see that the inclusions are proper. However, contrary to what one expects, no-C (cid:3) no-DC, which can be seen by considering the program P 1 = {x ← y, y ← x}. But the class no-DC2 which requires that a program has no directed cycles but may have directed good cycles of length 2 (as in P 1) generalizes both classes no-C and no-DC. By definition we have no-DBC (cid:2) no-DBEC, no-DEC (cid:2) no-DBEC, no-EC (cid:2) no-BEC, no-C (cid:2) no-EC, and no-DC (cid:2) no-DEC.Next we consider the target class Horn. Let C ∈ {no-C, no-DC, no-DC2, no-EC}. We easily observe that Horn (cid:3) C by considering the program P 2 = {a ← b; b ← c; c ← a} which is obviously Horn but does not belong to C. Conversely, we observe that C (cid:3) Horn by considering the program P 3 = {a ← ¬b} which belongs to C but is obviously not Horn. Thus, Cand Horn are incomparable. We observe that Horn (cid:2) no-BC by again considering the program P 3 which belongs to no-BC, −(r) = ∅but is obviously not Horn, and by considering the fact that all rules r in a Horn program P satisfy |H(r)| ≤ 1 and Bwhich yields that the dependency graph U P contains no bad vertices and hence gives us that U P contains no bad cycles. (cid:2)The class no-DBC coincides with the well-known class of stratified programs [2,77,19]. A normal program P is stratifiedif there is a mapping str : at(P ) → N, called stratification, such that for each rule r in P the following holds: (i) if x ∈ H(r)and y ∈ B+(r), then str(x) ≤ str( y) and (ii) if x ∈ H(r) and y ∈ B−(r), then str(x) < str( y).Lemma 5.8. (See Apt et al. [2].) Strat = no-DBC.The class no-DBEC, the largest class in Acyc, has already been studied by Zhao and Lin [156,110], who showed that every program in no-DBEC has at most one answer set, and this answer set can be found in polynomial time. For no-DBC the unique answer set can even be found in linear time [121].In our context this has the following important consequence.Proposition 5.9. All classes in Acyc are enumerable, the classes C ∈ Acyc with C ⊆ no-DBC are even linear-time enumerable.In view of Observation 5.5 and Proposition 5.9, all classes in Acyc satisfy the requirement of Theorem 3.9 and are there-fore in principle suitable target classes of a backdoor approach. Therefore we will study the parameterized complexity of Strong C-Backdoor Detection and Deletion C-Backdoor Detection for C ∈ Acyc. As we shall see in the next two subsec-tions, the results for Strong C-Backdoor Detection are throughout negative, however for Deletion C-Backdoor Detectionthere are several (fixed-parameter) tractable cases.5.1. Strong backdoor detectionProposition 5.10. Assume that the input program may contain tautological rules. Then, for every target class C ∈ Acyc, the problem Strong C-Backdoor Detection is W[2]-hard, and hence unlikely to be fixed-parameter tractable.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10379jjjjjjijijijij(cid:2)+(r+(s}, B}, B}, Bi ) = {aProof. We give an fpt-reduction from the W[2]-complete problem Hitting Set (see Section 2.3) to Strong C-BackdoorDetection. Let (S, k) be an instance of this problem with S = {S1, . . . , Sm}. We construct a program P as follows. As atoms for 1 ≤ i ≤ m, 1 ≤ j ≤ k + 1. For each 1 ≤ i ≤ m and we take the elements of U =i and b−(r1 ≤ j ≤ k + 1 we take two rules ri ) = S i (which is a tautological rule); }, B−(sjH(sji ) = {bWe show that S has a hitting set of size at most k if and only if P has a strong C-backdoor of size at most k.(⇒) Let H an hitting set of S of size at most k. We choose an arbitrary truth assignment τ ∈ 2H and show that P τ ∈ C . ji , i will be removed when forming P τ . Hence the only rules left in P τ are the rules smi=1 S i and new atoms ajji ) = {ai , si where H(rii ) = ∅.Since H is a hitting set, each rule rand so P τ ∈ no-DC ∩ no-C ⊆ C. Thus, H is a strong C-backdoor of P .i ) = S i ∪ {b(⇐) Let X be a strong C-backdoor of P of size at most k. We show that H = X ∩ U is a hitting set of S. Choose 1 ≤ i ≤ mand consider S i . We first consider the case no-DC ⊆ C. For each 1 ≤ j ≤ k + 1 the program P contains a bad even directed i ). In order to destroy these cycles, X must contain an atom from S i , since otherwise, X would need to contain cycle (afor each 1 ≤ j ≤ k + 1 at least one of the atoms from each cycle, but then | X| ≥ k + 1, contradicting the assumption on the size of X . Hence H is a hitting set of S. Now we consider the case no-C ⊆ C. For each 1 ≤ j ≤ k + 1 the program P contains a bad even cycle (a). In order to destroy these cycles, X must contain an atom from S i , since otherwise, X would need to contain an atom from each cycle, again a contradiction. Hence H is a hitting set of S. Consequently, the W[2]-hardness of Strong C-Backdoor Detection follows. (cid:2)i , vi , vi , bji ,bji ,a, bjijibajjjjjFor the target classes in D-Acyc we can avoid the use of tautological rules in the reduction and so strengthen Propo-sition 5.10 as follows (it would be interesting to know if this is also possible for the remaining classes mentioned in Proposition 5.10).Theorem 5.11. For every target class C ∈ D-Acyc, the problem Strong C-Backdoor Detection is W[2]-hard, and hence unlikely to be fixed-parameter tractable.Proof. In order to show that Strong C-Backdoor Detection is W[2]-hard for C ∈ D-Acyc when we forbid tautological rules jin the input, we modify the reduction used in the proof of Proposition 5.10 from Hitting Set by redefining the rules ri . ji ) = U . By the very same argument i ) = {bWe put H(ras in the proof of Proposition 5.10 we can show that S has a hitting set of size at most k if and only if P has a strong C-backdoor of size at most k. We would like to mention that this reduction does not work for the undirected cases as it yields undirected cycles (b(cid:11)) for any u, ui ) = ∅; H(si ) = S i ∪ {b(cid:11) ∈ U . (cid:2)i ) = {ai ) = {a}, B}, B}, B}, Bi , s+(s−(s−(r+(rjijijijijjjjjjjj(cid:11)i , u, bi(cid:11) , uFor the class no-DBEC we can again strengthen the result and show that detecting a strong no-DBEC-backdoor is already co-NP-hard for backdoor size 0; hence the problem is co-paraNP-hard (see Section 2.3).Theorem 5.12. The problem Strong no-DBEC-Backdoor Detection is co-paraNP-hard, and hence not fixed-parameter tractable unless P = co-NP.Proof. Recall that a path does not visit the same vertex twice. We reduce from the following problem, which is NP-complete [52,104],Directed Path via a NodeGiven: A digraph G and s, m, t ∈ V distinct vertices.Task:Decide whether G contains a directed path from s to t via m.Let G = (V , E) be a digraph and s, m, t ∈ V distinct vertices. We define a program P as follows: For each edge e = (v, w) ∈ Ewhere w (cid:10)= m we take a rule re : w ← v. For each edge e = (v, m) we take a rule re : m ← ¬v. Finally we add the rule rs,t : s ← ¬t. We observe that the dependency digraph of P is exactly the digraph we obtain from G by adding the “reverse” edge (t, s) (if not already present), and by marking (t, s) and all incoming edges of m as negative.We show that G has a path from s to t via m if and only if P /∈ no-DBEC. Assume G has such a path. Then this path must contain exactly one incoming edge of m, and hence it contains exactly one negative edge. The path, together with the negative edge (t, s), forms a directed bad even cycle of P , hence P /∈ no-DBEC. Conversely, assume P /∈ no-DBEC. Hence the dependency digraph of P contains a directed bad even cycle, i.e., a cycle that contains at least two negative edges. As it can contain at most one incoming edge of m, the cycle contains exactly one incoming edge of m and the reverse edge (t, s). Consequently, the cycle induces in G a directed path from s to t via m. (cid:2)80J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Fig. 5. Known complexity of the problem Strong C-Backdoor Detection. † When we allow tautologies in the input program, see Theorem 5.11.Fig. 5 illustrates the known complexity results of the problem Strong C-Backdoor Detection. An arrow from C to C(cid:11)-backdoor is at most the size of a is a proper subset of C and hence the size of a smallest strong C(cid:11)indicates that C(cid:11)smallest strong C-backdoor.Remark. Note that the unparameterized version of Strong C-Backdoor Detection for the acyclicity-based target classes Cis NP-hard since W[2]-hardness implies NP-hardness and co-paraNP-hardness also implies co-NP-hardness. Moreover, the reduction presented in the proof of Proposition 5.10 and Theorems 5.11, 5.12 can be used straightforward as a reduction of the unparameterized version of Hitting Set, Directed Path via a Node respectively, to Strong C-Backdoor Detection.5.2. Deletion backdoor detectionThe W[2]-hardness results of Theorems 5.11 and 5.12 suggest to relax the problem and to look for deletion backdoorsinstead of strong backdoors. In view of Lemma 3.4 and Observation 5.6, every deletion backdoor is also a strong backdoor for the considered acyclicity-based target classes, hence the backdoor approach of Theorem 3.9 works.Fortunately, the results of this section show that the relaxation indeed gives us fixed-parameter tractability of backdoor detection for most considered classes. Fig. 6 illustrates these results that we obtain by making use of very recent progress in fixed-parameter algorithmics on various variants of feedback vertex set and cycle transversal problems.Consider a graph G = (V , E) and a set W ⊆ V . A cycle in G is a W -cycle if it contains at least one vertex from W . A set T ⊆ V is a W -cycle transversal of G if every W -cycle of G is also a T -cycle. A set T ⊆ V is an even-length W -cycle transversalof G if every W -cycle of G of even length is also a T -cycle. A V -cycle transversal is also called a feedback vertex set.We give analog definitions for a digraph G = (V , E) and W ⊆ V . A directed cycle in G is a directed W -cycle if it contains at least on vertex from W . A set T ⊆ V is a directed W -cycle transversal of G if every directed W -cycle of G is also a directed T -cycle. A set T ⊆ V is an directed even-length W -cycle transversal of G if every directed W -cycle of G of even length is also a directed T -cycle. A directed V -cycle transversal is also called a directed feedback vertex set.Theorem 5.13. The problem Deletion C-Backdoor Detection is fixed-parameter tractable for all C ∈ Acyc \ {no-DEC, no-DBEC}.Proof. Let P be a program and k ≥ 0. Let U p be the dependency graph and D p the dependency digraph of P , respectively. Next we consider the various target classes C mentioned in the statement of the theorem, one by one, and show how we can decide whether P has a deletion C-backdoor of size at most k.First we consider “undirected” target classes. Downey and Fellows [34,35] have shown that finding a feedback vertex set of size at most k is fixed-parameter tractable. We apply their algorithm to the dependency graph U p . If the algo-rithm produces a feedback vertex set S of size at most k, then we can form a deletion no-C-backdoor of P of size at most k by replacing each negative vertex in S by one of its two neighbors, which always gives rise to an atom of P . If U p has no feedback vertex set of size at most k, then P has no deletion no-C-backdoor of size at most k. Hence Deletion no-C-Backdoor Detection is fixed-parameter tractable. Similarly, Deletion no-BC-Backdoor Detection is fixed-parameter tractable by finding a W -feedback vertex set of U p , taking as W the set of bad vertices of U p . Cygan et al. [26]and Kawarabayashi and Kobayashi [102] showed that finding a W -feedback vertex set is fixed-parameter tractable, hence so is Deletion no-BC-Backdoor Detection.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10381Fig. 6. Relationship between classes of programs and known complexity of the problem Deletion C-Backdoor Detection. An arrow from C to C(cid:11)that deletion C-backdoors are smaller than deletion C(cid:11)Theorem 5.15. The co-paraNP-hardness result is established in Theorem 5.16.indicates -backdoors. The FPT-results are established in Theorems 4.4 and 5.13. The XP-result is established in In order to extend this approach to Deletion no-EC-Backdoor Detection, we would like to use fixed-parameter tractabil-ity of finding an even W -cycle transversal, which was established by Misra et al. [116] for W = V , and by Kakimura et al. [98] for general W . In order to do this, we use the following trick of Aracena, Gajardo, and Montalva [117] that turns cy-(cid:11)cles containing an even number of bad vertices into cycles of even length. From D p we obtain a graph Up by replacing each negative edge e = (x, y) with three edges xue , ue ve , and ve y where ue and ve are new negative vertices, and by replacing each remaining directed edge (u, v) with two edges u we and we v where we is a new (non-negative) vertex. We observe (cid:11)p can be seen as being obtained from D p by subdividing edges. Hence there is a natural 1-to-1 correspondence be-that U(cid:11)p . Moreover, a cycle of U p containing an even number of negative vertices corresponds tween cycles in U p and cycles in U(cid:11)to a cycle of Up . Thus, when we have an even cycle (cid:11)p , we obtain a deletion no-EC-backdoor by replacing each negative vertex v ∈ S by its non-negative neigh-transversal S of Ubor. Hence Deletion no-EC-Backdoor Detection is fixed-parameter tractable. For Deletion no-BEC-Backdoor Detection we proceed similarly, using a even W -cycle transversal of U(cid:11)p of even length, and a bad cycle of U p corresponds to a bad cycle of U(cid:11)p , letting W be the set of negative vertices of UWe now proceed with the remaining “directed” target classes no-DC, no-DC2, and no-DBC.Let G = (V , E) be a digraph. Evidently, the directed feedback vertex sets of D p are exactly the deletion no-DC-backdoors of P . Hence, by using the fixed-parameter algorithm of Chen et al. [21] for finding directed feedback vertex sets we obtain fixed-parameter tractability of Deletion no-DC-Backdoor Detection.To make this work for Deletion no-DC2-Backdoor Detection we consider instead of D p the digraph D(cid:11)p obtained from D p by replacing each negative edge e = (u, v) by two (non-negative) edges (u, we), (we, v), where we is a new vertex. The (cid:11)directed cycles of D p and Dp correspond to good cycles of length 2 in D p . Bonsma and Lokshtanov [12] showed that finding a directed feedback vertex set that only needs (cid:11)p (and replacing each vertex weto cut cycles of length at least 3 is fixed-parameter tractable. Applying this algorithm to Din a solution with one of its neighbors) yields fixed-parameter tractability of Deletion no-DC2-Backdoor Detection.(cid:11)p are in a 1-to-1 correspondence. However, directed cycles of length 2 in D(cid:11)p .The approach for Deletion no-DC-Backdoor Detection extends to Deletion no-DBC-Backdoor Detection by consider-(cid:11)ing directed W -feedback vertex sets of the digraph Dp obtained from D p using a simple construction already mentioned by Cygan et al. [26] where we replace each negative edge e = (u, v) by two (non-negative) edges (u, we), (we, v) and (cid:11)W = {we : e is a negative edge}. The directed W -cycles of Dp and the directed bad cycles of D p are obviously in a 1-to-1 (cid:11)correspondence. Thus, when we have a directed W -feedback vertex set S of Dp , we obtain a deletion no-DBC-backdoor by replacing each vertex v ∈ S ∩ W by its neighbor. The fixed-parameter tractability of finding a directed W -feedback vertex set was shown by Chitnis et al. [23]. (cid:2)According to Observation 5.6, the classes mentioned in Theorem 5.13 are hereditary. Hence using Theorem 5.13 we can drop the assumption in Theorem 3.9 that the backdoor is given. We obtain directly the following results:Theorem 5.14. For all C ∈ Acyc \ {no-DEC, no-DBEC} all problems in AspFull are fixed-parameter tractable when parameterized by the size of a smallest deletion C-backdoor.Let us now turn to the two classes no-DEC, no-DBEC excluded in Theorem 5.13. We cannot establish that Deletion no-DEC-Backdoor Detection is fixed-parameter tractable, as the underlying even cycle transversal problem seems to be currently out of reach to be solved. However, in Theorem 5.15 below, we can at least show that for every constant k, we 82J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103can decide in polynomial time whether a strong no-DEC-backdoor of size at most k exists; thus, the problem is in XP. For Deletion no-DBEC-Backdoor Detection the situation is different: here we can rule out fixed-parameter tractability under the complexity theoretical assumption P (cid:10)= co-NP (Theorem 5.16).Theorem 5.15. The problem Deletion no-DEC-Backdoor Detection is in XP.Proof. Let P be a program, n the input size of P , and k be a constant. We are interested in a deletion no-DEC-backdoor of P of size at most k. We loop over all possible sets X ⊆ at(P ) of size at most k. Since k is a constant, there is a polynomial number O(nk) of such sets X . To decide whether X is a deletion no-DEC-backdoor of P , we need to check whether P − X ∈no-DEC. For the membership check P − X ∈ no-DEC we have to decide whether D P − X contains a bad even cycle. We use a directed variant of the trick in the proof of Theorem 5.13 (in fact, the directed version is slightly simpler). Let D P − X be the (cid:11)dependency digraph of P − X . From D P − X we obtain a new digraph DP − X by subdividing every non-negative edge, i.e., we replace each non-negative edge e = (x, y) by two (non-negative) edges (x, ue), (ue, y) where ue is a new vertex. Obviously, (cid:11)directed even cycles in D P − X are in 1-to-1 correspondence with directed cycles of even length in DP − X . Whether a digraph contains a directed cycle of even length can be checked in polynomial time by means of the following results: Vazirani and Yannakakis [151] have shown that finding a cycle of even length in a digraph is equivalent to finding a so-called Pfaffian orientation of a graph. Robertson, Seymour, and Thomas [133] have shown that a Pfaffian orientation can be found in polynomial time, hence the test works in polynomial time. (cid:2)Theorem 5.16. The problem Deletion no-DBEC-Backdoor Detection is co-paraNP-hard, and hence not fixed-parameter tractable unless P = co-NPProof. The theorem follows from the reduction in the proof of Theorem 5.12. (cid:2)Remark. We note that the unparameterized version of Deletion C-Backdoor Detection for the acyclicity-based target classes C is NP-hard and co-NP-hard respectively, since the reduction presented in the proof of Theorems 5.13 and 5.15can be used straightforward as a reduction of the unparameterized version of the variants of the minimal feedback vertex set problem, Directed Path via a Node respectively, to Deletion C-Backdoor Detection.5.3. Backdoors of benchmark instancesFor the acyclicity based target classes C ∈ Acyc we have computed small deletion C-backdoors only for very few selected instances with moderate size since the currently available algorithms can only deal with rather small instances within a reasonable computation time. The size of small deletion no-C-backdoors of selected instances of Solitaire was about half of the size of small strong Horn-backdoors.6. KernelizationIf we want to solve a hard problem, then in many settings, it is beneficial to first apply a polynomial preprocessing to a given problem instance. In particular, polynomial-time preprocessing techniques have been developed in ASP solving (see e.g., [45,65,68]). However, polynomial-time preprocessing for NP-hard problems has mainly been subject of empirical studies where provable performance guarantees are missing, mainly due to the fact, that if we can show that we can re-duce in polynomial-time a problem instance by just one bit, then by iterating this reduction we can solve the instances in polynomial time. In contrast, the framework of parameterized complexity offers with the notion of kernelization a useful mathematical framework that admits the rigorous theoretical analysis of polynomial-time preprocessing for NP-hard prob-lems. A kernelization is a polynomial-time reduction that replaces the input by a smaller input, called a “kernel”, whose size is bounded by some computable function of the parameter only. A well known result of parameterized complexity theory is that a decidable problem is fixed-parameter tractable if and only if it admits a kernelization [36]. The result leads us to the question of whether a problem also has a kernelization that reduces instances to a size which is polynomially bounded by the parameter, so-called polynomial kernels. Indeed, many NP-hard optimization problems admit polynomial kernels when parameterized by the size of the solution [134]. In the following we consider kernelizations for backdoor detection and backdoor evaluation in the context of ASP. We establish that for some target classes, backdoor detection admits a polyno-mial kernel. We further provide strong theoretical evidence that for all target classes considered, backdoor evaluation does not admit a polynomial kernel.We will later use the following problem:Vertex CoverA graph G = (V , E) and an integer k.Given:Parameter: The integer k.Task:Decide whether there is a vertex cover S ⊆ V (see Section 4) of size at most k.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10383Next we give a more formal definition of kernelization. Let L, L(cid:11) ⊆ Σ ∗ × N be parameterized problems. A bi-kernelizationis a polynomial-time many-to-one reduction from the problem L to problem Lwhere the size of the output is bounded by a computable function of the parameter. That is, a bi-kernelization is an algorithm that, given an instance (I, k) ∈ Σ ∗ × N(cid:11), koutputs for a constant c in time O(((cid:13)I(cid:13) + k)c) a pair (Iand (cid:11) = L then the reduction (ii) (cid:13)Iis called a kernelization, the reduced instance a kernel. If g is a polynomial then we say that L admits a polynomial bi-kernel, or polynomial kernel if in addition L = L. For instance, the problem Vertex Cover has a kernel of at most 2k vertices and thus admits a polynomial kernel [22]. L is called compressible if it admits a polynomial bi-kernel.(cid:11) ≤ g(k) where g is an arbitrary computable function, called the size of the kernel. If L(cid:11)) ∈ Σ ∗ × N, such that (i) (I, k) ∈ L if and only if (I(cid:11)(cid:13) + k(cid:11)) ∈ L(cid:11), k(cid:11)(cid:11)(cid:11)The following proposition states the connection between fixed-parameter tractable problems and kernels, as observed by Downey, Fellows, and Stege [36]:Proposition 6.1. (See Downey et al. [36], Flum and Grohe [50].) A parameterized problem is fixed-parameter tractable if and only if it is decidable and has a kernelization.Thus, our fixed-parameter tractability results of Theorems 3.9, 4.4, and 5.13 immediately provide that the mentioned problems admit a kernelization. In the following we investigate whether these problems admit polynomial kernels.6.1. Backdoor detectionThe first result of this section is quite positive.Theorem 6.2. For C ∈ {Horn, no-C} the problem Deletion C-Backdoor Detection admits a polynomial kernel. For C = Horn the kernel has a linear number of atoms, for C = no-C the kernel has a quadratic number of atoms.(cid:11)Proof. First consider the case C = Horn. Let (P , k) be an instance of Deletion Horn-Backdoor Detection. We obtain in polynomial time the negation dependency graph N p of P (see Definition 4.2) and consider (N p, k) as an instance of Vertex Cover. We use the kernelization algorithm of Chen et al. [22] for Vertex Cover and reduce in polynomial time (cid:11)) where G = (V , E) with at most 2k many vertices. It remains to translate G into a (N p, k) to a Vertex Cover instance (G, k(cid:11)) is a polynomial kernel with a linear program Pnumber of atoms.where N p(cid:11) = G by taking for every edge xy ∈ E a rule x ← ¬ y. Now (PSecond consider the case C = no-C. Let (P , k) be an instance of Deletion no-C-Backdoor Detection. We obtain in poly-nomial time the dependency graph U p of P and consider (U p, k) as an instance of Feedback Vertex Set (see Section 5.2). We use the kernelization algorithm of Thomassé [146] for Feedback Vertex Set and reduce in polynomial time (U p, k) to a (cid:11), kFeedback Vertex Set instance (Gwhere (cid:11)) is a polynomial kernel with a quadratic number of U p(cid:11) = G by taking for every edge xy ∈ E a rule x ← ¬ y. Now (Patoms. (cid:2)(cid:11)) with at most 4k2 vertices. As above we translate G = (V , E) into a program P(cid:11), k(cid:11), k(cid:11)Similar to the construction in the proof of Theorem 5.13 we can reduce for the remaining classes the backdoor detection problem to variants of feedback vertex set. However, for the other variants of feedback vertex set no polynomial kernels are known.We would like to point out that the kernels obtained in the proof of Theorem 6.2 are equivalent to the input program with respect to the existence of a backdoor, hence the kernels can be used to find a backdoor. However the obtained kernels are not equivalent with respect to the decision of the problems in AspReason , in consequence the kernel cannot be used for backdoor evaluation. In the next subsection we consider kernels with respect to problems in AspReason .6.2. Backdoor evaluationNext we consider the problems in AspReason . We will see that neither of them admits a polynomial kernel when pa-rameterized by the size of a strong C-backdoor for the considered target classes, subject to standard complexity theoretical assumptions.Our superpolynomial lower bounds for kernel size are based on a result by Fortnow and Santhanam [51] regarding satisfiability parameterized by the number of variables.Sat[Vars]A CNF formula F .Given:Parameter: The number k of variables of F .Decide whether F is satisfiable.Task:Proposition 6.3. (See Fortnow and Santhanam [51].) If Sat[Vars] is compressible, then NP ⊆ co-NP/poly.84J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103The complexity class NP/poly consists of all problems that can be solved non-deterministically in non-uniform poly-nomial time, i.e., by a non-deterministic polynomial-time Turing machine with an additional polynomial-bounded input that depends only on the length of the input, but not on the input itself (advice function), for details see e.g., [100]. It is well-known from Yap’s Theorem [154] that if NP ⊆ co-NP/poly then the Polynomial Hierarchy collapses to its third level (Σ P3The following theorem extends a result for normal programs [58]. We need a different line of argument, as the technique 3 ) which is considered unlikely by standard complexity theoretical assumptions.= Π pused in [58] only applies to problems in NP or co-NP.Theorem 6.4. Let C ∈ Acyc ∪ {Horn}. Then no problem in AspReason admits a polynomial kernel when parameterized by the size of a smallest strong C-backdoor or deletion C-backdoor, unless NP ⊆ co-NP/poly.Proof. We show that the existence of a polynomial kernel for any of the above problems implies that Sat[Vars] is com-pressible, and hence by Proposition 6.3 the collapse would follow.First consider the problem Consistency. From a CNF formula F with k variables we use a reduction of Niemelä [122] and construct a program P 1 as follows: Among the atoms of our program P 1 will be two atoms ax and a¯x for each variable x ∈var(F ), an atom bC for each clause C ∈ F . We add the rules a¯x ← ¬ax and ax ← ¬a¯x for each variable x ∈ var(F ). For each clause C ∈ F we add for each x ∈ C the rule bC ← ax and for each ¬x ∈ C the rule bC ← a¯x. Additionally, for each clause C ∈ F we add the rule ← ¬bC . Now it is easy to see that the formula F is satisfiable if and only if the program P 1has an answer set. We observe that X = {ax : x ∈ var(F )} ( X = {ax, a¯x : x ∈ var(F )}) is a smallest deletion (and smallest strong) C-backdoor of P 1 for each C ∈ Acyc (C = Horn). Hence (P 1, k), (P 1, 2k) respectively, is an instance of Consistency, parameterized by the size of a smallest strong C-backdoor or deletion C-backdoor, and if this problem would admit a polynomial kernel, this would imply that Sat[Vars] is compressible.For the problem Brave Reasoning we modify the reduction from above. We create a program P 2 that consists of all +(r) = ∅, and atoms and rules from P 1. Additionally, the program P 2 contains an atom t and a rule r with H(r) = {t}, B−(r) = ∅. We observe that the formula F is satisfiable if and only if the atom t is contained in some answer set of P 2. BSince X is still a backdoor of size k (2k), and a polynomial kernel for Brave Reasoning, again it would yield that Sat[Vars]is compressible.Let UnSat[Vars] denote the problem defined exactly like Sat[Vars], just with yes and no answers swapped. A bi-kernelization for UnSat[Vars] is also a bi-kernelization for Sat[Vars] (with yes and no answers swapped). Hence Sat[Vars]is compressible if and only if UnSat[Vars] is compressible. An argument dual to the previous one for Brave Reasoningshows that a polynomial kernel for Skeptical Reasoning, parameterized by backdoor size, would yield that UnSat[Vars] is compressible, which, as argued above, would yield that Sat[Vars] is compressible. (cid:2)7. Lifting parametersIn this section we will introduce a general method to lift ASP-parameters that are defined for normal programs to disjunctive programs. Thereby we extend several algorithms that have been suggested for normal programs to disjunctive programs. The lifting method also gives us an alternative approach to obtain some results of Section 5.The following definition allows us to speak about parameters for programs in a more abstract way.(cid:11)) ≤ p(P ) holds whenever PDefinition 7.1. An ASP-parameter is a function p that assigns to every program P some non-negative integer p(P ) such that is obtained from P by deleting rules or deleting atoms from rules. If p is only defined p(Pfor normal programs, we call it a normal ASP-parameter. For an ASP parameter p we write pto denote the ASP-parameter obtained by restricting p to normal programs.↓(cid:11)We impose the condition p(P(cid:11)) ≤ p(P ) for technical reasons. This is not a limitation, as most reasonable parameters and all parameters considered in this paper satisfy this condition.There are natural ASP-parameters associated with backdoors:Definition 7.2. For a class C of programs and a program P let sbC(P ) denote the size of a smallest strong C-backdoor and dbC(P ) denote the size of a smallest deletion C-backdoor of P .We will “lift” normal ASP-parameters to general disjunctive programs as follows.Definition 7.3. For a normal ASP-parameter p we define the ASP-parameter p↑(P ) as the minimum of | X| + p(P − X) over all inclusion-minimal deletion Normal-backdoors X of P .pby setting, for each disjunctive program P , ↑The next lemma shows that this definition is compatible with deletion C-backdoors if C ⊆ Normal. In other words, if Cis a class of normal programs, then we can divide the task of finding a deletion C-backdoor for a program P into two parts: (i) to find a deletion Normal-backdoor X , and (ii) to find a deletion C-backdoor of P − X .Lemma 7.4 (Self-lifting). Let C be a class of normal programs. Then dbC(P ) = (db↓C)↑(P ) for every program P .J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10385Proof. Let C be a class of normal programs, and P a program. Let X be a deletion C-backdoor of P of size dbC(P ). Thus, P − X ∈ C ⊆ Normal. Hence X is a deletion Normal-backdoor of P . We select an inclusion-minimal subset Xof X that (cid:11) = X , and then looping over all the elements x of X , is still a deletion Normal-backdoor of P (say, by starting with X(cid:11) \ {x}). What we end up with is an inclusion-minimal (cid:11) := X(cid:11) \ {x} is still a deletion C-backdoor, then setting Xand if X(cid:11)is a normal program. Since deletion Normal-backdoor X↑C , we Phave that db(cid:11)(cid:11) = X \ Xis a deletion C-backdoor of P . Thus, by the definition of dbof P of size at most dbC(P ). Let P(cid:11)(cid:11) ∈ C. Hence X(cid:11)(cid:11) = P − X , it follows that P(cid:11) − X(cid:11)(cid:11)| = dbC(P ).(cid:11) = P − X↑(cid:11)| + | XC(P ) ≤ | X↑C(P ) = k. Hence there is a deletion Normal-backdoor XConversely, let db(cid:11)of P such that | X(cid:11)| + dbC(P − Xand X(cid:11) − X. P(cid:11)) ≤ k − | X(cid:11) − X(cid:11)|, it follows that Pof size k − | X(cid:11)(cid:11) ∈ C. Hence X is a deletion C-backdoor of P . Since dbC(P ) ≤ | X| ≤ | Xhas a deletion C-backdoor X(cid:11)|. We put X = X(cid:11)| + | X(cid:11)(cid:11)| ≤ db(cid:11)) = k. Let (cid:11) ∪ X(cid:11)(cid:11)↑C(P ) ≤ k, (cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11)(cid:11) = P − X. Since dbC(PPand observe that P − X = Pthe lemma follows. (cid:2)We determine #negExample 7.1. Consider the program P of Example 2.1 and let #neg(P ) denote the number of atoms that appear in negative rule bodies of a normal program (we will discuss this parameter in more detail in Section 8.2).↑(P ) = 2 by the following observations: The set X1 = {c} is a deletion Normal-backdoor of P since P − X1 = {d ← a, e; a ← d, ¬b; e ← f ; f ← d; ← f , e, ¬b; ← d; b; f } belongs to the class Normal. The set X2 = {e} is a deletion Normal-backdoor of P since P − X2 = {d ← a; a ← d, ¬b, ¬c; c ← f ; f ← d, c; c ← f , ¬b; c ← d; b ← c; f }belongs to the class Normal. Observe that X1 and X2 are the only inclusion-minimal deletion Normal-backdoors of the ↑(P , X2) = 3 since #neg(P − X2) = 2. Thus, program P . We obtain #neg#neg↑(P , X1) = 2 since #neg(P − X1) = 1. We have #neg↑(P ) = 2.For every ASP-parameter p we consider the following problem.Bound[p]A program P and an integer k.Given:Parameter: The integer k.Task:Decide whether p(P ) ≤ k holds.For a problem L ∈ AspFull and an ASP-parameter p we write L[p] to denote the problem L parameterized by p. That is, the instance of the problem is augmented with an integer k, the parameter, and for the input program P it holds that p(P ) ≤ k. Moreover, we write L[p]N to denote the restriction of L[p] where instances are restricted to normal programs P . Similarly, Bound[p]N is the restriction of Bound[p] to normal programs. For all the problems L[p]N, p only needs to be a normal ASP-parameter.Next we state the main result of this section.Theorem 7.5 (Lifting). Let p be a normal ASP-parameter such that Bound[p]N and Enum[p]N are fixed-parameter tractable. Then for all L ∈ AspFull the problem L[p↑] is fixed-parameter tractable.We need some definitions and auxiliary results to establish the theorem.Definition 7.6. Let P be a disjunctive program. The head dependency graph H P of the program P is the graph which has as vertices the atoms of P and an edge between any two distinct atoms if they appear together in the head of a rule of P .Lemma 7.7. Let P be a disjunctive program. A set X ⊆ at(P ) is a deletion Normal-backdoor of P if and only if X is a vertex cover of the head dependency graph H P .Proof. Let X be a deletion Normal-backdoor of P . Consider an edge uv of H P , then there is a rule r ∈ P with u, v ∈ H(r)and u (cid:10)= v. Since X is a deletion Normal-backdoor of P , we have {u, v} ∩ X (cid:10)= ∅. We conclude that X is a vertex cover of H P .Conversely, assume that X is a vertex cover of H P . We show that X is a deletion Normal-backdoor of P . Assume to the contrary, that P − X contains a rule r whose head contains two variables u, v. Consequently, there is an edge uv in H Psuch that {u, v} ∩ X = ∅, contradicting the assumption that X is a vertex cover. (cid:2)Lemma 7.8. Let G = (V , E) be a graph, n = |E|, and let k be a non-negative integer. G has at most 2k inclusion-minimal vertex covers of size at most k, and we can list all such vertex covers in time O(2kn).86J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Proof. We build a binary search tree T of depth at most k where each node t of T is labeled with a set St . We build the tree recursively, starting with the root r with label Sr = ∅. If St is a vertex cover of G we stop the current branch, and tbecomes a “success” leaf of T . If t is of distance k from the root and St is not a vertex cover of G, then we also stop the current branch, and t becomes a “failure” leaf of T . It remains to consider the case where St is not a vertex cover and t is of distance smaller than k from the root. We pick an edge uv ∈ E such that u, v /∈ St (such edge exists, otherwise St would be to t with labels St(cid:11) = St ∪ {u} and St(cid:11)(cid:11) = St ∪ {v}. It is easy to see that for every a vertex cover) and add two children tinclusion-minimal vertex cover S of G of size at most k there is a success leaf t with St = S. Since T has O(2k) nodes, the lemma follows. (cid:2)(cid:11), t(cid:11)(cid:11)From Lemmas 7.7 and 7.8 we immediately obtain the next result.Proposition 7.9. Every disjunctive program of input size n has at most 2k inclusion-minimal deletion Normal-backdoors of size at most k, and all these backdoors can be enumerated in time O(2kn).Proof of Theorem 7.5. Let p be a normal ASP-parameter such that Enum[p]N and Bound[p]N are fixed-parameter tractable. ↑(P ) ≤ k. In the following, when we say Let P be a given disjunctive program of input size n and k an integer such that psome task is solvable in “fpt-time”, we mean that it can be solved in time O( f (k)nc) for some computable function f and a constant c.By Proposition 7.9 we can enumerate all inclusion-minimal deletion Normal-backdoors of size at most k in time O(2kn). We can check whether p(P − X) ≤ k −| X| for each such backdoor X in fpt-time since Bound[p]N is fixed-parameter tractable by assumption. Since p↑(P ) ≤ k, there is at least one such set X where the check succeeds.We pick such set X and compute AS(P , X) in fpt-time. That this is possible can be seen as follows. Obviously, for each truth assignment τ ∈ 2 X the program P τ is normal since P − X is normal, and clearly p(P τ ) ≤ p(P − X) ≤ k by Definition 7.1. We can compute AS(P τ ) in fpt-time since Enum[p]N is fixed-parameter tractable by assumption. Since there are at most 2ksuch programs P τ , we can indeed compute the set AS(P , X) in fpt-time.By Lemma 3.6 we have AS(P ) ⊆ AS(P , X), hence it remains to check for each M ∈ AS(P , X) whether it gives rise to an answer set of P . Since X is a deletion Normal-backdoor of P , and since one easily observes that Normal is hereditary, it follows by Lemma 3.4 that X is a strong Normal-backdoor of P . Hence Lemma 3.7 applies, and we can decide whether M ∈ AS(P ) in time O(2kn). Hence we can determine the set AS(P ) in fpt-time. Once we know the set AS(P ), we obtain for every problem L ∈ AspFull that L[p↑] is fixed-parameter tractable. (cid:2)Example 7.2. Consider the program P of Example 2.1 with the deletion Normal-backdoor X1 = {c} from Example 7.1. We want to enumerate all answer sets of P . We obtain with Ben-Eliyahu’s algorithm [4] the sets AS(P ¯c) = {{e, f }} and AS(P c) ={{b, f }}, and so we get the set AS(P , X) = {{e, f }, {b, c, f }} of answer set candidates. By means of the algorithm that solves the problem Strong C-Backdoor Asp Check (see Lemma 3.7) we observe that {b, c, f } is the only answer set of P .Remark. Please note that Definitions 4.2 and 5.1 introduce additional edges or certain cycles, respectively, on head atoms for non-singleton heads in the constructed graphs. This construction has the same effect on the size of smallest deletion backdoors into Horn or acyclicity-based target classes as the lifting of corresponding parameters from normal to disjunctive programs.8. Theoretical comparison of ASP-parametersIn this section we compare several ASP-parameters in terms of their generality. Fig. 7 illustrates the results in terms of a lattice. Let p and q be ASP-parameters. We say that p dominates q (in symbols p (cid:20) q) if there is a function f such that p(P ) ≤ f (q(P )) holds for all programs P . The parameters p and q are similar (in symbols p ∼ q) if p (cid:20) q and q (cid:20) p. The parameter p strictly dominates q (in symbols p ≺ q) if p (cid:20) q but not q (cid:20) p, and p and q are incomparable (in symbols p (cid:23)(cid:24) q) if neither p (cid:20) q nor q (cid:20) p.Observation 8.1. Let p and q be ASP-parameters and L ∈ AspFull . If p dominates q and L[p] ∈ FPT, then also L[q] ∈ FPT.Observation 8.2. Let p and q be normal ASP-parameters and ◦ ∈ {(cid:20), ≺, (cid:23)(cid:24)}. Then p ◦ q if and only if p↑ ◦ q↑.Proof. Let p and q be normal ASP-parameters. We will show that pof (cid:20), this shows the claimed observation.↑ (cid:20) q↑iff p (cid:20) q. Since ≺ and (cid:23)(cid:24) can be defined in terms Assume p↑ (cid:20) q↑. Hence there is a function f such that for all programs P we have p↑(P ) ≤ f (q↑(P )). In particular, if Pis normal we have by Definition 7.3 that p(P ) = p↑(P ) and q(P ) = q↑(P ), hence p(P ) ≤ q(P ), and so p (cid:20) q.Now assume p (cid:20) q. Hence there is a function f such that for all normal programs P we have p(P ) ≤ f (q(P )). Let fbe the monotonic functions on non-negative integers defined by f(cid:11)(n) = max0≤i≤n f (n) and f(cid:11)(cid:11)(n) = f(cid:11)(cid:11)(cid:11)(n) + n. Let P be a (cid:11), fJ.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10387Fig. 7. Domination Lattice (relationship between ASP-parameters when restricted to normal programs). An arrow from p to pstrictly dominates p. Please recall that deptw does not yield tractability (Proposition 8.36). When we do not restrict the parameters to normal programs and apply lifting (Observation 8.60) the parameter #headCycles is not strictly more general. A label i of an edge indicates that Proposition i establishes the result.indicates that p(cid:11)(cid:11)program and X a minimal deletion Normal-backdoor of P . We have | X| + p(P − X) ≤ | X| + f (q(P − X)) ≤ | X| + q(P − X) +(cid:11)(q(P − X)) ≤ | X| + q(P − X) + ff(cid:11)(cid:11)(| X| + q(P − X)). Hence pfollows by Definition 7.3. (cid:2)(cid:11)(| X| + q(P − X)) ≤ f↑ (cid:20) q↑Let C be a class of programs. In the following, we omit ·↓(see Definition 7.1) for the parameters dbC and sbC whenever it is clear from the context that we compare dbC or sbC with a normal ASP-parameter.In the following we define various auxiliary programs which we will use as examples, to separate the parameters from each other and establish incomparability or strictness results.Example 8.1. Let m and n be some large integers. We define the following programs:P n1P n2P n31P n32P n33P n34P n35P n4P n51P n52P n53P n54P n6P n7∪ {a ← d1; di ← di+1 : 1 ≤ i < n} ∪ {ci ← bi; di ← ci; di ← bi : 1 ≤ i ≤ n},∪ {di ← ¬bi : 1 ≤ i ≤ n},\ {a ← ¬bi; bi ← ¬a : 1 ≤ i ≤ n} ∪ {a0 ← ¬a} ∪ {bi ← a0 : 1 ≤ i ≤ n},:= {a ← ¬b1, . . . ,¬ bn},:= {ai ← ¬b : 1 ≤ i ≤ n},:= {bi ← ¬a; a ← ¬bi : 1 ≤ i ≤ n},:= {bi ← a; a ← bi : 1 ≤ i ≤ n},:= P n31:= P n33:= P n33:= {ci ← ¬ai; ci ← bi; bi ← ¬ai; ai ← ei; ei ← di; di ← ai : 1 ≤ i ≤ n},:= {bi ← ¬ai; ai ← ¬bi : 1 ≤ i ≤ n},:= {bi ← ai; ai ← ¬bi : 1 ≤ i ≤ n},:= {bi ← ai; ai ← bi : 1 ≤ i ≤ n},:= {bi ← ai; ci ← bi; ai ← ci : 1 ≤ i ≤ n},:= {a ← b1, . . . , bn, ci : 1 ≤ i ≤ n},:= {a j ← ai : 1 ≤ i < j ≤ n},88J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103P m,n8P n9P n11:= {b ← a1, . . . , am} ∪ {ci ← ci+1 : 1 ≤ i ≤ n} ∪ {cn+1 ← c1},:= {a2 ← ¬a1; a3 ← ¬a2} ∪ {bi ← a3; a1 ← bi : 1 ≤ i ≤ n},:= {ai ∨ b ← c; c ← b; b ← ai : 1 ≤ i ≤ n}.and8.1. ASP-parameters based on backdoor sizeBackdoor-based ASP-parameters can be related to each other in terms of their underlying base classes. We just need a very weak assumption stated in the following which holds for all target classes considered in the paper. Therefore, we need the following definition: A class C of programs is closed under the union of disjoint copies if for every P ∈ C and disjoint copies P 1, . . . , P i of P also P ∪ P 1 ∪ . . . ∪ P i ∈ C. We say a program Pis isomorphic to P and at(P ) ∩ at(Pis a disjoint copy of P if P(cid:11)) = ∅.(cid:11)(cid:11)Proposition 8.3. Let C, C(cid:11), then dbC(cid:11) (cid:20) dbC and sbC(cid:11) (cid:20) sbC , even dbC(cid:11) (P ) ≤ dbC(P ) and sbC(cid:11) (P ) ≤ sbC(P ) for every program P . If C(cid:11) \ C contains a program with at least one atom, then C ⊆ C(cid:11)be classes of programs that are closed under the union of disjoint copies. If C ⊆ C(cid:11)implies dbC(cid:11) ≺ dbC and sbC(cid:11) ≺ sbC .Proof. The first statement is obvious. For the second statement, let P ∈ C(cid:11) \ C with |at(P )| ≥ 1. We construct the program P nconsisting of n disjoint copies of P and observe that P n ∈ C(cid:11)but dbC(P n), sbC(P n) ≥ n. (cid:2)Hence the relationships between target classes as stated in Observation 5.7 carry over to the corresponding backdoor--backdoor is at most the size of a smallest strong then a smallest strong (deletion) C(cid:11)based ASP-parameters that is, if C ⊆ C(cid:11)(deletion) C-backdoor.According to Lemma 3.4 every deletion C-backdoor is a strong C-backdoor if C is hereditary, hence it also holds for smallest backdoors and we immediately get from the definitions:Observation 8.4. If C is hereditary, then sbC dominates dbC .According to Lemma 4.1, every strong Horn-backdoor of a program is a deletion Horn-backdoor and vice versa. Hence we obtain the following statement:Observation 8.5. sbHorn ∼ dbHorn.Observation 8.6. We make the following observations about programs from Example 8.1.2. Consider program P ndbno-DC(P nno-BEC} ∪ D-Acyc.3. Consider program P n4. Consider program P n1. Consider program P n32dbHorn(P ) ≤ 1, dbno-C(P ) ≤ 1, and dbno-DC(P ) ≤ 1. According to Observation 8.3, we have dbC(P nwhere C ∈ {Horn} ∪ Acyc.}. Since P − {a} is Horn and contains no cycle and no directed cycle, we obtain 32) ≤ 131) ≤ 1 and dbC(P n32 and let P ∈ {P n31 and P n31, P n33. Since P n3333) ≤ 1, and dbno-BC(P n− {a} is Horn and contains no directed cycle and no bad cycle, we obtain dbHorn(P n33) ≤ 1. According to Observation 8.3, we have dbC(P n33) = 0, 33) ≤ 1 where C ∈ {Horn, no-BC,34. Since P n4. The negation dependency graph of P n− {a} contains no even cycle, dbno-EC(P n3434) ≤ 1.tion Horn-backdoor are of size at least n. P nn directed even cycles. Hence smallest deletion C-backdoors are of size at least n and thus dbC(P n{Horn, no-C, no-BC, no-DC, no-DC2, no-EC, no-BEC, no-DEC}.4 contains 2n disjoint paths aibi and aici . Thus smallest dele-4 contains n disjoint bad cycles, n directed cycles of length at least 3, and 4) ≥ n where C ∈51 contains n disjoint paths and thus dbHorn(P n51) = n. According to Observation 8.3, we obtain dbC(P n51) = n. P n51 contains 51) ≥ n where 5. Consider program P n51. The negation dependency graph of P nn disjoint directed bad even cycles and thus dbno-DBEC(P nC ∈ {Horn} ∪ Acyc.6. Consider program P n7. Consider program P n52. Since P n54. Since P ndirected even cycles, we obtain by Observation 8.3 dbC(P n52 contains n disjoint directed bad cycles, dbno-DBC(P n54 contains n disjoint even cycles, n disjoint directed cycles of length at least 3, and n disjoint 52) = n.54) ≥ n where C ∈ {no-C, no-DC, no-DC2, no-EC, no-DEC}.8. Consider program P n6. Since P nAccording to Observation 8.3, we have dbC(P n6 is Horn and contains no cycle and no directed cycle, dbHorn(P n6) = 0 where C ∈ {Horn} ∪ Acyc.6) = dbno-C(P n6) = dbno-DC(P n6) = 0. 9. Consider program P n7. Since P n7 is Horn and contains no bad cycle and no directed cycle, dbHorn(P n7) = 0. According to Observation 8.3, we have dbC(P n7) = 0 where C ∈ {Horn, no-BC, no-BEC} ∪ D-Acyc.dbno-DC(P n7) = dbno-BC(P n7) =is Horn and P m,n− {c1} contains no cycle and no directed cycle, we obtain dbHorn(P m,n) = 0, 8) ≤ 1. According to Observation 8.3, we have dbC(P m,n− {a2} is Horn and P n99) ≤ 1. According to Observation 8.3, we have dbC(P n8− {a1} contains no cycle and no directed cycle, we have dbHorn(P n9) ≤ 1, 9) ≤ 1 where C ∈ {Horn} ∪ Acyc.8) ≤ 1 where C ∈ {Horn} ∪ Acyc.10. Consider program P m,n. Since P m,n) ≤ 1, dbno-DC(P m,n888dbno-C(P m,n811. Consider program P n9. Since P n9dbno-C(P n9) ≤ 1, and dbno-DC(P nJ.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–1038912. Consider program P nX is a deletion Horn-backdoor of P ncycle, we have dbC(P n1111 and let X = {b}. Since P n− X is Horn, − X) = 1. Since P n− X contains no cycle, no even cycle, and no directed 11− X) = 1 where C ∈ {Horn, Normal} ∪ Acyc.− X) = 1 where C ∈ Acyc. Consequently, dbC(P n11− X is normal, X is a deletion Normal-backdoor of P n11 and dbHorn(P n11. Since P n1111118.2. ASP-parameters based on the distance from HornOur backdoor-based ASP-parameter dbHorn can be considered as a parameter that measures the distance of a program from being a Horn program. In the literature some normal ASP-parameters have been proposed, that also can be considered as distance measures from Horn. In this section we compare them with dbHorn. Since the ASP-parameters considered in the literature are normal, we compare the parameters for normal programs only. However, in view of Observation 8.2 the results also hold for the lifted parameters to disjunctive programs.Definition 8.7. (See Ben-Eliyahu [4].) Let P be a normal program. Then(cid:6)(cid:6)(cid:3)a ∈ at(P ) : a ∈ B−#neg(P ) :=#non-Horn(P ) :=(cid:6)(cid:6){r ∈ P : r is not Horn }(r) for some rule r ∈ P(cid:6)(cid:6).(cid:4)(cid:6)(cid:6),Proposition 8.8. (See Ben-Eliyahu [4].) For each L ∈ AspFull , L[#neg]N ∈ FPT and L[#non-Horn]N ∈ FPT.Since Bound[p]N for p ∈ {#neg, #non-Horn} is clearly solvable in polynomial time and thus fixed-parameter tractable, we can use the Lifting Theorem (Theorem 7.5) to obtain the following result.Corollary 8.9. For each L ∈ AspFull , L[#neg↑] ∈ FPT and L[#non-Horn↑] ∈ FPT.Observation 8.10. We make the following observations about programs from Example 8.1.1. Consider program P n1 which contains n atoms that occur in B#neg(P n1) = n and #non-Horn(P n1) = 1.−(r) for some rule r ∈ P and exactly one non-Horn rule. Thus, 2. Consider program P n2 which contains only the atom b that occurs in B−(r) for some rule r ∈ P n2 and n non-Horn rules. Thus, #neg(P n2) = 1 and #non-Horn(P n2) = n.3. Consider program P nrules bi ← ¬a and a ← ¬bi . Hence, #neg(P n4. Consider program P n5. Consider program P nSo #neg(P n35) = #non-Horn(P n35) = 1.31 which contains for 1 ≤ i ≤ n the atoms a and bi that occur in B31) = 2n.31) = n + 1 and #non-Horn(P n32) = #non-Horn(P n32 which is Horn. Thus, #neg(P n35 which contains only the atom a that occurs in B32) = 0.−(r) for some rule r ∈ P n6. Consider program P n4 which contains for 1 ≤ i ≤ n the atoms ai that occur in Brules bi ← ¬ai and ci ← ¬ai . Thus, #neg(P n4) = n and #non-Horn(P n4) = 2n.7. Consider program P n51 which contains for 1 ≤ i ≤ n the atoms ai and bi that occur in Brules bi ← ¬ai and ai ← ¬bi . Hence, #neg(P n51) = #non-Horn(P n52 which contains the atoms bi that occur in B8. Consider the program P n51) = 2n.−(r) for some rule r ∈ P nHence, #neg(P n9. Consider programs P n52) = #non-Horn(P n52) = n.6, P n7) = #non-Horn(P n54, P n7, and P m,n7) = #neg(P m,n8 which are Horn. Thus, #neg(P n) = #non-Horn(P m,n) = 0.88= #neg(P n10. Consider the program P nrules a2 ← ¬a1 and a3 ← ¬a2. Hence, #neg(P n9 which contains only the atoms a1 and a2 that occur in B9) = #non-Horn(P n11. The set X = {b} is a deletion Normal-backdoor of P n11) = | X| + #neg(P n− X) = 0. Thus, #neg9) = 2.↑(P n1111. Consider the program P n#neg(P n11| X| + #non-Horn(P n11− X) = #non-Horn(P n11− X) = 1.−(r) for some rule r ∈ P n31 and the non-Horn 35 and exactly one non-Horn rule. −(r) for some rule r ∈ P n4 and the non-Horn −(r) for some rule r ∈ P and the non-Horn 52 and the non-Horn rules ai ← ¬bi . 54) = #non-Horn(P n54) = #neg(P n6) = #non-Horn(P n6)−(r) for some rule r ∈ P n9 and only the non-Horn 11. Since P n− X) = 1 and #non-Horn− X is Horn, we have 11) =↑(P n11Proposition 8.11. #neg and #non-Horn are incomparable.Proof. The proposition directly follows from considering P n2) = n by Observation 8.10. (cid:2)#neg(P n2) = 1 and #non-Horn(P n1 and P n2 where #neg(P n1) = n and #non-Horn(P n1) = 1; and However, it is easy to see that dbHorn dominates both parameters.Proposition 8.12. dbHorn strictly dominates #neg and #non-Horn. dbC and #neg; and dbC and #non-Horn are incomparable where C ∈ {no-C, no-DC, no-DC2, no-EC, no-DEC}.90J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Proof. For a normal program P define the sets BH(r) : r ∈ P , r is not Horn}. We observe that B#neg(P ) and dbHorn(P ) ≤ #non-Horn(P ). To show that dbHorn strictly dominates the two parameters, consider P ndbHorn(P n−(r) for some rule r ∈ P } and H(P ) = {a ∈−(P ) and H(P ) are deletion Horn-backdoors of P , hence dbHorn(P ) ≤31 where −(P ) = {a ∈ at(P ) : a ∈ B31) = 2n by Observations 8.6 and 8.10.31) = n + 1 and #non-Horn(P nThe second statement follows from considering the programs P ndbC(P nand 8.10. Hence dbC (cid:23)(cid:24) #neg and dbC (cid:23)(cid:24) #non-Horn for C ∈ {no-C, no-DC, no-DC2, no-EC, no-DEC}. (cid:2)31) ≥ n + 1; and 31 and P n54) = 0 for C ∈ {no-C, no-DC, no-DC2, no-EC, no-DEC} and p ∈ {#neg, #non-Horn} by Observations 8.631) ≤ 1, but #neg(P n31) ≤ 1 and p(P n54) ≥ n and p(P n54 where dbC(P n8.3. ASP-parameters based on the distance from being stratifiedBen-Eliyahu [4] and Gottlob et al. [85] have considered ASP-parameters that measure in a certain sense how far away a program is from being stratified. In this section we will investigate how these parameters fit into our landscape of ASP-parameters. Similar to the last section the parameters have been considered for normal programs only, hence we compare the parameters for normal programs only. Again, in view of Observation 8.2 the results also hold for the lifted parameters to disjunctive programs.Recall from Section 2.4 that SCC(G) denotes the partition of the vertex set of a digraph into strongly connected compo-nents.Definition 8.13. (See Ben-Eliyahu [4].) Let P be a normal program, D P its dependency digraph, and A ⊆ at(P ). P / A denotes the program obtained from P by (i) deleting all rules r in the program P where H(r) ∩ A = ∅ and (ii) removing from the bodies of the remaining rules all literals ¬a with a /∈ A (this corresponds to the well-known concept of a reduct). Thenlstr(P ) :=(cid:7)(cid:3)min(cid:4)#neg(P /C ), #non-Horn(P /C ).C∈SCC(D P )lstr(P ) is called the level of stratifiability of P .Proposition 8.14. (See Ben-Eliyahu [4].) For each L ∈ AspFull , L[lstr]N ∈ FPT.Since Bound[lstr]N is clearly solvable in polynomial time and thus fixed-parameter tractable, we can use the Lifting Theorem (Theorem 7.5) to obtain the following result.Corollary 8.15. For each L ∈ AspFull , L[lstr↑] ∈ FPT.Observation 8.16. We make the following observations about programs from Example 8.1.1. Consider program P n31 and let P = P n31. The partition SCC(D P ) contains only the set C = at(P ) and thus P /C = P . By Observa-tion 8.10 #neg(P ) = n + 1 and #non-Horn(P ) = 2n and hence lstr(P n31) = n + 1.2. Consider program P n32 and let P = P nby Observation 8.10, we have lstr(P n35 and let P = P n3. Consider program P n32. The partition SCC(D P ) contains only the set C = at(P ) and P /C = P . Since #neg(P ) = 032) = 0.35. The partition SCC(D P ) contains only the set C = at(P ). Thus, P = P /C . Since #neg(P n35) =4 and let P = P n4. We have SCC(D P ) contains exactly the sets Ai = {ai, ei, di}, B i = {bi}, and Ci = {ci}= {ci; ci ← bi}. Since #neg(P /C ) = 0 for = {ai ← ei; ei ← di; di ← ai} and P /Bi= {bi} and P /Ci1 by Observation 8.10, we conclude lstr(P n35) ≤ 1.4. Consider program P nwhere 1 ≤ i ≤ n. Hence P / Aievery C ∈ SCC(D P ), we have lstr(P n4) = 0.52 and let P ∈ {P n5. Consider program P n51 and P n1 ≤ i ≤ n and hence P /Ci#non-Horn(P /Ci ) = 2, respectively #neg(P /Ci ) = #non-Horn(P /Ci ) = 1, and there are n components we obtain lstr(P nand lstr(P n}. The partition SCC(D P ) contains exactly the sets Ci = {ai, bi} where = {bi ← ai; ai ← ¬bi : 1 ≤ i ≤ n}, respectively. Since #neg(P /Ci ) =51) = 2n= {bi ← ¬ai; ai ← ¬bi} and P /Ci51, P n5252) = n.6. Consider program P n6 and let P = P n1 ≤ i ≤ n. Hence P / A = {a ← b1, . . . , bn, ci : 1 ≤ i ≤ n} and P /BiSCC(D P ), we have lstr(P n6. The partition SCC(D P ) contains exactly the sets A = {a}, B i = {bi}, and Ci = {ci} where = ∅ where 1 ≤ i ≤ n. Since #neg(P /C ) = 0 for every C ∈= P /Ci7. Consider program P n7. The partition SCC(D P ) contains exactly the sets Ci = {ai} where 1 ≤ i ≤ n. Thus, P /Ci={ai ← a j : 1 ≤ j < i}. Hence #neg(P /Ci ) = 0 for every C ∈ SCC(D P ). We obtain lstr(P n7) = 0.8. Consider program P m,nC = {ci : 1 ≤ i ≤ n}. Hence P / Aic1}. Since #neg(P / Ai ) = 0 where 1 ≤ i ≤ m, #neg(P /B ) = 0, and #neg(P /C ) = 0, we obtain lstr(P m,n. The partition SCC(D P ) contains exactly the sets Ai = {ai} where 1 ≤ i ≤ m, B = {b}, and = ∅ where 1 ≤ i ≤ m, P /B = {b ← a1, . . . , am}, and P /C = {ci ← ci+1 : 1 ≤ i ≤ n} ∪ {cn+1 ←and let P = P m,n) = 0.889. Consider program P n9 and let P = P n#non-Horn(P ) = 2, we have lstr(P n9. The partition SCC(D P ) contains only the set C = at(P ). Hence P /C = P . Since #neg(P ) =9) = 2.86) = 0.7 and let P = P nJ.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–1039110. Consider program P n11. The set X = {b} is a deletion Normal-backdoor of P n11 by Observation 8.6. We have P = P n11c; c; ← ai : 1 ≤ i ≤ n}. The partition SCC(D P ) contains the sets Ai = {ai}, where 1 ≤ i ≤ n, and C = {c}. Hence P / Ai↑where 1 ≤ i ≤ n, and P /C = {c}. Since #neg(P /C ) = 0 for every C ∈ SCC(D P ), we obtain lstr(P ) = 0. Consequently, lstr| X| + lstr(P n11− X) = 1.− X = {ai ←= {ai ← c}, 11) =(P nObservation 8.17. lstr strictly dominates #neg and #non-Horn.(cid:5)−(r) for some rule r ∈ P }. By definition B−(P ) = {a ∈Proof. Let P be a normal program. We first show that −(P /C ) ⊆at(P ) : a ∈ B(cid:11) = ∅ and by defi-−(P ). Let C, CBC∈SCC(D P ) #neg(P /C ) ≤nition we have that B(cid:5)#neg(P ). A similar argument shows that C∈SCC(D P )min{#neg(P /C ), #non-Horn(P /C )}, we have lstr(P ) ≤ #neg(P ) and lstr(P ) ≤ #non-Horn(P ). To show that lstr strictly dom-4) ≥ 2n by inates the two parameters, consider program P nObservations 8.10 and 8.16. Hence the observation is true. (cid:2). By definition of a strongly connected component we have C ∩ C−(P /C (cid:11) ) ⊆ C(cid:5)−(P ) for some A ⊆ at(P ); thus, (cid:5)C∈SCC(D P ) #non-Horn(P /C ) ≤ #non − Horn(P ). Since lstr(P ) =C∈SCC(D P ) #neg(P /C ) ≤ #neg(P ). Define the set B(cid:11) ∈ SCC(D P ) and C (cid:10)= C(cid:11)−(P /C ) ⊆ C and B4) ≥ n and #non − Horn(P n−(P /C (cid:11) ) = ∅. Consequently 4) = 0, but #neg(P n4 where lstr(P n−(P / A) ⊆ B−(P /C ) ∩ BC∈SCC(D P ) B. Hence B(cid:2)(cid:11)Proposition 8.18. dbno-DBC strictly dominates lstr. Moreover, dbC and lstr are incomparable for the remaining target classes namely C ∈ Acyc \ {no-DBC, no-DBEC} ∪ {Horn}.Proof. We first show that dbno-DBC dominates lstr. For a normal program P define the sets B−(r) for some rule r ∈ P } and H(P ) = {a ∈ H(r) : r ∈ P , r is not Horn}. Let C ∈ SCC(D P ), we defineB(cid:8)XC =−(P /C ),BH(P /C ),−(P /C )| ≤ |H(P /C )|;if |Botherwise−(P ) = {a ∈ at(P ) : a ∈(cid:11)and X = { XC : C ∈ SCC(D P )}. We show that X is a deletion no-DBC-backdoor of P . By definition for every directed bad (cid:11) ∈ SCC(D P ) (all vertices of c belong to the same strongly cycle c = (x1, . . . , xl) of D P the atom xi ∈ Cconnected component). Moreover, by definition we have for every negative edge (xi, x j) ∈ D P of the dependency digraph D P−(P /C ) or H(P /C ), at least one of a corresponding rule r ∈ P such that x j ∈ H(r) and xi ∈ Bthe atoms xi, x j belongs to XC . Thus, for every directed bad cycle c of the program P at least one atom of the cycle belongs to X . Hence P − X ∈ no-DBC and X is a deletion no-DBC-backdoor of P . We obtain dbno-DBC(P ) ≤ lstr(P ). To show that 31) = n + 1 by Observations 8.6dbno-DBC strictly dominates lstr, consider program P nand 8.16. Hence dbno-DBC ≺ lstr.−(r). Since XC consists of either B31 where dbno-DBC(P n31) ≤ 1 and lstr(P nwhere 1 ≤ i ≤ l and CThen we show that the parameters dbC and lstr are incomparable. Consider the programs P n31) ≤ 14) ≥ n for C ∈ {Horn, no-C, no-BC, no-DC, no-DC2, no-EC, no-BEC, no-DEC}4 where dbC(P n3 and P nand lstr(P nby Observations 8.6 and 8.16. We conclude dbC (cid:23)(cid:24) lstr. (cid:2)31) = n + 1; and lstr(P n4) = 0 and dbC(P nDefinition 8.19. (See Gottlob et al. [85].) Let P be a normal program, D P its dependency digraph, U P its dependency graph, and A ⊆ at(P ). ˆP / A denotes the program obtained from P / A by removing from the bodies of every rule all literals a with +(P ) denotes the maximal set W ⊆ at(P ) such that there is no bad W -cycle in the dependency graph U P , in other a /∈ A. atwords the set of all atoms that do not lie on a bad cycle of P . Then(cid:3)fw(P ) := minwfw(P ) := fw|S| : S is a feedback vertex set of U P(cid:9)(cid:3)r ∈ ˆP /C − at( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈ no-DBC+(cid:4)(cid:10).(cid:4)andfw(P ) is called the feedback-width of P , and wfw(P ) is called the weak-feedback-width of P .Observation 8.20. Let P be a normal program and D P its dependency digraph. Then fw(P) = dbno-C(P ) and hencewfw(P) = dbno-C(cid:9)(cid:3)r ∈ ˆP /C − at+( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈ no-DBC(cid:4)(cid:10).Proposition 8.21. (See Gottlob et al. [85].) For each L ∈ AspFull , L[fw]N ∈ FPT and L[wfw]N ∈ FPT.Since Bound[fw]N and Bound[wfw]N is fixed-parameter tractable, we can use the Lifting Theorem (Theorem 7.5) to obtain the following result.Corollary 8.22. For each L ∈ AspFull , L[fw↑] ∈ FPT and L[wfw↑] ∈ FPT.Observation 8.23. We make the following observations about programs from Example 8.1.92J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10331) = 1.1. Consider the program P n31 and let P = P n31. The partition SCC(D P ) contains only the set C = at(P ). For every atom a ∈ C+( ˆP /C ) = ˆP /C = P . As P /∈ no-DBC, +( ˆP /C ) = ∅. Consequently, ˆP /C − at+( ˆP /C ), C ∈ SCC(D P ), ˆP /C /∈ no-DBC} = P . We have dbno-C(P ) = 1 by Observation 8.6 and according to Observa-the program P contains a bad {a}-cycle and thus at{r ∈ ˆP /C − attion 8.20, we obtain wfw(P n2. Consider program P n32 and let P = P nwe have ˆP /C ∈ no-DBC and thus {r ∈ ˆP /C − at32. The partition SCC(D P ) contains only the set C = at(P ), ˆP /C = P . For every atom a ∈ C+( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈ no-DBC} = ∅. Consequently, wfw(P n32) = 0.33, P n34, and P n3. Consider the programs P n}. We first observe that the dependency digraph of P contains 34, P nonly one strongly connected component. Hence the partition SCC(D P ) contains only the set C = at(P ). For every atom a ∈ C+( ˆP /C ) = ˆP /C = P . Since P /∈ no-DBC, we program P contains a bad {a}-cycle and thus atobtain {r ∈ ˆP /C − at+( ˆP /C ), C ∈ SCC(D P ), ˆP /C /∈ no-DBC} = P . We have dbno-C(P ) = n since P contains n disjoint {bi}-cycles. According to Observation 8.20, we conclude wfw(P n+( ˆP /C ) = ∅. Consequently, ˆP /C − at35 and let P ∈ {P n33, P n354. Consider program P n4 and let P = P nfor 1 ≤ i ≤ n. Hence ˆP / Aino-DBC. Consequently, {r ∈ ˆP /C − at51 and let P = P n5. Consider program P n= {ai ← ei; ei ← di; di ← ai}, ˆP /Bi34) = wfw(P n33) = wfw(P n35) = n.4. The partition SCC(D P ) contains exactly the sets Ai = {ai, di, ei}, B i = {bi}, and Ci = {ci}, = {ci}. For every C ∈ SCC(D P ) the program ˆP /C ∈= {bi} and ˆP /Ci+( ˆP /C ), C ∈ SCC(D P ), ˆP /C /∈ no-DBC} = ∅ and we obtain wfw(P n51. The partition SCC(D P ) contains exactly the sets Ci = {ai, bi}, for 1 ≤ i ≤ n, and thus 4) = 0.ˆP /Ci= {ai ← ¬bi; bi ← ¬ai}. Since dbno-C( ˆP /Ci ) = 1 and there are n components we obtain wfw(P n51) = n.6. Consider program P n52 and let P = P natom a ∈ Ci where 1 ≤ i ≤ n there is a bad {a}-cycle in the dependency graph of ˆP /Ci and thus atˆP /Cidbno-C(P ) = n and according to Observation 8.20, we obtain wfw(P n52. We observe that the partition SCC(D P ) contains exactly the sets Ci = {ai, bi}. For every +( ˆP /Ci ) = ∅. Consequently, +( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈ no-DBC} = P . We observe that +( ˆP /Ci ) = ˆP /Ci . Since ˆP /Ci /∈ no-DBC, {r ∈ ˆP /C − at− at52) = n.6. The partition SCC(D P ) contains exactly the sets A = {a}, B i = {bi}, and Ci = {ci} where = ∅ where 1 ≤ i ≤ n. Since dbno-C( ˆP /C ) = 0 for every C ∈ SCC(D P ), we obtain = ˆP /Ci7. Consider program P n6 and let P = P n1 ≤ i ≤ n. Hence ˆP / A = {a} and ˆP /Biwfw(P n6) = 0.8. Consider program P n7 and let P = P nand thus wfw( ˆP /{ai }) = 0. We obtain wfw(P n7) = 0.7. Since the partition SCC(D P ) contains exactly the sets {ai} where 1 ≤ i ≤ n, ˆP /{ai } = {ai}9. Consider program P m,nand let P = P m,nand C = {ci : 1 ≤ i ≤ n}. Hence ˆP / Aiprograms ˆP / Ai , ˆP /B , and ˆP /C belong to the class no-DBC for 1 ≤ i ≤ m. Consequently {r ∈ ˆP /C − atno-DBC} = ∅. Hence we conclude that wfw(P m,n. The partition SCC(D P ) contains exactly the sets Ai = {ai} for 1 ≤ i ≤ m, B = {b}, = ∅ for 1 ≤ i ≤ m, ˆP /B = ∅, and ˆP /C = {ci ← ci+1 : 1 ≤ i ≤ n} ∪ {cn+1 ← c1}. The +( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈) = 0.8889 and let P = P n9. The partition SCC(D P ) contains only the set C = at(P ). For every atom a ∈ C there is a bad +( ˆP /C ) = ˆP /C = P . Since P /∈ no-DBC, +( ˆP /C ) = ∅. Consequently, ˆP /C − at+( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈ no-DBC} = P . By Observation 8.6 dbno-C(P ) ≤ 1 and according to Observation 8.20, 10. Consider program P n{a}-cycle in the dependency graph of P and thus at{r ∈ ˆP /C − atwe obtain wfw(P n11. Consider program P n9) ≤ 1.11 and let P = P n11. The set X = {b} is a deletion Normal-backdoor of P n−X = {ai ← c; c; ← ai : 1 ≤ i ≤ n}. The partition SCC(D P ) contains exactly the sets {ai} for 1 ≤ i ≤ n and {c}. Hence ˆP /{ai } = {ai}for 1 ≤ i ≤ n and ˆP /{c} = {c}. We observe that dbno-C( ˆP /C ) = 0 for every C ∈ SCC(D P ) and according to Observation 8.20, we ↑obtain wfw(P ) = 0. Consequently, wfw11 by Observation 8.6 and P = P n− X) = 1.(P n1111) = | X| + wfw(P n11In the following proposition we state the relationship between the parameter wfw and our backdoor-based ASP param-eters. The first result (dbno-DBC strictly dominates wfw) was anticipated by Gottlob et al. [85].Proposition 8.24. wfw strictly dominates dbno-C and dbno-DBC strictly dominates wfw. Moreover, dbC and wfw are incomparable for the remaining target classes namely C ∈ {Horn, no-BC, no-DC, no-DC2, no-EC, no-BEC, no-DEC}.Next, we show that dbno-DBC strictly dominates wfw. Let P be a normal program and ˆP = { ˆP /C − atProof. We first show that wfw strictly dominates dbno-C. Let P be a normal program and X be a deletion no-C-backdoor of P . Define ˆP = { ˆP /C − at+( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈ no-DBC}. Since ˆP ⊆ P and no-C is hereditary (Observation 5.6), ˆP − X ∈ no-C and hence X is a deletion no-C-backdoor of ˆP . Consequently, wfw(P ) ≤ dbno-C( ˆP ). To show that wfw is 4) = n. Hence wfw ≺ dbno-Cstrictly more general than dbno-C, consider the program P nby Observations 8.3 and 8.23.+( ˆP /C ) : C ∈SCC(D P ), ˆP /C /∈ no-DBC}. According to Observation 8.20, wfw(P ) = dbno-C( ˆP ) and thus it is sufficient to show that dbno-DBC(P ) < dbno-C( ˆP ). Let X be an arbitrary deletion no-C-backdoor of ˆP . Since no-C ⊆ no-DBC Observation 8.3 yields that X is also a deletion no-DBC-backdoor of ˆP . Let c be an arbitrary directed bad cycle of D P . As all vertices of c belong to is an induced subdigraph of D P on at( ˆP /C ), we obtain c is a directed the same partition C ∈ SCC(D P ), at( ˆP /C ) ⊆ C , and D ˆP /C+( ˆP /C )-cycle . Since ˆP = { ˆP /C − atbad cycle in D ˆP /C. Since X is a deletion in U P , there is no directed bad at+( ˆP /C ) : C ∈ SCC(D P ), ˆP /C /∈ no-DBC} and by definition there is no at+( ˆP /C )-cycle in D P and hence c is also a directed bad cycle in D ˆP /C4) = 0 and dbno-C(P n4 where wfw(P nJ.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10393Fig. 8. Incidence graph I P of the program P of Example 2.1.no-DBC-backdoor of D ˆP /C, X is also a deletion no-DBC-backdoor of P . Consequently, dbno-DBC(P ) ≤ dbno-C( ˆP ) = wfw(P ). To show that dbno-DBC is strictly more general than the parameter wfw, consider the program P nand c is a directed bad X -cycle in D ˆP /C33) = n by Observations 8.6 and 8.23. Hence dbno-DBC ≺ lstr.33 where dbno-DBC(P n33) ≤ 1 and wfw(P nThe third statement follows from considering the programs P n34) ≤ 1 and wfw(P nno-DC, no-DC2, no-BEC, no-DEC} and dbno-EC(P nby Observations 8.6 and 8.23. Hence dbC (cid:23)(cid:24) wfw for C ∈ {Horn, no-BC, no-DC, no-DC2, no-EC, no-BEC, no-DEC}. (cid:2)33, P n34, and P n33) = wfw(P n4 where dbC(P n34) = n; and wfw(P n33) ≤ 1 for C ∈ {Horn, no-BC,4) = n4) = 0 and dbC(P nObservation 8.25. If p ∈ {#neg, #non-Horn, lstr}, then p and wfw are incomparable.Proof. To show that p and wfw are incomparable consider the programs P nwfw(P n35) = n by Observations 8.10, 8.16 and 8.23. (cid:2)35) ≤ 1 and wfw(P n31) = 1; and p(P n31 and P n35 where p(P n31) ≥ n + 1 and 8.4. Incidence treewidthTreewidth is graph parameter introduced by Robertson and Seymour [130–132] that measures in a certain sense the tree-likeness of a graph. See [8–10,86] for further background and examples on treewidth. Treewidth has been widely applied in knowledge representation, reasoning, and artificial intelligence [39,86,90,118,126].Definition 8.26. Let G = (V , E) be a graph, T = (N, E T ) a tree, and χ a labeling that maps any node t of T to a subset χ (t) ⊆ V . We call the sets χ (·) bags and denote the vertices of T as nodes. The pair (T , χ ) is a tree decomposition of G if the following conditions hold:1. for every vertex v ∈ V there is a node t ∈ N such that v ∈ χ (t) (“vertices covered”);2. for every edge v w ∈ E there is a node t ∈ N such that v, w ∈ χ (t) (“edges covered”); and3. for any three nodes t1, t2, t3 ∈ N, if t2 lies on the unique path from t1 to t3, then χ (t1) ∩ χ (t3) ⊆ χ (t2) (“connectivity”).The width of the tree decomposition (T , χ ) is max{|χ (t)| − 1 : t ∈ V (T )}. The treewidth of G, denoted by tw(G), is the minimum taken over the widths of all possible tree decompositions of G.We will use the following basic properties of treewidth.Lemma 8.27. (Folklore, e.g., [132].) Let G be a graph and C1, . . . , Cl its connected components, then tw(G) = max{tw(C j) : 1 ≤ i ≤ l}.Lemma 8.28. (Folklore, e.g., [6].) Let G be a graph. If G has a feedback vertex set size at most k, then tw(G) ≤ k + 1.Treewidth can be applied to programs by means of various graph representations.Definition 8.29. (See Jakl et al. [90].) Let P be a normal program. The incidence graph I P of P is the bipartite graph which has as vertices the atoms and rules of P and where a rule and an atom are joined by an edge if and only if the atom occurs in the rule. Then inctw(P ) := tw(I P ). The parameter inctw(P ) is called the incidence treewidth of P .Fig. 8 illustrates the incidence graph I P of the program P of Example 2.1.Proposition 8.30. (See Jakl et al. [90].) For each L ∈ AspFull \ {Enum}, L[inctw]N ∈ FPT and for Enum[inctw]N the solutions can be enumerated with fixed-parameter linear delay between any two consecutive solutions.94J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Observation 8.31. We make the following observations about programs from Example 8.1.1. Consider the programs P nincidence graph of P nand according to Lemma 8.27, we have inctw(P n32 and P n32 consists of the cycles a, ri, bi, r2i for 1 ≤ i ≤ n and the 51 consists of the cycles ai, ri, bi, r2i for 1 ≤ i ≤ n. According to Lemma 8.28, a cycle has treewidth at most 251. We observe that incidence graph of P n51) ≤ 2.7. Its incidence graph contains a clique on n vertices. Thus, by definition inctw(P n32) ≤ 2 and inctw(P n2. Consider the programs P n6) ≥ n − 1 and 6 and P n3. Consider program P m,n. The incidence graph consists of a tree on the vertices r0, b, a1, . . . , am and a cycle r1, c1, . . . , rn, cn, rn+1,cn+1, rn+2. By definition a tree has treewidth 1, according to Lemma 8.28, a cycle has treewidth at most 2, and according to Lemma 8.27, we obtain inctw(P m,n) ≤ 2.88inctw(P n7) ≥ n − 1.The following observation states why we cannot apply our lifting theorem and extend the parameter treewidth from normal to disjunctive programs.Observation 8.32. Enum[inctw]N /∈ FPT.51) ≤ 2. Let M ⊆ at(P ) such that either ai ∈ M or bi ∈ M. According to the Proof. Consider the program P ndefinitions, we obtain the GL-reduct P M = {ai : ai ∈ M} ∪ {bi : bi ∈ M}. Since M is a minimal model of P M , M is also an answer set of P . Thus, the program P has 2n many answer sets. Consequently, enumerating the answer sets of P takes time Ω(2n). (cid:2)51 where inctw(P nProposition 8.33. If C ∈ {Horn} ∪ Acyc and p ∈ {dbC, #neg, #non-Horn, lstr, wfw}, then p and inctw are incomparable.Proof. We observe incomparability from the programs P nand inctw(P n6) ≥ n − 1 by Observations 8.6, 8.10, 8.16, 8.23, and 8.31. (cid:2)51 and P n6 where p(P n51) ≥ n and inctw(P n51) = 2; and p(P n6) ≤ 18.5. Dependency treewidthOne might ask whether it makes sense to consider restrictions on the treewidth of the dependency graph. In this section we show that the dependency treewidth strictly dominates the incidence treewidth and backdoors with respect to the target class no-C, but unfortunately parameterizing the main ASP problems by the dependency treewidth does not yield fixed-parameter tractability.Definition 8.34. Let P be a program, then deptw(P ) = tw(U P ). We call deptw(P ) the dependency treewidth of P .Observation 8.35. We make the following observations about programs from Example 8.1.1. Consider programs P n2. Consider program P n32 and P n51. We observe that its dependency graph consists of n disjoint cycles bi, vbi ,ai , ai, vai ,bi for 1 ≤ i ≤ n. Accord-6 where the dependency graph is a tree. Thus, deptw(P n32) = deptw(P n6) = 1.ing to Lemma 8.28, a cycle has treewidth at most 2 and according to Lemma 8.27, we obtain deptw(P n3. Consider program P n7. Its dependency graph contains a clique on n vertices as a subgraph. Hence deptw(P n7) ≥ n − 1.51) ≤ 2.Proposition 8.36. deptw strictly dominates inctw and dbno-C. Let C ∈ {Horn} ∪ Acyc \ {no-C, no-EC} and p ∈ {dbC, #neg,#non-Horn, lstr, wfw}, then p and deptw are incomparable.Proof. Let P be a normal program, and I P its incidence graph. Let (T , χ ) be an arbitrary tree decomposition of I P . We create a tree decomposition (T , χ (cid:11)) for U P as follows: For every r ∈ P let vr be the corresponding vertex in I P . We replace the occurrence of a vr ∈ χ (t) by H(r) for all nodes t ∈ V (T ). Then the pair (T , χ (cid:11)) satisfies Conditions 1 and 2 of a tree decomposition of U P . Since all edges of I P are covered in (T , χ ) for every r ∈ P there is a t ∈ V (T ) such that vr ∈ χ (T ) and h ∈ χ (T ) where H(r) = {h}. Because all vr are connected in the bags of the tree decomposition (T , χ ) and all corresponding elements h are connected in (T , χ ), Condition 3 holds for (T , χ (cid:11)). Thus, (T , χ (cid:11)) is a tree decomposition of the dependency graph U P . Since the width of (T , χ (cid:11)) is less or equal to the width of (T , χ ) it follows tw(U P ) ≤ tw(I P ) for a normal 6) ≥ n. program P . To show that deptw strictly dominates inctw, consider the program P nHence deptw ≺ inctw.6) ≤ 1 and inctw(P n6 where deptw(P nLet P be a normal program and X a deletion no-C-backdoor of P . Thus, X is a feedback vertex set of the dependency graph U P . According to Lemma 8.28, tw(U P ) ≤ k + 1. Hence deptw (cid:20) dbno-C. To show that deptw strictly dominates dbno-C51) ≥ n. Consequently, deptw ≺ dbno-C and the proposition consider the program P nsustains.51) ≤ 2 and dbno-C(P n51 where deptw(P nTo show the last statement, consider again the programs P ndeptw(P n7) ≥ n − 1 and p(P n7) = 0 by Observations 8.6, 8.16, 8.23, and 8.35. (cid:2)51 and P n7 where deptw(P n51) ≤ 2 and p(P n51) ≥ n; and J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–10395Proposition 8.37. For each L ∈ AspReason , LN is NP-hard, even for programs that have dependency treewidth 2.Proof. First consider the problem Consistency. From a 3-CNF formula F with k variables we construct a program Pas follows: Among the atoms of our program P will be two atoms ax and a¯x for each variable x ∈ var(F ) and a new atom f . We add the rules a¯x ← ¬ax and ax ← ¬a¯x for each variable x ∈ var(F ). For each clause {l1, l2, l3} ∈ F we add the rule f ← h(l1), h(l2), h(l3), ¬ f where h(¬x) = ax and h(x) = a¯x. Now it is easy to see that the formula F is satisfiable if and only if the program P has an answer set. Let U P be the undirected dependency graph of P . We construct the fol-lowing tree decomposition (T , χ ) for U P : the tree T consists of the node t f and for each x ∈ var(F ) of the nodes t f x, tx¯x, and t ¯xx along with the edges t f t f x, t f xtx¯x, and tx¯xt ¯xx. We label the nodes by χ (t f ) := { f , v f } and for each x ∈ var(F ) by }. We observe that the pair (T , χ ) satisfies Condi-χ (t f x) := {ax, a¯x, f }, χ (tx¯x) := {ax, a¯x, vax ¯ax}, and χ (t ¯xx) := {ax, a¯x, v ¯axax¯ax in U P which are all “covered” ¯ax, ax v ¯axax , and v ¯axaxtion 1. The rules a¯x ← ¬ax and ax ← ¬a¯x yield the edges ax vax ¯ax , vax ¯axby χ (tx¯x) and χ (t ¯xx). The rule f ← h(l1), h(l2), h(l3), ¬ f yields the edge f v f which is covered by χ (t f ) and yields the edges f ax or f a¯x which are covered by χ (t f x). Thus, Condition 2 is satisfied. We easily observe that Condition 3 also holds for the pair (T , χ ). Hence (T , χ ) is a tree decomposition of the dependency graph U P . Since max{|χ (t)| − 1 : t ∈ V (T )} = 2, the tree decomposition (T , χ ) is of width 2 and deptw(P ) = 2. Hence the problem Consistency[deptw]N is NP-hard, even for programs that have dependency treewidth 2. We observe hardness for the problems Brave Reasoning and Skeptical Reasoning by the very same argument as in the proof of Theorem 6.4 and the proposition holds. (cid:2)8.6. Interaction treewidthIn this section we consider two parameters investigated by Ben-Eliyahu and Dechter [3]: the interaction treewidth in-troduced under the term “clique width”,4 and the feedback width of the interaction graph introduced under the term “cycle-cutset size”. The interaction graph represents “interactions” between head atoms and related body atoms (similar to the Gaifman graph). The interaction treewidth measures in a certain sense the tree-likeness of the interaction graph and the feedback width the distance of the interaction graph from being acyclic. Both parameters are considered together with the length of the longest cycle in the positive dependency digraph (which states dependencies between atoms in the head and atoms in the positive body).Definition 8.38. (See Ben-Eliyahu and Dechter [3].) Let P be a normal program. The interaction graph is the graph A P which (cid:11) ∈ Phas as vertices the atoms of P and an edge xy between any two distinct atoms x and y for which there are rules r, rsuch that x ∈ at(r), y ∈ at(r(cid:11)), and H(r) ∩ H(r(cid:11)) (cid:10)= ∅.5Definition 8.39. (See Kanchanasut and Stuckey [99], Ben-Eliyahu and Dechter [3].) Let P be a program. The positive depen-+P of P has as vertices the atoms at(P ) and a directed edge (x, y) between any two atoms x, y ∈ at(P ) for dency digraph Dwhich there is a rule r ∈ P with x ∈ H(r) and y ∈ B+(r).6Let G = (V , E) be a graph and c = (v 1, . . . , vl) a cycle of length l in G. A chord of c is an edge v i v j ∈ E where v i and v j are not connected by an edge in c (non-consecutive vertices). G is chordal (triangulated) if every cycle in G of length at least 4 has a chord.Definition 8.40. (See Ben-Eliyahu and Dechter [3].) Let G be a digraph and G(cid:11)a graph. Then(cid:3)(cid:3){2} ∪(cid:11)lc(G) := max(cid:10)(cid:3)(cid:9)cs(cid:11)G(cid:9)(cid:11):=(cid:10)w : G(cid:3)|c| : c is a cycle in G(cid:4)(cid:4),fwG:= min|S| : S is a feedback vertex set of G.is a subgraph of a chordal graph with all cliques of size at most w(cid:4)(cid:11)(cid:4),andlc is the length of the longest cycle. cs is the clique size.7Let P be a normal program, A P its interaction graph, and D+cluster(P ) := cs( A P ) · log lcDP(cid:9)cyclecut(P ) := fw( A P ) · log lcD(cid:10).+P(cid:9)(cid:10)+P its positive dependency digraph. Thencluster(P ) is called the size of the tree clustering. cyclecut(P ) is called the size of the cycle cutset decomposition.4 Today the term “clique-width” is predominately used to refer to a different graph parameter, see, e.g., [83].5 This definition is equivalent to the original definition in [3] which is given in terms of cliques: the interaction graph is the graph where each atom is associated with a vertex and for every atom a the set of all literals that appear in rules that have a in their heads are connected as a clique.6 Ben-Eliyahu and Dechter [3] used the term dependency graph while the term positive dependency graph was first used by Kanchanasut and Stuckey [99] and became popular by Erdem and Lifschitz [43].7 The original definition is based on the length of the longest acyclic path in any component of G instead of the length of the longest cycle and the term clique width is used instead of clique size.96J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103In fact the definition of cs(G) is related to the treewidth:Lemma 8.41. (See Robertson and Seymour [132].) Let G be a graph. Then tw(G) = cs(G) + 1.Corollary 8.42. Let P be a normal program, A P its interaction graph, and Dcluster(P ) =(cid:9)tw( A P ) − 1(cid:10)· log lc(cid:9)(cid:10)D+P+P its dependency digraph. ThenProposition 8.43. (See Ben-Eliyahu and Dechter [3].) For each L ∈ AspFull , L[cluster]N ∈ FPT and L[cyclecut]N ∈ FPT.Observation 8.44. We make the following observations about programs from Example 8.1.5351 and P n1. Consider programs P n}. The interaction graph A p contains n disjoint paths ai, bi , for 1 ≤ i ≤ m. Hence A P contains no cycles and fw( A P ) = 0 and according to Lemma 8.28, we obtain tw( A P ) ≤ 1. Moreover, the positive ++P ) = 2. Consequently, dependency digraph DP contains no edges, n disjoint cycles of length exactly 2 respectively. Thus, lc(Dcluster(P n53 and let P ∈ {P n51, P n51) ≤ 1 and cyclecut(P n51) ≤ 1; and cluster(P n53) ≤ 1 and cyclecut(P n2. Consider program P m,nand let P = P m,n. The interaction graph A P contains a clique on m vertices and thus tw( A P ) ≥ m − 1. According to Lemma 8.41, we obtain cs( A P ) ≥ m − 2. According to Lemma 8.28, we have fw( A P ) ≥ m − 2. Moreover, the positive ) ≥ (m − 2) · log ndependency digraph Dand cyclecut(P m,n+P contains the cycle c1, c2, . . . , cn, cn+1. Thus, lc(DP ) = n. Consequently, cluster(P m,n) ≥ (m − 2) · log n.53) ≤ 1.+8888Observation 8.45. cluster strictly dominates cyclecut.Proof. Let P be a normal program and A P its interaction graph. According to Lemma 8.28, we obtain tw( A P ) ≤ fw( A P ) + 1. Hence cluster(P ) ≺ cyclecut(P ). (cid:2)Proposition 8.46. inctw strictly dominates cluster. If C ∈ {Horn} ∪ Acyc and p ∈ {dbC, #neg, #non-Horn, lstr, wfw}, then p and cluster are incomparable; and p and cyclecut are incomparable.Proof. We first show that inctw dominates cluster. Let P be a normal program, I P its incidence graph, and A P its interaction graph. Let (T , χ ) be an arbitrary tree decomposition of A P . We create a tree decomposition (T , χ (cid:11)) for I P as follows: For every r ∈ P let vr be the corresponding vertex in I P . By definition for every r ∈ P there is a bag χ (t) where t ∈ V (T )such that at(r) ⊂ χ (t). We set χ (cid:11)(t) = χ (t) ∪ {vr}. Then the pair (T , χ (cid:11)) clearly satisfies Conditions 1 and 2 of a tree decomposition of I P by definition. Since every vr occurs in exactly one bag Condition 3 holds for (T , χ (cid:11)). Thus, (T , χ (cid:11))is a tree decomposition of the interaction graph A P . Since the width of (T , χ (cid:11)) is less or equal to the width of (T , χ )plus one it follows tw(I P ) ≤ tw( A P ) + 1. To show that inctw strictly dominates cluster, consider the program P m,n8 where inctw(P m,n) = (m − 2) log n by Observations 8.31 and 8.44. Hence inctw ≺ cluster.) ≤ 2 and cluster(P m,nLet p ∈ {dbC , #neg, #non-Horn, lstr, wfw} and C ∈ {Horn} ∪ Acyc. We show the incomparability of the parameter p and +P ) and +P ), respectively, and lc(I P ) can be arbitrarily large, and there are programs where the converse sustains. Therefore we ) ≤ 1 and ) ≥ (m − 2) · log n by Observations 8.6, 8.10, 8.16, 8.23, and 8.44. Consequently, cyclecut. In fact we show something stronger, there are programs P where p is of constant size, but both tw(Dfw(Dconsider the programs P ncyclecut(P m,nthe second statement holds. (cid:2)51 and P m,n) ≥ (m − 2) · log n and cluster(P m,n51) ≤ 1 and cyclecut(P n51) ≥ n and cluster(P n51) ≤ 1; and p(P m,n8 where p(P n888888.7. Number of bad even cyclesLin and Zhao [110] have considered the number of directed bad even cycles of a given program as a parameter which measures in a certain sense the distance of a program from being acyclic with respect to bad even cycles. This parameter relates to our notion of deletion no-DEC-backdoors and deletion no-DBEC-backdoors.Definition 8.47. (See Lin and Zhao [110].) Let P be a normal program. Then#badEvenCycles(P ) :=(cid:6)(cid:6){c : c is a directed bad even cycle of P }(cid:6)(cid:6)Proposition 8.48. For each L ∈ AspFull , L[#badEvenCycles]N ∈ FPT.Observation 8.49. We make the following observations about programs from Example 8.1.1. Consider program P n4 which contains no directed bad even cycle. Hence #badEvenCycles(P n4) = 0.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103972. Consider program P n3. Consider programs P n#badEvenCycles(P n4. Consider program P n7, and P m,n51 which contains n disjoint directed bad even cycles. Thus, #badEvenCycles(P n52, P n7) = #badEvenCycles(P m,n9 which contains the directed bad even cycles a1, a2, a3, bi for 1 ≤ i ≤ n. Since there are n of those directed 8 which contain no directed bad even cycle. Consequently we obtain #badEvenCycles(P n52) =) = 0.851) = n.bad even cycles we obtain #badEvenCycles(P n9) = n.Proposition 8.50. dbno-DBEC strictly dominates #badEvenCycles. Moreover, dbC and #badEvenCycles are incomparable for the re-maining target classes C ∈ Acyc \ {no-DBEC} ∪ {Horn}. If p ∈ {#neg, #non-Horn, lstr, wfw, inctw, deptw, cluster, cyclecut}, then pand #badEvenCycles are incomparable.Proof. To see that dbno-DBEC strictly dominates #badEvenCycles. Let P be a normal program. If P has at most k directed bad even cycles, we can construct a deletion no-DBEC-backdoor X for P by taking one element from each directed bad even cycle into X . Thus, dbno-DBEC(P ) ≤ #badEvenCycles(P ). If a program P has a deletion no-DBEC-backdoor of size 1, it 9) ≤ 1can have arbitrarily many even cycles that run through the atom in the backdoor, e.g. program P n9) = n by Observations 8.6 and 8.49. It follows that dbno-DBEC ≺ #badEvenCycles and the proposition and #badEvenCycles(P nholds.9 where dbno-DBEC(P nTo show the second statement, consider the programs P nand #badEvenCycles(P ndbno-DBC(P n{no-DBEC} ∪ {Horn} by Observations 8.6 and 8.49.52) ≥ n, and #badEvenCycles(P n9) = n; conversely dbC(P n9) = 1 for C ∈ Acyc ∪ {Horn}9 where dbC(P n4) ≥ n for C ∈ {Horn, no-C, no-BC, no-DC, no-DC2, no-EC, no-DEC, no-BEC}, 52) = 0. Hence dbC (cid:23)(cid:24) #badEvenCycles for C ∈ Acyc \4) = #badEvenCycles(P n52, and P n4, P n7) ≥ n − 1, p(P nTo show the third statement, consider the programs P ndeptw(P n(m − 2) log n, and #badEvenCycles(P np ∈ {inctw, deptw, cluster, cyclecut}, p(P n#badEvenCycles(P np ∈ {#neg, #non-Horn, lstr, wfw, inctw, deptw, cluster, cyclecut}. (cid:2), P n52) ≥ n for p ∈ {#neg, #non-Horn, lstr, wfw}, cyclecut(P m,n8) = #badEvenCycles(P n7) ≥ n − 1 and ) ≥51) ≤ 2 for 51) =9) = n by Observations 8.6, 8.10, 8.16, 8.23, 8.31, 8.35, 8.44, and 8.49. Hence p (cid:23)(cid:24) #badEvenCycles for 9) ≤ 2 for p ∈ {#neg, #non-Horn, lstr, wfw}, and #badEvenCycles(P n9 where inctw(P n) ≥ (m − 2) log n, cluster(P m,n7) = #badEvenCycles(P m,n52) = 0; conversely p(P n7, and P m,n51, P n52, P n8888.8. Number of positive cycles (loop formulas)Fages [46], Lin and Zhao [109], and Lee and Lifschitz [105] have introduced compilations of normal programs and dis-junctive programs to SAT, respectively. Fages [46] has established the notion of being acyclic with respect to the positive dependency digraph of a given program, so-called tight programs. Lin and Zhao [109] have extended this to non-tight pro-grams by adding additional formulas that prevent cycles in the positive dependency graph, so-called loop formulas. We would like to mention that loop formulas are used in some ASP solvers, e.g., Clasp3 [37] and Cmodels3 [108]. The concept of loop formulas is based on the observation that cycles in the positive dependency digraph yield additional models in the SAT formula which are in fact not answer sets and can be eliminated by forbidding a “circular justification” of atoms without having a “justification from outside”. The number of loop formulas depends on the number of cycles of the positive dependency digraph and yields the following parameter that measures in a certain sense the distance of a program from being tight.Definition 8.51. (See Fages [46].) Let P be a normal program and D#posCycles :=(cid:6)(cid:3)(cid:6)c : c is a directed cycle in D(cid:4)(cid:6)(cid:6)+PThe program P is called tight if #posCycles = 0.8+P its positive dependency digraph. ThenThe parameter has been generalized to disjunctive programs by Lee and Lifschitz [105].Proposition 8.52. (See Fages [46].) For L ∈ AspReason , L[#posCycles]N is NP-hard or co-NP-hard, even for tight programs.Observation 8.53. We make the following observations about programs from Example 8.1.#posCycles(P n1. Consider programs P n53) = n.2. Consider program P n7) = 0.3. Consider program P m,n#posCycles(P n32 and P n53 where the positive dependency digraphs contain n directed cycles. Hence #posCycles(P n51 and P n7 where the positive dependency digraphs contain no cycle. Hence #posCycles(P n32) =51) =. Its positive dependency digraph contains only the cycle c1, c2, . . . , cn, cn+1; thus, #posCycles(P n8) = 1.88 Fages [46] used the term positive-order consistent instead of tight.98J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103Proposition 8.54. If C ∈ {Horn} ∪ Acyc and p ∈ {dbC, #neg, #non-Horn, lstr, wfw, inctw, deptw, cluster, cyclecut, #badEven-Cycles}, then p and #posCycles are incomparable.Proof. We observe incomparability from the programs P n#neg, #non-Horn, lstr, wfw, #badEvenCycles}, inctw(P ncluster(P n,mp ∈ {dbC , #neg, #non-Horn, lstr, wfw, inctw, deptw} we have p(P n#posCycles(P nthe proposition holds. (cid:2)51) ≥ n for p ∈ {dbC) ≥ (m − 2) · log n, ) = 1; conversely for 53) ≤ 2 and 53) = n by Observations 8.6, 8.10, 8.16, 8.23, 8.31, 8.35, 8.44, 8.49, and 8.53. Consequently, . We have p(P n7) ≥ n − 1, cyclecut(P n,m7) = 0 as well as #posCycles(P m,n32) ≤ 2, for p ∈ {cluster, cyclecut} we have p(P n51, P n7) ≥ n − 1, deptw(P n) ≥ (m − 2) · log n, and #posCycles(P n51) = #posCycles(P n32) = #posCycles(P n7, and P n,m53, P n32, P n88888.9. Head-cyclesBen-Eliyahu and Dechter [3] have considered programs that do not contain certain cycles in their positive dependency digraph, so-called head-cycle-free programs. Head-cycle-free programs can be compiled into normal programs in polynomial time. We would like to mention that connections to head-cycle-free programs are exploited in the implementation of ASPsolvers (see e.g., [106]). In the following we consider the number of head cycles as a parameter which then measures in a certain sense the distance of a program from being head-cycle-free.Definition 8.55. (See Ben-Eliyahu and Dechter [3].) Let P be a program and Dcycle of Dhead-cycle.+P is an {x, y}-cycle9 where x, y ∈ H(r) for some rule r ∈ P . The program P is head-cycle-free if D+P its positive dependency digraph. A head-+P contains no One might consider the number of head-cycles as a parameter to tractability.Definition 8.56. Let P be a program and D+P its positive dependency digraph. Then#headCycles :=(cid:6)(cid:3)(cid:6)c : c is a head-cycle of D(cid:4)(cid:6)(cid:6)+PBut as the following proposition states that the ASP-reasoning problems are already NP-complete for head-cycle-free programs.Proposition 8.57. (See Ben-Eliyahu and Dechter [3].) Each L ∈ AspReason is NP-hard or co-NP-hard, even for head-cycle-free programs.Observation 8.58. We make the following observations about programs from Example 8.1.1. Consider program P n2. Consider program P n11) = n.#headCycles(P n51. Since the positive dependency digraph of P n11. The positive dependency digraph of P n51 contains no cycle, #headCycles(P n11 contains the head cycles aibc for 1 ≤ i ≤ n. Thus,51) = 0.Even though the parameter #headCycles does not yield tractability for the ASP-reasoning problems we are interested in the relationship between our lifted parameters and the parameter #headCycles. We will first restrict the input programs to normal programs in Observation 8.59 and then consider disjunctive programs Observation 8.60.Observation 8.59. If C ∈ {Horn} ∪ Acyc#badEvenCycles, #posCycles}, then #headCycles strictly dominates p↓.and p ∈ {dbC, #neg, #non-Horn, lstr, wfw, inctw, deptw, cluster, cyclecut,Proof. By definition every normal program is head-cycle-free, hence #headCycles strictly dominates p. (cid:2)Observation 8.60. If C ∈ {Horn} ∪Acyc, then dbC and #headCycles are incomparable. Moreover, if p ∈ {#neg, #non-Horn, lstr, wfw}, then pand #headCycles are incomparable.↑Proof. To see that the parameters are incomparable consider the programs P nand #headCycles(P n11) = 1 and #headCycles(P n51) = 0; and p(P n51 and P n11 where dbC ≥ n as well as p(P n51) ≥ n11) = n by Observations 8.6, 8.10, 8.16, 8.23, and 8.58. (cid:2)9 See Section 5.2 for the definition of a W -cycle.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103999. Summary and future workWe have introduced the backdoor approach to the domain of propositional answer set programming. In a certain sense, the backdoor approach allows us to augment known tractable classes and makes efficient solving methods for tractable classes generally applicable. Our approach makes recent progress in fixed-parameter algorithmics applicable to answer set programming and establishes a unifying approach that accommodates several parameters from the literature. This frame-work gives rise to a detailed comparison of the various parameters in terms of their generality. We introduce a general method of lifting parameters from normal to disjunctive programs and establish several basic properties of this method. We further studied the preprocessing limits of ASP rules in terms of kernelization taking backdoor size as the parameter.The results and concepts of this paper give rise to several research questions. For instance, it would be interesting to consider backdoors for target classes that contain programs with an exponential number of answer sets, but where the set of all answer sets can be succinctly represented. A simple example is the class of programs that consist of (in)dependent components of bounded size. It would be interesting to enhance our backdoor approach to extended rules in particular to weight constraints.An interesting further research direction is to study whether and how backdoors can be used to control modern heuris-tics in ASP solvers to obtain a speed-up. We do not expect a practically competitive heuristic that is purely based on backdoors and does not take other aspects of ASP solving into account. Therefore, a conclusive evaluation requires a rig-orous experimental setup that takes the interaction of various heuristic methods into account (e.g., interaction of solver techniques [101] and tuning of parameter values [88], modifying the branching heuristic by caching truth values of atoms and reusing them [127], modifying the atom score initially, or while learning conflict clauses, or at a certain depth of the search). So far various studies and theoretical considerations on the effect of restricting decision heuristics to a subset of variables based on structural properties have been carried out in the context of SAT and ASP, where both positive [80,81,143,75] and negative effects [96,95] have been observed.References[1] Benjamin Andres, Benjamin Kaufmann, Oliver Mattheis, Torsten Schaub, Unsatisfiability-based optimization in clasp, in: A. Dovier, V. Santos Costa (Eds.), Technical Communications of the 28th International Conference on Logic Programming, ICLP’12, in: Leibniz International Proceedings in Infor-matics (LIPIcs), vol. 17, 2012, pp. 212–221.[2] Krzysztof R. Apt, Howard A. Blair, Adrian Walker, Towards a theory of declarative knowledge, in: Foundations of Deductive Databases and Logic Programming, 1988, pp. 89–148.[3] Rachel Ben-Eliyahu, Rina Dechter, Propositional semantics for disjunctive logic programs, Ann. Math. Artif. Intell. 12 (1) (1994) 53–87.[4] Rachel Ben-Eliyahu, A hierarchy of tractable subsets for computing stable models, J. Artif. Intell. Res. 5 (1996) 27–52.[5] Nicole Bidoít, Christine Froidevaux, Negation by default and unstratifiable logic programs, Theor. Comput. Sci. 78 (1) (1991) 85–112.[6] Hans L. Bodlaender, Arie M.C.A. Koster, Combinatorial optimization on graphs of bounded treewidth, Comput. J. 51 (3) (2008) 255–269.[7] Hans L. Bodlaender, Rodney G. Downey, Michael R. Fellows, Danny Hermelin, On problems without polynomial kernels, J. Comput. Syst. Sci. 75 (8) (2009) 423–434.[8] Hans L. Bodlaender, A tourist guide through treewidth, Acta Cybern. 11 (1–2) (1993) 1–22.[9] Hans L. Bodlaender, Treewidth: algorithmic techniques and results, in: Igor Prívara, Peter Ružiˇcka (Eds.), Proceedings of the 22nd International Sympo-sium on Mathematical Foundations of Computer Science, MFCS’97, in: Lecture Notes in Computer Science, vol. 1295, Springer Verlag, 1997, pp. 19–36.[10] Hans L. Bodlaender, Discovering treewidth, in: Peter Vojtáš, Mária Bieliková, Bernadette Charron-Bost, Ondrej Sýkora (Eds.), Proceedings of the 31st Conference on Current Trends in Theory and Practice of Computer Science, SOFSEM’05, in: Lecture Notes in Computer Science, vol. 3381, Springer Verlag, 2005, pp. 1–16.[11] John A. Bondy, U.S.R. Murty, Graph Theory, Graduate Texts in Mathematics, vol. 244, Springer Verlag, New York, 2008.[12] Paul Bonsma, Daniel Lokshtanov, Feedback vertex set in mixed graphs, in: Frank Dehne, John Iacono, Jörg-Rüdiger Sack (Eds.), Proceedings of the 12th International Symposium on Algorithms and Data Structures, WADS’11, in: Lecture Notes in Computer Science, vol. 6844, Springer Verlag, 2011, pp. 122–133.[13] Stefan Brass, Jürgen Dix, Characterizations of the disjunctive well-founded semantics: confluent calculi and iterated GCWA, J. Autom. Reason. 20 [14] Marco Cadoli, Maurizio Lenzerini, The complexity of propositional closed world reasoning and circumscription, J. Comput. Syst. Sci. 48 (2) (1994) [15] Shaowei Cai, Kaile Su, Qingliang Chen, Ewls: a new local search for minimum vertex cover, in: Nestor Rychtyckyj, Daniel G. Shapiro (Eds.), Proceedings of the 24th AAAI Conference on Artificial Intelligence, AAAI’10, Atlanta, GA, USA, July 2010, pp. 45–50.[16] Shaowei Cai, Kaile Su, Chuan Luo, Abdul Sattar, Numvc: an efficient local search algorithm for minimum vertex cover, J. Artif. Intell. Res. 46 (2013) [17] Shaowei Cai, Kaile Su, Abdul Sattar, Local search with edge weighting and configuration checking heuristics for minimum vertex cover, Artif. Intell. (1998) 143–165.255–310.687–716.175 (2011) 1672–1696.[18] Francesco Calimeri, Giovambattista Ianni, Francesco Ricca, Mario Alviano, Annamaria Bria, Gelsomina Catalano, Susanna Cozza, Wolfgang Faber, Onofrio Febbraro, Nicola Leone, Marco Manna, Alessandra Martello, Claudio Panetta, Simona Perri, Kristian Reale, Maria Santoro, Marco Siri-anni, Giorgio Terracina, Pierfrancesco Veltri, The third answer set programming competition: preliminary report of the system competition track, in: James Delgrande, Wolfgang Faber (Eds.), Proceedings of the 11th International Conference on Logic Programming and Nonmonotonic Rea-soning, LPNMR’11, Vancouver, Canada, in: Lecture Notes in Computer Science, vol. 6645, Springer Verlag, 2011, pp. 388–403, https://www.mat.unical.it/aspcomp2011/OfficialProblemSuite.[19] Ashok K. Chandra, David Harel, Horn clause queries and generalizations, J. Log. Program. 2 (1) (1985) 1–15.[20] Hubie Chen, Yannet Interian, A model for generating random quantified Boolean formulas, in: Leslie Pack Kaelbling, Alessandro Saffiotti (Eds.), Pro-ceedings of the 19th International Joint Conference on Artificial Intelligence, IJCAI’05, Edinburgh, Scotland, UK, Professional Book Center, August 2005, pp. 66–71.[21] Jianer Chen, Yang Liu, Songjian Lu, Barry O’Sullivan, Igor Razgon, A fixed-parameter algorithm for the directed feedback vertex set problem, J. ACM 55 (5) (2008) 1–19.100J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103(2001) 374–425.[22] Jianer Chen, Iyad A. Kanj, Ge Xia, Improved upper bounds for vertex cover, Theor. Comput. Sci. 411 (40–42) (September 2010) 3736–3756.[23] Rajesh Chitnis, Marek Cygan, Mohammadtaghi Hajiaghayi, Dániel Marx, Directed subset feedback vertex set is fixed-parameter tractable, in: Artur Czumaj, Kurt Mehlhorn, Andrew Pitts, Roger Wattenhofer (Eds.), Proceedings of the 39th International on Colloquium Automata, Languages, and Programming, ICALP’12, Warwick, UK, in: Lecture Notes in Computer Science, vol. 7391, Springer Verlag, July 2012, pp. 230–241.[24] Vasek Chvatal, Linear Programming, Series of Books in the Mathematical Sciences, W.H. Freeman and Company, New York, 1983.[25] William Cook, Thorsten Koch, Daniel E. Steffy, Kati Wolter, A hybrid branch-and-bound approach for exact rational mixed-integer programming, Math. Program. Comput. 5 (3) (2013) 305–344.[26] Marek Cygan, Marcin Pilipczuk, Michał Pilipczuk, Jakub Onufry Wojtaszczyk, Subset feedback vertex set is fixed-parameter tractable, in: Luca Aceto, Monika Henzinger, Jiˇrí Sgall (Eds.), Proceedings of the 38th International Colloquium on Automata, Languages and Programming, ICALP’11, in: Lecture Notes in Computer Science, vol. 6755, Springer Verlag, 2011, pp. 449–461.[27] Evgeny Dantsin, Thomas Eiter, Georg Gottlob, Andrei Voronkov, Complexity and expressive power of logic programming, ACM Comput. Surv. 33 (3) [28] Ronald DeHaan, Stefan Szeider, The parameterized complexity of reasoning problems beyond NP, in: Chitta Baral, Giuseppe De Giacomo, Thomas Eiter (Eds.), Proceedings of the 14th International Conference on Principles of Knowledge Representation and Reasoning, KR’14, Vienna, Austria, The AAAI Press, 2014, Full version available from arXiv:1312.1672.[29] Marc Denecker, Joost Vennekens, Stephen Bond, Martin Gebser, Mirosław Truszczy ´nski, The second answer set programming competition, in: Esra Erdem, Fangzhen Lin, Torsten Schaub (Eds.), Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’09, Potsdam, Germany, in: Lecture Notes in Computer Science, vol. 5753, Springer Verlag, September 2009, pp. 637–654.[30] Reinhard Diestel, Graph Theory, 2nd edition, Graduate Texts in Mathematics, vol. 173, Springer Verlag, New York, 2000.[31] Bistra N. Dilkina, Carla P. Gomes, Ashish Sabharwal, Tradeoffs in the complexity of backdoor detection, in: Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming, CP’07, in: Lecture Notes in Computer Science, vol. 4741, Springer Verlag, 2007, pp. 256–270.[32] Bistra N. Dilkina, Carla P. Gomes, Ashish Sabharwal, Tradeoffs in backdoor detection for Sat and Unsat formulas, in: Proceedings of the 10th Interna-tional Symposium on Artificial Intelligence and Mathematics, ISAIM’08, Fort Lauderdale, FL, USA, January 2008, pp. 256–270.[33] William F. Dowling, Jean H. Gallier, Linear-time algorithms for testing the satisfiability of propositional Horn formulae, J. Log. Program. 1 (3) (1984) 267–284.[34] Rodney G. Downey, Michael R. Fellows, Parameterized Complexity, Monographs in Computer Science, Springer Verlag, New York, 1999.[35] Rodney G. Downey, Michael R. Fellows, Fundamentals of Parameterized Complexity, Texts in Computer Science, Springer Verlag, London, UK, 2013.[36] Rodney G. Downey, Michael R. Fellows, Ulrike Stege, Parameterized complexity: a framework for systematically confronting computational intractabil-ity, in: Contemporary Trends in Discrete Mathematics: from DIMACS and DIMATIA to the Future, in: AMS–DIMACS, vol. 49, American Mathematical Society, 1999, pp. 49–99.[37] Christian Drescher, Martin Gebser, Torsten Grote, Benjamin Kaufmann, Arne König, Max Ostrowski, Torsten Schaub, Conflict-driven disjunctive answer set solving, in: Gerhard Brewka, Jérôme Lang (Eds.), Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning, KR’08, Sydney, NSW, Australia, The AAAI Press, September 2008, pp. 422–432.[38] Christian Drescher, Martin Gebser, Benjamin Kaufmann, Torsten Schaub, Heuristics in conflict resolution, in: Maurice Pagnucco, Michael Thielscher (Eds.), Proceedings of the 12th International Workshop on Nonmonotonic Reasoning, NMR’08, vol. UNSW-CSE-TR-0819, The University of New South Wales, 2008, pp. 141–149.[39] Paul E. Dunne, Computational properties of argument systems satisfying graph-theoretic constraints, Artif. Intell. 171 (10–15) (2007) 701–729.[40] Wolfgang Dvoˇrák, Sebastian Ordyniak, Stefan Szeider, Augmenting tractable fragments of abstract argumentation, Artif. Intell. 186 (2012) 157–173.[41] Thomas Eiter, Georg Gottlob, On the computational cost of disjunctive logic programming: propositional case, Ann. Math. Artif. Intell. 15 (3–4) (1995) 289–323.[42] T. Eiter, M. Fink, H. Tompits, S. Woltran, Simplifying logic programs under uniform and strong equivalence, in: Ilkka Niemelä, Vladimir Lifschitz (Eds.), Proceedings 7th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’07, Tempe, AZ, USA, in: Lecture Notes in Computer Science, vol. 2923, Springer Verlag, May 2004, pp. 87–99.[43] Esra Erdem, Vladimir Lifschitz, Tight logic programs, Theory Pract. Log. Program. 3 (July 2003) 499–518.[44] William A. Stein, et al., Sage mathematics software (version 5.1.rc0), the Sage development team, http://www.sagemath.org, 2012.[45] Wolfgang Faber, Nicola Leone, Cristinel Mateis, Gerald Pfeifer, Using database optimization techniques for nonmonotonic reasoning, in: I.O. Committee (Ed.), Proceedings of the 7th International Workshop on Deductive Databases and Logic Programming, DDLP’99, Prolog Association of Japan, 1999, pp. 135–139.[46] Francois Fages, Consistency of Clark’s completion and existence of stable models, Log. Methods Comput. Sci. 1 (1) (1994) 51–60.[47] Johannes K. Fichte, Stefan Szeider, Backdoors to tractable answer-set programming, in: Toby Walsh (Ed.), Proceedings of the 22nd International Joint Conference on Artificial Intelligence, IJCAI’11, Barcelona, Catalonia, Spain, AAAI Press/IJCAI, July 2011, pp. 863–868.[48] Johannes K. Fichte, Stefan Szeider, Backdoors to normality for disjunctive logic programs, in: Marie des Jardins, Michael Littman (Eds.), Proceedings of the 27th AAAI Conference on Artificial Intelligence, AAAI’13, Bellevue, WA, USA, The AAAI Press, July 2013, pp. 320–327, A preliminary version of the paper was presented at the Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP’12).[49] Johannes K. Fichte, The good, the bad, and the odd: cycles in answer-set programs, in: Daniel Lassiter, Marija Slavkovik (Eds.), Proceedings of the 23rd European Summer School in Logic, Language and Information (ESSLLI’11), New Directions in Logic, Language and Computation (ESSLLI’10 and ESSLLI’11 Student Sessions, Selected Papers Series), in: Lecture Notes in Computer Science, vol. 7415, Springer Verlag, 2012, pp. 78–90.[50] Jörg Flum, Martin Grohe, Parameterized Complexity Theory, Theor. Comput. Sci., vol. XIV, Springer Verlag, Berlin, 2006.[51] Lance Fortnow, Rahul Santhanam, Infeasibility of instance compression and succinct PCPs for NP, J. Comput. Syst. Sci. 77 (1) (2011) 91–106.[52] Steven Fortune, John Hopcroft, James Wyllie, The directed subgraph homeomorphism problem, Theor. Comput. Sci. 10 (2) (1980) 111–121.[53] Marco Gario, Horn backdoor detection via vertex cover: benchmark description, in: Adrian Balint, Anton Belov, Daniel Diepold, Simon Gerber, Matti Järvisalo, Carsten Sinz (Eds.), Proceedings of SAT Challenge 2012; Solver and Benchmark Descriptions, 2012.[54] Serge Gaspers, Stefan Szeider, Backdoors to acyclic SAT, in: Artur Czumaj, Kurt Mehlhorn, Andrew M. Pitts, Roger Wattenhofer (Eds.), Proceedings of the 39th International Colloquium on Automata, Languages, and Programming, ICALP’12, Warwick, UK, in: Lecture Notes in Computer Science, vol. 7391, Springer Verlag, July 2012, pp. 363–374.[55] Serge Gaspers, Stefan Szeider, Backdoors to satisfaction, in: Hans Bodlaender, Rod Downey, Fedor Fomin, Dániel Marx (Eds.), The Multivariate Algo-rithmic Revolution and Beyond, in: Lecture Notes in Computer Science, vol. 7370, Springer Verlag, Heidelberg, Germany, 2012, pp. 287–317.[56] Serge Gaspers, Stefan Szeider, Strong backdoors to nested satisfiability, in: Alessandro Cimatti, Roberto Sebastiani (Eds.), Proceedings of the 15th International Conference on Theory and Applications of Satisfiability Testing, SAT’12, Trento, Italy, in: Lecture Notes in Computer Science, vol. 7317, Springer Verlag, June 2012, pp. 72–85.[57] Serge Gaspers, Stefan Szeider, Strong backdoors to bounded treewidth SAT, in: Omer Reingold (Ed.), Proceedings of the 54th Annual IEEE Symposium on Foundations of Computer Science, FOCS’13, Berkeley, California, USA, October 27–29, IEEE Computer Soc., 2013, pp. 489–498.[58] Serge Gaspers, Stefan Szeider, Guarantees and limits of preprocessing in constraint satisfaction and reasoning, Artif. Intell. 216 (2014) 1–19.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103101[59] Serge Gaspers, Sebastian Ordyniak, M.S. Ramanujan, Saket Saurabh, Stefan Szeider, Backdoors to q-Horn, in: Natacha Portier, Thomas Wilke (Eds.), Proceedings of the 30th International Symposium on Theoretical Aspects of Computer Science, STACS’13, San Francisco, CA, in: Leibniz International Proceedings in Informatics (LIPIcs), vol. 20, Schloss Dagstuhl, 2013, pp. 67–79.[60] Martin Gebser, Roland Kaminski, Personal communication, 2012.[61] Martin Gebser, Torsten Schaub, Asparagus, http://asparagus.cs.uni-potsdam.de, 2009.[62] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Conflict-driven answer set solving, in: Manuela M. Veloso (Ed.), Proceedings of the 20th International Joint Conference on Artificial Intelligence, IJCAI’07, Hyderabad, India, IJCAI, January 2007, pp. 386–392.[63] Martin Gebser, Lengning Liu, Gayathri Namasivayam, André Neumann, Torsten Schaub, Mirosław Truszczy ´nski, The first answer set programming system competition, in: Chitta Baral, Gerhard Brewka, John Schlipf (Eds.), Proceedings of the 9th Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’07, Tempe, AZ, USA, in: Lecture Notes in Computer Science, vol. 4483, Springer Verlag, May 2007, pp. 3–17.[64] Martin Gebser, Torsten Schaub, Sven Thiele, Gringo: a new grounder for answer set programming, in: Chitta Baral, Gerhard Brewka, John Schlipf (Eds.), Proceedings of the 9th International Conference Logic Programming and Nonmonotonic Reasoning, LPNMR’07, Tempe, AZ, USA, in: Lecture Notes in Computer Science, vol. 4483, Springer Verlag, May 2007, pp. 266–271.[65] Martin Gebser, Benjamin Kaufmann, André Neumann, Torsten Schaub, Advanced preprocessing for answer set solving, in: Malik Ghallab, Constantine D. Spyropoulos, Nikos Fakotakis, Nikolaos M. Avouris (Eds.), Proceedings of the 18th European Conference on Artificial Intelligence, ECAI’08, Patras, Greece, in: Front. Artif. Intell. Appl., vol. 178, IOS Press, July 2008, pp. 15–19.[66] Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Max Ostrowski, Torsten Schaub, Sven Thiele, A user’s guide to gringo, clasp, clingo, and iclingo, [67] M. Gebser, T. Schaub, S. Thiele, P. Veber, Detecting inconsistencies in large biological networks with answer set programming, Theory Pract. Log. Technical report, University Potsdam, 2010.Program. 11 (2–3) (2011) 323–360.[68] Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Torsten Schaub, Challenges in answer set solving, in: Marcello Balduccini, TranCao Son (Eds.), Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning – Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday, in: Lecture Notes in Artificial Intelligence, vol. 6565, Springer Verlag, 2011, pp. 74–90.[69] Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Torsten Schaub, Multi-criteria optimization in answer set programming, in: John Gallagher, Michael Gelfond (Eds.), Technical Communications of the 27th International Conference on Logic Programming, ICLP’11, Dagstuhl, Germany, in: Leibniz International Proceedings in Informatics (LIPIcs), vol. 11, Dagstuhl Publishing, 2011, pp. 1–10.[70] Martin Gebser, Roland Kaminski, Torsten Schaub, Complex optimization in answer set programming, Theory Pract. Log. Program. 11 (4–5) (2011) [71] Martin Gebser, Benjamin Kaufmann, Roland Kaminski, Max Ostrowski, Torsten Schaub, Marius Schneider, Potassco: the Potsdam answer set solving 821–839.collection, AI Commun. 24 (2) (2011) 107–124.[72] M. Gebser, B. Kaufmann, T. Schaub, Conflict-driven answer set solving: from theory to practice, Artif. Intell. 187 (188) (2012) 52–89.[73] Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Torsten Schaub, Answer Set Solving in Practice, Morgan & Claypool, 2012.[74] Martin Gebser, Thomas Glase, Orkunt Sabuncu, Torsten Schaub, Matchmaking with answer set programming, in: Pedro Cabalar, Tran Cao Son (Eds.), Proceedings of 12th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’13, Corunna, Spain, in: Lecture Notes in Computer Science, vol. 8148, Springer Verlag, 2013, pp. 342–347.[75] Martin Gebser, Benjamin Kaufmann, Ramon P. Otero, Javier Romero, Torsten Schaub, Philipp Wanko, Domain-specific heuristics in answer set pro-gramming, in: Marie des Jardins, Michael Littman (Eds.), Proceedings of the 27th AAAI Conference on Artificial Intelligence, AAAI’13, Bellevue, WA, USA, The AAAI Press, July 2013, pp. 350–356.[76] Martin Gebser, Tomi Janhunen, Jussi Rintanen, Answer set programming as SAT modulo acyclicity, in: Torsten Schaub, Gerhard Friedrich, Barry O’Sullivan (Eds.), Proceedings of the 21st European Conference on Artificial Intelligence, ECAI’14, Prague, Czech Republic, in: Front. Artif. Intell. Appl., vol. 263, IOS Press, August 2014, pp. 351–356.[77] Allen Van Gelder, Negation as failure using tight derivations for general logic programs, J. Log. Program. 6 (1–2) (1989) 109–133.[78] Michael Gelfond, Vladimir Lifschitz, The stable model semantics for logic programming, in: Robert A. Kowalski, Kenneth A. Bowen (Eds.), Proceedings of the 5th International Conference and Symposium, ICLP/SLP’88, Seattle, Washington, vol. 2, MIT Press, August 1988, pp. 1070–1080.[79] Michael Gelfond, Vladimir Lifschitz, Classical negation in logic programs and disjunctive databases, New Gener. Comput. 9 (3/4) (1991) 365–386.[80] E. Giunchiglia, A. Massarotto, R. Sebastiani, Act, and the rest will follow: exploiting determinism in planning as satisfiability, in: Jack Mostow, Charles Rich (Eds.), Proceedings of the 15th National Conference on Artificial Intelligence, AAAI’98, Madison, WI, USA, The AAAI Press, 1998, pp. 948–953.[81] E. Giunchiglia, M. Maratea, A. Tacchella, Dependent and independent variables in propositional satisfiability, in: Logics in Artificial Intelligence, 2002, pp. 296–307.[82] Enrico Giunchiglia, Yuliya Lierler, Marco Maratea, Answer set programming based on propositional satisfiability, J. Autom. Reason. 36 (4) (2006) 345–377.[83] Georg Gottlob, Reinhard Pichler, Hypergraphs in model checking: acyclicity and hypertree-width versus clique-width, SIAM J. Comput. 33 (2) (2004) [84] Georg Gottlob, Stefan Szeider, Fixed-parameter algorithms for artificial intelligence, constraint satisfaction and database problems, Comput. J. 51 (3) [85] Georg Gottlob, Francesco Scarcello, Martha Sideri, Fixed-parameter complexity in AI and nonmonotonic reasoning, Artif. Intell. 138 (1–2) (2002) [86] Georg Gottlob, Reinhard Pichler, Fang Wei, Bounded treewidth as a key to tractability of knowledge representation and reasoning, Artif. Intell. 174 (1) [87] Inc. Gurobi Optimization, Gurobi optimizer reference manual, Version 5.0.2, 2014.[88] Holger H. Hoos, Automated algorithm configuration and parameter tuning, in: Youssef Hamadi, Eric Monfroy, Frédéric Saubion (Eds.), Autonomous Search, Springer Verlag, 2012, pp. 37–71.[89] IBM, IBM ILOG CPLEX optimization studio CPLEX user’s manual, version 12 release 4 edition, 2011.[90] Michael Jakl, Reinhard Pichler, Stefan Woltran, Answer-set programming with bounded treewidth, in: Craig Boutilier (Ed.), Proceedings of the 21st International Joint Conference on Artificial Intelligence, IJCAI’09, Pasadena, CA, USA, vol. 2, Elsevier Science Publishers, North-Holland, July 2009, pp. 816–822.[91] Tomi Janhunen, Ilkka Niemelä, Compact translations of non-disjunctive answer set programs to propositional clauses, in: Marcello Balduccini, Tran Son (Eds.), Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning – Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday, in: Lecture Notes in Artificial Intelligence, vol. 6565, Springer Verlag, 2011, pp. 111–130.[92] Tomi Janhunen, Ilkka Niemelä, Dietmar Seipel, Patrik Simons, Jia-Huai You, Unfolding partiality and disjunctions in stable model semantics, ACM Trans. Comput. Log. 7 (1) (2006) 1–37.[93] Tomi Janhunen, Ilkka Niemelä, Mark Sevalnev, Computing stable models via reductions to difference logic, in: Esra Erdem, Fangzhen Lin, Torsten Schaub (Eds.), Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’09, Potsdam, Germany, in: Lecture Notes in Computer Science, vol. 5753, Springer Verlag, September 2009, pp. 142–154.351–378.(2008) 303–325.55–86.(2010) 105–132.102J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103(1997) 69–112.[94] Mikoláš Janota, Joao Marques-Silva, A tool for circumscription-based MUS membership testing, in: James P. Delgrande, Wolfgang Faber (Eds.), Pro-ceedings of the 11th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’11, Vancouver, Canada, in: Lecture Notes in Computer Science, vol. 6645, Springer Verlag, May 2011, pp. 266–271.[95] Matti Järvisalo, Tommi Junttila, Limitations of restricted branching in clause learning, Constraints 14 (3) (2009) 325–356.[96] M. Järvisalo, Ilkka Niemelä, The effect of structural branching on the efficiency of clause learning SAT solving: an experimental study, J. Algorithms 63 (1–3) (2008) 90–113.[97] Holger Jost, Orkunt Sabuncu, Torsten Schaub, Suggesting new interactions related to events in a social network for elderly, in: Proceedings of the 26th BCS Conference on Human Computer Interaction, HCI’12, Birmingham, UK, British Computer Society, Swinton, September 2012.[98] Naonori Kakimura, Ken-ichi Kawarabayashi, Yusuke Kobayashi, Erdös-Pósa property and its algorithmic applications: parity constraints, subset feed-back set, and subset packing, in: Dana Randall (Ed.), Proceedings of the 23rd Annual ACM–SIAM Symposium on Discrete Algorithms, SODA’12, San Francisco, CA, USA, Society for Industrial and Applied Mathematics (SIAM), 2012, pp. 1726–1736.[99] Kanchana Kanchanasut, Peter J. Stuckey, Transforming normal logic programs to constraint logic programs, Theor. Comput. Sci. 105 (1) (1992) 27–56.[100] Richard M. Karp, Richard J. Lipton, Some connections between nonuniform and uniform complexity classes, in: Proceedings of the 12th Annual ACM Symposium on Theory of Computing, STOC’80, Los Angeles, CA, USA, April 1980, pp. 302–309.[101] Hadi Katebi, Karem A. Sakallah, João P. Marques-Silva, Empirical study of the anatomy of modern Sat solvers, in: Karem A. Sakallah, Laurent Simon (Eds.), Proceedings of the 14th International Conference on Theory and Applications of Satisfiability Testing, SAT’11, Ann Arbor, MI, USA, in: Lecture Notes in Computer Science, vol. 6695, Springer Verlag, June 2011, pp. 343–356.[102] Kenichi Kawarabayashi, Yusuke Kobayashi, Fixed-parameter tractability for the subset feedback set problem and the s-cycle packing problem, Technical report, University of Tokyo, Japan, 2010.[103] Stephan Kottler, Michael Kaufmann, Carsten Sinz, A new bound for an NP-hard subclass of 3-SAT using backdoors, in: Hans Kleine Büning, Xishun Zhao (Eds.), Proceedings of the 11th International Conference on Theory and Applications of Satisfiability Testing, SAT’08, Guangzhou, China, in: Lecture Notes in Computer Science, vol. 4996, Springer Verlag, May 2008, pp. 161–167.[104] Andrea S. Lapaugh, Christos H. Papadimitriou, The even-path problem for graphs and digraphs, Networks 14 (4) (1984) 507–513.[105] Joohyung Lee, Vladimir Lifschitz, Loop formulas for disjunctive logic programs, in: Catuscia Palamidessi (Ed.), Logic Programming, Mumbai, India, in: Lecture Notes in Computer Science, vol. 2916, Springer Verlag, 2003, pp. 451–465.[106] Nicola Leone, Pasquale Rullo, Francesco Scarcello, Disjunctive stable models: unfounded sets, fixpoint semantics, and computation, Inf. Comput. 135 (2) [107] Nicola Leone, Gerald Pfeifer, Wolfgang Faber, Thomas Eiter, Georg Gottlob, Simona Perri, Francesco Scarcello, The DLV system for knowledge repre-sentation and reasoning, ACM Trans. Comput. Log. 7 (3) (2006) 499–562.[108] Yuliya Lierler, CMODELS – SAT-based disjunctive answer set solver, in: Chitta Baral, Gianluigi Greco, Nicola Leone, Giorgio Terracina (Eds.), Proceedings of the 8th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’05, Diamante, Italy, in: Lecture Notes in Computer Science, vol. 3662, Springer Verlag, 2005, pp. 447–451.[109] Fangzhen Lin, Jicheng Zhao, On tight logic programs and yet another translation from normal logic programs to propositional logic, in: Georg Gottlob, Toby Walsh (Eds.), Proceedings of the 18th International Joint Conference on Artificial Intelligence, IJCAI’03, Acapulco, Mexico, Morgan Kaufmann, August 2003, pp. 853–858.[110] Fangzhen Lin, Xishun Zhao, On odd and even cycles in normal logic programs, in: Anthony G. Cohn (Ed.), Proceedings of the 19th National Conference on Artificial Intelligence, AAAI’04, San Jose, CA, USA, The AAAI Press, July 2004, pp. 80–85.[111] Fangzhen Lin, Yuting Zhao, ASSAT: computing answer sets of a logic program by SAT solvers, Artif. Intell. 157 (1–2) (2004) 115–137.[112] Guohua Liu, Tomi Janhunen, Ilkka Niemelä, Answer set programming via mixed integer programming, in: Sheila McIlraith, Thomas Eiter (Eds.), Proceedings of the 13th International Conference on the Principles of Knowledge Representation and Reasoning, KR’12, Rome, Italy, The AAAI Press, 2012, pp. 32–42.[113] Wiktor Marek, Mirosław Truszczy ´nski, Autoepistemic logic, J. ACM 38 (3) (1991) 588–619.[114] Wiktor Marek, Mirosław Truszczy ´nski, Computing intersection of autoepistemic expansions, in: V. Wiktor Marek, V.S. Subrahmanian, Anil Nerode (Eds.), Proceedings of the 1st International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’91, Washington, D.C., USA, MIT Press, July 1991, pp. 37–50.[115] Victor W. Marek, Mirosław Truszczy ´nski, Stable models and an alternative logic programming paradigm, in: Krzysztof R. Apt, Victor W. Marek, Mirosław Truszczy ´nski, David S. Warren (Eds.), The Logic Programming Paradigm: A 25-Year Perspective, in: Artificial Intelligence, Springer Verlag, Berlin, Germany, September 1999, pp. 375–398.[116] Pranabendu Misra, Venkatesh Raman, M.S. Ramanujan, Saket Saurabh, Parameterized algorithms for even cycle transversal, in: Martin Charles Golumbic, Michal Stern, Avivit Levy, Gila Morgenstern (Eds.), Proceedings of the 38th International Workshop on Graph-Theoretic Concepts in Com-puter Science, WG’12, in: Lecture Notes in Computer Science, vol. 7551, Springer Verlag, 2012, pp. 172–183.[117] Marco Montalva, Julio Aracena, Anahí Gajardo, On the complexity of feedback set problems in signed digraphs, Electron. Notes Discrete Math. 30 [118] Michael Morak, Stefan Woltran, Preprocessing of complex non-ground rules in answer set programming, in: Agostino Dovier, Vítor Santos Costa (Eds.), Technical Communications of the 28th International Conference on Logic Programming, ICLP’12, Dagstuhl, Germany, in: Leibniz International Proceedings in Informatics (LIPIcs), vol. 17, Dagstuhl Publishing, 2012, pp. 247–258.[119] Michael Morak, Reinhard Pichler, Stefan Rümmele, Stefan Woltran, A dynamic-programming based ASP-solver, in: Tomi Janhunen, Ilkka Niemelä (Eds.), Proceedings of 12th European Conference on Logics in Artificial Intelligence, JELIA’10, Helsinki, Finland, in: Lecture Notes in Computer Science, vol. 6341, Springer Verlag, September 2010, pp. 369–372.[120] Rolf Niedermeier, Invitation to Fixed-Parameter Algorithms, Oxford Lecture Series in Mathematics and Its Applications, vol. 31, Oxford University Press, New York, NY, USA, 2006.[121] Ilkka Niemelä, Jussi Rintanen, On the impact of stratification on the complexity of nonmonotonic reasoning, J. Appl. Non-Class. Log. 4 (2) (1994) 141–179.[122] Ilkka Niemelä, Logic programs with stable model semantics as a constraint programming paradigm, Ann. Math. Artif. Intell. 25 (3) (1999) 241–273.[123] Naomi Nishimura, Prabhakar Ragde, Stefan Szeider, Detecting backdoor sets with respect to Horn and binary clauses, in: Holger H. Hoos, David G. Mitchell (Eds.), Proceedings of the 7th International Conference on Theory and Applications of Satisfiability Testing, SAT’04, Vancouver, BC, Canada, in: Lecture Notes in Computer Science, vol. 3542, Springer Verlag, May 2004, pp. 96–103.[124] Naomi Nishimura, Prabhakar Ragde, Stefan Szeider, Solving #SAT using vertex covers, Acta Inform. 44 (7–8) (2007) 509–523.[125] Andreas Pfandler, Stefan Rümmele, Stefan Szeider, Backdoors to abduction, in: Francesca Rossi (Ed.), Proceedings of the 23rd International Joint Conference on Artificial Intelligence, IJCAI’13, Beijing, China, The AAAI Press, August 2013, pp. 1046–1052.[126] Reinhard Pichler, Stefan Rümmele, Stefan Woltran, Belief revision with bounded treewidth, in: Esra Erdem, Fangzhen Lin, Torsten Schaub (Eds.), Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR’09, Potsdam, Germany, in: Lecture Notes in Computer Science, vol. 5753, Springer Verlag, 2009, pp. 250–263.(2008) 249–254.J.K. Fichte, S. Szeider / Artificial Intelligence 220 (2015) 64–103103[127] Knot Pipatsrisawat, Adnan Darwiche, A lightweight component caching scheme for satisfiability solvers, in: João P. Marques-Silva, Karem A. Sakallah (Eds.), Proceedings of the 10th International Conference on Theory and Applications of Satisfiability Testing, SAT’07, Lisbon, Portugal, in: Lecture Notes in Computer Science, vol. 4501, Springer Verlag, May 2007, pp. 294–299.[128] Igor Razgon, Barry O’Sullivan, Almost 2-SAT is fixed parameter tractable, J. Comput. Syst. Sci. 75 (8) (2009) 435–450.[129] Francesco Ricca, G. Grasso, Mario Alviano, Marco Manna, V. Lio, S. Iiritano, Nicola Leone, Team-building with answer set programming in the Gioia-Tauro seaport, Theory Pract. Log. Program. 12 (2012) 361–381.[130] Neil Robertson, P.D. Seymour, Graph minors. III. Planar tree-width, J. Comb. Theory, Ser. B 36 (1) (1984) 49–64.[131] Neil Robertson, P.D. Seymour, Graph minors – a survey, in: Surveys in Combinatorics 1985: Invited Papers for the 10th British Combinatorial Confer-ence, in: London Mathematical Society Lecture Note Series, Cambridge University Press, Cambridge, 1985, pp. 153–171.[132] Neil Robertson, P.D. Seymour, Graph minors. II. Algorithmic aspects of tree-width, J. Algorithms 7 (3) (1986) 309–322.[133] Neil Robertson, P.D. Seymour, Robin Thomas, Permanents, Pfaffian orientations, and even directed circuits, Ann. Math. 150 (3) (1999) 929–975.[134] Frances Rosamond, Table of races, in: Parameterized Complexity Newsletter, 2010, pp. 4–5, http://fpt.wikidot.com/.[135] Yongshao Ruan, Henry A. Kautz, Eric Horvitz, The backdoor key: a path to understanding problem hardness, in: Deborah L. McGuinness, George Fergu-son (Eds.), Proceedings of the 19th National Conference on Artificial Intelligence, AAAI’04, San Jose, CA, USA, The AAAI Press, July 2004, pp. 124–130.[136] Marko Samer, Stefan Szeider, Backdoor trees, in: Robert C. Holte, Adele E. Howe (Eds.), Proceedings of 23rd Conference on Artificial Intelligence, AAAI’08, Vancouver, BC, Canada, The AAAI Press, July 2008, pp. 363–368.[137] Marko Samer, Stefan Szeider, Backdoor sets of quantified Boolean formulas, J. Autom. Reason. 42 (1) (2009) 77–97.[138] Marko Samer, Stefan Szeider, Fixed-parameter tractability, in: Armin Biere, Marijn Heule, Hans van Maaren, Toby Walsh (Eds.), Handbook of Satisfia-bility, IOS Press, 2009, pp. 425–454, chapter 13.[139] C.P. Schnorr, On self-transformable combinatorial problems, in: H. König, B. Korte, K. Ritter (Eds.), Mathematical Programming at Oberwolfach, in: Mathematical Programming Studies, vol. 14, Springer Verlag, 1981, pp. 225–243.[140] Alexander Schrijver, Theory of Linear and Integer Programming, John Wiley & Sons, 1998.[141] Patrik Simons, Ilkka Niemelä, Timo Soininen, Extending and implementing the stable model semantics, in: Knowledge Representation and Logic Programming, Artif. Intell. 138 (1–2) (2002) 181–234.[142] Sinz Carsten, Towards an optimal CNF encoding of boolean cardinality constraints, in: Peter van Beek (Ed.), Proceedings of the 11th International Conference on Principles and Practice of Constraint Programming, CP’05, Sitges (Barcelona), Spain, in: Lecture Notes in Computer Science, vol. 3709, Springer Verlag, 2005, pp. 827–831.[143] Ofer Strichman, Tuning SAT checkers for bounded model checking, in: E. Allen Emerson, Aravinda Prasad Sistla (Eds.), Proceedings of the 12th International Conference on Computer Aided Verification, CAV’00, Chicago, IL, USA, in: Lecture Notes in Computer Science, vol. 1855, Springer Verlag, July 2000, pp. 480–494.[144] Stefan Szeider, Matched formulas and backdoor sets, J. Satisf. Boolean Model. Comput. 6 (2008) 1–12.[145] Michael Thielscher, Answer set programming for single-player games in general game playing, in: Patricia M. Hill, David S. Warren (Eds.), Proceedings of the 25th International Conference on Logic Programming, ICLP’09, Pasadena, CA, USA, July 14–17, in: Lecture Notes in Computer Science, vol. 5649, Springer Verlag, 2009, pp. 327–341.[146] Stéphan Thomassé, A quadratic kernel for feedback vertex set, in: Claire Mathieu (Ed.), Proceedings of the 29th Annual ACM–SIAM Symposium on Discrete Algorithms, SODA’09, New York, NY, USA, Society for Industrial and Applied Mathematics (SIAM), January 2009, pp. 115–119.[147] Son Thanh To, Enrico Pontelli, Tran Cao Son, A conformant planner with explicit disjunctive representation of belief states, in: Alfonso Gerevini, Adele E. Howe, Amedeo Cesta, Ioannis Refanidis (Eds.), Proceedings of the 19th International Conference on Automated Planning and Scheduling, ICAPS’09, Thessaloniki, Greece, The AAAI Press, September 2009, pp. 305–312.[148] Mirosław Truszczy ´nski, Trichotomy and dichotomy results on the complexity of reasoning with disjunctive logic programs, Theory Pract. Log. Program. [149] M.H. Van Emden, Robert A. Kowalski, The semantics of predicate logic as a programming language, J. ACM 23 (October 1976) 733–742.[150] Guido van Rossum, Python tutorial, Technical Report CS-R9526, Centrum voor Wiskunde en Informatica (CWI), Amsterdam, May 1995.[151] Vijay Vazirani, Mihalis Yannakakis, Pfaffian orientations, 0/1 permanents, and even cycles in directed graphs, in: Timo Lepistö, Arto Salomaa (Eds.), Proceedings of the 15th International Colloquium on Automata, Languages and Programming, ICALP’88, Tampere, Finland, in: Lecture Notes in Com-puter Science, vol. 317, Springer Verlag, 1988, pp. 667–681.[152] Ryan Williams, Carla Gomes, Bart Selman, Backdoors to typical case complexity, in: Georg Gottlob, Toby Walsh (Eds.), Proceedings of the 18th International Joint Conference on Artificial Intelligence, IJCAI’03, Acapulco, Mexico, Morgan Kaufmann, August 2003, pp. 1173–1178.[153] Ryan Williams, Carla Gomes, Bart Selman, On the connections between backdoors, restarts, and heavy-tailedness in combinatorial search, in: Informal Proceedings of the 6th International Conference on Theory and Applications of Satisfiability Testing, SAT’03, Portofino, Italy, May 2003, pp. 222–230.[154] Chee-K. Yap, Some consequences of nonuniform conditions on uniform classes, Theor. Comput. Sci. 26 (3) (1983) 287–300.[155] Yuting Zhao, Fangzhen Lin, Answer set programming phase transition: a study on randomly generated programs, in: Catuscia Palamidessi (Ed.), Proceedings of the 19th International Conference on Logic Programming, ICLP’03, Mumbai, India, December 9–13, 2003, in: Lecture Notes in Computer Science, vol. 2916, Springer Verlag, 2003, pp. 239–253.[156] Jicheng Zhao, A study of answer set programming, Mphil thesis, The Hong Kong University of Science and Technology, Dept. of Computer Science, 11 (2011) 881–904.2002.