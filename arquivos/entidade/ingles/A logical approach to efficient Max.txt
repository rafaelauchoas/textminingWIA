Artificial Intelligence 172 (2008) 204–233www.elsevier.com/locate/artintA logical approach to efficient Max-SAT solving ✩Javier Larrosa a,∗, Federico Heras a, Simon de Givry ba Universitat Politecnica de Catalunya, Barcelona, Spainb INRA, Toulouse, FranceReceived 2 August 2006; received in revised form 11 May 2007; accepted 15 May 2007Available online 29 May 2007AbstractWeighted Max-SAT is the optimization version of SAT and many important problems can be naturally encoded as such. Solvingweighted Max-SAT is an important problem from both a theoretical and a practical point of view. In recent years, there has beenconsiderable interest in finding efficient solving techniques. Most of this work focuses on the computation of good quality lowerbounds to be used within a branch and bound DPLL-like algorithm. Most often, these lower bounds are described in a proceduralway. Because of that, it is difficult to realize the logic that is behind.In this paper we introduce an original framework for Max-SAT that stresses the parallelism with classical SAT. Then, we extendthe two basic SAT solving techniques: search and inference. We show that many algorithmic tricks used in state-of-the-art Max-SATsolvers are easily expressible in logical terms in a unified manner, using our framework.We also introduce an original search algorithm that performs a restricted amount of weighted resolution at each visited node. Weempirically compare our algorithm with a variety of solving alternatives on several benchmarks. Our experiments, which constituteto the best of our knowledge the most comprehensive Max-SAT evaluation ever reported, demonstrate the practical usability of ourapproach.© 2007 Elsevier B.V. All rights reserved.Keywords: Max-SAT; Search; Inference1. IntroductionWeighted Max-SAT is the optimization version of the SAT problem and many important problems can be naturallyexpressed as such. They include academic problems such as Max-Cut or Max-Clique, as well as real problems indomains like routing [3], bioinformatics [4], scheduling [5], probabilistic reasoning [6] and electronic markets [7].In recent years, there has been a considerable effort in finding efficient exact algorithms. These works can be dividedinto theoretical [8–10] and empirical [11–15]. A common drawback of all these algorithms is that in spite of theclose relationship between SAT and Max-SAT, they cannot be easily described with logic terminology. For instance,✩ This paper includes and extends preliminary work from [J. Larrosa, F. Heras, Resolution in Max-SAT and its relation to local consistency forweighted CSPs, in: Proc. of the 19th IJCAI, Edinburgh, UK, 2005, pp. 193–198; J. Larrosa, F. Heras, New inference rules for efficient Max-SATsolving, in: Proc. of AAAI-06, Boston, MA, 2006].* Corresponding author.E-mail addresses: larrosa@lsi.upc.edu (J. Larrosa), fheras@lsi.upc.edu (F. Heras), degivry@toulouse.inra.fr (S. de Givry).0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2007.05.006J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233205the contributions of [11–14] are good quality lower bounds to be incorporated into a depth-first branch and boundprocedure. These lower bounds are mostly defined in a procedural way and it is very difficult to see the logic that isbehind the execution of the procedure. This is in contrast with SAT algorithms where the solving process can be easilydecomposed into atomic logical steps.In this paper we introduce an original framework for (weighted) Max-SAT in which the notions of upper andlower bound are incorporated into the problem definition. Under this framework classical SAT is just a particularcase of Max-SAT, and the main SAT solving techniques can be naturally extended. In particular, we extend the basicsimplification rules (for example, idempotency, absorption, unit clause reduction, etc.) and introduce a new one,hardening, that does not make sense in the SAT context. We also extend the two fundamental SAT algorithms: DPLL(based on search) and DP (based on inference). We also show that the complexity of the extension of DP is exponentialon the formula’s induced width (which is hardly a surprise, since this is also the case of other inference algorithms forgraphical models [16,17]). Interestingly, our resolution rule includes, as special cases, many techniques spread overthe recent Max-SAT literature. One merit of our framework is that it allows to see all these techniques as inferencerules that transform the problem into an equivalent simpler one, as it is customary in the SAT context.The second contribution of this paper is more practical. We introduce an original search algorithm that incorporatesthree different forms of resolution at each visited node: neighborhood resolution, chain resolution and cycle resolution.Our experimental results on a variety of domains indicate that our algorithm is generally much more efficient than itscompetitors. This is especially true as the ratio between the number of clauses and the number of variables increases.Note that these are typically the hardest instances for Max-SAT. Our experiments include random weighted andunweighted Max-SAT, Max-One, Max-Cut, Max-Clique, and combinatorial auctions.The structure of the paper is as follows: In Section 2 we review SAT terminology. In Section 3 we present Max-SAT and introduce our framework. In Section 4 we extend the essential solving techniques from SAT to Max-SAT.Section 5 summarizes in a unified way several specialized forms of resolution that can be used to simplify Max-SATformula. Section 6 describes our solver. Section 7 reports our experimental work, which corroborate the efficiency ofour solver compared to other state-of-the-art solving alternatives. Section 8 discusses related work. Finally, Section 9concludes and points out directions of future work.2. Preliminaries on SATIn the sequel X = {x1, x2, . . . , xn} is a set of Boolean variables. A literal is either a variable xi or its negation ¯xi .The variable to which literal l refers is noted var(l) (namely, var(xi) = var( ¯xi) = xi ). If variable xi is assigned totrue literal xi is satisfied and literal ¯xi is falsified. Similarly, if variable xi is instantiated to false, literal ¯xi is satisfiedand literal xi is falsified. An assignment is complete if it gives values to all the variables in X (otherwise it is partial).A clause C = l1 ∨ l2 ∨ · · · ∨ lk is a disjunction of literals such that ∀1(cid:2)i,j (cid:2)k, i(cid:5)=j var(li) (cid:5)= var(lj ). It is customaryto think of a clause as a set of literals, which allows to use the usual set operations. If x ∈ C (resp. ¯x ∈ C) we saythat x appears in the clause with positive (resp. negative) sign. The size of a clause, noted |C|, is the number ofliterals that it has. var(C) is the set of variables that appear in C (namely, var(C) = {var(l) | l ∈ C}). An assignmentsatisfies a clause if and only if it satisfies one or more of its literals. Consequently, the empty clause, noted (cid:2), cannotbe satisfied. Conversely, a clause which contains the negation of the empty clause, noted ¬(cid:2), is always satisfiedand can be discarded. Sometimes it is convenient to think of clause C as its equivalent C ∨ (cid:2). A logical formulaF in conjunctive normal form (CNF) is a conjunction of different clauses, normally expressed as a set. A satisfyingcomplete assignment is called a model of the formula. Given a CNF formula, the SAT problem consists in determiningwhether there is any model for it or not. The empty formula, noted ∅, is trivially satisfiable. A formula containing theempty clause is trivially unsatisfiable and we say that it contains an explicit contradiction.2.1. Graph concepts [18]The structure of a CNF formula F can be described by its interaction graph G(F) containing one vertex associatedto each Boolean variable. There is an edge for each pair of vertices that correspond to variables appearing in the sameclause. Given a graph G and an ordering of its vertices d, the parents of a node xi is the set of vertices connected toxi that precede xi in the ordering. The width of xi along d is the number of parents that it has. The width of the graphalong d, denoted wd , is the maximum width among the vertices.206J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Fig. 1. On the left, a graph G. On the right, the induced graph G∗d where d is the lexicographic order.The induced graph of G(F) along d, denoted G∗d (F), is obtained as follows: The vertices of G are processedfrom last to first along d. When processing vertex xi , we connect every pair of unconnected parents. The inducedwidth of G along d, denoted w∗d , is the width of the induced graph. The induced width (also known as tree-width,k-tree number or the dimension of the graph) is a measure of how far a graph is from acyclicity and it is a fundamentalstructural parameter in the characterization of many combinatorial algorithms. Computing the ordering d that providesthe minimum induced width is an NP-hard problem [19].Example 1. Consider the formula F = { ¯x1 ∨ x4, x1 ∨ x4, x2 ∨ x3, x2 ∨ x4, x2 ∨ ¯x5, x4 ∨ x5}. Its interaction graph G(F)is depicted in Fig. 1(a). The induced graph G∗d along the lexicographical order is depicted in Fig. 1(b). Dotted edge(x1, x2) is the only new edge with respect to the original graph. When processing node x5, no new edges are added,because the parents x2 and x4 of x5 are already connected. When processing node x4, the edge connecting x2 and x1 isadded because both variables are parents of x4 and they were not connected. When processing x3, x2 and x1, no newedges are added. The induced width w∗d is 2 because nodes x5 and x4 have width 2 (namely, they have two parents) inthe induced graph.2.2. SAT algorithmsCNF formulas can be simplified using equivalences or reductions. Well known equivalences are idempotencyC ∧ C ≡ C, absorption C ∧ (C ∨ B) ≡ C and unit clause reduction l ∧ (¯l ∨ C) ≡ l ∧ C. A well known reduc-tion is the pure literal rule which says that if there is a variable that only occurs in either positive or negative form,all clauses mentioning it can be discarded from the formula. Simplifications and reduction have a cascade effect andcan be applied until quiescence. The assignment of true (resp. false) to variable x in F is noted F[x] (resp. F[ ¯x]) andproduces a new formula in which all clauses containing x (resp. ¯x) are eliminated from the formula, and ¯x (resp. x)is removed from all clauses where it appears. Note that F[l] can be seen as the addition of l to the formula and therepeated application of unit clause reduction followed by the pure literal rule.Algorithms for SAT can be roughly divided into search and inference. The most popular search algorithm and thestarting point of most state-of-the-art SAT solvers was proposed in [20] and is usually called Davis Putnam LogemannLoveland (DPLL). Fig. 2 provides a recursive description. First, DPLL simplifies its input (line 1). If the resultingformula is empty, it reports success (line 2). If the resulting formula is a contradiction, it reports failure (line 3). Elseit selects a literal l (line 4) and sequentially assigns the formula with l and ¯l (line 5).We say that two clauses x ∨ A, ¯x ∨ B ∈ F clash if and only if A ∨ B is not a tautology and is not absorbed in F .More formally, we define the Clash function:(cid:2)Clash(x ∨ A, ¯x ∨ B) =∀l∈Atruefalse otherwise¯l /∈ B ∧ ∀C∈F C (cid:5)⊆ A ∨ BThe resolution rule, {x ∨ A, ¯x ∨ B} ≡ {x ∨ A, ¯x ∨ B, A ∨ B}, is applied to clashing clauses and is central to inferencealgorithms. Variable x is called the clashing variable and A ∨ B is called the resolvent. Resolution, which is soundand complete, adds to the formula (i.e., makes explicit) an implicit relation between A and B. Note that unit clausereduction is just a particular case of resolution.Two years before DPLL, Davis and Putnam proved that a restricted amount of resolution performed along someordering of the variables is sufficient for deciding satisfiability. The corresponding algorithm is noted DP [18,21].J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233207function DPLL(F ) return Boolean1. F := Simplify(F )if F = ∅ then return true2.if F = {(cid:2)} then return false3.l := SelectLiteral(F )4.5. return DPLL(F [l]) ∨ DPLL(F [¯l])endfunctionFig. 2. DPLL is a search algorithm. It returns true iff F is satisfiable.xi ∨ A := PopClause(B)while ∃ ¯xi ∨B∈B s.t. Clash(xi ∨ A, ¯xi ∨ B) doendwhileF := F ∪ {A ∨ B}function VarElim(F , xi ) return CNF formula1. B := {C ∈ F | xi ∈ var(C)}2. F := F − B3. while ∃ xi ∨ A ∈ B do45.6.7.8. endwhile9. return (F )endfunctionfunction DP(F ) return Boolean10. F := Simplify(F )11. if F = ∅ then return true12. if F = {(cid:2)} then return false13. xi :=SelectVar(F )14. return DP(VarElim(F , xi ))endfunctionFig. 3. DP is a pure inference algorithm. It returns true iff F is satisfiable.Fig. 3 provides a recursive description. It eliminates variables one-by-one until it obtains the empty formula or achievesa contradiction. The heart of DP is Function VarElim. It eliminates variable xi from formula F while preservingits solvability. First, it computes the so-called bucket of xi , noted B, which contains the set of clauses mentioningthe variable (line 1). All the clauses in the bucket are removed from the formula (line 2). Next, it applies resolutionrestricted to the clauses in the bucket while pairs of clashing clauses exist. Resolvents are added to the formula (line 6).The correctness of DP is based on the fact that clauses added in line 6 keep the essential information contained inclauses removed in line 2. Observe that the pure literal rule is just a special case of variable elimination in which nopair of clashing clauses exist, so the inner loop never iterates.The following lemma shows how the complexity of eliminating a variable depends on the number of other variablesthat it interacts with,Lemma 2. (See [18].) Let F be a CNF formula and xi one of its variables. Let ni be the number of variables sharingsome clause with xi in F . The space and time complexity of VarElim(F, xi ) is O(3ni ) and O(9ni ), respectively.The following lemma shows how the induced graph G∗d (F) captures the evolution of the interaction graph G(F)as variables are eliminated.Lemma 3. (See [18].) Let d denote the reverse order in which DP(F) eliminates variables. The width of xi along din the induced graph G(F)∗d bounds from above the number of variables sharing some clause with xi at the time ofits elimination.Thus, the induced width captures the most expensive variable elimination. The following theorem, which followsfrom the two previous lemmas, characterizes the complexity of DP in terms of the induced width.208J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Theorem 4. (See [18].) Let d denote the reverse order in which DP(F) eliminates variables. Let w∗induced width of G(F) along d. The space and time complexity of DP(F) is O(n × 3w∗d ) and O(n × 9w∗d denote thed ), respectively.A consequence of the previous theorem is that the order in which DP eliminates variables may be crucial for thealgorithm’s complexity. As an example, consider a formula, whose interaction graph is a tree of depth 1. If variablesare eliminated in a top-down order, the cost may be exponential in n. If variables are eliminated in a bottom-uporder, the cost is linear. In general, finding optimal elimination orderings is an NP-hard problem and approximatealgorithms must be used. In practical applications, DP is generally too space consuming and cannot be used [18].Nevertheless, resolution still plays an important practical role in combination with search: the addition of restrictedforms of resolution at each search node anticipates the detection of dead-ends and improves its performance [18,22–24]. As we will show, the use of resolution is even more relevant in the Max-SAT context.3. (Weighted) Max-SATWhen a Boolean formula does not have any model, one may be interested in finding a complete assignment withminimum number of falsified clauses. This problem is known as (unweighted) Max-SAT. Note that no repetition ofclauses is allowed and all clauses are equally important. The complexity of Max-SAT is P NP[log n], meaning that it canbe solved with a logarithmic number of calls to a SAT oracle [25].Weighted Max-SAT is an extension of Max-SAT. A weighted clause is a pair (C, w) such that C is a classical clauseand w is a natural number indicating the cost of its falsification. A weighted formula in conjunctive normal form isa set of weighted clauses. The cost of an assignment is the sum of weights of all the clauses that it falsifies. Given aweighted formula, weighted Max-SAT is the problem of finding a complete assignment with minimal cost. We canassume all clauses in the formula being different, since (C, u), (C, w) can be replaced by (C, u + w). Note that clauseswith cost 0 do not have any effect and can be discarded. Weighted Max-SAT is more expressive than unweightedMax-SAT and its complexity, P NP, is higher [25] (it may require a linear number of calls to a SAT oracle). Since mostMax-SAT applications require the expressiveness of weights, in this paper we will focus on weighted Max-SAT. Inthe following, when we say Max-SAT we will be referring to weighted Max-SAT.Example 5. Given a graph G = (V , E), a vertex covering is a set U ⊆ V such that for every edge (vi, vj ) eithervi ∈ U or vj ∈ U . The size of a vertex covering is |U |. The minimum vertex covering problem is a well-known NP-hard problem. It consists in finding a covering of minimal size. It can be naturally formulated as (weighted) Max-SAT.We associate one variable xi to each graph vertex. Value true (respectively, false) indicates that vertex xi belongs toU (respectively, to V − U ). There is a binary weighted clause (xi ∨ xj , u) for each edge (vi, vj ) ∈ E, where u is anumber larger than or equal to |V |. It specifies that at least one of these vertices must be in the covering because thereis an edge connecting them. There is a unary clause ( ¯xi, 1) for each variable xi , in order to specify that it is preferrednot to add vertices to U . Note that different weights in unary and binary clauses are required to express the relativeimportance of each type of clauses.Consider the minimum vertex covering of the graph in Fig. 1(a). The Max-SAT encoding is F = {( ¯x1, 1), ( ¯x2, 1),( ¯x3, 1), ( ¯x4, 1), ( ¯x5, 1), (x1 ∨ x4, 5), (x2 ∨ x3, 5), (x2 ∨ x4, 5), (x2 ∨ x5, 5), (x4 ∨ x5, 5)}. The optimal assignment is{x2 = x4 = true, x1 = x3 = x5 = false} with cost 2 that is equal to the size of the minimum vertex covering.Next, we propose an alternative, although equivalent, definition for weighted Max-SAT that will be more convenientfor our purposes. Given a weighted CNF formula, we assume the existence of a known upper bound (cid:13) on the cost ofan optimal solution ((cid:13) is a strictly positive natural number). This is done without loss of generality because, if a tightupper bound is not known, (cid:13) can be set to any number higher than the sum of weights of all the clauses. A model forthe formula is a complete assignment with cost less than (cid:13). An optimal model is a model of minimal cost. Then, Max-SAT can be reformulated as the problem of finding an optimal model, if there is any. Observe that any weight w (cid:2) (cid:13)indicates that the associated clause must be necessarily satisfied. Thus, we can replace w by (cid:13) without changing theproblem. Thus, without loss of generality we assume all costs in the interval [0..(cid:13)] and define the sum of costs as,a ⊕ b = min{a + b, (cid:13)}J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233209in order to keep the result within the interval [0..(cid:13)]. A clause with cost (cid:13) is called mandatory (or hard). A clausewith cost less than (cid:13) is called non-mandatory (or soft).Definition 6. A Max-SAT instance is a pair (F, (cid:13)) where (cid:13) is a natural number and F is a set of weighted clauseswith weights in the interval [0..(cid:13)]. The task of interest is to find an optimal model, if there is any.The following example shows that (cid:13) can be used to express that we are only interested in assignments of a certainquality.Example 7. Consider again the minimum vertex covering problem of the graph in Fig. 1(a). With the new notation,the associated formula isF =(cid:3)(cid:4)( ¯x1, 1), ( ¯x2, 1), ( ¯x3, 1), ( ¯x4, 1), ( ¯x5, 1), (x1 ∨ x4, (cid:13)), (x2 ∨ x3, (cid:13)), (x2 ∨ x4, (cid:13)), (x2 ∨ x5, (cid:13)), (x4 ∨ x5, (cid:13))which shows more clearly which clauses are truly weighted and which ones are mandatory. In the lack of additionalinformation, (cid:13) should be set to the sum of weights ((cid:13) = 5), meaning that any assignment that satisfies the mandatoryclauses should be taken into consideration. Suppose now that somehow (for example, with a local search algorithm)we find a covering of size 3. We can set (cid:13) to 3 because any assignment with cost 3 or higher does not interest usanymore. The resulting Max-SAT problem is tighter (and easier, because more partial assignments can be identifiedas being unfeasible).The interest of adding (cid:13) to the problem formulation is twofold. On the one hand, it makes explicit the mandatorynature of mandatory clauses. Besides, as we will see later, it allows to discover mandatory clauses that were disguisedas weighted clauses. On the other hand, it allows to see SAT as a particular case of Max-SAT.Remark 8. A Max-SAT instance with (cid:13) = 1 is essentially a SAT instance because there is no weight below (cid:13).Consequently, every clause in the formula is mandatory.A weighted CNF formula may contain ((cid:2), w) among its clauses. Since (cid:2) cannot be satisfied, w is a necessary costof any model. Therefore, w is an explicit lower bound of the cost of an optimal model. When the lower bound and theupper bound have the same value (namely, ((cid:2), (cid:13)) ∈ F ) the formula is trivially unsatisfiable and we call this situationan explicit contradiction.4. Extending SAT solving techniques to Max-SAT4.1. Extending simplification rules and clause negationWe say that two Max-SAT formulas are equivalent, F ≡ F (cid:15), if the cost of their optimal assignment is the same orif neither of them has a model. The following equivalence rules can be used to simplify CNF weighted formulas,• Aggregation: {(A, w), (A, u)} ≡ {(A, w ⊕ u)}.• Absorption: {(A, (cid:13)), (A ∨ B, w)} ≡ {(A, (cid:13))}.• Unit clause reduction: {(l, (cid:13)), (¯l ∨ A, w)} ≡ {(l, (cid:13)), (A, w)}.• Hardening: If(cid:3)(cid:4)(Ci, ui)(cid:5)ki=1 ui = (cid:13) and ∀1(cid:2)i<kCi ⊂ Ck then(cid:4)(cid:3)(cid:3)k−1(Ck, (cid:13)).i=1(cid:4)(Ck, uk)(cid:4)(Ci, ui)k−1i=1≡∪∪(cid:3)Aggregation generalizes to Max-SAT the idempotency of the conjunction in classical SAT. The Absorption rule in-dicates that in the Max-SAT context the absorbing clause must be mandatory. Similarly, unit clause reduction requiresthe unit clause being mandatory. The correctness of these equivalences is direct and we omit the proof. The Hardeningrule allows to identify weighted clauses that are indeed mandatory. It holds because the violation of Ck implies theviolation of all Ci with i < k. Therefore, any assignment that violates Ck will have cost(cid:5)ki=1 ui = (cid:13).210J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233It is easy to see that the definitions of the pure literal rule and the assignment of a formula F[l] (see Section 2.2),can be directly applied to Max-SAT. As in SAT, F[l] can be seen as the addition of (l, (cid:13)) to the formula which allowsa sequence of unit clause reductions followed by the application of the pure literal rule.Example 9. Consider the following formula {(x, (cid:13)), ( ¯x, 3), (y, 8), ( ¯x ∨ ¯y, 3)} with (cid:13) = 10. We can apply unit clausereduction to the first and second clauses, which produces {(x, (cid:13)), ((cid:2), 3), (y, 8), ( ¯x ∨ ¯y, 3)}. We can apply it againto the first and fourth clauses producing {(x, (cid:13)), ((cid:2), 3), (y, 8), ( ¯y, 3)}. The pure literal rule allows to remove thefirst clause producing {((cid:2), 3), (y, 8), ( ¯y, 3)}. We can harden the second clause because 3 ⊕ 8 = (cid:13). Thus, we obtain{((cid:2), 3), (y, (cid:13)), ( ¯y, 3)}. Unit clause reduction produces {((cid:2), 3), (y, (cid:13)), ((cid:2), 3)}. Aggregation yields {((cid:2), 6), (y, (cid:13))}and the pure literal rule produces the formula {((cid:2), 6)} which trivially has an optimal model of cost 6.Proposition 10. The algorithm that applies the previous simplifications until quiescence terminates in polynomialtime.Observe that if an explicit contradiction is achieved (i.e., ((cid:2), (cid:13)) ∈ F ), all clauses are subsequently absorbed andthe formula immediately collapses to ((cid:2), (cid:13)).The negation of a weighted clause (C, w), noted ( ¯C, w), means that the satisfaction of C has cost w, while itsfalsification is cost-free. Note that ¯C is not in clausal form when |C| > 1. In classical SAT the De Morgan rule can beused to recover the CNF syntax, but the following example shows that it cannot be applied to weighted clauses.Example 11. Consider the weighted clause (x ∨ y, 1) with (cid:13) > 1. The truth table of its negation (x ∨ y, 1) and thetruth table of {( ¯x, 1), ( ¯y, 1)} are given below (ignore the last column for the moment). Note that they are not equivalent.x y(x ∨ y, 1)f ff tt ft t0111{( ¯x, 1), ( ¯y, 1)}0 ⊕ 0 = 01 ⊕ 0 = 10 ⊕ 1 = 11 ⊕ 1 = 2{( ¯x ∨ y, 1), (x ∨ ¯y, 1), ( ¯x ∨ ¯y, 1)}0 ⊕ 0 ⊕ 0 = 00 ⊕ 1 ⊕ 0 = 11 ⊕ 0 ⊕ 0 = 10 ⊕ 0 ⊕ 1 = 1The following recursive transformation rule allows to compute the clausal form for totally or partially negatedclauses. Let A and B be arbitrary disjunctions of clauses,⎧⎨CNF(A ∨ l ∨ B, u) =⎩(A ∨ ¯l, u){(A ∨ ¯l ∨ B, u)} ∪ CNF(A ∨ l ∨ ¯B, u)∪ CNF(A ∨ ¯l ∨ ¯B, u)case |B| = 0case |B| > 0The last column in the truth table of the previous example shows the proper CNF encoding of clause (x ∨ y, 1).The main drawback of this rule is that it generates an exponential number of new clauses with respect to the arity ofthe negated clause. We will show in Section 4.3 that it is possible to transform it into a linear number of clauses.Theorem 12. CNF(A ∨ l ∨ B, u) returns an equivalent CNF expression.Proof. It is clear that CNF(A ∨ l ∨ B, u) generates a CNF expression because the negation is applied to a smallersub-expression at each recursive call. Eventually, it will be applied to literals, so the expression will be a clause. Weprove that CNF(A ∨ l ∨ B, u) returns an equivalent expression by induction over |B|. The |B| = 0 is trivial since theleft-hand and the right-hand sides are the same. Regarding the |B| > 0 case, there are three ways to falsify A ∨ l ∨ B.Each one of the three elements in the right-hand side corresponds to one of them. The last two are assumed correct bythe induction hypothesis. (cid:2)Remark 13. The weighted expression (A ∨ C ∨ (C ∨ B), u), where A, B and C are disjunctions of literals, is equiv-alent to (A ∨ C ∨ ¯B, u), because they are falsified under the same circumstances.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233211function Max-DPLL(F , (cid:13)) return N1. F := Simplify(F , (cid:13))if F = ∅ then return 02.if F = {((cid:2), w)} then return w3.l := SelectLiteral(F )4.5. (cid:13) := Max-DPLL(F [l], (cid:13))6. (cid:13) := Max-DPLL(F [¯l], (cid:13))7. return (cid:13)endfunctionFig. 4. If (F , (cid:13)) has models, Max-DPLL returns the optimal cost. Else it returns (cid:13).4.2. Extending DPLLIn Fig. 4 we present Max-DPLL, the extension of DPLL to Max-SAT. Max-DPLL(F, (cid:13)) returns the cost of theoptimal model if there is any, else it returns (cid:13). First, the input formula is simplified with the rules from the previoussubsection (line 1). If the resulting formula is empty, there is a 0 cost model (line 2). If the resulting formula onlycontains the empty clause, the algorithm returns its cost (line 3). Else, it selects a literal l (line 4) and makes tworecursive calls (lines 5 and 6). In each call, the formula is instantiated with l and ¯l. Observe that the first recursivecall is made with the (cid:13) inherited from its parent, but the second call uses the output of the first call. This implementsthe typical upper bound updating of depth-first branch and bound. Finally, the best value of the two recursive calls isreturned (line 7). Observe that, as search goes on, the value of (cid:13) may decrease. Consequently, clauses that originallywere soft may become hard which, in turn, may strengthen the potential of the simplification rules. The parallelismwith DPLL (Fig. 2) is obvious. The following statement shows that Max-DPLL is a true extension of classical DPLL.Remark 14. The execution of Max-DPLL with a SAT instance (i.e., (F, (cid:13)) with (cid:13) = 1) behaves like classical DPLL.It is easy to see that the time complexity of Max-DPLL is exponential on the number of variables n and the spacecomplexity is polynomial on |F|. Therefore, DPLL and Max-DPLL have the same complexity.4.3. Extending the resolution ruleConsider the subtraction of costs ((cid:17)) defined as in [26]. Let u, w ∈ [0, . . . , (cid:13)] be two weights such that u (cid:2) w,(cid:2)u (cid:17) w =u − w, u (cid:5)= (cid:13)u = (cid:13)(cid:13),Essentially, (cid:17) behaves like the usual subtraction except that (cid:13) is an absorbing element. The resolution rule can beextended from SAT to Max-SAT as,⎧(cid:4)(cid:3)(x ∨ A, u), ( ¯x ∨ B, w)≡⎪⎪⎪⎪⎨⎪⎪⎪⎪⎩(A ∨ B, m),(x ∨ A, u (cid:17) m),( ¯x ∨ B, w (cid:17) m),(x ∨ A ∨ ¯B, m),( ¯x ∨ ¯A ∨ B, m)⎫⎪⎪⎪⎪⎬⎪⎪⎪⎪⎭,where m = min{u, w}. In this rule, that we call Max-RES, (A ∨ B, m) is called the resolvent; (x ∨ A, u (cid:17) m) and( ¯x ∨ B, w (cid:17) m) are called the posterior clashing clauses. (x ∨ A ∨ ¯B, m) and ( ¯x ∨ ¯A ∨ B, m) are called the compensa-tion clauses. The effect of Max-RES, as in classical resolution, is to infer (namely, make explicit) a connection betweenA and B. However, there is an important difference between classical resolution and Max-RES. While classical res-olution yields the addition of a new clause, Max-RES is a transformation rule. Namely, it requires the replacementof the left-hand clauses by the right-hand clauses. The reason is that some cost of the prior clashing clauses must besubtracted in order to compensate the new inferred information. Consequently, Max-RES is better understood as amovement of knowledge.212J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Example 15. If we apply Max-RES to the following clauses {(x ∨ y, 3), ( ¯x ∨ y ∨ z, 4)} (with (cid:13) > 4) we obtain{(y ∨ y ∨ z, 3), (x ∨ y, 3 (cid:17) 3), ( ¯x ∨ y ∨ z, 4 (cid:17) 3), (x ∨ y ∨ (y ∨ z), 3), ( ¯x ∨ ¯y ∨ y ∨ z, 3)}. The first and fourth clausescan be simplified (see Remark 13). The second clause can be omitted because its weight is zero. The fifth clause can beomitted because it is a tautology. Therefore, we obtain the equivalent formula {(y ∨ z, 3), ( ¯x ∨ y ∨ z, 1), (x ∨ y ∨ ¯z, 3)}.The previous example shows that, under certain conditions, some of the right-hand side clauses can be removed.Clause (x ∨ A, u (cid:17) m) (symmetrically for ( ¯x ∨ B, w (cid:17) m)) can be omitted if and only if either,• B ⊆ A ∧ m = (cid:13), or• u = m < (cid:13).The first case holds because the clause is absorbed by the resolvent (A, (cid:13)). The second case holds because u (cid:17) m = 0.Regarding clause (x ∨ A ∨ ¯B, m) (symmetrically for ( ¯x ∨ ¯A ∨ B, m)), it can be omitted if and only if either,• B ⊆ A, or• u = (cid:13).The first case holds because the clause is a tautology. The second case holds because the clause is absorbed by theposterior clashing clause (x ∨ A, (cid:13) (cid:17) m = (cid:13)).Remark 16. The application of Max-RES to mandatory clauses is equivalent to classical resolution.Proof. Clashing clauses being mandatory means that u = w = (cid:13). Clearly, m = min{u, w} = (cid:13), u (cid:17) m = (cid:13) andw (cid:17) m = (cid:13). Consequently, all right-hand clauses are mandatory. Therefore, the prior and posterior clashing clausesare equal. Furthermore, the compensation clauses are absorbed by the clashing clauses (as we previously noted). Thus,Max-RES has the effect of adding (A ∨ B, (cid:13)) to the formula, which is equivalent to classical resolution. (cid:2)Theorem 17. Max-RES is sound.Proof. The following table contains in the first column all the truth assignments, in the second column the cost ofthe assignment according to the clauses on the left-hand of the Max-RES rule, and in the third column the cost of theassignment according to the clauses on the right-hand of the Max-RES rule. As it can be observed, the costs are thesame, so the resulting problem is equivalent.x A BLeftf f ff f tf t ff t tt f ft f tt t ft t tuu00w0w0Rightm ⊕ (u (cid:17) m)m ⊕ (u (cid:17) m)00m ⊕ (w (cid:17) m)0m ⊕ (w (cid:17) m)0Observe that compensation clauses (x ∨ A ∨ ¯B, m) and ( ¯x ∨ ¯A ∨ B, m) are not in clausal form when |A| > 1and |B| > 1. In the following, we assume that they are transformed to clausal forms as needed. In Section 4.1, weintroduced a recursive rule that computes a clausal form for totally or partially negated clauses. We noted that itproduces an exponentially large number of new clauses. Interestingly, using insights from the Max-RES rule, we canredefine it in such a way that only a linear number of clauses is generated,(cid:2)CNFlinear(A ∨ l ∨ B, u) =A ∨ ¯l,{(A ∨ ¯l ∨ B, u)} ∪ CNFlinear(A ∨ ¯B, u),The new rule is correct because the two recursive calls of CNF (Section 4.1), CNF(A ∨ l ∨ ¯B, u) and CNF(A ∨ ¯l ∨¯B, u), can be resolved on literal l and we obtain the equivalent call CNF(A ∨ ¯B, u). For example, the application|B| = 0|B| > 0J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233213(xi ∨ A, u) := PopMinSizeClause(B)while u > 0 ∧ ∃( ¯xi ∨B,w)∈B s.t. Clash(xi ∨ A, ¯xi ∨ B) dom := min{u, w}u := u (cid:17) mB := B − {( ¯xi ∨ B, w)} ∪ {( ¯xi ∨ B, w (cid:17) m)}B := B ∪ {(xi ∨ A ∨ ¯B, m), ( ¯xi ∨ ¯A ∨ B, m)}F := F ∪ {(A ∨ B, m)}function Max-VarElim(F , (cid:13), xi ) return weighted CNF formula1. B := {(C, u) ∈ F | xi ∈ var(C)}2. F := F − B3. while ∃(xi ∨ A, u) ∈ B do45.6.7.8.9.10.11.12. endwhile13. return (F )endfunctionfunction Max-DP(F , (cid:13)) return N14. F := Simplify(F , (cid:13))15. if F = ∅ then return 016. if F = {((cid:2), u)} then return u17. xi := SelectVar(F )18. return Max-DP(VarElim(F , (cid:13), xi ),(cid:13))endfunctionendwhileFig. 5. If (F , (cid:13)) has models, Max-DP returns their optimal cost. Else it returns (cid:13).of CNFlinear to (x ∨ y, 1) (Example 11) produces the equivalent {( ¯x ∨ y, 1), ( ¯y, 1)}. Observe that the output ofCNFlinear depends on how the literals are ordered in the clause. (cid:2)4.4. Extending DPThe following example shows that, unlike classical resolution, the unrestricted application of Max-RES does notguarantee termination.Example 18. Consider the following formula {(x ∨ y, 1), ( ¯x ∨ z, 1)} with (cid:13) = 3. If we apply Max-RES, we obtain{(y ∨ z, 1), (x ∨ y ∨ ¯z, 1), ( ¯x ∨ ¯y ∨ z, 1)}. If we apply Max-RES to the first and second clauses we obtain {(x ∨ y, 1),( ¯x ∨ y ∨ z, 1), ( ¯x ∨ ¯y ∨ z, 1)}. If we apply now Max-RES to the second and third clauses we obtain {(x ∨ y, 1),( ¯x ∨ z, 1)}, which is the initial formula.Nevertheless, Bonet et al. [27] have recently proved that when all clauses are non-mandatory, the directional appli-cation of Max-RES solves the Max-SAT problem. If their proof is combined with the proof of correctness of DP [21](namely, all clauses being mandatory), we have that the extension of DP to Max-SAT produces a correct algorithm.Max-DP (depicted in Fig. 5) is the extension of DP to Max-SAT. Both algorithms are essentially equivalent the maindifference being that Max-DP performs Max-RES instead of classical resolution. Observe the parallelism betweenFunction VarElim (Fig. 3) and Function Max-VarElim (Fig. 5). Both are in charge of the elimination of variablexi from the formula. As in the SAT case, Max-VarElim computes the bucket B (line 1) and removes its clausesfrom the formula (line 2). Then, it selects a clause (x ∨ A, u) and resolves it with all its clashing clauses. The functionClash is similar to its SAT definition (see Section 2.2), that is A ∨ B is not a tautology and is not absorbed in F ,except that it is now based on the Max-SAT definition of absorption. In VarElim, clause x ∨ A is resolved untilno clashing clauses exist. In Max-VarElim, clause (x ∨ A, u) is resolved until its weight u decreases to 0 or noclashing clauses exist. A difference worth noting with respect to the SAT case is that Max-VarElim selects in line 4a minimal size clause. This is not required for the correctness of the algorithm but only to achieve the complexitystated in Theorem 23.The following lemma shows that Max-VarElim transforms the input formula preserving its optimality.214J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Lemma 19. Consider a call to the Max-VarElim function. Let (F, (cid:13)) denote the input formula and let (F (cid:15), (cid:13))denote the output formula. It is true that (F, (cid:13)) has models if and only if (F (cid:15), (cid:13)) has models. Besides, if (F, (cid:13)) hasmodels, the cost of the optimal one is the same as the cost of the optimal model of (F (cid:15), (cid:13)).Proof. See Appendix A. (cid:2)Theorem 20. Algorithm Max-DP is correct.Proof. Max-DP is a sequence of variable eliminations until a variable-free formula is obtained. Lemma 19 showsthat each transformation preserves the cost of the optimal model. Therefore, the cost of the final variable-free formula((cid:2), u) is the cost of the optimal model of the original formula. (cid:2)The following lemma, shows that the complexity of eliminating a variable is the same in classical SAT as in Max-SAT.Lemma 21. Let (F, (cid:13)) be a Max-SAT instance and xi one of its variables. Let ni denote the number of variablessharing some clause with xi in F . The space and time complexity of Max-VarElim(F, (cid:13), xi ) is O(3ni ) and O(9ni ),respectively.Proof. See Appendix A. (cid:2)The next lemma shows that the induced graph plays the same role in DP as in Max-DP.Lemma 22. Let d denote the reverse order in which Max-DP(F, (cid:13)) eliminates variables. The width of xi along din the induced graph G(F)∗d bounds above the number of variables sharing some clause with xi at the time of itselimination.Proof. Same as in the SAT case (Lemma 3). (cid:2)The following theorem, which trivially follows from the previous two lemmas, bounds the complexity of Max-DP.Theorem 23. Let (F, (cid:13)) be an arbitrary Max-SAT instance. Let d denote the reverse order in which Max-DP(F, (cid:13))eliminates variables. The space and time complexity of DP(F) is O(n × 3w∗d ), respectively, where w∗dis the induced width of the interaction graph G(F) along d.d ) and O(n × 9w∗Observe that the complexities of DP and Max-DP are the same, even though Max-SAT has a complexity higherthan SAT. The following remark shows that Max-DP is a true extension of DP.Remark 24. The execution of Max-DP with a SAT instance (i.e., (F, (cid:13)) with (cid:13) = 1) behaves like classical DP.5. Efficient inferenceThe complexity results of the previous section show that solving Max-SAT with pure resolution methods is ingeneral too space consuming and can only be used in practice with formulas with a small induced width (around 30with current computers). A natural alternative is to use only restricted forms of resolution that simplify the formulaand use search afterwards. In this Section we summarize some simplification rules that have been proposed in therecent Max-SAT literature and show that they can be naturally explained with our framework. We also introduce twooriginal ones that will be used in the solver that we will introduce in Section 6.We classify these simplification rules in three categories: single applications of resolution, multiple applicationsof resolution (namely, hyper-resolution), and variable elimination. The following rules are presented in their generalform. In Section 6, we will use a subset of these rules in a restricted form.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–2332155.1. Single resolutionProposition 25. Unit clause reduction (also called upper bound rule in [13]),(cid:4)(cid:3)(l, (cid:13)), (¯l ∨ A, w)≡(cid:3)(cid:4)(l, (cid:13)), (A, w)is a particular case of Max-RES.Proof. If w = (cid:13), we have the classical SAT case, which is trivial. If w < (cid:13), we have that the application of Max-RESto {(l ∨ (cid:2), (cid:13)), (¯l ∨ A, w)} produces {(A, w), (l, (cid:13) (cid:17) w), (¯l ∨ A, w (cid:17) w), (l ∨ (cid:2) ∨ ¯A, w), (¯l ∨ ¬(cid:2) ∨ A, w)}.The third clause can be removed because w (cid:17) w = 0. The fourth clause can be removed because it is absorbed bythe second. The fifth clause can be removed because it is a tautology. (cid:2)Proposition 26. Neighborhood resolution [1] (also called replacement of almost common clauses in [8]),(cid:4)(cid:3)(l ∨ A, u), (¯l ∨ A, w)≡(cid:4)(cid:3)(A, w), (l ∨ A, u (cid:17) w)where, without loss of generality, w (cid:3) u, is a particular case of Max-RES.Proof. Resolving the two left-hand clauses, we obtain {(A, w), (l ∨ A, u (cid:17) w), (¯l ∨ A, w (cid:17) w), (l ∨ A ∨ ¯A, w),(¯l ∨ ¯A ∨ A, w)}. The third clause can be omitted because either its weight is 0 (when w < (cid:13)), or it is absorbed by theresolvent (when w = (cid:13)). The fourth and fifth clauses can be omitted because they are tautologies. (cid:2)The simplification potential of neighborhood resolution is shown in the following example.Example 27. Consider the formula {(y ∨ z, 1), ( ¯y ∨ z, 1), (¯z, 1)}. The application of neighborhood resolution yields{(z, 1), (¯z, 1)} which allows a new application of neighborhood resolution producing the trivial formula {((cid:2), 1)}.The term neighborhood resolution was coined by [28] in the SAT context. The Max-SAT extension was firstproposed in [8]. The practical efficiency of the |A| = 0, 1, 2 cases was assessed in [29,30], [14] and [1], respectively.5.2. Variable eliminationProposition 28. The pure literal rule ( first proposed in the Max-SAT context in [8]) is a special case of Max-VarElim.Proof. Consider a formula F such that there is a literal l, whose negation does not appear in the formula. Let x =var(l). Function Max-VarElim(F, (cid:13), x) has the same effect as the pure literal rule, because there is no pair ofclauses clashing on x. Thus, no resolution will be performed and all clauses containing l will be removed from theformula. (cid:2)Proposition 29. The elimination rule [8] (also called resolution in [9,10]) which says that if F = {(l ∨ A, u),(¯l ∨ B, w)} ∪ F (cid:15) and var(l) does not occur in F (cid:15) thenA ∨ B, min{u, w}F ≡ F (cid:15) ∪(cid:3)(cid:13)(cid:14)(cid:4)is a special case of Max-VarElim .Proof. Let x be the clashing variable (namely, x = var(l)). We need to prove that Function Max-VarElim with xas the elimination variable replaces {(l ∨ A, u), (¯l ∨ B, w)} by {(A ∨ B, min{u, w})}. There are two possibilities: If{(l ∨A, u), (¯l ∨B, w)} clash, they will be resolved and (A∨B, min{u, w}) will be added to the formula. All the clausesin the bucket after the resolution step do not clash on x, so Max-VarElim will discard them. If {(l ∨A, u), (¯l ∨B, w)}do not clash, Max-VarElim will directly discard them. In that case, A ∨ B either is a tautology or is absorbed, so ithas no effect on the right-hand side of the elimination rule. (cid:2)216J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Fig. 6. Graphical representation of Max-RES.Proposition 30. Let ˜x denote either x or ¯x. The small subformula rule [9], which says that, if F = {( ˜x ∨ ˜y ∨ A, u),( ˜x ∨ ˜y ∨ B, w), ( ˜x ∨ ˜y ∨ C, v)} ∪ F (cid:15) and x, y do not occur in F (cid:15) thenF ≡ F (cid:15)is a special case of Max-VarElim .Proof. We only need to prove that if we eliminate x and y from {( ˜x ∨ ˜y ∨ A, u), ( ˜x ∨ ˜y ∨ B, w), ( ˜x ∨ ˜y ∨ C, v)} withfunction Max-VarElim, we obtain the empty formula ∅.If all the occurrences of x or y have the same sign, the rule holds because the pure literal rule can be applied. Ifthere are occurrences of different sign, there are only two cases to consider (all other cases are symmetric):• If we have {(x ∨ y ∨ A, u), (x ∨ y ∨ B, v), ( ¯x ∨ ¯y ∨ C, w)}, there are no clauses clashing on x (neither on y), soMax-VarElim will just discard the clauses.• If we have {(x ∨ y ∨ A, u), ( ¯x ∨ y ∨ B, v), (x ∨ ¯y ∨ C, w)}, the first and second clauses clash, so Max-RESproduces,(cid:3)(y ∨ A ∨ B, m), (x ∨ y ∨ A, u (cid:17) m), ( ¯x ∨ y ∨ B, v (cid:17) m), (x ∨ y ∨ A ∨ y ∨ B, m),( ¯x ∨ y ∨ A ∨ y ∨ B, m), (x ∨ ¯y ∨ C, w),(cid:4)where m = min{u, v}; which is equivalent to,(cid:3)(y ∨ A ∨ B, m), (x ∨ y ∨ A, u (cid:17) m), ( ¯x ∨ y ∨ B, v (cid:17) m), (x ∨ y ∨ A ∨ ¯B, m),(cid:4)( ¯x ∨ ¯A ∨ y ∨ B, m), (x ∨ ¯y ∨ C, w).There are no further clauses clashing on x. Note that the second and third clauses do not clash: either u < (cid:13) ∨v < (cid:13) and one of these two clauses has a zero weight and can be discarded, or u = v = (cid:13) and because theresolvent is already in the formula (first clause), the two clauses do not clash by definition of absorption. SoMax-VarElim will just discard all the clauses that mention it, producing the equivalent {(y ∨ A ∨ B, m)}. Thepure literal rule will eliminate the clause, producing the empty formula. (cid:2)5.3. Hyper-resolutionHyper-resolution is a well known SAT concept that refers to the compression of several resolution steps intoone single step. In the following, we introduce four hyper-resolution inference rules. The first two (star rule anddominating unit-clause) are formal descriptions of already published rules. The other two rules (cycle and chainresolution) are original. We prove the correctness of these rules by developing the resolution tree that allows totransform the left-hand side of the rule into the right-hand side. Fig. 6 shows the graphical representation of Max-RES. On top there are the two prior clashing clauses. We write them in bold face to emphasize that they are removedfrom the formula. The resolvent is linked to the prior clashing clauses. At the left of the resolvent, we write theposterior clashing clauses and the compensation clashing clauses, which must be added to preserve equivalence.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233217Fig. 7. Resolution tree for the star rule.5.3.1. Star ruleThe star rule [9,14] identifies a clause of length k such that each of its literals appears negated in a unit clause.Then, at least one of the clauses will be falsified. Formally,(cid:2)(l1 ∨ l2 ∨ · · · ∨ lk, w),(¯li, ui)1(cid:2)i(cid:2)k(cid:15)⎧⎪⎪⎨≡⎪⎪⎩(l1 ∨ l2 ∨ · · · ∨ lk, w (cid:17) m),(¯li ∨ (li+1 ∨ li+2 ∨ · · · ∨ lk), m)1(cid:2)i<k,(¯li, ui (cid:17) m)1(cid:2)i(cid:2)k,((cid:2), m)⎫⎪⎪⎬⎪⎪⎭,where m = min{w, u1, u2, . . . , uk}.This rule can be proved in k resolution steps. Assume, without loss of generality, that ∀1(cid:2)i<k ui (cid:3) ui+1. Assume aswell that uk < (cid:13) (otherwise unit clause reduction could have been previously triggered). Let m = min{w, u1}. Fig. 7shows the corresponding resolution tree. Recall that bold clauses are resolved, so they must be removed from theformula. Essentially, each unit clause is used to eliminate one literal from the length k clause. At the end, we derivethe empty clause.5.3.2. Dominating unit-clauseThe dominating unit-clause rule [9] (also called UP3 in [13]) says that if the weight of a unit clause (l, u) is higherthan the sum of weights in which ¯l appears, we can safely assign l to the formula. Formally,with u (cid:2)F =(cid:16)F ≡∪∪k(cid:15)i=1(cid:4)(cid:3)(l ∨ Ai, ui)(cid:4)(cid:3)(l, u)j =1 wj and F (cid:15) does not contain any occurrence of l or ¯l, then(cid:3)(cid:4)(Bj , wj )(cid:4)(cid:3)(¯l ∨ Bj , wj )kj =1∪ F (cid:15)∪ F (cid:15).kkj =1This rule can be proved in k resolution steps plus the application of the pure literal rule. Fig. 8 shows the correspondingresolution tree. As in the previous case, we can assume that weight u is less than (cid:13) because otherwise the unit clause218J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Fig. 8. Resolution tree for the dominating unit clause rule.reduction could have been triggered. At each step, unit clause l is resolved with one (¯l ∨ Bj , wj ). Since, by definition,the weight of l is larger than or equal to wj , clause ¯l ∨ Bj is replaced by Bj . At the end of the process, there is noclause mentioning ¯l, so the pure literal rule can be applied, which proves the correctness of the rule.5.3.3. Chain resolutionOur original chain resolution rule identifies a subset of chained binary clauses and two unit clauses associated tothe ends. When such pattern exists, a sequence of unit resolution steps suffices to derive the empty clause. The rule isthe following,⎧⎨⎩(l1, u1),(¯li ∨ li+1, ui+1)1(cid:2)i<k,(¯lk, uk+1)⎫⎬⎭≡⎧⎪⎪⎪⎪⎨⎪⎪⎪⎪⎩(li, mi (cid:17) mi+1)1(cid:2)i(cid:2)k,(¯li ∨ li+1, ui+1 (cid:17) mi+1)1(cid:2)i<k,(li ∨ ¯li+1, mi+1)1(cid:2)i<k,(¯lk, uk+1 (cid:17) mk+1),((cid:2), mk+1)⎫⎪⎪⎪⎪⎬⎪⎪⎪⎪⎭,where mi = min{u1, u2, . . . , ui} and ∀1(cid:2)i<j (cid:2)k var(li) (cid:5)= var(lj ). This rule can also be proved in k steps of resolution.Fig. 9 shows the corresponding resolution tree. Starting with unit clause l1, at each resolution step a unit clause li isresolved with (¯li ∨ li+1, ui+1), which produces the unit clause li+1 to be used in the following resolution step. Thelast unit clause obtained is lk and it is resolved with (¯lk, uk+1), which derives the empty clause.Example 31. Consider the following formula {(x, 2), ( ¯x ∨ y, 1), ( ¯y ∨ z, (cid:13)), (¯z, 2)}. If we resolve (x, 2) and ( ¯x ∨ y, 1)we obtain {(x, 1), (y, 1), (x ∨ ¯y, 1), ( ¯y ∨ z, (cid:13)), (¯z, 2)}. If we resolve (y, 1) and ( ¯y ∨ z, (cid:13)) we obtain {(x, 1),(x ∨ ¯y, 1), (z, 1), (y ∨ ¯z, 1), ( ¯y ∨ z, (cid:13)), (¯z, 2)}. Next, if we resolve (z, 1) and (¯z, 2), we obtain {(x, 1), (x ∨ ¯y, 1),(y ∨ ¯z, 1), ( ¯y ∨ z, (cid:13)), (¯z, 1), ((cid:2), 1)}.Observe that chain resolution with k = 1 reduces to simple neighborhood resolution, with k = 2 reduces to the starrule limited to binary clauses, with k = 3, it is the 3-RES rule proposed in [2].J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233219Fig. 9. Resolution tree for the chain resolution rule.5.3.4. Cycle resolutionOur original cycle resolution rule identifies a subset of binary clauses with a cyclic structure. When such a patternexists, a sequence of resolution steps with binary clauses suffices to derive a new unit clause. The rule is the following,(cid:2)(¯li ∨ li+1, ui)1(cid:2)i<k,(¯l1 ∨ ¯lk, uk)(cid:15)≡⎧⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎩(¯l1 ∨ li, mi−1 (cid:17) mi)2(cid:2)i(cid:2)k,(¯li ∨ li+1, ui (cid:17) mi)2(cid:2)i<k,(¯l1 ∨ li ∨ ¯li+1, mi)2(cid:2)i<k,(l1 ∨ ¯li ∨ li+1, mi)2(cid:2)i<k,(¯l1 ∨ ¯lk, uk (cid:17) mk),(¯l1, mk)⎫⎪⎪⎪⎪⎪⎪⎬⎪⎪⎪⎪⎪⎪⎭,where mi = min{u1, u2, . . . , ui} and ∀1(cid:2)i<j (cid:2)k var(li) (cid:5)= var(lj ). This rule can be proved in k − 1 steps of resolution.Fig. 10 shows the corresponding resolution tree. The use of the cycle rule is to derive new unit clauses that, in turn,can be used by chain resolution to increase the weight of the empty clause.Example 32. Consider the formula {(x1 ∨ x2, 1), ( ¯x1 ∨ x3, 1), ( ¯x2 ∨ x3, 1), ( ¯x3 ∨ ¯x4, 1), (x4 ∨ x5, 1), ( ¯x5, 1)}. We canapply the cycle rule to the three first clauses obtaining, {(x3, 1), (x1 ∨ x2 ∨ ¯x3, 1), ( ¯x1 ∨ ¯x2 ∨ x3, 1), ( ¯x3 ∨ ¯x4, 1),(x4 ∨ x5, 1), ( ¯x5, 1)}. Chain resolution can be applied to the unary and binary clauses producing, {(x1 ∨ x2 ∨ ¯x3, 1),( ¯x1 ∨ ¯x2 ∨ x3, 1), (x3 ∨ x4, 1), ( ¯x4 ∨ ¯x5, 1), ((cid:2), 1)}.6. An efficient Max-SAT solverIn the previous section we presented a set of simplification rules. Some of them have been previously proposedby other researchers, while some others are original. We showed that all of them can be viewed as special cases ofresolution, hyper-resolution or variable elimination. In this section we consider their incorporation into the Max-DPLLalgorithm introduced in Section 4.2. The idea is to use these rules to simplify the current Max-SAT formula before220J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Fig. 10. Resolution tree for the cycle resolution rule.letting Max-DPLL branch on one of the variables. Our experimental work indicates that it is not cost effective to applyall of them on a general basis. We have observed that only three rules are useful in general: neighborhood resolution,chain resolution and cycle resolution. Besides, it only pays off to apply these rules to clauses of very small size (upto 2). The reason being that there is only a quadratic number of them which bounds the overhead of the detection ofsituations when they can be triggered. Regarding cycle resolution, we only found effective to apply the k = 3 case(namely, considering triplets of variables). Note that the fact that our solver only incorporates these three rules, doesnot prevent other rules from being effective in a particular class of problems where we did not experiment.A high-level description of our solver appears in Fig. 11. It is Max-DPLL augmented with the simplification rulesin function Simplify. This function iteratively simplifies the formula. It stops when an explicit contradiction isderived or no further simplification can be done (line 10). Simplification rules are arranged in an ordered manner,which means that if two rules R and R(cid:15) can be applied, and rule R has higher priority than rule R(cid:15), the algorithm willchose R. The rules with the highest priority are unit clause reduction and absorption grouped in the assignment F[l]operation (line 3). Next, we have aggregation (line 4), hardening (line 5), neighborhood resolution (line 6), chainresolution (line 7) and cycle resolution restricted to cycles of length 3 (line 8). All the rules are restricted to unary andbinary clauses. We do not apply any variable elimination rule.Although our actual implementation is conceptually equivalent to the pseudo-code of Fig. 11 it should be noted thatsuch code aims at clarity and simplicity. Thus, a direct translation into a programming language is highly inefficient.The main source of inefficiency is the time spent searching for clauses that match with the left-hand side of thesimplification rules. This overhead, which depends on the number of clauses, takes place at each iteration of theloop. As we mentioned, our current implementation only takes into account clauses of arity less than or equal to two.Another way to decrease such overhead is to identify those events that potentially make a transformation applicable.For instance, a clause may be made mandatory (line 5) only when its weight or the weight of the empty clauseincreases. Then, our implementation reacts to these events and triggers the corresponding rules. Such approach iswell-known in the constraint satisfaction field and it is usually implemented with streams of pending events [31,32].J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233221stop := falsefunction Simplify(F , (cid:13))1.2. doif (l, (cid:13)) ∈ F then apply F [l]3.elseif {(C, u), (C, w)} ⊆ F then apply Aggregation4.elseif {((cid:2), u), (C, w)} ⊆ F ∧ u ⊕ w = (cid:13) then apply Hardening5.elseif {(x ∨ A, u), ( ¯x ∨ A, w)} ⊆ F then apply Neighborhood Res.6.elseif {(l1, u1), (¯li ∨ li+1, ui+1)1(cid:2)i<k, (¯lk, uk+1)} ⊆ F then apply Chain Res.7.elseif {{(l ∨ h, u), (¯l ∨ q, v), ( ¯h ∨ q, w)}} ⊆ F then apply Cycle Res.8.else stop := true9.10. until ((((cid:2), (cid:13)) ∈ F ) ∨ stop)11. return (F )endfunctionfunction Max-DPLL(F , (cid:13)) return N12. F := Simplify(F , (cid:13))13. if F = ∅ then return 014. if F = {((cid:2), w)} then return w15. l := SelectLiteral(F )16. (cid:13) := Max-DPLL(F [l], (cid:13))17. (cid:13) := Max-DPLL(F [¯l], (cid:13))18. return (cid:13)endfunctionFig. 11. Max-DPLL enhanced with inference. Function Simplify(F , (cid:13)) converts the input formula into a simpler one. Note that in our imple-mentation, for efficiency reasons, we only consider the |A| (cid:3) 1 and |C| (cid:3) 2 case.The way in which we detect the chain resolution pattern also deserves special consideration. At each search node,we consider the set of binary and unary clauses and compute the corresponding implication graph defined as follows:• for each variable xi , the graph has two vertices xi and ¯xi ,• for each binary clause (li ∨ lj , u), the graph has two arcs: (¯li, lj ) and (¯lj , li). We say that these two arcs arecomplementary,• if the formula contains the unit clause (l, u), we say that vertex l is a starting vertex, and vertex ¯l is an endingvertex.It is easy to see that if there is a path (l1, l2, . . . , lk), where l1 and lk are starting and ending vertices, respectively,and the path does not cross any pair of complementary arcs, then chain resolution can be applied and the path tells theorder in which resolution must be applied.In our implementation, we select one arbitrary starting vertex and compute shortest paths to all ending verticesusing Dijkstra’s algorithm. If one of the paths does not cross complementary arcs, we trigger the rule. Else, anotherstarting vertex is selected and the process is repeated. Note that this method does not necessarily detect all the potentialapplications of chain resolution because it only takes into consideration one path between each pair of starting andending vertices (the shortest path given by Dijkstra). The fact that this path crosses complementary arcs does notprevent the existence of other paths that do not cross complementary arcs. We believe that a better approach would beto use a flow algorithm, but we have not yet studied this possibility.7. Experimental resultsWe divide the experiments in two parts. The purpose of the first part is to assess the importance of the differ-ent inference rules that our solver incorporates. These experiments include random Max-SAT instances and randomMax-Clique problems. The purpose of the second part is to evaluate the performance of our solver in comparison toother available solving techniques. These experiments include random weighted and unweighted Max-SAT instances,random and structured Max-One problems, random Max-Cut problems, random, structured and real Max-Cliqueproblems and combinatorial auctions.222J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Our solver, written in C, is available as part of the TOOLBAR software1 (version 3.0). Benchmarks are also availablein the TOOLBAR repository. In all the experiments with random instances, samples have 30 instances and plots reportmean CPU time in seconds. Executions were made on a 3.2 GHz Pentium 4 computer with Linux. Unless otherwiseindicated, executions were aborted when they reached a time limit of 1200 seconds. In all the plots’ legend, the orderof the items reflects the relative performance order of the different competitors. Default options were used for all thecompetitors’ solvers. No initial upper bounds were given, so the reported CPU time is the time to find an optimalsolution and prove its optimality.7.1. Adding inference to Max-DPLLWe consider the following versions of our solver:(1) Basic Max-DPLL. Namely, Algorithm 11 in which lines 6–8 in Function Simplify are commented out. Wedenote this algorithm Max-DPLL-1.(2) The previous algorithm enhanced with neighborhood resolution (namely, lines 7–8 in Simplify are commentedout). We denote this algorithm Max-DPLL-2.(3) The previous algorithm enhanced with chain resolution (namely, line 8 in Simplify is commented out). Wedenote this algorithm Max-DPLL-3.(4) The previous algorithm enhanced with cycle resolution (namely, all the lines in Simplify are considered). Wedenote this algorithm Max-DPLL-4.For the first experiment we consider random Max-k-SAT instances. A random k-SAT formula is defined by threeparameters (cid:18)k, n, m(cid:19). k is the fixed size of the clauses, n is the number of variables and m is the number of clauses.Each clause is randomly generated by selecting k distinct variables with a uniform probability distribution. The signof each variable in each clause is randomly chosen. In the following experiments we generate instances in which thenumber of clauses is always sufficiently high as to make the formula unsatisfiable and we solved the correspondingMax-SAT problem. We used the Cnfgen2 generator. Note that it allows repeated clauses, so v repetitions of a clauseC are grouped into one weighted clause (C, v).Fig. 12 (top-left) reports the results on random Max-2-SAT instances with 100 variables and varying number ofclauses. It can be seen that Max-DPLL-1 performs very poorly and can only solve instances with up to 200 clauses.The addition of neighborhood resolution (namely, Max-DPLL-2) improves its performance by 2 orders of magnitudeand allows to solve instances with up to 300 clauses. The further addition of chain resolution provides a spectacularimprovement which allows to solve instances with up to 750 clauses. Finally, the addition of cycle resolution allowsto solve in 100 seconds instances of up to 1000 clauses. The same improvements are observed on random Max-3-SATinstances (Fig. 12 top-right).The Max-Clique problem is the problem of finding a clique of maximum size embedded in a given graph. It isknown that solving the maximum clique problem of a graph G = (V , E) is equivalent to solving the minimum vertexcovering problem of graph G(cid:15) = (V , E(cid:15)) where E(cid:15) is the complementary of E (namely, (u, v) ∈ E(cid:15) if and only if(u, v) /∈ E). Therefore, we solved Max-Clique instances by encoding into Max-SAT the corresponding minimumvertex covering problem, as described in Example 5 in Section 3.A random graph is defined by two parameters (cid:18)n, e(cid:19) where n is the number of nodes and e is the number of edges.Edges are randomly chosen using a uniform probability distribution. Fig. 12 (bottom) reports the results of solvingthe Max-Clique problem of random graphs with 150 nodes and varying number of edges. It can be observed that theinstances with connectivity lower than 50 percent are trivially solved by the four algorithms. Note that instances withsmall connectivity have an associated Max-SAT encoding containing a large number of hard clauses. Hence, the unitclause reduction rule is applied very frequently on those instances. This is the reason why they are so easily solved.However, as the connectivity increases, the differences between all the versions also increases. We noticed a slightimprovement for Max-DPLL-2 over Max-DPLL-1. For connectivities between 76% and 99% the greatest differences1 http://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/ToolBarIntro.2 ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/contributed/UCSC/instances.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233223Fig. 12. Experimental results of different algorithms on random Max-k-SAT and Max-Clique instances.are found. While Max-DPLL-1 and Max-DPLL-2 are unable to solve those instances, both Max-DPLL-3 and Max-DPLL-4 perform well. With a connectivity near to 90%, it can be observed that using the cycle resolution reports anoticeable improvement.From these experiments we conclude that the synergy of the three inference rules of Max-DPLL-4 produces anefficient algorithm.7.2. Max-DPLL versus alternative solversIn the following experiments, we evaluate the performance of Max-DPLL-4 (we will refer to it as MAX-DPLL).For that purpose, we compare MAX-DPLL with the following state-of-the-art Max-SAT solvers: MAXSOLVER (Sep-tember 2004 second release) [13], LAZY (version 2.0) [14], UP (version 1.5) [33], LB4A [12] and MAXSATZ (July2006 release) [34]. They suffer from the following limitations:• The available version of MAXSOLVER is restricted to instances with less than 200 variables and 1000 clauses.• For implementation reasons, UP and MAXSATZ cannot deal with instances having clauses with high weights.Therefore, they cannot deal with instances that combine mandatory and weighted clauses.• LB4A can only solve unweighted Max-2-SAT problems (i.e., it is restricted to binary clauses with unit weightsand without repeated clauses).Consequently, in the experiments, we will only execute a solver if it is possible, according to its limitations.It is known that Max-SAT problems can also be solved with pseudo-Boolean and SAT solvers. For the sake of amore comprehensive comparison, we also consider PUEBLO (version 1.4) [35] and MINISAT+ (2005 release) [36],which are among the best pseudo-Boolean and SAT solvers, respectively. In Appendix B, we describe how we trans-lated the Max-SAT instances into these two frameworks. Note that pseudo-Boolean formulas are equivalent to 0–1224J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Fig. 13. Random Max-2-SAT and Max-3-SAT. Max-2-SAT instances on the plot on the left do not contain repeated clauses.integer linear programs (ILP). Thus, they can also be solved with a state-of-the-art ILP solver such as CPLEX. Wehave not considered this alternative because [11] showed that it is generally ineffective for Max-SAT instances. Max-SAT problems can also be solved with WCSP solvers [11]. We have not consider this type of solver in our study,because the reference WCSP solver is MEDAC [32], which uses techniques similar to those of Max-DPLL and canbe roughly described as a non-Boolean restricted version of Max-DPLL-3.7.2.1. Random Max-k-SATFor the following experiment, we generated random 2-SAT instances of 60 variables and 3-SAT instances of 40variables with varying number of clauses using the Cnfgen generator. We also generated random 2-SAT instances of140 variables using the 2-SAT generator of [12] that does not allow repeated clauses.Fig. 13 (top-left) presents the results on Max-2-SAT without repeated clauses. It can be observed that MAX-DPLL and MAXSATZ are the only algorithms that can solve problems of up to 1000 clauses. MAXSATZ is roughly3 times faster than MAX-DPLL. A surprising observation is that the LB4A solver, which was specifically designedfor Max-2-SAT without repetitions, performs worse than the other Max-SAT solvers in random unweighted Max-2-SAT. Fig. 13 (top-right) presents the results on Max-2-SAT with repeated clauses. MAX-DPLL and MAXSATZ arethe best algorithms, with similar performance. The third best solver, UP, is nearly 100 times slower in the hardestinstances. Fig. 13 (bottom) presents the results on Max-3-SAT. MAXSATZ provides the best performance. The secondbest option MAX-DPLL requires twice as much time. The third best option LAZY is about 20 times slower thanMAXSATZ. An observation worth noting is that the alternative encodings (namely, pseudo-Boolean and SAT) do notseem to be effective in these random instances.We can conclude from this experiment that MAXSATZ is the best solver for this type of problems (random and un-weighted). The second best option is MAX-DPLL. We explain in Section 8 that MAXSATZ can be roughly describedas UP enhanced with inference rules similar to those used by MAX-DPLL. Therefore, the importance of inferencerules based on weighted resolution is corroborated.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233225Fig. 14. Random Max-One instances.7.2.2. Max-OneGiven a satisfiable CNF formula, Max-One is the problem of finding a model with a maximum number of variablesset to true. This problem can be encoded as Max-SAT by considering the clauses in the original formula as mandatoryand adding a weighted unary clause (xi, 1) for each variable in the formula. Note that solving this problem is muchharder than solving the usual SAT problem, because the search cannot stop as soon as a model is found. The optimalmodel must be found and its optimality must be proved.Fig. 14 shows the results with random 3-SAT instances of 150 variables. Note that MAXSATZ cannot be executedin this benchmark because it cannot deal with mandatory clauses. The first thing to be observed is that LAZY andMINISAT do not perform well. Regarding the other solvers, PUEBLO is the best when the number of clauses is verysmall, but its relative efficiency decreases as the number of clauses grows. MAXSOLVER has the opposite behavior,and MAX-DPLL always lay in the middle. The performance of all these solvers converges as the number of clausesapproaches the phase transition peak. The reason is that, as the number of models decreases, the optimization part ofthe Max-One problem loses relevance (the number of models to chose from decreases).Fig. 15 reports results on the Max-One problem on selected satisfiable SAT instances from the DIMACS chal-lenge [37].3 The first column indicates the name of the problem classes. The second column indicates the number ofinstances of each class. The other columns indicate the performance of each solver by indicating the number of in-stances that could be solved within the time limit. If all the instances could be solved, the number in parenthesis is themean time in seconds. The “–” symbol in the MAXSOLVER column indicates that the instances could not be executeddue to the limitation that this solver has on the maximum number of variables and clauses. As can be observed, MAX-SOLVER and LAZY do not succeed in this benchmark, which means that MAX-DPLL is the only Max-SAT solverthat can deal with it. Its performance is comparable to the good performance of MINISAT and PUEBLO. However, inthe par16*c* instances MAX-DPLL performs badly, while in the par8* instances it performs better than the others.7.2.3. Max-CutGiven a graph G = (V , E), a cut is defined by a subset of vertices U ⊆ V . The size of a cut is the number of edges(vi, vj ) such that vi ∈ U and vj ∈ V − U . The Max-Cut problem consists in finding a cut of maximum size. It isencoded as Max-SAT associating one variable xi to each graph vertex. Value t (respectively, f) indicates that vertexvi belongs to U (respectively, to V − U ). For each edge (vi, vj ), there are two clauses xi ∨ xj and ¯xi ∨ ¯xj . Givena complete assignment, the number of falsified clauses is |E| − S where S is the size of the cut associated to theassignment. Note that this encoding produces an unweighted Max-2-SAT formula, so the LB4A solver can be used.3 ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/benchmarks/cnf.226J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Problem∗aim50∗aim100∗aim200∗jnh∗ii8∗ii32∗par8∗par16c∗n. inst. MaxDPLL MaxSolverLazyMiniSatPueblo16161616141710516(0.59)16(2.67)916(1.49)51110(0.92)5(784.14)16(0.12)16(4.92)4–––––16(28.25)006105016(0.01)16(0.02)16(0.03)16(0.08)101610(16.39)5(0.93)16(0.00)16(0.00)16(0.00)16(0.10)31510(26.52)5(0.93)Fig. 15. Results for the Max-One problem on selected DIMACS SAT instances.Fig. 16. Random Max-Cut instances.Random Max-Cut instances are extracted from random graphs (see Section 7.1 for their generation). We consideredgraphs of 60 nodes and varying number of edges.Fig. 16 reports the results on this benchmark. It can be observed that for all the solvers except for MAXSATZ andMAX-DPLL, problems become harder as the number of edges increases. However, MAXSATZ and MAX-DPLL solveinstances of up to 500 edges almost instantly. The third best solver is LB4A, but MAXSATZ is up to 30 times faster.PUEBLO and MINISAT perform so poorly even in the easiest instances that they are not included in the comparison.7.2.4. Max-CliqueThe Max-Clique problem is the problem of finding a clique of maximum size embedded in a given graph. Its Max-SAT encoding was described in Section 7.1. MAXSATZ, UP, MAXSOLVER and LB4A solvers could not be executedin this domain due to their limitations. Our first Max-Clique experiment used random graphs with 150 nodes andvarying number of edges. Fig. 17 reports the results. Again, MAX-DPLL is clearly better than any other competitor.All other competitors are more than 2 orders of magnitude slower than MAX-DPLL.We also considered the 66 Max-Clique instances from the DIMACS challenge [37].4 MAXSOLVER could not beexecuted in this benchmark because the number of variables and clauses of the instances exceed its capacity. Thus,the only two Max-SAT solvers that could be executed are MAX-DPLL and LAZY. Within the time limit, they solved32 and 23 instances, respectively. MINISAT and PUEBLO could solve 22 and 16 instances, respectively. Therefore,MAX-DPLL provided the best performance in this benchmark, too.4 ftp://dimacs.rutgers.edu/pub/challenge/graph/benchmarks/clique.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233227Fig. 17. Random Max-Clique instances.Problem1bpi–1knt1bpi–2knt1bpi–5pti1knt–1bpi1knt–2knt1knt–5pti1vii–1cph2knt–5pti3ebx–1era3ebx–6ebx6ebx–1era|V |2,2792,4363,0162,4941,8062,2361712,1842,5481,7681,666|C|Opt MaxDPLLLazy MiniSat2,213,0512,521,6193,851,4412,649,1731,391,2002,122,35713,1252,021,7052,769,7061,338,0351,189,5373129423039286283128203,8546,891–6,6019044,7490.273,9119,3321,6361,428––––12,379–0.32––16,58114,65125,30311,50224,60719,3105,71031,5350.4610,23952,43419,48219,367[4]19182301100460952366101Fig. 18. Protein structure alignment problem transformed into Max-Clique.These instances have been previously used to evaluate several dedicated maximum clique algorithms. Performinga proper comparison with MAX-DPLL is difficult because their codes are not available and we would need to re-program their algorithms. However, following the approach of [38], we overcome this problem by normalizing thereported times. Of course, this is a very simplistic approach which disregards very relevant parameters such as theamount of memory or the processor model. In consequence, the following results can only be taken as indicativeinformation. Giving a time limit of 2.5 hours per instance on a 3.2 GHz computer, MAX-DPLL was able to solve37 instances. In an equivalent (via normalization) time, [39] solves 38, [40] solves 36, [41] solves 45, and [38]solves 52.Finally, we considered 11 Max-Clique real instances, provided by J.S. Sokol, corresponding to the protein structurealignment problem transformed into the maximum clique problem as described in [4] (instances are taken before thepreprocessing described in the paper). In this problem, the goal is to compute a score of similarity between two proteinsbased on a particular knowledge of their respective three-dimensional structure. Due to the size of the instances andthe presence of mandatory and weighted clauses, only three solvers could be executed, MAX-DPLL, LAZY andMINISAT. The results are shown in Fig. 18 which gives the instance name as used in [4], the number of Booleanvariables, the number of clauses, the maximum clique size, the CPU time (in seconds, with a time limit of 10 hours)of MAX-DPLL (run on a 3 GHz Intel Xeon 64-bit with 16 GB), of LAZY and MINISAT (run on a 3 GHz Intel Xeonwith 4 GB), and of the specialized algorithm introduced in [4] (run on a 200 MHz SGI):228J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Fig. 19. Combinatorial auctions. Top-left: Paths distribution. Top-right: Regions distribution. Bottom: Scheduling distribution.LAZY and MINISAT require less memory than MAX-DPLL which could not solve 1bpi–5pti for memory reasons.LAZY could solve 4 instances only in less than 10 hours. Although MINISAT solves all the instances, it is approxi-mately 5 times slower than MAX-DPLL on 10 instances. The dedicated algorithm [4] solves all the instances severalorders of magnitude faster than MAX-DPLL, showing the gap between generic and specialized algorithms.7.2.5. Combinatorial auctionsCombinatorial auction allows bidders to bid for indivisible subsets of goods. Consider a set G of goods and n bids.Bid i is defined by the subset of requested goods Gi ⊆ G and the amount of money offered. The bid-taker, who wantsto maximize its revenue, must decide which bids are to be accepted. Note that if two bids request the same good, theycannot be jointly accepted [7]. In its Max-SAT encoding, there is one variable xi associated to each bid. There areunit clauses (xi, ui) indicating that if bid i is not accepted there is a loss of profit ui . Besides, for each pair i, j ofconflicting bids, we add a mandatory clause ( ¯xi ∨ ¯xj , (cid:13)).We used the CATS generator [42] that allows to generate random instances inspired from real-world scenarios. Inparticular, we generated instances from the Regions, Paths and Scheduling distributions. The number of goods wasfixed to 60 and we varied the number of bids. By increasing the number of bids, instances become more constrained(namely, there are more conflicting pairs of bids) and harder to solve. MAXSATZ, UP, MAXSOLVER and LB4A couldnot be executed due to their limitations. The LAZY solver could not be included in the Regions comparison due tooverflow problems.Fig. 19 (top-left) presents the results for the Paths distribution. MAX-DPLL produces the best results being 22times faster than the second best option LAZY. Fig. 19 (top-right) presents the results for the Regions distribution.MAX-DPLL is again the best algorithm. It is 26 times faster than the second best solver PUEBLO. Finally, results forthe Scheduling distribution are shown in Fig. 19 (bottom). In this benchmark, the performance of MAX-DPLL andMINISAT are quite similar, while the other solvers are up to 4 times slower.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–2332298. Related work8.1. Relation with weighted constraint satisfaction problemsA weighted constraint satisfaction problem (WCSP) [43] is similar to a Max-SAT instance except that: variablesare multi-valued rather than bi-valued, and costs are given by arbitrary cost functions, rather than by clauses. It isknown that a WCSP can be translated into a Max-SAT instance and vice-versa [11].Some of the ideas presented in this paper have strong connections to different techniques recently developed in theWCSP field. In the following we summarize these connections. The idea of adding a lower bound ((cid:2), w) and an upperbound (cid:13) to the problem formulation has been borrowed from [44]. The concept of equivalence-preserving problemtransformation by moving costs comes from [26]. DP and Max-DP can be seen as instantiations of bucket elimination[45], a meta-algorithm based on the variable elimination principle, which is well-known in the WCSP context [46,47].Neighborhood resolution is related to the notion of projection and has been used to enforce node and arc-consistency[26,48]. The application of Chain resolution with k = 2 is similar to the enforcement of existential arc consistency[32]. Cycle resolution with k = 3 is related to one particular case of the so-called high-order consistencies proposedin [49]. More precisely, it is a weighted version restricted to Boolean variables of path inverse consistency [50].8.2. Relation with other Max-SAT solversIn the last years several algorithms for Max-SAT have been proposed [11–15,30,33,51]. Most of them have incommon a basic branch and bound structure and mainly differ in the lower bound that they use. When the lower bounddoes not reach the upper bound, search continues below the current node and new lower bounds must be computed.The problem with all these lower bound computation methods is that they do not transform the formula and makethe lower bound explicit as part of the problem. Consequently, the lower bound needs to be computed from scratch ateach visited node and the same inconsistencies may be discovered again and again. In our approach the lower boundis computed as part of a simplification process and becomes part of the current problem. When the lower bound doesnot reach the upper bound, the simplified formula is passed to descendant nodes, so they actually inherit the lowerbound. Interestingly, Li et al. have also detected this common pitfall. In their last work [34], done independently andin parallel to ours, they introduce a Max-SAT solver with many similarities to our Max-DPLL. The main contributionof their paper are 6 Max-SAT simplification rules (called Rules 1–6). They conclude, as we do in this paper, thatthere is a small set of simplification rules that seems to be essential for the efficiency of a Max-SAT solver. Besides,their set of fundamental simplification rules is very similar to ours. Their solver, called MAXSATZ, is build on top oftheir previous solver [33,51]. The novelty of MAXSATZ is that it incorporates neighborhood resolution restricted tounary and binary clauses (Rules 1 and 2 using their terminology), chain resolution (Rules 3 and 4), a special case ofcycle resolution restricted to triplets of variables in which an immediate lower bound increment is guaranteed (Rule 5)and, finally, a sequence of chain resolution followed by cycle resolution in which, again, a lower bound increment isguaranteed (Rule 6). Besides, MAXSATZ identifies that a certain variable must necessarily take one of its two truthvalues exactly as our hardening rule does.A significant difference between MAXSATZ and Max-DPLL is the type of Max-SAT instances that are assumedto be solved. MAXSATZ assumes unweighted clauses or weighted clauses with low weights. As a consequence, Max-SAT instances are represented as multisets of clauses where w repetitions of clause C is equivalent to (C, w) in ournotation. The main advantage of this simplification is that it can inherit from the modern SAT solver SATz [52] theefficient data structures as well as the efficient implementation of propagation procedures. This may explain whyMAXSATZ seems to be better than Max-DPLL on unweighted instances. The main disadvantage of this assumptionis that MAXSATZ cannot be applied to instances having mandatory clauses or clauses with high weights. As shown inSection 7, this limits severely its scope of applicability.9. Conclusion and future workThis paper introduces a novel Max-SAT framework which highlights the relationship between SAT and Max-SATsolving techniques. Most remarkably, it extends the concept of resolution. Our resolution rule, first proposed in [1],has been proved complete in [27]. There are many beneficial consequences of this approach:230J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233• It allows to talk about Max-SAT solving with the usual SAT terminology.• It allows to naturally extend basic algorithms such as DPLL and DP.• It allows to express several solving techniques that are spread around the Max-SAT literature with a commonformalism, see their logical interpretation and see the connection with similar SAT, CSP and WCSP techniques.From a practical point of view, we have proposed a hybrid algorithm that combines search and some restrictedforms of inference. It follows a typical search strategy but, at each visited node, it attempts to simplify the currentsubproblem using special cases of resolution with which the problem is transformed into a simpler, equivalent one. Ourexperiments on a variety of domains show that our algorithm can be orders of magnitude faster than its competitors.Our current solver lacks features that are considered very relevant in the SAT context (for example, clause learning,re-starts, etc.). Since our framework makes the connection between SAT and Max-SAT very obvious, these featuresshould be easily incorporated in the future. Additionally, some of the ideas presented in this paper have been bor-rowed from the weighted CSP field [43]. Therefore, it seems also possible to incorporate new (weighted) constraintprocessing techniques.Finally, we want to note the recent work of [33] and [51] in which very good lower bounds are obtained bytemporarily setting (cid:13) = 1 and simulating unit propagation. Since the hyper-resolution rules presented in Section 5.2are special cases of their more general algorithm, we want to explore if their approach can be fully described with ourresolution rule.Appendix A. Correctness and complexity of Max-VarElimIn this appendix we prove Lemmas 19 and 21, which establish the correctness of the Max-VarElim function inFig. 5 and its time and space complexity. In the proofs we borrow some ideas from [18,21,27] and adapt them to ourframework.In the following, when we write C ∈ F we mean (C, u) ∈ F for some weight u (there is no ambiguity becauseF (cid:15) to denote the application of a resolution step to formula Fall clauses in F are different). We use symbol F (cid:20)xiresulting in formula F (cid:15), where the clashing variable was xi . Consider the elimination of variable xi with FunctionMax-VarElim. First of all, the formula is partitioned into two sets of clauses, B and F . Then, clauses of the form(xi ∨ A, u) are fetched from B, resolved with clashing clauses until quiescence or disappearance and, finally, arediscarded. Suppose that discarded clauses are stored in a set D. Formally, we can see the execution of Max-VarElimas a sequence of resolution steps,B1 ∪ F1 ∪ D1 (cid:20)xiBo ∪ Fo ∪ Do (cid:20)xiBq ∪ Fq ∪ Dq ,where Do = ∅. For all 0 (cid:3) k (cid:3) q: Bk is a set of clauses that contain either xi or ¯xi , Fk is a set of clauses that do notcontain xi neither ¯xi , and Dk is a set of clauses that contain xi . Besides, Bq does not have any clause with xi . Theoutput of Max-VarElim is Fq that, as we will prove, is essentially equivalent to the original formula. Let Ni denotethe set of variables sharing clauses with xi in the starting B (namely, Bo),· · · (cid:20)xiNi =(cid:4)(cid:3)xj (cid:5)= xi | ∃C∈Bo xj ∈ var(C)and let ni = |Ni| be its cardinality. In the remaining of this appendix we will show that: the number of new clausesgenerated during the sequence of resolution steps is bounded by O(3ni ) (space complexity), the number of resolutionsteps is bounded by O(9ni ) (time complexity) and, from an optimal model of Fq we can trivially generate an optimalmodel of the original formula Bo ∪ Fo (correctness).Observe that all the variables different from xi appearing in clauses generated by the resolution process mustbelong to Ni because resolution does not add new variables. Therefore, all the clauses in Bk have the form l ∨ Awhere var(l) = xi and var(A) ⊆ Ni . Variable xi must appear in the clause either as a positive or negative literal(namely, there are 2 options) and every xj ∈ Ni may or may not appear in A and, if it appears, it can be in positive ornegative form (namely, there are 3 options). Consequently, the size of Bk is bounded by 2 × 3ni . For similar reasons,every clause C added to F during the resolution process satisfies that var(C) ⊆ Ni . Every xj ∈ Ni may or may notappear in C and, if it appears, it may be positive or negative (namely, there are 3 options). Consequently, the number ofnon-original clauses in Fk is bounded by 3ni . Therefore, the number of clauses added to B and F during the executionof Max-VarElim is bounded by 2 × 3ni + 3ni . As a result, its space complexity is O(3ni ).J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233231Next, we analyze the time complexity. Recall that two clauses (xi ∨ A, u), ( ¯xi ∨ B, w) ∈ F clash if A ∨ B: is not¯l /∈ B) and, A ∨ B ∈ F is not absorbed (that is, ∀(C,(cid:13))∈F C (cid:5)⊆ A ∨ B). We say that a clausea tautology (that is, ∀l∈A(xi ∨ A, u) is saturated if there is no clause in F clashing with it. The following lemma shows that resolving on aclause, either removes the clause from the formula or reduces the number of clauses clashing with it,Lemma 33. Consider a resolution step P (cid:20)xieither xi ∨ A /∈ P (cid:15) or the number of clauses clashing with xi ∨ A decreases.P (cid:15) where (xi ∨ A, u) and ( ¯xi ∨ B, w) are the clashing clauses. Then,Proof. We reason by cases:(1) If u < w or u = w < (cid:13) then the posterior xi ∨ A has weight 0 (namely, disappears from the formula).(2) If u = w = (cid:13) then the effect of resolution is to add the resolvent to the formula (P (cid:15) = P ∪ (A ∨ B, (cid:13))). Then,¯xi ∨ B does not clash with xi ∨ A anymore.(3) If u > w then ¯xi ∨ B is replaced by ¯xi ∨ B ∨ ¯A in the formula. The new clause does not clash with xi ∨ A, becauseA ∨ B ∨ ¯A is a tautology. (cid:2)Consider the inner loop of Max-VarElim. It selects a clause xi ∨ A and resolves it until either it disappears orit saturates. If xi ∨ A saturates, it is removed from B and added to D. We call this sequence of resolution steps theprocessing of xi ∨ A and use symbol (cid:20)∗xi ∨A to represent it. A consequence of the previous lemma is that the number ofresolution steps required to process xi ∨ A is bounded by the number of clauses clashing with it. Note that the numberof clauses clashing with (xi ∨ A, u) is bounded by 3ni , because clashing clauses must belong to B and variable ximust occur negated. Therefore, for each iteration of the outer loop, the inner loop of Max-VarElim iterates at most3ni times.Consider now the outer loop of Max-VarElim. It selects a sequence of clauses xi ∨ A1, xi ∨ A2, . . . , xi ∨ As andprocesses them one after another. We can see this process as,Bk1Bo ∪ Fo ∪ Do (cid:20)∗∪ Dk1∪ Fk1· · · (cid:20)∗(cid:20)∗Bks∪ Fks∪ Dks .xi ∨A1xi ∨A2xi ∨AsRecall that the algorithm always selects for processing a clause xi ∨ Aj of minimal size (line 4). Observe that thesize of the compensation clause xi ∨ A ∨ ¯B added to B (line 9) is larger than the clause that is being processed. Asa consequence, once a clause is processed, it does not appear again in B, which means that ∀1(cid:2)j <j (cid:15)(cid:2)sAj (cid:5)= Aj (cid:15) .A direct consequence is that, since there are at most 3ni distinct Aj , the outer loop iterates at most 3ni . Therefore,the maximum number of iterations of the inner loop is 3ni × 3ni = 9ni , which means that the time complexity of thefunction is O(9ni ).Finally, we prove the correctness of Max-VarElim.Lemma 34. A saturated clause remains saturated during any sequence of resolution steps (cid:20)xi .F (cid:15). Let xi ∨ A and ¯xi ∨ B be the clashing clauses, and let xi ∨ C be a saturatedProof. Consider a resolution step F (cid:20)xiclause of F . We only need to prove that xi ∨ C remains saturated in F (cid:15). Since, xi ∨ C is saturated in F , either C ∨ Bis a tautology or it is absorbed in F . The only new clause in F (cid:15) that could clash with xi ∨ C is ¯xi ∨ B ∨ ¯A. However,if C ∨ B was a tautology, so it is C ∨ B ∨ ¯A. If C ∨ B was absorbed in F , so it will C ∨ B ∨ ¯A in F (cid:15). (cid:2)A consequence of the previous lemma is that at the end of the sequence of resolution steps performed by Max-VarElim we have a formula Bks∪ Fks∪ Dks such that all its clauses are saturated.To prove the correctness of Max-VarElim we only need to prove that any assignment I of Fks can be extendedto variable xi in a cost free-manner, taking into account the clauses ¯xi ∨ B ∈ Bks and the clauses xi ∨ A ∈ Dks , becauseit means that finding the optimal assignment of Fks is equivalent to finding the optimal assignment of Bks∪ Dkswhich, in turn is equivalent to finding the optimal assignment of the original formula.∪ FksIf Bks= ∅ (resp. Dks= ∅), variable xi must be set to true (resp. false). Else, consider that there is a clausexi ∨ A ∈ Dks such that I does not satisfy A (similarly for ¯xi ∨ B ∈ Bks ). Variable xi must be set to true. We show thatI satisfies every ¯xi ∨ B ∈ Bks : Clause xi ∨ A is saturated, then either A ∨ B is a tautology or there is a clause C ∈ Fkswith C ⊆ A ∪ B. In the first case, since I does not satisfy A, and since A ∨ B is a tautology, this means that I satisfiesB. In the second case, since I satisfies C and does not satisfy A, it must satisfy B.232J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233Appendix B. Solving Max-SAT with pseudo-Boolean and SAT solversIn linear pseudo-Boolean (LPB) problems over Boolean variables {x1, . . . , xn}, values true and false are replacedby numbers 1 and 0, respectively. Literal li represents either xi or its negation 1 − xi . A LPB problem is defined by aLPB objective function (to be minimized),n(cid:17)i=1aili, where ai ∈ Zand a set of LPB constraints,n(cid:17)i=1aij li (cid:2) bj , where aij , bj , ∈ Z, xi ∈ {0, 1}.A Max-SAT formula can be encoded as a LPB problem [11] by partitioning the set of clauses into three sets: Hcontains the mandatory clauses (C, (cid:13)), W contains the non-unary non-mandatory clauses (C, u < (cid:13)) and U containsthe unary non-mandatory clauses (l, u). For each hard clause (Cj , (cid:13)) ∈ H there is a LPB constraint C(cid:15)(cid:2) 1, wherejC(cid:15)j is obtained from Cj by replacing ∨ by + and negated variables ¯x by 1 − x. For each non-unary weighted clause(Cj , uj ) ∈ W there is a LPB constraint C(cid:15)j is computed as before, and rj is a new variable that,jwhen set to 1, trivially satisfies the constraint. Finally, the objective function is,+ rj (cid:2) 1, where C(cid:15)(cid:17)(cid:17)uj rj +uj lj (cid:3) (cid:13).(Cj ,uj )∈W(lj ,uj )∈UA LPB problem can be solved with a native LPB solver such as PUEBLO or with a SAT solver. In the latter case,each LPB constraint must be converted into a logic circuit. There are different possible conversions such as BDDs,adders or sorters. In our experiments we used MINISAT+ [53], a translating tool that converts each LPB constraintinto the presumably more convenient circuit and solves the corresponding SAT formula with MINISAT. MINISAT+converts the objective function of the LPB problem into another LPB constraint by setting an upper bound. The LPBproblem is solved by decreasing the value of the upper bound until an infeasible SAT formula is found.References[1] J. Larrosa, F. Heras, Resolution in Max-SAT and its relation to local consistency for weighted CSPs, in: Proc. of the 19th IJCAI, Edinburgh,UK, 2005, pp. 193–198.[2] J. Larrosa, F. Heras, New Inference Rules for Efficient Max-SAT Solving, in: Proc. of AAAI-06, Boston, MA, 2006.[3] H. Xu, R. Rutenbar, K. Sakallah, sub-SAT: A formulation for relaxed boolean satisfiability with applications in routing, in: Proc. Int. Symp.on Physical Design, San Diego CA, 2002, pp. 182–187.[4] D. Strickland, E. Barnes, J. Sokol, Optimal protein structure alignment using maximum cliques, Operations Research 53 (3) (2005) 389–402.[5] M. Vasquez, J. Hao, A logic-constrained knapsack formulation and a tabu algorithm for the daily photograph scheduling of an earth observationsatellite, Journal of Computational Optimization and Applications 20 (2) (2001) 137–157.[6] J.D. Park, Using weighted MAX-SAT engines to solve MPE, in: Proc. of AAAI-02, Edmonton, Alberta, Canada, 2002, pp. 682–687.[7] T. Sandholm, An algorithm for optimal winner determination in combinatorial auctions, in: Proc. of the 16th IJCAI, 1999, pp. 542–547.[8] N. Bansal, V. Raman, Upper Bounds for MaxSat: Further improved, in: ISAAC, 1999, pp. 247–258.[9] R. Niedermeier, P. Rossmanith, New upper bounds for maximum satisfiability, J. Algorithms 36 (1) (2000) 63–88.[10] J. Chen, I. Kanj, Improved exact algorithms for Max-SAT, in: Proc. of the 5th Latin American Symposium on Theoretical Informatics, 2002,pp. 341–355.[11] S. de Givry, J. Larrosa, P. Meseguer, T. Schiex, Solving Max-SAT as weighted CSP, in: Proc. of CP-03, Cork, Ireland, 2003, pp. 363–376.[12] H. Shen, H. Zhang, Study of lower bounds for Max-2-SAT, in: Proc. of AAAI-04, San Jose, CA, 2004, pp. 185–190.[13] Z. Xing, W. Zhang, MaxSolver: An efficient exact algorithm for (weighted) maximum satisfiability, Artificial Intelligence 164 (1–2) (2005)47–80.[14] T. Alsinet, F. Manya, J. Planes, Improved exact solver for weighted Max-SAT, in: Proc. of SAT-05, St Andrews, Scotland, 2005, pp. 371–377.[15] R. Nieuwenhuis, A. Oliveras, On SAT modulo theories and optimization problems, in: Proc. of SAT-06, Seattle, WA, 2006, pp. 156–169.[16] U. Bertele, F. Brioschi, Nonserial Dynamic Programming, Academic Press, New York, 1972.[17] R. Dechter, Constraint Processing, Morgan Kaufmann, San Francisco, CA, 2003.[18] I. Rish, R. Dechter, Resolution vs. inference: Two approaches to SAT, Journal of Automated Reasoning 24 (1) (2000) 225–275.[19] S. Arnborg, Efficient algorithms for combinatorial problems on graphs with bounded decomposability—a survey, BIT 25 (1985) 2–23.[20] M. Davis, G. Logemann, G. Loveland, A machine program for theorem proving, Communications of the ACM 5 (1962) 394–397.J. Larrosa et al. / Artificial Intelligence 172 (2008) 204–233233[21] M. Davis, H. Putnam, A computing procedure for quantification theory, Journal of the ACM 3 (1960).[22] A.V. Gelder, Satisfiability testing with more reasoning and less guessing, in: Cliques, Coloring, and Satisfiability: Second DIMACS Imple-mentation Challenge, American Mathematical Society, Providence, RI, 1995, pp. 0–1.[23] F. Bacchus, Enhancing Davis Putnam with extended binary clause reasoning, in: Proc. of AAAI-02, Edmonton, Alberta, Canada, 2002,pp. 613–619.[24] L. Drake, A. Frisch, T. Walsh, Adding resolution to the DPLL procedure for Boolean satisfiability, in: Proc. of SAT-02, Cincinnati, OH, 2002,pp. 122–129.[25] C. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, 1994.[26] T. Schiex, Arc Consistency for soft constraints, in: Proc. of CP-00, Singapore, 2000, pp. 411–424.[27] M. Bonet, J. Levy, F. Manya, A complete calculus for Max-SAT, in: Proc. of SAT-06, Seattle, WA, 2006, pp. 240–251.[28] B. Cha, K. Iwama, Adding new clauses for faster local search, in: Proc. of AAAI-96, Portland, OR, 1996, pp. 332–337.[29] R. Wallace, E. Freuder, Comparative studies of constraint satisfaction and Davis–Putnam algorithms for Max-SAT problems, in: Cliques,Coloring and Satisfiability, 1996, pp. 587–615.[30] T. Alsinet, F. Manya, J. Planes, Improved branch and bound algorithms for Max-SAT, in: Proc. of SAT-03, Portofino, Italy, 2003, pp. 408–415.[31] C. Bessière, Arc-consistency and arc-consistency again, Artificial Intelligence 65 (1) (1994) 179–190.[32] S. de Givry, F. Heras, J. Larrosa, M. Zytnicki, Existential arc consistency: getting closer to full arc consistency in weighted CSPs, in: Proc. ofthe 19th IJCAI, Edinburgh, UK, 2005, pp. 84–89.[33] C.M. Li, F. Manya, J. Planes, Exploiting unit propagation to compute lower bounds in branch and bound Max-SAT solvers, in: Proc. of CP-05,Sitges, Spain, 2005, pp. 403–414.[34] C.-M. Li, F. Manyà, J. Planes, New inference rules for Max-SAT, Journal of Artificial Intelligence Research, in press.[35] H.M. Sheini, K.A. Sakallah, Pueblo: A hybrid pseudo-Boolean SAT solver, Journal on Satisfiability, Boolean Modeling and Computation 2(2006) 165–189.[36] N. Eén, N. Sörensson, An Extensible SAT-solver, in: Proc. of SAT-03, Portofino, Italy, 2003, pp. 502–518.[37] D.S. Johnson, M. Trick, Cliques, Coloring, and Satisfiability: Second DIMACS Implementation Challenge, DIMACS Series in DiscreteMathematics and Theoretical Computer Science, vol. 26, AMS, 1993.[38] J.-C. Régin, Using constraint programming to solve the maximum clique problem, in: Proc. of CP-03, Cork, Ireland, 2003, pp. 634–648.[39] D. Wood, An algorithm for finding maximum cliques in a graph, Operations Research Letters 21 (1997) 211–217.[40] P.R.J. Ostergard, A fast algorithm for the maximum clique problem, Discrete Applied Mathematics 120 (2002) 197–207.[41] T. Fahle, Simple and fast: Improving a branch-and-bound algorithm for maximum clique, in: Proc. of ESA, 2002, pp. 485–498.[42] K. Leyton-Brown, M. Pearson, Y. Shoham, Towards a universal test suite for combinatorial auction algorithms, ACM E-Commerce (2000)66–76.[43] P. Meseguer, F. Rossi, T. Schiex, Soft constraints, in: F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Elsevier,Amsterdam, 2006 (Ch. 9).[44] J. Larrosa, T. Schiex, Solving weighted CSP by maintaining arc-consistency, Artificial Intelligence 159 (1–2) (2004) 1–26.[45] R. Dechter, Bucket elimination: A unifying framework for reasoning, Artificial Intelligence 113 (1–2) (1999) 41–85.[46] J. Larrosa, R. Dechter, Boosting search with variable elimination in constraint optimization and constraint satisfaction problems, Con-straints 8 (3) (2003) 303–326.[47] J. Larrosa, E. Morancho, D. Niso, On the practical applicability of Bucket Elimination: Still-life as a case study, Journal of Artificial Intelli-gence Research 23 (2005) 421–440.[48] J. Larrosa, Node and arc consistency in weighted CSP, in: Proc. of AAAI-02, Edmonton, Alberta, Canada, 2002, pp. 48–53.[49] M. Cooper, High-order consistency in valued constraint satisfaction, Constraints 10 (3) (2005) 283–305.[50] E. Freuder, C. Elfe, Neighborhood inverse consistency preprocessing, in: Proc. of AAAI-96, Portland, OR, 1996, pp. 202–208.[51] C.-M. Li, F. Manyà, J. Planes, Detecting disjoint inconsistent subformulas for computing lower bounds for Max-SAT, in: Proc. of AAAI-06,Boston, MA, 2006.[52] C.M. Li, Anbulagan, Heuristics based on unit propagation for satisfiability problems, in: Proc. of the 15th IJCAI, Nagoya, Japan, 1997,pp. 366–371.[53] N. Eén, N. Sörensson, Translating pseudo-Boolean constraints into SAT, Journal on Satisfiability, Boolean Modeling and Computation 2(2006) 1–26.