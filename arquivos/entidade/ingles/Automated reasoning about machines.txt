Artificial Intelligence 74 ( 1995) 1-53 Artificial Intelligence Automated reasoning about machines * Andrew Gelsey * Computer Science Department, Hill Center for the Mathematical Sciences, Rutgers University, New Brunswick, NJ 08903, USA Received June 1992; revised July 1993 Abstract simulation Numerical is often used in predicting machine behavior, a basic capability for many tasks such as design and fault diagnosis. However, using simulators requires considerable human effort both to create behavioral models and to analyze and understand simulation results. I describe algorithms which automate the kinematic and dynamical analysis needed to create behavioral models and which automate the intelligent control of computational simulations needed to understand a machine’s behavior over both short and long time scales. The input is a description of a machine’s geometry and material properties, and the output is a behavioral model for the machine and a concise qualitative/quantitative prediction of the machine’s long-term behavior. My algorithms have been implemented in a working program which can predict a machine’s behavior over both short and long time periods. At present this work is limited to mechanical devices, particularly clockwork mechanisms. 1. Introduction Predicting a machine’s behavior soning about machines, machines, predicting lation behavioral models on which and redesign of existing machines. Numerical the behavior of machines for many tasks requiring is a basic capability rea- such as diagnosis of malfunctioning machines, design of new in systems. However, using simu- human effort both to create the the and other physical requires considerable is based and to analyze and understand is often used the simulation simulation to predict machine behavior *This research was supported by National Science Foundation grants IRI-8610241 and IRI-8812790 and by the Defense Advanced Research Projects Agency and the National Aeronautics and Space Administration under NASA grant NAG2-645. * E-mail: gelsey@cs.rutgers.edu. 0004-3702/95/$09.50 @ 1995 Elsevier Science B.V. All rights reserved .SSDIOOO4-3702(94)00003-J A. C;elsey/Arr~ficm1 lnleliigence 74 (1995) l-53 b) Balance collides with lever @y=gf--~’ c) Escape wheel pushes lever and I balance d) Halfway through a full cycle Fig. I, Clock or watch escapement mechanism. to escape wheel are present in model but not shown in figures.) (Note: hairspring attached to balance and mainspring attached results of the simulation. Automating research in both spatial reasoning I describe this process requires basic artificial intelligence and reasoning about physical systems. The research l automated creation of behavioral models of machines directly in this article addresses two main problems: from models of their raw physical structure; l intelligent control of the computational experiments needed to reveal a machine’s long-term behavior. the algorithms Together, diction of a machine’s behavior over both short and long time periods. At present work is limited these problems allow the automated pre- this to mechanical devices, particularly clockwork mechanisms. for solving I present input All the algorithms in this article have been implemented in a working program. The is a description of the physical structure of a machine, which consists program’s primarily of a precise numerical specification of the machine’s geometry. From this input the program creates a behavioral model of the machine which it then uses to numerically the machine’s precise behavior when started from a number of intelligently simulate chosen description of the machine’s expected final output is a concise qualitative/quantitative initial conditions. The program’s long-term behavior. in Fig. 1 keeps the escape wheel, which I will present an example which gives an overview of the entire process. The escape- the average speed of a clock or watch constant by to advance is pushed clockwise by a strong spring, the motion of the to be by its attached spring. In Fig. 1 (b) the balance has hit the lever. then pushes the balance in spite of damping. Finally, ment mechanism allowing by only one escape wheel driven counterclockwise Impact both lever and balance as in Fig. 1 (c). This pushing loses to friction, so that it can act as a harmonic oscillator tooth for each oscillation of the balance. is blocked by the lever, and the balance to free the escape wheel, which the energy restores In Fig. 1 (a) is motionless the lever far enough force pushes and about A. Gebey/Artljkial Intelligence 74 (1995) l-53 3 in Fig. 1 (d), the escape wheel and lever are locked together again, and the balance has been brought temporarily to a halt by its spring. In this article, a behavioral model for a machine is considered to consist of two parts: l the identification of a set of stare variables: any particular state of the machine may be specified by assigning specific numerical values to each of the state variables; l a description of how the state variables change with time, usually by differential equations. The input to my program for the escapement example only specifies the shapes of the parts and their positions in space; this input does not indicate whether any of the parts are in contact or whether they impose any constraints on each other. Therefore, in order to identify a useful set of state variables, my program must use spatial reasoning to determine the kinematic properties of the escapement mechanism. The program identifies three kinematic pairs, pairs of parts which mutually constrain each other’s motion, by looking for pairs of parts having subparts with matching sym- metries in corresponding positions. For example, in the escapement, the balance has a hole in it which has rotational symmetry about a certain axis, and the frame has a shaft having rotational symmetry about the same axis. Algorithms 2 and 3 in Section 2.1.1 specify the conditions under which matching symmetries result in a kinematic pair. For the escapement, my program determines that each of the three moving parts forms a revolute pair with the frame and thus is constrained only to rotate about a fixed axis. The program then partitions the moving parts into kinematic subsystems each having a single degree of freedom, using algorithms from Section 2.1.3. In this mechanism, none of the three moving parts are connected to each other by kinematic pairs, so there are three kinematic subsystems, each consisting of a single moving part. As a result, the program concludes that a reasonable set of state variables for the escapement consists of six variables: one position variable and one velocity variable for each of the three kinematic subsystems. In order to generate the other half of the behavioral model for the escapement, the differential equations describing how the state variables change with time, the program must analyze the dynamics of the mechanism. My program can produce two separate behavioral models for a machine, based on distinctly different sets of approximations and simplifying assumptions. The user must choose between the two models: this article does not address model selection. However, the availability of at least two disparate models seems a necessary prerequisite for experimental investigation of how choices of approximations and simplifying assumptions influence the forms of behavioral models and the sorts of behavior the models predict. For the escapement mechanism, these models differ in their treatment of intermittent contacts between the moving parts, which are critical to the functioning of this mechanism. (Permanent contacts are handled with kinematic pairs, as described above.) The first model handles intermittent contacts between the moving parts of a mechanism by approximating the very small elastic distortions of the parts which give rise to contact forces. In the other model parts of the mechanism are treated as absolutely rigid bodies, and contact forces result from geometric constraints on the relative motions of parts in contact. Section 2.4 compares the two models. The other forces that must be modeled for the escapement mechanism are springs and friction, and my program uses simple linear models for both. 4 350 ; $ 300 k 250 ; 200 - 150 6 100 ;: 50 2 g 0 -50 A. Gelsey/Artificial Intelligence 74 (1995) 1-53 2 0 -2 -4 -6 -8 -10 -12 0 0 -20 -40 -60 -80 -100 -120 -140 -160 -200 -180 5 10 15 20 25 30 35 40 _a__ rime 0 0 5 10 15 20 25 30 35 40 time 1 5 10 15 20 25 30 35 40 .‘_.. L_ /IILcz balance lever escape wheel Fig. 2. Motion of escapement mechanism. The behavioral model generated by my program may be used to numerically simulate a the second dynamic model. The two models, using to do a good job of predicting machine’s behavior. Fig. 2 shows a plot of a simulation of the behavior of the escapement mechanism though quite different, that such a mechanism would both appear actually exhibit. to from this article. Both outputs are shown in [ 151.) My Fig. 2 and is therefore omitted are presented algorithms automated modeling (As a result, simulation output from the first model looks identical in Section 2. the behavior To the human eye, the data plot in Fig. 2 clearly shows the regularity of the mech- simulation data. is not explicit trace to make the be- is though Fig. 2 shows the regular behavior of the to decide how long this even a human would need to do further analysis clear, instructions. Also, the plot shows a sufficiently ran for that length of time in the numerical the only reason long behavior the simulation though a stream of simulation data to determine when it has become In Section 3 I present algorithms for continuously long enough to anism’s behavior, but this regularity Furthermore, havioral regularity because of explicit escapement, regular behavior would continue. processing show regularities, experiments for characterizing to determine the limits of validity of a hypothesized behavioral those regularities, and for doing controlled simulated regularity. results this process recognizes the most important qualitative For the escapement, havior which explicitly its repetitive nature, as well as the most important quantitative repetition of a behavior cycle has almost exactly can start with a description of the shapes of a clock’s parts and in effect conclude specification the mechanism meets a functional Although many mechanical device simulators in Section 4), in a concise description of its long-term be- feature of that behavior, the fact that each the same duration. Thus my program that are commercially information (see ref- the shape of a they are incapable of using for a clock. available feature, erences machine’s parts, so the users of these simulators about the following modeling inherit l for each pair of parts geometric constraint; in permanent contact, completely describe l for each pair of parts which may intermittently come in contact, supply a subroutine which for any positions of the two parts will determine whether or not they are in contact or interpenetrating. tasks are both done automatically These dressed aspects of these modeling a qualitative description of the machine’s expected by my program. Other researchers have ad- (see Section 4). The problem of extracting from numerical long-term behavior issues tasks: the resulting A. Gelsey/Art@cial Intelligence 74 (I 995) l-53 5 simulation described above (see Section 3). output has not been addressed for machines as complex as the escapement 2. Creating behavioral models My program creates a behavioral model of a machine directly from a representation systems used * is Solid Geometry [24,33], which each part in a machine structure of the system the shapes of mechanical Euclidean intersection, is widely used by CAD/CAM space which and difference to be modeled. The representation (CSG) in order to represent is represented is formed by applying of the physical Constructive solid modeling CSG representation, dimensional of union, a square plate with a hole in it might be represented cylinder, where the block would be appropriately plate, and the cylinder would have the correct diameter and position so that the difference operation would create supplemented with information constants, input data for the escapement mechanism. is the desired hole in the plate. This geometric such as masses, spring about other physical properties and coefficients of friction. Figs. 12 and 13 in Section 2.3 show the complete In the as a closed subset of three- set operations the Boolean solids. For example, as the difference of block and a the to a small set of primitive sized and positioned representation to represent devices. 2.1. Kinematics In order to identify a useful set of state variables, my program must determine the kinematic properties of a mechanism, which requires analysis geometry. Kinematic parts which mutually constrain [ 341, who classified kinematic pairs as either lower pairs or higher pairs. each other’s motion. The concept starts with the identification reasoning about the mechanism’s of kinematic pairs, pairs of is due to Reuleaux form a kinematic pair, there must be a set of points When two parts of a mechanism the two parts are in contact. limits is a two-dimensional the relative motion of the elements the prismatic pair, which allows only relative then the revolute pair, which where surface, include about a single axis; to an axis; and pairs are geometrically crankshaft/frame pair. Fig. 4 shows an example of a prismatic pair. The piston/frame cylindrical it isn’t allowed If this set of contact points the kinematic pair is classified as a lower pair. Examples of lower pairs to rotation parallel pair, which allows both motions. Only a few lower the rod pair in Fig. 3 is a it behaves as a prismatic pair since three examples of revolute pairs: rod pair, and the piston/connecting pair, the crankshaft/connecting in the complete mechanism possible. Fig. 3 shows the cylindrical pair, though translation to rotate. Higher pairs are kinematic pairs takes place along lines or points of contact rather than over a full surface. The most common higher pairs are gears. in which contact between the elements ’ I use the PADL-2 solid modeling system [ 201. 6 A. Gel.wy/Art~ciul Intelligence 74 (I 995) I-53 Frame Crankshaft Fig. 3. Crank mechanism. Fig. 4. Prismatic pair. 2.1. I. Identifying lower pairs The central concept used to identify lower pairs is symmetry. A three-dimensional like translation share a common from a two-dimensional If two parts form a lower pair they must if it can be generated or rotation. symmetry: (translational) in Fig. 3 the crankshaft shape has symmetry operation subparts which) for a prismatic pair, prismatic symmetries. For example, which symmetry. However, does not have rotational which are actually so the process of detecting subparts of every moving part of the mechanism. shape by a simple (have symmetry; pair, both forms a revolute pair with the frame, the two parts has rotational as a whole, to note that the crankshaft, considered and neither does the frame. The subparts of each though, of all the for a revolute pair, rotational for a cylindrical in contact with the other part must have rotational symmetry, lower pairs starts by listing all the symmetries it is important symmetry, if the area of contact between is only possible symmetry; The Constructive Solid Geometry representation to compute it easy systems) makes modeling subparts. CSG primitives have clearly defined symmetries. For example, of primitive including because cross-section are generally the cylinder is identical solids the list of the symmetries {widely used in CAD/CAM solid of a part’s like blocks and cylinders which regular solids the crankshaft several cylinders. Every cylinder has rotational in Fig. 3 is a combination symmetry to the volume swept out by rotating a two-dimensional of the cylinder about the cylinder’s axis of symmetry. Every cylinder also A. Gelsey/Arti&ial Intelligence 74 (1995) l-53 7 SYMMETRY type (rotational or prismatic) 1. symmetry 2. the axis of symmetry 3. the list of primitive solids in the part having the symmetry Fig. 5. The SYMMETRY data structure. AIgorithm 1. Find all symmetries of all subparts. For each PART For each primitive solid PRIM in PART For each symmetry SYM of PRIM If SYM is already on PART’s symmetry list then add PRZM to SYM’s list of primitive else add SYM to PARTS symmetry list solids has prismatic are identical. Some of the primitive have no rotational to three perpendicular axes. symmetry because all cross-sections perpendicular solids symmetry but have three different prismatic forming the crankshaft to its axis of symmetry are blocks, which symmetries with respect Algorithm Each subpart data structure in Fig. 3-three in the same SYMMETRY two rotational. The two rotational is represented 1 finds five SYMMETRY symmetry (Fig. 5). Algorithm prismatic, 1 generates a list of all the symmetries of all the subparts of every moving by an instance of the instances symme- rotations about distinct solids may instance: symmetry kinematic pair applies to two separate cylindrical part of the mechanism. SYMMETRY for the crankshaft tries have parallel axes but must be considered distinct because axes produce differing effects even if the axes are parallel. Several primitive participate the rotational about the axis of the crankshaft/frame subparts of the crankshaft. Though ferent rotational symmetry does not have a unique axis of symmetry-any also define the symmetry. Of course not all symmetries crankshaft, However, input which can then be filtered the cylinder subparts of the crankshaft have two dif- since prismatic to the axis can result in kinematic pairs: for the symmetries do not. as symmetries do but the three prismatic algorithms irrelevant expect all subpart symmetries symmetries. they all have the same prismatic the kinematic pair identification symmetry line parallel the two rotational for example symmetries, to remove The symmetry lists are used to find the lower kinematic pairs of the mechanism. The are represented by a list of KINEMATIC PAIR data the of lower pairs are identified by using Algorithm 2 to find the descriptions list of kinematic pairs, and then using Algorithm 5 to refine kinematic pairs of the mechanism structures initial the kinematic pairs on the list. (Fig. 6). The Algorithm 2 looks for pairs of parts having subparts with a common uses Algorithm 3 to determine whether forming a kinematic pair may consist of several primitive solids. For example, the subparts then form a kinematic pair. The subparts in Fig. 3, symmetry, 8 A. Gelsey/Artificiul lnfelligence 74 (1995) 1-53 KINEMATIC PAIR: 1. type of kinematic implementation) pair (revolute, prismatic, cylindrical, or gear, in the current the kinematic pair 2. the two parts forming 3. the axis of the kinematic pair (for lower pairs) 4. the gear ratio (for gear pairs) 5. a list of pairs of primitive 6. a list of CONSTRAINT data structures [ 151 solids making up the kinematic pair Fig. 6. The KINEMATIC PAIR data structure. Algorithm 2. Find the initial list of lower pairs. For each pair of parts PART1 and PART2 For each symmetry SYM shared by PART1 and PART2 For each primitive solid PRIM1 in PART1 having symmetry SYM For each primitive solid PRIM2 in PART2 having symmetry SYM Apply Algorithm 3 to PRIM1 and PRIM2. If they form a kinematic pair KP, then apply Algorithm 4. Algorithm 3. Check kinematic pair conditions. If PRIM1 and PRIM2 satisfy the following conditions: 1. They are the same type of primitive 2. One of them is solid and the other is hollow 3. Their dimensions intersection 4. Their solid are the same (except possibly along the axis of symmetry) solid of the same type is not empty and is also a primitive and dimensions then they form part of a kinematic pair KP solids solid of the same in the crankshaft participate in the kinematic pair with the two of the primitive solid in one element of the kinematic pair will be paired with a frame. Each primitive primitive in the other element of the type (e.g. block or cylinder) kinematic pair. One of these primitive solids must be solid, and the other must be hollow. A hollow primitive the in the frame. These holes are hollow primitive crankshaft solids, the surrounding solid is a child of a difference node in a CSG tree. For example, formed by subtracting solid block. in Fig. 3 fits into two holes cylinders of the appropriate size and position from of the paired primitive (My algorithms The dimensions axis of symmetry. in kinematic radius and length, and the dimensions sides. In a revolute pair the solid and hollow cylinders must have the same radius, but the the possibility of slippage or play are its of a block are the lengths of three perpendicular solids must be the same, except along In the CSG representation, currently neglect the dimensions of a cylinder pairs.) A. Gelsey/Art$icial Intelligence 74 (1995) 1-53 9 Algorithm 4. Merge two primitive solids into a kinematic pair. If KP is not already on the mechanism’s list of kinematic pairs then add KP to the mechanism’s list of kinematic pairs If SYM.type = prismatic then KP.type := prismatic rotational then KP.type := revolute If SYM.type = else add the pair (PRZMI,PRZM2) to KP’s list of pairs of primitive solids If KP.type = prismatic AND SYM.type = rotational revolute AND SYM.type == prismatic OR KP.type = then KP.type := cylindrical example, in the crank mechanism the solid cylinders of their lengths may differ-for the crankshaft extend far beyond the length of the hollow cylinders they fit into. In a prismatic pair, the hollow and solid primitives must have identical cross-sections, but again they may differ in the dimension along the axis of symmetry, as is the case for the prismatic pair in Fig. 4. Finally, the two primitive solids must have a non-empty intersection. A hole in one place will not form a kinematic pair with a solid that is somewhere else on the same axis. The intersection may however be smaller than either of the two primitive solids: the solid element may extend out of the hollow, as in the crankshaft/frame pair, and/or be inside a much larger hollow element, as is the case for the piston/frame pair. Since the Constructive Solid Geometry representation is based on Boolean set oper- ations, there is an easy way to define the shapes of two parts in order that they will fit together to form a lower pair: simply describe the shape of the solid element of the pair and then use a single difference operation to create the hollow element by subtract- ing the solid element from some other (larger) solid body. Algorithm 3 is particularly suitable for identifying lower pairs whose elements are defined in this way. However, in some cases the elements of a kinematic pair may be specified in other ways that are less convenient for the user but which yield exactly the same shapes, since Constructive Solid Geometry representations for solids are not unique [ 331. For example, a hole with a rectangular cross-section may be created either as a difference of two blocks or as a union of four blocks. A limitation of Algorithm 3 is the underlying assumption that the Boolean set operation used to form the hollow element of a kinematic pair is a difference operation, so Algorithm 3 could not currently identify a kinematic pair whose hollow element was formed as the union of four blocks. If two primitive solids satisfy the conditions in Algorithm 3, then Algorithm 4 is used to instantiate a new kinematic pair or merge new data into a previously instantiated pair. For example, a cylindrical pair has both prismatic and rotational symmetry. Depending on which symmetry is processed first, the pair will initially be instantiated as either prismatic or revolute, and then when the other symmetry is processed the type of kinematic pair will be set to cylindrical. Often the initial list of kinematic pairs will include degrees of freedom which are ac- tually unavailable to the mechanism being analyzed. Algorithm 5 is a heuristic algorithm which filters the degrees of freedom associated with each kinematic pair, attempting to IO A. Gelsey/Artificiul Intelligence 74 (I 995) 1-53 Algorithm 5. Refine the list of kinematic pairs. For each kinematic pair KP If KP.type == cylindrical and its translational motion then KP.type := revolute is blocked in both directions If KP.type == cylindrical and one of its primitive solids is a block then KP.type := prismatic If KP.type == cylindrical and it has two cylindrical subparts which are not coaxial then KP.typc := prismatic from is possible. it can then remove If translational motion degrees of freedom which the list. Any identify unavailable subpart will have both rotational and prismatic symme- kinematic pair with a cylindrical try and therefore will initially be labeled a cylindrical pair, but often a further limitation of the degrees of freedom is blocked because both ends of the solid element of the pair are in contact with solid parts of the other element, degree of freedom can be removed, and the kinematic pair can be then the translational declared a revolute pair. If translation though, even for a short distance, is kept, since my algorithms cur- the possibility of slippage or play in kinematic pairs. If rotational motion rently neglect is blocked because symmetry, the kinematic pair can be declared a prismatic pair. Every additional degree of freedom eliminated to run more efficiently, analysis will allow simulation of the machine’s dynamics since fewer state variables will be needed. the translational degree of freedom of the pair doesn’t have rotational in at least one direction, the total cross-section in kinematic is possible Algorithm 5 only removes one of a cylindrical pair’s two degrees of freedom if it is though it legitimately a degree of freedom that is actually available is that missing degrees of freedom may result strategy simulations, simulations. that that degree of freedom will never be available to the kinematic able to determine pair. Therefore to a kinematic pair will never mistakenly be removed, but, on the other hand, there may be cases when a degree could be. of freedom will not be removed by Algorithm 5 even though in for this cautious The reason but extra degrees of freedom will still give completely wrong behavioral The final behavioral model of a machine correct, less efficient, in the behavioral model any contact between incorporates if, for example, a revolute pair solid objects will generate an appropriate the fact that its translational motion was blocked would were classified as cylindrical, still be implicitly the represented in fact behave as a revolute pair because any translational motion kinematic pair would reduction would be resisted by an appropriate of degrees of freedom may result in incorrect simulated behavior because the behavioral model will have missing state variables, and forces which would in reality missing in the behavioral model, and in a behavioral simulation state variables will have no effect in this model. force. On the other hand, an unwarranted the geometric model, and force. Thus influence the 2.1.2. Identifying higher pairs At present, the only higher pairs my kinematic However, my model generator still works on mechanisms analyzer knows about are gear pairs. including other higher pairs: A. Gelsey/Art@cial Intelligence 74 (1995) I-53 II Algorithm 6. Find gear pairs. For each pair of parts PART1 and PART2 For each primitive solid PRIM1 in PART1 which is a “gear” For each primitive If PRIM1 solid PRIM2 intersects PRIM2 in PART2 which is a “gear” then instantiate a new “gear” kinematic pair since their behavior arises from the physics of bodies in contact, in Section 2.2.1 and Appendix A allow Fig. 14 shows an example of such a higher pair. that behavior the dynamics algorithms and simulated. to be modeled Modeling the physical structure of a gear poses a difficulty for the CSG representation available is a cylinder, and does not imply that the object modeled actually labeled with the property “gear”. This convention in Section 2.1, since gear teeth typically have a profile curve such as a cycloid described or an involute which cannot be represented with the primitives in most CSG implementations. My program expects a gear to be represented by its motion envelope, is just for shape which representation as a gear. If the motion envelopes of two such “gears” overlap to be meshed. 2 My program does not presently model gear tooth geometry, arbitrarily is considered computes that would be a compromise of tooth geometry would be to annotate each gear with the number of teeth and the tooth depth. Gear pairs are represented by the KINEMATIC PAIR data structure (Fig. 6) and identified by Algorithm 6. so an and the number of teeth analyzer the gear ratio to be the ratio of the diameters of the gears. A simple extension the present scheme and a full representation in space, then they are considered to be directly proportional to gear diameter, so the kinematic small overlap is considered for meshing, sufficient functions between 2.1.3. Partitioning The goal of kinematic analysis is to choose a useful set of state variables. It is since simulations will pairs that the set of state variables be as small as possible desirable run more efficiently with fewer state variables. State variables are chosen by partitioning the kinematic sets of parts which are kinematically constrained positions position and velocity of any one of the gears, so it is preferable of freedom associated with the entire gear train. so that the entire set has only a single degree of freedom. For example, and velocities of every gear in a gear train can be computed by knowing the the to have only one degree into kinematic subsystems, Each kinematic and a velocity variable. My current partitioning each moving part pairs that bind kinematic discuss partitioning subsystem has two state variables associated with it: a position variable is fairly limited, and requires algorithm the kinematic together must be higher pairs. In this section I will together by gears. For example, to be part of a fixed-axis kinematic pair. Therefore for kinematic subsystems subsystems bound * This is the only case of input to the kinematic analyzer in which the CSG representations of solid bodies are allowed to overlap in space. 12 A. Gelsey/Artijicial Intelligence 74 (1995) 1-53 KINEMATIC SUBSYSTEM: (Fig. 9) 1. the fixed-axis KINEMATIC PAIR 2. the motion envelope of the moving part of the KINEMATIC PAIR 3. a list of INTERACTOR data structures 4. the 5. the 6. the 7. the 8. the 9. the 10. the inertia of the moving part linear damping coefficient of the moving part spring description children: a list of KINEMATIC SUBSYSTEM parent: a KINEMATIC SUBSYSTEM type of relationship with the parent relationship data structures data structure data Fig. 7. The KINEMATIC SUBSYSTEM data structure (Escape Wheel) -+ (Lever) -----f (Frame) (Balance) a) Only balance moving (e.g. Fig. 1 (a) and Fig. 1 (d) ) (Balance) ---+ (Lever) -+ (Escape Wheel) b) All three parts moving together (e.g. Fig. I (b) and Fig. 1 (c) ) [Note: these are for the second behavioral model, Appendix A] Fig. 8. Kinematic subsystem trees for escapement. in the chiming clock shown gear form a single kinematic higher pairs that form temporary kinematic the three moving parts are considered pairs into a single kinematic in Fig. 26 (Section 3.2.2) subsystem. the escape wheel and the large In Appendix A I will introduce several transient in Fig. 1 (c) joined by two transient higher subsystems to be temporarily so that, for example, subsystem which has a total of one degree of freedom. kinematic subsystem A kinematic is a set of elementary subsystems, kinematic (Fig. 7). This data structure it (if there is one). The data structure also includes pointers sub- systems with only one moving part, each represented by a KINEMATIC SUBSYSTEM includes data from the model of physical data structure (see Section 2.1) : the inertia and damping of the moving part and a description structure of the spring driving the node’s parent and children, as a tree with a particular may be reorganized ferent elementary trees for escapement when the moving parts are linked by the transient higher pairs of is Appendix A. For example, Fig. 8(a) determined by that of the lever, and the position of the lever is determined by that of the frame. Since the frame never moves, neither do the lever or escape wheel. The balance, all three however, the tree to make a dif- subsystem subsystem be the root. Fig. 8 shows kinematic the kinematic as its root, though that the position of the escape wheel and can move. In Fig. 8(b), at any time using Algorithm and these pointers organize is in a separate kinematic 21 (Section A.2.1) elementary subsystem subsystem subsystem kinematic kinematic indicates to A. Gelsey/Art$icial Intelligence 74 (I 995) I-53 13 Algorithm 7. Form permunent kinematic subsystems. 1. For each kinematic pair KP If one element of the pair is the frame then instantiate a new KINEMATIC SUBSYSTEM data structure KS Store the value KP in the KINEMATIC PAIR field of KS Fill in physical structure data from the input model Set all other fields to NULL 2. For each gear pair GP If both of the associated kinematic subsystems have parents then make one the root of its tree by reversing links Make one of the associated kinematic subsystems which is a root the child of the other kinematic subsystem Set the relationship type to GEAR Set the relationship data to the gear ratio INTEXACTOR: 1. the two KINEMATIC SUBSYSTEMS that interact 2. the two sets of interacting primitive solids 3. the ACTIVE flag (see Appendix A) Fig. 9. The INTJZRACTOR data struchm.. can move, and the position of the escape wheel determines that of the other two. parts These trees are shown only for the second behavioral model (Appendix A) because for the first model, the three escapement subsystems always remain separate and never join to form a tree. The position and velocity state variables for a kinematic subsystem are the position and velocity of the elementary kinematic subsystem which is the root of the tree. The states of the other elementary kinematic subsystems may be computed by descending the tree, computing the state of each node from the state of its parent. Algorithm 7 generates all elementary kinematic subsystems, and forms permanent links between each pair of elementary kinematic subsystems whose moving parts are gears which are meshed with each other. In Appendix A I will describe dynamic partitioning algorithms which form additional links when the moving parts of different kinematic subsystems temporarily form certain other higher pairs. 2. I .4. Interaction analysis Interaction analysis determines which of the kinematic subsystems might potentially come in contact during the motion of the mechanism. Potential interactions are repre- sented by the INTERACTOR data structure (Fig. 9). This preprocessing results in an optimization of the model, but it isn’t an essential part of the model-generation process. Without preprocessing, any pair of parts would have to be treated as potentially inter- acting, which would slow down simulations using the model. My interaction analysis 14 A. Gelse.y/Artificiul Intelligence 74 (1995) 1-53 works by checking [ 151 and are currently limited to fixed-axis mechanisms. for intersecting motion envelopes; the algorithms are described in 2.2. Dynamics After finding a useful set of state variables, my program must complete the behavioral how the state variables change with time, which model of a mechanism is described using differential by determining equations dsi - dt =g,(s,r) (1) that my program creates. The behavior of a mechanism the s; are state variables. The functions g; are part of the behavioral model of depends on sorts of in two different ways: a two parts depends only on the state of those two parts are determined by the two where the mechanism the forces acting between simplifying local model two parts, and a global model simultaneous models. assumptions, my program can model the force between in which the parts of the mechanism. By making different the whole mechanism. Section 2.4 compares in which the forces between these forces equations involving 2.2.1. Local model for contact forces a mechanism consisting Consider kinematic subsystem, subsystems, of FL elementary kinematic subsystems with only one moving part. Let xi be the position variable associated with the ith elementary and let L’, be the time derivative of xi. The state of the machine at any time is specified completely by the values of the 2n state variables xi equations, each an and u;, and the way the state changes instance of Eq. ( 1). For mechanical are typically they cannot be nonlinear and in fact may not be expressible solved explicitly. To solve these equations numerically to compute the time derivatives of the state variables. For the x; this computation is described by 2n differential devices, in closed form, so in general requires algorithms these differential is trivial since equations dx, xt = dt = L’f. For the L!, dui ti;=dt=li. f; (2) (3) then the inertia In this equation pair with the frame, the frame of the revolute pair. The inertia structure force in the traditional I, is the inertiu of the moving part. If the moving part forms a prismatic is just its mass, and if it forms a revolute pair with the axis data (Fig. 7). For a prismatic pair, fi, the force on the moving part, is just the net sense, while for a revolute pair it is the net torque. is the moment of inertia of the moving part about from the KINEMATIC SUBSYSTEM then the inertia is available In my current from three sources: implementation springs, contributions friction, and contact to the total force on a subsystem come forces. Springs are attached between A. Gelsey/Artifcial Intelligence 74 (1995) l-53 15 Fig. 10. Free-body diagrams of escapement moving parts. kinematic subsystem, state variable. For example, the mainspring which gives the energy of an elementary function of the position two springs: the two elements linear in Fig. 1 involves and the hairspring which makes In my current model generator with information not explicitly kinematic variable implementation subsystem, and the frictional (i.e. viscous damping, not Coulomb represented. Friction occurs between force is a linear friction). springs are represented by annotating about springs constants; is a force the spring and the escapement mechanism to run the clock, rate. to the the shapes of the springs are the input the two elements of an elementary function of the velocity state the rotation of the balance oscillate at a regular The model for contact forces which I discuss in the present section explicitly considers the small elastic and plastic distortions model which greatly simplifies modeled overlap gives rise to a force. If o is the depth of overlap, is defined by the physics rigid, but their volumes I use a involved but is still quite useful. Bodies are in space, and this the magnitude 1 of the force of the parts near the point of contact. are allowed to overlap as being 0, 1 The contact I = Eo + DbMo, ifo>Oand otherwise. E+DMd>O, (4) force is basically being modeled as a linear spring with linear damping, factor term on the right b has significant magnitude where E is the spring constant and D is the damping coefficient. The additional continuous. MO in the second even when o = 0, so without MO, the damping (Typically force would finite value at the first instant of contact.) The direction of the force is taken to be that of the surface normal at the point of contact. Simulations to of mechanism changes in the values of the constants in Eq. (4), and the values from zero to a significant behavior appear fairly jump discontinuously the force function insensitive to make is there E = 100000, D = 10000, M = 100, are used for all examples The total force fi on subsystem in this article. i is fi = -kiXi - hiUi - c aiklk, where ki is the spring constant of the spring, the coefficient of linear friction of subsystem if any, attached i, lk is the contact (5) to subsystem i, hi is force described above 16 A. Gelsey/Art@cial Intelligence 74 (I 995) 1-53 Algorithm 8. Compute For each elementary kinematic Set i; = Ui and tii = ( -kixi subsystem - hiui) /Ii i time derivatives of state variables. For each INTERACTOR data structure (Fig. 9) For each pair of potentially interacting primitive solids If Algorithm 9 determines that their volumes overlap in space Let o be the depth of overlap it be the normal vector at the point of contact For each of the two interacting subsystems Let hi be a unit vector along the axis of the kinematic pair If subsystem elementary kinematic i is a prismatic pair i then set Qi = n ii; Else Let Ti be the radius vector from the axis to the point of contact Set ‘Y; = ri X n 2i If n points away from subsystem + (~2~2) Let i, = -(a,~ i, then negate ay, l=Eo+DtiMo For each of the two interacting Subtract aiZ/Zi from ti; elementary kinematic subsystems i the two parts in contact at contact k, and LYik is the geometric force multiplier between taking the contact force lk into a force on subsystem involved in contact k.) i. (qk is zero if subsystem i is not in Fig. 1 (c) for the state shown in which the escape wheel is pushing I will be the same for both subsystems the balance. A contact force contributes Fig. 10 shows free-body diagrams of the three moving parts of the escapement mech- the lever to iri for two different though the on each of them, but the factors LY will be different. For is positive, giving the f2 and f3 on the lever anism, which in turn is pushing subsystems. in opposite directions escapement balance a counterclockwise and escape wheel are negative, so they both experience clockwise acceleration. into a useful behavioral model of a mechanism state of Fig. 10, the net torque fl on the balance the net torques acceleration, while To turn algorithms overlap o, the rate of change of overlap 4 and the geometric these equations for determining which parts are in contact and for computing requires the depth of since the force acts equally force multiplier Algorithm 8 computes above. 3 Following EQ. (2)) the time derivatives of the state variables using is set to be Ui for all elementary kinematic ii cy. the equations subsystems i. ’ Though Algorithm 8 appears complicated, it is actually are partial differential etc. The equations of elasticity grid or mesh generation) complex shapes like predicting part failures by estimating metal fatigue, for predicting behavior under normal operating conditions. like the escapement mechanism to for their computational needed equations, and the automating far simpler than a proper model using true elasticity, (i.e. task for solution would be quite a challenging in Fig. 1. While a deeper model might be useful for tasks simply seems hard to justify the added complexity the discretization A. Gelsey/Art@cial Intelligence 74 (1995) l-53 17 Using Eq. (3) and part of Eq. (5), each tii is set to ( -kixi - h~~)/l~ to account for the spring and frictional forces. Then Algorithm 9 is used to find parts in contact, Eq. (4) is used to compute the resulting contact force, and this is used in Eq. (5) to find the net tii. In the case of a prismatic pair, the geometric force multiplier LY will be simply n . ii; it will select the component of the force along the axis of translation. For a revolute pair, a will be r x n - ii since the torque due to a force f is r x f and in this case the force is In where 1 is the magnitude of the contact force computed from Eq. (4) and n, the surface normal, is the direction of the contact force acting on the body touching the surface. The direction of the force on the other body is -n. The rate of change of overlap b, which appears in Eq. (4)) is the sum of the motions of the two parts at the point of contact, and these motions are computed from the velocity state variables using the same geometric factor CY. The fact that both force and velocity transformation use the same geometric factor is basically the principle of the lever. A force at one end of a lever appears at the other end multiplied by a certain factor, and the velocity appears divided by exactly the same factor. This equivalence can be proven more formally by permuting the scalar triple product r x n. ii to get ii x r. II which will take the angular velocity vector dui into the component of linear velocity in the surface normal direction. To compute the net force on each part the time derivative routine must determine which primitive solids have overlapping volumes. For each overlap detected, both the depth of overlap and the surface normal at the point of contact must be computed. Algorithm 8 applies Algorithm 9 to each pair of potentially interacting primitive solids to compute this information. In some sense Algorithm 9 is actually unnecessary: the PADL-2 solid modeler mentioned in Section 2 includes much more general algorithms for computing solid-body intersections. In my experiments I have found, however, that these general algorithms runs several orders of magnitude slower than Algorithm 9 and would make impossible the real-time simulations achieved by my current implementation (see Fig. 22). Algorithm 9 is currently limited to “2$-dimensional” overlapping parts: it works by analyzing two-dimensional projections of three-dimensional situations. Therefore prim- itive solids can’t have arbitrary orientations; they must have prismatic symmetry with respect to the z-axis. Overlap computations are currently limited to interactions between blocks and other blocks or cylinders. All these limitations could be removed, of course, simply by using the slow but general intersection capabilities of PADL-2. For the model of contact forces used in this section to be plausible, parts may only overlap slightly. Thus the algorithms in this section compute depths of overlap based on the assumption that the overlap will be slight. However, if the simulator is adjusting its step size to try to find an optimum, it may start by trying incorrect sizes that lead it to project physically implausible states like those shown in Fig. 11 (c) and Fig. 11 (e) . To allow the simulator to make proper adjustments, the depth values returned in these cases must be a reasonable extrapolation of the results in the physically plausible range. In the case of two potentially overlapping blocks, Algorithm 10 looks for a face of one of the blocks which separates one comer of the other block from its other three corners, with the one corner being inside the first block and the other three comers 18 a Blocks overlapping b Blocks not overlapping c Blocks overlapping too deeply I d Cylinder crosses face e Cylinder center inside block f Corner within cylinder g Cylinder not overlapping block Fig. I I. Cases the overlap detector must deal with. Algorithm 9. Check overlap of two primitive solids. 1. If the projections of the solids on the z-axis do not intersect, 2. Project 3. Return the solids on the x--v plane and apply Algorithm the depth of overlap, 10 or Algorithm 11 the point of overlap, and the local surface normal then exit is being outside. See Fig. 1 1 (a). Alternatively, in a plane such that one block is entirely on one side of the plane and the other block is entirely on the other side, then the blocks do not overlap. See Fig. 11(b). Otherwise the blocks do overlap, but more deeply so the depth must be extrapolated. See Fig. 1 1 (c) . if one of the blocks has a face which than physically plausible, Algorithm 11 deals with the case of a cylinder which potentially overlaps a block. A cylinder may cross a face of a block, as in Fig. 11 (d), or contain a corner of a block, the depth must be as in Fig. 11 (f). extrapolated the solids do not overlap. See Fig. 11 (g). range. See Fig. 11 (e). Otherwise from the physically plausible the center of the cylinder, If the block contains A. Gelsey/Artifcial Intelligence 74 (1995) 1-53 19 Algorithm 10. Check overlap of two blocks. 1. 2. 3. 4. Check each of the four comers of each of the two blocks to see if it is the only corner within the other block, as shown in Fig. 11(a) If a comer is within the other block, return the comer as the point of contact, the distance from the nearest face as the depth of overlap, and the perpendicular out of the face as the local surface normal If one of the four faces of either block separates the two blocks, as shown in Fig. 11 (b), then exit The blocks overlap deeply as in Fig. 11 (c) . Choose the point midway between the blocks’ centers as the point of contact, the overlap between the blocks’ containing spheres as the depth of overlap, and let the “normal” be along the line between the blocks’ centers Algorithm 11. Check overlap of a block and a cylinder. 1. 2. 3. 4. 5. If the cylinder crosses a face of the block as shown in Fig. 11 (d) , return the most deeply embedded point of the cylinder as the point of contact, the distance from the nearest face as the depth of overlap, and the perpendicular out of the face as the local surface normal If the block contains the center of the cylinder as in Fig. 11 (e) , choose the point midway between the solids’ centers as the point of contact, the overlap between the cylinder and the block’s containing sphere as the depth of overlap, and let the “normal” be along the line between the solids’ centers Check each of the four comers of the block to see if it is within the cylinder, as shown in Fig. 11 (f) If a comer is within the cylinder, return the deepest comer as the point of contact, the distance to the surface as the depth of overlap, and the normal to the cylinder’s surface The solids don’t overlap (Fig. 11 (g) ) . Exit 2.2.2. Global model for contact forces My program can also create an alternative model for contact forces that represents machines as collections of perfectly rigid bodies and which treats interactions between different kinematic subsystems by forming temporary kinematic pairs that join the var- ious interacting subsystems together into a single subsystem. When new temporary kinematic pairs are formed, the behavioral model dynamically reduces the number of state variables, because the state of each kinematic subsystem is determined by just two state variables-a position and a velocity-no matter how many parts are in the subsystem. When parts separate, the number of state variables increases again. In this model, the forces shown in the free-body diagrams in Fig. 10 are still acting, but they never need to be explicitly considered in predicting the motion of the mechanism: their effects are all captured by the kinematic constraints which reduce the number of state variables. Though the forces do not need to be computed to predict a machine’s behav- ior, if desired they may be determined using simultaneous mechanism, which this model are given in Appendix A. is why I call this a global model for contact equations involving the whole forces. The details of 2.3. Simulation A computational the differential equations of its behavioral model equations that standard algorithms in my local model for contact for numerically time steps are taken simulation of a machine’s behavior may be generated by numerically for a specific set of initial forces are “stiff”, solving differential equations will [ 121. Thus based for stiff differential in [ 231. My global model for contact forces does based on that model I use a more standard solving conditions. The differential which means be unstable unless very small on that model I use a special algorithm subroutine GEAR the publicly-available not have stiff equations, algorithm, method, subroutine RKF4.5 [ 381. Both GEAR and RKF45 are available via electronic mail from netlib@ornl.gov. the Runge-Kutta-Fehlberg in the publicly-available so for simulations for simulations implemented implemented equations, For both models the numerical solvers must be carefully controlled to ensure that to as shown in the motion of I (b), where the balance collides with the lever. Before the collision, to allow two moving parts of a mechanism the escapement mechanism take time steps large enough they never pass through each other. For example, consider Fig. the balance even step it may go directly a state in which the balance to predict is very smooth, and the simulator if it takes quite the collision of the balance with the lever. large time steps. However, can predict its position very accurately takes too large a time is on one side of the lever to is on the other side of the lever, so the simulation will fail if a simulator from a state in which the balance Figs. 12 and 13 show the complete [ 201. Fig. 13 shows the supplementary input data given to my program for the escapement in Fig. 1. Fig. 12 shows the geometric description of the mechanism which mechanism is parsed by the PADL-2 solid modeling program that the moments of inertia of the lever, balance, and escape wheel input data indicating are 10, 20, and 200, respectively, that their coefficients of friction with the frame are 5, 6, and 20, and that a spring with spring constant 15 and relaxed position at 90 degrees the balance and the frame and a spring with spring constant 20 and is attached between the escape wheel and the frame. relaxed position at - 10000 degrees for the are that (all velocities = 0), and are still shows (Fig. 1) when simulated with the global the local model it runs more slowly. (The global model is fast enough Fig. 22 at the end of this section gives numerical methods at time = 0 the parts of the mechanism in the original positions the behavior of the escapement mechanism model for contact yields to permit real-time timing data for all the examples. initial value problem the initial conditions in the input model. Fig. 2 in the introduction to give a complete examples Initial conditions must be specified in Appendix A. A simulation using simulation on a workstation.) to solve. For the following is attached between identical behavior, forces described are not moving specified though Fig. 14 shows a mechanism which converts into reciprocating motion. It consists of a wheel and an arm which both form revolute pairs with the frame. A rotary motion A. Gelsey/ArtiJTcial Intelligence 74 (1995) 1-53 21 generic esc(esc> tooth = blo(x=0.3,y=5.4) at (movx=-3.2) gap = 36 ewheel = ((cyl(d=lO,h=l) un tooth un\ un\ (tooth at (degz=gap)) (tooth at (degz=2*gap>> un\ (tooth at (degz=3*gap)) un\ (tooth at (degz=4*gap)) un\ (tooth at (degz=5*gap>> un\ (tooth at (degz=6*gap>> un\ (tooth at (degz=7*gap)) un\ (tooth at (degz=8*gap)) un\ (tooth at (degz=360-gap))) dif cyl(d=l)) at (movx=O) lever = (((((blo(x=lO,y=2.2) at (movx=-5,movy=6.4)) un\ (blo(x=0.9,y=2) at (degz=7,movx=-3,movy=5.6)) un\ (blo(x=0,9,y=2) at (degz=25,movx=-3,movy=5.6)) un\ (blo(x=l,y=2) at (movy=O.l,degz=-40,movx=2.4,movy=5.7)) un\ (blo(x=l,y=8) at (movx=-.5,movy=8)) un\ (blo(x=i,y=1.8) at (movy=-l,degz=-45,movy=16.2)) un\ (blo(x=l,y=1.8) at (movy=-l,movx=-l,degz=45,movy=16.2))) dif\ (cyl(d=l) at (movy=7.5))) at (movy=-7.5)) at (degz=5)) at\ (movy=7.5) bwheel = (((cyl(d=8,h=l) at (movy=20,movz=-1)) un\ (cyl(d=l,h=2) at (movx=-3,movy=2O,movz=-I))) dif (cyl(d=l) at\ (movy=20,movz=-1))) at (movx=O) frame = ((((blo(x=13,y=31) at (movx=-6.5,movy=-6.5,movz=-2)) un\ (cyl(h=4) at (movz=-2)) un (cyl(h=4) at (movy=7.5,movz=-2)) un\ (cyl(h=3) at (movy=20,movz=-2))) dif\ (ewheel un lever un bwheel)) un\ (cyl(d=l,h=3) at (movx=-1.6,movy=14,movz=-2)) un\ (cyl(d=l.,h=3) at (movx=l.6,movy=14,movz=-2))) at (movx=O) attr frame : frame = 1 esc = ewheel asb lever asb bwheel asb frame Fig. 12. Geometric input data for escapement mechanism. < LEVER : FRAME > 10 5 < BWHEEL : FRAME > 20 6 SPRING 90 15 < EWHEEL : FRAME > 200 20 SPRING -10000 20 Fig. 13. Supplementary input data for escapement mechanism. small cylinder which protrudes rotates, recognizes very common higher kinematic pairs, it does not recognize by the wheel and the arm. Nevertheless, my behavioral from the wheel fits in a grove in the arm. As the wheel analyzer only the pair formed the to oscillate back and forth. Since my kinematic is able to simulate the arm is forced simulator 22 A. Gelsey/Artijicial Intelligence 74 (1995) 1-53 Fig. 14. Mechanism wheel is present in model but not shown in figure.) to convert rotary motion into reciprocating (rocking) motion. (Note: spring attached to v, : S d 2 .r( .': ;: a - 1200 1000 800 600 400 r'- 200 0 0 0 -5 -10 -15 -20 -25 -30 5 10 15 20 0 5 10 15 20 time time wheel arm Fig. IS. Motion of the conversion mechanism. the continuous contact between the same methods the two elements that work for intermittent because in a mechanism behavior of this mechanism, of the higher pair can be modeled using contacts between parts the results of a simulation and the mechanism shown of coefficients between the moving parts and the frame.) of friction, in Fig. 14. (Note: my input representation of this mechanism, where the wheel like the escapement. Fig. 15 shows a plot of is driven by a spring starts in a state with all velocities zero and the parts in the position the specification friction and for all the examples I have specified nonzero (Section 2) allows Fig. 16 shows a “double escapement” mechanism which useful test for the simulator. Fig. 17 shows a plot of simulation jam and the It turns out that the double escapement doesn’t is not particularly in any unusual way; the two balances and lever move synchronously, but provides an interesting results for the double escapement. or behave mechanism exhibits the same regular behavior as the standard escapement. A. Gelsey/Artificial Intelligence 74 (1995) I-53 23 Fig. 16. “Double escapement”. (Note: hairsprings attached to balances and mainspring attached to escape wheel are present in model but not shown in figures.) “-soI __ 1 0 5 10 15 20 25 30 35 40 ’ __ -12 1 t1w tima 0 5 10 15 20 25 30 35 10 . -2: 7 1 -I 5 10 15 20 25 30 35 40 0 tinm Balance 1 Lever 1 Escape Wheel ; 300 0 250 s 200 i 150 g 100 ': 50 j 0 a-5o 2,. . .., 0 -2 -4 -6 -8 -10 -12 I 0 5 10 15 20 25 30 35 40 0 5 10 15 20 25 30 35 40 tinv tima Balance 2 Lever 2 Fig. 17. Motion of the double escapement mechanism. Fig. 18 shows a simple ratchet mechanism. When a counterclockwise force is applied to the wheel, its motion is blocked by the pawl, as shown in Fig. 19, but when a clockwise force is applied to the wheel, it turns freely. Fig. 20 shows a plot of the results of a simulation of this mechanism with a clockwise force on the wheel. Fig. 21 shows a plot of the results of a simulation of this mechanism with a counterclockwise force on the wheel. The configurations of the mechanisms at the end of the two simulations are shown in Fig. 19. 2.4. Comparing the models The global model for contact forces described in Appendix A has also been imple- mented and run on most of these examples. The capability to experiment with two disparate models is a useful tool for investigating how choices of approximations and 24 A. Geisey/Artijicial lntelli~ence 74 (1995) 1-53 Perspective view ” Parallel view Fig. 18. Ratchet mechanism. in figure.) (Note: springs attached to wheel and paw1 are present in model but not shown Clockwise force Counterclockwise force Fig. 19. Final state of ratchet mechanism the models predict. Both of the models appear influence assumptions simplifying havior predictions for clockwork mechanisms, ilar. Fig. 22 shows some experimental this implementation, takes less time to execute each step. This difference model, when parts come model dynamically the differential the local model stiff problems. reduces equations. Also, runs more quickly because to take somewhat in contact tends the forms of behavioral models and the sorts of be- to give quite realistic behavior so simulations using either model are very sim- data. Note that the global model, at least with fewer time steps and in the global the behavioral so that one part pushes another, is plausible because it both requires the number of state variables, which speeds the solution of like those in for longer even when using a solver the solution of stiff differential equations tailored For an application like routine design of some type of mechanical device, model seems superior to the local model for the task of evaluating the global of performance A. Gelsey/Art$cial Intelligence 74 (1995) 1-53 25 30 . . . 0 12 ;; 30 $ 25 & 01 20 'D 15 G .z: 10 .“, 0" a 0 5 '. * '* 3 4 5 6 7 8 91011 time . ~ 0 12 3 4 5 6 7 8 91011 time paw1 wheel Fig. 20. Motion of the ratchet mechanism (clockwise force). 1200 1000 800 600 400 200 0 0 20 40 60 80 100 time 0 20 40 60 80 100 time paw1 wheel Fig. 2 1. Motion of the ratchet mechanism as a function of time (counterclockwise force) Local model Escapement Rotary to Reciprocation Ratchet (cw) Ratchet (ccw) Double Escapement Global model Escapement Rotary to Reciprocation Ratchet (cw) Ratchet (ccw ) Execution time Steps Time/step Simulated time (seconds) (ms) 49.2 2.5 0.82 16.7 181 1.3 0.176 0.086 1.3 3942 2119 594 7928 5073 836 333 65 1089 12.5 1.2 1.4 2.1 36 1.6 0.53 1.3 1.2 31 20 10 100 39 37 20 1.9 100 Fig. 22. Experimental data (Sparcstation 10). 26 A. Gelsey/Art@cial Intelligence 74 (1995) l-53 the local model is likely candidate designs, simply because to be a better choice in which, for example, unusual or innovative designs must be evaluated, since its simpler derivation and implementation make it more adaptable it runs much faster. However, for an application to new situations. 3. Long-term behavior prediction The behavior of a machine with n state variables is a curve s(t) in an n-dimensional s(t) s(t) simulation, as described is the solution can be approximated to Eq. ( 1) (Section 2.2) in Section 2.3. However, many machines and s(t) may be computed over any particular for specific time period using exhibit as a simple function of t, at least for a state space. The function initial conditions, numerical repetitive behavior: discrete set of time points. Such an approximation a machine’s long-term behavior, since straight simulation over a very long time period can be quite also serves as a concise description of both the qualitative expensive. The approximation long-term behavior and thus may and quantitative provide considerable The approximation insight. used in my current aspects of the machine’s predicted is a linear function of time is useful for predicting implementation t(t) = s(to) + (t - to)A/D (6) that the linear. However, by limiting to the time points at the start of each repetitive behavior pattern, only holds at where A and D are constant. Of course, a glance at Fig. 2 makes behavior of something like an escapement the approximation a linear approximation these particular a detailed simulation over a time interval separating any two of the discrete where the approximation My program attempts the approximation values of s(t) may be computed by running time points becomes quite viable. Though time points, is far from intermediate it clear holds. to find such an approximation to find parameter values by using short, carefully for EQ. (6). It then simulations con- tests this to expose by subjecting it to a series of tests sI( t) and the actual s(t). in order the approximation trolled numerical hypothesized discrepancies approximation between An alternative approach two. In contrast, the mathematical clocks may be found in order to reduce ysis using mechanical assumptions to only my program has six state variables, as described to two state variables powerful Poincare-Bendixson tractors for two-dimensional these systems the less approximate is important systems and proves [ 7,261. for dynamical to predicting a machine’s theory of dynamical long-term behavior would be anal- analyses of systems. For example, in [ 1,27,3 11. These analyses use strong simplifying that must be considered the number of state variables behavioral model of a clock created by in Section 2. Reduction of the problem the use of the of at- for analysis, as it allows that chaotic behavior is impossible theorem, which provides a complete classification Thus long-term behavior prediction may be done either by using a detailed behavioral the behavioral in detail the resulting approximate model. In this article model and approximating model itself and then analyzing the resulting behavior s(t), or by approximating A. Gelsey/Art@cial Intelligence 74 (1995) l-53 27 I take the first approach, though automating the approximation and dynamical analysis process needed for the second approach appears to be an interesting (and challenging) research problem. However, finding an simple approximation s1( t) to the behavior seems likely to provide useful guidance in the task of generating an approximate behavioral model, so the two approaches are actually complementary rather than competitive. In addition, since the behavioral model used by my algorithms includes the complete mechanism geometry, the approximation s^(t) based on that detailed behavioral model should provide a valuable check for an analysis based on a more approximate behavioral model which must necessarily abstract away most details of a mechanical device’s geometry. 3.1. Finding behavioral regularities My program attempts to approximate s(t) at a series of discrete time points to + nD, where to is a time at which a particular repetitive behavior pattern begins, n is an integer, and D is the duration of the repetitive behavior patterns. The approximation currently used is the linear function of time in EQ. (6)) which may be rewritten in terms of n s^(to + nD) = s(to) + nA (7) Though the approximation only holds at time points to + nD for integer n, intermediate values of s(t) may be computed by running a detailed simulation with initial conditions sI( to + nD) for any n. For the simplest sort of periodic behavior, every component of the vector A will be zero, and the approximation will be constant. However, a constant approximation won’t work for something like the escapement, where Fig. 2 indicates that at least the entry of A corresponding to the escape wheel position will be nonzero. To find such an approximation, my program runs a numerical simulation to generate s(t), searching for values of to, D, and A which give an approximation matching s(t) at the time points to + nD. To constrain this potentially explosive search, the search process only examines states for which the function ek(s( t)) has a minimum, where ek is the kinetic energy of the mechanism. This restriction implies that the discrete time points to + nD will be kinetic energy minima. If the machine’s behavior is in fact repetitive, it is also plausible to assume that each interval of length D will include the same number of kinetic energy minima. My approximation algorithm focuses on kinetic energy minima because the presence of a kinetic energy minimum is a useful heuristic indicator of a boundary between qualitatively distinct regions of behavior, for example at a time when an oscillating part of a machine switches from moving in one direction to moving in another, or when a part of a machine receives a push or other energy boost so that its velocity stops decreasing and starts increasing. A change in the number of kinetic energy minima in a behavior pattern is thus a good indication of a significant qualitative change in behavior. My program uses Algorithm 12 to try to find the approximation s1( t) by filling in the fields of the data structure in Fig. 23 with values consistent with the stream of behavior data coming from the numerical simulator. The program simulates the behavior of the machine until it finds several kinetic energy minima. In order to avoid being misled by spurious local kinetic energy minima, the program only considers minima that are in the 28 A. Gelsey/Artificial Intelligence 74 (199.5) 1-53 I. Number of kinetic energy minima 2. Duration of the behavior pattern 3. Net change 4. List of periodically superimposed in each state variable over each pattern instance (A) processes (Fig. 25) in an instance of the behavior pattern (M) (D) Fig. 23. Parameters for approximation i(t) Algorithm 12. Find a locally satisfactov behavioral hypothesis. [Default parameter values: Pconsrm = 2, Prange_fraction = 10e5, ‘Pisnore = 4, ?i_match = .Ol , P s-vmatch = 421 While no behavioral hypothesis has been formed OR (hypothesis belief level) < M * Pconsn,, Perform a simulation Update range information If the previous state was a local kinetic energy minimum step AND its energy AND Pisnore kinetic energy minima have been ignored level < Pransefraction * (top of kinetic energy range) Then If there is no hypothesis Then hypothesize M+-1 D c difference a behavior pattern: in time between the current kinetic energy minimum and the previous one A t differences in the values of the state variables between the current kinetic energy minimum and the previous one Else the current hypothesis remains valid if and only if: D matches the time elapsed since the Mth previous kinetic energy minimum AND A matches to within Ptmatch the changes in the values of the state variables since the Mth previous kinetic energy minimum to within PS_v_matCh If the current hypothesis fails then form a new hypothesis: level) + 0 (hypothesis belief McMSl D t difference minimum A c differences in time between the current kinetic energy and the Mth previous one in the values of the state variables between the Else increment current kinetic energy minimum (hypothesis belief level) and the Mth previous one A. Gelsey/Artifcial Intelligence 74 (1995) 1-53 29 bottom Prmgefraction of the range of kinetic energies encountered during the simulation. The first Pigno= minima are ignored so that the program will not be misled by transient startup phenomena. Machines designed for regular behavior must incorporate damping or negative feedback to rapidly eliminate behavioral irregularities, so Pisnore can safely be set to a small value. The program searches for a viable approximation by successively forming each possi- ble hypothesis which is consistent with the currently available data. After each hypothesis is formed it is tested against the results of further simulation. Though the program re- quires that new data match the predictions of the hypothesis fairly closely, it does not require exact matches because of transients and other noise in the numerical data. The match parameters can be adjusted to “tune” the behaviors the program will recognize. For example, identical patterns with very different time durations could be detected by giving Ptm&, a large value. This algorithm is based on the following simple but powerful ideas: ( 1) Given a set of simulation data including exactly m kinetic energy minima, if M in Fig. 23 is assigned the value m, then there is clearly a unique assignment of D and A which is consistent with the data. (2) Given a set of simulation data including more than m kinetic energy minima, either the single m-minima hypothesis which is consistent with the first m minima will also be consistent with the rest of the data, or else no m-minima hypothesis can be consistent with all of the data, which implies that: (3) Once the program has found new data not consistent with a previously formed m-minima hypothesis (which was consistent with some particular sequence of m minima), it need never again consider any hypothesis with m kinetic energy minima. Thus the program can iterate through the possible behavioral hypotheses, testing each in turn. Note that the program looks for regularities in the behavior of the state variables (like that shown in Fig. 2), not in the behavior of the kinetic energy. Kinetic energy is simply used as a guide to tell the program when to look at the state variables-it might be considered a measure of the “interestingness” of a particular state of the machine. Focusing the search on the most significant points in the system’s behavior reduces the chance of incorrect matches, and also makes Algorithm 12 quite efficient. If a machine has a behavior pattern with M kinetic energy minima, and the behavioral simulator takes no more than S steps during each instance of the behavior pattern, then Algorithm 12 will terminate after no more than S(P. ,gnore + M(Pconfinn + 1)) iterations of its main loop. A potential drawback in using kinetic energy minima as a filter when analyzing a machine’s behavior is that some interesting behaviors could be filtered out. For example, any machine having no energy input, no potential energy storage mechanism, and no friction or other dissipation or energy output will clearly have absolutely constant kinetic energy at all times, even though it may have complex and interesting motions. However, such machines are not common; even a machine as simple as a frictionless pendulum fails to fully meet these criteria. Transformations between different forms of energy are central to the purpose of most machines. 30 A. Gelsey/ArtiJiciul intelligence 74 (1995) l-53 Algorithm 13. Test for gradual effects. Let n2 = 1 2 (initial total energy) (change in total energy per pattern instance) 1 Apply Algorithm If the new hypothesis does not match the initial 12 with initial conditions sI( to + n2D) locally satisfactory hypothesis Then FAILURE Else let s( to + nhD) be the last state reached s( to + n,,D> be the last state reached initial in generating the locally satisfactory hypothesis the in generating new locally satisfactory hypothesis If s(to + n,D) = s(to) + n,A Then SUCCESS Else reset A to be ts(to + n,D) - s(to + nbD)) (&I - 4) And test the new hypothesis at to using the validity test in Algorithm 12 3.2. Hypothesis failures 12 finds a “locally Algorithm s^(t) which to s( to + nD) for all n then the hypothesis must eventually failure: is consistent with the initial simulation satisfactory” behavioral hypothesis: an approximation the hypothesis fail. In this article I consider is also globally data. If f(to + nD) remains close otherwise satisfactory; two classes of hypothesis l the distance between sI( to + nD) and s( to + nD) gradually grows as n increases, eventually becoming transition l A sudden large in the machine’s behavior s(t) occurs at some time t,, so that the behavior s^(to + nD) predicted by the approximation is for n > (t,, - to)/D, far from the actual behavior s (to + nD) My program performs a variety of heuristic failures. therefore useful modified if possible or otherwise rejected. for long-term behavior prediction. tests in order to try to detect these hypothesis and satisfactory fails a test, it is If the hypothesis If a hypothesis passes all of the tests it is declared globally 3.2.1. Gradual effects Imprecisions in the components of A may cause the approximation s^( to + nD) = s( to) + nA (8) from to gradually deviate !( to + n2D) deviates significantly state of the machine, an unstable by running instabilities s (to + nD) . At a time to + nzD when from s (to + n2D), sI( to + n2D) will often represent 13 to look for such and my program uses Algorithm sI( to + n2D). If a initial conditions a short simulation with the actual behavior A. Gelsey/Artifcial Intelligence 74 (1995) 1-53 31 deviation approximation is detected s^( t) . in this way, Algorithm 13 attempts to modify A to improve the results tension provides the decreasing in the mainspring in a very slow decrease of the balance. However, The escapement mechanism noise for an initial clock runs, the amplitude of the oscillations the background searches balance between Algorithm change than background rithm 13 can easily correct A to include a small but nonzero change over each behavioral pattern. an example of such a gradual effect. As the in than in the simulation 12 locally valid s^( t), and the initial A indicates zero change for the repetitions. However, when s1( lo + n2D), the gradual noise, and Algo- in balance position the starts of successive behavior pattern initial conditions data, so it is not detected when Algorithm the simulation with this decrease has grown 13 restarts in balance far larger is smaller amplitude 3.2.2. Sudden transitions Figs. 26-29 show mechanisms the “time bomb” fail due to sudden for which hypotheses the machine’s behavior s(t). For example a normal clock for quite a while and then suddenly of the wheels will run into a protrusion on the frame. This sort of hypothesis quite different is unlikely sudden with the frame, but if s1( to + n2D) were instead the wheel on the other side of the protrusion, to detect that the actual behavior f(t). in transitions like in Fig. 29 will behave stop because a protrusion on one is 13 the the wheel collided state with 13 would have no way s(t) had deviated greatly from the predicted behavior in the previous section because Algorithm 13 would detect from the failures discussed the sudden transition. Of course Algorithm if s^( to + n2D) happened the (actually unreachable) to be a state just before then Algorithm to detect transition failure In the mechanical devices we are considering, sudden transitions are changes patterns of contact between parts categories: in the mechanism. I divide these changes in the two into ( 1) changes (2) new contacts between parts not previously in the pattern of contact between in contact. two parts which regularly make contact; The escapement mechanisms with modified escape wheels amples of the first category. The escape wheels so that the pattern of contact between a while, possible violating and the “time bomb” in Figs. 27 and 28 are ex- are modified the escape wheel and the lever will change after (Fig. 26) (Fig. 29) are examples of the second category. local hypothesis. The chiming clock in these two mechanisms a successful to the same state at the end of each behavioral pattern cannot change My program uses Algorithm 14 to make sure changes two parts which regularly make contact will not violate which return so the algorithm only considers pattern of contact, with hypothesized changes. The algorithm position subsystems which are revolute pairs, since net position Algorithm transitions, 14 either uses symmetry or it raises change per pattern would soon separate. the number of confirmations considerations the elements in the pattern of contact between the hypothesis. Moving parts their of a prismatic elementary is limited kinematic to elementary subsystems kinematic pair with a In the case of a rotating part, to rule out the possibility of sudden the hypothesis to make required 32 A. Gelsey/Artificial tntelligence 74 (1995) 1-53 Algorithm 14. Check for symmetric regular contacts. For each elementary subsystem EKS kinematic If EKS has a hypothesized AND EKS is a revolute pair AND EKS has interacted with another elementary kinematic Then position change let M be 27r/(the hypothesized position change for EKS) For each primitive PR in EKS which could interact with EKS2 If PR is not part of a union having M-radial or rotational to M Then raise the number of required confirmations subsystem EKS2 symmetry has been met. solid satisfactory locally revolution. so that the motion of the part will be simulated through a full The program applies Algorithm If Algorithm 14 raises 14 after Algorithm 12 has found a locally satisfactory the number of required confirmations, Algorithm 12 hypothesis. is applied again until the new requirement the primitive was defined using My program determines whether a primitive to the PADL-2 I added a primitive checking whether a syntactic extension takes five arguments: or TRANSLATIONAL), this into an explicit union, and also marks each resulting primitive union. Algorithm symmetric union or has the appropriate symmetry might. 14 checks each primitive in the PADL-2 a repetition solid modeling solid, an axis of symmetry, count, and a range. The preprocessor the SYMMETRKIJNION is part of a symmetric union by macro, language. This macro a type (ROTATIONAL expands the specified properties, symmetric solid PR to see if it is part of an appropriate itself, as a properly positioned cylinder language, having as having come from a particular 3.2.3. New contacts between parts not previously in contact for the first in contact they come The primitive solids which come in contact may be classified New contacts between parts not previously into a num- two time may both be moving, or one may not into contact. The moving part(s) may be rotating or into contact may be either blocks or predicts contacts between a block and a cylin- the other ber of categories, only some of which are handled by my current program. The parts coming have moved before translating. cylinders. My current der. One of them must be motionless must rotate about a fixed axis. The algorithms operate world described earlier cover all cases of a moving part running ward. Predicting more difficult; niques. into a motionless part would be straightfor- is considerably in the same “2&dimensional” I will describe in Section 2.2.1. Extension of the algorithms two simultaneously moving parts approach would probably the use of search into contact, and contacts between implementation they come a general require before tech- to Before presenting block and a cylinder, block and a cylinder, capable only of rotation about a common the algorithms my program uses I will derive some geometrical to predict contacts between preliminaries. a Fig. 24 shows a fixed axis of rotation. A. Gelsey/ArtQicial Intelligence 74 (1995) 1-53 33 4 Block separates axis of rotation (z-axis) from cylinder: q = -1 . . . . . . . . . . ~~::::::_:::::::::::::::~,.. b) Cylinder and axis of rotation (z-axis) on same side of block: \k = 1 Fig. 24. The two ways a cylinder can touch within a face of a block. (The algorithms assume only one of them moves, but this issue is irrelevant from the geometrical point of view.) The following symbols are used in the figure: D the distance from the axis of the cylinder to the axis of rotation, c the distance from the axis of the cylinder to the intersection between the plane of the two axes and the plane containing the face of the block, 8 the angle between the plane perpendicular to the face of the block which contains the axis of rotation and the plane containing the two axes, rb the distance from the axis of rotation to the face in contact with the cylinder, T-~ the radius of the cylinder, P 1 if the axes are separated, and -1 if they are not. By the properties of similar triangles, C -=- rc D+cYc t-b ’ so that Therefore case = !k = rb C - *rc ’ D (9) (10) (11) 34 PSP: A. Gel.~ey/Artijiciul Intelligence 74 (1995) l-53 (time between each start of the superimposed process) (how long the process runs) I. Period 2. Duration 3. Time at which process first starts 4. Vector of truth values specifying 5. Net change in each involved state variable over a process involved state variables Fig. 25. Periodically superimposed process (PSP) data structure It is also possible the edge of a face (Le., in Fig. 24, at one of the blocks’ corners). of cosines requires that that a cylinder may not touch a block within a face but rather at In this case the law rf = T: + 0’ - 2r,D cos 6),, (12) where 8, is the angular polar coordinate of the “corner” of the block when it is in contact with the cylinder, and rc is the corner’s radial polar coordinate, which is constant since the block rotates rigidly. Therefore cos 8, = r,” + D2 - t-1 2r,D In either case there are two possible solutions may be reflected across the horizontal appropriate solution. axis. The algorithms presented below choose for 8, due to the fact that the figures the (13) If one of the parts is fixed, When a new contact occurs, several can then be then the hypothesis will fail completely used to determine it will quickly come to a halt. On the other hand, if the part which was not moving prior to the contact is capable of motion, a new behavior pattern may emerge. at the time of contact. Simulation behavior of the mechanism; things may happen. the subsequent typically Many mechanisms are multiply periodic; different sorts of regular behavior occur at time scales. For example, a chiming clock like that in Fig. 26 will have very different an escapement with a regular behavior pattern times a second, and a chiming mechanism whose pattern might only be repeated once an hour. Perhaps that might be repeated several case of multiple periodicity is what I call a periodically super- (PSP) : an additional behavior pattern which is regularly superimposed represents periodically it. My program imposed process on the basic behavior pattern without disturbing superimposed the commonest Because a superimposed processes with the PSP data structure process does not disturb (Fig. 25). it may the basic behavior pattern, the basic pattern. I call these state to the simulation needed involve only state variables which don’t change during variables static. The static state variables are identified during generate local hypothesis. the original My program uses Algorithm The motion envelope of a part is the volume intersecting motion envelopes but have never been in contact, is computed using Algorithm 16. The parts can only come in contact resulting from a new contact. it sweeps out as it moves. If two parts have their first point of contact if the behavioral 15 to analyze behavior A. Gelsey/Artifcial Intelligence 74 (1995) 1-53 35 15. Analyze behavior resulting from a new contact. 16 to determine how many behavioral pattern instances will pass Algorithm 1. to new to check for gradual effects of steadily changing state variables, and modify given by s^(t) for t halfway initial conditions 13 with contact the first nonhypothesized Use Algorithm before Use Algorithm contact hypothesis If neither part is fixed, restart behavior s^( t) for t just before new contact. While simulating, state variables (a) Monitor behavior of nonstatic if necessary simulator with initial conditions given by to make sure none of them violate the original hypothesis (b) Monitor behavior of static state variables to gather data needed to fill in PSP data structure If the superimposed rithm 13 in default mode to for gradual effects when half the total energy and modify hypothesis process does not violate the original hypothesis, if necessary apply Algo- is gone, 2. 3. 4. Algorithm For each INTERACTOR 16. Look for nonhypothesized contacts. data structure (Fig. 9) If the two parts have never been in contact If both parts move then print a warning message Else if the moving part has a nonzero position change per behavioral pattern For each pair of potentially interacting primitive solids If the one solid is a block and the other is a cylinder For each of the four edges of the block’s 2D projection Use Algorithm cylinder 17 to find out when the edge will hit the Else print a warning message the distance Divide per basic behavioral pattern instance the part can move by its hypothesized displacement instance. Since predicts a net change there may be several nonhypothesized in one of the parts’ positions over contacts, the distance each of the moving parts can move freely per behavioral pattern. Thus contacts can be displacement instances without nonhypothesized If one of the parts is fixed (part of the frame), then my program determines for the original hypothesis ends at the new contact; otherwise, to identify a new periodic process that will be superimposed the on the the contact by the part’s hypothesized for the mechanism hypothesis each behavioral pattern the first is determined by dividing before the number of behavioral determined. that the valid region program attempts originally hypothesized pattern Algorithm 16 uses Algorithm edges of the block’s two-dimensional behavior pattern. 17 to find the first contact between one of the four is the cylinder’s and the circle which projection 36 A. Gelsey/Art@ial Intelligence 74 (1995) 1-53 Algorithm 17. Find first contact between a block’s edge and a cylinder. For each of the two cases {P = - 1 ; P = I} If lPrC + rbl 3 D For each of the two cases {S = - 1 ; S = 11 Let e=sarecos p+) ’ If the contact point (D + h-, cos 8, Pr, sin 6) lies between the endpoints of the edge of the block Then record this 0 as a possible contact Else if the more distant endpoint is nearer than the contact point, but its distance re from the axis of rotation is greater than D - rC OR if the nearer endpoint is farther away than the contact point, but its distance rp from the axis is less than D + r,. Then 8, = Sarccos is a possible contact t-z -+ D2 - r,’ 2r,D > The first contact is the nearest contact in the direction of motion of the moving solid axis, giving the cylinder four possibilities. projection. Each of the two contact cases shown horizontal will be inside output of the algorithm automatically eliminated first. If appropriate, can touch the cylinder. is the nearest contact, since a physically the algorithm also checks in others and in Fig. 24 can be reflected across the In some of these cases the body of the block the final cases will be happen the four ways an endpoint of the edge it will be outside. However, since the physically unrealizable possible contact must necessarily 3.3. Examples The algorithms 12 is that each behavior pattern in this section have all been implemented one at each extreme position of the balance. The and tested on a number of in Fig. 1 has two kinetic initial hypothesis instance has only one kinetic and that all three moving parts have a net position change per pattern. it finds that 12 tests this behavioral hypothesis at the next minimum, examples. The behavior pattern of the escapement mechanism energy minima, formed by Algorithm energy minimum, When Algorithm the net displacements changes. The formed balance nor the lever has a net position confirmed over the next ‘Pconsn,, pattern is then rejected, and a new hypothesis and neither is the is then instances, and finally accepted as locally valid. 13 as to + n2D has of the balance and lever are the negatives of the hypothesized the behavior pattern has two kinetic energy minima, After finding a locally acceptable hypothesis, change per pattern. This hypothesis half of the clock’s original energy the program applies Algorithm initial behavioral hypothesis failure. The simulation is restarted at a time in the mainspring) for hypothesis in which (stored the first check when approximately been dissipated. Algorithm and arrives at the same approximation 13 reapplies Algorithm 12 with this new initial condition, i(t) that it had before. However, when the A. Gelsey/Arti~ciul Intelligence 74 (1995) I-53 37 Fig. 26. Chiming clock. Fig. 27. Escapement mechanism with missing tooth. state s(to + n,D) was compared to the prediction s( to) + naA, Algorithm 13 found a significant deviation because the amplitude of the oscillations of the balance had become considerably smaller, due to the decrease in tension in the mainspring. The program then executes the final portion of Algorithm 13, changing A to include the small change in balance amplitude over each behavior pattern repetition. The new approximation s^(t) to work locally both at to and to + 4. No sudden transitions is then tested and found are found for this example. Fig. 26 shows a clock which chimes at regular intervals (e.g. every hour). A small gear on the escape wheel drives a large gear, which moves relatively slowly. The clapper 38 A. Celsey/Artifcial Intelligence 74 (1995) 1-53 Fig. 28. Escapement mechanism with extra-large tooth. is normally pressed against pushes when hypothesis there are five elementary have been running take the chiming Using the algorithms contact will occur between with initial conditions in order program the collision identifies affecting the clock’s energy to modify of the balance to check then restarts in order the approximation resulting it hits the chime again. it away from the chime and then releases In this example, it so that it makes a chiming the chime by a spring, but the protrusion on the large gear sound to find a local is that the clock will the initial hypothesis will not the only significant difference instead of three. Since the program proceeds subsystems for quite a while before it first chimes, just as it did in the previous example; kinematic given by Z(t) halfway between in Section 3.2.3, the program determines the large gear and the clapper. It then restarts for gradual effects, but no hypothesis modification into account and will therefore be an incomplete behavior prediction. that a nonhypothesized the simulation collision is needed. The given by s^(t) just before contact, and it on the basic hypothesis without 13 as usual at a time when about half of is gone to check again for gradual effects, and this time it does need in the amplitude of oscillation the simulation with initial conditions to determine the results of the nonhypothesized is superimposed to and this unexpected s^(f) to reflect a decrease tension from decreased in the mainspring. a periodic process which it. The program applies Algorithm Fig. 27 shows an escapement mechanism which escape wheel, and Fig. 28 shows an escapement mechanism on the escape wheel is exceptionally starts by finding these examples, locally confirm wheel. the same hypothesis the escape wheel the hypothesis is missing one of the teeth on the in which one of the teeth large. For both of these mechanisms, my program that it finds for the standard escapement. But in to through a full rotation of the escape the program attempts is not symmetric, it must simulate so when In the case of the mechanism with the extra-large a full revolution, the large tooth contacts further, so the initially tooth in Fig. 28, before the escape the lever and prevents fails. My and successful hypothesis to form other hypotheses, but none of them are confirmed wheel has completed the escape wheel from advancing then attempts program it gives up. eventually In the case of the mechanism with the missing tooth in Fig. 27, the initially successful A. Gelsey/Artifcial Intelligence 74 (1995) l-53 39 Fig. 29. The “time bomb”. hypothesis also fails before the escape wheel completes a full revolution. However, when the program starts forming new hypotheses, it eventually finds one with 20 kinetic energy minima in which the displacement of the escape wheel position state variable is one full revolution, and this new hypothesis turns out to be completely successful. Fig. 29 shows a “time bomb”, a clock which runs normally for a long time and then suddenly exhibits anomalous behavior by stopping when a protrusion on one of the wheels runs into a protrusion on the frame. In this example, Algorithm 12 finds a local hypothesis just as it did in the previous cases. The algorithms in Section 3.2.3 determine that an unexpected collision will occur. Algorithm 13 is used to check for gradual deviations of b(t) halfway between to and the collision. In this example, the amplitude of the balance oscillation has not changed significantly because the tension in the mainspring hasn’t changed much, so the original hypothesis is still considered globally consistent over the interval ending when the unexpected collision occurs. 4. Related work A number of mechanical device simulators are commercially available, such as ADAMS [6,29], DADS [22], and others (see surveys in [8,21,30,32]). Though these simulators include powerful algorithms for forming and solving the equations of motions for a wide variety of mechanisms, they are incapable of using information about the shape of a machine’s parts, so the user of the simulator inherits the following modeling tasks: l For each pair of parts in permanent contact, completely describe the resulting geometric constraint. l For each pair of parts which may intermittently come in contact, supply a subroutine which for any positions of the two parts will determine whether or not they are in contact or interpenetrating. These tasks are both done automatically by my program. 40 A. Gelsey/Art@kd Intelligence 74 (1995) 1-53 These tasks are also addressed by Joskowicz and Sacks [25]. They handle permanent contacts axes and planes of motion, which are then all surface-to-surface in the initial configuration intersected contacts by computing to compute reachable into axes of regions of intermittent spaces, which are two-dimensional. This approach of computing in advance the actual contacts which occur during a simulation. their kinematic analysis by adding a kinematic the behavior of many mechanisms: the behavior of a mechanism is quite different from my approach of they simulator which allows them is not the however, kinematic like an escapement, which requires simulation In [37] contacts by transforming potential kinematic pairs. They handle pairwise configuration the entire set of possible contacts locally computing supplement to simulate adequate sort of detailed dynamic analysis to predict Nakamura and Nakajima I have presented in this article. [28] describe a kinematic pair recognition represented using a feature description each pair of parts in a mechanism program the sets of matching pairs. identifies features a set of matching features and then found in some instantiations program. For the language, looks for the set in a list of of certain common kinematic The handling of intermittent [ 41, Gilmore and Cipra Cremer lators, these researchers to be specified as input constraints, constrained system of equations having proach to intermittent [ 51 and Goyal et al. [ 191, though bodies, not for mechanical devices. contacts in mechanism contacts [ 171 and Conti et al. [ 31. Like the commercial resulting been addressed by simu- require geometric constraints contacts to their programs. They all represent contacts with geometric from permanent simulation as I do in Appendix A; however, each rather than using the constraints equations then simulates using systems of as I do to form an unconstrained fewer degrees of freedom. The “soft contact” sort of ap- in Section 2 has also been used by Cundall rigid in both cases only for sets of unconstrained that I describe None of the above research cited above addresses long-term behavior based on numerical the problem of predicting a ma- simulation output. Long-term behavior chine’s systems, and, prediction is one of the goals of the mathematical in for example, analyses of very abstract models of mechanical [ 1,27,3 11; Section 3 discusses [ 391 describes a program which this approach. Weld detects repeating cycles of processes and produces an aggregate description of the repet- itive behavior. The behavior of the mechanical in this article does into a series of discrete processes, so Weld’s technique does not not easily decompose appear usable clocks may be found theory of dynamical devices described in this context. Forbus et al. [ 1 l] describe a system which does qualitative kinematic for a clock. Their simulation suffers to make ambiguous behavior predictions, simulation liability run, but not whether being qualitative, be constant, which would seem to be the defining characteristic of a clock. for numerical it will run and if so, for how long. Furthermore from a qualitative model’s and thus predicts cannot predict what the period of the clock will be or whether [ 411 and Sacks [ 361 describe controllers intelligent Yip systems. Their systems of physical they do not address execute, and interpret numerical require behavioral models the issue of model creation. Yip’s program can automatically (equations) experiments concerning Hamiltonian simulations as input; plan, systems with two analysis and inherent that the clock may the simulation, it will A. Gelsey/Art@cial Intelligence 74 (1995) 1-53 41 degrees of freedom. Sacks’ program can automatically form a detailed analysis of one- parameter planar ordinary differential equations. Both programs are quite powerful in their domains of expertise, though neither could handle a sixth-order system like the escapement mechanism I present in this article. Forbus and Falkenhainer [ 101 describe an intelligent controller for numerical simu- lations based on Qualitative Process Theory [ 91. Their work emphasizes automatically generating a system’s equations, which may change over time, from a physical model. Their input model is, however, at a considerably higher level than the model of raw physical structure my program uses as input, which would prevent their program from being able to generate a numerical simulation of a device like a clock in which contacts between parts appear and disappear dynamically. This article is mainly based on my dissertation, [ 151. Less detailed descriptions of some of the work described in this article appear in [ 13,14,16]. 5. Limitations and future work Combining my modeling algorithms from Section 2 with the capabilities of the com- mercial mechanical device simulators described in Section 4 would result in a system having a considerably wider range of applicability than either of its components. My dynamics modeling algorithms in Section 2.2 are presently limited to fixed-axis mecha- nisms, while the commercial simulators can’t make use of information about the shape of a machine’s parts, thus imposing a considerable modeling burden on the user, especially for mechanisms with intermittent contacts, as described in Section 4. The commercial simulators can handle complex movable-axis mechanisms, and my algorithms can auto- matically identify both permanent and intermittent contacts, so the two approaches are complementary and remedy each other’s deficiencies. The principal limitation of the long-term behavior prediction algorithms in Section 3 is the form of the approximation function given in Eq. (7). The set of machines whose long-term behavior can be predicted is necessarily limited to those whose behavior (at a set of discrete time points) can be adequately approximated by a function of this form. This limitation is also a strength: a constrained form for the approximation function makes possible the use of more powerful behavior recognition algorithms. An important direction for future work in this area is the investigation of how the set of possible approximations might usefully be expanded without precluding tractable behavior recognition. The question of what generalizations might be useful is probably best answered by pursuing the research in the context of particular tasks like diagnosis of malfunctioning machines or design of new machines. 6. Conclusion Predicting a machine’s behavior is a basic capability for many tasks requiring rea- soning about machines, such as diagnosis of malfunctioning machines, design of new 42 A. Gelsey/Artij?cial Intelligence 74 (1995) I-53 1 Fig. A.I. The position variables xi of the kinematic pairs are functions of the position variables qi of the kinematic subsystems. machines, the following capabilities: and redesign of existing machines. I have described a working program with l automated creation of behavioral models of machines directly from models of their raw physical structure; l intelligent control of the computational experiments needed to reveal a machine’s long-term behavior. The algorithms of a machine’s final output long-term behavior. I present for solving behavior over both short and allow these problems long time periods, and description of the machine’s the automated prediction the program’s expected is a concise qualitative/quantitative Appendix A. Global model for contact forces Contact in a single uniform way, but in this appendix forces between parts may result either from sudden collisions or from steady in Section 2.2.1 pushing of one part by another. The model for contact forces presented the two must treats collisions and pushing temporary kinematic pairs, and be dealt with separately. Pushing collisions take place as new temporary kinematic pairs are formed. Collisions between moving parts are idealized as completely for several reasons of which the most important inelastic. This assumption the concern elements of permanent kinematic pairs is plausible effects of lubrication [ 21. are “special case” momentum colliding parts and between is handled by forming transfers which the damping between A.1. Theory A.l.l. Equations of motion Consider a mechanism in which each moving part forms a permanent kinematic pair with the frame. Each of these kinematic pairs has an associated position variable xi. into At any particular m kinematic in Fig. A.1 the three moving parts have temporarily joined subsystem which has a total of one degree of freedom. the moving parts will group a single degree of freedom. For example, time subsystems into a single kinematic the contacts between each having together them A. Gelsey/Artijcial Intelligence 74 (1995) 1-53 43 Let qj be the position state variable for the jth kinematic subsystem. If the kinematic subsystem has only one moving part, qj will be the position variable for the kinematic pair that part forms with the frame, and if the subsystem has several moving parts, then qj will typically be the position variable of one of the parts; by the definition of kinematic subsystem, the positions of the other moving parts will be determined by qj. Let L be the Lagrangian of the mechanism, the difference between its kinetic energy and its potential energy. The behavior of the mechanism can be modeled by m differential equations of the form where Gj is the jth component of the generalized force. (This is the Lagrungian formulation of classical mechanics, which is equivalent to Newton’s formulation but more convenient for some problems [ 181.) Using the definitions from Section 2.2.1, the Lagrangian of the mechanism is (A.1) and the components of the generalized force are [ 18, p. 191 Gj = c -+ i J Substituting into Eq. (A. 1) and simplifying gives +kixi+&g. ‘dqj J =o which may be rearranged to give - (A.2) (A.3) (A.4) (A.5) which is the desired input form for a numerical simulator. See [ 151 for details of the above derivation. To turn this equation into a useful behavioral model of a mecha- nism requires algorithms for computing xi, dXi/dqj, and d2xi/dd as functions of qj. These algorithms are presented in Section A.2, and are based on the geometrical theory described in Section A.1.3. A. I .2. Collisions At any particular time the elementary subsystems in a mechanism will be grouped into m kinematic subsystems each having a single degree of freedom, the state of the mechanism will be specified by 2m state variables qj and gj, and the behavior of the 44 A. Gelsey/Artijicial Intelligence 74 (I 995) l-53 mechanism will be determined by m equations, an instance of Eq. (AS) m subsystems. for each of the then these When causes into contact, the motion of the mechanism to come to form a new subsystem having a single degree of freedom, and both the set of state variables and the equations of motion will change. For example, the balance, which had been moving comes in contact with the lever, and they begin moving together. two of the m kinematic subsystems may join two kinematic independently, in Fig. 1 (b), subsystems together A new contact begins with a collision. In the rigid-body model considered section, collisions during which the velocity state variables may change variables [ 35,401. The force F between remain constant are assumed to take place within an infinitesimally in this short time interval their values, but the position state is an the colliding subsystems impulsive the time motion for a kinematic force because interval At approaches the integral $+“’ Fdt converges zero. During the collision Eq. (A.4), subsystem, has an additional generalized to a finite nonzero value P as the equation of force term and becomes + kiXi + /$!ss, =Fdx, dqj dqj (A.6) of force F and x,- measures distance in the direction of F. where F is the magnitude Integrating this equation over the time of the collision yields (A.7) where F? is the magnitude of impulse @, using the assumption within an infinitesimally short time remain constant. interval during which that collisions take place state variables the position A. 1.3. Geometry Consider two moving parts in a mechanism which each form kinematic pairs with the fixed frame. If these parts are temporarily to compute the position state variable of one of the pairs from that of the other in order to make use is “2;- of the equations derived dimensional”: situations. implementation projections of three-dimensional it works by analyzing sections. My current it is often necessary in the previous two-dimensional in contact, In this section I will discuss the case of temporary contact between the moving parts of two revolute pairs with parallel axes. I will start with the case in which a corner of a block which of one of the moving parts touches an edge of a block which is a component of the other moving part. In the escapement mechanism discussed in earlier sections, the lever and escape wheel are of this type. the contacts between is a component I will refer to the first moving part as part C (for corner) and to the kinematic pair which it forms with the frame as pair C. The other part is part E (for edge) which is an element of pair E. In the following discussion in which the axis of rotation of revolute pair E coincides with the z-axis, and the axis of rotation I will use a coordinate system A. Gelsey/Artificial Intelligence 74 (1995) I-53 45 .’ I0 .@ \ \ . \ \ \ (-a, 0) a Fig. A.2. A comer in contact with an edge of revolute pair C is parallel to the z-axis and intersects the negative x-axis. The contact between the parts is a line segment parallel to the z-axis. I will discuss the situation as projected on the X-Y plane, and therefore I will refer to the contact as a point, with coordinates ( cx, cy ) . See Fig. A.2. I define the following symbols: a the distance between the axes of the revolute pairs, r the distance from the axis of rotation of C to the point of contact ( cx, cr >, h the shortest distance between the origin and the projection of the edge of part E involved in the contact, Bc the angular orientation of the point of contact (c,, c,,) relative to the axis of rotation of C, on the angle between the edge of E and the horizontal. Using plane geometry and trigonometry, we can then derive the following relations between the positions of the two moving parts (see [ 151 for details): c?, = rsinec, c, =rcos&-a, en = polarztngle( cy, c,) f arccos -- E&1* d& -a COS & r2 - (asin& - h)2’ d2& _,a((r’-h2-a2)sinB~fah(l+sin2BE)) d&z2 (r2 - (asin& - h)*)3/2 ’ (A.8) (A.9) (A.lO) (A.ll) (A.12) (A.13) 46 A. Gelsey/Artijicial Intelligence 74 (I 995) I-53 Algorithm 18. Find new contacts. Until no more interpolation is needed For each active INTERACTOR data structure (Fig. 9) For each pair of interacting primitive solids If Algorithm 9 finds an excessive depth of overlap the state of the system to make the depth acceptable Interpolate Restart this algorithm from the beginning - (A.14) ). (A.15) d& -=1+a dfk c; + c; A.2. Implementation Instead unencountered, After each simulation step, (the model of) their volumes will overlap the machine being simulated will be in state. Therefore moving parts which were separated a new, previously the parts will not, in general, be in perfect before may now be in contact. Actually, in space by some amount, The algorithm contact. for finding new contacts must determine the machine’s state back to the point where the parts first came in contact. See Algorithm 18. the Typically that simulation have occurred. this algorithm will find only one new contact: step. The interpolation the first to occur during any other new contacts the depth of overlap and then interpolate process will “re-separate” A.2.1. Amalgamating kinematic subsystems subsystems implementation, are represented Elementary kinematic (Fig. 7). Kinematic subsystems. are represented by the KINEMATIC SUBSYSTEM subsystems In my current data structure mentary kinematic subsystem may have one of three possible relation type of transient higher pair relation edge of another block, as described pair in the current higher pair is equivalent block outward by the radius of the cylinder and replacing block at its center. Thus the problem of analyzing to the problem of analyzing as directed trees of ele- an elementary kinematic relationships with its parent: either a gear (see Section 2.1) or one of two types of transient higher pair relations. One is that of a corner of a block sliding along the in Section A.1.3. The other type of transient higher is a cylinder sliding along the edge of a block. This the edge of the the cylinder by a corner of a the second type of higher pair reduces to a different higher pair formed by extending the first type, which was discussed in Section A.1.3. implementation A. Gelsey/Artifcial Intelligence 74 (1995) 1-53 4-l Algorithm 19. Amalgamate kinematic subsystems. 1. Use Algorithm 20 to compute relationship data that will not change while the elements of the new transient higher pair remain in contact 2. Initialize the normal vector and contact point to the values returned by Algo- rithm 18 3. Initialize the first and second derivatives by plugging values directly into the derivative formulas in Section A.1.3 the velocity of 4. Compute the new amalgamated kinematic subsystem using Eq. (A.19) The KINEMATIC SUBSYSTEM data structure specifies the type of relationship with the parent and the associated relationship data. For a gear relation, the relationship data is just the gear ratio. For the transient higher pairs, some of the relationship data is constant as long as the pair exists: the parameters a, r, and h (see Section A. 1.3)) (1) whether the child is a rotating line, or a rotating corner or cylinder, (2) the cylinder radius (= 0 for a corner), (3) (4) C offset (& = position state variable - C offset), (5) E offset (en = position state variable - E Offset), (6) coordinates of adjacent corners, (7) coordinates of edge endpoints, the point of contact (c,., cy > (see Section A. 1.3)) and some data changes with every simulation step: ( 1) the normal vector at the point of contact, (2) (3) d( child position) /d( parent position), (4) d2 (child position) /d( parent position) 2. When two separate kinematic subsystems come in contact, my program uses Algo- rithm 19 to amalgamate them into a single subsystem. The unchanging data is computed using Algorithm 20. Kinematic pairs C and E (see Section A.1.3), which previously were elements of disjoint kinematic subsystems, must be linked into a single new sub- system. Since a kinematic subsystem is represented as a directed tree, if both kinematic pairs happen to be children in the trees representing their previous kinematic subsystems, then one of the trees must be reversed using Algorithm 21 so that the child becomes the root of the tree. On the other hand, if either pair is NOT already a child, then there is no reason to reverse a tree. However, if the fixed frame is part of a kinematic subsystem, it must always be the root of the tree, since its position cannot change and thus determines the positions of all the other parts. A new contact begins with a collision. In Section A.1.2, I derived Eq. (A.7), which I restate here (A.16) I define qj, the position state variable for kinematic subsystem j, to be the position state 48 A. Gelsey/Artijicial Intelligence 74 (1995) l-53 Algorithm 20. Find transient higher pair constant data. 1) If either part is fixed then the other is the child-reverse its tree if necessary Else if the rotating corner then it is the child (or cylinder) is not already a child Else if the rotating edge is not already a child then it is the child Else reverse the rotating corner’s tree, making it the root, and make it the child of the rotating edge 2) If the contact finder (Algorithm 18) found a cylinder then store its radius 3) Compute a, r, and h from the current positions of the parts (see Fig. A.2) 4) 8c = polar_angle(contact C offset = position 5) & = polar_angle(normal vector found by Algorithm 9) - 1r/2 point found by Algorithm 9) state variable of C - 8c E offset = position state variable of E - on 6) transform corner and edge coordinates to the coordinate system of Fig. A.2 Algorithm 21. Make elementary kinematic subsystem EKS the root of its tree. 1. 2. then apply this algorithm If EKS has a parent Copy all relationship data from EKS to its parent, which will now become with the following changes: (a) negate the type flag (i.e. line versus corner), to it. its child, (b) d$ment/d&hild = 1/ (d&hild/d+mnt) 7 CC> d*Xpment/d-&ild = -d2nchild/dX~arenJ(dXchildldXparent)3. variable of the elementary kinematic kinematic subsystem j. For the geometry we are considering, subsystem which is the root of the tree representing dx, G = rj ,. X Ilj . Z (A.17) the new contact to the point of contact where r.i is the radius vector from the axis of the kinematic pair in kinematic j which has formed n is the local surface normal impulse P. The sum on the left-hand side of Eq. (A.16) can be computed directly the data in the tree of KINEMATIC SUBSYSTEM instance of Eq. (A. 16) for each of the two colliding law of motion, the other subsystem subsystem found by Algorithm 9, and found by Algorithm 9, which will be the direction of the from data structures. We may write an third subsystems, force on force on one subsystem is F, then the collision and by Newton’s if the collision is -F. A third equation comes from the assumption the two subsystems will be united the collision that the collision into one. If the colliding is inelastic so that after are subsystems A. Gelsey/Amj?cial Intelligence 74 (1995) 1-53 49 Algorithm 22. Reformulate the vector of state variables. state_variable_count := 0 For each elementary kinematic subsystem EKS If EKS does not have a parent then state_variable_vector[ state-variable-count] := state( EKS) increment state_variable_count j and k, then where dqj/dqk is computable from the geometry of the newly amalgamated kinematic subsystem. These three equations can be solved algebraically to compute the three unknown values fi, QF. and 4”;“‘. If qj is the parent in the new amalgamated kinematic subsystem, then (A.18) .after = 4y + 24k q_i _ Lyi dqk 7 ffk dqj 1 where (A.19) (A.20) A.2.2. Simulation Numerical simulation for this model is done by the publicly-available subroutine RKF45 [38], which my program calls once for each simulation time step. RKF45 is passed a vector of state variables specifying the current state of the machine and a pointer to one of my subroutines which it calls to compute the time derivatives of the state variables. RKF45 then returns a new vector of state variables specifying the new state of the system after the time step. If my program finds new contacts using Algorithm 18, then the current set of kine- matic subsystems will be changed using the algorithms in Section A.2.1. In this case, before calling RKF45 it is necessary to reformulate the vector of state variables using Algorithm 22, since the number of state variables will have changed. As I mentioned in Section A.2.1, I define qj, the position state variable for kinematic subsystem j, to be the position state variable of the elementary kinematic subsystem which is the root of the tree representing kinematic subsystem j. RKF45 calls a subroutine in my program which uses Algorithm 23 to compute the time derivatives of the state variables. The time derivatives of the position state variables are just the velocity state variables. The time derivatives of the velocity state variables SO A. Gelsey/Art@cial tntelligence 74 (1995) 1-53 Algorithm 23. Compute For each elementary kinematic subsystem EKS time derivatives of state variables. If EKS does not have a parent time derivative then position := velocity := 0 numerator denominator Apply Algorithm 24 to EKS velocity time derivative := 0 := numerator / denominator state variable of the kinematic subsystem containing i for elementary kinematic subsystem i. Algorithm 24. Recursive computations Let qj be the position If i does not have a parent then dxi/dqj = d’xi/d$ else = 1 1. 2. 3. subsystem kinematic Let elementary Compute Xi from xk using Algorithm 25 Compute dxi/dqj pute dxj/dxk and then setting k be the parent of i by first using either Eq. (A.12) or Eq. (A.14) dxi -_= dqi dxi dXk -- dxk de to com- (A.21) 4. Compute d*xi/d$ by first using either Eq. (A.13) or Eq. (A.15) to compute d*xi/dxi and then setting (A.22) Add r,dz”,# + kixi dq,; ’ dqj + h.d”i@ ’ dq.i ’ to numerator Add Ii (dxi/dqj) 2 to denominator For each CHZLD of elementary kinematic subsystem i Apply this algorithm to CHILD Algorithm 25. Compute position of child from parent. If the child is a moving corner (or cylinder) then compute x; from Xk using Eq. (A.1 1) else compute xi and (c,, cr) from xk using Eqs. (A.8), (A.9), and (A.lO) Choose the value of xi closest to the previous value A. Gelsey/Arti$cial Intelligence 74 (1995) l-53 51 Algorithm 26. Fill in the new nonconstant values. For each elementary kinematic subsystem EKS If EKS does not have a parent then for each CHILD of EKS Apply Algorithm 27 to CHILD Algorithm 27. Recursively fill in the new nonconstant values. 1. Let elementary kinematic subsystem k be the parent of i 2. Compute Xi and ( cx, cy ) from xk using Algorithm 25 3. normal vector := (- sin(&), cos(&)) 4. Compute dXi/dXk from xk using either Eq. (A.12) or E.q. (A.14) 5. Compute d2xi/‘dni using either Eq. (A.13) or Rq. (A.15) are computed from Eq. (AS) by Algorithm 23 (which calls Algorithm 24). Note that all positions and first and second derivatives are recomputed from scratch. This is necessary since when RKF45 calls my time-derivative subroutine it passes a state variable vector for some potential future state of the mechanism, not one that has been seen before. Therefore all other quantities must be recomputed from this new vector. Algorithm 24 uses Algorithm 25 to compute the position of the child subsystem from that of the parent. Since the appropriate equations from Section A.1.3 always give two possible values, Algorithm 25 must choose between them. In the current implementation, this is done by simply choosing whichever of the two values is closer to the value used on the previous step. Since the two values are typically quite far apart, this heuristic works well in practice. The first time this choice is made for a particular transient higher pair, the previous value used as a guide is the one returned by the contact finder and thus is not ambiguous. The correctness of the choice is checked by two other methods; warning messages are printed in case of disagreement. The first of the other methods is to check whether one of the possible choices causes the corner to be past the end of the edge. The second method is to check whether the position change is consistent with the velocity. Often these two methods aren’t able to make a choice, which is why neither is the primary method. RKF45 returns a vector of state variables representing the new state of the machine after the time step. My program then uses Algorithm 26 to fill in the new nonconstant values for every elementary kinematic subsystem. A.2.3. Detecting separation After the state of the machine has advanced by one simulation time step, as described in Section A.2.2, the current set of valid kinematic subsystems may have changed. In Section A.2.1, I discussed the amalgamation of kinematic subsystems after a time step as a result of new contacts detected by Algorithm 18. Configuration changes after a simulation time step may also cause parts to separate which were previously in contact. 52 A. Celsey/Ar@cial Intelligence 74 (199.5) 1-53 Algorithm 28. Separate kinematic subsystems. subsystem EKS For each elementary kinematic EKS has a parent If AND the point of contact between EKS and its parent the endpoints of the edge is not between OR one of the two edges ending at the corner is collinear with the edge that the corner is sliding on then break the contact between EKS and its parent the tree of KINEMATIC SUBSYSTEM In that case, subsystem must be broken kinematic higher pair which is no longer valid. into two separate data structures trees by removing representing the the transient Separation of invalid transient higher pairs is done by applying Algorithm 28 to every subsystem. There are two ways in which a transient higher pair kinematic elementary is sliding along an edge, it may fall off If a corner or a cylinder invalid. may become is sliding along an edge, relative rotation if a comer the end of the edge. Alternatively, contact. the comer-to-edge of the two parts may convert contact immediately Typically, the two parts will still be involving linked by a higher pair, the old higher pair is no longer valid. In this case, Algorithm 28 instantiated, that is deletes to be the old higher pair, and if a new higher pair needs been detected using done in the usual way using Algorithm 19 after the new contact has Algorithm this contact will a different corner and/or edge. Therefore, although into an edge-to-edge into another corner-to-edge contact then turn 18. References III 121 131 1 161 171 Lsl I91 I to1 ( 1992) 563-574. system kinematic analysis system for mechanism design and control, Ph.D. Thesis, Department of Computer Science, Cornell University, simulation, Mechanism Mach. Theory 27 (5) for general purpose physical A.A. Andronov, A.A. Vitt and SE. Khaikin, Theory of Uscillarors (Pergamon Press, Oxford, England, 1966). FP Bowden and D. Tabor, The Friction and Lubrication of Solids (Oxford University Press, London, 19.50). C. Conti, P Corron and l? Michotte, A computer-aided and computer J.F. Cremer, An architecture dynamics, (1989). P.A. Cundall, Formulation and represent contacts Geomech. Abstracts 25 (3) G. Dawson, The dynamic duo: Dram and Adams, Compur. Mech. Eng. (1985). PG. Drazin, Nonlinear Systems (Cambridge University Press, Cambridge, England, 1992). B. Fallahi and K.M. Ragsdell, A compact Mechanisms Transmissions Automation in Design 105 (1983) 434-440. K. Forbus, Qualitative process K.D. Forbus quantitative knowledge, to detect in a system composed of many polyhedral blocks, Inf. J. Rock Mech. Mining Sci. simulations: An in: Proceedings AAAI-90, Boston, MA ( 1990). theory, Artif Intell. 24 (1984) 85-168. analysis, Trans. ASME J. geometry, Ithaca, NY distinct element model-part of a three-dimensional and B. Falkenhainer, to planar kinematic simulation-integrating (1988) 107-l 16. Self-explanatory of qualitative I: a scheme integration approach and A. Gelsey/Artifcial Intelligence 74 (1995) 1-53 53 ] 11 I K.D. Forbus, I? Nielson and B. Faltings, Qualitative spatial reasoning: the CLOCK project, Artif: Intell. 51 (1991) 417-471. [ 121 C.W. Gear, Numerical Initial Value Problems in Ordinary Differential Equations (Prentice-Hall, Englewood Cliffs, NJ, 1971). [ 131 A. Gelsey, Automated reasoning about machine geometry and kinematics, in: Proceedings Third IEEE Conference on Artificial Intelligence Applications, Orlando, FL (1987); also in: D.S. Weld and J. de Kleer, eds., Readings in Qualitative Reasoning about Physical Systems (Morgan Kaufmann, San Mateo, CA, 1990). [ 141 A. Gelsey, Automated physical modeling, in: Proceedings IJCAI-89, Detroit, MI (1989). [ 151 A. Gelsey, Automated reasoning about machines, Ph.D. Thesis, YALEU/CSD/RR#785, Yale University, New Haven, CT ( 1990). [ 161 A. Gelsey, Using intelligently controlled simulation to predict a machine’s long-term behavior, in: Proceedings AAAI-91, Cambridge, MA (1991) 880-887. [ 171 B.J. Gilmom and R.J. Cipra, Simulation of planar dynamic mechanical systems with changing topologies, J. Mech. Design 113 (1991) 70-83. [ 181 H. Goldstein, Classical Mechanics (Addison-Wesley, Reading, MA, 2nd ed., 1980). [ 191 S. Goyal, F.W. Sinden and E.N. Pinson, Simulation of dynamics of rigid bodies I, II, and III, in: Proceedings Pacific-Rim International Conference on Modelling, Simulation and Identification, Vancouver, BC ( 1992). [20] G. Hartquist, Public PADLZ, IEEE Comput. Graph. Appl. ( 1983) 30-31. [21] E.J. Haug, A survey of dynamics software, in: E.J. Haug, ed., Computer Aided Analysis and Optimization of Mechanical System Dynamics ( Springer-Verlag, Berlin, 1984) 24-3 1. [ 221 E.J. Haug, Computer Aided Kinematics and Dynamics of Mechanical Systems, Volume 1: Basic Methods (Allyn and Bacon, Boston, MA, 1989). [23] A.C. Hindmarsh, ODEPACK, a systematized collection of ODE solvers, in: R. Stepleman, editor, Scientt@ Computing: Applications of Mathematics and Computing to the Physical Sciences, IMACS Transactions on Scientific Computation (North-Holland, Amsterdam, 1983) 55-64. [ 241 CM. Hoffmann, Geometric and Solid Modeling: An Introduction (Morgan Kaufmann, San Mateo, CA, 1989). [25] L. Joskowicz and E.P. Sacks, Computational kinematics, Arttf Intell. 51 (1991) 381-416. [26] A.J. Lichtenberg and M.A. Lieberman, Regular and Stochastic Motion (Springer-Verlag, Berlin, 1983). [27] N. Minorsky, Nonlinear Oscillations (D. Van Nostrand, Ptinceton, NJ, 1962). [ 281 A. Nakamura and N. Nakajima, Computer-aided design diagnosis for machines-kinematic model extraction from mechanisms, Mech. Mach. Theory 25 (3) ( 1990) 355-364. [29] N. Orlandea, M.A. Chace and D.A. Calahan, A sparsity-oriented approach to the dynamic analysis and design of mechanical systems, .I. Eng. Industry 99 ( 1977) 773-784, [ 301 B. Paul, Kinematics and Dynamics of Planar Machinery (Prentice-Ha& Englewood Cliffs, NJ, 1979). [ 3 11 A.B. Pippatd, The Physics of Vibration (Cambridge University Press, Cambridge, England, 1978). [ 321 CD. Potter, Mechanism analysis moves with the times, Comput. Graph. World 15 (5) (1992) 30. [33] A.A.G. Requicha, Representations for rigid solids: theory, methods, and systems, ACM Comput. Surv. 12 (1980) 437-464. [ 341 E Reuleaux, The Kinematics of Machinery (Macmillan, London, 1876). [ 351 E.J. Routh, The Elementary Part of a Treatise on the Dynamics of a System of Rigid Bodies (Dover, New York, 1960). [36] E.P. Sacks, Automatic analysis of one-parameter ordinary differential equations by intelligent numeric simulation, Art@ Intell. 48( 1) (1991). [ 371 E.P. Sacks and L. Joskowicz, Automated modeling and kinematic simulation of mechanisms, Cornput- Aided Design 25 (2) (1993) 106-118. [ 381 L.F. Shampine, H.A. Watts and S. Davenport, Solving non-stiff ordinary differential equations-the state of the art, SIAM Rev. 18 ( 1976) 376-411. [ 391 D.S. Weld, The use of aggregation in causal simulation, Artif Intell. 30 (1986) [40] J. Wittenbutg, Dynamics of Systems of Rigid Bodies (Teubner, Stuttgart, Germany, 1977). [ 411 K.M.K. Yip, Understanding complex dynamics by visual and symbolic reasoning, Artif Intell. 51 ( l-3 ) l-34. (1991) 179-221. 