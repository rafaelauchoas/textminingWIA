Artificial Intelligence 170 (2006) 1017–1029www.elsevier.com/locate/artintEvent calculus and temporal action logics comparedErik T. MuellerIBM Thomas J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY 10598, USAReceived 11 November 2005; received in revised form 8 May 2006; accepted 8 May 2006Available online 12 June 2006AbstractWe compare the event calculus and temporal action logics (TAL), two formalisms for reasoning about action and change.We prove that, if the formalisms are restricted to integer time, inertial fluents, and relational fluents, and if TAL action typespecifications are restricted to definite reassignment of a single fluent, then the formalisms are not equivalent. We argue thatequivalence cannot be restored by using more general TAL action type specifications. We prove however that, if the formalisms arefurther restricted to single-step actions, then they are logically equivalent.© 2006 Elsevier B.V. All rights reserved.Keywords: Commonsense reasoning; Reasoning about action and change; Event calculus; Temporal action logics (TAL)1. IntroductionReasoning about action and change is a fundamental area of research within artificial intelligence. This is an im-portant area because action and change are pervasive aspects of the world in which intelligent agents operate. Over theyears, a number of formalisms and frameworks for reasoning about action and change have been developed. Amongthem are the situation calculus [25,33], the event calculus [19,36], features and fluents [34,35], action languages [7–9],and the fluent calculus [12,41,42].Although there has been some cross-pollination, the various formalisms have been developed in relative isolation,and the relationship between them is not always well understood. But understanding the relationship between theformalisms is important for the following reasons:• It helps to advance the field. An understanding of the space of possible formalisms and where each formalism issituated in this space is essential to their refinement.• It enables sharing of reasoning tools. A number of reasoning tools are available, as shown in Table 1. If problemsin one formalism can be translated into another formalism, they can be solved using reasoning tools for the otherformalism.• It enables sharing of problem libraries developed for each of the formalisms and reasoning tools.• It facilitates collaboration. Researchers working using one formalism can understand and build on the results ofresearchers using another formalism.E-mail address: etm@us.ibm.com (E.T. Mueller).0004-3702/$ – see front matter © 2006 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2006.05.0011018E.T. Mueller / Artificial Intelligence 170 (2006) 1017–1029Table 1Tools for reasoning about action and changeFormalismSituation calculusEvent calculusTALC+EFluent calculusToolKM [3]http://www.cs.utexas.edu/users/mfkb/km.htmlEvent calculus planner [39]http://www.iis.ee.ic.ac.uk/~mpsha/planners.htmlDiscrete Event Calculus Reasoner [28]http://decreasoner.sourceforge.net/VITAL [20]http://www.ida.liu.se/~jonkv/vital/CCALC [9,23]http://www.cs.utexas.edu/users/tag/cc/E-RES [14,15]http://www.ucl.ac.uk/~uczcrsm/LanguageE/FLUX [43]http://www.fluxagent.org/Two major streams of research in reasoning about action and change are temporal action logics (TAL) [4–6,21],which has its origins in the features and fluents framework, and the event calculus [29,37]. TAL and the event calculusappear to be similar because they both have characterizations in classical logic and both use linear time. But theirexact relationship has been unclear.In this paper, we compare the event calculus with support for events with duration [26,37] and TAL 1.0 [4,5].1We start by restricting the event calculus and TAL 1.0 to integer time, inertial fluents, and relational fluents. Wefurther restrict TAL 1.0 action type specifications to definite reassignment of a single fluent. We then prove that theserestricted versions are not equivalent. We show that equivalence cannot be restored even if more general TAL actiontype specifications are used. We then further restrict the two formalisms to single-step actions and prove that theseversions are logically equivalent.2. Past workIn the past, four approaches have been used to compare formalisms for reasoning about action and change:(1) Two formalisms are proved to be logically equivalent.(2) A syntactic translation is defined from a domain description in one formalism to a domain description in anotherformalism, and the two domain descriptions are proved to entail the same results. Translations may be providedin one or both directions.(3) Semantic (model theoretic) conditions are defined under which a domain description in one formalism matchesa domain description in another formalism, and matching domain descriptions are proved to entail the sameresults.(4) A general formalism is defined, and formalisms are shown to be special cases of the general formalism.In order to ease comparison, the formalisms are often extended or restricted in various ways.The first approach is used by Kowalski and Sadri [17,18], who consider a version of the event calculus extendedwith branching time, but without concurrent events, continuous change, and release from the commonsense law ofinertia. They show that this version of the event calculus is logically equivalent to a version of the situation calculussimilar to that of Reiter [32]. The first approach is also used by Mueller [27], who proves that, if the domain of thetimepoint sort is restricted to the integers, the continuous event calculus is logically equivalent to a discrete version ofthe event calculus.We use the first approach in this paper.1 We use the variant of TAL 1.0 in which actions are treated as first-class citizens [5, pp. 19–20].E.T. Mueller / Artificial Intelligence 170 (2006) 1017–10291019The second approach is used by a number of researchers. Kartha [16] defines a translation from domain descriptionsof action language A [8] into three versions of the situation calculus [1,30,31]. He asserts that for any sequence ofevents, the A domain description and the situation calculus translations entail the same truth values of fluents.Thielscher [40] restricts A to a single sequence of actions, and restricts ego world semantics [35] to inertial fluents,relational fluents, and single-step actions. He defines a translation from A domain descriptions to ego world semanticsdomain descriptions, and defines a translation from ego world semantics domain descriptions to A domain descrip-tions. He sketches proofs that in both cases, the models of the domain descriptions entail the same event occurrencesand fluent truth values.Giunchiglia and Lifschitz [11] define a translation from unrestricted domain descriptions of action language C [10]into the situation calculus, and define a classical logic translation of the transition semantics of C domain descriptions.They prove that for any domain description, the two translations are logically equivalent. They also define a translationfrom restricted C domain descriptions to TAL domain descriptions, and define another classical logic translation ofthe transition semantics of C domain descriptions. They prove that for any domain description, the first translation isa conservative extension of the second translation.The third approach is used by Miller and Shanahan [26], who consider a version of the E action language [13] anda version of the event calculus without release from the commonsense law of inertia, continuous change, and stateconstraints. They define semantic conditions under which an E domain description matches an event calculus domaindescription. They prove that, if an E domain description matches an event calculus domain description, the domaindescriptions entail the same event occurrences and fluent truth values.The fourth approach is used by Van Belleghem, Denecker, and De Schreye [44], who define a general formalismthat encompasses both the situation calculus and a version of the event calculus without concurrent events, continuouschange, and release from the commonsense law of inertia. They describe how the situation calculus and this versionof the event calculus are obtained by restricting the general formalism.Bennett and Galton [2] define a versatile event logic (VEL) whose semantics includes a number of formalisms fortemporal reasoning, and present ways of describing the situation calculus and the event calculus within VEL. Theyconsider a version of the event calculus without continuous change and release from the commonsense law of inertia.A related approach is that of Sandewall [35], who defines ontological families and the intended models of a do-main description of a given family. The correctness of any particular formalism is then assessed against these formalspecifications.3. The event calculus and TALHow shall we go about proving logical equivalence of the event calculus with events with duration and TAL 1.0?As shown in Table 2, the formalisms do not support the same features. In addition, the formalisms do not addressindirect effects and nondeterministic effects using the same language features. Indirect effects are represented in theevent calculus using causal constraints and effect constraints [38], whereas they are represented in TAL 1.0 usingdependency constraints [5, pp. 16–18]. Nondeterministic effects are represented in the event calculus using determin-ing fluents [37, pp. 419–420], whereas they are represented in TAL 1.0 using disjunctions in reassignment operators[4, pp. 35–36].At this point, we have two choices. We can either extend the formalisms with their missing features, or we canrestrict the formalisms to their common features. We choose the second approach. We disallow causal constraints,continuous change, continuous time, and effect constraints in the event calculus, and we disallow dependency con-straints, disjunctions in reassignment operators, durational fluents, and functional fluents in TAL 1.0.In order to prove logical equivalence, we would like to characterize the event calculus and TAL 1.0 using the sameclassical language. TAL 1.0 domain descriptions are written in a specialized language L(ND) and then translatedinto a classical language L(FL). The important translation rules are provided in Appendix A. Event calculus domaindescriptions are also expressed in a classical language. But TAL 1.0 L(FL) and the event calculus use differentsymbol sets. TAL 1.0 L(FL) uses Holds, Occurs, and Occlude, whereas the event calculus as we have restricted ituses HoldsAt, InitiallyP, InitiallyN, Happens, Initiates, Terminates, Clipped, and Declipped. How shall we reconcilethese two languages?In TAL 1.0, the effects of events are specified using L(ND) action type specifications of the form[τ, τ(cid:2)]α (cid:2) β1020E.T. Mueller / Artificial Intelligence 170 (2006) 1017–1029Table 2Features of the event calculus and TAL 1.0FeatureCausal constraintsConcurrent eventsContext-sensitive effectsContinuous changeContinuous timeDependency constraintsDisjunctions in reassignment operatorsDurational fluentsEffect constraintsEvents with durationFunctional fluentsInertial fluentsState constraintsEvent calculus(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)TAL 1.0(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)where τ and τ (cid:2) are timepoints, α is an action, and β is a formula that specifies the preconditions and postconditionsof α. Postconditions are defined using the R, X, and I reassignment operators. The R operator specifies that a fluentis released from the commonsense law of inertia during a time interval and is constrained to have a particular valueat the end of the interval. The I operator specifies that a fluent is released from the commonsense law of inertiaduring a time interval and is constrained to have a particular value during the interval. The X operator specifies thata fluent is released from the commonsense law of inertia during a time interval. Note that a fluent released from thecommonsense law of inertia by a reassignment operator may be further constrained by other parts of the same actiontype specification or by different axioms such as state constraints.The effects of actions are often2 specified using L(ND) action type specifications of the form[τ, τ(cid:2)]α (cid:2) [τ ]γ → R((τ, τ(cid:2)](¬)β)(1)where τ and τ (cid:2) are timepoints, α is an action, γ is a formula, and β is a fluent. This represents that, if α occurs fromτ to τ (cid:2), and γ is true at τ , then β will be of indeterminate truth value from τ + 1 to τ (cid:2) − 1 inclusive, and will be true(false) starting at τ (cid:2). A specification of this form is translated into an L(FL) formula(cid:2)Occurs(τ, τ, β) ∧ ∀t (τ < t ∧ t (cid:3) τ(2)where γ (cid:2) is the L(FL) translation of [τ ]γ .3 Notice that (2) is logically equivalent to the conjunction of the formulas:, α) → (γ(cid:2) → Occlude(t, β)))(cid:2) → (¬)Holds(τ(cid:2)Occurs(τ, τOccurs(τ, τ(cid:2)(cid:2), α) ∧ γ, α) ∧ γ(cid:2) → (¬)Holds(τ(cid:2) ∧ τ < t ∧ t (cid:3) τ(cid:2), β)(cid:2) → Occlude(t, β)In order to reconcile the two languages, we assume that all TAL 1.0 action type specifications are of the form (1).Given this assumption we show in Sections 4 and 6 that the restricted TAL 1.0 is not equivalent to the restrictedevent calculus. We argue in Section 7 that, even if we relax this assumption and allow more general action typespecifications, we still cannot obtain equivalence.Given this assumption we can express [τ, τ (cid:2)]α (cid:2) [τ ]γ → R((τ, τ (cid:2)]β) as γ (cid:2) → Initiates(α, β, τ ), and [τ, τ (cid:2)]α (cid:2)[τ ]γ → R((τ, τ (cid:2)]¬β) as γ (cid:2) → Terminates(α, β, τ ), just as in the event calculus. We must then add the followingdomain-independent axioms to TAL:Occurs(t1, t2, e) ∧ Initiates(e, f, t1) → Holds(t2, f )Occurs(t1, t2, e) ∧ Terminates(e, f, t1) → ¬Holds(t2, f )(3)(4)2 46 of the 68 unique action type specifications provided with the latest release of VITAL, version 2.999.910 alpha of October 8, 2003, areof this form or can be rewritten as several specifications of this form. 8 specifications are of the form [τ, τ (cid:2)]α (cid:2) [τ ]γ → I ((τ, τ (cid:2)](¬)β) whereβ is a durational fluent, 5 specifications involve R([τ (cid:2)](¬)β), 3 specifications use disjunctions in reassignment operators, and the remaining6 specifications use other combinations of reassignment operators. Current TAL domains are more complex, but have not yet been added to VITAL.3 For example, the L(FL) translation of [τ ] β1 ∧ ¬β2 is Holds(τ, β1) ∧ ¬Holds(τ, β2). See Appendix A for more details.E.T. Mueller / Artificial Intelligence 170 (2006) 1017–10291021(Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e) ∧ t1 < t ∧ t (cid:3) t2 → Occlude(t, f )(5)Furthermore, we treat the TAL 1.0 L(FL) predicates Holds(t, f ), Occurs(t1, t2, e), and Occlude(t, f ), and theevent calculus predicates InitiallyP(f ), InitiallyN(f ), Clipped(t1, f, t2), and Declipped(t1, f, t2) as abbreviations.We use a many-sorted language with equality, with sorts for events, fluents, and timepoints. The domain of thetimepoint sort is the integers. The language has the following predicates:• HoldsAt(f, t): Fluent f is true at timepoint t.• Happens3(e, t1, t2): Event e occurs from timepoint t1 to timepoint t2.• Initiates(e, f, t1): If event e occurs from timepoint t1 to timepoint t2, then fluent f will be true after t2.• Terminates(e, f, t1): If event e occurs from timepoint t1 to timepoint t2, then fluent f will be false after t2.3.1. TALA axiomatizationWe use the following axiomatization of the restricted TAL 1.0, which we call TALA. We start with definitions ofHolds and Occurs.TALA1 Holds(t, f )TALA2 Occurs(t1, t2, e)def≡ HoldsAt(f, t)def≡ Happens3(e, t1, t2 − 1)Note the difference in the ending timepoint t2 between Occurs and Happens3.TAL uses circumscription [22,24] of the Occlude and Occurs predicates [21, p. 26], just as the event calculususes circumscription of Initiates, Terminates, and Happens [37, p. 417]. We continue with a definition based onthe circumscription of Occlude in (5). We compute the circumscription using Proposition 2 of Lifschitz [22], whichreduces circumscription to predicate completion.TALA3 Occlude(t, f )def≡ ∃e, t1, t2 ((Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e) ∧ t1 < t ∧ t (cid:3) t2)The TAL 1.0 nochange axiom ¬Occlude(t + 1, f ) → (Holds(t + 1, f ) ↔ Holds(t, f )) [4, p. 30] is logically equiva-lent to the conjunction of the axioms TALA4 and TALA5.TALA4 Holds(t, f ) ∧ ¬Occlude(t + 1, f ) → Holds(t + 1, f )TALA5 ¬Holds(t, f ) ∧ ¬Occlude(t + 1, f ) → ¬Holds(t + 1, f )We continue with formulas (3) and (4).TALA6 Occurs(t1, t2, e) ∧ Initiates(e, f, t1) → Holds(t2, f )TALA7 Occurs(t1, t2, e) ∧ Terminates(e, f, t1) → ¬Holds(t2, f )We finish with a constraint on the starting and ending timepoints of an event occurrence.TALA8 Occurs(t1, t2, e) → t1 < t2Let TALA be the formula generated by conjoining axioms TALA4 through TALA8 and then expanding the predicatesHolds, Occurs, and Occlude using definitions TALA1 through TALA3.3.2. ECA axiomatizationThere are two versions of the event calculus that support events with duration [26,37]. Both are candidates forequivalence with TAL 1.0. We start by using the following axiomatization of the event calculus. It is obtained fromthe version of the event calculus of Shanahan [37, p. 416] by eliminating Releases, and replacing InitiallyP, InitiallyN,Clipped, and Declipped with definitions.1022E.T. Mueller / Artificial Intelligence 170 (2006) 1017–1029ECA1 InitiallyP(f )ECA2 InitiallyN(f )def≡ HoldsAt(f, 0)def≡ ¬HoldsAt(f, 0)def≡ ∃e, t2, t3 (Happens3(e, t2, t3) ∧ t1 < t3 ∧ t2 < t4 ∧ Terminates(e, f, t2))def≡ ∃e, t2, t3 (Happens3(e, t2, t3) ∧ t1 < t3 ∧ t2 < t4 ∧ Initiates(e, f, t2))ECA3 Clipped(t1, f, t4)ECA4 Declipped(t1, f, t4)ECA5 InitiallyP(f ) ∧ ¬Clipped(0, f, t) → HoldsAt(f, t)ECA6 InitiallyN(f ) ∧ ¬Declipped(0, f, t) → ¬HoldsAt(f, t)ECA7 Happens3(e, t1, t2) ∧ Initiates(e, f, t1) ∧ t2 < t3 ∧ ¬Clipped(t1, f, t3) → HoldsAt(f, t3)ECA8 Happens3(e, t1, t2) ∧ Terminates(e, f, t1) ∧ t2 < t3 ∧ ¬Declipped(t1, f, t3) → ¬HoldsAt(f, t3)ECA9 Happens3(e, t1, t2) → t1 (cid:3) t2Let ECA be the formula generated by conjoining axioms ECA5 through ECA9 and then expanding the predicatesInitiallyP, InitiallyN, Clipped, and Declipped using definitions ECA1 through ECA4.We can now proceed to our first result.4. Lack of equivalence between TALA and ECAIn this section, we expose two differences between TALA and ECA. The first difference involves an occurrenceof an event that initiates a fluent, followed by another occurrence of an event that initiates the same fluent. In TALA,the fluent is of indeterminate truth value within the durations of both event occurrences, whereas in ECA, it is onlyof indeterminate truth value within the duration of the first event occurrence. Within the duration of the second eventoccurrence, the fluent is true, because it was previously initiated and has not been clipped.Theorem 1. TALA (cid:10)|= ECA.Proof. Consider the following structure S:Initiates = {(cid:11)I, F, 1(cid:12), (cid:11)I, F, 4(cid:12)}Terminates = ∅Happens3 = {(cid:11)I, 1, 2(cid:12), (cid:11)I, 4, 5(cid:12)}HoldsAt = {(cid:11)F, 3(cid:12), (cid:11)F, 4(cid:12), (cid:11)F, 6(cid:12), (cid:11)F, 7(cid:12), (cid:11)F, 8(cid:12), . . .}(6)(7)(8)(9)We can show S |= TALA but S (cid:10)|= ECA. It is straightforward to verify S |= TALA. In order to show S (cid:10)|= ECA, it issufficient to show S (cid:10)|= ECA7. Moreover, we need only showS (cid:10)|= Happens3(I, 1, 2) ∧ Initiates(I, F, 1) ∧ 2 < 5 ∧ ¬Clipped(1, F, 5) → HoldsAt(F, 5)(10)From (7), we haveS |= ¬∃e, t2, t3(Happens3(e, t2, t3) ∧ 1 < t3 ∧ t2 < 5 ∧ Terminates(e, F, t2))From this and definition ECA3, we have S |= ¬Clipped(1, F, 5). From this, (8), and (6), we haveS |= Happens3(I, 1, 2) ∧ Initiates(I, F, 1) ∧ 2 < 5 ∧ ¬Clipped(1, F, 5)But from (9), we have S |= ¬HoldsAt(F, 5). Therefore, we have (10). (cid:3)The second difference between TALA and ECA involves an occurrence of an event that initiates a fluent, whichoverlaps in time an occurrence of an event that terminates the same fluent. In TALA, the fluent is true at the end ofthe initiating event occurrence, whereas in ECA, the fluent is of indeterminate truth value at the end of the initiatingevent occurrence.Theorem 2. ECA (cid:10)|= TALA.E.T. Mueller / Artificial Intelligence 170 (2006) 1017–1029Proof. Consider the following structure S:Initiates = {(cid:11)I, F, 1(cid:12)}Terminates = {(cid:11)T, F, 2(cid:12)}Happens3 = {(cid:11)I, 1, 2(cid:12), (cid:11)T, 2, 3(cid:12)}HoldsAt = ∅1023(11)(12)(13)(14)We can show S |= ECA but S (cid:10)|= TALA. It is straightforward to verify S |= ECA. In order to show S (cid:10)|= TALA, it issufficient to show S (cid:10)|= TALA6. Furthermore, we need only showS (cid:10)|= Occurs(1, 3, I ) ∧ Initiates(I, F, 1) → Holds(3, F )(15)From (13), definition TALA2, and (11), we have Occurs(1, 3, I ) ∧ Initiates(I, F, 1). But from (14) and definitionTALA1, we have S |= ¬Holds(3, F ). Therefore, we have (15). (cid:3)Thus we have lack of equivalence.Corollary 3. TALA is not logically equivalent to ECA.Proof. This follows from either Theorem 1 or Theorem 2. (cid:3)5. ECB axiomatizationA second axiomatization of the event calculus that supports events with duration is provided by Miller and Shana-han [26, pp. 470–471]. After rewriting it in the style of ECA, it is as follows.def≡ ∃e, t2, t3(Happens3(e, t2, t3) ∧ t1 (cid:3) t3 ∧ t2 < t4 ∧ Terminates(e, f, t2))def≡ ∃e, t2, t3(Happens3(e, t2, t3) ∧ t1 (cid:3) t3 ∧ t2 < t4 ∧ Initiates(e, f, t2))def≡ ∃e, t2, t3(Happens3(e, t2, t3) ∧ t1 < t3 ∧ t2 < t4 ∧ Terminates(e, f, t2))def≡ ∃e, t2, t3(Happens3(e, t2, t3) ∧ t1 < t3 ∧ t2 < t4 ∧ Initiates(e, f, t2))ECB1 Clipped(cid:2)(t1, f, t4)ECB2 Declipped(cid:2)(t1, f, t4)ECB3 Clipped(t1, f, t4)ECB4 Declipped(t1, f, t4)ECB5 HoldsAt(f, t1) ∧ t1 < t2 ∧ ¬Clipped(cid:2)(t1, f, t2) → HoldsAt(f, t2)ECB6 ¬HoldsAt(f, t1) ∧ t1 < t2 ∧ ¬Declipped(cid:2)(t1, f, t2) → ¬HoldsAt(f, t2)ECB7 Happens3(e, t1, t2) ∧ Initiates(e, f, t1) ∧ t2 < t3 ∧ ¬Clipped(t1, f, t3) → HoldsAt(f, t3)ECB8 Happens3(e, t1, t2) ∧ Terminates(e, f, t1) ∧ t2 < t3 ∧ ¬Declipped(t1, f, t3) → ¬HoldsAt(f, t3)ECB9 Happens3(e, t1, t2) → t1 (cid:3) t2ECB differs from ECA in the following ways:• It eliminates the definitions of InitiallyP and InitiallyN.• It add definitions of Clipped(cid:2) and Declipped(cid:2).• It adds the axioms of inertia ECB5 and ECB6.Let ECB be the formula generated by conjoining axioms ECB5 through ECB9 and then expanding the predicatesClipped(cid:2), Declipped(cid:2), Clipped, and Declipped using definitions ECB1 through ECB4.We then have our second result.6. Lack of equivalence between TALA and ECBECB is not equivalent to TALA, for the two reasons previously given for ECA, as well as the following reason.Consider a single occurrence of an event that initiates a fluent. Within the duration of the event occurrence, the fluentis of indeterminate truth value in TALA, whereas in ECB a fluent that is true persists in each model because of the1024E.T. Mueller / Artificial Intelligence 170 (2006) 1017–1029frame axiom ECB5. That is, if in a given model the fluent is true at any given timepoint within an event occurrence,then it is true for all remaining timepoints within the event occurrence.Theorem 4. TALA (cid:10)|= ECB.Proof. Consider the following structure S:(16)(17)(18)Initiates = {(cid:11)I, F, 1(cid:12)}Terminates = ∅Happens3 = {(cid:11)I, 1, 3(cid:12)}HoldsAt = {(cid:11)F, 2(cid:12), (cid:11)F, 4(cid:12), (cid:11)F, 5(cid:12), (cid:11)F, 6(cid:12), . . .}(19)We can show S |= TALA but S (cid:10)|= ECB. It is straightforward to verify S |= TALA. In order to show S (cid:10)|= ECB, it issufficient to show S (cid:10)|= ECB5. Moreover, we need only showS (cid:10)|= HoldsAt(F, 2) ∧ 2 < 3 ∧ ¬Clipped(cid:2)(2, F, 3) → HoldsAt(F, 3)(20)From (17), we haveS |= ¬∃e, t2, t3(Happens3(e, t2, t3) ∧ 2 (cid:3) t3 ∧ t2 < 3 ∧ Terminates(e, F, t2))From this and definition ECB1, we have S |= ¬Clipped(cid:2)(2, F, 3). From this and (19), we haveS |= HoldsAt(F, 2) ∧ 2 < 3 ∧ ¬Clipped(cid:2)(2, F, 3)But from (19), we have S |= ¬HoldsAt(F, 3). Therefore, we have (20). (cid:3)Corollary 5. TALA is not logically equivalent to ECB.Proof. This follows from Theorem 4. (cid:3)7. General action type specificationsWe have shown that, if TAL action type specifications are of the form (1), then TAL and the event calculus arenot equivalent. What if we use a more general form of action type specification? Can we restore equivalence with theevent calculus?The answer is no. It is sufficient to show that the difference highlighted in the proof of Theorem 2 cannot be erased.ECA7 (as well as ECB7, which is identical) entails that, if a fluent is not clipped during an event occurrence thatinitiates the fluent, then the fluent is true at the end of the event occurrence. Action type specifications of the form (1)entail that the fluent is always true at the end of the event. We would like to add to the action type specification thecondition that the fluent is not clipped:[t1, t2]I (cid:2) ¬∃t3, t4[[t3, t4]T ∧ t1 < t4 − 1 ∧ t3 < t2] → R([t2]F )(I and T are actions, and F is a fluent.) Unfortunately, the consequent of an action type specification cannot containaction occurrence statements such as [t3, t4]T [4, p. 28].The underlying difficulty is that TAL does not have the notions of clipped and declipped. In order for TAL toemulate the event calculus with events with duration, it would have to be extended with these notions.8. Restriction to single-step actionsWe now consider what happens if we restrict TAL and the event calculus to single-step actions. We add TALA9 toTALA:TALA1 Holds(t, f )TALA2 Occurs(t1, t2, e)def≡ HoldsAt(f, t)def≡ Happens3(e, t1, t2 − 1)E.T. Mueller / Artificial Intelligence 170 (2006) 1017–10291025def≡ ∃e, t1, t2((Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e) ∧ t1 < t ∧ t (cid:3) t2)TALA3 Occlude(t, f )TALA4 Holds(t, f ) ∧ ¬Occlude(t + 1, f ) → Holds(t + 1, f )TALA5 ¬Holds(t, f ) ∧ ¬Occlude(t + 1, f ) → ¬Holds(t + 1, f )TALA6 Occurs(t1, t2, e) ∧ Initiates(e, f, t1) → Holds(t2, f )TALA7 Occurs(t1, t2, e) ∧ Terminates(e, f, t1) → ¬Holds(t2, f )TALA8 Occurs(t1, t2, e) → t1 < t2TALA9 Occurs(t1, t2, e) → t2 = t1 + 1Let TALAS be the formula generated by conjoining axioms TALA4 through TALA9 and then expanding the predicatesHolds, Occurs, and Occlude using definitions TALA1 through TALA3.For single-step actions, the version of the event calculus that appears to be the most similar to TAL is the discreteevent calculus (DEC) [27,29]. DEC was developed to improve the efficiency of automated reasoning in the eventcalculus. It improves efficiency by limiting time to the integers, and eliminating triply quantified time from manyof the axioms. Mueller [27] proves that, for integer time and single-step events, DEC is logically equivalent to anextended version of ECB [26].The following axiomatization is obtained from the full version of DEC by eliminating Trajectory, AntiTrajectory,Releases, and ReleasedAt.def≡ Happens3(e, t, t)DECA1 Happens(e, t)DECA2 HoldsAt(f, t) ∧ ¬∃e(Happens(e, t) ∧ Terminates(e, f, t)) → HoldsAt(f, t + 1)DECA3 ¬HoldsAt(f, t) ∧ ¬∃e(Happens(e, t) ∧ Initiates(e, f, t)) → ¬HoldsAt(f, t + 1)DECA4 Happens(e, t) ∧ Initiates(e, f, t) → HoldsAt(f, t + 1)DECA5 Happens(e, t) ∧ Terminates(e, f, t) → ¬HoldsAt(f, t + 1)DECA6 Happens3(e, t1, t2) → t1 = t2Let DECA be the formula generated by conjoining axioms DECA2 through DECA6 and then expanding the predicateHappens using definition DECA1.We then obtain our final result.9. Equivalence of TALAS and DECAWe can show that TALAS and DECA are logically equivalent. First, we prove a number of lemmas.Lemma 6. TALAS |= DECA2.Proof. Suppose TALAS. Let f be an arbitrary fluent and t be an arbitrary timepoint. We must show HoldsAt(f, t) ∧¬∃e(Happens(e, t) ∧ Terminates(e, f, t)) → HoldsAt(f, t + 1). SupposeHoldsAt(f, t)¬∃e(Happens(e, t) ∧ Terminates(e, f, t))(21)(22)We consider two cases.Case 1: ∃e(Happens(e, t) ∧ Initiates(e, f, t)).From definition DECA1, TALA2, and existential instantiation, we get Occurs(t, t + 1, E) ∧ Initiates(E, f, t) forsome E. From this, TALA6, and TALA1, we have HoldsAt(f, t + 1), as required.Case 2: ¬∃e(Happens(e, t) ∧ Initiates(e, f, t)).From (22), definition DECA1, and TALA2, we get¬∃e((Initiates(e, f, t) ∨ Terminates(e, f, t)) ∧ Occurs(t, t + 1, e))Therefore,t1 = t ∧ t2 = t1 + 1 → ¬((Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e))(23)1026E.T. Mueller / Artificial Intelligence 170 (2006) 1017–1029From TALA9, by contraposition, we get t2 (cid:10)= t1 + 1 → ¬Occurs(t1, t2, e). Hence,t2 (cid:10)= t1 + 1 → ¬((Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e))From this and (23), we havet2 (cid:10)= t1 + 1 ∨ t1 = t → ¬((Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e))We can showt1 < t + 1 ∧ t + 1 (cid:3) t2 → t2 (cid:10)= t1 + 1 ∨ t1 = twhich is logically equivalent to t1 < t + 1 ∧ t + 1 (cid:3) t2 ∧ t2 = t1 + 1 → t1 = t. To see this, supposet1 < t + 1t + 1 (cid:3) t2t2 = t1 + 1(24)(25)(26)(27)(28)From (27) and (28), we get t (cid:3) t1. From this and (26), we have t1 = t, as required.From (25) and (24), we havet1 < t + 1 ∧ t + 1 (cid:3) t2 → ¬((Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e))(29)From this and TALA3, we get ¬Occlude(t + 1, f ). From this, (21), TALA1, and TALA4, we have HoldsAt(f, t + 1),as required. (cid:3)Lemma 7. TALAS |= DECA3.Proof. The proof is identical to that of Lemma 6, except that ¬HoldsAt is substituted for HoldsAt, Initiates andTerminates are swapped, TALA7 is substituted for TALA6, and TALA5 is substituted for TALA4. (cid:3)Lemma 8. TALAS |= DECA4.Proof. Suppose TALAS. Let e be an arbitrary event, f be an arbitrary fluent, and t be an arbitrary timepoint. Wemust show Happens(e, t) ∧ Initiates(e, f, t) → HoldsAt(f, t + 1). Suppose Happens(e, t) ∧ Initiates(e, f, t). FromHappens(e, t), definition DECA1, and TALA2, we get Occurs(t, t + 1, e). From this, Initiates(e, f, t), TALA6, andTALA1, we have HoldsAt(f, t + 1). (cid:3)Lemma 9. TALAS |= DECA5.Proof. The proof is identical to that of Lemma 8, except that ¬HoldsAt is substituted for HoldsAt, Terminates issubstituted for Initiates, and TALA7 is substituted for TALA6. (cid:3)Lemma 10. TALAS |= DECA6.Proof. This follows from TALA9 and TALA2. (cid:3)Now we consider the other direction.Lemma 11. DECA |= TALA4.Proof. Suppose DECA. Let f be an arbitrary fluent and t be an arbitrary timepoint. We must show Holds(t, f ) ∧¬Occlude(t + 1, f ) → Holds(t + 1, f ). SupposeHolds(t, f )¬Occlude(t + 1, f )(30)(31)E.T. Mueller / Artificial Intelligence 170 (2006) 1017–10291027From (31) and definition TALA3, we have¬∃e, t1, t2((Initiates(e, f, t1) ∨ Terminates(e, f, t1)) ∧ Occurs(t1, t2, e) ∧ t1 < t + 1 ∧ t + 1 (cid:3) t2)Hence, ¬∃e(Terminates(e, f, t) ∧ Occurs(t, t + 1, e)). From this, definition TALA2, and DECA1, we get ¬∃e(Happens(e, t) ∧ Terminates(e, f, t)). From this, (30), definition TALA1, and DECA2, we have Holds(t + 1, f ),as required. (cid:3)Lemma 12. DECA |= TALA5.Proof. The proof is identical to that of Lemma 11, except that ¬Holds is substituted for Holds, Initiates andTerminates are swapped, and DECA3 is substituted for DECA2. (cid:3)Lemma 13. DECA |= TALA6.Proof. Suppose DECA. Let e be an arbitrary event, f be an arbitrary fluent, and t1 and t2 be arbitrary timepoints. Wemust show Occurs(t1, t2, e) ∧ Initiates(e, f, t1) → Holds(t2, f ). Suppose Occurs(t1, t2, e) ∧ Initiates(e, f, t1). FromOccurs(t1, t2, e) and definition TALA2, we have Happens3(e, t1, t2 − 1). From this and DECA6, we get t2 = t1 + 1.From this, Happens3(e, t1, t2 − 1), and DECA1, we have Happens(e, t1). From this, Initiates(e, f, t1), DECA4, anddefinition TALA1, we get Holds(t1 + 1, f ). From this and t2 = t1 + 1, we have Holds(t2, f ). (cid:3)Lemma 14. DECA |= TALA7.Proof. The proof is identical to that of Lemma 13, except that ¬Holds is substituted for Holds, Terminates is substi-tuted for Initiates, and DECA5 is substituted for DECA4. (cid:3)Lemma 15. DECA |= TALA8.Proof. This follows from definition TALA2 and DECA6. (cid:3)Lemma 16. DECA |= TALA9.Proof. This follows from definition TALA2 and DECA6. (cid:3)Now we proceed to the equivalence theorem.Theorem 17. TALAS is logically equivalent to DECA.Proof. We prove the two directions separately.(TALAS |= DECA) Suppose TALAS. Then DECA2, DECA3, DECA4, DECA5, and DECA6 follow from Lem-mas 6, 7, 8, 9, and 10, respectively.(DECA |= TALAS) Suppose DECA. Then TALA4, TALA5, TALA6, TALA7, TALA8, and TALA9 follow fromLemmas 11, 12, 13, 14, 15, and 16, respectively. (cid:3)10. ConclusionsWe have investigated the relationship between the event calculus and TAL. We started by restricting both for-malisms to their common features, and found that the resulting versions of the formalisms are not equivalent. Wethen further restricted the event calculus and TAL to single-step actions, and proved that these versions are logicallyequivalent.Some areas for further work are the following:• Lesser restrictions than the restriction to single-step actions could be explored. It may be possible to show a formof equivalence between TAL and the event calculus with events with duration if there are no overlapping events.1028E.T. Mueller / Artificial Intelligence 170 (2006) 1017–1029• Hybrids of the event calculus and TAL could be created.• The relationships between other pairs of formalisms for reasoning about action and change could be explored.Correspondences could be developed between the event calculus and action language C+, and between the situa-tion calculus and temporal action logics.AcknowledgementsI am grateful to three anonymous referees for helpful suggestions.Appendix A. Translation from TAL 1.0 L(ND) to L(FL)The important translation rules from TAL 1.0 L(ND) to L(FL) are as follows [5, pp. 6–9]:• If α is an action occurrence statement, then Trans(α (cid:2) β) = Trans(α) → Trans(β). If disjunction (∨) is usedin β, it must be in the scope of an R, I , or X reassignment operator so that circumscription of Occlude can becomputed using predicate completion [22].• If α is an action, then Trans([τ, τ (cid:2)]α) = Occurs(τ, τ (cid:2), α).• Trans(R((τ, τ (cid:2)] α)) = Trans(X((τ, τ (cid:2)]α) ∧ [τ (cid:2)]α).• Trans(R([τ ]α)) = Trans(X([τ ]α) ∧ [τ ]α).• Trans(I ((τ, τ (cid:2)]α)) = Trans(X((τ, τ (cid:2)]α) ∧ (τ, τ (cid:2)]α).• Trans(X((τ, τ (cid:2)]α)) = ∀t (τ < t ∧ t (cid:3) τ (cid:2) → Trans(X([t]α))).• Trans(X([τ ]¬α)) = Trans(X([τ ]α)).• If ⊗ ∈ {∧, ∨, →, ↔}, then Trans(X([τ ]α ⊗ β)) = Trans(X([τ ]α)) ∧ Trans(X([τ ]β)).• If Q ∈ {∃, ∀}, then Trans(X([τ ]Qν[α])) = Qν(Trans(X([τ ]α))).• If α is a fluent, then Trans(X([τ ]α)) = Occlude(τ, α).• Trans([τ ]¬α) = ¬Trans([τ ]α).• If ⊗ ∈ {∧, ∨, →, ↔}, then Trans([τ ]α ⊗ β) = Trans([τ ]α) ⊗ Trans([τ ]β).• If Q ∈ {∃, ∀}, then Trans([τ ]Qν[α]) = Qν(Trans([τ ]α)).• If α is a fluent, then Trans([τ ]α) = Holds(τ, α).References[1] A.B. Baker, Nonmonotonic reasoning in the framework of situation calculus, Artificial Intelligence 49 (1–3) (1991) 5–23.[2] B. Bennett, A.P. Galton, A unifying semantics for time and events, Artificial Intelligence 153 (1–2) (2004) 13–48.[3] P. Clark, B. Porter, KM—The Knowledge Machine 1.4.0: KM’s situation mechanism, Department of Computer Science, University of Texasat Austin, Austin, TX, 2000.+[4] P. Doherty, PMON: A fluent logic for action and change, Formal specification, version 1.0, Technical Report LiTH-IDA-R-96-33, Depart-ment of Computer and Information Science, Linköping University, Linköping, Sweden, 1996.[5] P. Doherty, J. Gustafsson, L. Karlsson, J. Kvarnström, TAL: Temporal Action Logics language specification and tutorial, Linköping ElectronicArticles in Computer and Information Science 3 (015) (1998).[6] P. Doherty, W. Łukaszewicz, Circumscribing features and fluents, in: D.M. Gabbay, H.J. Ohlbach (Eds.), Temporal Logic, in: Lecture Notesin Computer Science, vol. 827, Springer, Berlin, 1994, pp. 82–100.[7] R.E. Fikes, N.J. Nilsson, STRIPS: A new approach to the application of theorem proving to problem solving, Artificial Intelligence 2 (1971)189–208.[8] M. Gelfond, V. Lifschitz, Representing action and change by logic programs, Journal of Logic Programming 17 (2–4) (1993) 301–321.[9] E. Giunchiglia, J. Lee, V. Lifschitz, N.C. McCain, H. Turner, Nonmonotonic causal theories, Artificial Intelligence 153 (2004) 49–104.[10] E. Giunchiglia, V. Lifschitz, An action language based on causal explanation: Preliminary report, in: Proceedings of the Fifteenth NationalConference on Artificial Intelligence and Tenth Conference on Innovative Applications of Artificial Intelligence, AAAI Press, Menlo Park,CA, 1998, pp. 623–630.[11] E. Giunchiglia, V. Lifschitz, Action languages, temporal action logics and the situation calculus, Linköping Electronic Articles in Computerand Information Science 4 (040) (1999).[12] S. Hölldobler, J. Schneeberger, A new deductive approach to planning, New Generation Computing 8 (3) (1990) 225–244.[13] A.C. Kakas, R. Miller, A simple declarative language for describing narratives with actions, Journal of Logic Programming 31 (1–3) (1997)157–200.[14] A.C. Kakas, R. Miller, F. Toni, An argumentation framework for reasoning about actions and change, in: M. Gelfond, N. Leone, G. Pfeifer(Eds.), Proceedings of the Fifth International Conference on Logic Programming and Nonmonotonic Reasoning, in: Lecture Notes in Com-puter Science, vol. 1730, Springer, Berlin, 1999, pp. 78–91.E.T. Mueller / Artificial Intelligence 170 (2006) 1017–10291029[15] A.C. Kakas, R. Miller, F. Toni, E-RES—A system for reasoning about actions, events and observations, in: Proceedings of the Eighth Interna-tional Workshop on Non-Monotonic Reasoning, 2000.[16] G. Neelakantan Kartha, Soundness and completeness theorems for three formalizations of action, in: R. Bajcsy (Ed.), Proceedings of theThirteenth International Joint Conference on Artificial Intelligence, Morgan Kaufmann, San Mateo, CA, 1993, pp. 724–729.[17] R.A. Kowalski, F. Sadri, The situation calculus and event calculus compared, in: M. Bruynooghe (Ed.), Logic Programming: The 1994International Symposium, MIT Press, Cambridge, MA, 1994, pp. 539–553.[18] R.A. Kowalski, F. Sadri, Reconciling the event calculus with the situation calculus, Journal of Logic Programming 31 (1–3) (1997) 39–58.[19] R.A. Kowalski, M.J. Sergot, A logic-based calculus of events, New Generation Computing 4 (1) (1986) 67–95.[20] J. Kvarnström, VITAL: Visualization and implementation of temporal action logic, Department of Computer and Information Science,Linköping University, Linköping, Sweden, 2001.[21] J. Kvarnström, TALplanner and other extensions to temporal action logic, PhD thesis, Department of Computer and Information Science,Linköping University, Linköping, Sweden, 2005.[22] V. Lifschitz, Circumscription, in: D.M. Gabbay, C.J. Hogger, J.A. Robinson (Eds.), Handbook of Logic in Artificial Intelligence and LogicProgramming, vol. 3: Nonmonotonic Reasoning and Uncertain Reasoning, Oxford University Press, Oxford, 1994, pp. 298–352.[23] N.C. McCain, Causality in commonsense reasoning about actions, Technical Report CS-TR-97-25, Department of Computer Sciences, Uni-versity of Texas at Austin, Austin, TX, 1997.[24] J. McCarthy, Circumscription—a form of non-monotonic reasoning, Artificial Intelligence 13 (1–2) (1980) 27–39.[25] J. McCarthy, P.J. Hayes, Some philosophical problems from the standpoint of artificial intelligence, in: B. Meltzer, D. Michie (Eds.), MachineIntelligence 4, Edinburgh University Press, Edinburgh, 1969, pp. 463–502.[26] R. Miller, M. Shanahan, Some alternative formulations of the event calculus, in: A.C. Kakas, F. Sadri (Eds.), Computational Logic: LogicProgramming and Beyond: Essays in Honour of Robert A. Kowalski, Part II, in: Lecture Notes in Computer Science, vol. 2408, Springer,Berlin, 2002, pp. 452–490.[27] E.T. Mueller, Event calculus reasoning through satisfiability, Journal of Logic and Computation 14 (5) (2004) 703–730.[28] E.T. Mueller, A tool for satisfiability-based commonsense reasoning in the event calculus, in: V. Barr, Z. Markov (Eds.), Proceedings of theSeventeenth International Florida Artificial Intelligence Research Society Conference, AAAI Press, Menlo Park, CA, 2004, pp. 147–152.[29] E.T. Mueller, Commonsense Reasoning, Morgan Kaufmann, San Francisco, CA, 2006.[30] E.P.D. Pednault, ADL: Exploring the middle ground between STRIPS and the situation calculus, in: R.J. Brachman, H.J. Levesque, R. Reiter(Eds.), Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning, Morgan Kaufmann, SanMateo, CA, 1989, pp. 324–332.[31] R. Reiter, The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression, in:V. Lifschitz (Ed.), Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, Academic Press, SanDiego, CA, 1991, pp. 359–380.[32] R. Reiter, Proving properties of states in the situation calculus, Artificial Intelligence 64 (2) (1993) 337–351.[33] R. Reiter, Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems, MIT Press, Cambridge, MA,2001.[34] E. Sandewall, Filter preferential entailment for the logic of action in almost continuous worlds, in: N.S. Sridharan (Ed.), Proceedings of theEleventh International Joint Conference on Artificial Intelligence, Morgan Kaufmann, San Mateo, CA, 1989, pp. 894–899.[35] E. Sandewall, Features and Fluents: The Representation of Knowledge about Dynamical Systems, vol. I, Oxford University Press, Oxford,1994.[36] M. Shanahan, Solving the Frame Problem, MIT Press, Cambridge, MA, 1997.[37] M. Shanahan, The event calculus explained, in: M.J. Wooldridge, M.M. Veloso (Eds.), Artificial Intelligence Today: Recent Trends andDevelopments, in: Lecture Notes in Computer Science, vol. 1600, Springer, Berlin, 1999, pp. 409–430.[38] M. Shanahan, The ramification problem in the event calculus, in: Proceedings of the Sixteenth International Joint Conference on ArtificialIntelligence, Morgan Kaufmann, San Mateo, CA, 1999, pp. 140–146.[39] M. Shanahan, An abductive event calculus planner, Journal of Logic Programming 44 (1–3) (2000) 207–240.[40] M. Thielscher, An analysis of systematic approaches to reasoning about actions and change, in: P. Jorrand, V. Sgurev (Eds.), Proceedings ofthe Sixth International Conference on Artificial Intelligence: Methodology, Systems, Applications, World Scientific, River Edge, NJ, 1994,pp. 195–204.[41] M. Thielscher, From situation calculus to fluent calculus: State update axioms as a solution to the inferential frame problem, Artificial Intelli-gence 111 (1999) 277–299.[42] M. Thielscher, The qualification problem: A solution to the problem of anomalous models, Artificial Intelligence 131 (2001) 1–37.[43] M. Thielscher, Reasoning Robots: The Art and Science of Programming Robotic Agents, Springer, Dordrecht, 2005.[44] K. Van Belleghem, M. Denecker, D. De Schreye, On the relation between situation calculus and event calculus, Journal of Logic Program-ming 31 (1–3) (1997) 3–37.