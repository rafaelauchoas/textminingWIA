Artificial Intelligence 170 (2006) 739–778www.elsevier.com/locate/artintSolving logic program conflict through strong and weak forgettings ✩Yan Zhang a,∗, Norman Y. Foo ba Intelligent Systems Laboratory, School of Computing and Mathematics, University of Western Sydney, Penrith South DC, NSW 1797, Australiab School of Computer Science and Engineering, University of New South Wales, Sydney, NSW 2052, AustraliaReceived 6 September 2005; received in revised form 23 February 2006; accepted 23 February 2006Available online 29 March 2006AbstractWe consider how to forget a set of atoms in a logic program. Intuitively, when a set of atoms is forgotten from a logic program,all atoms in the set should be eliminated from this program in some way, and other atoms related to them in the program mightalso be affected. We define notions of strong and weak forgettings in logic programs to capture such intuition, reveal their closeconnections to the notion of forgetting in classical propositional theories, and provide a precise semantic characterization forthem. Based on these notions, we then develop a general framework for conflict solving in logic programs. We investigate varioussemantic properties and features in relation to strong and weak forgettings and conflict solving in the proposed framework. Weargue that many important conflict solving problems can be represented within this framework. In particular, we show that allmajor logic program update approaches can be transformed into our framework, under which each approach becomes a specificconflict solving case with certain constraints. We also study essential computational properties of strong and weak forgettings andconflict solving in the framework.© 2006 Elsevier B.V. All rights reserved.Keywords: Conflict solving; Knowledge representation; Answer set semantics; Logic program update; Computational complexity1. Introduction1.1. MotivationOne promising approach in the research of reasoning about knowledge dynamics is to represent agents’ knowledgebases as logic programs on which necessary updates/revisions are conducted as a way of modeling agents’ knowledgeevolution. A key issue in this study is to solve various conflicts and inconsistencies in logic programs, e.g. [15].We observe that some typical conflict solving problems in applications are essential in reasoning about agents’knowledge change, but they may not be properly handled by traditional logic program updates. Let us consider a✩ Some results presented in this paper were published in IJCAI-2005 and AAAI-2005 [Y. Zhang, N.Y. Foo, K. Wang, Solving logic programconflict through strong and weak forgettings, in: Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI-05), 2005,pp. 627–632; Y. Zhang, N.Y. Foo, A unified framework for representing logic program updates, in: Proceedings of the 20th National Conferenceon Artificial Intelligence (AAAI-05), 2005, pp. 707–712].* Corresponding author.E-mail addresses: yan@cit.uws.edu.au (Y. Zhang), norman@cse.unsw.edu.au (N.Y. Foo).0004-3702/$ – see front matter © 2006 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2006.02.002740Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778scenario. John wants Sue to help him to complete his assignment. He knows that Sue will help him if she is not sobusy. Tom is a good friend of John and wants John to let him copy John’s assignment. Then John learns that Sue hatesTom, and will not help him if he lets Tom copy his assignment, which will be completed under Sue’s help. While Johndoes not care whether Sue hates Tom or not, he has to consider Sue’s condition to offer him help. What is John goingto do? We formalize this scenario in a logic programming setting. We represent John’s knowledge base ΠJ :r1: complete(John, Assignment) ← help(Sue, John),r2: help(Sue, John) ← not Busy(Sue),r3: goodFriend(John, Tom) ←,r4: copy(Tom, Assignment) ← goodFriend(John, Tom), complete(John, Assignment),and Sue’s knowledge base ΠS :r5: hate(Sue, Tom) ←,r6: ← help(Sue, John), copy(Tom, Assignment).In order to take Sue’s knowledge base into account, John may update his knowledge base ΠJ in terms of Sue’sΠS . In this way, John obtains a solution: Π final= {r1, r2, r3, r5, r6} or its stable model, from which we know thatSue will help John to complete the assignment and John will not let Tom copy his assignment. Although the conflictbetween ΠJ and ΠS has been solved by updating, the result is somehow not always satisfactory. For instance, whileJohn wants Sue to help him, he may have no intention to contain the information that Sue hates Tom into his newknowledge base.JAs an alternative, John may just weaken his knowledge base by forgetting atom copy(Tom, Assignment) fromΠJ in order to accommodate Sue’s constraint on help. Then John will have a new program Π final(cid:4)= {r1, r2, r3}—John remains a maximal knowledge subset which is consistent with Sue’s condition without being involved in Sue’spersonal feeling about Tom.JThe formal notion of forgetting in propositional theories was initially considered by Lin and Reiter from a cognitiverobotics perspective [18] and has recently received a great attention in KR community. It has been shown that thetheory of forgetting has important applications in solving knowledge base inconsistencies, belief update and merging,abductive reasoning, causal theories of actions, and reasoning about knowledge under various propositional (modal)logic frameworks, e.g. [13,14,19,24]. Then a natural question is: whether can we develop an analogous theory offorgetting in logic programs and apply it as a foundational basis for various conflict solving in logic programs? Thispaper provides an answer to this question.1.2. Summary of contributions of this paperThe main contributions of this paper can be summarized as follows.(1) We define two notions of strong and weak forgettings in logic programs under answer set programming semantics.We reveal their close connections to the notion of forgetting in classical propositional theories, and provide aprecise semantic characterization for them.(2) Based on these notions, we develop a general framework for conflict solving called logic program contexts.Under this framework, conflicts can be solved by strongly or/and weakly forgetting certain sets of atoms fromcorresponding programs. We show that our framework is general enough to represent many important conflictsolving problems. In particular, for the first time we demonstrate that all major logic program update approachescan be transformed into our framework.(3) We investigate essential computational properties in relation to strong and weak forgettings and conflict solvingin the proposed framework. Specifically, we show that under the answer set programming with no disjunctionin the head, the associated inference problem for strong and weak forgettings is coNP-complete, and the irrele-vance problem related to strong and weak forgettings and conflict solving is coDP-complete. We also study othercomputational problems related to the computation of strong and weak forgetting and conflict solving.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–7787411.3. Structure of the paperThe rest of this paper is organized as follows. We first present preliminary definitions and concepts in Section 2.In Section 3, we give formal definitions of strong and weak forgettings in logic programs, and present their essentialproperties. Based on notions of strong and weak forgettings, in Section 4 we propose a framework called logic programcontexts for general conflict solving in logic programs. In Section 5, we investigate various semantic properties andfeatures in relation to strong and weak forgettings and conflict solving in the proposed framework. In Section 6, weshow that our conflict solving framework is general enough to represent all major logic program update approaches. InSection 7, we study essential computational properties of strong and weaking forgettings and conflict solving. Finally,in Section 8 we conclude the paper with some discussions.2. PreliminariesWe consider finite propositional normal logic programs in which each rule is of the form:a ← b1, . . . , bm, not c1, . . . , not cn,(1)where a is either a propositional atom or empty, b1, . . . , bm, c1, . . . , cn are propositional atoms, and not presents thenegation as failure. From (1) we know that a normal logic program does not contain classical negation and has nodisjunction in the head. When a is empty, rule (1) is called a constraint. Given a rule r of the form (1), we denotehead(r) = {a}, pos(r) = {b1, . . . , bm}, neg(r) = {c1, . . . , cn}, and body(r) = pos(r) ∪ neg(r). Therefore, rule (1) maysimply be represented as the form:head(r) ← pos(r), not neg(r),(2)here we denote not neg(r) = {not c1, . . . , not cn}. We also use atom(r) to denote the set of all atoms occurring in rule r.For a program Π , we define notions head(Π) =r∈Π neg(r),body(Π) =r∈Π atom(r). Given sets of atoms P and Q, we may use notionr∈Π body(r), and atom(Π) =r∈Π head(r), pos(Π) =r∈Π pos(r), neg(Π) =(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:4)r: head(r) ←(cid:3)pos(r) − P(cid:4), not(cid:4)(cid:3)neg(r) − Qto denote rule r (cid:4) obtained from r by removing all atoms occurring in P and Q in the positive and negation as failureparts respectively.The stable model of a program Π is defined as follows. Firstly, we consider Π to be a program in which each ruledoes not contain negation as failure not. A finite set S of propositional atoms is called a stable model of Π if S is thesmallest set such that for each rule a ← b1, . . . , bm from Π , if b1, . . . , bm ∈ S, then a ∈ S. Now let Π be an arbitrarynormal logic program. For any set S of atoms, program Π S is obtained from Π by deleting (1) each rule from Π thatcontains not c in the body if c ∈ S; and (2) all subformulas of not c in the bodies of the remaining rules. Then S isa stable model of Π if and only if S is a stable model of Π S [7]. We also call Π S is the result of Gelfond–Lifschitztransformation on Π with S. It is easy to see that a program may have one, more than one, or no stable models at all.A program is called consistent if it has a stable model. We say that an atom a is entailed from program Π , denoted asΠ |= a if a is in every stable model of Π .Two programs Π1 and Π2 are equivalent if Π1 and Π2 have the same stable models. Π1 and Π2 are called stronglyequivalent if for every program Π , Π1 ∪ Π and Π2 ∪ Π are equivalent [17]. The concept of strong equivalence canbe used to simplify a program. For example, if two programs are strongly equivalent, then whenever one program iscontained in a particular program, it can be replaced by the other program safely. The following observation gives twoinstances for this case which will be useful for our later formalization.Observation 1. Let Π be a logic program Π . Then Π is strongly equivalent to the empty set iff each rule r in Π is ofone of the following two forms: (1) head(r) (cid:7)= ∅ and head(r) ⊆ pos(r), or (2) pos(r) ∩ neg(r) (cid:7)= ∅.11 This result can be viewed as a special case of more general results proved in [9] and [20] respectively.742Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778For convenience in the later reference in this paper, we call the two types of rules mentioned above valid rules.Let Π be a logic program. We use [Π]C to denote the conjunctive normal form obtained from Π by translatingeach rule of the form (1) in Π into the clause: a ∨ ¬b1 ∨ · · · ∨ ¬bm ∨ c1 ∨ · · · ∨ cm. Note that this is not a translationin a classical sense since here we replace negation as failure not with classical negation ¬. For instance, if Π = {a ←not b, c ← a}, then we have [Π]C = (a ∨ b) ∧ (c ∨ ¬a). In general, we may write [Π]C = {C1, . . . , Cn} where eachCi is a conjunct of [Π]C . If C is a clause, we call any subformula of C a subclause of C.Now we introduce the notion of forgetting in a classical propositional theory [18,19]. Let T be a propositionaltheory. We use T [p/true] (or T [p/false], resp.) to denote the theory obtained from T by substituting all occurrencesof propositional atom p with true (or false, resp.). For instance, if T = {p ⊃ q, (q ∧ r) ⊃ s}, then T [q/true] = {r ⊃ s}and T [q/false] = {¬p}.2 Then we can define the notion of forgetting in terms of a propositional theory. For a givenpropositional theory T and a set of propositional atoms P , the result of forgetting P in T , denoted as Forget(T , P ), isdefined inductively as follows:Forget(T , ∅) = T ,ForgetForget= T [p/true] ∨ T [p/false],(cid:3)Forget(T , p), P(cid:3)T , {p}(cid:3)T , P ∪ {p}= Forget(cid:4)(cid:4)(cid:4).It is easy to see that the ordering in which atoms in P are considered does not affect the final result of forget-ting P from T . Consider T = {p ⊃ q, (q ∧ r) ⊃ s} again. From the above definition, we have Forget(T , {q}) ={(r ⊃ s) ∨ ¬p}.3. Strong and weak forgettings in logic programs3.1. DefinitionsLet us consider how to forget a set of atoms from a logic program. Intuitively, we would expect that after forgettinga set of atoms, all occurrences of these atoms in the underlying program should be eliminated in some way. Thoseatoms having certain connections to forgotten atoms through rules in the program might or might not be affecteddepending on the situation, while all other atoms should not be affected. We observe that the forgetting definition inpropositional theories cannot be directly used for logic programs as logic programs themselves cannot be disjunctedtogether. Further, different ways of handling negation as failure in forgetting may also lead to different resultingprograms.For example, suppose we have a program Π containing two rules:a ← b,b ← c.Now if we want to forget atom b, we can simply remove the second rule and replace the first rule with a ← c. Inthis case, forgetting b is just to remove b through the rule replacement. However, things become not so simple if wechange the program to:a ← not b,b ← c,and we still want to forget atom b. In this case, the method of replacement mentioned above seems not workingbecause replacing the first rule with a ← not c will change the entire semantics of the program. One way we cando is to completely remove the second rule since b is forgotten, and the first rule may be either reduced to a ←or completely removed depending on whether we assume b true or false. These two examples actually reflect ourintuition of defining forgetting notions in logic programs.To formalize our idea of forgetting in logic programs, we first introduce a program transformation called reduction.The intuition behind reduction may be easily illustrated as follows. Given a program Π = {p ← q, p(cid:4) ← p, not q(cid:4)},performing a reduction on Π with respect to atom p will result in a new program Π (cid:4) = {p(cid:4) ← q, not q(cid:4)}. The formaldefinition is presented as follows.2 For convenience, we may consider a finite set of formulas as a single conjunction of all elements in the set.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778743Definition 1 (Program reduction). Let Π be a program and p an atom. We define the reduction of Π with respect top, denoted as Reduct(Π, {p}), to be a program obtained from Π by (1) for each rule r with head(r) = {p} and eachrule r (cid:4) with p ∈ pos(r (cid:4)), replacing r (cid:4) with a new rule r (cid:4)(cid:4): head(r (cid:4)) ← (pos(r (cid:4)) − {p}), pos(r), not (neg(r) ∪ neg(r (cid:4)));(2) if there is such rule r (cid:4) in Π and has been replaced by r (cid:4)(cid:4) in (1), then removing rule r from the remaining program.Let P be a set of propositional atoms. Then the reduction of Π with respect to P is inductively defined as follows:Reduct(Π, ∅) = Π,(cid:4)(cid:3)Π, P ∪ {p}Reduct= Reduct(cid:3)Reduct(cid:3)Π, {p}(cid:4), P(cid:4).Note that in our program reduction definition, Step (1) is the same as Sakama and Seki’s [23] and Brass andDix’s [4] unfolding in logic programs. While unfolding is to eliminate positive middle occurrences of an atom in alogic program, the reduction, on other hand, is further to remove those rules with heads of this atom. Now let usconsider a program Π = {a ← b, b ← a, d ← not e}. Then(cid:3)(cid:4), {b}Π, {a}(cid:4)(cid:3), {a}Π, {b}= {b ← b, d ← not e},= {a ← a, d ← not e}.(cid:3)Reduct(cid:3)ReductReductReductand(cid:4)(cid:4)A brief glimpse of this example seems to indicate that the program reduction is not well defined since these twoprograms look different. However, it is easy to see that they are strongly equivalent, and both can be simplified to{d ← not e}. The following proposition actually shows that our program reduction is well defined under the strongequivalence.Proposition 1. Let Π be a logic program and p, q two propositional atoms. Then Reduct(Reduct(Π, {p}), {q}) isstrongly equivalent to Reduct(Reduct(Π, {q}), {p}).Proof. To prove this result, we need to consider a general case of iterated reductions which captures all possiblefeatures. For this purpose, it is sufficient to deal with a program Π = Π1 ∪ Π2, where all possible reductions relatedto atoms p and q are only happened within Π1. That is, we can assume Π1 consists of six parts: Π11 ∪ Π12 ∪ Π13 ∪Π14 ∪ Π15 ∪ Π16:Π11:r1: p ← pos(r1), not neg(r1),. . . ,rh: p ← pos(rh), not neg(rh),Π12:rh+1: p ← q, pos(rh+1), not neg(rh+1),. . . ,rk: p ← q, pos(rk), not neg(rk),Π13:rk+1: q ← pos(rk+1), not neg(rk+1),. . . ,rl: q ← pos(rl), not neg(rl),Π14:rl+1: q ← p, pos(rl+1), not neg(rl+1),. . . ,rm: q ← p, pos(rm), not neg(rm),744Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778Π15:rm+1: am+1 ← p, pos(rm+1), not neg(rm+1),. . . ,rn: an ← p, pos(rn), not neg(rn),Π16:rn+1: bn+1 ← q, pos(rn+1), not neg(rn+1),. . . ,rs: bs ← q, pos(rs), not neg(rs),where ai (cid:7)= p, ai (cid:7)= q, bj (cid:7)= p, and bj (cid:7)= q for all ai and bj , and also p, q do not occur in all pos(ri) (i = 1, . . . , s).We assume that p, q are not in head(Π2) and pos(Π2), i.e. no reduction related to p or q will occur in Π2.It is not hard to see that the above Π covers all possible cases of reductions of Π with respect to atoms p and q.In order to avoid a tedious proof, without loss of generality, we may consider a simplified version of program Π asfollows. Π = Π1 ∪ Π2, where Π1 contains the following rules:r1: p ← pos(r1), not neg(r1),(cid:4)(cid:4)(cid:4)1: p ← q, pos(r1), not neg(r1),rr2: q ← pos(r2), not neg(r2),(cid:4)(cid:4)(cid:4)2: q ← p, pos(r2), not neg(r2),rr3: a ← p, pos(r3), not neg(r3),r4: b ← q, pos(r4), not neg(r4).We assume p and q do not occur in pos(r1), pos(r (cid:4)2). Also, all rules in Π2 do not contain p or qin their heads and positive bodies. We should mention that our following proof can be extended to the general case ofΠ as constructed earlier.1), pos(r2) and pos(r (cid:4)Firstly, we have Reduct(Π, {p}) = Π (cid:4)1∪ Π2 consists of the following rules:(cid:3)(cid:4)(cid:4)neg(r1) ∪ neg(r,2)(cid:4)(cid:3)(cid:4)(cid:4)1) ∪ neg(r, notneg(r,2)(cid:4)(cid:3)neg(r1) ∪ neg(r3),(cid:4)(cid:4)1) ∪ neg(r3),(cid:3)neg(r(cid:3)pos(rr2: q ← pos(r2), not neg(r2),(cid:3)(cid:4)(cid:4)(cid:4)pos(r1) ∪ pos(r2: q ←, not2)r(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)1) ∪ pos(r2 : q ← q,2)r(cid:4)(cid:3)(cid:4)3: a ←pos(r1) ∪ pos(r3), notr(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)1) ∪ pos(r3)3 : a ← q,, notpos(rrr4: b ← q, pos(r4), not neg(r4).From Observation 1, we know that {r (cid:4)(cid:4)2Then by the reduction of Π (cid:4)1Π (cid:4)(cid:4)1∪ Π2, where Π (cid:4)(cid:4)3 , r4}.∪ Π2 with respect to {q}, we have the following result: Reduct(Reduct(Π, {p}), {q}) =} is strongly equivalent to the empty set. So we have Π (cid:4)1= {r2, r (cid:4)3, r (cid:4)(cid:4)2, r (cid:4)1 contains the following rules:(cid:4)(cid:3)(cid:4)(cid:3)(cid:4)3: a ←neg(r1) ∪ neg(r3)pos(r1) ∪ pos(r3), notr,(cid:4)(cid:3)(cid:4)(cid:3)∗(cid:4)(cid:4): a ←1) ∪ neg(r2) ∪ neg(r3)) ∪ pos(r2) ∪ pos(r3)neg(r, notpos(r1,r(cid:3)(cid:4)(cid:3)∗(cid:4)(cid:4)(cid:4)(cid:4)) ∪ pos(rpos(r1) ∪ pos(r1: a ←1) ∪ neg(rneg(r1) ∪ neg(r2) ∪ pos(r3), notr(cid:4)(cid:3)(cid:4)(cid:3)(cid:4)neg(r2) ∪ neg(r4)pos(r2) ∪ pos(r4)4: b ←, notr(cid:4)(cid:3)(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)neg(r1) ∪ neg(r2) ∪ neg(r4)2) ∪ pos(r4)pos(r1) ∪ pos(r4 : b ←r,.(cid:4)(cid:4)2) ∪ neg(r3),It is easy to see that programs {r (cid:4)). Therefore, rule r ∗(cid:4)neg(r ∗(cid:4)3can be removed. So finally, we have Π (cid:4)(cid:4)1= {r (cid:4)3, r ∗, r (cid:4)4, r (cid:4)(cid:4)4}.} are strongly equivalent because pos(r (cid:4)3) ⊆ pos(r ∗(cid:4)) and neg(r (cid:4)3) ⊆, not3, r ∗(cid:4) } and {r (cid:4)Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778745Now we consider Reduct(Π, {q}). It is easy to see that Reduct(Π, {q}) = Π † ∪ Π2, where Π † consists of thefollowing rules:(cid:3)neg(r(cid:3)neg(r(cid:4)(cid:4)1) ∪ neg(r2),(cid:4)(cid:4)(cid:4)1) ∪ neg(r2)r1: p ← pos(r1), not neg(r1),(cid:3)(cid:4)(cid:4)(cid:4)(cid:4)1) ∪ pos(r2)1 : p ←pos(r, notr(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)1) ∪ pos(r1 : p ← p,pos(rr2)r3: a ← p, pos(r3), not neg(r3),(cid:4)(cid:3)(cid:4)pos(r2) ∪ pos(r4)4: b ←, notr(cid:4)(cid:4)(cid:4)(cid:4)2) ∪ pos(r4)4 : b ← p,, notr1 can be removed from Π †. So we have Π † = {r1, r (cid:4)(cid:4)(cid:4)(cid:3)neg(r2) ∪ neg(r4),(cid:4)(cid:4)2) ∪ neg(r4).(cid:3)neg(r(cid:3)pos(r, not,Also, rule r (cid:4)(cid:4)(cid:4)Π ‡ ∪ Π2, where Π ‡ consists of the following rules:1 , r3, r (cid:4)4, r (cid:4)(cid:4)4}. Then Reduct(Reduct(Π, {q}), {p}) =,, not, not(cid:4)(cid:3)pos(r1) ∪ pos(r3)(cid:4)(cid:3)neg(r1) ∪ neg(r3)(cid:3)neg(r(cid:4)(cid:4)1) ∪ pos(r2) ∪ pos(r3)(cid:4)3: a ←r(cid:3)∗: ←pos(rr(cid:4)(cid:3)(cid:4)pos(r2) ∪ pos(r4)4: b ←, notr(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)pos(r1) ∪ pos(r2) ∪ pos(r4)4 : b ←, notr(cid:4)(cid:3)(cid:4)r †: b ←2) ∪ pos(r4)pos(r1) ∪ pos(r2) ∪ pos(r4 ) ⊆ pos(r†), we know that programs {r (cid:4)(cid:4)4, r (cid:4)(cid:4)(cid:4)(cid:3)neg(r2) ∪ neg(r4),(cid:3)neg(r1) ∪ neg(r, not3, r ∗, r (cid:4)} = Π (cid:4)(cid:4)4Since pos(r (cid:4)(cid:4)Π ‡. Therefore, Π ‡ = {r (cid:4)1 . This proves our result. (cid:2)(cid:4)(cid:4)1) ∪ neg(r2) ∪ neg(r3),(cid:4)(cid:4)2) ∪ neg(r4)(cid:3)neg(r1) ∪ neg(r2) ∪ neg(r,(cid:4)(cid:4)2) ∪ neg(r4).4 , r †} and {r †} are strongly equivalent. So r † can be removed fromExample 1. Let Π1 = {a ← not b, a ← d, c ← a, not e}, Π2 = {a ← c, not b, c ← not d}, and Π2 = {a ← b,b ← not d, c ← a, not e}. Then Reduct(Π1, {a}) = {c ← not b, not e, c ← d, not e}, Reduct(Π2, {a}) = Π2, andReduct(Π3, {a, b}) = {c ← not d, not e}.Definition 2 (Strong forgetting). Let Π be a logic program, and p a propositional atom. We define a program to be theresult of strongly forgetting p in Π , denoted as SForgetLP(Π, {p}), if it is obtained from the following transformation:(1) Π (cid:4) = Reduct(Π, {p});(2) Π (cid:4) = Π (cid:4) − {r | r is a valid rule};(3) Π (cid:4) = Π (cid:4) − {r | head(r) = {p}};(4) Π (cid:4) = Π (cid:4) − {r | p ∈ pos(r)};(5) Π (cid:4) = Π (cid:4) − {r | p ∈ neg(r)};(6) SForgetLP(Π, {p}) = Π (cid:4).Let us take a closer look at Definition 2. Step 1 is just to perform reduction on Π with respect to atom p. This isto replace those positive middle occurrences of p in rules with other rules having p as the head. Step 2 is to removeall valid rules which may be introduced by the reduction of Π with respect to p. From Observation 1, we know thatthis does not change anything in the program. Steps 3 and 4 are to remove those rules which have p as the head or inthe positive body. Note that after reduction, there does not exist any pair of rules r and r (cid:4) such that head(r) = {p} andp ∈ pos(r (cid:4)). The intuitive meaning of these two steps is that after forgetting p, any atom’s information in rules havingp as their heads or positive bodies will be lost because they are all relevant to p, i.e. these atoms either serve as asupport for p or p is in part of the supports for these atoms. On the other hand, Step 5 states that any rule containingp in its negation as failure part will be also removed. The consideration for this step is as follows. If we think neg(r)as a part of support of head(r), then when p ∈ neg(r) is forgotten, head(r)’s entire support is lost as well. Clearly,such treatment of negation as failure in forgetting is quite strong in the sense that more atoms may be lost togetherwith not p. Therefore we call this kind of forgetting strong forgetting.Definition 2 can be easily extended to the case of strongly forgetting a set of atoms:746Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778SForgetLP(Π, ∅) = Π,(cid:4)(cid:3)Π, P ∪ {p}SForgetLP(cid:3)(cid:3)Π, {p}= SForgetLPSForgetLP(cid:4), P(cid:4).With a different way of dealing with negation as failure, we have a weak version of forgetting as defined below.Definition 3 (Weak forgetting). Let Π be a logic program, and p a propositional atom. We define a program to be theresult of weakly forgetting p in Π , denoted as WForgetLP(Π, {p}), if it is obtained from the following transformation:(1) Π (cid:4) = Reduct(Π, {p});(2) Π (cid:4) = Π (cid:4) − {r | r is a valid rule};(3) Π (cid:4) = Π (cid:4) − {r | head(r) = {p}};(4) Π (cid:4) = Π (cid:4) − {r | p ∈ pos(r)};(5) Π (cid:4) = Π (cid:4) − Π ∗ ∪ Π †, where Π ∗ = {r | p ∈ neg(r)} andΠ † = {r (cid:4) | r (cid:4): head(r) ← pos(r), not(neg(r) − {p}) where r ∈ Π ∗};(6) WForgetLP(Π, {p}) = Π (cid:4).WForgetLP(Π, {p}) is defined in the same way as SForgetLP(Π, {p}) except Step 5. Suppose we have a rule liker: b ← pos(r), not neg(r) where p ∈ neg(r). Instead of viewing neg(r) as part of the support of head(r), we maytreat it as a default evidence of head(r), i.e. under the condition of pos(r), if all atoms in neg(r) are not presented,then head(r) can be derived. Therefore, forgetting p will result in the absence of p in any case. So r may be replacedby r (cid:4): b ← pos(r), not(neg(r) − {p}). The notion of weakly forgetting a set of atoms, denoted as WForgetLP(Π, P ),is defined accordingly:WForgetLP(Π, ∅) = Π,(cid:4)(cid:3)Π, P ∪ {p}WForgetLP(cid:3)(cid:3)Π, {p}= WForgetLPWForgetLP(cid:4), P(cid:4).The following proposition ensures that our strong and weak forgettings in logic programs are well defined understrong equivalence.Proposition 2. Let Π be a logic program and p, q two propositional atoms. Then(1) SForgetLP(SForgetLP(Π, {p}), {q}) is strongly equivalent to SForgetLP(SForgetLP(Π, {q}), {p}); and(2) WForgetLP(WForgetLP(Π, {p}), {q}) is strongly equivalent to WForgetLP(WForgetLP(Π, {q}), {p}).Proof. We only prove Result 1, as Result 2 is proved in a similar way. Similar to the proof of Proposition 1, withoutloss of generality, we consider a program Π = Π1 ∪ Π2, where Π1 contains the following rules:r1: p ← pos(r1), not neg(r1),(cid:4)(cid:4)(cid:4)1: p ← q, pos(r1), not neg(rr1),r2: q ← pos(r2), not neg(r2),(cid:4)(cid:4)(cid:4)2: q ← p, pos(r2), not neg(rr2),r3: a ← p, pos(r3), not neg(r3),r4: b ← q, pos(r4), not neg(r4).We assume p and q do not occur in pos(r1), pos(r (cid:4)in their heads and positive bodies, but may contain not p or not q.1), pos(r2) and pos(r (cid:4)2). Also, all rules in Π2 do not contain p or qThen we have Reduct(Π, {p}) = Reduct(Π1, {p}) ∪ Π2, where, according to the proof of Proposition 1,Reduct(Π1, {p}) consists of the following rules:r2: q ← pos(r2), not neg(r2),(cid:4)(cid:4)(cid:4)2: q ←, notr2)(cid:3)pos(r1) ∪ pos(r(cid:3)neg(r1) ∪ neg(r(cid:4)(cid:4),2)Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778747(cid:3)pos(r(cid:3)neg(r(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)1) ∪ neg(r1) ∪ pos(r2 : q ← q,, not,2)2)r(cid:4)(cid:3)(cid:4)(cid:3)(cid:4)neg(r1) ∪ neg(r3)pos(r1) ∪ pos(r3)3: a ←, notr,(cid:4)(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)(cid:4)1) ∪ neg(r3)1) ∪ pos(r3)3 : a ← q,, notpos(rr,r4: b ← q, pos(r4), not neg(r4).(cid:3)neg(rThen after Step 2 (removing valid rules), rule r (cid:4)(cid:4)Π (cid:4)3 , r4}, and Π (cid:4)1removed if they contain not p, according to Step 5 in the transformation.∪ Π (cid:4)⊆ Π2 in which all rules containing not p are removed. Note that rules in Π (cid:4)2 is removed. So we can write SForgetLP(Π, {p}) = Π (cid:4)= {r2, r (cid:4)3, r (cid:4)(cid:4)2, r (cid:4)212, where1 may be2 does not contain any rule having q in its head or positive2. By ignoring the details, we will have the final resulting program:1, not2, {q}). Since Π (cid:4)1, {q})∪Π (cid:4)Now we consider SForgetLP(Π (cid:4)1∪Π (cid:4)∪ Π (cid:4)2, {q}) = Reduct(Π (cid:4)2, {q}) = Π (cid:4)(cid:4)1 consists of the following rules:body, Reduct(Π (cid:4)1∪ Π (cid:4)(cid:4)∪ Π (cid:4)SForgetLP(Π (cid:4)1(cid:4)(cid:3)pos(r1) ∪ pos(r3)(cid:3)(cid:4)(cid:4)1) ∪ pos(r2) ∪ pos(r3)pos(r(cid:4)(cid:3)pos(r2) ∪ pos(r4), not(cid:4)(cid:3)(cid:4)2) ∪ pos(r4)pos(r1) ∪ pos(r2 , where Π (cid:4)(cid:4)(cid:4)(cid:3)neg(r1) ∪ neg(r3)(cid:4)(cid:3)(cid:4)1) ∪ neg(r2) ∪ neg(r3)neg(r(cid:4)(cid:3)neg(r2) ∪ neg(r4)(cid:4)(cid:3)neg(r1) ∪ neg(r2) ∪ neg(r4)(cid:4)3: a ←r∗: a ←r(cid:4)4: b ←r(cid:4)(cid:4)4 : b ←rand Π (cid:4)(cid:4)2 in which all rules containing not q are removed. Again, rules among {r (cid:4)⊆ Π (cid:4)2they contain not q. Let us denote the resulting program after such elimination as Π ∗(cid:4)in Π (cid:4)(cid:4), not, not,,,,1 containing not p or not q is removed from Π ∗(cid:4)1 .Let us examine the result of SForgetLP(SForgetLP(Π, {q}), {p}). Firstly, we have Reduct(Π, {q}) = Reduct(Π1,{q}) ∪ Π2, where Reduct(Π1, {q}) consists of the following rules:3, r ∗, r (cid:4)1 , i.e. Π ∗(cid:4)14, r (cid:4)(cid:4)} will be removed if1 where each rule4⊆ Π (cid:4)(cid:4)Now we consider SForgetLP(Π ∗1∪ Π ∗2 , {p}) = Reduct(Π ∗2 , {p}). Since Π ∗1 , {p} ∪ Π ∗2 does not contain any rule having p in its head or posi-2 ). Then we have Reduct(Π ∗1 , which has the1 , {p}) = Π ∗(cid:4)2 , where Π ∗1 , r3, r (cid:4)∪ Π ∗4,11 will be removed if they contain= {r1, r (cid:4)(cid:4), not(cid:3)neg(r(cid:3)neg(r(cid:4)(cid:4)1) ∪ neg(r2),(cid:4)(cid:4)(cid:4)1) ∪ neg(r2)r1: p ← pos(r1), not neg(r1),(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)1) ∪ pos(r2)1 : p ←, notpos(rr(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)1) ∪ pos(r1 : p ← p,pos(rr2)r3: a ← p, pos(r3), not neg(r3),(cid:4)(cid:3)(cid:4)(cid:3)(cid:4)neg(r2) ∪ neg(r4)pos(r2) ∪ pos(r4)4: b ←, notr,(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)2) ∪ neg(r4)2) ∪ pos(r4)4 : b ← p,, notr.1 is removed. So we can write SForgetLP(Π, {q}) = Π ∗Again, after Step 2, rule r (cid:4)(cid:4)(cid:4)r (cid:4)(cid:4)4not q.⊆ Π2 in which all rules containing not q are removed. Also rules in Π ∗}, and Π ∗2(cid:3)neg(r(cid:3)pos(r,1∪ Π ∗tive body, Reduct(Π ∗1following rules:(cid:4)(cid:3)pos(r1) ∪ pos(r3),, not, not(cid:4)(cid:3)neg(r1) ∪ neg(r3)(cid:3)neg(r(cid:4)(cid:4)1) ∪ pos(r2) ∪ pos(r3)(cid:4)3: a ←r(cid:3)∗: ←pos(rr(cid:4)(cid:3)(cid:4)pos(r2) ∪ pos(r4)4: b ←, notr(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)2) ∪ pos(r4)pos(r1) ∪ pos(r4 : b ←rThis program is Π (cid:4)(cid:4)not p according to Step 5. Then clearly, such resulting program is Π ∗(cid:4)∪ Π ∗So after performing Steps 2–5, we finally have SForgetLP(Π ∗1, not1 as we have shown above. Also note that rules in {r (cid:4)(cid:4)(cid:3)neg(r2) ∪ neg(r4),(cid:3)neg(r1) ∪ neg(r(cid:4)(cid:4)1) ∪ neg(r2) ∪ neg(r3)(cid:4)(cid:4)2) ∪ neg(r4),all rules containing not p are removed. Obviously, Π ∗(cid:4)2= Π (cid:4)(cid:4).4, r (cid:4)(cid:4)3, r ∗, r (cid:4)1 as mentioned above.∪ Π ∗(cid:4)2 , {p}) = Π ∗(cid:4)12 . This proves our result. (cid:2)4} will be removed if they contain2 , where Π ∗(cid:4)2⊆ Π ∗2 , in which748Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778Example 2. Let Π1 = {a ← not b, b ← not a}, and Π2 = {a ← b, not c, a ← not e, d ← a, e, e ← not a}. Then(cid:4)(cid:3)Π1, {a}SForgetLP(cid:3)Π1, {a, b}SForgetLP(cid:4)(cid:3)Π1, {a}WForgetLP(cid:3)Π1, {a, b}WForgetLP(cid:3)Π2, {a}SForgetLP(cid:3)Π2, {a}WForgetLP(cid:4)= ∅,(cid:4)= ∅,= {b ←},(cid:4)= ∅,= {d ← b, e, not c},(cid:4)= {d ← b, e, not c, e ←}.3.2. Relationship to forgetting in propositional theoriesAs we argued earlier, the notion of forgetting in propositional theories is not applicable to logic programs generally.However, as we will show next, there are close connections between forgetting in propositional theories and strongand weak forgettings in logic programs. Let us first consider the following example.Example 3. Let Π = {b ← a, c, d ← not a, e ← not f }. Then we have(cid:4)(cid:3)Π, {a}SForgetLP(cid:3)Π, {a}WForgetLP= {e ← not f },and(cid:4)= {d ←, e ← not f }.Now we consider Forget([Π]C, {a}), which is logically equivalent to formula (b ∨ ¬c ∨ d) ∧ (f ∨ e). Then it is clearthat(cid:4)(cid:3)[Π]C, {a}|= Forget(cid:3)(cid:5)Π, {a}WForgetLP|=⊃(cid:4)(cid:6)(cid:4)(cid:6)(cid:3)(cid:5)C,Π, {a}SForgetLP(cid:4)(cid:3)C ⊃ Forget[Π]C, {a}.andThe above example motivates us to examine deeper connections between strong and weak forgettings in logicprograms and forgetting in propositional theories. To begin with, we introduce a useful notion. Let Π be a programand L a clause, i.e. L = l1 ∨ · · · ∨ lk where each li is a propositional literal. We say that L is Π -coherent if there existsa subset Π (cid:4) of Π and a set of atoms P ⊆ atom(Π) (P could be empty) such that [Reduct(Π (cid:4), P )]C is a single clauseand L is a subclause of [Reduct(Π (cid:4), P )]C . Intuitively, the coherence notion tries to specify those clauses that are partsof clauses generated from program Π through reduction.Consider program Π = {a ← b, d ← a, not c, e ← not d}. Clause d ∨ ¬b is Π -coherent, where clause ¬d ∨ e isnot. Obviously, for each rule r ∈ Π , [{r}]C is Π -coherent. The following proposition provides a semantic account forΠ -coherent clauses.Proposition 3. Let Π be a program and L a Π -coherent clause. Then either |= [Π]C ⊃ L or |= L ⊃ Φ for someclause Φ where |= [Π]C ⊃ Φ.Proof. Note that if L is Π -coherent, then we can find a subset Π (cid:4) of Π and a set of atoms P ⊆ atom(Π), such thatReduct(Π (cid:4), P ) only contains one rule r and L is a subclause of [{r}]C . Recall that the reduction Reduct(Π (cid:4), P ) is justto eliminate positive middle occurrences of P in rules of Π (cid:4) and remove the rules with heads of P if such positive mid-dle occurrences exist in Π (cid:4). Then it is easy to observe that |= [Π]C ⊃ [Reduct(Π (cid:4), P )]C . If L = [Reduct(Π (cid:4), P )]C ,then |= [Π]C ⊃ L. If L is a proper subclause of [Reduct(Π (cid:4), P )]C , then |= L ⊃ [Reduct(Π (cid:4), P )]C . This proves ourresult. (cid:2)Definition 4. Let Π be a logic program, ϕ, ϕ1 and ϕ2 three propositional formulas where ϕ1 and ϕ2 are in conjunctivenormal forms.(1) ϕ1 is called a consequence of ϕ with respect to Π if |= ϕ ⊃ ϕ1 and each conjunct of ϕ1 is Π -coherent. ϕ1 is astrongest consequence of ϕ with respect to Π if ϕ1 a consequence of ϕ with respect to Π and there does not existanother consequence ϕ(cid:4)(cid:7)≡ ϕ1) with respect to Π such that |= ϕ(cid:4)11 of ϕ (ϕ(cid:4)⊃ ϕ1.1Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778749(2) ϕ2 is called a premiss of ϕ with respect to Π if |= ϕ2 ⊃ ϕ and each conjunct of ϕ2 Π -coherent. ϕ2 is a weakestpremiss of ϕ with respect to Π if ϕ2 a premiss of ϕ with respect to Π and there does not exist another premiss ϕ(cid:4)2of ϕ (ϕ(cid:4)2(cid:7)≡ ϕ2) with respect to Π such that |= ϕ2 ⊃ ϕ(cid:4)2.Example 4. (Example 3 continued) It is easy to verify that [SForgetLP(Π, {a})]C is a strongest consequence ofForget([Π]C, {a}) and [WForgetLP(Π, {a})]C is a weakest premiss of Forget([Π]C, {a}). In fact, the following theo-rem confirms that this is always true.Theorem 1. Let Π be a logic program and P a set of atoms. Then [SForgetLP(Π, P )]C is a strongest consequence ofForget([Π]C, P ) with respect to Π and [WForgetLP(Π, P )]C is a weakest premiss of Forget([Π]C, P ) with respectto Π .Proof. We only prove the first part of the result, while the second part is proved in a similar way. To simplify ourproof, we consider set P to be a singleton, i.e. P = {p}. The general case can be proved by induction on the sizeof P . Without loss of generality, we assume program Π is of the following form: Π = Π1 ∪ Π2 ∪ Π3, where Π1only contains rules which are related to the process of the reduction of Π with respect to p, Π2 does not contain anyrules containing p in heads or positive bodies (i.e. Π2 is irrelevant to the reduction process) but contains rules havingp in their negative bodies, and Π3 does not contain any rules having p in their heads, positive or negative bodies.Obviously, Π3 is irrelevant to the process of strongly forgetting p in Π . In particular, we assume Π1 and Π2 have thefollowing forms:Π1:r1: p ← pos(r1), not neg(r1),. . . ,rk: p ← pos(rk), not neg(rk),rk+1: qk+1 ← p, pos(rk+1), not neg(rk+1),. . . ,rm: qm ← p, pos(rm), not neg(rm),Π2:rm+1: qm+1 ← pos(rm+1), not p, not neg(rm+1),. . . ,rn: qn ← pos(rn), not p, not neg(rn).In Π1, we may assume that p is not in pos(ri) for i = 1, . . . , m (otherwise, those rules having p as heads can beomitted from Π1 according to Observation 1). For Π2, on the other hand, p is not in pos(rj ) for j = m + 1, . . . , n.Then according to Definition 1, we have Reduct(Π, {p}) = Π (cid:4)1∪ Π2 ∪ Π3, where Π (cid:4)1 is as follows:r1,k+1: qk+1 ← pos(r1), pos(rk+1), not neg(r1), not neg(rk+1),. . . ,r1,m: qm ← pos(r1), pos(rm), not neg(r1), not neg(rm),. . . ,rk,k+1: qk+1 ← pos(rk), pos(rk+1), not neg(rk), not neg(rk+1),. . . ,rk,m: qm ← pos(rk), pos(rm), not neg(rk), not neg(rm).Note that p may occur in negative bodies of some rules in Π (cid:4)that no p occurs in negative bodies in all rules of Π (cid:4)in the case of Π2.1. However, to simplify our proof, we may consider1 because p’s occurrences in negative bodies have been presented750Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778Now we consider SForgetLP(Π, {p}). Clearly, SForgetLP(Π, {p}) = Π (cid:4)1∪ Π3, where Π2 is removed from Step 5in Definition 2. Then we conclude that(cid:3)Π, {p}SForgetLPC = [Π(cid:4)(cid:6)(cid:5)]C ∧ [Π3]C,]C consists of the following clauses:(cid:4)1where [Π (cid:4)1(cid:7)qk+1 ∨ ¬pos(r1) ∨ ¬pos(rk+1) ∨. . .(cid:7)qm ∨ ¬pos(rk) ∨ ¬pos(rm) ∨(cid:8)(cid:8)neg(r1) ∨(cid:8)(cid:9)neg(rk+1),3neg(rk) ∨(cid:8)(cid:9)neg(rm).Obviously, each clause of SForgetLP(Π, {p}) is Π -coherent.Now we consider Forget([Π]C, {p}). Firstly, it is to observe that(cid:3)[Π]C, {p}(cid:4)Forget= Φ ∧ [Π3]C,where Φ is formula ([Π1]C[p/true] ∧ [Π2]C[p/true]) ∨ ([Π1]C[p/false] ∧ [Π2]C[p/false]). [Π1]C[p/true] ∧[Π2]C[p/true] consists of the following clauses:(cid:8)qk+1 ∨ ¬pos(rk+1) ∨. . . ,qm ∨ ¬pos(rm) ∨(cid:8)neg(rk+1),neg(rm),and [Π1]C[p/false] ∧ [Π2]C[p/false] contains the following clauses:(cid:8)¬pos(r1) ∨. . . ,¬pos(rk) ∨neg(r1),(cid:8)neg(rk),(cid:8)neg(rm+1),qm+1 ∨ ¬pos(rm+1) ∨. . . ,qn ∨ ¬pos(rn) ∨(cid:8)neg(rn).Then by translating Φ into CNF, say Con(Φ), it is easy to see that all clauses of [Π (cid:4)1So [SForgetLP(Π, {p})]C is a consequence of Forget([Π]C, {p}) with respect to Π .]C are contained in Con(Φ).Observing Con(Φ)’s structure, we know that Con(Φ) also contains the following clauses:qk+1 ∨ ¬pos(rk+1) ∨. . . ,qk+1 ∨ ¬pos(rk+1) ∨. . . ,qm ∨ ¬pos(rm) ∨(cid:8)(cid:8)(cid:8)neg(rk+1) ∨ qm+1 ∨ ¬pos(rm+1) ∨neg(rm+1),(cid:8)neg(rk+1) ∨ qn ∨ ¬pos(rn) ∨(cid:8)neg(rn),neg(rm) ∨ qn ∨ ¬pos(rn) ∨(cid:8)neg(rn).According to the structure of Π , none of these clauses is Π -coherent. Therefore, there does not exist another conse-quence ϕ(cid:4) of Forget([Π]C, {p}) with respect to Π such that |= ϕ(cid:4) ⊃ [SForgetLP(Π, {p})]C . This proves our result. (cid:2)Theorem 1 actually states that under a certain set of propositional atoms P , the conjunctive normal form of thestrong forgetting of P in program Π is the strongest formula which is implied by the forgetting of P in the corre-sponding propositional theory, while the conjunctive normal form of the weak forgetting of P in Π is the weakest3 Here ¬pos(r) presents the disjunction of all negative atoms whose atoms occur in pos(r) andneg(r).(cid:10)neg(r) presents the disjunction of all atoms inY. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778751formula that implies it. So semantically, our notions of strong and weak forgettings in logic programs are strongestnecessary and weakest sufficient conditions respectively for the forgetting in the corresponding propositional theory.3.3. A semantic characterizationFrom previous presentation, we can see that our strong and weak forgettings are defined in a syntactic way. Thisis one of the major differences comparing with the forgetting notion in propositional theories, where an equivalentmodel theoretic semantics is provided for the resulting theory after forgetting some atoms [19]. Although we donot have corresponding model theoretic definitions for strong and weak forgettings, the following property preciselycharacterizes the stable models of strong and weak forgettings.Firstly, we observe that the consistency of program Π does not necessarily imply a consistent SForgetLP(Π, P )or WForgetLP(Π, P ) for some set of atoms P , and vice versa. For example, consider program Π = {a ←,b ← not a, not b}, then weakly forgetting a in Π will result in an inconsistent program {b ← not b}. Similarly,strongly forgetting a from an inconsistent program Π = {b ← not a, c ← b, not c} will get a consistent program{c ← b, not c}. Theorem 2 explains how this happens.Given program Π and a set of atoms P , we specify two programs X and Y . Program X is a subset of Π containingthree types of rules in Π : (1) for each p ∈ P , if p /∈ head(Π), then rule r ∈ Π with p ∈ pos(r) is in X; (2) for eachp ∈ P , if p /∈ pos(Π), then rule r ∈ Π with head(r) = {p} is in X; and (3) rule r ∈ Π with neg(r) ∩ P (cid:7)= ∅ but notof the types (1) and (2) is also in X. Clearly, X contains those rules of Π satisfying atom(r) ∩ P (cid:7)= ∅ but will not beaffected by Reduct(Π, P ). On the other hand, program Y is obtained as follows: for each rule r in X of the type (3),a replacement of r of the form: r (cid:4): head(r) ← pos(r), not(neg(r) − P ) is in Y . It should be noted that both X and Ycan be obtained in linear time in terms of the sizes of Π and P . Then we have the following result.Theorem 2. Let Π be a program and P a set of atoms. A set of atoms S is a stable model of SForgetLP(Π, P ) (orWForgetLP(Π, P ) resp.) iff program Π − X (or (Π − X) ∪ Y resp.) has a stable model S(cid:4) such that S = S(cid:4) − P .Proof. From the definition of X, we can see that X contains exactly all those rules of Π that are not affected byReduct(Π, P ) but have to be removed from SForgetLP(Π, P ). So we have SForgetLP(Π, P ) = Reduct(Π, P ) − X =Reduct((Π − X), P ) (we suppose that no valid rule is presented here as it does not influence the result). So it is easyto see that SForgetLP(Π, P ) has a stable model S iff Π − X has a stable model S(cid:4) where S = S(cid:4) − P . Similarly, wecan observe that WForgetLP(Π, P ) = Reduct((Π − X) ∪ Y, P ). (cid:2)It is interesting to note that given program Π and set of atoms P , although computing SForgetLP(Π, P ) orWForgetLP(Π, P ) may need exponential time (see Section 7), its stable models can be computed through someprogram that is obtained from Π in linear time.4. Logic program contexts—A framework for conflict solvingIn this section, we define a general framework called logic program contexts to represent a knowledge system whichconsists of multiple agents’ knowledge bases. We consider the issue of conflicts occurring in the reasoning within theunderlying logic program context. As will be shown, notions of strong and weak forgettings that we proposed earlierwill provide a basis for solving such conflicts.Definition 5 (Logic program context). A logic program context is an n-ary tuple Σ = (Φ1, . . . , Φn), where each Φi isa triplet (Πi, Ci, Fi) − Πi and Ci are two logic programs, and Fi ⊆ atom(Πi) is a set of atoms. We also call each Φithe ith component of Σ. A logic program context Σ is consistent if for each i, Πi ∪ Ci is consistent. Σ is conflict-freeif for any i and j , Πi ∪ Cj is consistent.In Definition 5, each component Φi in Σ represents agent i’s local situation, where Πi is agent i’s knowledgebase, Ci is a set of constraints that agent i should comply and will not change in any case, and Fi is a set of atomsthat agent i may forget if necessary. Now the problem of conflict solving under this setting can be stated as follows:given a logic program context Σ = (Φ1, . . . , Φn), which may not be consistent or conflict-free, how can we find an752Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778alternative logic program context Σ (cid:4) = (Φ(cid:4)some sense.1, . . . , Φ(cid:4)n) such that Σ (cid:4) is conflict-free and is closest to the original Σ inWe first present formal definitions about the solution that solves conflicts in a logic program context.Definition 6 (Solution). Given a logic program context Σ = (Φ1, . . . , Φn), where each Φi = (Πi, Ci, Fi). We call alogic program context Σ (cid:4) a solution that solves conflicts in Σ, if Σ (cid:4) satisfies the following conditions:(1) Σ (cid:4) is conflict-free;(2) For each Φ(cid:4)Pi ⊆ Fi .i in Σ (cid:4), Φ(cid:4)i= (Π (cid:4)i , Ci, Fi), where Π (cid:4)i= SForgetLP(Πi, Pi) or Π (cid:4)i= WForgetLP(Πi, Pi) for someWe denote the set of all solutions of solving conflicts in Σ as Solution(Σ).Definition 7 (Ordering on solutions). Given three logic program contexts Σ, Σ (cid:4) and Σ (cid:4)(cid:4) where Σ (cid:4), Σ (cid:4)(cid:4) ∈ Solution(Σ).We say that Σ (cid:4) is closer or as close to Σ as Σ (cid:4)(cid:4), denoted as Σ (cid:4) (cid:15)Σ Σ (cid:4)(cid:4), if for each i, Φ(cid:4)i , Ci, Fi) ∈ Σ (cid:4)iand Φ(cid:4)(cid:4)= WForgetLP(Πi, Pi) for some Pi ⊆ Fi , andiΠ (cid:4)(cid:4)= WForgetLP(Πi, Qi) for some Qi ⊆ Fi respectively, we have Pi ⊆ Qi ⊆ Fi . Weidenote Σ (cid:4) ≺Σ Σ (cid:4)(cid:4) if Σ (cid:4) (cid:15)Σ Σ (cid:4)(cid:4) and Σ (cid:4)(cid:4) (cid:7)(cid:15)Σ Σ (cid:4).= SForgetLP(Πi, Qi) or Π (cid:4)(cid:4)i= SForgetLP(Πi, Pi) or Π (cid:4)ii , Ci, Fi) ∈ Σ (cid:4)(cid:4), where Π (cid:4)= (Π (cid:4)(cid:4)= (Π (cid:4)iProposition 4. (cid:15)Σ is a partial ordering.Proof. From the definition of (cid:15)Σ , it is easy to see that (cid:15)Σ is reflexive and antisymmetric. So we only need to show(cid:15)Σ is transitive, and this is obvious according to Definition 7. (cid:2)Definition 8 (Preferred solution). Given two logic program contexts Σ and Σ (cid:4). We say that Σ (cid:4) is a preferred so-lution that solves conflicts in Σ, if Σ (cid:4) ∈ Solution(Σ) and there does not exist another Σ (cid:4)(cid:4) ∈ Solution(Σ) such thatΣ (cid:4)(cid:4) ≺Σ Σ (cid:4).It should be noted that in order to achieve a preferred solution, both strong and weak forgettings may have to applyalternatively. Consider the following simple example.Example 5. Let Σ = (Φ1, Φ2), whereΦ1:Φ2:Π1: a ←,b ← a, not c,d ← a, not e,f ← d,C1: ← d, not f,← f, not d,F1: {a, b, c},Π2: c ←,d ← not e,e ←,f ← d,C2: ← b, not c,F2: {a, b, c, d, e, f }.Φ=It is easy to see that Σ is consistent but not conflict-free because neither Π1 ∪ C2 nor Π2 ∪ C1 is consistent. Nowconsider two logic program contexts Σ1 = (Φ(cid:4)2) and Σ2 = (Φ(cid:4)(cid:4)(cid:3)(cid:3)Π1, {c}SForgetLP(cid:3)(cid:3)Φ2, {e}WForgetLP(cid:3)(cid:3)Π1, {b, c}WForgetLP(cid:4)(cid:3)(cid:3), C2, F2Φ2, {e}WForgetLP(cid:4)(cid:4), C1, F1,(cid:4)(cid:4), C2, F2,(cid:4), C1, F1(cid:4).2 ), where1 , Φ(cid:4)(cid:4)1, Φ(cid:4)(cid:4),and===ΦΦΦ(cid:4)1(cid:4)2(cid:4)(cid:4)1(cid:4)(cid:4)2It can be verified that both Σ1 and Σ2 are solutions that solve the conflict in Σ, but only Σ1 is a preferred solution.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778753From the above example, we can see that to solve conflicts in a logic program context, the agent may applystrong forgettings, weak forgettings, or both to obtain a (preferred) solution. In this sense, the agent has a freedom tochoose the ways of conflict solving if no specific constraint is taken into account. It is noted that sometimes solvingconflict through strong forgetting will loose more atoms than weak forgetting, or vice versa. Therefore, in order tominimally forget atoms from a logic program, the agent can apply strong and weak forgettings alternatively in differentcomponents. However, in practice, it may be more desirable for an agent to use a unified approach in conflict solving.Our approach provided here can certainly accommodate this requirement by simply re-defining the solution of a logicprogram context by applying strong or weak forgetting only.Example 6. We consider a conflict solving scenario. A couple John and Mary are discussing their family investmentplan. They consider to invest four types of different shares shareA, shareB, shareC and shareD, where shareA andshareB are of high risk but also have high returns, and shareC and shareD are property investment shares and henceare of lower risk and may be suitable for a long term investment. John is very interested in shareA and wants to buyit definitely. He also tends to invest shareB if they invest neither shareC nor shareD. However, if they do not investshareB, John may consider to invest shareC or shareD if the house price will keep growing, which John is actuallynot sure yet. But John does not consider to invest both of them. On the other hand, Mary is more conservative. Sheprefers to invest both shareC and shareD because she believes that the house price will continue growing as she isconfident that the government has no plan to increase the Reserve Bank interest. Mary definitely does not considerto invest both shareA and shareB. At most, she may consider to buy some shareB if they invest neither shareA norshareC. But Mary insists that they should invest at least one of shareC and shareD in any case. Now how can Johnand Mary negotiate to achieve a common agreement?We first represent John and Mary’s investment preferences as the following programs respectively:ΠJ :r1: shareA ←,r2: shareB ← not shareC, not shareD,r3: shareC ← houseIncrease, not shareB, not shareD,r4: shareD ← houseIncrease, not shareB, not shareC,ΠM :r5: shareC ← houseIncrease,r6: shareD ← houseIncrease,r7: shareB ← not shareA, not shareC,r8: houseIncrease ← not interestUp.To negotiate with each other, John and Mary set up their conditions respectively that they do not want to compro-mise:CJ :CM :← not shareA,← shareC, shareD,and← shareA, shareB,← not shareC, not shareD.John and Mary then specify a logic program context to solve the conflict about their family investment plan:ΣJM = ((ΠJ , CJ , FJ ), (ΠM , CM , FM )), where FJ = {shareB, shareC, shareD} (note that shareA is not a forgettableatom for John as he definitely wants to buy it) and FM = {shareA, shareB, shareC, shareD}.Unfortunately, it is easy to check that ΣJM has no (preferred) solution. That means, it is impossible for John andMary to solve their conflict by just weakening their own belief sets. So John and Mary realize that they have to make754Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778further compromise that both of them should not only weaken their own belief sets, but also take the other’s beliefsinto account. However, their strategy is to take the other’s beliefs as little as possible. To this end, John and Maryspecify a new logic program context as follows: Σ NewJMJ ), (ΠM ∪ ΔJ , CM , F(cid:4)= ((ΠJ ∪ ΔM , CJ , F(cid:4)M )), where555,← not hr (cid:4)ΔM :(cid:4)5: shareC ← houseIncrease, not lr (cid:4)r(cid:4)r,51: lr (cid:4)(cid:4)6: shareD ← houseIncrease, not lr (cid:4)r(cid:4)r,61: lr (cid:4)(cid:4)7: shareB ← not shareA, not shareC, not lr (cid:4)r(cid:4)r71: lr (cid:4),(cid:4)8: houseIncrease ← not interestUp,r(cid:4)r,81: lr (cid:4)← not hr (cid:4)← not hr (cid:4)← not hr (cid:4),7766688,7not lr (cid:4)8,2111,← not hr (cid:4)← not hr (cid:4)ΔJ :(cid:4)1: shareA ← not lr (cid:4)r(cid:4),11: lr (cid:4)r(cid:4)2: shareB ← not shareC, not shareD, not lr (cid:4)r(cid:4)21: lr (cid:4)r(cid:4)3: shareC ← houseIncrease, not shareB, not shareD, not lr (cid:4)r(cid:4)r31: lr (cid:4)(cid:4)4: shareD ← houseIncrease, not shareB, not shareC, not hr (cid:4)r(cid:4)41: lr (cid:4)r= FJ ∪ {hr (cid:4)| i = 5, . . . , 8} and F (cid:4)M= FM ∪ {hr (cid:4)← not hr (cid:4)← not hr (cid:4),,,,3234234, lr (cid:4)ii, lr (cid:4)ii,,4and F (cid:4)Jduced atoms).| i = 1, . . . , 4} (hr (cid:4)(i = 1, . . . , 8) are newly intro-, lr (cid:4)iij, lr (cid:4)iΣ NewLet us take a closer look at ΔM . During the conflict solving, if none of hr (cid:4)i(i = 5, . . . , 8) has been stronglyor weakly forgotten, then all rules r (cid:4)i (i = 5, . . . , 8) in ΔM equipped with the corresponding rules from ΠM will bedefeated. In this case, John does not need to take any of Mary’s beliefs into his consideration. On the other hand, ifis weakly forgotten), then rules r (cid:4)for some j (5 (cid:2) j (cid:2) 8) hr (cid:4)j in ΔM will be initiated) (i = 5, . . . , 8) willand hence will affect John’s decision for conflict solving. As only a minimal number of hr (cid:4)(or lr (cid:4)iibe strongly forgotten (or weakly forgotten, resp.) in the conflict solving, John just takes a minimal number of Mary’srules for his consideration. The same explanation applies for ΔJ .is strongly forgotten (or lr (cid:4)jJM has a unique preferred solution ((Π (cid:4)(cid:3)ΠJ ∪ ΔM , {shareB, lr (cid:4)= WForgetLP(cid:3)ΠM ∪ ΔJ , {shareC, lr (cid:4)= WForgetLPJ , CJ , F (cid:4)(cid:4)},(cid:4).J has two stable models which include {shareA, shareC} and {shareA, shareD} respectively, and Π (cid:4)Π (cid:4)M has one stablemodel including shareA and shareD. Therefore, John has two options: either to invest shareA and shareC, or to investshareA and shareD, while Mary will only consider to invest shareA and shareD. Finally, John and Mary can reach anagreement to invest shareA and shareD.M , CM , F (cid:4)M )), whereJ ), (Π (cid:4)(cid:4)J(cid:4)MandΠΠ}81Example 6 presents an application of our approach to solve complex logic program conflicts involving negotiationand belief merging that most of current methods have difficulties to deal with.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–7787555. Semantic propertiesIn this section, we study important semantic properties in relation to strong and weak forgettings and logic programcontexts.5.1. IrrelevanceIrrelevance is an important issue related to forgetting [18]. Basically, if we are able to answer an query q against alogic program Π , i.e. Π |= q, then we are interested in knowing whether we still can answer this query in the resultingprogram after strongly or weakly forgetting a set of atoms from Π , because this will enable us to significantly simplifythe inference problem in the resulting logic program. We first give a formal definition of irrelevance in relation tostrong and weak forgetting.Definition 9 (Irrelevance). Let Π be a logic program and P a set of atoms. We say that atom a is irrelevant to thestrong forgetting (or weak forgetting) of P from Π , or simply say that a is s-irrelevant (or w-irrelevant, resp.) to Pin Π , if Π |= a iff SForgetLP(Π, P ) |= a (or WForgetLP(Π, P ) |= a resp.). We say that a is irrelevant to P in Π if ais either s-irrelevant or w-irrelevant to P in Π .Trivially, if Π is inconsistent, then a is s-irrelevant (w-irrelevant) to any P in Π iff SForgetLP(Π, P ) |= a (orWForgetLP(Π, P ) |= a, resp.). Also if for some P ⊆ atom(Π), SForgetLP(Π, P ) (WForgetLP(Π, P )) is inconsistent,then a is s-irrelevant (or w-irrelevant, resp.) to P in Π iff Π |= a. To provide a general characterization result forirrelevance, we need a notion of support.Definition 10. Let Π be a program and a an atom. We define a’s support with respect to Π to be a set of atomsSupport(a) specified as follows:S0 =Si+1 = Si ∪(cid:11)p | p ∈ body(r) where r ∈ Π and head(r) = {a}(cid:12);(cid:11)p | p ∈ body(r) where r ∈ Π and head(r) ⊆ Si∞(cid:13)(cid:12);Support(a) =Si.i=0An atom p ∈ Support(a) is called a positive (or negative) support of a if p ∈ pos(r) (or ∈ neg(r), resp.) for some ruler occurring in defining Support(a).4Basically, Support(a) contains all atoms that occur in those rules related to a’s derivation in program Π . Therefore,changing or removing any rules which contain atoms in Support(a) may affect atom a. It turns out that the notion ofsupport plays an important role in deciding the irrelevance.Theorem 3. Let Π be a logic program, P a set of atoms and a an atom. Suppose Π , SForgetLP(Π, P ) andWForgetLP(Π, P ) are consistent. Then the following results hold.(1) If a /∈ head(Π), then a is irrelevant to P in Π ;(2) If a ∈ P , then a is irrelevant to P in Π iff Π (cid:7)|= a;(3) If a /∈ P and P ∩ Support(a) = ∅, then a is irrelevant to P in Π .Proof. Proofs for Results 1 and 2 are trivial. Here we only prove Result 3. To prove this result, we need a result aboutprogram splitting from [26]. Before we present this program splitting result, we introduce a notion. Given a programΠ and a set of atoms S, we use e(Π, S) to denote the program obtained from Π by deleting: (1) each rule in Π havinga form not a in its body with a ∈ S; and (2) all atoms a in the bodies of the remaining rules with a ∈ S. Intuitively,4 Note that an atom in Support(a) could be both positive and negative supports of a.756Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778e(Π, S) can be viewed as a simplified form of Π given those atoms in S to be true. Then we can re-state Theorem 5in [26] under the normal logic program setting:A set of atoms S is a stable model of program Π if and only if Π = Π1 ∪ Π2 such that body(Π1) ∩ head(Π2) = ∅,and S = S1 ∪ S2, where S1 is a stable model of Π1 and S2 is a stable model of program e(Π2, S1).From the definition of Support(a), we can see that Π can be expressed as Π = Π1 ∪ Π2, where Π1 is the subsetof Π containing all rules mentioned in Support(a). So we have Π1 ∩ Π2 = ∅. Also, it is observed that body(Π1) ∩head(Π2) = ∅. Because if this is not true, then there must be some rule r ∈ Π2 such that body(r) ∩ body(Π1) (cid:7)= ∅.According to Π1’s construction, this leads to r ∈ Π1 as well. That is, Π1 ∩ Π2 (cid:7)= ∅. This is a contradiction. SinceP ∩ Support(a) = ∅, it is clear that all rules containing some atoms in P are in Π2. We may use Π(P ) to denote thisset of rules of Π .From body(Π1) ∩ head(Π2) = ∅, we know that each stable model S of Π can be expressed as S = S1 ∪ S2, whereS2 is a stable model of program e(Π2, S1). Also, since rule r a ∈ Π1, this implies that Π |= a iff Π1 |= a.Now from the definitions of strong and weak forgettings and condition Π(P ) ⊆ Π2, we know that both strong andweak forgettings only influence rules in Π2. So we haveSForgetLP(Π, P ) = Π1 ∪ Π †,WForgetLP(Π, P ) = Π1 ∪ Π ‡,andwhere head(Π †) ⊆ head(Π2) and head(Π ‡) ⊆ head(Π2). This follows:Π1 ∩ Π † = ∅, body(Π1) ∩ head(Π †) = ∅,Π1 ∩ Π ‡ = ∅, body(Π1) ∩ head(Π ‡) = ∅.andBy the result stated above, we have that each stable model Ss of SForgetLP(Π, P ) can be expressed as Ss = S1 ∪ S†,and each stable model Sw of WForgetLP(Π, P ) can be expressed as Sw = S1 ∪ S‡, where S1 is a stable model of Π1,S† and S‡ are stable models of Π † and Π ‡ respectively.Finally, from the observation that Π |= a iff Π1 |= a, we have (Π |= a iff SForgetLP(Π, P ) |= a) and (Π |= a iffWForgetLP(Π, P ) |= a). This proves our result. (cid:2)Theorem 3 provides common conditions under which atom a is both s-irrelevant and w-irrelevant to P in Π .However, we should note that in general, an atom’s s-irrelevance does not imply its w-irrelevance, and vice versa.Usually we need to deal with these two types of irrelevances separately. The following theorem illustrates differentsufficient conditions to ensure these irrelevances respectively.Theorem 4. Let Π be a logic program, P a set of atoms and a an atom where a /∈ P . Suppose that Π ,SForgetLP(Π, P ) and WForgetLP(Π, P ) are consistent. Then the following results hold:(1) If for each p ∈ P ∩ Support(a), p is a negative support of a and Π (cid:7)|= p, then a is w-irrelevant to P in Π ;(2) If for each p ∈ P ∩ Support(a), p is a negative support of a and Π |= p, then a is s-irrelevant to P in Π .Proof. We only prove Result 1, while Result 2 can be proved in a similar way. From the proof of Theorem 3, givenSupport(a), program Π can be expressed as Π = Π1 ∪ Π2, where Π1 ∩ Π2 = ∅, Π1 contains all rules used in comput-ing Support(a), and Π |= a iff Π1 |= a. Now let us consider WForgetLP(Π, P ). We will show that WForgetLP(Π, P )can be also expressed as WForgetLP(Π, P ) = Π (cid:4)|= a iff Π1 |= a.1To simplify our presentation, we may assume P = {p} where the proof for the general case can be easily extendedfrom this special case. Without loss of generality, we can consider that Π = Π1 ∪ Π2, where Π1 includes the followingrules in relation to P (note that Π1 may also contain other rules):2, such that body(Π (cid:4)) ∩ head(Π (cid:4)2) = ∅, and Π (cid:4)∪ Π (cid:4)1r1: head(r1) ← pos(r1), not p, not neg(r1),r2: p ← pos(r2), not neg(r2),r3: head(r3) ← p, pos(r3), not neg(r3),Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778757and Π2 includes the following rules related to P (again, Π2 may contain other rules):r4: head(r4) ← p, pos(r4), not neg(r4),r5: head(r5) ← pos(r5), not p, not neg(r5),we should indicate that Π2 does not contain a rule with head of p, because this rule will be contained in Π1 as a ruleused for computing Support(a).Clearly, by weakly forgetting {p} in Π , only rules r1–r5 will be affected, and other rules do remain unchanged.1 are following2, where the only difference between Π1 and Π (cid:4)∪ Π (cid:4)Therefore, we have WForgetLP(Π, {p}) = Π (cid:4)1rules in Π (cid:4)1:(cid:4)1: head(r1) ← pos(r1), not neg(r1),r(cid:4)(cid:3)(cid:4)pos(r2) ∪ pos(r3)3: head(r3) ←rand the only difference between Π2 and Π (cid:4)(cid:4)(cid:3)pos(r2) ∪ pos(r4)(cid:4)4: head(r4) ←r(cid:4)5: head(r5) ← pos(r5), not neg(r5).r1) ∩ head(Π (cid:4)(cid:4)(cid:3)neg(r2) ∪ neg(r3), not2 are the following rules in Π (cid:4)2:(cid:4)(cid:3)neg(r2) ∪ neg(r4),, not,This concludes that body(Π (cid:4)1, weaklyforgetting p actually does not affect the derivation of head(r3), while head(r1)’s derivation might be affected sincenot p has been removed from r (cid:4)1. However, note that Π (cid:7)|= a, in the original rule r1 in Π1, formula not p does notplay any role. So removing not p has no any effect on a’s derivation. This follows that Π (cid:4)|= a iff Π1 |= a. So a is1w-irrelevant to {p} in Π . (cid:2)|= a iff Π1 |= a. Observing that in Π (cid:4)2) = ∅. Now we show that Π (cid:4)1Example 7. Consider the following program Π :a ← not b,c ← d,e ← c,b ← not c.It is easy to see that a is w-irrelevant to {c} in Π . This is because Π (cid:7)|= a and WForgetLP(Π, {c}) = {a ← not b,e ← d, b ←} (cid:7)|= a. Indeed, since Support(a) = {b, c} where c is a negative support and Π (cid:7)|= c, the condition of Result1 of Theorem 4 holds. We can also verify that a is not s-irrelevant to {c} in Π .Now suppose we add an extra rule into Π: Π (cid:4) = Π ∪ {d ←}. Here we still have Support(a) = {b, c} where c is anegative support. However, since Π (cid:4) |= c, according to Result 2 in Theorem 4, a is s-irrelevant to {c} in Π (cid:4). It is alsoobserved that a is not w-irrelevant to {c} in Π (cid:4).We can generalize the notion of irrelevance to the logic program context. Formally, let Σ be a logic program contextand a an atom, we say that a is derivable from Σ’s ith component, denoted as Σ |=i a, if Φi = (Πi, Ci, Fi) ∈ Σ andΠi |= a.Definition 11 (Irrelevance wrt logic program contexts). Let Σ and Σ (cid:4) be two logic program contexts where Σ (cid:4) ∈Solution(Σ), and a an atom. We say that a is irrelevant with respect to Σ and Σ (cid:4) on their ith components, or simplysay that a is (Σ, Σ (cid:4))i -irrelevant, if Σ |=i a iff Σ (cid:4) |=i a.Given a logic program context Σ and an atom a, we would like to know whether there is a preferred solution Σ (cid:4)of Σ such that a is (Σ, Σ (cid:4))i -irrelevant. To answer this question, we need to consider the preservation of irrelevancealong the preferred ordering (cid:15)Σ on solutions of Σ. That is, if Σ (cid:4), Σ (cid:4)(cid:4) ∈ Solution(Σ), Σ (cid:4) (cid:15)Σ Σ (cid:4)(cid:4) and a is (Σ, Σ (cid:4)(cid:4))i -irrelevant, then under what conditions a is also (Σ, Σ (cid:4))i -irrelevant. If for each of those more preferred solutions, a’sirrelevance is preserved, then eventually, we can obtain a’s irrelevance with respect to Σ and its preferred solution.758Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778We formalize this idea as follows. Let Σ, Σ (cid:4), Σ (cid:4)(cid:4) be three logic program contexts and Σ (cid:4), Σ (cid:4)(cid:4) ∈ Solution(Σ). WeΣ Σ (cid:4)(cid:4), if forsay that Σ (cid:4) and Σ (cid:4)(cid:4) are forgetting-congruent on their ith components with respect to Σ, denoted as Σ (cid:4) ∼ieach Φi = (Πi, Ci, Fi) ∈ Σ,orΦΦ(cid:4)i(cid:4)(cid:4)i==ΦΦ(cid:4)i(cid:4)(cid:4)i==(cid:3)SForgetLP(Πi, P(cid:3)SForgetLP(Πi, P(cid:4)(cid:4)), Ci, Fi(cid:4)(cid:4)), Ci, Fi(cid:4)∈ Σ,(cid:4)(cid:4)(cid:4)∈ Σ,(cid:3)WForgetLP(Πi, P(cid:3)WForgetLP(Πi, P(cid:4)(cid:4)), Ci, Fi(cid:4)(cid:4)), Ci, Fi(cid:4)∈ Σ,(cid:4)(cid:4)(cid:4)∈ Σ,where P (cid:4), P (cid:4)(cid:4) ⊆ Fi . In other words, if two solutions of Σ are forgetting-congruent on their ith components, it meansthat both of their ith components are obtained by performing either strong forgettings or weaking forgettings on somesets of atoms from Σ’s ith component. We say that two solutions Σ (cid:4) and Σ (cid:4)(cid:4) of Σ are forgetting-congruent, denoted asΣ (cid:4) ∼Σ Σ (cid:4)(cid:4), if Σ (cid:4) ∼iΣ Σ (cid:4)(cid:4) for each i. The following theorem shows that forgetting-congruence is a sufficient conditionfor preserving irrelevance in terms of the preferred ordering on solutions.Theorem 5. Let Σ, Σ (cid:4), Σ (cid:4)(cid:4) be three logic program contexts and Σ (cid:4), Σ (cid:4)(cid:4) ∈ Solution(Σ), a an atom. Suppose Σ (cid:4) (cid:15)ΣΣ (cid:4)(cid:4) and a is (Σ, Σ (cid:4)(cid:4))i -irrelevant. Then a is (Σ, Σ (cid:4))i -irrelevant if Σ (cid:4) ∼iΣ Σ (cid:4)(cid:4).= (Π (cid:4)(cid:4)iProof. To prove this theorem, we need to show that for Σ (cid:4), Σ (cid:4)(cid:4) ∈ Solution(Σ), if Φ(cid:4)i= (Π (cid:4)Fi) and Φ(cid:4)(cid:4)iiWForgetLP(Πi, P (cid:4)(cid:4)), Ci, Fi), where Πi is in some Φi ∈ Σ, Φ(cid:4)iΠ (cid:4)(cid:4)iassume that all Πi , Π (cid:4)= (Π (cid:4)= SForgetLP(Πi, P (cid:4)), Ci,i= WForgetLP(Πi, P (cid:4)), Ci, Fi) and Φ(cid:4)(cid:4)=i∈ Σ (cid:4), Φ(cid:4)(cid:4)∈ Σ (cid:4)(cid:4), P (cid:4) ⊆ P (cid:4)(cid:4) ⊆ Fi , and Πi |= a iffi|= a. Recall that we do not consider invalid strong and weak forgettings, so here wei are consistent programs.|= a, then Πi |= a iff Π (cid:4)ii and Π (cid:4)(cid:4)= SForgetLP(Πi, P (cid:4)(cid:4)), Ci, Fi), or Φ(cid:4)iIn order to avoid unnecessary tediousness in our proof, we consider a simplified case in our proof where P (cid:4) = {p}and P (cid:4)(cid:4) = {p, q}. Note that the proof for the general case of P (cid:4) ⊆ P (cid:4)(cid:4) can be obtained in a similar way of this proof.Under the assumption of P (cid:4) = {p} and P (cid:4)(cid:4) = {p, q}, program Πi may be simplified as a form of Πi = Πi1 ∪ Πi2 ∪ Πi3,where Πi1 contains the following rules:= (Π (cid:4)(cid:4)ir1: p ← pos(r1), not neg(r1),(cid:4)(cid:4)(cid:4)1: p ← q, pos(r1), not neg(r1),rr2: q ← pos(r2), not neg(r2),(cid:4)(cid:4)2: q ← p, pos(r2), not neg(rrr3: head(r3) ← p, pos(r3), not neg(r3),r4: head(r4) ← q, pos(r4), not neg(r4).(cid:4)2),We assume p and q do not occur in anywhere else in Πi1. Πi2 contains the rules not having p and q in their headsand positive bodies, but only having p and q in their negative bodies:r5: head(r5) ← pos(r5), not p, not q, . . . ,r6: head(r6) ← pos(r6), not p, . . . ,r7: head(r7) ← pos(r7), not q, . . . .Finally, Πi3 consists of rules not containing p and q in anywhere.Case 1. Suppose Π (cid:4)i= SForgetLP(Πi, {p}) and Π (cid:4)(cid:4)i= SForgetLP(Πi, {p, q}). In this case, Π (cid:4)i and Π (cid:4)(cid:4)i are asfollows:Π(cid:4)i :r2: q ← pos(r2), not neg(r2),(cid:4)(cid:4)(cid:4)21: q ←, not2)r(cid:3)pos(r1) ∪ pos(r(cid:3)neg(r1) ∪ neg(r(cid:4)(cid:4),2)Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778759Π(cid:4)(cid:3)neg(r1) ∪ neg(r3),(cid:4)(cid:3)(cid:4)1) ∪ neg(r3)neg(r,(cid:4)(cid:3)r31: head(r3) ←pos(r1) ∪ pos(r3), not(cid:4)(cid:3)(cid:4)(cid:4)1) ∪ pos(r3)31: head(r3) ← q,, notpos(rrr4: head(r4) ← q, pos(r4), not neg(r4),r7: head(r7) ← pos(r7), not q, . . . ,Πi3,(cid:4)(cid:4)i :r31: head(r3) ←r32: head(r3) ←(cid:4)32: head(r3) ←rr33: head(r4) ←(cid:4)33: head(r4) ←rΠi3.(cid:4)(cid:3)(cid:4)(cid:3)pos(r1) ∪ pos(r3)neg(r1) ∪ neg(r3), not,(cid:4)(cid:3)(cid:3)(cid:4)1) ∪ pos(r3)pos(r2) ∪ pos(rneg(r2) ∪ neg(r, not(cid:4)(cid:3)(cid:4)(cid:4)1) ∪ pos(r3)2) ∪ pos(rpos(r1) ∪ pos(r, not(cid:4)(cid:3)(cid:4)(cid:3)neg(r2) ∪ neg(r4)pos(r2) ∪ pos(r4), not,(cid:3)(cid:4)(cid:3)(cid:4)neg(r1) ∪ neg(r2) ∪ pos(r4)pos(r1) ∪ pos(r, not(cid:4)(cid:4)1) ∪ neg(r3)(cid:3)(cid:4)2) ∪ neg(rneg(r1) ∪ neg(r,(cid:4)(cid:4)1) ∪ neg(r3),(cid:4)(cid:4)2) ∪ neg(r4),Now we assume that for some atom a, Πi |= a iff Π (cid:4)(cid:4)i= {r | r ∈ Πi and occurs in the definition of Support(a)}. Let Π|= a, where Π ∗iiff Π ∗iin the definition of Support(a)} and ΠΠ (cid:4)(cid:4)iΠ (cid:4)(cid:4)i|= a, we have Π ∗i|= a.Comparing structures of programs Πi and Π (cid:4)(cid:4)|= a iff Π(cid:4)(cid:4)∗i(cid:4)(cid:4)∗i= {r | r ∈ Π (cid:4)(cid:4)|= a. Then we will show that Π|= a. From the proof of Theorem 3, we know that Πi |= ai and occursi and occurs in the definition of Support(a)}. From Πi |= a iff|= a, this will follow Πi |= a iff= {r | r ∈ Π (cid:4)|= a iff Π(cid:4)∗i(cid:4)∗i(cid:4)∗ii even if it is in Πi because these rules are removed from Π (cid:4)(cid:4)a even if they are in Π ∗deriving a in Π (cid:4). On the other hand, for all rules in Π(cid:4)(cid:4)∗i by the corresponding rules after reduction on {q}. Then we have the fact that Πreplaced in Πfor all atoms which are not q. Now consider that a = q. since Π (cid:4)(cid:4)i(cid:4)(cid:4)∗Then we can conclude that Πir1, r2 and r (cid:4)holds.i , it is clear that rules r5, r6 and r7 do not play any role in derivingi . Consequently, rule r7 does not play any role inor have been(cid:4)∗|= bi(cid:7)|= q, and q is (Σ, Σ (cid:4)(cid:4))i -irrelevant, we have Πi (cid:7)|= q.(cid:7)|= q as well because if this is not the case, we will have Πi |= q (observing that rules(cid:7)|= q. So the result2 used to derive q can be replaced by r2 and r (cid:4), they are either in Π(cid:4)(cid:4)∗ii ), which contradicts with Π (cid:4)(cid:4)(cid:4)(cid:4)∗i|= b iff Π21 in Π (cid:4)(cid:4)(cid:4)∗i(cid:4)∗iiCase 2. Suppose Π (cid:4)i= WForgetLP(Πi, {p}) and Π (cid:4)(cid:4)i= WForgetLP(Πi, {p, q}). In this case, we have:ΠΠ(cid:4)i :r2: q ← pos(r2), not neg(r2),(cid:3)(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)(cid:4)neg(r1) ∪ neg(rpos(r1) ∪ pos(r21: q ←, notr2),2)(cid:4)(cid:3)(cid:4)(cid:3)r31: head(r3) ←neg(r1) ∪ neg(r3)pos(r1) ∪ pos(r3), not,(cid:4)(cid:3)(cid:4)(cid:3)(cid:4)(cid:4)(cid:4)1) ∪ neg(r3)1) ∪ pos(r3)31: head(r3) ← q,neg(r, notpos(rr,r4: head(r4) ← q, pos(r4), not neg(r4),(cid:4)5: head(r5) ← pos(r5), not q, . . . ,r(cid:4)6: head(r5) ← pos(r5), . . . ,rr7: head(r7) ← pos(r7), not q, . . . ,Πi3,(cid:4)(cid:4)i :r31: head(r3) ←r32: head(r3) ←(cid:4)32: head(r3) ←rr33: head(r4) ←(cid:4)(cid:3)(cid:4)(cid:3)pos(r1) ∪ pos(r3)neg(r1) ∪ neg(r3), not,(cid:4)(cid:3)(cid:3)(cid:4)1) ∪ pos(r3)pos(r2) ∪ pos(rneg(r2) ∪ neg(r, not(cid:4)(cid:3)(cid:4)(cid:4)1) ∪ pos(r3)2) ∪ pos(rpos(r1) ∪ pos(r, not(cid:4)(cid:3)(cid:4)(cid:3)neg(r2) ∪ neg(r4)pos(r2) ∪ pos(r4), not,(cid:4)(cid:4)1) ∪ neg(r3),(cid:4)2) ∪ neg(r(cid:3)neg(r1) ∪ neg(r(cid:4)(cid:4)1) ∪ neg(r3),760Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778(cid:3)pos(r1) ∪ pos(r(cid:4)(cid:4)2) ∪ pos(r4)(cid:3)neg(r1) ∪ neg(r(cid:4)(cid:4)2) ∪ neg(r4),, not(cid:4)33: head(r4) ←r(cid:4)(cid:4)5 : head(r5) ← pos(r5), . . . ,r(cid:4)(cid:4)6 : head(r6) ← pos(r6), . . . ,r(cid:4)(cid:4)7 : head(r7) ← pos(r7), . . . ,rΠi3.In a similar way as described above, we can show that Π (cid:4)(cid:4)i|= a iff Π (cid:4)i|= a. (cid:2)Corollary 1. Let Σ (cid:4), Σ (cid:4)(cid:4) ∈ Solution(Σ), where Σ (cid:4)(cid:4) is a preferred solution of Σ, and a an atom. Then a is (Σ, Σ (cid:4)(cid:4))i -irrelevant if a is (Σ, Σ (cid:4))i -irrelevant and Σ (cid:4) ∼iΣ Σ (cid:4)(cid:4).Example 8. Let us consider a logic program context Σ = (Φ1, Φ2, Φ3), whereΦ1:Φ2:Φ3:Π1: a ← not b,c ← a,d ← not e,C1: ∅,F1: {a, b, c, d, e},Π2: d ←,b ← not c,C2: ← not d,e ← c,F2: {b, c, d},Π3: b ← not a,c ← not a,d ← not c,C3: ← c, d,F3: {a, b, c, d}.It is easy to see that conflicts occur in Σ. That is, Π1 ∪ C2, Π1 ∪ C3, and Π3 ∪ C2 are inconsistent. By performing strongand weak forgettings, we obtain a solution of Σ: Σ (cid:4) = (Φ(cid:4)= (Π (cid:4)3, C3, F3),Π (cid:4)= SForgetLP(Π3, {a}) = {d ← not c}. We can verify that atom a1is (Σ, Σ (cid:4))i -irrelevant for all i = 1, 2, 3.= WForgetLP(Π1, {a, c, e}) = {d ←} and Π (cid:4)31, C1, F1), Φ(cid:4)3), where Φ(cid:4)On the other hand, by weakly forgetting only {c, e} in Π1, we further obtain a more preferred solution of Σ: Σ (cid:4)(cid:4) =(Φ(cid:4)(cid:4)1 , Φ2, Φ(cid:4)= WForgetLP(Π1, {c, e}) = {a ← not b, d ←}. In fact, Σ (cid:4)(cid:4) is alsoa preferred solution of Σ. Since Σ (cid:4) ∼Σ Σ (cid:4)(cid:4), according to Corollary 1, we know that a is also (Σ, Σ (cid:4)(cid:4))i -irrelevant(i = 1, 2, 3).1 , C1, F1), and Π (cid:4)(cid:4)3), where Φ(cid:4)(cid:4)1, Φ2, Φ(cid:4)= (Π (cid:4)(cid:4)= (Π (cid:4)31115.2. Characterizing solutions for conflict solvingIn this subsection, we focus our study on the semantic characterization on conflict solving solutions, because suchcharacterizations are useful to optimize the procedure of conflict solving in logic program contexts. To begin with, wegive a general result for the existence of preferred solutions for arbitrary logic program context.Theorem 6. Let Σ be a logic program context. Σ has a preferred solution iff Solution(Σ) (cid:7)= ∅.Proof. Obviously, if Σ has a preferred solution, then Solution(Σ) (cid:7)= ∅. Now we assume that Solution(Σ) (cid:7)= ∅. In thiscase, we only need to show that for each Σ (cid:4) ∈ Solution(Σ), a new solution Σ (cid:4)(cid:4) can always be generated from Σ (cid:4) suchthat Σ (cid:4)(cid:4) (cid:15)Σ Σ (cid:4). If no such solution can be generated from Σ (cid:4), then Σ (cid:4) itself is a preferred solution. We present thefollowing algorithm for this purpose.Algorithm: Solution-GenerationInput: Σ = (Φ1, . . . , Φn) and Σ (cid:4) = (Φ(cid:4)1, . . . , Φ(cid:4)n), where= (Π (cid:4)i , Ci, Fi);Φi = (Πi, Ci, Fi) and Φ(cid:4)i1 , . . . , Φ(cid:4)(cid:4)n );Output: Σ (cid:4)(cid:4) = (Φ(cid:4)(cid:4)for i = 1 to nlet Φ(cid:4)iΠ (cid:4)i= (Π (cid:4)i , Ci, Fi) ∈ Σ (cid:4) and= SForgetLP(Π, P ) or Π (cid:4)i= WForgetLP(Π, P ) (P ⊆ Fi );Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778761while Q ⊂ Ptesting the consistency of SForgetLP(Π, Q) ∪ Cjfor all j = 1, . . . , n;if consistency holds, then Π (cid:4)(cid:4)iif consistency does not hold, then= SForgetLP(Π, Q);testing the consistency of WForgetLP(Π, Q) ∪ Cjfor all j = 1, . . . , n;if consistency holds, thenΠ (cid:4)(cid:4)i= WForgetLP(Π, Q), otherwise Π (cid:4)(cid:4)i= Π (cid:4)i ;return Σ (cid:4)(cid:4) = ((Π (cid:4)(cid:4)1 , C1, F1), . . . , (Π (cid:4)(cid:4)n , Cn, Fn)).It is easy to see that algorithm Solution-Generation terminates as the procedures of computing SForgetLP(Πi, Q)and WForgetLP(Πi, Q), and consistency testing for a program can always finish in finite steps respectively. Further-more, the output Σ (cid:4)(cid:4) is either the same as Σ (cid:4) or Σ (cid:4)(cid:4) (cid:15)Σ Σ (cid:4). This proves our result. (cid:2)The proof of Theorem 5 actually provides a method to generate a preferred solution for a logic program context.That is, once we have an initial solution for a logic program context, we can always generate a more preferredsolution from the current one. We continue the process until a preferred solution is finally achieved. However, notevery logic program has a solution. For instance, a logic program context Σ = (Φ1, Φ2) = (∅, {← a, not b}, ∅),({a ← not b}, ∅, ∅)) has no solution.Proposition 5. Let Σ = (Φ1, . . . , Φn) be a logic program context. If for each Φi = (Πi, Ci, Fi), Πi does not con-tain a constraint rule (a rule with empty head), Ci is consistent, and for each r ∈ Πi , atom(r) ∩ Fi (cid:7)= ∅, thenSolution(Σ) (cid:7)= ∅.Proof. We show that Σ (cid:4) = (Φ(cid:4)= (∅, Ci, Fi) (1 (cid:2) i (cid:2) n) is a solution of Σ. Since for eachii, Fi ∩ atom(r) (cid:7)= ∅ for each r ∈ Πi , we have Π (cid:4)= SForgetLP(Πi, Fi) = ∅ (note that this is because we alreadyiassumed that Πi does not contain any rules with empty heads. Instead, this type of rule is contained in Ci ). Thisfollows that Π (cid:4)∪ Cj = Cj for all j = 1, . . . , n are consistent. So ((∅, C1, F1), . . . , (∅, Cn, Fn)) is a solution of Σ. (cid:2)in), where Φ(cid:4)1, . . . , Φ(cid:4)We should indicate that many conflict solving scenarios can be represented in the type of logic program contextin Proposition 5. For example, the negotiation scenario discussed in Example 6 and most logic program update ap-proaches (see Section 6) can be specified under logic program contexts with this form. Therefore, solving conflicts forthis particular type of logic program context has a special interest in various applications. This motivates us to studymore detailed properties related to the solution of this type of logic program contexts.We first introduce some useful concepts. A logic program Π ’s dependency graph [1], denoted as G(Π), is adirected graph (atom(Π), E), where atom(Π) is the set of vertices, and E is the set of edges. An edge (a, b) ∈ E iffthere is a rule r ∈ Π such that a ∈ pos(r) ∪ neg(r) and {b} = head(r). Edge (a, b) is labelled “positive” if a ∈ pos(r)and “negative” if a ∈ neg(r). Then a logic program is called call-consistent [12] if it does not contain a constraint (i.e.a rule with empty head) and its dependency graph has no simple cycles with odd number of negative edges.5Lemma 1. Let Π1 and Π2 be two logic programs and Π1 be consistent. Then program Π1 ∪ Π2 is consistent ifbody(Π1) ∩ head(Π2) = ∅ and Π2 is call-consistent.Proof. Similar to the proof of Theorem 3, To prove this lemma, we need a result about program splitting from [26].To remain a completeness of the proof, we present this result again. Before we present this program splitting result,we introduce a notion. Given a program Π and a set of atoms S, we use e(Π, S) to denote the program obtained fromΠ by deleting: (1) each rule in Π having a form not a in its body with a ∈ S; and (2) all atoms a in the bodies of theremaining rules with a ∈ S. Intuitively, e(Π, S) can be viewed as a simplicity of Π giving those atoms in S to be true.Then we can re-state Theorem 5 in [26] under the normal logic program setting:5 A simple cycle is the one that does not contain any other cycles.762Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778A set of atoms S is a stable model of program Π if and only if Π = Π1 ∪ Π2 such that body(Π1) ∩ head(Π2) = ∅,and S = S1 ∪ S2, where S1 is a stable model of Π1 and S2 is a stable model of program e(Π2, S1).From this result, we can see that under the condition that Π1 is consistent, Π1 ∪ Π2 is consistent if body(Π1) ∩head(Π2) = ∅, and for each stable model S1 of Π1, e(Π2, S1) is also consistent.Since a call-consistent program is also consistent [25], to prove our result, we will prove that if Π2 is call-consistent,then e(Π2, S1) is also call-consistent for any set of atoms S1. From the definition of call-consistency, it is clearthat if Π2 is call-consistent, its dependency graph does not contain a simple cycle with odd number of negativeedges. Observing that for any set of atoms S1, program e(Π2, S1)’s dependency graph G(e(Π2, S1)) can be obtainedfrom G(Π2) by removing more edges and nodes from G(Π2). That is, G(e(Π2, S1)) is a subgraph of G(Π2). Thisconcludes that G(e(Π2, S1)) does not contain a simple cycle with odd number of negative edges. So e(Π2, S1) is alsocall-consistent. (cid:2)We need to mention that in Lemma 1, the call-consistency condition for program Π2 is important. It is easy to seethat Π2’s consistency does not imply the consistency of Π1 ∪ Π2 even if the other conditions of Lemma 1 remain thesame. For example, consider two programs Π1 = {b ←} and Π2 = {a ← b, not a}. Both Π1 and Π2 are consistentand body(Π1) ∩ head(Π2) = ∅. But Π1 ∪ Π2 has no stable model. The following theorem states that the procedure ofgenerating a more preferred solution may be simplified under certain conditions.Theorem 7. Let Σ = ((Π1, C1, F1), . . . , (Πn, Cn, Fn)) be a logic program context satisfying the conditions statedin Proposition 5. Suppose Σ (cid:4) = ((Π (cid:4)is of theform SForgetLP(Πi, Pi) or WForgetLP(Πi, Pi) (Pi ⊆ Fi ).6 Then a logic program context Σ (cid:4)(cid:4) = ((Π (cid:4)(cid:4)1 , C1,F1), . . . , (Π (cid:4)(cid:4)is of the formΠ (cid:4)(cid:4)i ) = ∅iand Π (cid:4)(cid:4)in , Cn, Fn)) is a solution of Σ and Σ (cid:4)(cid:4) (cid:15)Σ Σ (cid:4), if for each i either Π (cid:4)(cid:4)n, Cn, Fn)) is a solution of Σ, where each Π (cid:4)= WForgetLP(Πi, Qi) for some Qi ⊆ Pi such that body(= SForgetLP(Πi, Qi) or Π (cid:4)(cid:4)iis call-consistent.= Π (cid:4)i , or Π (cid:4)(cid:4)(cid:2)ni=11, C1, F1), . . . , (Π (cid:4)Ci) ∩ head(Π (cid:4)(cid:4)iiiProof. From Lemma 1, it follows that if for each i, body(all programs Π (cid:4)(cid:4)iQi ⊆ Pi , this concludes that Σ (cid:4)(cid:4) (cid:15)Σ Σ (cid:4). (cid:2)(cid:2)∪ C1, . . . , Π (cid:4)(cid:4)iis call-consistent, then∪ Cn are consistent. So Σ (cid:4)(cid:4) is a solution of Σ. On the other hand, since for each i,Ci) ∩ head(Π (cid:4)(cid:4)i ) = ∅ and Π (cid:4)(cid:4)ini=1(cid:2)In Theorem 7, the condition that body(Ci) ∩ head(Π (cid:4)i is call-consistent ensures that Σ (cid:4) isa solution of Σ, while the minimal subset Pi of atom(Πi) implies that Σ (cid:4) is a preferred solution. The followingExample 9 illustrates how a preferred solution can be obtained under the condition of Theorem 7.i ) = ∅ and Π (cid:4)ni=1Example 9. Consider a logic program context Σ = (Φ1, Φ2, Φ3), whereΦ2:Φ3:Φ1:Π1: a ← not b,c ← a, not d,C1: e ← d,F1 = {a, b, c, d},Π2: d ←,f ← not b,e ← not d,C2: ← a, c,F2 = {b, d, e, f },Π3: a ← not b,c ← not b,C3: f ← d,F3 = {a, b, c}.Clearly, Σ is not conflict free since Π1 ∪ C2, Π2 ∪ C1, Π2 ∪ C3 and Π3 ∪ C2 are not consistent. We can verify that a1, Φ(cid:4)logic program context Σ1 = (Φ(cid:4)2, Φ(cid:4)3) is a solution of Σ, where(cid:4)(cid:4)(cid:3)(cid:3), C1, F1Π1, {c}SForgetLP,(cid:4)(cid:3)(cid:3), C2, F2Π2, {d, e, f }SForgetLP(cid:4)(cid:3)(cid:3)Π3, {a}WForgetLP.(cid:4), C3, F3(cid:4),===ΦΦΦ(cid:4)1(cid:4)2(cid:4)36 Note that from Proposition 5, a solution of Σ always exists. In the initial case, Π (cid:4)i could be ∅.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778763Now we consider a program WForgetLP(Π2, {d}):f ← not b,e ← .Since {e, f } ∩ body(C1 ∪ C2 ∪ C3) = ∅ and WForgetLP(Π2, {d}) is call-consistent, according to Theorem 7, we knowthat Σ (cid:4)(cid:4)= (WForgetLP(Π2, {d}), C2, F2) is also a solution of Σ and Σ (cid:4)(cid:4) (cid:15)Σ Σ (cid:4). In fact1Σ (cid:4)(cid:4)1, Φ(cid:4)(cid:4)1 is a preferred solution of Σ.3), where Φ(cid:4)2 , Φ(cid:4)= (Φ(cid:4)26. Representing logic program updatesLogic program updates have been considerably studied in recent years. While similarities and differences amongthese different approaches have been addressed by many researchers, it is believed that comparing different types ofupdate approaches at some formal level is generally difficult (discussions on this topic are referred to [5,6,15,28]).In this section, we show that four major logic program update approaches can be transformed into the framework oflogic program contexts, in which all these update approaches become special cases of conflict solving problems withdifferent types of constraints.6.1. Representing causal rejection based approachEiter et al.’s update approach is based on a principle called causal rejection where a sequence of logic programupdates is allowed [5]. Let P = (Π1, . . . , Πn), where Π1, . . . , Π1 are extended logic programs, be an (extended logicprogram) update sequence and A a set of atoms. We say that P is over A iff A represents the set of all atomsoccurring in the rules in Π1, . . . , Πn. We use LitA to denote the set of all literals whose corresponding atoms are in A.We assume a set A∗ of atoms extending A by new and pairwise distinct atoms rej(r) and ai , for each rule r occurringin Π1, . . . , Πn and each atom a ∈ A. Then Eiter et al.’s update process is defined by the following two definitions(here we only consider ground extended logic programs in our investigation).Definition 12. [5] Given an update sequence P = (Π1, . . . , Πn) over a set of atoms A, the update program P(cid:20) =Π1 (cid:20) · · · (cid:20) Πn over A∗ consisting of the following items:(1) all constraints in Π1, . . . , Πn (recall that a constraint is a rule with an empty head);(2) for each r in Πi (1 (cid:2) i (cid:2) n):li ← body(r), not rej(r)(3) for each r ∈ Πi−1 (2 (cid:2) i (cid:2) n):if head(r) = {l};rej(r) ← body(r), ¬liif head(r) = {l};(4) for each literal l occurring in Π1 ∪ · · · ∪ Πn:li−1 ← li (1 < i (cid:2) n),l ← l1.A set S ⊆ LitA is an update answer set of P iff S = S(cid:4) ∩ LitA for some answer set S(cid:4) of P(cid:20).As an example, consider an update sequence P = (Π1, Π2, Π3), where Π1, Π2 and Π3 consist of the followingrules respectively [5],Π1:r1: sleep ← not tv_on,r2: night ←,r3: tv_on ←,r4: watch_tv ← tv_on;764Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778Π2:r5: ¬tv_on ← power_ failure,r6: power_ failure ←,Π3:r7: ¬power_ failure ← .According to Definition 12, it{¬power_ failure, tv_on, watch_tv, night}, which is consistent with our intuition.is easy to see that P = (Π1, Π2, Π3) has a unique update answer set S =In order to transform this update approach into our framework of logic program context, we first re-formulate thisapproach in a normal logic program setting. In particular, given an update sequence P = (Π1, . . . , Πn) over A, weextend the set A to A by adding atom a to A for each a ∈ A. Then by replacing each negative atom ¬a occurringin Πi with a, and adding constraint ← a, a for each a ∈ A, we obtain a translated (normal logic program) updatesequence P = (Π 1, . . . , Π n) over A.We also extend set A to A∗ by including new atoms rej(r), ai and ai for each rule r in Π 1, . . . , Π n and each pairof atoms a, a ∈ A. Then following Definition 12, we can obtain the corresponding update program P(cid:20) which is also anormal logic program. We also call a stable model of P(cid:20) update stable model of P.Proposition 6. Let P = (Π1, . . . , Πn) be an update sequence, P(cid:20) the update program of P, and P and P(cid:20) the corre-sponding translations of P and P(cid:20) respectively as described above. S ⊆ LitA is an update answer set of P iff there isan update stable model S of P such that S = (S ∩ A) ∪ {¬a | a ∈ S}.7Having Proposition 6, we only need to consider a transformation from a normal logic program update sequenceP = (Π 1, . . . , Π n), where P is translated from an extended logic program update sequence P as described above, to aconflict solving problem under the framework of logic program contexts.Definition 13. Let P = (Π 1, . . . , Π n) (n > 1) be a normal logic program update sequence over A. We specify asequence of logic program contexts ΩCR = (Σ1, . . . , Σn−1)8 over the set of atoms B = A∗ ∪ {lai , lai| ai, ai ∈ A∗, i =1, . . . , n} where lai and lai are newly introduced atoms:(1) Σ1 = ((Π ∗(a) Π ∗1, ∅, F1), (∅, C1, ∅)), where1 consists of the following rules:(i) all constraints in Π 1, . . . , Π n;(ii) for each r ∈ Π i: a ← body(r) or a ← body(r) (i = 1, . . . , n), ai ← body(r), not lai , or ai ←body(r), not lai respectively,(iii) for each a, a in A,ai−1 ← ai , ai−1 ← aia ← a1, a ← a1.(i = 1, . . . , n),(b) F1 = {lan−1, lan−1(c) C1 = {← an−1, an, ← an−1, an | ∀a ∈ A};| ∀a ∈ A},(2) Σi = ((Π ∗(a) Π ∗iΣ (cid:4)i−1i , ∅, Fi), (∅, Ci, ∅)) (i = 1, . . . , n), where= Π †i−1, and Π †i−1 is in a preferred solution of Σi−1:= ((Π †i−1, ∅, Fi−1), (∅, Ci−1, ∅)),(b) Fi = {lan−i , lan−i| ∀a ∈ A},(c) Ci = {← an−i, an−i+1, ← an−i, an−i+1 | ∀a ∈ A}.7 Note that S is reduced to LitA if both a and ¬a are in S for some a ∈ A.8 Note that when n = 1 our transformation becomes trivial since we can simply specify ΩCR to consist of a single logic program contextΣ = ((Π 1, ∅, ∅), (∅, ∅, ∅)). In this case Σ has a (preferred) solution iff Π 1 is consistent. So in the rest of the paper we will only consider the casen > 1.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778765A subset S ⊆ B is called a model of ΩCR if S is a stable model of Π †Σn−1: Σ (cid:4)n−1, ∅, Fn−1), (∅, Cn−1, ∅)).= ((Π †n−1n−1, where Π †n−1 is in a preferred solution ofLet us take a closer look at Definition 13. Given an update sequence P = (Π 1, . . . , Π n), Definition 13 specifies asequence of logic program contexts ΩCR = (Σ1, . . . , Σn−1), where each Σi solves certain conflicts embedded in P.Σ1 represents the first level of conflict solving, where Π ∗1 is similar to P(cid:20) except that the possible conflict betweenan−1 and an (or an−1 and an) has been reformulated as a constraint ← an−1, an (or ← an−1, an resp.) in C1. Note thatin rules specified in (ii) of Definition 13: ai ← body(r), not lai , ai ← body(r), not lai , formulas not lan−1 and not lan−1(here i = n − 1) are introduced to solve the conflict between an−1 and an (or an−1 and an resp.).Observe that Σ1 only solves conflicts between atoms at level n − 1. For example, if both an−1 and an can be derived1, then rule an−1 ← body(r), not lan−1 will be eliminated from Π1 by strongly forgetting atom lan−1 under thefrom Π ∗constraint ← an−1, an in C1.In the sequence ΩCR = (Σ1, . . . , Σn−1), conflicts are solved in a downwards manner with respect to the updatesequence P = (Π 1, . . . , Π n), where each Σi (i > 1) is specified for the purpose of solving conflicts between atomsan−i and an−i+1 (or an−i and an−i+1).Example 10. Consider the TV example mentioned earlier, where P = (Π1, Π2, Π3) is an update sequence. Itis easy to translate P to the corresponding normal logic program update sequence P = (Π 1, Π 2, Π 3), where¬tv_on and ¬power_ failure are replaced by atoms tv_on and power_ failure respectively. According to Definition13, we then specify a sequence of logic program contexts ΩCR = (Σ1, Σ2) to solve the conflict occurring in P.Σ1 = ((Π ∗1 consists of the following rules9:,,1, ∅, F1), (∅, C1, ∅)), where Π ∗← not tv_on, not lsleep1sleep1← not lnight1night1,tv_on1 ← not ltv_on1,watch_tv1 ← tv_on, not lwatch_tv1tv_on2 ← power_ failure, not ltv_on2,← not lpower_ failure2power_ failure2,power_ failure3 ← not lpower_ failure3,night ← night1,tv_on ← tv_on1,watch_tv ← watch_tv1,tv_on1 ← tv_on2,tv_on ← tv_on1,power_ failure2 ← power_ failure3,power_ failure1 ← power_ failure2,power_ failure ← power_ failure1,← power_ failure2,power_ failure1power_ failure ← power_ failure1,F1 = {lpower_ failure2, lpower_ failure2},andC1 = {← power_ failure2, power_ failure3}.9 To avoid unnecessarily tedious details, here we omit some irrelevant rules and atoms from Π ∗1, F1 and C1. The same for Σ2.766Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778It is easy to see that Σ1 is not conflict free since Π ∗1∪ C1 is not consistent (i.e it has no stable model).To specify Σ2, we first need to obtain a preferred solution of Σ1. In fact Σ1 has a unique preferred solutionΣ (cid:4)1= ((Π †Π †11, ∅, F1), (∅, C1, ∅)), where(cid:3)= SForgetLPΠ∗1, {lpower_ failure2}(cid:4)= Π−∗1(cid:11)power_ failure2← not lpower_ failure2(cid:12).Now we specify Σ2 = ((Π †} and C2 = {← tv_on1, tv_on2}. Notethat Σ2 is already conflict free. So by ignoring those atoms with subscripts, ΩCR has a unique model {power_ failure,tv_on, watch_tv, night}, which is the same as the update stable model of update sequence P.1, ∅, F2), (∅, C2, ∅)), where F2 = {ltv_on1, ltv_on1Theorem 8. Let P = (Π 1, . . . , Π n) (n > 1) be a normal logic program update sequence over the set of atoms A.A subset S of A is an update stable model of P iff there is a sequence of logic program contexts ΩCR = (Σ1, . . . ,Σn−1) constructed from P as specified in Definition 13 such that ΩCR has a model S satisfying S = S ∩ A.Proof. We prove this result by induction on the length n of normal logic program update sequence P = (Π 1, . . . , Π n).i.e. P = (Π 1, Π 2). In this case, ΩCR = (Σ1), where Σ1 =Case 1. We first consider the case n = 2,1, ∅, F1), (∅, C1, ∅)) is formed as follows:((Π ∗(a) Π ∗1 consists of the following rules:(i) all constraints in Π 1 and Π 2;(ii) for each r ∈ Π i: a ← body(r) or a ← body(r) (i = 1, 2),ai ← body(r), not lai , or ai ← body(r), not lai respectively,(iii) for each a, a in A, . . . , Π n,a1 ← a2, a1 ← a2,a ← a1, a ← a1.(b) F1 = {la1, la1(c) C1 = {← a1, a2, ← a1, a2 | ∀a ∈ A}.| ∀a ∈ A},Note that in above (ii), for rule r ∈ Π 2, a2 ← body(r), not la2 , or a2 ← body(r), not la2 can be simplified asa2 ← body(r), or a2 ← body(r) respectively since atom la2 or la2 is not forgettable.Now we consider the update program P(cid:20) built upon P (see Definition 12), which consists of the following rules:(1) all constraints in Π 1 and Π 2;(2) a1 ← body(r), not rej(r) or a1 ← body(r), not rej(r) for r ∈ Π 1, and a2 ← body(r) or a2 ← body(r) for r ∈ Π 2;(3) rej(r) ← body(r), a2 if head(r) = {a1} or rej(r) ← body(r), a2 if head(r) = {a1} for r ∈ Π 1;(4) for all a ∈ A, a1 ← a2, a1 ← a2, a ← a1, a ← a1.Now suppose S is an update stable model of P. Then we can extend S to S∗ over set A∗ so that S∗ is a stable modelof program P(cid:20), which contains atoms rej(r) for some r ∈ Π 1. Note that those rules in item (2) above with rej(r) ∈ S∗actually play no roles and hence viewed as been removed from P. Then we specify a set P ⊆ F1 which includes thosela1 or la1 whose corresponding rules r ∈ Π 1 in (ii) are removed from P as indicated above. Then it can be verifiedthat S where S = S ∩ A must be a stable model of program SForgetLP(Π ∗1, P ), and P is a minimal such set to makeSForgetLP(Π ∗1, P ) consistent. That is, S is a model of ΩCR.On the other hand, consider a stable model S of SForgetLP(Π ∗1, P ) is in a preferredsolution of Σ1. Let S = S ∩ A. Similarly, for each la1 or la1 in P , we extend S to S∗ to contain atoms rej(r) in S∗.Note that for each rej(r), such r ∈ Π 1 corresponds to a1 ← body(r), not la1 or a1 ← body(r), not la1 in (ii) specifiedabove. Now we do a Gelfond–Lifschitz transformation on program P (cid:20) in terms of set S∗: P S∗(cid:20) . By avoiding tediouscheckings, we can show that S∗ is a stable model of P S∗(cid:20) .1, P ), where SForgetLP(Π ∗Case 2. Suppose for all n < k, S is an update stable model of P = (Π 1, . . . , Π n) iff there is a ΩCR =(Σ1, . . . , Σn−1) such that ΩCR has a model S satisfying S = S ∩ A. Now we consider the case of n = k.(⇒) Let S be an update stable model of P = (Π 1, . . . , Π k). We will show that we can generate a sequence of logicprogram contexts ΩCR with length of k − 1 such that ΩCR has a model S satisfying S = S ∩ A.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778767k−1= Π ∗We first specify a new normal logic program update sequence with length of k − 1: P(cid:4) = (Π 1, . . . , Π (cid:4)k−1Π (cid:4)∪ Π k, and Π ∗update stable model of P(cid:4). Now suppose Ω (cid:4)CRfrom P(cid:4) according to Definition 13. From the induction assumption, we know that Ω (cid:4)S = S ∩ A.k−1), where= Π k−1 − {r | rej(r) ∈ S∗}.10 Then from Definition 12, we can see that S is also an= (Σ1, . . . , Σk−2) is a sequence of logic program contexts constructedCR has a model S satisfyingk−1Now we show that Ω (cid:4)= (Σ1, . . . , Σk−2) actually can be extended to another ΩCR = (Σ (cid:4)CR1, Σ1, . . . , Σk−2) with alength of k − 1, which eventually is constructed from P = (Π 1, . . . , Π k).Observe Π (cid:4)k−1 in P(cid:4), we can see that those ak−1 or ak−1 cannot be derived if ak or ak is already presented in S.k−1. So the first logic program context Σ1 inThat is, no conflict between ak−1 and ak (or ak−1 and ak) exists in Π (cid:4)Ω (cid:4)CR is specified as Σ1 = ((Π ∗1, ∅, F1), (∅, C1, ∅)):(1) Π ∗1 consists of the following rules:(a) all constraints in Π 1, . . . , Π (cid:4)(b) for each r: a ← body(r) or a ← body(r) in Π i (i = 1, . . . , k − 2) or in Π (cid:4)k−1;ai ← body(r), not lai respectively,(c) for each a, a in A, ai−1 ← ai , ai−1 ← ai (i = 1, . . . , n),a ← a1, a ← a1.(2) F1 = {lak−2 , lak−2(3) C(cid:4)1| ∀a ∈ A},= {← ak−2, ak−1, ← ak−2, ak−1 | ∀a ∈ A}.k−1: ai ← body(r), not lai , orThus, we can view Σ1 in Ω (cid:4)whereCR represents a preferred solution of logic program context Σ (cid:4)1= ((Π ∗(cid:4)1 , ∅, F (cid:4)1), (∅, C(cid:4)1, ∅)),11(1) Π ∗(cid:4)1 consists of the following rules:(a) all constraints in Π 1, . . . , Π k;(b) for each r ∈ Π i: a ← body(r) or a ← body(r) (i = 1, . . . , k), ai ← body(r), not lai , or ai ← body(r), not lairespectively,(c) for each a, a in A,ai−1 ← ai , ai−1 ← ai (i = 1, . . . , n),a ← a1, a ← a1.= {lak−1 , lak−1| ∀a ∈ A},= {← ak−1, ak, ← ak−1, ak | ∀a ∈ A}.(2) F (cid:4)1(3) C(cid:4)1Now we form a new ΩCR = (Σ (cid:4)CR. On the otherhand, According to Definition 13, it turns out that ΩCR can be viewed as such a sequence of logic program contextsformed from P = (Π 1, . . . , Π k).1, Σ1, . . . , Σk−2). Obviously S is model of ΩCR iff S is a model of Ω (cid:4)(⇐) Given P = (Π 1, . . . , Π k) and ΩCR = (Σ1, . . . , Σk−1) which is specified as in Definition 13. Suppose Sis a model of ΩCR. We show that S ∩ A is an update stable model of P. Now we consider a subsequence ofΩ (cid:4)2, ∅, F2), (∅, C2, ∅)), which is a preferred solution of Σ1 in ΩCR. So wecan represent Π 2 = SForgetLP(Π ∗| ∀a ∈ A}, and Π ∗1 is in Σ1. Now we define aprogram based on P(cid:20):= (Σ2, . . . , Σk−1), where Σ2 = ((Π ∗1, P ), where P ⊆ F1 = {lak−1 , lak−1CR(cid:4)(cid:20) = P(cid:20) −P(cid:3)(cid:11)r: ak−1 ← body(r), not rej(r) | lak−1(cid:12)∪∈ P(cid:11)r: ak−1 ← body(r), not rej(r) | lak−1k−1) where Π ∗k−1(cid:12)(cid:4).∈ PEquivalently, we can view P(cid:4)Π k, and Π (cid:4)k−1(cid:20) as the update program of a new sequence P(cid:4) = (Π 1, . . . , Π ∗= Π k−1 − {r | those corresponding rules removed in P(cid:4)(cid:20)}. Also, it is easy to verify that Ω (cid:4)= Π (cid:4)∪k−1CR can be10 Here we denote S∗11 Note the difference between Π ∗1 and Π ∗(cid:4)1 .to be the extension of S containing atoms from A∗.768Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778generated from Π (cid:4)update stable model of P(cid:4).k−1 following Definition 13. According to the induction assumption, we know that S ∩ A is anOn the other hand, since S = S ∩ A is an update stable model of P(cid:4), we can extend S to A∗ containing those atomsin A∗. Therefore, for each rule r: ak−1 ← body(r), not rej(r) or r: ak−1 ← body(r), not rej(r) removed from P(cid:20) (see(cid:20) above), atom rej(r) should be in A∗. Otherwise, this will violate the induction assumption. Thisthe definition for P(cid:4)follows that S must be an update model for P too. This completes our proof. (cid:2)6.2. Representing dynamic logic program approachLogic program update based on dynamic logic programs (DLP) (or simply called DLP update approach) wasproposed by Alferes, Leite, Pereira, et al. [2], and then extended for various purposes [15]. DLP deals with generalizedlogic programs in which negation as failure not is allowed to occur in the head of a rule while classical negation ¬is excluded from the entire program. Let P = (Π1, . . . , Πn) be a sequence of generalized logic programs over set ofatoms A, we extend A to AD by adding pairwise distinct atoms a, ai, ai, aPi , aPi , for each a ∈ A.Definition 14. [15] Given a update sequence P = (Π1, . . . , Πn) over A, where each Πi is a generalized logic program,the corresponding dynamic update program P⊕ = Π1 ⊕ · · · ⊕ Πn over AD is a generalized logic program consistingof the following rules:(1) for each r ∈ Πi : head(r) ← pos(r), not neg(r),aPiaPi← pos(r), not neg(r) if head(r) = {a} or← pos(r), not neg(r), if head(r) = {not a};(2) for each a occurring P and each i = 1, . . . , n,ai ← aPi and a ← aPi ;(3) for each a occurring P and each i = 1, . . . , n,ai ← ai−1, not aPi ,ai ← ai−1, not aPi ;(4) for each a occurring P, a0 ←, a ← an, a ← an, not a ← an.The semantics of DLP is defined in terms of the dynamic stable model semantics [15]. However, it is easy tocharacterize this through the original stable model semantics.Proposition 7. Given a dynamic update program P⊕ = Π1 ⊕ · · · ⊕ Πn, we define P∗Then S is a dynamic stable model of P⊕ iff S = S(cid:4) ∪ {not a | an ∈ S(cid:4)}, where S(cid:4) is a stable model of P∗⊕.⊕ = P⊕ − {not a ← an | a ∈ A}.12Now we can represent a transformation from P∗⊕ to a sequence of logic program contexts which captures thedynamic logic programming update approach.Definition 15. Given a dynamic update program P⊕ = Π1 ⊕ · · · ⊕ Πn over AD (see Definition 14), and let P∗P⊕ − {not a ← a−natoms A∗D⊕ =| a ∈ A}. We specify a sequence of logic program contexts ΩDLP = (Σ1, . . . , Σn) over the set of| ai, ai ∈ AD, i = 0, . . . , n} where hai , hai , lai , lai are newly introduced atoms:= AD ∪ {hai , hai , lai , lai(1) Σ1 = ((Π ∗(a) Π ∗1 , ∅, F1), (∅, C1, ∅)), where1 consists of the following rules:(i) all rules in P∗⊕ except the following rules (i = 1, . . . , n):ai ← ai−1, not api , andai ← ai−1, not api ,(ii) for each pair of rules in P∗ai ← ai−1, not api , and⊕ (i = 1, . . . , n):12 Clearly, P∗⊕ is a normal logic program.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778769ai ← ai−1, not api ,replace them with the following rules in Π ∗1 :ai ← ai−1, not lai , ai ← ai−1, not lai ,laihai(b) F1 = {ha1 , ha1(c) C1 = {← a1, aP1 , ← a1, aP1← not hai , lai← aPi , hai← aPi ,| ∀a ∈ A},← not hai ,| ∀a ∈ A};(2) Σi = ((Π ∗(a) Π ∗iΣ (cid:4)i , ∅, Fi), (∅, Ci, ∅)), where= Π †i−1, and Π †i−1 is in a preferred solution of Σi−1:i−1, ∅, Fi−1), (∅, Ci−1, ∅)),= ((Π †i−1(b) Fi = {hai , hai| ∀a ∈ A},(c) Ci = {← ai, aPi , ← ai, aPi| ∀a ∈ A}.A subset S ⊆ A∗Σn: Σ (cid:4)= ((Π †nD is called a model of ΩDLP if S is a stable model of Π †n , ∅, Fn), (∅, Cn, ∅)).n , where Π †n is in a preferred solution ofi , then both ai and ai can be derived from Π ∗In Definition 15, the sequence of logic program contexts ΩDLP = (Σ1, . . . , Σn) represents a way of solving con-flicts between atoms in an upwards manner. Starting from i = 1, for each i Σi solves conflicts between atoms ai andaPi (or ai and aPi resp.) through weakly forgetting hai or hai . For instance, if both ai−1 and aPi are derived fromΠ ∗i as well. Therefore a conflict would occur. Σi solves such conflict byweakly forgetting hai . In particular, after weakly forgetting hai , rule haii will be removed, atom lai is then← not hai ). Consequently rule ai ← ai−1, not laiderived from laiis defeated so that atom ai cannot be derived from ai−1 via the corresponding inertia rule. This process continuousuntil all conflicts among atoms from level 1 to level n are solved.← (note that formula not hai is deleted from rule lai← aPi in Π ∗Theorem 9. Let P∗is a sequence of logic program contexts ΩDLP = (Σ1, . . . , Σn) constructed from P∗that ΩDLP has a model S satisfying S∗ = S ∩ AD.⊕ be specified as above over set of atoms AD. A subset S∗ ⊆ AD is a stable model of P∗⊕ iff there⊕ as specified in Definition 15 suchSince the proof for this theorem is tedious but similar to the proof of Theorem 8, we skip it here.6.3. Representing syntax based approachSakama and Inoue’s update approach is viewed as a typical syntax based logic program update approach [22],which solves conflicts between two programs on a basis of syntactic coherence.To simplify our discussion, we restrict Sakama and Inoue’s approach from an extended logic program setting to anormal logic program setting. Note that this restriction does not affect the result presented in this subsection. In fact,we may use the method described in last subsection to translate an extended logic program update into a normal logicprogram update by introducing new atoms in the underlying language.Definition 16. [22] Let Π1 and Π2 be two consistent logic programs. Program Π (cid:4) is a SI-result of a theory update ofΠ1 by Π2 if (1) Π (cid:4) is consistent, (2) Π2 ⊆ Π (cid:4) ⊆ Π1 ∪ Π2, and (3) there is no other consistent program Π (cid:4)(cid:4) such thatΠ (cid:4) ⊂ Π (cid:4)(cid:4) ⊆ Π1 ∪ Π2.Now we transform Sakama and Inoue’s theory update into a logic program context. First, for each rule r ∈ Π1, we1: for each r ∈ Π1,1. That is, for each r ∈ Π1, we simply extend its negative body1 be removable by strongly forgetting atom lr without influencing1, ∅, {lr | r ∈ Π1}) and Φ2 = (∅, Π2, ∅).introduce a new atom lr which does not occur in atom(Π1 ∪ Π2). Then we define a program Π (cid:4)rule r (cid:4): head(r) ← pos(r), not (neg(r) ∪ {lr }) is in Π (cid:4)with a unique atom lr . This will make each r (cid:4) in Π (cid:4)other rules. Finally, we specify ΣSI = (Φ1, Φ2), where Φ1 = (Π (cid:4)For convenience, we also use Π −notP to denote a program obtained from Π by removing all occurrences of atomsin P from the negative bodies of all rules in Π . For instance, if Π = {a ← b, not c, not d}, then Π −not{c} = {a ←b, not d}. Now we have the following characterization result.770Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778Theorem 10. Let Π1 and Π2 be two consistent programs, and ΣSI as specified above. Π (cid:4) is a SI-result of updatingΠ1 by Π2 iff Π (cid:4) = Π −not{lr |r∈Π1} ∪ Π2, where Σ (cid:4) = ((Π, ∅, {lr | r ∈ Π1}), (∅, Π2, ∅)) is a preferred solution of ΣSI.Proof. From the specifications of ΣSI and Σ (cid:4), we know that Π = SForgetLP(Π (cid:4), P ), where P is a minimal subset of{lr | r ∈ Π1} such that Π ∪ Π2 is consistent. Note that each rule r ∈ Π is of the form: head(r) ← pos(r), not(neg(r) ∪{lr }), which can actually be simplied as head(r) ← pos(r), not neg(r) since atom lr does not play any role in theprogram evaluation. That is, Π (cid:4) ∪ Π2 is equivalent to Π −not{lr |r∈Π1} ∪ Π2, which is a SI-result of the update of Π1with Π2. (cid:2)6.4. Representing integrated update approachDifferent from both model based and syntax based approaches, Zhang and Foo’s update approach integrated bothdesirable semantic and syntactic features of (extended) logic program updates [27]. Their approach also solves defaultconflicts caused by negation as failure in logic programs by using a prioritized logic programming language. Conse-quently, Zhang and Foo’s update approach can generate an explicit resulting program for a logic program update andalso avoid some undesirable solutions embedded in Sakama–Inoue’s approach [28].Since we do not consider default conflict solving in this paper, we will only focus on the transformation from firstpart of Zhang–Foo’s update approach, that is, the conflict (contradiction) elimination, into a logic program context.Let Π1 and Π2 be two extended logic programs. Updating Π1 with Π2 consists of two stages. Step (1): Simple factupdate—updating an answer set S of Π1 by program Π2. The result of this update is a collection of sets of literals,denoted as Update(S, Π2). Step (2): Select a S(cid:4) ∈ Update(S, Π2), and extract a maximal subset Π ∗ of Π1 such thatprogram Π ∗ ∪ {l ← | l ∈ S(cid:4)} (or simply represented as Π ∗ ∪ S(cid:4)) is consistent. Then Π ∗ ∪ Π2 is called a resultingprogram of updating Π1 with Π2.Note that in Step (1), the simple fact update is achieved through a prioritized logic programming [27]. Recently,Zhang proved an equivalence relationship between the simple fact update and Sakama and Inoue’s program up-date [28]:Update(S, Π2) =(cid:13)S(cid:3)(cid:3)SI-UpdateΠ(S), Π2(cid:2)(cid:4)(cid:4),where Π(S) = {l ← | l ∈ S}, andafter updating Π(S) by Π2 using Sakama–Inoue’s approach.S(SI-Update(Π(S), Π2)) is the class of all answer sets of resulting programsExample 11. Consider two extended logic programs Π1 and Π2 as follows:Π1:Π2:a ←,c ← b,d ← not e.b ← a,¬c ← b.Π1 has a unique answer set {a, d}. Then Step (1) Zhang–Foo’s simple fact update of {a, d} by Π2, Update({a, d}, Π2),which is equivalently to update {a ←, d ←} with Π2 using Sakama–Inoue’s approach, will contain a single set{a, b, ¬c, d}. Applying Step (2), we obtain the final update result {a ←, d ← not e} ∪ Π2.As we have already provided a transformation from Sakama–Inoue’s approach to a logic program context, to showthat Zhang–Foo’s update approach can also be represented within our framework, it is sufficient to only transformStep (2) above into a conflict solving problem under certain logic program context.As before, given two extended logic programs Π1 and Π2 over the set of atoms A, we extend A to A with newatom a for each a ∈ A. Then by replacing each ¬a in S(cid:4) and Π2 with a, we obtain the corresponding normal logicprograms Π 1 and Π 2 respectively. Suppose Update(S, Π 2) is the result of the simple fact update, where S is a stablemodel of Π 1.Definition 17. Let Π 1, Π 2, and Update(S, Π 2) be defined as above, and S(cid:4) ∈ Update(S, Π 2). We specify a logicprogram context ΣZF = ((Π (cid:4)1, ∅, F), (∅, C, ∅)) over the set of atoms A ∪ {lr | r ∈ Π 1} where lr are newly introducedatoms:Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778771(1) Π (cid:4)Π (cid:4)1 consists of rules: (a) for each rule r: head(r) ← pos(r), not neg(r) in Π 1, head(r) ← body(r), not lr is in1, and (b) S(cid:4) ⊆ Π (cid:4)1,(2) F = {lr | r ∈ Π 1},(3) C = {← a, a | a, a ∈ A}.The following theorem shows that Step (2) in Zhang–Foo’s approach can be precisely characterized by a logicprogram context specified in Definition 17.Theorem 11. Let Π 1, Π 2, ΣZF, and Update(S, Π 2) be defined as above, and S(cid:4) ∈ Update(S, Π 2). Π ∗ is amaximal subset of Π 1 such that Π (cid:4) = Π ∗ ∪ S(cid:4) is consistent iff Π (cid:4)(cid:4) is in a preferred solution of ΣZF: Σ (cid:4)=ZF((Π (cid:4)(cid:4), ∅, F), (∅, C, ∅)), where Π (cid:4)(cid:4) = {r: head(r) ← pos(r), not neg(r), not lr | r ∈ Π ∗}.The proof of Theorem 11 is similar to that of Theorem 10.6.5. Further discussions: Updates, constraints, and expressiveness−iFrom previous descriptions, we observe that the key step to transform an update approach into a sequence of logicprogram contexts (or one logic program context like the case of SI approach) is to construct the underlying constraintsfor conflict solving. In both Eiter et al.’s causal rejection and DLP approaches, constraints are specified based onatoms, e.g. ← an−i, an−i+1 in ΩCR, and ← ai, aPin ΩDLP.For SI approach, on the other hand, the underlying constraints are specified as the entire update program. Forinstance, consider the update of Π1 by Π2 using SI approach, the corresponding logic program context for this updateis of the form Σ = ((Π, ∅, F), (∅, Π2, ∅)), in which program Π2 serves as constraints for conflict solving.Finally, since Zhang and Foo’s integrated update approach combined both model and syntax based approaches,the transformation of this approach into logic program context framework consists of two steps: an equivalent SItransformation with program based constraints, followed by another transformation with atoms based constraints (seeDefinition 17).From the above observation, we can see that the main difference between model based and syntax based updateapproaches is to solve conflicts under different types of constraints, namely atoms based and program based constraintsrespectively.While we have shown that our conflict solving approach provides a unified framework to represent different kindsof logic program updates, we should indicate that our approach does not give specific computational advantages overthese logic program update approaches. As we will see in Section 7, conflict solving under our framework is generallyintractable. From previous definitions, we also observe that transforming model based logic program updates into asequence of logic program contexts may need exponential time because it involves the computation of solutions oflogic program contexts, although transforming syntax based logic program updates can always be done in polynomialtime.Nevertheless, the most significant feature of using our logic program contexts to represent logic program updatesis to provide an expressive framework that unifies many different logic program update approaches. Under the uni-fied framework, it becomes possible to analyze and compare syntactic and semantic properties of these differentapproaches.7. Computational issuesIn this section, we study related computational issues. In particular, we consider two major computational problemsconcerning (1) irrelevance in reasoning with respect to strong and weak forgettings and conflict solving, and (2)general decision problems for conflict solving under the framework of logic program contexts.We first introduce basic notions from complexity theory and refer to [21] for further details. Two important com-plexity classes are P and NP. The class P includes all languages recognizable by a polynomial-time deterministicTuring machine. The class NP, on the other hand, consists of those languages recognizable by a polynomial-timenondeterministic Turing machine. The class of coNP is the complements of class NP. The class of DP contains alllanguages L such that L = L1 ∩ L2 where L1 is in NP and L2 is in coNP. The class coDP is the complement of772Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778class DP. The class Σ P2machine with an NP oracle, where the class Π PP ⊆ NP ⊆ DP ⊆ Σ P= NPNP includes all languages recognizable in polynomial time by a nondeterministic Turing2 . It is well known that2 is the complement of Σ P2 , i.e. Π P2= coΣ P2 , and these inclusions are generally believed to be proper.7.1. Complexity results on irrelevanceBy definitions, we can see that the main computation of strong and weak forgettings relies on the procedure ofreduction that further inherits the computation of the conventional program unfolding. Hence, it is easy to observethat in the worst case, the size of the resulting program after strong (or weak) forgetting could be exponentially largerthan the original program. This means that in general computing strong and weak forgettings in logic programs is hard.However, the following result shows that this actually does not increase the complexity of the associated inferenceproblem.Theorem 12. Let Π be a logic program, P a set of atoms, and a an atom. Deciding whether SForgetLP(Π, P ) |= a(or WForgetLP(Π, P ) |= a) is coNP-complete.Proof. The hardness is obvious when P = ∅. To prove the membership, we first specify two transformations on Πwith respect to P . The program STrans(Π, P ) is obtained from Π by removing some rules in Π : (1) for each p ∈ P ,if p /∈ head(Π), then removing rules r in Π with p ∈ pos(r); (2) if p /∈ pos(Π), then removing rules r in Π withhead(r) = p; and (3) removing rules r in Π with p ∈ neg(r). The program WTrans(Π, P ), on the other hand, isobtained from Π in the same way as program STrans(Π, P ) except (3): for rules r in Π having p ∈ neg(r), change itto be of the form: r (cid:4): head(r) ← pos(r), not(neg(r) − {p}). Now we prove the following two results:Result 1. SForgetLP(Π, P ) is consistent if and only if program STrans(Π, P ) is consistent, and each of SForgetLP(Π,P )’s stable models S(cid:4) can be expressed as S(cid:4) = S − P , where S is a stable model of STrans(Π, P ).Result 2. WForgetLP(Π, P ) is consistentif and only if program WTrans(Π, P ) is consistent, and each ofWForgetLP(Π, P )’s stable models S(cid:4) can be expressed as S(cid:4) = S − P , where S is a stable model of WTrans(Π, P ).Here we give the proof of Result 1, while Result 2 can be proved in a similar way. Firstly, we assume thatSForgetLP(Π, P ) is consistent and S(cid:4) is a stable model of SForgetLP(Π, P ). Then we show that STrans(Π, P ) musthave a stable model S such that S(cid:4) = S − P . Observing the construction of the structure of STrans(Π, P ), we can seethat for each p ∈ P occurring in STrans(Π, P ), there are two rules r1 and r2 in STrans(Π, P ) of the forms:r1: p ← pos(r1), not neg(r1),r2: head(r2) ← p, pos(r2), not neg(r2),and furthermore, we also have P ∩ neg(STrans(Π, P )) = ∅. Now we present an algorithm to construct a set S of atomsas follows:Algorithm: Generating SInput: STrans(Π, P ) and S(cid:4) where S(cid:4) is a stable model of SForgetLP(Π, P );Output: a set S of atoms;let S = S(cid:4);selecting a rule r from STrans(Π, P ) of the form:r: p ← pos(r), not neg(r), where p ∈ P and pos(r) ∩ P = ∅;if no such rule exists in Strans(Π, P ), then return S;elseif each a ∈ pos(r) is in S(cid:4) and each b ∈ neg(r) is not in S(cid:4),then S = S ∪ {p};repeat the following two steps until S no longer changesselecting a rule r (cid:4) from STrans(Π, P ) of the form:Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778773r (cid:4): p ← pos(r (cid:4)), not neg(r (cid:4)) where p ∈ P ;if each a ∈ pos(r (cid:4)) is in S and each b ∈ neg(r (cid:4)) is not in S,then S = S ∪ {p};return S.We need to show that S generated from the above algorithm is a stable model of STrans(Π, P ). We performGelfond–Lifschitz transformation on STrans(Π, P ) with S, and obtain program STrans(Π, P )S . First, we prove thatfor each rule r: head(r) ← pos(r) in STrans(Π, P )S , if pos(r) ⊆ S, then head(r) ∈ S.Case 1. If pos(r) ⊆ S(cid:4), then head(r) ⊆ S according to the algorithm.Case 2. Suppose r is of the form: r: head(r) ← p, pos(r), where p ∈ P , {p} ∪ pos(r) ⊆ S and pos(r) ⊆ S(cid:4).In this case, we show head(r) ∈ S. This is true if head(r) ∈ P according to the above algorithm. Now sup-pose head(r) (cid:7)⊆ P . Consider r’s original form in STrans(Π, P ): r (cid:4): head(r) ← p(cid:4), pos(r), not neg(r (cid:4)) (i.e. thepart not neg(r (cid:4)) is removed in STrans(Π, P )S ). Recall the structure of STrans(Π, P ), in which there exists a ruler (cid:4)(cid:4): p ← pos(r (cid:4)(cid:4)), not neg(r (cid:4)(cid:4)). By performing proper reduction, eventually we can replace r (cid:4)(cid:4) with a new rule:r ∗: p ← pos(r ∗), not neg(r ∗) such that P ∩ pos(r ∗) = ∅ (note that if we can not reach this form of rule r ∗,for instance, P ∩ pos(r ∗) (cid:7)= ∅, we will have p /∈ S according to the above algorithm). As p ∈ S, we must havepos(r ∗) ⊆ S, and hence pos(r ∗) ⊆ S(cid:4). On the other hand, it is not hard to observe that a rule of the form is inSForgetLP(Π, P )S(cid:4): head(r) ← pos(r), pos(r ∗). Since we already know that pos(r) ∪ pos(r ∗) ⊆ S(cid:4) and S(cid:4) is a stablemodel of SForgetLP(Π, P ), it follows that head(r) ∈ S(cid:4) and hence head(r) ∈ S as S(cid:4) ⊆ S.On the other hand, it is also easy to show that S(cid:4) generated from the above algorithm is the smallest set to have theabove property for program STrans(Π, P ). This proves that S is a stable model of STrans(Π, P ).Now we assume that STrans(Π, P ) is consistent and S is a stable model of STrans(Π, P ). In this case, we simplyprove that S(cid:4) = S − P is a stable model of SForgetLP(Π, P ). We omit the proof as it is easy to verify.Having these results, the membership is proved as follows. For the case of strong forgetting, we consider thecomplement of the problem. Clearly, it is easy to see that the STrans(Π, P ) can be obtained from Π in polynomialtime. Guessing a S stable model of STrans(Π, P ), verifying it, and checking whether a /∈ S − P can be done inpolynomial time. So the complement of the problem is in NP. Consequently, the problem is in coNP. Proof for thecase of weak forgetting is the same. (cid:2)From the above result, we can show the complexity of irrelevance in relation to strong and weak forgettings.Theorem 13. Let Π be a logic program, P a set of atoms and a an atom. Deciding whether a is irrelevant to P in Πis coDP-complete.Proof. To prove this theorem, we need to show deciding whether Π |= a iff SForgetLP(Π, P ) |= a (s-irrelevant) iscoDP-complete, and deciding whether Π |= a iff WForgetLP(Π, P ) |= a (w-irrelevant) is coDP-complete. Here weonly give the proof of the first statement, and the second can be proved in a similar way.Membership. To decide whether Π |= a iff SForgetLP(Π, P ) |= a, we need to show Π |= a and SForgetLP(Π,P ) |= a, or Π (cid:7)|= a and SForgetLP(Π, P ) (cid:7)|= a. Clearly, given Π , P and a, deciding whether Π |= a and SForgetLP(Π,P ) |= a is in coNP, and deciding whether Π (cid:7)|= a and SForgetLP(Π, P ) (cid:7)|= a is in NP (see Theorem 12). So the problemis in coDP.Hardness. We consider a pair (Φ1, Φ2) of CNFs and from which we polynomially construct a program Π , a set ofatoms P and an atom a, and prove that Φ1 is satisfiable or Φ2 is unsatisfiable iff Π |= a and SForgetLP(Π, P ) |= a,or Π (cid:7)|= a and SForgetLP(Π, P ) (cid:7)|= a.Let Φ1 = {C1, . . . , Cm} and Φ2 = {C(cid:4)j (1 (cid:2) i (cid:2) n, 1 (cid:2) j (cid:2) n) are sets of proposi-tional literals respectively. We also assume that Φ1 and Φ2 do not share any propositional atoms. Now we construct aprogram Π based on propositional atoms atom(Φ1) ∪ atom(Φ2) ∪ ˆX ∪ ˆY ∪ {l1, . . . , ln, p, a, satΦ1 , unsatΦ1 , unsatΦ2},where any two sets of atoms are disjoint and | ˆX| = |atom(Φ1)| and | ˆY | = |atom(Φ2)|. Program Π consists of fourgroups of rules:}, where each Ci and C(cid:4)1, . . . , C(cid:4)nΠ1:for each x ∈ atom(Φ1), we have:774Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778x ← not ˆx,ˆx ← not x,for each y ∈ atom(Φ2), we have:y ← not ˆy,ˆy ← not y,Π2:unsatΦ1 ← C1,. . . ,unsatΦ1 ← Cm,unsatΦ2 ← C(cid:4)1,. . . ,unsatΦ2 ← C(cid:4)n,where for each clause Ci (or C(cid:4)then b ∈ Ci (or C(cid:4)j resp.),j ), if b ∈ Ci (or C(cid:4)j resp.), then not b ∈ Ci (or C(cid:4)j resp.), and if ¬b ∈ Ci (or C(cid:4)j resp.)Π3:l1 ← unsatΦ2 , not l2, . . . , not ln,. . . ,ln ← unsatΦ2 , not l1, . . . , not ln−1,pos(C(cid:4)j ) ← lj (1 (cid:2) j (cid:2) n),j ) ← lj represents a group of rules: for all atoms b ∈ C(cid:4)where pos(C(cid:4)is needed),j , we have b ← lj (note that if not b ∈ C(cid:4)j , no ruleΠ4:satΦ1 ← not unsatΦ1 ,a ← satΦ1 ,unsatΦ2 ← not a,p ← .Let us look at the intuition behind this program. Clearly, Π1 generates all truth assignments for Φ1 and Φ2 (recallthat atom(Φ1) ∩ atom(Φ2) = ∅). This ensures that there is a correspondence between stable models of Π and truthassignments of Φ1 and Φ2. Π2 indicates that if Φ1 (or Φ2) is unsatisfiable, then atom unsatΦ1 (or unsatΦ2 resp.) willbe derived. Rules in Π3 are used to force Φ2 to be unsatisfiable. That is, if atom unsatΦ2 is derived from through ruleunsatΦ2 ← not a in Π4, then the corresponding truth assignment of Φ2 in each stable model of Π must make someC(cid:4)j to be true.Now we prove that Φ1 is satisfiable or Φ2 is unsatisfiable if and only if Π |= a and SForgetLP(Π, {p}) |= a; orΠ (cid:7)|= a and SForgetLP(Π, {p}) (cid:7)|= a. We observe that SForgetLP(Π, {p}) = Π − {p ←}, which implies that if Π |= athen SForgetLP(Π, {p}) |= a and if Π (cid:7)|= a then SForgetLP(Π, {p}) (cid:7)|= a.Suppose that Φ1 is satisfiable or Φ2 is unsatisfiable. We consider the following cases. (1) If Φ1 is satisfiable, then itis easy to see that none of rules in Π2 with head unsatΦ1 is applicable and hence atoms satΦ1 and a can be derived fromΠ . In this case, no matter if Φ2 is satisfiable or unsatisfiable, we always have Π |= a and SForgetLP(Π, {p}) |= a.(2) If Φ2 is unsatisfiable. In this case one of rules in Π2 having unsatΦ2 as heads is applicable and hence atomunsatΦ2 is derivable from Π . In this case, if Φ1 is satisfiable, then a is derived from Π . Otherwise, a is not derivablefrom Π . The same for SForgetLP(Π, {p}). So we have the statement: if Φ1 is satisfiable or Φ2 is unsatisfiable, thenΠ |= a and SForgetLP(Π, {p}) |= a, or Π (cid:7)|= a and SForgetLP(Π, {p}) (cid:7)|= a.Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778775Suppose Π |= a and SForgetLP(Π, {p}) |= a; or Π (cid:7)|= a and SForgetLP(Π, {p}) (cid:7)|= a. (1) If Π |= a and henceSForgetLP(Π, {p}) |= a. From the construction of Π , we know that the only way to derive a from Π is that rule a ←satΦ1 in Π4 is applicable. This implies that none of rules in Π2 having unsatΦ1 as heads is applicable. Consequently,one of truth assignments generated from Π1 for Φ1 must satisfy Φ1. So Φ1 is satisfiable.(2) If Π (cid:7)|= a and hence SForgetLP(Π, {p}) (cid:7)|= a. In this case, sat unsatΦ2 can be derived from rule unsatΦ2 ← not a.Then from rule in Π3, we know that in each stable model of Π , the corresponding truth assignment of Φ2 must notsatisfy Φ2. Since all truth assignments of Φ2 have been represented in Π ’s stable models, this concludes that Φ2 isunsatisfiable. This proves our result. (cid:2)The following complexity result of irrelevance with respect to logic program contexts is inherited from Theorem 13.Theorem 14. Let Σ and Σ (cid:4) be two logic program contexts where Σ (cid:4) ∈ Solution(Σ), and a an atom. Deciding whethera is (Σ, Σ (cid:4))i -irrelevant is coDP-complete.7.2. Complexity results on conflict solvingProposition 8. Let Σ be a logic program context. Deciding whether Σ has a preferred solution is NP-hard.Proof. We consider a special form of logic program context Σ = ((Π1, ∅, ∅), . . . , (Πn, ∅, ∅)). Clearly, Σ has a solu-tion iff each Πi has a stable model, and we know checking whether a program has stable is NP-hard. On the other hand,from Theorem 6, we know that Σ has a preferred solution iff Solution(Σ) (cid:7)= ∅. Then the result directly follows. (cid:2)We observe that computing a solution for a logic program context consists of two major stages: (1) computingstrong and weak forgettings, and (2) consistency testing for all Πi ∪ Cj in the resulting logic program context (seeDefinition 6). While many existing results may be used for efficient consistency testing of a logic program (e.g. seeSection 5.2 and Chapter 3 in [3]), it is important to investigate possible optimizations for computing strong and weakforgettings in logic programs.For this purpose, we first introduce a useful notion. Let Π be a logic program, a an atom in atom(Π), and G(Π)the dependency graph of Π . In G(Π), we call a positive path13 without cycles starting from a the inference chainstarting from a. We define the inference depth of a, denoted as i-depth(a), to be the length of the longest inferencechain starting from a in G(Π). Intuitively, i-depth(a) represents the maximal number of rules that may be used toderive any other atoms starting from a in program Π . We denote the inference depth of Π asi-depth(Π) = Max(cid:4)(cid:3)i-depth(a): a ∈ atom(Π).It turns out that the inference depth plays a key role in characterizing the computation of strong and weak forgettingsin logic programs.Theorem 15. Let Π be a logic program. If Π has a bounded inference depth, i.e. i-depth(Π) (cid:2) c for some constantc, then for any set of atoms P ⊆ atom(Π), SForgetLP(Π, P ) and WForgetLP(Π, P ) can be computed in polynomialtime.Proof. To prove this theorem, we only need to show that under the condition of bounded inference depth,Reduct(Π, P ) is polynomially achievable for any P ⊆ atom(Π). Without loss of generality, for P = {p1, . . . , pk},we may assume that Π consists of three components:Π1:r11: p1 ← pos(r11), not neg(r11),. . . ,rll1 : p1 ← pos(r1l1 ), not neg(r1l1 ),13 That is, a path does not contain any negative edges.776Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778r21: p2 ← pos(r21), not neg(r21),. . . ,r2l2 : p2 ← pos(r2l2 ), not neg(r2l2 ),. . . ,rk1: pk ← pos(rk1), not neg(rk1),. . . ,rklk : pk ← pos(rklk ), not neg(rklk ),Π 142 :r1: head(r1) ← p1, pos(r1), not neg(r1),r2: head(r2) ← p2, pos(r2), not neg(r2),. . . ,rk: head(rk) ← pk, pos(rk), not neg(rk),Π3,where the reduction only occurs among rules in Π1 ∪ Π2, and Π3 contains all rules irrelevant to the reduction process.Now we show that if i-depth(Π) (cid:2) c for some constant c, the size of Reduct(Π, P ) will be at most polynomialtimes of the size of Π . Indeed, since i-depth(Π) (cid:2) c, it follows that for each pi ∈ P , i-depth(pi) (cid:2) c in programΠ1. This implies that during the reduction, for each pi ’s occurrence in other rule’s positive body, at most onlyh1 × · · · × hc+1, where {h1, . . . , hc+1} ⊆ {l1, . . . , lk}, new rules will be introduced due to the inference chain inΠ1 starting from a. This number of rules is bounded by |Π|c+1. If pi occurs in all other rules’ positive bodies in Π1,the total number of new rules possibly introduced through reduction via pi is bounded by |P | × |Π|c+1. Therefore,the number of all new rules introduced through the entire reduction via P is bounded by O(|P |2 × |Π|c+1). In otherwords, to perform Reduct(Π, P ), the number of all operations on rule substitutions and replacements is bounded byO(|P |2 × |Π|c+1). (cid:2)Theorem 16. Let Σ = (Φ1, . . . , Φn) and Σ (cid:4) = (Φ(cid:4)(Πi, Ci, Fi) ∈ Σ (1 (cid:2) i (cid:2) n), Φ(cid:4)iWForgetLP(Πi, Pi) for some Pi ⊆ Fi . Then the following results hold:∈ Σ (cid:4) is of the form Φ(cid:4)i1, . . . , Φ(cid:4)n) be two logic program contexts, where for each Φi == (Π (cid:4)== SForgetLP(Πi, Pi) or Π (cid:4)ii , Ci, Fi), where Π (cid:4)i(1) Deciding whether Σ (cid:4) is a solution of Σ is NP-complete;(2) Deciding whether Σ (cid:4) is a preferred solution of Σ is in Π Pbe computed in polynomial time;152 provided that strong and weak forgettings in Σ can(3) For a given atom a, deciding whether for all Σ (cid:4)(cid:4) ∈ Solution(Σ), Σ (cid:4)(cid:4) |=i a is in Π P2 provided that strong and weakforgettings in Σ can be computed in polynomial time.Proof. Result 1 is easy to prove. To check if Σ (cid:4) is a solution of Σ, we only need to check whether Π (cid:4)∪ Cj isiconsistent for all i and j , and altogether we need to do n2 such consistency checkings. On the other hand, we knowthat checking the consistency of Π (cid:4)∪ Cj is in NP. So the problem is in NP. For the hardness, just consider a specialicase where n = 1, then Σ (cid:4) is a solution of Σ iff Π (cid:4)1∪ C1 is consistent, and this is NP-hard.To prove Result 2, we consider the complement of the problem. If Σ (cid:4) is not a preferred solution of Σ, thenn whereis of1 , . . . , P (cid:4)(cid:4)ni ) can be done in polynomial time. Then we canthere must exist Σ (cid:4)(cid:4) such that Σ (cid:4)(cid:4) ∈ Solution(Σ) and Σ (cid:4)(cid:4) ≺Σ Σ (cid:4). This equals to that there are P (cid:4)(cid:4)P (cid:4)(cid:4)ithe form SForgetLP(Πi, P (cid:4)(cid:4)and computing each SForgetLP(Πi, P (cid:4)(cid:4)1 , . . . , P (cid:4)(cid:4)n , Cn, Fn)), and each Π (cid:4)(cid:4)n , C1, F1), . . . , (Π (cid:4)(cid:4)i ); and (2) Σ (cid:4)(cid:4) ∈ Solution(Σ). Clearly, guessing such P (cid:4)(cid:4)⊆ Pi and for some k we have P (cid:4)(cid:4)k⊂ Pk such that (1) Σ (cid:4)(cid:4) = ((Π (cid:4)(cid:4)i ) and WForgetLP(Πi, P (cid:4)(cid:4)i ) or WForgetLP(Πi, P (cid:4)(cid:4)i14 In Π2, there may be more than one rules having pi in their positive bodies. But this simplified case does not affect our proof.15 Computing strong and weak forgettings in Σ , we mean that for each Φi = (Πi , Ci , Fi ) ∈ Σ and P ⊆ Fi , we compute SForgetLP(Πi , P ) andWForgetLP(Πi , P ).Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778777i can be either SForgetLP(Πi, P (cid:4)(cid:4)construct a Σ (cid:4)(cid:4) in polynomial time, where Σ (cid:4)(cid:4) is of the form Σ (cid:4)(cid:4) = ((Π (cid:4)(cid:4)each i, Π (cid:4)(cid:4)Σ can be achieved with number of n2 calls for an NP oracle. So the problem is in Σ Pproblem is in Π P2 .i ) or WForgetLP(Πi, P (cid:4)(cid:4)n , Cn, Fn)), in which fori ). Then checking whether Σ (cid:4)(cid:4) is a solution of2 . Consequently, the originalWe prove Result 3 as follows. We guess a set of atoms Si , and n sets of atoms P1, . . . , Pn such that Pi ⊆ Fi foreach 1 (cid:2) i (cid:2) n. Then similarly to the proof of Result 2, we can construct a logic program context Σ in polynomialtime. Checking whether Σ (cid:4) ∈ Solution(Σ) can be achieved with one call to an NP oracle. Then checking whether Siis a stable model of a particular Π (cid:4)∈ Σ (cid:4) and Φ(cid:4)= (Π (cid:4), Ci, Fi), and a /∈ Si can be done in polynomial timeias well. So the complement of the problem is in Σ P1 , Ci, F1), . . . , (Π (cid:4)(cid:4)2 , and thus the original problem is in Π Pi , where Φ(cid:4)2 . (cid:2)i8. ConclusionsIn this paper, we defined notions of strong and weak forgettings in logic programs, which may be viewed as ananalogy of forgetting in propositional theories. Based on these notions, we developed a framework of logic programcontexts. We then studied the irrelevance property related to strong and weak forgettings and conflict solving andprovided various solution characterizations for logic program contexts. We showed that our approach presented in thispaper is quite general and unified all major logic program update approaches. We also analyzed the computationalcomplexity of strong and weak forgettings in logic programs and conflict solving in logic programs contexts.We noted that there were other methods for solving the inconsistency of logic programs in the literature, especiallythe work involving abductive reasoning in logic programs. For instance, Inoue’s method of deletion and additionof names of rules [8], where certain atoms can be blocked from derivation by removing/adding some rules in theprogram. In this case, these atoms are still presented in the program. As we have shown in Section 6.3, by introducingnew atom such as lr in the language, our approach can simply model this method to solve program inconsistency. Themain difference between our approach and others is that we presented a very general framework based on strong andweak forgettings, and this framework can handle many different types of conflict solving scenarios including logicprogram updates, negotiation and belief merging, that seem to be difficult for any other single method in the literature(e.g. see Example 6 in Section 4).Our work presented in this paper can be further extended. One interesting issue is to integrate dynamic preferenceorderings on forgettable atoms into the current framework of logic program contexts, so that the extended frameworkcan represent domain-dependent conflict solving cases. This is particularly important when we use this approach torepresent complex belief merging (e.g. [10,11,16]) and negotiations under the setting of logic programming, in whicheach agent usually has different preferences on the atoms that she may forget for a final agreement.AcknowledgementsThe authors thank Fangzhen Lin for useful discussions on this topic and valuable comments on an early draft of thispaper. The research of the first author was supported in part by Australian Research Council under grant DP0666540.The authors also thank the anonymous reviewers for their insightful comments and criticisms which were helpful inrevising and improving the paper.References[1] K.R. Apt, H.A. Blair, A. Walker, Towards a theory of declarative knowledge, in: J. Minker (Ed.), Foundations of Deductive Database andLogic Programming, Morgan Kaufmann, 1988, pp. 293–322.[2] J.J. Alferes, J.A. Leite, L.M. Pereira, et al., Dynamic logic programming, in: Proceedings of KR-98, 1998, pp. 98–111.[3] C. Baral, Knowledge Representation, Reasoning and Declarative Problem Solving, Cambridge University, 2002.[4] S. Brass, J. Dix, A general framework for semantics of disjunctive logic programs based on partial evaluation, Journal of Logic Program-ming 38 (3) (1998) 167–213.[5] T. Eiter, M. Fink, G. Sabbatini, H. Tompits, On properties of update sequences based on causal rejection, Theory and Practice of LogicProgramming 2 (2002) 711–767.[6] T. Eiter, M. Fink, G. Sabbatini, H. Tompits, Reasoning about evolving nonmonotonic knowledge base, ACM Transaction on ComputationalLogic 6 (2005) 389–440.[7] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: Proceedings of the International Conference on LogicProgramming, The MIT Press, 1988, pp. 1070–1080.778Y. Zhang, N.Y. Foo / Artificial Intelligence 170 (2006) 739–778[8] K. Inoue, A simple characterization of extended abduction, in: Proceedings of the First International Conference on Computational Logic(CL-2000), 2000, pp. 718–732.[9] K. Inoue, C. Sakama, Update of equivalence of logic programs, in: Proceedings of JELIA 2004, 2004.[10] S. Konieczny, R. Pino Pérez, On the logic of merging, in: Proceedings of the 6th International Conference on Knowledge Representation andReasoning (KR-98), 1998, pp. 488–498.[11] S. Konieczny, R. Pino Pérez, Propositional belief base merging or how to merge beliefs/goal coming from several sources and some links withsocial choice theory, European Journal of Operational Research 160 (3) (2005) 785–802.[12] K. Kunen, Signed data dependencies in logic programs, Journal of Logic Programming 7 (3) (1989) 231–245.[13] J. Lang, P. Marquis, Resolving inconsistencies by variable forgetting, in: Proceedings of the 8th International Conference on Principles ofKnowledge Representation and Reasoning (KR-2002), Morgan Kaufmann Publishers, 2002, pp. 239–250.[14] J. Lang, P. Liberatore, P. Marquis, Propositional independence—Formula-variable independence and forgetting, Journal of Artificial Intelli-gence Research 18 (2003) 391–443.[15] J.A. Leite, Evolving Knowledge Bases: Specification and Semantics, IOS Press, 2003.[16] P. Liberatore, M. Schaerf, A system for the integration of knowledge bases, in: Proceedings of the 7th International Conference on KnowledgeRepresentation and Reasoning (KR-2000), Morgan Kaufmann Publishers, 2000, pp. 145–152.[17] V. Lifschitz, D. Pearce, A. Valverde, Strongly equivalent logic programs, ACM Transactions on Computational Logic 2 (4) (2001) 426–541.[18] F. Lin, R. Reiter, Forget it!, in: Working Notes of AAAI Fall Symposium on Relevance, 1994, pp. 154–159.[19] F. Lin, On the strongest necessary and weakest sufficient conditions, Artificial Intelligence 128 (2001) 143–159.[20] F. Lin, Y. Chen, Discovering classes of strongly equivalent logic programs, in: Proceedings of IJCAI-2005, 2005.[21] C.H. Papadimitriou, Computational Complexity, Addison Wesley, 1995.[22] C. Sakama, K. Inoue, Updating extended logic programs through abduction, in: Proceedings of LPNMR’99, 1999, pp. 2–17.[23] C. Sakama, H. Seki, Partial deduction in disjunctive logic programming, Journal of Logic Programming 32 (3) (1997) 229–245.[24] K. Su, G. Lv, Y. Zhang, Reasoning about knowledge by variable forgetting, in: Proceedings of the 9th International Conference on Principlesof Knowledge Representation and Reasoning (KR-2004), Morgan Kaufmann Publishers, 2004, pp. 576–586.[25] J.-H. You, L. Yuan, A three-valued semantics for deductive databases and logic programs, Journal of Computer and System Sciences 49 (2)(1994) 334–361.[26] Y. Zhang, Two results for prioritized logic programming, Theory and Practice of Logic Programming 3 (2) (2003) 223–242.[27] Y. Zhang, N. Foo, Updating logic programs, in: Proceedings of ECAI-1998, 1998, pp. 403–407.[28] Y. Zhang, Logic program based updates, ACM Transaction on Computational Logic, submitted for publication http://www.acm.org/pubs/tocl/accepted.html, 2006.