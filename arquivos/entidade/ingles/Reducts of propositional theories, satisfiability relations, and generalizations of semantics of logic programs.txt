Artificial Intelligence 174 (2010) 1285–1306Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintReducts of propositional theories, satisfiability relations, andgeneralizations of semantics of logic programs ✩Miroslaw Truszczy ´nskiDepartment of Computer Science, University of Kentucky, Lexington, KY 40506, USAa r t i c l ei n f oa b s t r a c tArticle history:Received 24 November 2009Received in revised form 6 August 2010Accepted 8 August 2010Available online 12 August 2010Keywords:Logic programmingStable modelsSupported modelsReductsLogic HTOver the years, the stable-model semantics has gained a position of the correct (two-for programs withvalued) interpretation of default negation in programs. However,aggregates (constraints), the stable-model semantics, in its broadly accepted generalizationstemming from the work by Pearce, Ferraris and Lifschitz, has a competitor: the semanticsproposed by Faber, Leone and Pfeifer, which seems to be essentially different. Ourgoalis to explain the relationship between the two semantics. Pearce, Ferraris andLifschitz’s extension of the stable-model semantics is best viewed in the setting ofarbitrary propositional theories. We propose here an extension of the Faber–Leone–Pfeifersemantics, or FLP semantics, for short, to the full propositional language, which revealsboth common threads and differences between the FLP and stable-model semantics. Weuse our characterizations of FLP-stable models to derive corresponding results on strongequivalence and on normal forms of theories under the FLP semantics. We apply a similarapproach to define supported models for arbitrary propositional theories, and to studytheir properties.© 2010 Elsevier B.V. All rights reserved.1. IntroductionThe stable-model semantics introduced by Gelfond and Lifschitz [23] is the foundation of answer-set programming [37,41,22], a paradigm for modeling and solving search problems. Answer-set programming is broadly accepted as an effectiveknowledge representation tool for modeling intelligent agents and reasoning in complex domains [12,13,3]. In the lastdecade, it has been successfully applied in several areas of artificial intelligence such as product configuration [47], planning[50,48], reasoning about action [25], and diagnosis [43,2], with some of these applications concerning large-scale systemslike the space shuttle flight controller [43]. Answer-set programming has also been applied beyond artificial intelligence forproblems arising in bio-informatics [4,46], linguistics [7] and automated music generation [5].The success of answer-set programming as a knowledge representation formalism and its applications in artificial intelli-gence and beyond make it essential that theoretical underpinnings of its semantics be established. Consequently, right fromits inception, the stable-model semantics, has received much attention. The present paper contributes to this general line ofresearch by extending the theoretical framework for the stable-model semantics based of the results and ideas proposed anddeveloped by Pearce [44] and Ferraris [19] to two other closely related semantics that also play a major role in answer-setprogramming, the Faber–Leone–Pfeifer stable-model semantics [16] and the supported-model semantics [9,1,38].A far-reaching contribution by Pearce [44] explained the stable-model semantics in terms of models of theories in thelogic of here-and-there (HT, for short), introduced by Heyting [26]. It had two important consequences. First, it resulted in ageneralization of the stable-model semantics, originally limited to a restricted syntax of program rules, to arbitrary theories✩An extended abstract of this paper appeared in the proceedings of the 2009 International Conference on Logic Programming.E-mail address: mirek@cs.uky.edu.0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.08.0041286M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306in the language of propositional logic (we discuss the role of this development in more detail later). Second, it brought aboutthe notion of strong equivalence of programs, fundamental to modular program development [32]. Strong equivalence hasbeen extensively studied in the past decade. That research resulted in extensions and refinements of the original concept,in characterizations, and in complexity results [32,35,51,14,52,49].The original definition of stable models [23] was based on the reduct of a program with respect to a set of atoms.The characterization in terms of the logic HT makes no reference to reducts but employs a form of model minimization.Ferraris [19] extended the notion of reduct to propositional theories, and developed the reduct-based definition of stablemodels equivalent to that provided by the logic HT (an exposition of the idea can also be found in the paper by Ferrarisand Lifschitz [21]).The papers by Pearce and Ferraris resulted in an elegant comprehensive treatment of the stable-model semantics. Theyalso raise the question whether there are other generalizations of the stable-model semantics to the case of arbitrarylogic theories. An indication that it might be so comes from the work by Faber et al. [16] on programs with aggregates.Aggregates, in the form of weight atoms, were introduced to answer-set programming by Niemelä and Simons [42], whoextended the stable-model semantics to that class of programs. Ferraris [19] cast that generalization in terms of stablemodels of propositional theories. Stable models of programs with aggregates are no longer guaranteed to be minimal models.From the perspective of the Ferraris’ result, it is not surprising. Stable models of propositional theories in general do nothave the minimal-model property.However, as minimization is an important knowledge-representation principle, Faber et al. [16] sought an alternativesemantics for programs with constraints, one that would have the minimal-model property. Naturally, they also wanted itto coincide with the original semantics on the class of programs without aggregates. They came up with a solution thatsatisfied both requirements by modifying the concept of the reduct! In the setting with aggregates, the Faber–Leone–Pfeiferstable-model semantics, or FLP semantics, is different than the extension of the original stable-model semantics based onthe logic HT (throughout the paper, whenever we speak about the stable-model semantics, we have the original semanticsin mind). Thus, the question of alternative generalizations is relevant. The FLP semantics is steadily gaining on importance.It is now not only used as the basis for interpreting aggregates in the dlv system [17], but also in approaches aiming tointegrate answer-set programming with other declarative programing paradigms [11].A related question concerns a possibility of generalizing other semantics relevant to answer-set programming to thefull propositional logic language. The one we consider here is the supported-model semantics. Its importance stems fromtwo properties. First, the supported-model semantics is the key component of a characterization of stable models in termsof loop formulas [36], which gave rise to fast algorithms for computing stable models of programs [36,31,30]. Second,for a class of modal theories of some restricted syntax, it is a precise counterpart to the semantics of expansions of theautoepistemic logic [40,38], an important nonmonotonic logic for modeling belief sets of an agent with perfect introspectioncapabilities.Given the applications of the Faber–Leone–Pfeifer stable-model semantics as an alternative to the standard Gelfond–Lifschitz one, and the role of the supported-model semantics in answer-set programming and nonmonotonic logics, ourobjective here is to investigate these semantics and show that they also can be studied by the means stemming from thosedeveloped by Pearce and Ferraris for the stable-model semantics. Specifically, we have the following goals:(1) To extend the semantics of Faber et al. [16] to the language of propositional logic. We do so in two equivalent ways: bymeans of a generalization of the reduct introduced by Faber et al., as well as in terms of a certain satisfiability relationsimilar to the one that defines the logic HT. We show that the FLP semantics generalizes several properties of the stable-model semantics of logic programs and so, it can be regarded as its legitimate extension, alongside with the extensionbased on the logic HT. We derive several additional properties of the FLP semantics, including a characterization ofstrong equivalence under that semantics, and a normal-form result.(2) To relate the FLP and stable-model semantics of propositional theories. We show that each can be expressed in eachother in the sense that there are modular translations that do not use any auxiliary atoms and such that FLP-stablemodels of a theory are stable models of its image under the translation (and vice versa).(3) To apply a similar two-pronged approach, exploiting both some notion of reduct and some satisfiability relation, to thesupported model semantics. We show that also supported models can be defined for arbitrary propositional theories. Wegeneralize to propositional language some well-known properties of supported models, as well as the results connectingstable and supported models of programs.While most implemented answer-set programming systems [10] used in applications support only theories consistingof rules (we formally define rules in the next section), a generalization of answer-set programming to the full language ofpropositional logic is important. From the theoretical standpoint, it eliminates possible artifacts of syntactic restrictions andallows us to identify key principles behind the semantics of answer-set programming. In particular, considering answer setprogramming in the full language pinpoints the basic role of implication as a nonclassical connective, with the nonclassicalbehavior of the negation being a consequence of the fact that the negation can be expressed by means of the implicationwith the false consequent. The key role of implication is emphasized by the recursive definitions of the reducts — it isthe only case that is treated in a nonstandard way. Moreover, it leads to the semantics of HT-interpretations, which pavesthe way to generalizations of answer-set programming and its semantics to the case of first-order logic theories [28,45].M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061287From the practical standpoint, generalizations of the syntax of answer-set programming to the full language makes answer-set programming more flexible as a modeling formalism, and provides a basis for further extensions of the language, forinstance, with aggregates [20].Our paper demonstrates that the ideas originated by Pearce and Ferraris extend to two other semantics of logic programs:the FLP semantics and the supported-model semantics. The results concerning the FLP semantics have several potentialimplications and applications. They provide a certain normal-form result (cf. Section 4), which points to a possible extensionof the syntax of disjunctive logic program rules currently supported by disjunctive logic programming systems such as dlv.The results on strong equivalence (cf. Section 3.5) lay the necessary foundation for the development of techniques andmethods for modular program design under the FLP semantics. Finally, the extension of the FLP semantics to arbitraryrules demonstrates the feasibility of extending the present implementation of the dlv system to a richer input languagenot restricted to rules. Our results on the supported-model semantics are also of interest. As we observed above, logicprogramming with the supported-model semantics captures in a direct way a fragment of autoepistemic logic [38]. Byextending the supported-model semantics to the entire language of propositional logic, we provide a way to expand thescope of this direct connection.Our paper is organized as follows. In the next section, we recall two definitions of stable models of propositional theories.The first one is in terms of a reduct introduced by Ferraris [19]. It extends the original approach of Gelfond and Lifschitz. Thesecond definition is in terms of HT-interpretations and is due to Pearce [44]. In Section 3, we discuss the approach by Faberet al. [16], extend it to arbitrary propositional theories, and study the properties of the resulting concepts. In particular,we characterize the general FLP-stable-model semantics in terms of the appropriately modified concept of the reduct, andin terms of a certain entailment relation based on HT-interpretations. We also discuss the question of the minimality ofFLP-stable models, the complexity of reasoning with FLP-stable models, and the concept of strong equivalence with respectto FLP-stable models. Finally, we present a normal form theorem for that semantics. In Section 5, we show that techniquesused in our paper can be applied to the supported-model semantics. Specifically, we define supported models for arbitrarypropositional theories by modifying the notion of a reduct, and by introducing yet another entailment relation based onHT-interpretations. We derive several results for the generalized supported-model semantics and, in particular, we studythe concept of strong equivalence for supported-model semantics, and the relationship of that semantics to those based onstable models and FLP-stable models.2. PreliminariesIn this section we introduce basic terminology and describe the general definitions of the stable-model semantics interms of the here-and-there models [44], and in terms of the Ferraris reduct, or F-reduct, for short [19], that generalizes theoriginal Gelfond–Lifschitz reduct.We consider the language of propositional logic determined by an infinite countable set At of atoms, and boolean con-nectives ⊥, ∧, ∨, and →. A Backus–Naur Form expression ϕ ::= ⊥| A|(ϕ ∧ ϕ)|(ϕ ∨ ϕ)|(ϕ → ϕ), where A ∈ At, provides aconcise definition of a formula. The parentheses are used only to disambiguate the order of binary operations. Wheneverpossible, we omit them. Generalizing the concept of the head of a program rule, we say that an occurrence of an atom is ahead occurrence if it does not occur in the antecedent of any implication. Finally, when writing formulas, we often use thefollowing shorthands:(cid:7) = ⊥ → ⊥ and ¬F = F → ⊥.A set of formulas is a theory. In the case of all semantics we discuss here, there is no essential difference between finitetheories and formulas. The former can be represented as the conjunctions of their elements. We often distinguish betweenformulas and theories as we want to address the case of infinite theories, too.In the paper, we consider several special types of formulas and theories. A rule is a formulaA1 ∧ · · · ∧ Am ∧ ¬B1 ∧ · · · ∧ ¬Bn → C1 ∨ · · · ∨ C s ∨ ¬D1 ∨ · · · ∨ ¬Dt,(1)where Ai ’s, B i ’s, Ci ’s and D i ’s are atoms. If we use r to denote the rule (1), we say that the formulas A1 ∧ · · · ∧ Am ∧ ¬B1 ∧· · · ∧ ¬Bn and C1 ∨ · · · ∨ C s ∨ ¬D1 ∨ · · · ∨ ¬Dt are the body and the head of r, and denote them by body(r) and head(r),respectively. If m = n = 0, we represent the rule by its head. If s = t = 0, we write ⊥ for the head of the rule. A program isa set of rules. We emphasize that the phrases “a head occurrence in a formula”, discussed two paragraphs above, and “anelement of the head of a rule” have a different meaning. In particular, each literal ¬D i is an element of the head of therule (1), but the corresponding occurrence of D i in the rule is not a head occurrence.For consistency with the standard logic programming terminology, when referring to rules (1) with no negated atomsin the heads, we use the term disjunctive program rule or, simply, disjunctive rule. Further, we call disjunctive rules with atmost one atom in the head normal program rules or, simply normal rules. By the convention above, disjunctive rules have nonegated atoms in the head and so, this terminology agrees with the standard one.Originally, the stable-model semantics was defined by Gelfond and Lifschitz [23] for normal programs (collections ofnormal rules). The definition was later extended to disjunctive programs, that is, collections of disjunctive rules also byGelfond and Lifschitz [24], then to programs as understood here (collections of rules (1)) by Lifschitz and Woo [34], and to1288M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306a superclass of programs, programs with nested expressions by Lifschitz et al. [33]. Finally, the case of arbitrary theories wasaddressed by Pearce [44] and, later and in a different way, by Ferraris [19]. These last two approaches are equivalent. Wewill now discuss them, starting with the latter one.For a formula F and a set of atoms Y , we define the Ferraris reduct (F-reduct) of F with respect to Y , written as F Y , byinduction:⊥Y = ⊥.R1.R2. If A is an atom:(cid:2)AY =A if Y |(cid:8) A,⊥ otherwise.R3. For ◦ = ∧ and ∨:(cid:3)(G ◦ H)Y =R4. For →:G Y ◦ H Y⊥if Y |(cid:8) G ◦ H,otherwise.(cid:3)(G → H)Y =G Y → H Y⊥if Y |(cid:8) G → H,otherwise.We could have folded case (R4) into the case (R3). However, all concepts of reduct we consider later in the paper differonly in the way the implication is handled and so, we show this case separately.For a theory F , we define the F-reduct F Y by setting F Y = {F Y | F ∈ F }. Next, we define Y ⊆ At to be a stable model ofF if Y is a minimal model of the theory F Y . One can show that stable models are models (hence, the term stable model isjustified).We will now illustrate the notions we just introduced. We will use the theories discussed below throughout the paper.Example 1. Let E1 = {¬¬ A → A}. To compute the reduct E ∅tautology). Thus, E ∅1⊥) → ⊥, (¬¬ A)∅ = (( A → ⊥) → ⊥)∅ = ⊥. It follows that E ∅1subset X of ∅ such that X |(cid:8) E ∅= (¬¬ A)∅ → A. Since ∅ (cid:12)|(cid:8) A, A∅1 . Thus, ∅ is a stable model of E1.= (¬¬ A){ A} → A{ A}1Similarly, as { A} |(cid:8) ¬¬ A → A, E { A}⊥) → ⊥ (the expanded form of ¬¬ A), (( A → ⊥) → ⊥){ A} = ( A → ⊥){ A} → ⊥{ A}by the definition, ⊥{ A} = ⊥. Thus, E { A}X |(cid:8) E { A}= (⊥ → ⊥) → A. Clearly, { A} |(cid:8) E { A}, also { A} is a stable model of E1.1111 , we note that ∅ |(cid:8) ¬¬ A → A (as the formula is a classical∅ = ⊥. Moreover, ¬¬ A stands for ( A → ⊥) → ⊥. Since ∅ (cid:12)|(cid:8) ( A →1 and, trivially, there is no proper= ⊥ → ⊥. Clearly, ∅ |(cid:8) E ∅. The definition implies that A{ A} = A. Moreover, as { A} |(cid:8) ( A →. Since A (cid:12)|(cid:8) A → ⊥, ( A → ⊥){ A} = ⊥. Also,. As there is no proper subset X of { A} such thatExample 2. Let E2 = {( A ∨ ¬ A) → A}. To compute the reduct E ∅in particular, that ∅ is not a stable model of E2.2 , we note that ∅ (cid:12)|(cid:8) ( A ∨ ¬ A) → A. Thus, E ∅2= ⊥. It follows,Next, we observe that A |(cid:8) ( A ∨ ¬ A) → A. Thus, E { A}=( A ∨ ⊥) → A. Clearly, we have ∅ |(cid:8) E { A}. Thus, { A} is not a stable model of E2, either, and so, E2 has no stable models (asin the case of normal programs, we can restrict the search for stable models to subsets of the set of atoms that occur in thetheory).. Since (¬ A){ A} = ( A → ⊥){ A} = ⊥, E { A}= ( A ∨ ¬ A){ A} → A{ A}222This notion of a stable model generalizes all earlier ones. It also coincides with the one proposed by Pearce [44]. Theapproach by Pearce is based on the logic HT [26], a logic located strictly between the intuitionistic and the propositionallogics. Stable models are defined in terms of the satisfiability relation |(cid:8)ht in the logic HT. A pair (cid:13) X, Y (cid:14), where X, Y ⊆At, is an HT-interpretation if X ⊆ Y . The relation |(cid:8)ht, between HT-interpretations and formulas, is defined inductively asfollows:(1) (cid:13) X, Y (cid:14) (cid:12)|(cid:8)ht ⊥;(2) (cid:13) X, Y (cid:14) |(cid:8)ht A if X |(cid:8) A (applies only if A ∈ At);(3) (cid:13) X, Y (cid:14) |(cid:8)ht G ∧ H if (cid:13) X, Y (cid:14) |(cid:8)ht G and (cid:13) X, Y (cid:14) |(cid:8)ht H ;(4) (cid:13) X, Y (cid:14) |(cid:8)ht G ∨ H if (cid:13) X, Y (cid:14) |(cid:8)ht G or (cid:13) X, Y (cid:14) |(cid:8)ht H ;(5) (cid:13) X, Y (cid:14) |(cid:8)ht G → H if Y |(cid:8) G → H ; and (cid:13) X, Y (cid:14) (cid:12)|(cid:8)ht G, or (cid:13) X, Y (cid:14) |(cid:8)ht H .The relation extends in a standard way to theories. If for a theory F , (cid:13) X, Y (cid:14) |(cid:8)ht F , then (cid:13) X, Y (cid:14) is an HT-model of F . Someimportant properties of the relation |(cid:8)ht are gathered below (cf. Ferraris and Lifschitz [21]).M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061289Theorem 1. For every formula F and every X ⊆ Y ⊆ At:(1) (cid:13) X, Y (cid:14) |(cid:8)ht F implies Y |(cid:8) F ;(2) (cid:13) X, Y (cid:14) |(cid:8)ht ¬F if and only if Y |(cid:8) ¬F ;(3) (cid:13)Y , Y (cid:14) |(cid:8)ht F if and only if Y |(cid:8) F .Pearce [44] defined Y to be a stable model of a theory F if and only if (cid:13)Y , Y (cid:14) |(cid:8)ht F and for every X ⊆ Y if (cid:13) X, Y (cid:14) |(cid:8)ht F ,then X = Y (a form of minimality). Ferraris and Lifschitz [21] proved that the two approaches are equivalent by showing thefollowing two key results.Theorem 2. Let F be a theory:(1) for every Y ⊆ At, Y |(cid:8) F if and only if Y |(cid:8) F Y ;(2) for every X ⊆ Y ⊆ At, X |(cid:8) F Y if and only if (cid:13) X, Y (cid:14) |(cid:8)ht F .Example 3. Let us consider the theory E1 = {¬¬ A → A} from Example 1 and let Y = ∅. Since Y (cid:12)|(cid:8) ( A → ⊥) → ⊥, (cid:13)Y , Y (cid:14) (cid:12)|(cid:8)ht( A → ⊥) → ⊥ and Y |(cid:8) (( A → ⊥) → ⊥) → A. Thus, (cid:13)Y , Y (cid:14) |(cid:8)ht (( A → ⊥) → ⊥) → A or, in other words, (cid:13)Y , Y (cid:14) |(cid:8)ht E1.Trivially, there is no proper subset X of Y such that (cid:13) X, Y (cid:14) |(cid:8)ht E1. Thus, Y = ∅ is a stable model of E1, according to thedefinition by Pearce.Next, let Z = { A}. Then Z |(cid:8) (( A → ⊥) → ⊥) → A and (cid:13)Z , Z (cid:14) |(cid:8)ht A. Thus, (cid:13)Z , Z (cid:14) |(cid:8)ht (( A → ⊥) → ⊥) → A and, con-sequently, (cid:13)Z , Z (cid:14) |(cid:8)ht E1. The only proper subset of Z is X = ∅. Clearly, (cid:13) X, Z (cid:14) (cid:12)|(cid:8)ht A (as A /∈ X ). Let us also observe thatZ |(cid:8) ( A → ⊥) → ⊥, and (cid:13) X, Z (cid:14) (cid:12)|(cid:8)ht A → ⊥ (as Z (cid:12)|(cid:8) A → ⊥). Thus, (cid:13) X, Z (cid:14) |(cid:8)ht ( A → ⊥) → ⊥. It follows that (cid:13) X, Z (cid:14) (cid:12)|(cid:8)ht(( A → ⊥) → ⊥) → A. Thus, (cid:13) X, Z (cid:14) (cid:12)|(cid:8)ht E1, and so Z = { A} is a stable model of E1 according to the definition by Pearce.Similarly, one can check that the theory E2 from Example 2 has no stable models according to the definition by Pearce.Of course, these outcomes are only to be expected, given our discussion in Examples 1 and 2, and the equivalence of thedefinitions proposed by Ferraris and Pearce.We conclude by noting that throughout the paper, we are only interested in the satisfiability of reducts (the one dis-cussed in this section and two other types we introduce later) with respect to the standard propositional logic semantics.Thus, whenever we compute the reduct, we can simplify it by using propositional tautologies. Such simplifications have noeffect on the concept of stability. For instance, we could simplify the reduct E A1= (⊥ → ⊥) → A to A.3. FLP semanticsFaber et al. [16] based their work on a notion of reduct that differs from the one proposed by Gelfond and Lifschitz.Using our notation, it can be defined as follows. Let R be a disjunctive rule (that is, there are no negated atoms in the head)A1 ∧ · · · ∧ Am ∧ ¬B1 ∧ · · · ∧ ¬Bn → C1 ∨ · · · ∨ C s,where Ai , B i and Ci are atoms, and let Y be a set of atoms. The FLP-reduct R Y (the notation we use is meant to distinguishbetween the FLP- and the F-reduct) is either R, if Y |(cid:8) A1 ∧ · · · ∧ Am ∧ ¬B1 ∧ · · · ∧ ¬Bn, or (cid:7), otherwise. Given a disjunctiveprogram P , P Y is obtained by replacing each rule R ∈ P with R Y . Finally, Y is a stable model of P in the sense of Faberet al., if Y is a minimal model of P Y . Faber et al. [16] proved that “their” stable models of disjunctive programs coincidewith standard stable models. They also observed that the FLP-reduct does not depend on the syntactic form of the body ofa rule. All that matters is whether the body is satisfied by Y . Thus, they extended the definition to more general formulasthat are of the formF → C1 ∨ · · · ∨ C s,(2)where Ci are atoms and F is a propositional formula.1 That allowed them to extend the concept of a stable model to theclass of theories that consist of such “generalized” disjunctive rules. Importantly, they proved that stable models, in theirsense, of such theories are minimal models, while the stable-model semantics does not have that property. For instance, theprogram (theory) E1 = {¬¬ A → A} has only one FLP-stable model, ∅, but two stable models, ∅ and { A} (cf. Example 1 andExample 3, above).3.1. General FLP semanticsTo extend that approach to arbitrary propositional theories, we first generalize the notion of the FLP-reduct. To this end,we follow the inductive pattern of the definition of the F-reduct. There is no change for F = ⊥, F = A, where A ∈ At, and1 Faber et al. used conjunctions of literals and aggregate atoms as F , but that detail is immaterial here.1290M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306F = G ◦ H , where ◦ = ∨ and ∧. Indeed, there does not seem to be any other way, in which these cases could be handled.Thus, the only case that requires a discussion is that of F = G → H . Once that case is settled, we will define Y to be anFLP-stable model of a theory F if Y is a minimal model of the FLP-reduct F Y .So, let us discuss the case of the implication. A literal reading of the FLP-reduct for rules suggests the following inductivedefinition for the case F = G → H :(G → H)Y = G → H,if Y |(cid:8) G;otherwise,(G → H)Y = (cid:7).However, under that choice, all occurrences of → (and so, also all occurrences of ¬) in the consequent of another im-plication would be interpreted in the classical way. While not a problem for formulas that do not have any implicationsoccurring in the consequent of any “top-level” implication (and so, working correctly for the class of formulas consideredby Faber et al.), in general it leads to some counterintuitive behavior.For instance, let F = {¬¬ A} and G = {¬B → ¬¬ A}, where A and B are atoms. As B does not appear in the head of therule of G, it must be false in every reasonable generalization of the stable-model semantics. Consequently, F and G shouldhave the same stable models. However, under the proposed definition it would not be so. Let Y = { A}. Since ¬¬ A = ( A →⊥) → ⊥ and Y (cid:12)|(cid:8) A → ⊥, we would have F Y = {(cid:7)}. Consequently, Y would not be a minimal model of F Y = {(cid:7)} (as ∅is a model, too) and so, Y would not be a “stable” model of F . On the other hand, as Y |(cid:8) ¬B, G Y = {¬B → ¬¬ A}. Thus,clearly, Y would be a minimal model of G Y and, consequently, a “stable” model of G. A problem in itself, it also leads toanother one. In G, A has no head occurrence (informally, there is no “defining clause” for A in G), yet G would have { A} asa “stable” model.Thus, we need to handle the case of → differently, but in such a way that under the restriction to theories consisting offormulas (2) we obtain the same concept of a stable model as the one proposed by Faber et al. In particular, we must ensurethat all occurrences of → in the consequent of another occurrence of → are treated consistently in the same nonclassicalway. In the remainder of this section we will argue that it can be accomplished by the following definition:FLP4.(G → H)Y =⎧⎨⎩G → H Y(cid:7)⊥if Y |(cid:8) G and Y |(cid:8) H,if Y (cid:12)|(cid:8) G,otherwise (that is, when Y (cid:12)|(cid:8) G → H).While it looks different than the original definition [16], it preserves its basic idea. Specifically, in the first case, whenthe implication is “strongly” satisfied (both its antecedent and consequent are satisfied by Y ), we keep the antecedentunchanged, following the spirit of the original definition of Faber et al., but replace the consequent recursively with itsreduct, to make sure the implications occurring in the antecedent are treated in a consistent way. The case when Y “weakly”satisfies the implication, that is, does not satisfy its antecedent, is dealt with as in the previous naive attempt (and as inthe definition by Faber et al.). Namely, reflecting the principle that if the antecedent of an implication is false (informally,the implication “does not fire”), the implication is immaterial and can be replaced by (cid:7) (effectively “removed”). In thecase when the implication is not satisfied by Y , it can be replaced by ⊥. Faber et al. do not distinguish this case and, infact, proceed differently. They keep the rule in the program. However, they could have replaced it with ⊥, as we propose(following the pattern for F-reduct), without affecting the resulting concept of a stable model. Indeed, if Y does not satisfya rule in a program, Y cannot be a stable model of that program. Replacing a rule violated by Y with ⊥ just makes thatexplicit.To summarize, we define the FLP-reduct of the formula F with respect to Y , F Y , recursively, by using the clauses (R1)–(R3) of the definition of the F-reduct (adjusted to the notation F Y ), as well as the clause (FLP4) for the implication →.We extend the definition to theories in the standard way. With this definition in hand, we define next the notion of anFLP-stable model of a propositional theory (as announced above).Definition 1. Let F be a theory. A set of atoms Y is an FLP-stable model of F if Y is a minimal model of F Y .Example 4. We consider again the theory E1 = {¬¬ A → A} from Example 1. To compute the reduct E ∅∅ (cid:12)|(cid:8) ¬¬ A. Thus, E ∅1 and, trivially, there is no proper subset X of ∅ such that X |(cid:8) E ∅FLP-stable model of E1.= (cid:7). Clearly, ∅ |(cid:8) E ∅11 , we note that1 . Thus, ∅ is anOn the other hand, we have { A} |(cid:8) ¬¬ A and { A} |(cid:8) A. Thus, E= ¬¬ A → AThus, E{ A}1= ¬¬ A → A. Clearly, { A} |(cid:8) E{ A}1. However, we also have that ∅ |(cid:8) E{ A}{ A} = A.. The definition implies that A. Thus, { A} is not an FLP-stable model of E1.{ A}1{ A}1Example 5. Next, we reconsider the theory E2 = {( A ∨ ¬ A) → A} from Example 2. To compute the reduct E ∅∅ (cid:12)|(cid:8) ( A ∨ ¬ A) → A. Thus, E ∅= ⊥. It follows, as in Example 2, that ∅ is not an FLP-stable model of E2.22 , we note thatM. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061291On the other hand, we observe that { A} |(cid:8) ( A ∨ ¬ A) and { A} |(cid:8) A. Thus, Efollows that E= ( A ∨ ¬ A) → A. Clearly, we have { A} |(cid:8) Eand ∅ (cid:12)|(cid:8) E. Thus, { A} is an FLP-stable model of E2.{ A}2{ A}2{ A}2{ A}2= ( A ∨ ¬ A) → A{ A}. Since A{ A} = A, itExamples 1, 2, 4 and 5 show that stable models need not be FLP-stable models and vice versa. Later, we provide a detailedcomparison between the two semantics.3.2. Basic propertiesWe start with a generalization of the well-known property of the standard F-reduct of disjunctive programs (cf. Theo-rem 2).Proposition 1. For every theory F and for every set of atoms Y , Y |(cid:8) F if and only if Y |(cid:8) F Y .Proof. It is enough to prove that for every formula F , we have Y |(cid:8) F if and only if Y |(cid:8) F Y . We proceed by induction. Thebase cases of F = ⊥ and F = A, where A ∈ At, are evident. Let F = G ∧ H . If Y (cid:12)|(cid:8) F , then F Y = ⊥. Thus, both sides of theequivalence are false, and the equivalence follows. If Y |(cid:8) F or Y |(cid:8) F Y , then F Y = G Y ∧ H Y . Since(1) Y |(cid:8) F if and only if Y |(cid:8) G and Y |(cid:8) H , and(2) Y |(cid:8) F Y if and only if Y |(cid:8) G Y and Y |(cid:8) H Y ,the equivalence of Y |(cid:8) F and Y |(cid:8) F Y follows by the induction hypothesis. The argument for ∨ is similar. Thus, let F =G → H . If Y (cid:12)|(cid:8) F , then F Y = ⊥ and the equivalence in the assertion holds. Similarly, if Y (cid:12)|(cid:8) G, then F Y = (cid:7), and both Y |(cid:8) Fand Y |(cid:8) F Y hold. Finally, let Y |(cid:8) G and Y |(cid:8) H . In this case, F Y = G → H Y . By the inductive hypothesis, Y |(cid:8) H Y and so,Y |(cid:8) G → H Y . Thus, also in that case, both Y |(cid:8) F and Y |(cid:8) F Y hold. (cid:2)It follows that FLP-stable models are indeed models of formulas and theories.Corollary 1. Let F be a theory and Y a set of atoms. If Y is an FLP-stable model of F , then Y is a model of F .This result allows us to prove that on theories consisting of formulas of the form (2) FLP-stable models defined here andstable models of Faber et al. [16] coincide. Thus, our approach is a generalization of the one by Faber et al.Theorem 3. Let P be a theory consisting of formulas of type (2). Then Y is a stable model of P according to the definition by Faber etal. [16] if and only if Y is the FLP-stable model, according to Definition 1.(cid:15)(cid:15)(cid:15)Proof. Let P be a theory consisting of formulas (2), and let Y be a set of atoms. For a formula R = F → C1 ∨ · · · ∨ C sfrom P , we denote by Rthe reducts of R with respect to Y according to Faber et al., and according to ourdefinition, respectively. Further, we write P (cid:15)for the reducts of a program P with respect to Y according to Faberet al., and according to our definition, respectively.and P (cid:15)(cid:15)and RReasoning in either direction we can assume that Y is a model of P (it is known that stable models according toconsists of those rules R = F →differs only in that each formula(cid:15)(cid:15)1, . . . , Ctmay also contain (cid:7). It is evident, that forif and only if Y is a minimal model of P (cid:15)(cid:15),Faber et al. [16] are models; for FLP-stable models, it follows from Corollary 1). Thus, P (cid:15)C1 ∨ · · · ∨ C s, for which Y |(cid:8) F . In addition, it might possibly contain (cid:7). The reduct P (cid:15)(cid:15)R = F → C1 ∨ · · · ∨ C s from P that is retained in P (cid:15)are precisely those elements in {C1, . . . , C s} that hold in Y . In addition, as P (cid:15)every Z ⊆ Y , Z |(cid:8) P (cid:15)and so, the result follows. (cid:2). Thus, Y is a minimal model of P (cid:15)if and only if Z |(cid:8) P (cid:15)(cid:15), contributes to P (cid:15)(cid:15)its reduct R, P (cid:15)(cid:15)(cid:15)t , where C(cid:15)(cid:15) = F → C∨ · · · ∨ C(cid:15)1One of the problematic properties of the literal attempt to generalize the approach by Faber et al. was that stable modelsof some theories contained atoms without head occurrences. We will now show that our generalization behaves properlyin this respect.Proposition 2. Let F be a theory and Y an FLP-stable model of F . Then every atom in Y has a head occurrence in F .Proof. First, we prove by induction that for every set S of atoms containing all atoms with head occurrences in a formula F ,and for every Z ⊆ At, if Z |(cid:8) F then Z ∩ S |(cid:8) F Z . It is a stronger property than what we need below, but it is the one forwhich the inductive argument can be made to work. If F = ⊥, the claim is trivially true. If F = A, then A ∈ S. Let Z be anysubset of At such that Z |(cid:8) F . Then, it follows that A ∈ Z and F Z = A. Thus, Z ∩ S |(cid:8) F Z holds, as claimed. If F = G ∧ H orG ∨ H , then atoms with head occurrences in G (H , respectively) are contained in S. Thus, the induction hypothesis appliesto G and H (G or H , respectively), and the claim follows.1292M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306Finally, let F = G → H . Since Z |(cid:8) F , F Z = (cid:7), or Z |(cid:8) G, Z |(cid:8) H and F Z = G → H Z . In the first case, the assertion isevident. In the latter case, we have Z |(cid:8) H . By the induction hypothesis (it can be used as all atoms with head occurrencesin H have head occurrences in F , and so they belong to S), Z ∩ S |(cid:8) H Z . Thus, Z ∩ S |(cid:8) F Z in that case, too.Next, we prove the result. Let S be the set of atoms with head occurrences in F . Since Y is an FLP-stable model of F ,Y |(cid:8) F Y . By Proposition 1, Y |(cid:8) F . By the claim we proved above, Y ∩ S |(cid:8) F Y . Since Y is a minimal model of F Y andY ∩ S ⊆ Y , Y ∩ S = Y and, consequently, Y ⊆ S. (cid:2)Finally, we state and prove two properties that we use later in the paper.Proposition 3. For every formulas F and G, and for every set of atoms Y :(1) F Y ≡ ⊥ if and only if Y (cid:12)|(cid:8) F ;(2) (F ◦ G)Y ≡ F Y ◦ G Y , where ◦ = ∧ or ∨.Proof. (1) We proceed by induction. The cases F = ⊥ and F = A, where A ∈ At, are straightforward. Thus, let us assumethat F = G ∧ H . First, we consider the case when Y (cid:12)|(cid:8) F . In that case, F Y = ⊥ and the “if ” part of the assertion follows.Conversely, let Y |(cid:8) F . Then, Y |(cid:8) G and Y |(cid:8) H . By Proposition 1, Y |(cid:8) G Y and Y |(cid:8) H Y . Thus, Y |(cid:8) G Y ∧ H Y . Since in suchcase F Y = G Y ∧ H Y , it follows that Y |(cid:8) F Y and so, F Y (cid:12)≡ ⊥. Thus, the “only if” part of the equivalence holds, too. The caseof ∨ is essentially the same.It remains to consider the case F = G → H . For the “if” part, as before, it suffices to notice that if Y (cid:12)|(cid:8) F , then F Y = ⊥.Conversely, let Y |(cid:8) F .Case 1. Y (cid:12)|(cid:8) G. Then, F Y = (cid:7) and so, F Y (cid:12)≡ ⊥.Case 2. Y |(cid:8) G. Since Y |(cid:8) F , Y |(cid:8) H follows. Consequently, F Y = G → H Y . In addition, by Proposition 1, Y |(cid:8) H Y . Thus,Y |(cid:8) F Y and F Y (cid:12)≡ ⊥.(2) We consider the case ◦ = ∧ only. The case ◦ = ∨ is similar. If Y |(cid:8) F ∧ G then (F ∧ G)Y and F Y ∧ G Y are equal! Thus,let us assume that Y (cid:12)|(cid:8) F ∧ G. It follows that (F ∧ G)Y = ⊥. Moreover, we have Y (cid:12)|(cid:8) F or Y (cid:12)|(cid:8) G. By (1), F Y ≡ ⊥ or G Y ≡ ⊥.Thus, F Y ∧ G Y ≡ ⊥, and the claim follows. (cid:2)3.3. Minimal-model propertyThe main objective of Faber et al. [16] was to generalize the stable-model semantics to the class of theories consisting ofrules of the form (2) so that stable models would be minimal models. Faber et al. proved that their generalization indeedhas that property.The extended FLP semantics has the minimal-model property for a broad class of theories, including those consisting ofrules (2), but not in general.Example 6. Let F = ¬ A ∨ A and Y = ∅. Since Y |(cid:8) A → ⊥ and Y (cid:12)|(cid:8) A, (¬ A)Y = ( A → ⊥)Y = (cid:7). Moreover, AY = ⊥. Thus,F Y ≡ (¬ A)Y ∨ AY ≡ (cid:7). Clearly, Y is a minimal model of F Y and so, an FLP-stable model of F . Next, let us consider Z = { A}.We now have (¬ A) Z = ( A → ⊥) Z = ⊥ and A Z = A. Thus, F Z ≡ (¬ A) Z ∨ A Z ≡ A. Again, Z is a minimal model of F Z and so,an FLP-stable model of F . Thus, FLP-stable models of F do not form an antichain and Z is not a minimal model of F .To describe a broad class of theories for which FLP-stable models are minimal models, we introduce monotone anddisjunctive-monotone formulas.Definition 2. A formula F is monotone if for every X ⊆ Y ⊆ At, X |(cid:8) F implies Y |(cid:8) F . A formula F is disjunctive-monotone ifevery occurrence of ∨ in F operates on monotone formulas.We note that a disjunctive-monotone formula does not have to be monotone. For instance, A ∧ ¬C is disjunctive-monotone (as it contains no occurrence of ∨) but not monotone. Similarly, a monotone formula is not necessarilydisjunctive-monotone. For instance, (cid:7) ∨ ¬ A is monotone but not disjunctive monotone.Proposition 4. For every disjunctive-monotone formula F and every sets of atoms X and Y such that X ⊆ Y , if X |(cid:8) F and Y |(cid:8) Fthen X |(cid:8) F Y .Proof. We proceed by induction. The case of F = ⊥ is vacuously true. If F = A, where A is an atom, then F Y = A = F (itfollows from the assumption that Y |(cid:8) A). Thus, X |(cid:8) F Y (as X |(cid:8) F ). For the inductive step, there are three cases to consider.M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061293Case 1. F = G ∧ H . Since F is disjunctive-monotone, G and H are disjunctive-monotone, too, and we also have X |(cid:8) G,X |(cid:8) H , Y |(cid:8) G and Y |(cid:8) H . By the induction hypothesis, X |(cid:8) G Y and X |(cid:8) H Y . Consequently, X |(cid:8) G Y ∧ H Y = (G ∧ H)Y = F Y .Case 2. F = G ∨ H . Since X |(cid:8) F , X |(cid:8) G or X |(cid:8) H . Without loss of generality, we may assume that X |(cid:8) G. Since F isdisjunctive-monotone, G is disjunctive-monotone. Moreover, G is monotone. Thus, Y |(cid:8) G. By the induction hypothesis,X |(cid:8) G Y . Since F Y = G Y ∨ H Y , X |(cid:8) F Y .Case 3. F = G → H . Since Y |(cid:8) F , F Y (cid:12)= ⊥. If F Y = (cid:7) then X |(cid:8) F Y = (cid:7). If, on the other hand, Y |(cid:8) G, Y |(cid:8) H and F Y = G →H Y , then there are two cases to consider. If X (cid:12)|(cid:8) G, then X |(cid:8) F Y . If X |(cid:8) G, then X |(cid:8) H . Since H is disjunctive-monotone(as F is), by induction it holds that X |(cid:8) H Y . Thus, X |(cid:8) F Y in that case, too. (cid:2)Corollary 2. Let F be a theory such that every formula in F is of the form H or G → H , where H is disjunctive-monotone. For everyX ⊆ Y ⊆ At, if X |(cid:8) F and Y |(cid:8) F , then X |(cid:8) F Y .Proof. To prove the result, it suffices to prove it for each formula F in F . If F is disjunctive-monotone, then the resultfollows from Proposition 4. If F = G → H , where H is disjunctive-monotone, we reason as follows. Since Y |(cid:8) F , we haveF Y = (cid:7); or Y |(cid:8) G, Y |(cid:8) H and F Y = G → H Y . In the first case, X |(cid:8) F Y is evident. In the second case, if X (cid:12)|(cid:8) G, the assertionfollows. Otherwise, since X |(cid:8) F , X |(cid:8) H . By Proposition 4, X |(cid:8) H Y follows. Consequently, X |(cid:8) F Y follows, as well. (cid:2)Proposition 4 and Corollary 2 imply that for the class of theories of the type considered in Corollary 2, FLP-stable modelsare minimal.Corollary 3. Let F be a theory such that every formula in F is of the form H or G → H , where H is disjunctive-monotone. If Y is anFLP-stable model of F then Y is a minimal model of F .Proof. Since Y is a model of F Y , Y is a model of F (Proposition 1). Let us assume that X |(cid:8) F and X ⊆ Y . By Corollary 2,X |(cid:8) F Y . Since Y is a minimal model of F Y , X = Y . Thus, Y is a minimal model of F . (cid:2)Corollary 3 extends the result by Faber et al., as it applies in particular to theories consisting of formulas of type (2). Itcan be generalized further to the case, where each formula in a theory is of the form Hk → (Hk−1 → (· · · → (H1 → H0) · · ·)),where k (cid:2) 0 and H0 is disjunctive monotone. The argument is essentially the same.3.4. Computational complexity for FLP semanticsIt is well known that the truth value of a formula in an interpretation can be found in polynomial time. It follows thatgiven a formula and a set of atoms Y , one can compute F Y in polynomial time by means of a simple recursive algorithmthat directly follows the definition of the reduct. Further, we have that the problem to decide whether a model of a formulais a minimal model is in the class coNP (in fact, one can show it is coNP-complete). Indeed, the complementary problem,to decide whether a given model of a formula is not a minimal one is in NP (a model properly contained in the givenone serves as a witness). Thus, the problem to decide whether a formula has an FLP-stable model is in the class Σ P2 .The completeness of the problem for the class Σ P2 follows from the fact that on disjunctive programs FLP-stable modelscoincide with stable models [16], and the existence problem for stable models is Σ P2 -complete [15]. Consequently, decidingthe existence of an FLP-stable model is Σ P2 -complete, too. We state that result below, together with two other related resultsthat can be proved by similar arguments.Theorem 4. The problem of the existence of an FLP-stable model is Σ Pgiven atom a member of every FLP-stable model) is Π Pof some FLP-stable model) is Σ P2 -complete.2 -complete. Skeptical reasoning with FLP-stable models (is a2 -complete. Brave reasoning with FLP-stable models (is a given atom a member3.5. HT-interpretations and FLP semantics — strong equivalenceWe now describe FLP-stable models in terms of HT-interpretations, and apply that result to characterize strong equiva-lence with respect to the FLP semantics. First, we define a certain satisfiability relation |(cid:8)flp between HT-interpretations andformulas. The definition is inductive and follows the same pattern as that for |(cid:8)ht. The cases (cid:13) X, Y (cid:14) |(cid:8)flp F for F = ⊥, F = A,where A ∈ At, F = G ∧ H and G ∨ H , are handled as in the case of |(cid:8)ht. For the implication we have the following clause:(cid:15)5. (cid:13) X, Y (cid:14) |(cid:8)flp G → H if Y |(cid:8) G → H ; and Y (cid:12)|(cid:8) G, or X (cid:12)|(cid:8) G, or (cid:13) X, Y (cid:14) |(cid:8)flp H .1294M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306The relation |(cid:8)flp extends in a standard way to HT-interpretations and sets of formulas. If F is a theory and (cid:13) X, Y (cid:14) |(cid:8)flp F ,we say that (cid:13) X, Y (cid:14) is an FLP-model of F (not to be confused with an FLP-stable model).We have the following simple property of |(cid:8)flp, mirroring a similar one for |(cid:8)ht (cf. Theorem 1).Theorem 5. For every formula F and every sets X ⊆ Y ⊆ At:(1) (cid:13) X, Y (cid:14) |(cid:8)flp F implies Y |(cid:8) F ;(2) (cid:13) X, Y (cid:14) |(cid:8)flp ¬F if and only if Y (cid:12)|(cid:8) F ;(3) (cid:13)Y , Y (cid:14) |(cid:8)flp F if and only if Y |(cid:8) F .Proof. (1) The case F = ⊥ is evident. If F = A, where A ∈ At, and (cid:13) X, Y (cid:14) |(cid:8)flp F , then A ∈ X . Thus, A ∈ Y and Y |(cid:8) F . Theinductive step for F = G ∧ H and F = G ∨ H is standard. If F = G → H and (cid:13) X, Y (cid:14) |(cid:8) F then, in particular, Y |(cid:8) F (by thedefinition of |(cid:8)flp for the case of implication). Thus, the claim follows.(2) By the definition, (cid:13) X, Y (cid:14) |(cid:8)flp ¬F if and only if Y |(cid:8) ¬F , and Y (cid:12)|(cid:8) F or X (cid:12)|(cid:8) F or (cid:13) X, Y (cid:14) |(cid:8)flp ⊥. Thus, (cid:13) X, Y (cid:14) |(cid:8)flp ¬F ifand only if Y |(cid:8) ¬F and the claim follows.(3) We show only the argument in the inductive step for the case F = G → H (the basis and all other cases are straight-forward). First, by the definition, if (cid:13)Y , Y (cid:14) |(cid:8)flp F then Y |(cid:8) F . Conversely, if Y |(cid:8) F , then Y (cid:12)|(cid:8) G or Y |(cid:8) H . By the inductionhypothesis, Y |(cid:8) H is equivalent to (cid:13)Y , Y (cid:14) |(cid:8)flp H . Thus, (cid:13)Y , Y (cid:14) |(cid:8)flp F . (cid:2)Similarly as the relation |(cid:8)ht and the F-reduct, the |(cid:8)flp relation and the FLP-reduct are closely connected (cf. Theorem 2).Theorem 6. For every formula F and for every two sets of atoms X ⊆ Y , X |(cid:8) F Y if and only if (cid:13) X, Y (cid:14) |(cid:8)flp F .Proof. We proceed by induction. The case when F = ⊥ is straightforward. Let F = A, where A ∈ At. If X |(cid:8) A Y , then AY (cid:12)= ⊥.Thus, AY = A. It follows that X |(cid:8) A and so, (cid:13) X, Y (cid:14) |(cid:8) A. Conversely, if (cid:13) X, Y (cid:14) |(cid:8) A, then X |(cid:8) A. Since X ⊆ Y , Y |(cid:8) A. Thus,AY = A and X |(cid:8) AY as required.let F = G ∧ H .If X |(cid:8) (G ∧ H)Y , then (G ∧ H)Y = G Y ∧ H Y . Thus, X |(cid:8) G Y and X |(cid:8) H Y . By the induc-tive hypothesis, (cid:13) X, Y (cid:14) |(cid:8) G and (cid:13) X, Y (cid:14) |(cid:8) H . Thus, (cid:13) X, Y (cid:14) |(cid:8) G ∧ H , as needed. Conversely, let (cid:13) X, Y (cid:14) |(cid:8) G ∧ H . Then(cid:13) X, Y (cid:14) |(cid:8) G and (cid:13) X, Y (cid:14) |(cid:8) H and, by the inductive hypothesis, X |(cid:8) G Y and X |(cid:8) H Y . Thus, X |(cid:8) G Y ∧ H Y . By Proposition 3,G Y ∧ H Y ≡ (G ∧ H)Y . Thus, X |(cid:8) (G ∧ H)Y .Next,The argument for the case F = G ∨ H is similar. Thus, we move on to the case F = G → H . We have the followingequivalences:(1) X |(cid:8) (G → H)Y ;(2) Y (cid:12)|(cid:8) G; or Y |(cid:8) G and Y |(cid:8) H , and X |(cid:8) G → H Y ;(3) Y (cid:12)|(cid:8) G; or Y |(cid:8) H and X |(cid:8) G → H Y ;(4) Y (cid:12)|(cid:8) G or Y |(cid:8) H ; and Y (cid:12)|(cid:8) G or X |(cid:8) G → H Y ;(5) Y |(cid:8) G → H ; and Y (cid:12)|(cid:8) G or X (cid:12)|(cid:8) G, or X |(cid:8) H Y ;(6) Y |(cid:8) G → H ; and Y (cid:12)|(cid:8) G or X (cid:12)|(cid:8) G, or (cid:13) X, Y (cid:14) |(cid:8)flp H .The last statement is equivalent to (cid:13) X, Y (cid:14) |(cid:8)flp F and the result follows. (cid:2)Theorem 6 is the key to a characterization of FLP-stable models in terms of the relation |(cid:8)flp.Corollary 4. Let F be a theory and Y a set of atoms. Then Y is an FLP-stable model of F if and only if (cid:13)Y , Y (cid:14) |(cid:8)flp F and for everyX ⊂ Y , (cid:13) X, Y (cid:14) (cid:12)|(cid:8)flp F .Proof. By the definition, Y is an FLP-stable model of F if and only if Y |(cid:8) F Y and, for every X ⊂ Y , X (cid:12)|(cid:8) F Y . We applyTheorem 6. The former condition is equivalent to (cid:13)Y , Y (cid:14) |(cid:8)flp F . The latter one can be stated equivalently as: for everyX ⊂ Y , (cid:13) X, Y (cid:14) (cid:12)|(cid:8)flp F . Thus, the assertion follows. (cid:2)Example 7. Let us consider the theory E2 = {( A ∨ ¬ A) → A} from Example 2. Let Y = ∅. Then Y (cid:12)|(cid:8) ( A ∨ ¬ A) → A, and so,(cid:13)Y , Y (cid:14) (cid:12)|(cid:8)flp E2. Thus, in agreement with our results, Y = ∅ is not an FLP-stable model of E2.For Z = { A}, the situation is different. First, we note that now Z |(cid:8) ( A ∨ ¬ A) → A and (cid:13)Z , Z (cid:14) |(cid:8)flp A (as A ∈ Z ). Thus,(cid:13)Z , Z (cid:14) |(cid:8)flp ( A ∨ ¬ A) → A and so, (cid:13)Z , Z (cid:14) |(cid:8)flp E2. Clearly, X = ∅ is the only proper subset of Z and (cid:13) X, Z (cid:14) (cid:12)|(cid:8)flp ( A ∨ ¬ A) → A(indeed, we have Z |(cid:8) A ∨ ¬ A, X |(cid:8) A ∨ ¬ A and (cid:13) X, Z (cid:14) (cid:12)|(cid:8)flp A (as A /∈ X )). According to Corollary 4, { A} is an FLP-stablemodel of E2 (as we already established by means of the reduct-based definition in Example 2).M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061295We conclude this section with a discussion of the notion of strong FLP-equivalence. Theories F and G are strongly FLP-equivalent if for every theory H, the theories F ∪ H and G ∪ H have the same FLP-stable models. This is a literal adaptationof the standard definition of strong equivalence [32] to the case of FLP-stable models.Theorem 7. Let F and G be two formulas. Then, F and G are strongly FLP-equivalent if and only if F and G have the same FLP-models.Proof. (⇐) For every theory H, (cid:13) X, Y (cid:14) |(cid:8)flp F ∪ H if and only if (cid:13) X, Y (cid:14) |(cid:8)flp G ∪ H. By Corollary 4, F ∪ H and G ∪ H havethe same FLP-stable models.(⇒) Let us assume that there are X ⊆ Y ⊆ At such that (cid:13) X, Y (cid:14) satisfies one of F and G but not the other. Without lossof generality, we may assume that (cid:13) X, Y (cid:14) |(cid:8)flp F and (cid:13) X, Y (cid:14) (cid:12)|(cid:8)flp G. By Theorem 6, it follows that X |(cid:8) F Y and X (cid:12)|(cid:8) G Y . Thefirst property implies that F Y (cid:12)≡ ⊥. Consequently, by Proposition 3, Y |(cid:8) F . By Proposition 1, Y |(cid:8) F Y .Case 1. Y (cid:12)|(cid:8) G Y . It follows that (cid:13)Y , Y (cid:14) (cid:12)|(cid:8)flp G. Thus, Y (cid:12)|(cid:8) G and for every H, Y (cid:12)|(cid:8) G ∪ H. Thus, Y is not an FLP-stable modelof G ∪ H. Let us now define H = Y . We have (F ∪ H)Y ≡ F Y ∪ HY . Moreover, HY = H. Thus, (F ∪ H)Y ≡ F Y ∪ H. It followsthat (a) Y |(cid:8) (F ∪ H)Y , and (b) there is no X ⊂ Y such that X |(cid:8) (F ∪ H)Y . Thus, Y is an FLP-stable model of F ∪ H. As wenoted, Y is not an FLP-stable model of G ∪ H. Thus, F and G are not strongly FLP-equivalent, a contradiction.Case 2. Y |(cid:8) G Y . We recall that X (cid:12)|(cid:8) G Y . Thus, X ⊂ Y . We defineH = X ∪ { A → B | A, B ∈ Y \ X}.We have (F ∪ H)Y ≡ F Y ∪ HY . Moreover, it is easy to check that HY = H. Thus, (F ∪ H)Y ≡ F Y ∪ H. We recall thatX |(cid:8) F Y . We also have X |(cid:8) H. Thus, X |(cid:8) (F ∪ H)Y and so, Y is not an FLP-model of F ∪ H. Since (G ∪ H)Y ≡ G Y ∪ H,Y |(cid:8) G Y , and Y |(cid:8) H, we have Y |(cid:8) (G ∪ H)Y . Let Z ⊂ Y be such that Z |(cid:8) G Y ∪ H. Since Z |(cid:8) H, Z = X . However, X (cid:12)|(cid:8) G Y ,a contradiction. Thus, Y is a minimal model of (G ∪ H)Y and so a stable model of G ∪ H. This contradicts our assumptionthat F and G are FLP-equivalent. Consequently, F and G have the same FLP-models. (cid:2)4. Normal forms and a comparison with stable-model semanticsThe following result was obtained by Cabalar and Ferraris [8]. It concerns representing theories by programs — theoriesconsisting of rules (formulas of the form (1)).Theorem 8. For every theory F there is a program G (in the same language) such that F and G have the same HT-models (areequivalent in the logic HT).In other words, every theory F is strongly equivalent to some program G. A similar result holds for the FLP-models and,in fact, it can be obtained by means of a very similar argument to that used by Cabalar and Ferraris [8]. In what followswe write ¬Y for {¬ y | y ∈ Y }. We first state and prove three auxiliary results (analogous to results proved by Cabalar andFerraris [8] for HT-countermodels).Proposition 5. Let X ⊂ Y ⊆ Z be finite. Then (cid:13)U , V (cid:14), where U ⊆ V ⊆ Z , is an FLP-countermodel of(where the set complements X and Y are defined with respect to Z ) if and only if U = X and V = Y .(cid:7)(cid:7)X ∧¬Y →(cid:8)(cid:8)¬YX ∨Proof. Let us denoteX ∨subformula of(cid:8)(cid:7)(cid:8)(cid:7)(cid:8)(cid:8)¬Y →X ∨X ∧¬Y . Thus, F is a propositional tautology.¬Y by F . Since Y \ X (cid:12)= ∅, there is a ∈ Y \ X . It follows that a ∨ ¬a is aLet us consider a pair (cid:13)U , V (cid:14), where U ⊆ V . Due to the observation above, (cid:13)U , V (cid:14) is an FLP-countermodel of F if andonly if(cid:9)(cid:9)X ∧V |(cid:8)¬Y , U |(cid:8)(cid:9)(cid:9)X ∧¬Y ,and (cid:13)U , V (cid:14) (cid:12)|(cid:8)flp(cid:8)(cid:8)(cid:10)(cid:10)X ∨¬Y .Moreover, from the definition, one can check that (cid:13)U , V (cid:14) (cid:12)|(cid:8)flpX ∨¬Y if and only if U (cid:12)|(cid:8)(cid:7)(cid:8)X and U (cid:12)|(cid:8)X , X ⊆ U and U ∩ X = ∅. Thus, U = X . Since V |(cid:8)Now, since U |(cid:8)Y ⊆ V . Thus, V = Y .Conversely, if U = X and V = Y then V |(cid:8)FLP-countermodel of F . (cid:2)(cid:7)(cid:7)X ∧¬Y , U |(cid:8)(cid:7)(cid:7)X ∧¬Y , U (cid:12)|(cid:8)(cid:8)(cid:8)(cid:7)X and V (cid:12)|(cid:8)(cid:8)¬Y and V (cid:12)|(cid:8)(cid:8)(cid:8)¬Y .¬Y , V ⊆ Y andX and V (cid:12)|(cid:8)¬Y . Thus, (cid:13)U , V (cid:14) is anProposition 6. Let Y ⊆ Z be finite. Then (cid:13)U , V (cid:14), where U ⊆ V ⊆ Z , is an FLP-countermodel tocomplement Y is defined with respect to Z ) if and only if V = Y .(cid:7)Y ∧(cid:7)¬Y → ⊥ (where the set1296M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306(cid:7)Proof. By the definition, (cid:13)U , V (cid:14) is an FLP-countermodel to Y ∧Y ∧the disjunction of the two conditions is equivalent to V = Y , as required. (cid:2)¬Y , or (2) V |(cid:8)¬Y . The condition (1) is equivalent to V = Y . The condition (2) is equivalent to U = V = Y . Thus¬Y → ⊥ if and only if (1) V |(cid:8) Y ∧¬Y and U |(cid:8) Y ∧(cid:7)(cid:7)(cid:7)Proposition 7. Let F be a formula. If (cid:13)Y , Y (cid:14) is an FLP-countermodel of F , then for every X ⊆ Y , (cid:13) X, Y (cid:14) is an FLP-countermodel of F .Proof. If (cid:13)Y , Y (cid:14) is an FLP-countermodel of F , then Y (cid:12)|(cid:8) F Y (Theorem 6) and so, Y (cid:12)|(cid:8) F (Proposition 1). Consequently, byTheorem 5, (cid:13) X, Y (cid:14) is an FLP-countermodel of F . (cid:2)Theorem 9. Let F be a theory. There exists a program G such that F and G have the same FLP-models.Proof. For F ∈ F , we consider FLP-countermodels (cid:13) X, Y (cid:14) of F such that Y ⊆ At(F ). For each FLP-countermodel (cid:13) X, Y (cid:14) withX (cid:12)= Y , we take the formula defined in Proposition 5 (with Z = At(F )). For each countermodel (cid:13) X, Y (cid:14) such that X = Y , wetake the formula from Proposition 6. We take for G the set of all rules constructed in that way from countermodels offormulas in F . By Proposition 7, F and G have the same FLP-countermodels consisting of atoms in At(F ) and so, the sameFLP-models consisting of atoms in At(F ). Thus, they have the same FLP-models. (cid:2)We saw (Examples 1–2 and 4–5) that the semantics of stable and FLP-stable models are different and neither is strongerthan the other one. However, each can be expressed in terms of the other one. To see that, we first observe that HT- andFLP-models of rules coincide.Proposition 8. Let R be a rule. Then, R has the same HT- and FLP-models.(cid:7)(cid:7)(cid:8)(cid:8)Proof. Let R =and X ∩ A = ∅ or B ⊆ Y or C ⊆ X or Y ∩ D = ∅.¬B →C ∨A ∧¬D. Directly from the definition, it follows that (cid:13) X, Y (cid:14) |(cid:8)ht R if and only if Y |(cid:8) R;Similarly, (cid:13) X, Y (cid:14) |(cid:8)flp R if and only if Y |(cid:8) R; and X ∩ A = ∅ or B ⊆ X or Y ∩ A = ∅ or B ⊆ Y or C ⊆ X or Y ∩ D = ∅. SinceX ∩ A = ∅ or Y ∩ A = ∅ if and only if X ∩ A = ∅, and B ⊆ X or B ⊆ Y if and only if B ⊆ Y , the result follows. (cid:2)Theorems 8 and 9 yield now the following two corollaries relating the two semantics.Corollary 5. For every theory F there are programs Fht and F f lp such that(1) (cid:13) X, Y (cid:14) is an HT-model of F if and only if (cid:13) X, Y (cid:14) is an FLP-model of Fht ;(2) (cid:13) X, Y (cid:14) is an FLP-model of F if and only if (cid:13) X, Y (cid:14) is an HT-model of F f lp .Proof. It is enough to take for Fht and F f lp programs guaranteed by Theorems 8 and 9, respectively. (cid:2)Thus the meaning of any theory F under HT-models is captured by FLP-models of the normal form Fht of F that isassured by Theorem 8. Similarly, the meaning of any theory F under FLP-models is captured by HT-models of the normalform F f lp of F given by Theorem 9. As another corollary we state a result relating stable and FLP-stable models of F , Fhtand F f lp .Corollary 6. For every theory F :(1) Y is a stable model of F if and only if Y is an FLP-stable model of Fht ;(2) Y is an FLP-stable model of F if and only if Y is a stable model of F f lp .We mention that recently Lee and Meng [29] obtained a result related to Corollary 6(2) but restricted to formulas that areprograms with aggregates. Namely, they showed that a program, say F , as considered by Faber et al. [16] (and so, possiblywith aggregates in the bodies of rules), can be compiled into propositional formula FLP(F ) so that FLP-stable answer setsof P correspond to stable models of FLP(F ).We close by pointing out a drawback of the FLP semantics. Namely, the operator of ↔ does not function, in general, asthe operator of explicit definition.2 For instance, if we introduce a new atom B, then the theory E (cid:15)= {¬B → A, ¬ A ↔ B}1(we obtain it from E1 by replacing ¬ A with B and adding the “definition” ¬ A ↔ B) has two FLP-stable models,{B} and { A}, while the original theory E1 has only one FLP-stable model, { A} (and, in particular, no counterpart to thestable model {B}).2 This aspect of the FLP semantics was pointed out by one of the reviewers.M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–130612975. Supported modelsThe approach that yielded generalizations of stable and FLP-stable model semantics for arbitrary propositional theoriescan also be applied to the supported-model semantics.5.1. The reduct for the supported-model semanticsFor a formula F and a set of atoms X , we define the SPP-reduct of F with respect to Y , written as F Y , by adapting tothe new notation the inductive clauses (R1)–(R3), and using the following definition for the implication:SPP4.(G → H)Y =⎧⎨⎩if Y |(cid:8) G and Y |(cid:8) H,H Y(cid:7) if Y (cid:12)|(cid:8) G,⊥ otherwise.This notion of reduct is motivated by the definition of supported models in the case of programs with disjunctive rules[6,27]. We recall that definition. Let P be a disjunctive program. The supp-reduct of P with respect to a set of atoms Y ,P (Y ), is the set of the heads of those rules in P whose body is satisfied by Y . A set of atoms Y is a supported model of P ifY is a minimal model of P (Y ).The basic idea behind P (Y ) is to drop the antecedent of a rule if the antecedent is satisfied by Y . We adopt that idea inthe definition of the SPP-reduct. However, in the first case of the definition, we set the reduct (G → H)Y to be H Y ratherthan H due to the same reasons we discussed when generalizing the FLP-reduct. With the definition of the reduct in hand,the definition of a supported model is standard.Definition 3. Let F be a theory. A set of atoms Y is a supported model of F if Y is a minimal model of F Y .Example 8. We will one more time consider theories E1 = {¬¬ A → A} and E2 = {( A ∨ ¬ A) → A} from Examples 1 and 2,respectively. First, let Y = ∅. Clearly, we have Y (cid:12)|(cid:8) ¬¬ A. Thus, E Y= (cid:7). It follows that Y |(cid:8) E1 and, as Y = ∅, Y is a supportedmodel of E1 being trivially a minimal model of E Y= ⊥ and Y is not asupported model of E2.1 . On the other hand, Y (cid:12)|(cid:8) ( A ∨ ¬ A) → A. Thus, E Y12Next, let Z = { A}. Then, Z |(cid:8) ¬¬ A and Z |(cid:8) A. Thus, E Zof E1. Similarly, Z |(cid:8) ( A ∨ ¬ A) and Z |(cid:8) A. Thus, E Z21= (¬¬ A → A) Z = A Z = A. It follows that Z is a supported model= (( A ∨ ¬ A) → A) Z = A Z = A, and Z is a supported model of E2, too.The results and the proofs that worked in the case of stable and FLP semantics work, with only minor changes (andwith one exception) in the case of supported models, too. We start by gathering in one result several basic properties of theSPP-reduct and supported models.Proposition 9. For every theory F and every set of atoms Y :(1) Y |(cid:8) F if and only if Y |(cid:8) F Y ;(2) Y |(cid:8) F if and only if F Y (cid:12)≡ ⊥;(3) If Y is a supported model of F , then Y is a model of F ;(4) If Y is a supported model of F , then every atom in Y has a head occurrence in F .Proof. (1) It is enough to consider the case when F consists of a single formula F . We proceed by structural induction. Thebase cases of F = ⊥ and F = A, where A ∈ At, are straightforward. Let us consider F = G ∧ H . If Y (cid:12)|(cid:8) F , then F Y = ⊥. Thus,both sides of the equivalence are false, and the equivalence follows. If Y |(cid:8) F , then F Y = G Y ∧ H Y . By the definition and theinductive hypothesis, the following statements are equivalent:Y |(cid:8) F ,Y |(cid:8) G ∧ H,Y |(cid:8) G,Y |(cid:8) G YY |(cid:8) G Y ∧ H Y ,Y |(cid:8) F Y .and Y |(cid:8) H,and Y |(cid:8) H Y ,1298M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306Thus, again the required equivalence holds. The argument for ∨ is similar. Let then F = G → H . If Y (cid:12)|(cid:8) F , then F Y = ⊥ andthe equivalence in the assertion holds. Similarly, if Y (cid:12)|(cid:8) G, then F Y = (cid:7), and both Y |(cid:8) F and Y |(cid:8) F Y hold. Finally, let usassume that Y |(cid:8) G and Y |(cid:8) H . In this case, F Y = H Y . By the inductive hypothesis, Y |(cid:8) H Y and so, Y |(cid:8) F Y . Thus, also inthat case, both Y |(cid:8) F and Y |(cid:8) F Y hold.(2) As before, it is enough to consider the case when F consists of a single formula F . If Y |(cid:8) F then (1) implies thatF Y (cid:12)≡ ⊥. We prove the converse implication by induction. If F = ⊥, then the implication is trivially true. If F = A, whereA is an atom, then F Y = A (as the assumption excludes the only other possibility that F Y (cid:12)= ⊥). It follows that A ∈ Y andso, Y |(cid:8) F . Next, let F = G ∧ H . Since F Y (cid:12)≡ ⊥, F Y = G Y ∧ H Y . Moreover, G Y (cid:12)≡ ⊥ and H Y (cid:12)≡ ⊥. By the induction hypothesis,Y |(cid:8) G and Y |(cid:8) H . Thus, Y |(cid:8) F . The case F = G ∨ H is similar. Finally, if F = G → H , we have that either Y (cid:12)|(cid:8) G, or Y |(cid:8) G,Y |(cid:8) H and F Y = H Y . In either case, Y |(cid:8) F .(3) Follows from (1) and from the definition of a supported model.(4) We first show that for every formula F and every set of atoms S containing all atoms with head occurrences in F , ifY ⊆ At and Y |(cid:8) F then Y ∩ S |(cid:8) F Y . We proceed by induction. If F = ⊥, the claim is trivially true. If F = A, then A ∈ S. IfY |(cid:8) F , then A ∈ Y and F Y = A. Thus, the claim follows. If F = G ∧ H or G ∨ H , then Y |(cid:8) G and (or, respectively) Y |(cid:8) H .Moreover, atoms with head occurrences in G are contained in S and the same holds for H . Thus, the induction hypothesisapplies to G and H . Consequently, we have Y ∩ S |(cid:8) G and (or, respectively) Y ∩ S |(cid:8) H , and the claim follows.Finally, let F = G → H . Since Y |(cid:8) F , F Y = (cid:7), or Y |(cid:8) G, Y |(cid:8) H and F Y = H Y . In the first case, the assertion is evident.In the latter case, we have Y |(cid:8) H . By the induction hypothesis (it applies, as every atom with a head occurrence in H hasa head occurrence in F and so, it belongs to S), Y ∩ S |(cid:8) H Y . Thus, Y ∩ S |(cid:8) F Y in that case, too.We are ready to prove the assertion (4). Let S be the set of atoms with head occurrences in F . Since Y is a supportedmodel of F , Y |(cid:8) F Y . By (1), Y |(cid:8) F . Thus, by the property proved above, Y ∩ S |(cid:8) F Y . Since Y is a minimal model of F Y ,and Y ∩ S ⊆ Y , Y ∩ S = Y . Consequently, Y ⊆ S. (cid:2)We now observe that our concept of a supported model indeed generalizes that of a disjunctive program [6].Theorem 10. Let P be a disjunctive program. Then, Y ⊆ At is a supported model of P according to our definition if and only if Y is asupported model according to the original definition of supported models of disjunctive logic programs.Proof. If Y is a supported model according to either definition, Y is a model of P . Using this observation, as well as thedefinitions of the corresponding reducts, one can show that H 1 ∨ · · · ∨ Hk ∈ P Y if and only if k (cid:2) 1 and there are atomsHk+1, . . . , Hm such that H i /∈ Y , k + 1 (cid:3) i (cid:3) m, and H1 ∨ · · · ∨ Hk ∨ Hk+1 ∨ · · · ∨ Hm ∈ P (Y ). Let us assume that Y is asupported model of P according to the original definition. It follows that Y is a minimal model of P (Y ). By the observationabove, Y is a model of P Y . If Z ⊆ Y is a model of P Y , then Z is a model of P (Y ) (again, by the observation above, we havethat P Y classically entails P (Y )). Thus, Z = Y and Y is a minimal model of P Y . Consequently, Y is a supported model of Paccording to our definition.Conversely, let Y be a supported model of P according to our definition. Then, Y is a minimal model of P Y . Since P Yclassically entails P (Y ), Y is a model of P (Y ). Let Z ⊆ Y be a model of P (Y ). Let H 1 ∨ · · · ∨ Hk ∈ P Y . By the observationabove, there are atoms Hk+1, . . . , Hm such that H i /∈ Y , k + 1 (cid:3) i (cid:3) m, and H1 ∨ · · · ∨ Hk ∨ Hk+1 ∨ · · · ∨ Hm ∈ P (Y ). It followsthat H i /∈ Z , k + 1 (cid:3) i (cid:3) m. Since Z is a model of P (Y ), it follows that Z is a model of H 1 ∨ · · · ∨ Hk. Thus, Z is a model ofP Y and, consequently, Z = Y . Thus, Y is a minimal model of P (Y ) and so, a supported model of P according to the originaldefinition. (cid:2)5.2. HT-interpretations and supported modelsNext, we characterize supported models in terms of a certain satisfiability relation that connects HT-interpretations andformulas. It follows closely the definitions of |(cid:8)ht and |(cid:8)flp but is modified for the case of the implication.(cid:15)(cid:15)5. (cid:13) X, Y (cid:14) |(cid:8)spp G → H if Y |(cid:8) G → H , and Y (cid:12)|(cid:8) G or (cid:13) X, Y (cid:14) |(cid:8)spp H .If (cid:13) X, Y (cid:14) |(cid:8)spp F , we say that (cid:13) X, Y (cid:14) is an SPP-model of F .Our next result gathers together some simple properties of the relation |(cid:8)spp that mirror those of |(cid:8)ht and |(cid:8)flp.Theorem 11. For every formula F and every sets X ⊆ Y ⊆ At:(1) (cid:13) X, Y (cid:14) |(cid:8)spp F implies Y |(cid:8) F ;(2) (cid:13) X, Y (cid:14) |(cid:8)spp ¬F if and only if Y (cid:12)|(cid:8) F ;(3) (cid:13)Y , Y (cid:14) |(cid:8)spp F if and only if Y |(cid:8) F .Proof. (1) We proceed by induction. The claim is evident for F = ⊥. If F = A, where A is an atom, (cid:13) X, Y (cid:14) |(cid:8)spp F impliesthat A ∈ X . Thus, A ∈ Y and Y |(cid:8) F . If F = G ∧ H , then (cid:13) X, Y (cid:14) |(cid:8)spp F implies (cid:13) X, Y (cid:14) |(cid:8)spp G and (cid:13) X, Y (cid:14) |(cid:8)spp H . By theM. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061299induction hypothesis, Y |(cid:8) G and Y |(cid:8) H . Thus, Y |(cid:8) G ∧ H and, consequently, Y |(cid:8) F . The case F = G ∨ H is similar. Finally,let F = G → H . By the definition, if (cid:13) X, Y (cid:14) |(cid:8)spp F then Y |(cid:8) F . Thus, the result follows.(2) By the definition, (cid:13) X, Y (cid:14) |(cid:8)spp ¬F if and only if Y |(cid:8) ¬F and Y (cid:12)|(cid:8) F . Thus, the claim follows.(3) The argument is similar. The inductive step for the case F = G → H (the basis and all other cases are straightforward)is as follows. First, by the definition, if (cid:13)Y , Y (cid:14) |(cid:8)spp F then Y |(cid:8) F . Conversely, if Y |(cid:8) F , then Y (cid:12)|(cid:8) G or Y |(cid:8) H . By theinduction hypothesis, Y (cid:12)|(cid:8) G or (cid:13)Y , Y (cid:14) |(cid:8)spp H . Since Y |(cid:8) F (= G → H ), (cid:13)Y , Y (cid:14) |(cid:8)spp F follows. (cid:2)The following result is analogous to similar results for |(cid:8)ht and |(cid:8)flp, and ties the SPP-reduct and the relation |(cid:8)spp(cf. Theorems 2 and 6).Theorem 12. For every theory F and for every two sets of atoms X ⊆ Y , X |(cid:8) F Y if and only if (cid:13) X, Y (cid:14) |(cid:8)spp F .Proof. It is enough to prove the result for a single formula F . We proceed by induction. The case when F = ⊥ is straight-forward. Let F = A, where A ∈ At. If X |(cid:8) AY , then AY (cid:12)= ⊥. Thus, AY = A. It follows that X |(cid:8) A and so, (cid:13) X, Y (cid:14) |(cid:8)spp A.Conversely, if (cid:13) X, Y (cid:14) |(cid:8)spp A, then X |(cid:8) A. Since X ⊆ Y , Y |(cid:8) A. Thus, AY = A and X |(cid:8) AY as required.Next, let F = G ∧ H . If X |(cid:8) (G ∧ H)Y , then (G ∧ H)Y = G Y ∧ H X . Thus, X |(cid:8) G Y and X |(cid:8) H Y . By the inductive hypothesis,(cid:13) X, Y (cid:14) |(cid:8)spp G and (cid:13) X, Y (cid:14) |(cid:8)spp H . Thus, (cid:13) X, Y (cid:14) |(cid:8)spp G ∧ H , as needed. Conversely, let (cid:13) X, Y (cid:14) |(cid:8)spp G ∧ H . Then (cid:13) X, Y (cid:14) |(cid:8)spp Gand (cid:13) X, Y (cid:14) |(cid:8)spp H . By the inductive hypothesis, we have X |(cid:8) G Y and X |(cid:8) H Y . Thus, X |(cid:8) G Y ∧ H Y . Clearly, G Y (cid:12)≡ ⊥ andH Y (cid:12)≡ ⊥. By Proposition 9(2), Y |(cid:8) G and Y |(cid:8) H . Thus, Y |(cid:8) G ∧ H and so, (G ∧ H)Y = G Y ∧ H Y . Hence, X |(cid:8) (F ∧ G)Y .The argument for the case F = G ∨ H is similar. And so, let us move on to the case F = G → H . We have the followingequivalences:X |(cid:8) (G → H)Y ,Y (cid:12)|(cid:8) G;Y (cid:12)|(cid:8) G;Y (cid:12)|(cid:8) G or Y |(cid:8) H;Y |(cid:8) G → H;(cid:13)X, Y (cid:14) |(cid:8)spp F .Thus, the result follows. (cid:2)or Y |(cid:8) G and Y |(cid:8) H,or Y |(cid:8) H and X |(cid:8) H Y ,and X |(cid:8) H Y ,and Y (cid:12)|(cid:8) G or X |(cid:8) H Y ,and Y (cid:12)|(cid:8) G or(cid:13)X, Y (cid:14) |(cid:8)spp H,The main consequence of Theorem 12 is a characterization of supported models in terms of the relation |(cid:8)spp.Corollary 7. Let F be a theory and Y a set of atoms. Then Y is a supported model of F if and only if (cid:13)Y , Y (cid:14) |(cid:8)spp F and for everyX ⊂ Y , (cid:13) X, Y (cid:14) (cid:12)|(cid:8)spp F .Proof. By the definition, Y is a supported model of F if and only if Y |(cid:8) F Y , and for every X ⊂ Y , X (cid:12)|(cid:8) F Y . We now applyTheorem 12. The former condition is equivalent to (cid:13)Y , Y (cid:14) |(cid:8)spp F . The latter one is equivalent to the property that for everyX ⊂ Y , (cid:13) X, Y (cid:14) (cid:12)|(cid:8)spp F . Thus, the assertion follows. (cid:2)5.3. Strong equivalence with respect to supported modelsWe will now study the strong equivalence of theories with respect to the supported-model semantics. Two theories Fand G are strongly SPP-equivalent if for every theory H, F ∪ H and G ∪ H have the same supported models. Corollary 7implies that if F and G have the same SPP-models then they are strongly SPP-equivalent. Unlike in the case of stable orFLP-stable semantics, though, that condition is not necessary. A weaker condition provides a characterization of strong SPP-equivalence. An SPP-model is essential if it is of the form (cid:13)Y , Y (cid:14) or (cid:13)Y \ { A}, Y (cid:14), where A ∈ At. Having the same essentialSPP-models is sufficient and necessary for F and G to be strongly SPP-equivalent. To prove it, we need a simple auxiliaryproperty.Proposition 10. For every formula F and for every interpretation Y , F Y is monotone.Proof. Clearly, if F = ⊥, F Y is trivially monotone. If F = A, where A ∈ At and X |(cid:8) F Y , then F Y = A and A ∈ X . Thus, forevery Z , if X ⊆ Z , Z |(cid:8) F Y .Let us assume that F = G ∧ H and that X |(cid:8) F Y . Since F Y = G Y ∧ H Y (we note that F Y (cid:12)= ⊥), X |(cid:8) G Y and X |(cid:8) H Y .Let Z be an interpretation such that X ⊆ Z . By the induction hypothesis, Z |(cid:8) G Y and Z |(cid:8) H Y . Thus, Z |(cid:8) G Y ∧ H Y and so,Z |(cid:8) F Y . The case of F = G ∨ H is similar.1300M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306Finally, let us assume that F = G → H and that X |(cid:8) F Y . It follows that F Y = (cid:7) or F Y = H Y . Clearly, if F Y = (cid:7) thenfor every interpretation Z such that X ⊆ Z , Z |(cid:8) F Y . If F Y = H Y , then X |(cid:8) H Y and, by the induction hypothesis, for everyinterpretation Z such that X ⊆ Z , Z |(cid:8) H Y . Thus, in either case, if X ⊆ Z , then Z |(cid:8) F Y . (cid:2)We now have the following characterization of strong SPP-equivalence. Unlike the one developed for programs [49],where the general case is established through a certain reduction to normal programs, the present characterization is direct.Theorem 13. Let F and G be two theories. Then, F and G are strongly SPP-equivalent if and only if F and G have the same essentialSPP-models.Proof. (⇒) Let (cid:13)Y , Y (cid:14) be an essential SPP-model of F . It follows that Y |(cid:8) F Y ∪ Y = (F ∪ Y )Y . Moreover, Y is a minimalmodel of F Y ∪ Y = (F ∪ Y )Y . Consequently, Y is a supported model of F ∪ Y . By the assumption, Y is a supported modelof G ∪ Y . Thus, Y is a model of G and so, by Proposition 9, Y |(cid:8) G Y . By Theorem 12, it follows that (cid:13)Y , Y (cid:14) is an SPP-modelof G.Next, let (cid:13)Y \ {a}, Y (cid:14) be an essential SPP-model of F . It follows that Y \ {a} |(cid:8) F Y . By Proposition 10, Y |(cid:8) F Y . Thus,(cid:13)Y , Y (cid:14) is an SPP-model of F . By the argument given above, (cid:13)Y , Y (cid:14) is an SPP-model of G. By Proposition 9, Y |(cid:8) G Y . Thus,Y |(cid:8) G Y ∪ (Y \ {a}) = (G ∪ (Y \ {a}))Y . Let us assume that (cid:13)Y \ {a}, Y (cid:14) is not an SPP-model of G. Then, Y \ {a} (cid:12)|(cid:8) G Y . Sinceevery model of (G ∪ (Y \ {a}))Y = G Y ∪ (Y \ {a}) contains Y \ {a}, and Y \ {a} (cid:12)|(cid:8) G Y , it follows that Y is a minimal model of(G ∪ (Y \ {a}))Y . Thus, Y is a supported model of G ∪ (Y \ {a}). Consequently, it is a supported model of F ∪ (Y \ {a}). ButY \ {a} |(cid:8) (F ∪ (Y \ {a}))Y , a contradiction. Thus, (cid:13)Y \ {a}, Y (cid:14) is an SPP-model of G. By symmetry, it follows that essentialSPP-models of F and G coincide.(⇐) Let H be any theory and let Y be a supported model of F ∪ H. It follows that (cid:13)Y , Y (cid:14) is an SPP-model of Fand of H. By the assumption, (cid:13)Y , Y (cid:14) is an SPP-model of G and of H. Thus, (cid:13)Y , Y (cid:14) |(cid:8)spp G ∪ H. Let X ⊂ Y be such thatX |(cid:8) (G ∪ H)Y . It follows that X |(cid:8) G Y and X |(cid:8) HY . Let a ∈ Y \ X (such an a exists). Then, by Proposition 10, Y \ {a} |(cid:8) G Yand Y \ {a} |(cid:8) HY . Thus, (cid:13)Y \ {a}, Y (cid:14) is an SPP-model of G and so, of F . It follows that Y \ {a} |(cid:8) F Y and, consequently, thatY \ {a} |(cid:8) F Y ∪ HY ≡ (F ∧ H)Y . This is a contradiction with Y being a supported model of F ∪ H. Thus, Y is a minimalmodel of (G ∪ H)Y and so, Y is a supported model of G ∪ H. By symmetry, F ∪ H and G ∪ H have the same supportedmodels. Thus, they are strongly SPP-equivalent. (cid:2)5.4. Complexity of reasoning with supported modelsIt turns out that, as in the case of disjunctive logic programs, reasoning with supported models is easier (assuming thepolynomial hierarchy does not collapse) than reasoning with stable or FLP-stable models. Namely, we have the followingresult.Theorem 14. The problem of the existence of a supported model is NP-complete. Skeptical reasoning with supported models is coNP-complete. Brave reasoning with supported models is NP-complete.Proof. Given a theory F and a set of atoms Y , Y is a minimal model of F Y if and only if Y |(cid:8) F Y and for every a ∈ Y ,Y \ {a} (cid:12)|(cid:8) F Y (by the monotonicity of F Y , cf. Proposition 10). Since F Y can be computed in polynomial time, it followsthat the problem of the existence of a supported model of a theory F is in the class NP. The membership of the othertwo problems in their respective classes can also be established as a consequence of the observation that the problem ofchecking whether a set of atoms Y is a supported model of a theory F is in the class P. The hardness part follows in eachcase from the well-known hardness of the corresponding problems under the restriction to normal programs. For the sakeof completeness, we will outline here a proof that the problem of the existence of a supported model of a normal programis NP-hard. To this end, we note that by the Fages Lemma [18], for normal programs without positive atoms in the bodiesof rules, stable and supported models coincide. The problem of the existence of a stable model for such programs is NP-complete (the construction used by Marek and Truszczy ´nski [39], demonstrates that). Thus, the problem of the existence ofa supported model for such programs is NP-complete, too and, consequently, the NP-hardness of the problem for arbitrarynormal programs follows. (cid:2)5.5. Normal form result for the supported-model semanticsAs in the other two cases, also for the supported-model semantics every theory has a normal form. However, now it isgiven by even simpler formulas — conjunctions of normal rules. We start by stating several simple properties concerningthe equivalence of formulas with respect to SPP-models. We say that two formulas F and G are SPP-equivalent, denotedF ≡spp G, if they have the same SPP-models.M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061301Proposition 11. For every formulas F , G and H :(1) F → G ≡spp ¬F ∨ G;(2) ¬(F ∨ G) ≡spp ¬F ∧ ¬G;(3) ¬(F ∧ G) ≡spp ¬F ∨ ¬G;(4) F ∧ (G ∨ H) ≡spp (F ∧ G) ∨ (F ∧ H);(5) F ∨ (G ∧ H) ≡spp (F ∨ G) ∧ (F ∨ H);(6) ¬¬¬F ≡spp ¬F ;(7) ¬(cid:7) ≡spp ⊥ and ¬⊥ ≡spp (cid:7);(8) F ∧ ⊥ ≡spp ⊥ and F ∨ ⊥ ≡spp F ;(9) F ∧ (cid:7) ≡spp F and F ∨ (cid:7) ≡spp (cid:7);(10) F ◦ F ≡spp F , for ◦ = ∧ and ∨.Proof. (1) If (cid:13) X, Y (cid:14) |(cid:8)spp F → G then Y (cid:12)|(cid:8) F or (cid:13) X, Y (cid:14) |(cid:8)spp G. We recall that (cid:13) X, Y (cid:14) |(cid:8)spp ¬F if and only if Y (cid:12)|(cid:8) F (The-orem 11(2)). Thus, (cid:13) X, Y (cid:14) |(cid:8)spp ¬F or (cid:13) X, Y (cid:14) |(cid:8)spp G and so, (cid:13) X, Y (cid:14) |(cid:8)spp ¬F ∨ G. Conversely, if (cid:13) X, Y (cid:14) |(cid:8)spp ¬F ∨ G thenY |(cid:8) ¬F ∨ G (Theorem 11(1)) and, consequently, Y |(cid:8) F → G. Moreover, (cid:13) X, Y (cid:14) |(cid:8)spp ¬F or (cid:13) X, Y (cid:14) |(cid:8)spp G. Thus, Y (cid:12)|(cid:8) F or(cid:13) X, Y (cid:14) |(cid:8)spp G (again by Theorem 11(2)), and the claim follows.The properties (2) and (3) follow by Theorem 11(2) and the corresponding properties of equivalence in propositionallogic. For instance, (cid:13) X, Y (cid:14) |(cid:8)spp ¬(F ∨ G) if and only if Y (cid:12)|(cid:8) F ∨ G (Theorem 11(2)). The latter condition is equivalent toY (cid:12)|(cid:8) F and Y (cid:12)|(cid:8) G. This conjunction, in turn, is equivalent to (cid:13) X, Y (cid:14) |(cid:8)spp ¬F and (cid:13) X, Y (cid:14) |(cid:8)spp ¬G (Theorem 11(2), again).Thus, (cid:13) X, Y (cid:14) |(cid:8)spp ¬(F ∨ G) if and only if (cid:13) X, Y (cid:14) |(cid:8)spp ¬F ∧ ¬G, which implies (2).The properties (4) and (5) follow from the inductive definition of |(cid:8)spp for the connectives ∧ and ∨. For instance,(cid:13) X, Y (cid:14) |(cid:8)spp F ∧ (G ∨ H) if and only if (cid:13) X, Y (cid:14) |(cid:8)spp F and (cid:13) X, Y (cid:14) |(cid:8)spp G ∨ H . The latter condition can be equivalently re-stated as (cid:13) X, Y (cid:14) |(cid:8)spp F , and (cid:13) X, Y (cid:14) |(cid:8)spp G or (cid:13) X, Y (cid:14) |(cid:8)spp H , or as (cid:13) X, Y (cid:14) |(cid:8)spp F and (cid:13) X, Y (cid:14) |(cid:8)spp G, or (cid:13) X, Y (cid:14) |(cid:8)spp F and(cid:13) X, Y (cid:14) |(cid:8)spp H . Using the inductive definition of |(cid:8)spp for the connectives ∧ and ∨, we get that (cid:13) X, Y (cid:14) |(cid:8)spp F ∧ (G ∨ H) ifand only if (cid:13) X, Y (cid:14) |(cid:8)spp (F ∧ G) ∨ (F ∧ H), thus proving (4).The property (6) follows from Theorem 11(2), and the property (7) from the definitions of the shorthands (cid:7) and ¬, andfrom the definition of |(cid:8)spp. The remaining three properties follow from the inductive definition of |(cid:8)spp for the connectives∧ and ∨ and the facts that ⊥ has no SPP-models and (cid:7) is satisfied by every SPP-model. (cid:2)The normal form result is now a consequence of Proposition 11 and Theorem 13.Theorem 15. Let F be a theory. Then there is a program G consisting of normal rules such that F and G have the same essentialSPP-models (and so, are strongly SPP-equivalent and have the same supported models).Proof. It is enough to prove that for every formula F there is a program consisting of normal rules that has the same essen-tial SPP-models as F . Let us consider the following transformation of F . First, we replace in F every subformula G → H with¬G ∨ H (Proposition 11(1)). Then, we proceed as in the case of propositional logic when constructing a CNF representationof the formula, using De Morgan Laws (Proposition 11(2) and (3)) to move negation in, then using the “triple negation” law(Proposition 11(4)), distributivity properties (Proposition 11(5) and (6)), and simplification rules (Proposition 11(7)–(10)).When that process ends, we split the resulting conjunction into the set of its conjuncts — disjunctions that are of theformC1 ∨ · · · ∨ Ck ∨ ¬ A1 ∨ · · · ∨ ¬ Am ∨ ¬¬B1 ∨ · · · ∨ ¬¬Bn,(3)where Ai , B i , and Ci are atoms. By Proposition 11, the set of these formulas has the same SPP-models as the originalformula F . Thus, it is strongly SPP-equivalent to F .Next, we note that if k (cid:2) 2, then formulasC1 ∨ · · · ∨ Ck ∨ Gandk(cid:9)(Ci ∨ ¬¬C1 ∨ · · · ∨ ¬¬Ci−1 ∨ ¬¬Ci+1 ∨ · · · ∨ ¬¬Ck ∨ G),i=1where Ci are atoms and G is a formula, have the same essential models and, consequently, they are strongly SPP-equivalent.Thus, each disjunction (3) can be rewritten into a strongly SPP-equivalent set of disjunctions:Ci ∨ ¬¬C1 ∨ · · · ∨ ¬¬Ci−1 ∨ ¬¬Ci+1 ∨ · · · ∨ ¬¬Ck ∨ ¬ A1 ∨ · · · ∨ ¬ Am ∨ ¬¬B1 ∨ · · · ∨ ¬¬Bn,where 1 (cid:3) i (cid:3) k.1302M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306By Proposition 11(3) and (1), each such disjunction can be written as an SPP-equivalent normal ruleA1 ∧ · · · ∧ Am ∧ ¬B1 ∧ · · · ∧ ¬Bn ∧ ¬C1 ∧ · · · ∧ ¬Ci−1 ∧ ¬Ci+1 ∧ · · · ∧ ¬Ck → Ci,1 (cid:3) i (cid:3) k. Thus, the assertion follows. (cid:2)5.6. RelationshipsFinally, we will study the relationship between the semantics given by relations |(cid:8)ht and |(cid:8)flp, on the one hand, and|(cid:8)spp, on the other. To this end, we observe first that SPP-models are HT-models and FLP-models.Proposition 12. For every formula F and every X ⊆ Y ⊆ At:(1) (cid:13) X, Y (cid:14) |(cid:8)spp F implies (cid:13) X, Y (cid:14) |(cid:8)ht F ;(2) (cid:13) X, Y (cid:14) |(cid:8)spp F implies (cid:13) X, Y (cid:14) |(cid:8)flp F .Proof. We proceed by induction. Both for (1) and (2), the base case and the inductive step for F = G ◦ H , where ◦ = ∨and ∧, follow from the observation that the corresponding conditions defining the relations |(cid:8)spp, |(cid:8)ht and |(cid:8)flp are thesame.Let us consider F = G → H . Let us assume that (cid:13) X, Y (cid:14) |(cid:8)spp F . It follows thatY |(cid:8) G → H;and Y (cid:12)|(cid:8) G or(cid:13)X, Y (cid:14) |(cid:8)spp H.(4)We know that Y (cid:12)|(cid:8) G implies (cid:13) X, Y (cid:14) (cid:12)|(cid:8)ht G [21]. Combining that with the induction hypothesis, we obtain from (4) thatY |(cid:8) G → H ; and (cid:13) X, Y (cid:14) (cid:12)|(cid:8)ht G or (cid:13) X, Y (cid:14) |(cid:8)ht H . Thus, (cid:13) X, Y (cid:14) |(cid:8)ht G → H follows.It also follows from (4) that Y |(cid:8) G → H ; and Y (cid:12)|(cid:8) G or (cid:13) X, Y (cid:14) |(cid:8)spp H or X (cid:12)|(cid:8) G (we have added one more disjunct to thesecond conjunct). By the induction hypothesis, that new disjunction implies Y (cid:12)|(cid:8) G or (cid:13) X, Y (cid:14) |(cid:8)flp H or X (cid:12)|(cid:8) G. Consequently,(cid:13) X, Y (cid:14) |(cid:8)flp G → H follows. (cid:2)As a corollary, we now obtain that, as in the case of disjunctive logic programming, stable models (both under thestandard and FLP generalizations) are supported models.Theorem 16. For every theory F and every set of atoms Y , if Y is a stable model of F or Y is an FLP-stable model of F , then Y is asupported model of F .Proof. The proof is the same in both cases. Thus, we show the argument in the first case only. Let Y be a stable modelof F . It follows that (cid:13)Y , Y (cid:14) |(cid:8)ht F . Consequently, Y |(cid:8) F (cf. Theorem 1) and so, (cid:13)Y , Y (cid:14) |(cid:8)spp F (by Theorem 11). Let usassume that X ⊆ Y and (cid:13) X, Y (cid:14) |(cid:8)spp F . Then (cid:13) X, Y (cid:14) |(cid:8)ht F (Proposition 12). Since Y is a stable model of F , X = Y . Thus, Yis a supported model of F . (cid:2)In general, the implications in Proposition 12 cannot be reversed. However, in the case of the relation |(cid:8)ht, we can finda broad class of formulas for which the converse implication holds, too. The key is the following result that exhibits a classof formulas, for which the relation |(cid:8)ht reduces to the standard propositional entailment. Before we state it, we recall thatan occurrence of an atom A in a formula is directly under the scope of ¬, if it is the antecedent in the subformula A → ⊥.Proposition 13. Let F be a formula such that every occurrence of an atom in F is directly under the scope of ¬. Then, for everyX ⊆ Y ⊆ At, (cid:13) X, Y (cid:14) |(cid:8)ht F if and only if Y |(cid:8) F .Proof. The claim is evident if F = ⊥. Otherwise, F is of the form F = G ◦ H , where ◦ = ∨, ∧ or →. First, let us assume that◦ =→, G is an atom and H = ⊥. Then, the claim follows from Theorem 1(2). Otherwise, the induction hypothesis applies toG and H (every occurrence of an atom in G and H is directly under the scope of ¬) and again, the inductive step is easyto verify. (cid:2)This result has several consequences. First, we show that we can express the relation |(cid:8)spp in terms of the relation |(cid:8)ht.Moreover, it does not require any extension of the language. Given a formula F , we define F to be the formula obtained byreplacing every nonhead occurrence of an atom A that is not directly negated with ¬¬ A.Proposition 14. For every formula F and every X ⊆ Y ⊆ At, (cid:13) X, Y (cid:14) |(cid:8)spp F if and only if (cid:13) X, Y (cid:14) |(cid:8)ht F .M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061303Proof. The claim is evident if F = ⊥. If F = A, where A ∈ At, then F = A = F and the result holds.(cid:15) → H , where GSince G ◦ H = G ◦ H , for ◦ = ∧ and ∨, for these two connectives, the induction step is easy to verify. Thus, let F = G → H .is obtained from G by replacing every occurrence of an atom A that is not directly negated. By the definitions of Gand of theif and only if Y |(cid:8) G. Finally, by theClearly, F = Gwith ¬¬ A. Proposition 13 applies to G(cid:15)classical entailment relation |(cid:8), Y |(cid:8) Ginduction hypothesis, (cid:13) X, Y (cid:14) |(cid:8)ht H if and only if (cid:13) X, Y (cid:14) |(cid:8)spp H . Consequently, the following statements are equivalent:(cid:15)if and only if Y |(cid:8) G. Thus, (cid:13) X, Y (cid:14) |(cid:8)ht G(cid:15)if and only if Y |(cid:8) G. Thus, (cid:13) X, Y (cid:14) |(cid:8)ht G(cid:15)(cid:15)(cid:15)(cid:15)(1) (cid:13) X, Y (cid:14) |(cid:8)spp G → H ;(2) Y |(cid:8) G → H ; and Y (cid:12)|(cid:8) G or (cid:13) X, Y (cid:14) |(cid:8)spp H ;(cid:15) → H ; and (cid:13) X, Y (cid:14) (cid:12)|(cid:8)ht G(3) Y |(cid:8) G(4) (cid:13) X, Y (cid:14) |(cid:8)ht G(5) (cid:13) X, Y (cid:14) |(cid:8)ht F .(cid:15) → H ;(cid:15)or (cid:13) X, Y (cid:14) |(cid:8)ht H ;Thus, the claim for F = G → H follows. (cid:2)Corollary 8. For every formula F and every interpretation Y , Y is a supported model of F if and only if it is a stable model of F .Next, we observe that it is impossible to express |(cid:8)ht in terms of |(cid:8)spp. The following corollary makes the meaning ofthat statement precise.Corollary 9. Let A and B be atoms. There is no formula F such that (cid:13) X, Y (cid:14) |(cid:8)ht A → B ∨ ¬B ∨ ¬ A if and only if (cid:13) X, Y (cid:14) |(cid:8)spp F .Proof. Let H = A → B ∨ ¬B ∨ ¬ A. It is easy to verify that (cid:13)∅, { A, B}(cid:14) |(cid:8)ht H and (cid:13){ A}, { A, B}(cid:14) (cid:12)|(cid:8)ht H . Let us assume that thereis a formula F such that for every X ⊆ Y , (cid:13) X, Y (cid:14) |(cid:8)ht H if and only if (cid:13) X, Y (cid:14) |(cid:8)spp F . Then, (cid:13)∅, { A, B}(cid:14) |(cid:8)ht F . By Theorem 12,or, equivalently, (cid:13){ A}, { A, B}(cid:14) |(cid:8)ht F , a contradiction. (cid:2)∅ |(cid:8) F. By Proposition 10, F Y is monotone. Thus, { A} |(cid:8) F{ A,B}{ A,B}such that Y is a supported model of F if and only if Y is an FLP-stable model of F (cid:15)Given our result on the biexpressibility of stable and FLP-stable semantics, it follows that for every theory F there is atheory F (cid:15). In other words, we canexpress supported models in terms of FLP-stable models without the need to expand the language. On the other hand, thereis a theory F such that for no theory F (cid:15). Thus, FLP-stablemodels cannot be (in general) expressed as supported models, unless we extend the language., FLP-stable models of F are exactly supported models for F (cid:15)As a corollary to Proposition 14 we obtain the promised result showing a class of formulas, which have the same HT-and SPP-models.Proposition 15. Let F be a formula such that every occurrence of an atom in F is either a head occurrence or falls directly under thescope of ¬. For every X ⊆ Y ⊆ At, (cid:13) X, Y (cid:14) |(cid:8)ht F if and only if (cid:13) X, Y (cid:14) |(cid:8)spp F .Proof. Since under the assumptions about F , we have F = F , the claim follows from Proposition 14. (cid:2)In turn, this result implies the following generalization of the property that stable and supported models of purelynegative disjunctive programs coincide.Corollary 10. Let F be a theory such that every occurrence of an atom in F is either a head occurrence or falls directly under the scopeof ¬. Then Y is a stable model of F if and only if it is a supported model of F .There is an alternative argument that shows that the |(cid:8)spp relation can be expressed by means of the |(cid:8)ht and |(cid:8)flprelations.3 It is based on the following simple observation that identifies a class of formulas on which all three semanticscoincide.Proposition 16. Let F be a formula in which every occurrence of → has ⊥ in the consequent (in other words, formulas that can bewritten by means of the connectives ∧, ∨ and ¬). For every HT-interpretation (cid:13) X, Y (cid:14), the following conditions are equivalent:(1) (cid:13) X, Y (cid:14) |(cid:8)ht F ;(2) (cid:13) X, Y (cid:14) |(cid:8)flp F ;(3) (cid:13) X, Y (cid:14) |(cid:8)spp F .3 This argument is due to one of the anonymous reviewers.1304M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306Proof. The clauses defining each of the relations in the case when F = ⊥, F = A, where A is an atom, F = G ∧ H andF = G ∨ H are the same. Moreover, for each of the three satisfiability relations, (cid:13) X, Y (cid:14) satisfies (in the corresponding sense)¬G if and only if Y (cid:12)|(cid:8) G (and so, for such formulas, the three satisfiability relations also coincide). Thus, the result followsby induction. (cid:2)For every formula F , we denote by F the formula obtained from F by replacing each subformula G → H , where H (cid:12)= ⊥,with (G → ⊥) ∨ H (or ¬G ∨ H , for short).Corollary 11. For every formula F , SPP-models of F coincide with HT-models of F , with FLP-models of F and with SPP-models of F .Proof. By Proposition 11(1), F and F have the same SPP-models. Thus, the assertion follows from Proposition 16. (cid:2)The value of our first approach to show that the SPP semantics can be expressed in terms of HT and FLP semantics,which uses F (cid:23)→ F transformation, is in that it gives Corollary 10, a generalization of the property that in purely negativedisjunctive programs stable and supported models coincide. On the other hand, the value of the approach based on theF (cid:23)→ F transformation lies in the fact that it shows a class of formulas (theories), on which all three semantics coincide.6. Discussion and conclusionsIn this paper, we developed generalizations of the FLP semantics and the supported-model semantics to the full languageof propositional logics using appropriate variants of methods developed earlier by Pearce and Ferraris for the stable-modelsemantics. In this way, all three semantics are cast in the same uniform framework, which facilitates comparisons and offersinsights into their properties. Our results contribute to the theoretical foundations of answer-set programming, a majorknowledge representation formalism.More specifically, Ferraris [19] showed that the stable-model semantics can be extended to the language of propositionallogic by means of an appropriate generalization of the notion of the F-reduct. We showed that the approach by Ferrariscan be adapted to two other semantics of programs: the FLP and supported-model semantics. Moreover, the generalizationsrequire only small changes in the definition of the reduct that concern how the implication is handled in the case bothits antecedent and consequent are satisfied by the context. In the case of the FLP-reduct, we keep the antecedent of theimplication unchanged, in the case of the SPP-reduct, we drop it.Not only the definitions follow the same pattern. The theories of the three semantics are quite similar, too, both inthe way the results are stated as well as proved. In particular, in each case, we have a corresponding characterization ofthe semantics in terms of a satisfiability relation between HT-interpretations and formulas similar to the characterizationof the stable-model semantics of arbitrary propositional theory by Pearce [44]. As before, what differentiates between therelations is the way the implication is handled.The uniformity with which the three semantics can be defined and studied is striking. It suggests that considering thereduct-based approach in the general language of logic, may reveal new insights into the phenomenon of nonmonotonicity.A related question is whether any other semantics can be defined in this way, that is, whether there are any other notionsof reduct that might lead to useful formalisms. As there seem to be no simple ways to modify the reduct left, the uniformapproach presented here suggests that the realm of nonmonotonic semantics of programs and theories may essentially boildown to the three ones discussed in the paper.The uniformity notwithstanding, there are also differences. We saw that the relation |(cid:8)spp is, in some sense, weaker thanthe other two. Further, the relation |(cid:8)ht that captures the stable-models semantics defines a logic, namely the logic HT.To the contrary, the relation |(cid:8)flp does not: the set of formulas F such that for every (cid:13) X, Y (cid:14), (cid:13) X, Y (cid:14) |(cid:8)flp F while closedunder modus ponens, is not closed under substitution.4 Also, while stable and FLP semantics are closely related, supported-model semantics is essentially different (cf. the characterization of strong SPP-equivalence, and the normal form theorem).A detailed comparison of the semantics is beyond the scope of this paper. We leave it for future work.We note here that our argument for the normal form result with respect to SPP-models can be adjusted to show thatthe set of theorems with respect to |(cid:8)spp is closed under substitution and so, is a logic. The question of axiomatization ofthat logic is for now open.AcknowledgementsThe present text reflects many corrections and suggestions offered by the anonymous reviewers. The author gratefullyacknowledges their effort. The work was partially supported by the NSF grant IIS-0913459.4 Indeed, for every HT-interpretation we have (cid:13) X, Y (cid:14), (cid:13) X, Y (cid:14) |(cid:8)flp p → p, yet (cid:13){p}, {p, q}(cid:14) (cid:12)|(cid:8)flp (p → q) → (p → q). This behavior of the FLP semantics is adrawback. In particular, it is responsible for the difficulty of using explicit definitions under the FLP semantics, which we discussed at the end of Section 3.M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–13061305References[1] K. Apt, Logic programming, in: J. van Leeuven (Ed.), Handbook of Theoretical Computer Science, Elsevier, Amsterdam, 1990, pp. 493–574.[2] M. Balduccini, M. Gelfond, M. Nogueira, Answer set based design of knowledge systems, Annals of Mathematics and Artificial Intelligence 47 (1–2)(2006) 183–219.[3] C. Baral, From knowledge to intelligence – building blocks and applications, invited talk, AAAI 2005 (2005), http://www.public.asu.edu/~cbaral/aaai05-invited-talk.ppt.[4] C. Baral, K. Chancellor, N. Tran, N.L. Tran, A. Joy, M. Berens, A knowledge based approach for representing and reasoning about signaling networks,in: Proceedings of the 12th International Conference on Intelligent Systems for Molecular Biology/3rd European Conference on Computational Biology(Supplement of Bioinformatics), 2004, pp. 15–22.[5] G. Boenn, M. Brain, M.D. Vos, J. Fitch, Anton: Composing logic and logic composing, in: E. Erdem, F. Lin, T. Schaub (Eds.), Proceedings of the 10thInternational Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR 2009, in: Lecture Notes in Computer Science, vol. 5753, Springer,2009, pp. 542–547.[6] S. Brass, J. Dix, Characterizations of the disjunctive stable semantics by partial evaluation, Journal of Logic Programming 32 (3) (1997) 207–228.[7] D. Brooks, E. Erdem, J. Minett, D. Ringe, Character-based cladistics and answer set programming, in: M. Hermenegildo, D. Cabeza (Eds.), Proceedings ofthe 7th International Symposium on Practical Aspects of Declarative Languages, PADL 2005, in: Lecture Notes in Computer Science, vol. 3350, Springer,2005, pp. 37–51.[8] P. Cabalar, P. Ferraris, Propositional theories are strongly equivalent to logic programs, Theory and Practice of Logic Programming 7 (6) (2007) 745–759.[9] K. Clark, Negation as failure, in: H. Gallaire, J. Minker (Eds.), Logic and Data Bases, Plenum Press, New York–London, 1978, pp. 293–322.[10] M. Denecker, J. Vennekens, S. Bond, M. Gebser, M. Truszczy ´nski, The second answer set programming competition, in: E. Erdem, F. Lin, T. Schaub (Eds.),Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR 2009, in: Lecture Notes in ComputerScience, vol. 5753, Springer, 2009, pp. 637–654.[11] T. Eiter, G. Brewka, M. Dao-Tran, M. Fink, G. Ianni, T. Krennwallner, Combining nonmonotonic knowledge bases with external sources, in: S. Ghilardi,R. Sebastiani (Eds.), Proceedings of the 7th International Symposium on Frontiers of Combining Systems, FroCoS 2009, in: Lecture Notes in ComputerScience, vol. 5749, Springer, 2009, pp. 18–42.[12] T. Eiter, W. Faber, N. Leone, G. Pfeifer, A. Polleres, Answer set planning under action costs, Journal of Artificial Intelligence Research (JAIR) 19 (2003)25–71.[13] T. Eiter, W. Faber, N. Leone, G. Pfeifer, A. Polleres, A logic programming approach to knowledge-state planning, II: The dlvk system, Artificial Intelli-gence 144 (1–2) (2003) 157–211.[14] T. Eiter, M. Fink, S. Woltran, Semantical characterizations and complexity of equivalences in answer set programming, ACM Transactions on Computa-tional Logic 8 (3) (July 2007) 53.[15] T. Eiter, G. Gottlob, On the computational cost of disjunctive logic programming: Propositional case, Annals of Mathematics and Artificial Intelli-gence 15 (3–4) (1995) 289–323.[16] W. Faber, N. Leone, G. Pfeifer, Recursive aggregates in disjunctive logic programs: semantics and complexity, in: Proceedings of the 9th EuropeanConference on Artificial Intelligence, JELIA 2004, in: Lecture Notes in Artificial Intelligence, vol. 3229, Springer, 2004, pp. 200–212.[17] W. Faber, G. Pfeifer, N. Leone, T. Dell’Armi, G. Ielpa, Design and implementation of aggregate functions in the dlv system, Theory and Practice of LogicProgramming 8 (5–6) (2008) 545–580.[18] F. Fages, Consistency of Clark’s completion and existence of stable models, Journal of Methods of Logic in Computer Science 1 (1994) 51–60.[19] P. Ferraris, Answer sets for propositional theories, in: Logic Programming and Nonmonotonic Reasoning, 8th International Conference, LPNMR 2005, in:Lecture Notes in Artificial Intelligence, vol. 3662, Springer, 2005, pp. 119–131.[20] P. Ferraris, V. Lifschitz, Weight constraints and nested expressions, Theory and Practice of Logic Programming 5 (2004) 45–74.[21] P. Ferraris, V. Lifschitz, Mathematical foundations of answer set programming, in: S. Artëmov, H. Barringer, A. d’Avila Garcez, L.C. Lamb, J. Woods (Eds.),We Will Show Them! Essays in Honour of Dov Gabbay, College Publications, 2005, pp. 615–664.[22] M. Gelfond, N. Leone, Logic programming and knowledge representation – the A-prolog perspective, Artificial Intelligence 138 (2002) 3–38.[23] M. Gelfond, V. Lifschitz, The stable semantics for logic programs, in: Proceedings of the 5th International Conference on Logic Programming, ICLP 1988,MIT Press, 1988, pp. 1070–1080.[24] M. Gelfond, V. Lifschitz, Classical negation in logic programs and disjunctive databases, New Generation Computing 9 (1991) 365–385.[25] E. Giunchiglia, J. Lee, V. Lifschitz, N. McCain, H. Turner, Nonmonotonic causal theories, Artificial Intelligence 153 (1–2) (2004) 49–104.[26] A. Heyting, Die formalen Regeln der intuitionistischen Logik, Sitzungsberichte der Preussischen Akademie von Wissenschaften, Physikalisch-mathematische Klasse, 1930, pp. 42–56.[27] K. Inoue, C. Sakama, Negation as failure in the head, Journal of Logic Programming 35 (1998) 39–78.[28] J. Lee, V. Lifschitz, R. Palla, A reductive semantics for counting and choice in answer set programming, in: Proceedings of the 23rd AAAI Conference onArtificial Intelligence, AAAI 2008, AAAI Press, 2008, pp. 472–479.[29] J. Lee, Y. Meng, On reductive semantics of aggregates in answer set programming, in: Proceedings of the 10th International Conference on LogicProgramming and Nonmonotonic Reasoning, LPNMR 2009, in: Lecture Notes in Computer Science, vol. 5753, Springer, 2009, pp. 182–195.[30] Y. Lierler, Abstract answer set solvers, in: M.G. de la Banda, E. Pontelli (Eds.), Proceedings of the 24th International Conference on Logic Programming,ICLP 2008, in: Lecture Notes in Computer Science, vol. 5366, Springer, 2008, pp. 377–391.[31] Y. Lierler, M. Maratea, Cmodels-2: SAT-based answer set solver enhanced to non-tight programs, in: Proceedings of LPNMR-04, in: Lecture Notes inComputer Science, vol. 2923, Springer, 2004, pp. 346–350.[32] V. Lifschitz, D. Pearce, A. Valverde, Strongly equivalent logic programs, ACM Transactions on Computational Logic 2 (4) (2001) 526–541.[33] V. Lifschitz, L.R. Tang, H. Turner, Nested expressions in logic programs, Annals of Mathematics and Artificial Intelligence (1999) 369–389.[34] V. Lifschitz, T. Woo, Answer sets in general nonmonotonic reasoning, in: Proceedings of the 3rd International Conference on Principles of KnowledgeRepresentation and Reasoning, KR ’92, Morgan Kaufmann, San Mateo, CA, 1992, pp. 603–614.[35] F. Lin, Reducing strong equivalence of logic programs to entailment in classical propositional logic, in: Proceedings of the 8th International Conferenceon Principles of Knowledge Representation and Reasoning, KR 2002, Morgan Kaufmann, 2002, pp. 170–176.[36] F. Lin, Y. Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, in: Proceedings of the 18th National Conference on Artificial Intelli-gence, AAAI 2002, AAAI Press, 2002, pp. 112–117.[37] V. Marek, M. Truszczy ´nski, Stable models and an alternative logic programming paradigm, in: K. Apt, W. Marek, M. Truszczy ´nski, D. Warren (Eds.), TheLogic Programming Paradigm: A 25-Year Perspective, Springer, Berlin, 1999, pp. 375–398.[38] W. Marek, V. Subrahmanian, The relationship between stable, supported, default and autoepistemic semantics for general logic programs, TheoreticalComputer Science 103 (2) (1992) 365–386.[39] W. Marek, M. Truszczy ´nski, Autoepistemic logic, Journal of the ACM 38 (3) (1991) 588–619.[40] R. Moore, Semantical considerations on nonmonotonic logic, Artificial Intelligence 25 (1) (1985) 75–94.[41] I. Niemelä, Logic programming with stable model semantics as a constraint programming paradigm, Annals of Mathematics and Artificial Intelli-gence 25 (3–4) (1999) 241–273.1306M. Truszczy´nski / Artificial Intelligence 174 (2010) 1285–1306[42] I. Niemelä, P. Simons, Extending the smodels system with cardinality and weight constraints, in: J. Minker (Ed.), Logic-Based Artificial Intelligence,Kluwer Academic Publishers, 2000, pp. 491–521.[43] M. Nogueira, M. Balduccini, M. Gelfond, R. Watson, M. Barry, An a-prolog decision support system for the space shuttle, in: I.V. Ramakrishnan (Ed.),Proceedings of the 3rd International Symposium on Practical Aspects of Declarative Languages, PADL 2001, in: Lecture Notes in Computer Science,vol. 1990, Springer, 2001, pp. 169–183.[44] D. Pearce, A new logical characterisation of stable models and answer sets, in: J. Dix, L.M. Pereira, T.C. Przymusinski (Eds.), Non-Monotonic Extensionsof Logic Programming, NMELP ’96, in: Lecture Notes in Computer Science, vol. 1216, Springer, 1997, pp. 57–70.[45] D. Pearce, A. Valverde, Quantified equilibrium logic and foundations for answer set programs, in: Proceedings of the 24th International Conference onLogic Programming, ICLP 2008, 2008, pp. 546–560.[46] T. Schaub, S. Thiele, Metabolic network expansion with answer set programming, in: P. Hill, D. Warren (Eds.), Proceedings of the 25th InternationalConference on Logic Programming, ICLP 2009, in: Lecture Notes in Computer Science, vol. 5649, Springer, 2009, pp. 312–326.[47] T. Soininen, I. Niemelä, Developing a declarative rule language for applications in product configuration, in: G. Gupta (Ed.), Proceedings of the 1stInternational Workshop on Practical Aspects of Declarative Languages, PADL 1999, in: Lecture Notes in Computer Science, vol. 1551, Springer, 1998,pp. 305–319.[48] T. Son, E. Pontelli, C. Sakama, Logic programming for multiagent planning with negotiation, in: P. Hill, D. Warren (Eds.), Proceedings of the 25thInternational Conference on Logic Programming, ICLP 2009, in: Lecture Notes in Computer Science, vol. 5649, Springer, 2009, pp. 99–114.[49] M. Truszczy ´nski, S. Woltran, Hyperequivalence of logic programs with respect to supported models, in: Proceedings of the 23rd National Conferenceon Artificial Intelligence, AAAI 2008, AAAI Press, 2008, pp. 560–565.[50] P. Tu, T. Son, C. Baral, Reasoning and planning with sensing actions, incomplete information, and static causal laws using answer set programming,Theory and Practice of Logic Programming 7 (4) (2007) 377–450.[51] H. Turner, Strong equivalence made easy: Nested expressions and weight constraints, Theory and Practice of Logic Programming 3 (2003) 609–622.[52] S. Woltran, A common view on strong, uniform, and other notions of equivalence in answer-set programming, Theory and Practice of Logic Program-ing 8 (2) (2008) 217–234.