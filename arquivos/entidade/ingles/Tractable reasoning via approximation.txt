ELSEVIER Artificial Intelligence 74 ( 1995) 249-310 Artificial Intelligence Tractable reasoning via approximation * Marco Schaerf a,b,l, Marco Cadoli b** a lstituto di Elettrotecnica, Universitd di Cagliari, Piazza d’Armi, 90123 Cagliari, Italy b Dipartimento di Informatica e Sistemistica, Universitci di Roma “LA Sapienza”, via Salaria 113, 00198 Roma, Italy Received May 1993; revised November 1993 Abstract Problems in logic are well known to be hard to solve in the worst case. ‘l%o different strate- gies for dealing with this aspect are known from the literature: language restriction and theory approximation. In this paper we are concerned with the second strategy. Our main goal is to define a semanti- cally well-founded logic for approximate reasoning, which is justifiable from the intuitive point of view, and to provide fast algorithms for dealing with it even when using expressive languages. We also want our logic to be useful to perform approximate reasoning in different contexts. We define a method for the approximation of decision reasoning problems based on multivalued logics. Our work expands and generalizes, in several directions, ideas presented by other researchers. The major features of our technique are: ( 1) approximate answers give semantically clear information about the problem at hand; (2) approximate answers are easier to compute than answers to the original problem; (3) approximate answers can be improved, and eventually they converge to the right answer; (4) both sound approximations and complete ones are described. The method we propose is flexible enough to be applied to a wide range of reasoning problems. In our research we considered approximation of several decidable problems with different worst- case complexity, involving both propositional and first-order languages. In particular we defined approximation techniques for: propositional logic, fragments of first-order logic (concept descrip- *Work supp0rte.d by the ESPRIT Basic Research Action 6810-COMPLLOG II and by the Progetto Finalizzato Sistemi Informatici e Calcolo Parallel0 of the CNR (Italian Research Council). Parts of this paper appeared in prGninaxy form in papers presented at the Fourth Conference on Theoretical Aspects of Reasoning about Knowledge (TARK-92), the Third International Conference on the Principles of Knowledge Representation and Reasoning (KR-92) and the Second Italian Conference on AI ( AI*IA-91) . * Corresponding author. E-mail: cadoli@assi.dis.uniromal .it. 1 E-mail: schaerf@assi.dis.uniromal.it. 0004-3702/95/.@9.50 @ 1995 Elsevier Science B.V. All rights reserved SSDIOOO4-3702(94)00009-P 250 M. Schaerf. M. Cudoli/Artifciul Intelligence 74 (1995) 249-310 tion languages) and modal logic. In our research we also addressed the issue of representing the knowledge of a reasoner with limited resources and how to use such a knowledge for approximate reasoning purposes. 1. Introduction The benefits of formalizing AI problems in logic are manifold [ 45,601. Nevertheless to perform have high computational to be hard to solve in the worst case: the prototypical NP-complete problem we have to pay a price for that: one of the major drawbacks of logic as an AI tool is in the tasks that we are that if we formalize AI problems as logical problems in logic are well supposed is to known check whether a formula of propositional r.e.-complete [ 641. We notice which update.) [ 171, while the prototypical logic is inconsistent task, is a basic (e.g. knowledge the AI perspective-consistency formalisms is to check whether a formula of first-order is subsumed by many complexity. Problems logic is consistent in knowledge then typically representation that-from checking problem The computational drawback caused by logical formalization of problems of AI: Vardi in [73] shows how an increase of databases as logical objects versus in complexity their characterization characterizes is not a the as physical peculiarity formalization objects. In fact the use of “fancy” drawback the computational AI typically have higher computational order-logic. NP-complete, while consistency which complete As an example, consistency checking used for representing is commonly [ 521. forms of logic as tools for knowledge even more sensible. Logical complexity formalisms than classical-propositional representation makes in that are used or first- is logic logic PSPACE- classical logic S4-a [ 431 -is checking in propositional in the propositional modal the knowledge modality Since researchers realized this fundamental drawback, two different strategies emerged in the literature: ( 1) According to the ideas presented in [ 61, we can restrict knowledge so that the formalization representing sible, but resulting or at least decidable. As an example, propositional Horn clauses, which allow linear algorithms tasks are computationally feasible, for satisfiability of interesting the language used for cases is still pos- tractable to i.e. polynomially logic can be restricted testing [ 281. (2) According to [ 551, we could use a form of logic that allows weaker feasible is computationally power but language. As an example, propositional admits polynomial even with a full expressiveness calculus without testing for consistency algorithms [ 36,541. the modus ponens inferential in the rule Both ideas received great attention both from the theoretical and from the application- the whole database oriented community. The limited expressiveness approach. The CLASSIC built at AT&T and currently used in an industrial environment, uses both strategies. CLASSIC adopts a re- stricted avoiding some sources of intractability-but strategy underlies [4,5], allows constructors representation language-thus knowledge system M. Schaee M. Cadoli/Art$cial Intelligence 74 (1995) 249-310 251 that lead to intractable reasoning problems. Such constructors are dealt with incomplete inference algorithms grounded on non-standard semantics. For what concerns the language restriction approach, fundamental studies on the com- plexity of fragments of classical propositional [ 661 and first-order logic [ 291 have been done in the last decades. More recently, computational studies about several logical formalisms relevant for KR appeared. Studies analyzing the so-called tractability thresh- old between polynomially tractable and intractable languages are of particular practical interest. Among the most significant in this group we cite [27] on concept description languages, [ 48,7 11 on default logic, [ 101 on closed-world reasoning and circumscrip- tion, [ 3 1 ] on logic-based abduction, [ 701 on path-based inheritance, [ 81 on set covering abduction. As far as weak forms of reasoning are concerned, it is well known that AI has incompleteness and heuristics. The kind of weak always dealt with approximation, reasoning we are interested in in this work can be described in a nutshell as follows: we have a satisfactory logical formalization of a reasoning problem, but we don’t want to implement it exactly as it is, because it is computationally too expensive; hence we look for a formalization that “looks like” our favorite one, but it is easier to compute. In this work we are mainly interested in decision problems, as reasoning problems usually admit a boolean answer. Informally, an approximate solution to a decision problem is a “maybe” answer, equipped with reasons to believe that the “maybe” is actually a “yes” or to believe that it is actually a “no”. In a form of approximate reasoning called sound reasoning we have two possible answers: “yes” and “maybe no”. In the dual form of approximate reasoning (complete reasoning), the two possible answers are “no” and “maybe yes”. The obvious important questions we are faced with are: how do we measure the accuracy of an approximate answer? How do we know an approximate answer is any better than another one? It is important to recall that in logic we have no explicit metric that gives an immediate answer to the above questions. In this respect, approximation of reasoning problems is more difficult to study than approximation of optimization problems. Approximation schemata for reasoning problems are typically justified by means of cognitive or epistemic arguments (e.g. “this is an approximate but satisfactory description of how people reason”). Logic-based study of approximate reasoning is receiving increasing attention in the Al community. Several formalisms for weak reasoning that are supported by a “reasonable” semantics recently appeared. To this end the most significant approaches to a formal description of partial reasoning are Levesque’s [ 54-561 architecture based on incomplete reasoning, Frisch’s [ 35,361 limited inference systems, Crawford and Kuiper’s [ 191 access-limited logic, Kautz and Selman’s [47,49,69] knowledge compilation and Dean and Boddy’s [23] any-time algorithms, further investigated by Russell and Zilberstein in [ 651 and by Ginsberg in [ 391. In this work we are interested in the “tractability via approximation” approach. Our goal is to define a semantically well-founded logic for approximate reasoning, justifiable from the intuitive point of view, and to provide fast algorithms for dealing with it even when using expressive languages. We also want our logic to be useful to perform approximate reasoning in different contexts. 252 M. Schaerf; M. Cudoli/Art~ciul Intelligence 74 (I995) 249-310 We define a method for the approximation logics. The use of multivalued tractable reasoning of decision logics for representing problems based forms of local, reasoning has already been attempted by other ideas in several directions [ 36,541.) Our work expands and generalizes on multivalued incomplete authors presented by those researchers. and polynomially (cf. In order to introduce the topic of logic-based in the approximation, in this paper we survey literature by other authors: Levesque’s reasoning and Selman and Kautz’s knowledge compilation. The analysis of that have been defined two methods incomplete these methods motivates a list of desiderata The major features of our technique are: l approximate l approximate l approximate answer; answers give semantically answers are easier to compute answers can be improved, for a new theory of approximation. clear information than answers about the problem at hand; to the original problem; and eventually they converge to the right l both sound approximations and complete ones are described. Our method differs from the existing ones in one or more of the above points. The method we propose is flexible enough to be applied In our research we considered problems. with different worst-case guages. In particular we defined approximation logic; complexity, approximation involving both propositional techniques for: to a wide range of reasoning of several decidable problems lan- and first-order fragments of first-order logic (concept description languages) ; the issue of representing and how to use such a knowledge the knowledge of a reasoner reasoning for approximate ( 1) propositional (2) (3) modal logic. In our research we also addressed with purposes. resources limited The structure of the paper is as follows: that have been defined for a theory of approximation and we illustrate it for entailment aspects of such an approximation. language in a modal In Sections 7 and 8 we apply two methods in propositional In Section 2 we survey for in the literature by other authors. Our are given in Section 3. In Section 4 we formal- logic. In Section 5 In Section 6 we ad- the approximate knowledge owned to re- address open problems and sketch appen- logic and propositional modal technique logics, the approximation in appropriate are presented in fragments of first-order tasks In Section 9 we draw some conclusions, the proofs of the theorems reasoning the algorithmic approximate desiderata ize our technique we discuss dress the issue of representing by a limited intractable spectively. future dices. research. All reasoner. 2. Logic-based methods for approximation: existing techniques In this section we illustrate and two logic-based methods we make a brief comparison of them. In order to give the flavor of what is going on in the field, we show a “classic” method (Levesque’s), which has been analyzed and used by several authors, and a new-but (Selman and Kautz’s). already popular-one for approximate reasoning M. SchaerjY M. Cadoli/Art$icial Intelligence 74 (1995) 249-310 253 2.1. Levesque s limited inference The first method has been introduced by Levesque in several works [ 54-561 and it is based on the idea of limited inference. Independently, Frisch [ 35,361 developed similar formalizations. Levesque argues that if we are to model the mental activity of an agent, it is not reasonable to assume that he always answers queries by using a method that needs an exponential amount of time. It is more realistic to assume that, when faced with normal problems, the agent only applies simple inference rules. On the other hand, when the agent is faced with extremely important or tricky questions, he moves to what Levesque calls a “puzzle mode” and uses more complex inference procedures. As a consequence, a knowledge representation and reasoning system should be able to distinguish between what is explicit or evident in what he knows, and what is implicit and can be inferred given enough time and motivation. Since ordinary logic does not make any distinction of this kind, it is necessary to make appropriate formal steps in this direction. Levesque notices that a good deal of reasoning is based on detecting that a sentence and its negation are contradictory. As an example, starting from (p V q) A (14 V r) , we infer that (p V r) because q and lq are contradictory. On the other hand we can think about a shallow reading of sentences, where the contradiction between a sentence and its negation is not observed. In particular, reasoning like in the above example is not possible in the shallow reading. Levesque gives in [56] a formal definition-based the notion of shallow reading of sentences. L denotes a set of propositional letters. A literal is a letter 1 of L or its negation ~1. L* denotes the set of all literals associated with the letters of L. A truth assignment is a function mapping the set of literals L* into the set (091). on multivalued logics-of Definition 2.1 (Levesque [ 561). A 3-interpretation of L* is a truth assignment which does not map both a letter 1 of L and its negation ~1 into 0. According to this definition, for each propositional letter I and each 3-interpretation I there are three possibilities (hence the name 3-interpretation): (1) Z(Z) = 1 and Z(lZ) =O; (2) Z(Z) = 0 and Z(7Z) = 1; (3) Z(Z) = 1 and Z(7Z) = 1. Standard (2-valued) interpretations admit only the first two possibilities (where 1 is, respectively, true or false). The third possibility can be regarded as the logical value contnzdiction. The notion of 3-interpretation is extended to formulae in Conjunctive Normal Form (CNF) in the following way: a 3-interpretation Z satisfies a clause iff it maps one of its literals into 1; Z satisfies a CNF formula iff it satisfies all of its clauses. In Section 4 we show how to define the 3-interpretation of an arbitrary formula. The relation of 3-entailment can be immediately defined in the intuitive way:’ T * Our terminology and symbols are different from those used by Levesque. 254 M. Schuerf M. Cadoli/Arti@ial Intelligence 74 (1995) 249-310 3-entails y (written T k” y) into 1. Levesque notices that 3-entailment has interesting properties: iff every 3-interpretation mapping T into 1 also maps y l soundness: for each T and y, it holds that (T k3 r) l polynomial&y: if both T and y are in CNF, then T k3 y can be tested in 0( JTI .Iyl) (T /= 7) ; implies time. independent motivation Another or T tautologically and Dunn [2,30], proof theory of propositional for k=” is that (T k’ r) holds iff either y is a tautology entails y in the system of Relevance Logic of Anderson and Belnap in terms of the as shown rule (see also in [56]. Moreover k3 can be modeled the modus ponens inference calculus without ]35,361). Example 2.2 (Modus ponens does not hold for 3-entailment). Let L be the set {a, b}, and T be {a, ~a V 6). Clearly both T k=’ a and T k3 la V b hold, hence 3-entailment captures explicit knowledge. On the other hand T b b holds, but T k3 b does not hold: the truth assignment which maps a, ~a and -b into 1 and b into 0 is a 3-interpretation satisfying T. conclusion Levesque’s reasoning that the agent should always do prior to any form of deep logical analysis or problem solving, the kind of quick surface into the “puzzle mode”. is that k=” can model i.e. before entering 2.2. Selman and Kautz’s Horn compilation The second method has been introduced by Selman and Kautz in [47,49,69] and it is based on the idea of knowledge compilation. formulae-is The starting point of the technique 2 stems on the fact that testing 2 k a-where in in general co-NP-complete, while ,E is a Horn formula and (Y is in CNF. The fascinating question to compiEe a propositional is it possible and (Y are propositional polynomial time when addressed by Selman and Kautz is the following: formula 2 into a Horn one 2’ so that a significant performed under 2 can be performed under 2’ in polynomial amount of the inferences time? it is doable that are Selman and Kautz notice that there exist two different ways of doing such a compila- .Z’ k 2, or equivalently formula satisfies the relation tion. In the first case the compiled M ( 2’) C M ( 2) -where M (@) denotes reason 2’ is called a Horn lower bound-or LB-of fo~ula(a-c)A(b-c)A(aVb).Thefo~ula~~~=aAbAcisaHornLBof~. the set of models of the formula @. For this 2. As an example, 3 let @ be the is dual. The compiled version of 2 is a Horn formula the relation 2’ + X’, or equivalently M (2) C M (2’). X’ is called the formula to the previous example, 2. Returning The second form of compilation _Z’ that satisfies a Horn upper bound-or UB-of 4&, = (a - Compiled c) A (b ---+ c) is a Horn UB of @. forms of a knowledge base can sometimes be used for providing a quick if we are faced with the problem of answer checking Z?Z b LY, we may benefit from the fact that for any Horn LB &, of 2, & p a to an inference problem. As an example, ’ Taken from I69 I M. SchaerJ M. Cadoli/Artificial Intelligence 74 (1995) 249-310 255 implies .Z p (Y. & is a sound approximation of 2, since &, b a implies B k (Y. is therefore a complete approximation of 2. Dually, a Horn UB &, Selman and Kautz define the notion of Horn greatest lower bound or GLB of a formula 2, which is a Horn formula &glb such that M (&b) c M (2) and for no Horn formula .X’ it holds that M (&lb) C M (2’) E M (2). A Horn GLB is in some sense the “best” complete Horn approximation. Continuing the previous example, <qb2 = a A c is a Horn GLB of @. Dually, a Horn least upper bound or LUB of a formula 2 is a Horn formula &b such and for no Horn formula 2’ it holds that M (2) C_ M ( 2’) c that M (2) c M (&b) M (&b). @&,2 = c is a Horn LUB of @. Selman and Kautz’s proposal is to approximate inference under a propositional for- mula _Z by using its Horn GLBs and LUBs. In this way inference could be unsound or incomplete, but it is anyway possible to spend more time and use a general infer- ence procedure to determine the answer directly from the original theory. The general inference procedure could still use the approximations to prune its search space. We now summarize the major properties of Horn GLBs and LUBs stated in [47,49, 691: l size of the formula with respect to the size 1x1 of 2 - GLB: linear; - LUB: in general exponential; l number of possible approximations of this kind: - GLB: one; - LUB: many; l computational complexity of the search problem of finding the approximation: - GLB: PIP-hard; - LUB: NP-hard. Other authors [ 9,411 have further explored the Horn compilation method, analyzing several computational properties. Relations between Horn compilation and nonmonotonic reasoning are shown in [ 91. 2.3. Comparison between the two approaches Levesque’s approach is characterized by philosophical motivations and aims at build- ing inference systems justifiable from the intuitive point of view. Semantics is important for Levesque, as well as a comparison to techniques for the formalization of limited reasoning developed in different fields (e.g. Relevance Logic [ 21). Selman and Kautz’s method is motivated with strictly computational arguments, and semantics of approxi- mate answers is given in terms of the syntactic notion of Horn clause. Knowledge compilation supports sound inferences as well as complete ones. Leves- que’s method is only sound. Levesque’s inference is done in polynomial time. Both kinds of Horn compilation are polynomially intractable and the Horn LUB needs exponential space. While knowledge compilation can be done off-line, Levesque’s incomplete inference has to be performed on-line. Compiled knowledge bases can be used for answering many queries. 256 M. Schuer$ M. Cudoli/Artijiciul Intelligence 74 (1995) 249-310 Both methods are characterized by being “one-shot”: the sole thing to do is to resort on general-purpose the quality of approximate if we know that the approximate theorem- is not improvable. solutions solution may be wrong, proving procedures. Levesque’s In a nutshell: idea has been generalized to the solution of other reasoning problems, like epistemic reasoning [ 53,541 and reasoning in terminological languages [ 611. 3. Guidelines of a new method for approximation Here is our desiderata list for a theory of approximate reasoning. We would like a method that is: l semantically well-founded: approximate answers should give semantically clear in- formation about l computationally the problem at hand; attractive: approximate answers should be easier to compute than answers l improvable: to the original problem; to the right answer (provided we have enough approximate answers can be improved, they converge and eventually time and motivation); l dual: both sound approximations l flexible: the approximation wide range of reasoning problems. and complete ones should be described; schema should be general enough to be applied to a in Levesque’s We found the above desiderata. Loosely improvability, from a clear formulation our technique. keeping approach inspiration speaking we added a method for developing that fulfills all to Levesque’s method duality and flavor coming logics. We give now an abstract description of features and its semantical its nice computational in multivalued We model a reasoning task as the problem of deciding whether a string x belongs set V (e.g. the set of satisfiable propositional for approximating the corresponding a reasoning problem, or equivalently on the definition of two sequences of sets (‘&,V)I, . . . , IO,,,) and (VO,V’, that to a formulae) or not. The method we defined set V, relies such . . . , P) v(j c v, c . ‘. g vD,, = ;I, = 2)” g IY- & . g DO. The sequences have the following properties: l The lengths n and m of the sequences are polynomial with respect to the input x of the problem. l The elements of both sequences are defined by means of a semantics closely related to that of V. l Deciding whether the input string x belongs problem; is a polynomial membership in V”) deciding membership is not harder than deciding membership task is performed in V. in Vi and in Vi gets exponentially to V” or not (or loosely, deciding the same holds for ‘DO. In general harder as i grows, but it The reasoning sets Vi and Vj of both sequences If we prove membership in an incremental for increasing indexes fashion, by deciding membership in i and j, starting with i = j = 0. in V; on in any Vi, then we have also proved membership M. SchaerJ M. Cadoli/Arti$cial Intelligence 74 (1995) 249-310 257 the other hand if we disprove membership in any Vj, then we have also disproved membership in D. There are clearly two possibilities when we use this method: either we are able to solve the reasoning problem in a reasonable amount of time (in general for small indices i and j), or i and j get too large and we run out of computing resources. Since the reasoning problems taken into account are polynomially intractable, the latter case will be frequent, therefore it has to be analyzed very carefully. The whole purpose of our research on approximation is the study of how to give a meaningful answer in the latter case. We believe that such a meaningful answer has to be grounded on a simple semantics and justified by intuitive arguments. In this way we want to obtain a comprehensible reasoning system whose precision is arbitrary, but depends on the computational effort that has been spent. The system is realized by means of a stepwise procedure that can be interrupted at any step in such a way that the information obtained so far gives interesting semantic insights. Patel-Schneider In all applications of the above approximation schema presented throughout the paper, the lengths n and m of the sequences are linear with respect to the input of the problem. [ 61,621 and Frisch [ 361 pointed out that Levesque’s system suc- cessfully managed to lower the complexity of the inference tasks, but it is far too weak in sanctioning conclusions to be useful in many situations (see Example 2.2). They also argued that Levesque’s weak semantics is the building block on top of which more inferential capabilities should be added, without losing tractability. This is exactly the direction of research we pursue in our work. What we will show is that: l a very weak semantics can be used as the starting step of high complexity decision problems; l on top of this we can define sound and increasingly more complete procedures that are based on stronger semantics. In the following we also present a dual semantics being stronger than the classical one, that will be used as a basis for complete and increasingly more sound reasoning procedures. What we gain with our approach is the ability to characterize with a precise semantics a wide class of incomplete or unsound inference procedures. We proved the flexibility of the method applying it to several reasoning problems very popular in knowledge representation. In particular we defined approximation methods for: ( 1) propositional logic; (2) fragments of first-order logic (concept description languages); (3) propositional default logic and circumscription; (4) modal logics. Moreover we defined an epistemic language for the representation of resource-bounded reasoners. The language provides for a meta-level description of the approximate knowl- edge owned by an agent. In the rest of this paper we show all such applications, except for approximations of propositional nonmonotonic logics, that we have already analyzed in [14]. Our method depends on the complexity of the reasoning task only to some extent. The complexity of the reasoning problems addressed ranges from NP-complete to PSPACE- complete. 258 M. Schaeti M. Cadoli/Art@cial Intelligence 74 (1995) 249-310 4. Propositional logic In this section we illustrate our approximation technique tional logic. In particular we define a method for approximating for entailment the set in proposi- UT; Y) I T and Y are propositional formulae and T k y}. In Section 4.1 we define the semantics of the approximation. computational method. aspects and in Section 4.3 we present some examples and discuss In Section 4.2 we address the 4. I. Semantics As we said in the previous section, we are interested both in sound and in complete that there is an underlying approximations. We first show the sound approximation, which Levesque’s shallow reading of sentences assume Symbols mapped not proper-of t and f are used for denoting into I and 0, respectively. special propositional L. (cf. Definition 2.1) . Throughout finite alphabet L used for building all the sentences. letters, which are always In the following we denote with S a subset-possibly is a generalization of this section we Definition 4.1 (S-3-interpretation). which maps every -I does not map both a letter I of L \ S and its negation letter 1 of S and its negation An S-3-interpretation of L is a truth assignment into opposite values. Moreover, it --J into 0. According interpretation to this definition, I there are the following possibilities: for each propositional letter 1 E L and each S-3- (1) f(1) = 1 and 1(-l) (2) 1(1) =0 and 1(+ (3) Z(Z) = 1 and 1(~1) = 1 [only =O; = 1; if I E L\S]. S-3-interpretations tions and Levesque’s 3-interpretations. tions using generalized S = L, while a 3-interpretation S-3-interpretations to S. not belong are therefore “something in between” standard 2-valued Often we refer to standard 2-valued interpreta- interpreta- the term 2-interpretations. Both 2-interpretations by S-3-interpretations, since a 2-interpretation are with is an S-3-interpretation with S = 8. We can say that in is possible only for those letters that do is an S-3-interpretation and 3-interpretations the truth value contradiction Interpretations interpretation) First of all, we put formulae rewriting rules: (standard 2-valued assign a truth value interpretations to an arbitrary in Negation Normal Form as well as 3-interpretations formula by means of simple (NNF) using or S-3- rules. the following M. Schaer$ M. CadoWArtij’icial Intelligence 74 (1995) 249-310 259 Now negation occurs in a formula only at the literal level. Rules for assigning truth values to NNF formulae are the following: 0 V-rule: I k Q V p iff I k ff or Z + p; l A-rule:Z~=AAiffZ~cuandZ~p. A formula is S-3-satisjiable if an S-3-interpretation Z exists such that Z satisfies it, i.e. Z maps it into 1. Entailment is defined in the standard way for S-3-entailment: we say that T S-3-entails y (written T b=‘, y) iff every S-3-interpretation satisfying T also satisfies y. Example 2.2 of Section 2.1 showed that the modus ponens rule does not hold for 3-entailment. Let us continue that example considering the definitions we just gave. Example 4.2 (Sometimes modus ponens holds for S-3-entailment . . .) . Let L be the set {a, b}, and T be {a, la V b}. T b b holds and T k3 b does not hold. If S = {a}, then T ki b, since every S-3-interpretation satisfying T maps a and b into 1, and ~a into 0. ( . . . and sometimes it doesn’t). Let L be the set {a, b, c}, S = {a} and T be {a, ~a V b, -b V c}. T k c holds, but T b”, c does not hold. In the above example the relation /=i is sound and not complete with respect to +. We will see in the following that this is a general property of k=“, and we will return later on to the possibility of using b=‘, as an approximation of /=. Now we want to deal with complete and unsound approximations of b. Such a form of entailment is based on the following definition. Definition 4.3 (S-l-interpretation). An S-l-interpretation of L is a truth assignment which maps every letter 1 of S and its negation 4 into opposite values. Moreover, it maps every letter 1 of L \ S and its negation 4 into 0. According to this definition, for each propositional letter 1 E L and each S-l- interpretation Z there are the following possibilities: (1) Z(Z) = 1 and Z(lI) = 0; (2) Z(Z) = 0 and I(+) = 1; (3) Z(Z) =0 and I(+ =0 [if and only if 1 E L\S]. The reason why every letter 1 of L \ S and its negation 11 are mapped into 0 will be clarified shortly. The name S-l-interpretation originates from the fact that for each letter 1 E L \ S there is exactly one possibility. Intuitively, letters in 1 E L \ S are mapped into a truth value which is different from those already seen (tnre, false, contradiction), that we might call undefined. Truth assignment for arbitrary formulae is defined in the same way we did for S-3-interpretations. Analogously, S-l-entailment (denoted by ki) directly follows from that of S-l-interpretation using the same rule. We note that 2- interpretations are not S-l-interpretations and vice versa, unless S = L. In the following we show an example in which the notions of S-l-interpretation and S-l-entailment are used. 4.2. Computational aspects In this subsection we show some properties of S-3- and S-l-entailment that are im- portant from the computational point of view. We denote with T a generic propositional 260 M. Schaerg’ M. Caddi/Arti$cial Intelligence 74 (1995) 249-310 CNF formula and with y a generic propositional and its negation -1. clause not containing both a letter 1 Theorem 4.4 (Monotonicity). For any S and S’ such that S C. S’ Cr L, if T Fi y, then T FL, y (hence T p y). Moreover if T bi y, then T f=i, y (hence T f= y). Observation 4.5 (Convergence). IfT + y, then there exists an S C L such that T /=i y. If T F y then there exists an S C L such that T ki y. Theorem 4.6 (Uniform complexity). There exists an algorithm for deciding ifT /=i y and deciding if T kk y which runs in 0( ITI Iy( . 21’1) time. that Observation We notice S that trivially satisfies smaller size. Theorem 4.4 and Observation of deciding whether T /= y holds can be computed its statement 4.5 directly follows from the previous definitions. A set in sets S of problem fashion by proving or in a stepwise 4.5 show that the co-NP-complete is L itself, but we are interested disproving T ki y and T ki y for increasing sets S, starting with S = 8 and stopping for the least S C L such that either T p$ y or T ki y hold. Referring approximating to the terminology introduced in Section 3 (cf. formula ( l)), we are the set by means of the two families of sets Dl = {(T;Y) I T +;, Y>> D,’ = {(T;Y) I T i=;, ~1. In particular an approximation is defined by two increasing sequences of sets (Sl)=0c~“cS;c~“cS,,,=L), The above results do not tell us for which set S we are going to have a definite answer to the query T /= y. Theorem 4.6 tells us that, even in the worst case (i.e. when we is 0( ITI . IyI . 21Ll), prove or disprove T + y for S = L), the complexity of the method hence similar Notice that if we change Definition 4.3 so that an S-l-interpretation for deciding T k y. to the best-known I satisfies algorithms the weaker requirement (3’) 1(1) =0 and I(-I) =0 [only if It L\S], then deciding whether T kk y would be a co-NP-complete problem for all sets S. As a matter of fact, T +i according to the revised definition, iff T is not S-l-satisfiable, iff T is classically f The method for deciding propositional entailment and T would be S-l-satisfiable, satisfiable. (2-valued) can be stopped for any S C L, and in this case the time spent in the computation Propositional is computed entailment in a step-wise has provided clear semantical information. fashion, and the parameter S controls M. Schuer$ M. Cadoli/Artificial Intelligence 74 (1995) 249-310 261 the quality of the inference. The precision of the inference is arbitrary and depends on the computational effort that has been spent. If ISI is limited by a logarithmic function, then the resulting inference is polynomial. This is a typical approximation process, since every intermediate step provides a partial solution whose relation to the final solution (the error) is clearly identified. We have therefore reached our goal of defining a method for approximation of the consequence relation in propositional logic such that: l it is semantically founded; l approximate answers are easier to compute than the answers to the original inference problem; l approximate answers can be improved, and converge to the right answer (provided we have enough resources and motivation) ; l both only sound and only complete approximations are provided. In the rest of the paper we show methods for approximating other reasoning tasks. All such methods are supported by results analogous to Theorems 4.4 and 4.6 and Observation 4.5. Results analogous to Theorems 4.4 and 4.6 and Observation 4.5 hold for S-l- and S-3-satisfiability problems. This will be the topic of Section 5. All the results just shown (and in particular Theorem 4.6) hold even if T is a NNF formula and y is a generic formula in CNF. This aspect has been analyzed in [ 151, where we showed other normal forms for which the uniform complexity result holds. 4.3. Discussion and examples In this subsection we perform some informal considerations on the meaning of the entailment relations we defined. Let’s start considering two examples. Example 4.7 (Proving a consequence). We assume that the following CNF formula T is part of a very large knowledge base containing information about animals and their properties. T uses a small alphabet L, which we assume to be part of a larger dictionary. The large knowledge base contains a taxonomy of classes, which is partially present in T. L = { cow, dog, grass-eater, carnivore, mammal, has-canine-teeth, has-molar-teeth, vertebrate, animal); T = (-cow V grass-eater), (‘dog V carnivore), (lgrass-eater V lhas-canine-teeth) , (Tgrass-eater V mammal), (lcamivore V mammal), (-mammal V has-canine-teeth V has-molar-teeth), (~mummal V vertebrate), ( -wertebrate V animal). 262 M. Schaetf M. Cudoli/Ari@cial Intelligence 74 (1995) 249-310 Notice that T is not a Horn formula. We want to prove that T f= (lcowvhas-molar-teeth) holds. Since T p3 (--cow V has-molar-teeth), we try to determine a subset S of L such that T /==i (xow goal. In fact, this happens when S = {grass-eater, mammal, has-canine-teeth}, which a small subset of the whole dictionary. holds. By Theorem 4.4 this is sufficient V has-molar-teeth) for our is Example 4.8 (Disproving a consequence). L = {person, child, youngster, adult, senior, student,pensioner, worker, unemployed}; T = (-person V child V youngster V adult V senior), (-youngster V student V worker), (xdult V student V worker V unemployed), ( lsenior V pensioner V worker), (-student V child V youngster V adult), ( Ipensioner V senior), ( Ipensioner V lstudent) , (Ipensioner V lworker) We want to prove that T p ( xhild V pensioner). By Theorem 4.4 we try to de- a subset S of L such termine when S = {child, worker, pensioner} Ipensioner into 1 and all the other literals (Tchild V pensioner). In fact this happens since the S- 1 -interpretation mapping child, worker, into 0 satisfies T but not (xhildvpensioner) . that T k: it seems to include is present, Let us give a qualitative analysis of the above examples. in the set S concepts of the taxonomy which are superclasses in which taxonomic knowledge it is useful of the is concepts occurring spread over several indefinite clauses, an useful strategy seems to be that of extending S with classes with several properties, shared by several classes, such as worker. in the query. As for the second example, that in order to reach an exact solution such as pensioner, or properties in which the knowledge In the first example, the intuitive point of view, both S-3-interpretation to a representation From respond seriously”, while others are ignored. This a way of reasoning (the knowledge letters not in the set S) is ignored on purpose. S-3- and S-l-entailment mechanisms for creating partial views of the knowledge base. in which only some of the propositional in which part of the knowledge leads to an entailment relation cor- letters are “taken that models by are therefore represented and S-l-interpretation differ with respect S-3-entailment that are ignored. to contradictions, do not correspond it “harder” sound and not complete with respect and s-l-entailment In particular i.e. a knowledge base T may have plausible to ordinary models. This proliferation to classical entailment. not computationally) (logically, to prove entailment, letters states (S-3-models) to the treatment of the letters leads that states makes is i.e. S-3-entailment of admissible in S-3-entailment we don’t care if ignoring M. Schaerj M. Cadoli/Artl$icial Intelligence 74 (1995) 249-310 263 We claim that S-3-entailment models a deductive strategy that is sometimes applied in reality. Let us see this with an example, paraphrasing Example 4.7. We are consulting an encyclopedia about animals, looking for particular information, let’s say whether cows have molar teeth or not. It is natural to start our research from the paragraph about cows, then to broaden the scope more and more, taking into account the section on herbivores, the chapter on mammals, the volume on vertebrates, . . . . During this process it may happen that we find a term that we do not understand, because it is defined in a part that we did not read. Anyway we continue until we are able to answer the question or we run out of resources (time, motivation, . . .). We are performing two different forms of local reasoning: ( 1) only a part of the knowledge base is taken into account and (2) only a part of the alphabet is taken into account. While performing this research, we assume that the information not yet considered can be ignored, in the sense that if we prove that cows actually have molar teeth by considering only little information or a small part of the alphabet, then such an answer is definitely exact. Ignoring a part of the knowledge base (i.e. the first aspect of local reasoning) can be trivially modeled. On the other hand S-3-entailment models the second aspect of local reasoning: the set S represents the terms that “make sense” to us. Broadening the scope of our research is modeled by making the set S larger and larger. As far as the S-l-entailment relation is concerned, dual considerations hold. Also in this case we deal with a form of local reasoning, but the information which is ignored is considered in a pessimistic way. In other words we think that the information we are currently holding is useful only for disproving, and not for proving. This leads to dramatic reduction of the admissible states of a knowledge base (i.e. its S-l-models), hence it is possible to accept as a consequence what is not really a consequence (9 l- entailment is complete and unsound with respect to 2-entailment). Summing up, both relations for approximate entailment can model agents with limited resources. The difference is in that they have different attitudes with respect to what is outside the scope of the agents’ competence. Examples 4.7 and 4.8 show that an exact solution to an entailment problem can be reached with a small S. The choice of the minimal set S having this property may not be easy in general. If we knew the minimum size of a set S for which T b=“, y or T k: y holds, then we would know that an upper bound for the entailment problem is 0( ITI - Iy] e 29. A natural question is therefore the following: is approximation of propositional en- tailment only a theoretical method, or do we have a technique for choosing a set S of letters for which we have high expectation of having correct answers? Moreover, how much can we trust an approximate answer? What kind of “degree of belief’ can we associate to it? There are several ways to give answers to this kind of questions. For example we could look for “good” sets S using purely syntactic techniques, like using topological criteria in suitable representations of the formula as a graph. Another possibility relying on syntactic methods is to use parameters such as the number of occurrences of a single literal in the formula. Techniques of this kind have actually been used by several researchers for providing smart methods for solving computationally hard problems (see for example [ 241 in the area of constraint propagation). Moreover several heuristics for 264 M. SchuerJ M. Cudoli/Artificiul Inrelligence 74 (1995) 249-310 choice of the letters to be used in resolution algorithms satisfiability an intelligent [ 571) or in Davis-Putnam’s [46] ) have been developed. Another possibility attribution of a degree of confidence to an approximate for propositional procedure answer. is to use numerical parameters (see for example (see for example for the In our work we preferred reported above. We deal with have been given meta-level the logical for a smart choice of the set S. language relations presented to use a logical these aspects language for addressing in Section 6, where preliminary logic. Our goal has been in the framework of epistemic for the representation of approximate knowledge, in this section. This meta-level knowledge the questions answers to provide a as specified by can be used Techniques defined by other authors-apart ideas with our method. For example Giunchiglia [40] give logical description share method of approximate domain abstraction in the programming modified by Dalal and Etherington whose associated Dalal’s k-consistency reasoning. Related [44] and languages satisfiability [ 201 is similar problem in general community ideas can also be found of only sound as well as only complete from those addressed in Section 2- and Walsh’s abstract proofs forms in Imielinski’s work on born interpretation, [ 371, [ 181. Gal10 and ScutellB’s method formulae demanding. in [21], defines classes of propositional is more and more computationally in the area of abstract Our method differs significantly All the results presented The ideas shown in this section will be proved in Appendix A. 1. in this section have been presented in a preliminary form in [ 11 I. to this respect. from all the above techniques. 5. Algorithms to compute S-entailment The goal of this section into account entailment Taking semantics velop methods respectively. checking S-l- and S-3-satisfiability is to discuss algorithmic aspects of S-3- and S-l-entailment. that T k y holds can be reduced iff T U (1~) to unsatisfiability-in is unsatisfiable-i.e. for 2-valued the first subsection we de- for testing S-l- and S-3-entailment based on S-l- and S-3_unsatisfiability, In the second subsection we focus on the development of an algorithm for of a formula. 5.1. Reducing S-entailment to S-unsatisfiability In this subsection we use the symbol y to denote a clause. First of all, we can to S-entailment, since a formula T is S-l-satisfiable immediately if and only reduce S-unsatisfiability if T kk f, and T is S-3-satisfiable As for the reverse reduction, we introduce a set describing if and only if T ki f. the clause y. Definition 5.1. We denote with letters(y) -1 occurs in y}. the set (1 E L 1 1 occurs in y} U (1 E L 1 The next lemma shows that, when dealing with S-3-entailment, we can safely choose an S such that letters(y) C S. M. Schaefl M. CadoWArtificial Intelligence 74 (1995) 249-310 265 Lemma 5.2. Suppose letters(y) g S holds. Let S’ be the set S U letters(y). T bz y holds iff T k=“,, y holds. The next two theorems show that S-l- and S-3-entailment can be reduced to S-l- and S-3_unsatisfiability, respectively. Theorem 5.3 (Reducing S-l-entailment both letters( ys) C S and letters(q) S- 1 -satisfiable. to S-1-unsatisfiability). Let y be ysv%, where fl S = 0 hold. T & y holds iff T u (7~s) is not Theorem 5.4 (Reducing S-3-entailment to S-3-unsatisfiability). Let hold. T k=‘, y holds i#T U (1~) is not S-3-satisjiable. letters(y) & S The above theorems show that the problem of testing S-3-entailment [ S-l-entailment] can be reduced to the problem of deciding S-3-unsatisfiability [ S-1-unsatisfiability] of a suitable formula. This extends the well-known relation existing between classical entailment and unsatisfiability. The importance of such a result is in that S-3-satisfiability [ S-1-satisfiability] of a CNP formula T can be tested in the following way: ( 1) replace by t [ f] all occurrences (both positive and negative) in T of letters which belong to L \ S, thus obtaining the formula T: [ Tj ] ; test standard (2-valued) satisfiability of Tz [ Ti 1. (2) for NNP The transformation shown in point (1) preserves S-3- and 9l-satisfiability formulae as well (see [ 151). We notice that only letters which belong to S occur in Ti and Ti. As a consequence simple algorithms for deciding S-l- and S-3-satisfiability and running in time 0( ITI . 21’1) can be obtained directly from classic algorithms for satisfiability like Davis and Putnam’s [ 221 or Robinson’s [ 631. Nevertheless very specialized algorithms for propositional satisfiability (e.g. Van Gelder’s [ 721) can be used without loss of efficiency for computing S-l- .or S-3-satisfiability. We want to stress that we are not proposing a new algorithm or heuristic for the satisfiability problem, but we are instead interested in a semantic description of par- tial reasoning. We claim that many heuristics commonly used for the satisfiability problem can be applied in our method as well, since we are able to reduce the re- lations for approximate entailment to ordinary (2-valued) satisfiability of a smaller formula. In the next subsection we show custom algorithms for deciding S-l- and S-3- satisfiability. We now present some simple observations leading to significant simplifications of the formulae whose S-l- and S-3-unsatisfiability we must check in order to prove S-l- and S-3-entailment. We define an operation on formulae; we say that 0 = simplify( r, S), where 0 and r are CNP formulae and S is a set or a conjunction of literals, if 0 is obtained from r through the following steps: ( 1) delete all clauses of r that contain a literal occurring in 6; (2) in any clause /3 of r delete all literals 1 whose negation -1 occurs in 6. 266 M. Schaer$ M. Cadoli/ArtiJicial Intelligence 74 (1995) 249-310 lp occur This operation negation than the original some of the remaining about simplified information. can be done in 0. Moreover, r, formula in 0( Irl since some of the clauses of the latter disappeared, . (81) t’ ime. Notice that no literal p of S or its the simplified CNF formula 0 is always smaller and result process does not lead to loss of less literals. We can now prove a simple that the simplifying clauses contain stating formulae, Theorem 5.5 (Simplifying). and both a letter 1 and its negation 4 do not occur in S; simplify( T, S) is S- 1 -satisjable iff T U S is S- 1 -satisfiable. satisjable. Let 6 be a set of literals such that letters( 8) C S holds In addition, simpl@( T, 8) is S-3-satisfiable iff T U 8 is S-3- theorem The above is intuitive when S = L holds, logic. into account Theorems 5.3 and 5.4, the above result shows that, in order to By taking prove whether T pl y and T +: y holds, we can focus our attention on S-1-satisfiability of simplify( T, -ys) of simplification whole process of determining simplification the validity of the entailment can be done if the following hypotheses hold: respectively. The role in the the that is, for the 2-valued and on S-3-unsatisfiability of T is that of reducing thus gaining efficiency relation b. Anyway, of simplify( T, ly), its dimensions, ( 1) y is not a tautology; (2) letters(y) & S [only for pi]. Since checking entailment of tautologies assumed without can be assumed without loss of generality. loss of generality. Lemma 5.2 shows that also the second hypothesis is a trivial problem, the first hypothesis can be 5.2. Algorithms for testing S-satisjability As we showed in the previous subsection, to testing S-satisfiability. for checking S-l- and S-3-satisfiability. and well-known between S-satisfiability we design an original algorithm. testing S-entailment can always be reduced In this subsection we focus on the development of an algorithm In the first part we show the relations existing In the second part algorithms for satisfiability. 5.2.1. Resolution and enumeration Satisfiability of CNF formulae logic, extensively two of the major studied and discussed types of algorithms ( 1) Resolution-based algorithms formula T by deriving derived, then T is satisfiable. is a very well-known problem in the specialized in 2-valued propositional literature. Here we focus on for satisfiability: [ 631): (e.g. the empty clause they try to prove unsatisfiability of a from it. If the empty clause cannot be (2) Enumeration-based algorithms (e.g. [ 221) : they try to prove satisfiability of a formula T by generating is not found, tation The first type of algorithms them to be well suited to be well suited an interpretation which satisfies T. If such an interpre- then T is unsatisfiable. is more directed to proving unsatisfiability, to check S-3_unsatisfiability, while we expect hence we expect the latter ones to check S-l-satisfiability. We now state formally the correspondence M. Schaerf; M. Cadoli/Arrifcial Intelligence 74 (1995) 249-310 267 between these algorithms and the checks we are interested in. In the following we denote with Cl the empty clause, and with 0 the CNF formula with no clauses. In order to show the link existing between S-satisfiability and resolution-based algo- rithms, we introduce a family of CNF formulae T’ ( 1 < i < m), defined as follows (we denote with {at,. . . , a,} the set S): T’+’ = {X 1 3~1, y2 E T’ and x is the resolvent of yt and y2 upon ai+t } U {X 1 x E T’, ui+l $ x and TUi+t $ x}. The CNF formula T’ ( 1 < i < m) is the conjunction of all the resolvents at the ith level of the resolution tree having T as the root and which have been produced by resolving upon all the literals in {at,. . . , Ui} in any order. Notice that T’ has 0( 2’) times the number of clauses T has. Notice also that no literal of {at,. . . , Ui} occurs in T’. The next theorem shows how S-satisfiability of a CNF formula T can be computed using the resolution method. Theorem 5.6 (S-satisfiability and resolution). A formulu T is S-3-sutisjkble S-3-sutisJiable i$ (cid:144)i # T”‘. A formulu T is S-l-sutisjiuble Tm = R iff T* is S-1-sutisjkble iff Tm is iff Similar considerations enable us to relate S-satisfiability of a CNF formula T to the Davis-Putnam algorithm for checking satisfiability [22]. For this aim we introduce a family @’ ( 1 6 i < m) of sets of CNF formulae defined as follows: Q” = {T}; @+’ = {W 1 3H E d and W = simplify(H, {ui+l})} U {W 1 3H E d and W = simplify(H, {lui+l})}. The family @ ( 1 < i < m) is the set of all the CNF formulae H obtained by simplifying T with any set of literals representing a 2-interpretation of the letters in {at, . . . , ui}a In the generation of @+’ any formula H belonging to @ is replaced by the two formulae simplify( H, {ui+l}) and simplify( H, {lui+l}). Notice that @ has 2’ CNF formulae, each being smaller than T. Theorem 5.7 (S-satisfiability and Davis-Putnam algorithm). A formula T is S-3-sutis- jiuble iff there exists a H E @” that is S-3-sutisjiable; H is S-3-suti@able iff 0 $! H. ifl there exists a H E @“’ that is S-1-sutis$uble; H is A formula T is S-1-satisjable S-1-sutisjable iff H = 0. The possibility of using Theorems 5.6 and 5.7 for making an appropriate choice of the set S will be discussed shortly. 5.2.2. The algorithm We briefly sketch our desiderata about an algorithm for testing S-satisfiability: 268 M. Schuer$ M. Cudoli/ArtiJicicrl Intelligence 74 (1995) 249-310 l The algorithm must compute at the same time both S-1-satisfiability and S-3- unsatisfiability of a generic l It should benefit from previous computations. formula. still S-l-unsatisfiable S. In principle resources; using information therefore we want our algorithm in previous steps. gained In other words, if for a given S, T is and S-3-satisfiable, we probably want to try with a set S’ 3 this may happen after hours or days, depending on our computing to compute satisfiability incrementally, l Although we expect the algorithm to run in time exponential in ]SI, we want the algorithm to use polynomial space. that we want to accommodate into account By taking an important perform all the computations be kept from the past computations. issue for an efficient algorithm a stepwise extension of the set S, to from scratch. In other words, some form of history must is that this extension does not require algorithms respectively, and on enumeration and S-l -satisfiability for each step of the algorithms for straightforward Simply by generating for checking S-3-unsatisfiability the CNF formula T”’ we can determine Theorems 5.6 and 5.7 provide a semantics, based on S-3-unsatisfiability for satisfiability and on S-l- based on the satisfiability of truth assignments. These two theorems also resolution principle and the basis provide at the S-1-satisfiability. same time S-3-unsatisfiability of the formula T simply by checking whether T”’ contains 0 or T” is equal to a, in the same way this can be done through if the generation of the set of formulae @“I. Moreover, both algorithms are incremental: for a given S and T is still S-l-unsatisfiable and we take into account the set S’ = S U {ant+, }, then, in order to compute T”+l, we only need Tm; in the same way, in order to compute @“‘+I we only need @“I. These two algorithms fulfill our first the third one, because both two desiderata, but unfortunately algorithms use an amount of space which grows exponentially with the size of S. in the Davis-Putnam In fact, we can perform amount of space if we generate every com- is either ai or Tai, one at the is proven when we find a 8 such that simplify( T, 6) = L?. On if for all 6 we have that simpli&( T, S) the clause Cl. This procedure the first and the third desiderata, but fails the second one, since when we take into account a set S’ = S U {a,+,} we are both checks using a polynomially-bounded bination 6 = {cl,. time. S- I -satisfiability the other hand, S-3-unsatisfiability contains to fulfill not able to exploit and we must generate each combination . . , c,,}, where each c; (1 < i < m) the previous computations they fail to accomplish is proven fulfills This is particularly and S-3-satisfiable algorithm. evident {Cl). . . 1 cm, cm+1 ). Let us summarize all the above and classic algorithms algorithm existing between S-satisfiability [Davis-Putnam] of the resolution on the letters of S in any order, then S-satisfiability in common visited depth-first, using polynomial for selecting heuristics-developed appropriate choice of the set S is limited. implementations space. Therefore variables results and considerations about for satisfiability. the relationships If the search tree is visited breadth-first, [splitting] “is the same as” satisfiability. Anyway resolving of resolution or Davis-Putnam methods the search tree is the possibility of using specialized to resolve or split on-for making an A further possibility for determining S- 1- and S-3-satisfiability is to reduce T to Ti and Ti, respectively, as sketched in the previous subsection, and check their 2-satisfiability. M. Schaetf M. Cadoli/Artijcial Intelligence 74 (1995) 249-310 269 These reductions may simplify the computations, but they force us to work on two different formulae, thus making difficult the integration of the checks. Furthermore, it is not clear how to make these computations incremental, since the reduced formulae i$ and Ti vary with the set S. Our analysis has shown that all of the above algorithms fail to fulfill all of the desider- ata, hence, we now develop an enumeration algorithm for performing the satisfiability check based on the following properties. Algorithm S-3-unsat/S-l-sat; Input an alphabet L, a subset S = {al, . . , a,} of 15, a CNF formula T andanintegerji,suchthatO<j \ L” 1 <(2+‘-I); Output true, iff T is S-l-satisfiable, false iff T is S-3-unsatisfiable, an integer jO.t such that 0 < j,,“t < (2m - 1) otherwise; begin if there is a clause of T that does not contain at least one literal of S then S-1-unsat := true (* then T cannot be S-l-satisfiable *) else S-l-unsat := false; (* else T could be S-l-satisfiable *) S-l -sat := false; S-3-unsat := true; exit := false; j := 0; while (j < 2’9 and (not exit) do begin (* S-l-sat is false until we prove S-1-satisfiability *) (* S-3-unsat is true until we prove S-3-satisfiability *) (* this flag is used to control the loop *) let dl . . . d,,, be the binary coding of j; (* d,,, is the least significant bit *) for i := 1 to m do (* computation of a combination of literals *) ifdi=l then Ci := ai else Ci -@; := if (j 2 2 * jin) and (S-3-unsat) thenifTp3 (cl V...Vc,) then begin . := J S-3-unsat := false; . Joa if S-1-unsat (* T is both S-3-satisfiableand S-l-unsatisfiable *) then exit := true; (* hence we exit the loop *) end; if not S-1-unsat then if simplify( T; {cl, . . . , cm}) contains no clauses then begin S- 1 -sat := true; ( * T is S- 1 -satisfiable * ) exit := true (* hence we exit the loop *) end; j:=j+l end; (* while *) if S-l-sat then return true; if S-3-unsat then return false else return j,,, end; Fig. 1. The algorithm S-3-unsat/S-l-sat. 270 M. Schuerj M. Cudoli/Artijicial Intelligence 74 (1995) 249-310 Theorem 5.8 (Testing S-3-satisfiability). isjiable iffT k3 (al Anal) V.. holds for any combination .V(a,,A~a,,) Let S be the set {al,. . . , ant}. T is S-3-unsat- holds, or equivalently T k3 (cl v.. .vc,,) {cl, . . , c,,}, where each ci ( 1 6 i 6 m) is either ai or Tai. Theorem 5.9 (Testing S- 1-satisfiability). fiable ~a;, such that simpliJL(T, a) iff there exists a set CY = {cl,. is empty. Let S be the set {al,. . . , a,,}. T is S-l-satis- . , c,,}, where each ci (1 < i < m) is either ai or The basic idea of the algorithm is that, given any set S = {al,. we generate a combination is either a; or ~a;. To generate all the combinations coding of an integer T is S-l-satisfiable. if T F3 (cl V the first case we have a definite answer, while that, if {cl,. check of S-3unsatisfiability. . , a,,,}, at any step cy = {ci , . . . , c,,} of literals such that each ci (1 < i < m) . . , c,,} we use the binary {cl,. then In . V cm), in the second case we can stop our . . , c,,} such is the first combination j varying between 0 and 2”’ - 1. If simplify(T, a) Conversely, is empty then T is S-3-satisfiable. Notice that T p3 (cl V V c,,) holds, then for any other combination {gi, . , g,l} previously generated, T k3 (gl V. . .Vg,,) holds. If S’ = SU{a,+i } is the next set that we consider, V g,, V Tan,+1 ) and T k3 (gl V . . . V g,, V a,,] the combination and is provided as an output in order to prove S’-3_satisfiability, we can start to generate combinations , c,,, , ~a~,+1 }. Therefore, we already know that T k=” (gl V Hence, {Cl>. our computation used as an input of the next call of the algorithm. the integer ji, as input, representing clause of T does not contain at least one literal of S, then T is clearly S-l-unsatisfiable, therefore we do not need to generate ) . from the history of jout, which will be to have that if every the history of the previous call. Notice In the same way, we suppose through an integer its simplifications. {cl, . . , c,} represents The algorithm is reported in Fig. 1. In this algorithm we assume is obvious. that the set S is We notice incremented of a single unit at any step, its generalization the algorithm that, if we restrict S through successive calls to the algorithm, is less than or equal to 21Ll. to check S-3-unsatisfiability then the number of checks of 3-entailment and we extend All the results presented in this section will be proved in Appendix A.2. 6. Approximate reasoning and non-omniscient agents is an attempt at formalizing in Section 4 by means of a modal further applications the form of approximate propositional logic of knowledge. reason- In the remaining presented in of the approximation logics are probably such as knowledge and belief, held by agents. For a detailed account of this the most widely used formalism to represent propositional logics we refer to Hintikka’s work [43]. One of the best-known shortcomings through modal theories are ascribed represented quence of their knowledge tion that agents are capable of performing (or belief). of this representation the capability extremely complex of agents is that agents to infer any logical conse- assump- inferences. This drawback In other words, we make the unrealistic This section ing introduced Sections 7 and 8 we provide Section 3. Modal attitudes, usage of modal M. Schuerj M. CadoWArtificial Intelligence 74 (1995) 249-310 271 is known as the logical omniscience problem (see [43] ). Technically, logical omniscience is a consequence of the possible-worlds semantics commonly used [ 43,5 11 as the semantics for logics of knowledge and belief. General- izations of the possible-worlds semantics have been proposed to overcome the logical omniscience problem (for a detailed survey see [42] ). In the following we assume that the reader has some familiarity with modal logics and its best-known systems. We only want to remind that modal systems can be characterized either by a set of axiom schemata or by the corresponding constraints on the accessibility relation. A detailed description of the various modal systems can be found in the book by Chellas [ 161. In this section we present a very general system, where “approximate” knowledge can be explicitly represented and used; this system is also compared with some of the formalisms presented in the literature. The main idea underlying the system consists in providing language constructs for representing the kind of approximation implicit in the entailment relations +i and ki defined in Section 4. The system consists of two families of modal operators related to the notion of S-interpretation, where the elements of the first family are denoted as 0: and the elements of the second family as 0;. Formulae are built using the usual connectives and the two sets of modal operators 0: and 0: for any S C L. Formulae of the language are built over a set of literals L* using the binary connectives A and V, the modal operators 0: and Cl:, their negation -0: and -0: plus parentheses. In the following, we refer to formulae in this form as Modal Negation Norm& Form . This restriction does not cause any loss of generality since any formula can (MNNF) be transformed into an equivalent one in MNNF by substituting implication + and by pushing negation inside the formulae, by means of the rules presented in Section 4 and the following rules: (ecu)* H cia*; (loa)* H 7clLy*. When we discuss the semantics of general formulae we implicitly refer to their MNNF equivalent formula. Formulae not containing the modal operator are called simply propo- sitional. The semantics is a generalization of the classical possible-worlds semantics. A model is a triple M = (Sit, R, V), where Sit is a set of situations, R is an accessibility relation, and V a valuation, which maps any situation into an unrestricted truth assignment the set of situations s E Sit such (V:Sit+ that s is also a possible world, i.e. V(s) is a 2-interpretation. Similarly, we denote with the sets of situations that can be interpreted as S-3- and S-l- S-3( Sit) and S-l (Sit) interpretations, respectively. The semantics is defined as follows (y is a propositional formula) : (L* --+ {O,l})). W e d enote with W(Sit) iff V(s)(y) = 1; iff Vt E S-3(Sit)sRt l M,s +y l M, s + q $ implies M, t k a; l M, s + 7 0: LY iff 3 E S-3(Sit)sRt and M, t F a; l M, s + q $x iff Vt E S-l(Sit)sRt implies M, t k a; and M, t k a; . M,s k-0: (Y iff 3 E S-l(Sit)sRt 272 M. Schaerj M. Cadoli/Artijicial Intelligence 74 (1995) 249-310 A formula cx is valid, written b LY, if (Y is true at every possible world w E W(Sit) of every model M = (Sit, R, V). A formula (Sit, R, V) and a possible world w E W(Sit) (Y is satisfiable s.t. M, w b CT. if there is a model M = We notice is defined both Cl@ A 7 0: (Y and O&X A 1 q l!s LY are unsatisfiable. that negation of modal formulae in a classical fashion. In fact A minimal requirement relations for the system is its ability to represent +i and ki via the modal operators 0: and 0:. This is in fact possible, as proven by the following (a and y are propositional the entailment formulae): result Theorem 6.1 (Modal validity and S-3-entailment). is unsatisjiable) i# ( LY +i y). (+ 0$x + 03,~) i~(O~cy~~Cl~y Theorem 6.2 (Modal validity and S-l-entailment). is unsatisjiable) i# (cr ki y). ( + 0;~ + C&y) ifs ( (cid:144)I$xA~O~~ Hence, the proposed language can represent order to make our system comparable with the modal system S5 (see generally [ 431) , in the following we assume and euclidean. that the accessibility as an appropriate the approximate formalization considered of the notion of knowledge relation R is reflexive, relations. [ 161)) which In is (see transitive entailment It is now interesting for these new operators, agents. to check whether the schemata defining the system S5 are valid in order to show their adequacy to represent resource-bounded The system S5 is characterized sitional calculus plus the inference by the usual rules and axiom schemata of the propo- rule (necessitation): (Net) + (Y implies b Kcu. and the axiom schemata: (K) K(a--,p) + (Ka+KP). (T) Ka + a. (4) Ka -+KKa. (5) -Ka -+ K~KcY. We now analyze which of these schemata are valid in our semantics when we replace K with 0:. The result is the following: (Net) (K) b (Y does not imply I= q ;(a + P) --f (@ /= q $. --+ q $P). (T) F O&X + cy. hf. Schuer$ IU. Cadoli/Artifcial Intelligence 74 (1995) 249-310 273 The validity of the schemata 4 and 5 is a straightforward consequence of the properties of the accessibility relation, while the schema K follows from the semantic definition of 0:. We now show counterexamples for the properties which do not hold. (Net) Letcu=qV~q,S=$,M=(Sir,R,V),Sit={sl,sz},R={(sl,sl), (sl,s2), (~z,~z)}, (s~,sI), that W(Sit) = (~1). W e h ave M,st p q ;C.Y. V(sl)(q) = 1 and V(sl)(y~) = V(sz)(q) = V(s2)(+ that /= LY holds but k q $Y does not hold, in fact =O. Notice (T) Let S = 8, M = (Sit,R,V), Sit = {sI}, R = {(sl,s~)}, V(sl)(lp) = 1 and V(Q)(~) = 0. Notice that W(W) = (~1). Oip + p is valid iff VN VW E W(Sit) N, w k 10; p V N, w b p. Since by instantiating N to M and w to st we obtain that M, s1 p 1 Clip and M, s1 k p then it is not the case that $.I + LY is valid. We have shown that both the rule of necessitation and the axiom schema T do not hold to model an agent capable of performing in general. As a consequence we can use 0: at least every sound inference, because its knowledge is closed under modus ponens (the K schema), nevertheless, the agent can do some inference which is not sound, in fact the T schema does not hold. Since both schemata 4 and 5 are valid, it follows that agents modeled in our system are fully introspective. Even if the necessitation rule and the T schema do not hold in general they are valid whenever letters(o) C S, so they still hold for a subset of the language. We now analyze which schemata are valid in our semantics when we replace K with Cl;. Again, the schemata 4 and 5 are a straightforward consequence of the properties of the accessibility relation, while the schema T and the rule Net follow from the semantic definition of 0:. We now show a counterexample for the property K. Let S = 0, M = (Sit, R, V), Sit = {sl,s~}, R = {( sl,sl>,(sl,s2),(s2,sl)r(S2,S2)}, V(Sl)(P) = V(a)(q) = V(SZ)(P) = V(s2)(7p) = V(s2)(-q) = 1 and V(~)(T) V(sz)(q) = 0. Notice that W(W) = (~1). We have that M,sl + q ‘,(p -+ q) and M, SI + Clip but M, s1 + q liq does not hold. = V(sl)(-d = Even this set of modal operators does not satisfy all the rules and axiom schemata of S5. In this case the only property which is not satisfied is property K, that is the closure of the knowledge under modus ponens. This implies that an agent modeled with these operators is not committed to full logical omniscience. Its deductive capabilities are limited, but its inferences are always sound, as witnessed by the validity of the T schema. Again properties 4 and 5 continue to hold thus providing the agent with perfect introspection. Since Cl: is an approximation of K, it is clear that whenever the set S is equal to L the two operators coincide and therefore 0: will satisfy exactly the same properties of K, including the K schema. But this schema is also satisfied under weaker 214 M. Schaerj M. Cadoli/Art@cial Intelligence 74 (1995) 249-310 conditions, is valid if and only if (Y A T(Y is S-3-unsatisfiable. if LY is a propositional formula we have that q li( LY + p) + ( q $X + q $) There are other interesting properties which involve different sets S, for example we have that Theorem 6.3 (Monotonicity for 0:). Let S C: S’ C: L. k q ~cy + Cl:, a. We claim the second set accounts that the two sets of operators 0; and 0: account reasoner for a skeptical for a credulous one. We can now model an with a limited amount of resources. The first set of operators accounts reasoner, while agent’s reasoning capabilities a set of semantically motivated we claim agents, each having characterized assumption to its deductive capabilities. and providing In particular, the interaction of several non-ideal competence, that our system can be used for modeling credulous or skeptical-and the logical omniscience its own attitude-either for a non-ideal by the set S. restrictions avoiding It is commonplace in the choice of an efficient query-answering that knowledge about the structure of a knowledge base can be very the knowledge useful engineer who creates a knowledge base is aware of some knowledge about its structure. then the very little has been this kind of knowledge, to answer queries. While If we can design a language well suited to represent is asked take advantage of it when is generally acknowledged, strategy. In general, this information to represent the system we can importance done in practice in order to achieve this goal. We show how the proposed language the knowledge base. As an example, can be (sometimes) about formation knowledge base T, which contains knowledge to decide whether cows have molar properties of herbivores. This information teeth, useful the knowledge to represent in- engineer of the about animals, may know that, in order the to take into account only it is sufficient can be modeled by a formula [ q iT --+ q l~(cow --+ molar-teeth)] like: [T 4 (cow + molar-teeth)] + reading of the above formula letters, for example all letters expressing properties that cows for a fixed S. In the used to perform (cf. it using only S-3-entailment, should be automatically is: if it holds this meta-knowledge choice of the set S which guarantees an high degree of confidence teeth, then we can prove for a suitable set S of propositional of the herbivores. The intuitive have molar query-answering an “intelligent” end of Section 4). The specification process of actual procedures for taking advantage of structural knowledge represented in this meta-language deserves further investigation. non-omniscient Several other systems capable of representing agents have been pre- sented in the literature. We now briefly compare our system with some of the best-known formalisms. In Levesque’s system [ 541 the semantics of the modal operator of implicit belief L is the modal operator of explicit belief B in terms of possible worlds. Conversely, defined is defined with our operators, to 0; when S = 8. Hence, O$r has the intuitive in fact, L is equivalent in terms of situations. Both operators can be represented in our semantics and to 0; or 0; when S = L and B is equivalent reading of “a can be made explicit by M. Schaerj M. Cadoli/Art$cial Intelligence 74 (1995) 249-310 275 reasoning only on letters in S’. Lakemeyer [ 531 has extended Levesque’s system, allowing a restricted form of nesting of operators. However, his semantics, which relies on two distinct accessibility relations R and i? for interpreting negated formulae, is very different from ours, thus making difficult any comparison. A very interesting proposal has been presented by Fagin and Halpem in [ 331. In that paper they introduce a new propositional attitude, in addition to knowledge and belief: the attitude of awareness. This new modality should act as a kind of filter on the consequences that can be drawn. In their system, truth in a world is defined in terms of the relation bp, where q G L is a set of propositional letters and the agent is aware only of them. The intended meaning of b=’ is to restrict the attention only to letters in p, while letters in L \ P are ignored. Our notion of S-l-interpretation is exactly in the same spirit. However, in Fagin and Halpern’s system there is nothing close in spirit to the notion of S-3-interpretation. In a more recent work [ 341, Fagin, Halpern and Vardi present a different system which does not commit to the logical omniscience assumption. The presented system clarifies the reason why most of the non-classical semantics are not committed to logical omniscience. The main reasons are the impossibility of distinguishing either between coherent and incoherent worlds or between complete and incomplete ones. It is exactly the possibility of discerning between the various degrees of incoherence and incompleteness which has led us to the definition of our system. For example, the effect of the operator 0: is exactly to select only complete situations which can be only partially incoherent, i.e. can be incoherent only in the interpretation of the propositions in L \ S. Analogous is the effect of Cl! which selects only coherent situations being partially incomplete. All the results presented in this section will be proved in Appendix A.3. The results of this section have been published in a preliminary form in [ 121. 7. Concept description languages In this section we generalize the technique introduced in Section 4 to deal with (fragments of) first-order logic. In particular, we take into account the so-called concept description Zogics, also known as terminological logics, that are abstractions for several languages in computer science and artificial intelligence. The importance of concept languages in data modeling [ 71, object-oriented databases [ 31 and logic programming [ l] has been stressed by several authors. The computational complexity of concept languages has been extensively studied by ) . In particular, it has been shown that reasoning many researchers (see [ 25,27,59,68] is polynomially intractable in many interesting cases, and that tractability depends on small variations of the expressiveness of the language. A big effort has been spent in the design of “maximally polynomial languages”, i.e. polynomial languages such that no expressiveness can be added without losing tractability. Other researchers (see [ 58,611) proposed incomplete or unsound reasoning systems based on non-standard semantics in order to simplify reasoning tasks for concept lan- guages. Patel-Schneider in [ 6 1 ] presented a polynomially tractable terminological logic 276 M. Schaerf; M. Cadoli/Arti’ciul Intelligence 74 (1995) 249-310 based on a 4-valued plification the definition of sound approximations of concepts in order semantics. Kautz and Selman proposed in [69] a syntactical to make inference computationally more sim- tractable, by and complete approximations. In this paper we focus our attention on the languages belonging to the AL-family (see shown [68] and for an overview on the family) in [ 261, these languages are representative in particular on ALE and ALC. As of a wide class of concept languages. The structure of this section is as follows: languages, while in Section 7.2 we introduce multivalued in the following the logics In Sections 7.3 and 7.4 we demonstrate our subsection we recall in first-order languages. basic notions on concept for approximation approximation method for the two languages ALE and ALC, respectively. 7.1. Concept languages In this subsection we briefly summarize the syntax and semantics of concept descrip- tion languages. Concept concepts language constructors like female, are decidable languages ing with concepts. A concept kinds of symbols, primitive by various simply a symbol, ing a common property, that is used to represent constructor ical example of a language concept Vfriend.female the friends being female. Other typical cation 1 and the boolean connectives is jfriend.Tfemale, not female. like being a binary is a composite that represents sublanguages of predicate is a monadic predicate logic, designed for deal- that can be built up of two and roles. Primitive entities can be combined that is used to represent a class of individuals concept yielding individuals, relation among role is a symbol, female. A primitive complex concepts. A primitive is all hav- like friend, like friendship. A typ- is the universal quantification V. The symbol having all that represents are the existential quantifi- language constructors n, U, 1. Another example of composite concept the set of individuals having at least one friend being the set of individuals In this section we focus our attention on the two languages ALE and ALC belonging (see [ 681). to the AL-family Throughout concepts with the letter R. this section we denote primitive concepts with (either primitive or composite) with the letters C and D and primitive the letters A and B, roles The syntax of the language ACC is the following: c,D --+ TIIIAI~AI~~DICUDI~IR.CI~R.C The special symbols T and I stand for the universal concept and the empty concept, respectively. All the individuals belong to 1. Although the standard syntax of ACC allows negation in front of any concept, due to the presence of disjunction we don’t lose any generality by allowing negation only in front of primitive concepts. Examples of well-formed ALC concepts are: to T, while no individual belongs (3R.A) n (3R.(lAnVREIR.A)), ZlR.SlR.‘ifR.(AU B). M. Schaerf; M. Cadoli/Art@cial Intelligence 74 (1995) 249-310 211 In ALE is another interesting language, whose syntax is a restriction of that of MC. particular the construct C U D is not allowed in AL&, therefore the first of the two ALC concepts above is also an AC& concept, while the second is not. The semantics of concept languages is usually given by defining a domain of inter- pretation U, by assigning to every primitive concept a subset of U and to every primitive role a subset of U x U and by defining a rule for each constructor. For the purpose of our work we prefer to define the semantics of ACE and dLC by translating any con- cept C into a first-order sentence T(C) and interpreting it with the classical semantics is of first-order logic. As an example, the ALC concept D G (B n VR.A) U 3R.lB translated into the first-order formula (B(a) AVxNa,x) -+ A(x)) v (3yR(u,y) A +(Y)), where a is a constant symbol. In general the translation from a concept C into the corresponding first-order formula is obtained by applying the following rewriting rules to c: T(C) t--+ NCU), t, f9 @(T,x) H @(Lx) H @(A,x) H A(x), @( TA, x) I-+ PA, @(C n D,x) H @(C,x) A@(D,x), @(C u D,x) H @(C,x) V@(D,x), @(VR.C, x) ++ VyR(x, y) -+ @(C, y), @(3R.C,x) H 3yR(x,y) A@(C,Y), where u is a constant symbol, y is a variable symbol and x is either the constant symbol a or a variable symbol. We assume that the new variables introduced by the last two rules are fresh. A concept C is sutisjiubfe iff its translation T(C) is a satisfiable sentence, unsatisfiable otherwise. As an example, the concept VR.A is satisfiable, while the concept (VR.A) n3R.7A is unsatisfiable. It is immediate to show that this semantics is equivalent to the more standard semantics for concept languages as found, for example, in [68]. In this section we are interested in analyzing satisfiability problems, although the computational complexity of other reasoning tasks like subsumption and instance check- ing has been extensively studied in the literature. The complexity analysis has shown [ 681 and co-NP-complete for that satisfiability checking is PSPACE-complete for dLC ALE [25]. 7.2. First-order generalization of S-interpretations In this subsection we define a generalized notion of interpretation of first-order for- mulae, in particular extending to a first-order semantics the definitions of S-3- and 278 M. Schaer$ M. Cadoli/Art&iul Intelligence 74 (1995) 249-310 S-l-interpretations lowing cepts. for defining introduced approximations methods in Section 4. This new notion will be used in the fol- of ACE and d,CC con- for satisfiability In order to simplify our definitions, we consider for In particular we only consider Herbrand models. To this end, we assume the models. that all sentences are in Skolem Normal Form. Since we are interested only in studying the satisfiability that we are not losing any generality. fixed domains of interpretation theorem ensures the Herbrand of sentences, We recall l/j, of a formula 4 the constant and function that the Herbrand Universe that can be built using in 4 (if no constants occur in 4 include one in rl;,). The Herbrand Base Bh of 4 is the set of ground atoms built applying predicate in e5 to terms of the Herbrand Universe. is a pair I = (I+, I-) of the signature C used A Herbrand subsets of the Herbrand Base Bh which partition Bh. In other words I is built using rules: is the set of terms symbols occurring symbols occurring interpretation of two in 4 Rule 1. It U I- = B,,. Rule 2. I+ n I- = 0. the partition The subset represents possibilities to call LY (I + a) satisfaction conjunction I+ represents for an atom, namely it may belong either the set of atoms (Y of BI, whose negation the set of atoms LY of Bh which are true in I, while I- is true in I. Since there are only two to I+ or to I-, we are entitled I satisfies an atom iff LY E If and satisfies a negated atom T(Y (I k T(Y) iff LX E I-. The of complex and universal quantification: I k LY V/l of C. A %-interpretation I a 2-interpretation is defined using for disjunction, the standard sentences rules l V-rule: l A-rule: I f= a A p iff I b LY and I k /?; 0 V-rule: f + V’x.y(x) iff I + LY or I + /3; iff I + y(t) for all t E uh. We are not interested it is always possible rewriting rules presented in Section 4. in rules for the interpretation to “push” the negation since of complex negated formulae, in front of atoms using a variant of the The main idea of our semantic notion of approximation is to define formulae without using one of Rules 1 or 2. This presented formula of 3-interpretation in Section 4. In fact, loosely speaking, is the set of the boolean variables occurring given by Levesque corresponds idea is a generalization interpretation of of the idea the Herbrand Base of a propositional in it, therefore the Definition 2.1 to keep Rule 1 but not Rule 2. We use the symbol C to denote a signature. We define a 3-interpretation of L to of subsets of Bh such that Rule 1 holds and Rule 2 may not is defined by means of the V-rule, A-rule and formulae I-) of complex be a pair I = (If, hold. Interpretation V-rule. The notions of satisfiability Definition 4.1 of S-3-interpretation, and entailment are defined as in the propositional case. presented in Section 4 makes use of Rule 2 in a formulae. Let S be to first-order restricted way. We now give the definition a subset-even that applies the Herbrand Base Bh. not proper-of M. Schuerj M. Cadoli/Artij?cial Intelligence 74 (1995) 249-310 279 Definition 7.1 (S-3-interpretation of $rst-order formulae). An S-3-interpretation of .C is a pair I = (I+, I-) where both If and I- are subsets of Bh, such that Rule 1. I+ U I- = Bh. Rde2.ZfnZ-nS=Q). Intuitively, an S-3-interpretation is a 2-interpretation of the atoms of S, while it is a 34nterpretation of the remaining atoms. The three possibilities for each atom LY of Bh are the following: (1) cu~Z+ anda$Z-; (2) (Y 61 If and (Y E I-; (3) (Y E If and a E I- Notice that, for any S, a 2-interpretation [only if (Y E L \ S] . is always an S-3-interpretation, while the latter is always a 3-interpretation. Satisfaction of complex sentences is defined by means of the V-rule, A-rule and V-rule. Notice also that if S E S’ C Bh, then S-3-unsatisfiability of a formula always implies its S’-3-unsatisfiability, hence its 2-unsatisfiability. Using this characteristic of S-3-satisfiability we can approximate the satisfiability problem for a formula by means of a sequence (So c SI c . . . c S,, = Bh) of sets. In the following we show actual examples of the choice of this kind of sequences in the context of the languages ALE and MC. We now introduce the definition of S-l-interpretation of first-order formulae, which is dual to S-3-interpretation and modifies Rule 1 while keeping Rule 2. Definition 7.2 (S-I-interpretation of jirst-order fomulae) is a pair Z = (I+, I-) where both I+ and I- are subsets of Bh, such that . An S-l-interpretation of L Rule l.Z+UZ-=S. RuIe2.Z+nZ-=@. An S-l-interpretation is a 2-interpretation as long as the atoms of S are concerned, while for all the atoms Q not in S it holds that (Y @’ I+ and (Y $ I-. We define Term(S) to be the set of all the terms that can be generated by using the functions and constants which appear in atoms of S. Notice that this is in general a subset of the Herbrand Universe. We define S-l-interpretation by means of the V-rule, A-rule and the following l V/-rule: Z b Vx.y(x) iff Z b y(t) for all t E Terms(S). As we show in the following subsections, we are not interested in sets S containing all the ground instances of a predicate symbol. S-l-interpretation with the V-rule would be trivial, since no sentence can be satisfied. The intuition behind the V/-rule is that we are ignoring objects that are not in the intended domain of interpretation. 7.3. Approximation in ALE We now define a method for approximating the task of deciding satisfiability of an ALE concept. The method is based on a syntactic manipulation of concepts that 280 M. Schaerj M. Cadoli/Art@cial Intelligence 74 (1995) 249-310 simplifies precise semantics in terms of S-l- and S-3-interpretations, the task of checking their satisfiability. The syntactic manipulation is given a to present The method we are going a class with weaker properties, is based on the idea of approximating than another one: a concept can be approximated an ALE concept by means of two sequences of “simpler” ALE concepts. There are two ways in which a concept can be simpler either by a weaker concept or by a stronger one. A concept D is weaker it represents hand, stronger concepts concepts carry interesting unsatisfiable, stronger concept approximation and is improved and eventually contains only stronger concepts. It starts with a very rough approximation in a stepwise process, giving “stronger and stronger” approximations represent more specific classes. Both kinds of approximated information. than C if i.e. a less specific class. On the other is the satisfiability of a the In fact, if we can prove that a weaker concept of C. One of the two sequences defining contains only weaker concepts. concept. The second sequence of C is also proved. Proving then the unsatisfiability the satisfiability to the original is dual, and converging implies As an example, let’s consider an unsatisfiable ALE concept, called dummy in the following (3friend.tall)fl Vfriend. ( (Vfriend.doctor) n 3friend.ldoctor). It denotes friends having both all the friends doctor and at least one friend who is not a doctor. having at least one friend set of the individuals the (empty) tall and all the complex For obtaining approximating concepts dummy we syntactically it by sub- subconcepts with simpler ones, where a subconcept D of an dL& stituting concept C is a substring of C being an AL& concept. The depth of D is the number of universal quantifiers occurring the depth of the subconcept 3friend.ydoctor of dummy is 1, while the depth of 3friend.taII is 0. We define depth of its existentially quantified Using in C and having D in their scope. For example, subconcepts. The depth of dummy is 1. the sequence of weaker approximated the notion of depth we define the depth of a concept to be the maximum simplify The ith weaker concept of depth greater or equal than into account dummy we obtain is obtained by replacing every existentially quantified i with the primitive the sequence of concepts: concept T. As an example, concepts. subconcept taking l T n Vfriend. ( (Vfriend.doctor) n T) . l (3friend.tall) fl Vfriend. ( (Vfriend.doctor) n T) . a dummy. of the sequence The elements spectively. Notice is unsatisfiable. instead of T. Its elements are denoted as dummy;, that the first two concepts are denoted The sequence of the stronger concepts dummyT and dummy:, as dummy:, are both satisfiable, while re- the third one I respectively. sequences of AL& concepts. For each i (0 < i < n), is obtained by substituting and dummy;, dummy: Formally, we associate to an ALE concept C of depth n two distinct aT=CT n ,..., Cn’, andcrl=CO1,...,C,l+, M. Schoer$ M. CadoWArtijkial In!elligence 74 (1995) 249-310 281 is obtained from C by substituting every concept CiT [ Ci’ I of the sequence uT [al] every existentially quantified subconcept of C which is in the scope of at least i universal quantifiers with the concept T [I]. Moreover CT:+,, = C&t = C. Notice that, for each i (l<i<n+l) isstrictlylessthani. thedepthofc: [Ct] The semantics of the approximation will be addressed later on, but at this point we would like to make some intuitive considerations on the simplified concepts. As we noticed in Section 7.1, proving the satisfiability of a concept C is equivalent to proving the existence of an object a having the property represented by the first-order formula F(C) . If existentially quantified subconcepts of depth 0 occur in C, then it is necessary to consider objects related to a. As an example, when we deal with the concept dummy we need to consider the existence of a friend of a being tall, because of the subconcept 3friend.tall of C. Let’s call c this friend. Deeper existentially quantified subconcepts may also contribute to the generation of objects that have to be considered. Continuing our example, the subconcept 3friend.Tdoctor of dummy makes it necessary to take into account the existence of a friend of c-let’s call it f(c) -not being a doctor. Intuitively, focusing on simplified concepts means ignoring the properties of objects which are “far away” from a. As an example, considering dummy: frees us from taking into account the object f(c), while when we consider dummy: we don’t even have to deal with the object c. This intuition will be clarified when we will analyze the semantics of the concepts in the approximating sequences. We now give a couple of important properties of the sequences uT and &, that are useful for defining our approximation schema. Theorem 7.3 (Monotonicity of aT and a’). unsatisfiable then Cj’ is unsatis$able for all j 2 i, hence C is unsatisfiable. For each i (0 < i < n + 1 ), if CT is For each i (0 < i < n + 1 ), if CiL is satisjiable then C,A is satisjiable for all j 2 i, hence C is satisjiable. Observation 7.4 (Convergence of aT and al). Zf C is unsatis$able, then there exists an i (0 < i < n + 1) such that CiT is unsatisjkzble. Zf C is satisfiable, then them exists an i (0 < i < n + 1) such that Ci’ is satisfiable. We notice that these results correspond to Theorem 4.4 and Observation 4.5 shown in Section 4. Theorem 7.3 and Observation 7.4 suggest a method for deciding in an incremental fashion the satisfiability of an AL& concept C. We may start by deciding the satisfiability of CT; if COT is unsatisfiable, then by Theorem 7.3 we are guaranteed that C is unsatisfiable as well. Analogously, if Ck is satisfiable, then we know that C is satisfiable. If neither of the two cases happens, then we decide the satisfiability of C,T and C,l, and so on. Clearly we have a definite answer as soon as we prove either unsatisfiability of some CtT or satisfiability of some Ci*. Referring to the notation defined in Section 3, we approximate the set D of satisfiable AC& concepts of depth n (Da,~t,...,2)n+t) bymeansoftwosequencesofsets ‘.Di [D’] is the set of ALE concepts C whose stronger [weaker] form Ci’ [CfT] is satisfiable. and (@r,D’,...,2Y+1),where We now make some considerations on the computational cost of deciding satisfiability 282 M. SchaerJ M. Cudoli/Art@ial Intelligence 74 (1995) 249-310 fashion. Donini et al. show in [25] of an ALE concept whose depth is linear is co-NP-complete. in such an incremental the satisfiability of an AL& concept the problem of checking its length In the same paper any d,CCE concept having depth m can be checked 1 is the length of the concept. quantifiers nesting observation In other words, is the crucial measure of the complexity of satisfiability can be tested has the same importance of Theorem 4.6 presented it is shown in time proportional the nesting of existential is bounded by a constant, then satisfiability that in of to 1. 2m, where and universal checking. in linear If such a time. This in Section 4. that the satisfiability Our method for checking versions of C of increasing satisfiability. The complexity cannot be decided until the complexity case algorithms. Since significantly the problem satisfiability depth and may use existing algorithms of an ALE concept C considers for checking simplified their of the whole method is O(Z2 . 2m) even if satisfiability of our method the unsimplified concept C is taken is therefore comparable is co-NP-complete, we don’t expect any algorithm into account. In the worst to that of the existing to be better than ours in the worst case. We are now interested in giving a clear semantics to our approximation since as we stressed earlier it is not always possible important, amount of time a definite answer to the problem of checking particularly reasonable of an AL& concept. Therefore be very clear, since in general we can afford only an approximate the meaning of each step of the approximation to obtain the satisfiability should solution. schema. This is in a In order to give a semantic account to the approximations to use the notions of S-3- and S-l-interpretation now going As we noticed earlier, S-3-interpretations definition of satisfiability. Analogously, concepts of the sequence aT the original concept C. Our goal is to show that 2-satisfiability of each concept CjT is equivalent the Herbrand Base of the Skolem Normal Form SNF(T(C)) result will be obtained for a concept CiL and Si-1-satisfiability lead to a complete Theorem 7.3 shows to Si-3-satisfiability of ALE concepts, we are introduced in Section 7.2 (and in general unsound) (or simply, satisfiability) of C for a suitable subset Si of of T(C). An analogous of C. of the is complete and unsound with respect to the satisfiability of that satisfiability r(C). formula As we said in Section 7.1, the semantics of an ALE concept C can be defined in satisfiability Since we are only interested stratification the increasing can be stratified on the Herbrand Base. More precisely, complexity of its terms. This stratification the Skolem Normal Form SNF( r( C) ) of r(C) in terms of a first-order . The properties, we take into account in a very simple way by taking Herbrand Universe of SNF( T(C)) delivers another into account let uh be the Herbrand simple Universe of SNF( T(C)). This universe can be stratified with the following policy: Let Ue be {u} and Ui be the set of all the terms which can be formed using a, Skolem that constants of uh and functions the ... ua c ui E i. This stratification of the Herbrand skolemization of an existential quantifier of depth 50 C Si C . . . c &+I = Bj, on its Universe of SNF( r( C) ) induces a stratification in the following way: Herbrand Base Bh defined that a function of arity of uh of arity strictly less than i. Clearly it holds from = uh. Notice i comes c u,,, Si = {A(t) 1 A is a primitive concept and t E C/i} U{R(tl,tz) 1 R is a role and ti,t2 E Ui}. M. Schaerf, M. Cadoli/Artijicial Intelligence 74 (1995) 249-310 283 A clarifying example is in order. Let’s consider again the concept dummy (3friend.tall)f-l Vfriend.( (Vfriend.doctor) n 3friend.ldoctor) and the related first-order formula r(dummy), for the predicate symbols in which we use obvious abbreviations (3XF(Q,X) AT(x)) AVY F(a,y) + WZ(WY,Z) -D(z)) A(3uWy,u) A+(u))). The following formula is the Skolem Normal Form SNF( r(dummy) ) of I’(dummy) F(a,c) A T(c) A Vy(F(a,y) -+ W(F(y,z) -D(z))AF(y,f(y))A~D(f(y)))). ), c is a new constant symbol that replaces the variable x, while In SNF( r(dummy) the variable u. The Herbrand f( ) is a new function symbol-having ) is the set of all the terms that can be obtained from Universe Uh of SNF( r(dummy) a, c and f(). The Universe uh is stratified into the three sets Vc = {a}, Ui = {u, c} and U2 ={a,c,f(a),f(c>,f(f(~)),...}. arity l-replacing Notice that Si turns out to be equal (up to Skolem functions and constants renaming) to the Herbrand Base of SNF(r(CiT)). As we saw before the concept dummy is unsatisfiable. We noticed informally that its unsatisfiability can only be proven by taking into account the properties of the friends of the friends of a: All the members of this class should be doctors, while one of them is not a doctor. As a consequence, dummy is unsatisfiable, but its simplified versions dummy~ and dummy: are both satisfiable. As a semantic counterpart, we notice that SNF( r( dummy) ) is unsatisfiable and this follows from the existence of a term of the form f(c) which denotes the friend of the friend c of a. Actually SNF( r(dummy) ) is both SO-~- and Si-3-satisfiable, where a concept C is Si-3-satisfiable if SNF(T(C)) is 93-satisfiable with S = Si. This can be easily shown by noticing that the atom D(f(c)) does not belong to Si, hence it is possible to define an St-3-interpretation I = (I+, I-) such that D( f( c) ) E I+ and D( f(c)) E I-. This kind of interpretation “hides” the reason of inconsistency of the concept dummy, which is therefore Si-3-satisfiable. This argument obviously holds also for the stratum &. The above example shows that it is possible to relate Si-3-satisfiability of a concept to satisfiability of the ith element CT of the sequence uT. The following C of AL& theorem formalizes this result. Theorem 7.5 (Semantics of aT). For all i (0 < i < n + l), C is Si-3-satisfiable iff Ci’ is sutisjkble. What this theorem says is that our approximation schema based on the analysis of syntactically simplified concepts readily corresponds to the semantic idea of focusing on subsets of the Herbrand Base which are defined by a simpler universe. This characteri- zation of the approximation process could not be obtained if we were to use the more 284 M. Schaerf; M. Cadoli/Ariificial Intelligence 74 (1995) 249-310 for AL-languages (see Appendix A.4) based on extension functions, standard semantics since we could not introduce The above correspondence the notion of complexity of terms. between Si-3-satisfiability of the ith element CT of the sequence gT can be easily extended satisfiability dual case of Si-1-satisfiability. the approximation be interpreted from the equivalence of the Herbrand Base of SNF(T(Ci’)) SNF(T(C,T)). of the satisfiability as Si-1-satisfiability Similarly to the previous case, it is possible of a concept C through of the translated concept SNF( T(C)). of a concept C of AL& and to the to show that can This follows and the Herbrand Base of the sequence & Theorem 7.6 (Semantics CiL is satisfiable. of (TV). For all i (0 < i 6 n + I), C is $-l-satisfiable ifs Notice terpretation interpretation that the difference of atoms not belonging I of the concept dummy We conclude this section by making to the stratum Si. As an example, between Si-l- and Si-3-interpretations relies on the in- in each St-l- it holds that D( f( c) ) $Z If and D ( f( c) ) 6 I-. the choice of the schema. that the number of primitive concepts and roles used is not of an AC& role and no primitive problem even if a single primitive defining our approximation some considerations the satisfiability about in ALE. More precisely, deciding subsets Si of the Herbrand Base of SNF(T(CiT)) Donini et al. show in [25] a source of complexity concept C is a co-NP-complete concepts but T occur in C. This fact has an important instances of a single atomic is still co-NP-complete. it shows impact in the choice of an approximation schema for ALE if the subset S of the Herbrand Base contains of an role, then deciding S-3-satisfiability that, the sets S defining so that the real source of complexity-which Therefore the approximation is the depth of In particular concepts. all the ground ACE concept schema must be designed concepts-is addressed. 7.4. Approximation in ALC In this subsection we define a method ability of an ALC concept. Like the method this one is based on a syntactic manipulation S- I- and 93-satisfiability. for approximating illustrated of concepts the task of deciding in the previous subsection, satisfi- also in terms of that is interpreted introduced A first obvious question is: can we plainly use the method quantifiers deciding has at least satisfiability implies 7.3 for the purpose of approximating ALC concepts? We notice existential consequence an NP-hard problem. This concept an ALE from problems method this language of disjunction, the expressiveness of ALC concepts without existential quantifiers for the approximation that the method defined polynomially In our opinion of ACC should address both sources of complexity intractable an effective of in ACE, and that the very first step of the approximation. [ 261) : the complexity of existentials, used for ACC concepts-to for the approximation in the existential-free fragment of ALC. (see present of propositional also present leads-when in Section that ALC without calculus. As a is of hf. Schuerf; ht. CadoWArtijicial Intelligence 74 (1995) 249-310 285 The source of complexity of disjunction is also present in the propositional calculus. The method presented in Section 4 for approximating propositional satisfiability relies on the use of S-l- and S-3-satisfiability, in which sets S containing more and more boolean variables are taken into account. This corresponds to a stratification So C St C . * * c %,I = Bh of the Herbrand Base Bh, in which each stratum contains all the ground instances of a predicate symbol. As we noticed at the end of tbe previous section, such a stratification cannot be used for the approximation of ACE, which must instead be based on the complexity of the terms of the Herbrand Universe. It is therefore natural to combine both ideas for the approximation of ALC. In the method we are going to present, the concepts of the approximating sequences have both a fixed depth and interpret classically only a subset of the primitive concepts. Let’s start again with a concrete example and consider the following ALC concept: D z (A n -A) U ((VR.A) fl3R.lA). D is unsatisfiable, because it is the union of two unsatisfiable ~J!X concepts. D can be approximated either by substituting the existentially quantified subconcept 3R.lA with T or by replacing the primitive concept A and its negation TA with T. Moreover both methods can be combined. Each of the following dLC concepts is weaker than D and satisfiable: T_ D,,, = (T n T) u (VR.T n T). D&).0 = ( A n 1A) L. (VR.A n T). D& E (T n T) u (VR.T n 3R.T). The first subscript denotes the set of primitive concepts that are not substituted by T, while the second one denotes the depth of the approximation. In general, given an ALC concept C of depth n built on the set A of primitive concepts, a set P G A and an index 0 < i < it + 1, we denote with the symbol C~i the dLC concept obtained from C by means of the following rules: ( 1) Substitute each (positive or negative) occurrence of a primitive concept not in P with the concept T, thus obtaining the concept C’. (2) Substitute every existentially quantified subconcept of C’ which is in the scope of at least i universal quantifiers with the concept T. instead of T. Let PI and P2 be two The concept C~i is obtained by substituting I subsets of A and let it and iz be two indexes such that 0 < il, i2 < n + 1. Let C be an ACC concept and let Cl = C&, and C2 G Ci,iz be two approximations of C. We say that C1 5 C2 holds iff both PI G P2 and il Q i2 hold. We define the relation 5 only between pairs of weaker approximations and pairs of stronger ones. This relation is a partial order in the set of the approximations of an ALC concept. The following are two interesting properties of this relation: Theorem 7.7 (Monotonicity). Let P be a subset of A and i be an index such that 0 6 i < n + 1. Zf C& is unsatisjiable, then any subconcept D of C such that Czi 5 D is unsatis$able. If C~i is satisjiable, then any subconcept D of C such that Ckj 5 D is satisjable. 286 M. Schaetf M. Cadoli/Artijicial Intelligence 74 (1995) 249-310 Observation 7.8 (Convergence). A and an index i (0 < i < n + 1) such that CL. is unsatisfiable. If C is satisfiable, then there exists a subset P of A and an index i (0 < i 6 n + 1) such that C$. is satisfiable. then there exists a subset P of If C is unsatis$able, The above properties are analogous 7.4 for ALE. the same lines of Section 7.3, we say that any ALC concept C can be approx- sequence of weaker concepts respect can be to Theorem 7.3 and Observation of C. A strong approximation to a weak approximation to 3) (with Along imated by means of an increasing CL.. This corresponds obtained by considering It can be shown that satisfiability an increasing sequence of concepts Cki. checking of a subconcept CA or C&. can be done in time proportional to that of Section 7.3, in order ALC concepts in an incremental algorithms [ 681). (see to 21pl’i. This property entitles us to perform an argument to show that our method fashion has a complexity for checking comparable similar satisfiability of to the standard From the semantical point of view it is possible in terms of S-3- and S-l-interpretations. this form of approxi- Let C be an ALC concept and n be its exactly as in the case of ALE concepts. The stratification Uu c Ut C is defined as in the to mation depth-defined ... c Un+l = Uh of the Herbrand Universe ZJh of SNF( r( C)) previous section. We define be the following the subset SP,~ of the Herbrand Base Bh of SiVP’(T(C)) to characterize set: {A(t) / A is a primitive concept in P and t E Ui} U {R( tl, tz) 1 R is a role and tl, t2 E Ui}. iff it is S-3-satisfiable for S = SP,~. The intuition this definition We say that C is Sei-3-satisfiable behind S; defined the concept A belongs limiting both sources of potential complexity: Contradiction an analogous way we define SRI-l-satisfiability. relations between syntax and semantics: in Section 7.3. In particular we want a unary atom A(t) is that we are confining our attention only to a subset of the set to be in S,i only if to the set of privileged primitive concepts P. In this way we are disjunction cannot arise from roles, since d&C does not support negation on roles. In the and existential quantification. The following properties formalize Theorem 7.9 (Semantics concept C is Sp,i-3-satisfiable ifs Cgj is satisfiable. of T rewriting). For all i (0 < i < n + 1) and P C A the Theorem 7.10 (Semantics concept C is SRI- 1 -satisfiable iff C& is satisjable. of i rewriting). For all i (0 < i < n + 1) and P & A the is in some sense underspecified, this section by noticing We conclude of ALC concepts subsets P of the set of primitive concepts. it is more appropriate satisfiability we know exactly whether to enlarge of a given concept. We remind t satisfies that the method we propose for the approximation since we gave no criteria for choosing it makes sense to ask whether i when deciding In particular, the index the set P or to increase that for each A E P and each term t E Vi the property A or not. M. Schaerf; M. Cadoli/Artificial Intelligence 74 (1995) 249-310 287 In Section 7.3 we noticed that increasing the index i corresponds to admit terms of the interpretation that are more and more complex, i.e. to have a wider Herbrand Universe. On the other hand enlarging the set P amounts to interpret classically a wider set of concepts, but we don’t have to consider new terms, i.e. the Herbrand Universe remains the same. Therefore if we want a sound and complete treatment of a large collection of individuals, but we are not committed to assign them many properties, then we should increase the index i. If we want a sound and complete treatment of a large collection of properties, but we are not committed to consider all the potential individuals, then we should enlarge the set P. All the results presented in this section will be proved in Appendix A.4. The results of this section have been published in a preliminary form in [ 131. 8. Propositional modal logics In this section we present the use of our approximation methods in the field of modal logics. In particular we show how it is possible to approximate satisfiability in the most widely used modal logics for knowledge and belief, namely S5, K, 7 and S4. This is the second section devoted to modal logics. In Section 6 we focused on the use of a multimodal language as a tool for modeling approximate knowledge of a resource- bounded agent. The goal of this section is to approximate reasoning in classical modal logics. A detailed analysis of the computational complexity of satisfiability problems in several propositional modal systems has been done by Ladner [ 521. He showed that the problem of checking satisfiability of a formula in the systems K, 7 and S4 is PSPACE- complete, while the same problem is NP-complete in the system S5. Therefore most of the modal logics frequently used for modeling knowledge and belief (see [ 431) lead to computationally intractable reasoning problems. In this section we focus on the problem of applying approximation techniques to such propositional modal systems. The main idea is to extend the method defined for propositional logic by defining two classes of interpretations which are approximations of the standard Kripke semantics. In the following we refer to modal formulae which are built on the set L* by means of the usual connectives V and A, the modal operator K, the negation -IK of the modal operator, plus parentheses. Using the terminology introduced in Section 6, we call formulae of this kind modal negation normal form (MNNP) formulae. Let LY be a formula in which each occurrence of a modal operator lies in the scope of at most II modal operators. The parameter n is called the modal depth of cy. We remind the definition of a Kripke model. Definition 8.1 (Ktipke [ 5 1 ] ) . A Kripke model is a triple M = (W, R, V) where W is a set of worlds, R an accessibility relation among worlds and V a mapping W + 7, where T is the set of all the truth assignments of L*. In a standard Kripke model V(w) is a 2-interpretation for every world w E W. We 288 M. Schaerf; M. Cudoli/ArtiJciul Intelligence 74 (1995) 249-310 refer to standard Kripke models as 2-Kripke consider also other forms of interpretations, interpretations. defined as follows. In this section we want to Definition 8.2 (S- 1 -Kripke model tion 4.3). that V(w) such interpretation). An S-l-Kripke is a Kripke for every world w E W (cf. Defini- interpretation is an S-l-interpretation Definition 8.3 (S-3-Kripke model such tion 4.1). that V(w) interpretation). An S-3-Kripke is a Kripke for every world w E W (cf. Defini- interpretation is an S-3-interpretation The evaluation of a propositional formula y in any world w E W of an S-l-Kripke interpretation M = (W, R, V) is defined as in Section 6; in particular we write M, w /=l to a MNNF y iff V(w) (y) = 1, that is V(w) maps y into 1. The value assigned by M formula formulae and recursively (Y in a world w E W is defined by using the rule for propositional the following rules: l M, w bl KP iff Vt E W wRt implies M, t bk /I; l M,w~~~KPiffEItEWwRtandM,t+~~p. that /3 may not be in MNNF, Notice equivalent. A modal interpretation M = (W R, V) and a w E W s.t. M, w bi CL and S-3-Kripke The definitions of S-3-Kripke (Y is S-l-Kripke satisjiable formula in this case we need to transform it in its MNNF iff there exists an S-1-Kripke are straight- forward. We refer to standard satisfiability of a modal formula as 2-Kripke satisJubility. interpretation satisfiability Some remarks are in order here to make clear the differences introduced in Section 6. Notice, the system in Section 6 is an extension of the classical modal two families of modal operators, in fact we have meta-descriptors of the entailment are dealing with a simple modal computational were mainly for approximate language. Furthermore, behavior of the problems of satisfiability in the expressiveness inference. interested relations first of all, that the language and the analogies with introduced language with one modal operator, and q L, which are used as i.e. 0: /=i and bi. Here, on the other hand, we is the in Section 6 we tool here our main concern testing, while of the language as a representational for negation This difference for negation formula, is S-3-Kripke the case that Cl& A 10; CY is unsatisfiable while Ka A 7Ka leads to two different semantic definitions let a be a propositional in the emphasis in front of modal operators. To be more concrete, is always satisfiable whenever LX A T(Y is S-3-satisfiable. This is an immediate two different definitions a world connected find an S-3-situation of the in fact here M, w /=i -KP holds iff we can find to w which makes p false, while M, w k 10; LY holds iff we can to w which does not make LY true, i.e. M, w 1 q $r. for S-3-Kripke in the sequel on uniform complexity would no longer formulae language would not be expressive satisfiability hold. On the other side, if we were to define satisfiability in Section 6 using enough We want to point out that, if we were to choose the second definition the rule used here, the resulting to be able to represent then the results proven of negated modal the approximate consequence entailment connected relations. it We now demonstrate our definitions by means of two examples. M. Scherf; M. Cadoli/Artifcial Intelligence 74 (1995) 249-310 289 Example 8.4 (Proving S-3-Kripke unsatisfiability). We show an alphabet L, a modal formula (+ on L and a subset S of L such that CT is S-3-Kripke unsatisfiable. Let L be {a, b, c}, S be {a, b} and u be (Ka A K( ya V b) A Klb A ~Kc). Let us assume that u is S-3-Kripke satisfiable. By the above definition this implies that there exists an S-3-Kripke-interpretation M = (u! R, V) and a w E W such that all the following conditions hold: l M,w+iKa; l M,w ki K(TaVb); l M,w +-‘, Klb; l M,w k”, -Kc. The above conditions are equivalent to the following ones: l ‘dt E W wRt implies M, t ki a; l Q’tE WwRtimpliesM,t l Vt E W wRt implies M, t ki Tb; l %WwRtandM,t+. bi(~aVb); Let to be the world whose existence is implied by the last condition, that is let to E W, wRto and V( to) ( TC) = 1. According to the other conditions, the truth assignment V( to) must satisfy the propositional formula (a A (-a V b) A lb). Taking into account that V( to) is an S-3-interpretation of L* and that S = {a, b}, V(to) satisfies (a A Tb) if and only if it maps a into 1, la into 0, b into 0 and Tb into 1. Therefore V( to) maps (la v 6) into 0, hence it does not satisfy (a A ( Ta V b) A yb) . This contradiction proves that u is S-3-Kripke unsatisfiable. Notice that a is S’-3Xripke satisfiable, where S’ = {a}. Example 8.5 (Proving S-l-Kripke satisjiability). We show an alphabet L, a modal for- mula 7 on L and a subset S of L such that 7 is S-l-Kripke satisfiable. Let L be {a, b}, S be {b} and 7 be (lb A Ka A K( la V b) > . By the above definition, 7 is S-1-Kripke satisfiable if and only if there exists an S-1-Kripke-interpretation M = (W R, V) and a w E W such that all the following conditions hold: . M,w &b; l ‘v”t E W wRt implies M, t ki a; l ‘v”tEWwRtimpliesM,t+~(~aVb). Let W be the singleton {w}, R be the empty set and the S-l-interpretation V(w) of L* be such that V(w) (a) = V(w)(ya) = V(w)(b) = 0 and V(w)(lb) = 1. It is easy to see that M, w +i 7 holds, where M = (W, R, V). Therefore 7 is S-l-Kripke satisfiable. We now show two straightforward consequences of the definitions of S-l and S-3- Kripke satisfiability (a is a MNNF formula). . For any S and S’ such that S c S’ C L, if (Y is S-l- Theorem 8.6 (Monotonicity) Kripke satisjiable, then LY is S’-l-Kripke satis$able (hence 2-Kripke satisjiable). More- over if (Y is S-3-Kripke unsatis$able, then cr is S’-3-Kripke unsarisjable (hence 2-Kripke unsatisjiable) . 290 M. SchaerJ M. Cudoli/Arti’ciul Intelligence 74 (1995) 249-310 Observation 8.7 (Convergence). such that a is S- 1 -Kripke satisfiable. If a is 2-Kripke unsatisfiable, S 2 L such that LY is S-3-Kripke unsatisfiable. If a is 2-Kripke satisfiable, then there exists an S C L then there exists an The above properties account for a stepwise procedure to that defined formula. As a consequence IY of Example 8.4 is 2-Kripke unsatisfiable bility of a modal formula, which is analogous 2-satisfiability of a propositional that the formula ample 8.5 is 2-Kripke systems, e.g. S5, in which such a stepwise procedure point of view. satisfiable. The following for deciding 2-Kripke satisfia- in Section 4 for checking of Theorem 8.6 we have r of Ex- and the formula theorem shows that there exist modal is interesting from a computational complexity Theorem 8.8 (Uniform relations which are re$exive, to decide if a is S- 1 -Kripke satisfiable and one to decide if LY is S-3-Kripke satisfiable both in 0( m . ICYI 21’1) time, where m is the number of occurrences of the modal running in ff. operator for S5). transitive and euclidean, then there exists one algorithm If we restrict our attention to accessibility The above theorem shows that all the considerations made in Section 6 on the approx- imation of the 2-satisfiability satisfiability of the 2-Kripke The same of a propositional of any formula of the modal system S5. formula also hold for the approximation idea can be applied, with only minor variations, problem, check formula to be an NP-complete satisfiability This holds since in these systems any satisfiable interpretation whose set of worlds W has size bounded by a polynomial size of the formula to other systems whose such as X45 and X34.5. is satisfied by a 2-Kripke function of the is known itself. On the other hand, as proved by the following result, such as K, in which the stepwise procedure there exist interesting modal suggested by Theorem 8.6 and 8.7 is not useful from a computational point of view. systems, Observation Theorem 8.9 (Non-uniform stricted, then deciding satisfiable are PSPACE-complete complexity if a is S- I-Kripke for K) . If the accessibility satisfiable and deciding relation is unre- if a is S-3-Kripke problems even if ISI = 1. This result prevents us from the development accessibility [52] for unrestricted Ladner has shown are satisfied only by 2-Kripke exponential in the nesting of the modal operators. relation of a result analogous (unless P=PSPACE). This is not surprising, to Theorem 8.8 since in the systems K, 7 and S4, which is having a set of worlds whose size interpretations that there exist formulae A possible way to overcome this problem interpretations. We now present a semantics the possible-worlds a formula LY in a world w iff LY is satisfied containing is a particular is to focus only on limited parts of the for approximation which further extends interpretation M should satisfy in the subset W’ C W of the possible worlds those worlds whose distance from w is less than or equal to i, where i In this way we can limit our attention semantics. The idea is that a Kripke to Kripke interpretations integer. only M. SchueG M. Cadoli/Art@cial Intelligence 74 (1995) 249-310 291 having O(2’) worlds. The worlds which are outside the “range” i are treated differently in the s-l- and in the S-3-case. In particular s-l-Kripke interpretations are “pessimistic”, since they do not validate anything in those worlds, while S-3-Kripke interpretations are “optimistic”, since they validate everything. Let (Y be a modal formula, n its modal depth, S a subset of L, i Q n + 1, and M = (w R, V) an S-3-Kripke interpretation. We define a new relation bi,i as follows ( y is a propositional formula) : l M,w+i,iyifandonlyif(V(w)(y)=lori<O); l M,w~~,ia.ApifandonlyifM,w~~,iaandM,w~:iP; l M,~+~,~aVpifandonlyifM,w~~,~cyorM,w~~~/3; l M, w +i,i Ka if and only if Vf E W wRt implies M, t ps,i_, a; l M, w +i,i 7Ka if and only if 3t E W wRt and M, t bi,i_, TX. Notice that according to the above definition, if i < 0 then any formula is true in any world. A modal formula LY is (s,i)-3-Kripke satisfiable iff there exists an S-3- interpretation M = (u! R, V) and a w E W s.t. M, w k$ a. A similar definition can be given for the relation ki,i. The only difference is that now M is an S-1-Kripke interpretation and the definition of the base case is: l M,w +i,i y if and only if (V(w)(y) = 1 and i > 0). Notice that if i < 0 then a formula cannot be true in a world. It is easy to show that the analogue of Theorem 8.6 holds for the new definitions, when we compare pairs (S, i) and (9, j) such that S G S’ C L and i < j < n + 1. In other words if a modal formula LY is (S,i)-3-Kripke unsatisfiable, then it is (S’,j)-3-Kripke unsatisfiable, and if it is (S,i)-l-Kripke satisfiable. Moreover, there exists a subset S of L and an integer i < n + 1 such that (Y is either (S, i)-l-satisfiable or (S, i)-3-unsatisfiable. satisfiable, then it is (S’,j)-1-Kripke We can also prove that there exists an algorithm for deciding if a modal formula LY is (,S, i)-3-Kripke satisfiable which runs in 0( 1~~1. 21sl.i) time, provided that the constraints of either K: or 7 or S4 hold on the accessibility relation. The algorithm for determining (S, i)-3-Kripke satisfiability of a modal formula (r is based on a mapping of cr into another modal formula I& (LX), in which the nesting of the modal operators is limited and any occurrence of a letter not in S is substituted by the literal t. More precisely, if i < 0 then I,& (cu) is t, otherwise ~~,i ( (Y) is obtained by: ( 1) substituting each occurrence of a letter in L \ S with the literal t, thus obtaining the formula a’; (2) substituting every subformula TKP of (Y’ which is in the scope of at least i modal operators K with the literal t. The relation between LY and t&(a) is the following: Theorem 8.10 (Semantics of rewriting). Let a be a modal formula and X be a modal system admitting the K schema and the rule of necessitation. 7’he formula LY is (S, i)- is 2-Kripke satisjiable in the system 3-Kripke satis$able in the system X iff I&((Y) X. 292 M. Schaet$ hf. Cudoli/Ari$citrl Intelligence 74 (1995) 249-310 Since the 2-Kripke satisfiability of I& (a) can be determined with standard algorithms run in time 0( ICX . 21sl.i)-we -which Kripke satisfiability. The algorithm a similar mapping $& in which the literal f is used instead of using have an effective procedure (S, i)-1-Kripke for checking t. to decide (S,i)-3- is based on satisfiability Theorem 8.10 allows us to extend all the considerations the 2-satisfiability satisfiability of a propositional formula to the approximation As for the strategy of any formula of the modal systems PC, 7 and S4. satisfiability of a formula for approximating on the approximation of of the 2-Kripke K, 7 or S4, we have to choose whether S. Given the accuracy of each world within Section 7.4 applies to this case as well. that the index i captures in the modal systems the set the complexity of the frame, while the set S captures at the end of i or to enlarge the discussion to increase the frame, the index presented All the results presented The results of this section have been published in this section will be proved in Appendix A.5. in a preliminary form in [ 121. 9. Conclusions, open problems and future research Approximation techniques are widely used in many areas of computer science to deal with polynomially in the non-numerical logical systems. intractable problems. problems of inference In this paper we dealt with approximations checking and satisfiability in a number of We started by analyzing two techniques for approximate reasoning the fundamental that have been aspects of in the literature by other authors. By comparing defined these two techniques we were able to give a list of desiderata method. The most and efficient computation precise answers, unique approach of approximate important aspects of the new method are: semantical for a new approximation description answers, possibility of having more and more for a variety of deduction problems. The new technique has been introduced in the framework of propositional extended including has been successively systems, duced an epistemic by an agent with limited computational our approximation two of the best-known fragments of first-order language formalism schema to inference and satisfiability logic and modal for the representation of approximate resources. Further results on the applicability to reasoning problems of default logic and circumscription, for nonmonotonic reasoning, have been presented in checking logic, and in other logical logic. Moreover we intro- knowledge, owned of ]141. These results complement the more classical approach to tractability, restriction. expressiveness In particular of polynomial approximation languages techniques is severely can be very useful whenever limited. that is language the the point of providing [ 32,381) (for example the approximate are more interested answer with a in preserving In our research we stressed clear semantics. Other authors the plausibility parameter very interesting approaches specifying of the mechanism “how much” as a model of human the user can trust an approximate from the practical point of view. In our research we pursued symbolic and we tried to specify such a degree of belief by means of an epistemic that a answer would be reasoning. We believe M. SchuerJ M. CadoWArtijicial Intelligence 74 (1995) 249-310 293 logic for non-omniscient agents (cf. Section 6). Anyway we don’t disregard in principle methods based on numerical approaches. There are a number of possible directions in which our research on approximate reasoning can be continued. We close our work by giving a list of topics that we consider particularly interesting for future research: Logical aspects l We would like to provide S-l- and S-3-entailment with a proof theory, for example with a Gentzen-style system. l We would like to give a sort of “interpolation theorem” for S-3- and S-l-entailment (cf. [ 50, Section 561) In such a way we expect to have a formalization of the gain of information that we have in the stepwise solution of the problem. Computational aspects l It would be interesting to study the computational complexity of optimization problems like: - Given a pair of propositional formulae T and y, find the size ISI of a minimal set S such that either T bi y or T Fi y holds. Find one such set S of minimal size. - Given a pair of propositional formulae T and y and the fact that both T pi y and T b: y for a fixed set of letters S $0, find the size 1 S’I of a minimal set S’ > S such that either T k’,, y or T &, y holds. Find one such set S’ of minimal size. Integration with other approximation techniques l We have briefly mentioned in Section 4 that our method has some similarities with the techniques used in the field of abstract interpretation. Our approach is more semantics-oriented, while abstract interpretation uses algebraic and syntactic methods. We believe that a more careful comparison of the relative advantages of the two methods can lead to further results. l We think that the idea of knowledge compilation (see [47,49,69] and Section 2) is particularly interesting, as this is a task that can be done off-line. We plan to investigate about the possibility to integrate knowledge compilation and on-line approximate reasoning. l Is there any relation between our definition of approximation and a definition of approximation based on numerical estimates? As an example, we know that T k y iff M(T) G M(y), where M( ) denotes the models of a propositional formula. Let us define a new form of approximate entailment as follows: consider the number Sdefinedastheratio(]M(T)]-]M(y)])/]M(T)].ClearlyO<6< iff S = 0. Intuitively we can say that an estimate of S gives an estimate of the validity of the relation T b y; in particular if we suspect that S is low, then we might be willing to accept that T + y holds. Is there any relation between 6 and S-3-, S-l-entailment? Notice that if we can relate a numerical parameter of this kind with the approximate inference, then we might have a heuristic “measure” of the reliability of intermediate answers. 1andTby 294 M. Schaerf; M. Cudoli/Artijicial Intelligence 74 (1995) 249-310 Use of meta-knowledge l In Section 6 we have presented some ideas on how an expressive language can be state properties of a knowledge base and help in the query issue and we believe in applicative language has to complexity of such a modal this is a very important as well as experiments investigation the computational In our opinion, further theoretical process. used to declaratively answering that it deserves domains. Moreover be investigated. l Extend the epistemic work. Such an extended several non-omniscient language agents for non-omniscient language would be able to formalize agents. to a multi-agent frame- the interaction between Approximation l Extend of other computational the work on approximation tasks to planning In this field, there is a need for efficient search problems). to be used in real-time imation of planning has already been done (see for example ) . We believe algorithms to planning problems by adopting a stepwise construction (which are in general inference mechanisms In the literature some interesting work on approx- literature on any-time applied that our framework can be successfully [ 23,39,65] of plans. problems systems. Acknowledgments We want referee for their useful suggestions which helped to thank Marta Cialdea, Francesco M. Donini, Torsten Schaub, Carolyn improving Talcott and an anonymous and the contents of the paper. Luigia Carlucci Aiello, Maurizio both the presentation read and commented previous versions of this Lenzerini paper. Marco Cadoli acknowledges John McCarthy and Carolyn Talcott for their hospi- tality at the Computer Science Department of the Stanford University, where part of this research has been developed. Furthermore, we are grateful to Bart Selman and Henry Kautz for clarifications and Andrea Schaerf carefully on their method. Appendix A. Proofs of theorems A.I. Appendix to Section 4 First of all we prove two lemmata that originally appeared in [56] without proof. The lemmata have already been referenced in Section 2.1. Lemma A.1 (Soundness of k3). ff T b” y holds, then T b y holds. Proof. Each 3-interpretation interpretations same holds for y. Hence also true in all the interpretations of T is also an interpretation satisfying T is a subset of the set of 3-interpretations of T. Therefore the set of satisfying T. The satisfying T, then it is if y is true in all the 3-interpretations satisfying T. 0 h4. Schuet$ M. Cadoli/Artifcial Intelligence 74 (1995) 249-310 295 Lemma A.2 (Polynomiality of k3>. T b3 y holds iff either a clause subsumed by y (i.e. such that all its literals also occur in y) occurs in T or a pair p, up of literals occurs in y. Therefore, determining ifT b3 y holds can be checked in O( ITJ . Iyl) time. Proof. Let L’ be the alphabet LU{jF I p E L}. Let T’ be the formula obtained from T by substituting each occurrence of a negative literal 1p with the corresponding letter F of L’. Let y’ be the clause obtained from y in the same way. Let T” be the formula obtained by conjoining T’ with all the clauses of the set {(p V j?) I p E L}. Let y” be the clause obtained from y’ in the same way. It is easy to notice that there is a l-l correspondence between the set of 3-interpretations of T and the set of interpretations of T”: in each 3-interpretation of T the unique constraint on the truth values of a pair of corresponding literals p, lp is that they cannot be both 0; moreover, in each interpretation of T” the unique constraint on the truth values of a pair of corresponding literals p,B is that they cannot be both 0. The same property holds for the set of 3-interpretations of y and the set of interpretations of y”. Therefore T b3 y holds iff T” b y” holds. Since negative literals do not occur either in T” or in y”, the last relation holds iff either a clause subsumed by y’ (i.e. such that all its literals also occur in y’) occurs in T’ or a pair p,p of literals occurs in y’. Therefore T k3 y holds iff either a clause subsumed by y occurs in T or a pair p, lp of literals occurs in y. This can be checked in 0( ITI . Iyl) time. 0 Theorem 4.4. For any S and S’ such that S C S’ & L, ifT bi y holds, then T bi, y (hence T b y). Moreover if T pf y holds and both a letter 1 of S’ \ S and its negation 4 do not occur in y, then T &, y holds (hence T p y). Proof. As far as b”, is concerned, the proof is the same as that of Lemma A.1. As for bi, we prove that T b=f y implies T ki y . Suppose that T +b, y holds and that there exists an S-l-interpretation M satisfying T but not satisfying y. We show that this leads to a contradiction. We build an S’-l-interpretation N of the alphabet L of T in the following way: l for each 1 E S, N maps 1 into 1 iff M maps 1 into 1; moreover it maps 11 into the opposite value; l for each 1 E S’ \ S such that 1 occurs in y, N maps 1 into 0 and 71 into 1; l for each 1 E S’ \ S such that 4 occurs in y, N maps 1 into 1 and 4 l for each remaining letter 1, N maps 1 and 71 into 0. into 0; Notice that N is an S/-l-interpretation of L, since it maps every letter 1 of S’ and its into opposite values and it maps each remaining literal into 0. Moreover, negation 4 it satisfies T, since M maps at least one literal per clause of T into 1, and the set of literals that N maps into 1 is a superset of the set of literals M maps into 1. It is easy to notice that N does not satisfy y. but this contradicts the hypothesis that T FL, y holds. 0 Theorem 4.6. There exists an algorithm for deciding if T ki y and deciding if T ki y which runs in 0( ITI . IyI .21sl) time. 296 M. Schaerj; M. Cadoii/Artificiul Intelligence 74 (1995) 249-310 Proof. As far as bi is concerned, forthcoming Theorem A.3 states that T ki y can be tested by performing 2isl tests of the kind T b3 6, where 6 has size proportional size of y. Using Lemma A.2, we obtain to the the desired upper bound for the complexity of 6. As for bi, Theorem 5.3 reduces T +L y to the problem of testing S-1-unsatisfiability in Section 5, S-1-satisfiability of TA& where 6 is a CNF formula with size proportional showed r 0( Irl letter occurs algorithm on the resulting of a formula each positive or negative constant in S with the propositional .21sl) by: ( I ) substituting formula. 0 false; to the size of y. As we already in time in NNF can be tested literal whose corresponding any satisfiability running (2) Theorem A.3 (From S-3-entailment to 3-entailment). Let S be the set {al,. . . , anI}. T ki y iffT yv is either ui or Tui. (Cl v... k=’ yV [(al A ~1) V c,,) holds for any combination v ] holds, or equivalently T k3 {cl,. . . , c,,}, where each Ci (1 6 i 6 m) . . v (a,, A lam) Proof. (Only if part) Suppose that T bi y holds and a set {cl,. . . , c,} exists where each ci ( I < i < m) this leads to a contradiction. is either a, or ~a,, such that T I3 cl V . . V c, holds. We show that If T F” cl V . does not satisfy cl V This implies S-3-interpretation, . V c,, holds, then a 3-interpretation M satisfying T exists such that T that M maps each literal ci (1 6 i < m) into 0. that it maps each literal 7Ci ( 1 < i 6 m) into 1. Therefore, M is also an V c,,. Notice but this contradicts the hypothesis that T k’, y. (If part) Suppose that both T /==’ (al A 7~1) V . V (a,, A -urn) and T ki y. We show that this leads to a contradiction. If T p:‘, y, then an S-3-interpretation M satisfying T and not satisfying y exists. We in the following way: for each i ( 1 < i 6 m), if M maps ai into that exactly one . . , c,}, where each ci (1 < build a set H of literals 0, then put ai in H; if M maps YUi into 0, then put TUi in H. Notice literal in {Ui, YUi} ( 1 < i < m) occurs in H. Let H be {cl,. i 6 m) is either ai or TUi. Since M is a 3-interpretation satisfying T, T F3 cl V. . . V c,, holds, but this contradicts 0 the hypothesis that T k3 (al A ~a1 ) V. . .V (a,, A xnl) holds. A.2. Appendix to Section 5 Lemma 5.2. Suppose letters(y) g S holds. Let S’ be the set S U letters(y). T bi y holds iff T ki, y holds. Proof. (Only ifpurt) (If part) Suppose both T pi See Theorem 4.4. to a contradiction. An S-3-interpretation M exists such that M satisfies T and it does not that M maps that M maps each literal of y into 0. This satisfy y. It follows y and T f=i, y. We will show that this leads implies hi. Schuerj M. Cadoli/Artifcial Intelligence 74 (1995) 249-310 291 each literal of my into 1, therefore M is also an S’-3_interpretation, but this contradicts the hypothesis that T bi, y holds. 0. Theorem 5.3. L.et y be ys V E, where both letters(ys) C S and letters(E) hold. T bi y holds iff T U (1~s) is not S-1-satisjable. f~ S = 0 PnBof. (Only ifpart) Suppose that Tu{-~ys} is S-l-satisfiable; let M be the S-l-interpretation satisfying it. M satisfies T, but it does not satisfy ys. Moreover, M does not satisfy rs because it maps all its literals into 0. Therefore T kf ys V rs holds. (If part) Suppose that T U (7~s) is not S-l-satisfiable and that T pi y holds. We show that this leads to a contradiction. An S-l-interpretation M exists such that M satisfies T and does not satisfy y. M maps each literal of y into 0. Since no literal of ys is in L \ S, M satisfies 1~s. Therefore M satisfies T U { ~ys}, but this contradicts the former hypothesis. 0 Theorem 5.4. Let letters(y) C S hold. T ki y holds i$?T U (7~) is not S-3-satisfiable. Proof. Analogous to that of Theorem 5.3 with y = ys. 0 Theorem 5.5. Let 6 be a set of literals such that letters(S) C S holds and both a letter 1 and its negation --J do not occur in 6; simplify(T, S) is S-1-satis$able iff T U S is S- 1 -satis$able. In addition, simplify( T, S) is S-3-satis$able iff T U 6 is S-3-satisfiable. Proof. (If part for both properties) Suppose that T U 6 is S-x-satisfiable (X = 1 or 3). Let M be an S-x-interpretation satisfying it. M maps each literal of 6 into 1. Since S C S holds, M maps the negation of each literal of S into 0. Therefore, given any clause p of T in which the negation of a literal of S occurs, M satisfies one of the remaining literals of p. Taking into account that the only clauses of simplify(T, 6) are subclauses of those in which the negation of a literal of S occurs, we can easily notice that M satisfies simplify( T, 8). (Only if part for both properties) Suppose that simplifr( T, 8) is S-x-satisfiable. Let M be an S-x-interpretation satisfying it. Notice that M satisfies every clause of T in which no literal of S occurs. Recall that no literal of S occurs in simplify( T, 6). We build an S-x-interpretation N according to the following rule: N maps any literal I of 6 into 1 and its negation 4 into 0; moreover, N is equivalent to M for any remaining literal. M satisfies every clause of T in which no literal of S occurs; therefore N satisfies the same clauses. Moreover, N satisfies all the literals in S and every clause of T in which at least one literal of S occurs. Therefore N satisfies T U 6. 0 Theorem 5.6. A formula T is S-3-satisfiable iff Tm is S-3-satisfiable iff 0 #- Tm. A formula T is S- 1-satis$able iff Tm is S-l-satisfiable iff T”’ = R Proof. We divide the proof into two parts, first of all we prove, at the same time, the 298 M. Schuerf; M. Cudoli/Artifcial Intelligence 74 (1995) 249-310 (rfpart T is S-3satisfiable and T is S-l-satisfiable iff T”’ is S-3-satisfiable In the last part we prove iff 0 6 T”’ and T”’ is S-l-satisfiable two equivalences: the other two equivalences: Tm is iff T”’ is S-l-satisfiable. S-3-satisfiable iff Tm = R. We prove the first part by induction on m. The base case is trivial since 7c = T, in the inductive case we have: I satisfying T’ (0 < i < m) assume that there this leads satisfied by I, so it must be the resolvent of two clauses pt = {dt, . . . ,dk,ai+l} Suppose into 1 at least one literal of any clause of T’. Let us that it would be and resolved upon ai+,. Since I satisfies pt and /32 for both properties) then I maps is one clause is not satisfied by I we show to T’ because that there is an S-x-interpretation /3 of T’+’ which to a contradiction. /? cannot belong This clause w ic h’ h lai+l} of T’ P2={flt...tfj9 but not /3 then it must be the case that I maps ai+t and lUi+t the hypothesis that Z is an S-x-interpretation. into 1, but this contradicts lu;+i Suppose to Z except (0 < i < m) ifpart for both properties) that there is an S-x-interpretation that it maps Ui+t into 1, notice to T’+’ because into 0, or in it occurs into 0. In the first case define a new S-x-interpretation Z satis- then Z maps into 1 at least one literal of any clause of T’+‘. that there is one clause pi of T’ which is not satisfied by Z we show that it would be (Only fying T’+’ Let us assume this leads to a contradiction. This clause pt cannot belong satisfied by I, so in it must occur ui+i and Z maps ai+t is and Z maps equivalent Z’ satisfies T’+’ because a;+, does not occur in it. If there is another clause p2 E T’ which is not satisfied by I’ then in /?2 must occur TUi+t and now we have that the resolvent of /?I and flz belongs We now show is not satisfied by I’ hence contradiction. iff 0 $ Tm and T” that T” iff that T”’ does not contain any of the letters of S, hence T”’ is S-3- iff it is 3-satisfiable, but any formula not containing 0 is 3-satisfiable because it. For the same reason, at least one clause into 0 and, therefore, T”’ = 0. Notice satisfiable the 3-interpretation mapping all the literals T”’ is S-l-satisfiable is l-unsatisfiable does not satisfy the l-interpretation maps all the literals , is S-3-satisfiable to T i+’ but this resolvent that this new interpretation but any formula containing because it. 0 iff it is l-satisfiable, into 1 will satisfy is S-l-satisfiable I’ which lui+i Theorem 5.7. A formula T is S-3-sutisjkble sutisjiuble; H is S-3-sutisykble an H E CP that is S-1-sutisJuble; H is S-I-sutisjuble ifs H = R iff 0 # H. A formula T is S-1-sutisfiuble iff there exists iff there exists a H E a” that is S-3- the is S-3-satisfiable iff there exists a H E @“’ that is S-l-satisfiable. iff there exists a H E @” that is S-3-satisfiable the proof into two parts, first of all we prove, at the same time, T is S-3-satisfiable Proof. We divide two equivalences: In the last part and T is S-l-satisfiable iff we prove that any H E P’ H = R. We prove the first part by induction on m. The base case is trivial since p = T, in the inductive case we have: for both properties) an H E @’ (0 < i < m) There are two formulae HI = simplifl( H, {ui+l}) occur the reverse; we show that in the first case Z satisfies HI, while that there is an S-x-interpretation Z satisfying into 1 at least one literal of any clause of H. and Hz = simplify( H, {YZ~+I}) which into 1 and TUi+t into 0 or in the second case Z in @+I. Since Z is an S-x-interpretation iff 0 @ H and it is H is S-l-satisfiable Suppose then Z maps it maps ai+i (,fpurt M. Schuerj M. Cadoli/Artijcial Intelligence 74 (1995) 249-310 299 satisfies Hz. We examine the first case, the other case is similar. We assume that there is a clause p in HI which is not satisfied by I and show that this leads to a contradiction. It is clear that Z3 does not belong to H, hence /3 has been obtained by pt = PU {lUi+l} where pt E H, but now we have that Z does not validate /?I because I maps into 0 all literals of p and also maps lai+l into 0, hence we obtain a contradiction. (Only ifpart for both properties) Suppose that there is an S-x-interpretation I satis- fying an HI E &’ (0 < i < m) then Z maps into 1 at least one literal of any clause of HI. Since in HI the literals ai+t and Tai+i do not occur then also the interpretation I’ which is equal to I, except that it maps these two literals into the opposite of the value of I, satisfies HI. We know that there exist an H E @ s.t. either H1 = simplify( H, {ai+l}) or HI = simplify(H, { lai+l}), we show that in the first case Z satisfies H while in the second case I’ satisfies H. We examine the first case, the other case is similar. We assume that there is a clause /3 in H which is not satisfied by Z and show that this leads to a contradiction. It is clear that /? has been eliminated in the simplifying process, because otherwise it would be satisfied by I. But the only reason why it may have been eliminated is because in it occurs ai+t and in this case p is satisfied by I, hence contradiction. The last part is immediately proven noticing that any H E CD”’ will not contain any literal of the set S, hence the result trivially follows from the proof of the last part of the Theorem 5.6. 0 Theorem 5.8. Let S be the set {al, . , . , a,,,}. T is S-3-unsatisfiable iff T k3 (al A la1 ) V . . . V (a, A w,,,) holds, or equivalently T k3 (cl V . . . V c,) holds for any combination {Cl,.. . , c,}, where each ci ( 1 < i < m) is either ai or 1~. Proof. See proof of Theorem A.3. 0 Theorem 5.9. Let S be the set {al, . . . , a,,,}. T is S-l-satisfiable iff there exists a set , c,}, where each ci ( 1 < i < m) is either ai or yai, such that simplify( T, (u) (Y={c,,... contains no clauses. Proof. (If part) Suppose that for a set cy = {cl,. . . , c,}, where each ci ( 1 < i < m) is either ai or Tai, such that simplify( T, a) does not contain any clause. We define an S-l-interpretation M according to the following rule: M maps every letter 1 of L \ S and its negation 71 into 0; M maps every letter Ui of L \ S into 1 iff ai occurs in a, otherwise it maps ai into 0; M maps lai into the opposite value. Taking into account that the process of simplification deletes all the clauses of T which contain a literal appearing in CY, we can easily notice that M maps at least one literal per clause of T into 1. Therefore M is an S-l-interpretation satisfying T. (Only if part) Suppose that T is S-l-satisfiable and let M be an S-l-interpretation satisfying it. We define a set of literals a according to the following rule: if M maps a letter ai of S into 1 then ai occurs in CY; if M maps a letter ai of S into 0 then Tai occurs in CY. Notice that (Y is the set {cl,. . . , c,}, where each ci ( 1 < i 6 m) is either ai or lai. Taking into account that M maps at least one literal per clause of T into 1, 300 M. Schaerj M. Cudoli/Arttj?cial Intelligence 74 (1995) 249-310 we can easily notice of simplification that simplifi( T, (Y) does not contain any clause, since the process deletes all the clauses of T which contain a literal occurring in a. 0 A.3. Appendix to Section 6 Theorem 6.1. (k 0: a --f q 3,y) iff ( q a A 10: y is unsatisjable) ifs (a /=i y) Proof. We prove the theorem by showing ( 1) (Ci~cz /\ ~0~ y is unsatisfiable) the following ( k I& implies three properties: -+ q iy); (2) (+ O&Y -+ q liy) (3) implies ((u /=l y) Proof of ( 1). Assume As a consequence we have: s F cl+ + q ;y. implies (cu bz y); (I& A ~0~ y is unsatisfiable). that C&r A 7 0: y is unsatisfiable and k Cl& + q iy holds. ( I ) zlM.EIs.M, (2) 3M.&.(M,s (3) 3M.3s.~(3t M,t (4) 3M.&.(Vt t= Y). M,t Fyr,. (5) 3M.&.M,s (6) 3M.3s.M, (7) F 7 0: a) and (M,s p 0;~). E S-3(Sit) sRt and M,t F a) and -(Vt E S-3(Sit) sRt implies E S-3(Sit) sRt implies M, t k a) and (3 E S-3(,%) sRt and + q $ s + 0;~ A 10; y. and M, s + 7 0:~. IJia A 7 0: y is satisfiable, hence contradiction. Proof of (2). Assume that (k 0; LY + 0;~) an S-3-interpretation R = ((s, s)} and V(s) = I. We have that M, s + a and M,s only situation M, s F q l$ + q iy, but this contradicts there exists I s.t. I /= Q and I /+ y. Let M = (Sit, R, V) where Sit = {s}, k y. Since s is the in Sit, we also have that M, s b q l$ and M, s /= 7 0: y. Therefore, the assumptions. and (CX pi y). Hence, that LY bi y holds and q l$ A 7 0; y is satisfiable. As a Proof of (3). Assume consequence we have: i’M.Els.M, lMEls.(M,s ( 1) (2) (3) 3M.!ls.(‘v’t E S-3(Sit) s /= O&X A 10; y. + q i$) and fM,s + -0:~). sRf implies M,t /= a) and (3t E S-3(Sit) sRt and ky). M,t (4) 3M.3s.3t t F y AM, (5) There exists an x s.t. x is an S-3-interpretation (6) LY pi y, hence contradiction. sRt and M, E S-3(Sit) 0 t b a). and x k (Y and x k y. Theorem 6.2. ( b O&x + 0:~) ifs ( O&z A 7 0: y is unsatisfiable) ifs (a +i y). Proof. Simply replace S-l for S-3 in the previous proof. 0 Theorem 6.3. Let S C S’ C: L. k O&Y + C]~,LY. Proof. Assume that i# q $r + q $LY. As a consequence we have: M. Schuerj M. CadoUArtijcial Inrelligence 74 (1995) 249-310 s F 0;~ + q $a. s b q ;a and M, s F q ;,CX 301 sRt implies M, t b a) and (3x E S’-3(Sit) sRx and (1) 3M.3s.M, (2) 3M.3s.M, (3) 3M.%.(Vt E S-3(Sit) pa). M,x (4) Since Y-3 (Sit) 2 S-3 (Sit), we have that 3x E S-3 (Sit) SRX and M, x k a. But for such an x we also have that M, x k a, hence contradiction. 0 A.4. Appendix to Section 7 Some of the proofs given in the following use the standard semantics of concept languages based on extension functions. Now we briefly recall this semantics (for more details see [ 683 ) . An interpretation Z = (A’, . ‘) consists of a set AZ (the domain) and a function -’ that maps every concept to a subset of A’ and every role to a subset of AZ x AZ such that T==A=, I’=@, (CrlD)==c’nD=, (-A)’ = A= \ A=, (VR.C)= = {a E A= 1 @.(a, b) E ti ---) b E CT}, (3R.C)= = {u E A= 1 3b.(a, b) E RZ A b E C”}. A concept C is satisfiable if and only if there exists an interpretation Z such that Cz is non empty. We say C is subsumed by D (C L D) if for every interpretation Z we have Cz G D’. In order to prove some of the results of the paper we need the following lemma. the Let C be an ALC concept and D one of its subconcepts, we denote with C( D/G) concept obtained by replacing every occurrence of D in C with the concept G. Lemma A.4 Let C be an ALC concept and D one of its subconcepts which is not in the scope of any 1 operators. Let G be another ALC concept. If D 5 G, then C (D/G) is satis$able if C is satisfiable. On the other hand, if G 5 D then C is satisfiable if C (D/G) is satisjable. hf. The proof is done by induction on the structure of C. In the base case we have that C = D, thus C(D/G) = G and D 5 G. Then satisfiability of C implies In the general case we have to show that all the language satisfiability of C (D/G). constructors except negation preserve this property. In particular D C G implies C’ n D C C’ n G, C’ U D 5: C’ U G, 3R.D C 3R.G, VR.D 5 VR.G. The proof is straightforward for all cases. A dual argument holds for the case of G C D. 0 302 M. Schaet$ M. Cadoli/Art@cial Intelligence 74 (1995) 249-310 Theorem 7.3. For each i (0 < i < n + I ) , if CjT is unsatis$able for all j > i, hence C is unsatisfiable. then C,? is unsatis$able For each i (0 < i < n + I), if CjL is satisfiable then C,A is satisjable for all j > i, hence C is satisfiable. from Lemma A.4. In one case we are replacing of C Proof. It follows with T and it is always even if dC& allows negation, we never replace subconcepts which are under the scope of -, operator so the proof of Lemma A.4 still holds. In the other case, in which we replace subconcepts subconcepts is subsumed by T. Furthermore, the other part of Lemma A.4 is used. 0 the case that a concept of C with I, Theorem 7.5. For all i (0 < i < rz + 1 ), C is Si-3-satisfiable iff Ci’ is satisfiable. Proof. Dealing with an S-3-interpretation M, when an atom a E Bt, \ S belongs both to M+ and to M-, we say that (Y is mapped into contradiction. (Only if part) Suppose that CT is satisfiable, be an Herbrand model of SNF(r(CiT)). i.e. that SNF(T(CT)) is satisfiable. We define an Si-3- Let M = (M+, M-) interpretation N = (N+ , N-) of SNF( r( C) ) according to the following rules: l for each atom cr E Si: CXEM+=+ClEN+; CYEM-==+atN-; l for each atom (Y E Bh \ Si: LY E Ni and LY E N- . Notice that N is necessarily an Si-3-interpretation is equal to Si. We now show that N is also an Si-3-model, that C is Si-3-satisfiable. Since SNF( r( C) > is an universally quantified of SNF( r( C) ), since the Herbrand thus formula, instances. We split the proof in two to show that N satisfies all its ground Base of SNF(T(CiT)) proving it is sufficient subcases: (1) All the variables of SNF( T( C)) are bound to terms belonging case for every instance g of SNF( r( C) ) there exists a corresponding of SNF( r( CiT> > , where the same variables are bound precisely, all the atoms of h belong to Si, and h is obtained some of its subformulae with T. All the atoms occurring are instantiated on terms of uk \ c/i, where k > i and uk is a stratum of the Herbrand Base of SNF( T( C ) ) . Therefore all these atoms belong to Sk \ Si, hence are mapped into contradiction by N. Since M k SNF( r( CiT) ), we know that M + h, hence N + h. Since g differs from h in some literals which are anyway mapped to Ui. In this instance h to the same terms. More from g by substituting in these subformulae into contradiction by N, it follows that N + g. (2) At least one variable of SNF( T(C)) By definition of N, we know mapped by N to contradiction. Since is equal instance obtained to Ui, some of SNF( r(CiT) from g by binding any variable not bound instances g of SNF( r( C)) do not have a corresponding an instance g’ of SNF( r(CiT)) to terms belonging ). Let us consider to Vi to is bound that all the atoms to a term not belonging instantiated to (Ii. to those terms are the Herbrand Universe of SNF(r(CiT)) M. Schuerf; M. CadoWArtifcial Intelligence 74 (1995) 249-310 303 terms of Vi in an arbitrary way. From the previous item we know that N + g’. Remember all the atoms instantiated to terms not belonging to Ui are mapped into contru&ction by N. Therefore g differs from g’ in some literals which are mapped into contradiction by N, hence it follows that N j= g. (If part) Suppose that C is Si-3-satisfiable, i.e. that SNF( r( C) ) is Si-3-satisfiable. Let N = (N+ , N- ) be an S-3 Herbrand model of SNF( r( C) ) . We define an Herbrand interpretation M = (M+, h4-) of SNF(r(CiT)) according to the following rule. For each atom (Y E Si: Notice that M is necessarily an Herbrand interpretation of SNF( r( CiT) ), since the is equal to Si. We now show that M is also an Her- Herbrand Base of SNF(I’(CiT)) brand model, thus proving that CiT is satisfiable. Since SNF(r(CT)) is an universally quantified formula, it is sufficient to show that M satisfies all its ground instances g. Let h be any instance of SNF( r( C) ) which corresponds to g, where the same variables are we know that N b h. Moreover h bound to the same terms. Since N k SNF(T(C)), is obtained from g by substituting each occurrence of T with a formula. Since T occurs always positively in g and is satisfied by M, it follows that M + g. 0 Theorem 7.6. For all i (0 < i 6 n + 1 ), C is Si-1-satisjable iff Ci’ is satisjiable. Proof. Dealing with an S-l-interpretation M, when an atom (Y E Bh \ S belongs neither to M+ nor to M-, we say that CY is mapped into undejned. (Only if part) Suppose that CF is satisfiable, i.e. that SNF(T(CF)) Let M = (M+,M-) interpretation N = (N+ , N-j of SNF( r( C) ) according to the following rules: be an Herbrand model of SNF(T(Ck)). is satisfiable. We define an Si-l- l for each atom LY E Si: is equal to Si. We now show that N is also l foreachatomaEBh\Si:cr#N’andcu$N-. Notice that N is necessarily an Si- l-interpretation of SNF( r( C) ), since the Herbrand an Si-l-model, Base of SNF(T(CF)) thus proving that C is Si-l-satisfiable. Since SNF( r( C)) is an universally quantified formula, it is sufficient to show that N satisfies all its ground instances. We recall that, by definition of S-1-satisfiability, we have only to consider ground instances of SNF( r( C) ) in which variables are substituted by terms of the set Terms( Si), which are the terms occurring in the set Si, i.e. are the terms of Vi, Therefore we know that all the variables of SNF( r( C) ) are bound to terms belonging to Ui. This implies that for every instance where the g of SNF( T(C)) same variables are bound to the same terms. More precisely, all the atoms of h belong to Si, and h is obtained from g by substituting some of its subformulae with 1. Since M b SNF( I’( C,‘)), we know that M b h, hence N b h. Notice that J_ is not satisfied there exists a corresponding instance h of SNF(r(C,‘)), 304 M. SchuerJ M. Cudoli/ArtiJicial lnielligence 74 (I 995) 249-310 by N, therefore N k g even satisfied. Since if the subformulae this is the “worst” case, it follows that C is &-l-satisfiable, Suppose (Ifparr) that N b g. i.e. that SNF( T(C)) in which g differs from h are not is $-l-satisfiable. Let N = (N+, N-) be an Si-1 Herbrand model of SNF(T(C)). according interpretation M = (M+, M-) each atom (Y E Si: of SNF( r(C,‘)) We define an Herbrand rule. For to the following since Notice formula, interpretation thus showing of SNF( r(C,‘-)), an Herbrand is equal that Ci’- is satisfiable. Since SNF(T(Cj’)) the to Si. We now show that M is also an Her- that M is necessarily Herbrand Base of SNF( P(C,‘)) brand model, quantified it is sufficient h be any instance of SNF( r( C) ) which corresponds bound is obtained occurring a stratum of the Herbrand Base of SNF( r( C)). Therefore all these atoms belong Sk \ S,, hence are mapped is an universally instances g. Let to g, where the same variables are to the same terms. Since N k SNF( r( C)), we know that N k h. Moreover h each occurrence of I with a formula. All the atoms on terms of uk \ u;, where k > i and uk is to that into undefined by N. Since M maps _L into 0, it follows to show that M satisfies all its ground in this formula are instantiated from g by substituting Mkg.0 Theorem 7.7. Let P be a subset of A and i be an index such that 0 < i 6 n + 1. If Cp’i then any subconcept D of C such that CA. 3 D is unsatisfiable. If C$. is unsatisjiable, is satisfiable, then any subconcept D of C such that C~i 3 D is satisfiable. Proof. The same proof of Theorem 7.3 applies also in this case. In fact, we only allow negation that are in the scope of the 7 operator. 0 in front of primitive concepts. Hence, we never replace subconcepts Theorem 7.9. For all i (0 < i < n + I) and P c A the concept C is Sei-3-satisfiable iff C& is satisfiable. to that of Theorem 7.5 with the additional complication some of the primitive concepts and their negation with T. This is however taken into account when we define the Herbrand Base Bh of a simplified concept in CA and, even in this Proof. The proof is very similar of replacing already C&. In fact, Bh will only contain atoms of concepts appearing case, is equal to S,i. Hence, the same proof of Theorem 7.5 applies. 0 Theorem 7.10. For all i (0 < i < n + 1) and P C A the concept C is Sci-I-satisJi&le iff C~i is satisfiable. Proof. The proof is very similar the ones done in the proof of Theorem 7.9 hold. 0 to that of Theorem 7.6 since similar considerations to M. SchaerJ; M. Cadoli/Artifcial Intelligence 74 (1995) 249-310 305 A.5. Appendix to Section 8 Theorem 8.6. For any S and S’ such that S & St C L, if a is S-l-Kripke satisfiable, then a is S’-l-Kripke satisfiable (hence 2-Kripke satisfiable). Moreover if a is S-3-Kripke unsatisfiable, then a is S’-3-Kripke unsatisfiable (hence 2-Kripke unsatisfiable). Proof. Let a be S’-3-Kripke satisfiable and M = (W R, V) one of its S’-3-Kripke models. M is an S-3- is also an S-3-Kripke model, since, for each w E W, V(w) interpretation. Let LY be S-1-Kripke satisfiable and M = (W, R, V) one of its S-1-Kripke models. We build an S’-1-Kripke interpretation N = (W, R, V’) in the following way: for each w E W l for each 1 E S, V’(w) maps 1 into 1 iff V(w) maps 1 into 1; moreover it maps 4 into the opposite value; l for each 1 E S’ \ S, V’(w) maps 1 into 1 and 11 into 0; l for each remaining letter 1, V’(w) maps 1 and 71 into 0. Notice that for each w, V’(w) is an S’-l-interpretation of L, since it maps every letter 1 of S’ and its negation 71 into opposite values and it maps each remaining literal into 0. Therefore N is an S’-1-Kripke interpretation. Theorem 4.4 (applied when y is the empty clause) shows that for any propositional formula T and any S, S’ such that S 2 S’, if T is S-l-satisfiable, then T is S’-l-satisfiable. Therefore in each w E W the set of propositional formulae satisfied by V’ is a superset of the set of propositional formulae satisfied by V, hence N is an S’-l-Kripke model of a. 0 Theorem 8.8. If we restrict our attention to accessibility relations which are reflexive, transitive and euclidean, then there exists one algorithm to decide if a is S-l-Kripke satisfiable and one to decide if a is S-3-Kripke satisfiable both running in O(m. Ial .21sI> time, where m is the number of occurrences of the modal operator in a. Proof. The algorithms for checking S-l- and S-3-Kripke satisfiability are based on a mapping 7r from any modal formula (Y on the alphabet L into a propositional formula ~(a) onthealphabetr(L) The alphabet n-(L) that is it contains m + 1 copies of suchthat\~(L)j=(m+l).ILIandI?r(a)l is defined as UE!’ UPELpi, < (m+l>.laj. is defined as UET1 UpESpi. The each letter of L. If S is a subset of L, then r(S) mapping 7r( (u) is defined by the following rewriting rules, where CY, cyt , cyp are modal formulae, and p is in L: (al Aa2,i) H (al,i) A (a2,i), (w Va2,i) +-+ (w,i) V t&2,9, (+a~ Aaz),i) H (-xl,i) V (la2,i), H Va2),i) (-al,9 I-+ (a, 1) A +..A (a,m + l), (4~ (Ka,i) (+cr,i)++(7~,1)V...V(7~,m+l), A C-2,8, 306 M. Schaerf; M. Cadoli/Art$cial Intelligence 74 (1995) 249-310 (P, i> H P’, (lp, i) t-9 lpi. of the propositional satisfiability of the modal formula It is easy to prove that the 9I-Kripke to the S’-1-satisfiability the mapping 7~ is based on a generalization if /? is a 2-Kripke there exists a 2-Kripke and where the size of W is less than m + I (see [52, Lemma 6.11). In fact that then interpretation M = (W R, V) and a w E W such that M, w k p of a property of the system S5, stating of the modal operator, formula 7r( cr), where S’ = r(S). formula with m occurrences (Y is equivalent satisfiable The S’-I-satisfiability of T((Y) can be determined in O(m . [al . 21’1) time with the algorithms presented of Q. 0 satisfiability in Appendix A.1. Analogous properties hold for the S-3-Kripke Theorem 8.9. If the accessibility satisjiable and deciding even if ISI = 1. relation is unrestricted, satisfiable are PSPACE-complete then deciding if a is S-I -Kripke problems if cy is S-3-Kripke in [67] Proof. It is proven mapped proven even if only one primitive concept of the K: system that satisfiability in [68] in a concept of the language d13C such that satisfiability is preserved. It is that any formula of the K system can be polynomially of an ACC concept is used. As a consequence, is a PSPACE-complete problem, satisfiability of a formula in which only one propositional letter occur is PSPACE-complete. 0 Theorem 8.10. Let (Y be a modal formula and X be a modal system admitting satisfiable schema and the rule of necessitation. The formula LY is (S, i)-3-Kripke system X iff &(a) is 2-Kripke satisjable in the system X. the K in the Proof. (only if part) Assume that LY is (S, i)-3-Kripke satisfiable. Hence, there exists (over a model a. Let Ml = (WI, RI, VI) be a new model RI = R, F (x) = V(x) = V( lx) interpretation. the alphabet L) M = (W R, V) and a world w E W s.t. M, w bi,i the alphabet S) where WI = W, is a 2-Kripke (over if x E S. Notice and V, (lx) that MI We prove that M 1, w + t,b& (a) by a double induction on i and the size of LY. When i is smaller than 0 I&( cu) = t and, therefore, Ml, w k I& (a). If (Y = p or LY = lp it is clearly the case that MI, w + +&(cz>. If (Y = cut A (V)a;! then MI, w + @&(a) iff MI,W +$i,i(at) b=&,,(~2). If LY = KP, then it is the case that Vt.wRt and (or) MI,W implies M, t ki,i_, /?. By the inductive hypothesis, M, t ki,j_l /3 implies M 1, t + &, (/?), hence ‘dt.wRt implies M 1, t k I+$_, (j3). Therefore, we also have that MI, w k Kt&_, (/I). Since it is easy to show that $&(a) = K@j,i_t (P), we also have MI,W + J&((Y). A similar proof also applies (If part) Assume that J&((U) to cy = 7Kp. is satisfiable. Hence, alphabet S, MI = (WI, Rl,K) and a world w E W1 s.t. M,w there exists a model, over the Let M = b #&(a). M. Schaerf M. Cadoli/ArtijCcial Intelligence 74 (1995) 249-310 307 (W, R, V) be a new model over the alphabet L, where W = WI, R = RI, V(x) = VI(X) and V( TX) = L$ (lx) is an S-3-Kripke interpretation. if x E S and V(x) = V( TX) = 1 if x E L \ S. Notice that M We prove that M, w +i,i a by a double induction on i and the size of (Y. When i is smaller than 0, M, w kzi a holds by definition. If cr = p or cy = 1p it is clearly the casethatM,w~~,icu.IfCY=al~(V)(Y2thenM,~~~,i*iffM,w~~,i”* and(or) M, w +‘s,i (~2. If (Y = K/l, then it is the case that Vt.wRt implies Ml, t k S~,i_l (p). By the inductive hypothesis, MI, t + ~~,i_1 (p) M, t +&_, p. Therefore, we also have that M, w & implies M, t k?&, p, hence Vt.wRt implies Kp which in turn implies that M, w +z a. A similar proof also applies to CY = -K/l. 0 References [ 1 ] H. Ait-Kaci and R. Nasr, Login: a logic programming language with built-in inheritance, J. Logic Program. 3 (1986) 185-215. [2] A. Anderson and N. Belnap, Entailment: the Logic of Relevance and Necessity (Princeton University Press, Princeton, NJ, 1975). (31 C. Beeri, Data models and languages for databases, in: Proceedings International Conference on Database Theory (ICDT-88) (1988) 19-40. [4] A. Borgida R.J. Brachman, D.L. McGuinness and L.A. Resnick, CLASSIC: a structural data model for objects, in: Proceedings ACM SIGMOD International Conference on the Management of Data (1989) 58-67. [5] R.J. Brachman, “Reducing” CLASSIC to practice: knowledge representation theory meets reality, in: Proceedings Third International Conference on the Principles of Knowledge Representation and Reasoning (KR-92). Cambridge, MA (1992)247-258. [ 61 R.J. Brachman and H.J. Levesque, A fundamental tradeoff in knowledge representation and reasoning, in: R.J. Brachman and H.J. Levesque, eds., Readings in Knowledge Representation (Morgan Kaufmann, San Mateo, CA, 1985) 41-70. [7] R.J. Bra&man and J. Schmolze, An overview of the KL-ONE knowledge representation system, Cogn. Sci. 9 (1985) 171-216. [ 81 T. Bylander, The monotonic abduction problem: A functional characterization on the edge of tractability, in: Proceedings Second International Conference on the Principles of Knowledge Representation and Reasoning (KR-9I), Cambridge, MA (1991) 70-77. [9] M. Cadoli, Semantical and computational aspects of Horn approximations, in: Proceedings IJCAI-93, Chambery, France (1993) 39-44. [lo] M. Cadoli and M. Lenzerhri, The complexity of ptopositionalclosed world reasoning and circumscription, J. Comput. Syst. Sci. 48 (1994) 255-310. [ 1 l] M. Cadoli and M. Schaerf, Approximate entailment, in: Trends in Artificial Intelligence: Proceedings 2nd Conference of the Italian Association for Arttficial Intelligence (AI*IA-91) , Lecture Notes In Artificial Intelligence 549 ( Springer-Verlag, Berlin, 1991) 68-77. [ 121 M. Cadoli and M. Schaerf, Approximate reasoning and non-omniscient agents, in: Proceedings Fourth Conference on Theoretical Aspects of Reasoning about Knowledge (TARK-92) (1992) 169-183. [ 131 M. Cadoli and M. Schaerf, Approximation in concept description languages, in: B. Nebel, C. Rich and W. Swartout, eds., Proceedings Third International Conference on the Principles of Knowledge Representation and Reasoning (KR-92) (1992) 330-341. 308 M. Schaetf; M. Cadoli/Artificial Intelligence 74 (1995) 249-310 [ 141 M. Cadoli and M. Schaerf, Approximate Informaticae (to appear); Preliminary Infelligence (ECAI-92), Vienna, Austria (1992) 319-323. [ 15 ] M. Cadoli and M. Schaerf, The complexity of entailment inference version in default Fund, in: Proceedings Tenth European Conference on Artificial and circumscription, reasoning Mathematics and Artificial Intelligence (to appear); preliminary Symposium Series Workshop on Al and NP-hard problems ( 1993) 15-2 I. version in propositional multivalued logics, Annals of in: Proceedings AAAI Spring [ I6 I B. Chellas, Modal Logic: An Introduction (Cambridge University Press, Cambridge, England, 1980). [ 17 1 S.A. Cook, The complexity of theorem-proving in: Proceedings Third ACM Symposium on procedures, Theory of Computing, New York (1971) 151-158. I 18 1 P. Cousot and R. Cousot, Abstract interpretation: by construction Programming Languages (POPL-77), LAX Angeles, CA ( 1977) 238-252. or approximation of fixpoints, a unified lattice model for static analysis of programs in: Proceedings Fourth ACM Symposium on Principles of [ 19 I J.M. Crawford and B.J. Kuipers, Towards a theory of access in: Proceedings First International Conference on the Principles of Knowledge Representation and Reasoning (KR-89), Toronto, Ont. ( 1989) 67-78. reasoning, limited 1201 M. Dalal, Tractable instances of some hard deduction problems, in: Proceedings Tenth European Conference on Arfiftcial fnfelligence (ECAI-92), Vienna, Austria ( 1992) 354-358. [ 211 M. Dalal and D.W. Etherington, A hierarchy of tractable satisftability problems, Inf Process, Len. 44 (1992) 173-180. [ 22 I M. Davis and H. Putnam, A computing procedure 123 1 T. Dean and M. Boddy, An analysis of time-dependent for quantification planning, theory, J. ACM 7 ( 1960) 201-215. in: Proceedings AAAI-88, St. Paul, MN ( 1988) 49-54. 1241 R. Dechter and J. Pearl, Network-based heuristics for constraint-satisfaction problems, Artif Intell. 34 (1988) l-38. 125 1 FM. Donini, B. Hollunder, M. Lenzerini, A. Marchetti Spaccamela, D. Nardi and W. Nutt, The complexity of existential quantification in concept languages, Artif: fntell. 53 ( 1992) 309-327. [ 26 1 FM. Donini, M. Lenzerini, D. Nardi and W. Nutt, The complexity of concept in: Proceedings Second International Conference on the Princtples of Knowledge Representation and Reasoning (KR- 9/). Cambridge, MA (Morgan Kaufmann, San Mateo, CA, 1991) 1.51-162. languages, [ 27 1 EM. Donini, M. Lenzerini, D. Nardi and W. Nutt, Tractable concept ( 1991) 458-463. 91, Sydney, Australia languages, in: Proceedings IJCAI- I28 1 W.P. Dowling and J.H. Gallier, Linear-time algorithms for testing the satisfiability of propositional Horn formulae, J. Logic Program. 1 ( 1984) 267-284. [ 29 ] B. Dreben and W.D. Goldfarb, The Decision Problem. Solvable Classes of Quuntificational Formulas (Addison-Wesley, Reading, MA, 1979). [ 301 M. Dunn, Intuitive semantics for first-degree entailments and ‘coupled trees’, Philos. Stud. 29 ( 1976) 149-168. [ 3 I 1 T. Eiter and G. Gottlob, The complexity of logic-based abduction, in: Proceedings fOth Symposium on Theoretical Aspects of Computer Science, Lecture Notes Berlin, 1993). in Computer Science 665 (Springer-Verlag. [ 321 D.V. Etherington and International Workshop on Nonmonotonic Etherington J.M. Crawford, ( 1992). Towards efficient default the 4th (1992); Notes edited by H. Kautz and D.W. reasoning, Presented at Reasoning I33 1 R. Fagin and J.Y. Halpem, Belief, awareness and limited reasoning, Artif: Infell. 34 ( 1988) 39-76. 1341 R. Fagin, J.Y. Halpem and M.Y. Vardi, A nonstandard problem, in: Proceedings Third Conference on Theoretical Aspects of Reasoning about Knowledge (TARK-90), Pacific Grove, CA (1990) 41-55. [ 35 1 A.M. Frisch, Using model theory in: Proceedings IJCAI-85, Los Angeles, CA to the logical omniscience to specify Al programs, approach (1985) 148-154. [ 361 A.M. Frisch, Inference without chaining, [ 37 1 G. Gallo and M.G. Scutella, Polynomially in: Proceedings IJCAI-87. Milan, Italy ( 1987) 5 15-5 19. solvable satisfiability problems, bf Process. Lett. 29 (1988) 221-227. 138 I M.L. Ginsberg, Anytime declarativism, Tech. Rept., Stanford University, Depatment of Computer Science, Stanford, CA ( 199 I ). M. Schaerf; M Cadoli/Artijcial Inrelligence 74 (1995) 249-310 309 [39] M.L. Ginsberg, Computational considerations International Conference on rhe Principles of Knowledge Representation and Reasoning Cambridge, MA (1991) 250-261. in reasoning about action, in: Proceedings Second (KR-91), [40] E Giunchiglia and T. Walsh, A theory of abstraction, Artif: Intell. 57 (1992) 323-389. [41] R. Greiner and D. Schuurmans, Learning useful Horn approximations, In~ernarional Conference on the Principles of Knowledge Representation and Reasoning Cambridge, MA (1992) 383-392. in: Proceedings Third (KR-92), [42] J.Y. Halpem, Reasoning about knowledge: a survey circa 1991, in: A.A. Kent and J.G. Williams, eds., Encyclopedia of Computer Science and Technology (Marcel Dekker, New York, 199 1) [43] J. Hintikka, Knowledge and Belief (Cornell University Press, Ithaca, NY, 1962). [44] T. Imielinski, Domain abstraction and limited reasoning, in: Proceedings IJCAI-87, Milan, Italy (1987) 997-1003. [45] D. Israel, The role of logic in knowledge representation, IEEE Cornpurer 16 (1983) 37-42. [46] R.G. Jeroslow and J. Wang, Solving propositional satisfiability problems, Ann. Math. Arr$ Intell. 1 (1990) 167-187. [47] H.A. Kautz and B. Selman, A general framework for knowledge compilation, in: H. Richter and M. Richter, eds., Proceedings of International Workshop on Processing Declarative Knowledge (PDK- 91) , Lecture Notes in Artificial Intelligence 567 (Springer Verlag, Berlin, 1991) 287-300. [48] H.A. Kautz and B. Selman, Hard problems for simple default logics, Artif: Inrell. 49 (1991) 243-279. [49] H.A. Kautz and B. Selman, Forming concepts for fast inference, in: Proceedings AAAI-92, San Jose, CA (1992) 786-793. [ 501 S.C. Kleene, Mathematical Logic (Wiley, New York, 1966). [51] S.A. Kripke, Semantical considerations on modal logic, Acra Philos. Fenn. 16 ( 1963) 83-94. [52] R. Ladner, The computational complexity of provability in systems of modal propositional logic, SIAM J. Computing 6 (1977) 467-480. [53] G. Lakemeyer, Tractable meta-reasoning in propositional logics of belief, in: Proceedings NCAI-87, Milan, Italy (1987) 402-408. [ 541 H.J. Levesque, A logic of implicit and explicit belief, in: Proceedings AAAI-84, Austin, TX (1984) 198-202. [ 551 H.J. Levesque, Logic and the complexity of reasoning, J. Philos. Logic 17 (1988) 355-389. [ 561 H.J. Levesque, A knowledge-level account of abduction, in: Proceedings IJCAI-89, Detroit, MI ( 1989) 1061-1067. [ 571 D. Loveland, Automated Theorem Proving: A Logical Basis (North-Holland, Amsterdam, 1978). [58] R.M. MacGregor, Inside the LOOM desscription classifier, SIGART Bull. 2 (1991) 88-92. [ 591 B. Nebel, Terminological reasoning is inherently intractable, Arri$ Inrell. 43 ( 1990) 235-249. [60] N.J. Nilsson, Logic and artificial intelligence, Artif: Inrell. 47 (1991) 31-56. [ 611 P.F. Patel-Schneider, A four-valued semantics for terminological logic, Artif: Intell. 38 ( 1989) 3 19-35 1. [62] PF. Patel-Schneider. A decidable first-order logic for knowledge representation, J. Automated Reason. 6 (1990) 361-388. [63] J.A. Robinson, A machine oriented logic based on the resolution principle, J. ACM 12 (1965) 397-415. [ 641 H. Rogers, Theory of Recursive Functions and Eficfive Computability (McGraw-Hill, New York, 1967). IJCAI-91, Sydney, [65] S.J. Russell and S. Zilberstein, Composing real-time systems, in: Proceedings Australia (1991) 212-217. [ 661 T. Schaefer, The complexity of satisfiability problems, in: Proceedings IOrh ACM Symposium on Theory of Computing (1978) 216-226. [ 671 K. Schild, A correspondence theory for terminological logics: preliminary report, in: Proceedings IJCAI- 92, Sydney, Australia ( 1991) 466-471. [68] M. Schmidt-Schaul3 and G. Smolka, Attributive concept descriptions with complements, Arrij Inrell. 48 (1) (1991) l-26. [ 691 B. Selman and H.A. Kautz, Knowledge compilation using Horn approximations, in: Proceedings AAAI- 91, Anaheim, CA (1991). [70] B. Selman and H.J. Levesque, The tractability of path-based inheritance, in: Proceedings IJCAI-89, Detroit, MI (1989). 310 M. Schaerl; M. Cudoli/Artijicial Intelligence 74 (1995) 249-310 [ 71 1 J. Stillman, default logics, in: Proceedings AAAI-90, Boston, MA ( 1990) It’s not my default: The complexity of membership problems in restricted propositional [ 72 1 A. Van Gelder, A satisliability tester for non-clausal propositional calculus, Inf: Compuf. 79( 1) ( 1988) 1-21. [ 731 M.Y. Vardi, Querying logical databases, J. Compur. Sysf. Sci. 33 ( 1986) 142-160. 