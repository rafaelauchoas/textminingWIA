Artificial Intelligence 175 (2011) 346–377Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintFormalising the Fisherman’s Folly puzzlePedro Cabalar a,∗, Paulo E. Santos ba Dept. Computación, University of Corunna, Spainb AI and Automation Group (IAAA), Centro Universitário da FEI, São Paulo, Brazila r t i c l ei n f oa b s t r a c tArticle history:Available online 3 April 2010Keywords:Common sense reasoningQualitative spatial reasoningReasoning about actions and changeThis paper investigates the challenging problem of encoding the common sense knowledgeinvolved in the manipulation of spatial objects from a reasoning about actions and changeperspective. In particular, we propose a formal solution to a puzzle composed of non-trivialobjects (such as holes and strings) assuming a version of the Situation Calculus writtenover first-order Equilibrium Logic, whose models generalise the stable model semantics.© 2010 Elsevier B.V. All rights reserved.1. IntroductionReal life situations where we must deal with strings tying objects and passing through holes appear from time to timein very different contexts. Examples range from tying shoelaces, to handling ropes in a sailboat or organising the cableconnections map inside an office, a building or a whole city. Although humans show an amazing intuition for solvingproblems of this nature, a formal representation for reasoning about holes and strings is still a relatively unexplored area.To understand the complexity of this problem, note for instance that using a fully detailed mathematical model of theinvolved objects (assuming them as rigid) does not seem feasible for computational purposes, let alone when we considerdeformable objects like a string. Moreover, humans typically describe solutions to spatial reasoning problems in terms ofqualitative descriptions instead. This is, in fact, the orientation followed by Qualitative Spatial Reasoning (QSR) [1–3], a fieldthat attempts the logical formalisation of spatial knowledge based on primitive relations defined over elementary spatialentities. In general QSR approaches, however, lack a formal treatment of actions and change (apart from a few exceptions[4,5]). The formal treatment of actions are of central interest to the Reasoning about Actions and Change (RAC) community[6,7]. In this work we formalise a spatial domain from the perspective of RAC, aiming to provide a step in the directionof a rigorous treatment of reasoning about actions, change and qualitative space. This work falls within the logic-basedknowledge representation subfield of Artificial Intelligence [8,9], whose main goals are: the logical formalisation of reasoningprocesses capable of inferring knowledge from representations of the world; the construction of a medium for pragmaticallyefficient computation, in which the formal representation provides the means to organise domain knowledge allowing forefficient (and consistent) queries, updates and revisions of the knowledge base; or the rigorous treatment of ontologicalcommitments, which provide the base rules that guide reasoning about the world (for instance, what should or should notbe considered as the effects of actions, to which extent should ramifications of these effects be considered, how to assumethe persistence of objects through time and so on) [10]. In particular the problem of correctly inferring the effects (andnon-effects) of actions has received much attention by the AI community under the heading of the Frame Problem.In a nut-shell, the challenge of solving the Frame Problem is to find a compact representation of the non-effects ofactions, such that the complexity of the representation is at the order of the number of actions in the domain, and notof the number of domain elements times actions. Much solutions to this problem were related to the development of* Corresponding author.E-mail addresses: cabalar@udc.es (P. Cabalar), psantos@fei.edu.br (P.E. Santos).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.04.004P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377347non-monotonic reasoning formalisms [11] and the definition of a law of inertia, which states that actions do not changeproperties of a domain unless explicitly written [12]. Attempts to solve the Frame Problem stumbled on the existence ofmultiple possible models for sound domain representations, some of which were counter-intuitive as exemplified by theso-called Yale Shooting problem [13]. In this work we tackle the formalisation of a spatial scenario within a logic that hasbuilt into it an elegant solution to the Frame Problem as one of its ontological commitments, as exemplified in the simplesolution to the Yale Shooting scenario presented in Section 4.To obtain a suitable representation of spatial domains containing strings and holes we have adopted the followingmethodology. We begin from specific formalisations of particular scenarios, what usually implies a more abstract and simpli-fied description level, and advance then towards more general representations to cover different domains, what necessarilyimplies a more fine-grained ontology. As a starting point, puzzle-like examples constitute a good test bed, as they offer asmall number of objects while keeping enough complexity for a challenging problem of knowledge representation. Thus,puzzles involving physical objects are our drosophila,1 i.e. our base line from which we develop AI research.In this paper, we take as a starting point the work developed in [16], which presented an automated solution to theclassical puzzle called Fisherman’s Folly introduced below. The approach taken in [16], however, falls short on the formaltreatment of fluents, actions and the problematics surrounding these concepts (such as inertia). The present paper tacklesthese issues by presenting a formalisation of the Fisherman’s Folly puzzle into an Equilibrium Logic version of the SituationCalculus (SC). Here Situation Calculus [17,6] provides the syntactical tools to formalise the domain and Equilibrium Logic[18], a suitable semantics to the problem, which identifies its minimal models by means that resemble circumscription [19,20]. We shall deal with these concepts in more details below.In this context, the original contributions of the present work include the following:• a novel formalisation of the Situation Calculus in Equilibrium Logic. The main advantage of this formalisation over thetraditional classic logic SC is the first-order encoding of predicate extension minimisation providing a rigorous solutionto the frame problem (which in classic logic is accomplished by a fragment of the second-order calculus);• the first logical formalisation of a scenario composed of a string and rigid objects (hosting holes or not). This formalisa-tion allows the representation of string segments, as well as their creation (and annihilation), depending on the actionevoked. It is worth mentioning that the necessity to handle fragments of objects in this way brings a new challenge toKnowledge Representation formalisms;• in this paper we define a notion of connectivity as a fluent within an action formalism (the fluent linked in Section 5.1),an issue that has not been considered before in the field of Qualitative Spatial Reasoning.1.1. The Fisherman’s Folly puzzleThe elements of the Fisherman’s Folly puzzle are a holed post (Post) fixed to a wooden base (Base), a string (Str), a ring(Ring), a pair of spheres (Sphere1, Sphere2) and a pair of disks (Disk1, Disk2). The spheres can be moved along the string,whereas the disks are fixed at each string endpoint. The string passes through the post’s hole in a way that one sphere andone disk remain on each side of the post. It is worth pointing out that the spheres are larger than the post’s hole, thereforethe string cannot be separated from the post without cutting either the post, or the string, or destroying one of the spheres.The disks and the ring, in contrast, can pass through the post’s hole.In the initial state (shown in Fig. 1(a)) the post is in the middle of the ring, which in its turn is supported on the post’sbase. The goal of this puzzle is to find a sequence of (non-destructive) transformations that, when applied on the domainobjects, frees the ring from the other objects, regardless their final configuration. Fig. 1(b) shows one possible goal state.A crucial observation is that the puzzle actually deals with four holes: the post hole, the ring hole and the two sphereholes. Note that in a natural language description we would probably identify holes with their host objects, saying that “thestring passes through the sphere” (hole) or that “the post passes through the ring” (hole). Furthermore, we would talk about“sliding the ring up the post,” rather than “moving the post down through the ring hole”.We argue that the complexity imposed by the (possibly infinite) states of the string allied to the necessity of handlingvoid space (holes) makes spatial puzzles such as Fisherman’s Folly rich benchmark domains to be tackled from the CommonSense Knowledge Representation standpoint [21,8]. Moreover, besides the fact that this problem involves both Reasoningabout Actions and Change and Qualitative Spatial Reasoning about objects (that are ubiquitous in various everyday domains),there are a number of versions of puzzles involving strings and holes.2 Making use of these analogous puzzles we cancheck whether the representation and reasoning methods developed for one puzzle could be applied to other of its variants, thusverifying the elaboration tolerance [22] of our formalisation.In this paper we show that the same formalism developed to solve the Fisherman’s Folly puzzle solves other puzzles:the Rope Ladder puzzle – Fig. 2 (whose solution is presented in Section 7) and the Tricky Dick puzzle (cf. Appendix C). Theway the proposed formalism could be easily applied on distinct domains suggests that the proposed solution is tolerant toelaborations. However, we make no claim that the work developed here can solve any problem involving strings, holes and1 Following the metaphor used in [14] and [15].2 E.g. http://www.puzzlethis.co.uk/products_mad_cow.htm (last accessed in 12/10/2009).348P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Fig. 1. The Fisherman’s Folly puzzle.Fig. 2. The Rope Ladder puzzle in its initial state.rigid objects. For instance, the formalism is not capable of representing the case of a number of rings interlocking (such asin the symbol of the Olympic games), puzzles where string loops (or knots) are relevant to the solution, and so forth.At this point it is worth mentioning some previous work on dealing (separately) with holes and strings from a formalstandpoint. Reasoning about holes and holed objects have been discussed in detail in [23] and [24], whereby a formalontology for these entities, based on their topological aspects, is developed. In the present work we assume holes as sharingthe same level of existence as rigid objects, i.e., they are reified individuals that can be involved in actions. In the presentpaper we are mostly interested in how these entities could be engaged in actions, leaving aside some aspects of their preciseontology. A fine grained spatial ontology of the Fisherman’s Folly (following the guidelines proposed in [23]) is presented in[25].The problem of incorporating knowledge about strings and string manipulation has been tackled in [26,27] where arobotic system capable of learning to tie a knot from visual observation is proposed – this system is called the Knot Planningfrom Observation (KPO) paradigm. In KPO each state of a string is represented by a matrix encoding its segments, which aredefined by the portion of the string that lies in between its endpoints and points where it crosses over itself. Actions onflexible objects in this context were defined as an extension of the Reidemeister moves in knot theory [28]. This representa-tion is suitable for the identification of string states from a computer vision system; however, it falls short in the context ofproblem solving, which is the main purpose of the present paper. In contrast to the work proposed in [26], we do not takeinto account knots in this paper. Incorporating some of the ideas of the KPO paradigm in our work shall be investigated inthe future. Nonetheless, research on knot planning and reasoning about strings and holes are some of the issues that thegrowing community of robot assisted needle steering are interested about [29].This paper is organised as follows: Section 2 presents an early solution to the puzzle in order to provide the intuitionsbehind the present development; Section 3 introduces Equilibrium Logic; Situation Calculus theories written in EquilibriumLogic are developed in Section 4, while Section 5 presents the formalisation of Fisherman’s Folly in this version of SituationCalculus. The correctness of the developed formalism is discussed in Section 6; Section 7 presents a formal solution of amore complex version of the Fisherman’s Folly puzzle and Section 8 concludes this paper. Appendices A, B and C present,P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377349Fig. 3. Schematic representation of the initial state.respectively, the Prolog code of the planner developed following the guide lines presented in the paper, the proofs of thispaper’s propositions and a formal solution of a third puzzle.2. A simple automated solution to the Fisherman’s Folly puzzleThe formalisation of Fisherman’s Folly presented in this paper is based on a simple automated solution of the puzzleproposed in [16], briefly presented in this section to provide the intuitions behind this work.The simple solution presented in [16] relies on distinguishing the puzzle’s objects into three sorts: holes (which includesthe post hole, the ring hole and the holes through the spheres), long objects (that includes the string and the post), andregular objects (including all the remainder objects). For each hole h, its faces are distinguished: h; and for eachlong object l its tips lare defined.and hand l−−++The domain objects are represented by the following constants: Disk1, Disk2 (for the left and right disks), Base (repre-senting the square base), Ring, Sphere1, Sphere2, PostH (representing the holed objects), and Str and Post, for the so calledlong objects: the string and the non-holed part of the post (as shall be discussed further on the paper).For helping the reader to figure out a puzzle state, we use schematic representations like the one in Fig. 3, which showsthe initial state. Arrows correspond to segments of long objects, defined between pairs of hole crossings, or between a holeof a same long object l. Ellipses represent holescrossing and a tip. These arrows point in the direction from tip land boxes are linked regular objects. The positive face of a hole implicitly corresponds to the “visible” side of the ellipse.to tip l−+Central to this simple solution is the definition of a list data structure named chain( X). This data structure repre-sents the sequence of all hole crossings on a long object X , when traversing X from its negative tip to its positive+] andone. For instance, the state shown in Fig. 3 is represented by the following two chains: chain(Post) = [Ring+]. The former represents that the long object Post crosses the ring hole and thechain(Str) = [Sphere1latter states that the string crosses the hole on the sphere 1, the post hole and the hole on the sphere 2, respectively. Notethat, for brevity, only the outgoing hole faces are shown, following the direction negative to positive tip.+, Sphere2+, PostHAn action pass was defined3 to represent the movements of puzzle objects. The effects of pass either add or delete ahole crossing from the chain on which it is applied.Using these definitions, a solution to the Fisherman’s Folly puzzle can be represented by the sequence of chains shownin Fig. 4, whereby each state is identified by its sequence number plus the pair of lists chain(Post) and chain(Str) in thisorder. Note that State 5 has actually reached the goal since, at this point, the ring hole Ring does not occur in any list, i.e.,it is not crossed by any long object.In [16] we also present an iterative deepening planning system that manipulates chains in order to find a solution to thepuzzle.This early approach, however, completely overlooks any formal aspects of the domain or the system. This lack of formalityimplies on a number of drawbacks. First, there was no possibility of proving the correctness of the automated solutionsobtained, since we did not have available the mathematical tools to analyse the system. Second, there was no properontology of the domain, the simple chain definition did not allow any such formal definition. Amongst the definitions wewould like our theory to capture are the spatial properties of objects as three-dimensional regions (including holes). Besidesspatial properties, a formalisation of a spatial puzzle should have a rigorous treatment of actions and change, including theindirect effects of actions, the definition of non-executable actions and the efficient representation of actions’ non-effects(issues that are virtually impossible to address given the early list-based representation). In contrast, the present paperproposes a rigorous logical account for the Fisherman’s Folly puzzle, from which its solution can follow as a logical proof.3 In [16] two actions were defined, one representing the movement of rigid objects and another the movement of holed objects. As we will see later, inthe current paper these two actions will be replaced by a single one for passing a bundle of elements through a hole. Fig. 4 actually shows the solution interms of this new representation.350P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Fig. 4. A formal solution for the Fisherman’s puzzle and its graphical representation.Moreover, the relational nature of the formalism allows for the definition of the spatial extent of objects (some of which aredefined and used in this paper, as we shall see). On top of all, the theory proposed is defined on a well-known reasoningabout actions and change formalism, which carries built into it a complete account of the problematics surrounding rigorousdefinitions of dynamic domains.3. First-order equilibrium logicThere exist several alternatives for incorporating non-monotonicity in a formalism for Reasoning about Actions andChange (RAC). One possibility is using Predicate Circumscription [19], so that, we define a set of auxiliary predicates4and then minimise their extent using a particular circumscription policy – that is, deciding which predicates are fixed, min-imised or freely varied; deciding which parts of the theory are circumscribed and which parts are not, etc. These decisionshave proved to be a non-trivial task. In fact, it can be said that the area of RAC has evolved by a continuous proposal, andlater solution, of motivating examples showing counterintuitive results from an inadequate circumscription or minimisationpolicy.5Another possibility for formalising action domains that has recently gained some popularity is the use of Logic Program-ming (LP) as an underlying logical devise, and in particular, the methodology proposed in [35] that relies on the StableModels semantics [36]. The advantages of LP are that: (1) default negation provides a natural way for representing defaultsand, in particular, the inertia law for solving the frame problem; and (2) unlike classical material implication, programrules provide a directional behaviour very convenient for representing causal effects and, in particular, for avoiding theramification and qualification problems in a straightforward way.Traditionally, there has not been much work in combining Situation Calculus with LP under stable models semantics(as a pair of exceptions [37,38]). Perhaps the main reason for this was the need to resort to a ground theory, i.e., stablemodels was essentially a propositional formalism. This limitation, however, has drastically changed in the last years, thanks4 Many of them have been used in the literature, like Clipped [30], Abnormal [13,31], Occluded [32], Causes [33], Affects [7], etc.5 Consider, for instance, the minimal abnormality policy in the Yale Shooting Problem [13] or in the Ramification Problem as in [34], the chronologicalminimisation in the Stanford Murder Mystery [31], etc.P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377351to the logical characterisation of stable models in terms of Equilibrium Logic [39] and, in particular, to its extension to first-order theories, Quantified Equilibrium Logic (QEL) [40]. As a result of this characterisation, the concept of stable model isnow defined for any theory of predicate calculus with equality. In fact, stable models can be alternatively described by asecond-order logic operator [41] similar to Circumscription.In this section we proceed to introduce the main definitions of QEL. For a better understanding, it is crucial to bear inmind its intuitive connection to logic programming. In what follows, when talking about logic programs, we adopt a logicalsyntax notation, replacing the usual ‘←’, ‘,’ and ‘not ’ operators respectively by implication, conjunction and negation. In thisway, for instance, a typical logic program rule like:p(X) ← r(X, Y ), not q(Y )would just be written as the formula R(x, y) ∧ ¬Q (x) → P (x) where all variables are implicitly universally quantified. Thisinterpretation is extensible to Equilibrium Logic, where operator ‘¬’ can be informally understood as default negation.Let L = (cid:6)C, F , P (cid:7) be a first-order language where C is a set of constants, F a set of functions and P a set of predicates.First-order formulae for L are built up in the usual way, with the same syntax of classical predicate calculus. As in In-tuitionistic Calculus, the formula ¬ϕ will actually stand for ϕ → ⊥. We write Atoms(C, P ) to stand for the set of atomicsentences built with predicates in P and constants in C . Similarly, Terms(C, F ) denote the set of ground terms built fromfunctions in F and constants in C . From now on, a formula with free variables is implicitly assumed to be preceded by theiruniversal quantifications.The definition of Equilibrium Logic has two steps: we start first from a (monotonic) intermediate logic and then define amodel selection criterion on this logic.We recall the definition introduced in [18] of the logic of quantified here-and-there with static domain, decidable equalityand Herbrand structures, referring to it as the logic of here and there (HT) for short.The HT logic is an intermediate logic. It can be defined in terms of the Intuitionistic Calculus plus axioms:(cid:2)(cid:3)¬β ∨ (α → β)(cid:2)α ∨∀x ¬¬α(x) → ∃x¬¬∃x α(x) → ∃x ¬¬α(x)∀x∀ y (x = y ∨ x (cid:12)= y)(cid:3)α(x) → ∀x α(x)(DE)where the abbreviation x (cid:12)= y stands for ¬(x = y). In particular, (DE) is the axiom for decidable equality and states that theequality predicate behaves in a “classical” way, satisfying the law of the excluded middle.The corresponding semantics for HT is described as follows.Definition 1 (HT-interpretation). An HT interpretation for a language L = (cid:6)C, F , P (cid:7) is a tuple (cid:6)(D, σ ), H, T (cid:7) where:1. D is a non-empty set of constant names identifying each element in the interpretation universe. For simplicity, we takethe same name for the constant and the universe element.2. σ : Terms(D ∪ C, F ) → D assigns a constant in D to any term built with functions in F and constants in the extendedset of constants C ∪ D. It must satisfy: σ (d) = d for all d ∈ D.3. H and T are sets of ground atomic sentences such that H ⊆ T ⊆ Atoms(D, P ).Satisfaction of formulae is recursively defined as follows. Given an interpretation M = (cid:6)(D, σ ), H, T (cid:7), the followingstatements are true:• M |(cid:16) p(t1, . . . , tn) if p(σ (t1), . . . , σ (tn)) ∈ H .• M |(cid:16) t1 = t2 if σ (t1) = σ (t2).• M (cid:12)|(cid:16) ⊥.• M |(cid:16) α ∧ β if M |(cid:16) α and M |(cid:16) β. Disjunction ∨ is analogous.• M |(cid:16) α → β if both:(i) M (cid:12)|(cid:16) α or M |(cid:16) β and(ii) (cid:6)(D, σ ), T (cid:7) |(cid:16) α → β in classical logic.• M |(cid:16) ∀x α(x) if for each d ∈ D, M |(cid:16) α(d) and (cid:6)(D, σ ), T (cid:7) |(cid:16) α(d).• M |(cid:16) ∃x α(x) if for some d ∈ D, M |(cid:16) α(d).We say that M is a model of a theory Γ if M satisfies all the formulae in Γ .An interpretation like (cid:6)(D, σ ), T , T (cid:7) is said to be total and, moreover, may be seen as a classical interpretation (cid:6)(D, σ ), T (cid:7).In fact, it is easy to check that:Proposition 1. (cid:6)(D, σ ), T , T (cid:7) |(cid:16) Γ iff (cid:6)(D, σ ), T (cid:7) |(cid:16) Γ in classical logic.352P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Non-monotonic entailment is obtained by introducing a model-minimisation criterion. Let us define the following order-ing relation among interpretations.Definition 2. We say that an interpretation M = (cid:6)(D, σ ), H, T (cid:7) is smaller than an interpretation M(cid:17) = (cid:6)(D, σ ), Hten M (cid:2) M(cid:17), when H ⊆ H.(cid:17)(cid:17), T (cid:7), writ-That is, to be comparable, M and M(cid:17)must only differ in their H component, so that M (cid:2) M(cid:17)iff H ⊆ H(cid:17). As usual, wewrite M < M(cid:17)when M (cid:2) M(cid:17)and M (cid:12)= M(cid:17)(that is H ⊂ H(cid:17)).The next definition introduces the idea of minimal models for the HT logic.Definition 3 (Equilibrium model). A total model M of a theory Γ is an equilibrium model if there is no smaller modelM(cid:17) < M of Γ .Note that an equilibrium model is total, i.e., it has the form M = (cid:6)(D, σ ), T , T (cid:7) and can be seen as a classical interpre-tation M = (cid:6)(D, σ ), T (cid:7). We name Quantified Equilibrium Logic (QEL) the logic induced by equilibrium models.A Herbrand HT-interpretation (cid:6)(D, id), H, T (cid:7) is such that D = Terms(C, F ) and σ = id, where id is the identity relation. Inthe rest of the paper, we implicitly assume that we handle Herbrand HT models and Herbrand equilibrium models.As usual, a literal is an atom p(t) or its negation ¬p(t). A logic program is a conjunction of implications α → β where α(the body) is a conjunction of literals, β (the head) is a disjunction of literals, and all variables are universally quantified.Proposition 2. (From [18].) M = (cid:6)(D, σ ), T , T (cid:7) is a Herbrand equilibrium model of a logic program Π iff T is a stable model of the(possibly infinite) ground program gr D (Π) obtained by replacing all variables by all terms in D in all possible ways.Although QEL is defined for any arbitrary first-order theory, we will use in most cases a fragment of QEL that fits into thesyntactic class of logic program rules. Furthermore, the rest of the formulae we use that do not belong to this class can betranslated into LP, although their direct QEL representation is much more compact or readable and requires fewer auxiliarypredicates. When specifying these translations we will say that two theories Γ1, Γ2 are strongly equivalent with respect toa signature L, written Γ1 ≡Ls Γ2 iff for any theory Γ in that signature, the sets of equilibrium models of Γ1 ∪ Γ and Γ2 ∪ Γ ,when restricted to signature L, coincide. The idea of strong equivalence is that it guarantees replacing Γ1 by Γ2 and viceversa, regardless of the context Γ . In [18] it was shown that checking regular equivalence in the logic of Quantified Hereand There is a necessary and sufficient condition for Γ1 ≡Ls Γ2, provided that Γ1 and Γ2 also belong to the signature L.Proposition 3. ϕ → ψ ∧ γ is HT-equivalent to (ϕ → ψ) ∧ (ϕ → γ ).This proposition states that we can “compress” two program rules like ϕ → ψ and ϕ → γ into a formula ϕ → ψ ∧ γwith a conjunction in the consequent.Proposition 4. ¬ϕ is the formula ϕ → ⊥ by definition.In fact, this is the definition of ¬ as a derived operator. It asserts that a negated formula ¬ϕ can be understood orreplaced by a constraint with ϕ in its body.Proposition 5. ϕ → x = y is HT-equivalent to ϕ ∧ x (cid:12)= y → ⊥.This proposition is saying that a rule with an equality in the head can be understood as a constraint (a rule with ⊥head) where the negation of x = y has been moved to the antecedent.Proposition 6. Let Γ1 be a theory consisting of the single formulaα(x) ∧ ¬∃y β(x, y) → γ (x)(1)for language L, being x a tuple with all the variables that occur free in the antecedent or in the consequent. Then Γ1 ≡Lis the pair of formulae:s Γ2 where Γ2α(x) ∧ ¬aux(x) → γ (x),α(x) ∧ β(x, y) → aux(x)and aux(x) is a fresh auxiliary predicate not included in L.(2)(3)P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377353In other words, this proposition6 asserts that we can handle the negation of an existentially quantified formula in a rulebody by introducing a new auxiliary predicate. For example, the formula:(cid:2)Person(x) ∧ ¬(∃ y)(cid:3)Person( y) ∧ Parent(x, y)→ Orphan(x)is strongly equivalent to:Person(x) ∧ ¬aux(x) → Orphan(x)Person(x) ∧ Person( y) ∧ Parent(x, y) → aux(x)where aux(x) is taking the intuitive meaning “x has some parent.”The next section develops Situation Calculus in Quantified Equilibrium Logic.4. Situation Calculus theories in equilibrium logicWe introduce next a version of the Situation Calculus which essentially maintains its standard syntax [17,6], but replacesPredicate Calculus by Quantified Equilibrium Logic as the underlying logical framework. Our formalisation will be multi-sorted. We define a finite set of action names Action plus a finite set of fluent names Fluent. A situation is defined inthe usual way, that is, it can be the constant S0 (the initial situation) or a term like do(a, s) where a is an action and s asituation in its turn. We will use variables a, afor the sort Situation and f , ffor the sort Action, s, sfor Fluent.(cid:17)(cid:17)(cid:17)Notice that, as we deal with Herbrand models, axioms for unique names assumption are not needed. However, we doinclude Domain Closure axioms for all sorted variables. For instance, for any variable a ranging on sort Action we have:(cid:5)(cid:4)a = A1(x1)(∃x1)(cid:5)(cid:4)a = An(xn)∨ · · · ∨ (∃xn),(DC)where the Ai are all the action names included in Action and each xi is a tuple of variables whose cardinality is the arityof Ai . Analogous axioms are included for the Fluent sort.All fluents will be functional, that is, each f (x) has a unique value v among a range of possible values we denoterange( f ). The predicate Holds( f (x), v, s) represents that the fluent f (x) is assigned a value v ∈ range( f ) at a situation s.f will also be considered as functional with range( f ) =In order to keep an homogeneous notation, a Boolean fluentBoolean = {True, False}. As we will see later, this will be especially convenient7 for specifying the inertia default.Since the fluent stands for a function, it will have a unique value:(cid:2)Holdsf (x), v, s(cid:3)(cid:2)∧ Holds(cid:3)f (x), v(cid:17), s→ v = v(cid:17).(UV)Although in Situation Calculus we can always build formulae with any situation term, we will be usually interestedin describing some situations that are unfeasible, as some of their occurring actions cannot be executed. This is typicallyaccomplished by a predicate Poss(a, s) to point out when an action a is possible in a situation s. This predicate is used inso-called unfeasibility axioms, intuitively describing conditions under which Poss(a, s) is false, and in effect axioms, wherePoss(a, s) is used in the antecedent of an implication, acting as one more condition for the causal rule to be applied. Notethat this predicate should be true by default, that is, we only want to specify when an action cannot be executed, ratherthan explicitly stating all the cases in which the action can be performed. However, as in Equilibrium Logic all predicatesare false by default, we use here the predicate Imposs(a, s) stating the exact opposite, that is, performing the action a isimpossible at the situation s.A fluent may have a designated default value default( f ) = d, d ∈ range( f ). In order to establish the effect of this defaultvalue, we further divide the sort Fluent into two disjoint subsets: Inert (inertial fluents) and NonInert (non-inertialfluents or events). For any non-inertial fluent, f ∈ NonInert with default( f ) = d, we include the axiom:(cid:4)¬(∃v)(cid:2)v (cid:12)= d ∧ Holdsf (x), v, s(cid:3)(cid:5)(cid:2)→ Holds(cid:3)f (x), d, s(DV)that intuitively captures the meaning of its default value for any situation s. In the case of inertial fluents, however, thedefault fluent value will be its value in a previous situation (this is the inertia assumption):(cid:2)∧ ¬Released(cid:3)(cid:5)f (x), s(cid:2)¬Imposs(a, s) ∧ Holds(cid:4)∧ ¬(∃w)f (x), v, s(cid:2)w (cid:12)= v ∧ Holds.(INE)(cid:3)f (x), v, do(a, s)(cid:2)→ Holdsf (x), w, do(a, s)(cid:3)(cid:3)In other words, when an action execution is possible, ¬Imposs(a, s), if a fluent f (x) had value v in the previous situations and there is no evidence that the fluent has a different value w in the next situation do(a, s) then the fluent value vremains unchanged in do(a, s). The additional condition ¬Released( f (x), s) is included so that, when convenient, we can6 See the recent works [42] and [43] for a detailed description on this technique of removing existential quantifiers from the rule bodies.7 Most logic programming formalisations of inertia for boolean fluents make use of a second negation called strong or explicit. In this sense, an atomlike Holds( f (x), False, s) can be seen as the strong negation of f (x) at situation s. The advantage of our representation is that the inertia axiom is the samefor Boolean and non-Boolean fluents.354P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Fig. 5. State transition system for the Yale Shooting scenario.“release” a given inertial fluent f (x) from following the inertia default at a particular situation s. Predicate Released will beparticularly useful for forcing a fluent f (x) to become undefined (that is, it has no associated value), something we willrepresent with the negation of the following derived predicate:(cid:2)(cid:3)Definedf (x), s↔ (∃v)Holds(cid:2)(cid:3)f (x), v, s.(4)As we can see, Axiom (INE) does not establish any default assumption for the fluent value at the initial situation S 0. Theis inertial and has some default( f ) = dfluent default value, when provided, is used for that case. In other words, when fwe include the following version of (DV):(cid:3)(cid:5)(cid:3)(cid:4)¬(∃v)(cid:2)v (cid:12)= d ∧ Holdsf (x), v, S0(cid:2)→ Holdsf (x), d, S0.(DV0)For a compact description of a fluent, we use the notation8 f : D → R = d where D is the fluent domain, R the rangeand ‘= d’ is an optional specification of a default value default( f ) = d.We write ESC (for Equilibrium Situation Calculus) to denote this multi-sorted version of QEL including the set of axiomsseen before in this section: (DC), (UV), (DV), (INE) and (DV0).Since our spatial theory will deal with a relatively complex representation, it may be convenient to consider first a clas-sical actions’ scenario: the Yale Shooting Scenario [13], for a better understanding of notation and semantics. It is worthpointing out that the solution of this scenario in ESC shows how the semantics of Equilibrium Logic, together with the Situ-ation Calculus, solves the Frame Problem in a rigorous way. This solution is inherited by our formalisation of the Fisherman’sFolly puzzle, developed below.Example 1. Consider the classical Yale Shooting Scenario [13] where we have a gun that must be previously loaded in orderto shoot and kill a turkey. Initially the gun is not loaded and the turkey alive. We load the gun, wait one situation, and thenshoot.The formalisation of Example 1 would include the sorts Action = {load, wait, shoot} and Inert = {loaded, alive}, withboth fluents of range Boolean and no default value. The theory YALE would consist of ESC plus the formulae:Holds(loaded, True, s) → Imposs(load, s),Holds(loaded, False, s) → Imposs(shoot, s),(cid:2)(cid:17) = do(load, s) → Holds¬Imposs(load, s) ∧ s(cid:2)(cid:17) = do(shoot, s) → Holds¬Imposs(shoot, s) ∧ sHolds(loaded, False, S0) ∧ Holds(alive, True, S0).(cid:3)(cid:17)loaded, True, salive, False, s,(cid:3)(cid:17)(cid:2)∧ Holdsloaded, False, s(cid:3)(cid:17),(5)(6)(7)(8)(9)Proposition 7. Theory YALE has a unique equilibrium model whose atoms for Holds corresponds to the state transition system in Fig. 5.Proof. See Appendix B. (cid:2)As a result, the following is a QEL consequence of YALE:(cid:3)(cid:3)(cid:3)(cid:2)(cid:2)alive, False, doshoot, dowait, do(load, S0)(cid:2)Holds(it suffices to check it in Fig. 5).Having ESC at our disposal, next section formalises the Fisherman’s Folly puzzle in Equilibrium Situation Calculus.8 The current formalisation for functional fluents with default values has been adapted from [44].P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–3773555. Formalising the puzzleIn [16] the puzzle entities were classified into three different sorts: regular objects, holes (actually, single-holed objects)and long objects that will be respectively named as Regular, Hole and Long. In the Fisherman’s Folly domain, these sortsrespectively consist of:Regular = {Disk1, Disk2, Base},Hole = {Ring, Sphere1, Sphere2, PostH},Long = {Str, Post}.and(10)Notice that, for notational simplicity, we identify a hole, like the ring hole, with its host object, like Ring. The wholeset of physical objects is simply denoted as Object def= Regular ∪ Hole ∪ Long. We will also handle additional derivedsorts. The sort of sets of long objects Longset def= 2Long will be used to specify when a given object can pass through ahole currently crossed by several long objects. To understand the need for this sort, note for instance that the Sphere1 canpass through the ring, provided that the latter is not being currently crossed by the Post. We assume we have available theset predicates ‘∈’ and ‘⊆’ with their standard meaning (note that Longset is finite and the whole extension of these twopredicates can be provided explicitly without requiring further axiomatisation). Similarly, we will use the union operator ∪which can be fixed to its usual meaning in a similar way.We will define the two sides of a hole (we will call them faces) or the two tips of a long object as follows:(cid:6)Face def=(cid:6)Tip def=face(h, +), face(h, −)tip(x, +), tip(x, −)(cid:7)(cid:8)(cid:7) h ∈ Hole(cid:7)(cid:8)(cid:7) x ∈ Long,;+, hwhere tip and face are two new constructors or function symbols.9 For the sake of compactness, we will use the abbrevia-+−, xrespectively standing for face(h, +), face(h, −), tip(x, +) and tip(x, −). In this way, for instance, thetions h. The predicate Oppositestring has the two tips Strwill be used to assert that two different hole faces correspond to the same hole:whereas the Ring has two faces denoted as Ringand Ringand Strand x+−−+−Opposite(cid:2)h+, h(cid:3)−∧ Opposite(cid:2)h−(cid:3)+., h(11)Finally, we define a pair of additional (finite) derived sorts to deal with links among objects. The sort Node def= Tip ∪Hole ∪ Regular captures all the possible elements that can form a node of a link. The difference with respect to Objectas the link node. We also define Nodeset def= 2Nodeis that, for linking a long object x, we must use one of its tips xthat will be used to allow moving “bundles” of linked objects, and use ∈, ⊆, ∪ as we did for the sort Longset.or x−+5.1. Spatial predicates and fluentsWe begin defining an inertial fluent linked ∈ Inert:linked : Node × Node → Boolean = Falsewhose meaning is self-explanatory. In our scenario, linked will always relate a tip to a regular or a holed object, and thisinformation will not vary along time. We prefer to maintain this as a fluent, and not as a static predicate, to allow a futureinclusion of possible actions that change the degree of connectivity between objects.Formulae that describe a particular Fisherman’s Folly puzzle configuration will be labelled as (FFn). For instance, theinitial facts for linked in the puzzle would be:(cid:2)Holds(cid:2)linkedStr−(cid:3), Disk1, True, S0(cid:3)(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holdslinkedlinked(cid:2)(cid:2)(cid:2)+StrPost(cid:3)(cid:3), Disk2+, PostH(cid:3), True, S0(cid:3), True, S0(cid:3)(cid:3)−linkedPost, Base, True, S0.(FF1)As we can see in its declaration, linked will be False by default. If we do not provide further information for this predicateapart from (INE), axiom (DV) allows deriving that all the rest will be false. The following are some axioms for the fluentlinked:9 Remember we handle Herbrand models.356P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377(cid:2)Holds(cid:2)Holds(cid:2)Holdslinked(x, y), True, s(cid:3)(cid:3)linked(x, y), True, s+xlinked, x−(cid:3)(cid:2), False, s.(cid:2)→ Holds(cid:2)∧ Holds(cid:3)linked( y, x), True, s(cid:3)linked( y, z), True, s(cid:3),(cid:2)→ Holdslinked(x, z), True, s,(cid:3)(12)(13)(14)They respectively assert that the relation linked is commutative, transitive, and that the two tips of a long object are neverlinked.10In principle, information about what can or cannot pass through a hole will not vary along time. For this reason, we justconsider a static predicate CannotPass(x, h, y) to represent that the object x cannot pass through the hole h when the latteris currently crossed by the set of long objects y. In the Fisherman’s Folly example we include the following facts:CannotPass(disk, sphere, ∅) ∧ CannotPass(disk, Ring, ∅)∧ CannotPass(Base, Ring, ∅) ∧ CannotPass(Base, PostH, ∅)∧ CannotPass(Base, sphere, ∅)∧ CannotPass(Post, sphere, ∅) ∧ CannotPass(Post, PostH, ∅)∧ CannotPass(sphere, PostH, ∅) ∧ CannotPass∧ CannotPass∧ CannotPass(PostH, sphere, ∅)∧ CannotPass(Ring, sphere, ∅)sphere, Ring, {Post}(cid:3)(cid:2)(cid:2)sphere, sphere(cid:3)(cid:17), ∅(FF2)(cid:17)with disk varying on {Disk1, Disk2} and sphere, sphereon {Sphere1, Sphere2}. Note, for instance, that under any circumstance,any string can be passed through any hole. Note also that the spheres can pass through the Ring, unless the Ring is crossedby the Post. In order to guarantee this latter constraint, the following two axioms are also included:CannotPass(h, h, y);CannotPass(x, h, y) ∧ y ⊆ z → CannotPass(x, h, z),(15)(16)respectively stating that a single holed object h cannot pass through itself, and that once x cannot pass through h whencrossed by y, the same will hold for any superset of y. We also assert that if a long object x cannot pass through a hole,then none of its tips can do so by default:CannotPass(x, h, y) ∧ ¬CanPass(cid:2)xv , h, y(cid:3)→ CannotPass(cid:2)xv , h, z(cid:3),(17)where CanPass is an auxiliary predicate used to assert exceptions to this rule.It is worth pointing out that, as predicates are false by default and CannotPass is a “negative” predicate, we are assumingthat objects can pass through holes as a default. Apparently, this does not seem to be well chosen for the Fisherman’s Follyscenario, where there actually exist more cases in which objects cannot pass through holes than those that can – in otherwords, (FF2) would be smaller for a CanPass predicate. However, in a more complex scenario, it may be the case that wedo not have this information in a complete way. If so, the advantage of our representation is that an hypothetical plannercould go finding “optimistic” plans that, when tried on the physical object, could perhaps be unfeasible at some point oftheir execution, but could help us to find out a new fact for CannotPass(x, h, y) we had not realised before. In this way, wecould go refining our information for CannotPass until some obtained plan actually solves the physical problem.5.2. Crossings and segmentsWhen representing a long object, the relevant information we will be interested in is the set of hole crossings. It is impor-tant to notice that the same long object can cross the same hole several times and in different directions (this is especiallycommon when the long object is flexible, like a string). If we understand long objects and holes as three-dimensionalregions, a crossing is the overlapping region between a hole and a long object. We can define a segment as a maximalcontinuous portion of a long object not overlapping with any hole. An important assumption about long objects will bemade:For any long object x, there cannot be a segment of x connecting more than two hole crossings.10 In this paper we disregard handling circular long objects or, similarly, linking the negative and positive tips of a same long object. This possibility isleft for future study.P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377357Our representation of the domain, and in particular, of the state of a long object in a given situation, will rely on thisconcept of segment. Thus, when writing formulae, we will require a way to refer to a given segment. The representation ofsegments of a long object x will be done using segment labels. A segment label i is a term that must uniquely identify eachsegment in a long object x. In the textual or graphical explanations, we will represent a segment as x : i where x is a longobject and i a label.+−to tip xIntuitively, a good candidate sort for segment labels could be the natural numbers 0, 1, 2, . . . , or equivalently their Peano-like representation 0, s(0), s(s(0)), . . . so that we use their ordering to follow the sequence of crossings in the long object. In this way, for instance, the string would have the four initial segments Str : 0 (from Disk1 to Sphere1),from tip xStr : 1 (from Sphere1 to PostH), Str : 2 (from PostH to Sphere2) and Str : 3 (from Sphere2 to Disk2). An important problem,however, is that the set of segments will vary along time depending on the actions performed. When segments disappearthis is not a real problem, as this just means that we will “stop using” a label in the relevant fluents that represent thelong object state. Unfortunately, we also need to create new segments, which sometimes must be included between twoexisting segments. In this way, we should be able to partition a segment into new fragments as many times as needed.One possibility could be using rational numbers to this aim.11 However, in order to avoid their axiomatisation, we adopt asimpler choice. We will use four new Herbrand functions or label constructors pred(i), mid1(i, j), mid2(i, j) and succ(i), sothat:• x : pred(i) denotes a predecessor segment to x : i;• x : succ(i) denotes a successor segment to x : i and• x : mid1(i, j) and x : mid2(i, j) denote a pair of segments that are positioned in this same ordering, in the middle of x : iand x : j.We assume that there exists a way to assign a different label to each object segment occurring in the initial situationS0. Let us call InitLabel this finite set of initial labels. The sort Label is recursively defined as: l ∈ Label iff l ∈InitLabel or l has any of the forms pred(i), succ(i), mid1(i, j) or mid2(i, j) with i, j ∈ Label.+As said before, we will represent the list of segments and crossings following the chain from the negative tip xto thepositive one x. To this aim we can imagine a linear graph where each node is a segment and each arc is labelled withthe crossing that connects both segments, represented by the corresponding outgoing hole face. Following this notation, theinitial situation of the string Str would correspond to the graph:−Str : 0Sphere1+−→ Str : 1+PostH−→ Str : 2+Sphere2−→ Str : 3.The representation of this graph will be done with a pair of inertial fluents:next : Long × Label → Label ∪ {End}towards : Long × Label → Faceso that, for instance, a pair of facts like(cid:2)∧ Holdsnext(Str, 0), 1, s(cid:2)Holds(cid:3)towards(Str, 0), Sphere1(cid:3)+, srepresent the labelled graph edge Str : 0special constant End – in our example, Holds(next(Str, 3), End, S0).Sphere1+−→ Str : 1. For convenience, the last segment in the list will further point to aIt must be noticed that not any possible pair x : i will form a real object segment in any situation. For instance, in the goalsituation, the long object Post does not cross any hole and so, it has a unique segment, labelled in this case as Post : 0. Thus,for instance, there are no segments Post : 1 or Post : 2 in that situation, although 1 and 2 are possible labels. The “existence”of a segment x : i at a given situation s is captured by the fact that no atom Holds(next(x, i), z, s) or Holds(towards(x, i), y, s)is true at that situation, i.e., the segment is not referenced as argument of any true atom.(cid:3)(cid:2)Holdsnext(Str, 0), 1, S0The initial situation in the puzzle can be represented now by the formula:(cid:2)∧ Holdstowards(Str, 0), Sphere1(cid:2)∧ Holdsnext(Str, 1), 2, S0(cid:2)∧ Holdsnext(Str, 2), 3, S0(cid:2)∧ Holdsnext(Str, 3), End, S0(cid:3)(cid:2)∧ Holdsnext(Post, 0), 1, S0(cid:2)∧ Holdsnext(Post, 1), End, S0, S0(cid:2)∧ Holds(cid:2)∧ Holds(cid:3)(cid:2)∧ Holds(cid:3)+(cid:3)(cid:3)(cid:3)towards(Str, 1), PostHtowards(Str, 2), Sphere2, S0(cid:3)(cid:3)+, S0+towards(Post, 0), Ring(cid:3)+, S0(FF3)11 Another possibility we have not explored is the use of existential quantifiers, but this would surely mean a more difficult reading and longer formulaeto guarantee that segment labels are pairwise different.358P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Fig. 6. Schematic representation of the initial state showing the long object segments.where, as we can see in the fifth line of the previous statement, the post has also a crossing (towards Ring) and so it hasbeen divided into two segments, Post : 0 and Post : 1. We include the following axiom, to check that in S 0 no segment x : kis preceded by two different crossings:(cid:2)∧ Holds(cid:2)Holds→ i = j.next(x, j), k, S0next(x, i), k, S0(18)(cid:3)(cid:3)+At this point we would like to recall the schematic representation introduced in Section 2 (Fig. 3), reproduced in Fig. 6for convenience. Note the representation of segments: x : i.An additional non-inertial fluent (from below) will be useful for specifying action preconditions in a more readable12way.from : Long × Label → Face.Its meaning is fixed by the axiom:(cid:2)Holdsnext(x, j), i, s(cid:3)(cid:2)∧ Holdstowards(x, j), p, s(cid:3)(cid:2)→ Holdsfrom(x, i), p, s(cid:3)(19)that is, towards and from respectively indicate the next and the previous hole crossing of a given segment x : i.5.3. ActionsFrom a physical point of view, the solution to the Fisherman’s Folly puzzle can be exclusively described in terms ofactions for passing objects through holes in a given direction. In principle, this would lead us to consider some action like+).pass(x, p) meaning that we pass object x through some hole towards its face p, such as for instance, pass(Ring, PostHAlthough in principle x could be of any type Regular ∪ Long ∪ Hole, in practice some objects are not relevant to bepassed through a hole, w.r.t. the puzzle’s states. For example, assume we have a disconnected disk and we decide to passit through the post hole: it is not difficult to see that this action has no effect on our state representation at all. Generallyspeaking, passing a regular object x through a hole is only really relevant when x is linked to some tip of a long object.For this reason, we disregard the case x ∈ Regular in favour of passing long object tips instead, x ∈ Tip. Note that, bypassing tips, we can also disregard pass(x, p) for a whole long object x ∈ Long, as it can be replaced by a sequence of+, p). The only remaining possibility is pass(x, p) for some x ∈ Hole, that is,pass(xsome single holed object. In fact, the most difficult part of the formalisation has to do with the case in which x is currentlycrossed by one or more segments of one or more long objects.−, p) or pass(x−, p), pass(x+, p), pass(xApart from individually passing tips and holed objects, we must also bear in mind one more feature that is present inthe problem: linked objects. In our puzzle, we have four pairs of linked elements: three of them are linking tips to regularobjects, but one is linking a tip to a holed object. It is not difficult to imagine other scenarios (see, for instance, the TrickyDick puzzle discussed in Appendix C) where we may also link two tips of (different) long objects or two linked holedobjects. When elements are linked one each other, passing them through a hole implies passing each of their individualcomponents. We will define the concept of object bundle as a (maximal) set of linked objects. The non-inertial fluent:bundle : Nodeset → Boolean = True,will be used to reflect that a given set of objects B forms a bundle at some situation. This fluent is True by default becauseit is easier to specify when an arbitrary set of objects b does not form a bundle. Its meaning is captured by the followingaxioms:12 In fact, references to this additional fluent in action preconditions could be replaced by a suitable use of quantifiers.P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377359Fig. 7. Movements for passing the positive tip pass(x(cid:2)→ Holdsbundle(b), False, s(cid:3)(cid:3),linked(x, y), False, slinked(x, y), True, sbundle(b), False, s,(cid:3)(cid:2)→ Holds+, p).(cid:3)(cid:2)x ∈ b ∧ y ∈ b ∧ Holds(cid:2)x ∈ b ∧ ¬( y ∈ b) ∧ Holds(cid:3)bundle(∅), False, s(cid:2)Holds.(20)(21)(22)Axiom (20) asserts that the set b does not form a bundle when it contains two unlinked objects x and y. Axiom (20)captures the bundle maximality: a bundle b cannot contain an object x linked to an external element y not in b. Finally,(22) asserts that the empty set cannot be a bundle.Example 2. Axioms for bundle (20)–(22) and linked (12)–(14) plus the initial state of linked in the Fisherman’s Folly puzzle(FF1) and the default values for linked and bundle allow deriving the facts:(cid:2)Holds(cid:2)(cid:6)−(cid:8)(cid:3)bundleStr, Disk1, True, S0(cid:3)(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)(cid:6)+(cid:8)(cid:3)(cid:3)bundle(cid:2)(cid:6)Strbundle(cid:2)(cid:6)PostbundlePost+, Disk2−, Base, True, S0(cid:8)(cid:3)(cid:3), True, S0(cid:8)(cid:3)(cid:3), PostH, True, S0and no other bundle is formed at situation S0.To sum up, our main action will have the form pass(b, p) meaning that we pass the bundle b towards the hole face p.We will first describe the unfeasibility axioms, that is, conditions for which it is impossible to perform action pass(b, p) at agiven situation. To this aim, we define an auxiliary non-inertial fluent:crossedBy : Hole × Longset → Boolean = False,with axioms(cid:2)Holds(cid:2)Holdstowards(x, i), hv , s(cid:3)(cid:2)→ HoldscrossedBy(cid:3)(cid:2)(cid:3)h, {x}, True, s(cid:3),(cid:3)crossedBy(h, a), True, scrossedBy(h, b), True, s(cid:2)∧ Holds(cid:2)→ HoldscrossedBy(h, a ∪ b), True, s(cid:3).(23)(24)In other words, crossedBy points out all the long object sets that are crossing a given hole h at situation s. The unfeasibilityconditions are then specified as follows:(cid:2)Holds(cid:2)x ∈ b ∧ Holdsbundle(b), False, s→ Imposs(cid:3)(cid:2)(cid:3)crossedBy(h, a), True, spass(b, p), s(cid:3)∧ CannotPass(x, h, a) → Imposs,(cid:2)(cid:3)(cid:2)b, hv(cid:3), s.pass(25)(26)Axiom (25) asserts that we cannot pass a set b that does not form a bundle. Axiom (26) says that a bundle b cannot passthrough a hole h if b contains some node13 x that cannot currently pass through h.Let us proceed now with the effect axioms, that is, the causal rules describing effects of an action. To this aim, the effectsand constraints for passing a tip or a holed object inside a bundle are described separately. For instance, for passing apositive tip x+to some face p, we get:(cid:2)(cid:3)¬Imposspass(b, p), s∧ x+ ∈ b ∧ s(cid:2)(cid:17) = do(cid:3)pass(b, p), s(cid:2)∧ Holdsnext(x, i), End, s∧ Opposite(cid:3)(cid:2)(cid:3)(cid:17)p, p(cid:2)∧ ¬Holds(cid:2)(cid:3)∧ Holds(cid:3)(cid:17)(cid:2)→ Holds(cid:2)∧ Holdsfrom(x, i), p(cid:3)(cid:17), s(cid:3)(cid:17)next(x, i), succ(i), s(cid:3)(cid:2)nextx, succ(i), End, stowards(x, i), p, s(cid:2)∧ Releasedtowards(x, i), s(cid:3).(PR)13 To be precise, we could modify CannotPass to reflect when a set of objects cannot pass altogether through a hole currently crossed by another set ofobjects, but this is not really needed for the current puzzles and is disregarded in this paper.360P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Fig. 8. Movements for passing the negative tip pass(x−, p).Axiom name (PR) stands for Positive tip to “Right”. This axiom asserts that if x : i is the last segment and there is no, then we add a new crossing from x : i passingpreceding crossing through the same hole in the opposite direction pthrough p to a new (last) segment x : succ(i). The analogous movement for a positive tip (Positive tip to Left) would becovered by:(cid:17)(cid:2)¬Imposspass(b, p), s(cid:3)∧ x+ ∈ b ∧ s(cid:2)(cid:17) = do(cid:3)∧ Oppositepass(b, p), s(cid:2)∧ Holds(cid:2)→ Holdstowards(x, i0), p(cid:3)(cid:17)next(x, i0), End, s(cid:2)∧ Releasednext(x, i1), s(cid:3)(cid:17)(cid:17)(cid:3)(cid:2)(cid:2)∧ Holdsp, p(cid:2)(cid:3)∧ Holds, snext(x, i1), End, s(cid:2)∧ Releasedtowards(x, i0), s(cid:3)next(x, i0), i1, s(cid:3)(cid:3)(PL)(cid:17), we must removewhich states that when we execute pass(xthis crossing and the last segment. Fig. 7 schematically shows the effects of movements (PR), (PL).+, p) but the last crossing of x was in the opposite direction pAnalogous axioms are included for passing the tip x(cid:3)(cid:2). Passing Negative tip to Left is stated as follows:(cid:3)(cid:2)(cid:3)¬Imposspass(b, p), s∧ x− ∈ b ∧ spass(b, p), s∧ Opposite(cid:17)(cid:2)(cid:17) = do−(cid:2)∧ ¬Defined(cid:2)(cid:2)→ Holdsnextfrom(x, i), s(cid:3)x, pred(i), i, s(cid:3)(cid:2)p, p∧ Definednext(x, i), s(cid:2)(cid:3)(cid:17)∧ Holdstowards(cid:2)(cid:3)(cid:2)∧ ¬Holds(cid:3)(cid:17)x, pred(i), p(cid:3)(cid:17)from(x, i), p, s, s,(NL)(cid:3)that is, if i is the first segment (there are no previous crossings) and it is not followed by a crossing p then we add a newtowards i. Note that we require Defined(next(x, i), s) so that x : i is an existing(first) segment pred(i) passing through psegment, i.e., it is followed by a crossing or by End (in this case, it would be the sole object segment). Finally, the action forpassing the Negative tip of a long object to the Right of a hole is represented as follows:(cid:17)(cid:2)¬Imposspass(b, p), s(cid:3)∧ x− ∈ b ∧ s(cid:2)(cid:17) = do(cid:3)(cid:2)∧ Oppositepass(b, p), s(cid:2)∧ Holdstowards(x, i0), p, s(cid:2)→ Releasedp, p∧ ¬Defined(cid:2)∧ Released(cid:3)(cid:3)(cid:3)(cid:17)(cid:2)∧ Holds(cid:2)(cid:3)next(x, i0), i1, s(cid:3)from(x, i0), s(cid:3)next(x, i0), s(NR)which means that, if x : i0 is the initial segment (it has no previous crossing) and it points to x : i1 through face p, then thiscrossing is removed, so x : i1 implicitly becomes the first segment. Fig. 8 graphically represents the effects of (NL), (NR) –notice that the figure is almost symmetrical to Fig. 7.towards(x, i0), sWe move now to consider the effects of passing a holed object h through another hole towards the outgoing face p of−) with PostH ∈ b would pass the post hole towards the bottom side of the ring (in otherthe latter. For instance, pass(b, Ringwords, slide the ring upwards along the post hole). The execution of this action will affect all crossings of any long object xtowards any face hv of h. Note that the same long object may cross the same hole several times and in different directions.¬Imposs(cid:2)= do(cid:2)pass(b, p), s(cid:3)(cid:3)∧ h ∈ b ∧ Opposite(cid:2)∧ ¬Holds(cid:2)(cid:3)(cid:17)p, p(cid:17), s(cid:17)∧ s(cid:2)(cid:3)∧ Holdsfrom(x, i0), p(cid:2)(cid:3)∧ ¬Holds(cid:3)pass(b, p), s(cid:2)∧ Holds(cid:2)→ Holdstowards(x, i0), hv , s(cid:17)next(x, i0), mid1(i0, i1), s(cid:2)(cid:3)∧ Holdsx, mid1(i0, i1)(cid:2)∧ Holds(cid:3)x, mid2(i0, i1)towards(cid:2)next(cid:2)(cid:2)∧ Holds(cid:3)(cid:17), hv , s(cid:3)(cid:17)(cid:2)∧ Holds(cid:3)next(x, i0), i1, s(cid:3)towards(x, i1), p, stowards(x, i0), p, s(cid:3)(cid:17)(cid:2)∧ Holds(cid:2)(cid:3)nextx, mid1(i0, i1), mid2(i0, i1), s(cid:3)(cid:17)(1R)This first movement is applicable when segment x : i0 crosses h towards x : i1 but the former is not preceded by a(the opposite of p) and the latter is not followed by a crossing through p. The effect of pass(b, p) intowardscrossing through p(cid:17), p, s., i1, s(cid:2)(cid:3)x, mid2(i0, i1)(cid:3)(cid:17)(cid:17)P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377361Fig. 9. Movements (1R), (1L) for action pass(h, p).this part of the list is the insertion of two new crossings, one through p before h and one after h through p. This alsoimplies the creation of two new segments labelled with mid1(i0, i1) and mid2(i0, i1). The opposite movement is capturedby the axiom:(cid:17)(cid:2)∧ Holdstowards(x, i0), p(cid:3)(cid:3)(cid:17), spass(b, p), s(cid:2)(cid:3)¬Imposspass(b, p), s(cid:2)(cid:17) = do∧ s(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)→ Holdsnext(x, i2), i3, s(cid:3)(cid:17)next(x, i0), i3, snext(x, i1), i2, s(cid:2)∧ Released(cid:2)∧ Releasednext(x, i1), snext(x, i2), s(cid:2)(cid:3)(cid:17)p, p(cid:3)(cid:3)∧ h ∈ b ∧ Opposite(cid:2)∧ Holds(cid:3)(cid:3)towards(x, i1), hv , s(cid:3)next(x, i0), i1, s(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)(cid:3)∧ Released(cid:2)∧ Released(cid:17)towards(x, i2), p, s(cid:17)towards(x, i0), hv , s(cid:3)towards(x, i2), s(cid:17)towards(x, i1), s(cid:3), hv , p (with p(cid:3)(cid:3).(1L)When we have a sequence of crossings pp(cid:17)and p from the list. Movements (1R), (1L) are schematically represented in Fig. 9.The remaining movements do not create or destroy segments, but just swap crossings:opposite face of p), action pass(h, p) implies removing crossings(cid:2)(cid:3)(cid:17)p, p¬Imposspass(b, p), s(cid:2)(cid:17) = do∧ s(cid:2)∧ Holds(cid:2)→ Holdspass(b, p), stowards(x, i0), hv , s(cid:3)towards(x, i0), p, s(cid:3)∧ h ∈ b ∧ Opposite(cid:2)∧ ¬Holds(cid:3)(cid:2)∧ Holds(cid:2)∧ Holds(cid:17)towards(x, i1), p, s(cid:3)(cid:17)towards(x, i1), hv , s,from(x, i0), p(cid:3)(cid:17), s(cid:2)∧ Holds(cid:3)(cid:3)next(x, i0), i1, s(cid:2)(cid:2)(cid:3)(cid:3)¬Imposspass(b, p), s(cid:2)(cid:17) = do∧ s(cid:2)∧ Holds(cid:2)→ Holdsnext(x, i1), i2, stowards(x, i0), hv , spass(b, p), s(cid:3)∧ h ∈ b ∧ Opposite(cid:2)∧ Holds(cid:3)next(x, i0), i1, s(cid:2)∧ Holds(cid:17)(cid:2)∧ Holds(cid:3)towards(x, i1), hv , stowards(x, i1), p, s(cid:3).(cid:2)∧ Holdstowards(x, i0), p(cid:2)(cid:3)∧ ¬Holds(cid:17)(cid:17)(cid:3)(cid:17), s(cid:3)next(x, i2), p, s(cid:2)(cid:3)(cid:17)p, p(cid:3)(2R)(2L)The graphical representation of these movements is shown in Fig. 10.The goal can be specified as a ground situation s that satisfies the formulaGOAL(s)(cid:4)def= ¬(∃x, i, v)(cid:2)Holdstowards(x, i), Ringv , s(cid:3)(cid:5)which is entailed from our scenario description. GOAL(s) asserts that the Ring hole is not referenced in any crossing and so,is completely free.We define the Holes and Strings Theory, HST, as the set of formulae ESC ∪ {(11)–(26), (PR), (PL), (NR), (NL), (1L), (1R), (2L),(2R)}. An HST scenario consists of axioms in HST plus the definition of sorts Regular, Hole, Long and domain dependent362P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Fig. 10. Movements (2R), (2L) for action pass(h, p).axioms containing a conjunction of ground atoms for predicate CannotPass and initial values of linked, next and towards. Inparticular, we define the Fisherman’s Folly scenario, FOLLY, by adding to HST the sorts in (10) and the domain dependentaxioms (FF1), (FF2) and (FF3).The following proposition shows that the method for labelling new segments works as expected.Proposition 8. Let M be an Equilibrium model of an HST scenario and let L(s) = {i | M |(cid:16) Defined(next(x, i), s)}, that is, the labels of“existing” segments at situation s. Then, if the antecedent of (PR) holds in M, the composed label referred in its consequent succ(i) doesnot belong to L(s). The same happens for (NL) with new label pred(i) and for (1R) with the new labels mid1(i0, i1) and mid2(i0, i1).Proof sketch. This relies on the fact that we can establish a strict ordering relation among labels that coincides with theirsequence in the long object for the initial situation, while for composed labels satisfies: if pred(i) < i, i < mid1(i, j) <mid2(i, j) < j and i < succ(i). (cid:2)An important observation is that, axioms in an HST scenario can be seen as logic program rules, as with the formali-sation of the Yale Shooting scenario in Example 1. Furthermore, HST also preserves the same dependence ordering amongsituations: a predecessor situation s never depends on a successor one do(a, s). So, a similar splitting technique can be usedto prove the following results.Proposition 9. Let M be an equilibrium model of some HST scenario. Then, M satisfies (18) for any situation s:(cid:3)(cid:3)(cid:2)Holdsnext(x, i), k, s(cid:2)∧ Holdsnext(x, j), k, s→ i = j.In other words, we never get into a situation where two different crossings point to the same long object segment x : k.Proposition 10. Any HST scenario has at most a unique Equilibrium model.Proof sketch. As with YALE, if we carefully look at all movements, it can be checked that they induce a deterministic statetransition system. (cid:2)In the case of FOLLY, the theory is consistent, and so has a unique equilibrium model capturing the whole transitionstate system of the puzzle.The next section discusses the correspondence of the above formalisation with respect to a model of the domain basedon list manipulation. We argue that this model guarantees the correctness of our rigorous account of the Fisherman’s Follypuzzle.6. The induced transition system: operations on lists of crossingsAs we have seen the previous formalisation is not too far away from other typical uses of Situation Calculus, except thatclassical Predicate Calculus has been replaced by First-Order Equilibrium Logic as the underlying logical formalism. The useof the Situation Calculus allows us to express non-trivial properties of the system, while providing a high degree of flexibilityand elaboration tolerance. In this way, our formalisation can cope with some simple modifications of the scenario likeadding new constraints, or defining new actions. On the other hand, the use of Equilibrium Logic as the underlying logicalformalism allows us to inherit most of the typical constructs from action representations using Answer Set Programming [45]P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377363(ASP), but removing the ASP restriction to propositional theories. As a result, we get a compact representation of inertia(INE), and we may naturally deal with indirect effects, like Axiom (19), or handle action disqualifications, as shown withrespect to the predicate Imposs.Analogous to our investigation of the Yale Shooting Scenario in Fig. 5 (Section 4), we can also study the transitionsystem induced by our logical representation. This may help for a better understanding of the system behaviour, and canalso be used for an efficient implementation of a planning algorithm. On the other hand, it must be taken into account thata transition system is much less elaboration tolerant than the logical representation – for instance, it cannot adequatelyrepresent default values, inertia or indirect effects, so that small elaborations of the domain may drastically affect thetransition system configuration.In order to describe the transition system states, we have a problem that did not manifest in the Yale Shooting scenario,where all fluents were Boolean – we have an infinite set of states and, furthermore, their representation is hard due to thepossibility of arbitrarily creating new segments. To avoid using segments in the transition system representation, we adoptthe approach we followed in a previous work [16] (briefly introduced in Section 2) where a puzzle state was representedas an ordered list of crossings for each long object. Transitions were then specified as combinations of elementary trans-formations on these lists, inducing a transition system for which a simple forward-driven planner was designed. We willdescribe next the correspondence between the list-based solution of the puzzle and our present formalisation, proving thecorrectness of the planner.In this section we use Greek letters α, β, γ , . . . to denote lists and adopt the usual Prolog list notation. The expressionα · β represents the concatenation of lists α and β. Given an HST interpretation M and a situation s we will define itscorresponding state as a set of lists chain(x) for each long object x ∈ Long. The formal definition of chain(x) will be done interms of an auxiliary list cr(x, i), where i is one of the segment labels of x. This list cr collects all the crossings that followa given long object segment x : i (cf. the informal definitions presented in Section 2 above).Definition 4 (Crossing list). Given a model M of an HST scenario, a segment x : i, and a ground situation s, we define the listcr(x, i, s) recursively as follows:(cid:9)cr(x, i, s)def=[p] · cr(x, j, s)[ ]if M |(cid:16) Holds(next(x, i), j, s) ∧ Holds(towards(x, i), p, s)if M |(cid:16) Holds(next(x, i), End, s).The list chain(x, s) just appends the left and right tip of x as first and last element of the list obtained by cr(x, i, s), beingx : i the first segment of x. This is formally specified by:Definition 5 (Chain list). Given a model M of an HST scenario, a long object x, and a ground situation s, we define the listchain(x, s) as:chain(x, s)(cid:5)(cid:4)−xdef=· cr(x, i, s) ·(cid:5)(cid:4)+xwhere i is such that M |(cid:16) ¬Defined(from(x, i), s) ∧ Defined(next(x, i), s), that is, the first segment label of x.With these rules, it is easy to see that the state corresponding to the initial situation would be described by the pair oflists:(cid:4)chain(Str, S0) =chain(Post, S0) =−Str(cid:4)Post, Sphere1+−, Ring++, PostH(cid:5)+., Post, Sphere2+, Str(cid:5)+,Now, we will show that the value of chain(x, do(a, s)) after a transition can be directly computed from chain(s) using apair of simple list transformation operators, one for each action type: passing tips pass(t, p) and passing single-holed objectspass(h, p).Definition 6 (Operator opTt,p ). Let x be a long object, t one of its tips t = xv , p a face and pmation on list α = chain(x) caused by the action pass(t, p), written opTt,p , is defined as: opTt,p(cid:5), y (cid:12)= p+(cid:4)(cid:4)(cid:5),(cid:17)(cid:17)(cid:4)β ·β ·(cid:4)−x−x(cid:4)+, α = β ·(cid:4)y, p, x(cid:5)+x+if t = x+if t = x, α = β ·(cid:5)−· β if t = x, p(cid:5)−· β if t = x, α =p, α =(cid:4)−x, y(cid:17), x(cid:4)−, yx(cid:5)· β,y, x(cid:5)+,, p(cid:5)(cid:17)· β, y (cid:12)= p,where α · β denotes the concatenation of lists α and β.its opposite face. The transfor-def=(27)(28)(29)(30)364P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377It is easy to see that the four conditions (27)–(30) respectively correspond to movements (PR), (PL), (NL) and (NR),introduced in Section 5.1. The remaining movements of the puzzle can be stated as shown in Definition 7 below.the opposite face of p. Given a list of crossings α = chain(z)Definition 7 (Operator opHh,p ). Let h be a hole, p a face and pfor a long object z, the transformation on α caused by an action pass(h, p), written opHh,p(α), is recursively defined as:opHh,p(α)def=(cid:17)[x][x | γ ](cid:4)x, p, hv , p(cid:7)(cid:7) γx, p, hvif α = [x],(cid:4)if α =(cid:7)(cid:7) γ(cid:17)if α =(cid:7)(cid:5)(cid:7) γ(cid:7)(cid:7) γ(cid:4)hv , p(cid:4)hv(cid:4), y(cid:5)(cid:5)(cid:17)(cid:5)(cid:7)(cid:7) βif α =(cid:17), hv , p(cid:4)x, g v(cid:5)(cid:4)pif α =if α =(cid:2)(cid:4)(cid:5)(cid:3)(cid:7)(cid:7) β(cid:5)g v, g (cid:12)= h, γ = opHh,p(cid:7)(cid:4)(cid:7) β(cid:17), x (cid:12)= px, hv , y(cid:7)(cid:2)(cid:5)(cid:7) β= [p | γ ],, opHh,p(cid:7)(cid:3)(cid:5)(cid:7) β[p | β], x (cid:12)= px, hv , p, opHh,p(cid:7)(cid:2)(cid:4)(cid:5)(cid:7) β(cid:17), y (cid:12)= p, γ = opHh,p, hv , y,, y (cid:12)= p, γ = opHh,p(cid:3)[p | β](cid:17)= [p | γ ],(cid:3)[ y | β]p(cid:2).(cid:2)(cid:3)[ y | β],(31)(32)(33)(34)(35)(36)After a careful reading, it can be observed that conditions (33)–(36) correspond to movements (1R), (1L), (2R) and (2L).As we can see, opH operator processes triples x, hv , y in the list whose central element is a crossing through the movedhole h. Note that these movements exhaust all the possibilities: x and y could be the target face p, its opposite face pornone of them, but all the cases are covered in (33)–(36). Note also that the last element in a triple is being used as the firstelement of the next triple. This means that elementary movements can be combined, as shown by the following example,extracted14 from a similar puzzle explained in Section 7.(cid:17)Example 3 (Combined movements). Assume we have the list α =:++−−−++(cid:4)H1, Ring, H2, Ring, H1, Ring, H2(cid:5).+), that is, opHRing,H2+ (α), is computed as shown below. We just show relevantThe result corresponding to pass(Ring, H2steps involving some change in the list. At each step, we show the movement to be applied embracing the three involvedcrossings. The accumulated result is shown as a second appended list. When new crossings appear, they are shown inboldface:(cid:4)(cid:4)+H1, Ring−, H2+, Ring+−, H1(cid:10), Ring(cid:11)(cid:12)−, H2(cid:5)+(cid:13)· [ ]+H1, Ring−+, H2(cid:10), Ring(cid:11)(cid:12)+, H1(2R)(cid:4)H2+(cid:5)−(cid:13)·(cid:5)−, Ring(cid:4)H1(cid:10)+, Ring(cid:11)(cid:12)−, H2+(cid:13)(cid:5)·(1R)(cid:4)H2+, Ring+−, H2, H1−, H2+, Ring(cid:5)−(cid:4)[ ] ·(2R)+, H2H1+, Ring−, H2+, Ring+−, H2, H1−, H2+, Ring−(cid:5).Conjecture 1. Let Γ be an HST scenario, M a model of Γ , x a long object and s a ground situation such that chain(x, s) is defined w.r.t.M. Then:1. If M |(cid:16) ¬Imposs(pass(t, p), s) then chain(x, do(pass(t, p)), s) = opTt,p(chain(x, s));2. If M |(cid:16) ¬Imposs(pass(h, p), s) then chain(x, do(pass(h, p)), s) = opHh,p(chain(x, s)).Conjecture 1 above shall be formally proved in a future work.We have built a forward planner holestrings (see Appendix A) that tries all action executions in an iterative deep-ening strategy, using operators opH and opT and exclusively considering the lists of crossings for representing each state.Notice that, from the planner point of view, the Fisherman’s Folly goal consists now in checking that no lists of crossingscontains a face like Ringv . The planner cannot obtain any solution with less than six action executions. Fig. 11 presents thefirst solution obtained by the planner in six steps, and shows the executed actions together with each intermediate state forthe chain lists.15 A graphical representation is also included.14 List α is a portion of chain(Str) at state s3 in Fig. 15.15 For the sake of readability, we omitted the object tips x−+and xwhich should respectively occur as first and last element of each list chain(x).P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377365Fig. 11. A formal solution for the Fisherman’s puzzle and its graphical representation.7. A second puzzle: Rope LadderIn this section we briefly present a second strings & holes puzzle, named Rope Ladder (Fig. 12). Rope Ladder can be seenas a more complex variant of Fisherman’s Folly, containing the same sort of objects, entangled in a rigid U-shaped object.The ring in the initial state of this puzzle is trapped in the horizontal edge of the U-shaped figure, whose vertical edges areholed posts, each of which resembles the single post in the Fisherman’s puzzle. The string makes a zig-zag from one posthole to the other (see state S0 in Fig. 13), crossing each hole twice in the initial state. There are two holed spheres (thatcan slide through the string), initially lying near the tips of the string, each of these tips is linked to a disk. The constraintsare analogous to those stated in the previous domain: the spheres cannot pass through either post-holes, where the ringand disks have free passage, if the hole isn’t already crossed by another object.A formalisation of the Rope Ladder puzzle, along with its automated solution, is analogous to that developed for Fisher-man’s Folly. We have in this case the sorts:Regular = {Disk1, Disk2},Hole = {Ring, Sphere1, Sphere2, H1, H2},Long = {Str, Post}and(37)where H1 and H2 stand for the two post holes, Post represents the U-shaped object (without its holes) that is of longobject sort. Instead of (FF1), (FF2) and (FF3), we include now the domain dependent axioms:(cid:2)Holds(cid:2)linkedStr−(cid:3), Disk1, True, S0(cid:3)(cid:2)∧ Holds(cid:2)∧ Holdslinked(cid:2)(cid:2)Str+linkedPost(cid:3)(cid:3), Disk2(cid:3)+, H2, True, S0(cid:3), True, S0,(cid:2)∧ Holds(cid:2)linkedPost−(cid:3)(cid:3), H1, True, S0(RL1)366P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377CannotPass(disk, sphere, ∅) ∧ CannotPass(disk, Ring, ∅)Fig. 12. The Rope Ladder puzzle in its initial state.∧ CannotPass(Post, sphere, ∅) ∧ CannotPass(Post, postH, ∅)∧ CannotPass(sphere, postH, ∅) ∧ cannotPass∧ CannotPass∧ CannotPass(Ring, sphere, ∅)(cid:17)with disk varying on {Disk1, Disk2}, sphere, sphereon {Sphere1, Sphere2}, and postH on {H1, H2}.sphere, Ring, {Post}sphere, sphere∧ CannotPass(postH, sphere, ∅)(cid:3)(cid:17), ∅(cid:2)(cid:2)(cid:3)(cid:2)Holdsnext(Str, 0), 1, S0(cid:3)(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holdstowards(Str, 0), Sphere1next(Str, 1), 2, S0next(Str, 2), 3, S0next(Str, 3), 4, S0next(Str, 4), 5, S0next(Str, 5), 6, S0(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)+, S0(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:3)towards(Str, 1), H1towards(Str, 2), H2towards(Str, 3), H1towards(Str, 4), H2++−+, S0, S0, S0(cid:3)(cid:3)(cid:3)(cid:3), S0+towards(Str, 5), Sphere2(cid:3), S0next(Str, 6), End, S0(cid:3)next(Post, 0), 1, S0(cid:2)∧ Holds(cid:3)next(Post, 1), End, S0.towards(Post, 0), Ring(cid:3)+, S0(RL2)(RL3)The reduced number of changes in the formalisation of Fisherman’s Folly to account for Rope Ladder is an indicationthat our formal solution to the former respects Elaboration Tolerance [22], at least in what concerns the representation ofdifferent physical configurations.The solution of the Rope Ladder puzzle is sketched in Figs. 13 and 14 below, a list-based description of the states in thissolution is shown in Fig. 15.8. DiscussionIn this work we investigated a logic-based formalisation of a domain that involves qualitative spatial reasoning aboutnon-trivial physical objects (such as strings and holes) and reasoning about actions and change on these objects. The domainchosen is the spatial puzzle named Fisherman’s Folly, whose goal is to find a sequence of actions that applied to the puzzle’sobjects will disentangle a ring from a complex arrangement of a string, rigid objects and holes through them.The endeavour of formalising the Fisherman’s Folly puzzle is in line with the challenges for common sense reasoning16such as the egg cracking problem [46–48], whose logical formalisations were motivated by McCarthy’s seminal papers [21,17]. From a very abstract level, automated solutions to such domains could be obtained from a simple search on a state16 A list of such challenges can be found on the Common sense problem page: http://www-formal.stanford.edu/leora/commonsense/ (last accessed in10/12/2009).P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377367Fig. 13. Solution of Rope Ladder: first part.368P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377Fig. 14. Solution of Rope Ladder: second part.stateS 0s1s2s3s4s5s6s7s8s9s10s11s12chain(p)+][Ring+][Ring[ ][ ][ ][ ][ ][ ][Ring[ ][ ][ ][ ]−]chain(str)[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1[Sphere1+, H1+, H1+, H1+, H1+, H1+, H1+, H1+, Ring+, H1+, H1+, H1+, H1+, H1+, H2+, H2+, Ring+, Ring+, H2+, H2+, Ring−, H1+, Ring+, H2+, H2+, H2+, H2+, H1+, H1−, H2−, H2+, Ring+, Ring−, H2+, H2−, H2+, H1+, Ring+, H1+, H1−, H2−, H2+, Ring+, Ring−, H2−, H2+, Ring+, H1+, Ring−, Ring−, H1−, H2−, H2+, Sphere2+, Sphere2+, H1+, H1+, Ring+, Ring+, H1−, Ring+, H1+, H2−, Ring+, Ring+, Sphere2+]−]+, H2−, H2+, Ring−, Ring−, H2+, Sphere2−, Ring+, H2+, Ring−, H2−, H1+, H2+, Sphere2−, H1−, H2−]+, H2+, Sphere2−, H2+, H2−]+, H2+, Sphere2+, H2+, Sphere2−]−, H2+, H2,Ring−, Sphere2+, Ring+, Ring+, H2−]+, H2+, Sphere2+, Sphere2−, H2−]+, Ring−]+, H2+, Sphere2+, Ring−]+, H2−, Sphere2+, Ring−]+, H2+]−, H2,Ring+]+, H2−]+, Disk2}, H2+}, Ring−)next action(s)pass({Strpass({H2, Postpass({Sphere2}, Ring+)pass({Ring}, H2pass({Sphere2}, Ring−)pass({Ring}, H2−)pass({Ring}, H1−}, Ringpass({H1, Post+}, Ringpass({H2, Post+)pass({Sphere2}, Ring+)pass({Ring}, H2pass({Sphere2}, Ring+)−)−)−)+)+)Fig. 15. A formal solution to the Rope Ladder puzzle.P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377369space, resembling automated solutions to classical domains such as the 8-puzzle [49]. However, this sort of solutions carrya number of implicit (hard-wired) assumptions on reasoning about the domain, which are brought to light by a logicalrepresentation. An example of such assumptions is present in the so-called Yale Shooting Scenario [13], a simple domainthat proved to be an elusive problem in the formalisation of commonsense knowledge, due to the fact that its formaldescriptions allowed the existence of counter-intuitive models. Nevertheless, it is possible to hand code a correct state-transition solution for this scenario (such the one shown in Fig. 5). However, it turns out that this solution is a consequenceof sound reasoning about the domain, as it is the intended model of a correct logical encoding of the scenario. The problemhere is how a logic could derive only the intended models (and not possible counter-intuitive ones), a problem that hasmotivated the development of non-monotonic logics [11]. We presented in Section 4 a formalism that solves this problem.In Sections 5 and 6 we used the proposed formalism to solve the Fisherman’s Folly puzzle and, further, this solution isillustrated with a list-based model of the logical reasoning process. The connection between the list-based model and thelogic formalisation of the puzzle is analogous to that relating the state-transition description of the Yale Shooting Scenariowith its formal description: the list-based solution of the Fisherman’s Folly puzzle carry strong assumptions on reasoningabout the domain, which its logical description makes clear. In particular, the logic formalisation of the puzzle solves theproblem of defining which parts of a list are not changed, by incorporating a commonsense law of inertia within the stablemodel semantics underlying the formalism developed.Another advantage of using logic (over the direct application of a state transition system) for problem solving is itsflexibility in handling elaborations of the domain: including a new transition in an automaton may imply on changingcompletely its structure (let alone the inclusion of indirect effects or continuous change, for instance), whereas – in principle– logic allows this to be done by adding the related axioms. In fact, much research has been done to equip logic with theproper tools to accomplish robust and efficient knowledge representation [7,6,8,9]. In this paper we follow the streamlineof this research that tackles the solution of the various problems in knowledge representation assuming Situation Calculus(handling fluents and actions) and Equilibrium Logic (for correctly dealing with non-monotonicity) [18] as lingua franca.Although the approach presented in this paper could solve a few puzzles of distinct complexities, there are situationswhere a more complex treatment is needed. For instance, the current approach has difficulties on the representation of aholed object crossing another holed object. Instead we assume in this work that the state of a hole crossing another holeis an intermediate state that exists momentarily (i.e. the state transition is not complete until this crossing holds). Relaxingthis restriction is a matter for future investigations.Another interesting subject for future work is how to relate the current formalisation to a lower-level representationbased on spatial primitives, opening questions like the “creation” and “destruction” of regions (crossings and segments) orhow to deal with the concept of inertia for spatial change. Clarifying the spatial properties of the puzzle’s objects, such asthe string’s flexibility, and providing the precise reification of holes as real objects is the subject of our current research[25].It is worth mentioning that the importance of reasoning about strings and holes goes beyond pure theoretical interest,embracing application domains such as: cabling, where reasoning about flexible and perforated objects is needed for opti-mising the spatial arrangements of networks of cables; autonomous maintenance of mechanical machines, from which deviceshave to be extracted without damaging the surrounding parts. But, perhaps, the most challenging application of reasoningabout strings rely in the field of robotic surgery, where autonomous machines have to deal (and plan how to handle) suturesin situations involving very distinct and delicate structures.AcknowledgementsWe would like to close this paper by pointing out the influence of John McCarthy’s ideas, adopted by us as our mainmotivations, and which have inspired most part of this work. This was a report on our investigations on logical formalisationof a common sense domain, an issue that was first proposed by McCarthy in [21] as a project, and later stated as aphilosophical stance in [17]. Our formalisation was developed on top of the Situation Calculus and Equilibrium Logic. Theformer was first proposed by McCarthy in [17], and the latter is a novel non-monotonic formalism generalising stablemodels which surprisingly, have been recently characterised as a simple modification of Circumscription, also first proposedby McCarthy in [19]. Thus, it wouldn’t be much far from the truth if we say that every sentence, every concept, in thispaper was inspired by John’s ideas.Paulo Santos acknowledges support from FAPESP and CNPq, Brazil. Pedro Cabalar acknowledges support from SpanishMinistry MEC project TIN2006-15455-C03-02 and Xunta de Galicia project INCITE08-PXIB105159PR.We also want to thank the reviewers for their thorough work and useful suggestions that have helped to improve thepaper.Appendix A. PlannerIn this section we include the Prolog source for the planner. The program does not contain any domain dependent data,so it is applicable to Fisherman’s Folly but also to similar puzzles, like the one in the next section (the Rope Ladder). Theadditional data for the Fisherman’s Folly scenario is omitted, as it can be easily deduced from (FF1), (FF2) and (FF3).370P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377The planner contains an additional action (currently commented) for cutting a link. Of course, enabling this action allows−to Ring+.shorter solutions, like for instance, cutting the link between the post and its base and then passing Post% SORTS -------------------------------------------------------object(X) :- long(X); regular(X); hole(X).sign(+). sign(-).opposite(X^ +,X^ -). opposite(X^ -,X^ +).tip(X^V) :- long(X), sign(V).pole(H^V) :- hole(H), sign(V).action(pass_t(T,P)):- tip(T),pole(P).action(pass_h(H,G^V)):- hole(H),pole(G^V), G \= H.% action(cut(T)):-tip(T).% UNFEASIBILITY -----------------------------------------------crossedBy(_H,[],_S):-!.crossedBy(H,[X|Xs],S):- member(chain(X)=L,S),member(H^ _,L),!,crossedBy(H,Xs,S).imposs1(pass_t(X^_,H^_), S):- crossedBy(H,A,S), cannotPass(X,H,A),!.imposs1(pass_t(T,H^_), S):-member(linked(T,Y)=true,S), cannotPass(Y,H,A), crossedBy(H,A,S), !.imposs1(pass_h(H,H2^_), S) :- cannotPass(H,H2,A),crossedBy(H2,A,S), !.imposs1(cut(T), S) :- member(linked(T,_)=false,S),!.imposs2(pass_h(H,_), S) :- member(linked(_,H)=true,S),!.imposs(A,S) :- imposs1(A,S),!; imposs2(A,S).% EFFECTS -----------------------------------------------------replace(S0,X=V,S1):- append(Pre,[X=_|Suf],S0), append(Pre,[X=V|Suf],S1).trans(S0, cut(X^ V), S1):-!, member(linked(X^ V,Y)=true,S0),replace(S0,linked(X^ V,Y)=false,S1).trans(S0, pass_t(X^V,P), S1) :-!,member(chain(X)=A,S0), opT(X^V,P,A,B),replace(S0,chain(X)=B,S1).trans([], pass_h(_,_), []):-!.trans([chain(X)=A|S0], pass_h(H,P), [chain(X)=B|S1]):-!, opH(H,P,A,B), trans(S0,pass_h(H,P),S1).trans([Fact|S0], pass_h(H,P), [Fact|S1]):-!, trans(S0,pass_h(H,P),S1).opT(X^ +,P,A,G) :- !, append(B,[Y,X^ +],A),(opposite(P,Y),!, append(B,[X^ +],G); append(B,[Y,P,X^ +],G)).opT(X^ -,P,[X^ -,P|B],[X^ -|B]) :- !.opT(X^ -,P,[X^ -,Y|B],[X^ -,P1,Y|B]) :- !,opposite(P,P1).% (PR)% (PL)% (NL)% (NR)opH(_,_, [X],[X]) :- !.opH(H,P, [X,G^V|B],[X|D]) :- G\=H,!,opH(H,P, [G^V|B],D).opH(H,P, [X,H^V,Y|B],[X,P,H^V,P1|G]) :-opposite(P,P1), X \= P1, Y \= P, !, opH(H,P, [Y|B],G).% (1R)opH(H,P, [P1,H^V,P|B], [H^V|G]) :-opposite(P,P1),!,opH(H,P, [P|B],L), L=[P|G].% (1L)opH(H,P, [X,H^V,P|B],[X,P,H^V|G]) :-opposite(P,P1), X \= P1, !, opH(H,P, [P|B],L), L=[P|G]. % (2R)% (2L)opH(H,P, [P1,H^V,Y|B], [H^V,P1|G]) :-opposite(P,P1),Y \= P,!,opH(H,P, [Y|B],G).P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377371% TEMPORAL PROJECTION -----------------------------------------execute(S,[]) :- !, write_state(S).execute(S,[A|As]) :- !,write_state(S),nl,write(’ACTION: ’),write(A),nl,(imposs1(A,S),!,write(imposs(A)),nl,fail; trans(S,A,S1),execute(S1,As)).% PLANNING: DEPTH-FIRST ITERATIVE DEEPENING -------------------find_plan(MinDepth,MaxDepth,Sol):-initial(S0),iterate_depth(MinDepth,MaxDepth,S0,Sol).iterate_depth(N,Limit,_,_):-N>Limit,!,fail.iterate_depth(N,Limit,S0,Sol):-write(’Trying depth ’),write(N),nl,get_plan(N,[S0],[],Sol); M is N+1, iterate_depth(M,Limit,S0,Sol).get_plan(_N,[S0|Ss],Plan,([S0|Ss],Plan)):- is_goal(S0),nl.get_plan(N,_,P,_):-length(P,M),M>=N,!,fail.get_plan(N,[S0|Ss],Plan0,Sol):-action(A),check_undo_actions(A,Plan0),\+ imposs(A,S0),check_linked_action(S0,A,S1,A2),trans(S1,A,S2),\+ violated_constraint(S2),get_plan(N,[S2,S0|Ss],[A2|Plan0],Sol).% If we passed an object tip linked to a hole, we pass the hole toocheck_linked_action(S1,pass_t(T,P),S2,pass_t(T,P)+pass_h(H,P)):-member(linked(T,H)=true,S1),hole(H),!,trans(S1,pass_h(H,P),S2).check_linked_action(S1,A,S1,A).% Reject states with two repeated crossings... h+,h+violated_constraint(S) :-member(chain(_Y)=L,S), append(_Pre,[X,X|_Suf],L).opposite_action(pass_t(T,P),pass_t(T,P1)):-opposite(P,P1).opposite_action(pass_h(X,P),pass_h(X,P1)):-opposite(P,P1).check_undo_actions(A,[A1|_]):-!,\+ opposite_action(A,A1).check_undo_actions(_,_).write_solution((T,P)):-reverse(T,T1),reverse(P,P1),write_states(T1,P1).write_states([],_):-!.write_states([S],[]):-write_state(S).write_states([S|Ss],[A|As]):-write_state(S),write_action(A),write_states(Ss,As).write_state(S):-member(chain(X)=L,S),write(chain(X)=L),nl,fail.write_state(_):-nl.write_action(A):-write(’ACTION: ’),write(A),nl.goal :- find_plan(0,7,K),write_solution(K).Appendix B. ProofsFor proving Proposition 7 we will first use some properties of QEL that will allow us to convert YALE into an equivalenttheory with the syntactic form of a normal logic program containing function symbols and variables. This normal program372P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377can be transformed afterwards into an infinite ground program that can be inductively split to compute the transitionsystem shown in Fig. 5.Proof of Proposition 3. Proved in [50]. (cid:2)Proposition 11. For any interpretation (cid:6)(D, σ ), H, T (cid:7) and any formula ϕ, we have (cid:6)(D, σ ), H, T (cid:7) |(cid:16) ϕ implies (cid:6)(D, σ ), T (cid:7) |(cid:16) ϕ.Proof. It easily follows by structural induction. (cid:2)Proposition 12. (cid:6)(D, σ ), H, T (cid:7) |(cid:16) ¬ϕ is equivalent to (cid:6)(D, σ ), T (cid:7) |(cid:16) ¬ϕ.Proof. By simply checking the conditions for satisfaction in HT. (cid:2)Lemma 1. The formula α : (ψ → ϕ) → ¬(ψ ∧ ¬ϕ) is an HT-tautology.Proof. For any interpretation M = (cid:6)(D, σ ), H, T (cid:7) we must prove both (cid:6)(D, σ ), T (cid:7) |(cid:16) α and that M |(cid:16) (ψ → ϕ) implies M |(cid:16)¬(ψ ∧ ¬ϕ). The first condition follows from the fact that α is a classical tautology. Assume now that M |(cid:16) (ψ → ϕ). Thisimplies (cid:6)(D, σ ), T (cid:7) |(cid:16) ψ → ϕ in classical logic, and this is equivalent to (cid:6)(D, σ ), T (cid:7) |(cid:16) ¬(ψ ∧ ¬ϕ) which, in its turn, isequivalent to M |(cid:16) ¬(ψ ∧ ¬ϕ) by Proposition 12. (cid:2)Lemma 2. The following formula is an HT-tautology:ϕ ∨ ¬ϕ →(cid:2)(cid:3)(ψ → ϕ) ↔ ¬(ψ ∧ ¬ϕ).(B.1)Proof. For any interpretation M = (cid:6)(D, σ ), H, T (cid:7) we would have to prove that both: (cid:6)(D, σ ), T (cid:7) |(cid:16) (B.1); and M |(cid:16) ϕ ∨ ¬ϕimplies M |(cid:16) (ψ → ϕ) ↔ ¬(ψ ∧ ¬ϕ). The first condition is trivial, since (B.1) is a classical tautology. To prove the secondcondition, assume M satisfies ϕ ∨ ¬ϕ. By Lemma 1, the left to right direction of the equivalence (ψ → ϕ) → ¬(ψ ∧ ¬ϕ) isan HT-tautology. For the right to left direction, it is clear that (cid:6)(D, σ ), T (cid:7) |(cid:16) (ψ → ϕ) ← ¬(ψ ∧ ¬ϕ) since this is a classicaltautology. Assume now that M |(cid:16) ¬(ψ ∧ ¬ϕ). By Proposition 12 this is equivalent to (cid:6)(D, σ ), T (cid:7) |(cid:16) ¬(ψ ∧ ¬ϕ) that in itsturn is equivalent to (cid:6)(D, σ ), T (cid:7) |(cid:16) (ψ → ϕ). We remain to prove that M |(cid:16) ψ implies M |(cid:16) ϕ. Assume M |(cid:16) ψ but M (cid:12)|(cid:16) ϕ.From the latter and M |(cid:16) ϕ ∨ ¬ϕ we conclude M |(cid:16) ¬ϕ. By Proposition 12 this is equivalent to (cid:6)(D, σ ), T (cid:7) |(cid:16) ¬ϕ and, as wehad (cid:6)(D, σ ), T (cid:7) |(cid:16) (ψ → ϕ) we get (cid:6)(D, σ ), T (cid:7) (cid:12)|(cid:16) ψ that by Proposition 11 implies M (cid:12)|(cid:16) ψ reaching a contradiction. (cid:2)Proof of Proposition 5. Since (DE) asserts that equality satisfies the excluded middle x = y ∨ ¬(x = y), we can applyLemma 2 to obtain that ϕ → x = y is HT-equivalent to ¬(ϕ ∧ x (cid:12)= y). But, by Proposition 4, the latter is HT-equivalentto ϕ ∧ x (cid:12)= y → ⊥. (cid:2)Proof of Proposition 6. Independently shown in [42,43]. (cid:2)Proof of Proposition 7. Note first that YALE has the form of a logic program excepting for the use of an existential quantifierin (INE), (DV) and (DV0) and the use of conjunction in (8) and (9). Using the propositions in Section 3 and previous resultsin this appendix, we can transform YALE into a logic program, we can then consider Π = gr D (YALE), that is, the (infinite)ground logic program resulting from replacing variables by all terms in the Herbrand universe D. An important observationis that this program can be split in the sense of the Splitting Theorem in [51], as any ground atom for Holds or Imposs(cid:17), s) withindexed by a situation s never depends17 on an atom indexed by do(a, s). Furthermore, atoms for do(a, s) and do(aa (cid:12)= ado not even depend on each other. This allows us to construct an inductive proof on the structure of situation terms.For instance, the initial state for situation S0 is uniquely fixed by (9). Then, by the splitting theorem, we can independentlycompute the states for do(load, S0), do(wait, S0) and do(shoot, S0) considering their corresponding ground rules.(cid:17)We have implemented these 1-transition programs into lparse/smodels. The resulting programs can be seen in Figs. 16and 17. From their execution we obtain all possible single transitions leading to the successor states of S 0 in Fig. 5. Thenwe could move to consider all situations with two actions do(wait, do(load, S 0)), do(load, do(load, S0)), . . . , and so on. Thecomplete formal proof would actually consist in assuming that the correspondence to the figure holds for all situationsterms with n actions do(an, do(an−1, . . . , do(a1, S0) . . .)) and applying splitting to prove it for terms with n + 1 actions.Finally, note that we get a unique state for S0 and all transitions are deterministic. This shows that YALE has a uniqueequilibrium model. (cid:2)17 An atom p depends on an atom q if there exists a rule with p occurring in its head and q in its body.P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377373% Equilibrium Situation Calculus (ESC) -------------------------#domain situation(S).#domain fluent(F).#domain inertial(IF).#domain noninertial(NIF).#domain action(A).% Types of fluentsfluent(IF).fluent(NIF).% We only consider 1 transitionsituation(s0).situation(do(A,s0)).% Unique value (UV):- holds(F,S,V), holds(F,S,W), V != W,range(F,V), range(F,W).% Inertia (INE)holds(IF,do(A,s0),V) :- not imposs(A,s0),holds(IF,s0,V),not released(IF,s0),not ab(IF,V,A,s0),range(IF,V).ab(IF,V,A,s0) :- holds(IF,do(A,s0),W), W!=V,range(IF,V), range(IF,W).% Default values (DV)holds(NIF,S,V) :- not ab2(NIF,S,V), default(NIF,V), range(NIF,V).ab2(NIF,S,V) :- holds(NIF,S,W), W!=V, range(NIF,V), range(NIF,W).% Default values for inertial fluents (DV0)holds(IF,s0,V) :- not ab3(IF,s0,V), default(IF,V), range(IF,V).ab3(IF,s0,V) :- holds(IF,s0,W), W!=V, range(IF,V), range(IF,W).% ’defined’ predicatedefined(F,S) :- holds(F,S,V), range(F,V).Fig. 16. Axioms of ESC for a single transition, from S0 to do( A, S 0), represented in an lparse/smodels program.Appendix C. A third puzzle: the Tricky DickThe Tricky Dick© is a puzzle designed by Richard Earson that was presented in the International Puzzle Party, London1999. The puzzle, shown in Fig. 18, consists of:• two wooden cylinders of different length connected in their bottom by a tiny piece of string,• a pair of metallic rings of different diameter (the large one cannot pass through the small one),• a string loop linked to the top of the small cylinder and embracing the large cylinder,• and finally, a string linked to the top of the large cylinder, crossing through the small ring and linked to the largering.As in the other puzzles, the goal is removing the small ring, so it gets free from the rest of the puzzle.In order to formalise the puzzle we will make several simplifying assumptions. For instance, although the cylinders canpass through the large ring, after playing a while with the puzzle we may soon discover that the real role of this piece isto be a top for the small ring. Thus, for the sake of simplicity, we will consider the large ring as a regular object, ignoringits hole.A second simplifying assumption is considering the two cylinders and the tiny string that links them in their bottom asa single piece. In fact, the mobility of this part of the puzzle is practically null and so, is equivalent to a single ‘U’-shapedwooden piece.374P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377% YALE SHOOTING SCENARIO -----------------------------% We define sorts for fluent values.% In this case, just Boolean fluentsboolean(true;false).% We define the fluentsinertial(loaded).range(loaded,Bool) :- boolean(Bool).inertial(alive).range(alive,Bool) :- boolean(Bool).% We define the set of actionsaction(load).action(shoot).action(wait).% Executability axiomsimposs(load,S) :- holds(loaded,S,true).imposs(shoot,S) :- holds(loaded,S,false).% Effect axiomsholds(loaded,do(load,s0),true) :- not imposs(load,s0).holds(alive,do(shoot,s0),false) :- not imposs(shoot,s0).holds(loaded,do(shoot,s0),false) :- not imposs(shoot,s0).% Initial state generation1 { holds(F,s0,VAL) : range(F,VAL) } 1.hide.show holds(X1,X2,X3).Fig. 17. YALE represented in an lparse/smodels program.Fig. 18. The Tricky Dick puzzle.Finally, the role of the string loop is quite different from the way in which we handle the longest string. Since this loopis permanently fixed, it can be actually seen as a (flexible) holed object.18To sum up, the sorts for this scenario would correspond to:Regular = {LargeRing},Hole = {Ring, Loop},Long = {Str, Post}and(C.1)where Post represents the U-shaped object formed by the cylinders and the tiny string. The initial state of the puzzle canbe schematically represented by situation S0 in Fig. 19.The domain dependent axioms would be:(cid:2)Holds(cid:2)linkedStr(cid:3)+−, Post, True, S0(cid:3)(cid:2)∧ Holds(cid:2)∧ Holdslinked(cid:2)(cid:2)Str+linkedPost, LargeRing−(cid:3), Loop(cid:3)(cid:3), True, S0(cid:3), True, S0,(TD1)18 In fact, this is directly related to one of the topics we are currently considering for immediate future work: linking the two tips of a string or makinga knot in it forms a string loop that can be handled as a holed object (we can define two faces, pass objects through the loop, etc.).P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377375Fig. 19. Solution of Tricky Dick.376stateS 0s1s2s3s4s5s6s7P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377chain(Post)+][Loop+][Loop+, Ring[Loop+, Loop[Ring+, Loop[Ring+, Loop[Ring+, Ring[Loop+][Loop+]+]+, Ring+]+]+]chain(Str)[Ring[Loop[Ring[Loop[Ring[Loop[Ring[ ]−]+, Ring−, Loop−, Ring−, Loop−, Ring−]−, Loop+, Ring−, Loop−, Ring−, Loop−]−, Loop+, Ring−, Loop+]−]−]+]Fig. 20. A formal solution to the Tricky Dick puzzle.next action(s)pass({Ring}, Loop−, Postpass({Strpass({Ring}, Looppass({Loop, Post+, Strpass({Postpass({Ring}, Looppass({Post+)+}, Ring−)−}, Ring−}, Ring+)−}, Ring+, Str+)−)−)−)(cid:3)(cid:2)Holdsnext(Str, 0), S0, 1CannotPass(LargeRing, Ring, ∅) ∧ CannotPass(LargeRing, Loop, ∅),(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holds(cid:2)∧ Holdsnext(Str, 1), S0, End(cid:3)towards(Str, 0), S0, Ring(cid:2)∧ Holds(cid:3)next(Post, 0), S0, 1next(Post, 1), S0, End−(cid:3)(cid:3).towards(Post, 0), S0, Loop(cid:3)+(TD2)(RL3)The solution is shown in Figs. 19 and 20, that respectively contain the graphical representation and the complete inter-mediate states (in terms of chain lists).The real interesting feature of this puzzle is that state s5 is not actually feasible in the real device due to rigidness ofthe post (i.e. the cylinders). The real puzzle solution implies a combined movement: the right side of the ring is rotatedand the Loop. However, theeffects of this combined movementpivoting on its left side and simultaneously embracing Postexactly correspond to state s6 where we “virtually” decompose this action into first passing the loop and Post, and thenpassing Postin a second step. (cid:2)++−References[1] O. Stock (Ed.), Spatial and Temporal Reasoning, Kluwer Academic, 1997.[2] A.G. Cohn, S.M. Hazarika, Qualitative spatial representation and reasoning: An overview, Fundamenta Informaticae 46 (1–2) (2001) 1–29.[3] A.G. Cohn, J. Renz, Qualitative spatial representation and reasoning, in: F. van Hermelen, V. Lifschitz, B. Porter (Eds.), Handbook of Knowledge Repre-sentation, Elsevier, 2008, pp. 551–596.[4] M. Souchanski, P. Santos, Reasoning about dynamic depth profiles, in: Proc. of the 18th European Conference on Artificial Intelligence (ECAI), IOS, 2008,pp. 30–34.[5] M. Bhatt, S. Loke, Modelling dynamic spatial systems in the situation calculus, Spatial Cognition and Computation 8 (1–2) (2008) 86–130.[6] R. Reiter, Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems, MIT Press, Cambridge, MA, 2002.[7] M. Shanahan, Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia, MIT Press, Cambridge, MA, 1997.[8] E. Davis, Representations of Commonsense Knowledge, Morgan Kaufmann, 1990.[9] F. van Harmelen, V. Lifschitz, B. Porter (Eds.), Handbook of Knowledge Representation (Foundations of Artificial Intelligence), Elsevier Science, 2007.[10] R. Davis, H. Shrobe, P. Szolovits, What is a knowledge representation? AI Magazine 14 (1) (1993) 17–33.[11] G. Brewka, Nonmonotonic Reasoning: Logical Foundations of Commonsense, Cambridge University Press, 1991.[12] M. Shanahan, The frame problem, in: E.N. Zalta (Ed.), The Stanford Encyclopedia of Philosophy, Fall 2008, http://plato.stanford.edu/archives/fall2008/entries/frame-problem/.[13] S. Hanks, D. McDermott, Nonmonotonic logic and temporal projection, Artificial Intelligence 33 (3) (1987) 379–412.[14] H. Simon, J. Schaeffer, The game of chess, in: H. Aumann (Ed.), Handbook of Game Theory with Economic Applications, vol. 1, North-Holland, 1992,pp. 1–17.[15] J. McCarthy, AI as sport, Science 276 (5318) (1997) 1518–1519.[16] P. Cabalar, P. Santos, Strings and holes: an exercise on spatial reasoning, in: 10th Iberoamerican Conference on AI (IBERAMIA’06), in: Lecture Notes inArtificial Intelligence, vol. 4140, 2006, pp. 419–429.[17] J. McCarthy, P. Hayes, Some philosophical problems from the standpoint of artificial intelligence, Machine Intelligence Journal 4 (1969) 463–512.[18] D. Pearce, A. Valverde, Quantified equilibrium logic and the first order logic of here-and-there, Tech. Rep. MA-06-02, University of Málaga, Spain, 2006.[19] J. McCarthy, Circumscription: A form of non-monotonic reasoning, Artificial Intelligence 13 (1980) 27–39.[20] V. Lifschitz, Circumscription, in: D.M. Gabbay, C.J. Hogger, J.A. Robinson (Eds.), The Handbook of Logic in Artificial Intelligence and Logic Programming,vol. 3, Oxford University Press, 1994, pp. 297–352.[21] J. McCarthy, Programs with common sense, in: Proc. of the Teddington Conference on Mechanization of Thought Processes, 1959, pp. 75–91.[22] J. McCarthy, Elaboration tolerance, http://www-formal.stanford.edu/jmc/elaboration.ps, 1999.[23] A.C. Varzi, Reasoning about space: The hole story, Logic and Logical Philosophy 4 (1996) 3–39.[24] R. Casati, A.C. Varzi, Parts and Places, MIT Press, 1999.[25] P. Santos, P. Cabalar, Playing with a puzzle in mereotopology, Spatial Cognition and Computation 8 (1–2) (2008) 47–64.[26] T. Morita, J. Takamatsu, K. Ogawara, H. Kimura, K. Ikeuchi, Knot planning from observation, in: Proc. of the IEEE ICRA, 2003, pp. 3887–3892.[27] J. Takamatsu, T. Morita, K. Ogawara, H. Kimura, K. Ikeuchi, Representation for knot-tying tasks, IEEE Transactions on Robotics 22 (1) (2006) 65–78.[28] K. Reidemeister, Knot Theory, BCS Associates, 1983.[29] N. Abolhassani, R. Patel, M. Moallem, Needle insertion into soft tissue: A survey, Medical Engineering & Physics 29 (4) (2007) 413–431.[30] R. Kowalski, M. Sergot, A logic-based calculus of events, New Generation Computing 4 (1986) 67–95.[31] A.B. Baker, A simple solution to the Yale shooting problem, in: Proc. of the Intl. Conf. on Knowledge Representation and Reasoning, 1989, pp. 11–20.[32] E. Sandewall, Features and Fluents. A Systematic Approach to the Representation of Knowledge about Dynamical Systems, Oxford University Press,1994.P. Cabalar, P.E. Santos / Artificial Intelligence 175 (2011) 346–377377[33] F. Lin, Embracing causality in specifying the indirect effects of actions, in: C.S. Mellish (Ed.), Proc. of the Intl. Joint Conf. on Artificial Intelligence (IJCAI),Morgan Kaufmann, Montreal, Canada, 1995.[34] M. Thielscher, Ramification and causality, Artificial Intelligence Journal 1–2 (89) (1997) 317–364.[35] M. Gelfond, V. Lifschitz, Representing action and change by logic programs, Journal of Logic Programming 17 (1993) 301–321.[36] M. Gelfond, V. Lifschitz, The stable models semantics for logic programming, in: Proc. of the 5th Intl. Conf. on Logic Programming, 1988, pp. 1070–1080.[37] C. Baral, Embedding revision programs in logic programming situation calculus, Journal of Logic Programming 30 (1) (1997) 83–97.[38] H. Turner, Representing actions in logic programs and default theories: A situation calculus approach, Journal of Logic Programming 31 (1997) 245–298.[39] D. Pearce, A new logical characterisation of stable models and answer sets, in: Nonmonotonic Extensions of Logic Programming, Proc. NMELP’96, in:LNAI, vol. 1216, Springer-Verlag, 1996.[40] D. Pearce, A. Valverde, Towards a first order equilibrium logic for nonmonotonic reasoning, in: Proc. of the 9th European Conf. on Logics in AI (JELIA’04),2004, pp. 147–160.[41] P. Ferraris, J. Lee, V. Lifschitz, A new perspective on stable models, in: Proc. of the International Joint Conference on Artificial Intelligence (IJCAI’07),2007, pp. 372–379.[42] P. Cabalar, Existential quantifiers in the rule body, in: Proc. of the 23rd Workshop on (Constraint) Logic Programming (WLP’09), 2009.[43] J. Lee, R. Palla, System F2LP – computing answer sets of first-order formulas, in: Proc. of the 10th Intl. Conf. on Logic Programming and NonmonotonicReasoning (LPNMR’09), in: Lecture Notes in Computer Science, vol. 5753, Springer, 2009, pp. 515–521.[44] P. Cabalar, D. Lorenzo, Logic programs with functions and default values, in: 9th European Conference on Logics in Artificial Intelligence (JELIA’04),Lisbon, Portugal, in: LNAI, vol. 3229, 2004, pp. 294–306.[45] V. Lifschitz, Answer set programming and plan generation, Artificial Intelligence 138 (2002) 39–54.[46] M. Shanahan, An attempt to formalise a non-trivial benchmark problem in common sense reasoning, Artificial Intelligence 153 (1–2) (2001) 141–165.[47] L. Morgenstern, Mid-sized axiomatizations of commonsense problems: A case study in egg cracking, Studia Logica 67 (3) (2001) 333–384.[48] V. Lifschitz, Cracking an egg: An exercise in commonsense reasoning, in: Proc. of the Symposium of Logical Formalizations of Commonsense Reasoning,1998.[49] S. Russell, P. Norvig, Artificial Intelligence: A Modern Approach, Prentice-Hall, 2003.[50] V. Lifschitz, L.R. Tang, H. Turner, Nested expressions in logic programs, Annals of Mathematics and Artificial Intelligence 25 (1999) 369–389.[51] V. Lifschitz, H. Turner, Splitting a logic program, in: International Conference on Logic Programming, 1994, pp. 23–37.