ELSEVIER Artificial Intelligence 80 (1996) 197-241 Artificial Intelligence A metatheory of a mechanized object theory Faust0 Giunchiglia a*b**, Paolo Traverso a~’ a Mechanized Reasoning Group, IRST - lstituto per lo Ricerca Scientijica e Tecnologica, 38050 Povo, Trento, Italy h Mechanized Reasoning Group, DISA. University of Trento, via Imana 5, Trento, Italy Received November 1992; revised July 1994 Abstract In this paper we propose a metatheory, MT, which represents the computation which implements its object theory, OT, and, in particular, the computation which implements deduction in OT. To theory. MT has emphasize this fact we say that MT is a metutheory of a mechanized object some “unusual” properties, e.g. it explicitly represents failure in the application of inference rules, and the fact that large amounts of the code implementing OT are partial, i.e. they work only for a limited class of inputs. These properties allow us to use MT to express and prove tactics, i.e. expressions which specify how to compose possibly failing applications of inference rules, to interpret them procedurally to assert theorems in OT, to compile them into the system implementation code, and, finally, to generate MT automatically from the system code. The definition of MT is part of a larger project which aims at the implementation of self-reflective systems, i.e. systems which are able to introspect their own code, to reason about it and, possibly, to extend or modify it. 1. A metatheory of a mechanized object theory [28], metareasoning the seminal work by Goedel topics ), in philosophical in formal reasoning. Work has been done in mathematical (e.g. Since studied research (e.g. [ 15,3,9,50] in many (e.g. are by no means exhaustive. Our interests are in theorem proving with metatheories. Similar theory OT to previous work has been one of the most logic [ 5]), planning in logic programming (e.g. in automated deduction, we have mechanized subfields of AI, such as mathematical [47] ) and so on. These citations [48] 11, programming logic (e.g. an object [ 11,541)) languages reasoning [ 41]), (e.g. * Corresponding ’ E-mail: leaF@irst.itc.it. author. E-mail: fausto@irst.itc.it. 0004-3702/96/$15.00 SSDlOOO4-?702(95)00002-X @ 1996 Elsevier Science B.V. All rights reserved 198 F Giunchi~lk F! Tucrver.ro/Artifi’cirrl Intelligence 80 (1996) 197-241 its me&theory MT. The mechani~tion and theorem prover called GETFOL [ 171. Unlike previous work, we have defined MT to be a metatheory this fact, we say that MT is a rnetatheory of a mechanized object can be intuitively described as follows: the fact that OT is mechanized. To emphasize theory, This requirement that takes into account inside an interactive has been performed l MT represents the computation which implements OT. The words “computation” and “represent” can be formally defined, even in Section 9.6). is In particular, GETFOL is if this function in this paper in a LISP-like by representability (but see discussion programming we mean not done developed speaking, formed by a (recursive) in MT of a corresponding CONJ is the HGKM function or (CONJ A) 1ct FALSE depending structure A, is a conjunction, where --+ is the symbol CONJ is represented where “A” is the name of A if A is a conjunction false. “representing” in the implementation on whether in MT by the predicate called HGKM [ 19,49,X5]. Roughly language that for any computation which can be per- in the code implementing OT, there is a deduction formula, and vice versa. Thus, for instance, of OT such that (CONJ A) e TRUE the formula A, recorded by the data in HGKM. Then symbol Conj such that hr Conj(“A”), for computation and br +Lmj(“A”) if this is MT has also been defined to be a metatheory of provability, i.e. to be about what is provable or not provable in OT. In this perspective the above requirement becomes: o MT represents the computation which implements deduction in OT. fandi that br Tz -+B, recording “T2 +B”) implements introduction fandi such is represented fandi(“rl +A”, is the HGKM function which rj, F2 -+ A A B of OT. Then fandi for instance, rule performing the above equality holds. So far, we have considered in OT the in- in Section 5, GETFOL (GAMMAI, (GAMMA=!, B)) us (GAMMA1 GAMMA2, A AND B), where (GAMMAl, A), (GAMMAZ, conjunction a sequent version of natural deduction (as described [ 461). We have (f andi Thus, ference implements A) B), (GAMMA1 GAMMAZ, A AND B) stand for the data structures rt +A, tion symbol where “r, + A”, “r2 + B”, “r,, r2 -+A A B” are the names theorems of OT. We have the further requirement constant for which rule applications. However, only if certain preconditions tion elimination of a logic, but it is always vents solved HGKM functions, these can be applied and fail when ment fandeltac elimination) the requirement implemented them from asserting non-theorems. inside In the implementation fail for failure, the conclusion the theorems in MT by a func- = “rl, rz +A A B”, in MT of the above rz + A A B” is the unique successftd functions which can be applied to apply a conjunc- in the definition on paper It pre- of GETFOL, we have and by defining new of the rules when imple- tactics failure. For instance, left conjunction to a disjunction. This fact is left implicit is defined, and f aif otherwise. Dually, of representability, MT has a constant this problem by using a data structure these cannot be applied. Primitive returns when fandel the code of theorem provers. the total version of inference the value returned by fandel fail and new function to satisfy sym- tactics, which return are satisfied, e.g. rules by returning rules are partial it is impossible called primitive implements an explicit inference that “rt, in order (which E Giun~~~~ti~, fl Traver.~~~Art~~jal ln~el~i~en~e 80 (19961 191-241 199 bols, e.g. j’andeltac, with ~-M-I’ fandeltac( “r -? A A B”) = fandel( “r -+A A B”) and ~~ fandeltac( “r -+ A V B”) = fail. 2. Exploiting a metatheory of a mechanized object theory Since MT is a metatheory about deduction in a mechanized object theory, it has two main features: ( 1) We can construct ground wffs and terms whose structure there are wffs, stating respondence with the (computation) ticular, structure can be put in one to one correspondence with the computation the object tree constructed the provability of an object level proof steps which prove the theorem at the object itself, is in one to one cor- level. In par- level theorem, whose tree of (2) The symbols occurring in such ground wffs and terms have corresponding bolls in the underlying HGKM mechanization. representing symbols to fandeltac), sponds cability of inference denoting rules and primitive r~pre~nting (e.g. Conj corresponds for predicates inference rules In particular, tactics sym- this holds for function (e.g. fandeltac corre- to the appli- to CONJ), and for constants ~r~onditions symbols of the language and theorems of OT (e.g. “A” corresponds to A). content, theorems of object then asserts rules). Notice logic inference The firs{. feature makes to give tactics a procedural in a procedural metalanguage, i.e. to use them to assert object in CIT. This process of compilation from that used in most of the previous tactics, program tactics. The second tactics are programs written these latter tv express and prove tactics, where by tactics we it possible tactics (namely, possibly mean formulas of MT which specify how to compose primitive that in this paper, the word failing applications literature, e.g. in “tactic” has a different meaning [ 14,3 I, 32,441, where e.g. feature makes in ML 1341. We call level it possible (possibly proofs). This can be done in two ways. Tactics can be interpreted, theorems i.e. they c,an be given as input in OT the proved to an interpreter which theorem. Tactics can also be compiled into HGKM code which can then be executed to prove the combination to define a process, called lifting, which can be intuitively seen as the reverse of flattening, and which allows from the code implementing OT. us to generate MT (its language and axioms) a process where the metatheory tactics representing in the code. As a result, derived like the rest of the system and used to shorten subsequent proofs. at the at the theory is called fattening. Finally, it possible of the first and the second features makes is lifted from the code, and it is used to prove theorems which are then compiled down, or possibly rules can be executed Logical manipulation system in Fig, 1 (this figure was first presented efficiency nized object code writing and me&theoretic allows us to bridge advantages. From a computational theory allows us to compose level corresponds cycle, which can be iterated, represented in [4] >. This approach provides considerable point of view, a metatheory of a mecha- the output of theorem proving. From an intellectual point of view, it the gap between that is inside a real inning It has therefore been possible inside a unified environment to define and implement level. This reasoning is schematically transformation in practice, to program interpreted interesting system, starting 200 F: Ciunchi~lia. P Traverso/Artiftcial Intelligence 80 (1996) 197-241 ‘____~___“__“______~____________.___________~____________~_~______________~______~_~__, GETFOL METATHEORY Metalevel Theorem Proving Safe System Extension I.._____________________________________~~~~_~___________~__~~_~_~__________~__________. GETFOL SYSTEM CODE Fig. I. The lifting-reasoning-flattening cycle. and the computation which systems, deduction towards “really” and thus, possibly, extend or modify, correct way. self-reflective implements i.e. systems able deduction. This seems a first step about to reason deductively in a provably strategies reasoning their underlying 3. The project structures structures as an attempt and simulation are the mechanizable system and deduction in the code of a mechanized of the FOL system, described simulation [ 541. It can be described This project builds on and extends Richard Weyhrauch’s work on the FOL system, (where, analogue to push the idea of in the system point of view, GETFOL has been developed on top of a in [ 271. GETFOL has, with minor vari- some described here, to allow for in particular his work on Meta, reflection principles, using Weyhrauch’s terminology, of the notion of model) linking computation itself. From an implementational reimplementation ations, all the functionalities metatheoretic with Weyhrauch’s work can be seen by analyzing anization, The code mechanizes OT by construction. The code of CYT has been developed a finite that MT represents in detail terpreted constants structures implements OT. In fact, as described more the in- in the HGKM data implementing UT. Thus, for instance, “A A B”, “rl, r2 + A AB” denote A A B, theorem proving. From a conceptual point of view, the close connection the relation between UT, its mech- in Fig. 2. MT is a metatheory of UT by construction. in MT denote objects of OT which are recorded in Sections 6 and 9.1, this amounts of the model of MT, this achieves (and partial) presentation the computation which of FOL plus extensions, and MT, as shown two facts. First, to the following the requirement to be E Giunchiglia, J? Traverse/Artificial Intelligence 80 (1996) 197-241 201 MT = Metatheory( OT ) Code = Model( MT ) Code = Mechanization( OT ) Fig. 2. OT, MT and the code. r, , r2 +A A B, as recorded by the data structures (A AND B), (GAMMA1 GAMMA2, A AND B) , respectively. Second, respond words, HGKM functions are finite presentations application via the HGKM evaluator, by fandeltac. function and predicate symbols of MT cor- In other of the corresponding is computed, the extension of fund&m their set-theoretic meaning. in MT. Thus, for instance, symbols which compute of the interpretations to HGKM function the interpreted symbols object theory lifting, However the idea of having a metatheory of a mechanized is new, as tactics. in to the point where its code flattening and of using MT for synthesizing version of the tactic interpreter are the ideas of performing Indeed, even though FOL had a preliminary [ 541 and more in detail in [ 23]), FOL was never developed could be directly used in the metatheory, Most of the examples which can be found in the literature ad hoc and dedicated coding. Finally, unlike Weyhrauch’s metatheories 55]), we have proved machinery. We have flattening assert non-theorems, (see discussion interpretation. required some (often minor) (e.g. in [ 26,54, structure the lifting, that tactics, when executed, will not is correct implementation the correctness of MT and of the use of the simulation in fact shown under the hypothesis that MT, OT and that the underlying its mechanization, in Section 9.6). interpretation for instance to perform (described processes are such tactic and Starting from the complete reimplementation of the FOL system described influencing strongly in [ 271, this each other. of CYI, i.e. the production of code of of MT. These from computation project has been developed as two parallel subprojects The goal of the first subproject was the mechanization which implements OT and which, at the same time, constitutes the model of MT. The goal of the second project was the development two projects have influenced each other in the sense that the mapping to deductimon and vice versa (and, as a consequence, e.g. the kind of tactics which can be written, how they can be executed and also the definition of the lifting and flattening depends on the precise form of the axioms of MT and of the HGKM functions functions) mechanizing OT. The problem we had to face many times was that it was impossible to map MT into the code, and vice versa. This has required multiple major recodings of MT. The of GETFOL (which is more than one megabyte of code) and redefinitions a finite presentation 202 F: Giunchiglia, P Traver.w/Artijicial Intelligence 80 (1996) 197-241 a conjunction, to do, e.g., test for theoremhood, e$i%ziently. It is our committment to prove theoremhood of object level theorems, synthesize The constraint on MT is that it must be usable effectively, and difficult question we had to answer any time this happened was which interesting between MT and the code had to be modified, and how. The constraint on the code is assert a theorem, that it must do what it is supposed not to develop GETFOL as compute for a toy implementation. example, tactics, reason about in defining a metatheory MT with the structure of wffs. Currently we have succeeded all the desired properties and, therefore, we have also formulated to the code mechanizing OT. We have recoded all of GETFOL be followed when writing according process has lead to a situation where axioms, and where MT contains only tactics. (very slowly converging) large parts of the code of GETFOL are really facts needed like (and look alike) to prove and execute to this general schema. This a general schema the necessary 4. Contents of the paper is structured This material its mechanization. that it is a metatheory The goal of this paper is to describe MT, the sense of GETFOL are discussed only as follows. of a the goals described above. mechanized object theory, and the extent to which it achieves for what is needed The details of the implementation In Section 5 we describe OT to understand MT. The paper its and mechanization and its connection with the code mechanizing OT. In Section 7 we show how MT can express and prove tactics. In Section 8 we show that tactics can be given a procedural the code of interpreting GETFOL. In Section 9 we give some technical the correctness of our approach. The tactics considered Section 10 we discuss reasoning further work aimed at giving MT the desired expressibility In Section 11 we discuss that guarantee in this paper are very simple. In and in Section 6 to describe MT, i.e. some theorems the related work. is then used or compiling interpretation capabilities. by either results, them into 5. OT and its mechanization the set of axioms and the set of inference The object theory OT is a triple OT = (&A_x,R), language, first order classical natural deduction for A, >, V and I, as shown abbreviation of rules which contains rules, monadic deciders, and results can be easily generalized. (ND) calculus. We consider where L, dx and R are the rules of OT, respectively. OT is a rules in Fig. 3 (A, B, C, . . . are well formed formulas, 1A is an of OT in GETFOL allows for a richer set inference rules for other connectives, tautology checkers, a rewriter, a semantic simplifier. Definitions rules for equality, derived the inference for A 3 I). The implementation For various reasons, e.g. efficiency of the implementation the dependencies theory, GETFOL keeps the GETFOL rules as rules on sequents with introduction sequent. Fig. 4 describes sets of formulas). the rules of Fig. 3 in sequent notation rules, interchange that, of the structural (Notice locally to formulas. This allows one and elimination and elegance of the proof to see in the post (r, A,. . . are finite are and contraction E Giunchiglia, F! TraversdArtijicial Intelligence 80 (1996) 197-241 203 AE) A4) AAB - A A&) AAB B 3 E) A A>B B VExt) y f /If) >1:, Vl 3’ a) A B - AAB [Al B - A>B A - VxA; [A 3 J-1 -L A 1,) VI has the restriction that a must not occur in any assumption A depends on. Fig. 3. OT inference rules presented in ND form. Al) rdA AdB r,A+AAB > I\, r,A +B ’ r+A>B VI x’ a) r-A r +VxA”, AE) 1 r+AAB T+A A&) r+AAB T+B 3 E) r-A A+A>B r,A+B V’Ext) r --+VxA r--,A; J-C) T,A>_L +I r-A where VI has the restriction that a must not occur in r. Fig. 4. OT inference rules presented in sequent form. by sequent we mean a pair (r, A), also written not needed as we have sets, while weakening Technically, “formula of the sequent” and r are sequems of the form A + A. We suppose that > I always discharges A (see Fig. 4). This can be easily generalized. We take the notion of deduction defined is the set of “dependencies and cut are derived inference rules.) r -+ A, where A is the of the sequent”. Assumptions the assumption talking about OT, we also call a deduction of a formula A depending on the possibly empty set r of formulae, (tree) of the sequent r + A. We say that r + A is a theorem of OT, or that a proof r +A if there exists a proof (in OT) of r + A. We is provable write b-r 1’ + A to mean that r + A is provable in OT, if and only in [46]. When in OT. 204 E Giunchiglia, P: TraversdArtificial intelligence 80 (1996) 197-241 if it fails, and it a listen-act-respond GETFOL’s top level implements the rule, produces an error message the proof built so far, i.e. the proved can be found in [ 201. Here we mention only the relevant loop. It keeps, as part of its internal theorems and the reason why they have state, been proved. The proof can be inspected and manipulated by the user (via appropriate correctness preserving operations). When the action requested by the user is an inference rule application, GETFOL applies to the current proof otherwise. The details of the mechanization adds the proved theorem in a following paper. A somewhat detailed but still incomplete of GETFOL will be given issues. A first issue description the rest (e.g. I/O, statistics, is how to separate (possibly administration rules, changing for different to and at the appropriate the consider only code implementing to consider both. As a second example, when reasoning about proofs, whether wffs are implemented using pairs or lists is irrelevant. More interestingly, synthesizing wff. Finally, GETFOL has a lot of state (e.g. the proved into account the code mechanizing issue facilities). A second applications) of the system level of abstraction. Thus, for instance, implementing as Sections 6 and 7 will make clear, to be a of what it means theorems) which must be taken the logic from is that MT must describe a subset natural deduction, or vice versa, or it must be possible tactics does not require an explicit axiomatization inside MT and, in particular, when lifting MT. and inference it must be possible the decision procedures without considering functionalities the code details for instance that (e.g. or inessential rules. Consider according is idealized to the general in the sense to see in some detail the implementation For the goals of this paper, it is sufficient the reason why it has been generated). However the GETFOL implementation rules in GETFOL, also including schema described of the inference of AE!, as reported in Figs. 5, 6 and 7. All the inference the deciders, have been developed in the Figs. 5, 6 and 7. This schema level a lot of low implementational failures, faithful each recording to the link between MT and the HGKM code, e.g. function names, function calls, parameter passing, access to state. Let us start with it does not consider the fact that the code has many it is completely i.e. it does not read nor access state. The code of this kind is called “computation machinery”. AEl is implemented primitive that they take as input takes a theorem takes a theorem or a failure failure. fandel rules and primitive the same types of objects in our terminology) in output. Thus fandel and returns a theorem while f andeltac tactics are uniformly they produce and returns a theorem or a is the corresponding in our terminology) tactic. Inference in Fig. 5. All never returns is functional, in the sense by f andel. this code the code fandeltac (a fact (a tat typed fail. Fig. 6 reports the code modifying the state of the system, i.e. tacfproof Code of this kind is called “update machinery”. -update. that part of the state which keeps the theorems and the failures generated so far, (which updates tactic). -update and failures and one to tacf proof to be processed by the current program -add-tat -update tacfproof-update and updates the current proof) or updates the current proof, via a function (which prints an error message the standard output, via a function call in the user defined standard call to fproof-add-fact fproof updates via a function call to f proof the stack of theorems -update fproof (which updates to print-error-message output). E Giunchiglia, P Traver.so/Artifcial Intelligence 80 (1996) 197-241 205 (DEFLAM f andeltac (tat) (NOT (FAIL tat>> (IF (f andel fail)) ! tat) (DEFLAM f andel ! (fact) (CONJ fact) (IF (f andel fail) fact) (DEFLAM f andel (fact) (f act-mak (lfaud (f act-get-deplist (f act-get-wff fact)) ) > fact) Fig. 5. Computation machinery for left conjunction elimination. (DEFLAM tacfproof -update (tat) (SEQ (tacfproof (fproof -add-tat tat) tat) > 1 -update (DEFLAM fproof-update (tat) (IF (FAIL tat) (print-error-message (f proof -add-f act tat) ) ) tat) Fig. 6. Update machinery for proof state and I/O state. The code implementing the computation code implementing machinery”. prompt. the user interface FANDEL# is called when and the update machinery is called by the (see Fig. 7). Code of this kind is called “top level to the GETFOL the following command is typed GETFOL: : FANDEL <fact-name> ; GETFOL: : is printed by the system. The that the user wants to apply AEl and activates FACT# parses a fact from the standard calls fandel! is called by the program or a theorem) the program from the data structure (and not faudeltac) tactic recording top level, once parsed FANDEL, understands the routine it, i.e. FANDELK implementing input, or it aborts if this is not possible. FANDEL# as FACT# never returns a failure. Dually, FANDEL interpreter; TAC extracts the “current” object (a failure the objects which must be processed by tactic being executed, or it aborts if this is not possible. 206 E Giunchi&, P. Traver.w/Artijicial Intelligence 80 (I 996) 197-241 (DEFLAM FANDEL 0 (tacfproof -update (fandeltac (TAC) > > > (DEFLAM FANDEL# 0 (fproof-update (fandel! (FACT#))) > Fig. 7. Top level user controlled machinery for left conjunction elimination. 6. MT and its mechanization MT and OT are two distinct theories. Their implementation within GETFOL exploits [ 171. MT is a triple MT = (ML, Mdx, MR) where rules the set of axioms and the set of inference If LY is a formula of MT, In the following in MT (is a theorem of MT). facilities and MR the GETFOL’s multitheory ML, Mdx are the language, of MT, respectively. MT is a first order classical ND calculus. then br LY means of this section we describe ML, Mdx, MR. consider the axiomatization complete definition of ML of only and Mdx that (Y is provable two inference is given in Appendix A. In order to keep the paper shorter, we rules of OT, namely A& and VZ. A 6.1. The language ML to ML constant constants. a new individual variable x is “x”, the string representing In MT it must be possible Let us start with the individual the quotation mark name of the individual that of the formula VxA to refer to certain for any object are the “quotation mark names” of the objects of OT [24] and an object with double quotes. Thus, constant c is “c”, that of the that of the sequent is “VxA”, terms, variables, “objects In this paper we use names only for sequents, and constants of OT (from now on, called generically objects of OT. We do this by adding of OT. These constants are written by surrounding for instance, individual r +A individual (of OT)“), which we write as s, t, x, a and c, respectively. constant fail which denotes fail the other constants of MT, it corresponds mechanizing OT. For each inference symbol have an appropriate In ML, we have also a (see Fig. 5). to all by the code tactic of OT we is not the quotation mark name of an object of CYT. However, analogously rule and corresponding in MT: failure, as recorded by the data structure to a data structure manipulated is “r +A”. parameters primitive function fail AEi : fandel,fandeltac of arity 1, bfl : falli,fallitac of arity 3. for all the other to what happens to the HGKM functions Analogously correspond predicate = for equality, a unary predicate Set which holds of sequents, a unary predicate T for theoremhood, a unary predicate Fail which holds of fail, a predicate Tat which holds of fail and the theorems of OT, and inference and f andeltac rules, fandel and fandeltac (see Fig. 5). ML fandel has a E Giunchiglia, P Traverse/Artificial Intelligence 80 (1996) 197-241 207 l\E, : Conj of arity 1, VI : Pur of arity 1, VI : K2r of arity 1, VI : NoFree of arity 2. As for al.1 the other preconditions reified in the HGKM code, Conj corresponds to function CONJ; Fail corresponds the sentential constants T (which the HGKM boolean to FAIL (see Fig. 5). Finally, ML is also an axiom) and I for truth and falsity, contains respectively. MC has also individual variables and parameters written x, XI, x2 . . . and . . respectively. The context always makes clear whether we are talking of a,al,a;?. term variables and parameters of OT or of MT. Finally, MC contains (We write constructors if then else in boldface if A then t] else t2, where A is a wff and the readability of formulas.) tt , t2 are terms. the conditional to increase Within GE:TFOL, the correspondence between the HGKM data structures and functions analogue) the (mechanizable functional, predicative) constants of MT is constructed by using the [ 17,541). As described allows the commands ATTACH and MATTACH in [ 541 and hinted structure machinery in structure machinery and, in particular, in detail the user to define and use, within and the (individual, simulation in Section 3, the (described simulation the system, a finite presemation of a model of the theory under consideration. ATTACH and MATTACH, in function implement particular, interpretation g [ 131. MATTACH takes a pointer to the data structure m recording the constant m of MT and a pointer to the data structure o recording the object o of OT and stores the pair (m, o) as part of the state of the system. The idea is that the pair (m, o) records the fact that g(m) = o. Thus, if m is the individual constant the fact that “0” is the (quotation) mark name of “o”, then symbol fm, then the o. Analgously, pair (f m, f o) , where f o is an HGKM function symbol, records the fact that the extensional of fm. Following Weyhrauch’s (set-theoretic) of f o is the interpretation and terminology, we call the pair (m, o) an attachment we say that m is attached pair, or simply an attachment, the pair (“o”, o) records if m is the applicational (abstractly defined) (abstractly defined) characterization or predicative) of the model (functional to o. 6.2. The axioms MAX The axioms of MT have been devised to be lifted from the mechanization of OT. the mechanization However work correctly, namely sequents. is based on two implicit assumptions which make everything that no sequent is equal to fail and that all theorems are Vx T(sec(x> A Fail(x)), Vx (T(x) >Sec(x)). (1) (2) is implemented FAIL argument definition of Fail. computes as an HGKM boolean function which returns TRUE when its fail and FALSE otherwise. We can therefore lift the following 208 E Giunchiglia, P Traversn/Art#cial Intelligence 80 (I 996) 197-241 Vx (Fail(x) ++ x =fail). (3) (roughly speaking) is a partial (Fig. 5). f andel the computation machinery only with sequents whose wff is a conjunction. Consider called by f andeltac is implemented LISP CAR). Thus, may return a wrong value (e.g. with AVB, the left disjunct A) or it may even abort (e.g. any time its argument is not defined, fandeltac f andel is an HGKM atom). For all the inputs where f andel This fact is captured by the following axioms. to sequents whose wff is not a conjunction, the correctness of the implementation, as an HGKM CAR (which behaves returns never returns In order to guarantee In practice, f andel if it is applied the same as the function and it is fandel fail. fail. V.x 7 fandel( x) = fail, Vx1Vx2Vx3 7 falli(xl ,x2, x3) = fail. (4) (5) All the computation machinery (which, as pointed out in Section 5, is functional) is the following axioms. basically lifted to MT with a one to one mapping. This generates vx (TaC(Xl) > fandeltac(x~) = if +ail(xl) A Conj(x,) then fan&& x1 ) else fail ) vx,vx2vx3 (72X(x,) 3 fallitac( XI, x2, x3 ) = if -+ail(xl) A Var(x2) APar(x3) ANoFree(x3,x~) then fafli( XI , x2, x3 ) else fail ) (6) (7) Notice is defined that fandeltac other hand, has no corresponding is unfolded as f andel! other functions which think of possible applications Notice also that fandeltac hypothesis 7&(x,) which, on the in terms of the function in the lifting, f andel ! symbol fandel! in MT. Indeed, into its definiendum. An explicit definition of fundel! is useless for our goals composed with is not hard to this is not one of our current goals.) the returned by TAC. This generates of fandel!, however, to objects is applied take and produce objects of the same kind. and cannot be uniformly and returns a tat takes a fact in axioms fandel!, (It -update updates Consider tacfproof the update machinery has not been given because that part of the state of GETFOL which stores the theorems and the failures generated so far. Dually, extracts objects TAC (whose definition This part of the state of GETFOL from the system state updated by tacfproof set of approximates (in the set of theorems of OT union failure, see objects represented and TAC to Tat. This form Section 9.1) . This causes act and -add-f of lifting can be done in general. For instance FACT#, which are both lifted to a global variable which stores the current proof, i.e. the theorems proved so far. This global the sense that in MT by Tat (namely -update. a subset of) it applies also to fproof the lifting of tacfproof to T. In fact fproof the (non-recursive) adds its argument it is not relevant) it contains -add-fact -update (6) and (7). (Fig. 6). E Giunchiglia, P: Traver.w/Artijicial Intelligence 80 (1996) 197-24I 209 ,presentation of) the (non-recursive) is that the operations set of theorems of UI, a given set must be lifted this does not mean that f proof variable approximates by T (see Section 9.1). The intuition part of the system state which approximates representing such set. However (the finite are (the finite presentation of Tat. In fact none of them is attached to T or Tat (see Section 6.1) . The fact that, for instance, FACT# aborts for some object, It might simply be a theorem which does not mean we has not yet been proved. Within have two possibilities. Either print-error-message i.e. we have a failure, is called. This generates or f proof in MT represented that read and update some to the symbol act or FACT# are or TAC the interpretation of) the interpretation is not a theorem. -update of T or that tacfproof-update the following axiom. (and also tacfproof that the object --add-f act is called, -update) fproof -add-f ‘v’x (Tczc(x) H T(x) V Fail(x)). (8) the top level machinery (Fig. 7). Once understood how to lift the update the lifting of the top level machinery becomes a one to one mapping. Thus to FANDEL) are lifted to the following (FANDEL#, which could be lifted very much in the same way, has not been lifted Consider machinery, FANDEL and FALL1 (which axioms. for the same reasons as f andel is defined analogously ! ‘s.) ‘dx (k(x) > Tac(fandeZtac( x) ) ) , Vx~‘v’x2b’x~ (Tac(xl) > TaccfafZitac(x~,x2,~3))) (9) (10) Finally, ‘we have to describe the base case for deductions. Let A and B be wffs of OT. T(“A +A”), T(” -+A”), if --*A E Ax. (11) (12) following in OT and, as discussed performed by the basic inference The above axioms describe deduction tactics. However MT must also have axioms describing in Section 7, allow us the to express and synthesize rules. In syntax of OT, and the syntactic manipulation used to lift principle, we could generate such axioms statements about the the axioms above. This would allow us to use and prove universal formula of OT. However syntax of OT, e.g. about what it means for what concerns the main goal of MT to some the syntax of OT, to be able to discriminate arguments, as Section 9.3 will show, it is sufficient to have the ground version of such axioms and of all their consequences. Let a and x and variable of OT, A and B be wffs of OT, r be a finite be any individual set of formulas of CYT, c be any individual constant of OT and 5 be any object of OT. Then in particular between when a tactic, applied the same methodology to be a well formed are axioms of MT. is to reason about In this perspective, fails or succeeds. the following tactics and, parameter fandei’( “r + A A B”) = “r + A” falli( “r + A 31, bGx’_, (cay = ssr +vxA;“, where a does not occur in r (13) (14) 210 I? Giunchiglia, F! Traver.sn/Artijicial Intelligence 80 (1996) 197-241 Par( “a”) TPar( c) , if c is fail or “5” and 5 is not an individual parameter of (YT Var( “.a?‘) -Var(c), if c is fail or “5” and 5 is not an individual variable of OT 1 Cl =c2, if ci and c:! are distinct individual constants Conj( “r + A A B”) -Conj( “I- + A”) , if A is not a conjunction NoFree( “a”, “r --) A”), if a does not appear in r TNoFree( “a”, “I’ + A”), if a appears in r &c( “r + A”) +ec( “c’), if 5 is not a sequent of OT (15) (16) (17) (18) (19) (20) (21) (22) (23) (24) (25) (ground) consequences (and all their and to exploit the value denoted structure machinery e.g. Conj(fandel( “ * (A A the of the model of MT. This the command SIMPLIFY. SIMPLIFY takes in input a term or a wff ( 1 1 )-( 25) represent an infinite set of ground axioms. This is not a problem as in the of MT such axioms are really never asserted. For what concerns actual mechanization axioms ( 13)-( 25) B) A C”))), the idea is to use the simulation fact that the code implementing OT is a finite presentation is achieved through and, as a first step, it computes see Section 6.1). In the case of a term, the denoted value is by the set of attachments, its therefore SIMPLIFY asserts an element of the domain, term itself. In the case of a wff, the denoted value quotation mark name and the input in the is FALSE or TRUE; in the first case SIMPLIFY asserts ( 11) and ( 12) cannot be asserted using SIMPLIFY, since, second, that T (the reason being as seen in Section 6.1, T is not attached should have to be attached for first order logic. However this would make us lose the termination of SIMPLIFY, and we want to avoid this). They the fact that for any theorem s of OT (and, as a particular are asserted by exploiting case, for any axiom and assumption) we have br T( “s”). This is explained in detail in Section 9.3. to a theorem prover complete in MT the equality between in MT the input wff itself, in the defined model to any HGKM function its negation. Axioms (as constructed (e.g. +A) Notice that an object level sequent (e.g. “ +A”) (e.g. fandef( “ -+ A A II”)). We call the set of complex in MT by its quotation mark is denoted and by other terms that can be proved equal to its quotation mark name name terms that are provably equal to the quotation mark name of an object of CYT, the structural descriptive names of such object. In particular, an object level theorem can be given a structural descriptive name for each proof proving that name of 4A the fact ---) A can be obtained by applying A& to + A A B. Another structural descriptive the conjunction “ +A”, “ + B”) ) where fandi builds A II”) expresses it. For instance, is fandel(fandi( fandel(“ *A I? Giunchi&a, F! TraverdArtificial Intelligence 80 (1996) 197-241 211 (all names it is possible to give any object of two sequents. Notice moreover marks SIMPLIFY structural descriptive to their corresponding done very efficiently, names and taking To conclude, that writing quotation mark names using quotation is an option. GETFOL has no hardwired naming machinery. Using MATTACH and in OT the desired quotation mark and the structural descriptive names being provably equal in GETFOL is table lookup in the case of quotation mark in the case of structural descriptive names. that MT does not represent all the code of OT to lift only a is quite useful as it but only subset of the inference allows one to use the code as a storage of axioms and to extract them selectively. th.e small part that it reasons about. In particular to a simple time in their length quotation mark name). Finally, notice in GETFOL. This feature rules implemented it is important it is possible that naming amounting to notice linear Let us consider now some examples of use of the simulation all the examples of this paper we take r as a shorthand shorthand for the assumption Vx(A(x) AB(x)) of Vx(A(x) s’ as a shorthand of Vx(A(x) 3 B(x)); dVx(A(x) structure machinery. In for Vx( A( x) A B(x) ) ; s as a AB(x)); A as a shorthand 1 B(x)) +Vx(A(x) > B(x)). Example 6.1. Let us consider the following term: fulli(jhdef(fulle( “s”, “x”, “a”) ) , “x”, “u”). (26) From axiorns (13) and ( 14) (see also axiom aboutfulle in Appendix A) we can prove fulli(f;zndeZ(falle( I‘s”, “x”, “a”) ) , “x”, “u”) = “r -+VxA( x)” (27) theorem proving in MT. The same by command SIMPLIFY, when executed over (26)) runs a routine, called simplify, returns model. result can be achieved with SIMPLIFY. The which in the defined of the input expression (e.g. a term, a wff) the interpretation simplif yCfalli~undelCfulle( “r +Vx( A(x) A B(x) )“, “x”, “#) ), “x”, GL#) ) simplifyCfandel(&lle(. . .))) y( “x”) simplif y( “a”)) = (simplify(falli) simplif = (SimplifyCfalli) simplify(“x”) = (simplif y(fulli) SimplifyCfalle) (simplify(@ndel) simplify(“u”)) (simplif simplify(“r yCfandel) ( simplifyCfaUe(. . .))> simplif y( “x”) simplif +Vx(A(x) y( “u”))) simplif A B(X))“) y( “x") simplify( “a")) y(falli) r+Vx(A(x) (simplif y(fundel) ( A B(x)) x a)) simplify(“x”) simplify(“u”)) (simplify(fundel) r *A(a) A B(U)) y( “u”) > r +A(u) y( “x”) simplif (fandel “x”) simplify(“u”)) r dA(u) x a) T+A(u) A B(U)) simplify(“x”) simplify(“u”)) = (simplif falle = (simplify@lli) simplif = (simplify@lli) simplify( = (simplify&Eli) = (falli = l’+VxA(x) 212 E Giunchigliu, t? Truver.w/Art$icial Intelligence 80 (I 996) 197-241 SIMPLIFY computes in this case “f +‘dxA(x)“, of MT, in this case (27). the quotation mark name of the expression computed by simplify, and asserts its equality with the input term as a theorem Example 6.2. The functions occurring can be applied only to arguments where these functions are defined. To take into account failure, SIMPLIFY must be executed over terms containing primitive in (26) are partial. As a consequence, SIMPLIFY tactics. simplif = simplif = simplif = fail yCfalfituc(fundeltuc(falletuc( yCfullituc(jundeltuc( ycfallituccfuil, “x”, “a”) ) “s’“, “x”, “~2”) ) , “x”, “u”) ) “A + A (a) > B(u) “) , “x”, “u”) ) Therefore, SIMPLIFY, asserts the following theorem in MT: fullituc(fandeltuc(jXetac( “s”‘, “x”, “~2’) ) , “x”, “u”) = fail Example 6.3. In MT we can prove the following wff. Xonj(falle( “s”‘, “x”, “u”) ) (28) We execute SIMPLIFY over Conjvalle( “s”‘, “x”, “a”) ). simplif y( ConjCfaUe( “s”‘, “x”, “u”) ) ) = simplify(Conj(“A+A(u) = FALSE > B(a)“)) Since simplify this case (28). returns FALSE, then SIMPLIFY asserts the negation of the input wff, in 6.3. The rules MR and elimination The set of rules of MT, MR consists of the same rules as OT, described in Fig. set of rules for equality and the in Fig. 8. Rule states that from P (if A then tl else t2) and A [ TA], we can derive P (tl ) from A and a deduction of the fact that A is is a theory 3, for the language ML plus a sound and complete rules for the introduction if E [if E,] [ P( rz)]. Rule P(t2) discharged conservative if I states that, given a deduction of P( tl) from -A, we can prove P(if A then tl else t2) ([A] denotes the set of wffs the conclusion depends on). The resulting extension of MT [ I]. terms, reported of conditional from 7. Expressing and proving tactics Program tactics are programs which generate proofs. They may gramming Moreover, complex program control construct (e.g. conditionals, tactics are often constructed loops, calls to defined program using tacticals involve any pro- tactics). for in- (see I? Giunchiglia. P: TraverdArtifcial Intelligence 80 (1996) 197-241 213 [Al [TAI A B(if A then tl else t2) if E B(tl) B(tl) B(k) B(if A then tl else t2) if I TA B(if A then tl else t2) if E -l B(t2) Fig. 8. Conditional inference rules. [ 14,32,43] stance those that express a finite composition of proof steps. We show that ). In this paper we focus on a limited class of program tactics, i.e. ( 1) there exist wffs of MT which can be put in isomorphic correspondence with (2) tactics, and that program these wffs can be proved by building proofs where each proof step corresponds to a computation step of the program tactic. We call these wffs, tactics. 7.1. Expressing tactics Program tactics build trees of object level inference trees) where either all the rules are applicable is a rule which (the program is not applicable defined as follows. rule applications (the program tactic fails). Sequent (called sequent tactic succeeds) or there trees are formally Definition 7.1 (Sequent as follows: tree of s). A sequent tree of a sequent s is defined inductively ( 1) Base. For any sequent s, s is a sequent (2) Step. We have one case for each inference tree of s; rule. Let 171,. . . ,Z7” be sequent trees of SI,. . . , s, respectively. Let p be an n-ary inference rule. Then n1 SI . . . 17, . . . sn is a sequent applicable, or “ + I” otherwise. tree of S, where s is the conclusion of the application of p if p is We use leaf and end sequent of a sequent tree with the usual meaning. 7.1, when p is not applicable, we add + 1. The particular is irrelevant. We represent inference rule applications In item (2) form of this in the following uniform of Definition sequent way. 214 E Giunchiglia. P. Truverso/Artijiciul Intelligence 80 (1996) 197-241 We call I7 the sequent sr of 171. We associate terms are defined tree of s built by applying an inference to every OT sequent tree I7 (I71 ) a tactic term r, rule to the end sequent (T,,). Tactic inductively over the structure of sequent trees. Definition 7.2 (Tactic defined inductively over the structure of ZI. term of I7). The tactic term rn of the sequent tree I7 of s is ( I ) Base. “S” fail: r57 = C if s is an assumption or an axiom, otherwise. (2) Step. (a) (b) ( AE/) : T, =fundeltuc( T,, ), (V’lxu) : T, =fullituc( T,, , “x”, “u”). the following proof tree Ii’ (the axioms for VE are in Example 7.3. Let us consider Appendix A) : VE AEl VI l- +VxA(x) l- *A(u) A B(x) A B(a) I- +A(u) l- +VxA(x) r, is jiilfitucCfundeftuc(jMetuc( “s”, “x”, “a”) ) , “a?, “u”), the following sequent tree I7 (notice that X7 is not a Example 7.4. Let us consider proof tree) : VE A-5 VI A+VxA(x) A+A(u) > B(x) > B(u) +I +vx I T, is fallitucCfandeltucCfulletuc( “s”‘, “x”, “a”) ) , “x”, “a”). Tactic interested tactics, however, terms contain constants which denote either the leaves of the corresponding take arguments which get instantiated of tactic terms, where in a “generalization” time. We are therefore tree or failure. Program sequent at execution constants are replaced by variables, and which represent proof structures of the leaves of sequent termsr,asr,[ct,...,c,],wherect term. Each c; in cl,. fail, or the quotation mark name of a possible parameter of a rule application “a? and “a” By r,r[x~,.. 77r[Cl,..., of tactic. this is obtained as follows. We write tactic in the the constant (like variables of MT. . . , c, in c,] with the variables xl, . . . , x,, respectively. We can now define the notion in fullituc( “s”, “x”, “u”) ). Let xl,. . ,x,] we mean . . , c, may be the quotation mark name of a sequent, , . . . , c, are the individual constants appearing the term obtained by replacing . . ,x, be individual the constants cl,. trees. Technically, independently E Ciunchiglia, P Traverso/Arti$cial Intelligence 80 (1996) X97-241 215 Definition 7.5 (Tactic). Let cl,. . . , c, be constants Let cl,. quotation mark names of sequents or fail. Then a tactic is any wff of the form: . . ,cn,, with m < n, be all and the only constants term. . . , cn that are either and r,[ct , . . . , c,] a tactic in cl,. V’x, . ..vx,, (Tac(x,) A~~~ATaC(.x,,) 3 TaC(T,[Xl,..., x,])). (29) Axioms (9) and ( 10) are tactics. In Section 6 we have explained how in a precise: correspondence with the primitive respondence each function instance exists symbol the: following in T,[ xi, . . . , x,] corresponds example. in general between complex program they are tactics for AEI and MI. The same cor- Indeed, for tactics. tactic. Consider to a primitive tactics and Example 7.6. b”xlx2.q (Tac( XI > > TucCfalfitucCfandeltuc(tXetuc( XI, x2, XX) ) , x2, x3) ) ) . (30) (30) corre:sponds f alletac, f andeltac to the program and fallitac. tactic that composes the three primitive tactics 7.2. Proving tactics Tactics which correspond to primitive tactics are axioms of MT. From these axioms we can prove tactics which correspond to compositions of primitive tactics. Example 7,.7. Consider tactic (30). From the following axiom of MT (see Appendix A) YIX,VX:!VX~ (Tuc(xl) > Tuc(fulletuc(xl,x2,x3))) and axiom (9) we can prove Vx,Vx:,V’x3 (Tuc( xl ) > TucCfandeltucCfalletuc( x1, x2, x3)))). (31) (32) (32) from Then, from wff (3 1) which corresponds fullituc. and axiom ( 10) we can prove to f alletac. (30). Notice that the proof starts It then introduces fundeltuc and finally The proof in Example 7.7 suggests one possible general way to prove tactics, namely step of the corresponding to a computation tactics. Intuitively, the proof in Example 7.7 corresponds to build a proof where each step corresponds program object constructed type Tut, i.e. that it is either a theorem or a failure. This is similar tactic-based primitive theorems and which do not contain primitive theorem provers, where program tactics. For instance, by the composition tactics construct of falletac, fandeltac to checking and fallitac that the is of in theorems only by applying to assert to what happens tactics. Nevertheless, MT can prove statements which can be executed Vx (Kzc(x) A Conj( x) II TucCfandel(x) ) ) (33) 216 F: Giunchiglia, I? Traverso/Artifcial Intelligence 80 (1996) 197-241 where fatzdel corresponds under used safely the proper conditions, to f andel, i.e. when is a theorem of MT. Intuitively, is a conjunction, the argument (33) states that, can be fandel to construct a theorem. Similarly, the following are also theorems of MT. Vx (T(x) A Conj(x) > TCfandel(x))) VxlVx2Vx3 (T(xI) A Vur(x2) A Par(x3) ANoFree(x3,nl) 2 Tvhlli(xl ,x2,x3))) VxlVx2Vx3 (T(xi > A Var(x2) A Term(x3) A ~ra~l(xl) A Conj($zlle( xi, x2, x3 ) ) A Vur(x2) spar ~NoFree(x:,,fandel(falle(x1,x;?,x3))) > TCfalli(fandel(faZle(x~,x2,~3)),~2,~3))) (34) (35) (36) that (341, the derived from tactics (35) describe in an analogous way. (34), fandeltac and fallitac and factoring out the conditions of applicability (9) and (10) by of the level rule that applies VlE, AEl and VZ in the of The proof of (34) and (35) can be easily performed unfolding (36) can be proved rules. rules AE) and V7’1. (36) describes given order. Notice applicability of VE (second line). The rules get composed. which cannot be applied failures. “non-mechanized” rule. In (36) we have the preconditions those of VI (fourth describes how say nothing of what happens when a rule the code dealing with In this sense, they are closer to the “usual” on paper metalevel descriptions of term falli($andelCfaZZe( xl, ~2, x3) ) , x2, x3) ) ) (fifth “line”) is applied. They do not take into account (35) and (36) describe explicitly of the corresponding the preconditions the pr~onditions (35) and (36) of A,!?! (third the object line) and (derived) (derived) rules. line), (34), Finally, since tactics are theorems of MT and correspond to program perform program (30) and which corresponds logical manipulation which corresponds tactics. For instance, we can prove a wff which is logically equivalent tests. tactic which avoids redundant to code ~ansfo~ation, to a program tactics, we can thus optimizing Example 7.8. We can prove in MT VX~VX~VX~ (Tac(xl) faIlituc(Jandeltac~aIletuc( XI, x2, x3) > , x2, x3 ) = > if -Fail( XI ) A Var(x2) A Term(x3) A Forall A C~~~~a~~e(~j, x2, x3)) A Par(x3) A NoF~e(xs,fundelCfalle(xl, x2, x3))) thenfalli(fandel~ulle(xl else fail ) ,x2, x3)), x2, x3) The proof is performed by rewriting according to axioms assumption Tac( XI ). We assume (6)) first faflitac~andeLtac~Zietac(x~ (7) and the axiom about falletac in Appendix A, under the wff in the if condition , x2, x3) ) , x2, x3) the in wff (37) and its negation. to tactic (37) E Giunchiglia, R Traver.so/Artifcial Intelligence 80 (1996) 197-241 217 This allows us to eliminate obtain conditional terms by applying if E and if E,. We can thus fallitac(fandeltac~alletac(x~ , x7., x3) > , x2, x3) =failiCfandel($aZle(xl,x;!,x3)),~2,x3) depending on the if conditions in wff (37) (and Zhc( x1 ) ), and fallitacifandeltac~alletac( XI , x2, x3 > > , x2, x3 ) = fail depending thus apply if I discharging to a program corresponds to a program corresponds on the negation of the if conditions the assumptions tactic which calls FAIL in wff (37) and > I discharging Tac( xt ). While twice, (and Tac( xt )). We can (30) (37) times, and Var three tactic which calls these routines only once. Example 7.8 is very simple. The underlying intuition is that MT could be used (possibly with extensions) tactics about Isabelle-like to optimize code in more significant ways (see discussion in Section 10). 8. Executing tactics Tactics can be given a procedural content and thus used to assert object level theorems. them into program them or by compiling (flattening) This can be done by interpreting tactics. 8.1. Interpreting tactics Consider a generic tactic Y’x, . . .\fx, (Tac(xl) A.. .ATac(x,,) 3Tac(~~[xl,...,x,l)). By “tactic which asserts; an object level theorem or fails. This process is performed four steps. interpretation” we mean a process by which a tactic is fed into an interpreter in the following Step 1. Perform a sequence of forall eliminations, to obtain Tac(ci) A... A Tac(c,,) > TcIc(r,[ct,. . . ,c,]> where cl,. operation, on a set of arguments. . . ,cnl, . . . , c, are constants naming objects of OT. This is the dual tactic in a procedural metalanguage, the call to a program of typing Step 2. If any ci in cl,. proved in OT, then deduce . . , c,,, is either fail or the name of a sequent that has been as a theorem of MT, otherwise, stop. This is the dual operation of testing swme of the arguments of the program they are either theorems or failure. that tactic are of the right type, i.e. that 218 F: Giunchiglia, P. Truverso/Artificial Intelligence 80 (1996) 197-241 Step 3. Run simplify implementing returns fail, program over an object stop. This tactic with instantiated the term T,[CI, level sequent is the dual operation of executing . . . , c, I. If it returns a data structure in MT. If it the body of the s, then deduce T(“s”) arguments. Step 4. From T( “s”), assert s as a theorem of OT. This is the dual operation of asserting the result of the execution of a program tactic. Example 8.1. Let us consider ing three forall eliminations respectively. We obtain the following formula. tactic it by perform- In Step 1, we instantiate and by replacing XI. x2 and x3 with “s”, “x” and “a”, (30). 7iic( “s”) > Tac(fhllitacCfhndeltc~u~~e~~c( “s”, “x”, “a”) ) , “x”, “u”) ) . In Step 2, we exploit the fact that t-or s: Tac~allitucCfandeltac(falletac( “s”, “x”, “a”) ) , “x”, “a”) ) . (38) term The in runs simplify r +‘v’xA (x) . Then we have is the in Example term of the sequent over fullitucCfandeltuc~alletac( “s”, “x”, “a”) ) , “x”, “a”), tactic tree (38) 7.3. Step 3 that returns T(“r -vxA(x)“). Step 4 asserts r *‘v’xA(x) as a theorem of OT. Example 8.2. Let us consider now an execution before, but in Step 1 we instantiate term of Example 7.4. We can perform Step 2 as in Example 8.1 to obtain: that fails. We take the same tactic as the tactic it to obtain a ground wff that contains Tac(fallitac(jiindeltacCfalletac( “s”‘, “x”, “a”) ) , “x”, “a”) ) . Step 3 runs simplify fail returns over fallitacCfandeltac~alletac( “s”‘, “x”, “a”) ) , “x”, “a”), that (see Example 6.2). Then the process stops and Step 4 is not performed. statements Another possibility (35) and (36). Their is to interpret metalevel rules, e.g. wffs (34), of tactics. The first step is the same as Step 1. In the second step, wffs of the form T( “s”), where s is a theorem of OT, get factored out of the ground wff. The third step applies simplify is not T. If to each of the atomic ground wffs whose main predicate symbol it returns TRUE for all of them, to the term argument of T. Otherwise, then simplify the process stops. The last step is the same as Step 4. to the interpretation that describe interpretation is applied is similar (derived) Example 8.3. Consider wff (36). After the first two steps we have Var( “x”) A Term( “u”) A Forall( “s”) AConjCfalle( “s”, “x”, “a”) ) nVur( “x”) A Par( “a”) A NoFree( “x”,fandel(fulle( “s”, “x”, “u”) ) ) > T~alli(jundel(jalle( “s”, “x”, “u”) ) , ‘Ix”, “a”) ) (39) to the (40) (41) F: Giunchiglia, R Traver.w/Artijicial Intelligence 80 (1996) 197-241 219 third :step applies simplify is then applied The turns TRUE:. simplify It returns .r +VxA(x) OT. If xi gets ConjjCfalle( “s”, “xl’, “ ” a ) ) (Example 6.3). Therefore instantiated with s’, then simplify (see Example 6.1), which to the conjuncts. For each conjunct it re- “s”, “x”, “u”) ) , “A?, “a”). in (39), to fulli@zdelCfaZZe( is then asserted as a theorem of to returns FALSE when applied the process stops. 8.2. Flattening tactics By flattening we mean a process which takes (certain) theorems of MT and generates implementing tactic is composed of three parts: the computation machinery, in Section 5, the code a the and the update machinery. Flattening must generate the computation tactics program in the HGKM code. As seen program (primitive) top level machinery and the top level machinery. The update machinery In MT it is possible two parts of the code that must be generated. to “split” a tactic into two wffs, each of them corresponding is the same for all inference rules. Vx, . . .Vx,? newtuc(xl,. . .,x,) = T,[x~,. . . ,xn], vx, . . .‘dx, (Tac(x,) A * * .ATac(x,) 3tic(newtuc(xl,...,x,))). x,] symbol newtac. We obtain (40) is the definition of a new function in (29) with (40). We can now generate corresponding r,[x1,..., tactic newtac (40). We flatten attachments flattening of (40) and (41) consists of a simple syntactical following its top level machinery symbols to newtac. We flatten of MT applicative (41) by rewriting the code of a new program from the the the from (41). The flattening process exploits the attachments, to HGKM functions. Given translation. Consider its computation machinery example. Example ft.4. From tactic (30) we can prove Vxi VxzVxs distuc( xl, x2, x3) =fullitac(&andeltuc@zfalletuc(xl , x2, x3) ), x2, x3), VXlVx2VX3 (7izc(x,) > Tac(distac(xl, X2, X3))) (42) (43) where distac corresponds universal quantifier over conjunctions). to a program tactic which (42) gets flattened to implements distributivity (of the (DEFL,AM distac (fallitac (~1 ~2 ~3) (fandeltac (falletac xl x2 x3)) x2 x3) > is translated into a function definition. The universally the arguments xl, x2 and x3 of the function Notice that the universal statement quantified variables xi, x:! and x3 become definition. The function and distac tactic term to obtain is flattened distac is attached to distac. to obtain the body of the definition of distac. from (43) symbol distuc gets translated A simple syntactic into translation the HGKM symbol distac is performed on the for The top level machinery (DEFL,AM ~1s 0 220 E Giunchiglia, I? Traverse/Artificial Intelligence 80 (1996) 197-241 (tacfproof-update (distac (TAC) (TERM) (TERM))) > to the top level function DIS is arbitrary. Flattening always builds and of the functional the part of of the update tactic The name given composition the program according first argument gets extracted by TAC. TERM is a routine specific routine this case distac). to the hypotheses of the implication tacfproof type. (in -update The arguments of distac are constructed in (43). Since we have Tac(xt ), the for the extraction of terms of no We can also flatten logical manipulations of tactics and thus generate optimized code. Consider the following example. Example 8.5. From (37) and (42) we can prove In Section 7 we have manipulated wff (30) and obtained wff (37). vx,vx2vx3 (TaC(Xl) 3 distuc( x, ) X2, x3) = if lFuil( xl ) A Vur( x2) A Pur(cq) A ForuU( XI ) A Conj(fulle( XI, x2, x3) ) A NoFree( ~3,fundelCfulle( XI, x2, x3) ) ) thenfuZZi(fundel(fuZle(x~, else fail) x2, x3)), x2, x3) (44) (44) we can flatten the computation machinery of distac (and leave unchanged From the top level machinery). The result is: (DEFLAM distac (xl x2 x3) (if (AND (NOT (FAIL ~1)) (VAR x2) (PAR x3) (FORALL xl) (CONJ (falle xl x2 x3)) (NOFFlEE (fandel (falle (falle xl x2 x3)))) xl x2 x3) > x2 x3) (f andel (falli fail)) the same syntactic function and predicate symbols according The flattening process performs it translates the conditional the connectives A, 7 into AND, NOT, respectively. Notice optimized version of distac will replace the previous definition. term if . . . then . . . else . . . into the conditional translations flattened to their attachments, as in Example 8.4, namely it translates . . . > and tactic is an construct that this program (if in Example 8.4. When flattened, this definition Once flattened, program tactics get executed tactic with proper arguments, the call to the program (e.g. by TAC), the body of the program gets affected by the update machinery. Executing a tactic gives the same result as interpreting the tactic in MT. in the standard way, i.e. the user can type the arguments get type checked tactic gets executed, and the state of the system the HGKM code obtained by flattening E Giunchiglia, P TraversdArtificial Intelligence 80 (1996) 197-24I 221 that program Finally, notice tactics can be lifted is the inverse of flattening. For instance, into axioms of MT by a process which and DIS as in Example 8.4. This code can be lifted into wffs (42) and (43). Once MT has been lifted for the first time, involves only the computation machinery and the top level machinery the user can handcode distac lifting and flattening function definitions. 9. Everything works - some technical results In this section we give some results which guarantee the correctness of the solutions in Sections 6, 7 and 8. The proofs of theorems are in Appendix B. The results in Section 3, the hard work has of OT such that framework technical but not completely, as the proposed presented are technically not hard to prove. As described them, i.e. in defining a metatheory been in stating these results could be proved. They are needed has all the desired properties. This section results are discussed to show that the proposed to the goals of the paper. and a mechanization in relation is mainly 9.1. MT is consistent We define an interpretation M = (D,g) of ML, where D is the domain of interpre- 2) includes a two special elements E and F. E and is used to handle partialness. We use F to tation and g is the interpretation set (called D,,) of objects of OT. The domain contains intuitively denotes interpret function. The domain of interpretation i.e. the constant fail of MT. the value “undefined” failure, Definition 9.1. The interpretation M of ML 51),, is the set of terms, wffs and sequents of OT. E and F are distinct element of D. g is defined as follows: is the pair (V,g). 2, = ‘D, U {E} U {F}. from any other ( 1) g( “s”) = s, where s is any sequent of OT. (2) g( ‘Xv”) = w, where w is any wff of CYI’. (3) g( “t”) = t, where t is any term of O’I’. (4) g@il) = F. (5) g( Set) (6) g( =) is the identity (7) g(Par) (8) g( Vur) is the set of individual variables of OT. (9) g( Corzj) is the set of sequents of OT whose formula is the set of sequents of OT. relation over D. is the set of individual parameters of OT. ( IO) g( NoFree) an individual in r. appear is a conjunction. is the relation over V2 such that (dl, d2) E g(NoFree) parameter of OT, d2 is a sequent r *A is of OT and dl does not iff dl ( I I ) g(T) = TOT, where 7’0~ is the set of theorems of OT. ( 12) g(fundel) from D to ZJ such that, for any d E V is a function ifdisr+AAB, otherwise. 222 F: Giunchiglia. P Traverso/Art$cial Intelligence 80 (1996) 197-241 ( 13) g(falli) is a function from V3 to V such that, for any dl, d2, d3 E V g(falli) (dt ,&,dg) = r +b’xA;, E, { if dl is f +A, and a does not appear in r, otherwise. d2 is a, d3 is x ( 14) g(fundeltac) is a function from V to V such that, for any d E V gCfand4 (d), gCfandeltac) (d) = F’ E, i if d E TOT and d E g( Conj), if d E TOT U {F} and d $ g( Conj), otherwise. ( 15) g(fullitac) is a function from V3 to V such that, for any dl , d2, d3 E V ’ g(.Wi)(dl,d;!,ds), if dl E TOT, d2 E g( Var), d3 E g(Par) and (dn,dl) E g(NoFree), g(fallitac) (dl , d2, d3) = ( F, E, if dl E TOT U {F} and (d2 @ g( Vur) or ds $g(Par) $g(NoFree)), or (ds,dt) Wffs and terms get interpreted according to the usual standard tarskian semantics. otherwise. The semantics of conditional the value of tt if A is true, and the value of t2 otherwise. terms is as follows. The value of if A then tl else t2 is Theorem 9.2. M is a model of MT. Theorem 9.2 proves the consistency of MT. Moreover, since M is a model of MT, we have that If hT T(“s”) then br S (45) for any sequent s of OT. We say that MT is correct with respect to UT. of OT given in which sense in OT (e.g. f andel, It should now be clear the code of CYI’ has been developed to be a jinite presentation of the model of MT. Compare Definition 9.1 of M and the de- in Section 5. The HGKM functions which scription of the mechanization to be) fi- perform deduction nite presentations application lation structure machinery in the model M. The commands ATTACH and MATTACH implement analogue) important In particular Tut and T are left uninterpreted (e.g. gCfandel), gCfandeltac), g( Conj) ) . We can thus use the simu- analogous of the interpretation the (mechanizable It is that the code of CYT is a presentation of only a partial model of MT. (see discussion of the relations assigned by g (as defined above) of g. simplify to notice tests the truth of wffs in M, CONJ) are (implemented to the corresponding i.e. it implements the mechanizable in Section 6). to implement f andeltac, symbols k,,,,. F: Giunchixlia. I? Traver.w/Artijicial Intelligence 80 (1996) I97-241 223 characteristic In Definition 9.1, we have introduced E to interpret function (e.g. f andel to HGKM partial functions system). As it can be noticed are partial fulli) which correspond is a general running f andeltac (corresponding implemented the code implementing wffs and terms. Partialness test and decide for all the possible symbols and f alli). (e.g. fundel and Partialness of a large amount of the code of GETFOL (and of any from Definition 9.1, points (14) and (15), also functions defined only over theorems or failures is the case also for the tacticals tactics) and for all destructors and constructors of logical syntactical categories, e.g. allows us to achieve efficiency as the code does not have to in GETFOL [ 251 (which are defined only over program to the set (TOT U {F}) & Do>. This and f allitac inputs. Extending the domain with E to handle partial is a well known standard [ 12,421). One essential difference is that we have two special elements, E and F. From a theoretical point of view, we could have into a unique of this a model and a metatheory where E and F are collapsed of OT is not a finite presentation is that the mechanization functions (Isee, for instance, technique distinct constructed element. The problem model. The distinction between E and F is important between MT, its model M and the code implementing Fig. 2). E is not denoted by any symbol by any data structure on paper” in MT and is implemented fail by the data structure failures”. is “a witness of observable fail in the language of MT and is not implemented in the model “defined the fact that some programs are partial. On the contrary, F is denoted by fail in the GETFOL code. We say that in the GETFOL code. It is used to capture in order to define a correspondence deduction in OT (as shown in 9.2. Tlze use of SIMPLIFY is correct In Section 6 we use SIMPLIFY to assert axioms (13)-(25) that this use of the simulation and all their (ground) structure machinery that are attached that SIMPLIFY cannot be applied is consequences. We show here to all the (ground) terms or wffs sound. First notice to partial functions. For instance, of MT, since in MT we have symbols SIMPLIFY fandel( “ +A V B") would return a wrong value and SIMPLIFY Conj( “x”), where x is a variable of OT, would abort to to a subset S, of terms of MT, called guarantee (the set of) (the set of) simpl$ubfe terms simpli$able wffs. Roughly [ [t] ] M, to and atomic ground wffs which are well sorted. In the following, we write mean the element of D denoted by the term t of MT. terms, and a subset S, of wffs of MT, called soundness, we apply SIMPLIFY only these sets contain all and only in Section 6). In order (see discussion the ground speaking, Definition !).3 (SimpliJuble terms). ( 1) Let 17 be a constant of MT. Then c E S,. (2) If t 15 & and [ [t]]M E g(Conj), then fundel(t) E S,. (3) If t19t2,t3 E St, then fulli(t,,t2,tg) ([[t3llM~[[tlllM) E S,. E g(NoFme) and [[t211M E g(Var), (4) If t ‘E S, and If tl,tz,tj (5) [ [t] ]M E TOT U {F}, then fundeltuc( t) E S,. Es, and [[tl]]M ETmU{F}, thenfullituc(tl,t2,t3) ES,. 224 F: Giunchigliu, P. Traverso/Arrificial Intelligence 80 (1996) 197-241 Definition 9.4 (Simpl$able wffs) , ( 1) If ti , t2 E S,, then tl = t:! E SW. (2) If t E S,, then Set(t) E S,. (3) (4) (5) (6) (7) If t E S, and [ [t]]M E g(Sec) U {F}, then Fail(t) E S,. If t E S, and [ [t]]M E g(Sec), If t E A’,, then Par(t) E SW,. If t E S,, then Var( t) E S,. If tl, t2 E S,, tl E g(Par> and t2 E g(Sec), then Conj(t) E S,. then Nofree(tl,tz) E S,. Notice the correct type, i.e. it denotes only because T and Tat are not attached that even if t E S,, T(t) 6 S,,. and Tac( t) 6 SW also in the case where t is of is theorems or theorems and failures, respectively. This to anything. The soundness of the operation performed by SIMPLIFY is not obvious as in general is a subset of the set of true formulas. The following the set of provable theorem guarantees formulas that this is not the case. Theorem 9.5 (Correctness kW w*t-MTlW. of simplify). Let w E SW. Then kM w j IMT w and Notice limited that, from a purely the set of ground axioms theoretical point of view, with minor modifications of the ground axioms, Theorem 9.5 can be stated for all the ground atomic wffs that do not to simplifiable wffs. For instance, we could contain T and Tat, and not only extend to include +&rj(“x”> and k~r -Conj( “A?). But this extension would not be in the spirit of a metatheory of the fact a mechanized on a data that the code structure that can be evaluated by the simulation actual relation between provability model. object is partial, e.g. the fact that CONJ cannot be run successfully recording a variable. Definitions 9.3 and 9.4 capture exactly structure machinery. Theorem 9.5 captures the analogue of its that it would not take into account in MT and truth in the mechanizable and thus have FM Conj(“x”) those expressions in the sense theory, 9.3. MT is correct and complete with respect to provability in OT We prove that tactic terms have the right behaviour. Theorem 9.6 (MT correct and complete w.r.t. OT). r,, be the tactic term of Il. Then Let I7 be a sequent tree of s. Let ( I ) ~~ 7, = “S” (2) hr 7, =fail - - (a) (a) II n is a proof of s is not a proof - - (b) (b) ~-CT,). hT k&,T ~T(T,,). Part ( 1) of Theorem 9.6 states that a tactic term corresponds it can be proved equal to the name of a sequent of OT (part which denote a theorem of OT (part (2b)). Notice iff it can be proved equal is not a proof ( lb) ) . Part (2) states that a tactic to a successful proof iff (part ( la) ) which denotes a theorem tree iff it does not tactic fails to term corresponds to a sequent to failure (2a)) (part that the fact that a program F: Ciunchigiia, I? Tr~ver.~~/~rt~ciai f~te~~i~e~~e 80 (1996) 197-241 225 prove a sequent does not imply that the sequent is not provable. Analogously, part (2b) of Theorem 9.6 states that the tactic term does not denote a theorem (i.e. .T(t7)), but does not state the much stronger fact that s is not a theorem (i.e. --J’(“Y’) ). This result is therefore very different from the fact that --17‘(“s”) is provable in MT iff s is not provable in OT. Theorem 9.6 makes a statement about a single sequent tree Z7 and not about the provability of 3, which would involve considering all sequent trees of s. However, in part ( 1) of Theorem 9.6, the two notions collapse and from T(v-~) it is Indeed, as a corollary of Theorem 9.6, we have that if s is possible to prove T(“s”). is provable in MT. We have therefore that reflection down provable in OT then T(“s”) and reflection up, namely [ 22,231 Rdown hT Tt“s”) bT s hYrs 3 Rup EMT T( “s”) (46) are correct inference rules between theories in the multitheory system MT-OT, and that axioms ( II), ( 12) need not be explicitly and a priori stated. They can in fact be proved and asserted when needed with an application of RUp. 9.4. All tactics are theorems of MT We prove that all tactics are theorems of MT. Theorem 9.7. Any tactic is provable in MI: The fact that all tactics are provable in MT is exactly what we should have expected. In fact, any tactic corresponds to a program tactic which can be defined in the system code. To say that any tactic can be derived in the metatheo~ is equivalent to saying that any strategy implementing any finite composition of inference steps can be written in HGKM. In Section 7 we have proved theorems (34)) (35) and (36). They represent, without taking into account failure, (derived) object level inference rules. We show now that theorems of this kind can be proved in general. First we need some technical definitions. The sequent tree term t, and the preconditions P, of a sequent tree 17 are defined inductively over the structure of sequent trees. In the base case, a sequent tree is a single sequent s. If the sequent is a proof, i.e. it is either an axiom or an assumption, then its sequent tree term is “s” and its pr~onditions are T(“s”). If it is not a proof, i.e. it is neither an axiom nor an assumption, then its sequent tree term is fail and its preconditions are T(fai1). In the step case, if t,, and Pn, are the sequent tree term and the preconditions of nt, and L7 is built from ZIt by applying AEI (VI a x) to the end sequent of ZIt, then fan&&t,,) ) (P,, A Vur(“x”) A Par(“u”) A ~o~ree~“u”, t,, )) are the sequent tree term and the preconditions of ZI, respectively. For instance, if a sequent tree is built by applying first VE x a to an axiom s, and then AEl and Vf x a are applied in the sequent tree in the given order, then the corresponding sequent tree term is yhlli( tn,, “x”, “a”)) and P,, A Conj(t,, fa6li~andel~lle( “s”, ‘P’, “a”) ) , “x”, “u”) 226 F: Giunchigliu, I? TruverdArtiJciul Intelligence 80 (1996) I97-241 and the co~esponding preconditions are T( “s”) A Vur( “x”) A Term (“a”) A Forall ( “s”) ~Conj(fdfe( “s”, “x”, “a”) ) r\Var( “2’) A Pat-( “u”) A ~oFree( “x”, f~~~e~~~le( “s”, “x”, “u”) ) ) . tree we have a wff of . . ,c, are the individual sequent *. , c,?]), where cl,. For each OT T(f,[Cl,. quent We write as 7>n[xt,...,x,,] placing XI,...,X,, tree term and in the preconditions. Let xl,. , . . . ,x,1 and t,[nt the constants et, . . . , c, in %‘*[ci , . . . , c,,] and t,[ct respectively. We have that: the constants form P?,[cl, . . . , c,] appearing 3 in the se- . . , xn be individual variables of MT. the wff and the term obtained by re- , . . . , c,] with the variables Theorem 9.8. Any w# of the form vix, . ..\Jx,, (PTriIXl,...,&l 3T(t,lxi,..*,x,l)~ (47) is provable in MT 9.5. Tactic execution is correct Under the hypothesis that the underlying implementation is correct, tactic interpreta- c,] T,[cI,.... in Section 8.1) is a simplifiable of Theorems 9.5 and 9.6. We compute tion (described is correct, as it is the sequence of four steps, each of which is provably correct. Step 1 is trivially correct. The correctness of Step 2 is a con- sequence of Theorem 9.6. In fact, if ci isfail, then k~r ~c~~i~), while if ci is “s” with t-or s, then we have ~-MT T( “s”) and therefore kkrr 7bc( “s”). The correctness of Step y( r,, [ cl,. . . , c, I), 3 is a consequence ct , . . . , c,] ) = s, then where we have that the simplifiable wff r,[ct , . . . , cn] = r‘~” is true in M and, therefore, 9.5). From Theorem 9.6 part ( 1) we have that IMT T,[Cl,. hr T(“s”). wff r,[cr,... rem 9.5). From Theorem 9.6 part (2) we have that r,, does not correspond (45) Therefore Theorem 9.6) guarantees wffs of the form (47) can be shown exactly then we have that the simplifiable is true in M and, therefore, hr r,,[ct , . . . , c,] = fail (Theo- to a proof. (and also of that Step 4 is correct. The correctness of the interpretation in the same way. process stops correctly. Finally, property . . , c,] = “s" If simplify(ra[ct,. ..,c,,l> = fail, term. If simplify(r,[ the interpretation , c,,] =fuil (Theorem simplif The correctness of flattening can be argued very much that the reflecting up from OT and the assertion of a theorem in terms of function calls to the HGKM functions fproof-update in the same way, the main in OT difference being must be considered and TAC (see Section 5). 9.6. A remark The theoretical results presented above are all is needed correct under the hypothesis that the GETFOlL code does what it is supposed to show that our approach is to do. In fact E Giunchigiiu. R Traver.so/Artificial Intelligence 80 (1996) 197-241 227 that SIMPLIFY is used correctly, we know that MT, as lifted from the code, is consistent, that MT is correct and complete with respect in OT, that it can express and prove all tactics, and that tactics can be executed correctly. We still do not have a guarantee and derive all theorems, not even in principle. respect claimed In fact we have given all the results with of what the GETFOL code does, i.e. we have to a set-theoretic that the code is a finite presentation implementation will not derive non-theorems of the model defined (and non-proofs) that an incorrect in Section 9.1. characterization to proofs in [ 1,18,20], requires axiomatizing results can be found To lift this hypothesis the underlying HGKM interpreter. This reimplementing GETFOL (see Section 3). is the topic of a paper. Briefly put, these results start from an axiomatization work is being done as part of the subproject Some preliminary forthcoming interpreter, based on the work described is shown similar described take into account the GETFOL implementation modulo the fact that HGKM does what it is supposed of the HGKM property is as arise, for instance because we must the fact that GETFOL has state. These results give us the correctness of i.e. modulo of OT and MT. This property expressibility, and numeralwise the HGKM implementation representability the correctness of the HGKM interpreter, in [49,56]. Then a representability to the notions of numeralwise in [ 391. Some complications to hold between a full account for example to do. 10. Current and future work As hinted in Section 3, we have an implementation paper. Within GETFOL, we have mechanized OT, MT and the procedures and execute of tactics, only the tactics that correspond work is currently under way to overcome to finite compositions the current tactics. However MT, as described limitations of MT. of everything described in this to synthesize so far, can express a very limited class of proof steps. A lot of A first step is to extend MT to be expressive enough to represent the program tactics and tacticals used in most tactic-based [ 251 describes how MT can be extended i.e. then, axiomatization is as follows. orelse, try, progress and repeat. Consider interactive theorem provers (e.g. [ 14,32,43,44] ) . to axiomatize the most interesting tacticals, the tactical repeat. Its for instance ‘JxVt (7&(x) ALTac(t) 3 appi!y( repeat( t), x) = if (apply( t, x) =fail> then x else apply( repeM t> , apply( t, x> > 1 variables and LTac is a unary predicate holding of terms where x and t are individual tactic, e.g. called logic tactics. Logic through “jhdeltuc” tacticals, e.g. repeat( orefse( “jandeltac”, ‘fallituc”) > . The function symbol apply is used to express tactics and “@litad’, and terms constructed tactic application. For instance we have that for each primitive by composing a constant include tactics logic Vx (?%c( x) > upply( “jbzdeltuc”, x) =fandeltac( x) ) 228 F: Giunclzi~liu, P Traverso/Arrl~cial Intelligence 80 (1996) 197-241 tactical correspond to a finite composition repeat is the standard in the extended MT. The and on the recursive application to tactical used of tactics, which of proof steps. This form of is that, in general, repeat is not powerful rules which allow for the construction logic tactics may not preserve consistency. At the moment we are studying (possibly is provable write strategies, based on iteration do not necessarily recursion can be safely represented. A problem enough and that, on the other hand, introducing of recursive some more general “not terminating”) to synthesize Section 9.3. logic tactics which preserve consistency. We are also studying how in for a characterization the results presented tacticals, extending tactics containing of recursive “naturally” conditions sufficient in order Induction principles are A second step is to provide MT with induction principles. to synthesize or prove [ 8,371). Some preliminary the correctness of certain derived necessary rules (see for instance such extensions of MT have been performed. formulas containing and proved what extent such induction principles ideas about how this can be done for wffs and proofs. A third step is to extend MT to prove metarules inference in [ 11 describes a proof of the theorem about is also stated is how and to can be lifted from the code. [20] discusses some stated in [ 541 (the same theorem to investigate in [ 31). A problem which we are now starting of theorem proving only equivalences experiments in [ 441. similar some preliminary work [52] describes case. These rules are characterized by the fact that they use only wff constructors. Thus, the statement “if the formula A A B in our notation for instance, is a theorem, it is possible then A is a theorem” as to the propositional in this direction, to express to those described limited where xl, x2 range over wffs, Th is a unary predicate iff T( “ + A”) holds, and mkand is a wff constructor which takes two wffs and builds their conjunction. Notice from what we can prove in MT, i.e. that this is different ,(“A”) holds such that V’x (T(x) A Cunj(x) > TCfandef(x))), speaking, a proof constructor. This where x ranges over sequents and fandel is, intuitively represents all extension would allow us to extract from any given tactic which explicitly new tactic of only one proof step (and which does all the proofs steps, a corresponding tactic at the formula the manipulation that is in general much faster to execute. An interesting open problem here is whether it is possible structure machinery, and therefore, without explicitly adding axioms level). This latter tactic corresponds (an extended version of) to do this by using the simulation to a program to MT. Finally we have just started tactics effectively. We have started those implemented MT a similar kind of reasoning to investigate how to use MT to synthesize functions to develop a set of rewriting interesting similar in [ 451. Our goal is to perform to in in Cambridge LCF and described to that performed in proof planning [IO]. E Giunchiglia, P Traverso/Art$cial Intelligence 80 (1996) 197-241 229 11. Related work simple research However, in at least the use of in metalevel to synthesize in [ 16,30,37] theorem proving, in [ 16,37,40,44]. induction, which it does not allow it does not allow in the metatheories the work described three respects. First, in [ 12,291, however promises the metatheory to the previous is limited this has been fixed in [25] ). Second, between in particular ours) described tactics. As described in a new perspective. Finally, MT is first order, unlike This provides some advantages, it might prevent us from performing is used in [8,37]. Third, so far the system has been topics are in Section 10, these in the past investigated. We actually hope that the techniques elaborated (the extent to which this is true is still to be to be a very interesting project as trying to keep and the code may lead us to see the previous in see for instance interesting Compared in this paper expressive control structures and tacticals, as it is the case, for instance (but for instance used only currently being will largely apply to MT and its extensions found out). This investigation the connection work (and the work described the discussions forms of reasoning. these message of this paper, which theory, i.e. a metatheory which can be put in correspondence with the code implementing the object tactic interpretation. None of the metatheories developed the work on FOL, see Section 3) has features similar [ 321, NuPRL instance for the provers based on logic programming logical reason about metalanguage to translate programming, cannot modify strategy, however strategy. flattening and in the past (besides, of course, for to MT. This [ 29,301, and for the This has some consequences. None of these systems can if LCF, HOL, NuPRL and Isabelle provide a to be no straightforward way logical statements or vice versa. In the area of logic the metainterpreters for any desired search the metainterpreter will be executed by using the Prolog built-in search the underlying for writing program into metalevel are somehow orthogonal a metatheory of a mechanized even if they can control it. That though very important, is about describing lheory, and about how this can be exploited is, the user can write a metainterpreter to the main object the Prolog search strategy, [5,6,16,35,36]) there seems is the case, [ 3 11, 0BJ3 code. Even [ 441, HOL frarneworks [ 14,37,40], to perform (see e.g. [ 2,3,33]. for LCF Isabelle tactics, issues, lifting, them the notion of failure in the axiomatization in the past are the following: and the needed facts are extracted in any of the work described axiomatized structure machinery, The fact that MT is a metatheory of a mechanized object theory gives it some features some of the features of MT that the syntax from the code using the facts and FAIL, and inference tactics and has a notion of tactic. Some more usual features, but and not predicates, rules do not take theories and signatures which mak.e it somewhat unusual. Thus, for instance, cannot be found is not explicitly simulation are considered; kept distinct rules and primitive still not standard as it happens as arguments, multicontext machinery explicitly (this if MT can reason about proofs for instance form the notion of partialness; MT makes a distinction are the following: in [53]; is explicitly axiomatized, using fail for instance as it happens [ 171); even as it happens in GETFOL is solved using of the syntax only ground rules are functions the is not axiomatized, for instance this notion in [ 3,531. inference inference between in [53] 230 E Giunchigliu, P. Traverso/Art$cial Intelligence 80 (1996) 197-241 lifting, inference i.e. modulo [ 81 (modulo In our approach rules and program the code implementing is really this code can be added to MT and used to derive new to Boyer and Moore’s work on like axioms, facts. In this perspective our work is similar metafunctions A difference allowing complex inference principles. described at the beginning of this section). the extensions tacticals) we have mainly considered how to compose simple tactics into more the correctness of derived tactics. rules) using induction rules (not expressed as composition of simpler in this paper (also considering is that in the work described is instead on proving the limitations the emphasis inference in spirit In [8] tactics of Acl2 is similar Our long This goal theorem prover the development to that underlying term goal, far from being achieved, of a portion of the Boyer and Moore is to develop CETFOL into a system for provably correct system facilities whose code is provably correct, and which provides [9], a development. the [ 71, using reimplementation is that in Acl2 the same logic for which Acl2 is a theorem prover. One main difference logic language and the implementation language are the same. This is possible since Acl2 is written applicatively. On the other hand, GETFOL has a lot of state, e.g. the language so far, but also global the theorems and the proofs constructed of a theory, the axioms, of decision procedures, counters used for variables used to optimize and so on. This gives the automatic generation of different names for skolem functions, so far; us some advantages, however language and the logical the computation machinery, which (they are essentially is in fact functional, about how discussions the lifting are done in [ 18,201. Some hints are also in Section 6, to hide state during in the specific case of lifting implementing GETFOL proofs. identical only for what concerns see Sections 5 and 6). Some preliminary like that of being able of showing the update and top level machinery the proof constructed the relation between the implementation the implementation it complicates We share the goal of self-reflection with a lot of work in the programming community ing introspection the work on 3-lisp (see for instance one of the first contributions [ 38,57]), [47]. The substantial difference instead of by computation. is that in our approach is performed by deduction language in this area be- the Finally, as a minor remark, a further difference with a lot of the related work, with the is that MT is distinct from CYT. (Some motivations for this choice are given relation has some commonalities with that employed noticeable exceptions of [ 10,36,55], and advantages naming both MT and GGdel allow for structural descriptive names. One difference has no hardwired naming machinery names. in [22] .) In Gijdel [ 361, in particular, the in MT. Roughly speaking, is that GETFOL and that the objects of OT can be given arbitrary 12. Conclusion and acknowledgements The work described build GETFOL into a self-reflective modify Department of Edinburgh University. in this paper is part of a long term project whose final goal is to reason about, extend and the first author was at the AI financial support for the first author system able to introspect, in 1988 when its own code. This work started In Edinburgh, E Giunchiglia, R TraversdArtijicial Intelligence 80 (1996) 197-241 231 and the simulation is being developed within the Mechanized Reasoning Group(s) (Istituto Trentino di Cultura). At the moment (DIST) has completely the FOL rewriter. Alessandro Armando (IRST), Luca Vigano’ the first and second author’s the (MRG) at IRST of Communcation, Computer and System Sciences, University of structure reimplemented (DIST), Alessandro Cimatti (DIST, currently Max-Planck was providled by SERC grant GR/E/4459.8. Currently research at IRST is funded by ITC project and DIST (Department Genoa). Paolo Pecchiari machinery (IRST), M[ichela Della Lucia and Alessandro Zorer (IRST) have worked on the project whose Institute, Salarbruecken) (IRST) has goal is the design and reimplementation the work mechanized MT (extended the work of these people, and equally in this paper could have never been done. This work has been motivated and described and discussions with Alan Bundy and Richard strongly Weyhrauch David Basin, Frank Van Harmelen, John McCarthy, Luciano Serafini, Alex K. Simpson, Alan Smaill, Carolyn Talcott and Toby, Walsh have provided useful feedback in this paper. We thank Toby Walsh for carefully on various aspects of the work described proof readi,ng the paper. Finally, improve substantially the feedback provided by the referees has helped us to in GETFOL. Without feedback, of GETFOL. Massimo Benerecetti the quality of the presentation. the use of tacticals) by the collaboration important, without their continuous infuenced to allow Appendix .A. The metatheoxy MT MT is a. triple MT = (ML:, Mdx, MR) where ML, Mdx and MR are the language, the set of axioms and the set of inference rules of MT, respectively. A.I. The language ML Individual (constants The quotation mark names of the objects of OT plus fail. Function symbols AI : fandi,fanditac of arity 2, AEI : fandel,fandeltac of arity 1, AE, : fander, fandertac of arity 1, 3 I : jimpi,jimpitac of arity 2, > E : fimpe,Jimpetac of arity 2, VI : falli, fallitac of arity 3, VE : falle,falletac of arity 3, I, : false,falsetac of arity 2. 232 F: Giunchiglia. I? TraversdArtifcial Intelligence 80 (I 996) 197-241 Predicate symbols Par, Vat-, Term, Set, Wff of arity 1, Conj, Imp, Forall, False of arity 1, T, Fail, Tat of arity 1, NoFree, Hp of arity 2, = of arity 2. Sentential constants I, T. A.2. The axioms MAX Basic axioms A Fail(x)) Vx l(Sec(x) Vx (T(x) > Set(x)) Vx (Fail(x) c-1 x =fail) Inference rule axioms VXIVXZ -, fandi(xI ,x2) = fail, Vx 7 fandel(x) = fail, Vx 7 fander( x) = fail, Vx1 VXZ 1 jimpi(xl , x2) = fail, Vxl Vx2 1 $mpe( x1, x2) = fail, Vxl Vx2Vx3 1 falli( x1, x2, x3 ) = fail, VxjVx2Vx3 7 falle(xl x3) = fail, Vx, VXZ 1 false( xl, x2) = fail. ,x2, Computation machinery axioms Vx1Vx2 (Tac(xl) A Tac(x2) > fanditac(xl,xz) = if --Fail(xl) A TFail(x2) then fandi( x1, x2) else fail) Vx (Tat(x) > fandeltac( x) = if lFail( x) A Conj( x) then fandel( x) else fat’/) Vx (Tat(x) > fandertac(x) = if yFail(x) A Conj(x) then fander(x) else fail) Vx1Vx2 (Tac(x;?) > $mpitac( xl, x2) = if lFail( x2) A W#( XI ) then $mpi( xl, x2) else fail) E Giunchiglia. !? TraverdArtifcial Intelligence 80 (1996) 197-241 233 \dx,Yx2 (TaC(Xl) Jiwetac( A 7q.Q) XI, x2 ) = if dzil( XI ) A +iuil( x2) A Zmp( x2) A Hp( x1, x2) > then jmpe( XI, x2) else fail) vx,vx2vx3 (Tac(x1) 3 fullituc( x , 1 x2, x3 > =if -dGil(x~) A Vur(x2) APur(x3) then fulli( x I , x2, x3 > else fail) ANoFree(x3,x~) vxIVx;vx3 (xzC(Xl> II fulletuc( xl, x2, x3 ) = if lf%il( xl ) A Vur( x2) A Term(x3) A Fiindl( x1 ) then fulle( xl, x2, x3 > else fail) VXIV’X:, (Tac(x,) 3 fuketuc(x,,x2) = if 4%il(xl) A Wfl(x~2.) AFalse then fulse( x I, x2) else fail) Update machinery axioms Vx (7&(x) t+ T(x) V Fail(x)). Top level machinery axioms (Tuc(xl) A Tuc(x2) 3 TucC&ndituc(x,,x2))) Vxlb’xa Vx ( Ttrc( x) 2 TucCfundeltuc( x) ) ) > TucCfundertuc( x) ) ) Vx (k(x) VxlV’x:, VxlVx:, VXIVQVX~ VXIQX~VX~ (TIC VxlVx2 (TUC(XI) > Tuc(fulsetuc(xI,xq))) > Tuc@mpituc(xl, x2) )) (Tuc(x2) (Tuc(xl) A Tuc(x2) 3 Tuc(fimpetuc(xl,x2))) (Tuc(xl) > Tuccfallituc(x1,x2,x3))) > TucCfafletuc(xl,xz,x3))) Let a, x, t, and w be any individual parameter, term and wff of OT. Let A, B and C be wffs of OT. Let r and A be finite sets of formulas of OT. Let c, cl, c2 be constants of OT. Let 5 be any object of CT. individual variable, Ground axioms about T T(“A ,+A”) T(” -+A”), if +AEdx 234 E Giunchidiu, p Traver.w/Artificial Intelligence 80 (1996) 197-241 Ground axioms about inference rules fandi( “P + A”, “A -_) B) = “P, A -+ A A B” fandel(“P + A A B”) = “r w A” fander(“P + A A B”) = “r --_) B” jimpi( “A”, “P +B”) = “P - {A} --_) A > B” fimpe(“T + A”, ” A +A > B) = “r,A falli( “P -+ A”, “x”, “a”) = “P +VxAz”, .falle( “P +VxA”, fimpi( ,‘r +I”, “A”) = “r - {A > I} +A” “x”, Y’) = “r + A:” -+B” where a does not occur in r Ground axioms about syntax Par( “a”) lPar( c) , Var( “2’) -Var(c), Term (“t”) TTerm(c), Wsf( “W”) if c is fail or “f’ and 5 is not an individual parameter of OT if c is fail or “r’ and 6 is not an individual variable of OT if c is fail or “5” and 5 is not a term of OT if c is fail or “5” and ,$ is not a wff of OT constants if ct and c2 are distinct individual 4A”), “P + A”), -Wsf(c) 3 7 Cl =c2, Conj( “r + A A B”) Xonj( Imp( “P ---) A 3 B”) +np(“r Hp(“P +A “, “A + A > B”) lHp( “r 4 A”, “A +C”) NoFree(“a”, “P + A”), TNoFree( “a”, “P + A”), Forall(“T +VxA”) TForall(“T + A”), False ( “P ---) _L”) +alse(“r +A”), Sec( “r -+ A”) -6ec ( “5”) , if A is not I if 6 is not a sequent of OT if A is not a conjunction if A is not an implication if C is not of the form A > B , if a does not appear in r if a appears in r if A is not universally quantified Appendix B. Proofs B.I. Proof of Theorem 9.2 We show since g(Sec) defines g(falli)(dl.d2,&) that for any wff Q in ML, tl g( Fail) = 0. Axiom (2) b1~1~ a implies k=M (Y. Axiom is true since g(T) C g(Sec). Axiom is true (3) (4) and (5) are true since g(fande1) (d) $ {F} and (6). Let XI be (1) f or any d, dl, d2,ds E 23. Consider axiom 6 {F} the predicate Fail. Axioms I? Giunchiglia, P. Travemo/Art$cial Intelligence 80 (1996) 197-241 235 to d E g( Tut). If d E g( Conj), then the conditional into is true. The is to d E g( Tut), then g(fandeltuc) (d) E g( Tut), The proof for the predicate Tut. Axiom into F. Then axiom (6) term is interpreted (8) defines (9) is analogous. Axiom (7) if x is assigned assigned gCfundel) (d). If d @ g( Conj), then it is interpreted proof for axiom true since, axiom ( 10) is analogous. Axioms belong to g(T). Axioms and, if a does not appear in r, g(fulli) (r 4A, are trivially (13), true. ( 1 l), (14) are true since g@zndel)(r4A~B) ( 12) are true since OT axioms and assumptions = Z”4A (15)-( 25) x, a) = r +VxAz. Axioms B.2. Proof of Theorem 9.5 We first prove the following lemma. Lemma B-1. Let t E S,. Let c E S, be u constant of MT Zf kM t = c, then ~MT t = c. Proof. By induction over the structure of t. Base. Obvious Step. We have one case for each form of simplifiable since we have c = c. t, tl, t2, tg E St. term (Definition 9.3). Let ( 1) fundel( t) . t denotes a sequent of the form r -+ AA B, since t E S,. Then k,,,, t = “r 4AA B”. From the induction hypotheses we have that tMr t = “r 4AA B”. +A,, fundel( t) = c implies r 4 A. fundel( “r 4A A B”) = is axiom “r -+A” that c denotes ( 13). (2) faUi( tl , t2, t3). We have that tt denotes a sequent of the form r +A, t2 denotes an Individual variable x and t3 denotes an individual parameter a which does not appear free in r. From the induction hypotheses we have that k&tr t I = “r 4 A”, falli( k‘r 4 A”, “x”, “a”) = b7. t2 = “x” and br “r +VxAz” t3 = “a”. c denotes r 4VxA$ is axiom ( 14). (3) fundeltuc( t). The proof is similar for fundel( t). If t denotes to the proof then we use axioms (6) and (20). then we use axioms (6) and (21). a If t denotes a If t denotes that is a conjunction, that is not a conjunction, sequent sequent F, ihen we use axioms (6) and (3). (4) falr’ituc( ?I, t2, tg) . The proof is similar to the proof for fulli( tl , t2, tg ) . Cl Now we prove the following theorem. Theorem B.2. Let w E S,. Then k=M w 3 bT W. Proof. We have one case for each form of simplifiable wff (Definition 9.4). ( I) ti := t2. By induction over t2. The base case is Lemma B.l. The step cases are analogous to the step cases of the proof of Lemma B.l. (2) See(t). t denotes a sequent S. From Lemma B.l we have tMr t = “s”. Sec( “3”) is axiom (24). (3) Fa,il(t). t denotes F. From Lemma B.l we have br t = fail. From definition (3 ) we have )Mr Failcfail). 236 F: Giunchiglia. t? Traverso/Art@cial Intelligence 80 (1996) 197-241 (4) Conj( t). t denotes a sequent s whose formula is a conjunction. From Lemma B. 1 we have t-t,,rr t = “s”. Conj(“s”) is axiom t denotes an individual parameter a. From Lemma B.1 we have br (20). (5) Par(t). t = “a”. Par( “a”) is axiom ( 15). (6) Var( t). t denotes an individual variable x. From Lemma B.l we have hr t = “x”. Var( “2’) is axiom (7) Nofree( tl , t2). t2 denotes a sequent ( 17). r +A and tl denotes an individual param- eter a that does not appear and br tl = “a”. Nofree(“a”, “r +A”) in r. From Lemma B.l we have hr is axiom (22). 0 t2 = “r +A” We prove the following lemma. Lemma B.3. Let t E S,. Let c E S, be a constant of MT. If p,,,, t = c, then ~MT 1 t = c. Proof. We have one case for each form of simplifiable cl = ~2, then cl and c2 are distinct now simplifiable fade/(t) FM ( 19) ) . The proof for the other cases is similar. a sequent = c implies terms of the form fandef( s and, that FM “s” = c and, constants. therefore, t). From denotes fade/(t) 0 9.3). term (Definition 1 ct = cp is axiom If FM (19). Consider the fact that t E S, we have that /-MT fandel( t) = “s” (Theorem B.2). 1“s” = c (axiom therefore, br Finally, we prove the following theorem. Theorem B.4. Let w E S,. Then pM w =+ hT -w. Proof. We have one case for each form of simplifiable wff (Definition 9.4). (1) tt = t2. By induction over t2. The base case is Lemma B.3. The step cases are analogous (2) Sec( t). Either to the step cases of the proof of Lemma B.3. t denotes any object 5 of OT that is not a sequent or it denotes F. is axiom t = fail. From axiom In the former case, from Theorem B.2 we have hr (25). ( 1) we have l’&tr Tsec( t). In the latter case, from Theorem B.2 we have hr t = “5”. Gec(“e’) (3) Fail(t). axiom t denotes a sequent s. From Theorem B.2 we have kt,,rr t = “s”. From ( 1) we have l-&r-r +ail( t). (4) Canj( t) . t denotes a sequent s whose formula is not a conjunction. From Theorem B.2 we have br t = “s”. Xonj(“s”) is axiom (21). (5) Par(t). t denotes either F or an object 5 of OT which parameter. From Theorem B.2 we have either kt$r t = fail or hr axiom ( 16) we have either hr TParCfail) or br lPar( “&“). is not an individual t = “5”. From (6) Var( t). Proof analogous (7) Nofree( tl , t2). t2 denotes a sequent to the proof for Par(t). eter a that appears hr tl = “a”. TNofree( “a”, “ T--*A”) is axiom (23). q r +A in r. From Theorem B.2 we have br and tl denotes an individual param- and t2 = “r +A” R Giunchiglia, P TraversdArtificial Intelligence 80 (1996) 197-241 237 B.3. Proof of Theorem 9.6 In the proofs, we call II Theorem B.5 proves parts ( la) + and ( 1 b) +, Theorem B.6 proves part (2a) + and tree of s built by applying an inference (2b) +. the tactic terms of 171 and rule to the sequent ~1, end sequent of nl. We call TV, and r, trees. We give l7, respectively. The proofs are by induction over the structure of sequent only ( lb) x=, (2a) =+ and (2b) + are trivial corollaries of Theorems B.5 and B.6 and Theorem 9.2 (proofs by (contradiction). the proof for (VI) as conceptually to that for ( A,?$). ( la) +, the sequent identical Theorem B.5. Let II be a sequent proof of s, ,!hen kMT rT = “so and k-MT T( “s”). tree of s. Let r, be the tactic term of Il. If II is a Proof. Base. If .17 is s, then it must be either an axiom or an assumption. Then r,, is “s” and T(“s”) r, Step. is either axiom ik fallitac( T,, , “x”, “a”). From the induction hypotheses ~MT 7,, = “~1” and (11) or axiom (12). ~MT T(“sl”). From hT T(“sl”) we have hT Tac(“sl”). From axiom (7) we have hT faktac( 7,, , “x”, “a”) = if +ail( “sl “) A Var( “2’) A Par( “a”) A NoFree( “a”, “sl “) then falli( “si “, “x”, “a”) else fail (B.1) From axiom 7 ( 1) and ground axioms we have hT r, = fak( “sl”, “x”, “a”) and hT ( 10) we obtain kMT TaccfalZitac(“s~“, “x”, “a”) ) and therefore - “s”. From axiom t&-&(“S”). From axiom (1) we have hT T(“s”). 0 Theorem B’.6. Let 17 be a sequent tree of s. Let r, be the tactic term of IZ. If I7 is not a proof, then k’MT r,, = fail and kMT -T( 7,). Proof. Base. If L7 is s, then it is neither an axiom nor an assumption. Then 7, is fail. , “x”, “a”). We have two cases. Step. r, ( 1) 171 is a proof. From Theorem B.5 we have that hT T,, = “~1” and hT T( “,I”), From axiom (7) we have (B.l). is fallitac(r,,, implies hT Tac( “s,“). From axiom which (23 1) we have kMT r, = fail and therefore kMT 7T( 7,) (axioms ( 1) , (2) ) . (2) 171 is not a proof. From the induction hypotheses we have that hT 7,, = fail. Therefore bT Tac( T,,, ) . From axiom (7) we have hT 7v = if +ailcfai/) A Var( “x”) A Par( “a”) A NoFree( “a”,fail) then falli~ail, “x”, “a”) else fail Since hT Failcfail), we prove r, = fail and therefore hT 7T( 7,). 0 238 F: Giunchiglia, t! Traverso/Art@cial Intelligence 80 (1996) 197-241 B.4. Proof of Theorem 9.7 Proof by induction over the structure of Q-,(X, , . . . ,x,). Base. In the base case a tactic > Tut(x)). V’x (Tut(x) term is either “s” or fail. The corresponding tactic is Step. We consider only the case of (V’I) as the case of (A&) is very similar. Induction hypotheses are hT v’xl.. .Vx, (Tuc(xl) A.. .ATuc(x,,) ~T~c(~,[x~,...,x,])) and we have to prove hT vxl,. . . .~&,,~&+I .v&+2 (Tuc(x,) A...ATuc(x,,,) > TacCfaflituc(7,[XI,...,Xnl,n,+~,xn+2))). (B.2) Let al,. . . , a,,+2 be individual parameters of MT. From axiom (10) we prove in MT Tuc(~,,[al,. . . ,a,11 >TucCf~~~i~~c(~,[~l,...,~,l,a,+1,~,+2)) (B-3) From the induction hypotheses and (B.3) we prove Tuc( a, ) A . . . A Tada,,) > Tuccfallituc(~,[ul,. . . ,u,],u,+I,u,+~)). (B.4) We apply t’l to (B.4) and prove (B.2). B.5. Proof of Theorem 9.8 pV and t, are defined inductively over the structure of sequent trees. In the base case, > T(x)). Consider now the step case. we have ?,, and t, such that (47) We write (47) in the following form. is Vx (T(x) V’x, . ..Vx. (T(xI) A...AT(x,,) AP;[x I,..., x,] >T(t,[xl,..., x,l))(BS) where?G[xt,... (B.5) and derive Tuc(xl ) A. . .ATuc(x,,).From We can easily derive , x,] does not contain occurrences of T. We assume the hypotheses of (29) weobtain Tuc(~,[xI,...,x,]). vx, . . .vx,, 7,[Xl,. . . ,&,I = if +ail( x1 ) A . . .A-d%d(x,,) then tp[xI,...,x,] else fail From the assumption we derive -d%il( XI ) A. . .,x,1 = t,[xl,. . . ,x,1) V t,[xI,. . .,x,1 and thus Tuc(t,[xl,. . . , x, ] = fail (definition . . A -dM( x,) A P?: [ XI , . . . , x,] . There- . .,x,,]>, which is (8) ) . From axioms (5) we easily prove that -+, [ x1, . . . ,x,] =fuiland thereforeT(t,[xt,...,x,]). fore we obtain r,[xt,. equivalent to T(t,[xl,. (4)) APG[x~,...,x,,] (B.6) F: Giunchiglia, P. Traver.so/Artificial Intelligence 80 (1996) 197-241 239 References 1 I I A. Armando, Architetture riflessive per la deduzione automatica, Ph.D. Thesis, DIST, University of Genoa. Genoa ( 1993). 121 A. Avron, E Honsell and I. Mason, Using typed machine, LFCS Report Series ECS-LFCS-89-72, Computer Science Department, University of Edinburgh, Edinburgh Laboratory ( 1989). lambda calculus to implement formal systems on a for the Foundations of Computer Science, 13 1 D. Basin and R. Constable, Metalogical frameworks, in: Proceedings Second Workshop on Logical Frame uorks, Edinburgh 14 I D. Basin, E Giunchiglia ( 199 1) . and P. Traverse, Automating meta-theory 1991, 2nd Conference of the Italian Association AI*IA 48-57: also: IRST-Technical Report 9101-04, 15 I K.A. Elowen and R.A. Kowalski, Amalgamating for Artificial intelligence creation and system extension, in: (Springer, Berlin, 199 1) IRST, Trento. language and meta-language in logic programming, in: S. Tarlund, ed., Logic Programming 16 I K.A. 13owen and T. Weiberhg, A meta-level (Academic Press, New York, 1982) 153-173. extension of prolog, in: IEEE Symposium on Logic Progumming, Boston, MA (1985) 669-675. [ 7 I R.S. Boyer and J.S. Moore, A Compufarional 18 1 R.S. Bayer and J.S. Moore, Metafunctions: proof Iprocedures, (Academic Press, New York, 1981) 103-184. Logic proving in: R.S. Boyer and J.S. Moore, eds., The Correctness Problem them correct and using (Academic Press, New York, 1979). them efficiently as new in Compurer Science 19 I R.S. Boyer and J.S. Moore, A theorem prover for a computational logic, in: Proceedings 10th Conference on Auumafed Deduction, Lecture Notes in Computer Science 449 (Springer, Berlin, 1990) I 101 A. Bundy, The use of explicit plans Proceedings 9th Conference on Automated Deduction available as DA1 Research Paper No. 349, Department of Artificial I-IS. in: R. Luck and R. Overbeek, to guide inductive proofs, eds., (Springer, Berlin, 1988) 11 I-120; Longer version Intelligence, Edinburgh. for selective application of multiple rewrite rules Intell. 16 ( 198 I ) 189-2 12: also: DA1 Research Paper 12 1, Department inference [ 1 I 1 A. Bundy and B. Welham, Using meta-level in algebraic manipulation, Arti of Arlficial Intelligence, Edinburgh. I 12 I R. Cartwright AIM-324 and J. McCarthy, Recursive programs as functions ( 1979) ; also: CS Department Report STAN-CS-79- 17. in a first order theory, SAIL MEMO I 13 1 C.C. Chang and J.M. Keisler, Model Theory I 14 I R.L. Constable, SF. Allen and H.M. Bromley et al., Implementing Marhemafics with (North-Holland, Amsterdam, 1973). the NuPRL Proof Deve/opmenr System (Prentice-Hall, Englewood Cliffs, NJ, 1986). [ 15 I S. Feferman, Transfinite recursive progressions of axiomatic theories, J. Symbolic Logic 27 ( 1962) 259-316. I 16 1 A. Felty, Implementing tactics and tacticals in a higher-order logic programming language, J. Autom. Retrsouing 11 (1993) 43-81. I 17 I E Giunchiglia, Geneva, Genoa ( 1994). I I8 I F. Giunchiglia Trento I 191 E Giunchiglia (1989). I20 I F. Giunchiglia The GETFOL Manual ( 1992). - CETFOL version 1, Tech. Rept. 92-0010, DIST, University of and A. Armando, A conceptual architecture for introspective systems, Tech. Rept., IRST, and A. Cimatti. HGKM Manual - a revised version, Tech. Rept. 8906-22, IRST, Trento and A. Cimatti, Introspective metatheoretic reasoning, in: Proceedings META-94, Workshop on Mefaprogramming in Logic, Pisa ( 1994); also: Tech. Rept. 921 I-21, IRST, Trento. and L. Serafini, Multilanguage Intell. 65 ( 1994) 29-70. 12 I I E Giunchiglia logics), ArfiJ I22 I E Giimchiglia, semantics, in Computer Science 649 (Springer, Berlin, 1992) 235-249; and A. Smaill, Reflection [ 23 I F. Gilmchiglia in constructive hierarchical in: Proceedings META-92, Workshop on Mefaprogramming L. Serafini and A. Simpson, Hierarchical meta-logics: intuitions, theory and in Logic, Uppsala, Lecture Notes proof also: Tech. Rept. 9101-05, and non-constructive automated IRST, Trento. reasoning, logics (or: how we can do without modal in: H Abramson and M.H. Rogers, eds., Proceedings META-88, Workshop on Metaprogrumming in IRST, Trento and DA1 (MIT Press, Cambridge, MA, 1988) 123-145; also: Tech. Rept. 8902-04, Logic Research Paper 375, University of Edinburgh, Edinburgh. 240 F Ciunchiglia. I? Traverse/Artificial Intelligence 80 (1996) 197-241 I24 1 E Giunchiglia metatheories, ( 1990) 306-322; and P Traverse, Plan formation and execution in a uniform architecture in: M. Bruynooghe, ed., Proceedings META-90. Workshop on Metaprogramming of declarative in Logic also: Tech. Rept. 9003-12, IRST, Trento. ! 25 I F. Giunchiglia and P. Traverse, Program tactics and logic tactics, in: Proceedings 5th International Conference on Lqqic Programming Rept. 9301-01, and Mathematics, Fort Lauderdale, FL ( 1994). and Automated Reasoning IRST, Trento, presented at the Third International Symposium on Artificial (LPAR’94), Kiev ( 1994); also: Tech. Intelligence I26 1 E Giunchiglia monotonicity, Amsterdam, I27 ) E Giunchiglia and R.W. Weyhrauch, A multi-context monotonic in: D. Nardi and P Maes, eds., Meta-Level Architectures axiomatization of inessential non- and Reflection (North-Holland, 1988) 271-285; also: Tech. Rept. 9105-02, DIST, University of Genova, Genova. and R.W. Weyhrauch, FOL User Manual - FOL version 2, Manual 9109-08, IRST, Trento 128 1 K. Code], Uber formal unentscheidbare ( I99 1) ; also: Tech. Rept. 9 I-0006, DIST, University of Genova, Genova. Siitze der Principia Mathematics (English Moncrtsh. Mat/z. Phys. 38 ( 1931) 173-98 translation 1291 J. Goguen, Higher-order functions considered unnecessary und verwandter Systeme I, in 151 I). for higher-order in: D.A. (Addison-Wesley, Reading, MA, 1990) 309- programming, Turner, ed., Research Epics 351. in Functional Programming I30 1 J. Goguen, A. Stevens, H. Hilbrdink and K. Hobley, 20BJ: a metalogical framework theorem prover based on equational logic, Phil. Trans. R. Sot. Land. 339 ( 1992) 69-86. I 3 1 1 M.J. Gordon, A proof generating system for higher-order logic, in: G. Birtwistle and PA. Subrahmanyam, eds., VLSl Spec@cation and Synthesis (Kluwer, Dordrecht, I32 1 M.J. Gordon, A.J. Milner and C.P Wadsworth, Edinburgh LCF - A Mechanized Logic of Computation, 1987). Lecture Notes in Computer Science 78 (Springer, Berlin, 1979). I33 I R. Harper, E Home1 and G. Plotkin, A framework for defining logic% in: Symposium on Logic in Computer Science I341 R. Harper, D. McQueen ( 197 I ) 194-204. Laboratory Edinburgh, Edinburgh for Foundations ( 1986). and Robin Milner, Standard ML, LFCS report series ECS-LFCS-86-2, of Computer Science, Department of Computer Science, University of 13.5 1 PM. Hill and J.W. Lloyd, Analysis of meta-programs, in: J. Lloyd, ed., Proceedings META-88, Workshop on Metaprogrumming in Logic (MIT Press, Cambridge, MA, 1989). I361 P.M. Hill and J.W. Lloyd, The Giidel programming language, Tech. Rept. CSTR 92-27, Department of Computer Science, University of Bristol, Bristol ( 1992). ( 37 I D.J. Howe, Computational metatheory I38 1 S. Jagannathan and G. Agha, A reflective model of inheritance, in Nuprl, in: R. Lusk and R. Overbeek, eds., CADE9 ( 1988). in: The Sixth European Conference to (Springer, Berlin, in Computer Science Programming ( 1992), Lecture Notes on Object-Oriented appear). I 39 1 S.C. Kleene, 1401 T.B. Knoblock Introduction to Metamathematics (North-Holland, Amsterdam, 1952). and R.L. Constable, Formalized metatheory in type theory, Tech. Rept. TR 86-742, Department of Computer Science, Cornell University, Ithaca, NY ( 1986). I41 I S.A. Kripke, Outline of a theory of truth, University Press, Oxford, 1984) 53-82. in: Recent Essays on Truth and the Liar Paradox (Oxford Theory cti Computation (McGraw-Hill, New York, 1974). in Cambridge LCF, Tech. Rept. 39, Computer Laboratory, University I 42 1 Z. Manna, Mathematical I43 I L. Paulson, Tactics and tacticals of Cambridge, Cambridge ( 1979). I44 I L. Paulson, The foundation of a generic 145 I L.C. Paulson, A higher-order I46 I D. Prawitz, Natural Deduction I47 I B.C. Smith, Reflection and semantics I48 I M.J. Stefik, Planning and meta-planning, 1491 C. Talcott, The essence of RUM: theorem prover, J. Autom. Reasoning 5 ( 1989) 363-396. implementation of rewriting, Sci. Comput. Program. 3 ( 1983) 119-149. - A Proof Theoretical Study (Almquist and Wiksell, Stockholm, 1965). in LISP, in: Proceedings llth ACM POPL ( 1983) 23-35. Ar/t$ Intell. 16 (1981) 141-169. aspects of LISP-type computation, Ph.D. Thesis, Department of Computer Science, Stanford University, Stanford, CA ( 1985); also: report STAN-CS-85-1060. and extensional theory of the intensional 150 1 A. Tarski, Logic, Semantics, Mefumathematics (Oxford University Press, Oxford, 1956). F: Giunchiglia, I? Traverso/Artijicial Intelligence 80 (1996) 197-241 241 15 I 1 J. Van Heijenoort, From Frege to Giidel: A Source Book in Mathematical Logic. 1879-3931 (Harvard University Press, Cambridge, MA, 1967). 152 1 L. Vi8anb, Sintesi ed esecuzione di strategie di prova nella metateoria formale di un dimostratore interatrivo, Thesis, University of Genoa, Genoa ( 1994). 153 1 J. von Wright, Representing higher-order logic proofs in HOL, Tech. Rept. jan-18-94, Abo Akademi University, Turku ( 1994). 154 I R.W. Weyhrauch, Prolegomena 133-I 76. to a theory of mechanized formal reasoning, Arti& Intell. 13 ( 1980) 155 1 R.W. Weyhrauch, An example of FOL using metatheory. Formalizing reasoning and introducing derived inference rules, in: Proceedings 6th Conference on Automatic Deduction, New York ( 1982). I56 I R.W. Weyhrauch and C. Talcott, HGKM: a simple 157 1 A. Yonezawa, A reflective object oriented concurrent implementation, FOL working paper 4 ( 1985). language, Lecrure Notes in Computer Science 441 (Springer, Berlin, 199 I ) 254-256. 