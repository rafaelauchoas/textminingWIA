ELSEVIER Artificial Intelligence 74 (1995) 55-81 Artificial Intelligence Inductive functional programming using incremental program transformation Roland Olsson * Department of Computer Science. &fold College, OS Alle’ 9, 1777 Halden, Norway Received April 1993; revised March 1994 Abstract The paper presents a system, ADATE, for automatic functional programming. ADATE uses specifications that contain few constraints on the programs to be synthesized and that allow a wide range of correct programs. ADATE can generate novel and unexpected recursive programs with automatic invention of recursive auxiliary functions. Successively better programs are developed using incremental program transformations. A key to the success of ADATE is the exact design of these transformations. and how to systematically search for appropriate transformation sequences. 1. Introduction This paper reports on a system, ADATE& that synthesizes recursive Standard ML programs using a specification consisting of sample inputs and an output evaluation function. The name ADATE, Automatic Design of Algorithms Through Evolution, in- dicates that the goal of the research is automatic invention of new algorithms and not only automatic implementation of algorithms that the ADATE user already knows. One major dimension along which to differentiate inductive inference systems is the amount of information in the specifications that they employ. At one extreme are [ 11. At the same end of the spectrum are systems that use traces of computations systems requiring specifications that consist of input-output pairs [ 2,8, lo] or positive In such systems, and negative examples as in inductive logic programming [ 6,7,9,12]. the input-output pairs or the examples must have a structure that corresponds to a specific algorithm. * E-mail: Roland.Olsson@hiof.no. 0004-3702/95/$09.50 @ 1995 Elsevier Science B.V. All rights reserved SSDIOOO4-3702(94)00042-5 56 R. Olsson/Artifcial Intelligence 74 (1995) 55-81 such that the ratio between At the other end of the spectrum are genetic algorithm [ 51 and ADAm, which use specifications the difficulty of writing a desirable program and the difficulty of specification may be enormous. An important difference recursive between ADATE and GA systems search programs of the program space. is that the latter are very poor at inferring they use primitive program and an unsystematic (GA) systems transformations since syntactic complexity space. Section 3 presents the search of the program Section 2 explains how to specify programs and gives measures of program quality and time complexity. These measures are used such as correctness, the subset of Standard to guide ML in which inferred programs are written. Programs are synthesized using incremental transformations replace- ment, function and type embedding. The overall strategy the program space is given in Section 5. This strategy is based on iterative- for searching details and experimental deepening results. The next section discusses that are related to ADATE. The final section contains merits and drawbacks with ADATE and directions [ 41. Sections 6 and 7 list implementation systems in Section 4. These transformations as discussed abstraction, for future research. case-distribution are expression inference inductive 2. Specification and selection of programs A specification wants a program chosen specification are: implicitly defines a set C of correct programs. The specification writer for a from a set D of desirable programs. Some requirements ( 1) The specification should be as easy as possible to write and preferably be much simpler than any desirable program. (2) The specification (3) All desirable programs should facilitate efficient inference. should be correct according to the specification, i.e., D C C. (4) A computer correct. should reasonably quickly be able to decide if a given program is ( 1) and (2) are often in conflict. One main goal of the research presented to be as simple as possible. The only efficiency that were should be possible using computers inferences Requirements in this paper was to allow specifications goal was that many generally available A specification interesting in 1993. that satisfies requirement that eliminate if requirement does not contain constraints are loose. Even in comparison with the programs very simple the well-known NP-hard problems can be used to construct employ sample inputs and an output evaluation 4 is satisfied, that satisfy function. (3) is said to be loose. A loose specification desirable programs. ADATE specifications there are still many specifications that are them. For example, most of such specifications, which Example 2.1. Assume that the specification writer knows the minimum I. It is easy to construct of nodes. Here is a simple specification of a program P. that I is a large instance of the traveling salesman problem and cycle on in time O(n*), where n is the total number length &ii, of a Hamiltonian such an instance R. Olsson/Artijicial Intelligence 74 (1995) 55-81 57 Given input I, P is required to output a Hamiltonian cycle C of length &, less than n2/106 CPU seconds. in Note that it takes time O(n) to check if C is a Hamiltonian cycle of length L,,,,t,. The correctness of P is thus decidable in time 0(n2/106) + O(n) = 0(n2) even though P may be extremely difficult to find. The Journal of Algorithms maintains a list with hundreds of NP-complete problems that can be used to construct similar specifications. 2.1. Specijcation form Assume that a specification is to be used to check a synthesized ML program P. P is a definition of a function f which is an approximation of a desirable function. An ADAm specification consists of ( 1) a set of types, (2) (3) (4) a set of sample inputs { It, 12, . . ., Z# I }, evaluation (5) an output the primitive functions that are to be used in inferred programs, the type of f, function oe, which uses the set { (Zt , f( II)), . . ..(Z+YI.~(Z+YI))} torate P. The sample inputs need to be chosen so that incremental inference is facilitated. This means that the inputs should contain sufficiently many special cases. The sample inputs in the specification of a list sorting program may for example include an empty list, a singleton list, a sorted list and a few random lists. One interesting progression of more and more difficult sample inputs would be the problems in mathematics textbooks, rang- ing from first grade in elementary school up to university level. Even if the specification writer may not need to be as “pedagogical” as the authors of such textbooks, the sample inputs still need to be carefully chosen. It is important that specifications are not required to be based on input-output pairs. We have identified the following four problems with input-output pair specifications. Problems. ( 1) The choice of output sometimes reflects the particular algorithm that was used to construct it. The specification writer needs to know this algorithm to be able to provide output. An inference system naturally becomes much less useful if the writer is required to know the algorithm to be inferred. (2) Looseness is lost if the pairs do not include all possible outputs for a given input. (3) An input-output pair specification grades an output as correct or wrong. It is often desirable to use more than two grades. For example, the grades can be all real numbers in some interval. (4) It may be too difficult for the user to provide optimal outputs. Here are four examples such that example number (i) illustrates problem number (i) . 58 Examples. R. Ol.wm/Arti$cial Intelligence 74 (1995) 55-81 ( 1) Consider the specification of a function split : ‘a list -> ‘a list * ‘a list that splits a list Xs into a pair of lists (Ys , Zs) such that the lengths of Ys and Zs differ by at most one. The split is useful when implementing merge sort. The input-output function pair ([1,2,3,4,5,6,7,81, (l.l,2,3,4l,C5,6,7,8l>) reflects the particular algorithm obviously and Zs to the second half. However, and faster. that chooses Ys to the first half of Xs is both simpler the following split algorithm fun split nil = (nil,nil) I split (Xl::Xsl) = case split Xsl of (Ys,Zs) => (Xl::ZS,YS) An input-output pair that reflects this algorithm is thus ([1,2,3,4,5,6,7,81, (C1,3,5,71,[2,4,6,81)). Instead of giving outputs, function. Assume means output evaluation that Bs is a permutation that the function function computes it is much better to provide an output evaluation is-perm of As. Given is defined so that is_perm(As,Bs) (Ys, Zs), input Xs and output the is_perm(Xs,YsQZs) andalso abs(length Ys - length Zs) <= 1, where Q is the ML operator for list concatenation. (2) Problem (2) can be exemplified using ification only allowed programs of length Lmin, a program regarded as incorrect. The specification would tour exists. that produces another the above TSP specification. that produce a particular pre-determined If the spec- tour tour of length Lh” would be therefore not be loose if such a (3) This example illustrates intersects the usefulness of grades. Consider navigation of a poly- function the output evaluation any obstacle, compute if a given path, represented by a series of points and angles of the length and curvature of the path, gon among polygonal obstacles. When computing one might check rotation, the amount of rotation along the path and its safety i.e., margin In order consider choosing be difficult for the specification writer to provide optimal outputs i.e., Hamiltonian cycles of minimum to provide optimal outputs, It would then random graphs as inputs in the TSP specification. it may be problematic to obstacles. to illustrate length. that (4) 2.2. The output evaluation function Since the output evaluation in ADATE, the exact form of oe is described below. An inferred program may contain a special to be considered when defining oe. A ? constant means “don’t- constant, ?, that needs function oe is of fundamental importance R. Olsson/Artificial Intelligence 74 (1995) 55-81 59 know”. A correct a wrong of oe Let the is better of f a don’t-know input-type -> which in is better The domain (input-type * exec_result) list, execzesult is as datatype exec_result = I too_many_calls I some of ‘a. The outcome of the computation of f(Zi) is 0 ? if any ?-constant was evaluated, l too_many_calls exceeded, and if the call count l some Oi otherwise. limit, which is discussed in Section 6, was ADATF calls oe with an argument Execute-result which C(Zl,Rl),..., The range (I# 1, RN 1) I, where each Ri is the outcome of the computation list where cwd is defined as type of oe is cwd list * real is a list of the form of f( Zi) , datatype cwd = correct I wrong I dent_know returns to (Zir Ri) in Executezesult. If the call oe Executeresult sponds is to be minimized for example have the form [Grade-l, Grade21, where Grade-1 Grade2. i in Cs corre- is a list of floating point numbers which ordering on lists. Grades may than is more important element number lexicographic to the usual (Cs,Grades), according Grades of a program Example 2.2. Consider the specification that simplifies polynomials. As- of a polynomial Xs, e.g. 3X2 + 4X + 8X2 - 5X + 4 - X2 + 8, sume that simplification yields a polynomial Ys, e.g. 12 + 10X* - X. For a given polynomial Xs the user may need to determine how good an output Ys is without knowing any optimal output nor is defined so that the any way of computing for call eval_pol the variable is easier to define than a function [Grade] eval_pol the polynomial Pol with the integer Z substituted e.g. eval_pol( X3 +X2 + 1,3) = 37. Note that evalpol that simplifies polynomials. Grades (Pol , Z) evaluates in the polynomial, that the function such that Grade one. Assume is a singleton list than M + N different degrees. A polynomial oe checks that Xs and Ys are equivalent is the sum of the lengths of all correct output polynomials. in Xs and Ys respectively, that (Ys ,X> for all integers X in 1,. . . , it4 + N. This check since Xs@Ys cannot contain as a list the auxiliary in comparison pairs. The complete definition of oe, including looks complicated the structure of oe-definitions is shown in Fig. 1. This definition program. However, is even if much more complicated programs are is represented simplification (Xs ,X> = evalpol to ensure suffices evalpol obviously terms of more of (coefficient,exponent) evalpol with a polynomial basically specified. definition, If M and N are the number of terms the same for all specifications, 60 R. Olsson/Art@cial Intelligence 74 (1995) 55-81 (PO1 , Z) = fun eval_pol case Pol of nil => 0 I (Coeff,Exponent)::Pol Coeff * int_pow(Z,Exponent) => + eval_pol(Pol,Z) handle _ => 0 fun oe(Execute_result : cwd list * real : (input-type list = let val Zs = map(fn(Xs,R) => case R of ? => (dont_know,O) * output-type exec_result) list) I too_many_calls I some Ys => let => (wrong,O) val M = length Xs val N = length Ys in if (N<=l orelse N<M) andalso forall(fn X => eval_pol(Xs,X)=eval_pol(Ys,X), fromto(l,M+N)) then (correct ,N) else (wrong,01 end, Execute-result) in (map(#l,Zs), Creal(int_snm(map(#2,Zs)))l) end Fig. 1. The output evaluation function for polynomial simplification 2.3. The program evaluation functions ADATE uses the sample inputs II,. . . , I# 1 and the output evaluation function oe to compute three program evaluation functions pel, pe:! and pe3 that supplement the pro- gram rating provided by oe with measures of syntactic complexity and time complexity. The syntactic complexity is defined as follows. Let Nt , . . . , N# N be all nodes in the tree representations the number of symbols simplicity which is defined as Cy=f” log, mi. of all expressions that may occur and speed, type constraints are ignored when computing syntactic complexity, in the program. Due to scoping constraints, in node Ni is limited to some number mi. For The function f and the let-functions of f( It ) , . . . , f( I# I). The defined time complexity measure in a program P are called during the for P is the total computation number of such calls. Let l NC = the number of correct outputs, l NW = the number of wrong outputs, l S = the syntactic complexity, R. OlssodArtificial Intelligence 74 (1995) 55-81 61 Table 1 The definitions of pet, pa2 and pe3 i Value returned by pai 1 2 3 :: Grades Q [N,,S,TI :: Grades @ CN,,T,SI -NC -NC CN,.,,-NJ @ Grades (D [S,Tl l 7-z the total call count. The three program evaluation functions are defined in Table 1. A program P is to be better than a program Q according to pei if and only if pei(P) considered comes before poi(Q) in the lexicographic ordering of lists. For example, the program evaluation function pei prefers correctness to small syntactic complexity which in turn is preferred to low call count. 3. The functional language in which inferred programs are written Inferred programs are written in a subset of Standard ML without currying, boolean and references. All functions are viewed as having a single fun- operators, if-expressions argument which is a tuple. The ML subset consists of datatype-definitions, definitions, case-expressions and let-expressions. ( (int * int in the to be fully is restricted The pattern the (B as left-hand side of a fun-definition to a sin- gle tuple pattern. A tuple pattern is always required layered which that names are introduced means for all possible parts of a tuple pattern. For example, * int) type like * int) (C ,D> ,E) ,F). Requiring tuple patterns to be fully layered often leads (A as to the introduction of superfluous names. This problem is more aesthetic than practical. are required to exactly correspond to the al- for the type of the expression that is analyzed. in addition to tuple ternatives in the datatype-definition The only constructor allowed in the pattern of a case-alternative constructors is a single occurrence of the corresponding constructor in the datatype- definition. case-expressions are used instead of let-expressions of arity zero. Thus, the case-expression let-expression that introduce functions case Et of V => E2 is used instead of the The alternatives in a case-expression let val V = El to a pattern in Ez end. corresponds In ML, any expression El may be applied to an expression E2 provided that the type of E2 matches the domain type of El, but ADATE only produces applications where EI is a function symbol. 4. The program transformations A compound transformation is the composition of a sequence of atomic transforma- tions. The program evaluation functions pei, pe2 and pes, which are used to determine whether a program is to be kept or discarded, are only applied to programs resulting from compound transformations. Assume that program Pi+1 is produced from program 62 R. Olsson/Arrijicial Intelligence 74 (1995) 55-81 Pi with an atomic from PI will be written tr t2 . . t# ,. transformation ti. A compound transformation that produces P# t+, The initial program only consists of a single ? and thus gives a don’t-know output through a sequence is evolved from the initial program for all inputs. The final program of compound transformations. 4.1. Expression synthesis The synthesis of new expressions is fundamental synthesis containing form of expression for the transformation in order of increasing and exhaustive production is enumerative a fixed set of function size. The size of an expression A simple type correct expressions synthesized in the tree representation size 1, then all expressions the number of expressions of size 2 and so on. Since normally grows exponentially with size, great care must be taken to keep the size small expressions. The mere thought of such and to heuristically that is hard to overcome when exponential trying of the expression. ADATE first synthesizes acts as a mental barrier of a program. of are is the number of nodes all expressions of symbols. Expressions growth undoubtedly the most promising of ADATE. identify to understand ADATE employs ( I) Assume that the limitations the following heuristics. case E of Match, => Unknown] I ... I Match, => Unknown,, is a partially constant synthesized case-expression that later is to be replaced with a synthesized The program to be transformed contains replaced by a finished synthesized expression. case-expression should be discarded, Sub is replaced with the expression where each Unknowni expression. is a “dummy” a subexpression In order to check if the incomplete Sub that is to be (case E of Match, => Unknown1 I ... I Match, => Unknown,,; Sub ). for all sample is then executed if and only The resulting program is said to be activated The entire case-expression and finished case-expression a synthesized inputs. An expression this execution. if only one Unknowni was activated the is produced by replacing each activated Unknowni with and each non-activated Unknowni with a ?. the synthesis of a recursive call g( A,, A2, . . . , A,,) occurring the corresponding Matchi does not contain if it was evaluated during any variable. Otherwise, is discarded expression (2) Consider , V,> = . . At least one Ai is required v. A; is “smaller” than x if and only if Ai occurs in an in the dec- to be “smaller” g;(h,V*,... larationfun than the corresponding RHSk in a case-expression case L$ of Match, => RHS! I . . I Match,,, => RHS,, and (a) Ai is a proper subexpression (b) Matchk contains a variable W such that Ai is “smaller” of Matchk or than W. R. OlssodArrijicial helligence 74 (1995) 55-81 63 4.2. The atomic transformations There are four atomic transformations namely replacement, abstraction, case-distri- bution and embedding. 4.2.1. Replacement Replacement program. A replacement Sub of the program. During as subexpressions the replacement is the only atomic substitutes transformation a synthesized the synthesis of ,Synt, subexpressions of Synt. When Sub itself, but no other subexpression can be viewed as an insertion of a synthesized expression. the semantics of a that may change expression Synt for a subexpression of Sub may be reused of Sub, is reused, the inference of a list sorting program. Assume Example 4.1. Consider inputs are I1 = Cl , 12 = CIOI, Z3 = C10,20,30,401, 15 = [IO, 20,50,401. transformation fun In one out of many possible the last consists of a single sort Xs = ?. except Z4= [50,20,60,20,401 that the sample and inferences of sort, replacement. The initial program each compound is ( 1) Replacing the ? with the synthesized expression case Xs of nil => Xs I Xl::Xsl => ? is the first compound transformation which gives fun sort Xs = case Xs of nil => Xs I Xl::Xsl => ? (2) The next compound transformation is another ?-replacement that yields fun sort Xs = case Xs of nil I Xl::Xsl => Xs => case Xsl of nil => Xs I X2::Xs2 => ? (3) The third compound transformation, which also is a ?-replacement, gives fun sort Xs = case Xs of nil I Xl::Xsl => case Xsl of nil I X2::Xs2 => Xs => Xs => case X2xX1 of true => ? I false => Xs (4) The program above gives correct output for inputs is improved expression and wrong output by replacing Xsl with the synthesized for IS. The program II, 12 and Z3, ?-output to also give ?-output sort Xsl, which yields for 14 for ZS fun sort Xs = case Xs of nil I Xl::Xsl => case I X2::Xs2 => Xs sort Xsl of nil => Xs => case X2<XI of true => ? I false => Xs The final compound transformation is shown in Section 4.2.2. 64 R. Olsson/Artifcial Intelligence 74 (1995) 55-81 returns between In order to discriminate function peREu which the peREo value will be denoted by REQ whereas an ordinary replacements, ADATE employs a special program -NC : : Grades Q [NW]. A replacement that replace- contains several replacements, evaluation does not increase ment will be denoted by R. If a compound ADATB usually requires by trying Rs and selecting the ones that do not increase a small fraction of the Rs meet this requirement. The REQs are sorted according to the best REQs. are REQs. REQs are found value. Normally, only to the that one or more of the replacements value to give preference transformation the peREQ peREQ 4.2.2. Abstraction An abstraction E of the program introduces to be transformed. The transformation with a definition based on a subexpression is a let-function schema H(EI,E;!,...,&) let fun g(Vl,V2 --f ,..., V,) = H(Vi,V2 ,..., V,) in g(Er,Ez ,..., E,) end, where g is a new function. Matching E against H( El, E2,. . . , E,) may be viewed as higher-order unification that finds values for the variables H, El, E2, . . , E,. Example 4.2. One possible unifier of H( El, E2) and a(b(c(d) c(d), E2 = f(x) and H = fn(Xl,X2) => a(b(Xl,e) ,X2). ,o) ,f (x)) is El = An abstraction is done by choosing El,. . . , E, to disjoint subexpressions of E. Example 4.3. The last compound ABSTR REQ REQ R where ABSTR denotes an abstraction the last sort transformation program given above. The ABSTR has n = 1, El = sort Xsl and in the inference of sort has the form transformation. Consider H(EI) = case I X2::Xs2 sort Xsl of nil => Xs => case X2(X1 of true => ? I false => Xs The program produced by the ABSTR is thus => Xs fun sort Xs = case X.5 of nil I Xl::Xsl => let fun g Vi = case Vl of nil I X2::Xs2 in g(sort Xsl) end The first REQ replaces => Xs => case X2<Xl of true => ? I false => Xs fourth occurrence labeled Xs ’ and Xs ’ ‘. The program above is then written as that these occurrences of Xs. Assume for pedagogical the third occurrence of Xs. The second REQ replaces the reasons are R. OlssordArtificial Intelligence 74 (1995) 55-81 65 fun sort xs = case Xs of nil => Xs I Xl::Xsl let fun g Vl = => case VI of nil => Xs’ I X2::Xs2 => case X2(X1 of true => ? I false => X.9” in g(sort Xsl) end The first REQ replaces Xs ’ with the synthesized expression Xl : : nil. This preserves equivalence since Xs ’ always is a singleton. The second REQ replaces Xs ’ ’ with the synthesized expression Xl : : Vi. Equivalence is preserved since Xs ’ ’ always is sorted. The R then finally replaces the ? with the synthesized expression X2: :g Xs2 which yields a correct sorting program i.e., fun sort Xs = case Xs of nil => Xs I Xl::Xsl => let fun g Vl = case Vl of nil => X1::nil I X2::Xs2 => case X2<Xl of true => X2::g Xs2 I false => Xl::Vl in gbort Xsl) end 4.2.3. case-distribution This transformation symbol. is based on the following schema, where h denotes a function h(Ar,..., Ai, case E of Match1 => El I **. I Match, => E,,,Ai+l,...,A,) - case E of Match1 => h(Al ,..., Ai,El,Ai+l,..., A,) I Match, => h(Al,...,Ai,E,,Ai+l,...,A,) A case-distribution Note that the schema may be used both left-to-right and right-to-left. If the schema is USE left-to-right and some Ek is ?, h( Al,. . . , Ai, Ek, Ai+l, . . . , A,,,) is changed to ?. transformation consists of one or more applications of the schema. Each application marks the h and the case that were used. In the most general case, the first application may use any h and case such that the h is the parent or a child of the case. Subsequent applications are only allowed to use hs and cases that are marked or that have at least one marked child or parent in the expression tree. The purpose of marking is to only allow “related” applications of the schema. 66 R. Olsson/Artijicial Intelligence 74 (1995) S5-81 4.2.4. Embedding An embedding generalizes the type of a let-function. Two examples of embeddings are to add an argument list. Assume type ‘a to the function or to change an argument of type ‘a to one of that the let-function to be embedded has the definition let fun g(Vl ,V2,. .,V,> = RHS in Exp end. In its most general form, an embedding inserts a synthesized for g. When the type of g changes, to change too. Changing the types of functions occurring these types may make types and so on. Since types to change, a simplified this “chain reaction” makes form of embedding type expression into the in it necessary it a bit difficult that avoids chain type expression RHS and Exp may need to change other to choose which reactions is described below. The data type definitions provided by the specification writer are used for embedding. The allowed data type definitions following form. are a subset of ML data type definitions and have the datatype (‘at ,‘a2,. . ,‘a#,) Type-constructor = CI of TIJ * TI,~ * . . * 7’1.#7,, / c2 of T2,1 * T2,2 * . * T2,#Tz 1 C# c of T# C.I * T, c,2 * * T# c,# TN ( Each ‘ai is a type variable, each C.; is a constructor and each Tj,k is the type of argument number k of constructor C,i. A given datatype-definition T,,k. The types T and Tj,k are considered Tj,k may be applied to an object of type T according to the typing rules of ML. may be used to embed a type T only if T matches some type to match only if a function with domain Example 4.4. The datatype-definition for lists is datatype ‘a list = nil I :: of ‘a * ‘a list Since T2,1 is the type variable to embed any type. For example, embedding bin-tree) list. ‘a, which matches any type, this definition may be used the type ‘b bin-tree yields the type ( 'b Tuple types are predefined and given special treatment. A tuple type T, * . . . * T,, can be embedded in two ways. ( 1) The new type is TI * . (2) An index as described above. * T, * ‘a, where ‘a is a fresh type variable. i is chosen and the type T; is embedded using a datatype-definition The embedding structor bin-tree, to (int restriction corresponding list) of a proper subtree of some Ti is not allowed. Using the tuple type int list bin-tree * boo1 but not to (int simplifies the translation between the type con- * boo1 may for example be embedded * bool. This the type and an expression of the old bin-tree) list expression of the new type as described below. R. OlssodArtiJicial Intelligence 74 (1995) 55-81 67 tuple The only types Note that all embeddings reactions. The following to be synthesized that may be embedded the range of g. avoid chain schemas use a special constant, ?_emb, to denote an expression given below preserve semantics are the domain and completely and as part of an embedding transformation. Embedding Assume the domain of g that the domain is to be used. The two ways of embedding type of g is Tl * . . . * T, and that the datatype-definition tuple types given above are now for lists used as follows. (1) T, *-..*T,, to g( El,. (2) T,*.-.*q*...*T,, (a) Each to Tl *... * T,, *’ a. Each call of the form g( El,. . . , E,) is changed . . , E,, , ?_emb) toT,*...*Tilist*...*T,. call g(El,...,Ei, . . . , E,) is changed to g(E1,. . . , Ei: :?_emb, . ,&,I. (b) &IS is replaced by case K of nil => ?smb I X: :Xs => ( RHS with X substituted for K ), where X and XS are fresh variables. Embedding Assume the range of g that the range lists is to be used. The two ways of embedding as follows. (1) Tl *.-.*T,, toTI *-..*T,*‘a. (a) Each call g(. . .> is changed to type of g is Tl * . . . * T, and that the datatype-definition for tuple types given above are now used case g(. . .) of X as (Xl ,... ,Xn,Xn+t) => (Xl,. . .,X,). (b) The RHS, which is changed case-distribution a case-expression below. in this case is assumed , E,,, ?_emb). to (El,... to have the form (El,. . . , E,,), If n = 1 and El is a case-expression, is used to move ?_emb downwards until no ?smb as sibling. This is illustrated by the delrmin has example (2) T, * . . . * c * . . . * T, to Tl * . . . * K list (a) Ifn= 1, each call g(. . .) is changed * . . . * T,. to case g(...) of nil => ?_emb 1 X: :XS => X. If n > 2, each call g(. . .I is changed to case g(. . .) of X as (Xl,. *. ,Xi,. . . , Xn) => case Xi of nil => ?_emb I Y: :YS => (Xl,. ..,Xi_t,I:Xi+t,. . .9X,) * (b) The RHS, which in this case (El,. to is changed . . . , E,), expression, no ?_emb has a case-expression case-distribution is employed as sibling. to have is assumed . -9 Ei: :?-emb, . . . , En). . . . , Ei, (El, If Ei is a case- to move ?_emb downwards until the form 68 R. OlssodArtijicial Intelligence 74 (1995) 55-81 several (2) (a) in case for embedding the constructor The datatype-definition for lists was used above in order to make the presentation of the domain and : : was used In general, In case of the range, types Tj,k that match T;. For each such Tj,k, Ei may be translated ,?$ is argument number less abstract. embedding of type Ti to an expression of type Ti list. contain Cj(?_emb,. straightforward for lists. The same (j, k) must be used for all translations restriction in case (2) (b) for embedding of the domain and in case (2) (a) for embedding of the range. for (2) (b) an expression Ei may to k. It is of course also other than the one in the same embedding. This to use for translation to translate the datatype-definition that the system knows which case-alternative . . , Ei, . . . , ?_emb) where to datatype-definitions to generalize case-analysis ensures of a program del_min of the smallest integer it is natural that finds the smallest element for delrmin the element, inference that deletes one occurrence Example 4.5. Consider list list does not have a smallest ?. If ADATE was given a function min function delete-one ference would be trivial. An important point functions, which means tionality”. The sample 13 = C5,9,45,46,28,3,11,10,30,231. delmin. The initial program is fun delmin it is required that that deletes one occurrence of an element is that ADATE to invent corresponding inputs are Ii = CIOI, 12 = [1,2,3,4,5,6,7,8,9,101 Here is one of many possible Xs = ?. -> nil list : int int in a list. Since an empty to evaluate to in a list or a the in- is given neither of these func- “auxiliary and of from a list, inferences ( 1) The first compound transformation is a single R which gives fun del_min Xs = case Xs of nil 1 Xl::Xsl => case Xsi of nil => ? => nil I X2::Xs2 => ? (2) The second compound transformation has the form ABSTR EMB REQ R. The ABSTR gives fun del_min let Xs = fun g Ys = case Ys of nil I Xl::Xsl => case Xsl of nil in g Xs end => ? => nil I X2::Xs2 => ? range of g is then embedded list to int list int -> list so that -> the int type of g is changed list * int. Application from of ( 1) for embedding of the range and the accompanying case-distribution The int schema gives R. Olsson/Art$cial Intelligence 74 (1995) S-81 69 fun del_min Xs = fun g Ys = let case Ys of nil => ? I XI::Xsl case Xsl of nil => (nil,?_emb) => in case g Xs of V as (Zs,Z> => Zs end I X2::Xs2 => ? Note that the case-distribution changes each of the two occurrences of ? to (? , ?smb) which in turn immediately is replaced by ?. The type of each of the two occurrences of ? naturally changes from int * int. The EMB is then finished by replacing the single occurrence of ?_emb with Xl. Note that this program still has NC = 1 and N, = 0. The REQ yields a program with NC = 2 and NW = 0, namely to int list list fun del_min Xs = fun g Ys = let => case Ys of nil => ? I Xl::Xsl case Xsl of nil => (nil,Xl) case g Xsl of V as case Xl<W of (Ws,W> => true => (Xsl,Xl) I X2::Xs2 => I false => ? in case g Xs of V as (Zs,Z> => Zs end Note that the REQ is facilitated by input Z2. The R then produces the final program by replacing the last ? with (Xl : : Ws , W>. The final program has N, = 3 and N,=O. This inference is unusually short since it only consists of two compound transforma- tions. 4.3. Synthesis of compound transformations Recall that a compound transformation is a sequence tl . . . t#, where each atomic transformation ti is one of the following. l R. Replacement. l REQ. Replacement that does not make the program “worse”. l ABSTR. Abstraction. l CASE-DIST. case-distribution. l EMB. Embedding. 4.11. Compound transformations forms The choice of an atomic transformation ti, i 3 2, depends on the previously chosen transformations tl . . . ti- 1. No transformation except the first may be chosen freely. The 70 R. Olsson /Art@ciul Intelligence 74 (1995) 55-81 dependency all possible compound is specified with so-called coupling transformation forms. rules which are employed to produce Example 4.6. Consider presented where both the REQs and the R are coupled above. The form of this compound the last compound transformation in the inference of sort transformation is ABSTR REQ REQ R to the ABSTR as described below. Assume rule t’ + rule t’ ---f t” means that ti . . ti-1 have been chosen so far and that ti is to be chosen next. A to t” if t’ E {t, , . . . , t,-I }. that t, may be chosen to t” if t’ = t;_l When to tk. transformation may the production of a form, forms. These forms are computed “weak” coupling A “strong” coupling a rule t’ -+ r” or t’ + If a t” is followed by an ! mark in a coupling be coupled which means immediately that t; may be chosen t” is used with t’ equal to some rk, ti is said to be coupled that there are a finite number of possible after system start up and remain unchanged during to I”. No rule may be used more than once during rule, no subsequent r” means Transformation tr is chosen to R, REQ, ABSTR, CASE-DIST to have t# t = R and t; # R for each i < # t. Each transformation required chosen with one of the coupling by the applicability requirement rules below. Each t” in a coupling listed after each rule. in the expression introduced by the REQ. ( 1) REQ + R. The R is applied (2) REQ =+ ABSTR. The ABSTR occurs in the H( El,. (3) ABSTR + R. The R is applied is such that the expression . , En) used by the ABSTR but not entirely side H( VI, . in the right-hand introduced by the REQ in H. , V,) of the the entire execution. or EMB. A form is ti, i 2 2, is rule is constrained introduced by the ABSTR. --3 REQ! or (b) ABSTR + REQ! REQ!. The REQ(s) are applied . ,V,,). (5) ABSTR =+ EMB!. The let-function (6) CASE-DIST =+ ABSTR. The ABSTR introduced by the ABSTR is embedded. is such that the root of H(EI, . . . , E,) was marked by the CASE-DIST. (7) CASE-DIST 3 R. The R is such that the root of the expression Sub, which is replaced by the R, was marked by the CASE-DIST. (8) EMB + R. The R is applied in the right-hand side of the definition of the embedded function. Combining these 8 rules in all possible ways yields 22 forms. For example, ABSTR REQ REQ R is produced by first choosing coupling to be extended. rules (4b) and (3). The rule set above was found empirically the form ti to ABSTR and then applying and may need important focus a compound rules normally they are particularly Since coupling of the program, programs. For example, assume ABSTR form ABSTR REQ REQ R. Each of the four transformations subexpression. Without coupling, are about N. NiHs/ 2 choices with coupling, which means important transformation within a small part large and that an the needs to choose at least one there would be about N4/2 such choices whereas there , V,) contains NRHS subexpressions. Consider for small NRHS/N ratios. The denominator that a program contains N subexpressions that coupling 2 is used since is particularly the first REQ is applied so that H( 6,. for the transformation of very . (4) let-definition (a) ABSTR in H(Vl,. R. Olsson/Artijcial Intelligence 74 (1995) 55-81 71 and the second REQ may be interchanged without changing transformation. The actual number of choices since REQs only are found for a small fraction of the Nws the result of a compound is often much smaller than N - N&/2 subexpressions. 4.3.2. The algorithm that uses the forms to produce programs The algorithm operates with two concepts, work and combinatorial to be produced of a compound transformation. cost. The work is from the current program. The cost For each choice made that the algorithm the cost is multiplied by the number of alternatives the approximate number of programs is a measure of the complexity by the algorithm, has chosen between. Let W,,, be the total work goal. Let NformS be the number of forms of compound The number of programs to be produced using a specific form is to W,,,/Nf,,,. W,,, is thus uniformly distributed on the forms. transformations. chosen Given the current program P, a specific form F and a cost limit C, assume that comp_synt(F : form,C : real,P : program,Emit : program->unit) : unit form F with a cost that makes from P using is an ML function duced sis algorithm makes calls compsynt compsynt(F,27.O,P,Emit), the cost ing F. Thus, 3. It is not possible relationship less (F, 3.0, P, Emit), the call Emit Pi for each program Pi that can be pro- than C. For each form F, the synthe- (F, 9.0, P, Emit), . . . until Wtot/Nforms programs have been produced us- factor of the cost-work [4] with a branching iteratively compsynt to use the same final cost limit for all forms since varies too much from form to form. limit C is deepened 5. The overall search for an appropriate program Using compound transformation forms as described in the previous section, an ex- pansion of a parent program P produces children programs Pt , Pz, . . . , Pw,. The overall search uses a population of programs. The population that consists of a single ?. The population single program that all programs of this partitioning counts are expanded before programs with high case counts. is to maintain diversity and to ensure in a class contain the same number of case-expressions. is partitioned to a is initialized into classes such The purpose that programs with low case Each class contains three programs. Program number found so far according program c case-expressions. so far as judged by pei. ADATE programs with a case count Assume to program evaluation that cbeSti is the case tries to avoid futile expansions that does not exceed i in class number c is the best function pei that contains exactly found count of the best program by only expanding [max ( 1 *zCbest, v 1 *2Cbest3 >l. The Case Count Cbestz is omitted complexity. If the arguments preference may lead to very big programs unfold function calls. since pe2 prefers low call count of the max function above also included through sequences of R-transformations to small syntactic l.2cbeStz, this that 72 R. Olsson/Artificiul Intelligence 74 (I 995) 55-81 The search is run second iteration number A program iteration, 9 i. is eligible iteratively with W,,, = lo4 for the first iteration, 3 . lo4 for the IO4 for the third iteration and so forth, i.e., W,,, = 3’-’ . lo4 for to at least one pei and has not been expanded terminates when no program minimum case count is chosen as the next to be expanded. for expansion only if it is better than all its ancestors according iteration, which is eligible. Out of all eligible programs, a program with thus far during the current 6. Additional implementation details of replacement In order to reduce run times, the implementation The implementation transformations. sions of the “old” expression Sub are reused Subsub one subexpression is to be reused, to represent Subsub. special variable x pression Rawsyrzt, the finished synthesized for x. Assuming substituted chooses Rawsynt according uses additional restrictions on atomic is such that only 0 or 1 subexpres- expression Synt. When algorithm uses a the ex- expression Synt is Rawsynt with Subsub in the synthesized the expression algorithm produces synthesis If the synthesis that no A or E contains any case, the implementation to one of the following expression forms. (1) E. (2) case A of Match, => El (3) case A of Match) => El I ‘. I Match,, => E,, 1 Matchi => case A’ of Match; => Ei I . .. I Match;, => EL, I Match,, => E,, Thus, Raw-synt contains 0, 1 or 2 cases the root or a child of the root of Rawsynt. N/3 Rawsynts are chosen according according to form (3). such that each case occurrence If N expressions either is are to be synthesized, to form (2) and N/3 to form ( l), N/3 according uses the following three types of replacements. that does not reuse any part of Sub, that only reuses Sub itself, The implementation ( 1) a pure replacement (2) an insertion (3) a replacement If N replacements that reuses one subexpression are to be done, 40% are of type ( 1 ), 40% of type (2) and 20% of Sub but not Sub itself. of type (3). Abstraction transformations are restricted to introduce only let-functions of arities 1 or 2. If N abstractions are to be done, N/2 have arity 1 and N/2 have arity 2. Since an inferred program P may have very bad time complexity, the number of calls in P needs to be limited. The current version of ADATE uses a call to functions defined count f( Ii). The upper limit on the total number of calls is thus 200## 1. The fixed 200 limit is somewhat arbitrary and may in the future need to be replaced by an iterative-deepening limit of 200 when computing scheme. R. Olsson/ArtQicial Intelligence 74 (1995) 55-81 13 7. Sample specifications, inferred programs and run times Polynomial simplification. This problem was discussed in Section 2.2. The specification consisted of (1) The type int and the type declaration datatype ‘a list = nil I : : of ‘a * ‘a list. (2) The primitives = : int * int (3) The type of the function to be inferred i.e., (int*int) -> boo1 and + : int * int list -> int. -> (int*int) list. Recall that a polynomial is represented as a list of (coefficient,exponent) pairs. (4) The following sample inputs. ZI = Cl 12 = C(3,2)1 Z3= C(3,2), Z4= C(57,0), (31,0), (5,2), (12,2), (11,211 (71,4), (53,1), (37,3), (67,3), (117,1), (87,4)1 (13,2), (19,4), (5) The output evaluation function shown in Fig. 1. Note that these four sample inputs were chosen to facilitate incremental inference. It is an empty polynomial. Z2 consists of only one term. All terms in 13 have the same degree. Z4 is a “random polynomial”. Thus, It, Z2 and 13 are special cases which it may be advantageous to learn to simplify before trying to simplify general polynomials such as z4. With this specification, ADAm inferred a polynomial simplification program which below is shown exactly as it was printed by the system. fun f (V3_0) = case V3_0 of nil => V3_0 I ((V4996_0 as let (V4997_0, V4998_0)) :: V4999_0) => fun g5011724_0 (V5011725_0) = case V5011725_0 of nil => (V4996_0 :: nil) I ((V5000_0 as case (V5002_0 = V4998_0) of (V5001_0, V5002_0)) :: V5003_0) => true => (((V4997_0 + V5001_0), V4998_0) :: V5003_0) I false (v5000_0 in => :: g5011724_0(v5003_0)) g5011724_0(f (V4999_0) > end This program is equivalent to the one below in which identifiers generated by the system have been replaced by more readable identifiers. 74 R. Olsson/Ariijicial Intelligence 74 (I 995) 55-81 ( Bph, BpZy ) Fig. 2. Two non-intersecting rectangles and their coordinates fun simplify Xs = case Xs of nil => nil I let fun g Ys = (Xlc,Xle)) (Xl as :: Xsl => case Ys of nil => Xi::nil I (Yl as (Ylc,Yie)) :: Ysl => case Yle = Xle of I false => Yi :: g Ysl true => (Xlc+Ylc, Xle) :: Ysl in g(simplify Xsl) end The auxiliary function g, which was invented by the system, is such that the call g Ys tries to merge Xl with a term in Ys intersection. This is one of the few problems is adequate. The rectangles may be viewed as windows occurring Rectangle pair specification graphical user interface. The overlap between a foreground window and a background window needs i.e., made entirely visible. Each rectangle is represented by a pair of points which in turn are pairs of integers specifying the coordinates of the lower left and the upper right corners. Fig. 2 shows the representation of two rectangles A and B. for which an input-output to be updated when into the foreground, the latter is moved in a The specification ( 1) The type int of ‘a. contained and the type declaration datatype ‘a option = none I some (2) The primitive < : int (3) The type of the function -> bool. * int to be inferred. The type is * int) ((int ((int*int) * (int * (int* * int)) int)) * ((int option. * int) * (int * int>> -> (4) A set of 50 sample inputs consisting of each pair of rectangles the first or the second such that the big rectangle and such that the rectangle in Fig. 3 is either other is one of the 25 small rectangles. (5) An output evaluation function that knows the correct output for each sample input. The value returned by a correct rectangle input rectangles do not intersect and some C if their intersection program intersection is none if the two is the rectangle C. R. OlssodArtQicial Intelligence 74 (1995) 55-81 Fig. 3. The set of input rectangles. After renaming, the inferred program is as follows. fun rect_is(I as (A as (Apl as Ap2 as B as (Bpl as Bp2 as (Aplx,Aply), (Ap2x,Ap2y) > , (Bplx,Bply), (Bp2x,Bp2y)))) = case AplxCBp2x of true => (case AplZx<Bplx of true => none I false => case AplyCBp2y of true => (case Ap2yCBply of true => none I false => some((case Bplx<Aplx of true => Aplx I false => Bplx, case AplycBply I false => Aply), of true => Bply (case BpZxKAp2x of true => Bp2x I false => Ap2x, case ApZycBp2y of true => Ap2y I false => Bp2y))) I false => none) I false => none If two input rectangles A and B intersect, the output of this program is some((max(Apix,Bplx) ,max(Aply,Bply)), (min(Ap2x,Bp2x),min(Ap2y,Bp2y))) This algorithm is not obvious even though both the algorithm and the specification are simple. BST deletion. The problem is to delete an element from a binary search tree with integers in the nodes. The specification contained (1) The type int and the type declaration datatype * ‘a bin-tree. ‘a * ‘a bin-tree bt_cons of (2) The primitive < : int * int -> bool. ‘a bin-tree = btnil I 76 R. Olsson/Art$cial Intelligence 74 (I 995) 55-81 (3) (4) The type of the function to be inferred, i.e., bin-tree. Eight sample inputs. Assume that the element X is to be deleted from the BST Xs and that bt_cons(X,Ls is a subtree of Xs. The inputs cover the following four cases. int bin-tree ,Rs) int int -> * Ls Rs btnil btnil bt_cons(_, bt_cons(_, btnil bt_cons(_, -, -> _-) -> btnil _, _> bt_cons (_, _, _) (51 An output evaluation function that uses inorder listing and deletion for lists to check that the correct element is deleted. Note that it is possible to define this function without knowing any good way to delete an element from a BST. The output evaluation function oe uses the following auxiliary definitions. fun inorder bt_nil = nil I inorder(bt_cons(RoXs,LeXs,RiXs)) = inorder LeXs Q RoXs::inorder RiXs fun depth bt_nil = 0 I depth(bt_cons(_,LeXs,RiXs)) = l+max(depth LeXs,depth RiXs) fun delete_one(_,nil) = nil I delete_one(X,Y::Ys) = if X=Y then Ys else Y::delete_one(X,Ys) Given input (X,Xs> and output Ys, oe checks that inorder Ys = delete_one(X,inorder depth Ys <= depth Xs. Xs) andalso If the depth requirement depth Ys <= depth Xs is omitted, ADATE infers a BST deletion program that produces very unbalanced outputs. With the depth requirement, the following program was inferred. true => bt_cons(RoXs,LeXs,bst_del(X,RiXs)) true => bt_cons(RoXs,bst_del(X,LeXs),RiXs) fun bst_del(I as (X,Xs>> = => Xs => case Xs of bt_nil I bt_cons(RoXs,LeXs,RiXs) case RoXs<X of I false case X<RoXs of I false let => => fun g Ys = case Ys of bt_nil I bt_cons(RoYs,LeYs,RiYs) case LeYs of bt_nil I bt_cons(RoLeYs,LeLeYs,RiLeYs) => LeXs => => bt_cons(RoYs,LeXs,bst_del(RoYs,RiXs)) => g LeYs R. OlssodArtificial Intelligence 74 (1995) 55-81 II in g RiXs end The most innovative part of this program is the let-expression, which determines what to do when the element to be deleted has been found. BST insertion. This problem is to insert an integer into a binary search tree. In addition for binary trees, the specification contained the relation < on to the datatype-definition integers. No auxiliary function was needed. List reversal. The specification contained the datatype-definition function, that inserts an element last in a list, was inferred. for lists. An auxiliary intersection. The problem is to compute the intersection of two lists of integers. Lit The specification contained the datatype-definition for lists and the relation = on integers. An auxiliary function, that checks if an element occurs in a list, was inferred. List delete min. The problem is to delete exactly one occurrence of the minimum element in a list. The specification contained the datatype-definition for lists and the relation < on integers. The sample inputs and the inferred program were presented in Section 4.2. generation. The problem is to compute all permutations of a list of Permutation integers. The specification contained the datatype-definition for lists and the function Q that concatenates two lists. The output evaluation function measured the number of different permutations occurring in the output and checked that the output only consisted of permutations. The inferred program contains two auxiliary functions. for lists and the re- List sorting. The specification contained the datatype-definition lation < on integers. The sample inputs and the inferred program were presented in Section 4.2. List splitting. The specification contained the datatype-definition evaluation function was described in Section 2.1. for lists. The output The run times shown in Table 2 were obtained using the Standard ML of New Jersey compiler and a SUN SparcStation 10. Note that the table shows the times required to find correct programs. In general, there is no guarantee that a correct program also is small and efficient. 8. Related work The inference of LISP programs from input-output pairs is surveyed by D.R. Smith insight [ 81. Smith writes that all the methods in his survey stem from Summer’s [lo] 78 R. Olsson /Artijicial Intelligence 74 (I 995) 55-81 Table 2 Run times Problem Run time in days:hours simplification intersection Polynomial Rectangle BST deletion BST insertion List reversal List intersection List delete min Permutation generation List sorting List splitting 0:7 I:18 7:12 3:s 0:lO 6:3 8:8 9:s I:12 0:7 that a semi-trace of a computation pairs. Summer’s THESYS system then uses the semi-trace LISP program. can be constructed from well chosen to construct input-output the corresponding Example 8.1. Assume ( [I, 2,3] ,3). Standard ML notation. that If the input input-output , I>, the is Xs;, each output Yi can be described pairs are ([II ( [I,21 as follows using ,2) and YI = hd Xsl, Y:! = hd(tl Xs?), Y3 = hd(tl(tl Xs,>>. THESYS notes that Y; equals Y;_l with tl XSi substituted for Xsi-1. This recurrence relation is then employed to infer a function that finds the last element in a list. The inference method used by THESYS is highly specialized and requires that the structure of the input-output pairs directly corresponds to a specific program. to ILP specifications. A particularly Unfortunately, this also holds for inductive using so-called four problems with input-output also apply invention of new predicates, which is introduced When executing functional program. i.e., replacing corresponding by an abstraction However, the abstraction work, including predicate an instantiation instance of the left-hand Intuitively, logic programming (ILP) pair specifications, which were presented development interesting is reviewed by Irene Stahl systems. The in Section 2.1, in ILP is the [ 91. A new predicate resolution. which is based on inverse inverse resolution corresponds of the right-hand side. As described step corresponds to a function call in a function call” to “inverse side of a function definition with the in Section 4.2.2, this is done invention. of any previous independently to predicate transformation was developed invention. intra-construction, a logic program, a resolution transformation, which is therefore analogous One major difference between abstraction and predicate invention ILP systems need to be made to determine Many ask the user usefulness to confirm that is employed the initial definition of the invented that do predicate invention, e.g. CIGOL the usefulness of an invented predicate. Another is the size of the resulting program. Irene Stahl concludes is the choices that function or predicate. [ 121, criteria of [ 71 and SIERES R. OlssodArtijicial Intelligence 74 (1995) 55-81 19 that “Additionally, the experimental evaluation of systems performing predicate invention in ILP is almost lacking”. The specifications used by GA systems [5] are similar to ADATE specifications. The main program transformation is crossover, i.e., random exchange of subexpressions between two programs. This is a primitive program transformation indeed. Crossover is only effective if the schema theorem [3] is applicable. In general, this means that if a large expression E is to be inferred, it should primarily be composed from first- or higher-order subexpressions El, E2, . . . , E,, such that the fitness advantage of each Ei can be measured independently of each Ej with j # i. Unfortunately, practically all recursive programs consist of coupled Ei’S. Example 8.2. Consider the following ML list concatenation program, which is written using if and selectors instead of case in order to make it resemble Koza’s LISP style [51. fun O(Xs,Ys) = if null Xs then Ys else hd Xs::Q(tl Xs,Ys) The right-hand side can be written as ElEz with & = fn As => if null Xs then Ys else As E2= hd Xs::Q(tl Xs,Ys). The fitness advantage of E2 can obviously not be measured unless the base case of the recursion is properly handled. Thus, E2 has a positive effect on fitness only if it appears in conjunction with El or some equivalent expression. This so-called “subexpression coupling problem” means that crossover is an extremely inefficient program transformation when recursive programs are to be inferred. Therefore, it is quite natural that Koza’s book does not list any inferred programs that contain explicit recursive calls. The inability to infer recursive programs is most unfortunate since recursion is of fundamental importance in LISP and functional programming. In general, it seems to be equally difficult for Koza’s system to produce iterative programs. This means that the current form of the system is unlikely to ever become an effective tool for general purpose programming. 9. Conclusions and future work The main advantages of ADATE are ( 1) The abstraction transformation can invent auxiliary functions, which the user might be unaware of. (2) The embedding transformation can change the type of a function in order to make the function more general. (3) Specifications are loose. 80 R. Olsson/Artijiciul Intelligence 74 (1995) 55-81 to automatically invent nontrivial (4) The ability The main disadvantage reviewed programs much more knowledge run is the long in Section 8 are much from the users. algorithms. times. The systems faster. However, for induction they do need of logic to acquire ADATE of thorough through a combination finds “good” programs that is optimal according if ADATE always guaranteed of syntactic complexity. There is no guarantee to some program evaluation testing and at- that ADATE will function poi. For syntactic run times would in general grow exponentially with complexity. The ability therefore have little practical value. Fortunately, many small and fast, but not to the one for many in can be found for tempted minimization find a program example, complexity, to give such a guarantee would users are satisfied with a program necessarily NP-hard problems, where a solution within say 1% of the optimum polynomial finding an optimal solution the smallest nor the fastest. This situation to find a correct program of minimum the worst case time complexity that is correct and reasonably time with high probability, even though is analogous is exponential. are to arbitrary so that higher-order insertions improvements embedding abstraction Some possible ( 1) to generalize to generalize (2) to add more heuristics (3) pound to significantly mance massively parallel computer. transformations; improve (4) into type expressions; functions can be invented; to the algorithms that synthesize expressions and com- run times by implementing ADATE on a high perfor- future work is to that All programs inferred so far are rather small. The most important the inference of large programs. Recall in node Ni in an expression that mi is the number of symbols tree. A potential problem with inference-in- is that mi grows with the number of ancestor let- and case-nodes, is needed to determine introduce new symbols. More experimentation rules of Standard ML suffice techniques the are required. A related question of functions on-the-fly toolbox or on the construction to keep mi small or if additional is the use of library i.e., of specialized for inference-in-the-large if the system should tools as needed. is likely to be combinatorially a system the use of such tools seems since if sym- func- rely on In compar- to rely expen- study may occur the-large such nodes the scoping bol selection tions versus a general ison with human programmers, less on general sive. tools since invention Acknowledgements I am indebted to Olaf Owe at the University comments on a draft of this paper. The most important programming in the paper comes never have been done without teaching be. constructive influence on the work presented community. This work would the foresight shown by Ake Wikstrijm of Chalmers when [ I1 ] to freshmen, one of which I had the fortune to the functional for providing programming functional of Oslo from R. Olsson/Artifcial Intelligence 74 (1995) 55-81 81 References [ 1 ] A.W. Biermann and R. Krishnaswamy, Constructing programs from example computations, IEEE Trans. Sojiw. Eng. 2 (1976) 141-153. [ 2] A.W. Biermann, The inference of regular LlSP programs from examples, IEEE Trans. Syst. Man Cybernet. 8 (1978) 585-600. [ 3 1 J.H. Holland, Adaptation in Natural and Artificial Systems (University of Michigan Press, Ann Arbor, Ml, 1976). [4] R.E. Korf, Depth-first iterative-deepening: an optimal admissible tree search, Artij Infell. 27 ( 1985) 97-109. [5] J.R. Koza, Genetic Programming (MIT Press, Cambridge, MA, 1992). [6] S.H. Muggleton, Inductive logic programming, in: S. Muggleton, ed., Inductive Logic Programming (Academic Press, London, 1992) 4-21. [ 71 S.H. Muggleton and W. Buntine, Machine invention of first-order predicates by inverting resolution, in: Proceedings Fifh International Conference on Machine Learning, Ann Arbor, MI ( 1988) 339-352. [ 8 1 D.R. Smith, A survey of the synthesis of LISP programs from examples, in: A.W. Biermann, G. Guiho and Y. Kodratoff, eds., Aufomatic Program Construction Techniques (Macmillan, New York, 1982) 307-324. ]9] I. Stahl, Predicate invention in ILP-an overview, in: Proceedings European Conference on Machine Learning (Springer Verlag, Berlin, 1993) 313-322. [lo] PD. Summers, A methodology for LISP program construction from examples, J. ACM 24 (1977) 161-175. 1111 A. Wikstram, Functional Programming Using Standard ML (Prentice Hall, Englewood Cliffs, NJ, 1987). [ 121 R. Wirth and P. D’Rorke, Constraints for predicate invention, in: S. Muggleton, ed., Inductive Logic Programming (Academic Press, London, 1992) 299-3 18. 