Artificial Intelligence 224 (2015) 1–27Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintAn SMT-based approach to weak controllability for disjunctive temporal problems with uncertainty ✩Alessandro Cimatti a, Andrea Micheli a,b,∗a Fondazione Bruno Kessler, Istituto per la Ricerca Scientifica e Tecnologica, Via Sommarive 18, 38123 Povo, Trento, Italyb Doctoral School in Information and Communication Technology, University of Trento, Via Sommarive 9, 38123 Povo, Trento, Italy, Marco Roveri aa r t i c l e i n f oa b s t r a c tArticle history:Received 11 November 2013Received in revised form 27 February 2015Accepted 5 March 2015Available online 12 March 2015Keywords:Weak controllabilityTemporal problemsSatisfiability modulo theoryStrategy synthesisThe framework of temporal problems with uncertainty (TPU) is useful to express temporal constraints over a set of activities subject to uncertain (and uncontrollable) duration. In this work, we focus on the most general class of TPU, namely disjunctive TPU (DTPU), and consider the case of weak controllability, that allows one to model problems arising in practical scenarios (e.g. on-line scheduling).We first tackle the decision problem, i.e. whether there exists a schedule of the activities that, depending on the uncertainty, satisfies all the constraints. We propose a logical approach, based on the reduction to a problem of Satisfiability Modulo Theories (SMT), in the theory of Linear Real Arithmetic with Quantifiers. This results in the first implemented solver for weak controllability of DTPUs.Then, we tackle the problem of synthesizing control strategies for scheduling the activities. We focus on strategies that are amenable for efficient execution. We prove that linear strategies are not always sufficient, even in the sub-case of simple TPU (STPU), while piecewise-linear strategies, that are multiple conditionally-applied linear strategies, are always sufficient. We present several algorithms for the synthesis of linear and piecewise-linear strategies, in case of STPU and of DTPU.All the algorithms are implemented on top of SMT solvers. We provide experimental evidence of the scalability of the proposed techniques, with dramatic speed-ups in strategy execution compared to on-line reasoning.© 2015 Elsevier B.V. All rights reserved.1. IntroductionMany practical settings, such as planning and scheduling, require the solution of sets of constraints over time points, that typically represent the time at which activities begin and end. For example, constraints may represent a bound on the overall time span, or lower/upper bounds on the distance between two activities.The Temporal Problem (TP) [18,36] is a well studied formalism to model such temporal constraints. In the basic form of TP, also referred to as TP without uncertainty, the durations of activities are assumed to be controllable by the executor. This means that the executor assumes to have the possibility of choosing any duration that it may want. A solution is an assignment to all the time points (i.e., the beginning time and the end time of the activities), that satisfies the constraints. ✩This paper is an extended version of [10] published at AAAI 2012, Toronto, Canada.* Corresponding author.E-mail addresses: cimatti@fbk.eu (A. Cimatti), amicheli@fbk.eu (A. Micheli), roveri@fbk.eu (M. Roveri).http://dx.doi.org/10.1016/j.artint.2015.03.0020004-3702/© 2015 Elsevier B.V. All rights reserved.2A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Depending on the structure of the constraints, TPs range from simple temporal problems (STP) [18], to temporal constraint satisfaction problems (TCSP) [18], to disjunctive temporal problems (DTP) [36].In practice, activities may also have uncertain (and uncontrollable) durations. For example, it may be impossible to know precisely the time taken by a drilling or locomotion procedure; yet, the production of an overall schedule must be able to take this uncertainty into account. The formal framework of TPs has been extended with uncertainty (TPU), thus obtaining STPU, TCSPU, and DTPU [38,32,37]. Because of uncertainty, TPUs are much more complicated than TPs without uncertainty. In fact, they can be thought in terms of games, where the scheduler/executor must play against an “adversarial” envi-ronment. Intuitively, the variables representing the time points are separated into controllable ones (that are existentially quantified), and uncontrollable ones (universally quantified).Within this setting, several degrees of solution have been identified for TPUs [38]. In strong controllability, a solution is a fixed, unconditioned assignment to each controllable time point, that will satisfy the constraints regardless of the uncontrollable duration of the activities. This corresponds to devising a time-triggered program, where activities are started at fixed times.In dynamic controllability, a solution is a strategy where the values of controllable variables may depend on the values of the uncontrollable ones, as long as they can be observed, i.e. they occur in the past. The corresponding execution must deal with branching, and may interleave the start of activities with the observation of the uncontrollable (but observable) “end of activity” events.In this paper we focus on weak controllability, that is concerned with the existence of a strategy that associates values to the controllable starting points of each activity, as a function of the uncontrollable durations. The values for the uncon-trollable durations are not known at the moment of solving the problem; however, the executor is given the actual value of such durations just before the execution starts.There are several reasons for studying weak controllability. From the temporal problems perspective, weak controllabil-ity is a conceptually interesting dual of the strong controllability problem. In addition, deciding whether a given TPU is weakly controllable may serve as a pre-check for more complex problems such as dynamic controllability. In fact, weak controllability is a necessary condition for dynamic controllability [38].From the practical standpoint, weak controllability allows for the modeling of a setting where a number of tasks is to be repeatedly executed, but with modalities that depend on some environmental parameters that become available just prior to execution. For example, an automated production line may be required to perform a set of activities, whose duration functionally depends on the measured size of the objects to be manipulated. The duration of the activities is unknown a priori, except for an upper and lower bound, but it becomes precise once the actual objects materialize. Similarly, in a multi-core processor, the power management may dynamically control the actual clock speeds, thus affecting the duration of jobs. An on-line scheduler may be required to decide the appropriate allocation based on information that may be made available by the power management unit. Another example of application is given in the setting of remote systems (such as space exploration rovers or satellites), where the degradation due to use causes many activities to change duration over time. For example, the movement speed of many components may decrease with the age of the system. These domains share the fact that the tasks may be repeated multiple times, on platforms of limited capacity, and in conditions that can be estimated prior to execution. As such, they can be encoded as weak controllability problems.In this paper, we tackle weak controllability for DTPUs (i.e. in its most general form), making the following contributions. First, we propose a general decision procedure for the problem of weak controllability for DTPUs. Our approach makes use of the framework of Satisfiability Modulo Theory (SMT) [4], a formal framework that allows for the analysis of problems in decidable fragments of First Order Logic. The decision procedure is based on a reduction to an SMT problem for the theory of Quantified Linear Real Arithmetic (LRA). The encoding can be thought as working by refutation: we state the existence of an assignment to uncontrollable time points that cannot be countered by any controllable assignment. This means that the SMT problem is satisfiable if and only if the TPU is not weakly controllable. The problem can thus be directly provided to an efficient SMT solver. This approach accounts for the first implemented decision procedure for weak controllability of DTPUs.Then, we investigate the problem of on-line strategy execution, i.e. given a weakly controllable DTPU, how to repeatedly produce a suitable schedule for the controllable time points as a function of a valuation to the uncontrollable ones. We propose an approach, referred to as implicit strategy execution, based on the run-time execution of a solver for TP without uncertainty: any valuation to the uncontrollable durations removes the uncertainty from the problem, and thus transforms the TPU at hand into a TP. The solver is then invoked to solve the consistency problem yielding an assignment to the controllable time points. Unfortunately, this solution imposes strong requirements on the run-time: most notably, the control platform must support the execution of a solver; in addition, at each iteration it is required to solve an NP-hard problem, i.e. a DTP (without uncertainty).This motivates the investigation of efficient run-time execution for weakly controllable TPUs. We analyze the spectrum of explicit strategies, expressed in a form that does not require reasoning, and can thus be directly evaluated. We consider linear strategies, that are strategies in which the values for the controllable time points are a linear function of the uncontrollable ones; and piecewise-linear strategies, that are combinations of different linear strategies, each associated with an activation condition defined over the uncontrollable time points. Linear strategies turn out not to be expressive enough in general: we prove that even for the STPU problem class, a weakly controllable instance is not guaranteed to have a linear strategy. We A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–273also prove that piecewise-linear strategies are sufficiently expressive: a piecewise-linear strategy is guaranteed to exist for every weakly controllable DTPU.Finally, we address the synthesis problem: given a weakly controllable temporal problem, we algorithmically synthesize a function from an assignment to uncontrollable time points to an assignment to the controllable ones. We propose a number of algorithms for the synthesis of a strategy. We start by considering linear strategies, developing two algorithms to produce linear strategies for the STPU and DTPU cases. Then, we generalize to the case of piecewise-linear strategies, and we propose several algorithms for the STPU and DTPU cases.All the proposed algorithms have been implemented in a tool for solving temporal problems under uncertainty. The tool is developed on top of, and fully leverages, state-of-the-art SMT solvers [17,7]. To the best of our knowledge, this is the first implementation for weak controllability and strategy extraction. We carried out an extensive experimental evaluation on a comprehensive set of benchmarks. Our implementation, available on-line, demonstrates high scalability, and is able to automatically extract strategies of significant size. The experimental evaluation highlights a dramatic speed-up in the execution of the synthesized explicit strategies.Structure of the paper In Section 2, we provide some background and we define the addressed problem. In Section 3 we for-mally introduce TPUs and weak controllability. In Section 4 we describe our SMT-based decision procedure. In Section 5 we formalize the concept of weak strategy and we prove that linear strategies are not always present for a weakly controllable problem, but piecewise-linear strategies are. In Section 6 we analyze the problem of strategy synthesis for all the different problem classes and strategy types. In Section 7 we present an experimental evaluation of the approach. In Section 8 we summarize the most relevant work. Finally, in Section 9 we draw some conclusions and discuss future work.2. Background2.1. Technical preliminariesOur setting is standard First Order Logic [24]. The first-order signature is composed of constants, variables, function symbols, Boolean variables, and predicate symbols. A term is either a constant, a variable, or the application of a function symbol of arity n to n terms. A theory constraint (also called a theory atom) is the application of a predicate symbol of arity n to n terms. An atom is either a theory constraint or a Boolean variable. A literal is either an atom or its negation. A clause is a finite disjunction of literals. A formula is either true ((cid:3)), false (⊥), a Boolean variable, a theory constraint, the application of a propositional connective (¬, ∧, ∨, →, ↔) of arity n to n formulae, or the application of a quantifier (∀, ∃) to an individual variable and a formula. If t1 and t2 are terms, and φ is a formula, an if-then-else (ITE) term is ite(φ, t1, t2). The semantics of an ITE term is the usual if-then-else semantics from programming languages. For example, the term ite(x > y, x, y) where x and y are numeric variables, corresponds to the maximum between x and y. An ITE term ite(φ, t1, t2) occurring in a formula ψ can be rewritten by substituting each occurrence with a fresh variable v and by conjoining (¬φ ∨ (v = t1)) ∧ (φ ∨ (v = t2)). See [23] for a thorough discussion. We use x, y, v, . . . for variables, and (cid:11)x, (cid:11)y, (cid:11)v, . . .for vectors of individual or Boolean variables. Terms and formulae are referred to as expressions. Formulae are denoted with φ, ψ, . . . . Let (cid:11)x be a vector of variables, we indicate the i-th variable in the vector with xi . We write φ(x) to highlight the fact that x is free in φ, and φ((cid:11)x) to highlight the fact that the free variables of φ are variables in (cid:11)x. We indicate with Q (cid:11)x.φ((cid:11)x) the formula Q x1.Q x2. . . . Q xn.φ(x1, . . . , xn), where Q ∈ {∀, ∃}.Substitution is defined in the standard way. We write φ[s/v] for the substitution of every occurrence of the variable vin φ with the term s. Let (cid:11)v be a vector of variables and (cid:11)s be a vector of terms, we write φ[(cid:11)s/(cid:11)v] for the parallel substitution of every occurrence of v i in φ with si . With a slight abuse of notation, if φ((cid:11)x, (cid:11)y) is a formula, we write φ(ψ((cid:11)t ), (cid:11)y) as a shorthand for φ[ψ((cid:11)t )/(cid:11)x].We use the standard semantic notion of interpretation and satisfiability [24]. We call model μ of a formula φ((cid:11)x) a pair composed of an assignment that maps each variable xi into an element of its domain and an interpretation for the non-logical symbols that satisfies the formula. A formula φ((cid:11)x) is satisfiable if and only if it has a model. Thus, the problem of checking the satisfiability of a formula consists in determining whether there exists a model for that formula.2.2. Satisfiability modulo theoryIn propositional logic, the satisfiability problem is approached with enhancements of the DPLL algorithm [15]: the formula is converted into an equi-satisfiable one in Conjunctive Normal Form (CNF); then, a satisfying assignment is in-crementally built, until either all the clauses are satisfied, or a conflict is found, in which case back-jumping takes place (i.e. certain assignments are undone). Keys to efficiency are heuristics for the variable selection, and learning of conflicts [30].Given a first-order formula ψ with non-logical symbols interpreted in a decidable background theory T, Satisfiability Modulo Theory (SMT) [4] is the problem of deciding whether there exists a satisfying assignment to the free variables in ψ . For example, consider the formula (x ≤ y) ∧ ((x + 3 = z) ∨ (z ≥ y)) in the theory of real arithmetic. The theory of real arithmetic interprets the constant symbol “3” as the real number 3 and the operators +, =, <, >, ≤, ≥ as the usual functions and relations. The formula is satisfiable and a satisfying assignment is {x (cid:15)→ 5, y (cid:15)→ 6, z (cid:15)→ 8}.4A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27In this work we primarily concentrate on the theory of linear arithmetic over the real numbers (LRA). A formula in LRA is an arbitrary Boolean combination, a universal (∀) or an existential (∃) quantification, of atoms in the form (cid:2)i ai xi (cid:16)(cid:17) c where (cid:16)(cid:17) ∈ {>, <, ≤, ≥, (cid:18)=, =}, every xi is a real variable and every ai and c is a real constant. Difference logic (RDL) is the subset of LRA such that atoms have the form xi − x j (cid:16)(cid:17) c. If a formula in RDL is satisfiable, then there exists infinitely many models for such formula [13]. This is because in RDL we can only express “distances” between variables, thus the absolute value of at least one variable can always be chosen. We denote with QF _LRA and QF _RDLthe quantifier-free fragments of LRA and RDL, respectively. This means that a formula φ is in QF _LRA (resp. in QF _RDL) if it is in LRA (resp. in RDL) and no first-order quantifier appears in φ.A conjunction of atoms in LRA over n variables represents a (non-necessarily closed) convex polyhedron in n dimen-sions: each point of the polyhedron is a model of the formula. Similarly, an LRA formula represents the union of finitely many non-necessarily closed convex polyhedra. If φ((cid:11)x) and ψ((cid:11)x) are LRA formulae, the formula φ((cid:11)x) → ψ((cid:11)x) geometri-cally corresponds to the constraint φ((cid:11)x) ⊆ ψ((cid:11)x). Similarly, the conjunction of two formulae corresponds to intersection, the disjunction to union and the negation to the complement. A model μ of an LRA formula φ (μ |(cid:20)LRA φ) corresponds to a geometric point (cid:11)μ (that is the vector of values assigned by μ to each dimension) that belongs to the region represented by φ (that is (cid:11)μ ∈ φ).Given an LRA formula φ((cid:11)x) we denote with Atoms(φ((cid:11)x)) the set of its atoms (nal coefficients). Given an atom a((cid:11)x) ∈ Atoms(φ((cid:11)x)) (a((cid:11)x) .=be the conjunction of all the equalities in a given formula, namely Equalities(φ((cid:11)x)) .=(cid:2)xi ∈(cid:11)x ci xi (cid:16)(cid:17) b1), let Eq(a((cid:11)x)) =(cid:3)xi ∈(cid:11)x ci xi (cid:16)(cid:17) b, with ci and b being ratio-xi ∈(cid:11)x ci xi = b. Let Equalities(φ((cid:11)x))ai ((cid:11)x)∈Atoms(φ((cid:11)x)) Eq(ai((cid:11)x)) if ai((cid:11)x) =xi ∈(cid:11)x ci xi (cid:16)(cid:17) b with (cid:16)(cid:17) restricted to {≤, ≥, =}.We write x − y ∈ [a, b] where x and y are variables and a and b are constants, meaning the formula (x − y) ≥ a ∧(x − y) ≤ b. If a is −∞ then the first conjunct is omitted and similarly, if b is ∞ then the second conjunct is omitted. In presence of constant bounds, we write the intervals with the usual open-closed notation: [a, b], [a, ∞) or (−∞, b] for some a, b ∈ R.A second theory of interest for this work is the theory of Equality and Uninterpreted Functions (EU F ), in which variables range over an unspecified infinite domain and function symbols are introduced. The only interpreted symbol in the theory is =, the equality predicate. There is no restriction on the interpretation of function symbols: the only property assumed for is ∀x.∀ y.(x = y) → ( f (x) = f ( y)). In addition, we can have formulae defined over the combination of two or a function fmore theories. For example, an atom like x = f ( y + z) + w combines the + operator of LRA with function symbols of EU F , therefore this formula is expressed in the combination of EU F and LRA (indicated EU F ∪ LRA). Different techniques can be adopted to address the theory combination problem (e.g. Nelson–Oppen [31], Delayed Theory Combination [5], Model-based Theory Combination [16]).(cid:2)(cid:2)(cid:2)An SMT solver [4] is a decision procedure which solves the satisfiability problem for a formula expressed in a decidable subset of First Order Logic. The most efficient implementations of SMT solvers use the so-called “lazy approach” [34]. In order to decide a formula φ expressed in the theory T, a SAT solver is tightly integrated with a T-solver, that is used to decide conjunctions of constraints in the theory T. The role of the SAT solver is to enumerate the truth assignments to the Boolean abstraction of the first-order formula. The Boolean abstraction has the same Boolean structure of the first-order formula, but “replaces” the predicates which contain T information with fresh Boolean variables. The Boolean abstraction of (x ≤ y) ∧ ((x + 3 = z) ∨ (z ≥ y)) is P ∧ (Q ∨ R), where P , Q , R are fresh Boolean variables. The T-solver is invoked when the SAT solver finds a satisfying assignment for the Boolean abstraction: the satisfying assignment to Boolean abstraction maps directly to a conjunction of T atoms, which the T-solver can handle. If the conjunction is satisfiable also the original formula is satisfiable. Otherwise the T-solver returns a conflict set which identifies a reason for the unsatisfiability. Then, the negation of the conflict set is learned by the SAT solver in order to prune the search. Examples of solvers based on the “lazy approach” are MathSAT5 [7], Z3 [17], Yices [19] and OpenSMT [6].In order to deal with quantifiers in LRA, many techniques have been developed and implemented in SMT solvers. Some solvers (e.g. Z3) natively support quantifiers. However, many others (e.g. MathSAT5) cannot deal with them. For some theories of interest, it is possible to apply algorithms that remove quantifiers from any given formula in the theory. A theory T is said to admit quantifier elimination, if for every quantified formula φ in T, there exists a quantifier-free formula φ(cid:23)that is logically equivalent to φ. It was proved that LRA admits quantifier elimination, and there are techniques (e.g. Fourier–Motzkin [33], Loos–Weispfenning [25,26]) that transform any LRA formula containing quantifiers into an equivalent QF _LRA formula. These techniques, at a cost that is doubly exponential in time and space in the original formula size [33,26,25], enable for the use of solvers with no native support for quantifiers.3. Temporal problems with uncertaintyThe formalism of TP is used to model temporal constraints over time-valued variables representing time points. This formalism is often used to characterize scheduling problems, where activities must be ordered in time according to some specified constraints. The variables in a TP typically represent the beginning time and the end time of activities. For example, given two activities A1 and A2, it is possible to state that the distance between the beginning of A1 and the end of A2 is less 1 We use the symbol .= to indicate a definition. We need this symbol to distinguish between the definition from the equality as a logical predicate.A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–275Fig. 1. (a) The running example of a weakly controllable STPU: nodes are time points, double-circled nodes are uncontrollable time points; contingent constraints are depicted as dashed arrows while free constraints are solid. (b) The constraint definitions for the running example.than or equal to 2. The TP formalism is expressive enough to model Allen’s interval algebra [1], and also metric constraints in the form of arbitrary Boolean combination of atoms (x − y) ∈ [l, u], where x, y are time points and l, u ∈ R ∪ {+∞, −∞} [18].Two families of TPs have been presented in literature over the years: TP without Uncertainty, and TP with Uncertainty (TPU). In the first, simply called TP, all the time points (i.e. both beginning and end points) can be decided by the sched-uler/executor [18,36]. The case of TPU represents the more complex situation where the executor is only able to decide the beginning time of activities, whereas the end of activities is to be decided by an adversarial environment [38]. In this work we focus on TPUs.Definition 1. A TPU is a tuple ( Xc, Xu, Cc, C f ), where Xc(n ≥ m) is the set of uncontrollable time points, Ccis the set of free constraints.(cid:4)(cid:4).=cciE ij=1(ei − bi) ∈ [lci, j, uci, j].=c f iD ij=1(v i, j − w i, j) ∈ [lfi, j, ufi, j].= {b1, . . . , bn} is the set of controllable time points, Xu.= {cc1, . . . , ccm} is the set of contingent constraints, and C f.= {e1, . . . , em}.= {c f 1, . . . , c fh}ffsuch that: li, jconstraint, E i is the number of disjuncts for the i-th contingent constraint, v i, j , w i, j ∈ Xc ∪ Xu and v i, j (cid:18)= w i, j .∈ R ∪ {+∞, −∞}, lcis the number of disjuncts for the i-th free i, j, uci, ji, j , lci, ji, j , D ii, j, u≤ uc≤ ufi, j, lf∈ R+Variables in Xc represent time decisions that can be controlled by the executor. Variables in Xu represent time decisions that are under the control of the environment (and are thus uncontrollable from the point of view of the executor). We use the letters b and e as mnemonics for the beginning and end of activities, respectively.2The constraints are separated in two sets: free constraints C f are constraints that the executor is required to fulfill; contingent constraints Cc are the assumptions that the environment will fulfill. Intuitively, free constraints are the require-ments of the problem, while contingent constraints are the assumptions under which the problem must be solved. Notice that, differently from free constraints, each contingent constraint is required to be expressed using exactly two variables (bi and ei ) sharing the same index i. As in [38], we consider only contingent constraints involving exactly one controllable time point and one uncontrollable time point. Thus, each uncontrollable time point ei is linked by exactly one contingent constraint to a controllable time point bi and |Cc| = | Xu|. In fact, we have a number of controllable time points that is at least as big as the number of uncontrollable ones (hence n ≥ m) because we allow for controllable time points that are not linked to an uncontrollable via a contingent constraint. This formulation is customary in the literature, and assumes a com-plete independence between contingent constraints: the framework can express disjunctions in the contingent constraints but assumes the independence between different uncontrollable activities.An example of TPU is depicted in Fig. 1. The example is composed of two activities A1 and A2. A1 starts at time point b1and ends in e1; similarly, A2 starts at b2 and ends in e2. The two activities have uncontrollable duration: A1 has duration between 0 and 3 time units, while A2 lasts for at least 1 and at most 2 time units. We require b1 to be scheduled before b2 (b2 − b1 ∈ [0, +∞)), b2 before e1 (e1 − b2 ∈ [0, +∞)), e2 to happen at most 1 time unit before e1 (e1 − e2 ∈ (−∞, 1]) and e2 at most 2 time units after b1 (e2 − b1 ∈ (−∞, 2]).Depending on the form of the constraints in Cc and C f , we consider three classes of TPUs. Definition 1 captures the most general class, referred to in the literature definition as Disjunctive Temporal Problem with Uncertainty (DTPU) [32,37]. If each disjunction is restricted to refer to a single pair of variables, the resulting problem is a Temporal Constraint Satisfaction Problem with Uncertainty (TCSPU) [32,37]. If disjunctions are disallowed, we obtain a Simple Temporal Problem with Uncertainty(STPU) [38,29,28,21,22]. The problem in Fig. 1 is an STPU.Following the classification of Peintner et al. [32], we also say that a problem is simple-natured if the contingent con-straints have no disjunctions (E i = 1 for each i).2 The TPU formalism is more general, as it allows for the representation of fully controllable activities and of controllable time points not belonging to any activity. The bi -ei notation gives a useful intuition for uncontrollable activities, but it is possible to have the beginning and end time points of a controllable activity marked as bi and b j , because they both belong to Xc .6A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27We define an assignment to the time points as a total function from time points to real values. Given a TP without uncertainty, checking consistency corresponds to deciding the existence of an assignment that fulfills all the constraints of the problem. We call such an assignment a consistent schedule, and we say that the TP is consistent.Given a TPU, values for controllable time points can be decided, namely they can be scheduled in time by an executor, while an uncontrollable time point ei just happens after its activation time point bi has been scheduled. The only assump-tion is that the i-th contingent constraint will be satisfied by the values of bi and ei . Given this intuitive meaning, we rephrased the concept of situation for a TPU [38] for the DTPU problem class.Definition 2. Let PS i[lci, j, uci, jE ij=1.=(cid:5).= ( Xc, Xu, Cc, C f ) be a TPU where | Xu| = m. The space of situations for P is (cid:4)P]. A situation is an element ω of (cid:4)P ..= S1 × · · · × Sm, where Intuitively, a situation is a choice of the actual duration for each activity with uncontrollable duration. For example, the activity representation of the running example in Fig. 2, represents a possible situation in which yi is the duration of Ai .For a TPU, three different problems can be addressed [38]: strong controllability, dynamic controllability and weak con-trollability. In all these problems, the executor is required to find a winning strategy, i.e. an assignment to the controllable time points that “works” in any situation. More specifically, the assignment to the controllable time points must fulfill all the free constraints in any situation for the given problem. The difference depends on the extent to which the executor can use (or, observe) the situation to decide the assignments to the controllable time points.In strong controllability, the executor is “blind”, i.e. it cannot observe the situation at all. Therefore, the solution to a strong controllability problem is a fixed schedule, that assigns a time value to each controllable time point. This schedule must fulfill all the free constraints in any situation. The example problem in Fig. 1(a) is not strongly controllable, as there is no way of statically assign b2 without knowing in advance the time at which e2 will happen. In fact, scheduling b2 too early could violate the e1 − e2 ≤ 1 constraint.In weak controllability, the executor is allowed to act based on the situation, i.e. knowing in advance the uncontrollable durations. In this setting, the solution to a weak controllability problem has the form of a strategy that given a situation computes an assignment to the controllable time points.Dynamic controllability limits the observations of the executor to the past events only. This problem can be seen as a restriction of weak controllability, in which it is possible for the executor to condition the assignments to situations, as long as they have become apparent. In other works, if a choice depends on the duration of an activity, this must have already terminated.In the rest of this paper, we focus on weak controllability, addressing the decision problem (i.e. determining whether there exists a winning strategy), and the synthesis problem (i.e. extracting such a strategy in an executable form).We now formally define the concept of weak controllability.Definition 3. Let Pproblem P with respect to the situation ω is the TP ( Xc ∪ Xu, ∅, ∅, C f ∪ Ccontingent constraint (cid:23)c), where C] with a free constraint ei − bi ∈ [ωi, ωi]..= ( Xc, Xu, Cc, C f ) be a TPU and let ω .= (ω1, . . . , ω| Xu |) be a situation in (cid:4)P . The projection P ω of the (cid:23)c is derived from Cc by replacing each (cid:4)E ij=1(ei − bi) ∈ [lci, j, uci, jIntuitively, the projection P ω is the problem without uncertainty in which each uncontrollable duration has been fixed to a given value.Definition 4. Let Pprojection P ω is consistent..= ( Xc, Xu, Cc, C f ) be a TPU. P is weakly controllable if and only if for each situation ω ∈ (cid:4)P the Definition 4 captures the weak controllability concept by requiring the existence of a schedule for each situation. This definition implicitly models a strategy as a function f : (cid:4)P → R| Xc |that maps each situation ω in a schedule for the controllable time points that fulfills the constraints of the projection P ω . If such a function exists, the problem is weakly controllable.Weak controllability is, in terms of games, the dual of strong controllability: in strong controllability, the executor is required to make its move (i.e. all its decisions) without observing the situation (i.e. the move of the environment); in weak controllability, the environment is required to make all its decisions before the executor.Finally, we note that the constraints of a TPU are essentially RDL formulae. As such, if there exists a weak strategy that fulfills all the problem constraints, there are infinitely many other strategies obtained by adding the same constant value to each strategy decision. In the example of Fig. 1, the value of b1 can be arbitrarily chosen because it precedes all the other time points, and the chosen value acts only as a shift for all the other time points.4. Deciding weak controllabilityIn order to logically define weak controllability, we first perform some manipulations on the problem definition. We encode each uncontrollable time point ei in terms of the time difference with its starting time point bi by means of an A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–277Fig. 2. The running example seen from an activities point of view to explain the encoding of the problem. The striped regions are the uncontrollable space, namely where an uncontrollable time point can be scheduled given the decision on the related controllable time point. Each contingent constraint is seen as an activity ( A1 and A2 in the picture) and the duration yi is the actual duration of the i-th activity.Xc = {b1, b2}Y u = { y1, y2}(cid:6)( (cid:11)Y u) = ( y1 ≥ 0) ∧ ( y1 ≤ 3) ∧ ( y2 ≥ 1) ∧ ( y2 ≤ 2)(cid:7)( (cid:11)Xc, (cid:11)Y u) = (b2 − b1 ≥ 0) ∧((b1 + y1) − (b2 + y2) ≤ 1) ∧((b2 + y2) − b1 ≤ 2)Fig. 3. The encoding of the example STPU of Fig. 1.uncontrollable duration variable yi . Intuitively, if we take an activity view, yi measures the duration of the i-th activity. For E ievery contingent constraint cci =j=1(ei − bi) ∈ [li, j, ui, j], let yi ∈ R be the uncontrollable duration variable associated to E ij=1( yi ∈ [li, j, ui, j]). yi represents the duration of the interval [bi, ei] that is constrained by the i-th contingent ei such that constraint. We are thus symbolically encoding a situation ω .= (ω1, . . . , ω| Xu |) in which yi models the value of ωi . Fig. 2gives a pictorial representation of this encoding interpreted at the activity level.(cid:4)(cid:4)Definition 5. Given a TPU ( Xc, Xu, Cc, C f ), let (cid:11)Y u be the vector of uncontrollable duration variables ( y1, y2, . . . , ym), with m = | Xu|. We define the encoding of the problem as a tuple ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) wherem(cid:6)E i(cid:7)(cid:6)( (cid:11)Y u).=( yi ∈ [li, j, ui, j])i=1j=1and(cid:7)( (cid:11)Xc, (cid:11)Y u).=(cid:6)c f i[( (cid:11)Xc + (cid:11)Y u)/ (cid:11)Xu]( (cid:11)Xc, (cid:11)Y u).=c f i∈C f(cid:6)c f i∈C fc f i[(b1 + y1)/e1][(b2 + y2)/e2] . . .[(bm + ym)/em]( (cid:11)Xc, (cid:11)Y u).Intuitively, (cid:6)( (cid:11)Y u) is the formula representing the conjunction of all the contingent constraints after the recoding, and (cid:7)( (cid:11)Xc, (cid:11)Y u) is the conjunction of all the free constraints rewritten in terms of (cid:11)Xc and (cid:11)Y u .We remark that the use of this encoding yields two consequences. First, thanks to the redefinition of each ei in terms of yi , we managed to encode the contingent constraints in terms of (cid:11)Y u only, therefore they are independent of the values of the controllable time points ( (cid:11)Xc ). Intuitively, (cid:6)( (cid:11)Y u) encodes the set of all possible situations ((cid:4)P ) for the given problem P : each model of (cid:6)( (cid:11)Y u) corresponds to a situation ω. Second, the constraints in this formulation are expressed in the LRAtheory (the original formulation was expressed in the RDL fragment of LRA). This encoding applied to the STPU problem in Fig. 1 is shown in Fig. 3.From here on, we assume an encoded problem ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) is given. Intuitively, a temporal problem is weakly controllable if there exists a strategy that maps every situation to a corresponding assignment to controllable time points, in such a way that all free constraints are satisfied. We can rephrase the concept of weak controllability presented in Definition 4 as a satisfiability problem modulo the LRA theory as follows.Proposition 1. Let Ponly if the following formula is valid in the LRA theory..= ( Xc, Xu, Cc, C f ) be a TPU and let ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) be its encoding. P is weakly controllable if and ∀ (cid:11)Y u.∃ (cid:11)Xc.((cid:6)( (cid:11)Y u) → (cid:7)( (cid:11)Xc, (cid:11)Y u))(1)8A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27¬∃b1, b2.(( y1 ≥ 0) ∧ ( y1 ≤ 3) ∧( y2 ≥ 1) ∧ ( y2 ≤ 2)) →((b2 − b1 ≥ 0) ∧((b1 + y1) − (b2 + y2) ≤ 1) ∧((b2 + y2) − b1 ≤ 2))( y1 ≥ 0) ∧ ( y1 ≤ 3) ∧( y2 ≥ 1) ∧ ( y2 ≤ 2) ∧¬∃b1, b2.((b2 − b1 ≥ 0) ∧((b1 + y1) − (b2 + y2) ≤ 1) ∧((b2 + y2) − b1 ≤ 2))(a)(b)Fig. 4. Inverted encoding (a) and assumption-extraction encoding (b) applied to the running example STPU of Fig. 1.The formula in Eq. (1) is a direct formalization of the intuitive notion of weak controllability, and of the original definition in [38]. The universal quantifier captures the uncertainty in the decision of the duration variables. The implication ensures that free constraints are checked only when (cid:6)( (cid:11)Y u) is satisfied, that is only on assignments that encode situations of the original temporal problem. In fact, if (cid:6)( (cid:11)Y u) is not satisfied, the implication is automatically satisfied.If we interpret the vector of time points (cid:11)Xc and the vector of durations (cid:11)Y u as vectors of real variables, and the set of constraints (cid:6)( (cid:11)Y u) and (cid:7)( (cid:11)Xc, (cid:11)Y u) as formulae in QF _LRA, Eq. (1) becomes a formula in LRA that is valid if and only if the problem is weakly controllable.For example, the problem depicted in Fig. 1(a) is weakly controllable if and only if the following formula is valid.∀ y1, y2.∃b1, b2.((( y1 ≥ 0) ∧ ( y1 ≤ 3) ∧ ( y2 ≥ 1) ∧ ( y2 ≤ 2)) →((b2 − b1 ≥ 0) ∧ ((b1 + y1) − (b2 + y2) ≤ 1) ∧((b2 + y2) − b1 ≤ 2)))Looking at the weak controllability formal characterization in Proposition 1 from an SMT perspective, it is clear that we are solving the validity problem of an LRA formula. Any SMT solver supporting LRA is able to deal with such a formula directly and it can correctly solve the problem. However, due to the high computational cost of directly handling quantifiers, an optimized encoding is required.We first rewrite the formula encoding weak controllability in Proposition 1 by transforming the external universal quan-tifier into the negation of an existential one, and we consider the negation of the resulting formula. We call the resulting formula inverted encoding.¬∃ (cid:11)Xc.((cid:6)( (cid:11)Y u) → (cid:7)( (cid:11)Xc, (cid:11)Y u))(2)If this formula is unsatisfiable, then the problem is weakly controllable, while if it is satisfiable, then the problem is not weakly controllable. Note that in Eq. (2) we dropped the outermost ¬∃ (cid:11)Y u as any SMT problem is inherently an existential quantification and we consider the negation by reversing the interpretation of the result. Intuitively, we are searching for an assignment to the uncontrollable time points that is able to violate the free constraints under any possible strategy (it is a winning strategy for the environment). In fact, if the formula is satisfiable, each model corresponds to a situation for which no strategy of controllable time-point assignment exists. Therefore, differently from Eq. (1), this encoding is also helpful for debugging a non-weakly controllable problem. This encoding still requires a solver with full support of LRA, but is able to exploit the searching power of the SMT framework and, in case of non-weak controllability, it allows for the extraction of debug information by providing a model of the formula. An example of this encoding for the running example problem is shown in Fig. 4(a).A further improvement can be achieved by limiting as much as possible the scope of the existential quantifier. To this extent, we push the existential quantifier over the implication, and thus the quantification is limited to the free constraints only (ref. as assumption-extraction encoding):(cid:6)( (cid:11)Y u) ∧ ¬∃ (cid:11)Xc.(cid:7)( (cid:11)Xc, (cid:11)Y u).(3)The assumption-extraction encoding for the running example problem is reported in Fig. 4(b).The following proposition states that the inverted and assumption-extraction encodings are logically equivalent.Proposition 2. Eqs. (2) and (3) are logically equivalent.Proof. We show how to convert Eq. (2) into Eq. (3), using logically equivalent rewritings.¬∃ (cid:11)Xc.((cid:6)( (cid:11)Y u) → (cid:7)( (cid:11)Xc, (cid:11)Y u))⇔ ¬∃ (cid:11)Xc.(¬(cid:6)( (cid:11)Y u) ∨ (cid:7)( (cid:11)Xc, (cid:11)Y u))⇔ ¬((∃ (cid:11)Xc.¬(cid:6)( (cid:11)Y u)) ∨ (∃ (cid:11)Xc.(cid:7)( (cid:11)Xc, (cid:11)Y u)))⇔ ¬(¬(cid:6)( (cid:11)Y u) ∨ (∃ (cid:11)Xc.(cid:7)( (cid:11)Xc, (cid:11)Y u)))⇔ (cid:6)( (cid:11)Y u) ∧ ¬(∃ (cid:11)Xc.(cid:7)( (cid:11)Xc, (cid:11)Y u))(cid:2)A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–279Fig. 5. Schematic view of implicit strategy mechanism. The strategy is repeatedly executed once a situation is obtained by estimating the relevant parameters in the Plant. The output of the strategy is a controllable schedule (i.e. an assignment ¯Xc to all the controllable time points). The implicit strategy works by “projecting away” the uncertainty in the TPU: the uncontrollable durations (cid:11)Y u are substituted with the actual values of the situation ¯S. Then, a TP is obtained and is solved using a TP solver, yielding the assignment ( ¯Xc ) to the controllable time points.5. Strategies for weak controllabilityWe now consider the problem of actually executing a control strategy that is associated with a given weakly controllable TPU. A TPU is a modeling framework that represents a set of assumptions over the environment and imposes a set of requirements to be fulfilled. We consider the use-case in which a strategy for scheduling the controllable time points is repeatedly executed by reading the inputs from the environment in the form of a situation. Such a situation is generated by reading the parameters on which the uncontrollable durations depends, by means of appropriate sensors and estimators. The strategy computes an assignment to the controllable time points that fulfills the problem constraints and is then deployed to an actuator for execution.The problem we tackle here is to automatically synthesize such a strategy: we discuss two approaches. First, we use a TP solver to do on-line reasoning, thus executing a control strategy that is implicitly defined in the TPU, if solvable. Then, we investigate the idea of explicit strategies, that can be readily executed without resorting to on-line reasoning.5.1. Implicit strategiesA way of obtaining a strategy for a weakly controllable TPU is given by Definition 3 and depicted in Fig. 5: when a situ-ation ¯S is read,3 we eliminate the uncertainty by substituting the uncontrollable duration variables in the TPU formulation with the values obtained from the situation (obtaining a TP that is the projection of the TPU). Then, we solve the resulting temporal problem, that is now without uncertainty, and return the assignment to the controllable time points ¯Xc for execu-tion. Formally, given the encoding of a TPU ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) and an assignment to all the uncontrollable durations ¯S fulfilling (cid:6)( ¯S) (a situation), we can find an assignment to the controllable variables (cid:11)Xc by finding a model for the formula (cid:7)( (cid:11)Xc, ¯S). This strategy requires a solver to be executed once the situation ¯S is known. In practice, we can implement this idea using any SMT solver by searching for a model for (cid:7)( (cid:11)Xc, ¯S). However, this approach (called Implicit-SMT) requires one to solve a separate SMT problem for each situation. A more advanced approach is to exploit the incrementality feature of modern SMT solvers [4], allowing the solver to “recycle” discovered clauses and lemmas among different situations. For this purpose, we designed an incremental approach, described in Algorithm 1. Implicit-SMT-Incremental takes the encoding of a TPU ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)), and initializes the SMT solver by asserting the problem constraints (cid:7)( (cid:11)Xc, (cid:11)Y u). Then, it enters a (possibly infinite) loop, and processes a sequence of situations ¯S 1, ¯S 2, · · · . The problem description is asserted in the solver once and for all, while the situation is first asserted, and once an assignment is found, it is retracted.The main drawback of the implicit approach is the requirement of on-line reasoning. In fact, once the situation is known, a solver is invoked to discover the assignment for the controllable time points. Solving the TP resulting from the projection of a TPU is hard in general. If the problem belongs to the STPU problem class the resulting STP can be solved in polynomial time, but for the general case of DTPU, the projection results in a DTP that is, in general, NP-hard [37]. In addition, having a solver as part of the run-time may require much more expensive platforms.5.2. Explicit strategiesWe avoid the burden of on-line reasoning by providing techniques for the synthesis of functions that are simple and fast to execute. Consider the formalization in Proposition 1. Interestingly, we can apply skolemization [24], thus replacing the existential quantifier by means of a fresh function symbol.3 ¯S is a vector of | (cid:11)Y u| rational numbers, one for each uncontrollable duration.10A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Algorithm 1 Implicit strategy execution based on SMT with incrementality.1: procedure Implicit-SMT-Incremental((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u))2:3:for all bi ∈ (cid:11)Xc doSMT.declareRealVar(bi )for all y j ∈ (cid:11)Y u do4:5:6:7:8:9:10:11:12:13:14:15:16:SMT.declareRealVar( yi )SMT.assert((cid:7)( (cid:11)Xc, (cid:11)Y u))loop¯S ← WaitForSituation()SMT.push()for all yi ∈ (cid:11)Y u doSMT.assert( yi = ¯S i )if SMT.solve = SAT thenμ ← SMT.getModel()ExcecuteTimePoints(μ)else⊥(cid:16) Unreachable if the problem is WC and the situation S fulfills (cid:6)( (cid:11)Y u)SMT.pop()17:18:19: end procedureend loopTheorem 1. A TPU ( Xc, Xu, Cc, C f ) is weakly controllable if and only if the formula∀ (cid:11)Y u.(cid:6)( (cid:11)Y u) → (cid:7)( f ( (cid:11)Y u), (cid:11)Y u)is satisfiable.(4)Proof. Eq. (4) is the result of applying the skolemization [24] procedure to Eq. (1). Since skolemization produces an equi-satisfiable formula, Eq. (4) is equi-satisfiable to Eq. (1). Since Eq. (1) has no free variables nor has uninterpreted terms, satisfiability coincides with validity. Therefore Eq. (1) is valid if and only if Eq. (4) is satisfiable, and Proposition 1 states that the TPU is weakly controllable if and only if Eq. (1) is valid. (cid:2)We transform the inner existential quantifier into a function f that models the weak strategy for the problem. In fact, in Eq. (4), the interpretation of the function fis exactly a strategy that solves the problem. Eq. (4) gives a clear vision of what a strategy is: a function that gets in input the uncontrollable durations and returns an assignment to the controllable time points that fulfills all the problem constraints.In principle, one would like to exploit this formulation to query an SMT solver, and extract, from the model, a closed form for the strategy f . However, Eq. (4) is a quantified first-order formula involving uninterpreted functions,4 that is in general undecidable.In the following, we focus on two types of strategies: linear strategies, where each controllable variable is computed as a linear combination of the uncontrollable durations; piecewise-linear strategies, where different linear strategies are executed depending on the input situation.From here on, we assume the encoding ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) of a TPU is given. In general, a weak strategy is a function that maps each assignment to uncontrollable durations satisfying (cid:6)( (cid:11)Y u ) (i.e. each situation) into an assignment to the controllable time points, such that all the free constraints are satisfied.Definition 6. A weak strategy for a TPU is a function f : R|Y u | → R| Xc |(cid:7)( f ( (cid:11)Y u), (cid:11)Y u) holds for every (cid:11)Y u in (cid:6)( (cid:11)Y u).defined for every point (cid:11)Y u in (cid:6)( (cid:11)Y u) and such that Note that, this definition does not impose any constraint (e.g. linearity, continuity) on f other than being a function.In Definition 6 we modeled a weak strategy as a single function f : R|Y u | → R| Xc |, but we can equivalently consider a set of functions f 1, . . . , f| Xc | each computing a schedule for a single controllable time point given the situation. The two formalizations are equivalent because if there exists a unique function f , we can obtain the set of function by projection of f and vice-versa.Let ¯f ( (cid:11)Y u) : R|Y u | → R| Xc |be a strategy. The strategy imposes a relation between the controllable time points and the uncontrollable durations: (cid:11)Xc = ¯f ( (cid:11)Y ). If such a relation is expressible as a formula in a theory T we can check whether ¯fis a weak strategy for a given temporal problem by checking the existence of a point in (cid:6)( (cid:11)Y u) that violates the free constraints.(cid:6)( (cid:11)Y u) ∧ ¬(cid:7)( (cid:11)Xc, (cid:11)Y u) ∧ ( (cid:11)Xc = ¯f ( (cid:11)Y u))(5)4 Formally, Eq. (4) is a quantified first-order formula expressed in the theory combination of LRA and the theory of uninterpreted functions (EU F ) [4].A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2711If Eq. (5) is satisfiable modulo T ∪ QF _LRA, then ¯f ( (cid:11)Y u) is not a valid weak strategy, because there exists a situation for which the strategy violates the free constraints. In this case, T can be any theory needed to express the relation imposed by the strategy, for example it could be LRA or even Nonlinear Real Arithmetic. Note that, this check is very useful in practice if ¯f ( (cid:11)Y u) can be expressed in QF _LRA because the entire check would fit in QF _LRA. In the following, we describe two possible shapes of strategies, namely linear and piecewise-linear. Both the shapes can be expressed in QF _LRA. Therefore checking if such strategies are weak strategies for a given problem is possible by performing a single call to an SMT solver in QF _LRA.Linear strategies A linear strategy is such that the value of every controllable time point is obtained as a linear combination of (cid:11)Y u . Let n .= | Xc| and m .= | Xu|. A linear strategy can be represented with a matrix A of real coefficients of size n × m and a vector (cid:11)c of size n. Every controllable variable is scheduled according to a linear function of the uncontrollable durations. The strategy f ( (cid:11)Y u) can be then expressed as A · (cid:11)Y u + (cid:11)c in which each bi ∈ Xc can be computed as Ai,1 y1 + . . . + Ai,m ym + ci . Therefore, the matrix A must have one column for every duration and the vector (cid:11)c contains the constant additive terms. The problem of synthesizing a linear strategy is then equivalent to the problem of finding a suitable matrix A and vec-tor (cid:11)c.Piecewise-linear strategies A more general form of strategy is the piecewise-linear strategy, that is the composition of a finite number of linear strategies. A piecewise-linear strategy is defined by cases over a finite partition of the situations (a partition of the region represented by (cid:6)( (cid:11)Y u)). For each case we have a linear strategy that is a valid weak strategy for that subset of the situations. We can compose these linear strategies by first checking in which element of the partition the observed situation belongs, and then applying the corresponding linear strategy. In this setting, a linear strategy is a particular case of a piecewise-linear strategy in which we have a partition of cardinality one.Definition 7. A piecewise-linear strategy is a functionf ( (cid:11)Y u).=⎧⎪⎪⎨⎪⎪⎩if η1( (cid:11)Y u)f 1( (cid:11)Y u)f 2( (cid:11)Y u) else if η2( (cid:11)Y u)...f k( (cid:11)Y u) else if ηk( (cid:11)Y u)where each f i is a linear strategy and ηi( (cid:11)Y u) are sub-regions of (cid:6)( (cid:11)Y u) such that (cid:6)( (cid:11)Y u) ⊆ ((cid:5)ki=1 ηi( (cid:11)Y u)).Note that, even this kind of strategy can be directly encoded in QF _LRA. We call each pair ( f i( (cid:11)Y u), ηi( (cid:11)Y u)) a “piece” of the strategy. In order to compactly represent a piecewise-linear strategy in the algorithms we abstract a piecewise-linear strategy f ( (cid:11)Y u) as the ordered list of its pieces. For example, the strategy f ( (cid:11)Y u) in Definition 7 can be represented as the following list of pieces:[( f 1( (cid:11)Y u), η1( (cid:11)Y u)), ( f 2( (cid:11)Y u), η2( (cid:11)Y u)), . . . , ( f k( (cid:11)Y u), ηk( (cid:11)Y u))].Following Definition 7, no continuity requirement is imposed on a piecewise-linear strategy. Continuity is not required by the weak controllability definition and is not a useful requirement for our setting, as we assume that the parameters yielding the situation are fully specified before scheduling the problem. Continuity is instead an important issue in dynamic strategies as small variations in the situation should not yield substantial variations in the strategy outcome. However this discussion is out of the scope of this paper.Linearity is not enough A linear strategy is very useful in practice: it is compact to represent and easy to evaluate. In fact, it can be represented using just a matrix and a vector; moreover, given an assignment to the uncontrollable duration, we can compute the resulting assignment to the controllable variables by means of a single matrix multiplication. In general, unfortunately, a weakly controllable TPU is not guaranteed to have such a strategy. In fact, this holds even for the STPU class of problems.Theorem 2. There exists an STPU that is weakly controllable and does not have any linear strategy.Proof. Let us consider the STPU depicted in Fig. 6 obtained by adding the constraint e1 − b2 ∈ [0, +∞) to the running example in Fig. 1. In the following we show that this STPU is weakly controllable, but there exists no linear strat-egy.The problem is weakly controllable, because we can apply the following piecewise-linear weak strategy.(cid:12)(cid:13)b1b2= f ( y1, y2).=(cid:12)⎧⎪⎪⎨(cid:12)⎪⎪⎩(cid:13)0y1 − y2 − 1(cid:13)00if ( y2 ≤ y1 − 1)otherwise12A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Fig. 6. (a) The modified running example STPU: the problem is weakly controllable, but does not have any linear strategy. (b) The constraint definitions for the modified running example.Fig. 7. (a) The region of feasibility of the STPU in Fig. 3 with b1 = 0 in the space of b2, y1 and y2, depicted from two different angles.This strategy corresponds to the following assignments.b1 = 0(cid:14)b2 =y1 − y2 − 1 if ( y2 ≤ y1 − 1)0otherwiseThis strategy clearly covers the entire uncontrollable space because it is a total function. Given this strategy, the free con-straints are always satisfied: assuming (cid:6)( y1, y2) and y2 > y1 − 1, the formula (cid:7)( (cid:11)Xc, (cid:11)Y u) reduces to(cid:7)( f ( y1, y2), y1, y2).= (0 − 0 ≥ 0) ∧ ((0 + y1) − 0 ≥ 0) ∧((0 + y1) − (0 + y2) ≤ 1) ∧((0 + y2) − 0 ≤ 2)⇔ ( y1 ≥ 0) ∧ ( y1 − y2 ≤ 1) ∧ ( y2 ≤ 2).(6)The atoms ( y1 ≥ 0) and ( y2 ≤ 2) follow from the assumptions of (cid:6)( y1, y2) while the atom ( y1 − y2 ≤ 1) is entailed by the condition of the piece: y2 > y1 − 1.Considering the other piece, namely the case y2 ≤ y1 − 1, we obtain the following.(cid:7)( f ( y1, y2), y1, y2).= ( y1 − y2 − 1 − 0 ≥ 0) ∧ ((0 + y1) − ( y1 − y2 − 1) ≥ 0) ∧((0 + y1) − ( y1 − y2 − 1 − y2) ≤ 1) ∧(( y1 − y2 − 1 + y2) − 0 ≤ 2)⇔ ( y2 ≤ y1 − 1) ∧ ( y2 ≥ 1) ∧ (1 ≤ 1) ∧ ( y1 ≤ 3)(7)The atoms ( y2 ≥ 1) and ( y1 ≤ 3) follow from the assumptions of (cid:6)( y1, y2) while the atom ( y2 ≤ y1 − 1) is exactly the condition of the piece we are considering.We now show that no linear strategy exists for the given problem. For the sake of contradiction, let us suppose that a linear strategy exists for the problem. Let ¯f ( (cid:11)Y u) .= A · (cid:11)Y u + (cid:11)c be such a linear strategy. Then, b1 ˙= A1,1 y1 + A1,2 y2 + c1.= A2,1 y1 + A2,2 y2 + c2. If ¯f ( (cid:11)Y u) is a valid weak linear strategy, it must fulfill the problem constraints in all the and b2.= 0 and y2 ˙=1), ω2 = (0, 2), ω3 = (3, 1)situations. Let us consider four particular situations, namely ω1 = (0, 1) (that is, yiand ω4 = (3, 2).We can now build the following system obtained by instantiating each constraint of (cid:7)(b1, b2, y1, y2) in each of the four picked situations, and by substituting each bi with its strategy definition.A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2713( A2,1 · 0 + A2,2 · 1 + c2) − ( A1,1 · 0 + A1,2 · 1 + c1) ≥ 0( A1,1 · 0 + A1,2 · 1 + c1 + 0) − ( A2,1 · 0 + A2,2 · 1 + c2) ≥ 0( A1,1 · 0 + A1,2 · 1 + c1 + 0) − ( A2,1 · 0 + A2,2 · 1 + c2 + 1) ≤ 1( A2,1 · 0 + A2,2 · 1 + c2 + 1) − ( A1,1 · 0 + A1,2 · 1 + c1) ≤ 2( A2,1 · 0 + A2,2 · 2 + c2) − ( A1,1 · 0 + A1,2 · 2 + c1) ≥ 0( A1,1 · 0 + A1,2 · 2 + c1 + 0) − ( A2,1 · 0 + A2,2 · 2 + c2) ≥ 0( A1,1 · 0 + A1,2 · 2 + c1 + 0) − ( A2,1 · 0 + A2,2 · 2 + c2 + 2) ≤ 1( A2,1 · 0 + A2,2 · 2 + c2 + 2) − ( A1,1 · 0 + A1,2 · 2 + c1) ≤ 2( A2,1 · 3 + A2,2 · 1 + c2) − ( A1,1 · 3 + A1,2 · 1 + c1) ≥ 0( A1,1 · 3 + A1,2 · 1 + c1 + 3) − ( A2,1 · 3 + A2,2 · 1 + c2) ≥ 0( A1,1 · 3 + A1,2 · 1 + c1 + 3) − ( A2,1 · 3 + A2,2 · 1 + c2 + 1) ≤ 1( A2,1 · 3 + A2,2 · 1 + c2 + 1) − ( A1,1 · 3 + A1,2 · 1 + c1) ≤ 2( A2,1 · 3 + A2,2 · 2 + c2) − ( A1,1 · 3 + A1,2 · 2 + c1) ≥ 0( A1,1 · 3 + A1,2 · 2 + c1 + 3) − ( A2,1 · 3 + A2,2 · 2 + c2) ≥ 0( A1,1 · 3 + A1,2 · 2 + c1 + 3) − ( A2,1 · 3 + A2,2 · 2 + c2 + 2) ≤ 1( A2,1 · 3 + A2,2 · 2 + c2 + 2) − ( A1,1 · 3 + A1,2 · 2 + c1) ≤ 2⎧⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩⎧This system can be rewritten as follows.− A1,2 + A2,2 − c1 + c2 ≥ 0A1,2 − A2,2 + c1 − c2 ≥ 0− A1,2 + A2,2 − c1 + c2 ≥ 0A1,2 − A2,2 + c1 − c2 ≥ −1−2 A1,2 + 2 A2,2 − c1 + c2 ≥ 02 A1,2 − 2 A2,2 + c1 − c2 ≥ 0−2 A1,2 + 2 A2,2 − c1 + c2 ≥ −3+2 A1,2 − 2 A2,2 + c1 − c2 ≥ 0−3 A1,1 − A1,2 + 3 A2,1 + A2,2 − c1 + c2 ≥ 03 A1,1 + A1,2 − 3 A2,1 − A2,2 + c1 − c2 ≥ −3−3 A1,1 − A1,2 + 3 A2,1 + A2,2 − c1 + c2 ≥ 13 A1,1 + A1,2 − 3 A2,1 − A2,2 + c1 − c2 ≥ −1−3 A1,1 − 2 A1,2 + 3 A2,1 + 2 A2,2 − c1 + c2 ≥ 03 A1,1 + 2 A1,2 − 3 A2,1 − 2 A2,2 + c1 − c2 ≥ −3−3 A1,1 − 2 A1,2 + 3 A2,1 + 2 A2,2 − c1 + c2 ≥ 0−3 A2,1 − 2 A2,2 + 3 A1,1 + 2 A1,2 + c1 − c2 ≥ 0The system admits no solution in the real numbers. Therefore there exists no linear strategy for the given problem as there exists no assignment to the coefficients that are able to fulfill the four situations at the same time. (cid:2)In order to graphically explain the reason why no linear strategy exists for the given problem, we plotted the space of free constraints of the STPU problem in the space ( y1, y2, b2) regions in Figs. 7(a) and 7(b) (without loss of generality, we assigned b1 = 0 as we can always freely assign a reference controllable time point thanks to the RDL property of shifting solutions). The plot clearly shows that there exists no linear strategy for b2. Considering the vertex (0, 1) in the space ( y1, y2), a linear solution must contain point (0, 1, 0) as it is the only feasible point for the vertex (0, 1). Similarly, considering (0, 2) we must include (0, 2, 0); considering (3, 1) we must include (3, 1, 1) and for (3, 2) the linear solution must include the point (3, 2, 0). However, no linear solution can exist because no plane contains all the four points. In fact, the only plane containing (0, 1, 0), (0, 2, 0) and (3, 2, 0) is b2 = 0, but this plane does not contain the point (3, 1, 1).We can also exploit the encodings for the decision problem to show that the STPU in Fig. 6 is weakly controllable. The inverted SMT encoding of Eq. (2) for the example problem is as follows.¬∃b1, b2.(( y1 ≥ 0) ∧ ( y1 ≤ 3) ∧ ( y2 ≥ 1) ∧ ( y2 ≤ 2)) →((b2 − b1 ≥ 0) ∧ ((b1 + y1) − b2 ≥ 0) ∧((b1 + y1) − (b2 + y2) ≤ 1)) ∧((b2 + y2) − b1 ≤ 2)(8)This formula can be shown to be unsatisfiable by any LRA SMT solver. Therefore the problem is indeed weakly controllable. The unsatisfiability of the formula is also shown by Eqs. (6) and (7) that provide a witness strategy for the existential quantifier, making the formula false. In fact, if ( y2 > y1 − 1) holds, Eq. (8) is unsatisfiable because b1 = 0 and b2 = 0 is a model of Eq. (6). Similarly, if ( y2 ≤ y1 − 1) holds, Eq. (8) is unsatisfiable because b1 = 0 and b2 = y1 − y2 − 1 is a model of Eq. (7).14A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Piecewise-linear strategy is enough We now prove that a piecewise-linear strategy always exists for any weakly controllable TPU.Theorem 3. For any given TPU P , if P is weakly controllable, then P admits a piecewise-linear strategy.Proof. Let ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) be the encoding of P . Since P is weakly controllable, we know that∀ (cid:11)Y u.∃ (cid:11)Xc.(cid:6)( (cid:11)Y u) → (cid:7)( (cid:11)Xc, (cid:11)Y u)is valid.We want to prove that there exists a piecewise-linear strategy f such that∀ (cid:11)Y u.((cid:6)( (cid:11)Y u) ∧ (cid:11)Xc = f ( (cid:11)Y u)) → (cid:7)( (cid:11)Xc, (cid:11)Y u)is valid.By construction, both (cid:6)( (cid:11)Y u) and (cid:7)( (cid:11)Xc, (cid:11)Y u) are formulae in QF _LRA and hence they geometrically correspond to the union of finitely many closed convex polyhedra (the polyhedra are closed because all the inequalities are non-strict by problem definition).We now show that from each face we can extract a linear strategy that correctly work for a sub-region of (cid:6)( (cid:11)Y u ). By combining these linear strategies for all the faces of the polyhedron we obtain a weak strategy for P .Without loss of generality we can assume (cid:7)( (cid:11)Xc , (cid:11)Y u) being a bounded set (meaning that it can be completely contained in a ball of finite radius). This is because we already have bounds for all the uncontrollable variables in (cid:6)( (cid:11)Y u ) (because of the assumptions in Definition 1) and we can always add upper and lower bounds on controllable variables as follows. Since the .= max({g( (cid:11)Y u) | (cid:11)Y u |(cid:20) (cid:6)( (cid:11)Y u)})problem is weakly controllable, let g( (cid:11)Y ) be any weak strategy. For each variable x ∈ (cid:11)Xc , let ux.= min({g( (cid:11)Y u) | (cid:11)Y u |(cid:20) (cid:6)( (cid:11)Y u)}). We can then add the following constraint to the problem without altering its weak and lxcontrollability: x ∈ [lx, ux].Let φ1( (cid:11)Xc, (cid:11)Y u), · · ·, φ w ( (cid:11)Xc, (cid:11)Y u) be the formulae corresponding to the faces of (cid:7)( (cid:11)Xc, (cid:11)Y u). Each face φ z( (cid:11)Xc, (cid:11)Y u) is a convex polyhedron and can be expressed as a system of inequalities A( (cid:11)Xc| (cid:11)Y u) ≤ b with at least one inequality satisfied as an equality. From this system is easy to extract a linear strategy f z( (cid:11)Y u) by reducing the augmented matrix ( A|b) into reduced row echelon form and applying substitution to extract the relation between (cid:11)Xc and (cid:11)Y u in closed form.For each face φ z( (cid:11)Xc, (cid:11)Y u) we define its projection χ z( (cid:11)Y u) .= ∃ (cid:11)Xc.φ z( (cid:11)Xc, (cid:11)Y u). Since QF _LRA admits quantifier elimi-nation, also χ z( (cid:11)Y u) can be expressed as a QF _LRA formula, and geometrically corresponds to a finite union of convex polyhedra.Therefore, we can build the piecewise-linear weak strategy f defined as follows.f ( (cid:11)Y u).=⎧⎪⎪⎪⎨⎪⎪⎪⎩if χ 1( (cid:11)Y u)f 1( (cid:11)Y u)f 2( (cid:11)Y u) else if χ 2( (cid:11)Y u)...f k( (cid:11)Y u) else if χ k( (cid:11)Y u)(cid:4)wi=1 χ i( (cid:11)Y u)) → (cid:6)( (cid:11)Y u) because we know that P is weakly controllable and we assumed (cid:7)( (cid:11)Xc, (cid:11)Y u) to be Clearly, ∀ (cid:11)Y u.(bounded (being bounded, the projection of all the faces corresponds to the projection of the polyhedral union itself). In addition, each f z( (cid:11)Y u) applied to a point in χ z( (cid:11)Y u) yields a point belonging to a face of the polyhedron, hence belonging to (cid:7)( (cid:11)Xc, (cid:11)Y u). Thus, the strategy is a valid weak strategy for P . (cid:2)6. Synthesis of strategies for weak controllabilityWe are interested in generating strategies that can be efficiently executed once the situation is known. Given this re-quirement, linear strategies are very helpful, because they are compact (the size is quadratic in the number of time points) and can be executed by performing a linear computation in the size of the strategy. Piecewise-linear strategies are also helpful because they can be executed in linear time in the size of the strategy as they require only a case switch before applying the linear executor.The problem of synthesizing weak strategies can be classified along two dimensions; we distinguish between (i) convex (STPU) vs. disjunctive (DTPU) temporal problems and (ii) linear vs. piecewise-linear strategies. Table 1 summarizes this classification and indicates the algorithms we developed for each problem class.All the algorithms assume that the given problem is weakly controllable, but it is not known in advance whether the problem admits a linear strategy. Thus, the algorithms listed in the “Linear” column of Table 1 return ⊥ in case no linear strategy exists. The others are guaranteed to find a piecewise-linear strategy. In the rest of this section we analyze each combination of temporal problem class and strategy type separately.A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2715Table 1Overview of the developed algorithms with references to the section that describes each of them.Convex (STPU)Disjunctive (DTPU)Strategy typeLinearVertexEncoding (Section 6.1.1)IncrementalWeakening (Section 6.1.2)NRA Encoding (Section 6.3)Piecewise-linearSimplexesDecomposition (Section 6.2.1)LazyExpansion (Section 6.2.2)SkinCrawler (Section 6.4.1)ConvexRegionEnumerator (Section 6.4.2)SMT notation In the following, we present algorithms that use different features provided by modern SMT solvers, such as optimization [35]. We indicate with the prefix “SMT.” the functions that are related with SMT solving. In particular, the func-tion SMT.declareTypeVar(v) declares an SMT variable named v with type Type (e.g. SMT.declareRealVar(v) is the function that declares a real-valued SMT variable). SMT.solve(φ((cid:11)x)) is a function that checks the satisfiability of the formula φ((cid:11)x)and returns “SAT” if and only if the formula is satisfiable, otherwise the function returns “UNSAT”. SMT.getModel() returns a satisfying assignment to the formula that was checked using SMT.solve if the answer was “SAT”. Finally, the functionSMT.solveMaximizing(φ((cid:11)x), h((cid:11)x)) behaves like SMT.solve(φ((cid:11)x)) but generates the model that maximizes the function h((cid:11)x).In an incremental setting [7,17], we assume a stateful SMT solver that has the following capabilities. SMT.assert(φ((cid:11)x))conjoins the formula φ((cid:11)x) to the state of the SMT solver without performing any solving operation. SMT.push() records a backtrack point in the sate of the SMT solver in a stack. The last recorded state can be restored by calling the SMT.pop()function. Finally, when using incrementality we assume that the SMT.solve function can be called without arguments to check the satisfiability of the conjunction of the currently asserted set of formulae.6.1. Linear strategies for STPUIn the following, we discuss two algorithms that are able to synthesize linear strategies for a given STPU problem. They both leverage the convexity in the constraints of the STPU problem class.6.1.1. Vertex encodingIf the problem is an STPU, then the free constraints represent a convex space: given any two points in the space of free constraints, any point in the line connecting these two points is also a solution. Following this idea we can generalize the result of weak controllability on bounds in [38] to the search of linear strategies. We consider all the vertexes of the uncontrollable space (cid:6)( (cid:11)Y u) that, by definition of (cid:6)( (cid:11)Y u), are the elements of the set V (cid:6)} × · · · × {lc.= {lc}.m,1, ucm,11,1, uc1,1Theorem 4. Let Pstrategy. If ¯f fulfills (cid:7)( (cid:11)Xc, (cid:11)Y u) in all the vertexes v i ∈ V (cid:6) , then ¯f is a weak linear strategy for P ..= (Xc, Xu, Cc, C f ) be an STPU, ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) be its encoding and let ¯f : R|Y u | → R| Xc |be a linear Proof. For the sake of contradiction, let us suppose that there exists a point ¯p in the space of (cid:11)Y u such that (cid:6)( ¯p) holds and (cid:7)( ¯f ( ¯p), ¯p) does not hold.Then, there must exist a free constraint ck that is violated by ¯p. Since the problem is an STPU, each free constraint is geometrically either a half-space (for example a − b ∈ [1, ∞)) or the intersection of two half-spaces (for example, a − b ∈[10, 15] is the intersection of the half-space a − b ≤ 15 with a − b ≥ 10). Therefore, ¯p does not belong to one of the half-spaces encoded by ck. Let H be the violating half-space.However, for each vertex v i ∈ V (cid:6) , ¯f (v i) must belong to H because the free constraints are fulfilled in all the vertexes.The point ¯f ( ¯p) belongs to the convex hull of the points ¯f (v i), but then it must belong to the half-space H . Hence, we have a contradiction. (cid:2)Based on this insight, the idea is to create a single formula that encodes the problem with a symbolic strategy in all the vertexes of the uncontrollable region. The encoding is obtained instantiating the problem constraint in all the vertexes v i ∈ V (cid:6) and by enforcing a single hyperplane to contain all of them. If such a hyperplane exists, then it is a valid linear strategy for the entire problem.Algorithm 2 shows the pseudo-code for extracting a linear strategy with such encoding. We create a matrix A and a vector (cid:11)c of real SMT variables representing the coefficients of the linear strategy. The function VertexAssignments generates all the vertexes of the convex polyhedron corresponding to (cid:6)( (cid:11)Y u). In order to achieve this result if (cid:6)( (cid:11)Y u) is generated as in Definition 5, it suffices to generate all the possible combinations of assignments of contingent constraints bounds. We remark that each ¯p is a vector of constants, and therefore the only variables occurring in the formula φ( A, (cid:11)c) are the coefficients of the linear strategy f ( (cid:11)Y u) .= A · (cid:11)Y u + (cid:11)c. The function SMT.solve checks the satisfiability of the given formula using an SMT solver, while SMT.getModel returns the produced model in case of SAT answer.We presented this algorithm for an encoded problem as formalized in Definition 5, but the same idea can be applied when (cid:6)( (cid:11)Y u) and (cid:7)( (cid:11)Xc, (cid:11)Y u) are simply conjunctive QF _LRA formulae (so that they represent convex polyhedra). The only modification needed for the algorithm is to change the VertexAssignments so that it is able to produce the vertexes of 16A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Algorithm 2 Vertex Encoding.1: procedure VertexEncoding((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u))2:3:4:5:SMT.declareRealVar(ci )for all y j ∈ (cid:11)Y u dofor all bi ∈ (cid:11)Xc doSMT.declareRealVar( Ai, j )6:7:8:φ( A, (cid:11)c) ← (cid:3)for all ¯p ∈ VertexAssignments((cid:6)( (cid:11)Y u)) doφ( A, (cid:11)c) ← φ( A, (cid:11)c) ∧ (cid:7)( A · ¯p + (cid:11)c, ¯p)if SMT.solve(φ( A, (cid:11)c)) = SAT then( A, (cid:11)c) ← SMT.getModel()return f ( (cid:11)Y u) .= A · (cid:11)Y u + (cid:11)c9:10:11:12:return ⊥13:14: end procedureelsegeneral formulae. For doing this we can employ well known techniques for enumerating the vertexes of a convex polyhe-dron [3].Consider for example the STPU problem in Fig. 1. The resulting problem admits a linear strategy. The encoding obtained by the application of Algorithm 2 is as follows.(( A1,2 · 0 + A2,2 · 1 + c2) − ( A1,1 · 0 + A2,1 · 1 + c1) ≥ 0) ∧((( A1,1 · 0 + A2,1 · 1 + c1) + 0) − (( A1,2 · 0 + A2,2 · 1 + c2) + 1) ≤ 1) ∧((( A1,2 · 0 + A2,2 · 1 + c2) + 1) − ( A1,1 · 0 + A2,1 · 1 + c1) ≤ 2)∧∧∧(( A1,2 · 0 + A2,2 · 2 + c2) − ( A1,1 · 0 + A2,1 · 2 + c1) ≥ 0) ∧((( A1,1 · 0 + A2,1 · 2 + c1) + 0) − (( A1,2 · 0 + A2,2 · 2 + c2) + 2) ≤ 1) ∧((( A1,2 · 0 + A2,2 · 2 + c2) + 2) − ( A1,1 · 0 + A2,1 · 2 + c1) ≤ 2)(( A1,2 · 3 + A2,2 · 1 + c2) − ( A1,1 · 3 + A2,1 · 1 + c1) ≥ 0) ∧((( A1,1 · 3 + A2,1 · 1 + c1) + 3) − (( A1,2 · 3 + A2,2 · 1 + c2) + 1) ≤ 1) ∧((( A1,2 · 3 + A2,2 · 1 + c2) + 1) − ( A1,1 · 3 + A2,1 · 1 + c1) ≤ 2)(( A1,2 · 3 + A2,2 · 2 + c2) − ( A1,1 · 3 + A2,1 · 2 + c1) ≥ 0) ∧((( A1,1 · 3 + A2,1 · 2 + c1) + 3) − (( A1,2 · 3 + A2,2 · 2 + c2) + 2) ≤ 1) ∧((( A1,2 · 3 + A2,2 · 2 + c2) + 2) − ( A1,1 · 3 + A2,1 · 2 + c1) ≤ 2)The encoding is satisfiable and a possible model (encoding a linear strategy) is reported in Eq. (9).(cid:12)(cid:13)(cid:12)(cid:13)A =000 −1(cid:11)c =02(9)Therefore, the assignments for the controllable time points b1 and b2 are b1.= 0 and b2.= − y2 + 2.Note that, this approach leads to an exponential blowup in the size of the SMT problem, caused by the fact that the number of vertexes is 2|Y u |.6.1.2. Incremental weakeningIn order to limit the exponential blowup of the previous encoding to the worst case only, we developed another approach called “incremental weakening”, that tries to limit the number of coefficients to search for and to reduce the amount of variables that are used in the linear strategy. This idea amounts to finding a matrix A in which some (possibly many) columns are null vectors; in fact, if the i-th column is null in A, the strategy does not depend on the actual values of yi . In the limit case in which A is the null matrix, the strategy degenerates to an assignment of constant values to each controllable time points, and thus to a strong controllability solution.We start by solving a relaxed problem, in which no uncontrollable duration is observed. This coincides with the definition of a strong controllability problem. If a solution is found, the strong assignment is a valid weak linear strategy for the problem, because strong controllability implies weak controllability. Otherwise, a subset of the uncontrollable durations A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2717repeatAlgorithm 3 Incremental weakening.1: procedure IncrementalWeakening((cid:6)( (cid:11)Y u ), (cid:7)( (cid:11)Xc, (cid:11)Y u))2:3:4:5:O ← GetUsableDurations( (cid:11)Y u )N ← { y ∈ (cid:11)Y u | y /∈ O }η( (cid:11)Xc, (cid:11)O ) ← SC_Encode((cid:6)|N ( (cid:11)N), (cid:7)|Xc ∪N ( (cid:11)Xc , (cid:11)N))f ( (cid:11)O ) ← VertexEncoding((cid:6)| (cid:11)O ( (cid:11)O ), η( (cid:11)Xc, (cid:11)O ))if f ( (cid:11)O ) (cid:18)= ⊥ thenreturn AddNullColumns( f ( (cid:11)O ))6:7:8:until O = Y ureturn ⊥9:10:11: end procedure(cid:11)p ⊆ (cid:11)Y u is picked and marked as “usable” by the strategy. The algorithm then tries to build a linear strategy that uses uncontrollable durations in (cid:11)p only. In this way, we are limiting the observations available to our strategy. Using the previous algorithm, we build the coefficients for the p-th column of the matrix A and we encode the problem as in the previous algorithm, limiting the exponential explosion only to the durations marked as “usable”. If the algorithm fails to find a linear strategy for a particular set of “usable” durations, a different subset of the durations is picked and the approach is iterated, until all the uncontrollable durations are marked as “usable” and the encoding coincides with the previous approach.The pseudo-code of this method is reported in Algorithm 3. The function GetUsableDurations returns a heuristically computed subset of (cid:11)Y u that constitutes the set of “observed” durations. The function is stateful as it is assumed to return a different subset at each call. The termination of the algorithm requires that this function eventually returns the entire (cid:11)Y u that exits the repeat loop fulfilling the condition at line 9. In this termination condition, the algorithm behaves like the VertexEncoding procedure executed on the entire problem. The function SC_Encode produces the encoding of a strong controllability problem in SMT (as in [11]). This encoding is used to prevent the observation of non-used durations, leaving the others untouched. The function VertexEncoding is the function described in Algorithm 2. If the VertexEncoding func-tion returns a strategy that works for a subset of the uncontrollable duration variables, we return the same linear strategy completed by the function AddNullColumns. The function adds columns of 0s in the positions of the durations that were not used. This guarantees that the strategy is independent of the actual values of those durations.This algorithm tries to abstract the problem by limiting the set of “usable” durations in a strategy, and refines the abstraction if no linear strategy is found. The process is iterated until a strategy is found or the entire set of durations is marked as “usable”.As shown in the previous section, if we consider the running example in Fig. 1, we can derive a strategy in which y1 is never observed. The advantage of IncrementalWeakening over the previous algorithm is that if we choose to use y2 but not y1 in our strategy we can get to the same result reported in Eq. (9) with a smaller and simpler encoding.This algorithm depends on the heuristic used for selecting the “usable” durations. In fact, the number of cycles of the algorithm directly depends on the heuristic.In our experiments we implemented a heuristic based on a topological sorting of the uncontrollable time points. The heuristic first generates all the singleton subsets and, if the algorithm is not terminated, considers prefixes of the topological order of increasing size until all the durations are marked as “usable” and the algorithm terminates.6.2. Piecewise-linear strategies for STPUIn the following, we present two algorithms for extracting a piecewise-linear strategy for a given weakly controllable STPU.6.2.1. Simplexes decompositionA direct approach to extract a piecewise-linear strategy consists in partitioning the region of the uncontrollable durations in a set of m-simplexes (hyper-tetrahedra in m dimensions) with m = |Y u|. In geometry, a k-simplex is the generalization of a triangle to k-dimensions. A k-simplex is a k-dimensional polytope which is the convex hull of k + 1 linearly independent (i.e. not aligned) vertexes. For example, a 2-simplex is a triangle and a 3-simplex is a tetrahedron. We consider these polyhedra because they can be used to triangulate more complex regions [20]. The following theorem states the existence of a linear strategy in any simplex contained in the uncontrollable space..= ( (cid:11)Xc, (cid:11)Y u, (cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) be an encoded weakly controllable STPU. For each |Y u|-simplex σ ( (cid:11)Y u) such that Theorem 5. Let Pσ ( (cid:11)Y u) ⊆ (cid:6)( (cid:11)Y ) there exists a valid weak linear strategy f such that ∀ (cid:11)Y u.((σ ( (cid:11)Y u) ∧ (cid:11)Xc = f ( (cid:11)Y u)) → (cid:7)( (cid:11)Xc, (cid:11)Y u)) is valid.Proof. Let m .= | (cid:11)Y u| and V be the set of m + 1 vertexes of σ ( (cid:11)Y u). By definition of simplex, σ ( (cid:11)Y u) is the convex hull of the points in V . P is weakly controllable by assumption, therefore for each v i ∈ V , there exists a point ti that extends v i in the space of (cid:11)Xc ∪ (cid:11)Y u such that ti ∈ (cid:7)( (cid:11)Xc, (cid:11)Y u). Let T be {ti|v i ∈ V }.Let f be a linear strategy A · (cid:11)Y u + (cid:11)c, such that for each controllable time point bi ∈ Xc , bi = Ai,1 y1 + · · · + Ai,m ym + ci is the hyperplane passing through all the points ti ∈ T . Such a hyperplane exists and is unique because it is the m-hyperplane 18A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Fig. 8. Plot of the running example problem (with b1 assigned to 0) with a partition of the space of uncontrollable durations. The space of uncontrol-lable durations is split in two triangles, shown at the bottom of the figure. In (a) we plot the space of the solutions, while in (b) we draw a possible piecewise-linear strategy obtained by using a linear strategy for each triangle.Algorithm 4 Simplexes Decomposition strategy extraction algorithm.1: procedure SimplexesDecomposition((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xu, (cid:11)Y u))2:3:4:5:f ← GetEmptyStrategy()for all σ ( (cid:11)Y u) ∈ GetMaximalSimplexes((cid:6)( (cid:11)Y u)) dof sub ← VertexEncoding(σ ( (cid:11)Y u ), (cid:7)( (cid:11)Xu, (cid:11)Y u))f ← AddPieceToStrategy( f , (σ ( (cid:11)Y u), f sub))return f6:7: end procedureWe now prove that fcontaining the m + 1 not-collinear [14] points ti ∈ T (points in T are not collinear as they are the results of an extension of the points in V that are not collinear because are the m + 1 vertexes of a simplex).is a strategy such that ∀ (cid:11)Y u.(σ ( (cid:11)Y u) ∧ (cid:11)Xc = f ( (cid:11)Y u)) → (cid:7)( (cid:11)Xc, (cid:11)Y u) is valid by showing that the hyperplane bi = Ai,1 y1 + · · · + Ai,m ym + ci is contained in (cid:7)( (cid:11)Xc, (cid:11)Y u) for each (cid:11)Y u |(cid:20) σ ( (cid:11)Y u). Since the hyperplane contains all the ti ∈ T , for each point k in the convex hull of V , the hyperplane computed in k is contained in (cid:7)( (cid:11)Xc, (cid:11)Y u) because of the convexity of (cid:7)( (cid:11)Xc, (cid:11)Y u). This proves the thesis because σ ( (cid:11)Y u) is the convex hull of the points in V . (cid:2)In order to exploit Theorem 5 we need to be able to split the uncontrollable space into simplexes. Doing so would allow us to split the problem of finding a piecewise-linear strategy for the whole problem in the problem of finding linear strategies for each simplex and then combine them.The uncontrollable region (cid:6)( (cid:11)Y u) is a hyper-rectangle, and the minimum number of simplexes needed to cover a hyper-rectangle is an open mathematical problem [20]. However, it is known that any hyper-rectangle in m dimensions can be split in a factorial number of simplexes (m!). For example, a rectangle can be split in 2 triangles, and a rectangular cuboid can be covered by 6 tetrahedrons.Given (cid:6)( (cid:11)Y u), we can obtain all the simplexes using the following idea. Suppose that the bounds for all the uncontrol-lable variables are [0, 1]. Then, let R be the region satisfying the sequence of inequalities y p1≤ · · · ≤ y pm where (p1, . . . , pm) is a permutation of (1, . . . , m) and m is the number of uncontrollable duration variables. It can be shown that R is a simplex and that the simplexes generated for all the permutations form a partition of the uncontrollable space [20]. In the general case, when we can have arbitrary bounds, we apply the very same idea, permuting the variables and considering the inequalities arising from considering the concrete lower/upper bounds.≤ y p2Using this approach, we have to enumerate all the permutations of the uncontrollable variables. Thus, the number of considered simplexes is factorial in the number of uncontrollable variables (i.e. |Y u |!).For each simplex it is possible to find a linear strategy separately by enforcing a hyperplane to satisfy the problem constraints in all the simplex vertexes. In Fig. 8 we depicted an example of this idea for the running example problem.Algorithm 4 shows the pseudo-code for extracting a piecewise linear strategy by enumerating all the simplexes and find-ing a linear strategy for every simplex. The computational complexity of this algorithm is factorial due to the enumeration of all the (|Y u|!) simplexes.In the pseudo-code, the function GetMaximalSimplexes enumerates a sequence of |Y u|-simplexes needed to cover the (cid:6)( (cid:11)Y u) polyhedron, while VertexEncoding returns a linear strategy suitable for the given simplex.5 We obtain the resulting piecewise-linear strategy f by adding a piece for each simplex by means of the function AddPieceToStrategy.Consider the problem in Fig. 6; the algorithm works as follows. We first consider the simplex with vertexes {(0, 1), (0, 2), (3, 1)} in the space of y1 and y2. A possible linear strategy in this simplex is f 1 = A1 · (cid:11)Y u + (cid:11)c1 as follows.5 ( (cid:11)Xc , (cid:11)Y u, σ ( (cid:11)Y u), (cid:7)( (cid:11)Xu, (cid:11)Y u)) is not a well formed encoding of an STPU, because σ ( (cid:11)Y u ) is not in the shape prescribed by Definition 5. Nevertheless, theVertexEncoding algorithm can deal with any convex uncontrollable region.A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2719Algorithm 5 Lazy piecewise-linear strategy extraction.1: procedure LazyExpansion((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u))2:3:4:5:f ←GetEmptyStrategy()η( (cid:11)Y u) ← (cid:6)( (cid:11)Y u)for all y j ∈ (cid:11)Y u doSMT.declareVar( yi , R)while SMT.solve(η( (cid:11)Y u)) doσ ( (cid:11)Y u) ← GetUncoveredSimplex(η( (cid:11)Y u))f sub ← VertexEncoding(σ ( (cid:11)Y u ), (cid:7)( (cid:11)Xc, (cid:11)Y u))o( (cid:11)Y u) ← (cid:7)( f sub( (cid:11)Y u), (cid:11)Y u)f ← AddPieceToStrategy( f , (η( (cid:11)Y u) ∧ o( (cid:11)Y u), f sub))η( (cid:11)Y u) ← η( (cid:11)Y u ) ∧ ¬o( (cid:11)Y u )6:7:8:9:10:11:return f12:13: end procedure(cid:12)(cid:13)(cid:12)(cid:13)A1 =0 013 0(cid:11)c1 =00We then consider the second maximal simplex with vertexes {(0, 2), (3, 1), (3, 2)}. A possible linear strategy in this simplex is f 2 = A2 · (cid:11)Y u + (cid:11)c2 as follows.000 −1A2 =(cid:11)c2 =02(cid:12)(cid:12)(cid:13)(cid:13)The algorithm combines such strategies in a valid piecewise-linear weak strategy f as follows.(cid:12)(cid:13)(cid:15)= f ( y1, y2).=b1b26.2.2. Lazy expansionif ( y2 ≤ − 1f 1f 2 otherwise3 y1 + 2)To overcome the complexity limitation of the previous approach we developed a second technique, called Lazy Expansion, that first selects a simplex in the uncontrollable region and finds a linear strategy in that simplex. Second, we symbolically compute the region of the uncontrollable durations that is satisfied by the computed strategy. In this way, we perform a “widening” of the portion of the uncontrollable space that can be satisfied using the computed linear strategy. This widened region is guaranteed to cover at least the simplex, but it might be larger. We then associate the computed strategy to the resulting region. Finally, we search a new simplex in the remaining part of the space of uncontrollable durations. The algorithm terminates when the space of uncontrollable durations is completely covered. The idea behind the approach is to generalize the strategy found for a particular simplex to cover a wider potion of the space of the uncontrollable durations. The algorithm lazily picks a simplex from the region of the uncontrollable durations to be covered and gets a strategy that is able to cover that particular simplex. We then generalize the applicability of the returned strategy and proceed until we completely cover the uncontrollable space. The main advantage of this algorithm with respect to the previous one is that it is not forced to enumerate all the possible simplexes, because the computed strategy once found is exploited in all the possible points of the space where it is applicable.Algorithm 5 shows the pseudo-code for extracting a piecewise linear strategy exploiting lazy expansion. The functionGetUncoveredSimplex returns any simplex σ ( (cid:11)Y u) completely contained in the uncontrollable region (cid:6)( (cid:11)Y u). At each step we compute the widening of the simplex o( (cid:11)Y u), that is the region in which the computed linear strategy f sub is applicable. In order to symbolically obtain this region, we substitute the LRA encoding of the strategy f sub in the free constraints (cid:7)( (cid:11)Xc, (cid:11)Y u). In this way, each controllable time point variable bi ∈ (cid:11)Xc is replaced by the linear term that computes it according to f sub, and we are left with a formula defined over (cid:11)Y u . Each model of such formula, is a point in the uncontrollable region for which the application of f sub fulfills the free constraints of the problem. We use this procedure to create “bigger” pieces and reduce the number of iterations of the algorithm.In general, this algorithm is not guaranteed to terminate. In fact, termination can be assured with the following two re-quirements. First, each region σ ( (cid:11)Y u) covers a non-empty volume of the space of the uncontrollable durations. This is needed for progression: the piece of strategy computed at each step is guaranteed to cover at least the simplex that originated it (at each step σ ( (cid:11)Y u) |(cid:20)LRA o( (cid:11)Y u)). The second requirement is to have progression, that is we disallow infinite decomposition chains for finite regions. If we avoid empty regions and infinite subdivisions of finite regions, we will eventually get to the empty region, and thus to unsatisfiability and termination.In our implementation, we do not guarantee termination. However, the algorithm correctly terminated in all our ex-periments and in many cases it performed much faster than the SimplexesDecomposition algorithm. One possibility to guarantee the termination would be to hybridize this algorithm with the SimplexesDecomposition approach by bounding the number of loops of the LazyExpansion procedure or to take a portfolio approach.One key issue for the efficiency of this approach resides in finding good simplexes to cover a (possibly non-convex) region η( (cid:11)Y u). Defining what a “good” simplex is for the algorithm performance is a non-trivial task because the aim is to terminate with a minimum number of iterations, and thus to obtain a decomposition of (cid:6)( (cid:11)Y u ) in a minimal set of oi( (cid:11)Y u)regions.20A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Algorithm 6 Skin-based strategy extraction for DTPU.1: procedure SkinCrawler((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u))2:3:4:f ← GetEmptyStrategy()for all (o( (cid:11)Y u), f sub) ∈ GetFaceStrategies((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u)) dof ←AddPieceToStrategy( f , (o( (cid:11)Y u ), f sub))return f5:6: end procedure6.3. Linear strategies for DTPUWe now consider the DTPU problem class and we provide algorithms for strategy synthesis starting from the linear case.A way of computing the elements of matrix A and vector (cid:11)c for a linear strategy is an encoding of the constraints in the theory of Nonlinear Real Arithmetic over Polynomials (N RA). In fact, we can compactly express the properties of each entry of A and (cid:11)c by imposing constraints on polynomials. Eq. (10) is an encoding into N RA for extracting a linear strategy for any TPU problem in a single check.∃ A1,1, . . . , A1,m, c1,. . .An,1, . . . , An,m, cn.∀ (cid:11)Y u.(cid:16)(cid:17)(cid:6)( (cid:11)Y u) → (cid:7)[ A · (cid:11)Y u + (cid:11)c/ (cid:11)Xc]( (cid:11)Y u)(10)The idea is to let the solver search for the Ai, j and ci coefficients of the linear combination of (cid:11)Y u that represent the set of hyper-planes that are strategies for each bi ∈ (cid:11)Xc . If the solver reports unsatisfiable, it means that no linear strategy exists for the given problem. This approach directly follows from the definition of linear strategy and is applicable to the entire spectrum of temporal problems with uncertainty because no assumption on the convexity of the search space is made.As an example we show the encoding of Eq. (10) applied to the TPU in Fig. 6, to remark the fact that no linear strategy exists for this problem.∃ A1,1, A1,2, A2,1, A2,2, c1, c2.∀ y1, y2.(( y1 ≥ 0) ∧ ( y1 ≤ 3) ∧ ( y2 ≥ 1) ∧ ( y2 ≤ 2)) →((( A2,1 y1 + A2,2 y2 + c2) − ( A1,1 y1 + A1,2 y2 + c1) ≥ 0) ∧((( A1,1 y1 + A1,2 y2 + c1) + y1) − ( A2,1 y1 + A2,2 y2 + c2) ≥ 0) ∧((( A1,1 y1 + A1,2 y2 + c1) + y1) − (( A2,1 y1 + A2,2 y2 + c2) + y2) ≤ 1) ∧((( A2,1 y1 + A2,2 y2 + c2) + y2) − ( A1,1 y1 + A1,2 y2 + c1) ≤ 2))The running example problem is an STPU, but the approach presented here is more general. In fact, given a procedure that is able to decide N RA formulae with arbitrary disjunctions we can deal with DTPU as well. For example, the Cylindrical Algebraic Decomposition (CAD) procedure [12] can deal with this kind of formulae.6.4. Piecewise-linear strategies for DTPUIn this section we analyze the synthesis of a piecewise-linear strategy for a DTPU. When dealing with a DTPU, the con-vexity assumptions holding for the STPU case are not valid anymore. We present two algorithms for the strategy synthesis in the DTPU problem class. The “skin crawler” method searches a strategy by considering the faces of the DTPU solution space considered as a polyhedron. The “convex region enumerator” approach, instead, decomposes the DTPU in a number of convex regions and applies the techniques for the STPU problem class on each of them.6.4.1. Skin crawlerAn intuition that can be exploited to synthesize a weak strategy for the DTPU problem class is obtained from the proof of Theorem 3. The idea is to iterate on the faces of (cid:7)( (cid:11)Xc, (cid:11)Y u) and to project each of them in the space of (cid:11)Y u until the entire (cid:6)( (cid:11)Y u) region is covered by the projections. Such an iteration can be done efficiently by exploiting the optimization features of many modern SMT solvers.The top-level procedure, shown in Algorithm 6, iterates over the faces and extracts a linear strategy for each face, accumulating this result in a piecewise-linear strategy.The face extraction procedure (Algorithm 7) starts by extracting all the equalities from the free constraints. Since the free constraints are made of non-strict inequalities, we aim at extracting the skin of the free constraints by considering the equality a − b = k derived from a − b <= k. The algorithm uses an optimization procedure that maximizes the num-ber of equalities satisfied at each step represented by the variable satEqualities. In this way, considering the conjunction of A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2721Algorithm 7 Generates all the faces of (cid:7)( (cid:11)Xc, (cid:11)Y u) and converts them in a linear system of equations.1: procedure GetFaceStrategies((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc, (cid:11)Y u))2:3:for all xi ∈ (cid:11)Xc ∪ (cid:11)Y u doSMT.declareVar(xi , R)χ ( (cid:11)Xc , (cid:11)Y u) ← (cid:7)( (cid:11)Xc, (cid:11)Y u) ∧ (cid:6)( (cid:11)Y u)satEqualities ← 0for all eqi ( (cid:11)Xc, (cid:11)Y u) ∈ Equalities((cid:7)( (cid:11)Xc, (cid:11)Y u)) doSMT.declareVar(eqvi , R)χ ( (cid:11)Xc , (cid:11)Y u) ← χ ( (cid:11)Xc , (cid:11)Y u) ∧ (eqi ( (cid:11)Xc , (cid:11)Y u) → (eqviχ ( (cid:11)Xc , (cid:11)Y u) ← χ ( (cid:11)Xc , (cid:11)Y u) ∧ (eqi ( (cid:11)Xc , (cid:11)Y u) ∨ (eqvisatEqualities ← satEqualities + eqvi= 1))= 0))faces ← ∅while SMT.solveMaximizing(χ ( (cid:11)Xc, (cid:11)Y u), satEqualities) = SAT dosystem ← {eqi ( (cid:11)Xc , (cid:11)Y u) ∈ Equalities((cid:7)( (cid:11)Xc , (cid:11)Y u))|μ |(cid:20) eqi ( (cid:11)Xc , (cid:11)Y u)}(M(cid:11)t = (cid:11)d) ← ConvertToLinearSystem(system)bases ← GetBases(M(cid:11)t = 0)if |bases| ≥ | (cid:11)Y u| then( A, (cid:11)c) ← ToLinearStrategy(M)o( (cid:11)Y ) ← (cid:7)( A · (cid:11)Y u + (cid:11)c, (cid:11)Y u)faces ← faces ∪ {(o( (cid:11)Y ), A · (cid:11)Y u + (cid:11)c)}(cid:4)χ ( (cid:11)Xc , (cid:11)Y u) ← χ ( (cid:11)Xc , (cid:11)Y u) ∧ (eqi ( (cid:11)Xc , (cid:11)Y u )∈system¬eqi ( (cid:11)Xc, (cid:11)Y u))4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:return faces22: end procedureall the satisfied equalities, we first explore the vertexes, then the edges and finally the faces. The conjunction of equali-ties is actually a system of linear equalities representing a face. In order to extract a strategy from a face, we transform a conjunction of linear equalities into matrix form. As an optimization we discard systems that have dimension lower than the number of uncontrollable durations. This prevents the creation of pieces representing regions having null vol-ume.The algorithm termination depends only on the termination of the GetFaceStrategies procedure. The procedure is guar-anteed to terminate because at each step we add a new clause to χ ( (cid:11)Xc, (cid:11)Y u) that forces at least one equality that was positive in the found model to be false. Therefore we can have at most an exponential number of cycles with respect to the number of equalities in Equalities((cid:7)( (cid:11)Xc, (cid:11)Y u)).6.4.2. Convex region enumeratorWe can exploit the possibility of generating a strategy for the convex case by enumerating the convex regions in the space of free constraints.This idea requires the possibility to deal with a possibly non-convex (cid:6)( (cid:11)Y u) because the projection of a convex polyhedron space intersected with the non-convex (cid:6)( (cid:11)Y u) can generate non-convex (and non-rectangular) regions. The LazyExpansionalgorithm is able to deal with such constraints, because no constraint is imposed on the shape of (cid:6)( (cid:11)Y u ) during the algorithm execution.In this case, we need to enumerate a set of convex formulae {μi( (cid:11)Xc, (cid:11)Y u)|i ∈ [1, I]} such that i=1 μi ⇔ (cid:7)( (cid:11)Xc, (cid:11)Y u). Such formulae can be obtained by computing the Disjunctive Normal Form (DNF) of the formula (cid:7)( (cid:11)Xc , (cid:11)Y u). From the practical point of view, each disjunct is either an atom of the original formula or its negation. The DNF can be efficiently computed in the SMT framework using an incremental mechanism.(cid:4)IAlgorithm 8 shows the pseudo-code for the Convex Region Enumerator algorithm for the weak strategy synthesis of DTPU problems.The algorithm works as follows. First it selects any consistent temporal evolution by solving the SMT problem of the conjunction of the contingent and free constraints. Given the consistent model, the algorithm extracts the free constraints atoms that are satisfied and the atoms that are not fulfilled. The region obtained by conjoining all those atoms is a convex (non-necessarily closed) polyhedron. We compute the projection of such a polyhedron in the region of the uncontrollable durations and we compute a strategy for this quasi-STPU problem.6 The obtained strategy is applied in the covered region that is removed from the problem together with the polyhedron. This ensures the algorithm termination, because at each step we remove a model of the Boolean abstraction from the ρ( (cid:11)Xc , (cid:11)Y u) formula.In the pseudo-code, the function Project performs a quantifier elimination in order to compute the projection of a given polyhedron onto the given space and is used to compute the uncontrollable region that is covered by the selected polyhedron.Termination is not guaranteed, because we internally use the LazyExpansion algorithm that is incomplete; however, also in this case, the algorithm terminated in all the benchmarks.6 The problem is not a proper STPU because the projection can be non-rectangular and the constraints can contain strict inequalities. However theLazyExpansion algorithm is able to deal even with such degenerated problems.22A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Algorithm 8 Convex Region Enumeration strategy extraction for DTPU.1: procedure ConvexRegionEnumerator((cid:6)( (cid:11)Y u), (cid:7)( (cid:11)Xc , (cid:11)Y u))2:3:for all xi ∈ (cid:11)Xc ∪ (cid:11)Y u doSMT.declareVar(xi , R)f ← GetEmptyStrategy()ρ( (cid:11)Xc, (cid:11)Y u) ← (cid:7)( (cid:11)Xc, (cid:11)Y u) ∧ (cid:6)( (cid:11)Y u)while SMT.solve(ρ( (cid:11)Xc, (cid:11)Y u)) = SAT doμ ← SMT.GetModel()δ( (cid:11)Xc, (cid:11)Y u) ← (cid:3)for all α( (cid:11)Xc , (cid:11)Y u) ∈ Atoms((cid:7)( (cid:11)Xcif μ |(cid:20) α( (cid:11)Xc , (cid:11)Y u) then(cid:11)Y u)) doδ( (cid:11)Xc, (cid:11)Y u) ← δ( (cid:11)Xc, (cid:11)Y u) ∧ α( (cid:11)Xc , (cid:11)Y u)elseδ( (cid:11)Xc, (cid:11)Y u) ← δ( (cid:11)Xc, (cid:11)Y u) ∧ ¬(α( (cid:11)Xc , (cid:11)Y u))o( (cid:11)Y u ) ← Project(δ( (cid:11)Xc , (cid:11)Y u), (cid:11)Y u )f sub ← LazyExpansion(o( (cid:11)Y u), δ( (cid:11)Xc, (cid:11)Y u))f ← AddPieceToStrategy( f , (o( (cid:11)Y u ), f sub))ρ( (cid:11)Xc, (cid:11)Y u) ← ρ( (cid:11)Xc , (cid:11)Y u) ∧ ¬δ( (cid:11)Xc, (cid:11)Y u) ∧ ¬o( (cid:11)Y u )4:5:6:7:8:9:10:11:12:13:14:15:16:17:return f18:19: end procedure7. Experimental evaluationIn order to empirically test the effectiveness of the proposed approaches, we implemented a tool for deciding weak controllability and synthesizing weak strategies for a TPU. Our tool is implemented in Python. It reads a TPU problem, and applies to it the portfolio of encodings and algorithms we presented in this paper. The tool can synthesize explicit strategies as C++ functions (taking in input a situation), that can be compiled and linked in any program. We used the Z3 [17] SMT solver for the weak controllability decision problem; we rely on the Python API provided by the MathSAT5 [7] SMT solver for all the strategy-synthesis techniques.We tested the tool on a set of benchmarks described in detail below. We remark that, as far as our knowledge is concerned, there are no competitor tools or solvers able to deal with the weak controllability decision problem, nor with the synthesis of a weak strategy. Thus, in the experimental evaluation, we do not compare with any other tool or approach. All the experiments have been performed on a Scientific-Linux server equipped with two quad-core Xeon processors @ 2.70 GHz. We used a memory limit of 2 GB, a time-out of 300 seconds and we used sequential, single-core computation only. The tool, together with all the benchmarks and the results of the evaluation, can be downloaded from https :/ /es .fbk.eu /people /roveri /tests /aij-weakcontr.The randomly-generated benchmarks were obtained by modifying the generator of temporal problems presented in [2]by introducing uncertainty in the problem: each constraint introduced by the consistency problem generator is turned into a contingent constraint with a given probability, and its destination node is considered as uncontrollable. We used random instance generators because they are typically used in the literature (e.g. [2]), and because they can be easily scaled to stress the solvers.We tested the decision problem encoding over a set of 2442 randomly generated DTPU, TCSPU and STPU instances, with a number of time points ranging from 6 to 20000. For the evaluation of the strategy-extraction techniques, we used 1354weakly controllable STPU benchmarks and 2112 weakly controllable DTPU instances ranging from 4 to 50 time points.7.1. Decision problemThe results of checking the decision problem over the set of TPUs are plotted in Fig. 9. The cactus plot (a) reports, in the horizontal axis, the number of solved instances and, on the vertical axis, the cumulative time, in logarithmic scale, taken by the SMT solver for each encoding. For example, the Assumption-Extraction encoding takes about 10000 seconds to solve the easiest 750 instances. We compared the formulation of Proposition 1 called Direct with the Inverted andAssumption-Extraction encodings.The figure highlights the fact that Z3 performs much better when the Assumption-Extraction encoding of the problem is considered: in fact, this approach is able to solve, in less time, a higher number of instances with respect to the Invertedand Direct encodings. The Direct encoding performs almost identically to the Inverted one. This behavior is due to the fact that the Inverted encoding has the same shape as the Direct one. The only difference is the negation of the Directencoding, that does not affect the solver performance.In Figs. 9(b) and 9(c) we reported the scatter plots comparing the performances of the Assumption-Extraction with the Inverted encodings, distinguishing between weakly controllable and non-weakly controllable instances. We note that, in the weakly controllable case, the Assumption-Extraction encoding outperforms the Inverted encoding in most of the benchmarks. For non-weakly controllable instances, the two encodings perform similarly in terms of speed. However, theInverted encoding is able to solve 86 instances that are unsolvable by the Assumption-Extraction encoding due to the imposed memory limit.A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2723Fig. 9. Results for the decision problem encodings solved using the Z3 SMT solver. (a) reports the cumulative time (in logarithmic scale) cactus plot; (b) and (c) show the scatter plots of Inverted vs. Assumption-Extraction encodings divided in weakly controllable (b), and not weakly controllable (c). The TO line denotes the instances that reached the time out, while MO indicates instances that hit the memory limit.7.2. STPU strategy synthesisThe results for the evaluation of the strategy-extraction techniques for the 1354 STPU benchmarks are reported in Fig. 10(a). The plot considers only those benchmarks that admit a linear strategy, and compares the four different ap-proaches. The plot clearly shows that for linear strategies, the IncrementalWeakening approach outperforms all the others. The SimplexesDecomposition method quickly explodes due to the factorial complexity of simplexes enumeration. Although the techniques for piecewise-linear strategy extraction are penalized as they are strictly more general than the others, the plot shows that LazyExpansion approach is much faster than the SimplexesDecomposition. In Fig. 10(b) we plotted the number of “pieces” of the strategies for the LazyExpansion and SimplexesDecomposition methods. The plot clearly shows that, although for small problems the LazyExpansion approach generates additional, unneeded “pieces”, when the problem 24A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Fig. 10. Results for STPU linear strategy extraction problem. In (a) we plotted the cumulative cactus plot of the strategy extraction time for the different algorithms proposed in this paper, while in (b) we compared the number of pieces for piecewise-linear algorithms expressed as the number of split regions.Fig. 11. Results for strategy extraction problem in the DTPU problem class. In (a) we plotted the cumulative cactus plot of the solving time for theConvexRegionEnumerator and the SkinCrawler algorithms while (b) is a scatter plot of the data.size increases the number of “pieces” identified by the LazyExpansion method is much smaller than for the SimplexesDe-composition one. In general, the LazyExpansion approach has a huge gain in performances and in strategy size.7.3. DTPU strategy synthesisIn Fig. 11 we report the results on the DTPU problem class. The plots clearly show that the ConvexRegionEnumeratoralgorithm performs better than the SkinCrawler one. This is because of two main reasons. First, the SkinCrawler approach solves a costly minimization problem and has to traverse all the faces of the space of free constraints while the ConvexRe-gionEnumerator algorithm applies the cheap LazyExpansion approach to each convex region that is generated by a single call to the SMT solver. Second, the linear strategy generated by the LazyExpansion approach is generalized and applied A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2725Fig. 12. Results for strategy execution: for each problem, the generated strategy is executed on 1000 randomly generated situations. The plot considers all the STPU and DTPU randomly generated problems. The cactus plot shows the number of solved instances on the x axis and the accumulated time to solve them in the y axis.wherever possible, therefore if the problem allows for a linear strategy the ConvexRegionEnumerator algorithm is able to quickly synthesize it, while the SkinCrawler has to enumerate enough faces to cover the entire uncontrollable space.There is an interesting peak on the rightmost part of the ConvexRegionEnumerator curve in the plot. This is due to a particular instance that is solved in 287.28 seconds generating a strategy with 3750 pieces (thus using the same number of iterations to terminate). This is one example in which the splitting done by the LazyExpansion approach gets lost in splitting the uncontrollable space in simplexes.Finally, we did not experimented the effectiveness of the N RA encoding for two reasons. First, since a linear strategy is not guaranteed to exist for STPUs, it is also not guaranteed to exist in DTPUs. Second, the N RA approach needs a solver supporting the quantification over the real polynomial arithmetic (the full polynomial N RA theory), and to the best of our knowledge, no SMT solver fully supports this theory due to its complexity, even if the problem is decidable [12].7.4. Strategy executionIn this paper we proposed a number of approaches to synthesize weak strategies arguing that their execution is practi-cally more efficient than solving the individual problems without uncertainty obtained by projecting the uncertainty away. In this section we provide experimental evidence supporting this claim on a number of STPU and DTPU instances.We conducted the experiment as follows. For each TPU, we randomly generated 1000 situations, represented as complete assignments for the uncontrollable durations. We implemented the Implicit-SMT and Implicit-SMT-Incremental general strategies described in Section 5.1 using the MathSAT5 SMT solver. Other TP solvers can, in principle, be employed to create implicit strategies, but SMT solvers showed to be effective in dealing with consistency problems [11]. For this reason, and for the lack of publicly available implemented solvers, we limited our experimentation to the SMT based techniques described in Section 5.1.In addition, we considered three ways to compile in machine code the problem-specific strategies generated by the algo-rithms presented in this paper. We translated the linear or piecewise-linear strategy synthesized by any of our algorithms into a C++ code. The translation for linear strategies is straight-forward: we create a function that takes in input a numeric value for each uncontrollable duration and we compute the output of the strategy by solving the matrix multiplication as described in Section 5.2. Given a piecewise-linear strategy, we translate it using a sequence of if statements, one for each piece. The condition of each if is the transposition in C++ syntax of the piece condition. Each conditional statement returns the value computed by the translation of the linear strategy relative to the particular piece. We used three different datatypes to represent numeric values and perform the arithmetic operations. In particular, we used the (finite-precision) C++ float and double and the GNU-GMP library for arbitrary precision arithmetic.7 The float and double datatypes are a finite-precision representation of rational numbers. As such, they suffer from both numeric stability and rounding problems that may, in principle, cause unsoundness in the strategy output. On the other hand, GNU-GMP is the same li-brary employed by the MathSAT5 SMT solver and does not suffer from any kind of numeric stability or rounding problems.7 The GNU Multiple Precision Arithmetic Library https :/ /gmplib .org/.26A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–27Fig. 12 shows the results of the comparison: in our experiments the explicit strategies outperform projection-based implicit strategies. Implicit-SMT-Incremental performs better than Implicit-SMT, thanks to the incrementality feature of the SMT solver, but the explicit strategies bring a significant speedup on all the instances. Arbitrary-precision arithmetic (that fairly compares with the SMT precision) outperforms projection-based techniques by two orders of magnitude. The compiled strategies with native C++ datatypes perform even better, but the numerical stability problems can, in principle, lead to unsound results. We checked the output of each technique on each situation in order to assess the soundness, but all the results were correct. Nevertheless, studying under which condition we can guarantee that such finite-precision implementations are correct is subject of future work. We highlight that the compilations using native C++ datatypes can be translated to Boolean circuits, and open for the possibility to create very efficient hardware implementations of these strategies.8. Related workThe literature in temporal problems is vast. Starting from the seminal paper of Dechter [18] describing STP and TCSP, many authors worked in the field of temporal reasoning without uncertainty [2,36]. Armando et al. [2] were the first proposing the use of SMT in the field of temporal problems tackling the DTP problem class. This work focuses on temporal problems without uncertainty, and is thus limited to checking the consistency of a given TP.Fargier and Vidal introduced the concept of STPU and described the three controllability levels [38]. This work has been extended for TCSPU and DTPU in [32,37].Concerning strong controllability, this work already contained a polynomial algorithm for schedule synthesis of STPU. For TCSPU and DTPU, the strong controllability problem has been studied, from a theoretical point of view, by Peintner et al. in [32]; a number of techniques that leverage SMT solvers to obtain a practical solver are presented in our previous work [11].For the decision problem of weak controllability, in [38] a basic algorithm for the STPU class is presented. In [37], Venable et al. approached the problem of deciding weak controllability of DTPU using an explicit algorithm that enumerates the STPU components of a DTPU. In this work we also tackle the DTPU class, but we exploit symbolic techniques to avoid this explicit enumeration, delegating it to the SMT solver, that can exploit advanced mitigation techniques, such as variable selection heuristics and conflict learning. In addition, both [38] and [37] take a purely theoretical point of view of the problem, while here we formalize and encode the weak controllability decision problem in the SMT framework to obtain practical experimental results.The only work in the literature for the strategy extraction problem for weak controllability is our previous work [10]. In [10] we presented the algorithms for linear and piecewise-linear strategy extraction for the STPU problem class. In this paper, we cover the more general DTPU problem class, considering the strategy synthesis problem in presence of disjunctions. We provide a more detailed theory discussion, we add the proof of existence of piecewise linear strategies for any weakly controllable TPU, and proofs and explanations that were not included in [10]. Also, the experimental evaluation has been extended and clarified.There exists another form of controllability for TPUs, namely dynamic controllability. The key difference is that in the case of dynamic controllability the strategy is not allowed to observe the entire situation, but each decision can only depend on past events. The problem of dynamic controllability for STPU is a widely studied problem [29,28,27,21,22], in fact many algorithms have been devised for deciding the dynamic controllability of a STPU. For the disjunctive problem classes, in [37], Venable et al. present an algorithm for deciding dynamic controllability for TCSPU, while in [8] we, Hunsberger and Poseanto present a decision procedure for DTPUs based on a reduction of the dynamic controllability problem to the reachability problem in a Timed Game Automaton. Also in the field of dynamic controllability, strategy synthesis is a relevant topic: many authors presented implicit strategies for the runtime scheduling of time points [27,22] for STPU. Those strategies require on-line reasoning and are based on generating networks that can be dispatched by a runtime algorithm using constraint propagation techniques. Recently, we started a research line aiming at synthesizing explicit strategies for dynamic controllability in the STPU problem class [9] and in the DTPU problem class [8]. In these works, we present encodings of the dynamic controllability problem into reachability games in Timed Gamed Automata for which constructive solution techniques exist. The strategies generated can be converted in implicit strategies for the TPU that are similar to the one we synthesize in this paper, for weak controllability.9. Conclusions and future workIn this paper we presented the first comprehensive approach to the problem of weak controllability for TPUs. We cover the problem in its full generality, in the case of TPUs with disjunctions. We work in a logic-based framework, that relies on SMT techniques to achieve an efficient implementation. We make the following contributions: we provide the first effective procedure for deciding the weak controllability of DTPU; we investigate the problem of repeated execution; we propose various constructive forms of strategy extraction. The experimental evaluation shows the feasibility of the method, and demonstrates dramatic speed ups on explicit over implicit strategy execution.In the future, we will investigate the following research lines. The “incremental weakening” approach for linear strategy extraction and the “lazy decomposition” approach for piecewise-linear strategy extraction are strongly influenced by the A. Cimatti et al. / Artificial Intelligence 224 (2015) 1–2727selection heuristics. We will investigate the possibility of using topological information for the generation of effective subsets of (cid:11)y in “incremental weakening”, and the use of extremal simplexes in the “lazy decomposition” approach. We plan to study the applicability to the strategy construction problem of SMT proof-extraction techniques: the capability of modern solvers to extract proofs of unsatisfiability could provide a way to extract the strategy while proving weak controllability. In addition, determining under which conditions a finite state representation is guaranteed to be applicable, can open the way to more efficient and even hardware-implemented strategies. Finally, we believe that the techniques we described can pave the way to efficient explicit strategies for dynamic controllability, where strategies are required to rely only on the observation of events that have already occurred. In particular, we plan to combine the approaches to strong and weak controllability, to explore the continuum in between.References[1] James F. Allen, Maintaining knowledge about temporal intervals, Commun. ACM 26 (11) (1983) 832–843.[2] Alessandro Armando, Claudio Castellini, Enrico Giunchiglia, SAT-based procedures for temporal reasoning, in: ECP, 1999, pp. 97–108.[3] David Avis, Komei Fukuda, A pivoting algorithm for convex hulls and vertex enumeration of arrangements and polyhedra, Discrete Comput. Geom. [4] Clark W. Barrett, Roberto Sebastiani, Sanjit A. Seshia, Cesare Tinelli, Satisfiability modulo theories, in: Handbook of Satisfiability, IOS Press, 2009, 8 (1) (1992) 295–313.pp. 825–885.[5] Marco Bozzano, Roberto Bruttomesso, Alessandro Cimatti, Tommi Junttila, Silvio Ranise, Peter Van Rossum, Roberto Sebastiani, Efficient satisfiability modulo theories via delayed theory combination, in: CAV, 2005, pp. 335–349.[6] Roberto Bruttomesso, Edgar Pek, Natasha Sharygina, Aliaksei Tsitovich, The OpenSMT solver, in: TACAS, 2010, pp. 150–153.[7] Alessandro Cimatti, Alberto Griggio, Bastiaan Joost Schaafsma, Roberto Sebastiani, The MathSAT5 SMT solver, in: TACAS, 2013, pp. 93–107.[8] Alessandro Cimatti, Luke Hunsberger, Andrea Micheli, Roberto Posenato, Marco Roveri, Sound-and-complete algorithms for checking the dynamic controllability of temporal networks with uncertainty, disjunction and observation, in: TIME, 2014.[9] Alessandro Cimatti, Luke Hunsberger, Andrea Micheli, Marco Roveri, Using timed game automata to synthesize execution strategies for simple temporal networks with uncertainty, in: AAAI, 2014, pp. 2242–2249.[10] Alessandro Cimatti, Andrea Micheli, Marco Roveri, Solving temporal problems using SMT: weak controllability, in: AAAI, 2012.[11] Alessandro Cimatti, Andrea Micheli, Marco Roveri, Solving strong controllability of temporal problems with uncertainty using SMT, Constraints (2014).[12] George E. Collins, Hoon Hong, Partial cylindrical algebraic decomposition for quantifier elimination, J. Symb. Comput. 12 (3) (1991) 299–328.[13] Scott Cotton, Eugene Asarin, Oded Maler, Peter Niebert, Some progress in satisfiability checking for difference logic, in: FORMATS/FTRTFT, 2004, pp. 263–276.[14] H.S.M. Coxeter, Samuel L. Greitzer, Collinearity and concurrence, in: Geometry Revisited, Mathematical Association of America Textbooks, 1967, pp. 51–79.[15] Martin Davis, George Logemann, Donald W. Loveland, A machine program for theorem-proving, Commun. ACM 5 (7) (1962) 394–397.[16] Leonardo de Moura, Nikolaj Bjørner, Model-based theory combination, Electron. Notes Theor. Comput. Sci. 198 (2) (2008) 37–49.[17] Leonardo de Moura, Nikolaj Bjørner, Z3: an efficient SMT solver, in: TACAS, 2008, pp. 337–340.[18] Rina Dechter, Itay Meiri, Judea Pearl, Temporal constraint networks, Artif. Intell. 49 (1–3) (1991) 61–95.[19] Bruno Dutertre, Leonardo de Moura, The Yices SMT solver, Tool paper at http://yices.csl.sri.com/tool-paper.pdf, 2006.[20] Robert B. Hughes, Michael R. Anderson, Simplexity of the cube, Discrete Math. 158 (1–3) (1996) 99–150.[21] Luke Hunsberger, Fixing the semantics for dynamic controllability and providing a more practical characterization of dynamic execution strategies, in: TIME, 2009, pp. 155–162.[22] Luke Hunsberger, A fast incremental algorithm for managing the execution of dynamically controllable temporal networks, in: TIME, 2010, pp. 121–128.[23] Hyondeuk Kim, Fabio Somenzi, HoonSang Jin, Efficient Term-ITE conversion for satisfiability modulo theories, in: SAT, 2009, pp. 195–208.[24] S.C. Kleene, Mathematical Logic, J. Wiley & Sons, 1967.[25] Rüdiger Loos, Volker Weispfenning, Applying linear quantifier elimination, Comput. J. 36 (5) (1993) 450–462.[26] David Monniaux, A quantifier elimination algorithm for linear real arithmetic, in: LPAR, 2008, pp. 243–257.[27] Paul Morris, A structural characterization of temporal dynamic controllability, in: CP, 2006, pp. 375–389.[28] Paul Morris, Nicola Muscettola, Temporal dynamic controllability revisited, in: AAAI, 2005, pp. 1193–1198.[29] Paul Morris, Nicola Muscettola, Thierry Vidal, Dynamic control of plans with temporal uncertainty, in: IJCAI, 2001, pp. 494–502.[30] Matthew W. Moskewicz, Conor F. Madigan, Ying Zhao, Lintao Zhang, Sharad Malik Chaff, Engineering an efficient SAT solver, in: DAC, 2001, pp. 530–535.[31] Greg Nelson, Derek C. Oppen, Simplification by cooperating decision procedures, ACM Trans. Program. Lang. Syst. 1 (2) (1979) 245–257.[32] Bart Peintner, Kristen B. Venable, Neil Yorke-Smith, Strong controllability of disjunctive temporal problems with uncertainty, in: CP, 2007, pp. 856–863.[33] Alexander Schrijver, Theory of Linear and Integer Programming, J. Wiley & Sons, 1998.[34] Roberto Sebastiani, Lazy satisfiability modulo theories, J. Satisf. Boolean Model. Comput. 3 (3–4) (2007) 141–224.[35] Roberto Sebastiani, Silvia Tomasi, Optimization in SMT with LA(Q) cost functions, in: IJCAR, 2012, pp. 484–498.[36] Ioannis Tsamardinos, Martha E. Pollack, Efficient solution techniques for disjunctive temporal reasoning problems, Artif. Intell. 151 (1–2) (2003) 43–89.[37] Kristen B. Venable, Michele Volpato, Bart Peintner, Neil Yorke-Smith, Weak and dynamic controllability of temporal problems with disjunctions and [38] Thierry Vidal, Hélène Fargier, Handling contingency in temporal constraint networks: from consistency to controllabilities, J. Exp. Theor. Artif. Intell. uncertainty, in: COPLAS, 2010.11 (1) (1999) 23–45.