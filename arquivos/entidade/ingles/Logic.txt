Artificial Intelligence 174 (2010) 1093–1141Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintLogic-based ontology comparison and module extraction,with an application to DL-LiteRoman Kontchakov a,∗, Frank Wolter b, Michael Zakharyaschev aa Department of Computer Science and Information Systems, Birkbeck College London, UKb Department of Computer Science, University of Liverpool, UKa r t i c l ei n f oa b s t r a c tArticle history:Received 31 July 2009Received in revised form 30 April 2010Accepted 17 June 2010Available online 23 June 2010Keywords:Description logicOntologyModule extractionEntailmentComputational complexityUniform interpolationForgettingWe develop a formalframework for comparing different versions of ontologies, andapply it to ontologies formulated in terms of DL-Lite, a family of ‘lightweight’ descriptionlogics designed for data-intensive applications. The main feature of our approach is thatwe take into account the vocabulary (= signature) with respect to which one wantsto compare ontologies. Five variants of difference and inseparability relations betweenontologies are introduced and their respective applications for ontology developmentand maintenance discussed. These variants are obtained by generalising the notion ofconservative extension from mathematical logic and by distinguishing between differencesthat can be observed among concept inclusions, answers to queries over ABoxes, by takinginto account additional context ontologies, and by considering a model-theoretic, language-independent notion of difference. We compare these variants, study their meta-properties,determine the computational complexity of the corresponding reasoning tasks, and presentdecision algorithms. Moreover, we show that checking inseparability can be automatedby means of encoding into QBF satisfiability and using off-the-shelf general purpose QBFsolvers.Inseparability relations between ontologies are then used to develop a formal frameworkfor (minimal) module extraction. We demonstrate that different types of minimal modulesinduced by these inseparability relations can be automatically extracted from real-worldmedium-size DL-Lite ontologies by composing the known tractable syntactic locality-basedmodule extraction algorithm with our non-tractable extraction algorithms and using themulti-engine QBF solver aqme. Finally, we explore the relationship between uniforminterpolation (or forgetting) and inseparability.© 2010 Elsevier B.V. All rights reserved.1. IntroductionIn computer science, ontologies are used to provide a common vocabulary (or, in logic parlance, signature) for a domainof interest, together with a description of certain relationships between terms built from the vocabulary. Ontology languagesbased on description logics represent ontologies as ‘TBoxes’ (terminological boxes) containing inclusions between complexconcepts over the vocabulary [2]. An increasingly important application of ontologies is management of large amounts ofdata, where ontologies are used to provide flexible and efficient access to repositories consisting of data sets of instances ofconcepts and relations. In description logics, such repositories are typically modelled as ‘ABoxes’ (assertion boxes) [2].* Corresponding author.E-mail addresses: roman@dcs.bbk.ac.uk (R. Kontchakov), frank@csc.liv.ac.uk (F. Wolter), michael@dcs.bbk.ac.uk (M. Zakharyaschev).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.06.0031094R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Developing and maintaining ontologies for this and other purposes is a rather difficult task. When using description logics(including the description logic based dialects of the Web Ontology Language OWL1), the ontology designer is supported byefficient reasoning tools for classification, instance checking and a variety of other reasoning tasks. However, this support isgenerally recognised to be insufficient when ontologies are developed not as ‘monolithic entities’ but by means of importing,merging, combining, refining and extending already existing ontologies. In all those cases, reasoning support for analysingthe impact of the respective operation on the ontology would be extremely useful. Typical examples of such ‘unorthodox’reasoning services include the following:Comparing versions of ontologies. The standard syntactic diff utility is an indispensable tool for comparing differentversions of text files, and it would be very helpful to have a similar versioning tool for ontologies. However,a purely syntactic operation of computing the difference between ontologies is of little value [3] because ourconcern now is not the syntactic form of the ontologies, but their differing logical consequences. Moreover, insteadof comparing arbitrary logical consequences, it is more useful and informative to compare logical consequencesover the common vocabulary Σ of the versions, or even such consequences regarding a certain subject mattercorresponding to some subvocabulary of Σ . Thus, the reasoning service we need in this case should be able tocompare the logical consequences of different versions of ontologies over some vocabulary Σ .Ontology refinement. When refining an ontology by adding new axioms, one usually wants to preserve the relationshipsbetween terms of a certain part Σ of its vocabulary. The reasoning service required in such a case is to checkwhether the refined ontology has precisely the same logical consequences over Σ as the original one.Ontology re-use. When importing an ontology, one wants to use its vocabulary Σ as originally defined. However, relation-ships between terms over Σ may change due to interaction with some axioms in the importing ontology. So againwe need a reasoning service capable of checking whether new logical consequences over Σ are derivable (thisservice has been termed safety checking in [4]).In all these and many other cases, we are interested in comparing logical consequences over some vocabulary Σ that canbe drawn from two different ontologies. This gives rise to the three main notions we investigate in this paper: Σ -difference,Σ -entailment, and Σ -inseparability. Roughly, the Σ -difference between two ontologies is the set of ‘formulas’ over Σ thatare derivable from one ontology but not from the other; one ontology Σ -entails another one if all Σ -formulas derivablefrom the latter are also derivable from the former; and two ontologies are Σ -inseparable if they Σ -entail each other.In the discussion so far, we have not specified the language from which the logical consequences over Σ are drawn. Thislanguage depends on the application. For example, if one is mainly interested in terminological reasoning and differencesvisible in applications that use relationships between concepts, then an appropriate language is the set of all conceptinclusions. The Σ -difference then consists of all concept inclusions over Σ derivable from one ontology but not from theother. And one ontology Σ -entails another ontology if every concept inclusion over Σ derivable from the latter is derivablefrom the former. If, however, one is mainly interested in using ontologies to query instance data, then it is more appropriateto consider a language for consequences over Σ that reflects, in some way, answers to queries in the signature Σ (or Σ -queries) over instance data in Σ . In this case, two ontologies should be Σ -inseparable if, and only if, they give the sameanswers to every Σ -query in the chosen language for any instance data over Σ . Even this language may be insufficientfor applications where different versions of ontologies are imported into a context ontology, in which case two ontologiesshould be deemed Σ -inseparable only if after importing them into another ontology over Σ , the resulting extensions stillgive the same answers to Σ -queries.The first aim of this paper is to give precise formalisations of five variants of Σ -difference, Σ -entailment and Σ -insepa-NNhorn. These variants of Σ -difference and Σ -entailmentbool and DL-Literability for ontologies given in the DL-Lite logics DL-Liteare obtained by distinguishing between differences visible among concept inclusions, answers to queries over ABoxes, bytaking additional context ontologies into account, and by considering model-theoretic, language-independent notions ofΣ -difference and Σ -entailment.The DL-Lite family of description logics [5–8] has been originally designed with the aim of providing query access to largeamounts of data via a high-level conceptual (ontological) interface. Thus, the DL-Lite logics result from various compromisesbetween (i) the necessity of retaining the data complexity of query answering as close as possible to the complexity ofstandard database query evaluation and (ii) the desire of having the expressive means for representing various constraintsNbool [10]of data modelling formalisms such as the ER model and UML class diagrams [9]. For example, the logic DL-Lite(containing many other DL-Lite logics) can express is-a hierarchies of concepts, disjointness and covering constraints forNbool is in AC0 forconcepts, and domain, range and cardinality constraints for binary relations. Instance checking in DL-Litedata complexity (i.e., of the same complexity as database query evaluation); however, answering conjunctive queries isNhorn cannot express covering constraints, but boasts AC0 query answering (undercoNP-complete. On the other hand, DL-Litethe unique name assumption) [11]. To simplify presentation, in this paper we do not consider DL-Lite logics with roleinclusions, focusing mainly on the impact of the Boolean constructs in concept inclusions as well as number restrictions.1 http://www.w3.org/2007/OWL/.R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411095We also note that the DL-Lite family forms the basis of OWL 2 QL, one of the three profiles of the Web Ontology LanguageOWL 2.For Σ -entailment and Σ -inseparability to be applicable in practice, one has to understand their basic meta-propertiesand develop corresponding decision algorithms. The important meta-properties of Σ -entailment to be formalised and inves-tigated below specify the type of modifications of the signature Σ under which Σ -entailment is preserved, the operationson TBoxes as well as the type of context ontologies that preserve Σ -entailment.Thus, the second aim of this paper is to compare our notions of Σ -difference and Σ -entailment, study their meta-properties, determine the computational complexity of deciding Σ -entailment and Σ -inseparability between DL-Lite on-tologies, and develop decision algorithms.The notions of Σ -entailment and Σ -inseparability investigated in this paper can be employed to provide a formal foun-dation for module extraction and forgetting.Module extraction—the problem of finding a (minimal) subset of a given ontology that provides the same descriptionof the relationships between terms over a given sub-vocabulary as the whole ontology—has recently become an activeresearch topic; see, e.g., the recent volume on ontology modularisation [12] and the WoMO workshop series devoted tothis problem [13,14]. The reasons for this are manifold, with one of the most important being ontology re-use. It is oftenimpossible and not even desirable to develop an entirely new ontology for every new application; a better methodologyis to re-use appropriate existing ontologies. However, typically only a relatively small part of the vocabulary of a possiblylarge ontology is required, that is, one only needs a subset, or module, of the ontology that gives the same description ofthis sub-vocabulary. The phrase ‘gives the same description of the vocabulary’ is rather vague. It has been interpreted ina variety of ways, ranging from structural approaches [15,16] to logic-based approaches [17,1,18]. It should not come as asurprise now that in this paper we propose to understand the claim that ‘two ontologies give the same description of thevocabulary Σ ’ as ‘the two ontologies are Σ -inseparable’ in one of the senses described above. Thus, different variants ofΣ -inseparability give rise to different modules and module extraction problems, and we use the notion of Σ -inseparabilityto develop a framework for investigating such modules and algorithms for their extraction.Forgetting—the problem of constructing, given an ontology and a vocabulary Γ , a new ontology that results from theoriginal one by ‘forgetting’ Γ but retaining all the information about the remaining symbols (that are not in Γ )—has beenintroduced and investigated in AI [19–21] and, under the name of uniform interpolation, in mathematical logic [22–25].Forgetting is of interest to ontology engineering for a variety of reasons [26,27]. For example, similarly to module extractionit can be used to ‘extract’ from a given ontology another ontology that ‘provides the same description of a certain vocabularyas the original one’. However, in contrast to module extraction, the new ontology has to be formulated without using the‘forgotten’ symbols in Γ , and the axioms of the new ontology do not necessarily come from the original one. In this paper,we propose to define an ontology OΓ to be a result of forgetting a vocabulary Γ in a given ontology O if OΓ does notuse any symbols from Γ and O and OΓ are Γ -inseparable for the vocabulary Γ that consists of all remaining (i.e., non-Γ )symbols in O. So, like in the case of modules, different variants of Σ -inseparability induce different variants of forgetting.Thus, the third aim of this paper is to give formal definitions of modules, module extraction, and forgetting using Σ -inseparability. We develop generic module extraction algorithms, which extract minimal modules using the algorithmsdeciding Σ -inseparability as oracles. We also present first results on forgetting and uniform interpolation.Finally, our fourth aim is to find out whether the logic-based approach to detecting inseparability relations betweenDL-Lite ontologies can be used in practice, in particular, for minimal module extraction. With this aim in mind, we haveNbool ontologies (containing up to 1250conducted a series of experiments with a number of ‘real-world’ medium-size DL-Liteaxioms). Instead of implementing dedicated algorithms for checking Σ -entailment, we have encoded the semantic criteria ofΣ -entailment to be developed in this paper by means of quantified Boolean formulas (QBFs, for short) and then employedstandard off-the-shelf general purpose QBF solvers governed by the self-adaptive multi-engine QBF solver aqme [28].The paper, which is an extended version of [29] (containing also results of [30]), is structured in the following way.We begin, in Section 2, by introducing the DL-Lite logics, discussing their properties we need in this paper and giving anNbool ontology. In Section 3, we introduce, motivate and illustrate five different variants ofillustrative example of a DL-LiteΣ -entailment and its derivatives, Σ -difference and Σ -inseparability. We also start discussing the relationships betweenthese variants. In Section 4, we formulate semantic criteria for Σ -entailment. We introduce and illustrate all the technicalnotions involved, but move the actual proofs to Appendix A (apart from those that can be used for illustrative purposes).In Section 5, we investigate the important ‘robustness’ meta-properties of Σ -entailment mentioned above. In Section 6, wedetermine the computational complexity of deciding our Σ -entailment relations between DL-Lite ontologies and presentcorresponding decision algorithms. Again, almost all the technical proofs can be found in Appendix A. In Section 7, weshow how the notion of Σ -inseparability can be employed to define modules, analyse relationships between modules, anddesign module extraction algorithms, while in Section 8, we discuss the notion of forgetting. In Section 9, we describe ourexperiments and analyse their results. We draw conclusions and discuss open problems and further directions of researchin Section 10.2. DL-LiteOne of the most interesting and promising recent applications of description logics (DLs, for short) is to provide accessto large amounts of data through a high-level conceptual interface, which can be used in such areas as data integration1096R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Fig. 1. A UML class diagram.and ontology-based data access. The reasoning services required in this context include the traditional knowledge basesatisfiability and instance checking, as well as answering complex database-like queries by taking into account both theterminological axioms and the data stored in the knowledge base. As the amount of data is supposed to be large, thekey property for this approach to be viable in practice is the efficiency of query evaluation, with the ideal target beingtraditional database query processing. With this aim in mind the DL-Lite family of DLs has been designed in [5–8] and asupporting QuOnto system has been implemented [31,32]. The DL-Lite family forms the basis of OWL 2 QL, one of the threeprofiles of OWL 2.2 According to the official W3C profiles document, the purpose of OWL 2 QL is to be the language ofchoice for applications that use very large amounts of data and where query answering is the most important reasoningtask. A detailed analysis of the impact of various DL constructs on the computational behaviour of DL-Lite logics has beenconducted in [11], which resulted in a fine-grained classification of a more extensive class of DL-Lite related logics.Two contradicting requirements have determined the shape of DL-Lite logics:(i) answering conjunctive queries should be reducible to standard query evaluation in databases (in other words, it shouldbelong to the complexity class AC0 with respect to data complexity), and(ii) the logics should be able to capture as much of typical conceptual modelling formalisms such as UML class diagramsand ER models as possible.Before defining the syntax and semantics of DL-Lite logics formally, let us consider the UML class diagram depicted in Fig. 1and representing (a portion of) a computer science department information system. For example, according to this diagram,research and visiting staff are disjoint, project managers can only be from the visiting and academic staff, each project ismanaged by one or two managers, and each researcher works on at least one project, and the other way round. A crucialobservation here is that the information about binary relations such as ‘manages’ or ‘works on’ provided by the UML classdiagram concerns only their domains and ranges (the domain of ‘manages’ is a subset of all project managers, while itsrange is the set of all projects) as well as multiplicity (each project is managed by at most two managers). This observationmotivates the following description logic called DL-LiteNbool consists of three (pairwise disjoint) countably infinite sets: object names a1, a2, . . . , conceptNbool are defined inductively as follows:names A1, A2, . . . , and role names P 1, P 2, . . . . Complex roles R and concepts C of DL-LiteNbool [11] (and DL-Litebool in [10]).The alphabet of DL-Lite−R ::= P i | Pi ,B ::= ⊥ | (cid:4) | Ai | (cid:2) q R,C ::= B | ¬C | C1 (cid:5) C2,where q is a positive integer (given in binary3). The concepts of the form B are called basic. Other standard concept con-structs such as ∃R, (cid:3) q R and C1 (cid:7) C2 can be introduced as abbreviations: ∃R for (cid:2) 1 R, (cid:3) q R for ¬((cid:2) q + 1 R), and C1 (cid:7) C2for ¬(¬C1 (cid:5) ¬C2). Concepts of the form (cid:3) q R and (cid:2) q R will be called number restrictions, and those of the form ∃R and(cid:2) 1 R existential concepts.A concept inclusion in DL-Litedenoted by T , is a finite set of concept inclusions in DL-LiteC1 (cid:8) C2 and C2 (cid:8) C1.NNNbool is of the form C1 (cid:8) C2, where C1 and C2 are DL-Litebool concepts. A TBox in DL-Litebool,Nbool. As usual, we write C1 ≡ C2 instead of the two inclusionsWe use (cid:4)(C) to denote the length of a concept C —i.e., the number of symbols required to write it down. The length (or(cid:2)size) (cid:4)(T ) of a TBox T is defined by takingC1(cid:8)C2∈T ((cid:4)(C1) + (cid:4)(C2)).2 The OWL 2 profiles are fragments of the full OWL 2 that have been designed and standardised for specific application requirements; seehttp://www.w3.org/TR/owl2-profiles/.3 In fact, our complexity results do not depend on whether numbers are given in unary or binary; see Remark 45.Example 1. The UML class diagram in Fig. 1 can be represented by the following DL-LiteNbool TBox:R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411097∃manages (cid:8) ProjectManager,− (cid:8) Project,∃manages−Project (cid:8) ∃manages− (cid:8) ⊥,(cid:2) 3 managesVisiting (cid:8) ProjectManager,ProjectManager (cid:8) Academic (cid:7) Visiting.,∃worksOn (cid:8) Research,− (cid:8) Project,∃worksOnResearch (cid:8) ∃worksOn,Project (cid:8) ∃worksOnAcademic (cid:8) ProjectManager,−,Research (cid:8) Staff,Visiting (cid:8) Staff,Research (cid:5) Visiting (cid:8) ⊥,Academic (cid:8) Staff,We will also consider a sub-language DL-Litesions in DL-LiteNhorn are restricted to the formB1 (cid:5) · · · (cid:5) Bk (cid:8) B,Nhorn of DL-LiteNbool, called the Horn fragment of DL-LiteNbool. The concept inclu-(Horn)(cid:3)where B and the B i are basic concepts. Note that the inclusionsNhorn is a finite set of concept inclusions in DL-LiteDL-LiteNhorn. A TBox inNbool, basic conceptsNhorn we can express both global functionality of a rolewill also be called DL-Liteand local functionality (i.e., functionality restricted to a (basic) concept B) by means of the concept inclusions (cid:2) 2R (cid:8) ⊥ and(cid:2) 2R (cid:5) B (cid:8) ⊥.Nhorn. In the context of this fragment of DL-LiteNhorn concepts. It is worth noting that in DL-Litek Bk (cid:8) ⊥ and (cid:4) (cid:8) B are legal in DL-LiteNbool or DL-LiteLet L be one of the languages DL-LiteNhorn. An ABox in L, denoted A, is a finite set of assertions of the formC(ai), R(ai, a j), ai = a j and ai (cid:11)= a j , where C is an L-concept, R a role, and ai, a j are object names. An L knowledge base(L-KB, for short) is a pair K = (T , A) with a TBox T and an ABox A both in L.By a signature we understand any finite set Σ of concept and role names. (As TBoxes in DL-LiteNbool do not contain objectnames, we do not have to include them in signatures.) Given a concept, role, TBox, ABox, or any other expression E in theNbool, we denote by sig(E) the signature of E, that is, the set of concept and role names that occur in E. Italphabet of DL-Liteis to be noted that ⊥ and (cid:4) are regarded as logical symbols, and so sig(⊥) = sig((cid:4)) = ∅. A concept (role, TBox, ABox, etc.)E is called a Σ -concept (role, TBox, ABox, etc., respectively) if sig(E) ⊆ Σ . Thus, Pis a Σ -role if, and only if, P ∈ Σ .Given a signature Σ , we define a Σ -interpretation I as a structure of the form ((cid:5)I , ·I ), where (cid:5)Iis an interpretation function that assigns to each concept name Ai ∈ Σ a subset Ais a nonempty set,⊆ (cid:5)Ithe domain of interpretation, and ·Iof the domain, to each role name P i ∈ Σ a binary relation Pover the domain, and to each object name ai. If I interprets all concept and role names or Σ is understood, then we usually drop the modifier Σan element aand call I simply an interpretation. For an interpretation I and a signature Σ , we denote by I (cid:4)Σ the Σ -reduct of I to Σ ,that is, the Σ -interpretation with domain (cid:5)I, for all roleI(cid:2)Σnames P i ∈ Σ , and ai, for all concept names Ai ∈ Σ , P, for all object names ai .⊆ (cid:5)I × (cid:5)Iin which A∈ (cid:5)II(cid:2)ΣiI(cid:2)Σi= A= P= aIiIiIiIiIiIi−Complex roles and concepts are interpreted in I as follows:( y, x) ∈ (cid:5)I × (cid:5)I | (x, y) ∈ P(cid:7)Ii(cid:6)(cid:8)(cid:8) (cid:6)y ∈ (cid:5)I(cid:8)(cid:8) (x, y) ∈ R(cid:7)I(cid:7)(cid:2) q(cid:4)(cid:6)−i(cid:5)I =P(cid:4)I = (cid:5)I⊥I = ∅((cid:2)q R)I =(¬C)I = (cid:5)I \ CI(C1 (cid:5) C2)I = C1(cid:6)x ∈ (cid:5)II∩ CI2(inverse role),(the whole domain),(the empty set),(at least q R-successors),(not in C ),(both in C1 and C2),where, for typographical reasons, we denote the cardinality of X by (cid:6) X instead of the usual | X|.The satisfaction relation |(cid:15) is defined by taking:I |(cid:15) C1 (cid:8) C2I |(cid:15) C(ai)I |(cid:15) R(ai, a j)iff Ciff a(cid:4)aiffI1Ii⊆ CI2 ,I ,∈ C(cid:5)IIi , aj∈ RI |(cid:15) ai = a jI |(cid:15) ai (cid:11)= a jiff aiff aIiIi= a(cid:11)= aIj ,Ij ,I ,where C , C1, C2 are L-concepts, R a role, and ai, a j object names. An L-KB K = (T , A) is said to be satisfiable (or consistent)if there is an interpretation I satisfying all the members of T and A. In this case we write I |(cid:15) K (as well as I |(cid:15) T andI |(cid:15) A) and say that I is a model of K (and of T and A). A concept inclusion C1 (cid:8) C2 follows from (or is a logical consequenceof ) T , T |(cid:15) C1 (cid:8) C2 in symbols, if every model of T satisfies C1 (cid:8) C2. A concept C is T -satisfiable if there exists a model Iof T with CI (cid:11)= ∅.1098R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141An (essentially positive) existential query q(x1, . . . , xn) in L (or simply a query, if L is understood) is a first-order formula∃ y1 . . . ∃ ymϕ(x1, . . . , xn, y1, . . . , ym),where ϕ is constructed, using only ∧ and ∨, from atoms of the form C(t) and R(t1, t2), with C being an L-concept, R arole, and ti being either an object name or a variable from the list x1, . . . , xn, y1, . . . , ym. The free variables of q are calleddistinguished variables of q and the bound ones non-distinguished variables of q. We write q(x1, . . . , xn) for a query withdistinguished variables x1, . . . , xn. Given a query q(x) with x = x1, . . . , xn and an n-tuple a of object names, we write q(a)for the result of replacing every occurrence of xi in q(x) with the ith member of a. Queries containing no distinguishedvariables are called ground or Boolean.Let I = ((cid:5)I , ·I ) be an interpretation. An assignment a in (cid:5)Ia( y) of (cid:5)Iwith respect to a given assignment a is defined inductively by taking:. We will use the following notation: aIi and y= aI,aiis a function associating with every variable y an elementI,a = a( y). The satisfaction relation for existential queriesI |(cid:15)a C(t)I |(cid:15)a R(t1, t2)I |(cid:15)a ϕ1 ∧ ϕ2I |(cid:15)a ϕ1 ∨ ϕ2I |(cid:15)a ∃ yϕiffI,a ∈ Ct(cid:4)I,at1I ,(cid:5)I,a2, t∈ RI ,iffiff I |(cid:15)a ϕ1 and I |(cid:15)a ϕ2,iff I |(cid:15)a ϕ1 or I |(cid:15)a ϕ2,iff I |(cid:15)b ϕ, for some assignment b in (cid:5)Ithat may differ from a only on y.For a ground query q(a), the satisfaction relation does not depend on the assignment a; so we write I |(cid:15) q(a) instead ofI |(cid:15)a q(a).For a KB K = (T , A), we say that a tuple a of object names from A is a certain answer to q(x) with respect to K andwrite K |(cid:15) q(a), if I |(cid:15) q(a) whenever I |(cid:15) K. A certain answer to a ground query q(a) with respect to K is either ‘yes’ ifK |(cid:15) q(a) and ‘no’ otherwise. The query answering problem in L can be formulated as follows: given an L-KB K = (T , A),a query q(x) in L, and a tuple a of object names from A, decide whether K |(cid:15) q(a).Nbool, essentially positive existential queries may contain ‘complex atoms’ C(t) like (¬((cid:2) 7 PRemark 2. The reader must have probably noticed that the class of essentially positive existential queries in L we deal within this paper is larger than the standard class of positive existential queries which can be built, using ∧ and ∨, only fromatoms of the form Ai(t) and P j(t1, t2) where the Ai and P j are concept and role names, respectively. In particular, in the−j ) (cid:5) ¬ Ai)( y). Thecase of DL-Litereason why we consider more complex queries will be discussed in Section 5.1. Note, however, that query answering foressentially positive existential queries in L can be reduced to query answering in L using positive existential queries: givenan L-KB K = (T , A) and an essentially positive existential query q(x) in L, one can replace every occurrence of a complexatom C(t) in q(x) with AC (t), for a fresh concept name AC , and add to T the definition AC ≡ C , which clearly belongs to L.Denote the resulting positive existential query by q. It is readily seen that, for every tuplea of object names from A, we have K |(cid:15) q(a) if, and only if, K(cid:18) |(cid:15) q(cid:18)(x) and the resulting L-KB by K(cid:18)(cid:18)(a).Remark 3 (on the unique name assumption). According to the definitions given above, we do not adopt here the uniquename assumption (UNA, for short), which can be formulated as follows. We say that an interpretation I is a model of aIKB K = (T , A) under the UNA if I |(cid:15) K and aj , for any distinct object names ai and a j occurring in A. Instead, wefollow the more liberal approach taken in OWL: the UNA is dropped, but the user is provided with means, = and (cid:11)=, tosay explicitly which object names must denote the same individual and which must be different. Of course, we can alwaysenforce the UNA by adding to each ABox A the inequalities ai (cid:11)= a j for all pairs of distinct object names ai and a j occurringin A. In fact, we shall see in Theorem 18 that for our purposes it does not matter which of the two approaches is taken.However, the complexity of standard reasoning tasks like satisfiability checking or query answering in the DL-Lite logicsdoes depend on whether the UNA is adopted or not. We recall the following complexity results [10,11] for our DL-Lite logicswith and without the UNA:(cid:11)= aIiWith the UNA:the satisfiability problem for knowledge bases is NP-complete for DL-Litewith respect to combined complexity; answering positive existential queries is in AC0 for DL-Litecomplete for DL-LiteNbool KBs with respect to data complexity.Without the UNA: satisfiability is NP-complete with respect to combined complexity and query answering is coNP-Ncomplete with respect to data complexity for both DL-Litehorn; by limiting number restrictionsto global functionality constraints (cid:2) 2R (cid:8) ⊥ and existential concepts ∃R only, we reduce the complexity of sat-isfiability and query answering for the Horn fragment to P; and if the functionality constraints are also removedthen the complexity of satisfiability becomes the same as in the UNA case, while query answering for the Hornfragment drops to LogSpace (or even to AC0 if the use of = is not allowed).Nbool and DL-LiteNbool and P-complete for DL-LiteNhorn KBs and coNP-NhornR. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–114110993. What is the difference?In this section, we give precise definitions of various notions of difference, entailment, and inseparability between on-tologies with respect to a signature and discuss how these notions are related to each other.Nbool, DL-LiteIntuitively, an ontology T1 is inseparable from an ontology T2 with respect to a signature Σ if T1 and T2 cannotbe distinguished from each other by means of their consequences over Σ . To make this intuition precise, we have tospecify a language from which the consequences are drawn. As we consider ontologies formulated in the DL-Lite logicsNhorn, the most obvious language for consequences is probably the concept inclusions in L. Thus, weL = DL-Litecan say that TBoxes T1 and T2 in L are Σ -inseparable if T1 and T2 imply the same Σ -concept inclusions in L. The cor-responding non-symmetric notion of Σ -entailment is formulated as follows: T1 Σ -entails T2 if every Σ -concept inclusionin L that follows from T2 also follows from T1 (so T1 and T2 are Σ -inseparable if, and only if, they Σ -entail each other).Finally, the Σ -difference between T1 and T2 can be defined as the set of all Σ -concept inclusions in L that follow fromT2 but not from T1. To indicate that we are interested in consequences of ontologies in the form of concept inclusions, weprefix these notions of difference, entailment and inseparability with the modifier concept. Here is a formal definition:Definition 4. The Σ -concept difference between TBoxes T1 and T2 in L is the set cDiffC (cid:8) D in L such that T1 (cid:11)|(cid:15) C (cid:8) D and T2 |(cid:15) C (cid:8) D.LΣ (T1, T2) of all Σ -concept inclusionsT1 Σ -concept entails T2 in L if cDiffLΣ (T1, T2) = ∅. T1 and T2 are Σ -concept inseparable in L if they Σ -concept entail eachother in L.Σ -concept inseparability between T1 and T2 means that T1 can be replaced by T2 in any application that is only con-cerned with Σ -concept inclusions in L (we elaborate on this claim below). An ontology developer who wants to comparetwo versions T1 and T2 of an ontology with respect to a signature Σ can check whether they are Σ -concept inseparableLΣ (T2, T1) to analyse the Σ -differences between theseand, if this is not the case, further inspect cDiffversions.LΣ (T1, T2) and cDiffRemark 5. The notion of Σ -concept entailment between TBoxes is a generalisation of the notion of conservative extensioninvestigated in [24,33] for expressive descriptions logics such as ALC and ALCQI. Namely, a TBox T2 is a conservative ex-tension of a TBox T1 if T1 ⊆ T2 and T1 Σ -concept entails T2 for Σ = sig(T1). The notion of conservative extension originatesfrom mathematical logic where it is used, e.g., for relative consistency proofs in arithmetic and set theory; see [34] for moreinformation. In computer science, conservative extensions have found applications in modular software specification andverification [35–38]. The first papers suggesting to use conservative extensions (or variants thereof) for modular ontologyengineering were [39,17,24]. In answer set programming, modularity and variations of conservative extensions have beeninvestigated in, e.g., [40–43].Concept inclusions are not the only interesting type of consequences of TBoxes. In the context of DL-Lite ontologies,answers to queries over ABoxes are probably of even greater importance than concept inclusions. The following exampleshows that the ‘concept-based’ notions of difference and entailment introduced above are not appropriate for applicationsthat involve query answering. (The claims made in the examples below will be explained in a informal way; strict proofscan be easily given using the semantic criteria to be discussed in Section 4.)Example 6. Let Σ = {Lecturer, Course},(cid:6)T1 = ∅ and T2 =Lecturer (cid:8) ∃teaches, ∃teaches− (cid:8) Course(cid:7).Intuitively, the only (non-tautological) consequence of T2 over Σ is ‘if there is a lecturer, then there is a course’, whichNcannot be expressed by means of Σ -concept inclusions. Thus, T1 and T2 are Σ -concept inseparable (in both DL-LiteboolNhorn). On the other hand, T1 and T2 become Σ -separable if they are used to query ABoxes. For instance, letand DL-LiteA = {Lecturer(a)} and q = ∃ y Course( y). Although both sig(A) and sig(q) are in Σ , they nevertheless separate T1 and T2because (T1, A) (cid:11)|(cid:15) q but (T2, A) |(cid:15) q.Thus, in applications where TBoxes are used to query ABoxes, T1 cannot be regarded as indistinguishable from T2 withrespect to Σ because one can find a Σ -ABox and a Σ -query in the presence of which T1 behaves differently from T2.To take into account the differences between TBoxes that can be detected by means of ABoxes and queries, we proposethe following definition:LDefinition 7. The Σ -query difference between TBoxes T1 and T2 in L is the set qDiffΣ (T1, T2) of pairs of the form (A, q(x)),where A is a Σ -ABox in L and q(x) a Σ -query in L such that (T1, A) (cid:11)|(cid:15) q(a) and (T2, A) |(cid:15) q(a), for some tuple a ofobject names from A.T1 Σ -query entails T2 in L if qDiffLΣ (T1, T2) = ∅. T1 and T2 are Σ -query inseparable in L if they Σ -query entail each otherin L.1100R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141In the definition of Σ -query difference, we take into consideration arbitrary Σ -ABoxes in L. The reason for this is that,during the ontology design phase, the data repositories to which the ontology will be applied are often either completelyunknown or are subject to more or less frequent changes. Thus, to assume that we have a fixed ABox is unrealistic whenchecking Σ -query differences between ontologies, and that is why in our approach we regard ABoxes as ‘black boxes’.This notion of Σ -query difference and entailment has been discussed in [25] and investigated for the description logic ELin [44].As we shall see later (cf. Theorem 24), for DL-LiteNhorn implies Σ -concept en-Nbool. However, this implication does not hold for Σ -query entailment, as shown by the following example:Nhorn TBoxes, Σ -concept entailment in DL-Litetailment in DL-LiteExample 8. Let Σ = {Lecturer},T1 = ∅ and T2 =(cid:6)Lecturer (cid:8) ∃teaches, Lecturer (cid:5) ∃teaches(cid:7)− (cid:8) ⊥.Then T1 does not Σ -query entail T2 in DL-Lite(T1, A) (cid:11)|(cid:15) q and (T2, A) |(cid:15) q. On the other hand, as we do not allow negation in DL-LiteT1 Σ -query entails T2 in DL-LiteNbool. Indeed, for A = {Lecturer(a)} and q = ∃ y ¬Lecturer( y), we haveNhorn queries, one can show thatNhorn.Similarly to Σ -concept inseparability, Σ -query inseparability between TBoxes T1 and T2 means that T1 can be replacedby T2 in the applications where only answers to Σ -queries over Σ -ABoxes are of interest. However, this informal explana-tion should be taken with caution. To see why, recall that one of the reasons for studying inseparability and difference isontology re-use: instead of constructing ontologies from scratch, it is often preferable to import (parts of) already existingontologies. In other words, ontologies are designed as the unionTself ∪ Timp,where Tselfis an ontology developed specifically for the given application and Timp is an imported ontology. A problemarises when we have a choice between different versions of such Timp or when it is preferable to import only a small subsetof Timp (later, in Section 7, called a module) that contains all the relevant information for the new application. In thesecases, we would like to be able to detect whether it makes any difference if we import a version T (cid:18)imp or a version T (cid:18)(cid:18)impof Timp and, likewise, whether it makes any difference if Timp itself is imported or only its subset M. In other words, wewould like to know whether• Tself ∪ T (cid:18)• Tself ∪ M and Tself ∪ Timp are Σ -inseparable,imp and Tself ∪ T (cid:18)(cid:18)imp are Σ -inseparable, and whetherwhere Σ is the signature required for the application. Now, instead of checking Σ -inseparability after taking the union withTself , it would be much more useful to be able to check Σ -inseparability independently of Tself and before importing theontologies we are interested in. Consider, for example, a situation when Tself is still evolving or subject to frequent changes.Thus, it would be desirable to have a notion of Σ -inseparability with the following replacement property:(replace) if T1 and T2 are Σ -inseparable in L, then T ∪ T1 and T ∪ T2 are Σ -inseparable in L, for all Σ -TBoxes T in L.If a notion of Σ -inseparability has this property, then Σ -inseparability of T1 and T2 ensures that T1 can be replaced byT2 within any context Σ -TBox T in the given language L. For further discussions of the replacement property, we refer thereader to Section 7, where Σ -inseparability is used for module extraction, and to Section 5.4, where we consider contextTBoxes that are given in expressive DLs such as SHIQ.Unfortunately, not all the notions of inseparability introduced so far enjoy the replacement property.Example 9. Let again T1 = ∅ and T2 be the TBox from Example 8 saying that every lecturer teaches and that a lecturer is notNsomething that is taught. As before, consider Σ = {Lecturer}. Then T1 and T2 are Σ -concept inseparable in both DL-LiteboolNhorn. But for T = {(cid:4) (cid:8) Lecturer}, we have T1 ∪ T (cid:11)|(cid:15) (cid:4) (cid:8) ⊥ and T2 ∪ T |(cid:15) (cid:4) (cid:8) ⊥, i.e., the former TBox is consistentand DL-Litewhile the latter is not. Thus, no difference between T1 and T2 is visible if we only consider Σ -concept inclusions; that thetwo TBoxes are indeed different becomes apparent in the presence of the extra Σ -TBox T .To take such context ontologies into account, we introduce two stronger variants of Σ -inseparability that, by their verydefinitions, enjoy the replacement property.Definition 10. The strong Σ -concept difference in L between TBoxes T1 and T2 is the set scDiffwhere T is a Σ -TBox in L and C (cid:8) D belongs to cDiffscDiffLΣ (T1, T2) of pairs (T , C (cid:8) D)LΣ (T ∪ T1, T ∪ T2). T1 strongly Σ -concept entails T2 in L ifLΣ (T1, T2) = ∅. T1 and T2 are strongly Σ -concept inseparable in L if they strongly Σ -concept entail each other in L.R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411101The strong Σ -query difference in L between T1 and T2 is the set sqDiffLΣ (T1, T2) of triples (T , A, q(x)) such that T is aLLΣ (T1, T2) = ∅. T1 and T2 areΣ (T ∪ T1, T ∪ T2). T1 strongly Σ -query entails T2 in L if sqDiffΣ -TBox in L and (A, q(x)) ∈ qDiffstrongly Σ -query inseparable in L if they strongly Σ -query entail each other in L.Sometimes it will be convenient to use the following rephrasing of the definition of strong Σ -concept entailment (andanalogously for strong Σ -query entailment): T1 strongly Σ -concept entails T2 in L if, and only if, T ∪ T1 Σ -conceptentails T ∪ T2, for all Σ -TBoxes T in L. Thus, if two versions of ontologies are strongly Σ -inseparable for their sharedsignature Σ , then they can be safely replaced by each other within any ontology T which only uses symbols from Σ ;after such a replacement no differences between the sets of derivable Σ -concept inclusions (or answers to Σ -queries) canbe detected. In the context of defining modules within ontologies, taking into account changes to ontologies and contextontologies has been strongly advocated in [4], which inspired our definition; see also Section 7.The notions of difference and inseparability introduced so far are language-dependent because the set of syntactic objectscollected in the difference between two ontologies depends on the description logic under consideration. We have alreadyNseen in Example 8 that Σ -query entailment in DL-Litehorn, even forNDL-Litehorn does not imply strongΣ -concept entailment in DL-LiteNhorn TBoxes. Here is another example showing that strong Σ -concept entailment in DL-LiteNbool does not coincide with Σ -query entailment in DL-LiteNbool.Example 11. Consider the DL-LiteNhorn TBoxesT1 = {Male (cid:5) Female (cid:8) ⊥, (cid:4) (cid:8) ∃father, (cid:4) (cid:8) ∃mother, ∃fatherT2 = {(cid:4) (cid:8) ∃id, Male (cid:5) ∃id− (cid:8) ⊥, Female (cid:5) ∃id− (cid:8) ⊥},− (cid:8) Male, ∃mother− (cid:8) Female},and let Σ = {Male, Female}. It follows from T2 that the range of the role id is disjoint from Male and Female. Now letT = {(cid:4) (cid:8) Male (cid:7) Female}. Then T ∪ T1 is consistent, but T ∪ T2 is inconsistent. Thus we have T ∪ T2 |(cid:15) (cid:4) (cid:8) ⊥, whileNbool. However, one can show that T1 stronglyT ∪ T1 (cid:11)|(cid:15) (cid:4) (cid:8) ⊥, and so T1 does not strongly Σ -concept entail T2 in DL-LiteNΣ -concept entails T2 in DL-Litehorn we cannot express that Male andFemale together cover the whole domain.Nhorn. Intuitively, the reason for this is that in DL-LiteLanguage-dependence of the notions of difference between ontologies is unproblematic and justified if the languagesinvolved in the application are known in advance. For example, if the application involves conceptual reasoning in DL-LiteNhornNor DL-Litebool, or query answering over ABoxes in these languages, the corresponding notions introduced above are entirelyappropriate. Moreover, if weaker descriptions logics or query languages than the ones considered above are used, it isstill sound to work with the notions of difference introduced so far as no relevant differences are missed. In some cases,however, one might be interested in importing DL-Lite ontologies into ontologies formulated in more expressive languagessuch as SHIQ [2] or even first-order logic. Or one might be interested in querying DL-Lite ontologies in more expressivelanguages than essentially positive existential queries. In these cases, our notions of difference can be incomplete becausemore expressive languages can potentially detect differences that are not observable in DL-Lite. The following exampleillustrates this point.Example 12. Let T1 = ∅, T2 = {(cid:4) (cid:8) ((cid:2) 2P )} and Σ = ∅. The only difference between T1 and T2 with respect to the emptysignature Σ is that T1 has a model with domain of cardinality one, but T2 does not have such a model. Using this observa-tion, one can show that T1 Σ -entails T2 for all the notions of Σ -entailment introduced above (these notions are insensitiveto cardinalities). However, the first-order Σ -sentence ϕ = ∃x∃ y(x (cid:11)= y) distinguishes between T1 and T2 since T1 (cid:11)|(cid:15) ϕ andT2 |(cid:15) ϕ.Instead of defining and investigating Σ -entailment for other languages such as SHIQ or first-order logic, in this paperwe consider a language-independent, purely model-theoretic notion of difference, which covers all the differences detectablein standard description logics, first-order and even second-order logic. Apart from that, we will show in Section 5 thatNstrong Σ -query entailment in DL-Litebool is actually extremely robust in terms of language extensions within the family ofdescription logics (see Theorem 40).Definition 13. The Σ -model difference between TBoxes T1 and T2 is the class mDiffΣ (T1, T2) of all Σ -interpretations I forwhich there exists a model I1 of T1 with I1 (cid:4)Σ = I but there is no model I2 of T2 with I2 (cid:4)Σ = I. We say that T1 Σ -modelentails T2 if mDiffΣ (T1, T2) = ∅. T1 and T2 are Σ -model inseparable if they Σ -model entail each other.Observe that, for T1, T2 and Σ from Example 12, mDiffΣ (T1, T2) consists of all isomorphic copies of the Σ -interpretationwhose domain has exactly one element. We give one more example illustrating our language-independent notion of Σ -difference.1102R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Example 14. Let T1 be a TBox in DL-LiteNhorn stating, using an auxiliary role name R, that concept B is nonempty:T1 = {(cid:4) (cid:8) ∃R, ∃R− (cid:8) B}.Consider also a TBox T2 in DL-LiteNhorn stating that P is an injective function from A to B:T2 = { A ≡ ∃P , ∃P− (cid:8) B, (cid:2) 2 P (cid:8) ⊥, (cid:2) 2 P− (cid:8) ⊥}.Let Σ = { A, B}. Then mDiffΣ (T1, T2) is the set of Σ -interpretations I in which BIis larger than the cardinality of B(and so there cannot be an injection from A). As this set of interpretations isnonempty, T1 does not Σ -model entail T2. One can show, however, that T1 Σ -entails T2 for all the language-dependentnotions of Σ -entailment introduced above (see Example 22 below).is nonempty and the cardinality of Ato BIIIIThe following proposition provides some basic implications between the variants of Σ -entailment introduced above;a systematic investigation will be conducted in the next section.Proposition 15. Let L be one of DL-LiteNbool or DL-LiteNhorn, T1 and T2 TBoxes in L, and Σ a signature.(i) If T1 Σ -query entails T2 in L then T1 Σ -concept entails T2 in L. In other words, if cDiff(ii) If T1 Σ -model entails T2 then T1 strongly Σ -query entails T2 in L. In other words, if sqDiffLLΣ (T1, T2) (cid:11)= ∅.Σ (T1, T2) (cid:11)= ∅ then qDiffLΣ (T1, T2) (cid:11)= ∅ then mDiffΣ (T1, T2) (cid:11)= ∅.Proof. (i) To see that any difference between T1 and T2 detectable by means of concept inclusions can also be detectedby means of queries, suppose that we have T1 (cid:11)|(cid:15) C1 (cid:8) C2 and T2 |(cid:15) C1 (cid:8) C2, for some Σ -concept inclusion C1 (cid:8) C2 in L.NConsider the ABox A = {C1(a)} and the query q = C2(a). Then (T2, A) |(cid:15) q, while (T1, A) (cid:11)|(cid:15) q. (Note that in DL-Litehorn boththe ABox and the query are defined correctly as C1 = B1 (cid:5) · · · (cid:5) Bk and C2 = B, where B, B1, . . . , Bk are basic concepts, andso A = {B1(a), . . . , Bk(a)} and q = B(a).)(ii) To see that any difference between T1 and T2 detectable by triples (T , A, q(x)) can also be detected by means ofΣ -interpretations, suppose that (T ∪ T1, A) (cid:11)|(cid:15) q(a) and (T ∪ T2, A) |(cid:15) q(a), where T , A and q contain symbols from Σonly. Take a model I of (T ∪ T1, A) such that I (cid:11)|(cid:15) q(a). We show that I(cid:4)Σ ∈ mDiffΣ (T1, T2). Indeed, otherwise we wouldhave a model I(cid:18)of T2 such that I(cid:4)Σ = I(cid:18)(cid:4)Σ . But then, since T , A and q use symbols from Σ only, I(cid:18) |(cid:15) (T ∪ T2, A) andI(cid:18) (cid:11)|(cid:15) q(a), contrary to (T ∪ T2, A) |(cid:15) q(a). (cid:2)We conclude this section with two important observations. First we consider Σ -entailment between DL-Lite TBoxescontaining no role names—in essence, Σ -entailment between propositional theories—and show that in this case all thevariants of Σ -entailment introduced above coincide. And then we prove that our notions of Σ -entailment do not dependon the unique name assumption (UNA), as promised in Section 2.Example 16 (Σ -entailment in propositional logic). If a TBox T does not contain any role names then we can identify conceptnames with propositional variables and regard T as a finite set T ∗of propositional (Boolean) formulas (with the obviouscorrespondence between the concept construct (cid:5) and Boolean conjunction ∧ and between concept inclusion (cid:8) and Booleanimplication →). Moreover, if T is a DL-Liteis a finite set of propositional Horn formulas. This brings usto Σ -entailment between propositional theories.horn TBox, then T ∗NA propositional theory is just a finite set of propositional formulas, and a propositional signature is just a set of propositionalvariables. Let Σ be such a signature. Say that a propositional theory Φ1 Σ -entails a propositional theory Φ2 if, for everypropositional formula ϕ over Σ , we have Φ1 |(cid:15) ϕ whenever Φ2 |(cid:15) ϕ. This notion can be characterised in purely model-theoretic terms: Φ1 Σ -entails Φ2 if, and only if, for every propositional model I (assigning truth-values to propositionalvariables) of Φ1, there exists a propositional modelof Φ2 that coincides with I on the variables in Σ . Indeed, theimplication (⇐) is trivial. To show the converse, suppose that Φ1 Σ -entails Φ2, but there is a model I of Φ1 such that nomodel of Φ2 coincides with I on the variables from Σ . Consider the formulaI(cid:18)(cid:9) (cid:10)(cid:10)p ∧(cid:11)¬p.χI,Σ = ¬p∈Σ, I|(cid:15)pp∈Σ, I(cid:11)|(cid:15)pBy our assumption, Φ2 |(cid:15) χI,Σ . But then we must have Φ1 |(cid:15) χI,Σ , contrary to I |(cid:15) Φ1 and I (cid:11)|(cid:15) χI,Σ . Thus, in contrast tothe notions of Σ -entailment between DL-Lite TBoxes, in the propositional case the canonical language-dependent notion ofΣ -entailment coincides with the model-theoretic notion of Σ -entailment.It is also not difficult to prove that a propositional Horn theory Φ1 Σ -entails a propositional Horn theory Φ2 if, and onlyif, for every propositional Horn formula ϕ over Σ , Φ2 |(cid:15) ϕ implies Φ1 |(cid:15) ϕ (cf. Theorem 24 for a somewhat more generalR. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411103result). In other words, for Horn theories it does not make any difference whether one considers Horn or arbitrary formulasin the language-dependent notion of Σ -entailment.Theorem 17. Let L be one of DL-LiteThen the following conditions are equivalent:Nbool or DL-LiteNhorn. Let T1, T2 be TBoxes in L without occurrences of role names and Σ a signature.• T1 (strongly) Σ -concept entails T2 in L;• T1 (strongly) Σ -query entails T2 in L;• T1 Σ -model entails T2;1 Σ -entails T ∗• T ∗2 (as propositional theories).NNProof. Assume first that L is DL-Litebool. Since T1 and T2 do not contain rolebool and that both T1 and T2 are in DL-Litenames, we may assume without loss of generality (see Theorem 33 below) that Σ contains no role names. It should be clearfrom Example 16 that T1 Σ -concept entails T2 in DL-Lite2 . Thus, in view of Proposition 15,it suffices to show that if T1 Σ -entails T2, then T1 Σ -model entails T2. Suppose otherwise. Then there is a model I of T1such that for no model I(cid:18)of T2 do we have I (cid:4)Σ = I(cid:18) (cid:4)Σ . In fact, as T1 and T2 contain no role names, we can find such anI whose domain consists of a single point, say x. Then, similarly to the argument in Example 16, we take the Σ -conceptinclusion (cid:4) (cid:8) CI,Σ , wherebool if, and only if, T ∗1 Σ -entails T ∗N(cid:9)(cid:11)CI,Σ = ¬(cid:3)Ai ∈Σ, x∈ AIiAi (cid:5)¬ Ai.(cid:3)Ai ∈Σ, x /∈ AIiBy our assumption, T2 |(cid:15) (cid:4) (cid:8) CI,Σ , and so T1 |(cid:15) (cid:4) (cid:8) CI,Σ , contrary to I |(cid:15) T1 and I (cid:11)|(cid:15) (cid:4) (cid:8) CI,Σ .Now assume that T1 and T2 are in DL-Liteit suffices to show that if T1 Σ -concept entails T2 in DL-Litein DL-Literequired. (cid:2)horn, then for every Horn formula ϕ over Σ , T ∗NNhorn. As we have proved the result for DL-Lite1 Σ -entails T ∗horn, then T ∗|(cid:15) ϕ. Thus, by Example 16, T ∗|(cid:15) ϕ implies T ∗1Nbool and in view of Proposition 15,2 . But if T1 Σ -concept entails T22 , as1 Σ -entails T ∗N2As mentioned in Section 2, there are two main paradigms for interpreting object names. One of them (typically adoptedin the DL community) treats different object names from a given ABox as denoting different objects in interpretations; it isknown as the unique name assumption (UNA). According to the other paradigm (which is standard in the OWL communityas well as in first-order logic), no assumption is made as to how object names can be interpreted in general, but the usersare provided with the ABox constructs = and (cid:11)= in order to impose any constraints on object name interpretations theywant. For example, to simulate the UNA, we can add to the ABoxes we are interested in the inequalities ai (cid:11)= a j for all pairsof distinct object names ai and a j occurring in the ABoxes. Fortunately, in the context of the present investigation, it doesnot matter which of the two paradigms is adopted.Theorem 18. Let L ∈ {DL-Liteintroduced above, T1 Σ -entails T2 in L under the UNA if, and only if, T1 Σ -entails T2 in L without the UNA (but with = and (cid:11)=).}. Let T1, T2 be TBoxes in L and Σ a signature. Then, for any variant of Σ -entailmentNbool, DL-LiteNhornProof. The claim is clear for Σ -concept, strong Σ -concept and Σ -model entailments because no ABoxes are involved intheir definitions.Consider Σ -query entailment. As was observed above, the case without the UNA covers the one with the UNA. Sosuppose that T1 does not Σ -query entail T2 without the UNA and show that T1 still does not Σ -query entail T2 underthe UNA. Let A be a Σ -ABox in L and q(x) a Σ -query in L such that (T2, A) |(cid:15) q(a) but (T1, A) (cid:11)|(cid:15) q(a) for some tuple afrom A. Let I be a model of (T1, A) (without the UNA) and a an assignment with a(xi) = ai such that I (cid:11)|(cid:15)a q(x). Define anIequivalence relation ∼ on the set of object names by taking ai ∼ a j if, and only if, aj . Take a member aξ from each(cid:18)(x) to be the ABox and query that result from A and q(x) by replacing every∼-equivalence class ξ and define A(cid:18)(cid:18)), whereai with aξ for the ∼-equivalence class ξ of ai . Then clearly I is a model of (T1, A(cid:18)) under the UNA and I (cid:11)|(cid:15) q(cid:18)is the tuple obtained from a by replacing every ai with aξ for the ∼-equivalence class ξ of ai . On the other hand, weaimmediately obtain from (T2, A) |(cid:15) q(a) that q(cid:18)) holds in any model of (T2, A(cid:18)) under the UNA. (cid:2)and q= a(cid:18)(a(cid:18)(aIiFor technical reasons, it will be more convenient for us to adopt the UNA, or, which is the same, to assume that everyABox A contains inequalities ai (cid:11)= a j for all distinct ai , a j occurring in A.4. Semantic criteria of Σ -entailmentIn this section, we give semantic criteria for the language-dependent notions of Σ -entailment in DL-LiteNbool andNhorn. These criteria will be used to classify the notions of Σ -entailment, investigate their robustness properties inDL-Lite1104R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Section 5, provide tight complexity bounds for deciding Σ -entailment in Section 6, and design practical decision proceduresin Section 9. Detailed proofs of all the results are given in Appendix A.2.4.1. Semantic criteria for DL-LiteNboolAccording to Proposition 15, Σ -model entailment implies all the language-dependent variants of Σ -entailment consid-ered in this paper. Thus, to develop model-theoretic characterisations of language-dependent notions of Σ -entailment, wehave to weaken the following condition characterising Σ -model entailment between TBoxes T1 and T2:(model) every model of T1 can be transformed into a model of T2 by changing the interpretation of non-Σ -symbols.We will do this by means of additional modifications of models of T1 when transforming them into models of T2. Ourcriteria have a somewhat syntactic flavour in the sense that they are formulated in terms of types—syntactic abstractions ofdomain elements—realised in models. The advantage of such characterisations is that they can be used directly for designingNdecision algorithms, despite the fact that the underlying models are often infinite, as neither DL-Litehorn hasthe finite model property [45]. Needless to say, however, that the correctness of the type-based characterisations presentedbelow requires model constructions, which can be found in Appendix A.Nbool nor DL-LiteLet Σ be a signature and Q a set of positive natural numbers containing 1. A basic Σ Q -concept B is any concept ofthe form ⊥, (cid:4), Ai , (cid:2) q R, for some Ai ∈ Σ , Σ -role R and q ∈ Q , and by a Σ Q -literal we mean a basic Σ Q -concept or itsnegation. A Σ Q -type is a set t of Σ Q -literals containing (cid:4) and such that the following conditions hold:• for every basic Σ Q -concept B, either B ∈ t or ¬B ∈ t,• if the numbers q < qare both in Q and (cid:2) q(cid:18)(cid:18)R ∈ t then (cid:2) q R ∈ t.(cid:18)are both in Q and ¬((cid:2) q R) ∈ t then ¬((cid:2) q(cid:18)R) ∈ t. Clearly, for every interpretation IIt follows that if the numbers q < qand every point x ∈ (cid:5)I(cid:8)(cid:8) x ∈ CtI (x) =, the set(cid:7)I , C a Σ Q -literal(cid:6)C(1)is a Σ Q -type. Conversely, for each Σ Q -type t with ⊥ /∈ t, there is an interpretation I with a point x such that x ∈ Cforall C ∈ t. In this case we say that t is realised (at x) in I. Thus, Σ Q -types can indeed be regarded as abstractions of domainelements. To avoid syntactic clutter in the examples below we do not include ¬⊥ and (cid:4) in Σ Q -types.IDefinition 19. Given a TBox T , we call a Σ Q -type T -realisable if it is realised in a model of T . A set Ξ of Σ Q -types issaid to be T -realisable if there is a model of T realising all the types from Ξ . We also say that Ξ is precisely T -realisable ifthere is a model I of T realising all the types in Ξ , with every Σ Q -type realised in I being in Ξ .Now, returning back to the characterisation (model) of Σ -model entailment, we see that if I (cid:4)Σ = I(cid:18) (cid:4)Σ —i.e., I(cid:18)isrealise the same Σ Q -types, for everyobtained from I by modifying the interpretation of non-Σ -symbols—then I and I(cid:18)set Q of numerical parameters. Thus, if T1 Σ -model entails T2 then– every T1-realisable Σ Q -type is T2-realisable; moreover,– every precisely T1-realisable set of Σ Q -types is precisely T2-realisable.These two conditions are much more flexible than (model): because of using types as abstractions of domain elements, thedomain of the model is not fixed anymore, and so we can manipulate the domain elements by removing some of them orintroducing new ones. The following two theorems state that these conditions indeed provide the semantic characterisationsof the Σ -entailments we are looking for.For a TBox T , let Q T denote the set of numerical parameters occurring in T , together with number 1.Theorem 20. The following conditions are equivalent for TBoxes T1 and T2 in DL-LiteNbool and a signature Σ :(ceb) T1 Σ -concept entails T2 in DL-Lite(r) every T1-realisable Σ Q T1∪T2 -type is T2-realisable.Nbool;Note that this equivalence is almost trivial if one considers ΣN-types (i.e., types using arbitrary parameters) instead ofΣ Q T1∪T2 -types. Thus, the message here is that it is sufficient to consider only the parameters from Q T1∪T2 .NThe next theorem characterises the remaining language-dependent variants of Σ -entailment for DL-Litebool TBoxes.Theorem 21. The following conditions are equivalent for TBoxes T1 and T2 in DL-LiteNbool and a signature Σ :R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411105(sceb) T1 strongly Σ -concept entails T2 in DL-Lite(qeb) T1 Σ -query entails T2 in DL-Lite(sqeb) T1 strongly Σ -query entails T2 in DL-Lite(pr) every precisely T1-realisable set of Σ Q T1∪T2 -types is precisely T2-realisable.Nbool;Nbool;Nbool;Comparing these two criteria, we see that Σ -concept entailment is ‘local’ in the sense that it refers to a single pointin a model, while Σ -query and strong Σ -concept/query entailments are ‘global’ because all points in a model have to beconsidered.Example 22. To illustrate the criteria, we re-use Examples 6 and 14.(i) Consider first the TBoxes T1, T2 and the signature Σ = {Lecturer, Course} from Example 6. There are exactly fourΣ Q T1∪T2 -types: {¬Lecturer, ¬Course}, {Lecturer, ¬Course}, {¬Lecturer, Course}, {Lecturer, Course}, and all of them areT1-realisable. To see that T1 Σ -concept entails T2 it remains to check that all these types are T2-realisable. On theother hand, the singleton {{Lecturer, ¬Course}} is precisely T1-realisable but not precisely T2-realisable. Thus, T1 doesnot Σ -query entail T2.(ii) Consider the TBoxes T1 and T2 from Example 14: the former states that B is nonempty, while the latter that there is aninjection from A to B. Let Σ = { A, B}. The four Σ Q T1∪T2 -types {¬ A, ¬B}, { A, ¬B}, {¬ A, B}, { A, B} are all Ti -realisable,for i = 1, 2. Thus, T1 Σ -concept entails T2. To see that T1 Σ -query entails T2, let Ξ be a precisely T1-realisable set ofΣ Q T1∪T2 -types. Then there exists t ∈ Ξ with B ∈ t. Take a Σ -interpretation I precisely realising Ξ and such that theset {d ∈ (cid:5)I | t = tI (d)} is countably infinite, for every (of the at most four) t ∈ Ξ . Then there exists an injection fromis either empty or countably infinite. Thus, I can be extended toAis countably infinite and Aa model of T2, and so Ξ is precisely T2-realisable.It is of interest to observe that all models I of T2 precisely realising Ξ = {{ A, ¬B}, { A, B}} are infinite, because Aand Bis a proper subset of (cid:5)II = (cid:5)Ibecause Binto BIIIII.4.2. Semantic criteria for DL-LiteNhornThe language of DL-LiteNhorn does not contain negation; it operates only with basic concepts. Like in the previous section,we use the modifier Σ Q to indicate that a syntactic object is built up using concept and role names from Σ and numericalNhorn is a concept inclusion of the form B 1 (cid:5) · · · (cid:5) Bk (cid:8) B,parameters from Q . For example, a Σ Q -concept inclusion in DL-Litei∈∅ B i is understood as (cid:4), which is a basicwhere B1, . . . , Bk, B are basic Σ Q -concepts. As usual, the empty conjunctionΣ Q -concept for any Σ and Q .(cid:3), which does not include negative literals, by taking:Given a Σ Q -type t, we define its ‘positive part’ t+ = {B ∈ t | B a basic concept}.t+Say that a Σ Q -type t1 is positively contained in a Σ Q -type t2 if tits positive part. Thus, we can (and frequently will) define a Σ Q -type t by giving only its positive part texample of such a definition.Given a TBox T in DL-LiteNhorn and a Σ Q -type t with Σ ⊆ sig(T ) and Q T ⊆ Q , we define the T -closure of t to be theconsists of all basic sig(T )Q -concepts B such that+2 . Clearly, a Σ Q -type is uniquely determined by. Here is a firstsig(T )Q -type, denoted clT (t), in which (clT (t))+⊆ t+1+T |(cid:15)Bk∈t+ Bk (cid:8) B.(cid:3)Nhorn can be checked in polynomial time, it follows that clT (t) can be computed in polynomialSince subsumption in DL-Litetime in the size of T . The following lemma provides a simple standard criterion for T -realisability of types when T is aTBox in DL-LiteNhorn.Proposition 23. Let T be a TBox in DL-LiteNhorn and Σ ⊆ sig(T ). A Σ Q -type t is T -realisable if, and only if, t = clT (t) (cid:4)Σ and ⊥ /∈ t.Here, for a Σ (cid:18)Turning to type-based criteria for Σ -entailment in DL-LiteQ -type t, we denote by t (cid:4)Σ the restriction of t to Σ -concepts, that is, t (cid:4)Σ = {C ∈ t | C a Σ Q -literal}.Nhorn, we first observe that for Σ -concept entailment no newNcriterion is required because it coincides with Σ -concept entailment for DL-Litebool. Thus, we generalise the well-knownresult from propositional logic according to which two propositional Horn theories entail the same Horn formulas if, andonly if, these theories have the same consequences in the class of all propositional formulas.1106R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Theorem 24. The following two conditions are equivalent for TBoxes T1 and T2 in DL-LiteNhorn and a signature Σ :(ceh) T1 Σ -concept entails T2 in DL-Lite(ceb) T1 Σ -concept entails T2 in DL-LiteNhorn;Nbool.Proof. The implication (ceb) ⇒ (ceh) is obvious. To show the converse, suppose that T1 does not Σ -concept entail T2 inNbool. Without loss of generality, we may assume that Σ ⊆ sig(T1) and Σ ⊆ sig(T2). If this is not the case, one canDL-Liteadd A (cid:8) A and ∃P (cid:8) ∃P to T1 and T2, for all A, P ∈ Σ that are not in sig(T1) or sig(T2), respectively. By Theorem 20,there exists a T1-realisable Σ Q T1∪T2 -type t that is not T2-realisable. Consider now the T1- and T2-closures clT1 (t) andclT2 (t) of t. Since t is T1-realisable, we have clT1 (t) (cid:4)Σ = t by Proposition 23. On the other hand, as t is not T2-realisable,Proposition 23 implies that t is properly positively contained in clT2 (t) (cid:4)Σ . Therefore, there is B ∈ clT2 (t) (cid:4)Σ \clT1 (t) (cid:4)Σ suchthatT1 (cid:11)|(cid:15)Bk∈t+ Bk (cid:8) B and T2 |(cid:15)Bk∈t+ Bk (cid:8) B.(cid:3)(cid:3)Since, by definition, sig(Bk) ⊆ Σ for all Bk ∈ t+, T1 does not Σ -concept entail T2 in DL-LiteNhorn. (cid:2)Examples 8 and 11 show that this theorem does not hold for the stronger notions of Σ -entailment. Moreover, for bothDL-LiteNhorn and DL-LiteNbool, none of the stronger notions is equivalent to Σ -concept entailment.The following definition will be used to characterise other Σ -entailments in DL-LiteNhorn:Definition 25. A set Ξ of Σ Q -types is said to be sub-precisely T -realisable if there is a model I of T such that I realisesall the types from Ξ , and every Σ Q -type realised in I is positively contained in a type from Ξ . We also say that Ξ ismeet-precisely T -realisable if there is a model I of T realising all the types from Ξ and such that, for every Σ Q -type trealised in I, Ξt (cid:11)= ∅ and t, where Ξt = {t i ∈ Ξ | t+ ⊆ t+ =(cid:12)}.tt i ∈Ξt+i+iThe notion of meet-precise T -realisability is stronger than the notion of sub-precise T -realisability. Indeed, if I is amodel of T realising all the types from Ξ and meeting the conditions for sub-precise realisability, then for each t realisedin I, we have Ξt (cid:11)= ∅ and so there is t. Thus, t is positively contained in a type from Ξ .(cid:18) ∈ Ξt with t+ ⊆ t(cid:18)+Theorem 26. The following conditions are equivalent for TBoxes T1 and T2 in DL-LiteNhorn and a signature Σ :(qeh) T1 Σ -query entails T2 in DL-Lite(spr) every precisely T1-realisable set of Σ Q T1∪T2 -types is sub-precisely T2-realisable.Nhorn;Theorem 27. The following conditions are equivalent for TBoxes T1 and T2 in DL-LiteNhorn and a signature Σ :(sceh) T1 strongly Σ -concept entails T2 in DL-LiteN(sqeh) T1 strongly Σ -query entails T2 in DL-Litehorn;(mpr) every precisely T1-realisable set of Σ Q T1∪T2 -types is meet-precisely T2-realisable.Nhorn;Example 28. Consider the TBoxes and signature from Example 8. The T1-realisable Σ Q T1∪T2 -types are {¬Lecturer} andN{Lecturer}, and both of them are T2-realisable. Hence T1 Σ -concept entails T2 in DL-Litehorn).The singleton {{Lecturer}} is precisely T1-realisable, but not precisely T2-realisable. Hence T1 does not Σ -query entail T2 inNNbool. However, {{Lecturer}} is sub-precisely T1-realisable and therefore, T1 Σ -query entails T2 in DL-Litehorn. On theDL-LiteNother hand, {{Lecturer}} is not meet-precisely T2-realisable, and so T1 does not strongly Σ -concept entail T2 in DL-Litehorn.Nbool (and therefore, in DL-LiteExample 29. Consider now the TBoxes T1 and T2 and signature Σ = {Male, Female} from Example 11. We show that T1Nstrongly Σ -concept entails T2 in DL-Litehorn. One can readily see that there exist exactly three T1-realisable Σ Q T1∪T2 -types,namely,t1 = {Male, ¬Female},t2 = {¬Male, Female},t3 = {¬Male, ¬Female}.Moreover, there are exactly two sets of Σ Q T1∪T2 -types that are precisely T1-realisable, namely, Ξ1 = {t1, t2} andΞ2 = {t1, t2, t3}. We have to show that Ξ1 and Ξ2 are meet-precisely T2-realisable. This can be seen by taking the in-terpretation I with(cid:5)I = {x, y, z},MaleI = {x},FemaleI = { y},I =id(cid:6)(cid:7)(x, z), ( y, z), (z, z).I is a model of T2 precisely realising Ξ2. Hence, it meet-precisely realises Ξ2. It remains to show that it meet-precisely+realises Ξ1. The only interesting type in Ξ1 is t3 as it is not realised in I. But t1and t= ∅ coincides with the intersection of t+3+2 , as required.R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411107Table 1Comparing the notions of Σ -entailment in DL-LiteNbool and DL-LiteNhorn.Every T1-realisabletype is T2-realisable(cid:24) Thm. 20Σ-concept(cid:24) Thm. 24Prop. 15(i),Ex. 9, 22⇐(cid:15)DL-LiteNbool:DL-LiteNhorn:Σ-conceptProp. 15(i)⇐(cid:15)Every precisely T1-realisable set of types is precisely T2-realisable(cid:24) Thm. 21Σ-query⇓ Ex. 8, 28Σ-query(cid:24) Thm. 26Thm. 21⇐⇒Ex. 28⇐(cid:15)strong Σ-concept⇓ Ex. 11Thm. 21⇐⇒strong Σ-query⇓strong Σ-concept(cid:24) Thm. 27Thm. 27⇐⇒strong Σ-queryProp. 15(ii),Ex. 14⇐(cid:15)Prop. 15(ii),Ex. 14⇐(cid:15)Σ-model(cid:24) def.Σ-modelEvery precisely T1-realisable set of typesis sub-precisely T2-realisableEvery precisely T1-realisable set of typesis meet-precisely T2-realisableTable 1 shows the relative ‘strength’ of the variants of Σ -entailment introduced in Section 3 for the languages DL-LiteNhorn: ⇔ stands for ‘the two notions are equivalent’, (cid:24) for ‘the two notions are equivalent for TBoxes formulatedand DL-Litein the smaller language’, and ⇐ and ⇓ mean that one notion is properly weaker than the other (for TBoxes in the smallerlanguage in case of ⇓).Nbool4.3. Σ -differenceLΣ (T1, T2), qDiffLΣ (T1, T2), scDiffThe semantic criteria formulated above can be used to approximate different variants of Σ -difference between ontolo-gies. When comparing two ontologies with respect to a signature, the ontology engineer needs not only a ‘yes’ or ‘no’answer, but also some informative representation of the difference if the ontologies are different. It is not hard to see thatLΣ (T1, T2) and mDiffΣ (T1, T2) of Σ -differences defined ineach of the sets cDiffSection 3 is either empty or infinite. Thus, only approximations of these sets can be computed in practice. One possibility toobtain such approximations is to exploit the semantic criteria provided above. For example, by the criterion of Theorem 20for Σ -concept difference, the Σ Q T1∪T2 -types that are T1-realisable but not T2-realisable are the obvious candidates forinclusion in such an approximation. For each basic Σ Q T1∪T2 -concept B, these types contain either B itself or its negation.Of course, as there are exponentially many types in the size of Σ and T1 ∪ T2, this method can be unfeasible in practicebecause there can be too many types to analyse and the resulting list can be incomprehensible. For stronger versions ofΣ -difference, one has to consider sets of Σ Q T1∪T2 -types; cf. the criteria of Theorems 21, 26 and 27. A detailed investigationof this approach to representing Σ -differences between ontologies is beyond the scope of this paper; we leave it for futureresearch.LΣ (T1, T2), sqDiff5. Robustness propertiesThe results on Σ -difference and Σ -entailment can easily be misinterpreted if they are not considered in the context ofcertain robustness properties; moreover, the notions of Σ -difference and Σ -entailment themselves are of limited use if theydo not enjoy these properties. In this section, we discuss four types of robustness conditions. First, we consider robustnessunder definitorial extensions of TBoxes and justify our decision to work with essentially positive existential queries ratherthan seemingly more natural positive existential queries. Second, we consider preservation results for Σ -entailment underthe addition of fresh symbols to Σ and analyse robustness of Σ -inseparability and entailment under taking unions ofTBoxes. These two robustness properties are closely related to the interpolation theorem and Robinson’s joint consistencyproperty from mathematical logic. Finally, we consider robustness under extensions of the description logic in questionwith new constructs (which means extensions of the TBox, ABox and query languages). Rather surprisingly, it turns out thatNbool to the very expressive SHIQ and still preservein some important cases one can extend the ‘lightweight’ DL DL-LiteΣ -entailment.An important robustness property not discussed in this section is robustness under replacement, which was introducedin Section 3 as the replacement property and used to justify and explain the strong notions of Σ -difference and entailmentin Definition 10. We will revisit robustness under replacement in the discussion of inseparability modules below.5.1. Robustness under definitorial extensionsconcepts (although negated concepts are not allowed in the case of DL-LiteRecall from Section 2 that in both essentially positive existential queries and ABoxes in DL-LiteNbool we allow negatedNhorn, where we have proper positive existentialNqueries). An alternative approach would be to allow only positive concepts (as in DL-Litehorn) or even concept names. Asmentioned in Remark 2, these two ways are essentially equivalent in the presence of TBoxes. Yet, they give rise to differentnotions of Σ -query entailment. Indeed, if only positive concepts are allowed in queries then the TBox T2 from Example 8 is1108R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141NΣ -query entailed by T1 = ∅, even in DL-Litebool. We argue, however, that it is the essentially positive existential queries thatshould be considered in the context of this investigation. The reason is that, with only positive existential queries allowed,the addition of the definition A ≡ ¬Lecturer to both T1 and T2 and A to Σ would result in the TBoxes T (cid:18)2 and signatureNsuch that T (cid:18)Σ (cid:18)bool. This kind of non-robust behaviour of Σ -query entailment is2 in DL-Liteclearly undesirable.1 does not Σ (cid:18)-query entail T (cid:18)1 , T (cid:18)To be able to speak about all of our (and perhaps some other) notions of entailment and inseparability at the same time,we introduce the following notation. Given a DL L, we use (cid:5) to denote a ternary entailment relation in L, whose argumentsare two ontologies T1 and T2 in L, and a signature Σ . Thus, T1 (cid:5)Σ T2 is a shorthand for ‘T1 Σ -entails T2 in L’. In otherwords, (cid:5) is the collection of the respective Σ -entailment relations for all signatures Σ . Likewise, we use ≡ to denote aternary inseparability relation in L: T1 ≡Σ T2 if, and only if, T1 (cid:5)Σ T2 and T2 (cid:5)Σ T1.Definition 30. An entailment relation (cid:5) in a DL L is called robust under definitorial extensions if, for any signature Σ ,T1 (cid:5)Σ T2 implies T1 ∪ { A ≡ C} (cid:5)Σ∪{ A} T2 ∪ { A ≡ C} whenever A /∈ sig(T1 ∪ T2) and C is a Σ -concept in L.The proof of the following result is straightforward and left to the reader.Theorem 31. All the entailment relations from Section 3 are robust under definitorial extensions in DL-LiteNbool and DL-LiteNhorn.5.2. Robustness under vocabulary extensionsClearly, all our entailment relations are preserved under removing symbols from Σ : T1 (cid:5)Σ T2 implies T1 (cid:5)Σ (cid:18) T2, for anyΣ (cid:18) ⊆ Σ . Obviously, the converse implication does not (and should not) hold in general. However, it turns out that it holdsif only fresh symbols are added to the signature.Definition 32. An entailment (cid:5) in L is robust under vocabulary extensions if T1 (cid:5)Σ T2 implies T1 (cid:5)Σ (cid:18) T2, for any Σ and Σ (cid:18)with Σ (cid:18) ∩ sig(T2) ⊆ Σ .Robustness under vocabulary extensions is of particular importance for Σ -query entailment and the strong versions ofΣ -entailment. For example, it means that if T1 strongly Σ -query entails T2 then, for any ABox A, TBox T and query qcontaining, apart from symbols in Σ , some arbitrary symbols not occurring in T2, we have (T1 ∪ T , A) |(cid:15) q(a) whenever(T2 ∪ T , A) |(cid:15) q(a). This property is critical for applications, as it is hardly possible to restrict ABoxes and context ontologiesto a fixed signature Σ and not permit the use of fresh symbols.Theorem 33. All the entailment relations from Section 3 are robust under vocabulary extensions in DL-LiteNbool and DL-LiteNhorn.Remark 34. Robustness under vocabulary extensions has important consequences for our investigation of the computationalcomplexity of deciding whether a TBox T1 Σ -entails another TBox T2. Namely, since T1 Σ -entails T2 if, and only if, T1Σ (cid:18)-entails T2 for Σ (cid:18) = sig(T2) ∩ Σ , we can always assume that Σ ⊆ sig(T2). Thus, we can take (cid:4)(T1) + (cid:4)(T2) as the size ofthe input (and neglect the size of Σ ) when measuring the size of the input of the decision problem ‘does T1 Σ -entail T2?’Sometimes we will also assume that Σ ⊆ sig(T1) or even Σ = sig(T1). The assumption Σ ⊆ sig(T1) is justified becausewe can always add A (cid:8) A and ∃P (cid:8) ∃P to T1 for all A, P ∈ Σ . We can even work with Σ = sig(T1) because we canuniformly rename all occurrences of concept and role names from sig(T1) \ Σ in T2 by fresh concept and, respectively, rolenames, and work with the resulting TBox T (cid:18)2 instead of T2.5.3. Robustness under joinsApart from the addition of fresh symbols, it is also important to guarantee robustness under certain joins of ontologies.Definition 35. An inseparability relation ≡ in L is robust under joins if, for any TBoxes T , T1 and T2 in L and any signa-ture Σ , we have T ≡Σ T1 ∪ T2 whenever T ≡Σ T1, T ≡Σ T2 and sig(T1) ∩ sig(T2) ⊆ Σ .Robustness under joins is of interest for collaborative ontology development. This property means, for example, that iftwo (or more) ontology developers extend independently an ontology T to ontologies T1 ⊇ T and T2 ⊇ T and do not usecommon symbols apart from those in a certain signature Σ , then they can form the union T1 ∪ T2 without any (potentiallydamaging) additional Σ -consequences, provided that Ti and T are Σ -inseparable, for i = 1, 2.Theorem 36. All the inseparability relations from Section 3 are robust under joins in DL-LiteNbool and DL-LiteNhorn.R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411109Note that instead of the definition given above, one could consider a stronger one by replacing Σ -inseparability withΣ -entailment. More precisely, one could require that for all TBoxes T , T1 and T2 in L and any signature Σ , we have that TΣ -entails T1 ∪ T2 whenever T Σ -entails Ti , for i = 1, 2, and sig(T1) ∩ sig(T2) ⊆ Σ . Unfortunately, this stronger robustnessproperty does not always hold for the inseparability relations from Section 3. We give an example showing this for Σ -concept inseparability (it would be of interest to investigate this stronger notion for other inseparability relations as well,but it is beyond the scope of this paper).Example 37. Let T1 = { A (cid:8) ∃R, ∃RT1 ∪ T2 |(cid:15) A (cid:8) ⊥, and so T does not Σ -concept entail T1 ∪ T2.− (cid:8) B}, T2 = T = {B (cid:8) ⊥}, and Σ = { A, B}. Then T Σ -concept entails Ti , i = 1, 2, butRemark 38. Robustness under vocabulary extensions and robustness under joins have been first introduced in [25]. Thatpaper investigates in detail the relationship between these properties and the well-known Robinson consistency lemma andCraig interpolation property (see, e.g., [46]). For the description logic EL, the two robustness conditions are investigatedin [44]; and for expressive description logics such as ALC and its extensions as well as first-order logic they are investigatedin [25]. Rather interestingly, both robustness under vocabulary extensions and robustness under joins as well as interpolationtypically fail for description logics with nominals and/or role inclusions [47,25].5.4. Robustness under language extensionsAs we have already seen, in general, language-dependent notions of Σ -entailment do depend on the underlying logic:a stronger logic may induce more differences. So it would be natural to expect that our language-dependent notions of Σ -Nbool to more expressive description logics such as ALC or SHIQ. Ratherentailment are not robust under extending DL-LiteNbool (and, therefore, strong Σ -query entailment) is robust undersurprisingly, it turns out that Σ -query entailment in DL-LiteNbool language of queries, ABoxes, and context TBoxes to that of SHIQ. In fact, this result holds for allextending the DL-LiteDLs for which the class of models of TBoxes is closed under disjoint unions (see Appendix A.1 for a definition of disjointunions). We note that typical DLs for which the class of models of TBoxes is not closed under disjoint unions are DLs withnominals and DLs with the universal role.We remind the reader that, compared to DL-LiteNbool, SHIQ allows qualified number restrictions of the form (cid:2) qR.C , roleinclusion axioms R1 (cid:8) R2, and transitivity constraints stating that certain roles are to be interpreted by transitive relations;see [2] for more details. An ABox in SHIQ consists of assertions of the form C(a), where C is a SHIQ-concept, andan (essentially positive existential) query in SHIQ can contain atoms C(t) such that C is a SHIQ-concept. With theseauxiliary definitions at hand we can repeat Definition 10 for L = SHIQ:Definition 39. Let T1 and T2 be TBoxes and Σ a signature. We say that T1 strongly Σ -query entails T2 in SHIQ if, forall TBoxes T , ABoxes A and queries q in SHIQ with sig(T ∪ A ∪ {q}) ⊆ Σ and all tuples a of object names from A,(T2 ∪ T , A) |(cid:15) q(a) implies (T1 ∪ T , A) |(cid:15) q(a).The following result will be proved in Appendix A.3:Theorem 40. For any TBoxes T1 and T2 in DL-Liteentails) T2 in DL-LiteNbool, then T1 strongly Σ -query entails T2 in SHIQ.Nbool and any signature Σ , if T1 Σ -query entails (or, equivalently, strongly Σ -concept6. Complexity of Σ -entailmentNow we investigate the computational complexity of deciding Σ -entailment (and so Σ -inseparability) betweenNhorn TBoxes. A first impression of what one can expect is given by Theorem 17 and the known com-DL-Liteplexity results for deciding Σ -entailment between propositional theories.Nbool and DL-Lite6.1. Lower boundsWe remind the reader that the complexity class Π p2 , also denoted coNPNP, consists of those problems that can be solvedby coNP Turing machines with an NP oracle. A typical example of a Π p2 -complete problem is determining the truth ofquantified Boolean formulas (QBFs, for short) of the form ∀p∃qϕ(p, q), where ϕ(p, q) is a propositional formula built frompropositional variables in the lists p and q (see, e.g., [48,49]). Σ -entailment between propositional theories can be reducedto satisfiability of QBFs of this form. Indeed, let ϕ(p, q) and ψ(r, q) be propositional formulas with disjoint p, q, r andΣ = q. Then ϕ(p, q) Σ -entails ψ(r, q) if, and only if, the QBF ∀q∀p∃r(ϕ(p, q) → ψ(r, q)) is true.The following result is proved in [50] (it can also be proved directly using the discussion in Example 16).Theorem 41. Deciding Σ -entailment between propositional theories is Π pHorn theories is coNP-complete.2 -complete. Deciding Σ -entailment between propositional1110R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141As every propositional theory Φ can trivially be encoded (in linear time) by means of a TBox T such that Φ and T ∗Nhorn whenever Φ is a Horn theory), by Theorems 41 and 17 we obtain theare logically equivalent (with T being in DL-Litefollowing complexity lower bounds:Theorem 42. Deciding Σ -entailment in DL-LiteDL-LiteNhorn is coNP-hard.Nbool is Π p2 -hard for all of our variants of Σ -entailment; deciding Σ -entailment inIt turns out that these lower bounds actually coincide with the upper bounds for deciding language-dependent Σ -Nhorn; we will prove this in Section 6.2. Deciding Σ -model en-entailments (and inseparability) in DL-Litetailment turns out to be a much harder problem. In Section 6.3, we will discuss how to establish decidability of Σ -modelentailment in DL-LiteNbool and show that this problem is coNExpTime-hard.Nbool and DL-LiteRemark 43. For many expressive DLs as well as EL, the computational complexity of certain notions of Σ -entailmentand inseparability is known. Interestingly, even for EL deciding Σ -entailment is typically much harder than for DL-Lite.For example, Σ -concept entailment and Σ -query entailment are both ExpTime-complete for EL [51,44]. (However, for ELTBoxes consisting of (possibly cyclic) concept definitions only, Σ -concept entailment becomes tractable [52].) When movingto more expressive DLs such as ALC and ALCQI, Σ -concept entailment becomes 2ExpTime-complete; for ALCQIO Σ -concept entailment becomes undecidable [24,33]. For expressive DLs such as ALC the complexity Σ -query entailment iscurrently unknown. Σ -model entailment is undecidable for EL (and all its extensions) [51].6.2. Complexity of language-dependent Σ -entailmentsAs we mentioned in Section 2, the satisfiability problem for DL-LiteNhorn KBs it isP-complete (under the UNA). It follows that the problem of deciding whether a type t is T -realisable—that is, whether theNNKB (T , {C(a) | C ∈ t}) is satisfiable—is NP-complete for DL-Litebool and P-complete for DL-Litehorn. We employ this result andthe criterion of Theorem 20 to prove the following:Nbool KBs is NP-complete, while for DL-LiteTheorem 44. Deciding Σ -concept entailment between DL-LiteDL-LiteNhorn TBoxes is coNP-complete.Nbool TBoxes is Π p2 -complete. Deciding Σ -concept entailment betweenProof. Let T1, T2 be TBoxes in DL-LiteΣ ⊆ sig(T1 ∪ T2). By Theorem 20, the following algorithm decides whether T1 does not Σ -concept entail T2:Nbool and Σ a signature. By Remark 34, we may assume without loss of generality that1. Guess a Σ Q T1∪T2 -type t. (Observe that the size of t is quadratic in the size of T1 ∪ T2.)2. Check, by calling an NP-oracle, whether (i) t is T1-realisable and whether (ii) t is not T2-realisable.3. Return ‘T1 does not Σ -concept entails T2’ if the answers to (i) and (ii) are both positive.Clearly, this algorithm runs in Σ p2 , and so the problem of deciding whether T1 does Σ -concept entail T2 is in Π p2 .The same algorithm, calling a P-oracle for DL-LiteTBoxes T1 and T2, whether T1 Σ -concept entails T2 is in coNP. (cid:2)Nhorn TBoxes, runs in NP and so the problem of deciding, given DL-LiteNhornRemark 45. The size of a Σ Q T1∪T2 -type is quadratic in (cid:4)(T1 ∪ T2) because all numbers in Q T1∪T2 occur as numericalparameters in T1 ∪ T2. (Under binary coding of numbers it would be exponential in (cid:4)(T1 ∪ T2) had we included in Q T1∪T2all natural numbers between 1 and the maximal number qmax occurring in the TBoxes.) It follows, in particular, that thecomplexity result above (as well as subsequent results) do not depend on whether numbers are coded in binary or not.We note that it is possible to define types of only linear size in (cid:4)(T1 ∪ T2) serving the same purpose as our typesby considering the numerical parameters for each role separately. To simplify notation, we have refrained from doing so.However, in our experiments described in Section 9 we do precisely that to reduce the size of the QBFs.To check the criterion of Theorem 21 for the other language-dependent variants of Σ -entailment, we should be able toestablish precise realisability of sets of types. The following simple example illustrates the intuition behind the notions weneed to do this.− (cid:8) B, B (cid:8) ∃R}, and suppose that we want to knowExample 46. Let Σ = { A, B}, Q = {1}, T = { A ≡ ∃P , ∃P= {¬ A, B} is T -realisable. In other words, we wouldwhether the set Ξ = {tlike to know whether there is a model I of T with points x0 and x1 such that t⊆ t i = tI (xi), i = 0, 1, where tI (xi) isthe sig(T )Q -type of xi defined by (1). If such I and the xi do exist then, clearly, ∃P ∈ t0 and ∃R ∈ t1, which means thata P -arrow starts from x0 and an R-arrow starts from x1. But then there must exist ‘witness types’ for the ends of these, respectively. By the axioms of T , both ofarrows, that is, some sig(T )Q -types t∃P − and t∃R− containing ∃P− (cid:8) B, ∃R(cid:18)= { A, ¬B} and t1} of the Σ Q -types tand ∃R(cid:18)0, t(cid:18)1(cid:18)0−−(cid:18)iR. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411111Fig. 2. The first three steps of constructing a model realising {t(cid:18)0, t(cid:18)1} by means of unravelling.these types must contain B and ∃R, which again requires a witness type for ∃R, e.g., the same t∃R− . In fact, the types t0,t1, t∃P − and t∃R− are all we need to construct an infinite forest-like model of T realising Ξ and precisely realising the set{t0, t1, t∃P − , t∃R− }. This construction known as ‘unravelling’ (of the appropriate part of I) is shown in Fig. 2.−It is not hard to see that in general, for a TBox with m role names, this unravelling procedure, having started withk types, will produce a model with at most k + 2m distinct types. More precisely, a set Ξ (cid:18)of Σ Q -types is T -realisable(with Σ ⊆ sig(T ) and Q T ⊆ Q ) if, and only if, there is a precisely T -realisable set Ξ of sig(T )Q -types such that (i)|Ξ | (cid:3) |Ξ (cid:18)| + 2m, where m is the number of role names in T , and (ii) each type in Ξ (cid:18)can be extended to a type in Ξ .This example motivates the following definition. Let T be a TBox in DL-Litenatural numbers with Σ ⊆ sig(T ) and Q T ⊆ Q .Nbool, Σ a signature and Q a set of positive} of (k + 1) Σ Q -types, a pair of sequences Ξ T = ((t 0, . . . , tk), (tk+1, . . . , tk+2m)) ofDefinition 47. Given a set Ξ = {t(not necessarily distinct) sig(T )Q -types is called a T -witness for Ξ if m is the number of role names in T and the followingconditions are satisfied:(cid:18)0, . . . , t(cid:18)k(cid:18)i= t i(cid:4)Σ , for 0 (cid:3) i (cid:3) k;(w1) t(w2) each type in the sequence t0, . . . , tk, tk+1, . . . , tk+2m is T -realisable;(w3) for each role name P i in T (1 (cid:3) i (cid:3) m), the types tk+2i−1 and tk+2i are witnesses for ∃P i and ∃P−i, respectively; moreprecisely,∃P i ∈ tk+2i−1and ∃P−i∈ tk+2i wheneverA T -witness Ξ Tis called a precise T -witness for Ξ if(cid:6)∃P−i , ∃P i(cid:7)∩ t j (cid:11)= ∅, for some 0 (cid:3) j (cid:3) k + 2m.(w-pr) for every type t i in the sequence tk+1, . . . , tk+2m, there is a type t(cid:18)j∈ Ξ such that t i(cid:4)Σ = t(cid:18)j .Example 48. In the setting of Example 46, the pair ((t0, t1), (t 0, t∃P − , t1, t∃R− )) is a precise T -witness for Ξ = {t(cid:18)0, t(cid:18)1}.It follows from the definition and the unravelling construction of Example 46 (see also [10]) that we have:Proposition 49.(i) A set Ξ of Σ Q -types is T -realisable if, and only if, there is a T -witness for Ξ .(ii) A set Ξ of Σ Q -types is precisely T -realisable if, and only if, there is a precise T -witness for Ξ .(cid:18)i(cid:18)kIi(cid:18)0, . . . , t(cid:18)Proof. (i) Suppose that Ξ = {ti , i (cid:3) k,there is a sig(T )Q -type t i realised in I and such that t= t i(cid:4)Σ . For each role name P i in T , 1 (cid:3) i (cid:3) m, we have eitherI= ∅. In the former case, we take tk+2i−1 and tk+2i to be some sig(T )Q -types realised in I and containing(cid:11)= ∅ or PPi−, respectively. In the latter case, we can define tk+2i−1 and tk+2i to be some sig(T )Q -types realised in I. It is∃P i and ∃Pireadily checked that ((t 0, . . . , tk), (tk+1, . . . , tk+2m)) is a T -witness for Ξ .} is T -realisable. Take a model I of T realising Ξ . Then, for each Σ Q -type tConversely, assume that ((t 0, . . . , tk), (tk+1, . . . , tk+2m)) is a T -witness for Ξ . We construct a model I of T preciselyis an arbitrary countably infinite set. Take some surjective function f : (cid:5)I →in such a way that, forif, and only if, B ∈ f (x). Such an interpretation function can be definedis the set of natural numbers. For the basis of induction, weif, and only if, A ∈ f (0), for every concept name A. Given a role R, let q be maximal with (cid:2) q R ∈ f (0). Ifrealising the set {t0, . . . , tk+2m}. Its domain (cid:5)I{t0, . . . , tk+2m} with infinite fevery basic sig(T )Q -concept B, we have x ∈ Binductively as in the unravelling construction. Suppose (cid:5)Iset 0 ∈ A−1(t i), for every i (cid:3) k + 2m, and define an interpretation function ·III1112R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141− ∈ f (ni), 1 (cid:3) i (cid:3) q. (Such numbers exist in view of (w3).) Then we set (0, ni) ∈ Rq = 0, we do nothing. Otherwise, we take q numbers n1, . . . , nq which have not been involved in the construction yet andsuch that ∃R. In the induction step, wedo the same with the next number n but taking into account that there may be already (at most) one incoming R-arrow-successors of n in I, where q (cid:2) 1(l, n) ∈ R− ∈ f (n). To see that the constructed interpretation I is a model of T , it suffices to recall that allis maximal with (cid:2) q Rthe types t i are T -realisable by (w2). Indeed, if I (cid:11)|(cid:15) T then there are some C (cid:8) D ∈ T and x ∈ (cid:5)Iandx /∈ D, for some R and l < n, in which case we need only (q − 1)-many fresh R, in which case the type f (x) cannot be T -realisable.such that x ∈ C−IIIIThe proof of (ii) is similar and left to the reader. (cid:2)Recall now that, by Theorem 21, to check whether T1 Σ -query entails T2, we have to verify the condition:(pr) every precisely T1-realisable set of Σ Q T1∪T2 -types is precisely T2-realisable.The unravelling construction illustrated in Example 46 and Proposition 49 indicate, however, that instead of consideringarbitrary T1-realisable sets of Σ Q T1∪T2 -types, we can deal with T1-witnesses generated by a single Σ Q T1∪T2 -type only.More precisely, we can simplify (pr) to the following criterion:Theorem 50. T1 Σ -query entails T2 in DL-LiteNbool if, and only if, the following condition holds:(cid:18)(pr) for every Σ Q T1∪T2 -type t, if there is a T1-witness ((t 0), (t1, . . . , t2m1 )) for {t}, then there is a precise T2-witness for the set{t0(cid:4)Σ , t1(cid:4)Σ , . . . , t2m1(cid:4)Σ }, where m1 is the number of role names in T1.(cid:18)Proof. (pr) ⇒ (prset {t0(cid:4)Σ , t1(cid:4)Σ , . . . , t2m1it has a precise T2-witness.). It follows from the proof of Proposition 49 that if ((t 0), (t1, . . . , t2m1 )) is a T1-witness for {t} then the(cid:4)Σ } is precisely T1-realisable. By (pr), this set is precisely T2-realisable, and so, by Proposition 49,(cid:18)(pr) ⇒ (pr). Suppose now that a set Ξ = {t} of Σ Q T1∪T2 -types is precisely T1-realisable. By Proposi-tion 49, there exists a precise T1-witness Ξ T1 = ((t 0, . . . , tk), (tk+1, . . . , tk+2m1 )) for Ξ . Then, clearly, the sequences((t i), (tk+1, . . . , tk+2m1 )) are T1-witnesses for the singletons {t i}, 0 (cid:3) i (cid:3) k. According to (pr) and Proposition 49, there(cid:4)Σ } ⊆ Ξ . Now, define an interpretation I asare models Ji of T2 precisely realising the sets Ξi = {t i(cid:4)Σ , tk+1(cid:4)Σ , . . . , tk+2m1the disjoint union of the Ji (a precise definition is given in Appendix A.1). Asi=0 Ξi = Ξ , it is easy to see that I is amodel of T2 precisely realising Ξ . (cid:2)(cid:13)k(cid:18)(cid:18)0, . . . , t(cid:18)kNote that the size of witnesses mentioned in condition (pr) is polynomial in the size of T1 and T2: the T1-witnesscontains 1 + 2m1 types and the T2-witness 1 + 2m1 + 2m2 types, where mi is the number of roles names in Ti , i = 1, 2, witheach type being quadratic size in the size of T1 and T2. Thus, for every t, condition (pr) can be checked in non-deterministicpolynomial time; for more details, consult Section 9.1. We will use this observation to construct a Π p2 algorithm decidingNΣ -query and the strong forms of entailment between DL-Litebool TBoxes. But before that let us see how to modify theNnotions of witnesses for DL-Litehorn TBoxes.(cid:18)(cid:18)Definition 51. Given a TBox T in DL-LiteT -witness Ξ T = ((t0, . . . , tk), (tk+1, . . . , tk+2m)) for Ξ satisfying the following condition:Nhorn and a set Ξ of Σ Q -types, by a sub-precise T -witness for Ξ we understand any(w-spr) for every type t i in the sequence tk+1, . . . , tk+2m, there is a type t(cid:18)j∈ Ξ such that t+(cid:4)Σ ⊆ (ti(cid:18)j)+.A meet-precise T -witness for Ξ is any T -witness Ξ T = ((t0, . . . , tk), (tk+1, . . . , tk+2m)) for Ξ such that(w-mpr) for every type t i in tk+1, . . . , tk+2m, the set Ξt i= {t(cid:18)j∈ Ξ | t+(cid:4)Σ ⊆ (ti(cid:18)j)+} is nonempty and t+(cid:4)Σ =i(cid:12)t(t(cid:18)j)+.(cid:18)j∈ΞtiIt follows from the definition and the unravelling construction that we have:Proposition 52. For a TBox T in DL-LiteNhorn,(i) a set Ξ of Σ Q -types is sub-precisely T -realisable if, and only if, there is a sub-precise T -witness for Ξ .(ii) a set Ξ of Σ Q -types is meet-precisely T -realisable if, and only if, there is a meet-precise T -witness for Ξ .Since realisability of a single type with respect to a TBox in DL-LiteNhorn can be checked in deterministic polynomial timeand the number of types in witnesses is linear in the number of roles (and thus, in the length of the TBox), one can checkwhether a given set has a precise (or sub- or meet-precise) witness and compute it in polynomial time (a proof can befound in Appendix A.4):R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411113Lemma 53. There is an algorithm which, given a TBox T in DL-Liteistic polynomial time whether Ξ has a precise, sub-precise or meet-precise T -witness and constructs such a witness if it exists.Nhorn and a set Ξ of Σ Q -types with Q ⊇ Q T , decides in determin-Similarly to Theorem 50, conditions (spr) and (mpr) of Theorems 26 and 27 can be equivalently reformulated in termsof sub- and meet-precise witnesses:Theorem 54.(i) T1 Σ -query entails T2 in DL-LiteNhorn if, and only if, the following condition holds:(spr(cid:18)) for every Σ Q T1∪T2 -type t, if there is a T1-witness ((t 0), (t 1, . . . , t2m1 )) for {t} then there is a sub-precise T2-witness forthe set {t0(cid:4)Σ , t1(cid:4)Σ , . . . , t2m1(ii) T1 strongly Σ -query entails T2 in DL-LiteNhorn if, and only if, the following condition holds:(cid:18)) for every Σ Q T1∪T2 -type t, if there is a T1-witness ((t 0), (t1, . . . , t2m1 )) for {t} then there is a meet-precise T2-witnessfor the set {t0(cid:4)Σ , t1(cid:4)Σ , . . . , t2m1(cid:4)Σ }, where m1 is the number of role names in T1;(cid:4)Σ }, where m1 is the number of role names in T1.(mprWe are now in a position to obtain the following tight complexity results:Theorem 55.(i) Deciding Σ -query (and so strong Σ -concept and strong Σ -query) entailment between DL-Lite(ii) Deciding Σ -query, strong Σ -concept and strong Σ -query entailments between DL-LiteNbool TBoxes is Π pNhorn TBoxes is coNP-complete.2 -complete.Proof. (i) Let T1, T2 be TBoxes in DL-Litethat Σ ⊆ sig(T1 ∪ T2). By Theorem 50, the following algorithm decides whether T1 does not Σ -query entail T2:Nbool and Σ a signature. By Remark 34, we may assume without loss of generality1. Guess a Σ Q T1∪T2 -type t.2. Check, by calling an NP-oracle, whether (a) there is a precise T1-witness ((t 0), (t1, . . . , t2m1 )) for {t} and (b) there is noprecise T2-witness for {t0(cid:4)Σ , t1(cid:4)Σ , . . . , t2m1(cid:4)Σ }.3. Return ‘T1 does not Σ -query entails T2’ if the answers to (a) and (b) are both positive.This algorithm runs in Σ p2 , and so the problem of deciding whether T1 Σ -query entails T2 is in Π p2 .(ii) Here we use a similar algorithm, calling a P-oracle of Lemma 53 to compute for a given set of types a sub-precise ormeet-precise T2-witness. This algorithm clearly runs in NP. (cid:2)6.3. Decidability of Σ -model entailmentIn this section, we show that Σ -model entailment between TBoxes in DL-LiteNhorn is decidable, butcoNExpTime-hard. The decidability proof is by embedding in the two-sorted first-order theory of Boolean algebras (BA)combined with Presburger arithmetic (PA) for representing cardinalities of sets. The decidability of this theory, called BAPA,has been first proved in [53]. The computational complexity and practical algorithms for BAPA have been investigatedin [54]. The coNExpTime lower bound is proved by reduction of the model conservativity problem for the modal logic S5,which is known to be coNExpTime-complete [55]. As reasoning in BAPA is known to be harder than coNExpTime and ourencoding is exponential in the worst case, the precise computational complexity of Σ -model entailment remains open. Wewill provide a brief discussion of the feasibility of using Σ -model entailment in practice at the end of this section.Nbool and DL-LiteLet us begin by expanding Example 14 and showing that uncountable models have to be considered when decidingΣ -model entailment.Example 56. Let T1 be a DL-LiteNhorn TBox stating, using auxiliary role names R and R B , that a concept B is infinite:T1 =−BFor T2 we take the same TBox as in Example 14 stating that P is an injection from A to B:(cid:8) B, B (cid:8) ∃R B , (cid:2) 2 R− (cid:8) ∃R B , ∃R(cid:4) (cid:8) ∃R, ∃R(cid:8) ⊥, ∃R− (cid:5) ∃R−B−B.(cid:7)(cid:8) ⊥T2 =A ≡ ∃P , ∃P− (cid:8) B, (cid:2) 2 P (cid:8) ⊥, (cid:2) 2 P(cid:7)− (cid:8) ⊥.(cid:6)(cid:6)ILet Σ = { A, B}. There exists an uncountable model I of T1 with uncountable Ano injection from Ahowever, that if I is a countably infinite model of T1, then there is always an injection from Athere exists a model I(cid:18)T2 for any of the language-dependent notions of Σ -entailment.. Thus, there is, and so I(cid:4)Σ ∈ mDiffΣ (T1, T2) and T1 does not Σ -model entail T2. It is of interest to observe,. Thus, in this caseof T2 that coincides with I on Σ . Using our semantic criteria, it is readily checked that T1 Σ -entailsand at most countable Bto Bto BIIIII1114R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141This example shows that to decide Σ -model entailment we have to reason effectively about (possibly infinite) cardi-nalities of sets and, of course, basic set-theoretic operations such as intersection and complement. BAPA is a two-sortedfirst-order language designed precisely for this purpose.Formally, the language of BAPA is defined as follows. Its terms of sort set are constructed from variables X1, X2, . . . andconstants 0 (the empty set) and 1 (the whole set) using the binary function symbols ∩ (intersection), ∪ (union), and· (complement). The terms of sort number are constructed from variables x1, x2, . . . , constantsthe unary function symbolfrom the set K = {0, 1, 2, . . .} for natural numbers, and expressions |B|, for B a term of sort set, using the binary functionsymbol +. As usual, we prefer the infix notation for the binary function symbols and write, e.g., X ∩ Y instead of( X, Y ).Atomic BAPA formulas are of the form:(cid:12)– B1 = B2 and B1 ⊆ B2, where B1 and B2 are terms of sort set;– |B| = k and |B| (cid:2) k, where B is a term of sort set and k a term of sort number;– k1 (cid:3) k2, where k1 and k2 are of sort number.BAPA formulas are now constructed in the standard way using first-order quantification (for variables of sort set and number),conjunction and negation.We are interested in the validity of BAPA formulas in two-sorted relational structures, called BAPA structures, of the form(cid:4)(cid:4)(cid:5)(cid:4)A =2(cid:5), ∩, ∪, · , ∅, (cid:5),card((cid:5)), +, 0, 1, 2, . . .(cid:5)(cid:5), | · |,where (2(cid:5), ∩, ∪, · , ∅, (cid:5)) is the Boolean algebra of subsets of a nonempty set (cid:5), card((cid:5)) is the set of cardinal numbers{κ | κ (cid:3) |(cid:5)|}, and |B| is the cardinality of a subset B of (cid:5). A BAPA model M consists of a BAPA structure A, an interpretation∈ {n | n (cid:3) |(cid:5)|} of the variables xi of sortXMinumber as cardinal numbers that are not greater than the cardinality of (cid:5). (Our use of exactly the same symbols in BAPAformulas and BAPA structures is deliberate and should ease the presentation.)⊆ (cid:5) of the variables Xi of sort set as subsets of (cid:5), and an interpretation xMiDecidability of validity of BAPA formulas follows from [53]:Theorem 57. The problem whether a BAPA sentence is true in all BAPA models is decidable.In fact, it follows from [54] that the validity problem for BAPA sentences is in 2ExpSpace. We now give a reduction ofNbool to validity of BAPA sentences. As BAPA does not have binary relation symbols, the mainΣ -model entailment in DL-Liteproblem is to encode the truth conditions for number restrictions (cid:2) q R as BAPA sentences.Nbool and a signature Σ are given. By Remark 34, we may assume without lossSuppose that TBoxes T1 and T2 in DL-Liteof generality that Σ = sig(T1).For every basic concept B occurring in T1 ∪ T2, we take a BAPA variable X B of sort set and then, for every concept C inthe signature of T1 ∪ T2, define inductively a BAPA term C s of sort set:B s = X B ,⊥s = 0,(cid:4)s = 1,(¬C)s = (C)s,(C1 (cid:5) C2)s = C s1∩ C s2.We also set, for i = 1, 2,(cid:8)(cid:6)(cid:8) C1 (cid:8) C2 ∈ Ti⊆ C s2C s1T si=(cid:7).As a first approximation, we can try and translate the problem whether T1 Σ -model entails T2 as the validity problemfor the BAPA sentences of the form(cid:10)(cid:9) (cid:10)∀Xα → ∃Y(cid:11)α,(2)α∈T s1α∈T s22 but not in T swhere X is the sequence of variables of sort set occurring in T s1 and Y is the sequence of variables of sort set that occur1 . This sentence is supposed to convey the meaning of ‘T1 Σ -model entails T2’ for Σ = sig(T1): everyin T sΣ -model of T1 can be extended to a model of T2 (cf. Definition 13). The problem, however, is that our encoding does nottake into account the semantics of number restrictions.Let qmax be the maximal numerical parameter occurring in T1 ∪ T2; if there are no such parameters then we set qmax = 0.For every role name P in T1 ∪ T2, we introduce two sets of additional fresh variables of sort set: for R ∈ {P , P−}, setXR = { X=q R | 0 (cid:3) q (cid:3) qmax} ∪ { X>qmax R }.Intuitively, we want X=q R to stand for the set of points with precisely q R-successors, and X>qmax R for the set of pointswith more than qmax R-successors. To ensure this, we first add to T sthe following (obviously sound) equations, for everyi−}:role name P in Ti and R ∈ {P , PR. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411115(cid:18) = 0, for any two distinct X, X– X ∩ X– X=0 R ∪ · · · ∪ X=qmax R ∪ X>qmax R = 1;– X(cid:3)q R = X=q R ∪ X=(q+1) R ∪ · · · ∪ X=qmax R ∪ X>qmax R , for every basic concept (cid:2) q R in Ti .(cid:18) ∈ XR ;The resulting sets of BAPA sentences will be denoted by T s,eof the interpretations of variables in XP and Xo(cid:16)(d) = |{d(cid:18)) ∈ (cid:16)}|; the (cid:16)-indegree of d is i(cid:16)(d) = |{d(cid:18) | (d, d(cid:18) | (d(cid:18), d) ∈ (cid:16)}|.. It remains to formulate relationships between the cardinalityP − . For a binary relation (cid:16), define the (cid:16)-outdegree o(cid:16)(d) of a point d asiDefinition 58. Let qmax (cid:2) 0 be a natural number. A set-systemS = ( A1, . . . , Aqmax , A∞), (B1, . . . , Bqmax , B∞)consists of two finite sequences of sets such that the sets in each sequence are mutually disjoint. A binary relation (cid:16) iscalled a solution to S if– Aq is the set of points of (cid:16)-outdegree q, for 1 (cid:3) q (cid:3) qmax, A∞ is the set of points of (cid:16)-outdegree > qmax;– Bq is the set of points of (cid:16)-indegree q, for 1 (cid:3) q (cid:3) qmax, B∞ is the set of points of (cid:16)-indegree > qmax.The following result will be proved in Appendix A.4.Lemma 59. For every role name P and every number qmax (cid:2) 1, one can construct a BAPA formula ϕP ,qmax with free variablesX=1 P , . . . , X=qmax P , X>qmax P , X=1 P − , . . . , X=qmax P − , X>qmax P −such that, for every BAPA model M, the following conditions are equivalent:(i) M |(cid:15) ϕP ,qmax ;(ii) the set-system ( XM=1 P , . . . , XM=qmax P , XM>qmax P ), ( XM=1 P − , . . . , XM=qmax P − , XM>qmax P − ) has a solution.Given this lemma, we can rectify (2) in a straightforward way. Let X be the sequence of variables of sort set occurringbut not in X . Then we define a BAPA formulaand let Y be the sequence of variables of sort set occurring in T s,e2in T s,e1ϕT1,T2 by takingϕT1,T2= ∀X(cid:9)(cid:9) (cid:10)(cid:10)α ∧α∈T s,e1P ∈sig(T1)(cid:11)ϕP ,qmax→ ∃Y(cid:9) (cid:10)(cid:10)α ∧(cid:11)(cid:11)ϕP ,qmax,α∈T s,e2P ∈sig(T2)if qmax > 0 and ϕT1,T2 has the form (2) if qmax = 0. Now, one can prove the following reduction theorem (the proof is givenin Appendix A.4).Theorem 60. Let Σ = sig(T1). Then T1 Σ -model entails T2 if, and only if, ϕT1,T2 is valid.It follows from Remark 34 and the decidability of BAPA that Σ -model entailment is decidable. The formula ϕP ,qmax con-structed in the proof of Lemma 59 is exponential in qmax, and so the upper bound for the computational complexity of de-ciding Σ -model entailment, obtained from this reduction, is ‘disappointing’ 4ExpSpace (if qmax is coded in binary). In Appen-dix A.4 we establish, using a reduction of the model conservativity problem for modal logic S5, the following lower bound:Theorem 61. Deciding Σ -model entailment for TBoxes in DL-Litehard.Nhorn with maximal numerical parameter qmax = 3 is coNExpTime-Finding tight complexity bounds for deciding Σ -model entailment remains an open problem that is beyond the scope ofthis paper. As the encoding of Σ -model entailment into BAPA uses only very little arithmetic (exhibited in the constructionof ϕP ,qmax in the proof of Lemma 59), we conjecture that the complexity is actually between coNExpTime and ExpSpace. It isimportant to note that the formula ϕP ,qmax constructed in Lemma 59 is of polynomial size if the maximal parameter qmax isfixed. This appears to be a natural assumption, as in many cases number restrictions are only used to introduce functionalroles. It would be of interest to conduct experiments for such TBoxes and Σ -model entailment using the encoding intoBAPA above and, say, the BAPA reasoner introduced in [54].7. Inseparability modulesIn this section, we discuss how the notions of Σ -inseparability can be employed to define modules, analyse relationshipsbetween modules, and design module extraction algorithms. Intuitively, a module of a TBox T is a subset M of T that says1116R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141the same about a certain subject matter as the whole T . Assuming that subject matters are represented by signatures Σand that ‘saying the same about Σ ’ is formalised as being Σ -inseparable, we come to modules that are Σ -inseparable fromthe TBoxes containing them.Many interesting properties of such modules and even module extraction algorithms can be described without refer-ring to a particular notion of Σ -inseparability, but only using certain properties of inseparability relations. So, like inSection 5, we will consider some abstract notion ≡ of inseparability relation in a DL L, which covers all the variants ofΣ -inseparability introduced above, and develop the corresponding notions of modules within this framework. One obviousNproperty of ≡ we need is that it is an equivalence relation. As before, we assume that L is one of the logics DL-Litebool orDL-LiteNhorn.Definition 62. We call an inseparability relation ≡ in L monotone if it satisfies the following two conditions, for all TBoxesT1 and T2 in L and all signatures Σ :(Msig) for any Σ (cid:18) ⊆ Σ , if T1 ≡Σ T2 then T1 ≡Σ (cid:18) T2;(MT) for any TBox T in L, if T1 ⊆ T ⊆ T2 and T1 ≡Σ T2, then T ≡Σ T1.Condition (Msig) formalises the intuition that if two TBoxes are Σ -inseparable then they are Σ (cid:18)-inseparable for any; (MT) demands that any TBox sandwiched between two inseparable TBoxes should be inseparablesmaller signature Σ (cid:18)from either of them. The following statement is left to the reader as an easy exercise.Theorem 63. All the inseparability relations in DL-LiteNbool and DL-LiteNhorn from Section 3 are monotone.We now introduce and discuss three notions of modules induced by an inseparability relation. The first one formalisesthe intuition discussed above, whereas the other two take into account some additional properties one might want modulesto have.Definition 64. Let ≡ be an inseparability relation in L, T a TBox in L, M ⊆ T , and Σ a signature. We say that M is– a ≡Σ -module of T if M ≡Σ T ;– a self-contained ≡Σ -module of T if M ≡Σ∪sig(M) T ;– a depleting ≡Σ -module of T if ∅ ≡Σ∪sig(M) T \ M.M is a minimal (self-contained, depleting) ≡Σ -module of T if M is a (self-contained, depleting) ≡Σ -module of T , but noproper subset of M is such a (self-contained, depleting) ≡Σ -module of T .The main feature of self-contained ≡Σ -modules is that they are indistinguishable from the original TBox not only withrespect to Σ but also with respect to their own signature. Such a module is self-contained in the sense that the originalTBox does not imply any extra consequences for the module’s signature. It follows from the definition that if ≡ satisfies(Msig), which is the case for all of our inseparability relations, then every self-contained ≡Σ -module is also a ≡Σ -module.Depleting modules emphasise a different aspect of modularity: to be a depleting module, it is required that the TBox withoutthe module does not imply any non-tautological consequences for Σ and the module’s signature. We will see below thatunder certain conditions for the inseparability relation this implies being a self-contained module.However, in general, no non-trivial inclusions between these types of modules exist.Example 65. (i) Let T = { A (cid:8) B, B (cid:8) A} and Σ = {E}. Then M = { A (cid:8) B} is clearly a ≡Σ -module of T , for every inseparabil-ity relation ≡ introduced in Section 3. On the other hand, M is not a self-contained ≡Σ -module of T for any inseparabilityrelation ≡ from Section 3 because T |(cid:15) B (cid:8) A, M (cid:11)|(cid:15) B (cid:8) A, and A, B ∈ sig(M).(ii) To show that not all self-contained ≡Σ -modules are depleting ≡Σ -modules, consider T = { A (cid:8) B, A (cid:8) B (cid:5) B} andΣ = { A, B}. Then M1 = { A (cid:8) B} and M2 = { A (cid:8) B (cid:5) B} are self-contained ≡Σ -modules, but T itself is the only depleting≡Σ -module of T , for any inseparability relation ≡ introduced in Section 3.A more interesting example is needed to show that not all depleting ≡cΣ -modules are (self-contained) ≡cΣ -modules,where ≡cΣ is the Σ -concept inseparability relation in DL-LiteNbool.Example 66. Consider the following modification of Example 6. Let Σ = {Lecturer, Course} andT =(cid:6)Lecturer (cid:8) ∃teaches, ∃teachesThen M = {Course (cid:8) ⊥} is a depleting ≡c≡cΣ -module) of T because T |(cid:15) Lecturer (cid:8) ⊥.(cid:7)− (cid:8) Course, Course (cid:8) ⊥Σ -module of T . However, M is not a ≡c.Σ -module (and so not a self-containedR. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411117Before investigating the relationship between self-contained and depleting modules further, we present a straightforwardalgorithm extracting one minimal ≡Σ -module from a given TBox, using an oracle deciding the inseparability relation ≡.Theorem 67. Let ≡ be an inseparability relation in L satisfying (MT), T a TBox in L and Σ a signature. Then the following algorithmcomputes a minimal ≡Σ -module of T :input T , ΣM := T ;for each α ∈ M doif M \ {α} ≡Σ M then M := M \ {α}end foroutput MProof. By (MT), the algorithm computes a ≡Σ -module M of T such that M \ {α} is not an ≡Σ -module of T , for anyα ∈ M. Again by (MT), no proper subset of such an M is a ≡Σ -module. (cid:2)Note that the minimal ≡Σ -module extracted by this algorithm depends on the order of picking the axioms α and thatin principle there may be exponentially many distinct minimal ≡Σ -modules of the same TBox.Example 68. Consider the following generalisation of the TBox from Example 65: for n (cid:2) 0, letTn = { Ai (cid:8) B i, Ai (cid:8) B i (cid:5) B i | i (cid:3) n},and let Σn = { Ai, B i | i (cid:3) n}. Then any M ⊆ Tn containing either Ai (cid:8) B i or Ai (cid:8) B i (cid:5) B i , for each i (cid:3) n, is clearly a minimal≡c-module of Tn, and the number of such modules is 2n.ΣnWe now investigate modules induced by inseparability relations that satisfy the replacement property (replace) consideredin Section 3. For the convenience of the reader, we give the definition again.Definition 69. An inseparability relation ≡ in L is robust under replacement if, for all TBoxes T , T1 and T2 in L and allsignatures Σ , we have T1 ∪ T ≡Σ T2 ∪ T whenever T1 ≡Σ T2 and sig(T ) ⊆ Σ .As explained in Section 3, robustness under replacement is fundamental for ontology re-use. Taken together with ro-bustness under vocabulary extensions and having defined the notion of a module, its importance can now be justified in asuccinct and precise way. Suppose that an ontology developer imports a ≡Σ -module M of a TBox T into her own TBox O.If ≡ is robust under replacement and vocabulary extensions, then O ∪ T ≡Σ (cid:18) O ∪ M, for every signature Σ (cid:18)such thatΣ (cid:18) ∩ sig(T ) ⊆ Σ and sig(T ) ∩ sig(O) ⊆ Σ (cid:18). (To show this, observe that by robustness under vocabulary extensions we haveT ≡Σ (cid:18)∪sig(O) M. Thus, by robustness under replacement, O ∪ T ≡Σ (cid:18)∪sig(O) O ∪ M.) It follows that these robustness proper-ties ensure that it does not make any difference, as far as such a signature Σ (cid:18)is concerned, whether she imports the wholeT or some ≡Σ -module M of T into O. Moreover, these properties only depend on the signature of O and can be checkedby considering only T and M.The following result summarises what has already been shown in Examples 9 and 11 or follows from the correspondingtheorems on the equivalence of inseparability notions.Theorem 70.(i) The following inseparability relations are not robust under replacement: Σ -concept inseparability in DL-Liteand Σ -query inseparability in DL-LiteNhorn.(ii) The following inseparability relations are robust under replacement: Σ -query inseparability in DL-LiteNbool and DL-LiteNhorn as well as Σ -model inseparability.strong Σ -query inseparability in DL-LiteNbool, and Σ -conceptNbool, strong Σ -concept andWe now give two more reasons explaining the importance of robustness under replacement.Theorem 71. If an inseparability relation ≡ in L is robust under replacement, then every depleting ≡Σ -module is a self-contained≡Σ -module.Proof. If T \ M ≡Σ∪sig(M) ∅, robustness under replacement implies T = (T \ M) ∪ M ≡Σ∪sig(M) ∅ ∪ M = M. (cid:2)Thus, the reason why depleting ≡cΣ -modules are not always self-contained ≡cΣ -concept inseparability relation ≡c is not robust under replacement.Σ -modules (cf. Example 66) is that the1118R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Theorem 72. Let ≡ be a monotone inseparability relation in L that is robust under replacement, T a TBox in L and Σ a signature.Then there is a unique minimal depleting ≡Σ -module of T , which can be computed by the following algorithm:input T , ΣM := ∅;W := ∅;while (T \ M) (cid:11)= W dochoose α ∈ (T \ M) \ WW := W ∪ {α};if W (cid:11)≡Σ∪sig(M) ∅ thenM := M ∪ {α};W := ∅endifend whileoutput MProof. Let M be a depleting ≡Σ -module of T , i.e., T \ M ≡Σ∪sig(M) ∅. We first prove the following:Claim. For all signatures Σ (cid:18)with Σ ⊆ Σ (cid:18) ⊆ Σ ∪ sig(M), if M0 ⊆ T is a minimal set with M0 (cid:11)≡Σ (cid:18) ∅, then M0 ⊆ M.Proof of claim. Suppose the claim does not hold, i.e., M0 (cid:11)⊆ M. Then we must have X ≡Σ (cid:18) ∅, where X = M ∩ M0 (forotherwise X is a proper subset of M0 with X (cid:11)≡Σ (cid:18) ∅, contrary to the minimality of M0). As M is a depleting Σ -moduleand sig(X ) ⊆ sig(M), by robustness under replacement, (T \ M) ∪ X ≡Σ∪sig(M) X . Using Σ (cid:18) ⊆ Σ ∪ sig(M), (Msig), andtransitivity of ≡Σ (cid:18) , we obtain from X ≡Σ (cid:18) ∅ that (T \ M) ∪ X ≡Σ (cid:18) ∅. By (MT), we obtain from ∅ ⊆ M0 ⊆ (T \ M) ∪ Xthat M0 ≡Σ (cid:18) ∅, which is a contradiction. (cid:2)Using this claim, one can easily prove by induction that each M computed during a run of the algorithm of Theorem 72on input T and Σ is contained in every depleting ≡Σ -module of T . Hence, its output M is contained in every depleting≡Σ -module of T . On the other hand, by the termination condition of the algorithm, this M is a depleting ≡Σ -module ofT (when the algorithm terminates, T is partitioned into M and W with the latter being Σ ∪ sig(M)-inseparable from ∅).Consequently, M is the unique minimal depleting ≡Σ -module of T . (cid:2)The algorithm above computes the minimal depleting ≡Σ -module in time quadratic in the number of concept inclusions|T | in T by calling the oracle deciding the inseparability relation ≡ at most |T |2 times.It follows that minimal depleting modules have the advantage of being uniquely determined (under mild conditions),which sharply contrasts with the behaviour of the other types of modules. Another advantage is that depleting modulessupport modular ontology development in the following sense. Suppose M is a depleting ≡Σ -module of T and ≡ is robustunder replacement and vocabulary extensions. Then one can import into the ontology T \ M any module M(cid:18)such thatsig(M(cid:18)) ∩ sig(T ) ⊆ Σ ∪ sig(M) and be sure that T \ M does not interfere with M(cid:18)—i.e., (T \ M) ∪ M(cid:18) ≡Σ (cid:18) M(cid:18)wheneverΣ (cid:18) ∩ sig(T \ M) ⊆ Σ ∪ sig(M). The importance of this property was first pointed out in [1].In the following illustrative example we compute three kinds of modules in DL-Lite– minimal Σ -concept inseparability modules (MCM),– minimal Σ -query inseparability modules (MQM), and– minimal depleting Σ -query inseparability modules (MDQM).These abbreviations will be also used in Section 9.Example 73. Consider the following DL-LiteNbool TBox T :Nbool:− (cid:8) Distributor,(1) Publisher (cid:8) ∃pubHasDistrib,(2) ∃pubHasDistrib(3) Publisher (cid:8) ¬Distributor,(4) ∃pubHasDistrib (cid:8) Publisher,(5) Publisher (cid:8) (cid:3) 1 pubHasDistrib,(6) Role (cid:8) ¬Distributor,(7) User (cid:8) ¬Distributor,− (cid:8) AdmUser (cid:7) BookUser,(8) Publisher (cid:8) ∃pubAdmedBy,(9) ∃pubAdmedBy(10) AdmUser (cid:8) User,(11) BookUser (cid:8) User,(12) User (cid:8) ∃hasRole,− (cid:8) Role,(13) ∃hasRole(14) Role (cid:8) ¬Publisher,(15) User (cid:8) ¬Publisher,(16) Role (cid:8) ¬User,(17) User (cid:8) ∃userAdmedBy,(18) ∃userAdmedBy(19) ∃userAdmedBy (cid:8) User,(20) ∃pubAdmedBy (cid:8) Publisher− (cid:8) AdmUser,R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411119(which is part of the larger Core ontology to be discussed in Section 9), and let Σ = {Publisher}. Observe that the MCM ofT is empty, which is typical of singleton signatures and Σ -concept inseparability, as no interesting concept inclusions overa singleton signature exist. However, for Σ -query inseparability, we can ask whether Publisher or ¬Publisher is not empty,which gives precisely three different MQMs of T :MD =(cid:6)(cid:7)(1), (2), (3), MR =(cid:6)(cid:7)(8), (9), (10), (11), (12), (13), (14), MU =(cid:6)(cid:7)(8), (9), (10), (11), (15).First, they are indeed Σ -query inseparable from T , which can be verified via the semantic criterion of Theorem 21. Second,they are minimal. For consider the ABox A = {Publisher(a)} and the query q = ∃x ¬Publisher(x). Clearly, we have (T , A) |(cid:15) q,while (T (cid:18), A) (cid:11)|(cid:15) q, for any proper subset T (cid:18)of MD , MR or MU . As part of our experiments described in Section 9 wechecked that no other MQM exists.In contrast to this finding, the MDQM of T is T itself. To illustrate that this is indeed the case, consider the TBox T (cid:18)with concept inclusions (17)–(19) and show that M = T \ T (cid:18)issig(M)-query separable from ∅. (Note that sig(M) = sig(T ) \ {userAdmedBy}.) Let A = {User(a)} and q = ∃x AdmUser(x).Then clearly (T (cid:18), A) |(cid:15) q.is not an MDQM of T . In other words, we show that T (cid:18)Consider now Σ (cid:18) = {Publisher, pubHasDistrib}. Then the only MCM of T with respect to Σ (cid:18)consists of concept inclu-sions (1)–(5), and there are only two MQMs with respect to Σ (cid:18)M(cid:18)R= MD ∪ MR ∪(cid:6)(cid:7)(4), (5), (6)and M(cid:18)U:= MD ∪ MU ∪(cid:6)(cid:7)(4), (5), (7).To show that they are indeed an MCM and two MQMs is left to the reader. Again, the fact that there are no other MCMsand MQMs was shown as part of our experiments.8. Forgetting and uniform interpolationWhen extracting a subset M from an ontology T that ‘says the same about a signature Σ ’ as T , one typically has toinclude into M a large number of axioms from T that contain non-Σ -symbols. Example 73 above shows that even for Σof size one or two, many additional symbols occur in the module. In this section, we aim at ‘extracting’ new ontologiesfrom a given ontology that ‘say the same about Σ ’ as the original ontology and, in addition, do not use non-Σ -symbols.Often, this can only be achieved by introducing new axioms that do not occur in the original ontology. In mathematicallogic parlance such an ontology would be called a uniform interpolant of the original ontology [22,23], whereas in artificialintelligence, computing the new ontology is known as forgetting (the non-Σ -symbols) [19,20,27]. The advantage of forgettingover module extraction is that it does not depend on the way the original ontology is formulated: whereas modules aresubsets of the original ontology, forgetting can (and will) be defined independently from the axiomatisation of the ontology.Of course, this can also be regarded as a disadvantage because the ontology engineer is not familiar with the new axioms,which can be hard to understand and process.To formalise forgetting/uniform interpolation, we employ again our notions of Σ -inseparability and say that a TBoxTΣ is a uniform interpolant of a TBox T with respect to Σ if the signature of TΣ is included in Σ and T and TΣare Σ -inseparable. Of course, the problems whether such a TBox TΣ exists, its size, and whether it can be constructedeffectively, depend on the available language constructs, the signature Σ , and the type of Σ -inseparability one is interestedNin. In this section, we consider the notions of uniform interpolation corresponding to Σ -concept inseparability in DL-LitehornNand DL-Litebool. A more systematic study of how inseparability relations can beused to define forgetting is beyond the scope of this paper (see [26] for such a study for extensions of the descriptionlogic EL).Nbool and Σ -query inseparability in DL-LiteWe start by defining forgetting and uniform interpolation based on Σ -concept inseparability in DL-LiteDL-LiteNhorn.Nbool andDefinition 74. Let L ∈ {DL-LiteTBox T in L and every signature Σ , there exists a TBox TΣ in L with sig(TΣ ) ⊆ Σ such that T and TΣ are Σ (cid:18)inseparable in L for all Σ (cid:18)in L.}. We say that L admits forgetting (or has uniform interpolation) if, for every-conceptwith sig(T ) ∩ Σ (cid:18) ⊆ Σ . In this case, TΣ is called a uniform interpolant of T with respect to ΣNhorn, DL-LiteNboolNote that this definition appears to be more restrictive than what was indicated in the informal discussion above: instead-concept inseparable for everywith sig(T ) ∩ Σ (cid:18) ⊆ Σ . It is readily seen, however, that the two definitions are actually equivalent because Σ -conceptof demanding that TΣ and T are Σ -concept inseparable, we require that TΣ and T are Σ (cid:18)Σ (cid:18)entailment is robust under vocabulary extensions.Example 75. Let T = {Hand (cid:8) BodyPart, BodyPart (cid:8) PhysicalObject} and Σ = {Hand, PhysicalObject}. Then the TBox TΣ ={Hand (cid:8) PhysicalObject} is a uniform interpolant of T with respect to Σ in both DL-LiteNbool and DL-LiteNhorn.Note that if L has uniform interpolation, then in principle we can use uniform interpolants to check Σ -concept en-in L and that we want to see whether T Σ -concepttailment in L. Indeed, suppose that we are given TBoxes T and T (cid:18)1120entails T (cid:18)following:R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141in L. To this end, we compute a uniform interpolant T (cid:18)Σ of T (cid:18)with respect to Σ in L. And then we have the– T Σ -concept entails T (cid:18)if, and only if, T |(cid:15) C (cid:8) D, for all (C (cid:8) D) ∈ T (cid:18)Σ .Thus, checking Σ -concept entailment can be reduced to computing uniform interpolants and checking subsumption in L.NThe following theorem states that DL-Litehorn do enjoy uniform interpolation. (It will be proved in Ap-pendix A.1 and subsequently used to establish some results stated earlier in this paper.)Nbool and DL-LiteTheorem 76. Let L ∈ {DL-Liteto Σ in L can be constructed effectively.Nbool, DL-LiteNhorn}. Then L has uniform interpolation, and a uniform interpolant of a TBox T with respectIn the worst case, the uniform interpolants given in the proof of this theorem are exponential in the size of T . Note thateven in propositional logic all known algorithms for computing uniform interpolants return, in the worst case, interpolantsof exponential size. In fact, it is known that, unless P = NC (i.e., unless every polynomial-time problem can be solved inpolylogarithmic time on a parallel computer with a polynomial number of processors), which is regarded as rather unlikely,there do not always exist uniform interpolants of polynomial size in propositional logic [56].Example 77. For DL-Litecase, of exponential size. Indeed, let(cid:6)Tn = { A ≡ B1 (cid:5) · · · (cid:5) Bn} ∪Nhorn, one can give a simple example showing that minimal uniform interpolants are, in the worst(cid:8)(cid:8) 1 (cid:3) i (cid:3) n, j = 1, 2(cid:7)(cid:8) B iand Σn = { A} ∪(cid:6)Aij(cid:8)(cid:8) 1 (cid:3) i (cid:3) n, j = 1, 2(cid:7).AijThen(cid:6)(cid:8)(cid:8) 1 (cid:3) j1, . . . , jn (cid:3) 2(cid:7)=A1j1TΣn(cid:8) A(cid:5) · · · (cid:5) Anjnis a uniform interpolant of Tn with respect to Σn in DL-Litein DL-Litewhich is of polynomial size:(cid:14)(cid:15)T (cid:18)Σn=(cid:3)1(cid:4)i(cid:4)n(cid:4)(cid:5)Ai1(cid:7) Ai2(cid:8) A.Nhorn. It is of size 2n, and there is no smaller uniform interpolantNNhorn. It is worth mentioning, however, that there exists a uniform interpolant of Tn with respect to Σn in DL-LiteboolOf course, these worst case lower bounds do not imply that in practice it is unfeasible to compute uniform interpolants;for example, it would be interesting to conduct experiments on deciding Σ -concept entailment using Theorem 76 andcompare the performance of this approach with the one based on the QBF encoding to be discussed below. For experimentalresults on computing uniform interpolants for TBoxes in the description logic EL we refer the reader to [26].The notion of uniform interpolation considered above reflects the interpretation of ‘saying the same about a vocabularyΣ ’ as being Σ -concept inseparable. How can this notion of uniform interpolation be modified when we are interested not inΣ -concept inseparability but, say, in Σ -query inseparability? The straightforward modification of Definition 74 by replacingconcept inseparability with query inseparability (or any other notion of inseparability introduced above) is unsatisfactory, asshown by the following example.Example 78. Let L ∈ {DL-LiteNhorn(cid:6)Lecturer (cid:8) ∃teaches, ∃teachesNbool, DL-Lite}. Consider the TBox− (cid:8) Course(cid:7)T =from Example 6, and let Σ = {Lecturer, Course}. Then TΣ = ∅ is a uniform interpolant of T with respect to Σ in L because,as we have already seen, the empty TBox and T are Σ -concept inseparable in L. Equivalently, we know that the set ofΣ -concept inclusions C (cid:8) D such that T |(cid:15) C (cid:8) D consists of tautologies only. We also know that no Σ -TBox consisting oftautologies is Σ -query inseparable in L from T . Thus, there does not exist a Σ -TBox T (cid:18)Σ and Tare Σ -query inseparable. Hence, the straightforward modification of Definition 74 by replacing concept inseparability withNbool and signatures Σ without uniformquery inseparability leads to a definition which allows very simple TBoxes in DL-Liteinterpolants.bool such that T (cid:18)Σ in DL-LiteNThe example above shows that to obtain a satisfactory notion of forgetting and uniform interpolation that reflects Σ -query inseparability, apart from replacing Σ -concept inseparability with Σ -query inseparability in Definition 74, we alsohave to increase the expressive power of the description logic in which uniform interpolants are formulated.Denote by DL-Liteubool the extension of DL-LiteNbool with the universal role U, where the DL-Liteubool concepts are defined asfollowsD ::= C | ∃U.C | D1 (cid:5) D2 | ¬D,R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411121where C are DL-LiteNbool concepts. Given an interpretation I, we set (∃U.C)I = (cid:5)IThe remaining model-theoretic notions are defined exactly as for DL-Litethat the subsumption problem ‘T |(cid:15) C1 (cid:8) C2?’ is still coNP-complete for TBoxes T in DL-LiteuC1 (cid:8) C2 in DL-Liteubool. It is important that we regard U as a logical symbol, so that sig(∃U.C) = sig(C).if CI (cid:11)= ∅, and (∃U.C)I = ∅ otherwise.Nbool. Using the construction from [10] one can showbool and concept inclusionsDefinition 79. Let T be a TBox in DL-Liteof T with respect to Σ in DL-LiteuNbool and Σ a signature. A TBox TΣ in DL-Liteubool is called a uniform query interpolantbool if T |(cid:15) α for all α ∈ TΣ , sig(TΣ ) ⊆ Σ , and T and TΣ are Σ -query inseparable.Example 80. Consider again the TBox(cid:6)T =Lecturer (cid:8) ∃teaches, ∃teaches− (cid:8) Course(cid:7)and Σ = {Lecturer, Course}.Then TΣ = {Lecturer (cid:8) ∃U.Course} is a uniform query interpolant of T with respect to Σ in DL-Liteubool.To analyse and justify this definition of uniform query interpolants, we first show that one can use uniform queryinterpolants to understand Σ -query entailment in the same way as uniform interpolants can be used to understand Σ -concept entailment.Theorem 81. Let T and T (cid:18)to Σ in DL-Liteube TBoxes in DL-Litebool. Then T Σ -query entails T (cid:18)Nbool and Σ a signature. And let T (cid:18)if, and only if, T |(cid:15) C (cid:8) D, for every (C (cid:8) D) ∈ T (cid:18)Σ .Σ be a uniform query interpolant of T (cid:18)with respectFinally, one can show that uniform query interpolants always exist.Theorem 82. For every TBox T in DL-Literespect to Σ in DL-Liteubool.Nbool and every signature Σ , one can construct a uniform query interpolant TΣ of T withDL-LiteNhorn as well as query inseparability in DL-LiteWe have proposed notions of forgetting and uniform interpolation induced by concept inseparability in DL-LiteWe close this section with a brief discussion of open problems and related work on forgetting and uniform interpolation.Nbool andNbool. We have seen that the latter case is not straightforward, as weNhad to enrich the underlying description logic DL-Litebool by the universal role so as to obtain a notion for which queryuniform interpolants always exist. Developing uniform interpolants based on the remaining Σ -inseparability relations is aninteresting problem, but it goes beyond the scope of this paper.Forgetting concepts (but not roles) in DL-Lite was studied in [27] using a resolution-based technique. It is also worthmentioning that, for many standard DLs such as ALC and even EL, uniform interpolants do not always exist [24–26].9. Experimental resultsIn order to see whether the logic-based approach to checking inseparability relations between and extracting minimalmodules from DL-Lite ontologies is feasible in practice, we conducted a series of experiments with a number of ‘typical’Nbool ontologies. Instead of developing and implementing algorithms for checking the Σ -concept andmedium-size DL-LiteΣ -query entailment criteria of Theorems 20, 21 and 50, we encoded these criteria by means of quantified Boolean formulas(QBFs, for short) and then employed standard off-the-shelf general purpose QBF solvers. In this section, we discuss somedetails of the encodings and the results of the experiments.9.1. QBF encodingsWe begin by showing how the conditions of Proposition 49 for realisability and precise realisability of sets of types canbe encoded by means of QBFs. Given a signature Σ and a finite set Q of natural numbers, fix a list B 1, . . . , Bn of all basicΣ Q -concepts different from (cid:4) and ⊥. Denote by b a sequence (B 1b) of n pairwise distinct propositional variables(containing a variable B b, for each basic Σ Q -concept B save (cid:4) and ⊥). Such a sequence b will be called a Σ Q -typevariable. It follows from the definitions that we have:b, . . . , BnProposition 83. Let a be an assignment of truth-values to propositional variables satisfying the following condition:(tp) for every Σ -role R, if the numbers q < q(cid:18)are both in Q and a(((cid:2) q(cid:18)R)b) is true then a(((cid:2) q R)b) is also true.Then a defines a (unique) Σ Q -type taa (unique) assignment of the truth-values to propositional variables of the sequence b.b , where B ∈ tab if, and only if, a(B b) is true. Conversely, every Σ Q -type t with ⊥ /∈ t determines1122R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Let T be a TBox in DL-LiteNbool, m the number of role names in T , and Q ⊇ Q T . To encode the notion of a T -witnessfor a set of (k + 1)-many Σ Q -types used in Proposition 49, we take (k + 2m + 1)-many distinct sig(T )Q -type variablesb0, . . . , bk+2m and consider the propositional formulaΦkT (b0, . . . , bk+2m) =k+2m(cid:10)(cid:10)(cid:4)j=0C1(cid:8)C2∈T(C1)b j→ (C2)b j(cid:5)∧k+2m(cid:10)m(cid:10)(cid:10)(cid:16)(cid:4)((cid:2) q P i)b j→(cid:4)(cid:18)(cid:2) qP i(cid:4)(cid:4)∧(cid:5)(cid:5)b j(cid:2) q P(cid:5)−ib j(cid:4)→(cid:18)(cid:2) qP−i(cid:5)(cid:5)(cid:17)b j∧(cid:18)<q(cid:18)∈Q , qq,q(cid:18)(cid:18)<q for no q(cid:18)(cid:18)∈Qj=0i=1q(cid:18)<q(cid:18)(cid:9) k+2m(cid:19)(cid:4)m(cid:10)i=1j=0∃P(cid:11)→ (∃P i)bk+2i−1∧(cid:5)−ib j(cid:9) k+2m(cid:19)j=0(∃P i)b j→(cid:5)(cid:4)∃P−ibk+2i(cid:11)(cid:20),where Cb, for C a Σ Q -concept, is defined inductively as follows:⊥b = ⊥,(cid:4)b = (cid:4),(¬C)b = ¬Cb,(C1 (cid:5) C2)b = (C1)b ∧ (C2)b.The second conjunct of this formula represents condition (tp) of Proposition 83, while the first and the last conjunctsrepresent conditions (w2) and (w3) of Definition 47, respectively. The following proposition is an immediate consequenceof Proposition 83 and Definition 47:Proposition 84. Let Σ ⊆ sig(T ) and let a be an assignment of the truth-values to the propositional variables. Then Φkis true under a if, and only if, the pair Ξ T = ((tab0set Ξ = {tab0T (b0, . . . , bk+2m))) of sequences of sig(T )Q -types is a T -witness for the(cid:4)Σ } of Σ Q -types.(cid:4)Σ , . . . , tabk, . . . , tabk, . . . , ta), (tabk+2mbk+1Note that the size of the formula ΦkUsing the formulas ΦkT (b0, . . . , bk+2m) is linear in k and polynomial in the size (cid:4)(T ) of T .T (b0, . . . , bk+2m) and Propositions 49 and 84, we can now represent the problem of decidingwhether T1 Σ -concept entails T2 as the truth problem for certain QBFs. Let mi be the number of role names in Ti , i = 1, 2,and Q = Q T1∪T2 . We assume that the basic sig(T1)Q - and sig(T2)Q -concepts are ordered in such a way that all Σ Q -(cid:21)concepts precede (sig(Ti) \ Σ)Q -concepts, for i = 1, 2. Take, a Σ Q -type variable b, a (sig(Ti) \ Σ)Q -type variablebi0 andsig(Ti)Q -type variables bi, for i = 1, 2.1, . . . , bi2miProposition 85. The QBF∀ b(cid:16)∃ (cid:21)0, b1b11, . . . , b12m1(cid:4)Φ 1T1b · (cid:21)0, b1b11, . . . , b12m1(cid:5)→ ∃ (cid:21)0, b2b21, . . . , b22m2(cid:4)Φ 1T2b · (cid:21)0, b2b21, . . . , b22m2(cid:5)(cid:17)is true if, and only if, T1 Σ -concept entails T2 in DL-Litefor i = 1, 2.Nbool. Here b · (cid:21)0 is the sig(Ti)Q -type variable obtained by appendingbi(3)(cid:21)bi0 to b,Informally, QBF (3) says the following: for every Σ Q -type t (represented by b in the sense of Proposition 83), if t can be(cid:21)0) for which there exist 2m1-many sig(T1)Q -types (represented by b1b1extended to a sig(T1)Q -type (by means of2m1such that the resulting set of 2m1 + 1 types is T1-realisable (as stated by Φ 1)), then t can also beT1extended to a sig(T2)Q -type for which 2m2-many sig(T2)Q -types can be found such that the resulting set of these 2m2 + 1Ntypes is T2-realisable. In other words, QBF (3) is true if, and only if, T1 Σ -concept entails T2 (in DL-Litehorn).Note, by the way, that together with the known results on the complexity of classes of QBFs [50,57], this encoding providesNNan alternative proof of the upper complexity bounds for deciding Σ -concept entailment for both DL-Litebool and DL-Litehorn.Nbool TBoxes., for i = 1, 2, and sig(T2)Q -type variablesIn a similar manner we can encode the criterion of Theorem 50 for Σ -query entailment between DL-LiteNbool or DL-Lite(b · (cid:21)0, b1b11, . . . , b11, . . . , b12m1)Take Σ Q -type variables b0, . . . , b2m1 , (sig(Ti) \ Σ)Q -type variables1, . . . , b3b3.(cid:21)bi0, . . . ,(cid:21)bi2m12m2R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411123Proposition 86. The QBF(cid:22)∃ (cid:21)b10, . . . ,∀ b0, . . . , b2m1(cid:21)b12m1(cid:4)Φ 1T1(cid:23)∃ (cid:21)b20, . . . ,(cid:21)2m1 ∃ b3b21, . . . , b32m2Φ 1+2m1T2b0 · (cid:21)b10, . . . , b2m1· (cid:21)b12m1(cid:5)→(cid:4)b0 · (cid:21)b20, . . . , b2m1· (cid:21)b22m1, b31, . . . , b32m2(cid:24)(cid:25)(cid:5)2m2(cid:10)2m1(cid:19)(cid:5)∧(cid:4)χb3i , b ji=1j=0(4)is true if, and only if, T1 Σ -query entails T2 in DL-LiteΣ Q -concepts.Nbool. Here χ (b3i , b j) is the conjunction of formulas (B b3↔ B b j ), for all basicii , b j) is required to encode condition (w-pr) of Definition 47.Note that χ (b3Although QBFs (3) and (4) look similar and belong to the same class of ∀∃ QBFs, in practice they behave quite differently.In (3), we take a Σ Q -type t, (i) extend t to a sig(T1)Q -type, (ii) check whether there are ‘witnesses’ for all the roles in thattype and the types providing those witnesses, and if this is the case, we repeat (i) and (ii) again for T2 in place of T1. QBF (4)is much more complex not only because now we have to start with a set of (1 + 2m1) Σ Q -types rather than a single type.More importantly, the T2-witnesses we choose for these types are notarbitrary but must have Σ -restrictions that coincidewith some of the original (1 + 2m1) Σ Q -types. This last condition, represented by a formula with (2m2 × (1 + 2m1))-manyoccurrences of χ (b3i , b j), makes QBF (4) computationally much more costly in practice.9.2. Experiments with Σ -entailmentTo evaluate the performance of QBF solvers when checking Σ -concept and Σ -query entailment, we used an extensionNof the DL-Litebool approximation of the standard Department ontology (cf. http://swat.cse.lehigh.edu/projects/lubm/). Theontology together with details of the experiments is available at http://www.dcs.bbk.ac.uk/~roman/qbf/. The reader canappreciate the complexity of the problems the QBF solvers were facing by trying to check by hand whether the followingontology T1 (which is a tiny part of our Department ontology) Σ -concept and Σ -query entails the ontology T2 = T1 ∪{Visiting (cid:8) (cid:2) 2 writes}, for Σ = {teaches}:ResearchStaff (cid:5) Visiting (cid:8) ⊥∃teaches (cid:8) Academic (cid:7) ResearchStaffResearchStaff (cid:8) ∃worksIn−Project (cid:8) ∃managesAcademic (cid:8) ∃teaches (cid:5) ¬ (cid:2) 2 teaches∃writes (cid:8) Academic (cid:7) ResearchStaff∃worksIn∃manages (cid:8) Academic (cid:7) Visiting− (cid:8) ProjectAs our benchmarks, we considered three series of instances of the form (T1, T2, Σ), where both T1 and T2 were subsetsof the whole Department ontology. In the NN-series, T1 does not Σ -concept entails T2; in the YN-series, T1 Σ -concept butnot Σ -query entails T2; and in the YY-series, T1 Σ -query entails T2. The sizes of the instances are uniformly distributedover the intervals given in the table below:SeriesNNYNYYNumber ofinstances840504624Number of concept inclusionsT1T259–30856–30243–17874–39677–38243–222Number of basic conceptsT1T247–25044–24640–15849–30058–29840–188Σ5–1036–895–64The next table illustrates the sizes of the QBF translations of our instances for both Σ -concept and Σ -query entailment:SeriesNNYNYYΣ-concept entailment QBFΣ-query entailment QBFNumber of variablesNumber of clausesNumber of variablesNumber of clauses1469–48,6311460–46,8731006–16,0332391–74,6212352–71,1771420–23,3631715–60,4991755–59,3971202–20,5135763–1,217,1517006–1,122,3612963–204,889Note the large difference between the sizes of the QBF translations for Σ -concept and Σ -query entailment (say, 74,621vs. 1,217,151 clauses in the same instance), which reflects the difference between QBFs (3) and (4) discussed above. Althoughof the same worst-case complexity, in practice Σ -concept entailment turns out to be much easier to check than Σ -queryentailment; see Fig. 3, where the graphs in the left (right) column show the percentage of solved instances for Σ -concept(respectively, Σ -query) entailment.1124R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Fig. 3. Percentage of solved Σ -entailments in a given timeout.We experimented with four standard QBF solvers: Skolemisation-based sKizzo [58] and search-based 2clsQ [59], yQuaf-fle [60,61] and QuBE [62]. The tests were conducted on a 3 GHz P4 machine with 2 GB RAM.It turned out that none of the four solvers was better than the others on all instances: for example, QuBE performedmuch stronger than sKizzo on the NN and YN series, but was outperformed by sKizzo on the (much harder) YY series.Moreover, none of the solvers could cope single-handedly with all of the tests and, even when the solver was successful,the runtime was quite unpredictable and could range from a few seconds to a few hours.To select ‘the best’ QBF solver for each given instance, we employed the self-adaptive multi-engine system aqme [28],a tool capable of learning and choosing a QBF engine with ‘more chances’ to solve a given input. As yQuaffle was alwaysoutperformed by at least one of the other three solvers, we excluded it from these experiments. An important propertyR. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411125of aqme is that it can update its learned policies when the usage scenario changes substantially by using an adaptationschema called retraining. Prior to the experiments, aqme computed a selection of syntactic features (characterising theparticular problems in question) from a pool of suitable QBF instances. A typical run of aqme is as follows. First, it leveragesits inductive model (built using 1-nearest neighbour) to predict the best engine for a given input QBF. If the engine solvesthe QBF, aqme terminates and returns the answer. Otherwise, it starts its self-adaptive mechanism. It calls a different engineto solve the input formula. If it is successful, the retraining procedure is called and the inductive model is updated. Whichengine is called for retraining and how much CPU time is granted to each engine are critical points for aqme’s performance.As follows from Fig. 3, aqme indeed managed to select the best solver in all the cases, which was absolutely crucial for ourmodule extraction experiments.9.3. Practical module extractionWe extracted minimal modules from DL-LiteNbool encodings of two real-world commercial software applications called‘Core’ and ‘Umbrella’. The Core ontology is based on a supply-chain management system used by the bookstore chain Ot-takar’s, now rebranded as Waterstone’s. It contains 1283 concept inclusions, 83 concept names and 77 role names, andfeatures numerous functionality constraints, covering and disjointness constraints, and quite a few concepts of the form(cid:2) q R with q > 2. The Umbrella ontology is based on a specialised research data validation and processing system used bythe Intensive Care National Audit and Research Centre (http://www.icnarc.org). It contains 1247 concept inclusions, 79 con-cept names and 60 role names. Both ontologies are representations of the relevant data structures and were constructed byanalysing the data model, database schema and application-level business logic. The ‘publisher ontology’ in Example 73 ispart of Core.We have conducted experiments with three types of minimal module extraction: for a DL-LiteNbool TBox T and a signa-ture Σ , extract some minimal Σ -concept inseparability module (MCM) of T , some minimal Σ -query inseparability module(MQM), and the minimal depleting Σ -query inseparability module (MDQM) of T . As we have seen above, these extractionproblems can be solved by the algorithms of Theorems 67 and 72 together with the ‘QBF oracle’ for deciding the Σ -conceptand Σ -query inseparability relations. Unfortunately, a naïve implementation of the MDQM extraction algorithm turns out tobe hopelessly inefficient for ‘typical’ real-world examples because, for an ontology with, say, a thousand concept inclusions,the algorithm would call the oracle about 500 thousand times. To reduce the number of such calls, we modified the algo-rithm of Theorem 72 by making it choose a group of concept inclusions {α1, . . . , αk} rather than a single concept inclusionα at a time: if W ∪ {α1, . . . , αk} is Σ ∪ sig(M)-query inseparable from the empty set then all the αi can be moved to M;otherwise, a subset of {α1, . . . , αk} has to be considered instead. In practice, this optimisation reduced the number of callsto a few thousand for an ontology with a thousand axioms. On the other hand, to reduce the size of the original ontology,we ‘pre-processed’ it by means of the tractable syntactic locality-based algorithm [1] extracting the so-called (cid:4)⊥-module((cid:4)⊥M), which is a (not necessarily minimal) module with respect to the Σ -model inseparability relation, and so containsall the minimal modules we are interested in. In fact, we have the following inclusions:MCM ⊆ MQM ⊆ MDQM ⊆ (cid:4)⊥M,where the first ⊆ should be read as ‘every MQM contains some MCM’, the second as ‘every MQM is contained in the MDQM’,and the third ⊆ as ‘the MDQM is contained in the (cid:4)⊥M’. Thus we can use these inclusions by computing modules fromright to left.Modules for |Σ| = 1. Our first experiment was to extract the minimal modules of all three types for all singleton sig-natures and compare the relative sizes of the modules. For instance, the extracted MCM, MQM and MDQM of Core forΣ = {Publisher} are given in Example 73 and contain 0, 3, and 20 concept inclusions, respectively, whereas the correspond-ing (cid:4)⊥M has 228 concept inclusions. Fig. 4 summarises the results of the experiments (on average per module) in termsof the number of concept inclusions in modules. It also contains the average sizes of the segments extracted using otherFig. 4. Average module size and the standard deviation for singleton signatures.1126R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Table 2Extraction time and distribution of calls for MDQM extracted from the (cid:4)⊥M and the full ontology.Extraction timeTotal aqme callssKizzo2clsQQuBECore(cid:4)⊥M126 s38514%2%84%Full2233 s56576%17%7%Umbrella(cid:4)⊥M60 s2544%1%95%Full2488 s46374%14%12%approaches: SR [16], Prompt [15] and E-conn [17]. Since these approaches do not support role names in the initial signature,we have only extracted modules for concept names in these cases. Furthermore, SR and Prompt are not logic-based and,in general, do not preserve entailments. (The Publisher-segments for SR, Prompt, and E-conn contain 19, 189, and 349 con-cept inclusions, respectively.) Interestingly, the segments extracted using Prompt are significantly larger than the modulesextracted using our logic-based approach (see also Fig. 5). On the other hand, the segments extracted using SR are smallerthan MDQMs, but the properties of such segments are rather unclear. Finally, the modules extracted using E-conn behaverather differently from MDQMs: for Core, they are typically larger than MDQMs whereas for Umbrella they are slightlysmaller than MDQMs. Further experiments are required to give a satisfactory explanation of this phenomenon.Our second experiment was to extract MDQMs from the full Core and Umbrella ontologies and from the correspondingpre-computed (cid:4)⊥Ms. Table 2 compares the average extraction time and distribution of QBF engine calls for the two sce-narios. The distribution of calls to the QBF engines changes notably if MDQMs are extracted from the whole ontology ratherthan from the (cid:4)⊥Ms: in the former case, the majority of calls is issued to sKizzo, while QuBE handles most of the calls inthe latter case. This complies with the observation that, in general, QuBE tends to solve easier instances more quickly, andsKizzo performs more successfully on harder instances.We also extracted MCMs and MQMs from the respective MDQMs: the average extraction time is 27.1 s and 23.3 s,respectively, for Core, and 22.5 s and 14.4 s for Umbrella.Modules for |Σ| = 10. Then, for each of our ontologies, we randomly generated 30 signatures of 10 concept names eachand extracted modules: MCMs and MQMs were extracted from MDQMs, which in turn were extracted from (cid:4)⊥Ms. Theaverage sizes and standard deviation are shown in Fig. 5. We extracted all MCMs and MDQMs and the average runtimewas around 30 minutes for MDQMs and 90 s for MCMs. It is to be noted that we have only been able to extract 23 and10 MQMs for Umbrella and Core, respectively, because the runtime for certain instances becomes unfeasible. One of thereasons is the growth of the QBF instances generated whenever the algorithm needs to test query inseparability betweenmodule candidates and the original ontology. In the case of MDQMs, a candidate’s complement needs to be compared withthe empty TBox, which can be done rather efficiently. The case of MQMs involves many comparisons of two very similarTBoxes, which leads to the generation of QBF instances that are quadratic in the number of roles involved (as opposed tolinear for MCMs; see Section 9.1).At the time of preparing the paper for publication, we became aware of a new QBF solver DepQBF [63], which outper-forms other search-based solvers (e.g., QuBE and 2clsQ) on our QBF instances [64]. With DepQBF and sKizzo as the twomain engines for aqme, we improved performance of the MQM extraction algorithm and managed to extract a number ofnew modules.Fig. 5. Average module size and standard deviation for |Σ| = 10.R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141112710. ConclusionWe have introduced and analysed a framework for signature-based notions of difference, entailment and inseparabilityNbetween ontologies in the description logics DL-Litehorn. These notions can be used to compare two versionsof an ontology, to check whether importing one ontology into another has (possibly unwanted) side-effects, and to studyand define refinements of a given ontology. We have also demonstrated that Σ -inseparability can be used as a frameworkfor both module extraction and forgetting. Finally, we have presented promising experimental results of using QBF solversto decide Σ -inseparability and extract (minimal) modules.Nbool and DL-LiteMany open problems remain. Here we mention some of them:Approximating Σ -difference.In this paper, we have focused on deciding Σ -entailment and its application to module ex-traction. However, it is of equal importance to investigate how the (mostly exponential!) Σ -difference betweenontologies can be approximated in practice. Any approximation should provide the developers and users of on-tologies with sufficient information to decide how different versions of ontologies can be reconciled and whetherthe differences are relevant for a certain application.Complexity of Σ -model entailment.It would be interesting to establish the precise computational complexity of Σ -modelNbool TBoxes corresponding toentailment and understand its practical applicability. We conjecture that, for DL-LiteUML class diagrams or ER models used in practice, typically rather small counterexamples to Σ -model entailmentexist and that discovering and computing them is often feasible.Forgetting and uniform interpolation.(strong) query inseparability in DL-LiteIt would be interesting to investigate forgetting and uniform interpolation forNbool, it will be necessary to extend the expressiveNpower of DL-Litehorn so as to be able to express uniform interpolants. We conjecture that the universal role canagain be employed to define suitable extensions. We also need experiments showing the size of uniform inter-polants for real-world ontologies. So far, experimental results are available only for EL [26].Nhorn. Similarly to DL-LiteΣ -entailment and module extraction for other DL-Lite logics.In this paper we have considered only two of the widerclass of DL-Lite logics [11]. In the context of OWL 2 QL and efficient query answering, one can also consider theso-called core variants of DL-Lite with concept inclusion of the form B 1 (cid:8) B2 and B1 (cid:5) B2 (cid:8) ⊥, where the B i areNbasic concepts. We believe that Σ -entailment for DL-Litecore can be tractable and that uniform interpolants can beof polynomial size. Another important construct used in OWL 2 QL is role inclusions. To investigate its impact onΣ -entailment is another interesting open problem.Axiomatic characterisation of Σ -entailment and inseparability.In Section 7, we have developed rudiments of an ax-iomatic approach to understanding inseparability. We have introduced properties of inseparability relations suchas monotonicity and robustness properties and have seen how they are related to modularity and well knownmeta-properties of logics such as the interpolation property and Robinson joint consistency property. However, afull-fledged axiomatic approach would have to introduce additional abstract properties of inseparability relationsand establish representation theorems relating those abstract properties to query languages that induce insepara-bility relations having them.Finer complexity analysis.It would be of interest to provide a finer analysis of the complexity of checking Σ -entailment byseparating the influence of T1 and T2 on the complexity of deciding whether T1 Σ -entails T2. As a first step, onecan fix T1 or T2 and analyse the complexity of Σ -entailment for varying T2 and, respectively, T1. In the context ofALC, results of this type are obtained in [24]. Another interesting parameter is the difference (T2 \ T1) ∪ (T1 \ T2)between T1 and T2. In many applications this set should be small compared to the sizes of T1 and T2, whichcould be helpful to understand the influence this has on the complexity of deciding Σ -entailment.AcknowledgementsWe thank Marco Benedetti, Florian Lonsing, Luca Pulina, Uli Sattler, Thomas Schneider and Petra Selmer for their help inconducting experiments described in Section 9. We thank the anonymous referees of this paper for many helpful suggestionsfor improvement of the first draft.Appendix AHere we provide the omitted proofs of the statements from the previous sections. We begin by establishing a number ofbasic results that will be required in these proofs.A.1. PreliminariesThe aim of this section is to introduce, in Lemma 87, an operation which allows us to amalgamate interpretations in a‘truth-preserving’ way. We will need two simple definitions.Given a signature Σ , we say that two interpretations I and J are Σ -isomorphic and write I ∼Σ J if there is a bijection, for every concept name A, for every object name a, x ∈ Aif, and only if,such that f (af : (cid:5)I → (cid:5)Jf (x) ∈ AI ) = aJJI1128R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141in Σ , and (x, y) ∈ Pcannot be distinguished by Σ -TBoxes, Σ -ABoxes or Σ -queries.if, and only if, ( f (x), f ( y)) ∈ PJIGiven a family of interpretations Ii , for i ∈ I, with 0 ∈ I, define the interpretation, for every role name P in Σ . Clearly, Σ -isomorphic interpretationsJ =(cid:26)i∈IIi,Ii }, for a conceptwhere (cid:5)J = {(i, w) | i ∈ I, w ∈ (cid:5)Ii }, aIi }, for a role name P . J will be called the disjoint union of the Ii .name A, and PThe disjoint union of ω copies4 of an interpretation I, that is, the disjoint union of the family Ii , for i ∈ ω and Ii = I, willbe denoted by Iω:J = {((i, w 1), (i, w 2)) | i ∈ I, (w 1, w 2) ∈ PI0 ), for an object name a, AJ = {(i, w) | i ∈ I, w ∈ AJ = (0, aIω =(cid:26)i∈ωIi.It should be clear that Σ -TBoxes, Σ -ABoxes or Σ -queries in any of our languages and for any signature Σ cannot distinguishbetween I and Iω.The following lemma provides an important model-theoretic property of DL-Litetablish model-theoretic characterisations of various notions of Σ -entailment.Nbool that will be frequently used to es-Lemma 87. Let T1 and T2 be TBoxes in DL-Litetypes. Then, for every at most countable model I1 of T1 precisely realising Ξ and every signature Σ (cid:18)a model I∗Nbool, Σ a signature, and let Ξ be a both T1- and T2-precisely realisable set of Σ Q T1∪T2 -with Σ (cid:18) ∩ sig(T2) ⊆ Σ , there isof T2 such that(i) I∗ ∼Σ (cid:18) Iω1 ;(ii) I∗precisely realises Ξ .In particular, if sig(T1) ⊆ Σ (cid:18)then I∗is a model of T1 ∪ T2.Proof. Let I2 be an at most countable model of T2 precisely realising Ξ . As both Iω2 → (cid:5)Iωfrom Ξ at a countably infinite number of points, there is a bijection f : (cid:5)IωIω1 , for all basic Σ Q T1∪T2 -concepts. Define I∗types, which means that x ∈ B(cid:5)Iω−1(a(cid:14)if, and only if,1 ), for all object names a, and1 and Iω2 realise each Σ Q T1∪T2 -type1 which is invariant under Σ Q T1∪T2 -by taking (cid:5)I∗ =f (x) ∈ BI∗ = f2 , aIω2Iω(cid:14)I∗ =A{x | f (x) ∈ AAIω2 ,Iω1 },if A ∈ Σ ∪ Σ (cid:18),otherwise,I∗ =P{(x, y) | ( f (x), f ( y)) ∈ PPIω2 ,Iω1 },if P ∈ Σ ∪ Σ (cid:18),otherwise,for all concept names A and role names P . By definition, I∗ ∼Σ∪Σ (cid:18) Iω1 . Therefore, I∗ ∼Σ (cid:18) IωObserve that each point x in (cid:5)I∗Σ Q T1∪T2 -types, for a basic Σ Q T1∪T2 -concept B, we have x ∈ Bfor a basic (sig(T2) \ Σ)Q T1∪T2 -concept B, BIω2 by definition. Therefore, I∗ |(cid:15) T2.has the same sig(T2)Q T1∪T2 -type in Iωif, and only if,Iω22 and I∗1 and I∗. Indeed, as fprecisely realises Ξ .is invariant underf (x) ∈ BIω1if, and only if, x ∈ BI∗. And,Finally, sig(T1) ⊆ Σ (cid:18)and I∗ ∼Σ (cid:18) IωI∗ = B1 give I∗ |(cid:15) T1. (cid:2)INext, we establish an analogue of Lemma 87 for TBoxes in DL-LiteNhorn and sub-precise realisability. Given a signature ΣI ), for every object name a,and interpretations I and J , a map h : (cid:5)I → (cid:5)JJx ∈ Aimplies h(x) ∈ A, for everyNrole name P in Σ and x, y ∈ (cid:5)Ihorn are positive existentialformulas and therefore, if there is a Σ -homomorphism from I to J then I |(cid:15) q(a) implies J |(cid:15) q(a), for every Σ -queryq(x) in DL-LiteJ = h(ais called a Σ -homomorphism if aI, and (x, y) ∈ P. A Σ -homomorphism is onto if it is surjective. Queries in DL-Lite, for every concept name A in Σ and x ∈ (cid:5)Iimplies (h(x), h( y)) ∈ PJNhorn and every tuple a.Lemma 88. Let T1 and T2 be TBoxes in DL-Liteis also sub-precisely T2-realisable. Then, for every at most countable model I1 of T1 precisely realising Ξ and every signature Σ (cid:18)Σ (cid:18) ∩ sig(T2) ⊆ Σ , there exist a model I∗of T2 realising all the types from Ξ and a Σ (cid:18)I∗Nhorn, Σ a signature, and let Ξ be a set of precisely T1-realisable Σ Q T1∪T2 -types thatwithonto I1. In particular,-homomorphism from I∗sub-precisely realises Ξ .4 As usual in set theory, we identify the ordinal ω with the set of natural numbers.R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411129Proof. Let I2 be an at most countable model of T2 sub-precisely realising Ξ . Without loss of generality we may assumethat the interpretations of all symbols not in sig(T2) are empty. We construct a sequence of pairs ((cid:5)i, hi), i ∈ ω, where(cid:5)i ⊆ (cid:5)Iω2 and hi : (cid:5)i → (cid:5)I1 is a Σ -homomorphism from the (cid:5)i part of Iω(cid:27)2 onto I1, such that(cid:5)i ⊆ (cid:5)i+1,for all i ∈ ω and(cid:5)i = (cid:5)Iω2 .i∈ωTo start with, choose (cid:5)0 ⊆ (cid:5)Iωand each Σ Q T1∪T2 -type realised in Iωbecause IωAssume that an ordering < of (cid:5)Iω22 and a bijection h0 : (cid:5)0 → (cid:5)I1 in such a way that h0 is invariant under Σ Q T1∪T2 -types2 \ (cid:5)0. Such a bijection exists2 is realised by countably infinitely many points in (cid:5)Iω2 realises every Σ Q T1∪T2 -type from Ξ countably infinitely many times.construct ((cid:5)k+1, hk+1), we apply one of the following two rules to x ∈ (cid:5)Iωy ∈ (cid:5)Iω2 with y < x.is isomorphic to ω, and suppose that ((cid:5)k, hk) have already been constructed. To2 , provided that neither is applicable to any• If x ∈ (cid:5)k and the Σ Q T1∪T2 -type of x in Iω2 contains (cid:2) q R such that R2 \ (cid:5)k that has the same Σ Q T1∪T2 -type as a point z ∈ (cid:5)I1 with (hk(x), z) ∈ RIω2 ∩ ((cid:5)k × (cid:5)k) has fewer than q pairs (x, xi), pickI1 (this can be done since2 is positively contained in the Σ Q T1∪T2 -type of hk(x) in I1). Then we set (cid:5)k+1 = (cid:5)k ∪ { y}a point y ∈ (cid:5)Iωthe Σ Q T1∪T2 -type of x in Iωand hk+1 = hk ∪ {( y, z)}.• If x ∈ (cid:5)Iω2 \ (cid:5)k, select z ∈ (cid:5)I1 such that the Σ Q T1∪T2 -type of x in Iωz in I1. Set (cid:5)k+1 = (cid:5)k ∪ {x} and hk+1 = hk ∪ {(x, z)}.2 is positively contained in the Σ Q T1∪T2 -type of(cid:13)Let h =(cid:14)i∈ω hi . Define an interpretation I∗by taking (cid:5)I∗ = (cid:5)Iω2 , aI∗ = h−10 (aI1 ), for all object names a, andAIω2 ,I1 },I∗ ={x | h(x) ∈ AAif A ∈ Σ ∪ Σ (cid:18),otherwise,for all concept names A and role names P . Clearly, the function h is a Σ ∪ Σ (cid:18)onto I1 (recall thatin I2 the interpretations of symbols from Σ (cid:18) \ sig(T2) are empty) and the sig(T2)Q T1∪T2 -type of each x is the same in I∗and Iωif P ∈ Σ ∪ Σ (cid:18),otherwise,-homomorphism from I∗{(x, y) | (h(x), h( y)) ∈ PPis a model of T2. (cid:2)I∗ =I1 },Iω2 ,P2 . Hence I∗(cid:14)Theorem 76. Let L ∈ {DL-Liteto Σ in L can be constructed effectively.Nbool, DL-LiteNhorn}. Then L has uniform interpolation, and a uniform interpolant of a TBox T with respect(cid:3)Nbool and Σ a signature. Let TΣ be the set of all concept inclusionsProof. Let T be a TBox in DL-LiteC∈t C (cid:8) ⊥ such that tNis a Σ Q T -type which is not T -realisable. We show that TΣ is a uniform interpolant for T with respect to Σ in DL-Litebool.Clearly TΣ |(cid:15) C (cid:8) D implies T |(cid:15) C (cid:8) D for all concept inclusions C (cid:8) D. Conversely, assume that TΣ (cid:11)|(cid:15) C (cid:8) D andsig(C (cid:8) D) ⊆ Σ (cid:18)with Σ (cid:18) ∩ sig(T ) ⊆ Σ . Let I1 be a model of TΣ such that I1 (cid:11)|(cid:15) C (cid:8) D. By Löwenheim–Skolem and closure under disjoint unions, we may assume that I1 is at most countable and realises the set Ξ of allTΣ -realisable Σ Q T -types. By the definition of TΣ , Ξ coincides with the set of all T -realisable Σ Q T -types. Thus, Ξ isboth T and TΣ -precisely realisable. So, by Lemma 87, we have a model I∗ ∼Σ (cid:18) Iω1 of T . It follows that I∗ (cid:11)|(cid:15) C (cid:8) D. ThusT (cid:11)|(cid:15) C (cid:8) D, as required., for a signature Σ (cid:18)horn TBox. Define T (cid:18)Assume now that T is a DL-LiteNfrom T , where t is a Σ Q T -type that is not T -realisable and ¬B 0 ∈ t \ tT with respect to Σ . To this end, we show that T (cid:18)C∈t C (cid:8) ⊥, or, equivalently,inclusions of the formenjoy the disjunction property, there exists ¬B 0 ∈ t \ tobtain T (cid:18)C∈t C (cid:8) ⊥, as required. (cid:2)ΣB∈t+ B (cid:8) B0 that followΣ as the set of all concept inclusions. We show that T (cid:18)+Σ is a uniform interpolant ofΣ implies every concept inclusion in TΣ . Indeed, TΣ consists of concept¬B∈t\t+ B. Take such a concept inclusion. As Horn KBsΣ and weB∈t+ B (cid:8)such that TΣ |(cid:15)B∈t+ B (cid:8) B0. Thus,B∈t+ B (cid:8) B0 ∈ T (cid:18)(cid:3)+(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)|(cid:15)(cid:3)A.2. Proofs of results from Section 4Now we use the technique developed in the previous section in order to prove the claims made in Section 4. Throughoutthis section we use the fact that if a type is realised then it is realised in an at most countable model (and similarly, if a setof types is precisely realisable then it is precisely realisable in an at most countable model).Theorem 20. The following conditions are equivalent for TBoxes T1 and T2 in DL-LiteNbool and a signature Σ :(ceb) T1 Σ -concept entails T2 in DL-Lite(r) every T1-realisable Σ Q T1∪T2 -type is T2-realisable.Nbool;1130R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141(cid:3)Proof. (ceb) ⇒ (r) Suppose that t is a T1-realisable Σ Q T1∪T2 -type which is not T2-realisable. Then T2 |(cid:15)T1 (cid:11)|(cid:15)C∈t C (cid:8) ⊥, contrary to T2 being Σ -concept entailed by T1.C∈t C (cid:8) ⊥ but(cid:3)(r) ⇒ (ceb) Suppose that (ceb) does not hold. Using Theorem 76 and its proof, we can construct a uniform interpolantNbool. As T2 and T2Σ are Σ -concept insep-T2Σ of T2 with respect to Σ that consists of Σ Q T2 -concept inclusions in DL-LiteNarable, we can find C1 (cid:8) C2 ∈ T2Σ such that T1 (cid:11)|(cid:15) C1 (cid:8) C2. And as C1 (cid:8) C2 is a Σ Q T2 -concept inclusion in DL-Litebool, wecan find a T1-realisable Σ Q T1∪T2 -type that is not T2-realisable. Indeed, let I be a model of T1 with a point x such thatx ∈ (C1 (cid:5) ¬C2)I. Then the Σ Q T1∪T2 -type realised at x in I is not T2-realisable. (cid:2)Theorem 21. The following conditions are equivalent for TBoxes T1 and T2 in DL-LiteNbool and a signature Σ :(sceb) T1 strongly Σ -concept entails T2 in DL-Lite(qeb) T1 Σ -query entails T2 in DL-Lite(sqeb) T1 strongly Σ -query entails T2 in DL-Lite(pr) every precisely T1-realisable set of Σ Q T1∪T2 -types is precisely T2-realisable.Nbool;Nbool;Nbool;Proof. The implication (sqeb) ⇒ (qeb) is immediate from the definitions and (sqeb) ⇒ (sceb) is proved similar to Proposi-tion 15(i).(pr) ⇒ (sqeb) Suppose there are a Σ -TBox T , Σ -ABox A and Σ -query q(a) in DL-LiteNbool with (T2 ∪ T , A) |(cid:15) q(a) and(T1 ∪ T , A) (cid:11)|(cid:15) q(a). Take a model I1 of (T1 ∪ T , A) such that I1 (cid:11)|(cid:15) q(a) and let Ξ be the set of Σ Q T1∪T2 -types realisedin I1. By (pr), Ξ is precisely T2-realisable. Then, by Lemma 87, there exists a model I∗of T2 such that I∗ ∼Σ Iω1 , and soI∗ |(cid:15) (T , A) and I∗ (cid:11)|(cid:15) q(a), contrary to (T2 ∪ T , A) |(cid:15) q(a).(qeb) ⇒ (pr) Let Ξ be the set of Σ Q T1∪T2 -types realised in a model I of T1, and let AΞ = {C(at ) | C ∈ t, t ∈ Ξ }, whereat is a fresh object name for each t ∈ Ξ . It follows that I |(cid:15) (T1, AΞ ). Suppose that Ξ is not precisely T2-realisable. Thentwo cases are possible:1. If, for every model I(cid:18)of T2, there is some t ∈ Ξ that is not realised in I(cid:18), i.e., I(cid:18) (cid:11)|(cid:15) AΞ , then consider the query q = ⊥:we have (T2, AΞ ) |(cid:15) q but (T1, AΞ ) (cid:11)|(cid:15) q, which is a contradiction.2. Otherwise, every model of T2 must realise a Σ Q T1∪T2 -type that is not in Ξ . Let Θ be the set of all T2-realisableC∈t C(x). Then we have (T2, AΞ ) |(cid:15) q butΣ Q T1∪T2 -types that are not in Ξ . As Θ (cid:11)= ∅, we can take q = ∃xI (cid:11)|(cid:15) q, and so (T1, AΞ ) (cid:11)|(cid:15) q, which is again a contradiction.t∈Θ(cid:28)(cid:29)(sceb) ⇒ (pr) Let Ξ be a set of precisely T1-realisable Σ Q T1∪T2 -types, and let TΞ = {(cid:4) (cid:8)t ∈ Ξ , we have T1 ∪ TΞ (cid:11)|(cid:15)(cid:3)realising t such that all Σ Q T1∪T2 -types realised in it are in Ξ . Clearly,types in Ξ . (cid:2)C∈t C (cid:8) ⊥. Therefore, by (sceb), T2 ∪ TΞ (cid:11)|(cid:15)(cid:3)(cid:3)C∈t C}. Then, for everyt∈Ξ(cid:3)C∈t C (cid:8) ⊥, and thus there is a model It of T2 ∪ TΞ(cid:30)It is a model of T2 precisely realising thet∈ΞTheorem 26. For any TBoxes T1 and T2 in DL-LiteNhorn and any signature Σ , the following conditions are equivalent:(qeh) T1 Σ -query entails T2 in DL-Lite(spr) every precisely T1-realisable set of Σ Q T1∪T2 -types is sub-precisely T2-realisable.Nhorn;NProof. (spr) ⇒ (qeh) Suppose there are a Σ -ABox A and a Σ -query q(a) in DL-Litehorn such that (T2, A) |(cid:15) q(a) and(T1, A) (cid:11)|(cid:15) q(a). Let I1 be an most countable model of (T1, A) with I1 (cid:11)|(cid:15) q(a), and let Ξ be the set of Σ Q T1∪T2 -typesrealised in I1. By (spr), Ξ is sub-precisely T2-realisable. By Lemma 88, there is a model I∗of T2 and a Σ -homomorphismfrom I∗onto I1. But then I∗ |(cid:15) A and I∗ (cid:11)|(cid:15) q(a), from which (T2, A) (cid:11)|(cid:15) q(a), contrary to our assumptions.(qeh) ⇒ (spr) Let Ξ be the set of Σ Q T1∪T2 -types realised in a model I of T1, and let AΞ = {B(at ) | B ∈ t+, t ∈ Ξ },is a fresh object name for each t ∈ Ξ . It follows that I |(cid:15) (T1, AΞ ). Suppose that Ξ is not sub-precisely T2-where atrealisable. Then two cases are possible:1. If, for every model I(cid:18)of T2, there is t ∈ Ξ with (have (T1, AΞ ) (cid:11)|(cid:15) q but (T2, AΞ ) |(cid:15) q, which is a contradiction.(cid:3)B∈t+ B)I(cid:18) = ∅, i.e., I(cid:18) (cid:11)|(cid:15) AΞ , then consider the query q = ⊥: we2. Otherwise, every model I(cid:18)type from Ξ . Let Θ be the set of all such Σ Q T1∪T2 -types. As Θ (cid:11)= ∅, we can take q = ∃x(T2, AΞ ) |(cid:15) q but (T1, AΞ ) (cid:11)|(cid:15) q, which is again a contradiction.of T2 satisfying AΞ must realise a Σ Q T1∪T2 -type that is not positively contained in anyB∈t+ B(x). Thent∈Θ(cid:28)(cid:29)This completes the proof of the theorem. (cid:2)The following model-theoretic property of TBoxes in DL-LiteNhorn is standard in Horn logic; see, e.g., [10].R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411131Lemma 89. Let T be a TBox in DL-Litesuch that JT (t) realises t and, for every model I of T realising t, there exists a Σ -homomorphism from JT (t) to I.Nhorn and t a T -realisable Σ Q -type. Then there exists an at most countable model JT (t) of TIn what follows we fix some model JT (t) mentioned in the formulation of the lemma and call it the minimal model ofT realising t.Given a realisable set Ξ of Σ Q -types, let the TBox TΞ contain all the Σ Q -concept inclusionsB1 (cid:5) · · · (cid:5) Bk (cid:8) B+Nhorn such that B ∈ t+in DL-Lite(i) if, for distinct Σ Q -concepts B 1, . . . , Bk, there is no t ∈ Ξ with B1, . . . , Bk ∈ t(ii) if B ∈ tT -realisability of a set Ξ in terms of T ∪ TΞ -realisability:, for all t ∈ Ξ . We will call TΞ the TBox induced by Ξ . Note thatthen B1 (cid:5) · · · (cid:5) Bk (cid:8) ⊥ is in TΞ , and, for all t ∈ Ξ , then (cid:4) (cid:8) B ∈ TΞ . The following lemma establishes a useful criterion for deciding meet-precisewhenever B1, . . . , Bk ∈ t++Lemma 90. Let Ξ be a set of Σ Q -types and t a Σ Q -type. Let Ξt = {t i ∈ Ξ | tand t+ =(cid:12)t.t i ∈Ξt+iIn particular, Ξ is meet-precisely T -realisable, for a TBox T in DL-Lite+ ⊆ t+i}. Then t is TΞ -realisable if, and only if, Ξt (cid:11)= ∅Nhorn, if, and only if, every type in Ξ is T ∪ TΞ -realisable.B∈t+ B (cid:8) ⊥ is in TΞ , and so t cannot be TΞ -realisable. If Ξt (cid:11)= ∅ then, for every B(cid:18) ∈(cid:12)t i ∈Ξt+i,tProof. (⇒) If Ξt = ∅ thenwe have(cid:18)(cid:3)B∈t+ B (cid:8) Bin TΞ , and so B(⇐) If there is no model of TΞ realising t, then TΞ |(cid:15)+. Thus, t(cid:3)(cid:18)(cid:18)(cid:18) ∈ t+ ⊇+B∈t+ (cid:8) B, and soB∈t+ B (cid:8) Bt \ tsuch that TΞ |(cid:15)t i ∈Ξt+t.iB∈t+ B (cid:8)is in TΞ . Therefore, B(cid:3)(cid:3)(cid:12)(cid:3)(cid:3)¬B∈t\t+ B, whence, by Theorem 24, there is ¬B, which is impossible. (cid:2)(cid:18) ∈ t+(cid:18) ∈Lemma 91. Let Ξ be a T -realisable set of Σ Q -types. If a Σ Q -type t is TΞ -realisable then t is T -realisable.Proof. By Lemma 90, there are t1, . . . , tk ∈ Ξ such that tsuppose that there is no model of T realising t. As we saw, it follows that there is ¬Band so we must have B. Now, in the same way as in the proof of Lemma 90 (⇐),(cid:18) ∈ t \ t+(cid:18)B∈t+ (cid:8) B,, which is a contradiction. (cid:2)(cid:18) ∈ t i , for all i = 1, . . . , k. But then Bsuch that T |(cid:15)(cid:18) ∈ t(cid:3)i t+(cid:12)+ =+iWe are now in a position to prove the following criterion:Theorem 27. For any TBoxes T1 and T2 in DL-LiteNhorn and any signature Σ , the following conditions are equivalent:(sceh) T1 strongly Σ -concept entails T2 in DL-LiteN(sqeh) T1 strongly Σ -query entails T2 in DL-Litehorn;(mpr) every precisely T1-realisable set of Σ Q T1∪T2 -types is meet-precisely T2-realisable.Nhorn;Proof. The implication (sqeh) ⇒ (sceh) is trivial.(mpr) ⇒ (sqeh) Suppose there are a Σ -TBox T , a Σ -ABox A and a Σ -query q(a) in DL-LiteNhorn with (T2 ∪ T , A) |(cid:15) q(a)but (T1 ∪ T , A) (cid:11)|(cid:15) q(a). Let I be a model of (T1 ∪ T , A) with I (cid:11)|(cid:15) q(a), and let Ξ be the set of Σ Q T1∪T2 -types realisedin I. Since I |(cid:15) TΞ , every type in Ξ is TΞ -realisable. Let Ξ ∗be the set of all TΞ -realisable Σ Q T1∪T2 -types. Consider(cid:26)J = I ⊕JTΞ (t).t∈Ξ ∗As Ξ is T1 ∪ T -realisable, by Lemma 91, every TΞ -realisable type is T1 ∪ T -realisable, and so, by Lemma 89, J |(cid:15) T1 ∪ T .Clearly, we have J |(cid:15) A and, as there is a Σ -homomorphism from J onto I, J (cid:11)|(cid:15) q(a). Also, observe that J preciselyrealises Ξ ∗: indeed, J realises every type in Ξ ∗and, conversely, every Σ Q T1∪T2 -type realised in J is TΞ -realisable.of T2 realising all the types in Ξ ∗By (mpr) and Lemma 90, there exists a model I(cid:18)and such that each Σ Q T1∪T2 -typerealised in I(cid:18)is TΞ -realisable, by Lemma 91, everyTΞ ∗ -realisable type t is TΞ -realisable, and so t ∈ Ξ ∗of T2such that I∗ ∼Σ J ω. It follows that I∗is a model of (T2 ∪ T , A) such that I∗ (cid:11)|(cid:15) q(a), which is a contradiction.. We then apply Lemma 87 to J and Ξ ∗is TΞ ∗ -realisable. In fact, I(cid:18)realises precisely the set Ξ ∗and find a model I∗(sceh) ⇒ (mpr) Let Ξ be a set of precisely T1-realisable Σ Q T1∪T2 -types. Then T1 ∪ TΞ (cid:11)|(cid:15)¬B∈t\t+ B, for, whence, by (sceh), T2 ∪ TΞ (cid:11)|(cid:15)each t ∈ Ξ . Therefore, for each t ∈ Ξ and each ¬B. As an intersection of models of a Horn KB is also a model of this KB, we obtain T2 ∪ TΞ (cid:11)|(cid:15)B∈t+ B (cid:8) BB∈t+ B (cid:8)(cid:3)(cid:3)¬B∈t\t+ B, and thus t is T2 ∪ TΞ -realisable, for each t ∈ Ξ . Take the disjoint union J of all models It of T2 ∪ TΞ realisingt, for t ∈ Ξ . Clearly, J realises all the types in Ξ and each Σ Q T1∪T2 -type realised in J is T2 ∪ TΞ -realisable. Therefore, byLemma 90, Ξ is meet-precisely T2-realisable. (cid:2), we have T1 ∪ TΞ (cid:11)|(cid:15): since Ξ ∗B∈t+ B (cid:8) BB∈t+ B (cid:8)(cid:18) ∈ t \ t(cid:3)(cid:3)(cid:3)(cid:3)+(cid:18)(cid:18)1132R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141A.3. Proofs of results from Section 5Theorem 33. All the entailment relations from Section 3 are robust under vocabulary extensions in DL-LiteNbool and DL-LiteNhorn.Proof. We go through the different notions of Σ -entailment.(a) Σ -concept entailment in DL-LiteNbool. This case follows from uniform interpolation of DL-Literem 76 above. Suppose that T1 Σ -concept entails T2, sig(T2) ∩ Σ (cid:18) ⊆ Σ , T2 |(cid:15) C1 (cid:8) C2, and sig(C1 (cid:8) C2) ⊆ Σ (cid:18)show that T1 |(cid:15) C1 (cid:8) C2. Let T2,Σ be a uniform interpolant of T2 with respect to Σ in DL-LiteT2,Σ |(cid:15) C1 (cid:8) C2, by the definition of uniform interpolants. Hence T1 |(cid:15) C1 (cid:8) C2, as required.(b) Σ -concept entailment in DL-LiteNhorn. This case follows from uniform interpolation of DL-LiteNbool, as proved in Theo-. We have toNbool. Then T1 |(cid:15) T2,Σ andNhorn in the same way asin (a).1 . Therefore, I∗precisely realises Ξ .N(c) Σ -query entailment in DL-LiteSuppose that T1 Σ -query entails T2 and Σ (cid:18)Assume that there is a model I1 of T1 precisely realising a set Ξ of Σ (cid:18)is T1-precisely realisable, it is also precisely T2-realisable. By Lemma 87, we then obtain a model I∗I∗ ∼Σ (cid:18) IωNbool (and, equivalently, strong Σ -concept entailment and strong Σ -query entailment).is a signature with sig(T2) ∩ Σ (cid:18) ⊆ Σ . We use the criterion of Theorem 21.Q T1∪T2 -types. Let Ξ(cid:4)Σ = {t(cid:4)Σ | t ∈ Ξ }. As Ξ(cid:4)Σof T2 such that(d) Σ -query entailment in DL-Liteis a signature with sig(T2) ∩ Σ (cid:18) ⊆ Σ . Weuse the criterion of Theorem 26. Assume that there is a model of T1 precisely realising a set Ξ of Σ (cid:18)Q T1∪T2 -types. LetΞ(cid:4)Σ = {t(cid:4)Σ | t ∈ Ξ }. As Ξ(cid:4)Σ is T1-precisely realisable in a model I1, it is also sub-precisely T2-realisable. By Lemma 88,we then obtain a model I∗onto I1. Therefore, I∗sub-precisely realises Ξ .horn. Suppose T1 Σ -query entails T2 and Σ (cid:18)of T2 realising all the types in Ξ and a Σ (cid:18)-homomorphism from I∗(e) Strong Σ -query entailment in DL-LiteQ T1∪T2 -types is precisely T1-realisable. Consider the set Ξ ∗Nhorn (and, equivalently, strong Σ -concept entailment). Suppose that T1 stronglyis a signature with sig(T2) ∩ Σ (cid:18) ⊆ Σ . We use the criterion of Theorem 27. Assume that aΣ -concept entails T2 and Σ (cid:18)set Ξ of Σ (cid:18)Q T1∪T2 -types (constructedin the same way as in the proof of Theorem 27, (mpr) ⇒ (sceh)). It is precisely realised in some model J . Let Ξ ∗(cid:4)Σ ={t(cid:4)Σ | t ∈ Ξ ∗}. As Ξ ∗(cid:4)Σ is precisely T1-realisable (e.g., in J ), there exists a model I2 of T2 meet-precisely realising Ξ ∗(cid:4)Σ .By Lemma 90, every type in Ξ ∗(cid:4)Σ is T2 ∪ TΞ ∗(cid:2)Σ -realisable, and by Lemma 91, TΞ(cid:2)Σ -realisable. Thus, J and I2 preciselyrealise the same set Ξ(cid:4)Σ of Σ Q T1∪T2 -types. By Lemma 87, we obtain a model I∗of T2 such that I∗ ∼Σ (cid:18) J ω, and thusprecisely realising Ξ ∗and every Σ (cid:18)Q T1∪T2 -type in Ξ is T2 ∪ TΞ -realisable, by Lemma 90, Ξ is meet-preciselyT2-realisable.of all TΞ -realisable Σ (cid:18). As Ξ ⊆ Ξ ∗(f) Σ -model entailment. Suppose that T1 Σ -model entails T2 and Σ (cid:18)is a signature with sig(T2) ∩ Σ (cid:18) ⊆ Σ . Let I be aof T2 that coincides with I on Σ . As sig(T2) ∩ Σ (cid:18) ⊆ Σ , we may actually assume-model(one may ‘copy’ the valuation of the symbols in Σ (cid:18) \ sig(T2) from I). Hence T1 Σ (cid:18)model of T1. Then there exists a model I(cid:18)that I(cid:18)coincides with I on Σ (cid:18)entails T2. (cid:2)Theorem 36. All the inseparability relations from Section 3 are robust under joins in DL-LiteNbool and DL-LiteNhorn.NNbool. Suppose that T and Ti are Σ -concept inseparable in DL-Litebool, for i = 1, 2.Proof. (a) Σ -concept inseparability in DL-LiteConsider a T -realisable Σ Q -type t with Q = Q T ∪T1∪T2 . By Theorem 20, it is sufficient to show that t is T1 ∪ T2-realisable.Let Ξ be the set of all T -realisable Σ Q -types. As T and Ti are Σ -concept inseparable, Ξ is also the set of all Ti -realisableΣ Q -types, for i = 1, 2. It follows that Ξ is precisely Ti -realisable, for i = 1, 2. Using Lemma 87 with Σ (cid:18) = sig(T1), we obtaina model for T1 ∪ T2 precisely realising Ξ . This model realises t.N(b) Σ -concept inseparability in DL-Litehorn. This case follows from (a) by Theorem 24.Nbool (and, equivalently, strong Σ -concept inseparability and strong Σ -query insepa-(c) Σ -query inseparability in DL-LiteNrability). Suppose that T and Ti are Σ -query inseparable in DL-Litebool, for i = 1, 2, and let Ξ be a precisely T -realisableset of Σ Q -types, where Q = Q T ∪T1∪T2 . By Theorem 21, it is sufficient to show that Ξ is precisely T1 ∪ T2-realisable. ByTheorem 21, Ξ is precisely Ti -realisable, for i = 1, 2. Using Lemma 87, we obtain a model for T1 ∪ T2 precisely realising Ξ .NNhorn. Suppose that T and Ti are Σ -query inseparable in DL-Litehorn, for i = 1, 2, andlet Ξ be a precisely T -realisable set of Σ Q -types, where Q = Q T ∪T1∪T2 . By Theorem 26, it is sufficient to show that Ξ issub-precisely T1 ∪ T2-realisable. As T and Ti are Σ -query inseparable, we obtain a set Ξ (cid:18) ⊇ Ξ which is precisely T -, T1-,and T2-realisable and such that each t ∈ Ξ (cid:18)is positively contained in a type from Ξ . By Lemma 87, we obtain a model forT1 ∪ T2 precisely realising Ξ (cid:18). But then Ξ is sub-precisely T1 ∪ T2-realisable.(d) Σ -query inseparability in DL-LiteNhorn (and, equivalently, strong Σ -concept inseparability). Suppose that T and Ti(e) Strong Σ -query inseparability in DL-LiteNhorn, for i = 1, 2, and let Ξ be a precisely T -realisable set of Σ Q -types, whereare strongly Σ -query inseparable in DL-LiteQ = Q T ∪T1∪T2 . Let I be a model of T precisely realising Ξ . Consider the set Ξ ∗of all TΞ -realisable Σ Q -types as in theproof of Theorem 27, (mpr) ⇒ (sceh). As follows from that proof, the set Ξ ∗is precisely Ti -realisable, for i = 1, 2. Hence,by Lemma 87, there exists a model for T1 ∪ T2 precisely realising Ξ ∗, and thus meet-precisely realising Ξ .(f) Σ -model inseparability. Suppose that T and Ti are Σ -model inseparable and sig(T1) ∩ sig(T2) ⊆ Σ . Let I be a modelof T . Then there are models I1 and I2 of T1 and T2, respectively, that coincide with I on Σ . As sig(T1) ∩ sig(T2) ⊆ Σ , wemay assume that I1(cid:4)sig(T2)\Σ = I2. Thus I1 is a model of T1 ∪ T2 coinciding with I on Σ . (cid:2)R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411133Theorem 40. If T1 Σ -query entails (or, equivalently, strongly Σ -concept entails) T2 in DL-LiteT2 in SHIQ.Nbool, then T1 strongly Σ -query entailsProof. Suppose (T1 ∪ T , A) (cid:11)|(cid:15) q(a). Take a model J of (T1 ∪ T , A) such that J (cid:11)|(cid:15) q(a). By Lemma 87, we can find a modelI∗is a model of (T ∪ T2, A) such that I∗ (cid:11)|(cid:15) q(a). Hence (T2 ∪ T , A) (cid:11)|(cid:15) q(a). (cid:2)of T2 such that I∗ ∼Σ J ω. But then I∗A.4. Proofs of results from Section 6Lemma 53. There is an algorithm which, given a TBox T in DL-Liteistic polynomial time whether Ξ has a precise, sub-precise or meet-precise T -witness and constructs such a witness if it exists.Nhorn and a set Ξ of Σ Q -types with Q ⊇ Q T , decides in determin-NProof. First we observe that, given a TBox T in DL-Litehorn and a Σ Q -type t with Q ⊇ Q T , clT (t) can be computed inpolynomial time: just extend t with all the basic sig(T )Q -concepts B such that B 1 (cid:5) · · · (cid:5) Bk (cid:8) B ∈ T and the B i are alreadyin the computed extension of t.(cid:18)0, . . . , t}. In all three algorithms we first extend the types of Ξ to sig(T )Q -types and check whether they areLet Ξ = {t(cid:18)kT -realisable (cf. (w1) and (w2) in Definition 47):1. For each 0 (cid:3) i (cid:3) k, compute t i = clT (twith answer ‘no’ (see Proposition 23).(cid:18)i) and check whether t i(cid:4)Σ = t(cid:18)i and ⊥ /∈ t i . If this is not the case for some i, stopThe types t0, . . . , tk will form the first sequence of sig(T )Q -types in a T -witness of Ξ (provided that it exists). So, itremains to construct the second sequence (and actually find all required witnesses for nonempty roles). The algorithm isiterative. To start with, we let t j = t0, for k < j (cid:3) k + 2m, where m is the number of role names in T (note that the choiceof t0 is arbitrary). Also, let the set Ω0 of ‘processed’ roles be empty.Suppose we are at step n. Select a role name P i from T that is nonempty and has not been processed yet (cf. (w3)), i.e.,some P i /∈ Ωn such that∃P i, ∃P(cid:7)(cid:6)∩ t j (cid:11)= ∅,−ifor 0 (cid:3) j (cid:3) k + 2m.If no such role exists we terminate: ((t0, . . . , tk), (tk+1, . . . , tm+2k)) is the required T -witness for Ξ . Otherwise, computetk+2i−1 = clT (t∃P i ) and tk+2i = clT (t∃P= {B}. Terminate with answer ‘no’if either ⊥ ∈ tk+2i−1 or ⊥ ∈ tk+2i (for these types are not T -realisable, see Proposition 23 and (w1)). The next step of thealgorithm depends on the particular type of witness: for t being both tk+2i−1 and tk+2i , we check), where t B is the sig(T )Q -type such that t+B−i(cid:18)2-a. whether t(cid:4)Σ = t+(cid:4)Σ ⊆ t2-b. whether t2-c. whether Ξt (cid:11)= ∅ and tfor some t(cid:18)+(cid:18) ∈ Ξ , if we need a precise T -witness;for some t(cid:12)+(cid:4)Σ =(cid:18) ∈ Ξ , if we need a sub-precise T -witness;t i ∈Ξt, where Ξt = {t+(cid:4)Σ ⊆ t∈ Ξ | t(cid:18)+i(cid:18)i(cid:18)it}, if we need a meet-precise T -witness.Terminate with answer ‘no’ if the test fails. Otherwise, we update the types tk+2i−1 and tk+2i of the sequence with the justcomputed ones and set Ωn+1 = Ωn ∪ {P i}.Clearly, the algorithm runs in polynomial time. (cid:2)Next, we provide proofs of Lemma 59, Theorems 60 and 61. For Lemma 59, we have to construct a BAPA formula ϕP ,qmaxstating that a set-system S has a solution. For the construction we require, in addition to the notion of a solution to S, thefollowing notion of a left solution. LetS = ( A1, . . . , Aqmax , A∞), (B1, . . . , Bqmax , B∞)be a set-system. A relation ρ is called a left solution to S if– Aq is the set of points of ρ-outdegree q, for 1 (cid:3) q (cid:3) qmax; A∞ is the set of points of ρ-outdegree > qmax;– every point in Bq has ρ-indegree (cid:3) q, for 1 (cid:3) q (cid:3) qmax; B∞ is the set of points of ρ-indegree > qmax.Thus, the only difference between a left solution and a solution is that, in the former, points in Bq do not necessarily haveρ-indegree q, but can have ρ-indegree (cid:3) q. First, we establish necessary and sufficient conditions for a set-system to havea (left) solution in some special case:Lemma 92. Let qmax < ω and S = ( A1, . . . , Aqmax , ∅), (B1, . . . , Bqmax , ∅) be a set-system.(B) If S has a solution thenqmax(cid:31)qmax(cid:31)q · | Aq| =q · |Bq|.(5)q=1Conversely, if(cid:2)qmaxq=1q=1| Aq| (cid:2) q2max or(cid:2)qmaxq=1|Bq| (cid:2) q2max, then (5) implies that S has a solution.1134R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141(BL) If S has a left solution thenqmax(cid:31)q=1q · | Aq| (cid:3)qmax(cid:31)q=1q · |Bq|.(6)Conversely, if(cid:2)qmaxq=1| Aq| (cid:2) q2max or(cid:2)qmaxq=1|Bq| (cid:2) q2max, then (6) implies that S has a left solution.Before we come to the proof, note that in (B), (5) alone does not imply that S has a solution. As an example consider theset system ( A1, A2, ∅), (B1, B2, ∅), where A1 = B1 = ∅ and A2 = B2 = {a}. Clearly, (5) holds but S does not have a solution.The same example shows that in (BL), (6) alone does not imply that S has a left solution. We now come to the proof.(7)(8)qmaxq=1| Aq| (cid:2) q2Proof. (B) A straightforward pigeonhole argument shows that (5) holds if S has a solution. Now suppose that (5) holds and(cid:2)max. If the sums in (5) are infinite (i.e., at least one of the | Aq| and one of the |Bq| is an infinite cardinal),qmaxq=1 Aq andthen a solution ρ is readily constructed. So we concentrate on the case where the sums are finite. Let A =qmaxq=1 Bq. We first show that there exists a map f : A × B → N such that, for each 1 (cid:3) q (cid:3) qmax,B =(cid:31)(cid:31)(cid:13)(cid:13)f (a, d) = q,for every a ∈ Aq,f (d, b) = q,for every b ∈ Bq.d∈B(cid:31)andd∈ A(cid:31)Assume that such a map does not exist. Take a map f : A × B → N such that, for 1 (cid:3) q (cid:3) qmax,f (a, d) (cid:3) q,for every a ∈ Aq,andf (d, b) (cid:3) q,for every b ∈ Bqd∈Bd∈ A(the set of such maps is nonempty, e.g.,and (5),f (x, y) = 0 satisfies (8)) and(cid:2)(x, y)∈ A×B f (x, y) is maximal. By our assumption(cid:31)(x, y)∈ A×Bf (x, y) <qmax(cid:31)q=1q · | Aq| =qmax(cid:31)q=1q · |Bq|.(cid:2)(cid:2)(cid:2)(x, y)∈ A×B f(cid:2)d∈B f (a1, d) < q1 and(cid:18)(x, y) contrary to f having the maximal(cid:18)(x, y) = f (x, y) for all (x, y) ∈ A × B distinct from (a, b). Then (8) still holds for fThus, there exist q1, q2 and a ∈ Aq1 , b ∈ Bq2 such that(cid:18)(a, b) = f (a, b) + 1 and ff(cid:2)(x, y)∈ A×B f (x, y) <We now show that there actually exists a map with (7) into {0, 1}. Suppose such a map does not exist. Take a mapf (x, y)>1 f (x, y) > 1 is minimal and find a, b with f (a, b) > 1. We havemax, and(cid:18), b) = 0. Indeed, let C = {c | f (a, c) > 0} and(cid:18) ∈ A \ D and,max. As | A| (cid:2) q2max, there exists a(cid:18), b) = 0. Define a new map f 0 which coincidesf with (7) such that(cid:18)) = 0, and f (a(cid:18), bso there exists (aD = {d | there is c ∈ C with f (d, c) > 0}. We have |C| < qmax, and so |D| < q2by (7), there exists bwith f except that(cid:4)a, b(cid:5)(cid:18)(cid:18), b(cid:4)a(cid:18), b(cid:5)(cid:18)= f− 1.(cid:18)) ∈ A × B such that f (ad∈ A f (d, b) < q2. Define f(cid:18)) > 0. By construction,by setting(cid:18)but(x, y)∈ A×B f (x, y).(cid:18) ∈ B with f (a| Aq| (cid:2) q2(cid:18)) = f (a(cid:18)) > 0,= 1,= 1,f (a, bf (a, bqmaxq=1(cid:4)a(cid:4)a(cid:18), b(cid:18), band, b(cid:2)(cid:2)(cid:5)(cid:5)(cid:18)(cid:18)f 0f 0(cid:18)f 0(a, b) = f (a, b) − 1,(cid:2)(cid:2)f 0(cid:2)Then f 0 still has (7) and(cid:2)|Bq| (cid:2) q2f 0(x, y)>1 f 0(x, y) <max is considered analogously.qmaxq=1Let f : A × B → {0, 1} satisfy (7). Then the relation ρ = {(a, b) ∈ A × B | f (a, b) = 1} is a solution to S.(BL) can be proved in the same way as (B). (cid:2)f (x, y)>1 f (x, y), contrary tof (x, y)>1 f (x, y) being minimal. The case whenNote that the existence of a (left) solution to a set-system S does not depend on the sets themselves but only on theircardinalities. Thus, we can (and will) equivalently represent a set-system S in the formS = (n1, . . . , nqmax , n∞), (m1, . . . , mqmax , m∞),where the ni and mi are cardinal numbers. In what follows, we will choose the representation most convenient for ourpurposes. The following lemma will be used to prove Lemma 59. It covers all four possible combinations and reduces theproblem whether S has a solution to the special cases mentioned in Lemma 92.Lemma 93. Let qmax (cid:2) 0. For any set-system S = ( A1, . . . , Aqmax , A∞), (B1, . . . , Bqmax , B∞), the following holds:(C0) If | A∞| > qmax and |B∞| > qmax then S has a solution.(C1) If | A∞| > qmax and |B∞| (cid:3) qmax then S has a solution if, and only if, the following holds:R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411135– if |B∞| = 0 then S(cid:18)1– if |B∞| > 0 then S(cid:18)2= ( A1, . . . , Aqmax , A∞, ∅), (B1, . . . , Bqmax , ∅, ∅) has a left solution;= ( A|B∞|+1, . . . , Aqmax , A∞, ∅, . . . , ∅ !" #|B∞|), (B1, . . . , Bqmax , ∅) has a left solution.(C2) If | A∞| (cid:3) qmax and |B∞| > qmax then S has a solution if, and only if, the following holds:= (B1, . . . , Bqmax , B∞, ∅), ( A1, . . . , Aqmax , ∅, ∅) has a left solution;= (B| A∞|+1, . . . , Bqmax , B∞, ∅, . . . , ∅ !" #| A∞|– if | A∞| = 0 then S(cid:18)1– if | A∞| > 0 then S(cid:18)2), ( A1, . . . , Aqmax , ∅) has a left solution.(C3) If | A∞| (cid:3) qmax and |B∞| (cid:3) qmax then S has a solution if, and only if, there are numbers nDq , for D ⊆ B∞ and 1 (cid:3) q (cid:3) qmax, and(cid:2)mDD⊆B∞ nD–q– for all e ∈ B∞,– and S(cid:18) = (nq , for D ⊆ A∞ and 1 (cid:3) q (cid:3) qmax, such that the following holds:(cid:2)= |Bq|, for all 1 (cid:3) q (cid:3) qmax;D⊆ A∞ mDqq > qmax − | A∞| and, for all e ∈ A∞,nD(cid:18), 0) has a solution, where1, . . . , mD⊆B∞e∈D, 0), (m(cid:18)qmax(cid:2)(cid:2)qmaxq=1D⊆ A∞e∈DmDq > qmax − |B∞|;nDq(cid:18)and mk=qmax(cid:31)(cid:31)q=1D⊆ A∞q−|D|=kmDq ,for 1 (cid:3) k (cid:3) qmax.= | Aq| and(cid:2)(cid:2)qmaxq=1(cid:18)(cid:18)1, . . . , nqmaxqmax(cid:31)(cid:31)q=1D⊆B∞q−|D|=k(cid:18)nk=(cid:13)Proof. Let A =qmaxq=1 Aq and B =qmaxq=1 Bq.(cid:13)(cid:13)(C0) | A∞| > qmax and |B∞| > qmax. For every a ∈ Aq, take a set Ya ⊆ B∞ of cardinality q, and, for every a ∈ A∞, take aset Ya ⊆ B∞ of cardinality qmax + 1. Such sets exist because |B∞| > qmax. Similarly, for every b ∈ Bq, take a set Xb ⊆ A∞ ofcardinality q, and for every b ∈ B∞, take a set Xb ⊆ A∞ of cardinality qmax + 1. Such sets exist because | A∞| > qmax. Thenb∈B∪B∞ ( Xb × {b}) is clearly a solution to S.the relation ρ =(C1) | A∞| > qmax and |B∞| (cid:3) qmax. Consider first |B∞| = 0. Let ρ be a solution to S. For every a ∈ A∞ such thatoρ (a) > qmax + 1, we remove (oρ (a) − qmax − 1)-many pairs (a, b) from ρ and denote the resulting binary relation by ρ(cid:18).is a left solution to S(cid:18)Then oρ(cid:18) (a) = qmax + 1 for all a ∈ A∞, and so ρ(cid:18)1 has a left solution ρ.For any q (cid:3) qmax and b ∈ Bq such that iρ (b) < q, take (q − iρ (b))-many points a ∈ A∞ such that (a, b) /∈ ρ and add the pairs(a, b) to ρ. This is possible because | A∞| > qmax. Then the resulting relation ρ(cid:18)1. Conversely, assume that S (cid:18)a∈ A∪ A∞ ({a} × Ya) ∪is a solution to S.(cid:13)The claim for |B∞| > 0 is proved similarly.(C2) | A∞| (cid:3) qmax and |B∞| > qmax. This is a mirror image of (C1).(C3) | A∞| (cid:3) qmax and |B∞| (cid:3) qmax. Suppose that S has a solution ρ. Define A Dq , for D ⊆ B∞, 1 (cid:3) q (cid:3) qmax, and B Dq , forD ⊆ A∞, 1 (cid:3) q (cid:3) qmax, by taking(cid:8)(cid:4)(cid:8) ∀b ∈ B∞(cid:8)(cid:8) ∀a ∈ A∞(cid:6)a ∈ Aq(cid:6)b ∈ BqA DqB Dq==(cid:4)(a, b) ∈ ρ ↔ b ∈ D(a, b) ∈ ρ ↔ a ∈ D(cid:5)(cid:7)(cid:5)(cid:7),.q are the points in Aq that are ρ-related to exactly the points in D ⊆ B∞. We show that the numbers nD|= | A DThus, e.g., A Dq| satisfy the (in)equalities of (C3) and that S (cid:18)= | Aq| follows from the= |B Dand mDqqfact that each a ∈ Aq is in exactly one set of the form A Dq is the number of points awith (a, e) ∈ ρ such that a /∈ A∞. This number must be greater than (qmax − | A∞|) because iρ (e) > qmax and there are atq are considered in the same way. Consider now the restriction ρ(cid:18)most | A∞| points a ∈ A∞ with (a, e) ∈ ρ. The numbers mD(cid:18)k (as defined in (C3)) and the number of points b ∈ Bof ρ to A × B. Then the number of points a ∈ A with oρ (a) = k is n(cid:18)(cid:18)k (as defined in (C3)). Thus, ρ(cid:18)with iρ (b) = k is m1, . . . , nis a solution to (nqmaxFor the converse direction, suppose that we have numbers nDq satisfying the conditions of (C3). Let ρ be a solution, ∅), 0). We may assume that ρ is a solution to a system ( Aq . Let e ∈ B∞. Thenhas a solution. The equality, 0), as required.e∈D⊆B∞ nD(cid:18)1, . . . , mD⊆B∞ nDq, ∅), (Bq , mD, 0), (m, 0),(m(cid:18)qmaxqmaxq=1(cid:2)(cid:2)(cid:2)q(cid:18)(cid:18)1, . . . , A(cid:18)qmax(cid:18)1, . . . , B(cid:18)qmax(cid:18)1, . . . , m(cid:18)qmax(cid:18)1, . . . , nto (nin which(cid:18)qmax– each A– each B(cid:18)k is the disjoint union of sets (cid:21)A Dk is the disjoint union of sets (cid:21)B Dkk(cid:18)⊆ A of cardinality nD⊆ B of cardinality mDq , for D ⊆ B∞ and q − |D| = k;q , for D ⊆ A∞ and q − |D| = k.(cid:18)(cid:2)(cid:2)(cid:2)k , we add to ρ the pairs (a, d), d ∈ D, and the pairs (dNow, for each a ∈ (cid:21)A Dk and each b ∈ (cid:21)B Dresulting relation by ρ0. It follows fromfrom(cid:2). Denote the= | Aq| that the number of points a with oρ0 (a) = q is | Aq|. Similarly,= |Bq| we obtain that the number of points b with iρ0 (b) = q is |Bq|. For e ∈ B∞, using the inequality(cid:18) ∈ A∞ so that the indegreeq > qmax − | A∞|, we can expand ρ0 by sufficiently many pairs (eqmaxq > qmax − |B∞|, we canq=1(cid:18) ∈ B∞ so that the outdegree of each e ∈ A∞ is at least qmax + 1. Theof each e ∈ B∞ is at least qmax + 1. Similarly, for e ∈ A∞, using the inequality(cid:18)) with eexpand ρ0 by sufficiently many pairs (e, eresulting relation ρ is a solution to the set-system ( A1, . . . , Aqmax , A∞), (B1, . . . , Bqmax , B∞). (cid:2)D⊆ A∞ mDqe∈D⊆B∞ nD(cid:18), e) with ee∈D⊆ A∞ mDD⊆B∞ nDq(cid:18), b), d(cid:18) ∈ Dqmaxq=1(cid:2)(cid:2)(cid:18)1136R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141We are now in a position to prove the following:Lemma 59. For every role name P and every number qmax (cid:2) 1, one can construct a BAPA formula ϕP ,qmax with free variablesX=1P , . . . , X=qmax P , X>qmax P , X=1P − , . . . , X=qmax P − , X>qmax P −such that, for every BAPA model M, the following conditions are equivalent:(9)(i) M |(cid:15) ϕP ,qmax ;(ii) the set-system ( XM=1P , . . . , XM=qmax P , XM>qmax P ), ( XM=1P − , . . . , XM=qmax P − , XM>qmax P − ) has a solution.Proof. The formula ϕP ,qmax is defined by a case distinction similar to the formulation of Lemma 93 above. Namely, wedefine ϕP ,qmax as the conjunction of the formulas:– (| X>qmax P | > qmax) ∧ (| X>qmax P − | > qmax) → (0 = 0),– (| X>qmax P | > qmax) ∧ (| X>qmax P − | (cid:3) qmax) → ψ1,– (| X>qmax P | (cid:3) qmax) ∧ (| X>qmax P − | > qmax) → ψ2,– (| X>qmax P | (cid:3) qmax) ∧ (| X>qmax P − | (cid:3) qmax) → ψ3.qmaxq=1| XM=q PThe first conjunct corresponds to (C0) of Lemma 93 stating that a solution exists whenever the cardinalities of the setsof points of outdegree and, respectively, indegree > qmax are greater than qmax. To define formulas ψ1, ψ2, ψ3, note firstthat one can trivially construct a BAPA formula ϕ0satisfying the conditions of Lemma 59 for all models M with(cid:2)|( X=q P − )M| < q2(maxof the free variables in (9) for which solutions exist. (Note that the formula can be of exponential size in qmax.) Now,according to (B) of Lemma 92, we can define a formula ψ B with the intended meaning=1P − , . . . , XMXMP ,qmaxmax) by simply listing all possible configurations of cardinalities < q2=1P , . . . , XMXMhas a solution’max) and (=qmax P , ∅=qmax P − , ∅| < q2qmaxq=1(cid:4)‘(cid:2)(cid:5)(cid:4)(cid:5),by taking(cid:23)qmax(cid:31)q=1(cid:4)q · | X=q P |(cid:5)=(cid:4)q · | X=q P − |(cid:5)qmax(cid:31)q=1(cid:24)(cid:23)(cid:23)∧qmax(cid:31)(cid:4)q=1| X=q P | < q2maxqmax(cid:31)(cid:4)(cid:5)∧q=1| X=q P − | < q2max(cid:24)(cid:5)(cid:24)→ ϕ0P ,qmax.Similarly, by using the condition of (BL) in Lemma 92, we can define a BAPA formula ψ B L stating that a set-system( XM=1P , . . . , XMAnd by Lemma 93, ψ1, ψ2 and ψ3 can be constructed from ψ B and ψ B L (with appropriate renaming of variables). We=qmax P − , ∅) has a left solution.=qmax P , ∅), ( XM=1P − , . . . , XMleave this rather tedious but straightforward construction to the interested reader. (cid:2)Theorem 60. Let Σ = sig(T1). Then T1 Σ -model entails T2 if, and only if, ϕT1,T2 is valid.Proof. The proof is indirect. We show that if T1 does not Σ -model entail T2, then ϕT1,T2 is not valid. The proof of theconverse direction is similar and, therefore, omitted. Let I be a model of T1 which cannot be expanded to a model of T2.Let A be the BAPA structure based on (cid:5) = (cid:5)I. We construct a BAPA model M based on A and refuting ϕT1,T2 , that is,M |(cid:15)(cid:10)α ∧(cid:10)α∈T s,e1P ∈sig(T1)ϕP ,qmaxand M |(cid:15) ¬∃Y(cid:10)α ∧(cid:10)α∈T s,e2P ∈sig(T2)(cid:23)(cid:24)ϕP ,qmax.I= ATo define M, set XMAd ∈ (cid:5) such that there are exactly q points dsame canonical way using Robserve that the set-systemIfor all X A ∈ X such that A is a concept name; for X=qR ∈ X we define XM=qR as the set of all. The remaining values XM>qmax R are defined in the. It should be clear that M |(cid:15) α, for all α ∈ T s,e . To see that M |(cid:15) ϕP ,qmax for every P ∈ sig(T1),(cid:3)qR and XMwith (d, d(cid:18)) ∈ RI(cid:18)(cid:4)=1 P , . . . , XMXMhas the solution ρ = PI=qmax P , XM>qmax P=1 P − , . . . , XMXM=qmax P − , XM>qmax P −(cid:5)(cid:4),(cid:5). Thus, by Lemma 59, M |(cid:15) ϕP ,qmax .(cid:29)α ∧To show the second part, assume that, contrary to our claim, there exist values Y N for Y ∈ Y such that N |(cid:15)P ∈sig(T2) ϕP ,qmax , where N is based on A and interprets the symbols X ∈ X in the same way as M. By Lemma 59, for eachα∈T s,e2(cid:29)P ∈ sig(T s,e(cid:4)) such that P /∈ Σ , there exists a solution ρP of the set-system(cid:5).2=1 P , . . . , X NX N=1 P − , . . . , X NX N=qmax P , X N=qmax P − , X N>qmax P −>qmax P(cid:4)(cid:5),R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411137We define an interpretation J which coincides with I for all symbols in Σ and for which AA ∈ sig(T2) \ Σ and Pto our assumption that no such model of T2 exists. (cid:2)A for all concept namesJ = ρP for all role names P ∈ sig(T2) \ Σ . It is not difficult to show that J is a model of T2, contraryJ = X NIn the remainder of this section we give a proof of Theorem 61 stating that deciding Σ -model entailment for TBoxesNhorn with maximal numerical parameter qmax = 3 is coNExpTime-hard. The proof is by reduction of the modelin DL-Liteconservativity problem for modal logic S5. Recall that formulas of the propositional modal language ML are constructedfrom propositional variables p1, p2, . . . using the Booleans ∧, ¬, and the modal (possibility) operator (cid:3). ML-formulasKare interpreted in (Kripke) models of the form K = ((cid:5)K, p1 , pfor allpropositional variables pi . The interpretation ϕKKiof a modal formula ϕ in K is defined inductively as follows:2 , . . .), where (cid:5)Kis a nonempty set and p⊆ (cid:5)KK∩ ψ K2 ,1(ψ1 ∧ ψ2)K = ψ K(¬ψ)K = (cid:5)K \ ψ K,(cid:8)(cid:6)(cid:8) ∃dd ∈ (cid:5)K((cid:3)ψ)K =(cid:18) ∈ ψ K(cid:7).A global formula is a modal formula in which every propositional variable is in the scope of a (cid:3). Observe that, for everyglobal formula ϕ and every model K, we have ϕK ∈ {∅, (cid:5)K}. We say that K is a model of a global formula ϕ (or that ϕ istrue in K) if ϕK = (cid:5)K.A global formula ϕ2 is said to be a (finite) model conservative extension of a global formula ϕ1 if, for every (finite) model, for all variables pi of ϕ1. The following resultof ϕ2 such that (cid:5)K = (cid:5)K(cid:18)and p= pKiK(cid:18)iK of ϕ1, there exists a model K(cid:18)is proved in [55].5Theorem 94.(i) For any global modal formulas ϕ1 and ϕ2, ϕ2 is a model conservative extension of ϕ1 if, and only if, ϕ2 is a finite model conservativeextension of ϕ1.(ii) It is NExpTime-hard to decide whether a global formula ϕ2 is not a (finite) model-conservative extension of a global formula ϕ1.We first present a reduction of model conservativity in S5 to Σ -model entailment between DL-Litemodify this reduction to obtain a reduction of finite model-conservativity in S5 to Σ -model entailment between DL-LiteTBoxes.Fix global modal formulas ϕ1 and ϕ2. Denote by s(ϕi) the set of all formulas ψ and ¬ψ , where ψ is a subformula of ϕi .For every ψ ∈ s(ϕi), take a concept name Aψ and, additionally, for every (cid:3)ψ ∈ s(ϕi), take three role names S(cid:2)ψ , L(cid:2)ψ andS¬(cid:2)ψ . Let Dom and Box be fresh concept names.The extensions of Dom will be employed to simulate the domains of S5-models. Thus, the interpretation ψ KNhornNbool TBoxes. Then wesubformula ψ of ϕi will correspond to ( Aψ (cid:5) Dom)I(cid:5)IDL-Liteas well but prefer allowing Dom to be a proper subset of (cid:5)INhorn.)in the description logic interpretation I. (We could work with Dombecause that will be necessary for the reduction toWe assemble a TBox T1 by first encoding the truth-conditions for ∧ and ¬ in the obvious manner by takingof aI =¬ Aψ (cid:5) Dom ≡ A¬ψ (cid:5) Dom,(cid:5) Dom ≡ Aψ1∧ψ2(cid:5) Aψ2for all ¬ψ ∈ s(ϕ1),(10)Aψ1(11)To encode the truth condition for (cid:3) we use, besides A(cid:2)ψ , the role names S(cid:2)ψ , S¬(cid:2)ψ and L(cid:2)ψ . First we state that, forevery (cid:3)ψ ∈ s(ϕ1), the extensions of ∃S(cid:2)ψ and A(cid:2)ψ as well as their negations coincide on Dom:(cid:5) Dom,for all ψ1 ∧ ψ2 ∈ s(ϕ1).Dom (cid:5) A(cid:2)ψ ≡ Dom (cid:5) ∃S(cid:2)ψ ,Dom (cid:5) A¬(cid:2)ψ ≡ Dom (cid:5) ∃S¬(cid:2)ψ .Next, we state that S(cid:2)ψ and S¬(cid:2)ψ , for (cid:3)ψ ∈ s(ϕ1), are binary relations between Dom and Box:∃S(cid:2)ψ (cid:8) Dom,∃S¬(cid:2)ψ (cid:8) Dom,To ensure that Box is nonempty if Dom is nonempty (even for ϕ1 without occurrences of (cid:3)), we take(cid:8) Box,(cid:8) Box.∃S∃S−¬(cid:2)ψ−(cid:2)ψDom (cid:8) ∃R0,∃R−0(cid:8) Box,(12)(13)(14)for a fresh role name R0. Finally, we connect Aψ and A(cid:2)ψ (via S(cid:2)ψ , S¬(cid:2)ψ , and L(cid:2)ψ ) by stating, for every (cid:3)ψ ∈ s(ϕ1),Aψ (cid:5) Dom (cid:8) ∃S(cid:2)ψ ,∃S(cid:2)ψ (cid:8) ∃Lψ ,∃L−ψ(cid:8) Dom (cid:5) Aψ ,∃S−(cid:2)ψ(cid:5) ∃S−¬(cid:2)ψ(cid:8) ⊥.(15)5 Note that this is result is not formulated explicitly in [55] but follows immediately from the proof of [55, Theorem 4] stating that the conservativityproblem is coNExpTime-hard for a large family of normal modal logics including S5.1138R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141These inclusions together enforce that A(cid:2)ψ (cid:5) Dom simulates (cid:3)ψ in models where Box is a singleton set: in such a modelI we have (∃S(cid:2)ψ )I = ∅ or (∃S¬(cid:2)ψ )I = ∅, by the last inclusion of (15) and the condition that the range of S(cid:2)ψ andS¬(cid:2)ψ is a subset of Box. Thus, if (∃S(cid:2)ψ )I (cid:11)= ∅ then, by (12) and (10), (∃S(cid:2)ψ )I ⊇ Dom. Using this implication and theremaining inclusions in (15), (12) and (13), we obtain that ( Aψ (cid:5) Dom)I (cid:11)= ∅ if, and only if, (∃S(cid:2)ψ )I (cid:11)= ∅ if, and only if,(∃S(cid:2)ψ )I = Dom, as required. Finally, to say that ϕ1 is true we take:if, and only if, ( A(cid:2)ψ (cid:5) Dom)I = DomIIIDom (cid:8) Aϕ1 .(16)Thus, T1 consists of the concept inclusions (10)–(16).We construct T2 in the same way (but now taking concept inclusions for ψ ∈ s(ϕ2)), except that we do no includeDom (cid:8) Aϕ2 corresponding to (16) into T2. Instead, we take a set of inclusions that forces, when not satisfiable, Box to beand include into T2 the following axioms statinga singleton set. To this end, we consider three fresh role names S0, S, S(cid:18)that S and Sto the reader):(cid:18)(cid:18)are functions from Dom to Box (we leave the inclusions for S(cid:2) 2 S (cid:8) ⊥.− (cid:8) Box,∃S∃S ≡ Dom,We also add an axiom saying that if a point is in the range of both S and S(cid:18), then it is in the domain of S0:∃S− (cid:5) ∃S(cid:18) − (cid:8) ∃S0.Finally, we encode that ϕ2 is true by taking∃S−0(cid:8) Dom (cid:5) Aϕ2 .Lemma 95. ϕ2 is a model conservative extension of ϕ1 if, and only if, T1 Σ -model entails T2, for Σ = sig(T1).(17)(18)(19)Proof. Suppose ϕ2 is not a model conservative extension of ϕ1. Take a model K of ϕ1 for which there is no model K(cid:18)ofϕ2 having the same domain and the same interpretations of the variables in ϕ1 as K (in this case, we simply say that Kcannot be expanded to a model of ϕ2). Define an interpretation I by taking (cid:5)I = (cid:5)KI = {d}, for somed ∈ (cid:5)II = (cid:5)I, Dom, Box, and(b) SI(a) AψI(cid:2)ψIψI0(c) L(d) R= ψ K, for all ψ ∈ s(ϕ1);I= ((cid:3)ψ)K × {d} and S¬(cid:2)ψI × ψ K, for all (cid:3)ψ ∈ s(ϕ1);II × Box= Dom= Dom.= (¬(cid:3)ψ)K × {d}, for all (cid:3)ψ ∈ s(ϕ1);Iexists. Then, by (17)–(19) and BoxIt is readily checked that I is a model of T1. We show that it cannot be expanded to a model of T2. Assume that such anexpansion I(cid:18)of K bybeing a singleton set, AI(cid:18)is a singleton set, onesetting ppcan show by induction that ψ K(cid:18) = Ais nonempty (and so coincides with the domain of K(cid:18)which is a contradiction.for all those variables p in ϕ2 that do not occur in ϕ1. Using the fact that Boxψ for all ψ ∈ s(ϕ2). Hence ϕK(cid:18)I(cid:18)is nonempty. Define an expansion K(cid:18)K(cid:18) = AConversely, assume that T1 does not Σ -model entail T2. Let I be a witness model—i.e., a model of T1 that cannot beI (cid:11)= ∅, by (14). We first show that BoxIexpanded to a model of T2. It is readily checked that Domisand define an extension I0 of I by takinga singleton set. Assume that this is not the case. Choose distinct d, dI × {dI0 = Dom= ∅. Then I0 is a model of (17)–(19) independently of the interpretationSof Aϕ2 . It is straightforward to interpret the remaining fresh symbols of T2 in such a way that I0 is a model of T2, contraryto our assumption.I (cid:11)= ∅. Hence BoxI(cid:18) ∈ Box(cid:18) I0 = DomI × {d}, S(cid:18)}, and SI00I(cid:18)ϕ2),I2Now take a model K with domain DomIsingleton set, it is easily checked by induction that, for all ψ ∈ s(ϕ1),K = A∩ Domand pIpI, for all variables p in ϕ1. Using the fact that Boxis aIψ K = AIψ∩ DomI .Thus, K is a model of ϕ1. We show that there does not exist an expansion K(cid:18)exists. Define an expansion I(cid:18)of I by setting ADefine extensions of S(cid:2)ψ , S¬(cid:2)ψ and Lψ as in (b)–(c) above (now using K(cid:18)IIfrom Domto Boxa contradiction. (cid:2)I(cid:18)0 be a function from Box= ψ K(cid:18)and let Sto DomI(cid:18)ψIIof K that is a model of ϕ2. Assume such a K(cid:18)II.⊇ Domfor (cid:3)ψ ∈ s(ϕ2)). Let SI(cid:18)ϕ2I(cid:18)because ϕK(cid:18) = Domand Sbe functionsis a model of T2, which is(cid:18)I(cid:18). It is readily checked that I(cid:18)for all new ψ ∈ s(ϕ2). Then, AWe now modify the reduction above with the aim of obtaining a reduction to DL-Litelematic’ axiom is (10) encoding negation. To construct a DL-LiteFirst, we state, using an auxiliary role name P , that the whole domain is exactly twice as large as Dom:Nhorn TBox T (cid:18)Nhorn. Observe that the only ‘prob-1 , we take (11)–(16) and replace (10) as follows.(cid:2) 3 P (cid:8) ⊥, Dom ≡ (cid:2) 2 P ,∃P (cid:8) Dom, (cid:2) 2 P− (cid:8) ⊥, (cid:4) (cid:8) ∃P−.(20)R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411139We also state that Aψ and A¬ψ are disjoint: for ψ ∈ s(ϕ1),Aψ (cid:5) A¬ψ (cid:8) ⊥.(21)Finally, we add that Dom and Aψ have the same cardinality for ψ ∈ s(ϕ1). To this end, we use a fresh role name P ψ andsay that P ψ is a bijection from Dom onto Aψ :Aψ ≡ ∃P−ψ , (cid:2) 2 P ψ (cid:8) ⊥, (cid:2) 2 P−ψ(cid:8) ⊥.(22)Dom ≡ ∃P ψ ,Nhorn TBox T (cid:18)The DL-Lite1 consists of concept inclusions (11)–(16) and (20)–(22).Lemma 96. If I is a finite model of T (cid:18)1 then, for all ψ ∈ s(ϕ1), ( A¬ψ (cid:5) Dom)I = (¬ Aψ (cid:5) Dom)I.Proof. By (21), Aand (cid:5)I \ DomIIψ and Aall have the same cardinality and (cid:5)II¬ψ are disjoint. Thus, it is sufficient to show that AIψis finite, a simple pigeonhole argument shows A. In fact, as A∪ AI⊇ Dom∪ AI¬ψIψ , AI¬ψII¬ψ , Dom= (cid:5)I. (cid:2)IψNote that Lemma 96 does not hold for infinite models. To construct T (cid:18)lated for ψ ∈ s(ϕ2)) except (16). We add axioms (17) and (18) from the definition of T2. For T (cid:18)to add (19) as we do not only have to ensure that Box(19) by the axioms saying that a fresh role name Z is an injective function from (cid:5)I1 (formu-2 , however, it is not sufficientis a singleton set but also that I is finite. To this end we replace:2 , we take the concept inclusions from T (cid:18)to (cid:5)II(cid:4) (cid:8) ∃Z ,(cid:2) 2 Z (cid:8) ⊥,(cid:2) 2 Z− (cid:8) ⊥(23)together with the following concept inclusion stating that if a point is in the range of Z and the range of S 0, then it is inDom (cid:5) Aϕ2 :−0− (cid:8) Dom (cid:5) Aϕ2 .(cid:5) ∃Z(24)∃STo understand the purpose of these axioms, recall that a set (cid:5)Iis finite if, and only if, there does not exist an injectivefunction from (cid:5)Ithat is not surjective. Thus, if an interpretation I is infinite, then we can always expand it to amodel I(cid:18)of (23) and (24) by choosing an injective but non-surjective function Z whose range is disjoint from the range ofS0 (as we can always choose an S0 having only one point in its range). On the other hand, if I is finite, then (23) and (24)enforce, in the same way as (19) above, that Dom (cid:5) Aϕ2 is nonempty if Box is a singleton set.to (cid:5)IThe following lemma can be proved using this observation and combining the proof of Lemma 95 with Lemma 96:Lemma 97. ϕ2 is a finite model conservative extension of ϕ1 if, and only if, T (cid:18)1 Σ -model entails T (cid:18)2 , where Σ = sig(T (cid:18)1 ).Remark 98. It is worth mentioning that the TBox T (cid:18)DL-Lite1 constructed above can be used to show that finite model reasoning inNhorn is non-tractable (in contrast to the results of [45] showing that, in other logics of the DL-Lite family, finite model1 for a propositional formula ϕ1—i.e., assume that the modal(cid:5) Dom is satisfiable in a finite modelNhorn TBox is NP-hard.reasoning is tractable). Indeed, consider the DL-Liteoperator (cid:3) does not occur in ϕ1. Then ϕ1 is satisfiable if, and only if, the concept Aϕ1Nof T (cid:18)horn concept is satisfiable in finite model of a DL-Lite1 . Thus, the problem whether a DL-Litehorn TBox T (cid:18)NA.5. Proofs of results from Section 8Here we prove Theorems 81 and 82.Theorem 81. Let T and T (cid:18)to Σ in DL-Liteube TBoxes in DL-Litebool. Then T Σ -query entails T (cid:18)Nbool and Σ a signature. And let T (cid:18)Σ be a uniform query interpolant of T (cid:18)if, and only if, T |(cid:15) C1 (cid:8) C2, for every (C1 (cid:8) C2) ∈ T (cid:18)Σ .with respectProof. Suppose that T Σ -query entails T (cid:18)Σ . Let I be a model of T such that I (cid:11)|(cid:15) (cid:21). Let Q bethe set of numerical parameters in T ∪ T (cid:18) ∪ {(cid:21)} and Ξ the set of Σ Q -types realised in I. Then Ξ is T -precisely realisable.Hence, by Theorem 21, Ξ is T (cid:18)precisely realising Ξ . Then I(cid:18) (cid:11)|(cid:15) (cid:21) because Iand I(cid:18)realise the same Σ Q -types. It follows that T (cid:18) (cid:11)|(cid:15) (cid:21), and so (cid:21) /∈ T (cid:18)and T (cid:11)|(cid:15) (cid:21), for some (cid:21) ∈ T (cid:18)-precisely realisable. Let I(cid:18)be a model of T (cid:18)Σ , which is a contradiction.. By Theorem 21, there exists a set Ξ of Σ Q T ∪T (cid:18) -types whichConversely, suppose that T does not Σ -query entail T (cid:18)-realisable. Letis precisely T -realisable but not precisely T (cid:18)(cid:9)D =where ∀U.CT (cid:11)|(cid:15) (cid:21). (cid:2)∃U.(cid:3)t∈Ξ(cid:3)C∈t(cid:18) = ¬∃U.¬C(cid:18)(cid:11)(cid:9)C(cid:5)∀U.(cid:11)C,$t∈Ξ (cid:3)C∈t. Then T (cid:11)|(cid:15) D (cid:8) ⊥ but T (cid:18) |(cid:15) D (cid:8) ⊥. It follows that T (cid:18)Σ|(cid:15) D (cid:8) ⊥. So there exists (cid:21) ∈ T (cid:18)Σ such that1140R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–1141Theorem 82. For every TBox T in DL-Literespect to Σ in DL-Liteubool.Nbool and every signature Σ , one can construct a uniform query interpolant TΣ of T withProof. Let T be a TBox in DL-Litecontaining all concept inclusions of the formconcept inclusions of the form(cid:3)Nbool and Σ a signature. Let m be the number of role names in T . Define TΣ to be the setC∈t C (cid:8) ⊥, where t is a Σ Q T -type which is not T -realisable, as well as all(cid:9)$(cid:11)C∈t C (cid:8)(cid:3)Ξ ∈Ω(cid:3)t(cid:18)∈Ξ∃U.C,(cid:3)C∈t(cid:18)where t is a T -realisable Σ Q T -type and Ω is the set of all sets Ξ of Σ Q T -types with |Ξ | (cid:3) 2m + 1 such that {t} ∪ Ξ isprecisely T -realisable. It follows that TΣ can be constructed in exponential time in the size of T . It remains to show thatTΣ is a uniform query interpolant. Clearly, T |(cid:15) (cid:21), for all (cid:21) ∈ TΣ . For the converse direction, it is sufficient to show thateach precisely TΣ -realisable set of Σ Q T -types is precisely T -realisable. Let Ξ0 be such a set. By the complexity analysisNbool in Section 6.2, for each t ∈ Ξ0 there exists Ξt ⊆ Ξ0 such that {t} ∪ Ξt is T -preciselyfor Σ -query entailment for DL-Literealisable. Take the disjoint union of models of T realising {t} ∪ Ξt , for t ∈ Ξ0. It is readily seen that this is a model of Tprecisely realising Ξ0. (cid:2)References[1] B. Cuenca Grau, I. Horrocks, Y. Kazakov, U. Sattler, Modular reuse of ontologies: Theory and practice, J. Artificial Intelligence Research 31 (2008)273–318.[2] F. Baader, D. Calvanese, D. McGuinness, D. Nardi, P.F. Patel-Schneider (Eds.), The Description Logic Handbook: Theory, Implementation and Applications,Cambridge University Press, 2003.[3] N. Noy, M. Musen, Promptdiff: A fixed-point algorithm for comparing ontology versions, in: Proc. of the 18th Nat. Conf. on Artificial Intelligence (AAAI2002), 2002, pp. 744–750.[4] B. Cuenca Grau, I. Horrocks, Y. Kazakov, U. Sattler, A logical framework for modularity of ontologies, in: Proc. of the 20th Int. Joint Conf. on ArtificialIntelligence (IJCAI 2007), 2007, pp. 298–303.[5] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, DL-Lite: Tractable description logics for ontologies, in: Proc. of the 20th Nat. Conf. onArtificial Intelligence (AAAI 2005), 2005, pp. 602–607.[6] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, Data complexity of query answering in description logics, in: Proc. of the 10th Int.Conf. on the Principles of Knowledge Representation and Reasoning (KR 2006), 2006, pp. 260–270.[7] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, Tractable reasoning and efficient query answering in description logics: The DL-Litefamily, J. Automated Reasoning 39 (3) (2007) 385–429.[8] A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, R. Rosati, Linking data to ontologies, J. Data Semantics X (2008) 133–173.[9] A. Artale, D. Calvanese, R. Kontchakov, V. Ryzhikov, M. Zakharyaschev, Reasoning over extended ER models, in: Proc. of the 26th Int. Conf. on ConceptualModeling (ER 2007), in: Lecture Notes in Computer Science, vol. 4801, Springer, 2007, pp. 277–292.[10] A. Artale, D. Calvanese, R. Kontchakov, M. Zakharyaschev, DL-Lite in the light of first-order logic, in: Proc. of the 22nd Nat. Conf. on Artificial Intelligence(AAAI 2007), 2007, pp. 361–366.[11] A. Artale, D. Calvanese, R. Kontchakov, M. Zakharyaschev, The DL-Lite family and relations, J. Artificial Intelligence Research 36 (2009) 1–69.[12] H. Stuckenschmidt, C. Parent, S. Spaccapietra (Eds.), Modular Ontologies: Concepts, Theories and Techniques for Knowledge Modularization, LectureNotes in Computer Science, vol. 5445, Springer, 2009.[13] P. Haase, V. Honavar, O. Kutz, Y. Sure, A. Tamilin (Eds.), Proc. of the 1st Int. Workshop on Modular Ontologies, WoMO’06, co-located with the Interna-tional Semantic Web Conference (ISWC’06), Athens, Georgia, USA, November 5, 2006, CEUR Workshop Proceedings, vol. 232, CEUR-WS.org, 2007.[14] B. Cuenca Grau, V. Honavar, A. Schlicht, F. Wolter (Eds.), Proc. of the 2nd Int. Workshop on Modular Ontologies (WoMO 2007), Whistler, Canada,October 28, 2007, CEUR Workshop Proceedings, vol. 315, CEUR-WS.org, 2008.[15] N.F. Noy, M.A. Musen, Specifying ontology views by traversal, in: S.A. McIlraith, D. Plexousakis, F. van Harmelen (Eds.), Proc. of the 3rd Int. SemanticWeb Conf., ISWC 2004, in: Lecture Notes in Computer Science, vol. 3298, Springer, 2004, pp. 713–725.[16] J. Seidenberg, A. Rector, Web ontology segmentation: Analysis, classification and use, in: L. Carr, D.D. Roure, A. Iyengar, C.A. Goble, M. Dahlin (Eds.),Proc. of the 15th Int. Conf. on World Wide Web (WWW 2006), ACM Press, New York, NY, USA, 2006, pp. 13–22.[17] B. Cuenca Grau, B. Parsia, E. Sirin, A. Kalyanpur, Modularity and web ontologies, in: P. Doherty, J. Mylopoulos, C.A. Welty (Eds.), Proc. of the 10th Int.Conf. on the Principles of Knowledge Representation and Reasoning (KR 2006), AAAI Press, 2006, pp. 198–209.[18] B. Konev, C. Lutz, D. Walther, F. Wolter, Semantic modularity and module extraction in description logics, in: M. Ghallab, C.D. Spyropoulos, N. Fakotakis,N. Avouris (Eds.), Proc. of the 18th Europ. Conf. on Artificial Intelligence (ECAI08), in: Frontiers in Artificial Intelligence and Applications, vol. 178, IOSPress, 2008, pp. 55–59.[19] J. Lang, P. Liberatore, P. Marquis, Propositional independence: Formula-variable independence and forgetting, J. Artificial Intelligence Research 18 (2003)391–443.[20] F. Lin, R. Reiter, Forget it!, in: Proc. of the AAAI Fall Symposium on Relevance, 1994, pp. 154–159.[21] T. Eiter, K. Wang, Semantic forgetting in answer set programming, Artificial Intelligence 172 (3) (2008) 1644–1672.[22] A. Pitts, On an interpretation of second-order quantification in first-order intuitionistic propositional logic, J. Symbolic Logic 57 (1) (1992) 33–52.[23] A. Visser, Uniform interpolation and layered bisimulation, in: P. Hájek (Ed.), Gödel’96, in: Lecture Notes in Logic, vol. 6, Springer, 1996, pp. 139–164.[24] S. Ghilardi, C. Lutz, F. Wolter, Did I damage my ontology? A case for conservative extensions in description logic, in: Proc. of the 10th Int. Conf. on thePrinciples of Knowledge Representation and Reasoning (KR 2006), 2006, pp. 187–197.[25] B. Konev, C. Lutz, D. Walther, F. Wolter, Formal properties of modularisation, in: Modular Ontologies: Concepts, Theories and Techniques for KnowledgeModularization, Springer, 2009, pp. 25–66.[26] B. Konev, D. Walther, F. Wolter, Forgetting and uniform interpolation in large-scale description logic terminologies, in: Proc. of the 21st Int. Joint Conf.on Artificial Intelligence (IJCAI 2009), 2009, pp. 830–835.[27] Z. Wang, K. Wang, R.W. Topor, J.Z. Pan, Forgetting concepts in DL-Lite, in: S. Bechhofer, M. Hauswirth, J. Hoffmann, M. Koubarakis (Eds.), Proc. of the5th Europ. Semantic Web Conf., ESWC 2008, in: Lecture Notes in Computer Science, vol. 5021, Springer, 2008, pp. 245–257.[28] L. Pulina, A. Tacchella, A self-adaptive multi-engine solver for quantified Boolean formulas, Constraints 14 (1) (2009) 80–116.R. Kontchakov et al. / Artificial Intelligence 174 (2010) 1093–11411141[29] R. Kontchakov, F. Wolter, M. Zakharyaschev, Can you tell the difference between DL-Lite ontologies?, in: Proc. of the 11th Int. Conf. on the Principlesof Knowledge Representation and Reasoning (KR 2008), 2008, pp. 285–295.[30] R. Kontchakov, L. Pulina, U. Sattler, T. Schneider, P. Selmer, F. Wolter, M. Zakharyaschev, Minimal module extraction from DL-Lite ontologies using QBFsolvers, in: Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI 2009), 2009, pp. 836–840.[31] A. Acciarri, D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, M. Palmieri, R. Rosati, QuOnto: Querying ontologies, in: Proc. of the 20th Nat. Conf.on Artificial Intelligence (AAAI 2005), 2005, pp. 1670–1671.[32] A. Poggi, M. Rodriguez, M. Ruzzi, Ontology-based database access with DIG-Mastro and the OBDA Plugin for Protégé, in: K. Clark, P.F. Patel-Schneider(Eds.), Proc. of the 4th Int. Workshop on OWL: Experiences and Directions (OWLED 2008 DC), 2008.[33] C. Lutz, D. Walther, F. Wolter, Conservative extensions in expressive description logics, in: Proc. of the 20th Int. Joint Conf. on Artificial Intelligence(IJCAI 2007), 2007, pp. 453–458.[34] C. Lutz, F. Wolter, Mathematical logic for life science ontologies, in: H. Ono, M. Kanazawa, R.J.G.B. de Queiroz (Eds.), Logic, Language, Information andComputation, 16th Int. Workshop (WoLLIC 2009), in: Lecture Notes in Computer Science, vol. 5514, Springer, 2009, pp. 37–47.[35] R. Diaconescu, J. Goguen, P. Stefaneas, Logical support for modularisation, in: G. Huet, G. Plotkin (Eds.), Logical Environments, Cambridge UniversityPress, New York, 1993, pp. 83–130.[36] P. Mosses (Ed.), CASL Reference Manual: The Complete Documentation of the Common Algebraic Specification Language, Lecture Notes in ComputerScience, vol. 2960, Springer, 2004.[37] P. Byers, D.H. Pitt, Conservative extensions: A cautionary note, Bulletin of the EATCS 41 (1990) 196–201.[38] T. Maibaum, Conservative extensions, interpretations between theories and all that!, in: M. Bidoit, M. Dauchet (Eds.), Proc. of the 7th Int. Joint Conf.CAAP/FASE on Theory and Practice of Software Development (TAPSOFT ’97), in: Lecture Notes in Computer Science, vol. 1214, Springer, 1997, pp. 40–66.[39] G. Antoniou, A. Kehagias, A note on the refinement of ontologies, Int. J. Intelligent Systems 15 (7) (2000) 623–632.[40] T. Eiter, M. Fink, S. Woltran, Semantical characterizations and complexity of equivalences in answer set programming, ACM Trans. Comput. Log. 8 (3).[41] M. Fink, Equivalences in answer-set programming by countermodels in the logic of here-and-there, in: M.G. de la Banda, E. Pontelli (Eds.), Proc. of the24th Int. Conf. on Logic Programming (ICLP 2008), in: Lecture Notes in Computer Science, vol. 5366, Springer, 2008, pp. 99–113.[42] D. Pearce, A. Valverde, Synonymous theories in answer set programming and equilibrium logic, in: Proc. of the 16th European Conf. on ArtificialIntelligence (ECAI 2004), 2004, pp. 388–392.[43] V. Lifschitz, D. Pearce, A. Valverde, A characterization of strong equivalence for logic programs with variables, in: Proc. of the 9th Int. Conf. on LogicProgramming and Nonmonotonic Reasoning (LPNMR), 2007, pp. 188–200.[44] C. Lutz, F. Wolter, Deciding inseparability and conservative extensions in the description logic EL, J. Symbolic Computation 45 (2) (2010) 194–228.[45] R. Rosati, Finite model reasoning in DL-Lite, in: S. Bechhofer, M. Hauswirth, J. Hoffmann, M. Koubarakis (Eds.), Proc. of the 5th Europ. Semantic WebConf. (ESWC 2008), in: Lecture Notes in Computer Science, vol. 5021, Springer, 2008, pp. 215–229.[46] C. Chang, H. Keisler, Model Theory, Elsevier, 1990.[47] C. Areces, B. ten Cate, Hybrid logics, in: P. Blackburn, J. van Benthem, F. Wolter (Eds.), Handbook of Modal Logic, Elsevier, 2006, pp. 821–868.[48] C. Papadimitriou, Computational Complexity, Addison–Wesley, 1994.[49] D. Kozen, Theory of Computation, Springer, 2006.[50] H. Kleine Büning, T. Lettman, Propositional Logic: Deduction and Algorithms, Cambridge University Press, 1999.[51] C. Lutz, F. Wolter, Conservative extensions in the lightweight description logic EL, in: F. Pfenning (Ed.), Proc. of the 21st Conf. on Automated Deduction(CADE-21), in: Lecture Notes in Computer Science, vol. 4603, Springer, 2007, pp. 84–99.[52] B. Konev, D. Walther, F. Wolter, The logical difference problem for description logic terminologies, in: Proc. of the Int. Joint Conf. on AutomatedReasoning (IJCAR-08), in: LNAI, Springer, 2008, pp. 259–274.[53] S. Feferman, R.L. Vaught, The first-order properties of algebraic systems, Fundamenta Mathematicae 47 (1959) 57–103.[54] V. Kuncak, H.H. Nguyen, M.C. Rinard, Deciding Boolean algebra with Presburger arithmetic, J. Automated Reasoning 36 (3) (2006) 213–239.[55] S. Ghilardi, C. Lutz, F. Wolter, M. Zakharyaschev, Conservative extensions in modal logics, in: G. Governatori, I. Hodkinson, Y. Venema (Eds.), Advancesin Modal Logics, vol. 6, College Publications, 2006, pp. 187–207.[56] H. Liu, C. Lutz, M. Miliˇci ´c, F. Wolter, Updating description logic ABoxes, in: Proc. of the 10th Int. Conf. on the Principles of Knowledge Representationand Reasoning (KR 2006), 2006, pp. 46–56.[57] A. Remshagen, K. Truemper, The complexity of futile questioning, in: H.R. Arabnia, P.L. Zhou (Eds.), Proc. of the Int. Conf. on Foundations of ComputerScience (FCS 2007), CSREA Press, 2007, pp. 132–138.[58] M. Benedetti, sKizzo: A suite to evaluate and certify QBFs, in: R. Nieuwenhuis (Ed.), Proc. of the 20th Int. Conf. on Automated Deduction (CADE-20),in: Lecture Notes in Computer Science, vol. 3632, Springer, 2005, pp. 369–376.[59] H. Samulowitz, F. Bacchus, Binary clause reasoning in QBF, in: A. Biere, C.P. Gomes (Eds.), Proc. of the 9th Int. Conf. on Theory and Applications ofSatisfiability Testing (SAT 2006), in: Lecture Notes in Computer Science, vol. 4121, Springer, 2006, pp. 353–367.[60] L. Zhang, S. Malik, Towards a symmetric treatment of satisfaction and conflicts in quantified Boolean formula evaluation, in: P.V. Hentenryck (Ed.),Proc. of the 8th Int. Conf. on Principles and Practice of Constraint Programming (CP 2002), in: Lecture Notes in Computer Science, vol. 2470, Springer,2002, pp. 200–215.[61] L. Zhang, S. Malik, Conflict driven learning in a quantified Boolean satisfiability solver, in: L.T. Pileggi, A. Kuehlmann (Eds.), Proc. of the IEEE/ACM Int.Conf. on Computer-aided Design (ICCAD), ACM, 2002, pp. 442–449.[62] E. Giunchiglia, M. Narizzano, A. Tacchella, Clause-term resolution and learning in quantified Boolean logic satisfiability, J. Artificial Intelligence Re-search 26 (2006) 371–416.[63] F. Lonsing, A. Biere, DepQBF: A dependency-aware QBF solver, J. Satisfiability, Boolean Modeling and Computation (2010), in press.[64] C. Peschiera, L. Pulina, A. Tacchella, U. Bubeck, O. Kullmann, I. Lynce, The seventh QBF solvers evaluation (QBFEVAL’10), in: O. Strichman, S. Szeider(Eds.), Proc. of the 13th Int. Conf. on Theory and Applications of Satisfiability Testing (SAT’10), in: Lecture Notes in Computer Science, vol. 6175,Springer, 2010, pp. 237–250, see also http://www.qbflib.org/index_eval.php.