Artificial Intelligence 174 (2010) 570–584Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintGeneralizing constraint satisfaction on trees: Hybrid tractability andvariable eliminationMartin C. Cooper a, Peter G. Jeavons b,∗, András Z. Salamon b,ca IRIT, University of Toulouse III, 31062 Toulouse, Franceb Computing Laboratory, University of Oxford, Oxford, OX1 3QD, UKc Oxford-Man Institute of Quantitative Finance, 9 Alfred Street, Oxford, OX1 4EH, UKa r t i c l ei n f oa b s t r a c tArticle history:Received 17 August 2009Received in revised form 13 February 2010Accepted 24 March 2010Available online 27 March 2010Keywords:Constraint satisfactionTractabilityComputational complexityArc consistencyVariable orderingVariable eliminationis a central generic problem in artificialThe Constraint Satisfaction Problem (CSP)intelligence. Considerable progress has been made in identifying properties which ensuretractability in such problems, such as the property of being tree-structured. In this paperwe introduce the broken-triangle property, which allows us to define a novel tractableclass for this problem which significantly generalizes the class of problems with treestructure. We show that the broken-triangle property is conservative (i.e., it is preservedunder domain reduction and hence under arc consistency operations) and that there is apolynomial-time algorithm to determine an ordering of the variables for which the broken-triangle property holds (or to determine that no such ordering exists). We also presenta non-conservative extension of the broken-triangle property which is also sufficient toensure tractability and can also be detected in polynomial time.We show that both the broken-triangle property and its extension can be used to eliminatevariables, and that both of these properties provide the basis for preprocessing proceduresthat yield unique closures orthogonal to value elimination by enforcement of consistency.Finally, we also discuss the possibility of using the broken-triangle property in variable-ordering heuristics.© 2010 Elsevier B.V. All rights reserved.1. IntroductionThe Constraint Satisfaction Problem (CSP) is a central generic problem in artificial intelligence where each instanceconsists of a collection of variables which must be assigned values subject to specified constraints. Each CSP instance hasan underlying undirected graph, known as its constraint network, whose nodes are the variables of the instance, and whoseedges connect precisely those pairs of variables which are related by some specified constraint. Such a graph is sometimescalled the structure of the instance.There is a well-known efficient algorithm for solving any CSP instance whose underlying constraint network is a tree[1,2]. If establishing arc consistency leads to a domain wipe-out, then no solution exists; otherwise a solution exists and canbe found by a backtrack-free search if the variables are ordered from any designated root to the leaves.However, having tree structure is a very restrictive property. It is therefore worthwhile exploring more general problemclasses, to identify more widely-applicable properties which still allow efficient solution algorithms. Any subclass of thegeneral CSP which can be solved in polynomial time, and also can be identified in polynomial time, is called a tractablesubclass.* Corresponding author.E-mail addresses: cooper@irit.fr (M.C. Cooper), Peter.Jeavons@comlab.ox.ac.uk (P.G. Jeavons), Andras.Salamon@comlab.ox.ac.uk (A.Z. Salamon).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.03.002M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584571There has been a considerable research effort in identifying tractable subclasses of the CSP over the past two decades.Most of this work has focused on one of two general approaches: either identifying forms of constraint which are sufficientlyrestrictive to ensure tractability no matter how they are combined [3,4], or else identifying structural properties of constraintnetworks which ensure tractability no matter what forms of constraint are imposed [2,5].The first approach has had considerable success in characterizing precisely which forms of constraint ensure tractabilityno matter how they are combined. A set of constraint types with this property is called a tractable constraint language. Ingeneral it has been shown that any tractable constraint language must have certain kinds of algebraic properties knownas polymorphisms [6]. A complete characterization of all possible tractable constraint languages has been established inthe following cases: conservative constraint languages (i.e., constraint languages containing all unary constraints) [7], andconstraint languages over a 2-element domain [8] or a 3-element domain [9].The second approach has also had considerable success in characterizing precisely which structures of constraint net-works ensure tractability no matter what constraints are imposed. For the class of problems where the arity of theconstraints is bounded above by some fixed constant (such as binary constraint problems) it has been shown that (subject tocertain technical assumptions) the only class of structures which ensure tractability are structures of bounded tree-width [10–12]. This result significantly extends the class of tree-structured CSPs while retaining tractability.In practice, constraint satisfaction problems usually do not possess a sufficiently restricted structure or use a sufficientlyrestricted constraint language to fall into any of these tractable classes. They may still have properties which ensure theycan be solved efficiently, but these properties concern both the structure of the constraint network and the form of theconstraints. Such properties have sometimes been called hybrid reasons for tractability [13–16], and they are less widely-studied and much less well-understood than the language properties and structural properties described above.A classical approach to tractability of CSPs is to identify conditions on the class of CSP instances that can be used toconstruct an ordering of variables which allows the instance to be solved efficiently. Freuder introduced a condition thatallows a variable ordering to be found in polynomial time, such that this variable ordering provides a backtrack-free searchprocedure [1]. The condition amounts to requiring that a level of consistency has been enforced that is at least as great as ameasure he called the width of the constraint graph. More generally, the amount of backtracking can be bounded in termsof the relationship between the level of consistency and the width of the constraint graph [17]. We note that Freuder’snotion of width is equivalent to the notion of tree-width which is now widely used in graph theory [18].The basic property described in this paper, which we call the Broken-Triangle Property (BTP), is a polynomial-time de-tectable property which defines a novel hybrid tractable class of binary CSP instances. The BTP can be viewed as forbiddingthe occurrence of certain subproblems of a fixed size within a CSP instance. A number of other properties of subproblemsof bounded size that guarantee tractability have previously been identified in the literature [19,20], but the BTP is unusualin that it also incorporates variable ordering information.The class of CSP instances that have the BTP with respect to some ordering is tractable: for all such instances thereis a polynomial-time procedure to determine a variable ordering which guarantees backtrack-free search. Our class is notcontained in the classes considered by Freuder, as we do not require a fixed relationship between tree-width and consistency[1,17]. We show that all tree-structured CSP instances satisfy the BTP, as well as many other instances that are not tree-structured (including some with unbounded tree-width).We also show that the BTP, and certain generalizations, can be used to define a variable-elimination strategy which canbe applied to any binary CSP. Even when no variables can be eliminated by this strategy, we show that it can still providea basis for a new form of variable-ordering heuristic. For example, if the BTP is satisfied on a subset S of the variables,then these variables should be placed at the end of the variable ordering. This guarantees that a search algorithm whichmaintains arc consistency during search will not backtrack on the variables in S.The paper is structured as follows. Sections 2 and 3 introduce the broken-triangle property and prove the tractabilityof binary CSP instances satisfying the BTP even in the case when the variable ordering is unknown a priori. Section 4shows that the BTP defines a tractable class that properly includes several other known tractable classes. Section 5 gives analternative characterization of instances which have the BTP, while Section 6 defines a non-conservative generalization ofthe BTP. Variable elimination by means of the BTP and its extension are discussed in Sections 7 and 8. Finally, in Section 9we discuss the possible use of the BTP in variable-ordering heuristics and prove the intractability of finding a maximumsubset of the variables on which a CSP instance has the BTP.2. The broken-triangle propertyIn this paper we focus on binary constraint satisfaction problems. A binary relation over domains D i and D j is a subsetof D i × D j . For a binary relation R, the reverse relation rev(R) is defined as {(v, u) | (u, v) ∈ R}.A binary CSP instance consists of a set of variables (where each variable is denoted by a number i ∈ {1, . . . , n}); for eachvariable i, a domain D i containing possible values for variable i; and a set of constraints. Each constraint is of the form(cid:4)(i, j), R(cid:5), where i and j are variables, the pair (i, j) is called the scope of the constraint, and R is a relation such thatR ⊆ D i × D j , specifying the allowed combinations of values for the variables in the scope.To simplify notation we introduce the notion of a canonical constraint relation which combines all of the specifiedS, where S is a set of relations,information about a pair of variables i, j. In the following definition, we use the notationto denote the intersection of all the relations in S.(cid:2)572M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584Fig. 1. The broken-triangle property on variables i, j, k.Definition 2.1. Suppose i and j are variables of a CSP instance. Denote by U i j the set of constraint relations specified forthe (ordered) pair of variables (i, j). The canonical constraint relation between variables i and j will be denoted R i j and isdefined as(cid:3)(cid:4)(cid:5)R i j =U i j ∪rev(R)(cid:6)(cid:6) R ∈ U ji(cid:7)(cid:8).The canonical constraint relation R i j contains precisely the pairs of values that are allowed for the variables i and j byall the constraints on i and j. Note that R i j = rev(R ji). If there are no specified constraints on the pair of variables i and j,then all pairs of values are allowed, so R i j is defined to be the complete relation D i × D j . (This can be viewed as definingthe value of an empty intersection in Definition 2.1 to be D i × D j .)Throughout this paper, whenever we consider a binary CSP instance, we will use the notation R i j to refer to the canonicalconstraint relation between variables i and j.Definition 2.2. A binary CSP instance satisfies the broken-triangle property (BTP) with respect to the variable ordering <,if, for all triples of variables i, j, k such that i < j < k, if (u, v) ∈ R i j , (u, a) ∈ R ik and (v, b) ∈ R jk, then either (u, b) ∈ R ik or(v, a) ∈ R jk.The broken-triangle property can be represented in diagrammatic form by the implication shown in Fig. 1. In the figure,each vertex represents an assignment of a value to a variable, and for each variable an oval is drawn containing all itspossible values. Each line represents a consistent assignment of values for a pair of variables. A line joins element u ∈ D iand element v ∈ D j if (u, v) ∈ R i j . The BTP on i, j, k simply says that for any “broken-triangle” a − u − v − b, as illustratedin Fig. 1, there is always a true triangle u − v − c (where c is either equal to a or b).It is important to note that the BTP must be satisfied for all triples i < j < k, even if the description of the instance doesnot specify a constraint between all pairs of these variables. As noted above, if there is no specified constraint between iand j, then R i j allows all pairs of values.We remark that the definition of the BTP is similar to the standard definition of directional path consistency [2], but a littlestronger. To be directional path consistent requires that for all triples of variables i, j, k such that i < j < k, if (u, v) ∈ R i j ,then there exists some c ∈ Dk such that (u, c) ∈ R ik and (v, c) ∈ R jk (but the implication shown in Fig. 1 may not be satisfied,because c is not necessarily equal to a or b).We also remark that the definition of the BTP is similar to the definition of hyper-3-consistency given in [21], but a littleweaker. To be hyper-3-consistent requires that for all triples of variables i, j, k, if (u, v) ∈ R i j , (u, a) ∈ R ik and (v, b) ∈ R jk,then both (u, b) ∈ R ik and (v, a) ∈ R jk.A simple reformulation of Definition 2.2 shows that the BTP is equivalent to forbidding the existence of subproblems ofa certain form.M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584573Lemma 2.3. A binary CSP instance satisfies the broken-triangle property with respect to the variable ordering <, if, and only if, itdoes not contain an ordered triple of variables i, j, k with i < j < k, and values a, b ∈ Dk, u ∈ D i and v ∈ D j , such that (u, v) ∈ R i, j ,(u, a) ∈ R ik, (v, b) ∈ R jk, (u, b) /∈ R ik and (v, a) /∈ R jk.For an element a ∈ D i , we write R i j(a) to represent {b ∈ D j: (a, b) ∈ R i j}, the image of a in the relation R i j . The nextresult shows that the BTP is equivalent to having certain inclusion relations between certain image sets.Lemma 2.4. A binary CSP instance satisfies the broken-triangle property with respect to the variable ordering < if, and only if, for alltriples of variables i < j < k, and for all (u, v) ∈ R i j ,(cid:8)R ik(u) ⊆ R jk(v)(cid:8)R jk(v) ⊆ R ik(u)(1)∨(cid:4)(cid:4).Proof. The condition that either R ik(u) ⊆ R jk(v) or R jk(v) ⊆ R ik(u) is equivalent to stating that there do not exist elementsa of R ik(u) and b of R jk(v) such that a /∈ R jk(v) and b /∈ R ik(u). By the definition of the image of an element in a relation,this in turn is equivalent to the statement that there do not exist a, b ∈ Dk such that (u, a) ∈ R ik, (v, b) ∈ R jk, (u, b) /∈ R ikand (v, a) /∈ R jk. Hence the result follows by Lemma 2.3. (cid:2)Definition 2.5. A class of CSP instances is called conservative if it is closed under domain restrictions (i.e., the addition ofarbitrary unary constraints). A property is called conservative if it defines a conservative class of instances.Lemma 2.6. The broken-triangle property with respect to any fixed variable ordering is conservative.Proof. Lemma 2.3 states that the broken-triangle property holds for a binary CSP instance if and only if it does not containcertain subproblems. Removing values from the domain of any variable in an instance cannot create new subproblems, andhence cannot cause the broken-triangle property to become false. (cid:2)This result implies that the broken-triangle property is invariant under domain reduction operations such as arc consis-tency: if a binary CSP instance satisfies the broken-triangle property, then so does its closure under arc consistency. Indeed,any pre-processing operation which only performs domain reductions, such as arc consistency, path-inverse consistency [22],or neighbourhood substitution [23,24], can be applied before looking for a variable ordering for which the broken-triangleproperty is satisfied; these reduction operations cannot destroy the broken-triangle property, but they can make it morelikely to hold.A set of CSP instances may satisfy the broken-triangle property due to the structure of the constraint graph, due to thelanguage of the constraint relations, or due to a combination of these.Example 2.7. Let I be a binary CSP instance whose constraint relations are all zero/one/all (ZOA) relations, as defined in [25].Such relations have the property that, for each pair of variables i, j, each u ∈ D i is compatible with either zero, one orall possible values for j. ZOA relations notably include all relations specified by 2SAT clauses. An important property ofinstances where all constraint relations are ZOA is that this remains true after establishing arc consistency and path con-is both arc consistent and path consistent. By arcsistency. Therefore we may assume without loss of generality that Iconsistency, and the definition of ZOA relations, R i j(u) is either a singleton or equal to D j , whenever i and j are distinctvariables and u ∈ D i . The BTP could then only be violated for u ∈ D i , v ∈ D j if R ik(u), R jk(v) were both singletons withR ik(u) (cid:9)= R jk(v). However, if this were the case, then (cid:4)u, v(cid:5) would have been deleted from R i j by path consistency. ThereforeI satisfies the BTP.Further examples of some broad classes of CSP instances which satisfy the BTP are discussed in Section 4 (see Theo-rem 4.8).3. Tractability of BTP instancesIn this section we show that if a CSP instance has the broken-triangle property with respect to some fixed variableordering, then finding a solution is tractable. Moreover, we show that the problem of finding a suitable ordering if it existsis also tractable.For a binary CSP instance with n variables, let d = max{|D1|, . . . , |Dn|} and let e be the number of constraints. Note thatan assignment of values (cid:4)u1, . . . , uk(cid:5) to the first k variables of a binary CSP instance is called consistent if ui ∈ D i whenever1 (cid:2) i (cid:2) k, and (ui, u j) ∈ R i j whenever 1 (cid:2) i < j (cid:2) k [26].Theorem 3.1. For any binary CSP instance which satisfies the BTP with respect to some known variable ordering <, it is possible to finda solution in O (d2e) time (or determine that no solution exists).574M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584Proof. By the discussion in Section 2, if an instance has the BTP with respect to <, then establishing arc consistencypreserves the BTP. Furthermore, it is known that arc consistency can be established in O (d2e) time [27]. If this results inan empty domain, then the instance has no solutions. Therefore, we assume in the following that the CSP instance is arcconsistent and has non-empty domains.We can assign some value u1 ∈ D1 to the first variable, since D1 is non-empty. To prove the result it is sufficient toshow, for all k = 2, . . . , n, that any consistent assignment (cid:4)u1, . . . , uk−1(cid:5) for the first k − 1 variables can be extended to aconsistent assignment (cid:4)u1, . . . , uk(cid:5) for the first k variables. The case k = 2 follows from arc consistency.By Lemma 2.4, if i < j < k then either R ik(ui) ⊆ R jk(u j) or R jk(u j) ⊆ R ik(ui). For any fixed k > 2, we can therefore applyLemma 2.4 to every pair of variables occurring before k in the ordering to establish that the set {R ik(ui) | i < k} is totallyordered by subset inclusion, and hence has a minimal element(cid:3)R i0k(ui0 ) =R ik(ui)i<k(2)for some i0 < k. Since the instance is arc consistent, R i0k(ui0 ) (cid:9)= ∅. By the definition of R ik(ui), it follows from Eq. (2) that(cid:4)u1, . . . , uk(cid:5) is a consistent assignment for the first k variables, for any choice of uk ∈ R i0k(ui0 ).The time taken to calculate the intersections in (2) is at most O (ed) overall, since each value in the domain must bechecked against each relevant constraint. (cid:2)Theorem 3.2. Given a binary CSP instance I , there is a polynomial-time algorithm to find a variable ordering <, such that I satisfiesthe broken-triangle property with respect to < (or to determine that no such ordering exists).Proof. Given a binary CSP instance I , we define an associated CSP instance P I that has a solution precisely when thereexists a suitable variable ordering for I .To construct P I , let O 1, . . . , O n be variables taking values in {1, . . . , n} representing positions in the ordering. We imposethe ternary constraintO k < max{O i, O j}(3)for all triples of variables i, j, k in I such that the broken-triangle property fails to hold for some u ∈ D i , v ∈ D j , anda, b ∈ Dk when the variables are ordered i < j < k. The instance P I then has a solution precisely if there is an orderingof the variables 1, . . . , n of I which satisfies the broken-triangle property. Note that if the solution obtained represents apartial order (for instance, if O i and O j are assigned the same value for some i (cid:9)= j), then it can be extended to a totalorder which still satisfies all the constraints by using a linear-time topological sort.For each triple of variables in I , the construction of the corresponding constraints in P I requires O (d4) steps to checkwhich constraints to add. There are O (n3) such triples, so constructing instance P I takes O (n3d4) steps, which is polynomialin the size of I .The constraints in P I are all of the form (3), and such constraints have the property that they are max-closed1 [28].Max-closed constraints are a tractable constraint language [28]: any CSP instance with max-closed constraints can be solvedby establishing generalized arc consistency [29] and then choosing the maximum element which remains in each variabledomain. Since the size of P I is polynomial in the size of I , it follows that the instance P I can be solved in time polynomialin the size of I . (cid:2)In Section 7 we describe an alternative, more efficient, approach to finding a suitable variable ordering, or determiningthat no such ordering exists (see Corollary 7.5).4. Related tractable classesIn this section we will show that the broken-triangle property generalizes several other known tractable classes, someof which have unbounded tree-width.Definition 4.1. A binary relation R i j on the sets D i and D j , where D j is totally ordered, is said to be right monotone if∀a ∈ D i , ∀b, c ∈ D j ,(a, b) ∈ R i j ∧ b < c ⇒ (a, c) ∈ R i j.A commonly-used right monotone constraint is the inequality constraint: “value of variable i (cid:2) value of variable j”. Thecomplete relation, which allows every combination of values, is also right monotone.1 To verify that a constraint is max-closed we need to show that if we take any 2 tuples which satisfy the constraint, and then compute the maximumof the 2 values in each co-ordinate position of these tuples, then we always obtain a tuple that satisfies the constraint [28]. To verify that this holds for all, we simply note that if p1 < max{q1, r1} and p2 < max{q2, r2} then max(p1, p2) < max{max(q1, q2), max(r1, r2)}.the constraints in P(cid:14)M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584575Definition 4.2. A binary CSP instance is renamable right monotone with respect to a variable ordering < if each set Dk, fork ∈ {2, . . . , n}, can be ordered (separately), such that R ik is right monotone for every i < k.Proposition 4.3. If a binary CSP instance is renamable right monotone with respect to a variable ordering <, then it satisfies thebroken-triangle property with respect to <.Proof. Suppose the CSP instance is renamable right monotone with respect to variable ordering <, and let k be any variable.Since the instance is renamable right monotone with respect to <, there is an ordering of Dk such that whenever i < k thenR ik is right monotone. Now suppose i < j < k are variables in this ordering. Then each of R ik and R jk is right monotone.Now suppose that (u, v) ∈ R i j , (u, a) ∈ R ik and (v, b) ∈ R jk. If a < b, then (u, b) ∈ R ik (since R ik is right monotone); if a > b,then (v, a) ∈ R jk (since R jk is right monotone). Hence, by Definition 2.2, the broken-triangle property is satisfied for thetriple i, j, k. Since the choice of k was arbitrary, it follows that the instance satisfies the BTP. (cid:2)Using Lemma 2.4 we can obtain another simple sufficient condition for the broken-triangle property to hold.Lemma 4.4. A binary CSP instance satisfies the broken-triangle property with respect to a variable ordering < if, for all triples ofvariables i < j < k, either R ik or R jk is a complete relation.Proof. If R ik is a complete relation, then R ik(u) = Dk, while if R jk is a complete relation, then R jk(v) = Dk. In either case,by Lemma 2.4, the instance satisfies the BTP. (cid:2)Proposition 4.5. If a binary CSP instance has a tree structure, then it satisfies the broken-triangle property with respect to any variableordering in which each node occurs before its children.Proof. If we order the nodes of a tree from any designated root to the leaves, then each node is connected to at most onenode earlier in the ordering. Hence, if a CSP instance has a tree structure, then any variable ordering < of this kind has theproperty that, for each variable k, there is at most one variable i, with i < k, such that R ik is not a complete relation. Hence,by Lemma 4.4, the instance satisfies the BTP with respect to any such ordering. (cid:2)To obtain a further class of examples we note that with any CSP instance P (of arbitrary arity) we can associate a binaryCSP instance I P which is called the dual of P [30]: the instance I P has a variable for each constraint of P , and a binaryconstraint between each pair of variables associated with overlapping constraints of P . The binary constraints in I P aredefined to ensure that the variables in I P can only take values which agree on the corresponding shared variables of P(see [30] for details).Lemma 4.6. Let P be a CSP instance (of arbitrary arity) with constraint scopes E 1, E2, . . . , Em, where the constraints allow all combi-nations of values from some fixed domain D. The dual instance I P , with corresponding variables 1, 2, . . . , m, has the BTP with respectto some ordering < if, and only if, for all triples E i, E j, Ek with i < j < k we have(E i ∩ Ek ⊆ E j ∩ Ek) ∨ (E j ∩ Ek ⊆ E i ∩ Ek).(4)Moreover, if this condition holds, then the dual of any instance P(cid:14)with the same constraint scopes also has the BTP with respect to <.Proof. By Lemma 2.4, I P has the BTP with respect to < if and only if for all triples i < j < k, and for all (u, v) ∈ R i j ,(R ik(u) ⊆ R jk(v)) ∨ (R jk(v) ⊆ R ik(u)). But, by the definition of the dual [30], for any fixed pair u, v, the range R ik(u) isdetermined purely by the overlap of E i and Ek, and the range R jk(v) is determined purely by the overlap of E j and Ek.Hence, I P has the BTP with respect to < if and only if the given condition holds on E i ∩ Ek and E j ∩ Ek.Finally, we note that the dual of any other instance Pwith the same constraint scopes can be obtained from the dualof such an instance P , for an appropriate choice of D, by imposing restrictions on the domains. Hence, by Lemma 2.6, thedual of Pwill also have the BTP with respect to <. (cid:2)(cid:14)(cid:14)The edges of any tree can be ordered so that they satisfy the condition given in Lemma 4.6, so we obtain the followingcorollary of this result.Corollary 4.7. The dual of any tree-structured binary CSP instance has the BTP with respect to some ordering.Now let TREE be the constraint satisfaction problem consisting of all instances that have tree structure, RRM be theCSP consisting of all instances that are renamable right monotone with respect to some variable ordering, and DUAL-TREEbe the CSP consisting of all instances which are duals of instances with tree structure. Note that these three classes areincomparable, for example an instance consisting of a single equality constraint belongs to TREE and DUAL-TREE but not to576M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584Fig. 2. An instance in BTP that is not in RRM, TREE or DUAL-TREE.RRM. Moreover, both RRM and DUAL-TREE contain instances of arbitrary tree-width; for example, RRM contains instanceswhere the constraint structure is a grid of arbitrary size, and DUAL-TREE contains instances where the constraint structureis a clique of arbitrary size (such as the dual of any instance whose structure is a star). Finally, let BTP be the CSP consistingof all instances which have the broken-triangle property with respect to some variable ordering. We now show that theclass BTP properly includes the other 3 classes.Theorem 4.8. RRM (cid:2) BTP, TREE (cid:2) BTP, and DUAL-TREE (cid:2) BTP.Proof. The inclusions follow from Propositions 4.3, 4.5 and Corollary 4.7; the instance shown in Fig. 2 establishes the strictseparations. (cid:2)5. An alternative characterization of the BTPIn this section we consider the broad class of properties which are both conservative and preserved by taking sub-problems. We show that the broken-triangle property is the only such property which ensures that the following desirablebehaviour can be guaranteed simply by achieving a certain level of arc consistency:Definition 5.1. A CSP instance is universally backtrack-free with respect to an ordering < of its n variables if ∀k ∈ {2, . . . , n},any consistent assignment for the first k − 1 variables can be extended to a consistent assignment for the first k variables.Definition 5.2. Given a CSP instance I on variables 1, . . . , n, the induced subproblem I({i1, . . . , im}), where 1 (cid:2) i1 < i2 <· · · < im (cid:2) n, is the m-variable CSP instance with domains D i1 , . . . , D im and exactly those constraints of I whose scopes aresubsets of {i1, . . . , im}.Definition 5.3. A set Σ of CSP instances is inclusion-closed if ∀I ∈ Σ , all subproblems I(M) on subsets M of the variablesof I also belong to Σ .Definition 5.4. (See [2].) A binary CSP instance is directional arc consistent with respect to a variable ordering <, if for allpairs of variables i < j, for every a in D i , there exists some b ∈ D j such that (a, b) ∈ R i j .Given any binary CSP instance I , we can remove values from the domains of the variables to achieve directional arcconsistency, without changing the set of solutions [2]. The result of applying such an algorithm is unique, and is called thedirectional arc-consistency closure of I .Proposition 5.5. Let Σ be a conservative inclusion-closed set of binary CSP instances. The directional arc-consistency closure DAC(I)of every I ∈ Σ with respect to a variable ordering < is universally backtrack-free with respect to < if, and only if, ∀I ∈ Σ , DAC(I)satisfies the broken-triangle property with respect to <.Proof. The argument used in the proof of Theorem 3.1 shows that if any binary CSP instance satisfies the broken-triangleproperty then its directional arc-consistency closure is universally backtrack-free.To prove the converse, suppose that Σ is a conservative inclusion-closed set of CSP instances and consider any I ∈ Σ .Since Σ is conservative, DAC(I) also belongs to Σ , since it is obtained from I by a sequence of domain reductions. In thefollowing, we let D i denote the domain of variable i in DAC(I). Consider three variables i < j < k and four domain valuesu ∈ D i , v ∈ D j , a, b ∈ Dk such that (u, v) ∈ R i j , (u, a) ∈ R ik and (v, b) ∈ R jk. Denote by Ithe induced subproblem of DAC(I)on variables i, j, k and with reduced domain {a, b} for variable k. Establishing directional arc consistency in Imay reducethe domains of variables i and j, but cannot delete v from the domain of variable j (since it has a support, namely b,(cid:14)(cid:14)M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584577at k) nor can it delete u from the domain of variable i (since it has supports at variables j and k). If DAC(I) is universallybacktrack-free, then the consistent assignment (cid:4)u, v(cid:5) for the variables (cid:4)i, j(cid:5) can be extended to a consistent assignment for(cid:4)i, j, k(cid:5), which must be either (cid:4)u, v, a(cid:5) or (cid:4)u, v, b(cid:5). This corresponds exactly to the definition of the broken-triangle property,and so DAC(I) satisfies the BTP. (cid:2)(cid:14)6. Generalizing the BTPIn this section we show that a weaker form of the broken-triangle property also implies backtrack-free search. Thisleads to a strictly larger, but non-conservative, tractable class of CSP instances. Throughout this section, we assume that allvariable domains are totally ordered.Definition 6.1. A binary CSP instance is min-of-max extendable (MME) with respect to the variable ordering <, if for alltriples of variables i, j, k such that i < j < k, if (u, v) ∈ R i j , then (cid:4)u, v, c(cid:5) is a consistent assignment for (cid:4)i, j, k(cid:5), where(cid:4)c = minmax(cid:4)(cid:8)R ik(u)(cid:4)(cid:8)(cid:8), maxR jk(v).The symmetrically equivalent property max-of-min extendability is defined similarly, but with c = max(min(R ik(u)),min(R jk(v))).Lemma 6.2. A binary CSP instance satisfies the broken-triangle property with respect to a variable ordering < if, and only if, it ismin-of-max extendable with respect to < for all possible domain orderings.Proof. Suppose that a CSP instance satisfies the broken-triangle property with respect to <, and consider an arbitraryordering of each of the domains. To prove min-of-max extendability, it suffices to apply the broken-triangle property toa = max(R ik(u)) and b = max(R jk(v)). If a = b then clearly (cid:4)u, v, min(a, b)(cid:5) is a consistent assignment for (cid:4)i, j, k(cid:5). Otherwise,since a and b are maximal, (cid:4)u, v, max(a, b)(cid:5) is not a consistent assignment; hence by the BTP, (cid:4)u, v, min(a, b)(cid:5) is a consistentassignment.To prove the converse, suppose that a CSP instance is min-of-max extendable for all possible domain orderings. For anydistinct a, b ∈ Dk, consider an ordering of Dk for which a = max(Dk) and b = max(Dk − {a}). The broken-triangle propertythen follows from the definition of min-of-max extendability. (cid:2)Theorem 6.3. If a binary CSP instance is min-of-max extendable with respect to some known variable ordering < and some (possiblyunknown) domain orderings, and is also directional arc consistent with respect to <, then it is universally backtrack-free with respectto <, and hence can be solved in polynomial time.Proof. Suppose that (cid:4)u1, . . . , uk−1(cid:5) is a consistent assignment for the variables (cid:4)1, . . . , k − 1(cid:5). By directional arc consistency,∀i < k, R ik(ui) (cid:9)= ∅. This means that(cid:5)c = minmax(cid:4)(cid:8)R ik(ui): 1 (cid:2) i (cid:2) k − 1(cid:7)is well-defined. Let j ∈ {1, . . . , k − 1} be such that c = max(R jk(u j)). Let i be any variable in {1, . . . , k − 1} − { j}. Applyingthe definition of min-of-max extendability to variables i, j, k allows us to deduce that (ui, c) ∈ R ik. It follows that ∃uk ∈ Dk(namely uk = c) such that (cid:4)u1, . . . , uk(cid:5) is a consistent assignment for the variables (cid:4)1, . . . , k(cid:5). This establishes that theinstance is universally backtrack-free.Note that we used the ordering of domain Dk only to prove the existence of at least one consistent extension (cid:4)u1, . . . , uk(cid:5)of (cid:4)u1, . . . , uk−1(cid:5). A search algorithm can find some consistent value for uk, without any information about the domainorderings, simply by checking each possible value from Dk. Hence the instance can be solved in polynomial time, evenwhen the domain orderings are unknown. (cid:2)Theorem 6.4. The problem of finding a variable ordering for a binary CSP instance with ordered domains such that it is min-of-maxextendable with respect to that ordering (or determining that no such ordering exists) is solvable in polynomial time.Proof. The requirements for the ordering are a subset of the requirements for establishing the broken-triangle property.Hence the result can be proved exactly as in the proof of Theorem 3.2. (cid:2)We can use Theorem 6.4 in the following way: given a CSP instance with ordered domains, compute its arc consistencyclosure, and then test (in polynomial time) whether this reduced instance is min-of-max extendable for some ordering ofits variables. If we find such an ordering, then the instance can be solved in polynomial-time, by Theorem 6.3.However, this approach is not guaranteed to find all possible useful variable orderings achieving min-of-max extendabil-ity, because min-of-max extendability is not conservative, as the following example shows.578M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584Fig. 3. An example of a CSP instance which is directional arc consistent and min-of-max extendable, but which fails to be min-of-max extendable whenmade arc consistent.Example 6.5. Fig. 3 shows a binary CSP instance in which a dashed line between values p ∈ D i and q ∈ D j represents thefact that (cid:4)p, q(cid:5) /∈ R i j . All pairs of values not joined by a dashed line are consistent. This instance is directional arc consistentand min-of-max extendable with respect to the variable ordering 1 < 2 < 3 < 4 and the ordering a > b > c of domain D 4(and any orderings of the other domains). However, this instance does not satisfy the BTP (consider the “broken triangle”b − u − v − c).If we establish arc consistency, the value a is deleted from D4 since it has no support in D1. The resulting CSP instanceis arc consistent but no longer min-of-max extendable, since (cid:4)u, v(cid:5) ∈ R 23 but cannot be extended to a consistent assignmentfor variables 2, 3, 4.Since min-of-max extendability is not a conservative property, it can be the case that, for some variable orderings, thedirectional arc-consistency closure is min-of-max extendable but the full arc-consistency closure is not, as in Example 6.5.Finally, we show that min-of-max extendability is a strict generalization of a previously-identified hybrid tractable class.Definition 6.6. (See [31].) A CSP instance is row-convex (with respect to a fixed variable ordering and fixed domain order-ings) if for all pairs of variables i < j, ∀u ∈ D i , R i j(u) is the interval [a, b] for some a, b ∈ D j .It is known that a directional path-consistent row-convex binary CSP instance is universally backtrack-free and hencetractable [31]. (However, it should be noted that establishing directional path consistency may destroy row-convexity.) Ourinterest in this hybrid tractable class is simply to demonstrate that it is a special case of min-of-max extendability.Proposition 6.7. If a binary CSP instance is directional path-consistent and row-convex, then it is min-of-max extendable (and max-of-min extendable).Proof. Consider the triple of variables i < j < k and suppose that (u, v) ∈ R i j . By directional path consistency, ∃c ∈ Dksuch that (u, c) ∈ R ik and (v, c) ∈ R jk. By row-convexity, R ik(u) and R jk(v) are intervals in the ordered domain Dk. Theexistence of c means that these intervals overlap. Both end-points of this overlap provide extensions of (u, v) to a consistentassignment for the variables (cid:4)i, j, k(cid:5). One end-point is given by min(max(R ik(u)), max(R jk(v))) which ensures min-of-maxextendability. (The other ensures max-of-min extendability.) (cid:2)On the other hand, it is perfectly possible for a binary CSP instance to be min-of-max extendable without being row-convex, as shown by Example 6.5 (consider R34(v)).7. Variable elimination using the BTPClassical techniques for reducing the search space of a CSP are based on domain reduction via value elimination. In thissection we will show that the BTP can be used to define a novel strategy for variable elimination in binary CSPs. We willinvestigate the time complexity of applying this variable elimination strategy, and explore the interaction between variableand value eliminations.In contrast to bucket elimination, which requires space exponential in the tree-width of the constraint network [32],our scheme for variable elimination using the BTP can be applied in polynomial time even to classes of CSP instances withunbounded tree-width.M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584579Existing techniques for choosing good variable orderings have focused on variants of the smallest domain heuristic [33],probabilistic estimates of the most likely assignments [34], and dynamic variable orderings together with a local searchcriterion [35]. Our scheme could be used as part of input preprocessing, or even during search, together with the usualenforcement of arc or path consistency. Existing variable ordering heuristics can then be applied during search after somevariables have been eliminated.We first define a local broken-triangle property for a single variable k.Definition 7.1. A variable k in a binary CSP instance satisfies the local broken-triangle property (lBTP) if for all pairs ofdistinct variables i, j (cid:9)= k, ∀a, b ∈ Dk, (cid:4)u, v(cid:5) ∈ R i j , (cid:4)u, a(cid:5) ∈ R ik and (cid:4)v, b(cid:5) ∈ R jk implies that (cid:4)u, b(cid:5) ∈ R ik or (cid:4)v, a(cid:5) ∈ R jk.Let [n]−k denote the set {1, . . . , n} \ {k} = {1, . . . , k − 1, k + 1, . . . , n}.Proposition 7.2. Let I be an arc-consistent binary CSP instance on variables [n] such that variable k satisfies the lBTP, and let Iinduced subproblem of I on variables [n]−k. Then Iexactly the projection of the set of solutions of I onto the variables [n]−k.has a solution if and only if I has a solution. Indeed, the set of solutions of Ibe the(cid:14)is(cid:14)(cid:14)(cid:14)is a subproblem of I , we only need to prove that every solution of I(cid:14)Proof. Since Ican be extended to a solution of I . Let(cid:4)a1, . . . , ak−1, ak+1, . . . , an(cid:5) be a solution of I. By arc consistency, ∀i (cid:9)= k, R ik(ai) (cid:9)= ∅. Since k satisfies the lBTP, by the sameargument as in the proof of Lemma 2.4, any two elements of {R ik(ai) | i ∈ [n]−k} are ordered by subset inclusion, so this setis totally ordered by subset inclusion, and hence has a non-empty intersection. This implies that every solution of Ican beextended to a solution of I , which completes the proof. (cid:2)(cid:14)(cid:14)Proposition 7.2 tells us that the solvability of any CSP instance is invariant under the elimination of any variables thatsatisfy the lBTP.The following proposition gives a concrete example of the application of this form of variable elimination.Proposition 7.3. In a path consistent binary CSP instance, all variables k such that |Dk| = 2 satisfy the lBTP and hence can be elimi-nated.Proof. Consider a variable k such that |Dk| = 2. Suppose for a contradiction that for some i, j (cid:9)= k, we have (cid:4)u, v(cid:5) ∈ R i j ,(cid:4)u, a(cid:5) ∈ R ik, (cid:4)v, b(cid:5) ∈ R jk, (cid:4)u, b(cid:5) /∈ R ik and (cid:4)v, a(cid:5) /∈ R jk. Then a (cid:9)= b, and we can deduce that Dk = {a, b}. But then (cid:4)u, v(cid:5) ∈ R i jhas no support at variable k, which contradicts the assumption of path consistency. (cid:2)Theorem 7.4. The closure of a binary CSP instance under the elimination of all variables that satisfy the lBTP is unique and can befound in O (ned3) time.Proof. By Definition 7.1, if variable k satisfies the lBTP in a binary CSP instance I , then k satisfies the lBTP in any subproblemof I that includes k. Thus, if variables j and k both satisfy the lBTP, then variable j will still satisfy the lBTP after eliminationof variable k. It follows that the result of eliminating all variables that satisfy the lBTP is unique, since a variable eliminationcannot invalidate another variable elimination. However, as with value eliminations by arc consistency, variable eliminationscan provoke new variable eliminations; if variable i did not satisfy the lBTP before elimination of k, it may satisfy the lBTPafter the elimination of k.A variable k satisfies the lBTP and can be eliminated if, for all distinct i, j ∈ [n]−k, (u, v) ∈ R i j implies thatR ik(u) ⊆ R jk(v) ∨ R ik(u) ⊇ R jk(v).(5)If for some u ∈ D i and some v ∈ D j , Eq. (5) does not hold, then we say that {i, j} is an lBTP obstruction-pair for k. LetObk be the set of lBTP obstruction-pairs {i, j} for k. We can assume that the set R ik(u) (for each i ∈ [n]−k and each u ∈ D i )is stored in a direct access data structure, so that the test a ∈ R ik(u) is an O (1) operation. Furthermore, Eq. (5) triviallyholds if there is no constraint with scope {i, k} or no constraint with scope { j, k}. It follows that Obk can be determined bychecking whether Eq. (5) holds for each pair of constraints whose scopes contain k, and each possible choice of the valuesu and v, by checking each possible a ∈ Dk. This can be completed in O (e2k d3) time, where d is the maximum domain sizeand ek is the number of binary constraints whose scope contains k.Hence, the sets Obk (for all k ∈ [n]) can be calculated in O (ned3) time sinceIf any set Obk is empty, then variable k satisfies the lBTP and can be eliminated. When a variable k is eliminated, thesets Obi (i (cid:9)= k) must be updated by deleting all obstruction-pairs containing k. If any other Obi now becomes empty, thenvariable i can also be eliminated, and the same updating procedure must be applied again. Since each obstruction-pair(cid:9){i, j} is deleted at most once from each Obk, the total number of deletions is bounded above bynk=1 e2k(cid:2)k=1 nek = 2ne. Therefore, using appropriate indexing, the total time complexity to determine the variable eliminationclosure by lBTP is O (ned3 + ne) = O (ned3). (cid:2)k=1 nekd3 = 2ned3.(cid:9)nk=1 e2(cid:9)nk=1|Obk| (cid:2)k d3 (cid:2)(cid:9)n(cid:9)n580M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584Corollary 7.5. The problem of finding a variable ordering for which a binary CSP instance I satisfies the BTP (or determining that nosuch order exists) can be solved in O (ned3) time.Proof. To determine whether there exists a variable ordering for which I satisfies the BTP, we can simply test whether itsclosure under the elimination of all variables that satisfy the lBTP is empty. If so, then the reverse of the order in whichvariables were eliminated is a variable ordering for which I satisfies the BTP. Otherwise, no such ordering exists. (cid:2)Theorem 7.6. If the binary CSP instance I satisfies the BTP for some possibly unknown variable order ≺, then MAC (Maintaining ArcConsistency during search) solves I in O (ned3) time whatever the instantiation order < of the variables during search.of I produced by domain reduc-Proof. Since I satisfies the BTP, and the BTP is a conservative property, any restriction Itions (whether the result of instantiation of variables or arc consistency operations) also satisfies the BTP. By the proof ofTheorem 3.1, any arc consistent CSP instance that satisfies the BTP either has a solution or an empty domain. It followsthat MAC will be backtrack-free when applied to I , provided an assignment of a value to a variable is only accepted if theresulting arc-consistency closure has non-empty domains. In the worst case, for each variable i, MAC will have to try allvalues in D i . This makes a total of O (nd) times that arc consistency will have to be established. The complexity of O (ned3)follows assuming that MAC uses an O (ed2) arc consistency algorithm such as AC-2001 [27]. (cid:2)(cid:14)Corollary 7.5 shows that the class of binary CSP instances satisfying the BTP for some possibly unknown variable orderingcan be recognized in O (ned3) time. Combining this with Theorem 7.6, it is possible to detect whether a binary CSP instanceI satisfies the BTP, and if the result is positive, to actually solve I , in O (ned3) time. The advantage of this approach, ratherthan simply running MAC, is that we know in advance (in polynomial time) whether the BTP is satisfied and hence thatsearch will terminate in polynomial time.In general, we would expect that some but not all variables can be eliminated using lBTP. An important question ishow variable elimination by lBTP interacts with classical value elimination techniques. Eliminating values (for example,by arc consistency, path inverse consistency or neighbourhood substitution) cannot invalidate a variable elimination bylBTP but can provoke new variable eliminations by lBTP. Similarly, a variable elimination by lBTP cannot invalidate valueeliminations by any of these techniques but can provoke a new value elimination by neighbourhood substitution. However,a variable elimination by lBTP cannot destroy any form of consistency, and hence cannot provoke new value eliminationsby consistency operations. It is known that eliminating values by any convergent sequence of neighbourhood substitutionor consistency operations produces a CSP instance which is unique up to isomorphism [24]. It follows from the abovediscussion that a similar result holds for any convergent sequence of variable eliminations by lBTP and value eliminationsby neighbourhood substitution or consistency operations.8. Variable elimination using min-of-max extendabilityAs with the BTP, min-of-max extendability can also be used to eliminate variables. The important difference is that min-of-max extendability is defined relative to an ordering of the domains. In this section, we first assume that orderings aregiven for all domains, which allows us to generalize in a straightforward way the results of Section 7. Finally, we study thecase in which suitable domain orderings must be calculated.We first define a local form of min-of-max extendability for a single variable k.Definition 8.1. A variable k in a binary CSP instance is locally min-of-max extendable (lMME) for some ordering of Dk, if forall pairs of distinct variables i, j (cid:9)= k, (u, v) ∈ R i j implies that (cid:4)u, v, c(cid:5) is a consistent assignment for (cid:4)i, j, k(cid:5), where(cid:4)c = minmax(cid:4)(cid:8)R ik(u)(cid:4)(cid:8)(cid:8), maxR jk(v).Proposition 8.2. Let I be an arc-consistent binary CSP instance on variables {1, . . . , n} such that variable k is lMME for some orderingof Dk, and let Ihas a solution if and only if I has a solution. Indeed, the setof solutions to Ibe the induced subproblem of I on variables [n]−k. Then Iis exactly the projection of the set of solutions to I onto variables [n]−k.(cid:14)(cid:14)(cid:14)(cid:14)is a subproblem of I we only need to prove that every solution of Ican be extended to a solution of I . LetProof. Since I(cid:4)a1, . . . , ak−1, ak+1, . . . , an(cid:5) be a consistent labelling of [n]−k, i.e., a solution of I. By arc consistency, ∀i (cid:9)= k, R ik(ai) (cid:9)= ∅. Letc = min{max(R ik(ai)): i ∈ [n]−k} and suppose that c = max(R i0k(ai0 )) where i0 ∈ [n]−k. Since variable k is lMME, ∀ j /∈ {i0, k},(cid:4)ai0 , a j, c(cid:5) is a consistent assignment for (cid:4)i0, j, k(cid:5). Hence (cid:4)a1, . . . , ak−1, c, ak+1, . . . , an(cid:5) is a consistent assignment for variables{1, . . . , n}, i.e., a solution of I . (cid:2)(cid:14)(cid:14)An important, although obvious, property of any form of variable elimination is that it preserves arc consistency, sinceeliminating a variable cannot invalidate arc consistency.M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584581Theorem 8.3. Given orderings of all domains, the closure of an arc-consistent binary CSP under the elimination of all variables that arelMME is unique and can be found in O (ned2) time.Proof. By Definition 8.1, if variables j and k are both lMME, then variable j will still be lMME after elimination of variable k.It follows that the result of eliminating all variables that are lMME is unique, and can be obtained by eliminating suchvariables (in any order) until convergence.Call {i, j} an lMME obstruction-pair for k if ∃(u, v) ∈ R i j such that (cid:4)u, v, c(cid:5), where c = min(max(R ik(u)), max(R jk(v))),is not a consistent assignment for (cid:4)i, j, k(cid:5). The maximum value in each R i j(u), for all i, j, u, can be precomputed in O (ed2)time. Using these precomputed values we can calculate Obk, the set of lMME obstruction-pairs for k, in O (e2k d2) time, whereek is the number of binary constraints whose scope includes k. Summing over all variables k, we obtain a complexity ofO ((cid:9)nk=1 ekd2) = O (ned2).As in the proof of Theorem 7.4, we require O (ne) additional time to propagate deletions of variables. Hence the totaltime complexity to calculate the closure under eliminations of variables that are lMME is O (ed2 + ned2 + ne) = O (ned2). (cid:2)If a variable satisfies the lBTP, then it is lMME (but the converse is not always true). It follows that eliminating variablesthat are lMME is both stronger and (asymptotically) faster than eliminating variables that satisfy the lBTP.Corollary 8.4. For given domain orderings, the problem of finding a variable ordering for which an arc-consistent binary CSP instanceis min-of-max extendable (or determining that no such variable ordering exists) can be solved in O (ned2) time.Proof. Similar to the proof of Corollary 7.5. An arc-consistent binary CSP instance is min-of-max extendable if, and only if,each of its variables can be eliminated in turn (in some order) because they are lMME. (cid:2)For a given ordering of Dk, we can clearly test whether the variable k is lMME in polynomial time. We call such anordering of the values of k a min-of-max ordering. If |Dk| is bounded by a constant, then we can test all possible orderingsof Dk in polynomial time. An obvious question is, in the case that |Dk| is not bounded by a constant, whether determiningthe existence of a min-of-max ordering of Dk is tractable or not. We complete our study of min-of-max extendability byshowing below that this problem is, in fact, NP-complete.Min-of-Max Ordering (MMO)a binary CSP instance I and a variable kInput:Question: does there exist a min-of-max ordering of Dk in I?Theorem 8.5. The MMO problem for the class of CSP instances with finite but unbounded domain size is NP-complete.Proof. MMO ∈ NP since checking that k is lMME for a given ordering of Dk is polynomial-time. To prove NP-completenesswe will construct a polynomial reduction from SAT to MMO. Consider an instance ISAT of SAT with n variables v 1, . . . , vn.We will construct a 3-variable binary CSP instance I in which D3 = {1, . . . , 2n + 2} and for which there exists a min-of-maxordering of Dk if, and only if, ISAT is satisfiable.Let D1 = D2 and place an equality constraint on variables (cid:4)1, 2(cid:5). For each i ∈ {1, . . . , n}, we add distinct values ai, bi, cito D1 = D2 and tuples to the constraints with scopes (cid:4)1, 3(cid:5), (cid:4)2, 3(cid:5) such that R13(ai) = {i, 2n + 1}, R23(ai) = {n + i, 2n + 1},R13(bi) = {i, 2n + 2}, R23(bi) = {n + i, 2n + 2}, R13(ci) = {i, n + i, 2n + 1}, R23(ci) = {i, n + i, 2n + 2} (for i ∈ {1, . . . , n}). This isillustrated in Fig. 4. This construction ensures that, in any min-of-max ordering ≺ of D3, for each i ∈ {1, . . . , n}, exactly oneof i, n + i is less than both of 2n + 1, 2n + 2: the assignment (cid:4)ai, ai(cid:5) (respectively (cid:4)bi, bi(cid:5)) to variables (cid:4)1, 2(cid:5) ensures thatmin(i, n + i) is less than 2n + 1 (respectively 2n + 2), while the assignment (cid:4)ci, ci(cid:5) to variables (cid:4)1, 2(cid:5) ensures that at mostone of i, n + i is less than both of 2n + 1, 2n + 2.For any min-of-max ordering ≺ of D3, we associate the truth value false with v i precisely when i ≺ 2n + 1 andi ≺ 2n + 2. Clearly, n + i can be associated with ¬v i , since by the construction in Fig. 4 exactly one of i, n + i is less thanboth of 2n + 1, 2n + 2. For each clause C j = v i1∨ · · · ∨ v ir in ISAT , we add a distinct value d j to D1 = D2 and tuples to theconstraints with scopes (cid:4)1, 3(cid:5), (cid:4)2, 3(cid:5) such that R13(d j) = {i1, . . . , ir, 2n + 1}, R23(d j) = {i1, . . . , ir, 2n + 2}. This is illustrated∨ v i3 . In any min-of-max ordering of D3, not all of i1, . . . , ir can be less than both 2n + 1in Fig. 4 for the clause v i1and 2n + 2; this corresponds to imposing the constraint that one of the variables v i1 , . . . , v ir is true. (If the clause involvesa negated variable ¬v i , then we replace the value i by n + i in R13(d j) and R23(d j).) It follows that there is a min-of-maxordering of D3 if, and only if, ISAT is satisfiable. This reduction can clearly be completed in polynomial time. (cid:2)∨ v i29. Variable ordering heuristics based on the BTPEven when it is not possible to eliminate any variable from an instance I using the lBTP, as described in Section 7, itmay still be true that some induced subproblem of I , on some subset of variables S, satisfies the BTP for some ordering of582M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584(a)(b)Fig. 4. (a) The construction which codes vn+i = ¬v i , since it implies that exactly one of the values i, n + i is less than both of 2n + 1, 2n + 2 in an MMEP∨ v i3 since it implies that not all of i1, i2, i3 are less than both of 2n + 1, 2n + 2 inordering of D3. (b) The construction which codes the clause v i1an MMEP ordering of D3.∨ v i2its variables. In this case, by ordering the whole set of variables X of I so that the variables in S all occur after the variablesin X − S, the subproblem on variables S obtained after the instantiation of the variables in X − S satisfies the BTP, since theBTP is conservative. In this case, we know by Theorem 7.6 that MAC will be backtrack-free on the variables S. This impliesthat the maximum number of leaf nodes visited in the MAC search tree will be dn−|S|. (Note that the same argument doesnot apply to min-of-max extendability, as it is not conservative.)Hence, to limit the size of the search tree explored by the MAC algorithm, it is desirable to find a large set of variablesS on which the BTP is satisfied. Once we have found such a set of variables S, then standard variable-ordering heuristics[33–35] can be used to order the variables in X − S.Unfortunately, finding the largest possible set of variables on which the BTP is satisfied is an NP-hard problem, as wenow show.Theorem 9.1. Given a binary CSP instance I on variables X , it is NP-hard to determine the maximum size of a subset S ⊆ X such thatthe induced subproblem of I on S satisfies the BTP.Proof. The problem MAX-ONES is the problem of finding a solution to a problem SAT which maximizes the number ofboolean variables assigned the value true. It is known [36] that MAX-ONES is NP-hard (in fact, APX-complete) even whenrestricted to instances whose clauses are all of the form φ(xi, x j, xk), where φ(x, y, z) = ¬x ∨ ¬ y ∨ ¬z. We will show thatany instance I1 of MAX-ONES whose clauses are all of this form can be expressed as a problem of finding the maximumsize of a subset of variables of a binary CSP instance I2 such that the induced subproblem of I2 on S satisfies the BTP.M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584583We say that there is a BTP obstruction (i, j, k, a, u, v, b) with respect to variable ordering < if there exist i < j < k suchthat u ∈ D i , v ∈ D j , a, b ∈ Dk and (u, a) ∈ R ik, (u, v) ∈ R i j , (v, b) ∈ R jk, (u, b) /∈ R ik, and (v, a) /∈ R jk.For each variable xi in I1, we create a variable i in I2. For each clause φ(xi, x j, xk) in I1, we create three BTP obstructionswhich imply O i < max(O j, O k), O j < max(O k, O i) and O k < max(O i, O j). For example, creating a BTP obstruction whichimplies O k < max(O i, O j) means adding values a, b to Dk, u to D i and v ∈ D j satisfying (u, v) ∈ R i j , (u, a) ∈ R ik, (v, b) ∈R jk, (u, b) /∈ R ik and (v, a) /∈ R jk. The inequality constraints implied by the three BTP obstructions are inconsistent, but anysubset of two of these constraints is consistent. Therefore at most two of i, j, k can belong to S. Associating xi = true withi ∈ S, these three BTP obstructions therefore impose the constraint φ(xi, x j, xk) on the corresponding variables in I1. Thisreduction is polynomial-time (and in fact log-space), which demonstrates that finding the maximum induced subproblemof I2 which satisfies the BTP is NP-hard. (cid:2)10. ConclusionWe have described new tractable classes of binary CSP instances which significantly generalize tree-structured problemsas well as previously-identified language-based classes. These new classes are obtained by imposing requirements on thesets of constraints imposed on all ordered triples of variables. Moreover, we have shown that the problem of determining avariable ordering for which these properties hold is solvable in polynomial time.We see this work as a first step towards a complete characterization of all hybrid tractable classes of constraint satisfac-tion problems, that is, all tractable classes which are obtained by restricting the combined properties of both the constraintrelations and the way in which they interact.From a practical point of view, we have shown that the properties which define the tractable classes introduced inthis paper can also be used to eliminate variables in binary CSPs. This provides us with a reduction technique which isorthogonal and complementary to classical value elimination techniques such as arc consistency.Furthermore, one of the local properties (the BTP) can be used to improve variable-ordering heuristics by instantiatinglast a subset of variables on which the BTP holds. An interesting area for future research would be to investigate variableordering heuristics which try to minimize the number of times the BTP is not satisfied.AcknowledgementsWe would like to thank Chris Jefferson for pointing out Theorem 7.6.References[1] E.C. Freuder, A sufficient condition for backtrack-free search, Journal of the ACM 29 (1) (1982) 24–32, doi:10.1145/322290.322292.[2] R. Dechter,J. Pearl, Network-based heuristics for constraint-satisfaction problems, ArtificialIntelligence 34 (1) (1987) 1–38, doi:10.1016/0004-3702(87)90002-6.[3] A. Bulatov, P. Jeavons, A. Krokhin, Classifying the complexity of constraints using finite algebras, SIAM Journal on Computing 34 (3) (2005) 720–742,doi:10.1137/S0097539700376676.[4] T. Feder, M.Y. Vardi, The computational structure of monotone monadic SNP and constraint satisfaction: A study through Datalog and group theory,SIAM Journal on Computing 28 (1) (1998) 57–104, doi:10.1137/S0097539794266766. Available from: http://link.aip.org/link/?SMJ/28/57/1.[5] D. Cohen, P. Jeavons, M. Gyssens, A unified theory of structural tractability for constraint satisfaction problems, Journal of Computer and SystemSciences 74 (5) (2008) 721–743, doi:10.1016/j.jcss.2007.08.001.[6] P. Jeavons, On the algebraic structure of combinatorial problems, Theoretical Computer Science 200 (1–2) (1998) 185–204, doi:10.1016/S0304-3975(97)00230-2.[7] A.A. Bulatov, Tractable conservative constraint satisfaction problems,in: Proceedings of 18th IEEE Symposium on Logic in Computer Sci-ence (LICS 2003), Ottawa, Canada, 22–25 June 2003, IEEE Computer Society, 2003, pp. 321–330. Available from: http://csdl.computer.org/comp/proceedings/lics/2003/1884/00/18840321abs.htm.[8] T.J. Schaefer, The complexity of satisfiability problems, in: STOC ’78: Proceedings of the Tenth Annual ACM Symposium on Theory of Computing, 1978,pp. 216–226.[9] A.A. Bulatov, A dichotomy theorem for constraint satisfaction problems on a 3-element set,Journal ofthe ACM 53 (1)(2006) 66–120,doi:10.1145/1120582.1120584.[10] M. Grohe, The structure of tractable constraint satisfaction problems, in: Proceedings of the 31st Symposium on Mathematical Foundations of ComputerScience, in: Lecture Notes in Computer Science, vol. 4162, Springer-Verlag, 2006, pp. 58–72.[11] V. Dalmau, P.G. Kolaitis, M.Y. Vardi, Constraint satisfaction, bounded treewidth, and finite-variable logics, in: CP ’02: Proceedings of the 8th InternationalConference on Principles and Practice of Constraint Programming, in: Lecture Notes in Computer Science, vol. 2470, Springer-Verlag, 2002, pp. 310–326.[12] M. Grohe, The complexity of homomorphism and constraint satisfaction problems seen from the other side, Journal of the ACM 54 (1) (2007) 1–24,doi:10.1145/1206035.1206036.[13] R. Dechter, Constraint Processing, Morgan Kaufmann, 2003.[14] D. Cohen, P. Jeavons, The complexity of constraint languages, in: F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Elsevier,2006, pp. 245–280.[15] D.A. Cohen, M.J. Green, Typed guarded decompositions for constraint satisfaction, in: F. Benhamou (Ed.), CP ’06: Proceedings of the 12th InternationalConference on Principles and Practice of Constraint Programming, in: Lecture Notes in Computer Science, vol. 4204, Springer-Verlag, 2006, pp. 122–136.[16] T.K. Kumar, A framework for hybrid tractability results in boolean weighted constraint satisfaction problems, in: CP ’08: Proceedings of the 14thInternational Conference on Principles and Practice of Constraint Programming, in: Lecture Notes in Computer Science, vol. 5202, Springer-Verlag,2008, pp. 282–297.[17] E.C. Freuder, A sufficient condition for backtrack-bounded search, Journal of the ACM 32 (4) (1985) 755–761, doi:10.1145/4221.4225.584M.C. Cooper et al. / Artificial Intelligence 174 (2010) 570–584[18] H.L. Bodlaender, A linear-time algorithm for finding tree-decompositions of small treewidth, SIAM Journal on Computing 25 (6) (1996) 1305–1317,doi:10.1137/S0097539793251219. Available from: http://link.aip.org/link/?SMJ/25/1305/1.[19] J. Pearson, P. Jeavons, A survey of tractable constraint satisfaction problems, Tech. Rep. CSD-TR-97-15, Royal Holloway, University of London, July 1997.Available from: ftp://ftp.cs.rhul.ac.uk/pub/constraints/survey.ps.[20] P. van Beek, R. Dechter, Constraint tightness and looseness versus local and global consistency,Journal of the ACM 44 (4) (1997) 549–566,doi:10.1145/263867.263499.[21] P. Jégou, On the consistency of general constraint-satisfaction problems, in: AAAI, 1993, pp. 114–119. Available from: http://www.aaai.org/Library/AAAI/1993/aaai93-018.pdf.[22] E.C. Freuder, C.D. Elfe, Neighborhood inverse consistency preprocessing, in: Proc. AAAI/IAAI-96, Portland, OR, vol. 1, 1996, pp. 202–208. Available from:http://www.aaai.org/Library/AAAI/1996/aaai96-030.php.[23] E.C. Freuder, Eliminating interchangeable values in constraint satisfaction problems, in: Proc. AAAI-91, Anaheim, CA, 1997, pp. 227–233. Available from:http://www.aaai.org/Library/AAAI/1991/aaai91-036.php.[24] M.C. Cooper, Fundamental properties of neighbourhood substitution in constraint satisfaction problems, Artificial Intelligence 90 (1–2) (1997) 1–24,doi:10.1016/S0004-3702(96)00018-5.[25] M. Cooper, D. Cohen, P. Jeavons, Characterising tractable constraints, Artificial Intelligence 65 (1994) 347–361, doi:10.1016/0004-3702(94)90021-3.[26] C. Bessiere, Constraint propagation, in: F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of Constraint Programming, Elsevier, 2006, pp. 29–83.[27] C. Bessière, J.-C. Régin, Refining the basic constraint propagation algorithm,in: Proc IJCAI’01, Seattle, WA, 2001, pp. 309–315. Available from:http://www.lirmm.fr/%7Ebessiere/stock/ijcai01.ps.[28] P.G. Jeavons, M.C. Cooper, Tractable constraints on ordered domains, Artificial Intelligence 79 (2) (1995) 327–339, doi:10.1016/0004-3702(95)00107-7.[29] R. Mohr, G. Masini, Good old discrete relaxation, in: Y. Kodratoff (Ed.), Proceedings of the 8th European Conference on Artificial Intelligence—ECAI’88,Pitman, 1988, pp. 651–656.[30] R. Dechter, J. Pearl, Tree clustering for constraint networks (research note), Artificial Intelligence 38 (3) (1989) 353–366, http://dx.doi.org/10.1016/0004-3702(89)90037-4.[31] P. van Beek, R. Dechter, On the minimality and decomposability of row-convex constraint networks, Journal of the ACM 42 (3) (1995) 543–561,doi:10.1145/210346.210347.[32] R. Dechter, Bucket elimination: A unifying framework for reasoning, Artificial Intelligence 113 (1–2) (1999) 41–85, doi:10.1016/S0004-3702(99)00059-4.[33] B.M. Smith, The Brélaz heuristic and optimal static orderings, in: CP ’99: Proceedings of the 5th International Conference on Principles and Prac-tice of Constraint Programming, in: Lecture Notes in Computer Science, vol. 1713, Springer-Verlag, 1999, pp. 405–418. Available from: http://www.springerlink.com/content/3dgkv9kgvc4h340w/.[34] J.C. Beck, P. Prosser, R.J. Wallace, Toward understanding variable ordering heuristics for constraint satisfaction problems, in: Proceedings of the Four-teenth Irish Artificial Intelligence and Cognitive Science Conference, 2003, pp. 11–16. Available from: http://tidel.mie.utoronto.ca/pubs/promise.aics.pdf.[35] C. Bessière, A. Chmeiss, L. Saïs, Neighborhood-based variable ordering heuristics for the constraint satisfaction problem, in: CP ’01: Proceedings of the7th International Conference on Principles and Practice of Constraint Programming, in: Lecture Notes in Computer Science, vol. 2239, Springer-Verlag,2001, pp. 565–569.[36] N. Creignou, S. Khanna, M. Sudan, Complexity Classification of Boolean Constraint Satisfaction Problems, SIAM Monographs on Discrete Mathematicsand Applications, vol. 7, Society for Industrial and Applied Mathematics, Philadelphia, PA, 2001.