Artificial Intelligence 172 (2008) 738–771www.elsevier.com/locate/artintSolving quantified constraint satisfaction problems ✩Ian P. Gent a, Peter Nightingale a, Andrew Rowley a, Kostas Stergiou b,∗a School of Computer Science, University of St Andrews, St Andrews, Fife, KY16 9SS, UKb Department of Information and Communication Systems Engineering, University of the Aegean, GreeceReceived 15 August 2006; received in revised form 2 April 2007; accepted 5 November 2007Available online 22 November 2007AbstractWe make a number of contributions to the study of the Quantified Constraint Satisfaction Problem (QCSP). The QCSP is anextension of the constraint satisfaction problem that can be used to model combinatorial problems containing contingency oruncertainty. It allows for universally quantified variables that can model uncertain actions and events, such as the unknown weatherfor a future party, or an opponent’s next move in a game. In this paper we report significant contributions to two very differentmethods for solving QCSPs. The first approach is to implement special purpose algorithms for QCSPs; and the second is to encodeQCSPs as Quantified Boolean Formulas and then use specialized QBF solvers. The discovery of particularly effective encodingsinfluenced the design of more effective algorithms: by analyzing the properties of these encodings, we identify the features in QBFsolvers responsible for their efficiency. This enables us to devise analogues of these features in QCSPs, and implement them inspecial purpose algorithms, yielding an effective special purpose solver, QCSP-Solve. Experiments show that this solver and ahighly optimized QBF encoding are several orders of magnitude more efficient than the initially developed algorithms. A final,but significant, contribution is the identification of flaws in simple methods of generating random QCSP instances, and a means ofgenerating instances which are not known to be flawed.© 2007 Elsevier B.V. All rights reserved.Keywords: Quantified constraint satisfaction problems; Quantified Boolean formulas; Arc consistency; Search algorithms; Random problems1. IntroductionQuantified Constraint Satisfaction Problems (QCSPs) can be used to model various PSPACE-complete combina-torial problems from domains like planning under uncertainty, design, adversary game playing, and model checking.For example, in game playing we may want to determine if a consistent strategy exists for all possible moves of theopponent. In a design problem it may be required that a configuration must be possible for all possible sequences ofuser choices. As a final example, when planning in a safety critical environment, such as a nuclear station, we may✩ Parts of this paper have appeared in the conference papers [I. Gent, P. Nightingale, A. Rowley, Encoding quantified CSPs as quantified Booleanformulae, in: Proceedings of ECAI-2004, 2004, pp. 176–180; I. Gent, P. Nightingale, K. Stergiou, QCSP-Solve: A solver for quantified constraintsatisfaction problems, in: Proceedings of IJCAI-2005, 2005].* Corresponding author.E-mail addresses: ipg@dcs.st-and.ac.uk (I.P. Gent), pn@dcs.st-and.ac.uk (P. Nightingale), agdr@dcs.st-and.ac.uk (A. Rowley),konsterg@aegean.gr (K. Stergiou).0004-3702/$ – see front matter © 2007 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2007.11.003I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771739require that an action is possible for every eventuality. QCSPs extend traditional, unquantified, CSPs to deal with thekind of contingency found in the above examples.The QCSP naturally generalizes the standard CSP formalism by allowing for universally quantified variables.Universal variables are used to model actions or events which are contingent, for which we are uncertain, or justthose which are not in our control. Examples would be contingencies such as user choices in a configuration problem,uncertainties such as the weather in a plan to hold a garden party, or opponent moves in an adversary game. In aconventional CSP, all variables are existentially quantified, since all are within our control. The values in the domainof a universal variable capture all the possible outcomes of the event or action modelled by this variable. In this way,QCSPs model bounded uncertainty. In a QCSP we try to find a strategy, defining the values of the existential variablesfor all possible sequences of instantiations for the universal variables, so that all the constraints in the problem aresatisfied. Such a strategy guarantees that there is a solution whatever values the universal variables take, i.e. whateverthe outcome of the uncertain actions and events. The generalization of CSPs to QCSPs increases the expressiveness ofthe framework, but at the same time the complexity of the decision task rises from NP-complete to PSPACE-complete[8,26,38].There is already considerable interest in quantified constraint reasoning in the case of Quantified Boolean Formulae(QBF), which is the generalization of SAT that allows universal quantification (for example, [13,23,29,32,33]). Also,there is a significant body of work on quantified problems with continuous real domains (e.g. [5,41]). Ratschan givesnumerous references to papers on this subject [40]. As far as QCSPs with discrete finite non-Boolean domains areconcerned, there is recent research on theory defining the complexity of various reasoning tasks and also specifyingtractable subclasses (e.g. [8,11,15–18]). Also, various useful concepts from CSPs, such as global and local consistency,substitutability and interchangeability, have been defined for QCSPs [11,12]. However, little has been done as faras algorithms for solving QCSPs are concerned. In the few existing works, Bordeaux and Monfroy introduced aframework for implementing arc consistency and described filtering operators for certain classes of constraints [9,12]. Also, very recently, Verger and Bessière proposed a bottom-up solver for QCSPs called BlockSolve [44], whileBenedetti, Lallouet and Vautard implemented QeCode, a QCSP solver built on top of the CSP solver Gecode [4].In this paper we report the first comprehensive attempt to build effective QCSP solvers, although we limit ourselvesto the case where constraints are binary. We make contributions to two very different approaches to solving QCSPs.These are special purpose solvers for QCSPs; and encoding QCSPs as QBF instances so that existing QBF solverscan be used. In each approach we introduce novel and effective techniques. We also show how experience with theencodings directly influenced the design of better techniques for the specialized solvers.We first approach QCSPs directly by extending well-known algorithms from the standard to the quantified case.This is analogous to the approach taken at the early stages of research in QBF. We show that some of the most widelyused techniques for CSPs can be adapted to deal with quantification. We first describe a generic arc consistencyalgorithm that can be used to enforce AC in any binary QCSP. We then extend the chronological backtracking (BT),forward checking (FC), and maintaining arc consistency (MAC) algorithms so that they can handle quantification. Wealso propose modifications of FC and MAC that take advantage of the properties of QCSPs.Then we follow an orthogonal approach, based on encoding QCSPs as QBFs. A particular advantage of encod-ing one search problem as another occurs when, as here, search techniques for the target problem are more highlydeveloped than the original. In contrast to QCSP, numerous advanced solvers are available for QBF. We describe afinely-tuned encoding which can be several orders of magnitudes more efficient than the direct methods described sofar. The tuning of encodings to be effective for search is considerably more involved than in the case of SAT, whereencodings often have an elegant simplicity. A simple way of lifting CSP encodings to QCSP is very ineffective, so weexplore and implement new ideas, without analogues in SAT, that make search very effective.Apart from obtaining efficient tools for QCSP solving, we benefit from the study and development of encodings tolearn valuable lessons that can be transferred to direct algorithms. So in the third, and final, stage in the developmentof algorithms for QCSPs we analyze the advantages offered by our QBF encoding to identify the features responsi-ble for its efficiency. We identify three sophisticated techniques; conflict-based backjumping [39], solution-directedbackjumping [32], and most importantly, the pure literal rule [14], as important reasons for the success of QBF solversin solving encoded QCSP instances. We devise analogues of these features in QCSPs, and implement them on top ofdirect algorithms, to yield a specialized direct solver, called QCSP-Solve.A final issue we address in this paper is that of benchmarking, since there is naturally a distinct lack of benchmarksto compare algorithms on. This is a familiar problem that has appeared in the early stages of experimental research740I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771in various other areas. As was the case with CSP, SAT, and QBF, we address this problem by proposing and usingmethods to generate random instances. We show that a simple generalization of random generation models fromCSPs or QBF to QCSPs is prone to flaws, which quickly affect all generated instances. We then introduce a randomgenerator that is free from these flaws, although it remains possible that it will suffer from a currently unknown flaw.Experiments run on problems created using this generator reveal a progressive, and dramatic, improvement in theefficiency of our methods; starting with the initial direct algorithms and culminating in QCSP-Solve and a highlyoptimized QBF encoding.This paper is structured as follows. In Section 2 we give the necessary definitions and background. We then presentprogressively more efficient methods of handling QCSPs. In Section 3 we follow the direct approach by extendingstandard algorithms from CSPs to QCSPs. In Section 4 we describe some of the existing work on encodings, anddevelop a finely-tuned encoding which is remarkably more efficient than the direct approaches. In Section 5 weshow how lessons learned from the encoding of QCSP into QBF can be utilized to enhance the direct algorithms,resulting in QCSP-Solve; an advanced solver for QCSPs. Section 6 describes a flaw which can arise in randomQCSPs, introduces a random generator for QCSPs, and gives indicative experimental results which demonstrate thebuilding of progressively more efficient techniques. Finally, in Section 7 we conclude.2. PreliminariesA Constraint Satisfaction Problem (CSP) consists of a set of variables, each associated with a domain of possiblevalues, and a set of constraints restricting the combinations of values that the variables can simultaneously take. InCSPs all variables are existentially quantified. QCSPs are more expressive in that they allow universally quantifiedvariables. In this way they enable the formulation of problems where all contingencies must be allowed for. We nowgive a formal definition of a QCSP instance. As is usual practice in CSPs, we use the name QCSP to denote bothparticular instances and the decision problem of determining whether an instance is true (i.e. soluble) or not.Definition 1. A Quantified Constraint Satisfaction Problem (QCSP) F is a tuple (cid:3)V , Q, D, C(cid:4) where:• V is a linearly ordered set of n variables. In the following we will denote by vi the i-th element of V with respectto this linear order.• Q is a mapping from V to the set of quantifiers {∃, ∀}. For each variable vi ∈ V , Q(vi) is a quantifier (∃ or ∀)associated with vi .• D is a mapping from V to a set of domains D = {D(v1), . . . , D(vn)}. For each variable vi ∈ V , D(vi) is the finitedomain of its possible values.• C = {c1, . . . , cm} is a set of m constraints. Each constraint ci ∈ C is defined as a pair (vars(ci), rel(ci)), where:1) vars(ci) = (vj1, . . . , vjk ) is an ordered subset of V called the constraint scope. The size of vars(ci) is calledthe arity of ci . 2) rel(ci) is a subset of the Cartesian product D(vj1 ) × · · · × D(vjk ) and it specifies the allowedcombinations of values for the variables in vars(ci).The above definition of a QCSP reduces to that of a standard CSP if there are no universally quantified variables inthe problem.A block of variables in a QCSP F is a maximal subsequence of variables in V that have the same quantification.The assignment (also called instantiation) of value aj ∈ D(vj ) to variable vj ∈ V will be denoted by vj (cid:8)→ aj .Accordingly, the tuple assigning values a1, . . . , ai to variables v1, . . . , vi will be denoted by (cid:3)v1 (cid:8)→ a1, . . . , vi (cid:8)→ ai(cid:4).The set of variables over which a tuple τ is defined will be denoted by vars(τ ). For any subset vars(cid:10) of vars(τ ), τ [vars(cid:10)]denotes the sub-tuple of τ that includes only assignments to the variables in vars(cid:10). A tuple τ is consistent, iff for allci ∈ C, s.t. vars(ci) ⊆ vars(τ ), τ [vars(ci)] ∈ rel(ci). For any constraint ci ∈ C, variable vj ∈ V and value a ∈ D(vj ),we denote by ci[vj (cid:8)→ a] the subset of rel(ci) that only includes tuples where vj takes value a. If vj /∈ vars(ci) thenci[vj (cid:8)→ a] ≡ rel(ci). We write C[vj (cid:8)→ a] as a shorthand for c1[vj (cid:8)→ a] ∧ · · · ∧ cm[vj (cid:8)→ a].In what follows we will often refer to universally and existentially quantified variables as universals and existentialsrespectively.I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771741Fig. 1. A solution to the problem of Example 1.Definition 2 (QCSP semantics). A QCSP F = (cid:3)V , Q, D, C(cid:4) represents the logical formula φ = Q(v1)v1 ∈D(v1) . . . Q(vn)vn ∈ D(vn) (C). The semantics of a QCSP can be defined recursively as follows.The base case is a QCSP instance with an empty quantifier prefix Q, i.e. all variables assigned. This QCSP in-stance is true iff, for each constraint ci ∈ C, the tuple of values of assigned variables in its scope vars(ci) belongsto its relation rel(ci). Note that an empty QCSP is vacuously true. If φ is of the form ∃v1 ∈ D(v1) Q(v2)v2 ∈D(v2) . . . Q(vn)vn ∈ D(vn) (C) then F is true iff there exists some value a ∈ D(v1) such that Q(v2)v2 ∈D(v2) . . . Q(vn)vn ∈ D(vn)(C[v1 (cid:8)→ a]) is true. Or in words, if under the assignment v1 (cid:8)→ a the rest of the prob-lem is true. If φ is of the form ∀v1 ∈ D(v1) Q(v2)v2 ∈ D(v2) . . . Q(vn)vn ∈ D(vn) (C) then F is true iff for eachvalue a ∈ D(v1), Q(v2)v2 ∈ D(v2) . . . Q(vn)vn ∈ D(vn)(C[v1 (cid:8)→ a]) is true.To better understand the semantics of a QCSP, we first need to define the notion of a strategy. A strategy is a treewith each level of the tree corresponding to a variable. Level 1 corresponds to the first variable v1 in V , and levelsthereafter follow the order of V . A node in the ith level of the tree corresponds to a tuple of variable assignments(cid:3)v1 (cid:8)→ a1, . . . , vi (cid:8)→ ai(cid:4), where a1 ∈ D(v1), . . . , ai ∈ D(vi). The root of the tree corresponds to the empty tuple, thefirst level nodes correspond to a 1-tuple assigning a value to the first variable in V , the second level nodes correspondto 2-tuples assigning the first two variables in V , generated by extending the first level assignment, etc. A node inthe tree corresponding to tuple (cid:3)v1 (cid:8)→ a1, . . . , vi (cid:8)→ ai(cid:4) has as many children as the values in D(vi+1), if vi+1 isuniversally quantified, whereas it has a single child if vi+1 is existentially quantified. A node corresponding to tupleτ = (cid:3)v1 (cid:8)→ a1, . . . , vi (cid:8)→ ai(cid:4) is true iff τ is consistent. Otherwise, the node is false. A tuple of assignments to allvariables in a QCSP (i.e. a n-tuple) constitutes a scenario. Within a scenario, the value of each existential variabledepends on the values of the universal variables that precede it in V . A scenario is consistent iff all the variableassignments in the scenario satisfy all constraints in the problem.We can now give an alternative definition of the semantics of a QCSP: A QCSP with n variables is true (orsatisfiable) iff there exists a strategy where all the leaf nodes (i.e. the nodes of level n) are true.1 Or in other words,iff there exists a strategy such that all the scenarios of the strategy are consistent. Such a strategy is called a consistentstrategy, or simply a solution, to the QCSP. As we will show, backtracking-based algorithms can solve a QCSP bytraversing the space of strategies until they discover a consistent one or prove that none exists.Example 1. Consider the problem ∀v1∃v2∀v3∃v4 (v1 (cid:14)= v2 ∧ v1 (cid:14)= v4 ∧ v3 (cid:14)= v4). This is a QCSP where V consists offour variables, and C is a conjunction of three constraints. The problem reads “for all values of v1 there exist valuesof v2 such that for all values of v3 there exist values of v4, such that all constraints are satisfied”. Assuming that allvariables have domain {0, 1, 2} then the problem is true. A solution to this problem is depicted in Fig. 1. Each path toa leaf node is a consistent scenario.Note that, in contrast to standard CSPs, the variables in a QCSP are ordered. This means that changing their ordergives rise to a different problem. For example, the problem ∀vi∃vj (vi = vj ), with D(vi) = D(vj ) = {0, 1}, is true asfor any value of vi we can find a value for vj to satisfy the constraint. However, the problem ∃vj ∀vi (vj = vi ), withD(vj ) = D(vi) = {0, 1}, is false as no value of vj satisfies the constraint for both possible assignments to vi .1 This definition can easily be extended to the case where nodes may be pruned by propagation.742I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771In this paper we restrict our attention to binary QCSPs. As is common, we assume that at most one constraint isdefined on any pair of variables. In a binary QCSP, each constraint, denoted by cij , involves two variables (vi and vj )which may be universally or existentially quantified. We assume that for any constraint cij , variable vi precedes vj inV , unless explicitly specified otherwise. Some of the techniques described below can be easily extended to constraintsof any arity, but for others this extension is much more involved. We briefly elaborate on this in Section 3.1.3. Extending CSP algorithms to handle QCSPsIn this section we begin the presentation of techniques for solving QCSPs. We first approach the problem directlyby extending standard algorithms from CSPs to deal with quantification. Namely, we describe an arc consistencyalgorithm for binary QCSPs, and adapt widely used backtracking search algorithms to handle QCSPs. We also showhow the notion of value interchangeability can be exploited in QCSPs to break some symmetries.3.1. Arc consistencyAn important concept in CSPs is the concept of local consistency. Local consistencies are properties that can beachieved in a CSP, using (typically) algorithms with polynomial time complexity, to remove some inconsistent valueseither prior to or during search. Arc consistency is the most commonly used local consistency property in the existingconstraint programming engines.A constraint cij in a CSP is arc consistent (AC) iff for each value a ∈ D(vi) there exists a value b ∈ D(vj ) sothat the assignments vi (cid:8)→ a and vj (cid:8)→ b are compatible (i.e. satisfy cij ). In this case we say that b is a support fora on constraint cij . Accordingly, a is a support for b on the same constraint. A binary CSP is arc consistent iff allits constraints are arc consistent. The operation performed to determine whether a value a ∈ D(vi) is supported by avalue b ∈ D(vj ) with respect to constraint cij is called a constraint check.Bordeaux and Monfroy extended the definition of AC to QCSPs and described the schema of a generic AC3-basedalgorithm for QCSPs [12]. This algorithm can be instantiated to achieve AC on specific constraints (not necessarilybinary) once filtering operators have been defined for these constraints. A filtering operator for a constraint c is afunction that specifies which values in the domains of the variables involved in c are arc inconsistent with respect to c,taking in consideration the quantification of the variables [12]. Consider the following example:Example 2. Bordeaux and Monfroy defined filtering operators for constraint ¬vi = vj , where vi and vj have Booleandomains [12]. These operators specify the values in D(vi) and D(vj ) that are arc inconsistent according to the quan-tification of the two variables. The application of an AC algorithm will prune these values from the domains. Forinstance, if vi is existentially quantified and vj is universally quantified (i.e. the formula is ∃vi∀vj (¬vi = vj )) thenthe following applies: If D(vj ) = {0} then value 0 is pruned from D(vi). If D(vj ) = {1} then value 1 is prunedfrom D(vi).The definition of AC and the AC algorithm of [12] are based on decomposing complex constraints (e.g. constraintsof high arity), that may be present in a QCSP, into “primitive” constraints for which AC filtering operators havebeen defined. As noted in [12], this definition is somewhat different from the standard definition of AC in CSPs, and isactually closer to the definition of relational consistency [21]. In [12], and later in [9], filtering operators for constraintson Boolean variables and also for linear numerical constraints were defined. The aim of our work on AC for QCSPs isto define filtering operators for arbitrary binary constraints, as opposed to specific constraints with known semantics,and embed these into an efficient algorithm.We first give an alternative definition of AC for binary QCSPs that closely follows the standard CSP definition.Based on this definition, we then define filtering operators for arbitrary binary constraints in a straightforward way.Finally, we describe QAC-2001, a generic AC algorithm that utilizes these filtering operators to achieve AC in arbitrarybinary QCSPs. In contrast to the algorithm of [12] which is based on AC3, QAC-2001 is based on AC2001/3.1, theAC algorithm of [6] for binary CSPs.22 Note that other AC algorithms, like AC-6, can be used as basis. We chose to use AC2001/3.1 because of its simplicity and optimal timecomplexity.I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771743Definition 3. A binary QCSP F = (cid:3)V , Q, D, C(cid:4) is arc consistent iff all the constraints cij ∈ C are arc consistent.Consider a constraint cij ∈ C, where vi is before vj in V . There are four possible combinations of quantification forvi and vj . For each case, constraint cij is arc consistent iff:∃ vi ∃ vj : Each value a ∈ D(vi) is supported by at least one value in D(vj ), and each value b ∈ D(vj ) is supportedby at least one value in D(vi).∀ vi ∀ vj : Each value a ∈ D(vi) is supported by all values in D(vj ), and each value b ∈ D(vj ) is supported by allvalues in D(vi).∀ vi ∃ vj : Each value a ∈ D(vi) is supported by at least one value in D(vj ), and each value b ∈ D(vj ) is supportedby at least one value in D(vi).∃ vi ∀ vj : Each value a ∈ D(vi) is supported by all values in D(vj ), and each value b ∈ D(vj ) is supported by atleast one value in D(vi).Matching the four cases of the definition above, we can define filtering operators for an arbitrary binary constraintcij as follows. These filtering operators specify the values that are arc inconsistent, and thus must be removed fromthe domains of the variables involved in the constraint.∃ vi ∃ vj (cij ): If a value a ∈ D(vi) has no support in D(vj ) then a is removed from D(vi). Similarly, if a valueb ∈ D(vj ) has no support in D(vi) then b is removed from D(vj ). If any of the two domains becomes emptythen the problem is false.∀ vi ∀ vj (cij ): If any value a ∈ D(vi) is not supported by all values in D(vj ) (in which case at least one valueb ∈ D(vj ) will also not be supported by all values in D(vi)) then the problem is false. Note that it suffices tocheck the constraint only in one direction. If all values of vi are supported by all values of vj then, obviously,the opposite also holds.∀ vi ∃ vj (cij ): If a value a ∈ D(vi) has no support in D(vj ) then the problem is false. If a value b ∈ D(vj ) has nosupport in D(vi) then b is removed from D(vj ). If D(vj ) becomes empty then the problem is false.∃ vi ∀ vj (cij ): If a value a ∈ D(vi) is not supported by all values in D(vj ) then a is removed from D(vi). If D(vi)becomes empty then the problem is false. If a value b ∈ D(vj ) has no support in D(vi) then the problemis false. Note that it suffices to check the constraint only in one direction. If there is at least one value inD(vi) that is supported by all values in D(vj ) then, obviously, all values in D(vj ) have at least one supportin D(vi).In Fig. 2 we sketch algorithm QAC-2001. The algorithm takes as input a QCSP F = (cid:3)V , Q, D, C(cid:4) and removesunsupported values from the domains of the variables using the filtering operators described above. If the domain ofan existential becomes empty or a value is removed from the domain of a universal then the algorithm returns FALSE.The algorithm performs constraint-based propagation. That is, it uses a stack of constraints that are propagatedinstead of a stack of variables. Apart from this, it is similar to AC2001/3.1 augmented with the handling of universalvariables. As in AC2001/3.1, we use a structure, called currentSupport (corresponding to structure Last in [6]), tokeep track of the most recently discovered supports for the values of the variables. To be precise, if cij ∈ C thencurrentSupportvi ,a,vj is the value in D(vj ) that currently supports value a ∈ D(vi). For each vi ∈ V , a ∈ D(vi), andvj ∈ V (s.t. vi is constrained with vj ) currentSupportvi ,a,vj is initialized to NIL. As in [6], value NIL is defined asa dummy value which precedes any value in any domain. We assume that there exists an order of the values in thedomains.Initially, all constraints are added to the stack S. Constraints of the form ∃vi∀vj (cij ) and ∀vi∀vj (cij ) are dealtwith by a preprocessing step in function QAC-2001. For the former, each value of D(vi) that is not supported by allvalues of D(vj ) is removed from D(vi). For the latter, if there is a value of D(vi) that is not supported by all valuesof D(vj ) then we can determine that the problem is false. Such constraints are thereafter removed from S and are notconsidered during the propagation phase.In the propagation phase, function Revise is called for each constraint cij in the stack. This function looks for asupport in D(vj ) for each value a of D(vi). This is done by first looking at value currentSupportvi ,a,vj . If this isNIL or it has been removed from D(vj ) because of propagation then the values of vj are examined starting with theone immediately after currentSupportvi ,a,vj . If no support is found for a, it is removed from D(vi). In this case, if vi744I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771Boolean QAC-2001(F = (cid:3)V , Q, D, C(cid:4))input: A QCSP Foutput: TRUE if AC is successfully applied on F and FALSE if there a domain wipeoutof an existential or a value is removed from the domain of a universalput all constraints of C in SS(cid:10) ← ∅for each cij ∈ C where Q(vi ) = ∀ and Q(vj ) = ∀for each a ∈ D(vi )if a is not supported by all values in D(vj ) return FALSEadd cij to S(cid:10)for each cij ∈ C where Q(vi ) = ∃ and Q(vj ) = ∀for each a ∈ D(vi )if a is not supported by all values in D(vj )remove a from D(vi )if D(vi ) = ∅ return FALSEelse add cij to S(cid:10)S ← S \ S(cid:10)return Propagation(F, S)function Propagation(F, S : stack)input: A QCSP F and a stack of variables Soutput: TRUE if AC is successfully applied on F and FALSE if there a domain wipeoutof an existential or a value is removed from the domain of a universalfor each constrained pair of variables vi , vj ∈ Vfor each a ∈ D(vi )currentSupportvi ,a,vjwhile S (cid:14)= ∅← NILpop a constraint cij from Sif Revise(vi , vj , currentSupport)if Q(vi ) = ∀ or D(vi ) = ∅ return FALSEput each constraint cki in Sreturn TRUEfunction Revise(vi , vj , currentSupport)input: A pair of variables vi ,vj and the data structure currentSupportoutput: TRUE if a value is removed from a domain and FALSE otherwiseDELETION ← FALSEfor each a ∈ D(vi )if currentSupportvi ,a,vj is NIL or is no longer in D(vj )if exists b(∈ D(vj )) > currentSupportvi ,a,vj and b supports acurrentSupportvi ,a,vjelse remove a from D(vi )← bif Q(vi ) = ∀ return TRUEDELETION ← TRUEreturn DELETIONFig. 2. QAC-2001: An arc consistency algorithm for binary QCSPs.is universally quantified or D(vi) becomes empty then we can determine that the problem is false. Otherwise, eachconstraint cki involving vi and some other variable vk is added to the stack so that it can be revised. The algorithmterminates successfully if the stack becomes empty.We now show that, despite the presence of universal quantifiers, the worst-case time complexity of QAC-2001 isthe same as that of AC-2001/3.1. We assume that m is the number of binary constraints in a problem, and d is themaximum domain size.I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771745Proposition 1. The worst-case time complexity of algorithm QAC-2001 is O(md 2).Proof. The worst-case time complexity of the algorithm can be determined by examining the constraint checks exe-cuted in the two for loops in function QAC-2001 and also in function Propagation.In the first for loop we iterate through all constraints cij that involve two universal variables vi and vj . For eachvalue a ∈ D(vi), we check if a is supported by all values in D(vj ) or not. Therefore, each iteration costs O(d 2)constraint checks. Hence, the first for loop costs O(md 2) checks. In the second for loop we iterate through all con-straints cij that involve an existential variable vi and a universal vj . As with the first loop, it is easy to see that the costof the second loop is again O(md 2).Function Revise is called at most d times for each constraint cij ∈ C; once for every deletion of a valuefrom D(vj ). In each call to Revise the algorithm performs at most d checks (one for each value a ∈ D(vi)) tosee if currentSupportvi ,a,vj is still in the domain of D(vj ). If it is not (or it is NIL), the algorithms tries to find anew support for a in D(vj ) starting from the value immediately after currentSupportvi ,a,vj . Since we use structurecurrentSupport, each time Revise is called for cij , and for each value a ∈ D(vi), we only check values that have notbeen checked before. In other words, we can check each of the d values in D(vj ) at most once for each value of vi .So overall, in the worst case, we have d checks plus the d checks to test the validity of the current support. For thed values of vi the upper bound in checks performed to make one variable AC is therefore O(d 2). For m constraintsthe worst-case complexity bound of Propagation is O(md 2). Hence, the worst-case time complexity of QAC-2001 isO(md 2 + md 2 + md 2) = O(md 2). (cid:2)The generalization of AC to non-binary constraints is usually referred to as Generalized Arc Consistency (GAC).Processing a non-binary constraint to achieve GAC according to the definition by Bordeaux et al. [9,11,12] is muchmore challenging than the binary case for several reasons. Firstly, since this level of consistency is a generalizationof GAC for CSP, enforcing it takes exponential time in general, whereas binary quantified arc consistency can beenforced in O(md 2). Secondly, an algorithm that achieves GAC on non-binary QCSPs would be considerably morecomplex than a similar algorithm for GAC in CSP, because (for a constraint with arity k) it should be able to handleup to 2k different quantifier sequences. Thirdly, a support for a value in a non-binary constraint c is no longer simplya tuple that includes that value and is allowed by c, as in the CSP case. Here, we need a more complex definition ofa support that takes into account the quantified variables in the constraint’s scope. Hence we restrict our attention tobinary QCSPs in this paper and leave consistency algorithms for non-binary QCSPs as future work.Finally, compared to the work of [12] on AC, we can note the following differences: We only deal with binaryconstraints whereas the definition of [12] is generic (i.e. it covers GAC). We have defined filtering operators forarbitrary binary constraints, whereas [12] defined filtering operators for specific binary (and ternary) Boolean andnumerical constraints. The AC algorithm of [12] is based on AC3 while ours is based on AC2001/3.1.3.2. Search algorithmsNumerous search algorithms have been developed for CSPs. Most of them are based on backtracking search. Inthis section we adapt chronological backtracking (BT), forward checking (FC) [35] and maintaining arc consistency(MAC) [42] to deal with binary QCSPs. Also, we show that by slightly modifying FC and MAC we get algorithmsthat can discover inconsistencies earlier, and therefore can be more efficient.For any algorithm, we assume that before commencing search the input QCSP has been made AC using algorithmQAC-2001. Under this assumption, we do not have to consider constraints of the form ∃vi∀vj (cij ) or ∀vi∀vj (cij ) inthe algorithms. All values of variable vi , in such constraints, are definitely consistent with all values of variable vj . Ifsome value was not consistent then it would have been removed by the application of QAC-2001. This implies that,during search, we can safely ignore the last variables in V if they are universally quantified. For instance, if a problem∃vi∀vj ∃vk∀vl (cij ∧ cj k ∧ ckl) is AC, then we can remove constraint ckl and ignore variable vl. Hence it suffices toapply search on the simplified problem ∃vi∀vj ∃vk (cij ∧ cj k).3.2.1. Chronological backtrackingBT, depicted in Fig. 3, is a straightforward extension of the corresponding algorithm for standard CSPs. It takes asinput a QCSP F and traverses the space of strategies until the truth of the problem is proved or disproved. To simplify746I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771assign vcur with the next value a ∈ D(vcur)if vcur (cid:8)→ a is compatible with the assignments to all past variableselsevcur ← last_e(vcur)if all values in D(vcur) have been triedBoolean BT(F = (cid:3)V , Q, D, C(cid:4))input: A QCSP Foutput: TRUE if a solution to F exists and FALSE otherwise1: vcur ← v12: while vcur (cid:14)= NILif Q(vcur) = ∃3:4:5:6:7:8:9:10:11:12:13: else //Q(vcur) = ∀//14:15:16:17:18:19: if vcur = NIL return FALSEif vcur is the first universal in V return TRUEelse vcur ← last_u(vcur)if there are no universals in V return TRUEelse vcur ← last_u(vcur)else assign vcur with the next value a ∈ D(vcur)if all values in D(vcur) have been triedelse vcur ← next(vcur)vcur ← next(vcur)if vcur = vnFig. 3. Chronological backtracking for binary QCSPs.the description of the algorithm (and the ones that follow), we assume that variables are assigned values followingtheir order in V . However, consecutive variables with the same quantification can be instantiated in any order. Thevariable that is currently instantiated is called the current variable and is denoted by vcur. The variables in V aftervcur are called future variables, while the ones before vcur are called past variables. A situation where all values of thecurrent variable are deemed inconsistent is called a dead-end. We make use of the following functions:next: For any variable vi , function next(vi) returns the variable immediately after vi in V .last_u: For any variable vi , function last_u(vi) returns the variable vj ∈ V such that vj is universally quan-tified, it precedes vi in V , and there is no universal variable after vj and before vi in V . If vf u is the firstuniversal in V then last_u(vf u) is NIL.last_e: For any variable vi , function last_e(vi) returns the variable vj ∈ V such that vj is existentially quan-tified, it precedes vi in V , and there is no existential variable after vj and before vi in V . If vf e is the firstexistential in V then last_e(vf e) is NIL.BT terminates successfully if all the values of the first universal variable are found to be part of a consistent scenario(line 15). In case there are no universals in the problem, the algorithm terminates successfully once the last existentialhas been consistently instantiated (line 10), as the problem is a standard CSP.If the current variable is existential and a dead-end occurs then the algorithm backtracks to the previously instanti-ated existential variable, possibly jumping over some universal variables (lines 4–5). Detecting a dead-end means thatthe algorithm determines that the currently explored strategy cannot be extended to a solution. Therefore, it backtracksto the previous existential to assign it a new value and explore an alternative strategy. If there is no dead-end, the nextavailable value of the current variable is checked against the previous assignments (line 8). If the value is compatiblewith all assignments to past variables and BT has reached a true leaf node then it backtracks to the previous universalvariable (line 11). If BT is not at a leaf node, it proceeds by moving to the next variable (line 12). In case someconstraint check fails, BT tries the next value of the current variable in the next iteration of the while loop.If the current variable is universal then there are two cases. If all of its values have been proved to be part of aconsistent scenario, BT backtracks to the previous universal variable (lines 14, 16) to assign it its next value. If not allof the current variable’s values have been tried, BT assigns it with its next value and proceeds with the next variable(lines 17, 18). Note that when BT assigns a value to a universal variable it does not check this value against theI.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771747previously made assignments. The reason is that, due to AC preprocessing, all values of a universal variable vi aredefinitely consistent with all values of the variables before vi in V .Correctness of BT We now demonstrate, informally, the correctness of BT. To show soundness, we need to demon-strate that whenever BT returns true after traversing a strategy, this strategy is indeed consistent. Or, in other words,that all the scenarios in the strategy are consistent. Take any scenario in the strategy and consider any tuple of as-signments τ = (cid:3)v1 (cid:8)→ a1, . . . , vi (cid:8)→ ai(cid:4) along this scenario. BT extends this tuple to variable vi+1 by assigning it avalue ai+1 only if ai+1 is consistent with all assignments in τ . Therefore, when a tuple (cid:3)v1 (cid:8)→ a1, . . . , vi (cid:8)→ an−1(cid:4) isextended to an n-tuple, all assignments in the tuple will be consistent with each other. This means that the tuple is aconsistent scenario.To show completeness, we need to demonstrate that if a consistent strategy exists, BT will correctly verify itby returning true once it has traversed it. It suffices to show that BT traverses the entire search space apart fromsome sub-spaces that are not part of any consistent strategy. BT systematically explores the search space trying toverify that for any sequence of assignments to the universals we can find a consistent scenario that includes theseassignments. Search sub-spaces are skipped 1) when a value of the current variable fails a constraint check with anassignment of a past variable, and 2) when there is a backtrack to an existential. In the first case, let τ = (cid:3)v1 (cid:8)→a1, . . . , vi−1 (cid:8)→ ai−1(cid:4) be the current tuple of assignments and assume that value ai of the current variable vi fails aconstraint check with an assignment in τ . Tuple τ cannot be extended to a consistent scenario and hence ai (and thesub-tree below the corresponding node) is correctly pruned. A backtrack to an existential vi assigned value ai meansthat the currently explored strategy cannot be extended to a consistent strategy and therefore ai (and the sub-tree belowthe corresponding node) is correctly pruned.3.2.2. Forward checking and MACMany ways to improve the performance of BT have been proposed in the CSP literature. Most of them are classifiedas either look-ahead or look-back methods. The former try to detect inconsistencies early by performing some amountof local reasoning after each variable instantiation. The latter try to deal with a dead-end in an intelligent way byidentifying the variables that are responsible for the dead-and directly backtracking to one of these variables. Wenow show how the most commonly used look-ahead algorithms, FC and MAC, can be adapted to QCSPs. Look-backmethods for QCSPs are discussed in Section 5.The algorithm FC0, shown in Fig. 4, is an extension of standard FC to QCSPs. It operates in a way similar to BTwith the difference that, as in standard CSPs, constraint checks are made against future instead of past variables. Tobe precise, once a variable assignment to an existential or universal is made, it is checked against values of futureexistentials using function Forward_Check0 (lines 9 and 25). In this function any value that is not compatible with thecurrent assignment is temporarily removed from the domain of the corresponding variable. As mentioned, constraintsof the form ∃ vi∀ vj (cij ) or ∀ vi∀ vj (cij ) have already been handled by preprocessing. Therefore, no checks againstuniversals are performed. If all the values are removed from the domain of a variable (domain wipe-out) then thecurrent assignment is rejected. In this case, if vcur is an existential, procedure Restore is called to undo any changesmade in the domains of the variables (line 16). Then the algorithm will try the next value of vcur in the next iterationof the while loop. If vcur is a universal, the algorithm will backtrack to the previous existential last_e(vcur) in V (line29). Before backtracking, all values that were temporarily removed because of the assignments to variables betweenlast_e(vcur) and vcur are restored in their domains using procedure Restore (line 28).Note that Restore must be called whenever a backtrack occurs. That is, apart from the case described above,restoration of values to domains is required when a dead-end is encountered (line 5), when a true leaf node is reached(line 13), and when all the assignments to a universal have been proved to be part of a consistent scenario (line 21).By slightly modifying the forward checking function of FC0 we get an algorithm, which we call FC1, that candiscover inconsistencies earlier than FC0. Algorithm FC1 has exactly the same behavior as FC0 when the currentvariable is existentially quantified. If the current variable vcur is universally quantified then we first check every valueof vcur against all future variables before assigning a specific value to it. This is done using Function Forward_Check1,depicted in Fig. 5. If one of vcur’s values causes a domain wipe-out then we backtrack to the last existential variable.Otherwise, we proceed in the usual way by instantiating vcur with its next available value a and removing all valuesof future variables that are incompatible with the assignment vcur (cid:8)→ a. In this way we can discover dead-ends earlierand avoid fruitless exploration of search tree branches.748I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771elseif vcur = vnif all values in D(vcur) have been triedRestore(F, vcur,last_e(vcur))vcur ← last_e(vcur)if there are no universals in V return TRUEelseassign vcur with the next value a ∈ D(vcur)if Forward_Check0(F, vcur, a)Boolean FC0(F = (cid:3)V , Q, D, C(cid:4))input: A QCSP Foutput: TRUE if a solution to F exists and FALSE otherwise1: vcur ← v12: while vcur (cid:14)= NILif Q(vcur) = ∃3:4:5:6:7:8:9:10:11:12:13:14:15:16:17: else //Q(vcur) = ∀//18:19:20:21:22:23:24:25:26:27:28:29:30: if vcur = NIL return FALSERestore(F, vcur,last_u(vcur))vcur ← last_u(vcur)else vcur ← next(vcur)else Restore(F, vcur, vcur)assign vcur with the next value a ∈ D(vcur)if Forward_Check0(F, vcur, a)if vcur is the first universal in V return TRUEelseRestore(F, vcur,last_u(vcur))vcur ← last_u(vcur)Restore(F, vcur,last_e(vcur))vcur ← last_e(vcur)if all values in D(vcur) have been triedvcur ← next(vcur)elseelsefunction Forward_Check0(F, vcur, a)input: A QCSP F , the current variable vcur and its assigned value aoutput: TRUE if no domain is wiped out and FALSE otherwise1: for each existential vi after vcur in V2:3:4:5:6: return TRUEif vi (cid:8)→ b is incompatible with vcur (cid:8)→ atemporarily remove b from D(vi )if D(vi ) is wiped out return FALSEfor each b ∈ D(vi )procedure Restore(F, vcur, vback)input: A QCSP F , the current variable vcur and the variable where the algorithm will backtrack vbackoutput: -1: for vi = vback to vcur2:3:restore to D(vj ) any value that was removed because of vi ’s instantiationfor each existential vj after vi in VFig. 4. FC0: Forward checking for binary QCSPs.Note that the look-ahead of FC1 need only be applied once when the algorithm reaches a universal at some branchof the search tree. That is, immediately before trying the first available assignment of the universal. Assuming thatnone of the universal’s possible assignments causes a domain wipe-out, then applying the FC1 type of look-aheadI.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771749function Forward_Check1(F, vcur)input: A QCSP F and the current variable vcuroutput: FALSE if some value of vcur is incompatible with all values of an existential, andTRUE otherwise1: for each a ∈ D(vcur)2:3:4: return TRUEif vcur (cid:8)→ a is incompatible with all values in D(vi ) return FALSEfor each existential vi after vcur in VFig. 5. Forward checking function of algorithm FC1.again after a backtrack to the universal occurs is redundant. This is obvious since the restoration of values guaranteesthat the result will be the same as before, i.e. none of the remaining possible assignments for the universal will causea domain wipe-out.It is easy to see that FC1 will always visit at most the same number of search tree nodes as FC0 as it may discoveran inconsistency earlier than FC0 but never later. The two algorithms are incomparable in the number of constraintchecks they perform. That is, depending on the problem, FC0 may perform less checks than FC1 and vice versa.Correctness of FC The correctness of FC can be informally demonstrated following similar arguments as in thecase of BT. In addition, we need to show that the forward checking functions of FC0 and FC1 are correct. That is,they prune parts of the search space that do not belong to a consistent strategy. Function Forward_Check0 is calledafter assigning an existential or universal variable vi with a value ai . Assume that the current tuple of assignments isτ = (cid:3)v1 (cid:8)→ a1, . . . , vi (cid:8)→ ai(cid:4). Forward_Check0 will prune any value from the domain of a future existential that failsa constraint check with assignment vi (cid:8)→ ai . This means that any such value is not consistent with τ and therefore τcannot be extended to a consistent scenario that includes this value. Hence, it is correctly pruned. Forward_Check1is called before assigning a universal variable vi and for each value ai ∈ D(vi) it temporarily prunes any value fromthe domain of a future existential that fails a constraint check with ai . If the domain of a future existential vj is wipedout then the algorithm backtracks. Assume that the assignment vi (cid:8)→ ai causes the wipeout of D(vj ). This means thatno value of vj can participate in a consistent scenario of the currently explored strategy that includes the assignmentvi (cid:8)→ ai . Therefore, no consistent scenario that includes vi (cid:8)→ ai exists in the current strategy and, hence, the algorithmcorrectly backtracks to try an alternative strategy.Maintaining arc consistency Based on the above description of FC, we can easily adapt the MAC algorithm toQCSPs. MAC is the most widely used complete search algorithm for CSPs. It reduces the domains of future variablesduring search by applying an AC algorithm on the problem after each variable instantiation. In this way inconsistenciesare discovered early and search effort is saved.To implement MAC for QCSPs we need a simple modification in the pseudo-code of FC0. We need to replace thecalls to Forward_Check0 in lines 9 and 25 of Fig. 4 with calls to function Propagation of QAC-2001. In this casethe stack of constraints would have to be initialized by adding to it only constraints that involve the current variable.MAC can also be modified in the same way as FC to yield MAC1, an algorithm analogous to FC1. That is, when thecurrent variable vcur is universally quantified we can (temporarily) enforce AC for each instantiation vcur (cid:8)→ a, wherea ∈ D(vcur), before committing to a particular instantiation. If one of the instantiations causes a domain wipe-out thenwe backtrack. Otherwise, we commit to one of the values and proceed with the next variable.3.3. Symmetry breakingMany CSPs contain symmetries which means that for a given solution there are equivalent solutions. This can havea profound effect on the search cost when looking for one or (even more) all solutions to a CSP. Various methods forsymmetry breaking have been proposed. Most of these methods add symmetry breaking constraints to the problemeither statically, before search, or dynamically during search. A survey of work on symmetry in standard CSPs hasrecently been published, giving extensive references to the large body of work in that area [30].QCSPs, in particular, can greatly benefit from symmetry breaking techniques, since we have to check if thereexists a consistent scenario for all values of all universally quantified variables. We propose the exploitation of value750I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771interchangeability as a static and dynamic symmetry breaking technique in QCSPs. However, we consider only asimple type of symmetry in this paper, leaving until future work extension of more powerful techniques devised forconstraint satisfaction. Some advanced concepts, like value substitutability, that can be used for symmetry breakingin QCSPs have been defined (though not implemented) in [11].The notion of interchangeable values in CSPs was defined by Freuder in [24]. A value a of a variable vi is fullyinterchangeable with a value b of vi , iff every solution which contains the assignment vi (cid:8)→ a remains a solution ifwe substitute b for a, and vice versa. Since determining full interchangeability is coNP-complete [10], Freuder alsodefined various local interchangeabilities that are polynomially computable.Definition 4. Given a variable vi ∈ V , a value a ∈ D(vi) is neighborhood interchangeable (NI) with a value b ∈ D(vi),iff for each vj ∈ V , such that vj is constrained with vi , a and b are supported by exactly the same values in D(vj ).Neighborhood interchangeability is a sufficient (but not necessary) condition for full interchangeability [24]. A setof NI values can be replaced by a single representative of the set without losing any solutions. Experiments showedthat this can reduce the search effort in standard CSPs when applied as a preprocessing step or during search, andespecially when looking for all solutions to a problem [2,36]. In what follows we will often refer to NI values simplyas interchangeable.In the context of QCSPs we can exploit interchangeability to break symmetries by pruning the domains of universalvariables. That is, for each set (sometimes called bundle) of NI values we can keep one representative and remove theothers, either permanently before search, or temporarily during search. If the algorithm finds a consistent scenario forthe representative value then surely there exists one for the rest of the NI values as well. Therefore, branching on thesevalues is redundant. Consider the following example.Example 3. We have the QCSP ∀v1∃v2∃v3 (v1 (cid:14)= v2 ∧ v1 (cid:14)= v3), where the domains of the variables are D(v1) ={0, 1, 2, 3, 4}, D(v2) = {0, 1}, D(v3) = {0, 2}. Values 3 and 4 of v1 are NI since they are supported by the same valuesin both v2 and v3. Therefore, they can be replaced by a single value or, to put it differently, one of them can be prunedout of the domain.The cost of computing all neighborhood interchangeable values in a CSP, using the algorithm of [24], is O(d 2n2).In QCSPs we can detect NI values as a preprocessing step and thus remove values from the domains of universalvariables, and we can also detect them dynamically during search to avoid repeated exploration of similar subtrees.Example 4. Assume that variables ∀vi∃vj ∃vk∃vl are part of a QCSP and their domains are D(vi) = {a1, a2}, D(vj ) =D(vk) = D(vl) = {a3, a4, a5, a6}. Also, the QCSP includes constraints cij , cik, cil. Assume that value a1 is supportedby values a3, a4, a5 in each of vj , vk and vl, and a2 is supported by a3, a4, a6. If the current variable at some stage ofsearch is vi and values a5 and a6 have been previously removed from the domains of vj , vk and vl then at that stagea1 and a2 are NI. We can proceed to search for a consistent scenario that includes assignment vi (cid:8)→ a1. If one is foundthen when we backtrack to universal variable vi we do not need to perform a similar search for assignment vi (cid:8)→ a2.If we backtrack further back and undo the deletions of values a5, a6 from the domains of vj , vk and vl then the nexttime we reach variable vi the values a1 and a2 may not be NI.Naturally, we can also use NI to reduce the domains of existential variables as proposed by Freuder. However, ourexperiments showed that this is an overhead that slows down the algorithms. The (small) reduction in the number ofsearch tree node visits is outweighed by the cost of computing the NI values of existentials.NI-based symmetry breaking can be embedded in the search algorithms described previously using two simpleprocedures. The first one detects bundles of NI values as a preprocessing step, keeps one representative of each bundleand removes the rest from the domains of universals. To check if two values a, b of a universal variable vi are NI,this procedure iterates through the domain of any existential variable vj ∈ V that is constrained with vi and is aftervi in V . If a value is found that is a support for a but not for b, or vice versa, then a and b are not NI. Otherwise,they are NI, so one of them is removed. This is repeated for all pairs of values of vi . In a similar way, the secondprocedure dynamically detects bundles of NI values each time the algorithm reaches a universal variable vi . In thiscase, one representative of each bundle is kept, and the rest of the values are temporarily removed from D(vi). TheI.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771751values are restored when the algorithm backtracks to a variable before vi in V . The worst-case time complexity ofthese symmetry detecting procedures, as they are currently implemented, is O(d 3n2).4. Encoding QCSP as QBFIn this section we first give some general background on QBFs. Then we briefly elaborate on the difficulties inencoding QCSP into QBF and describe the features of the QBF solver we used in our experiments. In the main partof the section we present the previous best encoding of QCSP into QBF (the adapted log encoding), and we introducea new encoding which improves on it, both in simplicity and performance.4.1. Quantified Boolean FormulaeA special case of a QCSP is a Quantified Boolean Formula (QBF). A QBF is of the form (cid:3)V , Q, D, C(cid:4) where Vand Q are defined as in Definition 1, but each domain in D has only two elements {F, T } (or {0, 1}). C is a Booleanformula in conjunctive normal form (CNF), a conjunction of clauses where each clause is a disjunction of literals. Eachliteral is a variable and a sign. A literal is said to be negative if negated and positive otherwise. A universal literalis a literal whose variable is universally quantified and an existential literal is a literal whose variable is existentiallyquantified. The semantic definition is the same as for QCSPs. Note that 2-QBF (i.e. QBF problems with at most twoliterals per clause) is solvable in polynomial time. However, binary QCSPs are PSPACE-complete [8].A QBF is vacuously true if it consists of an empty set of clauses. It is vacuously false if the set of clauses containseither an empty clause (i.e. a clause with no literals) or an all universal clause (i.e. a clause with only universal literals).4.2. The difficulty in encoding QCSP to QBFGent, Nightingale and Rowley introduced a number of different ways to encode a QCSP instance into QBF [27].To encode an existential QCSP variable to a set of QBF variables, some assignments to the QBF variables representvalues of the original variable, and other assignments are ruled out by adding clauses to the formula. For example, if anassignment to the QBF variables indicates that the original QCSP variable has no values in its domain, the assignmentis invalid and is ruled out with a clause. However this approach is not possible for a universal QCSP variable.To see why, consider the following example. In QBF instance φ, we have two universal variables xi and xj .φ represents an adversarial game, and the assignment xi = T , xj = T represents a cheating move in the game.Naively we might use a clause (¬xi ∨ ¬xj ) to rule out this assignment. Unfortunately, such a clause is trivially false,and therefore would render φ false.The encodings introduced in [27] were able to overcome this difficulty. However, the global acceptability encod-ing and the local acceptability encoding were very inefficient compared to direct QCSP algorithms. In contrast, theadapted log encoding, which we describe below, turned out to be very efficient.4.3. QBF solverMany advanced solvers for QBF have been proposed in the literature [3,7,22,32,34,37]. We concentrate on search-based solvers, which interleave search (by instantiating variables individually, in quantifier order) with reasoning onthe formula (local reasoning). They are based on the Davis–Putnam–Logemann–Loveland algorithm [19,20], adaptedto QBF [14]. Local reasoning cuts down the search space. Also, in certain situations, backjumping is applied whichallows the solver to jump several levels up the search tree (undoing several search operations at once), by identifyingthe cause of a success or failure.We give a brief overview of some of the literature to set the encodings in context. We use the solver CSBJ [37],which implements the following two local reasoning techniques. We only sketch each technique in the broadest wayand refer the reader elsewhere for full details.Unit propagation A literal l of variable x is unit if it appears alone in a clause, or if the other literals in the clauseare universal, and their corresponding variables are quantified after x [14]. When l is unit, it is instantiated752I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771(l = T ) and the formula is simplified. If x is universal, the formula simplifies to false. Otherwise, clausescontaining l are removed, and all literals ¬l are removed. This may cause other literals to become unit.The pure literal rule A literal l is called pure (or monotone) if its complementary literal does not appear in any clause[14]. Such literals are important because they can immediately be assigned a value without any need forbranching. This is what the pure literal rule does. If an existential pure literal l is found, it is set to true.If a false leaf node is then reached, assigning l to false will be unnecessary since it is certain that this willagain lead to a false leaf node. If a universal pure literal l is found, it is set to false. If a true leaf node is thenreached, assigning l to true will be unnecessary since it is certain that this will again lead to a true leaf node.As we mentioned, local reasoning and search is commonly augmented with backjumping. CSBJ implements con-flict and solution backjumping. We informally describe these two techniques. This is only intended to give a flavor ofthe techniques.Conflict-based backjumping Conflict-based backjumping (CBJ) is a look-back technique, originally proposed forCSPs, that tries to reduce the number of backtracks performed by a search algorithm [39]. CBJ tries todeal with dead-ends in an intelligent way by recording and exploiting conflict sets. A conflict set is a set ofexistential literals whose assignments are responsible for a contradiction in the formula, i.e. an empty or alluniversal clause. When a contradiction is encountered, CBJ backjumps to one of the existential literals in theconflict set of the current variable, instead of blindly backtracking to the last assigned existential. In this way,search effort can be saved.Solution-directed backjumping Solution-directed backjumping (SBJ) is a specialized technique for QBF that tries toavoid redundant search after a true leaf node is reached in the search tree [32]. This is accomplished byrecording and exploiting solution sets. A solution set is a set of universals such that all clauses not satisfiedby the current assignment of the existentials are satisfied by at least one of the universals. After a true leafnode is reached, a solution set is calculated and SBJ backjumps to one of the variables in the set, possiblyjumping over some universals.Efficient implementation is crucial in the SAT domain, and various techniques have been carried across into thesolver we used. For example, watched literals give us efficient lazy unit propagation, and watched clauses do the samefor the pure literal rule [37].4.4. Adapted log encodingThis section describes a previous contribution, the adapted log encoding (by Gent, Nightingale and Rowley [27]).It is described here in order to set the enhanced log encoding (in the following section) in context. We briefly explainthe main groups of clauses in the encoding. For full technical details we refer the reader to Gent et al. [27].In order to deal with the difficulty described above, the adapted log encoding uses indicator variables (first describedby Rowley [31]) to indicate when a universal assignment is not valid. An indicator variable takes value T iff aparticular (invalid) assignment is made to universal variables. There is one indicator variable zv for each of the originaluniversal QCSP variables v. zv is existentially quantified in a final block at the end of the variable sequence. All clausesrepresenting constraints contain a literal zv. Hence, they are true under any assignment setting zv to true. In this way,if an invalid assignment is made to universal variables, the formula simplifies to true by unit propagation, as requiredto deal with the difficulty.In SAT, it has often been noted that just three variables are needed to encode 8 values of a CSP variable, insteadof the 8 in the direct encoding [25,45]. This is known as the log encoding. Walsh proves that unit propagation on thelog encoding does less work than on the direct encoding [45], and hence it is rarely used. However we adapt the logencoding for QCSP with good results.Each variable in a QCSP is encoded to a set of variables in QBF, with these sets quantified in the same way andin the same order as in the QCSP. Additional existential variables are added to the end of the variable sequence. Foran existential variable, each QBF variable represents one value. For a universal, each value is represented by a uniqueassignment to the QBF variables, and also each value is represented by an existential QBF variable quantified at theI.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771753end. There are clauses which maintain correspondence between these two representations, named channelling clauseshere.We now describe the encoding in more detail. We first show how the QCSP variables are encoded and then presentthe clauses of the encoding. The notation wu∗ is used for the set of w variables with superscript u and any subscript.The ∗ is used in the same way with xu∗ and iu∗ .• QuantificationTo encode some existential variable v ∈ {1 . . . d}:– We use existential variables ∃xvTo encode some universal variable u ∈ {1 . . . d}:– We use universal variables ∀wu– We also use existential variables representing each value: ∃xu1 , . . . , ∃xud– Finally, We use indicator variables for each invalid assignment to wu(cid:18)log2d(cid:19)−1, . . . , ∀wu1 , . . . , ∃xvd0∃iu∗ , ∃zu∗ , and one overall indicator variable:For some universal variable v, the following clauses map assignments of wv∗ . These channelling clausesensure that at least one of the xv∗ is only set to T whenthe wv∗ variables take the corresponding invalid assignment. Variable u is the universal that directly precedes v in theQCSP variable order. The indicator variable zu is T only when u or a previous universal has an invalid assignment: itis used to make the channelling clauses true in this situation.∗ variables is set to T , and that an indicator variable in iv∗ and iv∗ or iv∗ to xvThe clauses are given as an example for d = 5, but the general form is easy to infer from the example.• Channelling clauseszu ∨zu ∨zu ∨zu ∨zu ∨zu ∨zu ∨zu ∨(cid:3)(cid:3)(cid:2)∧ ¬wv∧ ¬wv(¬wv12(cid:2)∧ wv∧ ¬wv(¬wv12(cid:2)∧ ¬wv∧ wv(¬wv12(cid:2)∧ wv∧ wv(¬wv12(cid:2)∧ ¬wv∧ ¬wv(wv12(cid:2)∧ ¬wv(wv∧ wv12(cid:2)∧ ¬wv∧ wv(wv12(cid:2)∧ wv∧ wv(wv120 ) ⇒ xv1(cid:3)0 ) ⇒ xv20) ⇒ xv3(cid:3)0 ) ⇒ xv40) ⇒ xv50 ) ⇐⇒ iv60 ) ⇐⇒ iv7(cid:3)0 ) ⇐⇒ iv8(cid:3)(cid:3)(cid:3)These eight expressions correspond to all possible assignments to {wv}, from (cid:3)F, F, F (cid:4) for the first ex-pression, to (cid:3)T , T , T (cid:4) for the last. Each assignment is linked either to an xv variable if it is valid, or an iv variableotherwise. The expressions are expanded into clauses in the encoding.2 , wv1, wv0The variables iva single indicator variable zv which is T iff at least one of ivis T .∗ indicate when the assignment is invalid in a particular way. These variables are accumulated into∗ is T , or the previous accumulated indicator variable zu• Indicator collector clauseszv ⇐⇒ iv6∨ iv7∨ iv8∨ zuNote that if zv is set to T , this assignment will be propagated to the next indicator collector clause and thus willmake the next accumulated indicator variable T . This assignment will be propagated further, and so on.For each existential variable v, at least one of the QBF variables xv∗ must be set to true to ensure that v is assigneda value. This is accomplished with an at-least-one (ALO) clause.754I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771• ALO clause(cid:4)xvii∈1...dConstraints are represented as follows. Consider a constraint cuv between variables u and v, where u precedes vin the variable order. A pair of values (cid:3)i, j (cid:4), where i ∈ D(u) and j ∈ D(v), that do not satisfy the constraint (i.e. theydo not belong to rel(cuv)) is represented with a single clause in the QBF. Assume variable t is universally quantifiedand directly precedes v in the variable order. Note that t may be the same as u. The indicator variable zt for t is used,so that if a preceding universal variable is set in an invalid way, the conflict clause is satisfied. (When a universal isset invalidly, the remaining part of the QBF must be true). Given this, conflict clauses only contain indicator variablesand negative literals.• Conflict clauses∀(cid:3)i, j (cid:4) /∈ rel(cuv) :zt ∨ ¬xui∨ ¬xviFor channelling and conflict clauses, if there is no preceding universal variable in the QCSP, the indicator variableis omitted. To illustrate the encoding, we give an example of a simple QCSP.Example 5. Consider the QCSP ∀v∃u : v (cid:14)= u where D(v) = D(u) = {1, . . . , 5}. This is encoded as follows:• QBF variables:1 , xv2 , wv• Channelling clauses for v:0 , ∃xv1 , wv∀wv2 , xv3 , xv4 , xv5 , ∃xu1 , xu2 , xu3 , xu4 , xu5 , ∃zv, iv6 , iv7 , iv80) ⇒ xv∧ ¬wv∧ ¬wv(¬wv1120 ) ⇒ xv∧ ¬wv∧ wv(¬wv2120 ) ⇒ xv∧ ¬wv∧ wv(¬wv3120 ) ⇒ xv∧ wv∧ wv(¬wv4120 ) ⇒ xv∧ ¬wv∧ ¬wv(wv5120 ) ⇐⇒ iv∧ wv∧ ¬wv(wv6120) ⇐⇒ iv∧ ¬wv∧ wv(wv7120) ⇐⇒ iv∧ wv∧ wv(wv812• Indicator collector clauses for v:∨ iv7∨ ivzv ⇐⇒ iv86• At-least-one clause for u:∨ xu∨ xu42∨ xu3• Conflict clauses representing v (cid:14)= u:∨ xu5xu1zv ∨ ¬xv1zv ∨ ¬xv2zv ∨ ¬xv3zv ∨ ¬xv4zv ∨ ¬xv5∨ ¬xu1∨ ¬xu2∨ ¬xu3∨ ¬xu4∨ ¬xu5I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771755The subtlety of this encoding is that we omit the clauses which force equivalence between xvb : the implication is one way in the channelling clauses involving xv2 . It might seem that this is erroneous, as it allows a universal to take two values, if xva and the correspondinga . So we omit clauses such as zu ∨values of wv∨ ¬wv¬xv1 and xv2 are both true.1But there is no way that setting of the universal variables wva to be true. The advantage ofthis arrangement is that xv∗ variables occur only positively in the channelling clauses. Therefore if a particular variablev did not occur in any conflict clause, it would be pure. Furthermore, this could lead to wvx1∗ variables becoming pure,reducing the need for search. So, with sufficient care, we can use the pure literal rule included in our QBF solver, andhave it work in the QCSP case. This property carries over to the enhanced log encoding, described below.∗ can force more than one xv4.5. Enhanced log encodingThe enhanced log encoding is a refinement of adapted log which has not been previously published. Each universal∗ which are consecutively universally quantified. The order of variables isd variables for each universal QCSP variable v, which are existentially quantified∗ variables are channelledvariable v is encoded by (cid:18)log2d(cid:19) variables wvpreserved. We also introduce xvat the end of the variable sequence. These xvto the xv∗ variables with a set of d clauses. For the following example d = 5.∗ variables are used in the conflict clauses. The wv1 . . . xv• Channelling clauses0) ⇒ xv10 ) ⇒ xv2∧ ¬wv∧ ¬wv(¬wv12∧ ¬wv∧ wv(¬wv121 ) ⇒ xv∧ wv(¬wv321 ) ⇒ xv∧ ¬wv(wv421 ) ⇒ xv∧ wv(wv52There are 8 possible assignments to the wv∗ variables, and 5 values, so for the values 3, 4 and 5 there are two wv∗assignments mapped onto each, hence all 8 assignments are valid. In contrast to adapted log, no local acceptabilityvariable (zv in the previous subsection) is present, because no assignments to previous universal variables can beinvalid.To state this formally, we represent a QBF with the tuple F (cid:10) = (cid:3)Q(cid:10), V (cid:10), C(cid:10)(cid:4) where Q(cid:10) is the quantifier mapping, V (cid:10)is the ordered set of Boolean variables and C(cid:10) is the set of disjunctive clauses, to mirror the QCSP F = (cid:3)Q, V , D, C(cid:4).Domains are excluded as they are always {0, 1}.The ordered set of variables V for the QCSP is encoded by an ordered set of Boolean variables as shown by thefollowing recursive rules where translate(V ) = V (cid:10).translate(∃v ∈ {1 . . . d}, V1) = ∃xvtranslate(∀v ∈ {1 . . . d}, V2) = ∀wv1 . . . ∃xv(cid:18)log2d(cid:19)−1 . . . ∀wvAn existential variable v in the QCSP instance is mapped to d existential variables (xv0 , translate(V2), ∃xvd , translate(V1)1 . . . ∃xvd1 . . . xvd ) in the encoding.(cid:5)i∈1...d xvi ).These represent each value in the domain. The enhanced log encoding also has the at-least-one clause (In this respect, the enhanced log encoding is identical to the adapted log.A universal variable v in the QCSP is mapped to l = (cid:18)log2d(cid:19) variables wv∗. Every complete assignment A to∗ (of which there are 2l) is mapped to a value b ∈ D(v). All values b map to one assignment, or twovariables wvassignments with only one literal different. It is never necessary to have a value b mapping to more than two as-signments, whatever the value of d. 2l − d values must map to two assignments. An assignment A is represented asa conjunction of literals (e.g. wv1 ). For some value b which maps to just one assignment A, the channelling0clause is as follows.¬A ∨ xvb∧ ¬wvThe negated conjunction ¬A is converted to a disjunction in the usual way. For some other value c which maps to twoassignments A1 and A2, the channelling clause is given below.¬(A1 ∨ A2) ∨ xvc756I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771The simplification of ¬(A1 ∨ A2) ends with a disjunction of l − 1 literals.For a constraint cij , with satisfying tuples rel(cij ) the conflict clauses are:• Conflict clauses For all tuples (cid:3)a, b(cid:4) /∈ rel(cij ),(¬xvia∨ ¬xvjb )To illustrate the encoding, we encode the QCSP of Example 5.Example 6. We have the QCSP ∀v∃u: v (cid:14)= u where D(v) = D(u) = {1, . . . , 5}. This is encoded as follows:• QBF variables:1 , xv2 , wv• Channelling clauses for v:0 , ∃xv1 , wv∀wv2 , xv3 , xv4 , xv5 , ∃xu1 , xu2 , xu3 , xu4 , xu50) ⇒ xv10 ) ⇒ xv2∧ ¬wv∧ ¬wv(¬wv12∧ wv∧ ¬wv(¬wv121 ) ⇒ xv∧ wv(¬wv321 ) ⇒ xv∧ ¬wv(wv421 ) ⇒ xv∧ wv(wv52• At-least-one clause for u:xu1∨ xu2∨ xu3∨ xu4∨ xu5• Conflict clauses representing v (cid:14)= u:¬xv1¬xv2¬xv3¬xv4¬xv5∨ ¬xu1∨ ¬xu2∨ ¬xu3∨ ¬xu4∨ ¬xu5Theorem 1. A QCSP is true if and only if the encoded QBF is true, for the enhanced log encoding.Proof. The proof is recursive and closely follows the definition of QCSP semantics (definition 2). A QCSP F =(cid:3)V , Q, D, C(cid:4) represents the logical formula φ = Q(v1)v1 ∈ D(v1) . . . Q(vn)vn ∈ D(vn) (C) which is encoded as aQBF F (cid:10) = (cid:3)V (cid:10), Q(cid:10), C(cid:10)(cid:4) representing φ(cid:10) = Q(cid:10)(x1)x1 . . . Q(cid:10)(xn)xn (C(cid:10)). The encoding of the empty QCSP (containingno variables or constraints) is the empty QBF which is vacuously true.Existential case:• Assume φ is of the form ∃v1Q(v2) . . . (C) (domains are omitted for simplicity).• Now φ(cid:10) must be of the form ∃xv1d translate(Q(v2) . . .)(C(cid:10)).• By Definition 2, F is true iff there exists some value a ∈ D(v1) such that Q(v2) . . . Q(vn)(C[v1 (cid:8)→ a]) is true.• Equivalently, in the encoding F (cid:10) is true iff there exists an assignment A = xv11(cid:8)→ b1 . . . xv1d1 . . . ∃xv1(cid:8)→ bd such that theALO clause is true and translate(Q(v2) . . .)(C(cid:10)[A]) is true.The QCSP value a can be any value such that xv1can be extended to a solution.a (cid:8)→ 1. If there is more than one a s.t. xv1a (cid:8)→ 1, then all these valuesI.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771757Universal case:• Assume φ is of the form ∀v1Q(v2) . . . (C).• Now φ(cid:10) must be of the form ∀wv1. . . ∀wv1l• By Definition 2, F is true iff for all values a ∈ D(v1) : Q(v2) . . . (C[v1 (cid:8)→ a]) is true.• Equivalently, in the encoding F (cid:10) is true iff for all assignments A = wv1(cid:8)→ bl . . . wv1l00 translate(Q(v2) . . .)(C(cid:10)) where l = (cid:18)log2d(cid:19) − 1.(C(cid:10)[A]) is true.(cid:8)→ b0 : translate(Q(v2) . . .)Note that each value a is covered by some assignment A. If the assignment A is made, the additional xv1introduced by the encoding must be 1 because of the channelling clauses. Other variables xv1the channelling clauses, and therefore can be set to 0 if they are contained in any conflict clause.a variableb(cid:14)=a are not constrained byTherefore, by examination of Definition 2, the encoding is true iff the original QCSP is true, because each step ofthe recursion of Definition 2 can be performed equivalently in the QCSP and in the encoding. (cid:2)The problem with this encoding is that the QBF solver can search two equivalent subtrees in some cases, forexample when wv2After setting wv(cid:8)→ T and wv12 and wv(cid:8)→ T , the solver can branch on wv0 which is not contained in any clause.0 and ¬wv0 does not exist. Both wv1 , if either is set to T then the first two clauses above are satisfied and in the reduced setof clauses wv0 are pure, so if the solver implements the pure literal rule then it willnot branch on this variable. This solves the repeated subtree problem mentioned above, on the condition that wv0 is setlast. Also, in common with the adapted log encoding, the channelling works only from wv to xv variables, so onlypositive xv literals are included in the clause set above, therefore the pure literal rule can detect cases where the xva isinvolved in no conflicts. In some circumstances, this can also lead to the elimination of wv variables. For example, if4 and xvxv2 becomes pure as well and the search is reduced accordingly.5 become pure, then wv5. QCSP-Solve: A direct solver for QCSPsThe efficiency of the adapted and enhanced log encodings is largely due to their ability to exploit sophisticatedtechniques offered by the underlying QBF solver; namely, the pure literal rule, conflict-based backjumping, andsolution-directed backjumping. Two questions that immediately arise are: what do these techniques correspond toin QCSPs, and how can we implement them within direct algorithms? In this section we try to answer these questionsand describe the resulting efficient direct solver, which we call QCSP-Solve.QCSP-Solve performs a backtracking search, as described in Section 3, augmented with various capabilities. Firstof all, QCSP-Solve always applies algorithm QAC-2001 as a preprocessing step. As explained in Section 3.1, apartfrom reducing the problem size by deleting values from the domains of existentials, QAC-2001 removes from theproblem all constraints of the form ∃ vi∀ vj (cij ) and ∀ vi∀ vj (cij ). During search, QCSP-Solve can apply any of thebasic forms of look-ahead described in Section 3, i.e. FC0, MAC0, and their enhancements FC1 and MAC1. In whatfollows we will describe how new look-ahead and look-back techniques are combined with an FC-based look-ahead.Most of these techniques can be combined with a MAC-based look-ahead in a very similar way.5.1. The pure value ruleOur experiments showed that the most important QBF technique, in terms of its practical effectiveness in theencoded QCSPs, is the pure literal rule. We now explain what this corresponds to in a binary QCSP, and how we canexploit it to prune the search space. We first define the notion of a pure value.Definition 5. A value a ∈ D(vi) in a QCSP F = (cid:3)V , Q, D, C(cid:4) is pure iff for each vj ∈ V , where vj (cid:14)= vi and for eachb ∈ D(vj ), the assignments vi (cid:8)→ a and vj (cid:8)→ b are compatible [28].Bordeaux et al. introduced the notion of a fixable value in a CSP [10]. In few words, a value a of a variable vis fixable if for any solution which includes the assignment of a value b to v, we still have a solution if v (cid:8)→ b issubstituted with v (cid:8)→ a. As noted in [10], a sufficient (but not necessary) condition for determining the fixability of avalue can be computed through local reasoning in polynomial time. This is similar to the pure literal rule in SAT. The758I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771same authors defined the notion of fixability for QCSPs [11]. Following the terminology of [11], if a value is pure thisis a sufficient but not necessary condition for the value to be d-fixable.In a way analogous to the pure literal rule in QBF, we have devised and implemented a look-ahead technique,which we call the pure value (PV) rule, that detects and exploits pure values. The actions taken are dual for existentialand universal pure values. An existential variable with a pure value can be set to that value as it will not violate anyconstraint in any scenario. On the other hand, a pure value is removed from the domain of a universal variable as itwill certainly be part of any solution and thus we do not need to search for a consistent scenario that includes it. Thisduality reflects the dual semantics of existential and universal variables. For a universal variable, showing that a valuea is pure does not prove that it leads to a consistent scenario, only that if some other value of the same variable leads toa consistent scenario then a does. Hence it is a subsumption rule and the last value in the domain cannot be removed.Note that values can become pure dynamically during search as variable assignments and constraint propagationremove values from the domains of the variables (see Example 9 in Section 5.3). Therefore, the PV rule is applied bothas a preprocessing technique and as a dynamic look-ahead technique during search. The PV rule works as follows.• If a pure value a of an existential vi is discovered during preprocessing (search), then the assignment vi (cid:8)→ a ismade and all other values of vi are permanently (temporarily) removed from D(vi). To check, during search, if avalue a of an existential vi is pure, we only need to check if the assignment vi (cid:8)→ a is compatible with all valuesof future variables. FC (or MAC) guarantee that vi (cid:8)→ a is compatible with the instantiations of the past variables.• If a pure value a of a universal vi is discovered during preprocessing (search), then a is permanently (temporarily)removed from D(vi) unless it is the final value in D(vi). To check if a value of a universal is pure, we only needto check against future variables since preprocessing with AC guarantees that there are no constraints between auniversal and a past variable. If we discover during preprocessing that all the values of a universal are pure thenwe can ignore it thereafter as it is certain that all its values can be part of any consistent scenario.In both cases, any value that was temporarily removed because of the pure value rule is restored once a backtrackto a variable before vi in V occurs.Currently, the PV rule is implemented within two simple functions; one for preprocessing and another for thedynamic application of the rule during search. In both cases, to detect the pure values of a variable vi we iteratethrough the domains of the other variables that are constrained with vi (only variables after vi in case of dynamicapplication). During preprocessing we have to repeat this for all the variables in the problem, which gives a worst-case time complexity of O(n2d 2). During search we can restrict PV detection to the values of the current variable.This gives a worst-case time complexity of O(nd 2).The function that applies the PV rule during search need only be called before assigning the current variable vcurwith its first available value. That is, immediately after line 2 in Fig. 4, assuming that the underlying algorithm is FC0.Calling the function again when a backtrack to vcur later occurs is redundant as the restoration of the domains aftera backtrack guarantees that the pure values that were previously detected will remain pure and no new values willbecome pure.Relation between the pure value and the pure literal rule The PV rule applied to a QCSP F has a similar effect to theapplication of the pure literal rule (PL) to the enhanced log encoding (E). In some cases, PV and PL are equivalent,and in other cases details are different and an exact equivalence is elusive. To discuss this, we consider four cases, twoeach for existential and universal variables.If an existential variable ve has one pure value a in F , ve will be assigned to a in F . In the encoding PL will assignxvea (cid:8)→ T , since if ve (cid:8)→ a is not contained in any conflict in F , then ¬xvea is not contained in any conflict clause in E.The instantiation xvea (cid:8)→ T makes the ALO clause for ve true.If an existential variable ve in F has more than one pure value a, b, . . ., then one of the pure values is instantiatedby the PV rule. The value instantiated would typically be the first discovered by the algorithm. In the encoding, allcorresponding variables xveb , . . . are positively pure, and are instantiated to T by the PL rule. Again, this makesthe ALO clause true.a , xveIf a universal variable vu in F has a set of pure values P , and P (cid:2) D(vu), then all values in P are removed. Inthe encoding, all variables xvua , where a ∈ P , are positively pure, and are instantiated to T by the PL rule. Thus thechannelling clauses containing each of these variables are true, and the variables are entirely removed from E. ThisI.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771759may cause variables in the set wvu∗ to become pure, reducing the number of branches explored by the QBF solver.However, there is not an exact equivalence here between PV and PL.If all values of a universal variable vu in F are pure, then all but one are removed in F . In the encoding, all variablesxvu∗ are positively pure and all are set to true by the PL rule. Consequently, all channelling clauses are true, and allvariables wvu∗ are pure. Therefore they are also instantiated, and the QBF solver does not branch on any variable inthe set wvu∗ . Similarly, the QCSP solver does not branch on vu after instantiating it.5.2. CBJ and solution-directed pruning5.2.1. Conflict-based backjumpingCBJ has been successfully combined with FC in CSPs [39], and a DLL-based procedure in QBF [32] to dealwith dead-ends in an intelligent way and, thus, avoid redundant search. We now explain how CBJ is implemented inQCSP-Solve.As in CSPs, for each variable vi ∈ V we keep a set of variables called conflict set and denoted by conf_set(vi).This holds the past existentials that are responsible for the deletion of values from D(vi). Initially all conflict setsare empty. When encountering a dead-end at an existential or when a value of a universal is rejected, the algorithmexploits information kept in the conflict set of the current variable vcur to backjump to one of the past existentialsthat are responsible for the dead-end instead of blindly backtracking chronologically to the previous existential in V .To be precise, the algorithm backjumps to the most recently instantiated existential, say vk, among the existentials inconf_set(vcur) and reassigns it with its next available value. As vk’s previous assignment caused the deletion of (atleast one) value from D(vcur), if we reassign it, one or more values in D(vcur) may now become available. In contrast,an algorithm that always backtracks chronologically, as BT and the two FC variants do, may repeatedly encounter adead-end since the existential immediately before vcur in V may not belong to conf_set(vcur). In this case, reassigningthis existential will not “free” any of vcur’s values and therefore the dead-end at vcur will be encountered again.Conflict sets are updated as follows.• If the current variable vcur is existentially quantified and, during forward checking, a value of a future variable vjis found to be incompatible with the assignment of vcur then vcur is added to conf_set(vj ). This is straightforwardas now the assignment of vcur is responsible for the removal of a value from D(vj ).• If, after assigning a value a to vcur (which may be existential or universal) and forward checking, the domainof a future existential vj is wiped out then the existentials in conf_set(vj ) are added to the conflict set of thecurrent variable. This is done because the domain wipe-out of vj will result in value a being rejected. The pastexistentials that can be considered responsible for this rejection are the ones whose instantiations removed valuesfrom D(vj ). To understand this consider that were it not for the assignments to these existentials, a might not berejected since D(vj ) would not have been wiped out. Note that this is the only way in which the conflict set of auniversal can be updated.Backjumping can occur in either of the following two cases:1. If the current variable vcur is existential and there are no more values to be tried for it then the algorithm backjumpsto the latest (i.e. the most recently instantiated) existential vk in V that belongs to conf_set(vcur). At the same timeall variables in conf_set(vcur) (except vk) are copied to conf_set(vk) so that no information about conflicts is lost.This requires some explanation.Assume that vk was added to conf_set(vcur) because the assignment vk (cid:8)→ a resulted in the removal of value bfrom D(vcur). If after the backjump to vk all remaining values of vk are rejected then we have a dead-end andmust jump further back. Now assume that the most recent existential vl in conf_set(vk), where the algorithm willbackjump, was copied to conf_set(vk) from conf_set(vcur). Since vl was in conf_set(vcur), its current assignmentresulted in the removal of (at least one) value from vcur. When we change vl’s assignment it is possible that oneor more of these values will not be removed from D(vcur). Therefore, it may be possible to reassign vk with a inthe future without causing a dead-end at vcur further down the search tree. This gain of search effort would notbe possible if conf_set(vcur) was not copied to conf_set(vk) since we would have to backjump to an existentialbefore vl in V once encountering the dead-end at vk. Example 7 further demonstrates this reasoning.760I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771Fig. 6. The search tree explored by FC1 with CBJ on the problem of Example 7. The consistent strategy found is depicted with bold lines.2. If the current variable vcur is universal and one of its values fails (because it results in the domain wipe-out ofan existential vj ) then the algorithm backjumps to the latest existential vk in V that belongs to conf_set(vcur).That is, to the most recent existential whose instantiation removed a value from D(vj ). Again all variables inconf_set(vcur) (except vk) are copied to conf_set(vk) so that no information about conflicts is lost. The reasoningbehind this is similar to above.Example 7. Consider the following QCSP where V consists of 6 quantified variables, and C is a conjunction of 5constraints: ∃v1∃v2∃v3∃v4∀v5∃v6(v1 = v3 ∧ v2 (cid:14)= v6 ∧ v3 (cid:14)= v6 ∧ v4 (cid:2) v6 ∧ v5 (cid:14)= v6). Assume that the domains ofthe variables are as follows: D(v1) = D(v3) = D(v4) = D(v5) = D(v6) = {0, 1, 2}, D(v2) = {2, 3}. Algorithm FC1equipped with CBJ will proceed to solve the problem as follows.Variable v1 is assigned its first value 0. Forward checking removes values 1 and 2 from D(v3) and we setconf_set(v3) = {v1}. Variable v2 is assigned its first value 2. Forward checking removes value 2 from D(v6) andwe set conf_set(v6) = {v2}. Variable v3 is assigned its first value 0. Forward checking removes value 0 from D(v6)and v3 is added to conf_set(v6). So now we have conf_set(v6) = {v2, v3}. Variable v4 is assigned its first value 0. For-ward checking does nothing. We now reach variable v5 which is universally quantified. FC1 will forward check eachof v5’s values against v6. Value 1 of v5 results in the domain wipe-out of v6. Therefore, conf_set(v6) will be copiedto conf_set(v5) and we have conf_set(v5) = {v2, v3}. Since one of v5’s values failed we must backjump to the mostrecent variable in conf_set(v5) which is v3. All variables in conf_set(v5) (except v3) will be copied to conf_set(v3)and we now get conf_set(v3) = {v1, v2}. There are no more available values in D(v3) and therefore the algorithm willjump further back to the most recent variable in conf_set(v3), which is v2.Variable v2 is assigned its next value 3. Forward checking does nothing. Variable v3 is assigned its first value 0.Forward checking removes value 0 from D(v6) and we set conf_set(v6) = {v3}. Variable v4 is assigned its first avail-able value 0. Forward checking does nothing. We now reach variable v5 again so FC1 will forward check each of v5’svalues against v6. None of its values results in the domain wipe-out of v6. Therefore, there is no dead-end and theconsistent strategy shown in Fig. 6 will be found.Note that if we had not added the variables in conf_set(v5) to conf_set(v3), we would backjump to v1 whenencountering the dead-end at v3. This would result in a different solution being found, with more search effort.5.2.2. Solution-directed pruningAs discussed in Section 4.3, Giunchiglia et al. introduced solution-directed backjumping for QBF [32]. This allowsbackjumps over universally quantified literals once reaching a true leaf node. Inspired by this idea, we have imple-mented a technique that can prune values from universal variables when reaching a true leaf node and may also performsolution-directed backjumps. We call this solution-directed pruning (SDP). SDP is based on the following idea.Assume that vi is the last universal in V and q = (vi+1 . . . vn) is the sequence of existentials after vi in V . Also,assume that a consistent scenario including assignment vi (cid:8)→ ai has been found and (cid:3)vi+1 (cid:8)→ ai+1, . . . , vn (cid:8)→ an(cid:4) arethe assignments of the existential variables (vi+1 . . . vn) in this scenario. Then any value of vi that is compatible withI.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771761all these assignments will, obviously, also be part of a consistent scenario. Therefore, for each such value we canavoid running a search in the remaining existentials (i.e. any such value can be pruned). Based on this, after reachinga true leaf node, SDP first computes the values of the last universal vi in V that have the above property. All suchvalues are temporarily pruned from D(vi). If there are no available values in D(vi), SDP proceeds with the universalimmediately before vi in V , say vj .SDP then checks if vj ’s remaining values are compatible with the assignments of all existentials after vj . Eachsuch value is pruned from D(vj ), under the condition that all values of D(vi), after the first one, were previouslypruned by SDP. Or in other words, if all values of vi were found to be compatible with the same set of assignments(cid:3)vi+1 (cid:8)→ ai+1, . . . , vn (cid:8)→ an(cid:4) for the existentials after vi . Essentially this means that to prune a value from D(vj ) itmust be compatible with all the assignments in the previously discovered strategy for setting the variables after vj .This is repeated recursively until a universal is found which has available values left in its domain after SDP has beenapplied. The algorithm then backjumps to this universal. Example 8 illustrates how SDP operates.Example 8. Consider the QCSP ∀v1∃v2∀v3∃v4∃v5 (C). Assume that all variables have the domain {0, 1, 2} exceptv1 whose domain is {0, 1, 2, 3}. C includes some constraints which we don’t mention for simplicity reasons. Imaginethat BT, coupled with SDP, is used to solve the problem. Fig. 7 depicts a solution to the problem, and the nodes prunedby SDP together with the subtrees that are not searched.Assume that the consistent scenario (cid:3)v1 (cid:8)→ 0, v2 (cid:8)→ 1, v3 (cid:8)→ 0, v4 (cid:8)→ 1, v5 (cid:8)→ 2(cid:4) has been discovered. The al-gorithm will now backtrack to the last universal (i.e. v3) and apply SDP. Assuming that values 1 and 2 of v3 arecompatible with assignments v4 (cid:8)→ 1, v5 (cid:8)→ 2, SDP will prune values 1 and 2 from D(v3) and, thus, avoid searchingthe subtrees below the corresponding nodes. Since there are no values left in D(v3), the algorithm will apply SDP tothe previous universal (i.e. v1). Assuming that value 1 of v1 is compatible with assignments v2 (cid:8)→ 1, v4 (cid:8)→ 1, v5 (cid:8)→ 2,SDP will prune value 1 from D(v1). According to the definition of SDP the pruning is possible because all valuesof D(v3), after the first one, were pruned by SDP previously. That is, assignment v1 (cid:8)→ 1 is compatible with all theassignments in the previously discovered strategy for setting the variables after v1.Now assuming value 2 of v1 is not compatible with assignments v2 (cid:8)→ 1, v4 (cid:8)→ 1, v5 (cid:8)→ 2, the algorithm willbackjump to v1 and proceed by making the assignment v1 (cid:8)→ 2. As shown in Fig. 7, the algorithm will then findconsistent scenarios for values 0 and 1 of v3, while SDP will prune value 2 of v3 because it is compatible withassignments v4 (cid:8)→ 1, v5 (cid:8)→ 1. Since there are no more values in D(v3), the algorithm will apply SDP to v1. However,value 3 of v1 cannot be pruned because not all of v3’s values, after the first one, had been previously pruned by SDP.Therefore, the algorithm will proceed as usual to explore the subtree below the node corresponding to assignmentv1 (cid:8)→ 3. Note that SDP is not able to detect that the subtrees below the nodes corresponding to v1 (cid:8)→ 2 and v1 (cid:8)→ 3are similar because it only uses information about the most recently discovered consistent scenario.The way SDP operates, illustrated in Example 8, immediately suggests possible enhancements. For example, analgorithm that stores a history of consistent scenarios discovered earlier, as opposed to only the last one, may beable to perform more pruning than SDP, albeit with greater spatial requirements. We plan to investigate such learningtechniques in the future.Fig. 7. A solution to the problem of Example 8. Dark nodes are pruned by SDP and the subtrees below them (enclosed in dotted areas) are notsearched.762I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–7715.3. The algorithm of QCSP-SolveA high level description of QCSP-Solve’s algorithm is shown in Fig. 8. It takes a QCSP F = (cid:3)V , Q, D, C(cid:4) anddetermines whether the problem is true or false. The version of QCSP-Solve shown in Fig. 8 is based on FC. In Fig. 8,• preprocess is a function that preprocesses the problem by applying algorithm QAC-2001, and computing pureand NI values.• compute_PV computes the pure values of vcur during search. If vcur is existential and one of its values (say a)is pure then compute_PV assigns vcur with a and temporarily removes the rest of D(vcur)’s values. If vcur isuniversal then compute_PV temporarily removes all the pure values, except the last one, from D(vcur). The ifstatement of line 4 ensures that compute_PV is only called before vcur is assigned with its first available value.• Forward_Check0 is the function of Fig. 4 and implements the FC0-type look-ahead. It is called after the currentvariable (existential or universal) is assigned and checks this assignment against all future existentials constrainedwith vcur. If a value of a variable vi is deleted then vcur is added to conf_set(vi). If D(vi) is wiped out then eachvj ∈ conf _set(vi) is added to conf_set(vcur).• Forward_Check1 is the function of Fig. 5 and implements the FC1-type look-ahead. It is called before vcur isassigned (if it is a universal) and checks all of D(vcur)’s available values against the future variables constrainedwith vcur. If the domain of a variable vi is wiped out then each vj ∈ conf _set(vi) is added to conf_set(vcur). Theif statement of line 30 ensures that f c1() is called only before vcur is assigned with its first available value.• SDP implements solution-directed pruning. SDP prunes values from universals according to the reasoning de-scribed in Section 5.2 and returns the first universal found that has values left in its domain after SDP has beenapplied.• Restore is the procedure depicted in Fig. 9 used to restore values to the domains of variables upon backtracks.This procedure is slightly different from the one used by FC as it has to restore any values pruned by the PV rulein addition to the ones pruned by forward checking.QCSP-Solve works as follows. It takes as input a QCSP F = (cid:3)V , Q, D, C(cid:4) and, after preprocessing the problem(line 1), it proceeds by making assignments of values to variables until the truth of the problem is proved or disproved.Before assigning a value to vcur, QCSP-Solve calls compute_PV to compute the pure values of vcur (lines 4–5). Ifvcur is existential and there are no available values in D(vcur) then the algorithm backtracks to the latest variable in Vbelonging to conf_set(vcur) (lines 7–10). Otherwise, vcur is assigned with its next available value and the assignmentis checked against future variables (lines 12–13). If there is no domain wipe-out and the algorithm has reached a trueleaf node (i.e. vcur is the last variable in V ) then SDP is called to perform solution-directed pruning (lines 16–19). IfQCSP-Solve is not at a leaf node, it proceeds by moving to the next variable (line 20). If there is a domain wipe-out,the next value of vcur will be tried in the next iteration of the while loop. Note that if there are no universals in theproblem (i.e. it is a standard CSP), QCSP-Solve terminates when a true leaf node is reached (line 15).If vcur is a universal and consistent scenarios have been found for all of its values, then there are two cases. Ifvcur is the first universal, QCSP-Solve terminates successfully (line 24). Otherwise, it backtracks to the last universal(line 27). Before assigning any value to a universal variable, QCSP-Solve calls Forward_Check1 to perform the FC1-type look-ahead (lines 30–31). If there is a domain wipe-out, the algorithm backtracks to the latest variable in Vbelonging to conf_set(vcur) (lines 36–39). If there is no domain wipe-out, or Forward_Check1 has already been calledat this level, vcur is assigned with its next available value (line 33), the assignment is checked against future variables(line 34), and QCSP-Solve proceeds with the next variable (line 35).Although it is not shown in Fig. 8, QCSP-Solve can also employ the dynamic symmetry-breaking technique basedon computing NI values, described in Section 3.3. However, the experiments we have run so far have showed thatthe time overheads of this technique outweigh the benefits it offers, when the PV rule is also used. That is why itis not included in the pseudo-code of Fig. 8. However, in other problems than the ones we tried, and with betterimplementation, it is quite possible that dynamic NI-based symmetry breaking may be useful.The following example demonstrates how QCSP-Solve operates.Example 9. Consider the following QCSP where V consists of 7 quantified variables, and C is a conjunction of 9constraints. ∃v1∃v2∀v3∀v4∀v5∃v6∃v7(v1 (cid:14)= v6 ∧ v1 (cid:14)= v7 ∧ v2 (cid:14)= v6 ∧ v3 (cid:14)= v6 ∧ v3 < v7 ∧ v4 (cid:14)= v6 ∧ v4 (cid:14)= v7 ∧ v5 (cid:14)= v6 ∧I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771763Boolean QCSP-Solve(F = (cid:3)V , Q, D, C(cid:4))input: A QCSP Foutput: TRUE if a solution to F exists and FALSE otherwiseelseif vcur = vnif Q(vcur) = ∃compute_PV(F, vcur)if all values in D(vcur) have been triedif the previously assigned variable was vcur−1if there are no universals in V return TRUEelseassign vcur with the next available value a ∈ D(vcur)if Forward_Check0(F, vcur, a)vback ← SDP(F )Restore(F, vcur, vback)vcur ← vbackelse vcur ← next(vcur)else Restore(F, vcur, vcur)vback ← latest variable in V belonging to conf_set(vcur)Restore(F, vcur, vback)vcur ← vback1: preprocess(F )2: vcur ← v13: while vcur (cid:14)= NIL4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22: else //Q(vcur) = ∀//23:24:25:26:27:28:29:30:31:32:33:34:35:36:vback ← latest variable in V belonging to conf_set(vcur)37:Restore(F, vcur, vback)38:vcur ← vback39:40: if vcur = NIL return FALSEassign vcur with the next available value a ∈ D(vcur)Forward_Check0(F, vcur, a)vcur ← next(vcur)FC_result ←TRUEif the previously assigned variable was vcur−1FC_result ←Forward_Check1(F, vcur)if vcur is the first universal in V return TRUEelseRestore(F, vcur,last_u(vcur))vcur ← last_u(vcur)if all values in D(vcur) have been triedif FC_resultelseelseFig. 8. The algorithm of QCSP-Solve.procedure Restore(F, vcur, vback)input: A QCSP F , the current variable vcur and the variable where the algorithm will backtrack vbackoutput: -1: for vi = vback to vcur2:3:4:restore to D(vj ) any value that was removed because of vi ’s instantiationrestore to D(vj ) any value that was removed because of the PV rulefor each variable vj after vi in VFig. 9. Restoration procedure of QCSP-Solve.764I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771Fig. 10. Search tree of Example 9. Dark nodes are pruned by QCSP-Solve. Such nodes together with the feature responsible for their pruning areincluded in dotted ovals in the last figure. Dotted edges denote parts of the tree that were visited in the past. DWO stands for domain wipe-out.v5 < v7). Assume that the domains of the variables are as follows: D(v1) = {2, 3}, D(v2) = {0, 1, 2}, D(v3) = {0, 3},D(v4) = {0, 1, 6}, D(v5) = {4, 5}, D(v6) = {0, 1, 2, 3}, D(v7) = {0, 2, 3, 6}.Let us trace the execution of QCSP-Solve for a few steps to understand how its various features prune the searchspace. Figs. 10a to 10k demonstrate how the search tree explored by QCSP-Solve is built, how certain nodes arepruned, and the way the domains of the variables change during search.Fig. 10a Preprocessing is applied (line 1 of the algorithm). There are no arc inconsistent or pure values, so no pruningis performed.3Fig. 10b The assignment v1 (cid:8)→ 2 is made (line 12). Forward_Check0 reduces D(v6) and D(v7) to {0, 1, 3} and{0, 3, 6} respectively (line 13). We now have the following: conf_set(v6) = conf _set (v7) = {v1}.3 Values 4 and 5 of v5 are NI, but let us ignore this for the sake of the example.I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771765Fig. 10c Now, value 2 of v2 becomes pure because it is supported by all values in future variables (lines 4–5). ThePV rule will immediately make the assignment v2 (cid:8)→ 2.Fig. 10d The next variable is a universal. Forward_Check1 (lines 30–31) does not wipe out any future domain, sothe assignment v3 (cid:8)→ 0 is made (line 33). Forward_Check0 reduces D(v6) and D(v7) to {1, 3} and {3, 6}respectively (line 34).Fig. 10e Value 0 of v4 is pure (lines 4–5). Therefore, it is removed. Forward_Check1 (lines 30–31) does not wipe outany future domain, so the assignment v4 (cid:8)→ 1 is made (line 33) and Forward_Check0 reduces D(v6) to {3}(line 34).Fig. 10f The next variable is v5. Forward_Check1 does not wipe out any future domain (lines 30–31), so the assign-ment v5 (cid:8)→ 4 will be made (line 33). Forward_Check0 reduces D(v7) to {6} (line 34).Fig. 10g v6 and v7 are assigned their only available values (in line 12) and a true leaf node is found (line 14).Fig. 10h Now function SDP is called (line 17). SDP discovers that value 5 of the last universal (v5) is compatiblewith the assignments of all the existentials after v5. Therefore, this value is removed from D(v5). SDP isthen applied to the previous universal v4. Value 6 of v4 is not compatible with the assignments to v6 and v7.Therefore, a solution-directed backjump to v4 is performed (line 19).Fig. 10i The assignment v4 (cid:8)→ 6 is made (line 33). Forward_Check0 reduces D(v6) and D(v7) to {1, 3} and {3}respectively (line 34).Fig. 10j Forward_Check1 (lines 30–31) applied at v5 wipes out D(v7) because value 4 of v5 is incompatible with theonly value in D(v7). Therefore, we have a dead-end and conf_set(v7) will be added to conf_set(v5).Fig. 10k The algorithm will backjump to the latest variable in V belonging to conf_set(v5), which is v1 (line 37–39).Fig. 10l shows the part of the search tree traced in the example and illustrates how subtrees are pruned by applyinglook-ahead and look-back techniques.6. Experimental evaluationTo compare the performance of the methods presented in the previous sections, we ran experiments on randomlygenerated QCSPs. Before presenting the results, we discuss the issue of flaws in random instances, which is familiarfrom other search problems such as CSP and QBF and can have a significant impact on experimental studies. We showthat random generators derived by extending standard generators for QBF and CSP give rise to flaws, which quicklyinfect all generated problems. Since this is an important problem for experiments in QCSP, we propose a randomgenerator that is free from these flaws.6.1. Flaws in random QCSP generationLocal flaws have been discovered in random generation models for search problems, such as CSPs [1] and QBF[29]. We show that random generation models for QCSPs that are based on standard generators for QBF and CSPscan suffer from a local flaw (specific to QCSPs) that makes almost all of the generated instances false, even for smallproblem sizes.Consider, for example, the k-QBF random generation model [29] which has been widely used in experimentswith QBF. In this model there are k + 1 blocks of variables with alternating quantification, with the variables in thefirst block being existentially quantified. For example, in a 2-QBF problem we have a block of existential variablesfollowed by a block of universal variables followed by another block of existential variables. This model can be easilyadapted to generate QCSP instances. The blocks of variables are generated as in k-QBF and the binary constraints canbe generated using a standard model for binary CSPs (e.g. model B [43]).However, the k-QCSP generator is subject to a local flaw. Suppose we can find assignments (cid:3)v1 (cid:8)→ 7, v2 (cid:8)→2, . . . , vk (cid:8)→ 3(cid:4) for universals v1, . . . , vk, and there exists an existential ve appearing later in V than all variablesvi where i ∈ 1 . . . k. If every value of ve conflicts with one of the chosen values of one of the universals, this tuple ofassignments is inconsistent. But it remains inconsistent irrespective of assignments to other universals or existentialsand so the problem is trivially false as a whole. Even taking the extreme case of only one conflict per constraint, thiscan happen as long as there are as many universals before ve as values in its domain.766I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771Assume there are d universals, and there is a constraint between a pair of variables with probability p. Eachconstraint has one nogood. Assume that D(ve) = {1, . . . , d}. The probability of a conflict between some universal andvalue 1 in D(ve) is pd/d (i.e. we pick a universal u from d universals, with probability p there is a constraint betweenu and ve, and with probability 1/d the single conflict involves value 1 ∈ D(ve)). For value 2, the set of availableuniversals has size d − 1, so the probability is p(d − 1)/d. Overall the probability of a flaw between existential ve andd particular universals is P (ve) =With k existential variables quantified after d universals, the probability of no flaw occurring is (1 − P (ve))k. SinceP (ve) does not depend on k, with fixed d and p this probability tends to 0 as k → ∞. Not only are flaws certain tooccur, but there is no phase transition: i.e. for any p > 0 almost all problems are false asymptotically.(cid:6)di=1 pi/d.This flaw is not only very common, but also discovering its presence is an NP-complete problem. Let us repeat thedescription of the flaw slightly more formally.Definition 6 (Flawed problem). Suppose that we have a set of variable assignments S = {v1 (cid:8)→ a1, . . . , vi (cid:8)→ ai},where for each aj , j = 1 . . . i, aj ∈ D(vj ), and each vj , j = 1 . . . i, is universally quantified and appears in V beforean existential variable ve. If every value b ∈ D(ve) is incompatible with at least one value assignment vj (cid:8)→ aj ∈ S((cid:3)aj , b(cid:4) /∈ cj e), then the entire problem is false, and is said to be flawed.Notice that the only case of this which is detected by either a QCSP technique or encoding is the case wherethe set of variable-value pairs is a singleton. I.e. some vj (cid:8)→ aj is inconsistent with every value of ve. In this casealgorithm QAC-2001 reports failure. For the case where each constraint contains only one conflict, it is easy to checkeach existential variable for a flaw. That is how we computed the proportion of flawed problems above. However, ingeneral it is hard to confirm the existence of a flaw:Theorem 2. Checking for the presence of a flaw in a QCSP is NP-complete.Proof. Consider any SAT instance. We convert this into a QCSP such that the SAT instance has a solution iff theQCSP is flawed. For each SAT variable v we have a corresponding universal QCSP variable v with two values, 0 and1. We have a single existential variable ve quantified last, with domain size equal to the number of clauses in the SATproblem. We have a constraint between every universal variable and ve. This constraint has a conflict for each SATclause that the variable occurs in. If the literal in clause i is ¬v, the conflict rules out the pair (cid:3)v (cid:8)→ 0, ve (cid:8)→ i(cid:4), whileif the literal is v, the conflict rules out (cid:3)v (cid:8)→ 1, ve (cid:8)→ i(cid:4).Now consider any satisfying assignment to the SAT instance. This is a set of literals such that at least one occursin each clause. Say ¬v is in the set and occurs in clause i. Then the translation ensures that v (cid:8)→ 0 rules out ve (cid:8)→ i.Similarly, if u is in the assignment and occurs in clause j , then u (cid:8)→ 1 is in conflict with ve (cid:8)→ j . So each value of veis ruled out. We never need to set any variable to 0 and 1 simultaneously, as the satisfying assignment does not containboth a variable and its negation.The reverse direction is similar. Say that the translated QCSP is flawed. Then there is a set of assignments {vi (cid:8)→ ai}ruling out each value of ve. If ai = 0 then, by construction, the literal ¬v occurs in clause i and satisfies it. And ifai = 1 then v occurs in clause i. As all values of ve are ruled out, the SAT instance is satisfied.The flaw is easily witnessed, by a choice of values for universal variables, so the problem of instances being flawedis also in NP so is NP-complete. (cid:2)Note that the flaw is simply a situation in which search can be terminated. As such it might give rise to interestingnew propagation techniques in QCSP, or valuable new clauses in QBF encodings.6.1.1. Random problem generatorThe random generator we used controls the probability of flaws. Variables appear in blocks with alternating quan-tification. For simplicity, we describe the model in the case of three blocks. That is, a block of existentials followed bya block of universals then another block of existentials. The generator takes 7 parameters: (cid:3)n, n∀, npos, d, p, q∀∃, q∃∃(cid:4)where n is the total number of variables, n∀ is the number of universally quantified variables, npos is the position ofthe first universally quantified variable in V , d is the uniform domain size, p is the number of binary constraints as afraction of all possible constraints.I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771767q∃∃ is the number of goods (i.e. satisfying tuples) in ∃ vi∃ vj (cij ) constraints as a fraction of all possible tuples,and q∀∃ is a similar quantity for ∀ vi∃ vj (cij ) constraints explained below. The other two types of binary constraintcan be removed entirely by preprocessing and so we do not generate them.Since the flaw is a characteristic of ∀ vi∃ vj (cij ) constraints, we restrict these in the following way: we generatea random total bijection (i.e. a one-to-one correspondence) from one domain D(vi) to the other D(vj ). Conflicts arechosen only from those pairs in the bijection. All 2-tuples not in the bijection are goods. Now q∀∃ is the fraction ofgoods from the d tuples in the bijection.Notice that the p, q∃∃, q∀∃, and q∀∃ parameters are proportions rather than probabilities, hence this model is similarin style to model B for random CSPs.To control the probability pf of the flaw, we write down an expression for pf , approximating proportionsp, q∀∃, q∃∃ as probabilities. n∀ is the number of universal variables, and n∃ is the number of existential variablesin the second existential block.For each existential assignment ve (cid:8)→ 1, the probability that it is covered by a universal vu is p(1 − q∀∃). If thevariable ve is flawed, then all its values are in conflict with some value of some universal variable. However, eachuniversal variable can only cover one value (since we use a bijection).For an individual existential variable ve (in the second existential block), and representing domain values usingpositive integers, we start by writing down the following equation. It places an ordering on the values and representsthe probability of all values in D(ve) being flawed as a product of the probabilities of each value a, given that allvalues less than a are flawed. So for example, if a = 5, the probability that value 5 is flawed (given values 1, 2, 3, 4are flawed) is written as p(5|1, 2, 3, 4).p(ve flaw) = p(1)p(2|1)p(3|1, 2) . . .(1)The probability that value a is flawed, given that the previous a − 1 values are flawed, is given by Eq. (2). 1 − q∀∃is the probability of the particular value a ∈ D(ve) being in a nogood of any particular constraint. This is multipliedby p1 to obtain an approximate probability of a particular universal vg and constraint cge having a nogood containinga ∈ D(ve).The exponent n∀ − (a − 1) is the number of universal variables, minus those (a − 1) variables which are alreadyinstantiated to conflict with the (a − 1) lower values in D(ve). The probability p1(1 − q∀∃) of a particular universalhaving a conflict with a ∈ D(ve) is complemented, raised to the exponent and complemented again to obtain theprobability of any remaining universal variable having a conflict with a ∈ D(ve).p(a|1 . . . a − 1) = 1 −(cid:2)(cid:3)n∀−(a−1)1 − p1(1 − q∀∃)Substituting Eq. (2) into Eq. (1) gives the probability of one particular existential variable being flawed.p(ve flaw) =d−1(cid:7)i=0(cid:2)1 −(cid:2)(cid:3)n∀−i1 − p1(1 − q∀∃)(cid:3)The probability that no existential variables are flawed is given below. This formula gives incorrect results whend > n∀. In this case, pf = 1 since there are not enough universal variables to cover all elements of a domain.(cid:3)(cid:2)1 − p(ve flaw)pf =n∃(4)6.2. Experimental resultsIn this section we present experimental results from problems generated using the model described above. Our aimis to demonstrate the huge progress in the efficiency of QCSP solving that was made, starting from our first methodsand culminating in the most advanced ones. Therefore, we only give indicative results for the various techniques.6.2.1. Direct algorithmsFig. 11 presents a comparison of algorithms FC1, FC1 + PV, MAC1 + PV, and QCSP-Solve on problems generatedaccording to the model described above. All algorithms apply AC, and NI preprocessing. For each value of q∃∃ shownin the figures, 100 problem instances were generated and we use the mean average. The generation parameters aren = 21, d = 8, p = 0.2, and q∀∃ = 0.5. Variables v1 . . . v7 are existentials, v8 . . . v14 are universals, and v15 . . . v21 are(2)(3)768I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771Fig. 11. Comparison of direct algorithms for QCSPs. n = 21, n∀ = 7, d = 8, p = 0.20, q∀∃ = 1/2.Fig. 12. Comparison of the enhanced log encoding with adapted log and QCSP-Solve.existentials. These parameters ensure that the instances are unflawed. Finally, q∃∃ is varied across the satisfiabilityphase transition. We include FC1 + PV and MAC1 + PV in the comparison to illustrate the power of the PV rule.Note that, for the problems we tried, the FC-based algorithms are more efficient than the corresponding MAC-basedones. However, for larger problems this may easily be reversed.In the problems of Fig. 11 the execution of FC1 was stopped at the cut-off limit of 2 hours in more than 50% of theinstances. As we can see, QCSP-Solve is many orders of magnitude faster than FC1. The speed-up obtained is largelydue to the application of the PV rule. Similar results were obtained with various parameter settings.At this point we should note that both the recently proposed QCSP solvers BlockSolve and QeCode, of [44] and [4]respectively, achieved very good results on randomly generated QCSPs. Both these solvers are considerably differentthan QCSP-Solve. BlockSolve is a bottom-up solver that displays better performance than QCSP-Solve on satisfiableinstances, but as a downside requires exponential space. QeCode is built on top of Gecode and hence is equipped withmany advanced CSP techniques such as GAC algorithms for certain global constraints. On the other hand, it lacksspecialized features for QCSPs, such as pure value handling.6.2.2. Encodings of QCSP as QBFAs explained in Section 4, the global and local acceptability encodings perform poorly compared to the otherencodings and the direct methods. Therefore, we do not include results for these two encodings. The enhanced logencoding gives a remarkable improvement over adapted log. It is also competitive with QCSP-Solve and can be twoorders of magnitude better. Fig. 12 shows results using the three methods. The generation parameters are n = 24,d = 9, p = 0.2, and q∀∃ = 0.5. Variables v1 . . . v8 are existentials, v9 . . . v16 are universals, and v17 . . . v24 are existen-I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771769tials. q∃∃ is varied across the satisfiability phase transition. For each point, 100 instances were generated. The medianaverage is used because of high outliers. The time taken to encode the instances is not included, but since it is a linearencoding this is negligible for difficult instances.The closest setting of q∃∃ to the phase transition is 0.55, with 43 instances out of 100 being true. This also ap-proximately coincides with the difficulty peaks for the encodings, but not for QCSP-Solve. For lower values of q∃∃fewer of the instances are true and the enhanced log encoding is less competitive with QCSP-Solve. For example atq∃∃ = 0.35, 99 of the instances are false, and QCSP-Solve outperforms the enhanced log encoding. Where q∃∃ = 0.8all the instances are true and the enhanced log encoding outperforms QCSP-Solve. At q∃∃ = 0.9, the median for theenhanced log encoding fell below the resolution of the timer, so it is not shown on the graph.This suggests that the QBF solver CSBJ is more effective in pruning or backjumping over universal variables,because in a loosely-constrained instance the main cost is branching on universals. Testing this, and identifying whichrules in CSBJ are responsible, remains for future work.We very briefly experimented with two other solvers, the resolution solver Quantor, and the hybrid (search andresolution) solver sKizzo. The aim was to gather some initial evidence as to whether the enhanced log encoding isas efficient with non-search-based solvers as it is with search-based ones like CSBJ. The random instances run hadthe following parameters: n = 24, 3 blocks of 8 variables with alternating quantification, and d = 9, ensuring thatthe instances are unflawed. p = 0.2, q∀∃ = 0.5, and q∃∃ = 0.5 (at the phase transition and difficulty peak for CSBJ).10 instances were generated. CSBJ solved 9 instances in under half a second each, and the tenth in 8.98 s. Quantorquickly ran out of memory (>1 GB) on eight of the instances, solved one in 2.98 s and ran out of time for the other(>60 s). sKizzo was unable to solve any instance within 60 s. From this we conjecture that search-based solvers arepreferable for the encoding. However, further experiments are necessary to validate this conjecture.7. ConclusionsIn this paper we studied various methods for solving QCSPs with finite discrete non-Boolean domains. Our firstapproach was based on adapting techniques from CSPs to deal with QCSPs. We described an AC algorithm for QCSPsthat can deal with arbitrary binary constraints. We then extended the BT, FC, and MAC algorithms so that they canhandle quantification. We also proposed modifications of FC and MAC that are better suited to QCSPs.Our second approach was based on encoding QCSPs as QBFs. Our motivation was that at an early stage of researchinto a new problem like QCSP, encoding into a more studied problem like QBF would very likely provide competitiveperformance. We introduced progressively more efficient encodings, culminating in the enhanced log encoding, whichcan be several orders of magnitude faster than the direct QCSP algorithms. Through this study it was also demonstratedthat the effective encoding of QCSP into QBF can be a complex process, since simple generalizations of CSP-to-SATencodings are very inefficient.Apart from giving us efficient tools for QCSP solving, the performance and properties of encodings and techniquesused in QBF solving indicated significant enhancements to the direct QCSP algorithms. We identified two featuresof the log encodings and the underlying QBF solver as largely responsible for their success; first, their ability to takeadvantage of the pure literal rule in QBF, and second, their backjumping capabilities, manifested by CBJ and SBJ.We devised and implemented analogues of these features within direct QCSP algorithms, resulting in QCSP-Solve,an efficient direct solver.Finally, we proposed a model for the random generation of QCSPs that is free from known flaws. Experimentswith problems generated using this model demonstrated the dramatic improvement in performance when comparingour initial QCSP solving attempts to the sophisticated techniques developed later.AcknowledgementsWe would like to thank the anonymous reviewers for their comments and suggestions that helped greatly improvethe presentation of this paper.References[1] D. Achlioptas, L.M. Kirousis, E. Kranakis, D. Krizanc, M.S.O. Molloy, Y.C. Stamatiou, Random constraint satisfaction: A more accuratepicture, in: Proc. CP97, Springer, 1997, pp. 107–120.770I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771[2] A. Beckwith, B. Choueiry, On the dynamic detection of interchangeability in finite constraint satisfaction problems, in: Proceedings of CP-2001, 2001, p. 760.[3] M. Benedetti, sKizzo: A suite to evaluate and certify QBFs, in: Proc. of 20th International Conference on Automated Deduction (CADE05),2005.[4] M. Benedetti, A. Lallouet, J. Vautard, Reusing CSP propagators for QCSPs, in: Proceedings of CSCLP-2006, 2006.[5] F. Benhamou, F. Goualard, Universally quantified interval constraints, in: Proceedings of CP-2000, 2000, pp. 67–82.[6] C. Bessière, J.C. Régin, R. Yap, Y. Zhang, An optimal coarse-grained arc consistency algorithm, Artificial Intelligence 165 (2) (2005) 165–185.[7] A. Biere, Resolve and expand, in: Proc. 7th Intl. Conf. on Theory and Applications of Satisfiability Testing (SAT’04), vol. 3542, 2005,pp. 59–70.[8] F. Boerner, A. Bulatov, P. Jeavons, A. Krokhin, Quantified constraints: Algorithms and complexity, in: Proceedings of CSL-2003, 2003,pp. 244–258.[9] L. Bordeaux, Boolean and interval propagation for quantified constraints, in: Proceedings of the CP-2005 Workshop on Quantification inConstraint Programming, 2005.[10] L. Bordeaux, M. Cadoli, T. Mancini, Exploiting fixable, removable, and implied values in constraint satisfaction problems, in: Proceedings ofLPAR-2004, 2004, pp. 270–284.[11] L. Bordeaux, M. Cadoli, T. Mancini, CSP properties for quantified constraints: Definitions and complexity, in: Proceedings of AAAI-2005,2005, pp. 360–365.[12] L. Bordeaux, E. Monfroy, Beyond NP: Arc-consistency for quantified constraints, in: Proceedings of CP-2002, 2002, pp. 371–386.[13] M. Cadoli, A. Giovanardi, M. Schaerf, An algorithm to evaluate quantified Boolean formulae, in: Proceedings of AAAI-98, 1998, pp. 262–267.[14] M. Cadoli, M. Schaerf, A. Giovanardi, M. Giovanardi, An algorithm to evaluate quantified Boolean formulae and its experimental evaluation,Journal of Automated Reasoning 28 (2) (2002) 101–142.[15] H. Chen, The computational complexity of quantified constraint satisfaction, PhD Thesis, 2004.[16] H. Chen, Collapsibility and consistency in quantified constraint satisfaction, in: Proceedings of AAAI-04, 2004, pp. 155–160.[17] H. Chen, Quantified constraint satisfaction and bounded treewidth, in: Proceedings of ECAI-04, 2004, pp. 161–165.[18] Complexity Classifications of Boolean Constraint Satisfaction Problems, N. Creignou, S. Khanna, M. Sudan (Eds.), SIAM Monographs inDiscrete Mathematics and Applications, SIAM, 2001.[19] M. Davis, G. Logemann, D. Loveland, A machine program for theorem proving, Communications of the ACM 5 (7) (1962) 394–397.[20] M. Davis, H. Putnam, A computing procedure for quantification theory, Journal of the ACM 7 (1) (1960) 201–215.[21] R. Dechter, P. van Beek, Local and global relational consistency, Theoretical Computer Science 173 (1997) 283–308.[22] A. Tacchella E. Giunchiglia, M. Narizzano, Learning for quantified Boolean logic satisfiability, in: Proc. 18th National Conference on ArtificialIntelligence (AAAI-02).[23] U. Egly, T. Eiter, H. Tompits, S. Woltran, Solving advanced reasoning tasks using quantified Boolean formulas, in: Proceedings of AAAI-2000,2000, pp. 417–422.[24] E. Freuder, Eliminating interchangeable values in constraint satisfaction problems, in: Proceedings of AAAI-91, 1991, pp. 227–233.[25] A. Frisch, T.J. Peugniez, Solving non-Boolean satisfiability problems with stochastic local search, in: Proc. IJCAI-01, 2001, pp. 282–288.[26] M. Garey, D. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman, 1979.[27] I. Gent, P. Nightingale, A. Rowley, Encoding quantified CSPs as quantified Boolean formulae, in: Proceedings of ECAI-2004, 2004, pp. 176–180.[28] I. Gent, P. Nightingale, K. Stergiou, QCSP-Solve: A solver for quantified constraint satisfaction problems, in: Proceedings of IJCAI-2005,2005.[29] I. Gent, T. Walsh, Beyond NP: The QSAT phase transition, in: Proceedings of AAAI-99, 1999, pp. 648–653.[30] I.P. Gent, J.-F. Puget, K.E. Petrie, Symmetry in constraint programming, in: F. Rossi, P. van Beek, T. Walsh (Eds.), Handbook of ConstraintProgramming, Elsevier, 2006, pp. 329–376.[31] I.P. Gent, A.G.D. Rowley, Encoding connect-4 using quantified Boolean formulae, in: Proceedings of Workshop on Modelling and Reformu-lating Constraint Satisfaction Problems, 2003, pp. 78–93.[32] E. Giunchiglia, M. Narizzano, A. Tacchella, Backjumping for quantified Boolean logic satisfiability, in: Proceedings of IJCAI-2001, 2001,pp. 275–281.[33] E. Giunchiglia, M. Narizzano, A. Tacchella, Learning for quantified Boolean logic satisfiability, in: Proceedings of AAAI-2001, 2002, pp. 649–654.[34] E. Giunchiglia, M. Narizzano, A. Tacchella, Clause/term resolution and learning in the evaluation of quantified Boolean formulas, Journal ofArtificial Intelligence Research 26 (2006) 371–415.[35] R.M. Haralick, G.L. Elliot, Increasing tree search efficiency for constraint satisfaction problems, Artificial Intelligence 14 (1980) 263–313.[36] A. Haselbock, Exploiting interchangeabilities in constraint satisfaction problems, in: Proceedings of IJCAI-93, 1993, pp. 282–287.[37] M. Narizzano, A. Rowley, I. Gent, E. Giunchiglia, A. Tacchella, Watched data structures for qbf solvers, in: Proceedings SAT 2003, Springer,2003, pp. 25–36.[38] C. Papadimitriou (Ed.), Computational Complexity, Addison Wesley, 1994.[39] P. Prosser, Hybrid algorithms for the constraint satisfaction problem, Computational Intelligence 9 (3) (1993) 268–299.[40] S. Ratschan, Applications of quantified constraint solving over the reals bibliography, http://www.cs.cas.cz/~ratschan/appqcs.html, 2003.[41] S. Ratschan, Efficient solving of quantified inequality constraints over the reals, ACM Transactions on Computational Logic 7 (4) (2006)723–748.I.P. Gent et al. / Artificial Intelligence 172 (2008) 738–771771[42] D. Sabin, E. Freuder, Contradicting conventional wisdom in constraint satisfaction, in: Proceedings of ECAI-94, 1994, pp. 125–129.[43] B. Smith, Phase transition and the mushy region in constraint satisfaction problems, in: Proceedings of ECAI-94, 1994, pp. 100–104.[44] G. Verger, C. Bessière, Blocksolve: A bottom-up approach for solving quantified CSPs, in: Proceedings of CP-2006, Springer, 2006, pp. 635–649.[45] T. Walsh, SAT v CSP, in: Proceedings of CP-2000, in: LNCS, vol. 1894, Springer, 2000, pp. 441–456.