Artiﬁcial Intelligence 187–188 (2012) 156–192

Contents lists available at SciVerse ScienceDirect

Artiﬁcial Intelligence

www.elsevier.com/locate/artint

Magic Sets for disjunctive Datalog programs ✩

Mario Alviano, Wolfgang Faber

∗

, Gianluigi Greco, Nicola Leone

Department of Mathematics, University of Calabria, 87036 Rende, Italy

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 13 January 2011
Received in revised form 20 April 2012
Accepted 24 April 2012
Available online 26 April 2012

Keywords:
Logic programming
Stable models
Magic Sets
Answer set programming
Data integration

In this paper, a new technique for the optimization of (partially) bound queries over
disjunctive Datalog programs with stratiﬁed negation is presented. The technique exploits
the propagation of query bindings and extends the Magic Set optimization technique
(originally deﬁned for non-disjunctive programs).
An important feature of disjunctive Datalog programs is non-monotonicity, which calls
for non-deterministic implementations, such as backtracking search. A distinguishing
characteristic of the new method is that the optimization can be exploited also during
the non-deterministic phase. In particular, after some assumptions have been made during
the computation, parts of the program may become irrelevant to a query under these
assumptions. This allows for dynamic pruning of the search space. In contrast, the effect
of the previously deﬁned Magic Set methods for disjunctive Datalog is limited to the
deterministic portion of the process. In this way, the potential performance gain by using
the proposed method can be exponential, as could be observed empirically.
The correctness of the method is established and proved in a formal way thanks to a
strong relationship between Magic Sets and unfounded sets that has not been studied in
the literature before. This knowledge allows for extending the method and the correctness
proof also to programs with stratiﬁed negation in a natural way.
The proposed method has been implemented in the DLV system and various experiments
on synthetic as well as on real-world data have been conducted. The experimental results
on synthetic data conﬁrm the utility of Magic Sets for disjunctive Datalog, and they
highlight the computational gain that may be obtained by the new method with respect
to the previously proposed Magic Set method for disjunctive Datalog programs. Further
experiments on data taken from a real-life application show the beneﬁts of the Magic
Set method within an application scenario that has received considerable attention in
recent years, the problem of answering user queries over possibly inconsistent databases
originating from integration of autonomous sources of information.

© 2012 Elsevier B.V. All rights reserved.

1. Introduction

Disjunctive Datalog is a language that has been proposed for modeling incomplete data [48]. Together with a light
version of negation, in this paper stratiﬁed negation, this language can in fact express any query of the complexity class
2 (i.e., NPNP) [22], under the stable model semantics. It turns out that disjunctive Datalog with stratiﬁed negation is
Σ P
strictly more expressive (unless the polynomial hierarchy collapses to its ﬁrst level) than normal logic programming (i.e.,
non-disjunctive Datalog with unstratiﬁed negation), as the latter can express “only” queries in NP. As shown in [22], the

✩

Preliminary portions of this paper appeared in the proceedings of the 20th International Conference on Logic Programming (ICLP’04).

* Corresponding author.

E-mail addresses: alviano@mat.unical.it (M. Alviano), faber@mat.unical.it (W. Faber), ggreco@mat.unical.it (G. Greco), leone@mat.unical.it (N. Leone).

0004-3702/$ – see front matter © 2012 Elsevier B.V. All rights reserved.
http://dx.doi.org/10.1016/j.artint.2012.04.008

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

157

high expressive power of disjunctive Datalog has also some positive practical implications in terms of modeling knowledge,
since many problems in NP can be represented more simply and naturally in stratiﬁed disjunctive Datalog than in normal
logic programming. For this reason, it is not surprising that disjunctive Datalog has found several real-world applications
[42,49,50,57,58], also encouraged by the availability of some eﬃcient inference engines, such as DLV [43], GnT [37], Cmodels
[46], or ClaspD [21]. As a matter of fact, these systems are continuously enhanced to support novel optimization strategies,
enabling them to be effective over increasingly larger application domains. In this paper, we contribute to this development
by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic
Set method [6,9,63].

The goal of the original Magic Set method (deﬁned for non-disjunctive Datalog programs) is to exploit the presence
of constants in a query for restricting the possible search space by considering only a subset of a hypothetical program
instantiation that is suﬃcient to answer the query in question. In order to do this, a top–down computation for answering
the query is simulated in an abstract way. This top–down simulation is then encoded by means of rules, deﬁning new Magic
Set predicates. The extensions of these predicates (sets of ground atoms) will contain the tuples that are calculated during
a top–down computation. These predicates are inserted into the original program rules and can then be used by bottom–up
computations to narrow the computation to what is needed for answering the query.

Extending these ideas to disjunctive Datalog faces a major challenge: While non-disjunctive Datalog programs are deter-
ministic, which in terms of the stable model semantics means that any non-disjunctive Datalog program has exactly one
stable model, disjunctive Datalog programs are non-deterministic in the sense that they may have multiple stable models.
Of course, the main goal is still isolating a subset of a hypothetical program instantiation, upon which the considered query
will be evaluated in an equivalent way. There are two basic possibilities how this non-determinism can be dealt with in
the context of Magic Sets: The ﬁrst is to consider static Magic Sets, in the sense that the deﬁnition of the Magic Sets is still
deterministic, and therefore the extension of the Magic Set predicates is equal in each stable model. This static behavior is
automatic for Magic Sets of non-disjunctive Datalog programs. The second possibility is to allow dynamic Magic Sets, which
also introduce non-deterministic deﬁnitions of Magic Sets. This means that the extension of the Magic Set predicates may
differ in various stable models, and thus can be viewed as being specialized for each stable model.

While the nature of dynamic Magic Sets intuitively seems to be more ﬁtting for disjunctive Datalog than static Magic
Sets, considering the architecture of modern reasoning systems for disjunctive Datalog substantiates this intuition: These
systems work in two phases, which may be considered as a deterministic (grounding) and a non-deterministic (model
search) part. The interface between these two is by means of a ground program, which is produced by the deterministic
phase. Static Magic Sets will almost exclusively have an impact on the grounding phase, while dynamic Magic Sets also
have the possibility to inﬂuence the model search phase. In particular, some assumptions made during the model search
may render parts of the program irrelevant to the query, which may be captured by dynamic Magic Sets, but not (or only
under very speciﬁc circumstances) by static Magic Sets.

In the literature, apart from our own work in [20], there is only one previous attempt for deﬁning a Magic Set method
for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work. The basic idea
of SMS is that bindings need to be propagated not only from rule heads to rule bodies (as in traditional Magic Sets), but also
from one head predicate to other head predicates. In addition to producing deﬁnitions for the predicates deﬁning Magic Sets,
the method also introduces additional auxiliary predicates called collecting predicates. These collecting predicates however
have a peculiar effect: Their use keeps the Magic Sets static. Indeed, both magic and collecting predicates are guaranteed
to have deterministic deﬁnitions, which implies that disjunctive Datalog systems can exploit the Magic Sets only during the
grounding phase. Most systems will actually produce a ground program which does contain neither magic nor collecting
predicates.

In this article, we propose a dynamic Magic Set method for disjunctive Datalog with stratiﬁed negation under the stable
model semantics, provide an implementation of it in the system dlv, and report on an extensive experimental evaluation.
In more detail, the contributions are:

(cid:2)

(cid:2)

(cid:2)

(cid:2)

We present a dynamic Magic Set method for disjunctive Datalog programs with stratiﬁed negation, referred to as
Dynamic Magic Sets (DMS). Different from the previously proposed static method SMS, existing systems can exploit
the information provided by the Magic Sets also during their non-deterministic model search phase. This feature
allows for potentially exponential performance gains with respect to the previously proposed static method.
We formally establish the correctness of DMS. In particular, we prove that the program obtained by the transfor-
mation DMS is query-equivalent to the original program. This result holds for both brave and cautious reasoning.
We highlight a strong relationship between Magic Sets and unfounded sets, which characterize stable models. We
can show that the atoms which are relevant for answering a query are either true or form an unfounded set,
which eventually allows us to prove the query-equivalence results.
Our results hold for a disjunctive Datalog language with stratiﬁed negation under the stable model semantics. In
the literature, several works deal with non-disjunctive Datalog with stratiﬁed negation under the well-founded or
the perfect model semantics, which are special cases of our language. For the static method SMS, an extension to
disjunctive Datalog with stratiﬁed negation has previously only been sketched in [33].

158

(cid:2)

(cid:2)

(cid:2)

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

We have implemented a DMS optimization module inside the DLV system [43]. In this way, we could exploit
the internal data-structures of the DLV system and embed DMS in the core of DLV. As a result, the technique is
completely transparent to the end user. The system is available at http://www.dlvsystem.com/magic/.
We have conducted extensive experiments on synthetic domains that highlight the potential of DMS. We have
compared the performance of the DLV system without Magic Set optimization with SMS and with DMS. The
results show that in many cases the Magic Set methods yield a signiﬁcant performance beneﬁt. Moreover, we can
show that the dynamic method DMS can yield drastically better performance than the static SMS. Importantly, in
cases in which DMS cannot be beneﬁcial (if all or most of the instantiated program is relevant for answering a
query), the overhead incurred is very light.
We also report on experiments which evaluate the impact of DMS on an industrial application scenario on real-
world data. The application involves data integration and builds on several results in the literature (for example
[5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context
stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.
By leveraging these results, DMS can be viewed as a query optimization method for inconsistent databases or for
data integration systems. The results show that DMS can yield signiﬁcant performance gains for queries of this
application.

Organization. The main body of this article is organized as follows. In Section 2, preliminaries on disjunctive Datalog and
on the Magic Set method for non-disjunctive Datalog queries are introduced. Subsequently, in Section 3 the extension DMS
for the case of disjunctive Datalog programs is presented, and we show its correctness. In Section 4 we discuss the imple-
mentation and integration of the Magic Set method within the DLV system. Experimental results on synthetic benchmarks
are reported in Section 5, while the application to data integration and its experimental evaluation is discussed in Section 6.
Finally, related work is discussed in Section 7, and in Section 8 we draw our conclusions.

2. Preliminaries

In this section, (disjunctive) Datalog programs with (stratiﬁed) negation are brieﬂy described, and the standard Magic

Set method is presented together with the notion of sideways information passing strategy (SIPS) for Datalog rules.

2.1. Disjunctive Datalog programs with stratiﬁed negation

In this paper, we adopt the standard Datalog name convention: Alphanumeric strings starting with a lowercase character
are predicate or constant symbols, while alphanumeric strings starting with an uppercase character are variable symbols;
moreover, we allow the use of positive integer constant symbols. Each predicate symbol is associated with a non-negative
integer, referred to as its arity. An atom p(¯t) is composed of a predicate symbol p and a list ¯t = t1, . . . , tk (k (cid:3) 0) of terms,
each of which is either a constant or a variable. A literal is an atom p(¯t) or a negated atom not p(¯t); in the ﬁrst case the
literal is positive, while in the second it is negative.

A disjunctive Datalog rule with negation (short: Datalog

rule) r is of the form

∨,¬

p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

∨,¬

where p1(¯t1), . . . , pn(¯tn), q1(¯s1), . . . , qm(¯sm) are atoms and n (cid:3) 1, m (cid:3) j (cid:3) 0. The disjunction p1(¯t1) ∨ · · · ∨ pn(¯tn) is the
head of r, while the conjunction q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm) is the body of r. Moreover, H(r) denotes
−(r) for denoting the sets of
the set of head atoms, while B(r) denotes the set of body literals. We also use B
atoms appearing in positive and negative body literals, respectively. If r is disjunction-free, that is n = 1, and negation-free,
+(r) is empty in addition, then we say that r is a fact.
that is B
A disjunctive Datalog program P is a ﬁnite set of rules; if all the rules in it are disjunction- and negation-free, then P is a
(standard) Datalog program.

−(r) is empty, then we say that r is a Datalog rule; if B

+(r) and B

Given a Datalog

program P , a predicate belongs to the Intensional Database (IDB) if it is either in the head of a rule
with non-empty body, or in the head of a disjunctive rule; otherwise, it belongs to the Extensional Database (EDB). The
set of rules having IDB predicates in their heads is denoted by IDB(P), while EDB(P) denotes the remaining rules, that
is, EDB(P) = P \ IDB(P). For simplicity, we assume that predicates will always be of the same type (EDB or IDB) in any
program.

The set of all constants appearing in a program P is the universe of P and is denoted by U P ,1 while the set of ground
atoms constructable from predicates in P with constants in U P is the base of P , denoted by BP . We call an atom (rule, or
program) ground if it does not contain any variables. A substitution ϑ is a function from variables to elements of U P . For an
expression S (atom, literal, rule), by Sϑ we denote the expression obtained from S by substituting all occurrences of each
variable X in S with ϑ( X). A ground atom p(¯t) (resp. ground rule r g ) is an instance of an atom p(¯t
(cid:4)) (resp. rule r) if there

1 If P has no constants, an arbitrary constant is added to U P .

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

159

(cid:4)) (resp. in r) to U P such that p(¯t) = p(¯t

(cid:4))ϑ (resp. r g = rϑ ). Given a program P ,

is a substitution ϑ from the variables in p(¯t
Ground(P) denotes the set of all possible instances of rules in P .
Given an atom p(¯t) and a set of ground atoms A, by A|

p(¯t) we denote the set of ground instances of p(¯t) belonging
p(¯t) is the set of all ground atoms obtained by applying to p(¯t) all the possible substitutions from
to A. For example, BP |
the variables in p(¯t) to U P , that is, the set of all the instances of p(¯t). Abusing notation, if B is a set of atoms, by A|B we
denote the union of all A|

p(¯t), for each p(¯t) ∈ B.
∨,¬

∨,¬

∨,¬

∨,¬

+(r). A Datalog

programs is safety. A Datalog

A desirable property of Datalog

rule r is safe if each variable appearing in r appears
in at least one atom of B
program is safe if all its rules are safe. Moreover, programs without recursion
programs. Without going into details, a predicate p in the
over negated literals constitute an interesting class of Datalog
+(r), and p
head of a rule r depends on all the predicates q in the body of r; p depends on q positively if q appears in B
−(r). A program has recursion over negation if a cycle of dependencies with at
depends on q negatively if q appears in B
least one negative dependency exists. If a program has no recursion over negation, then the program is stratiﬁed (short:
Datalog

∨,¬s ). In this work only safe programs without recursion over negation are considered.

An interpretation for a program P is a subset I of BP . A positive ground literal p(¯t) is true with respect to an interpre-
tation I if p(¯t) ∈ I ; otherwise, it is false. A negative ground literal not p(¯t) is true with respect to I if and only if p(¯t) is
false with respect to I , that is, if and only if p(¯t) /∈ I . The body of a ground rule r is true with respect to I if and only if
−(r) ∩ I = ∅. An interpretation I
all the body literals of r are true with respect to I , that is, if and only if B
satisﬁes a ground rule r ∈ Ground(P) if at least one atom in H(r) is true with respect to I whenever the body of r is true
program P if I satisﬁes all the rules in Ground(P). Since
with respect to I . An interpretation I is a model of a Datalog
an interpretation is a set of atoms, if I is an interpretation for a program P , and P (cid:4)
is another program, then by I|BP(cid:4) we
denote the restriction of I to the base of P (cid:4)

+(r) ⊆ I and B

∨,¬

.

Given an interpretation I for a program P , the reduct of P with respect to I , denoted by Ground(P)I , is obtained by
−(r g) ∩ I (cid:9)= ∅, and then by removing all the negative literals from the

deleting from Ground(P) all the rules r g with B
remaining rules.

∨,¬

∨,¬

The semantics of a Datalog

program P is given by the set SM(P) of stable models of P , where an interpretation M
is a stable model for P if and only if M is a subset-minimal model of Ground(P)M . It is well-known that there is exactly
∨,¬s program P ,
one stable model for any Datalog program, also in presence of stratiﬁed negation. However, for a Datalog
|SM(P)| (cid:3) 1 holds (Datalog

programs, instead, can also have no stable model).

Given a ground atom p(¯t) and a Datalog

program P , p(¯t) is a cautious (or certain) consequence of P , denoted by
P |(cid:10)c p(¯t), if p(¯t) ∈ M for each M ∈ SM(P); p(¯t) is a brave (or possible) consequence of P , denoted by P |(cid:10)b p(¯t), if p(¯t) ∈
M for some M ∈ SM(P). Note that brave and cautious consequences coincide for Datalog programs, as these programs
∨,¬s program P are also brave consequences of
have a unique stable model. Moreover, cautious consequences of a Datalog
P because |SM(P)| (cid:3) 1 holds in this case.

Given a query Q = g(¯t)? (an atom),2 Ansc(Q, P) denotes the set of all substitutions ϑ for the variables of g(¯t) such that

P |(cid:10)c g(¯t)ϑ , while Ansb(Q, P) denotes the set of substitutions ϑ for the variables of g(¯t) such that P |(cid:10)b g(¯t)ϑ .

Let P and P (cid:4)
are brave-equivalent with respect to Q,
, if Ansb(Q, P ∪ F ) = Ansb(Q, P (cid:4) ∪ F ) is guaranteed for each set of facts F deﬁned over predicates
Q P (cid:4)
denoted by P ≡b
which are EDB predicates of P or P (cid:4)
Q P (cid:4)
,
if Ansc(Q, P ∪ F ) = Ansc(Q, P (cid:4) ∪ F ) is guaranteed for each set of facts F deﬁned over predicates which are EDB predicates
of P or P (cid:4)

are cautious-equivalent with respect to Q, denoted by P ≡c

programs and Q a query. Then P and P (cid:4)

; similarly, P and P (cid:4)

be two Datalog

∨,¬

.

∨,¬

2.2. Bottom–up disjunctive Datalog computation

∨,¬

Many Datalog

systems implement a two-phase computation. The ﬁrst phase, referred to as program instantiation or
grounding, is bottom–up. For an input program P , it produces a ground program which is equivalent to Ground(P), but
signiﬁcantly smaller. Most of the techniques used in this phase stem from bottom–up methods developed for classic and
deductive databases; see for example [1] or [28,43] for details. Essentially, predicate instances which are known to be true
or known to be false are identiﬁed and this knowledge is used for deriving further instances of this kind. Eventually, the
truth values obtained in this way are used to produce rule instances which are not satisﬁed already. It is important to note
that this phase behaves in a deterministic way with respect to stable models. No assumptions about truth or falsity of atoms
are made, only deﬁnite knowledge is derived, which must hold in all stable models. For this reason, programs with multiple
stable models cannot be solved by grounding.

The second phase is often referred to as stable model search and takes care of the non-deterministic computation. Es-
sentially, one undeﬁned atom is selected and its truth or falsity is assumed. The assumption might imply truth or falsity
of other undeﬁned atoms. Hence, the process is repeated until either an inconsistency is derived or all atoms have been
interpreted. In the latter case an additional check is performed to ensure stability of the model. Details on this process can

2 Note that more complex queries can still be expressed using appropriate rules. We assume that each constant appearing in Q also appears in P ; if
this is not the case, then we can add to P a fact p(¯t) such that p is a predicate not occurring in P and ¯t are the arguments of Q. Question marks will be
usually omitted when referring to queries in the text.

160

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

be found for example in [23]. Query answering is typically handled by storing all admissible answer substitutions as stable
models are computed. For brave reasoning, each stable model can contribute substitutions to the set of answers. In this
case the set of answers is initially empty. For cautious reasoning, instead, each stable model may eliminate some substitu-
tions from the set of admissible answers. Therefore, in this case all possible substitutions for the input query are initially
contained in the set of answers.

2.3. Sideways information passing for Datalog rules

The Magic Set method aims at simulate a top–down evaluation of a query Q, like for instance the one adopted by Prolog.
According to this kind of evaluation, all the rules r such that p(¯t) ∈ H(r) and H(r)ϑ = {Qϑ (cid:4)} (for some substitution ϑ for
all the variables of r and some substitution ϑ (cid:4)
for all the variables of Q) are considered in a ﬁrst step. Then the atoms
+(r)ϑ are taken as subqueries (we recall that standard Datalog rules have empty negative body), and the procedure
in B
is iterated. Note that, according to this process, if a (sub)query has some argument that is bound to a constant value, this
information is “passed” to the atoms in the body. Moreover, the body is considered to be processed in a certain sequence,
and processing a body atom may bind some of its arguments for subsequently considered body atoms, thus “generating”
and “passing” bindings within the body. Whenever a body atom is processed, each of its argument is therefore considered
to be either bound or free. We illustrate this mechanism by means of an example.

Example 2.1. Let path(1, 5) be a query for a program having the following inference rules:

r1: path(X, Y ) :− edge(X, Y ).
r2: path(X, Y ) :− edge(X, Z ), path(Z , Y ).

Since this is a Datalog program, brave and cautious consequences coincide. Moreover, let F1 = {edge(1, 3), edge(2, 4),
edge(3, 5)} be the EDB of the program. A top–down evaluation scheme considers r1 and r2 with X and Y bound to 1
and 5, respectively. In particular, when considering r1, the information about the binding of the two variables is passed to
edge(X, Y), which is indeed the only query atom occurring in r1. Thus, the evaluation fails since edge(1, 5) does not occur
in F1.

When considering r2, instead, the binding information can be passed either to path(Z, Y) or to edge(X, Z). Suppose
that atoms are evaluated according to their ordering in the rule (from left to right); then edge(X, Z) is considered before
path(Z, Y). In particular, F1 contains the atom edge(1, 3), which leads us to map Z to 3. Eventually, this inferred binding
information might be propagated to the remaining body atom path(Z, Y), which hence becomes path(3, 5).

The process has now to be repeated by looking for an answer to path(3, 5). Again, rule r1 can be considered, from

which we conclude that this query is true since edge(3, 5) occurs in F1. Thus, path(1, 5) holds as well due to r2.

Note that in the example above we have two degrees of freedom in the speciﬁcation of the top–down evaluation scheme.
The ﬁrst one concerns which ordering is used for processing the body atoms. While Prolog systems are usually required to
follow the ordering in which the program is written, Datalog has a purely declarative semantics which is independent of
the body ordering, allowing for an arbitrary ordering to be adopted. The second degree of freedom is slightly more subtle,
and concerns the selection of the terms to be considered bound to constants from previous evaluations. Indeed, while we
have considered the propagation of all the binding information that originates from previously processed body atoms, it is
in general possible to restrict the top–down evaluation to partially propagate this information. For instance, one may desire
to propagate only information generated from the evaluation of EDB predicates, or even just the information that is passed
on via the head atom.

The speciﬁc propagation strategy adopted in the top–down evaluation scheme is called sideways information passing strat-
egy (SIPS), which is just a way of formalizing a partial ordering over the atoms of each rule together with the speciﬁcation
of how the bindings originated and propagate [9,33]. To formalize this concept, in what follows, for each IDB atom p(¯t),
we shall denote its associated binding information (originated in a certain step of the top–down evaluation) by means of a
string α built over the letters b and f , denoting “bound” and “free”, respectively, for each argument of p(¯t).

Deﬁnition 2.2 (SIPS for Datalog rules). A SIPS for a Datalog rule r with respect to a binding α for the atom p(¯t) ∈ H(r) is a
pair (≺α

r , f α

r ), where:

is a strict partial order over the atoms in H(r) ∪ B
is a function assigning to each atom q(¯s) ∈ H(r) ∪ B

(1) ≺α
r
(2) f α
r
when processing q(¯s).

+(r), such that p(¯t) ≺α
+(r) a subset of the variables in ¯s—intuitively, those made bound

r q(¯s), for all atoms q(¯s) ∈ B

+(r); and,

Intuitively, for each atom q(¯s) occurring in r, the strict partial order ≺α

before processing atom q(¯s). Eventually, an argument X of q(¯s) is bound to a constant if there exists an atom q
that q

(cid:4))). Note that the head atom p(¯t) precedes all other atoms in ≺α
r .

r q(¯s) and X ∈ f α

(cid:4)) ≺α

r (q

(cid:4)(¯s

(cid:4)(¯s

r speciﬁes those atoms that have to be processed
(cid:4)) such

(cid:4)(¯s

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

161

Example 2.3. The SIPS we have adopted in Example 2.1 for r1 with respect to the binding bb (originating from the query
path(1, 5)) can be formalized as the pair (≺bb
(path(X, Y)) = {X, Y}, and
r1
f bb
(edge(X, Y)) = ∅. Instead, the SIPS we have adopted for r2 with respect to the binding bb can be formalized as the
r1
pair (≺bb
path(Z, Y), f bb
(edge(X, Z)) = {Z}, and
r2
r2
f bb
r2

, f bb
r2
(path(Z, Y)) = ∅.

(path(X, Y)) = {X, Y}, f bb
r2

), where path(X, Y) ≺bb
r1

), where path(X, Y) ≺bb
r2

edge(X, Z) ≺bb
r2

edge(X, Y),

, f bb
r1

f bb
r1

All the algorithms and techniques we shall develop in this paper are orthogonal with respect to the underlying SIPSes
to be used in the top–down evaluation. Thus, in Section 2.4, we shall assume that Datalog programs are provided in input
together with some arbitrarily deﬁned SIPS (≺α
r ), for each rule r and for each possible adornment α for the head atom
in H(r).

r , f α

2.4. Magic Sets for Datalog programs

The Magic Set method is a strategy for simulating the top–down evaluation of a query by modifying the original program
by means of additional rules, which narrow the computation to what is relevant for answering the query. We next provide a
brief and informal description of the Magic Set rewriting technique. The reader is referred to [63] for a detailed presentation.

The method is structured in four main phases, which are informally illustrated below by means of Example 2.1.

(1) Adornment. The key idea is to materialize the binding information for IDB predicates that would be propagated during
a top–down computation. In particular, the fact that an IDB predicate p(¯t) is associated with a binding information α (i.e.,
a string over the letters b and f , one for each term in ¯t) is denoted by the atom obtained adorning the predicate symbol
with the binding at hand, that is, by pα(¯t). In what follows, the predicate pα is said to be an adorned predicate.

First, adornments are created for query predicates so that an argument occurring in the query is adorned with the letter
if it is a variable. For instance, the adorned version of the query atom path(1, 5)

b if it is a constant, or with the letter f
is pathbb(1, 5), which gives rise to the adorned predicate pathbb.

Each adorned predicate is eventually used to propagate its information into the body of the rules deﬁning it according
to a SIPS, thereby simulating a top–down evaluation. In particular, assume that the binding α has to be propagated into a
rule r whose head is p(¯t). Thus, the associated SIPS (≺α
r ) determines which variables will be bound in the evaluation
of the various body atoms. Indeed, a variable X of an atom q(¯s) in r is bound if and only if either

r , f α

(1) X ∈ f α
(2) X ∈ f α

r (q(¯s)) with q(¯s) = p(¯t); or,
r (b(¯z)) for an atom b(¯z) ∈ B

+(r) such that b(¯z) ≺α

r q(¯s) holds.

Adorning a rule r with respect to an adorned predicate pα means propagating the binding information α, starting from
the head predicate p(¯t) ∈ H(r), thereby creating a novel adorned rule where all the IDB predicates in r are substituted by
the adorned predicates originating from the binding according to (1) and (2).

Example 2.4. Adorning the query path(1, 5) generates pathbb(1, 5). Then, propagating the binding information bb into
the rule r1, i.e., when adorning r1 with pathbb, produces the following adorned rule (recall here that adornments apply
only to IDB predicates, whereas edge is an EDB predicate):

1: pathbb(X, Y) :− edge(X, Y).
ra

Instead, when propagating bb into the rule r2 according to the SIPS (≺bb
r2
following adorned rule:

, f bb
r2

) deﬁned in Example 2.3 we obtain the

2: pathbb(X, Y) :− edge(X, Z), pathbb(Z, Y).
ra

While adorning rules, novel binding information in the form of yet unseen adorned predicates may be generated, which
should be used for adorning other rules. In fact, the adornment step is repeated until all bindings have been processed,
yielding the adorned program, which is the set of all adorned rules created during the computation. For instance, in the
2 for no adorned predicate different from pathbb is gener-
above example, the adorned program just consists of ra
ated.

1 and ra

(2) Generation. In the second step of the Magic Set method, the adorned program is used to generate magic rules, which
are used to simulate the top–down evaluation scheme and to single out the atoms relevant for answer the input query.
For an adorned atom pα(¯t), let magic(pα(¯t)) be its magic version deﬁned as the atom magic_pα(¯t
is obtained
from ¯t by eliminating all arguments corresponding to an f
label in α, and where magic_pα is a new predicate symbol (for
simplicity denoted by attaching the preﬁx “magic_” to the predicate symbol pα ). Intuitively, magic_pα(¯t
(cid:4))ϑ (ϑ a substitution)
is inferred by the rules of the rewritten program whenever a top–down evaluation of the original program would process a
subquery of the form pα(¯t

is obtained from ¯t by applying ϑ to all terms in ¯t

(cid:4)(cid:4)), where ¯t

(cid:4)), where ¯t

(cid:4)(cid:4)

.

(cid:4)

(cid:4)

162

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

Thus, if q

head, a magic rule r

i (¯si) is an adorned atom (i.e., βi is not the empty string) in the body of an adorned rule ra having pα(¯t) in
βi
∗) is the union of {magic(pα(¯t))} and
βi
i (¯si))} and (ii) B(r

is generated such that (i) H(r

∗

the set of all the atoms q

β j
j (¯s j) ∈ B

+(r) such that q j(¯s j) ≺α

∗) = {magic(q
r qi(¯si).

Example 2.5. In our running example, only one magic rule is generated,

∗
2: magic_pathbb(Z, Y) :− magic_pathbb(X, Y), edge(X, Z).

r

In fact, the adorned rule ra

1 does not produce any magic rule, since there is no adorned predicate in B

+(ra

1).

(3) Modiﬁcation. The adorned rules are subsequently modiﬁed by adding magic atoms to their bodies. These magic atoms
limit the range of the head variables avoiding the inference of facts which cannot contribute to the derivation of the query.
In particular, each adorned rule ra, whose head atom is pα(¯t), is modiﬁed by adding the atom magic(pα(¯t)) to its body. The
resulting rules are called modiﬁed rules.

Example 2.6. In our running example, the following modiﬁed rules are generated:

(cid:4)
1: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Y).
(cid:4)
2: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Z), pathbb(Z, Y).

r

r

(4) Processing the Query. Finally, given the adorned predicate gα obtained when adorning a query g(¯t), (1) a magic seed
magic(gα(¯t)) (a fact) and (2) a rule g(¯t) :− gα(¯t) are produced. In our example, magic_pathbb(1, 5) and path(X, Y) :−
pathbb(X, Y) are generated.

The complete rewritten program according to the Magic Set method consists of the magic, modiﬁed, and query rules
, it is well-known

(together with the original EDB). Given a Datalog program P , a query Q, and the rewritten program P (cid:4)
that P and P (cid:4)

are equivalent with respect to Q, i.e., P ≡b

and P ≡c

hold [63].

Q P (cid:4)

Q P (cid:4)

Example 2.7. The complete rewriting of our running example is as follows:3

magic_pathbb(1, 5).
path(X, Y) :− pathbb(X, Y).

∗
2: magic_pathbb(Z, Y) :− magic_pathbb(X, Y), edge(X, Z).
(cid:4)
1: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Y).
(cid:4)
2: pathbb(X, Y) :− magic_pathbb(X, Y), edge(X, Z), pathbb(Z, Y).

r

r

r

In this rewriting, magic_pathbb(X, Y) represents a potential sub-path of the paths from 1 to 5. Therefore, when answering
the query, only these sub-paths will be actually considered in the bottom–up computation. One can check that this rewriting
is in fact equivalent to the original program with respect to the query path(1, 5).

3. Magic Set method for Datalog

∨,¬s programs

In this section we present the Dynamic Magic Set algorithm (DMS) for the optimization of disjunctive programs with
stratiﬁed negation. Before discussing the details of the algorithm, we informally present the main ideas that have been
exploited for enabling the Magic Set method to work on disjunctive programs (without negation).

3.1. Overview of binding propagation in Datalog

∨

programs

As ﬁrst observed in [33], while in non-disjunctive programs bindings are propagated only head-to-body, a Magic Set
transformation for disjunctive programs has to propagate bindings also head-to-head in order to preserve soundness.
Roughly, suppose that a predicate p is relevant for the query, and a disjunctive rule r contains p( X) in the head. Then,
besides propagating the binding from p( X) to the body of r (as in the non-disjunctive case), the binding must also be
propagated from p( X) to the other head atoms of r. The reason is that any atom which is true in a stable model needs a
supporting rule, which is a rule with a true body and in which the atom in question is the only true head atom. Therefore,
r can yield support to the truth of p( X) only if all other head atoms are false, which is due to the implicit minimality
criterion in the semantics.

3 The Magic Set rewriting of a program P affects only IDB(P), so we usually omit EDB(P) in examples.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

163

∨,¬s program P , and a query Q = g(¯t)?

Algorithm DMS(Q, P )
Input: A Datalog
Output: The rewritten program DMS(Q, P);
var: S, D: set of adorned predicates; modiﬁedRulesQ,P , magicRulesQ,P : set of rules;
begin

pα := an element of S; remove pα from S; add pα to D;
for each rule r ∈ P and for each atom p(¯t) ∈ H(r) do

1. S := ∅; D := ∅; modiﬁedRulesQ,P := ∅; magicRulesQ,P := {BuildQuerySeed(Q, S)};
2. while S (cid:9)= ∅ do
3.
4.
5.
6.
7.
8.
end for
9. end while
10. DMS(Q, P) := magicRulesQ,P ∪ modiﬁedRulesQ,P ∪ EDB(P);
11. return DMS(Q, P);

ra := Adorn(r, pα (¯t), S, D);
magicRulesQ,P := magicRulesQ,P ∪ Generate(r, pα (¯t), ra);
modiﬁedRulesQ,P := modiﬁedRulesQ,P ∪ {Modify(r, ra)};

end.

Fig. 1. Dynamic Magic Set algorithm (DMS) for Datalog

∨,¬s programs.

∨

Consider, for instance, a Datalog

program P consisting of the rule p(X) ∨ q(Y) :− a(X, Y), b(X), and the query p(1).
Even though the query propagates the binding for the predicate p, in order to correctly answer the query we also need
to evaluate the truth value of q(Y), which indirectly receives the binding through the body predicate a(X, Y). For instance,
suppose that the program contains the facts a(1, 2) and b(1); then the atom q(2) is relevant for the query p(1) (i.e., it
should belong to the Magic Set of the query), since the truth of q(2) would invalidate the derivation of p(1) from the above
rule, due to the minimality of the semantics. It follows that, while propagating the binding, the head atoms of disjunctive
rules must be all adorned as well.

However, the adornment of the head of one disjunctive rule r may give rise to multiple rules, having different adorn-
ments for the head predicates. This process can be somehow seen as “splitting” r into multiple rules. While this is not a
problem in the non-disjunctive case, the semantics of a disjunctive program may be affected. Consider, for instance, the pro-
gram consisting of the rule p(X, Y) ∨ q(Y, X) :− a(X, Y), in which p and q are mutually exclusive (due to minimality) since
they do not appear in any other rule head. Assuming the adornments pbf and qbf to be propagated, we might obtain rules
whose heads have the form pbf(X, Y) ∨ qfb(Y, X) (derived while propagating pbf) and pfb(X, Y) ∨ qbf(Y, X) (derived while
propagating qbf). These rules could support two atoms pbf(m, n) and qbf(n, m), while in the original program p(m, n) and
p(n, m) could not hold simultaneously (due to semantic minimality), thus changing the original semantics.

The method proposed in [33] circumvents this problem by using some auxiliary predicates that collect all facts coming
from the different adornments. For instance, in the above example, two rules of the form collect_p(X, Y) :− pfb(X, Y)
and collect_p(X, Y) :− pbf(X, Y) are added for the predicate p. The main deﬁciency of this approach is that collecting
predicates will store a sizable superset of all the atoms relevant to answer the given query.

An important observation is that these collecting predicates are deﬁned in a deterministic way. Since these predicates
are used for restricting the computation in [33], a consequence is that assumptions during the computation cannot be
exploited for determining the relevant part of the program. In terms of bottom–up systems, this implies that the optimiza-
tion affects only the grounding portion of the solver. Intuitively, it would be beneﬁcial to also have a form of conditional
relevance, exploiting also relevance for assumptions. In fact, in Section 5, we provide experimental evidence for this intu-
ition.

In the following, we propose a novel Magic Set method that guarantees query equivalence and also allows for the

exploitation of conditional or dynamic relevance, overcoming a major drawback of SMS.

3.2. DMS algorithm

Our proposal to enhance the Magic Set method for disjunctive Datalog programs has two crucial features compared to

the one of [33]:

(1) First, the semantics of the program is preserved by stripping off the adornments from non-magic predicates in modiﬁed
rules, and not by introducing collecting predicates that can introduce overhead in the grounding process, as discussed
in Section 3.1.

(2) Second, the proposed Magic Set technique is not just a way to cut irrelevant rules from the ground program; in fact,
it allows for dynamic determination of relevance, thus optimizing also the non-deterministic computation by disabling
parts of the programs which are not relevant in any extension of the current computation state.

The algorithm DMS implementing these strategies is reported in Fig. 1 as pseudo-code. We assume that all variables
are passed to functions by reference, in particular the variable S is modiﬁed inside BuildQuerySeed and Adorn. Its input

164

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

Function BuildQuerySeed(Q, S)
Input: Q: query; S: set of adorned predicates;
Output: The query seed (a magic atom);
var: α: adornment string;
begin

1. Let p(¯t) be the atom in Q.
2. α := (cid:6);
3. for each argument t in ¯t do
4.
5. end for
6. add pα to S;
7. return magic(pα (¯t));

if t is a constant then α := αb; else α := α f ; end if

end.

Fig. 2. BuildQuerySeed function.

∨,¬s program4 P and a query Q. The algorithm uses two sets, S and D, to store adorned predicates to be
is a Datalog
propagated and already processed, respectively. After all the adorned predicates have been processed, the method outputs a
rewritten program DMS(Q, P) consisting of a set of modiﬁed and magic rules, stored by means of the sets modiﬁedRulesQ,P
and magicRulesQ,P , respectively (together with the original EDB). The main steps of the algorithm are illustrated by means
of the following running example.

Example 3.1 (Strategic Companies [15]). Let C = {c1, . . . , cm} be a collection of companies producing some goods in a set G,
(cid:4) ⊆ C is a
such that each company ci ∈ C is controlled by a set of other companies O i ⊆ C . A subset of the companies C
produce all the goods in
strategic set if it is a minimal set of companies satisfying the following conditions: Companies in C
G; and O i ⊆ C

, for each i = 1, . . . , m.

implies ci ∈ C

(cid:4)

(cid:4)

(cid:4)

We assume that each product is produced by at most two companies and that each company is controlled by at
most three companies. It is known that the problem retains its hardness (for the second level of the polynomial hierar-
chy; see [15]) under these restrictions. We assume that production of goods is represented by an EDB containing a fact
produced_by(p, c1, c2) for each product p produced by companies c1 and c2, and that the control is represented by facts
controlled_by(c, c1, c2, c3) for each company c controlled by companies c1, c2, and c3.5 This problem can be modeled
via the following disjunctive program Psc:

r3: sc(C1) ∨ sc(C2) :− produced_by(P, C1, C2).
r4: sc(C) :− controlled_by(C, C1, C2, C3), sc(C1), sc(C2), sc(C3).

Moreover, given a company c ∈ C , we consider a query Qsc = sc(c) asking whether c belongs to some strategic set of C .

The computation starts in step 1 by initializing S, D, and modiﬁedRulesQ,P to the empty set. Then, the function Build-
QuerySeed(Q, S) is used for storing in magicRulesQ,P the magic seed, and inserting in the set S the adorned predicate
of Q. Note that we do not generate any query rules because standard atoms in the transformed program will not contain
adornments. Details of BuildQuerySeed(Q, S) are reported in Fig. 2.

Example 3.2. Given the query Qsc = sc(c) and the program Psc,
magic_scb(c) and inserts scb in S.

function BuildQuerySeed(Qsc, S) creates the fact

The core of the algorithm (steps 3–8) is repeated until the set S is empty, i.e., until there is no further adorned predicate
to be propagated. In particular, an adorned predicate pα is moved from S to D in step 3, and its binding is propagated in
each (disjunctive) rule r ∈ P of the form

r:

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

(with n (cid:3) 0) having an atom p(¯t) in the head (note that the rule r is processed a number of times that equals the number
of head atoms with predicate p; steps 4–8).

(1) Adornment. Step 5 in Fig. 1 implements the adornment of the rule. Different from the case of non-disjunctive positive
programs, the binding of the predicate pα needs to be also propagated to the atoms p1(¯t1), . . . , pn(¯tn) in the head. Therefore,
binding propagation has to be extended to the head atoms different from p(¯t), which are therefore adorned according to

4 Note that the algorithm can be used for non-disjunctive and/or positive programs as a special case.
5 If a product is produced by only one company, c2 = c1, and similarly for companies controlled by fewer than three companies.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

165

Function Adorn(r, pα (¯t), S, D)
Input: r: rule; pα (¯t): adorned atom; S, D: set of adorned predicates;
Output: an adorned rule;
var: ra : adorned rule; αi : adornment string;
begin

) be the SIPS associated with r and pα (¯t).

, f

pα (¯t)
r

Let (≺pα (¯t)
r
ra := r;
for each IDB atom pi (¯ti ) in H(r) ∪ B

αi := (cid:6);
for each argument t in ¯t do
if t is a constant then

+(r) ∪ B

−(r) do

αi := αib;

else

Argument t is a variable. Let X be this variable.
if X ∈ f

(p(¯t)) or there is q(¯s) in B
q(¯s) ≺pα (¯t)

pα (¯t)
r

+(r) such that

pi (¯ti ) and X ∈ f

r

αi := αib;

else

αi := αi f ;

end if

pα (¯t)
r

(q(¯s)) then

end if
end for
substitute pi (¯ti ) in ra with p
αi
if set D does not contain p
i

αi
i (¯ti );
then add p

αi
i

to S; end if

1.
2.
3.
4.
5.
6.
7.
8.
9.

10.

11.
12.
13.
14.
15.
16.
17.
18.

19.
20. end for
21.
end.

return ra ;

Fig. 3. Adorn function.

a SIPS speciﬁcally conceived for disjunctive programs. Notation gets slightly more involved here: Since in non-disjunctive
rules there is a single head atom, it was suﬃcient to specify an order and a function for each of its adornments (omitting
the head atom in the notation). With disjunctive rules, an order and a function need to be speciﬁed for each adorned head
atom, so it is no longer suﬃcient to include only the adornment in the notation, but we rather include the full adorned
atom.

Deﬁnition 3.3 (SIPS for Datalog
is a pair (≺pα (¯t)

), where:

pα (¯t)
r

, f

r

∨,¬s rules). A SIPS for a Datalog

∨,¬s rule r with respect to a binding α for an atom p(¯t) ∈ H(r)

(1) ≺pα (¯t)

r

is a strict partial order over the atoms in H(r) ∪ B
+(r) ∪ B
q(¯s), for all atoms q(¯s) ∈ H(r) ∪ B

(a) p(¯t) ≺pα (¯t)
(b) for each pair of atoms q(¯s) ∈ (H(r) \ {p(¯t)}) ∪ B

r

+(r) ∪ B
−(r), such that:
−(r) different from p(¯t);

−(r) and b(¯z) ∈ H(r) ∪ B

+(r) ∪ B

−(r), q(¯s) ≺pα (¯t)

r

b(¯z) does not hold;

and,

(2) f

pα (¯t)
r
made bound when processing q(¯s).

is a function assigning to each atom q(¯s) ∈ H(r) ∪ B

+(r) ∪ B

−(r) a subset of the variables in ¯s—intuitively, those

As for Datalog rules, for each atom q(¯s) occurring in r, the strict partial order ≺pα (¯t)

speciﬁes those atoms that have to
(cid:4))
(cid:4)(¯s
be processed before processing atom q(¯s), and an argument X of q(¯s) is bound to a constant if there exists an atom q
(cid:4))). The difference with respect to SIPSes for Datalog rules is
(cid:4)(¯s
occurring in r such that q
precisely in the dependency from p(¯t) in addition to α, and in condition (1.b) stating that head atoms different from p(¯t)
and negative body literals cannot provide bindings to variables of other atoms.

q(¯s) and X ∈ f

(cid:4)) ≺pα (¯t)

pα (¯t)
r

(cid:4)(¯s

(q

r

r

The underlying idea is that a rule which is used to “prove” the truth of an atom in a top–down method will be a rule
which supports that atom. This implies that all other head atoms in that rule must be false and that the body must be true.
Head atoms and atoms occurring in the negative body cannot “create” bindings (that is, restrict the values of variables), but
these atoms are still relevant to the query, which leads to the restrictions in Deﬁnition 3.3.

Note that this deﬁnition considers each rule in isolation and is therefore independent of the inter-rule structure of a

program. In particular, it is not important for the SIPS deﬁnition whether a program is cyclic or contains head cycles.

In the following, we shall assume that each Datalog

∨,¬s program is provided in input together with some arbitrarily
), the adornment can be carried out
deﬁned SIPS for Datalog
precisely as we discussed for Datalog programs; in particular, we recall here that a variable X of an atom q(¯s) in r is bound
if and only if either:

). In fact, armed with (≺pα (¯t)

∨,¬s rules (≺pα (¯t)

pα (¯t)
r

pα (¯t)
r

, f

, f

r

r

166

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

(1) X ∈ f
(2) X ∈ f

pα (¯t)
r
pα (¯t)
r

(q(¯s)) with q(¯s) = p(¯t); or,
(b(¯z)) for an atom b(¯z) ∈ B

+(r) such that b(¯z) ≺pα (¯t)

r

q(¯s) holds.

The function Adorn(r, pα(¯t), S, D) produces an adorned disjunctive rule ra from an adorned atom pα(¯t) and a suit-
able unadorned rule r (according to the bindings deﬁned in the points (1) and (2) above), by inserting all newly adorned
predicates in S. Hence, in step 5 the rule ra is of the form

ra:

pα(¯t) ∨ p

α1
1 (¯t1) ∨ · · · ∨ p

αn
n (¯tn) :− q

β1
1 (¯s1), . . . , q

β j
j (¯s j), not q

β j+1
j+1 (¯s j+1), . . . , not q

βm
m (¯sm).

Details of Adorn(r, pα(¯t), S, D) are reported in Fig. 3.

Example 3.4. Let us resume from Example 3.2. We are supposing that the adopted SIPS is passing the bindings via
produced_by and controlled_by to the variables of sc atoms, in particular
sc(C1) ≺scb(C1)
sc(C1) ≺scb(C1)
produced_by(P, C1, C2) ≺scb(C1)

produced_by(P, C1, C2)

sc(C2)

sc(C2)

r3

r3

r3

sc(C2) ≺scb(C2)
sc(C2) ≺scb(C2)
produced_by(P, C1, C2) ≺scb(C2)

r3

r3

r3

r4

r4

sc(C) ≺scb(C)
sc(C) ≺scb(C)
sc(C) ≺scb(C)
sc(C) ≺scb(C)
controlled_by(C, C1, C2, C3) ≺scb(C)
controlled_by(C, C1, C2, C3) ≺scb(C)
controlled_by(C, C1, C2, C3) ≺scb(C)

r4

r4

r4

r4

r4

produced_by(P, C1, C2)

sc(C1)

sc(C1)

controlled_by(C, C1, C2, C3)

sc(C1)

sc(C2)

sc(C3)

sc(C1)

sc(C2)

sc(C3)

= ∅

= {C1}

(cid:2)
(cid:3)
sc(C1)
(cid:2)
(cid:3)
produced_by(P, C1, C2)
(cid:2)
(cid:3)
sc(C2)
(cid:2)
(cid:3)
sc(C2)
(cid:2)
(cid:3)
produced_by(P, C1, C2)
(cid:2)
(cid:3)
sc(C1)
(cid:3)
sc(C)

= {C2}

= {C}

= ∅

= {P, C2}

= {P, C1}

scb(C1)
r3
scb(C1)
r3
scb(C1)
r3

scb(C2)
r3
scb(C2)
r3
scb(C2)
r3

(cid:2)

scb(C)
r4
scb(C)
r4
scb(C)
r4

f

f

f

f

f

f

f

f

f

(cid:2)

(cid:3)
controlled_by(C, C1, C2, C3)

= {C1, C2, C3}

(cid:2)

sc(C1)

(cid:3)

= f

scb(C)
r4

(cid:2)

(cid:3)
sc(C2)

= f

scb(C)
r4

(cid:2)

(cid:3)
sc(C3)

= ∅

When scb is removed from the set S, we ﬁrst select rule r3 and the head predicate sc(C1). Then the adorned version is

3,1: scb(C1) ∨ scb(C2) :− produced_by(P, C1, C2).
ra

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

167

Function Generate(r, pα (¯t), ra )
Input: r: rule; pα (¯t): adorned atom; ra : adorned rule;
Output: a set of magic rules;
: rule;
var: R: set of rules; r
begin

∗

Let (≺pα (¯t)

, f

pα (¯t)
r

) be the SIPS associated with r and pα (¯t).

1.
r
2. R := ∅;
3.
4.
5.

αi
i (¯ti ) in H(ra) ∪ B
αi
i (¯ti )) :− magic(pα (¯t));

for each atom p
if αi (cid:9)= (cid:6) then
∗ := magic(p
r
for each atom p j (¯t j ) in B
add atom p j (¯t j ) to B
+(r

+(r) such that p j (¯t j ) ≺pα (¯t)
∗);

r

pi (¯ti ) do

+(ra) ∪ B

−(ra) different from pα (¯t) do

end for
R := R ∪ {r

6.
7.
8.
9.
end if
10.
11. end for
12.
end.

return R;

∗};

Fig. 4. Generate function.

Next, r3 is processed again, this time with head predicate sc(C2), producing

3,2: scb(C2) ∨ scb(C1) :− produced_by(P, C1, C2).
ra

Finally, processing r4 we obtain

4: scb(C) :− controlled_by(C, C1, C2, C3), scb(C1), scb(C2), scb(C3).
ra

(2) Generation. The algorithm uses the adorned rule ra for generating and collecting the magic rules in step 6 (Fig. 1).
αi
More speciﬁcally, Generate(r, pα(¯t), ra) produces magic rules according to the following schema: if p
i (¯ti) is an adorned
atom (i.e., αi is not the empty string) occurring in ra and different from pα(¯t), a magic rule r
is generated such that (i)
+(r) such that
H(r
q j(¯s j) ≺α

∗) is the union of {magic(pα(¯t))} and the set of all the atoms q

r pi(¯ti). Details of Generate(r, pα(¯t), ra) are reported in Fig. 4.

αi
i (¯ti))} and (ii) B(r

∗) = {magic(p

β j
j (¯s j) ∈ B

∗

Example 3.5. Continuing with our running example, by invoking Generate(r3, scb(C1), ra
produced:

3,1), the following magic rule is

∗
3,1: magic_scb(C2) :− magic_scb(C1), produced_by(P, C1, C2).

r

Similarly, by invoking Generate(r3, scb(C2), ra

3,2), the following magic rule is produced:

∗
3,2: magic_scb(C1) :− magic_scb(C2), produced_by(P, C1, C2).

r

Finally, the following magic rules are produced by Generate(r4, scb(C), ra

4):

∗
4,1: magic_scb(C1) :− magic_scb(C), controlled_by(C, C1, C2, C3).
∗
4,2: magic_scb(C2) :− magic_scb(C), controlled_by(C, C1, C2, C3).
∗
4,3: magic_scb(C3) :− magic_scb(C), controlled_by(C, C1, C2, C3).

r

r

r

(3) Modiﬁcation. In step 7 the modiﬁed rules are generated and collected. The only difference with respect to the Datalog
case is that the adornments are stripped off the original atoms. Speciﬁcally, given an adorned rule ra associated with a rule
is obtained from r by adding to its body an atom magic(pα(¯t)) for each atom pα(¯t) occurring in H(ra).
r, a modiﬁed rule r
(cid:4)
Hence, the function Modify(r, ra), reported in Fig. 5, constructs a rule r

(cid:4)

(cid:4)

:

r

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic

(cid:2)

of the form
(cid:3)
(cid:3)
α1
αn
n (¯tn)
1 (¯t1)
q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

(cid:3)
pα(¯t)

, . . . , magic

, magic

p

p

(cid:2)

(cid:2)

,

Finally, after all the adorned predicates have been processed, the algorithm outputs the program DMS(Q, P).

168

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

(cid:4)

: rule;

Function Modify(r, ra )
Input: r: rule; ra : adorned rule;
Output: a modiﬁed rule;
var: r
begin
1.
2.
3.
4. end for
return r
5.
end.

add magic(pα (¯t)) to B

;

(cid:4)

(cid:4) := r;
r
for each atom pα (¯t) in H(ra) do

+(r

(cid:4));

Fig. 5. Modify function.

Example 3.6. In our running example, we derive the following set of modiﬁed rules:

r

r

(cid:4)
3,1: sc(C1) ∨ sc(C2) :− magic_scb(C1), magic_scb(C2), produced_by(P, C1, C2).
(cid:4)
3,2: sc(C2) ∨ sc(C1) :− magic_scb(C2), magic_scb(C1), produced_by(P, C1, C2).
(cid:4)
4: sc(C) :− magic_scb(C), controlled_by(C, C1, C2, C3), sc(C1), sc(C2), sc(C3).
r

(cid:4)
3,1 (resp. r

3,2, ra
Here, r
4).
Thus, the optimized program DMS(Qsc, Psc) comprises the above modiﬁed rules as well as the magic rules in Example 3.5,
and the magic seed magic_scb(c) (together with the original EDB).

(cid:4)
4) is derived by adding magic predicates and stripping off adornments for the rule ra

3,1 (resp. ra

(cid:4)
3,2, r

Before establishing the correctness of the technique, we brieﬂy present an example of the application of DMS on a

program containing disjunction and stratiﬁed negation.

Example 3.7. Let us consider a slight variant of the Strategic Companies problem described in Example 3.1 in which we have
to determine whether a given company c does not belong to any strategic set. We can thus consider the query nsc(c) for
the program Pnsc obtained by adding to Psc the following rule:

rnsc: nsc(C) :− company(C), not sc(C).

where company is an EDB predicate. Company c does not belong to any strategic set if the query is cautiously false.

In this case, processing the query produces the query seed magic_nscb(c) (a fact) and the adorned predicate nscb
(which is added to set S). After that, nscb is moved from S to D and rule rnsc is considered. Assuming the following SIP:

nsc(C) ≺nscb(C)
nscb(C)
rnsc

rnsc
(nsc(C)) = {C}

f

company(C)

nsc(C) ≺nscb(C)
rnsc
(company(P)) = f

sc(C)

nscb(C)
rnsc
by invoking Adorn(rnsc, nscb(C), S, D) we obtain the following adorned rule:

nscb(C)
rnsc

f

(sc(C)) = ∅

nsc: nscb(C) :− company(C), not scb(C).
ra

The new adorned predicate scb is added to S. Then, Generate(rnsc, nscb(C), ra
ing magic and modiﬁed rules:

nsc) and Modify(rnsc, ra

nsc) produce the follow-

∗
nsc: magic_scb(C) :− magic_nscb(C).
(cid:4)
nsc: nsc(C) :− magic_nscb(C), company(C), not sc(C).

r

r

The algorithm then processes the adorned atom scb. Hence, if the SIPS presented in Example 3.4 is assumed, the rewritten
∗
nsc , r
program comprises the following rules: r

(cid:4)
nsc , r

∗
4,2 and r

(cid:4)
3,1, r

∗
4,1, r

∗
3,1, r

∗
3,2, r

(cid:4)
3,2, r

(cid:4)
4, r

∗
4,3.

3.3. Query equivalence result

We conclude the presentation of the DMS algorithm by formally proving its correctness. We would like to point out
that all of these results hold for any kind of SIPS, as long as it conforms to Deﬁnition 3.3. Therefore, in the remainder of
this section, we assume that any program comes with some associated SIPS. In the proofs, we use the well established
notion of unfounded set for disjunctive Datalog programs (possibly with negation) deﬁned in [44]. Before introducing un-
founded sets, however, we have to deﬁne partial interpretations, that is, interpretations for which some atoms may be
undeﬁned.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

169

Deﬁnition 3.8 (Partial interpretation). Let P be a Datalog
program. A partial interpretation for P is a pair (cid:14)T , N(cid:15) such that
T ⊆ N ⊆ BP . The atoms in T are interpreted as true, while the atoms in N are not false and those in N \ T are undeﬁned.
All other atoms are false.

∨,¬

Note that total interpretations are a special case in which T = N. We can then formalize the notion of unfounded set.

program P , and X ⊆ BP be a set of
Deﬁnition 3.9 (Unfounded sets). Let (cid:14)T , N(cid:15) be a partial interpretation for a Datalog
atoms. Then, X is an unfounded set for P with respect to (cid:14)T , N(cid:15) if and only if, for each ground rule r g ∈ Ground(P) with
X ∩ H(r g) (cid:9)= ∅, at least one of the following conditions holds:

∨,¬

+(r g) (cid:2) N;
(1.a) B
−(r g) ∩ T (cid:9)= ∅;
(1.b) B
+(r g) ∩ X (cid:9)= ∅;
(2) B
(3) H(r g) ∩ (T \ X) (cid:9)= ∅.

Intuitively, conditions (1.a), (1.b) and (3) check if the rule is satisﬁed by (cid:14)T , N(cid:15) regardless of the atoms in X , while

condition (2) checks whether the rule can be satisﬁed by taking the atoms in X as false.

Example 3.10. Consider again the program Psc of Example 3.1 and assume EDB(Psc) = {produced_by(p, c, c1)}. Then
Ground(Psc) consists of the rule

rsc: sc(c) ∨ sc(c1) :− produced_by(p, c, c1).

(together with facts, and rules having some ground instance of EDB predicate not occurring in EDB(Psc), omitted for sim-
plicity). Consider now a partial interpretation (cid:14)Msc, BPsc
(cid:15) such that Msc = {produced_by(p, c, c1), sc(c)}. Thus, {sc(c1)}
is an unfounded set for P with respect to (cid:14)Msc, BPsc
(cid:15) (rsc satisﬁes condition (3) of Deﬁnition 3.9), while {sc(c), sc(c1)} is
not (rsc violates all conditions).

The following is an adaptation of Theorem 4.6 in [44] to our notation.

Theorem 3.11. (See [44].) Let (cid:14)T , N(cid:15) be a partial interpretation for a Datalog
that T ⊆ M ⊆ N, and for each unfounded set X of P with respect to (cid:14)T , N(cid:15), M ∩ X = ∅ holds.

∨,¬

program P . Then, for any stable model M of P such

Example 3.12. In Example 3.10, we have shown that {sc(c1)} is an unfounded set for P with respect to (cid:14)Msc, BPsc
that the total interpretation Msc is a stable model of Psc, and that the unfounded set {sc(c1)} is disjoint from Msc.

(cid:15). Note

(cid:4)

Equipped with these notions and Theorem 3.11, we now proceed to prove the correctness of the DMS strategy. In
particular, we shall ﬁrst show that the method is sound in that, for each stable model M of DMS(Q, P), there is a sta-
(cid:4)|Q = M|Q (i.e., the two models coincide when restricted to the query). Then, we prove
ble model M
of P , there is a stable model M of DMS(Q, P) such that
that the method is also complete, i.e., for each stable model M
M

(cid:4)|Q = M|Q.
In both parts of the proof, we shall exploit the following (syntactic) relationship between the original program and the

of P such that M

(cid:4)

transformed one.

Lemma 3.13. Let P be a Datalog
transformed program). Then the ground rule

∨,¬s program, Q a query, and let magic(pα(¯t)) be a ground atom6 in BDMS(Q,P) (the base of the

r g :

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

belongs to Ground(P) if and only if the ground rule

(cid:4)
g :

r

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic

(cid:2)

(cid:2)

(cid:3)
pα(¯t)

(cid:3)
(cid:3)
α1
αn
n (¯tn)
1 (¯t1)
q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

, . . . , magic

, magic

p

p

(cid:2)

,

belongs to Ground(DMS(Q, P)).

6 Note that in this way the lemma refers only to rules that contain a head atom for which a magic predicate has been generated during the transforma-

tion.

170

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

Proof. (⇒) Consider the following rule r ∈ P such that r g = rϑ for some substitution ϑ :

(cid:3)

(cid:2)
¯t

(cid:4)

p

(cid:3)

(cid:2)
(cid:4)
¯t
1

∨ p1

r:

∨ · · · ∨ pn

(cid:3)

(cid:2)
(cid:4)
¯t
n

:− q1

(cid:3)

(cid:2)

¯s

(cid:4)
1

, . . . , q j

(cid:2)

¯s

(cid:4)
j

(cid:3)
, not q j+1

(cid:2)

¯s

(cid:4)
j+1

(cid:3)

, . . . , not qm(¯s

(cid:4)
m).

Since magic(pα(¯t)) is a ground atom in BDMS(Q,P), pα has been inserted in the set S at some point of the Magic Set
(cid:4) ∈ DMS(Q, P):

transformation, and it has eventually been used to adorn and modify r, thereby producing the following rule r
(cid:2)
¯t

, . . . , magic

(cid:2)
¯t

pα

∨ · · · ∨ pn

∨ p1

(cid:3)(cid:3)

(cid:3)(cid:3)

(cid:3)(cid:3)

p

p

p

(cid:2)

(cid:3)

(cid:2)

(cid:3)

(cid:2)

(cid:3)

,

r

:

(cid:4)

(cid:4)

(cid:4)

(cid:2)
(cid:4)
¯t
n

(cid:2)
(cid:4)
¯t
1

:− magic
(cid:3)
(cid:4)
1

q1

¯s

(cid:2)

, magic
(cid:3)
(cid:2)
¯s

(cid:4)
j

α1
1

(cid:2)
(cid:4)
¯t
1
(cid:2)
¯s

(cid:3)

(cid:4)
j+1

, . . . , q j

, not q j+1

, . . . , not qm

αn
n
(cid:2)

(cid:2)
(cid:4)
¯t
n
(cid:3)
(cid:4)
¯s
m

.

Clearly enough, the substitution ϑ mapping r into r g can also be used to map r

(cid:4)

into r

(cid:4)
g , since the magic atoms added

(cid:4)

into the positive body of r

are deﬁned over a subset of the variables occurring in head atoms.

(⇐) Let r

(cid:4)

:

r

p

(cid:4) ∈ DMS(Q, P) be a rule such that r
(cid:2)
¯t

∨ · · · ∨ pn

∨ p1

(cid:2)
(cid:4)
¯t
n

(cid:2)
(cid:4)
¯t
1

(cid:3)

(cid:3)

(cid:3)

(cid:4)

(cid:4)
g

= r
(cid:2)

pα

(cid:4)ϑ for some substitution ϑ :
(cid:2)
(cid:2)
¯t

(cid:3)(cid:3)

(cid:3)(cid:3)

p

(cid:4)

, . . . , magic

, magic
(cid:3)
(cid:2)
¯s

(cid:4)
j

α1
1

(cid:2)
(cid:4)
¯t
1
(cid:2)
¯s

(cid:3)

(cid:4)
j+1

(cid:2)

p

αn
n
(cid:2)

(cid:2)
(cid:4)
¯t
n
(cid:3)
(cid:4)
¯s
m

(cid:3)(cid:3)

,

.

, . . . , q j

, not q j+1

, . . . , not qm

:− magic
(cid:3)
(cid:4)
1

q1

¯s

(cid:2)

By the construction of DMS(Q, P), r

(cid:4)

is a modiﬁed rule produced by adding some magic atom to the positive body of a

rule r ∈ P of the form:
(cid:2)
(cid:2)
(cid:4)
¯t
¯t
1

∨ p1

r:

p

(cid:3)

(cid:4)

(cid:3)

∨ · · · ∨ pn

(cid:3)

(cid:2)
(cid:4)
¯t
n

:− q1

(cid:3)

(cid:2)

¯s

(cid:4)
1

, . . . , q j

(cid:2)

¯s

(cid:4)
j

(cid:3)
, not q j+1

(cid:2)

¯s

(cid:4)
j+1

(cid:3)

, . . . , not qm

(cid:2)

(cid:3)

.

(cid:4)
¯s
m

Thus, the substitution ϑ mapping r

(cid:4)

to r

(cid:4)
g can also be used to map r to r g , since r and r

(cid:4)

have the same variables. (cid:2)

3.3.1. Soundness of the Magic Set method

Let us now start with the ﬁrst part of the proof, in particular, by stating some further deﬁnitions and notations. Given a
, we next deﬁne the set of atoms which are relevant

of DMS(Q, P), and a model N

of Ground(DMS(Q, P))M

(cid:4) ⊆ M

(cid:4)

(cid:4)

(cid:4)

model M
for Q but are false with respect to N

(cid:4)

.

(cid:4)

(cid:4)
(cid:4)) of the killed atoms with respect to M

Deﬁnition 3.14 (Killed atoms). Given a model M
killedM
Q,P (N
(cid:4)
k(¯t) ∈ BP \ N

(cid:4)

(cid:5)
(cid:5) either k is an EDB predicate, or there is a binding α such that magic

(cid:2)
(cid:3)
kα(¯t)

(cid:6)

(cid:4)

.

∈ N

for DMS(Q, P), and a model N
(cid:4)
is deﬁned as:

and N

(cid:4)

(cid:4) ⊆ M

(cid:4)

of Ground(DMS(Q, P))M

(cid:4)

, the set

Example 3.15. We consider the program DMS(Qsc, Psc) presented in Section 3.2 (we recall that Qsc = sc(c)), the
EDB {produced_by(p, c, c1)} introduced in Example 3.10, and a stable model M
= {produced_by(p, c, c1), sc(c),
magic_scb(c), magic_scb(c1)} for DMS(Qsc, Psc). Thus, Ground(DMS(Qsc, Psc))Msc consists of the following rules:

(cid:4)
sc

magic_scb(c).
sc(c) ∨ sc(c1) :− magic_scb(c), magic_scb(c1), produced_by(p, c, c1).

magic_scb(c1) :− magic_scb(c).

(cid:4)
sc is also a model of the program above, we can compute killed

Since M
to it because of magic_scb(c1) in M
produced_by(p, c1, c) or controlled_by(c, c1, c1, c1) belong to killed
belongs to this set.

(cid:4)
sc) and check that sc(c1) belongs
(cid:4)
sc. Note that, by deﬁnition, also false ground instances of EDB predicates like
(cid:4)
sc). Moreover, note that no other atom

(cid:4)
M
sc
Qsc,Psc

(M

(M

(cid:4)
M
sc
Qsc,Psc

The intuition underlying the deﬁnition above is that killed atoms are either false ground instances of some EDB predicate,
(cid:4)
); since N
, we expect that these atoms are also false in any stable model for P

or false atoms which are relevant with respect to Q (for there exists an associated magic atom in the model N
is a model of Ground(DMS(Q, P))M
containing M

restricted on the atoms originally occurring in P ).

(cid:4)|BP (which, we recall here, is the model M

contained in M

(cid:4)

(cid:4)

(cid:4)

(cid:4)

= {produced_by(p, c, c1), sc(c)}, which coin-
Example 3.16. Let us resume from Example 3.15. We have that M
cides with model Msc of Example 3.10. Hence, we already know that {sc(c1)} is an unfounded set for Psc with respect
(cid:4)
to (cid:14)Msc, BPsc
sc) is such that k is an EDB predicate, we also have that
(M
(cid:15). Therefore, as a consequence of Theorem 3.11,
(M
killed
each stable model M of Psc such that Msc ⊆ M ⊆ BPsc (in this case only Msc itself) is disjoint from killed

(cid:15). Since each other atom k(¯t) in killed
(cid:4)
sc) is an unfounded set for Psc with respect to (cid:14)Msc, BPsc

(cid:4)
M
sc
Qsc,Psc

(cid:4)
M
sc
Qsc,Psc

|Psc

(M

(cid:4)
sc).

(cid:4)
M
sc
Qsc,Psc

(cid:4)
sc

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

171

This intuition is formalized below.

Proposition 3.17. Let M
unfounded set for P with respect to (cid:14)M

be a model for DMS(Q, P), and N
(cid:4)|BP , BP (cid:15).

(cid:4)

(cid:4) ⊆ M

(cid:4)

be a model of Ground(DMS(Q, P))M

(cid:4)

. Then, killedM

Q,P (N

(cid:4)

(cid:4)) is an

Proof. According to Deﬁnition 3.9 of unfounded sets (for P with respect to (cid:14)M
of the form

(cid:4)|BP , BP (cid:15)), given any rule r g in Ground(P)

r g :

k(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

(cid:4)) ∩ H(r g), then at least one of the following conditions holds: (1.a) B

+(r g) (cid:2) BP ;

we have to show that if k(¯t) ∈ killedM
(1.b) B

Q,P (N
+(r g) ∩ killedM

(cid:4)

(cid:4)

−(r g) ∩ M

(cid:4)|BP (cid:9)= ∅; (2) B

(cid:4)) (cid:9)= ∅; (3) H(r g) ∩ (M
Note that the properties above refer to the original program P . However, our hypothesis is formulated over the trans-
formed one DMS(Q, P) (for instance, we know that M
is a model of DMS(Q, P)). The line of the proof is then to analyze
DMS(Q, P) in the light of its syntactic relationships with P established via Lemma 3.13. In particular, recall ﬁrst that, by
(and, hence, magic(kα(¯t)) is a ground atom in BDMS(Q,P)).
Deﬁnition 3.14, there is a binding α such that magic(kα( ¯t)) ∈ N
Thus, we can apply Lemma 3.13 and conclude the existence of a ground rule r

∈ Ground(DMS(Q, P)) such that:

(cid:4)|BP \ killedM

(cid:4))) (cid:9)= ∅.

Q,P (N

Q,P (N

(cid:4)

(cid:4)

(cid:4)

(cid:4)
g

k(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic

(cid:2)

(cid:2)
(cid:3)
kα(¯t)

(cid:3)
(cid:3)
α1
αn
n (¯tn)
1 (¯t1)
,
q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

, . . . , magic

, magic

p

p

(cid:2)

(cid:4)
g :

r

(cid:4)

is a model of DMS(Q, P), the proof is just based on analyzing the following three scenarios that exhaustively cover

Since M
all possibilities (concerning the fact that the rule r

(cid:4)
g is satisﬁed by M

(cid:4)

):

(S1) B
(S2) B
(S3) B

(cid:4)
g) ∩ M
(cid:4)
g) (cid:2) M
(cid:4)
g) ∩ M

−(r
+(r
+(r
−(r
true with respect to M

(cid:4) (cid:9)= ∅, i.e., the negative body of r
(cid:4)
, i.e., the positive body of r
(cid:4) = ∅, B
(cid:4)
g) ⊆ M
, and H(r
(cid:4)
.

(cid:4)

(cid:4)
g is false with respect to M

(cid:4)

;

(cid:4)
g is false with respect to M
(cid:4)
g) ∩ M

(cid:4)

;

(cid:4) (cid:9)= ∅, i.e., none of the previous cases holds, and hence the head of r

(cid:4)
g is

In the remaining, we shall show that (S1) implies condition (1.b), (S2) implies condition (2), and (S3) implies either (2)

or (3). In fact, note that condition (1.a) cannot hold.

(S1) Assume that B

B

−(r g) ∩ M
(S2) Assume that B
(cid:2)
¯t

k

r

:

(cid:4)

−(r

(cid:4)
g) ∩ M

(cid:4) (cid:9)= ∅. Since B
(cid:4)|BP (cid:9)= ∅, i.e., (1.b) holds.
(cid:4)
, and let r

+(r
(cid:3)

(cid:4)
g) (cid:2) M
(cid:3)
(cid:2)
(cid:4)
¯t
1

∨ p1

(cid:4)

∨ · · · ∨ pn

−(r g) = B

−(r

(cid:4)
g) and B

−(r g) ⊆ BP , from B

−(r

(cid:4)
g) ∩ M

(cid:4) (cid:9)= ∅ we immediately conclude

(cid:4) ∈ DMS(Q, P) be a modiﬁed rule such that r
(cid:3)(cid:3)
(cid:2)
(cid:4)
¯t
n

(cid:2)
kα

(cid:2)
¯t

(cid:3)(cid:3)

p

(cid:3)

(cid:2)

(cid:4)

(cid:2)
(cid:4)
¯t
1
(cid:2)

, magic
(cid:3)
(cid:2)
¯s

α1
1
, not q j+1

(cid:4)
j

(cid:3)

¯s

(cid:4)
j+1

:− magic
(cid:3)
(cid:4)
1

q1

¯s

(cid:2)

, . . . , q j

, . . . , magic

p

, . . . , not qm

αn
n
(cid:2)

(cid:2)
(cid:4)
¯t
n
(cid:4)
¯s
m

,

(cid:3)

.

(cid:4)
g

= r

(cid:4)ϑ for some substitution ϑ :
(cid:2)

(cid:3)(cid:3)

(cid:4)

(cid:4)

(cid:4)

∗

∗

+(r

+(r

+(r

+(r

αi
i (¯t

, a magic rule r

must hold in this case. To prove the claim, observe that during the Generation
∗
(cid:4))),
i ) = {magic(p
(cid:4)
j)} has been produced for each 1 (cid:4) i (cid:4) n (we recall that magic rules have empty negative bodies).
∗
(cid:4)
i we obtain a
i,g) ⊆ {magic(kα(¯t)), q1(¯s1), . . . , q j(¯s j)} = {magic(kα(¯t))} ∪
is a model containing magic(kα(¯t)) by
(cid:4)
(cid:4)
(cid:4)
g) (cid:2) M

, from the above magic rules and since N

, by applying the substitution ϑ to r

. However, this is impossible, since N

i ) ⊆ {magic(kα(¯t

(cid:4)
i))} and B

(cid:4)
g)|BP ⊆ N

(cid:4) ⊆ M

(cid:4)
1), . . . , q j(¯s

We ﬁrst claim that B

αi
i (¯ti))} and B

(cid:4)
g)|BP . Thus, if B

∗
i such that H(r

(cid:4)
g)|BP (cid:2) N
(cid:4)
step preceding the production of r
q1(¯s
∗
Hence, since the variables of r
i are a subset of the variables of r
∗
∗
i,g) = {magic(p
i,g such that H(r
ground rule r
(cid:4)
+(r
+(r
B
assumption, then we would conclude that B
imply B
Now, B
In particular, we can assume w.l.o.g. that, for any q(¯s) ∈ B
(cid:4)
where r is the rule in P from which the modiﬁed rule r
+(r
B
Otherwise, qi is an IDB predicate. In this case, there is a magic rule r
∗
i ) = {magic(q

(cid:4)
+(r
g) (cid:2) N
.
(cid:4)
+(r
g)|BP (cid:2) N

(cid:4)
g)|BP \ N

(cid:4)
g) ⊆ N

(cid:4)
g)|BP with q(¯s

implies the existence of an atom qi(¯si) ∈ B

). If qi is an EDB predicate, the atom qi(¯si) belongs to killedM

(cid:4)
g)|BP such that qi(¯si) /∈ N
(cid:4)) ≺kα (¯t

+(r
has been generated (just take a ≺kα (¯t

, that is, qi(¯si) ∈ BP \ N
i), it is the case that q(¯s) ∈ N
-minimum element in
(cid:4)) by the deﬁnition of killed atoms.
∗
i , produced during the Generation step preceding
(cid:4)
+(r) | q(¯s
i)}.
holds because magic(kα(¯t)) belongs to N
(cid:4)
(cid:4)
βi
i (¯si)) belongs to N
,
(cid:4)) follows from the deﬁnition of killed atoms. Thus, independently of the type (EDB,

i ) = {magic(kα(¯t
∗
(cid:4)
i))} and B(r
∗
∗
+(r
i ϑ belongs to Ground(DMS(Q, P)). In particular, B
i,g) ⊆ N
is a model of Ground(DMS(Q, P))M

, such that H(r

(cid:4)))} ∪ {q(¯s

(cid:4)) ≺kα (¯t

, magic(q

Q,P (N

(cid:4)) ∈ B

the production of r
Thus, r
and by the properties of qi(¯si). Therefore, since N
from which qi(¯si) ∈ killedM
IDB) of qi , (2) holds.

Q,P (N

βi
i (¯s

and B

qi(¯s

qi(¯s

+(r

+(r

= r

∗
i,g

(cid:4))

(cid:4))

(cid:4))

.

,

r

r

r

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

172

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

(S3) Assume that B

+(r

(cid:4)
g) ⊆ M

(cid:4)

, B

−(r

(cid:4)
g) ∩ M

(cid:4) = ∅, and H(r

(cid:4)
g) ∩ M
obtained from r

(cid:4) (cid:9)= ∅. First, observe that from B

(cid:4) = ∅ we can
(cid:4)
g by removing its negative body literals. Consider

(cid:4)
g) ∩ M

−(r

(cid:4)

∗
i,g produced during the Generation step, for each 1 (cid:4) i (cid:4) n (as in (S2)). We distinguish two cases.
, we can conclude that B

+(r
, the latter implies that magic(p

is a model of Ground(DMS(Q, P))M
(cid:4)
g) ∩ M

(cid:4)|BP ) \ killedM

Q,P (N

(cid:4)

(cid:4)
g) contains only standard atoms and H(r
(cid:4)
, and by Deﬁnition 3.14, N

(cid:4) ∩ killedM

(cid:4)

(cid:4)

(cid:4)

(cid:4)

∗
i,g) ⊆ N
αi
i (¯ti)) ∈ N

, for each 1 (cid:4) i (cid:4) n. Moreover,
, for each 1 (cid:4) i (cid:4) n. Then
). We now observe that
(cid:4)) (cid:9)= ∅. Moreover, the latter is equiv-
(cid:4)
g) = H(r g). In addition,
(cid:4)) = ∅ holds. Hence,

Q,P (N

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

B

(cid:4)
g) ∩ N

(cid:4)|BP \ killedM

holds, and so H(r

, since magic(kα(¯t)) ∈ N

is a model of Ground(DMS(Q, P))M

conclude that there is a rule in Ground(DMS(Q, P))M
now the rules r
If {q1(¯s1), . . . , q j(¯s j)} ⊆ N
since N
(cid:4)
+(r
g) ⊆ N
(cid:4)
g) ∩ (M
H(r
alent to (H(r g) ∩ M
(cid:4) ⊆ M
from N
(cid:4)) \ killedM
(H(r g) ∩ M
Otherwise, {q1(¯s1), . . . , q j(¯s j)} (cid:2) N
qi(¯s
predicate, the atom qi(¯si) belongs to killedM
and there is a magic rule r

(cid:4) (cid:9)= ∅ (because N
(cid:4))) (cid:9)= ∅ is equivalent to (H(r
(cid:4)) (cid:9)= ∅ because H(r
Q,P (N
(cid:4) ⊆ H(r g) ∩ M
(cid:4)

we conclude H(r g) ∩ N
(cid:4)) ⊇ H(r g) ∩ N
(cid:4)

i) implies q(¯s) ∈ N

Q,P (N
(cid:4)) \ killedM

Q,P (N

Q,P (N

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

, which is not empty, and so condition (3) holds.

. Let i ∈ {1, . . . , j} be such that qi(¯si) /∈ N

(where r is the rule in P from which the modiﬁed rule r

(cid:4)

and, for any q(¯s) ∈ B

(cid:4)) ≺kα (¯t
has been generated). If qi is an EDB
(cid:4)) by the deﬁnition of killed atoms. Otherwise, qi is an IDB predicate
∗
(cid:4)
i,g) ⊆ N
.
(cid:4)) follows from the deﬁnition of killed atoms.

βi
i (¯si)) in head, and such that B

(cid:4)
g)|BP , q(¯s

+(r

+(r

(cid:4))

r

(cid:4)

Therefore, magic(q
Thus, independently of the type (EDB, IDB) of qi , (2) holds. (cid:2)

βi
i (¯si)) belongs to N

∈ Ground(DMS(Q, P)) having an atom magic(q
, from which qi(¯si) ∈ killedM

Q,P (N

(cid:4)

(cid:4)

∗
i,g

We can now complete the ﬁrst part of the proof.

Lemma 3.18. For each stable model M

(cid:4)

of DMS(Q, P), there is a stable model M of P such that M ⊇ M

(cid:4)|BP .

Proof. Let M be a stable model of P ∪ M
shall show that M is in fact a stable model of P such that M ⊇ M
So, the line of the proof is to show that if M is not stable, then it is possible to build a model N
such that N

, thereby contradicting the minimality of M

over the models of Ground(DMS(Q, P))M

(cid:4)|BP , the program obtained by adding to P a fact for each atom in M

(cid:4)|BP . Of course, M is a model of P such that M ⊇ M

(cid:4)|BP . We
(cid:4)|BP .
of Ground(DMS(Q, P))M

(cid:4) ⊂ M

.

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Assume, for the sake of contradiction, that M is not stable and let N ⊂ M be a model of Ground(P)M . Deﬁne N

(cid:4)

(cid:4)|BP ) ∪ (M
(cid:4)
(cid:4) = M

(cid:4) \ BP ). By construction, note that N
, we would have that N ⊇ M

interpretation (N ∩ M
fact, in the case where N
would not only be a model for Ground(P)M but also a model for Ground(P ∪ M
(cid:4)|BP . So, N
holds. However, this is impossible, since M is a stable model of P ∪ M
proof and get a contradiction, it remains to show that N
the rules in Ground(DMS(Q, P))M

(cid:4) ⊆ M
(cid:4)|BP , since (N ∩ M

(cid:4)

(cid:4)

(cid:4)

, since M

. To this end, we have to consider the following two kinds of rules:

is actually a model of Ground(DMS(Q, P))M

(cid:4)

(cid:4)|BP ) and (M

coincides with M

as the
(cid:4)|BP ∪ (M
(cid:4) \ BP ). In
(cid:4) \ BP ) are disjoint. Hence, N
(cid:4)|BP )M , while on the other hand N ⊂ M
(cid:4) ⊂ M
must hold. Hence, to complete the
, i.e., it satisﬁes all

(cid:4)

(cid:4)

∗
∈ Ground(DMS(Q, P))M
(1) Consider a ground magic rule r
g
+(r
, B
(cid:4)

(cid:4) ⊂ M
∗
g). Since N
g)| = 1, magic(pα(¯t)) ∈ M

atom in H(r
|H(r
atom, magic(pα(¯t)) is also contained in M

implies that B
must hold (we recall that B

, and let magic(pα(¯t)) be the (only)
such that B
∗
+(r
is a model of DMS(Q, P) and
g) ⊂ M
∗
−(r
g) = ∅). Moreover, since BP does not contain any magic
(cid:4) (cid:9)= ∅.
(cid:4) \ BP . Thus, by the construction of N
∈ Ground(DMS(Q, P)) where

∗
+(r
g) ⊆ N
. In fact, since M

(2) Consider a rule obtained by removing the negative literals from a ground modiﬁed rule r

, we can conclude that H(r

∗
g) ⊆ N

∗
g) ∩ N

∗

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)
g

(cid:4)
g :

r

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic

(cid:2)

(cid:2)

, magic

(cid:3)
pα(¯t)

(cid:3)
α1
1 (¯t1)
,
q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).
(cid:4)
g) ∩ M

(cid:3)
αn
n (¯tn)

, . . . , magic

p

p

(cid:2)

+(r
and where B
Ground(P) associated with r

(cid:4)
g) ⊆ N

(cid:4)

(cid:4)
g (according to Lemma 3.13):

. Observe that B

−(r

(cid:4) = ∅ holds by the deﬁnition of reduct. Moreover, let r g be the rule of

r g :

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

We have to show that H(r

(cid:4)
g) ∩ N

(cid:4) (cid:9)= ∅. The proof is based on establishing the following properties on r

(cid:4)
g and r g :

(cid:2)

(cid:3)

= ∅;

∩ M = ∅;

(cid:4)

(cid:3)

(cid:2)

(cid:3)

M

(cid:4)
• M ∩ killedM
Q,P
(cid:3)
(cid:4)
(cid:4)
\ M
•
H
g
(cid:4)
−
∩ M = ∅;
• B
g
(cid:2)
(cid:3)
(cid:2)
(cid:4) = H
∩ M
• H
r
r
• H(r g) ∩ N (cid:9)= ∅.

(cid:2)
r
(cid:2)
r
(cid:4)
g

(cid:3)

(cid:4)
g

∩ M

(cid:4)|BP = H

(cid:3)

(cid:2)
r

(cid:4)
g

∩ M;

(1)

(2)

(3)

(4)

(5)

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

173

In particular, we shall directly prove (1), and show the following implications: (1) → (2) ∧ (3), (2) → (4), and (3) → (5).
(cid:4) (cid:9)= ∅ can be easily derived as follows: Since H(r g) ⊆ BP , by the
(cid:4)|BP ). Moreover, because
coincides in turn with (H(r g) ∩ N) ∩ (H(r g ) ∩ M). Then, recall that N ⊂ M.

Eventually, based on (4) and (5), the fact that H(r
deﬁnition of N
of (4) and the fact that H(r g) = H(r
Thus, H(r g) ∩ N

we can conclude that H(r g) ∩ N
(cid:4)
g), H(r g) ∩ N
(cid:4) = H(r g) ∩ N, which is not empty by (5).

(cid:4)|BP ) = (H(r g) ∩ N) ∩ (H(r g) ∩ M

(cid:4) = H(r g) ∩ (N ∩ M
(cid:4)

(cid:4)
g) ∩ N

(cid:4)

In order to complete the proof, we have to show that all the above equations actually hold.

(cid:4)|BP , BP (cid:15). In fact, one may notice that killedM

Proof of (1). We recall that, by Proposition 3.17, we already know that killedM
respect to (cid:14)M
(cid:14)M
by Deﬁnition 3.14. Thus, since M ⊇ M
(cid:4)) = ∅.
conclude that M ∩ killedM

(cid:4)|BP , BP (cid:15) too, since the rules added to P are facts corresponding to the atoms in M

(cid:4)|BP and M is a stable model of P ∪ M

Q,P (M
(cid:4)) is an unfounded set for P ∪ M

(cid:4)) is an unfounded set for P with
(cid:4)|BP with respect to
(cid:4)) = ∅
Q,P (M
(cid:4)|BP , we can apply Theorem 3.11 in order to

(cid:4)|BP ∩ killedM

(cid:4)|BP and M

Q,P (M

(cid:4)

(cid:4)

(cid:4)

Q,P (M

(cid:4)

Proof of (2). After (1), we can just show that H(r

implies B

+(r

(cid:4)
g) ⊂ M

(cid:4)

. Thus, H(r

(cid:4)
g) \ M

(cid:4) ⊆ killedM

(cid:4)

Q,P (M

(cid:4)
g) \ M

(cid:4) ⊆ killedM

(cid:4)

Q,P (M

(cid:4)). In fact, since N

(cid:4) ⊂ M

(cid:4)

(cid:4)) follows by Deﬁnition 3.14 and the form of rule r

, we note that B
(cid:4)
g .

+(r

(cid:4)
g) ⊆ N

(cid:4)

Proof of (3). After (1), we can just show that B
belong to killedM
Q,P (M
To this end, consider a modiﬁed rule r

(cid:4)), as EDB atoms in B

−(r

(cid:4)

(cid:4)

:

r

(cid:3)

(cid:2)
¯t

(cid:4)

p

(cid:3)

(cid:2)
(cid:4)
¯t
1

∨ p1

∨ · · · ∨ pn

(cid:2)
(cid:4)
¯t
n

−(r

(cid:4)
g) ⊆ killedM

Q,P (M

(cid:4)

(cid:4)
g) clearly belong to killedM

(cid:4) ∈ DMS(Q, P) such that r
(cid:2)
(cid:3)

(cid:3)(cid:3)

(cid:4)
g

(cid:2)
¯t

(cid:4)

pα

:− magic
(cid:3)
(cid:4)
1

q1

¯s

(cid:2)

, magic
(cid:3)
(cid:2)

¯s

(cid:4)
j

, . . . , q j

, not q j+1

(cid:4)

−(r

Q,P (M

(cid:4)
g)
(cid:4) = ∅ by assumption.

(cid:4)) because B

(cid:4)). Actually, we show that the IDB atoms in B
−(r
(cid:4)
g) ∩ M
(cid:4)ϑ for some substitution ϑ :
(cid:3)(cid:3)
(cid:2)
(cid:4)
¯t
1
(cid:2)
¯s

, . . . , magic

, . . . , not qm

(cid:2)
(cid:4)
¯t
n
(cid:3)
(cid:4)
¯s
m

αn
n
(cid:2)

(cid:4)
j+1

(cid:3)(cid:3)

p

(cid:2)

(cid:3)

,

.

= r

(cid:2)

p

α1
1

(cid:4)
(cid:4)) has been produced for each j + 1 (cid:4) i (cid:4) m such that qi is an IDB predicate. Hence, since the variables of r

∗
i ) = {magic(q

∗
i with H(r

, a magic rule r

(cid:4)
i))} and where B

βi
i (¯s

During the Generation step preceding the production of r
+(r
B
of the variables of r
∗
+(r
i,g) ⊆ B
∗
i,g must be true with respect to M

, the substitution ϑ can be used to map r
(cid:4)
g) ⊆ N
(cid:4)

(cid:4)
g). Now, since B

+(r

+(r

B

(cid:4)

(cid:4)

of r
holds, for each j + 1 (cid:4) i (cid:4) m such that qi is an IDB predicate. Moreover, B
βi
i (¯si) ∈ B
q

(cid:4)
g). Thus, by Deﬁnition 3.14, q

βi
i (¯si) ∈ killedM

Q,P (M

−(r

(cid:4)).

(cid:4)

∗
i to a ground rule r

(cid:4) ⊂ M

, we can conclude that B

+(r
(we recall that magic rules have empty negative bodies). That is, magic(q
−(r

(cid:4) = ∅ implies that q

∗
i ϑ with H(r
∗
i,g) is in turn contained in M

∗
i,g) = {magic(q

= r

∗
i,g

(cid:4)

(cid:4)
g) ∩ M

∗
+(r
i ) ⊆
∗
i are a subset
βi
i (¯si))} and
. Thus, the head
(cid:4)
βi
i (¯si)) ∈ M
, as

(cid:4)

βi
i (¯si) ∈ BP \ M

Proof of (4). The property immediately follows from (2) and the fact that H(r

(cid:4)
g) ⊆ BP and M ⊇ M

(cid:4)|BP .

Proof of (5). Note that B
the atoms in B
+(r g) ⊆ N (more speciﬁcally, B
B
H(r g) ∩ N (cid:9)= ∅. (cid:2)

−(r

−(r g) = B

(cid:4)
g), and so (3) implies that there is a rule in Ground(P)M obtained from r g by removing
+(r
(cid:4)
−(r g). Note also that B
(cid:4)
g) ⊆ N
). Thus, by the deﬁnition of N
,
(cid:4)|BP ). Moreover, since N is a model of Ground(P)M , the latter entails that

+(r g) = B
+(r g) ⊆ N ∩ M

(cid:4) ∩ BP (since B

(cid:4)
g) ∩ BP ⊆ N

+(r

(cid:4)

Theorem 3.19. Let Q be a query for a Datalog
M of P such that M

(cid:4)|Q = M|Q.

∨,¬s program P . Then, for each stable model M

(cid:4)

of DMS(Q, P), there is a stable model

Proof. Because of Lemma 3.18, for each stable model M
M

(cid:4)|BP . Thus, we trivially have that M|Q ⊇ M
In fact, by the deﬁnition of DMS(Q, P), the magic seed is associated to any ground instance of Q. Then BP |Q \
(cid:4)) by Deﬁnition 3.14 (we recall that BP |Q denotes the ground instances of Q). By Proposition 3.17,
(cid:4) ⊆ killedM
(cid:4)|BP , BP (cid:15). Hence, by Theorem 3.11, we have that M ∩
Q,P (M
(cid:4)|Q implies
Q,P (M

Q,P (M
(cid:4)) is an unfounded set for P with respect to (cid:14)M
(cid:4)) = ∅. It follows that M ∩ (BP |Q \ M

(cid:4)|Q holds. We now show that the inclusion cannot be proper.

(cid:4)|Q = ∅, which combined with M|Q ⊇ M

(cid:4)) = ∅. Thus, M|Q \ M

of DMS(Q, P), there is a stable model M of P such that M ⊇

(cid:4)

(cid:4)

(cid:4)

M
killedM
killedM
M|Q = M

(cid:4)

(cid:4)|Q. (cid:2)

3.3.2. Completeness of the Magic Set method

For the second part of the proof, we construct an interpretation for DMS(Q, P) based on one for P .

174

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

Deﬁnition 3.20 (Magic variant). Let I be an interpretation for P . We deﬁne an interpretation variant
called the magic variant of I with respect to Q and P , as the limit of the following sequence:

∞
Q,P (I) for DMS(Q, P),

variant0
varianti+1
(cid:4)

Q,P (I) = EDB(P);
Q,P (I) = varianti

and
Q,P (I) ∪
(cid:5)
(cid:5) there is a binding α such that
(cid:6)
(cid:3)
pα(¯t)
∪
Q,P (I)
magic
(cid:3) (cid:5)
(cid:3)
(cid:5) ∃r
∗
DMS(Q, P)
g
(cid:2)
(cid:3)
pα(¯t)
∗
∈ H
r
g

∈ Ground
(cid:3)
∗
g

∈ varianti
(cid:2)

and B

(cid:2)
r

+

(cid:3)

(cid:2)

pα(¯t)
(cid:2)

p(¯t) ∈ I

(cid:4)

(cid:2)

magic

magic

such that

(cid:6)
Q,P (I)

⊆ varianti

, ∀i (cid:3) 0.

Example 3.21. Consider the program DMS(Qsc, Psc) presented in Section 3.2, the EDB {produced_by(p, c, c1)} and the in-
terpretation Msc = {produced_by(p, c, c1), sc(c)}. We next compute the magic variant variant
(Msc) of Msc with
respect to Qsc and Psc. We start the sequence with the original EDB: variant0
(Msc) = {produced_by(p, c, c1)}.
For variant1
(Msc), we add sc(c) (because
(Msc)), and magic_scb(c1) (because magic_scb(c1) :− magic_scb(c).
sc(c) ∈ Msc and magic_scb(c) ∈ variant0
is a rule of Ground(DMS(Qsc, Psc)) and magic_scb(c) ∈ variant0
(Msc)). Any other element of the sequence coincides
with variant2
(Msc), and so also variant

Qsc,Psc
(Msc), we add magic_scb(c) (the query seed), while for variant2

∞
Qsc,Psc

(Msc).

Qsc,Psc

Qsc,Psc

Qsc,Psc

Qsc,Psc

∞
Qsc,Psc

Qsc,Psc

By deﬁnition, for a magic variant variant

∞
Q,P (I) of an interpretation I with respect to Q and P , variant
holds. More interestingly, the magic variant of a stable model for P is in turn a stable model for DMS(Q, P).

∞
Q,P (I)|BP ⊆ I

Example 3.22. The magic variant of Msc with respect to Qsc and Psc (see Example 3.21) coincides with the interpretation
(cid:4)
M
sc is a stable
model of DMS(Qsc, Psc).

(cid:4)
sc introduced in Example 3.15. From previous examples, we know that Msc is a stable model of Psc, and M

The following two lemmas formalize the intuition above, with the latter being the counterpart of Lemma 3.18.

Lemma 3.23. For each stable model M of P , the magic variant M
M ⊇ M

(cid:4)|BP .

(cid:4) = variant

∞
Q,P (M) of M is a model of Ground(DMS(Q, P))M

(cid:4)

with

(cid:4)

is the magic variant of the stable model M, we trivially have that M ⊇ M

Proof. As M
is a model of Ground(DMS(Q, P))M
rule obtained by removing the negative body literals from a rule r
+(r
B

hold. We have to show that H(r

(cid:4)

(cid:4)

(cid:4)
g

(cid:4)
g) ⊆ M

. To this end, consider a rule in Ground(DMS(Q, P))M

∈ Ground(DMS(Q, P)) such that B

(cid:4)

(cid:4)|BP holds. We next show that M
having the body true, that is, a
(cid:4) = ∅ and
(cid:4)
g) ∩ M

−(r

(cid:4)

In the case where r

(cid:4)
g is a magic rule, then B

(cid:4)
g) belongs to M
(cid:4)
tion 3.20). The only remaining (slightly more involved) case to be analyzed is where r
g is a modiﬁed rule of the form
(cid:2)
(cid:3)
(cid:3)
α1
αn
n (¯tn)
1 (¯t1)
q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− magic

implies that the (only) atom in H(r

(cid:3)
pα(¯t)

, . . . , magic

, magic

(cid:4)
g :

p

p

(cid:2)

(cid:2)

,

r

(cid:4)

(cid:4)

(by Deﬁni-

(cid:4) (cid:9)= ∅.
(cid:4)
g) ∩ M
(cid:4)
+(r
g) ⊆ M

In this case, we ﬁrst apply as usual Lemma 3.13 in order to conclude the existence of a rule r g ∈ Ground(P) of the form

r g :

p(¯t) ∨ p1(¯t1) ∨ · · · ∨ pn(¯tn) :− q1(¯s1), . . . , q j(¯s j), not q j+1(¯s j+1), . . . , not qm(¯sm).

Then, we claim that the following two properties hold:

−

+

• B
• B

(r g) ∩ M = ∅;
(r g) ⊆ M.

(6)

(7)

These properties are in fact what we just need to establish the result. Indeed, since M is a model of Ground(P)M , (6) and (7)
(cid:4)
g) ∩ M and
imply H(r g) ∩ M (cid:9)= ∅. So, we can recall that H(r g) = H(r
(cid:4)
+(r
+(r
g) ⊆
magic(p
M
as well by Deﬁnition 3.20. That is,
H(r

g), and hence let pi(¯ti) be an atom in H(r g) ∩ M = H(r
(cid:4)
g) (i ∈ {(cid:6), 1, . . . , n}, where (cid:6) is the empty string). Since B
(cid:4)

(by hypothesis) and since pi(¯ti) ∈ M, we can then conclude that pi(¯ti) is in M
(cid:4)
g) ∩ M
Let now ﬁnalize the proof, by showing that the above properties actually hold.

αi
i (¯ti)) be its corresponding magic atom in B

(cid:4) (cid:9)= ∅.

(cid:4)

(cid:4)

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

175

(cid:4) ∈ DMS(Q, P) such that r
Proof of (6). Consider a modiﬁed rule r
(cid:3)

(cid:3)(cid:3)

(cid:3)

(cid:2)

(cid:3)

(cid:4)
g
(cid:2)

(cid:4)

r

:

p

(cid:2)
¯t

(cid:4)

(cid:2)
(cid:4)
¯t
1

∨ p1

∨ · · · ∨ pn

(cid:2)
(cid:4)
¯t
n

(cid:2)
¯t

(cid:4)

= r

p

α1
1

(cid:3)(cid:3)

(cid:4)ϑ for a substitution ϑ :
(cid:2)
(cid:2)
(cid:4)
(cid:4)
¯t
¯t
n
1
(cid:3)
(cid:2)
(cid:4)
¯s
¯s
m

, . . . , not qm

, . . . , magic

(cid:4)
j+1

αn
n
(cid:2)

p

(cid:2)

(cid:3)

(cid:3)(cid:3)

,

.

, not q j+1

and the rule r ∈ P from which r
(cid:3)

(cid:3)

(cid:4)

(cid:2)
¯t

(cid:4)

(cid:2)
(cid:4)
¯t
1

∨ p1

r:

p

∨ · · · ∨ pn

(cid:2)
(cid:4)
¯t
n

:− q1

¯s

(cid:4)
1

, . . . , q j

, not q j+1

¯s

(cid:4)
j

(cid:3)

(cid:2)

¯s

(cid:4)
j+1

, . . . , not qm

(cid:2)

(cid:3)

.

(cid:4)
¯s
m

pα

(cid:2)

:− magic
(cid:3)
(cid:4)
1
is produced (such that r g = rϑ ):
(cid:3)

, magic
(cid:3)
(cid:2)
¯s

, . . . , q j

q1

(cid:4)
j

¯s

(cid:3)

(cid:2)

(cid:3)

(cid:2)

(cid:4)

B

, a magic rule r

is an IDB predicate. Hence, since the variables of r
∗
i,g

∗
i to a ground rule r

(cid:4)
, the substitution ϑ can be used to map r
+(r

During the Generation step preceding the production of r
produced for each j + 1 (cid:4) i (cid:4) m such that qi
variables of r
∗
+(r
i,g) ⊆ B
∗
+(r
i,g) is in turn contained in M
is, magic(q
belongs to M, by Deﬁnition 3.20 we can conclude that qi(¯si) ∈ M
−(r g) = B
(we recall that B
EDB predicates too, since B

(cid:4)
g)). This proves that IDB predicates in B
(cid:4)
g) ∩ M

−(r
−(r g) ∩ M

i (¯ti)) ∈ M
βi

(cid:4) = ∅ and M

(cid:4)
g) (we recall that magic rules have empty negative body). Now, since B
. Thus, by the construction of M

, the head of r

∗
i,g must be true with respect to M
holds for each j + 1 (cid:4) i (cid:4) m such that qi is an IDB predicate. So, if some (IDB) atom qi(¯si) ∈ B
(cid:4)
g) ∩ M

, that
−(r g)
(cid:4) = ∅
−(r g) do not occur in M. The same trivially holds for

, which contradicts the assumption that B

(cid:4)
i))} has been
∗
i are a subset of the
i (¯ti))} and
βi
, we can conclude that

∗
i,g) = {magic(q
(cid:4)

(cid:4) ⊇ EDB(P) (by the deﬁnition of magic variant).

∗
i ϑ such that H(r
+(r
(cid:4)
g) ⊆ M

∗
i such that H(r

∗
i ) = {magic(q

(cid:4) = B

βi
i (¯s

−(r

−(r

= r

B

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Proof of (7). The equation straightforwardly follows from the fact that B
+(r
B

hold by the construction of M

and by the initial hypothesis on the choice of r

(cid:4)

(cid:4)

(cid:4)
g) ⊆ M

+(r g) = B

+(r

(cid:4)
g)|BP , and since M ⊇ M
(cid:4)
g , respectively. (cid:2)

(cid:4)|BP and

Lemma 3.24. For each stable model M of P , there is a stable model M
M ⊇ M

(cid:4)|BP .

(cid:4)

of DMS(Q, P) (which is the magic variant of M) such that

(cid:4)

. Let N

Proof. After Lemma 3.23, we can show that M
P))M
variant that M
contains only EDB facts. Suppose varianti

is in turn contained in N

(cid:4) ⊆ M
(cid:4)

(cid:4)

be a minimal model of Ground(DMS(Q, P))M
(cid:4)

(cid:4) = variant

∞
Q,P (M) is also minimal over all the models of Ground(DMS(Q,
. We prove by induction on the deﬁnition of the magic
Q,P (M)

Q,P (M) ⊆ N

(cid:4)

) is clearly true, since variant0
Q,P (M) ⊆ N

holds as well.

(cid:4)

. The base case (i.e., variant0

(cid:4)
in order to prove that varianti+1

(cid:4)

While considering an atom in varianti+1

Q,P (M), we distinguish two cases:

Q,P (M) ⊆ N
Q,P (M) \ varianti

(cid:4)

∗

∗
g

g) = {magic(pα(¯t))} and B

(a) For a magic atom magic(pα(¯t)) in varianti+1

Ground(DMS(Q, P)) having H(r
negative body and so r
hypothesis and so magic(pα(¯t)) ∈ N
(b) For a standard atom p(¯t) in varianti+1

Q,P (M) \ varianti
Q,P (M), by Deﬁnition 3.20 there must be a rule r
∗
+(r
g) ⊆ varianti
holds). We can then conclude that B
(cid:4)
is a model of Ground(DMS(Q, P))M

Q,P (M) (we recall that magic rules have empty
(cid:4)
holds by the induction

∈ Ground(DMS(Q, P))M
(cid:4)
(cid:4)
(because N
Q,P (M) \ varianti

+(r
).
Q,P (M), by Deﬁnition 3.20 there is a binding α such that
Q,P (M) and the atom p(¯t) belongs to M. Assume for the sake of contradiction that p(¯t) /∈ N
(cid:4)
.
(cid:4))
, we can compute the set killedM
Q,P (N
(cid:4)) holds (by deﬁnition). Moreover, by
(cid:4)|BP holds
(cid:4)|BP , and we can hence apply Theorem 3.11 in
(cid:4)) and p(¯t) ∈ M.

magic(pα(¯t)) ∈ varianti
Since M
as introduced in Section 3.3.1 and note, in particular, that p(¯t) ∈ killedM
Proposition 3.17, killedM
by Deﬁnition 3.20. Thus, M is a stable model for P such that M ⊇ M
order to conclude that M ∩ killedM
Hence, p(¯t) ∈ N
. (cid:2)

(cid:4)) = ∅. The latter is in contradiction with p(¯t) ∈ killedM

(cid:4)) is an unfounded set for P with respect to (cid:14)M

is a model of Ground(DMS(Q, P))M

(cid:4)|BP , BP (cid:15). In addition, M ⊇ M

is a model of DMS(Q, P) and N

∗
g) ⊆ N

Q,P (N

Q,P (N

Q,P (N

Q,P (N

∈

∗
g

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

We can then prove the correspondence of stable models with respect to queries.

Theorem 3.25. Let Q be a query for a Datalog
DMS(Q, P) (which is the magic variant of M) such that M

(cid:4)|Q = M|Q.

∨,¬s program P . Then, for each stable model M of P , there is a stable model M

(cid:4)

of

Proof. Let M be a stable model of P and M
model of DMS(Q, P) such that M ⊇ M
inclusion.

(cid:4) = variant

(cid:4)|BP . Thus, we trivially have that M|Q ⊇ M

∞
Q,P (M) its magic variant. Because of Lemma 3.24, M

(cid:4)

is a stable
(cid:4)|Q holds. We now show the reverse

Since M

(cid:4)

is a stable model of DMS(Q, P), we can determine the set killedM

Deﬁnition 3.14 we can conclude that (a) BP |Q \ M
(we recall that BP |Q denotes the ground instances of Q). Moreover, since M is a stable model of P with M ⊇ M

Q,P (M

(cid:4)) because M

(cid:4) ⊆ killedM

(cid:4)

(cid:4)

Q,P (M
(cid:4)

(cid:4)) as deﬁned in Section 3.3.1. Hence, by
contains the magic seed by construction
(cid:4)|BP

176

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

(cid:4)

and killedM
M ∩ killedM
equivalent to M|Q ⊆ M

Q,P (M
Q,P (M

(cid:4)

(cid:4)|Q. (cid:2)

(cid:4)) is an unfounded set for P with respect to (cid:14)M
(cid:4)) = ∅ by Theorem 3.11. Thus, by combining (a) and (b) we obtain that (BP |Q \ M

(cid:4)|BP , BP (cid:15) by Proposition 3.17, we can conclude that (b)
(cid:4)) ∩ M = ∅, which is

Finally, we show the correctness of the Magic Set method with respect to query answering, that is, we prove that the

original and rewritten programs provide the same answers for the input query on all possible EDBs.

Theorem 3.26. Let P be a Datalog

∨,¬s program, and let Q be a query. Then DMS(Q, P) ≡b

Q P and DMS(Q, P) ≡c

Q P hold.

facts F deﬁned over the EDB predicates of P (and DMS(Q, P)),
Proof. We want to show that,
Ansb(Q, DMS(Q, P) ∪ F ) = Ansb(Q, P ∪ F ) and Ansc(Q, DMS(Q, P) ∪ F ) = Ansc(Q, P ∪ F ) hold. We ﬁrst observe that
the Magic Set rewriting does not depend on EDB facts; thus, DMS(Q, P) ∪ F = DMS(Q, P ∪ F ) holds. Moreover, note that
∨,¬s programs always have stable models. Therefore, as a direct consequence of Theorem 3.19 and Theorem 3.25, we
Datalog
can conclude Ansb(Q, DMS(Q, P ∪ F )) = Ansb(Q, P ∪ F ) and Ansc(Q, DMS(Q, P ∪ F )) = Ansc(Q, P ∪ F ). (cid:2)

for any set of

3.4. Magic Sets for stratiﬁed Datalog programs without disjunction

Stratiﬁed Datalog programs without disjunction have exactly one stable model [29]. However, the Magic Set transfor-
mation can introduce new dependencies between predicates, possibly resulting in unstratiﬁed programs (we refer to the
analysis in [38]). Clearly, original and rewritten programs agree on the query, as proved in the previous section, but the
question whether the rewritten program admits a unique stable model is also important. In fact, for programs having the
unique stable model property, brave and cautious reasoning coincide and a solver can immediately answer the query after
the ﬁrst (and unique) stable model is found. The following theorem states that the rewritten program of a stratiﬁed program
indeed has a unique stable model.

Theorem 3.27. Let P be a disjunction-free Datalog program with stratiﬁed negation and Q a query. Then DMS(Q, P) has a unique
stable model.

Proof. Let M be the unique stable model of P , and M
By Lemma 3.24 we already know that M
DMS(Q, P) contains M
variant0
well. Thus, while considering an atom in varianti+1

Q,P (M) contains only EDB facts. Suppose varianti

by induction on the structure of M

(cid:4)

(cid:4)

is a stable model of DMS(Q, P). We now show that any stable model N

∞
Q,P (M) its magic variant as presented in Deﬁnition 3.20.
of
) is clearly true, since
Q,P (M) ⊆ N

in order to prove that varianti+1

Q,P (M) ⊆ N

. The base case (variant0

holds as

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Q,P (M) ⊆ N

Q,P (M) \ varianti

Q,P (M), two cases are possible:

(cid:4) = variant

(1) For a magic atom magic(pα(¯t)) in varianti+1

∗

Ground(DMS(Q, P)) having H(r
negative bodies and so r
hypothesis and so magic(pα(¯t)) ∈ N
(2) For a standard atom p(¯t) in varianti+1

∈ Ground(DMS(Q, P))N
(cid:4)
(cid:4)
(because N
Q,P (M) \ varianti

g) = {magic(pα(¯t))} and B

∗
g

Q,P (M) \ varianti
Q,P (M), by Deﬁnition 3.20 there must be a rule r
∗
+(r
g) ⊆ varianti
holds). We can then conclude that B
(cid:4)
is a model of Ground(DMS(Q, P))N

Q,P (M) (we recall that magic rules have empty
(cid:4)
holds by the induction

+(r
).

∗
g) ⊆ N

(cid:4)

∈

∗
g

(cid:4)

is a stable model of DMS(Q, P), we can compute the set killedN

Q,P (M), by Deﬁnition 3.20 there is a binding α such that
Q,P (M) and the atom p(¯t) belongs to M. Assume for the sake of contradiction that p(¯t) /∈ N
magic(pα(¯t)) ∈ varianti
(cid:4)
.
(cid:4)) as introduced in Section 3.3.1 and note,
Since N
in particular, that p(¯t) ∈ killedN
(cid:4)) is an unfounded
Q,P (N
(cid:4)|BP ,
set for P with respect to (cid:14)N
which would mean that p(¯t) /∈ N holds. Hence, we can conclude that N and M are two different stable models of P ,
obtaining a contradiction, as P has a unique stable model.

Q,P (N
(cid:4)|BP , BP (cid:15). In addition, by Lemma 3.25 there is a stable model N of P such that N ⊇ N

(cid:4)) holds, by deﬁnition. Moreover, by Proposition 3.17, killedN

Q,P (N

(cid:4)

(cid:4)

(cid:4)

Since stable models are incomparable with respect to containment, M

stable model of DMS(Q, P). (cid:2)

(cid:4) ⊆ N

(cid:4)

implies M

(cid:4) = N

(cid:4)

. Hence, M

(cid:4)

is the unique

4. Implementation

The Dynamic Magic Set method (DMS) has been implemented and integrated into the core of the DLV [43] system. In this
section, we shall ﬁrst brieﬂy describe the architecture of the system and its usage. We then brieﬂy present an optimization
for eliminating redundant rules, which are sometimes introduced during the Magic Set rewriting.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

177

Fig. 6. Prototype system architecture.

4.1. System architecture and usage

We have created a prototype system by implementing the Magic Set technique described in Section 3 inside DLV, as
shown in the architecture reported in Fig. 6. DLV supports both brave and cautious reasoning, and for a completely ground
query it can be also used for computing all stable models in which the query is true. DLV performs brave reasoning if
invoked with the command-line option -FB, while -FC indicates cautious reasoning.

In our prototype, the DMS algorithm is applied automatically by default when the user invokes DLV with -FB or -FC
together with a (partially) bound query. Magic Sets are not applied by default if the query does not contain any constant.
The user can modify this default behavior by specifying the command-line options -ODMS (for applying Magic Sets) or
-ODMS- (for disabling Magic Sets).

If a completely bound query is speciﬁed, DLV can print the magic variant of the stable model (not displaying magic
predicates), which witnesses the truth (for brave reasoning) or the falsity (for cautious reasoning) of the query, by specifying
the command-line option - -print-model.

Within DLV, DMS is applied immediately after parsing the program and the query by the Magic Set Rewriter module. The
rewritten (and optimized as described in Section 4.2) program is then processed by the Intelligent Grounding module and the
Model Generator module using the implementation of DLV. The only other modiﬁcation is for the output and its ﬁltering:
For ground queries, the witnessing stable model is no longer printed by default, but only if - -print-model is speciﬁed,
in which case the magic predicates are omitted from the output.

The SIPS schema7 implemented in the prototype is as follows: For a rule r, head atom p(¯t) and binding α, ≺pα (¯t)

satisﬁes
the conditions of Deﬁnition 3.3, in particular p(¯t) ≺pα (¯t)
b(¯z) holds for all
head or negative body atoms q(s) (cid:9)= p(¯t) and any atom b(¯z) in r. Moreover, all the positive body literals of r form a chain
in ≺pα (¯t)
. This chain is constructed by iteratively inserting those atoms containing most bound arguments (considering α
) into the chain. Among the atoms with most bindings an arbitrary processing
and also the partially formed chain and f
(q(¯s)) = X holds if and only if q(¯s)

pα (¯t)
r
pα (¯t)
order (usually the order appearing in the original rule body) is used. Furthermore,
r
belongs to the positive body of r, has at least one bound argument and X occurs in ¯s.

q(¯s) holds for all q(¯s) (cid:9)= p(¯t) in r, and q(¯s) ⊀pα (¯t)

f

r

r

r

r

7 Since technically a SIPS has a deﬁnition for every single rule, implementations use a schema for creating the SIPS for a given rule.

178

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

This means that apart from the head atom via which the rule is adorned, only positive body atoms can yield variable
bindings and only if at least one of their arguments is bound, but both atoms with EDB and IDB predicates can do so.
Moreover, atoms with more bound arguments will be processed before those with fewer bound arguments.

Note that in this work we did not study the impact of trying different SIPS schemes, as we wanted to focus on
showing the impact that our technique can have, rather than ﬁne-tuning its parameters. While we believe that the SIPS
schema employed is well-motivated, there probably is quite a bit of room for improvement, which we leave for future
work.

An executable of the DLV system supporting the Magic Set optimization is available at http://www.dlvsystem.com/magic/.

4.2. Dealing with redundant rules

Even though our rewriting algorithm keeps the amount of generated rules low, it might happen that some redundant
rules are generated when adorning disjunctive rules, thereby somewhat deteriorating the optimization effort. For instance, in
Example 3.6 the ﬁrst two modiﬁed rules are semantically equivalent, and this might happen even if the two head predicates
differ. In general not only duplicated rules might be created, but also rules which are logically subsumed by other rules in
the program. Let us ﬁrst give the deﬁnition of subsumption for Datalog

∨,¬s rules.

(cid:4)

Deﬁnition 4.1. Let P be a Datalog
r (cid:25) r
if there exists a rule r

) if there exists a substitution ϑ for the variables of r
such that r (cid:25) r

program, and let r and r

.

(cid:4)

(cid:4)

(cid:4)

∨,¬

(cid:4)

be two rules of P . Then, r is subsumed by r

(cid:4)

(denoted by
(cid:4))ϑ ⊆ B(r). A rule r is redundant

, such that H(r

(cid:4))ϑ ⊆ H(r) and B(r

Ideally, a Magic Set rewriting algorithm should be capable of identifying all the possible redundant rules and removing
them from the output. Unfortunately, this approach is unlikely to be feasible in polynomial time, given that subsumption
checking on ﬁrst-order expressions is NP-complete (problem [LO18] in [27]).

Thus, in order to identify whether a rule r produced during the Magic Set transformation is redundant, we pragmati-
cally apply a greedy subsumption algorithm in our implementation, for checking whether r (cid:25) r
. In
particular, the employed heuristics aims at building the substitution ϑ (as in Deﬁnition 4.1) by iteratively choosing an atom
p(¯t) (which is not yet processed) from r
and by matching it (if possible) with some atom of r. The greedy approach prefers
those atoms of r

with the maximum number of variables not yet matched.

holds for some rule r

(cid:4)

(cid:4)

(cid:4)

(cid:4)

To turn on subsumption checking (applied once after the Magic Set rewriting), DLV has to be invoked with the command-

line option -ODMS+.

5. Experiments on standard benchmarks

We performed several experiments for assessing the effectiveness of the proposed technique. In this section we present
the results obtained on various standard benchmarks, most of which have been directly adopted from the literature. Further
experiments on an application scenario using real-world data will be discussed in detail in Section 6. We also refer to
[45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning
tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is
confronted against other ontology systems. In both publications the impact of Magic Sets is stated explicitly.

5.1. Compared methods, benchmark problems and data

In order to evaluate the impact of the proposed method, we have compared DMS (using the SIPS deﬁned outlined
in Section 4) both with the traditional DLV evaluation without Magic Sets and with the SMS method proposed in [33].
Concerning SMS, we were not able to obtain an implementation, and have therefore performed the rewriting manually. As
a consequence, the runtime measures obtained for SMS do not contain the time needed for rewriting, while it is included
for DMS.

For the comparison, we consider the following benchmark problems. The ﬁrst three of them had been already used to

assess SMS in [33], to which we refer for details:

• Simple Path: Given a directed graph G and two nodes a and b, does there exist a unique path connecting a to b in G?
The instances are encoded by facts edge(v1, v2) for each arc (v 1, v 2) in G, while the problem itself is encoded by the
program8

sp(X, X) ∨ not_ sp(X, X) :− edge(X, Y).
sp(X, Y) ∨ not_ sp(X, Y) :− sp(X, Z), edge(Z, Y).

8 The ﬁrst rule of the program models that for each node X of G, a unique path connecting X with itself can either exist or not.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

179

Fig. 7. Instances structure of Simple Path and Related (left) and of Conformant Plan Checking (right).

path(X, Y) :− sp(X, Y).
path(X, Y) :− not_ sp(X, Y).
not_ sp(X, Z) :− path(X, Y1), path(X, Y2), Y1 <> Y2, edge(Y1, Z), edge(Y2, Z).

with the query sp(a, b). The structure of the graph, which is the same as the one reported in [33], consists of a square
matrix of nodes connected as shown in Fig. 7, and the instances have been generated by varying of the number of
nodes.

• Related: Given a genealogy graph storing information about relationships (father/brother) among people and given two
people p1 and p2, is p1 an ancestor of p2? The instances are encoded by facts related(p1, p2) when p1 is known to
be related to p2, that is, when p1 is the father or a brother of p2. The problem can be encoded by the program

father(X, Y) ∨ brother(X, Y) :− related(X, Y).
ancestor(X, Y) :− father(X, Y).
ancestor(X, Y) :− father(X, Z), ancestor(Z, Y).

and the query is ancestor(p1, p2). The structure of the “genealogy” graph is the same as the one presented in [33]
and coincides with the one used for testing Simple Path. Also in this case, the instances are generated by varying the
number of nodes (thus the number of persons in the genealogy) of the graph.

(cid:4)

for some i = 1, . . . , m then ci ∈ C

• Strategic Companies: This is a slight variant of the problem domain used in the running example. The description here
is of the problem as posed in the Third ASP Competition. We consider a collection C of companies, where each com-
pany produces some goods in a set G and each company ci ∈ C is controlled by a set of owner companies O i ⊆ C .
(cid:4) ⊂ C is a strategic set if it is a minimal set of companies producing all the goods in G,
A subset of the companies C
such that if O i ⊆ C
must hold. As in the Second Answer Set Competition,9 we
assume that each product is produced by at most four companies, and that each company is controlled by at most
four companies (the complexity of the problem under these restrictions is as hard as without them). Given two dis-
tinct companies ci, c j ∈ C , is there a strategic set of C which contains both ci and c j ? The instances are encoded by
facts produced_by(p, c1, c2, c3, c4) when product p is produced by companies c1, c2, c3, and c4; if p is produced
by fewer than four companies (but at least one), then c1, c2, c3, c4 contains repetitions of companies. Moreover, facts
controlled_by(c, c1, c2, c3, c4) represent that company c is controlled by companies c1, c2, c3, and c4; again, if c
is controlled by fewer than four companies, then c1, c2, c3, c4 contains repetitions. The problem can be encoded by the
program

(cid:4)

st(C1) ∨ st(C2) ∨ st(C3) ∨ st(C4) :− produced_by(P, C1, C2, C3, C4).
st(C) :− controlled_by(C, C1, C2, C3, C4), st(C1), st(C2), st(C3), st(C4).

with the query st(ci), st(cj). While the language presented in the previous sections allowed only for one atom in a
query for simplicity, the implementation in DLV allows for a conjunction in a query; it is easy to see that a conjunctive
query can be emulated by a rule with the conjunction in the body and an atom with a new predicate in the head,
which contains all body arguments, and ﬁnally replacing the query conjunction with this atom. In this case this would
mean adding a rule q(ci, cj) :− st(ci), st(cj) and replacing the query by q(ci, cj). For this benchmark we used
the instances submitted for the Second Answer Set Competition.

9 http://www.cs.kuleuven.be/~dtai/events/ASP-competition/index.shtml.

180

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

Fig. 8. Simple Path: Average execution time.

• Conformant Plan Checking: In addition, we have included a benchmark problem, which highlights the fact that our Magic
Set technique can yield improvements not only for the grounding, but also for the model generation phase, as discussed
in Section 7. This problem is inspired by a setting in planning, in particular testing whether a given plan is conformant
with respect to a state transition diagram [30]. Such a diagram is essentially a directed graph formed of nodes repre-
senting states, and in which arcs are labeled by actions, meaning that executing the action in the source state will lead
to the target state. In the considered setting non-determinism is allowed, that is, executing an action in one state might
lead non-deterministically to one of several successor states. A plan is a sequence of actions, and it is conformant with
respect to a given initial state and a goal state if each possible execution of the action sequence leads to the goal state.
In our benchmark, we assume that the action selection process has already been done, thus having reduced the state
transition diagram to those transitions that actually occur when executing the given plan. Furthermore we assume
that there are exactly two possible non-goal successor states for any given state. This can also be viewed as whether
all outgoing paths of a node in a directed graph reach a particular conﬂuence node. We encoded instances by facts
ptrans(s0, s1, s2) meaning that one of states s1 and s2 will be reached in the plan execution starting from s0. The
problem is encoded using

trans(X, Y) ∨ trans(X, Z) :− ptrans(X, Y, Z).
reach(X, Y) :− trans(X, Y).
reach(X, Y) :− reach(X, Z), trans(Z, Y).

and the query reach(0, 1), where 0 is the initial state and 1 the goal state. If the query is cautiously true, the plan is
conformant. The transition graphs in our experiments have the shape of a binary tree rooted in state 0, and from each
leaf there is an arc to state 1, as depicted in Fig. 7.

In addition, we have performed further experiments on an application scenario modeled from real-world data for an-

swering user queries in a data integration setting. These latter experiments will be discussed in more detail in Section 6.

5.2. Results and discussion

The experiments have been performed on a 3 GHz Intel® Xeon® processor system with 4 GB RAM under the Debian
4.0 operating system with a GNU/Linux 2.6.23 kernel. The DLV prototype used has been compiled using GCC 4.3.3. For each
instance, we have allowed a maximum running time of 600 seconds (10 minutes) and a maximum memory usage of 3 GB.
On all considered problems, DMS outperformed SMS, even if SMS does not include the rewriting time, as discussed in

Section 5.1. Let us analyze the results for each problem in more detail.

The results for Simple Path are reported in Fig. 8. DLV without Magic Sets solves only the smallest instances, with a very
steep increase in execution time. SMS does better than DLV, but scales much worse than DMS. The difference between SMS
and DMS is mostly due to the grounding of the additional predicates that SMS introduces.

Fig. 9 reports the results for Related. Compared to Simple Path, DLV without Magic Sets exhibits an even steeper increase
in runtime, while in contrast both SMS and DMS scale better than on Simple Path. Comparing SMS and DMS, we note that
DMS appears to have an exponential speedup over SMS. In this case, the computational gain of DMS over SMS is due to the
dynamic optimization of the model search phase resulting from our Magic Sets deﬁnition. This aspect is better highlighted
by the Conformant Plan Checking benchmark, and will be discussed later in this section.

For Strategic Companies, we report the results in Fig. 10 as a bar diagram, because the instances do not have a uniform
structure. The instances are, however, ordered by size. Also here, DLV without Magic Sets is clearly the least eﬃcient of the

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

181

Fig. 9. Related: Average execution time.

Fig. 10. Strategic Companies: Average execution time.

tested systems, resolving only the smallest two instances in the allotted time (600 seconds). Concerning the other systems,
SMS and DMS essentially show equal performance. In fact, the situation here is quite different to Simple Path and Related,
because grounding the program produced by the Magic Set rewriting takes only a negligible amount of time for SMS and
DMS. For this benchmark the important feature is reducing the ground program to the part which is relevant for the query,
and we could verify that the ground programs produced by SMS and DMS are precisely the same.

Finally, the results for Conformant Plan Checking are shown in Fig. 11. While DLV shows a similar behavior as for Simple
Path and Related, here also SMS does not scale well at all, and in fact DMS appears to have an exponential speedup over
SMS. There is a precise reason for this: While the Magic Set rewriting of SMS always creates a deterministic program deﬁn-
ing the magic predicates, this is not true for DMS. As a consequence, all magic predicates are completely evaluated during
the grounding phase of DLV for SMS, while for DMS this is not the case. At the ﬁrst glance, this may seem like a disadvan-
tage of DMS, as one might believe that the ground program becomes larger. However, it is actually a big advantage of DMS,
because it offers a more precise identiﬁcation of the relevant part of the program. Roughly speaking, whatever SMS identiﬁes
as relevant for the query will also be identiﬁed as relevant in DMS, but DMS can also include non-deterministic relevance in-
formation, which SMS cannot. This means that in DMS Magic Sets can be exploited also during the non-deterministic search
phase of DLV, dynamically disabling parts of the ground program. In particular, after having made some choices, parts of
the program may no longer be relevant to the query, but only because of these choices, and the magic atoms present in the
ground program can render these parts satisﬁed, which means that they will no longer be considered in this part of the
search. SMS cannot induce any behavior like this and its effect is limited to the grounding phase of DLV, which can make a
huge difference, as evidenced by Conformant Plan Checking.

5.3. Experimenting DMS with other disjunctive Datalog systems

In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the
following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37]. ClaspD is based on advanced Boolean constraint solving
techniques, featuring backjumping and conﬂict-driven learning. Cmodels is based on the deﬁnition of program completion
and loop formula for disjunctive programs [40,47], and uses a SAT solver for generating candidate solutions and testing

182

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

Fig. 11. Conformant Plan Checking: Average execution time.

Fig. 12. Simple Path: Average execution time on other systems.

them. GnT1 is based on Smodels [61], a system handling Datalog programs with unstratiﬁed negation (normal programs):
A disjunctive program is translated into a normal program, the stable models of which are computed by Smodels and
represent stable model candidates of the original program. Each of these candidates is then checked to be a stable model of
the original program by invoking Smodels on a second normal program. GnT2 is a variant of GnT1 in which the number of
candidates produced by the ﬁrst normal program is reduced by means of additional rules that discard unsupported models,
i.e., models containing some atom a for which there is no rule r such that B(r) is true and a is the only true atom in H(r).
All of the benchmarks presented in the previous section were tested on these systems. Since DMS is not implemented
in these systems, rewritten programs were produced by DLV during the preparation of the experiment. We recall that DMS
does not depend on EDB relations and point out that DLV computes rewritten programs for the considered encodings in
1–2 hundredths of a second. The results of our experiment are reported in Figs. 12–16. In general, we tried use a consistent
scales in the graphs in order to ease comparability. However, for some graphs we chose a different scale in order to keep
them readable for the main purpose (comparing performances with and without DMS), and we mention this explicitly in
the accompanying text.

Concerning Simple Path, the advantages of DMS over the unoptimized encoding are evident on all tested systems. In fact,
as shown in Fig. 12, without DMS all tested systems did not answered in the allotted time (600 seconds) on instances with
more than 400 nodes (900 for Cmodels). On the other hand, all of the instances considered in the benchmark (up to 40
thousands of nodes) were solved by all tested solvers with the DMS encoding. We also observe that with DMS the tested
systems are faster than DLV in this benchmark, which is a clear indication of the optimization potential that can be provided
to these systems by our Magic Set technique.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

183

Fig. 13. Related: Average execution time on other systems.

For Related we obtained a similar result, reported in Fig. 13 (we used a different scale for the y-axis for Cmodels for
readability). Without DMS only the smallest instances were solved in the allotted time (up to 2025 nodes for ClaspD and
Cmodels, up to 625 nodes for GnT1 and GnT2). With DMS, instead, all tested systems solved the biggest instances of the
benchmark (up to 10 thousands of nodes). In particular, with DMS Cmodels is as performant as dlv in this benchmark.

The effectiveness of DMS is also evident in the Strategic Companies benchmark (Figs. 14–15). In fact, we observed sensible
performance gains of all systems on all tested instances. GnT1, which is already faster than the other tested systems in this
benchmark, draws particular advantage from DMS, solving all instances in few seconds. We give another evidence of the
optimization potential provided by DMS to these systems by comparing the number of solved instances: Of a total of 60
tests, we counted 37 timeouts on the unoptimized encoding (10 on ClaspD, 14 on Cmodels, 3 on GnT1 and 10 on GnT2),
while just one on the encoding obtained by applying DMS. We point out that the timeout on the rewritten program was
obtained by the Cmodels system, which alone collected 14 timeouts on the unoptimized encoding and is thus the least
performant on this benchmark.

Finally, consider the results for Conformant Plan Checking reported in Fig. 16 (we used a different scale on the y-axis for
ClaspD for readability; note also that ClaspD and GnT2 only solved the smallest instances of this benchmark, and we thus
used a different scale for their x-axes). The performance of ClaspD is poor in this benchmark, nonetheless we observed a
slight improvement in execution time if DMS is applied on the encoding reported in Section 5.1. Cmodels performs better
than ClaspD in this case and the optimization potential of DMS emerges with an exponential improvement in performance.
A similar result was observed for GnT1, while GnT2 on this benchmark is the only outlier of the experiment: Its performance
deteriorates if the original program is processed by DMS. However, in this benchmark GnT2 performs worse that GnT1
also with the original encoding. In fact, while GnT1 solved the biggest instance (more than 65 thousands of states) in
209.74 seconds (12.28 seconds with the DMS encoding), the execution of GnT2 did not terminate in the allotted time
(600 seconds) on instances containing more than 10 thousands of states. We ﬁnally note that with DMS GnT1 and Cmodels
are faster than DLV in this benchmark. In fact, for the biggest instance in the benchmark, GnT1 and Cmodels required 12.28
and 19.13 seconds, respectively, while DLV terminated in 279.41 seconds. The signiﬁcant performance gain of GnT1 and
Cmodels due to DMS is a further conﬁrmation of the potential of our optimization technique.

6. Application to data integration

In this section we give a brief account of a case study that evidences the impact of the Magic Set method when used
on programs that realize data integration systems. We ﬁrst give an overview of data integration systems, show how they
∨,¬s , and ﬁnally assess the impact of Magic Sets on a data integration system involving
can be implemented using Datalog
real-world data.

6.1. Data integration systems in a nutshell

The main goal of data integration systems is to offer transparent access to heterogeneous sources by providing users
with a global schema, which users can query without having to know from what sources the data come from. In fact, it is
the task of the data integration system to identify and access the data sources which are relevant for ﬁnding the answer

184

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

Fig. 14. Strategic Companies: Average execution time on other systems (part 1).

to a query over the global schema, followed by a combination of the data thus obtained. The data integration system uses
a set of mapping assertions, which specify the relationship between the data sources and the global schema. Following [41],
we formalize a data integration system I as a triple (cid:14)G, S, M(cid:15), where:

(1) G is the global (relational) schema, that is, a pair (cid:14)Ψ, Σ(cid:15), where Ψ is a ﬁnite set of relation symbols, each with an
associated positive arity, and Σ is a ﬁnite set of integrity constraints (ICs) expressed on the symbols in Ψ . ICs are
ﬁrst-order assertions that are intended to be satisﬁed by database instances.

(2) S is the source schema, constituted by the schemes of the various sources that are part of the data integration system.
We assume that S is a relational schema of the form S = (cid:14)Ψ (cid:4), ∅(cid:15), which means that there are no integrity constraints on
the sources. This assumption implies that data stored at the sources are locally consistent; this is a common assumption
in data integration, because sources are in general external to the integration system, which is not in charge of analyzing
or restoring their consistency.

(3) M is the mapping which establishes the relationship between G and S. In our framework, the mapping follows the

GAV approach, that is, each global relation is associated with a view—a Datalog

∨,¬s query over the sources.

The main semantic issue in data integration systems is that, since integrated sources are originally autonomous, their
data, transformed via the mapping assertions, may not satisfy the constraints of the global schema. An approach to remedy
to this problem that has lately received a lot of interest in the literature (see, e.g., [3,11,12,14,16–19,25,26]) is based on
the notion of repair for an inconsistent database as introduced in [4]. Roughly speaking, a repair of a database is a new
database that satisﬁes the constraints in the schema, and minimally differs from the original one. Since an inconsistent
database might possess multiple repairs, the standard approach in answering user queries is to return those answers that
are true in every possible repair. These are called consistent answers in the literature.

6.2. Consistent query answering via Datalog

∨,¬s queries

There is an intuitive relation between consistent answers to queries over data integration systems and queries over
∨,¬s
∨,¬s programs: Indeed, if one could ﬁnd a translation from data sources, mapping, and the query to a Datalog

Datalog

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

185

Fig. 15. Strategic Companies: Average execution time on other systems (part 2).

Fig. 16. Conformant Plan Checking: Average execution time on other systems.

186

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

program, which possesses a stable model for each possible repair, and a query over it, the consistent answers within the
data integration system will correspond to cautious consequences of the obtained Datalog

∨,¬s setting.

In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the constraints of the global schema G into
various kinds of logic programs, such that the stable models of this program yield the repairs of the database retrieved from
the sources. Some of these approaches use logic programs with unstratiﬁed negation, [16], whereas disjunctive Datalog
programs together with unstratiﬁed negation have been considered in [13,51].

It has already been realized earlier that Magic Sets are a crucial optimization technique in this context, and indeed the
availability of the transformational approach using stable logic programming as its core language was a main motivation for
the research presented in this article, since in this way a Magic Set method for stable logic programs immediately yields
an optimization technique for data integration systems. Indeed, the beneﬁts of Magic Sets in the context of optimizing logic
programs with unstratiﬁed negation (but without disjunction) have been discussed in [24]. The Magic Set technique deﬁned
in [24] is quite different from the one deﬁned in this article, as it does not consider disjunctive rules, and works only
for programs, which are consistent, that is, have at least one stable model. In [51] our preliminary work reported in [20],
which eventually led to the present article, has been expanded in an ad-hoc way to particular kinds of Datalog programs
with disjunction and unstratiﬁed negation. It is ad-hoc in the sense that it is tailored to programs which are created by
the transformation described in [51]. The experimental results reported in [51] show huge computational advantages when
using Magic Sets.

We now report an alternative transformation which produces Datalog

∨,¬s programs (therefore different to [51], there
are no unstratiﬁed occurrences of negation). This rewriting has been devised and used within the INFOMIX system on data
integration [42].

Let I = (cid:14)G, S, M(cid:15) be a data integration system where G = (cid:14)Ψ, Σ(cid:15), and let D be a database for G, which is represented
as a set of facts over the relational predicates in G. We assume that constraints over the global schema are key and exclusion
dependencies. In particular, we recall that a set of attributes ¯x is a key for the relation r if:

(cid:2)
(cid:3)
r(¯x, ¯y) ∧ r(¯x, ¯z)

→ ¯y = ¯z, ∀

(cid:6)
(cid:4)
r(¯x, ¯y), r(¯x, ¯z)

⊆ D

and that an exclusion dependency holds between a set of attributes ¯x of a relation r and a set of attributes ¯w of a relation
s if

(cid:2)
(cid:3)
r(¯x, ¯y) ∧ s( ¯w, ¯z)

→ ¯y (cid:9)= ¯z, ∀

(cid:6)
(cid:4)
r(¯x, ¯y), s( ¯w, ¯z)

⊆ D

Then, the disjunctive rewriting of a query q with respect to I is the Datalog

∨,¬s program Π(I) = ΠKD ∪ ΠED ∪ ΠM ∪ Πcoll

where:

• For each relation r in G and for each key deﬁned over its set of attributes ¯x, ΠKD contains the rules:

rout(¯x, ¯y) ∨ rout(¯x, ¯z) :− rD(¯x, ¯y), rD(¯x, ¯z), Y 1 (cid:9)= Z1.

...

rout(¯x, ¯y) ∨ rout(¯x, ¯z) :− rD(¯x, ¯y) , rD(¯x, ¯z), Ym (cid:9)= Zm.

where ¯y = Y 1, . . . , Ym, and ¯z = Z1, . . . , Zm.

• For each exclusion dependency between a set of attributes ¯x of a relation r and a set of attributes ¯w of a relation s,

ΠED contains the following rule:

rout(¯x, ¯y) ∨ sout( ¯w, ¯z) :− rD(¯x, ¯y), sD( ¯w, ¯z), X1 = W 1, . . . , Xm = W m.

where ¯x = X1, . . . , Xm, and ¯w = W 1, . . . , W m. In the implementation the following equivalent rule is used:

rout(¯x, ¯y) ∨ sout(¯x, ¯z) :− rD(¯x, ¯y), sD(¯x, ¯z).

• For each relation r in G, Πcoll contains the rule:

r( ¯w) :− rD( ¯w), not rout( ¯w).

• For each Datalog rule r in M such that:

k(¯t) :− q1(¯s1), . . . , qm(¯sm).

where k is a relation in G and qi (for 1 (cid:4) i (cid:4) m) is a relation in S, ΠM contains the rule:

kD(¯t) :− q1(¯s1), . . . , qm(¯sm).

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

187

Fig. 17. Average execution time of query evaluation in the INFOMIX Demo Scenario.

It can be shown that for each user query Q (over G) and for each source database F (over S), consistent query answers
to Q precisely coincide with the set Ansc(Q, Π (I) ∪ F ). Actually, within the INFOMIX project also inclusion dependencies
have been considered according to the rewriting discussed in [16], whose details we omit for clarity. Since the rewriting
for inclusion dependencies also modiﬁes queries, in the INFOMIX project queries have been limited to conjunctive queries.
∨,¬s
It is however important to notice that the program Π(I) contains only stratiﬁed negation and is therefore a Datalog
program, making the Magic Set method deﬁned in this article applicable.

6.3. Experimental results

The effectiveness of the Magic Set method in this crucial application context has then been assessed via a number of
experiments carried out on the demonstration scenario of the INFOMIX project, which refers to the information system of
the University “La Sapienza” in Rome. The global schema consists of 14 global relations with 29 constraints, while the data
sources include 29 relations of 3 legacy databases and 12 wrappers generating relational data from web pages. This amounts
to more than 24 MB of data regarding students, professors and exams in several faculties of the university. For a detailed
description of the INFOMIX project see https://www.mat.unical.it/infomix/.

On this schema, we have tested ﬁve typical queries with different characteristics, which model different use cases. For
the sake of completeness, the full encodings of the tested queries are reported in Appendix A. In particular, we measured
the average execution time of DLV computing Ansc(Q, Π (I) ∪ F ) and Ansc(Q, DMS(Q, Π (I)) ∪ F ) on datasets of increasing
size. The experiments were performed by running the INFOMIX prototype system on a 3 GHz Intel® Xeon® processor
system with 4 GB RAM under the Debian 4.0 operating system with a GNU/Linux 2.6.23 kernel. The DLV prototype used
as the computational core of the INFOMIX system had been compiled using GCC 4.3.3. For each instance, we allowed a
maximum running time of 10 minutes and a maximum memory usage of 3 GB.

The results, reported in Fig. 17, conﬁrm that on these typical queries the performance is considerably improved by Magic
Sets. On Queries 1 to 4 in Fig. 17 the response time scales much better with Magic Sets than without, appearing essentially
linear on the tested instance sizes, while without Magic Sets the behavior has a decidedly non-linear appearance. We also
observe that there is basically no improvement on Query 5. We have analyzed this query and for this use case all data

188

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

seems to be relevant to the query, which means that Magic Sets cannot have any positive effect. It is however important to
observe that the Magic Set rewriting does not incur any signiﬁcant overhead.

7. Related work

In this section we ﬁrst discuss the main body of work which is related to DMS, the technique developed in this paper
for query answering optimization. In particular, we discuss Magic Set techniques for Datalog languages. The discussion is
structured in paragraphs grouping techniques which cover the same language. After that, we discuss some applications for
which DMS have already been exploited. All these applications refer to the preliminary work published in [20].

Magic Sets for Datalog. In order to optimize query evaluation in bottom–up systems, like deductive database systems,
several works have proposed the simulation of top–down strategies by means of suitable transformations introducing new
predicates and rewriting clauses. Among them, Magic Sets for Datalog queries are one of the best-known logical optimization
techniques for database systems. The method, ﬁrst developed in [6], has been analyzed and reﬁned by many authors; see,
for instance, [9,55,62,63]. These works form the foundations of DMS.

¬s . Many authors have addressed the issue of extending the Magic Set technique in order to deal
Magic Sets for Datalog
¬s
with Datalog queries involving stratiﬁed negation. The main problem related to the extension of the technique to Datalog
¬s programs have a natural and
programs is how to assign a semantics to the rewritten programs. Indeed, while Datalog
accepted semantics, namely the perfect model semantics [2,64], the application of Magic Sets can introduce unstratiﬁed
negation in the rewritten programs. A solution has been presented in [10,38,39,59]. In particular, in [38,59] rewritten pro-
programs which
grams have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog
is two-valued for stratiﬁed programs, while in [10,39] ad-hoc semantics have been deﬁned. All of these methods exploit a
¬s which is not present in disjunctive Datalog, uniqueness of the intended model. This property in turn
property of Datalog
implies that query answering just consists in establishing the truth value of some atoms in one intended model. Using our
terminology, brave and cautious reasoning coincide for these programs. Therefore, all these methods are quite different from
DMS, the technique developed in this paper.

¬

¬

¬

¬

. Extending the Magic Set technique to Datalog

programs must face two major diﬃculties. First,
Magic Sets for Datalog
program uniqueness of the intended model is no more guaranteed, thus query answering in this setting
for a Datalog
involves a set of stable models in general. The second diﬃculty is that parts of a Datalog
program may act as constraints,
programs has been
thus impeding a relevant interpretation to be a stable model. In [24] a Magic Set method for Datalog
deﬁned and proved to be correct for coherent programs, i.e., programs admitting at least one stable model. This method
takes special precautions for relevant parts of the program that act as constraints, called dangerous rules in [24]. We observe
∨,¬s programs, which allows for the simpler DMS algorithm to work correctly
that dangerous rules cannot occur in Datalog
for this class of programs.

¬

¬

∨

. The ﬁrst extension of the Magic Set technique to disjunctive Datalog is due to [32,33], where the
Magic Sets for Datalog
SMS method has been presented and proved to be correct for Datalog
programs. We point out that the main drawback of
this method is the introduction of collecting predicates. Indeed, magic and collecting predicates of SMS have deterministic
deﬁnitions. As a consequence, their extension can be completely computed during program instantiation, which means that
no further optimization is provided for the subsequent stable model search. Moreover, while the correctness of DMS has
∨,¬s programs has only
been formally established for Datalog
been outlined in [32,33].

∨,¬s programs in general, the applicability of SMS to Datalog

∨

Applications. Magic Sets have been applied in many contexts. In particular, [13,36,51,53] have proﬁtably exploited the
optimization provided by DMS. In particular, in [13,51] a data integration system has been presented. The system is based
on disjunctive Datalog and exploits DMS for fast query answering. In [36,53], instead, an algorithm for answering queries
over description logic knowledge bases has been presented. More speciﬁcally, the algorithm reduces a SHIQ knowledge
base to a disjunctive Datalog program, so that DMS can be exploited for query answering optimization.

8. Conclusion

The Magic Set method is one of the best-known techniques for the optimization of positive recursive Datalog programs
due to its eﬃciency and its generality. Just a few other focused methods such as the supplementary Magic Set and other
special techniques for linear and chain queries have gained similar visibility (see, e.g., [34,56,63]). After seminal papers
[6,9], the viability of the approach was demonstrated e.g., in [35,55]. Later on, extensions and reﬁnements were proposed,
addressing e.g., query constraints in [62], the well-founded semantics in [38], or integration into cost-based query optimiza-
tion in [60]. The research on variations of the Magic Set method is still going on. For instance, in [24] an extension of the
Magic Set method was discussed for the class of unstratiﬁed logic programs (without disjunction). In [10] a technique for
the class of soft-stratiﬁable programs was given. Finally, in [33] the ﬁrst variant of the technique for disjunctive programs
(SMS) was described.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

189

In this paper, we have elaborated on the issues addressed in [32,33]. Our approach is similar to SMS, but differs in

several respects:

• DMS is a dynamic optimization of query answering, in the sense that in addition to the optimization of the grounding
process (which is the only optimization performed by SMS), DMS can drive the model generation phase by dynamically
disabling parts of the program that become irrelevant in the considered partial interpretations.

• DMS has a strong relationship with unfounded sets, allowing for a clean application to disjunctive Datalog programs

also in presence of stratiﬁed negation.

• DMS can be further improved by performing a subsequent subsumption check.
• DMS is integrated into the DLV system [43], proﬁtably exploiting the DLV internal data-structures and the ability of

controlling the grounding module.

We have conducted experiments on several benchmarks, many of which taken from the literature. The results of our
experimentation evidence that our implementation outperforms SMS in general, often by an exponential factor. This is
mainly due to the optimization of the model generation phase, which is speciﬁc to our Magic Set technique. In addition, we
have conducted further experiments on a real application scenario, which show that Magic Sets can play a crucial role in
optimizing consistent query answering over inconsistent databases. Importantly, other authors have already recognized the
beneﬁts of our optimization strategies with respect to this very important application domain [51], thereby conﬁrming the
validity and the robustness of the work discussed in this paper.

We conclude by observing that it has been noted in the literature (e.g., in [38]) that in the non-disjunctive case memoing
techniques lead to similar computations as evaluations after Magic Set transformations. Also in the disjunctive case such
techniques have been proposed (e.g., Hyper Tableaux [8]), for which similar relations might hold. While [38] has already
evidenced that an advantage of Magic Sets over such methods is that they may be more easily combined with other
optimization techniques, we believe that achieving a deeper comprehension of the relationships among these techniques
constitutes an interesting avenue for further research.

Another issue that we leave for future work is to study the impact of changing some parameters of the DMS method, in

particular the impact of different SIPSes.

Appendix A. Queries on the INFOMIX demo scenario

INFOMIX is a project that was funded by the European Commission in its Information Society Technologies track of the
Sixth Framework Programme for providing an advanced system for information integration. A detailed description of the

courseD(X1, X2) : − esame(_, X1, X2, _).
courseD(X1, X2) : − esame_diploma(X1, X2).
exam_recordD(X1, X2, Z, W, X4, X5, Y) : − affidamenti_ing_informatica(X2, X3, Y),

dati_esami(X1, _, X2, X5, X4, _, Y), dati_professori(X3, Z, W).

exam_recordout(X1, X2, X3, X4, Y5, Y6, Y7) ∨ exam_recordout(X1, X2, X3, X4, Z5, Z6, Z7) : −

exam_recordD(X1, X2, X3, X4, Y5, Y6, Y7), exam_recordD(X1, X2, X3, X4, Z5, Z6, Z7), Y5 (cid:9)= Z5.

exam_recordout(X1, X2, X3, X4, Y5, Y6, Y7) ∨ exam_recordout(X1, X2, X3, X4, Z5, Z6, Z7) : −

exam_recordD(X1, X2, X3, X4, Y5, Y6, Y7), exam_recordD(X1, X2, X3, X4, Z5, Z6, Z7), Y6 (cid:9)= Z6.

exam_recordout(X1, X2, X3, X4, Y5, Y6, Y7) ∨ exam_recordout(X1, X2, X3, X4, Z5, Z6, Z7) : −

exam_recordD(X1, X2, X3, X4, Y5, Y6, Y7), exam_recordD(X1, X2, X3, X4, Z5, Z6, Z7), Y7 (cid:9)= Z7.

course(X1, X2) : − courseD(X1, X2), not courseout(X1, X2).
exam_record(X1, X2, X3, X4, X5, X6, X7) : − exam_recordD(X1, X2, X3, X4, X5, X6, X7),

not exam_recordout(X1, X2, X3, X4, X5, X6, X7).

query1(CD) : − course(C, CD), exam_record(“09089903", C, _, _, _, _, _).
query1(CD)?
studentD(X1, X2, X3, X4, X5, X6, X7) : − diploma_maturita(Y, X7),

studente(X1, X3, X2, _, _, _, _, _, _, _, _, _, X6, X5, _, _, X4, _, _, _, _, Y, _).

student(X1, X2, X3, X4, X5, X6, X7) : − studentD(X1, X2, X3, X4, X5, X6, X7),

not studentout(X1, X2, X3, X4, X5, X6, X7).

query2(SFN, SLN, COR, ADD, TEL, HSS) : − student(“09089903", SFN, SLN, COR, ADD, TEL, HSS).
query2(SFN, SLN, COR, ADD, TEL, HSS)?
studentD(X1, X2, X3, X4, X5, X6, X7) : − diploma_maturita(Y, X7),

studente(X1, X3, X2, _, _, _, _, _, _, _, _, _, X6, X5, _, _, X4, _, _, _, _, Y, _).
student_course_planD(X1, X2, X3, X4, X5) : − orientamento(Y1, X3),
piano_studi(X1, X2, Y1, X4, Y2, _, _, _, _, _), stato(Y2, X5).

student(X1, X2, X3, X4, X5, X6, X7) : − studentD(X1, X2, X3, X4, X5, X6, X7),

not studentout(X1, X2, X3, X4, X5, X6, X7).

student_course_plan(X1, X2, X3, X4, X5) : − student_course_planD(X1, X2, X3, X4, X5),

not student_course_planout(X1, X2, X3, X4, X5).
query3(SID, SLN, R) : − student(SID, “ZNEPB", SLN, _, _, _, _),

student_course_plan(_, SID, _, R, “APPROVATO SENZA MODIFICHE").

query3(SID, SLN, R)?

Fig. A.1. INFOMIX Queries 1–3.

190

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

studentD(X1, X2, X3, X4, X5, X6, X7) : − diploma_maturita(Y, X7),

studente(X1, X3, X2, _, _, _, _, _, _, _, _, _, X6, X5, _, _, X4, _, _, _, _, Y, _).

courseD(X1, X2) : − esame(_, X1, X2, _).
courseD(X1, X2) : − esame_diploma(X1, X2).
student_course_planD(X1, X2, X3, X4, X5) : − orientamento(Y1, X3),
piano_studi(X1, X2, Y1, X4, Y2, _, _, _, _, _), stato(Y2, X5).

plan_dataD(X1, X2, X3) : − dati_piano_studi(X1, X2, _),

esame_ingegneria(X2, Y3, Y2, _), tipo_esame(Y2, X3).

student(X1, X2, X3, X4, X5, X6, X7) : − studentD(X1, X2, X3, X4, X5, X6, X7),

not studentout(X1, X2, X3, X4, X5, X6, X7).

student_course_plan(X1, X2, X3, X4, X5) : − student_course_planD(X1, X2, X3, X4, X5)

not student_course_planout(X1, X2, X3, X4, X5).

plan_data(X1, X2, X3) : − plan_dataD(X1, X2, X3), not plan_dataout(X1, X2, X3).
course(X1, X2) : − courseD(X1, X2), not courseout(X1, X2).
query4(F, S) : − course(CID, “RETILOGICHE"), plan_data(SCID, CID, _),

student(SID, F, S, “ROMA", _, _, _), student_course_plan(SCID, SID, _, _, _).

query4(F, S)?
courseD(X1, X2) : − esame(_, X1, X2, _).
courseD(X1, X2) : − esame_diploma(X1, X2).
student_course_planD(X1, X2, X3, X4, X5) : − orientamento(Y1, X3),
piano_studi(X1, X2, Y1, X4, Y2, _, _, _, _, _), stato(Y2, X5).

plan_dataD(X1, X2, X3) : − dati_piano_studi(X1, X2, _),

esame_ingegneria(X2, Y3, Y2, _), tipo_esame(Y2, X3).

student_course_plan(X1, X2, X3, X4, X5) : − student_course_planD(X1, X2, X3, X4, X5),

not student_course_planout(X1, X2, X3, X4, X5).

plan_data(X1, X2, X3) : − plan_dataD(X1, X2, X3), not plan_dataout(X1, X2, X3).
course(X1, X2) : − courseD(X1, X2), not courseout(X1, X2).
query5(D) : − course(E, D), plan_data(C, E, _), student_course_plan(C, “09089903", _, _, _).
query5(D)?

Fig. A.2. INFOMIX Queries 4–5.

project, including references in the literature, can be found at https://www.mat.unical.it/infomix/. Five typical queries of the
INFOMIX demo scenario have been considered for assessing Dynamic Magic Sets. The full encodings of the tested queries
are reported in Figs. A.1–A.2. Note that the encodings include the transformation described in Section 6, and that underlined
predicates denote source relations.

References

[1] Serge Abiteboul, Richard Hull, Victor Vianu, Foundations of Databases, Addison–Wesley, 1995.
[2] Krzysztof R. Apt, Howard A. Blair, Adrian Walker, Towards a Theory of Declarative Knowledge, in: Minker [52], pp. 89–148.
[3] Marcelo Arenas, Leopoldo Bertossi, Jan Chomicki, Scalar aggregation in fd-inconsistent databases, in: International Conference on Database Theory

(ICDT-2001), Springer-Verlag, 2001, pp. 39–53.

[4] Marcelo Arenas, Leopoldo E. Bertossi, Jan Chomicki, Consistent query answers in inconsistent databases, in: Proc. of the 18th ACM SIGACT SIGMOD

SIGART Symp. on Principles of Database Systems (PODS’99), 1999, pp. 68–79.

[5] Marcelo Arenas, Leopoldo E. Bertossi, Jan Chomicki, Specifying and querying database repairs using logic programs with exceptions, in: Proc. of the

4th Int. Conf. on Flexible Query Answering Systems (FQAS 2000), Springer, 2000, pp. 27–41.

[6] François Bancilhon, David Maier, Yehoshua Sagiv, Jeffrey D. Ullman, Magic sets and other strange ways to implement logic programs, in: Proc. Int.

Symposium on Principles of Database Systems, 1986, pp. 1–16.

[7] Pablo Barceló, Leopoldo Bertossi, Repairing databases with annotated predicate logic, in: Proc. the 10th Int. Workshop on Non-Monotonic Reasoning

(NMR 2002), 2002, pp. 160–170.

[8] Peter Baumgartner, Ulrich Furbach, Ilkka Niemelä, Hyper tableaux, in: Proceedings of the European Workshop on Logics in Artiﬁcial Intelligence

(JELIA’96), in: LNCS, vol. 1126, Springer, 1996, pp. 1–17.

[9] Catriel Beeri, Raghu Ramakrishnan, On the power of magic, Journal of Logic Programming 10 (1–4) (1991) 255–259.

[10] Andreas Behrend, Soft stratiﬁcation for magic set based query evaluation in deductive databases, in: PODS’03: Proceedings of the Twenty-Second ACM

SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, ACM, New York, NY, USA, 2003, pp. 102–110.

[11] Leo Bertossi, Jan Chomicki, Query answering in inconsistent databases, in: J. Chomicki, R. van der Meyden, G. Saake (Eds.), Logics for Emerging Appli-

cations of Databases, Springer-Verlag, 2003, pp. 43–83, Chapter 2.

[12] Leopoldo Bertossi, Jan Chomicki, Alvaro Cortes, Claudio Gutierrez, Consistent answers from integrated data sources, in: Proc. of the 6th Int. Conf. on

Flexible Query Answering Systems (FQAS 2002), 2002, pp. 71–85.

[13] Leopoldo E. Bertossi, Loreto Bravo, Consistent query answers in virtual data integration systems, in: Inconsistency Tolerance, in: LNCS, vol. 3300,

Springer, 2005, pp. 42–83.

[14] Loreto Bravo, Leopoldo Bertossi, Logic programming for consistently querying data integration systems, in: Proc. of the 18th Int. Joint Conf. on Artiﬁcial

Intelligence (IJCAI 2003), 2003, pp. 10–15.

[15] Marco Cadoli, Thomas Eiter, Georg Gottlob, Default logic as a query language, IEEE Transactions on Knowledge and Data Engineering 9 (3) (May/June

1997) 448–463.

[16] Andrea Calì, Domenico Lembo, Riccardo Rosati, Query rewriting and answering under constraints in data integration systems, in: Proc. of the 18th Int.

Joint Conf. on Artiﬁcial Intelligence (IJCAI 2003), 2003, pp. 16–21.

[17] Jan Chomicki, Jerzy Marcinkowski, Minimal-change integrity maintenance using tuple deletions, Information and Computation 197 (1–2) (2005) 90–

121.

[18] Jan Chomicki, Jerzy Marcinkowski, Slawomir Staworko, Computing consistent query answers using conﬂict hypergraphs, in: Proc. 13th ACM Conference

on Information and Knowledge Management (CIKM-2004), ACM Press, 2004, pp. 417–426.

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

191

[19] Jan Chomicki, Jerzy Marcinkowski, Slawomir Staworko, Hippo: A system for computing consistent answers to a class of SQL queries, in: Elisa Bertino,
Stavros Christodoulakis, Dimitris Plexousakis, Vassilis Christophides, Manolis Koubarakis, Klemens Böhm, Elena Ferrari (Eds.), 9th International Confer-
ence on Extending Database Technology (EDBT-2004), in: Lecture Notes in Computer Science, vol. 2992, Springer, 2004, pp. 841–844.

[20] Chiara Cumbo, Wolfgang Faber, Gianluigi Greco, Nicola Leone, Enhancing the magic-set method for disjunctive datalog programs, in: Proceedings of

the 20th International Conference on Logic Programming – ICLP’04, in: Lecture Notes in Computer Science, vol. 3132, 2004, pp. 371–385.

[21] Christian Drescher, Martin Gebser, Torsten Grote, Benjamin Kaufmann, Arne König, Max Ostrowski, Torsten Schaub, Conﬂict-driven disjunctive answer
set solving, in: Gerhard Brewka, Jérôme Lang (Eds.), Proceedings of the Eleventh International Conference on Principles of Knowledge Representation
and Reasoning (KR 2008), AAAI Press, Sydney, Australia, 2008, pp. 422–432.

[22] Thomas Eiter, Georg Gottlob, Heikki Mannila, Disjunctive Datalog, ACM Transactions on Database Systems 22 (3) (September 1997) 364–418.
[23] Wolfgang Faber, Enhancing eﬃciency and expressiveness in answer set programming systems, PhD thesis, Institut für Informationssysteme, Technische

Universität Wien, 2002.

[24] Wolfgang Faber, Gianluigi Greco, Nicola Leone, Magic sets and their application to data integration, Journal of Computer and System Sciences 73 (4)

(2007) 584–609.

[25] Ariel Fuxman, Elham Fazli, Renée J. Miller Conquer, Eﬃcient management of inconsistent databases, in: SIGMOD Conference, 2005.
[26] Ariel Fuxman, Renée J. Miller, First-order query rewriting for inconsistent databases, in: Thomas Eiter, Leonid Libkin (Eds.), Proceedings of the 10th

International Conference on Database Theory (ICDT 2005), in: LNCS, vol. 3363, Springer, 2005, pp. 337–351.

[27] Michael R. Garey, David S. Johnson, Computers and Intractability, A Guide to the Theory of NP-Completeness, W.H. Freeman and Company, 1979.
[28] Martin Gebser, Torsten Schaub, Sven Thiele, Gringo: A new grounder for answer set programming, in: Chitta Baral, Gerhard Brewka, John Schlipf
(Eds.), Logic Programming and Nonmonotonic Reasoning – 9th International Conference, LPNMR’07, in: Lecture Notes in Computer Science, vol. 4483,
Springer-Verlag, Tempe, Arizona, May 2007, pp. 266–271.

[29] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: Logic Programming: Proceedings Fifth Int. Conference and Symposium,

MIT Press, Cambridge, MA, 1988, pp. 1070–1080.

[30] R. Goldman, M. Boddy, Expressive planning and explicit knowledge, in: Proceedings AIPS-96, AAAI Press, 1996, pp. 110–117.
[31] Gianluigi Greco, Sergio Greco, Ester Zumpano, A logic programming approach to the integration, repairing and querying of inconsistent databases, in:

Proc. of the 17th Int. Conf. on Logic Programming (ICLP’01), in: Lecture Notes in Artiﬁcial Intelligence, vol. 2237, Springer, 2001, pp. 348–364.

[32] Sergio Greco, Optimization of Disjunction Queries, in: Danny De Schreye (Ed.), Proceedings of the 16th International Conference on Logic Programming

(ICLP’99), The MIT Press, Las Cruces, New Mexico, USA, November 1999, pp. 441–455.

[33] Sergio Greco, Binding propagation techniques for the optimization of bound disjunctive queries, IEEE Transactions on Knowledge and Data Engineer-

ing 15 (2) (March/April 2003) 368–385.

[34] Sergio Greco, Domenico Saccà, Carlo Zaniolo, The PushDown method to optimize chain logic programs, in: Proc. Int. Colloquim on Automata, Languages

and Programming, 1995, pp. 523–534 (extended abstract).

[35] Ashish Gupta, Inderpal Singh Mumick, Magic-sets transformation in nonrecursive systems, in: Proceedings of the Thirteenth ACM SIGACT SIGMOD-

SIGART Symposium on Principles of Database Systems (PODS-92), 1992, pp. 354–367.

[36] Ullrich Hustadt, Boris Motik, Ulrike Sattler, Reasoning in description logics by a reduction to disjunctive datalog, Journal of Automated Reasoning 39 (3)

(2007) 351–384.

[37] Tomi Janhunen, Ilkka Niemelä, Dietmar Seipel, Patrik Simons, Jia-Huai You, Unfolding partiality and disjunctions in stable model semantics, ACM

Transactions on Computational Logic 7 (1) (January 2006) 1–37.

[38] David B. Kemp, Divesh Srivastava, Peter J. Stuckey, Bottom–up evaluation and query optimization of well-founded models, Theoretical Computer Sci-

ence 146 (July 1995) 145–184.

[39] Jean-Marc Kerisit, Jean-Marc Pugin, Eﬃcient query answering on stratiﬁed databases, in: FGCS, 1988, pp. 719–726.
[40] Joohyung Lee, Vladimir Lifschitz, Loop formulas for disjunctive logic programs, in: Proceedings of the Nineteenth International Conference on Logic

Programming (ICLP-03), Springer-Verlag, December 2003.

[41] Maurizio Lenzerini, Data integration: A theoretical perspective, in: Proc. of the 21st ACM SIGACT SIGMOD SIGART Symp. on Principles of Database

Systems (PODS 2002), 2002, pp. 233–246.

[42] Nicola Leone, Georg Gottlob, Riccardo Rosati, Thomas Eiter, Wolfgang Faber, Michael Fink, Gianluigi Greco, Giovambattista Ianni, Edyta Kałka, Domenico
Lembo, Maurizio Lenzerini, Vincenzino Lio, Bartosz Nowicki, Marco Ruzzi, Witold Staniszkis, Giorgio Terracina, The INFOMIX system for advanced
integration of incomplete and inconsistent data, in: Proceedings of the 24th ACM SIGMOD International Conference on Management of Data (SIGMOD
2005), ACM Press, Baltimore, Maryland, USA, June 2005, pp. 915–917.

[43] Nicola Leone, Gerald Pfeifer, Wolfgang Faber, Thomas Eiter, Georg Gottlob, Simona Perri, Francesco Scarcello, The DLV system for knowledge represen-

tation and reasoning, ACM Transactions on Computational Logic 7 (3) (July 2006) 499–562.

[44] Nicola Leone, Pasquale Rullo, Francesco Scarcello, Disjunctive stable models: Unfounded sets, ﬁxpoint semantics and computation, Information and

Computation 135 (2) (June 1997) 69–112.

[45] Senlin Liang, Paul Fodor, Hui Wan, Michael Kifer, OpenRuleBench: An analysis of the performance of rule engines, in: Juan Quemada, Gonzalo León,
Yoëlle S. Maarek, Wolfgang Nejdl (Eds.), Proceedings of the 18th International Conference on World Wide Web (WWW 2009), ACM, 2009, pp. 601–610.
[46] Yuliya Lierler, Disjunctive answer set programming via satisﬁability, in: Chitta Baral, Gianluigi Greco, Nicola Leone, Giorgio Terracina (Eds.), Logic
Programming and Nonmonotonic Reasoning – 8th International Conference, LPNMR’05, Diamante, Italy, September 2005, Proceedings, in: Lecture
Notes in Computer Science, vol. 3662, Springer-Verlag, September 2005, pp. 447–451.

[47] Fangzhen Lin, Yuting Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, in: Proceedings of the Eighteenth National Conference

on Artiﬁcial Intelligence (AAAI-2002), AAAI Press/MIT Press, Edmonton, Alberta, Canada, 2002.

[48] Jorge Lobo, Jack Minker, Arcot Rajasekar, Foundations of Disjunctive Logic Programming, The MIT Press, Cambridge, MA, 1992.
[49] Marco Manna, Massimo Ruffolo, Ermelinda Oro, Mario Alviano, Nicola Leone, The HiLeX system for semantic information extraction, in: Transactions on

Large-Scale Data- and Knowledge-Centered Systems, in: Lecture Notes in Computer Science, vol. 7100, Springer, Berlin/Heidelberg, 2012, pp. 91–125.

[50] Marco Manna, Francesco Scarcello, Nicola Leone, On the complexity of regular-grammars with integer attributes, Journal of Computer and System

Sciences (JCSS) 77 (2) (2011) 393–421.

[51] Mónica Caniupán Marileo, Leopoldo E. Bertossi, The consistency extractor system: Querying inconsistent databases using answer set programs, in: SUM

2007, 2007, pp. 74–88.

[52] Jack Minker (Ed.), Foundations of Deductive Databases and Logic Programming, Morgan Kaufmann Publishers, Inc., Washington DC, 1988.
[53] Boris Motik, Reasoning in description logics using resolution and deductive databases, PhD thesis, Fakultät für Wirtschaftswissenschaften, Universität

Fridericiana zu Karlsruhe, 2006.

[54] Boris Motik, Ulrike Sattler, A comparison of reasoning techniques for querying large description logic aboxes, in: Miki Hermann, Andrei Voronkov
(Eds.), Logic for Programming, Artiﬁcial Intelligence, and Reasoning, 13th International Conference (LPAR 2006), in: Lecture Notes in Computer Science,
vol. 4246, Springer, 2006, pp. 227–241.

[55] Inderpal Singh Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, Raghu Ramakrishnan, Magic is relevant, in: Proceedings of the 1990 ACM SIGMOD

International Conference on Management of Data, 1990, pp. 247–258.

192

M. Alviano et al. / Artiﬁcial Intelligence 187–188 (2012) 156–192

[56] Raghu Ramakrishnan, Yehoshua Sagiv, Jeffrey D. Ullman, Moshe Y. Vardi, Logical query optimization by proof-tree transformation, Journal of Computer

and System Sciences 47 (1) (1993) 222–248.

[57] Francesco Ricca, Mario Alviano, Antonella Dimasi, Giovanni Grasso, Salvatore Maria Ielpa, Salvatore Iiritano, Marco Manna, Nicola Leone, A logic-based

system for e-tourism, Fundamenta Informaticae 105 (1–2) (2010) 35–55.

[58] Francesco Ricca, Giovanni Grasso, Mario Alviano, Marco Manna, Vincenzino Lio, Salvatore Iiritano, Nicola Leone, Team-building with answer set pro-
gramming in the Gioia–Tauro seaport, Theory and Practice of Logic Programming (2012), http://dx.doi.org/10.1017/S147106841100007X, in press.

[59] K.A. Ross, Modular stratiﬁcation and magic sets for datalog programs with negation, Journal of the ACM 41 (6) (1994) 1216–1266.
[60] Praveen Seshadri, Joseph M. Hellerstein, Hamid Pirahesh, T.Y. Cliff Leung, Raghu Ramakrishnan, Divesh Srivastava, Peter J. Stuckey, S. Sudarshan, Cost-
based optimization for magic: Algebra and implementation, in: H.V. Jagadish, Inderpal Singh Mumick (Eds.), Proceedings of the 1996 ACM SIGMOD
International Conference on Management of Data, ACM Press, June 1996, pp. 435–446.

[61] Patrik Simons, Ilkka Niemelä, Timo Soininen, Extending and implementing the stable model semantics, Artiﬁcial Intelligence 138 (June 2002) 181–234.
[62] Peter J. Stuckey, S. Sudarshan, Compiling query constraints, in: Proceedings of the Thirteenth Symposium on Principles of Database Systems (PODS’94),

ACM Press, May 1994, pp. 56–67.

[63] Jeffrey D. Ullman, Principles of Database and Knowledge-Base Systems, vol. II, Computer Science Press, 1989.
[64] A. van Gelder, Negation as failure using tight derivations for general logic programs, in: Minker [52], pp. 1149–1176.

