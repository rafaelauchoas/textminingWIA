Artificial Intelligence 175 (2011) 890–913Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintLoop-separable programs and their first-order definabilityYin Chen a,∗, Fangzhen Lin b, Yan Zhang c, Yi Zhou ca Department of Computer Science, South China Normal University, Guangzhou, Guangdong, Chinab Department of Computer Science, Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kongc Intelligent Systems Lab, School of Computing and Mathematics, University of Western Sydney, Penrith South DC, NSW 1797, Australiaa r t i c l ei n f oa b s t r a c tAn answer set program with variables is first-order definable on finite structures if the setof its finite answer sets can be captured by a first-order sentence. Characterizing classesof programs that are first-order definable on finite structures is theoretically challengingand of practical relevance to answer set programming. In this paper, we identify a non-trivial class of answer set programs called loop-separable programs and show that they arefirst-order definable on finite structures.© 2010 Elsevier B.V. All rights reserved.Article history:Received 23 December 2009Received in revised form 18 December 2010Accepted 18 December 2010Available online 22 December 2010Keywords:Answer set programmingFirst-order definabilityKnowledge representationNonmonotonic reasoning1. IntroductionThis work is about answer set programming (ASP), a constraint-based programming paradigm that has been foundapplications in a wide range of areas including bioinformatics [9,12,29] and the semantic web [11,27]. Currently in ASPapplications, a program normally has two parts: a finite set of rules with variables, and a finite set of ground facts. Theformer represents general domain knowledge and the latter the specific instance of the problem that one wants to solve.Since current ASP solvers can only deal with rules without variables [14,20,22,28], the latter is used to ground the formerinto a set of propositional rules, and together they are given to an ASP solver.Recently there has been work on extending answer set semantics to programs with variables [4,13,23,25], and to considerthe possibility of constructing an ASP solver that can deal with rules with variables [4]. Against this backdrop, in this paperwe consider the problem of first-order definability of answer set programs with variables. This is a problem because ingeneral, the answer sets of a program with variables correspond to a second-order sentence [13,23] or an infinite set offirst-order sentences [4].The study on non-grounding based method for computing answer sets/stable models has been carried out by someresearchers [10,16]. The motivation of developing this approach is to avoid large sets of facts after grounding a programcontaining variables. By introducing concepts such as constrained non-ground stables [10] and covers/anticovers [16], usingthis approach we can derive some kind of compact representations of the stable models of the original program, so thatstable models may be partially pre-computed at compile-time.Although both the approach mentioned above and the first-order definability of logic programs address non-groundinglogic programs, the foundation of these two topics are actually quite different. In this paper, our study will be based on thefirst-order stable model semantics and identify a class of programs that is first-order definable on finite structures, whilethe non-ground approach only provided an alternative method to compute stable models of a propositional logic program.* Corresponding author.E-mail addresses: ychen@scnu.edu.cn (Y. Chen), flin@cse.ust.hk (F. Lin), yan@scm.uws.edu.au (Y. Zhang), yzhou@scm.uws.edu.au (Y. Zhou).0004-3702/$ – see front matter © 2010 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2010.12.001Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913891While our work presented in this paper is the first in-deep study on the first-order definability of answer set programswith variables, we should mention that the related problem has been addressed in propositional case. In particular, Dungand Kanchanasut have shown that every propositional logic program Π can be transformed into a propositional theory T Πsuch that the set of stable models of Π is exactly the set of models of T Π [8]. More recently, Lin and Zhao proved a similarresult by using loop-formulas [22].Studying the first-order definability of answer set programs has both theoretical and practical values. Firstly, since thesemantics of first-order answer set programs is defined based on second-order logic, it becomes an immediate issue tounderstand the expressive power of first-order answer set programs. Results of the first-order definability will providepartial answers to this issue and help us to achieve a better understanding on the difference between first-order answer setprograms and classical first-order logic. Results in this aspect will provide an important theoretical foundation for first-orderanswer set programming.Secondly, as evident from the work in Datalog and finite model theory, proving first-order definability results are usuallyhighly challenging. Very often, new proof techniques have to be developed, which may also be useful for other problemsolving. For instance, as it will be shown in this paper, in order to prove our first-order definability result, we extend theexpansion tree concept in Datalog [3] to ASP and apply it to loop-separable programs. We believe that both the notion ofloop-separable programs and the new expansion tree concept proposed in this paper may be useful for other related studiesin first-order answer set programming.Finally, knowing that a program is first-order definable is certainly helpful if one wants to construct an ASP solver forfirst-order answer set programs. It initiates the possibility of exploiting first-order inference tools, e.g. model generators andtheorem provers, to reason on programs that are first-order reducible. Also, it can be helpful for SAT-based propositionalASP solvers. This is because current SAT-based ASP solvers compute loop formulas incrementally as needed. If we know thatthe given program can be captured by a first-order sentence, then it may be more effective to bypass loop formulas andjust instantiate the first-order sentence on a given instance directly.In this paper, we show that if a program is so-called loop-separable, then it is first-order definable on finite structures.Furthermore, it is decidable whether a program is loop-separable. As we shall see, the notion of loop-separable programsdepends on a careful study of how rules interacts with first-order loops introduced in [4]. It also includes all first-orderdefinable classes of programs that we knew of, like the class of program with finite set of complete loops.The rest of the paper is organized as follows. Section 2 presents basic logic concepts and notions which will be usedin our following study. Section 3 introduces the notion of first-order definability, and Section 4 defines a class of programscalled loop-separable program. Section 5 contains the detailed proof that loop-separable programs are first-order definable.Section 6 considers some special subclasses of loop-separable programs and discusses some related work. Finally, Section 7concludes this paper with some discussions.2. First-order answer set programs with extensional databases2.1. PreliminariesWe consider a second-order language with equality but without function symbols. A vocabulary consists of a finite setof constant symbols and a finite non-empty set of relation symbols including equality =. Given a vocabulary τ , we denote byC(τ ) the sets of constant symbols in τ , and by P(τ ) the set of relation symbols. The notions of term, atom, (first-order orsecond-order) formula and (first-order or second-order) sentence are defined as usual. An atom is called an equality atomif it is an atom of the form t1 = t2, and a proper atom otherwise. We use Var(O) to denote the set of variables occurringin O, which can be a term, atom, formula, sentence or other expressions. Given a vocabulary τ , the unique name assumption(or UNA for short) on τ , denoted by Σuna(τ ) (or Σuna when τ is obvious from the context), is the conjunction of ci (cid:3)= c j forany two different constant ci, c j in C(τ ).¬∀x(Q (x) ⊃ P (x)). For the given tuples of relation symbols P = (P 1, . . . , P k) and P (cid:7) = (P(1 (cid:2) i (cid:2) k) have the same arity, we use P < P (cid:7)Let P and Q be two relation symbols or variables of the same arity. P < Q stands for the formula ∀x(P (x) ⊃ Q (x)) ∧(cid:7)(cid:7)(cid:7)1, . . . , Pk), where all P i and P(cid:2)iki=1(cid:2)ki=1AAAn ), where A is a finite set called the domain of A,A finite structure A of vocabulary τ is a tuple ( A, cm , R1 , . . . , cAA(the interpretation of a k-ary relation symbol R i ) (1 (cid:2) i (cid:2) n),∈ A (the interpretation of constant ci ) (1 (cid:2) i (cid:2) m), and Rciia k-ary relation on A. In the following, we use Dom(A) to denote the domain of structure A. Unless stated otherwise, thedomains of all structures are assumed to be finite in this paper.(cid:7)i(x) ⊃ P i(x)).to denote the formulaGiven two tuples s = (s1, . . . , sn) and ¯t = (t1, . . . , tn) of the same length, we use s = ¯t to denote the formulai=1 si = ti ,and s (cid:3)= ¯t the formula ¬(s = ¯t). A binding is an expression of the form x/t, where x is a variable, and t a term, and asubstitution is a set of bindings containing at most one binding for each variable. If ϕ is a first-order formula (term, tuple ofterms, etc.), and θ a substitution, we denote by ϕθ the result of replacing every free variable in ϕ according to θ .∀x(P i(x) ⊃ P(cid:7)i(x)) ∧ ¬A1 , . . . , R∀x(PGiven a set of variables or relation variables V and a structure A, an assignment σ on V over A is function that assignseach variable in V to a domain element in Dom(A) and each n-ary relation variable in V to an n-ary relation on Dom(A).We write (A, σ ) |(cid:9) ϕ(x) to mean that ϕ is true in A under the assignment σ .(cid:2)n892Y. Chen et al. / Artificial Intelligence 175 (2011) 890–9132.2. Syntax and semanticsWe introduce the syntax and semantics of first-order answer set programs with extensional databases in this section.A rule is of the form:a ← b1, . . . , bk, not c1, . . . , not cl,(1)where a is either a proper atom or ⊥, and b1, . . . , bk, c1, . . . , cl (k, l (cid:3) 0) are atoms. A rule is called a constraint if a is ⊥.Given a rule r of form (1), we call a the head of r, denoted by Head(r), {b1, . . . , bk, not c1, . . . , not cl} the body of r, denotedby Body(r), {b1, . . . , bk} the positive body of r, and {not c1, . . . , not cl} the negative body of r. We also use Pos(r) and Neg(r) todenote the set of atoms {b1, . . . , bk} and the set of atoms {c1, . . . , cl}. A variable x in a rule r is called a local variable if itoccurs in the body of r but not in the head of r.A first-order answer set program with extensional database (or simply called program) is a finite set of rules. Given a pro-gram Π , we use τ (Π) to denote the vocabulary containing all the relation symbols and constants in Π . A relation symbolP in τ (Π) is called intensional predicate if it occurs in the head of some rules of Π , and extensional predicates otherwise. Weuse τext(Π) to denote the vocabulary containing all extensional predicates and constants in Π , and τint(Π) the vocabularycontaining all intensional predicates in Π . We also use P(Π), Pint(Π) and Pext(Π) to denote the sets (tuples, if it is clearfrom the context) of all predicates, intensional predicates and extensional predicates in Π respectively. A proper atom P (¯t)is extensional (intensional) if P is extensional (intensional).Now we present the semantics of first-order answer set programs with extensional databases. For each rule r of form (1),⊃ a), where y is the tuple of all local variables of r and x the rest of variables(cid:2)Bodyrwe use (cid:3)r to denote the sentence ∀x(∃ yin r, and(cid:2)Bodyr the formula b1 ∧ · · · ∧ bk ∧ ¬c1 ∧ · · · ∧ ¬cl. By (cid:3)Π , we denote the sentence(cid:7)1, . . . , PLet P = (P 1, . . . , P k) and P (cid:7) = (P(cid:7)i (1 (cid:2)i (cid:2) k) are of the same arity. Given a rule r of form (1), by (cid:3)r [+P/P (cid:7)], we mean the formula that is obtained from (cid:3)r byreplacing each relation symbol in P occurring in the head and positive body of r by the corresponding relation symbol in(cid:3)r [+P/P (cid:7)]. For instance, if r is the rule P (x) ← R(x), not Q (x), thenP (cid:7)(cid:7)(x)). Note that here we do not replace the relation symbol Q in(cid:3)r [+{P , Q }/{Pthe negative body of r.(cid:7)k) be two tuples of relation symbols or relation variables where P i and P. We also use (cid:3)Π[+P/P (cid:7)] to denote the formula(cid:7)}] is the sentence ∀x(R(x) ∧ ¬Q (x) ⊃ P(cid:7), Qr∈Π(cid:2)(cid:2)(cid:3)r.r∈ΠDefinition 1 (Answer set). Let Π be a program. A structure A of τ (Π) is an answer set of Π if and only if A is a model of(cid:4)(cid:3)Π ∧ ¬∃P ∗P ∗< Pint(Π) ∧ (cid:3)Π(cid:5)+Pint(Π)/P ∗(cid:6)(cid:7).(2)Example 1. We consider a program Π1 consisting of the following rules:T (x, y) ← E(x, y), not E(x, x), not E( y, y),T (x, z) ← T (x, y), T ( y, z),A = {(a, a), (a, b), (b, c),where Pext(Π1) = {E} and Pint(Π1) = {T }. Let A = ( A, EA = {(b, c), (c, d), (b, d)}. According to Definition 1, A is an answer set of Π . If we view E as a graph, then T(c, d)} and Tcomputed by program Π1 is the transitive closure of the induced subgraph of E on the set of nodes that do not have anedge going into themselves.A) be a structure of τ (Π), where EA, TNote that in Definition 1, minimization only applies on intensional predicates while extensional predicates are viewedas the initial input of the program. This is different from the previous first-order answer set semantics such as Ferraris etal. [13] and Lin and Zhou’s semantics [23]. There are both theoretical and practical advantages by separating a programvocabulary into intensional and extensional. Firstly, by separating intensional and extensional predicates in a program, theprogram itself may be viewed as a generic description of certain system or agent’s behaviors, while the extensional pred-icates just provide various instantiations of the system or agent’s initial inputs. Consequently, the class of programs thatcontain the same rules but with different extensional predicate inputs share many essential properties so that our studyon these properties such as first-order definability and complexity may be simplified. Secondly, from a practical viewpoint,such separation will also simplify the underlying implementation for problem solving in various domains. This is the currentpractice in ASP anyway. For instance, we can easily write a generic program of computing Hamiltonian cycles for any finitegraph without considering specific input graph – which will be represented by extensional predicate values.In fact, the semantics presented above is nothing new by a simplification of the answer set (stable model) semanticsrecently presented by Ferraris et al. [13] and by Lin and Zhou [23]. The main differences are twofold. First, we distinguishbetween extensional and intensional predicates as discussed above. Second, here we only consider normal logic programswith constraints (i.e. programs without functions, disjunctions and nested expressions) rather than an arbitrary first-ordersentence. Also, this definition goes back to the early work of Lin [21] by relating normal logic program under the stablemodel semantics and circumscription. As we will show next, under the context of finite structures, it is the same as thestandard Gelfond–Lifschitz transformation semantics when the program is “grounded” on finite domains.Y. Chen et al. / Artificial Intelligence 175 (2011) 890–9138932.3. Relation to other answer set semanticsGiven a program Π and a structure A of τext(Π), we shall define the instantiation of Π on A as a propositional programover the following propositional language LA:LA =(cid:8)P (a)(cid:9)(cid:9) P ∈ Pint(Π) and a ∈ Dom(A)n(cid:10).We begin with one more notation. Let α be an atom and σ an assignment over A. We denote by α[σ ] the result ofreplacing every constant c in α by domain element cand every variable x in α by σ (x).ALet r ∈ Π be a rule of form (1). We define the instantiation of r on A, written rA, to be the set of propositional rulesobtained fromR =(cid:8)a[σ ] ← b1[σ ], . . . , bk[σ ], not c1[σ ], . . . , not cl[σ ](cid:9)(cid:10)(cid:9) σ is an assignment on Var(r) over Aby the following transformations:• if the body of a rule in R contains either a = b for some distinct elements a, b ∈ Dom(A) or not a = a for some element• if the body of a rule in R contains either P (a) for extensional predicate P and a /∈ PAor not P (a) for extensionala ∈ Dom(A), then delete this rule;predicate P and a ∈ PA, then delete this rule;• delete a = a and not a = b for all elements a, b ∈ Dom(A) in the bodies of the remaining rules;• delete P (a) and not P (a) in the bodies of the remaining rules, where P is an extensional predicate.The instantiation of a program Π on A, written ΠA, is then the union of the instantiations of all the rules in Π on A.We also recall some definitions of answer set semantics for propositional program from [15]. Given a propositionallanguage L, a propositional program π is a finite set of propositional rules of the form:pa ← pb1, . . . , pbk, not pc1, . . . , not pcl,(3)where pa is either ⊥ or a propositional atom in L, and pb1, . . . , pbk, pc1, . . . , pcl (k, l (cid:3) 0) are propositional atoms. A propo-sitional program π is called positive if l = 0 for all rules of form (3) in π . Given a set of propositional atoms M ⊆ L and apropositional program π , we use GLM (π ) to denote the propositional program obtained from π by the following transfor-mations:• if a rule of form (3) is in π and pci ∈ M for some i, 1 (cid:2) i (cid:2) l, then delete this rule;• delete not pci , 1 (cid:2) i (cid:2) l, in the bodies of the remaining rules.A set of propositional atoms M ⊆ L is an answer set of a propositional program π if it is the minimal set of propositionalatoms that satisfies every rule in GLM (π ), where M satisfies a rule of form (3) if• either pa is ⊥, and {pb1, . . . , pbk} (cid:3) M or {pc1, . . . , pcl} ∩ M (cid:3)= ∅,• or pa is a propositional atom, and pa ∈ M whenever {pb1, . . . , pbk} ⊆ M and {pc1, . . . , pcl} ∩ M = ∅.Proposition 1. Given a program Π and a finite structure A of τext(Π), let A(cid:7)A(cid:7) = cconly if MA(cid:7) is an answer set of ΠA, where MA(cid:7) = {P (a) | P ∈ Pint(Π) and a ∈ Pfor every constant c, and a ∈ Pif and only if a ∈ PA(cid:7)AAA(cid:7) }.for every extensional predicate P . A(cid:7)be a structure of τ (Π) such that Dom(A(cid:7)) = Dom(A),is an answer set of Π if andProof. Assume that Pint(Π) = {P 1, . . . , Pn}, and let P ∗ = {P(1 (cid:2) i (cid:2) n) are of the same arity.∗1, . . . , P∗n} be a set of relation variables such that P i and P∗i“⇒”: A(cid:7)is an answer set of Π . By Definition 1, A(cid:7)is a model of (2), so it is a model of (cid:3)Π . By the definition of ΠA andMA(cid:7) , we can see that MA(cid:7) satisfies every rules in ΠA and GLMA(cid:7) (ΠA). We will show that MA(cid:7) is the minimal set whichsatisfies every rules in GLMA(cid:7) (ΠA).Otherwise, there is a set M(cid:7)(cid:7) ⊂ MA(cid:7) which also satisfies every rules in GLMA(cid:7) (ΠA). We can see that M(cid:7)(cid:7)∗i ) if and only if P i(a) ∈ M(cid:7)(cid:7)also satisfies, for every intensionalevery rules in Π(A). Let σ be an assignment on P ∗such that a ∈ σ (Ppredicate P i (1 (cid:2) i (cid:2) n). We will show that (A(cid:7), σ ) |(cid:9) (cid:3)Π [+Pint(Π)/P ∗].Let r ∈ Π be a rule of form (1), and σ (cid:7)(cid:5)σ (cid:7)(cid:6), . . . , bk← b1(cid:6), not c1(cid:5)σ (cid:7)(cid:5)σ (cid:7)(cid:7) : a(cid:6)r(cid:5)σ (cid:7)(cid:6), . . . , not cl(cid:5)σ (cid:7)(cid:6),an assignment on Var(r). Consider the propositional rulewe can see that either• there is a = b for some distinct elements a, b ∈ Dom(A) or not a = a for some element a ∈ Dom(A) in ror not P (a) for extensional predicate P and a ∈ P• there is P (a) for extensional predicate P and a /∈ PA(cid:7), orA,894or(cid:7)(cid:7)• Msatisfies propositional rule rthe body of r.(cid:7)Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913(cid:7)(cid:7), where r(cid:7)(cid:7)is obtained by removing all the equality atoms and extensional atoms inBy considering both cases, we have (A(cid:7), σ ) |(cid:9)(cid:3)r [+Pint(Π)/P ∗], and then (A(cid:7), σ ) |(cid:9) (cid:3)Π [+Pint(Π)/P ∗]. So, we have (A(cid:7), σ ) |(cid:9)(P ∗ < Pint(Π)) ∧(cid:3)r [+Pint(Π)/P ∗] by noticing that Mis a model of (2).is a model of (cid:3)Π . It is sufficient“⇐”: MA(cid:7) is an answer set of ΠA. By the definitions of ΠA and MA(cid:7) , we can see that A(cid:7)(cid:7)(cid:7) ⊂ MA(cid:7) , which is a contradiction to the fact that A(cid:7)to show that there does not exist an assignment σ on P ∗such that (A(cid:7), σ ) |(cid:9) (P ∗ < Pint(Π)) ∧(cid:3)r [+Pint(Π)/P ∗].Otherwise, let σ be an assignment on P ∗(cid:7)(cid:7)if and only if a ∈ σ (PLA such that P i(a) ∈ Msatisfies every rules in ΠA.such that (A(cid:7), σ ) |(cid:9) (P ∗ < Pint(Π)) ∧(cid:3)r [+Pint(Π)/P ∗]. Let Mbe a subset of∗(cid:7)(cid:7)i ), for every intensional predicate P i (1 (cid:2) i (cid:2) n). We will show next that M(cid:7)(cid:7)Let r(cid:7)(cid:7) ∈ ΠA be a propositional rule obtained from the propositional rule(cid:5)(cid:6)(cid:7) : a(cid:5)(cid:5)σ (cid:7)σ (cid:7)where there is a rule r of form (1) in Π , and σ (cid:7)(cid:6), . . . , bk(cid:6), not c1← b1(cid:5)σ (cid:7)σ (cid:7)r(cid:6), . . . , not cl(cid:5)σ (cid:7)(cid:6),is an assignment on Var(r). By the definition of ΠA,• each equality atom in the body of r• if P (a) ∈ Pos(r• if P (a) ∈ Neg(rA(cid:7)), then a ∈ P(cid:7)), then a /∈ PA, for extensional predicate P ,, for extensional predicate P .(cid:7)is of the form a = a or not a = b, where a and b are distinct elements in Dom(A),We already have (A(cid:7), σ ) |(cid:9)(cid:3)r [+Pint(Π)/P ∗]. So, by the definition of Mby (A(cid:7), σ ) |(cid:9) P ∗ < Pint(Π), we can see that MMA(cid:7) satisfies every rules in ΠA. This is a contradiction to the fact that MA(cid:7) an answer set of ΠA. (cid:2). Furthermore,also satisfies every rules in GLMA(cid:7) (ΠA) by noticing that(cid:7)(cid:7) ⊂ MA(cid:7) , and M, we can see that Msatisfies rule r(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)Proposition 1 indicates that Definition 1 coincides with the standard Gelfond–Lifschitz semantics but lifted to an arbitraryfinite structures rather than only considering the Herbrand structure [15]. As a consequence, Definition 1 also coincides withFerraris et al.’s recent semantics [13] restricted to normal logic programs with constraints on finite structures.Corollary 2. Let Π be a program such that all predicates in Π are intensional. A structure A is a stable model of (cid:3)Π under Ferrariset al.’s definition [13] iff it is an answer set of Π under Definition 1.Another issue is that we distinguish between intensional predicates and extensional predicates in this paper. In fact,the main purpose is conceptual but not technical. Also followed from Proposition 1, the following two properties showthat programs with and without extensional predicates can be simply transformed from one another. More precisely, fromprograms without extensional predicates to those with, one can add “identity rules” of the formP (x) ← P (x)for every predicate P in Π . For the other way around, one can add “choice rules” of the form(cid:7)(x) ← not P (x),PP (x) ← not P(cid:7)(x)for every extensional predicate P , where P(cid:7)is a new predicate that has the same arity as P .Corollary 3. Let Π be a program. A structure A is a stable model of (cid:3)Π under Ferraris et al.’s definition [13] iff it is an answer set ofΠ ∪ ID(Π) under Definition 1, where ID(Π) is the set of all identity rules for all predicates in Π .Corollary 4. Let Π be a program. A structure A is an answer set of Π under Definition 1 iff A(cid:7)under Ferraris et al.’s definition [13], where A(cid:7)P ∈τ (Π)is the set of all choice rules for all extensional predicates in Π .is the conservative extension of A under(cid:2)is a stable model of (cid:3)Π ∧ (cid:4)∀x(P (x) ↔ ¬PChoice(Π)(cid:7)(x)), and Choice(Π)Recently, Pelov, Denecker and Bruynooghe also introduced an alternative first-order extension of logic programs withaggregates under stable semantics [26]. In their formalism, a program is a (possibly infinite) set of aggregate rules of theform A ← ϕ, where A is an atom and ϕ is a first-order formula potentially including aggregate expressions. By defininga three-value immediate consequence operator of an aggregate program, they defined the extended stable semantics forsuch aggregate programs. Nevertheless, by ignoring the issue of aggregates, it is not difficult to observe that their fixpointbased extended stable semantics actually coincides with Gelfond–Lifschitz’s original stable model semantics on groundedprograms [15].(cid:11)1(cid:2)i(cid:2)kwherexθ = ¯t);Y. Chen et al. / Artificial Intelligence 175 (2011) 890–9138952.4. Loops and loop formulasFor finite domains, the answer set semantics of a first-order logic program can also be captured by loop formulas [4]. Inthe following, we review some results about loops and loop formulas as they will be used in defining a class of first-orderdefinable programs.1Given a program Π , the positive dependency graph of Π , denoted by GΠ , is the infinite graph (V , E), where V is the setof atoms of τint(Π), and (α, β) is an edge in E if there is a rule r ∈ Π and a substitution θ , such that α = Head(rθ) andβ ∈ Pos(rθ). A finite non-empty subset L of V is said to be a loop of Π if there exists a cycle in GΠ that goes through onlyand all the nodes in L. In particular, for each atom α ∈ V , we treat {α} as a special loop, in which there is a singleton. A ruler is said to be involved in a loop if there is a loop L and two atoms α and β in L such that α = Head(r) and β ∈ Pos(r).Let r be a rule of form (1), and suppose that a is P (t1, . . . , tn) for some predicate P and tuple (t1, . . . , tn) of terms. Ifx = (x1, . . . , xn) is a tuple of variables not in r, then the normal form of r on x is the following rule:P (x1, . . . , xn) ← x1 = t1, . . . , xn = tn, b1, . . . , bk, not c1, . . . , not cl.Given a loop L of a program Π and an atom P (¯t) in L, the external support formula of P (¯t) for Π with respect to L, denotedby ES(P (¯t), L, Π), is the following formula:(cid:12)∃ yi(cid:4)Bodyri θ∧(cid:13)Q (¯t(cid:7))∈L, Q (¯t)∈Pos(ri θ )(cid:14)¯t (cid:3)= ¯t(cid:7),(4)• r1, . . . , rk are the normal forms on x of rules in Π whose head mention the predicate P ;• x is a tuple of variables that are not in Π , and if ¯t = (t1, . . . , tn) and x = (x1, . . . , xn), then θ = {x1/t1, . . . , xn/tn} (so that• yi (1 (cid:2) i (cid:2) k) is the tuple of local variables of ri .The loop formula of L in Π , denoted by LF(L, Π), is the universal closure of(cid:11)(cid:11)α ⊃ES(α, L, Π).(5)α∈Lα∈LWe use LF(Π) to denote the set of all loop formulas in Π .Theorem 1. (See [4].) Let Π be a program2 and A a finite structure of τ (Π), where A is a model of Σuna. A is an answer set of Π ifand only if A is a model of { (cid:3)Π} ∪ LF(Π).In general case, a program may have infinite many loops, and thus LF(Π) is an infinite set of sentences (see programsΠ4 and Π5 illustrated in next section). However, there are programs whose loop formulas can be captured by a finite set offormulas.A complete set of loops S of a program Π is a set of loops such that for every loop L of Π , there is a loop L(cid:2)(cid:7) ∈ S and a(cid:7)θ . If a program Π has a finite complete set of loops S, then a finite structure A is an answersubstitution θ such that L = Lset of Π if and only if A is a model of the sentence (cid:3)Π ∧L∈S LF(L, Π).Example 2. Consider the following program Π2:r1:P (x) ← Q (x), R1(x),r2: Q (x) ← P (x), R2(x),r3:P (x) ← R3(x),r4: Q (x) ← R4(x).(cid:4)One of the complete set of loops of Π2 is {{P ( y)}, {Q ( y)}, {P ( y), Q ( y)}}, and thus a structure A is an answer set of Π2 ifand only if it is a model of the conjunction of (cid:15)Π2 and the following loop formulas:(cid:7)∨ R3( y)(cid:7)∨ R4( y)(cid:7)⊃ R3( y) ∨ R4( y)P ( y) ⊃Q ( y) ⊃(cid:4)(cid:4)(cid:7)P ( y) ∨ Q ( y)(cid:7)Q ( y) ∧ R1( y)(cid:7)(cid:4)P ( y) ∧ R2( y)∀ y∀ y∀ y(cid:4)(cid:4),,.1 Some notions are a little bit different from [4] to fit our context.2 The theorem in [4] consider only programs without constraint, while it is straightforward to extend it to arbitrary programs.896Y. Chen et al. / Artificial Intelligence 175 (2011) 890–9133. First-order definable programsNow we present a formal definition of first-order definability for answer set programs.Definition 2. A program Π is called first-order definable on finite structures (under answer set semantics) if there is a first-order sentence ψ on vocabulary τ (Π) such that for every finite structure A of τ (Π), A is a model of ψ if and only if A isan answer set of Π . In this case, we say that Π is defined by ψ .This notion of first-order definability for answer set programs is closely related to the well-studied definability problemof datalog queries in deductive database [1,6]. A datalog rule is a rule without negation, and a datalog program is a finiteset of datalog rules, i.e., a program without negation. For any datalog program Π , it can be shown that given any database(structure) of extensional predicates, there is a unique answer set of Π based on the database. This unique answer set iswhat is computed by the datalog program from the given database of the extensional predicates.A datalog query (Q , Π) ( Q ∈ Pint(Π)) represents the intended value of Q on a given extensional database A of Π ,denoted as Q (A). (Q , Π) is explicitly first-order definable if and only if there exists a first-order formula φ(x) on τext(Π)such that for every extensional database A of Π , Q (A) is the same as the relation represented by φ(x) under A. (Q , Π)is implicitly first-order definable if there is a first-order sentence φ on τext(Π) ∪ {Q } such that for every extensional databaseA of Π and a relation R on A, φ is satisfied in the extension of A with R if and only if R = Q (A) [17]. It has been shownthat explicit definability implies implicit definability, but the converse is not true in general on finite structures [1].Our definition of first-order definability is similar to implicit first-order definability in Datalog. One main difference isthat the first-order definability issue considered in ASP is about a program but not a query. Another difference is that inour definition we require a first-order sentence to capture all answer sets and thus all intensional predicates, not just thesingle intensional predicate mentioned in the query.Example 3. Consider the following program Π3:P (x) ← Q (x), not R1(x),Q (x) ← R2(x).Π3 has two intensional predicates: P and Q . According to Definition 2, Π3 can be defined by the sentence(cid:4)∀xP (x) ≡(cid:4)Q (x) ∧ ¬R1(x)(cid:7)(cid:7)(cid:4)∧ ∀x(cid:7)Q (x) ≡ R2(x).From our remarks at the end of last section, we see that if a program has a finite complete set of loops, then it isfirst-order definable. However, the converse is not true in general. As the following examples show.Example 4. Consider the program Π4:r1:r2:P (x) ← R(x),P (x) ← P ( y), S(x, u), not T ( y, v).(6)(7)For this program, P is the only intensional predicate. Clearly, Π4 does not have a finite complete set of loops: for eachn > 0, {P (x1), . . . , P (xn)} is a loop.Now consider how P (x1) can be derived. There are two rules for it:P (x1) ← R(x1),P (x1) ← P (x2), S(x1, u1), not T (x2, v 1).(8)(9)The first one is a base rule, where a rule is called a base rule if all predicates in the body of the rule are extensional. Thesecond one has a recursive call to P (x2). Expanding the recursive call in the second rule produces two new rules for P (x1):P (x1) ← R(x2), S(x1, u1), not T (x2, v 1),P (x1) ← P (x3), S(x2, u2), not T (x3, v 2), S(x1, u1), not T (x2, v 1).(10)(11)Again, the first one is a base rule, and the second one has a recursive call to P (x3) which can be further expanded toproduce more rules about P (x1). However, these new rules are really redundant. For instance, expanding P (x3) in (11)using rule (6) produces the following rule:P (x1) ← R(x3), S(x2, u2), not T (x3, v 2), S(x1, u1), not T (x2, v 1).(12)Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913897But this rule is subsumed by (10). In fact, one can show that this program is equivalent to the program Π (cid:7)two rules (8) and (10). Π (cid:7)4 has no loops and is defined by the conjunction of4 and(cid:15)Π (cid:7)4 which contains(cid:4)∀xP (x) ⊃ R(x) ∨ ∃ yuvR( y) ∧ S(x, u) ∧ ¬T ( y, v).(cid:4)(cid:7)(cid:7)This is an example where recursive expansion terminates in one step. As we shall see, one reason is that the body of r2can be separated into two parts, Bh = {S(x, u)} and Bb = {P ( y), not T ( y, v)}, such that Bh and the head of rule r2 do notshare any variables with Bb.Example 5. Consider another program Π5:r1:P (x) ← R1(x),r2: Q (x, y) ← R2(x, y),r3:r4: Q (x, y) ← P (x), S(x, u).P (x) ← Q (x, y), not T ( y, v),For this program, the intensional predicates are P and Q . We can see that Π5 does not have a finite complete setof loops either: for each n > 0, {P (x), Q (x, y1), . . . , Q (x, yn)} is a loop. Notice here that in every loop, all atoms share acommon variable x.Just like Example 4, the recursive rules r3 and r4 only need to be expanded a finite number of times. For r3, expandingQ (x, y) in its body once produces one base rule and one recursive rule of the form P (x) ← P (x), . . . which can be discarded.For r4, expanding P (x) in its body once produces a base rule and the following recursive rule:Q (x, y) ← Q (x, y1), S(x, u), not T ( y1, v).Expanding Q (x, y1) in (13) using r2 produces a base rule:Q (x, y) ← R2(x, y1), S(x, u), not T ( y1, v).Expanding Q (x, y1) in (13) using r4 produces a recursive rule:Q (x, y) ← P (x), S(x, u1), S(x, u), not T ( y1, v).(13)(14)(14) is subsumed by r4. It is redundant, and do not need to be expanded.On further examination, we found that what makes this program first-order definable is that in every loop that“uses” the recursive rule r3 (and similarly r4), the body of the rule can be separated into two parts, Bh = ∅ andBb = {Q (x, y), not T ( y, v)}, such that the variables in both Bh ∪ {Head(r3)} and Bb are the same as the variables in allthe atoms in this loop.4. Loop-separable programsWe have seen two examples above that do not have finite complete sets of loops but are nonetheless first-order definable.They are what we will call loop-separable programs. Our main result of this paper is in showing that all such programs arefirst-order definable. To define these programs, we need to first introduce some additional notions about loops.4.1. Loop patternsThe two examples above suggest that when the variables in the rules involved in the loops of a program have some“patterns”, its loop formulas are then “well-behaved” in the sense that they do not grow infinitely long. However, loops aresets of atoms, and the variables in a loop may not be the same as the variables occurring in the rules involved in the loop.This motivates our following definition of derivation paths, which extends the notion of path in the dependency graph of aprogram.Definition 3. A derivation path S of a program Π is a finite sequence of pairs of an atom and a rule:(α1, ρ1), . . . , (αn, ρn)where(15)• for 1 (cid:2) i (cid:2) n, there is a rule ri ∈ Π and a substitution (xi/ yi) such that ρi = ri(xi/ yi), where xi is the tuple of all thevariables in ri and for any local variable xi j of ri , yi j is a new variable not in (αk, ρk) (1 (cid:2) k < i);• for 1 (cid:2) i (cid:2) n, αi = Head(ρi);• for 1 (cid:2) i < n, αi+1 ∈ Pos(ρi).898Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913If there is a path starting from an atom and ending at the same atom, then there is a loop. For derivation path, we alsoneed to know when there is a cycle. In the following, we will define a relation between two pairs of an atom and a rule.Let ¯t1 = (t11, . . . , t1n) and ¯t2 = (t21, . . . , t2n) be two tuples of terms of the same length. We define ¯t1 ∼ ¯t2 if• for every i (1 (cid:2) i (cid:2) n) and constant c, t1i = c if and only if t2i = c;• for every i (1 (cid:2) i (cid:2) n) and variable x, if x ∈ ¯t1 and x ∈ ¯t2, then t1i = x if and only if t2i = x;• for every i (1 (cid:2) i (cid:2) n) and variable x, if x ∈ ¯t1 and x /∈ ¯t2, then there is a variable y such that y ∈ ¯t2 and y /∈ ¯t1, and• for every i (1 (cid:2) i (cid:2) n) and variable x, if x ∈ ¯t2 and x /∈ ¯t1, then there is a variable y such that y ∈ ¯t1 and y /∈ ¯t2, andt1i = x if and only if t2i = y;t2i = x if and only if t1i = y.We also use ¯t1 (cid:5) ¯t2 if it is not the case ¯t1 ∼ ¯t2. For example, we have (x, y, x, z) ∼ (x, u, x, w) and (x, y, z) (cid:5) ( y, x, u).Intuitively, ¯t1 ∼ ¯t2 represents a special mutual substitution relation between ¯t1 and ¯t2, where variables and their cor-responding positions occurring in ¯t1 and ¯t2 cannot be mixed. Precisely, these properties are presented in the followingproposition.Proposition 5. Let ¯t1 and ¯t2 be two tuples of terms of length n, and ¯t1 ∼ ¯t2. Then, there is a substitution x/ y = {x1/ y1, . . . , xk/ yk},where xi and yi (1 (cid:2) i (cid:2) k) are variables, and• for any 1 (cid:2) i < j (cid:2) k, xi and x j are different variables;• for any 1 (cid:2) i < j (cid:2) k, yi and y j are different variables;• {x1, . . . , xk} ∩ Var(¯t2) = ∅ and { y1, . . . , yk} ∩ Var(¯t1) = ∅;• ¯t1(x/ y) = ¯t2 and ¯t2( y/x) = ¯t1.Proof. Let x1, . . . , xk be the variables only in ¯t1 and y1, . . . , yk the variables only in ¯t2, such that t1i = x j if and only ift2i = y j , 1 (cid:2) i, j (cid:2) k. (cid:2)In the following, we call the substitution (x/ y), as shown in Proposition 5, the witness of ¯t1 ∼ ¯t2. For example, { y/u, z/w}is the witness of (x, y, x, z) ∼ (x, u, x, w).We extend relation ∼ to atoms, rules and pairs of an atom and a rule. For two atoms α1 and α2, where α1 = P (¯t1) andα2 = P (¯t2), we use α1 ∼ α2 if ¯t1 ∼ ¯t2. For two rules ρ1 and ρ2, where ρ1 = r(x/ y1), ρ2 = r(x/ y2) and x is the tuple of allvariables in r, we use ρ1 ∼ ρ2 if y1 ∼ y2. For two pairs (α1, ρ1) and (α2, ρ2), where α1, α2 are atoms, and ρ1, ρ2 are rules,we use (α1, ρ1) ∼ (α2, ρ2) if α1 ∼ α2 and ρ1 ∼ ρ2. We also use O1 (cid:5) O2, if it is not the case O1 ∼ O2, where O1 and O2can be two atoms, rules or pairs of an atom and a rule.Now we can give the definition of loop pattern.Definition 4. A derivation path of form (15) is called a loop pattern if n > 1, ρ1 ∼ ρn, and ρi (cid:5) ρ j for any other i,(1 (cid:2) i, j (cid:2) n).jExample 6. We continue with the program Π4 in Example 4 and Π5 in Example 5.For program Π4, its loop patterns are of the form:lp1:(cid:4)(cid:4)(cid:4)(cid:7)P (x1), r2(x/x1, y/x2, u/u1, v/v 1)(cid:7)P (x2), r2(x/x2, y/x3, u/u2, v/v 2)(cid:7)P (x3), r2(x/x3, y/x4, u/u3, v/v 3),,.Note thatr2(x/x1, y/x2, u/u1, v/v 1) ∼ r2(x/x3, y/x4, u/u3, v/v 3),r2(x/x1, y/x2, u/u1, v/v 1) (cid:5) r2(x/x2, y/x3, u/u2, v/v 2)butandr2(x/x2, y/x3, u/u2, v/v 2) (cid:5) r2(x/x3, y/x4, u/u3, v/v 3).For program Π5, there are two forms of loop patterns:(16)Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913lp1:lp2:(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4),(cid:7)P (x1), r3(x/x1, y/x2, v/v 1)(cid:7)Q (x1, x2), r4(x/x1, y/x2, u/u1)(cid:7)P (x1), r3(x/x1, y/x3, v/v 2)(cid:7)Q (x1, x2), r4(x/x1, y/x2, u/u1)(cid:7)P (x1), r3(x/x1, y/x3, v/v 1)(cid:7)Q (x1, x3), r4(x/x1, y/x3, u/u2),,,,.899(17)(18)The following proposition shows the relationship between loop patterns and loops.Proposition 6. If S is a loop pattern of form (15) of a program Π , then {α1( y/x), . . . , αn( y/x)} is a loop of Π , where (x/ y) is thewitness of α1 ∼ αn.Proof. There is a path from α1( y/x) to αn( y/x), and α1( y/x) = αn( y/x). (cid:2)There are programs that do not have a finite complete set of loops, while the following proposition shows that everyprogram has a finite complete set of loop patterns.Proposition 7. For every program Π , there is a finite set of loop patterns Sl such that for every loop pattern S of Π , there is a looppattern S(cid:7)θ , where θ = (x/ y) is a substitution, and all variables in y are different.(cid:7) ∈ Sl and S = SProof. Please see Section 5.1. (cid:2)4.2. Loop-separable programNow we present our main result.Definition 5 (Loop-separable programs). A program Π is loop-separable if for every loop pattern of form (15), one of thefollowing cases holds:Case 1: there is a pair (αi, ρi), 1 (cid:2) i < n, such that Body(ρi) can be separated into two parts Bh and Bb and– Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(ρi),– αi+1 ∈ Bb,– Var({αi} ∪ Bh) ∩ Var(Bb) = ∅;Case 2: for every pair (αi, ρi), 1 (cid:2) i < n, Body(ρi) can be separated into two parts Bh and Bb and– Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(ρi),– αi+1 ∈ Bb,– Var({αi} ∪ Bh) ∩ Var(Bb) =(cid:16)nj=1 Var(α j).Example 7. Consider loop pattern lp1 of program Π4 and the pair (P (x1), r(cid:7)2), where r(cid:7)2 isr2(x/x1, y/x2, u/u1, v/v 1) : P (x1) ← P (x2), S(x1, u1), not T (x2, v 1).We can separate Body(rcase 1 in Definition 5, and program Π4 is loop-separable.(cid:7)) into two parts: Bh = {S(x1, u1)} and Bb = {P (x2), not T (x2, v 1)}. So lp1 satisfies the condition ofConsider loop patterns lp1 and lp2 of program Π5. We can see that both of them satisfy the condition of case 2 inDefinition 5, so program Π5 is also loop-separable.Note that the two cases in Definition 5 are not exclusive. There are loop patterns that satisfy the conditions of bothj=1 Var(α j) = ∅. Furthermore, givencases. For instance, a loop pattern of form (15) could be both of case 1 and case 2 ifa program, it is possible that some of its loop patterns are of case 1 while others case 2.(cid:16)nExample 8. Consider the program Π6:r1:P (x) ← R1(x),r2: Q (x) ← R2(x),r3:P (x) ← Q (x), R3( y),900Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913r4: Q (x) ← P (x), R4( y),P (x) ← P ( y), R5( y).r5:There are four forms of loop patterns:lp1:lp2:lp3:lp4:(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4),,(cid:7)P (x1), r5(x/x1, y/x2)(cid:7)P (x2), r5(x/x2, y/x3)(cid:7)P (x3), r5(x/x3, y/x4),(cid:7)P (x1), r3(x/x1, y/ y1),(cid:7)Q (x1), r4(x/x1, y/ y1)(cid:7)P (x1), r3(x/x1, y/ y1),(cid:7)Q (x1), r4(x/x1, y/ y1)(cid:7)P (x1), r3(x/x1, y/ y1),(cid:7)Q (x1), r4(x/x1, y/ y1)(cid:7)Q (x1), r4(x/x1, y/ y1)(cid:7)P (x1), r3(x/x1, y/x2),(cid:7)P (x2), r3(x/x2, y/ y2),(cid:7)Q (x2), r4(x/x2, y/ y2),,,,.(19)(20)(21)(22)As we can see that lp4 is a loop pattern of case 1, lp2 and lp3 are loop patterns of case 2, and lp1 is a loop pattern of bothcase 1 and case 2.Theorem 2. If a program is loop-separable, then it is first-order definable.According to Theorem 2, programs Π4, Π5 and Π6 are first-order definable.Furthermore, the problem of checking whether a given program is loop-separable is decidable, as indicated by the fol-lowing theorem.Theorem 3. It is decidable to check whether a program is loop-separable.5. Proofs of the main theoremsThe proofs of the main theorems (i.e. Theorems 2 and 3) are rather technical and tedious. However, the underlyingideas are simple. For Theorem 2, we first prove that it holds with the restriction of the UNA, then extend this result tothe general case. The first step is of the most technically challenging. For this purpose, we need to relate the answer setsemantics to so-called expansion tree, extended from the same technique in Datalog. Then, we show that for any loop-separable program, we can always pick up a finite set of expansion trees to capture all its answer sets. Based on these finitenumber of expansion trees, we can explicitly define a first-order sentence that exactly captures the original program.Theorem 3 is a direct consequence of Proposition 7, which can be proven by showing that, under the operator ∼, thereis a bound for the length of loop patterns of a given program.5.1. Proofs of Proposition 7 and Theorem 3We first prove Proposition 7 and Theorem 3, as the proof techniques are needed in proving Theorem 2. We need thefollowing lemma about the length of a derivation path.Lemma 1. Let Π be a program. There exists an natural number N such that for any derivation path of form (15), if n > N then thereexists i, j (1 (cid:2) i < j (cid:2) n) such that (αi, ρi) ∼ (α j, ρ j).Proof. Note that Π has only finite many rules, so the original statement follows immediately from the following one:Let k be a natural number. There exists a natural number Nk such that for any set {¯t1, . . . , ¯tn} of tuples of length k, if n > Nk thenthere exists i, j (1 (cid:2) i < j (cid:2) n) such that ¯ti ∼ ¯t j .In other words, there exists a bound for a set of term tuples of fixed length if there are no two similar term tuples in it.Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913901(cid:7)(cid:7)i= tWe first ignore all constants. Now we divide the set of term tuples into categories such that each category is a partitionof the k terms. That is, for any two term tuples ¯t and ¯tj (1 (cid:2) i (cid:3)= j (cid:2) k), ti = t j(cid:7)j . The number of categories is finite since k is a fixed number. More specifically, the number of allif and only if tcategories is exactly Bk, the k-th Bell number, which can be understood as the number of equivalence relations on a setwith k members. Clearly, two term tuples in different categories are not similar. We now prove that there exists a boundfor any of the categories if there are no two similar term tuples in it. Without loss of generality, we only consider the casethat all terms in the term tuple are distinct. The other cases can be obtained in a similar way.in the same category, for every pair i,In this category, for any term tuple ¯t, there does not exist ti and t j such that ti = t j . Let Tk be the maximal number ofterm tuples of length k in this category such that there are no two similar term tuples in it. Clearly, T 1 = 1. Now considerto calculate Tk for k > 1. Suppose there are no two term tuples that are similar in this category. Let ¯t = (x1, . . . , xk) be ais not similar to ¯t, then there must exist i (1 (cid:2) i (cid:2) k) such thatterm tuple and xi (cid:3)= x j (1 (cid:2) i (cid:3)= j (cid:2) k). If another tuple ¯txi ∈ ¯t. Then,consider all the term tuples in this category such that x1 is in the k-th position. The number of such term tuples is less orequal than Tk−1. Otherwise, there exist two term tuples that are similar. Thus, we have. Without loss of generality, assume that x1 is in the k-th position of ¯tand xi is not in the i-th position in ¯t(cid:7)(cid:7)(cid:7)(cid:7)T 1 = 1,Tk (cid:2) k(k − 1)Tk−1 + 1,k > 1.Here, k in k(k − 1)Tk−1 means that there are k terms, k − 1 means that these variables must be in a different position, andTk−1 means that, as discussed above, there are at most Tk−1 term tuples by fixing a term in a particular position. Hence,Tk is bounded. In fact,Tk (cid:2) k!(k − 1)! ×(cid:17)1(cid:2)i(cid:2)k1i!(i − 1)!.The above proof shows that there exists a bound when ignoring all constants. When considering constants, this statementstill holds since the set of constants is finite. In fact, we can divide the set of term tuples into m groups that contain mdifferent constants, 0 (cid:2) m (cid:2) C , where C is the number of all constants. Then, each group has a bound if there does not existtwo substations “similar”. The above case is for m = 0. The proof can be easily extended to an arbitrary m. (cid:2)Proof of Proposition 7. By Lemma 1, given a program Π , there are natural numbers N1 and N2, such that for every looppattern S of Π , the length of S is less than N1, and thus, the number of variables in S is less than N2. Let v 1, . . . , v N2 beN2 variables not in Π , and Sl be all the possible loop patterns of Π using these variables.We can see that Sl is finite, and for every loop pattern S of Π , there is a loop pattern S(cid:7) ∈ S and S = S(cid:7)θ , whereθ = (x/ y) is a substitution, and all variables in y are different. (cid:2)Proof of Theorem 3. The set of loop patterns in Sl as defined in Proposition 7 is finite, and it is sufficient to check if thecondition in Definition 5 holds for each loop pattern in Sl. (cid:2)5.2. Correspondence between answer set and expansion treeNow we extend the notion of expansion tree, introduced in Datalog [3], to first-order answer set program with exten-sional database, and show how it is related to the answer set semantics. More precisely, we show that a structure A is ananswer set of a given program Π if and only if A is supported by a set of expansion trees of Π . In this subsection and thenext, unless stated otherwise, we assume that all the structures considered are models of Σuna.Definition 6. An expansion tree T of a program Π is a (finite) tree such that• the nodes of T are pairs of the form (α, ρ), where α is an atom and ρ = rθ such that r ∈ Π is a rule, θ a substitution,and α = Head(ρ);• for any node (α, ρ), let β1, . . . , βi be all the intensional atoms in Pos(ρ), then (α, ρ) has i children labeled with theatom β1, . . . , βi .In particular, a node (α, ρ) of an expansion tree T is a leaf of T if and only if all the atoms in Pos(ρ) are either equalityor extensional atoms.Let T be an expansion tree of a program Π and w a node of T . We use αw and ρw to denote the atom and the ruleof w, and T w the subtree of T whose root is w. Let θ be a substitution. We use wθ to denote the pair (αw θ, ρw θ), and T θthe expansion tree obtained from T by replace every node w in T by wθ . We also use dep(T ) to denote the depth of anexpansion tree T , and tree(Π) the (infinite) set of all expansion trees of Π .902Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913Given an expansion tree T of a program Π , without loss of generality, we assume that variables in T and variables in Πare disjoint, and that for any node w, the variables in the body of ρw either occur in the head of ρw or they do not occurin any nodes of T except T w . Note that every path in T is a derivation path of Π .Given an expansion tree T , we use rT to denote the rule whose head is the atom of the root of T , and the positive bodyand negative body are defined by:(cid:18)(cid:8)(cid:18)(cid:8)Pos(rT ) =Pos(ρw )Neg(rT ) =Neg(ρw )(cid:10)(cid:9)(cid:9) w is a leaf of T,(cid:9)(cid:9) w is a node of T(cid:10).Given two expansion trees T 1 and T 2, we say that T 1 is subsumed by T 2 (or T 2 subsumes T 1) if the roots of T 1 and T 2 arelabeled by the same atom and Body(rT 2 ) ⊂ Body(rT 1 ).Definition 7. Let Π be a program, A a structure of τ (Π) and T a (possibly infinite) set of expansion trees. We say that Ais supported by T , if for every intensional predicate P and a ∈ P, there is an expansion tree T ∈ T and an assignment σon Var(T ) over A such that σ (¯t) = a and (A, σ ) |(cid:9) (cid:4)BodyrT , where P (¯t) is the atom of the root of T .AThe following two lemmas show the relationship between the answer sets and expansion trees.Lemma 2. Let Π be a program and A a structure of τ (Π) which is a model of (cid:3)Π . If A is an answer set of Π , then A is supported bytree(Π).Proof. Assume that A is an answer set of Π . Let Ae be the structure of τext(Π) such that Dom(Ae) = Dom(A) and PAfor all extensional predicate P ∈ Pext(Π). Also, let M = {P (a) | P ∈ Pint(Π) and a ∈ PPanswer set of the propositional program ΠAe , where ΠAe is the instantiation of Π on Ae .Ae =A}. By Proposition 1, M is anBy Definition 7, it is sufficient to show that for every P (a) ∈ M, there is an expansion tree T ∈ tree(Π) and an assignmentσ on Var(T ) over A such that P (a) = α[σ ] and (A, σ ) |(cid:9) (cid:4)BodyrT , where α is the atom of the root of T .From the definition of the answer set for propositional program, M is the minimal set which satisfies every rules inGLM (ΠAe ). We define M0 = ∅ and Mi = TP(Mi−1) for i > 0, where TP is a map from a subset of LA to a subset of LAdefined as following:(cid:9)(cid:9) there is a rule pa ← pb1, . . . , pbk in GLM (ΠAe ) such that {pb1, . . . , pbk} ⊆ STP(S) =pa(cid:8)(cid:10).GLM (ΠAe ) is positive, so there exists n such that Mn = Mn+1 = M [30]. We will show by induction that if P (a) ∈ Mi ,0 (cid:2) i (cid:2) n, then there is an expansion tree T ∈ tree(Π) and an assignment σ on Var(T ) over A such that P (a) = α[σ ] and(A, σ ) |(cid:9) (cid:4)BodyrT , where α is the atom of the root of T .For i = 0, the statement holds trivially. We assume that the statement holds for all i < j, and we will show next that italso holds for j.Let P (a) ∈ M j . By the definition of TP(M j), there is a ruleP (a) ← pb1, . . . , pbkin GLM (ΠAe ) such that {pb1, . . . , pbk} ⊆ M j−1. By the definitions of ΠAe and GLM (ΠAe ), there is a ruleP (a) ← pb1, . . . , pbk, not pc1, . . . , not pclin ΠAe , and there is a rule r:P (¯t) ← b1, . . . , bk, bk+1, . . . , bk(cid:7) , not c1, . . . , not cl, not cl+1, . . . , not cl(cid:7)in Π and an assignment σr on Var(r) over A such that:• P (¯t)[σr] = P (a);• b1, . . . , bk are intensional atoms, and bm[σr] = pbm, 1 (cid:2) m (cid:2) k;• bk+1, . . . , bk(cid:7) are either extensional atoms or equality atoms, and (A, σr) |(cid:9) bm, k < m (cid:2) k• c1, . . . , cl are intensional atoms, and cm[σr] = pcm, 1 (cid:2) m (cid:2) l;• cl+1, . . . , cl(cid:7) are either extensional atoms or equality atoms;• (A, σr) (cid:3)|(cid:9) cm, 1 < m (cid:2) l.(cid:7)(cid:7);By assumption, for every 1 (cid:2) m (cid:2) k, there is an expansion tree Tm ∈ tree(Π) and an assignment σm on Var(Tm) over A, where αm is the atom of the root of Tm. Without loss of generality, wesuch that pbm = αm[σm] and (A, σm) |(cid:9) (cid:4)BodyrTmassume Var(Tm1 ) ∩ Var(Tm2 ) = ∅, 1 (cid:2) m1 (cid:3)= m2 (cid:2) k.Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913903We introduce a new variable vc for each domain element c ∈ Dom(A), and define a substitution θm for each Tm, 1 (cid:2)m (cid:2) k, as following:(cid:9)(cid:9) x ∈ Var(Tm) and x is assigned to c in σmθm =x/vc(cid:8)(cid:10).We can see that pbm = αm[σm] = αmθm[σ (cid:7)root of Tm and σ (cid:7)element c., where αm is them is the assignment on Var(Tmθm) over A which assign every variable of the form vc to the domain], and (A, σm) |(cid:9) (cid:4)BodyrTmif and only if (A, σ (cid:7)m) |(cid:9) (cid:4)BodyrTm θmmLet θ be the substitution(cid:8)θ =x/vc(cid:9)(cid:9) x ∈ Var(r) and x is assigned to c in σr(cid:10).We then define an expansion tree T as following:• the root of T is (P (¯t)θ, rθ),• (P (¯t)θ, rθ) have k subtree: T 1θ1, . . . , Tkθk.We can see that b1θ, . . . , bkθ are all the intensional atoms in Pos(rθ). For 1 (cid:2) m (cid:2) k, the atom of the root of Tmθm is αmθm,] = pbm and pbm = bm[σr] = bmθ[σ (cid:7)and αmθm = bmθ by noticing that αmθm[σ (cid:7)]. So T is well defined.mmAll variables in T are of the form vc where c is a domain element of A. Let σ ∗every variable of the form vc in Var(T ) to the domain element c. We can see that:be the assignment on Var(T ) that assign• T θ is an expansion tree by noticing that T 1θ1, . . . , Tkθk are expansion trees and that (P (¯t)θ, rθ) has k children whichare labeled with the atoms b1θ, . . . , bkθ ;• the root of T θ is labeled by atom P (¯t)θ and P (a) = P (¯t)θ[σ ∗] by noticing P (a) = P (¯t)[σr];• (A, σ ∗) |(cid:9) (cid:4)(1 (cid:2) m (cid:2) k), (A, σ ∗) |(cid:9) bm (k < m (cid:2) kBodyrT θ by noticing that (A, σm) |(cid:9) (cid:4)BodyrTm θm).(1 (cid:2) m (cid:2) l(cid:7)(cid:7)), and (A, σ ∗) (cid:3)|(cid:9) cmThis completes the proof. (cid:2)Lemma 3. Let Π be a program and A be a structure of τ (Π) which is a model of (cid:3)Π . If A is supported by a set of expansion trees T ,then A is an answer set of Π .Proof. Assume that A is a model of (cid:3)Π , and is supported by a set of expansion trees T . By Theorem 1, it is sufficient toshow that A is a model of LF(Π).Let L be a loop of Π The loop formula of L is the universal closure of(cid:11)(cid:11)α ⊃α∈Lα∈LES(α, L, Π).Let σ be an arbitrary assignment on Var(L) over A. If (A, σ ) (cid:3)|(cid:9)wise, there exists a ∈ Pcase.α∈L α, then (A, σ ) |(cid:9)such that P (¯t) ∈ L and a = σ (¯t). We will show that (A, σ ) |(cid:9)A(cid:19)(cid:19)(cid:19)(cid:19)α∈L α ⊃α∈L ES(α, L, Π). Other-α∈L ES(α, L, Π) also holds in thisBy assumption, A is supported by T . So there exists an expansion tree T ∈ T and an assignment δ on Var(T ) over∗) is the atom of the root of T . We will show by induction on theA such that (A, δ) |(cid:9) (cid:4)BodyrT and δ(¯tstructure of the expansion tree T that for every node w = (P∗) = a, where P (¯t(cid:7)), ρ) of T ,(cid:7)(¯t• (A, δ) |(cid:9) P• for every loop L(cid:7)) and(cid:7)(cid:7)(¯t(cid:19)(A, σ (cid:7)) |(cid:9)α∈L(cid:7) ES(α, L, if there is an atom P(cid:7)(cid:7), Π). Without loss of generality, we assume Var(Land an assignment σ (cid:7)(cid:7)(cid:7)) ∈ L(cid:7)(¯t(cid:7)) ∩ Var(T ) = ∅.on Var(L(cid:7)) over A such that σ (cid:7)(¯t(cid:7)(cid:7)) = δ(¯t(cid:7)), then(cid:7)(¯t(cid:7)), ρ) is a leaf, then Body(ρ) ⊆ Body(rT ). We have (A, δ) |(cid:9) (cid:4)Bodyρ and (A, δ) |(cid:9) P(cid:7)(¯t(cid:7)) by noticing that Abe a loop and x the tuple of variables in Land σ (cid:7)(¯t(cid:7). Let σ (cid:7)(cid:7)). Also, let y be the tuple of the local variables of ρ, and σ (cid:7)(cid:7)be an assignment on x over A such that there is an atombe the assignment on x ∪ y over A(cid:7)(cid:7)) = δ(¯t(cid:7)(1) If w = (Pis a model of (cid:3)Π .(cid:7)Let L(cid:7)(¯t(cid:7)(cid:7)) ∈ LPsuch that σ (cid:7)(cid:7)(x) = σ (cid:7)(x) and σ (cid:7)(cid:7)( y) = δ( y).We have(cid:4)A, σ (cid:7)(cid:7)(cid:7)|(cid:9) (cid:4)Bodyρ ∧(cid:13)s (cid:3)= s(cid:7)Q (s)∈L(cid:7), Q (s(cid:7))∈Pos(ρ)904Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913(cid:7), and that the positive part of ρ are all extensional atoms. So, weby noticing that there are only intensional atoms in Lhave(cid:7)A, σ (cid:7)|(cid:9) ∃ y(cid:12)(cid:4)Bodyρ ∧(cid:14)(cid:13)s (cid:3)= s(cid:7)Q (s)∈L(cid:7), Q (s(cid:7))∈Pos(ρ)(cid:4)(cid:4)and(cid:7)|(cid:9)A, σ (cid:7)(cid:11)(cid:4)ES(cid:7)α, L(cid:7), Π.α∈L(cid:7)(cid:7)), ρ) is not a leaf, then let w 1, . . . , wn be the children of w. Assume that for every child w i = (Q i(¯ti), ρi)(cid:7)(¯t(2) If w = (Pof w, 1 (cid:2) i (cid:2) n,• (A, δ) |(cid:9) Q i(¯ti) and(cid:7)(cid:7)• for every loop L(cid:7)(cid:7), Π).α∈L(cid:7)(cid:7) ES(α, L(cid:19), if there is an atom Q i(¯t(cid:7)i) ∈ L(cid:7)(cid:7)and an assignment σ (cid:7)(cid:7)such that σ (cid:7)(cid:7)(¯t(cid:7)i) = δ(¯ti), then (A, σ (cid:7)(cid:7)) |(cid:9)(cid:7)By the definition of rT , we have Neg(ρ) ⊆ Neg(rT ). We also have Pos(ρ) = {Q 1(¯t1), . . . , Q n(¯tn)}, and (A, δ) |(cid:9) Q i(¯ti),, if there is an atom1 (cid:2) i (cid:2) n. So, we have (A, δ) |(cid:9) (cid:4)(cid:7)(¯t(cid:7)(cid:7)) ∈ Lon Var(LPIf there is a child w i = (Q i(¯ti), ρi) of w, and there is an atom Q i(¯tα∈L(cid:7) ES(α, L(cid:7), Π) by induction hypotheses. Otherwise, for any two atoms Q (s) ∈ L(cid:7)). We still need to show that for every loop L(cid:7)(cid:7), Π).i) = δ(¯ti), then (A, σ (cid:7)) |(cid:9)and Q (s(cid:7)) ∈ Pos(ρ), we have σ (cid:7)(s) (cid:3)=be the assignment on x ∪ y over A such that(cid:7)), then (A, σ (cid:7)) |(cid:9)(cid:7)i) ∈ Lα∈L(cid:7) ES(α, Lsuch that σ (cid:7)(¯t(cid:7)Bodyρ and (A, δ) |(cid:9) Pand an assignment σ (cid:7)(cid:7)) such that σ (cid:7)(¯t(cid:7)(cid:7)) = δ(¯t(cid:7)(¯t(cid:19)(cid:19)(cid:7)(cid:7)δ(s(cid:7)). Similarly to (1), let y be the tuple of the local variables of ρ, and σ (cid:7)(cid:7)σ (cid:7)(cid:7)(x) = σ (cid:7)(x) and σ (cid:7)(cid:7)( y) = δ( y). We have|(cid:9) (cid:4)(cid:13)(cid:7)(cid:4)s (cid:3)= s(cid:7).A, σ (cid:7)(cid:7)Bodyρ ∧So,and(cid:4)(cid:4)Q (s)∈L(cid:7), Q (s(cid:7))∈Pos(ρ)(cid:7)A, σ (cid:7)|(cid:9) ∃ y(cid:12)(cid:4)Bodyρ ∧(cid:13)(cid:14)s (cid:3)= s(cid:7)Q (s)∈L(cid:7), Q (s(cid:7))∈Pos(ρ)(cid:7)|(cid:9)A, σ (cid:7)(cid:11)α∈L(cid:7)(cid:4)ES(cid:7)α, L(cid:7), Π.(cid:2)5.3. Finite set of expansion trees for loop-separable programFrom Lemmas 2 and 3, a program Π can be defined by (cid:3)Π and all its expansion trees. However, there might exist infinitenumber of expansion trees in general by even considering the equivalence under substitution. Fortunately, we can showthat for loop-separable programs, we can always find a finite set of expansion trees which is equivalent to tree(Π).The key idea is that for loop-separable programs, the depth of their expansion trees can be bounded to some extent. Thatis, for any loop-separable program, there exists a natural number k such that for any expansion tree of the program whosedepth is greater than k, we can always construct another expansion tree, which subsumes the original one and whose depthis less than k. Roughly speaking, any large expansion tree of a loop-separable program can be unfolded into a smaller one.For this purpose, we need to show some propositions of derivation paths and loop patterns. A derivation path of form(15) is called a base pattern if atoms in Pos(ρn) are either equality or extensional atoms, and ρi (cid:5) ρ j (1 (cid:2) i < j (cid:2) n). In thefollowing, we will define how a derivation path is extended by a loop pattern, and show the relationship between the looppatterns and the derivation paths in expansion trees.Definition 8. Let S = (w 1, . . . , wn) be a derivation path, S(cid:7)that S can be extended by Spairs:if there is a node w i (1 (cid:2) i (cid:2) n) such that w i ∼ w(cid:7) = (w(cid:7)1, . . . , w(cid:7)m) a loop pattern, and Var(S) ∩ Var(S(cid:7)1. An extension of S by S(cid:7)(cid:7)) = ∅. We sayis a sequence ofw 1, . . . , w i−1, w(cid:7)1θ1, . . . , w(cid:7)mθ1, w i+1θ2, . . . , wnθ2where(23)• (x/x(cid:7)) is the witness of w i ∼ w• ( y1/ ym) is the witness of w(cid:7)1;∼ w(cid:7)1(cid:7)m;Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913905• θ1 = x(cid:7)/x ∪ z(cid:7)/z, where z(cid:7)is the tuple of variables Var(S(cid:7)) \ x(cid:7), z is a tuple of new variables not in Var(S) ∪ Var(S(cid:7)), andall variables in z are different;• θ2 = {u/v | there is a variable v(cid:7)such that u/v(cid:7) ∈ (x/x(cid:7)), v(cid:7)/v(cid:7)(cid:7) ∈ ( y1/ ym) and v(cid:7)(cid:7)/v ∈ θ1}.Proposition 8. Let S = (w 1, . . . , wn) be a derivation path and SIf S, then Sbe an extension of S by Sis also a derivation path, Var(S∗∗(cid:7)(cid:7) = (w(cid:7)1, . . . , w∗) ∩ Var(S(cid:7)m) a loop pattern such that Var(S) ∩ Var(S(cid:7)) = ∅ and the length of Sis n + m − 1.∗(cid:7)) = ∅.Proof. Let Sso S∗is also a derivation path.∗be an extension of S by S(cid:7)of form (23). By Definition 8, we have w i = w(cid:7)1(x(cid:7)/x) = w(cid:7)1θ1 and w(cid:7)mθ1 = w iθ2,Consider the substitution θ1. All variables in Sare substitute to distinct new variables, so we have Var(S(cid:7)∗) ∩ Var(S(cid:7)) = ∅.It is obvious that the length of S∗is n + m − 1. (cid:2)Given a derivation path S and loop patterns S1, . . . , Sn. We also say a derivation path Sif there exist derivation paths S(cid:7)0(= S), S(cid:7)1, . . . , S(cid:7)n(= S(cid:7)) such that for 1 (cid:2) i (cid:2) n, S(cid:7)(cid:7)i is an extension of Sis an extension of S by S1, . . . , Sn(cid:7)i−1 by S i .Proposition 9. Let Π be a program and T an expansion tree of Π . Also, let Sl be the set of loop patterns as mentioned in Proposition 7and assume that Var(T ) ∩ Var(Sl) = ∅. If S = (w 1, . . . , wn) is a path in T such that w 1 is the root of T and wn a leaf, then S is eithera base pattern or an extension of S0 by S1, . . . , Sm, where S0 is a base pattern and S1, . . . , Sm are loop patterns such that S i ∈ Sl,1 (cid:2) i (cid:2) m.Proof. If w i (cid:5) w j (1 (cid:2) i < j (cid:2) n), then S is a base pattern. Otherwise, there exists w i , w j (1 (cid:2) i < j (cid:2) n) in S such thatw i ∼ w j .By Proposition 7, if there exists a base pattern S0 and loop patterns S(cid:7)m such that S is an extension of S0 by(cid:7)m, then there always exist loop patterns S1, . . . , Sm, such that S i ∈ Sl (1 (cid:2) i (cid:2) m) and S is an extension of S0 by∗1 and a loop(cid:7)1, . . . , SSS1, . . . , Sm. In the following, we will show that if S is not a base pattern, then there exists a derivation path Spattern S∗1 is less than the length of S and S is an extension of S∗2 such that the length of SWithout loss of generality, we assume that w i(cid:7) (cid:5) w j(cid:7)=(w 1, . . . , w i, w j+1( y1/x1), . . . , wn( y1/x1)), where (x1/ y1) is the witness of w i ∼ w j . Also,= (w i(x2/ y2), . . . ,w j(x2/ y2)), where x2 is the tuple of all variables in {w i, . . . , w j}, y2 is a tuple of new variables not in T and all vari-ables in y2 are different.∗∗1 by S2.(cid:7)(cid:7) (cid:2) j unless i = ifor every i (cid:2) i∗1 is a derivation path by noticing that w i = w j( y1/x1) and all variables in x1 do not occur in w j+1, . . . , wn. S∗2 is a∗2) = ∅ by noticing that y2 is a tuple of new variables. Furthermore, by Definition 8 and∗1) ∩ Var(Sand j = j(cid:7)1, . . . , S(cid:7) < j. Let Slet S∗1∗2S(cid:7)loop pattern and Var(SProposition 8, S is an extension of S∗1 by S∗2, and the length of S∗1 is less than the length of S. (cid:2)In the following, we will show that some properties of a derivation path still keep unchanged when it is extended. Weintroduce one more notion here. Given a derivation path S of form (15), we use NS(S) to denote the number of pair (αi, ρi),1 (cid:2) i < n, such that Body(ρi) can be separated into two parts Bh and Bb and• Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(ρi),• αi+1 ∈ Bb,• Var({αi} ∪ Bh) ∩ Var(Bb) = ∅.Proposition 10. Let S = (w 1, . . . , wn) be a derivation path, Sof form (23), thenthe extension of S by S(cid:7)(cid:7) = (w(cid:7)1, . . . , w(cid:7)m) a loop pattern and Var(S) ∩ Var(S(cid:7)) = ∅. Let S∗be(1) if (w(cid:7)1, . . . , w(cid:7)m) is a loop pattern of case 1 in Definition 5, and w(cid:7)j= (α(cid:7)j, ρ(cid:7)j) is the pair such that Body(ρ(cid:7)j) can be separated into∈ Bb,} ∪ Bh) ∩ Var(Bb) = ∅,two parts Bh and Bb and– Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(ρ(cid:7)j),– α(cid:7)j+1– Var({α(cid:7)j(cid:7)then (w1θ1, . . . , w– Bhθ1 ∩ Bbθ1 = ∅ and Bhθ1 ∪ Bbθ1 = Body(ρ j)θ1,– α(cid:7)– Var({α(cid:7)(cid:7)(cid:7)1, . . . , wm) is a loop pattern of case 2 in Definition 5, then (w∗) = NS(S) + NS(S(cid:7)mθ1) is also a loop pattern of case 1, and Body(wjθ1} ∪ Bhθ1) ∩ Var(Bbθ1) = ∅;j+1θ1 ∈ Bbθ1,(cid:7)).(2) if (w(3) NS(S(cid:7)j)θ1 can be separated into two parts Bhθ1 and Bbθ1 and(cid:7)1θ1, . . . , w(cid:7)mθ1) is also a loop pattern of case 2 in Definition 5;Proof. Statements (1) and (2) hold by noticing that a variable is always replaced by a distinct new one in substitutions θ1and θ2.906Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913For statement (3), we have w i = wNS(S) = NS= NS= NS(cid:4)(cid:4)(cid:4)(cid:7)(w 1, . . . , w i)(cid:4)(cid:4)w 1, . . . , w i−1, ww 1, . . . , w i−1, w(cid:7)mθ1 = w iθ2. So,(cid:7)1(x(cid:7)/x) = w(cid:4)(cid:7)1θ1 and w(cid:7)(w i, . . . , wn)(cid:7)(cid:7)+ NS+ NS(cid:7)(cid:7)w(cid:7)(cid:4)(w iθ2, . . . , wnθ2)(cid:4)(cid:4)(cid:7)mθ1, . . . , wnθ2+ NS(cid:7)1θ1(cid:7)1θ1(cid:7)(cid:7),(cid:7)(cid:7)(cid:4)(cid:7)(cid:7)Sθ1+ NS(cid:7)1θ1(cid:4)(cid:4)+ NSw(cid:7)mθ1, . . . , wnθ2(cid:7)(cid:7)and(cid:4)NSS(cid:7)∗w 1, . . . , w i−1, w(cid:4)(cid:7)(cid:7)(cid:4)(cid:4)= NS= NS(S) + NS= NS(S) + NS(cid:4)S(cid:7)Sθ1(cid:7).(cid:2)∗In the following two propositions, we will show that for some large expansion tree T , we can always find another smaller∗one Tsuch that T is subsumed by Tand the depth of Tis less than T .∗Proposition 11. Given a program Π and an expansion tree T of Π , let S = (w 1, . . . , wn) be a path in T such that w 1 is the root ofT and wn a leaf. If S is an extension of a base pattern S0 by loop patterns S1, . . . , Sm and there exists a loop pattern Sof case 1 in∗occurs in S1, . . . , Sm more than once, then there is an expansion tree TDefinition 5 such that Ssuch that T is subsumed by T∗∗∗.∗is loop pattern of case 1 in Definition 5. Let w = (αk, ρk) be the pair in S∗such that Body(ρk) can be separatedProof. Sinto two parts Bh and Bb and• Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(ρk),• αk+1 ∈ Bb,• Var({αk} ∪ Bh) ∩ Var(Bb) = ∅.From (3) in Proposition 10, there exist two nodes w i, w j in S such that• w i = (αi, ρkθi) and w j = (α j, ρkθ j);• for two different variables x1, x2, x1/ y1 ∈ θi and x2/ y2 ∈ θi , then y1, y2 are two different variables;• for two different variables x1, x2, x1/ y1 ∈ θ j and x2/ y2 ∈ θ j , then y1, y2 are two different variables.So, Body(ρk)θi can be also separated into two parts Bhθi and Bbθi and• Bhθi ∩ Bbθi = ∅ and Bhθi ∪ Bbθi = Body(ρkθi),• αi+1θi ∈ Bbθi ,• Var({αiθi} ∪ Bhθi) ∩ Var(Bbθi) = ∅.Let θ ∗be the substitution:(cid:8)∗ =θ(cid:9)(cid:9) x ∈ V∗, x/t ∈ θ jx/t,is the set of variables in Bb. Consider the rule ρkθ ∗x/t, x/t ∈ θi∪(cid:10)(cid:8)(cid:9)(cid:9) x /∈ V∗(cid:10)where V∗, we have• Head(ρkθ ∗) = αi ;• for every literal l ∈ Body(ρk), if lθi ∈ Bhθi , then lθ ∗ = lθi ∈ Body(ρkθi);• for every literal l ∈ Body(ρk), if lθi ∈ Bbθi , then lθ ∗ = lθ j ∈ Body(ρkθ j).We can construct T∗as shown in Fig. 1. Let T∗be the expansion tree obtained from T by• keep the nodes not in the subtree of w the same as T ;• replace the node w by w• for every intensional atom β∗ ∈ Body(ρkθ ∗), if β ∈ Body(ρk) is the atom such that βθi = β∗ ∈ Bhθi then (αw , ρkθ ∗) has∗ = (αi, ρkθ ∗);a child labeled by atom β∗, and copy all the node in the subtree of βθi in T w i to T• for every intensional atom β∗ ∈ Body(rθ ∗), if β ∈ Body(ρk) is the atom such that βθi ∈ Bbθi and βθ j = β∗;, then∗(αw , ρkθ ∗) has a child labeled by atom β∗, and copy all the node in the subtree of βθ j in T w j to T∗.From the construction of Tso T is subsumed by T∗∗. (cid:2), we can see that the roots of T and T∗are labeled by the same atom, and Body(rT ∗ ) ⊂ Body(rT ),Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913907Fig. 1. The proof of Proposition 11.Proposition 12. Given a program Π and an expansion tree T of Π , let S = (w 1, . . . , wn) be a path in T such that w 1 is the rootof T and wn a leaf. If there exist w i and w j in S such that (w i, . . . , w j) is a loop pattern of case 2 in Definition 5, then there is anexpansion tree Tsuch that T is subsumed by T∗∗.Proof. (w i, . . . , w j) is a loop pattern of case 2 in Definition 5. Let w i = (αi, r(x/¯ti)), w j = (α j, r(x/¯t j)). From case 2 ofDefinition 5, r(x/¯ti) can be separated into two parts Bh and Bb such that• Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(r(x/¯ti)),• αi+1 ∈ Bb,• Var({αi} ∪ Bh) ∩ Var(Bb) =k=i Var(αwk ).(cid:16)jLet θ ∗be the substitution:∗ =θ(cid:8)x/t(cid:9)(cid:9) x ∈ V∗, x/t ∈ x/¯t j(cid:10)(cid:8)∪x/t∗where VConsider the rule rθ ∗is the set of variables in Bb and not in, we have∗(cid:9)(cid:9) x /∈ V(cid:16), x/t ∈ x/¯ti(cid:10),jk=i Var(αwk ).• Head(rθ ∗) = αw i ;• for every literal l ∈ Body(r), if l(x/¯ti) ∈ Bh, then lθ ∗ = l(x/¯ti) ∈ Body(r(x/¯ti));• for every literal l ∈ Body(r), if l(x/¯ti) ∈ Bb, then lθ ∗ = l(x/¯t j) ∈ Body(r(x/¯t j)).We can construct T∗as shown in Fig. 2. Let T∗be the expansion tree obtained from T by• keep the nodes not in the subtree of w i the same as T ;• replace the node w i by (αw i , rθ ∗);• for every intensional atom β∗ ∈ Body(rθ ∗), if β ∈ Body(r) is the atom such that β(x/¯ti) = β∗ ∈ Bh then (αw i , rθ ∗) has achild labeled by atom β∗, and copy all the node in the subtree of β(x/¯ti) in T w i to T• for every intensional atom β∗ ∈ Body(rθ ∗), if β ∈ Body(r) is the atom such that β(x/ yi) ∈ Bb and β(x/¯t j) = β∗, then∗;(αw i , rθ ∗) has a child labeled by atom β∗, and copy all the node in the subtree of β(x/¯t j) in T w j to T∗.From the construction of Tso T is subsumed by T∗∗. (cid:2), we can see that the roots of T and T∗are labeled by the same atom, and Body(rT ∗ ) ⊂ Body(rT ),To end this section, we draw the conclusion that every loop-separable program can be captured by a finite set of itsexpansion trees.Lemma 4. Given a loop-separable program Π , there exists a finite set of expansion trees T such that for any structure A of τ (Π)which is a model of (cid:3)Π , if A is supported by tree(Π), then A is supported by T .908Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913Fig. 2. The proof of Proposition 12.Proof. Let Sl be the set of loop patterns as mentioned in Proposition 7. Let Sl = Sl1 ∪ Sl2, where Sl1 is the set of looppatterns of case 1 in Definition 5 and Sl2 is the set of loop patterns of case 2 and not case 1 in Definition 5. LetN1 = (numns + maxbn + 1) × (N + 1) + maxbl,where(cid:20)S∈Sl1• numns =NS(S),• N is the number mentioned in Lemma 1,• maxbl is the maximum length of base patterns of Π ,• maxbn is the maximum NS(Sb) when Sb is a base pattern.By Lemma 1, maxbl and maxbn always exist. Let N2 be the maximum number of variables in an expansion tree whose depthis less than or equal to N1. Let v 1, . . . , v N2 be N2 variables not in Π , and T be the set of all the expansion trees usingthese variables whose depth is less than or equal to N1.there is an expansion tree TIt is obvious that T is finite, and for every expansion trees T such that T do not share variables with T and dep(T ) (cid:2) N1,(cid:7).Let T ∈ tree(Π) be an expansion tree and dep(T ) > N1. It is sufficient to show that there exists an expansion tree T(cid:7)(x/ y), where x is the tuple of all variables in T(cid:7) ∈ T and a substitution x/ y such that T = T(cid:7)such that T is subsumed by T(cid:7)and dep(T(cid:7)) (cid:2) N1.Let S = (w 1, . . . , wn) be a path in T , where w 1 is the root of T , wn is a leaf of T , and n = dep(T ). We can see that(1) either NS(S) > numns + maxbn, or(2) there are wk1 , wk2 in S such that k2 − k1 > N and NS({wk1+1, . . . , wk2}) = 0.We will show that in both cases, there exists an expansion tree T∗such that T is subsumed by T∗.(1) By Proposition 9, assume that S is an extension of S0 by S1, . . . , Sm, where S0 is a base pattern and S1, . . . , Smmk=0 NS(Sk). We already have NS(S) >occurs in.are loop patterns such that S i ∈ Sl, 1 (cid:2) i (cid:2) m. By Proposition 10, we have NS(S) =numns + maxbn. So there exists a loop pattern SS1, . . . , Sm more than once. By Proposition 11, we can construct an expansion tree Tis a loop pattern of case 1 in Definition 5 and Ssuch that T is subsumed by T(2) From Lemma 1, there are two nodes w i, w j ∈ S (k1 < i < j (cid:2) k2) such that w i ∼ w j and NS((w i, . . . , w j)) = 0.. We can see that (w i, . . . , w j) issuch that such that T isWithout loss of generality, assume that w i(cid:7) (cid:5) w j(cid:7) (i (cid:2) ia loop pattern of case 2 in Definition 5. By Proposition 12, we can construct an expansion tree Tsubsumed by T(cid:7) (cid:2) j) unless i = iand j = jsuch that S(cid:7) < j(cid:20)∗∗∗∗∗∗∗.(cid:7)(cid:7)(cid:7)such that T is subsumed by T(cid:7)and dep(T(cid:7)) (cid:2) N1. (cid:2)Repeat above construction. We can always find an expansion tree T5.4. Proof of Theorem 2Now, we face to the proof of our main theorem, namely Theorem 2. We first consider the case with the restriction ofthe UNA, and then release the condition to the general case.Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913909Lemma 5. If a program Π is loop-separable, then Π is first-order definable under UNA. That is, there exists a first-order sentence ψon vocabulary τ (Π) such that for every structure A of τ (Π) which is a model of Σuna, it is an answer set of Π if and only if A is amodel of ψ .Proof. Let T be the set of expansion trees mentioned in Lemma 4. From Lemmas 2, 3 and 4, Π is defined by the conjunctionof (cid:3)Π and the following sentences:(cid:12)∀xP (x) ⊃(cid:11)(cid:14)(cid:4)BodyrT∧ x = ¯tT ∈T ∗for every predicate P ∈ Pint(Π), where T ∗form P (¯t). (cid:2)is the set of expansion trees in T whose root is labeled by the atom of theClearly, if a program is first-order definable then it is first-order definable under UNA. However, the converse does nothold in general.Example 9. We consider a program Π7 consisting of the following rules:T (x, y) ← E(x, y), not E(x, x), not E( y, y),T (x, z) ← T (x, y), T ( y, z),P (a, b) ← a = b,P (a, b) ← not P (a, b),(24)(25)where C(τ (Π7)) = {a, b}, Pext(Π7) = {E} and Pint(Π) = {T , P }.For any structure A which is a model of Σuna, we can see that A is not an answer set of Π by noticing that rule (24) isnever triggered and rule (25) is a contradiction. Π has no answer set which is a model of Σuna, and is defined by ⊥ underUNA.If we also consider structures where a and b are mapped to the same domain element, we can see that Π is notfirst-order definable. Otherwise, the program Π1 in Example 1 would be first-order definable.3Fortunately, for loop-separable programs, they are always first-order definable even without the restriction of the UNA.Given a vocabulary τ , let Fτ be the set of all functions f , where• the domain of f• if c ∈ C(τ ) is in the range of f , then f (c) = c.is C(τ ), and the range of fis a subset of C(τ );Given a program Π and f ∈ Fτ (Π) a function, let Π f be the program obtained by replace each occurrence of c in Π byf (c) for all c ∈ C(τ (Π)). Note that the only difference between vocabularies τ (Π) and τ (Π f ) is the set of constants. Theset of constants of τ (Π f ) is a subset of that of τ (Π).Proposition 13. Let Π be a program, and f ∈ Fτ (Π) a function. If Π is a loop-separable program, then Π fprogram.is a loop-separableProof. Directly from the definition of loop-separable program. (cid:2)The following proposition explicitly defines a sentence that captures a loop-separable program without the restriction ofthe UNA.Proposition 14. Let Π be a loop-separable program. Π is defined by(cid:12)(cid:11)f ∈Fτ (Π)ψΠ f∧ Σuna(cid:4)(cid:7)τ (Π f )∧(cid:13)(cid:4)f (c) = cc∈C(τ (Π ))(cid:14)(cid:7),(26)where Π f is defined by ψΠ f under UNA.Proof. Let A = ( A, cA1 , . . . , cAm , RA1 , . . . , RAn ) be a structure of τ (Π). It is sufficient to show that:3 For the proof of the indefinability of Π1, please refer to Example 3 and Proposition 2 in [5]. The basic ideas of these two examples are quite similar.910Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913(i) if A is an answer set of Π , then there is a function f ∈ Fτ (Π) such that A is a model of ψΠ f(cid:2)∧ Σuna(τ (Π f )) ∧(ii) if there is a function f ∈ Fτ (Π) such that A is a model of ψΠ f∧ Σuna(τ (Π f )) ∧(cid:2)c∈C(τ (Π))( f (c) = c), then A is anc∈C(τ (Π))( f (c) = c);answer set of Π .A(cid:7)m(cid:7) , RA1 , . . . , RLet A(cid:7) = ( A, c, A(cid:7)f and A(cid:7)(i) Let f ∈ Fτ (Π) be a function such that f (c1) = f (c2) if and only if cAn ) be the structure of τ (Π f ), where cA(cid:7)1 , . . . , cis a model of Σuna(τ (Π f )).If A is an answer set of Π , then A(cid:7)by ψ f under UNA, so A(cid:7)(cid:2)∧ Σuna(τ (Π f )) ∧ψΠ f(cid:2)c∈τ (Π)( fA(c) = c).f ∈ Fτ (Π) be the function such that A is a model of ψΠ f(ii) LetA(cid:7)A(cid:7)A( A, cm(cid:7) , R1 , . . . , c1 , . . . , RWe can see that A(cid:7)An ) be the structure of τ (Π f ), where cis an answer set of Π f . Π fA(cid:7)i∧ Σuna(τ (Π f )) by noticing that A(cid:7)c∈τ (Π)( f (c) = c) is also a formula of vocabulary of τ (Π), so A is a model of ψΠ fis also a loop-separable program, and is definedis model of Σuna(τ (Π f )). Notice that∧ Σuna(τ (Π f )) ∧is a model of ψΠ fc∈τ (Π)( f (c) = c). Let A(cid:7) =for each constant ci in vocabulary τ (Π f ).is a model of Σuna(Π f ) and ψΠ f , so it is an answer set of Π f , and thus A is an answer set of Π . (cid:2)∧ Σuna(τ (Π f )) ∧= f (ci)A(cid:7)(cid:2)A1A(cid:7)iA= c2 , where c1 and c2 are constants in τ (Π).= f (ci)A. From the definition offor 1 (cid:2) i (cid:2) m(cid:7)Finally, Theorem 2 follows from Lemma 5 and Proposition 14.Proof of Theorem 2. Lemma 5 shows that a loop-separable program is first-order definable under UNA, and Proposition 14shows that it is also first-order definable without the restriction of Σuna. (cid:2)6. Subclasses and related resultsWe identify some interesting subclasses of loop-separable program, and show some related results.6.1. Programs with a finite complete set of loopsWe show here that the set of programs with a finite complete set of loops is a subset of loop-separable programs.Proposition 15. If program Π has a finite complete set of loops, then Π is a loop-separable program.Proof. By Theorem 2 in [4], a program Π has a finite complete set of loops, if and only if for every loop L and two atomsα, β ∈ L, Var(α) = Var(β).Let (α1, ρ1), . . . , (αm, ρm) be a loop pattern. We show first that for every 1 (cid:2) i < j (cid:2) m, Var(αi) = Var(α j). Otherwise,assume that Var(αi) (cid:3)= Var(α j) for some 1 (cid:2) i < j (cid:2) m. Let x/ y be the witness of (α1, ρ1) ∼ (αm, ρm), θ = x/ y ∪ y/x, andL = {α1, . . . , αm} be a set of atoms. We can see that L ∪ Lθ is a loop of Π by noticing that αm = α1θ and α1 = αmθ . We stillhave {αi, α j} ⊆ L ∪ Lθ and Var(αi) (cid:3)= Var(α j), which contradicts to Theorem 2 in [4].Thus, for every rule ρi (1 (cid:2) i (cid:2) m), ρi can be separated into two parts: Bh = ∅ and Bb = Body(ρi). (cid:2)Example 10. We continue with the program Π2 in Example 2. Now we consider Π2 as a loop-separable program. Forintensional predicate P , we need to consider the following two expansion trees:(cid:4)(cid:4)(cid:7)P ( y), r3(x/ y)(cid:7)P ( y), r1(x/ y),−T 1:T 2:(cid:4)(cid:7)Q ( y), r4(x/ y)and for Q , the following two expansion trees:(cid:4)(cid:4)(cid:7)Q ( y), r4(x/ y)(cid:7)Q ( y), r2(x/ y),−T 3:T 4:(cid:4)(cid:7)P ( y), r3(x/ y).Thus, Π2 is defined by the conjunction of (cid:15)Π2 and(cid:7)(cid:7)(cid:7)(cid:4)(cid:4)(cid:4)∀ y∀ y(cid:4)P ( y) ⊃Q ( y) ⊃R3( y) ∨(cid:4)R4( y) ∨R2( y) ∧ R4( y)(cid:4)R1( y) ∧ R3( y),(cid:7)(cid:7)(cid:7).As we can see, a program with a finite complete set of loops can be defined by using loop formulas or by using expansiontrees, and the formulas obtained by these two ways are quite different.6.2. Separable on rulesY. Chen et al. / Artificial Intelligence 175 (2011) 890–913911It is obvious that “loop-separable” is not a modular property. Program Π ∪ Π (cid:7)is possibly not loop-separable program,are loop-separable programs. However, if we consider the “separable” property on each rulewhen both programs Π and Π (cid:7)of a program, we can specify a subclass of loop-separable programs.A program Π is rule-separable if for every rule r ∈ Π , Body(r) can be separated into two parts Bh and Bb such thatVar(Bh) ⊆ Var(Head(r)) and Var(Bb) ∩ Var(Head(r)) = ∅.Proposition 16. A rule-separable program is loop-separable.Proof. Let Π be a rule-separable program, and S = (α1, ρ1), . . . , (αn, ρn) be a loop pattern of Π , then for every ρi(1 (cid:2) i (cid:2) n), Body(ρi) can be separated into two parts Bhi and Bbi such that Var(Bhi ) ⊆ Var(Head(ρi)) and Var(Bbi ) ∩Var(Head(ρi)) = ∅.If there exists 1 (cid:2) i < n such that αi+1 ∈ Bbi , then S is a loop pattern of case 1 in Definition 5.Otherwise, for 1 (cid:2) i < n, we have αi+1 ∈ Bhi . By the definition of rule-separable program, we have Var(αi+1) ⊂ Var(αi)for 1 (cid:2) i < n. By the definition of loop pattern, we have α1 ∼ αn, and Var(α1) = · · · = Var(αn). So, S is a loop pattern ofcase 2 in Definition 5. (cid:2)We can see that if Π and Π (cid:7)A program is called a unary program if it has only unary predicates and no equality (=). The program Π6 in Example 8are two rule-separable programs, then Π ∪ Π (cid:7)is also a rule-separable program.is a unary program.Proposition 17. If Π is a unary program, then Π is rule-separable.Proof. For every rule r ∈ Π , the body of r can be separated into two parts Bh and Bb, where(cid:4)(cid:8)(cid:9)(cid:9) α ∈ Body(r) and Var(α) = VarHead(r)(cid:7)(cid:10),Bh =αand(cid:8)α(cid:9)(cid:9) α ∈ Body(r) and Var(α) (cid:3)= Var(cid:4)Bb =(cid:7)(cid:10)Head(r).(cid:2)By Proposition 17, a unary program is first-order definable. If we consider our definition of answer set as a second-orderformula, then this result is a special case of Theorem 8 in [7] (also see [24]), which shows that any second-order sentencethat only contains unary predicates is always first-order definable.6.3. Separable on loopsIf we replace “loop patterns” by “loops” in Definition 5, we get another subclass of loop-separable program, as shown inthe following proposition.Proposition 18. Let Π be a program. If for each loop L of Π , one of the following holds:(a) for every cycle α1, . . . , αn(= α1) such that {α1, . . . , αn} = L, there is αi (1 (cid:2) i < n) such that for any rule r ∈ Π and substitu-tion θ , if αi = Head(rθ) and αi+1 ∈ Body(rθ), then Body(rθ) can be separated into two parts Bh and Bb, such that:– Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(rθ);– αi+1 ∈ Bb;– Var({αi} ∪ Bh) ∩ Var(Bb) = ∅;(b) for any two atoms and α, β ∈ L, and any rule r ∈ Π and substitution θ , if α = Head(rθ) and β ∈ Body(rθ), then Body(rθ) can beseparated into two parts Bh and Bb, such that:– Bh ∩ Bb = ∅ and Bh ∪ Bb = Body(rθ);– β ∈ Bb;– Var({α} ∪ Bh) ∩ Var(Bb) =α(cid:7)∈L Var(α(cid:7)),(cid:16)then Π is a loop-separable program.Proof. We show this by contradiction. Let Π be not a loop-separable program, and (α1, ρ1), . . . , (αn, ρn) be a loop patternof neither case 1 nor case 2 in Definition 5.Let y/ y(cid:7) be the witness of α1 ∼ αn, and x the tuple of variables in Var(α1) ∩ V ar(αn). We can see thati=1 Var(αi) = xby noticing that we always use new variables for local variables of a rule in derivation path. Let θ = y/ y(cid:7) ∪ y(cid:7)/ y ∪ z/z(cid:7)where z is the tuple of all variables in (α1, ρ1), . . . , (αn, ρn) except variables in x ∪ y ∪ y(cid:7), and z(cid:7) a tuple of new variables.(cid:16)n912Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913We can see that (α1θ, ρ1θ), . . . , (αnθ, ρnθ) is also a loop pattern of neither case 1 nor case 2 in Definition 5. Considerthe set of atoms L = {α1, . . . , αn, α1θ, . . . , αnθ}, we can see that L is a loop by noticing that α1θ = αn, and αnθ = α1.α(cid:7)∈L Var(α(cid:7)) = x, and thus α1, . . . , αn(= α1θ), . . . , αnθ(= α1) is a cycle of neither case (a) nor case (b) inWe also haveProposition 18, which contradicts to the assumption of Π . (cid:2)(cid:16)However, there are loop-separable programs that are not covered by the conditions in Proposition 18.Example 11. Let Π7 be the program:P (x, y) ← Q (u, v),Q (x, y) ← P (u, v).There are two loop patterns of Π7:lp1:lp2:(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:7)P (x1, x2), P (x1, x2) ← Q (x3, x4),(cid:7)Q (x3, x4), Q (x3, x4) ← P (x5, x6)(cid:7)P (x5, x6), P (x5, x6) ← Q (x7, x8),(cid:7)Q (x1, x2), Q (x1, x2) ← P (x3, x4)(cid:7)P (x3, x4), P (x3, x4) ← Q (x5, x6),(cid:7)Q (x5, x6), Q (x5, x6) ← P (x7, x8),,.Both lp1 and lp2 are loop patterns of case 1 in Definition 5, but if we consider loop(cid:10)P (x1, x2), Q (x1, x2), P (x1, x3)L =(cid:8)of program Π7, we can see that L is neither a loop of (a) nor (b) in Proposition 18.Example 11 also shows the reason why we need the notion loop pattern to define the loop-separable program.6.4. Safe programsLee and Meng recently also identified a subclass of first-order definable programs named safe programs [19]. By restrictingto our definition of program, a program Π is safe if for every rule r ∈ Π , every variable occurring in the rule also occurs inPos(r). However, when extensional databases are taken into account, a safe program is not necessarily first-order definable.For instance, the program Π1 in Example 1 is a safe program, and can be proved that it is not first-order definable underour context [5].7. Concluding remarksIn this paper, we have studied a notion of first-order definability for first-order answer set program with extensionaldatabase. Our main contribution is in identifying a non-trivial class of programs that are first-order definable on finitestructures. This class, what we called loop-separable programs, is defined based on a detailed analysis of first-order loops,and contains several other interesting classes of first-order definable programs.As we have mentioned in Section 1, study on first-order definability for answer set programs has an important appli-cation value. In another recent paper [2], we have proposed an approach to implement a first-order ASP solver, where wehave shown that under finite structures, every normal logic program can be translated to a first-order sentence within alarger signature. By developing a proper first-order grounder, we can then further implement an SAT based ASP solver. Whatmakes our results presented in this paper useful is that for loop-separable programs, the translation from the program to afirst-order sentence could be much simpler.One future work is to discover more classes of first-order definable programs, especially those that generalize our classof loop-separable programs. The notion of loops and loop formulas has been extended to disjunctive programs [18,19]. Itcould be interesting to consider whether our result can be extended to disjunctive programs. Another important future workis to study computational properties of loop-separable programs. We proved that the class of loop-separable programs isdecidable. However, in general, deciding whether a program is loop-separable is expensive. It would be interesting to seewhether a non-trivial tractable subclass can be identified.Y. Chen et al. / Artificial Intelligence 175 (2011) 890–913913AcknowledgementsWe thank the reviewers for their valuable comments which have helped us to improve this paper.The first author is supported in part by China NSFC 60703095 and Guangdong GDSF 07300237. The second author issupported in part by China NSFC 60573009 and 60963009 and Hongkong RGC GRF 616909. The third and fourth authorsare supported in part by an Australian Research Council Discovery Grant DP0988396.References[1] M. Ajtai, Y. Gurevich, Datalog vs first-order logic, Journal of Computer and Systems Science 49 (1994) 562–588.[2] V. Asuncion, F. Lin, Y. Zhang, Y. Zhou, Ordered completion for first-order logic programs on finite structures, in: Proceedings of AAAI-2010, 2010, pp.249–254.[3] S. Chaudhuri, M.Y. Vardi, On the equivalence of recursive and nonrecursive datalog programs, in: Proceedings of the 11th ACM SIGACT-SIGMOD-SIGARTSymposium on PODS, 1992, pp. 55–66.[4] Y. Chen, F. Lin, Y. Wang, M. Zhang, First-order loop formulas for normal logic programs, in: Proceedings of the 10th International Conference onPrinciples of Knowledge Representation and Reasoning (KR-2006), 2006, pp. 298–307.[5] Y. Chen, Y. Zhang, Y. Zhou, First-order indefinability of answer set programs on finite structures, in: Proceedings of the 24th AAAI Conference onArtificial Intelligence (AAAI-2010), 2010, pp. 285–290.[6] S.S. Cosmadakis, On the first-order expressibility of recursive queries, in: Proceedings of the 8th ACM SIGACT-SIGMOD-SIGART Symposium on PODS,1989, pp. 311–323.[7] P. Doherty, W. Lukaszewicz, A. Szalas, Computing circumscription revisited: A reduction algorithm, Journal of Automated Reasoning 18 (1997) 297–336.[8] P.M. Dung, K. Kanchanasut, On the generalized predicate completion of non-Horn programs, in: Proceedings of NACLP’89, 1989, pp. 604–625.[9] S. Dworschak, S. Grell, V.J. Nikiforova, T. Schaub, J. Selbig, Modeling biological networks by action languages via answer set programming, Constraints 13(2008) 21–65.[10] T. Eiter, J. Lu, V.S. Subrahmanian, Computing non-ground representations of stable models, in: Proceedings of the 4th International Conference on LogicProgramming and Nonmonotonic Reasoning (LPNMR-1997), 1997, pp. 198–217.[11] T. Eiter, G. Ianni, T. Lukasiewicz, R. Schindlauer, H. Tompits, Combining answer set programming with description logics for the semantic web, ArtificialIntelligence 172 (2008) 1495–1539.[12] E. Erdem, O. Erdem, F. Türe, HAPLO-ASP: Haplotype inference using answer set programming, in: Proceedings of the 10th International Conference onLogic Programming and Nonmonotonic Reasoning (LPNMR-2009), 2009, pp. 573–578.[13] P. Ferraris, J. Lee, V. Lifschitz, A new perspective on stable models, in: Proceedings of the 20th International Joint Conference on Artificial Intelligence(IJCAI-2007), 2007, pp. 372–379.[14] M. Gebser, B. Kaufmann, A. Neumann, T. Schaub, Conflict-driven answer set solving, in: Proceedings of the 20th International Joint Conference onArtificial Intelligence (IJCAI-2007), 2007, pp. 386–392.[15] M. Gelfond, V. Lifschitz, The stable model semantics for logic programming, in: Proceedings of the 5th International Conference and Symposium onLogic Programming, 1988, pp. 1070–1080.[16] G. Gottlob, S. Marcus, A. Nerode, G. Salzer, V.S. Subrahmanian, A non-ground realization of the stable and well-founded semantics, Theoretical Com-puter Science 166 (1996) 221–262.[17] P.G. Kolaitis, Implicit definability on finite structures and unambiguous computations (preliminary report), in: Proceedings of the 5th Annual IEEESymposium on Logic in Computer Science (LICS’90), 1990, pp. 168–180.[18] J. Lee, V. Lifschitz, Loop formulas for disjunctive logic programs, in: Proceedings of the 19th International Conference on Logic Programming (ICLP-2003), 2003, pp. 451–465.[19] J. Lee, Y. Meng, On loop formulas with variables, in: Proceedings of the 11th International Conference on Principles of Knowledge Representation andReasoning (KR-2008), 2008, pp. 444–453.[20] N. Leone, G. Pfeifer, W. Faber, T. Eiter, G. Gottlob, S. Perri, F. Scarcello, The DLV system for knowledge representation and reasoning, ACM Transactionson Computational Logic 7 (2006) 499–562.[21] F. Lin, A study of nonmonotonic reasoning, PhD thesis, Stanford University, 1991.[22] F. Lin, Y. Zhao, ASSAT: Computing answer sets of a logic program by SAT solvers, Artificial Intelligence 157 (2004) 115–137.[23] F. Lin, Y. Zhou, From answer set logic programming to circumscription via logic of GK, in: Proceedings of the 20th International Joint Conference onArtificial Intelligence (IJCAI-2007), 2007, pp. 441–446.[24] L. Löwenheim, Über Möglichkeiten im Relativekalkül, Mathematische Annalen (1915) 137–148.[25] D. Pearce, A. Valverde, Quantified equilibrium logic and foundations for answer set programs, in: Proceedings of the 24th International Conference onLogic Programming (ICLP-2008), 2008, pp. 546–560.[26] N. Pelov, M. Denecker, M. Bruynooghe, Well-founded and stable semantics of logic programs with aggregates, Theory and Practice of Logic Program-ming 7 (2007) 301–353.[27] A. Polleres, From SPARQL to rules (and back), in: Proceedings of the 16th International Conference on World Wide Web (WWW-2007), 2007, pp.787–796.[28] T. Syrjänen, I. Niemelä, The smodels system, in: Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning(LPNMR-2001), 2001, pp. 434–438.[29] N. Tran, C. Baral, Hypothesizing about signaling networks, Journal of Applied Logic 7 (2009) 253–274.[30] M.H. van Emden, R.A. Kowalski, The semantics of predicate logic as a programming language, Journal of ACM 23 (1976) 733–742.