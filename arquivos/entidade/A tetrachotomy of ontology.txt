Artificial Intelligence 309 (2022) 103738Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintA tetrachotomy of ontology-mediated queries with a covering axiomOlga Gerasimova a, Stanislav Kikot b, Agi Kurucz c,∗Michael Zakharyaschev ea HSE University, Moscow, Russiab Institute for Information Transmission Problems, Moscow, Russiac Department of Informatics, King’s College London, UKd Steklov Mathematical Institute, Moscow, Russiae Department of Computer Science and Information Systems, Birkbeck, University of London, UK, Vladimir Podolskii d,a, a r t i c l e i n f oa b s t r a c tArticle history:Received 19 July 2020Received in revised form 4 May 2022Accepted 5 May 2022Available online 13 May 2022Keywords:Ontology-mediated queryDescription logicDatalogDisjunctive datalogFirst-order rewritabilityData complexityOur concern is the problem of efficiently determining the data complexity of answering queries mediated by description logic ontologies and constructing their optimal rewritings to standard database queries. Originated in ontology-based data access and datalog optimisation, this problem is known to be computationally very complex in general, with no explicit syntactic characterisations available. In this article, aiming to understand the fundamental roots of this difficulty, we strip the problem to the bare bones and focus on Boolean conjunctive queries mediated by a simple covering axiom stating that one class is covered by the union of two other classes. We show that, on the one hand, these rudimentary ontology-mediated queries, called disjunctive sirups (or d-sirups), capture many features and difficulties of the general case. For example, answering d-sirups is (cid:2)p2 -complete for combined complexity and can be in AC0 or L-, NL-, P-, or coNP-complete for data complexity (with the problem of recognising FO-rewritability of d-sirups being 2ExpTime-hard); some d-sirups only have exponential-size resolution proofs, some only double-exponential-size positive existential FO-rewritings and single-exponential-size nonrecursive datalog rewritings. On the other hand, we prove a few partial sufficient and necessary conditions of FO- and (symmetric/linear-) datalog rewritability of d-sirups. Our main technical result is a complete and transparent syntactic AC0/NL/P/coNP tetrachotomy of d-sirups with disjoint covering classes and a path-shaped Boolean conjunctive query. To obtain this tetrachotomy, we develop new techniques for establishing P- and coNP-hardness of answering non-Horn ontology-mediated queries as well as showing that they can be answered in NL.© 2022 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).* Corresponding author.(V. Podolskii), michael@dcs.bbk.ac.uk (M. Zakharyaschev).E-mail addresses: ogerasimova@hse.ru (O. Gerasimova), staskikotx@gmail.com (S. Kikot), agi.kurucz@kcl.ac.uk (A. Kurucz), podolskii@mi.ras.ruhttps://doi.org/10.1016/j.artint.2022.1037380004-3702/© 2022 The Author(s). Published by Elsevier B.V. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 1037381. Introduction1.1. The ultimate questionThe general research problem we are concerned with in this article can be formulated as follows: for any given ontology-mediated query (OMQ, for short) Q = (O, q) with a description logic ontology O and a conjunctive query q,(data complexity) determine the computational complexity of answering Q over any input data instance A under the open (rewritability) reduce the task of finding certain answers to Q over any input A to the task of evaluating a conventional is then called a rewriting of the OMQ with optimal data complexity directly over A (the query Q(cid:3)(cid:3)world semantics and, if possible,database query QQ ).Ontology-based data access Answering queries mediated by a description logic (DL) ontology has been known as an im-portant reasoning problem in knowledge representation since the early 1990s [1]. The proliferation of DLs and their applications [2,3], the development of the (DL-underpinned) Web Ontology Language OWL,1 and especially the paradigm of ontology-based data access (OBDA) [4–6] (proposed in the mid 2000s and recently rebranded to the virtual knowledge graph (VKG) paradigm [7]), have made theory and practice of answering ontology-mediated queries (OMQs) a hot research area lying at the crossroads of Knowledge Representation and Reasoning, Semantic Technologies and the Semantic Web, Knowledge Graphs, and Database Theory and Technologies.In a nutshell, the idea underlying OBDA is as follows. The users of an OBDA system (such as Mastro2 or Ontop3) may assume that the data they want to query is given in the form of a directed graph whose nodes are labelled with concepts (unary predicates or classes) and whose edges are labelled with roles (binary predicates or properties)—even though, in reality, the data can be physically stored in different and possibly heterogeneous data sources—hence the moniker VKG. The concept and role labels come from an ontology, designed by a domain expert, and should be familiar to the intended users who, on the other hand, do not have to know anything about the real data sources. Apart from providing a user-friendly vocabulary for queries and a high-level conceptual view of the data, an important role of the ontology is to enrich possibly incomplete data with background knowledge. To illustrate, imagine that we are interested in the life of ‘scientists’ and would like to satisfy our curiosity by querying the data available on the Web (it may come from the universities’ databases, publishing companies, personal web pages, social networks, etc.). An ontology O about scientists, provided by an OBDA system, might contain the following ‘axioms’ (given, for readability, both as DL concept inclusions and first-order sentences):BritishScientist (cid:4) ∃ affiliatedWith.UniversityInUK∀x [BritishScientist(x) → ∃ y (affiliatedWith(x, y) ∧ UniversityInUK( y))]∃ worksOnProject (cid:4) Scientist∀x [∃ y worksOnProject(x, y) → Scientist(x)]Scientist (cid:9) ∃ affiliatedWith.UniversityInUK (cid:4) BritishScientist∀x [(Scientist(x) ∧ ∃ y (affiliatedWith(x, y) ∧ UniversityInUK( y))) → BritishScientist(x)]BritishScientist (cid:4) Brexiteer (cid:10) Remainer∀x [BritishScientist(x) → (Brexiteer(x) ∨ Remainer(x))]Now, to find, for example, British scientists, we could execute a simple OMQ Q (x) = (O, q(x)) with the query(1)(2)(3)(4)q(x) = BritishScientist(x)mediated by the ontology O. The OBDA system is expected to return the members of the concept BritishScientist that are extracted from the original datasets by ‘mappings’ (database queries connecting the data with the ontology vocabulary and virtually populating its concepts and roles) and also deduced from the data and axioms in O such as (3). It is this latter reasoning task that makes OMQ answering non-trivial and potentially intractable both in practice and from the complexity-theoretic point of view.1 https://www.w3 .org /TR /owl2 -overview/.2 https://www.obdasystems .com.3 https://ontopic .biz.2O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Uniform approach To ensure theoretical and practical tractability, the OBDA paradigm presupposes that the users’ OMQs are reformulated—or rewritten—by the OBDA system into conventional database queries over the original data sources, which have proved to be quite efficiently evaluated by the existing database management systems. Whether or not such a rewriting is possible and into which query language naturally depends on the OMQ in question. One way to uniformlyguarantee the desired rewritability is to delimit the language for OMQ ontologies and queries. Thus, the DL-Lite family of description logics [5] and the OWL 2 QL profile4 of OWL 2 were designed so as to guarantee rewritability of all OMQs with a DL-Lite ontology and a conjunctive query (CQ) into first-order (FO) queries, that is, essentially SQL queries [8]. In complexity-theoretic terms, FO-rewritability of an OMQ means that it can be answered in LogTime uniform AC0, one of the smallest complexity classes [9]. In our example above, only axioms (1) and (2) are allowed by OWL 2 QL. Various dialects of tuple-generating dependencies (tgds), aka datalogor existential rules, that admit FO-rewritability and extend OWL 2 QLhave also been identified; see, e.g., [10–13].±Any OMQ with an EL, OWL 2 EL or HornSHIQ ontology is datalog-rewritable [14–17], and so can be answered inP—polynomial time in the size of data—using various datalog engines, say GraphDB,5 LogicBlox6 or RDFox.7 Axioms (1)–(3)are admitted by the EL syntax. On the other hand, OMQs with an ALC (a notational variant of the multimodal logicKn [18]) ontology and a CQ are in general coNP-complete [1], and so often regarded as intractable and not suitable for OBDA, though they can be rewritten to disjunctive datalog [19–21] supported by systems such as DLV8 or clasp.9 For example, coNP-complete is the OMQ ({(4)}, q1) with the CQ= ∃w, x, y, z [Brexiteer(w) ∧ hasCoAuthor(w, x) ∧ Remainer(x) ∧q1hasCoAuthor(x, y) ∧ Brexiteer( y) ∧ hasCoAuthor( y, z) ∧ Remainer(z)](see also the representation of q1 as a labelled graph below). It might be of interest to note that by making the role hasCoAuthor symmetric using, for example, the role inclusion axiomhasCoAuthor (cid:4) hasCoAuthor−∀x, y [hasCoAuthor(x, y) → hasCoAuthor( y, x)](5)we obtain the OMQ ({(4), (5)}, q1), which is rewritable to a symmetric datalog query, and so can be answered by a highly parallelisable algorithm in the complexity class L (logarithmic space).For various reasons, many existing ontologies do not comply with the restrictions imposed by the standard languages for OBDA. Notable examples include the large-scale medical ontology SNOMED CT,10 which is mostly but not entirely in EL, and the oil and gas NPD FactPages11 ontology and the Subsurface Exploration Ontology [22], both of which fall outside OWL 2 QLby a whisker, in particular because of covering axioms like (4) that are quite typical in conceptual modelling. One way to (partially) resolve this issue is to compute an approximation of a given ontology within the required ontology language, which is an interesting and challenging reasoning problem by itself; see, e.g., [23–26] and references therein. In practice, the non-complying axioms are often simply omitted from the ontology in the hope that not too many answers to OMQs will be lost. An attempt to figure out whether it was indeed the case for the OMQs with the Subsurface Exploration Ontology and geologists’ queries from [22] was the starting point of research that led to this article.Non-uniform approach An ideal alternative to the uniform approach to OBDA discussed above would be to admit OMQs in a sufficiently expressive language and supply the OBDA system with an algorithm that recognises the data complexity of each given OMQ and rewrites it to a database query in the corresponding target language. For example, while answering the OMQ ({(4)}, q1) is coNP-complete, we shall see later on in this paper that ({(4)}, q2) with the same ontology and the CQ q2 shown in the picture below is P-complete and datalog-rewritable, ({(4)}, q3) is NL- (non-deterministic logarithmic space) complete and linear-datalog-rewritable, ({(4)}, q4) is L-complete and symmetric-datalog-rewritable, while ({(4)}, q5)is in AC0 and FO-rewritable. In the picture, F (u) stands for Brexiteer(u), T (u) forq1FwRTxFyRTzRq2TxTySRFz4 https://www.w3 .org /TR /owl2 -profiles/.5 https://graphdb .ontotext .com.6 https://developer.logicblox .com.7 https://www.oxfordsemantic .tech.8 http://www.dlvsystem .com.9 https://potassco .org /clasp/.10 https://bioportal .bioontology.org /ontologies /SNOMEDCT.11 https://factpages .npd .no.3O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738q3TxTyRFzRq4xSTyRFzq5TxRyRF TzRemainer(u), R(u, v) for hasCoAuthor(u, v), S(u, v) for hasBoss(x, y), and all of the variables w, x, y, z are assumed to be existentially quantified. Another example is the experiments with the NPD FactPages and Subsurface Exploration ontologies used for testing OBDA in industry [15,22,27]. Although the ontologies contain covering axioms of the form A (cid:4) B 1 (cid:10) · · · (cid:10) Bnnot allowed in OWL 2 QL, one can show that the concrete queries provided by the end-users do not ‘feel’ those dangerous axioms and are FO-rewritable. Note also the experiments in [28] showing that rewriting non-Horn OMQs to datalog can significantly improve the efficiency of answering by means of existing engines.Is it possible to efficiently recognise the data complexity of answering any given OMQ and construct its optimal rewrit-ing? The database community has been investigating these questions in the context of datalog optimisation since the 1980s; see Section 1.3 for details and references. For various families of DLs, a complexity-theoretic analysis of the (data complex-ity) problem was launched by Lutz and Wolter [29] and Bienvenu et al. [30]. Incidentally, the latter discovered a close connection with another important and rapidly growing area of Computer Science and AI: constraint satisfaction problems (CSPs), for which a P/NP-dichotomy, conjectured by Feder and Vardi [31], has recently been established [32,33]. We briefly survey the current state of the art in Section 1.3 below. Here, it suffices to say that recognising FO-rewritability is ExpTime-complete for OMQs with a ‘lightweight’ EL ontology [34,35] and 2NExpTime-complete for OMQs with a ‘full-fledged’ ALContology [36]. In either case, the problem seems to be too complex for a universal algorithmic solution, although experi-ments in [37] demonstrated that many real-life atomic OMQs in EL can be efficiently rewritten to non-recursive datalog by the ExpTime algorithm.A more practical take on the (rewritability) problem, started by Motik [19], exploits the datalog connection mentioned above. In a nutshell, the idea is as follows. OMQs with a Horn DL ontology are rewritten to datalog queries, which could further be treated by the datalog optimisation techniques for removing or linearising recursion or partial FO-rewriting algorithms such as [38]. Non-Horn OMQs are transformed to (possibly exponential-size [20]) disjunctive datalog queries to which partial datalog rewriting algorithms such as the ones in [28] can be applied. It is to be emphasised, however, that tractable datalog optimisation and rewriting techniques cannot be complete.In this article, we propose to approach the ultimate question from a different, bottom-up direction. In order to see the wood for the trees, we isolate some major sources of difficulty with (data complexity) and (rewritability) within a syntactically simple yet highly non-trivial class of OMQs. Apart from unearthing the fundamental roots of high complexity, this will allow us to obtain explicit syntactic rewritability conditions and even complete classifications of OMQs according to their data complexity and rewritability type. (Note that similar approaches were taken for analysing datalog programs and CSPs; see Sections 1.2 and 1.3.)1.2. Our contributionWe investigate the (data complexity) and (rewritability) problems for OMQs Q of a very simple form:(d-sirup) Q = (cov A, q), where cov A = { A (cid:4) F (cid:10) T } and q is a Boolean CQ with unary predicates F , T and arbitrary binary predicates.Our ultimate aim is to understand how the interplay between the covering axiom A (cid:4) F (cid:10) T and the structure of q determines the complexity and rewritability properties of Q . By regarding q and data instances as labelled directed graphs (like in the picture above), we can formulate the problem of answering Q in plain graph-theoretic terms:Instance: any labelled directed graph (digraph, for short) A;Problem: decide whether each digraph obtained by labelling every A-node in A with either F or T contains a homomor-phic image of q (in which case the certain answer to Q over A is ‘yes’).By definition (see, e.g., [39]), this can be done in coNP as q is fixed, and so the existence of a homomorphism from q to any labelling of A can be checked in polynomial time by inspecting all possible |A||q|-many maps from q to A. In practice, we could try to solve this problem using, say, a resolution-based prover (see Example 2) or by evaluating the disjunctive datalog program {(6), (7)} below over A, both of which would require finding proofs of exponential size in general (see Theorem 3). The (data complexity) and (rewritability) problems ask whether there exists a more efficient algorithmic solution for the given Q in principle and whether it can be realised as a standard (linear, symmetric) datalog or FO-query evaluated over the input graphs A.The OMQ Q = (cov A, q) is equivalent to the monadic disjunctive datalog queryT (x) ∨ F (x) ← A(x)G ← q4(6)(7)O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738with a nullary goal predicate G . In the 1980s, trying to understand boundedness (FO-rewritability) and linearisability (linear-datalog-rewritability) of datalog queries, the database community introduced the notion of sirup—standing for ‘datalog query with a single recursive rule’ [40–42]—which was thought to be crucial for understanding datalog recursion and optimising datalog programs [43, Problem 4.2.10]. Our OMQs Q or disjunctive datalog queries ({(6), (7)}, G)—which henceforth are referred to as (monadic) disjunctive sirups or simply d-sirups—play the same fundamental role for understanding OMQs with expressive ontologies and monadic disjunctive datalog queries.Looking pretty trivial syntactically, d-sirups form a very sophisticated class of OMQs. For example, deciding FO-rewritability of d-sirups (even those of them that are equivalent to monadic datalog sirups) turns out to be 2ExpTime-hard [44]—as complex as deciding program boundedness of arbitrary monadic datalog programs [45,46]. Interestingly, one of the sources of this unexpectedly high complexity is ‘twin’ F T -labels of nodes in CQs like q5 above. We can eliminate this source by imposing the standard disjointness constraint F (cid:9) T (cid:4) ⊥ (or ⊥ ← F (x), T (x) in datalog parlance), often used in ontologies and conceptual modelling. Thus, we arrive to dd-sirups of the form(dd-sirup) Q = (cov⊥⊥A , q), where covA= { A (cid:4) F (cid:10) T , F (cid:9) T (cid:4) ⊥ }.The complexity and rewritability of both d- and dd-sirups only depend on the structure of the CQs q, which suggests a research programme of classifying (d)d-sirups by the type of the graph underlying q—directed path, tree, their undirected variants, etc.—and characterising the data complexity and rewritability of OMQs in the resulting classes. Thus, in the context of datalog sirups, Afrati and Papadimitriou [47] gave a complete characterisation of binary chain sirups that are computable in NC, and so parallelisable. Actually, according to [47], Kanellakis and Papadimitriou ‘have investigated the case of unary sirups, and have made progress towards a complete characterization’. Unfortunately, that work has never been published.12(As shown later on in this article and [44], unary datalog sirups are closely connected to d-sirups.)The main achievement of this article is a complete characterisation of dd-sirups with a path-shaped CQ (like q1–q3 and q5 above). Syntactically, the obtained characterisation, a tetrachotomy, is transparent and easily checkable: for any dd-sirup ⊥Q = (covA , q) with a path-shaped CQ q,(AC0) Q is FO-rewritable and can be answered in AC0 iff q contains an F T -twin or has no F -nodes or no T -nodes;otherwise,(NL) Q is linear-datalog-rewritable and answering it is NL-complete if q is a ‘periodic’ CQ with a single F -node or a single T -node;(P) Q is datalog-rewritable and answering it is P-complete if q is an ‘aperiodic’ CQ with a single F - or T -node;(CONP) answering Q is coNP-complete if q has at least two F -nodes and at least two T -nodes.(Assuming that NL (cid:14)= P (cid:14)= coNP, the three ‘if’ above can be replaced by ‘iff’.) From the technical point of view, however, to establish this first complete syntactic characterisation of OMQs with disjunctive axioms, we require an adaptation of known methods from description logic [34,35] and datalog [45,46] as well as developing novel techniques for proving P-and especially coNP-hardness. As a (cruel) exercise, the reader might be tempted to consider the dd-sirup with q1 above and then permute the F s and T s in it. The known techniques of encoding NP-complete problems such as 2+2CNF or graph ⊥A is not capable of any reasoning bar binary3-colouring in terms of OMQ answering are not applicable in this case as covcase distinction and q1 has only one binary relation. (To compare, the first coNP-hard d-sirup found by Schaerf [1] has five roles that are used to encode clauses and their literals in 2+2-CNFs.) An even harder problem is to find a unified construction for arbitrary path-shaped CQs as different types of them require different treatment.In the remainder of this section, we briefly review the related work. Section 2 contains the necessary Structure of the articlebackground definitions. It also shows (by reduction of the mutilated chessboard problem [48,49]) that answering d-sirups using resolution-based provers requires finding proofs of exponential size in general.In Section 3, we make an initial scan of the ‘battleground’ and obtain a few relatively simple complexity and rewritability results for arbitrary (not necessarily path-shaped) d- and dd-sirups. First, we show (by reduction of ∀∃SAT) that answering (d)d-sirups is (cid:2)p2 -complete for combined complexity (in the size of q and A), that is, harder than answering DL-Lite and ELOMQs [50,15] (unless NP = (cid:2)p2 , and so NP = PSpace). This result is an improvement on (cid:2)p2 -hardness of answering OMQs with a Schema .org ontology [51], which are more expressive than (d)d-sirups. Then we start classifying d-sirups in terms of occurrences of F and T in the CQs q. Those without occurrences of a solitary F (like q5) or a solitary T are readily seen to be FO-rewritable. All other twinless d-sirups are shown to be L-hard, with certain symmetric d-sirups with one solitary F and one solitary T being rewritable to symmetric datalog, and so L-complete. D-sirups with a single solitary F or a single solitary T (and possibly with twins) are shown to be rewritable to monadic datalog queries (which also 12 https://en .wikipedia .org /wiki /Paris _Kanellakis.5O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738follows from [28]). This observation allows us to use datalog expansions [52] (called cactuses in our context) and automata-theoretic techniques [45] to analyse FO- and linear-datalog-rewritability of the corresponding d-sirups. In [44], we used the criterion of FO-rewritability in terms of cactuses to prove that deciding FO-rewritability of d-sirups with a single solitary F or T as well as that of monadic datalog sirups is 2ExpTime-complete. Here, we show that nonrecursive datalog, positive existential and UCQ-rewritings of such d-sirups are of at least single-, double- and triple-exponential size in the worst case, respectively.As far as we are aware, there is no known semantic or syntactic criterion distinguishing between datalog programs in NLand P, though Lutz and Sabellek [34,35] gave a nice semantic characterisation of OMQs with an EL ontology. In Section 4, we combine their ideas with the automata-theoretic technique of Cosmadakis et al. [45] and prove a useful graph-theoretic sufficient condition for d-sirups to be linear-datalog-rewritable (and so in NL). Note that every d-sirup whose CQ q is a ditree with a single solitary F (or T ) at the root can be rewritten to an atomic OMQ in EL, to which the ExpTime-complete trichotomy of [34] is applicable.Finally, in Sections 5 and 6, we obtain the tetrachotomy of the path-shaped dd-sirups discussed above. Items (AC0)and (NL) and the upper bound in (P) follow from the previous sections. By far the hardest part of the tetrachotomy is establishing P- and coNP-hardness. To prove the former, we assemble AND- and OR-gates from copies of a given aperiodic CQ and then use those gates to construct ABoxes that ‘compute’ arbitrary monotone Boolean circuits, which is known to be P-complete. The structure of the gates and circuits is uniform for each type of aperiodicity. In the proof of coNP-hardness, building 3CNFs from copies of a given CQ q is not uniform as various parts of the construction subtly depend on the order of and the distances between the F - and T -nodes in q. We are not aware of any even remotely similar methods in the literature, and believe that our novel ‘bike technique’ can be used for showing coNP-hardness of many other classes of OMQs. (It might be of interest to note that the coNP-hardness result in our tetrachotomy implies completeness of the datalog rewriting algorithm from [28] for path-shaped dd-sirups.)In Section 7, we summarise the obtained results and formulate a few open problems for future research.An extended abstract [53] with some of the results from this article has been presented at the 17th International Con-ference on Principles of Knowledge Representation and Reasoning.1.3. Related workThere have been two big waves of research related to (data complexity) and (rewritability) of ontology-mediated queries. The first one started in the mid 1980s, when the database community was working on optimisation and paralleli-sation of datalog programs, which was hoped to be done by ‘intelligent compilers’ (see, e.g., [54,40,55–59], surveys [43,60]and references therein). One of the fundamental problems considered was to decide whether the depth of recursion re-quired to evaluate a given datalog query could be bounded independently of the input data, which implies FO-rewritability of the datalog query. Boundedness was shown to be decidable in P for some classes of linear programs [61,54], NP-complete for linear monadic and dyadic single rule programs [41], PSpace-complete for linear monadic programs [45,62], and 2ExpTime-complete for arbitrary monadic programs [45,46]; see also [63]. On the other hand, boundedness of linear datalog queries with binary predicates and of ternary linear datalog queries with a single recursive rule was proved to be undecidable [64,65] along with many other semantic properties of datalog programs including linearisability, being in L or being in NC [66]. The computational complexity of evaluating datalog sirups (of arbitrary arity) as well as their descriptive complexity were studied in [42].The second wave was largely caused by the apparent success story of the DL-underpinned Web Ontology Language OWL and the OBDA paradigm, both in theory and practice. On the one hand, as we mentioned earlier, large families of DLs that guarantee FO-rewritability [5,67] (the DL-Lite-family) and datalog-rewritability [68–70] (the EL-family) and [14,20] (the Horn DL-family) were designed and investigated. Other types of rule-based languages with FO-rewritability have also been identified [71,72,11–13]. On the other hand, various methods for rewriting expressive OMQs to (disjunctive) datalog were suggested and implemented [16,17,73,28,74,75]. For example, the PAGOdA system combines the datalog reasoner RDFox and the OWL 2 reasoner HermiT [24]. A partial FO-rewriting algorithm for OMQs with an ELU ontology (allowing disjunction in EL) and an atomic query was suggested in [38], and a sound and complete but not necessarily terminating algorithm for OMQs with existential rules in [13].Complexity-theoretic investigations of the (data complexity) and (rewritability) problems for DL OMQs fall into two categories depending on whether the ontology language is Horn or not. FO-rewritability of OMQs with an ontology given in a Horn DL between EL and HornSHIF was studied in [76,37,77], which provided semantic characterisations and estab-lished, using automata-theoretic techniques, the complexity of deciding FO-rewritability ranging from ExpTime via NExpTimeto 2ExpTime. A complete characterisation of OMQs with an EL-ontology was obtained in [34,35], establishing an AC0/NL/P data complexity trichotomy, which corresponds to an FO-/linear-datalog-/datalog-rewritability trichotomy. Deciding this trichotomy was shown to be ExpTime-complete. FO-rewritability of OMQs whose ontology is a set of (frontier-)guarded existential rules was investigated in [78].For non-Horn ontology languages (allowing disjunctive axioms), a crucial step in understanding (data complexity) and(rewritability) was the discovery in [30,36] of a connection between OMQs and non-uniform constraint satisfaction prob-lems (CSPs) with a fixed template via MMSNP of [31]. It was used to show that deciding FO- and datalog-rewritability of OMQs with an ontology in any DL between ALC and SHIU and an atomic query is NExpTime-complete. The Feder-Vardi 6O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738dichotomy of CSPs [32,33] implies a P/coNP dichotomy of such OMQs, which is decidable in NExpTime. For monadic disjunc-tive datalog and OMQs with an ALCI ontology (that is, ALC with inverse roles) and a CQ, deciding FO-rewritability rises and becomes 2NExpTime-complete; deciding whether such an OMQ is rewritable to monadic datalog is between 2NExpTimeand 3NExpTime [79,36]. Deciding FO-rewritability of OMQs with a Schema.org13 ontology (which admits inclusions between concept and role names as well as covering axioms for role domains and ranges) and a union of CQs (UCQ) is PSpace-hard; for acyclic UCQs, it can be done in NExpTime [51]. The data complexity and rewritability of OMQs whose ontology is given in the guarded fragment of first-order logic were considered in [80].Despite the discovery of general algebraic, automata- and graph-theoretic and semantic characterisations of data com-plexity and rewritability—which are usually very hard to check—there are very few explicit and easily checkable, possibly partial and applicable to limited OMQ families, sufficient and/or necessary conditions let alone complete classifications. Notable examples include (non-)linearisability conditions for chain datalog queries [81–83], the markability condition of datalog rewritability for disjunctive datalog programs and DL ontologies [28], and explicit NC/P-dichotomy of datalog chain sirups [47]. Classifications and dichotomies of various CSPs have been intensively investigated since Schaefer’s classification theorem [84]; see, e.g., [85–88,32,33] and references therein.The natural idea [30] of translating OMQs to CSPs and then using the algorithms and techniques developed for checking their complexity looks hardly viable in general: for instance, as reported in [89], the Polyanna program [90], designed to check tractability of CSPs, failed to recognise coNP-hardness of the very simple OMQ obtained by swapping the last F - and T -labels in ({(4)}, q1) above because the CSP translation is unavoidably exponential.2. PreliminariesUsing the standard description logic syntax and semantics [3], we consider ontology-mediated queries (OMQs) of the form Q = (O, q), where O is one of the two ontologiescov A = { A (cid:4) F (cid:10) T },cov⊥A= { A (cid:4) F (cid:10) T , F (cid:9) T (cid:4) ⊥ }and q is a Boolean conjunctive query (CQ, for short): an FO-sentence q = ∃x ϕ(x), in which ϕ is a conjunction of (constant-and function-free) atoms with variables from x. We often think of q as the set of its atoms. In the context of this paper, CQs may only contain two unary predicates F , T and arbitrary binary predicates. As in the previous section, OMQs Q = (covA, q)are also called d-sirups and Q = (covOccasionally, we set A = (cid:15), in which case A (cid:4) F (cid:10) T becomes the total covering axiom F (cid:10) T . It is to be noted that this axiom is domain dependent [8], and so regarded to be unsafe and disallowed in disjunctive datalog. In general, answering a d-sirup (cov A, q) could be harder than answering the corresponding OMQ (cov(cid:15), q) as shown by Example 20. We only consider OMQs (cov(cid:15), q) in examples and when proving some lower complexity bounds.⊥A , q) dd-sirups.An ABox (data instance), A, is a finite set of ground atoms with unary or binary predicates. We denote by ind(A) the set of constants (individuals) in A. An interpretation is a structure of the form I = ((cid:4)I, ·I) with a domain (cid:4)I (cid:14)= ∅ and an for any constant a, (cid:15)I = (cid:4)Iinterpretation function ·Ifor any unary predicate P , I ⊆ (cid:4)I × (cid:4)Ifor any binary P . The truth-relation I |= q, for any CQ q, is defined as usual in first-order logic. The and PI = ∅; it is a model of A if P (a) ∈ A implies interpretation I is a model of O if AI ∈ Pand P (a, b) ∈ A implies (aa⊥and, for O = covA , also FI ⊆ FI, b, ⊥I = ∅, Psuch that aI ∪ TI.I ⊆ (cid:4)II ∈ (cid:4)II) ∈ PI ∩ TThe certain answer to an OMQ Q = (O, q) over an ABox A is ‘yes’ if I |= q for all models I of O and A—in which case we write O, A |= q—and ‘no’ otherwise. A model of O and A is minimal if, for each undecided A-individual a, for which A(a)is in A but neither F (a) nor T (a) is, exactly one of aholds. Clearly, O, A |= q iff I |= q for every minimal or amodel I of O and A. So, from now on, ‘model’ always means ‘minimal model’.I ∈ FI ∈ TIIIIIt is often convenient to regard CQs, ABoxes and interpretations as digraphs with labelled edges and partially labelled nodes (by F , T in CQs and F , T , A in ABoxes and interpretations). It is straightforward to see that the truth-relation I |= qis equivalent to the existence of a digraph homomorphism h : q → I preserving the labels of nodes and edges. Without loss of generality, we assume that CQs are connected as undirected graphs. This graph-theoretic perspective allows us to consider special classes of CQs such as tree-shaped CQs, in which the underlying undirected graph is a tree, or ditree-shapedCQs, in which the underlying directed graph is a tree with all edges pointing away from the root, or dag-shaped CQs, which contain no directed cycles, etc. In particular, by a path-shaped CQ q (or path CQ, for short) we mean a (simple) directed path each of whose edges is labelled by one binary predicate. In other words, the binary atoms in q form a sequence R1(x1, x2), R2(x2, x3), . . . , Rn(xn, xn+1), where the xi are all pairwise distinct variables in q (the R i are not necessarily dis-tinct).We illustrate the reasoning required to find the certain answer to a d-sirup over an ABox both on intuitive and formal levels. Our first example shows that, unsurprisingly, answering d-sirups can be done by a plain proof by cases.Example 1. Consider the OMQ Q = (cov(cid:15), q) with A = (cid:15) and the path CQ q shown in the picture below:13 https://schema .org.7O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738TTFSRBy analysing the four possible cases for a, b ∈ FI, Treadily see that each of them contains q as a subgraph, and so the certain answer to Q over this ABox is ‘yes’.in an arbitrary model I of cov(cid:15) and the ABox below, one can IabSRTRFSTTTRSIndeed, if aI ∈ FIf bcase bII ∈ TIII ∈ FI, then q is homomorphically embeddable into the S–R path on the left-hand side of I. Otherwise a. , then q is homomorphically embeddable into the bottom S–R path on the right-hand side of I. In the remaining I ∈ T, there is a homomorphism from q into the S–R path on the top of I.Such proofs can be given as formal resolution refutations (derivations of the empty clause) in clausal logic.Example 2. The certain answer to a d-sirup Q = (cov A, q) over an ABox A is ‘yes’ iff the following set S Q ,A of clauses is unsatisfiable:(cid:2)S Q ,A =¬ A( y) ∨ F ( y) ∨ T ( y),(cid:3)(cid:4)¬P (x)∪ A.P (x)∈q⊥(For a dd-sirup Q = (covA , q), the set S Q ,A also contains the clause ¬F (z) ∨ ¬T (z).) In other words, the certain answer to Q over A is ‘yes’ iff there is a derivation of the empty clause from S Q ,A in classical first-order resolution calculus [91]. By grounding S Q ,A, that is, by uniformly substituting individuals in ind(A) for the variables x, y and z in the first two clauses of S Q ,A, we obtain a set ¯S Q ,A of essentially propositional clauses with | ¯S Q ,A| polynomial in |A|. Again, the certain answer to Q over A is ‘yes’ iff there is a derivation of the empty clause from ¯S Q ,A using propositional resolution. We now show that, in general, such derivations are of exponential size in |A|.Theorem 3. There exist a CQ q and a sequence An, n > 0, of ABoxes such that |An| is polynomial in n and any resolution refutation of S Q ,An or ¯S Q ,An , for Q = (cov A, q), is of size 2(cid:5)(n).Proof. We show that the mutilated chessboard problem can be solved by answering a d-sirup Q over certain ABoxes An. The problem is as follows: given a chessboard of size 2n × 2n, for n > 0, with two white corner squares removed, prove that it cannot be covered by domino tiles (rectangles with two squares). This problem was encoded as a set of propositional clauses of size linear in n [48,49], any resolution proof of which is of size 2(cid:5)(n) [48, Theorem 2.1]. We encode the same problem by the set S Q ,An , for some d-sirup Q = (cov A, q) and ABox An. Since our encoding and the one in [48] are ‘locally’ translatable to each other and in view of [49, Proposition 3.4]), any resolution refutation of S Q ,An or ¯S Q ,An is also of size 2(cid:5)(n).Our CQ q is shown on the left-hand side of Fig. 1. The mutilated 2n × 2n chessboard is turned to an ABox An by replacing each of its squares with the pattern shown in the middle of Fig. 1. The encodings of the different squares are connected via their four contacts, depicted as ◦-nodes. Each of these contacts is labelled by A or F , depending on whether it is in-between two squares, or at the boundary of the board; see the right-hand side of Fig. 1. All of the binary edges in q and An are assumed to be labelled by R. Labels w, x, y, z are just pointers and not parts of q or An.We call a model I of cov A and An covering if exactly one contact in the encoding of each square is in T. Covering models are clearly in one-to-one correspondence with domino-coverings (with each contact being in Tiff it is between two squares covered by the same domino). We show that a model I of cov A and An is covering iff I (cid:14)|= q. This implies the correctness of our encoding: the 2n × 2n mutilated chessboard cannot be covered by dominos iff the answer to Q over Anis ‘yes’, that is, there exist resolution refutations of both S Q ,An and ¯S Q ,An .(⇒) If I is covering, then at least one of the four contacts of each square is not labelled by F . Thus, node x of q can be homomorphically mapped only to node w of the encoding of some square, and so y should be mapped to z. But then the two T -nodes in q should be mapped to two different contacts of the same square, contrary to the fact that in covering models only one such contact is labelled by T . Therefore, there is no q → I homomorphism. (⇐) If I is not covering because there is a square none of whose contacts is labelled by T , then by mapping x to z in the encoding of that square we can obtain a q → I homomorphism. And if there is a square such that at least two of its contacts are labelled by T , we can obtain a q → I homomorphism by mapping x to w and y to z. (cid:2)II8O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738qFxFFTyFTAnA/FTA/F(cid:2)zA/FFFFFFAAAAAAAAAFFFAAFTA/FFwFFFig. 1. Encoding the mutilated chessboard problem as S(cov A ,q),An .FAAFAAFFFAAFFAAAFOur concern in the remainder of this article is the combined and data complexity of deciding, for a given (d)d-sirup Q = (O, q) and an ABox A, whether O, A |= q. In the former case, both q and A are regarded as input; in the latter one, q is fixed. It should be clear that (cid:2)pis an upper bound for the combined complexity of our problem, which 2amounts to checking that, for every model I of O and A, there exists a homomorphism q → I, with the latter being NP-complete. For data complexity, when q is fixed, checking the existence of a homomorphism q → I can be done in P, and so the whole problem is in coNP.= coNPNPWe are also interested in various types of rewritability of (d)d-sirups. An OMQ Q = (O, q) is called FO-rewritable if there is an FO-sentence (cid:6) such that O, A |= q iff (cid:6) is true in A given as an FO-structure [9]. In terms of circuit complexity, FO-rewritability is equivalent to answering Q in logtime-uniform AC0 [9].Recall from, say [8], that a datalog program, (cid:2), is a finite set of rules of the form ∀x (γ0 ← γ1 ∧ · · · ∧ γm), where each γiis a (constant- and function-free) atom Q ( y) with y ⊆ x. As usual, we omit ∀x. The atom γ0 is the head of the rule, and γ1, . . . , γm its body. All of the variables in the head must occur in the body. The predicates in the heads of rules are called IDB predicates, the rest EDB predicates. The arity of (cid:2) is the maximum arity of its IDB predicates; 1-ary (cid:2) is called monadic. A datalog query in this article takes the form ((cid:2), G) with a 0-ary (goal) atom G . The answer to ((cid:2), G) over an ABox A is ‘yes’ if G is true in the structure (cid:2)(A) obtained by closing A under the rules in (cid:2), in which case we write (cid:2), A |= G . We call ((cid:2), G) a datalog-rewriting of an OMQ Q = (O, q) in case O, A |= q iff (cid:2), A |= G , for any ABox A containing EDB predicates of (cid:2) only. If Q is datalog-rewritable, then it can be answered in P for data complexity [60].If there is a rewriting of Q to a ((cid:2), G) with a linear program (cid:2), having at most one IDB predicate in the body of each of its rules, then Q can be answered in NL (non-deterministic logarithmic space). The NL upper bound also holds for datalog queries with a linear-stratified program, which is defined as follows. A stratified program [8] is a sequence (cid:2) = ((cid:2)0, . . . , (cid:2)n)of datalog programs, called the strata of (cid:2), such that each predicate in (cid:2) can occur in the head of a rule only in one stratum (cid:2)i and can occur in the body of a rule only in strata (cid:2) j with j ≥ i. If, in addition, the body of each rule in (cid:2) contains at most one occurrence of a head predicate from the same stratum, (cid:2) is called linear-stratified. Every linear-stratified program can be converted to an equivalent linear datalog program [83], and so datalog queries with a linear-stratified program can be answered in NL for data complexity.A linear program (cid:2) is symmetric if, for any recursive rule I(x) ← J ( y) ∧ E(z) in (cid:2) (except the goal rules), where J is an IDB predicate and E(z) is the conjunction of the EDBs of the rule, its symmetric counterpart J ( y) ← I(x) ∧ E(z) is also a rule in (cid:2). It is known (see, e.g., [92]) that symmetric programs can be evaluated in L (deterministic logarithmic space) for data complexity. Thus, if Q is rewritable to a symmetric datalog query, it can be answered in L.The complexity classes we deal with in this article form the chainAC0 (cid:2) L ⊆ NL ⊆ P ⊆ coNP ⊆ (cid:2)p2(whether any of the inclusions ⊆ is strict is a major open problem in complexity theory). The P/NP dichotomy for CSPs [32,33] and the reductions from [30,36] imply that every (d)d-sirup is either in P or coNP-complete. However, as far as we know, at the moment there are no other established dichotomies for OMQs with disjunctive axioms. On the other hand, as mentioned above, OMQ answering in AC0 is equivalent to FO-rewritability, but whether OMQ answering in L (NL or P) implies symmetric-datalog-rewritability (respectively, linear-datalog- or datalog-rewritability) also remains open.3. Initial observationsIn this section, we obtain a number of relatively simple complexity and rewritability results that are applicable to arbi-trary (not necessarily path) d- and dd-sirups.9O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 1037383.1. Combined complexityOur first result pushes to the limit [51, Theorem 5] according to which answering OMQs with a Schema .org ontology is 2 -complete for combined complexity (the hardness proof of that theorem uses an ontology with an enumeration definition (cid:2)pE = {0, 1} and additional concept names, i.e., unary predicates, none of which is available in our case).⊥Theorem 4. (i) Answering d-sirups (covA, q) and dd-sirups (covA , q) is (cid:2)p2 -complete for combined complexity.(ii) Answering d- and dd-sirups with a tree-shaped CQ q is coNP-complete for combined complexity.Proof. As mentioned in Section 2, deciding whether O, A |= q, given a (d)d-sirup Q = (O, q) and an ABox A, can be done by a coNP Turing machine (checking all models I of O and A) with an NP-oracle (checking the existence of a homomorphism h : q → I); for tree-shaped q, a P-oracle is enough (see, e.g., [93] and further references therein). The lower bound in (ii) follows from Theorem 27.For (i), we prove it by reduction of (cid:2)p2 -complete ∀∃3SAT [94]. We remind the reader that a propositional formula ψ(x, y)with tuples x and y of propositional variables is a 3CNF if it is a conjunction of clauses of the form (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3, where each (cid:2)i is a literal (a propositional variable or a negation thereof). The decision problem ∀∃3SAT asks whether the fully quantified propositional formula ϕ = ∀x∃ y ψ(x, y) is true, for any given 3CNF ψ . We may assume that each clause contains each variable at most once. Denote by qϕ the CQ that, for each clause c = (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3 in ψ , contains atoms Rci ), i = 1, 2, 3, with uc= xc if x ∈ x occurs in (cid:2)i ; in the latter case, qϕ also contains T (xc) if i(cid:2)i = x and F (xc) if (cid:2)i = ¬x. For example, clauses c1 = x1 ∨ ¬x2 ∨ y1 and c2 = ¬ y1 ∨ x2 ∨ y2 contribute the following atoms to qϕ := y if y ∈ y occurs in (cid:2)i and ucii (zc, ucTFxc11xc12Txc22Rc11zc1y1zc2Rc22Rc13Rc21Rc12Rc23y2y . Aϕ contains the atoms A(a◦∗For O = cov A , the ABox Aϕ is defined as follows. For x ∈ x, we take individuals ax and, for y ∈ y, individuals b Fx and a∗◦x), for x ∈ x. For each c = (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3, we define a set E c of triples of and bTx ), F (athe above individuals: (e1, e2, e3) ∈ E c iff (i) for i = 1, 2, 3, ei ∈ {a} whenever x ∈ x occurs in (cid:2)i , (ii) for i = 1, 2, 3, ei ∈∗x , or ei = bν{b Fy and the assignment y = ν makes (cid:2)i true. Now, for any c and (e1, e2, e3) in E c , we take a fresh individual dc(e1,e2,e3)—the centre of the pair (cid:6)(cid:5)(e1,e2,e3), ei), i = 1, 2, 3, to Aϕ . To illustrate, for c1 = x1 ∨ ¬x2 ∨ y1, the set E c1c, (e1, e2, e3)) except (acontains all triples of the form (a} whenever y ∈ y occurs in (cid:2)i , and (iii) there is i ∈ {1, 2, 3} such that either ei = a—and add three atoms Rci (dcμ2x2 , bνy1) and gives the following fragment of Aϕ :◦x), T (aμ1x1 , ay , bTy, b Fy1∗x , a◦x1, a◦x2◦xyAa∗x1F Ta◦x1Rc11Rc11Aa∗x2Rc11Rc11Rc12dc1(a∗x1,a∗x2,b Fy1)Rc11dc1(aRc12◦x1,a∗x2,b Fy1)Rc12Rc11dc1(a∗x1,a◦x2,b Fy1)Rc11Rc12dc1(aF Ta◦x2Rc12Rc12∗x1,a◦x2,bTy1)dc1(a◦x1,a◦x2,bTy1)Rc12dc1(a∗x1,a∗x2,bTy1)dc1(a◦x1,a∗x2,bTy1)Rc13Rc13Rc13Rc13Rc13Rc13Rc13b Fy1bTy1⊥For O = covx and aTA , we take aF(i) in the definition of E c with (i)(cid:3)◦x , add the atoms F (aFx , aTxThe number of atoms in Aϕ is polynomial in the size of ϕ.for i = 1, 2, 3, ei ∈ {ax instead of each a∗x , aF} whenever x ∈ x occurs in (cid:2)i .x ), T (aTx ) instead of F (a◦x), T (a◦x), and replace item 10O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Claim 4.1. Suppose a : x → {F , T } is any assignment andAaϕ= Aϕ ∪ { T (a∗x ) | a(x) = F , x ∈ x }.There exists an assignment b : y → {F , T } that makes ψ(a(x), b( y)) true iff Aaϕ∗x ) | a(x) = T , x ∈ x } ∪ { F (a|= qϕ .ii= a= a= a= a= bb( y)y1, ec2, eci ) = ec∗x is labelled by F in Aa3) is in E c . Then we define a map h by taking h(zc) to be the centre of i as follows. We let (i) ec(cid:5)c, (ecCase covA : For any clause c = (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3 in ψ and for any i = 1, 2, 3, we define ec◦x if x ∈ x occurs in (cid:2)i and a makes (cid:2)i false, and (iii) ecProof. (⇒) Suppose b is such that ψ(a(x), b( y)) is true. We need to show that there is a homomorphism h : qϕ → Aaϕ .∗x if x ∈ xif y ∈ y occurs in occurs in (cid:2)i and a makes (cid:2)i true, (ii) ec(cid:6)i(cid:2)i . As ψ(a(x), b( y)) is true, (ec2, ec1, ec3)i . It follows from the construction that h is well-defined and a homomorphism from qϕ to Aϕ with respect to and h(ucthe binary atoms. We show that it preserves the unary atoms as well. Indeed, for each c and each x ∈ x occurring in some ∗literal (cid:2)i in c, there are two cases: (1) If xc is labelled by T in qϕ , then (cid:2)i = x. So if a makes (cid:2)i true, then ecx is labelled by T in Aaϕ . (2) If xc is labelled by F in qϕ , then ◦(cid:2)i = ¬x. So if a makes (cid:2)i true, then ecx is labelled by both iT and F in Aaϕ .Case cov= aFx if (cid:2)i = x for some x ∈ x and a(x) = F , and (ii)(cid:3)(cid:3)x if (cid:2)i = ¬x for some x ∈ x and a(x) = T . Again, we claim that h as defined above preserves the unary atoms. Indeed, ecifor each c and for each x ∈ x occurring in some literal (cid:2)i in c, there are two cases: (1) If xc is labelled by T in qϕ , then (cid:2)i = x. So if a makes (cid:2)i true, then ecx is labelled by T in iAaϕ . And if a makes (cid:2)i false, then eci∗= ax is labelled by T in Aaϕ . (2) If xc is labelled by F in qϕ , then (cid:2)i = ¬x. So if a makes (cid:2)i true, then ecϕ . And if a makes (cid:2)i false, then eci= a◦x is labelled by both T and F in Aaϕ . And if a makes (cid:2)i false, then eciϕ . And if a makes (cid:2)i false, then ecii , we replace (ii) with (ii)(cid:3)⊥A : In the definition of ecϕ . Then, for any y ∈ y, we have h( y) = bνy for some ν ∈ {F , T }. We then set b( y) = ν. We claim that ψ(a(x), b( y)) is true. Indeed, for every clause c = (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3 in ψ , there is (e1, e2, e3) ∈ E c such that h maps the ∗x , for some i ∈ {1, 2, 3}, (e1,e2,e3). If (e1, e2, e3) is in E c because ei = a‘contribution’ of c in qϕ onto the ‘star’ with centre dc∗x in Aax ∈ x, then the label of aϕ is a(x). As h is a homomorphism, the label of xc in qϕ is also a(x), and so a makes c true by the definition of qϕ . And if (e1, e2, e3) is in E c because ei = b, for some i ∈ {1, 2, 3}, y ∈ y with b( y) making (cid:2)i true, then c is clearly true as well. (cid:2)∗x is labelled by F in Aa(⇐) Suppose h : qϕ → Aax is labelled by F in Aaϕ .= aT= aT= aFb( y)y= a= aeciiiFinally, we prove that ϕ is satisfiable iff O, Aϕ |= qϕ iff I |= qϕ for every model I of O and Aϕ . (⇒) Given I, define . Then I = AaIIϕ , and so we are ϕ is a model of O and Aϕ , for every assignment an assignment aI : x → {F , T } by taking aI(x) = T if adone by Claim 4.1. The implication (⇐) also follows from Claim 4.1, as Aaa : x → {F , T }. (cid:2)and aI(x) = F if a∈ F∈ T∗x∗xI3.2. Data complexity: AC0 and LFrom now on, we focus on the data complexity of answering d-sirups (cov A, q) and dd-sirups (cov⊥A , q). We start classi-fying (d)d-sirups in terms of occurrences of F and T in the CQs q. Atoms F (x), T (x) ∈ q, for some variable x, are referred to as F T -twins in q. If q does not contain F T -twins, we call it twinless, and similarly for ABoxes. By a solitary F or T we mean a non-twin F - or, respectively, T -node.Observe that answering (covA, q) is not easier than answering (cov⊥A , q): If a given ABox A contains F T -twins, then there cov A, A |= qis no model of cov⊥A , A |= q. Also,⊥A and A, and so cov⊥A , A |= q,(cid:5)⊥If q contains F T -twins, then ∃x A , q). In general, any rewriting of (cov A, q) can be ⊥converted to a rewriting of (covA , q) into the same language. For example, if ((cid:2), G) is a (symmetric/linear) datalog rewriting of (covA, q), then ((cid:2) ∪ {⊥ ← F (x), T (x)}, G) is a (symmetric/linear) datalog rewriting of (covfor any twinless ABox A.(cid:6)F (x) ∧ T (x)is an FO-rewriting of (covcov(8)iffAiming to identify FO-rewritable (d)d-sirups, we consider first those CQs that do not have a solitary F or a solitary T , calling them 0-CQs. Queries of this type are quite common, only asking about one of the covering predicates (as in ‘are there any undergraduate students who take symbolic AI courses?’ and ‘what about the postgraduate ones?’ provided that students are either undergraduate or postgraduate). The following theorem establishes a complexity dichotomy between 0-CQs and non-0-CQs, which contain occurrences of both covering predicates (as in ‘are there both undergraduate and postgraduate students in the College’s University Challenge team?’).⊥A , q).Theorem 5. (i) If q is a 0-CQ, then both (covA, q) and (covthem.⊥A , q) can be answered in AC0, with q being an FO-rewriting of each of (ii) If q is twinless and contains at least one solitary F and at least one solitary T , then answering (cov(cid:15), q) and (cov(covA, q) and (cov⊥A , q) is L-hard.11⊥(cid:15), q), and so O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738⊥A . We show that O, A |= q iff A |= q, and so q is an FO-rewriting of (O, q). (⇒)Proof. (i) Let O be one of cov A or covSuppose A (cid:14)|= q and q has no solitary F (the other case is similar). Let A(cid:3)be the result of adding a label F to every undecided A-node in A. Clearly, A(cid:3)is a model of O and A with A(cid:3) (cid:14)|= q. (⇐) is trivial.(ii) The proof is by an FO-reduction of the L-complete reachability problem for undirected graphs. Denote by q(cid:3)obtained by gluing together all the T -nodes and by gluing together all the F -nodes in q. Thus, q(cid:3) \ {T (x), F ( y)}.x, and a single F -node, y. Clearly, there is a homomorphism h : q → q. Let q(cid:3)(cid:3) = q(cid:3)the CQ contains a single T -node, (cid:3)such that, in qSuppose G = (V , E) is a graph with s, t ∈ V . We regard G as a directed graph such that (u, v) ∈ E iff (v, u) ∈ E, for any (cid:3)(cid:3)e of (cid:3)(cid:3)e , node x is renamed to u, y to v, and all other nodes z to some fresh copy ze . Then AG comprises all (cid:3)(cid:3)e , for e ∈ E, as well as atoms T (s) and F (t). We show that there is a path from s to t in G (s →G t, in symbols) iff u, v ∈ V . Construct a twinless ABox AG from G in the following way. Replace each edge e = (u, v) ∈ E by a copy q(cid:3)(cid:3)qsuch qcov(cid:15), AG |= q iff cov⊥(cid:15), AG |= q (cf. (8)).(⇒) Suppose there is a path s = v0, . . . , vn = t in G with ei = (vi, vi+1) ∈ E, for i < n. Consider an arbitrary model I of . As cov(cid:15) and AG . Since I |= cov(cid:15), and T (s) and F (t) are in AG , we can find some i < n such that vi ∈ T(cid:3)(cid:3)qeiis an isomorphic copy of q(⇐) Suppose s (cid:14)→G t. Then, by the construction, t is not reachable from s in AG (not even via an undirected path). to be the set of nodes in AG that are reachable from s (via an undirected IDefine a model I of covIpath) and Fnodes. Since q is connected and contains at least one T and at least one F , it follows that I (cid:14)|= q. (cid:2)its complement. Clearly, no connected component of AG (as undirected graph) contains both T⊥(cid:15) and AG by taking T, we obtain I |= q, and so I |= q.and vi+1 ∈ F- and FIIII(cid:3)(cid:3)(cid:3)(cid:3)As AC0 (cid:2) L and ∃x (F (x) ∧ T (x)) is an FO-rewriting of (covand necessary criterion of FO-rewritability for dd-sirups:⊥A , q) in which q contains a twin, Theorem 5 gives a sufficient Corollary 6. A dd-sirup Q = (cov⊥A , q) can be answered in AC0 iff q is a 0-CQ or contains a twin.Characterising FO-rewritable d-sirups with a CQ containing twins turns out to be a much harder problem, which will be discussed in Section 3.4.Example 7. Meanwhile, the reader is invited to show that the d-sirups with the CQs below are FO-rewritable (see also Example 14). Note that each of these CQs is minimal, that is, not equivalent to any of its proper sub-CQs.F TTFF TTF TFRRRSSSRRRRRThe lower bound result in Theorem 5 (ii) is complemented by the following simple sufficient condition. To formulate it, we require non-Boolean CQs q(x) that apart from existentially quantified variables may also contain free variables x(cid:3)(x, y) is symmetric if, for any ABox A and any a, b ∈ ind(A), we have called answer or distinguished variables. Such a CQ qA |= q(cid:3)(b, a), where A is regarded as an FO-structure and |= is the usual first-order truth relation.(cid:3)(a, b) iff A |= qTheorem 8. Let O be one of cov A or cov⊥A and let q be a Boolean CQ that is equivalent to(cid:5)(cid:3)∃x, yF (x) ∧ q(cid:3)1(x), q(cid:3)1(x) ∧ q(cid:3)(x, y) and qwhere (a) CQs qdisjoint, with x and y being their only common variables with qso can be answered in L.(x, y) ∧ q(cid:3)2( y) do not contain solitary T and F , (b) q,(cid:6)(cid:3)2( y) ∧ T ( y)(cid:3)(cid:3)(x, y) is symmetric, and (c) q2( y) are (cid:3)(x, y). Then (O, q) is rewritable to a symmetric datalog program, and (cid:3)1(x) and qProof. Suppose O = cov A . We claim that O, A |= q iff there exist n ≥ 1 and v 0, v 1, . . . , vn ∈ ind(A) such that(S1) F (v 0), A(v 1), . . . , A(vn−1), T (vn) ∈ A,(S2) A |= q(S3) A |= q(S4) A |= q(cid:3)(v i, v i+1), for 0 ≤ i < n,(cid:3)1(v i), for 0 ≤ i < n,(cid:3)2(v i), for 1 ≤ i ≤ n.IIndeed, suppose there are v 0, v 1, . . . , vn ∈ ind(A) such that (S1)–(S4) hold. Consider any model I of O and A. By (S1), . Then (S2)–(S4) guarantee that I |= q. Conversely, suppose O, A |= q for some there is i < n with v i ∈ FAABox A. For P ∈ {F , T , A}, let P, (cid:3)(cid:3)(cid:3)(a, b) ∧ q1(a) ∧ qj=0 F jF(cid:5)(cid:6)(cid:7)∞j(cid:3)A \j for and Tj=1 F jAA = {a ∈ ind(A) | P (a) ∈ A}. Define inductively sets F j and F(cid:3)2(b) for some a ∈ F j} and F j+1 = A. By our assumption, there is a homomorphism h : q → I. Thus, h(x) ∈ F j and h( y) ∈ F(cid:3)j , for j ≥ 0, by setting F 0 = F(cid:7)∞(cid:3)j . Let I be a model of O and A with F= {b | A |= qA ∪I = Tand v i+1 ∈ TA ∩ FI =I12O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Asome j. Then h( y) ∈ Tthen we are done with n = 1. If j > 0 then h(x) ∈ A(cid:3)(vn−2, vn−1) ∧ qqA ∩ F(cid:3)2(vn−1). By iterating this process, we obtain v 0, v 1, . . . , vn ∈ ind(A) as required., for otherwise h( y) ∈ F j+1, contrary to h( y) ∈ T(cid:3)j−1, and so there is vn−2 ∈ F j−1 such that A |= q. Now, let vn−1 = h(x) and vn = h( y). If j = 0(cid:3)1(vn−2) ∧It remains to observe that checking whether there are v 0, v 1, . . . , vn ∈ ind(A) such that (S1)–(S4) hold can be done by Ithe following symmetric datalog program, in which B(x) = A(x) ∧ q(cid:3)1(x) ∧ q(cid:3)2(x):G ← qG ← F (x), qP (x) ← B(x), qP (x) ← B(x), q(x, y), P ( y)(cid:3)(cid:3)1(x), q(cid:3)(x, y), q(cid:3)2( y), T ( y)(x, y), P ( y), B( y)(cid:3)where, by the symmetry of qcounterpart. If O = cov(cid:3)(x, y), the only recursive rule P (x) ← B(x), q(cid:3)(x, y), P ( y), B( y) is equivalent to its symmetric ⊥A , we add the non-recursive rule G ← F (x), T (x) to the program. (cid:2)Example 9. By Theorems 8 and 5 (ii), the d-sirup (cov(cid:15), q) with q shown below is L-complete.FTRSSQQ3.3. Datalog rewritability of d-sirups with a 1-CQIn this section, we introduce a technical tool that can be used to show datalog rewritability of (d)d-sirups whose CQ contains exactly one solitary F and at least one solitary T (or exactly one solitary T and at least one solitary F ). We refer to such CQs as 1-CQs. The tool is an adaptation of the known (disjunctive) datalog technique of expansions [54,45,52]. We use this tool to observe that every (d)d-sirup with a 1-CQ can be rewritten to a very simple datalog query—nearly a sirup in the sense of [40,41], and so can be answered in P. Note that a more general markability technique (tracing dependencies on disjunctive predicates in the program rules) for rewriting disjunctive datalog programs into datalog was developed in [28]. In Section 3.4, we also adapt the datalog expansion technique to characterise FO-rewritability of those datalog queries semantically.Throughout this section, we assume that q is a 1-CQ, with F (x) and T ( y1), . . . , T ( yn) being all of the solitary occurrences ⊥of F and T in q. As before, we let O be one of cov A or covA . For each dd-sirup Q = (O, q), we define a monadic (that is, having at most unary IDB predicates) datalog program (cid:2) Q with nullary goal G and four rulesG ← F (x), q(cid:3), P ( y1), . . . , P ( yn)P (x) ← T (x)P (x) ← A(x), q(cid:3), P ( y1), . . . , P ( yn)(9)(10)(11)G ← F (x), T (x)(12)(cid:3) = q \ {F (x), T ( y1), . . . , T ( yn)} and P is a fresh predicate symbol that never occurs in ABoxes. Thus, the body of where qrule (11) is obtained from q by replacing F (x) with A(x) and each T ( yi) with P ( yi). If O = covA , rule (12) is omitted.We also define by induction a class K Q of ABoxes called cactuses for Q . We start by setting K Q = {q}, regarding q as an ABox, and then recursively apply to K Q the following ‘budding’ rule:(bud) if T ( y) ∈ C ∈ K Q with solitary T ( y), then we add to K Q the ABox obtained by replacing T ( y) in C with the set (q \ {F (x)}) ∪ { A(x)}, in which x is renamed to y and all other variables are given fresh names.It is straightforward to see by structural induction thatO, C |= q,for every C ∈ K Q .(13)For C ∈ K Q , we refer to the copies s of (maximal subsets of) q comprising C as segments. The skeleton Cs of C is the ditree whose nodes are the segments s of C and edges (s, s(cid:3)) mean that s(cid:3)was attached to s by budding. The depth of s in C is the number of edges on the branch from the root of Cs to s. The depth of C is the maximum depth of its segments.Example 10. In the picture below, the cactus C2 is obtained by applying (bud) to the 1-CQ q twice. Its skeleton Csthree segments s0, s1, s2 is shown on the right-hand side of the picture.2 with 13O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738qTy2STy1RFxTs2TSRC2Ay2TSSs0Ay1RFxRTs1Cs2s0s1s2Theorem 11. For any (d)d-sirup Q = (O, q) with a 1-CQ q and any ABox A, the following conditions are equivalent:(i) O, A |= q,(ii) (cid:2) Q , A |= G ,(iii) there exists a homomorphism h : C → A, for some C ∈ K Q , or O = cov⊥A and A contains an F T -twin.Proof. We show the implications (i) ⇒ (ii) ⇒ (iii) ⇒ (i).I⊥A and A contains a node labelled by both T and F , then G holds in the closure (cid:2) Q (A) of A under (i) ⇒ (ii) If O = cov(cid:2) Q by rule (12). In any other case, we define a model I based on A by labelling each ‘undecided’ A-node a by T if P (a)Iholds in (cid:2) Q (A), and by F otherwise. As I is a model of O and A, there is a homomorphism h : q → I. Then h( yi) ∈ T, holds in (cid:2) Q (A), for every i ≤ n (by rule (10) and the definition of I). We claim that h(x) is an F -node in and so P(cid:2) Q (A), and so G holds in (cid:2) Q (A) by rule (9). Indeed, otherwise by h(x) ∈ Fand the definition of I, h(x) is an A-node but not a P -node in (cid:2) Q (A), contrary to rule (11).(cid:6)(cid:5)h( yi)i for i ≤ n. If ya(ii) ⇒ (iii) Suppose O = covA or A does not contain a node labelled by both T and F . Then rule (12) is either not in (cid:2) Q or not used. We define inductively (on the applications of rule (11) in the derivation of G ) a cactus C ∈ K Q and a homomorphism h : C → A. To begin with, there are objects xa, yan for which rule (9) was triggered. Thus, xa is an F -node in (cid:2) Q (A), and so it is an F -node in A. Take a function h0 : q → A that preserves binary predicates, with h0(x) = xai is a T -node in A for every i ≤ n, then h = h0 is the required homomorphism from q ∈ K Q to and h0( yi) = yaA. If yais an A-node in in. Let C be the cactus obtained A. Also, there are xb = yafrom q by budding at yi . We extend h0 to a function h1 : C → A such that it preserves binary predicates and h1( ysj ) = ybj is a T -node in A for every j ≤ n, then h = h1 is the required homomorphism for all T -nodes ysfrom C ∈ K Q to A. Otherwise, we bud C again and repeat the above argument. As the derivation of G from A using (cid:2) Qis finite, sooner or later the procedure stops with a cactus and a homomorphism.is not a T -node in A, for some i, then yaii and ybis a P -node in (cid:2) Q (A) obtained by rule (11), and so yain such that rule (11) was triggered for xb, ybj of the new segment s. If yb⊥A and A contains a node labelled by both T and F , then O, A |= q obviously holds. Otherwise, take (iii) ⇒ (i) If O = covof O and C by ‘pulling back I’ via the homomorphism h: for I+. Thus, the composition of g and h. By (13), there is a homomorphism g : q → I+an arbitrary model I of O and A. We define a model I+every node x in C, x ∈ Ais a q → I homomorphism, as required. (cid:2)iff h(x) ∈ A1, . . . , yb1, . . . , yb1, . . . , yaIjCorollary 12. Any (d)d-sirup (O, q) with a 1-CQ q is datalog-rewritable, and so can be answered in P.As mentioned in the introduction, the problems of FO-rewritability (aka boundedness in the datalog literature) and linear-datalog-rewritability (aka linearisability) of datalog queries have been thoroughly investigated since the 1980s. In Sections 3.4 and 4, we discuss these questions for (d)d-sirups with a 1-CQ.3.4. Deciding FO-rewritability of d- and dd-sirups with a 1-CQA key to understanding FO-rewritability of d- and dd-sirups with a 1-CQ is the following semantic criterion, which is well-known in the datalog setting; see, e.g., [54,45]:Theorem 13. A (d)d-sirup Q = (O, q) with a 1-CQ q is FO-rewritable iff there exists a d < ω such that every cactus C ∈ K Q contains a homomorphic image of some cactus C− ∈ K Q of depth ≤ d, in which case a disjunction of the cactuses of depth ≤ d, regarded as Boolean CQs, is an FO-rewriting of Q .∨ · · · ∨ qn, where the qi are CQs. Treating the Proof. (⇒) By [30, Proposition 5.9], Q has an FO-rewriting of the form q1|= q, and so, by Theorem 11, there is a homomorphism from some Ci ∈ K Q to qi . qi as ABoxes, we obviously have O, qiNow let d be the maximum of the depths of the Ci . Consider any C ∈ K Q of depth > d. Then there are homomorphisms Ci → qi→ C, for some i, 1 ≤ i ≤ n, as required.(⇐) Given d < ω, we take all of the cactuses C1, . . . , Cn of depth ≤ d (up to isomorphism). Now we consider each Cias a CQ. Then C1 ∨ · · · ∨ Cn is an FO-rewriting of Q . Indeed, if O, A |= q then there are homomorphisms Ci → C → A, for some C and i, again by Theorem 11. (cid:2)14O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Example 14. Let Q 1 be the d-sirup with the first CQ from Example 7. It is not hard to verify that every cactus for Q 1contains a homomorphic image of this CQ, which is therefore an FO-rewriting of Q 1. Now, let Q 2 be the d-sirup with the second CQ from Example 7. Let Ck be the cactus obtained by applying (bud) k-times to the original cactus C0 (isomorphic to the given CQ). There are homomorphisms h : C1 → Ck, for k ≥ 2, and so Q 2 is rewritable to C0 ∨ C1.As follows from [45], which considered arbitrary monadic datalog queries, checking the criterion of Theorem 13 can be done in 2ExpTime. A matching lower bound for monadic datalog queries with multiple recursive rules was estab-lished in [46]. It has recently been shown that already deciding FO-rewritability of monadic datalog sirups of the form ({(10), (11)}, P (x)) and also of d-sirups with a 1-CQ is 2ExpTime-hard [44]. Thus, we obtain:Theorem 15 ([45,36,44]). Deciding FO-rewritability of d-sirups can be done in 2NExpTime. Deciding FO-rewritability of d-sirups with a 1-CQ is 2ExpTime-complete. It follows that deciding FO-rewritability of CQs mediated by a Schema .org or DL-Litebool [67] ontology can be done in 2NExpTime, and is 2ExpTime-hard.The exact complexity of deciding FO-rewritability of d-sirups (2NExpTime or 2ExpTime) remains an open problem. An-other important issue for OBDA and datalog optimisation is the succinctness problem for FO-rewritings [95,50]. It is not known if every FO-rewritable d-sirup has a polynomial-size FO-rewriting. However, we can show that this is not the case for the UCQ-, PE- and NDL-rewritings, which are standard in OBDA systems. We remind the reader (see [50] for details and further references) that a UCQ-rewriting takes the form of disjunction (union) of CQs, while a positive existential (PE) rewriting is built from atoms using ∃, ∧ and ∨ in an arbitrary way. A nonrecursive datalog (NDL) rewriting is a datalog query ((cid:2), G) such that the dependency digraph of (cid:2) is acyclic, where a predicate P depends on a predicate Pin (cid:2) if (cid:2) has a clause with P in the head and Pin the body.(cid:3)(cid:3)Theorem 16. There is a sequence of FO-rewritable d-sirups Q nNDL-rewritings of Q n are of at least triple, double and single exponential size in n, respectively.= (cov A, qn) of polynomial size in n > 0 such that any UCQ-, PE- and Proof. Consider an alternating Turing machine (ATM) M n that works as follows on any input of length ≤ n. Its tape of size exponential in n is used as a counter from 0 to 22n. The tape also has two extra cells a and b. M n begins in a ∨-state by writing 0 and 1 in cell a in two alternative branches of the full computation space. Then M n continues, in a ∧-state, by writing 0 and 1 in cell b in two alternative branches of the full computation space. If the bits in a and b in a given branch of the tree are distinct, Mn enters an accepting state. Otherwise, the counter is increased by 1 and the ATM repeats the previous two steps. If the counter exceeds 22n, Mn enters a rejecting state. Thus, Mn rejects every input. Moreover, given any input w, every computation tree of Mn on w contains exactly one rejecting configuration, which is the leaf of a branch of length double-exponential in n.We now use the ATMs M n and any input w of length ≤ n to construct, as described in [44], polynomial-size 1-CQs qn. Then, by the (⇒) direction of [44, Lemma 4], the d-sirups Q n= (cov A, qn) are FO-rewritable. On the other hand, one can show similarly to the proof of the (⇐) direction of [44, Lemma 4] that any computation tree of Mn on w corresponds to a cactus C ∈ K Q n of triple-exponential size in n such that no smaller cactus is homomorphically embeddable to C. It follows that any UCQ-rewritings of Q n must be of at least triple-exponential size.Any PE-rewritings of Q n are of at least double-exponential size. Indeed, given a PE-rewriting in prenex form of size s (the number of atoms in the formula), we can transform its matrix (the quantifier-free part) to DNF and obtain a UCQ rewriting of size ≤ s2s. So if s were sub-double-exponential, then the size of this UCQ-rewriting would be less than triple-exponential. A similar argument shows that it is impossible to obtain NDL-rewritings of subexponential size because otherwise we could transform them to sub-double-exponential PE-rewritings. (cid:2)The proof above does not provide us with any lower bound on the size of FO-rewritings because, by a result of Gurevich and Shelah [96], there is a potentially non-elementary blow-up in length from a homomorphism invariant FO-sentence to its shortest equivalent PE-sentence. We illustrate Theorem 16 by a simple example of an FO-rewritable d-sirup whose UCQ-rewritings are of at least double-exponential size.Example 17. Consider the d-sirups Q non the edges being all R (and r, ai, bi, ci being pointers rather than labels in qn).= (cov A, qn), where qn, for n ≥ 2, is the 1-CQ depicted below, with the omitted labels S. . .cncn−1cn−2c2c1rFQSTa1b1SQTa2b2F Ta3b3a0b015O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738CC1 or a, h(a0) = aC1 , h(ai) = aC2 for j = 0, 1, h(b j) = bC3 for i = 1, 2, 3, h(b j) = bCdenote the copy of x in the root segment of C. Observe that C is of For any cactus C ∈ K Q n and any node x in qn, let xCand has ≥ n A-nodes, the first of which is either adepth ≥ n iff C contains an R-path π that starts at r2 . We show Cfirst that if the depth of C is ≥ n, then there is a homomorphism h : qn1 , then CCwe can define h by taking h(r) = r3 for j = 2, 3, c1, . . . , cn−1 are h-mapped to the next n − 1 A-nodes in π , and h(cn) is the F T -node in the segment with root h(cn−1). (The case when the first A-node of π is aC2 is similar.) So Theorem 13 implies that Q n is FO-rewritable.→ C. Indeed, if the first A-node of π is aOn the other hand, we claim that if C, C(cid:3)are cactuses of depths < n and there is a homomorphism h : C → C(cid:3). We show this by induction on the depth of C (which cannot exceed the depth of C(cid:3)C, then C = C(cid:3)). Observe first that, for any xC(cid:3)CC) = xbecause the F T -node a3 has no S-successors, for a0 because the depth in qn, we must have h(xC(cid:3)C(cid:3)Cof C(cid:3)1 ) (cid:14)= a3 because a0 and a1 have a common successor, 2 because a2 has no Q -predecessor, h(ais less than n, h(aC(cid:3)C) = xfor x = c1, . . . , cn−1, a3. while a0 and a3 do not, we have a similar argument for h(aIt follows that if C = qn then C(cid:3) = qn must also hold, otherwise h does not preserve T . If the depth of C is > 0 then, for i as its root node, and let C−i = 1, 2, let si be the segment in Cs having ai be the ‘subcactus’ of C whose skeleton is the subtree of Cs with root si . We define C(cid:3)similarly. An inspection of qn shows that we must have homomorphisms h1 : C−and h2 : C−and C−→ C(cid:3)by the induction hypothesis (IH). Therefore, 11C = C(cid:3)follows, and so the UCQ rewriting (cid:6)n of Q n provided by Theorem 13 contains all different cactuses of depth < n, O(n)the number of which is 22disjuncts. For otherwise, by in (cid:6)n and C → D and C(cid:3) → D homomorphisms, for some the pigeonhole principle, there exist different disjuncts C and C(cid:3)disjunct D of (cid:6)(cid:3)in (cid:6)n, and so, as shown above, C = C(cid:3) = C(cid:3)(cid:3)Cfrom C(cid:3). Thus, we have C−n. On the other hand, there is a D → C(cid:3)(cid:3)C2 ), and then we clearly have h(x. It follows that any UCQ-rewritings (cid:6)(cid:3)homomorphism, for some disjunct Cn of Q n have at least 22, which is a contradiction.: This holds for rC1 ) (cid:14)= a→ C(cid:3)2= C(cid:3)2= C(cid:3)1One can readily transform (cid:6)n to an equivalent PE-rewriting of exponential size at the expense of nested ∧ and ∨. But, by the proof of Theorem 16, there are no PE-rewritings of subexponential size. On the other hand, the datalog program {(9)–(11)} can be converted to an NDL-program describing cactuses of depth < n and containing O (n) rules.O(n)−−−−−(cid:3)(cid:3)212iFinding an explicit syntactic characterisation of FO-rewritable d-sirups turns out to be nearly as hard as characterising FO-rewritable OMQs in fully-fledged expressive DLs and monadic disjunctive datalog queries. Notice, however, that the 1-CQs used in Example 17 and the construction of [44] (underlying Theorem 16) are quite involved dags with multiple edges and possibly multiple F T -twins. So one could hope that by restricting the shape of CQs and/or by disallowing F T -twins we would obtain less impenetrable yet practically useful classes of d-sirups. Indeed, for d-sirups Q whose 1-CQ is a ditreewith its unique solitary F -node as root, the program (cid:2) Q can be reformulated as an EL-ontology, and so one can use the AC0/NL/P trichotomy of [34,35], which is checkable in ExpTime.Example 18. To illustrate, consider the 1-CQ q below:FF TTRSQWe have covA, A |= q iff E, A |= ∃x B(x), where E is the EL TBox {F (cid:9) Cq (cid:4) B, T (cid:4) P , A (cid:9) Cq (cid:4) P } with Cq = ∃R.(F (cid:9) T (cid:9)∃S.∃Q .P ) and the DL syntax illustrated in terms of first-order logic by (1)–(4) in Section 1.Further, as shown in [44], any d-sirup with a ditree 1-CQ, not necessarily having an F -labelled root, is either FO-rewritable or L-hard, and deciding this dichotomy is fixed-parameter tractable if we regard the number of solitary T -nodes as a parameter. Moreover, for dd-sirups with an arbitrary ditree CQ, there is an explicit syntactic trichotomy: each of them is either FO-rewritable or L-complete, or NL-hard. On the other hand, there is no readily available machinery for explicitly characterising NL-completeness, P- and coNP-hardness of (d)d-sirups (let alone more general types of OMQs). We are going to fill in this gap to some extent in the remainder of the article. To begin with, we combine some ideas from [45,34] to prove a general sufficient condition of linearisability for d-sirups with a 1-CQ.4. Linear-datalog-rewritability of d- and dd-sirups with a 1-CQ⊥We require a few new definitions, assuming as before that O is one of cov A or covA . First, we extend the class K Q of +Qcactuses for any (d)d-sirup Q = (O, q) to a wider class Kas the class of structures obtained from q by recursively applying (bud) and the following ‘pruning’ rule:+Q by adding another inductive rule to its definition. We define K+(prune) if C ∈ KQ and O, C− |= q, where C− = C \ {T ( y)}, for some solitary T ( y) in C, then we add C−to K+Q .is obtaining from C by (prune), we define the skeleton (C−)s of C−If C−cactuses. We write C(cid:3) ⊆ C to say that, when regarded as ABoxes (sets of atoms), the cactus C(cid:3)to be Cs. We continue to call members of K+Qis (isomorphic to) a subset of 16O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738+the cactus C. A cactus C ∈ Kis denoted by KminQ is minimal if, for every C(cid:3) ∈ KQ . It should be clear that (13) holds for Kmin+Qin place of K Q .Q , C(cid:3) ⊆ C implies C(cid:3) = C. The class of minimal cactuses in K+QExample 19. Consider the d-sirup Q = (cov A, q) with q shown on the left-hand side of the picture below (the R-labels on the edges are omitted). The cactus C1 is obtained by budding y1 in q, and C2 is obtained by budding y2 in C1.FqTy1Ty2Ty2FAy1TTC1FAAy1y2C2TTTT1 be the result of removing T ( y2) from C1. Then cov A, C−Let C−not. Based on this observation, one can show that the skeleton of each cactus in Kmin|= q, the pruned cactus C−1Q has only one branch.1 is minimal, while C2 ⊃ C−1 is The branching number [34] of a rooted tree T is defined as follows. For any node u in T, we compute inductively its branching rank br(u) by taking br(u) = 0 if u is a leaf and, for a non-leaf u,(cid:8)br(u) =m + 1,m,if u has ≥ 2 children of branching rank m;otherwise,(14)where m is the maximum of the branching ranks of u’s children. The branching number of T is the branching rank of its root node. (In other words, the branching number of T is b if the largest full binary tree that is a minor of T is of depth b.) +Q is the branching number of Cs. We call KminThe branching number of a cactus C ∈ Kboundedly branching if there is some b < ω such that Kmincontains a cactus with branching number b but no cactus of greater branching number. Otherwise, we call KminQ unboundedly branching.QQExample 20. The branching number of each cactus in Kminfrom Example 19 is 0; however, there are cactuses in K Q with an arbitrarily large branching number b < ω. As another instructive example, consider the 1-CQ q depicted on the left-hand side below. The cactus C2 for Q = (cov(cid:15), q) on the right-hand side, obtained by first budding y2 and thenQFqTy1Ty2TTFTy1y2y(cid:3)1TC2(cid:3)1, can be pruned at y1 by removing T ( y1) (since every node in a model of cov(cid:15) is labelled by F or T ). Using this yQ has branching number ≤ 1. On the other hand, if Q = (cov A, q), then observation, one can show that every cactus in KminKminQis unboundedly branching as follows from Theorems 21 and 26.Theorem 21. Every (d)d-sirup Q = (O, q) with a 1-CQ q and boundedly branching Kminanswered in NL.Q is linear-datalog-rewritable, and so can be Proof. Similarly to [45], we represent cactus-like ABoxes as terms of a tree alphabet and construct a tree automaton A Qare accepted by A Q , and (ii) for every ABox A accepted by A Q , we have O, A |= q. Then, such that (i) cactuses in Kminusing ideas of [34], we show that if Kminis boundedly branching, then the automaton A Q can be transformed into a (monadic) linear-stratified datalog rewriting of Q . As shown in [83], such a rewriting can further be converted into a linear datalog rewriting (at the expense of increasing the arity of IDB predicates in the program).QQWe only consider the case O = cov A leaving a similar proof for cov⊥A to the reader. As before, we assume that q is a 1-CQ such that F (x) and T ( y1), . . . , T ( yn) are all of the solitary occurrences of F and T in q.17O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 1037380-ary:(F )(F )(F )(F )(cid:5)(cid:6)s2, s3(s2)s1Fs1FxTTTT1-ary:(F )(F )(F )(F )AATy1Ty2ATATAA2-ary:(F )AA1-CQ qsymbols of (cid:12) QFig. 2. An example of a tree alphabet (cid:12) Q and a cactus as a (cid:12) Q -tree.s2s3TTTAs2TTRecall from [97] that a tree alphabet is a finite set (cid:12) of symbols, each of which is associated with a natural number, its arity. A (cid:12)-tree is any ground term built up inductively, using the symbols of (cid:12) as functions: 0-ary symbols in (cid:12) are (cid:12)-trees and, for any k-ary a in (cid:12) and (cid:12)-trees C1, . . . , Ck, the term a(C1, . . . , Ck) is a (cid:12)-tree. The branching number of a (cid:12)-tree is that of its parse tree. We define a tree alphabet (cid:12) Q as follows. Consider cactus-like ABoxes that are built from q using(bud) and (prune), with applications of the latter also allowed when cov A, C− (cid:14)|= q for the resulting ABox C−, and extend the notions of skeleton, branching number and segments to these in the natural way. The symbols of (cid:12) Q are the segments s of such ABoxes, with the arity of s being the number of its budding nodes, and with the x-node of s being either labelled +by F or not. Then each cactus in KQ can be encoded by some (cid:12) Q -tree; see Fig. 2 for an example. On the other hand, every (cid:12) Q -tree represents some cactus-like ABox. So, with a slight abuse of terminology, from now on by a (cid:12) Q -tree we mean either the corresponding term or ABox.However, such an ABox C is not necessarily a cactus in K+Q for two possible reasons: either cov A, C (cid:14)|= q or C having F -nodes in some ‘wrong’ segments (every cactus has a unique F -node, viz., the x-node of its root segment). We are interested in those (cid:12) Q -trees C for which cov A, C |= q. To capture them, we use tree automata [97]. A nondeterministic finite tree automaton (NTA) over a tree alphabet (cid:12) is a quadruple A = (Q , Q f , (cid:4), (cid:12)), where Q is a finite set of states, Q f ⊆ Qis a set of final states, and (cid:4) is a set of transitions of the form q1, . . . , qk ⇒a q, where k ≥ 1 is the arity of a ∈ (cid:12) and q1, . . . , qk, q ∈ Q ; for symbols a of arity 0, we have initial transitions in (cid:4) of the form ⇒a q. A run of A on a (cid:12)-tree C is a labelling function r from the subterms of C to Q satisfying the following condition: for any subterm C− = a(C1, . . . , Ck) of C, there is a transition q1, . . . , qk ⇒a q in (cid:4) such that r(C1) = q1, . . . , r(Ck) = qk and r(C−) = q (in which case we say that the transition is used in r). A (cid:12)-tree C is accepted by A if there is a run of A on C that labels C with a final state. Let L(A)be the set of all (cid:12)-trees accepted by A. A set L of (cid:12)-trees is called a regular tree language if L = L(A), for some NTA A over (cid:12).Claim 21.1. L Q = {C | C is a (cid:12) Q -tree with covA, C |= q} is a regular tree language.Proof. We proceed via a series of steps. In the construction, we use Theorem 11 for describing L Q by means of the datalog program (cid:2) Q = {(9), (10), (11)}. We extend the tree alphabet (cid:12) Q to a tree alphabet (cid:12)eQ as follows. For each symbol s in (cid:12) Q , we label some (possibly none) of the nodes in segment s by P . We call each resulting ‘segment’ se an extension ofs. (Each symbol in (cid:12) Q might have several extensions, and each of them has the same arity as s.) Let (cid:12)eQ consist of all Q -tree Ce is an extension of a (cid:12) Q -tree C if they have isomorphic possible extensions of every s in (cid:12) Q . We say that a (cid:12)etree structures, and each symbol se in Ce is an extension of the corresponding symbol s in C. For example, the closure (cid:2) Q (C) of any (cid:12) Q -tree C under (cid:2) Q is an extension of C.For any (cid:12)eQ -tree Ce , we write Ce |= G , for the goal predicate G of (cid:2) Q , if there is a homomorphism from qe to Ce , where qe = q \ {T ( y1), . . . , T ( yn)} ∪ {P ( y1), . . . , P ( yn)}. We claim that each of the following is a regular tree language:(a) the set of (cid:12)eQ -trees Ce with Ce (cid:14)= (cid:2) Q (Ce);18O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Q -trees Ce with Ce |= G ;(b) the set of (cid:12)e(c) the set of (cid:12) Q -trees C that have some extension Ce with Ce = (cid:2) Q (Ce) and Ce (cid:14)|= G ;(d) the set of (cid:12) Q -trees C with (cid:2) Q , C |= G .Indeed, to show (a), we need an NTA ‘detecting a pattern’ in the ABox Ce falsifying one of rules (10)–(11) in (cid:2) Q . Similarly, to show (b), we need an NTA ‘detecting a pattern’ in Ce corresponding to an application of rule (9) in (cid:2) Q . Now, (c) follows from (a), (b) and the fact that regular tree languages are closed under taking complements, intersections and linear homomorphisms [97] (as the ‘forgetting’ function substituting s for each se is a linear tree homomorphism from (cid:12)eQ -trees to (cid:12) Q -trees, mapping any extension Ce to C). To show (d), take the complement of (c), and observe that (cid:2) Q , C |= G iff, for every extension Ce of C, whenever Ce = (cid:2) Q (Ce) then Ce |= G .Finally, it follows from (d) and Theorem 11 that L Q is a regular tree language. (cid:2)An NTA A = (Q , Q f , (cid:4), (cid:12)) is linear-stratified if there is a function st : Q → ω such that, for any transition q1, . . . , qk ⇒a qin (cid:4),– st(qi) ≤ st(q), for every i, 1 ≤ i ≤ k, and– there is at most one i such that 1 ≤ i ≤ k and st(qi) = st(q).Claim 21.2. For any NTA A and any b < ω, there is a linear-stratified NTA As such that{C ∈ L(A) | the branching number of C is ≤ b} ⊆ L(As) ⊆ L(A).(15)Proof. Suppose A = (Q , Q f , (cid:4), (cid:12)). We define As = (Q s, Q sf , (cid:4)s, (cid:12)) as follows. First, set Q s = Q × {0, . . . , b} and Q f =Q f × {0, . . . , b}. Then, for any transition of the form ⇒a q in (cid:4), we add the transition ⇒a (q, 0) to (cid:4)s. For any transition q1, . . . , qk ⇒a q in (cid:4) and any m ≤ b, we add to (cid:4)s all transitions (q1, m1), . . . , (qk, mk) ⇒a (q, m) such that– either m1, . . . , mk < m and mi = m j = m − 1, for some i (cid:14)= j;– or mi = m, for some i, and m j < m, for all j (cid:14)= i.= m, for q ∈ Q , m ≤ b. To show (15), observe that L(As) ⊆ L(A) since from As is linear-stratified as one can set stevery run r of As on C we obtain a run of A on C by replacing each (q1, m1), . . . , (qk, mk) ⇒a (q, m) used in r with q1, . . . , qk ⇒a q. For the other inclusion, given a run r of A on some C with branching number ≤ b, we obtain a run of As(cid:6)−on C by labelling each subterm C−is the branching number of C−of C with state (cid:5)r(C−), b, where b. (cid:2)−(cid:5)(cid:6)(q, m)We can now complete the proof of Theorem 21. Indeed, suppose that every cactus in Kminmost b < ω. By Claims 21.1 and 21.2, there is a linear-stratified NTA A = (Q , Q f , (cid:4), (cid:12) Q ) such thatQ has branching number at {C ∈ L Q | the branching number of C is at most b} ⊆ L(A) ⊆ L Q .Using A, we construct a (monadic) linear-stratified program (cid:2)A with goal predicate G A as follows. For every q ∈ Q , we introduce a fresh unary predicate P q. For every final state q ∈ Q f , the program (cid:2)A contains the ruleG A ← P q(x).(16)For every transition q1, . . . , qk ⇒s q in (cid:4), where the budding nodes in the k-ary segment s are yi1 , . . . , yik , (cid:2)A containsP q(x) ← s, P q1 ( yi1 ), . . . , P qk ( yik ).(17)As A is linear-stratified, it is easy to see that the program (cid:2)A is linear-stratified. We claim that ((cid:2)A, G A) is a datalog-rewriting of Q , that is, for any ABox A (without the P q), we have (cid:2)A, A |= G A iff cov A, A |= q.(⇐) By Theorem 11, there is a homomorphism h : C → A, for some C ∈ K Q . As C always contains some C(cid:3) ∈ KminQ , we may assume that C ∈ KminQ , it follows that C ∈ L Q , and so C ∈ L(A). Let r be an accepting run of A on C. We construct a derivation of G A in (cid:2)A(A) by induction on C as a (cid:12) Q -tree, moving from leaves to the root. For every segment s in C, if the transition q1, . . . , qk ⇒s q is used in rthen we apply (17) with the substitution of h(z) for any node z in s. Also, if r(C) = q, for some final state q of A, then we apply (16) with the substitution h(xs0 ), where xs0 is the x-node of the root segment s0 in C. It follows that (cid:2)A, A |= G A.Q , and so C has branching number ≤ b. As cov A, C |= q clearly holds for every C ∈ Kmin(⇒) By induction on a derivation of G A, we construct a (cid:12) Q -tree B, an accepting run r of A on B, and a homomorphism f : B → A. To begin with, there is an object xa for which (16) was triggered for some q ∈ Q f . Then P q(xa) was deduced by an application of (17) for some s. If this s is 0-ary, then s is a (cid:12) Q -tree (of depth 0), the function r labelling s with q is an accepting run on s, and the substitution f 0 used in (17) is a homomorphism from s to A. If s is k-ary, for some k > 0, then there are yai1for which (17) was triggered. For each j = 1, . . . , k, consider the rule, . . . , yaik19O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738P q j (x) ← s j, P( yi1 ), . . . , Pqj1( yik j)qjk j) was deduced. Take the ABox B built up by glueing the x node of each segment s j to the yi j node of by which P q j ( yai js, extend r by labelling each s j with q j , and extend f 0 to a B → A homomorphism by taking the substitutions used in the rules. Now, if every s j is 0-ary, then B is a (cid:12) Q -tree and we are done. Otherwise, repeat the above procedure for the ‘arguments’ of each s j of arity > 0. As the derivation of G A is finite, sooner or later the procedure stops, as required.As B ∈ L(A) ⊆ L Q , by Theorem 11 there exists a homomorphism h : C → B, for some cactus C ∈ K Q . Then the compo-sition of h and fis a homomorphism from C to A, and so cov A, A |= q by Theorem 11, as required. (cid:2)We do not know if the sufficient condition in Theorem 21 of linear-datalog-rewritability of (d)d-sirups with a 1-CQ is also a necessary one. As follows from [34,35], this is so for ditree 1-CQs with root labelled by F ; see Example 18. We use Theorem 21 in the next section to show that answering path-shaped dd-sirups with a certain periodic structure can be done in NL.5. AC0 / NL / P / CONP-tetrachotomy of dd-sirups with a path CQWe now obtain the main result of this article: a complete syntactic classification of dd-sirups (cov⊥A , q) with a path-shaped CQ q according to their data complexity and rewritability type. While the AC0/NL part of this AC0/NL/P/coNP-tetrachotomy follows from our earlier results, proving P- and especially coNP-hardness turns out to be tough and requires the development of novel machinery.From now on, we only consider path CQs q (whose digraph is path-shaped). Solitary F - and T -nodes will simply be called F - and T -nodes, respectively. We denote the first (root) node in q by bq and the last (leaf) node by eq . Given nodes x and y, we write x ≺ y to say that there is a directed path from x to y in q; as usual, x (cid:29) y means x ≺ y or x = y. For x (cid:29) y, the set [x, y] comprises those atoms in q whose variables are in the interval {z | x (cid:29) z (cid:29) y} and (x, y) =[x, y] \ {T (x), F (x), T ( y), F ( y)}. For i = (x, y), we let |i| be the length of the path from x to y, and |q| = |(bq, eq)|.We divide path CQs into three disjoint classes: the 0-CQs and the 1-CQs defined earlier, and the 2-CQs that contain at ⊥least two F -nodes and at least two T -nodes. As we saw in Section 3.2, dd-sirups (covA , q) with q containing F T -twins are always FO-rewritable. We split twinless 1-CQs further into periodic and aperiodic ones, only considering 1-CQs with a single F -node and at least one T -node (as the case with a single T -node and at least one F -node is symmetric). Given such a twinless 1-CQ q and natural numbers l, r with l + r ≥ 1, we write q = qlr to say that q has l-many T -nodes x−l ≺ · · · ≺ x−1that ≺-precede its only F -node x0, and r-many T -nodes x1 ≺ · · · ≺ xr that ≺-succeed x0. For every i with −l ≤ i ≤ r + 1, we define a set ri of binary atoms by taking ri = (xi−1, xi), where x−l−1 = bq and xr+1 = eq. Note that ri (cid:14)= ∅ for −l < i < r + 1, but r−l = ∅ if bq = x−l and rr+1 = ∅ if xr = eq.q = qlrr−lTx−lbq. . .r0Tx−1Fx0r1Tx1. . .rr+1TxreqEach ri determines a finite sequence (cid:30)ri(cid:31) of binary predicate symbols. We call q right-periodic if q = q0r and either r = 1or (cid:30)ri(cid:31) = (cid:30)r1(cid:31) for all i = 1, . . . , r and (cid:30)rr+1(cid:31) = (cid:30)r1(cid:31)∗λ for some (possibly empty) prefix λ of (cid:30)r1(cid:31). By taking a mirror image of this definition, we obtain the notion of left-periodic 1-CQ, in which case q = ql 0 and either l = 1 or (cid:30)r−i(cid:31) = (cid:30)r0(cid:31) for all i = 1, . . . , l − 1 and (cid:30)r−l(cid:31) = λ(cid:30)r0(cid:31)∗for some (possibly empty) suffix λ of (cid:30)r0(cid:31). A twinless 1-CQ q is called periodic if it is either right- or left-periodic, and aperiodic otherwise.Theorem 22 (tetrachotomy). Let Q be any d-sirup with a twinless path CQ q or any dd-sirup with a path CQ q. Then the following tetrachotomy holds (where the three ‘if’ can be replaced by ‘iff’ provided that NL (cid:14)= P (cid:14)= coNP):(AC0) Q is FO-rewritable and can be answered in AC0 iff q is a 0-CQ or contains an F T -twin; otherwise,(NL) Q is linear-datalog-rewritable and answering it is NL-complete if q is a periodic 1-CQ;(P) Q is datalog-rewritable and answering it is P-complete if q is an aperiodic 1-CQ;(CONP) answering Q is coNP-complete if q is a 2-CQ.The first item follows from Theorem 5 and the fact that AC0 (cid:14)= L. The upper bounds in the remaining three are given by Theorem 24, Corollary 12, and Theorem 4, respectively. The matching lower bounds are established by Theorems 23, 26 and 27 to be proved below. We begin with the following criterion:Theorem 23. If q is a twinless path 1-CQ, then answering (covA, q) and (cov⊥A , q) is NL-hard.20O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Proof. The proof is by an FO-reduction of the NL-complete reachability problem for directed acyclic graphs (dags). We assume that there exist a T -node x and an F -node y in q with x ≺ y (the other case is symmetric) and without any F - or T -nodes between them. Given a dag G = (V , E) with nodes s, t ∈ V , we construct a twinless ABox AG as follows. Replace each edge e = (u, v) ∈ E by a fresh copy qe of q such that node x in qe is renamed to u with T (u) replaced by A(u), and node y is renamed to v with F (v) replaced by A(v). Then AG comprises all such qe , for e ∈ E, as well as T (s) and F (t). We show that s →G t iff cov A, AG |= q iff cov⊥A , AG |= q (cf. (8)).(⇒) Suppose there is a path s = v0, . . . , vn = t in G with ei = (vi, vi+1) ∈ E, for i < n. Then, for any model I of cov A and . Thus, the isomorphism mapping from q to its copy qei is a q → Iand vi+1 ∈ FIIAG , there is some i < n such that vi ∈ Thomomorphism, and so I |= q.(⇐) Suppose s (cid:3)G t. Define a model I of cov A and AG by labelling with T the undecided A-nodes in AG that are reachable from s (via a directed path) and with F the remaining ones. By excluding all possible locations where the T -node x could be mapped, we see that there is no homomorphism h : q → I. Indeed, suppose h(x) is in a copy qe for some edge e = (u, v) ∈ E. Then h(x) cannot precede u or succeed v in qe , otherwise there is not enough room in qe for the rest of q to be mapped. And h(x) cannot be between u and v either, as q is twinless and there are no T -nodes between x and y in q. If h(x) = u, then we exclude all options where the F -node y could be mapped: h( y) cannot succeed u in q(u(cid:3),u) for any edge (u(cid:3), u) because of the lack of room in q(u(cid:3),u), and h( y) = v(cid:3)cannot hold in q(u,v(cid:3)) for any edge (u, v(cid:3)) ∈ E because such a v(cid:3)is labelled by T in I. For similar reasons, h(x) = v cannot happen either. (cid:2)A generalisation of this theorem to d-sirups with ditree-shaped 1-CQs possibly containing F T -twins has been proved in [44] using a much more involved construction; see also Example 25 below.By Corollary 12, all (d)d-sirups with a 1-CQ are datalog-rewritable and can be answered in P. Our next task is to establish an NL/P dichotomy for d-sirups with a twinless path 1-CQ.Theorem 24. If q is a periodic twinless path 1-CQ, then both (covA, q) and (covanswered in NL.⊥A , q) are linear-datalog-rewritable, and so can be Proof. We use the notation above, and only consider the case when Q = (cov A, q) and q = q0r is a right-periodic twinless path 1-CQ with a single F -node x0 and T -nodes x1, . . . , xr . We show that every cactus in KminQ has branching number at most 1 and use Theorem 21. If r = 1, then the cactuses in KminQ have branching number 0.So suppose r ≥ 2 and C ∈ KminQ . For nodes u, v in C, we write u ≺C v to say that there is a directed path from u to v in the (acyclic) digraph C. We call a node in C a T -copy if it is a copy of a T -node xi of q for some i = 1, . . . , r. There can be three kinds of T -copies: those that were budded while constructing C are labelled by A, those that were pruned have no label, and the rest are labelled by T . Observe first thatif some T -copy u is unlabelled in C, then there is no T -copy v such that u ≺C v and v is labelled by T .(18)(cid:3)(cid:3)with u ≺C uI. As cov A, C |= q, there is a Indeed, consider any model I of cov A and C in which all A-nodes us0homomorphism h : q → I. As x0 is an F -node in q and its copy xin the root segment s0 of C is the only F -node in C, it 0follows from our assumption on I that u ⊀C h(x0). We show that u ⊀C h(xi), for any i ≤ r. Indeed, this is clear if h(x0) ⊀C u. s0So suppose h(x0) ≺C u ≺C h(xr). Then, either h(x0) = x0 or h(x0) is a budded T -copy ≺C -preceding u. By q being right-periodic, every T -copy on the path from h(x0) to h(xr) in C different from h(x0) must be labelled by T . However, this is not the case for u, which is a contradiction. As u ⊀C h(xi) for any i ≤ r, by using (bud) and (prune) we can construct a cactus +C1 ∈ Kbeing unlabelled. Then C1 ⊆ C, and so Q that is the same as C apart from all T -labelled T -copies uC ∈ KminQimplies that C = C1, proving (18).Next, consider any branch s0, . . . , sn−1, sn in the skeleton Cs of C such that there are no A-nodes in the segment sn−1≺C-succeeding the A-labelled T -copy w that has been budded to obtain the leaf segment sn. Let π be the path in C from the root node of s0 to the leaf node of sn. We claim thatwith u ≺C uare in T(cid:3)(cid:3)all T -copies in π are labelled by either T or A.(19)Indeed, by (18), it is enough to show that all T -copies in sn are labelled by T . Suppose on the contrary that at least one of them is not. Let I be a model of cov A and C where the A-node w is labelled by F . Then there is a homomorphism +h : q → I such that h(xi) (cid:14)= w for any i = 0, . . . , r. Thus, by using (bud) and (prune) we can construct a cactus C2 ∈ KQthat is the same as C apart from w in sn−1 not being budded but pruned (and so w is unlabelled in C2 and sn is not a 2). Then C2 ⊆ C but C2 (cid:14)= C, contrary to C ∈ Kminsegment in CsQ .Now (19) and q being right-periodic imply that, for any model I of cov A and C, there is a homomorphism h : q → Imapping x0 and (x0, eq) into π . Indeed, take h(x0) = z where z is the ≺C-last F -labelled A-node in π if there is such, and s00 otherwise. By the definition of budding, the part of q ≺-preceding x0 can be mapped to I as well, possibly covering xsome parts of C not in π but in a child-segment of some of the si . Therefore, by using (bud) and (prune) we can construct a +Q whose skeleton consists of the branch s0, . . . , sn and all other children of the segments si for i = 0, . . . , n − 1, cactus C3 ∈ K21O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738the T -copies that were labelled by A and budded further in C in some of these children are unlabelled in C3, and all other T -copies are the same in C3 and C. Then C3 ⊆ C and the branching number of C3 is at most 1. As C ∈ KminQ , C = C3follows. (cid:2)One can generalise the proof of Theorem 24 to various path 1-CQs with F T -twins. Here are some examples.Example 25. We invite the reader to show that answering the d-sirups with the following 1-CQs is NL-complete:FF TF TTTFF TF TTTTTF TFTTF TF TF TFF TTTWe next show that answering any d-sirup with twinless path 1-CQs not covered by Theorem 24 is P-hard.Theorem 26. If q is an aperiodic twinless path 1-CQ, then answering both (covA, q) and (cov⊥A , q) is P-hard.Proof. The theorem is proved by an FO-reduction of the monotone circuit evaluation problem, which is known to be P-complete [98]. We remind the reader that a monotone Boolean circuit is a directed acyclic graph C whose vertices are called gates. Gates with in-degree 0 are input gates. Each non-input gate g is either an AND-gate or an OR-gate, and has in-degree 2(with the two edges coming in from gates we call the inputs of g). One of the non-input gates is distinguished as the output gate. Given an assignment α of F and T to the input gates of C , we compute the value of each gate in C under α as usual in Boolean logic. The output C (α) of C on α is the truth-value of the output gate. For every monotone Boolean circuit C and every assignment α, we construct a twinless ABox AC ,α whose size is polynomial in the sizes of q and C , and then show that C (α) = T iff cov A, AC ,α |= q iff covWe prove the theorem for aperiodic 1-CQs with a single F -node (the other case is symmetric). Suppose q = qlr for some l, r with l + r ≥ 1. Then there can be three reasons for q being aperiodic: (i) l = 0 and q is not right-periodic, (ii) r = 0 and q is not left-periodic, or (iii) l, r ≥ 1. In each of the three cases (i)–(iii), we give a different reduction.⊥A , AC ,α |= q (cf. (8)).(i) If q = q0r and q is not right-periodic, then r ≥ 2. We let(cid:9)n =r,min {i | 1 < i ≤ rand(cid:30)ri(cid:31) (cid:14)= (cid:30)r1(cid:31)}, otherwise.if (cid:30)r1(cid:31) = (cid:30)r2(cid:31) = · · · = (cid:30)rr(cid:31);Then n ≥ 2. The ABox AC ,α is built up from isomorphic copies of the following intervals: l = (bq, x0), r1 = (x0, x1), r =(x1, xn−1), s = (xn−1, xn), and t = (xn, eq). Note that s is nonempty and has no T -nodes. On the other hand, l can be empty when bq = x0, r can be empty when n = 2, and t can be empty when xn = eq.lFx0r1Tx1bqr2Tr. . .Txnrn−1Ts = rnxn−1tTxneq(cid:3)We use the gadgets in Fig. 3 to simulate the AND- and OR-gates. For AND-gates, we distinguish between two cases |s| > |r1| and |s| ≤ |r1|, while the gadget for OR-gates is the same in both cases. Throughout, in our pictures of ABoxes, (cid:3) = b are lower case letters like a, b, z, . . . are just pointers, not actual labels of nodes. In Fig. 3, if r = ∅ then z = alabelled only by A.and zGiven a monotone circuit C and an assignment α, we construct AC ,α as follows. With each non-input gate g we associate a fresh copy of its gadget. When the inputs of g are gates ga and gb then, for each i = a, b, if gi is a non-input gate, then we merge node c of the gadget for gi with node i in the gadget for g; and if gi is an input gate, we replace the label A of (if available) in the gadget for g with α(gi). Finally, we replace the label A of node c in the gadget for the output i and igate with F . We claim that cov A, AC ,α |= q iff C (α) = T .(⇐) is proved by induction on the number of non-input gates in C . The basis is obvious. For the induction step, suppose the output gate g in C is an AND-gate with inputs ga and gb, at least one of which is a non-input gate. Let I be an arbitrary model of cov A and AC ,α . If both a and b in the gadget for g are in T, then it is easy to check that we always have a q → I homomorphism, no matter what the labels of a(if available) are. It remains to consider the case when either a or b is in Fof C whose output gate is gi . Then −,α is the sub-ABox of AC ,α with node c in the gadget for gi as its topmost node, and A(c) replaced by F (c). Now, if ACI−homomorphism, and so I |= q as well. is the restriction of I to ACThe case when the output gate g in C is an OR-gate is similar., and so the corresponding gi is not an input gate. Take the subcircuit C), then by IH there is a q → I−−,α (and so c ∈ Fand bI−−II(cid:3)(cid:3)(cid:3)22O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738AND-gate gadget for|s| > |r1|for |s| ≤ |r1|cAsTzr(cid:3)ar1Ar1TruTsAallttA(cid:3)blr1TrTstAbAr1TrAcl(cid:3)zOR-gate gadgetcAr1lr1TTrsTTrsstAabtAatAbFig. 3. Gate gadgets in case (i).(cid:3)(⇒) Suppose C (α) = F . To show cov A, AC ,α (cid:14)|= q, we define a model I of cov A and AC ,α inductively by labelling the A-nodes in the gadget for each non-input gate g of C by F or T as follows: node c is labelled by the truth-value of g under if applicable), for i = a, b, is labelled by the truth-value of gi under α, where ga and gb are the α, while node i (and node iinputs of g. Suppose, on the contrary, that there is a homomorphism h : q → I. We exclude all options for the image h(q)of q. To this end, we track possible locations for h(x0) ∈ F. Let the non-input gate g be such that h(x0) is in the gadget for g and the inputs of g are gates ga and gb. We may assume that h(x0) is different from nodes a and b, because if h(x0) = ifor i ∈ {a, b} then gi must be a non-input gate (otherwise there is no room for h(q) in AC ,α ), and so h(x0) = c in the gadget for gi .ISuppose first that g is an AND-gate and |s| > |r1|. We have the following cases:a, aa, aa, a(cid:3)II, b, b(cid:3), c ∈ F: If h(x0) = c, then h(x1) = a(cid:3) ∈ T. But then, since |s| > |r1|, the node h(xn) must be strictly between u and a which is impossible because there are no T -nodes (cid:3)in s. We cannot have h(x0) = b(cid:3), c ∈ F(cid:3) ∈ T: If h(x0) = aT -node. But then, since |s| > |r1|, the node h(xn−1) must be strictly between bare no T -nodes in s.(cid:3), c ∈ F(cid:3), b, b, h(q) cannot continue ‘vertically’ towards a. Then h(x1) is the central and z, which is impossible because there , h(q) cannot continue ‘horizontally’ towards b: This case is covered by the previous ones.because b ∈ F(cid:3)then, since a ∈ Fand there is no room for h(q) in t.and, since bI, b, b(cid:3) ∈ FIIIII(cid:3)(cid:3)I, and so h(xn) is located in some other gadget gSuppose next that g is an AND-gate and |s| ≤ |r1|. Then h(x0) = c and h(xn−1) = b, provided that b ∈ T(otherwise such h is impossible), which means that a ∈ Fwhose node c is merged with the current b = h(xn−1). However, this is impossible because of the following. In every gadget, the ‘edges’ leaving node c, if |s| < |r1| then h(xn) must be are all labelled by r1. As xn−1 is ‘s-connected’ to xn and h(xn−1) = c in the gadget for gstrictly between c and the end-node of an r1-edge, but there are no T -nodes there. So suppose |s| = |r1|. Then h(xn) is the , and so (cid:30)s(cid:31) = (cid:30)r1(cid:31). Now it follows from the definition of n and s that n = rend-node of an r1-edge in the gadget for gand (cid:30)r1(cid:31) = · · · = (cid:30)rr(cid:31) = (cid:30)s(cid:31). As h(xr) = h(xn) is the end-node of an r1-edge starting at c in the gadget for g, an inspection of the gate-gadgets shows that rr+1 = (xr, eq) = t must be mapped to a non-empty sequence of r1-intervals followed by t, or in some subsequent gadgets). So (cid:30)rr+1(cid:31) must be a possibly empty sequence of (cid:30)r1(cid:31)s, possibly (either in the gadget for gfollowed by a non-empty proper prefix of (cid:30)r1(cid:31), contrary to q being not right-periodic.Finally, if g is an OR-gate and h(x0) = c in the gadget for g, then both a and b of the gadget are in F I , and so h(xn) ∈ F, I(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)Iwhich is a contradiction.The proof of (ii) is a mirror image of the previous one.(iii) If q = qlr and l, r ≥ 1, then AC ,α is built up from isomorphic copies of the following intervals: l = (bq, x−1), r =(x−1, x0), s = (x0, xr), and t = (xr, eq). Note that r is not empty and has no T -nodes, while l and t may be empty.lTx−1rFx0sTxrteqbqWe use the gadgets in Fig. 4 to simulate the AND- and OR-gates. The number of A-nodes in the gadget for a non-output AND-gate exceeds |q| + 2.Given a monotone circuit C and an assignment α, we construct AC ,α as follows. With each non-input gate g we associate a fresh copy of its gadget. When the inputs of g are gates ga and gb then, for each i = a, b, if gi is a non-input gate, then 23O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738output AND-gate gadgetFnon-output AND-gate gadgetoutput OR-gate gadgetllrAarAanon-output OR-gate gadgetlrAasArArAbTbTbFssAzttltlFig. 4. Gate gadgets in case (iii).TTTTssssrrrA...zAAAAlllllrAasAbtttttwe merge the topmost A-node of the gadget for gi with node i in the gadget for g; and if gi is an input gate, we replace the label A of i in the gadget for g with α(gi). We claim that cov A, AC ,α |= q iff C (α) = T .(⇐) is proved by induction on the number of non-input gates in C . The basis (when C has one non-input gate) is obvious. For the induction step, suppose the output gate g in C is an OR-gate with inputs ga and gb, at least one of which Iis a non-input gate. Let I be an arbitrary model of cov A and AC ,α . If at least one of a or b in the gadget for g is in T, then clearly I |= q. It remains to consider the case when a and b are both in F. Let i be such that gi is a non-input gate. of C whose output gate is gi . There are two cases. (a) If node z in the gadget for gi is in FThen Ais the restriction CIof I to Athen giis an AND-gate and, as the topmost A-node in the gadget for gi is in F, there is an A-node in the gadget for gi that is in while the next A-node above it is in F I . So we have a q → I homomorphism. The case when the output gate of C is Tan AND-gate is similar.−,α is the sub-ABox of AC ,α with z as its topmost node, and A(z) replaced by F (z). Now, if I−homomorphism, and so I |= q as well. (b) If z ∈ T) then, by IH, there is a q → I−, consider the subcircuit C−,α (and so z ∈ F(⇒) Suppose C (α) = F . To show cov A, AC ,α (cid:14)|= q, we define a model I of cov A and AC ,α by putting the A-nodes of the ) if the truth-value of g under α is F (or, respectively, T ). Suppose, on the contrary, gadget for any gate g in C to Fthat there is a homomorphism h : q → I. We track the possible locations of h(x0) ∈ F(or TI−−IIIIIII:C– If the output gate is an AND-gate, then h(x0) cannot be the F -node of its gadget because then h(x−1) = a and h(xr) = b, and so at least one of them would be in F I , which is a contradiction.– If the output gate is an OR-gate, then h(x0) cannot be the F -node of its gadget because then either h(x−1) = a or h(x−1) = b, and so h(x−1) would be in F I , a contradiction.– So suppose h(x0) is an A-node in a gadget for a non-input and non-output gate g. If g is an OR-gate, then either h(x−1) = a or h(x−1) = b in the gadget for g, and so h(x−1) would be in F I , a contradiction. So suppose g is an AND-gate, and consider the gadget for g. Then h(x0) cannot be any A-node located above z, because otherwise h(x−1) would , a contradiction. Finally, if h(x0) = z then, as the vertical line comprised of the rbe the previous A-node, and so in Fis longer than q and contains no T -nodes, h(x1) ∈ Tmust also be in the gadget for g, and it must be in one of the horizontal s. But this is impossible because r is non-empty, and so the distance between z = h(x0) and h(x1) in the gadget would be greater than the distance between x0 and x1 in q.IIThus, we cannot have a homomorphism h : q → I. (cid:2)The proof above bears some superficial similarities to the construction of Afrati and Papadimitriou [47] in their clas-sification of binary chain sirups. One could also draw some parallels with the proof of P-hardness for OMQs with an ELontology given by Lutz and Sabellek [34,35], who used a reduction of path systems accessibility (PSA) rather than monotone circuit evaluation.The most difficult part of our tetrachotomy is proving coNP-hardness of dd-sirups with path 2-CQs. Despite the abun-dance of results on algorithmic aspects of graph homomorphisms [87], we failed to find any known technique applicable to our case. In the remainder of the article, we develop a new method for establishing coNP-hardness of disjunctive OMQs.24O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 1037386. Proving CONP-hardness: the bike techniqueTheorem 27. If q is a twinless path 2-CQ, then answering both (covA, q) and (cov⊥A , q) is coNP-hard.We prove Theorem 27 by a polynomial reduction of the complement of NP-complete 3SAT [98]. Recall that a 3CNF is a conjunction of clauses of the form (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3, where each (cid:2)i is a literal (a propositional variable or a negation thereof). The decision problem 3SAT asks whether a given 3CNF ψ is satisfiable. For any 3CNF ψ , we construct a twinless ABox Aq,ψ⊥A , Aq,ψ (cid:14)|= q (cf. whose size is polynomial in the sizes of q and ψ , and show that ψ is satisfiable iff cov A, Aq,ψ (cid:14)|= q iff cov(8)). The construction, called the bike technique, builds Aq,ψ from many copies of q via three major steps:1. First, we represent the truth-values of the literals in ψ by gadgets called cogwheels.2. Next, we connect cogwheels to represent negation properly by gadgets called bikes.3. Finally, we connect bikes to represent the interaction of the clauses in ψ and obtain Aq,ψ .IThese steps will be defined and investigated in detail in Sections 6.1–6.3. But before that we explain the underlying ideas and illustrate them by an example. Each cogwheel W in Step 1 has many A-nodes (the number depends on |q| and the number of clauses in ψ ) where the different copies of q meet. Each W is such that, for every model I of cov A and W, . If a variable p occurs in ψ , then in Step 2 a bike B, we have I (cid:14)|= q iff the A-nodes in W are all in Trepresenting the pair {p, ¬p} of literals, is assembled from two disjoint cogwheels by connecting them via A-nodes using two further copies of q. We have pairwise disjoint bikes for all variables occurring in ψ . Each bike B is constructed in such a way that, for every model I of cov A and B, we have I (cid:14)|= q iff the truth-values in I represented by the two cogwheels of B are opposites of each other. Finally, in Step 3, for each clause c = (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3 in ψ , we use a further copy qc of qto connect, via three A-nodes, three cogwheels from the bikes representing {(cid:2)1, ¬(cid:2)1}, {(cid:2)2, ¬(cid:2)2} and {(cid:2)3, ¬(cid:2)3} in such a way that for every model I of cov A and the resulting ABox Aq,ψ , we have I (cid:14)|= q iff the labels of the three ‘c-connection’ A-nodes in I define an assignment satisfying c. If in Step 1 we choose the number of A-nodes in the cogwheels to be large enough, then in each cogwheel we can use different ‘c-connection’ A-nodes for different clauses, and they can also be different from those A-nodes that are used for constructing the bikes from the cogwheels.or are all in FIExample 27.1. Consider the d-sirup (cov A, q) with the 2-CQ q shown in the picture below (with R on edges omitted).TTFFLet ψ = c1 ∧ c2 ∧ c3, where c1 = ¬p ∨ q ∨ ¬r, c2 = p ∨ q ∨ ¬r, and c3 = p ∨ ¬q ∨ r. Fig. 5 shows the steps of the construction of Aq,ψ . In Step 1, we construct six cogwheels, each from four copies of q, representing one of p, ¬p, q, ¬q, r, ¬r. Then in Step 2 we construct three bikes, representing the pairs {p, ¬p}, {q, ¬q} and {r, ¬r}. Finally, we connect the bikes in Step 3 to obtain Aq,ψ . Given an assignment a : {p, q, r} → {T , F }, we define a model Ia of cov A and Aq,ψ as follows: for v ∈ {p, q, r}, Ia ; and if a(v) = F then the if a(v) = T then the A-nodes in the v-cogwheel are in TIa . It is tedious but not hard to check that Ia (cid:14)|= qA-nodes in the v-cogwheel are in Fiff a satisfies ψ .Ia and in the ¬v-cogwheel are in FIa and in the ¬v-cogwheel are in TIt is far from obvious what exactly are the particular properties of this construction that can be generalised to arbitrarytwinless path 2-CQs (just consider some permutations of the F - and T -nodes in q above). On the one hand, it is easy to identify what is needed for the ‘if cov A, Aq,ψ (cid:14)|= q then ψ is satisfiable’ direction to hold. However, the main obstacle in proving the converse implication is that, given a model I determined by an assignment satisfying ψ , we need to exclude all q → I homomorphisms, not just those that map q onto one of its copies in Aq,ψ . At each of the three steps, there can be such ‘parasite’ q → I homomorphisms, and there is no single, universal way of correctly assembling the Aq,ψ for all qand ψ . In the remainder of the article, we show how to overcome this obstacle.(cid:3)We fix some twinless path 2-CQ q and use the following notation. For any k, we let tk ( fk) denote the kth T -node (F -node) in q. In particular, t1, tlast−1, and tlast denote, respectively, the first, the last but one, and the last T -node in q. , that is, δq(cid:3) (x, y)Given any path CQ q(cid:3) = q, and set is the number of edges in the path from x to y whenever x (cid:29)q(cid:3) y. As before, we omit the subscripts when q|q| = δ(bq, eq), for the first (root) node bq and the last (leaf) node eq in q., we write ≺q(cid:3) and (cid:29)q(cid:3) for the ordering of nodes in q, and δq(cid:3) for the distance in qThroughout, when proving statements of the form cov A, A (cid:14)|= q for some ABox A, we use a generalisation of homomor-phisms, which allows us to regard our CQs as if they contained a single binary predicate only. Given a model I of an ABox A, we call a map h : q → I a subhomomorphism if the following conditions hold:(cid:3)(cid:3)I– h(x) ∈ T, for every T -node x in q, and h(x) ∈ F– for any nodes x, y in q, if R(x, y) is in q for some R, then S(cid:6)(cid:5)h(x), h( y), for every F -node x in q;Iis in A for some S.25O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738A(cid:2)AStep 1:ATFFTStep 2:TTFTATFA(cid:2)AA¬(cid:2)Aq1...qk+1Step 3:TTqc1qc2qc3TFFFig. 5. An example of the bike-technique.t 1Af nt k+1Af kqnq2Wf 1At 2f k−1At kFig. 6. An n-cogwheel W for q.AqA¬qAA¬rArAAq,ψApA¬pA...qk−1qkThe ABoxes A we build from copies of q will contain cycles, but these cycles will be large compared to |q|. Thus, for any subhomomorphism h mapping q to some model I of A, h(q) can always be regarded as a path CQ, and we have the following obvious ‘h-shift’ property:δ( y, z) = δh(q)(cid:5)(cid:6)h( y), h(z), for all nodes y and z in q.6.1. Representing the truth-values of literals by cogwheels(20)For n ≥ |q|, we take n disjoint copies q1, . . . , qn of q. For any j, 1 ≤ j ≤ n, and any node x in q, let x j denote the copy of x in q j . For each j, we pick a T -node t j and an F -node f j in q j , calling the selected nodes contacts. We replace the T -and F -labels of all the contacts with A, and then glue f j together with t j+1 for every j, 1 ≤ j ≤ n, with ± being understood throughout modulo n. We call the resulting ABox W an n-cogwheel (for q); see Fig. 6. Given two contacts c1 = f i = t i+1 and c2 = f j = t j+1, we define the contact-distance between c1 and c2 in W as min(cid:5)|i − j|, n − |i − j|As shown in Lemma 27.3 below, it is straightforward to see that, for any n-cogwheel W, if I is a model of cov A and Wwith I (cid:14)|= q, then either all contacts of W are in T. We want the converse implication to hold as well, in which case W would ‘represent’ a truth-value. In order to achieve this, we need to choose the contacts in such a way that all possible locations in W for the image h(q) of a potential homomorphism h : q → I are excluded. The following example shows an improper choice of contacts.or all contacts of W are in F(cid:6)II.Example 27.2. Consider the 2-CQ shown in the picture below.qTt1Ff 1Tt2Tt3Ff 2Take two copies q1 and q2 of q in W. If we choose the contacts t 1 = t1contacts of W are in F1, f 1 = f 1, then we do have the following h : q → I homomorphism:I1 , t 2 = t23, f 2 = f 12 , and I is such that all 26O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Tq2FTTIFt 2 = f 1hFTFq1TTTqFTo make the search space for contacts smaller and exclude cases like in Example 27.2, we make the following assump-tions. To begin with, we assume thatt1 ≺ f 1(21)(as the other case is symmetric). We also assume that the contacts of the n-cogwheel W have the following properties:q j f j, for every j with 1 ≤ j ≤ n;t j ≺if t j+1 = t j+1 and f j = f j, then t ≺ f , for all j with 1 ≤ j ≤ n.(22)(23)(Note that (23) does not hold in Example 27.2, as t3 ⊀ f 1.) For each j, the nodes preceding t j in q j form its initial cog, while the nodes succeeding f j in q j form its final cog.The following general criterion still gives us quite some flexibility in designing cogwheels:Lemma 27.3. Suppose W is an n-cogwheel for some n ≥ |q| satisfying (22) and (23). For any model I of cov A and W, we have I (cid:14)|= qiff the contacts in I are either all in Tor all in FII.Proof. (⇒) Suppose the contact f i−1 = t i is in TIby induction that all of the contacts in W are in Tf i−2 = t i−1 is also in FI. Since I (cid:14)|= q, the ‘clockwise next’ contact f i = t i+1 is also in TI. It follows , then the ‘anti-clockwise next’ contact . If the contact f i−1 = t i is in FIII, from which it follows by induction that all of the contacts are in F(⇐) First, suppose that I is a model of cov A and W such that all contacts in I are in F.. The proof is via excluding all possible locations in W for the image h(q) of a potential subhomomorphism h : q → I. As n ≥ |q|, we may consider h(q) as a path CQ, so (cid:29)h(q) and δh(q) are well-defined. Observe that if t and f are such that t j = t j and f j = f j for some j then, by the definition of the minimal model I, we clearly cannot have that h(t) = t j and h( f ) = f j . In particular, there is no q → Isubhomomorphism mapping q onto any of the q j , and so h(q) must intersect with at least two copies of q in W. Further, by (23), there is not enough room for h(q) to start in an initial cog and then, after reaching a contact, to finish in a final cog (like in Example 27.2).ISo, without loss of generality, we may assume that there is some k such that 2 ≤ k < n,h(q) intersects each of the copies q1, . . . , qk,q1 h(bq) ≺b1qh(q) ∩ qk (cid:14)= {t k}.q1 f 1, and≺(24)(25)(26)t 1q1h(q)f 1t 2q2q1q3f 2t 3f k−1t k. . .qkq2qk−1qkf kNow, consider the sub-ABox H of W consisting of the copies q1, . . . , qk. For any (cid:16) with 1 ≤ (cid:16) ≤ k, let ι(cid:16) : q(cid:16) → q be the isomorphism mapping each x(cid:16) to x. We define a function g← : ind(H) → ind(H) by taking g←(x) = hwhenever x is a node in q(cid:16), where we consider each contact c = f (cid:16) = t (cid:16)+1, for 1 ≤ (cid:16) < k, as a node in q(cid:16)+1, that is, g←(c) = g←(t (cid:16)+1) =(cid:6)(cid:5)ι(cid:16)+1(t (cid:16)+1). Throughout, we use the following property of g←, which is a straightforward consequence of the h-shift in h(20) and the similar property of the isomorphism ι(cid:16): for every (cid:16) with 1 ≤ (cid:16) ≤ k,(cid:6)(cid:5)ι(cid:16)(x)if y, z are both in the same copy q(cid:16), y, z (cid:14)= f (cid:16) whenever (cid:16) < k, and y (cid:29)q(cid:16) z,then g←( y) (cid:29)h(q) g←(z) and δq(cid:16) ( y, z) = δh(q)27(cid:5)(cid:6)g←( y), g←(z).(27)(29)(30)(cid:6)(cid:5)t (cid:16) j , y j. Let K < N be O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738As H is finite, there exists a ‘fixpoint’ of g←: a node x in H and a number N > 0 such that g Nfixpoint-cycle to the left.’ More precisely, we claim that←(x) = x. We ‘shift this there is a contact c with g N←(c) = c.(28)Indeed, let y0 = x, y1 = g←(x), y2 = g2←( y j) = y j for every j < N, and so if one of the y jis a contact, we are done with (28). So suppose otherwise. We cannot have that every y j is in q1, as otherwise, by (27) and (25), for every j ≤ N,← (x). Then g N←(x), . . . , y N−1 = g N−1(cid:6)q), g←( y j)(here + is modulo N). Therefore, by (26),q, y j) = δh(q)δq1 (b1g←(b1(cid:5)= δh(q)(cid:5)(cid:6)h(bq), y j+1)(cid:5)(cid:6)h(bq), y j+1)(cid:5)(cid:6)b1q, y j+1)< δq1= δq1there exists j < N such that y j is in q(cid:16) j and t (cid:16) j ≺q(cid:16) j y j, for some (cid:16) j > 1.(When (cid:16) j = 1, such a contact t (cid:16) j does not necessarily exist.) For j < N with (cid:16) j > 1, we set d j = δqsuch that(cid:16) jdK = min{d j | j < N and (cid:16) j > 1}(which is well-defined by (30)), and set c = f (cid:16)K −1 = t (cid:16)K . By (24), we have y j ≺definition of K and (27), for every j ≤ N, gj←(c) belongs to the same copy q(cid:16)K + j as y K + j , gq(cid:16) j f (cid:16) j whenever 1 < (cid:16) j < k. Thus, by the j←(c) (cid:29)q(cid:16)K + j y K + j , anddK = δq(cid:16)K + j(cid:5)g j←(c), y K + j(cid:6).It follows, in particular, that g N←(c) = c, as required in (28).g N←(c) belongs to the same copy q(cid:16)K as y K , and δq(cid:16)K(cid:5)g N←(c), y K(cid:6)= δq(cid:16)K (c, y K ). Therefore, It remains to show that (28) leads to a contradiction. Indeed, c ∈ FI(cid:6)(cid:5)ι(cid:16)(t (cid:16))Ithe minimality of I. On the other hand, we show by induction on j ≥ 1 that gthen g←(c) = hfor some (cid:16), and so g←(c) ∈ Tj−1← (c) ∈ Tthen g(cid:5)j−1j←(c) = hι(cid:16)← (c)gThe case of I with contacts in T(cid:6)(cid:5)ι(cid:16)(x)hg→(f (cid:16)) = hj−1← (c) is not a contact and ι(cid:16)by IH. Thus, gis in T, as h is a subhomomorphism.(cid:6)(cid:5)ι(cid:16)(f (cid:16))(cid:6)(cid:6)gg(cid:5)IIIis similar. Now we define a function g→ : ind(H) → ind(H) by taking again g→(x) =whenever x is a node in q(cid:16), but now we consider each contact c = f (cid:16) = t (cid:16)+1 as a node in q(cid:16), that is, g→(c) =. Then, in the proof of (28) for g→, we ‘shift the fixpoint-cycle to the right’. (cid:2)by our assumption, and so c cannot be in Tby I. If j = 1as ι(cid:16)(t (cid:16)) is a T -node in q and h is a subhomomorphism. If j > 1must be a T -node in q for some (cid:16). Therefore, , and so c = g N(cid:6)j−1← (c)j←(c) ∈ T←(c) ∈ T(cid:5)IIRemark 27.4. It is to be noted that if we make more specialised assumptions on the choice of contacts, then Lemma 27.3 can jhave a more straightforward proof. For example, suppose that the n-cogwheel W satisfies (22) and f j = f1 , for all j with 1 ≤ j ≤ n. Given a model I such that all contacts of W have the same truth-value, we can show that no subhomomorphism h : q → I exists by excluding the possible locations of h( f 1):– h( f 1) cannot be a contact f j , otherwise h(t) is also a contact, for the T -node t with t j = t j ;– h( f 1) cannot be in the final cog of some q j , otherwise there is no room for h(q) in that cog; and– there are no other options for h( f 1), as there is no F -node preceding f 1 in q.Unfortunately, as illustrated in Example 27.6 below, we cannot always assume our n-cogwheels to be that simple.6.2. Representing negation by bikesFor each variable in the 3CNF ψ , we take a fresh pair of cogwheels W• and W◦ and connect them using two more fresh copies of q in a special way. We want to achieve that, for any model I of cov A and the resulting ‘two-wheel’ ABox, we have I (cid:14)|= q iff the two cogwheels W• and W◦ ‘represent’ opposite truth-values:either all contacts of W• are in FIand all contacts of W◦ are in TI,or all contacts of W• are in TIand all contacts of W◦ are in FI.(31)To this end, suppose W• and W◦ are two disjoint n-cogwheels, for some n > 4|q| + 2, built up from the q-copies q n, respectively. For i = 1, . . . , n and ∗ = •, ◦, we denote the contacts in ∗f i ; and t j•+1 in W••q 1, . . . , •for any node x in q, we denote by ∗q i . We pick two contacts •x i the copy of x in ∗t i•+1 and •q n and ◦q 1, . . . , ◦t i and ∗q i by ∗f j• = •f i• = •28O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738•q i•...q j•+1••t i•Af i•−1•••f j•+1At j•+2q i•+1•W••q j••F f•t i•+1Af i•••t j•+1A•f j••Tt◦F f◦f i◦At i◦+1◦Fq......t j◦+1Af j◦◦◦◦TtTqFig. 7. An n-bike B for q.◦q i◦W◦q j◦+1◦◦◦t i◦+2Af i◦+1◦f j◦−1At j◦◦q i◦+1◦...◦q j◦that are ‘far’ from each other in the sense that the contact-distance between them in W• is > 2|q|. Similarly, we pick two contacts ◦t j◦+1 in W◦ such that the contact-distance between them in W◦ is > 2|q|.t i◦+1 and ◦f j◦ = ◦f i◦ = ◦Next, let Fq, Tq be two more fresh and disjoint copies of q. For Z = F , T and any node x in q, we denote by Zx the ◦copy of x in Zq. We connect W• and W◦ via Fq and Tq as follows. First, we pick two F -nodes fwith fof Fq with the contact •t i•+1 of W•, and in q, and replace their F -labels by A. Then we glue together node F f• ≺ twith the contact ◦also glue together F fin q, and and tt j•+1 of W•, and also glue replace their T -labels by A. Then we glue together node Ttt j◦+1 of W◦. The resulting ABox B is called an n-bike (for q), see Fig. 7. We call the together Ttt i◦+1 F -connections in B; the F -neighbourhood of B consists of those contacts f i◦ = ◦contacts F ft j◦+1• = •whose contact-distance from an F -connection is ≤ |q|. Similarly, the contacts TtT-connections in B, and the T-neighbourhood of B consists of those contacts whose contact-distance from a T-connection is ≤ |q|.t i◦+1 of W◦. Finally, we pick two T -nodes tof Tq with the contact •with the contact ◦•f i• = •◦f j◦ = ◦◦ = ◦t j•+1 and Tt•f j• = •t i•+1 and F f◦• = •f j◦ = ◦f j• = •f i◦ = ◦f i• = •with t• ≺ fand f◦ = ◦◦•◦◦•Using Lemma 27.3 and the fact that the F -connections are F -nodes in Fq while the T-connections are T -nodes in Tq, it is straightforward to see that, for any n-bike B, if I is a model of cov A and B with I (cid:14)|= q, then (31) holds.However, for the converse implication to hold, we need to choose the contacts that are (a) the F -connections in Fq, (b)the T-connections in Tq, and (c) located in the F - and T-neighbourhoods in the two cogwheels of B carefully, in such a way that all possible locations in B for the image h(q) of a potential homomorphism h : q → I are excluded. So suppose Iis a model of cov A and B satisfies (31). We will again try to exclude all h : q → I subhomomorphisms. To begin with, as n > 4|q| > |q|, we may consider the image h(q) of q in I as a path CQ. If we choose all the contacts in (a)–(c) above in such a way that (22) and (23) hold for both cogwheels in B then, by Lemma 27.3, we know that h(q) must intersect with at least one of Fq and Tq. Therefore, the intersection of h(q) with any of the two n-cogwheels cannot go beyond their F -and T-neighbourhoods. Further, it is straightforward to see that because of (31),there is no subhomomorphism h : q → I such that h(f•) = F f, andthere is no subhomomorphism h : q → I such that h(t◦) = F fand h(f◦••) = Tt•and h(t◦) = Tt◦.(32)(In particular, there is no q → I subhomomorphism mapping q onto Fq or onto Tq.) Because of this, h(q) must properly intersect with at least one of the two n-cogwheels W• or W◦ in the sense that the intersection of h(q) and the cogwheel is not just a T- or F -connection. As the F -connections are of contact-distance > 2|q| from the T-connections, h(q) cannot intersect with both Fq and Tq at the same time. It is easy to check that, by (32), all options for such a h(q) are covered by the eight cases given in Fig. 8.We aim to show that, for every 2-CQ, suitable contact choices always exist by actually providing an algorithm that, given any 2-CQ q, describes contact choices that are suitable for an n-bike constructed from copies of q. For some 2-CQs the suitable contact choices are straightforward (even uniquely determined by (22) and (23)), for some others not so. In general, the different cases in Fig. 8 place different constraints on the suitable contact choices. There might even be some further interaction among these constraints because h(q) might intersect, say, the T-neighbourhoods of both cogwheels in B. These interactions, together with constraints (22) and (23), make finding a general solution a tricky cat-and-mouse game. We have tried several different ways of systematising the search for solutions, and ended up with the following choices in our ‘heuristics’ (with Remark 27.4 motivating (H2)):(H1) We try to choose all contacts in a way that results in as few cases as possible.(H2) In excluding possible locations for h(q), we aim to track h( f 1). So we aim to choose the contacts in such a way that leaves as few options for h( f 1) as possible.29O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738(1)T h(q) starts in W• and h(t•) ≺h(q)•Tt(2)T h(q) starts in Tq and ends in W••TtW•h(q)◦Tt. . .W◦Tqh(q)•TtW•◦TtW◦(3)T h(q) starts in W◦ and ends in Tq(4)T h(q) ends in W◦ and Tt◦ ≺h(q) h(t◦)•TtW•◦TtW◦h(q)Tqh(q). . .•TtW•◦TtW◦(1)F h(q) starts in W• and h(f•) ≺h(q)•F f(2)F h(q) starts in Fq and ends in W••F fW•h(q)◦F f. . .W◦Fqh(q)•F fW•◦F fW◦(3)F h(q) starts in W◦ and ends in Fq(4)F h(q) ends in W◦ and F f◦ ≺h(q) h(f◦)•F fW•◦F fW◦h(q)Fqh(q). . .•F fW•◦F fW◦TqTqFqFqFig. 8. Possible locations for h(q) intersecting Fq or Tq.In particular, in light of (H1) and (H2), we decided to go for ftwo options for h( f 1) in Fq: its two contacts ffor •t i◦+1 as illustrated by the following examples.t i•+1 and ◦or f•◦◦ = f 2 as F -connections. This leaves us with only . However, we still have to deal with case distinctions in the choices • = f 1 and fExample 27.5. (i) Consider the 2-CQqTt1Tt2Ff 1Ff 2If we choose •Iare in Tt i•+1 = •t i•+11and •f i•+1 = •f i•+11, and I is such that all contacts of W• are in FIand all contacts of W◦, then we do have the following h : q → I homomorphism (see case (2)F in Fig. 8):FqITIFF f 1 = •f i•+11TIF•f i•+11q i•+1•F. . . W•TThqTTNote that choosing •f i•+1 = •(ii) Consider the 2-CQf i•+12would not help.qTt1FTFf 2FTt2Ff 130O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738If we choose ◦Iare in Ft i◦+1 = ◦t i◦+11and ◦f i◦+1 = ◦f i◦+11, and I is such that all contacts of W• are in TIand all contacts of W◦, then we do have the following h : q → I homomorphism (see case (4)F in Fig. 8):q i◦+1◦FT. . . W◦TTIF◦f i◦+11FIFF f 2 = ◦t i◦+11FTFqTITF f 1hqTTTwould not help.Note again that choosing ◦f i◦+1 = ◦f i◦+12(iii) On the other hand, as shown in Lemma 27.7 below, the contact choices of •t i•+1 = •t i◦+1◦1, and ◦f i◦+1 = ◦f i◦+11are suitable for any of the following three 2-CQs:t i•+11, •f i•+1 = •f i•+11, ◦t i◦+1 =Tt1Tt2Ff 1Ff 2Tt1Ff 1Tt2Ff 2Tt1Ff 1Ff 2Tt2There are other sources of inherent case distinctions. For example, in light of Remark 27.4, it would be tempting to try (the copies of) f 1 as contacts throughout the F -neighbourhoods of W• and W◦. However, this is not always possible, as illustrated by the following examples.f i•Example 27.6. (i) Take any 2-CQ q that contains only two F -nodes. Thus, we must choose f1 , f i•then in case (2)F it is always possible to start h(q) in Fq, map f 1 to F f1 , and finish h(q) in the final cog of •• = f 1. If we choose •f i• = •f i• = •f 1 = •• = •q i• .(ii) Consider the 2-CQTt1Tt2Ff 1Ff 2Then we must choose fcontacts of W• are in Tcase (4)F in Fig. 8):• = f 1 and fI◦ = f 2, and so F fand all contacts of W◦ are in F• = F f 1 and F fI◦ = F f 2. If we choose ◦f i◦1 , and I is such that all , then we do have the following h : q → I homomorphism (see f i◦ = ◦TFqTThqITF f 1IFFF f 2 = ◦f i◦1◦f i◦2◦q i◦TFFThere are also examples showing that, unlike the F -connections, the T-connections cannot be chosen uniformly for all possible 2-CQs q. (The problems we face are not ‘symmetric counterparts’ of those with the F -connections because of our overall assumption that t1 ≺ f 1; see (21).) We hope that the above examples convince the reader that, even after fixing (H1) and (H2) (or any other heuristics), finding a general solution that satisfies (22) and (23) but excludes all cases in Fig. 8 for any 2-CQ q is quite a challenge. The following lemma describes such a solution found along the lines of (H1) and (H2):Lemma 27.7. Let B be an n-bike, for some n ≥ 4|q| + 2, built up from the n-cogwheels W• and W◦, each satisfying (22) and (23). Suppose B is such that the following hold for its T-connections:(cid:8)• = t1,t◦ =tt ,tlast,if f 1 ≺ tlast, where t is the first T -node succeeding f 1,if tlast ≺ f 1;the following hold for its T-neighbourhood:31O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738•t j• = •tj•(cid:2) , where t(cid:2) is the last T -node preceding f 1,•f j• =◦t j◦ = ◦tj◦1 ,◦f j◦ =(cid:8)◦◦ffif tlast ≺ f 1 and δ(tlast−1, tlast) = δ(tlast, f 1),j◦2 ,j◦1 , otherwise,(cid:8)••ffj•1 ,j•2 ,if f 1 ≺ tlast,if tlast ≺ f 1,∗t k = ∗t k1 ,∗f k = ∗f k1 ,for ∗ = •, ◦ and for any other k with j∗ − |q| ≤ k ≤ j∗ + |q|;the following hold for its F -connections:• = f 1,f◦ = f 2;fand the following hold for its F -neighbourhood, for ∗ = •, ◦:∗∗∗∗1∗,f i∗−kt i∗+(cid:16) =f i∗ = ∗∗for 0 < k ≤ |q|,f i∗2 ,f i∗−k = ∗t i∗ = ∗t i∗1 ,t i∗−kt i∗−k = ∗,1(cid:8)t i∗+(cid:16)∗1t i∗+(cid:16)∗(cid:2) , otherwise, where t(cid:2) is the last T -node preceding f 1,f i∗+(cid:16)f i∗+(cid:16)if tlast ≺ f 1 and δ( f 1, f 2) ≥ δ(t1, f 1),if tlast ≺ f 1 and δ( f 1, f 2) < δ(t1, f 1),, otherwise,f i∗+(cid:16) =(cid:8),,∗∗21for 1 ≤ (cid:16) ≤ |q|.Then, for any model I of cov A and B, we haveI (cid:14)|= q iffeither all contacts of W• are in TIand all contacts of W◦ are in FIor all contacts of W• are in FIand all contacts of W◦ are in TI.It is straightforward to check that n-bikes B satisfying the conditions of the lemma always exist: The F - and T-neighbourhoods of B can be kept disjoint by taking > 2|q| contact-distance between the F - and T-connections of each of the cogwheels in B and, by choosing, say, ∗2 for all other k and ∗ = •, ◦, conditions (22) and (23)f khold in both cogwheels.1 and ∗t kt k = ∗f k = ∗Proof. The implication (⇒) of Lemma 27.7 clearly holds for any n-bike B by the (⇒) direction of Lemma 27.3. To show (⇐), suppose B is as above, and I is a model of cov A and B such that (31) holds. The proof is via excluding all possible locations in B for the image h(q) of a potential subhomomorphism h : q → I. As we discussed above, we have the eight cases in Fig. 8. In line with (H2), in each of these eight cases, we track the location of h( f 1), and exclude all options for it. Throughout, our arguments will use the h-shift property in (20) without explicit reference.First, we deal with the cases when h(q) ∩ Tq (cid:14)= ∅:(1)T h(q) starts in W• and h(th(q). . .•TtW•Tt•.•) ≺h(q)◦TtTqW◦f••j•−k1•) ≺h(q)Then h(q) definitely properly intersects the T-neighbourhood of W•, and it might also properly intersect the T-T f 1. As •t j•+1 = •neighbourhood of W◦. It follows from h(tand tq j•−k for any k ≤ |q|, oth-t j•−k ≺•q j•−k•erwise there is not enough room for h(q) in that cog. As •for all k with 0 < k ≤ |q|, , otherwise h(t1) is also a contact of W•, contradicting (31). For h( f 1) cannot be a contact of W• different from Ttthe remaining options, we consider the two cases f 1 ≺ tlast and tlast ≺ f 1:Ttfor all k < |q|, h( f 1) cannot be in the initial cog of neither •that h( f 1) is in Tq then h( f 1) ≺Tqq j•+1 nor •j•−kf1If f 1 ≺ tlast then tt j• = •tW•. As •contradicting (31). As there is no F -node preceding f 1 in q, there are no other options for h( f 1) in W•., and so T f 1 ≺Tqj•1 , h( f 1) cannot be the contact Tt. As there is no F -node preceding T f 1 in Tq, h( f 1) is in 1 , otherwise h(t(cid:2)) is also a contact of W•, • = t1 and f 1 ≺ tt j•−k = •t(cid:2) and •j•f j•−k = •f j• = •j•+11and •j•−k1◦ = ◦Ttj◦◦◦•ff32O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738•q j••tj•(cid:2)q j•+1•Tt• = Tt1TqT f 1◦Tt•fj•1= •tj•+11W◦qt1 (cid:29) t(cid:2)no Ff 1If tlast ≺ f 1 then t• = t1 and th( f 1) is either in W• or in W◦.◦ = tlast = t(cid:2), and so Tt◦ = Ttlast ≺TqT f 1. As there is no F -node preceding T f 1 in Tq, q j•+1•Tt• = Tt1Tt◦ = TtlastT f 1T f 2Tq•fj•2•fj•1•q j••t(cid:2) = •j•tj•lastW◦f 1f 2qt(cid:2) = tlastno F– First, we exclude the remaining options in W•. As •otherwise both h(t(cid:2)) and h( f 2) are contacts of W•, contradicting (31). And if h( f 1) is the contact Ttwe track the location of h(tlast). As h(q) starts in W• and h(tlast) ≺h(q) h( f 1), h(tlast) is in W•. As •and t1 ≺ tlast, h(tlast) cannot be in the initial cog of •cog. Thus, we havej•1 , f• = •j•2 , then fj•+1t j•+1 = •t1q j•+1, otherwise there is not enough room for h(q) in that 2 , we cannot have h( f 1) = •(cid:2) and •j•t j• = •tf j• = •j•f(cid:5)h(tlast),(cid:6)•fj•2δh(q)= δh(q)(cid:5)(cid:6)h(tlast), h( f 1)= δ(tlast, f 1) < δ(tlast, f 2) = δ•q j•(cid:5)•tj•last,•fj•2(cid:6),and so h(tlast) is a node between •tpreceding f 2 in q is f 1, there are no other options for h( f 1) in W•.t(cid:2) and •= •tj•last2 . But there is no such T -node in •j•j•fq j• . As the only F -node •tj•lastht(cid:2) = tlast•fj•1•fj•2•q j•qf 1f 2no T– If h( f 1) is in W◦ then Ttwe have h(tlast) = h(tformer case, as •enough room for h(q) in that cog. Thus, we have◦) ≺h(q)Ttj•+1t j•+1 = •t1◦ = Ttlast (cid:29)h(q) h( f 1). We track the location of h(tlast). As h(t•) ≺h(q)by our assumption, •◦, and so either h(tlast) is in W• and h(tlast) ≺h(q), or h(tlast) is in Tq. In the Ttq j•+1, otherwise there is not and t1 ≺ tlast, h(tlast) cannot be in the initial cog of •Tt•(cid:5)h(tlast),(cid:6)•fj•2δh(q)= δh(q)(cid:5)h(tlast), Tt(cid:6)•(cid:5)(cid:6)h(tlast), h( f 1)=< δh(q)δ(tlast, f 1) < δ(tlast, f 2) = δ•q j•(cid:5)•tj•last,•fj•2(cid:6),and so h(tlast) is a node between •tj•last= •tj•t(cid:2) and •fj•2 . But there is no such T -node in •q j• .33O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738•q j••tj•last•fj•1•TtTq Tt◦ht(cid:2) = tlast•fj•2no Tf 1f 2. . . W◦qSo suppose that h(th(t1) cannot be in the initial cog of •have◦) = h(tlast) is in Tq. Now we track the location of h(tj•+1, 1q j•+1, otherwise there is not enough room for h(q) in that cog. Thus, we •) = h(t1) in W•. As •t j•+1 = •t(cid:5)h(t1),(cid:6)•fj•2δh(q)= δh(q)(cid:5)h(t•), Tt(cid:6)•(cid:6)◦(cid:5)h(t◦), Tt= δTq(cid:5)(cid:6)h(tlast), h( f 1)(cid:6)(cid:5)h(tlast), Ttlast= δTq= δ(tlast, f 1) ≺ δ(tlast, f 2) = δ•q j•≤(cid:5)•tj•last,•fj•2(cid:6),δh(q)and so h(t1) is a node between •tj•last and •fj•2 . But there is no such T -node in •q j• .. . .W••tj•last•fj•1Tt1TqTtlastht1•fj•2no Ftlastf 1f 2no T. . . W◦q(2)T h(q) starts in Tq and ends in W•.•◦h(q)TtTtTqW•W◦• = t1 and t1 ≺ f 1 by (21), h( f 1) is in W• and Then h(q) properly intersects the T-neighbourhood of W• only. As t• = Tt1 (cid:29)h(q) h( f 1), otherwise there is not enough room for h(q) in Tq. Now we track the location of h(t1). Again, Tt• = Tt1 (cid:29)h(q) h(t1) and otherwise there is not enough room for h(q) in Tq. As the part of qh(t1) is in W• and Ttpreceding t1 is empty (containing no F - or T -nodes), if h : q → I is a subhomomorphism, then we can modify it to obtain a subhomomorphism from q to the restriction of I to W•, which contradicts Lemma 27.3 by (31).(3)T h(q) starts in W◦ and ends in Tq.•◦TtTth(q)TqW•W◦Then h(q) properly intersects the T-neighbourhood of W◦ only. As ◦cog of ◦k with 0 < k ≤ |q|, h( f 1) cannot be a contact of W◦ different from Tt(31). To exclude the remaining options, we consider the two cases f 1 ≺ tlast and tlast ≺ f 1:q j◦+1, otherwise there is not enough room for h(q) in that cog. As ◦, h( f 1) cannot be in the initial j◦−kand ◦for all 1, otherwise h(t1) is also a contact, contradicting t j◦+1 ≺◦q j◦+1If f 1 ≺ tlast then T f 1 ≺Tqt j◦ = ◦◦tdicting (31). As there is no F -node preceding f 1 in q, there are no other options for h( f 1) in W◦.j◦1 , h( f 1) cannot be the contact Tt, and so h( f 1) cannot be in Tq, otherwise there is not enough room for h(q) in Tq. As 1 , otherwise h(t1) is also a contact of W◦, contra-j◦+1f1t j◦−k = ◦t1 and ◦f j◦−k = ◦f j◦ = ◦j◦−k1◦ = ◦Ttj◦j◦◦◦◦fffIf tlast ≺ f 1 then t◦ = tlast, and so Tt◦ = Ttlast ≺TqT f 1. As there is no F -node preceding T f 1 in Tq, either h( f 1) (cid:29)h(q)◦Ttand h( f 1) is in W◦, or h( f 1) = T f 1, otherwise there is not enough room for h(q) in Tq. We will exclude both:fj◦f j◦ = ◦– Suppose first that h( f 1) is in W◦. As ◦1 or ◦then because otherwise h(t1) is also a contact of W◦, and if ◦j◦1 : If ◦then because otherwise both h(t1) and h( f 2) are contacts of W◦, contradicting (35) in both cases. As the only F -node preceding f 2 in qis f 1, the only remaining option for h( f 1) being in W◦ is when h( f 1) = ◦j◦2 . Now we track the location of h(tlast).2 , we cannot have h( f 1) = ◦ff j◦ = ◦is either ◦1 and ◦t j◦ = ◦tf j◦ = Ttf j◦ = ◦j◦j◦j◦j◦◦12ffff34O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738◦tj◦last◦fj◦1Tt◦ = Ttlast◦fj◦2htlastf 1no Tqf 2t j◦+1 = ◦tAs ◦that cog. Thus, we havej◦+11, h(tlast) cannot be in the initial cog of ◦q j◦+1, otherwise there is not enough room for h(q) in (cid:5)h(tlast),(cid:6)◦fj◦2δh(q)= δh(q)(cid:5)(cid:6)h(tlast), h( f 1)= δ(tlast, f 1) < δ(tlast, f 2) = δ◦q j◦(cid:5)◦tj◦last,◦fj◦2(cid:6).t j◦ = ◦tAs ◦j◦1so h( f 1) cannot be in W◦.≺◦q j◦◦tj◦last, it follows that h(tlast) is between ◦tj◦last and ◦fj◦2 . But there is no such T -node in ◦q j◦ , and – If h( f 1) = c f 1 then h(tlast) = Ttlast = Ttj◦+1. We track the location of h(tlast−1). As ◦1be in the initial cog of ◦q j◦+1, otherwise there is not enough room for h(q) in that cog. As ◦tf j◦ = h(tlast), we have ◦◦j◦t1only T -node succeeding tlast−1 in q). Therefore,f j◦ , and so h(tlast−1) = ◦t≺◦q j◦ h(tlast−1) ≺◦q j◦, h(tlast−1) cannot ◦j◦(cid:29)◦q j◦≺◦q j◦flastlast must hold (as tlast is the t j◦+1 = ◦tj◦last−1(cid:29)◦q j◦◦tj◦j◦◦◦1δ(tlast−1, tlast) = δh(q)(cid:6)(cid:5)h(tlast−1), h(tlast)=(cid:8)=(cid:5)(cid:5)◦t◦tδ◦q j◦δ◦q j◦with both cases being impossible.(cid:6)(cid:6)ffj◦2j◦1= δ(tlast, f 2),= δ(tlast, f 1),if δ(tlast−1, tlast) = δ(tlast, f 1),if δ(tlast−1, tlast) (cid:14)= δ(tlast, f 1),j◦last, ◦last, ◦j◦◦tj◦lasthT f 1T f 2TqTtlast◦f j◦tlast−1tlastf 1f 2no Tno Tq◦).◦ ≺h(q) h(t◦TtTq(4)T h(q) ends in W◦ and Tth(q). . .Tt•W•W◦f◦j◦+(cid:16)1(cid:29)◦q j◦+(cid:16)Then h(q) definitely properly intersects the T-neighbourhood of W◦, and it might also properly intersect the T-q j◦+(cid:16) for any neighbourhood of W•. As ◦(cid:16) ≤ |q|, otherwise there is not enough room for h(q) in that cog. As ◦for all (cid:16) with 1 ≤ (cid:16) ≤ |q|, h( f 1) cannot be a contact of W◦ different from Tt, otherwise h(t1) is also a contact, contradicting (31). As there is no F -node preceding f 1 in q, it follows that h( f 1) must be in Tq. To exclude the remaining options, we consider the two cases f 1 ≺ tlast and tlast ≺ f 1:f j◦+(cid:16) for all (cid:16) ≤ |q|, h( f 1) cannot be in the final cog of ◦j◦+(cid:16)t j◦+(cid:16) = ◦t1If f 1 ≺ tlast then t◦ ≺h(q) h(t◦ = t , where t is the first T -node succeeding f 1. As by our assumption h(q) ends in W◦ and ◦ = Tt . Now we track the location of h(t(cid:2)) for the last T -node t(cid:2)Ttpreceding f 1. As t1 (cid:29) t(cid:2) ≺ f 1, it follows that h(t(cid:2)) is between Tt(cid:2) and h( f 1), and so between Tt(cid:2) and Tt . But there is no such T -node in Tq.◦), it follows that T f 1 ≺Tq h( f 1) (cid:29)Tqf j◦+(cid:16) = ◦and ◦j◦+(cid:16)1Tt◦f35O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Tt• = Tt1Tt(cid:2)T f 1Tt = Tt◦Tqht(cid:2)qf 1t no TIf tlast ≺ f 1 then t◦ = tlast. As h(q) ends in W◦ and Tt◦ ≺h(q) h(t◦), it follows that Tt◦ ≺h(q) h(tlast) ≺h(q) h( f 1). Thus, h( f 1) cannot be in Tq, leaving us no options.Next, we deal with the cases when h(q) ∩ Fq (cid:14)= ∅:(1)F h(q) starts in W• and h(fh(q). . .•F fW•F f•.•) ≺h(q)◦F fFqW◦• = f 1, we have h( f 1) ≺h(q)t i•+1, h( f 1) cannot be in the initial cog of •f j•−k = •Then h(q) definitely properly intersects the F -neighbourhood of W•, and it might also properly intersect the F -•neighbourhood of W◦. As fF ffor either choice of •q i•+1, otherwise there is not enough room for h(q) in that cog. As •for all k with 0 < k ≤ |q|, h( f 1) cannot be a contact of W• different •f i•from F f2 , we cannot have h( f 1) = •f i•1 , otherwise both h(t1) and h( f 2) are contacts of W•, again contradicting (31). As the only F -node preceding f 2 in q is f 1, there are no more options for h( f 1).t j•−k = •t, otherwise h(t1) is also a contact of W•, contradicting (31). And as •and h( f 1) is in W•. As •t i•+1 ≺•q i•+11 and •t i•t i• = •f i• = •and •j•−k1f i•+1j•−k1•1f...W•q i•−2•q i•−1••f i•−21t i•−2•1t i•−1•1q•q i•q i•+1••f i•−11•t i•1hF f 1Fq•f i•1•f i•2t1no Ff 1f 2no FFq(2)F h(q) starts in Fq and ends in W•.•◦h(q)F fF fW•W◦Then h(q) properly intersects the F -neighbourhood of W• only. As fotherwise there is not enough room for h(q) in Fq. Thus, F ffor all (cid:16) ≤ |q|, h( f 1) cannot be in the final cog of •that cog. To exclude the remaining options, we consider the two cases f 1 ≺ tlast and tlast ≺ f 1:• = F f 1, f i•+(cid:16)•q i• for any (cid:16) ≤ |q|, otherwise there is not enough room for h(q) in • (cid:29)h(q) h( f 1) and h( f 1) is in W•. As •• = f 1, we cannot have h( f 1) ≺h(q)t i•+(cid:16)(cid:2)f 1. Thus, h( f 1) cannot be a contact of W• different from F fthere is no F -node preceding f 1 in q, the only remaining option for h( f 1) is h( f 1) = F fby (31). We track the location of h(t ) for the first T -node t succeeding f 1 in q.in Ffor all (cid:16) with 1 ≤ (cid:16) ≤ |q|, where t(cid:2) is the last T -node preceding , otherwise h(t(cid:2)) is also a contact, contradicting (31). As . Then all contacts of W• are If f 1 ≺ tlast then •F f(cid:29)•q i•+(cid:16)f i•+(cid:16) = •t i•+(cid:16) = •and •f i•+(cid:16)f i•+(cid:16)I••1136O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738Fq•f i•2•q i•f i•+1•1• = •t i•+1(cid:2)F ft i•+2•(cid:2)ht(cid:2)f 1no Tq i•+1•q i•+(cid:16)•t i•+(cid:16)•. . .•f i•+(cid:16)1. . .qt As •f i• = •2 , h(t ) cannot be in the final cog of •f i•q i• , otherwise h( f 2) is also in that cog and there is not enough room for h(q) in that cog (unlike in Example 27.6 (i)). Further, h(t ) cannot be a contact of W•, as all contacts of W•q i•+(cid:16) for some (cid:16) with are in F1 ≤ (cid:16) ≤ |q|. Then. As there is no T -node between t(cid:2) and f 1 in q, h(t ) must be in the final cog of •I(cid:5)•(cid:6), h(t )f i•+(cid:16)1δ•q i•+(cid:16)(cid:5)(cid:6), h(t )•F f= δh(q)(cid:5)(cid:6)h( f 1), h(t )< δh(q)= δ( f 1, t ) = δ•q i•+(cid:16)(cid:5)•f i•+(cid:16)1,t i•+(cid:16)•(cid:6),and so h(t ) is between •f i•+(cid:16)1and •t i•+(cid:16) . But there is no such T -node in •q i•+(cid:16).If tlast ≺ f 1 then there are two cases, depending on the relationship between δ( f 1, f 2) and δ(t1, f 1):t i•+(cid:16) = •– If δ( f 1, f 2) < δ(t1, f 1) then ••a contact of W• different from F fpreceding f 1 in q, the only remaining option for h( f 1) is h( f 1) = F ff i• = ••(unlike in Example 27.6 (i)). Thus,2 , h( f 2) cannot be in the final cog of •f i•, for all (cid:16) with 1 ≤ (cid:16) ≤ |q|. Thus, h( f 1) cannot be , otherwise h(t1) is also a contact, contradicting (31). As there is no F -node . Next, we track the location of h( f 2). As q i• , otherwise there is not enough room for h(q) in that cog f i•+(cid:16) = •and ••11f i•+(cid:16)t i•+(cid:16)(cid:5)t i•+1•1(cid:6), h( f 2)δh(q)= δh(q)(cid:5)(cid:6), h( f 2)•F f= δh(q)(cid:5)(cid:6)h( f 1), h( f 2)=and so h( f 2) is between •t i•+11δ( f 1, f 2) < δ(t1, f 1) = δ•q i p w+1and •f i•+11. But there is no such F -node in •q i•+1.•f i•2•q i••f i• = •t i•+11q i•+1•. . . W••f i•+11(cid:5)t i•+1•1,•f i•+11(cid:6),qt1no Fhf 1f 2– If δ( f 1, f 2) ≥ δ(t1, f 1) then •and •t i•+(cid:16) = •, for all (cid:16) with 1 ≤ (cid:16) ≤ |q|, where t(cid:2) is the last T -node preceding f 1. Thus, h( f 1) = •cannot hold for any (cid:16) with 1 ≤ (cid:16) ≤ |q|, otherwise both h(t(cid:2)) and h( f 2)are contacts of W•, contradicting (31). As the only F -node preceding f 2 in q is f 1, the only remaining option for h( f 1) is to be a contact of W•, that is, h( f 1) = •for some (cid:16) with 1 ≤ (cid:16) ≤ |q|. Again, we track the location of h( f 2). As •q i• , otherwise there is not enough room for h(q) in that cog. Thus,2 , h( f 2) cannot be in the final cog of •f i•f i•+(cid:16) = •f i• = •t i•+(cid:16)(cid:2)t i•+(cid:16)(cid:2)f i•+(cid:16)f i•+(cid:16)21(cid:5)(cid:6)t i•+(cid:16)•(cid:2) , h( f 2)δh(q)= δh(q)(cid:5)(cid:6)h( f 1), h( f 2)= δ( f 1, f 2) ≥ δ(t1, f 1) > δ(t(cid:2), f 1) = δ•q i•+(cid:16)(cid:5)t i•+(cid:16)•(cid:2) ,•f i•+(cid:16)1(cid:6).On the other hand,(cid:5)(cid:6)t i•+(cid:16)•(cid:2) , h( f 2)δh(q)= δh(q)(cid:5)(cid:6)h( f 1), h( f 2)= δ( f 1, f 2) < δ(t(cid:2), f 2) = δ•q i•+(cid:16)(cid:5)t i•+(cid:16)•(cid:2) ,•f i•+(cid:16)2(cid:6),and so h( f 2) is between •f i•+(cid:16)1and •f i•+(cid:16)2. But there is no such F -node in •q i•+(cid:16).37 O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738•f i•+(cid:16)−12q i•+(cid:16)−1•t i•+(cid:16)•(cid:2)•f i•+(cid:16)1•f i•+(cid:16)2q i•+(cid:16)•. . . W•qht(cid:2)f 1f 2no Fno F(3)F h(q) starts in W◦ and ends in Fq.•◦F fF fh(q)FqW•W◦Then h(q) properly intersects the F -neighbourhood of W◦ only. We have h(f, as otherwise there is no room ◦ = f 2, we have h( f 1) ≺h(q) h( f 2) (cid:29)h(q)and h( f 1) is in W◦. We can exclude all possible locations for h(q) in Fq. As fF ffor h( f 1) by the same argument as in case (1)F , with the F -neighbourhood of W◦ in place of the F -neighbourhood of W•.F f◦◦) (cid:29)h(q)◦(4)F h(q) ends in W◦ and F fh(q). . .F f•◦).◦ ≺h(q) h(f◦F fFqW•W◦Then h(q) definitely properly intersects the F -neighbourhood of W◦, and it might also properly intersect the F -◦ (cid:29)h(q) h( f 1)◦ = f 2, there is no F -node between F fneighbourhood of W•. As fand h( f 1) is in W◦. We can exclude all possible locations for h( f 1) by the same argument as in case (2)F , with the F -neighbourhood of W◦ in place of the F -neighbourhood of W•.in Fq, and so F f• = f 1 and fand F f•◦We excluded all possible locations in B for the image h(q) of a potential subhomomorphism h : q → I, which completes the proof of Lemma 27.7. (cid:2)6.3. Representing clauses with shared literalsSuppose ψ is a 3CNF with nψ clauses of the form (cid:2)1 ∨ (cid:2)2 ∨ (cid:2)3, where each (cid:2)i is a literal. We build an ABox Aq,ψ as follows. We let n ≥ (nψ + 2)(2|q| + 1) and, for each propositional variable p in ψ , we take a fresh n-bike Bp having n-cogwheels W p◦ and satisfying the conditions in Lemma 27.7. We pick three nodes v1, v2 and v3 in q such that each vz is a T -node or an F -node, and v1 ≺ v2 ≺ v3. We call these three nodes the special triple of q. Then, for every clause c = ((cid:2)c3 of the special 1triple in cq, and replace their F - or T -labels with A. Then, for z = 1, 2, 3, we glue vc3) in ψ , we proceed as follows. We take a fresh copy cq of q, consider the copies vcz to a contact2 and vc• , W p∨ (cid:2)c21, vc∨ (cid:2)c(p1) in W p(p2) in W p• iff either (cid:2)cz◦ iff either (cid:2)cz= p and vz is an F -node in q, or (cid:2)cz= p and vz is an T -node in q, or (cid:2)cz= ¬p and vz is a T -node in q;= ¬p and vz is a F -node in q.For example, if q looks like on the left-hand side of the picture below and c = (p ∨ ¬q ∨ r), then we obtain the graph shown on the right-hand side of the picture with the n-cogwheels depicted as circles:qTv1Fv2Fv3AW p◦AWq◦AWr•cq1, vc2 and vcWe call vc3 c-connections, while the c-neighbourhood consists of those contacts in each of the three n-cogwheels whose contact-distance from its c-connection is ≤ |q|. For different clauses c, c-connections ‘sharing’ the same n-cogwheel W in such a way that the c- and c-neighbourhoods are disjoint from each other and from the F -and T-neighbourhoods in W. (We can do this as n ≥ (nψ + 2)(2|q| + 1).) We treat the resulting labelled graph as an ABox, call it a (ψ, n)-gadget (for q), and denote it by Aq,ψ . Clearly, the size of Aq,ψ is polynomial in the sizes of q and ψ .The following lemma is a consequence of the definition of Aq,ψ , and the ‘easy’ (⇒) direction of Lemma 27.7., we pick the c- and c(cid:3)(cid:3)(cid:3)Lemma 27.8. If cov A, Aq,ψ (cid:14)|= q, then ψ is satisfiable.38O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738I• are in Tand all contacts of W pProof. Suppose I is a model of cov A and Aq,ψ such that I (cid:14)|= q. As for each variable p in ψ , the n-bike Bp satisfies the Iconditions in Lemma 27.7, either all contacts of the n-cogwheel W p, or all contacts of W p∨ (cid:2)c3) in ψ , there is 2z = 1, 2, 3 such that either vz is a T -node in q but vc. Define an assignment azz) = T for each clause c in ψ (and arbitrary otherwise). We claim that a is well-defined in the sense that by setting a((cid:2)cwe never set both a(p) = T and a(¬p) = T . Indeed, suppose otherwise. Suppose also that the former is because of (cid:2)c1z1 in a clause c1 and the latter because of (cid:2)c2z2 in a clause c2.ICase 1: vz1 is a T -node in q but vc1z1I. As I (cid:14)|= q, for every clause c = ((cid:2)c1I∈ T= p, by (p2) of the construction vc1, or vz is an F -node in q but vczand all contacts of W p◦ are in T∨ (cid:2)c◦ are in FI• are in F∈ F∈ FI. As a(p) = T implies that (cid:2)c1z1◦ are in Fz2 is a contact in W p. On the other hand, a(¬p) = T implies that (cid:2)c2z2I• are also in F• by (p1), and so all contacts in W pI, then vc2z2 is a contact in W p◦ by (p2), and so all contacts in W pz1 is a contact = ¬p. If vz2 is a , a contradiction. , a ◦ are in TIin the n-cogwheel W p◦ . So all contacts in W pT -node in q but vc2∈ Fz2And if vz2 is an F -node in q but vc2z2contradiction again., then vc2∈ TIICase 2: vz1 is an F -node in q but vc1z1Thus, the assignment a is well-defined and makes true at least one literal in every clause in ψ . (cid:2). This case is similar and left to the reader.∈ TIIt remains to find some conditions on Aq,ψ that would guarantee that the converse of Lemma 27.8 also holds. So suppose that ψ is satisfiable under an assignment a. We define a model Ia of cov A and Aq,ψ as follows:For every variable p in ψ , we putall contacts of W pall contacts of W p• to F• to TIa and all contacts of W pIa and all contacts of W p◦ to F◦ to TIa , whenever if a(p) = T ; andIa , whenever if a(p) = F .(33)We aim to find some conditions on Aq,ψ that would imply Ia (cid:14)|= q. Just like in the case of other ABoxes built up from copies of q before, we are looking for conditions that exclude all possible locations in Aq,ψ for the image h(q) of a potential sub-homomorphism h : q → Ia. The definition of Aq,ψ allows flexibility– in the choice of the special triple v1, v2, v3 in q, and– also in the choices of the contacts in the c-neighbourhoods, for each clause c.If we choose all these contacts in such a way that (22), (23) and the conditions of Lemma 27.7 hold then, by (33) and Lemma 27.7, we know that h(q) must intersect with at least one cq for some clause c. Therefore, the intersection of h(q)with any of its n-cogwheels cannot go beyond its c-neighbourhoods. Further, we claim that,• , or vz is a T -node in q but vczfor any clause c in ψ , there is no subhomomorphism h : q → Ia such that h(vz) = vcIa as it is in W p= ¬p is dually symmetric. It follows that a((cid:2)c(34)(In particular, there is no q → Ia subhomomorphism mapping q onto cq.) Indeed, suppose on the contrary that there is = p, then either vz is an F -node in q but such a subhomomorphism h for some c. Suppose a((cid:2)c∈ Tvcz. The case zof (cid:2)czBy (34), h(q) must properly intersect with at least one of the three n-cogwheels Wc3 glued to cq in the sense that h(q) ∩ Wcz for any z = 1, 2, 3. zAlso by Lemma 27.3, we may assume that if h(q) properly intersects with Wcz is in the (cid:3)c-neighbourhood of Wc-neighbourhoods are disjoint, there is a unique c with h(q) properly the c- and cintersecting with one or two of the n-cogwheels Wc1, Wc3 glued to cq (it cannot properly intersect with all three). It is easy to check that, by (34), all options for such a h(q) are covered by the six cases (1)c –(6)c in Fig. 9.} for some z = 1, 2, 3. By (33) and Lemma 27.3, we may assume that h(q) (cid:5) Wcz) (cid:14)= T for any z = 1, 2, 3, contrary to a satisfying ψ .z) = T for some a. If (cid:2)cIa as it is in W p∈ F◦ , both are impossible when h(vz) = vcz , then every node in h(q) ∩ Wcz for all z = 1, 2, 3.z . As for c (cid:14)= c2 and Wc2 and Wc1, Wc(cid:5) {vczz(cid:3)We aim to show that for every 2-CQ suitable contact choices always exist by actually providing an algorithm that, given any 2-CQ q, describes contact choices that, for large enough n, are suitable for any 3CNF ψ and any (ψ, n)-gadget constructed from copies of q. Just like in case of bikes, the different potential locations of a homomorphic image place different constraints on our choices. By following our heuristics choices (H1) and (H2) above, we will be able to use the same techniques as for bikes in the proof of Lemma 27.7. In light of (H1), our algorithm chooses v1 = t1. This is because our assumption throughout is that t1 ≺ f 1 (cf. (21)), and so t1 is the only node that is followed by at least two other F -or T -nodes (tlast and f 1) in every 2-CQ q, even if q contains only two F -nodes and two T -nodes. Similarly, v3 is chosen to be f 2, as in general f 2 is the only node that is preceded by at least two other F - or T -nodes (t1 and f 1). And then v2 is chosen from the two ‘middle’ nodes that are always present, either tlast or f 1. The choice of the ≺-smaller of tlast and f 1 as v2 is motivated by (H2).However, now the 3CNF ψ introduces some more ‘variables’ into our constraint system. In order to reduce the search space, we made some further choices in our heuristics:(H3) Given any 2-CQ q and any assignment a satisfying some 3CNF ψ , we give an algorithm describing choices suitable for achieving Ia (cid:14)|= q for any q such that the choices do not depend on ψ and a, only on q.39O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738(1)c h(q) starts in W1 and h(v1) ≺h(q) vc1(2)c h(q) starts in cq and ends in W1vc1W1h(q)vc2. . .W2vc3W3(3)c h(q) starts in W2 and h(v2) (cid:29)h(q) vc2vc1W1(5)c h(q) starts in W3vc1W1vc2W2vc2W2h(q)vc3. . .W3vc3W3cqcqh(q)vc1W1vc2W2(4)c h(q) ends in W2 and vc2(cid:29)h(q) h(v2)h(q). . .vc1W1vc2W2h(q)cq(6)c h(q) ends in W3 and vc3≺h(q) h(v3)vc1W1h(q). . .vc2W2cqcqcqvc3W3vc3W3vc3W3Fig. 9. Possible locations for h(q) intersecting cq.(H4) The algorithm chooses the contacts in the c-neighbourhoods of Aq,ψ uniformly, not depending on the particular clause c, but only on q.Yet another difficulty is that (34) is weaker than (32): It does not exclude cases when h ‘fixes’ two (but not all three) c-connections. Say, in case (3)c it can happen that h(q) intersects W2 and W3, at least one of them properly, it does not intersect W1, and both h(v2) = vc3 hold. The following example shows how the need for excluding such a situation might ‘force’ particular contact choices not only for the c-connection of the ‘middle’ cogwheel, but also throughout‘half’ of its c-neighbourhood:2 and h(v3) = vcExample 27.9. Consider again the 2-CQ from Example 27.2.qTt1Ff 1Tt2Tt3Ff 2According to the above, as f 1 ≺ tlast = t3, we choose v2 = f 1 (and v1 = t1, v3 = f 2). Suppose that, for some clause c, the = c f 1 is 2f x2 , in some copy 2q x2 of q. Then the argument in contact in the ‘middle’ cogwheel W2 glued together with vc2Example 27.6 (i) shows that we cannot choose 2f x2 = 2 f x22 . Now we have three choices for 2t x2 . However, if we choose either 2t x2 = 2t x22 , and Ia is such that all contacts of W1, W2 and W3 are in Ia , then we do have the following h : q → Ia homomorphism (see case (3)c in Fig. 9):F1 , and so we must have 2f x2 = 2 f x21 or 2t x2 = 2t x2T2q x2F2q x2−1. . .W22t x2−12t x22f x2−1cqTTqTTTIa c f 2FIa c f 1F2 f x22W3FTTFTherefore, 2t x2 = 2t x23 must hold. Let us continue with some other contact choices in the c-neighbourhood of W2. In light of Remark 27.4, we might want to stick to the ‘default’ contact choice for 2q x2−1, and choose 2f x2−1 = 2 f x2−1. Then, as 2t x2−1 ≺2q x2. However, in this case (23) fails, and there is a h : q → Iahomomorphism, as shown in Example 27.2. In fact, by repeating the above argument, we obtain that we must choose 2f x2−k = 2 f x2−k2f x2−1 by (22), we must choose 2t x2−1 = 2t x2−1and 2t x2−k = 2t x2−k, for every k ≤ |q|.−1112340O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738In Lemma 27.10 below, we describe a general algorithmic solution to the constraint system along the lines of (H1)–(H4), and show that for this solution the converse of Lemma 27.8 holds. In order to formulate our solution, we need to fix some notation for c-neighbourhoods. With a slight abuse of notation in light of (H4), for any given clause c in ψ , we denote by z of cq is glued to. For each z = 1, 2, 3, Wz is built up from the q-copies W1, W2, W3 the three n-cogwheels the node vcz of cq with the contact zfxz = ztxz+1 of Wzzq1, . . . , zqn, and the c-connection of Wz is obtained by glueing together node vc(throughout, as before, ± is modulo n).cqvc1W1vc2W2vc3W3zq xz+1zq xzzq xzvczzf xzzt xz+1Wzzq xz−1...zq xz+1zq xz+2. . .For any node x in q, we denote by cx the copy of x in cq; and for i = 1, . . . , n and z = 1, 2, 3, we denote by zxi the copy of x in zq i . Recall that for any k, we let tk ( fk) denote the kth T -node (F -node) in q. In particular, tlast−1 denotes the last but one T -node in q, and tlast the last T -node. We again assume that t1 ≺ f 1 (cf. (21)), and let t(cid:2) denote the last T -node preceding f 1.Lemma 27.10. Given a 3CNF ψ , let Aq,ψ be a (ψ, n)-gadget, for some n ≥ (nψ + 2)(2|q| + 1), built up from n-bikes, each satisfying the conditions of Lemma 27.7. Suppose Aq,ψ is such that the following hold for its special triple:v1 = t1,v2 =(cid:8)f 1,tlast,if f 1 ≺ tlast,if tlast ≺ f 1,v3 = f 2;and for every clause c in ψ , the following hold for the c-neighbourhood in W1:(cid:8)1t x1 = 1t x1(cid:2) ,1f x1 =1t k = 1t k1 ,1f k = 1 f k1 ,if f 1 ≺ tlast,if tlast ≺ f 1,1 f x11 ,1 f x12 ,for any other k with x1 − |q| ≤ k ≤ x1 + |q|;the following hold for the c-neighbourhood in W2, for k ≤ |q| and 1 ≤ (cid:16) ≤ |q|:if f 1 ≺ tlast and there is a T -node t(cid:3) with t(cid:3) ≺ f 2 and δ(t(cid:3), f 2) = δ(t1, f 1),(cid:8)1,⎧⎪⎨2t x2−k =2f x2−k =2t x2−k(cid:3)2t x2−k2 f x2−k22 f x22 ,2 f x2−k2t x2+(cid:16)(cid:2)2t x2+(cid:16)2f x2+(cid:16) = 2 f x2+(cid:16)2t x2+(cid:16) =⎪⎩(cid:8);11,13t x3 = 3t x31 ,3t x3−k = 3t x3−k1(cid:8)3t x3+(cid:16) =(cid:8)3f x3+(cid:16) =,1,3t x3+(cid:16)3t x3+(cid:16)(cid:2)3 f x3+(cid:16)3 f x3+(cid:16)21, otherwise,,if f 1 ≺ tlast,if k = 0, tlast ≺ f 1 and δ(tlast−1, tlast) = δ(tlast, f 1),, otherwise,if f 1 ≺ tlast,if tlast ≺ f 1,3f x3 = 3 f x32 ,3f x3−k = 3 f x3−k,if tlast ≺ f 1 and δ( f 1, f 2) < δ(t1, f 1),for 0 < k ≤ |q|,1, otherwise,,if tlast ≺ f 1 and δ( f 1, f 2) ≥ δ(t1, f 1),, otherwise,for 1 ≤ (cid:16) ≤ |q|.the following hold for the c-neighbourhood in W3:Then Ia (cid:14)|= q, for any assignment a satisfying ψ .41O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738It is straightforward to check that (ψ, n)-gadgets Aq,ψ satisfying the conditions of the lemma always exist: As ψ has nψ -many clauses and n ≥ (nψ + 2)(2|q| + 1), for different clauses c, c-neighbourhoods of the same n-cogwheel W can be kept disjoint from each other and from the F - and T-neighbourhoods of W. Thus, choices for the present lemma do not interfere with the choices for Lemma 27.7. Also, by choosing (the corresponding copies of) t1 and f 2 as contacts outside the F -, T- and c-neighbourhoods, conditions (22), (23) hold for all cogwheels in Aq,ψ ., the c- and c(cid:3)(cid:3)Proof. Suppose a is an assignment satisfying ψ , and take the model of cov A and Aq,ψ defined in (33). In light of (H4), we do not use any specifics about the clause c, and so we do not have explicit information about the particular labelings of 3 in Ia. However, (33) still implies that each of the attached cogwheels W1, W2 and W3the c-connections vc1, vc‘represents’ a truth-value:2 and vcfor each z = 1, 2, 3, the contacts of Wz are either all in TIa or all in FIa .(35)Now the proof of Lemma 27.10 is via excluding all possible locations in Aq,ψ for the image h(q) of a potential sub-homomorphism h : q → Ia. As explained above, by (34), Lemmas 27.3 and 27.7, only the cases (1)c –(6)c in Fig. 9 remain for the location of h(q), and we need to show that none of them is possible. In light of (H2), we always track the location of h( f 1) and, whenever possible, try to reduce the cases to cases in the proof of Lemma 27.7 for bikes:(1)c h(q) starts in W1 and h(v1) ≺h(q) vc1.vc1h(q)vc2. . .W1W2cqvc3W3Then h(q) definitely properly intersects the c-neighbourhood of W1, and it might also properly intersect the c-neighbourhoods of W2 or W3. It follows from h(v1) ≺h(q) vcc f 1. We can exclude all possible locations for h( f 1) by the same argument as in case (1)T in the proof of Lemma 27.7, with the c-neighbourhood of W1 in place of the T-neighbourhood of W•.1 that if h( f 1) is in cq then h( f 1) ≺cq(2)c h(q) starts in cq and ends in W1.vc1h(q)vc2W1W2cqvc3W3Then h(q) properly intersects the c-neighbourhood of W1 only. We can exclude all possible locations for h( f 1)by the same argument as in case (2)T in the proof of Lemma 27.7, with the c-neighbourhood of W1 in place of the T-neighbourhood of W•.(3)c h(q) starts in W2 and h(v2) (cid:29)h(q) vc2.vch(q)1vc2W1W2. . .cqvc3W3Then h(q) definitely properly intersects the c-neighbourhood of W2, and it may also properly intersect the c-neighbourhood of W3. We consider the two cases f 1 ≺ tlast and tlast ≺ f 1:2. As 2f x2−k = 2 f x2−kIf f 1 ≺ tlast then v2 = f 1, and so h( f 1) (cid:29)h(q)cannot hold for any such k, otherwise both h(t) and h( f 2) are contacts of W2 for the T -node t with 2t x2−k = 2t x2−k, contradicting (35). Since the only F -node preceding f 2 in q is f 1, the only remaining option for h( f 1) is when h( f 1) = 2 f x2−kis a contact of W2 for some k ≤ |q|. Now we track the location of h(t1). We havefor all k ≤ |q|, h( f 1) = 2 f x2−kc f 1 = vc212(cid:5)h(t1), 2 f x2−k2(cid:6)δh(q)= δh(q)(cid:5)(cid:6)h(t1), h( f 1)= δ(t1, f 1) = δ( y, f 2) = δ2q x2−k(cid:5)2yx2−k, 2 f x2−k2(cid:6),(36)where y is the node in q with y ≺ f 2 and δ( y, f 2) = δ(t1, f 1). Consider two cases, depending on whether y is a T -node or not:– If y is a T -node t(cid:3), then 2t x2−k = 2t x2−k(cid:3) , and so h(t1) = 2t x2−k by (36). Thus, h(t1) is a contact, contradicting (35)and the fact that h( f 1) is also a contact of W2.– If y is not a T -node t(cid:3) then 2t x2−k = 2t x2−k1δ( y, f 2) = δ(t1, f 1) < δ(t1, f 2). Then h(t1) = 2yx2−k follows by (36). But 2yx2−k is not a T -node.. While y (cid:29) f 1 and f 1 ≺ y are both possible, we surely have t1 ≺ y, as If tlast ≺ f 1 then v2 = tlast. If follows from h(v2) (cid:29)h(q) vcc f 1. As there is no F -node preceding c f 1 in cq, either h( f 1) is in W2, or h( f 1) = c f 1. We can exclude all possible locations for h( f 1) by 2 that if h( f 1) is in cq then h( f 1) (cid:29)cq42O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738the same argument as in case (3)T in the proof of Lemma 27.7, with the c-neighbourhood of W2 in place of the T-neighbourhood of W◦.(4)c h(q) ends in W2 and vc2h(q). . .(cid:29)h(q) h(v2).vc2vc3vc1cqW1W2W3Then h(q) definitely properly intersects the c-neighbourhood of W2, and it might also properly intersect the c-neighbourhood of W1. We consider the two cases f 1 ≺ tlast and tlast ≺ f 1:If f 1 ≺ tlast then v2 = f 1, and so vc2= c f 1 (cid:29)h(q) h( f 1) and h( f 1) is in W2. We can exclude all possible locations for h( f 1) by the same argument as in case (2)F in the proof of Lemma 27.7, with the c-neighbourhood of W2 in place of the F -neighbourhood of W•.If tlast ≺ f 1 then v2 = tlast. As by our assumption h(q) ends in W2 and vc2(cid:29)h(q)h(tlast) ≺h(q) h( f 1). We can exclude all possible locations for h( f 1) by the same argument as in case (4)T in the proof of Lemma 27.7, with the c-neighbourhood of W2 in place of the T-neighbourhood of W◦.(cid:29)h(q) h(v2), if follows that vc2(5)c h(q) starts in W3.vc1W1vc2W2h(q)cqvc3W3Then h(q) properly intersects the c-neighbourhood of W3 only. We have h(v3) (cid:29)h(q) vc3, as otherwise there is no 3 and h( f 1) is in W3. We can exclude all possible room for h(q) in cq. As v3 = f 2, we have h( f 1) ≺h(q) h( f 2) (cid:29)h(q) vclocations for h( f 1) by the same argument as in case (1)F in the proof of Lemma 27.7, with the c-neighbourhood of W3 in place of the F -neighbourhood of W•.(6)c h(q) ends in W3 and vc3vc1W1≺h(q) h(v3).h(q). . .vc2W2cqvc3W3Then h(q) definitely properly intersects the c-neighbourhood of W3, and it may also properly intersect the ≺h(q) h( f 2). Therefore, if h( f 1) is in cq then c f 1 ≺ cq h( f 1). c-neighbourhood of W1 or W2. As v3 = f 2, we have c f 2 = vc3(cid:29)h(q) h( f 1) and h( f 1) is in W3. We As vc2can exclude all possible locations for h( f 1) by the same argument as in case (2)F in the proof of Lemma 27.7, with the c-neighbourhood of W3 in place of the F -neighbourhood of W•.c f 1 and there is no F -node between c f 1 and c f 2 in cq, it follows that vc3(cid:29) cqWe excluded all possible locations in Aq,ψ for the image h(q) of a potential subhomomorphism h : q → Ia, which completes the proof of Lemma 27.10. (cid:2)To complete the proof of Theorem 27, given a 3CNF ψ with nψ clauses, we set n = (nψ + 2)(2|q| + 1) and take some (ψ, n)-gadget Aq,ψ satisfying the conditions of Lemma 27.10. By Lemmas 27.8 and 27.10, we then obtain: cov A, Aq,ψ (cid:14)|= qiff ψ is satisfiable.7. ConclusionThis article contributes to the non-uniform approach to ontology-based data access, which—broadly conceived—also in-cludes optimisation of datalog and disjunctive datalog programs. There are three distinctive directions of research in this area (for detailed references, see Section 1.3):(I) Finding general automata-theoretic, model-theoretic or algebraic characterisations of OMQs with a given data com-plexity or rewritability type and investigating the computational complexity of checking those characterisations. As it turned out, for many standard DL ontology languages and monadic (disjunctive) datalog programs, the complexity of deciding FO- and datalog-rewritability ranges between ExpTime and 3ExpTime.(II) Designing practical (possibly incomplete) rewriting and approximation algorithms. For example, the algorithm from [28] either successfully rewrites a given disjunctive datalog program into an equivalent plain datalog program or fails to decide whether the input is datalog rewritable or not.(III) Obtaining explicit classifications of ‘natural’ restricted families of OMQs such as, for instance, binary chain datalog sirups [47]. Apart from supplementing (II), results in this direction help pinpoint key sources of the high complexity in(I) and thereby identify interesting and better behaved classes of OMQs, as well as develop fine methods of establishing data complexity bounds for OMQ answering.43O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738This article contributes to directions (I) and (III). We introduce two classes of rudimentary OMQs, called d- and dd-sirups, and show that they capture many difficulties of both general OMQs with a disjunctive DL ontology and general monadic (plain and disjunctive) datalog queries. Indeed, the syntactically very simple and seemingly inexpressive d-sirups reveal rather complex and unexpected behaviour: (i) answering them is (cid:2)p2 -complete for combined complexity and requires find-ing exponential-size resolution proofs in general; (ii) deciding their FO-rewritability turns out to be 2ExpTime-hard [44]—as hard as deciding FO-rewritability of arbitrary monadic datalog queries—with (iii) nonrecursive datalog, positive existential, and UCQ rewritings being of at least single-, double- and triple-exponential size in the worst case, respectively. Thus, un-derstanding the behaviour of d-sirups is challenging yet fundamental for developing OBDA with expressive ontologies (note that d-sirups also constitute a new interesting class of CSPs).The proofs of the ‘negative’ results mentioned above point to two ‘culprits’: possibly intersecting classes F and T in the covering axiom F (x) ∨ T (x) ← A(x), and multiple binary relations between the same pair of variables in a query. We demonstrate that elimination of these culprits can lead to non-trivial OMQ classes that admit complete explicit classifica-tions, though may need the development of new methods and quite tricky, laborious proofs. Our main achievement here is an explicit AC0 / NL/ P/ coNP-tetrachotomy of path-shaped dd-sirups (with disjoint F and T ), which required new tech-niques for establishing membership in NL and for proving P- and especially coNP-hardness. (Incidentally, the bike technique for proving coNP-hardness shows that the algorithm from [28] mentioned in (II) is complete for path-shaped dd-sirups.) We believe that these techniques can also be used for wider classes of OMQs, which is witnessed by the AC0 / L / NL-hardness trichotomy of ditree-shaped dd-sirups in [44].7.1. Next stepsInteresting and challenging problems arising from our research are abundant; here are some of them.1. Find complete explicit classifications of the following families of OMQs: (i) d-sirups with path CQs (that may contain F T -twins), (ii) undirected path-shaped, (iii) ditree- and (i v) undirected tree-shaped dd- and d-sirups. Also, consider (d)d-sirups (cov(cid:15), q) and (cov⊥(cid:15), q) with total covering ∀x (F (x) ∨ T (x)).2. Settle the tight complexity of deciding FO- and other types of rewritability for arbitrary (i) d-sirups and (ii) dd-sirups. We conjecture that (i) is harder than (ii) in general.3. Identify the complexity of deciding FO- and other types of rewritability to ontologies in (i) Schema .org and (ii) DL-Litekromand DL-Litebool [67]. Ontologies in (i) allow multiple disjunctions (and so covering by any number of classes); those in (ii) allow restricted existential quantification on the right-hand side of implications.4. Analyse the size of FO-rewritings for OMQs with disjunctive axioms (starting with d- and dd-sirups). Could FO-rewritings be substantially more succinct than NDL- and PE-rewritings (cf. [96, Theorem 6.1])? (Note that the succinctness problem for OMQ rewritings is closely related to circuit complexity [95,50].)5. Consider the (data complexity) and (rewritability) problems for d- and dd-sirups with multiple answer variables (which could lead to simpler classifications as indicated by [51]).6. Investigate interconnections between (d)d-sirups and CSPs (starting from those in [30,36]) with the aim of transferring results from one formalism to the other.7. Using the techniques developed in this article for establishing lower data complexity bounds, identify classes of OMQs for which rewriting algorithms such as the ones in [38,28] are complete.Declaration of competing interestThe authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.AcknowledgementsThe work of O. Gerasimova was funded by RFBR, project number 20-31-90123. The work of V. Podolskii was supported by the HSE University Basic Research Program. The work of M. Zakharyaschev was supported by the EPSRC U.K. grant EP/S032282. We are grateful to Frank Wolter for his remarks that helped us improve the article. Thanks are also due to the anonymous referees for their careful reading, valuable comments and constructive suggestions.References[1] A. Schaerf, On the complexity of the instance checking problem in concept languages with existential quantification, J. Intell. Inf. Syst. 2 (1993) 265–278.[2] F. Baader, D. Calvanese, D.L. McGuinness, D. Nardi, P.F. Patel-Schneider (Eds.), The Description Logic Handbook, 2 ed., Cambridge University Press, 2007.[3] F. Baader, I. Horrocks, C. Lutz, U. Sattler, An Introduction to Description Logic, Cambridge University Press, 2017.[4] A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, R. Rosati, Linking data to ontologies, J. Data Semant. X (2008) 133–173.[5] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, R. Rosati, Tractable reasoning and efficient query answering in description logics: the DL-Lite family, J. Autom. Reason. 39 (2007) 385–429.44O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738[6] G. Xiao, D. Calvanese, R. Kontchakov, D. Lembo, A. Poggi, R. Rosati, M. Zakharyaschev, Ontology-based data access: a survey, in: J. Lang (Ed.), Proc. IJCAI 2018, 2018, pp. 5511–5519, ijcai .org.[7] G. Xiao, L. Ding, B. Cogrel, D. Calvanese, Virtual knowledge graphs: an overview of systems and use cases, Data Intell. 1 (2019) 201–223.[8] S. Abiteboul, R. Hull, V. Vianu, Foundations of Databases, Addison-Wesley, 1995.[9] N. Immerman, Descriptive Complexity, Springer, 1999.[10] C. Civili, R. Rosati, A broad class of first-order rewritable tuple-generating dependencies, in: Proc. of the 2nd Int. Datalog 2.0 Workshop, in: Lecture Notes in Computer Science, vol. 7494, Springer, 2012, pp. 68–80.[11] G. Gottlob, G. Orsi, A. Pieris, Query rewriting and optimization for ontological databases, ACM Trans. Database Syst. 39 (2014) 25:1–25:46.[12] J. Baget, M. Leclère, M. Mugnier, E. Salvat, On rules with existential variables: walking the decidability line, Artif. Intell. 175 (2011) 1620–1654.[13] M. König, M. Leclère, M. Mugnier, M. Thomazo, Sound, complete and minimal UCQ-rewriting for existential rules, Semant. Web 6 (2015) 451–475.[14] U. Hustadt, B. Motik, U. Sattler, Data complexity of reasoning in very expressive description logics, in: L.P. Kaelbling, A. Saffiotti (Eds.), Proc. IJCAI 2005, Professional Book Center, 2005, pp. 466–471.[15] R. Rosati, On conjunctive query answering in EL, in: D. Calvanese, E. Franconi, V. Haarslev, D. Lembo, B. Motik, A. Turhan, S. Tessaris (Eds.), Proc. DL 2007, in: CEUR Workshop Proceedings, vol. 250, 2007, CEUR-WS .org.[16] H. Pérez-Urbina, B. Motik, I. Horrocks, Tractable query answering and rewriting under description logic constraints, J. Appl. Log. 8 (2010) 186–209.[17] T. Eiter, M. Ortiz, M. Šimkus, T. Tran, G. Xiao, Query rewriting for Horn-SHIQ plus rules, in: J. Hoffmann, B. Selman (Eds.), Proc. AAAI 2012, AAAI [18] D. Gabbay, A. Kurucz, F. Wolter, M. Zakharyaschev, Many-Dimensional Modal Logics: Theory and Applications, Studies in Logic and the Foundations of [19] B. Motik, Reasoning in description logics using resolution and deductive databases, Ph.D. thesis, Karlsruhe Institute of Technology, Germany, 2006.[20] U. Hustadt, B. Motik, U. Sattler, Reasoning in description logics by a reduction to disjunctive datalog, J. Autom. Reason. 39 (2007) 351–384.[21] B. Cuenca Grau, B. Motik, G. Stoilos, I. Horrocks, Computing datalog rewritings beyond Horn ontologies, in: F. Rossi (Ed.), Proc. IJCAI 2013, IJCAI/AAAI, Press, 2012.Mathematics, vol. 148, Elsevier, 2003.2013, pp. 832–838.[22] D. Hovland, R. Kontchakov, M.G. Skjæveland, A. Waaler, M. Zakharyaschev, Ontology-based data access to Slegge, in: C. d’Amato, M. Fernández, V.A.M. Tamma, F. Lécué, P. Cudré-Mauroux, J.F. Sequeda, C. Lange, J. Heflin (Eds.), Proc. ISWC 2017, Part II, in: Lecture Notes in Computer Science, vol. 10588, Springer, 2017, pp. 120–129.[23] D. Carral, C. Feier, B. Cuenca Grau, P. Hitzler, I. Horrocks, EL-ifying ontologies, in: S. Demri, D. Kapur, C. Weidenbach (Eds.), Proc. IJCAR 2014, in: Lecture Notes in Computer Science, vol. 8562, Springer, 2014, pp. 464–479.[24] Y. Zhou, B. Cuenca Grau, Y. Nenov, M. Kaminski, I. Horrocks, PAGOdA: pay-as-you-go ontology query answering using a datalog reasoner, J. Artif. Intell. Res. 54 (2015) 309–367.[25] E. Botoeva, D. Calvanese, V. Santarelli, D.F. Savo, A. Solimando, G. Xiao, Beyond OWL 2 QL in OBDA: rewritings and approximations, in: D. Schuurmans, M.P. Wellman (Eds.), Proc. AAAI 2016, AAAI Press, 2016, pp. 921–928.[26] A. Bötcher, C. Lutz, F. Wolter, Ontology approximation in Horn description logics, in: S. Kraus (Ed.), Proc. IJCAI 2019, 2019, pp. 1574–1580, ijcai .org.[27] E. Kharlamov, D. Hovland, M.G. Skjæveland, D. Bilidas, E. Jiménez-Ruiz, G. Xiao, A. Soylu, D. Lanti, M. Rezk, D. Zheleznyakov, M. Giese, H. Lie, Y.E. Ioannidis, Y. Kotidis, M. Koubarakis, A. Waaler, Ontology based data access in Statoil, J. Web Semant. 44 (2017) 3–36.[28] M. Kaminski, Y. Nenov, B. Cuenca Grau, Datalog rewritability of disjunctive datalog programs and non-Horn ontologies, Artif. Intell. 236 (2016) 90–118.[29] C. Lutz, F. Wolter, Non-uniform data complexity of query answering in description logics, in: G. Brewka, T. Eiter, S.A. McIlraith (Eds.), Proc. KR 2012, [30] M. Bienvenu, B. ten Cate, C. Lutz, F. Wolter, Ontology-based data access: a study through disjunctive datalog, CSP, and MMSNP, ACM Trans. Database [31] T. Feder, M.Y. Vardi, The computational structure of monotone monadic SNP and constraint satisfaction: a study through datalog and group theory, [32] A.A. Bulatov, A dichotomy theorem for nonuniform CSPs, in: C. Umans (Ed.), Proc. FOCS 2017, IEEE Computer Society, 2017, pp. 319–330.[33] D. Zhuk, A proof of CSP dichotomy conjecture, in: C. Umans (Ed.), Proc. FOCS 2017, IEEE Computer Society, 2017, pp. 331–342.[34] C. Lutz, L. Sabellek, Ontology-mediated querying with the description logic EL: trichotomy and linear datalog rewritability, in: C. Sierra (Ed.), Proc. IJCAI [35] C. Lutz, L. Sabellek, A complete classification of the complexity and rewritability of ontology-mediated queries based on the description logic EL, CoRR, [36] C. Feier, A. Kuusisto, C. Lutz, Rewritability in monadic disjunctive datalog, MMSNP, and expressive description logics, Log. Methods Comput. Sci. 15 [37] P. Hansen, C. Lutz, I. Seylan, F. Wolter, Efficient query rewriting in the description logic EL and beyond, in: Proc. IJCAI 2015, AAAI, 2015, pp. 3034–3040.[38] M. Kaminski, B. Cuenca Grau, Sufficient conditions for first-order and datalog rewritability in ELU, in: T. Eiter, B. Glimm, Y. Kazakov, M. Krötzsch (Eds.), Proc. DL, in: CEUR Workshop Proceedings, vol. 1014, 2013, pp. 271–293, CEUR-WS .org.[39] S. Arora, B. Barak, Computational Complexity: A Modern Approach, 1st ed., Cambridge University Press, 2009.[40] S.S. Cosmadakis, P.C. Kanellakis, Parallel evaluation of recursive rule queries, in: A. Silberschatz (Ed.), Proc. PODS 1986, ACM, 1986, pp. 280–293.[41] M.Y. Vardi, Decidability and undecidability results for boundedness of linear recursive queries, in: C. Edmondson-Yurkanan, M. Yannakakis (Eds.), Proc. PODS 1988, ACM, 1988, pp. 341–351.[42] G. Gottlob, C.H. Papadimitriou, On the complexity of single-rule datalog queries, Inf. Comput. 183 (2003) 104–122.[43] P.C. Kanellakis, Elements of relational database theory, in: J. van Leeuwen (Ed.), Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics, Elsevier and MIT Press, 1990, pp. 1073–1156.[44] S. Kikot, A. Kurucz, V. Podolskii, M. Zakharyaschev, Deciding boundedness of monadic sirups, in: Proc. PODS 2021, ACM Press, 2021.[45] S.S. Cosmadakis, H. Gaifman, P.C. Kanellakis, M.Y. Vardi, Decidable optimization problems for database logic programs, in: Proc. STOC 1988, 1988, pp. 477–490.[46] M. Benedikt, B. ten Cate, T. Colcombet, M. Vanden Boom, The complexity of boundedness for guarded logics, in: Proc. LICS 2015, 2015, pp. 293–304.[47] F.N. Afrati, C.H. Papadimitriou, The parallel complexity of simple logic programs, J. ACM 40 (1993) 891–916.[48] S.S. Dantchev, S. Riis, “Planar” tautologies hard for resolution, in: Proc. FOCS 2001, IEEE Computer Society, 2001, pp. 220–229.[49] M. Alekhnovich, Mutilated chessboard problem is exponentially hard for resolution, Theor. Comput. Sci. 310 (2004) 513–525.[50] M. Bienvenu, S. Kikot, R. Kontchakov, V. Podolskii, M. Zakharyaschev, Ontology-mediated queries: combined complexity and succinctness of rewritings via circuit complexity, J. ACM 65 (2018) 28:1–28:51.[51] A. Hernich, C. Lutz, A. Ozaki, F. Wolter, Schema.org as a description logic, in: Q. Yang, M.J. Wooldridge (Eds.), Proc. IJCAI 2015, AAAI Press, 2015, pp. 3048–3054.[52] J.D. Ullman, Principles of Database and Knowledge-Base Systems, Volume II, Computer Science Press, 1989.[53] O. Gerasimova, S. Kikot, A. Kurucz, V. Podolskii, M. Zakharyaschev, A data complexity and rewritability tetrachotomy of ontology-mediated queries with a covering axiom, in: D. Calvanese, E. Erdem, M. Thielscher (Eds.), Proc. KR 2020, 2020, pp. 403–413.45AAAI Press, 2012.Syst. 39 (33) (2014) 1–44.SIAM J. Comput. 28 (1998) 57–104.2017, 2017, pp. 1181–1187, ijcai .org.arXiv:1904 .12533 [abs], 2019.(2019).O. Gerasimova, S. Kikot, A. Kurucz et al.Artificial Intelligence 309 (2022) 103738[54] J.F. Naughton, Data independent recursion in deductive databases, in: A. Silberschatz (Ed.), Proc. PODS 1986, ACM, 1986, pp. 267–279.[55] J.D. Ullman, A.V. Gelder, Parallel complexity of logical query programs, Algorithmica 3 (1988) 5–42.[56] J.F. Naughton, Minimizing function-free recursive inference rules, J. ACM 36 (1989) 69–91.[57] R. Ramakrishnan, Y. Sagiv, J.D. Ullman, M.Y. Vardi, Proof-tree transformation theorems and their applications, in: A. Silberschatz (Ed.), Proc. PODS 1989, ACM Press, 1989, pp. 172–181.[58] Y.P. Saraiya, Linearizing nonlinear recursions in polynomial time, in: A. Silberschatz (Ed.), Proc. PODS 1989, ACM Press, 1989, pp. 182–189.[59] K. Wang, Some positive results for boundedness of multiple recursive rules, in: G. Gottlob, M.Y. Vardi (Eds.), Proc. ICDT 1995, in: Lecture Notes in Computer Science, vol. 893, Springer, 1995, pp. 383–396.[60] E. Dantsin, T. Eiter, G. Gottlob, A. Voronkov, Complexity and expressive power of logic programming, ACM Comput. Surv. 33 (2001) 374–425.[61] Y.E. Ioannidis, A time bound on the materialization of some recursively defined views, in: A. Pirotte, Y. Vassiliou (Eds.), Proc. VLDB 1985, Morgan Kaufmann, 1985, pp. 219–226.[62] R. van der Meyden, Predicate boundedness of linear monadic datalog is in PSPACE, Int. J. Found. Comput. Sci. 11 (2000) 591–612.[63] J.F. Naughton, Y. Sagiv, A decidable class of bounded recursions, in: M.Y. Vardi (Ed.), Proc. PODS 1987, ACM, 1987, pp. 227–236.[64] G.G. Hillebrand, P.C. Kanellakis, H.G. Mairson, M.Y. Vardi, Undecidable boundedness problems for datalog programs, J. Log. Program. 25 (1995) 163–190.[65] J. Marcinkowski, Achilles, turtle, and undecidable boundedness problems for small DATALOG programs, SIAM J. Comput. 29 (1999) 231–257.[66] H. Gaifman, H.G. Mairson, Y. Sagiv, M.Y. Vardi, Undecidable optimization problems for database logic programs, J. ACM 40 (1993) 683–713.[67] A. Artale, D. Calvanese, R. Kontchakov, M. Zakharyaschev, The DL-Lite family and relations, J. Artif. Intell. Res. 36 (2009) 1–69.[68] F. Baader, S. Brandt, C. Lutz, Pushing the EL envelope, in: L.P. Kaelbling, A. Saffiotti (Eds.), Proc. IJCAI 2005, Professional Book Center, 2005, pp. 364–369.[69] F. Baader, C. Lutz, B. Suntisrivaraporn, Efficient reasoning in EL+, in: B. Parsia, U. Sattler, D. Toman (Eds.), Proc. DL 2006, in: CEUR Workshop Proceedings, [70] F. Baader, S. Brandt, C. Lutz, Pushing the EL envelope further, in: K. Clark, P.F. Patel-Schneider (Eds.), Proc. OWLED 2008 DC Workshop on OWL: vol. 189, 2006, CEUR-WS .org.Experiences and Directions, 2008.[71] A. Calì, G. Gottlob, T. Lukasiewicz, A general datalog-based framework for tractable query answering over ontologies, J. Web Semant. 14 (2012) 57–83.[72] A. Calì, G. Gottlob, A. Pieris, Towards more expressive ontology languages: the query answering problem, Artif. Intell. 193 (2012) 87–128.[73] M. Kaminski, Y. Nenov, B. Cuenca Grau, Datalog rewritability of disjunctive datalog programs and its applications to ontology reasoning, in: C.E. Brodley, P. Stone (Eds.), Proc. AAAI 2014, AAAI Press, 2014, pp. 1077–1083.[74] D. Trivela, G. Stoilos, A. Chortaras, G.B. Stamou, Optimising resolution-based rewriting algorithms for OWL ontologies, J. Web Semant. 33 (2015) 30–49.[75] D. Trivela, G. Stoilos, A. Chortaras, G. Stamou, Resolution-based rewriting for horn-SHIQ ontologies, Knowl. Inf. Syst. 62 (2020) 107–143.[76] M. Bienvenu, C. Lutz, F. Wolter, First-order rewritability of atomic queries in Horn description logics, in: F. Rossi (Ed.), Proc. IJCAI 2013, IJCAI/AAAI, [77] M. Bienvenu, P. Hansen, C. Lutz, F. Wolter, First order-rewritability and containment of conjunctive queries in Horn description logics, in: S. Kambham-pati (Ed.), Proc. IJCAI 2016, IJCAI/AAAI Press, 2016, pp. 965–971.[78] P. Barceló, G. Berger, C. Lutz, A. Pieris, First-order rewritability of frontier-guarded ontology-mediated queries, in: J. Lang (Ed.), Proc. IJCAI 2018, 2018, pp. 1707–1713, ijcai .org.Proc. KR 2016, AAAI Press, 2016, pp. 207–216.[79] P. Bourhis, C. Lutz, Containment in monadic disjunctive datalog, MMSNP, and expressive description logics, in: C. Baral, J.P. Delgrande, F. Wolter (Eds.), [80] A. Hernich, C. Lutz, F. Papacchini, F. Wolter, Dichotomies in ontology-mediated querying with the guarded fragment, ACM Trans. Comput. Log. 21 [81] Y.P. Saraiya, Polynomial-time program transformations in deductive databases, in: D.J. Rosenkrantz, Y. Sagiv (Eds.), Proc. PODS 1990, ACM Press, 1990, [82] W. Zhang, C.T. Yu, D. Troy, Necessary and sufficient conditions to linearize double recursive programs in logic databases, ACM Trans. Database Syst. 15 [83] F.N. Afrati, M. Gergatsoulis, F. Toni, Linearisability on datalog programs, Theor. Comput. Sci. 308 (2003) 199–226.[84] T.J. Schaefer, The complexity of satisfiability problems, in: R.J. Lipton, W.A. Burkhard, W.J. Savitch, E.P. Friedman, A.V. Aho (Eds.), Proc. STOC 1978, ACM, [85] A.A. Bulatov, P. Jeavons, A.A. Krokhin, Classifying the complexity of constraints using finite algebras, SIAM J. Comput. 34 (2005) 720–742.[86] B. Larose, C. Loten, C. Tardif, A characterisation of first-order constraint satisfaction problems, Log. Methods Comput. Sci. 3 (2007).[87] P. Hell, J. Nesetril, Colouring, constraint satisfaction, and complexity, Comput. Sci. Rev. 2 (2008) 143–163.[88] H. Chen, B. Larose, Asking the metaquestions in constraint tractability, ACM Trans. Comput. Theory 9 (2017) 11:1–11:27.[89] O. Gerasimova, S. Kikot, M. Zakharyaschev, Checking the data complexity of ontology-mediated queries: a case study with non-uniform CSPs and Polyanna, in: C. Lutz, U. Sattler, C. Tinelli, A. Turhan, F. Wolter (Eds.), Description Logic, Theory Combination, and All That, in: Lecture Notes in Computer Science, vol. 11560, Springer, 2019, pp. 329–351.[90] R. Gault, P. Jeavons, Implementing a test for tractability, Constraints 9 (2004) 139–160.[91] C.-L. Chang, R.C.-T. Lee, Symbolic Logic and Mechanical Theorem Proving, 1st ed., Academic Press, 1973.[92] L. Egri, B. Larose, P. Tesson, Symmetric datalog and constraint satisfaction problems in logspace, in: Proc. LICS 2007, IEEE, 2007, pp. 193–202.[93] M. Grohe, The complexity of homomorphism and constraint satisfaction problems seen from the other side, J. ACM 54 (2007) 1:1–1:24.[94] L.J. Stockmeyer, The polynomial-time hierarchy, Theor. Comput. Sci. 3 (1976) 1–22.[95] G. Gottlob, S. Kikot, R. Kontchakov, V. Podolskii, T. Schwentick, M. Zakharyaschev, The price of query rewriting in ontology-based data access, Artif. Intell. 213 (2014) 42–59.[96] B. Rossman, Homomorphism preservation theorems, J. ACM 55 (2008) 15:1–15:53.[97] H. Comon, M. Dauchet, R. Gilleron, C. Löding, F. Jacquemard, D. Lugiez, S. Tison, M. Tommasi, Tree automata techniques and applications, Available at 2013, pp. 754–760.(2020) 20:1–20:47.pp. 132–144.(1990) 459–482.1978, pp. 216–226.http://www.grappa .univ-lille3 .fr /tata, 2007.[98] C. Papadimitriou, Computational Complexity, Addison-Wesley, 1994.46