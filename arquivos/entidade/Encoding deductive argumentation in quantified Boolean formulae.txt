Artificial Intelligence 173 (2009) 1406–1423Contents lists available at ScienceDirectArtificial Intelligencewww.elsevier.com/locate/artintEncoding deductive argumentation in quantified Boolean formulaePhilippe Besnard a, Anthony Hunter b,∗, Stefan Woltran ca IRIT-CNRS, Universitè Paul Sabatier, 118 rte de Narbonne, 31062 Toulouse, Franceb Department of Computer Science, University College London, Gower Street, London, WC1E 6BT, UKc Institute for Information Systems 184/2, Technische Universität Wien, Favoritenstrasse 9-11, 1040 Vienna, Austriaa r t i c l ei n f oa b s t r a c tThere are a number of frameworks for modelling argumentation in logic. They incorporatea formal representation of individual arguments and techniques for comparing conflictingarguments. A common assumption for logic-based argumentation is that an argument is apair (cid:3)(cid:2), α(cid:4) where (cid:2) is minimal subset of the knowledge-base such that (cid:2) is consistentand (cid:2) entails the claim α. Different logics provide different definitions for consistency andentailment and hence give us different options for argumentation. Classical propositionallogic is an appealing option for argumentation but the computational viability of generatingan argument is an issue. To better explore this issue, we use quantified Boolean formulaeto characterise an approach to argumentation based on classical logic.© 2009 Elsevier B.V. All rights reserved.Article history:Received 27 January 2009Received in revised form 12 May 2009Accepted 25 June 2009Available online 27 June 2009Keywords:Argument systemsArgumentationClassical logicInconsistencyQuantified Boolean formulaeConflicting knowledge1. IntroductionArgumentation is a vital aspect of intelligent behaviour by humans. Consider diverse professionals such as politicians,journalists, clinicians, scientists, and administrators, who all need to collate and analyse information looking for pros andcons for consequences of importance when attempting to understand problems and make decisions.There is a range of proposals for logic-based formalisations of argumentation (for reviews see [8,13,31]). These proposalsallow for the representation of arguments for and against some claim, and for counterargument relationships betweenarguments.In a number of key proposals for argumentation, an argument is a pair where the first item in the pair is a consistentset (or a minimal consistent set) of formulae that proves the second item which is a formula (see for example [1,5,7,15,24,26,30]). Hence, different underlying logics provide different definitions for consistency and entailment and hence give usdifferent options for defining the notion of an argument.Since classical logic has many advantages for representing and reasoning with knowledge including syntax, proof theoryand semantics for the intuitive language incorporating negation, conjunction, disjunction and implication, it is an interestingand promising choice for the underlying logic for argumentation. However, it is computationally challenging to generatearguments from a knowledge-base using classical logic. If we consider the problem as an abduction problem, where weseek the existence of a minimal subset of a set of formulae that implies the consequent, then the problem is in the secondlevel of the polynomial hierarchy [23]. Furthermore, given a knowledge-base (cid:4) and a formula α, it has been shown thatascertaining whether there is a subset (cid:2) of (cid:4) such that (cid:3)(cid:2), α(cid:4) is an argument (i.e. (cid:2) is consistent, (cid:2) entails α, and thereis no subset of (cid:2) that entails α) is a (cid:5) p2 -complete decision problem [29].* Corresponding author.E-mail address: A.Hunter@cs.ucl.ac.uk (A. Hunter).0004-3702/$ – see front matter © 2009 Elsevier B.V. All rights reserved.doi:10.1016/j.artint.2009.06.006P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231407Beyond these observations, there remains a range of further important computational complexity questions. So to betterunderstand the use of classical logic in argumentation, and in particular to understand its computational properties, weuse quantified Boolean formulae (QBFs) to characterise an approach to argumentation that is based on classical logic. Thischaracterisation can then be used to obtain computational complexity results in terms of upper bounds.A further reason to characterise logic-based argumentation in the form of QBFs is that we can then harness implementa-tions of QBF solvers to develop prototype implementations for logic-based argumentation. There are numerous QBF solversavailable (see, e.g, [28] and the references therein), and the encodations we present in this paper can be straightforwardlyhandled in them.2. Preliminaries2.1. Logical argumentationIn this section we review an existing proposal for logic-based argumentation [7]. We consider a classical propositionallanguage. We use α, β, γ , . . . to denote formulae and (cid:4), (cid:2), (cid:8), . . . to denote sets of formulae. Deduction in classical propo-sitional logic is denoted by the symbol (cid:5) and deductive closure by Th so that Th((cid:2)) = {α | (cid:2) (cid:5) α}.For the following definitions, we first assume a knowledge-base (cid:4) (a finite set of formulae) and use this (cid:4) throughout.We further assume that every subset of (cid:4) is given an enumeration (cid:3)α1, . . . , αn(cid:4) of its elements, which we call its canonicalenumeration. This really is not a demanding constraint: In particular, the constraint is satisfied whenever we impose anarbitrary total ordering over (cid:4). Importantly, the order has no meaning and is not meant to represent any respective impor-tance of formulae in (cid:4). It is only a convenient way to indicate the order in which we assume the formulae in any subset of(cid:4) are conjoined to make a formula logically equivalent to that subset.The paradigm for the approach is a large repository of information, represented by (cid:4), from which arguments can beconstructed for and against arbitrary claims. Apart from information being understood as declarative statements, there is noa priori restriction on the contents, and the pieces of information in the repository can be as complex as possible. Therefore,(cid:4) is not expected to be consistent. It need not even be the case that every single formula in (cid:4) is consistent.The framework adopts a very common intuitive notion of an argument. Essentially, an argument is a set of relevantformulae that can be used to classically prove some claim, together with that claim. Each claim is represented by a formula.Definition 1. An argument is a pair (cid:3)(cid:2), α(cid:4) such that: (1) (cid:2) ⊆ (cid:4); (2) (cid:2) (cid:7)(cid:5) ⊥; (3) (cid:2) (cid:5) α; and (4) there is no (cid:2)(cid:9) ⊂ (cid:2) suchthat (cid:2)(cid:9) (cid:5) α. We say that (cid:3)(cid:2), α(cid:4) is an argument for α. We call α the claim (or consequent) of the argument and (cid:2) thesupport of the argument (we also say that (cid:2) is a support for α).Example 1. Let (cid:4) = {α, α → β, γ → ¬β, γ , δ, δ → β, ¬α, ¬γ }. Some arguments are:(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)(cid:3){α, α → β}, β{¬α}, ¬α{α → β}, ¬α ∨ β{¬γ }, δ → ¬γ(cid:3).(cid:3)By monotonicity of classical logic the following equivalent characterisation easily follows.Proposition 1. A pair (cid:3)(cid:2), α(cid:4) is an argument iff it satisfies (1)–(3) from Definition 1 together with (4(cid:9)) for each φ ∈ (cid:2), ((cid:2) \ {φ}) (cid:7)(cid:5) α.Arguments are not independent. In a sense, some encompass others (possibly up to some form of equivalence). To clarifythis requires a few definitions as follows.Definition 2. An argument (cid:3)(cid:2), α(cid:4) is more conservative than an argument (cid:3)(cid:8), β(cid:4) iff (cid:2) ⊆ (cid:8) and β (cid:5) α.Example 2. (cid:3){α}, α ∨ β(cid:4) is more conservative than (cid:3){α, α → β}, β(cid:4).Definition 3. An argument (cid:3)(cid:2), α(cid:4) is strictly more conservative than an argument (cid:3)(cid:8), β(cid:4) iff (cid:2) ⊆ (cid:8), β (cid:5) α, and either (cid:8) (cid:7)⊆ (cid:2)or α (cid:7)(cid:5) β.Some arguments directly oppose the support of others, which amounts to the notion of an undercut.Definition 4. An undercut for an argument (cid:3)(cid:2), α(cid:4) is an argument (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) where {φ1, . . . , φn} ⊆ (cid:2).1408P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423Example 3. Let (cid:4) = {α, α → β, γ , γ → ¬α}. Then, (cid:3){γ , γ → ¬α}, ¬(α ∧ (α → β))(cid:4) is an undercut for (cid:3){α, α → β}, β(cid:4). A lessconservative undercut for (cid:3){α, α → β}, β(cid:4) is (cid:3){γ , γ → ¬α}, ¬α(cid:4).Definition 5. (cid:3)(cid:8), β(cid:4) is a maximally conservative undercut for (cid:3)(cid:2), α(cid:4) iff (cid:3)(cid:8), β(cid:4) is an undercut for (cid:3)(cid:2), α(cid:4) such that noundercuts of (cid:3)(cid:2), α(cid:4) are strictly more conservative than (cid:3)(cid:8), β(cid:4).The value of the following definition of canonical undercut is that we only need to take the canonical undercuts intoaccount. This means we can justifiably ignore the potentially very large number of non-canonical undercuts.Definition 6. An argument (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) is a canonical undercut for (cid:3)(cid:2), α(cid:4) iff it is a maximally conservative undercutfor (cid:3)(cid:2), α(cid:4) and (cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2).The next result is central.Proposition 2. (See Theorem 5.4 [7].) A pair (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) is a canonical undercut for (cid:3)(cid:2), α(cid:4) iff it is an undercut for (cid:3)(cid:2), α(cid:4)and (cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2).In other words, the canonical undercuts for (cid:3)(cid:2), α(cid:4) are given by all arguments of the form (cid:3)(cid:8), ¬(φ1 ∧ · · · ∧ φn)(cid:4) where(cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2). Later we need to refer to all possible supports of canonical undercuts for anargument. We thus introduce the following concept.Definition 7. For (cid:3)(cid:2), α(cid:4), we define UndercutSupports((cid:3)(cid:2), α(cid:4)) as the set of its supports:(cid:4)(cid:5)(cid:8) | (cid:3)(cid:8), β(cid:4) is a canonical undercut for (cid:3)(cid:2), α(cid:4).We shall make use of the notation UndercutSupports((cid:3)(cid:2), α(cid:4)) later when defining suitable representations of argumenttrees. Using Proposition 2, we can alternatively characterise the set UndercutSupports((cid:3)(cid:2), α(cid:4)) as follows.Proposition 3. For (cid:3)(cid:2), α(cid:4), with (cid:3)φ1, . . . , φn(cid:4) the canonical enumeration of (cid:2),(cid:4)(cid:6)(cid:7)(cid:3)(cid:2), α(cid:4)=(cid:8) |(cid:3)(cid:2)(cid:8), ¬(φ1 ∧ · · · ∧ φn)UndercutSupportsis an argument(cid:5).Next we recall the notion of an argument tree following [7], and then introduce a more succinct notion to representargument trees which is also more suitable for our later purposes.An argument tree describes the various ways an argument can be challenged, as well as how the counter-arguments tothe initial argument can themselves be challenged, and so on recursively.Definition 8. An annotated tree is a tree where each node is a pair (cid:3)(cid:2), β(cid:4). An argument tree for α is an annotated tree,such that1. each node is an argument with the root being an argument for α;2. for no node (cid:3)(cid:2), β(cid:4) with ancestor nodes (cid:3)(cid:2)1, β1(cid:4), . . . , (cid:3)(cid:2)n, βn(cid:4) is (cid:2) a subset of (cid:2)1 ∪ · · · ∪ (cid:2)n;3. the children nodes of a node N consist of some canonical undercuts for N that obey 2.A complete argument tree is as just defined with “some” replaced by “all” in item 3 above.The definition of an argument tree ensures that each argument on a branch has to introduce at least one formula inits support that has not already been used by ancestor arguments. This is meant to avoid making explicit undercuts thatsimply repeat over and over the same reasoning pattern except for switching the role of some formulae (as illustrated inExample 5 below).As a notational convenience, in examples of argument trees the (cid:2) symbol is used to denote the consequent of anargument when that argument is a canonical undercut (no ambiguity arises as proven in [7]).Example 4. Given (cid:4) = {α, α → β, γ , γ → ¬α, ¬γ ∨ ¬α}, we have the following argument tree.(cid:2){α, α → β}, β(cid:3)(cid:6)(cid:2){γ , γ → ¬α}, ¬(cid:7)(cid:3)α ∧ (α → β)(cid:16)(cid:17)(cid:6)(cid:2){γ , ¬γ ∨ ¬α}, ¬(cid:7)(cid:3)α ∧ (α → β)Note the two undercuts are equivalent. They do count as two arguments because they are based on two different items ofthe database (even though these items turn out to be logically equivalent).P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231409Example 5. Let (cid:4) = {α, α → β, γ → ¬α, γ }.(cid:3)(cid:2){α, α → β}, β↑(cid:2)(cid:2)(cid:3){γ , γ → ¬α}, (cid:2)↑(cid:3){α, γ → ¬α}, (cid:2)This is not an argument tree because the undercut to the undercut is actually making exactly the same point (that α andγ are incompatible) as the undercut itself does, just by using modus tollens instead of modus ponens.Example 6. Given (cid:4) = {α, β, α → γ , β → δ, ¬α ∨ ¬β}, consider the following tree.(cid:2){α, β, α → γ , β → δ}, γ ∧ δ(cid:3)(cid:2){α, ¬α ∨ ¬β}, ¬β(cid:3)(cid:16)(cid:17)(cid:2){β, ¬α ∨ ¬β}, ¬α(cid:3)This is not an argument tree because the two children nodes are not maximally conservative undercuts. The first undercutis essentially the same argument as the second undercut in a rearranged form (relying on α and β being incompatible,assume one and then conclude that the other doesn’t hold). If we replace these by the maximally conservative undercut(cid:3){¬α ∨ ¬β}, (cid:2)(cid:4), we obtain an argument tree.Notably, there is a finite number of argument trees with the root being an argument with the claim α that can beformed from (cid:4), and each of these trees has finite branching and a finite depth (the finite tree property).For our purposes in this paper, we require a more formal representation of argument trees. It makes use of the fact thatall consequences in the nodes (except the root) of an argument tree are determined by their direct ancestor (as alreadymentioned above when introducing (cid:2)). To this end, a node is now a set of formulae rather than an argument, and a parentfunction determines the structure of the tree.Definition 9. A parent function p (over k (cid:2) 1) is a partial function from {1..k} to {1..k}, such that p( j) is undefined forj = 1 but p( j) is defined and p( j) < j, for any 1 < j (cid:3) k.p is a parent function for a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) of subsets of (cid:4) if p is a parent function over k and is such thatp(i) = p( j) implies (cid:2)i (cid:7)= (cid:2) j , for any 1 < j < i (cid:3) k.A tuple form is a triple (cid:3)α, A, p(cid:4), where α is a formula, A is a sequence of subsets of (cid:4), and p is a parent functionfor A.Given a tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4), we define, for each 1 (cid:3) i (cid:3) k, an associated pair, A(i), as follows A(1) = (cid:3)(cid:2)1, α(cid:4)and, for i > 1, A(i) = (cid:3)(cid:2)i, ¬(φ1 ∧ · · · ∧ φn)(cid:4), where (cid:3)φ1, . . . , φn(cid:4) is the canonical enumeration of (cid:2)p(i).Tuple forms are an alternative way to denote annotated trees. Intuitively, A collects all supports of the tree’s nodes, α isthe claim of the root node, and the parent function p links each node to its parent node, and thus determines the structureof the tree. This is feasible, since p is defined for each node except the root and links to a previous element in A; thecondition that p(i) = p( j) implies (cid:2)i (cid:7)= (cid:2) j , for i (cid:7)= j just avoids duplicate children nodes.The concept of tuple forms is best illustrated by examples.Example 7. First, consider the tree from Example 4. That annotated tree can be represented in tuple form (cid:3)β, (cid:3)(cid:2)1, (cid:2)2, (cid:2)3(cid:4), p(cid:4)where (cid:2)1 = {α, α → β}, (cid:2)2 = {γ , γ → ¬α}, (cid:2)3 = {γ , ¬γ ∨ ¬α}, and p is defined as p(2) = p(3) = 1. An alternative wayto represent the same annotated tree would be to exchange the sets for (cid:2)2 and (cid:2)3.Conversely, given the tuple form (cid:3)β, (cid:3)(cid:2)1, (cid:2)2, (cid:2)3(cid:4), p(cid:4), we can derive from it an annotated tree as follows: The nodes aregiven by A(1), A(2), A(3), and we get by definition of p that A(2) and A(3) are the children of the root node A(1).Example 8. As a second example, consider Example 5. The only way to achieve a tuple form for thattree is(cid:3)β, (cid:3)(cid:2)1, (cid:2)2, (cid:2)3(cid:4), p(cid:4) where (cid:2)1 = {α, α → β}, (cid:2)2 = {γ , γ → ¬α}, (cid:2)3 = {α, γ → ¬α}, and p is defined as p(2) = 1, p(3) = 2.We now formally describe these relations.Definition 10. We define a mapping TreeForm from tuple forms to graphs as follows: For each t = (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4), thenodes of TreeForm(t) are given by the set { A(i) | 1 (cid:3) i (cid:3) k}; and a pair ( A(i), A( j)) is an edge of TreeForm(t) iff p( j) = i, for1 < j (cid:3) k.1410P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423Lemma 1. For any tuple form t, TreeForm(t) is an annotated tree.Proof. TreeForm(t) is a tree because it is a graph which is connected (ignoring direction of edges) and has exactly one edgeless than it has vertices:By Definition 10, ( A(i), A( j)) is an edge iff p( j) = i (for 1 < j (cid:3) k). I.e., ( A(p( j)), A( j)) for j = 1..k exhausts all edges.Since p is a parent function, TreeForm(t) has k − 1 edges. There remains to show that TreeForm(t) is connected (whendirections of edges are ignored). This easily follows from the fact that any node in TreeForm(t) is connected to A(1) (thelatter is true because if 1 < j (cid:3) k, then there exists n such that pn( j) = 1 as p is a parent function). In short, TreeForm(t) is atree. It is an annotated tree because Definition 10 trivially shows that all nodes in TreeForm(t) are pairs A(i) for i = 1..k. (cid:3)In view of the above lemma, we call, for a given tuple form t, TreeForm(t) the tree associated to t. As well, we say thatt represents tree TreeForm(t).We now characterise argument trees and complete argument trees via tuple forms. This result is valuable later whencharacterising argument trees via QBFs. We need one more technical notation.Definition 11. Given a tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4), we define, for each 1 (cid:3) i (cid:3) k, pancestors, i.e.,(i) =pn(i) | there exists m (cid:2) n (cid:2) 1 such that pm(i) = 1(cid:4)(cid:5)p∗.∗(i) as the set of indices of (cid:2)i ’sLemma 2. A tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4) represents• an argument tree iff(1) (cid:3)(cid:2)1, α(cid:4) is an argument,(2) for each 1 < i (cid:3) k, (cid:2)i (cid:7)⊆(3) for each 1 < i (cid:3) k, (cid:2)i ∈ UndercutSupports( A(p(i))) hold;j∈p∗(i) (cid:2) j , and(cid:8)• a complete argument tree iff, (1)–(3) hold together with(4) for each 1 (cid:3) i (cid:3) k and for each (cid:8) ∈ UndercutSupports( A(i)), there exists an index j ∈ {1..k}, such that (cid:2) j = (cid:8) and p( j) = i.Proof. The first statement in Lemma 2 means that TreeForm(t) is an argument tree iff (1)–(3) hold together. Let us firstassume that TreeForm(t) is an argument tree. Then, (1) and (2) are easily verified. By item 3 in Definition 8, the children ofa node N are canonical undercuts for N. So, if N is (cid:3)(cid:2), β(cid:4), any child of N is a canonical undercut A(i) = (cid:3)(cid:2)i, ¬(φ1 ∧ · · · ∧ φn)(cid:4)of N = A(p(i)). Then, Definition 7 directly yields (cid:2)i ∈ UndercutSupports( A(p(i))). That is, (3) holds as well.As to the other direction, let us assume that (1)–(3) hold. By (3) and item 4 in Definition 9, Definition 7 means thatA(i) is an argument for 1 < i (cid:3) k. Due to (1), it follows that item 1 in Definition 8 is verified. It is easy to verify that (2)implies item 2 in Definition 8. Lastly, (3) and item 4 in Definition 9 entail (cf Definition 7) that for 1 < i (cid:3) k, each A(i) is acanonical undercut of A(p(i)). I.e., item 3 in Definition 8 holds.Let us assume (1)–(4). Let us further assume that TreeForm(t) is not a complete argument tree. In view of Definition 8,this can only happen due to a node N = A(p(i)) lacking at least one canonical undercut as a child (TreeForm(t) is anargument tree, as proved above). By Definition 7, there then exists (cid:8) in UndercutSupports( A( j)), for some j, satisfying(cid:8) = (cid:2)i for no i such that p(i) = j. This contradicts (4). So, the if direction is proved. Proof of the only if direction is easyand is omitted. (cid:3)(cid:8)∗(3) = {1, 2} andj∈p∗(3) (cid:2) j = (cid:2)1 ∪ (cid:2)2 = {α, γ , γ → ¬α}. Since (cid:2)3 = {α, γ → ¬α} is a subset of that set, condition (2) in Lemma 2 isExample 9. Consider again the tuple form for the tree in Example 5, as given in Example 8. We have pthusviolated. Thus, we have that the tuple form does not represent an argument tree.Lemma 3. Each argument tree is represented by a tuple form.Proof. Consider an argument tree T with nodes N1, . . . , Nk, where nodes are of the form Ni = ((cid:2)i, αi), for each 1 (cid:3) i (cid:3) k,and N1 is the root of T . Consider tT = (cid:3)α1, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4) where p is a partial function {1..k} to {1..k} satisfying, for each1 (cid:3) j < k, p( j) = i iff N j is a children node of Ni in T . Since T is an argument tree, p is in fact a parent function over k.Thus tT is a tuple form and one can show that TreeForm(t T ) = T , which holds by the observation that the pairs associatedto tT satisfy A(i) = Ni , for each 1 (cid:3) i (cid:3) k. (cid:3)2.2. Quantified Boolean formulaeQuantified Boolean formulae (QBFs) generalize ordinary propositional formulae by the admission of quantifications overpropositional variables. In particular, the language of QBFs contains, for any atom p, unary operators of the form ∀p and ∃p,called universal and existential quantifiers, respectively. However, the quantifiers do not range over some arbitrary domain,P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231411but over truth assignments. Thus, a QBF of form ∀p ∃q F is satisfiable iff, for all truth assignments of p, there is a truthassignment of q such that F is satisfiable; see also Example 10 below.An occurrence of a propositional variable p in a QBF F is free iff it does not appear in the scope of a quantifier Qp(Q ∈ {∀, ∃}), otherwise the occurrence of p is bound. If F contains no free variable occurrences, then F is closed, otherwiseF is open. Furthermore, we write F [p/φ] to denote the result of uniformly substituting each free occurrence of the variablep in F by a φ. For a set P = {p1, . . . , pn} of propositional variables, we let ∀P F stand for the formula ∀p1∀p2 · · · ∀pn, and∃P F for the formula ∃p1∃p2 · · · ∃pn.By an interpretation, I , we mean a set of atoms. Informally, an atom p is true under I iff p ∈ I . In general, the truth value,νI (F ), of a QBF F under an interpretation I is recursively defined as follows:1. if F = (cid:21), then νI (F ) = 1;2. if F = p is an atom, then νI (F ) = 1 if p ∈ I , and νI (F ) = 0 otherwise;3. if F = ¬G, then νI (F ) = 1 − νI (G);4. if F = (F 1 ∧ F 2), then νI (F ) = min({νI (F 1), νI (F 2)});5. if F = ∀p G, then νI (F ) = νI (G[p/(cid:21)] ∧ G[p/⊥]);6. if F = ∃p G, then νI (F ) = νI (G[p/(cid:21)] ∨ G[p/⊥]).The truth conditions for ⊥, ∨, →, and ↔ follow from the above in the usual way. We say that F is true under I iff νI (F ) = 1,otherwise F is false under I. If νI (F ) = 1, then I is a model of F . If F has some model, then F is said to be satisfiable. If Fis true under any interpretation, then F is valid. Observe that a closed QBF is either valid or unsatisfiable, because closedQBFs are either true under each interpretation or false under each interpretation. Hence, for closed QBFs, there is no needto refer to particular interpretations. Therefore, closed QBFs are simply either true or false. Two QBFs are logically equivalentiff they possess the same models.Example 10. Consider the QBF F 1 = ∀q(p ↔ q). In this QBF, the propositional variable p if free, while q is bound. To evaluatethe QBF, we thus consider two interpretations: I1 = ∅ setting p to false; and I2 = {p} setting p to true.In general, given an interpretation I , we can evaluate a QBF with respect to I in two ways: (i) first evaluate the freevariables according to I and then apply the semantics for the now closed QBF; (ii) first apply the semantics for quantifiersand then evaluate the now quantifier-free formula using I .So, in our example (i) is as follows: For I1, we get ∀q(⊥ ↔ q), i.e., ∀q(¬q); and for I2, we get ∀q((cid:21) ↔ q), i.e., ∀q(q).Both closed QBFs are false, thus neither I1 nor I2 is a model of F 1. Following attempt (ii), we first treat the universalquantification for q according to the semantics and get (p ↔ (cid:21)) ∧ (p ↔ ⊥) which is equivalent to p ∧ ¬p. Clearly, neitherI1 nor I2 is a model of this propositional formula. Hence, neither I1 nor I2 is a model of F 1. Observe that we thus can alsostate that the closed QBF∃p∀q(p ↔ q)is false.Now consider the QBF F 2 = ∃q(p ↔ q). As before, interpretations I1 and I2 are of interest. According to (ii), F 2 reducesto (p ↔ (cid:21)) ∨ (p ↔ ⊥) which is equivalent to p ∨ ¬p. Now both, I1 and I2 are models of that formula and thus of F 2. Thisleads us to the further observation that the closed QBF∀p∃q(p ↔ q)is true.QBFs allow us to talk about semantical concepts in propositional logic. For instance, a propositional formula F overpropositional variables V is satisfiable iff the closed QBF ∃V (F ) is true. Likewise, F is valid iff the closed QBF ∀V (F ) is true.Consequently, given a knowledge-base (cid:4) and a formula, both over V , (cid:4) (cid:5) α holds iff the QBF ∀V ((cid:9)δ∈(cid:4) δ → α) is true.Example 11. Consider (cid:4) = {p, p → q} and let α = q. We have V = {p, q} and thus consider the closed QBF(cid:6)(cid:6)(cid:7)p ∧ (p → q)(cid:7)→ q.∀p∀qObserve that the inner part of that QBF, i.e., the propositional formula (p ∧ (p → q)) → q is valid, and thus true under allassignments. Hence, the above QBF is true.In the same way as the satisfiability problem of classical propositional logic is the “prototypical” problem of NP, i.e.,being an NP-complete problem, the satisfiability problem of QBFs in prenex form are the “prototypical” problems of the k-thlevel of the polynomial hierarchy.Proposition 4. (See [35].) Given a propositional formula φ with its atoms partitioned into i (cid:2) 1 sets P 1, . . . , P i , deciding whetherQ1 P 1Q2 P 2 . . . Qi P iφ is true is (i) (cid:5) pi -complete, if Q1 = ∃; (ii) (cid:12)pi -complete, if Q1 = ∀.1412P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423In fact, the hardness results in above proposition hold only for those QBFs where the quantifiers in the prefixQ1 P 1Q2 P 2 . . . Qi P i are alternating, i.e., Q j (cid:7)= Q j+1 holds, for each 1 (cid:3) j < i. We call such QBFs also (Q1, i)-QBFs.The complexity landscape can be extended to arbitrary closed QBFs if the maximal number of quantifier alternationsalong a path in the QBF’s formula tree is taken into account. In turn, an arbitrary QBF can be transformed into an equivalentQBF in prenex form. This transformation is not deterministic and it is crucial for the performance of QBF solvers requiringthe input formula in this normal form (for details, see [20,21]).Finally, we highlight the used reduction approach. Given a decision problem D, we aim at finding a translation schemeTD into closed QBFs, such that1. TD (·) is faithful, i.e., TD (K ) is true iff K is a yes-instance of D;2. for each instance K , TD (K ) is computable in polynomial time with respect to the size of K ; and3. determining the truth of the QBFs resulting from TD (·) is not computationally harder (by means of Proposition 4) thanthe computational complexity of D.In addition, if we are interested in a search problem S we aim at establishing a certain one-to-one correspondencebetween the models of the QBF encodings and the solutions to S. Indeed the transformation TD (·) then has to yield openQBFs instead of closed QBFs. Given the models of the QBF TD (K ), the computation of the solutions of K has to be feasiblein polynomial time.2.3. Basic concept of encodingsWe now sketch our basic ideas for capturing logic-based argumentation in QBFs.In the following, we assume aknowledge-base (cid:4) to be given over a set of atoms V (cid:4). Moreover, α, β always refer to formulae, which are, without loss ofgeneralization, assumed to be given over atoms from V (cid:4). In general, for a set (cid:2) of formulae, the set V (cid:2) contains all atomsoccurring in (cid:2).Given a finite knowledge-base (cid:4), we assign to each element of (cid:4) several new atoms via a generator function. The aimof this function to provide new atoms, such that interpretations over those atoms are used to represent subsets of (cid:4). Theformal definition is as follows:Definition 12. A generator function g maps each δ ∈ (cid:4) to a new propositional atom g(δ) /∈ V (cid:4), such that g(δ1) = g(δ2)implies δ1 = δ2, for all δ1, δ2 ∈ (cid:4). With some abuse of notation we write, for any subset (cid:2) ⊆ (cid:4), g((cid:2)) to denote the set{g(δ) | δ ∈ (cid:2)}. Moreover, for two different generator functions g1, g2, we ensure g1((cid:4)) ∩ g2((cid:4)) = ∅, i.e., each generatorfunction provides its own fresh atoms.Interpretations (usually given over arbitrary atoms) are linked to subsets of (cid:4) via generator functions as follows.Definition 13. Let I be an interpretation, g be a generator function, and (cid:2) ⊆ (cid:4). We say that I represents (cid:2) via g iffI ∩ g((cid:4)) = g((cid:2)). Moreover, for a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) of subsets of (cid:4) and a corresponding sequence G = (cid:3)g1, . . . , gk(cid:4)of different generator functions, we say that an interpretation I represents A via G iff I ∩ gi((cid:4)) = gi((cid:2)i), holds for all1 (cid:3) i (cid:3) k.A word of caution is in order here: When I represents (cid:2) via some g, I may, but need not, be a model of (cid:2). Theforthcoming Definition 14 and Lemma 4 provide the missing link.Definition 14. For (cid:13) ⊆ (cid:4), a formula α, and a generator function g, define(cid:13) ⇒g α = ∀V (cid:13)∪{α}(cid:10)(cid:10) (cid:11)(cid:6)(cid:12)(cid:7)(cid:12)→ α.g(δ) → δδ∈(cid:13)Lemma 4. Let (cid:4) be a knowledge base, and I be an interpretation. For (cid:13) ⊆ (cid:4), and (cid:2) ⊆ (cid:13), such that I represents (cid:2) via generatorfunction g, then, for all α, we have that, (cid:13) ⇒g α is true under I iff (cid:2) (cid:5) α.Proof. We have that (cid:2) (cid:5) α iff each model over atoms V (cid:2)∪{α} of (cid:2) is also a model of α. By the semantics of QBFs, it iseasily verified that the latter holds iff the closed QBF(cid:10)(cid:10) (cid:11)(cid:12)(cid:12)δ→ α∀V (cid:2)∪{α}δ∈(cid:2)(1)P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231413is true. (Recall that a closed QBF is either true under any interpretation I or false under any interpretation I .) We nextincrease the set of quantified variables in (1) from V (cid:2)∪{α} to V (cid:13)∪{α}, which yields(cid:10)(cid:10) (cid:11)(cid:12)(cid:12)∀V (cid:13)∪{α}δ→ α.(2)δ∈(cid:2)This QBF is also closed since (cid:2) ⊆ (cid:13) and it holds that (2) is true iff (1) is true, since the added quantified variables do nothave any influence here.Next, we replace each δ by the equivalent formula (cid:21) → δ, and add trivially true conjuncts of the form ⊥ → γ , yielding1(cid:14)(cid:12)(cid:12)(cid:12)(cid:13)(cid:10)(cid:10) (cid:11)(cid:10) (cid:11)∀V (cid:13)∪{α}((cid:21) → δ)∧(⊥ → γ )→ α.(3)δ∈(cid:2)γ ∈(cid:13)\(cid:2)So far, this shows that (cid:2) (cid:5) α iff the closed QBF (3) is true. Now, let g be a generator function, and consider any inter-pretation I which represents (cid:2) via g. Hence, for each δ ∈ (cid:2), g(δ) ∈ I , and for each γ ∈ (cid:13) \ (cid:2), g(γ ) /∈ I holds. Recall thatg((cid:4)) ∩ V (cid:4) = ∅, and thus by our assumptions g((cid:4)) ∩ V (cid:13)∪{α} = ∅. We therefore can rewrite (3) to(cid:6)(cid:13)(cid:10)(cid:10) (cid:11)(cid:10) (cid:11)(cid:12)(cid:12)(cid:7)(cid:12)(cid:14)(cid:6)(cid:7)g(δ) → δ∧g(γ ) → γ→ α.(4)∀V (cid:13)∪{α}δ∈(cid:2)γ ∈(cid:13)\(cid:2)Observe that the atoms g(·) are free in (4) and thus are subject to interpretations. In fact, by the definition of a representa-tion (cf. Definition 13), it is easy to see that (4) is true under any I which represents (cid:2) via g iff (3) is true. To conclude theproof, observe (4) is equivalent to (cid:13) ⇒g α. (cid:3)(cid:15)(cid:6)Example 12. Let (cid:4) = {p, p → q}, α = q, and let us consider g((cid:4)) = {g p, g p→q}. Hence, the generator function provides foreach δ ∈ (cid:4) a new variable of the form g(δ) = gδ . Then, (cid:4) ⇒g α is given byg p→q → (p → q)(5)Note that, for each (cid:2) ⊆ (cid:4), we thus have interpretations representing (cid:2) via g. Since g((cid:4)) are the only free variables in(cid:4) ⇒g α it is thus sufficient to investigate the following four interpretations for being models of (cid:4) ⇒g α:(g p → p) ∧∀p∀q→ q(cid:7)(cid:7)(cid:6)(cid:16).I1 = ∅I2 = {g p}I3 = {g p→q}I4 = {g p, g p→q}.Let us now evaluate (5) under these four interpretation. We shall do so by first evaluating the free variables in (5) andthen inspect the remaining QBF, i.e., following method (ii) as sketched in Example 10. We start with I1. Then (5) reduces toclosed QBF∀p∀q⊥ → (p → q)(⊥ → p) ∧→ q(cid:7)(cid:7)(cid:15)(cid:6)(cid:6)(cid:16)which is equivalent to∀p∀q[q].This QBF is obviously false, and hence, I1 is not a model of (5).For I2 one of the conjuncts in the antecedent survives. We get⊥ → (p → q)((cid:21) → p) ∧∀p∀q→ q(cid:7)(cid:7)(cid:15)(cid:6)(cid:6)(cid:16)which is equivalent to∀p∀q[p → q].Still, this QBF is false, and hence, also I2 is not a model of (5).For I3, we get∀p∀q(cid:15)(cid:6)(⊥ → p) ∧(cid:6)(cid:21) → (p → q)(cid:7)(cid:7)(cid:16)→ qwhich is equivalent to(cid:15)(p → q) → q(cid:16).∀p∀q1 This can be done since the replacement theorem holds for QBFs.1414P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423Again, this QBF is false, and hence, also I3 is not a model of (5).Finally, evaluating (5) under I4 yields(cid:15)(cid:6)(cid:6)∀p∀q((cid:21) → p) ∧(cid:21) → (p → q)(cid:7)(cid:7)(cid:16)→ qwhich is equivalent to(cid:15)(cid:6)(cid:7)p ∧ (p → q)(cid:16).→ q∀p∀qThis QBF is true since the inner part (p ∧ (p → q)) → q is indeed a valid formula of propositional logic. Therefore, I4 is amodel of (5).So having I4 as the only model, we conclude that the set it represents via g, namely {p, p → q}, is the only subset (cid:2) of(cid:4), for which (cid:2) (cid:5) α holds.QBFs abbreviated by (cid:13) ⇒g α will be used as subformulae in various more complex QBF formulae. In a sense, they areuseful building blocks that can be used repeatedly. We will refer to a schema like (cid:13) ⇒g α as a module.3. CharacterisationsIn what follows, we will employ the basic encoding (cid:13) ⇒g α to characterise various problems for logic-based argumenta-tion. We start by characterising arguments and undercuts via models of certain QBFs. Then, we suitably combine the latterin such a way that the resulting formulae will allow us to reason about argument trees. We will first consider argumenttrees of a fixed structure (i.e., where the parent function is given when constructing the encodings) and then also provideencodings, where the parent function is characterised by the QBF itself.3.1. Arguments and undercutsDefinition 15. For a knowledge base (cid:4), a formula α, and a generator function g, definearg(g, (cid:4), α) = ¬ ((cid:4) ⇒g ⊥) ∧ ((cid:4) ⇒g α) ∧(cid:11)(cid:6)g(δ) → ¬(cid:6)(cid:6)(cid:4) \ {δ}(cid:7)(cid:7)(cid:7).⇒g αδ∈(cid:4)Note that the three main parts of the encoding check properties (2), (3), and respectively (4(cid:9)) from Proposition 1.Theorem 1. For a knowledge base (cid:4), a formula α, an interpretation I , and (cid:2) ⊆ (cid:4), such that I represents (cid:2) via generator function g,we have that arg(g, (cid:4), α) is true under I iff ((cid:2), α) is an argument.Proof. Using Lemma 4, we immediately conclude that the first two conjuncts of arg(g, (cid:4), α) are true in I iff conditions (2)and (3) from Proposition 1 hold. So, there only remains to take care of the third conjunct in arg(g, (cid:4), α), i.e.:(cid:11)(cid:6)g(δ) → ¬(cid:6)(cid:6)(cid:4) \ {δ}(cid:7)(cid:7)(cid:7).⇒g αδ∈(cid:4)However, all of the following five statements are equivalent:(i)I |(cid:26)(cid:11)(cid:6)g(δ) → ¬(cid:6)(cid:6)(cid:7)(cid:4) \ {δ}⇒g α(cid:7)(cid:7)δ∈(cid:4)(cid:11)(cid:6)(cid:6)¬(cid:4) \ {δ}(cid:7)(cid:7)⇒g α(ii)I |(cid:26)δ∈(cid:2)(cid:6)(cid:6)I |(cid:26) ¬(cid:7)(cid:4) \ {δ}(iii)(iv)I |(cid:26) ¬ ∀V ((cid:4)\{δ})∪{α}(v)I |(cid:26) ¬ ∀V ((cid:4)\{δ})∪{α}(cid:7)⇒g α(cid:10)(cid:10) (cid:11)for all δ ∈ (cid:2)(cid:6)g(σ ) → σ(cid:12)(cid:7)(cid:12)→ αfor all δ ∈ (cid:2)σ ∈((cid:4)\{δ})(cid:17)(cid:11)(cid:6)(cid:7)(cid:18)→ αfor all δ ∈ (cid:2)(cid:2) \ {δ}where the first and last steps are correct because I represents (cid:2) via g.(cid:9)Since ((cid:2) \ {δ}) ⊆ ((cid:4) \ {δ}), all propositional symbols in((cid:2) \ {δ}) → α are quantified upon through ∀V ((cid:4)\{δ})∪{α}. Hence,(cid:9))((cid:2) \ {δ}) → α is invalid in propositional logic, or, equivalently, iff (cid:2) \ {δ} (cid:7)(cid:5) α. In other words, condition (4(cid:9)(v) holds ifffrom Proposition 1 is satisfied iff (v) holds, i.e., iff (i) holds. (cid:3)P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231415We now consider the following example in order to compare the functioning of the third condition of Definition 15 witha simpler alternative that, whilst plausible, does not behave as required. In fact, consider one replaces(cid:11)(cid:6)g(δ) → ¬(cid:6)(cid:6)(cid:7)(cid:4) \ {δ}⇒g α(cid:7)(cid:7)in arg(g, (cid:4), α) by ¬(cid:6)(cid:6)(cid:4) \ {δ}(cid:7)(cid:7).⇒g αδ∈(cid:4)We observe the following problem.Example 13. Let (cid:4) = {p, q}, let α be p, and let g((cid:4)) = {g p, gq}. So the original version of the third condition in Definition 15gives the following(cid:6)(cid:6)(cid:7)(cid:7)(cid:6)g p → ¬∀p∀q(gq → q) → p∧gq → ¬∀p∀q(cid:6)(g p → p) → p(cid:7)(cid:7).We evaluate this with the following interpretations getting the answers we expect for the QBF in each case.I1 = ∅I2 = {g p}I3 = {gq}I4 = {g p, gq}therefore the QBF is truetherefore the QBF is truetherefore the QBF is truetherefore the QBF is false.Now consider the alternative (incorrect) version of the definition which gives the following(cid:6)(cid:6)(cid:7)(cid:7)(cid:6)(cid:6)¬∀p∀q(gq → q) → p∧¬∀p∀q(g p → p) → p(cid:7)(cid:7).We evaluate this with the following interpretations which shows that we fail to get answer we expect for the QBF with I2.I1 = ∅I2 = {g p}I3 = {gq}I4 = {g p, gq}therefore the QBF is truetherefore the QBF is falsetherefore the QBF is truetherefore the QBF is false.With the encoding from Definition 15 at hand, we can decide a number of typical decision problems, e.g., questionwhether given (cid:3)(cid:2), α(cid:4), is (cid:3)(cid:2), α(cid:4) an argument? A more general variant of this question is as follows: Given (cid:4) and disjointof (cid:4), does there exist an argument (cid:3)(cid:2), α(cid:4), such that (cid:4)+ ⊆ (cid:2) and (cid:2) ∩ (cid:4)− = ∅?subsets (cid:4)+and (cid:4)−Definition 16. Let g be a generator function and (cid:4)+, (cid:4)− ⊆ (cid:4). Then, we define as an abbreviationfix(g, (cid:4)+, (cid:4)−) =g(δ) ∧¬g(δ).(cid:11)(cid:11)δ∈(cid:4)+δ∈(cid:4)−and (cid:4)−, a generator function g, and a formula α, there exists an argument (cid:3)(cid:2), α(cid:4) suchCorollary 1. Given (cid:4), two disjoint sets (cid:4)+that (cid:4)+ ⊆ (cid:2) and (cid:2) ∩ (cid:4)− = ∅ iff(cid:6)∃g((cid:4))fix(g, (cid:4)+−, (cid:4)(cid:7)) ∧ arg(g, (cid:4), α)(6)is true.Obviously, by setting (cid:4)+ = (cid:2) and (cid:4)− = (cid:4) \ (cid:2) in (6), we can answer the question given (cid:3)(cid:2), α(cid:4), is (cid:3)(cid:2), α(cid:4) an argument?In this setting, we shall also write fix(g, (cid:2)) instead of fix(g, (cid:4)+, (cid:4)−). Another question is whether a certain element δ ∈ (cid:4)is part of a support for α. For this, we can set (cid:4)+ = {δ} and (cid:4)− = ∅ in (6). Finally, if we drop the fix(g, (cid:4)+, (cid:4)−) conjunct,i.e., we set (cid:4)+ = (cid:4)− = ∅ in (6), then our encoding is true iff there is a subset (cid:2) of (cid:4) such that (cid:3)(cid:2), α(cid:4) is an argument.Next, we show how to use two different generator functions g1 and g2 to characterise subsets of (cid:4) simultaneously; infact, this module allows us to derive the supports of undercuts.Definition 17. For a knowledge base (cid:4) and generator functions g1, g2, define(cid:11)(cid:12)(cid:10)(cid:6)(cid:7)suc(g1, g2, (cid:4)) = argg1, (cid:4), ¬g2(δ) → δ.δ∈(cid:4)Theorem 2. For a knowledge base (cid:4), an interpretation I , and (cid:2)1, (cid:2)2 ⊆ (cid:4), such that I represents (cid:3)(cid:2)1, (cid:2)2(cid:4) via generator functions(cid:3)g1, g2(cid:4), we have that suc(g1, g2, (cid:4)) is true under I iff ((cid:2)1, ¬(φ1 ∧ · · · ∧ φn) is an argument, where (cid:3)φ1, . . . , φn(cid:4) is the canonicalenumeration of (cid:2)2.1416P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423Proof. Since I represents (cid:2)2 via g2, it follows that, in I , g2(δ) → δ is equivalent with δ whenever δ ∈ (cid:2)2 and is equivalentwith (cid:21) whenever δ ∈ (cid:4) \ (cid:2)2. So, the next two statements are equivalent:(cid:10)(i)I |(cid:26) argg1, (cid:4), ¬(cid:17)(ii)I |(cid:26) argg1, (cid:4), ¬(cid:12)(cid:7)(cid:11)(cid:6)δ∈(cid:4)(cid:11)g2(δ) → δ(cid:18).(cid:2)2Since I represents (cid:2)1 via g1, Theorem 1 yields that (ii) holds iff (cid:3)(cid:2)1, ¬that suc(g1, g2, (cid:4)) is true in I , holds iff (cid:3)(cid:2)1, ¬(cid:2)2(cid:4) is an argument. (cid:3)(cid:9)(cid:9)(cid:2)2(cid:4) is an argument. Therefore, (i), which meansCorollary 2. For a knowledge base (cid:4), a formula α, an interpretation I , and (cid:2)1, (cid:2)2 ⊆ (cid:4), such that I represents (cid:3)(cid:2)1, (cid:2)2(cid:4) via (cid:3)g1, g2(cid:4),we have thatarg(g2, (cid:4), α) ∧ suc(g1, g2, (cid:4))is true under I iff (cid:3)(cid:2)2, α(cid:4) is an argument and (cid:2)1 ∈ UndercutSupports((cid:3)(cid:2)2, α(cid:4)).3.2. Argument trees with fixed structureWe now show how to characterise trees via their tuple form using QBFs. We start with encodings where the treestructure is fixed via a given parent function, but the nodes of the tuple form can be arbitrarily characterised by assignmentsto the atoms from generator functions. In other words, given a parent function p over k and a formula α, we characterise allsequences A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), such that (cid:3)α, A, p(cid:4) is a tuple form. We then refine these encodings to obtain all such sequencesA, such that the tuple form (cid:3)α, A, p(cid:4) represents a (complete) argument tree. Note that in the forthcoming encodings, wecomes together with p as an input. The aim of the forthcoming module is to ensure that p correctlyalso assume that papplies to the sequence A, in such a way that p does not lead to duplicate children notes (as required in Definition 9).∗Definition 18. For a knowledge base (cid:4), a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), and a parent function p over k,we definedistinct(G, (cid:4), p) =(cid:11)(cid:10) (cid:11)¬(cid:12)gi(δ) ↔ g j(δ).i, j: p(i)=p( j);i(cid:7)= jδ∈(cid:4)Lemma 5. For a knowledge base (cid:4), a parent function p over k, and an interpretation I representing A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G =(cid:3)g1, . . . , gk(cid:4), we have that distinct(G, (cid:4), p) is true under I iff p is a parent function for A.Proof. (Only if direction) If distinct(G, (cid:4), p) is true in I then for all two distinct i and j (each in the range 1..k) wherep(i) = p( j), there must exist δ(cid:9) ∈ (cid:4) such that gi(δ(cid:9)) ↔ g j(δ(cid:9)) is false in I . So, I |(cid:26) gi(δ(cid:9)) ∧ ¬g j(δ(cid:9)) or I |(cid:26) ¬gi(δ(cid:9)) ∧ g j(δ(cid:9)).The cases are symmetric, so it is enough to consider the former: I |(cid:26) gi(δ(cid:9)) ∧ ¬g j(δ(cid:9)). Since gi(δ(cid:9)) and g j(δ(cid:9)) are atoms,it then follows that gi(δ(cid:9)) ∈ I and g j(δ(cid:9)) /∈ I . Therefore, g j(δ(cid:9)) /∈ I ∩ g j((cid:4)) whereas gi(δ(cid:9)) ∈ I ∩ gi((cid:4)) (as gi(δ(cid:9)) ∈ gi((cid:4)) dueto δ(cid:9) ∈ (cid:4)). However, I represents A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G = (cid:3)g1, . . . , gk(cid:4) meaning that I ∩ gi((cid:4)) is gi((cid:2)i) and I ∩ g j((cid:4)) isg j((cid:2)i) (Definition 13). Whence gi(δ(cid:9)) ∈ gi((cid:2)i) and g j(δ(cid:9)) /∈ g j((cid:2) j). I.e., gi(δ(cid:9)) ∈ {gi(δ) | δ ∈ (cid:2)i} and g j(δ(cid:9)) /∈ {g j(δ) | δ ∈ (cid:2) j}(cf. Definition 12). As an immediate consequence, δ(cid:9) /∈ (cid:2) j . On the other hand, gi(δ(cid:9)) ∈ {gi(δ) | δ ∈ (cid:2)i} implies δ(cid:9) ∈ (cid:2)i becausegi is injective according to Definition 12. Now, δ(cid:9) /∈ (cid:2) j together with δ(cid:9) ∈ (cid:2)i yields (cid:2)i (cid:7)= (cid:2) j .(If direction) We must show that distinct(G, (cid:4), p) is true in I . In fact, we show that, for any two distinct i and j(each in the range 1..k) such that p(i) = p( j), then gi(δ(cid:9)) ↔ g j(δ(cid:9)) is false in I for some δ(cid:9) ∈ (cid:4). To start with, (cid:2)i (cid:7)= (cid:2) jbecause p is a parent function for A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4). Trivially, there then exists δ(cid:9) ∈ (cid:4) such that either δ(cid:9) ∈ (cid:2)i and δ(cid:9) /∈ (cid:2) jor δ(cid:9) /∈ (cid:2)i and δ(cid:9) ∈ (cid:2) j . The cases are symmetric, so it is enough to consider the former. From δ(cid:9) /∈ (cid:2) j , we easily getg j(δ(cid:9)) /∈ {g j(δ) | δ ∈ (cid:2) j}, which, by Definition 12, means g j(δ(cid:9)) /∈ g j((cid:2) j). That is, g j(δ(cid:9)) /∈ I ∩ g j((cid:4)) because I representsA = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G = (cid:3)g1, . . . , gk(cid:4) (cf. Definition 13). In view of g j(δ(cid:9)) ∈ g j((cid:4)) (due to δ(cid:9) ∈ (cid:4)), it then follows thatg j(δ(cid:9)) /∈ I . On the other hand, δ(cid:9) ∈ (cid:2)i . So, gi(δ(cid:9)) ∈ {gi(δ) | δ ∈ (cid:2)i} = gi((cid:2)i). Then, gi(δ(cid:9)) ∈ I ∩ gi((cid:4)) because I representsA = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G = (cid:3)g1, . . . , gk(cid:4) (cf. Definition 13). So, gi(δ(cid:9)) ∈ I . Combined with g j(δ(cid:9)) /∈ I as proven above, thisyields I (cid:7)|(cid:26) gi(δ(cid:9)) ↔ g j(δ(cid:9)). (cid:3)Given a parent function p, we now know how to characterise sequences A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via QBFs, such that, p is aparent function for A. Thus, we can already obtain all tuple forms (cid:3)α, A, p(cid:4), for a given p. Next, we add further conditionsto get only those A, such that (cid:3)α, A, p(cid:4) represents also an argument tree.Definition 19. For a knowledge base (cid:4), a formula α, a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), and a parentfunction p over k, we defineP. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231417argtree(G, α, (cid:4), p) = arg(g1, (cid:4), α) ∧k(cid:11)(cid:6)(cid:7)suc(gi, g p(i), (cid:4))∧i=2k(cid:11)(cid:10)(cid:19)(cid:11)(cid:12)¬g j(δ).gi(δ) ∧i=2δ∈(cid:4)j∈p∗(i)Theorem 3. For a knowledge base (cid:4), an interpretation I , and a tuple form (cid:3)α, A, p(cid:4), such that I represents A via generator functions Gwe have that the QBFdistinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p)is true under I iff (cid:3)α, A, p(cid:4) represents an argument tree.Proof. By Lemma 5 and the fact that (cid:3)α, A, p(cid:4) is a tuple form (see item 3 in Definition 9), distinct(G, (cid:4), p) is true under I .So, we need only focus on argtree(G, α, (cid:4), p).tree iffLemma 2 states thatrepresent an argument(cid:3)α, A, p(cid:4)is an argument, and (ii) (cid:2)i ∈UndercutSupports( A(p(i))) for 1 < i (cid:3) k, and (iii) (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i)∪ · · · ∪ (cid:2)pn(i)=1 for 1 < i (cid:3) k. We show that each of(i)–(iii) holds iff the corresponding conjunct in argtree(G, α, (cid:4), p) is true under I . By Theorem 1, (i) holds iff arg(g1, (cid:4), α),namely the first conjunct in argtree(G, α, (cid:4), p), is true under I . Let us turn to (ii). In fact, (cid:2)i ∈ UndercutSupports( A(p(i)))(cid:2)p(i)(cid:4) is an argument iff suc(gi, g p(i), (cid:4)),means that (cid:3)(cid:2)i, ¬namely the second conjunct in argtree(G, α, (cid:4), p), is true under I . Let us turn to (iii). Trivially, (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i)∪ · · · ∪(cid:2)pn(i)=1 means that there exists δ(cid:9) ∈ (cid:2)i such that δ(cid:9) /∈ (cid:2)p(i) ∪ (cid:2)p2(i)∪ · · · ∪ (cid:2)pn(i)=1. Since I represents A via G, for all∪ · · · ∪ (cid:2)pn(i)=1 iff for some δ(cid:9)j = 1..k, Definition 13 tells us that g j(δ(cid:9)) is true under I iff δ(cid:9) ∈ (cid:2) j . Then, (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i),gi(δ(cid:9)) is true under I while g p(i)(δ(cid:9)), g p2(i)(δ(cid:9)), . . . , g pn(i)=1(δ(cid:9)) are all false under I . So, (cid:2)i (cid:7)⊆ (cid:2)p(i) ∪ (cid:2)p2(i)∪ · · · ∪ (cid:2)pn(i)=1 iff(cid:2)p(i)(cid:4) is an undercut of (cid:3)(cid:2)p(i), . . .(cid:4). By Theorem 2, (cid:3)(cid:2)i, ¬(cid:3)(cid:2)1, α(cid:4)(cid:9)(cid:9)(i)(cid:10)(cid:19)(cid:11)gi(δ) ∧¬g j(δ)(cid:12)δ∈(cid:4)j∈p∗(i)is true under I . (cid:3)Our next definition captures the condition that for a sequence of generator functions G, and for each argument thatcan be represented via a generator function gi in G, if there is an undercut for it that can be represented by a generatorfunction g, then g is also in G.Definition 20. For a knowledge base (cid:4), a parent function p over k, a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), anda further generator function g, we definecomplete(G, (cid:4), p) =(cid:10)∀g((cid:4))suc(g, gi, (cid:4)) →k(cid:11)i=1(cid:19)(cid:11)(cid:6)(cid:7)g(δ) ↔ g j(δ)(cid:12).j:p( j)=iδ∈(cid:4)Theorem 4. For a knowledge base (cid:4), an interpretation I , and a tuple form (cid:3)α, A, p(cid:4), such that I represents A via generator functionsG we have that the QBFdistinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p) ∧ complete(G, (cid:4), p)is true under I iff (cid:3)α, A, p(cid:4) represents a complete argument tree.Proof. By Theorem 2, suc(g, gi, (cid:4)) is true under I iff (cid:3)(cid:8), ¬(cid:2)i(cid:4) is an argument ((cid:8) is taken to denote the set that grepresents under I ), or, equivalently, (cid:3)(cid:8), . . .(cid:4) is an undercut of (cid:3)(cid:2)i, . . .(cid:4). Since I represents A via G, Definition 13 meansthat g j(δ) is true under I iff δ ∈ (cid:2) j . Therefore, g(δ) ↔ g j(δ) is true under I iff (cid:8) = (cid:2) j . So, complete(G, (cid:4), p) is true underI iff for each 1 (cid:3) i (cid:3) k and for each (cid:8) ∈ UndercutSupports( A(i)), there exists an index j ∈ {1..k} such that (cid:2) j = (cid:8) andp( j) = i. Then, apply Lemma 2 and Theorem 3. (cid:3)(cid:9)As already shown for single arguments, we can use now the fix(g, (cid:2)) module to encode further decision problems. Inour first example (given in Corollary 3), we can ensure that the argument tree has a particular argument as the root of thetree.1418P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423Corollary 3. For a knowledge base (cid:4), (cid:8) ⊆ (cid:4), an interpretation I , and a tuple form (cid:3)α, A, p(cid:4), such that I represents A via generatorfunctions G we have that the QBFfix(g1, (cid:8)) ∧ distinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p)is true under I iff (cid:3)α, A, p(cid:4) represents an argument tree with root ((cid:8), α).As a further example, we can check whether a given tuple form (cid:3)α, A, p(cid:4) with A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via QBFs, represents anargument tree. To this end let, G((cid:4)) =(cid:8)ki=1 gi((cid:4)).Corollary 4. A tuple form (cid:3)α, (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), p(cid:4) represent an argument tree iff the closed QBF(cid:21)fix(gi, (cid:2)i) ∧ distinct(G, (cid:4), p) ∧ argtree(G, α, (cid:4), p)(cid:20)k(cid:11)i=1∃G((cid:4))is true.Likewise, we can apply these two corollaries to complete argument trees by adding the conjunct complete(G, (cid:4), p)accordingly.3.3. Argument trees with arbitrary structureCompared to the previous characterisation, we now shall not only compute the sequence A for a tuple form (cid:3)α, A, p(cid:4)with given p, but also possible parent functions p via the encodings. Hence, we first have to represent functions p as well∗|as its closure pi, j1 (cid:3) j < i (cid:3) k}. Intuitively, if an atom pi, j is true under I , then I is used to characterise a parent function p with p(i) = j.To show how this can be done, we first need a weaker notion than a parent function. We sometimes also regard a parentfunction over k as a binary relation over {1, . . . , k} satisfying the restrictions in the following definition.. Given a parent function p over k, we use further new atoms P k = {pi, j | 1 (cid:3) j < i (cid:3) k} and P= {p∗k∗Definition 21. For k = 1, let p = ∅, and for k > 1, let p ⊆ {2..k} × {1..k} be a relation where (i, j) ∈ p implies j < i.We say that an interpretation I represents p via P k iff, for all 1 (cid:3) j < i (cid:3) k, pi, j ∈ I iff (i, j) ∈ p.The forthcoming propositional encoding has those interpretations as its models which represent relations (according toDefinition 21) satisfying the requirement for being a parent functions (according to Definition 9).Definition 22. For any k (cid:2) 1, definepreparent(P k) =k(cid:11)i−1(cid:19)pi, j ∧(cid:20)k(cid:11)i−1(cid:11)i=2j=1i=3j=2pi, j →(cid:21)¬pi,l.j−1(cid:11)l=1Example 14. Consider k = 4. There are six possible trees (i.e., realizations of a parent relation p according to Definition 9)that can be formed from 4 nodes. These can be represented by the following six options:Option 1 p(4) = 3,Option 2 p(4) = 3,Option 3 p(4) = 1,Option 4 p(4) = 2,Option 5 p(4) = 2,Option 6 p(4) = 1,p(3) = 2,p(3) = 1,p(3) = 2,p(3) = 1,p(3) = 2,p(3) = 1,p(2) = 1p(2) = 1p(2) = 1p(2) = 1p(2) = 1p(2) = 1.By Definition 22, formula preparent(P 4) is as followsp2,1 ∧ (p3,2 ∨ p3,1) ∧ (p4,3 ∨ p4,2 ∨ p4,1) ∧ (p3,2 → ¬p3,1) ∧ (p4,2 → ¬p4,1) ∧ (p4,3 → ¬p4,1 ∧ ¬p4,2).Note that (p4,3 → ¬p4,1 ∧ ¬p4,2) implies (p4,3 → ¬p4,1) and (p4,3 → ¬p4,2). Hence, by contraposition, we get (p4,1 →¬p4,3) and (p4,2 → ¬p4,3), and thereby get the constraints we require on the relation p to form a parent function.Lemma 6. Let p ⊆ {2..k} × {1..k} be a relation where (i, j) ∈ p implies j < i, and I be an interpretation, such that I represents p viaatoms P k. Then, the formula preparent(P k) is true under I iff p is a parent function over k.P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231419Proof. Since p is such that (i, j) ∈ p implies j < i, the lemma holds iff preparent(P k) expresses that p is a function. In viewof Definition 21, that every i in {2..k} has an image by p is expressed byI |(cid:26)k(cid:11)i−1(cid:19)i=2j=1pi, j.That i in {2..k} only has one image by p can be expressed as follows: if (i, j) ∈ p then for all l (cid:7)= j, (i, l) /∈ p. Since (i, l) ∈ pimplies l < i, this test is only necessary for i in {3..k} (observe that (2, 1) always is in p for k > 1 and there is no otherj such that (i, j) ∈ p holds, it is enough to focus on (i, l) /∈ p for allpossibility). Moreover, since the test is checked for alll < j. Finally, it is sufficient that j ranges from 2 to i − 1. In view of Definition 21, this amounts toI |(cid:26)(cid:20)k(cid:11)i−1(cid:11)i=3j=2pi, j →j−1(cid:11)l=1(cid:21)¬pi,l.(cid:3)Next, we show how to suitably characterise the closure p∗(cf. Definition 11) of a parent function p.Definition 23. For any k (cid:2) 1, defineclosure(P k, P∗k ) =(cid:20)k(cid:11)i−1(cid:11)i=2j=1(cid:20)∗i, jp↔pi, j ∨i−1(cid:19)(cid:21)(cid:21)(pi,l ∧ p∗l, j).l= j+1Lemma 7. Let p be a parent function over k and q ⊆ {2..k} × {1..k} a relation where (i, j) ∈ q implies j < i. Moreover, let I be an∗(i) = { j | q(i, j)} for i = 2..k.interpretation representing p via P k and q via P∗k . Then, the formula closure(P k, P∗k ) is true under I iff pProof. By Definition 21, closure(P k, P(cid:22)q(i, j) ⇔p(i, j), orp(i, l) and q(l, j)∗k ) is, under I , equivalent, for i = 2..k and j = 1..i − 1, tofor some l ∈ { j + 1, . . . , i − 1}which, by virtue of p being a parent function and q being such that (i, j) ∈ q implies j < i, amounts to(cid:22)q(i, j) ⇔p(i, j), orp(i, l) and q(l, j)for some l ∈ {1, . . . , k}which is known to characterise the transitive closure of p (taken as a relation) provided that p has a finite domain and isacyclic but both points are obvious here. (cid:3)Example 15. Consider k = 4 as in Example 14. One possible parent function was p(4) = 3, p(3) = 2, p(2) = 1. We use atoms∗P 4 = {p2,1, p3,1, p4,1, p3,2, p4,2, p4,3} and likewise P4 . Any interpretation I which assigns true to p2,1, p3,2, p4,3, and false∗4) under such I . Into p3,1, p4,1, and p4,2 represents the above parent function p via P 4. Let us now evaluate closure(P 4, P∗∗fact, we then expect that only those I are models of closure(P 4, P4) which assign true to all atoms in P4 . By definition, Ithen represents p(according to Definition 11) via P∗4 . Observe that we have∗closure(P 4, P∗4) = (p(cid:6)p(p(cid:6)(cid:6)pp(p∗2,1∗3,1∗3,2∗4,1∗4,2∗4,3↔ p2,1) ∧(cid:6)↔p3,1 ∨ (p3,2 ∧ p(cid:7)(cid:7)∗2,1)∧↔ p3,2) ∧(cid:6)↔p4,1 ∨ (p4,2 ∧ pp4,2 ∨ (p4,3 ∧ p(cid:6)↔↔ p4,3).(cid:7)(cid:7)∗3,1)∧∗2,1) ∨ (p4,3 ∧ p∗∧3,2)(cid:7)(cid:7)(7)(8)(9)(10)(11)(12)Recall that we consider I assigning true to p2,1, p3,2, p4,3; conjuncts (7), (9), and (12) thus require that palso assigned to true by a model I of closure(P 4, P∗I . Similarly for line (10), we already know that p3,1 and p4,3 are true in I , and we can conclude that also pFinally, (11) forces also ptrue in I .∗∗∗3,2, p4,3 are2,1, p∗∗3,1 is true in2,1 and p3,2 in I . Thus by line (8) also p∗4,1 is true in I .∗3,2 are∗4,2 to be true in I as well, since we already have seen that for a model I also p4,3 and p∗4). Now we have p1420P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423We are now ready to relate interpretations to parent functions in combination with sequences A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4). Forthis, we have to guarantee that models represent parent functions (this is done with the already introduced conjunctpreparent(P k)) and that the represented parent function correctly relates to a represented sequence A avoiding duplicatechildren (in a way that is similar to what we did in Definition 18 for the module distinct(G, (cid:4), p)). The latter task is realizedvia the second conjunct in the forthcoming definition.Definition 24. For a knowledge base (cid:4), and a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), definej−1(cid:11)i−1(cid:11)k(cid:11)(cid:11)(cid:12)(cid:10)parent(G, (cid:4), P k) = preparent(P k) ∧(pi,l ∧ p j,l) → ¬(cid:6)(cid:7)gi(δ) ↔ g j(δ).i=3j=2l=1δ∈(cid:4)Lemma 8. For a knowledge base (cid:4), and an interpretation I representing A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G, and a relation p via P k, we havethat parent(G, (cid:4), P k) is true under I iff p is a parent function for A.Proof. We already know from Lemma 6 that preparent(P k) is true under I iff p (represented by I ) is a parent function(over k). We thus need to show that the remaining part of parent(G, (cid:4), P k) is true under I iff p is a parent function forA = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4), that is, p(i) = p( j) implies (cid:2)i (cid:7)= (cid:2) j , for any 1 < j < i (cid:3) k (in fact, it is sufficient to use 2 < j < i (cid:3) k, sincethe root has obviously no parent node). Since I also represents A (via G = (cid:3)g1, . . . , gk(cid:4)), we have (cid:2)i (cid:7)= (cid:2) j iff there existssome δ ∈ (cid:4) such that gi(δ) ↔ g j(δ) is false in I . This holds iff ¬δ∈(cid:4)(gi(δ) ↔ g j(δ)) is true under I . Since we performthis test for each pair of children A(i), A( j) of each node A(l) in the annotated tree (represented by I ), the claim followsby the same arguments as used to show Lemma 5. (cid:3)(cid:9)Definition 25. For a knowledge base (cid:4), a formula α, and a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), we defineargtree(G, α, (cid:4), P k, P∗k ) = arg(g1, (cid:4), α) ∧i−1(cid:11)(cid:6)k(cid:11)(cid:7)pi, j → suc(gi, g j, (cid:4))∧i=2k(cid:11)j=1(cid:19)(cid:20)i=2δ∈(cid:4)gi(δ) ∧i−1(cid:11)(cid:6)j=1(cid:7)→ ¬g j(δ)∗i, jp(cid:21).Theorem 5. For a knowledge base (cid:4), a formula α, and an interpretation I , representing a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G, and arelation p via P k we have that the QBFAT(G, (cid:4), P k) = parent(G, (cid:4), P k) ∧ ∃Pis true under I iff (cid:3)α, A, p(cid:4) represents an argument tree.(cid:6)∗kclosure(P k, P∗k ) ∧ argtree(G, α, (cid:4), P k, P(cid:7)∗k )Proof. We only give a sketch here, since we already know the following properties:• By Lemma 8, I represents a parent function for A iff parent(G, (cid:4), P k) is true under I ;• By Lemma 7, given an interpretation I representing a parent function p (over k) via P k, I represents the transitiveclosure of p via P∗k iff closure(P k, P∗k ) is true under I ;• Formula argtree(G, α, (cid:4), P k, P∗k ) follows the same structure from Definition 19 but instead of using the functions p, p∗k of variables. Using this observationexplicitly, we represent them (see Definition 25) by the respective sets P k and P∗k (as done in the proofs above) with the structure of the proofand by suitably combining the techniques for P k and Pof Theorem 3, one can show the following relation: Given (cid:4), α, and an interpretation I representing A via G, a parent∗function p for A via P k, and the transitive closure of p, i.e. pk , we have that (cid:3)α, A, p(cid:4) represents an argumenttree iff argtree(G, α, (cid:4), P k, P∗k ) is true under I ., via P∗∗∗From the latter observation and the semantics of the existential quantifier, the claim holds. Note that we used ∃Pk just to“hide” the variables representing the transitive closure of the parent function from the user, since it is not an explicit partof the requested problem, but rather an internal detail which is fully determined by p. (cid:3)Definition 26. For a knowledge base (cid:4), a sequence of generator functions G = (cid:3)g1, . . . , gk(cid:4), and a further generator func-tion g, we definecomplete(G, (cid:4), P k) =k(cid:11)i=1(cid:20)∀g((cid:4))suc(g, gi, (cid:4)) →(cid:10)i−1(cid:19)j=1pi, j ∧(cid:11)(cid:6)δ∈(cid:4)(cid:7)g(δ) ↔ g j(δ)(cid:12)(cid:21).P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231421Theorem 6. For a knowledge base (cid:4), a formula α, and an interpretation I , representing a sequence A = (cid:3)(cid:2)1, . . . , (cid:2)k(cid:4) via G, and arelation p over P k we have that the QBFCAT(G, (cid:4), P k) = parent(G, (cid:4), P k) ∧ ∃P(cid:6)∗kclosure(P k, P∗k ) ∧ argtree(G, α, (cid:4), P k, P(cid:7)∗k ) ∧ complete(G, (cid:4), P k)is true under I iff (cid:3)α, A, p(cid:4) represents a complete argument tree.The proof of Theorem 6 is similar to the proof for Theorem 4 except that at the end, Theorem 5 instead of Theorem 3 isrequired.Again, we now can decide different decision problems by using above concepts plus fixing some of the concepts. Aninteresting question is as follows: Given α and A, does there exist an argument tree (a complete argument tree) usingsets A? In other words, can we find a parent function p, such that (cid:3)α, A, p(cid:4) represents an argument tree (a completeargument tree)?Corollary 5. Given A = (cid:2)1, . . . , (cid:2)k and a formula α, there exists a parent function p, such that (cid:3)α, A, p(cid:4) represents1. an argument tree iff the closed QBF(cid:21)fix(gi, (cid:2)i) ∧ AT(G, (cid:4), P k)2. a complete argument tree iff the closed QBF(cid:20)(cid:21)fix(gi, (cid:2)i) ∧ CAT(G, (cid:4), P k)(cid:20)k(cid:11)i=1k(cid:11)i=1∃P k∃G((cid:4))is true;∃P k∃G((cid:4))is true.3.4. RemarksWe give a few remarks concerning the actual size of the encodings provided in the previous sections compared to thesize of the encoded problem.First, we address the number of additional atoms (mostly stemming from the generator functions g) required in theencodings. For the encodings given in Section 3.1, note that we require a new atom for each formula in (cid:4). Hence, if thecardinality of (cid:4) is n, we need n new atoms for most of the encodings in that section, with the exception of the encodingswhere suc(·) is involved where we used two generator functions g1, g2 resulting in 2n new atoms. For the encodings inSection 3.2, where we used tuple forms of length k to represent trees with k nodes, also the size of the tree comes into play.One can check that the number of additional atoms required for the encodings in that section is bound by n(k + 1). Finally,encodings of argument trees with arbitrary structure (Section 3.3) require a much higher number of additional atoms due to∗k of atoms. Note that these sets are of cardinality k(k − 1)/2.the task of representing the tree structure via further sets P k, PTogether with the atoms stemming from the generator functions, we get here a need for n(k + 1) + k2 new atoms.Concerning the size of the encodings, we just mention that the size is linear in the size of (cid:4) for the encodings inSection 3.1. For the more involved encodings in Sections 3.2 and 3.3, the size of the encodings is at most quadratic in thesize of (cid:4) and the size of tree.However, both the theoretical point of view as well as practical experience tell us that the nesting depth of alternatingquantifiers is the most crucial parameter for evaluating QBFs, although the parameters of formula size and number of atomscannot be ignored. We recall that for all our encodings this nesting depth is fixed and independent of the size of (cid:4) orthe size of the considered argument tree. In fact, one can check that there are at most two quantifier alternations at eachbranch of a formula tree associated with our encodings.As a final remark, we mention that the number of new atoms has to be increased if one wants to employ QBF solverswhich rely on inputs in certain normal forms. Here, the transformation to such a normal form further introduces new atoms.Most of the current QBF solvers (see [28]) require such a normal form, but there are also solvers (e.g. [21]) which can beapplied to the encodings directly (modulo some transformation steps which do not introduce new atoms).4. DiscussionThere is increasing interest in formalisations for argumentation, and in particular computational models of argument(see for example [4,6,8,13,17,31]). In this paper, we have addressed this issue in the context of argumentation with classicallogic as the underlying logic by providing encodation in terms of quantified Boolean formulae. This approach is beneficialwith respect to several aspects.1422P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–1423First, it offers the possibility of implementing decision procedures for argumentation based on classical logic using exist-ing QBF solvers.Second, it allows to obtain novel complexity results for interesting decision problems associated with logic-based argu-mentation. Indeed, while for abstract argumentation, there has been a comprehensive analysis of computational complexityof some of the key decision problems (in particular [16]), there are only a few published results concerning computationalcomplexity of logic-based argumentation. In [29], for instance, it is shown that given a knowledge-base (cid:4) and a formula α,ascertaining whether there is a (cid:2) ⊆ (cid:4) such that (cid:3)(cid:2), α(cid:4) is an argument (i.e. (cid:2) is a minimal consistent set of premises entail-ing α) is a (cid:5) p2 -complete decision problem. Our results can be employed to obtain similar results for more involved decisionproblems. In fact, since all encodings are constructible in polynomial time with respect to the size of the problem descrip-tion, inspecting the quantifier structure of the encodings and applying Proposition 4 immediately yields upper complexitybounds for the encoded problems. For instance, this shows that several decision problems formulated for argumentationtrees remain located in (cid:5) p2 -completeness forthose decision problems over argumentation trees is expected. However, if complete argumentation trees are taken into ac-count, our encodings indicate that this leads to an increasing complexity, having such problems located in (cid:5) p3 . Establishingexact complexity results for numerous decision problems in logic-based argumentation is indeed part of our ongoing work.In another approach to deductive argumentation, Wooldridge et al. [34] show that by taking a “maximal" set of argu-ments (i.e. a set of arguments that does not include “equivalent" arguments), they can treat the set of arguments as anabstract argument system with the attack relation holding between a pair of arguments A and Awhen A is a defeaterof A. This means that the abstract argument system can be evaluated using the notions of acceptability defined by Dung[14]. This offers a different way of assembling and evaluating arguments to that considered in this paper. Furthermore, theyprovide complexity results concerning the identification of the “maximal" sets of arguments.2 . Since the evaluation of a single argument is already hard for this class, (cid:5) p(cid:9)(cid:9)Finally, our results are useful for comparing different approaches to argumentation. In fact, there is increasing interestin algorithms and implementations for argumentation systems including for abstract argumentation systems [2,11,12,32],for assumption-based argumentation systems [15,25,27], for logic-based argumentation systems based on defeasible logic[9,10,26,33], and for logic-based argumentation systems based on classical logic [18]. Undertaking empirical evaluationsthat compare these algorithms is difficult because of the diverse approaches taken in implementing them. So undertakingevaluations via encodations as QBFs offers the opportunity for a level playing field for comparisons that draw out thestrengths and weaknesses of each of the algorithms and their underlying reasoning mechanisms. In particular, comparisonswith QBF encodings for other argumentation formulations [22] or, encodings in terms of classical logic for nonmonotonicformalisms in general [3,19] are now enabled.AcknowledgementsThis work was supported by the Vienna Science and Technology Fund (WWTF) under grant ICT08-028.References[1] L. Amgoud, C. Cayrol, A model of reasoning based on the production of acceptable arguments, Annals of Mathematics and Artificial Intelligence 34(2002) 197–216.[2] P. Baroni, M. Giacomin, Argumentation through a distributed self-stabilizing approach, Journal of Experimental and Theoretical Artificial Intelli-gence 14 (4) (2002) 273–301.[3] R. Ben-Eliyahu, R. Dechter, Default reasoning using classical logic, Artificial Intelligence 84 (1–2) (1996) 113–150.[4] T. Bench-Capon, P. Dunne, Argumentation in artificial intelligence, Artificial Intelligence 171 (10–15) (2007) 619–641.[5] S. Benferhat, D. Dubois, H. Prade, Argumentative inference in uncertain and inconsistent knowledge bases, in: Proceedings of the 9th Annual Conferenceon Uncertainty in Artificial Intelligence (UAI 1993), Morgan Kaufmann, 1993, pp. 411–419.[6] Ph. Besnard, S. Doutre, A. Hunter (Eds.), Computational Models of Argument: Proceedings of COMMA 2008, IOS Press, 2008.[7] Ph. Besnard, A. Hunter, A logic-based theory of deductive arguments, Artificial Intelligence 128 (2001) 203–235.[8] Ph. Besnard, A. Hunter, Elements of Argumentation, MIT Press, 2008.[9] D. Bryant, P. Krause, A review of current defeasible reasoning implementations, Knowledge Engineering Review 23 (3) (2008) 227–260.[10] D. Bryant, P. Krause, G. Vreeswijk, Argue tuprolog: A lightweight argumentation engine for agent applications, in: P. Dunne, T. Bench-Capon (Eds.),Computational Models of Argumentation (COMMA 2006), IOS Press, 2006, pp. 27–31.[11] C. Cayrol, S. Doutre, J. Mengin, Dialectical proof theories for the credulous preferred semantics of argumentation frameworks, in: Quantitative andQualitative Approaches to Reasoning with Uncertainty (ECSQARU 2001), in: LNCS, vol. 2143, Springer, 2001, pp. 668–679.[12] C. Cayrol, S. Doutre, J. Mengin, On decision problems related to the preferred semantics for argumentation frameworks, Journal of Logic and Computa-tion 13 (3) (2003) 377–403.[13] C. Chesñevar, A. Maguitman, R. Loui, Logical models of argument, ACM Computing Surveys 32 (2000) 337–383.[14] P. Dung, On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games, ArtificialIntelligence 77 (2) (1995) 321–358.[15] P. Dung, R. Kowalski, F. Toni, Dialectical proof procedures for assumption-based admissible argumentation, Artificial Intelligence 170 (2006) 114–159.[16] P. Dunne, T. Bench-Capon, Coherence in finite argumentation systems, Artificial Intelligence 141 (2002) 187–203.[17] P. Dunne, T. Bench-Capon (Eds.), Computational Models of Argument: Proceedings of COMMA 2006, IOS Press, 2006.[18] V. Efstathiou, A. Hunter, Algorithms for effective argumentation in classical propositional logic, in: Proceedings of the International Symposium onFoundations of Information and Knowledge Systems (FOIKS 2008), in: LNCS, vol. 4932, Springer, 2008, pp. 272–290.[19] U. Egly, T. Eiter, H. Tompits, S. Woltran, Solving advanced reasoning tasks using quantified boolean formulas, in: Proceedings of the 17th NationalConference on Artificial Intelligence (AAAI’00), AAAI Press/MIT Press, 2000, pp. 417–422.P. Besnard et al. / Artificial Intelligence 173 (2009) 1406–14231423[20] U. Egly, M. Seidl, H. Tompits, S. Woltran, M. Zolda, Comparing different prenexing strategies for quantified boolean formulas, in: Proceedings of the6th International Conference on the Theory and Applications of Satisfiability Testing (SAT-03), Selected Revised Papers, in: LNCS, vol. 2919, 2004, pp.214–228.[21] U. Egly, M. Seidl, S. Woltran, A solver for QBFs in nonprenex form, Constraints 14 (1) (2009) 38–79.[22] U. Egly, S. Woltran, Reasoning in argumentation frameworks using quantified Boolean formulas, in: Proceedings COMMA’06, IOS Press, 2006, pp. 133–144.[23] T. Eiter, G. Gottlob, The complexity of logic-based abduction, Journal of the ACM 42 (1995) 3–42.[24] M. Elvang-Gøransson, P. Krause, J. Fox, Dialectic reasoning with classically inconsistent information, in: Proceedings of the 9th Conference on Uncer-tainty in Artificial Intelligence (UAI 1993), Morgan Kaufmann, 1993, pp. 114–121.[25] D. Gaertner, F. Toni, Computing arguments and attacks in assumption-based argumentation, IEEE Intelligent Systems 22 (6) (2007) 24–33 (special issueon argumentation technology).[26] A. García, G. Simari, Defeasible logic programming: An argumentative approach, Theory and Practice of Logic Programming 4 (1) (2004) 95–138.[27] A. Kakas, F. Toni, Computing argumentation in logic programming, Journal of Logic and Computation 9 (1999) 515–562.[28] M. Narizzano, L. Pulina, A. Tacchella, Report of the third QBF solvers evaluation, Journal of Satisfiability, Boolean Modeling and Computation 2 (2006)145–164.[29] S. Parsons, M. Wooldridge, L. Amgoud, Properties and complexity of some formal inter-agent dialogues, Journal of Logic and Computation 13 (3) (2003)347–376.[30] H. Prakken, G. Sartor, Argument-based extended logic programming with defeasible priorities, Journal of Applied Non-Classical Logics 7 (1997) 25–75.[31] H. Prakken, G. Vreeswijk, Logical systems for defeasible argumentation, in: D. Gabbay (Ed.), Handbook of Philosophical Logic, Kluwer, 2002.[32] M. South, G. Vreeswijk, J. Fox, Dungine: A java dung reasoner, in: Computational Models of Argumentation (COMMA 2008), IOS Press, 2008, pp. 360–368.[33] G. Vreeswijk, An algorithm to compute minimally grounded defence sets in argument systems, in: P. Dunne, T. Bench-Capon (Eds.), ComputationalModels of Argumentation (COMMA 2006), IOS Press, 2006, pp. 109–120.[34] M. Wooldridge, P. Dunne, S. Parsons, On the complexity of linking deductive and abstract argument systems, in: Proceedings of the Twenty FirstNational Conference on Artificial Intelligence (AAAI-06), MIT Press, 2006, pp. 299–304.[35] C. Wrathall, Complete sets and the polynomial-time hierarchy, Theoretical Computer Science 3 (1) (1976) 23–33.